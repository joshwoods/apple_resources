WEBVTT

00:00:01.180 --> 00:00:04.940
Good afternoon everybody.

00:00:04.940 --> 00:00:09.700
Welcome to Building Xsan
Application Session 622.

00:00:09.700 --> 00:00:16.580
My name is Jason Thorpe and I manage
the Xsan engineering team at Apple.

00:00:17.220 --> 00:00:19.280
First of all,
how many of you know what Xsan is?

00:00:19.330 --> 00:00:20.780
Raise your hand.

00:00:20.890 --> 00:00:22.740
Yay, that's just about everybody.

00:00:22.740 --> 00:00:24.510
So for the few of you who
didn't raise your hand,

00:00:24.560 --> 00:00:27.070
Xsan is the SAN file system for Mac OS X.

00:00:27.100 --> 00:00:31.300
SAN stands for Storage Area Network and
that's going to be kind of a key

00:00:31.300 --> 00:00:33.390
thing in my presentation here today.

00:00:33.520 --> 00:00:35.090
Remember that, Storage Area Network.

00:00:35.100 --> 00:00:39.000
So what I'm hoping you're
going to come away from this

00:00:39.000 --> 00:00:43.360
presentation with today is one,
how Xsan works, and two,

00:00:43.360 --> 00:00:48.140
the volume characteristics
that your applications are

00:00:48.140 --> 00:00:50.250
going to need to be aware of.

00:00:50.900 --> 00:00:56.100
Three, some tips on configuring your Xsan
volumes and also on how to make your

00:00:56.100 --> 00:00:59.660
applications compatible with Xsan.

00:00:59.680 --> 00:01:04.430
And also how to improve your
application's performance with Xsan.

00:01:04.920 --> 00:01:07.980
To facilitate those,
we're going to teach you about

00:01:08.040 --> 00:01:11.520
some Xsan Developer APIs and we're
also going to demonstrate setting

00:01:11.630 --> 00:01:15.900
up a simple Xsan sandbox for doing
application development with Xsan.

00:01:15.900 --> 00:01:19.510
And in the course of that,
we're going to actually show you how

00:01:19.560 --> 00:01:21.660
the Xsan Admin Application works.

00:01:22.980 --> 00:01:27.240
So let's just jump right
in and how Xsan works.

00:01:27.250 --> 00:01:30.900
So first of all,
how many people attended last

00:01:30.900 --> 00:01:32.140
year's Xsan in-depth session?

00:01:32.140 --> 00:01:33.260
Did anyone go to that?

00:01:33.260 --> 00:01:35.140
So some of this is a review.

00:01:35.140 --> 00:01:37.710
We're going to go over just
basically some file system types

00:01:37.800 --> 00:01:40.120
that you might be familiar with,
traditional file system types,

00:01:40.170 --> 00:01:44.240
the first one being
direct attached storage.

00:01:44.240 --> 00:01:45.560
This has been around for decades.

00:01:45.560 --> 00:01:48.880
It's your traditional hard drive
connected to your computer.

00:01:48.880 --> 00:01:52.780
It's a single disk that contains
both a catalog and your user data.

00:01:52.780 --> 00:01:56.700
And the file system code runs on the
single computer that accesses that data.

00:01:56.700 --> 00:01:59.720
And examples of these kinds of
file systems are HFS+ and UFS,

00:01:59.840 --> 00:02:02.890
the two really common ones in Mac OS.

00:02:03.730 --> 00:02:07.600
Next we have the network attached
storage type file systems.

00:02:07.650 --> 00:02:12.360
These solve the lack of shared
access that direct attached

00:02:12.400 --> 00:02:13.590
storage file systems have.

00:02:13.600 --> 00:02:16.600
It allows multiple computers to
share files in the file system.

00:02:16.600 --> 00:02:20.760
The way these work is they accept
high level calls from applications,

00:02:20.850 --> 00:02:23.680
transmit them over the
wire to the file server,

00:02:23.680 --> 00:02:26.860
then the file server in turn
translates those calls into basically

00:02:26.860 --> 00:02:32.600
the direct access storage system
that's connected to that file server.

00:02:32.710 --> 00:02:37.260
And examples of this type of
file system are AFP and NFS.

00:02:38.760 --> 00:02:42.200
So in contrast, a Xsan file system works
a little differently.

00:02:42.270 --> 00:02:44.300
First of all,
the disks are attached to all the

00:02:44.300 --> 00:02:46.460
computers on the Xsan via some fabric.

00:02:46.480 --> 00:02:50.730
And the most common fabric for Xsans
out there today is fiber channel.

00:02:51.330 --> 00:02:55.460
The catalog and the user data
are actually stored separately.

00:02:55.460 --> 00:03:00.390
They are stored separately so that one
process running on a dedicated machine

00:03:00.480 --> 00:03:05.790
can actually act as an arbitrator and
serialize access to that information.

00:03:05.800 --> 00:03:10.260
It basically acts as a server
that translates these high level

00:03:10.790 --> 00:03:15.600
metadata calls to block offsets
on the actual disks themselves.

00:03:15.760 --> 00:03:23.700
The kernel side file system client
on each client computer is then able

00:03:23.700 --> 00:03:29.020
to access the data directly on the
disks using the Fibre Channel Fabric.

00:03:30.000 --> 00:03:35.140
So, just to illustrate how Xsan works,
we have kind of a diagram

00:03:35.140 --> 00:03:37.500
here of a very simple SAN.

00:03:37.500 --> 00:03:43.500
We have a metadata controller,
the XServe G5 there, along with a G5 desk

00:03:43.500 --> 00:03:46.990
side as a client system.

00:03:47.090 --> 00:03:51.080
And a couple of XServe RAIDs
connected with Fibre Channel and

00:03:51.080 --> 00:03:55.960
the client and the controller are
connected via a private IP network.

00:03:56.060 --> 00:03:58.450
And then we have,
since we have two XServe RAIDs,

00:03:58.570 --> 00:04:00.990
each XServe RAID has
one controller per side.

00:04:00.990 --> 00:04:05.000
So we have four RAID LUNs, logical units.

00:04:05.000 --> 00:04:09.000
LUN1 we've configured as a RAID 1 and the
other three we've configured as RAID 5.

00:04:09.000 --> 00:04:13.700
And if you're curious why that is,
we'll get to that just in a minute.

00:04:15.110 --> 00:04:21.250
Okay, so we select one LUN to
store the metadata and we've

00:04:21.270 --> 00:04:24.590
highlighted there LUN number one.

00:04:25.550 --> 00:04:28.450
And then the controller is configured
to know that all those LUNs

00:04:28.450 --> 00:04:31.890
together are grouped into a volume.

00:04:33.360 --> 00:04:37.680
So, it's important to note that the
client side has no knowledge of

00:04:37.680 --> 00:04:39.320
the layout of the data on the disk.

00:04:39.370 --> 00:04:42.030
It doesn't know how directories work,
it doesn't know about things like

00:04:42.080 --> 00:04:43.280
inodes or anything like that.

00:04:43.290 --> 00:04:47.350
It knows that there's some disks out
there and there's some data out on

00:04:47.370 --> 00:04:49.550
them and that's all that it knows.

00:04:50.850 --> 00:04:56.560
So an application then is able to
access that data by communicating

00:04:56.560 --> 00:04:57.540
with the metadata controller.

00:04:57.610 --> 00:05:00.500
And to illustrate that,
we have a hypothetical application

00:05:00.500 --> 00:05:01.440
that's writing some data.

00:05:01.440 --> 00:05:04.620
It makes a write call to the Xsan volume.

00:05:05.500 --> 00:05:08.110
In turn,
the file system code on the client

00:05:08.110 --> 00:05:11.880
sends a message to the controller,
basically asking where is

00:05:11.880 --> 00:05:13.560
the data for this file.

00:05:14.230 --> 00:05:17.440
The controller then reads the
catalog data from the metadata

00:05:17.440 --> 00:05:19.530
LUN that we've designated,
LUN1 there.

00:05:21.300 --> 00:05:24.460
And then it responds to the client
telling it where the file lives

00:05:24.520 --> 00:05:28.400
and we call these file extents.

00:05:28.400 --> 00:05:31.820
The client then writes the
data directly to the disk.

00:05:35.100 --> 00:05:40.560
Okay, so in Xsan you group disks together
into what we call storage pools.

00:05:40.560 --> 00:05:43.000
And you do this primarily
for better performance.

00:05:43.000 --> 00:05:45.660
This is really similar
to how RAID 0 works,

00:05:45.660 --> 00:05:47.000
software RAID 0.

00:05:47.000 --> 00:05:52.610
So if you've used the Apple RAID facility
that comes in Mac OS X to put a couple of

00:05:52.670 --> 00:05:58.000
RAIDs together into a larger RAID volume,
this works very similarly.

00:05:58.000 --> 00:06:01.700
Except that instead of being handled
by a driver on the client computer

00:06:01.700 --> 00:06:04.690
itself as a block level driver,
this is actually handled

00:06:04.690 --> 00:06:06.000
by the controller.

00:06:06.000 --> 00:06:08.830
So to illustrate that,
we're going to just basically

00:06:08.830 --> 00:06:10.390
make the same call again.

00:06:11.480 --> 00:06:13.800
and the controller responds
that that file is actually split

00:06:13.800 --> 00:06:16.450
in half on two different LUNs.

00:06:17.690 --> 00:06:21.590
And then the client can write to
both of those LUNs in parallel.

00:06:21.930 --> 00:06:26.800
So this means that it actually has
two paths into the data at once.

00:06:27.240 --> 00:06:30.830
Since your Apple Fiber
Channel Controller has two ports,

00:06:30.850 --> 00:06:34.750
this allows you to actually have
two full 2 gigabit per second

00:06:34.980 --> 00:06:38.520
paths to that data at once,
doubling your bandwidth.

00:06:40.420 --> 00:06:44.660
So where the data lives is completely
transparent not only to the client

00:06:44.660 --> 00:06:46.620
but also to the application.

00:06:46.620 --> 00:06:50.080
And this abstraction allows us to
simply reconfigure the controller

00:06:50.160 --> 00:06:51.820
to add more storage to the volume.

00:06:55.180 --> 00:07:00.150
So the controller is
very important in Xsan.

00:07:00.740 --> 00:07:01.500
It happens.

00:07:01.710 --> 00:07:06.530
Hardware fails, power goes out,
someone trips over the Ethernet cable.

00:07:06.560 --> 00:07:09.280
If your controller fails,
you can set a backup controller

00:07:09.420 --> 00:07:12.430
to actually take over if
the primary should go down.

00:07:12.600 --> 00:07:16.170
The way this works is it actually
uses the journal data to actually

00:07:16.170 --> 00:07:20.600
reconstruct the state of the file system
from where the previous system failed.

00:07:20.600 --> 00:07:23.600
The clients then reestablish
any locks they might have.

00:07:23.600 --> 00:07:26.600
This whole process is very quick.

00:07:26.600 --> 00:07:29.600
The new controller can be hosting the
volume in just a matter of seconds.

00:07:29.690 --> 00:07:32.410
It's important to note that during
this time that the failover occurs,

00:07:32.410 --> 00:07:34.600
if the clients actually
know where their data lives,

00:07:34.600 --> 00:07:37.600
they can continue to stream
directly to the disk.

00:07:37.600 --> 00:07:39.600
They don't even know
the controller is gone.

00:07:39.600 --> 00:07:43.270
This is a huge difference from a
traditional file server where the

00:07:43.310 --> 00:07:47.440
controller is directly involved
with all IO to the disk themselves.

00:07:48.550 --> 00:07:51.670
Okay, so now that you have a basic
understanding of how Xsan works,

00:07:51.670 --> 00:07:54.540
let's talk about how you
actually configure it.

00:07:55.580 --> 00:07:59.430
First of all, metadata storage.

00:07:59.440 --> 00:08:03.730
The metadata is comprised of
both the catalog information,

00:08:03.860 --> 00:08:07.580
basically your directory entries and
other information about the files,

00:08:07.650 --> 00:08:12.540
as well as the file system journal
that's used to provide crash recovery and

00:08:12.550 --> 00:08:15.720
failover capability for the file system.

00:08:16.240 --> 00:08:21.700
This metadata should be
isolated from all other data.

00:08:21.700 --> 00:08:24.830
This is good for both performance
reasons and it can actually avoid

00:08:24.830 --> 00:08:29.590
some problems that can occur if
the LUN where your metadata is

00:08:29.620 --> 00:08:31.750
stored otherwise gets too full.

00:08:33.300 --> 00:08:35.250
Metadata is extremely important.

00:08:35.330 --> 00:08:39.500
If you lose your metadata,
you are going to lose your file system.

00:08:39.500 --> 00:08:43.830
For this reason,
the LUN should be redundant, so RAID 1,

00:08:43.830 --> 00:08:44.920
etc.

00:08:44.920 --> 00:08:47.960
You should have a hot spare so that
you can immediately rebuild in case

00:08:47.960 --> 00:08:49.830
one of those drives should fail.

00:08:49.970 --> 00:08:53.180
You also need to have good random
I/O performance on that LUN.

00:08:53.180 --> 00:08:56.330
That's critical for the performance
of the entire file system because

00:08:56.350 --> 00:09:00.900
metadata operations are small and
they're scattered all over the disk.

00:09:00.900 --> 00:09:03.900
So you don't want to have prefetching
turned on or anything like that.

00:09:03.900 --> 00:09:07.900
It's really key that good random
I/O performance is on that LUN.

00:09:07.900 --> 00:09:10.950
And you don't need a lot
of storage for metadata,

00:09:10.950 --> 00:09:13.900
about 10 GB per 10 million files or so.

00:09:13.900 --> 00:09:18.110
So for this reason we really like to see
people use RAID 1 for their metadata LUN.

00:09:18.110 --> 00:09:22.730
Going back to the previous slide where
we actually did that in the diagram.

00:09:24.080 --> 00:09:27.530
So for data storage, again,
you want to combine your

00:09:27.530 --> 00:09:29.800
LUNs into storage pools.

00:09:29.880 --> 00:09:32.540
This increases the
performance through striping,

00:09:32.710 --> 00:09:36.480
and again, this leverages the
multi-pathing capability that's

00:09:36.480 --> 00:09:38.270
built into Fibre Channel.

00:09:38.510 --> 00:09:41.680
But you only want to combine LUNs
with the same characteristics.

00:09:41.770 --> 00:09:45.440
If you have some LUNs that are
slow and some LUNs that are fast,

00:09:45.440 --> 00:09:47.840
you don't want to combine them
together because you're going to

00:09:47.840 --> 00:09:53.400
bring down the effective speed of
that pool to the lower speed LUNs.

00:09:53.580 --> 00:09:56.780
And you also don't want to combine
LUNs of different sizes because in

00:09:57.020 --> 00:10:00.690
order for striping to occur optimally,
what happens is that the larger

00:10:00.690 --> 00:10:04.220
LUNs will be truncated logically
to the size of the smallest one.

00:10:04.270 --> 00:10:07.320
So that's something you
need to watch out for.

00:10:07.900 --> 00:10:10.580
Second of all, you really want to create
different storage pools for

00:10:10.580 --> 00:10:12.240
different kinds of workloads.

00:10:12.280 --> 00:10:16.580
This is key for performance of
certain types of applications

00:10:16.630 --> 00:10:21.230
where you may have a combination
of random I/O and streaming I/O.

00:10:21.480 --> 00:10:24.250
and it allows you to basically
choose the optimal RAID configuration

00:10:24.310 --> 00:10:27.100
for each type of data,
not only at the file system level,

00:10:27.170 --> 00:10:30.170
but it allows you to configure
the XServe RAIDs as well for

00:10:30.170 --> 00:10:34.000
the type of workload that you're
going to be subjecting them to.

00:10:34.190 --> 00:10:37.740
This also has the advantage that
I/O that's occurring on one pool

00:10:37.830 --> 00:10:39.150
does not interfere with another.

00:10:39.380 --> 00:10:43.530
For example,
if you have a digital asset management

00:10:43.530 --> 00:10:50.180
application and you're streaming some
data off of your archival pool to get

00:10:50.250 --> 00:10:54.330
into your video production workflow,
you don't want the indexing operations

00:10:54.330 --> 00:10:57.960
or lookup operations that are happening
by some other user interfering with

00:10:58.020 --> 00:10:59.300
streaming that data off the drives.

00:10:59.410 --> 00:11:02.000
You can do that with storage pools.

00:11:02.610 --> 00:11:08.110
So here's just a quick example
to illustrate storage pools here.

00:11:08.180 --> 00:11:10.370
Going back to our diagram,

00:11:11.200 --> 00:11:14.440
So again we have our one
metadata storage pool.

00:11:14.440 --> 00:11:17.210
We just got a single RAID 1 one there.

00:11:18.030 --> 00:11:21.500
Then we have in this hypothetical
example an audio storage pool.

00:11:21.500 --> 00:11:22.850
We don't need a lot of space for this.

00:11:22.920 --> 00:11:25.480
It doesn't need to stream
a lot of data off quickly.

00:11:25.770 --> 00:11:28.300
And so we're just going to
use a single RAID 5 for that.

00:11:28.440 --> 00:11:32.900
But in this instance we're using say
uncompressed high definition video

00:11:32.900 --> 00:11:34.500
and we really need the bandwidth.

00:11:34.610 --> 00:11:39.690
So for video we're going to go with four
RAID 5s so that we have a total of four

00:11:39.770 --> 00:11:42.980
2 gigabit per second paths to that data.

00:11:44.630 --> 00:11:48.280
But this all appears as a
single icon on your desktop,

00:11:48.380 --> 00:11:50.130
one volume.

00:11:51.830 --> 00:11:53.920
So storage pools, they're powerful.

00:11:54.050 --> 00:11:55.650
How do we use them?

00:11:55.930 --> 00:11:57.960
This is where affinities come into play.

00:11:57.980 --> 00:12:03.800
So a controller normally assigns files to
a storage pool in a round robin fashion.

00:12:03.800 --> 00:12:07.910
As you create a file,
it starts here at storage pool one,

00:12:07.910 --> 00:12:11.440
you create a next file,
it goes on the storage pool two, etc.

00:12:11.860 --> 00:12:19.400
But affinities give you the ability to
steer data to specific storage pools.

00:12:19.400 --> 00:12:22.930
These storage pools can also be marked
as an exclusive storage pool so that

00:12:22.930 --> 00:12:30.100
data is only assigned to them if
it's specifically steered towards it.

00:12:30.930 --> 00:12:35.460
The Xsan Admin application allows
mapping of folders to specific storage

00:12:35.460 --> 00:12:39.730
pools and Mike Margolis is going
to demo that for you later today.

00:12:39.840 --> 00:12:44.530
There's a command line tool that allows
you to query and set storage pools for

00:12:44.640 --> 00:12:50.950
files and folders and also an application
API that we'll get into shortly.

00:12:52.310 --> 00:12:57.570
Okay, so now you've learned a bit
about storage pools now,

00:12:57.590 --> 00:13:01.860
so let's talk about Xsan
volume characteristics.

00:13:01.860 --> 00:13:04.360
These are of particular importance
to application developers who

00:13:04.360 --> 00:13:08.230
are writing applications that
actually do file system-y stuff,

00:13:08.310 --> 00:13:11.020
actually talk to files on a disk.

00:13:11.020 --> 00:13:14.050
First of all,
performance characteristics of Xsan.

00:13:14.520 --> 00:13:17.410
It's a shared volume,
but the metadata operations

00:13:17.490 --> 00:13:20.740
are actually much faster than
a traditional file server.

00:13:20.740 --> 00:13:25.740
For one, the IP network is not involved
in the actual data transfer.

00:13:25.740 --> 00:13:28.070
We actually recommend that you
use a private Ethernet network

00:13:28.190 --> 00:13:32.490
for connecting your metadata
controllers to your clients.

00:13:32.500 --> 00:13:35.410
For this reason,
that network is lightly loaded

00:13:35.410 --> 00:13:37.640
and should be highly responsive.

00:13:37.640 --> 00:13:39.930
In addition,
the metadata controller itself,

00:13:39.930 --> 00:13:42.650
unlike a traditional file server,
is not actually involved

00:13:42.650 --> 00:13:44.340
in the data transfer.

00:13:44.340 --> 00:13:47.770
So it can respond to those
metadata operations quickly.

00:13:48.790 --> 00:13:52.100
But it's also important to remember
that this is not a local volume.

00:13:52.100 --> 00:13:55.500
Talking to a local disk is always faster
than taking a round trip on the network.

00:13:55.630 --> 00:13:58.640
So things like lookup, create,
anything that changes

00:13:58.640 --> 00:14:02.380
the attribute of a file,
these all require the client

00:14:02.380 --> 00:14:05.640
to go out onto the network and
talk to the metadata controller,

00:14:05.640 --> 00:14:08.500
which is slower than
talking on the local volume.

00:14:08.830 --> 00:14:12.500
But file I/O is going
to happen at RAID speed.

00:14:15.310 --> 00:14:18.790
So, some things you need to be
aware of when you're writing

00:14:18.870 --> 00:14:21.050
an Xsan compatible application.

00:14:22.010 --> 00:14:24.100
First of all, it's a shared volume.

00:14:24.160 --> 00:14:27.390
So you need to be aware that file
locking comes into play here,

00:14:27.450 --> 00:14:30.260
just like any other shared volume.

00:14:30.260 --> 00:14:33.260
We support all the
standard file locking APIs,

00:14:33.360 --> 00:14:37.370
both the shared and exclusive
lock flags to open as well as

00:14:37.480 --> 00:14:39.940
POSIX byte range file locking.

00:14:40.930 --> 00:14:44.140
You should also expect very
large volumes with Xsan.

00:14:44.150 --> 00:14:47.320
Multi-terabyte volumes are
extremely common as are

00:14:47.320 --> 00:14:49.180
very large numbers of files.

00:14:49.300 --> 00:14:54.190
So if you're writing some sort of
backup application or any other

00:14:54.190 --> 00:14:56.530
data management application,
you need to make sure to use the

00:14:56.580 --> 00:15:01.050
correct types for file sizes,
for block numbers, for inode numbers,

00:15:01.050 --> 00:15:01.690
etc.

00:15:02.880 --> 00:15:04.910
Now, this is not an HFS+ volume.

00:15:05.090 --> 00:15:07.800
It's actually a lot more
like UFS in a lot of ways.

00:15:07.800 --> 00:15:09.370
It's case sensitive.

00:15:09.660 --> 00:15:12.700
It's a single fork file system
so Carbon uses Apple Double.

00:15:12.700 --> 00:15:16.640
Bear that in mind if, again,
you're writing backup software,

00:15:16.640 --> 00:15:18.610
you need to pay attention to these
little dot underbar files that

00:15:18.610 --> 00:15:19.640
are scattered all over the place.

00:15:20.980 --> 00:15:23.800
And you need to be aware of
ownership and file permissions.

00:15:23.800 --> 00:15:29.760
Unlike AFP and SMB where you actually log
in to create a session to the SharePoint,

00:15:29.890 --> 00:15:31.800
there is no user ID mapping in Xsan.

00:15:31.800 --> 00:15:38.700
We rely completely on standard
POSIX UID and GID and POSIX permissions.

00:15:42.640 --> 00:15:45.870
So getting the most out
of Xsan performance wise,

00:15:45.990 --> 00:15:48.860
first of all, again,
remember the metadata operations

00:15:48.960 --> 00:15:51.800
require a network round trip.

00:15:51.930 --> 00:15:53.100
There's latency involved there.

00:15:53.100 --> 00:15:55.480
So try to avoid them at all costs.

00:15:55.610 --> 00:15:58.420
Don't use lots of small
files in your application.

00:15:58.490 --> 00:16:00.280
Don't use the file
system like a database.

00:16:00.280 --> 00:16:03.880
Actually create a database file if
you need that type of functionality.

00:16:04.030 --> 00:16:08.640
And then use the Xsan
APIs to preload file extents.

00:16:09.060 --> 00:16:11.600
When streaming data,
this actually reduces the number

00:16:11.610 --> 00:16:14.180
of round trips that you'll
have to make to the controller

00:16:14.180 --> 00:16:16.000
while you're streaming data off.

00:16:16.130 --> 00:16:19.330
And it also allows you to
continue to stream data more

00:16:19.330 --> 00:16:23.330
reliably if the controller
should fail over to the backup.

00:16:24.290 --> 00:16:27.340
You should also keep file
fragmentation to a minimum.

00:16:27.340 --> 00:16:30.860
File fragmentation means more work
for the metadata controller and more

00:16:30.860 --> 00:16:35.770
work for the client having to talk
to more drives and it does not always

00:16:35.770 --> 00:16:38.470
generate the optimal I/O pattern.

00:16:39.170 --> 00:16:44.700
So you can do this by preallocating
storage when you write files.

00:16:44.700 --> 00:16:47.050
We actually support
two preallocation APIs,

00:16:47.130 --> 00:16:50.710
both the fpreallocate fcontrol
that's available in POSIX and

00:16:50.710 --> 00:16:55.350
also the fsallocate fork call
that's available in Carbon.

00:16:56.750 --> 00:16:59.990
Finally, make sure you issue large
I/O requests when possible.

00:17:00.090 --> 00:17:03.600
The magic number we talk
about is about a megabyte.

00:17:03.610 --> 00:17:06.600
This allows two things.

00:17:06.600 --> 00:17:09.440
One, the file system,
if you're not using pre-allocation,

00:17:09.440 --> 00:17:13.010
can avoid fragmentation this way
because it sees that you're making

00:17:13.010 --> 00:17:14.600
these large sequential writes.

00:17:14.810 --> 00:17:19.130
Also,
it allows the file system to exploit

00:17:19.150 --> 00:17:22.190
the parallelism that's built right
into the Fibre Channel Fabric.

00:17:23.650 --> 00:17:26.640
Alright so,
let's talk a little bit about the

00:17:26.770 --> 00:17:29.480
developer APIs that make some of these

00:17:31.960 --> 00:17:35.320
So the developer APIs, again,
they provide access to

00:17:35.320 --> 00:17:37.320
Xsan-specific features.

00:17:37.340 --> 00:17:42.180
These include extent preloading,
bandwidth reservation, and affinities.

00:17:42.190 --> 00:17:46.230
Now, the underlying API uses sysctl.

00:17:46.310 --> 00:17:50.860
It's not the prettiest API in the world,
but if you're not,

00:17:50.860 --> 00:17:54.100
there's plenty of example code
that's available on the Xsan CD.

00:17:54.260 --> 00:17:58.680
And the Xsan CD is actually available
to all registered ADC developers.

00:17:58.680 --> 00:18:02.420
You can actually download
that developer preview.

00:18:02.730 --> 00:18:03.990
Now the API is still in flux.

00:18:04.040 --> 00:18:07.240
We said that last year
and it's still true.

00:18:07.410 --> 00:18:09.860
But rest assured that every effort
is going to be made to maintain

00:18:09.860 --> 00:18:13.470
binary compatibility so that your
applications that actually take

00:18:13.470 --> 00:18:16.200
advantage of Xsan's features,
while they may need source

00:18:16.200 --> 00:18:19.150
code changes going forward,
the old applications will

00:18:19.150 --> 00:18:20.490
continue to run fine.

00:18:20.960 --> 00:18:23.100
And finally,
we're actually working toward better

00:18:23.100 --> 00:18:26.950
integration with the other Mac OS APIs so
that you don't have to think about

00:18:27.040 --> 00:18:28.390
this stuff so much in your application.

00:18:28.400 --> 00:18:31.580
We're hoping to make this a little
more automatic in the future.

00:18:32.570 --> 00:18:35.440
First of all, we're going to talk about
file pre-allocation.

00:18:35.440 --> 00:18:39.810
This is not something
that's Xsan specific at all,

00:18:39.810 --> 00:18:40.340
actually.

00:18:40.340 --> 00:18:43.500
HFS also supports file pre-allocation.

00:18:43.500 --> 00:18:46.500
We actually strongly
encourage you to just do it,

00:18:46.500 --> 00:18:49.400
no matter what kind of file
system you're talking to.

00:18:49.400 --> 00:18:53.520
You can treat it as an advisory call,
you can ignore any errors,

00:18:53.520 --> 00:18:57.270
but basically what it allows
the file system to do is

00:18:57.380 --> 00:18:59.820
make optimal block allocation
decisions for your application.

00:18:59.980 --> 00:19:04.640
So here's just an example of using
F control to actually do this.

00:19:04.700 --> 00:19:06.970
It's pretty straightforward,
very similar to actually using

00:19:06.970 --> 00:19:08.230
the POSIX byte range locking.

00:19:08.300 --> 00:19:11.410
You fill out an FStoreT structure.

00:19:11.490 --> 00:19:18.690
You want to tell it basically what
the position mode you want to use.

00:19:18.690 --> 00:19:22.970
You always want to use the physical
end of file position mode in this call.

00:19:23.100 --> 00:19:24.360
Tell it where to start.

00:19:24.360 --> 00:19:27.690
So offset zero from end of file
is basically where we're starting.

00:19:27.780 --> 00:19:29.880
So we're starting at the end of the file.

00:19:30.010 --> 00:19:32.310
And then you want to tell it
how much you want to allocate.

00:19:32.410 --> 00:19:34.810
In this case the file size
because we're saving a file here.

00:19:34.900 --> 00:19:38.030
And it can also actually return
to you the number of bytes

00:19:38.030 --> 00:19:39.550
that have been allocated.

00:19:39.550 --> 00:19:41.300
You can ignore this.

00:19:41.300 --> 00:19:42.300
You can pay attention to it.

00:19:42.300 --> 00:19:43.100
It doesn't really matter.

00:19:43.100 --> 00:19:45.110
Again,
I encourage you to treat this as an

00:19:45.210 --> 00:19:48.290
advisory call in your application
and issue it all the time.

00:19:48.290 --> 00:19:51.100
If an error comes back from a file
system that doesn't support it,

00:19:51.100 --> 00:19:52.110
who cares.

00:19:52.300 --> 00:19:53.320
Thank you.

00:19:54.520 --> 00:19:56.740
And here's just the same
thing again in Carbon.

00:19:56.740 --> 00:19:59.770
Again, very straightforward.

00:20:01.160 --> 00:20:05.660
So the rest of the APIs that we're going
to talk about actually require that you

00:20:05.660 --> 00:20:08.580
issue them only on an Xsan file system.

00:20:08.890 --> 00:20:16.040
So the way that you tell if a volume
is actually an Xsan volume is you use

00:20:16.040 --> 00:20:21.670
the statfs system call and you pass
it a path and you get back a statfs

00:20:21.770 --> 00:20:25.800
structure and in that statfs structure
there is a file system type name.

00:20:25.800 --> 00:20:29.460
And in the header file that we provide
in the Xsan software development

00:20:29.610 --> 00:20:33.330
kit there is a string constant that
defines what that file system type

00:20:33.330 --> 00:20:37.950
name is and you just compare it
and if it returns zero then you

00:20:37.950 --> 00:20:40.280
know that it is an Xsan file system.

00:20:41.850 --> 00:20:47.960
So this is just a really simple example
of how you make a call to the Xsan API.

00:20:47.960 --> 00:20:50.580
This particular example,
we actually are just querying the

00:20:50.580 --> 00:20:52.790
version information of the file system.

00:20:52.800 --> 00:20:56.200
And as you can see,
it's pretty straightforward.

00:20:56.270 --> 00:21:00.680
That fs_sysctl function is
actually included in the

00:21:00.680 --> 00:21:02.910
example code that's on the CD.

00:21:02.920 --> 00:21:05.380
And you can just cut and paste that
directly in your application so you

00:21:05.380 --> 00:21:08.130
don't have to worry about rewriting
exactly all the stuff that it does.

00:21:08.250 --> 00:21:11.110
It does a few sort of bookkeeping
things to make sure that,

00:21:11.210 --> 00:21:15.150
or to actually find out the index,
the file system index number of

00:21:15.150 --> 00:21:17.200
the file system in the kernel.

00:21:17.200 --> 00:21:18.660
And that function takes care of it.

00:21:18.720 --> 00:21:19.940
You can just use that.

00:21:21.740 --> 00:21:23.700
So preloading file extents.

00:21:23.700 --> 00:21:28.760
You want to use the F_LOAD_EXT API call.

00:21:28.770 --> 00:21:31.880
I strongly encourage anyone
who is writing a streaming

00:21:31.880 --> 00:21:33.440
application to use this call.

00:21:33.510 --> 00:21:36.580
It's going to make your
application work much better,

00:21:36.580 --> 00:21:39.300
especially if you have
a controller failover.

00:21:39.300 --> 00:21:40.560
Very straightforward.

00:21:40.560 --> 00:21:42.980
You basically,
here in this particular example,

00:21:42.980 --> 00:21:47.560
we've determined the size
of the file using stat.

00:21:47.560 --> 00:21:53.020
We just provide that to the little data
structure that we pass up to this call.

00:21:53.020 --> 00:21:55.740
We issue it and it does all the
communication with the metadata

00:21:55.740 --> 00:21:59.350
controller and preloads all the extent
information right into the kernel on the

00:21:59.350 --> 00:22:03.610
client side so that it can just begin to
stream data as soon as you start to read.

00:22:05.080 --> 00:22:07.180
Bandwidth Reservation.

00:22:07.200 --> 00:22:09.400
We actually demoed this
a little bit last year.

00:22:09.400 --> 00:22:13.520
I don't actually have any sample
code that will fit on one slide

00:22:13.520 --> 00:22:15.340
for bandwidth reservation,
unfortunately.

00:22:15.340 --> 00:22:17.460
There's lots of things you have to do.

00:22:17.550 --> 00:22:20.990
But fear not,
this is documented in the documentation

00:22:20.990 --> 00:22:23.170
that's included on the Xsan CD.

00:22:23.660 --> 00:22:28.390
But essentially what you do is
you use the FsetRTIO API call to

00:22:28.390 --> 00:22:30.600
enable real time I/O on a file.

00:22:30.600 --> 00:22:33.570
Now keep in mind this does require
some additional configuration

00:22:33.660 --> 00:22:35.600
on your metadata controller.

00:22:35.600 --> 00:22:38.770
This configuration,
these configuration knobs are not

00:22:38.870 --> 00:22:40.600
available in the Xsan Admin GUI.

00:22:40.600 --> 00:22:43.600
You actually do have to edit a
config file manually to do this

00:22:43.600 --> 00:22:44.600
but it's very straight forward.

00:22:44.600 --> 00:22:48.530
I've got a little example snippet there
of what you might put in the config file.

00:22:48.640 --> 00:22:54.580
Essentially for each storage pool what
you need to do is specify the throughput

00:22:54.690 --> 00:22:56.520
that's available on that storage pool.

00:22:56.620 --> 00:23:00.600
That's something the Xsan Admin
Application can't really determine.

00:23:00.600 --> 00:23:03.960
There are tools out there that do disk
performance testing and you want to

00:23:03.960 --> 00:23:08.590
use those types of tools to determine
the throughput available on your pool.

00:23:08.730 --> 00:23:12.480
And then the next thing you need
to do is you need to specify the

00:23:12.480 --> 00:23:18.090
amount of bandwidth that is reserved
for non-real-time applications.

00:23:18.100 --> 00:23:22.280
So by default this defaults to 1
megabyte per second where you don't want,

00:23:22.280 --> 00:23:24.430
you essentially don't want an
application to be able to reserve

00:23:24.680 --> 00:23:27.500
all of the bandwidth available
because then you might deadlock other

00:23:27.500 --> 00:23:31.100
applications out from being able
to read and write that volume at all.

00:23:31.180 --> 00:23:35.100
This example we've just reserved
10 megabytes per second for

00:23:35.130 --> 00:23:37.140
all non-real-time clients.

00:23:38.640 --> 00:23:39.840
So, affinities.

00:23:39.840 --> 00:23:44.470
There are essentially three
basic API calls used to

00:23:44.470 --> 00:23:47.100
manipulate affinities in Xsan.

00:23:47.170 --> 00:23:49.600
First is the fgetaffinity API call.

00:23:49.600 --> 00:23:53.590
This, as the name might suggest,
gets the affinity that

00:23:53.590 --> 00:23:54.720
is assigned to a file.

00:23:55.670 --> 00:23:59.060
Then there's the FSGInfo API call.

00:23:59.070 --> 00:24:02.990
And what this does is it returns
information about the storage pools

00:24:02.990 --> 00:24:04.740
that are available on the volume.

00:24:04.750 --> 00:24:08.650
Each volume actually has an
8-byte key assigned to it.

00:24:09.540 --> 00:24:13.680
And then that key is used with the
FsetAffinity API call to actually

00:24:13.680 --> 00:24:16.000
assign the affinity for the file.

00:24:16.120 --> 00:24:19.540
And that affinity then takes
effect for all new data,

00:24:19.540 --> 00:24:21.840
all new extents allocated for that file.

00:24:21.840 --> 00:24:24.840
It will not move extents that
are already assigned to a file.

00:24:24.870 --> 00:24:27.560
There are actually command line tools
available in Xsan to do that for you.

00:24:27.560 --> 00:24:30.120
Or once you've assigned a file,
you can actually copy it and

00:24:30.120 --> 00:24:33.700
it will go to the new place.

00:24:33.720 --> 00:24:38.100
So how you might use these
three API calls together.

00:24:38.400 --> 00:24:45.480
Say your application has a save file
dialog and you want to allow your user

00:24:45.480 --> 00:24:48.800
to specify the affinity for that file.

00:24:48.800 --> 00:24:52.300
You'd use the getAffinity
call to provide a popup,

00:24:52.300 --> 00:24:54.850
sorry to provide a default for a popup.

00:24:54.860 --> 00:24:58.090
That popup would then contain
a list of all the storage pools

00:24:58.140 --> 00:25:01.550
available and you can get that
list using the SGINFO API call.

00:25:01.740 --> 00:25:05.910
The user can then select the popup
they want or leave the default.

00:25:06.060 --> 00:25:10.540
And then when you write out that file,
you'd use setAffinity to

00:25:10.540 --> 00:25:12.790
actually set the affinity.

00:25:13.790 --> 00:25:16.500
So, just to illustrate this,
we're going to walk through an example

00:25:16.500 --> 00:25:18.730
of saving a file to an Xsan volume.

00:25:18.870 --> 00:25:20.300
Pretty simple operation.

00:25:20.450 --> 00:25:24.790
These steps are really
similar to what the Carbon and

00:25:24.840 --> 00:25:27.700
Cocoa safe-save operations do.

00:25:27.870 --> 00:25:30.890
First of all,
you would use the open system

00:25:30.980 --> 00:25:33.410
call to create a temporary file.

00:25:34.420 --> 00:25:37.930
Then you could optionally use the
setAffinity API call to assign

00:25:37.930 --> 00:25:40.690
it to a specific storage pool.

00:25:42.190 --> 00:25:45.430
Next,
because you're all good Xsan citizens,

00:25:45.430 --> 00:25:48.300
you're going to pre-allocate
the storage for that file.

00:25:49.720 --> 00:25:51.180
Xsan is the Xsan
application for Mac OS X.

00:25:51.240 --> 00:25:53.620
Learn the basics of how Xsan works
and how its differences relative

00:25:53.740 --> 00:25:56.700
to HFS+ might be important to your
products for maximized performance.

00:26:19.720 --> 00:26:23.480
Now, if you allocate all this space
and you don't use it all,

00:26:23.580 --> 00:26:27.270
that's OK, because when you close
the file when you're done,

00:26:27.570 --> 00:26:30.290
all that unused preallocated space
will be freed back to the file

00:26:30.290 --> 00:26:34.050
system so you don't have to worry
about wasting file system space.

00:26:35.990 --> 00:26:40.300
Finally, in order to provide atomicity
from the user's perspective,

00:26:40.300 --> 00:26:46.090
you use rename to rename the temporary
file to the user's specified file name.

00:26:46.090 --> 00:26:50.170
This provides consistency for the user
if any of these operations should fail

00:26:50.180 --> 00:26:52.210
in middle and you abort the operation.

00:26:54.040 --> 00:26:59.430
So, you're all charged up to develop your
Xsan compatible applications I hope,

00:26:59.460 --> 00:27:02.060
but you're probably wondering, "Well,
how do I do this without spending a

00:27:02.060 --> 00:27:04.900
whole lot of money on gear?" Well,
you don't actually have to do that

00:27:04.900 --> 00:27:09.720
if you just want to make sure your
application is compatible with Xsan.

00:27:09.720 --> 00:27:12.220
Really all you need is a
desktop or a powerbook,

00:27:12.220 --> 00:27:15.030
a FireWire drive,
and a network connection with

00:27:15.030 --> 00:27:20.180
a static IP address and you can
have a fully functional sandbox.

00:27:20.280 --> 00:27:23.240
With that,
I'm going to turn the podium over to

00:27:23.240 --> 00:27:28.680
Mike Margolis and he's going to show you

00:27:29.960 --> 00:27:32.560
All right, I have cheerleaders I guess.

00:27:32.560 --> 00:27:36.680
So, demo machine.

00:27:38.040 --> 00:27:42.200
So you're going to need a
FireWire drive right here.

00:27:42.200 --> 00:27:46.390
The first step is going to be
to plug it into your machine.

00:27:46.530 --> 00:27:48.000
Now this is an HFS+ volume.

00:27:48.000 --> 00:27:51.000
I use it to store some
random files for work.

00:27:51.000 --> 00:27:55.090
What we're going to need to do
is remove the HFS+ partition

00:27:55.120 --> 00:27:57.000
so that Xsan can use it.

00:27:57.000 --> 00:28:00.960
The second step,
because the first step was plugging in,

00:28:01.000 --> 00:28:02.000
is to erase that.

00:28:02.000 --> 00:28:04.040
So we launch Disk Utility.

00:28:04.040 --> 00:28:05.960
We click on the volume.

00:28:05.960 --> 00:28:09.980
Click on partition and you
format it as free space.

00:28:09.980 --> 00:28:13.070
And then go ahead and partition it.

00:28:13.130 --> 00:28:15.860
And we'll get a little error back.

00:28:15.860 --> 00:28:18.540
Don't mind that, that's normal.

00:28:18.540 --> 00:28:24.050
We now run the admin tool now that we
have a FireWire drive that's ready.

00:28:24.070 --> 00:28:27.690
So let's log in as our
local administrator here.

00:28:28.040 --> 00:28:29.820
And this will go ahead and connect.

00:28:29.820 --> 00:28:32.400
So as you can see the file system
is running but we don't have

00:28:32.400 --> 00:28:33.700
any mounted clients or capacity.

00:28:33.700 --> 00:28:35.900
We don't have a Xsan volume yet.

00:28:35.900 --> 00:28:39.890
If you were here last year
some of this might be review.

00:28:39.890 --> 00:28:44.880
You can use the admin to see the
logs for any machine on the system

00:28:44.900 --> 00:28:46.900
and you can even filter the logs.

00:28:46.900 --> 00:28:50.750
You can use graphs for
the IP network traffic,

00:28:50.760 --> 00:28:54.030
fiber network traffic, or CPU usage.

00:28:54.030 --> 00:28:55.060
There's no fiber traffic.

00:28:55.080 --> 00:28:55.820
There's no fiber.

00:28:55.900 --> 00:28:59.880
So the CPU usage of any
machine on the network as well.

00:28:59.960 --> 00:29:01.900
Right now there's just one.

00:29:02.000 --> 00:29:03.890
And here's where the fun comes in.

00:29:03.940 --> 00:29:06.370
We're going to set up
a SAN on this machine.

00:29:06.500 --> 00:29:09.450
So the first step is to select
the machine and it says you must

00:29:09.840 --> 00:29:11.400
enter an Xsan serial number.

00:29:11.400 --> 00:29:16.600
Well luckily we have an Xsan
serial number right here.

00:29:16.650 --> 00:29:19.640
So let's go ahead and paste that in
and it will validate automatically

00:29:19.640 --> 00:29:22.700
so it won't let you enter weird
invalid serial numbers and you

00:29:22.700 --> 00:29:25.600
can see this expires Monday,
June 13th.

00:29:25.600 --> 00:29:31.590
We need this to be a controller as
well so that it can serve up volumes.

00:29:31.590 --> 00:29:34.710
The failover priority isn't
too important right now.

00:29:34.740 --> 00:29:38.460
Normally it lets you specify the
order in which machines failover

00:29:38.690 --> 00:29:42.600
when they go down but we only have
one so that's not the problem.

00:29:42.600 --> 00:29:44.600
Not a problem here.

00:29:44.600 --> 00:29:47.600
So we also want to access the
Xsan via built in Ethernet.

00:29:47.600 --> 00:29:51.300
If you have a multiple NIC machine
you want to specify if you want the

00:29:51.320 --> 00:29:53.700
private network or the public network.

00:29:53.720 --> 00:29:55.500
Usually the private needs
to tell it which one it is.

00:29:55.600 --> 00:29:58.440
This is actually important for
your PowerBook development.

00:29:58.450 --> 00:30:01.690
You need a static IP address because
the file system configuration files

00:30:01.770 --> 00:30:04.750
use this IP address so if you come
up again with a different IP you

00:30:04.860 --> 00:30:06.580
won't be able to mount your volume.

00:30:06.700 --> 00:30:08.600
You'll kind of have to
scrub and start over.

00:30:08.600 --> 00:30:11.140
So let's go ahead and click OK.

00:30:11.600 --> 00:30:14.600
And let's name this WWDC-San.

00:30:14.600 --> 00:30:16.720
Click over on LUNs.

00:30:16.720 --> 00:30:18.600
Then step two which we
conveniently numbered for you.

00:30:18.600 --> 00:30:22.720
Go ahead and you can see
it's a 27 gigabyte LUN.

00:30:22.740 --> 00:30:24.510
So it's definitely a FireWire device.

00:30:24.600 --> 00:30:26.540
Click on storage.

00:30:26.580 --> 00:30:27.730
Step three.

00:30:27.730 --> 00:30:28.560
This is the fun part.

00:30:28.620 --> 00:30:29.600
Create the volume.

00:30:29.600 --> 00:30:31.600
So you click the new volume button here.

00:30:31.780 --> 00:30:34.860
And let's name this MicSan.

00:30:34.960 --> 00:30:36.520
Mic volume actually.

00:30:36.600 --> 00:30:40.300
There are certain configuration
parameters here like the block allocation

00:30:40.310 --> 00:30:40.600
size and the allocation structure.

00:30:40.600 --> 00:30:44.230
We don't need to tweak with them
right now but if you need to know more

00:30:44.260 --> 00:30:47.600
about them you can click on the help
button in any sheet and it will bring

00:30:47.600 --> 00:30:47.600
up inline help in the application.

00:30:47.600 --> 00:30:49.590
And that's it.

00:30:50.390 --> 00:30:53.850
The next step is to click the new
storage pool button next to the

00:30:53.940 --> 00:30:55.700
list and we create a storage pool.

00:30:55.820 --> 00:30:58.290
Now normally we recommend that
you separate your journaling and

00:30:58.290 --> 00:31:01.200
metadata into its own storage pool.

00:31:01.320 --> 00:31:05.800
In our case we only have one LUN so
we're going to go with any data.

00:31:05.920 --> 00:31:09.060
Again there's more configuration
values here that you can play

00:31:09.060 --> 00:31:12.200
with and you can click on help
to get information about them.

00:31:12.310 --> 00:31:16.980
And finally we click on available
LUNs and you drag and drop

00:31:17.040 --> 00:31:18.700
create a Xsan right there.

00:31:18.830 --> 00:31:22.560
And you click save and it pops
up a warning saying oh no you're

00:31:22.590 --> 00:31:24.400
only using one storage pool.

00:31:24.400 --> 00:31:27.290
Are you sure this might hurt
performance because if you mix your

00:31:27.290 --> 00:31:30.700
user data and your metadata you can
interrupt your streaming performance.

00:31:30.820 --> 00:31:32.300
And you might even run out.

00:31:32.390 --> 00:31:33.690
So we don't really mind.

00:31:33.780 --> 00:31:35.060
It's not a real SAN anyways.

00:31:35.200 --> 00:31:36.090
Click save.

00:31:36.200 --> 00:31:40.140
So this is going to go
ahead and create our volume.

00:31:40.300 --> 00:31:43.200
While it's creating it I'm
going to show you notifications.

00:31:43.200 --> 00:31:46.510
Xsan has the ability to send you
email notifications if certain things

00:31:46.540 --> 00:31:50.370
happen like a controller fails over,
someone takes scissors

00:31:50.370 --> 00:31:51.490
to the fiber channel.

00:31:51.500 --> 00:31:55.130
It'll email you about
that if you really want.

00:31:55.300 --> 00:34:44.500
[Transcript missing]

00:34:50.620 --> 00:34:51.600
Great, thanks Mike.

00:34:51.890 --> 00:34:57.820
Go back to slides, thanks.

00:34:58.270 --> 00:35:01.330
Hopefully you're all excited
about developing your

00:35:01.350 --> 00:35:03.480
applications to be Xsan aware.

00:35:03.480 --> 00:35:08.200
Before we wrap up,
I'm going to go over examples

00:35:08.200 --> 00:35:11.750
of some applications that really
ought to be made Xsan aware.

00:35:11.830 --> 00:35:15.160
You can maybe take this as a little
challenge to application developers

00:35:15.220 --> 00:35:17.200
out there to go out and do this.

00:35:17.280 --> 00:35:21.000
If you do,
you'll have a leg up in your competition

00:35:21.000 --> 00:35:23.770
when you work better with Xsan.

00:35:24.090 --> 00:35:27.880
Being involved in the
management of this product,

00:35:28.090 --> 00:35:31.620
I hear a lot of complaints sometimes.

00:35:31.620 --> 00:35:37.640
One of the questions we
feel a lot is backups.

00:35:37.640 --> 00:35:40.200
How do we do backups on Xsan?

00:35:40.510 --> 00:35:44.730
I don't know if any of you were
at Rusty Tucker's ACL session

00:35:44.730 --> 00:35:46.780
a couple of sessions ago.

00:35:47.180 --> 00:35:50.590
They talked about Tivoli
Storage Manager and how it

00:35:50.590 --> 00:35:52.790
actually has Xsan support.

00:35:53.210 --> 00:35:54.550
Backup software.

00:35:54.600 --> 00:35:57.700
There are a couple of Xsan
specific things in backup software

00:35:57.700 --> 00:35:59.300
that you really want to support.

00:35:59.340 --> 00:36:02.290
One of them is to be able to
backup and restore the affinity

00:36:02.410 --> 00:36:05.080
information for individual files.

00:36:05.130 --> 00:36:07.340
If there is a catastrophic
failure on your SAN,

00:36:07.340 --> 00:36:10.090
when you restore it you want
it to have the same performance

00:36:10.090 --> 00:36:12.100
characteristics that it had before.

00:36:12.100 --> 00:36:15.490
You can do that by extending your
backup catalog information to be able

00:36:15.570 --> 00:36:17.100
to store the affinity for a file.

00:36:17.100 --> 00:36:20.320
When a volume is restored,
it is restored with the same

00:36:20.320 --> 00:36:24.030
types of storage pool names and
when those files are restored,

00:36:24.030 --> 00:36:27.080
they are restored to the
correct storage pools.

00:36:27.550 --> 00:36:31.920
Secondly, we are often asked, "Well,
how do you back up quota information?"

00:36:31.920 --> 00:36:35.260
Quota information is really kind
of a property of the volume and

00:36:35.260 --> 00:36:38.690
you can actually use Xsan APIs to
query the quota information and

00:36:38.690 --> 00:36:42.790
then you can store that in your volume
attributes in your backup catalog.

00:36:44.180 --> 00:36:45.920
Next, digital asset management.

00:36:45.920 --> 00:36:49.790
I think I mentioned this
earlier in the slides.

00:36:50.400 --> 00:36:53.750
You can use storage pools in
a digital asset management

00:36:53.750 --> 00:36:57.280
application to really improve the
performance of your application.

00:36:57.360 --> 00:36:59.910
You can separate your index,
your previews,

00:37:00.250 --> 00:37:02.700
and your full res data from one another.

00:37:02.700 --> 00:37:04.740
You perform data isolation this way.

00:37:04.780 --> 00:37:11.650
This allows you to continue to
stream full res data off while you

00:37:12.010 --> 00:37:15.190
do indexing operations and that
I/O won't conflict with one another.

00:37:16.560 --> 00:37:18.810
Next, distributed applications.

00:37:18.820 --> 00:37:20.220
How many of you are familiar with Xgrid?

00:37:20.250 --> 00:37:21.100
Raise your hands.

00:37:21.100 --> 00:37:22.100
You've heard of it?

00:37:22.240 --> 00:37:22.500
Used it?

00:37:22.560 --> 00:37:25.400
Okay, so in distributed applications,
traditionally,

00:37:25.490 --> 00:37:32.100
data is copied from the scheduling
entity out to the processing entities.

00:37:32.100 --> 00:37:34.600
And that's usually done over a network.

00:37:34.600 --> 00:37:39.080
So we'd like to encourage you to use,
instead of the pass-by-value

00:37:39.080 --> 00:37:42.740
semantics of actually sending
that data over the network,

00:37:42.740 --> 00:37:44.050
pass it by reference.

00:37:44.120 --> 00:37:49.480
Provide it a path name and connect all
of your computing resources to the Xsan.

00:37:49.480 --> 00:37:53.220
This allows all of those applications
to actually read that data at full speed

00:37:53.240 --> 00:37:58.700
directly from disk instead of having to
shuttle it over the network manually.

00:38:02.120 --> 00:38:03.760
Next, streaming applications.

00:38:03.760 --> 00:38:08.900
This would include any type
of video production software.

00:38:08.900 --> 00:38:12.000
This would include
streaming media servers.

00:38:12.000 --> 00:38:17.350
Anything where you open a file
and you read it to the end.

00:38:18.230 --> 00:38:21.540
One, you should use extent preloading
like we talked about before.

00:38:21.540 --> 00:38:26.070
This is going to improve your
performance and your reliability.

00:38:26.260 --> 00:38:30.630
Also,
consider using the bandwidth reservation

00:38:30.630 --> 00:38:34.550
APIs in order to make sure that you don't
have interruptions of service as you are

00:38:34.550 --> 00:38:39.410
streaming that data out to the network
or any other consumer of that data.

00:38:41.000 --> 00:38:43.170
Next, Media Ingest Applications.

00:38:43.200 --> 00:38:45.800
I guess this would be kind
of the flip side of the video

00:38:45.800 --> 00:38:49.900
post production workflow,
pulling the data in.

00:38:49.900 --> 00:38:54.140
Use pre-allocation when you're
writing that data to the Xsan.

00:38:54.290 --> 00:38:56.930
It's going to greatly improve the
performance of your application

00:38:57.350 --> 00:38:59.700
as you then read it back later.

00:39:00.380 --> 00:39:03.250
And then finally you can also
consider using bandwidth reservation

00:39:03.250 --> 00:39:06.820
in this scenario as well in order to
have guaranteed service so that as

00:39:06.820 --> 00:39:10.610
you're streaming it off of tape you
don't suddenly drop a frame and have

00:39:10.610 --> 00:39:12.650
to back up and start over again.

00:39:14.910 --> 00:39:19.150
So, just to wrap up here,
I think we've shown you that

00:39:19.150 --> 00:39:24.430
Xsan actually allows for
highly flexible use of storage.

00:39:24.440 --> 00:39:27.960
Much more flexible than just your
traditional direct attached storage,

00:39:28.030 --> 00:39:32.250
much more flexible than a file server,
and it also allows for

00:39:32.250 --> 00:39:35.980
shared access at high speeds.

00:39:37.300 --> 00:39:43.040
Next, the applications really should be
aware of Xsan's volume characteristics.

00:39:43.040 --> 00:39:45.520
There are some differences
from traditional HFS that

00:39:45.710 --> 00:39:47.670
you need to be aware of.

00:39:47.670 --> 00:39:51.910
Also, the flipside of that is that
applications can then be tuned for

00:39:51.910 --> 00:39:54.030
better performance on Xsan as well.

00:39:54.700 --> 00:39:57.680
Finally,
it's really easy to set up a sandbox

00:39:57.680 --> 00:40:02.590
for developing an application
to be compatible with Xsan.

00:40:04.530 --> 00:40:08.760
So for more information about Xsan,
obviously the first place you should go

00:40:08.810 --> 00:40:13.190
is the Xsan webpages on www.apple.com.

00:40:13.220 --> 00:40:17.610
It's chock full of information
including examples of how it can be

00:40:17.610 --> 00:40:20.910
used in various types of environments,
be it high performance computing,

00:40:20.980 --> 00:40:26.400
video workflow,
and enterprise IT type deployments.

00:40:26.810 --> 00:40:33.320
Also, I strongly encourage you to join
the Xsan users mailing list.

00:40:33.320 --> 00:40:36.340
For those of you who are
using and deploying Xsan,

00:40:36.420 --> 00:40:39.890
it's a great resource for seeing
how other people use Xsan and

00:40:39.890 --> 00:40:46.310
just a good user community
for sharing tips and tricks.

00:40:46.630 --> 00:40:49.930
For application developers,
this is also a good resource for

00:40:49.930 --> 00:40:54.500
finding out how your potential
customers are using Xsan.

00:40:54.500 --> 00:40:58.180
I strongly encourage everyone to
sign up on that mailing list if you

00:40:58.180 --> 00:41:00.170
have any interest in Xsan at all.

00:41:03.270 --> 00:41:07.200
So, documentation and sample code.

00:41:07.200 --> 00:41:09.440
We don't have anything
up on the WWDC website,

00:41:09.460 --> 00:41:15.700
but you can actually get this
on the Xsan CD that's available

00:41:15.700 --> 00:41:17.200
from Apple Developer Connection.

00:41:17.200 --> 00:41:20.350
Again, any registered ADC member can
actually download a developer

00:41:20.420 --> 00:41:22.140
preview of Xsan and start using it.

00:41:22.200 --> 00:41:26.160
And there's a software development
kit included there with PDF files,

00:41:26.240 --> 00:41:28.370
got documentation in it,
along with sample code and

00:41:28.440 --> 00:41:32.510
the API header file that you
need in order to get started.
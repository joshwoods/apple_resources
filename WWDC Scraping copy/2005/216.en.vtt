WEBVTT

00:00:01.550 --> 00:00:04.750
Hi, my name is Andrew Barnes,
and this is the Graphics

00:00:04.820 --> 00:00:08.040
2D Performance session.

00:00:08.140 --> 00:00:10.900
So now, we're going to start.

00:00:15.710 --> 00:00:21.930
So what you'll learn today is about
how to use the graphics 2D API,

00:00:21.930 --> 00:00:25.710
Quartz 2D API, efficiently.

00:00:25.710 --> 00:00:25.710
And...

00:00:26.300 --> 00:00:31.990
to help you to improve your
application's graphics performance.

00:00:32.080 --> 00:00:35.010
So,
what you'll learn today is how to draw

00:00:35.010 --> 00:00:36.770
what you have to draw efficiently.

00:00:36.800 --> 00:00:42.160
The second thing you're going to learn
today is how you get what you've drawn

00:00:42.180 --> 00:00:44.720
onto the screen so the user can see it.

00:00:44.720 --> 00:00:47.600
And the third thing that
you're going to do is sort of a

00:00:47.600 --> 00:00:51.700
meta-level type of how does your
application interact with the user,

00:00:51.700 --> 00:00:55.070
sort of live resizing,
little things that you might want to

00:00:55.070 --> 00:00:57.500
know when you're writing applications.

00:00:57.580 --> 00:00:59.860
So, let's get started.

00:01:00.480 --> 00:01:01.950
Here's the graphics architecture slide.

00:01:01.980 --> 00:01:04.410
You've seen it before
in other presentations.

00:01:04.430 --> 00:01:07.930
Basically,
applications can draw either video, 3D,

00:01:08.140 --> 00:01:08.660
or 2D.

00:01:08.660 --> 00:01:12.400
And what they do is they draw,
particularly for video and 3D,

00:01:12.400 --> 00:01:13.700
they draw into surfaces.

00:01:13.700 --> 00:01:15.220
Those are hardware-accelerated surfaces.

00:01:15.220 --> 00:01:17.860
And for your 2D content,
you draw into window backing stores.

00:01:17.880 --> 00:01:21.110
Those window backing stores are
sort of shared between processes,

00:01:21.110 --> 00:01:23.400
the Quartz compositor,
and your application.

00:01:23.400 --> 00:01:26.100
And what happens is the Quartz
compositor takes that data,

00:01:26.100 --> 00:01:29.060
the data you've just rendered,
either video or 3D,

00:01:29.520 --> 00:01:32.300
and assembles it all together,
puts it in the frame buffer,

00:01:32.300 --> 00:01:33.370
and it scans out.

00:01:33.420 --> 00:01:34.380
The user sees it.

00:01:34.460 --> 00:01:35.100
Great.

00:01:35.120 --> 00:01:38.460
So what we're not going
to talk about today,

00:01:38.460 --> 00:01:41.250
although the things that you
learn in this session would

00:01:41.270 --> 00:01:44.230
be definitely applicable,
is 3D and video.

00:01:44.240 --> 00:01:46.080
There are other sessions
related to those topics.

00:01:46.100 --> 00:01:48.540
And the second thing we're not
going to talk about is Quickdraw.

00:01:48.540 --> 00:01:50.600
So hopefully you were
at the last session,

00:01:50.600 --> 00:01:55.100
which had to do with transitioning
from Quickdraw to Quartz,

00:01:55.100 --> 00:01:56.830
so we won't be talking about that here.

00:01:56.840 --> 00:01:59.320
But definitely your questions,
go take them through the Q&A.

00:01:59.320 --> 00:01:59.350
Thank you.

00:01:59.380 --> 00:02:04.160
And hopefully we can accelerate your
transition from Quickdraw to Quartz.

00:02:04.160 --> 00:02:07.230
Now what we will be
talking about is Quartz 2D.

00:02:10.010 --> 00:02:12.900
Ah, there you go.

00:02:13.330 --> 00:02:16.400
But first, interesting topic.

00:02:16.490 --> 00:02:18.980
What about Quartz 2D Extreme?

00:02:19.360 --> 00:02:22.270
You've heard it in the past,
previous presentations,

00:02:22.270 --> 00:02:24.470
and for those of you
who haven't heard it,

00:02:24.470 --> 00:02:27.980
it's the OpenGL-based
acceleration of the Quartz 2D API.

00:02:28.010 --> 00:02:34.870
The final version, as Peter said in his
keynote presentation,

00:02:34.870 --> 00:02:40.090
was that the final version
was not in Panther--oh,

00:02:40.090 --> 00:02:40.090
sorry, Tiger.

00:02:40.090 --> 00:02:40.090
But a debug version is
available for you to test.

00:02:40.090 --> 00:02:40.090
So...

00:02:41.000 --> 00:02:43.880
While we went off and did
all this really crazy,

00:02:43.880 --> 00:02:46.880
cool stuff,
we learned a few interesting lessons.

00:02:46.900 --> 00:02:50.800
One lesson is that for the
majority of applications,

00:02:50.820 --> 00:02:55.520
graphics rendering is not
always the bottleneck.

00:02:55.580 --> 00:03:02.100
But for the applications
that are rendering bound,

00:03:02.100 --> 00:03:08.350
we found out that if you were to not use
the Quartz 2D API in the optimal fashion,

00:03:08.520 --> 00:03:10.720
you get varying results.

00:03:10.740 --> 00:03:17.050
And so this session is really
designed to help you to try and--

00:03:17.900 --> 00:03:21.080
Change your application in
such a way that you can make

00:03:21.080 --> 00:03:26.380
optimal use of the 2D API,
such that when Quartz

00:03:26.690 --> 00:03:33.800
Extreme 2D comes online,
you will benefit from it greatly.

00:03:33.800 --> 00:03:38.180
So the last point on this things we've
learned was that if you use the API well,

00:03:38.180 --> 00:03:38.180
you get tremendous performance increases.

00:03:38.280 --> 00:03:41.470
So what you have to do as
developers is definitely run out

00:03:41.480 --> 00:03:49.070
and take your applications and
test it on Quartz 2D Extreme,

00:03:49.070 --> 00:03:49.070
the debug version.

00:03:49.070 --> 00:03:49.070
And the optimization--

00:03:50.000 --> 00:03:56.900
[Transcript missing]

00:03:57.040 --> 00:04:04.160
Let's talk about drawing your stuff
or your data into your backing stores.

00:04:04.440 --> 00:04:07.520
So what I'm going to cover
here is basically some basic

00:04:07.520 --> 00:04:09.600
graphics optimization tenants.

00:04:09.640 --> 00:04:11.760
They're sort of
micro-level optimizations,

00:04:11.760 --> 00:04:14.320
and they're sort of
macro-level optimizations.

00:04:14.410 --> 00:04:17.540
The first one is
minimizing state changes.

00:04:17.630 --> 00:04:20.060
Doesn't matter what graphics
architecture you're on,

00:04:20.110 --> 00:04:23.460
what graphics engine you're using,
minimizing state changes will

00:04:23.650 --> 00:04:25.300
increase your performance.

00:04:25.350 --> 00:04:28.600
So as we go through some
more of this session,

00:04:28.600 --> 00:04:30.770
you'd realize that I was
going to be talking to this

00:04:30.770 --> 00:04:32.760
point over and over again.

00:04:32.820 --> 00:04:35.360
The second thing is
minimize your drawing.

00:04:35.390 --> 00:04:39.530
If stuff doesn't need to be drawn,
don't draw it.

00:04:39.550 --> 00:04:41.620
If you can get rid of
data by culling it out,

00:04:41.650 --> 00:04:44.780
or know that you only need to update
a little section of the screen,

00:04:44.900 --> 00:04:45.400
do that.

00:04:45.410 --> 00:04:50.890
It will serve you well in
any kind of graphics API.

00:04:51.180 --> 00:04:54.090
The third thing is sort of--

00:04:54.830 --> 00:04:57.840
You have to be cautious about
how much memory you consume,

00:04:57.880 --> 00:04:58.080
right?

00:04:58.080 --> 00:05:00.430
Even though people say memory is
cheap and you've got a lot of it,

00:05:00.530 --> 00:05:01.170
the disk is slow.

00:05:01.180 --> 00:05:06.260
Every byte you write out to memory is a
byte that can potentially get paged off.

00:05:06.340 --> 00:05:10.720
So if you are cautious about the
type of memory that you have and

00:05:10.720 --> 00:05:15.140
whether or not you need your terabyte
of data of your atlas or your images,

00:05:15.140 --> 00:05:17.140
and you don't need it,
you only draw it at once,

00:05:17.140 --> 00:05:17.770
just get rid of it.

00:05:17.880 --> 00:05:20.100
Don't let the system try and decide, oh,
you need pages,

00:05:20.100 --> 00:05:21.380
so I've got to page this stuff out.

00:05:21.380 --> 00:05:24.310
Well, that's going to take some time,
especially on my Mac Mini.

00:05:24.700 --> 00:05:28.110
So now we're going to move on
to sort of macro-level tenants.

00:05:28.180 --> 00:05:33.780
The biggest one here is sort
of knowing your data set.

00:05:33.820 --> 00:05:38.660
It's kind of a dubious kind of statement,
but it applies to a lot of things,

00:05:38.660 --> 00:05:39.940
and it has a broad spectrum.

00:05:39.940 --> 00:05:43.320
It has to do with knowing
what types of data,

00:05:43.320 --> 00:05:45.230
knowing the size of data.

00:05:45.240 --> 00:05:47.920
I always keep on saying there are
like three numbers in the universe.

00:05:47.920 --> 00:05:49.080
Zero, nothing.

00:05:49.080 --> 00:05:51.780
One, something, and only one thing.

00:05:51.780 --> 00:05:53.180
And N, everything else.

00:05:53.180 --> 00:05:55.560
If your application falls into the
trap of the class of there's going

00:05:55.560 --> 00:05:57.200
to be nothing or there's one thing,
then fine.

00:05:57.200 --> 00:05:59.450
You can just have a very trivial
algorithm that will deal with that.

00:05:59.460 --> 00:06:02.090
But if your application says, yes,
I can open a file that

00:06:02.090 --> 00:06:04.570
has thousands of lines,
you have to have ways of

00:06:04.600 --> 00:06:06.480
dealing with thousands of lines.

00:06:06.520 --> 00:06:08.980
The same thing with images
and sizes of images,

00:06:08.980 --> 00:06:11.100
and even the types of images.

00:06:11.100 --> 00:06:13.560
So knowing what type of
data you're dealing with is

00:06:13.560 --> 00:06:14.740
definitely an important thing.

00:06:14.740 --> 00:06:19.750
The final point on macro-level tenants is
sort of you kind of have to every now and

00:06:19.750 --> 00:06:23.290
again stand at 60,000 foot level and say,
is this the right way of doing things?

00:06:23.320 --> 00:06:24.540
I know I did it before.

00:06:24.540 --> 00:06:24.650
This is the right way.

00:06:24.760 --> 00:06:25.120
This is the best way.

00:06:25.200 --> 00:06:29.580
But perhaps I should change
things around and see if I can

00:06:29.650 --> 00:06:32.930
get better performance out of it.

00:06:33.340 --> 00:06:37.450
First, we're going to move to the number
one rule in minimized state changes.

00:06:37.670 --> 00:06:38.550
Objects.

00:06:38.560 --> 00:06:40.530
Objects are paths and
different types of objects.

00:06:40.630 --> 00:06:42.100
We'll talk about those later.

00:06:42.160 --> 00:06:47.240
But you have to consider,
can think about objects as a state.

00:06:47.390 --> 00:06:48.660
Right?

00:06:48.660 --> 00:06:50.360
Even in GL.

00:06:50.360 --> 00:06:51.160
Even in video.

00:06:51.160 --> 00:06:51.960
Any type of thing.

00:06:51.960 --> 00:06:53.590
And once you have an object,
that object pretty

00:06:53.850 --> 00:06:55.000
much represents states.

00:06:55.010 --> 00:06:56.930
There's a lot of data
associated with it sometimes.

00:06:57.100 --> 00:06:59.040
But it's definitely represents states.

00:06:59.040 --> 00:07:02.710
So what you really want to do is you want
to sort of say hang on to your objects,

00:07:02.710 --> 00:07:06.040
reuse your objects,
set your object state, use your object,

00:07:06.380 --> 00:07:09.200
either release your object if you
no longer want to deal with it,

00:07:09.360 --> 00:07:10.460
or hang on to it.

00:07:10.610 --> 00:07:15.270
So within Quartz,
your objects as you retain them,

00:07:15.470 --> 00:07:20.030
sort of we kind of track your
objects in a working set.

00:07:20.040 --> 00:07:25.610
And these objects are sort of your
object references are effectively

00:07:25.610 --> 00:07:29.840
keys in terms of into any internal
caches that we might have.

00:07:29.980 --> 00:07:29.980
Right?

00:07:30.060 --> 00:07:33.000
So if you hang on to your image refs,
you know, like for instance images,

00:07:33.050 --> 00:07:35.690
we might, when you render an image,
we might color match it and

00:07:35.770 --> 00:07:37.300
do some other stuff to it.

00:07:37.340 --> 00:07:41.280
And we will retain this image.

00:07:41.280 --> 00:07:44.450
And your performance will increase
whenever you sort of go back

00:07:44.550 --> 00:07:46.390
and reuse that same image again.

00:07:46.500 --> 00:07:49.470
So just hanging on to your image
is definitely a good thing.

00:07:49.480 --> 00:07:52.450
Or hanging on to your path
or hanging on to your colors.

00:07:52.640 --> 00:07:55.770
The third thing is sort of
more related to PDF generation.

00:07:56.070 --> 00:07:59.040
If you have an image that is, you know,
whatever, how many, how big it is,

00:07:59.040 --> 00:08:02.120
but you're drawing it 60 times,
if you draw that image and

00:08:02.120 --> 00:08:04.160
then you release that image,
and then you go to the next page and you

00:08:04.180 --> 00:08:07.040
draw the image and you release the image,
what's going to actually end up happening

00:08:07.040 --> 00:08:09.520
is that you're going to end up with,
you know, the 60 copies of that image

00:08:09.520 --> 00:08:10.470
inside of your PDF file.

00:08:10.540 --> 00:08:13.650
So hanging on to that image is
probably good and when you reuse it,

00:08:13.720 --> 00:08:16.020
you get much more
efficient PDF generation.

00:08:16.040 --> 00:08:19.580
So there are other set of related
objects that we'll talk about further

00:08:19.580 --> 00:08:23.130
on in the sessions that have to
do with when you hold on to these

00:08:23.130 --> 00:08:25.540
objects and you reuse these objects,
you get much more

00:08:25.540 --> 00:08:25.540
efficient PDF generation.

00:08:25.540 --> 00:08:27.420
So I told you when to
hold on to your objects,

00:08:27.770 --> 00:08:30.520
but what about when to
release your objects?

00:08:30.560 --> 00:08:33.090
Well, the obvious time to release your
objects is when you don't need it,

00:08:33.090 --> 00:08:33.540
right?

00:08:33.540 --> 00:08:37.520
Or more optimally,
or sometimes more optimally,

00:08:37.620 --> 00:08:39.260
you might want to release
it when you know you're not

00:08:39.260 --> 00:08:40.490
going to use it for a while,
right?

00:08:40.540 --> 00:08:44.210
And by doing that, we will say, oh, yes,
you know, the guy has decided

00:08:44.210 --> 00:08:46.620
to release his object,
we can blow away our terabyte

00:08:46.850 --> 00:08:48.540
image because we no longer need it.

00:08:48.540 --> 00:08:52.540
So first we're going to start
to talk about little objects.

00:08:52.540 --> 00:08:55.020
Objects can be classified
into two types of sections.

00:08:55.040 --> 00:08:56.960
So the coverage type objects,
which is sort of like

00:08:56.960 --> 00:09:00.010
your cookie cutter sheet,
and then your colorized objects,

00:09:00.060 --> 00:09:03.190
which is sort of your color that
you're going to be pouring through

00:09:03.210 --> 00:09:04.870
this sheet to present to the user.

00:09:05.040 --> 00:09:07.940
So there are several
types of coverage objects.

00:09:08.040 --> 00:09:10.070
There are paths,
which are just general paths,

00:09:10.130 --> 00:09:11.040
and clips and text.

00:09:11.040 --> 00:09:17.000
And colorized objects, colors, patterns,
shadings, layers, and images.

00:09:17.040 --> 00:09:21.040
So now we're sort of going to
focus on coverage type objects.

00:09:21.690 --> 00:09:23.430
Paths.

00:09:24.500 --> 00:09:29.870
Paths are basically general
containers for any kind of geometry.

00:09:30.020 --> 00:09:34.820
They have curves, they have lines,
they have rectangles, ellipses,

00:09:34.820 --> 00:09:36.880
anything you want to do.

00:09:36.880 --> 00:09:41.560
One important point about paths is that
they actually represent atomic coverage.

00:09:41.590 --> 00:09:46.560
And what that means is that if you
constructed a huge crisscross path,

00:09:47.110 --> 00:09:51.220
basically the coverage for each pixel
inside of that path is computed such

00:09:51.920 --> 00:09:56.540
that the pixel is only touched once,
which is a very different

00:09:56.540 --> 00:10:00.710
scenario than if you draw a line,
line, line, the intersection points are

00:10:00.740 --> 00:10:03.600
going to be touched multiple
times as you draw each line.

00:10:03.600 --> 00:10:07.290
So depending on, for instance,
things like your blend mode and whether

00:10:07.290 --> 00:10:11.490
or not anti-aliasing is turned on or not,
you end up with little

00:10:11.490 --> 00:10:12.680
aliasing artifacts.

00:10:12.680 --> 00:10:16.440
So if you want a path rendered
atomically as one object,

00:10:16.440 --> 00:10:20.550
you put it into one big
fat path and you render it.

00:10:20.930 --> 00:10:24.930
The third thing about paths is that
we've gone through great lengths to

00:10:24.930 --> 00:10:28.360
make sure that your paths are fast.

00:10:28.360 --> 00:10:32.180
If you use path refs,
like you construct your path,

00:10:32.180 --> 00:10:36.360
and then you say CG context,
fill path or stroke path,

00:10:36.360 --> 00:10:38.530
that's going to be way faster
than you going around and saying,

00:10:38.560 --> 00:10:41.360
"Oh, jeez, I've got my data structure
which has got my 10,000 lines.

00:10:41.360 --> 00:10:45.350
Let me go through and say CG context move
to line to whatever." So if you want,

00:10:45.360 --> 00:10:48.780
or I would suggest that you
sort of build your paths up,

00:10:48.930 --> 00:10:52.360
hang on to your path refs,
and then you can reuse your path refs,

00:10:52.360 --> 00:10:55.360
and you get much better performance.

00:10:55.360 --> 00:10:58.810
If you don't use path refs,
or even if you do use path refs,

00:10:58.850 --> 00:11:02.260
you should probably try and
use the convenience APIs.

00:11:02.360 --> 00:11:04.330
Example I like to give
is the ellipse case.

00:11:04.430 --> 00:11:08.080
It's much faster for us to
generate the ellipse than for you

00:11:08.080 --> 00:11:10.350
to have to put in eight Bezieres.

00:11:10.360 --> 00:11:14.360
So if you need complex objects,
you should probably try.

00:11:14.360 --> 00:11:17.360
If there's a convenience
function API for you to use,

00:11:17.360 --> 00:11:19.350
you should probably use it.

00:11:19.960 --> 00:11:26.440
So one of the final set of two points,
avoiding state changes.

00:11:26.490 --> 00:11:29.180
So even though you've constructed
your coverage or your path

00:11:29.290 --> 00:11:33.080
that represents your coverage,
you might want to think about sort of

00:11:33.180 --> 00:11:37.970
maybe reorganizing your data such that
you draw all your blue lines together

00:11:38.020 --> 00:11:41.860
and then your green lines together,
for example.

00:11:41.860 --> 00:11:47.240
So little things like color and
actual line styles for stroking,

00:11:47.360 --> 00:11:49.570
whether it be the line
width or the dashes,

00:11:49.700 --> 00:11:52.250
you want to set that state up
and draw all of those together

00:11:52.440 --> 00:11:54.340
and then draw some other stuff.

00:11:54.340 --> 00:11:57.580
Last point on here,
knowing your geometric locality.

00:11:57.710 --> 00:12:03.510
Sort of a bizarre kind of statement.

00:12:04.460 --> 00:12:08.790
It's better off for you to,
if you know that you have a path that

00:12:08.790 --> 00:12:13.040
consists of a little point over on the
far corner and another path over there,

00:12:13.040 --> 00:12:18.840
it's better for you to use two
independent paths for those things

00:12:18.920 --> 00:12:22.830
rather than using it as one big object.

00:12:22.900 --> 00:12:26.460
So that's one thing you
have to sort of look at.

00:12:26.460 --> 00:12:29.340
If there's data over here and
there's data over here and I don't

00:12:29.340 --> 00:12:32.820
need to see the data over here,
it's nice to kind of separate the data.

00:12:34.140 --> 00:12:36.700
So let's move a little
bit on to the subpath,

00:12:36.790 --> 00:12:38.620
subsection of paths.

00:12:38.800 --> 00:12:40.280
Lines and rectangles.

00:12:40.280 --> 00:12:43.140
Well, paths are really cool for curves
and all this monster stuff,

00:12:43.140 --> 00:12:44.760
but what about just lots of lines?

00:12:44.760 --> 00:12:46.100
How do I do that fast?

00:12:46.140 --> 00:12:50.100
Well, for Tiger,
we've introduced a new Stroke Lines API.

00:12:50.100 --> 00:12:53.930
We've had DrawRex for some while now.

00:12:53.940 --> 00:12:58.380
And this is the fastest way to draw
lines and rectangles on Quartz.

00:12:58.380 --> 00:13:01.900
So you definitely want to cut
over to using stuff like that.

00:13:03.270 --> 00:13:07.900
And here our point comes back
about knowing your data set.

00:13:07.900 --> 00:13:10.740
As you can see, those are little,
small diagrams.

00:13:10.740 --> 00:13:13.660
But well, on screen they're kind of big.

00:13:13.660 --> 00:13:18.480
But basically,
if you know exactly what your layout is,

00:13:18.480 --> 00:13:22.960
and you have a huge monster,
many megabyte CAD drawing

00:13:22.960 --> 00:13:29.140
that you need to draw,
you might want to think about knowing

00:13:29.240 --> 00:13:32.280
what the data is and where it is.

00:13:32.390 --> 00:13:36.870
So there's also this stuff
about lots and lots of data.

00:13:36.990 --> 00:13:41.420
If you've got a waveform that has lots
of little itty bitty line segments,

00:13:41.420 --> 00:13:47.850
you might want to think that you should
probably distill that data down to

00:13:47.850 --> 00:13:50.410
something a little bit more optimal.

00:13:50.420 --> 00:13:52.820
You've got 10,000 lines,
and you only got 100 pixels

00:13:52.930 --> 00:13:54.130
across for your window.

00:13:54.160 --> 00:13:54.900
Guess what?

00:13:54.900 --> 00:13:58.250
The 10,000 lines,
they're not going to mean a whole lot.

00:13:58.290 --> 00:14:03.500
So what you want to do is you want
to know what needs to be drawn.

00:14:03.630 --> 00:14:06.750
So that means you don't want to draw
the stuff that doesn't need to be drawn,

00:14:06.810 --> 00:14:07.170
i.e.

00:14:07.250 --> 00:14:09.640
that part of the map that's not visible.

00:14:09.650 --> 00:14:12.570
And what you want to do is
you also want to know what is

00:14:12.570 --> 00:14:14.600
going to be too small to draw.

00:14:14.600 --> 00:14:18.710
A little tiny thing that occupies 1
to 56 of a pixel is probably not going

00:14:18.780 --> 00:14:20.700
to make a difference to the user.

00:14:20.700 --> 00:14:23.890
So you probably want to say,
kind of cull away those

00:14:23.890 --> 00:14:26.140
objects and minimize them.

00:14:26.140 --> 00:14:28.790
The last point is sort of about
going back to re-examining

00:14:28.790 --> 00:14:30.440
your architectural decisions.

00:14:30.490 --> 00:14:35.000
Huge CAD maps, for example,
are really complicated,

00:14:35.020 --> 00:14:37.370
and they have a lot of data.

00:14:37.470 --> 00:14:40.540
So knowing exactly what your data is,
if you have a set of features that

00:14:40.540 --> 00:14:43.920
are buildings and features that
are a bunch of lines and streets

00:14:43.940 --> 00:14:47.660
and pathways and bike paths,
you want to sort of kind of

00:14:47.930 --> 00:14:52.850
divide that stuff up into sort
of geometrically localized data.

00:14:52.990 --> 00:14:56.200
So if you have a lot of
different mechanisms there,

00:14:56.200 --> 00:14:57.610
there's sort of grids and quad trees.

00:14:57.870 --> 00:15:00.280
My favorite is archery,
which is sort of a-- Yeah.

00:15:00.280 --> 00:15:00.410
Yeah.

00:15:00.500 --> 00:15:03.080
It's a multi-dimensional bee tree.

00:15:03.080 --> 00:15:06.620
It allows you to-- so for 2D,
it gets you to sort of organize

00:15:06.620 --> 00:15:09.200
your things into different sections,
so that when you have your viewport,

00:15:09.360 --> 00:15:12.090
which is sort of walking around
inside of your CAD drawing,

00:15:12.090 --> 00:15:16.200
you can cull away huge sections of
data instead of re-rendering that data.

00:15:16.200 --> 00:15:19.020
So for the graphics applications that
do deal with these volumes of data,

00:15:19.030 --> 00:15:20.660
I'm sure you're doing all of the stuff.

00:15:20.660 --> 00:15:25.720
But for the other people who are sort of
not as-- have applications that large,

00:15:25.830 --> 00:15:28.960
you might want to consider
looking into some of these

00:15:28.960 --> 00:15:31.760
ways of organizing your data.

00:15:31.760 --> 00:15:40.220
So now I'm going to invite Haruno to give
us a demo for the new Path and Lines API.

00:15:40.220 --> 00:15:41.580
HARUNO KAURU: Thank you, Andrew.

00:15:41.620 --> 00:15:43.690
So I'm just going to talk about,
through code,

00:15:43.920 --> 00:15:47.790
some very simple examples of some of the
things that Andrew just talked about.

00:15:47.850 --> 00:15:50.390
This code example is QuartzLines.

00:15:50.400 --> 00:15:53.740
You want to pull that up if
you've got access to it already.

00:15:53.740 --> 00:15:58.520
And we're just going to do a very simple
example of trying to draw 10,000 lines.

00:15:58.520 --> 00:16:01.760
It sort of simulates--
arbitrary random data.

00:16:01.920 --> 00:16:05.470
But let me just run it just so
people know what we're looking at.

00:16:09.290 --> 00:16:14.430
It is supposed--it should show you some,
you know, random lines being drawn,

00:16:14.440 --> 00:16:17.140
but it's--you know,
you can use this as an example

00:16:17.160 --> 00:16:20.570
for audio waveform data,
you know, stock charts, whatever.

00:16:20.800 --> 00:16:23.310
But it's basically a set of sample data.

00:16:23.370 --> 00:16:27.710
In this case, it's 10,000 lines.

00:16:27.770 --> 00:16:33.390
So let's look at the three different
ways we're gonna actually do this.

00:16:33.390 --> 00:16:33.390
Let me just comment out
some of this stuff for now.

00:16:34.340 --> 00:16:35.430
Come into here.

00:16:35.630 --> 00:16:39.300
The first way-- Andrew's talked about
different ways of drawing lines and

00:16:39.300 --> 00:16:41.320
some of the issues associated with them.

00:16:41.320 --> 00:16:44.200
The first way is we're
going to create a new path.

00:16:44.200 --> 00:16:48.540
We're going to move to and add a line
to that path and stroke the path.

00:16:48.540 --> 00:16:51.280
Basically,
repeatedly all 10,000 lines are

00:16:51.340 --> 00:16:53.420
going to go out as separate paths.

00:16:53.420 --> 00:16:55.750
So that's our first example.

00:16:55.790 --> 00:16:58.640
Second example, instead,
what we're going to do is build

00:16:58.740 --> 00:17:01.340
a path once outside of the loop.

00:17:01.340 --> 00:17:04.540
And later,
we're just going to begin the path,

00:17:04.540 --> 00:17:06.600
add the path, and stroke the path.

00:17:06.600 --> 00:17:09.020
This is what we're
going to be timing next.

00:17:09.060 --> 00:17:12.310
Finally, the last example is--

00:17:13.830 --> 00:17:16.600
Instead, we're going to use the
Stroke Line Segments API,

00:17:16.600 --> 00:17:19.190
but that just takes an array of points.

00:17:19.340 --> 00:17:23.840
So we're just going to take our
original data and instead create

00:17:23.840 --> 00:17:26.890
these new arrays of points from that.

00:17:26.900 --> 00:17:33.410
But really, most of the work is
really being done there.

00:17:33.410 --> 00:17:33.410
So let's run this code now.

00:17:34.790 --> 00:17:37.650
So I've got these three lines,
three different ways of doing it,

00:17:37.700 --> 00:17:41.220
and they're just offset so
that people can see everything.

00:17:41.530 --> 00:17:45.510
The original one being drawn as
separate line segments is roughly

00:17:45.630 --> 00:17:50.750
around 200,000 lines per second,
but the key point is the bulk line

00:17:50.760 --> 00:17:56.440
APIs that I talked about that we
referenced is around 1.3 million.

00:17:56.580 --> 00:17:58.610
So definitely use this sample code.

00:17:58.830 --> 00:18:00.360
Try it out in your application.

00:18:00.360 --> 00:18:04.210
There's enough people that have asked
these questions in the last few years

00:18:04.210 --> 00:18:07.550
that this should be very useful for
people to test and debug some of

00:18:07.550 --> 00:18:11.400
the things and see why they're not
getting this level of performance.

00:18:12.130 --> 00:18:20.020
One last thing I'm going to do
is look at the--apply Andrew's

00:18:20.700 --> 00:18:23.680
comment of knowing your data set.

00:18:24.100 --> 00:18:27.550
So in this case,
what we're going to do is--I've

00:18:27.560 --> 00:18:30.250
got 10,000 lines that don't
necessarily all need to be drawn

00:18:30.250 --> 00:18:34.170
immediately because my window is
roughly around 1,000 pixels across.

00:18:34.330 --> 00:18:38.300
So all we're going to do is
generate a limited set of

00:18:38.310 --> 00:18:42.580
lines from the original data,
and we're just going to have a small

00:18:42.580 --> 00:18:45.870
sampling frequency that sort of goes
through that data appropriately.

00:18:45.880 --> 00:18:48.800
So we're not really going
to draw all 10,000 lines.

00:18:48.830 --> 00:18:51.000
Let's see how that works out.

00:18:53.040 --> 00:18:55.290
And obviously, you know,
we're only drawing about

00:18:55.380 --> 00:18:56.960
1,300 lines instead.

00:18:56.960 --> 00:19:00.030
It reasonably represents
the original data,

00:19:00.160 --> 00:19:01.620
so use that to your advantage.

00:19:01.640 --> 00:19:05.760
And the key thing is, it used to take,
you know, seven seconds.

00:19:05.760 --> 00:19:07.760
Now it's taking half the time, roughly.

00:19:07.790 --> 00:19:11.380
So know your data set.

00:19:11.440 --> 00:19:15.150
Take advantage of it.

00:19:15.150 --> 00:19:17.760
I'm going to pass it back
to Andrew at this stage.

00:19:22.110 --> 00:19:24.040
Thanks, Harun.

00:19:24.040 --> 00:19:26.190
So as Harun said,
the key point is know your

00:19:26.190 --> 00:19:29.500
data set and use the bulk API.

00:19:29.500 --> 00:19:34.020
So now let's talk a little
bit more about clips.

00:19:34.020 --> 00:19:39.350
Clips are sort of like paths,
but paths are sort of like set your path,

00:19:39.400 --> 00:19:39.980
go.

00:19:40.000 --> 00:19:41.660
Forget about it.

00:19:41.660 --> 00:19:45.250
Clips are more like, OK, here's a clip.

00:19:45.250 --> 00:19:47.820
I'm going to draw a whole bunch of stuff,
and I'm going to change my clip.

00:19:47.880 --> 00:19:51.500
So you want to use
clipping to your advantage.

00:19:51.580 --> 00:19:55.920
So there's some things that you can
do in order to speed up your drawing.

00:19:55.920 --> 00:19:59.530
Obviously,
the goal here is to not draw too

00:19:59.620 --> 00:20:04.450
much in addition to the state
changes thing that you want to do.

00:20:04.630 --> 00:20:08.530
So what you would like to do is sort
of cull out huge sections of objects.

00:20:08.640 --> 00:20:11.880
For instance, in the diagram there,
there's a focus in on the picture because

00:20:11.880 --> 00:20:13.460
you just want to get that cut out.

00:20:13.730 --> 00:20:16.820
But all those runs of text,
you can just ditch.

00:20:16.820 --> 00:20:20.080
And you can ditch them at sort
of an object level if you capture

00:20:20.130 --> 00:20:23.560
objects as runs of text in an array.

00:20:23.560 --> 00:20:27.420
You can look at these objects without
doing anything terribly complicated.

00:20:27.420 --> 00:20:29.450
And you can say, hey,
this entire thing is not going

00:20:29.500 --> 00:20:30.840
to touch my clipping boundary.

00:20:30.840 --> 00:20:32.540
Why don't I just not draw that?

00:20:32.540 --> 00:20:34.960
If you don't do that,
we'll end up doing that.

00:20:34.960 --> 00:20:37.350
So instead of handing us all of the
stuff where we have to go through and

00:20:37.350 --> 00:20:40.630
get fonts and glyphs and all that stuff,
we can ditch that entire thing

00:20:40.630 --> 00:20:42.840
if you don't tell us to draw it.

00:20:42.890 --> 00:20:45.400
So that's one thing, right?

00:20:45.400 --> 00:20:46.590
Culling your data.

00:20:46.930 --> 00:20:50.010
The second point is
about trivial clipping.

00:20:50.200 --> 00:20:52.770
If you know that the
data can't be culled,

00:20:52.810 --> 00:20:56.270
but you do know that you sort
of have to draw some of it,

00:20:56.270 --> 00:20:59.580
if you can, do trivial clipping.

00:20:59.580 --> 00:21:03.290
Rectangles, you say, hey, great,
let's cut the rectangle, or text, OK,

00:21:03.290 --> 00:21:07.170
instead of drawing all
1,600 characters of text,

00:21:07.250 --> 00:21:09.140
let's draw the 16 of them.

00:21:09.140 --> 00:21:13.680
So you're sort of waiting between
what your data structure is.

00:21:14.930 --> 00:21:37.260
So, definitely,
you probably want to definitely

00:21:37.260 --> 00:21:40.040
color away your objects and you
want to do trivial clipping.

00:21:40.180 --> 00:21:43.130
And the third guy is if you
don't do trivial clipping,

00:21:43.140 --> 00:21:43.880
at least use Quartz.

00:21:43.900 --> 00:21:51.620
So, okay, great, we told you how to clip,
but we also want to minimize your clips,

00:21:51.650 --> 00:21:52.680
right?

00:21:53.000 --> 00:21:57.900
Objects that are going to be
clipped and objects that are

00:21:57.950 --> 00:22:02.710
going to share the same clip,
you should probably just set the

00:22:02.900 --> 00:22:05.380
clip once and draw the objects.

00:22:05.400 --> 00:22:07.460
What you don't want to
do is you want to say,

00:22:07.550 --> 00:22:10.560
oh, geez,
I've got an object A with clip A,

00:22:10.560 --> 00:22:12.680
and then I've got an
object B with clip B,

00:22:12.680 --> 00:22:15.080
and then I want to draw
A again with clip A,

00:22:15.080 --> 00:22:18.040
and then I want to draw
B again with clip B.

00:22:18.060 --> 00:22:22.810
Why don't you just set the clip to
be A and draw all your A objects and

00:22:22.810 --> 00:22:25.700
draw your B objects with the B clip?

00:22:25.700 --> 00:22:31.050
So that's basically getting
along or talking to the point of

00:22:31.610 --> 00:22:34.280
minimizing your state changes.

00:22:34.280 --> 00:22:39.050
The second thing is you probably
want to try to clip only the

00:22:39.050 --> 00:22:41.940
things that need to be clipped.

00:22:41.940 --> 00:22:44.940
Something I see developers do a
lot of times is they have an image,

00:22:44.940 --> 00:22:47.730
opaque or transparent,
it doesn't really matter.

00:22:47.780 --> 00:22:47.850
But they clip.

00:22:47.910 --> 00:22:47.970
They clip.

00:22:47.980 --> 00:22:48.020
They clip.

00:22:48.020 --> 00:22:51.580
They clip to the bounds of the image,
and then they draw their image.

00:22:51.600 --> 00:22:53.290
That clip is useless.

00:22:53.620 --> 00:22:57.020
The image itself inherently
has its own clip.

00:22:57.070 --> 00:23:00.930
So try not to draw and try not
to set clips on things that you

00:23:00.940 --> 00:23:02.830
know you don't need to clip.

00:23:02.920 --> 00:23:06.000
So that's one important point
about minimizing your clipping.

00:23:06.010 --> 00:23:10.390
Also, in PDF and PostScript generation,
it is much more efficient

00:23:10.390 --> 00:23:11.710
to do it that way.

00:23:12.640 --> 00:23:20.810
So the last point on here is going on our
little genre of minimizing state changes.

00:23:20.900 --> 00:23:28.860
You probably want to minimize your
state changes around your clip,

00:23:28.860 --> 00:23:30.290
which gets back to the whole point of
drawing your A objects with your A clip

00:23:30.290 --> 00:23:30.290
and then your B objects with your B clip.

00:23:30.610 --> 00:23:36.030
So we're going to talk a little
bit more about some more clipping.

00:23:36.210 --> 00:23:39.090
You'd like to clip on pixel boundaries.

00:23:39.200 --> 00:23:43.180
You might have a user space,
which is rotated in that example.

00:23:43.210 --> 00:23:47.340
And the goal here is
to find a device pixel.

00:23:47.370 --> 00:23:50.040
Typically, the rotated case is sort
of almost a bad example,

00:23:50.040 --> 00:23:55.090
but it sort of gives you an
idea about the complexity of it.

00:23:55.120 --> 00:23:59.500
Mostly it would be used for
rectilinear-type transformations.

00:23:59.500 --> 00:24:01.960
So things are either
stretched or whatever.

00:24:02.110 --> 00:24:04.620
And if you want your rectangle
to hit a pixel boundary,

00:24:04.640 --> 00:24:08.170
what you really would like to do
is specify a user space point such

00:24:08.170 --> 00:24:10.510
that it will hit a device pixel.

00:24:10.560 --> 00:24:13.880
So given that you have the
user space point in user space,

00:24:13.900 --> 00:24:18.160
what you want to do is you want
to use the APIs to get the user

00:24:18.160 --> 00:24:22.640
space to device space transform,
take your point or points,

00:24:22.940 --> 00:24:27.780
transform them to device space,
then round them however you wish.

00:24:27.800 --> 00:24:29.370
And then invert transform.

00:24:29.480 --> 00:24:31.660
Those device space points
back into user space.

00:24:31.670 --> 00:24:34.870
They may not align,
but they would be a point such

00:24:34.880 --> 00:24:38.210
that if you were to draw it,
it would hit a device pixel.

00:24:38.420 --> 00:24:41.140
So that's something that
you might want to do,

00:24:41.160 --> 00:24:43.960
especially with clipping,
especially with image drawing.

00:24:43.960 --> 00:24:47.020
If you want things to hit cracks,
this is what you'd have to do.

00:24:47.040 --> 00:24:51.500
We also have convenience APIs,
CG context, convert point to device space

00:24:51.570 --> 00:24:54.920
and convert point to user space,
to convert back and forth

00:24:54.920 --> 00:24:57.090
to simplify your work.

00:24:57.300 --> 00:25:00.160
So now we're going to go into
a little bit more clipping.

00:25:00.160 --> 00:25:04.610
A common technique that
developers can use is to do

00:25:04.620 --> 00:25:07.160
pre-rasterization of the clipping.

00:25:07.160 --> 00:25:09.160
If your clip is really,
really complicated,

00:25:09.160 --> 00:25:13.160
and you probably don't want to-- and
you have to use it multiple times,

00:25:13.170 --> 00:25:16.460
and you don't really want to incur
the cost of having to rebuild that

00:25:16.470 --> 00:25:20.460
clip every time you change it,
one mechanism that you can use is that

00:25:20.460 --> 00:25:24.160
you can either-- you can pre-render
your clip into a bitmap context,

00:25:24.160 --> 00:25:27.010
for instance,
an alpha-only bitmap context,

00:25:27.190 --> 00:25:30.120
that would record the actual
coverage for the path.

00:25:30.120 --> 00:25:32.120
Then you take that path,
you hang on to that image ref,

00:25:32.200 --> 00:25:34.120
and then whenever you
need to set that clip up,

00:25:34.150 --> 00:25:37.120
you can reuse that clip by
either saying clip to mask,

00:25:37.120 --> 00:25:40.120
or you can actually say clip to image.

00:25:40.180 --> 00:25:43.120
It'll be considered at
that point an image mask.

00:25:43.120 --> 00:25:46.120
So you could have a color,
and you'd say draw image mask,

00:25:46.120 --> 00:25:49.280
or draw image,
which it'll look at the image and

00:25:49.290 --> 00:25:52.450
discover that it's only an alpha image,
and therefore it'll apply the

00:25:52.450 --> 00:25:57.120
current color through that mask to
give you the drawing that you want.

00:25:57.120 --> 00:25:59.980
So that's clipping.

00:26:00.600 --> 00:26:04.750
At the Quartz level,
text is sort of viewed as just

00:26:04.790 --> 00:26:09.700
a basic collection of paths,
cache paths, right?

00:26:09.700 --> 00:26:13.330
Your container is your font and your
glyphs are your index into all these

00:26:13.330 --> 00:26:16.220
different little elements that we use.

00:26:16.220 --> 00:26:20.220
So at our level,
this is how we look at paths effectively.

00:26:20.220 --> 00:26:23.440
So what you need to do
in order to do full text,

00:26:23.440 --> 00:26:26.820
and, of course,
text is way more complicated

00:26:26.820 --> 00:26:31.000
than just a collection of paths,
you need to use the Cocoa and

00:26:31.110 --> 00:26:35.990
Atsui APIs to do your text
layout for you and rendering.

00:26:36.350 --> 00:26:42.170
One thing that we always realize,
especially when dealing with text,

00:26:42.170 --> 00:26:45.740
is that layout is hugely expensive,
right?

00:26:45.740 --> 00:26:48.620
So, if you have a lot of text,
and you're doing a lot of

00:26:48.620 --> 00:26:51.020
drawing related to text,
I'm not just talking about

00:26:51.020 --> 00:26:51.830
the button type text.

00:26:51.840 --> 00:26:53.840
I'm talking about like documents.

00:26:54.050 --> 00:26:57.130
You want to consider caching your layout.

00:26:57.260 --> 00:26:57.860
Right?

00:26:57.860 --> 00:27:02.060
As I said, layout is the most expensive
part of text rendering.

00:27:02.060 --> 00:27:04.650
We can render the paths
like nobody's business.

00:27:04.660 --> 00:27:08.660
But when it comes to layout,
layout is hugely expensive.

00:27:08.660 --> 00:27:14.230
So, you probably want to start thinking
about if you can cache your layout,

00:27:14.230 --> 00:27:16.150
you should do that too.

00:27:16.180 --> 00:27:18.840
The last point on here is to
try and avoid state changes,

00:27:18.870 --> 00:27:19.540
obviously.

00:27:19.660 --> 00:27:22.820
Things like font size,
text rendering mode,

00:27:22.820 --> 00:27:27.560
even color have to do with state
changes in order to render your text.

00:27:27.560 --> 00:27:29.360
So,
you should probably try and minimize it.

00:27:29.360 --> 00:27:33.020
And minimize it to the point
of reorganizing your objects.

00:27:33.020 --> 00:27:34.620
I mean, if you have a web page.

00:27:34.620 --> 00:27:37.040
That has a whole bunch
of black characters.

00:27:37.080 --> 00:27:38.940
And then, you know,
a whole bunch of blue characters.

00:27:38.960 --> 00:27:41.200
It's probably wise, you know,
for you to say, set the font.

00:27:41.280 --> 00:27:42.030
Set the color to black.

00:27:42.110 --> 00:27:43.480
Render all your black text.

00:27:43.520 --> 00:27:44.710
And then set the font.

00:27:44.730 --> 00:27:45.740
And then set the color to blue.

00:27:45.890 --> 00:27:47.980
And then render all your blue text.

00:27:47.980 --> 00:27:50.530
And so, within balance, I mean,
there's a painter's model

00:27:50.530 --> 00:27:51.780
where you draw one thing.

00:27:51.780 --> 00:27:53.360
And it's supposed to
appear on top of the other.

00:27:53.410 --> 00:27:55.850
But, you know,
typically people don't like overlapping

00:27:55.850 --> 00:27:57.420
text because they can't read it.

00:27:57.480 --> 00:27:59.880
So, that's one thing that you can do.

00:28:00.080 --> 00:28:04.150
So now we're going to talk a
little bit about colorized objects.

00:28:04.220 --> 00:28:06.200
So we've spoke what?

00:28:06.770 --> 00:28:08.100
So, coverage objects.

00:28:08.100 --> 00:28:11.100
Now we're going to talk
about colorized objects.

00:28:11.100 --> 00:28:13.320
So the first colorized object is color.

00:28:13.590 --> 00:28:14.330
Color refs.

00:28:14.400 --> 00:28:18.800
Color refs represent single
sort of color spot colors.

00:28:18.800 --> 00:28:22.910
Sort of its infinite sheet of
everything being the same color.

00:28:22.910 --> 00:28:24.770
As well as patterns, right?

00:28:24.770 --> 00:28:27.710
It's still an infinite sheet,
but it's a repeating

00:28:27.710 --> 00:28:29.970
pattern that sort of goes,
continues.

00:28:30.110 --> 00:28:34.350
Using color refs are always faster.

00:28:34.350 --> 00:28:41.190
Always faster than using the
CG context set RGB color or

00:28:41.910 --> 00:28:43.250
It's more efficient.

00:28:43.410 --> 00:28:46.650
We can cache the colors, color refs,
as I said.

00:28:46.690 --> 00:28:52.970
Your color references are keys
to internal caches inside of CG.

00:28:52.970 --> 00:28:58.200
And when you reuse your color refs,
that is going to be a

00:28:58.200 --> 00:29:00.590
good advantage to you.

00:29:00.590 --> 00:29:01.800
So as I say,
even in the case where you're doing

00:29:01.800 --> 00:29:01.800
the black text versus the blue text,
use a color ref to set the text.

00:29:01.930 --> 00:29:05.160
The second thing is,
or the third thing on this slide,

00:29:05.190 --> 00:29:07.390
is about color spaces.

00:29:07.440 --> 00:29:11.490
What you'd like to do is you'd like
to use the color spaces appropriately.

00:29:11.550 --> 00:29:15.730
If you have gray and it is gray,
say it's gray.

00:29:16.000 --> 00:29:19.560
Don't say it's RGB.

00:29:19.560 --> 00:29:23.270
This helps us in many ways.

00:29:23.400 --> 00:29:26.290
It's more complicated to match
those colors versus gray colors.

00:29:26.390 --> 00:29:30.520
If something is gray or it's not CMYK,
don't convert it into CMYK because it's

00:29:30.520 --> 00:29:33.040
not always equal to the same thing.

00:29:33.040 --> 00:29:35.560
You definitely want to use your
color spaces appropriately.

00:29:35.560 --> 00:29:38.510
And as always, try to avoid color state
changes if you've got your blue

00:29:38.510 --> 00:29:40.420
text versus your black text.

00:29:40.420 --> 00:29:42.680
You know the story.

00:29:42.680 --> 00:29:45.420
The other thing is to
do with transparency.

00:29:45.420 --> 00:29:48.690
It doesn't matter what
architecture you're on,

00:29:48.710 --> 00:29:52.700
how fast your GPU is or your CPU,
dealing with transparency is

00:29:52.700 --> 00:29:54.460
encouraged at a certain cost.

00:29:54.510 --> 00:29:58.000
If an object needs to be transparent,
then say it's a transparent object.

00:29:58.000 --> 00:30:00.040
If it doesn't need to be transparent,
like it's very close to opaque,

00:30:00.050 --> 00:30:01.460
then say it's a opaque.

00:30:01.460 --> 00:30:07.390
Whenever we're dealing with transparency,
it's a full read modifier

00:30:07.390 --> 00:30:09.700
right of the destination.

00:30:09.700 --> 00:30:11.960
So if you want to
increase your fill rate,

00:30:11.970 --> 00:30:14.780
for example,
you would probably want to use things

00:30:14.780 --> 00:30:18.540
that you would realize when you actually
profile it yourself that opaque fills

00:30:18.540 --> 00:30:22.090
are much faster than transparent fills.

00:30:22.200 --> 00:30:23.940
So I told you to minimize
your state changes,

00:30:23.940 --> 00:30:25.930
and I told you to use color refs.

00:30:25.980 --> 00:30:29.810
But what happens if you have a
gradient that is a slight transition

00:30:29.830 --> 00:30:32.050
from one alpha to the next?

00:30:32.080 --> 00:30:35.370
You can go and create separate objects,
but that's somewhat wasteful in

00:30:35.370 --> 00:30:36.900
order to just change the alpha.

00:30:36.950 --> 00:30:40.450
So you can use CGContext set
alpha to get the same effect,

00:30:40.460 --> 00:30:43.720
and it's a much more
lightweight state change.

00:30:43.720 --> 00:30:46.430
It has nothing to do with
the color or color matching.

00:30:46.540 --> 00:30:49.330
It only has to do with
a transparency value.

00:30:49.420 --> 00:30:56.050
So if you use the CGContext set alpha,
you get a much faster method

00:30:56.090 --> 00:30:58.960
of doing alpha transitions.

00:30:59.060 --> 00:31:00.780
OK, let's go on to patterns.

00:31:00.830 --> 00:31:04.960
Patterns are basically
representations of tile drawing.

00:31:04.970 --> 00:31:07.600
They're a lot faster than you
going through and saying tile,

00:31:07.650 --> 00:31:09.560
tile, tile, tile, tile, tile.

00:31:09.590 --> 00:31:12.360
Patterns are also cached by courts.

00:31:12.480 --> 00:31:14.660
So what happens is that
when you draw a pattern,

00:31:14.660 --> 00:31:17.790
regardless of what space you
specified your pattern to be,

00:31:17.850 --> 00:31:22.540
the pattern-- the space that matters
or the representation that matters

00:31:22.540 --> 00:31:25.200
is the one that's actually going
to physically hit your device.

00:31:25.200 --> 00:31:27.420
So you might have a pattern
that's 1,000 by 1,000,

00:31:27.420 --> 00:31:29.870
but you're only running
it into 100 by 100.

00:31:29.880 --> 00:31:32.820
What we do is we cache the 100
by 100 color matched version.

00:31:32.820 --> 00:31:35.270
So now whenever you want to fill,
if you reuse your

00:31:35.290 --> 00:31:37.740
pattern ref all the time,
what will happen is we look

00:31:37.820 --> 00:31:40.800
that up in our internal caches,
and we'll find them and say, hey,

00:31:40.800 --> 00:31:41.400
we've got something.

00:31:41.400 --> 00:31:44.170
We don't have to go through and
call your pattern proc again and

00:31:44.170 --> 00:31:45.880
do color matching on the data.

00:31:45.960 --> 00:31:48.340
So definitely you want to
reuse your pattern refs.

00:31:48.340 --> 00:31:49.780
So that's a big advantage.

00:31:49.780 --> 00:31:52.610
And the last point on here
is about tiling boundaries.

00:31:52.830 --> 00:31:54.800
So in the previous
section about clipping,

00:31:54.800 --> 00:31:57.700
where we spoke about transforming
your user space to your device space,

00:31:57.740 --> 00:32:00.480
you probably want to do that
too in this particular case,

00:32:00.480 --> 00:32:04.260
because you do want your
patterns to hit pixel alignment.

00:32:04.260 --> 00:32:06.800
Easy way to do that is to set
the appropriate tiling mode,

00:32:06.800 --> 00:32:09.420
which is a constant spacing version
which allows your patterns to

00:32:09.420 --> 00:32:11.790
be spaced on pixel boundaries.

00:32:12.140 --> 00:32:14.420
So now let's go into shadings.

00:32:14.720 --> 00:32:17.710
Shadings represent sort of smooth
transitions between colors,

00:32:17.970 --> 00:32:18.180
right?

00:32:18.300 --> 00:32:22.240
And they're much faster than you,
obviously, drawing each scan line.

00:32:22.240 --> 00:32:26.510
Imagine doing that picture by
just drawing little thin lines of

00:32:26.510 --> 00:32:29.000
colors or even stretching an image.

00:32:29.000 --> 00:32:34.920
So you can definitely do shadings,
use shadings, and you get much faster

00:32:34.940 --> 00:32:36.850
color transitions.

00:32:36.930 --> 00:32:38.420
Shadings are also cast by Quartz.

00:32:38.460 --> 00:32:43.400
In the same way that patterns are
cached in a device-represented form,

00:32:43.610 --> 00:32:46.800
color matched and sized appropriately,
shadings are similar.

00:32:46.860 --> 00:32:50.370
So when you reuse your shading refs,
you would get-- end up picking up the

00:32:50.370 --> 00:32:52.890
cached version every time you redraw it.

00:32:53.080 --> 00:32:56.800
Final point on here is
to do with function refs.

00:32:57.020 --> 00:33:00.490
You should try and represent
function refs efficiently,

00:33:00.540 --> 00:33:00.950
right?

00:33:01.200 --> 00:33:05.030
If you're going to be running a function
that's doing some sine curve or whatever,

00:33:05.170 --> 00:33:08.020
you might want to think of a more--
a more efficient way of having the

00:33:08.140 --> 00:33:11.940
function samples get generated,
you know, or-- a more efficient way of

00:33:11.940 --> 00:33:13.860
generating your function samples.

00:33:13.860 --> 00:33:17.220
And the other thing that you
would probably want to do is that,

00:33:17.220 --> 00:33:19.820
you know, given that you have a shading
which represents an actual shading,

00:33:20.100 --> 00:33:24.650
if they share function refs,
you should probably try to reuse

00:33:24.660 --> 00:33:28.860
those function refs because your
function ref samples are also cached.

00:33:28.860 --> 00:33:31.020
So if you have a shading,
you can change the shading geometry

00:33:31.030 --> 00:33:32.860
any which way you want or even
use different types of shadings.

00:33:32.860 --> 00:33:36.860
But if you reuse your functions,
then you get much better performance.

00:33:36.860 --> 00:33:39.860
So now we're going to talk
about the big Mongo person,

00:33:39.860 --> 00:33:40.860
images.

00:33:40.860 --> 00:33:45.030
Images,
they represent sort of general data,

00:33:45.330 --> 00:33:48.860
which represent general bitmap data,
which is either color

00:33:48.860 --> 00:33:53.860
or-- which is and--sorry,
color and alpha.

00:33:53.860 --> 00:33:57.320
Images--images are the biggest
cached object that we have,

00:33:57.320 --> 00:33:57.820
right?

00:33:57.860 --> 00:33:59.620
We go through great
lengths to try and get,

00:33:59.620 --> 00:34:00.860
you know, image caching.

00:34:00.860 --> 00:34:04.120
I mean, patterns are 1Ks,
and they are used,

00:34:04.140 --> 00:34:06.850
and developers use them frequently.

00:34:06.860 --> 00:34:08.860
Images are the one that, you know,
pretty much, you know,

00:34:08.860 --> 00:34:11.860
most user interfaces are a
lot--are built with images.

00:34:11.860 --> 00:34:14.190
Images and text,
those are the big guys that we

00:34:14.200 --> 00:34:15.740
concentrate on all the time.

00:34:15.860 --> 00:34:19.860
So a few important points about images.

00:34:19.860 --> 00:34:22.850
Definitely you want to
consider in certain situations

00:34:22.850 --> 00:34:24.860
to use the image quality,
right?

00:34:24.860 --> 00:34:27.860
If you have an image
that's being down sampled,

00:34:27.860 --> 00:34:31.860
you want to probably,
depending on what you're doing,

00:34:31.860 --> 00:34:36.820
whether you're interactive mode and
you want to do things quick and dirty,

00:34:36.880 --> 00:34:38.860
you want to set the
interpolation level off,

00:34:38.860 --> 00:34:39.770
interpolation quality to low.

00:34:39.860 --> 00:34:41.950
And what will happen,
we just do a point sample,

00:34:41.950 --> 00:34:45.190
and then we can sort of render
things more appropriately when

00:34:45.190 --> 00:34:47.860
you feel appropriate--when
you feel it's appropriate,

00:34:47.860 --> 00:34:49.860
you can say,
set the image quality to high.

00:34:49.860 --> 00:34:51.860
And then that way,
we go through and do the full line cost,

00:34:51.990 --> 00:34:55.200
you know, down sample to get the,
you know, pristine quality that

00:34:55.200 --> 00:34:56.860
you guys would like.

00:34:56.940 --> 00:34:58.830
So use the interpolation
quality to your advantage.

00:34:58.870 --> 00:35:01.860
That's a good thing.

00:35:01.860 --> 00:35:06.860
The last thing is--the second
to last thing is--is sort of--

00:35:07.010 --> 00:35:10.860
also related to clips and also
related to pattern boundaries.

00:35:10.860 --> 00:35:12.830
You want to grab pixel boundaries.

00:35:12.850 --> 00:35:13.850
You want to find them and draw them,
right?

00:35:13.860 --> 00:35:17.940
If you tell us to draw an image that's
on a pixel crack--not on a pixel crack,

00:35:18.060 --> 00:35:20.140
but halfway in,
we go through great lengths to make

00:35:20.170 --> 00:35:22.860
sure that you get those nice little
anti-alias edges on the corner.

00:35:22.860 --> 00:35:26.150
So if you don't want that to happen,
align your images to

00:35:26.150 --> 00:35:27.860
your destination pixels.

00:35:27.860 --> 00:35:32.310
The last thing is sort of
using alpha effectively.

00:35:32.790 --> 00:35:36.730
As I said before previously,
that alpha is an expensive operation,

00:35:36.730 --> 00:35:39.600
causes the full read modify right.

00:35:39.600 --> 00:35:42.760
If you have an image data that
is really opaque and you just

00:35:42.760 --> 00:35:46.090
happen to fill in all the alpha
channel FFF and you say it's alpha,

00:35:46.190 --> 00:35:48.410
guess what,
you're going to get a performance

00:35:48.410 --> 00:35:50.430
penalty because we're going
to think of it as alpha.

00:35:50.520 --> 00:35:54.490
We have to do a per pixel operation to
figure out whether or not this pixel

00:35:54.490 --> 00:35:56.960
needs to be blended with the destination.

00:35:57.030 --> 00:35:59.440
If you have things that, let's say,
packed high,

00:35:59.450 --> 00:36:03.250
like you've got your alpha and your
RGB just because your rendering engine

00:36:03.260 --> 00:36:06.660
or whatever you did came in that form
but it really is an opaque image,

00:36:06.660 --> 00:36:08.670
just say alpha skip
first and then we'd say,

00:36:08.670 --> 00:36:10.210
oh, it's an opaque image.

00:36:10.310 --> 00:36:12.020
We can just blast that
to the destination.

00:36:12.020 --> 00:36:16.440
So definitely you want
to use alpha effectively.

00:36:16.440 --> 00:36:21.080
So getting more into sort of images,
knowing your pixel format.

00:36:21.290 --> 00:36:25.790
This is a whole knowing
your data set thing.

00:36:25.940 --> 00:36:28.680
First guy is Robites, right?

00:36:29.570 --> 00:36:35.510
Typically what ends up happening is that,
one, either your image is going to be

00:36:35.680 --> 00:36:40.230
aligned to the size of your image,
the width of your image,

00:36:40.300 --> 00:36:44.620
and in the case of sub-byte pixels,
it's gonna be the nearest byte.

00:36:44.620 --> 00:36:47.740
That's actually not on this slide,
but it's definitely rounded up.

00:36:47.830 --> 00:36:50.080
You want to use an alignment
that's appropriate.

00:36:50.290 --> 00:36:52.750
Definitely you want to start
off with at least the byte,

00:36:52.900 --> 00:36:55.840
rounded up to the nearest byte
if you have sub-byte pixels.

00:36:55.840 --> 00:37:00.080
The second thing is you want to
at least align up to the pixel.

00:37:00.080 --> 00:37:04.750
If you've got RGB data that
is eight bits per component,

00:37:04.750 --> 00:37:09.120
32 bits, aligning onto a 32-bit
boundary is probably -- sorry,

00:37:09.120 --> 00:37:12.510
a four-byte boundary is
probably a good thing.

00:37:12.510 --> 00:37:15.100
The next one up from
there is vector alignment.

00:37:15.140 --> 00:37:16.450
Vector alignment is also good.

00:37:16.450 --> 00:37:19.970
We have a lot of vectorized routines that
would benefit greatly from you telling us

00:37:20.040 --> 00:37:21.740
not to have to do shuffles all the time.

00:37:21.740 --> 00:37:24.310
So if you aligned your row
bytes to be vector aligned,

00:37:24.310 --> 00:37:25.550
that would be a good thing.

00:37:25.550 --> 00:37:28.320
The second one or the third one
is sort of cache line alignment.

00:37:28.320 --> 00:37:30.650
Cache line alignment,
that's sort of a dubious one because

00:37:30.710 --> 00:37:34.690
it depends on your architecture,
but 32, 64, those are good sizes.

00:37:34.690 --> 00:37:37.200
Of course,
there's wasted space on the side,

00:37:37.200 --> 00:37:38.990
but this is what you
have to sort of gauge,

00:37:38.990 --> 00:37:41.940
whether or not that wasted space
is worth the effort or worth the

00:37:41.940 --> 00:37:44.770
performance advantage versus not.

00:37:44.770 --> 00:37:47.570
So the next thing is component size.

00:37:47.800 --> 00:37:51.740
Well, 8 bits, 16 bits,
32 bits and floats, those are all good.

00:37:51.740 --> 00:37:55.600
Your 11-bit data, for example,
that's probably not going

00:37:55.600 --> 00:37:57.240
to go down the optimal path.

00:37:57.260 --> 00:38:01.400
So if you have data that is 11 bits,
if you're only going to draw it once,

00:38:01.400 --> 00:38:03.690
let's say, and you're going to rely
on the image caching,

00:38:03.690 --> 00:38:05.700
then sure, fine, set your 11-bit data.

00:38:05.750 --> 00:38:08.840
But if you're going to draw it
repeatedly and you figure that it's

00:38:08.840 --> 00:38:12.830
going to get drawn out of your cache
and you're going to reuse it often

00:38:12.960 --> 00:38:16.990
over and over but not too frequently,
you might want to sort of move

00:38:16.990 --> 00:38:19.880
that into a different 16-bit,
for example.

00:38:19.880 --> 00:38:22.160
That will be a lot more optimal path.

00:38:22.160 --> 00:38:24.930
So those are component sizes.

00:38:24.940 --> 00:38:27.330
More about pixel format.

00:38:27.510 --> 00:38:29.390
Premultiplied data.

00:38:29.390 --> 00:38:32.370
People always wonder, geez,
do I premultiply my data or not?

00:38:32.370 --> 00:38:33.920
Well, that's a good question.

00:38:33.920 --> 00:38:36.790
If you have data that
you're working with,

00:38:36.850 --> 00:38:39.440
like pixels that you're actually
physically manipulating,

00:38:39.440 --> 00:38:43.240
you've got some rendering engine,
if it's better for you

00:38:43.240 --> 00:38:46.750
to work with alpha,
premultiplied alpha, then sure, do so.

00:38:46.760 --> 00:38:49.560
We have paths that will handle that.

00:38:49.770 --> 00:38:52.960
But if you're not,
don't try to premultiply the

00:38:52.960 --> 00:38:55.230
data for us because we can do it.

00:38:55.310 --> 00:38:56.690
We don't need any help.

00:38:56.760 --> 00:39:02.030
And sometimes, as a second point on here,
if you try to premultiply the data ahead

00:39:02.030 --> 00:39:06.000
of time in order to save us time but
you just happen to do the wrong thing,

00:39:06.000 --> 00:39:09.520
like color match it or interpolate
it or something like that,

00:39:09.520 --> 00:39:11.760
we end up having to undo
your premultiplication.

00:39:11.900 --> 00:39:16.180
So the best advice is for you to just,
if you have data that's unpremultiplied,

00:39:16.180 --> 00:39:17.450
leave it unpremultiplied.

00:39:17.450 --> 00:39:19.980
If you have data that you want
to work with premultiplied,

00:39:20.210 --> 00:39:20.970
sure, that's fine.

00:39:20.980 --> 00:39:22.620
Use the premultiplication there.

00:39:22.930 --> 00:39:26.470
That's a very important point.

00:39:26.780 --> 00:39:30.090
Okay, so now let's talk a little bit
about knowing your Indian-ness.

00:39:30.210 --> 00:39:36.440
We all heard about the switch.

00:39:36.440 --> 00:39:41.220
So we're wondering how we're
going to deal with that.

00:39:41.220 --> 00:39:41.220
So images are considered
at the API level to be a--

00:39:41.320 --> 00:39:43.440
Byte, order, stream.

00:39:43.440 --> 00:39:47.280
And what that means is most significant
to least significant repeated

00:39:47.280 --> 00:39:50.080
ad infinitum for every scanline.

00:39:50.080 --> 00:39:53.180
We've added some new bitmap info
constants that you can mask in

00:39:53.180 --> 00:39:54.900
when you create your objects.

00:39:54.900 --> 00:39:58.130
And what they are,
are basically-- it tells

00:39:58.130 --> 00:40:00.180
us basically a swap unit.

00:40:00.180 --> 00:40:05.700
And the swap unit is effectively
applied to entire stream in sequence.

00:40:05.700 --> 00:40:06.940
There's no skipping.

00:40:06.940 --> 00:40:10.710
It's sort of you have your image data,
and we do swaps of the

00:40:10.880 --> 00:40:14.070
stream as we go into pixels.

00:40:14.180 --> 00:40:17.300
So as developers, when you're running
on the Intel platform,

00:40:17.320 --> 00:40:21.900
you probably want to be
prepared for image data.

00:40:21.900 --> 00:40:25.310
If you are asking for
data or manipulating data,

00:40:25.400 --> 00:40:29.280
you probably want to be prepared
to receive this kind of data.

00:40:29.360 --> 00:40:33.820
So you can test to find out
what the image bitmap format

00:40:33.820 --> 00:40:38.520
is by asking get bitmap info,
and that will give you the actual mask.

00:40:38.600 --> 00:40:41.290
That you can sort of-- sorry,
the info field,

00:40:41.290 --> 00:40:46.000
which you can mask off to say, geez,
is it big Indian, is it little Indian,

00:40:46.000 --> 00:40:47.260
or is it host?

00:40:47.260 --> 00:40:50.380
We've applied host here to sort of say,
I want it to be host.

00:40:50.380 --> 00:40:51.220
I don't want to care.

00:40:51.220 --> 00:40:53.460
It's a relative fashion
versus an absolute.

00:40:53.520 --> 00:40:59.740
So you have those three sets of-- or
three classes of constants to use.

00:40:59.740 --> 00:41:03.340
So let's say you're on an Intel machine,
and you have some data,

00:41:03.340 --> 00:41:07.000
and you want to apply this
Indian thing to go fast.

00:41:07.000 --> 00:41:08.500
Well.

00:41:08.500 --> 00:41:12.460
Our suggestion is to only do
this for things that really,

00:41:12.460 --> 00:41:14.600
really make sense.

00:41:14.670 --> 00:41:20.280
Things like RGB data that's
swapped on a 32-byte boundary,

00:41:20.280 --> 00:41:22.600
that doesn't make a lot of sense.

00:41:22.600 --> 00:41:25.440
And there are probably not going
to be too many optimal paths

00:41:25.440 --> 00:41:27.780
to pick this kind of data up.

00:41:27.780 --> 00:41:31.280
So you probably want to stay
away from stuff like that.

00:41:31.420 --> 00:41:35.370
But definitely,
things that are like 32-byte,

00:41:35.370 --> 00:41:38.400
that are ARGB, or even skip RGB,
then you can apply the 32-byte.

00:41:38.400 --> 00:41:45.020
So the important things to know
about whether or not you should

00:41:45.020 --> 00:41:49.190
apply this byte order swap flag,
it has to do with one,

00:41:49.190 --> 00:41:53.430
your component size, two,
your pixel size, and three,

00:41:53.430 --> 00:41:54.700
your row bytes.

00:41:54.710 --> 00:41:59.680
So the best way for you to figure out
whether or not you should use these

00:42:00.150 --> 00:42:05.820
flags is you think about it as the
component size or the pixel size must

00:42:05.820 --> 00:42:08.300
be congruent to the value you want.

00:42:08.420 --> 00:42:11.450
So if it's 16-bit components
or 16 bits per pixel,

00:42:11.680 --> 00:42:15.200
yes, you can turn on the swapping,
use the swapping.

00:42:15.270 --> 00:42:16.930
As well as row bytes, right?

00:42:17.060 --> 00:42:20.190
That's obvious,
because you really don't want us to be

00:42:20.190 --> 00:42:22.890
swapping across scanline boundaries.

00:42:22.990 --> 00:42:25.330
So you have to use this with caution.

00:42:25.480 --> 00:42:30.270
But in general,
these flags are really useful and

00:42:30.270 --> 00:42:33.270
allows you to go a lot faster,
because we have a lot of very,

00:42:33.270 --> 00:42:36.540
very tuned paths for these cases.

00:42:36.610 --> 00:42:38.940
So now we're going to move on
to color space and color spaces.

00:42:38.940 --> 00:42:41.900
So even though you
know your pixel format,

00:42:41.900 --> 00:42:43.890
you want to know what color space to use.

00:42:43.900 --> 00:42:47.240
Well, our suggestion is that you should
use the generic color spaces,

00:42:47.240 --> 00:42:48.040
right?

00:42:48.040 --> 00:42:52.240
We have lots of generic color spaces,
which are RGB, CMYK, and gray.

00:42:52.240 --> 00:42:56.880
You want to use those for your data.

00:42:56.880 --> 00:42:57.920
Which one do you use?

00:42:57.920 --> 00:43:01.480
Use the one with the least number of
components for which you have data.

00:43:01.480 --> 00:43:06.580
In my example about colors,
you don't want to say, oh, jeez,

00:43:06.580 --> 00:43:08.970
let's make it RGB when you have gray.

00:43:09.010 --> 00:43:10.330
Just use gray.

00:43:10.590 --> 00:43:12.600
So don't try and coerce your
data into something else.

00:43:12.600 --> 00:43:15.220
If you've got data,
we have color spaces that suit you.

00:43:15.240 --> 00:43:18.280
We have all sorts of RGB gray.

00:43:18.280 --> 00:43:21.670
And we have a lot of other color spaces,
like calibrated stuff,

00:43:21.670 --> 00:43:23.220
that you can use also.

00:43:23.320 --> 00:43:27.040
So definitely avoid coercing your data.

00:43:27.070 --> 00:43:31.130
So other people sometimes want to say,
jeez, well,

00:43:31.130 --> 00:43:32.720
I really want my images to go fast.

00:43:32.720 --> 00:43:34.720
I don't want to have to go
through this color conversion

00:43:34.720 --> 00:43:36.480
bottleneck or color conversion hit.

00:43:36.500 --> 00:43:37.990
How can I avoid it?

00:43:38.190 --> 00:43:41.210
Well,
you can use the destination color space.

00:43:41.220 --> 00:43:43.370
If you say that your image is
in a destination color space,

00:43:43.500 --> 00:43:45.750
we don't incur any color
matching penalties.

00:43:45.950 --> 00:43:47.290
But there's a catch.

00:43:47.300 --> 00:43:49.570
The data is in color match.

00:43:49.680 --> 00:43:50.860
So it's not color correct.

00:43:50.910 --> 00:43:51.560
It's not color managed.

00:43:51.590 --> 00:43:52.920
So you've got to be cautious about that.

00:43:53.010 --> 00:43:54.500
If you want it to go fast, then fine.

00:43:54.500 --> 00:43:57.240
Sometimes if you want to
create color correct data,

00:43:57.240 --> 00:43:59.080
you probably don't want
to do that instead.

00:43:59.120 --> 00:44:01.390
You want to use a generic color space.

00:44:01.500 --> 00:44:04.120
The last point on there is,
what if I don't know my color space?

00:44:04.130 --> 00:44:04.880
Where do I get it from?

00:44:04.880 --> 00:44:06.700
Well,
you can get it from the bitmap context,

00:44:06.700 --> 00:44:07.900
or you can use a display profile.

00:44:07.900 --> 00:44:10.520
In your examples,
for I think the worm example,

00:44:10.520 --> 00:44:13.210
there's a method of getting
the display profile.

00:44:13.320 --> 00:44:16.270
So that's what you'd use
to go for window contexts.

00:44:17.500 --> 00:44:20.400
Um, images and caching.

00:44:20.650 --> 00:44:23.940
Strange thing, but sometimes useful.

00:44:24.020 --> 00:44:26.930
You got, like, a 16-megabyte

00:44:27.220 --> 00:44:28.960
file, which is a TIF file.

00:44:28.960 --> 00:44:32.160
And you really want to
render a little thumbnail.

00:44:32.170 --> 00:44:35.880
Common technique that we suggest to
developers is to pre-render the data.

00:44:35.880 --> 00:44:38.950
And how you would do that is
that you'd create a bitmap

00:44:38.950 --> 00:44:43.800
context of the appropriate size
and color space-- remember,

00:44:43.810 --> 00:44:47.690
either destination or
generic-- and pixel format,

00:44:47.790 --> 00:44:49.120
alpha or not.

00:44:49.210 --> 00:44:51.360
If your image is rotated,
you probably want alpha.

00:44:51.410 --> 00:44:53.860
If it's not rotated and it's rectilinear,
it's going to fit right

00:44:53.860 --> 00:44:55.080
inside of your destination.

00:44:55.280 --> 00:44:58.600
You can create something
that doesn't require alpha.

00:44:58.600 --> 00:45:02.080
That's also going to be a
performance speedup for you.

00:45:02.200 --> 00:45:03.400
So you create your destination.

00:45:03.460 --> 00:45:05.740
You draw your image
into the bitmap context.

00:45:05.740 --> 00:45:08.460
Then you ask the bitmap
context for its image.

00:45:08.470 --> 00:45:10.570
And then you render the image instead.

00:45:10.670 --> 00:45:12.100
Don't render the terabyte image.

00:45:12.100 --> 00:45:14.100
Render the little tiny thumbnail.

00:45:14.290 --> 00:45:16.310
So that's one way of caching.

00:45:16.690 --> 00:45:20.710
The second way of caching
is sort of more advanced.

00:45:21.060 --> 00:45:22.660
It has to do with data providers.

00:45:22.700 --> 00:45:25.100
You all see these data provider
things that we have to create.

00:45:25.150 --> 00:45:26.620
In image IO, there's data sources.

00:45:26.620 --> 00:45:33.140
It represents the data source,
where you're getting your bits from.

00:45:33.250 --> 00:45:39.290
But it effectively decouples your
image specification of what it is,

00:45:39.290 --> 00:45:41.540
from the actual data source.

00:45:41.580 --> 00:45:45.050
And because we cache images,
or your image addressor

00:45:45.050 --> 00:45:49.530
uses keys to caches,
you can sort of create your image,

00:45:49.570 --> 00:45:53.340
create your source-- or sorry,
create your source first, obviously,

00:45:53.340 --> 00:45:54.600
which is your data provider.

00:45:54.600 --> 00:45:56.700
Then create your image,
wrap it around that,

00:45:56.700 --> 00:45:57.860
and then draw your image.

00:45:57.860 --> 00:45:58.980
And you say, OK, great.

00:45:58.980 --> 00:45:59.940
I want to hang on to my source.

00:45:59.940 --> 00:46:01.380
I don't want to evict all that data.

00:46:01.380 --> 00:46:03.240
So what I'm going to do is I'm
going to hang on to my source,

00:46:03.240 --> 00:46:04.380
but I'm going to blow away my image.

00:46:04.430 --> 00:46:06.200
At that point, we say, oh,
you've destroyed the image.

00:46:06.220 --> 00:46:07.780
So we blow away our cache version.

00:46:07.780 --> 00:46:09.340
But you still have your data source.

00:46:09.340 --> 00:46:11.160
Now,
there are lots of different techniques

00:46:11.160 --> 00:46:14.360
that you can use to minimize the effects
of hanging on to that data source.

00:46:14.360 --> 00:46:14.360
Right?

00:46:14.360 --> 00:46:17.040
You can purge the data
source when you see fit.

00:46:17.040 --> 00:46:17.540
Right?

00:46:17.540 --> 00:46:20.000
Or you can pre-render your data source.

00:46:20.000 --> 00:46:22.160
Like, for instance,
the first time you use your image,

00:46:22.160 --> 00:46:24.200
you can pre-render it
or pre-decompress it.

00:46:24.200 --> 00:46:24.700
Right?

00:46:24.710 --> 00:46:26.900
And then when you draw your image,
it's already going to

00:46:26.900 --> 00:46:27.900
be pre-decompressed.

00:46:27.930 --> 00:46:31.370
So there's lots of different ways
that you can use data providers

00:46:31.440 --> 00:46:35.740
to your advantage to sort of
deal with decoupling this,

00:46:35.740 --> 00:46:38.560
where am I getting my image data
from versus the image that I'm

00:46:38.560 --> 00:46:40.060
actually going to use to draw.

00:46:40.080 --> 00:46:44.300
So you can definitely start using data
providers in a more appropriate fashion.

00:46:44.320 --> 00:46:46.350
So you can start sort
of dealing with caching,

00:46:46.360 --> 00:46:48.360
doing your own caching,
doing your own pre-decompression,

00:46:48.360 --> 00:46:49.730
doing a lot of these different things.

00:46:49.740 --> 00:46:51.940
And even in the previous
example about image caching,

00:46:51.940 --> 00:46:55.900
you can actually have an image that
is actually-- you have the data

00:46:55.980 --> 00:46:58.960
provider that is there sitting there,
but you haven't physically

00:46:58.960 --> 00:46:59.820
made memory for it.

00:46:59.820 --> 00:47:02.940
And it's only when the request happens
for the first time do you actually say,

00:47:02.940 --> 00:47:04.850
oh, geez, actually,
let me actually draw my little

00:47:04.850 --> 00:47:06.540
thumbnail for my two terabyte image.

00:47:06.540 --> 00:47:08.820
And then that way,
you can ditch the image when

00:47:08.860 --> 00:47:10.700
you see it's appropriate.

00:47:10.700 --> 00:47:14.690
So that's another way of sort of an
advanced technique for getting of some of

00:47:14.690 --> 00:47:18.000
the penalties associated with large data.

00:47:18.200 --> 00:51:40.600
[Transcript missing]

00:51:41.490 --> 00:51:46.120
So in this case,
this is the key code that

00:51:46.170 --> 00:51:47.160
we're really looking at.

00:51:47.160 --> 00:51:52.420
Everything else around it is really-- so
this is about 14 operations per second.

00:51:52.420 --> 00:51:53.890
Instead, let's move on.

00:51:53.950 --> 00:51:57.430
What if we were to just have
CG do the caching for us,

00:51:57.440 --> 00:52:00.590
because all we're going to do is
repeatedly draw that image instead.

00:52:00.600 --> 00:52:02.520
And this is the second example.

00:52:02.570 --> 00:52:04.360
Here,
we're just going to draw that image.

00:52:04.360 --> 00:52:09.450
Let's go back to our example
to go on to the second case.

00:52:09.470 --> 00:52:11.780
We're up to about 1,000
operations per second.

00:52:11.780 --> 00:52:15.660
So in this case, CG is just basically
blasting through that data,

00:52:15.660 --> 00:52:17.300
because it's already cached.

00:52:18.200 --> 00:52:21.920
What if we, as Andrew mentioned earlier,
what if we ended up using

00:52:21.930 --> 00:52:24.330
CG bitmap context to actually
do the caching for us?

00:52:24.400 --> 00:52:27.730
So there's quite a bit of code one has
to come up with in terms of all of the

00:52:27.730 --> 00:52:30.790
details of creating the bitmap context.

00:52:30.860 --> 00:52:33.750
When we're done with it,
what we're going to do is draw our

00:52:33.810 --> 00:52:36.980
original image into that bitmap context.

00:52:36.980 --> 00:52:39.970
And once we're done with it,
from the bitmap context,

00:52:39.980 --> 00:52:42.860
we're going to now have
our cached image instead.

00:52:42.860 --> 00:52:45.570
One other thing that Andrew was
referring to earlier was,

00:52:45.580 --> 00:52:47.800
this bitmap context,
we're actually creating an

00:52:47.890 --> 00:52:49.640
display RGB color space.

00:52:49.680 --> 00:52:50.870
So have a look at the code.

00:52:50.950 --> 00:52:54.040
It's very simple to actually
get at the RGB color space.

00:52:54.040 --> 00:52:55.410
That's the one we're going to be doing.

00:52:55.420 --> 00:52:59.660
We're going to match directly to
that space once and be done with it.

00:52:59.800 --> 00:53:02.520
And finally, all we're really going to do
in terms of our test is just

00:53:02.660 --> 00:53:05.020
draw the cached image instead.

00:53:05.020 --> 00:53:08.620
So let's see how long that took in
terms of the operations per second.

00:53:08.620 --> 00:53:09.620
Roughly the same thing.

00:53:09.620 --> 00:53:12.300
Basically,
CG is doing the same level of caching

00:53:12.300 --> 00:53:14.360
effectively as you would end up doing.

00:53:14.430 --> 00:53:17.060
So better for you to just
hold onto your image refs.

00:53:17.080 --> 00:53:21.570
Instead, what if instead we were
to use a layer ref?

00:53:21.740 --> 00:53:23.440
This is my fourth example.

00:53:23.510 --> 00:53:25.810
In the layer ref, the API is very simple.

00:53:25.820 --> 00:53:31.940
You don't have to worry about the details
of what type of image from-- sorry,

00:53:31.950 --> 00:53:34.100
what type of bitmap
context I want to create.

00:53:34.230 --> 00:53:37.000
Just get the content,
create the layer from the context,

00:53:37.000 --> 00:53:38.480
and then just draw the image into it.

00:53:38.580 --> 00:53:41.410
So we're basically very simple.

00:53:41.560 --> 00:53:43.600
Performance wise--

00:53:44.430 --> 00:53:46.850
roughly the same,
so in all of those cases you know the

00:53:46.990 --> 00:53:51.300
code is much simpler so definitely
you want to use that instead.

00:53:51.300 --> 00:53:54.870
My next example is where you
may have your own rendering

00:53:55.060 --> 00:53:59.540
engine where you've got,
you know, you are drawing repeatedly

00:53:59.540 --> 00:54:03.620
to it and you want to just
draw that image to the screen,

00:54:03.620 --> 00:54:07.860
so I'm simulating that by just drawing
a random rectangle into my bit map

00:54:07.860 --> 00:54:11.680
context and the bit map context
represents my off screen bit map

00:54:11.680 --> 00:54:15.990
that I've -- that I'm drawing into
and I want to draw that repeatedly

00:54:15.990 --> 00:54:18.560
or draw that as fast as possible.

00:54:18.560 --> 00:54:23.870
Basically in this case because that image
is immutable you do want to create a

00:54:24.010 --> 00:54:26.840
new image out of it and then release it.

00:54:26.940 --> 00:54:31.130
If you were to hold on to that image
you would probably get the cache

00:54:31.130 --> 00:54:35.020
representation that was there already,
so let's look at the

00:54:35.050 --> 00:54:36.770
performance in this one.

00:54:36.950 --> 00:54:38.310
These are our rectangles.

00:54:38.400 --> 00:54:42.910
We're roughly at around
287 operations per second.

00:54:43.750 --> 00:54:48.160
Better yet, if you can draw everything
through the CG API,

00:54:48.160 --> 00:54:50.840
and you do not need to touch
the bits directly yourself,

00:54:50.840 --> 00:54:52.160
just use LayerRef instead.

00:54:52.160 --> 00:54:56.930
And the reason for that is we can
actually do-- let me jump to it-- much,

00:54:57.140 --> 00:54:58.430
much better caching of it.

00:54:58.560 --> 00:55:00.520
So LayerRefs are the way to go.

00:55:00.520 --> 00:55:03.840
And take advantage of them.

00:55:03.970 --> 00:55:08.630
CG Image IO, there's been several
sessions on it already.

00:55:08.640 --> 00:55:09.400
It's very simple.

00:55:09.400 --> 00:55:11.860
I'm not going to go into detail,
but basically, in this case,

00:55:11.860 --> 00:55:13.680
I've got a test image
that I'm loading up.

00:55:13.680 --> 00:55:20.910
Going to use CG Image IO using an image,
a source ref, and just draw the image.

00:55:21.490 --> 00:55:26.110
My point here is, in this case,
it's actually taking 23

00:55:26.110 --> 00:55:27.940
operations per second.

00:55:27.970 --> 00:55:30.620
What's really going on here is
the entire image is being decoded.

00:55:30.620 --> 00:55:31.840
It's actually being color-matched.

00:55:31.840 --> 00:55:33.730
It's also being down-sampled.

00:55:33.810 --> 00:55:36.620
So everything's being done at this point.

00:55:36.650 --> 00:55:43.940
Instead, what if we were to do some image
I/O decompression caching so we

00:55:43.940 --> 00:55:47.660
could get rid of one of those cases?

00:55:47.660 --> 00:55:51.400
And to do that, all we have to do is--

00:55:55.400 --> 00:55:57.300
That's actually, I don't see it here.

00:55:57.370 --> 00:56:00.590
But it's probably in
the create image code.

00:56:00.600 --> 00:56:05.130
But we want to pass in an option
to the CGImageCreate so that we can

00:56:05.180 --> 00:56:07.620
actually get the caching done for us.

00:56:07.620 --> 00:56:09.480
So let's look at that running.

00:56:09.480 --> 00:56:14.040
And in this case,
it's now 43-- double the performance.

00:56:14.040 --> 00:56:18.540
So what we've actually done is just,
the JPEG is now no longer

00:56:18.540 --> 00:56:21.120
being decompressed repeatedly.

00:56:21.120 --> 00:56:25.040
But instead, what we're seeing is the
image is being downsampled.

00:56:25.040 --> 00:56:30.020
And I've actually scaled it so that
we can defeat CG's caching instead.

00:56:30.050 --> 00:56:32.620
So at this stage,
I'd like to pass it back to Andrew.

00:56:32.620 --> 00:56:34.180
ANDREW WONG: Thanks, Arun.

00:56:40.130 --> 00:56:42.180
So the key points--reuse your image refs.

00:56:42.420 --> 00:56:45.840
Another key point--switch
from bitmap context to layers.

00:56:45.960 --> 00:56:48.840
Third point--use
ImageIO where appropriate.

00:56:48.990 --> 00:56:53.000
Okay,
so now we've told you how to draw your

00:56:53.000 --> 00:56:56.170
data into the Backing Store efficiently,
and now we're going to start

00:56:56.270 --> 00:56:58.100
talking about how to get
your data from your Backing

00:56:58.230 --> 00:57:00.540
Store onto the screen efficiently.

00:57:01.230 --> 00:57:04.890
So, graphics architecture slide,
you've seen it before.

00:57:04.970 --> 00:57:08.800
As I said,
we're concentrating not on the part

00:57:08.800 --> 00:57:15.620
that's drawing into the backing store,
but we're concentrating more on the part

00:57:15.620 --> 00:57:20.810
where the Quartz compositor takes all
the surfaces and all the backing stores,

00:57:20.810 --> 00:57:20.810
generates them together to produce
the final output on the frame buffer.

00:57:20.810 --> 00:57:20.810
So, flushing, right?

00:57:21.550 --> 00:57:23.630
A lot of users sort of
just flush willy-nilly.

00:57:23.810 --> 00:57:25.500
You probably want to stop that.

00:57:25.500 --> 00:57:28.720
You make sure that what you
flush is what the developer--is

00:57:28.720 --> 00:57:31.670
what the user needs to see,
not what you just happened

00:57:31.720 --> 00:57:33.000
to draw at the moment.

00:57:33.000 --> 00:57:36.170
Users would prefer to see an
atomic frame show up and say,

00:57:36.170 --> 00:57:40.250
"Hey, here's your result," as opposed
to things trickling on screen.

00:57:40.250 --> 00:57:43.810
So definitely, you want to flush only
what needs to be flushed.

00:57:43.870 --> 00:57:47.490
Second point about flushing is that
if you try to flush faster than

00:57:47.490 --> 00:57:49.400
the refresh rate of the monitor,
the user's not going to see it.

00:57:49.900 --> 00:57:52.450
So don't flush faster than the
refresh rate in the monitor.

00:57:52.650 --> 00:57:55.940
Try to flush in a more efficient way.

00:57:55.940 --> 00:57:58.400
If you don't flush in
a more efficient way,

00:57:58.410 --> 00:58:01.460
basically you're just going to
consume tons of CPU in order to

00:58:01.460 --> 00:58:03.140
get that data onto the screen.

00:58:03.200 --> 00:58:09.100
So definitely minimizing what you
flush is a definite advantage.

00:58:09.100 --> 00:58:11.640
So let's see a little bit about that.

00:58:11.640 --> 00:58:15.210
So we've got a little timeline where
we're running our refresh going at VBL1,

00:58:15.220 --> 00:58:16.260
VBL2, VBL3.

00:58:16.260 --> 00:58:17.220
We got an application.

00:58:17.220 --> 00:58:17.640
It's green.

00:58:17.760 --> 00:58:19.200
It's all good to go.

00:58:19.200 --> 00:58:22.640
Application comes in at VBL1.

00:58:22.640 --> 00:58:25.570
Screen refreshes,
and that's what you see on the screen.

00:58:25.870 --> 00:58:29.790
At subsequent, before VBL2,
application draws A,

00:58:29.790 --> 00:58:32.820
consumes a chunk of CPU and
GPU resources to do so.

00:58:32.820 --> 00:58:35.440
Then application draws
a little bit again,

00:58:35.440 --> 00:58:38.930
draws B, consumes even more CPU and
GPU resources to draw B.

00:58:39.390 --> 00:58:43.140
But guess what?

00:58:43.140 --> 00:58:43.140
VBL2 gets what the
user's going to see--B.

00:58:43.580 --> 00:58:44.930
So, let's try again.

00:58:45.050 --> 00:58:47.500
Do C, consume even more CPU.

00:58:47.560 --> 00:58:48.800
Do some more stuff.

00:58:48.830 --> 00:58:49.870
Lots of flushing.

00:58:49.900 --> 00:58:52.000
Lots of drawing and lots of flushing.

00:58:52.000 --> 00:58:53.930
And then finally ends through Z.

00:58:54.540 --> 00:58:56.700
That's a lot of stuff.

00:58:56.710 --> 00:58:57.820
Lots of CPU.

00:58:58.110 --> 00:58:59.520
But guess what the user is going to see.

00:58:59.520 --> 00:59:01.360
Just Z.

00:59:01.420 --> 00:59:05.970
So wouldn't it be nice if the
developer could-- or you guys-- or

00:59:05.970 --> 00:59:09.210
your applications would be a little
bit more optimal than what it flushed?

00:59:09.220 --> 00:59:13.530
And get rid of all of those guys
and then look at the resources used

00:59:13.530 --> 00:59:15.940
in order to render those frames.

00:59:16.020 --> 00:59:20.080
So definitely,
if you want to increase your

00:59:20.080 --> 00:59:23.280
performance in your application,
don't overflush.

00:59:23.280 --> 00:59:29.340
What you want to do is you want to use
an optimal flushing kind of mechanism.

00:59:29.370 --> 00:59:34.480
So one suggestion is to use
animated-- for animated content,

00:59:34.480 --> 00:59:36.060
you probably want to use a timer.

00:59:36.080 --> 00:59:38.360
Have your timer run at the
refresh rate of the monitor,

00:59:38.360 --> 00:59:40.400
or half the refresh rate of the monitor.

00:59:40.400 --> 00:59:44.110
The second thing about your drawing is
that you should probably try to-- the

00:59:44.110 --> 00:59:49.370
refresh rate should be greater than
what it takes for you to draw a frame.

00:59:49.380 --> 00:59:52.020
Because you don't want to have
your timer backing up on itself.

00:59:52.040 --> 00:59:53.040
So definitely.

00:59:53.040 --> 00:59:54.420
Use the timers.

00:59:54.420 --> 00:59:58.100
Another thing about it is to-- which
is a very important point about

00:59:58.100 --> 01:00:01.260
drawing-- is that what you really
would like to do is you really would

01:00:01.260 --> 01:00:04.800
like to decouple your visualization
engine from your data engine.

01:00:04.800 --> 01:00:07.630
If your data engine is going off and
running off and touching the network

01:00:07.630 --> 01:00:10.110
and churning out a bunch of files,
you don't want to have the

01:00:10.300 --> 01:00:11.560
user penalized for that.

01:00:11.560 --> 01:00:14.450
You want the user to be able to
resize and snap around and do all

01:00:14.530 --> 01:00:18.050
this extra stuff whenever he wants to.

01:00:18.070 --> 01:00:20.310
But your data can get
rummaged on the disk,

01:00:20.310 --> 01:00:22.800
and you can do all that heavy lifting.

01:00:22.800 --> 01:00:24.550
And you can do it in the background.

01:00:24.630 --> 01:00:27.200
So another example of that would be,
for instance, like TextEdit.

01:00:27.200 --> 01:00:29.540
TextEdit does this layout when
you open a really large document.

01:00:29.540 --> 01:00:31.740
The layout actually happens
on a separate thread.

01:00:31.740 --> 01:00:34.020
The user can open a
document instantaneously,

01:00:34.040 --> 01:00:35.550
but the layout happens further on.

01:00:35.640 --> 01:00:39.040
So this is what you can also
use these different techniques.

01:00:39.040 --> 01:00:41.960
Definitely for network and disk I/O,
threads would be the answer.

01:00:42.600 --> 01:00:43.920
Sometimes timers are good.

01:00:43.920 --> 01:00:46.850
So you want to definitely minimize
your flushing in that way.

01:00:46.920 --> 01:00:50.440
So what I'm going to do is I'm
going to invite Harun up again to

01:00:50.450 --> 01:00:55.030
show another demo about drawing--
drawing and flushing optimally.

01:00:55.640 --> 01:00:57.520
OK, so this is a worm demo.

01:00:57.520 --> 01:01:00.060
So you want to pull that down
if you've got access to it.

01:01:00.070 --> 01:01:03.940
But this was something that
was discussed a few WWDCs ago.

01:01:03.940 --> 01:01:05.450
So I won't go into the details of it.

01:01:05.540 --> 01:01:08.620
But let me at least run the demo,
so you know what's going on.

01:01:08.640 --> 01:01:10.760
But basically I'm just
going to be playing a game,

01:01:10.760 --> 01:01:13.660
which is-- you get the point.

01:01:13.660 --> 01:01:14.960
You've seen these games before.

01:01:14.960 --> 01:01:17.810
It's a worm or snake going around.

01:01:18.000 --> 01:01:21.040
And we're going to try and see
how fast we can actually do this.

01:01:21.040 --> 01:01:23.010
When the game's playing,
it's running at around

01:01:23.090 --> 01:01:24.290
six frames a second.

01:01:24.300 --> 01:01:27.700
And there are different
ways of improving it.

01:01:27.700 --> 01:01:33.620
So in this case, in the four cases above,
instead of the play,

01:01:33.630 --> 01:01:36.600
what we're doing is basically
trying to run the game engine

01:01:36.600 --> 01:01:38.180
at about 1,000 frames a second.

01:01:38.180 --> 01:01:40.740
But we're only seeing about 200 frames.

01:01:40.740 --> 01:01:43.910
And then we go through
a few optimizations.

01:01:44.600 --> 01:02:00.900
[Transcript missing]

01:02:01.350 --> 01:02:04.120
So let me move this out of the way.

01:02:04.120 --> 01:02:06.260
And notice,
I'm actually running on Panther,

01:02:06.260 --> 01:02:09.100
and we'll talk about Tiger later.

01:02:09.130 --> 01:02:12.010
So the first optimization-- let me
quickly skip through some of this stuff.

01:02:12.180 --> 01:02:16.520
But we're setting the view as opaque.

01:02:16.520 --> 01:02:19.130
In the second optimization,
which I won't cover here,

01:02:19.140 --> 01:02:20.730
we're only drawing the change rectangle.

01:02:20.900 --> 01:02:24.560
The third optimization that could be
done is using the NsLayoutManager to

01:02:24.560 --> 01:02:27.120
actually do the caching of the layout.

01:02:27.140 --> 01:02:29.160
The fourth one is what
we're really interested in,

01:02:29.160 --> 01:02:33.840
is decoupling the display
timer from the engine timer.

01:02:33.890 --> 01:02:37.300
So this is where
I wanted to point to you,

01:02:37.300 --> 01:02:41.600
that we're running the engine
at about 1,000 frames a second.

01:02:41.600 --> 01:02:46.040
What we're really doing in this case
is just adding a new timer in here.

01:02:46.040 --> 01:02:49.280
The timer is actually going
to run at 30 frames a second,

01:02:49.280 --> 01:02:51.100
which was one of the
recommendations I made.

01:02:51.100 --> 01:02:56.070
And then the timer, on its callback,
all it's going to do is actually

01:02:56.340 --> 01:02:58.040
end up calling the fire update.

01:02:58.040 --> 01:02:59.160
Well, let's look at the fire.

01:02:59.160 --> 01:03:02.700
Fire update does nothing more than
just do a sets need display in Rect.

01:03:02.700 --> 01:03:05.850
And given that we were actually going
to be drawing this periodically,

01:03:05.850 --> 01:03:09.080
and we may want to accumulate
a dirty region instead,

01:03:09.080 --> 01:03:13.240
so most of this code really
does is have a look at it,

01:03:13.280 --> 01:03:14.060
play with it.

01:03:14.060 --> 01:03:17.100
All this does is actually just
update the dirty rectangle.

01:03:17.160 --> 01:03:19.410
So finally, what you want to do is
just stop the timer.

01:03:19.460 --> 01:03:23.280
So back to Andrew.

01:03:23.280 --> 01:03:24.780
ANDREW FITZ GIBBON: Thanks, Arun.

01:03:25.280 --> 01:03:29.600
So I hope you guys caught the CPU meter,
right?

01:03:29.600 --> 01:03:31.430
As soon as you switch
to the good version,

01:03:31.430 --> 01:03:34.020
the CPU meter went . So that's
what I was getting at,

01:03:34.020 --> 01:03:37.290
sort of consuming resources
in order to flush.

01:03:37.690 --> 01:03:39.080
So thanks, Rune.

01:03:39.080 --> 01:03:41.640
So now let's go a little
bit up to updates.

01:03:41.640 --> 01:03:45.200
Every flush you do causes an
update to happen on the screen.

01:03:45.270 --> 01:03:47.660
So we go back to our little diagram,
but we're going to change

01:03:47.660 --> 01:03:49.190
it up a little bit,
and what we're going to do is

01:03:49.190 --> 01:03:55.780
track the CPU required to produce
the next frame for the next VBL.

01:03:56.130 --> 01:03:59.070
So application one comes in,
and let's say he did exactly

01:03:59.070 --> 01:04:01.750
what Haroon did and minimized his
drawing and flushing at 30 hertz.

01:04:01.840 --> 01:04:05.880
So he comes in and he starts to draw,
causes some CPU utilization or to

01:04:05.880 --> 01:04:07.900
generate the frames for the next VBL.

01:04:07.920 --> 01:04:13.140
Application two comes in, right,
draws some more, consumes some more CPU.

01:04:13.140 --> 01:04:16.280
And it's easy to see that
after N applications,

01:04:16.280 --> 01:04:17.950
guess what, we're already maxed out.

01:04:18.030 --> 01:04:21.560
So even though you've done your work and
ran off and optimized things and changes

01:04:21.570 --> 01:04:26.460
so that you don't flush all the time
and create an optimal way of doing it,

01:04:26.590 --> 01:04:28.570
there are other applications in
the system that can be running at

01:04:28.580 --> 01:04:31.080
the same time that will still cause
us to get into this situation.

01:04:31.080 --> 01:04:39.440
So what we're going to do is I'm going
to demonstrate exactly what will happen

01:04:39.460 --> 01:04:41.240
when these applications are all running.

01:04:41.280 --> 01:04:44.770
Switch to demo machine one.

01:04:44.780 --> 01:04:45.910
Demo machine one.

01:04:48.190 --> 01:04:50.700
Okay, so here we have, you know,
a little status updater.

01:04:50.920 --> 01:04:53.940
Basically what it's doing,
it's pretending as if it's copying files,

01:04:53.940 --> 01:04:56.110
let's say.

01:04:56.110 --> 01:05:04.480
But it does insist on printing
every string that needs to be shown.

01:05:04.480 --> 01:05:04.480
So what we're going to do is
we're going to start these guys.

01:05:05.340 --> 01:05:07.860
So the number really should
be exactly that number.

01:05:07.860 --> 01:05:08.930
It's 480, right?

01:05:08.980 --> 01:05:12.200
Because that's the time in which
the simulation is happening.

01:05:12.300 --> 01:05:21.660
So as we start--so he's basically saying
every time he needs to copy a file,

01:05:21.660 --> 01:05:24.200
he--or print a copy of
file or do an iteration,

01:05:24.200 --> 01:05:24.200
he prints a string, right?

01:05:24.200 --> 01:05:24.200
So now we start another guy.

01:05:26.770 --> 01:05:29.660
And then now we start another guy.

01:05:29.660 --> 01:05:32.290
Oops.

01:05:32.380 --> 01:05:34.180
And right away,

01:05:36.090 --> 01:05:42.680
It's not taking us too long before
we start cutting our rate in two.

01:05:42.740 --> 01:05:44.920
So basically,
our data engine is running at exactly

01:05:44.920 --> 01:05:46.740
the same speed as a visualization engine.

01:05:47.000 --> 01:05:48.860
But guess what?

01:05:48.910 --> 01:05:56.040
Our data engine is being slowed
down by a visualization engine.

01:05:56.040 --> 01:05:57.240
So what you really would
like to do is not do this.

01:05:57.240 --> 01:05:57.240
You would really want to say, well,

01:05:57.390 --> 01:06:01.480
Do we really need to be printing
all these strings all the time?

01:06:01.660 --> 01:06:03.600
I mean, can you see those strings?

01:06:03.790 --> 01:06:04.590
Probably not.

01:06:04.630 --> 01:06:06.450
Or you can see a blur, I guess.

01:06:06.600 --> 01:06:11.040
So what you want to
do is you want to say,

01:06:11.040 --> 01:06:16.410
hey,
got a little version here setting up that

01:06:16.410 --> 01:06:16.490
it's doing things in a different way.

01:06:16.490 --> 01:06:16.490
It's actually printing out
the strings like every--

01:06:17.100 --> 01:06:41.100
[Transcript missing]

01:06:45.390 --> 01:06:49.110
We're still copying at 480, right?

01:06:49.260 --> 01:06:54.380
So don't let your visual engine
slow down your data engine,

01:06:54.380 --> 01:06:54.380
right?

01:06:55.500 --> 01:06:57.460
So that's one important good,
very good point.

01:06:57.720 --> 01:07:00.480
So let's go back to the
slides a little bit.

01:07:00.580 --> 01:07:06.360
So even though you've drawn optimally,
and we told you about the situation,

01:07:06.470 --> 01:07:09.160
even in that example,
we can still run into other

01:07:09.160 --> 01:07:11.490
situations where we're still,
because of multiple

01:07:11.490 --> 01:07:14.190
applications are running,
we're still banging into each other

01:07:14.250 --> 01:07:17.350
because you and you and you and you,
you're all wanting to flush.

01:07:17.530 --> 01:07:20.120
You're doing it optimally,
but you can still see the

01:07:20.120 --> 01:07:22.270
CPU is going to get taxed.

01:07:22.450 --> 01:07:28.670
So what we did for Tiger is we
co-released all these updates.

01:07:29.820 --> 01:07:31.800
What happens is that your
applications draw into their

01:07:31.810 --> 01:07:35.500
perspective backing stores,
and that data is then composited

01:07:35.560 --> 01:07:38.850
together in one atomic frame,
or co-released together

01:07:38.850 --> 01:07:42.860
in one atomic frame,
and presented to the user at once.

01:07:43.030 --> 01:07:47.170
So basically, all the applications,
all their flushes,

01:07:47.170 --> 01:07:51.100
are all co-released together,
and they all get sent out in one frame.

01:07:51.220 --> 01:07:55.460
So this type of strategy makes
much better use of the GPU and CPU.

01:07:55.600 --> 01:07:59.600
So we don't actually obey your
flush right now for the next VBL,

01:07:59.600 --> 01:08:02.920
or we don't send it out,
but we schedule it for the next VBL.

01:08:03.210 --> 01:08:04.860
And you're flush, and you're flush,
and you're flush.

01:08:04.890 --> 01:08:07.180
And you get to see the points.

01:08:07.270 --> 01:08:08.540
But let's sort of look at it.

01:08:08.540 --> 01:08:11.540
Let's go back to our little
familiar timeline here.

01:08:11.550 --> 01:08:17.110
Got timelines going,
the CPU tax for actually sending

01:08:17.110 --> 01:08:18.770
out a frame for the next VBL.

01:08:18.900 --> 01:08:21.110
So let's say application
one starts to flush,

01:08:21.110 --> 01:08:23.680
but he doesn't really
get flushed right away.

01:08:23.690 --> 01:08:25.670
We sort of schedule him for the next VBL.

01:08:25.890 --> 01:08:30.460
So that's actually what happens,
and then CPU usage to generate

01:08:30.460 --> 01:08:33.460
that VBL frame actually goes up,
obviously.

01:08:33.500 --> 01:08:36.480
But the second application that
comes in and flushes sometime later,

01:08:36.480 --> 01:08:39.080
or before, or whenever,
he does his flush,

01:08:39.080 --> 01:08:40.940
and it also gets scheduled
for the next VBL.

01:08:41.010 --> 01:08:42.320
But the CPU meter hasn't gone up.

01:08:42.320 --> 01:08:45.120
We haven't spent any more
time generating that frame.

01:08:45.130 --> 01:08:50.490
And you can see, after n applications,
there's no more extra CPU being used.

01:08:50.640 --> 01:08:55.160
So we only end up generating a certain
amount of CPU just to render that frame.

01:08:55.160 --> 01:08:58.300
And we're not sort of at the mercy of
multiple applications generating it.

01:08:58.300 --> 01:08:59.620
We're generating and flushing.

01:08:59.640 --> 01:09:01.640
So now I'm going to show you a
little bit of this in action,

01:09:01.640 --> 01:09:03.750
switching to demo two.

01:09:04.420 --> 01:09:07.890
So now we have--in Haroun's example,
I got--well,

01:09:07.900 --> 01:09:09.800
I have the status updaters up there.

01:09:09.800 --> 01:09:11.630
There are two bad ones and one good one.

01:09:11.730 --> 01:09:14.630
And I got worm,
which is Haroun's example,

01:09:14.930 --> 01:09:18.460
but one good worm,
which is the one he showed you last,

01:09:18.490 --> 01:09:21.870
and then I actually colored
the bad worm in red.

01:09:21.870 --> 01:09:25.010
So now we're going--the
fish are swimming.

01:09:25.010 --> 01:09:29.850
We're--we're--we're--see it, you know,
they're hopping along.

01:09:29.850 --> 01:09:31.110
And then, you know,
let's say we wanted to play a movie.

01:09:32.020 --> 01:09:33.380
So we play a movie, right?

01:09:33.540 --> 01:09:36.420
So the movie's being played,
and it's also utilizing a

01:09:36.430 --> 01:09:38.900
certain amount of resources in
order to generate its frames.

01:09:38.900 --> 01:09:42.090
But the movie is pretty taxing,
so it's actually using CPU.

01:09:42.330 --> 01:09:47.170
But what happens now is that,
as you can see,

01:09:47.170 --> 01:09:50.370
the fish are kind of chunky.

01:09:50.480 --> 01:09:53.210
But when we switch to Tiger with those
co-release updates optimizations put in,

01:09:53.210 --> 01:09:53.210
we get this instead.

01:09:53.860 --> 01:09:55.670
Fish is swimming a lot faster.

01:09:55.730 --> 01:09:59.130
There's less CPU being used in order to
generate the frames for the next VBL.

01:09:59.140 --> 01:10:01.750
Everybody gets scheduled together, right?

01:10:01.850 --> 01:10:03.760
So there's a definite
advantage for your user.

01:10:03.900 --> 01:10:09.390
Your application's--your entire user
interface does not feel buggy because

01:10:09.390 --> 01:10:11.710
it has multiple stuff going on.

01:10:11.820 --> 01:10:16.460
Not that you'd be really running
Atlantis and playing a movie and

01:10:16.460 --> 01:10:17.090
copying files at the same time,
but you get the point.

01:10:17.090 --> 01:10:17.090
So now we're gonna go back to the slides.

01:10:20.550 --> 01:10:22.400
So--sorry.

01:10:22.510 --> 01:10:24.040
So, co-released updates.

01:10:24.210 --> 01:10:27.150
Well,
we told you that your application updates

01:10:27.260 --> 01:10:29.610
are being scheduled for the next VBL.

01:10:29.630 --> 01:10:32.160
That's exactly what's going to happen.

01:10:32.160 --> 01:10:35.540
But there's an important,
interesting point to note.

01:10:35.540 --> 01:10:38.810
Your application drawing
onto a particular area,

01:10:38.810 --> 01:10:42.410
when you flush that area,
it's going to stop you from drawing

01:10:42.440 --> 01:10:46.540
on that area until the actual area
that you've previously flushed

01:10:46.540 --> 01:10:46.700
got committed to the display.

01:10:46.700 --> 01:10:46.700
So there's a hitch.

01:10:46.900 --> 01:10:48.150
So let's look at what that means.

01:10:48.370 --> 01:10:50.670
So applications typically
go through a drawing cycle,

01:10:50.670 --> 01:10:51.400
right?

01:10:51.400 --> 01:10:52.640
They draw and they flush.

01:10:52.740 --> 01:10:59.590
So application starts drawing
for a particular period of time,

01:10:59.590 --> 01:10:59.590
then it issues a flush.

01:10:59.590 --> 01:10:59.590
That flush gets scheduled
for the next PBL.

01:11:00.690 --> 01:11:03.100
During that time,
the application will be blocked

01:11:03.360 --> 01:11:08.720
from drawing on his Backing
Store until the actual data

01:11:08.720 --> 01:11:08.720
gets committed to the display.

01:11:08.910 --> 01:11:10.330
Similarly,
another application that comes in,

01:11:10.330 --> 01:11:13.980
maybe starts to draw a little
later and flushes a little later,

01:11:14.010 --> 01:11:15.050
he also gets scheduled.

01:11:15.080 --> 01:11:17.240
But his waiting time is
a little bit shorter.

01:11:17.380 --> 01:11:19.310
But basically the point is what
you would really like to do is

01:11:19.310 --> 01:11:21.670
any time you need to do updating,
try to sort of do at half

01:11:21.670 --> 01:11:24.580
the refresh rate or even the
refresh rate of the monitor.

01:11:24.580 --> 01:11:27.240
That way you sort of
minimize your drawing.

01:11:27.490 --> 01:11:31.110
But to be more specific,
what you'd like to do is you'd like to

01:11:31.190 --> 01:11:33.580
sort of obviously avoid these blocks.

01:11:33.580 --> 01:11:35.700
How do you avoid blocking
your application?

01:11:35.700 --> 01:11:37.450
Well, the first thing you've got to do,
as we said before,

01:11:37.520 --> 01:11:38.860
is minimize your flushing.

01:11:38.900 --> 01:11:40.050
That's the one thing you have to stop.

01:11:40.180 --> 01:11:43.260
You use timers or use threads
or whatever you want to use,

01:11:43.270 --> 01:11:44.080
try to do.

01:11:44.080 --> 01:11:47.890
The second thing to do when you happen
to do drawing is what you'd like to

01:11:47.890 --> 01:11:52.100
do is try to do useful work before
you start drawing your next frame.

01:11:52.100 --> 01:11:55.160
So if you've got lots of layout to do,
do the layout first before

01:11:55.160 --> 01:11:56.830
you start drawing your text.

01:11:56.850 --> 01:12:00.100
Don't layout and draw at the same time.

01:12:00.100 --> 01:12:02.620
So that way you have ample
amount of time from your previous

01:12:02.660 --> 01:12:05.440
flush to do lots of useful work.

01:12:05.440 --> 01:12:05.460
We're not off touch with this.

01:12:05.460 --> 01:12:09.240
Do layout, whatever you want to do,
and then start generating the next frame.

01:12:09.240 --> 01:12:11.800
So another important point, scrolling.

01:12:11.800 --> 01:12:13.260
Scrolling is an interesting thing.

01:12:13.260 --> 01:12:14.680
Scrolling,
you might need special treatment

01:12:14.750 --> 01:12:17.070
for scrolling because scrollers,
especially on the button,

01:12:17.180 --> 01:12:18.190
user interactions are fine.

01:12:18.260 --> 01:12:20.790
But when you're scrolling the buttons,
typically developers say, OK, great,

01:12:20.850 --> 01:12:21.830
I've got another button click.

01:12:21.880 --> 01:12:22.850
Let's advance by 10.

01:12:22.860 --> 01:12:23.870
I've got another button click.

01:12:23.910 --> 01:12:24.810
Let's advance by 10.

01:12:24.900 --> 01:12:26.980
What you more want to do
is you want to do timing.

01:12:27.010 --> 01:12:29.580
So you say, OK, I've got a button click.

01:12:29.580 --> 01:12:31.400
I've advanced by a certain amount.

01:12:31.400 --> 01:12:34.480
OK, the next time I come back, you say,
well, I'm not actually moved up by 10,

01:12:34.480 --> 01:12:36.260
but I'm actually moved up by 50.

01:12:36.260 --> 01:12:39.260
Let's issue the next scroll
application to move by 50.

01:12:39.260 --> 01:12:46.910
So those are a bunch of different ways
you can do to alleviate your problem.

01:12:47.380 --> 01:12:50.550
What you'd like to do is sort of also,
how to detect the problem.

01:12:50.680 --> 01:12:53.100
Well,
Quartz Debug is there for you to use,

01:12:53.140 --> 01:12:58.980
and you want to use Shark also
to debug your samples.

01:12:59.060 --> 01:13:02.370
There's a special option
called Times All Thread States.

01:13:02.380 --> 01:13:03.680
What you want to use is use that.

01:13:03.810 --> 01:13:06.660
And what that would do is that
will not only track the time

01:13:06.660 --> 01:13:08.500
spent in your application,
but it actually tracks a

01:13:08.510 --> 01:13:09.730
time global system-wide.

01:13:09.970 --> 01:13:12.110
So that's the way how you
would pick up blocking.

01:13:12.270 --> 01:13:14.540
But there's a Shark session
that is coming on further

01:13:14.540 --> 01:13:15.980
today that you would see.

01:13:16.060 --> 01:13:19.420
But anyway, so the crux is that there are
some difficulties involved.

01:13:19.420 --> 01:13:26.060
But there will be a technical coming up
that would talk some more about trying

01:13:26.080 --> 01:13:31.310
to avoid some of the penalties associated
with over-flushing and trying to optimize

01:13:31.370 --> 01:13:33.820
your flushing so that you work better.

01:13:33.840 --> 01:13:39.720
So now we're going to talk a little bit
about application graphics optimizations.

01:13:39.730 --> 01:13:43.930
Basically,
I'd like to share this quote with you.

01:13:44.480 --> 01:13:46.560
Premature evil.

01:13:46.920 --> 01:13:48.440
It's a very nice quote, I like it.

01:13:48.560 --> 01:13:52.840
Don't optimize before you
figure out you need to optimize.

01:13:53.040 --> 01:13:56.280
So basic discipline,
profile your application,

01:13:56.290 --> 01:13:57.780
optimize your application.

01:13:57.790 --> 01:13:59.870
Rinse and repeat, add in front item,
keep on going.

01:13:59.880 --> 01:14:02.320
Re-explore architectural
decisions you might want to use.

01:14:02.410 --> 01:14:05.480
So that's the basic discipline.

01:14:05.550 --> 01:14:07.200
Tools to use, Shark.

01:14:07.280 --> 01:14:09.480
Shark's your friend, right?

01:14:09.520 --> 01:14:11.620
And then related sessions
coming up at 2:00 PM,

01:14:11.620 --> 01:14:12.470
you want to use that.

01:14:12.490 --> 01:14:14.180
Go to that session.

01:14:14.350 --> 01:14:19.680
What you want to look for in Shark,
anything to do with graphics.

01:14:19.720 --> 01:14:24.060
Graphics, course filling,
stuff like that, you want to use those.

01:14:24.150 --> 01:14:26.540
Second thing you want
to look for is flushing.

01:14:26.570 --> 01:14:29.270
Well, you won't actually see flushing.

01:14:29.570 --> 01:14:32.200
What you flush is
completely asynchronous.

01:14:32.210 --> 01:14:36.350
And when you try to do this flush,
it won't show up on your profile.

01:14:36.470 --> 01:14:40.160
What will show up on your profile is the
next drawing operation after you flushed.

01:14:40.440 --> 01:14:42.340
So that's what you would see in profile.

01:14:42.370 --> 01:14:44.400
The last thing you want to look
for in Shark is anything to do

01:14:44.400 --> 01:14:45.340
with locking and synchronize.

01:14:45.340 --> 01:14:46.580
Basically means contention.

01:14:46.580 --> 01:14:48.900
If you see it, try and avoid it.

01:14:48.900 --> 01:14:50.320
Another tool to use is Quartz Debug.

01:14:50.320 --> 01:14:53.440
Lots of cool things in Quartz Debug.

01:14:53.440 --> 01:14:56.760
Auto-flushing shows what's been
drawn and how frequently or

01:14:56.760 --> 01:14:59.540
redundantly it's been drawn.

01:14:59.740 --> 01:15:02.610
Flashing updates, that will show you and
say what's been flushed,

01:15:02.620 --> 01:15:03.880
even though you've drawn it.

01:15:03.880 --> 01:15:05.120
You wouldn't want to flash it.

01:15:05.130 --> 01:15:08.700
And flashing identical updates,
what that does is it allows you to

01:15:08.770 --> 01:15:13.740
figure out what's being drawn that
may not necessarily need to be drawn.

01:15:13.740 --> 01:15:15.760
You see the same white rectangle
being flashed all the time.

01:15:15.820 --> 01:15:19.760
Well, that's probably something that you
probably didn't need to flush or draw.

01:15:20.050 --> 01:15:22.300
And there are also lots of
tools to do with high DPI and

01:15:22.300 --> 01:15:25.200
frame rates and stuff like that.

01:15:25.220 --> 01:15:29.360
So let's consider one last
section about live resizing.

01:15:29.380 --> 01:15:32.820
As I said, user wants to interact
with his application.

01:15:32.840 --> 01:15:36.700
And they really want to
behave in a certain way.

01:15:36.700 --> 01:15:39.600
What you really want to do is
try and do separate data engine

01:15:39.630 --> 01:15:41.650
versus visualization engine.

01:15:41.780 --> 01:15:44.910
You might want to maybe sometimes
render lower quality results.

01:15:45.030 --> 01:15:46.780
You don't have to draw your
high interpolation quality

01:15:46.780 --> 01:15:48.880
every time you resize.

01:15:48.900 --> 01:15:49.940
And text layout.

01:15:50.150 --> 01:15:51.440
Do your text layout ahead of time.

01:15:51.440 --> 01:15:53.340
Or do the text layout every so often.

01:15:53.340 --> 01:15:56.940
Or do the text layout when the
application has finished resizing.

01:15:57.090 --> 01:15:58.610
Those are all these things.

01:15:58.770 --> 01:16:00.750
Network and data access, avoid them.

01:16:00.960 --> 01:16:02.160
Don't do them at all.

01:16:02.370 --> 01:16:05.070
Just if you can get away with
having your application resized

01:16:05.070 --> 01:16:07.900
without having to touch the network,
you should probably-- your

01:16:07.900 --> 01:16:10.070
application will benefit greatly.

01:16:10.170 --> 01:16:14.460
So for live resizing in Carbon,
there are a bunch of things

01:16:14.580 --> 01:16:16.540
that are associated with it.

01:16:16.580 --> 01:16:18.410
But basically,
the general rule is to don't draw

01:16:18.420 --> 01:16:22.370
or invalidate-- or only draw or
invalidate the newly exposed stuff.

01:16:22.440 --> 01:16:23.670
Don't draw too much.

01:16:23.750 --> 01:16:27.260
So the way how you do that
is just basically diff the

01:16:27.260 --> 01:16:29.550
previous and the next bounds,
or the current bounds and the

01:16:29.630 --> 01:16:31.160
previous bounds in the event.

01:16:31.160 --> 01:16:34.320
And then for HI views that
are compositing views,

01:16:34.320 --> 01:16:41.300
you would use the invalidate to
minimize what you're invalidating.

01:16:41.300 --> 01:16:43.380
And notifications are available
when it's been started.

01:16:43.380 --> 01:16:45.120
When it's been stopped,
you can use that to say, OK, great.

01:16:45.120 --> 01:16:48.560
I'll create my low quality result image,
or I'll do my layout or whatever.

01:16:48.560 --> 01:16:49.920
So you get the notifications.

01:16:49.920 --> 01:16:52.680
In Cocoa, similar set of rules.

01:16:52.680 --> 01:16:54.160
Only draw the newly exposed regions.

01:16:54.160 --> 01:16:57.770
You can find those out by calling the
get next and get exposed recs call to

01:16:57.770 --> 01:17:00.400
give you back only the exposed regions.

01:17:00.400 --> 01:17:03.900
And the other thing is, too,
you can use the in resize

01:17:03.900 --> 01:17:05.800
option to figure out,
oh, I'm actually in resize.

01:17:05.800 --> 01:17:08.580
Maybe I don't need to do
my high quality image.

01:17:08.580 --> 01:17:12.060
And the other option that the kit has
also provided was preserving content.

01:17:12.060 --> 01:17:14.620
You can specify that-- your view
preserves content during resize,

01:17:14.620 --> 01:17:16.110
so you don't have to draw anything.

01:17:16.120 --> 01:17:18.880
You only have to draw
the newly exposed data.

01:17:18.880 --> 01:17:21.190
And notifications are
also available in the kit,

01:17:21.190 --> 01:17:21.580
too.

01:17:21.590 --> 01:17:26.530
So for more information,
there's lots of sample code and

01:17:26.530 --> 01:17:31.620
resources that can be found at that URL,
other related sessions.

01:17:31.620 --> 01:17:34.110
Swimming with the Sharks,
definitely want to go to that.

01:17:34.130 --> 01:17:35.340
Sharks your friend.

01:17:35.380 --> 01:17:37.580
And who to contact?

01:17:37.580 --> 01:17:38.080
Travis.

01:17:38.080 --> 01:17:39.010
Everybody knows Travis.

01:17:39.080 --> 01:17:39.600
He's cool.

01:17:39.620 --> 01:17:43.600
And basically, this is a book that's been
presented I'm sure maybe you've

01:17:43.740 --> 01:17:45.220
seen other graphics presentations.

01:17:45.220 --> 01:17:46.160
There were these slides.

01:17:46.160 --> 01:17:47.380
There's a free chapter on performance.

01:17:47.380 --> 01:17:48.900
This is a very, very, very good book.

01:17:48.990 --> 01:17:51.320
It's written by one of the
developers that work with Apple.

01:17:51.340 --> 01:17:54.200
So he's got the whole skinny on
basically every type of optimization

01:17:54.220 --> 01:17:55.710
technique you might want to use.

01:17:55.720 --> 01:17:57.770
And just basic drawing.
WEBVTT

00:00:09.910 --> 00:00:14.060
Okay, hello and welcome to
Advanced Core Data Usages,

00:00:14.060 --> 00:00:15.600
session 143.

00:00:15.620 --> 00:00:18.240
I'm not Ben Trumbull, I am, however,
Melissa Turner.

00:00:18.240 --> 00:00:22.580
We helped build Core Data and they,
in exchange, made us get up on stage

00:00:22.580 --> 00:00:24.680
and tell you all about it.

00:00:27.040 --> 00:00:29.310
So this is what we hope you
already know about Core Data.

00:00:29.340 --> 00:00:32.930
Core Data is a model-driven object graph
management and persistency framework.

00:00:33.050 --> 00:00:35.420
It provides scalable object
lifecycle management,

00:00:35.430 --> 00:00:38.950
automatic undo/redo support,
user interface synchronization through

00:00:38.970 --> 00:00:40.770
our integration with the Cocoa bindings.

00:00:40.940 --> 00:00:43.520
We help ensure data
consistency and correctness,

00:00:43.540 --> 00:00:47.600
and we take care of reading and writing
to various types of files for you.

00:00:49.710 --> 00:00:50.750
Why do you want to use Core Data?

00:00:50.880 --> 00:00:52.120
Okay, can I get a show of hands?

00:00:52.170 --> 00:00:54.560
Everybody here who's written
a piece of code that,

00:00:54.560 --> 00:00:56.600
well, they knew somebody else
out there had implemented,

00:00:56.600 --> 00:00:59.280
they maybe even knew the implementation,
they just decided they

00:00:59.280 --> 00:01:01.370
could do it better,
so they had to write it?

00:01:01.420 --> 00:01:03.640
Can I get a show of hands for this?

00:01:03.690 --> 00:01:06.320
And how many of you who aren't
putting up your hands are just

00:01:06.320 --> 00:01:08.040
lying to me or yourselves?

00:01:08.080 --> 00:01:10.640
'Cause I suspect it's the rest of you.

00:01:11.360 --> 00:01:13.160
We believe you of having
to reinvent the wheel.

00:01:13.160 --> 00:01:15.360
We think we did a pretty good job of it,
and quite honestly,

00:01:15.360 --> 00:01:17.920
it's probably better than
you're going to do yourself,

00:01:17.920 --> 00:01:19.330
so we think you should use it.

00:01:19.400 --> 00:01:21.850
It'll give you a faster
development cycle.

00:01:21.850 --> 00:01:23.960
Every line of code you don't
have to write and test,

00:01:23.960 --> 00:01:26.900
well, that's a line of code you
can spend writing and test,

00:01:26.920 --> 00:01:29.770
or the time you can spend writing,
you know, features that your customers

00:01:29.800 --> 00:01:32.880
are going to find unique and
interesting about your application.

00:01:33.520 --> 00:01:35.930
It's likely going to give you
a more robust application.

00:01:36.010 --> 00:01:37.530
We test the heck out of this stuff.

00:01:37.530 --> 00:01:39.120
We've released it to all of you guys.

00:01:39.170 --> 00:01:40.080
You build stuff.

00:01:40.110 --> 00:01:42.540
You go down through code
paths that we really didn't

00:01:42.540 --> 00:01:44.890
think people would ever try,
so we're pretty sure

00:01:44.890 --> 00:01:47.800
there's not a lot of bugs,
and we're devoted to fixing those,

00:01:47.800 --> 00:01:50.880
the ones that there are,
and that's something you can't guarantee

00:01:50.950 --> 00:01:52.780
if you write the code yourself.

00:01:52.780 --> 00:01:54.610
And, you know,
it prepares your application

00:01:54.610 --> 00:01:55.870
for future features in Cocoa.

00:01:55.870 --> 00:01:58.060
We don't know what those features are,
but, you know,

00:01:58.060 --> 00:02:01.100
if somebody comes along and, say,
switches your architecture, you know,

00:02:01.300 --> 00:02:03.110
processor architecture
out from under you,

00:02:03.380 --> 00:02:05.180
That's code you don't have
to worry about porting.

00:02:05.180 --> 00:02:07.040
We're going to have to do it.

00:02:09.530 --> 00:02:11.060
What are we going to cover this session?

00:02:11.090 --> 00:02:12.160
Well, a bunch of things.

00:02:12.160 --> 00:02:14.740
We're going to cover the general
architecture of Core Data,

00:02:14.840 --> 00:02:17.270
the individual components,
how they fit all together.

00:02:17.320 --> 00:02:20.890
We're going to talk about
some advanced topics,

00:02:20.890 --> 00:02:24.800
some of the tougher questions
you're going to have to ask

00:02:24.900 --> 00:02:29.550
yourselves or run across when
you're building an application.

00:02:29.550 --> 00:02:30.000
And we're going to talk about some
of the decision points and the

00:02:30.000 --> 00:02:30.000
things to think about when you're
building a Core Data application.

00:02:32.230 --> 00:02:36.180
So Core Data architecture is essentially
built from a bunch of components.

00:02:36.180 --> 00:02:38.900
There's the models that
define how data looks.

00:02:38.900 --> 00:02:41.250
There's the managed objects
and the object context that

00:02:41.250 --> 00:02:44.020
are the living representations
of data in your application.

00:02:44.020 --> 00:02:48.490
There's predicates and fetch requests
which specify which particular

00:02:48.520 --> 00:02:52.820
object or objects you want to be
working with at any point in time.

00:02:52.820 --> 00:02:55.210
And there's object stores and
store coordinator that take care

00:02:55.210 --> 00:02:57.960
of putting your objects to sleep
between runs of your application.

00:02:58.720 --> 00:03:03.010
We're integrated with Cocoa through
the NS document architecture

00:03:03.010 --> 00:03:04.960
and through the controllers.

00:03:05.400 --> 00:03:08.900
We've got a design tool in Xcode that
if you were at any of the earlier

00:03:08.970 --> 00:03:12.700
Core Data sessions you've already seen,
that can allow you to create data models.

00:03:12.720 --> 00:03:18.290
And Xcode includes templates for
creating Core Data applications.

00:03:18.850 --> 00:03:21.200
You hopefully have
seen this slide before.

00:03:21.240 --> 00:03:26.160
This is the Core Data basic architecture,
or what we call the persistent stack.

00:03:26.250 --> 00:03:28.920
Starts all the way up at the
top with managed objects,

00:03:29.020 --> 00:03:31.880
which are contained in a
managed object context,

00:03:31.890 --> 00:03:35.780
which fetch them using a fetch request
from a persistent store coordinator,

00:03:35.780 --> 00:03:38.810
using the managed object
model from a persistent store.

00:03:38.820 --> 00:03:42.910
Those are all the basic pieces.

00:03:42.910 --> 00:03:43.560
That's sort of how they
connect left to right.

00:03:46.260 --> 00:03:47.400
Managed Object Model.

00:03:47.400 --> 00:03:49.640
As Matt said in his
intro session earlier,

00:03:49.640 --> 00:03:53.540
Managed Object Model is possibly the
most important piece of the application.

00:03:53.540 --> 00:03:57.220
It's the piece that defines what the
data in your application is and how it

00:03:57.220 --> 00:03:59.410
relates to itself or other pieces of it.

00:03:59.480 --> 00:04:04.040
It's an interaction diagram for
interaction between application

00:04:04.040 --> 00:04:05.380
data types and objects.

00:04:05.380 --> 00:04:08.410
Designing a data model allows
you to focus on the architecture

00:04:08.660 --> 00:04:11.890
of your application rather
than control flow through it.

00:04:11.960 --> 00:04:15.700
And it's pretty much the baseline
for doing model-based development.

00:04:15.700 --> 00:04:18.580
If you don't know what your model is,
you pretty much can't be

00:04:18.580 --> 00:04:20.370
doing model-based development.

00:04:20.790 --> 00:04:23.460
There's two main elements
to a managed object model.

00:04:23.460 --> 00:04:25.960
There's entity descriptions
and configurations,

00:04:25.960 --> 00:04:31.000
telling you how those entity
descriptions are related to each other.

00:04:31.340 --> 00:04:37.860
Here's the basic Core Recipes model that
is on the CD that all of you should have.

00:04:37.970 --> 00:04:42.930
We'll probably make references
to this during the talk when we

00:04:43.120 --> 00:04:45.690
draw our little example cases.

00:04:46.330 --> 00:04:47.860
So what's in a model?

00:04:47.900 --> 00:04:51.000
Models have entities,
which have attributes, relationships,

00:04:51.000 --> 00:04:52.660
and fetch properties.

00:04:52.690 --> 00:04:56.800
Models also have fetch request templates,
which are templates specifying

00:04:56.800 --> 00:05:00.200
how to fetch certain subsets of
objects from your object stores.

00:05:00.300 --> 00:05:03.220
And they have configurations,
which are strings used to

00:05:03.220 --> 00:05:06.900
label sets of entities,
which allow you to specify which set

00:05:06.900 --> 00:05:09.430
of entity goes to which object store.

00:05:11.620 --> 00:05:13.160
An entity, what's an entity?

00:05:13.210 --> 00:05:16.780
Well,
it's a named collection of attributes,

00:05:16.830 --> 00:05:19.050
properties, relationships.

00:05:19.620 --> 00:05:21.380
There's several types of properties,
attributes.

00:05:21.460 --> 00:05:22.950
These are essentially your IVARs.

00:05:23.160 --> 00:05:26.880
They contain the value
data for your objects,

00:05:26.880 --> 00:05:29.480
scalars, NSValue classes.

00:05:30.430 --> 00:05:32.300
There's also relationships.

00:05:32.300 --> 00:05:36.540
These contain interaction information
about how your objects interact.

00:05:36.540 --> 00:05:39.640
This chef object has a bunch of recipes.

00:05:39.640 --> 00:05:40.890
This recipe has a bunch of chefs.

00:05:40.890 --> 00:05:42.410
This recipe has a bunch of ingredients.

00:05:42.410 --> 00:05:43.760
Those are your relationships.

00:05:43.760 --> 00:05:46.000
They're essentially pointers
to other managed objects.

00:05:46.360 --> 00:05:50.030
There's also fetched properties,
which are much like fetch requests,

00:05:50.030 --> 00:05:52.730
which are relationships
specified by a predicate.

00:05:52.730 --> 00:05:56.260
This allows you to specify weak
unidirectional relationships.

00:05:56.260 --> 00:06:00.560
And there's a number of special predicate
variables that are in our documentation

00:06:00.560 --> 00:06:04.420
that you can read about that allow you
to do interesting things specifying

00:06:04.420 --> 00:06:06.580
relationships from target object.

00:06:06.580 --> 00:06:10.280
And one thing to note about
fetched properties is they

00:06:10.280 --> 00:06:14.250
only refresh when the object,
the instance of the entity

00:06:14.290 --> 00:06:16.280
they're on is refreshed.

00:06:16.360 --> 00:06:17.380
Thank you.

00:06:19.600 --> 00:06:20.000
Properties.

00:06:20.000 --> 00:06:22.180
As I said, they're the data containing
elements of an entity.

00:06:22.180 --> 00:06:27.090
They're the values, the scalers,
the NS values, they're the pointers.

00:06:27.090 --> 00:06:29.160
They can be transient or persistent.

00:06:29.160 --> 00:06:31.960
Transient properties are really,
really useful.

00:06:31.960 --> 00:06:34.720
They can be used for storing cached
data that was calculated during your

00:06:34.720 --> 00:06:37.410
application processing that's not
really important enough that you

00:06:37.410 --> 00:06:38.900
want to save it to disk anywhere.

00:06:39.870 --> 00:06:42.600
They can hold unsupported data types.

00:06:42.800 --> 00:06:48.230
This is a good way to store NSColor and
NSRect or any of your custom data types,

00:06:48.230 --> 00:06:53.220
very simple ones that you want to
have us do change tracking for.

00:06:54.710 --> 00:06:59.100
You can use transient properties
to model cross-store relationships.

00:06:59.100 --> 00:07:01.200
We'll get into that in
a lot more detail later.

00:07:01.230 --> 00:07:03.060
And you can use them to
store derived properties,

00:07:03.110 --> 00:07:05.750
which is properties whose
value is computed from one or

00:07:05.820 --> 00:07:11.330
more other properties on an
object or on related objects.

00:07:12.190 --> 00:07:13.550
Relationships.

00:07:13.760 --> 00:07:15.260
These are your pointers.

00:07:15.370 --> 00:07:16.910
Relationships are sets.

00:07:17.030 --> 00:07:18.290
They are not arrays.

00:07:18.410 --> 00:07:20.290
There's no ordering.

00:07:20.380 --> 00:07:22.400
We'll talk about that on
the next couple of slides.

00:07:22.470 --> 00:07:25.530
But it's important to remember
that unless you explicitly

00:07:25.710 --> 00:07:31.250
specify an order in your UI,
if you put an NSArray controller

00:07:31.250 --> 00:07:33.630
on top of a set,
the order is not guaranteed to come

00:07:33.630 --> 00:07:35.560
back the same from time to time.

00:07:35.620 --> 00:07:38.770
It also gives you unique correlations,
which means that an object

00:07:38.770 --> 00:07:40.770
can only be in that set once.

00:07:41.490 --> 00:07:43.550
Core Data manages inverse
relationships for you.

00:07:43.570 --> 00:07:45.200
Any relationship,
when you think about it,

00:07:45.220 --> 00:07:47.000
really is two ways.

00:07:47.100 --> 00:07:50.860
A chef has recipes, recipes have chefs.

00:07:50.960 --> 00:07:56.220
What Core Data does is allow you to,
when you create a recipe and set

00:07:56.220 --> 00:08:00.070
that recipe chef to be chef A,
then we will automatically

00:08:00.070 --> 00:08:03.640
go in to chef A and say,
"This chef has a new recipe," and we'll

00:08:03.640 --> 00:08:06.100
tidy up that back pointer for you.

00:08:06.540 --> 00:08:08.540
This means that you have to
specify delete rules when

00:08:08.540 --> 00:08:11.380
you create a relationship,
so we know what should happen

00:08:11.410 --> 00:08:15.420
if you delete an entity that has
relationships to other objects.

00:08:16.230 --> 00:08:19.890
If you specify the nullify delete rule,
we'll simply go through and

00:08:19.890 --> 00:08:22.920
find all the objects on the
other end of the relationship

00:08:22.930 --> 00:08:24.880
and nullify the back pointer.

00:08:24.880 --> 00:08:26.700
This object no longer exists.

00:08:26.700 --> 00:08:29.800
We can have a cascade delete rule
that says if we delete a Chef object,

00:08:29.800 --> 00:08:33.750
then we also want to delete all of
the recipes associated with that Chef.

00:08:33.900 --> 00:08:37.120
There's the deny delete rule,
which is if I try and delete

00:08:37.120 --> 00:08:40.440
a Chef which has recipes,
I'm not allowed to do that until

00:08:40.440 --> 00:08:42.900
I assign the recipes to some other Chef.

00:08:42.900 --> 00:08:46.260
There's also the no action delete rule,
which says, okay, Core Data,

00:08:46.260 --> 00:08:47.480
don't you do anything.

00:08:47.510 --> 00:08:48.790
I'm going to take care of it myself.

00:08:48.900 --> 00:08:52.040
If you use this one,
you are fundamentally going

00:08:52.040 --> 00:08:55.870
to be responsible for fixing
up all of the back pointers.

00:08:56.660 --> 00:08:58.890
Relationships, as I said,
are not ordered.

00:08:59.020 --> 00:08:59.380
Why?

00:08:59.710 --> 00:09:02.890
Because when you really think about it,
most data isn't ordered.

00:09:02.890 --> 00:09:06.580
If you have employees,
what's the inherent order of employees?

00:09:06.580 --> 00:09:09.940
You can order them by first name,
you can order them by last name.

00:09:09.940 --> 00:09:12.280
Employee number is a popular one.

00:09:12.280 --> 00:09:13.670
There's hire date.

00:09:13.700 --> 00:09:16.300
If you're having some
kind of company photo op,

00:09:16.300 --> 00:09:18.550
you might want to order them by height.

00:09:18.610 --> 00:09:21.720
There is no inherent order
in how employees are ordered.

00:09:21.720 --> 00:09:22.700
Same for books.

00:09:24.200 --> 00:09:29.340
Title, ISBN, Library of Congress number,
Dewey Decimal number.

00:09:29.340 --> 00:09:31.480
If you're an interior decorator,
it may be color.

00:09:31.480 --> 00:09:34.940
Some data are inherently organized,
though.

00:09:34.940 --> 00:09:37.860
If you have entries in a ledger,
it doesn't really make sense to look

00:09:37.860 --> 00:09:40.890
at entry A without the context of
all of the entries came before it.

00:09:40.940 --> 00:09:43.500
It's really hard to tell if you're
going into overdraft on your checking

00:09:43.500 --> 00:09:45.990
account if you don't know what
order you made transactions in.

00:09:45.990 --> 00:09:47.700
Customers do, however, like order.

00:09:47.700 --> 00:09:50.100
They like to see things in
predictable ways in their UI.

00:09:50.100 --> 00:09:53.220
So you really have to ask yourself
when you're designing an application,

00:09:53.220 --> 00:09:57.740
Do you really need order or do you
just need the appearance of order?

00:10:01.040 --> 00:10:03.540
If what you really need fundamentally
is the appearance of order,

00:10:03.540 --> 00:10:05.470
it's kind of arbitrary,
users can switch it

00:10:05.470 --> 00:10:08.400
around however they want,
there's a few ways to achieve that.

00:10:08.530 --> 00:10:12.190
You can use fetch requests and specify
a sort order on the fetch request,

00:10:12.230 --> 00:10:14.520
which will say,
this is the order the array in which

00:10:14.560 --> 00:10:16.990
we return objects should be sorted.

00:10:17.060 --> 00:10:21.160
Can you sort orderings on the
array controller using bindings?

00:10:21.200 --> 00:10:23.260
Or you can,
if you've just shoved all your

00:10:23.260 --> 00:10:27.300
managed objects into an array,
you can use NSArray sorting methods,

00:10:27.320 --> 00:10:29.060
also use sort descriptors.

00:10:29.120 --> 00:10:32.900
The tricky problem is if you have,
you really, really need order.

00:10:32.970 --> 00:10:34.950
That's a complicated case,
and in that case you're going

00:10:34.950 --> 00:10:39.330
to have to explicitly create an
order attribute on your object.

00:10:39.650 --> 00:10:41.850
And when you do that,
you take responsibility for

00:10:41.970 --> 00:10:43.840
explicitly maintaining that attribute.

00:10:43.840 --> 00:10:46.610
Anytime something gets added to a set,
you're going to have to figure

00:10:46.920 --> 00:10:48.680
out what the ordering is,
and you're going to have to

00:10:48.710 --> 00:10:49.750
set that order attribute.

00:10:49.880 --> 00:10:51.870
Something gets removed,
you're going to have to remove that

00:10:51.880 --> 00:10:56.620
and go through and clean up the order
attributes on all of the other objects.

00:10:59.100 --> 00:11:01.300
Skipping over to loading models,
how do we load a model?

00:11:01.300 --> 00:11:06.070
We've created one, presumably in the
Core Data modeling tool.

00:11:06.270 --> 00:11:08.120
Now I want to load it in
my application's runtime.

00:11:08.120 --> 00:11:09.790
There's a few ways to do that.

00:11:09.850 --> 00:11:12.400
If you've just got a single model,
use init with contents of

00:11:12.420 --> 00:11:14.340
URL on NSManagedObjectModel.

00:11:14.340 --> 00:11:17.320
If you've got multiple models,
you're a framework or you're an

00:11:17.320 --> 00:11:20.600
application loading a number of
models from a number of frameworks,

00:11:20.680 --> 00:11:22.470
then there's a couple ways to do it.

00:11:22.510 --> 00:11:27.030
You can tell NSManagedObjectModel,
merge model from bundles,

00:11:27.030 --> 00:11:29.220
and pass it an array of bundles.

00:11:29.620 --> 00:11:32.750
We'll go through, find all the managed
object models in those,

00:11:32.750 --> 00:11:34.610
create a merged model from it.

00:11:35.050 --> 00:11:36.860
You can also do model by merging models.

00:11:36.860 --> 00:11:39.570
You can go off and specifically pick
the models on the system that you

00:11:39.570 --> 00:11:41.260
want loaded into your application.

00:11:41.260 --> 00:11:42.940
Use model by merging models.

00:11:42.960 --> 00:11:45.980
There is one caveat to this,
which is that there can't

00:11:45.980 --> 00:11:47.520
be any entity overlap.

00:11:47.520 --> 00:11:51.400
If those models that you're loading and
trying to create a merged model with

00:11:51.400 --> 00:11:55.360
contain any entities with the same name,
you're going to get an error.

00:11:57.790 --> 00:12:00.810
If you're using configurations,
those configurations will be

00:12:00.810 --> 00:12:02.300
merged during the merging as well.

00:12:02.300 --> 00:12:05.980
So if you have a configuration in
Model A named public and you have a

00:12:06.100 --> 00:12:09.640
configuration in Model B named public,
all entities in both of those

00:12:09.670 --> 00:12:12.860
public configurations in your
merged model are going to end

00:12:12.860 --> 00:12:14.700
up in a public configuration.

00:12:14.700 --> 00:12:20.540
So that's something you have to
think about if you're doing a

00:12:20.540 --> 00:12:20.540
configuration-based application.

00:12:22.080 --> 00:12:24.050
This is something we've had a
few questions about this week,

00:12:24.120 --> 00:12:27.560
so we rushed and harassed our graphic
designers to put in a slide about it.

00:12:27.640 --> 00:12:29.620
What's good model design?

00:12:29.620 --> 00:12:31.970
Well,
there's a few things you should keep

00:12:32.040 --> 00:12:34.880
in mind when you're building a model,
just in terms of how data is

00:12:34.880 --> 00:12:37.400
loaded from the disk and how
objects relate to each other.

00:12:37.400 --> 00:12:42.170
If you've got a really large data object,
you know, a movie, a picture,

00:12:42.170 --> 00:12:45.930
Chef's homepage in its entirety,
you probably want to put that at the

00:12:46.010 --> 00:12:47.610
other end of a to-one relationship.

00:12:47.620 --> 00:12:51.870
What this does is allows you,
when your entity is instantiated,

00:12:51.870 --> 00:12:55.750
to avoid the overhead of actually
loading in all of that data

00:12:55.750 --> 00:12:58.100
if you don't actually need to.

00:12:58.100 --> 00:13:01.380
This is a way of essentially
lazy loading large blobs of data.

00:13:01.380 --> 00:13:05.850
Something else to think about is
that you can't query an NSData type.

00:13:05.950 --> 00:13:10.240
It just doesn't work in most
databases or data stores.

00:13:10.240 --> 00:13:13.280
So you might want to consider,
if it's a large text blob,

00:13:13.440 --> 00:13:16.010
consider extracting the
bits of information that

00:13:16.050 --> 00:13:17.610
you might want to search.

00:13:17.620 --> 00:13:19.020
on.

00:13:20.120 --> 00:13:23.700
These last two points
are kind of complicated.

00:13:23.760 --> 00:13:26.040
You want to normalize your data
sets so you can avoid having

00:13:26.040 --> 00:13:27.740
duplicate data in your database.

00:13:27.790 --> 00:13:29.940
In the Chef's Re-- the
Core Recipes example,

00:13:29.940 --> 00:13:32.400
you don't want to have the
chef name on every single

00:13:32.400 --> 00:13:35.740
instance of an entity because,
well,

00:13:36.110 --> 00:13:39.390
It's space consuming and it's a pain
in the neck if the chef goes off,

00:13:39.490 --> 00:13:41.100
gets married, and changes their name.

00:13:41.100 --> 00:13:43.880
So you want to normalize
that out as much as possible.

00:13:43.930 --> 00:13:46.100
The problem is that joins,
which is following

00:13:46.100 --> 00:13:48.550
relationships between objects,
is expensive.

00:13:48.740 --> 00:13:53.250
So you also want to consider
denormalizing data that you know you're

00:13:53.250 --> 00:13:54.800
going to be searching on frequently.

00:13:54.800 --> 00:13:56.400
So you have to play this balancing game.

00:13:56.400 --> 00:14:00.400
And there is no one right or wrong
answer that will fit all applications.

00:14:00.400 --> 00:14:03.520
You really have to look at your
data set and how you think your

00:14:03.520 --> 00:14:08.200
users are going to be querying it
in order to determine where various

00:14:08.200 --> 00:14:11.100
pieces of information need to live.

00:14:13.490 --> 00:14:17.010
And something we've also run across
is the data migration question.

00:14:17.180 --> 00:14:20.660
You write version one of your
application that has model version one.

00:14:20.800 --> 00:14:24.080
But when you listen to your customers,
they say, "Oh, we need this new feature.

00:14:24.080 --> 00:14:25.160
Oh, we need this new feature.

00:14:25.160 --> 00:14:28.690
And why won't you let us store
that piece of information?"

00:14:29.100 --> 00:14:33.580
You come up with v2 of your model and
it's got all that new information.

00:14:33.580 --> 00:14:35.760
How do you read those old model files?

00:14:35.820 --> 00:14:37.430
Users aren't going to
be happy if you say,

00:14:37.480 --> 00:14:39.460
"Oh, well, this is v2 of my application.

00:14:39.460 --> 00:14:43.490
Just forget all of those old files.

00:14:43.490 --> 00:14:43.490
You're not allowed to use them anymore."

00:14:43.710 --> 00:14:47.360
you come up with v2 of your model and
it's got all that new information.

00:14:47.360 --> 00:14:50.350
How do you read those old model files?

00:14:50.360 --> 00:14:52.200
Users aren't going to
be happy if you say,

00:14:52.200 --> 00:14:55.240
oh, well, this is v2 of my application,
just forget all of those old files,

00:14:55.350 --> 00:14:58.000
you're not allowed to use them anymore.

00:15:13.660 --> 00:15:17.800
But the basic principle is you
create two separate stacks,

00:15:17.870 --> 00:15:20.500
one with the old model,
one with the new model,

00:15:20.660 --> 00:15:24.350
you load objects into the old stack,
you copy the data out of

00:15:24.350 --> 00:15:26.850
them into new objects,
which you then insert in

00:15:26.950 --> 00:15:28.620
the new stack and save.

00:15:28.780 --> 00:15:31.670
You'll notice implied there is
the fact that you have to keep

00:15:31.690 --> 00:15:33.360
your old model around to do this.

00:15:33.530 --> 00:15:36.700
Don't just go edit your new
model without having a copy

00:15:36.860 --> 00:15:39.150
stuffed off in CVS somewhere.

00:15:41.390 --> 00:15:44.190
Some tips and tricks to make this
a little bit less painful than

00:15:44.190 --> 00:15:47.440
it sounds and a little bit less
memory consuming than it could be.

00:15:47.500 --> 00:15:49.820
You can do multiple passes
across your old data,

00:15:49.930 --> 00:15:54.040
move discrete chunks of the
object graph separately.

00:15:54.110 --> 00:15:56.330
If you've got little pieces
that live off in their own world

00:15:56.330 --> 00:16:00.210
that are only connected to,
you know, themselves, move those first,

00:16:00.210 --> 00:16:02.480
then move other chunks,
and eventually it'll all be there.

00:16:02.600 --> 00:16:06.240
This helps minimize memory use,
which can be really important if you've

00:16:06.240 --> 00:16:08.240
got a sufficiently large data set.

00:16:08.640 --> 00:16:11.990
And models can be modified at runtime,
so you can temporarily disable

00:16:11.990 --> 00:16:15.620
validation things that would
make doing multiple passes hard.

00:16:15.750 --> 00:16:18.880
You can use managed objects instead
of custom subclasses if you really

00:16:18.920 --> 00:16:22.390
don't need all the overhead that goes
into the business logic on those.

00:16:22.440 --> 00:16:25.730
And like I said,
there's an upgrade example

00:16:25.730 --> 00:16:27.600
on the WWDC source CD.

00:16:27.910 --> 00:16:29.160
And now I'm going to
hand you over to Ben,

00:16:29.160 --> 00:16:32.200
who's going to tell you
all about managed objects.

00:16:32.900 --> 00:16:33.400
Great.

00:16:33.400 --> 00:16:35.150
Thank you, Melissa.

00:16:38.020 --> 00:16:39.260
And now I'm going to
hand you over to Ben,

00:16:39.260 --> 00:16:42.300
who's going to tell you
all about managed objects.

00:16:43.000 --> 00:16:43.420
Great.

00:16:43.570 --> 00:16:45.260
Thank you, Melissa.

00:16:59.700 --> 00:17:00.950
And now I'm going to
hand you over to Ben,

00:17:00.960 --> 00:17:04.000
who's going to tell you
all about managed objects.

00:17:04.690 --> 00:17:05.200
Great.

00:17:05.200 --> 00:17:06.960
Thank you, Melissa.

00:17:29.600 --> 00:17:32.990
So you're going to get the data
from your rows or your XML nodes.

00:17:33.110 --> 00:17:34.820
These are the things that
you're going to fetch.

00:17:34.840 --> 00:17:37.500
You're going to insert, save, delete.

00:17:37.630 --> 00:17:40.850
If you're looking for a Core Data noun,
the subject of an operation,

00:17:40.900 --> 00:17:43.180
it's going to be a managed object.

00:17:44.140 --> 00:17:47.730
and each managed object is described
by a single NAD description,

00:17:47.730 --> 00:17:49.340
and those are in your model.

00:17:49.540 --> 00:17:52.600
They possess a unique managed object ID,
which we'll talk a little

00:17:52.620 --> 00:17:54.940
bit more about later,
but every managed object

00:17:55.000 --> 00:17:58.180
has a managed object ID,
and they're associated with a

00:17:58.180 --> 00:18:01.900
single managed object context,
and the context is what's responsible

00:18:01.900 --> 00:18:06.320
for managing changes and stuff like that,
and we'll have a whole section on that.

00:18:07.290 --> 00:18:09.640
Managed objects are the objects
that you're gonna subclass,

00:18:09.640 --> 00:18:12.250
so you can implement custom
business logic on these classes,

00:18:12.340 --> 00:18:14.740
you can implement the
framework callbacks,

00:18:14.810 --> 00:18:16.710
we'll go over those,
and you can also implement

00:18:16.720 --> 00:18:19.270
custom validation,
and all managed objects respond to key

00:18:19.270 --> 00:18:23.610
value coding and key value observing,
so you can use the root NSManageObject

00:18:23.620 --> 00:18:26.020
class to get a whole lot of work done.

00:18:26.020 --> 00:18:29.110
You can just, you know, value for key,
set value for key,

00:18:29.140 --> 00:18:31.260
and that's gonna get you pretty far.

00:18:32.950 --> 00:18:38.140
So the life cycle of a managed object is
a little bit different than an NS object.

00:18:38.700 --> 00:19:30.900
[Transcript missing]

00:19:31.370 --> 00:19:35.240
So all the objects, like I mentioned,
have key value coding and

00:19:35.240 --> 00:19:36.780
key value observing support.

00:19:36.890 --> 00:19:40.900
And Core Data provides this
over all of the properties

00:19:40.900 --> 00:19:42.110
you've described in your model.

00:19:42.150 --> 00:19:46.460
So Core Data will look at the entity
and make sure that all of those

00:19:46.780 --> 00:19:50.250
objects have space and respond to that.

00:19:50.310 --> 00:19:53.560
So there are mutable proxies
for key value coding.

00:19:53.600 --> 00:19:56.060
In Panther,
there's a mutable array proxy,

00:19:56.080 --> 00:19:58.530
and in Tiger now there's
a mutable set proxy.

00:19:58.610 --> 00:20:01.500
And these are the proxies that you're
gonna use on your too many relationships.

00:20:01.500 --> 00:20:03.350
As Melissa described,
your too many relationships are

00:20:03.370 --> 00:20:05.100
always sets and they're unordered.

00:20:05.130 --> 00:20:08.780
And you can use this mutable proxy
to make changes to that that'll

00:20:08.870 --> 00:20:12.820
post KVO notifications for you
and handle most of the issues.

00:20:13.040 --> 00:20:16.500
And managed objects,
you can use the standard

00:20:16.580 --> 00:20:18.680
KVO dependent key notifications.

00:20:18.680 --> 00:20:22.530
And it's just a little caveat
down here at the bottom.

00:20:22.820 --> 00:20:24.990
Remember that key value coding
is only gonna do a retain.

00:20:25.070 --> 00:20:26.350
It's not gonna do a copy.

00:20:26.420 --> 00:20:30.540
So we've had a few people, you know,
they'll pass in a mutable

00:20:30.540 --> 00:20:32.980
string to say a name property,
right,

00:20:32.980 --> 00:20:36.180
and they didn't realize that we didn't
create a copy form 'cause we're just

00:20:36.180 --> 00:20:37.840
using standard key value coding.

00:20:37.850 --> 00:20:39.270
So that's not gonna work.

00:20:39.280 --> 00:20:42.950
So on managed objects,
we also implement something

00:20:42.950 --> 00:20:44.880
called primitive key value coding.

00:20:44.920 --> 00:20:48.340
And the difference here is key
value coding and your public

00:20:48.340 --> 00:20:50.980
assessors issue KVO notifications.

00:20:51.330 --> 00:20:53.380
They maintain relationships for you.

00:20:53.380 --> 00:20:55.420
You'll look in,
if you've seen the examples or

00:20:55.420 --> 00:20:57.920
in some of the other sessions,
a lot of the inverse maintenance

00:20:57.920 --> 00:20:58.800
just happened for you.

00:20:58.800 --> 00:21:02.280
When you deleted objects
in the hands-on session,

00:21:02.280 --> 00:21:04.150
they showed how you
can propagate a delete.

00:21:04.210 --> 00:21:06.580
So if you delete a recipe,
you also delete the chef that's

00:21:06.580 --> 00:21:07.580
associated with that recipe.

00:21:07.590 --> 00:21:09.590
And you can just see that all happen,
right?

00:21:09.810 --> 00:21:11.860
Primitive key value coding
doesn't do any of that.

00:21:12.110 --> 00:21:14.840
This is here as a way,
both for the framework and for yourself

00:21:15.050 --> 00:21:19.920
to just move properties in their backing
store around in a very primitive way.

00:21:19.970 --> 00:21:22.540
It doesn't go through any of
the key value coding accessors.

00:21:22.620 --> 00:21:25.740
It doesn't perform validation,
argument checking, any kind of integrity

00:21:25.760 --> 00:21:26.610
maintenance or type coercion.

00:21:26.640 --> 00:21:27.640
It's just a way to move properties
around in a very primitive way.

00:21:27.640 --> 00:21:32.220
And it's basically here for when
you subclass a managed object

00:21:32.580 --> 00:21:35.180
and you need to get at where the
framework has put the storage and

00:21:35.180 --> 00:21:38.680
you need to move it around for
implementing your own accessor methods.

00:21:40.710 --> 00:21:44.500
So as I mentioned, every managed object
has a managed object ID.

00:21:44.530 --> 00:21:48.230
And this identifies the managed
object across applications.

00:21:48.330 --> 00:21:52.120
It's scoped to the particular file that
that managed object has been saved in.

00:21:52.170 --> 00:21:54.560
So it's unique to that file.

00:21:54.720 --> 00:21:59.670
And as I keep mentioning,
they're vaguely analogous to a unique

00:21:59.760 --> 00:22:02.510
XML node or a unique SQLite row.

00:22:02.780 --> 00:22:07.760
They can be archived as shown
in a bunch of the sessions

00:22:07.840 --> 00:22:09.680
before the UI representation.

00:22:09.680 --> 00:22:14.200
You can take that URI representation
and you can customize it.

00:22:14.580 --> 00:22:16.460
You can pass it to launch services.

00:22:16.460 --> 00:22:21.140
If you saw in the Core Recipes example,
you can export a recipe to RTF.

00:22:21.140 --> 00:22:23.300
And there's a little link in
there that you can click and

00:22:23.300 --> 00:22:25.040
come back into the Core Recipes.

00:22:25.070 --> 00:22:28.800
And that's done by turning an object
ID into its URI representation.

00:22:28.800 --> 00:22:31.660
So just a couple of things to note.

00:22:31.670 --> 00:22:35.830
When you're passing the URIs around,
you can use object with ID on the

00:22:35.860 --> 00:22:39.760
context to get back the real object
that's associated with that ID.

00:22:39.760 --> 00:22:40.750
And you can also do a fetch.

00:22:40.760 --> 00:22:45.320
So you can write a predicate that
says self equals whatever the ID is.

00:22:45.320 --> 00:22:48.590
And the framework will take that
predicate and we'll find the row where

00:22:48.690 --> 00:22:50.880
basically that object has that ID.

00:22:50.900 --> 00:22:55.090
Using the fetch request is
probably better when you're passing

00:22:55.090 --> 00:22:58.220
around the URI representations,
because while someone's looking at the

00:22:58.250 --> 00:23:02.090
RTF file that has the little URL link,
someone else might've gone through

00:23:02.120 --> 00:23:05.800
and in the Core Recipes example,
deleted the object.

00:23:05.830 --> 00:23:08.600
So doing a fetch will make sure
that the object's actually still

00:23:08.600 --> 00:23:11.740
there and will give you back zero
results if it's been deleted.

00:23:11.870 --> 00:23:17.450
Object IDs are pretty much the only
thing from Core Data you can pass around

00:23:17.450 --> 00:23:19.860
with impunity in a thread safe manner.

00:23:19.880 --> 00:23:23.040
And it's important to keep
around that temporary objects,

00:23:23.040 --> 00:23:25.940
things that have been newly inserted,
also have temporary IDs.

00:23:26.110 --> 00:23:30.300
So if you're going to hand off
this object ID to something else,

00:23:30.300 --> 00:23:32.780
then you should probably save the
object first or take that into

00:23:32.860 --> 00:23:36.400
consideration that the ID will
change when the object gets saved.

00:23:36.430 --> 00:23:40.230
Similarly, if you do a store migration,
it's very easy to do on the

00:23:40.230 --> 00:23:43.820
persistent store coordinator,
convert a store, do a save as basically,

00:23:43.860 --> 00:23:46.850
all those object IDs are going
to change because the object

00:23:46.850 --> 00:23:52.110
IDs are scoped to the file,
to the store that that object is in.

00:23:53.280 --> 00:23:59.120
So as I said, NSManageObject is basically
your opportunity to subclass

00:23:59.470 --> 00:24:02.280
here in the framework,
get callbacks.

00:24:02.760 --> 00:24:07.450
and it's just important to note
that the framework is kind of

00:24:07.450 --> 00:24:09.950
responsible for maintaining
the lifecycle of these objects.

00:24:10.020 --> 00:24:12.060
When you do a fetch,
you don't have to worry

00:24:12.060 --> 00:24:14.740
about initializing,
alloc-initing these things.

00:24:14.780 --> 00:24:17.180
The framework goes off, finds them,
takes the rows,

00:24:17.210 --> 00:24:19.480
and gives you back objects.

00:24:19.530 --> 00:24:21.620
It's also important not to use init.

00:24:21.630 --> 00:24:25.600
You need to use initWithEntity,
insert into ManageObject context.

00:24:25.630 --> 00:24:30.110
And the reason for that is we
have to know what the entity is.

00:24:30.120 --> 00:24:32.090
We can't do anything useful
with ManageObject if you

00:24:32.380 --> 00:24:33.700
just pass it a blank init.

00:24:33.830 --> 00:24:39.760
And another thing is you should do
your cleanup in didTurnIntoFault,

00:24:39.780 --> 00:24:42.240
and I'll explain exactly what
faults are a little bit later,

00:24:42.280 --> 00:24:45.000
but this is actually where the
framework releases all the data

00:24:45.000 --> 00:24:46.820
associated with that ManageObject.

00:24:46.860 --> 00:24:50.430
And in doing this instead of
dialog is important because both

00:24:50.430 --> 00:24:53.710
with init and within dialog,
the object isn't in sort of the state

00:24:53.830 --> 00:24:55.710
that you're used to dealing with it.

00:24:55.820 --> 00:24:58.730
The framework isn't done, for instance,
initializing the object

00:24:58.730 --> 00:24:59.530
at the end of init.

00:24:59.700 --> 00:25:02.540
It's got to associate it with the
context and do a bunch of other things.

00:25:02.550 --> 00:25:05.000
And in the same way, in dialog,
you may no longer have

00:25:05.100 --> 00:25:06.550
a ManageObject context.

00:25:06.630 --> 00:25:09.300
So the object is kind of,
it's coming into existence

00:25:09.380 --> 00:25:12.660
or leaving existence,
and it's not in the same state that you

00:25:12.660 --> 00:25:15.310
would expect it to be in when you're
working with it most of the time.

00:25:15.350 --> 00:25:17.620
So you just need to
be careful about that.

00:25:17.720 --> 00:25:20.030
And for that reason,
we have a bunch of callbacks here

00:25:20.040 --> 00:25:23.700
that make it a little bit easier,
awake from fetch and awake from insert.

00:25:23.710 --> 00:25:27.110
And these are called after the object
has been completely initialized

00:25:27.200 --> 00:25:28.730
and the framework is done doing
everything it needs to do with it,

00:25:28.730 --> 00:25:29.940
and it hands you back, you know,
to the object.

00:25:29.940 --> 00:25:33.920
It hands you back your ManageObject,
and it will call awake from fetch

00:25:33.920 --> 00:25:36.010
on it after it's fetched it.

00:25:36.140 --> 00:25:38.170
And this is a place where
you can initialize things.

00:25:38.210 --> 00:25:40.040
You can set transients.

00:25:40.040 --> 00:25:41.310
You can set default values.

00:25:41.370 --> 00:25:43.340
You can hook up
cross-store relationships,

00:25:43.340 --> 00:25:46.960
which is something that you kind of
have to do a little work with yourself.

00:25:46.980 --> 00:25:49.530
Awake from insert is when
the object is newly created.

00:25:49.550 --> 00:25:50.420
You get that.

00:25:50.540 --> 00:25:54.500
DidTurnIntoFault is the method that
basically the framework will call.

00:25:54.500 --> 00:25:57.140
This is, you know,
the object is sort of going to sleep.

00:25:57.290 --> 00:25:58.460
It's being cleaned up.

00:25:58.640 --> 00:25:59.830
You don't need any of your resources.

00:25:59.840 --> 00:26:00.930
You don't need any of
your resources anymore.

00:26:00.950 --> 00:26:03.800
This is a good place to call back into.

00:26:03.840 --> 00:26:07.260
WillSave and DidSave will happen when
the context is saving the object.

00:26:07.360 --> 00:26:10.580
So that's if you want to,
you want to update a last

00:26:10.580 --> 00:26:12.460
save timestamp or something.

00:26:12.480 --> 00:26:14.100
WillSave is a good place for that.

00:26:14.110 --> 00:26:15.840
And DidSave is just the inverse.

00:26:15.970 --> 00:26:19.240
And then the validation callbacks
are there where you can do some very

00:26:19.320 --> 00:26:21.420
customized validation on your object.

00:26:21.450 --> 00:26:24.180
All these methods are
in nsmanageobject.h.

00:26:24.190 --> 00:26:26.890
There are comments in the header file,
so.

00:26:27.100 --> 00:26:29.000
and I will be talking about the core
data application in a little bit.

00:26:29.000 --> 00:26:32.380
It's a little more efficient
if you let Core Data manage

00:26:32.380 --> 00:26:33.990
the space for the properties.

00:26:34.000 --> 00:26:37.150
So Core Data knows about all the
properties you've declared in the model,

00:26:37.180 --> 00:26:40.940
and it's easier for us when
we fetch a row or a reading

00:26:41.140 --> 00:26:45.960
from XML to just basically slap
stuff down in our own storage.

00:26:46.000 --> 00:26:51.000
You can put attributes in your own
IVARS if you want to on a subclass.

00:26:51.000 --> 00:26:52.880
You can do that.

00:26:53.030 --> 00:26:55.980
It's mandatory for too many relationships
and fetch properties that you let us do

00:26:55.980 --> 00:27:00.800
that because we don't actually expose
the actual class that those objects are.

00:27:00.830 --> 00:27:06.290
And for too many relationships,
we encourage you to use the

00:27:06.290 --> 00:27:08.160
immutable set value for key proxy.

00:27:08.310 --> 00:27:11.300
It's gonna be more efficient than
writing your own accessor methods.

00:27:11.300 --> 00:27:12.880
It'll be a little bit faster.

00:27:12.940 --> 00:27:16.100
You can use your own accessor methods
if you have aesthetic reasons,

00:27:16.100 --> 00:27:19.140
you feel like it, but for the most part,
encourage the framework

00:27:19.200 --> 00:27:21.710
to just do its thing.

00:27:22.380 --> 00:27:24.250
You can use these IVARs, as I mentioned.

00:27:24.430 --> 00:27:28.800
They should be immutable value classes,
like NSString, NSNumber,

00:27:28.820 --> 00:27:31.350
and you can also make them scalar types.

00:27:31.470 --> 00:27:34.760
Key value coding will automatically
do boxing and unboxing across a

00:27:34.780 --> 00:27:37.320
large number of the standard C types.

00:27:37.350 --> 00:27:41.260
And when you're doing your public
access or methods on your subclass,

00:27:41.260 --> 00:27:44.810
just remember to post the
KVO notifications that are appropriate.

00:27:44.890 --> 00:27:48.800
The examples and the templates that
you build using the design tool will

00:27:48.800 --> 00:27:51.030
show you how to do that properly.

00:27:51.750 --> 00:27:55.780
Unmodeled properties are basically
IVARs that you've put on your subclass

00:27:55.780 --> 00:27:57.050
that you don't tell Core Data about.

00:27:57.170 --> 00:27:59.900
So you have a subclass,
you make some IVARs,

00:27:59.900 --> 00:28:03.320
and you don't put them in
the entity's description.

00:28:03.320 --> 00:28:04.500
You don't put them in your model.

00:28:04.500 --> 00:28:05.300
This is fine.

00:28:05.300 --> 00:28:07.630
You just have to manage
all this yourself.

00:28:07.750 --> 00:28:09.680
So this is where you
can stash data aside.

00:28:11.310 --> 00:28:13.520
Basically,
Core Data is not going to persist these.

00:28:13.700 --> 00:28:15.590
We won't know about them,
so we won't include them

00:28:15.590 --> 00:28:16.680
in our undo management.

00:28:16.680 --> 00:28:18.960
And it's preformed customization.

00:28:18.960 --> 00:28:21.790
You can maintain them in
the same callbacks you would

00:28:21.790 --> 00:28:23.340
maintain a transient in.

00:28:23.340 --> 00:28:25.440
So you can maintain them
in will save and did save,

00:28:25.460 --> 00:28:28.250
awake from fetch, awake from insert,
and you can get rid of them,

00:28:28.260 --> 00:28:30.480
clean these things up,
and did turn default.

00:28:32.900 --> 00:28:37.500
So NSManagedObject is your
basic subject of these actions,

00:28:37.530 --> 00:28:41.110
and the managed object context is where
you're gonna find a lot of the actions.

00:28:41.120 --> 00:28:45.570
So here's where it is in
our architecture diagram.

00:28:46.840 --> 00:28:50.100
And this provides a context,
a scratch pad,

00:28:50.100 --> 00:28:52.700
as we've discussed in the previous
sessions for all of your changes.

00:28:52.750 --> 00:28:55.640
It does change tracking,
relationship maintenance.

00:28:55.720 --> 00:28:57.560
It's where you're gonna
find a lot of the verbs.

00:28:57.570 --> 00:29:01.920
If you wanna save, fetch, undo,
reset everything,

00:29:01.960 --> 00:29:06.200
you'll find those actions described as
methods on the Manage Object Context.

00:29:06.240 --> 00:29:08.900
So this is a good place
to go for your actions.

00:29:13.130 --> 00:29:16.580
So for finding data,
we've covered this in previous sessions,

00:29:16.580 --> 00:29:19.500
go over briefly fetch requests,
which have an entity,

00:29:19.600 --> 00:29:21.240
that's the type of data
you're looking for,

00:29:21.240 --> 00:29:24.440
a predicate, which is optional,
and a sort descriptor, which is also,

00:29:24.440 --> 00:29:25.140
again, optional.

00:29:25.140 --> 00:29:28.020
And predicates and sort descriptors
are both described in foundation.

00:29:28.020 --> 00:29:31.460
You pass the request to the context
you want to fetch these objects

00:29:31.570 --> 00:29:35.140
and associate them with using
the execute fetch request method.

00:29:35.140 --> 00:29:39.400
Two things that weren't covered
very deeply in previous sessions,

00:29:39.400 --> 00:29:41.150
there are two other ways.

00:29:41.520 --> 00:29:44.310
If you have an object ID,
you can ask a context

00:29:44.380 --> 00:29:46.240
for exactly that object.

00:29:46.260 --> 00:29:49.580
And you can use object with ID,
which will always give you a proxy.

00:29:49.580 --> 00:29:53.420
So it's not going to go to the file
and make sure that that row exists.

00:29:53.420 --> 00:29:55.660
It's going to give you
a proxy for that ID.

00:29:55.660 --> 00:29:58.270
And whenever you use it,
it will automatically

00:29:58.740 --> 00:30:00.280
go off and get the data.

00:30:00.280 --> 00:30:02.740
You can also use object
registered for ID,

00:30:02.740 --> 00:30:05.160
which will only give you back
a result if it's already been

00:30:05.160 --> 00:30:06.640
registered with the context.

00:30:06.640 --> 00:30:09.190
So that's a way to distinguish between
something you've already fetched.

00:30:09.780 --> 00:30:12.710
And you need to take an ID and
turn it into an object or something

00:30:12.750 --> 00:30:14.540
for which you just want a proxy.

00:30:17.130 --> 00:30:20.440
It's important to note unsaved
changes affect fetching.

00:30:20.480 --> 00:30:24.580
So the context is providing you
a view around a set of changes.

00:30:24.730 --> 00:30:27.070
And when you do fetches,
those changes are gonna be

00:30:27.070 --> 00:30:28.290
reflected in the results.

00:30:28.320 --> 00:30:33.040
So what this means is that the context
has to take the predicate that you've

00:30:33.040 --> 00:30:36.460
associated with the fetch request
and check if any of the inserted

00:30:36.540 --> 00:30:41.260
objects match it because the XML file
or SQLite isn't gonna be able to

00:30:41.500 --> 00:30:44.370
know about these newly inserted
objects that you haven't saved yet.

00:30:44.430 --> 00:30:46.970
And it's also gonna have to take
into consideration deletions that

00:30:46.970 --> 00:30:50.060
you haven't saved yet and whether
or not any changes you've made will

00:30:50.100 --> 00:30:52.630
change the results of that predicate.

00:30:52.660 --> 00:30:55.340
For this reason,
if you have a lot of unsaved changes,

00:30:55.360 --> 00:30:58.910
it's gonna be a bit slower
when you do a fetch.

00:31:00.760 --> 00:31:03.510
- Deleting an object from a
context is pretty straightforward.

00:31:03.560 --> 00:31:04.620
There's just a delete method.

00:31:04.770 --> 00:31:10.060
And what I really want to drive home
here is that a lot of these things

00:31:10.150 --> 00:31:12.270
are queued up until you actually save.

00:31:12.400 --> 00:31:16.430
So with the delete method,
you have a pending delete,

00:31:16.430 --> 00:31:17.480
and that object is marked.

00:31:17.530 --> 00:31:19.490
You can ask it, you know,
are you deleted?

00:31:19.500 --> 00:31:22.480
And it'll say, yeah,
I'll be deleted in the next save.

00:31:24.310 --> 00:31:28.210
But those changes are coalesced,
and you can still work with the object.

00:31:28.260 --> 00:31:31.800
It's perfectly valid until
you save that deletion.

00:31:33.930 --> 00:31:37.070
Saving changes,
the managed object context, as I said,

00:31:37.070 --> 00:31:39.680
it coalesces all these changes together.

00:31:39.720 --> 00:31:43.580
So it'll grab all the inserts,
the deletes, and it'll create a request,

00:31:43.580 --> 00:31:46.050
and it'll ask the persistent
store coordinator to go off

00:31:46.060 --> 00:31:47.610
and handle that request.

00:31:47.640 --> 00:31:49.910
And the persistent store
coordinator will figure out which

00:31:49.910 --> 00:31:54.820
objects should go to which file,
which store, and send off appropriate

00:31:55.060 --> 00:31:58.520
requests to those stores,
and each store will then use its own

00:31:58.520 --> 00:32:00.470
native mechanism for dealing with it.

00:32:00.510 --> 00:32:04.160
So our XML store uses
foundations and as XML.

00:32:04.170 --> 00:32:07.180
The SQLite store obviously
talks with SQLite,

00:32:07.230 --> 00:32:10.570
and the binary store
is using key archiving.

00:32:11.970 --> 00:32:14.700
So there are a bunch of different
things if you've made some changes

00:32:14.730 --> 00:32:16.090
and you want to get rid of them.

00:32:16.180 --> 00:32:19.540
Rollback will set you back
to the previous saved state.

00:32:19.570 --> 00:32:21.500
So that's,
you've made some changes and you want

00:32:21.500 --> 00:32:24.700
to go back to what you're doing and
continue working with the context.

00:32:24.810 --> 00:32:28.140
Reset will turn the context
back into its zero state,

00:32:28.150 --> 00:32:31.060
its initial state,
and that will invalidate all of the

00:32:31.060 --> 00:32:33.400
objects associated with that context.

00:32:33.400 --> 00:32:36.680
So you won't be able to use any
of those references anymore.

00:32:36.680 --> 00:32:40.970
This is really mostly useful if you have
a context and it's wired into a nib or

00:32:40.970 --> 00:32:44.700
a controller and it's really difficult
to just release it and have it dealloc

00:32:44.740 --> 00:32:46.190
and create a new one and replace it.

00:32:46.230 --> 00:32:48.790
If you're working with code,
your own context,

00:32:48.910 --> 00:32:52.660
you'd probably just throw away the
old context and create a new one.

00:32:52.900 --> 00:32:55.970
And then we provide undo support for you.

00:32:56.020 --> 00:32:59.940
We can undo and redo across saves,
handle relationships,

00:33:00.000 --> 00:33:02.880
deletions propagating through
a series of relationships,

00:33:02.890 --> 00:33:04.030
and that all works.

00:33:04.040 --> 00:33:07.960
We use the standard NSUndoManager
API provided in foundation.

00:33:08.080 --> 00:33:10.520
You can get an undo
manager from the context.

00:33:12.060 --> 00:33:15.940
And configure it using
the undo manager API.

00:33:16.060 --> 00:33:20.380
So for instance, you may, oh,
and we also do event-based undo

00:33:20.380 --> 00:33:22.990
groupings with the undo manager.

00:33:23.020 --> 00:33:27.310
So you can call process pending
changes to alter that and to

00:33:27.320 --> 00:33:30.700
immediately coalesce all the
changes that the context might make.

00:33:30.720 --> 00:33:35.900
And this is how you might, for instance,
get the undo manager from the context,

00:33:36.050 --> 00:33:39.060
flush out any pending changes
using process pending changes,

00:33:39.110 --> 00:33:44.300
and then tell the undo manager to disable
further changes and do some stuff,

00:33:44.410 --> 00:33:48.730
flush out those changes,
and then re-enable the undo management.

00:33:50.260 --> 00:33:53.290
So for synchronizing changes,
you have a bunch of different

00:33:53.350 --> 00:33:55.080
contexts in your application.

00:33:55.090 --> 00:33:58.620
There's some issues
with keeping data fresh.

00:33:58.660 --> 00:34:02.240
Basically,
if you've pulled in data into a context,

00:34:02.280 --> 00:34:04.910
we try not to disturb
that unless you ask us to.

00:34:04.990 --> 00:34:07.900
So if you refetch the data,
we're gonna give you the view

00:34:07.960 --> 00:34:09.750
that you were working with.

00:34:09.800 --> 00:34:14.400
So you'll need to use refresh object
with the merge changes parameter to force

00:34:14.400 --> 00:34:19.520
us to throw away the view of the object
you're working with and get the latest.

00:34:19.550 --> 00:34:21.880
You can also use the
set stillness interval,

00:34:21.890 --> 00:34:26.260
which will kind of automatically
tell us that you wanna go back

00:34:26.390 --> 00:34:30.340
to the file and refetch new data
at a particular time interval.

00:34:30.480 --> 00:34:34.560
And the alternative here,
which is kind of what we encourage,

00:34:34.560 --> 00:34:38.220
unless you are specifically poking
at an object that you wanna refresh,

00:34:38.220 --> 00:34:39.800
is to just let the data get stale.

00:34:39.830 --> 00:34:42.770
And if there's a conflict,
handle the conflict.

00:34:42.820 --> 00:34:45.230
And you do that with a merge policy.

00:34:46.010 --> 00:34:48.440
So talk a bit about merge policies.

00:34:48.470 --> 00:34:52.400
And what merge policies are is a
way of handling conflicting rights.

00:34:52.430 --> 00:34:56.320
If you have multiple threads working
with different contexts and they

00:34:56.460 --> 00:34:59.920
both try to write to the same data,
you're gonna have to resolve that.

00:34:59.950 --> 00:35:03.580
And the merge policy is a way of
telling the framework what you wanna do.

00:35:03.630 --> 00:35:05.800
But you can also get into a
situation where you have a

00:35:05.800 --> 00:35:08.470
bunch of different contexts,
just a single thread,

00:35:08.530 --> 00:35:12.950
say you have an inspector window,
and they both manage the same object.

00:35:12.980 --> 00:35:14.030
They do a save.

00:35:15.420 --> 00:35:17.800
you're going to have to
do something about that.

00:35:18.980 --> 00:35:23.120
So basically what the framework does
is we detect these conflicts and

00:35:23.260 --> 00:35:25.400
it's an optimistic locking paradigm.

00:35:25.420 --> 00:35:29.870
This is a fairly standard paradigm where
basically we keep information about the

00:35:29.890 --> 00:35:34.540
objects you fetched and whether or not
change has been made to those objects.

00:35:34.560 --> 00:35:37.900
And we write out those changes and we
assume that the saves are gonna succeed.

00:35:37.930 --> 00:35:41.540
And if the store says, nope,
I can't do that 'cause the data's

00:35:41.540 --> 00:35:44.210
changed up from underneath you,
we'll get this failure,

00:35:44.330 --> 00:35:47.780
we'll roll back the transaction,
and we'll report it to you.

00:35:47.820 --> 00:35:51.370
It's important that there's a slight
difference between the store types.

00:35:51.420 --> 00:35:54.260
So the XML and the binary
store types are atomic,

00:35:54.310 --> 00:35:56.620
which means you read and
write them in their entirety.

00:35:56.660 --> 00:35:58.570
So they'll work like an NS document.

00:35:58.850 --> 00:36:01.020
They'll just overwrite
whatever's on disk.

00:36:01.100 --> 00:36:04.440
So it will only detect conflicts
within your application,

00:36:04.490 --> 00:36:06.880
within the same persistent
store coordinator.

00:36:06.960 --> 00:36:09.980
But the SQLite store does
partial reads and writes,

00:36:10.000 --> 00:36:12.140
and it will handle,
if you have multiple processes

00:36:12.200 --> 00:36:16.690
writing to the same SQLite file,
it'll handle conflict detection there.

00:36:17.320 --> 00:36:19.970
And the basic merge policies we have,
we have five of them.

00:36:20.030 --> 00:36:21.120
They're fairly simple.

00:36:21.150 --> 00:36:22.900
The error merge policy
is the default one.

00:36:22.900 --> 00:36:25.480
This is mostly a reminder
that you haven't set one,

00:36:25.650 --> 00:36:29.560
but it also has a user info dictionary
that will describe in great detail,

00:36:29.560 --> 00:36:32.840
which objects had conflicts,
which properties they were.

00:36:32.840 --> 00:36:36.630
And you can use that information if
you want a very customized approach.

00:36:36.910 --> 00:36:39.670
You can get that,
you can refresh those objects and

00:36:39.670 --> 00:36:43.810
then save again using the information
in the user info dictionary.

00:36:44.310 --> 00:36:45.890
The next four are prepackaged.

00:36:46.100 --> 00:36:47.300
They'll do all the work for you.

00:36:47.300 --> 00:36:48.760
They won't even report a conflict.

00:36:48.760 --> 00:36:50.140
They'll just resolve it for you.

00:36:50.180 --> 00:36:53.800
And the overwrite merge policy is
basically the last writer wins.

00:36:53.800 --> 00:36:56.760
This is if you want sort of
an NSDocument-style behavior.

00:36:56.760 --> 00:36:59.400
The rollback merge policy
is the first writer wins,

00:36:59.400 --> 00:37:06.020
and any subsequent writers, excuse me,
basically will throw away their changes

00:37:06.020 --> 00:37:08.080
and pull in what the first person did.

00:37:08.080 --> 00:37:11.240
And then the next two
are basically those,

00:37:11.240 --> 00:37:12.970
but on a property-by-property basis.

00:37:13.500 --> 00:37:15.440
So any properties that
haven't been changed,

00:37:15.440 --> 00:37:19.040
you'll be able to write over,
and then the properties which conflict,

00:37:19.040 --> 00:37:22.100
you'll resolve as either a first
writer or last writer wins.

00:37:24.590 --> 00:37:28.140
Now, you can also have conflicts that
are sort of semantic conflicts

00:37:28.380 --> 00:37:29.740
with data that you haven't changed.

00:37:29.740 --> 00:37:33.830
For instance, if you go to Expedia and
you book a flight that has

00:37:33.970 --> 00:37:37.410
a bunch of different legs,
then you try to check out,

00:37:37.410 --> 00:37:41.000
you'll notice that if the flight
prices have changed in between

00:37:41.000 --> 00:37:44.150
the time you started the process,
I find that when I book

00:37:44.150 --> 00:37:47.350
flights near midnight,
this seems to happen a lot,

00:37:47.430 --> 00:37:51.080
then when I check out, it says,
I can't do that because

00:37:51.080 --> 00:37:53.060
the prices have changed.

00:37:53.060 --> 00:37:56.340
So one way you can use is
there's a method on the context.

00:37:56.390 --> 00:37:59.360
It's called detect conflicts for object.

00:37:59.360 --> 00:38:03.020
And what this will do is this will flag
an object that you want to make sure that

00:38:03.020 --> 00:38:05.270
it hasn't changed out from beneath you.

00:38:05.280 --> 00:38:08.570
So if you have a running total
that's saved on a third object,

00:38:08.620 --> 00:38:11.650
and then you have cost and
cost two on separate objects,

00:38:11.750 --> 00:38:15.170
and the costs haven't changed
when you make your running total,

00:38:15.180 --> 00:38:18.200
and you just want to write
out a new running total,

00:38:18.200 --> 00:38:21.260
you can mark those cost
one and cost two objects.

00:38:21.620 --> 00:38:24.260
And ensure that they don't
change out from underneath you,

00:38:24.270 --> 00:38:26.920
particularly like with the
SQLite store if you have another

00:38:26.950 --> 00:38:28.900
application working with that file.

00:38:31.090 --> 00:38:35.810
So I'm going to talk a little bit
about using multiple contexts with

00:38:35.810 --> 00:38:38.350
working with different change sets.

00:38:39.000 --> 00:39:01.400
[Transcript missing]

00:39:03.200 --> 00:39:53.800
[Transcript missing]

00:39:55.400 --> 00:39:57.690
So a few details.

00:39:57.730 --> 00:40:02.230
Inserted objects have temporary IDs,
so only the context that has that

00:40:02.230 --> 00:40:06.280
inserted object will be able to see it,
and other contexts won't.

00:40:06.340 --> 00:40:09.730
So again,
same as if you're moving objects between

00:40:09.740 --> 00:40:13.430
applications using a URI representation,
you have the same issue here,

00:40:13.440 --> 00:40:15.760
working with different contexts.

00:40:15.760 --> 00:40:18.740
You probably want to save the
object before it's visible.

00:40:18.790 --> 00:40:20.660
It's in the next context.

00:40:20.710 --> 00:40:25.260
Also, if you're trying to decide whether
or not you want to work with one

00:40:25.330 --> 00:40:28.260
persistent store coordinator or
multiple persistent store coordinators,

00:40:28.260 --> 00:40:32.280
one thing to keep in mind is sharing a
persistent store coordinator is going

00:40:32.280 --> 00:40:36.170
to share the caches that Core Data uses
to help speed things up and know

00:40:36.230 --> 00:40:39.270
which objects you're working with
and which you've already fetched.

00:40:39.310 --> 00:40:41.840
And multiple persistent
store coordinators is going

00:40:41.840 --> 00:40:44.160
to duplicate that caching.

00:40:44.890 --> 00:40:46.460
All right,
so I'm gonna hand you back over

00:40:46.460 --> 00:40:50.040
to Melissa right now to talk about
the persistent store coordinator.

00:40:58.660 --> 00:41:02.710
So what you've heard until now is
pretty much the stuff that you are

00:41:02.710 --> 00:41:04.690
mostly going to be working with.

00:41:04.790 --> 00:41:07.430
But just because it's really useful
and sometimes will avoid having

00:41:07.430 --> 00:41:10.600
you shoot yourself in the foot,
it's helpful to know about how

00:41:10.600 --> 00:41:12.600
things work under the covers.

00:41:12.600 --> 00:41:19.070
And that would be the persistent
store coordinator and the object

00:41:19.070 --> 00:41:19.070
stores and all the stuff down
there at the bottom of the stack.

00:41:19.900 --> 00:41:22.860
Persistent Store Coordinator is
essentially a bridge between the

00:41:22.880 --> 00:41:26.360
object lifecycle management that is
done by the managed object context

00:41:26.540 --> 00:41:28.400
and the persistence mechanism,
which is the stores.

00:41:28.400 --> 00:41:32.610
In a very real sense,
it's the center of the frameworks world.

00:41:32.620 --> 00:41:35.860
You've got one persistent
store coordinator per stack,

00:41:35.860 --> 00:41:39.660
but you can have any number of
managed object contexts on top of it,

00:41:39.660 --> 00:41:43.970
and any other number of persistent
stores spewed out on the bottom.

00:41:44.000 --> 00:41:46.800
There's only ever going to be
one persistent store coordinator.

00:41:47.740 --> 00:41:51.780
Its main purpose is to provide
a facade of there being a single

00:41:51.780 --> 00:41:53.160
store to the managed object context.

00:41:53.160 --> 00:41:55.710
The managed object context
doesn't need to know or care about

00:41:55.710 --> 00:41:57.160
where its data is coming from.

00:41:57.160 --> 00:41:59.680
It just knows it talks to the
persistence store coordinator,

00:41:59.680 --> 00:42:01.750
the persistence store
coordinator takes care of stuff.

00:42:01.760 --> 00:42:04.360
When you create a persistence
store coordinator,

00:42:04.360 --> 00:42:06.840
you initialize it with
a managed object model,

00:42:06.840 --> 00:42:10.070
and at that point when you do that,
that managed object model gets frozen.

00:42:10.080 --> 00:42:12.560
We talked earlier about
modifying models at runtime.

00:42:12.560 --> 00:42:16.320
You can only do that until you attach
one to a persistence store coordinator.

00:42:16.320 --> 00:42:19.700
If you try and do it after that,
you'll get exceptions.

00:42:21.470 --> 00:42:22.920
If you've already looked
at the documentation,

00:42:22.920 --> 00:42:24.040
then yes, we've heard this.

00:42:24.040 --> 00:42:25.200
A lot of you have said, "What?

00:42:25.210 --> 00:42:30.060
There's no NSObjectStore,
NSPersistentStore API?" No, there isn't.

00:42:30.160 --> 00:42:33.220
All interaction goes through the
NSPersistentStore coordinator.

00:42:33.290 --> 00:42:38.170
And you create stores
using the AddStore API,

00:42:38.170 --> 00:42:44.470
and we have a number of types
that we support out of the box.

00:42:44.490 --> 00:42:45.590
It's the binary, XML, SQLite,
and in-memory store types.

00:42:46.000 --> 00:42:49.040
Which brings us to a decision when
you're building an application.

00:42:49.040 --> 00:42:50.910
What kind of store do we want to use?

00:42:50.940 --> 00:42:55.380
Each type has its advantages
and disadvantages.

00:42:55.480 --> 00:42:58.480
For example,
the XML store is probably the

00:42:58.480 --> 00:43:00.120
slowest of all of our stores.

00:43:00.120 --> 00:43:04.620
As we all know,
XML is big and slow to parse.

00:43:05.150 --> 00:43:08.280
It takes in and writes out the
whole object graph all at once,

00:43:08.310 --> 00:43:11.680
but it does have the unique advantage
of being externally parsable,

00:43:11.680 --> 00:43:19.170
and you can transform the data in
your XML store using an XSLT so

00:43:19.170 --> 00:43:19.170
that other applications can read it.

00:43:19.210 --> 00:43:22.430
We've also got a binary store,
which is a lot faster than the

00:43:22.430 --> 00:43:25.170
XML store and even faster than
the SQL store if we're talking

00:43:25.210 --> 00:43:27.200
pure qualification in memory.

00:43:27.200 --> 00:43:29.760
It takes a bit longer to load in,
a lot longer if you've

00:43:29.800 --> 00:43:31.200
got a huge object graph.

00:43:31.200 --> 00:43:33.100
And again, it works on the whole graph.

00:43:33.200 --> 00:43:36.370
This is probably the best kind of
store for if you want to do application

00:43:36.490 --> 00:43:38.140
preferences or that kind of thing.

00:43:38.260 --> 00:43:42.110
Fairly small object graph
that's neatly contained.

00:43:42.360 --> 00:43:46.040
Doesn't have any of those
other advantages though.

00:43:46.080 --> 00:43:48.660
There's the SQLite store,
which is going to be the

00:43:49.020 --> 00:43:50.540
fastest for most things.

00:43:50.540 --> 00:43:53.920
It has a really,
really huge advantage in scalability

00:43:53.940 --> 00:43:56.890
in that it's capable of having
only pieces of your object

00:43:56.890 --> 00:43:58.700
graph read in at any one time.

00:43:58.700 --> 00:44:01.900
Just the subset of objects that
you're actually working with now.

00:44:01.900 --> 00:44:03.250
It's really, really useful.

00:44:03.250 --> 00:44:05.700
You don't need to care or
manage any of the other stuff.

00:44:06.000 --> 00:44:09.190
We also have an in-memory store,
which is fast and which also

00:44:09.190 --> 00:44:12.700
manages the whole object graph,
but doesn't have a backing store.

00:44:12.700 --> 00:44:15.990
And why would you care about that?

00:44:15.990 --> 00:44:17.490
I mean, it's just like any other store.

00:44:17.490 --> 00:44:18.400
It doesn't save to disk.

00:44:18.430 --> 00:44:19.340
Why would I use that?

00:44:19.380 --> 00:44:22.980
It can be useful if you've got objects
that you want to have transient.

00:44:23.000 --> 00:44:26.320
We have an example of this in the
Core Recipes application where we

00:44:26.320 --> 00:44:29.620
have the smart groups that appear
in the left-hand browser for the

00:44:29.630 --> 00:44:31.800
library and for the imported files.

00:44:31.800 --> 00:44:35.000
We just create those and stuff
them into an in-memory store,

00:44:35.000 --> 00:44:38.540
which we can then use and query
and join relationships off of.

00:44:38.680 --> 00:44:40.780
They never get saved because
we don't really need to take

00:44:40.810 --> 00:44:42.520
up space on disk with it.

00:44:42.520 --> 00:44:44.680
I mean, they're always the same.

00:44:44.730 --> 00:44:48.120
We can create them up front every time,
but we need them to act

00:44:48.230 --> 00:44:49.470
like managed objects.

00:44:49.560 --> 00:44:50.320
That's how you do it.

00:44:50.380 --> 00:44:55.130
They also have one other really huge use,
which is handling legacy file formats.

00:44:55.200 --> 00:44:58.540
Well,

00:44:59.120 --> 00:45:01.420
At this point,
I'd say it's a safe bet that none

00:45:01.420 --> 00:45:04.230
of you have a Core Data application,
so none of you have your data

00:45:04.280 --> 00:45:06.980
being stored in one of the
Core Data specific formats.

00:45:07.100 --> 00:45:12.110
If you did,
I'm pretty sure somebody wants to

00:45:12.110 --> 00:45:12.110
talk to you about violation of NDAs.

00:45:13.820 --> 00:45:15.470
So how do you deal with Core Data?

00:45:15.480 --> 00:45:16.460
How do you use Core Data?

00:45:16.460 --> 00:45:19.620
There's a lot of advantages
in Core Data that aren't

00:45:19.690 --> 00:45:21.120
just specific to persistence.

00:45:21.120 --> 00:45:25.010
You may want to use all of the
object lifecycle management stuff,

00:45:25.020 --> 00:45:27.910
but you still, for one reason or another,
need to live with your

00:45:27.910 --> 00:45:29.020
legacy file format.

00:45:29.820 --> 00:45:34.640
You create your stack and back
it with an in-memory store.

00:45:34.870 --> 00:45:40.270
And in your initialization methods
for your application or your load

00:45:40.270 --> 00:45:44.540
methods for your application,
you read in your data

00:45:44.540 --> 00:45:45.840
in your legacy format.

00:45:45.840 --> 00:45:45.840
You go through, create NSNNs,
and then you go through and create

00:45:45.840 --> 00:45:45.840
your own legacy file format.

00:45:45.840 --> 00:45:45.840
So how do you deal with Core Data?

00:45:45.840 --> 00:45:45.840
How do you use Core Data?

00:45:45.840 --> 00:45:45.840
How do you use Core Data?

00:45:45.840 --> 00:45:45.840
There's a lot of advantages
in Core Data that aren't

00:45:45.840 --> 00:45:45.840
just specific to persistence.

00:45:45.840 --> 00:45:45.840
You may want to use all of the
object lifecycle management stuff,

00:45:45.840 --> 00:45:45.840
but you still, for one reason or another,
need to live with your

00:45:45.840 --> 00:45:45.840
legacy file format.

00:45:45.840 --> 00:45:50.460
You create your stack and back
it with an in-memory store.

00:45:50.460 --> 00:45:53.900
And in your initialization methods
for your application or your load

00:45:53.900 --> 00:45:56.380
methods for your application,
you read in your data

00:45:56.560 --> 00:45:57.800
in your legacy format.

00:45:57.840 --> 00:45:57.840
You go through, create NSNNs,
and then you go through and create

00:45:57.840 --> 00:45:57.840
your own legacy file format.

00:45:57.890 --> 00:45:59.490
- I'm afraid.

00:46:00.300 --> 00:46:01.920
And then you save,
and they get shoved off

00:46:02.010 --> 00:46:04.590
down to the in-memory store,
and you can then register and catch for

00:46:04.710 --> 00:46:06.850
the NSManagedObjectDidSave notification.

00:46:06.870 --> 00:46:10.710
And at that point, you go off,
pull all those objects associated

00:46:10.710 --> 00:46:13.770
with the in-memory store out,
serialize them using whatever

00:46:13.770 --> 00:46:16.230
mechanism you were using before,
and stuff them back out

00:46:16.300 --> 00:46:17.270
in your legacy file.

00:46:17.280 --> 00:46:20.280
This gives you the ability to
switch slowly over to Core Data.

00:46:20.310 --> 00:46:21.520
You don't have to go whole hog.

00:46:21.520 --> 00:46:22.500
You don't have to do it all at once.

00:46:22.500 --> 00:46:23.800
You don't have to write everything.

00:46:23.800 --> 00:46:28.200
You don't have to severely upset your
management chain when they're going,

00:46:28.200 --> 00:46:30.840
well, we have this file format we've
had for the last 10 years.

00:46:30.840 --> 00:46:31.570
We want to keep it.

00:46:31.620 --> 00:46:35.040
You can still use Core Data and
get a lot of the benefits of it

00:46:35.050 --> 00:46:37.000
by using the in-memory store.

00:46:41.230 --> 00:46:43.400
Switching a little bit,
we'll talk about working

00:46:43.400 --> 00:46:44.490
with multiple stores.

00:46:44.540 --> 00:46:45.990
Ben has talked about this.

00:46:45.990 --> 00:46:47.040
I've talked about this.

00:46:47.040 --> 00:46:48.440
You can have one
persistent store corridor,

00:46:48.530 --> 00:46:49.130
multi-stores.

00:46:49.140 --> 00:46:53.280
By default, if you have a stack that
has multiple stores,

00:46:53.280 --> 00:46:56.980
we're going to send the fetch
request when you request information

00:46:56.980 --> 00:47:00.240
to retrieve data from all stores
that could possibly contain objects

00:47:00.240 --> 00:47:01.600
of the type you're looking for.

00:47:01.600 --> 00:47:05.540
You can use the affected stores
accessor on the fetch requests to

00:47:05.540 --> 00:47:10.440
narrow down your queries so you only
get objects back from a specific store.

00:47:11.200 --> 00:47:16.220
We also, if you're using multiple stores,
will automatically do object

00:47:16.220 --> 00:47:17.930
assignment at save time.

00:47:18.120 --> 00:47:21.680
We'll basically go through all of the
inserted objects in your object graph,

00:47:21.980 --> 00:47:26.070
figure out which stores they can be
assigned to based on which entities

00:47:26.090 --> 00:47:32.340
are in which stores and which entities
your object has relationships to.

00:47:32.340 --> 00:47:34.500
We'll figure out the best
fit and put it in there.

00:47:34.500 --> 00:47:38.330
Sometimes we can't do this because
you've done something that's a little

00:47:38.330 --> 00:47:41.320
not kosher and we'll return it and say,
we've done what we can,

00:47:41.390 --> 00:47:42.730
you're going to have to do the rest.

00:47:43.080 --> 00:47:46.720
Or if you want to avoid that entirely,
you can assign objects when you

00:47:46.750 --> 00:47:51.980
create them using the NSManagedObject
assign object to persistent store API.

00:47:52.220 --> 00:47:54.910
You use configurations,
we mentioned those earlier in the model,

00:47:54.910 --> 00:47:58.700
they're a way of creating named
groups of entities to assign

00:47:58.760 --> 00:48:00.990
sets of entities to stores.

00:48:01.180 --> 00:48:06.000
You do this when you add the store
to the persistent store coordinator,

00:48:06.040 --> 00:48:12.360
one of the parameters in that call is
a configuration name which you'll use

00:48:12.380 --> 00:48:14.660
to say which entities go in that store.

00:48:14.810 --> 00:48:16.610
There's some considerations
that you have to,

00:48:16.780 --> 00:48:18.690
there's some things you have to
take into account if you're using

00:48:18.690 --> 00:48:20.900
multiple stores and Cocoa bindings,
which is that out of the box,

00:48:20.980 --> 00:48:22.600
we don't support
cross-store relationships.

00:48:22.600 --> 00:48:25.940
So if you tie this with the
first bullet point on this slide,

00:48:26.020 --> 00:48:29.740
which is that we fetch,
we retrieve all data from all stores.

00:48:29.740 --> 00:48:33.020
If you have,
back in the Core Recipes example,

00:48:33.020 --> 00:48:38.880
chefs and recipes in a number of stores,
you have a pop-up list backed

00:48:38.880 --> 00:48:43.800
by an NSArray controller that
knows it is fetching chefs.

00:48:44.100 --> 00:48:49.380
It may and will actually fetch chefs
from both stores when you're in your

00:48:49.380 --> 00:48:52.320
recipes view and trying to figure out
which chef to assign the recipe for.

00:48:52.320 --> 00:48:55.540
You're going to have to be careful
and do some workarounds to,

00:48:55.540 --> 00:49:00.330
you know, make sure that the chefs that
appear in that pop-up list...

00:49:00.810 --> 00:49:02.660
Don't accidentally create
a cross-store relationship.

00:49:02.660 --> 00:49:04.420
So you're really going to have to
think about this kind of thing.

00:49:04.420 --> 00:49:10.840
This is where using the affected
stores accessors to narrow down the

00:49:10.840 --> 00:49:13.160
sets of objects can come in really,
really useful.

00:49:13.160 --> 00:49:16.810
So you have to think about that when
you're using bindings and a core data

00:49:16.810 --> 00:49:19.240
application with multiple stores.

00:49:19.240 --> 00:49:22.690
There's lots and lots of stuff I could
go on for like 15 minutes about it,

00:49:22.800 --> 00:49:26.040
but that gives you enough of a pointer
to know where to go look for things,

00:49:26.040 --> 00:49:27.360
what to think about.

00:49:28.260 --> 00:49:32.520
As Ben mentioned earlier,
store migration, save as,

00:49:32.520 --> 00:49:34.160
is pretty simple.

00:49:34.160 --> 00:49:36.460
There's one call on the
persistent store coordinator.

00:49:36.460 --> 00:49:38.830
Some things you need to think about
when you're doing it is that it

00:49:38.910 --> 00:49:42.560
works by pulling everything in the
store into memory and resaving it.

00:49:42.640 --> 00:49:45.060
It's kind of time and memory expensive.

00:49:46.740 --> 00:49:50.900
And once it's done, the old object store
is going to be removed.

00:49:50.900 --> 00:49:53.960
The managed object context is
designed to take care of this.

00:49:53.960 --> 00:49:56.270
We'll switch object
IDs out from under it.

00:49:56.410 --> 00:49:59.610
But the object IDs themselves in
those managed objects that you've

00:49:59.610 --> 00:50:02.790
got a hold of will be invalid,
will change, among other things,

00:50:02.800 --> 00:50:04.420
the store ID when we do this.

00:50:04.420 --> 00:50:06.300
So you're going to have
to get rid of those object

00:50:06.300 --> 00:50:09.740
IDs and somehow retrieve them.

00:50:09.810 --> 00:50:13.220
Best to hang onto if you know
that you're going to be doing this

00:50:13.220 --> 00:50:15.370
managed objects rather than IDs.

00:50:16.220 --> 00:50:19.240
But I said it's simple
and that's the call.

00:50:19.320 --> 00:50:22.490
That's all you have
to do to do a Save As.

00:50:26.550 --> 00:50:28.450
This is just sort of the
random stuff section.

00:50:28.470 --> 00:50:30.400
So at some point,
you're going to have to decide what kind

00:50:30.490 --> 00:50:32.080
of Core Data stack you want to build.

00:50:32.080 --> 00:50:34.450
Do you want to use an
NS-persistent document or not?

00:50:34.500 --> 00:50:36.120
The answer is actually pretty simple.

00:50:36.120 --> 00:50:38.160
You're going to want to use
NS-persistent document if your

00:50:38.160 --> 00:50:40.820
data is completely encapsulated,
doesn't have relationships.

00:50:40.990 --> 00:50:43.740
You don't need to worry about
data coming up from other sources.

00:50:43.830 --> 00:50:48.250
Otherwise, you're going to want a
non-document-based application.

00:50:49.100 --> 00:50:50.940
The big bug about
cross-story relationships.

00:50:50.940 --> 00:50:55.860
We've had questions about this, and,
well, it's not supported out of the box.

00:50:55.960 --> 00:50:59.160
But there is a way to implement
it using the transient properties

00:50:59.160 --> 00:51:01.640
that we've talked about
and/or using fresh properties.

00:51:01.770 --> 00:51:04.560
But in both cases,
you're going to need a custom subclass

00:51:04.560 --> 00:51:08.930
of NSManagedObject to do the dirty work.

00:51:08.950 --> 00:51:10.700
There's two basic patterns.

00:51:10.800 --> 00:51:15.160
One of which is that you update
the persistent storage-- I'll

00:51:15.170 --> 00:51:19.260
explain that in a sec-- at set
time when you set the attribute,

00:51:19.260 --> 00:51:20.040
the relationship.

00:51:20.040 --> 00:51:21.600
Sorry.

00:51:21.600 --> 00:51:26.130
You override your custom accessor to
push data into a backing attribute,

00:51:26.130 --> 00:51:26.980
and you'll--

00:51:27.810 --> 00:51:30.190
is the founder and founder
of the Backing Store.

00:51:30.190 --> 00:51:37.170
He's been working on the
Backing Store for over 20 years.

00:51:37.170 --> 00:51:37.170
He's been working on a
number of other things,

00:51:37.170 --> 00:51:37.170
including the Backing Store for the

00:51:38.000 --> 00:51:44.000
Create an object that has two properties,
one of which is the

00:51:44.080 --> 00:51:47.640
relationship property,
and you mark that as transient.

00:51:47.640 --> 00:51:50.150
The other of which is
going to be an attribute,

00:51:50.150 --> 00:51:53.360
and it's going to be an NSData,
and it's going to contain all

00:51:53.360 --> 00:51:56.870
of the information about the
objects in that relationship.

00:51:58.140 --> 00:52:03.570
For example, say we have a model that we
want to have look like this.

00:52:03.770 --> 00:52:07.740
We've got a Chef object, managed object,
has first name, last name,

00:52:07.810 --> 00:52:09.000
and a bunch of recipes.

00:52:09.120 --> 00:52:11.580
We have a recipe object with a name,
description,

00:52:11.710 --> 00:52:13.600
and a relationship back to that Chef.

00:52:13.750 --> 00:52:17.000
What do we do if we want to have that
relationship cross a store boundary?

00:52:17.000 --> 00:52:21.500
Well, the first thing we have to
do is on both objects we have

00:52:21.500 --> 00:52:26.790
to add an NSData attribute,
call it recipes_urls and chef_id_url.

00:52:27.410 --> 00:52:29.040
And then we get into the writing of code.

00:52:29.040 --> 00:52:31.920
We've chosen to use the second
pattern here in WillSave.

00:52:31.920 --> 00:52:34.080
Call super WillSave.

00:52:34.440 --> 00:52:37.950
This is our access.

00:52:38.940 --> 00:52:41.650
Go off and grab the
managed object ID for,

00:52:41.880 --> 00:52:44.800
I believe we're working on
the recipe side of things.

00:52:44.800 --> 00:52:49.400
So this is getting the recipe chef,
getting its managed object ID,

00:52:49.480 --> 00:52:53.070
getting its URI representation,
and we shove it into that.

00:52:53.300 --> 00:53:09.900
[Transcript missing]

00:53:10.400 --> 00:53:20.500
[Transcript missing]

00:53:22.210 --> 00:53:24.900
Grab the managed object context,
get the coordinator.

00:53:24.910 --> 00:53:26.660
This is a complicated thing, sort of.

00:53:26.760 --> 00:53:29.200
Or at least it takes some code.

00:53:30.310 --> 00:53:33.530
Get the managed object ID for
that URI representation,

00:53:33.530 --> 00:53:36.160
and then ask the context
to get that object.

00:53:36.380 --> 00:53:41.700
This really requires that both stores
be there in the before and after case.

00:53:42.040 --> 00:53:47.720
If the store at the destination of this
cross-store relationship has not been

00:53:47.720 --> 00:53:51.700
added to the coordinator at this point,
you're going to get a nil back.

00:53:52.400 --> 00:53:57.400
Set the managed object ID you got in the
previous step in the Chef relationship,

00:53:57.510 --> 00:54:00.290
and you now have a relationship
that bridges the stores.

00:54:00.300 --> 00:54:05.770
It's a little bit clunky,
but it's probably the best way to do it.

00:54:05.990 --> 00:54:10.900
Set the managed object ID you got in the
previous step in the Chef relationship,

00:54:10.900 --> 00:54:11.140
and you now have a relationship
that bridges the stores.

00:54:11.140 --> 00:54:11.140
It's a little bit clunky,
but it's probably the best way to do it.

00:54:16.270 --> 00:54:18.000
Great, so we're on the home stretch here.

00:54:18.000 --> 00:54:22.630
So just a quick note that
there is spotlight integration.

00:54:22.690 --> 00:54:25.240
As Matt mentioned in the intro session,
these are very

00:54:25.240 --> 00:54:29.750
complimentary technologies,
and the Core Recipes example provides a

00:54:29.750 --> 00:54:31.760
sampling of how you can do this yourself.

00:54:31.940 --> 00:54:34.990
The recommended way of doing this,
particularly for small

00:54:35.000 --> 00:54:37.150
amounts of metadata,
is to put that information

00:54:37.160 --> 00:54:38.340
in the store metadata.

00:54:38.340 --> 00:54:39.900
The coordinator has a method.

00:54:39.930 --> 00:54:43.680
You can set the metadata for the
store when you save the store,

00:54:43.700 --> 00:54:47.440
and then you can get it back using
metadata for persistent store with URL,

00:54:47.710 --> 00:54:51.580
and that will get it without
creating a Core Data stack.

00:54:51.580 --> 00:54:56.840
So that you can do on an instance of
the NSPersistentStoreCoordinator class,

00:54:56.860 --> 00:54:59.850
as opposed to creating
a whole stack yourself.

00:54:59.910 --> 00:55:03.360
Now, this does duplicate the information
that you put in the metadata,

00:55:03.420 --> 00:55:06.260
because the metadata for the stores
is saved separately from the actual

00:55:06.570 --> 00:55:08.410
persistent data for those objects.

00:55:08.480 --> 00:55:11.470
It is, however, the recommended approach.

00:55:11.480 --> 00:55:14.650
It's the fastest way of working
with Spotlight and keeping your

00:55:14.650 --> 00:55:17.060
Spotlight importer importer lien.

00:55:18.800 --> 00:55:22.870
So for really large amounts of metadata,
the Spotlight team doesn't

00:55:22.960 --> 00:55:26.020
really encourage this,
but you can create a persistent

00:55:26.030 --> 00:55:28.310
store stack within your importer.

00:55:28.350 --> 00:55:31.690
It's gonna be a bit slower,
but at the least, then you won't have to

00:55:31.700 --> 00:55:32.860
duplicate the metadata.

00:55:32.920 --> 00:55:36.360
So your mileage may vary and you
can experiment with that approach.

00:55:36.390 --> 00:55:39.430
The Core Recipes approach
takes the first approach.

00:55:40.050 --> 00:55:42.340
and it's on your WWDC CD.

00:55:42.680 --> 00:55:45.370
I'm not gonna talk any more about
that other than refer you to the

00:55:45.370 --> 00:55:49.300
example and you can post questions
on the COCODIP mailing list.

00:55:49.860 --> 00:55:53.080
Again, so memory management for
these advanced topics,

00:55:53.100 --> 00:55:57.240
I'm trying to help you understand
what the right questions to ask are.

00:55:57.240 --> 00:55:59.080
We don't really have time
to answer everything,

00:55:59.080 --> 00:55:59.680
I'm afraid.

00:55:59.680 --> 00:56:03.170
But one of the most important
things to note is the managed

00:56:03.170 --> 00:56:06.720
objects and their associated
context do not retain each other.

00:56:06.720 --> 00:56:09.170
There's basically a weak
reference between the two.

00:56:09.180 --> 00:56:11.600
So the managed objects,
when you're done using them,

00:56:11.600 --> 00:56:13.610
you release them, they can just go away.

00:56:13.620 --> 00:56:16.780
The context doesn't maintain a
separate retain count on them.

00:56:17.320 --> 00:56:19.710
And in this way,
the framework also provides

00:56:19.710 --> 00:56:22.870
managed objects to work as
sort of lightweight proxies.

00:56:22.880 --> 00:56:23.820
And we call them faults.

00:56:23.820 --> 00:56:26.670
And it's very analogous to
your virtual memory paging,

00:56:26.670 --> 00:56:27.930
your demand paging.

00:56:27.940 --> 00:56:31.980
If you fetch an object and it has a
relationship to a bunch of other objects,

00:56:31.980 --> 00:56:33.730
you don't have to fetch
those other objects.

00:56:33.750 --> 00:56:37.690
You can use key value coding and just
walk the relationship like you might

00:56:37.690 --> 00:56:39.690
normally with value for key path.

00:56:39.780 --> 00:56:42.690
And Core Data will handle figuring
out where all those objects

00:56:42.690 --> 00:56:44.330
are and bring them into memory.

00:56:44.340 --> 00:56:47.250
And when you're done using them,
you can get the faults to go away.

00:56:47.780 --> 00:56:52.410
Malcolm Crawford, who's over here,
has done an excellent job in

00:56:52.410 --> 00:56:53.730
the Core Data Programming Guide.

00:56:53.740 --> 00:56:56.920
And the section Using Managed
Objects talks very heavily about

00:56:56.920 --> 00:56:59.740
the nitty-gritty details about
memory management with Core Data.

00:56:59.740 --> 00:57:02.780
And that actually should answer
all of your questions in this.

00:57:02.780 --> 00:57:07.560
So some notes on handling
really large data sets.

00:57:07.560 --> 00:57:10.030
And by this,
I mean many tens of thousands,

00:57:10.110 --> 00:57:13.760
hundreds of thousands,
possibly even millions of records.

00:57:13.760 --> 00:57:17.000
Is basically to use the Escalite store.

00:57:17.000 --> 00:57:17.300
Okay.

00:57:17.320 --> 00:57:18.570
When you can for this.

00:57:18.580 --> 00:57:21.460
So I do know people who have
worked with tens of millions

00:57:21.460 --> 00:57:23.440
of rows with Escalite directly.

00:57:23.440 --> 00:57:26.420
And I myself,
the performance testing that we do

00:57:26.530 --> 00:57:30.840
is hundreds and hundreds of thousands
of records through Core Data.

00:57:30.840 --> 00:57:33.980
So it's really pretty well.

00:57:33.980 --> 00:57:37.760
The binary store is your second best
option if you need the NS document

00:57:37.900 --> 00:57:40.200
atomic reading and writing behavior.

00:57:40.200 --> 00:57:43.260
And that will probably get
you to a few thousand objects.

00:57:43.260 --> 00:57:47.030
And your keynote here is to
minimize the working set.

00:57:47.320 --> 00:57:49.990
So as you have more and more data,
you're going to want your fetch

00:57:49.990 --> 00:57:52.430
requests to have predicates
that are more and more specific.

00:57:53.820 --> 00:57:56.600
To only retain the things you need,
once you're done with them,

00:57:56.890 --> 00:58:00.080
release the managed objects and the
framework will clean up afterwards.

00:58:00.100 --> 00:58:04.160
And basically just let them
get turned into faults.

00:58:05.200 --> 00:58:09.770
So to talk briefly about threading,
Malcolm has thoughtfully volunteered

00:58:09.770 --> 00:58:13.550
or been volunteered to write
a programming guide on this.

00:58:13.560 --> 00:58:16.580
It's forthcoming,
but this should get you started

00:58:16.580 --> 00:58:17.520
with some of the basics.

00:58:17.580 --> 00:58:19.480
So the Core Data classes,
for the most part,

00:58:19.520 --> 00:58:22.780
except for the managed object ID,
are not thread-safe intrinsically.

00:58:22.780 --> 00:58:26.730
A lot of fine-grained locking that
you don't need would slow you down,

00:58:26.730 --> 00:58:27.900
so we don't do it.

00:58:28.010 --> 00:58:30.220
So NSManagedObject has
similar restrictions to,

00:58:30.270 --> 00:58:31.910
say, an NSMutable dictionary.

00:58:32.800 --> 00:58:36.430
The Core Data framework itself,
internally, makes sure that it does the

00:58:36.440 --> 00:58:39.170
right thing when it's working,
particularly between a context

00:58:39.170 --> 00:58:42.190
and that context coordinator,
so you don't have to worry about

00:58:42.190 --> 00:58:44.380
objects that you're not working with.

00:58:44.380 --> 00:58:46.980
The framework will do the right thing for
the things that it does behind your back,

00:58:46.980 --> 00:58:49.030
but for the objects that
you are working with,

00:58:49.100 --> 00:58:52.020
you're going to have to take care
to use them in a thread-safe way.

00:58:52.020 --> 00:58:55.310
And you really either need to
lock these objects or not share

00:58:55.400 --> 00:58:57.050
them at all if you use them.

00:58:57.080 --> 00:58:59.980
And by use them,
I mean you pass a message to them.

00:58:59.980 --> 00:59:01.430
You send a message to
one of these objects,

00:59:01.430 --> 00:59:02.730
or you access one of these objects.

00:59:02.800 --> 00:59:03.300
I'm Arsene.

00:59:05.070 --> 00:59:09.240
So some threading tips is
I strongly recommend that each

00:59:09.240 --> 00:59:11.990
thread has its own private context.

00:59:12.080 --> 00:59:15.440
If you're not sharing the context,
then you don't have to lock it.

00:59:15.650 --> 00:59:18.200
It makes things much,
much easier to deal with.

00:59:18.230 --> 00:59:21.200
And it also provides,
as I'll talk about in a little bit,

00:59:21.220 --> 00:59:25.000
a little more consistency in
the implications of what all

00:59:25.000 --> 00:59:28.060
those change sets are doing,
because each context is tracking

00:59:28.060 --> 00:59:29.500
a different set of changes.

00:59:29.560 --> 00:59:33.290
So you can only pass managed
object IDs between threads.

00:59:33.360 --> 00:59:35.220
And it's okay to pass
them as just pointers.

00:59:35.310 --> 00:59:38.300
You don't have to convert them
into URIs and pass them back,

00:59:38.380 --> 00:59:39.800
although you can if you want to.

00:59:39.840 --> 00:59:42.540
And I recommend that you do
not pass managed objects or the

00:59:42.600 --> 00:59:44.600
context between threads directly.

00:59:44.610 --> 00:59:46.820
That gets into a lot of very
fine-grained locking and can

00:59:46.820 --> 00:59:48.770
be very difficult to get right.

00:59:49.570 --> 00:59:52.940
So here's basically the approach
that I recommend you start out with.

00:59:52.950 --> 00:59:55.180
If you want to work with
multiple threads in Core Data,

00:59:55.240 --> 00:59:59.050
and each of those contexts is
working with a different thread,

00:59:59.090 --> 01:00:01.390
they share a persistent
store coordinator.

01:00:01.430 --> 01:00:04.300
So you share all the caching,
and this works for the

01:00:04.320 --> 01:00:07.180
XML and the binary stores,
as well as the SQLite store.

01:00:07.300 --> 01:00:11.320
And you can have as many persistent
backends as you would like.

01:00:12.720 --> 01:00:16.940
One alternative is you can instead
have an entire stack per thread.

01:00:16.990 --> 01:00:19.100
This will get you a
little more concurrency.

01:00:19.110 --> 01:00:23.100
As you see, there's no bottleneck at the
persistent store coordinator level.

01:00:23.130 --> 01:00:26.720
This only works with the SQLite store,
and there's no shared caching,

01:00:26.730 --> 01:00:29.940
so there's gonna be a little
impact on your memory.

01:00:30.820 --> 01:00:34.260
So the locking isn't
just about thread safety.

01:00:34.300 --> 01:00:37.500
The contexts are tracking
changes and essentially represent

01:00:37.500 --> 01:00:41.470
a scope of a transaction,
a view of a working set of changes.

01:00:41.530 --> 01:00:45.610
So by preventing interspersing,
like locking and unlocking

01:00:45.650 --> 01:00:47.350
of these contexts,
you also prevent

01:00:47.440 --> 01:00:48.480
interspersing of changes.

01:00:48.510 --> 01:00:52.390
You have different threads inserting
changes into the context and maybe

01:00:52.390 --> 01:00:55.140
undoing and other threads changes,
stuff like that.

01:00:55.160 --> 01:00:56.410
It gets very complicated.

01:00:56.470 --> 01:00:58.890
So that's why...

01:00:59.050 --> 01:01:02.320
I recommend that you just have
a private context per thread.

01:01:02.320 --> 01:01:05.520
It's important to note that the
way the framework is designed,

01:01:05.590 --> 01:01:09.280
that a thread must own the context
for a managed object in order

01:01:09.280 --> 01:01:10.680
to access the managed object.

01:01:10.750 --> 01:01:15.780
The managed objects themselves are
treated as too finely grained to

01:01:16.120 --> 01:01:17.620
lock and unlock separately yourself.

01:01:17.780 --> 01:01:20.340
You should lock the context that owns
them because the context is the one

01:01:20.340 --> 01:01:22.610
that's doing the change tracking.

01:01:24.320 --> 01:01:26.520
One last note, so again,
look for Malcolm's

01:01:26.710 --> 01:01:28.560
forthcoming programming guide.

01:01:28.590 --> 01:01:30.060
Malcolm, one second, be ready.

01:01:30.060 --> 01:01:34.080
Is that Cocoa Bindings
is not thread safe.

01:01:34.120 --> 01:01:35.960
And if you wanna work
with your controller,

01:01:35.990 --> 01:01:37.510
you must do that on the main thread.

01:01:37.550 --> 01:01:39.130
There's no way around that.

01:01:39.190 --> 01:01:41.060
There's nothing I can do about it.

01:01:41.080 --> 01:01:43.560
But if you wanna add or remove
an object from a controller,

01:01:43.580 --> 01:01:46.080
you're gonna have to use
perform selector on main thread.

01:01:46.110 --> 01:01:48.510
That's actually true for a lot
of different app kit issues.

01:01:48.580 --> 01:01:51.710
It's much easier to work
with it on the main thread.

01:01:52.500 --> 01:01:53.960
and some notifications.

01:01:54.000 --> 01:01:57.040
This is a summary of the
notifications we presented to you.

01:01:57.070 --> 01:02:00.070
And this is the best place for you
to do your own customization of

01:02:00.070 --> 01:02:03.260
the framework behavior outside of
subclassing and managed objects.

01:02:03.290 --> 01:02:07.370
So if you want to change the way a
context or coordinator is doing things.

01:02:07.510 --> 01:02:10.420
So the manage object context
has two notifications.

01:02:10.420 --> 01:02:14.600
It has an objects did change notification
that gets sent when it coalesces

01:02:14.600 --> 01:02:16.290
the changes at the end of the event.

01:02:16.340 --> 01:02:20.420
So every time a set of an event
ends that has had changes,

01:02:20.420 --> 01:02:21.940
you'll get this notification.

01:02:21.970 --> 01:02:24.640
There are a bunch of keys in it, insert,
update, and delete the keys.

01:02:24.660 --> 01:02:28.640
These are sets of the manage objects
that have changed during that past event.

01:02:28.650 --> 01:02:31.550
And the controller actually listens
to this notification itself to

01:02:31.560 --> 01:02:34.190
figure out its own behavior.

01:02:34.290 --> 01:02:36.120
And then there's the
did save notification,

01:02:36.160 --> 01:02:39.010
which is presented to you a number
of times for using the in-memory

01:02:39.050 --> 01:02:42.950
store to track when someone's
actually saved a set of changes.

01:02:43.390 --> 01:02:46.100
The persistent store coordinator
also posts a notification,

01:02:46.100 --> 01:02:48.270
and that stores did change,
and this is whenever a

01:02:48.270 --> 01:02:52.770
store gets added or removed,
or the UUID, the real unique reference

01:02:52.770 --> 01:02:54.400
to that store has changed.

01:02:54.470 --> 01:02:58.080
It provides an array of the
stores that actually changed.

01:02:59.430 --> 01:03:02.200
The persistent store coordinator
also posts a notification,

01:03:02.200 --> 01:03:04.370
and that stores did change,
and this is whenever a

01:03:04.370 --> 01:03:08.870
store gets added or removed,
or the UUID, the real unique reference

01:03:08.870 --> 01:03:10.510
to that store has changed.

01:03:10.520 --> 01:03:14.180
It provides an array of the
stores that actually changed.

01:03:29.400 --> 01:03:32.480
And primitive key value coding
does not trigger key value

01:03:32.480 --> 01:03:34.340
observing notifications.

01:03:35.710 --> 01:03:39.460
section on some common errors that
have come up and some things is

01:03:39.620 --> 01:03:45.820
basically changing the model and
trying to read the data again.

01:03:45.820 --> 01:03:48.590
I know we've had a lot of
questions about schema versioning.

01:03:48.650 --> 01:03:51.230
Currently version one of the
framework doesn't support this.

01:03:51.260 --> 01:03:52.860
So you can't do it.

01:03:52.860 --> 01:03:54.890
You'll have to bring up a
stack as Melissa described,

01:03:55.170 --> 01:03:56.550
reading the old data and say that again.

01:03:56.550 --> 01:03:59.350
If you're doing your
own custom accessors,

01:03:59.400 --> 01:04:04.640
forgetting to send the KVO notifications
will cause lots of things to go awry.

01:04:04.640 --> 01:04:05.680
The controllers won't know
that you're doing that.

01:04:05.700 --> 01:04:06.720
They won't know that
you've changed things.

01:04:06.720 --> 01:04:11.720
Neither will the context be able to track
those changes and update those inverses.

01:04:11.750 --> 01:04:14.480
So if you start misusing the
primitive key value coding,

01:04:14.480 --> 01:04:16.290
you'll see things get out of sync.

01:04:16.350 --> 01:04:19.770
And then another sort of general
kind of paradigm issue is not

01:04:19.770 --> 01:04:22.030
really letting the framework drive.

01:04:22.050 --> 01:04:24.530
Like I mentioned,
the lifecycle of managed object is

01:04:24.610 --> 01:04:26.470
largely controlled by the framework.

01:04:26.610 --> 01:04:28.680
It'll fetch them and
save them and whatnot.

01:04:28.680 --> 01:04:32.480
So it's best to work within the callbacks
we provide you or the notifications and

01:04:32.480 --> 01:04:34.680
let the framework do the heavy lifting.

01:04:36.590 --> 01:04:39.660
So one of these is that it
could not merge changes.

01:04:39.710 --> 01:04:41.820
And this is if you come
across a situation,

01:04:41.840 --> 01:04:44.450
maybe you have two contexts
with different sets of changes

01:04:44.460 --> 01:04:46.780
in an inspector window,
you try to save,

01:04:46.810 --> 01:04:48.240
and you haven't set a merge policy.

01:04:48.290 --> 01:04:50.060
You'll get this.

01:04:51.900 --> 01:04:54.360
And then here,
Core Data could not fulfill a fault.

01:04:54.410 --> 01:04:57.560
So here you've given Core Data an
object ID and you've asked

01:04:57.850 --> 01:05:01.760
for an object back with it,
and that object doesn't exist.

01:05:01.760 --> 01:05:03.800
It's been deleted out
from underneath you.

01:05:03.870 --> 01:05:06.870
We had a proxy for that row,
but the row's gone.

01:05:06.930 --> 01:05:09.950
So you'll get this message,
and you're gonna have to discard the

01:05:09.950 --> 01:05:12.140
object because it's been deleted,
basically.

01:05:12.140 --> 01:05:16.450
And then here, this class is not key
value coding compliant.

01:05:16.580 --> 01:05:20.440
This will happen if you have
your standard typo in a key,

01:05:20.480 --> 01:05:23.810
or if you initialize the
object accidentally with -init

01:05:23.990 --> 01:05:27.220
instead of init with entity in
certain managed object context.

01:05:27.370 --> 01:05:29.770
Like I said,
you have to initialize it with our

01:05:29.770 --> 01:05:33.120
designated initializer so we know what
entity that object just belongs to,

01:05:33.130 --> 01:05:37.010
and we can find all of its properties.

01:05:37.880 --> 01:05:40.590
So here you can't assign an
object to a store that does not

01:05:40.590 --> 01:05:42.080
contain the object's entity.

01:05:42.120 --> 01:05:45.080
You can only assign them to stores
that have been configured with

01:05:45.080 --> 01:05:48.990
the coordinator when you added
the store that has that entity.

01:05:50.390 --> 01:05:53.330
and then here you can't
reassign an object to a store.

01:05:53.630 --> 01:05:56.660
Once it's been saved,
you'll have to basically insert

01:05:56.660 --> 01:05:59.790
it again into a new store and
then delete it from the old store.

01:05:59.830 --> 01:06:02.200
So you basically have to do a copy.

01:06:03.330 --> 01:06:06.600
and then here you can't
reassign an object to a store.

01:06:06.600 --> 01:06:09.570
Once it's been saved,
you'll have to basically insert

01:06:09.650 --> 01:06:12.800
it again into a new store and
then delete it from the old store.

01:06:12.800 --> 01:06:15.200
So you basically have to do a copy.

01:06:34.910 --> 01:06:38.160
and then here you can't
reassign an object to a store.

01:06:38.330 --> 01:06:41.230
Once it's been saved,
you'll have to basically insert

01:06:41.260 --> 01:06:44.390
it again into a new store and
then delete it from the old store.

01:06:44.400 --> 01:06:46.730
So you basically have to do a copy.

01:06:58.220 --> 01:07:02.260
So for more information, WWDC,
so the Core Recipes example.

01:07:04.660 --> 01:07:09.230
and at your fingertips here,
the Core Data Programming Guide.

01:07:09.280 --> 01:07:12.900
A lot of these sessions,
if you read the guide,

01:07:12.900 --> 01:07:15.040
will make a lot more sense.

01:07:15.090 --> 01:07:21.300
Malcolm's done a great job in explaining
all the nitty-gritty details of various

01:07:21.310 --> 01:07:24.070
different issues with Core Data.

01:07:24.070 --> 01:07:24.180
And there are a bunch of
other different guides.

01:07:24.180 --> 01:07:24.180
There are a bunch of examples installed
with the developer tools on your system.

01:07:24.500 --> 01:07:27.360
and again,
Core Recipes installed on the developer

01:07:27.360 --> 01:07:29.580
CD you have for the conference.

01:07:29.900 --> 01:07:57.900
[Transcript missing]
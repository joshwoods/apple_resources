WEBVTT

00:00:00.980 --> 00:00:02.730
I'm Bill Bumgarner.

00:00:02.930 --> 00:00:08.930
I manage core data for Tiger,
and I'm doing some Xcode stuff now,

00:00:08.930 --> 00:00:12.170
and I've always had a love
with WebObjects and have

00:00:12.170 --> 00:00:14.080
been using it forever.

00:00:15.320 --> 00:00:17.860
And of course, as you know,
WebObjects is the world's best

00:00:17.980 --> 00:00:20.040
rapid application development
tool for app servers.

00:00:20.040 --> 00:00:23.500
And with that is the paradigm
of just-in-time engineering.

00:00:23.500 --> 00:00:25.710
So in the interest of that,
we're making sure that two of

00:00:25.770 --> 00:00:27.180
the other presenters are late.

00:00:27.220 --> 00:00:28.630
Ravi's here.

00:00:28.630 --> 00:00:30.880
Max will be here soon.

00:00:30.880 --> 00:00:32.010
So let's get going.

00:00:32.010 --> 00:00:33.460
We'll fill in the blanks.

00:00:33.520 --> 00:00:34.700
I'm Bill Bumgarner.

00:00:34.700 --> 00:00:37.240
I will be joined by
Max Muller and Ravi Mendis.

00:00:37.280 --> 00:00:39.520
Ravi wrote a wonderful WebObjects book.

00:00:39.570 --> 00:00:43.140
And both Ravi and Max work
on the Music Store.

00:00:45.010 --> 00:00:47.940
Let's, as we dive into this,
we really wanted to do something

00:00:47.940 --> 00:00:49.140
completely new this year.

00:00:49.140 --> 00:00:51.700
And the first thing we wanted
to do was take a step back and

00:00:51.780 --> 00:00:53.300
really look at the landscape.

00:00:53.300 --> 00:00:56.500
What's your target market for
deploying WebObjects applications

00:00:56.560 --> 00:00:58.090
and application servers in general?

00:00:58.100 --> 00:01:02.870
And in the 10, 12, 13,
some odd years that we've

00:01:02.870 --> 00:01:06.480
been doing this stuff now,
there's been a few things that

00:01:06.480 --> 00:01:08.300
really have changed quite a bit.

00:01:08.410 --> 00:01:10.840
And there's some surprising
things that have stayed the same.

00:01:10.840 --> 00:01:14.160
In particular,
we have oodles of bandwidth now.

00:01:14.550 --> 00:01:16.420
And sadly enough,
the United States has less

00:01:16.420 --> 00:01:18.740
bandwidth than most of the rest
of the countries in the world.

00:01:18.800 --> 00:01:21.870
But, you know,
that changes the picture a bit.

00:01:22.000 --> 00:01:25.470
We need to also look at the current
state of the art of HTML-based user

00:01:25.470 --> 00:01:30.490
interfaces and the growing market of
alternative interface technologies.

00:01:30.620 --> 00:01:34.090
And finally,
we really need to look at how has this

00:01:34.270 --> 00:01:38.410
changed optimization of WebObjects
applications and more importantly,

00:01:38.420 --> 00:01:39.780
WebObjects solutions.

00:01:40.050 --> 00:01:43.060
Because rarely is it just about
one or two applications now.

00:01:44.170 --> 00:01:45.810
So, bandwidth.

00:01:45.920 --> 00:01:50.620
Yes, there's just tons of bandwidth out
there and it's cheap as dirt these days.

00:01:51.310 --> 00:01:54.220
Broadband is widely deployed.

00:01:54.220 --> 00:01:56.640
I mean,
you even have broadband to phones now.

00:01:56.720 --> 00:02:01.290
And it's more and more commonly a
requirement in sites because there's

00:02:01.290 --> 00:02:03.490
such an emphasis on multimedia content.

00:02:03.580 --> 00:02:07.580
We're seeing more and more often there's
like flash stuff being shoved in there

00:02:07.580 --> 00:02:10.690
and movies and sounds and you name it.

00:02:10.840 --> 00:02:15.460
So, you know, the little bit of HTML,
your applications are generating anymore.

00:02:15.460 --> 00:02:17.460
As long as you're
generating it very quickly,

00:02:17.550 --> 00:02:21.380
the actual bytes on the wire
just don't matter that much.

00:02:21.460 --> 00:02:25.460
Also, server environments have a lot more
bandwidth than they ever have before.

00:02:25.460 --> 00:02:30.460
Your backplanes and your server farms are
going to typically be gigabit Ethernet.

00:02:30.460 --> 00:02:34.920
They also have a much faster connection
to the net at large or at least

00:02:34.920 --> 00:02:38.460
you can obtain faster connections
for a lot cheaper than ever before.

00:02:38.700 --> 00:02:43.000
And just basically the whole server
infrastructure has a lot more bandwidth

00:02:43.020 --> 00:02:46.330
more bandwidth and power available to it.

00:02:47.350 --> 00:02:50.540
So where's the clicker thingy?

00:02:50.540 --> 00:02:52.300
There it is.

00:02:52.340 --> 00:02:54.140
And now let's look at the user interface,
though.

00:02:54.140 --> 00:02:56.720
Now what's interesting about
the HTML user interface is

00:02:56.720 --> 00:02:59.880
that it really hasn't changed
at all in the last few years.

00:02:59.930 --> 00:03:02.260
It's still kind of primitive.

00:03:03.480 --> 00:03:05.880
We have CSS now,
which has allowed us to shuffle

00:03:05.920 --> 00:03:08.820
some of the bits around for
defining the user interfaces.

00:03:08.830 --> 00:03:12.850
You can push more of the sort
of interface architecture,

00:03:12.850 --> 00:03:15.790
the construction of the
UI into these CSS files,

00:03:15.790 --> 00:03:19.340
and then apply them across the site
so that your customers even can have

00:03:19.350 --> 00:03:21.400
more control over the look and feel.

00:03:21.400 --> 00:03:26.290
But by and large, it's still, you know,
TDs and TRs and forms and

00:03:26.290 --> 00:03:30.820
inputs and the same stuff we've
been doing for a long time.

00:03:30.860 --> 00:03:33.390
But what has changed?

00:03:33.490 --> 00:03:37.140
What has changed is that the
baseline feature set of the sites

00:03:37.140 --> 00:03:39.120
have become much more intense.

00:03:39.230 --> 00:03:40.620
They're much more dynamic.

00:03:40.620 --> 00:03:43.160
In particular,
there's more inferential content.

00:03:43.160 --> 00:03:45.460
More often now,
you have to generate content

00:03:45.640 --> 00:03:48.900
based on where the user's been
or what they may have done in the

00:03:48.900 --> 00:03:50.990
last year or purchase histories.

00:03:51.000 --> 00:03:54.880
You may have to be generating content
based on partnership agreements and

00:03:54.880 --> 00:03:58.970
marketing agreements and buying records
of all the customers on the site.

00:03:58.980 --> 00:04:01.700
And these are really the features
you start to need to have to

00:04:01.700 --> 00:04:03.220
implement into your systems.

00:04:03.480 --> 00:04:07.210
And not just commercial marketing
systems or point of sale systems,

00:04:07.280 --> 00:04:10.310
but also in back-end
systems to stay competitive.

00:04:10.480 --> 00:04:14.430
As we've seen with Spotlight on Mac OS X,
what does Spotlight do?

00:04:14.440 --> 00:04:17.890
Well, it allows the user to stop thinking
about the individual items in

00:04:17.890 --> 00:04:22.430
their environment and to start
thinking about just finding stuff,

00:04:22.660 --> 00:04:25.390
just letting the system suggest
where things are and point

00:04:25.400 --> 00:04:26.800
out the right directions.

00:04:26.840 --> 00:04:31.530
You're also required to provide
more customization to your users.

00:04:31.640 --> 00:04:32.020
Given that you may have a lot of
stuff that you want to customize,

00:04:32.020 --> 00:04:32.640
you may want to make sure that you have a
lot of things that you want to customize.

00:04:32.640 --> 00:04:32.640
You may want to make sure that you have a
lot of things that you want to customize.

00:04:32.640 --> 00:04:32.840
You may want to make sure that you have a
lot of things that you want to customize.

00:04:32.840 --> 00:04:36.160
we may have hundreds of thousands
of items that the user is

00:04:36.160 --> 00:04:40.380
managing at any one time,
as opposed to dozens or hundreds.

00:04:40.400 --> 00:04:45.250
Now, the user needs to have a lot more
control over the presentation,

00:04:45.680 --> 00:04:49.730
And what all this means is
that you now have a requirement

00:04:49.820 --> 00:04:54.100
to use less static content.

00:04:54.100 --> 00:04:58.560
And there's also obviously the increased
integration with external resources.

00:04:58.680 --> 00:05:02.330
Various different kinds of Web services
like Google's AdSense and the search

00:05:02.330 --> 00:05:07.170
features and some of the product matching
features and forms and things like that,

00:05:07.270 --> 00:05:09.370
they have really matured a lot.

00:05:09.670 --> 00:05:14.010
Some of them are very impressive and
integrating with those is becoming more

00:05:14.010 --> 00:05:17.400
and more critical to remain competitive.

00:05:18.100 --> 00:05:21.130
Now, also at the same time,
while HTML hasn't advanced,

00:05:21.130 --> 00:05:24.310
alternative interface
technologies have become huge.

00:05:24.320 --> 00:05:27.580
It's just not just about HTML.

00:05:27.580 --> 00:05:30.960
Flash, dynamic Flash production
is becoming more common.

00:05:30.960 --> 00:05:33.410
Java applets, all kinds of things.

00:05:33.430 --> 00:05:37.130
And one of the areas that's really,
really important or has grown hugely in

00:05:37.130 --> 00:05:39.860
the last few years has been Web services.

00:05:40.940 --> 00:05:44.140
And really,
this is one of those just overused

00:05:44.590 --> 00:05:48.960
garbage words that you can throw out
and just think of it as an XML API.

00:05:48.960 --> 00:05:50.620
It's a bunch of methods.

00:05:50.620 --> 00:05:53.290
You call them with an XML call,
and it gives a bunch of XML back.

00:05:53.340 --> 00:05:59.120
Now, XMLs, on the XML side,
one of the most popular ones is RSS,

00:05:59.120 --> 00:06:02.160
which you see a lot of new services
being pushed out about that.

00:06:02.180 --> 00:06:05.360
That's really just an
alternative user interface.

00:06:05.360 --> 00:06:08.750
And then, of course,
the most popular alternative

00:06:08.750 --> 00:06:10.840
user interface in the world.

00:06:10.850 --> 00:06:14.660
is the iTunes Music Store,
which is really just an XML interface

00:06:15.170 --> 00:06:20.850
on a WebObjects application with a very
nice rendering engine on the other side.

00:06:20.860 --> 00:06:25.090
Likewise, on Tiger itself,
many of the dashboard widgets

00:06:25.090 --> 00:06:30.260
are actually using calls back to
Web servers to spew out information.

00:06:30.260 --> 00:06:34.230
So you have these beautiful
photorealistic renderings of

00:06:34.230 --> 00:06:36.590
otherwise simple XML content.

00:06:37.070 --> 00:06:39.850
Now, on the HTML front,
while HTML hasn't changed,

00:06:39.860 --> 00:06:42.200
it's being used in very
new and different places.

00:06:42.200 --> 00:06:46.240
You see, like, for example, in Xcode,
the documentation window

00:06:46.240 --> 00:06:49.870
is an HTML viewer,
and it has integration with the servers

00:06:49.870 --> 00:06:53.020
at Apple Developer Connection as well
as static content on your machine.

00:06:53.020 --> 00:06:56.240
Plus, the user can command-double-click
a piece of code,

00:06:56.240 --> 00:06:58.640
or, I'm sorry,
option-double-click a piece of code,

00:06:58.640 --> 00:07:00.240
and go straight into the documentation.

00:07:00.240 --> 00:07:02.530
So now you have source
code integrated with HTML.

00:07:03.620 --> 00:07:06.340
You also have the WebKit,
and on Windows you have other

00:07:06.340 --> 00:07:09.720
widgets that allow you to embed
HTML in any random application.

00:07:09.720 --> 00:07:13.430
So now you suddenly have the need
to have very small fragments of

00:07:13.440 --> 00:07:17.290
HTML that are sitting in the middle of
otherwise normal desktop applications.

00:07:17.300 --> 00:07:21.800
This changes the way your back-end
applications need to deal with the data.

00:07:23.350 --> 00:07:25.690
And of course,
app servers are generally now have

00:07:25.700 --> 00:07:29.200
to talk with other app servers
to keep track of what's going on.

00:07:29.200 --> 00:07:32.630
Sometimes it's not sufficient just
to do all the communications through

00:07:32.630 --> 00:07:37.020
a database or through notifications
and then faulting in new data.

00:07:37.340 --> 00:07:41.030
So the end result really here is
your application is going to be

00:07:41.040 --> 00:07:44.960
generating content that's destined
for use in all kinds of contexts

00:07:45.200 --> 00:07:47.800
outside of a big browser window.

00:07:47.910 --> 00:07:51.020
And that really changes
the optimization picture.

00:07:51.600 --> 00:07:56.430
In particular,
now WebObjects applications

00:07:56.510 --> 00:07:59.050
more than ever before,
application servers

00:07:59.050 --> 00:08:02.500
more than ever before,
are all about the database.

00:08:02.700 --> 00:08:07.440
And it's about active monitoring of
the environment and load balancing

00:08:07.730 --> 00:08:13.000
adaptively in response to the changing
usage patterns of the application server

00:08:13.000 --> 00:08:16.000
environment and of your customer base.

00:08:16.210 --> 00:08:21.000
The increased use of inferential content

00:08:21.270 --> 00:08:23.800
Sorry, I can't even read that.

00:08:23.820 --> 00:08:27.780
The increased use of inferential
content means that you've got a

00:08:27.780 --> 00:08:30.290
lot of content that's going to be
dynamic where it was static before.

00:08:30.320 --> 00:08:34.180
Now, what's interesting about that is
even though it's inferential data

00:08:34.180 --> 00:08:37.990
and it's user interface that needs
to be generated in response to users,

00:08:37.990 --> 00:08:40.360
that doesn't mean it has to be real time.

00:08:40.420 --> 00:08:43.350
So if you look at things like
Akamai and some of the caching

00:08:43.350 --> 00:08:46.370
technologies that are out there,
and that's when we start

00:08:46.370 --> 00:08:51.310
talking about really huge sites,
the ability to pre-render and

00:08:51.310 --> 00:08:55.730
predict where users are going to go,
adapt to the popular pieces of your

00:08:55.730 --> 00:08:59.360
site and render that stuff statically so
that when a user comes in and asks for

00:08:59.370 --> 00:09:03.870
something that is dynamically generated
based on sales data or whatever,

00:09:03.880 --> 00:09:05.880
it's actually coming from a static cache.

00:09:05.940 --> 00:09:08.780
That's where you can really
achieve a lot of performance.

00:09:08.780 --> 00:09:12.590
You can vastly reduce the
loads on your servers.

00:09:13.100 --> 00:11:19.400
[Transcript missing]

00:11:22.700 --> 00:11:24.120
Thank you very much, Bill,
for that introduction.

00:11:24.120 --> 00:11:25.920
Good afternoon, everybody.

00:11:25.920 --> 00:11:28.930
For those of you who didn't catch it,
my name is Ravi Mendis,

00:11:28.950 --> 00:11:32.450
and I work with Max on
the iTunes Music Store.

00:11:32.670 --> 00:11:35.240
Now,
for the first half of this presentation,

00:11:35.240 --> 00:11:38.140
we thought we'd focus
on design optimization.

00:11:38.520 --> 00:11:43.920
As Bill mentioned just now, typically,
you optimize an application

00:11:43.920 --> 00:11:45.790
once it has been built.

00:11:45.920 --> 00:11:51.700
That is, you identify those bits of your
application that is used the most,

00:11:51.700 --> 00:11:54.080
and you optimize those bits.

00:11:54.140 --> 00:11:57.970
It's the 90-10 principle that I'm sure
most of you are fairly familiar with.

00:11:58.710 --> 00:12:01.460
However,
that does not mean we can't build

00:12:01.530 --> 00:12:07.370
and design our application with
performance and scalability in mind.

00:12:07.400 --> 00:12:10.060
And to that end,
we have three design goals

00:12:10.060 --> 00:12:12.320
we'd like to focus on.

00:12:12.420 --> 00:12:15.470
will be speaking today,
and the first of which is inspired

00:12:15.580 --> 00:12:22.190
by a personal hero of mine,
the legendary Bruce Lee.

00:12:24.720 --> 00:12:27.280
True refinement seeks simplicity.

00:12:27.280 --> 00:12:32.990
Now his philosophy or mantra can
be applied or translates very well

00:12:32.990 --> 00:12:39.000
into software engineering in that
sometimes to improve something

00:12:39.000 --> 00:12:40.280
we need to make it simpler.

00:12:40.280 --> 00:12:44.440
And for those of us who can't
afford the luxury of re-engineering,

00:12:44.440 --> 00:12:47.040
it helps to keep it simple to begin with.

00:12:50.450 --> 00:12:52.770
Design goal number one, keep it simple.

00:12:52.770 --> 00:12:57.010
Reengineering is expensive,
and this is particularly true

00:12:57.280 --> 00:12:58.610
of your database and model.

00:12:58.620 --> 00:13:04.220
It becomes incredibly expensive,
if not prohibitively difficult,

00:13:04.220 --> 00:13:08.070
to reengineer your data and
model once you have thousands

00:13:08.070 --> 00:13:11.340
upon thousands of users,
and your database is gigabytes

00:13:11.340 --> 00:13:12.890
upon gigabytes in size.

00:13:14.370 --> 00:13:18.440
So,
you need to get it right from the start,

00:13:18.670 --> 00:13:21.120
and we do that by
keeping the model simple.

00:13:21.120 --> 00:13:24.840
Now, we're smart guys,
and we like to come up with, you know,

00:13:24.970 --> 00:13:29.400
interesting solutions to problems,
so it takes a huge amount of

00:13:29.680 --> 00:13:35.190
discipline and restraint to
not over-engineer anything.

00:13:35.720 --> 00:13:41.780
As a rule of thumb,
it helps to not over-abstract your model.

00:13:41.960 --> 00:13:47.230
Arguably, a concrete model is
superior to an abstract one.

00:13:47.380 --> 00:13:51.770
And in general,
a deeper understanding of your business

00:13:51.770 --> 00:13:58.190
or your problem domain will result in
a more concretely architected model.

00:13:58.660 --> 00:14:02.800
And finally, minimize use of inheritance.

00:14:02.810 --> 00:14:06.600
EOF inheritance adds a significant
amount of complexity to your project.

00:14:06.600 --> 00:14:10.820
And in particular,
in applications that scale up,

00:14:10.820 --> 00:14:16.220
like the iTunes Music Store,
you must bear in mind the performance

00:14:16.320 --> 00:14:20.600
penalty that you might incur if
you do implement inheritance.

00:14:20.600 --> 00:14:25.390
And while we're on that topic,
let's compare the three

00:14:26.210 --> 00:14:29.600
inheritance methodologies.

00:14:29.600 --> 00:14:37.750
What we're going to look at here is if
you were to perform a fetch of entities,

00:14:37.750 --> 00:14:40.400
of EOs rather,
from an entity in a parent or root

00:14:41.000 --> 00:14:44.600
entity in an inheritance tree.

00:14:44.620 --> 00:14:50.600
So for single table inheritance,
this would simply require one fetch.

00:14:50.630 --> 00:14:54.770
But in an inheritance tree modeled
using horizontal table inheritance,

00:14:54.770 --> 00:14:59.810
say an inheritance tree consisting
of n concrete subclasses,

00:14:59.810 --> 00:15:05.600
a fetch into the parent or root
entity will result in n fetches.

00:15:05.600 --> 00:15:10.590
The equivalent fetch in using vertical
table inheritance will be n fetches.

00:15:10.620 --> 00:15:14.210
In fact,
n joins over m tables if you have where

00:15:14.210 --> 00:15:17.590
your inheritance tree is m levels deep.

00:15:17.620 --> 00:15:19.600
So very clearly,
vertical inheritance tree is a fetch.

00:15:19.600 --> 00:15:19.910
But in an inheritance tree modeled
using horizontal table inheritance,

00:15:19.910 --> 00:15:20.160
say an inheritance tree consisting
of n concrete subclasses,

00:15:20.160 --> 00:15:20.590
a fetch into the parent or root
entity will result in n fetches.

00:15:20.640 --> 00:15:21.860
So the difference between a single
table inheritance and a horizontal table

00:15:21.890 --> 00:15:22.600
inheritance is at a disadvantage here.

00:15:22.600 --> 00:15:25.680
And perhaps that may be why
it has gone out of fashion and

00:15:25.690 --> 00:15:27.600
out of favor in recent years.

00:15:27.600 --> 00:15:30.780
So typically,
you'd be deciding to -- you'd be

00:15:30.780 --> 00:15:36.600
choosing between single table inheritance
and horizontal table inheritance.

00:15:36.600 --> 00:15:39.750
Now, you might also say that, well,
you know,

00:15:39.780 --> 00:15:44.430
I rarely need to fetch the entities --
the EOs in a root or parent entity in a

00:15:44.430 --> 00:15:47.600
horizontal table inheritance hierarchy.

00:15:47.600 --> 00:15:49.600
And that just might be the case.

00:15:49.600 --> 00:15:51.560
It all depends on your requirements.

00:15:51.830 --> 00:15:54.590
However, if you do choose horizontal
table inheritance,

00:15:54.590 --> 00:16:01.600
do be aware or be careful of what are
referred to as ambiguous relationships.

00:16:01.600 --> 00:16:05.290
That is,
relationships that point to a parent

00:16:05.290 --> 00:16:08.520
or root entity in an inheritance tree.

00:16:08.700 --> 00:16:11.630
For example,
if we have a horizontal table

00:16:11.630 --> 00:16:16.600
inheritance hierarchy consisting
of 20 concrete subclasses,

00:16:16.600 --> 00:16:21.600
if you were to have a relationship
into that -- the parent or root entity,

00:16:21.600 --> 00:16:25.600
in order to resolve that
relationship at runtime,

00:16:25.600 --> 00:16:28.600
EOF will fire 20 fetches to the database.

00:16:28.770 --> 00:16:32.490
And in a big application,
that can be a significant penalty.

00:16:32.600 --> 00:16:35.590
So when in doubt,
use single table inheritance.

00:16:37.460 --> 00:16:40.010
Let's discuss a couple more
features about inheritance,

00:16:40.060 --> 00:16:41.780
a couple more pointers and caveats.

00:16:41.860 --> 00:16:45.870
So the first one is try and use
flat inheritance hierarchies.

00:16:46.000 --> 00:16:47.750
Avoid deep trees.

00:16:47.870 --> 00:16:50.970
Ideally, keep them simple,
keep them one level deep.

00:16:51.080 --> 00:16:53.200
Use abstract superclasses.

00:16:53.210 --> 00:16:57.160
Don't use concrete superclasses
if you can't help it.

00:16:57.200 --> 00:17:00.740
And actually, the second point is very,
very important.

00:17:00.740 --> 00:17:05.150
Do not combine or mix and
match the methodologies.

00:17:05.500 --> 00:17:10.340
One must remember that EOF is
an object relational tool.

00:17:11.810 --> 00:17:15.980
And these three methodologies
are approximations to

00:17:15.980 --> 00:17:18.040
OO in a relational model.

00:17:18.040 --> 00:17:21.100
And although technically
possible to mix and match,

00:17:21.240 --> 00:17:24.950
that is have a hybrid
hierarchy consisting of part

00:17:24.990 --> 00:17:27.200
horizontal table inheritance.

00:17:27.260 --> 00:17:30.050
And finally,
be economical with inheritance.

00:17:30.180 --> 00:17:32.590
And by this I don't mean
avoid inheritance altogether.

00:17:32.590 --> 00:17:37.040
By all means, use inheritance if it
helps to enrich your model.

00:17:37.170 --> 00:17:40.880
However, just don't go overboard.

00:17:41.050 --> 00:17:43.200
And case in point,
as Bill mentioned earlier,

00:17:43.280 --> 00:17:47.970
the iTunes Music Store is by
far most definitely the flagship

00:17:47.980 --> 00:17:49.700
WebObjects application at the minute.

00:17:49.700 --> 00:17:53.640
The largest, certainly most visible,
and talked about.

00:17:53.660 --> 00:17:59.870
Now, we have over 400 entities
defined in a dozen or so models.

00:18:01.270 --> 00:18:06.570
However, Max and his team of the original
iTunes Music Store architects

00:18:06.650 --> 00:18:10.590
made the incredibly bold,
if not quite radical, decision to keep

00:18:10.910 --> 00:18:12.250
inheritance to a minimum.

00:18:12.260 --> 00:18:15.720
We have just one inheritance
tree that is one level deep.

00:18:15.780 --> 00:18:18.870
And this decision has
actually paid off hugely,

00:18:18.900 --> 00:18:22.390
if not enormously,
now that the music store is scaling

00:18:22.390 --> 00:18:24.760
to the dizzying heights that it is.

00:18:26.220 --> 00:18:29.450
And with that,
I think we have design goal number two.

00:18:29.780 --> 00:18:32.350
Exploit the database.

00:18:32.460 --> 00:18:37.740
Now, these database servers have
been around for a long time,

00:18:37.740 --> 00:18:39.080
two, three decades.

00:18:39.100 --> 00:18:41.620
They're based on solid
mathematical foundation,

00:18:41.620 --> 00:18:44.510
and they're incredibly good
and incredibly efficient

00:18:44.520 --> 00:18:45.600
in doing what they do.

00:18:45.600 --> 00:18:49.680
If you want to build a fast application,
as Bill mentioned earlier,

00:18:49.680 --> 00:18:55.220
you want to really leverage the power of
your database to drive your application.

00:18:56.430 --> 00:19:00.910
There are three features of
EOF that I'd like to look at today.

00:19:00.920 --> 00:19:04.180
Um... And...

00:19:05.750 --> 00:19:12.590
I should say that EOF,
although we love it for insulating

00:19:12.610 --> 00:19:17.650
us from the intricacies of SQL,
at the same time it also obscures

00:19:17.770 --> 00:19:21.390
us from the richness and the
power that the language provides.

00:19:21.440 --> 00:19:25.210
And subqueries, for one,

00:19:25.900 --> 00:19:30.140
Raw rows and prefetching can
be used to more fully exploit

00:19:30.140 --> 00:19:32.140
SQL in our application.

00:19:32.140 --> 00:19:36.500
So subqueries can be used
to implement aggregation.

00:19:36.500 --> 00:19:38.130
They're excellent for that.

00:19:38.270 --> 00:19:42.110
Raw rows are ideal for fast
search results and prefetching,

00:19:42.110 --> 00:19:45.240
which can be used on
edit and inspect pages.

00:19:45.310 --> 00:19:49.470
Let's take a look at
subqueries in more detail.

00:19:50.090 --> 00:19:53.660
Given that there's not a
lot of documentation on

00:19:53.660 --> 00:20:02.530
subqueries at the minute,
this slide is a quick how-to construct

00:20:02.590 --> 00:20:04.010
an aggregate attribute as a subquery.

00:20:04.730 --> 00:20:09.710
For those of you familiar with the
movies model that ships with WebObjects,

00:20:09.790 --> 00:20:15.050
let's consider for a minute the
requirement to add the number

00:20:15.060 --> 00:20:16.900
of movies to a studio list page.

00:20:16.900 --> 00:20:20.530
Now typically this would
involve performing a count

00:20:20.620 --> 00:20:22.840
on the movies relationship.

00:20:22.900 --> 00:20:25.890
Now there are two disadvantages to this.

00:20:26.000 --> 00:20:31.940
The first is that when you fetch
and display the list of studios,

00:20:32.020 --> 00:20:34.990
that will perform not only the
fetch on the studios table,

00:20:34.990 --> 00:20:37.900
but will also perform n
fetches on the movie tables

00:20:37.900 --> 00:20:42.900
for the n studios being listed.

00:20:42.900 --> 00:20:47.540
The second disadvantage is that in
order to perform the count in memory,

00:20:47.540 --> 00:20:50.900
EOF has to fetch and store
those movies in memory.

00:20:51.050 --> 00:20:55.900
So we can actually implement
this slightly more elegantly.

00:20:55.900 --> 00:21:01.180
More efficiently as an aggregate
attribute exploiting a subquery.

00:21:01.400 --> 00:21:05.390
So on the studio entity we implement
a new attribute called moviesCount.

00:21:05.400 --> 00:21:09.650
And the SQL that you see up there
is actually the subquery that

00:21:09.740 --> 00:21:13.390
we insert into the column field.

00:21:13.570 --> 00:21:18.040
You then set the attribute to be derived,
and you make it read-only

00:21:18.040 --> 00:21:19.400
and not locking.

00:21:19.430 --> 00:21:21.940
And that's all there is to it.

00:21:22.160 --> 00:21:27.340
And the advantage here is that
when you now display the studios,

00:21:27.410 --> 00:21:29.700
you will only be performing
one select statement.

00:21:29.700 --> 00:21:32.980
In fact,
it will be a select with a subquery,

00:21:32.980 --> 00:21:37.480
and you won't have to fetch
the movies into memory as well.

00:21:37.480 --> 00:21:40.690
So there are two advantages to this.

00:21:42.010 --> 00:21:45.390
and a couple more advantages
and caveats of subqueries.

00:21:45.390 --> 00:21:48.880
I should say that they're excellent
for implementing other sort of

00:21:48.880 --> 00:21:52.500
aggregate functions as well,
like max, min, and average.

00:21:52.500 --> 00:21:54.500
They're incredibly fast.

00:21:54.500 --> 00:22:00.490
These database servers are very
good at executing these subqueries.

00:22:00.520 --> 00:22:03.820
And thirdly,
they can be implemented as fairly

00:22:03.820 --> 00:22:06.050
elegantly as EO attributes.

00:22:06.060 --> 00:22:10.560
There isn't need to execute
raw SQL at the adapter level in

00:22:10.660 --> 00:22:13.750
order to do things like this.

00:22:14.650 --> 00:22:19.140
However,
do note that one of the caveats of using

00:22:19.670 --> 00:22:25.170
subqueries is that on large data sets,
there can be a performance penalty.

00:22:25.360 --> 00:22:31.020
And this happens if the table you're
subquerying is too big or the table

00:22:31.050 --> 00:22:33.940
that you're subquerying from is too big.

00:22:33.940 --> 00:22:37.000
In either or both of those circumstances,
you will get a significant

00:22:37.220 --> 00:22:38.200
performance penalty.

00:22:38.490 --> 00:22:42.360
So do use it with caution,
as with any technology,

00:22:42.360 --> 00:22:44.290
it can also be abused.

00:22:44.390 --> 00:22:47.430
And case study,
we use subqueries extensively

00:22:47.560 --> 00:22:48.480
in the music store.

00:22:48.480 --> 00:22:52.460
In fact,
it plays a critical role in the content

00:22:52.460 --> 00:22:54.850
management system that we work on.

00:22:55.680 --> 00:22:59.080
Next, let's take a look at raw rows.

00:22:59.260 --> 00:23:01.690
Many of you, I'm sure,
are familiar with raw rows,

00:23:01.700 --> 00:23:03.600
so we'll go through this really quickly.

00:23:03.600 --> 00:23:06.280
The advantages are that
they're lightweight,

00:23:06.280 --> 00:23:10.200
they're easy on memory because
you fetch them as dictionaries

00:23:10.200 --> 00:23:12.600
instead of fully-fledged EOs.

00:23:12.650 --> 00:23:16.770
And the second point is you
can generate optimal SQL as

00:23:16.770 --> 00:23:19.340
in select or join statements.

00:23:19.790 --> 00:23:22.100
However, one of the disadvantages,
of course,

00:23:22.110 --> 00:23:26.700
is because ROROs are read-only,
you need to fault them in

00:23:26.700 --> 00:23:30.000
order to convert them to an
EO before you can edit them.

00:23:30.000 --> 00:23:32.040
And that requires a FETs to the database.

00:23:32.040 --> 00:23:34.210
So when to use ROROs?

00:23:34.290 --> 00:23:38.210
They're ideal,
excellent for fast search pages,

00:23:38.370 --> 00:23:43.980
list pages, and finally,
to cache read-only non-referenced data.

00:23:44.580 --> 00:23:48.520
Now, some applications,
front-end web applications,

00:23:48.610 --> 00:23:50.670
tend to be mostly read-only.

00:23:50.680 --> 00:23:54.110
And in which case, it would make sense,
sometimes,

00:23:54.260 --> 00:23:59.540
to cache some of your non-referenced
data into your shared editing context,

00:23:59.540 --> 00:24:02.060
a feature that we shall
talk about very shortly.

00:24:02.060 --> 00:24:06.340
And an example of such
read-only non-referenced data,

00:24:06.340 --> 00:24:09.920
you could consider the
iTunes Music Store.

00:24:09.920 --> 00:24:12.820
The front-end is essentially
a read-only application.

00:24:13.590 --> 00:24:21.030
So when an iTunes client views albums,
artists, and songs,

00:24:21.030 --> 00:24:26.400
that would be an example of
read-only non-referenced data.

00:24:28.250 --> 00:24:32.800
And with that,
we move on to design goal number three.

00:24:32.850 --> 00:24:35.430
Now, this is--

00:24:35.800 --> 00:24:39.160
Design goal number three is also
inspired by a personal hero of mine,

00:24:39.200 --> 00:24:41.090
the aviator Howard Hughes.

00:24:41.100 --> 00:24:48.860
It can be said that building applications
is a little bit like building airplanes,

00:24:48.860 --> 00:24:54.360
that sometimes to make planes go faster,
or for that matter, go further,

00:24:54.360 --> 00:24:56.060
they make them lighter.

00:24:56.060 --> 00:24:59.660
Certainly they did that in
the days of Howard Hughes.

00:24:59.660 --> 00:25:02.130
In the film The Aviator,

00:25:02.490 --> 00:25:07.030
Howard Hughes breaks a speed record
by flying one of his own planes

00:25:07.030 --> 00:25:09.320
with the fuel tank almost emptied.

00:25:09.320 --> 00:25:13.400
He only had just enough fuel
to break the speed record.

00:25:13.400 --> 00:25:19.390
Indeed, nowadays we don't have
to go to such extremes,

00:25:19.780 --> 00:25:26.540
but the challenges of modern aviation
are no longer about speed or distance,

00:25:26.540 --> 00:25:29.870
but about capacity,
about building larger planes

00:25:29.870 --> 00:25:31.960
that can carry more people.

00:25:32.770 --> 00:25:36.830
And equivalently, it could be said of
the iTunes Music Store,

00:25:37.030 --> 00:25:44.120
no longer is performance so much
a challenge as is scalability.

00:25:44.120 --> 00:25:44.120
And in order to build

00:25:44.360 --> 00:25:48.070
Ultra-efficient,
highly scalable applications.

00:25:48.070 --> 00:25:49.780
You make them lighter.

00:25:49.790 --> 00:25:54.280
So design goal number three,
minimize your memory footprint and

00:25:54.280 --> 00:25:57.290
optimize or minimize recession state.

00:25:57.480 --> 00:26:02.580
And the logic behind this is the
less memory your session consumes,

00:26:02.610 --> 00:26:05.790
the greater the number of sessions your
application will be able to service.

00:26:05.800 --> 00:26:11.800
So try and implement as much
stateless pages as possible.

00:26:11.800 --> 00:26:15.520
A rule of thumb, if a page does not
require authentication,

00:26:15.520 --> 00:26:18.320
that is user login,
it can then be implemented

00:26:18.320 --> 00:26:19.530
as a direct action.

00:26:19.540 --> 00:26:22.480
So use direct actions
and stateless components.

00:26:22.940 --> 00:26:25.820
Number two, share data across sessions.

00:26:25.820 --> 00:26:28.750
Leverage your EOF shared editing context.

00:26:28.850 --> 00:26:33.940
It's a relatively new feature of EOF,
and I hope many of you do use it.

00:26:33.980 --> 00:26:41.710
Third, try not to add layer upon layer
of middleware to your application.

00:26:41.720 --> 00:26:44.700
Apart from obscuring the
use of standard APIs,

00:26:44.700 --> 00:26:48.060
it adds to the memory
footprint of an application.

00:26:48.060 --> 00:26:50.950
And as I said before,
the more memory your

00:26:50.950 --> 00:26:53.810
application consumes,
the fewer the number of

00:26:53.820 --> 00:26:56.040
instances you'll be able to run,
and the fewer the number of

00:26:56.040 --> 00:26:57.440
sessions you'll be able to service.

00:27:01.900 --> 00:27:05.680
And fourthly and lastly,
partition your application functionality.

00:27:05.870 --> 00:27:11.910
A fairly typical partitioning of
application functionality is front end,

00:27:12.020 --> 00:27:15.410
perhaps read only,
and a back end admin tool.

00:27:15.530 --> 00:27:19.200
And an example of that would be, again,
the iTunes Music Store.

00:27:19.250 --> 00:27:22.860
We have a pseudo web service front end,
which is pretty much read only,

00:27:23.020 --> 00:27:26.850
and we have a content
management tool as a back end.

00:27:27.100 --> 00:27:29.830
Now these two applications are
just the tip of the iceberg.

00:27:29.920 --> 00:27:32.440
They form a suite of applications,
in fact,

00:27:32.480 --> 00:27:35.760
that make up the iTunes Music Store.

00:27:35.990 --> 00:27:39.380
Let's take a look at the first
point in a little more detail.

00:27:39.380 --> 00:27:41.230
Optimize your session state.

00:27:41.230 --> 00:27:46.040
As I said,
we do this by really taking advantage

00:27:46.040 --> 00:27:50.780
of direct actions and making as
much of your application stateless.

00:27:52.460 --> 00:27:54.840
So use direct action
pages wherever possible,

00:27:54.840 --> 00:27:57.900
and then fetch EOs into
local editing contexts.

00:27:57.900 --> 00:28:01.900
Now, for example,
if we were to have a search page that

00:28:02.280 --> 00:28:08.020
fetched EOs or search results into
your session's default editing context,

00:28:08.020 --> 00:28:12.420
those EOs will stay in memory
until that session is discarded,

00:28:12.420 --> 00:28:15.420
that is, until the user has logged out.

00:28:15.460 --> 00:28:19.130
It makes more sense to
fetch those sort of results,

00:28:19.470 --> 00:28:22.350
search results, into editing contexts.

00:28:22.470 --> 00:28:24.050
But we also want to make sure that we
are not only collecting the EOs that are

00:28:24.050 --> 00:28:30.610
local to the component or the action,
because as a result,

00:28:30.610 --> 00:28:30.610
they will be discarded at the
end of the request response loop.

00:28:31.100 --> 00:28:34.090
and third, implement stateless
WebObjects components.

00:28:34.130 --> 00:28:38.990
Now these are singleton components
that service the entire application.

00:28:39.230 --> 00:28:43.070
And they're very handy,
they can be used in stateless direct

00:28:43.250 --> 00:28:46.670
action pages as well as WebObjects pages.

00:28:46.970 --> 00:28:49.460
And finally,
and this is in fact very key,

00:28:49.540 --> 00:28:51.890
is to minimize your session state.

00:28:51.930 --> 00:28:56.060
Try not to scope your
variables within your session.

00:28:56.060 --> 00:28:59.620
Only do that when absolutely necessary.

00:28:59.620 --> 00:29:04.810
And this helps to keep the
session memory down to a minimum.

00:29:06.180 --> 00:29:07.800
Let's look at EO Shared Editing Context.

00:29:07.910 --> 00:29:10.320
Again, I'm sure many of you are
fairly familiar with this,

00:29:10.430 --> 00:29:13.700
so very quickly, the advantages.

00:29:14.780 --> 00:29:19.890
It's ideal for sharing
read-only data between sessions,

00:29:19.900 --> 00:29:22.990
and emphasis being on read-only.

00:29:23.130 --> 00:29:25.190
In fact,
Bill suggests that EO shared editing

00:29:25.190 --> 00:29:27.230
context is a bit of a misnomer.

00:29:27.240 --> 00:29:31.170
It should really be EO read-only
shared editing context.

00:29:31.300 --> 00:29:34.500
But there you go.

00:29:34.590 --> 00:29:36.200
It's also thread-safe.

00:29:36.320 --> 00:29:41.770
And thirdly, in fact, most importantly,
it reduces database traffic.

00:29:41.940 --> 00:29:45.750
The kind of reference data that
we mean that should be stored

00:29:45.760 --> 00:29:50.790
in a shared editing context,
things like countries, currencies,

00:29:50.820 --> 00:29:52.310
states, things like that.

00:29:52.380 --> 00:29:57.020
Now, consider for a minute a page that
has a pop-up consisting of countries.

00:29:57.020 --> 00:30:01.590
Now, every time that page is requested,
if countries were not shared

00:30:01.590 --> 00:30:06.130
or cached as shared EOs,
the EOF will perform a select

00:30:06.250 --> 00:30:09.420
statement onto the database.

00:30:09.680 --> 00:30:12.480
In a large application like
the iTunes Music Store,

00:30:12.480 --> 00:30:19.240
these frequent but small fetches could
in fact throttle the database connection.

00:30:19.260 --> 00:30:22.520
So, shared editing contexts
serve a second purpose,

00:30:22.650 --> 00:30:25.290
and that is to reduce database traffic.

00:30:25.300 --> 00:30:28.200
And case in point,
the iTunes Music Store,

00:30:28.200 --> 00:30:33.340
we have over 40 plus shared entities,
and we experience a significant

00:30:33.340 --> 00:30:36.090
performance boost using shared EOs.

00:30:38.970 --> 00:30:42.260
And finally, we come to the second
half of the presentation.

00:30:42.260 --> 00:30:47.370
But before I introduce Max,
who's going to demonstrate and talk about

00:30:47.390 --> 00:30:52.240
some advanced optimization techniques,
I'd just like to say a few points.

00:30:52.660 --> 00:30:57.410
The key to successful optimization,
just like any other science,

00:30:57.410 --> 00:30:58.840
is observation.

00:30:58.840 --> 00:31:04.210
It is careful observation to monitor
the application youth edge is what can

00:31:04.210 --> 00:31:09.980
help identify those bits of the system
that need to be tweaked and optimized.

00:31:09.980 --> 00:31:13.140
And to that end,
there are a set of tools at your

00:31:13.360 --> 00:31:16.050
disposal to help with this analysis.

00:31:16.150 --> 00:31:19.900
And the first port of call,
as I'm sure most of you should

00:31:19.950 --> 00:31:22.660
or probably are aware of,
is statistics.

00:31:22.660 --> 00:31:24.860
It's a tool that allows you
to turn on your SQL logging.

00:31:24.860 --> 00:31:28.940
And you do that by setting
your adapter debug enabled on.

00:31:30.230 --> 00:31:33.230
The chances are that
20 to 30%, if not more,

00:31:33.280 --> 00:31:36.540
of your optimization issues
will be database related,

00:31:36.550 --> 00:31:40.330
in which case you will actually
identify them at this point.

00:31:40.340 --> 00:31:44.690
After this, we need to turn to some
more sophisticated tools to

00:31:44.690 --> 00:31:46.880
optimize our application.

00:31:46.880 --> 00:31:50.170
And the first would be your
WoEvents page to profile your

00:31:50.170 --> 00:31:52.980
application using WoEvents,
something Max is going

00:31:52.980 --> 00:31:57.290
to show up very shortly,
and monitor your usage using WoEstats.

00:31:57.610 --> 00:32:00.940
You can even take that a little
further and use web server log

00:32:01.120 --> 00:32:06.000
analysis tools like Webalyzer
and Webtrends to monitor usage.

00:32:06.000 --> 00:32:09.690
And with that, I think I should introduce
you to Max Muller.

00:32:09.700 --> 00:32:13.280
He's Manager of Content Provisioning
at the iTunes Music Store.

00:32:13.280 --> 00:32:14.360
Everybody, Max.

00:32:20.920 --> 00:32:21.260
Excellent.

00:32:21.430 --> 00:32:22.500
Thank you, Ravi.

00:32:22.650 --> 00:32:24.430
As Ravi mentioned, my name is Max Muller.

00:32:24.440 --> 00:32:27.000
I am engineering manager for
content provisioning and operations

00:32:27.000 --> 00:32:28.240
at the iTunes Music Store.

00:32:28.240 --> 00:32:30.550
I've been in the
WebObjects field for many,

00:32:30.550 --> 00:32:33.760
many years and with the
Music Store since the inception.

00:32:33.760 --> 00:32:40.200
So I've experienced all of the different
performance problems and tuning problems

00:32:40.200 --> 00:32:46.000
that we've gone through as the load has
increased and the performance has become

00:32:46.490 --> 00:32:49.110
very critical with the Music Store.

00:32:49.730 --> 00:32:52.670
So what I thought I would do is
actually go through a number of

00:32:52.670 --> 00:32:57.520
the knobs and screws that you can
tune for your entire deployment.

00:32:57.520 --> 00:33:01.690
Oftentimes, we focus all of our energy on
basically getting the WOA to perform

00:33:01.780 --> 00:33:04.260
exactly the way we want it to,
making sure it's not

00:33:04.310 --> 00:33:06.540
doing extraneous fetches,
these types of issues.

00:33:06.540 --> 00:33:10.460
But then when we actually go
to deploy the application,

00:33:10.460 --> 00:33:15.120
we find that the performance is
suffering or the application is

00:33:15.120 --> 00:33:17.880
not responding in the correct way.

00:33:18.480 --> 00:33:21.410
So we find these kind of very
strange anomalies going on where

00:33:21.410 --> 00:33:24.610
we have one application that's
taking down all the rest of the

00:33:24.610 --> 00:33:27.560
applications and these type of issues.

00:33:27.600 --> 00:33:31.750
So the first point at which
any request comes into your

00:33:31.750 --> 00:33:34.360
site is through the web server.

00:33:34.440 --> 00:33:35.980
So this is essentially the WOA adapter.

00:33:35.980 --> 00:33:40.160
This is the piece of code that runs in
Apache or one of the other web servers.

00:33:40.260 --> 00:33:43.330
And it is the Achilles heel
and the choke point for all

00:33:43.330 --> 00:33:45.460
requests into your application.

00:33:45.520 --> 00:33:47.320
So it's important to understand
exactly how to tune that.

00:33:47.330 --> 00:33:51.800
exactly how to tune that before you
actually even get to your application.

00:33:52.030 --> 00:33:55.580
So, in terms of the WoW adapter,
there's a number of different ways

00:33:55.580 --> 00:33:56.960
in which it can be configured.

00:33:56.960 --> 00:34:00.020
And the most important bit being
that the default configuration is

00:34:00.020 --> 00:34:02.790
most definitely not what you want for
every single one of your applications.

00:34:02.800 --> 00:34:05.190
It's probably not even what you
want for one of your applications.

00:34:05.200 --> 00:34:10.060
So, within the parameters,
the first point to look at

00:34:10.060 --> 00:34:12.950
are all the timeout settings.

00:34:13.040 --> 00:34:16.550
Within one application setting,
you have what's called

00:34:16.900 --> 00:34:19.360
the connect timeout,
the send timeout,

00:34:19.710 --> 00:34:21.370
and the receive timeout.

00:34:21.900 --> 00:34:24.750
So, breaking that down,
and also I thought that

00:34:25.040 --> 00:34:28.450
I'd put up here what,
yeah, this is essentially a snippet

00:34:28.580 --> 00:34:31.960
from exactly how we have
Music Store configured today for

00:34:31.960 --> 00:34:35.230
one of our basically storefront.

00:34:35.240 --> 00:34:38.170
It's a sessionless read-only
application that essentially

00:34:38.170 --> 00:34:41.670
renders all of the album pages,
store pages, these type of pages.

00:34:41.680 --> 00:34:45.300
So, the send timeout,
or the connect timeout, sorry,

00:34:45.420 --> 00:34:50.290
is how long the adapter will wait
trying to connect your application.

00:34:50.300 --> 00:34:51.770
If your app's down.

00:34:51.900 --> 00:34:55.290
If it is completely busy
processing all the other requests

00:34:55.300 --> 00:34:58.350
and its queue is completely full,
how long is it going to sit there and

00:34:58.350 --> 00:35:00.340
basically wait on your application?

00:35:00.340 --> 00:35:03.140
Setting this to something very high,
you'll start to get,

00:35:03.140 --> 00:35:07.040
this is where you start to basically
get no instance available back.

00:35:07.080 --> 00:35:11.540
Setting it to something very low means
that if your app is very busy and

00:35:11.540 --> 00:35:14.910
just doesn't have time to respond back
to basically take in the request,

00:35:14.940 --> 00:35:17.050
then you're going to start
snapping it and it's going to

00:35:17.050 --> 00:35:18.380
start getting marked as dead.

00:35:18.380 --> 00:35:21.880
So, playing with this app,
playing with this setting,

00:35:21.900 --> 00:35:28.090
is important in knowing how much
time basically a buffer for that.

00:35:28.330 --> 00:35:30.120
The second one is the send timeout.

00:35:30.140 --> 00:35:32.140
This one's not nearly as important.

00:35:32.140 --> 00:35:35.060
It's how long is it going to
basically wait to send the

00:35:35.080 --> 00:35:37.120
request into your application.

00:35:37.140 --> 00:35:41.890
This is more important if you're
dealing with large uploads of files,

00:35:41.890 --> 00:35:43.380
these type of things,
because that's how long

00:35:43.480 --> 00:35:45.620
it's going to wait before it
basically snaps the connection.

00:35:45.660 --> 00:35:47.600
The third one is the receive timeout.

00:35:47.660 --> 00:35:51.580
This is by far the most
important of the three timeouts.

00:35:51.900 --> 00:35:54.860
This is how long the adapter is
going to wait for the response.

00:35:54.900 --> 00:36:00.900
So, setting this to a very high value
means that if your application wedges,

00:36:00.900 --> 00:36:04.180
then essentially it's not going to
be getting the response back and the

00:36:04.180 --> 00:36:05.900
adapter is going to wait there forever.

00:36:05.900 --> 00:36:08.390
The most important part
about that is that as long as

00:36:08.510 --> 00:36:10.950
it's opening the connection,
your web server is

00:36:11.010 --> 00:36:12.880
holding that request open.

00:36:12.900 --> 00:36:15.360
OS X,
you can handle about 800 requests before

00:36:15.360 --> 00:36:18.880
the whole box wedges up and you have to
go in and start killing Apache processes.

00:36:18.960 --> 00:36:21.660
So, having a very high
timeout here means that,

00:36:21.900 --> 00:36:24.590
if something goes wrong in your
environment where your apps all of

00:36:24.590 --> 00:36:28.330
a sudden stop responding quickly,
that's essentially your window

00:36:28.330 --> 00:36:32.670
of time for how long before
your web server backs up.

00:36:32.900 --> 00:36:37.900
So, for the store,
we have it connected 5, 20, and 30.

00:36:37.900 --> 00:36:41.000
It means we're going to wait 30
seconds for the page to render,

00:36:41.000 --> 00:36:42.890
after which point we're going to snap it.

00:36:42.900 --> 00:36:44.900
So, the second bit is the retries.

00:36:44.900 --> 00:36:47.900
This is if you don't get a
response back from an app,

00:36:47.900 --> 00:36:52.250
how many times should you basically,
should you take the request, and say,

00:36:52.250 --> 00:36:53.890
"Well, let me go try this application.

00:36:54.090 --> 00:36:57.890
Let me go try this one." So,
within the store, it's fine,

00:36:57.890 --> 00:36:58.900
it's read-only.

00:36:58.970 --> 00:37:02.470
But, configuring this for a finance
application where somebody clicks "Buy

00:37:02.490 --> 00:37:05.900
Song" and all of a sudden it can't
get a response back from this finance,

00:37:05.930 --> 00:37:08.420
so it says, "Hmm,
I'll go ahead and hand it off to this

00:37:08.440 --> 00:37:10.900
one." And this one would mean that
the user might all of a sudden say,

00:37:10.900 --> 00:37:12.980
"Well, I only clicked the Buy Song once
and all of a sudden I got

00:37:12.980 --> 00:37:15.690
charged three times." So,
you have to be careful with that

00:37:15.700 --> 00:37:18.170
one because that's the number
of times it's going to retry.

00:37:18.720 --> 00:37:21.820
and so the third one is the dead timeout.

00:37:21.910 --> 00:37:24.030
That's the one on the
far right hand corner.

00:37:24.110 --> 00:37:26.310
So when you pull this page up,
the dead timeout is

00:37:26.320 --> 00:37:27.860
actually the countdown.

00:37:27.860 --> 00:37:30.240
And what happens is that
if the application doesn't

00:37:30.240 --> 00:37:33.990
respond or can't connect to it,
the app gets marked as dead.

00:37:34.040 --> 00:37:38.260
When an app is dead,
then no other requests are routed to it.

00:37:38.280 --> 00:37:43.150
So that is the dead timeout
over here is 20 seconds.

00:37:43.250 --> 00:37:46.730
So that means if for whatever
reason your box goes offline,

00:37:46.730 --> 00:37:48.580
that you're out,
that you're out of timeout.

00:37:48.600 --> 00:37:51.340
So that means that the adapter
is going to route a request to

00:37:51.380 --> 00:37:55.720
that guy once every 20 seconds,
which means that that request is

00:37:55.720 --> 00:37:58.250
for sure going to get rejected
and handed off to another guy.

00:37:58.260 --> 00:38:01.210
Or if you have a finance application
and you've just lost a box,

00:38:01.210 --> 00:38:04.210
that means that the user is going
to basically get a nice little,

00:38:04.220 --> 00:38:06.520
sorry,
music store is not available right now,

00:38:06.520 --> 00:38:07.880
come back again later.

00:38:07.880 --> 00:38:10.750
One out of every 20,
once every 20 seconds,

00:38:10.790 --> 00:38:14.890
one user out there is going to be getting
that response for every application

00:38:14.900 --> 00:38:17.130
that's dead and completely offline.

00:38:17.920 --> 00:38:21.320
So having a very high dead timeout,
so this is also very important

00:38:21.330 --> 00:38:22.560
when you bounce applications.

00:38:23.140 --> 00:38:24.770
Because if it takes, you know,
three minutes for your app to

00:38:24.820 --> 00:38:27.570
come up and you bounce an app,
then that means that, you know,

00:38:27.570 --> 00:38:30.340
you're going to basically be
routing over six requests to it,

00:38:30.380 --> 00:38:34.550
no, sorry, nine requests to it,
before it's actually even

00:38:34.550 --> 00:38:35.980
able to process requests.

00:38:35.980 --> 00:38:39.250
So the temptation here might be to
basically bump that up very high.

00:38:39.250 --> 00:38:44.390
But then you start to get this nice
swimming effect where if you have

00:38:44.390 --> 00:38:48.400
a three minute dead timeout and all
of a sudden you get hit with a large

00:38:48.400 --> 00:38:50.970
load and the apps just start to are
just taking a while to process it,

00:38:50.970 --> 00:38:53.440
then everything gets marked as dead.

00:38:53.600 --> 00:41:14.200
[Transcript missing]

00:41:15.290 --> 00:41:17.910
So now after the adapter,
before we've even gotten to

00:41:18.020 --> 00:41:22.120
start processing the request,
so what are some of the tools that we

00:41:22.260 --> 00:41:24.360
can basically tune at the WOA level?

00:41:24.380 --> 00:41:26.880
So the first is the listen queue size.

00:41:26.880 --> 00:41:29.920
Now the listen queue is
essentially the thread,

00:41:30.050 --> 00:41:34.410
the server socket thread that sits
there and listens for requests.

00:41:34.420 --> 00:41:38.600
This is the one that if it's full,
then the connect timeout from the

00:41:38.600 --> 00:41:41.270
adapter is basically not able to get in.

00:41:42.410 --> 00:41:46.930
This is also essentially the queue,
the complete queue size that your

00:41:47.110 --> 00:41:52.310
application will hold to basically
hand off to worker threads to process.

00:41:52.320 --> 00:41:55.360
Now the default is 128.

00:41:55.360 --> 00:41:58.140
So...

00:41:58.910 --> 00:42:01.820
What we noticed is that this
is incredibly high value.

00:42:01.820 --> 00:42:07.070
And it's interesting because
what we would find is that we

00:42:07.070 --> 00:42:09.940
would get hit with some slowdown
would happen within the system.

00:42:09.960 --> 00:42:12.980
Either the credit card
processing would have a blip,

00:42:12.980 --> 00:42:15.780
or the web servers would
freak out for a moment,

00:42:15.780 --> 00:42:19.380
or we'd get a database oopsie,
or something along those

00:42:19.380 --> 00:42:20.520
lines would happen.

00:42:21.300 --> 00:42:24.450
But we noticed that it would
take 15 to 20 minutes before

00:42:24.550 --> 00:42:26.080
all of the apps would come down.

00:42:26.080 --> 00:42:28.480
In terms of, you know,
the CPU would be up to the roof,

00:42:28.590 --> 00:42:31.720
and they'd be sitting there processing,
doing a whole lot of stuff,

00:42:31.720 --> 00:42:33.540
and the web servers would
still be freaking out.

00:42:33.540 --> 00:42:36.580
And we couldn't figure out what this
was because we'd see this one blip

00:42:36.580 --> 00:42:39.540
that we could definitely identify,
and then we'd see like 15 to

00:42:39.660 --> 00:42:41.160
20 minutes of pain afterwards.

00:42:41.160 --> 00:42:43.740
And, you know,
so we're basically going through

00:42:43.740 --> 00:42:45.440
all the different settings.

00:42:45.440 --> 00:42:46.810
We're like, oh, what's going on here?

00:42:46.820 --> 00:42:49.830
And just nothing but broken
pipes throughout the logs.

00:42:50.720 --> 00:42:53.390
So what we actually found was that,
you know, we hadn't basically adjusted

00:42:53.390 --> 00:42:54.340
the listen queue size.

00:42:54.340 --> 00:42:57.660
So what, we're under quite a bit of load.

00:42:57.680 --> 00:42:59.640
All of a sudden we get a blip,
which means that your

00:42:59.640 --> 00:43:01.340
apps basically stop for,
you know, 5,

00:43:01.340 --> 00:43:04.260
10 seconds where they're waiting
on the database to come back,

00:43:04.350 --> 00:43:07.140
waiting for a lock or something like
this that we hadn't anticipated.

00:43:07.140 --> 00:43:10.360
Meanwhile,
the adapters are sitting there, you know,

00:43:10.360 --> 00:43:13.260
continuing to feed your WOAs,
and the listen queues

00:43:13.280 --> 00:43:14.970
are basically queuing up.

00:43:16.280 --> 00:43:17.000
So then what happens?

00:43:17.000 --> 00:43:21.300
Then basically the lock comes back,
your app starts processing again,

00:43:21.300 --> 00:43:23.300
but it's got 128 requests to process.

00:43:23.300 --> 00:43:26.410
Not to mention the adapter is all
ready to basically give you more.

00:43:26.420 --> 00:43:29.480
And those 128,
if the blip was long enough,

00:43:29.480 --> 00:43:33.310
and remember the receive
timeout was set to 30 seconds?

00:43:33.320 --> 00:43:37.080
So if the blip lasted 30 seconds,
you've got 128 requests there

00:43:37.080 --> 00:43:40.220
that the adapter has long since
severed the connection on.

00:43:40.640 --> 00:43:43.540
Your WOA is going to sit there and
just basically sit there and diligently

00:43:43.540 --> 00:43:46.790
chew through every single one,
finish rendering the page,

00:43:46.880 --> 00:43:49.410
get it all ready to go,
then go to write it out and be like, oh,

00:43:49.410 --> 00:43:50.170
broken pipe.

00:43:50.200 --> 00:43:52.100
Well,
let me grab the next one off the queue,

00:43:52.100 --> 00:43:54.780
work through the whole thing, then oh,
broken pipe again.

00:43:54.780 --> 00:43:58.120
So the queue size is pretty important
because this is kind of how,

00:43:58.120 --> 00:44:00.360
this is how many you
should basically have,

00:44:00.360 --> 00:44:03.470
how many requests you can handle
in flight and still be within

00:44:03.470 --> 00:44:05.360
that receive timeout window.

00:44:05.360 --> 00:44:10.010
So 128, you're going to have to
have one hefty WOA there.

00:44:10.140 --> 00:44:13.810
And you have some really fast responses
to be able to get 128 of those guys out.

00:44:13.820 --> 00:44:15.750
All right, so next step.

00:44:15.840 --> 00:44:17.980
So after the queue,
you then get handed off

00:44:17.980 --> 00:44:19.190
to the worker thread.

00:44:19.240 --> 00:44:21.620
So the worker thread,
these are the actual ones that go

00:44:21.730 --> 00:44:25.630
through the dispatch request and actually
generate something and then hand it off.

00:44:25.660 --> 00:44:31.560
So the thread size is interesting in how
you basically build your application.

00:44:31.560 --> 00:44:33.790
You know,
typically we won't have more than

00:44:33.790 --> 00:44:37.110
a worker thread size of actually
four within the music store.

00:44:37.120 --> 00:44:39.640
And that's mainly because
even for our multi-task,

00:44:39.640 --> 00:44:39.640
we're going to have a lot of requests.

00:44:39.730 --> 00:44:41.780
And for our multi-threaded ones,
we don't want to get too many of

00:44:41.780 --> 00:44:43.270
these guys going at the same time.

00:44:43.320 --> 00:44:44.690
You know, we're all on XSERVs.

00:44:44.740 --> 00:44:46.400
We've got two processors.

00:44:46.460 --> 00:44:49.790
And for our fully threaded ones,
they're CPU bound.

00:44:49.840 --> 00:44:54.640
So you get 256 of these guys
going on an XSERV and basically

00:44:54.640 --> 00:44:56.970
all the threads are sitting there
waiting for processing time.

00:44:56.980 --> 00:44:58.710
And so it actually
brings down your whole,

00:44:58.780 --> 00:45:03.710
you know, your overall, you know,
your overall performance level.

00:45:03.830 --> 00:45:06.550
So you got to be careful with the
worker thread size because the

00:45:06.570 --> 00:45:09.140
worker thread size and your CPUs,
you know, the current processing time,

00:45:09.140 --> 00:45:11.140
the current processing
that you have available,

00:45:11.170 --> 00:45:12.680
that's where you want to
make your trade off there.

00:45:12.920 --> 00:45:13.920
And.

00:45:16.320 --> 00:45:19.370
But even on a single-threaded app,
the temptation is always basically to

00:45:19.370 --> 00:45:21.340
just have like one worker thread there.

00:45:21.360 --> 00:45:23.900
But you typically want to
have like two or three,

00:45:23.940 --> 00:45:27.310
just because it does take a long
time sometimes for large requests

00:45:27.430 --> 00:45:29.360
to basically stream back out.

00:45:29.450 --> 00:45:32.470
So even after you've finished
in the dispatch request,

00:45:32.470 --> 00:45:35.440
dispatch request, by the way,
is fully threaded.

00:45:35.440 --> 00:45:40.260
FYI, even if you have a Woken current
request handling set to false,

00:45:40.480 --> 00:45:43.690
dispatch request fully threaded.

00:45:43.940 --> 00:45:46.580
So, anyway,
so those are some of the knobs that

00:45:46.580 --> 00:45:49.110
you can basically tune even before
you start processing your requests.

00:45:49.120 --> 00:45:53.950
One word of caution I would point out,
we did have cases where we were basically

00:45:54.020 --> 00:45:57.860
looking for long-running requests that
had basically screwed something up.

00:45:57.860 --> 00:46:01.080
And so the first implementation was
basically just to nuke the thread.

00:46:01.100 --> 00:46:05.540
But FYI,
that'll leave EOF in a very nasty state.

00:46:05.580 --> 00:46:10.570
Best just to basically system exit if you
want to basically go something like that.

00:46:12.160 --> 00:46:13.480
So there's your WOA.

00:46:13.480 --> 00:46:16.070
That's how you can basically
tune your WOA server.

00:46:17.500 --> 00:46:20.000
So the last bit that I'd
mention is essentially how do

00:46:20.000 --> 00:46:21.190
you then tune your deployment.

00:46:21.190 --> 00:46:25.280
So you now have your adapter
set configured correctly.

00:46:25.280 --> 00:46:29.300
You know basically how you
want your WOA to behave.

00:46:29.300 --> 00:46:32.560
So now you're kind of looking at your
whole deployment architecture because

00:46:32.720 --> 00:46:34.440
you're now basically ready to deploy.

00:46:35.480 --> 00:46:39.670
So one bit that I'd mention is you
might want to separate your web

00:46:39.720 --> 00:46:43.340
servers because one of the bits that,
you know, within the music store we never

00:46:43.340 --> 00:46:45.360
want to stop taking orders,
ever.

00:46:45.800 --> 00:46:50.050
So, but at the same time, you know,
we have other very high performance

00:46:50.110 --> 00:46:56.150
things like search and like the store
pages and if you have all of your web

00:46:56.260 --> 00:47:03.790
servers essentially sharing one comp
file and handling the HTTPS and the HTTP,

00:47:03.790 --> 00:47:03.790
then

00:47:04.000 --> 00:49:54.400
[Transcript missing]

00:49:55.300 --> 00:54:20.700
[Transcript missing]

00:54:20.800 --> 00:55:49.300
[Transcript missing]

00:55:49.590 --> 00:55:52.200
the latency of basically going and
getting those things is probably

00:55:52.230 --> 00:55:53.460
slowing down the request response loop.

00:55:53.480 --> 00:55:56.750
Also being able to kind of look
at the total properties that

00:55:57.160 --> 00:55:58.620
you have within the system.

00:55:58.620 --> 00:56:00.960
You know, we've got 15, 20 frameworks.

00:56:00.960 --> 00:56:02.440
They all have their own properties files.

00:56:02.440 --> 00:56:03.560
We have deployment properties.

00:56:03.560 --> 00:56:05.140
We have all these kind
of mixture of properties.

00:56:05.140 --> 00:56:08.610
And so a lot of the times, you know,
when you're looking at to debug a

00:56:09.040 --> 00:56:11.770
problem going on in the environment,
you're like,

00:56:11.940 --> 00:56:13.090
what is this thing configured with?

00:56:13.160 --> 00:56:16.610
So being able to kind of
look at and reload and touch

00:56:16.610 --> 00:56:19.780
properties has been very helpful.

00:56:19.780 --> 00:56:24.120
And again, I mentioned having kind of
the independent web servers.

00:56:24.120 --> 00:56:26.360
So we had to move to kind of
having independent web servers

00:56:26.360 --> 00:56:29.460
for our monitoring tools as
well as kind of the front end.

00:56:29.460 --> 00:56:33.190
Because oftentimes when you
want the information the most

00:56:33.340 --> 00:56:34.960
is when things are going wrong.

00:56:34.980 --> 00:56:38.180
And when your web servers are down,
then you can't monitor as well.

00:56:38.200 --> 00:56:40.780
So kind of having a
different set of web servers,

00:56:40.780 --> 00:56:43.460
that you basically are talking
into and looking into your

00:56:43.460 --> 00:56:47.330
applications versus the... the
application versus the web servers

00:56:47.340 --> 00:56:49.260
that are serving the applications,
we found that to be

00:56:49.260 --> 00:56:50.420
very beneficial as well.

00:56:50.440 --> 00:56:51.900
And so I apologize.

00:56:51.900 --> 00:56:53.750
Demo gods were not with me.

00:56:53.780 --> 00:56:58.960
But my machine is actually kernel
panicking when I connect in to this.

00:56:58.960 --> 00:57:03.980
So I did have a small demo set up
to basically show kind of being

00:57:03.980 --> 00:57:07.140
able to do property turnaround,
being able to dump stack when

00:57:07.140 --> 00:57:09.280
you... for long-running requests.

00:57:09.280 --> 00:57:11.270
But... So I apologize for that.

00:57:11.280 --> 00:57:13.160
But that is actually the session.

00:57:13.160 --> 00:57:15.480
And now... more information.

00:57:15.800 --> 00:57:19.420
At this point,
I think we are opening up to questions.

00:57:23.010 --> 00:57:29.210
So, we got a WebObjects
feedback session after this.
WEBVTT

00:00:12.070 --> 00:00:16.880
Hello,
welcome to the FxPlug Overview session.

00:00:16.880 --> 00:00:20.760
My name is Dave Howell,
and I'm an FxPlug engineer.

00:00:20.760 --> 00:00:26.640
And we're going to talk
today about the FxPlug spec.

00:00:26.640 --> 00:00:33.240
You'll learn about what
the FxPlug spec is,

00:00:33.240 --> 00:00:34.520
what the SDK is, and why we developed it.

00:00:35.180 --> 00:00:40.950
And we'll talk about how to
write your own FxPlug plug-ins.

00:00:43.110 --> 00:00:52.080
First, the FxPlug spec is a new FxPlug-in
architecture that we've introduced.

00:00:52.080 --> 00:00:55.000
It was created by the
Apple Pro Apps team,

00:00:55.050 --> 00:01:00.040
and the first host app,
which was recently, just last month,

00:01:00.040 --> 00:01:02.510
released is Motion 2.0.

00:01:04.810 --> 00:01:11.980
Now, we developed a new plugin
architecture for quite a few reasons.

00:01:11.980 --> 00:01:16.360
There are other ways to write
plugins that will run in motion.

00:01:16.360 --> 00:01:21.260
We wanted to add features that we
think plugin developers need to

00:01:21.370 --> 00:01:26.140
really make their image processing
algorithms and effects shine.

00:01:26.140 --> 00:01:30.400
So, some of those are unique things
that we want in our own --

00:01:30.400 --> 00:01:37.720
that we have in our own apps,
like the dashboard in motion.

00:01:37.720 --> 00:01:41.180
And taking advantage of things
like the fact that the motion

00:01:41.180 --> 00:01:43.590
app renders its canvas in OpenGL.

00:01:43.590 --> 00:01:46.750
So,
you can render custom on-screen controls

00:01:46.750 --> 00:01:49.810
right onto the canvas in OpenGL.

00:01:50.010 --> 00:01:54.260
Hardware acceleration,
there isn't another image processing

00:01:54.260 --> 00:02:02.140
effects plug-in architecture that lets
you do hardware accelerated plug-ins.

00:02:02.140 --> 00:02:05.220
We wanted you to be able
to take advantage of

00:02:05.220 --> 00:02:10.370
Core Image and OpenGL itself,
and Core Graphics, Quartz Extreme.

00:02:11.100 --> 00:02:16.960
So another thing is that most plugin
architectures are cross platform.

00:02:16.960 --> 00:02:21.780
And a disadvantage of that is that the
people designing it need to use the

00:02:21.780 --> 00:02:26.960
least common denominator between the
different apps that between the different

00:02:26.960 --> 00:02:30.240
platforms that the plugins will run on.

00:02:30.240 --> 00:02:31.240
And we didn't have to do that.

00:02:31.240 --> 00:02:33.860
We were able to leverage
strengths of the Apple platform.

00:02:33.860 --> 00:02:38.890
All the things that you've heard at the
other sessions here at the conference,

00:02:38.890 --> 00:02:43.100
things like first class
adoption of OpenGL,

00:02:43.100 --> 00:02:49.550
core image filters,
and creating interfaces using AppKit and

00:02:49.640 --> 00:02:54.240
Interface Builder and Objective-C itself.

00:02:54.240 --> 00:02:59.410
Now why did we go and use Objective-C?

00:03:00.090 --> 00:03:04.240
We wanted to be able to use both in
our design of the architecture and also

00:03:04.240 --> 00:03:12.490
to support in your plug-ins all of the
elegance of C++ without the problems

00:03:12.500 --> 00:03:18.870
that you get with subsequent versions
of the GCC compiler like the application

00:03:18.870 --> 00:03:23.070
binary interface changing from one
version to another or the fragile

00:03:23.160 --> 00:03:26.830
base class problem that CCC presents.

00:03:26.830 --> 00:03:27.900
Objective C helps with that.

00:03:28.490 --> 00:03:33.240
And of course we wanted you to
be able to access AppKit and

00:03:33.260 --> 00:03:36.270
Core Image in particular.

00:03:36.440 --> 00:03:40.640
And to use Interface Builder,
which integrates nicely with the

00:03:40.650 --> 00:03:45.550
classes in your controllers and views
when you're doing custom parameter UI.

00:03:49.120 --> 00:03:53.810
So reasons that you might want to
write FxPlug plug-ins and port any

00:03:53.810 --> 00:03:59.980
plug-ins you may have to the FxPlug
SDK or develop new plug-ins in our SDK.

00:03:59.980 --> 00:04:05.670
One is that even though at the moment
we're only supporting FxPlugs in Motion,

00:04:05.670 --> 00:04:09.780
there are plans,
we plan to support them in Final Cut.

00:04:09.780 --> 00:04:15.480
And between the two apps,
over a third of a million users

00:04:15.480 --> 00:04:15.780
are waiting to buy your plug-in.

00:04:16.410 --> 00:04:19.510
Another thing is that if you've
already got a plug-in that's

00:04:19.510 --> 00:04:23.820
running in software only mode,
you can use OpenGL and use

00:04:23.820 --> 00:04:29.410
Core Image Filters to accelerate your
plug-in and get really dramatic results.

00:04:31.500 --> 00:04:39.290
Another thing is that the custom UI that
we are supporting lets you use all of

00:04:39.370 --> 00:04:45.060
the app kit and NSView and NSResponder.

00:04:45.950 --> 00:04:46.890
and David Koehn.

00:04:47.900 --> 00:04:47.900
Thank you, Dave.

00:04:47.900 --> 00:04:48.900
Thank you, Dave.

00:04:49.320 --> 00:04:50.080
So, we're going to start off with a quick
overview of the FxPlug code that you

00:04:50.090 --> 00:04:50.900
would put into an app of your own,
into a plug-in.

00:04:50.920 --> 00:04:57.080
And finally,
the on-screen controls that I mentioned

00:04:57.080 --> 00:05:02.250
that you can render controls onto
the canvas surface itself to let

00:05:02.320 --> 00:05:08.780
people directly manipulate your points
and shapes and outlines or motion

00:05:08.780 --> 00:05:12.900
paths or whatever you have in your
plug-in without having to present

00:05:12.900 --> 00:05:14.980
them separately in an inspector.

00:05:14.980 --> 00:05:17.700
So that's all supported in FxPlug.

00:05:17.700 --> 00:05:20.440
So to get right into it,
we want to show some things that have

00:05:20.480 --> 00:05:24.070
been done with the FxPlug spec before
coming back and talking about some

00:05:24.080 --> 00:05:25.970
of the details of writing your own.

00:05:26.020 --> 00:05:29.480
And to start that out,
we have Ben Syverson from DV Garage.

00:05:29.480 --> 00:05:30.430
Ben Syverson: Hello.

00:05:30.450 --> 00:05:32.320
Hi.

00:05:32.320 --> 00:05:36.250
So I'm just going to show you,
going to show off DVMAT here and just

00:05:36.250 --> 00:05:40.780
talk a little bit about the process
of importing a plug-in which was

00:05:40.830 --> 00:05:44.050
an After Effects plug-in to Motion.

00:05:44.440 --> 00:05:45.050
Okay.

00:05:45.060 --> 00:05:50.980
So let me just play this and
get this loaded up into RAM.

00:05:51.740 --> 00:05:54.590
Okay, so this is our base plate.

00:05:54.590 --> 00:05:58.760
Let's go ahead and turn on DVMap Blast.

00:05:58.760 --> 00:06:02.060
Actually what I'm going to do is
delete this from the stack and add

00:06:02.070 --> 00:06:04.100
it so you can see how easy it is.

00:06:04.100 --> 00:06:09.720
Alright, okay, hang on.

00:06:18.630 --> 00:06:21.600
Okay,
now what we do is just pick a high color.

00:06:21.600 --> 00:06:25.700
This is all pretty even.

00:06:25.760 --> 00:06:29.220
Pick a low color of the screen,
which might be down here.

00:06:30.710 --> 00:06:33.490
Switch this over, and there you go.

00:06:33.660 --> 00:06:37.970
And this is, you know, HDV footage,
this is running in, well,

00:06:38.410 --> 00:06:40.540
pretty close to real time here.

00:06:40.540 --> 00:06:45.280
If we turn this off, which we don't need,
we can get up to, you know,

00:06:45.490 --> 00:06:48.540
30 frames a second on
HDV footage keying in real time,

00:06:48.540 --> 00:06:51.590
which is, you know,
just something you would not

00:06:51.590 --> 00:06:54.220
be able to do in software,
and probably something you'd

00:06:54.220 --> 00:06:57.450
have to spend about $200,000
for about six months ago,

00:06:57.450 --> 00:06:57.780
so.

00:06:59.780 --> 00:07:03.210
So yeah, this is, well,
let me show you some of the

00:07:03.210 --> 00:07:04.940
sort of features of DVMAT.

00:07:04.980 --> 00:07:07.940
Switch this over to Primat RT,
which is a built-in real

00:07:07.950 --> 00:07:09.320
time keyer in Ocean.

00:07:09.320 --> 00:07:12.310
And if we zoom in,
you can kind of see some of these

00:07:12.310 --> 00:07:17.500
artifacts on the side of her face,
and sort of down by the shoulder.

00:07:17.500 --> 00:07:21.240
If I switch back to DVMAT,
you should be able to see.

00:07:21.240 --> 00:07:23.740
It's, you know,
it's doing it pretty clean.

00:07:23.790 --> 00:07:30.710
So, yeah, I came to FXplug without any
OpenGL programming experience,

00:07:30.770 --> 00:07:35.880
and without any, you know,
you make these ARB fragment programs,

00:07:35.880 --> 00:07:38.440
which are, you know,
sort of pseudo-assembly

00:07:38.460 --> 00:07:42.780
for the graphics card,
and I had no experience with that either.

00:07:42.780 --> 00:07:45.680
You know,
I just have done strictly software,

00:07:45.680 --> 00:07:47.880
you know, only image processing.

00:07:47.880 --> 00:07:53.210
And within a couple of days,
also I had no Cocoa experience,

00:07:53.250 --> 00:07:56.270
and within a couple of days,
I was able to get, you know,

00:07:56.270 --> 00:08:00.810
basically this version of DVMAT going,
just by, you know,

00:08:00.830 --> 00:08:05.250
sort of figuring out what, you know,
how you make that sort

00:08:05.280 --> 00:08:08.780
of mental mapping from,
you know, going pixel to pixel,

00:08:08.850 --> 00:08:12.390
to doing sort of, you know,
processes that go,

00:08:12.510 --> 00:08:13.720
that take in entire images.

00:08:13.910 --> 00:08:16.680
And so, you know, I think that's kind of

00:08:16.930 --> 00:08:21.830
So yeah, it was a really fun experiment,
and obviously I'm very

00:08:21.830 --> 00:08:23.340
pleased with the results.

00:08:23.450 --> 00:08:26.520
This same frame rendering in the
software version of DVMAT takes anywhere

00:08:26.990 --> 00:08:28.900
from two to four seconds to render.

00:08:28.900 --> 00:08:33.100
So now it's going at 30 frames a second,
which is, as a developer,

00:08:33.100 --> 00:08:36.980
it's just so gratifying to see
your stuff running that quickly.

00:08:36.980 --> 00:08:40.510
You have to spend a little
bit more time developing,

00:08:40.510 --> 00:08:45.600
but once you get over that hump,
you realize this is where you want to be.

00:08:46.800 --> 00:08:48.650
It's very exciting,
and now I'm going to pass

00:08:48.650 --> 00:08:52.200
you off to Pete Warden,
the graphics wizard from

00:08:52.420 --> 00:08:53.750
Apple's Motion team.

00:08:55.620 --> 00:08:56.190
Yeah, thanks, Ben.

00:08:56.200 --> 00:08:57.370
Thanks, Ben.

00:08:59.740 --> 00:09:04.500
So I'm just going to give you a little
idea of some of the variety of things

00:09:04.500 --> 00:09:07.820
that you can actually do using FXplug.

00:09:07.820 --> 00:09:10.130
Since we are just opening
up the whole of OpenGL,

00:09:10.130 --> 00:09:13.210
I'm just going to show you
another plug-in from another

00:09:13.210 --> 00:09:17.720
third-party developer,
somebody who's been active in other image

00:09:17.760 --> 00:09:24.100
processing apps and has been porting
over-- Boris has been porting over their

00:09:24.100 --> 00:09:28.260
filters to using the FXplug architecture.

00:09:28.260 --> 00:09:31.440
So you can see here,

00:09:31.860 --> 00:09:34.800
You can imagine anybody who's got any
OpenGL experience will know that this

00:09:34.800 --> 00:09:41.130
is very straightforward just to do
this sort of 3D rendering as long as

00:09:41.130 --> 00:09:43.840
you've just got an OpenGL context.

00:09:43.840 --> 00:09:48.810
You can see the sort of speed,
we're running at 30 frames a second.

00:09:48.810 --> 00:09:53.000
And doing these sort of like
3D effects running in Motion,

00:09:53.060 --> 00:09:56.490
because we're just giving you an
OpenGL context to render into,

00:09:56.490 --> 00:10:00.000
you can use all of the
OpenGL rendering capabilities.

00:10:00.040 --> 00:10:06.380
And so you can get these sort of 3D
filters and any 3D effects that you

00:10:06.430 --> 00:10:11.940
can imagine really doing using OpenGL,
you can do as FxPlug filters.

00:10:11.950 --> 00:10:14.450
And I'm really excited to be seeing
some of the stuff that people

00:10:14.450 --> 00:10:16.980
are going to be coming out with,
and some of the stuff that

00:10:16.980 --> 00:10:18.350
we've been seeing already.

00:10:18.420 --> 00:10:23.190
Okay,
I'll pass back to Dave for the slides.

00:10:24.300 --> 00:10:27.990
Okay, so you've seen what you can do,
and now we'll talk about

00:10:27.990 --> 00:10:29.990
how you go about it.

00:10:32.480 --> 00:10:35.510
There are five basic steps
in writing your own fx plug.

00:10:35.520 --> 00:10:38.680
And at the very top level,
those things are choosing

00:10:38.700 --> 00:10:40.900
an Xcode template,
which in order to make

00:10:41.010 --> 00:10:45.410
this an easy transition,
we've shipped two Xcode templates

00:10:45.460 --> 00:10:47.460
that make it easy to get started.

00:10:47.460 --> 00:10:49.360
One is a filter, and one's a generator.

00:10:49.360 --> 00:10:51.800
And it's not very much
code to start out with,

00:10:51.800 --> 00:10:55.300
so it's really a matter of taking
your code and putting it in there.

00:10:55.300 --> 00:11:01.350
Next thing you need to do is edit
the unique IDs in the Info.plist.

00:11:02.420 --> 00:11:04.880
If you don't do that,
your plugins will probably...

00:11:04.990 --> 00:11:07.370
One plugin that you write will
conflict with another one,

00:11:07.400 --> 00:11:08.840
so you need to follow that step.

00:11:08.900 --> 00:11:10.150
It's an easy thing to forget to do.

00:11:10.160 --> 00:11:14.690
And you'll need to
customize the source code,

00:11:14.710 --> 00:11:16.020
of course.

00:11:16.040 --> 00:11:20.120
If you've got an existing C function,
you can just call that as a first pass.

00:11:20.120 --> 00:11:25.210
Ideally, of course,
you'd implement an OpenGL path as well.

00:11:27.990 --> 00:11:36.590
The other part of customizing your source
code is to edit the parameter list.

00:11:36.950 --> 00:11:40.660
The render method that you edit,
that you change,

00:11:40.670 --> 00:11:43.480
there's one or two render methods.

00:11:43.480 --> 00:11:48.060
You may either implement a
hardware path or a software path,

00:11:48.060 --> 00:11:48.890
or both.

00:11:49.170 --> 00:11:52.460
And finally,
you build and install and test

00:11:52.460 --> 00:11:54.530
in the Motion application.

00:11:54.660 --> 00:11:57.870
So, to sort of step you through that,
you go to one of these two,

00:11:57.890 --> 00:12:03.050
the FxPlug Filter or
FxPlug Generator templates.

00:12:03.110 --> 00:12:04.770
Choose that.

00:12:06.660 --> 00:12:14.110
So, we'll start with the project.

00:12:14.110 --> 00:12:14.110
We'll change the name,
and that will change the name of the

00:12:14.110 --> 00:12:14.110
project and the resulting plug-in,
and all that kind of thing.

00:12:14.200 --> 00:12:37.100
[Transcript missing]

00:12:38.370 --> 00:12:44.970
Now, editing the unique IDs is a bit
tedious because you have to go

00:12:44.970 --> 00:12:50.550
to the terminal to enter... to
type UUID gen to make it UUID.

00:12:50.750 --> 00:12:54.180
So, I recommend creating an Xcode script.

00:12:54.180 --> 00:12:58.050
This isn't installed by
the Fxplug SDK installer,

00:12:58.050 --> 00:13:01.830
but it's pretty easy to do,
and the documentation

00:13:01.860 --> 00:13:02.860
explains how to do it.

00:13:02.860 --> 00:13:06.460
It's a file that contains
texts that you can,

00:13:06.460 --> 00:13:10.180
I believe, copy out of the documentation.

00:13:10.180 --> 00:13:14.960
And it basically just issues the UUID gen
command and pastes it into your text.

00:13:14.960 --> 00:13:18.660
So you select one of the existing UUIDs,
and in this case,

00:13:18.660 --> 00:13:24.690
it's set up to be command shift U,
and it will type in a new UUID for you.

00:13:24.900 --> 00:13:30.440
So when you open up the info P list,
you need to change two UUIDs.

00:13:30.560 --> 00:13:33.690
One is the ID of the plugin itself.

00:13:33.700 --> 00:13:37.640
And the other is the idea of the
group that the plugin falls into.

00:13:37.640 --> 00:13:40.910
And those are groups like normally
you would use like the name of your

00:13:40.910 --> 00:13:43.030
company or product line as the group.

00:13:43.100 --> 00:13:45.690
It could be blurs or stylized
or something like that.

00:13:46.380 --> 00:13:48.880
And you define what group
you're going to appear in,

00:13:48.880 --> 00:13:53.030
your plugin will appear in,
with the dictionary

00:13:53.030 --> 00:13:56.400
inside the info P list.

00:13:56.400 --> 00:13:59.740
So in addition to editing
the UUID of the group,

00:13:59.740 --> 00:14:02.860
you also need to edit
that for the plugin.

00:14:02.860 --> 00:14:04.480
Now there are two UUIDs in the plugin.

00:14:04.480 --> 00:14:06.600
One of them identifies the plugin itself.

00:14:06.600 --> 00:14:09.680
And the other points back to the group.

00:14:09.780 --> 00:14:12.300
So you need to use a copy
of the group UUID there.

00:14:13.640 --> 00:14:17.940
Fortunately,
there's comments right in the info.p

00:14:17.950 --> 00:14:21.080
list that sort of step you through that.

00:14:21.130 --> 00:14:23.180
Customizing the source code, of course,
is very simple.

00:14:23.180 --> 00:14:25.060
It takes about six seconds,
as you can see.

00:14:25.160 --> 00:14:29.340
Taking the filter and editing it.

00:14:29.350 --> 00:14:30.740
What could be easier?

00:14:30.830 --> 00:14:34.090
Seriously, the editing,
we'll go into that in more detail,

00:14:34.110 --> 00:14:37.770
but if you have an existing algorithm,
the first pass of doing this

00:14:37.770 --> 00:14:39.510
is really straightforward.

00:14:39.590 --> 00:14:45.130
If it's just a C function that renders
a frame or that filters a frame.

00:14:45.200 --> 00:14:49.400
The next step of moving to OpenGL,
of course, depending on your algorithm,

00:14:49.400 --> 00:14:52.790
it could be impossible or
difficult or very easy.

00:14:54.170 --> 00:14:57.920
The next step of
building/installing your plug-in,

00:14:57.990 --> 00:15:00.080
I have another tip for
doing the installation,

00:15:00.080 --> 00:15:02.940
which you're probably using in your own
plug-ins if you're writing plug-ins now,

00:15:03.000 --> 00:15:09.650
which is just to create a SIM link that
points from the FXPlug folder into the

00:15:09.650 --> 00:15:16.000
place where your built products go and
just do that once using a line like this.

00:15:16.000 --> 00:15:17.460
This is also in the documentation.

00:15:17.740 --> 00:15:22.660
But the plug-ins go into
library/plugins/fxplug or your home

00:15:22.660 --> 00:15:25.930
directory library/plugins/fxplug.

00:15:26.350 --> 00:15:29.100
And that's where
Motion will look for those.

00:15:29.130 --> 00:15:31.680
And finally, the next time you launch
Motion after building,

00:15:31.680 --> 00:15:35.490
assuming that that link is in place,
you'll just be able to test

00:15:35.570 --> 00:15:40.300
your plug-in and step through
it and put breakpoints in,

00:15:40.300 --> 00:15:41.400
and so on.

00:15:42.750 --> 00:15:46.160
Now, to the details of that one step
that I kind of glossed over

00:15:46.170 --> 00:15:49.580
about editing your source code.

00:15:49.580 --> 00:15:52.300
An FxPlug is a type of ProPlug.

00:15:52.380 --> 00:15:56.060
And ProPlug is a generic plug-in
architecture that we've developed

00:15:56.060 --> 00:16:01.570
in ProApps that is an extension
of CFBundle and NSBundle.

00:16:01.600 --> 00:16:07.780
And we developed this so that we
could support dynamic as well as

00:16:07.780 --> 00:16:13.530
static plug-in registration and
add support for host APIs that

00:16:13.530 --> 00:16:15.190
can be retrieved from a plug-in.

00:16:15.310 --> 00:16:20.000
This is similar to a callback suite
in some of the legacy plug-in specs.

00:16:20.000 --> 00:16:25.800
And the host APIs might be available
in one host app but not in another one,

00:16:25.800 --> 00:16:29.990
so this lets you request an
API that you might be able to use.

00:16:30.480 --> 00:16:40.310
ProPlug helps you with that.

00:16:40.310 --> 00:16:40.310
It has some support for
retrieving host APIs.

00:16:41.170 --> 00:16:46.060
The way Proplug is designed,
most of what we do is with protocols.

00:16:46.060 --> 00:16:51.140
We define protocols that you implement,
and we define protocols that a host app

00:16:51.150 --> 00:16:54.100
implements in a Proplug architecture.

00:16:54.100 --> 00:16:59.440
And so FxPlug itself defines
two basic plug-in protocols,

00:16:59.440 --> 00:17:03.100
one for a filter and one for a generator.

00:17:03.100 --> 00:17:05.320
You would implement those,
implement a class that

00:17:05.320 --> 00:17:07.100
conforms to those protocols.

00:17:07.230 --> 00:17:10.480
And the host app provides,
there are a few different

00:17:10.650 --> 00:17:12.080
host app protocols.

00:17:12.150 --> 00:17:15.100
There are some for
creating parameter lists,

00:17:15.100 --> 00:17:21.090
one for retrieving parameter
values or setting parameter values,

00:17:21.090 --> 00:17:22.020
and so on.

00:17:22.020 --> 00:17:24.490
And we'll talk more about those.

00:17:27.750 --> 00:17:34.450
ProPlug is defined in the
Plugin Manager framework.

00:17:34.450 --> 00:17:39.040
The Plugin Manager framework
is very simple.

00:17:39.040 --> 00:17:44.300
There are only two
protocols defined in it.

00:17:44.300 --> 00:17:46.200
One of them is for doing
dynamic registration.

00:17:46.200 --> 00:17:50.740
If you're just going to put
your plug-ins into a bundle,

00:17:50.740 --> 00:17:55.770
which is the normal course,
you don't need to use the dynamic

00:17:55.770 --> 00:17:57.220
registration protocol at all.

00:17:57.770 --> 00:18:00.280
You can simply ignore it.

00:18:00.650 --> 00:18:05.710
If you are going to use it,
then you need to

00:18:05.900 --> 00:18:09.650
You might use dynamic registration if
you wanted to look for certain conditions

00:18:09.660 --> 00:18:11.830
before deciding whether to load plug-ins.

00:18:11.920 --> 00:18:14.450
If you wanted to only load some
of the plug-ins in your bundle,

00:18:14.450 --> 00:18:17.090
that kind of thing,
you have multiple plug-ins in a bundle.

00:18:17.420 --> 00:18:25.630
And of course the plugin manager defines
a protocol for retrieving host APIs in

00:18:25.630 --> 00:18:29.260
the pro API accessing header file.

00:18:32.200 --> 00:19:43.100
[Transcript missing]

00:19:46.820 --> 00:19:51.890
If you're doing dynamic registration,
there are five different

00:19:51.890 --> 00:19:55.180
methods that you can use to

00:19:55.600 --> 00:20:08.100
[Transcript missing]

00:20:08.920 --> 00:20:11.540
So, host APIs.

00:20:11.550 --> 00:20:15.700
To get a host API you need
to first get the API manager,

00:20:15.700 --> 00:20:20.320
and when your plug-in's
principal class is initialized,

00:20:20.320 --> 00:20:25.020
it will be initialized with
an initWithAPIManager method.

00:20:25.020 --> 00:20:32.060
And that passes in an object that
conforms to the pro-API accessing

00:20:32.520 --> 00:20:39.690
Dave Howell, Pete Warden,
and Dave Howell, Pete Warden,

00:20:39.690 --> 00:20:39.690
and Dave Howell,

00:20:40.900 --> 00:20:46.070
So once you have the API manager around,
you can then use the

00:20:46.070 --> 00:20:50.900
APIForProtocol method,
give it the name of the protocol,

00:20:50.900 --> 00:20:54.300
and get back the protocol that
you want to use from the API.

00:20:54.300 --> 00:20:58.100
In this case, we're getting the one for
retrieving values of parameters.

00:20:58.100 --> 00:21:03.400
And we then call-- excuse me-- we
then call a method GetFloatValue,

00:21:03.400 --> 00:21:07.740
which is one of the methods
defined by this protocol.

00:21:07.740 --> 00:21:11.640
You'll see more of that
as the session goes on.

00:21:11.640 --> 00:21:15.560
Now, the FXPlug SDK-- once you
understand the ProPlug bit,

00:21:15.560 --> 00:21:19.740
the FXPlug itself, the SDK is--

00:21:19.870 --> 00:21:23.680
Each of these things I've
listed here is a header,

00:21:23.680 --> 00:21:27.400
and there's one for the FX filter
and one for the FX generator,

00:21:27.400 --> 00:21:33.230
which are the primary protocols that you
would conform to to implement a plug-in.

00:21:33.640 --> 00:21:37.950
The next thing that you might
or might not use is on-screen

00:21:38.480 --> 00:21:42.360
controls and custom parameter UI.

00:21:44.480 --> 00:21:48.230
And the host APIs that you
might want to retrieve and use,

00:21:48.230 --> 00:21:52.240
you'll always use the parameter
API header for creating,

00:21:52.250 --> 00:21:54.540
setting, and getting parameter values.

00:21:54.540 --> 00:21:57.440
You might use the optional
parameter API if you're doing

00:21:57.480 --> 00:22:00.700
certain kinds of parameters,
if you're using histograms

00:22:00.700 --> 00:22:02.520
or gradients specifically.

00:22:02.520 --> 00:22:05.100
And of course you might
do on-screen controls,

00:22:05.100 --> 00:22:07.170
you would get the host API for that.

00:22:07.290 --> 00:22:10.070
And you might want to do re-timing,
in which case you would

00:22:10.070 --> 00:22:11.590
use the temporal image API.

00:22:11.640 --> 00:22:14.680
There's a layer info API,
which is very simple just for getting

00:22:14.680 --> 00:22:17.870
position information about an input.

00:22:18.350 --> 00:22:21.640
And in addition to all those protocols,
we also define a class.

00:22:21.750 --> 00:22:24.590
So creating parameters.

00:22:26.910 --> 00:22:32.660
Your plugin needs to implement
a method called Add Parameter.

00:22:32.660 --> 00:22:37.820
Add Parameters, excuse me,
that's defined in both FX filter

00:22:37.820 --> 00:22:39.180
and FX generator protocol.

00:22:39.180 --> 00:22:44.040
And it will be called when
your plugin is instantiated.

00:22:44.040 --> 00:22:49.260
It will use the FX parameter
creation API to add each parameter.

00:22:49.260 --> 00:22:52.410
And there's a method for each different
kind of parameter that you would add.

00:22:52.420 --> 00:22:54.510
And you can see here we're
adding a floating point slider

00:22:54.510 --> 00:22:55.730
and then a point parameter.

00:22:56.340 --> 00:22:59.320
And I'll go through each of
the types of parameters that

00:22:59.340 --> 00:23:01.260
you can create very briefly.

00:23:01.260 --> 00:23:03.880
Here's the floating point slider.

00:23:05.540 --> 00:23:07.360
This is the way it
looks in the inspector.

00:23:07.390 --> 00:23:11.400
Of course, you can also animate most of
these in the timeline as well,

00:23:11.570 --> 00:23:14.550
and see them in the dashboard.

00:23:15.120 --> 00:23:18.930
So this long method here is what
you use to add a floating point

00:23:18.930 --> 00:23:21.330
slider to your parameter list.

00:23:22.960 --> 00:23:26.180
You can add an integer slider,
which is the same thing obviously,

00:23:26.180 --> 00:23:27.160
but integers.

00:23:27.250 --> 00:23:31.090
You can add a checkbox,
which we call a toggle button.

00:23:33.720 --> 00:23:38.600
And an angle slider,
which lets you define,

00:23:38.600 --> 00:23:42.960
like the other ones,
a minimum and maximum angle and

00:23:42.960 --> 00:23:45.450
the default value and so on.

00:23:45.460 --> 00:23:49.020
I haven't mentioned this,
there's a parameter flags value

00:23:49.020 --> 00:23:52.170
that you can pass in to set
characteristics of each parameter,

00:23:52.180 --> 00:23:57.550
like whether it's visible or if it's
enabled or if it's to be saved or

00:23:57.550 --> 00:24:00.870
not saved when a project is saved.

00:24:01.760 --> 00:24:05.190
If it's to be suppressed or
included in the dashboard and

00:24:05.860 --> 00:24:10.480
whether it has custom UI or not
and a few other flags like that.

00:24:12.390 --> 00:24:17.350
You can add an RGB color
or an RGB color with alpha.

00:24:19.890 --> 00:24:22.820
And a 2D point here, this is shown open.

00:24:22.940 --> 00:24:26.980
The 2D point is an interesting
one because it automatically

00:24:26.980 --> 00:24:29.970
is given on screen controls.

00:24:32.100 --> 00:24:34.700
And of course a pop-up menu.

00:24:34.700 --> 00:24:40.100
In this case the default
value is an index,

00:24:40.100 --> 00:24:46.880
and the menu entries is an array
of strings for the menu items.

00:24:47.960 --> 00:24:53.460
And you can create an image well that
a user can drag images or movies into.

00:24:57.110 --> 00:24:59.850
Now the most interesting
one is the custom parameter.

00:24:59.880 --> 00:25:04.710
Two things you should keep
distinct is custom parameters

00:25:04.770 --> 00:25:06.180
and custom parameter UI.

00:25:06.320 --> 00:25:10.840
You can create a custom
parameter with no UI at all.

00:25:10.890 --> 00:25:15.870
It can be completely hidden,
and it might have its values set by

00:25:15.870 --> 00:25:21.800
something about external conditions,
or it might have its values

00:25:21.800 --> 00:25:21.800
set by an on-screen control.

00:25:22.130 --> 00:25:23.780
But it doesn't need to have a custom UI.

00:25:23.780 --> 00:25:27.240
I think in most cases it would,
but you can think of a lot of uses for

00:25:27.240 --> 00:25:29.890
a custom parameter with no UI at all.

00:25:29.940 --> 00:25:34.550
In this case,
you can see because there's no explicit

00:25:34.900 --> 00:25:40.890
support for a text-type parameter,
you can create a custom

00:25:40.890 --> 00:25:44.140
parameter that does text.

00:25:44.140 --> 00:25:49.040
And then you can completely control
how it works because you're creating

00:25:49.040 --> 00:25:51.220
an NS text edit view control.

00:25:51.220 --> 00:25:57.630
So you can respond to the methods in that
view in its controller however you want.

00:25:57.640 --> 00:25:59.210
You can limit the length.

00:25:59.280 --> 00:26:05.100
You can add features for capitalizing
or not capitalizing or whatever.

00:26:06.820 --> 00:26:13.090
Next we have the group parameter,
which is not really a parameter,

00:26:13.090 --> 00:26:14.780
but it does have a name.

00:26:14.860 --> 00:26:21.770
It's the way you create a hierarchy of
parameters in your add parameters method.

00:26:21.770 --> 00:26:21.770
And the group

00:26:21.900 --> 00:26:40.500
[Transcript missing]

00:26:42.480 --> 00:26:45.580
And I'm going to gloss over the
gradients and histograms because

00:26:45.580 --> 00:26:49.200
we'll talk about them more in the
FxPlug in-depth session tomorrow.

00:26:49.200 --> 00:26:54.170
But you can create a
gradient or a histogram.

00:26:55.190 --> 00:27:00.540
Now to get a value of a parameter,
you use the FX parameter retrieval API.

00:27:00.620 --> 00:27:03.690
So you go to the API manager
and request that parameter,

00:27:03.780 --> 00:27:06.590
and then call a method
to get a parameter value.

00:27:06.640 --> 00:27:11.330
You might do this in your render method,
you might do it in response to an

00:27:11.330 --> 00:27:16.150
action in one of your custom views,
or to an on-screen control.

00:27:19.260 --> 00:27:23.670
And likewise, setting values is done by
the FX Parameter Setting API,

00:27:23.670 --> 00:27:29.690
and there's one method for
each kind of parameter.

00:27:31.860 --> 00:27:34.660
Now we want to talk about
how you do rendering,

00:27:34.730 --> 00:27:38.700
and I'm going to hand off again to
Pete Warden from the Motion team.

00:27:41.850 --> 00:27:42.200
Thanks Dave.

00:27:42.200 --> 00:27:43.960
Okay, well,
I'm actually one of the engineers who's

00:27:44.030 --> 00:27:50.700
worked on a whole bunch of the filters
that we use internally to motion.

00:27:50.880 --> 00:27:56.690
So what I'm going to be talking about
now is OpenGL rendering specifically.

00:27:56.690 --> 00:28:00.700
The CPU based rendering will be
very familiar to anybody who's

00:28:00.700 --> 00:28:02.700
ever had to deal with a bitmap.

00:28:02.940 --> 00:28:07.700
But the OpenGL rendering
is a bit of a new world.

00:28:07.700 --> 00:28:09.700
It's really not something
that anybody else is doing.

00:28:09.700 --> 00:28:13.700
So there's an awful lot to talk
about as far as the details.

00:28:13.700 --> 00:28:19.700
And a lot of those I'll be going into
tomorrow in the FxPlug in depth talk.

00:28:19.700 --> 00:28:23.240
But I just want to give you
like a whistle stop tour of the

00:28:23.240 --> 00:28:27.690
fundamentals of how the rendering
works in OpenGL with FxPlug.

00:28:27.700 --> 00:28:31.890
But also, just before I do that,
I just want to do a little

00:28:31.890 --> 00:28:37.640
bit of evangelization for
doing these OpenGL FxPlugs.

00:28:37.710 --> 00:28:39.610
It really is a hell of a lot of fun.

00:28:39.710 --> 00:28:48.700
We've done 60 or 70 in Motion,
and just seeing the speed increases,

00:28:48.700 --> 00:28:52.940
as Ben's example shows,
going from like one frame every two or

00:28:52.970 --> 00:28:58.550
three seconds up to 30 frames a second
really is something astonishing to see.

00:28:58.700 --> 00:29:01.830
But also,
what I think is really exciting is

00:29:01.830 --> 00:29:06.740
the kind of new possibilities that
actually having OpenGL rendering

00:29:06.740 --> 00:29:08.340
being in there opens up.

00:29:08.760 --> 00:29:13.470
Could everybody who's actually
an OpenGL programmer who knows

00:29:13.470 --> 00:29:17.700
some OpenGL put their hands up,
just so I get an idea?

00:29:17.950 --> 00:29:21.240
Now, if you imagine,
I'm sure a lot of you guys have

00:29:21.240 --> 00:29:26.290
got your favorite little effects
or demo effects or just little,

00:29:26.290 --> 00:29:29.590
you know, sort of maybe a couple of
screens of code that really

00:29:29.600 --> 00:29:31.660
does something that looks cool.

00:29:31.870 --> 00:29:35.670
But there really isn't, you know,
you can't write a game just

00:29:35.670 --> 00:29:37.700
to put that effect in there.

00:29:37.700 --> 00:29:39.720
You know,
you can put demos out on the web,

00:29:39.720 --> 00:29:42.640
and you know, we do see an awful lot
of cool stuff out there.

00:29:42.730 --> 00:29:46.700
But there's going to be 350,000
people paying customers.

00:29:46.700 --> 00:29:51.700
Who may well get very excited
by seeing those effects.

00:29:51.700 --> 00:29:54.140
You know,
they aren't people who necessarily

00:29:54.140 --> 00:29:55.700
look at all the demo stuff.

00:29:55.700 --> 00:30:00.560
So even stuff that you might not
really think much of yourself,

00:30:00.760 --> 00:30:03.700
people get very excited to see that.

00:30:03.700 --> 00:30:06.000
So there really is some
very strong reasons to be

00:30:06.000 --> 00:30:07.680
writing these effects plugs.

00:30:07.780 --> 00:30:10.770
And we're already seeing an awful
lot of really cool stuff coming

00:30:10.770 --> 00:30:12.700
out of the third-party developers.

00:30:12.700 --> 00:30:15.700
So I just really want to encourage
you to really think hard about it.

00:30:15.710 --> 00:30:19.700
And I encourage you to really think
hard about doing effects plugs.

00:30:19.710 --> 00:30:21.700
Okay.

00:30:21.700 --> 00:30:23.020
So.

00:30:23.400 --> 00:30:27.380
How do you write a filter
that runs on the GPU?

00:30:27.380 --> 00:30:33.580
The real cornerstone of everything
that we're doing in Motion is the

00:30:33.580 --> 00:30:37.790
ARB fragment program extension.

00:30:38.630 --> 00:30:41.930
As you can see,
we've just got an example here.

00:30:41.940 --> 00:30:49.470
It's a pseudo-assembly language
that runs per pixel on the GPU.

00:30:49.800 --> 00:30:55.230
It's supported on all the graphics
cards that ship with the G5s,

00:30:55.230 --> 00:31:01.720
and is supported by pretty
much most Apple hardware.

00:31:01.720 --> 00:31:07.740
Increasingly, most people out there with
Macs will be able to run this,

00:31:07.780 --> 00:31:13.090
and that's going to be
increasing as time goes on.

00:31:13.860 --> 00:31:21.180
So you write one of these per pixel,
sort of pixel shaders.

00:31:21.180 --> 00:31:27.620
And then you just use the
GL calls to actually bind it.

00:31:27.620 --> 00:31:35.150
And then all you do is we pass you
an OpenGL context that you end up

00:31:35.150 --> 00:31:41.280
just drawing a quad with that pixel
shader bound to it and with the input

00:31:41.280 --> 00:31:45.640
texture that we actually give you
also bound to it so that the pixel

00:31:45.640 --> 00:31:50.130
shader operates on that texture,
does its processing on those

00:31:50.260 --> 00:31:55.110
pixels that we pass into you,
and then you end up drawing the

00:31:55.360 --> 00:31:58.820
results into the output screen.

00:31:59.220 --> 00:32:01.440
It really is very, very simple.

00:32:01.500 --> 00:32:04.140
You can have,
I think the example template

00:32:04.140 --> 00:32:09.690
is maybe a screen of code for
the actual render function.

00:32:09.910 --> 00:32:14.150
And anybody who's familiar with
OpenGL should really find it very easy.

00:32:14.200 --> 00:32:17.120
There's no viewport setting
up or anything else like

00:32:17.180 --> 00:32:19.390
that that you need to do.

00:32:20.310 --> 00:32:24.910
I'm just going to briefly cover
the different classes that we

00:32:24.990 --> 00:32:28.300
give you for passing the image
information back and forth.

00:32:28.300 --> 00:32:33.250
FxImage is the fundamental
building block of this.

00:32:33.340 --> 00:32:37.270
All it's got in it really is get width,
get height,

00:32:37.330 --> 00:32:41.300
some information on the depth,
and the fundamental image attributes.

00:32:41.300 --> 00:32:46.040
And then we have FX texture,
which just builds on top of that.

00:32:46.040 --> 00:32:51.640
And it really isn't very much
above and beyond an OpenGL texture.

00:32:51.640 --> 00:32:56.820
It has the texture coordinates
in there that you need to use,

00:32:56.820 --> 00:33:01.160
and not really that much else.

00:33:01.160 --> 00:33:03.820
It isn't a big utility class.

00:33:03.820 --> 00:33:10.820
And the RAM-based version
of that is FX bitmap.

00:33:11.530 --> 00:33:17.720
And anybody who's ever used
a CPU-based bitmap class will

00:33:17.720 --> 00:33:19.540
feel very comfortable with this.

00:33:19.540 --> 00:33:23.640
You can get the data,
and you can manipulate it, and yeah,

00:33:23.890 --> 00:33:24.760
that's about it.

00:33:27.340 --> 00:33:32.810
Now we support various
different pixel formats,

00:33:32.810 --> 00:33:36.540
all with alpha, all ARGB.

00:33:36.540 --> 00:33:38.760
That was a deliberate
decision on our part.

00:33:38.760 --> 00:33:42.690
We really didn't want to be
supporting or forcing people to

00:33:42.690 --> 00:33:44.780
support many different pixel formats.

00:33:44.840 --> 00:33:48.380
We just wanted to keep as
few code paths as possible.

00:33:48.380 --> 00:33:55.690
We have the 8, 16 and the 32-bit float
formats that we support.

00:33:55.710 --> 00:34:01.590
All of our bitmaps are actually coming
through as pre-multiplied alpha.

00:34:01.630 --> 00:34:07.040
Our whole pipeline works
using pre-multiplied alpha.

00:34:07.810 --> 00:34:13.330
FX Texture again, like I said,
it's got the texture coordinates

00:34:13.830 --> 00:34:19.700
contained as part of the structure
and you pull those back when you want

00:34:19.700 --> 00:34:22.260
to actually use that texture to draw.

00:34:22.710 --> 00:34:27.790
Now one thing to be careful of is
often the origin is in one corner

00:34:27.790 --> 00:34:33.450
and you can just use the width and
height as the texture coordinates

00:34:33.450 --> 00:34:40.220
and you can skip actually explicitly
asking for the texture coordinates.

00:34:40.220 --> 00:34:43.620
But that gets kind of dangerous
because we do various things,

00:34:43.620 --> 00:34:47.030
especially when we're rendering
at different resolutions,

00:34:47.030 --> 00:34:50.180
for example for preview or if
the user's decided that they

00:34:50.180 --> 00:34:52.170
want to get faster renderings.

00:34:52.440 --> 00:34:57.720
So it's very important,
it will appear to work at first

00:34:57.720 --> 00:35:03.780
if you don't actually get the
coordinates but you really need to

00:35:03.780 --> 00:35:10.670
explicitly check for them if you're
going to have something robust.

00:35:11.750 --> 00:35:16.940
All you do is just call bind and
enable functions on these textures,

00:35:16.940 --> 00:35:21.910
on these FX textures,
just like you would for a GL texture.

00:35:22.050 --> 00:35:25.030
And actually,
you can even get the idea of

00:35:25.030 --> 00:35:30.060
the texture if you want to do
stuff more explicitly than that.

00:35:30.180 --> 00:35:34.660
And these textures, as I said,
all of our pipeline is

00:35:34.750 --> 00:35:36.970
pre-multiplied alpha.

00:35:40.300 --> 00:35:43.300
So, I'm going to pass you back to Dave.

00:35:43.300 --> 00:35:47.300
So, before we go on to the
more information section,

00:35:47.300 --> 00:35:51.550
I just wanted to point out that,
of course, if you've been to the

00:35:51.630 --> 00:35:53.920
Core Image sessions,
you've seen that you can write an image

00:35:53.920 --> 00:35:58.970
unit that can be used as a plug-in,
and is available in Motion,

00:35:58.980 --> 00:36:01.960
and they're great.

00:36:02.040 --> 00:36:06.250
If you want to deploy a plug-in
that works across applications

00:36:06.250 --> 00:36:10.940
from iMovie to Motion,
It's a great way to go unless you need

00:36:10.940 --> 00:36:13.380
some of the specific features that are

00:36:13.940 --> 00:36:17.560
In FxPlug but not in Core Image,
such as the on-screen

00:36:18.170 --> 00:36:22.090
controls or the custom UI.

00:36:22.600 --> 00:36:28.500
[Transcript missing]

00:36:31.400 --> 00:36:40.790
So to get the FxPlug SDK,
there's information on the WWDC website,

00:36:40.810 --> 00:36:45.620
and there's a download,
but it will point you to the developer

00:36:45.650 --> 00:36:50.320
connection where if you go to
connect.apple.com and log in and go to

00:36:50.380 --> 00:36:57.470
downloads and look at Apple applications,
there is a FxPlug SDK 1.0.

00:36:57.480 --> 00:37:03.240
Just download that and it contains an
installer and a documentation folder.

00:37:03.240 --> 00:37:09.130
The documentation folder has
something called the FxPlug Overview,

00:37:09.300 --> 00:37:15.810
and also HTML text documentation
that was generated by HeaderDoc,

00:37:15.890 --> 00:37:18.560
which is not always the
easiest thing to read,

00:37:18.570 --> 00:37:19.800
but it's pretty complete.

00:37:19.800 --> 00:37:23.600
So start with the overview
and then the HeaderDoc stuff

00:37:23.600 --> 00:37:25.730
is a great reference later.

00:37:26.190 --> 00:37:33.460
The installer will give you the
Xcode templates and two examples,

00:37:33.710 --> 00:37:41.400
one of which shows how to write a
filter which uses on-screen controls,

00:37:41.540 --> 00:37:44.120
I'm sorry, custom UI, parameter UI.

00:37:44.120 --> 00:37:51.300
And the other one is a generator that
shows you how to do on-screen controls.

00:37:51.300 --> 00:37:56.010
So it's like the custom,
each of those uses a single

00:37:56.010 --> 00:38:00.000
custom parameter type which
is just a list of points.

00:38:00.000 --> 00:38:01.580
It lets you draw a path.

00:38:01.580 --> 00:38:07.210
One of them lets you draw the path
in a simple view in the inspector,

00:38:07.210 --> 00:38:10.800
and the other one lets you draw
it on-screen on the canvas.

00:38:10.800 --> 00:38:16.130
And each of them is a pretty awful
example of how to write a paint program,

00:38:16.130 --> 00:38:21.010
but maybe you could start with
it and give us something great.

00:38:21.320 --> 00:38:25.770
In addition to the examples, of course,
there's the framework and the

00:38:25.770 --> 00:38:28.200
FxPlug protocols and so on.

00:38:28.330 --> 00:38:30.200
Now, there are two related sessions.

00:38:30.200 --> 00:38:35.840
If you can come out tomorrow,
we have at 10:30 a.m.

00:38:36.050 --> 00:38:40.510
the in-depth session where we'll talk
more about the issues that we didn't

00:38:40.510 --> 00:38:42.200
go into too much depth about today.

00:38:42.280 --> 00:38:46.050
There's also a brown bag lunch after
that that we encourage you to grab

00:38:46.050 --> 00:38:50.550
a lunch downstairs and head up and
meet us on the third floor in the

00:38:50.550 --> 00:38:53.200
Pro Audio and Pro Video connection room.

00:38:53.350 --> 00:38:58.890
We'll just hang out and talk
about FxPlug and what you can do.

00:39:02.900 --> 00:39:07.440
Just as an example of some of
the interesting OpenGL stuff

00:39:07.440 --> 00:39:09.860
that we can actually do,
I'm just going to show off a

00:39:09.870 --> 00:39:11.840
couple of generator effects.

00:39:11.840 --> 00:39:17.510
Just to give some concrete examples
of what I was talking about that

00:39:17.510 --> 00:39:21.950
our users are really interested in,
that I think some of you guys can

00:39:21.960 --> 00:39:25.920
come out with some stuff that will
hopefully be even cooler than this.

00:39:26.050 --> 00:39:31.850
For example, here's...

00:39:32.390 --> 00:39:34.380
and David Koehn.

00:39:35.420 --> 00:39:41.520
So, we have a water core sticks generator
that's done entirely using OpenGL.

00:39:41.520 --> 00:39:47.800
And it's really something that the
software versions are very... It's

00:39:47.800 --> 00:39:51.040
never been something that's been
solved very well in the software space,

00:39:51.140 --> 00:39:55.290
but actually using the OpenGL rendering
engine and doing polygonal

00:39:55.290 --> 00:39:59.520
rendering to actually get this,
it actually turned out

00:39:59.520 --> 00:40:02.810
not to be too tricky.

00:40:02.860 --> 00:40:06.150
And another example is...

00:40:06.440 --> 00:40:10.740
In Motion, we call this Clouds,
but what this actually is,

00:40:10.760 --> 00:40:13.470
is a Perlin noise generator.

00:40:13.870 --> 00:40:19.990
And just written using Fragment programs,

00:40:20.200 --> 00:40:50.800
[Transcript missing]

00:40:52.500 --> 00:40:54.390
So finally,
if you have any other questions,

00:40:54.400 --> 00:40:58.540
if we could go back to the slides.

00:40:58.540 --> 00:41:00.790
Any questions,
you can email Patrick Collins,

00:41:00.810 --> 00:41:04.370
who's the technology manager for
this Apple applications track,

00:41:04.370 --> 00:41:07.850
at patrick@apple.com.

00:41:07.960 --> 00:41:12.350
Or better yet, write to the ProApp SDK.

00:41:12.690 --> 00:41:16.910
Only one, it's not ProApps SDK,
there were some people that got

00:41:16.910 --> 00:41:20.880
the wrong address before and were
getting an email sent somewhere else.

00:41:20.880 --> 00:41:25.180
But ProApp SDK at group.apple.com.

00:41:25.180 --> 00:41:28.730
And a few of us who are involved
in the FxPlug project get those

00:41:28.730 --> 00:41:30.160
emails and will respond to it.

00:41:30.160 --> 00:41:33.270
We don't have a mail list
set up for this just yet.

00:41:33.280 --> 00:41:34.640
We're starting with this.
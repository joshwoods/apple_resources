WEBVTT

00:00:00.190 --> 00:00:01.940
Hi, good afternoon.

00:00:01.940 --> 00:00:05.820
This is Core OS Enhancements
for BSD Developers.

00:00:05.820 --> 00:00:07.500
I'm happy to see you all here today.

00:00:07.500 --> 00:00:10.590
The heckling section is in the front.

00:00:10.700 --> 00:00:15.090
My name is Marc Majka and I'll
be doing a tag team session

00:00:15.160 --> 00:00:18.080
today along with Dave Zarzycki.

00:00:18.220 --> 00:00:19.660
He'll be up in a few minutes.

00:00:19.660 --> 00:00:22.260
We're going to tell you about
a couple of topics that I hope

00:00:22.320 --> 00:00:26.200
you'll find interesting and useful,
the stuff that we've added to Tiger.

00:00:26.200 --> 00:00:30.060
I'm going to start off talking
about the Apple System Logger.

00:00:30.100 --> 00:00:32.990
Let's just get into it.

00:00:33.010 --> 00:00:34.080
What is it?

00:00:34.110 --> 00:00:38.310
This has kind of come in as a fairly
low profile enhancement to Tiger,

00:00:38.400 --> 00:00:43.270
but it's the start of something that
I think will be a useful direction

00:00:43.270 --> 00:00:45.080
for you as developers in the future.

00:00:45.180 --> 00:00:51.100
ASL is a new approach to creating
and managing system log messages.

00:00:51.100 --> 00:00:58.200
It's a replacement for and an
extension to the old BSD syslog system.

00:00:58.400 --> 00:00:59.980
There's several new components.

00:00:59.980 --> 00:01:03.260
There's a new API that I'll be
describing a little bit later.

00:01:03.310 --> 00:01:10.140
There's some behind the scene
changes in the syslog API library.

00:01:10.180 --> 00:01:17.810
There is a rewritten syslogd server
and a new syslog command line utility.

00:01:18.130 --> 00:01:23.790
The goals of this work
were to provide structured,

00:01:23.790 --> 00:01:30.570
flexible, and hopefully more useful
system log messages,

00:01:30.580 --> 00:01:37.090
to try to reduce the proliferation
of log files that you find

00:01:37.090 --> 00:01:37.870
scattered around on the system,
and to make it easier to find

00:01:37.870 --> 00:01:37.870
log file messages and read them.

00:01:38.990 --> 00:01:45.280
Let's start with our starting point,
which is the BSD syslog message system.

00:01:45.420 --> 00:01:50.610
BSD log messages had associated
with them a priority level,

00:01:50.610 --> 00:01:54.530
one of a fixed set of
different facilities,

00:01:54.530 --> 00:01:57.380
and a fixed format of message.

00:01:57.420 --> 00:02:03.980
In the example, a timestamp, a host name,
the sending application's

00:02:03.980 --> 00:02:08.500
name and process ID,
and a piece of message text.

00:02:08.600 --> 00:02:10.250
Pretty basic.

00:02:10.470 --> 00:02:14.460
What we've done with
ASL is extended messages,

00:02:14.470 --> 00:02:18.000
or we've made messages extensible
key value dictionaries.

00:02:18.000 --> 00:02:21.320
Keys and values are just
null terminated strings.

00:02:21.320 --> 00:02:24.340
There are a bunch of standard
keys in every message.

00:02:24.340 --> 00:02:30.580
Things like the priority level,
a time stamp, the sending process ID,

00:02:30.580 --> 00:02:34.440
PID, and the message string.

00:02:34.440 --> 00:02:38.820
But you can add additional keys that
are appropriate to your application.

00:02:39.440 --> 00:02:43.120
So if your application
feels it's useful to attach,

00:02:43.160 --> 00:02:48.440
let's say, a color key to a message or a
language or something like that,

00:02:48.510 --> 00:02:51.940
this is totally up to you and
hopefully to make things more

00:02:51.940 --> 00:02:53.930
useful to your application.

00:02:53.940 --> 00:03:01.400
The little example message at the
bottom shows a typical ASL message.

00:03:01.400 --> 00:03:03.540
The content here is not the big thing.

00:03:03.540 --> 00:03:06.360
The useful feature here
is the message structure.

00:03:08.900 --> 00:03:14.070
Take a quick tour of the ASL APIs,
but before I get into it with the slides,

00:03:14.120 --> 00:03:18.000
let me just mention that your
conference registration includes

00:03:18.000 --> 00:03:21.760
some complete example code that
has a bunch of this stuff in it

00:03:21.760 --> 00:03:23.540
that may be useful to look at.

00:03:23.720 --> 00:03:30.480
I'll also direct you to look at the
online Unix man pages for ASL and

00:03:30.490 --> 00:03:34.200
syslog and a number of associated
components that I think will really help.

00:03:34.310 --> 00:03:40.840
So here's a little example of
just a hello world in the ASL API.

00:03:40.840 --> 00:03:47.260
ASL log is the basic
send a message routine.

00:03:47.260 --> 00:03:52.270
There's a couple of null parameters
at the front here that I'll

00:03:52.270 --> 00:03:54.880
talk about in the next slide.

00:03:54.880 --> 00:03:57.700
We're just using default
messages in this one.

00:03:57.700 --> 00:04:02.000
And basically we're just setting
a priority level debug here

00:04:02.100 --> 00:04:04.180
and a hello world message.

00:04:04.180 --> 00:04:06.920
And off it goes to the syslog server.

00:04:06.920 --> 00:04:12.300
And once again you can see the message
that this actually produces has a

00:04:12.390 --> 00:04:18.000
bunch of this sort of extra or standard
message keys like the timestamp,

00:04:18.000 --> 00:04:20.080
the host name and so on.

00:04:20.340 --> 00:04:24.560
All of which are added into the
message by the library code.

00:04:27.280 --> 00:04:30.140
Here's a little bit more
of a sophisticated example

00:04:30.140 --> 00:04:31.460
of sending a message.

00:04:31.460 --> 00:04:35.120
In this one,
we start off by creating an ASL client.

00:04:35.200 --> 00:04:38.000
It's a connection handle,
a connection to the server.

00:04:38.000 --> 00:04:41.000
In the previous example,
we didn't have one of these,

00:04:41.000 --> 00:04:44.920
and that's sufficient for code that's
single-threaded or that only has one

00:04:45.220 --> 00:04:47.410
thread that actually logs messages.

00:04:47.420 --> 00:04:50.750
If your application has multiple
threads logging messages,

00:04:50.750 --> 00:04:53.760
each of them should have its
own connection handle to the

00:04:53.760 --> 00:04:55.680
server to make them thread-safe.

00:04:56.820 --> 00:05:02.460
We also create a connection handle in the
ASL open call that creates the handle.

00:05:02.660 --> 00:05:03.810
There's a couple of parameters.

00:05:03.920 --> 00:05:08.040
There's a sending process name.

00:05:08.060 --> 00:05:10.560
We've allowed that to be null here,
and it'll just pick up

00:05:10.560 --> 00:05:12.640
your application's name.

00:05:13.030 --> 00:05:14.630
And a facility.

00:05:14.880 --> 00:05:18.740
One of the nice changes in this
ASL system is that facilities

00:05:18.740 --> 00:05:23.900
are no longer hardwired into a
header file somewhere or other.

00:05:24.010 --> 00:05:26.440
A facility is just a string.

00:05:26.440 --> 00:05:29.330
If you're creating a
new suite of utilities,

00:05:29.330 --> 00:05:33.640
application programs that all
kind of work together in some way,

00:05:33.640 --> 00:05:39.020
then you can make up a
facility name and use that.

00:05:39.210 --> 00:05:41.160
You don't have to go edit
anybody's header files,

00:05:41.160 --> 00:05:43.010
or you don't have to recompile anything.

00:05:43.020 --> 00:05:49.240
After opening a connection handle,
this example creates a message,

00:05:49.370 --> 00:05:51.900
an ASL message structure.

00:05:51.900 --> 00:05:55.160
That's actually the key value dictionary.

00:05:55.160 --> 00:05:56.050
It's an opaque structure.

00:05:56.060 --> 00:05:59.600
And in order to set keys and
values in that dictionary,

00:05:59.600 --> 00:06:00.740
you use ASL set.

00:06:00.740 --> 00:06:06.060
Here we're adding a subsystem key and
a language key with appropriate values.

00:06:06.060 --> 00:06:10.610
Once again,
call ASL log to log the message,

00:06:10.690 --> 00:06:18.000
and then clean up with a couple of frees,
a free for the message and a close

00:06:18.000 --> 00:06:22.060
to shut down the connection handle.

00:06:22.060 --> 00:06:24.060
Let's look at the output from this.

00:06:24.060 --> 00:06:25.680
You see, once again,
all of this is in the same way.

00:06:25.680 --> 00:06:25.680
You can see that the output
is the same as the output.

00:06:25.680 --> 00:06:30.600
Once again, all the standard keys and
values set by the library,

00:06:30.750 --> 00:06:36.660
but this message includes the subsystem
and language keys that you set in the

00:06:36.680 --> 00:06:40.680
previous slide in the example code.

00:06:40.680 --> 00:06:44.410
That's about it for that.

00:06:44.800 --> 00:08:37.500
[Transcript missing]

00:08:38.580 --> 00:08:42.170
Here's a search example, the search API.

00:08:42.610 --> 00:08:46.680
Once again,
we open up a connection handle using

00:08:46.700 --> 00:08:50.550
ASL open and once again create a message.

00:08:50.550 --> 00:08:52.400
This message is slightly different.

00:08:52.400 --> 00:08:53.490
This is actually a query.

00:08:53.490 --> 00:08:55.440
It looks a lot like a message.

00:08:55.440 --> 00:08:57.520
Once again,
it's a set of keys and values.

00:08:57.520 --> 00:09:00.850
But in addition to
setting a key and a value,

00:09:00.850 --> 00:09:03.520
you also can supply an operator.

00:09:04.500 --> 00:09:08.720
Operators are things like equal,
not equal, substring, prefix,

00:09:08.720 --> 00:09:11.130
as you might imagine.

00:09:11.320 --> 00:09:14.400
They're all documented in the man pages.

00:09:14.400 --> 00:09:19.650
And in this example,
we're looking for all messages that have

00:09:19.700 --> 00:09:23.950
a key flavor that has a value vanilla,
exactly.

00:09:24.050 --> 00:09:28.010
And we run through the data
store and search for all of

00:09:28.010 --> 00:09:30.640
those with the ASL search call.

00:09:30.640 --> 00:09:34.120
That returns a list that
we can iterate over.

00:09:34.520 --> 00:09:38.510
With ASL response next,
each of those gives us

00:09:38.520 --> 00:09:39.580
a message structure.

00:09:39.690 --> 00:09:44.720
See the example code or the man
pages to look at how you tear apart a

00:09:44.740 --> 00:09:47.870
message structure to get the individual
keys and values that are in it.

00:09:48.060 --> 00:09:50.650
You can print them or compare them
or look at them any way you want.

00:09:51.040 --> 00:09:57.280
Finally, some cleanup to free the
returned iteration list,

00:09:57.510 --> 00:10:02.110
the query message and
shut down the connection.

00:10:03.690 --> 00:10:07.810
It may be a little bit onerous to ask
you to write a new application every time

00:10:07.820 --> 00:10:11.500
you want to go look for log messages,
so we also provided a

00:10:11.500 --> 00:10:16.030
syslog command line utility,
which will do exactly the same thing.

00:10:16.040 --> 00:10:19.020
It has a bunch of
different search options.

00:10:19.020 --> 00:10:22.500
Syslog is a real
Swiss Army knife of a tool.

00:10:22.500 --> 00:10:25.970
It does all kinds of stuff,
so I highly recommend taking a look at

00:10:26.020 --> 00:10:29.610
the man page to see all of the options.

00:10:29.620 --> 00:10:33.030
You can also do syslog-help,
and it prints a reasonably

00:10:33.030 --> 00:10:35.340
useful help message on terminal.

00:10:35.340 --> 00:10:38.220
A few usage examples here.

00:10:38.220 --> 00:10:40.850
Syslog, all by itself,
just prints every message

00:10:40.850 --> 00:10:42.360
that's in the data store.

00:10:42.360 --> 00:10:46.030
Syslog-k, flavor vanilla,
as in this example,

00:10:46.030 --> 00:10:51.390
prints out every message that has a
keyword flavor with a value vanilla,

00:10:51.480 --> 00:10:53.300
as you might expect.

00:10:53.340 --> 00:10:57.540
Syslog-k, facility user.

00:10:57.540 --> 00:10:58.940
Syslog-k, time.

00:10:58.940 --> 00:10:59.600
Syslog-k, time.

00:10:59.620 --> 00:11:02.300
GE minus 1D, what's all that about?

00:11:02.300 --> 00:11:04.820
Well, that's actually searching for
two different keys and values.

00:11:04.820 --> 00:11:08.980
We're searching for all user
facility messages that were

00:11:08.990 --> 00:11:10.820
logged within the last day.

00:11:10.860 --> 00:11:19.120
So GE greater than or equal minus
1D means one day before right now.

00:11:19.120 --> 00:11:21.940
And that's a useful little convention.

00:11:21.940 --> 00:11:24.300
A day is just a 24-hour period.

00:11:24.300 --> 00:11:27.820
It'll take all kinds of different
things like H for hours,

00:11:27.820 --> 00:11:30.860
S for seconds, and so on, M for minutes.

00:11:30.860 --> 00:11:37.040
So if you want to know everything
that happened since a particular time,

00:11:37.040 --> 00:11:40.580
you can also actually give it
an absolute value of seconds,

00:11:40.580 --> 00:11:45.660
and it'll use that too,
but most people don't have a watch

00:11:45.660 --> 00:11:48.420
that gives them the absolute number
of seconds since January 1st,

00:11:48.420 --> 00:11:50.140
whatever, 1969.

00:11:50.140 --> 00:11:54.900
Final example here, syslog-w.

00:11:54.900 --> 00:11:56.760
The dash-w option means watch the data.

00:11:56.820 --> 00:11:57.320
Watch the database.

00:11:57.350 --> 00:12:01.780
Watch the data store and print messages
as they come into the database.

00:12:01.780 --> 00:12:04.430
It gives you a similar
functionality to something like,

00:12:04.430 --> 00:12:07.670
let's say, tail-f of a log file.

00:12:07.680 --> 00:12:09.230
So it keeps watching the data store.

00:12:09.240 --> 00:12:15.640
The dash capital F flag means
that you are supplying a format,

00:12:15.640 --> 00:12:18.160
an output format for the messages.

00:12:18.160 --> 00:12:21.660
It has a couple of default,
or a couple of different formats

00:12:21.660 --> 00:12:23.770
that it can print messages in.

00:12:24.150 --> 00:12:28.890
One's a sort of very much a very
much like the kind of format that

00:12:28.890 --> 00:12:36.030
you might see in a syslog file,
or a system.log file, excuse me.

00:12:36.290 --> 00:12:41.120
It has a couple of different options
for printing out the messages.

00:12:41.120 --> 00:12:45.030
And if you want, you can say, no,
I really only want to know, let's say,

00:12:45.040 --> 00:12:50.240
the time stamp and the sending
process ID and the message text,

00:12:50.300 --> 00:12:52.130
as it is in this example.

00:12:52.450 --> 00:12:55.610
And once again, in this example,
I'm only interested in

00:12:55.610 --> 00:12:59.190
messages that had a,
a level less than or equal to three.

00:12:59.200 --> 00:13:02.300
So fairly high priority messages.

00:13:04.680 --> 00:13:07.280
Let's take a quick look at
the architecture of all of the

00:13:07.440 --> 00:13:09.200
stuff that goes on behind this.

00:13:09.200 --> 00:13:11.480
syslogd is the ASL server.

00:13:11.480 --> 00:13:15.830
It provides both the old syslogd
functionality plus support for

00:13:15.870 --> 00:13:17.660
the new API and the datastore.

00:13:17.660 --> 00:13:22.590
There are input modules that receive
messages on a variety of different

00:13:22.590 --> 00:13:28.700
channels and output modules that sort and
file and forward messages as appropriate.

00:13:28.700 --> 00:13:30.640
We'll take a look at that in a sec.

00:13:31.220 --> 00:13:36.990
There's an API for sending messages,
both the ASL API that we just looked

00:13:36.990 --> 00:13:40.610
at a moment ago and the syslogd APIs.

00:13:40.940 --> 00:13:46.040
Both of those are in the system
framework lib system and the syslogd

00:13:46.180 --> 00:13:49.170
APIs continue to work as they used to.

00:13:49.180 --> 00:13:55.860
And of course there's the kernel printf
which also gets picked up by syslogd.

00:13:56.190 --> 00:14:00.160
API for searching the
data store is in ASL,

00:14:00.420 --> 00:14:03.300
the ASL library.

00:14:03.330 --> 00:14:06.380
And once again,
I mentioned the syslog command

00:14:06.380 --> 00:14:10.260
line tool for searching the data
store and monitoring messages.

00:14:10.300 --> 00:14:12.160
Here's the big picture.

00:14:12.240 --> 00:14:17.460
At the top, a number of different
clients using different APIs,

00:14:17.460 --> 00:14:24.660
either the ASL API,
the kernel using its printf, syslog API,

00:14:24.660 --> 00:14:31.860
or a remote client sending
messages via a UDP datagram from

00:14:32.210 --> 00:14:34.900
somewhere else across the network.

00:14:34.920 --> 00:14:38.190
syslogd listens on all
of those various ports,

00:14:38.190 --> 00:14:43.000
pulls in the messages,
and hands them to various output modules.

00:14:43.000 --> 00:14:48.520
In this case, there's a couple,
an ASL output module and a BSD module,

00:14:48.520 --> 00:14:52.270
both of which do whatever is
appropriate with those messages.

00:14:53.240 --> 00:14:59.260
The ASL module will put
things in the data store.

00:14:59.520 --> 00:15:02.700
It will actually also forward to NotifyD.

00:15:02.760 --> 00:15:04.570
It's kind of a...

00:15:05.700 --> 00:15:08.510
This is a piece of work
that's in development.

00:15:08.510 --> 00:15:11.810
We haven't really done a lot
of documentation on that.

00:15:11.810 --> 00:15:15.210
If you're really interested in it,
I can tell you a bit more

00:15:15.260 --> 00:15:16.830
in the Q&A after this.

00:15:16.910 --> 00:15:20.060
But you can have syslogd
send a notification,

00:15:20.090 --> 00:15:24.230
post a notification using the
notification APIs whenever a

00:15:24.230 --> 00:15:29.590
particular message comes in that
matches a particular search criteria.

00:15:30.720 --> 00:15:37.260
The BSD output module logs things to
all the various log files as it used to.

00:15:37.260 --> 00:15:42.650
It'll send messages to a
terminal as the old one used to.

00:15:42.650 --> 00:15:45.900
And once again,
it will also forward on messages

00:15:45.900 --> 00:15:47.940
to some network log server.

00:15:50.600 --> 00:15:53.130
Let me talk a little bit
about filtering messages,

00:15:53.130 --> 00:15:56.680
because lots of processes
are logging lots of messages,

00:15:56.680 --> 00:16:00.490
can lead to a fairly
large amount of messages.

00:16:00.510 --> 00:16:05.470
So there's some filtering that
you can use to control the flow.

00:16:06.530 --> 00:16:09.600
The client library,
both the syslog library

00:16:09.600 --> 00:16:13.300
and the new ASL library,
contain some filtering controls

00:16:13.420 --> 00:16:17.540
that you can set when you're writing
your applications to determine which

00:16:17.540 --> 00:16:21.390
priority messages actually get sent
from your application to the server.

00:16:21.400 --> 00:16:25.300
If you've used the syslog API,
you're familiar with setlogmask.

00:16:25.660 --> 00:16:32.220
And ASL has a similar filter
to determine which priorities

00:16:32.220 --> 00:16:36.400
actually get through to syslog.

00:16:36.400 --> 00:16:40.290
The server, syslogd,
also has a filter which controls

00:16:40.290 --> 00:16:44.350
which priority of messages
it saves in the datastore.

00:16:44.360 --> 00:16:47.060
So by default, it doesn't save everything
in the datastore.

00:16:47.060 --> 00:16:48.470
You can tell it to if you want.

00:16:48.520 --> 00:16:52.890
By default, it actually ignores debug and
info level messages and stores

00:16:52.950 --> 00:16:55.200
everything else in the database.

00:16:55.200 --> 00:16:59.740
And what's interesting is that we've
added a remote control mechanism on

00:16:59.750 --> 00:17:06.240
top of both of these that allow you
to control the flow of log messages.

00:17:06.400 --> 00:17:11.790
So you can tell an application, hey,
even though I set the logmask to,

00:17:11.790 --> 00:17:15.000
let's say,
filter out certain types of messages,

00:17:15.000 --> 00:17:17.020
now I want to see those messages.

00:17:17.020 --> 00:17:19.160
And you don't have to restart
your application or send

00:17:19.160 --> 00:17:20.480
it any signals or anything.

00:17:20.480 --> 00:17:21.790
All of this happens dynamically.

00:17:21.800 --> 00:17:25.630
Let's take a quick look at that.

00:17:25.890 --> 00:17:29.770
What we've done is modified
the client library,

00:17:29.780 --> 00:17:33.700
both the ASL actually
and the syslog library,

00:17:33.700 --> 00:17:40.630
so that they listen to... notifications
from the syslog command line tool,

00:17:40.630 --> 00:17:42.720
syslog-c in this case.

00:17:42.720 --> 00:17:44.180
Once again, see the man page.

00:17:44.180 --> 00:17:49.610
But you can say to an application,
I want a certain set of log messages

00:17:49.620 --> 00:17:54.500
to be either filtered out or
passed through to syslogd server.

00:17:54.500 --> 00:17:57.270
Likewise,
there's a control on the syslogd

00:17:57.270 --> 00:18:01.600
server for which messages it will
actually put in the datastore.

00:18:01.600 --> 00:18:06.970
And once again,
syslog-c will control... which

00:18:06.970 --> 00:18:10.780
messages get stored in the database.

00:18:11.300 --> 00:20:00.200
[Transcript missing]

00:20:00.870 --> 00:20:04.330
Well, of course, if lots of messages get
saved to the database,

00:20:04.380 --> 00:20:06.020
the database can get large.

00:20:06.020 --> 00:20:11.160
So we need some sort of a pruning
mechanism to get rid of old messages.

00:20:11.160 --> 00:20:15.290
And by default, as I mentioned,
the datastore doesn't save

00:20:15.400 --> 00:20:17.860
info or debug-level messages.

00:20:17.860 --> 00:20:22.430
You can set that as a startup
option for syslogd if you wish,

00:20:22.510 --> 00:20:25.680
or you can use the control mechanism.

00:20:26.960 --> 00:20:30.980
So just by not saving
info and debug messages,

00:20:30.980 --> 00:20:34.570
we actually don't,
the file doesn't grow that fast,

00:20:34.690 --> 00:20:35.620
but it still grows.

00:20:35.620 --> 00:20:40.140
So there's a daily cronscript,
the periodic daily cronscript

00:20:40.140 --> 00:20:42.700
actually prunes the datastore.

00:20:42.700 --> 00:20:47.540
If you look in that file, let's see,
periodic daily 500.daily,

00:20:47.540 --> 00:20:50.660
you'll see where the
datastore gets pruned.

00:20:50.660 --> 00:20:54.430
You can also use syslogd, syslog,
the syslog command line

00:20:54.430 --> 00:20:56.500
utility with the dash P flag.

00:20:56.960 --> 00:20:59.610
Which is all that happens in
the daily script to prune the

00:20:59.610 --> 00:21:01.620
datastore anytime you want manually.

00:21:01.620 --> 00:21:03.770
You just tell it to throw
away certain messages.

00:21:03.780 --> 00:21:07.660
In the cronscript,
we sort of tail off messages.

00:21:07.660 --> 00:21:13.490
So although we keep all
messages above the level notice

00:21:13.590 --> 00:21:17.320
and above at the beginning,
after a day,

00:21:17.320 --> 00:21:20.700
we throw away the notice message
and the warning messages.

00:21:20.700 --> 00:21:23.760
After a couple of days,
we throw away a little bit more.

00:21:23.760 --> 00:21:26.640
And then finally,
we throw away everything.

00:21:26.960 --> 00:21:28.140
That's a week old or more.

00:21:28.140 --> 00:21:32.330
So by default, we only keep messages for
a week in that datastore.

00:21:34.190 --> 00:21:38.840
I should just mention that we're
working on some improvements in that

00:21:38.840 --> 00:21:41.140
data store for Leopard and beyond.

00:21:41.140 --> 00:21:43.820
Right now it's pretty simple.

00:21:43.830 --> 00:21:47.580
It's actually mostly a flat
file if you go and look at it.

00:21:47.650 --> 00:21:49.380
I know a number of people have.

00:21:49.630 --> 00:21:52.950
We're probably going to turn that
into a slightly more sophisticated

00:21:53.020 --> 00:21:56.460
database in Leopard and beyond.

00:21:56.460 --> 00:22:01.450
So that we can do a little bit better
management of duplicated strings and make

00:22:01.470 --> 00:22:04.460
pruning a little bit faster and easier.

00:22:04.820 --> 00:22:09.930
With that, I'll turn the podium over to
Dave Zarzycki who's going to tell

00:22:09.930 --> 00:22:12.440
you about service management.

00:22:12.560 --> 00:22:15.260
And I'll be available in
the Q&A session afterwards.

00:22:15.430 --> 00:22:20.110
Thanks.

00:22:22.030 --> 00:22:23.440
Thanks, Marc.

00:22:23.540 --> 00:22:26.220
So, service management in Mac OS X.

00:22:26.550 --> 00:22:28.620
Well, what are services?

00:22:28.740 --> 00:22:30.890
Services are background processes.

00:22:31.140 --> 00:22:33.310
We need to manage them
somehow on the system.

00:22:33.310 --> 00:22:36.320
In Tiger, we've introduced launchd.

00:22:36.320 --> 00:22:40.860
It's our unification of
background process management.

00:22:40.860 --> 00:22:44.240
It is the daemon to end all daemons.

00:22:44.840 --> 00:22:47.760
It is XML based instead of shell scripts.

00:22:47.860 --> 00:22:50.030
These are our key points
we'd like to bring up,

00:22:50.100 --> 00:22:50.800
actually.

00:22:50.850 --> 00:22:52.840
It's XML based instead of shell scripts.

00:22:52.840 --> 00:22:57.030
It is less work for you
as a software developer,

00:22:57.030 --> 00:22:59.850
as we'll demonstrate later.

00:23:00.230 --> 00:23:02.720
It is easy to use for simple scenarios.

00:23:02.720 --> 00:23:08.660
Not very many knobs you need to tweak
just to get your daemon up and running.

00:23:08.680 --> 00:23:14.340
It has more flexible options than
any configuration daemon before it.

00:23:14.600 --> 00:23:20.020
And it has new kind of launch-on-demand
criteria if you don't necessarily

00:23:20.020 --> 00:23:22.050
need your job running all the time.

00:23:22.080 --> 00:23:26.860
It has a simplified notion of
dependencies that we actually feel

00:23:26.860 --> 00:23:30.750
can lead to a better system as
far as reliability is concerned.

00:23:30.760 --> 00:23:33.360
And it has support for
user-supplied jobs,

00:23:33.360 --> 00:23:38.170
which some of the previous daemons to
manage all other daemons didn't support.

00:23:39.700 --> 00:23:42.000
So XML, why XML?

00:23:42.510 --> 00:23:45.200
Well, structured data is a good thing.

00:23:45.280 --> 00:23:49.730
It's very easy with XML to
quickly introspect every job,

00:23:49.730 --> 00:23:53.580
daemon, agent, whatever you want to
call it on the system,

00:23:53.580 --> 00:23:57.880
and look at, let's say, well,
what user is this job running as?

00:23:57.880 --> 00:24:00.340
Well, there's a key and a value for that.

00:24:00.390 --> 00:24:03.700
Is this job nice at all?

00:24:03.700 --> 00:24:05.260
Well, there's a key and a value for that.

00:24:05.400 --> 00:24:07.710
And let's say if we want to
bulk modify some daemons.

00:24:07.800 --> 00:24:10.410
Well, we can script that,
we can quickly do that

00:24:10.410 --> 00:24:11.790
in a structured way.

00:24:11.800 --> 00:24:14.560
And it's consistent above all else.

00:24:14.560 --> 00:24:16.490
That's why we can do things like this.

00:24:16.500 --> 00:24:20.000
In the past, we had shell scripts and
with the shell script,

00:24:20.000 --> 00:24:20.900
it's a language.

00:24:20.900 --> 00:24:24.110
It's really hard to just
run into a language,

00:24:24.110 --> 00:24:27.330
you know,
any kind of file with a language in

00:24:27.330 --> 00:24:31.430
it and just find where a particular
variable is tweaked or there

00:24:31.430 --> 00:24:34.540
could be a whole multitude of
ways those things are accomplished.

00:24:35.070 --> 00:24:36.860
And we brought that
all together with XML,

00:24:36.860 --> 00:24:38.360
so it's done in a consistent manner.

00:24:38.370 --> 00:24:41.960
It's also faster, too,
because now you don't need to run through

00:24:42.090 --> 00:24:47.350
an interpreter of some kind and actually
try and run through and do what probably

00:24:47.350 --> 00:24:50.900
amounts to a few simple things like just,
hey, run this process.

00:24:50.900 --> 00:24:55.090
We can just launch it directly.

00:24:55.500 --> 00:24:58.730
Now, on the topic of less work,
how can you as a developer

00:24:58.800 --> 00:25:00.710
find yourself with less work?

00:25:00.930 --> 00:25:03.860
Well, you don't need to fork
and have the parent exit,

00:25:03.940 --> 00:25:06.280
or what some people call daemonizing.

00:25:06.280 --> 00:25:10.060
SetSid, another common daemonizing task.

00:25:10.180 --> 00:25:11.400
Nope, you don't need to do that.

00:25:11.400 --> 00:25:14.190
You don't need to close
stray file descriptors.

00:25:14.190 --> 00:25:17.360
You don't need to reopen
standard IO as dev null.

00:25:18.280 --> 00:25:21.270
And you don't need to change
the working directory to slash.

00:25:21.320 --> 00:25:22.600
There's a whole bunch of things.

00:25:22.680 --> 00:25:24.940
No, you're pre-daemonized.

00:25:24.940 --> 00:25:25.620
You can hit main.

00:25:25.630 --> 00:25:28.220
If all you want to do is say
sleep for a million years,

00:25:28.220 --> 00:25:30.060
fine, that's a daemon.

00:25:30.060 --> 00:25:32.480
You don't need to do anything
special to become one now.

00:25:34.160 --> 00:25:36.930
And in fact,
when you don't do some of these things,

00:25:36.930 --> 00:25:39.940
like close standard IO,
that allows us to actually,

00:25:39.940 --> 00:25:44.410
before we launch your process,
maybe direct those to interesting places.

00:25:44.500 --> 00:25:47.640
By default,
we'll have them go to Dev Null, but if,

00:25:47.640 --> 00:25:51.320
let's say, an administrator says, no,
for this daemon,

00:25:51.320 --> 00:25:54.820
I want his standard out and
standard error to go to this file.

00:25:54.820 --> 00:25:56.400
Well, now we can do that.

00:25:56.650 --> 00:25:58.690
Whereas before,
the daemon would just say, bye-bye,

00:25:58.690 --> 00:26:00.300
I closed it, I know what's going on.

00:26:00.500 --> 00:26:03.080
And that would be difficult to do,
but now it's easy.

00:26:04.620 --> 00:26:05.650
Now it's easy to use.

00:26:05.740 --> 00:26:10.500
Here is, minus the header and footer,
an XML property list.

00:26:10.630 --> 00:26:13.590
We have the label,
which uniquely identifies

00:26:13.590 --> 00:26:14.960
the job to launchd.

00:26:15.120 --> 00:26:19.100
We have the on-demand key,
which tells launchd, "No,

00:26:19.100 --> 00:26:20.830
this is not on-demand.

00:26:20.910 --> 00:26:28.170
We want this job running all the
time." And what program to invoke,

00:26:28.170 --> 00:26:28.170
in this case, somethingd.

00:26:28.370 --> 00:26:31.320
And what launchd will do
is when this property list

00:26:31.320 --> 00:26:33.870
gets loaded up into launchd,
it'll say, hey,

00:26:34.040 --> 00:26:35.530
this is not an on-demand job.

00:26:35.590 --> 00:26:37.020
We need to have it running all the time.

00:26:37.080 --> 00:26:39.520
And it'll start something deep.

00:26:39.760 --> 00:26:44.120
And if for some reason something deep
consciously or accidentally exits,

00:26:44.120 --> 00:26:48.540
launchd will notice and say, hey,
this job's supposed to be running all

00:26:48.540 --> 00:26:51.060
the time and start them back up again.

00:26:52.990 --> 00:26:56.640
So now you as a daemon
writer cannot worry about,

00:26:56.730 --> 00:27:01.600
you know, if you die accidentally,
the system will restart you.

00:27:01.920 --> 00:27:03.740
Increased flexibility.

00:27:03.920 --> 00:27:08.010
Well, as we talked about,
we now have a standardized schema with

00:27:08.010 --> 00:27:10.180
XML to represent how a daemon started.

00:27:10.180 --> 00:27:14.720
We also have a lot more parameters
that you can tweak than other previous

00:27:14.720 --> 00:27:17.100
daemon managers have supported.

00:27:17.100 --> 00:27:20.740
As I mentioned earlier,
we have the standard out and standard

00:27:20.740 --> 00:27:23.140
error that we can set on a per job basis.

00:27:23.140 --> 00:27:26.520
There's the nice level,
the working directory if you

00:27:26.520 --> 00:27:30.180
want a daemon to maybe have
a little sandbox over here.

00:27:30.640 --> 00:27:33.200
Even the root directory,
if you really just want to root

00:27:33.260 --> 00:27:37.040
the daemon off and have them not
affect other parts of the system.

00:27:37.080 --> 00:27:39.560
The UMass,
you can have per job environment

00:27:39.560 --> 00:27:44.220
variables that are easy to set up and see
in a consistent manner with the plist.

00:27:44.220 --> 00:27:48.690
There's actually a huge multitude of
things you can adjust and where you

00:27:48.690 --> 00:27:53.700
can look for these variables on the
system is the launchd.plist man page.

00:27:53.700 --> 00:27:55.180
It's in section 5.

00:27:55.180 --> 00:27:58.410
And you can find where all this
stuff is documented and what

00:27:58.410 --> 00:28:00.140
they do and how they behave.

00:28:01.500 --> 00:29:47.000
[Transcript missing]

00:29:47.500 --> 00:29:50.880
We also have interval timers.

00:29:51.080 --> 00:29:55.360
Now some of you may have in the past
in cron sat there and calculated

00:29:55.410 --> 00:29:58.280
out the exact interval you wanted
to run for every five minutes.

00:29:58.280 --> 00:30:00.680
So you say 5, 10, 15, 20.

00:30:00.770 --> 00:30:02.600
No, no, no,
you don't need to do that anymore.

00:30:02.680 --> 00:30:05.720
Just say run it every 300
seconds and launchd will do

00:30:05.720 --> 00:30:07.400
the rest of the work for you.

00:30:07.550 --> 00:30:12.350
And in fact, if you want to be weird
and say every 137 seconds,

00:30:12.350 --> 00:30:12.350
you can do that.

00:30:12.740 --> 00:30:23.890
Also, we have still,
if you want the more cron-like semantics,

00:30:23.890 --> 00:30:23.890
you can specify a
calendar-based interval timer.

00:30:23.890 --> 00:30:23.890
So that way you can run it
on the third of every month.

00:30:24.740 --> 00:30:25.830
Now, dependencies.

00:30:26.000 --> 00:30:27.560
Let's first talk about the old way.

00:30:27.560 --> 00:30:31.000
Since we have been talking a
little bit about system boot up,

00:30:31.000 --> 00:30:33.450
it's important to talk about
dependencies because we came

00:30:33.450 --> 00:30:34.990
from a world with System Starter.

00:30:35.000 --> 00:30:38.490
In System Starter,
dependencies were explicitly

00:30:38.490 --> 00:30:41.200
declared by the Startup Item writer.

00:30:41.240 --> 00:30:44.920
Well, in reality,
this didn't work out well.

00:30:44.920 --> 00:30:49.890
What ended up happening is that one
of the following things would happen.

00:30:49.950 --> 00:30:51.230
Dependencies were overstated.

00:30:51.230 --> 00:30:54.510
People weren't sure,
so they'd just throw some

00:30:54.520 --> 00:30:57.300
more in there until it worked.

00:30:57.610 --> 00:30:59.560
Dependencies were sometimes understated.

00:30:59.570 --> 00:31:03.970
Sometimes a developer didn't know and
it just happened to work on a system.

00:31:03.980 --> 00:31:06.360
So he missed something,
but it wouldn't work for someone else.

00:31:06.360 --> 00:31:09.210
And dependency meaning was often vague.

00:31:09.420 --> 00:31:11.160
Well, I need the network.

00:31:11.160 --> 00:31:12.550
Well, what does that mean?

00:31:12.700 --> 00:31:15.700
Do I need a DNS server?

00:31:15.770 --> 00:31:18.100
Do I just need an
IP address on an interface?

00:31:18.100 --> 00:31:19.790
I don't know.

00:31:19.880 --> 00:31:24.620
And that was difficult for people to
both decide on what dependencies to

00:31:24.620 --> 00:31:27.580
export and what dependencies to export.

00:31:27.600 --> 00:31:36.170
Also, dependencies sometimes were just
virtually assumed by other dependencies.

00:31:36.180 --> 00:31:40.150
Well, I need, let's say,
directory services.

00:31:40.150 --> 00:31:43.560
And there were some StartupItems
out there that we found inside the

00:31:43.570 --> 00:31:46.920
company that assumed that if they
needed directory services that

00:31:46.920 --> 00:31:49.800
the network would already be up,
whatever that meant.

00:31:49.800 --> 00:31:53.340
Well, that was a problem,
and we need to fix that.

00:31:53.370 --> 00:31:56.790
So how did we solve all this?

00:31:56.940 --> 00:32:01.690
In Mac OS X,
we've essentially inlined dependencies.

00:32:01.690 --> 00:32:06.550
We made the observation that, well,
you don't really need the network,

00:32:06.680 --> 00:32:08.580
you need the ability to talk to configd.

00:32:08.580 --> 00:32:11.890
And configd knows when the network's
up and can tell you when that changes.

00:32:12.500 --> 00:32:18.110
We noticed that some people need to
find out when disk came and went,

00:32:18.330 --> 00:32:21.130
the device, you know,
disk were mounted or unmounted.

00:32:21.260 --> 00:32:24.400
Well, you don't need to wait for
all the disk to be mounted,

00:32:24.400 --> 00:32:28.790
you need to talk to disk arbitrationd
and find out when these events happen.

00:32:29.220 --> 00:32:33.010
So this observation was IPC was the key.

00:32:33.010 --> 00:32:37.560
And what we do now is we register
all these IPC handles of configd

00:32:37.560 --> 00:32:39.270
and other daemons with launchd.

00:32:39.280 --> 00:32:41.730
And we get all those
registrations done at bootup.

00:32:41.800 --> 00:32:44.100
And then we allow daemons to start up.

00:32:44.210 --> 00:32:47.650
And because the communication handles
are registered now with the system,

00:32:47.670 --> 00:32:50.160
daemons,
when they start talking to each other,

00:32:50.160 --> 00:32:53.800
now find each other because
their handles are out there.

00:32:54.610 --> 00:32:58.500
And this allows us to boot up really,
really fast because what we can do is

00:32:58.500 --> 00:33:00.520
start up a lot of daemons in parallel.

00:33:00.650 --> 00:33:03.590
And as they're initializing themselves
and start talking to other daemons,

00:33:03.590 --> 00:33:06.510
it doesn't matter if the other daemon
isn't done initializing itself.

00:33:06.510 --> 00:33:10.580
It won't answer its
IPC query until it's ready.

00:33:10.970 --> 00:33:19.510
And that way, the thundering herd,
eventually the dust settles

00:33:19.510 --> 00:33:22.080
and your system's booted.

00:33:22.080 --> 00:33:22.080
Yeah.

00:33:23.800 --> 00:33:27.500
Now, again, what this means though,
as a daemon writer,

00:33:27.540 --> 00:33:32.050
if you expect people to depend on you,
you need to declare your sockets and

00:33:32.050 --> 00:33:34.180
your communication and your P-list.

00:33:34.320 --> 00:33:37.080
Because if you don't,
people can start up and they'll try and

00:33:37.080 --> 00:33:39.240
connect to your socket and it'll fail.

00:33:39.240 --> 00:33:43.270
And then you end up with all these
degenerate code paths that probably

00:33:43.340 --> 00:33:45.900
haven't been tested in a very long time.

00:33:46.170 --> 00:33:48.950
So what you, yeah, please,
please just declare your

00:33:48.950 --> 00:33:52.690
socket's in your P list and
everything will just be groovy.

00:33:53.360 --> 00:33:59.740
Now, if we want to talk about a case
study of declaring socket in PLIS,

00:33:59.740 --> 00:34:02.120
we can talk about the SSH agent.

00:34:02.120 --> 00:34:05.110
In the past,
there was an interesting dependency

00:34:05.110 --> 00:34:09.390
problem that people would have with
trying to start their SSH agent.

00:34:09.880 --> 00:34:14.850
What people would do is they'd put
a lot of complicated shell logic

00:34:14.970 --> 00:34:18.790
in their shell startups to figure
out if SSH agent was running.

00:34:18.840 --> 00:34:21.750
And if it was, use the existing copy.

00:34:21.970 --> 00:34:24.290
And if it wasn't, start a new one.

00:34:24.460 --> 00:34:27.980
Well, this is all actually a lot
easier with launchd now with

00:34:27.980 --> 00:34:29.800
a small patch to SSH agent.

00:34:29.930 --> 00:34:33.540
And I'll demonstrate
this later in a demo.

00:34:34.070 --> 00:34:38.370
But now it's just you put a plist
in your home directory saying here,

00:34:38.370 --> 00:34:41.760
launch SSH agent when somebody
connects to this socket.

00:34:41.760 --> 00:34:46.330
And SSH agent will then start up and
accept whatever connection came in.

00:34:46.370 --> 00:34:50.810
And it's now a lot simpler for
a user to use the SSH agent.

00:34:50.960 --> 00:34:52.660
And if you want to
actually play with this,

00:34:52.690 --> 00:34:55.720
you can go to one of the
OpenDarwin developers,

00:34:55.720 --> 00:35:00.550
Landon, and grab the patch and the
plist and play with it yourself.

00:35:01.660 --> 00:35:07.050
Now, this SSH agent that is talked about,
it needs to get its socket

00:35:07.200 --> 00:35:11.660
from launchd and actually then
demux and dequeue this IPC.

00:35:11.660 --> 00:35:12.550
Well, how does it do that?

00:35:12.600 --> 00:35:17.560
We have an IPC API to talk to launchd.

00:35:17.560 --> 00:35:22.300
It's a very simple RTTI,
runtime type information based object

00:35:22.300 --> 00:35:25.200
graph system to support message passing.

00:35:25.200 --> 00:35:27.200
That's all it's designed for.

00:35:27.200 --> 00:35:30.380
It's not designed to be core
foundation or any of these other

00:35:30.740 --> 00:35:32.720
stratosphere level frameworks.

00:35:32.720 --> 00:35:37.170
It's just IPC, you know, hello, goodbye,
you know, that kind of thing.

00:35:37.180 --> 00:35:40.160
Here's the simple C APIs.

00:35:40.160 --> 00:35:44.240
As you can see here, the very first one,
the one and only really one to

00:35:44.250 --> 00:35:46.280
talk to launchd is launch message.

00:35:46.360 --> 00:35:48.720
It'll take an opaque object in.

00:35:48.720 --> 00:35:51.140
It'll return you an object from launchd.

00:35:51.140 --> 00:35:55.080
An example of creating an opaque object,
as we see here,

00:35:55.080 --> 00:35:57.130
is I'd like to create a new integer.

00:35:57.200 --> 00:35:58.860
And you get an object back.

00:35:58.930 --> 00:36:02.260
And I'd like to get from the
object what integer is in there.

00:36:02.260 --> 00:36:03.460
There you go.

00:36:03.570 --> 00:36:04.410
It's really simple.

00:36:06.600 --> 00:36:08.880
Now,
if we want to talk about the semantics

00:36:08.910 --> 00:36:12.030
of that launch message and launchdataT,
here we go.

00:36:12.420 --> 00:36:15.180
launchdataT just
represents an object graph.

00:36:15.270 --> 00:36:18.020
It could be a single object,
like a string or a number,

00:36:18.140 --> 00:36:20.160
or it could be a more complicated tree.

00:36:20.160 --> 00:36:25.380
The launch message API is
synchronous for the common case.

00:36:25.380 --> 00:36:30.300
It returns null if there's some kind of
IPC failure itself to talking to launchd.

00:36:30.300 --> 00:36:32.710
And you can check error
no if that happens.

00:36:33.580 --> 00:36:38.810
You can get asynchronous messages back
from launchd if you've requested them

00:36:38.810 --> 00:36:41.980
by passing null to launch message.

00:36:41.980 --> 00:36:45.610
And then the first message
that was asynchronously sent

00:36:45.620 --> 00:36:47.400
to you will be returned.

00:36:47.400 --> 00:36:51.210
And you can keep calling that in
a loop until you've drained the

00:36:51.220 --> 00:36:53.540
queue of asynchronous messages.

00:36:53.540 --> 00:36:56.810
And at that point, null is returned.

00:36:56.820 --> 00:37:00.400
And then you can check error no to see if
it's not equal to zero to differentiate

00:37:00.400 --> 00:37:03.470
whether there was an actual error or
if there's just no more asynchronous.

00:37:03.580 --> 00:37:05.270
messages.

00:37:05.990 --> 00:37:08.700
Now, let's dive a little bit
deeper into launchd.

00:37:08.910 --> 00:37:09.890
What does it support?

00:37:09.890 --> 00:37:14.460
It supports dictionaries,
key value pair-based entries.

00:37:14.460 --> 00:37:18.590
It supports plain old arrays,
if you don't actually need keys.

00:37:18.710 --> 00:37:21.690
It supports file descriptors
as a unique object type.

00:37:21.750 --> 00:37:24.660
It's not just a number,
it represents a file descriptor.

00:37:24.890 --> 00:37:29.450
Integers, real numbers, booleans,
strings, opaque data.

00:37:30.020 --> 00:37:35.210
This is all that we needed and actually
a little bit more for talking to launchd.

00:37:36.210 --> 00:37:39.240
The, again,
this is just IPC we're talking about.

00:37:39.520 --> 00:37:41.950
We have get and set for the basic types.

00:37:42.250 --> 00:37:43.770
That's all we need.

00:37:43.780 --> 00:37:46.830
For dictionaries,
the only thing we needed

00:37:46.880 --> 00:37:51.320
was the ability to insert,
look up, remove, and iterate.

00:37:51.320 --> 00:37:53.980
Again, we're just talking to launchd.

00:37:53.980 --> 00:37:56.290
We're not trying to solve
all the world's problems.

00:37:56.570 --> 00:38:01.180
Arrays, get and set index,
and get the count.

00:38:02.050 --> 00:38:08.960
Now, stepping back a bit from the APIs,
I'm going to talk about the XML plist.

00:38:08.980 --> 00:38:13.350
There's only two keys that are actually
required in LaunchD property list.

00:38:13.640 --> 00:38:16.680
One is the label,
which uniquely identifies the job,

00:38:16.680 --> 00:38:19.060
and the other is what to launch.

00:38:19.060 --> 00:38:22.660
And by default,
if you don't specify the on-demand key,

00:38:22.690 --> 00:38:26.120
you will default to being on-demand
because we'd just like to push

00:38:26.120 --> 00:38:29.590
you to be that way because,
again, it helps you help us.

00:38:29.860 --> 00:38:32.470
But the common case is that
people will include the label,

00:38:32.470 --> 00:38:35.140
the program arguments,
and the on-demand key with the

00:38:35.200 --> 00:38:37.380
on-demand key set to false.

00:38:37.380 --> 00:38:40.200
So that way they can have their
daemon running all the time.

00:38:40.480 --> 00:38:42.890
But if you do have the
on-demand key set to true,

00:38:42.960 --> 00:38:47.150
we then have some optional keys you can
then use to specify how to launch you.

00:38:47.150 --> 00:38:50.930
As we talked about earlier,
there's the sockets or the

00:38:51.060 --> 00:38:53.010
timers or watching a file.

00:38:53.010 --> 00:38:56.780
There's also many other optional keys,
as we've talked about earlier.

00:38:56.780 --> 00:39:01.080
There's even things like the
username and group name if you're

00:39:01.490 --> 00:39:03.790
having a daemony-type launchd job.

00:39:05.040 --> 00:39:06.230
And let's see.

00:39:06.230 --> 00:39:07.040
Yeah.

00:39:07.040 --> 00:39:09.540
Now, sockets.

00:39:09.830 --> 00:39:11.760
Sockets are actually a
complicated thing to set up.

00:39:11.850 --> 00:39:15.500
But we tried to do a
lot of same defaults.

00:39:15.680 --> 00:39:19.700
We default to example to the stream type,
but if because that's the common case,

00:39:19.760 --> 00:39:22.290
but if you need a datagram socket,
you can set that up.

00:39:22.420 --> 00:39:27.860
It contains a lot of details of like,
I want to connect to this machine.

00:39:27.920 --> 00:39:30.040
And then a file descriptor
will be created.

00:39:30.120 --> 00:39:34.920
Or maybe you want to listen on
this IP address with only the IPVP.

00:39:34.940 --> 00:39:36.690
And a datagram socket.

00:39:36.690 --> 00:39:39.560
Well, you can then also specify that.

00:39:39.590 --> 00:39:43.890
And to repeat myself, since I think it's
important for this talk,

00:39:44.120 --> 00:39:48.380
all these configuration details of
how to specify your property list

00:39:48.380 --> 00:39:51.080
are in the launchd.plist man page.

00:39:51.080 --> 00:39:55.620
Now, once you have your socket set up,
we get to an interesting thing.

00:39:55.620 --> 00:39:59.670
What we do is we actually take this
property list and do kind of a quick

00:40:00.270 --> 00:40:04.360
transform of it over to launchdata-t,
since it maps really well.

00:40:05.050 --> 00:40:09.220
The only difference, though,
is we take the socket specification

00:40:09.220 --> 00:40:13.160
and turn them into launchdata-t
file descriptor objects.

00:40:13.160 --> 00:40:16.580
And that has a very interesting
and powerful effect.

00:40:16.690 --> 00:40:22.160
What that does is it makes it so launchd
is not aware of socket types at all.

00:40:22.170 --> 00:40:24.590
It's just an opaque file descriptor.

00:40:24.600 --> 00:40:29.160
This future proofs launchd such that
you could have a long running system.

00:40:29.160 --> 00:40:32.930
And if you wanted to have a
new file descriptor type as

00:40:32.930 --> 00:40:34.600
maybe a kernel extension.

00:40:34.940 --> 00:40:37.640
You could do that,
load the kernel extension,

00:40:37.640 --> 00:40:41.340
create this new socket,
and hand it over to the running launchd,

00:40:41.340 --> 00:40:43.880
and now he can launch your job on demand.

00:40:43.940 --> 00:40:47.890
It also means since you can
programmatically talk to launchd,

00:40:47.890 --> 00:40:52.450
you could also come up with a new file
descriptor that launchd hasn't heard

00:40:52.570 --> 00:40:55.870
about and just hand it over and say,
hey, yeah, when this becomes readable,

00:40:56.530 --> 00:40:58.510
launch this job.

00:40:58.700 --> 00:41:01.980
So we're very excited about this
particular aspect of launchd and

00:41:01.980 --> 00:41:04.970
how potentially people might use it.

00:41:05.580 --> 00:41:08.440
But other than that,
we take the XMLP list that's now

00:41:08.440 --> 00:41:13.020
transformed and we can do something
like a submit job as an example message.

00:41:13.020 --> 00:41:21.920
And messages are simply dictionaries with
the one key and the value is the message.

00:41:21.920 --> 00:41:26.600
So the key might be submit job and
the value is the now launchdata T that

00:41:26.600 --> 00:41:29.230
represents the XML property list.

00:41:29.840 --> 00:41:32.270
You can also do something
like a remove job.

00:41:32.360 --> 00:41:35.640
That's again a dictionary
with one key saying remove.

00:41:35.640 --> 00:41:39.060
The value is the string
representing the label.

00:41:39.060 --> 00:41:43.560
You can do other things like get
jobs and get jobs is so simple

00:41:43.560 --> 00:41:44.560
it doesn't even take an argument.

00:41:44.560 --> 00:41:48.620
So the way we do that is we just
throw a string at launchd saying hey,

00:41:48.620 --> 00:41:49.960
this is the message.

00:41:50.020 --> 00:41:50.680
It's a string.

00:41:50.680 --> 00:41:52.020
It says get jobs.

00:41:52.020 --> 00:41:56.950
If you want a specific job,
again back to the dictionary, hey,

00:41:56.950 --> 00:41:59.150
here's the key,
the value is the label and

00:41:59.160 --> 00:42:01.840
you can get a specific job and
find out about its attributes.

00:42:01.840 --> 00:42:08.330
Checking in is how a native launchd job
gets its configuration parameters and

00:42:08.330 --> 00:42:12.420
its file descriptors back from launchd
and then goes about its business.

00:42:13.730 --> 00:42:19.120
There's also things like start and stop,
which if we rewound a few slides and

00:42:19.120 --> 00:42:23.820
how I pointed out that a label and
program arguments is all that you need.

00:42:23.870 --> 00:42:25.860
Well,
if you don't specify the on-demand key,

00:42:25.860 --> 00:42:27.980
your job's just going to
sit there not running.

00:42:28.040 --> 00:42:31.810
And if you really want,
you can manually poke a job and say, hey,

00:42:31.820 --> 00:42:33.420
launchd, start that job.

00:42:33.470 --> 00:42:34.690
And launchd will start it.

00:42:34.700 --> 00:42:37.890
Or if you want to say stop it,
launchd will stop it.

00:42:38.150 --> 00:42:41.440
But that's primarily meant
for testing purposes.

00:42:41.440 --> 00:42:44.990
If you have an on-demand job and
you want to manually start it

00:42:44.990 --> 00:42:49.690
up to make sure that it works,
your keys and your criteria should

00:42:49.690 --> 00:42:52.520
ideally launch your job on demand.

00:42:53.210 --> 00:42:58.480
Now to go into an actual programming
example of how you would talk to launchd.

00:42:58.600 --> 00:43:01.640
Again, we're going to allocate a
dictionary for the message.

00:43:01.700 --> 00:43:08.320
We're going to insert a string,
com.example.helloD,

00:43:08.330 --> 00:43:10.000
and start job is the key.

00:43:10.000 --> 00:43:14.600
And here we go, launch message,
send the message and get a response.

00:43:14.600 --> 00:43:17.000
And now we can free the
message and the response.

00:43:17.170 --> 00:43:20.490
It's really that simple
to talk to launchd.

00:43:20.900 --> 00:43:22.430
Now to rehash.

00:43:22.710 --> 00:43:24.800
Launchd, we see this as the future.

00:43:24.800 --> 00:43:28.430
It has less work for you.

00:43:28.680 --> 00:43:31.440
You're pre-daemonized out the get-go.

00:43:31.440 --> 00:43:33.630
If you just want to sleep forever,
you can do that.

00:43:33.680 --> 00:43:36.130
There's nothing else you need
to do to become an official

00:43:36.130 --> 00:43:37.800
daemon as far as we're concerned.

00:43:37.800 --> 00:43:40.970
If you've gone native with us,
just check in and go.

00:43:40.970 --> 00:43:44.800
That's only one message you
really need to send and get back.

00:43:44.960 --> 00:43:46.730
Other than that,
you're done talking to launchd.

00:43:47.950 --> 00:43:51.520
There's automatic restarting if you're
worried about your daemon staying up.

00:43:51.640 --> 00:43:55.990
Again, a very powerful feature that
many people will appreciate.

00:43:56.520 --> 00:44:00.230
There's more flexible criteria than
ever before to get your job running.

00:44:00.470 --> 00:44:03.880
We hope that you can take
advantage of it to help us help

00:44:03.980 --> 00:44:06.700
everybody save system resources.

00:44:06.700 --> 00:44:10.220
We also have the ability
to monitor multiple,

00:44:10.220 --> 00:44:13.270
lots of file descriptors if you want.

00:44:13.330 --> 00:44:16.940
So if you want half a dozen connections
scattered around the universe

00:44:16.940 --> 00:44:20.580
and be able to launch on demand
whenever any of them become readable,

00:44:20.580 --> 00:44:21.580
we can do that.

00:44:21.620 --> 00:44:25.520
And finally, user agents,
like I talked about with the SSH agent.

00:44:26.610 --> 00:44:30.560
That is a powerful concept that
we haven't ever had before with

00:44:30.560 --> 00:44:32.560
daemons like INETD or INIT.

00:44:32.580 --> 00:44:37.730
So let's jump into a demo about
this SSH agent and some of the other

00:44:37.730 --> 00:44:40.640
powerful things launchd can do.

00:44:40.640 --> 00:44:42.100
So system two.

00:44:42.100 --> 00:44:48.120
Okay, so just to show you what can
happen with the SSH agent,

00:44:48.120 --> 00:44:51.550
we've dropped a property list
describing it into the system.

00:44:51.560 --> 00:44:55.320
And when we log in now,
we have an SSH agent.

00:44:55.320 --> 00:44:55.780
Oops.

00:44:56.400 --> 00:44:57.880
Ready to launch on demand.

00:44:57.880 --> 00:45:01.110
And I'll show you with a quick
PS output that it's not running,

00:45:01.110 --> 00:45:04.160
but when we say SSH add,
it'll get launched on demand.

00:45:07.730 --> 00:45:15.350
Let's see, that's readable, right?

00:45:15.350 --> 00:45:15.500
All right.

00:45:17.670 --> 00:45:24.760
No SSH agent,
but if we do a set pipe grip SSH,

00:45:31.400 --> 00:45:33.400
This is the font of demos.

00:45:33.400 --> 00:45:38.240
Library launch agents.

00:45:38.240 --> 00:45:38.240
Yeah.

00:45:39.700 --> 00:45:42.740
Apparently it wasn't, oh, I'm sorry.

00:45:42.770 --> 00:45:45.620
One of the things I haven't done that
I was going to demonstrate is how

00:45:45.620 --> 00:45:48.560
this environment variable gets set.

00:45:48.560 --> 00:45:51.230
It's actually loaded,
as I can show you right

00:45:51.290 --> 00:45:53.600
now with launchctl list.

00:45:53.600 --> 00:45:58.380
But the environment variable that SSH add
uses to talk back to the agent isn't set.

00:45:58.630 --> 00:46:02.480
And if you remember before,
I said that people needed a lot of

00:46:02.480 --> 00:46:07.200
shell logic to figure out whether
the SSH agent isn't running or what,

00:46:07.200 --> 00:46:08.920
or whether to start it.

00:46:09.080 --> 00:46:10.060
Well, we don't need that anymore.

00:46:10.070 --> 00:46:15.750
In fact, the only thing you need to do
at the top of your shell startup

00:46:16.100 --> 00:46:19.630
scripts now is say launchctl export.

00:46:20.000 --> 00:46:24.520
And what that did,
just to run it again and show you,

00:46:24.520 --> 00:46:31.420
is it did a quick shell script output of
all the environment variables in launchd.

00:46:31.420 --> 00:46:33.240
And now we've set them
in our own local shell.

00:46:33.350 --> 00:46:40.050
And the important one would be this
SSH authsoc that is using launchd.

00:46:40.110 --> 00:46:44.020
And now we can say SSH add.

00:46:45.980 --> 00:46:49.240
And now, the SSH agent is running.

00:46:49.240 --> 00:46:55.340
And the -l flag is the flag we
created to say launch on demand.

00:46:55.340 --> 00:46:59.940
And just to prove that that is the case,
we can say list, there's the key,

00:47:00.010 --> 00:47:05.560
and if we kill that, and then list,
now there's no more identities.

00:47:05.560 --> 00:47:09.450
And it's,
obviously a new version is running.

00:47:11.900 --> 00:47:22.710
and David Zawadzka,
are the main developers of

00:47:22.710 --> 00:47:22.710
the OS Enhancments for BSD.

00:47:25.660 --> 00:47:26.820
This is what we used.

00:47:26.860 --> 00:47:31.930
Here's the program arguments
to launch SSH Agent on Demand.

00:47:31.970 --> 00:47:36.460
As you can see, they're pre-tokenized,
which saves everyone a lot of work.

00:47:36.490 --> 00:47:41.710
Because that way we don't need to launch
a shell just for every daemon we launch.

00:47:41.740 --> 00:47:44.220
Now we can launch the process directly.

00:47:44.400 --> 00:47:48.580
And for the sockets, again,
I mentioned earlier that we have

00:47:48.650 --> 00:47:51.200
a lot of defaults like SOC stream.

00:47:51.320 --> 00:47:58.000
In this case, a secure socket with key
implies a Unix datagram socket.

00:47:58.080 --> 00:48:00.940
And the key is the environment
variable we want set.

00:48:01.090 --> 00:48:04.090
And this is all we need, oh,
this and service IPC,

00:48:04.100 --> 00:48:09.400
which contractually obligates that this
guy will do a check-in with launchd.

00:48:09.580 --> 00:48:11.960
But other than that,
this is all we needed to

00:48:11.960 --> 00:48:13.620
get the SSH Agent running.

00:48:13.830 --> 00:48:20.030
To now move on and show
some general launchd,

00:48:20.040 --> 00:48:28.000
launchctl stuff that you can
look at on your own Tiger system,

00:48:28.000 --> 00:48:28.000
we can move to the stuff
that Apple provides.

00:48:31.310 --> 00:48:34.880
So if we were to look
at the Postfix example,

00:48:34.880 --> 00:48:42.640
we can see that we launch post, in fact,
we specify where exactly the

00:48:42.640 --> 00:48:43.920
program is with the program.

00:48:44.000 --> 00:48:47.100
But the actual arguments are right here.

00:48:47.100 --> 00:48:53.640
And what this -e says is, and 60,
is that after 60 seconds

00:48:53.700 --> 00:48:56.640
of nothing to do,
Postfix will exit.

00:48:56.640 --> 00:48:59.480
And that wasn't even something
we needed to add to Postfix.

00:48:59.480 --> 00:49:02.060
They already actually had that built in.

00:49:02.060 --> 00:49:04.640
And again, here's the Q directories.

00:49:04.640 --> 00:49:08.210
If we just watch this directory and
anytime something shows up in there,

00:49:08.230 --> 00:49:10.220
we launch Postfix.

00:49:10.220 --> 00:49:13.220
Another interesting example,
actually using a combination of

00:49:13.220 --> 00:49:17.260
launchd criteria is the cron example.

00:49:17.480 --> 00:49:22.560
Now we, oh, that's right.

00:49:25.070 --> 00:49:28.480
We have cron, the thing we're running.

00:49:28.480 --> 00:49:31.600
And if we notice the lack
of the on-demand key,

00:49:31.600 --> 00:49:33.580
it now defaults to on-demand.

00:49:33.680 --> 00:49:34.790
So this is an on-demand job.

00:49:34.840 --> 00:49:38.840
What we did tell launchd to do is
try running this at least once.

00:49:38.840 --> 00:49:42.000
And what that does is
when cron is run at boot,

00:49:42.190 --> 00:49:46.040
it looks it around,
particularly its Etsy cron tab.

00:49:46.040 --> 00:49:48.940
And if it finds that
it has no work to do,

00:49:49.070 --> 00:49:52.920
no user cron tabs, no system cron tabs,
it exits.

00:49:53.000 --> 00:49:54.970
And then we can take
it back to the system.

00:49:55.020 --> 00:49:58.530
And we can take advantage of this
launch on-demand criteria to watch

00:49:58.610 --> 00:50:02.230
this file and to watch this directory
to see if it goes non-empty.

00:50:02.230 --> 00:50:06.230
And if either of these criteria fire,
we then run cron again.

00:50:06.420 --> 00:50:10.530
It goes out and looks around and
finds some work to do and then sticks

00:50:10.530 --> 00:50:12.750
around and does its cron thing.

00:50:12.820 --> 00:50:17.560
But again, if it finds no work to do,
it'll exit and it'll launch on-demand the

00:50:17.570 --> 00:50:20.470
next time particularly this file changes.

00:50:20.490 --> 00:50:24.740
Another example that
I'd like to demonstrate.

00:50:25.000 --> 00:50:29.250
is the, oops,

00:50:30.530 --> 00:50:33.800
Oh, the NNB, I believe, oh sorry, SMBD.

00:50:33.860 --> 00:50:37.050
So this one's a little bit interesting.

00:50:37.060 --> 00:50:41.900
The front part isn't as interesting
as much as the next part.

00:50:41.910 --> 00:50:46.900
So to demonstrate the Sockets
dictionary of how that works,

00:50:46.930 --> 00:50:49.220
we have two keys here.

00:50:49.310 --> 00:50:51.940
Notice net bias and direct.

00:50:51.970 --> 00:50:55.110
These keys are up to you, the programmer,
to use.

00:50:55.330 --> 00:50:58.080
You can use these keys to
describe whatever you want.

00:50:58.110 --> 00:50:59.480
Ideally, it should be a protocol.

00:50:59.500 --> 00:51:02.740
In this case,
these are two separate protocols.

00:51:02.760 --> 00:51:06.700
And what happens is when you check in,
you get the Sockets dictionary back,

00:51:06.700 --> 00:51:09.540
and you can look up these keys and
find out the file descriptors that

00:51:09.540 --> 00:51:12.180
actually correspond to that protocol.

00:51:12.210 --> 00:51:15.190
So this dictionary will end up
allocating some file descriptors,

00:51:15.350 --> 00:51:19.260
probably just one,
since we're only doing IPv4.

00:51:19.330 --> 00:51:24.130
But again, here's the service name.

00:51:24.220 --> 00:51:26.140
We'll look this up,
translate it to a port,

00:51:26.200 --> 00:51:29.070
bind to a file descriptor,
and that'll get passed along

00:51:29.070 --> 00:51:31.830
to when this guy checks in.

00:51:31.860 --> 00:51:34.760
Direct, again,
we'll look up a different port.

00:51:34.770 --> 00:51:37.960
It represents a different protocol,
so we stuck it over here.

00:51:37.960 --> 00:51:42.360
And we bound it to IPv4 specifically.

00:51:42.360 --> 00:51:44.580
So that's an example of
potentially having one daemon

00:51:44.680 --> 00:51:49.790
handle multiple protocols using
the configuration file syntax.

00:51:50.810 --> 00:51:53.180
Is there any other fun
examples to show here?

00:51:53.180 --> 00:51:56.130
Oh, an example of the

00:51:57.130 --> 00:52:00.120
periodic, the calendar based stuff.

00:52:00.180 --> 00:52:04.240
We have actually a few extra keys here,
which are interesting.

00:52:04.240 --> 00:52:05.970
One is the low priority IO.

00:52:06.180 --> 00:52:07.920
That's a feature we have in LaunchD.

00:52:08.070 --> 00:52:11.180
It tells the kernel,
well it gives a hint to the kernel

00:52:11.330 --> 00:52:15.540
that this job is not terribly important
as far as its disk IO is concerned.

00:52:15.540 --> 00:52:20.580
So try and make it a second tier
as far as disk access is concerned.

00:52:20.590 --> 00:52:24.420
And the nice does the
same thing for the CPU.

00:52:24.890 --> 00:52:29.160
Now we have the plain old
cron stuff before on the,

00:52:29.160 --> 00:52:32.840
at 3:15 in the morning,
let's run this job.

00:52:32.910 --> 00:52:36.380
And finally, let's see.

00:52:37.740 --> 00:52:44.290
Oh, I should at least show the simplest
example as I demonstrated earlier.

00:52:45.910 --> 00:52:47.560
Here's a job that just runs on demand.

00:52:47.620 --> 00:52:48.720
Here's the label.

00:52:48.750 --> 00:52:50.080
Here's the program argument.

00:52:50.100 --> 00:52:51.270
On demand, false.

00:52:51.300 --> 00:52:54.420
And this is how the
kernel event agent starts.

00:52:54.470 --> 00:52:55.940
So I think that's enough plist to show.

00:52:56.040 --> 00:53:03.520
The only other fun thing to show is you
can use launchctl to talk to launchd.

00:53:03.900 --> 00:53:05.430
And there's a whole bunch
of things you can do.

00:53:05.580 --> 00:53:08.420
You can say load to load a property list.

00:53:08.510 --> 00:53:11.030
So for example,

00:53:11.750 --> 00:53:15.350
You could say load system
library launch daemons nmbd.

00:53:15.350 --> 00:53:19.390
And that's how you would load
up a property list into launchd.

00:53:19.390 --> 00:53:23.670
If it were disabled, which is a key,
you can use dash w to remove the

00:53:23.670 --> 00:53:25.890
disabled key and then load it up.

00:53:25.890 --> 00:53:28.870
Because at boot up,
what happens is this whole

00:53:28.880 --> 00:53:32.860
directory of system library
launch daemons gets evaluated to

00:53:32.860 --> 00:53:34.820
decide if we want to load a job.

00:53:34.970 --> 00:53:38.160
And if the disabled key is true,
we won't load it.

00:53:38.220 --> 00:53:41.640
And the dash w flag
removes the disabled key.

00:53:41.700 --> 00:53:47.600
But some other fun things you can do,
for example,

00:53:47.830 --> 00:53:52.040
is you can list all the jobs.

00:53:52.050 --> 00:53:57.040
You can look at its environment-- whoops.

00:53:59.360 --> 00:54:01.010
Yeah, export is one way of doing that.

00:54:01.250 --> 00:54:07.480
But if you wanted to, for example,
set mv foo bar, now you can get mv foo.

00:54:07.810 --> 00:54:09.950
And that came all the way from launchd.

00:54:10.090 --> 00:54:13.430
We set it over there, it came back,
and you can even unset it,

00:54:13.430 --> 00:54:16.850
which is useful for any job
launching out of launchd,

00:54:16.910 --> 00:54:21.570
if you want to just have it set globally,
not have to set it in every plist.

00:54:22.410 --> 00:54:27.760
You can do things like adjust
launchd's limits if maybe you

00:54:27.770 --> 00:54:32.660
want to turn core dumps on and not
have to do it on a per job basis.

00:54:32.710 --> 00:54:36.520
You can use the launchctl
command to adjust launchd itself.

00:54:36.560 --> 00:54:43.860
Here's what launchd is logging,
the following log levels.

00:54:43.880 --> 00:54:47.440
If you wanted to adjust its logging,
you can use the log command,

00:54:47.440 --> 00:54:50.140
log level debug.

00:54:51.110 --> 00:54:54.490
and now it's going to log debug messages.

00:55:03.000 --> 00:55:05.000
Let's see, help.

00:55:05.010 --> 00:55:09.030
But all these things here are adjusting
launchd to kind of a global level,

00:55:09.070 --> 00:55:11.190
not at a per job level.

00:55:11.880 --> 00:55:13.770
You can also, oh,
one of my favorite things to

00:55:13.840 --> 00:55:18.300
demonstrate is if we use the
lsof command to look at launchd,

00:55:18.360 --> 00:55:21.900
you can see the standard out
and standard error are dev null,

00:55:21.900 --> 00:55:31.510
whereas now we can use launchctl
standard out var log launchd dot launchd.

00:55:32.000 --> 00:55:43.700
[Transcript missing]

00:55:44.060 --> 00:55:47.950
We can see that those files are
now indeed opened up to that.

00:55:47.960 --> 00:55:51.460
And now any daemon that launches
at a launchd that doesn't manually

00:55:51.460 --> 00:55:56.580
override its standard out and standard
error will inherit this log file,

00:55:56.580 --> 00:56:02.940
which can be useful sometimes if
you just want to get the standard

00:56:02.940 --> 00:56:02.940
out and standard error of every
background process on the system.

00:56:03.400 --> 00:56:06.010
So I think that's it for doing a demo.

00:56:06.110 --> 00:56:12.290
If we can get back to the slides.

00:56:15.300 --> 00:56:19.750
So for more information,
we have documents, sample code,

00:56:19.770 --> 00:56:23.040
and other resources available
at the following URL.

00:56:23.840 --> 00:56:30.820
and we should talk to Craig Keithley at,
there's his email address.
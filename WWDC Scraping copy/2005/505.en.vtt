WEBVTT

00:00:02.530 --> 00:00:03.500
Good afternoon.

00:00:03.500 --> 00:00:11.740
There we go.

00:00:11.740 --> 00:00:12.710
My name is Dean Reece.

00:00:12.750 --> 00:00:15.680
I'm the manager of the I/O Kit team.

00:00:15.680 --> 00:00:19.090
Some of you have probably seen me do
a similar presentation in the past,

00:00:19.090 --> 00:00:22.010
some maybe a first year here at WWDC.

00:00:22.020 --> 00:00:24.060
I'd like to have a quick show of hands.

00:00:24.060 --> 00:00:27.990
How many here have written a kernel
extension or I/O Kit driver for

00:00:27.990 --> 00:00:31.060
Mac OS X already or has one in process?

00:00:31.060 --> 00:00:32.100
Okay.

00:00:32.100 --> 00:00:34.500
How many people have not written
one and are wanting to learn a

00:00:34.500 --> 00:00:36.540
little bit about how to write them?

00:00:37.400 --> 00:00:37.890
All right, good.

00:00:37.900 --> 00:00:40.890
We have a mix of some
veterans and some new folks.

00:00:40.950 --> 00:00:43.270
Hopefully I've got some
good information for you.

00:00:43.270 --> 00:00:45.490
And let's go ahead and get started.

00:00:47.300 --> 00:00:49.200
So sort of the top level outline of
what I'm going to be talking about.

00:00:49.200 --> 00:00:53.300
I've broken the slides down
into four major groups.

00:00:53.360 --> 00:00:56.870
The structure for today's talk is really,
I think of it kind of

00:00:56.940 --> 00:00:58.080
like a travel journal.

00:00:58.210 --> 00:01:01.570
Over the last year, year and a half,
I've reviewed a number of

00:01:01.570 --> 00:01:06.380
kernel extensions both inside
Apple and third party extensions.

00:01:06.380 --> 00:01:09.100
And I've been sort of collecting
issues that I've seen.

00:01:09.100 --> 00:01:10.600
I've also been listening to questions.

00:01:10.770 --> 00:01:15.180
So this is really just a lot of these
questions and issues put together.

00:01:15.600 --> 00:01:18.560
Hopefully this will give you some
tips as to how you can improve

00:01:18.640 --> 00:01:20.300
your own kernel extensions.

00:01:20.300 --> 00:01:24.300
And again,
the categories are kind of broad.

00:01:24.300 --> 00:01:26.300
So if I ramble a little bit, I apologize.

00:01:26.300 --> 00:01:29.300
But again,
hopefully it will be useful for you.

00:01:29.300 --> 00:01:31.990
So first we'll talk a little
bit about binary compatibility.

00:01:31.990 --> 00:01:34.120
Obviously with the
Intel announcement on Monday,

00:01:34.180 --> 00:01:36.300
this is something that
will be interesting.

00:01:36.300 --> 00:01:39.300
I've got a little bit to
talk about about Intel.

00:01:39.300 --> 00:01:42.730
I don't have any slides on it,
but I do have some things

00:01:42.730 --> 00:01:44.300
I do want to tell you.

00:01:44.300 --> 00:01:46.300
So I'm going to talk a little bit
about kernel extension debugging.

00:01:46.300 --> 00:01:52.300
We have some new stuff as well as talk
a little bit about what's already there.

00:01:52.300 --> 00:01:55.300
And I spend a little bit of
time talking about performance.

00:01:55.300 --> 00:01:57.590
Hopefully you'll be able to take
some of this back and look at your

00:01:57.590 --> 00:02:01.290
kernel extension and maybe be able
to make it a little bit tighter.

00:02:01.300 --> 00:02:02.630
And also reliability.

00:02:02.630 --> 00:02:06.030
There's a few issues we've seen
and there's also some techniques

00:02:06.030 --> 00:02:09.300
you can use to make your
kernel extension more reliable.

00:02:10.660 --> 00:02:13.930
So this is the obligatory
"You are here" slide,

00:02:13.930 --> 00:02:17.200
just to give you an idea of sort
of the layer of technology that

00:02:17.200 --> 00:02:18.600
we'll be talking about today.

00:02:18.740 --> 00:02:22.800
If you see here, the large purple box
represents the entire kernel,

00:02:22.800 --> 00:02:27.160
and of course it hosts a number
of libraries and frameworks

00:02:27.220 --> 00:02:28.520
that applications link against.

00:02:28.610 --> 00:02:31.870
But within the kernel,
where I'm really going to be talking,

00:02:31.920 --> 00:02:34.580
it's divided into three
major plug-in spaces.

00:02:34.600 --> 00:02:38.580
We have file systems and networking,
which fit within the BSD universe,

00:02:38.640 --> 00:02:41.600
and then we have device
drivers and families,

00:02:41.600 --> 00:02:43.600
which fit within I/O Kit.

00:02:43.610 --> 00:02:45.680
And of course,
underpinnings for all of that

00:02:45.800 --> 00:02:49.420
include the Mach kernel and libkern,
which libkern, I think,

00:02:49.580 --> 00:02:52.600
is the closest analog
to libc that we have.

00:02:52.600 --> 00:02:55.570
For those of you new to
kernel development Mac OS X,

00:02:55.600 --> 00:02:59.650
the only framework that you
can use for developing kernel

00:02:59.670 --> 00:03:01.550
extensions is the kernel framework.

00:03:01.680 --> 00:03:03.440
Any other libraries,
any headers you get anywhere

00:03:03.440 --> 00:03:04.600
else are not going to be used.

00:03:04.600 --> 00:03:07.430
suitable for Kernel
Extension development.

00:03:07.840 --> 00:03:09.960
So kernel framework.

00:03:09.990 --> 00:03:12.420
So we'll start talking
about binary compatibility,

00:03:12.500 --> 00:03:16.020
excuse me,
binary compatibility a little bit.

00:03:16.020 --> 00:03:18.110
The good news is,
KEXT management hasn't really changed

00:03:18.170 --> 00:03:19.650
in a significant way for Tiger.

00:03:19.820 --> 00:03:24.080
And in fact, it isn't changing in a
significant way for Intel either.

00:03:24.080 --> 00:03:28.260
So we have spent some time improving
the KEXT cache and validation logic.

00:03:28.260 --> 00:03:31.020
Some of you may have encountered
bugs where you would install a

00:03:31.020 --> 00:03:35.070
kernel extension and the caching
mechanism didn't notice it.

00:03:35.070 --> 00:03:41.640
The publicly described way of making sure
the caching mechanism updates correctly

00:03:41.640 --> 00:03:44.860
is to touch system library extensions.

00:03:44.860 --> 00:03:50.380
The modified date on that folder is all
the cache system needs in order to know

00:03:50.380 --> 00:03:53.010
that it needs to rebuild its caches.

00:03:53.040 --> 00:03:55.110
But I've also seen a
number of people say,

00:03:55.190 --> 00:03:57.700
"Well, if you go and remove the caches,
everything will be

00:03:57.700 --> 00:03:59.870
fine." And in the past,
there have been workarounds

00:03:59.870 --> 00:04:01.640
that was a necessary workaround.

00:04:01.640 --> 00:04:02.640
For Tiger and going forward,
I think it's important to have a

00:04:02.640 --> 00:04:03.010
system library extension that's
really clear and easy to use.

00:04:03.090 --> 00:04:03.640
And then you can go back
and see what's going on.

00:04:03.640 --> 00:04:04.120
And then you can go back
and see what's going on.

00:04:04.120 --> 00:04:04.750
And then you can go back
and see what's going on.

00:04:04.790 --> 00:04:05.250
And then you can go back
and see what's going on.

00:04:05.250 --> 00:04:05.980
But it's not just the caching
system that's changing.

00:04:06.010 --> 00:04:06.640
It's the cache system
that's being removed.

00:04:06.640 --> 00:04:06.950
It's the cache system
that's being removed.

00:04:06.950 --> 00:04:07.640
And so I think it's important
to be aware of that.

00:04:07.640 --> 00:04:08.230
And I'm sure that there are some
other things that you can do to

00:04:08.230 --> 00:04:09.640
make sure that you're not just
going to be removing the caches.

00:04:09.640 --> 00:04:09.740
But in fact, the caching system for
every major release of the

00:04:09.890 --> 00:04:11.210
OS has changed in some ways.

00:04:11.210 --> 00:04:13.970
And so removing the cache may
be an incomplete solution.

00:04:13.970 --> 00:04:17.120
I have seen people ship products
that had incomplete cache removal,

00:04:17.120 --> 00:04:20.640
which led to some interesting problems
because it worked fine in Panther and

00:04:20.640 --> 00:04:22.340
then didn't work somewhere else.

00:04:22.340 --> 00:04:27.620
So touch system library extensions is the
approved way of letting the system know

00:04:27.620 --> 00:04:30.430
you've installed or modified a cache.

00:04:30.440 --> 00:04:34.740
And if you find that that's not
invalidating the caches correctly,

00:04:34.740 --> 00:04:35.910
file a bug report.

00:04:35.910 --> 00:04:38.800
It always, in every circumstance,
needs to.

00:04:39.350 --> 00:04:41.680
Now, of course,
you need to restart the system after

00:04:41.690 --> 00:04:45.910
you've installed a kernel extension,
but as of 10.3,

00:04:45.910 --> 00:04:50.290
and of course in Tiger as well,
you actually can signal Kexty and

00:04:50.290 --> 00:04:52.540
have it rescan the extensions folder.

00:04:52.570 --> 00:04:55.690
And what'll happen is if that driver,
the driver that you

00:04:55.690 --> 00:04:58.770
installed or modified,
can be loaded against the hardware,

00:04:58.800 --> 00:04:59.440
it will be.

00:04:59.480 --> 00:05:03.290
So this is an opportunity for you
to have a better user experience

00:05:03.820 --> 00:05:06.840
if you have a kernel extension
being installed for the first time,

00:05:06.860 --> 00:05:10.200
or the user has the ability
to say unplug a USB device and

00:05:10.200 --> 00:05:13.980
plug it back in where the driver
would be unloaded and reloaded,

00:05:14.030 --> 00:05:18.060
then the system can basically immediately
make use of your updated driver.

00:05:18.200 --> 00:05:21.350
If you have a driver for say a
PCI card that you're rooted off

00:05:21.450 --> 00:05:24.280
of and it can't be unloaded,
then you are going to have to reboot

00:05:24.310 --> 00:05:26.180
to get your kernel extension in.

00:05:26.220 --> 00:05:30.540
So there's a Q&A note there, QA 1319,
that you ought to have a look

00:05:30.540 --> 00:05:31.580
at if you're interested in this.

00:05:31.580 --> 00:05:34.970
It will give you the details
of how to go about doing it.

00:05:39.000 --> 00:05:40.860
Now I'm sure you've heard about KPIs.

00:05:41.020 --> 00:05:42.360
How does this affect you?

00:05:42.380 --> 00:05:46.320
Well, one of the issues that we had
with the kernel is we didn't

00:05:46.320 --> 00:05:47.930
really have formal interfaces.

00:05:48.040 --> 00:05:50.400
We had a number of symbols
you could link against,

00:05:50.400 --> 00:05:53.480
a lot of things you could call,
data that you could query,

00:05:53.520 --> 00:05:57.940
and it was a bit of a maintenance
nightmare for us because every

00:05:57.940 --> 00:06:00.940
time we changed something that
was necessary to improve the

00:06:00.940 --> 00:06:04.150
system or bring out a new feature,
we would invariably break some

00:06:04.150 --> 00:06:05.600
number of kernel extensions.

00:06:05.650 --> 00:06:07.860
Now I/O Kit was designed
from the ground up.

00:06:07.950 --> 00:06:10.200
It was a brand new thing
that Apple invented,

00:06:10.220 --> 00:06:13.760
and so those interfaces were
fairly clean and we've been able

00:06:13.780 --> 00:06:15.660
to stand by those fairly well.

00:06:15.790 --> 00:06:20.470
With the BSD interfaces, however,
there's a lot of legacy code there.

00:06:20.600 --> 00:06:23.200
We've obviously upgraded
it tremendously at Apple,

00:06:23.320 --> 00:06:25.500
and we needed to come up with
a nice clean interface for you,

00:06:25.500 --> 00:06:28.290
and the KPIs are the way to do this.

00:06:28.410 --> 00:06:30.790
So within I/O Kit and Libkern,
the functionality is

00:06:30.790 --> 00:06:32.940
pretty much the same,
or in Libkern's case,

00:06:32.940 --> 00:06:34.990
it's actually expanded a good bit.

00:06:35.080 --> 00:06:38.420
So if you were limiting yourself
to I/O Kit and Libkern before,

00:06:38.530 --> 00:06:42.300
you'll probably be absolutely
fine in Tiger and going forward.

00:06:42.470 --> 00:06:45.480
Within BSD and Mach, however,
we've actually eliminated a

00:06:45.480 --> 00:06:48.790
large number of symbols because
they represented functions we

00:06:48.810 --> 00:06:50.900
couldn't maintain going forward.

00:06:50.900 --> 00:06:54.440
So I'm only going to talk
a little bit about KPIs,

00:06:54.650 --> 00:06:58.570
but the main thing as far as
rules of engagement for KPIs,

00:06:58.950 --> 00:07:02.610
The two namespaces,
the pre-KPI namespace we call

00:07:02.630 --> 00:07:07.710
the compatibility cache or
compatibility namespace is not

00:07:07.710 --> 00:07:10.960
mixable with the KPI namespace.

00:07:11.060 --> 00:07:16.060
So your kernel extension either
needs to link with all of the

00:07:16.060 --> 00:07:18.700
older compatibility symbols,
that would be versions

00:07:18.700 --> 00:07:18.700
prior to version 8.0.

00:07:19.070 --> 00:07:22.810
The two namespaces,
the pre-KPI namespace we call

00:07:22.810 --> 00:07:27.910
the compatibility cache or
compatibility namespace is not

00:07:27.910 --> 00:07:31.150
mixable with the KPI namespace.

00:07:31.170 --> 00:07:32.880
So your kernel extension either
needs to link with all of the

00:07:32.880 --> 00:07:32.880
older compatibility symbols,
that would be versions

00:07:32.880 --> 00:07:32.880
prior to version 8.0.

00:07:34.140 --> 00:07:37.550
I should point out that there's
a lab as well that will help you

00:07:37.700 --> 00:07:41.370
port specifically file systems,
but it will help you sort of explore

00:07:41.370 --> 00:07:43.710
the new KPIs if you haven't yet.

00:07:43.800 --> 00:07:46.980
So that's tomorrow at 3:30.

00:07:48.320 --> 00:07:50.250
Now, of course,
this brings one very obvious

00:07:50.250 --> 00:07:53.830
question is if I have to support
multiple releases of Mac OS X,

00:07:53.880 --> 00:07:54.530
how can I do that?

00:07:54.640 --> 00:07:56.200
Can I do it with one kernel extension?

00:07:56.200 --> 00:07:59.200
And the answer is, of course, it depends.

00:07:59.200 --> 00:08:01.180
So we'll talk about that.

00:08:01.280 --> 00:08:06.200
So with KPIs, how do I release one text
across multiple OS releases?

00:08:06.220 --> 00:08:09.170
So if you can use the
compatibility libraries,

00:08:09.380 --> 00:08:13.190
version 799 and prior,
then that one kernel extension

00:08:13.200 --> 00:08:17.200
should be able to work on both
Tiger and previous OS releases.

00:08:17.200 --> 00:08:20.200
Obviously, you'll have to try it and see.

00:08:20.310 --> 00:08:22.630
But if it does fail to load,
the most likely reason that it will

00:08:22.630 --> 00:08:24.190
fail to load is an undefined symbol.

00:08:24.200 --> 00:08:26.980
If you use kextload with
one of the verbose options,

00:08:26.980 --> 00:08:29.200
it'll tell you exactly what symbols.

00:08:29.200 --> 00:08:33.410
And probably what's happened is
we've made that symbol unavailable

00:08:33.430 --> 00:08:36.680
in Tiger through the KPIs,
in which case you will

00:08:36.680 --> 00:08:38.630
need to port your driver.

00:08:41.000 --> 00:10:01.500
[Transcript missing]

00:10:02.000 --> 00:10:05.140
So again, just to kind of graphically
illustrate the nesting here,

00:10:05.250 --> 00:10:08.000
these are two separate kernel extensions.

00:10:08.000 --> 00:10:10.560
As you can see, the dependencies here,
some of them are on,

00:10:10.640 --> 00:10:15.400
the red one is on 8.0 and
the blue one is on 7.0.

00:10:15.640 --> 00:10:19.600
You can nest the older driver
inside the newer driver or the

00:10:19.600 --> 00:10:22.700
other way around if you prefer by
simply creating a plugins folder.

00:10:22.700 --> 00:10:26.340
There's ample examples of
this on Mac OS X itself.

00:10:26.340 --> 00:10:30.340
You can certainly examine the extensions
folder and see how this is done.

00:10:34.800 --> 00:10:38.780
And to talk a little bit about what we
mean when we say binary compatibility,

00:10:38.780 --> 00:10:42.380
this question's come up quite a bit.

00:10:42.380 --> 00:10:44.540
I know I've addressed it
in mail lists and so on,

00:10:44.540 --> 00:10:46.320
but I'll state it here
just for the record.

00:10:46.460 --> 00:10:51.190
So we consider backward compatibility
the ability to load an existing

00:10:51.220 --> 00:10:55.030
kernel extension on newer OS releases,
right?

00:10:55.270 --> 00:11:00.340
So as we roll along and come out with new
software updates or new major releases,

00:11:00.360 --> 00:11:03.190
ideally your kernel extension continues
to load and be useful to the user.

00:11:03.190 --> 00:11:06.800
And we certainly put a lot of
effort in not breaking you.

00:11:06.870 --> 00:11:09.630
We call forward compatibility
the opposite of that,

00:11:09.630 --> 00:11:13.790
the ability to load a new driver on an
older release of an operating system.

00:11:13.850 --> 00:11:16.000
I/O Kit does not provide
forward compatibility.

00:11:16.000 --> 00:11:20.760
We have some active binary compatibility
mechanisms that assume that the

00:11:20.880 --> 00:11:24.700
Vtable is specifically Vtable related,
but the classes that you're

00:11:24.700 --> 00:11:28.840
loading in your KEXT need to be
less than or equal to what are

00:11:28.880 --> 00:11:31.500
already present in the kernel.

00:11:31.500 --> 00:11:35.170
So we don't support forward
compatibility with kernel extensions.

00:11:35.320 --> 00:11:37.790
We also don't guarantee
source compatibility.

00:11:37.800 --> 00:11:38.980
This is very important.

00:11:39.000 --> 00:11:42.820
Again,
it's a question that's come up before.

00:11:43.240 --> 00:11:45.930
We go to some great lengths
to avoid breaking you.

00:11:46.070 --> 00:11:48.150
We really understand that
it's painful to bring your

00:11:48.150 --> 00:11:49.590
source forward if we break you.

00:11:49.590 --> 00:11:51.230
And in fact,
we have to bring all of our own

00:11:51.230 --> 00:11:54.660
drivers forward as well if we change
something that's going to break them.

00:11:55.080 --> 00:11:55.800
effort for us.

00:11:55.800 --> 00:11:58.150
So we only do it if
there's a good reason.

00:11:59.030 --> 00:12:02.900
One of those reasons would
be changing the compiler.

00:12:02.900 --> 00:12:05.400
This does happen and has in
fact happened with Tiger.

00:12:05.560 --> 00:12:09.400
So what compiler should you
use for kernel extensions?

00:12:09.670 --> 00:12:12.910
Well,
for the Intel development systems that

00:12:12.910 --> 00:12:17.810
go out that we've announced yesterday,
GCC4 is the compiler to use.

00:12:17.900 --> 00:12:19.850
That's, I believe,
the only compiler we're

00:12:19.850 --> 00:12:23.900
going to be supporting for
development on that platform.

00:12:23.900 --> 00:12:28.350
But for PowerPC,
you can of course use GCC3.3 as well.

00:12:28.400 --> 00:12:32.670
I'd recommend using GCC4 if you
can get your sources to build.

00:12:32.950 --> 00:12:34.870
There's a few subtle changes
that you'll have to make.

00:12:34.870 --> 00:12:37.900
They're typically not very hard.

00:12:37.900 --> 00:12:41.200
Also, a GCC4 built KEXT should be
able to load on older releases

00:12:41.200 --> 00:12:42.900
all the way back to 10.2.

00:12:42.910 --> 00:12:45.900
So we don't expect to
have problems there.

00:12:46.380 --> 00:12:51.380
Now, if any of you are still
compiling with GCC 295,

00:12:51.460 --> 00:12:54.860
please be warned,
we're going to stop supporting

00:12:54.860 --> 00:12:59.460
GCC 295 built drivers at some
major release in the near future.

00:12:59.520 --> 00:13:04.430
So it's basically provided now
only for support for your kernel

00:13:04.890 --> 00:13:09.910
extensions that were compiled
in the 10.1 or 10.0 timeframe.

00:13:10.590 --> 00:13:13.040
There's some extra steps we
have to go through to modify the

00:13:13.040 --> 00:13:16.900
binary at load time and those,
that particular system,

00:13:16.900 --> 00:13:19.190
the remangler will be going away.

00:13:19.190 --> 00:13:23.420
So please move forward to
GCC 3.3 or ideally 4.0.

00:13:24.780 --> 00:13:27.460
As I said before regarding
forward compatibility,

00:13:27.460 --> 00:13:31.800
what you need to use is the
oldest SDK that you plan to

00:13:31.830 --> 00:13:33.250
make your driver available for.

00:13:33.290 --> 00:13:36.870
So if you want to be
compatible back to 1028,

00:13:36.870 --> 00:13:39.090
please use the 1028 SDK.

00:13:39.440 --> 00:13:41.700
Another very important point
for binary compatibility,

00:13:41.700 --> 00:13:44.410
this one's subtle and has
bitten a number of people,

00:13:44.410 --> 00:13:47.040
is the OS define and OS declare macros.

00:13:47.240 --> 00:13:48.100
These are very important.

00:13:48.100 --> 00:13:50.580
This is part of our binary
compatibility system.

00:13:50.580 --> 00:13:54.940
The Vtable patcher looks at the
information laid down by these macros,

00:13:54.940 --> 00:13:57.590
and that's what it uses to
patch up your Vtable and make

00:13:57.700 --> 00:13:59.460
it work with the running system.

00:13:59.590 --> 00:14:03.610
If you don't put these in correctly
for every class you define,

00:14:03.790 --> 00:14:05.530
at least the ones that
inherit from OSObject,

00:14:05.580 --> 00:14:10.180
then at some point in the future,
your kernel extension will fail to

00:14:10.190 --> 00:14:14.010
load because the vTable patcher won't
have any work to do if you're building

00:14:14.010 --> 00:14:15.540
and running on the same release.

00:14:15.540 --> 00:14:18.740
But if you're building on an old
release and running on a new release,

00:14:18.740 --> 00:14:19.730
it does have work to do.

00:14:19.760 --> 00:14:24.100
So in this regard,
the IOService class did change in Tiger.

00:14:24.100 --> 00:14:27.640
So if you have built a kernel
extension on Panther and you try to

00:14:27.640 --> 00:14:30.790
load it on Tiger and you get this,
your class is not compatible

00:14:30.790 --> 00:14:35.510
with its superclass message,
at kexload time, then you're probably

00:14:35.510 --> 00:14:36.580
being bitten by this.

00:14:36.580 --> 00:14:38.680
You need to make sure you've
implemented these macros correctly.

00:14:43.770 --> 00:14:46.980
So moving to GCC 4.0, as I said,
is recommended.

00:14:46.990 --> 00:14:50.080
It is a little bit more
strict with C++ code.

00:14:50.200 --> 00:14:52.650
A few things that were warnings
in the past are now fatal.

00:14:52.750 --> 00:14:54.320
There's some new warnings.

00:14:54.350 --> 00:14:56.220
So it may take you a
little bit of work to do,

00:14:56.220 --> 00:14:57.460
but it's not too bad.

00:14:57.480 --> 00:15:00.590
One common problem, though,
is casting member functions

00:15:01.600 --> 00:15:03.010
to C function pointers.

00:15:03.020 --> 00:15:06.180
And we use this in
I/O Kit a lot for callbacks,

00:15:06.240 --> 00:15:09.160
for our target action
parameter callbacks.

00:15:09.200 --> 00:15:15.220
So we've introduced in Tiger a new
API called OS Member Function Cast.

00:15:15.250 --> 00:15:18.540
And basically,
this is something that's there to allow

00:15:18.540 --> 00:15:22.500
you to do the casting without having
to worry about the compiler details.

00:15:22.540 --> 00:15:28.400
So this eliminates the unavoidable
build failure in GCC 4.0.

00:15:28.400 --> 00:15:30.680
As a caveat,
I will say you will see one warning.

00:15:30.680 --> 00:15:32.600
With the set of headers
that we shipped in Tiger,

00:15:32.630 --> 00:15:34.930
there will be one warning generated.

00:15:35.040 --> 00:15:35.790
Don't worry about it.

00:15:35.800 --> 00:15:37.040
It's actually OK.

00:15:37.080 --> 00:15:41.680
And if you're-- really want to get
rid of every warning in your code,

00:15:41.710 --> 00:15:44.720
send out email on the Darwin Dev List,
and we'll tell you the minor

00:15:44.720 --> 00:15:46.540
tweak to do to get rid of that.

00:15:46.610 --> 00:15:47.540
But it's harmless.

00:15:47.550 --> 00:15:49.480
Also, it allows you to get rid
of the F permissive flag.

00:15:49.480 --> 00:15:52.380
If the only reason you had to have
this before is because of the casting,

00:15:52.490 --> 00:15:55.120
you can finally get rid of that.

00:15:56.200 --> 00:16:15.600
[Transcript missing]

00:16:19.830 --> 00:16:21.930
All right, let's move on to kernel
extension debugging.

00:16:21.940 --> 00:16:29.540
So a lot of people continue to do
kernel development on single machine.

00:16:29.540 --> 00:16:31.160
It's not what we recommend.

00:16:31.160 --> 00:16:34.400
We are aware, of course,
that people do this and we've

00:16:34.480 --> 00:16:37.080
actually added some stuff in
Tiger to hopefully make it easier.

00:16:37.540 --> 00:16:41.530
Just sort of to sell you away
from single machine debugging,

00:16:41.530 --> 00:16:42.970
it's definitely a slower cycle time.

00:16:43.020 --> 00:16:46.980
If you're developing on a machine,
you load the text and you have to reboot,

00:16:46.980 --> 00:16:49.840
I would very strongly urge you,
whether you're doing single

00:16:49.850 --> 00:16:52.260
or dual machine debugging,
as soon as you get your driver

00:16:52.260 --> 00:16:56.140
up and kind of limping along,
make it a priority to make

00:16:56.140 --> 00:16:58.230
it unloadable cleanly.

00:16:58.400 --> 00:17:00.900
And at every stage of your development,
make sure it unloads cleanly

00:17:00.900 --> 00:17:02.980
because that's a good sign
that you're not leaking things.

00:17:02.980 --> 00:17:05.240
Basically,
if you can't unload your kernel

00:17:05.240 --> 00:17:08.540
extension and you don't know why,
it probably means you've got some

00:17:08.540 --> 00:17:11.190
references outstanding that you
really ought to be cleaning up.

00:17:12.180 --> 00:17:14.510
But certainly on single
machine debugging,

00:17:14.520 --> 00:17:16.770
that's a real win,
being able to load and unload.

00:17:16.770 --> 00:17:20.200
Now, of course,
you won't always get the opportunity

00:17:20.200 --> 00:17:21.770
to unload because it will panic some.

00:17:21.770 --> 00:17:25.730
And when that happens, of course,
you're risking data corruption.

00:17:25.840 --> 00:17:29.080
We try very hard, of course,
on a panic to not lose your data,

00:17:29.080 --> 00:17:32.030
but if you have uncommitted data
in a write buffer somewhere,

00:17:32.060 --> 00:17:33.770
it will not get to disk.

00:17:33.940 --> 00:17:37.520
So, if you're doing development on the
same system that you're testing on,

00:17:37.520 --> 00:17:38.730
back up your data and

00:17:39.360 --> 00:17:42.040
Just, you know, good common sense there.

00:17:42.090 --> 00:17:43.870
But we also,
as you probably are well aware,

00:17:43.920 --> 00:17:45.900
we don't have any local
kernel debugger support.

00:17:45.930 --> 00:17:49.090
You can't debug the kernel on
the machine that you're running.

00:17:53.100 --> 00:17:55.500
If we can save the questions
for a Q&A at the end,

00:17:55.500 --> 00:17:58.560
I'll be happy to address that.

00:17:58.560 --> 00:18:01.120
So a little more on
single machine debugging.

00:18:01.160 --> 00:18:04.350
A lot of you have used
I/O Log for debugging.

00:18:04.360 --> 00:18:07.130
It is very useful to kind of
figure out the flow of code and,

00:18:07.130 --> 00:18:09.360
you know, is this function getting
called and if so,

00:18:09.480 --> 00:18:10.600
what's the parameter?

00:18:10.600 --> 00:18:14.330
It's certainly a first line of
defense for any kind of effort

00:18:14.330 --> 00:18:16.180
to try to corner a problem.

00:18:16.190 --> 00:18:18.460
But keep in mind, it really is intended
as a logging service.

00:18:18.460 --> 00:18:20.720
It's not I/O debug, it's I/O log.

00:18:20.720 --> 00:18:23.640
And it's intended to be very,
very low cost to the system.

00:18:23.640 --> 00:18:27.300
So that's why there's only a
4K buffer and syslogd only runs

00:18:27.300 --> 00:18:31.280
periodically to pull data out of
it and store it off to the file.

00:18:31.280 --> 00:18:35.050
So the reason that you can overflow
it pretty easily is that's by design.

00:18:35.060 --> 00:18:36.940
It's a low bandwidth logging service.

00:18:36.940 --> 00:18:37.940
And it's also not synchronous.

00:18:37.940 --> 00:18:40.680
It's not, you know,
it's within a few seconds but

00:18:40.750 --> 00:18:42.780
it's certainly not synchronous.

00:18:42.780 --> 00:18:45.320
Now if you really want
to use it synchronously,

00:18:45.320 --> 00:18:45.960
you can.

00:18:45.960 --> 00:18:48.820
You can make it synchronous
with this boot arg.

00:18:48.820 --> 00:18:50.700
So you can use the end of your
RAM command to set your boot.

00:18:50.700 --> 00:18:54.260
And you can use the boot arg,
I/O equals 200,000 hex.

00:18:54.260 --> 00:18:57.360
And actually you can look in I/O Kit,
I/O Kit debug.h and there's a

00:18:57.360 --> 00:19:00.690
whole list of bits in there for
subsystems that will log additional

00:19:00.690 --> 00:19:02.470
information if you care to see it.

00:19:02.550 --> 00:19:06.450
But this particular bit,
the 200,000 will turn I/O logs

00:19:06.530 --> 00:19:09.960
and I believe also printfs into
synchronous writes to the console.

00:19:10.080 --> 00:19:12.120
That's very important.

00:19:12.120 --> 00:19:15.360
Writes to the console means the
actual screen that you're using.

00:19:15.360 --> 00:19:18.940
So this is the, you know,
white text on the black background that

00:19:18.940 --> 00:19:20.680
we used to see with panic messages.

00:19:20.680 --> 00:19:22.900
This is back in the day.

00:19:22.900 --> 00:19:26.580
Now if you want to get to the console,
there's a bit that you can

00:19:26.610 --> 00:19:29.460
set in the boot arg again
to force that all the time.

00:19:29.540 --> 00:19:30.660
But it's very simple.

00:19:30.770 --> 00:19:33.360
At the login prompt,
you just type greater than console

00:19:33.360 --> 00:19:36.900
for the user name and that will
exit the Windows server and

00:19:36.900 --> 00:19:39.320
put you into the console mode.

00:19:39.320 --> 00:19:43.680
And then you can do whatever thing
you need to do to trigger the problem.

00:19:43.680 --> 00:19:48.100
And you'll see synchronous I/O logs
coming out on the console scrolling.

00:19:50.390 --> 00:19:51.820
We also added two new APIs.

00:19:51.870 --> 00:19:54.150
This has been requested on and off.

00:19:54.150 --> 00:19:58.190
The primary one here is called
OS Report with Backtrace.

00:19:58.190 --> 00:20:02.870
What this does is it gives you a
backtrace of the four prior stack frames,

00:20:03.080 --> 00:20:06.810
that is prior to calling this,
and it allows you to see how you

00:20:06.810 --> 00:20:08.700
got into a particular function.

00:20:08.730 --> 00:20:12.320
Let's say your function keeps
getting calls with some bogus value

00:20:12.320 --> 00:20:15.740
and you want to understand what the
call graph was that got you there.

00:20:15.760 --> 00:20:19.980
This will just log as a normal
I/O log those four stack frames,

00:20:20.020 --> 00:20:22.610
but it returns, unlike panic.

00:20:24.320 --> 00:20:28.120
So if you need more stack
frames deep or if you want to

00:20:28.120 --> 00:20:30.090
do some more complicated logic,
you know,

00:20:30.090 --> 00:20:33.820
if you're trying to implement a logic
analyzer in your kernel extension,

00:20:33.820 --> 00:20:35.460
you can use the OS backtrace below.

00:20:35.460 --> 00:20:39.140
That's really the guts of
OS report with backtrace.

00:20:39.140 --> 00:20:42.180
And this simply gives
you an array of pointers,

00:20:42.180 --> 00:20:44.020
an array of stack frames.

00:20:44.020 --> 00:20:46.360
So you can pass in as deep as you want.

00:20:46.360 --> 00:20:48.590
You could get 20 frames,
and if they're there, it'll give you the

00:20:48.610 --> 00:20:49.620
address of all of them.

00:20:49.620 --> 00:20:54.050
So you could use that to do statistical
analysis on your call graph.

00:20:54.060 --> 00:20:55.330
You could do all sorts of things.

00:20:55.440 --> 00:20:57.660
But the top one there is great,
particularly if you are

00:20:57.680 --> 00:21:00.310
single machine debugging,
because you don't have to take

00:21:00.410 --> 00:21:04.490
a panic to cause something
interesting to get logged out.

00:21:05.320 --> 00:21:09.940
Now again, these functions have no
place in commercial code.

00:21:09.990 --> 00:21:15.180
Make sure that they get FDFed out,
compiled out in production code.

00:21:17.400 --> 00:21:49.700
[Transcript missing]

00:21:49.960 --> 00:21:52.960
Now you need to start by,
and this is true really for any kind

00:21:52.960 --> 00:21:56.440
of a GDB work that you're going to
be doing on Mac OS X in the kernel,

00:21:56.440 --> 00:21:59.610
you need to download the appropriate
kernel debug kit from the

00:21:59.700 --> 00:22:01.650
Apple Developer Connection website.

00:22:01.890 --> 00:22:05.180
We get these out as quickly as
we can after each new release or

00:22:05.180 --> 00:22:07.360
software update that has a new kernel.

00:22:07.420 --> 00:22:09.500
And it has what we
call a symboled kernel.

00:22:09.610 --> 00:22:12.470
For those of you that don't know,
it's sort of a byproduct

00:22:12.470 --> 00:22:13.640
of the build process.

00:22:13.660 --> 00:22:15.990
It's the same binary
that's on the system,

00:22:16.050 --> 00:22:18.320
but it has a tremendous amount
of debugging information in it,

00:22:18.430 --> 00:22:19.690
the line numbers and everything.

00:22:19.790 --> 00:22:23.840
The kernels are huge, but again,
it's loaded with information.

00:22:23.990 --> 00:22:27.000
If you debug using the kernel
that's on your system already,

00:22:27.170 --> 00:22:32.660
what you're going to see is addresses
relative to the nearest global function.

00:22:32.920 --> 00:22:36.360
So you're going to see some
global function like bcopy,

00:22:36.360 --> 00:22:40.060
and the offset you see might be,
I don't know,

00:22:40.120 --> 00:22:43.150
several hundred k off of that because
there are several intervening static

00:22:43.240 --> 00:22:45.600
functions that got stripped out,
and those symbols are not

00:22:45.600 --> 00:22:46.900
in the shipping kernel.

00:22:46.950 --> 00:22:49.580
But the symboled kernel has all those,
so it'll give you, tell you exactly what

00:22:49.580 --> 00:22:51.650
function you're dying in.

00:22:52.170 --> 00:22:55.410
Now, of course,
you'll have to also build symbol

00:22:55.410 --> 00:22:58.660
versions of kernel extensions
for any keks that you've built,

00:22:58.670 --> 00:22:58.840
right?

00:22:58.920 --> 00:23:03.500
Anything that--any kernel extension
that you're loading yourself,

00:23:03.560 --> 00:23:05.200
there are a variety of ways to do this.

00:23:05.200 --> 00:23:09.380
You can have the keks loader drop the
symbols at the time that it loads them.

00:23:09.650 --> 00:23:11.700
If you're debugging a
panic after the fact,

00:23:11.700 --> 00:23:15.000
you can generate them
given the load address.

00:23:15.090 --> 00:23:18.330
But again, the tech note gives you
the details on that.

00:23:18.810 --> 00:23:21.120
Once you have those pieces
and you run GDB on it,

00:23:21.250 --> 00:23:23.380
you can start to examine things.

00:23:23.380 --> 00:23:28.520
X/I means basically examine memory as
an integer and you pass it an address,

00:23:28.520 --> 00:23:30.500
or excuse me, an instruction.

00:23:30.580 --> 00:23:32.720
X/X would be for integer.

00:23:32.720 --> 00:23:35.620
X/I means examine it as an instruction.

00:23:35.620 --> 00:23:38.540
You give it the address and it
shows you the instruction as

00:23:38.540 --> 00:23:40.980
well as what function it's in.

00:23:40.980 --> 00:23:44.870
Remember though, look at PC and LR,
the program counter and the link

00:23:44.870 --> 00:23:48.210
register are the most recent things
that would have been executed.

00:23:48.360 --> 00:23:50.780
But for all of the addresses you're
getting from the stack crawl,

00:23:51.040 --> 00:23:52.660
remember that's the return address.

00:23:52.660 --> 00:23:55.960
That's the address that the processor
would execute next when it returned.

00:23:55.960 --> 00:23:57.460
So remember to subtract four.

00:23:57.460 --> 00:24:00.320
That's the branching off
point that got you there.

00:24:00.320 --> 00:24:02.520
And then because we're
talking about I/O Kit,

00:24:02.520 --> 00:24:05.180
we're also talking about C++,
you're going to be getting

00:24:05.180 --> 00:24:08.480
symbols that look like this,
the underbar, underbar, Z symbols.

00:24:08.480 --> 00:24:09.600
Those are the mangled symbols.

00:24:09.600 --> 00:24:14.280
They basically contain encoded
information about arguments and so on.

00:24:14.280 --> 00:24:17.180
So if you run that through C++ Filt,
it can convert it into

00:24:17.210 --> 00:24:17.740
a nicely readable file.

00:24:17.740 --> 00:24:19.430
readable form there.

00:24:19.430 --> 00:24:22.690
So that's a handy thing to do.

00:24:23.890 --> 00:24:26.930
Now for two-machine debugging,
this is really the way to fly.

00:24:27.050 --> 00:24:29.260
If you can at all do this,
I strongly recommend it.

00:24:29.350 --> 00:24:32.300
We've added some capabilities
in Tiger recently,

00:24:32.300 --> 00:24:33.210
we'll talk about that.

00:24:33.490 --> 00:24:36.370
But obviously you have an
expendable target machine,

00:24:36.370 --> 00:24:39.030
your development machine
is safe and secure.

00:24:39.100 --> 00:24:42.120
I've known some people that set
up an environment where they

00:24:42.120 --> 00:24:46.240
actually NFS export the root
volume from their build machine,

00:24:46.300 --> 00:24:48.920
and so their target machine isn't
even running on a local disk,

00:24:48.920 --> 00:24:50.480
it's actually rooted off of that NFS.

00:24:50.780 --> 00:24:53.570
So it has no opportunity to
corrupt anything when it crashes,

00:24:53.730 --> 00:24:56.590
and it makes it easy to
copy kernel extensions up.

00:24:56.690 --> 00:25:00.040
So what'll happen is, as you move into a
two-machine environment,

00:25:00.100 --> 00:25:03.320
you'll develop some scripts and some
techniques for moving the kecks around,

00:25:03.410 --> 00:25:06.910
because it does involve RCPing
or moving kernel extensions

00:25:06.910 --> 00:25:10.380
over in your favorite way,
but it really is the way to fly.

00:25:10.480 --> 00:25:13.910
Now there are three ways to
attach to a target machine.

00:25:14.200 --> 00:25:17.030
Ethernet is the tried and true way that
we've been talking about for years.

00:25:17.040 --> 00:25:18.500
I'm not going to spend long on that.

00:25:19.140 --> 00:25:22.500
But we've added FireWire debugging.

00:25:22.500 --> 00:25:25.790
If you look into developer extras,
kernel debugging.

00:25:25.800 --> 00:25:27.920
You have to install, of course,
the software developer kit.

00:25:27.950 --> 00:25:32.500
But this allows you to connect to the
target machine via the FireWire cable.

00:25:32.500 --> 00:25:48.040
Now you have to install a piece
both on the target machine and

00:25:48.040 --> 00:25:57.080
on your development machine,
and you have to set up the

00:25:57.090 --> 00:25:58.070
link prior to the panic.

00:25:58.100 --> 00:25:58.760
So this doesn't save you if the
machine is panicked and you're

00:25:58.760 --> 00:25:59.110
trying to get the data off of it.

00:25:59.110 --> 00:25:59.730
You have to install a piece
both on the target machine and

00:25:59.730 --> 00:26:00.320
on your development machine,
and you have to set up the

00:26:00.320 --> 00:26:00.610
link prior to the panic.

00:26:00.610 --> 00:26:01.270
So this doesn't save you if the
machine is panicked and you're

00:26:01.270 --> 00:26:02.040
trying to get the data off of it.

00:26:02.040 --> 00:26:02.570
Now you have to install a piece
both on the target machine and

00:26:02.570 --> 00:26:03.050
on your development machine,
and you have to set up the

00:26:03.050 --> 00:26:03.420
link prior to the panic.

00:26:03.420 --> 00:26:09.830
So this doesn't save you if the
machine is panicked and you're

00:26:09.870 --> 00:26:13.460
trying to get the data off of it.

00:26:15.750 --> 00:26:19.590
So also with machine debugging
we have remote KPRNF.

00:26:20.150 --> 00:26:24.090
You can connect over serial if you
have a machine with a serial port.

00:26:24.270 --> 00:26:26.240
Not many machines
available like that today,

00:26:26.290 --> 00:26:29.600
but you could maybe with
a G4 with a stealth card.

00:26:29.620 --> 00:26:32.510
Firewire is really the
way to do it nowadays.

00:26:32.510 --> 00:26:36.570
Coming soon,
and I believe the very next Firewire SDK,

00:26:36.640 --> 00:26:39.600
there'll be the pieces that you
need in order to set this up.

00:26:39.600 --> 00:26:43.940
And you can have the target machine,
KPRNF,

00:26:43.940 --> 00:26:47.740
appear on a viewer on the test machine.

00:26:47.740 --> 00:26:50.060
And if you had attended the
Firewire session previously,

00:26:50.060 --> 00:26:51.600
they would have talked a
little bit more about this.

00:26:51.600 --> 00:26:55.600
But I believe that's coming in
the Firewire SDK version 20.

00:26:55.950 --> 00:26:59.520
That's similar to local logging,
except that it has some advantages.

00:26:59.580 --> 00:27:01.800
One of the big ones is
you can save your session.

00:27:01.890 --> 00:27:04.070
If you've logged 50 things,
you can cut and paste

00:27:04.070 --> 00:27:06.140
it into a bug report,
for example,

00:27:06.280 --> 00:27:09.500
or you can do searching on it,
which you can't do with a local console.

00:27:09.680 --> 00:27:12.800
Just yet another reason
to go to machine here.

00:27:12.800 --> 00:27:14.180
It's also a good bit faster.

00:27:14.180 --> 00:27:18.130
If you're going over Firewire,
it's a pretty fast bus.

00:27:19.330 --> 00:27:22.560
Now, to talk a little more
about kernel core dumps,

00:27:22.560 --> 00:27:25.180
this is a network connected core dump.

00:27:25.200 --> 00:27:30.420
And the idea here is you can set up
one collection server system for pretty

00:27:30.420 --> 00:27:32.680
much as many machines as you want.

00:27:32.680 --> 00:27:34.990
It's pretty common to have
one departmental server.

00:27:35.050 --> 00:27:37.930
If you're a small company,
you could have one for the whole company.

00:27:37.940 --> 00:27:41.190
And you configure each of the client
machines every time they panic to

00:27:41.190 --> 00:27:43.360
dump core back to that machine.

00:27:43.360 --> 00:27:46.080
Now it does take a little
bit of work to set up.

00:27:46.080 --> 00:27:47.080
It's not tremendous.

00:27:47.080 --> 00:27:51.760
There's a tech note here, tech note 2118,
that will walk you through all the steps.

00:27:51.760 --> 00:27:54.700
But once you've got it set up,
it's a very low investment

00:27:54.700 --> 00:27:56.010
in time to maintain.

00:27:56.040 --> 00:27:56.990
And think about it.

00:27:57.020 --> 00:27:58.860
You collect every panic that you have.

00:27:58.950 --> 00:28:03.180
Every panic that occurs on your network,
you now have a full core image of.

00:28:03.180 --> 00:28:06.770
So if you're looking for those hard
to reproduce panics and you hate

00:28:06.770 --> 00:28:09.700
it because you missed it and you
couldn't attach to the machine,

00:28:09.700 --> 00:28:11.390
well, this is a way to collect those.

00:28:11.400 --> 00:28:13.800
And you can look at them at your leisure.

00:28:13.800 --> 00:28:15.690
The core files are
obviously fairly large.

00:28:15.700 --> 00:28:17.010
But at least you can collect them.

00:28:17.110 --> 00:28:19.600
And you can move them around as you need.

00:28:19.600 --> 00:28:22.030
Now of course, you're not talking to a
real live running machine.

00:28:22.060 --> 00:28:23.900
You're talking to the memory image.

00:28:23.900 --> 00:28:26.850
So you're not setting breakpoints
and continuing or single stepping.

00:28:26.870 --> 00:28:28.880
But still,
pretty much everything is there.

00:28:28.880 --> 00:28:31.740
So you can look at the stacks,
for example.

00:28:34.770 --> 00:28:38.830
All right,
let's move our topic here to performance.

00:28:38.910 --> 00:28:40.330
Performance is kind of hard to pin down.

00:28:40.340 --> 00:28:42.440
It means different things
to different people.

00:28:42.490 --> 00:28:44.290
So throughput is a classic measure.

00:28:44.390 --> 00:28:46.800
How much data can you
cram through the system?

00:28:46.820 --> 00:28:51.560
Latency is now in this day and
age with AV being so important,

00:28:51.560 --> 00:28:53.780
latency is maybe a little
bit more interesting.

00:28:53.810 --> 00:28:55.730
And jitter is also tossed around.

00:28:55.780 --> 00:29:00.600
Latency is basically from the first bit
of data in to the last bit of data out,

00:29:00.630 --> 00:29:04.490
how quickly can you move
transaction through the system?

00:29:04.500 --> 00:29:06.100
And obviously with AV, it's important.

00:29:06.210 --> 00:29:08.910
Jitter is really how
constant is that time?

00:29:09.060 --> 00:29:11.270
If you can get data through
your system in a millisecond,

00:29:11.460 --> 00:29:14.060
is it a millisecond plus
or minus a millisecond?

00:29:14.060 --> 00:29:16.580
Or is it a millisecond plus
or minus a microsecond?

00:29:16.600 --> 00:29:19.270
Low jitter is very important
because it allows you to keep

00:29:19.440 --> 00:29:21.670
relatively small buffers.

00:29:22.970 --> 00:29:25.470
Personally, I like efficiency as a
measure of performance.

00:29:25.650 --> 00:29:29.700
It's ultimately what it comes down
to is how well are you utilizing the

00:29:29.700 --> 00:29:31.500
hardware that the customer has bought.

00:29:31.660 --> 00:29:35.210
It's optimized for low CPU cost.

00:29:36.640 --> 00:29:39.650
When you do this,
you'll find after the fact that

00:29:39.660 --> 00:29:42.090
it usually is improved either
your latency or your throughput

00:29:42.100 --> 00:29:45.500
or sometimes both depending on
exactly how your code is structured.

00:29:45.640 --> 00:29:49.460
So, you know, it's certainly a good way
to attack the problem.

00:29:49.500 --> 00:29:51.680
Throughput and latency are
really external measurements and

00:29:51.680 --> 00:29:53.410
I think they're observational.

00:29:53.490 --> 00:29:56.190
Efficiency is an internal
measurement and I think that's

00:29:56.250 --> 00:29:59.500
something that you can really get
behind and go through and look at.

00:29:59.500 --> 00:30:02.500
It reduces the footprint of your system.

00:30:02.580 --> 00:30:03.500
This is very, very important, right?

00:30:03.500 --> 00:30:04.690
You're reducing memory.

00:30:04.690 --> 00:30:08.590
If you optimize by reducing your
code path or reducing your data,

00:30:08.590 --> 00:30:11.500
it's going to decrease the amount
of memory that you get wired down.

00:30:11.500 --> 00:30:13.500
And in the kernel, that's very important.

00:30:13.740 --> 00:30:17.600
But the interesting thing here
is CPU utilization directly

00:30:17.820 --> 00:30:19.690
tracks with battery life.

00:30:20.110 --> 00:30:30.100
and temperature and
therefore fan noise as well.

00:30:30.100 --> 00:30:30.100
So you can actually say, "Well,
I'm making my driver run quieter

00:30:30.100 --> 00:30:30.110
by making it more efficient."
And that is actually true.

00:30:31.490 --> 00:30:32.970
Let's talk a little
more about wired memory.

00:30:33.070 --> 00:30:34.240
This is very important.

00:30:34.290 --> 00:30:37.100
Wired memory is the most expensive
kind of memory on your system

00:30:37.400 --> 00:30:38.960
because it's permanently used.

00:30:39.110 --> 00:30:42.520
It's not available to the
VM system to page out,

00:30:42.520 --> 00:30:44.400
to have somebody else make use of.

00:30:44.570 --> 00:30:48.890
So all in-kernel allocations
by default are wired memory.

00:30:48.950 --> 00:30:51.020
You can get pageable
memory in the kernel,

00:30:51.020 --> 00:30:53.400
but most of the common
allocators are wired.

00:30:53.400 --> 00:30:56.820
Now, when you load your KEXT,
all of the text and all of

00:30:56.820 --> 00:31:00.770
the data associated with that
KEXT are also in wired memory.

00:31:02.240 --> 00:31:04.960
There are some rounding errors
here that actually make it a

00:31:04.960 --> 00:31:06.700
little bit worse than that.

00:31:06.820 --> 00:31:09.180
When you create a
subclass of I/O service,

00:31:09.370 --> 00:31:11.220
because of the infrastructure
you're inheriting,

00:31:11.410 --> 00:31:14.800
particularly the Vtable and the
binary compatibility patch-up stuff,

00:31:14.840 --> 00:31:18.950
there's approximately 2K,
it's a little bit less than that,

00:31:18.960 --> 00:31:22.000
about 2K used, just getting you there.

00:31:22.750 --> 00:31:25.280
I don't want to discourage
you from using classes.

00:31:25.280 --> 00:31:27.880
I'm a very strong believer
in object-oriented design.

00:31:27.880 --> 00:31:29.140
I think it has real value.

00:31:29.200 --> 00:31:31.740
But be aware that there's this tax.

00:31:31.740 --> 00:31:34.860
You don't want to go and create
50 classes if you can avoid it.

00:31:34.930 --> 00:31:38.060
If you can get by with two or three
classes with maybe some parameters that

00:31:38.060 --> 00:31:41.190
would help describe the distinctions.

00:31:41.540 --> 00:31:44.510
Also, subclass from the highest
point that you can.

00:31:44.610 --> 00:31:46.800
The higher up you go
in the class hierarchy,

00:31:46.870 --> 00:31:50.980
the less you're inheriting,
the less the permanent tax.

00:31:51.220 --> 00:31:52.930
And this is something you
might not have considered.

00:31:52.940 --> 00:31:55.610
If you make use of
internal helper classes,

00:31:55.620 --> 00:31:59.580
these are maybe data representations
that you use that never migrate

00:31:59.580 --> 00:32:01.000
outside of your kernel extension.

00:32:01.000 --> 00:32:03.600
These objects are never
put into a dictionary.

00:32:03.630 --> 00:32:05.370
They never get passed
off to anybody else.

00:32:05.470 --> 00:32:06.600
They're just helpers.

00:32:06.650 --> 00:32:09.000
You don't even need to make
those inherit from OS object.

00:32:09.120 --> 00:32:12.060
You can actually create
your own root C++ class.

00:32:12.060 --> 00:32:16.000
And you don't obviously need the binary
compatibility logic if everything

00:32:16.000 --> 00:32:17.910
is contained within your text.

00:32:18.130 --> 00:32:20.250
And that can even be true if
you have a suite of kecks that

00:32:20.250 --> 00:32:21.300
are always shipped together.

00:32:21.300 --> 00:32:25.200
You can share classes between them as
long as they're always shipped together.

00:32:25.200 --> 00:32:27.980
You don't have to worry
about incompatibilities.

00:32:30.000 --> 00:32:33.240
Now another thing I'll talk about,
because of the way

00:32:33.380 --> 00:32:37.250
kernel extensions load,
there's approximately a 4K

00:32:37.250 --> 00:32:38.790
tax of wired memory there.

00:32:38.900 --> 00:32:42.240
And the reason is this:
we load the text segment and

00:32:42.240 --> 00:32:45.900
the data segment of each text
at the beginning of a page.

00:32:45.900 --> 00:32:48.490
And on average that means we're
going to waste about a half a

00:32:48.490 --> 00:32:49.860
page at the end of your text.

00:32:49.900 --> 00:32:53.950
Of course if your text has got
exactly 8K of text and 4K of data,

00:32:53.950 --> 00:32:55.660
then we're not wasting any.

00:32:55.900 --> 00:33:00.900
But on average, if you look at a system,
it's about 4K per kernel extension.

00:33:00.900 --> 00:33:02.940
And this is so that when it
comes time to unload them,

00:33:03.000 --> 00:33:06.900
we don't have a page partially
pinned down with some other text.

00:33:06.930 --> 00:33:12.900
Now you can help minimize this text
by refactoring your text suites.

00:33:13.870 --> 00:33:15.710
Here,
I'll show you some diagrams here that

00:33:15.840 --> 00:33:17.560
give you an idea what I'm talking about.

00:33:17.630 --> 00:33:20.590
Let's say you have two keks
that you ship as a suite.

00:33:20.710 --> 00:33:24.070
You've got an actual driver and
then you've got a support library.

00:33:24.220 --> 00:33:26.860
In a real world example,
you'd probably have more than one driver.

00:33:26.860 --> 00:33:29.200
You'd have one library
and say three drivers,

00:33:29.250 --> 00:33:32.100
something that were maybe
bus specific or something.

00:33:32.160 --> 00:33:36.820
Well, if they're always loaded together,
then combine them.

00:33:37.000 --> 00:33:40.010
And by doing that,
you just saved one page of wired memory

00:33:40.180 --> 00:33:41.840
without having to change any code.

00:33:41.920 --> 00:33:44.640
This is just changing
your project to combine.

00:33:46.090 --> 00:33:48.640
Splitting can also make sense.

00:33:48.640 --> 00:33:52.940
If you have a suite that you're putting
together in a single kernel extension,

00:33:52.940 --> 00:33:57.900
but for most users, most of the time,
they're not loaded together,

00:33:57.900 --> 00:33:58.900
you can split them up.

00:33:58.920 --> 00:34:02.750
So in this example here,
the red kernel extension represents the

00:34:02.950 --> 00:34:07.250
portions of your kecks that are talking
to the HID system and the portions

00:34:07.250 --> 00:34:09.200
that are talking to the USB family.

00:34:09.200 --> 00:34:13.000
Let's say those are used very frequently,
but maybe you don't think the

00:34:13.000 --> 00:34:16.900
ADB functionality is used very
frequently on your product.

00:34:16.900 --> 00:34:20.070
Since we don't have anything that
you can plug ADB into these days,

00:34:20.070 --> 00:34:21.360
that's probably true.

00:34:21.360 --> 00:34:24.870
And as a result,
you still have ADB compatibility

00:34:24.870 --> 00:34:28.470
with your product here,
but you don't have the penalty

00:34:29.040 --> 00:34:31.290
of loading all of that code.

00:34:31.340 --> 00:34:33.480
It's not used.

00:34:34.270 --> 00:34:37.160
The red text would get loaded
the majority of the time

00:34:37.160 --> 00:34:38.140
when your device is present.

00:34:38.210 --> 00:34:41.600
The blue text sits out on the file
system pretty much never getting loaded.

00:34:41.750 --> 00:34:45.370
So again, you save not only 4K,
you save the entire cost

00:34:45.480 --> 00:34:47.210
of that functionality.

00:34:47.950 --> 00:34:51.910
The good general rule for memory
footprint is keep only what you need.

00:34:52.140 --> 00:34:56.280
I can't stress enough how many times
I've seen kecks go out the door with

00:34:56.280 --> 00:35:00.100
development and debugging information
in them that isn't necessary.

00:35:00.210 --> 00:35:02.070
And I don't want to
pick on third parties.

00:35:02.070 --> 00:35:03.100
Apple does this too.

00:35:03.100 --> 00:35:04.410
It's very easy to forget.

00:35:04.510 --> 00:35:09.230
So it's something that really
you need to be mindful of.

00:35:09.350 --> 00:35:11.620
One thing you might not be aware,
the I/O registry is a

00:35:11.620 --> 00:35:12.710
wired data structure.

00:35:12.830 --> 00:35:14.310
It's in wired memory.

00:35:14.440 --> 00:35:18.800
So when you put that 64K
block of data in there,

00:35:19.000 --> 00:35:20.640
that's wired memory.

00:35:20.660 --> 00:35:24.040
So don't put anything in there
that you don't absolutely need.

00:35:24.040 --> 00:35:26.080
Of course,
your I/O personalities in your kernel

00:35:26.200 --> 00:35:29.530
extension get downloaded into the
registry when you load the KEXT.

00:35:29.570 --> 00:35:32.900
So that's one source for large
blocks of data would be to

00:35:32.900 --> 00:35:34.830
have it in the personalities.

00:35:34.860 --> 00:35:36.650
So avoid that if you can.

00:35:37.280 --> 00:35:39.910
If you have a firmware image or
something that you're going to need

00:35:39.920 --> 00:35:42.950
to download your hardware once,
put it in a throwaway KEXT.

00:35:43.100 --> 00:35:44.870
Put it in a KEXT that can be unloaded.

00:35:45.130 --> 00:35:47.190
And depending on the details
of what you're doing,

00:35:47.190 --> 00:35:48.990
there are a variety of ways to do this.

00:35:49.020 --> 00:35:52.180
Probably the easiest way is to
have the main KEXT for your device

00:35:52.900 --> 00:35:54.500
match and load against the device.

00:35:54.500 --> 00:35:56.820
And when it knows that
it needs some firmware,

00:35:56.960 --> 00:36:00.140
it can register itself for matching
or it can create a nub that will

00:36:00.140 --> 00:36:01.630
match that firmware KEXT in.

00:36:01.800 --> 00:36:03.820
And in fact,
it gives you the opportunity to

00:36:03.820 --> 00:36:05.700
have multiple firmware KEXTs,
right?

00:36:05.780 --> 00:36:07.910
You could say, "Oh,
this is version B of the board,

00:36:07.980 --> 00:36:11.580
so we're going to get this particular
KEXT that we need for version

00:36:11.580 --> 00:36:16.150
B firmware." And it will download it
to the board and then will evaporate

00:36:16.150 --> 00:36:18.540
and unload and free up that memory.

00:36:20.300 --> 00:37:26.300
[Transcript missing]

00:37:27.640 --> 00:37:31.120
I'm going to spend just a few seconds
here talking about memory fragmentation.

00:37:31.150 --> 00:37:34.400
If you're writing an application,
memory fragmentation is annoying,

00:37:34.420 --> 00:37:39.110
but when your app exits,
all that fragmentation is gone.

00:37:39.440 --> 00:37:42.600
When you're running in a kernel,
fragmentation is kind of like a

00:37:42.800 --> 00:37:44.950
permanent plaque in the system.

00:37:44.960 --> 00:37:47.920
So think of the kernel as
an app that never exits,

00:37:47.920 --> 00:37:50.340
or at least you hope it never exits.

00:37:51.480 --> 00:37:56.090
So, yeah, and the fragmentation problem
is that as you allocate a bunch

00:37:56.090 --> 00:37:59.420
of small pieces of memory,
typically smaller than a page,

00:37:59.420 --> 00:38:04.200
and maybe keep them for a long time,
and then you've also got some allocations

00:38:04.200 --> 00:38:07.070
that you only keep for a short time,
you can cause pages to be pinned

00:38:07.080 --> 00:38:08.880
down that don't really need to be.

00:38:09.040 --> 00:38:11.200
The efficiency of that memory goes down.

00:38:11.420 --> 00:38:13.590
You have 4K per page,
maybe only 2K if it's

00:38:13.700 --> 00:38:14.800
actually being used.

00:38:14.800 --> 00:38:17.860
The other 2K is memory
that can't be freed up.

00:38:17.920 --> 00:38:21.990
So, a couple things you can do
for a small amount of data,

00:38:22.200 --> 00:38:25.570
and I want to emphasize small.

00:38:25.830 --> 00:38:28.440
dozens of bytes,
put it on the stack if you can.

00:38:28.460 --> 00:38:32.240
There's no allocations involved,
there's no locking, no atomic operations,

00:38:32.340 --> 00:38:33.400
very efficient.

00:38:33.460 --> 00:38:37.040
If we're doing string processing,
you want to do an 80 character string,

00:38:37.070 --> 00:38:40.600
that's OK to put on the stack.

00:38:40.600 --> 00:38:42.440
If you're talking about
larger allocations,

00:38:42.480 --> 00:38:46.420
hundreds of bytes up to a page,
if you're doing something very briefly,

00:38:46.420 --> 00:38:50.180
you might even consider doing
a whole page allocation.

00:38:50.180 --> 00:38:53.910
We do zone allocations in the kernel,
so if your allocations happen

00:38:54.040 --> 00:38:56.240
to be power of two sizes,
that aligns very well

00:38:56.340 --> 00:38:57.820
with the zone allocators.

00:38:57.850 --> 00:39:00.740
But I'll talk about that in a minute.

00:39:00.740 --> 00:39:03.400
Also, cluster your long term allocations.

00:39:03.400 --> 00:39:05.600
This is actually a very good technique.

00:39:05.630 --> 00:39:07.110
Think about your average case.

00:39:07.210 --> 00:39:08.680
How many buffers are you going to need?

00:39:08.680 --> 00:39:09.680
How many command buffers?

00:39:09.680 --> 00:39:10.300
Whatever.

00:39:10.300 --> 00:39:12.360
Allocate them in a pool.

00:39:12.360 --> 00:39:14.320
We have an example of
this in IO command pool,

00:39:14.320 --> 00:39:15.940
and I believe that's in Darwin.

00:39:15.940 --> 00:39:17.800
So you can have a look
at how we've done that.

00:39:17.880 --> 00:39:22.080
What you can do is have your average
case allocated and waiting for you.

00:39:22.080 --> 00:39:25.070
And then you can also allocate
additional resources on demand.

00:39:25.080 --> 00:39:28.260
So if you have a spike where you
need some additional resources,

00:39:28.280 --> 00:39:30.900
you can grow the pool,
and you can even have some logic in there

00:39:30.900 --> 00:39:32.580
to drop it back down if you want to.

00:39:32.590 --> 00:39:34.880
I would not recommend
allocating for your worst case,

00:39:34.920 --> 00:39:39.300
because that's, of course,
permanent memory now that you've pinned.

00:39:39.360 --> 00:39:40.780
Performance is always a trade off.

00:39:40.780 --> 00:39:44.880
You need to decide what's going to
be most important and design for it.

00:39:44.920 --> 00:39:45.650
But think about it.

00:39:45.760 --> 00:39:47.120
That's the most important thing.

00:39:47.120 --> 00:39:48.920
Make a conscious decision.

00:39:48.940 --> 00:39:50.490
And if you have questions, ask us.

00:39:50.580 --> 00:39:51.940
We're here to help.

00:39:51.960 --> 00:39:53.280
Now, leaks.

00:39:53.280 --> 00:39:53.490
Leaks.

00:39:53.520 --> 00:39:56.560
These are evil,
particularly in kernel extensions,

00:39:56.560 --> 00:39:58.650
because again,
we're leaking wired memory.

00:39:58.690 --> 00:40:03.750
This isn't a page of memory that's going
to go cold and then get sort of forgotten

00:40:03.790 --> 00:40:05.600
about off in a swap file somewhere.

00:40:05.600 --> 00:40:07.650
This is memory that's
permanently allocated and

00:40:07.650 --> 00:40:09.200
will never be touched again.

00:40:09.210 --> 00:40:12.370
So the symptom is the machine
gets slower and slower and slower

00:40:12.390 --> 00:40:15.630
as available memory goes down,
and then it'll eventually crash or the

00:40:15.630 --> 00:40:17.480
user will get fed up and reboot it.

00:40:17.480 --> 00:40:19.960
It seriously damages the user experience.

00:40:19.960 --> 00:40:23.330
And the reason they're so evil
is they often don't get caught in

00:40:23.330 --> 00:40:27.480
QA because you're doing maybe short
cycle time on testing or you're

00:40:27.480 --> 00:40:29.240
not looking specifically for leaks.

00:40:29.240 --> 00:40:30.920
So everything can work correctly.

00:40:30.920 --> 00:40:32.070
Your driver may be perfect.

00:40:32.090 --> 00:40:37.700
But if it's leaking, that's a problem for
the entire community.

00:40:38.100 --> 00:42:18.900
[Transcript missing]

00:42:23.180 --> 00:42:25.980
Locks, atomic operations in
general are expensive,

00:42:26.170 --> 00:42:27.710
particularly on an MP system.

00:42:27.850 --> 00:42:30.470
Our systems are cache coherent.

00:42:30.470 --> 00:42:34.590
So you're not only taking time on
the processor that you're running on,

00:42:34.720 --> 00:42:37.620
you're taking time on the other processor
because you're messing with its cache.

00:42:37.620 --> 00:42:42.080
So you want to avoid taking more
locks than necessary and you want

00:42:42.130 --> 00:42:45.560
to avoid taking them on the data
path because the data path is

00:42:45.560 --> 00:42:47.100
where you want your low latency.

00:42:47.470 --> 00:42:49.050
Anytime you have to do
an atomic operation,

00:42:49.050 --> 00:42:52.150
you're introducing jitter because
you don't know if that resource is

00:42:52.150 --> 00:42:54.100
going to be available for you to grab.

00:42:54.310 --> 00:42:56.370
Also be aware,
any kernel function that says in the

00:42:56.370 --> 00:42:59.500
documentation that this may block,
it's blocking because it's

00:42:59.500 --> 00:43:01.100
doing an atomic operation.

00:43:01.100 --> 00:43:03.590
It's acquiring a lock,
it's doing something that is

00:43:03.590 --> 00:43:05.100
atomic and that's expensive.

00:43:05.240 --> 00:43:09.070
So that's something to be aware
of as you're writing your code.

00:43:09.320 --> 00:43:12.320
Context switches are expensive
compared particularly to

00:43:12.320 --> 00:43:14.070
just a direct function call.

00:43:14.100 --> 00:43:17.100
So you want to design your code
to avoid that as necessary.

00:43:17.250 --> 00:43:20.790
And there's an interesting thing we
call the ping pong effect where you can

00:43:20.840 --> 00:43:25.100
have one thread running on processor
zero and it wakes up another thread.

00:43:25.320 --> 00:43:29.670
That other thread then schedules and runs
on processor one and starts working with

00:43:29.670 --> 00:43:32.030
the data that the prior thread created.

00:43:32.100 --> 00:43:36.100
Well, that's on the other processor and
the data is not in its data cache.

00:43:36.100 --> 00:43:39.450
So you can have these two threads
ping ponging between the processors

00:43:39.450 --> 00:43:41.040
and blowing cache affinity.

00:43:41.120 --> 00:43:43.120
So if you can do what you need
to do without a context switch,

00:43:43.120 --> 00:43:44.100
you avoid that, right?

00:43:44.100 --> 00:43:46.070
Because you're still running in
the same thread of execution.

00:43:46.130 --> 00:43:47.100
You're still on the same thread.

00:43:47.100 --> 00:43:49.100
You're still on the same processor.

00:43:49.100 --> 00:43:51.970
And of course,
disabling interrupts is evil for

00:43:51.970 --> 00:43:56.100
a number of reasons because you're
basically taking the CPU away

00:43:56.100 --> 00:43:58.580
from the scheduler and saying,
"No, I'm going to decide what runs,

00:43:58.580 --> 00:44:01.980
not you." And that affects
our real-time performance.

00:44:02.160 --> 00:44:04.210
So disabling interrupts.

00:44:04.320 --> 00:44:06.360
That also causes jitter.

00:44:06.420 --> 00:44:07.930
So we of course have I/O Work Loop.

00:44:08.160 --> 00:44:10.080
Everybody who's looked at
I/O Kit has encountered this.

00:44:10.090 --> 00:44:10.600
It's central.

00:44:10.600 --> 00:44:12.940
It's one of our core concepts here.

00:44:13.330 --> 00:44:16.180
But it really is designed
from a systemic view.

00:44:16.180 --> 00:44:19.480
For those of you that have looked at
some of the APIs of I/O Work Loop and

00:44:19.480 --> 00:44:23.560
they perhaps don't make immediate
sense when you're approaching it

00:44:23.650 --> 00:44:30.430
from a driver/rider perspective,
it's because it was designed

00:44:30.750 --> 00:44:36.710
from a systemic perspective.

00:44:36.710 --> 00:44:36.710
How does this affect the whole system?

00:44:36.710 --> 00:44:36.710
How does this work when you
stack multiple layers of

00:44:36.710 --> 00:44:36.710
drivers on top of each other?

00:44:36.780 --> 00:44:39.500
The main thing it tries to
do there is eliminate context

00:44:39.500 --> 00:44:40.850
switches in the data path.

00:44:40.940 --> 00:44:45.140
As you start from a user request and
you go all the way down to the hardware,

00:44:45.140 --> 00:44:47.350
we tend to inherit the
I/O work loop along the client

00:44:47.350 --> 00:44:50.700
provider chain in the registry,
which tends to be the data flow.

00:44:50.830 --> 00:44:53.780
So, by and large,
a request can go all the way down

00:44:54.060 --> 00:44:58.390
to the hardware on the client's
thread with no context switch.

00:44:58.920 --> 00:45:01.830
And likewise with
interrupt event sources,

00:45:02.100 --> 00:45:04.020
you're not doing any work,
you're not doing any interrupt

00:45:04.180 --> 00:45:05.970
processing in the interrupt handler.

00:45:06.100 --> 00:45:09.800
All you're doing is writing a filter to
make sure it really is your interrupt.

00:45:10.010 --> 00:45:13.220
And then the thread schedules,
your work loop thread

00:45:13.220 --> 00:45:14.800
will schedule to run.

00:45:14.800 --> 00:45:18.570
Then it can process the data, but again,
that will be passed up the

00:45:18.570 --> 00:45:21.800
stack all the way up to the
highest level on a single thread.

00:45:21.800 --> 00:45:24.710
You're minimizing context switches.

00:45:26.630 --> 00:45:27.590
I/O command gate.

00:45:27.610 --> 00:45:28.300
This is an interesting one.

00:45:28.300 --> 00:45:30.760
I've had a number of requests
for us to publish the lock

00:45:30.760 --> 00:45:33.000
that's associated with this.

00:45:33.000 --> 00:45:36.750
And the reason we don't do
this is really two reasons.

00:45:36.750 --> 00:45:39.780
One is sort of a methodology,
a design methodology that

00:45:39.780 --> 00:45:41.060
we like to talk about.

00:45:41.230 --> 00:45:44.290
I call it a gated community.

00:45:44.290 --> 00:45:51.040
The idea here is you have a set of
functions within the driver that all know

00:45:51.040 --> 00:45:53.020
they're running behind the command gate.

00:45:53.160 --> 00:45:57.260
They can call into each other without
having to do any additional locking.

00:45:57.290 --> 00:46:00.410
Remember,
locking equals atomic operation.

00:46:00.550 --> 00:46:04.200
And all of the functions outside of
that gated community know that they are

00:46:04.200 --> 00:46:06.700
not running with the command gate held.

00:46:06.700 --> 00:46:09.440
So when you want to call
into a gated function,

00:46:09.440 --> 00:46:12.070
you take the function pointer
to it using that nice macro

00:46:12.220 --> 00:46:14.040
that I showed you earlier.

00:46:14.040 --> 00:46:17.340
You use command gate,
you call through to it.

00:46:17.340 --> 00:46:22.080
It also has a very interesting
debugging technique associated with it.

00:46:22.080 --> 00:46:24.780
Because all calls through the command
gate show up in the command gate.

00:46:24.800 --> 00:46:27.020
And the function calls
are all function calls.

00:46:27.100 --> 00:46:30.400
So if you have a deadlock,
a show all stacks will point exactly

00:46:30.400 --> 00:46:34.180
where it is because every access to
one of these locks is on the stack.

00:46:34.180 --> 00:46:37.470
Whereas if we publish the lock,
you'd be able to take the lock in

00:46:37.470 --> 00:46:39.970
your code and release it directly.

00:46:39.970 --> 00:46:44.280
Any imbalances there would
cause deadlocks and there

00:46:44.340 --> 00:46:46.590
would be basically nothing

00:46:46.700 --> 00:47:00.600
[Transcript missing]

00:47:04.370 --> 00:47:07.350
If you haven't used the utility Top,
I urge you immediately after

00:47:07.460 --> 00:47:10.300
the session is over to whip
out your laptop and run it.

00:47:10.420 --> 00:47:13.880
Top is one of these essential
little utilities to understand

00:47:13.950 --> 00:47:15.660
what is going on in the system.

00:47:15.740 --> 00:47:21.810
And it isn't necessarily directly
that relevant to what drivers do,

00:47:21.820 --> 00:47:24.800
but it does help you understand
when things go wrong,

00:47:24.800 --> 00:47:25.890
maybe what is going wrong.

00:47:25.910 --> 00:47:28.600
You've got a demon
spinning out of control.

00:47:28.710 --> 00:47:32.260
You can use it a little bit for
seeing what's going on with drivers.

00:47:32.380 --> 00:47:36.060
The kernel and the collection
of all kernel extensions are

00:47:36.060 --> 00:47:38.700
accounted for under PID 0,
the kernel.

00:47:38.700 --> 00:47:40.700
It's the very last line on the slide.

00:47:40.860 --> 00:47:44.780
And if you're running a stress test,
if you're really beating on your driver,

00:47:44.780 --> 00:47:46.600
maybe you've got a gigabit
Ethernet driver and you're

00:47:46.600 --> 00:47:49.880
really pushing data through it,
that will show some numbers there.

00:47:49.900 --> 00:47:53.680
And so you can actually start to
look at memory usage and CPU usage

00:47:54.220 --> 00:47:55.870
collectively for the whole kernel.

00:47:55.900 --> 00:47:59.900
And as your driver becomes more lean,
those numbers should get better.

00:47:59.900 --> 00:48:01.900
So if you run this sort of on a bus,
you can actually see the difference.

00:48:02.300 --> 00:48:04.300
And if you run this before
and after tuning exercise,

00:48:04.300 --> 00:48:08.610
you might actually see these
needles wiggle a little bit.

00:48:08.700 --> 00:48:10.600
I would hope you would be able to.

00:48:13.190 --> 00:48:15.660
We also have the ability
to profile the kernel.

00:48:15.660 --> 00:48:19.240
Again, this is the whole system really
is being profiled by Shark.

00:48:19.370 --> 00:48:21.630
But if you're running a
load test on your driver,

00:48:21.780 --> 00:48:25.100
this actually will probably
yield some interesting results.

00:48:25.150 --> 00:48:28.970
Now, first and foremost,
you really do need to get the kernel

00:48:28.970 --> 00:48:31.630
SDKs because Shark will give you,
again,

00:48:31.640 --> 00:48:35.530
very peculiar data if you don't have
the symbol kernel because you're

00:48:35.600 --> 00:48:39.410
going to be getting whatever the
nearest global symbol is and that

00:48:39.410 --> 00:48:42.100
may not be very close to the actual
function that you're landing in.

00:48:42.100 --> 00:48:46.490
So if you have the symbol kernel,
you run Shark, and you particularly put

00:48:46.510 --> 00:48:50.100
your driver under load,
it will help you identify sort of the

00:48:50.110 --> 00:48:54.560
hot call paths through your driver and
you will understand maybe a little bit

00:48:54.560 --> 00:48:57.100
better about what you need to optimize.

00:49:02.610 --> 00:49:05.650
Now this is something that has
come to our attention in the last

00:49:05.650 --> 00:49:09.280
year and this is why I'm bringing
it up here for the first time.

00:49:09.410 --> 00:49:13.450
The I/O registry is a large
sprawling data structure

00:49:14.180 --> 00:49:18.300
that is protected by locks.

00:49:18.660 --> 00:49:21.980
If your driver is directly
setting or modifying a container

00:49:22.160 --> 00:49:25.430
in the registry that is talking
directly to the container,

00:49:25.430 --> 00:49:26.850
the collection object,

00:49:27.100 --> 00:49:41.300
[Transcript missing]

00:49:41.600 --> 00:49:44.000
to the registry,
particularly to collection

00:49:44.000 --> 00:49:47.830
objects in the registry,
need to go through and take this lock.

00:49:47.840 --> 00:49:49.480
And there's a couple ways to do this.

00:49:49.480 --> 00:49:51.730
The easiest way,
I've got another slide that

00:49:51.730 --> 00:49:54.610
shows the way to remedy this,
but the easiest way to tell if

00:49:54.610 --> 00:49:59.010
you're doing this is with this sys
control that we've added to TIGER.

00:49:59.040 --> 00:50:00.920
This turns on strict checking.

00:50:00.930 --> 00:50:04.170
And what this means is,
anytime one of these container

00:50:04.170 --> 00:50:07.490
collection objects gets modified
while it's in the registry,

00:50:07.570 --> 00:50:10.680
if that lock isn't taken,
you take an instant panic.

00:50:10.680 --> 00:50:13.440
Now,
we shipped this off by default because

00:50:13.440 --> 00:50:16.210
the system was not reliable with this on.

00:50:17.150 --> 00:50:19.100
Okay, this is how important it is.

00:50:19.110 --> 00:50:20.990
Now it's truly a lottery ticket, right?

00:50:21.130 --> 00:50:26.260
You're modifying the dictionary that
contains your statistics information.

00:50:26.330 --> 00:50:29.400
What's the likelihood that somebody's
reading it at that very instant?

00:50:29.400 --> 00:50:32.100
It's pretty small, but it's non-zero.

00:50:32.100 --> 00:50:37.370
So we see a number of data
corruption panics and we

00:50:37.480 --> 00:50:38.980
believe most of them are this.

00:50:39.170 --> 00:50:43.080
They usually will involve an
object that's been modified or

00:50:43.080 --> 00:50:45.100
freed from the registry recently.

00:50:45.100 --> 00:50:48.180
Now there are a few types of objects
that are safe to modify and there's

00:50:48.180 --> 00:50:52.030
one in particular I want to talk about
because it's a handy technique to have.

00:50:52.090 --> 00:50:55.100
The OS data object points
to a block of memory.

00:50:55.100 --> 00:50:58.120
Now you can modify the memory
that's being pointed to by that.

00:50:58.130 --> 00:51:01.020
That's not something that's
going to affect any pointers,

00:51:01.020 --> 00:51:02.710
any reference counting anywhere.

00:51:03.130 --> 00:51:06.080
And I know some people will use that to
communicate statistics information out.

00:51:06.090 --> 00:51:08.680
They'll have a struct,
they wrap that as an OS data and

00:51:08.940 --> 00:51:12.100
they put that in the registry
so an app can read that.

00:51:12.100 --> 00:51:13.100
That's safe to do.

00:51:13.100 --> 00:51:16.930
But if you're modifying a collection
or modifying anything that would

00:51:16.940 --> 00:51:19.980
affect a reference count or
the existence of an object,

00:51:20.050 --> 00:51:21.090
you're at risk.

00:51:24.910 --> 00:51:25.770
Okay, so what do you do?

00:51:25.820 --> 00:51:29.410
When you find one of these,
you need to make sure that the

00:51:29.510 --> 00:51:32.560
modifications to the registry
go through I/O registry entry.

00:51:32.560 --> 00:51:34.560
That is basically your super class.

00:51:34.740 --> 00:51:37.790
I/O registry entry is the
parent of I/O service,

00:51:37.920 --> 00:51:41.280
which is the parent of basically
all the I/O Kit driver classes.

00:51:41.430 --> 00:51:45.770
There's a set property in there,
a set property function in there

00:51:45.770 --> 00:51:49.810
that will take the correct lock,
make the changes to the registry,

00:51:49.810 --> 00:51:52.290
and then return,
or release the lock and return.

00:51:52.400 --> 00:51:55.390
If you need to do complex changes,
then you've got a couple options.

00:51:55.430 --> 00:51:58.960
You can either copy the dictionary or
the collection that you want to modify,

00:51:58.960 --> 00:52:02.460
make the changes there,
and then set them back in

00:52:02.550 --> 00:52:04.000
atomically using set property.

00:52:04.000 --> 00:52:07.750
And by the way, for Tiger,
we've added two new

00:52:07.750 --> 00:52:09.860
APIs to help you with this.

00:52:10.300 --> 00:52:11.560
One is copy collection.

00:52:11.800 --> 00:52:12.720
This does a deep copy.

00:52:12.720 --> 00:52:15.700
So it does not copy the leaf nodes.

00:52:15.950 --> 00:52:18.420
What it does is it copies all
of the objects that would be at

00:52:18.530 --> 00:52:19.890
risk for this type of corruption.

00:52:19.920 --> 00:52:22.240
So if you've got an object
that you want to modify,

00:52:22.250 --> 00:52:26.310
that's maybe multi-levels deep,
you can use copy collection on it.

00:52:26.320 --> 00:52:30.720
It gives you a new collection object
that's safe for you to mess around with.

00:52:30.720 --> 00:52:33.600
You make your changes,
then you use set property to put it back.

00:52:33.600 --> 00:52:37.670
Let's say you want to make
a larger set of changes,

00:52:37.680 --> 00:52:40.420
or you need to do maybe some read,
modify, write type stuff,

00:52:40.420 --> 00:52:41.840
and you want to make it atomic.

00:52:41.840 --> 00:52:46.030
We've added a new entry called run
property action to I/O registry entry.

00:52:46.030 --> 00:52:49.400
And this, again,
sort of like the gated community concept,

00:52:49.480 --> 00:52:52.160
this allows you to run a
function in the context,

00:52:52.160 --> 00:52:54.230
that has that lock held.

00:52:54.230 --> 00:52:56.640
And of course,
the fact the active returning from that

00:52:56.640 --> 00:52:58.530
function causes the lock to be released.

00:52:58.530 --> 00:53:01.010
So this run property action
will allow you to modify

00:53:01.010 --> 00:53:02.700
anything in your registry entry.

00:53:02.730 --> 00:53:05.840
It needs to be fairly quick,
because while that function is running,

00:53:06.010 --> 00:53:07.940
nobody can read or modify the registry.

00:53:08.150 --> 00:53:10.320
So you shouldn't be blocking in there.

00:53:13.630 --> 00:53:15.410
Again, I want to talk about cyclers.

00:53:15.420 --> 00:53:17.340
I won't spend a lot of
time talking about this.

00:53:17.340 --> 00:53:19.950
This is something that we found
tremendously useful at Apple and

00:53:19.950 --> 00:53:21.450
we're expanding our use of them.

00:53:21.510 --> 00:53:25.060
But it's really cheap QA, right?

00:53:25.580 --> 00:53:27.630
Find a way to exercise different
paths through your driver,

00:53:27.630 --> 00:53:30.500
particularly what I call
bookended functions.

00:53:30.500 --> 00:53:35.070
Close, open, load, unload,
anything that has some set of

00:53:35.110 --> 00:53:36.500
states that you can walk through.

00:53:36.500 --> 00:53:40.660
And build a cycler around it and as part
of your QA program run those cyclers.

00:53:40.660 --> 00:53:43.450
And while you're running them,
look for leaks.

00:53:44.000 --> 00:53:46.500
This is very easy to do.

00:53:46.500 --> 00:53:48.500
It doesn't take that much
time once you've invested

00:53:48.500 --> 00:53:49.500
the time to build the cycler,
that is.

00:53:49.500 --> 00:53:54.500
And I think you'll learn a lot about your
driver that you might not have realized.

00:53:56.530 --> 00:53:58.620
So just a few points about cyclers.

00:53:58.620 --> 00:54:02.180
It's nice to make them issue the
cycles at controllable rates because

00:54:02.180 --> 00:54:05.980
sometimes you want to do race
condition checking and you want

00:54:05.980 --> 00:54:07.480
to really run them at top speed.

00:54:07.890 --> 00:54:10.140
Sometimes you don't want
to really stress it.

00:54:10.170 --> 00:54:13.800
You just want to say, you know,
cycle this thing once every five seconds.

00:54:13.800 --> 00:54:17.140
And you're trying to do it,
trying to isolate each action separately.

00:54:17.140 --> 00:54:19.960
But, you know, again,
no matter how you run it,

00:54:19.960 --> 00:54:22.080
look at the memory as you do this.

00:54:22.080 --> 00:54:25.020
And also make sure your cycler logs
something on every pass because

00:54:25.430 --> 00:54:26.480
when something does go wrong,
you're going to have to do it again.

00:54:26.500 --> 00:54:29.530
You're going to run your cycler
over the weekend when you go home.

00:54:29.570 --> 00:54:31.270
You come back and realize
it died Saturday afternoon.

00:54:31.270 --> 00:54:32.370
You're going to want to know why.

00:54:32.380 --> 00:54:33.880
So log as much as you can.

00:54:37.380 --> 00:54:38.930
Okay, I have two checklists for you.

00:54:39.110 --> 00:54:41.050
This is something you should
be doing before you ready

00:54:41.050 --> 00:54:42.660
your drivers for release.

00:54:42.810 --> 00:54:46.190
The source checklist here,
I think there's a lot of kernel

00:54:46.190 --> 00:54:50.010
extensions that could have been a
lot cleaner when they shipped if

00:54:50.010 --> 00:54:51.240
they had gone through this checklist.

00:54:51.300 --> 00:54:54.100
And again, this is made up of real
problems that I have seen.

00:54:54.270 --> 00:54:56.580
Make sure your classes
use the correct naming.

00:54:56.750 --> 00:54:59.540
We have a recommended
reverse DNS name idiom.

00:54:59.690 --> 00:55:01.900
Make sure it's not my class.

00:55:02.100 --> 00:55:05.870
Make sure it's not anything
that has Apple in it.

00:55:05.870 --> 00:55:06.540
That's for us.

00:55:06.800 --> 00:55:26.100
[Transcript missing]

00:55:26.630 --> 00:55:29.740
Please make sure you don't have any
debugging log messages in there.

00:55:29.820 --> 00:55:34.120
Printfs, kprintfs,
I/O logs that spam the console.

00:55:34.370 --> 00:55:38.280
Remember, I/O logs get written to a file,
var log system log.

00:55:38.340 --> 00:55:42.080
So if you're logging
50 messages a second,

00:55:42.080 --> 00:55:44.690
and I have seen this,
those are going to fill up

00:55:44.690 --> 00:55:46.440
your customer's hard disk.

00:55:47.020 --> 00:55:51.180
So please just check that as
part of your final checkout.

00:55:51.180 --> 00:55:53.130
Look for the log messages
and see what's out there.

00:55:53.160 --> 00:55:55.360
And any other debugging specific stuff.

00:55:55.380 --> 00:55:58.100
Panic, assert, I/O log,
all those things need to

00:55:58.100 --> 00:55:59.880
be only in your debug code.

00:55:59.920 --> 00:56:01.740
So make sure you're looking at that.

00:56:01.800 --> 00:56:03.800
Binary checklist.

00:56:03.800 --> 00:56:06.360
So this is something that maybe
your QA team would want to do

00:56:06.370 --> 00:56:09.680
because you can do it without really
having to look at the source code.

00:56:09.690 --> 00:56:10.750
Very simple one.

00:56:11.010 --> 00:56:12.260
kextload-tn.

00:56:12.260 --> 00:56:16.220
That means test the KEXT, but do nothing.

00:56:16.600 --> 00:56:19.500
So it's not loading the KEXT,
it's just acting as if it were going to.

00:56:19.500 --> 00:56:21.290
It runs all the validation checks.

00:56:21.290 --> 00:56:25.100
And it will issue some diagnostic
messages describing what's going wrong.

00:56:25.100 --> 00:56:27.930
You can add the V flag to
get more verbose output,

00:56:28.080 --> 00:56:29.470
but that's a very easy check.

00:56:29.500 --> 00:56:31.240
This is kind of a silly one.

00:56:31.240 --> 00:56:34.250
Run a find on your KEXT and
see what all is in there.

00:56:34.250 --> 00:56:36.500
I've seen a lot of like GDB backtraces.

00:56:36.500 --> 00:56:40.280
I've seen, of course,
the .ds_store files and

00:56:40.280 --> 00:56:42.500
other .files like that.

00:56:42.500 --> 00:56:45.500
I've even seen source code in there.

00:56:46.530 --> 00:56:47.500
I don't know how it got in there.

00:56:47.500 --> 00:56:49.490
I'm not sure how somebody
set up their project.

00:56:49.510 --> 00:56:52.110
But you really only ought to
be shipping the folders and the

00:56:52.110 --> 00:56:55.500
Info.plist and the binary and maybe
if you have any other resources.

00:56:55.500 --> 00:56:59.820
But make sure every file in there is
something you know you're shipping.

00:57:00.560 --> 00:57:02.620
Also make sure your
binary has been stripped.

00:57:02.620 --> 00:57:04.970
We recommend strip-S.

00:57:05.010 --> 00:57:06.080
If you don't do this, guess what?

00:57:06.140 --> 00:57:09.770
You're shipping line numbers
and source file names.

00:57:10.370 --> 00:57:14.080
You want to keep your source code closed,
run stripped because you're

00:57:14.110 --> 00:57:17.180
actually putting a lot of symbolic
information in there otherwise.

00:57:17.360 --> 00:57:21.100
If you actually ship it unstripped,
it's also very large which

00:57:21.100 --> 00:57:22.900
is why we personally care.

00:57:22.950 --> 00:57:25.060
We don't mind if you
open up your source code,

00:57:25.060 --> 00:57:25.970
but you might.

00:57:26.900 --> 00:57:27.910
Look at your info P list.

00:57:28.070 --> 00:57:31.510
The I/O Kit debug property needs
to be gone or it needs to be zero.

00:57:31.640 --> 00:57:33.790
This causes additional logging
when your driver's loaded.

00:57:33.800 --> 00:57:36.730
There's no point in this
being in a shipping text.

00:57:36.820 --> 00:57:40.120
In fact, at one point we played around
with making those only load under

00:57:40.120 --> 00:57:45.220
certain specific debug situations,
but we actually found that would break a

00:57:45.270 --> 00:57:47.000
number of shipping texts if we did that.

00:57:48.440 --> 00:57:50.200
So, and make sure your version
numbers match everywhere.

00:57:50.200 --> 00:57:52.620
I know there's several
places it has to be checked.

00:57:52.650 --> 00:57:57.500
We're working on reducing that number,
but make sure they're right.

00:57:57.530 --> 00:57:59.830
Now also, check your copyright string.

00:57:59.830 --> 00:58:02.450
This is not something we
personally care about,

00:58:02.500 --> 00:58:06.280
but I've seen a lot of things
like copyright 1999 my company.

00:58:06.500 --> 00:58:17.900
[Transcript missing]

00:58:18.050 --> 00:58:20.380
I'm working on a utility called Kextpert.

00:58:20.590 --> 00:58:23.360
It's basically a big honkin' Perl script.

00:58:23.360 --> 00:58:26.420
And what I'm trying to do is
capture a lot of these tests,

00:58:26.460 --> 00:58:29.220
a lot of these simple problems
that can be automated into a test.

00:58:29.260 --> 00:58:30.480
That's what I'm trying to put in there.

00:58:30.490 --> 00:58:33.500
It's a lot of complexity
because I'm also trying to build

00:58:33.570 --> 00:58:35.340
in version awareness to it.

00:58:35.350 --> 00:58:37.920
So you'll be able to basically
run Kextpert with a set of

00:58:38.210 --> 00:58:41.180
versions you care about,
OS releases you want to run on,

00:58:41.180 --> 00:58:42.670
and point it at a KEXT.

00:58:42.720 --> 00:58:44.600
And it will go through it,
and for every file in there,

00:58:44.600 --> 00:58:46.060
it will tell you what it thinks.

00:58:46.160 --> 00:58:47.750
It will give you particularly errors.

00:58:47.750 --> 00:58:49.920
These are things that you
probably would have already found,

00:58:49.920 --> 00:58:52.680
but if you didn't,
it'll tell you about them.

00:58:52.680 --> 00:58:54.700
Warnings are things that,
depending on context,

00:58:54.700 --> 00:58:57.320
may or may not be a problem,
but they're certainly something

00:58:57.430 --> 00:58:59.210
you want to track down.

00:58:59.210 --> 00:59:00.060
Suggestions is an interesting one.

00:59:00.060 --> 00:59:03.580
This is one we're going to use to promote
new and improved ways of doing things.

00:59:03.580 --> 00:59:06.530
It's going to say, "Hey,
maybe if you use this property instead,

00:59:06.530 --> 00:59:10.320
you could eliminate some complexity."
So it's going to look for telltale signs

00:59:10.330 --> 00:59:12.880
of maybe an optimal ways of doing things.

00:59:12.880 --> 00:59:14.660
And info is really in there for my sense.

00:59:14.660 --> 00:59:16.520
And then it's going to
tell you what it thinks.

00:59:16.520 --> 00:59:18.590
So it's going to tell you
what the parsing engine is

00:59:18.590 --> 00:59:19.820
thinking about this file.

00:59:19.910 --> 00:59:21.960
So it just kind of tells
you how it's analyzing

00:59:24.070 --> 00:59:27.510
Now it's also going to contain a
section at the end that for every

00:59:27.670 --> 00:59:30.810
one-liner that it spits out at the top,
hopefully will give you a link

00:59:30.970 --> 00:59:32.850
to more detailed information.

00:59:33.000 --> 00:59:35.190
So the ubiquitous, you know,

00:59:35.300 --> 00:59:39.880
is the founder of the I/O Kit.

00:59:39.880 --> 00:59:46.180
Dean Reece is the founder of the I/O Kit.

00:59:46.180 --> 00:59:52.330
Dean Reece is the founder of the I/O Kit.

00:59:52.560 --> 00:59:58.780
Dean Reece is the founder of the I/O Kit.

00:59:58.780 --> 01:00:04.960
Dean Reece is the founder of the I/O Kit.

01:00:09.750 --> 01:00:14.840
So for more information,
there's obviously a lot of

01:00:14.840 --> 01:00:17.000
information about these topics.

01:00:17.110 --> 01:00:19.870
You can go to developer.apple.com.

01:00:19.870 --> 01:00:25.050
There's a special page there, WWDC 2005,
and that basically has all of

01:00:25.050 --> 01:00:29.660
these links on it that will help
you find the resources you need.

01:00:29.720 --> 01:00:32.220
Just a few quick words here.

01:00:32.220 --> 01:00:34.760
The Apple Developer Connection
website has a few specific mail

01:00:34.760 --> 01:00:36.590
lists that you want to know about.

01:00:36.650 --> 01:00:39.560
Lists.apple.com is the site
you go to to set them up.

01:00:39.760 --> 01:00:42.740
With the ATA and SCSI development list,
tremendously helpful to

01:00:42.840 --> 01:00:44.310
folks working in that space.

01:00:44.310 --> 01:00:46.640
This is also true for FireWire and USB.

01:00:46.930 --> 01:00:48.540
We have dedicated lists.

01:00:48.570 --> 01:00:52.610
Obviously, we can't talk too much about
future products or future plans,

01:00:52.730 --> 01:00:57.060
but if you're trying to get something
going and you're getting stuck,

01:00:57.060 --> 01:00:58.880
those are great places to go.

01:00:58.880 --> 01:01:01.350
We also have Darwin as
a tremendous resource.

01:01:01.620 --> 01:01:04.110
The Darwin Kernel is open sourced.

01:01:04.190 --> 01:01:07.380
I don't know the exact percentage,
but it's something like 99.99% of

01:01:07.430 --> 01:01:13.760
the kernel and the surrounding pieces
are made available as open source.

01:01:13.760 --> 01:01:15.290
In addition to that,
there's a number of mail lists

01:01:15.340 --> 01:01:19.760
that I personally frequent and
so do a number of other people.

01:01:19.760 --> 01:01:22.280
General development, Darwin dev, USB.

01:01:22.360 --> 01:01:26.300
That looks like a cut and

01:01:43.540 --> 01:01:43.540
Sorry, I need to debug my slides.

01:01:43.540 --> 01:01:43.540
So there's general development,
there's driver development,

01:01:43.540 --> 01:01:43.540
and there's also kernel development.

01:01:43.540 --> 01:01:43.540
So I believe it's
darwindrivers@list.apple.com is what

01:01:43.540 --> 01:01:43.540
that next to last line should have been.

01:01:43.540 --> 01:01:43.540
I'll make sure this gets
updated on the WWDC site.

01:01:44.360 --> 01:01:46.930
And of course,
there are several related sessions.

01:01:46.950 --> 01:01:51.290
Session 508 is about open source,
and obviously we're talking

01:01:51.290 --> 01:01:52.740
about the kernel there.

01:01:52.740 --> 01:01:56.580
USB session 509,
both of those are tomorrow.

01:01:56.710 --> 01:02:00.520
And then on Thursday,
we've got the BSD talk,

01:02:00.540 --> 01:02:03.400
which obviously if you're
working on non-I/O Kit pieces,

01:02:03.400 --> 01:02:06.210
or even in some cases bridges,
that'll be important.

01:02:06.330 --> 01:02:07.290
And then there's two labs.

01:02:07.360 --> 01:02:11.500
Tomorrow afternoon,
we've got a KPI lab that's specifically

01:02:11.500 --> 01:02:12.880
for file system development.

01:02:13.020 --> 01:02:15.150
And then Thursday afternoon,
we have a general kernel

01:02:15.170 --> 01:02:17.700
extension porting lab for Tiger.

01:02:20.310 --> 01:02:24.760
and Craig Keithley is the person
in Developer Relations who is

01:02:24.760 --> 01:02:26.880
responsible for the I/O Kit area.

01:02:26.880 --> 01:02:29.940
And I, again,
am the manager of the I/O Kit team.
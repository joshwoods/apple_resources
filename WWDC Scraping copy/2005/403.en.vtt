WEBVTT

00:00:00.170 --> 00:00:02.650
Welcome to Power Programming in Xcode.

00:00:02.730 --> 00:00:05.980
This session we're going to look at
both some of the features that have

00:00:05.980 --> 00:00:09.830
been in Xcode for a while as well as
some of the new refinements we've done

00:00:09.830 --> 00:00:15.630
for the 2.1 release and really focus
on using the tool to make your code,

00:00:15.660 --> 00:00:18.940
make it work, and keep it working.

00:00:19.620 --> 00:00:21.170
So, I'm Bill Bumgarner.

00:00:21.200 --> 00:00:22.840
I will be joined shortly by David Ewing.

00:00:22.840 --> 00:00:25.240
We're both in developer
tools architecture.

00:00:25.260 --> 00:00:27.910
And so first,
before we really dive into this,

00:00:28.010 --> 00:00:30.320
let's look at software development.

00:00:30.320 --> 00:00:32.450
You know, what's really the issue here?

00:00:32.460 --> 00:00:36.570
Bottom line is software development
just takes too dang long,

00:00:36.570 --> 00:00:38.200
and it's repetitive.

00:00:38.200 --> 00:00:41.730
It's a lot of making mistakes and a lot
of finding and fixing those mistakes.

00:00:41.800 --> 00:00:45.400
You know, and really,
time flies when you're mired in tedium.

00:00:45.400 --> 00:00:47.540
I think we've all experienced this.

00:00:49.090 --> 00:00:50.730
So...

00:00:51.430 --> 00:00:53.780
Looking at specifically
where the time goes,

00:00:53.780 --> 00:00:56.060
it's all about that edit, compile, run,
debug loop.

00:00:56.060 --> 00:00:59.050
Or now the model, edit, compile, run,
debug loop.

00:00:59.060 --> 00:01:04.100
And a part of that is writing your code,
which is, you know,

00:01:04.100 --> 00:01:06.640
it's advanced word processing,
more or less.

00:01:06.660 --> 00:01:10.560
And, you know, you want to,
it's just a lot of complexity,

00:01:10.560 --> 00:01:13.130
a lot of details to remember there.

00:01:13.140 --> 00:01:15.590
And then you move into,
you've got to build the products.

00:01:15.790 --> 00:01:17.980
Now, with the applications
we're building today,

00:01:17.980 --> 00:01:21.340
you are very often targeting multiple
versions of an operating system.

00:01:21.340 --> 00:01:23.690
Now you're targeting
multiple kinds of CPUs.

00:01:23.740 --> 00:01:26.860
As well, you're looking at having
different configurations.

00:01:26.880 --> 00:01:29.700
You've got your debug configuration
and release configuration,

00:01:29.700 --> 00:01:33.090
maybe a testing configuration,
maybe even like professional

00:01:33.090 --> 00:01:35.280
versus light configurations.

00:01:36.920 --> 00:01:40.050
You also need to figure out
whether or not it works.

00:01:40.050 --> 00:01:41.600
And that can be actually challenging.

00:01:41.600 --> 00:01:44.800
It's not just the quality assurance of
double-clicking the app on the desktop,

00:01:44.800 --> 00:01:47.590
making sure it launches and runs
and does what it's supposed to,

00:01:47.590 --> 00:01:51.420
but it's also verifying that the
underlying functionality is working,

00:01:51.420 --> 00:01:54.390
your algorithms are correct,
and things like that.

00:01:54.680 --> 00:01:58.070
And once you've identified
that there are problems,

00:01:58.070 --> 00:02:00.560
you've got to spend the
time to fix what went wrong.

00:02:00.590 --> 00:02:03.620
And this is the debugging process.

00:02:03.950 --> 00:02:06.810
And as well, you got to make sure you
didn't break other things.

00:02:06.920 --> 00:02:10.180
Because as you know with software,
software is a very complex beast.

00:02:10.220 --> 00:02:14.370
And if you change one thing over here,
it may break something over there

00:02:14.370 --> 00:02:16.980
even though the two seem unrelated.

00:02:17.000 --> 00:02:18.410
And then you get back
to the repetition part.

00:02:18.410 --> 00:02:24.130
So really, software development is really
just a highly repetitive process.

00:02:24.210 --> 00:02:25.870
There's lots of tedious steps.

00:02:26.170 --> 00:02:31.030
And lots of research shows that tedium
plus repetition means lots of silly,

00:02:31.030 --> 00:02:33.680
often time-consuming mistakes.

00:02:34.050 --> 00:02:36.700
So how are we going to use
Xcode to develop this process,

00:02:36.700 --> 00:02:40.550
or what features have we really added
to Xcode with the goal of making this

00:02:40.550 --> 00:02:44.170
process less tedious and more productive?

00:02:44.350 --> 00:02:47.420
First,
we want to reinforce the big picture.

00:02:47.650 --> 00:02:51.110
Software is more complex now
than it's ever been before.

00:02:51.210 --> 00:02:53.670
In particular,
your frameworks just simply have more

00:02:53.700 --> 00:02:55.470
functionality and are doing more for you.

00:02:55.500 --> 00:02:57.870
So even if you're writing
less code because you're using

00:02:57.870 --> 00:03:00.440
things like Quartz Composer,
Core Data,

00:03:00.440 --> 00:03:05.000
and Spotlight and these other things,
there's more moving parts underneath

00:03:05.000 --> 00:03:07.490
and sometimes they can mash together.

00:03:07.930 --> 00:03:11.060
First,
we want to reinforce the big picture.

00:03:11.060 --> 00:03:14.770
Software is more complex now
than it's ever been before.

00:03:14.820 --> 00:03:17.260
In particular,
your frameworks just simply have more

00:03:17.280 --> 00:03:19.100
functionality and are doing more for you.

00:03:19.100 --> 00:03:21.460
So even if you're writing
less code because you're using

00:03:21.470 --> 00:03:24.030
things like Quartz Composer,
Core Data,

00:03:24.040 --> 00:03:26.160
and Spotlight and these other things,
there's more moving parts underneath

00:03:26.160 --> 00:03:26.160
and sometimes they can mash together.

00:03:26.600 --> 00:03:30.270
And whenever you do make a mistake,
the mistake should be indicated very

00:03:30.270 --> 00:03:34.810
clearly when Xcode can figure out
that there is a mistake present.

00:03:35.580 --> 00:03:39.230
And it should really remember
your past successes so you don't

00:03:39.230 --> 00:03:40.740
reinvent the wheel in the future.

00:03:43.400 --> 00:04:14.300
[Transcript missing]

00:04:19.900 --> 00:04:39.300
[Transcript missing]

00:04:39.640 --> 00:04:41.660
You need to understand
how your code works.

00:04:41.780 --> 00:04:45.530
Everybody around here is dealing
with huge projects most of the time,

00:04:45.530 --> 00:04:49.810
and you need to have the
navigation capabilities that let

00:04:49.910 --> 00:04:51.350
you move around through your code.

00:04:53.700 --> 00:04:56.830
So then we're going to talk a little
bit about creating new source files

00:04:56.880 --> 00:05:01.000
and some of the extensibility features
in Xcode that let you do that,

00:05:01.010 --> 00:05:02.740
customize the way you do that.

00:05:02.800 --> 00:05:09.420
And we'll talk about writing code itself
accurately and actually some new features

00:05:09.470 --> 00:05:16.570
in Xcode 2.0 that help you do that more
accurately and extend what's there.

00:05:17.660 --> 00:05:21.900
So, understanding the system APIs,
hopefully all of you,

00:05:21.900 --> 00:05:24.100
if you're using Xcode now,
you use the integrated

00:05:24.100 --> 00:05:25.730
documentation viewer that's there.

00:05:25.740 --> 00:05:29.970
The features,
it supports nice text searching,

00:05:29.970 --> 00:05:31.540
API searching.

00:05:31.540 --> 00:05:34.760
One of the best ways to get to
that information is using the

00:05:34.760 --> 00:05:38.680
option double-click functionality,
where you option double-click

00:05:38.680 --> 00:05:41.480
on a word in your source file,
and it starts an API search

00:05:41.480 --> 00:05:43.080
in the documentation viewer.

00:05:44.060 --> 00:05:47.830
The new in Xcode 2.0 is
automatically updating that

00:05:47.830 --> 00:05:50.120
documentation over the internet.

00:05:50.330 --> 00:05:53.290
And of course,
there's lots of new content.

00:05:53.300 --> 00:05:56.300
Here's an example.

00:05:56.610 --> 00:05:59.230
This is the Xcode 2.1 user's guide.

00:05:59.420 --> 00:06:02.290
I mean, this thing is huge.

00:06:02.460 --> 00:06:10.290
Xcode 1 was, I don't know,
probably a quarter of that thickness.

00:06:10.560 --> 00:06:14.690
So another new thing in the
documentation viewer itself is the

00:06:14.690 --> 00:06:16.800
man page support that's in there.

00:06:16.800 --> 00:06:19.490
So the APIs, system APIs are indexed.

00:06:19.710 --> 00:06:24.940
And in fact, the whole man page system is
indexed for full text searches.

00:06:24.950 --> 00:06:29.290
And of course, there's lots of new
documentation in Tiger.

00:06:31.400 --> 00:06:33.350
So let's talk about moving
around in your code.

00:06:33.380 --> 00:06:34.660
There's lots of ways to do that.

00:06:34.730 --> 00:06:39.510
There's the class browser that
lets you get access to the system

00:06:40.200 --> 00:06:42.300
classes and your own classes.

00:06:42.300 --> 00:06:45.490
There's lots of options for
navigating through that.

00:06:45.800 --> 00:06:50.650
You can click on items in the list
and go to declarations or option

00:06:50.650 --> 00:06:53.760
click to take you to the definitions.

00:06:55.320 --> 00:06:59.610
There's the Project Symbol Smart Group,
which lets you focus in on the

00:06:59.810 --> 00:07:02.460
source in your project itself.

00:07:02.460 --> 00:07:04.300
And it's not limited just to classes.

00:07:04.300 --> 00:07:09.740
There's of course functions and type defs
and preprocessor macros are listed there.

00:07:09.740 --> 00:07:14.670
You can use the search field to
filter down to what you want to look

00:07:14.670 --> 00:07:17.370
at and go directly to that code.

00:07:19.080 --> 00:07:22.490
And the best way, at least I find,
to move around through your source

00:07:22.490 --> 00:07:23.940
code is command double click.

00:07:24.000 --> 00:07:28.770
Click on a word and it does an
API search for you right there.

00:07:29.080 --> 00:07:31.110
And if there's multiple choices,
it'll bring up a little

00:07:31.200 --> 00:07:32.140
pop up you can select.

00:07:32.200 --> 00:07:37.410
If there's lots and lots of choices,
it'll actually do a definition search

00:07:37.520 --> 00:07:40.110
and bring up the batch find window.

00:07:41.070 --> 00:07:44.000
And what's new in Xcode
2.0 with class modeling,

00:07:44.000 --> 00:07:48.460
you can use that to navigate through
your source code too and go directly

00:07:48.460 --> 00:07:51.830
to the source from the class model.

00:07:52.000 --> 00:07:57.080
You can create these class models by just
clicking on an item in the groups and

00:07:57.160 --> 00:08:04.990
files group and say click quick model
in the design edit in the design menu.

00:08:07.180 --> 00:08:09.750
Okay, let's talk,
now that you've sort of found

00:08:09.760 --> 00:08:14.900
your way around through things,
let's talk about creating code.

00:08:15.480 --> 00:08:18.650
So we provide lots of file
templates on the system for

00:08:18.650 --> 00:08:21.840
creating new types of source files.

00:08:21.840 --> 00:08:27.420
You can--well, there's lots, you know,
for Java, Cocoa, Carbon.

00:08:27.420 --> 00:08:29.360
But you can create your
own file templates too,

00:08:29.360 --> 00:08:31.000
and I strongly suggest you do.

00:08:31.180 --> 00:08:33.120
It really makes your life easier.

00:08:33.250 --> 00:08:36.610
Those of us who live, you know,
in a corporate environment where you need

00:08:36.770 --> 00:08:40.800
to have special headers at the top of the
file that has the copyright information,

00:08:40.950 --> 00:08:44.740
by creating your own file templates,
you can do that very easily.

00:08:44.740 --> 00:08:50.320
So you can look at what's there installed
on the system sitting inside /library.

00:08:50.320 --> 00:08:54.370
And when you create your own,
the best place to put them

00:08:54.480 --> 00:08:59.300
is inside your home directory
in the library subdirectory.

00:08:59.300 --> 00:09:02.360
And one of the cool things, of course,
about creating file templates

00:09:02.360 --> 00:09:04.100
is that they do macro expansion.

00:09:04.100 --> 00:09:09.440
You can have words in the file that
get expanded when the file is created.

00:09:09.440 --> 00:09:15.090
One of the common ones, of course,
is the ever-present organization

00:09:15.090 --> 00:09:20.500
name that occurs in most of our
file templates that we ship.

00:09:20.500 --> 00:09:23.840
And that gets expanded by
default to __mycompanyname__.

00:09:23.840 --> 00:09:28.910
And that's not particularly useful,
but you can use the user defaults.

00:09:28.910 --> 00:09:32.960
You can--at the command line,
you can set the macro--the

00:09:32.970 --> 00:09:35.300
default macro expansion for that.

00:09:35.360 --> 00:09:39.690
That's actually documented
in the expert user defaults

00:09:39.740 --> 00:09:41.420
item underneath the helpdesk.

00:09:41.420 --> 00:09:42.580
the help menu in Xcode.

00:09:42.580 --> 00:09:45.580
So that's a good place to look for stuff.

00:09:47.500 --> 00:09:50.400
Okay,
let's talk about actually writing code.

00:09:50.400 --> 00:09:53.960
So we have a number of
features in Xcode that we,

00:09:54.050 --> 00:10:01.470
together we call CodeSense that help
you accurately enter your new code.

00:10:02.420 --> 00:10:05.210
Something that's familiar from
the beginnings of Xcode is

00:10:05.210 --> 00:10:06.850
the completion command itself.

00:10:06.860 --> 00:10:08.610
That's available in the edit menu.

00:10:08.620 --> 00:10:14.140
And that brings up a pop-up list that
contextually helps you insert code.

00:10:14.140 --> 00:10:17.340
You can scroll through the list
and see what you're looking for.

00:10:17.340 --> 00:10:19.940
You can type to filter it down
and the list shrinks down.

00:10:19.940 --> 00:10:22.350
That's been there for a while.

00:10:22.360 --> 00:10:26.560
Something that's new in Xcode 2.0
is the next completion command.

00:10:26.560 --> 00:10:31.930
And this immediately inserts what Xcode
thinks is its best guess into your text.

00:10:32.300 --> 00:10:39.170
Xcode itself uses lots of heuristics
to come up with a short list of

00:10:39.170 --> 00:10:41.570
what it thinks are its best guesses.

00:10:41.580 --> 00:10:46.700
And the next completion command actually
will cycle through that list of commands.

00:10:46.700 --> 00:10:49.620
So if the first guess isn't
what you were looking for,

00:10:49.620 --> 00:10:51.280
you can hit the command again.

00:10:51.280 --> 00:10:55.560
And it'll cycle through its best list.

00:10:55.700 --> 00:10:59.460
And if it's not one of the top items,
what you're looking for, of course,

00:10:59.550 --> 00:11:01.490
you can bring up the completion
list right where you are.

00:11:02.300 --> 00:11:05.860
And you can move back and forth
between the completion list and

00:11:05.860 --> 00:11:08.000
the next completion command,
too.

00:11:08.060 --> 00:11:15.690
One of the things when you actually
insert the text into a file is that

00:11:15.920 --> 00:11:20.810
it will put argument placeholders in
places where you'll need to fit in.

00:11:20.820 --> 00:11:23.160
Where you'll need to insert some code.

00:11:23.760 --> 00:11:28.670
There's a select next placeholder
command also in the edit menu that

00:11:28.670 --> 00:11:31.070
you use to move between those.

00:11:31.130 --> 00:11:32.030
You can also double click.

00:11:32.220 --> 00:11:34.380
You'll notice that we'll
see this in a little bit.

00:11:34.820 --> 00:11:39.600
But those placeholders have angle
brackets and pound signs quoting them.

00:11:39.820 --> 00:11:43.030
And you can double click on
those and have it select.

00:11:43.900 --> 00:11:48.830
But one other feature that's
new to CodeSense is text macros.

00:11:48.960 --> 00:11:52.990
So these are a way to extend not
just the completion commands,

00:11:53.190 --> 00:11:57.190
but you can get to the text macros
through the menu system as well.

00:11:57.480 --> 00:12:00.950
And you can--well,
let's talk about that here.

00:12:01.050 --> 00:12:02.690
Text macros.

00:12:02.820 --> 00:12:04.910
So they're in the edit menu.

00:12:05.500 --> 00:12:08.880
Now, when you're typing code,
the most convenient thing to do when you

00:12:08.880 --> 00:12:13.040
insert a text macro is not really to go
up into a menu and down into a hierarchy.

00:12:13.160 --> 00:12:16.550
But the one thing that's cool
about having these in the edit

00:12:16.590 --> 00:12:21.540
menu is that they can then have
key equivalents assigned to them.

00:12:21.540 --> 00:12:27.030
And you can go into the Xcode preference
and go to the key bindings panel in there

00:12:27.320 --> 00:12:30.200
and assign key bindings to these macros.

00:12:30.540 --> 00:12:35.900
So you really can keep your hand on
the keyboard and insert text macros.

00:12:35.920 --> 00:12:39.380
But of course, you can get to them right
through code completion.

00:12:39.480 --> 00:12:42.640
The completion list and the
next completion commands

00:12:42.640 --> 00:12:44.480
also know about text macros.

00:12:44.540 --> 00:12:47.830
We'll show a little bit about how that
works and how that hooks together.

00:12:47.840 --> 00:12:50.710
And of course, you can add your own.

00:12:50.720 --> 00:12:52.870
What good are text macros
if you can't add your own?

00:12:55.630 --> 00:12:57.300
So creating new text macros.

00:12:57.300 --> 00:13:01.360
Text macros are defined
in property list files,

00:13:01.500 --> 00:13:04.020
standard property list files on Mac OS X.

00:13:04.020 --> 00:13:08.000
The files themselves need to
have the XCTXT macro extension

00:13:08.110 --> 00:13:09.460
so that we know what they are.

00:13:10.360 --> 00:13:13.510
We ship with a bunch that sit
inside the Xcode application

00:13:13.600 --> 00:13:15.780
itself inside the plugins folder.

00:13:15.780 --> 00:13:20.260
And that text macros.XCTXT macro
file there is actually a bundle

00:13:20.260 --> 00:13:24.940
and the macros themselves are
sitting further down inside there.

00:13:24.940 --> 00:13:28.020
But it's really easy to find
that stuff and look at them.

00:13:28.020 --> 00:13:32.660
When you define your own text macros,
you should put them in your home

00:13:32.660 --> 00:13:37.250
directory inside of the specification
subfolder where all of our,

00:13:37.250 --> 00:13:40.890
where a number, well there's,
there's a bunch of file

00:13:40.890 --> 00:13:43.940
templates go inside there too,
right, inside application support,

00:13:43.940 --> 00:13:46.050
Apple developer tools.

00:13:47.910 --> 00:13:49.740
So what can text macros do?

00:13:49.740 --> 00:13:53.300
Well,
if you put your text macros in a menu,

00:13:53.300 --> 00:13:57.140
you can actually set them up to
cycle through a list of macros.

00:13:57.140 --> 00:14:02.130
So let's say, for example,
you want to insert a for loop.

00:14:02.160 --> 00:14:04.970
Well,
there's probably lots of different types

00:14:04.970 --> 00:14:07.280
of for loops that you want to insert.

00:14:07.280 --> 00:14:12.690
Oh, I want to say for i equals
0 to 10 or whatever.

00:14:12.690 --> 00:14:17.220
You might also want to do a for
loop that goes through an NSArray.

00:14:17.800 --> 00:14:21.780
So you can define macros to
do all those sorts of things.

00:14:21.780 --> 00:14:25.510
We actually have a bunch of macros
for for loops and some similar

00:14:25.600 --> 00:14:27.100
things you can add to that.

00:14:27.160 --> 00:14:32.140
But you can set the menu up so that when
you hit the key to insert that macro,

00:14:32.140 --> 00:14:34.380
it inserts the first choice.

00:14:34.500 --> 00:14:38.240
If that's not the one you're looking for,
it can cycle to the

00:14:38.240 --> 00:14:39.950
next choice and so on.

00:14:40.250 --> 00:14:43.700
So macros can also inherit
settings from other macros.

00:14:43.840 --> 00:14:49.770
So we'll see in a second that macros
are really just dictionaries that can,

00:14:49.770 --> 00:14:54.800
and they can inherit their
settings from their parent macro.

00:14:54.800 --> 00:14:58.120
And they can inherit settings
from user defaults too.

00:14:58.120 --> 00:15:01.160
So you can set your macro to
insert some text that actually

00:15:01.560 --> 00:15:03.640
gets set using a user default.

00:15:04.380 --> 00:15:08.670
One of the common things
is some of our macros,

00:15:08.670 --> 00:15:11.770
for instance, for the for loop,
are actually

00:15:12.000 --> 00:15:14.130
By default,
it'll put that curly brace on the

00:15:14.260 --> 00:15:16.660
same line as the for statement itself.

00:15:16.790 --> 00:15:19.960
Well,
the way that's done is that there's a

00:15:19.970 --> 00:15:24.300
setting in there called block separator
that sits between that closing paren

00:15:24.300 --> 00:15:28.590
and that opening curly brace that we,
by default, define to be a space.

00:15:28.740 --> 00:15:31.510
Well, you can define it to
be a carriage return,

00:15:31.620 --> 00:15:34.940
so using your user default,
so that when you insert the text macros,

00:15:34.940 --> 00:15:37.880
it puts the curly brace on the next line.

00:15:39.400 --> 00:15:41.250
Okay, let's show one here.

00:15:41.340 --> 00:15:46.480
I defined a little text macro called
NSEnum and used code completion

00:15:46.480 --> 00:15:48.460
to insert that into the text.

00:15:48.460 --> 00:15:52.770
And it expanded to this multi-line
thing that had placeholders in there and

00:15:52.770 --> 00:15:55.810
you can move between the placeholders.

00:15:56.210 --> 00:15:57.340
So very convenient.

00:15:57.340 --> 00:16:00.000
I type five characters, hit complete,
and boom,

00:16:00.000 --> 00:16:02.160
all that stuff went into the text file.

00:16:02.160 --> 00:16:04.890
So what does that macro
actually look like?

00:16:04.980 --> 00:16:07.080
Well, there's an identifier.

00:16:07.080 --> 00:16:08.580
It's got a name.

00:16:08.580 --> 00:16:12.480
It needs that name because that's how
it gets hooked into the menu system.

00:16:12.480 --> 00:16:15.300
And it has a parent macro.

00:16:15.300 --> 00:16:19.710
By saying it's based on objc,
that means it actually will go into

00:16:19.710 --> 00:16:23.720
the Objective-C menu that's up there,
so it makes it easy to find.

00:16:24.280 --> 00:16:27.330
It will show up in the menu item
with the name enumerator loop.

00:16:27.510 --> 00:16:31.360
It also, at the bottom there,
it says completion prefix.

00:16:31.500 --> 00:16:35.820
Well, that's what you type if you want to
hook into the code completion system.

00:16:35.820 --> 00:16:37.050
All right.

00:16:37.310 --> 00:16:40.540
The text string itself is mostly obvious.

00:16:40.690 --> 00:16:42.800
I mean,
it's just the code that gets inserted,

00:16:42.800 --> 00:16:46.450
and you can put placeholders in there
that hook into the code completion

00:16:46.450 --> 00:16:48.360
system for moving between placeholders.

00:16:48.360 --> 00:16:52.540
The one cool thing there,
the placeholder you'll notice that's

00:16:52.540 --> 00:16:57.720
highlighted is surrounded by angle
bracket pound sign exclamation point.

00:16:57.740 --> 00:17:02.130
Now, what that does is that bit
will get replaced with whatever

00:17:02.130 --> 00:17:04.170
the current selection is.

00:17:04.770 --> 00:17:07.530
So if you select some,
let's say a couple of lines of code,

00:17:07.530 --> 00:17:11.160
and then use this macro
from the edit menu,

00:17:11.160 --> 00:17:14.660
it will end up wrapping
that code with this macro.

00:17:14.660 --> 00:17:18.920
So you can put stuff inside of
a loop easily by doing this.

00:17:23.420 --> 00:17:27.010
Well, let's talk a little bit about
source control management

00:17:27.220 --> 00:17:31.810
and project configuration,
what's new in Xcode 2.0 and 2.1.

00:17:33.260 --> 00:17:35.990
So source control management.

00:17:36.370 --> 00:17:39.100
Source control management
is about leaving,

00:17:39.110 --> 00:17:41.200
not leaving any of your changes behind.

00:17:41.200 --> 00:17:45.290
You need to know the history
of what changes you've had.

00:17:45.830 --> 00:17:47.200
So what's new?

00:17:47.250 --> 00:17:51.820
Well, in 2.0 and 2.1, we've improved the
Perforce support greatly.

00:17:51.820 --> 00:17:54.080
So those of you who are using Perforce,
yes.

00:17:54.150 --> 00:17:56.950
A little applause there, that's right.

00:17:56.950 --> 00:17:59.900
I think you'll be much
happier with what's there now.

00:17:59.900 --> 00:18:03.320
We absolutely want to know
if we've missed a few things.

00:18:03.320 --> 00:18:05.960
But boy, it's so much better than it was.

00:18:07.470 --> 00:18:11.210
We've added initial support
for unwrapped files,

00:18:11.210 --> 00:18:12.240
such as nib files.

00:18:12.330 --> 00:18:16.670
So this, of course,
matters for the Perforce folks

00:18:16.810 --> 00:18:19.800
and the Subversion folks.

00:18:20.150 --> 00:18:22.870
But it also matters for those using CVS.

00:18:22.930 --> 00:18:27.420
The mainline CVS that's out in the
wild doesn't support wrapping nib

00:18:27.420 --> 00:18:29.300
files and checking those in and out.

00:18:29.540 --> 00:18:33.190
You really need to use unwrapped files.

00:18:34.290 --> 00:18:39.310
So the subversion support itself
has been greatly enhanced.

00:18:39.410 --> 00:18:43.800
And a lot of this is also due to
the fact that Subversion itself has

00:18:43.800 --> 00:18:46.340
matured quite a bit with version 1.2.

00:18:50.300 --> 00:19:18.000
[Transcript missing]

00:19:20.700 --> 00:19:38.900
[Transcript missing]

00:19:40.630 --> 00:19:44.840
And a lot of this is also due to
the fact that Subversion itself has

00:19:45.000 --> 00:19:47.540
matured quite a bit with version 1.2.

00:19:48.990 --> 00:19:51.860
There are things you can do
to enhance the precompiled

00:19:51.930 --> 00:19:55.580
header support that's built in,
and there's some new things in

00:19:55.580 --> 00:19:59.420
Xcode 2.1 that allow this to be
even better than it was before.

00:20:01.200 --> 00:20:02.850
There's predictive compilation.

00:20:02.950 --> 00:20:07.260
So this is something you turn on
in the build preferences pane.

00:20:07.260 --> 00:20:09.980
It's just a checkbox there.

00:20:09.980 --> 00:20:12.480
And what that does is that
when you save your file,

00:20:12.480 --> 00:20:15.330
it'll actually go out and start a
compile of that file rather than

00:20:15.330 --> 00:20:16.910
waiting for you to go do a build.

00:20:16.920 --> 00:20:20.120
Now it won't show any errors or
anything like that right there,

00:20:20.300 --> 00:20:22.540
but it'll speed up the
process if you decide,

00:20:22.540 --> 00:20:25.240
oh, I really am ready to do
a build or do a compile.

00:20:25.240 --> 00:20:30.150
Most of the work has already been
done by the time you get there.

00:20:32.090 --> 00:20:33.840
There's predictive compilation.

00:20:33.840 --> 00:20:38.160
So this is something you turn on
in the build preferences pane.

00:20:38.160 --> 00:20:40.700
It's just a checkbox there.

00:20:41.010 --> 00:20:43.240
And what that does is that
when you save your file,

00:20:43.380 --> 00:20:46.100
it'll actually go out and start a
compile of that file rather than

00:20:46.410 --> 00:20:47.730
waiting for you to go do a build.

00:20:47.870 --> 00:20:51.000
Now it won't show any errors or
anything like that right there,

00:20:51.000 --> 00:20:53.440
but it'll speed up the
process if you decide,

00:20:53.440 --> 00:20:56.140
oh, I really am ready to do
a build or do a compile.

00:20:56.350 --> 00:21:01.060
Most of the work has already been
done by the time you get there.

00:21:02.000 --> 00:21:04.490
Universal builds don't
live together right now.

00:21:04.490 --> 00:21:09.340
So in your debug build configurations,
you want to set just the

00:21:09.500 --> 00:21:14.210
current machine architecture
as the one you want to build.

00:21:14.260 --> 00:21:16.570
And then you can still use ZeroLink.

00:21:16.580 --> 00:21:18.200
ZeroLink is supported on the Intel.

00:21:21.770 --> 00:21:23.100
Then there's distributed builds.

00:21:23.170 --> 00:21:26.470
Of course, it makes no sense to have all
these computers sitting around your

00:21:26.470 --> 00:21:27.780
office that are just sitting idle.

00:21:27.780 --> 00:21:31.640
You want to help speed up
your build by using those.

00:21:34.920 --> 00:21:36.210
Then there's distributed builds.

00:21:36.270 --> 00:21:39.570
Of course, it makes no sense to have all
these computers sitting around your

00:21:39.570 --> 00:21:40.880
office that are just sitting idle.

00:21:40.880 --> 00:21:44.800
You want to help speed up
your build by using those.

00:21:52.450 --> 00:21:53.400
And there's Automator.

00:21:53.400 --> 00:21:57.120
Automator has some really cool things,
a new feature there in Tiger.

00:21:58.500 --> 00:22:17.400
[Transcript missing]

00:22:18.250 --> 00:22:20.750
But you can go a step further.

00:22:20.750 --> 00:22:27.430
With Xcode 2.1,
we can share these precompiled headers

00:22:27.490 --> 00:22:31.540
across projects a lot more easily
than you could in previous versions.

00:22:31.540 --> 00:22:35.200
So in order to do that,
there's two main things

00:22:35.310 --> 00:22:36.980
that you have to do.

00:22:36.980 --> 00:22:41.110
You have to make sure that your prefix
file actually has the same name in

00:22:41.110 --> 00:22:43.130
each case where you're using it.

00:22:43.980 --> 00:22:45.780
And the contents need to be identical.

00:22:45.810 --> 00:22:51.790
You can't have separate comments, oh,
this is my prefix file for this project,

00:22:51.790 --> 00:22:53.700
and it still includes the same source.

00:22:53.720 --> 00:22:56.640
We actually look at that contents
to make sure they're identical.

00:22:56.680 --> 00:23:02.040
The build settings, of course,
need to be the same between targets that

00:23:02.040 --> 00:23:05.220
build and share precompiled headers.

00:23:05.220 --> 00:23:09.480
We're actually a lot better about
determining which build settings matter,

00:23:09.480 --> 00:23:10.130
though.

00:23:10.140 --> 00:23:13.920
In older versions, we weren't so good.

00:23:13.920 --> 00:23:35.020
In older versions, we weren't so good.

00:23:36.260 --> 00:23:38.530
Distributed builds, sharing the load.

00:23:38.530 --> 00:23:40.370
So this is really easy to set up.

00:23:40.450 --> 00:23:43.890
You just go into the distributed
builds pane of the preferences panel.

00:23:43.890 --> 00:23:48.250
And you turn on sharing
for your machine or not.

00:23:48.290 --> 00:23:52.720
But what you need to do is go to the
other machines that you want to use

00:23:52.720 --> 00:23:57.500
to build your project with and make
sure that they're set up to share.

00:23:58.760 --> 00:24:02.040
The machines need to be running
the same version of the OS.

00:24:02.120 --> 00:24:04.850
And they also need to be running
the same version of the Xcode tools,

00:24:04.900 --> 00:24:07.250
including the GCC compiler.

00:24:07.260 --> 00:24:10.260
But once that's done,
you can start using the sharing.

00:24:10.260 --> 00:24:12.830
We've actually fixed
a lot of bugs in this,

00:24:12.830 --> 00:24:17.260
too, in the 2.0 release and 2.1 release.

00:24:17.260 --> 00:24:21.820
Where it would have a hard
time knowing whether a machine

00:24:21.820 --> 00:24:24.260
was offline and things would--

00:24:24.390 --> 00:24:26.800
It would sort of forget about a
machine or a machine would be,

00:24:26.800 --> 00:24:28.900
it would hang a build.

00:24:32.690 --> 00:24:36.400
You can--no, so same architecture also,
right?

00:24:36.400 --> 00:24:38.350
The machines need to be
the same architecture,

00:24:38.350 --> 00:24:43.700
so you cannot share between a
PowerPC and an Intel machine.

00:24:43.940 --> 00:24:45.260
So they really are much faster.

00:24:45.260 --> 00:24:49.100
You take one example project here,
relatively small,

00:24:49.100 --> 00:24:54.130
not terribly small project,
went down by a factor of two and a half

00:24:54.280 --> 00:24:57.360
by distributing to three other machines.

00:25:00.110 --> 00:25:02.600
So scripting Xcode.

00:25:02.630 --> 00:25:10.300
Xcode build is the main
thing for scripting builds.

00:25:10.300 --> 00:25:14.100
We at Apple internally use Xcode
build to build hundreds and

00:25:14.100 --> 00:25:16.960
hundreds of projects for our builds.

00:25:17.070 --> 00:25:19.160
It's very easy to use from shell scripts.

00:25:19.160 --> 00:25:23.040
It has command line options to
specify which build configuration

00:25:23.040 --> 00:25:25.810
or which target you want to build.

00:25:25.810 --> 00:25:29.310
It's great for doing your release builds.

00:25:30.030 --> 00:25:32.600
AppleScript support is much, much better.

00:25:32.600 --> 00:25:34.370
2.0 improved things a lot.

00:25:34.500 --> 00:25:36.640
2.1 went a bunch of steps further.

00:25:36.640 --> 00:25:40.260
So you can now create and
configure your targets and set

00:25:40.260 --> 00:25:42.160
build settings via AppleScript.

00:25:42.160 --> 00:25:45.580
You can get to shell script build phases.

00:25:45.580 --> 00:25:49.980
You can add files to your
project and add them to targets.

00:25:50.070 --> 00:25:52.980
You can run builds from AppleScript.

00:25:52.980 --> 00:25:56.580
So of course, if you can run builds,
you can run builds of multiple projects,

00:25:56.580 --> 00:25:57.080
right?

00:25:58.300 --> 00:26:01.060
One thing we don't support
yet is creating a project from

00:26:01.060 --> 00:26:02.240
scratch using AppleScript.

00:26:05.380 --> 00:26:05.900
Automator.

00:26:05.900 --> 00:26:09.100
Automator is new in Tiger,
and it has some built-in

00:26:09.220 --> 00:26:11.240
actions that will do builds.

00:26:11.290 --> 00:26:16.670
It also has actions that support
some of the CVS commands,

00:26:16.670 --> 00:26:20.370
and it does versioning with
the AGV tool that we ship with.

00:26:22.910 --> 00:26:25.810
With that, I'm gonna bring Bill back up,
and we're gonna talk a

00:26:25.910 --> 00:26:27.300
little bit about debugging.

00:26:27.400 --> 00:26:28.300
Thank you, Dave.

00:26:28.620 --> 00:26:30.350
So...

00:26:32.090 --> 00:26:35.280
Now that we have all these awesome tools
for writing lots of code lots faster,

00:26:35.280 --> 00:26:37.200
and you're working with
a higher level framework,

00:26:37.200 --> 00:26:39.930
so that means you get
to write bugs faster,

00:26:39.930 --> 00:26:41.550
and they're more abstract.

00:26:41.740 --> 00:26:47.350
So we figured we really needed to
bring the debugging tools forward.

00:26:47.480 --> 00:26:48.470
What is debugging?

00:26:48.750 --> 00:26:53.150
Well, debugging is all about figuring out
whether or not something works right

00:26:53.220 --> 00:26:55.280
and also fixing what doesn't work.

00:26:55.400 --> 00:26:59.740
Now, what's interesting about this is
especially when you start looking

00:26:59.740 --> 00:27:03.450
at complex applications that
are using the higher level APIs,

00:27:03.450 --> 00:27:06.860
setting a breakpoint on a method
doesn't do you a heck of a lot

00:27:06.990 --> 00:27:11.400
of good if it's the 167,382nd
execution of it that breaks.

00:27:11.400 --> 00:27:14.300
That's a lot of continue button hits.

00:27:14.410 --> 00:27:19.200
So it's really all about figuring out
how to make the debugger not stop.

00:27:19.820 --> 00:27:24.260
So, we now have added several new
kinds of breakpoints here.

00:27:24.260 --> 00:27:26.860
We have conditional breakpoints.

00:27:26.860 --> 00:27:31.370
There's actions on the breakpoints,
including automatically continuing,

00:27:31.370 --> 00:27:34.980
which most importantly will not
actually cause Xcode to come forward or

00:27:34.980 --> 00:27:37.180
change which application is activated.

00:27:37.180 --> 00:27:41.760
So if you're debugging an event loop,
you can actually do so now with GDB.

00:27:42.710 --> 00:27:46.530
There's templates and groups so you
can organize and share your breakpoints

00:27:46.540 --> 00:27:48.660
as well with the important export.

00:27:48.660 --> 00:27:53.290
So, let's look at this in
a little more detail.

00:27:53.490 --> 00:27:54.380
Breakpoint actions.

00:27:54.530 --> 00:27:55.490
These are really cool.

00:27:55.750 --> 00:28:00.210
When a breakpoint is hit,
now GDB and the debugging user

00:28:00.280 --> 00:28:02.340
interface in Xcode can take an action.

00:28:02.340 --> 00:28:05.160
And it's not just like, you know,
do a little command.

00:28:05.160 --> 00:28:07.790
We obviously can send
commands to the debugger and,

00:28:07.810 --> 00:28:11.130
you know, evaluate expressions or do
whatever you need to do.

00:28:11.130 --> 00:28:12.880
But we can also log or speak text.

00:28:12.880 --> 00:28:15.820
So you can actually have your
programs talking to you about

00:28:15.820 --> 00:28:17.490
what internal state they're in.

00:28:17.610 --> 00:28:19.500
Again, without activating Xcode.

00:28:19.500 --> 00:28:22.930
Great for full screen games and the like.

00:28:23.520 --> 00:28:25.650
We can play sounds, play a system sound.

00:28:25.650 --> 00:28:27.050
We can run a shell script.

00:28:27.120 --> 00:28:28.850
So you can run a system command.

00:28:28.850 --> 00:28:31.780
So you can say move a file into
the way or delete a file or do

00:28:31.810 --> 00:28:33.660
whatever you need to do there.

00:28:33.660 --> 00:28:35.400
We can also fire off an Apple script.

00:28:35.400 --> 00:28:38.900
So you can go and tell some other program
to do something or do whatever you can

00:28:38.900 --> 00:28:40.840
possibly imagine with Apple script.

00:28:40.870 --> 00:28:43.290
And now there's the
visualization breakpoint,

00:28:43.440 --> 00:28:46.760
which we saw a demo of in
Chris Espinosa's talk a couple days ago.

00:28:46.760 --> 00:28:47.940
Or was that yesterday?

00:28:48.050 --> 00:28:50.130
Time flies when you're having fun.

00:28:50.570 --> 00:28:53.140
And that'll highlight methods.

00:28:53.400 --> 00:28:58.990
And that'll highlight methods in
the class diagram as they're hit.

00:28:59.720 --> 00:29:00.870
Click.

00:29:00.920 --> 00:29:02.180
Breakpoint conditions.

00:29:02.290 --> 00:29:04.720
This is all about stopping or
not stopping when you want to.

00:29:04.720 --> 00:29:10.590
GDB in the console has the ability
to evaluate arbitrary expressions

00:29:10.690 --> 00:29:11.850
and print out the results.

00:29:11.850 --> 00:29:14.820
What a conditional breakpoint
does is it allows you to evaluate

00:29:14.820 --> 00:29:18.350
the same arbitrary expressions,
and if it returns true or returns false,

00:29:18.350 --> 00:29:21.090
it will either stop at the
breakpoint or it will just ignore

00:29:21.090 --> 00:29:22.920
the breakpoint and life goes on.

00:29:22.950 --> 00:29:25.000
These really aren't true or false.

00:29:25.180 --> 00:29:27.180
It's really zero and non-zero.

00:29:27.180 --> 00:29:29.630
You don't have to worry
too much about the return.

00:29:29.700 --> 00:29:33.660
But you do have to cast the expressions,
and that means the sub-expressions too.

00:29:33.660 --> 00:29:36.760
And if you've noticed,
if you've ever worked with a GDB console,

00:29:36.760 --> 00:29:39.120
a lot of times when you go
and you print something,

00:29:39.120 --> 00:29:42.570
it'll come back and say, hey,
I don't know what you're talking about.

00:29:42.570 --> 00:29:44.320
I don't know what the return type is.

00:29:44.400 --> 00:29:47.600
And you have to go and cast it to
ID or cast it to Boolean or whatever.

00:29:47.600 --> 00:29:50.310
Make sure you do that,
including the sub-expressions,

00:29:50.310 --> 00:29:51.840
as you can see in this example.

00:29:51.840 --> 00:29:53.700
And you can test these in the console.

00:29:53.710 --> 00:29:57.040
Anything that can be evaluated in the
console with a print command can be

00:29:57.120 --> 00:29:59.680
used as a conditional for a breakpoint.

00:29:59.700 --> 00:30:02.820
And they're really powerful
when combined with actions.

00:30:02.840 --> 00:30:06.520
Hey, only play the system
sound on when this is nil,

00:30:06.520 --> 00:30:07.880
something like that.

00:30:07.940 --> 00:30:10.740
Breakpoint's conditions
are supported for C,

00:30:10.740 --> 00:30:13.210
C++, Objective-C, and Objective-C++.

00:30:13.390 --> 00:30:17.360
And that's just because of the
capabilities of the underlying debugger.

00:30:17.360 --> 00:30:20.030
So now the templates and the groups.

00:30:20.110 --> 00:30:22.560
So now that we've got these
really amazing breakpoints,

00:30:22.560 --> 00:30:25.110
we want to make sure that they
weren't lost or forgotten.

00:30:25.120 --> 00:30:28.070
And you can group them together,
and you can collect your

00:30:28.070 --> 00:30:29.540
breakpoints together.

00:30:29.540 --> 00:30:32.710
So you can have sets of breakpoints for
particular kinds of debugging tasks.

00:30:32.750 --> 00:30:37.300
So you can have custom groups,
and you can enable and disable entire

00:30:37.300 --> 00:30:39.330
groups with a single control click.

00:30:39.380 --> 00:30:42.320
So if you need a set of
breakpoints for debugging,

00:30:42.320 --> 00:30:47.010
say, the rendering of an NS view, hey,
you can do a whole set of them, enable,

00:30:47.030 --> 00:30:48.380
disable all at once.

00:30:48.380 --> 00:30:50.610
If you need to do something
down at the model layer,

00:30:50.610 --> 00:30:51.890
you can do the same thing.

00:30:51.940 --> 00:30:55.010
As well, you can have what are
called template breakpoints.

00:30:55.050 --> 00:30:57.490
And with a template breakpoint,
it's simply a breakpoint

00:30:57.490 --> 00:30:58.780
that provides a template.

00:30:59.390 --> 00:31:04.280
That is available in the context menu
in the gutter of your source code.

00:31:04.400 --> 00:31:07.240
So you can just create a new
breakpoint of that type anywhere

00:31:07.310 --> 00:31:09.420
you want to very easily.

00:31:09.440 --> 00:31:12.180
And the customized templates
are just done by creating a

00:31:12.490 --> 00:31:14.340
template breakpoints group.

00:31:14.340 --> 00:31:17.470
Now, of course, in Xcode,
this means we've got the ability

00:31:17.560 --> 00:31:21.950
to import and export breakpoints,
as well as the configurations,

00:31:21.960 --> 00:31:23.620
as well as a couple other things.

00:31:23.620 --> 00:31:26.810
So please,
I want to see a healthy eBay market

00:31:27.090 --> 00:31:29.220
of all the settings in Xcode.

00:31:29.220 --> 00:31:31.270
Or at least post them somewhere.

00:31:31.470 --> 00:31:36.060
So with the watchpoints, OK,
watchpoints are the ability

00:31:36.060 --> 00:31:38.660
to watch a variable,
watch a hunk of memory,

00:31:38.660 --> 00:31:42.020
and cause a breakpoint to
be hit when it changes.

00:31:42.030 --> 00:31:43.250
They're slow.

00:31:43.260 --> 00:31:45.450
They're really, really slow.

00:31:45.510 --> 00:31:46.740
But they're really useful.

00:31:46.750 --> 00:31:50.220
The reason why they're slow is the way
this works is it uses the Mach memory

00:31:50.220 --> 00:31:56.140
manager to mark the pages that the
variables reside upon as read only.

00:31:56.140 --> 00:31:59.060
And then any time a write
happens to one of those,

00:31:59.060 --> 00:32:01.300
the page fault's handled by GDB.

00:32:01.300 --> 00:32:04.040
It goes, was that something I'm
really interested in?

00:32:04.060 --> 00:32:04.500
Yes.

00:32:04.500 --> 00:32:05.420
OK, great break.

00:32:05.420 --> 00:32:05.860
No.

00:32:05.860 --> 00:32:07.220
OK, let's mark the page writable.

00:32:07.220 --> 00:32:10.660
Write to it,
then mark it as readable only again.

00:32:10.780 --> 00:32:16.170
So yeah, this slows execution down a lot,
depending on how often you're hitting

00:32:16.170 --> 00:32:18.660
the pages that are being watched.

00:32:18.900 --> 00:32:20.940
And it's really kind of a last resort.

00:32:20.940 --> 00:32:22.820
But again, it is very, very useful.

00:32:22.820 --> 00:32:23.940
And it's nice that you have it.

00:32:23.940 --> 00:32:28.900
It's simply accessed by Control-clicking
on one of the variables in the variable.

00:32:28.900 --> 00:32:30.620
It's a variable viewer.

00:32:30.620 --> 00:32:33.120
And it's very dangerous to
watch values on the stack.

00:32:33.220 --> 00:32:36.580
In particular, what will happen is if
you go into a system call,

00:32:36.630 --> 00:32:38.970
so you're down in kernel land,
and the kernel goes,

00:32:38.970 --> 00:32:42.820
let me write to the page of
memory that's now read only,

00:32:42.830 --> 00:32:44.770
the kernel doesn't like that.

00:32:44.780 --> 00:32:47.020
So it'll just kill your app.

00:32:47.790 --> 00:32:50.040
And the watches are
automatically removed,

00:32:50.220 --> 00:32:53.580
stack watches are automatically removed
when you return from the stack frame,

00:32:53.690 --> 00:32:57.980
which we consider to be a convenience
feature because that would mean the next

00:32:57.980 --> 00:33:01.020
time the stack grew below that point,
you'd be watching random things.

00:33:01.020 --> 00:33:03.690
It's probably not what you want.

00:33:03.960 --> 00:33:06.280
And you can also watch ranges of memory.

00:33:06.430 --> 00:33:10.060
So as an example here,
I have set up something that can actually

00:33:10.060 --> 00:33:14.620
watch the contents of an NSMutable data,
such that if anywhere in your code

00:33:14.620 --> 00:33:17.050
the contents of that data changes,
the actual bytes that

00:33:17.050 --> 00:33:19.420
are stored within it,
it will break in the debugger.

00:33:19.420 --> 00:33:22.540
And not only will it break,
but it also pops down this really

00:33:22.540 --> 00:33:25.400
nice little sheet that will
actually tell you what bytes

00:33:25.550 --> 00:33:27.540
changed inside the mutable data.

00:33:27.540 --> 00:33:29.340
So that's pretty handy.

00:33:30.320 --> 00:33:35.360
It's not the prettiest bit of syntax,
but we wanted to emphasize that

00:33:35.420 --> 00:33:37.160
it's not just about the GUI.

00:33:37.160 --> 00:33:39.320
There is a console there,
and it's really powerful.

00:33:40.790 --> 00:33:44.180
So, as a demo of all these
wonderful breakpoints,

00:33:44.200 --> 00:33:48.500
I will introduce Chris Friesen,
debugging engineer extraordinaire.

00:33:48.520 --> 00:33:50.490
Thank you, Bill.

00:33:55.780 --> 00:33:59.100
Breakpoint actions are a great way
to instrument your application,

00:33:59.160 --> 00:34:00.910
and you can do it right in the debugger.

00:34:00.970 --> 00:34:03.820
And see, we already have demo one here.

00:34:06.670 --> 00:34:10.240
And what I have here is I have
Sketch running in the debugger already.

00:34:10.240 --> 00:34:12.780
And I'll go down here and I'll
Control-click in the gutter to

00:34:12.780 --> 00:34:14.980
bring up the contextual menu.

00:34:15.680 --> 00:34:18.440
And we'll go to the built-in
breakpoint actions that we have.

00:34:18.490 --> 00:34:20.790
So we have a whole selection here,
and I'll go ahead and select

00:34:20.950 --> 00:34:22.600
sound out and continue.

00:34:22.660 --> 00:34:26.780
Because I'd like to do is I'd like to
find out sort of how often did change

00:34:26.780 --> 00:34:31.790
is getting called in my application
when I'm modifying objects in Sketch.

00:34:34.260 --> 00:34:37.080
So now we'll go draw a shape.

00:34:37.080 --> 00:34:39.070
We get a whole bunch of clicks
the first time on a mouse down,

00:34:39.130 --> 00:34:42.330
which might be a little surprising
because you might not have expected did

00:34:42.330 --> 00:34:44.880
change to be called that many times.

00:34:44.880 --> 00:34:45.960
And then we get two more.

00:34:46.130 --> 00:34:49.140
I couldn't count how many
happened the first time.

00:34:49.140 --> 00:34:53.190
So let's go ahead and
use a logging breakpoint.

00:34:53.500 --> 00:35:06.900
[Transcript missing]

00:35:08.100 --> 00:35:10.920
So as we draw another shape,
on mouse down we see this

00:35:10.920 --> 00:35:12.980
got called seven times.

00:35:13.000 --> 00:35:15.580
Mouse up, we get two more hits.

00:35:18.100 --> 00:35:21.340
Now we can add a breakpoint.

00:35:21.340 --> 00:35:23.860
There's a shortcut to
editing your breakpoints,

00:35:23.860 --> 00:35:25.990
and that is if you
double-click the breakpoint,

00:35:25.990 --> 00:35:28.290
then you automatically go
to the breakpoint window,

00:35:28.530 --> 00:35:31.090
and you're editing the actions.

00:35:31.700 --> 00:35:35.580
So we got these logs whenever
did change was called.

00:35:35.600 --> 00:35:38.660
It would be great if we had some
backtraces to go with that so we could

00:35:38.660 --> 00:35:42.200
explore why did change was actually
getting called what the code paths were.

00:35:42.200 --> 00:35:46.190
So we can add a breakpoint command here.

00:35:46.820 --> 00:35:52.000
And we can use gdb command backtrace,
and we'll only print the

00:35:52.120 --> 00:35:54.570
first five stack frames.

00:35:56.510 --> 00:35:59.470
Now we go back to Sketch.

00:35:59.510 --> 00:36:02.710
And you can see on the console that
we're generating back traces here

00:36:02.710 --> 00:36:05.430
for each time that we hit Did Change.

00:36:05.470 --> 00:36:07.790
And then we get a
couple more on mouse up.

00:36:08.630 --> 00:36:10.850
So from there,
you can go through the console.

00:36:10.970 --> 00:36:14.160
You can explore those stack traces
and figure out whether or not any of

00:36:14.160 --> 00:36:18.580
those did change calls were extraneous,
whether you can optimize anything there.

00:36:21.620 --> 00:36:25.170
Now these template breakpoints are great,
but you'd also like to be

00:36:25.170 --> 00:36:27.160
able to customize them.

00:36:27.160 --> 00:36:33.650
So to do that, we'll create a new group
using contextual menu,

00:36:33.740 --> 00:36:35.670
and we'll call it template

00:36:36.560 --> 00:36:39.970
Now these template breakpoints are great,
but you'd also like to be

00:36:39.970 --> 00:36:41.960
able to customize them.

00:36:41.960 --> 00:36:48.560
So to do that, we'll create a new group
using contextual menu,

00:36:48.560 --> 00:36:48.940
and we'll call it template

00:36:49.550 --> 00:36:53.070
Now these template breakpoints are great,
but you'd also like to be

00:36:53.210 --> 00:36:54.870
able to customize them.

00:36:54.870 --> 00:36:55.890
So to do that, we'll create a new group
using contextual menu,

00:36:55.890 --> 00:36:55.890
and we'll call it template

00:37:12.670 --> 00:37:16.320
So here we have a breakpoint,
and it's got an action.

00:37:16.330 --> 00:37:19.050
The action is visualize,
and I've unselected the

00:37:19.050 --> 00:37:22.350
open debug visualizer,
because I only want the

00:37:22.590 --> 00:37:24.690
variables to be updated in--

00:37:25.010 --> 00:37:26.450
Xcode's debugger interface.

00:37:26.450 --> 00:37:29.290
And then we'll auto-continue
after a pause of one second.

00:37:32.200 --> 00:37:33.670
Xcode's debugger interface.

00:37:33.670 --> 00:37:36.390
And then we'll auto-continue
after a pause of one second.

00:37:46.810 --> 00:37:52.230
So we'll call this show
variables and continue.

00:37:54.720 --> 00:38:02.180
Now when we go back to our code,
and we'll go to set bounds.

00:38:02.830 --> 00:38:04.630
And when I control click
in the gutter again,

00:38:04.690 --> 00:38:06.960
I get our menu,
and here we see our template

00:38:06.960 --> 00:38:11.030
breakpoint is appended to the
bottom of the contextual menu.

00:38:16.970 --> 00:38:23.680
As I go ahead and change
the size of the shape,

00:38:25.000 --> 00:38:34.200
[Transcript missing]

00:38:35.430 --> 00:38:40.640
As I go ahead and change
the size of the shape,

00:38:42.180 --> 00:38:43.880
Now that's great,
but it's hard to get at those

00:38:43.880 --> 00:38:47.210
values because they're simply
displayed and they're lost.

00:38:47.270 --> 00:38:51.560
So we can go ahead and create a
different kind of breakpoint action.

00:38:51.570 --> 00:38:55.440
We'll use the contextual menu,
and we'll use the shortcut add and edit.

00:38:55.520 --> 00:38:57.960
So this adds a fine line
breakpoint and immediately

00:38:57.960 --> 00:39:03.000
opens up the breakpoints window,
and we're here editing the commands.

00:39:03.120 --> 00:39:07.300
So we'll tell it to auto-continue.

00:39:07.400 --> 00:39:11.600
And we can print bounds.size.

00:39:14.240 --> 00:39:15.980
Now that's great,
but it's hard to get at those

00:39:15.980 --> 00:39:19.360
values because they're simply
displayed and they're lost.

00:39:19.400 --> 00:39:23.090
So we can go ahead and create a
different kind of breakpoint action.

00:39:24.800 --> 00:39:27.860
Everything's being logged
to the debugger console.

00:39:27.860 --> 00:39:29.730
Xcode does not come
forward to interrupt us.

00:39:29.730 --> 00:39:31.090
We can interact with our application.

00:39:31.090 --> 00:39:32.120
It's all good.

00:39:37.100 --> 00:39:40.160
Everything's being logged
to the debugger console.

00:39:40.160 --> 00:39:42.040
Xcode does not come
forward to interrupt us.

00:39:42.040 --> 00:39:43.310
We can interact with our application.

00:39:43.430 --> 00:39:44.440
It's all good.

00:39:50.850 --> 00:39:53.860
Everything's being logged
to the debugger console.

00:39:53.860 --> 00:39:55.740
Xcode does not come
forward to interrupt us.

00:39:55.740 --> 00:39:57.100
We can interact with our application.

00:39:57.100 --> 00:39:58.140
It's all good.

00:40:02.620 --> 00:40:07.180
And I added that to the wrong one.

00:40:07.190 --> 00:40:11.640
So I'll add it to an actual breakpoint
in the project breakpoints group here.

00:40:11.740 --> 00:40:16.610
Bound.size.height greater than 200.

00:40:17.710 --> 00:40:26.440
Bounds.size.width less than 50.

00:40:26.440 --> 00:40:29.110
And we'll also add a sound again.

00:40:35.320 --> 00:40:42.910
Bounds.size.width less than 50.

00:40:42.910 --> 00:40:42.910
And we'll also add a sound again.

00:40:48.240 --> 00:40:54.580
Now you can also add breakpoint
actions to your symbolic breakpoints.

00:40:54.580 --> 00:40:57.280
So if we type a symbol name here.

00:40:58.260 --> 00:41:02.470
You'll notice that the enabled
checkbox is in fact just a dash.

00:41:02.470 --> 00:41:04.990
And this is a visual indication
that your breakpoint is pending.

00:41:05.040 --> 00:41:09.070
G2B has not been able to find
a symbol called "dialoog."

00:41:10.540 --> 00:41:15.370
Another reason that your breakpoint might
be pending is that you might have asked

00:41:15.510 --> 00:41:17.400
for a symbol that hasn't been loaded yet.

00:41:17.400 --> 00:41:18.970
For instance,
you might have asked for a symbol that's

00:41:18.970 --> 00:41:23.400
in a bundle or that's in a zero link
file that your code hasn't executed yet.

00:41:23.460 --> 00:41:26.500
So this is a good visual indication
for if you wonder why your breakpoint

00:41:26.500 --> 00:41:30.480
hasn't been hit and it's still pending,
then either you might have entered

00:41:30.480 --> 00:41:35.350
the wrong symbol or GDB simply doesn't
have symbols for that particular file.

00:41:36.850 --> 00:41:42.200
So let's go ahead and
we'll add a valid symbol.

00:41:45.360 --> 00:41:50.590
And it turns out there are many
dialog symbols in our application.

00:41:50.610 --> 00:41:54.980
And so now we get a pop-up,
and it shows us that SKD graphic dialog

00:41:55.170 --> 00:41:56.640
and this object dialog is in here.

00:41:56.640 --> 00:41:59.100
All kinds of classes have this symbol.

00:41:59.100 --> 00:42:01.680
So we can go ahead and choose
the exact one that we want.

00:42:08.090 --> 00:42:15.230
And now we can see that this
is set on SKT Graphic dialog.

00:42:15.260 --> 00:42:18.000
And it's set-- since
we're running ZeroLink,

00:42:18.180 --> 00:42:22.200
it's actually set in the file,
sktgraphic.ob.

00:42:26.600 --> 00:42:29.170
And with that,
we hope that Breakpoint Actions are

00:42:29.180 --> 00:42:32.380
becoming an exciting new addition
to your debugging in Xcode 2.1.

00:42:32.380 --> 00:42:34.530
Back to you, Bill.

00:42:40.070 --> 00:42:41.960
Thank you, Chris.

00:42:41.970 --> 00:42:45.000
Yes,
so actually I'm only going to be here for

00:42:45.000 --> 00:42:47.910
a brief moment to introduce Chris Hansen,
who will discuss unit

00:42:47.940 --> 00:42:49.410
testing and demonstrate it.

00:42:49.440 --> 00:42:50.670
Thanks, Chris.

00:42:50.680 --> 00:42:52.190
Thank you, Bill.

00:42:57.590 --> 00:43:03.390
So Xcode 2.1 now includes
full support for unit testing.

00:43:03.590 --> 00:43:06.200
What does this actually mean, though?

00:43:06.270 --> 00:43:08.100
Well, I'm going to tell you.

00:43:08.150 --> 00:43:10.960
First of all, we're going to talk about
what unit testing is.

00:43:11.260 --> 00:43:13.360
We're going to talk a little bit
about why you should write unit tests.

00:43:13.360 --> 00:43:17.890
And we're going to talk about what
this support that I've been talking

00:43:17.890 --> 00:43:21.300
about all week actually means,
what it includes.

00:43:21.850 --> 00:43:25.040
So first of all, what is unit testing?

00:43:25.050 --> 00:43:28.560
Well, unit tests are small,
isolated tests of individual

00:43:28.560 --> 00:43:29.800
software components.

00:43:29.880 --> 00:43:30.540
They're very tiny.

00:43:30.550 --> 00:43:32.400
They test one thing.

00:43:32.470 --> 00:43:37.150
That means they can do one thing well,
and they're very easy to get right.

00:43:37.910 --> 00:43:41.840
Since they're so small,
they're also easy to make run fast.

00:43:41.850 --> 00:43:45.190
And since they run fast,
you'll run them regularly.

00:43:45.340 --> 00:43:48.550
You can run them as regularly
as every time you hit

00:43:48.560 --> 00:43:50.980
Command-B to build your project.

00:43:51.720 --> 00:43:55.110
and they provide sort of a
scaffolding for your code.

00:43:55.270 --> 00:43:58.110
So if you've ever seen
a building being built,

00:43:58.160 --> 00:44:01.740
the construction workers first
put sort of a skeleton around the

00:44:01.740 --> 00:44:02.910
structure that they're creating.

00:44:02.920 --> 00:44:06.080
The scaffolding lets them
work on the structure without

00:44:06.090 --> 00:44:08.240
disturbing the structure itself.

00:44:08.260 --> 00:44:10.450
And that's really what
your unit tests are.

00:44:10.460 --> 00:44:13.170
The difference is that
when you ship software,

00:44:13.170 --> 00:44:15.980
you don't have to tear
that scaffolding down.

00:44:16.380 --> 00:44:20.750
You can ship your application to
your users and keep your scaffolding

00:44:20.850 --> 00:44:24.050
on your development machine and
run it every time you make a

00:44:24.050 --> 00:44:26.770
tiny tweak to your application,
every time you add a new feature.

00:44:28.900 --> 00:44:30.800
So why should you write tests?

00:44:30.800 --> 00:44:33.450
Well,
the number one reason is to prevent bugs

00:44:33.570 --> 00:44:36.180
from creeping in and causing regressions.

00:44:36.190 --> 00:44:40.230
We've all had this happen,
and it really sucks.

00:44:40.240 --> 00:44:44.640
I mean, you know,
you change one thing over here,

00:44:44.790 --> 00:44:47.580
something over here doesn't like
it because suddenly you violated

00:44:47.580 --> 00:44:50.950
some expectation that that code had
when you wrote it two years ago that

00:44:51.020 --> 00:44:52.460
you've completely forgotten about.

00:44:52.460 --> 00:44:56.500
Unit tests help you
document those expectations.

00:44:56.890 --> 00:45:01.490
That also lets you much more
rapidly change your applications.

00:45:01.540 --> 00:45:07.610
Because all of your expectations
are documented in code that

00:45:07.610 --> 00:45:07.610
runs every time you build,

00:45:08.030 --> 00:45:11.620
You actually have sort of something--
you have an alternate memory.

00:45:11.810 --> 00:45:14.080
You have the computer acting
as your memory for you.

00:45:14.340 --> 00:45:19.730
So you can go through and make much
more far-reaching changes to your

00:45:20.190 --> 00:45:22.740
code base as you refactor it than
you otherwise might be able to.

00:45:23.610 --> 00:45:28.500
And by doing so,
they act as an executable specification.

00:45:28.620 --> 00:45:30.270
So this is great for prototyping.

00:45:30.270 --> 00:45:33.300
For example, if you're developing
frameworks like Apple has been,

00:45:33.300 --> 00:45:37.350
you can test out these new
APIs that you're creating,

00:45:37.350 --> 00:45:40.260
see how they feel,
get a feel for how they might react

00:45:40.270 --> 00:45:44.780
under different circumstances and how you
might use them before they even exist.

00:45:45.400 --> 00:45:48.910
And by doing this, you'd really be doing
test-driven development.

00:45:49.210 --> 00:45:52.580
You'd be creating your unit tests
that specify your software before

00:45:52.730 --> 00:45:56.800
even creating the software itself,
so you know when you're finished.

00:45:59.310 --> 00:46:02.960
So what does Xcode unit
testing actually consist of?

00:46:02.990 --> 00:46:06.120
Well, we've got testing frameworks
and tools included.

00:46:06.240 --> 00:46:10.020
For Objective-C and Cocoa,
we've included OCUnit from Cente.

00:46:10.140 --> 00:46:12.870
And for C++,
we've included a brand new framework

00:46:12.980 --> 00:46:16.220
that we created ourselves called C++Test.

00:46:16.330 --> 00:46:20.180
We include target templates for
creating what we call test bundles.

00:46:20.230 --> 00:46:23.880
And we'll talk a little bit more
about those in a couple minutes.

00:46:23.920 --> 00:46:26.400
We include file templates
for creating test cases for

00:46:26.400 --> 00:46:30.280
both OCUnit and for C++Test.

00:46:30.300 --> 00:46:35.680
And we have a shell script build phase in
our test bundle target template that runs

00:46:35.680 --> 00:46:39.750
your unit tests as part of your build.

00:46:39.820 --> 00:46:45.090
And all this really does is just invoke
a run unit tests script that's in

00:46:45.090 --> 00:46:50.870
developer tools that takes care of all
the heavy lifting of running your tests.

00:46:50.920 --> 00:46:54.940
You can look at the run unit test
man page to see how this all works.

00:46:55.120 --> 00:46:59.910
And if you want,
you can take a look at the script.

00:47:00.120 --> 00:47:03.860
Unit test errors are all
reported via the build results,

00:47:03.930 --> 00:47:05.820
just like your compile and link errors.

00:47:06.030 --> 00:47:09.800
So you make a syntax error in your code,
it gets reported via the build results.

00:47:09.920 --> 00:47:12.840
If you try and use something
that you're not linking against,

00:47:12.970 --> 00:47:14.600
it gets reported in the build results.

00:47:14.800 --> 00:47:19.060
And if you violate some of
your code's expectations,

00:47:19.100 --> 00:47:23.670
and it causes a unit test to fail,
that gets reported via the build results.

00:47:26.180 --> 00:47:27.760
So, test cases.

00:47:27.760 --> 00:47:29.600
We'll start bottom up.

00:47:29.600 --> 00:47:34.090
You build your unit tests as
classes called test cases that

00:47:34.280 --> 00:47:35.600
descend from a common base class.

00:47:35.600 --> 00:47:39.150
And your unit tests
themselves are implemented as

00:47:39.150 --> 00:47:41.390
methods in those test cases.

00:47:41.400 --> 00:47:46.180
The test case exists to set up and
tear down a common environment that we

00:47:46.290 --> 00:47:49.140
call a fixture around your unit tests.

00:47:49.280 --> 00:47:55.460
So, one fixture gets set up and torn down
around every invocation of a test method.

00:47:56.190 --> 00:47:57.560
In fact, it goes a little further.

00:47:57.560 --> 00:48:02.220
One instance of a test case
is also set up and torn down,

00:48:02.220 --> 00:48:05.360
allocated and deallocated,
around every set up and

00:48:05.630 --> 00:48:09.260
tear down of a fixture,
which is set up and torn down around

00:48:09.260 --> 00:48:11.970
every invocation of a test method.

00:48:11.980 --> 00:48:15.290
It's a little recursive,
but what that does is it serves

00:48:15.320 --> 00:48:19.170
to isolate your test code from
the testing framework's code.

00:48:19.180 --> 00:48:21.460
That means that if there's
a bug in your code,

00:48:21.460 --> 00:48:23.970
it doesn't affect the run
of the rest of your tests.

00:48:24.700 --> 00:48:26.810
And also,
if there's a bug in the test framework,

00:48:26.810 --> 00:48:29.260
it doesn't affect your tests as much.

00:48:29.260 --> 00:48:34.740
Test methods use assertion macros,
which we've provided a bunch of.

00:48:34.890 --> 00:48:37.750
There's a whole bunch in
OCUnit that are really great.

00:48:38.100 --> 00:48:43.060
Plus, we have one that serves as a
base for you for C++ tests.

00:48:43.180 --> 00:48:46.890
And these assertions just
verify the state of your code.

00:48:46.900 --> 00:48:49.460
You can verify that objects are equal.

00:48:49.460 --> 00:48:52.380
You can verify that
scalar values are equal.

00:48:52.380 --> 00:48:54.320
You can verify that variables are nil.

00:48:54.710 --> 00:48:58.190
And you can output
messages when they're not.

00:48:59.310 --> 00:49:06.750
Tests should be independent,
so they shouldn't rely on ordering.

00:49:06.800 --> 00:49:31.500
[Transcript missing]

00:49:33.120 --> 00:49:36.140
Test cases get grouped into
what we call test bundles.

00:49:36.140 --> 00:49:39.170
And this is sort of a new technique.

00:49:39.830 --> 00:49:43.320
There's sort of a traditional
way of testing applications where

00:49:43.320 --> 00:49:46.560
you create an application target,
then you create a clone of it,

00:49:46.820 --> 00:49:51.260
and you put your test cases in the clone
along with all of your application code.

00:49:51.280 --> 00:49:54.040
The problem is that you
have to keep these in sync.

00:49:54.140 --> 00:49:58.270
So by grouping your unit tests into
test bundles that are separate from

00:49:58.270 --> 00:50:02.680
your application or framework code,
you've isolated the code under test

00:50:02.680 --> 00:50:04.630
from the code that's testing it.

00:50:05.320 --> 00:50:09.360
This means that you don't have to worry
so much about synchronizing the two,

00:50:09.360 --> 00:50:12.650
you know, making sure that when you add a
resource to your application that

00:50:12.690 --> 00:50:16.140
you also add it to the version of the
application that includes the tests,

00:50:16.240 --> 00:50:16.750
and so on.

00:50:16.800 --> 00:50:20.610
It also makes it easy to test both
your debug and release builds because

00:50:20.610 --> 00:50:24.540
you can actually take your application
as deployed to your customers,

00:50:24.560 --> 00:50:26.870
build your unit test bundle,
pull it over,

00:50:26.900 --> 00:50:28.680
and then run the tests against it.

00:50:30.500 --> 00:50:35.330
Of course, your test bundle needs to link
against the code that it's testing.

00:50:35.660 --> 00:50:37.280
So for frameworks, this is really easy.

00:50:37.370 --> 00:50:40.500
You just link against the
framework and it picks it up.

00:50:40.500 --> 00:50:42.380
For applications,
this is a little bit more

00:50:42.770 --> 00:50:45.500
involved because you need to
specify the bundle loader.

00:50:45.500 --> 00:50:50.780
When you specify as a linker flag
the bundle loader for a bundle,

00:50:51.730 --> 00:50:57.550
What it'll do is it'll tell the bundle,
hey, if you have any unresolved

00:50:57.740 --> 00:51:00.130
symbols at link time,
check this executable to see

00:51:00.190 --> 00:51:01.760
if they're resolved there.

00:51:01.760 --> 00:51:04.350
And then when you're loaded
by whoever loads you,

00:51:04.630 --> 00:51:06.510
look for those symbols in your loader.

00:51:06.580 --> 00:51:10.770
This means that you don't actually
have to include all of your application

00:51:10.770 --> 00:51:12.640
classes in your test bundle.

00:51:12.660 --> 00:51:17.730
And we provide a target template
that does most of the work for you.

00:51:18.400 --> 00:51:21.590
It even includes a shell script
build phase that'll run your

00:51:21.590 --> 00:51:23.070
unit test as part of your build.

00:51:23.100 --> 00:51:27.620
The only thing it won't do is actually
link against the code under test.

00:51:27.680 --> 00:51:30.400
You need to do that yourself because,
you know,

00:51:30.400 --> 00:51:32.950
we don't know if you want to test
an application or a framework.

00:51:35.080 --> 00:51:36.540
So what do we do for Objective-C testing?

00:51:36.540 --> 00:51:39.800
Well, like I said, we provide OCUnit,
which is a very mature,

00:51:39.870 --> 00:51:41.590
robust framework for unit testing.

00:51:41.600 --> 00:51:43.650
It's really great.

00:51:43.700 --> 00:51:46.520
And it's very easy to get started with.

00:51:46.760 --> 00:51:51.680
We've even published an article
on ADC already about using OCUnit

00:51:51.680 --> 00:51:54.490
to test drive your development.

00:51:54.500 --> 00:51:57.500
It supports testing
applications and frameworks,

00:51:57.530 --> 00:52:00.380
and you can also test
other types of binaries.

00:52:00.380 --> 00:52:04.820
You just have to do a little bit more
work and use the OCUnit API directly.

00:52:05.200 --> 00:52:09.300
rather than rely on automatic
infrastructure to do it for you.

00:52:09.500 --> 00:52:12.820
Our run unit test script
knows how to run test bundles,

00:52:12.820 --> 00:52:16.610
the end and dot OC test,
as collections of OC unit tests.

00:52:16.670 --> 00:52:20.160
And since Objective-C is
just a superset of ANSI C,

00:52:20.530 --> 00:52:25.390
you can also test your C code
by writing tests using OC unit.

00:52:26.260 --> 00:52:30.950
For C++, we created our own unit
testing framework that's very,

00:52:30.960 --> 00:52:35.940
very lightweight and very
easy to use called C++ Test.

00:52:36.090 --> 00:52:39.180
It follows the standard
star unit testing pattern,

00:52:39.330 --> 00:52:42.640
and like I said, it's very,
very lightweight.

00:52:42.660 --> 00:52:46.380
It supports applications and frameworks.

00:52:46.990 --> 00:52:52.400
Just like OCUnit, the tests are run by
the runUnitTest script.

00:52:52.400 --> 00:52:54.120
The only difference is
that your test bundle,

00:52:54.290 --> 00:52:59.210
when using C++ test,
needs to end in the extension.cptest.

00:52:59.240 --> 00:53:02.790
There's a little bit of difference
in how the tests get run,

00:53:02.790 --> 00:53:05.780
and runUnitTest knows
how to take care of that.

00:53:07.130 --> 00:53:11.200
Since C++ is mostly a superset of C,
you can generally test C code too.

00:53:11.200 --> 00:53:15.630
And C++ test is not just built universal.

00:53:15.740 --> 00:53:18.780
It's actually built 64-bit too.

00:53:18.780 --> 00:53:21.470
So since you can't have
a 64-bit application,

00:53:21.620 --> 00:53:25.970
you can really only have 64-bit tools,
we can't actually run your unit test

00:53:25.980 --> 00:53:30.650
from the run unit test script when
you're building a 64-bit tool with tests.

00:53:31.030 --> 00:53:35.300
You generally will have to do the
clone to target and add tests to

00:53:35.360 --> 00:53:40.590
the clone technique to test 64-bit,
but you can test 64-bit.

00:53:40.970 --> 00:53:46.110
And since it's a C++ framework,
it requires you to use GCC4.

00:53:47.210 --> 00:53:49.550
But what are we doing for other
languages and other frameworks?

00:53:49.560 --> 00:53:54.080
Well, we provide a simple infrastructure
for you to develop and hook

00:53:54.080 --> 00:53:55.560
in your own test tools.

00:53:55.560 --> 00:53:58.910
We provide a test rig build setting
in the unit test group in the

00:53:59.030 --> 00:54:03.100
Xcode build settings that lets
you point to a custom tool to run.

00:54:03.170 --> 00:54:06.400
This tool just gets passed as
its first argument a path to the

00:54:06.600 --> 00:54:08.400
test bundle that you want to run.

00:54:08.440 --> 00:54:12.480
And all the details about the
environment that this runs in are

00:54:12.480 --> 00:54:14.850
in the man page for run unit tests.

00:54:15.780 --> 00:54:17.990
And like I said before,
you can actually take a look

00:54:18.060 --> 00:54:20.780
at the run unit test script,
too, to see how this all works.

00:54:20.780 --> 00:54:25.980
On error, all your test tool needs to
do is generate output in a

00:54:25.980 --> 00:54:28.510
GCC compiler-like format.

00:54:28.520 --> 00:54:32.890
So if your own test tool wants to
put a warning in the build log or

00:54:32.940 --> 00:54:36.500
wants to put an error in the build
log to indicate a test failure,

00:54:36.500 --> 00:54:39.840
all you have to do is just
emulate what GCC outputs.

00:54:39.840 --> 00:54:45.600
And let me show you how
it works over on demo 2.0.

00:54:45.780 --> 00:54:47.320
here.

00:54:50.000 --> 00:54:51.840
I've just got a very simple project.

00:54:51.840 --> 00:54:55.860
It's a simple framework with one class.

00:54:56.170 --> 00:54:58.510
Let me open this up here.

00:55:01.010 --> 00:55:02.250
And it's just an introducer.

00:55:02.420 --> 00:55:04.310
All it knows how to do is say hello.

00:55:04.470 --> 00:55:07.400
So what I'm going to do is that
first I'm going to add a unit test

00:55:07.560 --> 00:55:11.400
bundle target and show you how to
configure that for testing a framework.

00:55:11.400 --> 00:55:16.380
So I create a new, I create a, actually,
I'm just going to control click

00:55:16.500 --> 00:55:19.400
on this and add a new target.

00:55:19.720 --> 00:55:23.700
Under my new targets, under Cocoa,
I have a unit test bundle

00:55:23.700 --> 00:55:26.400
target that's new in Xcode 2.1.

00:55:26.400 --> 00:55:28.250
I'll just add that.

00:55:28.320 --> 00:55:30.400
I'll call it unit tests.

00:55:30.550 --> 00:55:32.340
And finish this here.

00:55:32.390 --> 00:55:38.120
And Xcode brings up my info panel,
which will let me set a dependency.

00:55:38.120 --> 00:55:40.370
So what I'm going to do most of
the time is I'm actually going

00:55:40.370 --> 00:55:41.900
to build my unit test target.

00:55:41.920 --> 00:55:44.260
I'm not going to build
my framework target.

00:55:44.260 --> 00:55:47.140
Instead,
I'm going to let my unit test target

00:55:47.490 --> 00:55:52.260
build my framework target for me.

00:55:52.360 --> 00:55:55.580
The only other thing that
I'll need to do here now

00:55:57.670 --> 00:56:03.360
is making sure that my unit test
target is selected and links

00:56:03.360 --> 00:56:06.900
against my framework product.

00:56:07.030 --> 00:56:11.420
So all I have to do is click the
target membership checkbox in here.

00:56:12.270 --> 00:56:19.200
And my unit test bundle is now linked
against my framework under test.

00:56:19.220 --> 00:56:21.500
So the next thing I'm going
to do is create a new file.

00:56:21.500 --> 00:56:26.320
I'm going to control click on my project
here and add a new file and add a new

00:56:26.320 --> 00:56:30.620
Cocoa Objective-C test case class.

00:56:31.760 --> 00:56:34.020
I'm going to add it to
my unit test target,

00:56:34.020 --> 00:56:36.910
and I'm going to just
name it unit test as well.

00:56:39.460 --> 00:56:44.840
I'll just delete the
extraneous header here.

00:56:44.840 --> 00:56:49.920
And we don't actually need to
put anything in our class here

00:56:49.920 --> 00:56:53.000
because C++ is a dynamic language.

00:56:53.000 --> 00:56:55.400
We don't actually need
to declare our methods.

00:56:55.400 --> 00:56:57.840
So let's save and quit that.

00:56:57.840 --> 00:57:00.000
Whoops.

00:57:00.420 --> 00:57:02.300
Get rid of the extraneous header.

00:57:02.370 --> 00:57:05.130
And I'm just going to
create a test method.

00:57:05.320 --> 00:57:07.300
These are methods that have no return.

00:57:07.440 --> 00:57:09.770
Begin with the word "test."

00:57:10.280 --> 00:57:11.310
And then just have a name.

00:57:11.510 --> 00:57:14.800
So I'm going to create a save,
say hello method.

00:57:14.810 --> 00:57:17.300
I'm going to create an introducer.

00:57:25.580 --> 00:57:30.450
Of course, once I'm done,
I'm going to release it.

00:57:30.450 --> 00:57:34.920
And now I'm just going to
assert that this introducer

00:57:34.920 --> 00:57:37.010
does what we expect it to.

00:57:42.160 --> 00:57:44.500
So I'm going to assert that two
objects are equal because I'm

00:57:44.500 --> 00:57:45.880
going to compare some strings.

00:57:46.070 --> 00:57:48.740
There are separate
comparisons for scalar values,

00:57:48.740 --> 00:57:51.910
which you can generally compare
using double equals in C,

00:57:51.910 --> 00:57:53.430
and object values,
which you really need to

00:57:53.500 --> 00:57:55.850
compare by sending as equal.

00:58:02.500 --> 00:58:05.480
Introducer, say hello.

00:58:05.480 --> 00:58:10.520
And I'm going to output a message
in case something goes wrong.

00:58:10.580 --> 00:58:12.880
When, if a unit test fails,
not only will it inform

00:58:12.880 --> 00:58:15.310
me what the failure was,
but it'll also print this message.

00:58:15.400 --> 00:58:17.240
And this message can
be any format string.

00:58:17.460 --> 00:58:23.610
You can have any number of
arguments because it takes

00:58:23.610 --> 00:58:25.980
advantage of the variable arguments
extension to GCC's macro system.

00:58:36.060 --> 00:58:37.600
So now I'm going to save this.

00:58:37.600 --> 00:58:41.780
I'm going to import introducer.h2
just to make sure that I don't

00:58:41.900 --> 00:58:43.000
get any compile errors here.

00:58:43.000 --> 00:58:45.960
Now I'm going to bring
up the build results,

00:58:45.960 --> 00:58:48.970
change my window size, and build.

00:58:49.050 --> 00:58:51.000
It's going to compile my framework first.

00:58:51.000 --> 00:58:54.360
Of course,
it's got to precompile everything.

00:58:55.070 --> 00:58:58.000
Now it's building my unit tests,
and it built and ran them.

00:58:58.220 --> 00:58:59.550
Well, it says build succeeded.

00:58:59.650 --> 00:59:02.330
It didn't provide any other output,
but let's see what's in

00:59:02.330 --> 00:59:03.890
the build transcript.

00:59:04.200 --> 00:59:11.200
[Transcript missing]

00:59:11.470 --> 00:59:16.900
that test case unit tests say hello,
tests say hello, passed.

00:59:18.120 --> 00:59:22.600
Now I'm going to add another
unit test for a change that

00:59:22.600 --> 00:59:23.810
I want to make for the framework.

00:59:23.850 --> 00:59:26.370
I'm actually going to add this
before I make the change because

00:59:26.370 --> 00:59:30.460
I'm going to let my test tell
me how to change the framework.

00:59:30.460 --> 00:59:32.420
So I'm just going to add another test.

00:59:32.420 --> 00:59:35.720
So test say hello to me.

00:59:36.870 --> 00:59:40.800
I'm going to add a little bit
of variability to my introducer.

00:59:40.800 --> 00:59:48.690
I can just copy and paste this,
or I can clone this out into a setup

00:59:48.960 --> 00:59:53.600
method and put it in a fixture.

00:59:53.600 --> 00:59:57.590
Of course,
I have to tear down that fixture.

01:00:05.930 --> 01:00:13.090
Of course, I need to put this variable
declaration in my header file.

01:00:13.110 --> 01:00:16.260
That means I can get rid
of some code in my tests.

01:00:22.150 --> 01:00:29.480
Of course,
I have to forward declare the class.

01:00:29.480 --> 01:00:33.680
And finally, I'm going to change say
hello to me to say hello,

01:00:33.680 --> 01:00:35.020
Chris.

01:00:35.020 --> 01:00:37.450
And I'm going to change the invocation.

01:00:40.200 --> 01:00:47.400
[Transcript missing]

01:00:47.800 --> 01:00:50.510
And you can see that my build,
even though it succeeded here,

01:00:50.510 --> 01:00:55.540
which means that it actually built all
the binaries that it was supposed to,

01:00:55.570 --> 01:00:56.940
it still got an error.

01:00:56.940 --> 01:00:59.170
And this is a unit test failure.

01:00:59.260 --> 01:01:01.900
It actually raised an exception.

01:01:03.000 --> 01:01:15.700
[Transcript missing]

01:01:25.210 --> 01:01:37.210
And of course I have to use
NSString string with format here.

01:01:37.380 --> 01:01:40.650
And of course I should also
declare the method to make sure

01:01:40.770 --> 01:01:42.820
that I don't get any warnings.

01:01:45.220 --> 01:01:48.560
So let's just put it above there.

01:01:48.570 --> 01:01:50.280
Now let's build.

01:01:50.890 --> 01:01:53.800
It just built my framework,
it built my unit tests,

01:01:53.800 --> 01:01:57.540
it ran my unit tests,
and if we bring up the build results,

01:01:57.540 --> 01:02:01.930
we can see now we just passed two
unit tests with zero failures.

01:02:03.690 --> 01:02:05.550
So that's test-driven development.

01:02:05.620 --> 01:02:09.230
What it lets me do now is actually
do a little bit of refactoring too.

01:02:09.240 --> 01:02:11.960
I've got a bit of duplication
in the introducer here.

01:02:11.960 --> 01:02:14.500
I've got something that says
hello to whatever I pass it,

01:02:14.530 --> 01:02:16.980
and then I've got another
thing saying hello world.

01:02:17.010 --> 01:02:19.910
Well, I can just make the
first call the second.

01:02:25.500 --> 01:02:29.340
And since I have these handy unit tests,
I can just build again

01:02:29.420 --> 01:02:30.720
by hitting Command B.

01:02:30.720 --> 01:02:36.260
And it just built my framework,
built my unit tests, ran my unit tests,

01:02:36.280 --> 01:02:37.330
and they all passed again.

01:02:37.340 --> 01:02:39.880
So I know I didn't break
anything by making that change.

01:02:43.540 --> 01:02:45.820
Let's go back to the slides.

01:02:45.820 --> 01:02:50.980
And now Bill is going to give
us some more information.

01:02:52.060 --> 01:02:56.290
It's really bright, so I need a shield.

01:02:56.400 --> 01:02:57.660
So yeah, more information.

01:02:57.660 --> 01:03:01.840
Documentation sample and other code,
the developer.apple.com site,

01:03:01.980 --> 01:03:04.900
WWDC section,
there's lots and lots of resources there.

01:03:04.900 --> 01:03:09.180
The documentation team,
they have been very, very busy people.

01:03:09.180 --> 01:03:11.350
There is lots and lots
of new documentation,

01:03:11.350 --> 01:03:14.320
not just reference materials,
but concept guides too.

01:03:14.320 --> 01:03:18.130
I mean, you saw this thing.

01:03:18.670 --> 01:03:21.640
You know,
there's going to be a lot of read the

01:03:21.640 --> 01:03:24.340
manual answers on the mailing lists.

01:03:27.830 --> 01:03:29.420
Now, other sessions.

01:03:29.430 --> 01:03:32.050
Well, the subversion control,
that would have been after this one,

01:03:32.130 --> 01:03:33.290
but then they moved this one.

01:03:33.410 --> 01:03:34.320
So, yeah, right.

01:03:34.320 --> 01:03:35.460
You missed that one.

01:03:35.610 --> 01:03:38.890
But there's Power User's Guide to
the Apple Developers Connection.

01:03:38.920 --> 01:03:40.500
Tremendous wealth of resources there.

01:03:40.590 --> 01:03:42.260
Go to this session to
learn how to use it.

01:03:42.770 --> 01:03:48.380
There's also
Project Management Mastery with Xcode.

01:03:48.380 --> 01:03:51.120
That's on Friday.

01:03:51.120 --> 01:03:51.950
Is it on Friday?

01:03:51.980 --> 01:03:53.200
Yeah, it's on Friday.

01:03:53.200 --> 01:03:57.660
So that's the real guts of the way that
Xcode projects are being developed.

01:03:57.700 --> 01:04:00.070
Projects are managed in
the way the builds work.

01:04:00.080 --> 01:04:02.780
And then there's a
Development Tools Feedback Forum.

01:04:02.780 --> 01:04:05.380
And in general,
if you want to provide feedback to us,

01:04:05.380 --> 01:04:07.020
bugreport.apple.com.

01:04:07.070 --> 01:04:09.450
And with that, who to contact?

01:04:09.450 --> 01:04:12.820
Matthew Formica, mformica at apple.com.

01:04:12.820 --> 01:04:16.600
He's our Developers
Tools and Cocoa Evangelist.
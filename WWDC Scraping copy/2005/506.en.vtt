WEBVTT

00:00:10.100 --> 00:00:14.150
Hi, my name is Chris Emura and I'm the
File System Engineering Manager within

00:00:14.150 --> 00:00:16.260
Apple's CoreOS organization.

00:00:16.410 --> 00:00:20.530
Today we'll be talking about what's
new with the File System for Tiger.

00:00:22.510 --> 00:00:27.190
Over the next 40 minutes or so,
we'll briefly cover the SMP KPI work,

00:00:27.320 --> 00:00:30.850
continue on with Extended Attributes,
Access Control Lists,

00:00:30.850 --> 00:00:36.220
File Notification Mechanisms,
and the Finder's very own Copy Engine.

00:00:36.460 --> 00:00:40.080
I carved out a little bit of time
for what I call "Oldies but Goodies."

00:00:40.080 --> 00:00:43.190
These are basically topics which may
not necessarily be new for Tiger,

00:00:43.370 --> 00:00:46.640
but are definitely worth
covering in some detail.

00:00:46.640 --> 00:00:49.050
And then finally,
the very 15 minutes or so,

00:00:49.050 --> 00:00:51.460
the very last 15 minutes,
we'll leave a good

00:00:51.460 --> 00:00:53.800
amount of time for Q&A.

00:00:56.630 --> 00:00:58.710
Quick word about the intended audience.

00:00:58.770 --> 00:01:02.410
The vast majority of today's
presentation content is targeted

00:01:02.460 --> 00:01:04.300
toward application developers.

00:01:04.370 --> 00:01:08.380
That said, those of you who are
File System or Kernel developers,

00:01:08.430 --> 00:01:10.390
as well as IT professionals,
will still get a lot

00:01:10.390 --> 00:01:11.550
out of the presentation.

00:01:11.690 --> 00:01:18.480
And I will be sure to highlight or
call out other labs and sessions

00:01:18.480 --> 00:01:18.480
more closely aligned to your needs.

00:01:20.710 --> 00:01:23.540
Okay,
let's just jump into the SMP KPI changes.

00:01:23.580 --> 00:01:25.680
I realize this wasn't hyped
up very much in the media,

00:01:25.800 --> 00:01:30.810
but this easily represents one of the
most significant changes in OS X history.

00:01:32.010 --> 00:01:35.660
The essence of the SMP KPI work
starts with two major benefits.

00:01:35.860 --> 00:01:39.900
The first is the capability for the
OS to scale as the hardware scales.

00:01:39.900 --> 00:01:43.050
Underscoring all of this was a
big change in the kernel where we

00:01:43.050 --> 00:01:46.850
moved away from two giant locks to
a much finer grained locking model.

00:01:46.860 --> 00:01:50.870
The benefits from any kind of SMP work
are typically expressed via performance

00:01:50.870 --> 00:01:54.190
as the number of CPUs goes up,
but there's also positive impact at

00:01:54.190 --> 00:01:58.070
the single processor level as well,
involving better concurrency.

00:01:58.940 --> 00:02:02.000
Some examples include the
ability to do concurrent stats,

00:02:02.000 --> 00:02:05.700
reads and writes to a single file,
as well as greatly improved lookups,

00:02:05.780 --> 00:02:07.120
much faster lookups.

00:02:07.120 --> 00:02:10.970
In general, as an application developer,
you get a lot of these performance and

00:02:10.970 --> 00:02:14.740
scalability benefits for free without
having to do anything to your code.

00:02:17.340 --> 00:02:19.700
The second benefit is
this sustainable KPI,

00:02:19.700 --> 00:02:23.420
or Kernel Programming Interface,
which isolates kernel developers

00:02:23.420 --> 00:02:25.340
from implementation details.

00:02:25.370 --> 00:02:28.830
As many of you already know,
binary compatibility and performance

00:02:28.830 --> 00:02:31.900
optimizations on our part are
very difficult when dependencies

00:02:31.900 --> 00:02:35.070
are made or built up around
accessing internal data structures,

00:02:35.200 --> 00:02:37.300
private variables,
and betting the farm on an

00:02:37.300 --> 00:02:39.000
implementation specific.

00:02:39.030 --> 00:02:42.590
The KPI prevents that,
or isolates you from those changes,

00:02:42.590 --> 00:02:45.900
and gives us binary
compatibility moving forward.

00:02:46.340 --> 00:02:48.740
For those of you who are kernel
or file system developers,

00:02:48.740 --> 00:02:53.190
I do want to call out the KPI feedback
at apple.com mailing alias.

00:02:53.240 --> 00:02:55.950
This is something that's been
active for some time now.

00:02:55.950 --> 00:02:58.780
And again,
you can use it to provide feedback,

00:02:58.790 --> 00:03:01.230
suggestions, start some dialogue.

00:03:01.470 --> 00:03:04.900
I also want to call out this
lab tomorrow at 3:30 PM.

00:03:05.000 --> 00:03:07.800
For those of you who are, again,
File System developers,

00:03:07.870 --> 00:03:09.240
this is dedicated for you.

00:03:09.280 --> 00:03:13.260
It's going to be at 3 o'clock tomorrow
in the Performance and Tools Lab,

00:03:13.260 --> 00:03:16.310
which is right behind, I believe,
this wall here.

00:03:18.690 --> 00:03:21.100
Before I move on,
and because I won't have a chance to

00:03:21.100 --> 00:03:24.680
broadcast this at the lab tomorrow,
I did want to call out two

00:03:24.680 --> 00:03:28.700
specifics involving future
plans in the SMP KPI area.

00:03:28.840 --> 00:03:31.630
Just to be clear, this slide,
or this particular slide here,

00:03:31.640 --> 00:03:35.160
is targeted toward the handful of
File System developers in the room today,

00:03:35.270 --> 00:03:37.990
and not you application developers.

00:03:38.560 --> 00:03:41.640
The first is that we do plan to
drop Funnel Support in Shibli,

00:03:41.640 --> 00:03:43.040
or Leopard.

00:03:43.080 --> 00:03:43.430
Is it Leopard?

00:03:43.560 --> 00:03:46.780
Yeah, Shibli, their next major release.

00:03:46.830 --> 00:03:48.760
This means that all of you will have
to protect your data structures on

00:03:48.760 --> 00:03:51.140
your own and not depend on the funnel.

00:03:51.470 --> 00:03:54.280
From our own experience at Apple,
and even at other companies which

00:03:54.280 --> 00:03:58.900
underwent a similar type of transition,
if this is new territory for you,

00:03:58.900 --> 00:04:02.600
you'll probably want to pay special
attention to the potential new races

00:04:02.610 --> 00:04:06.850
caused or created in the Rename,
Unlink, and Create paths.

00:04:07.750 --> 00:04:10.430
The second change here involves
the FNode cache semantic.

00:04:10.550 --> 00:04:14.940
This is a direct I/O of sorts for those
of you familiar with that paradigm.

00:04:15.010 --> 00:04:18.260
We do plan to expand this semantic
to the per file descriptor

00:04:18.270 --> 00:04:22.460
level as well as maintain the
more global per VNode semantic.

00:04:22.520 --> 00:04:28.880
Those of you who write File System will
just have to pay attention to the

00:04:28.880 --> 00:04:28.880
I/O flag when you read and write VNOPs.

00:04:33.730 --> 00:04:36.770
All right, let's move right along
to Extended Attributes,

00:04:36.850 --> 00:04:38.160
or EAs for short.

00:04:38.170 --> 00:04:40.980
EAs simply refer to arbitrary
bits of data which do not live

00:04:40.980 --> 00:04:43.280
in the actual file itself.

00:04:43.280 --> 00:04:46.110
As application developers,
I'm sure there's a ton of EA uses

00:04:46.460 --> 00:04:47.530
which we haven't even seen yet.

00:04:47.690 --> 00:04:51.580
But examples today include
things like a place to put hints,

00:04:51.670 --> 00:04:55.850
checksums, keywords, and so on,
especially in the cases where the file

00:04:55.850 --> 00:05:01.020
format you're working with makes no such
allowances for such additional content.

00:05:03.020 --> 00:05:04.160
Quick overview here.

00:05:04.160 --> 00:05:07.180
Extended Attributes or EAs are going
to be supported on all file systems

00:05:07.510 --> 00:05:09.700
and network file system protocols,
starting with Tiger.

00:05:09.700 --> 00:05:13.560
In cases where the file
system or network file system

00:05:13.560 --> 00:05:16.750
protocol supports EAs natively,
that's fantastic.

00:05:16.800 --> 00:05:18.140
We'll go ahead and use that method.

00:05:18.140 --> 00:05:21.610
In cases where the file system
does not support EAs natively,

00:05:21.610 --> 00:05:24.690
we will synthesize support at
the kernel VFS level and use

00:05:25.040 --> 00:05:27.420
Apple Double Files as the backing store.

00:05:27.420 --> 00:05:31.520
Apple Double Files are, of course,
those corresponding dot underbar files.

00:05:32.360 --> 00:05:36.750
We'll be using a very simple reverse
DNS naming convention for each EA tag.

00:05:36.770 --> 00:05:40.030
That's definitely not something
that's new as far as a convention

00:05:40.030 --> 00:05:41.430
for file naming and so on.

00:05:43.170 --> 00:05:46.450
I didn't want to call out
two current limitations.

00:05:46.460 --> 00:05:51.050
The first is an approximate
4K per EA size limitation.

00:05:51.090 --> 00:05:53.820
You should note that HFS is
definitely capable of completely

00:05:53.820 --> 00:05:55.240
removing this limitation.

00:05:55.240 --> 00:05:56.310
We just didn't get around to it.

00:05:56.340 --> 00:06:00.340
We'll definitely be able to
move this in the future without

00:06:00.460 --> 00:06:03.120
incurring a volume format change.

00:06:04.230 --> 00:06:07.680
The second limitation has to
do with the EA API itself.

00:06:07.680 --> 00:06:10.880
Currently,
it's very much a get-and-set type API,

00:06:10.910 --> 00:06:13.730
even though, again,
we have the implementation

00:06:14.330 --> 00:06:19.050
robustness to handle a much more
streams-oriented API or access workload.

00:06:22.580 --> 00:06:25.270
Before I jump into the actual
source code walkthrough,

00:06:25.270 --> 00:06:28.200
I wanted to give you a lay of
the land of sorts with regard to

00:06:28.200 --> 00:06:30.100
the various layers or frameworks.

00:06:30.160 --> 00:06:32.450
All of you are already
familiar with Carbon and Cocoa,

00:06:32.580 --> 00:06:36.050
but the vast majority of today's
presentation as far as the source

00:06:36.070 --> 00:06:39.320
code walkthrough will be taking
place at the BSD API level.

00:06:39.790 --> 00:06:45.940
The one exception will be
the Finder copy engine,

00:06:45.940 --> 00:06:46.110
which of course takes
place at the Carbon level.

00:06:48.080 --> 00:06:52.900
Okay, moving right into the ListXAdder
call as far as the EA API.

00:06:52.900 --> 00:06:56.120
ListXAdder, of course,
lists the EAs for a given file.

00:06:56.120 --> 00:06:59.830
And if you look at the sample code here,
the flow is actually pretty simple.

00:06:59.830 --> 00:07:02.360
We have the first call to
get the size of the list.

00:07:02.360 --> 00:07:04.400
We go ahead and then allocate a buffer.

00:07:04.400 --> 00:07:07.530
And then, of course,
the second call to get the list itself.

00:07:08.380 --> 00:07:12.090
This particular call is wrapped
in this LSX.C sample code.

00:07:12.090 --> 00:07:15.100
Incredibly simple,
incredibly distilled down,

00:07:15.100 --> 00:07:16.290
very easy to read.

00:07:16.290 --> 00:07:20.630
It's a command line utility of sorts
you can use to experiment with EAs.

00:07:23.420 --> 00:07:27.500
The Get Ex Adder call, of course,
gets a particular EA on a given file.

00:07:27.790 --> 00:07:30.280
Similar flow to the list call
in terms of the two passes,

00:07:30.280 --> 00:07:31.050
if you will.

00:07:31.170 --> 00:07:34.600
The first to get the size,
and the second to get the, in this case,

00:07:34.600 --> 00:07:35.780
the EA itself.

00:07:35.790 --> 00:07:38.950
This is going to be wrapped
in that same sample code.

00:07:42.530 --> 00:07:44.900
Moving on to the Set X Add or Call.

00:07:44.900 --> 00:07:47.120
This of course sets an
EA for a given file.

00:07:47.650 --> 00:07:51.260
This comes in its own wrapper as
far as this setx.c sample code.

00:07:51.260 --> 00:07:53.390
Again, very simple and distilled down.

00:07:53.400 --> 00:07:54.650
You can use to experiment with.

00:07:54.700 --> 00:07:56.810
I didn't want to call
out the last argument.

00:07:56.920 --> 00:07:58.150
And here it's zeroed out.

00:07:58.290 --> 00:08:00.310
But the last argument to
the Set X Add or Call,

00:08:00.310 --> 00:08:01.700
it's an options field.

00:08:01.700 --> 00:08:04.780
And for the Set Call,
you can actually specify setting an

00:08:04.780 --> 00:08:06.920
EA for a symlink or a symlink target.

00:08:06.920 --> 00:08:08.820
You're able to differentiate
between those two.

00:08:08.820 --> 00:08:12.250
And we've also provided a
replace semantic where you get

00:08:12.250 --> 00:08:16.470
an error if the EA already exists
and also a create semantic,

00:08:16.500 --> 00:08:19.510
which is very similar
to the open O create.

00:08:23.000 --> 00:08:26.050
The Remove X Adder call rounds
off the EA API family and of

00:08:26.050 --> 00:08:30.300
course simply removes an EA or
named EA from a given file.

00:08:30.300 --> 00:08:34.310
It's worth noting that all of
these calls have got an equivalent

00:08:34.400 --> 00:08:38.360
identical version that takes a
file descriptor instead of a path.

00:08:38.360 --> 00:08:42.120
And that option I mentioned
about differentiating between a

00:08:42.120 --> 00:08:45.340
symlink with a symlink target is
a common option for all of them.

00:08:45.400 --> 00:08:50.550
This Remove X Adder call here is
wrapped in its own rmx.c sample code.

00:08:50.580 --> 00:08:52.890
It's the same theme,
it's like a utility you can use to

00:08:52.970 --> 00:08:56.110
play around or experiment with EAs.

00:08:58.990 --> 00:09:02.080
Okay,
a quick few words about preservation.

00:09:02.190 --> 00:09:05.300
Preservation is something that
all of you need to be mindful,

00:09:05.300 --> 00:09:07.180
even if you do not use EAs directly.

00:09:07.180 --> 00:09:11.370
I typically worry most about those
of you who are doing your own copies,

00:09:11.410 --> 00:09:13.830
moves, archives, backups, or safe saves.

00:09:13.900 --> 00:09:16.410
By safe save,
I simply refer to a mechanism

00:09:16.820 --> 00:09:20.710
whereby prior to modifying a file,
you go ahead and make a complete copy,

00:09:20.710 --> 00:09:23.280
you work on the copy version,
close it off,

00:09:23.320 --> 00:09:27.880
and then do an atomic rename or
exchange data so that you get these

00:09:27.880 --> 00:09:29.880
all-or-nothing type semantics.

00:09:29.900 --> 00:09:32.390
But in general,
when it comes to preservation,

00:09:32.500 --> 00:09:36.340
we have an internal mantra we use that
always boils down to three things.

00:09:36.340 --> 00:09:38.540
The first, of course, is data.

00:09:38.540 --> 00:09:40.660
This is no surprise to anyone.

00:09:40.660 --> 00:09:43.450
Basically, what's in the file,
the data fork.

00:09:43.990 --> 00:09:45.680
For those of you who are
familiar with that paradigm.

00:09:45.680 --> 00:09:49.200
The second one involves EAs,
or attributes in general, and EAs,

00:09:49.200 --> 00:09:50.680
Extended Attributes.

00:09:50.680 --> 00:09:54.340
You should note that things like
the finder info and resource fork

00:09:54.430 --> 00:09:57.980
will show up in the EA namespace,
so you are able to use the

00:09:58.100 --> 00:09:59.960
EA API to preserve those.

00:09:59.960 --> 00:10:02.600
The third thing here is
the security information.

00:10:02.600 --> 00:10:05.540
In our context for today,
this is typically going to be the

00:10:05.540 --> 00:10:07.340
ACLs or the access control lists.

00:10:07.340 --> 00:10:10.720
I'll be talking about that in a
little bit more detail shortly.

00:10:10.720 --> 00:10:12.350
But again,
if you need to focus on these three

00:10:12.350 --> 00:10:13.860
things when it comes to preservation,
you need to be mindful of the EAs.

00:10:13.880 --> 00:10:16.650
preservation, you'll be in good shape.

00:10:18.240 --> 00:10:20.480
I wanted to bring up industry
fragmentation a little as far

00:10:20.480 --> 00:10:21.850
as it relates to preservation.

00:10:21.860 --> 00:10:25.080
And by industry fragmentation,
I just mean that if you look throughout

00:10:25.080 --> 00:10:28.960
the industry on various platforms,
and even versions within those platforms,

00:10:28.990 --> 00:10:32.000
EA support can be spotty, right,
as far as what's supported, what's not.

00:10:32.000 --> 00:10:34.270
On top of that,
you also have size limitations,

00:10:34.280 --> 00:10:37.250
which definitely are not
consistent throughout the industry,

00:10:37.330 --> 00:10:39.470
and sometimes have very
dubious error paths,

00:10:39.480 --> 00:10:41.580
if you will,
as far as losing things that kind

00:10:41.580 --> 00:10:43.220
of fall off or get truncated.

00:10:43.220 --> 00:10:45.560
So definitely something
to be aware of there.

00:11:06.730 --> 00:11:06.900
On the topic of industry fragmentation,
we have tried some things

00:11:06.900 --> 00:11:06.900
internally that have been
exported via things like the tar,

00:11:06.900 --> 00:11:06.900
the tar binary on our system,
where we do synthesize dot underbar

00:11:06.900 --> 00:11:06.900
files to help deal with some
of this industry fragmentation.

00:11:06.900 --> 00:11:06.900
But it's by no means a panacea or,
you know, a complete solution.

00:11:06.900 --> 00:11:06.900
So just something to be mindful about.

00:11:07.900 --> 00:11:10.840
Of course, tools, applications,
and utilities on our platform

00:11:10.840 --> 00:11:14.130
have been retrofitted or
modified to be EA-aware and,

00:11:14.170 --> 00:11:16.330
of course, preserve everything.

00:11:16.480 --> 00:11:19.660
This, of course, starts with the Finder,
as far as Finder file operations,

00:11:19.660 --> 00:11:21.590
copy and move, and so on.

00:11:21.950 --> 00:11:24.360
It goes all the way down
to the core commands,

00:11:24.360 --> 00:11:28.310
especially the big ones like CP, move,
tar, and rsync.

00:11:28.450 --> 00:11:30.320
I believe that's the first time
in history this has happened,

00:11:30.320 --> 00:11:31.600
so-- I mean, out of the box anyway.

00:11:31.600 --> 00:11:37.170
So a big round of applause for those
people that have done that work.

00:11:42.290 --> 00:11:45.730
On the topic of preservation,
I did want to call out two calls.

00:11:45.780 --> 00:11:48.710
The first one is this rename call
as far as semantics that we've

00:11:48.800 --> 00:11:50.180
worked hard to preserve here.

00:11:50.260 --> 00:11:54.600
Rename is typically used a lot in that
safe-save context I mentioned earlier.

00:11:54.730 --> 00:11:58.490
To demonstrate this semantic,
we start with two files, foo and bar,

00:11:58.640 --> 00:12:02.070
and both these files have been
initialized with the data in an

00:12:02.070 --> 00:12:05.940
EA that clearly reflects their
initial state or their origins.

00:12:06.180 --> 00:12:09.180
We go ahead and do a
rename of foo to bar.

00:12:09.410 --> 00:12:12.330
And you see that the rename semantic
is very much intact in terms of all

00:12:12.330 --> 00:12:14.280
that has really changed is the name.

00:12:14.280 --> 00:12:16.280
I mean, the file foo is now called bar.

00:12:16.280 --> 00:12:20.300
The data and the EI are exactly
where you'd expect them to be.

00:12:21.920 --> 00:12:25.150
The second call I wanted to
highlight here was Exchange Data as

00:12:25.150 --> 00:12:26.540
far as those semantics.

00:12:26.540 --> 00:12:29.450
And again, we start off with the
exact two same files,

00:12:29.450 --> 00:12:31.880
foo and bar,
same initial state with regard

00:12:31.880 --> 00:12:35.970
to the data in the EA that
clearly reflects their origins.

00:12:36.370 --> 00:12:39.520
We go ahead and do an
exchange data on Foo and Bar.

00:12:39.700 --> 00:12:43.760
And here you see that the exchange data
semantic has also been very much intact.

00:12:43.890 --> 00:12:45.960
As far as all that has
changed is the data fork,

00:12:45.960 --> 00:12:46.380
if you will.

00:12:46.380 --> 00:12:48.160
It's been swapped or exchanged.

00:12:48.170 --> 00:12:50.420
Everything else,
as far as the name and the EA,

00:12:50.420 --> 00:12:51.600
and the ACLs for that matter.

00:12:51.680 --> 00:12:55.120
But the ACLs just follow the
EA as far as the semantics go.

00:12:55.320 --> 00:12:57.690
The exchange data semantic
here has been preserved.

00:12:57.780 --> 00:13:00.320
I know this might take a little
while to get used to or digest,

00:13:00.320 --> 00:13:03.040
but you do have those utilities
to play around with this.

00:13:03.090 --> 00:13:06.590
And as long as they've been called out,
this is something that you can

00:13:06.600 --> 00:13:09.960
predigest in your own time,
I suppose.

00:13:11.590 --> 00:13:15.230
Okay, moving on to access control lists,
or ACLs for short.

00:13:15.260 --> 00:13:17.900
In a nutshell,
ACLs are a permissions model

00:13:17.920 --> 00:13:20.850
typically associated with,
but definitely not limited to,

00:13:20.890 --> 00:13:22.340
files and directories.

00:13:22.340 --> 00:13:25.500
As an application developer,
they give you much finer

00:13:25.500 --> 00:13:28.000
granularity around what you,
your application,

00:13:28.000 --> 00:13:29.980
and your users can and cannot access.

00:13:29.980 --> 00:13:32.990
They do help enable much
more effective collaboration,

00:13:32.990 --> 00:13:34.470
workflow, and sharing.

00:13:35.880 --> 00:13:38.480
Fortunately, the ACL paradigm is not
new to the industry,

00:13:38.500 --> 00:13:41.270
so you'll find a good use of,
or a good group of users and

00:13:41.270 --> 00:13:44.710
professionals that will be able to use
this functionality right out of the

00:13:44.820 --> 00:13:46.670
box without any kind of initial shock.

00:13:49.670 --> 00:13:51.460
Let's go over some quick
terminology that will be used

00:13:51.460 --> 00:13:54.820
throughout today's presentation,
actually even in some of the

00:13:54.910 --> 00:13:57.020
documentation and source.

00:13:57.240 --> 00:14:01.030
Access Control List or ACLs,
which are made up of

00:14:01.100 --> 00:14:03.980
Access Control Entries or ACES.

00:14:03.980 --> 00:14:09.130
The old school POSIX or UNIX UID,
User ID, and Group ID.

00:14:09.310 --> 00:14:12.740
You want to spend a little time
here as far as GUIDs and UUIDs.

00:14:12.770 --> 00:14:15.930
For the purposes of today's presentation,
as well as I've noticed

00:14:15.930 --> 00:14:18.540
in the header files,
documentation, source code,

00:14:18.540 --> 00:14:21.840
and things like that, in that context,
as far as ACLs is concerned,

00:14:21.840 --> 00:14:24.000
these two terms are used interchangeably.

00:14:24.040 --> 00:14:30.190
So don't get too hung up with that as
far as some of the swapping that goes on,

00:14:30.190 --> 00:14:30.190
especially in a few of the
header files I've seen.

00:14:30.690 --> 00:14:33.030
Of course,
we have the Windows Security ID,

00:14:33.140 --> 00:14:38.660
just the model used in the
Windows network and security protocols.

00:14:40.240 --> 00:14:42.180
Okay,
let's start off with where we are today,

00:14:42.180 --> 00:14:45.470
or where we were as far as the old
school historic Unix permissions model.

00:14:45.470 --> 00:14:48.340
The UID, GID, and this Mode T,
or these permission bits.

00:14:48.340 --> 00:14:49.590
Pretty straightforward.

00:14:49.590 --> 00:14:53.170
You've got, you know, read, write,
and execute bits for the owner, yourself,

00:14:53.170 --> 00:14:55.890
a group you belong to,
and then other or the rest of the world.

00:14:55.890 --> 00:14:57.760
Read, write, and execute there.

00:14:57.760 --> 00:15:02.280
You also have this sticky bit semantic,
which a lot of you are familiar

00:15:02.280 --> 00:15:05.800
with in terms of temp directories,
drop boxes, and such.

00:15:05.840 --> 00:15:09.860
You also have this set UID and set GID,
most commonly used for running

00:15:09.860 --> 00:15:11.760
executables as someone else.

00:15:11.760 --> 00:15:13.720
A bit of a no-no.

00:15:13.720 --> 00:15:18.520
Also have this 16 group limit,
this historic 16 group limit,

00:15:18.520 --> 00:15:23.290
and there are definitely no nested
groups or groups within groups.

00:15:24.090 --> 00:15:26.800
So you compare that with the
much finer granularity of ACLs,

00:15:26.810 --> 00:15:30.190
and here I've just enumerated
the permissions for a file and

00:15:30.360 --> 00:15:32.240
their directory counterparts.

00:15:32.510 --> 00:15:35.890
You should note that there's definitely
a allow or deny tag that's associated

00:15:35.890 --> 00:15:39.510
with each one of these permissions,
so the granularity is quite fine without

00:15:39.510 --> 00:15:41.600
being overly complex or complicated.

00:15:41.710 --> 00:15:44.500
If you look at any one of
these permissions here,

00:15:44.500 --> 00:15:49.020
there's nothing here that seems very
difficult to understand or grasp.

00:15:51.410 --> 00:15:53.020
Let's do a little overview here.

00:15:53.020 --> 00:15:56.880
ACLs, again, are made up of ACES,
or Access Control Entries.

00:15:56.880 --> 00:16:00.390
Here I've cut and pasted a little
bit from the retrofitted ls command,

00:16:00.560 --> 00:16:03.280
showing the ACL or the access
control list for the file foo.

00:16:03.780 --> 00:16:07.330
You'll see them enumerated
there as far as the seven ACES.

00:16:07.570 --> 00:16:09.410
If you look closely at this,
you'll see that we do

00:16:09.410 --> 00:16:11.880
support inheritance,
but by inheritance I want to call

00:16:11.880 --> 00:16:15.230
out the fact that we only support
static inheritance at this time.

00:16:15.350 --> 00:16:18.720
Static inheritance simply refers to
the fact that an object or a file

00:16:18.810 --> 00:16:23.050
or directory inherits its ACE from
its immediate parent at create time.

00:16:23.280 --> 00:16:25.840
Now you contrast that with what a lot
of you think about when you think about

00:16:25.920 --> 00:16:29.900
inheritance in general with regard to
you have a huge directory hierarchy,

00:16:29.970 --> 00:16:32.520
and you want to slap an ACE on
at the very top of the root and

00:16:32.520 --> 00:16:34.100
have it somehow trickle down.

00:16:34.100 --> 00:16:37.190
That can be done manually,
but as far as static inheritance, again,

00:16:37.250 --> 00:16:41.050
static inheritance is the case where
an object inherits its ACE from its

00:16:41.050 --> 00:16:44.170
immediate parent at create time.

00:16:44.510 --> 00:16:48.610
This last bullet here is my attempt
to give you a simple mental model for

00:16:48.610 --> 00:16:52.100
how the kauth or kernel authorization
subsystem makes its decisions,

00:16:52.190 --> 00:16:53.760
how the ACLs model kind of works.

00:16:53.760 --> 00:16:57.070
We always start with this tuple,
this identity, operation,

00:16:57.130 --> 00:16:58.260
and object tuple.

00:16:58.260 --> 00:17:00.690
The identity is basically
you or your GUID.

00:17:00.720 --> 00:17:03.260
The operation is what
you're trying to do,

00:17:03.260 --> 00:17:06.410
whether it be a read, write, delete,
and so on.

00:17:06.420 --> 00:17:09.840
And the object in this case,
in this context, is typically going to

00:17:09.840 --> 00:17:11.110
be a filer directory.

00:17:11.120 --> 00:17:12.840
So you start off with that tuple.

00:17:13.110 --> 00:17:17.520
We go ahead and scan the ACEs in order,
as far as you look at that list above,

00:17:17.600 --> 00:17:18.320
the one through seven.

00:17:18.340 --> 00:17:21.250
Scan those ACEs in order,
try to make a decision, and of course,

00:17:21.260 --> 00:17:24.130
along the way,
we go ahead and compare identities

00:17:24.260 --> 00:17:26.120
and resolve groups as needed.

00:17:26.210 --> 00:17:29.320
If after all of that we still cannot
make a decision or don't have enough

00:17:29.320 --> 00:17:32.970
information to make a decision,
we do fall back to the POSIX Mode T,

00:17:33.000 --> 00:17:35.090
or those old school Unix
permissions I mentioned earlier.

00:17:35.090 --> 00:17:39.220
So that in a nutshell is the
mental model as far as the

00:17:39.240 --> 00:17:41.970
ACLs decisions are concerned.

00:17:49.220 --> 00:17:53.130
Continuing on with the overview,
ACLs are enabled by default

00:17:53.130 --> 00:17:55.040
on the server product only.

00:17:55.070 --> 00:17:58.280
And I put only in quotes
here just because there is a

00:17:58.280 --> 00:18:02.340
FS ACL cuddle command that ships
on even the non-server version.

00:18:02.360 --> 00:18:03.910
I don't think it's currently documented.

00:18:03.990 --> 00:18:05.310
That'll probably change.

00:18:05.670 --> 00:18:06.440
But I have a slide.

00:18:06.440 --> 00:18:09.440
The next slide will show a quick
usage there so you can get started

00:18:09.440 --> 00:18:13.700
and start experimenting with
ACLs on your non-server version.

00:18:13.700 --> 00:18:19.000
The supported file systems and network
file system protocols include HFS,

00:18:19.000 --> 00:18:20.040
CIFS, and AFP.

00:18:20.040 --> 00:18:22.220
And note that because we
are so functionally close

00:18:22.220 --> 00:18:25.440
to the Windows ACLs model,
there's great potential with regard to

00:18:25.440 --> 00:18:28.110
the CIFS client and integration there.

00:18:28.420 --> 00:18:31.720
For those of you who are
IT professionals or just want to

00:18:31.730 --> 00:18:35.460
learn more about ACLs in general,
there's a very dedicated

00:18:35.540 --> 00:18:40.900
session tomorrow at 2:00,
session 617, so be sure to attend that.

00:18:43.440 --> 00:18:46.410
Here's that command
line blurb I mentioned.

00:18:46.490 --> 00:18:50.540
Here we go ahead and use the fsaclcuddle
command to enable ACLs on a volume,

00:18:50.580 --> 00:18:54.340
the dash p or dash path to
specify the mount point,

00:18:54.340 --> 00:18:55.750
dash e to enable.

00:18:55.810 --> 00:18:58.090
Although it might not
be in the documentation,

00:18:58.120 --> 00:19:02.260
if you do go ahead and enable ACLs
on your volume just to play around,

00:19:02.370 --> 00:19:05.360
you may want to then unmount
and mount that volume,

00:19:05.380 --> 00:19:10.060
or just reboot just to make sure there's
no caching effects in the upper layers.

00:19:10.060 --> 00:19:12.920
The change mod command here has
been retrofitted with this +a or -b,

00:19:12.920 --> 00:19:15.100
and it's been retrofitted
with the change mod command.

00:19:15.100 --> 00:19:19.100
So if you want to use the change mod
command to enable ACLs on your volume,

00:19:19.100 --> 00:19:19.100
you can do that.

00:19:20.100 --> 00:19:21.100
Here's that command
line blurb I mentioned.

00:19:21.100 --> 00:19:24.530
Here we go ahead and use the fsaclcuddle
command to enable ACLs on a volume,

00:19:24.530 --> 00:19:26.250
the dash p or dash path to
specify the mount point,

00:19:26.260 --> 00:19:27.070
dash e to enable.

00:19:27.120 --> 00:19:29.100
Although it might not
be in the documentation,

00:19:29.100 --> 00:19:31.950
if you do go ahead and enable ACLs
on your volume just to play around,

00:19:31.950 --> 00:19:34.270
you may want to then unmount
and mount that volume,

00:19:34.330 --> 00:19:37.070
or just reboot just to make sure there's
no caching effects in the upper layers.

00:19:37.140 --> 00:19:39.870
The change mod command here has
been retrofitted with this +a or -b,

00:19:39.960 --> 00:19:45.540
and it's been retrofitted higher
level GUI administrative tools.

00:19:49.420 --> 00:19:52.390
Let's go ahead and walk through
the Access Control List,

00:19:52.390 --> 00:19:55.140
or the ACL API,
the user-land version anyway.

00:19:55.160 --> 00:19:59.010
I wrote a very quick
ACL API fragment.c sample project.

00:19:59.130 --> 00:20:03.340
All this sample project does is
create a file foo in the current

00:20:03.420 --> 00:20:06.300
working directory with what
I consider read-only permissions.

00:20:06.410 --> 00:20:09.150
And I know that sounds
incredibly straightforward,

00:20:09.150 --> 00:20:13.000
but there is quite a bit of detail that
I want to walk through just because,

00:20:13.060 --> 00:20:16.220
again, the documentation has
been in a state of flux.

00:20:17.710 --> 00:20:20.990
First thing we do here is make the
path conf call to see if ACLs are

00:20:20.990 --> 00:20:24.840
even supported on the directory or
the file system we're working with.

00:20:25.040 --> 00:20:27.550
Pass in this extended
security non-portable flag.

00:20:27.580 --> 00:20:31.620
For those of you who work with
network file system clients,

00:20:31.620 --> 00:20:35.640
there's also a PC auth opaque
NP or non-portable flag you can

00:20:35.640 --> 00:20:40.720
pass in to see if authorization is
occurring locally or on the server.

00:20:40.720 --> 00:20:43.800
Again, that's probably more useful
for those of you who deal with

00:20:43.900 --> 00:20:45.580
network file system clients.

00:20:48.610 --> 00:20:51.680
We go ahead and get
our GUID from the UID.

00:20:51.680 --> 00:20:54.740
This is probably one of the most
frequently asked questions from

00:20:54.790 --> 00:20:58.510
the last WWDC as to how do I get
or how do I generate a UID.

00:20:58.790 --> 00:21:02.170
These MBR, these member functions,
are finally documented in Tiger,

00:21:02.180 --> 00:21:03.420
so take a look at those.

00:21:03.520 --> 00:21:05.100
There's some good
detail in the man pages.

00:21:05.100 --> 00:21:08.700
So we go ahead and generate our
UID and pass it on into this

00:21:08.700 --> 00:21:11.200
ACL read-only example function.

00:21:11.200 --> 00:21:13.340
This is the function that
does all of the heavy lifting.

00:21:13.530 --> 00:21:16.780
So let's go ahead and dive into that.

00:21:18.340 --> 00:21:21.490
ACL init, go ahead and initialize
our ACL structure.

00:21:21.490 --> 00:21:24.010
I'm not sure why I passed in 32 there.

00:21:24.010 --> 00:21:27.790
But basically 32 simply refers
to the number of aces or slots

00:21:27.790 --> 00:21:31.080
in that particular structure
or that particular ace.

00:21:31.090 --> 00:21:34.720
There's a corresponding ACL free
call that you should be using

00:21:34.720 --> 00:21:36.630
to clean up after yourself.

00:21:38.230 --> 00:21:42.150
Create Entry: Create an actual ACE.

00:21:42.190 --> 00:21:45.010
The actual call I wanted to highlight was
the non-portable version of this call.

00:21:45.100 --> 00:21:49.160
If you remember the mental
model I mentioned earlier where

00:21:49.200 --> 00:21:53.070
we process the ACEs in order,
you can see that order obviously matters

00:21:53.070 --> 00:21:55.100
for both deny and allow permissions.

00:21:55.100 --> 00:21:58.580
So this non-portable version of
the call does allow you to specify

00:21:58.680 --> 00:22:00.600
a position as a third argument.

00:22:00.710 --> 00:22:03.180
Definitely a useful feature.

00:22:06.120 --> 00:22:09.560
Allow or deny,
we go ahead and set allow in this case,

00:22:09.650 --> 00:22:14.200
and then go ahead and associate
our UUID with that particular ACE.

00:22:17.750 --> 00:22:20.360
The classic get, clear, add,
and set flow.

00:22:20.360 --> 00:22:23.410
This is basically where we just add
the read-only permissions that I've

00:22:23.440 --> 00:22:25.040
defined to that particular ACE.

00:22:25.040 --> 00:22:28.400
Those read-only permissions are
defined a lot earlier in the file.

00:22:28.400 --> 00:22:31.390
And here you'll note that there's
an interesting parallel with that

00:22:31.390 --> 00:22:34.800
preservation mantra I mentioned earlier,
where we fixate on three things,

00:22:34.940 --> 00:22:37.710
the data, the attributes,
and the security information.

00:22:37.710 --> 00:22:39.540
So that's a consistent theme there.

00:22:42.600 --> 00:22:43.770
Finally,
get to see the light at the end of

00:22:43.770 --> 00:22:47.470
the tunnel with regard to associating
with the actual creation of the file.

00:22:47.630 --> 00:22:49.830
Here we use this extended
non-portable open,

00:22:49.870 --> 00:22:51.660
the openx_np.

00:22:52.140 --> 00:22:55.430
There's a whole class of calls
like this as far as being extended

00:22:55.430 --> 00:22:59.840
and non-portable that take a file
sec t as an additional argument.

00:22:59.890 --> 00:23:03.310
That file security object
is what houses our ACL,

00:23:03.420 --> 00:23:04.950
and it's what we pass in.

00:23:05.270 --> 00:23:07.710
So basically here,
if the open call succeeds,

00:23:07.730 --> 00:23:12.640
you'll be left with a file foo with those
read-only permissions I defined earlier.

00:23:15.620 --> 00:23:18.570
Okay, moving on to file notification.

00:23:18.650 --> 00:23:22.300
As application developers,
it doesn't take much imagination to see

00:23:22.300 --> 00:23:28.600
how important file or directory chain
notification can be for your deployments.

00:23:28.600 --> 00:23:30.970
And again,
although it's not new for Tiger,

00:23:30.990 --> 00:23:34.410
I didn't want to call out KQs
as being the de facto standard

00:23:34.410 --> 00:23:36.970
for userland file notification.

00:23:37.430 --> 00:23:40.440
Those of you who have seen KQs or have
used it on other platforms realize that

00:23:40.470 --> 00:23:44.200
it's far more efficient than disjoint
implementations of SELECT and PULL.

00:23:44.200 --> 00:23:46.540
It's great for directory
update notification.

00:23:46.540 --> 00:23:51.190
In fact, our very own Finder uses KQs,
and it's very evident when you

00:23:51.190 --> 00:23:54.100
look at highly visible active
windows like the desktop,

00:23:54.100 --> 00:23:54.920
for example.

00:23:55.000 --> 00:23:58.320
You go ahead and create some files
in a terminal or an SSH session

00:23:58.320 --> 00:24:02.140
and see them appear instantly and
very efficiently in the desktop.

00:24:20.690 --> 00:24:20.690
That said,
there still are some current limitations.

00:24:20.690 --> 00:24:20.690
The first is that KQs aren't currently
supported in all volume formats,

00:24:20.690 --> 00:24:20.690
although if you've been
following the industry,

00:24:20.690 --> 00:24:20.690
you do realize that there is
precedent to uplift KQ support

00:24:20.690 --> 00:24:20.690
into the kernel VFS layer such
that all file systems can benefit.

00:24:21.230 --> 00:24:24.930
Local only here refers to the
single client or single server

00:24:24.930 --> 00:24:29.090
multiple client type configuration
where an update caused by another

00:24:29.090 --> 00:24:30.800
client may not show up on yours.

00:24:30.800 --> 00:24:33.630
No payload actually means
a lot of different things,

00:24:33.650 --> 00:24:38.040
but here I just want to call out one case
where when you do register for an event,

00:24:38.140 --> 00:24:41.620
you don't get any hint or payload
that tells you what has changed.

00:24:41.670 --> 00:24:44.780
So, in the case where you register
against a particular directory and

00:24:44.780 --> 00:24:48.120
you're just waiting for events there,
you'll get an event that tells you

00:24:48.190 --> 00:24:51.110
that the directory has changed,
but you won't have a payload or hint

00:24:51.190 --> 00:24:55.970
to let you know what file or directory
within that directory has changed.

00:24:56.270 --> 00:25:00.660
Finally, there is what I refer to as the
Recursive Directory Hierarchy Challenge.

00:25:00.700 --> 00:25:04.350
This is the case where you as a developer
want to monitor an entire directory

00:25:04.350 --> 00:25:08.180
hierarchy and then be notified whenever
anything in that hierarchy changes.

00:25:08.290 --> 00:25:11.440
Of course, with a single KQ registered
against the root immediately

00:25:11.540 --> 00:25:14.770
underneath that particular parent,
a change that happens much lower

00:25:14.770 --> 00:25:16.740
in the hierarchy will go unnoticed.

00:25:18.240 --> 00:25:22.170
Because it is a de facto standard
for user land file notification,

00:25:22.170 --> 00:25:25.020
we did provide some
really simple sample code.

00:25:25.020 --> 00:25:27.440
Again,
this is another completely standalone

00:25:27.440 --> 00:25:30.740
command line utility that can be
run against a file or directory

00:25:30.740 --> 00:25:33.200
and then prints the standard out
whenever something has happened.

00:25:34.710 --> 00:25:39.110
We start by allocating a KQ structure
here and then go ahead and use the EV set

00:25:39.110 --> 00:25:40.860
macro to initialize that data structure.

00:25:40.860 --> 00:25:43.380
I did want to call out
the OEventOnly flag,

00:25:43.380 --> 00:25:46.180
which for some reason
isn't highlighted here,

00:25:46.180 --> 00:25:48.560
that flag over there in the open call.

00:25:49.070 --> 00:25:51.510
A very useful flag to use,
especially for those of you who

00:25:51.510 --> 00:25:54.160
have always been hit by the I cannot
eject the volume cleanly type

00:25:54.490 --> 00:25:56.900
scenario where you try to eject
or unmount a volume and you get a

00:25:56.900 --> 00:25:58.860
message telling you that it's in use.

00:25:59.560 --> 00:26:02.750
This particular flag here is useful
in that case where your reference

00:26:02.750 --> 00:26:04.120
will not prevent the volume.

00:26:04.160 --> 00:26:06.610
from being unmounted cleanly.

00:26:09.800 --> 00:26:32.400
[Transcript missing]

00:26:33.600 --> 00:26:35.500
As I mentioned earlier
in the ACLs portion,

00:26:35.500 --> 00:26:38.820
the KAUTH subsystem is a general
framework or kernel framework for

00:26:38.850 --> 00:26:40.500
authorization decision making.

00:26:40.500 --> 00:26:42.150
I really want to highlight
the second point.

00:26:42.200 --> 00:26:47.000
It was not initially designed for
file or directory notification.

00:26:47.250 --> 00:26:49.300
That said,
if you look at how cleanly it's been

00:26:49.300 --> 00:26:54.130
architected as far as we finally have a
case where the redundant authorization

00:26:54.130 --> 00:26:57.510
code has been uplifted and stripped
out of the individual file systems

00:26:57.530 --> 00:27:01.020
and then centralized so everything
effectively goes through the subsystem.

00:27:01.020 --> 00:27:03.430
So you take a look at that
particular architecture,

00:27:03.430 --> 00:27:05.450
that design,
and you combine that with the

00:27:05.580 --> 00:27:08.720
fact that we do allow third-party
developers to write keks or plug-ins,

00:27:08.720 --> 00:27:13.910
and it becomes very tempting to use
this as a file notification mechanism.

00:27:15.220 --> 00:27:17.430
Should you go down this path,
the basic design involves the

00:27:17.430 --> 00:27:19.880
registration of authorization
events you're interested in,

00:27:20.030 --> 00:27:23.020
that's your scopes,
and a pretty simple voting mechanism.

00:27:23.020 --> 00:27:26.930
Actually, the main takeaway from this
slide here is that your plugin or

00:27:27.000 --> 00:27:31.120
your text is permitted to block,
and this is shorthand for it's very easy

00:27:31.120 --> 00:27:33.190
for you to bring the entire system down.

00:27:33.200 --> 00:27:35.290
So definitely be aware of that.

00:27:35.360 --> 00:27:39.400
You want to take care if you're in a
commonly called authorization path.

00:27:39.500 --> 00:27:41.970
It's the hot paths I mentioned there,
basically something that's getting

00:27:42.030 --> 00:27:43.100
called over and over again.

00:27:43.580 --> 00:27:46.860
And you want to be extra paranoid if
your text calls outside of itself,

00:27:46.970 --> 00:27:49.940
because you definitely increase
your chances for deadlock there.

00:27:49.940 --> 00:27:52.630
For those of you who really want
to do this kernel programming,

00:27:52.630 --> 00:27:56.000
go down this particular path,
we do have two documents,

00:27:56.000 --> 00:27:58.090
or two reference bits
of reference material.

00:27:58.150 --> 00:28:01.170
I believe the first one,
I think they're both on the DTS website,

00:28:01.220 --> 00:28:02.830
you can do a search for kauth.

00:28:02.840 --> 00:28:05.280
There's some documentation
as far as a white paper,

00:28:05.280 --> 00:28:09.370
and then there's also this sample text
you can use to get started and experiment

00:28:09.820 --> 00:28:12.470
a little bit with the kauth subsystem.

00:28:16.430 --> 00:28:19.740
Okay, let's go ahead and move up
the stack a level into the

00:28:19.830 --> 00:28:21.780
Carbon File Manager domain.

00:28:21.780 --> 00:28:25.390
If you remember all of those steps
you had to take to preserve data,

00:28:25.390 --> 00:28:28.060
EAs, and ACLs,
and it's a little bit too hairy for you,

00:28:28.060 --> 00:28:31.560
you can save yourself a lot of
trouble and finally use the same

00:28:31.560 --> 00:28:34.190
copy engine the Finder does.

00:28:39.050 --> 00:28:40.920
When you get a chance,
take a look at this FS file

00:28:41.000 --> 00:28:43.190
operation sample project,
which again is a basic,

00:28:43.220 --> 00:28:46.240
simple command line wrapper that
demonstrates this functionality.

00:28:46.240 --> 00:28:49.100
I've just called out the async
version of this copy call,

00:28:49.140 --> 00:28:52.380
but keep in mind that there's
also a move variant and a simpler

00:28:52.380 --> 00:28:54.450
synchronous version of both calls.

00:28:54.460 --> 00:28:58.860
This API supports both the
POSIX paths as well as FS refs.

00:28:59.020 --> 00:29:02.930
It supports a limited form pre-flight
and is integrated with the CF run loop.

00:29:02.980 --> 00:29:06.520
So again, just go ahead and check out
the FS file operation sample

00:29:06.520 --> 00:29:08.360
project there to get started.

00:29:12.400 --> 00:29:14.620
Okay,
oldies but goodies are winding down here.

00:29:14.650 --> 00:29:18.480
These are basically issues again that
may not necessarily be new for Tiger,

00:29:18.480 --> 00:29:20.360
but are definitely worth
covering in more detail,

00:29:20.360 --> 00:29:25.960
especially since documentation can
sometimes be scant or non-existent.

00:29:27.680 --> 00:29:31.720
The first thing I wanted to call
out was this UID or this User ID 99.

00:29:31.740 --> 00:29:34.580
This is actually,
this starts with the Ignore Ownership

00:29:34.580 --> 00:29:38.330
on this volume checkbox that
you'll see on the finder's Get Info

00:29:38.340 --> 00:29:40.760
panel for any non-network volume.

00:29:40.780 --> 00:29:43.820
That setting is the default for
drives which were not present

00:29:43.820 --> 00:29:45.600
at first boot after an install.

00:29:45.600 --> 00:29:50.480
If you're not sure,
you can go ahead and take a look at

00:29:50.480 --> 00:29:54.280
the var db volinfo.database to see
if your drive is actually in there.

00:29:54.720 --> 00:29:58.440
This corresponds to this mount ignore
ownership bit in the mount T structure.

00:29:58.490 --> 00:30:01.700
You can programmatically check
for this by calling statfs

00:30:01.880 --> 00:30:05.400
and look at the F flags field,
I believe.

00:30:05.430 --> 00:30:08.820
The mount HFS,
the lower level mount HFS mount command

00:30:08.860 --> 00:30:11.100
itself does take a -u and -g option.

00:30:11.120 --> 00:30:13.500
We can provide a user and/or group.

00:30:13.540 --> 00:30:16.280
And that capability definitely
adds a wrinkle with regard

00:30:16.280 --> 00:30:17.600
to expected semantics.

00:30:17.600 --> 00:30:20.480
So what I wanted to do was
walk through some of the

00:30:20.560 --> 00:30:22.790
possible configurations there.

00:30:23.470 --> 00:30:25.640
This is the default case where
you're basically doing nothing.

00:30:25.640 --> 00:30:30.160
You're not setting any bit or setting
any flag in the finder get info panel,

00:30:30.160 --> 00:30:32.350
and you're certainly not
passing anything in as far as

00:30:32.430 --> 00:30:33.920
the mount command is concerned.

00:30:33.920 --> 00:30:36.070
There you get pretty
much what you'd expect.

00:30:36.140 --> 00:30:39.200
The UIDs and GIDs are preserved,
meaning that what you read

00:30:39.200 --> 00:30:41.780
is what's actually on disk,
and what's written is

00:30:41.780 --> 00:30:43.280
pretty much who you are.

00:30:57.110 --> 00:30:57.120
They raise this wildcard, this UID 99,
as far as preexisting files

00:30:57.120 --> 00:30:57.120
and directories with this UID.

00:30:57.120 --> 00:30:57.120
Those will be considered owned by the
current user for authorization purposes,

00:30:57.120 --> 00:30:57.120
so you'll have free
reign over those files.

00:30:57.120 --> 00:30:57.120
Again, this is the default case.

00:30:58.230 --> 00:31:01.100
For volumes mounted with
that Mount Ignorant Bit set,

00:31:01.100 --> 00:31:03.430
where you basically go in the Finder
window and you check that bit,

00:31:03.460 --> 00:31:06.920
but you still haven't passed anything
in with regard to the Mount HFS command,

00:31:06.920 --> 00:31:11.260
here your UID reported will be 99,
regardless of what's on disk.

00:31:11.260 --> 00:31:14.960
And what's written will be 99,
regardless of what your UID is.

00:31:14.960 --> 00:31:16.580
Items will be considered owned.

00:31:16.580 --> 00:31:19.270
Files and directories will be
considered owned by the current

00:31:19.270 --> 00:31:20.980
user for authorization purposes.

00:31:20.980 --> 00:31:23.950
Basically means you have free
reign over that particular volume.

00:31:25.230 --> 00:31:25.800
So far, so good.

00:31:25.800 --> 00:31:29.640
Here's where things get a little bit more
tricky as far as volumes mounted with

00:31:29.640 --> 00:31:31.400
that Mount Ignorant Ownership Bit set.

00:31:31.450 --> 00:31:34.770
And you're also passing in an
explicit owner at mount time

00:31:34.800 --> 00:31:36.580
via that Mount HFS command.

00:31:37.460 --> 00:31:40.830
There, the UID and GID reported will
be whatever you passed in.

00:31:40.830 --> 00:31:44.560
What's written will still be 99,
and files and directories will be

00:31:44.560 --> 00:31:48.460
considered owned by the provided
owner for authorization purposes.

00:31:51.540 --> 00:31:54.130
And then rounding off as
far as the fourth case,

00:31:54.130 --> 00:31:56.680
in the case where mounting
ownership bit is not set,

00:31:56.720 --> 00:32:00.560
but you are passing in an
explicit user group at mount time.

00:32:00.560 --> 00:32:04.320
This is actually kind of similar to
the first default case where UIDs and

00:32:04.320 --> 00:32:07.490
GIDs are preserved for the most part,
meaning that what you read is

00:32:07.540 --> 00:32:10.460
what's on disk and what you
write is pretty much who you are.

00:32:10.460 --> 00:32:13.110
The difference here is
that items with the UID 99,

00:32:13.110 --> 00:32:16.650
as far as files and directories on
disk with pre-existing UIDs of 99,

00:32:16.650 --> 00:32:20.770
will be considered owned by the provided
user for authorization purposes.

00:32:24.600 --> 00:32:27.370
Okay,
moving on to some miscellaneous topics.

00:32:27.380 --> 00:32:30.060
The F-Sync one especially.

00:32:30.060 --> 00:32:32.740
This has definitely got a lot of
mileage on the external boards.

00:32:32.740 --> 00:32:35.320
The first,
this F-Sync one involves widespread

00:32:35.360 --> 00:32:39.470
public misconceptions around F-Sync on
OS X not working correctly or resulting

00:32:39.600 --> 00:32:41.980
in some kind of data loss or corruption.

00:32:41.980 --> 00:32:44.060
Nothing could be further from the truth.

00:32:44.060 --> 00:32:48.130
F-Sync on OS X and just about every other
Unix platform has always flushed data

00:32:48.130 --> 00:32:52.160
from the host or from the system down
to the drive on which the file resides.

00:32:52.220 --> 00:32:55.440
The critical detail to be
aware of here is that while the

00:32:55.440 --> 00:32:58.340
data has made it to the drive,
it may be in the drive cache

00:32:58.340 --> 00:33:01.540
and not the actual platters,
what we consider stable storage.

00:33:01.540 --> 00:33:05.670
To complicate matters much further,
the drive or the storage subsystem

00:33:05.670 --> 00:33:09.240
may also reorder the writes such
that any given writes in say A,

00:33:09.240 --> 00:33:12.820
B, C order followed by an F-Sync
and then more writes in D,

00:33:12.820 --> 00:33:15.890
E, F order followed by a
fault or a power outage,

00:33:15.950 --> 00:33:16.700
crash, whatever.

00:33:16.700 --> 00:33:20.270
You may see cases where, you know,
writes A and D have made it

00:33:20.270 --> 00:33:22.040
to disk but B and C have not.

00:33:22.220 --> 00:33:25.980
This behavior is clearly unacceptable
for a whole bunch of users as

00:33:25.980 --> 00:33:29.530
far as the general file system,
databases or any applications

00:33:29.530 --> 00:33:32.770
that require this unstable
storage semantic and,

00:33:32.820 --> 00:33:34.700
you know, no write reordering.

00:33:34.720 --> 00:33:40.590
So we've introduced this F-Sync F-control
to ask the drive to flush its cache.

00:33:40.780 --> 00:33:43.000
Of course,
history continues to demonstrate that

00:33:43.000 --> 00:33:46.700
there are certain drives or storage
solutions which Apple does not qualify

00:33:46.860 --> 00:33:51.700
that basically ignore this command anyway
and you're left with the same problem.

00:33:51.890 --> 00:33:54.070
Of course,
history continues to demonstrate that

00:33:54.100 --> 00:33:57.870
there are certain drives or storage
solutions which Apple does not qualify

00:33:57.870 --> 00:34:02.680
that basically ignore this command anyway
and you're left with the same problem.

00:34:13.190 --> 00:34:15.550
HFSx or Case Sensitive HFS.

00:34:15.600 --> 00:34:19.290
This last point here is something you
kind of mentioned in the feedback forum

00:34:19.290 --> 00:34:21.440
as far as case insensitive environments.

00:34:21.440 --> 00:34:24.070
As application developers,
my plea to you here,

00:34:24.070 --> 00:34:26.360
or the takeaway I want
you to focus on here is,

00:34:26.460 --> 00:34:28.770
you know,
please test your applications on

00:34:28.770 --> 00:34:31.100
these case sensitive environments.

00:34:31.100 --> 00:34:36.410
We've had incidents both internally and
externally that have resulted in breakage

00:34:36.500 --> 00:34:38.890
just because an application developer,
for whatever reason,

00:34:38.890 --> 00:34:41.100
was hard coding these
lookups in their code.

00:34:41.100 --> 00:34:44.330
And they got away with it for
a long time as far as running

00:34:44.330 --> 00:34:46.100
on case insensitive HFS.

00:34:46.100 --> 00:34:50.540
But again, if you can just test all your
applications in your environment,

00:34:50.620 --> 00:34:53.130
make sure there's at least one
matrix configuration for this

00:34:53.200 --> 00:34:58.720
case insensitive configuration.

00:35:01.140 --> 00:35:01.990
Okay, tools.

00:35:02.010 --> 00:35:04.480
Tools to help you debug
file system issues.

00:35:04.520 --> 00:35:05.900
The first one is FS Usage.

00:35:05.900 --> 00:35:06.980
Pretty straightforward.

00:35:06.980 --> 00:35:08.420
This is actually a pretty simple command.

00:35:08.420 --> 00:35:11.090
Pretty powerful, too,
in terms of dumping out all file

00:35:11.090 --> 00:35:14.330
system activity on your given
platform or on your given system.

00:35:14.340 --> 00:35:18.340
I personally use the "-w option a lot
to get a much wider printout of the path

00:35:18.340 --> 00:35:20.700
and just more information in general.

00:35:20.700 --> 00:35:24.310
There's also this dyld image
suffix variable you can use.

00:35:24.310 --> 00:35:28.270
You can set it to default and just get
the Carbon File Manager calls in line

00:35:28.270 --> 00:35:30.580
in context with regard to the output.

00:35:31.180 --> 00:35:35.010
The man page has got all that detail,
so be sure to reference that.

00:35:35.560 --> 00:35:39.290
The Sample Call or the Sample Utility
is definitely not file system specific,

00:35:39.290 --> 00:35:41.990
but we use this quite a bit
internally to help debug cases

00:35:42.000 --> 00:35:45.500
where the system is hung,
at least user-land-wise it's hung.

00:35:45.500 --> 00:35:47.790
You get the spinning beach
ball of death and so on.

00:35:47.890 --> 00:35:56.170
The Sample Utility can be pointed against
a particular process and you'll get

00:35:56.170 --> 00:35:56.170
a number of stack traces to give you
a hint as to where things are stuck.

00:35:56.890 --> 00:35:59.800
LSOF List of Open Files.

00:35:59.800 --> 00:36:01.500
This is definitely not specific to OS X.

00:36:01.500 --> 00:36:03.940
It's imported on a
number of Unix platforms.

00:36:03.940 --> 00:36:07.470
This is most useful in cases where
you're trying to debug a situation.

00:36:07.470 --> 00:36:10.320
You've got a lingering reference
on a volume that cannot be

00:36:10.320 --> 00:36:12.040
cleanly ejected or unmounted.

00:36:12.080 --> 00:36:15.480
LSOF is great for dumping that
out as far as being run as root.

00:36:16.120 --> 00:36:18.150
One thing you want to
be aware of in Tiger,

00:36:18.150 --> 00:36:20.520
which is nice,
is the fact that LSOF has been

00:36:20.580 --> 00:36:22.520
enhanced to print out MMAP references.

00:36:22.540 --> 00:36:25.830
That's definitely a welcome
change and will help you catch

00:36:25.830 --> 00:36:29.040
those type of references as well,
which previously went

00:36:29.060 --> 00:36:30.600
unnoticed on Panther.

00:36:32.350 --> 00:36:37.000
KTrace, basic syscall level tracing,
very similar to PAR on

00:36:37.000 --> 00:36:38.620
iRix or Trust on Solaris.

00:36:38.620 --> 00:36:41.500
Basically gives you the syscall,
a little bit of payload

00:36:41.500 --> 00:36:43.060
information and return value.

00:36:43.060 --> 00:36:46.180
It can give you a feel for
where things are going wrong.

00:36:46.180 --> 00:36:49.020
And then finally you've got
general profiling tools like Shark.

00:36:49.020 --> 00:36:52.360
I like Shark just because it does
cross the user land kernel boundary.

00:36:52.360 --> 00:36:55.810
It gives you a little bit more holistic
view of what's going on with your app.

00:36:55.830 --> 00:36:59.770
It's also quite good at digesting
huge amounts of data and showing

00:36:59.770 --> 00:37:02.000
them in nice condensed GUI form.

00:37:02.030 --> 00:37:03.960
So you can kind of pinpoint areas
you want to drill down on and

00:37:03.960 --> 00:37:05.200
figure out what's going wrong.

00:37:08.740 --> 00:37:13.100
I'm just going to do a quick demo
here to demonstrate those command

00:37:13.100 --> 00:37:16.340
line utilities I mentioned earlier
and also kind of hit home with the

00:37:16.440 --> 00:37:19.240
preservation mantra I mentioned earlier.

00:37:19.240 --> 00:37:22.070
I'll go ahead and switch to the demo.

00:37:22.800 --> 00:37:27.900
[Transcript missing]

00:37:32.140 --> 00:37:35.600
So this is a representation of
what you have on your DVDs or on

00:37:35.660 --> 00:37:40.400
the DTS website as far as those
utilities I mentioned earlier.

00:37:40.410 --> 00:37:42.460
They have been Xcodified if you
want to go ahead and use that,

00:37:42.570 --> 00:37:46.240
but I'm just going to
quickly do a make here.

00:37:57.300 --> 00:38:05.600
[Transcript missing]

00:38:06.930 --> 00:38:08.780
So, you know,
I'm just going to create a file here,

00:38:08.780 --> 00:38:16.240
touch A as far as, and then do a set X,
what should we call it, com.apple.

00:38:22.600 --> 00:38:25.170
Set an EA for this particular file.

00:38:25.220 --> 00:38:28.690
Pretty simple semantics there,
simple usage there.

00:38:28.750 --> 00:38:30.750
List those extended attributes there.

00:38:30.760 --> 00:38:34.880
You can remove them as well, I guess.

00:38:34.880 --> 00:38:34.880
Remove X.

00:38:41.480 --> 00:38:43.370
So we removed it there,
unless nothing's there.

00:38:43.450 --> 00:38:46.000
Let's go ahead and set
it again real fast.

00:38:46.020 --> 00:38:48.240
Wanted to quickly show that
if you look at things like

00:38:48.310 --> 00:38:51.520
the copy command-- actually,
the only way we should do is actually set

00:38:51.520 --> 00:38:53.560
an ace for this particular file as well.

00:38:53.750 --> 00:39:00.530
So change mode, plus a-- actually,
who am I?

00:39:10.970 --> 00:39:13.430
Let's go ahead and just add an
A quickly to that file there.

00:39:13.480 --> 00:39:20.020
Change mode, plus A, it's local,
allow read, something really simple.

00:39:20.020 --> 00:39:23.600
Of course that ls-le again
on A will show it there.

00:39:23.600 --> 00:39:32.470
So now we have a file A with both
an ACL and some extended attributes.

00:39:32.470 --> 00:39:32.780
Just to show that the copy
command does work as advertised.

00:39:33.220 --> 00:39:35.440
Oh, you know what we should do
is actually use the preserve.

00:39:35.440 --> 00:39:36.630
I forget about this all the time.

00:39:36.630 --> 00:39:39.000
This is the default for the finder,
but not for the copy command.

00:39:39.000 --> 00:39:45.480
It's just preserve,
or preserve permissions and stuff.

00:39:45.480 --> 00:39:45.480
A.copy.

00:39:48.480 --> 00:39:55.310
So just make sure that the actual
EAs are preserved as well as the...

00:39:58.630 --> 00:40:01.170
More interesting thing for a
lot of you is the Finder info,

00:40:01.170 --> 00:40:03.310
or the Finder making sure that
it does the same thing here.

00:40:03.310 --> 00:40:06.580
As far as the A,
I'm going to go ahead and select that.

00:40:06.580 --> 00:40:11.590
Do a duplicate as far as the Finder copy.

00:40:22.400 --> 00:40:22.410
That's kind of difficult to read there,
but if we do an LSX of A star,

00:40:22.410 --> 00:40:22.420
you'll see that the A space
copy is also preserved.

00:40:22.420 --> 00:40:22.640
That's the byproduct of
the Finder copy there.

00:40:22.640 --> 00:40:27.360
Just to show you guys what I said earlier
about the Finder info and resource forks

00:40:27.360 --> 00:40:29.350
also showing up in the EA namespace.

00:40:29.420 --> 00:40:31.430
I'll go ahead and start with that file A.

00:40:31.430 --> 00:40:32.600
I'll go ahead and create an alias.

00:40:32.640 --> 00:40:34.640
We'll get a resource
fork loaded up there.

00:40:34.990 --> 00:40:37.840
Also, that's the easiest way to do this.

00:40:37.840 --> 00:40:41.620
We get info,
kind of tag that file with a color,

00:40:41.620 --> 00:40:43.640
which will get some Finder
info information in there.

00:40:43.640 --> 00:40:44.580
It's red now.

00:40:44.580 --> 00:40:50.300
Again, if we do a LSX of A star here,
you will see that that file A,

00:40:50.400 --> 00:40:55.640
as far as that little flag I added,
that color flag, got a Finder info entry.

00:40:55.640 --> 00:40:58.940
Then the alias itself, of course,
lives in the resource fork.

00:40:59.030 --> 00:41:00.640
All of that stuff is preserved.

00:41:00.840 --> 00:41:06.730
If you do a copy, So, cp minus p.

00:41:09.200 --> 00:41:10.670
- Another copy.

00:41:10.670 --> 00:41:15.890
You'll see that that's preserved
as well as far as even that flag,

00:41:16.030 --> 00:41:19.010
that red flag I added there earlier.

00:41:19.100 --> 00:41:23.790
Also show that the ACLs
have been preserved as well.

00:41:41.620 --> 00:41:41.620
So you see here that the ACEs
for those particular files and

00:41:41.620 --> 00:41:41.620
their copies are all preserved.

00:41:41.620 --> 00:41:41.620
That's pretty much it as far
as just showing you how these

00:41:41.620 --> 00:41:41.620
utilities basically work.

00:41:41.620 --> 00:41:41.620
You can play around with this
and experiment with scalability,

00:41:41.620 --> 00:41:41.620
performance, and all those things.

00:41:41.620 --> 00:41:41.630
Pretty straightforward stuff.

00:41:41.630 --> 00:41:41.630
Right?

00:41:51.180 --> 00:41:52.660
All right.

00:41:52.660 --> 00:41:56.010
I think we're about done.

00:41:56.070 --> 00:41:59.360
We're not quite done yet.

00:41:59.360 --> 00:42:02.710
It's more information really quickly.

00:42:02.710 --> 00:42:02.710
Go to this WWDC site here.

00:42:02.710 --> 00:42:02.710
Again, do a search on this particular
session or the kauth if you

00:42:02.710 --> 00:42:02.710
wanted to dive into that a bit.

00:42:03.040 --> 00:42:05.250
Those two related sessions
I mentioned earlier,

00:42:05.250 --> 00:42:08.580
the ACL session tomorrow at 2:00,
and then right after that in

00:42:08.700 --> 00:42:12.100
the Performance and Tools Lab,
the session or the lab targeted

00:42:12.100 --> 00:42:13.730
towards FOSTER developers.

00:42:13.820 --> 00:42:20.260
But if anyone, feel free to attend and
interact with my group.

00:42:20.370 --> 00:42:22.670
Some contact information.
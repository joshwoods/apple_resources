WEBVTT

00:00:04.120 --> 00:00:05.540
Good morning.

00:00:05.540 --> 00:00:10.060
Welcome to the introduction
to the Shake SDK session.

00:00:10.060 --> 00:00:14.150
My name is Angus Taggart,
and I'm an engineer with the Shake team.

00:00:14.370 --> 00:00:20.540
I do some development and I also
do a lot of work with the SDK.

00:00:20.920 --> 00:00:23.650
Our objectives for this morning
are really to provide you with

00:00:23.650 --> 00:00:28.200
a general introduction to Shake,
what it does, our customer base,

00:00:28.200 --> 00:00:30.430
you know, who's using Shake,
some of the people who

00:00:30.460 --> 00:00:32.650
developed for Shake,
and then I'm going to spend some time

00:00:32.650 --> 00:00:35.350
talking about Shake's architecture,
some important concepts.

00:00:35.440 --> 00:00:40.570
And we want to take a high-level
overview of Shake's architecture,

00:00:40.570 --> 00:00:45.800
and then we're going to move into
some of the code building blocks.

00:00:46.640 --> 00:00:48.490
And Shake is a very complex application.

00:00:48.490 --> 00:00:53.750
It's a very sophisticated piece of
software that solves a lot of very

00:00:54.120 --> 00:00:56.180
interesting problems for our customer.

00:00:56.180 --> 00:00:57.790
Hang on, for our customers.

00:00:57.790 --> 00:01:00.240
So let me just get started.

00:01:00.240 --> 00:01:01.380
Let's introduce Shake.

00:01:01.380 --> 00:01:03.020
First of all,
I want to see a show of hands.

00:01:03.020 --> 00:01:06.380
How many people here are familiar with
the Shake product and what it does?

00:01:07.930 --> 00:01:08.800
Okay, fantastic.

00:01:08.800 --> 00:01:09.300
That's great.

00:01:09.300 --> 00:01:11.140
I was expecting to see only a couple.

00:01:11.140 --> 00:01:14.310
So we're going to do a
quick intro to Shake.

00:01:14.420 --> 00:01:16.250
We're going to talk
about the customer base,

00:01:16.400 --> 00:01:19.830
third-party developer community,
and the SDK package, just to get started.

00:01:19.840 --> 00:01:23.190
First of all,
as it sounds like most of you know,

00:01:23.190 --> 00:01:27.200
Shake is Apple's high-end
digital compositing and visual

00:01:27.200 --> 00:01:29.490
effects software solution.

00:01:29.500 --> 00:01:32.170
New in Shake 4,
an exciting new feature is

00:01:32.170 --> 00:01:36.140
the ability to do digital
compositing in a 3D environment.

00:01:36.850 --> 00:01:41.750
A lot of our customers are more and more
working or implementing workflows that

00:01:41.750 --> 00:01:46.630
require 3D solutions for compositing,
and Shake 4 has a very exciting

00:01:46.630 --> 00:01:48.520
new capability to support that.

00:01:48.570 --> 00:01:52.870
It's got a lot of underlying
capabilities to do image processing,

00:01:52.870 --> 00:01:53.640
effects.

00:01:53.640 --> 00:01:56.430
It's just a very powerful application.

00:01:56.460 --> 00:02:01.370
One of the things I'd like to do really
quickly is introduce the kinds of

00:02:01.490 --> 00:02:04.640
problems that our customers are solving.

00:02:05.810 --> 00:02:09.120
We're fortunate enough to get
an effects build-up clip from

00:02:09.120 --> 00:02:10.990
our friends at Weta Digital.

00:02:11.000 --> 00:02:13.470
They're based in New Zealand,
and they did, obviously,

00:02:13.490 --> 00:02:14.840
all the Lord of the Rings work.

00:02:14.940 --> 00:02:18.520
In this shot, what you'll see is they
take the original footage,

00:02:18.590 --> 00:02:22.740
and then they do a huge amount
to it to create the final shot.

00:02:22.760 --> 00:02:25.140
They paint in shadows using mattes.

00:02:25.140 --> 00:02:26.760
They do color correction.

00:02:26.760 --> 00:02:29.760
Now they need to put in a
background so that they create

00:02:29.760 --> 00:02:31.510
a matte for the background.

00:02:31.520 --> 00:02:34.730
At this point, we're going to start
introducing 3D digital elements.

00:02:34.740 --> 00:02:37.740
We're going to have horses,
which are 3D digital elements.

00:02:37.910 --> 00:02:41.740
There's a big dragon that swoops
in that's a 3D digital element.

00:02:41.800 --> 00:02:43.740
This is really the core
of what Shake does.

00:02:43.740 --> 00:02:49.820
It takes a number of different sources of
imagery from live footage to CG elements,

00:02:49.820 --> 00:02:53.810
and it combines them all to
create a seamless final image,

00:02:53.840 --> 00:02:54.740
what you see on the scene.

00:02:54.740 --> 00:02:56.800
That's the core of what Shake does.

00:02:56.800 --> 00:02:59.790
It's a very powerful product.

00:03:00.700 --> 00:03:07.220
One of the things I wanted to go
over is the Shake customer base.

00:03:07.220 --> 00:03:10.100
As plug-in developers,
you have to make an economic decision.

00:03:10.100 --> 00:03:12.600
You're going to put in so much
work to build your plug-ins,

00:03:12.600 --> 00:03:14.600
and you want to know,
who am I selling to?

00:03:14.600 --> 00:03:16.000
How big is the customer base?

00:03:16.000 --> 00:03:19.710
First and foremost,
Shake is entrenched at the

00:03:19.770 --> 00:03:22.410
high-end film visual FX market.

00:03:22.510 --> 00:03:27.180
I've listed, basically,
in the United States, in Europe,

00:03:27.230 --> 00:03:31.630
and also in the South Pacific,
Shake is used by the top-tier

00:03:31.630 --> 00:03:33.200
high-end visual FX companies.

00:03:33.200 --> 00:03:35.840
It would be surprising if
you went to see one of the

00:03:35.840 --> 00:03:39.500
blockbuster movies this summer,
and it would be very surprising if

00:03:39.540 --> 00:03:43.950
Shake hadn't been used to help produce
some of the visual FX for those movies,

00:03:43.990 --> 00:03:45.480
Batman Begins, that sort of thing.

00:03:46.010 --> 00:03:51.120
It's becoming a required courseware
at a number of film schools.

00:03:51.290 --> 00:03:54.880
I think a very exciting story for Shake,
and this is something that's

00:03:54.880 --> 00:03:58.600
really happened over the last two
or three years as Shake has been

00:03:58.600 --> 00:04:04.070
brought into the Apple family,
is that with the port to OS X and

00:04:04.070 --> 00:04:07.810
very aggressive pricing and marketing,
we're seeing a rapid adoption of

00:04:07.810 --> 00:04:11.080
Shake in what you would consider
to be the broadcast video market.

00:04:11.110 --> 00:04:15.900
That is a very large customer base.

00:04:15.900 --> 00:04:19.680
It's a very large customer base that
certainly as a plug-in developer

00:04:19.700 --> 00:04:23.790
would mean your return on your
investment would be greatly enhanced.

00:04:23.800 --> 00:04:28.910
Since Shake has been around for, I guess,
since the late '90s, mid-late '90s,

00:04:28.910 --> 00:04:34.000
we actually have a fairly established
third-party developer community in place,

00:04:34.000 --> 00:04:40.410
and we're very fortunate to have support
from some of the top motion graphics

00:04:40.420 --> 00:04:45.780
plug-in developers in the world.

00:04:45.810 --> 00:04:46.110
We're very fortunate to have support
from some of the top motion graphics

00:04:46.110 --> 00:04:46.380
plug-in developers in the world.

00:04:46.420 --> 00:04:47.110
We're very fortunate to have support
from some of the top motion graphics

00:04:47.110 --> 00:04:47.580
plug-in developers in the world.

00:04:47.600 --> 00:04:47.600
And the reason that we have this kind
of support is that Shake is being used

00:04:47.600 --> 00:04:47.600
in some of the most exciting projects,
post-production work going on now,

00:04:47.600 --> 00:04:47.600
and so people naturally choose
Shake as a way to get their

00:04:47.600 --> 00:04:47.600
technology out to high-end users.

00:04:47.610 --> 00:04:52.720
And the reason that we have this kind
of support is that Shake is being used

00:04:52.990 --> 00:04:58.460
in some of the most exciting projects,
post-production work going on now,

00:04:58.470 --> 00:05:02.550
and so people naturally choose
Shake as a way to get their

00:05:02.550 --> 00:05:05.500
technology out to high-end users.

00:05:06.390 --> 00:05:11.220
Okay, one of the things that it's really
worthwhile doing is spending a bit of

00:05:11.320 --> 00:05:13.640
time talking about Shake's architecture.

00:05:13.640 --> 00:05:20.980
One of the great advantages of Shake is
that the SDK exposes the same internals,

00:05:20.980 --> 00:05:24.030
basically the same base classes
that the internal development

00:05:24.040 --> 00:05:25.380
engineering team uses.

00:05:25.380 --> 00:05:28.670
And so as an SDK developer,
you're going to be able to get

00:05:28.670 --> 00:05:30.780
very deep into the application.

00:05:30.780 --> 00:05:35.370
You're going to be able to very tightly
merge your technology in with Shake,

00:05:35.380 --> 00:05:36.270
and that's very exciting.

00:05:36.300 --> 00:05:38.400
But to do that,
you need a conceptual base.

00:05:38.470 --> 00:05:42.280
You need to be able to sit there and go,
okay, I understand what I'm looking at.

00:05:42.280 --> 00:05:44.300
I understand why Shake's doing that.

00:05:44.350 --> 00:05:48.440
And so that's why I like to spend
a little bit of time talking about

00:05:48.440 --> 00:05:53.800
Shake's architecture and just reviewing
some of the key things that Shake does.

00:05:53.840 --> 00:05:56.960
So there's essentially three main
points we're going to look at.

00:05:56.960 --> 00:05:58.920
We're going to look at dependency graph.

00:05:59.000 --> 00:06:01.580
Shake is a dependency
graph-based application.

00:06:01.580 --> 00:06:03.680
The rendering engine,
we're going to look at how

00:06:03.680 --> 00:06:06.280
the rendering engine works,
at least at a high level.

00:06:06.300 --> 00:06:08.800
And we're also going to
look at the workspace.

00:06:08.800 --> 00:06:11.900
You know, everything exists inside
of a 2D coordinate system,

00:06:11.900 --> 00:06:15.570
but we want to know a little bit
more about how Shake tracks things

00:06:15.570 --> 00:06:18.100
inside of that 2D coordinate system.

00:06:18.320 --> 00:06:22.290
So first of all, I guess I'll ask,
how many people here have worked on an

00:06:22.550 --> 00:06:27.410
application or developed an application
that has a dependency graph architecture?

00:06:28.150 --> 00:06:29.530
Okay, so there's a couple of you.

00:06:29.690 --> 00:06:32.270
Good,
I'm glad I've got these slides then.

00:06:32.310 --> 00:06:35.670
So first and foremost,
let's just take a look.

00:06:35.670 --> 00:06:38.920
If you open up Shake and you start
putting together a composition,

00:06:38.920 --> 00:06:42.740
one of the things that you'll see
is a very simple processing tree.

00:06:42.760 --> 00:06:46.920
So we've got some input image data,
we've got a color wheel,

00:06:46.920 --> 00:06:50.070
we've got an input file,
and you'll see that the

00:06:50.070 --> 00:06:53.090
image data flows down,
and that as it flows down,

00:06:53.090 --> 00:06:55.690
it goes through what we call nodes.

00:06:55.690 --> 00:07:00.130
And the two key conceptual
underpinnings of a dependency

00:07:00.130 --> 00:07:01.930
graph are nodes and plugs.

00:07:02.060 --> 00:07:07.130
A node is essentially an entity
where data processing occurs.

00:07:07.290 --> 00:07:10.580
So it's within nodes that
actual computation occurs.

00:07:10.590 --> 00:07:13.050
If you've got an image
processing algorithm,

00:07:13.050 --> 00:07:16.240
you're going to be implementing
it inside of a node.

00:07:16.240 --> 00:07:19.680
Now, plugs are the entity within Shake.

00:07:19.680 --> 00:07:22.990
They're basically containers for data,
and they allow the movement of

00:07:22.990 --> 00:07:25.560
data through the dependency graph.

00:07:25.560 --> 00:07:29.370
So if we take a quick look
at that image in Shake,

00:07:29.390 --> 00:07:32.400
what you'll see--let me see
if my laser pointer skills.

00:07:32.400 --> 00:07:35.570
So what you'll see is we've
got some image data that's

00:07:35.720 --> 00:07:39.650
flowing down through the tree,
but essentially that data is

00:07:39.650 --> 00:07:44.800
transferred in and out of nodes
through entities called plugs.

00:07:44.800 --> 00:07:49.090
So if we take a look at--in the right,
I've got a very simple blown-up diagram,

00:07:49.090 --> 00:07:51.960
and what it does is it basically
shows you a couple of input plugs

00:07:52.090 --> 00:07:54.060
where data moves into the node.

00:07:54.060 --> 00:07:55.660
The node then processes that data.

00:07:55.750 --> 00:07:59.280
Once it's done processing the data,
it sort of places the answer or

00:07:59.280 --> 00:08:04.560
whatever value or values that
it's computed in an output plug.

00:08:04.570 --> 00:08:10.930
So that's the basis,
the basics of a dependency graph.

00:08:10.980 --> 00:08:12.240
Let's talk a little bit about nodes.

00:08:12.240 --> 00:08:16.370
So nodes are connected via plugs.

00:08:16.370 --> 00:08:18.660
That's the way we move data.

00:08:18.660 --> 00:08:20.990
Key things--plugs must be
of the same data types.

00:08:21.050 --> 00:08:23.560
So if you've got a floating point value,
if you want to connect

00:08:23.560 --> 00:08:26.220
it to another plug,
that other plug has to be

00:08:26.300 --> 00:08:28.120
a floating point value.

00:08:28.120 --> 00:08:31.570
And the--one of the key efficiencies
in a dependency graph is you

00:08:31.570 --> 00:08:35.510
might have 30 plugs all connected,
but they all share a reference

00:08:35.510 --> 00:08:36.980
to a single data item.

00:08:36.980 --> 00:08:41.370
So that's something that makes the
dependency graph very efficient.

00:08:41.380 --> 00:08:46.660
There's not duplication of data
and also the state of the data.

00:08:46.660 --> 00:08:49.890
Basically,
all the plugs will inherit or all

00:08:49.900 --> 00:08:53.060
the connected plugs will inherit
the same state of the data.

00:08:53.060 --> 00:08:58.570
Another key concept with nodes is
the fact that they're hierarchical.

00:08:58.700 --> 00:09:03.910
And this is very important because you
can imagine that Shake actually has a lot

00:09:03.910 --> 00:09:09.250
of very simple data processing nodes that
do things like maybe a bytes conversion,

00:09:09.250 --> 00:09:11.470
you know, from 8-bit to 16-bit.

00:09:11.470 --> 00:09:15.360
You can imagine that there's nodes
in Shake that do things like,

00:09:15.360 --> 00:09:17.870
you know, crop data, all kinds of things.

00:09:17.950 --> 00:09:20.700
Well, you want to be able to
reuse that functionality.

00:09:20.700 --> 00:09:22.390
You don't want to have to rewrite it.

00:09:22.520 --> 00:09:24.730
And, so,
one of the things that you're able to do

00:09:24.730 --> 00:09:28.830
is you're able to take advantage of the
hierarchical nature of the dependency

00:09:28.840 --> 00:09:33.720
graph and you're able to create what
we call composite nodes or macro nodes.

00:09:33.850 --> 00:09:39.530
And, so, you can rapidly create your own
customized image processing node,

00:09:39.550 --> 00:09:42.950
but at the same time reuse some
of the existing functionality that

00:09:42.950 --> 00:09:45.550
Shake's already implemented for you.

00:09:45.650 --> 00:09:49.470
And it's just a question of
wiring up your own internal node

00:09:49.940 --> 00:09:52.140
tree to manage that processing.

00:09:52.140 --> 00:09:54.500
So, that's an important concept.

00:09:56.010 --> 00:09:58.360
So let's look at plugs.

00:09:58.390 --> 00:09:59.500
Some points with plugs.

00:09:59.570 --> 00:10:03.180
We know that they're containers for data,
but an important point with them is that

00:10:03.180 --> 00:10:05.200
they must always be owned by a node.

00:10:05.200 --> 00:10:10.490
There's no such thing as just a
plug dangling outside somewhere or

00:10:10.490 --> 00:10:12.940
in some sort of outside of a node.

00:10:12.940 --> 00:10:17.360
We basically always have to have
an owner node for that plug.

00:10:18.500 --> 00:10:22.000
Plugs have polarity,
meaning certain plugs are dedicated

00:10:22.000 --> 00:10:25.800
to bringing data into the node,
and other plugs are dedicated

00:10:25.910 --> 00:10:28.120
for taking data out of the node.

00:10:28.120 --> 00:10:31.310
And when you define a plug,
you're going to say right up front you're

00:10:31.320 --> 00:10:33.460
an input plug or you're an output plug.

00:10:33.460 --> 00:10:36.970
And finally,
the plugs in Shake actually only

00:10:36.970 --> 00:10:39.770
represents five basic data types.

00:10:39.770 --> 00:10:46.100
We've got ins floats, double strings,
and also a plug that can store a pointer.

00:10:46.140 --> 00:10:48.480
So that's something that
you might want to look at.

00:10:48.500 --> 00:10:50.310
And then there's the plug that
you might find kind of surprising,

00:10:50.310 --> 00:10:51.100
but that's all we need.

00:10:51.100 --> 00:10:55.240
And the reason for that is that
plugs similar to nodes can have

00:10:55.240 --> 00:10:57.600
hierarchical relationships.

00:10:57.600 --> 00:11:01.870
And so one of the things that you can do
is you can actually create fairly complex

00:11:01.970 --> 00:11:04.380
plugs that have a lot of children plugs.

00:11:04.380 --> 00:11:09.400
And basically it allows you to
pass in a complex data structure.

00:11:09.400 --> 00:11:13.170
In this particular example,
we've got a composite

00:11:13.420 --> 00:11:18.370
plug or a macro plug,
and ten of its children are input plugs.

00:11:18.500 --> 00:11:20.480
Six of its children are output plugs.

00:11:20.480 --> 00:11:25.710
And so it allows sort of an interesting
movement of data in and out of the node.

00:11:25.770 --> 00:11:31.080
And the analogy I always like to make
is that nodes that have hierarchical

00:11:31.080 --> 00:11:35.700
relationships are basically supporting
more complicated processing.

00:11:35.720 --> 00:11:37.860
So when you see a node
with a lot of children,

00:11:37.860 --> 00:11:40.920
it's basically performing
more complex processing.

00:11:40.920 --> 00:11:44.540
If you see a plug with a lot of children,
what it is is it's more

00:11:44.540 --> 00:11:46.020
complex data structure.

00:11:46.020 --> 00:11:49.360
I always consider a plug with
children to be like a C struct.

00:11:49.580 --> 00:11:53.290
Basically you've got a number of
data members that are part of it,

00:11:53.660 --> 00:11:58.870
and it allows you to move complex
data in and out of your node.

00:12:00.560 --> 00:12:06.260
So where does the dependency part of the
dependency graph architecture come from?

00:12:06.500 --> 00:12:10.890
It comes from the concept that
your node produces values and

00:12:10.890 --> 00:12:15.640
places them in their output plug,
but you need to register with

00:12:15.640 --> 00:12:19.650
Shake what dependencies your,
what input plugs your

00:12:19.750 --> 00:12:21.950
output plug depends upon.

00:12:21.960 --> 00:12:25.810
So to produce a value,
usually you can write out a simple

00:12:25.940 --> 00:12:30.190
equation like C equals A plus B,
and then you can derive a very simple

00:12:30.190 --> 00:12:34.420
dependency relationship which says,
hey, plug C is dependent upon

00:12:34.420 --> 00:12:36.830
both plugs A and plugs B.

00:12:36.840 --> 00:12:40.370
And the reason that this is
important is because Shake needs

00:12:40.370 --> 00:12:44.350
to know whether the value stored
in your plug is up to date or not.

00:12:44.400 --> 00:12:49.520
Now let's say that you've got a plug
that computes A plus B equals C,

00:12:49.520 --> 00:12:55.220
and it's computed at once,
and so plug C is storing some value.

00:12:55.270 --> 00:12:58.710
Well, when Shake goes back to your node
to request the value of plug C,

00:12:58.930 --> 00:13:02.120
the first thing that it's going to
do is it's going to look at plug

00:13:02.120 --> 00:13:06.300
A and plug B and see if the values
have changed since the last time that

00:13:06.300 --> 00:13:08.920
it requested the value of plug C.

00:13:08.920 --> 00:13:12.290
And if plug A and plug B's
values haven't changed,

00:13:12.290 --> 00:13:13.570
then guess what?

00:13:13.570 --> 00:13:17.420
Shake isn't going to ask you
to do any processing at all.

00:13:17.420 --> 00:13:21.800
It's going to use the existing
value that's stored in plug C.

00:13:21.800 --> 00:13:23.970
And this is something that
makes a dependency graph very,

00:13:23.970 --> 00:13:29.100
very efficient so that there's only
recomputation when it's necessary.

00:13:29.220 --> 00:13:32.810
So if somebody does come in and
change an input value such as,

00:13:32.910 --> 00:13:35.910
okay, I'm going to change the
input value stored in plug B,

00:13:36.320 --> 00:13:39.680
Shake's dependency graph
architecture tracks that,

00:13:39.680 --> 00:13:42.890
and it'll say, hey, guess what?

00:13:42.890 --> 00:13:42.890
You need to recompute C.

00:13:45.690 --> 00:13:51.150
Another very important point that makes
Shake's dependency graph efficient

00:13:51.200 --> 00:13:55.780
is that the Shake node engine or
dependency graph engine is only going

00:13:55.780 --> 00:13:58.420
to call your plug-in for output values.

00:13:58.420 --> 00:14:03.280
I don't want to say it doesn't
care about your input plugs,

00:14:03.280 --> 00:14:06.630
but at the end of the day,
Shake is only going to ask your

00:14:06.630 --> 00:14:08.420
node to produce an output value.

00:14:09.280 --> 00:14:12.760
And what that means is that somebody
can go in and be fiddling with

00:14:12.760 --> 00:14:16.330
the value in plug B and plug A,
but your node isn't necessarily

00:14:16.330 --> 00:14:19.340
going to be called at that
point to compute a value.

00:14:19.340 --> 00:14:22.950
It's only going to be called when
somebody else out there needs your

00:14:23.230 --> 00:14:25.050
value stored in output plug C.

00:14:25.060 --> 00:14:28.920
So when somebody requests
the value stored in plug C,

00:14:28.920 --> 00:14:32.920
at that point,
Shake does its dependency graph logic,

00:14:33.020 --> 00:14:36.180
looks at the value
stored in plugs A and B.

00:14:36.180 --> 00:14:38.500
If they've changed,
then you're going to get called.

00:14:38.910 --> 00:14:40.380
And then you're going to
have to do some computation.

00:14:40.430 --> 00:14:45.420
So both lazy evaluation and dependencies
are very key aspects of dependency

00:14:45.750 --> 00:14:48.290
graphs that make them very efficient.

00:14:52.000 --> 00:14:54.140
So let's take a look at
SHAKE's rendering engine.

00:14:54.140 --> 00:14:58.970
First thing, when SHAKE came out,
you know, back in the middle, late 90s,

00:14:59.030 --> 00:15:03.990
one of the things that people just loved
about SHAKE was that it supported both 8,

00:15:03.990 --> 00:15:06.580
16, and 32-bit image data.

00:15:06.580 --> 00:15:09.740
You know,
what you'll see is it's 2005 now,

00:15:09.740 --> 00:15:12.340
and if you go to some of
the computer graphics,

00:15:12.340 --> 00:15:16.790
trade shows, NAB, SIGGRAPH,
somebody will come out and say, hey,

00:15:16.790 --> 00:15:20.670
we support HDR data now,
or high dynamic range data.

00:15:21.150 --> 00:15:22.890
Well,
SHAKE's been supporting high dynamic

00:15:22.890 --> 00:15:28.120
range data by supporting 32-bit
image data since the late 90s.

00:15:28.120 --> 00:15:29.070
That's no big deal for us.

00:15:29.160 --> 00:15:31.220
We've been able to manage
that for a very long time.

00:15:31.220 --> 00:15:34.630
Resolution independence,
that means that when you're

00:15:34.630 --> 00:15:38.420
working on a composition in SHAKE,
you can bring in 4K images,

00:15:38.420 --> 00:15:42.820
you can bring in 2K images,
you can bring in 640 by 480 images,

00:15:42.820 --> 00:15:45.820
and you can bring in all those
images into the same composition.

00:15:45.820 --> 00:15:48.460
It's not like I'm going to
sit down and I'm going to do a

00:15:48.480 --> 00:15:54.380
composition and this one's going
to be a 720 by 486 composition,

00:15:54.380 --> 00:15:56.770
and everything coming in has
to be cropped to that size.

00:15:56.880 --> 00:15:59.360
And actually,
if you take a look at the little

00:15:59.380 --> 00:16:02.880
graphics that I've got at the bottom,
it just shows we've got a color wheel.

00:16:02.880 --> 00:16:04.740
That color wheel is 8-bit image data.

00:16:04.880 --> 00:16:07.880
We're reading in a--that's
actually an OpenEXR file,

00:16:07.880 --> 00:16:12.240
and it's just a sample image,
and that's 32-bit image data.

00:16:12.550 --> 00:16:14.880
You can see that the sizes
of the images are different,

00:16:14.880 --> 00:16:17.350
and all we're doing is a
simple layering operation,

00:16:17.380 --> 00:16:19.880
and you'll see that SHAKE manages
that without any problem.

00:16:19.880 --> 00:16:24.670
So it can put A on top of
B without any problems whatsoever.

00:16:24.880 --> 00:16:27.360
And you can choose whether you
want the bit depth promoted

00:16:27.360 --> 00:16:30.790
to the background image value
or the foreground image value.

00:16:30.880 --> 00:16:33.880
So that's a very powerful aspect
of SHAKE's rendering engine.

00:16:33.880 --> 00:16:36.880
The reason I bring that up is, okay,
you're a plug-in developer,

00:16:36.880 --> 00:16:40.530
and you've got an image processing
algorithm that you want to

00:16:40.530 --> 00:16:41.880
get working inside of SHAKE.

00:16:41.880 --> 00:16:45.880
The thing that you need to do is you
need to make sure that you have an 8-bit,

00:16:45.880 --> 00:16:50.880
a 16-bit, and a 32-bit implementation
of your algorithm,

00:16:50.880 --> 00:16:52.870
meaning-- 'cause when you've
got your pointers to the data,

00:16:52.880 --> 00:16:54.850
it's got to be a pointer
to a data of a certain,

00:16:54.850 --> 00:16:56.880
you know, certain bit depth.

00:16:56.880 --> 00:17:01.280
And so most image processing nodes
in SHAKE support all three of

00:17:01.280 --> 00:17:03.880
those--all three of those bit depths.

00:17:03.880 --> 00:17:06.390
So that's something to keep in
the back of your mind when you're

00:17:06.470 --> 00:17:07.880
developing your algorithms.

00:17:08.120 --> 00:17:09.670
Um...

00:17:10.500 --> 00:17:15.160
Okay, so that's sort of the
first piece of information.

00:17:15.160 --> 00:17:18.430
The second piece of information
is that how does Shake actually

00:17:18.430 --> 00:17:19.920
generate pixel values?

00:17:19.920 --> 00:17:22.190
Well, what it does is,
I don't know if you're familiar

00:17:22.190 --> 00:17:23.720
with like a scanline renderer.

00:17:23.720 --> 00:17:27.730
A scanline renderer essentially
just renders a line of pixels and,

00:17:27.730 --> 00:17:30.830
you know,
just sequentially does one line after the

00:17:30.830 --> 00:17:33.470
next until it builds up an entire image.

00:17:33.470 --> 00:17:40.400
Shake uses what we call a hybrid block
scanline and tile-based renderer.

00:17:40.500 --> 00:17:44.680
And the reason why it's a block
scanline is that Shake will

00:17:44.680 --> 00:17:50.130
basically process as many scanlines
as can fit in the CPU's L2 cache.

00:17:50.130 --> 00:17:54.450
The reason is that, you know,
the processing nodes are constantly

00:17:54.570 --> 00:18:00.340
updating the pixel data stored in memory,
and if you've got that pixel data

00:18:00.340 --> 00:18:05.800
sitting in your CPU's L2 cache,
the retrieval of that is very fast.

00:18:05.800 --> 00:18:08.660
It makes the Shake rendering engine very,
very fast.

00:18:08.660 --> 00:18:09.920
So that's an important thing.

00:18:10.690 --> 00:18:13.280
The other thing is that,
so tile-based rendering.

00:18:13.360 --> 00:18:16.410
Tile-based rendering basically
is what it sounds like.

00:18:16.410 --> 00:18:19.460
It takes an image and breaks
it up into individual tiles and

00:18:19.520 --> 00:18:21.580
can work with individual tiles.

00:18:21.580 --> 00:18:26.210
And there are certain circumstances
that Shake will internally convert

00:18:26.260 --> 00:18:28.510
to being a tile-based renderer.

00:18:28.750 --> 00:18:32.880
And the final point on that is by
rendering just a few scan lines

00:18:32.880 --> 00:18:36.130
at a time instead of working
with full frame image buffers,

00:18:36.130 --> 00:18:38.700
it really reduces
Shake's memory footprint.

00:18:38.800 --> 00:18:42.560
A lot of our customers will be
working on composites that might have,

00:18:42.560 --> 00:18:44.860
like, 40 or 50 input files.

00:18:44.860 --> 00:18:46.970
These things look like a map of L.A.

00:18:46.970 --> 00:18:49.610
I mean,
you've got a huge number of input nodes.

00:18:49.650 --> 00:18:52.350
You've got, you know,
tons of a lot of image

00:18:52.380 --> 00:18:53.990
processing operations.

00:18:53.990 --> 00:18:58.360
And so, it's very important that image
processing nodes in Shake are able

00:18:58.360 --> 00:19:01.570
to work on just a few scan lines of
data at a time so that the memory

00:19:01.570 --> 00:19:03.070
footprint doesn't become ridiculous.

00:19:05.000 --> 00:19:07.600
So in tile-based mode,
you can imagine that if,

00:19:07.800 --> 00:19:13.070
let's say you're a transformation
operator or a warp operator where

00:19:13.070 --> 00:19:16.490
you've got to rotate an input image.

00:19:16.500 --> 00:19:19.860
Well, to do the rotation,
you're actually going to need

00:19:19.860 --> 00:19:23.290
to retrieve pixel data from
other regions of the image.

00:19:23.320 --> 00:19:25.890
And we're trying to just work
on a few scan lines at a time,

00:19:25.970 --> 00:19:26.450
right?

00:19:27.240 --> 00:19:30.630
And so underneath the hood,
what Shake will do is when you

00:19:30.630 --> 00:19:34.660
request essentially image data
from outside of your scan line,

00:19:34.660 --> 00:19:39.280
Shake can actually break up the incoming
image into tiles that it caches.

00:19:39.280 --> 00:19:41.460
And so it'll give you that image data.

00:19:41.460 --> 00:19:43.250
It'll keep the tile around.

00:19:43.260 --> 00:19:46.910
And then if like a subsequent pixel
that's being processed down the

00:19:46.910 --> 00:19:50.690
scan line needs image data from one
of those tiles that's been cached,

00:19:50.690 --> 00:19:52.690
it's right there and very fast.

00:19:52.770 --> 00:19:57.060
So that's sort of the
basics of the rendering.

00:19:57.060 --> 00:20:02.010
And one of the things that we always
encourage our developers to do because

00:20:02.020 --> 00:20:07.210
sometimes developers will come from
doing plug-ins from an application that

00:20:07.220 --> 00:20:09.920
they get the full frame image buffer.

00:20:09.920 --> 00:20:12.500
And so they're used to
having all of the pixel data,

00:20:12.500 --> 00:20:14.760
all of the input image
pixel data at once.

00:20:14.760 --> 00:20:19.040
And so sometimes developers need
to refactor their algorithms or

00:20:19.050 --> 00:20:23.430
image processing algorithms so
that they can actually work within

00:20:23.430 --> 00:20:25.820
a block scan line environment.

00:20:25.820 --> 00:20:28.500
And a lot of times...
It's very easy to do that.

00:20:28.630 --> 00:20:32.830
It's just a question of sometimes
developers will have image processing

00:20:32.830 --> 00:20:36.960
libraries and those image processing
libraries expect the full frame

00:20:36.960 --> 00:20:40.460
input image and they just need
to do some refactoring to work

00:20:40.460 --> 00:20:42.560
on just a few scan lines at a time.

00:20:45.260 --> 00:20:48.020
Okay, so within Shake,
all the pixels live in

00:20:48.020 --> 00:20:49.780
a 2D coordinate space.

00:20:49.780 --> 00:20:54.280
And one of the things that we
like to do right up front is,

00:20:54.280 --> 00:20:59.100
you know, where is the origin of
this 2D coordinate system?

00:20:59.100 --> 00:21:02.130
And as this graphic illustrates,
if you open up Shake,

00:21:02.160 --> 00:21:04.560
there is what we call the viewer window.

00:21:04.560 --> 00:21:08.730
And in the viewer window,
you actually see the final,

00:21:08.730 --> 00:21:13.650
what the dimensions of the final
image are going to look like.

00:21:14.170 --> 00:21:15.840
So I call that the image window.

00:21:16.010 --> 00:21:21.110
And the 2D coordinate system inside of
Shake is always anchored to the lower

00:21:21.110 --> 00:21:22.990
left-hand corner of the image window.

00:21:23.000 --> 00:21:26.950
So if you've got a 720 by 486 image,
your coordinate system is

00:21:26.950 --> 00:21:30.270
going to be anchored to the
lower left-hand corner of that.

00:21:30.290 --> 00:21:34.900
You know, you've got a 640 by, you know,
486, whatever it is,

00:21:34.900 --> 00:21:38.210
it's always going to be
anchored to the lower left-hand

00:21:38.210 --> 00:21:40.080
corner of the image window.

00:21:40.080 --> 00:21:42.960
And even within a composite,
let's say you've got a composite.

00:21:42.960 --> 00:21:46.810
The input image is 720 by 486.

00:21:46.960 --> 00:21:50.960
But at some other point in the composite,
you change the size of the image.

00:21:50.960 --> 00:21:54.960
Maybe you've done a resize
to make it larger or smaller.

00:21:54.960 --> 00:21:59.670
The 2D coordinate system still stays
anchored to that lower left-hand corner.

00:22:00.010 --> 00:22:03.960
Everything else sort of adjusts
itself with respect to that.

00:22:03.960 --> 00:22:07.950
So that's the first piece of information.

00:22:08.880 --> 00:22:13.520
The second piece of information,
and this is sort of another one of the

00:22:13.520 --> 00:22:17.600
things that's a bit of a first in Shake,
is the notion that the

00:22:17.600 --> 00:22:20.960
composition workspace is
actually an infinite workspace.

00:22:20.960 --> 00:22:27.750
There aren't hard boundaries where image
data can be lost in most circumstances.

00:22:27.770 --> 00:22:31.750
And so if you transform
pixels or resize them,

00:22:31.760 --> 00:22:37.320
do a corner pin, whatever you're doing,
even though that pixel data might

00:22:37.320 --> 00:22:40.920
fall outside of your image window,
as you see, for instance,

00:22:40.930 --> 00:22:44.580
in this graphic down here,
the color wheel has been

00:22:44.620 --> 00:22:46.390
transformed to the right.

00:22:46.460 --> 00:22:52.290
And even though some of its image
data is outside of the image window,

00:22:52.290 --> 00:22:54.900
Shake is still tracking it.

00:22:55.150 --> 00:22:57.740
Shake, under the hood,
actually tracks pixel data.

00:22:57.760 --> 00:22:59.410
And so if you want to track pixel data,
you can track pixel data

00:22:59.410 --> 00:23:00.380
everywhere in this 2D space.

00:23:00.380 --> 00:23:04.130
And a quick point that I want to cover,
because it comes up in

00:23:04.150 --> 00:23:08.070
plug-in development,
is there is a color to Shake's canvas,

00:23:08.070 --> 00:23:10.880
and it's important to track this color.

00:23:10.880 --> 00:23:12.230
It's called the background pixel.

00:23:12.240 --> 00:23:14.530
And in this case,
you can see that the background

00:23:14.530 --> 00:23:17.170
pixel color is black,
and it's almost always black.

00:23:17.250 --> 00:23:18.000
It rarely changes.

00:23:18.000 --> 00:23:20.670
But it is what we call
the color of the canvas,

00:23:20.840 --> 00:23:22.420
the background pixel.

00:23:22.420 --> 00:23:27.500
And there's a couple
of key bounding boxes.

00:23:27.760 --> 00:23:32.880
And the first one is that Shake defines
to enable you to track where pixel data

00:23:32.880 --> 00:23:35.520
is and where processing should occur.

00:23:35.520 --> 00:23:38.460
The first thing is the
domain of definition,

00:23:38.460 --> 00:23:40.120
or we just call it DOD.

00:23:40.120 --> 00:23:46.490
And the DOD is a bounding box that
actually bounds all valid pixel data.

00:23:46.500 --> 00:23:49.340
And by valid pixel data, you say, oh,
it's valid pixel data.

00:23:49.340 --> 00:23:53.880
It's a pixel value that is not
equal to the background pixel value.

00:23:53.880 --> 00:23:57.220
So even though in this graphic,
it's not equal to the

00:23:57.250 --> 00:23:57.740
background pixel value,
it's a pixel value that is not

00:23:57.740 --> 00:23:57.740
equal to the background pixel value.

00:23:57.740 --> 00:23:59.850
And so in this graphic
that I've got here,

00:23:59.850 --> 00:24:02.680
what you'll see is the DOD is
represented by the ground or

00:24:02.680 --> 00:24:04.400
by the green rubber band box.

00:24:04.400 --> 00:24:08.290
And actually,
that green rubber band box extends

00:24:08.290 --> 00:24:10.760
off the screen to encompass.

00:24:10.760 --> 00:24:12.530
Let me use my laser pointer again.

00:24:12.540 --> 00:24:17.000
The green bounding box will
actually extend off the screen to

00:24:17.000 --> 00:24:22.180
track where the edge of the valid
pixel data for the color wheel is.

00:24:22.200 --> 00:24:26.720
And so that's the first
thing that Shake tracks.

00:24:26.720 --> 00:24:27.680
The second thing.

00:24:27.760 --> 00:24:30.090
The third thing that Shake tracks is
what we call the region of interest.

00:24:30.100 --> 00:24:34.080
And the region of interest is
a very powerful tool within

00:24:34.080 --> 00:24:38.390
Shake because essentially,
you might have a 2K image coming in.

00:24:38.460 --> 00:24:42.020
But at the end of the day,
the user might only be interested

00:24:42.020 --> 00:24:46.440
in a small 200 by 200 region
inside of that 2K image.

00:24:46.440 --> 00:24:51.280
The region of interest allows
you to tell Shake or basically

00:24:51.290 --> 00:24:54.560
allows you to tell Shake,
we only want to process

00:24:54.710 --> 00:24:56.520
these 200 by 200 pixels.

00:24:56.520 --> 00:25:00.950
I don't want to perform image
processing on the full 2K plate.

00:25:01.020 --> 00:25:04.270
So the region of interest is
a very important bounding box.

00:25:04.310 --> 00:25:06.770
In this case, the region of interest
is actually-- well,

00:25:06.770 --> 00:25:09.210
we'll take a look at it really quickly.

00:25:10.210 --> 00:25:13.320
Next slide.

00:25:14.100 --> 00:26:53.600
[Transcript missing]

00:26:56.100 --> 00:28:59.800
[Transcript missing]

00:29:00.170 --> 00:29:03.630
You're going to be using plugs to
get data in and out of your node,

00:29:03.730 --> 00:29:06.640
and so you're going to be
using the NRI plug class.

00:29:06.700 --> 00:29:08.930
You're rarely going to need
to derive from NRI plug.

00:29:09.130 --> 00:29:15.050
As it turns out,
we've got 26 example plug-ins in the SDK,

00:29:15.240 --> 00:29:22.010
and I don't think any of them actually
end up coming up with a specialized

00:29:22.010 --> 00:29:24.730
plug that derives from NRI plug,
so you'll just be using

00:29:24.730 --> 00:29:24.730
the NRI plug class as is.

00:29:28.580 --> 00:29:31.720
And is everyone, I mean,
if you're Objective

00:29:31.720 --> 00:29:35.310
C programmers or C++ programmers,
you're probably comfortable

00:29:35.920 --> 00:29:38.500
with the idea of an interface,
a functional interface.

00:29:38.500 --> 00:29:39.840
Is everyone pretty comfortable with that?

00:29:39.970 --> 00:29:44.930
So essentially a functional
interface is a set of functions

00:29:44.930 --> 00:29:47.670
or a suite of functions that,
you know,

00:29:47.670 --> 00:29:50.300
fulfill a certain contract or task.

00:29:50.600 --> 00:29:53.170
And in Shake,
we've got a set of functions

00:29:53.190 --> 00:29:57.680
in the NRI node base class that
allow you to communicate with

00:29:57.700 --> 00:30:00.500
Shake's dependency graph engine,
basically, and rendering engine.

00:30:00.500 --> 00:30:02.260
And I think you'll be surprised.

00:30:02.260 --> 00:30:05.780
There's actually not a lot of
functions that you'll need to override.

00:30:05.780 --> 00:30:07.300
It'll be fairly straightforward.

00:30:07.300 --> 00:30:11.110
The first and most important
one is the eval function.

00:30:11.110 --> 00:30:17.510
And your eval function is where you
compute the value of output plugs.

00:30:17.540 --> 00:30:21.820
Remember, with lazy evaluation,
Shake isn't going to ask you for

00:30:21.820 --> 00:30:23.200
the value of your input plugs.

00:30:23.200 --> 00:30:25.670
It's not going to come to you and say,
"Give me a value of your

00:30:25.670 --> 00:30:28.490
input plugs." Shake is only
going to come to you and say,

00:30:28.580 --> 00:30:32.290
"I need this value for your output
plug." And when it does that,

00:30:32.310 --> 00:30:35.500
it's going to call your
eval member function.

00:30:35.600 --> 00:30:39.400
It's going to pass in a pointer to
the plug that it's interested in.

00:30:39.400 --> 00:30:41.870
And then essentially what
you've got inside of your

00:30:41.870 --> 00:30:45.050
eval is something that says,
"Ah, if you're interested in the

00:30:45.050 --> 00:30:47.840
value of this output plug,
then I need to do this set of

00:30:47.840 --> 00:30:50.200
computations." You do those computations.

00:30:50.200 --> 00:30:53.120
And you update the value
in the output plug.

00:30:53.200 --> 00:30:58.390
A second one, which is one that ends up
being used quite a bit,

00:30:58.500 --> 00:30:59.900
is the notify.

00:31:00.310 --> 00:31:04.750
And the reason for this is that the
concept of lazy evaluation is you're only

00:31:04.890 --> 00:31:08.200
going to be asked for your output plugs.

00:31:08.200 --> 00:31:11.370
But sometimes you want to
get notified when one of your

00:31:11.370 --> 00:31:13.200
input plug values changes.

00:31:13.200 --> 00:31:16.450
You know, a user might do something and
it might change the mode that

00:31:16.450 --> 00:31:18.200
your plug-in is going to work in.

00:31:18.200 --> 00:31:19.800
So you want some kind of notification.

00:31:19.800 --> 00:31:22.580
So there is a way around this.

00:31:22.830 --> 00:31:28.370
With an input plug, you can say to Shake,
"Hey, call me when somebody changes the

00:31:28.370 --> 00:31:32.070
value of one of my input plugs."
Because there's some stuff I need to do,

00:31:32.080 --> 00:31:33.670
reset up, whatever it is.

00:31:33.870 --> 00:31:36.800
And so on an input plug,
you can register that plug.

00:31:36.800 --> 00:31:40.130
Say, "I want to be notified when it
changes." When its value changes,

00:31:40.130 --> 00:31:43.800
Shake is going to call you through
the notify callback function.

00:31:43.800 --> 00:31:46.800
At that point,
you can take any action you want to take.

00:31:46.800 --> 00:31:49.400
You can't actually do image processing.

00:31:49.400 --> 00:31:51.400
Or core rendering.

00:31:51.400 --> 00:31:53.400
But there's a lot of things
that you can do in there.

00:31:53.970 --> 00:31:59.250
Another one that developers
might override is the begin exec.

00:31:59.400 --> 00:32:02.400
That essentially gets called
right before render starts.

00:32:02.400 --> 00:32:06.400
So if you've got things you need to
set up before you do your rendering,

00:32:06.690 --> 00:32:08.400
implement that in the begin exec.

00:32:08.470 --> 00:32:10.400
Because it's just called once
right before frame renders.

00:32:10.400 --> 00:32:12.400
It's called on a per frame basis.

00:32:12.400 --> 00:32:14.380
So each frame that renders,
your begin exec will be called.

00:32:14.400 --> 00:32:19.000
And then you can allocate some memory,
set up some flags, whatever you want.

00:32:19.000 --> 00:32:21.040
whatever you need to do.

00:32:24.060 --> 00:32:28.840
I think we covered that, didn't we?

00:32:28.840 --> 00:32:31.690
End exec,
that's just sort of the other side

00:32:31.690 --> 00:32:33.520
of the render from the begin exec.

00:32:33.520 --> 00:32:37.060
So when the frame finishes rendering,
if there's something you need

00:32:37.060 --> 00:32:42.660
to do to clean up or reset,
override the end exec member function.

00:32:42.820 --> 00:32:48.850
One of the things that Shake sort of does
for free for you is that it'll serialize

00:32:48.850 --> 00:32:54.200
in sort of a standardized format all
of your input plug values for you.

00:32:54.470 --> 00:33:00.130
So Shake actually manages serialization
of your plug-in's input values for you.

00:33:00.240 --> 00:33:03.630
If you need to customize that,
if there are some actions

00:33:03.630 --> 00:33:06.900
that you need to take,
then you'll need to override

00:33:06.980 --> 00:33:09.210
the serialize member function.

00:33:09.410 --> 00:33:12.810
Most plug-ins don't have to,
but it's something that you have the

00:33:12.810 --> 00:33:17.210
option of doing so that you can override
the default serialization logic that's

00:33:17.360 --> 00:33:20.300
built into the NRI node base class.

00:33:20.300 --> 00:33:25.470
And a final one for computationally
intensive image processing algorithms,

00:33:25.470 --> 00:33:28.270
I think there's a check
interrupt function.

00:33:28.440 --> 00:33:31.290
It's not something that
you override or implement,

00:33:31.290 --> 00:33:34.880
but it's just there for you to call so
that let's say you've got this big loop,

00:33:34.880 --> 00:33:38.540
maybe in the outer loop you
can put in a check interrupt so

00:33:38.680 --> 00:33:42.220
that if the user hits escape,
the check interrupt will tell you that

00:33:42.220 --> 00:33:45.200
the user's hit escape and then you can
do the right thing and stop computing.

00:33:45.200 --> 00:33:47.690
Because if you've got
something that takes 15,

00:33:47.690 --> 00:33:50.960
20 seconds or a minute or more,
you've certainly got to give the user

00:33:50.990 --> 00:33:53.660
the option of canceling the processing.

00:33:56.680 --> 00:34:01.400
Wow, we got duplicate,
I see it lit up when I pressed it, okay.

00:34:01.400 --> 00:34:04.920
So code building blocks,
let's get into plugs cuz one of the

00:34:04.960 --> 00:34:07.840
things you're gonna need to do is
you're gonna need to get values out

00:34:07.840 --> 00:34:10.770
of plugs cuz plugs are containers,
they store the values.

00:34:10.780 --> 00:34:12.260
But you need to get those values out.

00:34:12.260 --> 00:34:15.170
So for each of the data types,
you'll see that there's the

00:34:15.310 --> 00:34:20.360
associated give me the data as an int,
as a float, as a double,

00:34:20.360 --> 00:34:22.820
as a pointer and as a string.

00:34:22.820 --> 00:34:24.900
And Shake has its own string class.

00:34:24.990 --> 00:34:27.700
Most applications end up doing
that for whatever reason,

00:34:27.700 --> 00:34:30.160
unless they use STL or
something like that.

00:34:30.160 --> 00:34:34.400
And so if you need to get a const char*,
it's really easy.

00:34:34.400 --> 00:34:36.740
The shake string class is nri_name.

00:34:36.740 --> 00:34:38.750
If you need to get your const
char* pointer out of that,

00:34:38.850 --> 00:34:40.960
just call get_string
on the nri_name object.

00:34:40.960 --> 00:34:43.850
So that's how you get
data out of your plugs.

00:34:43.860 --> 00:34:46.620
And most of the time you're pulling
data out of your input plugs cuz

00:34:46.620 --> 00:34:50.740
you're gonna need those input values
to compute your output values.

00:34:51.360 --> 00:34:54.490
Finally,
there is only a single member function

00:34:54.490 --> 00:34:56.600
for setting a value in a plug.

00:34:56.600 --> 00:35:01.860
The logic inside of the
NRI plug base class will manage,

00:35:01.860 --> 00:35:06.920
let's say you want to set a
floating point value and you

00:35:06.920 --> 00:35:13.500
set it as a quoted string 4.0,
there is logic inside of the NRI plug

00:35:13.500 --> 00:35:13.500
base class to do the necessary conversion
based on the data type of the plug.

00:35:15.690 --> 00:35:20.490
And a key thing in a dependency graph,
the only way that we can move data in a

00:35:20.500 --> 00:35:22.750
dependency graph is by connecting plugs.

00:35:22.750 --> 00:35:27.170
And so one of the things that you'll
use a lot is the connect call.

00:35:27.180 --> 00:35:30.800
As we said earlier,
connections can only be made

00:35:30.800 --> 00:35:33.680
between plugs of the same data type.

00:35:33.730 --> 00:35:41.250
And there is sort of an order
or a getter-setter relationship.

00:35:41.650 --> 00:35:44.440
Basically,
if I'm a plug and I say connect me to,

00:35:44.440 --> 00:35:47.130
I'm plug A,
and I say connect me to plug B,

00:35:47.130 --> 00:35:50.960
that means that plug B is
going to be setting my value.

00:35:50.960 --> 00:35:52.490
I'm not setting plug B's value.

00:35:52.510 --> 00:35:55.090
So if I'm plug A and I say
connect me to plug B,

00:35:55.090 --> 00:35:57.830
that means I'm getting
my value from plug B.

00:35:57.830 --> 00:36:01.500
And I'm sharing a number of other things,
like the state of the plug.

00:36:01.810 --> 00:36:04.950
Like in the dependency graph,
we know that input plugs,

00:36:04.950 --> 00:36:07.900
if their value's changed,
will have a state that

00:36:07.900 --> 00:36:11.560
we call marked as dirty,
meaning that its input value is has

00:36:11.700 --> 00:36:13.590
changed since the last evaluation.

00:36:13.590 --> 00:36:15.960
Connected plugs all share that state.

00:36:16.020 --> 00:36:20.800
So if I've got 30 connected plugs,
the plug at the end of that chain shares

00:36:20.850 --> 00:36:25.420
the same value and up-to-date state
as the plug at the end of the chain.

00:36:28.700 --> 00:36:32.060
And finally,
how do you add a plug to your node?

00:36:32.360 --> 00:36:37.140
As we said, plugs must be owned by nodes,
and so it makes sense that the NRI node

00:36:37.200 --> 00:36:41.460
base class actually has the function
necessary to add a plug to itself.

00:36:41.460 --> 00:36:43.380
So when you add a plug, you set its name.

00:36:43.430 --> 00:36:45.760
It's just a string,
and it's actually the name that

00:36:45.780 --> 00:36:48.820
will show up in the UI when
somebody's editing your plug-in.

00:36:48.820 --> 00:36:52.900
So it's usually good to choose a
name that's intuitive to the user.

00:36:52.900 --> 00:36:57.440
So that's the first argument.

00:36:58.120 --> 00:36:59.470
The second argument is the type.

00:36:59.540 --> 00:37:02.080
Is it going to be an int, float, double,
pointer, string?

00:37:02.080 --> 00:37:05.320
The next argument is the IO.

00:37:05.320 --> 00:37:09.640
As we discussed, a plug is either an
input or an output plug,

00:37:09.640 --> 00:37:11.250
so you'll be setting that.

00:37:11.260 --> 00:37:14.350
An internal plug is one that
won't show up in the UI.

00:37:14.350 --> 00:37:17.340
It's just something that stores
a value internally for you.

00:37:17.420 --> 00:37:19.540
So you can set a plug
as being K internal.

00:37:19.540 --> 00:37:25.070
And one of the things that plug-in
developers come back with is,

00:37:25.070 --> 00:37:29.270
how do I change the order of
how my plugs appear in the UI?

00:37:29.340 --> 00:37:32.630
Well, your node actually stores a list
of all the plugs you've added,

00:37:32.630 --> 00:37:34.400
and you can control that ordering.

00:37:34.400 --> 00:37:38.300
And within this add plug,
you can actually say, hey,

00:37:38.300 --> 00:37:40.640
add this plug as the
first one in the list,

00:37:40.640 --> 00:37:44.100
which means when the user's
editing your plug-in,

00:37:44.250 --> 00:37:47.840
they'll actually see that
plug first in the list.

00:37:50.330 --> 00:37:54.450
Okay, so I think those are the
basic code building blocks.

00:37:54.500 --> 00:37:58.680
There's obviously a lot more classes
that are part of the Shake code base,

00:37:59.450 --> 00:38:03.270
but the key ones that you're going
to be using over and over and over

00:38:03.270 --> 00:38:05.400
again is nri_node and nri_plug.

00:38:05.400 --> 00:38:08.880
Making the connection, setting values,
that's the core things that

00:38:08.960 --> 00:38:11.220
the plugins in Shake do.

00:38:11.220 --> 00:38:16.370
So what I want to do is I want
to revisit the C equals A plus

00:38:16.370 --> 00:38:21.850
B plugin example and actually Take a
look at some source code for that.

00:38:23.680 --> 00:38:29.210
So let's take a look at the
class definition for this node.

00:38:29.250 --> 00:38:31.570
The first thing is that
this one we're just going to

00:38:31.570 --> 00:38:32.840
derive directly from NRI node.

00:38:32.840 --> 00:38:34.800
We're not doing anything fancy in it.

00:38:34.890 --> 00:38:38.850
So we derive from NRI node,
and we've got three plugs.

00:38:38.860 --> 00:38:40.380
We've got A, B, and C.

00:38:40.380 --> 00:38:41.920
A and B are input plugs.

00:38:41.920 --> 00:38:43.420
C is the output plug.

00:38:43.420 --> 00:38:47.320
And so we declare pointers
to them in our header.

00:38:47.780 --> 00:38:53.310
In the constructor in Shake,
and this is an important point,

00:38:53.460 --> 00:38:57.250
is that in some
object-oriented environments,

00:38:57.250 --> 00:39:00.980
it's encouraged that you don't
do too much in the constructor.

00:39:00.980 --> 00:39:04.080
You know, that you basically have a
very lightweight constructor,

00:39:04.080 --> 00:39:06.960
and then maybe you'll have an
initialized member function where

00:39:06.960 --> 00:39:09.080
everything happens in the initialized.

00:39:09.080 --> 00:39:10.710
Well, Shake doesn't follow that.

00:39:10.840 --> 00:39:12.080
Actually, it's just the opposite.

00:39:12.080 --> 00:39:14.850
In Shake,
you do everything in terms of setup

00:39:14.850 --> 00:39:17.070
must happen in your constructor.

00:39:17.160 --> 00:39:20.160
So in terms of adding
the plugs to your node,

00:39:20.160 --> 00:39:23.410
registering dependencies,
making connections,

00:39:23.410 --> 00:39:27.820
anything that you're going to do,
you're going to do in the constructor

00:39:27.870 --> 00:39:30.600
when you're building a plug-in in Shake.

00:39:30.660 --> 00:39:34.960
And in this, the only dependency graph
interface function that we're

00:39:35.060 --> 00:39:39.220
going to override is eval,
because the only thing that we're going

00:39:39.280 --> 00:39:42.730
to need to do is eval the value of C,
our output plug.

00:39:42.740 --> 00:39:46.560
So that's what your
header file looks like.

00:39:47.160 --> 00:39:48.440
Fairly simple.

00:39:48.440 --> 00:39:53.440
And let's take a look at the
constructor for this plug-in.

00:39:53.440 --> 00:39:56.960
As you can see,
we're using the add plug member function.

00:39:56.960 --> 00:39:59.500
We've just decided to
name the plugs capital A,

00:39:59.620 --> 00:40:03.420
capital B, capital C, and that's the way
they'll appear in the UI.

00:40:03.420 --> 00:40:07.840
The first,
all three plugs are integer plugs.

00:40:07.840 --> 00:40:12.620
And the first two, A and B,
we tell Shake that they're input plugs.

00:40:12.640 --> 00:40:15.300
And the third plug,
we tell Shake that it's an output plug.

00:40:15.300 --> 00:40:17.040
So that's the first thing.

00:40:17.160 --> 00:40:18.410
Add all your plugs.

00:40:18.420 --> 00:40:22.510
Now that you've got your plugs added,
remember this is a dependency graph,

00:40:22.510 --> 00:40:26.580
and Shake needs a way to know
when the value that you're

00:40:26.590 --> 00:40:29.050
computing for plug C is up to date.

00:40:29.120 --> 00:40:33.330
So what you've got to
do is add dependencies.

00:40:33.360 --> 00:40:37.890
So on plug C, we call add dependencies,
and we tell Shake, by the way,

00:40:37.900 --> 00:40:42.040
the output value of C is dependent
upon A and B being up to date.

00:40:42.070 --> 00:40:44.650
And here,
I just wanted to give you a demonstration

00:40:44.650 --> 00:40:46.640
of actually setting a plug's value.

00:40:47.290 --> 00:40:49.500
You'll see that for plug A,
I just set it using a

00:40:49.500 --> 00:40:50.940
standard integer value.

00:40:50.940 --> 00:40:55.140
But you'll also see with plug B,
I actually passed in a quoted string.

00:40:55.140 --> 00:40:58.300
And as we discussed before,
the NRI node base class,

00:40:58.300 --> 00:41:01.950
or the NRI plug base class,
knows how to handle the conversion

00:41:01.950 --> 00:41:04.250
necessary based on your plug type.

00:41:07.570 --> 00:41:10.680
Okay, so let's go into our eval function.

00:41:10.680 --> 00:41:14.530
So this is how, this is the function that
Shake's going to call when

00:41:14.530 --> 00:41:15.940
it wants the value of plug C.

00:41:15.940 --> 00:41:20.190
So all we're going to do is,
we've defined pointers to our

00:41:20.190 --> 00:41:24.640
input plugs and our output plugs,
and so what we're going to do is we're

00:41:24.650 --> 00:41:29.200
just going to see whether Shake is
calling us for the value of plug C.

00:41:29.200 --> 00:41:33.340
And if it is, then you'll see that we're
going to retrieve the values

00:41:33.340 --> 00:41:37.180
from plug A and plug B,
so we've got our two integer values.

00:41:37.500 --> 00:41:40.160
And then we're going to
do a simple computation,

00:41:40.160 --> 00:41:43.310
A plus B, and we're going to take
the resulting value of C,

00:41:43.330 --> 00:41:45.520
and we've got to actually
set it into the plug.

00:41:45.520 --> 00:41:48.880
So remember, a plug is a container,
and it holds a value,

00:41:48.880 --> 00:41:52.240
so we've actually got to set
that value into the C plug.

00:41:52.240 --> 00:41:56.180
And one of the things that
happens is that since Shake,

00:41:56.790 --> 00:42:01.960
actually Shake has quite a deep class
hierarchy for doing image processing,

00:42:01.960 --> 00:42:07.260
it's always good form to call your
super class or your parent class.

00:42:07.500 --> 00:42:09.760
And because you might
not evaluate that plug,

00:42:09.760 --> 00:42:12.580
it might actually be a plug
that your parent class defines

00:42:13.260 --> 00:42:16.880
and has logic for evaluating,
so it's always good form in Shake to

00:42:16.880 --> 00:42:18.510
call your super class with a plug.

00:42:18.520 --> 00:42:21.970
Now, in this case,
you could put something in the

00:42:21.970 --> 00:42:26.260
evaluation section for plug
C where it just says return zero,

00:42:26.260 --> 00:42:26.960
and that would be fine.

00:42:26.960 --> 00:42:30.780
Zero is the success code in
Shake or the error code that

00:42:30.810 --> 00:42:33.480
indicates that nothing went wrong.

00:42:33.680 --> 00:42:36.580
And so, okay, we've covered that.

00:42:37.970 --> 00:42:44.460
Cool, so one of the main things you're
gonna do with Shake is you're going

00:42:44.460 --> 00:42:48.530
to develop image processing plug-ins.

00:42:48.680 --> 00:42:53.620
I would say 90% of the plug-ins
that people develop for Shake are

00:42:53.770 --> 00:42:55.040
image processing plug-ins.

00:42:55.040 --> 00:42:59.630
The other ones, if I were to list them,
you'll see people

00:42:59.710 --> 00:43:02.280
developing asset management,
you know,

00:43:02.280 --> 00:43:06.750
plug-ins that enable Shake to work
with an asset management system.

00:43:06.760 --> 00:43:11.540
Render queue submittal plug-ins
are another variety of plug-in.

00:43:11.570 --> 00:43:14.490
But for the most part,
our developers out there are

00:43:14.500 --> 00:43:16.980
developing image processing plug-ins.

00:43:17.000 --> 00:43:22.970
And so that's what I would guess is,
like, out of everyone there,

00:43:23.040 --> 00:43:25.140
do you guys do,
if you do do plug-in development,

00:43:25.140 --> 00:43:28.200
do you do image processing
plug-in development?

00:43:28.210 --> 00:43:31.650
Okay, what other kinds of plug-in
development do you guys do?

00:43:32.270 --> 00:43:33.200
Render queue?

00:43:33.340 --> 00:43:36.440
Okay, we've got a plug-in
type that supports that.

00:43:36.610 --> 00:43:38.500
Any others?

00:43:38.500 --> 00:43:39.170
Okay.

00:43:39.300 --> 00:43:44.030
Anyhow, let's talk about, first of all,
plug-in types.

00:43:44.090 --> 00:43:44.450
Here they are.

00:43:45.140 --> 00:43:49.420
Image processing plug-ins,
on-screen controls, like for instance,

00:43:49.420 --> 00:43:52.460
is everyone familiar with
an on-screen control?

00:43:53.840 --> 00:43:57.160
Basically, it's a reference geometry that
sits right on top of the image,

00:43:57.160 --> 00:44:00.490
and what you can do is the user can
actually interact with that reference

00:44:00.550 --> 00:44:02.940
geometry to make parameter changes.

00:44:02.940 --> 00:44:07.060
So instead of actually going over to a
parameter editor and tweaking a slider,

00:44:07.070 --> 00:44:10.420
there's reference geometry
drawn right on top of the image,

00:44:10.420 --> 00:44:12.760
and by interacting with
that reference geometry,

00:44:12.810 --> 00:44:15.770
you're actually modifying
values and changing the image.

00:44:16.600 --> 00:44:20.090
One of the things that we've
just introduced in Shake 4 is

00:44:20.090 --> 00:44:24.110
the ability to get spline data or
shape data in and out of Shake.

00:44:24.240 --> 00:44:28.110
There's a number of applications
out there that support rotoscoping,

00:44:28.120 --> 00:44:31.780
and that's the kind of thing,
and we need to get shape data in and out.

00:44:31.800 --> 00:44:34.040
As I mentioned, render queue interface.

00:44:34.040 --> 00:44:37.540
Also, Shake's widget toolkit
is open to developers,

00:44:37.540 --> 00:44:42.660
so let's say you want to create custom
dialogues and custom parameter widgets,

00:44:42.660 --> 00:44:43.880
you can do that.

00:44:44.540 --> 00:44:47.230
And we've also got custom file
format readers and writers.

00:44:47.260 --> 00:44:50.560
So let's say you've got
a custom file format,

00:44:50.610 --> 00:44:53.500
you need to get it into Shake,
you can actually write something

00:44:53.500 --> 00:44:55.580
that's able to read that file format.

00:44:57.610 --> 00:45:01.450
Okay,
so let's just dig into image processing

00:45:01.470 --> 00:45:04.600
plug-ins and just focus in on this.

00:45:04.600 --> 00:45:10.690
One of the key things to understand
when developing an image processing

00:45:10.690 --> 00:45:14.100
plug-in in Shake is the image plug.

00:45:14.300 --> 00:45:16.300
So if we take a look
at this image up here,

00:45:16.300 --> 00:45:20.440
you'll see that we've generated
a color wheel and that image data

00:45:20.440 --> 00:45:22.460
is flowing down through the tree.

00:45:22.460 --> 00:45:26.770
And you'll see that there's a
connection made between the node

00:45:26.770 --> 00:45:30.640
that generates the color wheel
and then an image processing node.

00:45:30.640 --> 00:45:33.640
And the connection's indicated by
something in Shake called noodles.

00:45:33.640 --> 00:45:39.360
And actually what a noodle is,
is it's a connection, a plug connection.

00:45:39.360 --> 00:45:42.070
And it's the image plug.

00:45:42.080 --> 00:45:46.420
This is the thing that the image data
and the information associated with the

00:45:46.420 --> 00:45:51.240
image data moves from one processing node
in Shake to the next processing node.

00:45:51.240 --> 00:45:55.360
That is the primary connection between
image processing nodes in Shake.

00:45:55.380 --> 00:45:56.660
It's the image plug.

00:46:00.970 --> 00:46:05.320
And one of the things that makes
the image plug a little bit

00:46:05.320 --> 00:46:09.560
tougher to sort of get a handle
on is that it's a composite plug.

00:46:09.560 --> 00:46:16.700
It actually has 16 children plugs,
and 10 of those children plugs carry

00:46:16.700 --> 00:46:21.330
data down the processing tree in Shake,
and 6 of those plugs actually

00:46:21.510 --> 00:46:23.960
carry data up the processing tree.

00:46:23.960 --> 00:46:27.290
So there's some information, you know,
let's say you've got a node,

00:46:27.290 --> 00:46:30.240
let me go back a little bit,
let me see what the

00:46:30.300 --> 00:46:32.250
next slide looks like.

00:46:32.250 --> 00:46:32.250
Okay, let's go back.

00:46:33.690 --> 00:46:38.110
So there's a certain amount of
information in SHAKE that is defined

00:46:38.200 --> 00:46:40.480
by what we'll call a leaf node.

00:46:40.480 --> 00:46:43.610
It's a node right at the
top of the processing tree.

00:46:43.610 --> 00:46:46.170
And that information will flow down.

00:46:46.170 --> 00:46:51.150
But there's also information that
will be defined at the bottom of the

00:46:51.160 --> 00:46:53.790
processing tree that will flow up.

00:46:53.790 --> 00:46:57.100
Basically some information,
I'll cover it,

00:46:57.100 --> 00:47:01.230
but you can imagine that in terms of
what time do you want the image data.

00:47:01.280 --> 00:47:04.940
Well, that's defined by something
near the bottom of the tree.

00:47:04.940 --> 00:47:07.610
But in terms of what
size the image data is,

00:47:07.620 --> 00:47:11.360
that's something defined by something
near the top of the processing tree.

00:47:11.360 --> 00:47:15.210
So there's this flow of information
both up and down the processing tree

00:47:15.430 --> 00:47:18.200
that as a plug-in you've got to track.

00:47:20.420 --> 00:47:22.300
Okay.

00:47:22.300 --> 00:47:26.480
Now, this is a chart that I'm not gonna
go into a huge amount of time

00:47:26.480 --> 00:47:28.970
going through each of the items,
because when you develop, you know,

00:47:28.970 --> 00:47:30.970
when you start working
with Shake Plugins,

00:47:30.970 --> 00:47:33.480
you'll get all this information.

00:47:33.480 --> 00:47:38.250
But these are the 10 plugs,
or child plugs, that carry information

00:47:38.250 --> 00:47:39.950
down the processing tree.

00:47:39.950 --> 00:47:43.700
So the information that flows down,
the width and height of the image,

00:47:43.760 --> 00:47:44.550
that flows down.

00:47:44.590 --> 00:47:46.970
The bit depth of the image,
that flows down the tree.

00:47:46.970 --> 00:47:49.820
The domain of definition,
which is that bounding box that

00:47:49.890 --> 00:47:53.490
tells us where valid pixel data is,
that flows down the tree.

00:47:53.600 --> 00:47:55.470
Let me see.

00:47:55.480 --> 00:47:58.890
I better click again.

00:47:58.890 --> 00:47:58.890
Some of these

00:47:59.350 --> 00:48:03.650
The active color channels.

00:48:03.710 --> 00:48:04.890
That's another very important one.

00:48:04.900 --> 00:48:08.330
One of the things that Shake can do,
or that plug-ins and Shake can do,

00:48:08.330 --> 00:48:11.780
is they can say, guess what,
I've only got valid image

00:48:11.780 --> 00:48:13.540
data or luminance data.

00:48:13.540 --> 00:48:16.580
I've only got valid image data
and luminance and alpha channels.

00:48:16.960 --> 00:48:19.550
And that information
propagates down the tree,

00:48:19.550 --> 00:48:22.650
and that means that plug-ins
can limit their processing to

00:48:22.650 --> 00:48:24.660
only the active color channels.

00:48:24.660 --> 00:48:26.560
It might only have RGB and not alpha.

00:48:26.560 --> 00:48:31.070
As you guys are probably well aware,
the kind of image data that can come

00:48:31.120 --> 00:48:35.320
in and the channels that are being
processed can change quite a bit,

00:48:35.500 --> 00:48:39.450
and it's a big efficiency gain
for a plug-in if it only processes

00:48:39.450 --> 00:48:41.630
the active color channels.

00:48:41.660 --> 00:48:44.280
The background pixel
we discussed earlier,

00:48:44.280 --> 00:48:46.280
that's the color of the canvas.

00:48:47.020 --> 00:48:50.570
You can attach some blind data
and pass it down the tree,

00:48:50.570 --> 00:48:54.310
which is really cool,
because let's say you're an input

00:48:54.310 --> 00:48:58.550
node and you've opened up a data file,
and that data file or that image

00:48:58.550 --> 00:49:02.200
file has some metadata that you're
going to want further down the tree.

00:49:02.200 --> 00:49:04.180
Well,
you can take that metadata and you can

00:49:04.410 --> 00:49:07.670
store it all in the blind data plug,
and that'll be passed down the tree,

00:49:07.670 --> 00:49:11.580
and then a node further down the tree can
actually retrieve that data and use it.

00:49:11.640 --> 00:49:13.540
The time range is
something that flows down,

00:49:13.550 --> 00:49:16.940
because an input node usually knows that
it's going to be passed down the tree.

00:49:16.940 --> 00:49:21.230
It knows, okay,
I'm opening up 100 frames of data,

00:49:21.230 --> 00:49:23.920
so it can set the valid time range.

00:49:23.920 --> 00:49:26.850
And the key thing,
the image buffer itself,

00:49:26.860 --> 00:49:30.840
we call it the O-buff,
and that gets passed down the tree.

00:49:30.840 --> 00:49:35.050
So you'll actually retrieve that O-buff,
which comes in from the node above you,

00:49:35.060 --> 00:49:38.330
and that's processed image data,
meaning it's been processed

00:49:38.330 --> 00:49:39.720
by the node above you.

00:49:39.720 --> 00:49:42.550
You bring it in, you do your processing,
and then you pass it

00:49:42.650 --> 00:49:43.900
to the node below you.

00:49:46.700 --> 00:51:31.500
[Transcript missing]

00:51:32.710 --> 00:51:35.900
So the final one is the iBuff.

00:51:35.900 --> 00:51:39.600
And actually what happens in Shake in
the processing tree is that the node

00:51:39.600 --> 00:51:43.640
at the bottom of the tree actually
ends up allocating the image buffer.

00:51:43.640 --> 00:51:47.200
So because the node at the bottom of
the tree knows the region of interest,

00:51:47.200 --> 00:51:49.980
it knows how much pixel data
the user wants to look at,

00:51:50.080 --> 00:51:51.540
it allocates the buffer.

00:51:51.540 --> 00:51:54.950
That buffer then is passed all
the way up to the top leaf node,

00:51:54.950 --> 00:51:58.220
and it gets to the top leaf node,
and then the top leaf node

00:51:58.220 --> 00:52:01.990
starts filling in pixel values,
passes it to the node below it.

00:52:02.520 --> 00:52:04.550
He does his processing,
and then it goes like that.

00:52:04.600 --> 00:52:08.050
So you can sort of get this image
in your head or in your mind of

00:52:08.050 --> 00:52:11.600
an image buffer being allocated
at the bottom of the tree,

00:52:11.600 --> 00:52:14.260
being passed all the way
up to the top leaf node,

00:52:14.260 --> 00:52:17.350
and then the top leaf node
fills in pixel values,

00:52:17.350 --> 00:52:19.880
and then it goes back down
to the processing tree.

00:52:23.840 --> 00:52:27.850
So the next two slides,
if you're developing

00:52:27.850 --> 00:52:31.630
image processing plugins,
the next two slides are worth

00:52:31.630 --> 00:52:35.390
just looking at because as the
SDK engineer and support guy,

00:52:35.530 --> 00:52:39.560
I get more questions from this
aspect of plugin development,

00:52:39.560 --> 00:52:42.300
image processing plugin development,
than any other.

00:52:42.310 --> 00:52:45.660
And that is the fact that you've
got an input image plugged to

00:52:45.660 --> 00:52:48.860
your node and you've got an
output image plugged to your node.

00:52:48.860 --> 00:52:54.280
And tracking the polarity
of the child plugs is key.

00:52:54.280 --> 00:52:57.270
Once you get this slide,
these kind of plugins, very,

00:52:57.290 --> 00:52:59.340
very easy to do.

00:52:59.340 --> 00:53:03.210
So okay,
let's look at the top of the node.

00:53:03.220 --> 00:53:06.790
At the top of the node,
I've got image data coming into me.

00:53:06.800 --> 00:53:11.100
Well, those ten downstream plugs
are now inputs to my node.

00:53:11.100 --> 00:53:13.460
It's the data flowing into my node.

00:53:13.460 --> 00:53:19.020
And we know from dependency graph
concepts that Shake-Only asks us

00:53:19.020 --> 00:53:23.320
for the output values from our node,
the output plug values.

00:53:23.320 --> 00:53:29.160
So all the child plugs
that are green in here,

00:53:29.170 --> 00:53:31.370
Shake isn't gonna ask you for
those because they're inputs.

00:53:31.440 --> 00:53:35.060
Those are values that you take
into your node and you use those

00:53:35.060 --> 00:53:37.580
values to compute some value.

00:53:37.580 --> 00:53:42.360
So you can see in the input image plug,
it's actually the data flowing up the

00:53:42.460 --> 00:53:45.540
tree that are the outputs to your node.

00:53:45.550 --> 00:53:50.500
So if you wanna change the
ROI or the region of interest,

00:53:50.510 --> 00:53:53.580
then that's something that's
gonna flow up the tree.

00:53:53.640 --> 00:53:55.520
Shake will ask you for that.

00:53:55.520 --> 00:53:58.640
Let's go down and take a look
at the output image plug.

00:53:58.670 --> 00:54:02.520
The polarity's flipped now cuz it's
now an output plug to the node.

00:54:02.520 --> 00:54:05.720
And you can see that all of
the downstream quantities

00:54:05.720 --> 00:54:07.100
are now outputs to the node.

00:54:07.100 --> 00:54:10.090
So anything associated with the width,
the bytes, the DOD,

00:54:10.130 --> 00:54:13.430
the active color channels,
Shake can potentially be asking

00:54:13.430 --> 00:54:16.780
you for that information cuz
it's outputs to your node.

00:54:16.780 --> 00:54:20.230
And you'll see that the information
flowing up the dependency graph

00:54:20.230 --> 00:54:25.280
or up the processing tree,
the current time, the region of interest,

00:54:25.330 --> 00:54:27.050
etc., those are inputs to your node.

00:54:27.100 --> 00:54:30.830
So Shake won't ask you
for those on that plug.

00:54:33.230 --> 00:54:36.220
So how do you actually
do image processing?

00:54:36.220 --> 00:54:40.490
Like how do you implement your
image processing algorithm?

00:54:40.500 --> 00:54:45.760
Well, a lot of the time, let's face it,
you're not going to change those values.

00:54:45.760 --> 00:54:47.870
Like for instance,
a lot of times you're not going to

00:54:47.870 --> 00:54:49.620
change the width and height of the image.

00:54:49.620 --> 00:54:51.770
I mean, you're going to stick with
the same width and height.

00:54:51.970 --> 00:54:56.150
So all you need to do is you
need to take the output plugs.

00:54:56.270 --> 00:54:58.950
So these are the output plugs to my node.

00:54:58.960 --> 00:55:00.170
I don't want to change them.

00:55:00.180 --> 00:55:03.400
I don't want to change the width,
the height, the bit of the DOD or the

00:55:03.410 --> 00:55:05.020
active color channels.

00:55:05.100 --> 00:55:07.860
So I simply connect them to the inputs.

00:55:07.890 --> 00:55:11.140
And once I form that
connection between the inputs,

00:55:11.180 --> 00:55:14.100
those input values,
and the output values,

00:55:14.160 --> 00:55:15.900
Shake won't call me
for the output values.

00:55:15.970 --> 00:55:18.300
Because it'll look, it'll say,
how do I get that value?

00:55:18.390 --> 00:55:21.560
And it realizes that it can just
go up through a connection tree and

00:55:21.600 --> 00:55:23.960
retrieve that value somewhere else.

00:55:23.960 --> 00:55:26.530
So that means that you
might have thought,

00:55:26.560 --> 00:55:30.460
oh, crap, I've got 16 plugs I might have
to evaluate and do all the

00:55:30.460 --> 00:55:31.720
bookkeeping on in my node.

00:55:31.800 --> 00:55:33.360
Well, actually you don't.

00:55:33.360 --> 00:55:34.620
Most of the time,
you've only got a couple

00:55:34.660 --> 00:55:37.100
plugs that you're actually
going to change the values of.

00:55:37.120 --> 00:55:39.770
So you leave the others connected
so that that data just flows

00:55:39.770 --> 00:55:41.300
straight through your node.

00:55:41.340 --> 00:55:44.820
So you can see the data moving
down the processing tree,

00:55:44.890 --> 00:55:46.500
flow straight through your node.

00:55:46.500 --> 00:55:49.920
And the data going up the processing
tree flow straight through your node.

00:55:49.920 --> 00:55:52.300
Two key ones you've got to cut, though.

00:55:52.300 --> 00:55:55.200
The first one is the O buff.

00:55:55.200 --> 00:56:00.240
You're going to be doing some kind
of processing on the buffer itself.

00:56:00.240 --> 00:56:04.740
So you need to get that buffer of
pixels from the node above you,

00:56:04.740 --> 00:56:07.650
implement your algorithm,
modify their values,

00:56:07.650 --> 00:56:10.780
and take that pointer to the buffer
and put it into the output O buff.

00:56:10.780 --> 00:56:13.290
So you're always going to do, oops.

00:56:13.600 --> 00:56:16.120
So you're always going to do this.

00:56:16.200 --> 00:56:18.790
You're always going to snip
the connection between the

00:56:18.790 --> 00:56:20.730
incoming obuf and the out obuf.

00:56:20.730 --> 00:56:23.120
The other one is this cache ID.

00:56:23.120 --> 00:56:30.050
Shake has a very sophisticated caching
system so that it'll make up its mind

00:56:30.120 --> 00:56:32.080
to cache some of your image data.

00:56:32.080 --> 00:56:34.980
So that, let's say you've got
a node that does some,

00:56:35.110 --> 00:56:38.770
like an FFT, some expensive computation
to produce an image.

00:56:38.770 --> 00:56:41.410
Well, Shake can,
under certain circumstances,

00:56:41.490 --> 00:56:43.220
cache your output image data.

00:56:43.500 --> 00:56:47.810
And if it decides that all of your inputs
haven't changed at all since the last

00:56:47.810 --> 00:56:51.000
time that it cached your image data,
when your node is requested

00:56:51.000 --> 00:56:53.760
to process image data,
it'll just use the cache value.

00:56:53.760 --> 00:56:58.080
The cache ID is actually,
it's simply a string that's used to

00:56:58.080 --> 00:57:01.220
track the up-to-date state of your node.

00:57:01.220 --> 00:57:04.410
Basically, the cache ID is the thing that
enables Shake to determine,

00:57:04.420 --> 00:57:07.240
has anything changed since
I last cached your image data?

00:57:07.240 --> 00:57:12.280
If it hasn't, Shake will reuse image
data that it's caching.

00:57:12.340 --> 00:57:13.480
You won't get called to process.

00:57:13.500 --> 00:57:16.020
and that's a big efficiency gain.

00:57:16.600 --> 00:57:19.900
So, as you can imagine,
Shake's a very deep,

00:57:19.900 --> 00:57:22.280
sophisticated application.

00:57:22.280 --> 00:57:26.240
There are a lot of base classes that
we've defined that are dedicated to doing

00:57:26.240 --> 00:57:28.450
different kinds of image processing.

00:57:28.460 --> 00:57:31.940
Sort of the parent,
the mother of all image

00:57:31.940 --> 00:57:37.150
processing base classes,
you'll find out is we call it NRIFX.

00:57:37.200 --> 00:57:41.000
All it does is simply
define an output image plug.

00:57:41.000 --> 00:57:43.350
And you can understand that
that's the most basic thing that

00:57:43.380 --> 00:57:46.110
an image processing node can do,
is generate some image data.

00:57:46.490 --> 00:57:48.500
Not even worry about
taking any image data in,

00:57:48.500 --> 00:57:50.190
just simply generate an image.

00:57:50.200 --> 00:57:53.350
And so the NRIFX base class,
which is the mother of all

00:57:53.350 --> 00:57:57.000
image processing base classes,
provides that functionality.

00:57:57.000 --> 00:58:00.720
And at this point, what I wanted to do,
since we've got just a

00:58:00.790 --> 00:58:04.820
little over 12 minutes left,
is I can keep going and review

00:58:04.830 --> 00:58:08.380
some of the additional image
processing base classes,

00:58:08.380 --> 00:58:12.780
so that as a developer, you'll say, oh,
I'm developing this kind of node.

00:58:12.780 --> 00:58:15.950
That's the base class I want to
start deriving my class from.

00:58:16.490 --> 00:58:18.440
Or would you like me to open up to Q&A?

00:58:18.440 --> 00:58:21.000
Because we've got 10, 12 minutes.

00:58:21.000 --> 00:58:22.880
If you guys have questions,
I can spend the time

00:58:22.880 --> 00:58:24.120
answering your questions.

00:58:24.120 --> 00:58:25.550
So any vote, yay or nay?

00:58:25.560 --> 00:58:27.720
Keep going.

00:58:27.720 --> 00:58:28.910
Keep going.

00:58:31.030 --> 00:58:32.770
Okay, we'll keep going,
unless you've got questions.

00:58:32.780 --> 00:58:35.020
Stop me if you've got
questions at this point.

00:58:35.340 --> 00:58:35.600
Okay.

00:58:38.530 --> 00:58:39.400
Not yet.

00:58:39.770 --> 00:58:40.030
Yeah.

00:58:40.030 --> 00:58:41.230
Fair enough.

00:58:41.230 --> 00:58:45.310
I can answer that question
if you'd like right now.

00:58:46.550 --> 00:58:53.980
There are image processing base classes
in Shake that support concatenation.

00:58:53.980 --> 00:59:00.140
The concept of concatenation is,
imagine if you've got five image

00:59:00.140 --> 00:59:07.420
processing nodes that do transformations,
and all of those transformations

00:59:07.420 --> 00:59:11.350
use a 4x4 transformation matrix.

00:59:11.800 --> 00:59:17.180
Well, if you have all of those four nodes
basically stacked up together,

00:59:17.180 --> 00:59:20.750
Shake has logic that takes
each of the transformation

00:59:20.750 --> 00:59:24.530
matrices and concatenates them,
and basically takes what looks

00:59:24.530 --> 00:59:27.880
like four image processing
operations and concatenates them

00:59:27.880 --> 00:59:32.450
so they're actually executed as a
single image processing operation.

00:59:32.460 --> 00:59:35.340
This is done with lookup
table-based operators.

00:59:35.500 --> 00:59:39.090
Certain color-based image
processing nodes do support that.

00:59:44.530 --> 00:59:46.510
Just arrived from the right class.

00:59:46.700 --> 00:59:50.790
Yeah, so let me actually go through
the classes really quickly.

00:59:51.470 --> 00:59:54.380
So a very popular one is NRI Monadic.

00:59:54.380 --> 00:59:57.740
It takes a single input image and
produces a single output image.

00:59:57.740 --> 01:00:00.450
It doesn't cache image data, though.

01:00:00.550 --> 01:00:03.720
So if you've got a very expensive
image processing operation,

01:00:03.720 --> 01:00:08.210
look at the NRI Cmonadic base class,
because that actually has an

01:00:08.210 --> 01:00:12.040
internal node that actually
supports the caching of image data.

01:00:12.040 --> 01:00:14.380
Like we talked about
right at the beginning,

01:00:14.430 --> 01:00:17.940
nodes can have children nodes,
and if you derive from NRI Cmonadic,

01:00:17.940 --> 01:00:20.830
that is a node that supports
caching of image data.

01:00:21.400 --> 01:00:26.070
but it still takes a single input
image and a single output image.

01:00:26.500 --> 01:02:21.500
[Transcript missing]

01:02:21.840 --> 01:02:25.940
Some image processing nodes,
they know ahead of time that

01:02:26.000 --> 01:02:28.120
they want four input images.

01:02:28.120 --> 01:02:31.380
And that's never gonna change,
it's always gonna wanna

01:02:31.380 --> 01:02:33.580
work on four input images.

01:02:33.580 --> 01:02:36.960
You're gonna wanna derive from
the NRI an attic base class,

01:02:36.960 --> 01:02:40.320
so you can preset how many
input images there's gonna be.

01:02:40.320 --> 01:02:45.620
Shake will call you then with the
fill output buffer member function,

01:02:45.630 --> 01:02:47.850
it'll basically prep all
the input image buffers.

01:02:47.920 --> 01:02:51.480
They'll be there in an array for you so
you've got all your input image data.

01:02:51.480 --> 01:02:56.060
And this is a really popular base class,
because a lot of people like getting

01:02:56.210 --> 01:02:58.560
the full frame input image buffer.

01:02:58.560 --> 01:03:00.880
In this class,
you can set a flag and say,

01:03:00.880 --> 01:03:02.520
give me a full frame input image buffer.

01:03:02.610 --> 01:03:05.660
Guess what, my algorithm,
it's doing FFTs,

01:03:05.660 --> 01:03:07.640
I need the full frame image buffer.

01:03:07.640 --> 01:03:10.300
You can set a flag,
and with NRI and attic,

01:03:10.300 --> 01:03:12.410
it can work with one input,
just as well as it can

01:03:12.410 --> 01:03:13.500
work with ten inputs.

01:03:13.500 --> 01:03:17.180
So some people will just use NRI and
attic simply because they want,

01:03:17.180 --> 01:03:20.800
they love the full frame
image buffer functionality.

01:03:21.620 --> 01:03:25.380
If you're a generator node,
one of the things,

01:03:25.380 --> 01:03:30.240
if you want to generate an image,
you'll want to derive from

01:03:30.240 --> 01:03:33.190
the NRI input member function.

01:03:33.190 --> 01:03:35.050
The nice thing about
it is you might think,

01:03:35.050 --> 01:03:37.120
well,
I'll just start with NRI effects because

01:03:37.230 --> 01:03:38.810
it defines a single output image.

01:03:38.830 --> 01:03:44.290
But the things that you get for free
from NRI input is how to manage the

01:03:44.290 --> 01:03:47.740
valid time range and that sort of thing.

01:03:47.740 --> 01:03:51.930
So there's a lot of logic built in
there so that you can pass information

01:03:51.930 --> 01:03:55.590
down the tree about how to handle
once you're outside of a valid

01:03:55.670 --> 01:03:57.910
time range and that sort of thing.

01:03:58.920 --> 01:04:02.040
And let me just wrap up at this point.

01:04:02.040 --> 01:04:05.040
We've got a little bit,
we've got some more information.

01:04:05.370 --> 01:04:10.320
Documentation,
sample code and other resources,

01:04:10.320 --> 01:04:14.590
the WWDC website is
one good place to look.

01:04:14.820 --> 01:04:15.520
Who to contact?

01:04:15.770 --> 01:04:20.470
Patrick Collins is the track manager,
so you'll want to,

01:04:20.470 --> 01:04:25.060
and technology manager,
you'll want to contact him.

01:04:25.060 --> 01:04:27.590
And also myself, angus at apple.com.

01:04:28.550 --> 01:04:32.640
And actually, you know,
an address that I want to give you

01:04:32.640 --> 01:04:37.610
guys is shake-sdk at apple.com.

01:04:37.610 --> 01:04:40.530
If you're interested in getting
a hold of the SDK package,

01:04:40.530 --> 01:04:45.160
drop us a line there so that
we can start talking to you.
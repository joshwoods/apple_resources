WEBVTT

00:00:10.810 --> 00:00:16.140
My name is Christopher Linn and
I work in the Core Services group

00:00:16.140 --> 00:00:21.360
at Apple Software Engineering and
especially on Uniform Type Identifiers

00:00:21.360 --> 00:00:23.100
and I also work on Launch Services.

00:00:23.370 --> 00:00:27.980
This session is actually almost all
Uniform Type Identifiers with a little

00:00:27.980 --> 00:00:30.450
bit about Launch Services in it.

00:00:30.560 --> 00:00:33.360
Since that's what I know,
that's what I'm going to

00:00:33.490 --> 00:00:36.160
talk about in my session.

00:00:37.880 --> 00:00:44.260
Let me just give a quick overview of what
we are going to do during the next hour.

00:00:44.260 --> 00:00:46.740
In the form of several
questions that I hope to answer.

00:00:46.800 --> 00:00:49.320
I presume that,
I am making a presumption that

00:00:49.320 --> 00:00:52.560
I can answer the question,
why are you here?

00:00:52.560 --> 00:00:56.030
And I will give you several reasons
and that may answer some other

00:00:56.150 --> 00:01:01.280
why are you here questions for you
that you may have been aware of.

00:01:01.280 --> 00:01:04.510
And we'll go through,
kind of the design background

00:01:04.510 --> 00:01:06.590
of uniform type identifiers.

00:01:06.600 --> 00:01:10.400
And then go into some more
practicalities of how they are used

00:01:10.400 --> 00:01:14.720
on Tiger and how you can use them
to make your applications better.

00:01:15.850 --> 00:01:17.770
So, why are you here?

00:01:18.070 --> 00:01:22.270
And I don't mean that in
the life-affirming answer

00:01:22.290 --> 00:01:25.840
to everything question,
but why are you in this room right now?

00:01:25.840 --> 00:01:29.360
One reason is that you want
to know about uniform type

00:01:29.360 --> 00:01:31.940
identifiers because of Spotlight.

00:01:31.940 --> 00:01:35.340
If you've been to any of the
Spotlight sessions earlier today,

00:01:35.340 --> 00:01:41.090
you found out that uniform type
identifiers end up being used heavily

00:01:41.220 --> 00:01:48.360
to categorize importers and search
results in the Spotlight framework.

00:01:48.360 --> 00:01:51.980
So for example, if you look at the--

00:01:53.600 --> 00:03:25.800
[Transcript missing]

00:03:26.610 --> 00:03:32.000
compatible actions being
hooked up in the workflow.

00:03:32.150 --> 00:03:38.140
Some other areas in TIGR are core image,
several places in the Carbon API,

00:03:38.180 --> 00:03:41.810
such as Pasteboard, Translation,
Navigation,

00:03:41.810 --> 00:03:49.480
as well as Launch Services itself using
uniform type identifiers for working

00:03:49.550 --> 00:03:55.400
with file system objects and modeling
things like document binding preferences.

00:03:55.540 --> 00:04:01.140
So these are all areas that uniform
type identifiers are now used in 10.4.

00:04:01.140 --> 00:04:04.380
They were introduced in 10.3,
but used very sparingly

00:04:04.380 --> 00:04:08.380
just in one specific area,
the Carbon Pasteboard.

00:04:08.380 --> 00:04:13.000
But it's much more of
a foundation in 10.4,

00:04:13.050 --> 00:04:17.680
and I hope that you'll see that it's
a very useful thing to understand

00:04:17.680 --> 00:04:20.510
and a very powerful concept.

00:04:21.610 --> 00:04:25.260
Let's just look back at the things I've
mentioned and see how they're layered.

00:04:25.420 --> 00:04:30.300
Uniform Type Identifiers are very closely
related to the Launch Services database.

00:04:30.300 --> 00:04:34.340
It's actually implemented
as part of Launch Services.

00:04:34.510 --> 00:04:39.030
And then the higher levels of
Launch Services itself is a client

00:04:39.270 --> 00:04:43.190
to the UTI API and database.

00:04:44.340 --> 00:04:49.470
And then some of the other
things we've talked about:

00:04:49.610 --> 00:04:56.840
Spotlight, pieces of Carbon,
the Core Image Framework sit above that

00:04:56.840 --> 00:05:03.170
and make use of Launch Services and
Uniform Type Identifiers.

00:05:03.740 --> 00:05:06.080
And then various applications
including perhaps your application

00:05:06.080 --> 00:05:06.080
are clients of this technology.

00:05:08.700 --> 00:05:11.990
So let me give a design
overview and then later on,

00:05:11.990 --> 00:05:15.300
as I said,
we'll get into some more coding examples

00:05:15.300 --> 00:05:18.190
and practicalities of using the API.

00:05:18.620 --> 00:05:21.310
What do I mean by type identification?

00:05:21.630 --> 00:05:25.920
Which is the term I'm going to
be talking about quite a bit.

00:05:26.160 --> 00:05:33.300
It's a very general term and that makes
it a little bit hard to get a handle on.

00:05:33.450 --> 00:05:39.110
So I brought up Dashboard in
the Thesaurus to get some ideas.

00:05:39.610 --> 00:05:43.740
And it says some words in
the Thesaurus like Variety,

00:05:43.740 --> 00:05:45.530
Class, Category.

00:05:45.620 --> 00:05:48.920
Category I think is probably
the best synonym in this case.

00:05:49.090 --> 00:05:55.990
It's a way of categorizing the objects
that we work with on our computers.

00:05:58.700 --> 00:06:00.600
So what kinds of things
are we talking about?

00:06:00.600 --> 00:06:04.420
What kinds of objects do we
want to categorize and identify?

00:06:04.420 --> 00:06:08.230
Basically, it's things that the
user is working with,

00:06:08.540 --> 00:06:10.530
and therefore,
they arrive at the doorstep

00:06:10.530 --> 00:06:12.720
of your application,
and you've got to be able

00:06:12.840 --> 00:06:14.120
to know what they are.

00:06:14.160 --> 00:06:16.480
So of course,
it includes file system objects.

00:06:16.480 --> 00:06:20.440
But I didn't call it file
system type identification.

00:06:20.440 --> 00:06:22.880
I didn't call it data
type identification.

00:06:22.880 --> 00:06:26.600
It's just type identification,
because files, folders, volumes,

00:06:26.600 --> 00:06:31.320
that's one of the things we can
deal with using this technology.

00:06:31.320 --> 00:06:33.660
There's also Pasteboard.

00:06:33.660 --> 00:06:38.120
Not only does the Carbon Pasteboard API,
the modern one, the new one,

00:06:38.280 --> 00:06:41.530
introduced on 10.3,
not only is it based on UTIs,

00:06:41.530 --> 00:06:44.990
but actually,
the internal Pasteboard that goes between

00:06:44.990 --> 00:06:48.280
Carbon and Cocoa apps is based on UTIs.

00:06:48.280 --> 00:06:51.930
And we use this technology to be
able to map between the namespaces

00:06:51.930 --> 00:06:54.340
of those two different Pasteboards.

00:06:55.010 --> 00:06:58.550
as well as the old Carbon Scrap API.

00:06:58.800 --> 00:07:02.480
We can also identify the types of things
that aren't necessarily really living

00:07:02.550 --> 00:07:06.410
in the file system such as contacts,
people, information from address book,

00:07:06.590 --> 00:07:08.740
email messages, calendar events.

00:07:08.810 --> 00:07:16.210
All these things are searchable
by Spotlight and can be identified

00:07:16.210 --> 00:07:16.210
by UniForm Type Identifiers.

00:07:16.620 --> 00:07:20.140
And finally,
we can work with data arriving

00:07:20.290 --> 00:07:23.600
over the Internet that,
for instance,

00:07:23.600 --> 00:07:28.900
might be identified by a MIME type,
and we want to be able to link

00:07:28.930 --> 00:07:33.330
that back to data of the same type,
save it to the file system,

00:07:33.330 --> 00:07:35.260
and have the correct extension.

00:07:35.260 --> 00:07:38.510
For instance, UTIs can help with that.

00:07:40.430 --> 00:07:47.340
So I wanted to look at the grand arc
of history of type identification.

00:07:47.380 --> 00:07:51.940
And in the beginning,
there was the file extension.

00:07:52.070 --> 00:07:55.080
How he hates it.

00:07:55.820 --> 00:08:02.090
But there's really not a whole lot we can
do to get rid of file extensions because

00:08:02.090 --> 00:08:07.740
they're everywhere and they're used on
other platforms a lot and we've embraced

00:08:07.740 --> 00:08:10.320
them on Mac OS X because we have to.

00:08:10.320 --> 00:08:13.700
We have to interoperate
with other platforms.

00:08:13.700 --> 00:08:17.210
And of course,
the problem with file name extensions is,

00:08:17.390 --> 00:08:18.840
well, they're in the name.

00:08:18.840 --> 00:08:19.960
We all hate that.

00:08:19.970 --> 00:08:23.670
They're generally not very helpful,
not very explanatory.

00:08:23.670 --> 00:08:27.130
So even though they're in the name,
you've got to be sort of an

00:08:27.130 --> 00:08:29.010
expert to know what they mean.

00:08:29.010 --> 00:08:30.810
And they're just a free for all.

00:08:30.860 --> 00:08:33.510
There's lots of -- there can
be collisions and redundancy.

00:08:33.740 --> 00:08:38.260
So along came the Mac and
Apple introduced the OS type

00:08:38.260 --> 00:08:40.540
four character codes.

00:08:40.540 --> 00:08:47.190
And this at least isn't in the name,
but there still can be collisions

00:08:47.190 --> 00:08:52.630
and they're not -- text is a great
one because it's easy to understand,

00:08:52.750 --> 00:08:54.480
but most actual OS types aren't.

00:08:54.480 --> 00:08:56.880
They're not very verbose,
not very explanatory.

00:08:56.990 --> 00:08:59.400
If you look at the code,
you don't -- as a developer,

00:08:59.400 --> 00:09:02.870
you really don't know anything
about it just looking at it.

00:09:04.160 --> 00:09:08.700
And then in the 90s
along came mime types.

00:09:08.700 --> 00:09:11.120
And this was interesting
because you start to see,

00:09:11.180 --> 00:09:13.030
first of all, it's a lot more verbose.

00:09:13.220 --> 00:09:14.660
It's kind of plain English.

00:09:14.680 --> 00:09:17.240
You can understand a lot
about what that means.

00:09:17.430 --> 00:09:21.770
And it starts to kind of get at
the idea of types are kind of,

00:09:21.820 --> 00:09:26.500
they kind of have an organization and
relationships that-- there's text types,

00:09:26.500 --> 00:09:29.820
and there's audio types, and video types.

00:09:29.850 --> 00:09:33.260
And this was a good idea.

00:09:33.300 --> 00:09:36.880
And the hierarchy, however,
is very fixed and encoded

00:09:36.880 --> 00:09:37.660
as part of the name.

00:09:37.770 --> 00:09:39.880
So it can never change or evolve.

00:09:39.980 --> 00:09:45.860
And pretty much what we ended up with
mime types is the application type

00:09:46.140 --> 00:09:48.940
ends up being kind of a dumping ground.

00:09:48.940 --> 00:09:50.830
And even worse than that,
even though there's a

00:09:50.900 --> 00:09:55.700
bureaucracy for registering
mime types to avoid collisions,

00:09:55.710 --> 00:09:59.700
in fact, there's a zillion mime types
out there that begin with x-dash

00:09:59.820 --> 00:10:02.390
as the experimental namespace.

00:10:02.470 --> 00:10:04.560
And that just kind of
sticks for all time.

00:10:04.640 --> 00:10:08.720
So mime types aren't really the answer,
the ultimate answer,

00:10:08.760 --> 00:10:12.840
to type identification
because of these problems.

00:10:12.840 --> 00:10:15.370
And there's also,
as I have discovered working with

00:10:15.380 --> 00:10:17.350
this over the past couple of years,
there's a lot of

00:10:17.350 --> 00:10:18.560
redundancy in mime types.

00:10:18.560 --> 00:10:19.510
There's the x-dash.

00:10:19.640 --> 00:10:23.580
There's the non-x-dash
version of a given mime type.

00:10:23.580 --> 00:10:28.130
And they're all sort of synonyms
for the same actual data type.

00:10:28.490 --> 00:10:34.250
So we needed something to not only to be
better than this but to also interoperate

00:10:34.260 --> 00:10:38.900
with all of this type identification
that was just sort of a big mess.

00:10:38.940 --> 00:10:43.630
And so we came up with
Uniform Type Identifiers.

00:10:43.920 --> 00:10:47.380
These are the key points about
what a Uniform Type Identifier is.

00:10:47.500 --> 00:10:50.400
First of all, it's just a string and it
has a naming convention.

00:10:50.400 --> 00:10:54.160
We reuse, again,
as we do in other places on the system,

00:10:54.510 --> 00:10:56.780
the reverse DNS naming scheme.

00:10:56.800 --> 00:10:59.900
And we do this solely to--well,
not solely,

00:10:59.900 --> 00:11:02.800
but primarily to prevent collisions.

00:11:02.850 --> 00:11:05.460
Now there's like a really,
really good chance that if

00:11:05.630 --> 00:11:09.800
you declare your own UTI,
Uniform Type Identifier,

00:11:09.800 --> 00:11:13.610
it's not gonna collide with
somebody else's name because it has

00:11:13.610 --> 00:11:15.740
your company's name as a prefix.

00:11:15.820 --> 00:11:19.800
It also is handy because it says
who the owner of the type is.

00:11:19.800 --> 00:11:25.800
You know, looking at a UTI that--oh,
maybe you can contact somebody at

00:11:25.800 --> 00:11:31.660
a particular company or at Apple to
find out about a particular UTI.

00:11:32.340 --> 00:11:37.990
This allows us to make the system
freely extensible by third parties,

00:11:37.990 --> 00:11:41.240
by everyone, all of you,
without any central registration

00:11:41.240 --> 00:11:44.200
bureaucracy because of
the collision avoidance.

00:11:44.480 --> 00:11:50.810
There's also sort of a gestalt of
using verbose names because when you

00:11:51.100 --> 00:11:56.360
have a nice long string like that,
it's really easy for a developer to

00:11:56.360 --> 00:11:58.200
look at that and understand what it is.

00:11:58.200 --> 00:12:00.800
It's very descriptive.

00:12:03.200 --> 00:12:11.300
[Transcript missing]

00:12:11.460 --> 00:12:16.250
UTIs are an improvement over
other type identification systems,

00:12:16.270 --> 00:12:17.140
we think.

00:12:17.140 --> 00:12:23.690
But beyond being a string,
we've added a whole collection of

00:12:23.770 --> 00:12:30.340
information associated with types
that I call type representation.

00:12:30.370 --> 00:12:33.530
There's the idea of a type identifier,
but then there's also an

00:12:34.000 --> 00:12:35.740
abstract notion of a type.

00:12:36.000 --> 00:12:37.300
What is a type?

00:12:37.340 --> 00:12:42.830
And I think of it as the association
between a unique identifier,

00:12:42.830 --> 00:12:46.690
the UTI, and a bunch of properties
that describe the type.

00:12:46.980 --> 00:12:55.280
So in the framework, given a UTI,
you can ask for various attributes,

00:12:55.700 --> 00:12:59.140
such as the description,
which is a localized string.

00:12:59.140 --> 00:13:01.320
So it's a human-readable description.

00:13:01.320 --> 00:13:06.360
You can associate an iconic image,
an icon, with a particular type.

00:13:06.420 --> 00:13:10.150
And then you can also have
any number of other mappings,

00:13:10.150 --> 00:13:15.040
or tags as we call them, to other spaces,
such as extensions, MIME types,

00:13:15.040 --> 00:13:16.560
and OS types.

00:13:16.560 --> 00:13:20.790
And this is really powerful because
it allows you to abstract your app

00:13:20.880 --> 00:13:26.760
away from having to know that there's
two different MIME types for MP3,

00:13:26.760 --> 00:13:32.400
and there's two different OS types,
and you don't know which one to use.

00:13:32.400 --> 00:13:35.240
And you don't want to have to keep
track of mapping all of those back

00:13:35.400 --> 00:13:37.900
to a canonical type identifier.

00:13:37.900 --> 00:13:42.140
And by associating all this
information right in the API,

00:13:42.140 --> 00:13:45.640
it allows you to work at a
higher level in your application

00:13:45.640 --> 00:13:48.940
by just thinking about,
OK, I'm working with MP3s,

00:13:48.940 --> 00:13:52.100
and the system is going to help
me with all of the metadata that

00:13:52.100 --> 00:13:55.390
is associated with the MP3 type.

00:13:55.890 --> 00:13:56.780
But we didn't stop there.

00:13:56.840 --> 00:14:00.230
We also wanted to formalize
this notion of a hierarchy.

00:14:00.730 --> 00:14:06.800
And there's a bunch of ways in
which a hierarchy is pretty useful.

00:14:06.800 --> 00:14:08.300
But let me just give an example.

00:14:08.300 --> 00:14:11.780
The terminology we use is conformance.

00:14:11.810 --> 00:14:16.450
We say that one type
conforms to a supertype.

00:14:16.580 --> 00:14:22.150
So for instance, mp3 conforms to audio.

00:14:22.300 --> 00:14:26.890
By the way, I didn't mention earlier the
public prefix is a special prefix

00:14:27.050 --> 00:14:31.320
reserved by Apple for essentially
types that aren't owned by Apple.

00:14:31.560 --> 00:14:34.520
They're more in the public domain,
if you will.

00:14:34.520 --> 00:14:38.520
And so that's why you're seeing all
these strings that begin with public.

00:14:38.620 --> 00:14:42.510
And that's just to unicify them.

00:14:42.770 --> 00:14:46.190
Anyway, MP3 conforms to generic audio.

00:14:46.190 --> 00:14:51.220
It's a kind of audio which in turn
conforms to audio-visual content.

00:14:51.220 --> 00:14:54.140
And as you'll see later,
audio-visual content includes

00:14:54.140 --> 00:14:55.700
other things like movies.

00:14:55.890 --> 00:15:00.060
And then it gets even more generic
that there's something called

00:15:00.060 --> 00:15:04.330
public.content which covers
all sort of document content,

00:15:04.350 --> 00:15:05.480
if you will.

00:15:05.930 --> 00:15:12.370
So this is just an introduction to
conformance and we'll now go into more

00:15:12.370 --> 00:15:18.680
of the actual details of how a hierarchy,
how our hierarchy is organized.

00:15:18.720 --> 00:15:22.750
And actually I'm going to go back and
say one more word about conformance.

00:15:23.310 --> 00:15:28.090
Conformance, it's a little bit hard to
grasp the significance of it,

00:15:28.090 --> 00:15:34.050
but it ends up being the most important
part of this technology because it

00:15:34.050 --> 00:15:40.290
allows you to essentially with other
type systems you do string compares.

00:15:40.600 --> 00:15:42.420
You're basically testing for equality.

00:15:42.620 --> 00:15:45.250
Is this type something I understand?

00:15:45.290 --> 00:15:48.390
So you compare a string that
comes in from the pasteboard,

00:15:48.440 --> 00:15:52.560
say, to a type that you,
to a string constant that you know of.

00:15:52.620 --> 00:15:59.030
And you do a whole bunch of compares and
you find out what type of data you have.

00:15:59.030 --> 00:15:59.030
Well,

00:15:59.910 --> 00:16:03.600
By replacing a string compare
with a conformance test,

00:16:03.640 --> 00:16:07.260
it allows you to not have
to know about every type of

00:16:07.340 --> 00:16:08.780
image out there in the world.

00:16:08.910 --> 00:16:12.680
If you can, for instance, just say,
is this thing an image?

00:16:12.700 --> 00:16:15.560
And if it is, then I'm going to give it
to QuickTime and see if

00:16:15.560 --> 00:16:17.040
QuickTime can deal with it.

00:16:17.060 --> 00:16:18.640
And that way,
you don't have to know about

00:16:18.640 --> 00:16:21.060
everybody's image type in the universe.

00:16:21.090 --> 00:16:22.710
You don't have to check
for all those types.

00:16:22.750 --> 00:16:27.490
You do a very fast conformance
test of a high-level type,

00:16:27.840 --> 00:16:29.960
and You can work with a
lot more data that way,

00:16:29.960 --> 00:16:32.240
a lot more kinds of data.

00:16:32.800 --> 00:16:39.260
So what we've done with UTIs is actually
allow just a multiple inheritance,

00:16:39.330 --> 00:16:43.660
a multiple inheritance
graph of conformance.

00:16:43.870 --> 00:16:49.250
So the reason we did this is that we came
up with two ways of looking at types.

00:16:49.260 --> 00:16:54.050
There's a physical hierarchy,
which looks at a low level technical

00:16:54.060 --> 00:16:58.640
view of something is implemented,
say on disk, as either a file or perhaps

00:16:58.650 --> 00:17:00.920
a package or a folder.

00:17:00.920 --> 00:17:03.920
And those are physical
representations on disk.

00:17:03.980 --> 00:17:07.880
And then there's a functional hierarchy,
which is the user's view of a type.

00:17:08.080 --> 00:17:14.450
And that is especially driven by
Spotlight and allows us to categorize

00:17:14.450 --> 00:17:20.340
things in ways that users view an object,
a document, or a piece of data.

00:17:20.500 --> 00:17:22.420
And for instance,
the users don't care whether it's

00:17:22.420 --> 00:17:26.850
implemented as a package or a flat file,
but they care about what its

00:17:26.850 --> 00:17:28.980
function is in their head.

00:17:29.300 --> 00:17:32.820
And every type on the system
has a place in both the physical

00:17:32.820 --> 00:17:34.810
and functional hierarchies.

00:17:34.810 --> 00:17:38.190
So let's just look at the
very top of the hierarchy.

00:17:38.330 --> 00:17:43.130
We have some good documentation
updated for Tiger on the WWDC website

00:17:43.170 --> 00:17:45.920
that goes into the whole hierarchy.

00:17:46.050 --> 00:17:50.800
But here just to give you a flavor of
kind of how it's organized at the top.

00:17:50.870 --> 00:17:54.760
The physical hierarchy starts
with the root of public.item.

00:17:54.840 --> 00:17:59.910
And we needed a root there because
mainly because of Spotlight has

00:17:59.910 --> 00:18:03.100
some basic attributes associated
with everything that it can

00:18:03.100 --> 00:18:07.550
index which includes two things.

00:18:07.700 --> 00:18:11.470
Data which is what we call
flat files or data in memory.

00:18:11.560 --> 00:18:18.020
Every file is a data stream so it
conforms to files are all public.data.

00:18:18.100 --> 00:18:22.220
Or directories which only
exist on disk not in memory.

00:18:22.420 --> 00:18:24.760
Directories can be further
divided into packages,

00:18:24.760 --> 00:18:29.860
or plain folders and a volume is
just a flavor of a plain folder.

00:18:29.860 --> 00:18:32.680
Something that the user can browse into.

00:18:33.580 --> 00:18:37.780
And then from this,
these are pretty much abstract types.

00:18:37.810 --> 00:18:43.640
Well, they're not completely abstract,
but often you'll have all the concrete

00:18:43.640 --> 00:18:46.400
types are descend from this tree.

00:18:46.400 --> 00:18:52.400
So all image formats, movie formats,
all conform to public.data, for example.

00:18:54.100 --> 00:18:58.260
Now, there's a functional hierarchy
that divides the world differently.

00:18:58.350 --> 00:19:02.400
And probably the most common
type-- there's not a single root

00:19:02.440 --> 00:19:05.290
in the functional hierarchy,
but one of the most

00:19:05.460 --> 00:19:06.610
common ones is content.

00:19:06.620 --> 00:19:08.780
And this is all documents.

00:19:09.010 --> 00:19:17.860
So documents are divided into basic text,
which may include marked

00:19:17.940 --> 00:19:21.220
up text like HTML,
or images.

00:19:21.220 --> 00:19:24.720
And there's another one,
audio-visual content,

00:19:25.140 --> 00:19:27.880
which includes movies and audio.

00:19:28.020 --> 00:19:32.330
And so again,
every type either plugs into this

00:19:32.330 --> 00:19:36.800
part of the functional hierarchy,
or if it's not a document,

00:19:36.920 --> 00:19:40.810
it might go into one of the
other categories we have,

00:19:40.810 --> 00:19:48.420
which is messages for email or chat logs,
calendar events.

00:19:48.460 --> 00:19:53.510
So all the specific iCal data
types conform to calendar event.

00:19:54.680 --> 00:19:57.940
Contacts for address book
entries and Archives for

00:19:58.260 --> 00:20:01.210
disk images and tar archives,
things like that.

00:20:01.330 --> 00:20:04.460
And there's a few more,
but this is just to give you

00:20:04.620 --> 00:20:06.780
an idea of how it's organized.

00:20:06.850 --> 00:20:10.910
And again, this is spelled out in more
detail in the documentation.

00:20:12.060 --> 00:20:18.810
So, um, sorry,
I'm going to go back again.

00:20:18.810 --> 00:20:18.810
The, uh,

00:20:19.430 --> 00:20:25.780
When we get to the demo phase,
you'll see how these functional

00:20:25.890 --> 00:20:31.300
types are used to allow you to

00:20:32.930 --> 00:20:40.000
The last part that I wanted to touch
on very quickly is something that you

00:20:40.000 --> 00:20:45.270
run into fairly quickly when you start
working with this and that's something

00:20:45.410 --> 00:20:46.900
called Dynamic Type Identifiers.

00:20:46.950 --> 00:20:51.380
And this is to solve a particular
problem that when we look at any,

00:20:51.630 --> 00:20:54.480
say, file on disk,
we don't necessarily -- we can't

00:20:54.490 --> 00:20:58.880
necessarily map every extension
to a formal Type Identifier.

00:20:58.980 --> 00:21:03.880
There's lots of things that aren't
declared yet or legacy things that will

00:21:04.040 --> 00:21:06.820
never actually be formalized as UTIs.

00:21:06.900 --> 00:21:12.040
And so we generate this funny
string when Launch Services,

00:21:12.040 --> 00:21:18.210
for instance, is asked to say,
"What's the UTI for this file?" It will

00:21:18.210 --> 00:21:21.350
-- instead of giving you no answer,
it gives you an answer that preserves

00:21:21.350 --> 00:21:23.900
what we do know about this object.

00:21:23.900 --> 00:21:28.230
And what we know about it
is that it has an extension,

00:21:28.230 --> 00:21:28.900
foo.

00:21:28.900 --> 00:21:31.900
And it's a file,
so it conforms to public.data.

00:21:31.910 --> 00:21:34.840
So what you get back is this
funny string and it's an opaque

00:21:35.350 --> 00:21:36.900
encoding of some information.

00:21:36.900 --> 00:21:39.410
But you can pass it around
like any other UTI and you can

00:21:39.420 --> 00:21:41.550
ask questions about it like,
"Okay, UTI,

00:21:41.600 --> 00:21:43.900
what's your extension?" You get back foo.

00:21:43.900 --> 00:21:47.890
You say, "Do you conform to
public.data?" You get back yes.

00:21:47.900 --> 00:21:51.520
And so it's sort of a way to
degrade gracefully when we don't

00:21:51.560 --> 00:21:53.900
have complete type information.

00:21:53.900 --> 00:21:56.480
So don't be alarmed when
you see something like that

00:21:56.480 --> 00:21:57.710
show up in your debugger.

00:22:01.000 --> 00:22:05.310
All right, so now it's time to move on
to the practice portion of the

00:22:05.400 --> 00:22:08.190
talk where I get into more.

00:22:09.390 --> 00:22:12.490
details about the API and how to use it.

00:22:12.500 --> 00:22:18.150
So there's sort of two key usage
patterns here that I think are

00:22:18.150 --> 00:22:20.900
worth thinking about looking at.

00:22:21.100 --> 00:22:25.280
The first one is just using
the existing types that we have

00:22:25.280 --> 00:22:28.140
built in to Mac OS X Tiger.

00:22:28.180 --> 00:22:35.530
And you can use all the existing types
we have to adopt new Carbon APIs,

00:22:35.990 --> 00:22:39.870
work with the file system--
file system objects at a higher

00:22:39.870 --> 00:22:42.260
level than just raw metadata.

00:22:42.260 --> 00:22:47.260
Or if you want to run a
Spotlight query with known types,

00:22:47.490 --> 00:22:49.260
you can do that.

00:22:49.260 --> 00:22:53.570
And then the next level up that
we'll talk about a little bit

00:22:53.570 --> 00:22:57.600
later is declaring new types,
extending the type system in your

00:22:57.600 --> 00:23:03.190
application or your plug-in so that
you can more tightly integrate with key

00:23:03.190 --> 00:23:06.760
features like Spotlight and Automator.

00:23:07.330 --> 00:23:10.370
All right, so let's talk more about
working with existing types.

00:23:10.370 --> 00:23:15.450
On Tiger, we have over 150 type
declarations built in.

00:23:15.600 --> 00:24:01.000
[Transcript missing]

00:24:03.140 --> 00:24:07.280
The core API is-- the whole
API is actually very simple.

00:24:07.430 --> 00:24:12.860
The core of it is, as I mentioned,
being able to do a conformance test.

00:24:12.880 --> 00:24:17.870
So UT type conforms to takes two
strings and it returns a Boolean.

00:24:18.510 --> 00:24:25.320
And this is what Spotlight uses
and what Navigation Services uses,

00:24:25.320 --> 00:24:31.350
the Pasteboard, in order to learn about a
type that it is working with.

00:24:32.130 --> 00:24:39.420
You can also convert to other type
tag namespaces as we call them.

00:24:39.650 --> 00:24:46.460
So, anything--any other kind of
identifier is called a tag.

00:24:46.870 --> 00:24:51.830
It has a MIME or an--MIME type
or an extension or an OS type.

00:24:51.830 --> 00:24:51.830
You can go back and forth mapping
between UTIs and those other spaces.

00:24:51.930 --> 00:24:54.350
And then you can, of course,
fetch attributes like the

00:24:54.350 --> 00:25:00.650
description or indirectly the
icon through icon services.

00:25:00.770 --> 00:25:04.270
These functions are in uttype.h.

00:25:05.350 --> 00:25:13.320
Now, going up to the next
layer to Launch Services,

00:25:13.320 --> 00:25:13.320
the Launch Services API,

00:25:13.520 --> 00:25:18.200
This is the layer at which you
can learn about or ask for the

00:25:18.200 --> 00:25:20.760
UTI of file system objects.

00:25:20.960 --> 00:25:23.400
UTIs are not stored in the file system.

00:25:23.410 --> 00:25:28.260
We don't have any file system
currently that actually stores a

00:25:28.260 --> 00:25:31.610
UTI directly next to a file as metadata.

00:25:31.840 --> 00:25:35.890
But Launch Services wraps all of the
logic around looking at an object,

00:25:36.000 --> 00:25:40.100
seeing if it's a directory or a file,
and what kind of metadata.

00:25:40.100 --> 00:25:43.300
It looks at all the available metadata,
the extension, what have you,

00:25:43.360 --> 00:25:47.530
and it can give you back
what we call a content type.

00:25:47.690 --> 00:25:51.300
So Launch Services has this new
thing called named attributes where

00:25:51.350 --> 00:25:56.040
you can ask for things by name such
as the content type and things that

00:25:56.040 --> 00:25:58.830
you're already probably familiar
with with Launch Services such as

00:25:58.840 --> 00:26:01.200
the display name and the kind string.

00:26:01.280 --> 00:26:05.080
But for purposes of this talk,
the content type is the most interesting

00:26:05.100 --> 00:26:08.800
because this gives you kind of
the unifying view of the types of

00:26:08.860 --> 00:26:11.040
objects that are on the file system.

00:26:11.090 --> 00:26:13.200
This is what Spotlight uses.

00:26:13.200 --> 00:26:18.060
Whenever it's going to import
a file or a folder or whatever,

00:26:18.060 --> 00:26:22.550
it turns to Launch Services and says,
"What's the content type of this

00:26:22.550 --> 00:26:25.800
object?" And Launch Services gives
it back a string,

00:26:25.800 --> 00:26:29.430
and then it uses that string
to find an importer for that.

00:26:29.600 --> 00:26:33.600
And that way Spotlight doesn't
have to know that there are,

00:26:33.600 --> 00:26:38.360
you know, four different ways of
identifying JPEG images on disk.

00:26:38.400 --> 00:26:42.930
It just gets back a single string,
public.jpeg, and it finds an importer.

00:26:43.270 --> 00:26:45.430
for that type.

00:26:49.640 --> 00:26:54.180
Another new feature in
Launch Services in Tiger is using

00:26:54.180 --> 00:26:56.740
UTIs to simplify your document claims.

00:26:56.880 --> 00:27:01.500
So currently in your InfoP list,
when you open a bunch of document types,

00:27:01.690 --> 00:27:03.930
you need to list out a
whole bunch of metadata,

00:27:03.930 --> 00:27:04.500
right?

00:27:04.500 --> 00:27:10.640
Back to the JPEG example,
you need to list all the extensions

00:27:10.640 --> 00:27:16.170
for JPEG in your document claim,
and you need to list,

00:27:16.170 --> 00:27:16.570
I think it's just one OS type.

00:27:16.730 --> 00:27:21.450
And everyone has to go through the
same exercise of identifying the

00:27:21.450 --> 00:27:26.900
redundant types of metadata that
identify a particular type in order to

00:27:27.000 --> 00:27:31.010
claim that for your application or to
be able to open that kind of document.

00:27:31.140 --> 00:27:36.390
And by using a new keyword in your
document types section of your plist,

00:27:36.470 --> 00:27:41.940
the ls_item_content types,
and then it takes an array of UTIs,

00:27:42.120 --> 00:27:45.720
you can make both-- well,
you can simplify your

00:27:45.720 --> 00:27:47.120
Info.plist quite a bit.

00:27:47.280 --> 00:27:50.710
So if you open JPEGs,
you just say public.jpeg.

00:27:50.820 --> 00:27:54.330
You've got one entry,
and launch services takes care of

00:27:54.340 --> 00:27:58.180
all the details of knowing that,
oh, this means that you can

00:27:58.180 --> 00:28:03.570
handle extension JPG and JPEG,
as well as any other metadata

00:28:03.600 --> 00:28:05.750
that identifies a JPEG.

00:28:05.920 --> 00:28:11.500
It also leverages conformance,
because when you list a UTI in

00:28:11.500 --> 00:28:16.380
your info.p list like this,
you're saying, you open anything that

00:28:16.380 --> 00:28:18.420
conforms to this UTI.

00:28:18.560 --> 00:28:24.040
And it's a much better way of doing
what we used to achieve with wildcards.

00:28:24.180 --> 00:28:29.240
Basically, you can -- with wildcards,
you can say either you open a specific

00:28:29.240 --> 00:28:33.760
type that you identify specific metadata,
or you say, I open everything.

00:28:33.880 --> 00:28:38.960
And that allows a user to drop
anything on your application icon.

00:28:39.060 --> 00:28:41.700
And even if you can't open it,
you're still going to get

00:28:41.990 --> 00:28:43.860
launched and given the object.

00:28:43.950 --> 00:28:47.060
And at that point, you have to figure out
what to do with it.

00:28:47.140 --> 00:28:51.420
If you do something high level,
like in this example, claim public.data,

00:28:51.570 --> 00:28:56.680
then what happens is
that -- what that means,

00:28:56.680 --> 00:29:01.020
what public.data means
is files in this context.

00:29:01.350 --> 00:29:03.450
Because files are all data streams.

00:29:03.490 --> 00:29:03.760
And you're saying, well,
what's the point of this?

00:29:03.840 --> 00:29:06.890
And you're saying,
I want to be able to drop

00:29:07.510 --> 00:29:13.960
any kind of file on my icon,
but not a folder and not a volume,

00:29:13.960 --> 00:29:17.410
not an alias, for example.

00:29:18.190 --> 00:29:22.290
It allows the user experience to be
much better because then in the finder,

00:29:22.290 --> 00:29:28.440
the feedback for dragging is much more
precise about what kinds of things you

00:29:28.480 --> 00:29:31.430
want to be able to open in your app.

00:29:31.550 --> 00:29:37.790
And now is a good time to do a
demo to show some of these concepts

00:29:37.790 --> 00:29:41.140
that I've been talking about.

00:29:41.140 --> 00:29:43.880
So if we can switch over.

00:29:43.880 --> 00:29:44.460
I was looking--can we switch to demo?

00:29:46.000 --> 00:29:59.400
[Transcript missing]

00:29:59.810 --> 00:30:04.100
The code was available for and which did
some interesting things like just maybe

00:30:04.100 --> 00:30:08.780
open some different kinds of documents,
something more than just text.

00:30:08.840 --> 00:30:12.130
I also wanted a Carbon app
because right now Carbon has a

00:30:12.130 --> 00:30:15.790
little bit tighter integration
with this stuff than Cocoa does.

00:30:15.940 --> 00:30:20.850
Cocoa, you can of course use the
C APIs for Uniform Type Identifiers,

00:30:20.980 --> 00:30:26.570
but it's not currently integrated
into the Cocoa Objective C APIs.

00:30:26.890 --> 00:30:30.840
But I thought about simple text,
Carbon app,

00:30:30.840 --> 00:30:38.640
and I remembered vaguely that it
sometimes displayed more than just text.

00:30:38.670 --> 00:30:44.280
And so I thought I would try
dropping an image onto simple

00:30:44.280 --> 00:30:46.140
text and see what it did.

00:30:46.150 --> 00:30:48.450
And this document is too large.

00:30:48.680 --> 00:30:52.480
And I thought, oh,
it doesn't open images.

00:30:52.480 --> 00:30:54.800
I guess I was wrong.

00:30:54.800 --> 00:30:56.320
But I went and looked at
source code and I thought,

00:30:56.360 --> 00:30:59.200
great, now I have to debug simple text.

00:30:59.200 --> 00:31:03.600
And it must have some sort of lame size
check because it thinks it's a text file.

00:31:03.640 --> 00:31:08.480
And as I debugged it,
I realized the only problem is that

00:31:08.480 --> 00:31:12.210
it doesn't know that this is an image
because simple text was never updated

00:31:12.320 --> 00:31:14.480
to know anything about extensions.

00:31:14.600 --> 00:31:19.110
And so in this case,
this is a file that has an extension,

00:31:19.180 --> 00:31:22.300
but it doesn't have any file
type code associated with it.

00:31:22.370 --> 00:31:26.100
So simple text actually has
no idea that it's a JPEG file.

00:31:26.230 --> 00:31:28.320
And the same thing happened
when I dropped a movie on.

00:31:28.320 --> 00:31:30.520
This is too large.

00:31:30.650 --> 00:31:32.950
So what can we do about this?

00:31:33.070 --> 00:31:37.560
And, you know,
we can go and add a whole bunch of

00:31:37.560 --> 00:31:38.320
extensions to the list of what JPEGs are.

00:31:38.320 --> 00:31:40.320
And we can add a JPEG pin open.

00:31:40.320 --> 00:31:46.320
But can we make it any simpler and not
have to know so much about file metadata?

00:31:46.320 --> 00:31:50.360
This is a little bit large.

00:31:55.050 --> 00:31:56.200
I know it's very readable.

00:31:56.200 --> 00:31:58.020
It would be even readable
if it was larger,

00:31:58.110 --> 00:32:01.530
but I won't have enough room.

00:32:01.650 --> 00:32:04.020
Is that somewhat readable?

00:32:04.450 --> 00:32:05.220
No.

00:32:05.220 --> 00:32:07.530
Yeah, the front row.

00:32:07.540 --> 00:32:08.380
Okay.

00:32:08.490 --> 00:32:09.100
All right.

00:32:09.100 --> 00:32:09.510
My bad.

00:32:09.700 --> 00:32:12.780
We'll just,
we'll go with your preference.

00:32:22.700 --> 00:32:31.700
[Transcript missing]

00:32:36.750 --> 00:32:41.100
somewhat cryptically
determined window type OR open.

00:32:41.160 --> 00:32:44.790
I love these OR functions.

00:32:44.910 --> 00:32:47.380
Depending on what I tell you to do,
do it.

00:32:47.420 --> 00:32:53.100
And this is responsible for
figuring out what things are.

00:32:53.100 --> 00:32:55.020
And it's all OS type-based.

00:32:55.040 --> 00:32:59.760
And it tries to figure out-- it
builds up lists of image types

00:32:59.760 --> 00:33:03.080
and movie types and text types.

00:33:03.080 --> 00:33:05.420
And it turns out when you
go look at these functions,

00:33:05.420 --> 00:33:08.320
they're just hard-coded
lists of OS types.

00:33:08.320 --> 00:33:12.780
And they're not even very complete
compared to what QuickTime can do

00:33:12.780 --> 00:33:16.920
as far as importing images movies.

00:33:17.730 --> 00:33:21.360
So these aren't very useful,
and especially if there's no OS type

00:33:21.430 --> 00:33:26.100
on the file that we're trying to open.

00:33:26.200 --> 00:33:29.560
So what I did was I put
my code over here.

00:33:32.700 --> 00:33:34.100
And I'm just going to
make a few changes here.

00:33:34.100 --> 00:33:37.430
I want to work with the UTI.

00:33:37.790 --> 00:33:42.410
What happens in this function is an
FSRef is passed in to the function

00:33:42.590 --> 00:33:45.100
and we have to figure out what it is.

00:33:45.250 --> 00:33:50.950
So we want to ask for its content
type from Launch Services.

00:33:51.190 --> 00:33:56.020
So I have a CFString variable
there and I'm going to...

00:33:59.280 --> 00:34:08.200
"Place this if clause with something
that basically asks for the content type.

00:34:08.250 --> 00:34:11.000
Now see,
you have to deal with the wrapping

00:34:11.000 --> 00:34:13.470
now because you wanted the big font."

00:34:15.050 --> 00:34:16.750
There it is.

00:34:17.130 --> 00:34:21.400
We LS copy item attribute,
we get back a CFString in

00:34:21.400 --> 00:34:23.930
the content type,
and then we can do

00:34:23.930 --> 00:34:26.090
conformance tests on that.

00:34:26.300 --> 00:34:29.270
So I'm going to do first,

00:34:31.550 --> 00:34:36.510
I'm going to say,
does it conform to image, UT type image?

00:34:36.900 --> 00:34:40.040
And if it is an image,
then I'm going to continue doing this

00:34:40.160 --> 00:34:44.980
little thing that simple text does,
where it asks QuickTime if

00:34:45.210 --> 00:34:49.510
there is an importer available
for this kind of image.

00:34:49.730 --> 00:34:54.260
And the only problem with trying to do
that is that QuickTime is looking for,

00:34:54.260 --> 00:34:57.630
in this case,
the type is the OS type or the

00:34:57.630 --> 00:34:59.680
file type code of the file.

00:34:59.730 --> 00:35:03.280
And we know that in some cases,
in this case, we don't have one.

00:35:03.320 --> 00:35:03.960
And we need one.

00:35:04.080 --> 00:35:10.780
So we can get one from the
Uniform Type Identifier API.

00:35:10.850 --> 00:35:13.600
Because we have the content type now.

00:35:13.620 --> 00:35:18.440
And let's go paste this in.

00:35:18.440 --> 00:35:20.580
I put it in the wrong place.

00:35:28.970 --> 00:35:29.900
Okay.

00:35:30.030 --> 00:35:32.840
So, we're going to get back
from this function,

00:35:32.840 --> 00:35:36.460
we're going to get back the
OS type or the file code,

00:35:36.480 --> 00:35:38.740
the type code as a CFString.

00:35:38.810 --> 00:35:42.920
And then we use a utility function to
actually turn it into an actual OS type

00:35:43.250 --> 00:35:45.420
data type and that happens right here.

00:35:45.560 --> 00:35:50.270
And we release the CFString.

00:35:50.270 --> 00:35:50.270
And then we can,

00:35:50.860 --> 00:35:54.890
"We can pass that type that we get
back into QuickTime and even though

00:35:54.890 --> 00:35:58.930
the file doesn't have a file type,
we can get back an importer

00:35:58.930 --> 00:36:01.040
that QuickTime can provide.

00:36:01.050 --> 00:36:05.610
And if we get one of those back,
then we know that in simple text terms,

00:36:05.610 --> 00:36:07.560
it's a picked window."

00:36:08.000 --> 00:36:21.300
[Transcript missing]

00:36:21.470 --> 00:36:23.560
So what I've added is one
more conformance test.

00:36:23.560 --> 00:36:25.730
I just say, "Okay,
does the content type of the file

00:36:25.830 --> 00:36:29.080
conform to movie?" And if so,
then let's call it a movie

00:36:29.210 --> 00:36:30.450
file or a movie window.

00:36:30.800 --> 00:36:33.210
And that means later on,
Simple Text will try to create

00:36:33.210 --> 00:36:34.700
a movie controller for that.

00:36:34.700 --> 00:36:37.070
So I'm going to go ahead and build that.

00:36:40.100 --> 00:36:46.170
and I are going to go ahead
and start the session.

00:36:47.900 --> 00:36:49.900
Let's see what happens.

00:36:49.900 --> 00:36:52.900
Didn't work.

00:36:52.900 --> 00:36:53.840
Is that the right app?

00:36:54.000 --> 00:36:56.900
It is the right app,
but... It's still running.

00:36:56.900 --> 00:36:57.900
Yeah, that's exactly the problem.

00:36:57.900 --> 00:37:03.710
I told myself a million times,
"Quit the app." Who said that?

00:37:03.930 --> 00:37:05.870
Who said it's still running?

00:37:05.880 --> 00:37:10.900
Thank you.

00:37:10.900 --> 00:37:12.920
But you were wrong.

00:37:20.210 --> 00:37:27.710
Yeah, well it's running again
because I just... Alright,

00:37:27.710 --> 00:37:27.710
now I'm getting too much advice.

00:37:44.600 --> 00:38:21.000
[Transcript missing]

00:38:37.400 --> 00:38:49.500
[Transcript missing]

00:38:53.920 --> 00:38:57.420
Now it's rebuilding everything
because I changed where it builds to.

00:38:57.750 --> 00:39:00.680
Get rid of that evil window.

00:39:00.680 --> 00:39:04.670
Still running.

00:39:13.000 --> 00:39:20.400
[Transcript missing]

00:39:23.130 --> 00:39:26.770
What?

00:39:26.960 --> 00:39:29.170
Yeah, that's not a bad idea.

00:39:40.900 --> 00:39:46.600
[Transcript missing]

00:39:48.320 --> 00:39:49.190
Okay.

00:39:49.190 --> 00:39:52.500
Now, this should just work.

00:39:52.730 --> 00:39:54.000
No, I dragged it to the wrong place.

00:39:54.180 --> 00:40:00.290
Yeah, yeah, yeah, yeah, yeah, yeah.

00:40:05.200 --> 00:40:10.600
And now I can do the world premiere of
my 10-year-old daughter's clay animation.

00:40:34.510 --> 00:40:35.600
I only have one running.

00:40:35.600 --> 00:40:38.940
I don't want this one anymore.

00:40:38.940 --> 00:40:41.720
And next problem.

00:40:42.060 --> 00:40:48.960
I went and looked at the open
panel and if we go into our...

00:40:50.000 --> 00:41:06.300
[Transcript missing]

00:41:09.440 --> 00:41:16.400
All we need to do is
look for the open panel.

00:41:17.730 --> 00:41:18.690
Open File Dialog.

00:41:18.690 --> 00:41:21.190
This is what puts up the Open Panel.

00:41:21.190 --> 00:41:26.740
And it's using the old style
Nav Services filtering.

00:41:26.740 --> 00:41:30.040
So I'm going to get rid of the thing
that allocates that special handle

00:41:30.040 --> 00:41:31.680
that has all the OS types in it.

00:41:31.690 --> 00:41:36.700
And we're not going to pass it in anymore
to the Nav Create Get File Dialog.

00:41:36.700 --> 00:41:42.140
And we're certainly not going
to dispose of the handle when

00:41:42.140 --> 00:41:42.140
we're done because there is none.

00:41:43.550 --> 00:41:47.640
And instead we're going to
just add this little bit.

00:41:47.640 --> 00:41:51.750
If we created the dialogue correctly,

00:41:52.140 --> 00:41:56.750
Then the next thing we're going
to do is create an array of UTIs

00:41:56.870 --> 00:41:58.660
that we want NAV to filter by.

00:41:58.840 --> 00:42:02.420
In this case, text, image, and movie.

00:42:02.470 --> 00:42:07.340
And we're saying anything that
conforms to one of these base types,

00:42:07.390 --> 00:42:10.100
I want you to enable
in the File Open Panel.

00:42:10.100 --> 00:42:18.780
You probably thought I wasn't
going to remember to quit.

00:42:18.780 --> 00:42:18.780
Let's build.

00:42:26.100 --> 00:42:27.500
"We've built.

00:42:27.500 --> 00:42:31.560
Let's run it.

00:42:31.560 --> 00:42:31.560
Open.

00:42:33.440 --> 00:42:36.780
and all of my documents are now enabled.

00:42:36.780 --> 00:42:38.370
Now I've done all this.

00:42:38.370 --> 00:42:43.680
I've made SimpleText extension aware
without having to use any extensions.

00:42:43.690 --> 00:42:44.580
Isn't that lovely?

00:42:44.690 --> 00:42:51.120
If you hate extensions,
then you don't have to use

00:42:51.120 --> 00:42:51.120
them to interoperate with them.

00:42:52.780 --> 00:42:53.210
10.4.

00:42:53.520 --> 00:42:57.940
This is supported on 10.4.

00:42:57.940 --> 00:43:02.080
The last thing I was going to do was make
a quick change to the Info P List because

00:43:02.400 --> 00:43:05.220
there was this other annoying problem.

00:43:05.220 --> 00:43:09.210
Let's see.

00:43:09.210 --> 00:43:09.210
I got to get it back.

00:43:11.510 --> 00:43:12.580
There we go.

00:43:12.580 --> 00:43:13.600
I need it in the doc.

00:43:13.630 --> 00:43:18.610
There was this other annoying problem
that now we can-- if you noticed before,

00:43:18.610 --> 00:43:20.920
even though I couldn't
open this file before,

00:43:20.920 --> 00:43:22.280
it would still highlight.

00:43:22.300 --> 00:43:24.760
And in fact, you can drag pretty much
anything down to simple text,

00:43:24.820 --> 00:43:25.740
and it will try to open it.

00:43:25.740 --> 00:43:27.640
You can drop a folder on it.

00:43:27.680 --> 00:43:32.360
And it says,
it may be in use by someone else.

00:43:32.360 --> 00:43:37.220
Now we can fix that error message,
but what we really want to do is

00:43:37.440 --> 00:43:41.890
just have proper feedback and not
highlight the application icon at all.

00:43:41.900 --> 00:43:43.640
You can even drop a volume on there.

00:43:43.690 --> 00:43:48.140
And the reason is because the Info.plist,
if you look at all of

00:43:48.140 --> 00:43:50.760
these document types,
it's got all the specific

00:43:50.760 --> 00:43:52.500
metadata that it wants to claim.

00:43:52.520 --> 00:43:56.550
Down at the bottom, though, it says,
let's claim four stars,

00:43:56.660 --> 00:43:59.120
which is the OS type for wildcard claims.

00:43:59.130 --> 00:44:04.320
And that means just drop anything on me.

00:44:04.790 --> 00:44:07.770
And what we really want to do
is be more specific about what

00:44:07.800 --> 00:44:08.850
simple text can actually do.

00:44:08.990 --> 00:44:10.220
So we use this.

00:44:10.220 --> 00:44:13.620
We use this new key,
LS item content types,

00:44:13.630 --> 00:44:16.810
which is how to claim UTIs.

00:44:17.040 --> 00:44:22.420
And we replace the wildcard
with these same three UTIs,

00:44:22.510 --> 00:44:25.000
text, image, and movie.

00:44:25.030 --> 00:44:26.950
And--

00:44:31.200 --> 00:44:35.430
Build.

00:44:35.510 --> 00:44:39.470
Build very quickly because it
was just an IP list change.

00:44:39.510 --> 00:44:41.820
And let's hide this.

00:44:42.390 --> 00:44:48.390
Now we can still drag images down,
movies, but we shouldn't be able to

00:44:48.390 --> 00:44:49.950
drag say volumes anymore.

00:44:50.060 --> 00:44:52.300
No highlighting on the icon.

00:44:52.670 --> 00:44:56.310
Same with folders.

00:44:58.050 --> 00:45:00.250
And text opens just fine still.

00:45:00.490 --> 00:45:03.000
All right,
so that was just three simple changes to

00:45:03.000 --> 00:45:09.780
simple text that enabled it to actually
do what it can do and not be blocked

00:45:09.780 --> 00:45:12.190
by some poor management of metadata.

00:45:12.340 --> 00:45:17.580
Okay, we can go back to slides.

00:45:21.150 --> 00:45:30.520
So now I want to turn to more advanced
uses of UTIs and that involves extending

00:45:30.520 --> 00:45:33.310
the system by declaring your own types.

00:45:33.490 --> 00:45:35.050
And it's a cooperative system.

00:45:35.590 --> 00:45:40.570
Anyone can add to it and
it's a shared database of

00:45:40.570 --> 00:45:43.100
information of type knowledge,
if you will,

00:45:43.380 --> 00:45:46.060
that is available to all applications.

00:45:46.190 --> 00:45:51.560
It's shared across all the
processes that are running in

00:45:52.410 --> 00:45:52.650
the current user's context.

00:45:52.920 --> 00:45:56.590
And since it needs to be known
even when your app isn't running,

00:45:56.590 --> 00:45:59.640
we actually declare
types in your Info.plist.

00:45:59.680 --> 00:46:03.390
And this allows, for instance,
the finder to know about your

00:46:03.390 --> 00:46:05.790
types before your app is even run.

00:46:05.920 --> 00:46:08.790
Types can be declared currently
in three kinds of bundles:

00:46:09.110 --> 00:46:15.660
Applications, Spotlight Importers,
and Automator Action Bundles.

00:46:15.800 --> 00:46:19.650
We limit it to these three because
these are the ones that actually

00:46:19.650 --> 00:46:23.800
need it and there's some scaling
issues that we haven't dealt with yet.

00:46:23.800 --> 00:46:26.790
So these are the places where
you can declare a new type.

00:46:26.800 --> 00:46:29.800
There's two ways to declare a type.

00:46:29.800 --> 00:46:33.640
As I said, it happens in your Info.plist,
so it's just a little bit of XML.

00:46:33.800 --> 00:46:37.130
But there's two styles:
there's exported types

00:46:37.130 --> 00:46:38.790
and imported types.

00:46:38.800 --> 00:46:41.800
And exported types is how you
declare something that you own,

00:46:41.800 --> 00:46:45.800
a format or type that you control.

00:46:45.800 --> 00:46:50.790
However, you might depend on some type
that's not built into the system,

00:46:50.800 --> 00:46:54.800
it's from some third party,
and you know how the third party

00:46:54.800 --> 00:46:57.790
declares it in their product,
but you can't count on that product

00:46:57.790 --> 00:46:58.780
being installed on the system.

00:46:58.800 --> 00:47:03.160
So you just add it to your Info.plist and
you call it "imported." And that

00:47:03.160 --> 00:47:04.800
way we know it's kind of secondary.

00:47:04.800 --> 00:47:08.720
We know that we'll use this imported
declaration if there isn't an equivalent

00:47:08.720 --> 00:47:10.800
one for the same UTI that's exported.

00:47:10.800 --> 00:47:13.800
And that way your product
continues to work.

00:47:13.800 --> 00:47:15.800
But if the UTI is not exported,
it's not going to be used.

00:47:15.800 --> 00:47:20.880
So the other product is installed,
they are the de facto,

00:47:21.000 --> 00:47:23.670
the master copy of the declaration,
if you will.

00:47:23.800 --> 00:47:29.560
And so it's just two slightly
different ways to declare a type.

00:47:29.760 --> 00:47:33.750
And also by doing it in the InfoP-List,
it allows us to leverage the

00:47:33.750 --> 00:47:37.380
bundle format to do resource
loading such as the description

00:47:37.380 --> 00:47:39.540
which can be a localized string.

00:47:39.540 --> 00:47:43.710
It's loaded from bundle
resources as well as the icon.

00:47:43.960 --> 00:47:46.990
So this is just an
example type declaration.

00:47:47.140 --> 00:47:51.050
It looks something like a
document type declaration.

00:47:51.140 --> 00:47:55.360
You've got the UT exported type
declarations key up at the top,

00:47:55.430 --> 00:47:58.150
and then what follows
is an array of types,

00:47:58.200 --> 00:48:03.800
each its own little dictionary,
and some of the most important keys

00:48:03.800 --> 00:48:08.560
in there are the type identifier,
which is the actual UTI,

00:48:08.640 --> 00:48:13.460
the single UTI or an array
of UTIs that it conforms to.

00:48:13.460 --> 00:48:14.600
That's really important.

00:48:14.820 --> 00:48:18.790
I encourage you to read through
the documentation about conformance

00:48:19.050 --> 00:48:22.880
and familiarize yourself with the
abstract hierarchy so that you

00:48:22.880 --> 00:48:27.120
can get your conformance right
to work really well with Spotlight.

00:48:27.320 --> 00:48:32.640
There's the description,
which is the human readable string.

00:48:32.720 --> 00:48:40.140
And then there's yet another
dictionary which lists out all of the,

00:48:40.140 --> 00:48:46.050
what we call, tags,
which are the extensions and the

00:48:46.050 --> 00:48:46.710
MIME types that you-- and OS types
and NS pasteboard string types

00:48:46.710 --> 00:48:46.710
that you want to map to this UTI.

00:48:47.330 --> 00:48:51.130
And once you put that
in your info.p list,

00:48:51.130 --> 00:48:54.050
then all you have to do is get it
registered with Launch Services and

00:48:54.050 --> 00:48:56.560
it becomes active on the system.

00:48:56.560 --> 00:49:00.500
Registering with Launch Services is,
especially in the past

00:49:00.500 --> 00:49:03.030
but still a little bit,
it's a little bit of a black art,

00:49:03.290 --> 00:49:07.990
but you need to be registered
on the system for your bundle

00:49:07.990 --> 00:49:12.010
identifier to be findable,
in order for your document bindings

00:49:12.010 --> 00:49:15.550
to work and your icons to show up,
and now for your type declarations

00:49:15.550 --> 00:49:17.560
to also be active on the system.

00:49:17.600 --> 00:49:19.880
For applications,
it pretty much happens automatically,

00:49:19.880 --> 00:49:23.460
either by installing
with the Apple installer,

00:49:23.460 --> 00:49:27.850
or if you're just browsing around the
Finder or you launch an application,

00:49:27.850 --> 00:49:31.210
we notice it and we
register your info.p list.

00:49:31.410 --> 00:49:34.770
For Spotlight importers
and Automator plug-ins,

00:49:34.770 --> 00:49:38.060
it's a little more complicated.

00:49:38.100 --> 00:49:42.540
You can drag them into the
appropriate library folder,

00:49:42.540 --> 00:49:44.340
like either the Spotlight folder.

00:49:44.360 --> 00:49:49.720
Or the Automator folder inside
either /library or the library

00:49:49.720 --> 00:49:51.720
in the user's home directory.

00:49:51.760 --> 00:49:54.500
And at that point, they'll get noticed by
Spotlight right away,

00:49:54.720 --> 00:49:57.130
because it's watching those folders.

00:49:57.150 --> 00:50:01.740
It will also get noticed by
Automator when the app runs next.

00:50:01.950 --> 00:50:05.960
If you have your own installer,
there is lsregister functions that were

00:50:05.960 --> 00:50:10.480
available first in 10.3 to allow you
to register something right away after

00:50:10.480 --> 00:50:13.180
you've installed it in the right place.

00:50:14.330 --> 00:50:16.560
One note about debugging.

00:50:16.560 --> 00:50:20.120
I get this question a lot,
that you change your InfoP list

00:50:20.400 --> 00:50:23.260
and it doesn't have any effect.

00:50:23.260 --> 00:50:24.810
Because you're just trying
to do something quick.

00:50:24.920 --> 00:50:26.450
And I do it all the time myself.

00:50:26.520 --> 00:50:28.390
You want to change an app in place.

00:50:28.500 --> 00:50:31.300
You want to change its InfoP list
and not have to rebuild.

00:50:31.300 --> 00:50:32.740
The problem is we don't
know it's changed.

00:50:32.740 --> 00:50:36.440
We don't watch every InfoP list on
the disk to know that it's changed.

00:50:36.570 --> 00:50:41.170
But if you edit an InfoP list and
then touch the mod date of the .app

00:50:41.170 --> 00:50:47.570
bundle or the importer plug-in,
then we notice the next time, say,

00:50:47.570 --> 00:50:51.080
we go to launch that app,
that it's changed.

00:50:51.160 --> 00:50:55.500
And we will then go inside and read the
InfoP list again and re-register it.

00:50:55.700 --> 00:51:00.720
So with apps, generally the best practice
is touch the mod date,

00:51:00.720 --> 00:51:03.160
launch the app,
and you should be good to go.

00:51:03.210 --> 00:51:05.520
Now you notice I didn't have to
do any of that with Xcode when

00:51:05.520 --> 00:51:08.350
I was rebuilding SimpleText,
as long as I could find where

00:51:08.350 --> 00:51:09.890
the hell SimpleText was.

00:51:10.060 --> 00:51:17.230
And that was because Xcode will also
re-register your app after you build it.

00:51:20.290 --> 00:51:23.200
And that brings us to the
Launch Services database.

00:51:23.200 --> 00:51:26.190
This is more debugging info.

00:51:26.430 --> 00:51:29.200
People often want to know where
the Launch Services database is,

00:51:29.200 --> 00:51:32.970
and it's in /LibraryCaches,
and it begins with

00:51:32.970 --> 00:51:36.200
com/AppleLaunchServices,
and the numbers that come after that,

00:51:36.200 --> 00:51:38.200
you can probably reverse engineer
to figure out what they mean.

00:51:38.200 --> 00:51:42.680
But if you really want to blow it away,
you can actually blow away

00:51:42.680 --> 00:51:44.200
all of /LibraryCaches.

00:51:44.200 --> 00:51:46.190
Some other components might
not like to hear me say that,

00:51:46.200 --> 00:51:50.200
but that's the design
point of /LibraryCaches,

00:51:50.200 --> 00:51:52.200
is that it's a cache.

00:51:52.200 --> 00:51:55.200
It's all reconstructable,
so you can blow the whole thing away,

00:51:55.200 --> 00:51:58.200
reboot,
and everything's supposed to get rebuilt.

00:51:58.220 --> 00:52:03.510
And in fact, Launch Services,
the database, will get rebuilt when you

00:52:03.510 --> 00:52:06.150
reboot in such a circumstance.

00:52:06.420 --> 00:52:12.570
On Tiger,
actually every user has a separate

00:52:13.020 --> 00:52:17.300
Launch Services database and
that's because we were getting a

00:52:17.300 --> 00:52:17.300
little too much crosstalk between
having one shared database and

00:52:17.300 --> 00:52:17.300
multiple users on the system.

00:52:18.500 --> 00:52:23.550
and this is not the version of the
slides that I approved last night.

00:52:23.550 --> 00:52:23.550
Oh well.

00:52:23.980 --> 00:52:26.440
But in order to reset your
launch services database,

00:52:26.440 --> 00:52:29.140
if you really want to,
you don't have to reboot.

00:52:29.240 --> 00:52:30.670
There's easier ways.

00:52:30.680 --> 00:52:33.550
And there's this tool which is
hidden away down in the launch

00:52:33.550 --> 00:52:36.840
services framework because it's
not really a developer tool,

00:52:36.840 --> 00:52:39.880
but I've talked about it enough
on mailing lists that I thought

00:52:39.880 --> 00:52:40.780
I would just put it out there.

00:52:40.910 --> 00:52:42.780
It's called lsregister.

00:52:42.780 --> 00:52:45.830
And rather than give you the long path,
I would just suggest that you

00:52:45.960 --> 00:52:50.550
use the find command in system
library frameworks to look for it.

00:52:50.640 --> 00:52:53.510
That's a little bit easier
to remember than a long path.

00:52:53.520 --> 00:52:56.810
And once you find it,
you can run it and do things

00:52:56.880 --> 00:53:01.200
like the dash dump switch
which will give a long dump.

00:53:01.200 --> 00:53:04.150
Set your terminal window to unlimited
scroll back because it will blow

00:53:04.150 --> 00:53:06.340
out whatever you have currently.

00:53:06.340 --> 00:53:10.050
And it's fairly readable dump of what's
in the launch services database and

00:53:10.050 --> 00:53:14.400
all the document type claims and all of
the type declarations that are there.

00:53:14.400 --> 00:53:17.740
And that can be useful for finding, say,
that, oh, yeah,

00:53:17.740 --> 00:53:21.310
I have that old crummy version of my
app that I built two weeks ago and

00:53:21.310 --> 00:53:23.140
it's still on the disk somewhere.

00:53:23.140 --> 00:53:26.780
And launch services knows about it,
but I don't.

00:53:26.780 --> 00:53:28.720
And that's why things
aren't working right.

00:53:28.720 --> 00:53:30.620
So the dump is useful for that.

00:53:30.620 --> 00:53:33.890
And what I suggest in that case is you
take that crappy old version of your app,

00:53:33.890 --> 00:53:35.890
you put it in the trash,
and you empty the trash,

00:53:35.890 --> 00:53:37.160
and it will get unregistered.

00:53:38.810 --> 00:53:44.860
You can also start from scratch
by doing lsregister-kill-seed and

00:53:44.860 --> 00:53:49.820
this will erase the database and
then rescan for apps just as if you

00:53:49.820 --> 00:53:51.700
were booting for the first time.

00:53:51.700 --> 00:53:57.930
You can also force a specific app
to get re-registered with the -f

00:53:58.250 --> 00:53:59.700
switch which stands for force.

00:53:59.700 --> 00:54:03.700
That way even if it's already registered,
it will force it to get registered again

00:54:03.700 --> 00:54:05.700
even if the mod date hasn't changed.

00:54:05.810 --> 00:54:09.690
So this is handy for avoiding
lots of hair pulling and teeth

00:54:09.690 --> 00:54:15.940
gnashing and calling me bad
names and things like that.

00:54:17.700 --> 00:54:24.360
I wanted to have one slide on some
of the new API in Launch Services.

00:54:24.360 --> 00:54:28.740
We talked about named attributes
and getting the content type

00:54:28.850 --> 00:54:32.470
with the display name a little
earlier but there's also a few new

00:54:33.120 --> 00:54:37.400
versions of the LS open functions,
new ways to open things.

00:54:37.400 --> 00:54:40.650
For one thing,
we have replaced the launch

00:54:40.650 --> 00:54:45.260
application function which was
part of the process manager,

00:54:45.260 --> 00:54:48.100
it's still supported
but we modernized it.

00:54:48.100 --> 00:54:51.910
It's a little easier to use,
it's part of Launch Services and it

00:54:52.010 --> 00:54:54.200
still returns a process serial number.

00:54:54.200 --> 00:54:57.200
In fact,
all the new LS open functions will return

00:54:57.280 --> 00:55:02.080
process serial numbers for the apps that
are used to handle either the app that

00:55:02.080 --> 00:55:07.190
you're opening or the app that's used
to handle the document or the URL you're

00:55:07.660 --> 00:55:12.690
We also have now functions for managing
user preferences both for URL Scheme

00:55:12.830 --> 00:55:15.600
bindings and also for document bindings.

00:55:15.600 --> 00:55:21.600
And we can do this for document bindings,
or if you will,

00:55:21.600 --> 00:55:25.600
binding preferences for document
types because we have UTIs now.

00:55:25.600 --> 00:55:30.030
It used to be that it was very complex
to do it because you could have a

00:55:30.030 --> 00:55:34.800
different binding for extension JPG and
a different binding for JPEG and a

00:55:34.800 --> 00:55:36.600
different binding for OS Type JPEG.

00:55:36.610 --> 00:55:38.600
And we didn't really want that.

00:55:38.600 --> 00:55:41.600
That's impossible for
the user to understand.

00:55:41.810 --> 00:55:46.130
So instead,
we have an API which is centered around

00:55:46.140 --> 00:55:51.930
UTIs and you have one binding for
Type JPEG and you have another binding

00:55:51.960 --> 00:55:54.600
for Type TIFF and what have you.

00:55:54.600 --> 00:55:59.600
And these allow you to inspect the
user preferences as well as set them.

00:55:59.600 --> 00:56:03.260
And if you're going to set them,
I just encourage you to do it on the

00:56:03.260 --> 00:56:05.600
user's behalf and not just slam things.

00:56:05.600 --> 00:56:06.790
Thank you.

00:56:09.960 --> 00:56:15.780
These new API are in these two
header files mentioned here.

00:56:16.030 --> 00:56:19.710
The last topic I want to talk about
was drag and drop service invocation.

00:56:19.740 --> 00:56:23.390
I just have a couple of minutes left,
but this is something that

00:56:23.390 --> 00:56:24.900
you might not be aware of.

00:56:24.900 --> 00:56:27.120
If you came to my talk last year,
you're aware of it,

00:56:27.230 --> 00:56:36.310
but it's always worth showing it
again because it's a nice little

00:56:36.320 --> 00:56:36.570
service that your app can offer
if it doesn't support it already.

00:56:36.820 --> 00:56:43.160
If you look up in most applications,
you look up in the File menu,

00:56:43.160 --> 00:56:43.160
there's a Services item.

00:56:43.450 --> 00:56:48.490
And the contents of the Services submenu
change depending on what's selected in

00:56:48.490 --> 00:56:50.370
the document window that is in front.

00:56:50.370 --> 00:56:54.720
If it's text,
you get certain services available that

00:56:54.720 --> 00:56:57.400
are provided by other applications.

00:56:57.560 --> 00:57:00.830
So for instance,
Safari has a service that will do

00:57:00.930 --> 00:57:03.400
a Google search on text selected.

00:57:03.400 --> 00:57:10.100
Well, the Services menu is great and it's
brought over from Next Step days

00:57:10.150 --> 00:57:14.470
and it does some really nice things,
but it's a little inconvenient.

00:57:14.570 --> 00:57:17.400
And so we realized we had all the
technology available to integrate

00:57:17.400 --> 00:57:21.750
it with drag and drop and make it
happen in the dock and really leverage

00:57:21.750 --> 00:57:26.400
the dock as an always present,
always on top drag destination.

00:57:26.630 --> 00:57:31.220
And rather than talk about this anymore,
I think I'll just show it to you.

00:57:31.390 --> 00:57:33.400
So can I have the demo machine?

00:57:33.400 --> 00:57:36.640
Demo one.

00:57:39.990 --> 00:57:41.800
Prior to Tiger,
the only thing you could drag

00:57:41.800 --> 00:57:46.020
down to the doc and drop onto
an application was document.

00:57:46.040 --> 00:57:50.370
A lot of apps will
properly make links live,

00:57:50.520 --> 00:57:51.660
URLs live.

00:57:51.770 --> 00:57:57.810
But you still find yourself in a
lot of cases wanting to open a URL,

00:57:57.810 --> 00:57:59.560
and you can't just click on it.

00:57:59.610 --> 00:58:00.890
And now there's a pretty simple gesture.

00:58:00.960 --> 00:58:03.330
If I can get the timing right.

00:58:03.610 --> 00:58:06.990
Select something, grab it, drag it down.

00:58:07.060 --> 00:58:11.830
It gets turned into a
get URL event and sent to

00:58:12.070 --> 00:58:13.930
sent off to Safari.

00:58:14.010 --> 00:58:17.740
Yeah, this is very natural stuff,
and Safari didn't have to

00:58:17.800 --> 00:58:19.540
change to make this work.

00:58:19.540 --> 00:58:21.690
We just added it to the
dock in the Launch Services.

00:58:21.910 --> 00:58:23.540
You can grab some text.

00:58:23.660 --> 00:58:25.020
I don't want to select that image,
though.

00:58:25.020 --> 00:58:29.020
I'm going to go down here.

00:58:30.200 --> 00:58:32.190
Grab some text.

00:58:32.200 --> 00:58:36.950
I can go, say, to-- back to TextEdit.

00:58:36.970 --> 00:58:41.440
I wanted to save this off to the side.

00:58:41.440 --> 00:58:45.970
And--oh, you're thinking it didn't work.

00:58:45.970 --> 00:58:45.970
Well, actually, it did.

00:58:45.970 --> 00:58:45.970
It's just white.

00:58:45.970 --> 00:58:45.970
This web page has to be white.

00:58:45.970 --> 00:58:45.970
In fact, I can go to plain text.

00:58:46.510 --> 00:58:47.380
And there we go.

00:58:47.460 --> 00:58:48.530
There's the text back.

00:58:48.650 --> 00:58:53.020
Again, that's using TextEdit's service
which opens a text selection

00:58:53.420 --> 00:58:55.400
in a new untitled window.

00:58:55.700 --> 00:59:00.720
Now I mentioned that you can
do Google searches with Safari.

00:59:00.740 --> 00:59:04.400
And so let's say I want to learn
more about Siberian tigers.

00:59:04.440 --> 00:59:08.180
I can select that, grab,
drag it down to Safari.

00:59:08.520 --> 00:59:11.680
And since it's not a URL,
what Safari does instead is open

00:59:11.680 --> 00:59:13.400
a new window with a Google search.

00:59:13.420 --> 00:59:15.220
I can look for images.

00:59:15.670 --> 00:59:18.400
And here's an image that I like.

00:59:18.400 --> 00:59:20.400
Let me look at the full-size image here.

00:59:20.400 --> 00:59:25.700
I like this because it looks like the
last photograph this guy ever took.

00:59:26.570 --> 00:59:28.160
But this works even with images.

00:59:28.160 --> 00:59:33.100
You can drag an image in Safari and let's
say you like that and you want to borrow

00:59:33.260 --> 00:59:36.000
it for a while and import it into iPhoto.

00:59:36.000 --> 00:59:38.780
You just drag it down to iPhoto,
it launches and it imports

00:59:38.860 --> 00:59:40.250
the image into the library.

00:59:40.400 --> 00:59:45.400
So this is just some very nice gestures,
very convenient, easier than copy/paste,

00:59:45.400 --> 00:59:49.400
easier than using the service
menu up in the file menu.

00:59:49.400 --> 00:59:51.370
So what do you need
to do to support this?

00:59:51.400 --> 00:59:56.190
Well, if you already have services
advertised in your InfoP list,

00:59:56.190 --> 00:59:58.380
then you probably already support it.

00:59:58.400 --> 01:00:01.370
If you--oh, can we go back to the slides?

01:00:01.370 --> 01:00:02.810
Sorry.

01:00:06.070 --> 01:00:10.080
If you don't, then I encourage you
to read about services.

01:00:10.080 --> 01:00:15.340
It's basically an NS Services entry in
your Info.plist and you can advertise

01:00:15.440 --> 01:00:17.320
what types of data you act on.

01:00:17.530 --> 01:00:21.070
In this case,
the services can send and return

01:00:21.070 --> 01:00:24.820
data and the only kind that you can
invoke through the dock are send only,

01:00:24.900 --> 01:00:27.320
the kind that don't return any data.

01:00:27.670 --> 01:00:31.190
The way we implement it behind the
scenes is a new Apple event so that

01:00:31.190 --> 01:00:35.200
we can just send an Apple event off to
your app and there's a default handler.

01:00:35.220 --> 01:00:38.200
It's called the
Open Contents Apple Event.

01:00:38.220 --> 01:00:39.800
You don't have to handle
the event directly.

01:00:39.800 --> 01:00:43.700
You can if you want to,
but we have a default handler that

01:00:43.700 --> 01:00:47.040
will actually just turn around,
take the data on the pasteboard or

01:00:47.170 --> 01:00:50.790
put the data back onto the pasteboard
and call your service function.

01:00:50.930 --> 01:00:54.220
So all you really have to do is
provide an NS Service and you'll

01:00:54.220 --> 01:00:58.090
show up in both the Services menu
and you'll work with the dock.

01:00:59.170 --> 01:01:01.700
So that's all I have to cover today.

01:01:01.700 --> 01:01:05.930
The things I'd like you to
take home and think about are:

01:01:05.970 --> 01:01:08.040
use uniform type identifiers,
use the ones that are

01:01:08.050 --> 01:01:11.480
built into the system,
read the documentation,

01:01:11.530 --> 01:01:17.620
and use them to simplify your app
and improve your user experience.

01:01:17.730 --> 01:01:20.920
Extend the system to really
integrate tightly with

01:01:21.330 --> 01:01:23.560
Tiger by declaring new types,
new UTIs.

01:01:23.560 --> 01:01:29.270
Think about the new launch services APIs,
see if they solve any problems

01:01:29.280 --> 01:01:32.840
you've been having with some
of the new options available.

01:01:33.100 --> 01:01:37.800
And also, think about offering services
now that there are multiple

01:01:37.800 --> 01:01:40.030
ways to use them on the system.

01:01:40.230 --> 01:01:40.470
That's it.

01:01:40.700 --> 01:01:41.880
Thank you very much for coming.

01:01:46.400 --> 01:01:47.830
I'm for QA.

01:01:47.960 --> 01:01:54.390
There's a-- By the way,
there's a-- The documentation

01:01:54.390 --> 01:01:57.580
I mentioned is on the web.

01:01:57.620 --> 01:02:03.160
Also, we're trying to get the final
version of simple text that I showed,

01:02:03.160 --> 01:02:03.160
that code,
we're trying to get that up there too

01:02:03.160 --> 01:02:03.160
so that you can take a look at that.
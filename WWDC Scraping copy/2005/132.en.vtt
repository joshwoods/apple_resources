WEBVTT

00:00:01.970 --> 00:00:04.580
Good morning.

00:00:04.580 --> 00:00:07.460
Welcome to session 132,
Implementing Networking

00:00:07.570 --> 00:00:09.660
Using the Cocoa Classes.

00:00:09.660 --> 00:00:10.680
My name is Chris Parker.

00:00:10.680 --> 00:00:13.410
I work on the Cocoa Frameworks
Team in the foundation and mainly

00:00:13.410 --> 00:00:15.180
our foundation and core foundation.

00:00:15.180 --> 00:00:20.400
But we're going to be talking a lot today
about working on networking in Cocoa.

00:00:20.400 --> 00:00:23.060
As a quick, just a quick show of hands,
how many people have actually used like

00:00:23.060 --> 00:00:25.840
the NS stream classes or CF network,
stuff like that?

00:00:25.840 --> 00:00:26.860
Okay.

00:00:26.950 --> 00:00:30.420
So some of this will be fairly
comfortable for a lot of you.

00:00:30.480 --> 00:00:32.570
We'll talk today about a lot
of the aspects of working

00:00:32.580 --> 00:00:33.920
with networking in Cocoa.

00:00:33.960 --> 00:00:38.320
So we'll talk about how to write
some basic TCP servers and clients.

00:00:38.320 --> 00:00:41.620
Using Bonjour effectively,
publishing on the net.

00:00:41.920 --> 00:00:43.320
When to use what classes?

00:00:43.440 --> 00:00:45.930
Cocoa doesn't cover all
of the networking stack,

00:00:45.940 --> 00:00:49.620
partly because there's a lot of stuff
to control down there that's going

00:00:49.620 --> 00:00:51.100
to be particular to your application.

00:00:51.100 --> 00:00:54.830
So we'll show some basic examples
on using CF socket and then

00:00:54.830 --> 00:00:57.100
wrapping that using NS stream.

00:00:57.100 --> 00:01:00.070
We'll show some examples later of
NSURL and actually using a little

00:01:00.070 --> 00:01:04.570
bit of CF HTTP message to store some
state in an example we'll do later.

00:01:04.700 --> 00:01:06.780
The examples that we'll build
up will start fairly simple.

00:01:06.840 --> 00:01:12.160
We'll work all the way up through to an
HTTP server example and then we'll do

00:01:12.170 --> 00:01:14.580
some more complicated client side stuff.

00:01:14.580 --> 00:01:17.540
So let's start with the really
basic clients and servers.

00:01:17.910 --> 00:01:23.580
The example code that's on your
download image has a TCP server,

00:01:23.580 --> 00:01:26.130
a Cocoa Echo example that
contains a TCP server,

00:01:26.130 --> 00:01:27.580
which is a simple code that's
on your download image.

00:01:27.580 --> 00:01:28.070
It has a TCP server,
a Cocoa Echo example,

00:01:28.070 --> 00:01:28.580
and a Cocoa Echo service.

00:01:28.580 --> 00:01:30.280
So it's a simple wrapper around the
CF socket to listen for incoming

00:01:30.280 --> 00:01:36.400
connections and then it'll go ahead
and publish a port both on IPv4 and V6.

00:01:36.400 --> 00:01:39.120
And this will advertise with
Bonjour automatically and it's

00:01:39.150 --> 00:01:41.700
by default implemented through
delegate-based connection handling.

00:01:41.720 --> 00:01:45.080
So when a connection comes in,
the delegate will be told about it.

00:01:45.080 --> 00:01:46.080
But you can override that.

00:01:46.080 --> 00:01:48.540
It's designed to be subclassable.

00:01:48.570 --> 00:01:51.020
So you can use this in your own code.

00:01:51.170 --> 00:01:55.300
The Cocoa Echo example is
just a simple Echo service.

00:01:55.300 --> 00:01:58.580
So it's very similar to the one
that we're using in the client.

00:01:58.580 --> 00:02:02.640
The server just subclasses TCP server
and it manages connection pairs.

00:02:02.690 --> 00:02:04.580
So we'll show you how that
looks in the code in a minute.

00:02:04.580 --> 00:02:07.180
And the client is just a
simple GUI application.

00:02:07.180 --> 00:02:12.240
It has a browser for services and then
we'll be able to click on some fields

00:02:12.240 --> 00:02:15.060
and send some text and get it back.

00:02:15.060 --> 00:02:19.760
You'll notice some things in the code
that these things do and don't do.

00:02:19.760 --> 00:02:22.580
So what they do is they offer
services on both V4 and V6.

00:02:22.580 --> 00:02:25.290
And we'd like to encourage you to do
this in your own programs as well,

00:02:25.290 --> 00:02:27.580
especially since the local network
provides a lot of services.

00:02:27.580 --> 00:02:30.770
browsing the Discovery Bonjour stuff,
all publishes addresses

00:02:30.790 --> 00:02:32.180
on both V4 and V6.

00:02:32.550 --> 00:02:35.650
It'll show you how to publish the
stuff with Bonjour and it actually

00:02:35.650 --> 00:02:37.680
handles events as asynchronous events.

00:02:37.680 --> 00:02:39.480
So we're not going to poll
these streams for events.

00:02:39.480 --> 00:02:42.640
We're going to wait for the stream
to tell us that something's happening

00:02:42.640 --> 00:02:44.280
and respond to those events.

00:02:44.370 --> 00:02:47.410
What they don't do is treat
IPv4 and IPv6 differently.

00:02:47.440 --> 00:02:50.940
If you're listening on those endpoints,
you're just going to be getting data,

00:02:50.940 --> 00:02:51.360
right?

00:02:51.460 --> 00:02:54.260
So whether it's a V4 address
or a V6 address isn't terribly

00:02:54.260 --> 00:02:57.270
interesting but we're going to
show you how to do both of that.

00:02:57.320 --> 00:02:59.570
It doesn't show the UI for
the Cocoa Echo example.

00:02:59.570 --> 00:03:01.370
It won't show the user
host names or ports,

00:03:01.370 --> 00:03:01.800
right?

00:03:01.840 --> 00:03:04.770
So for Bonjour browsing,
especially if I'm clicking on things,

00:03:04.770 --> 00:03:07.870
your user is mainly interested in
being able to just connect to the

00:03:07.870 --> 00:03:11.270
service and use it rather than,
"Oh, well, it's on this host and it's

00:03:11.270 --> 00:03:13.520
on this port and you have to
connect to it in this way." No,

00:03:13.520 --> 00:03:15.810
they just want to click
on it and start going.

00:03:15.840 --> 00:03:20.960
And I'm actually not resolving
the discovered services.

00:03:20.960 --> 00:03:23.320
There's some new API in
Tiger that lets me do that.

00:03:23.320 --> 00:03:29.460
So... You'll see in the Echo example
that we use code from all the way

00:03:29.470 --> 00:03:33.780
down in BSD sockets up through into
some stuff from Core Foundation.

00:03:33.900 --> 00:03:35.520
We use very little in CF Network.

00:03:35.520 --> 00:03:38.220
We use a lot of stuff in
Foundation and then the

00:03:38.380 --> 00:03:40.920
Cocoa Echo example wraps those classes.

00:03:40.920 --> 00:03:43.280
So we're using some
stuff from BSD sockets.

00:03:43.280 --> 00:03:46.600
CF socket from Core Foundation we
used to actually create things.

00:03:46.650 --> 00:03:49.230
And then we'll use NSInputStream
and NSOutputStream as the primary

00:03:49.230 --> 00:03:52.290
way to talk to those services.

00:03:53.130 --> 00:03:56.150
The Echo server, right,
servers do two things pretty much.

00:03:56.190 --> 00:03:59.330
They set up to listen for
incoming connections and they

00:03:59.330 --> 00:04:01.050
manage those connection pairs.

00:04:01.140 --> 00:04:03.200
So the Echo server,
when it handles a new connection,

00:04:03.200 --> 00:04:05.570
it's going to get an
incoming connection request.

00:04:05.640 --> 00:04:07.590
From there,
it will create a pair of streams.

00:04:07.590 --> 00:04:10.250
It will create an input stream
and an output stream to the remote

00:04:10.260 --> 00:04:13.090
side that's connecting and those
will be put into a dictionary.

00:04:13.100 --> 00:04:16.710
I'm just using a dictionary here in
order to manage these connections.

00:04:16.710 --> 00:04:19.140
We'll show a new,
different way to do that

00:04:20.120 --> 00:04:24.800
The Echo Server, once it handles data,
this becomes the delegate of the streams.

00:04:24.800 --> 00:04:27.680
So every time an event happens,
the delegate of the stream

00:04:27.720 --> 00:04:30.750
gets a callback on the
stream handle event method.

00:04:30.750 --> 00:04:36.540
Okay, so incoming data comes in on the
NS input stream for the source

00:04:36.540 --> 00:04:38.500
and we get stream handle event.

00:04:38.500 --> 00:04:42.340
And the Echo Server turns around
and looks up the corresponding

00:04:42.340 --> 00:04:46.390
NS output stream and writes that
data right out to the output stream.

00:04:46.390 --> 00:04:47.540
Okay.

00:04:47.540 --> 00:04:49.360
Let's take a look at this in code.

00:04:49.360 --> 00:04:50.380
Could I demo one, please?

00:04:54.180 --> 00:05:00.690
I have the Echo server here,
which if I blow this font size up,

00:05:00.730 --> 00:05:04.930
we'll see that it's just printing out
a little diagnostic here that says

00:05:04.930 --> 00:05:08.680
it's starting the server on this port,
but that's mainly for my

00:05:08.680 --> 00:05:10.550
convenience when I was debugging.

00:05:10.600 --> 00:05:14.230
If I run the Cocoa Echo client here,
we'll see that the server is,

00:05:14.270 --> 00:05:17.220
the service is discovered
as demo Echo service.

00:05:17.220 --> 00:05:23.090
And actually if I kill this here,
I should see it disappear.

00:05:23.090 --> 00:05:26.090
So there's Bonjour running.

00:05:28.480 --> 00:05:29.770
Fire that up again.

00:05:30.050 --> 00:05:31.400
So we have a new demo echo service.

00:05:31.400 --> 00:05:39.400
And when I click on it,
if I just type up here in the top box,

00:05:39.400 --> 00:05:39.400
is there an echo in here?

00:05:42.400 --> 00:05:45.840
And here, return,
I get that response back from the server.

00:05:45.840 --> 00:05:48.360
So it's a very simple example.

00:05:48.360 --> 00:05:51.420
Let me take a look at the code here.

00:05:53.040 --> 00:05:57.520
The TCP server itself is
pretty straightforward.

00:05:57.720 --> 00:05:59.960
We have a delegate object
that it keeps track of,

00:05:59.960 --> 00:06:02.940
some state about what domain and
name and type we're going to be

00:06:02.940 --> 00:06:06.870
using to publish this service,
and we actually keep track of

00:06:06.890 --> 00:06:09.380
the V4 and V6 sockets as well.

00:06:09.570 --> 00:06:13.880
There are some basic accessors.

00:06:13.880 --> 00:06:19.260
The main event here is handle
new connection from address.

00:06:19.260 --> 00:06:22.860
Every time a new connection comes in,
this method is going to get called with

00:06:22.860 --> 00:06:24.700
the input and output streams for that.

00:06:24.700 --> 00:06:27.560
We'll be able to use that as
a subclassing point later on.

00:06:27.720 --> 00:06:31.380
By default,
this is designed to hand a TCP server

00:06:31.470 --> 00:06:38.290
did receive connection from address input
stream and output stream to the delegate.

00:06:38.900 --> 00:06:44.530
So let's take a look at where
we listen for connections.

00:06:46.780 --> 00:06:54.060
This start code here is where
we actually set things up.

00:06:54.150 --> 00:06:57.480
So you'll see here at CF socket create,
we're creating two sockets.

00:06:57.490 --> 00:06:59.690
One's a V4 socket, one's a V6 socket.

00:06:59.690 --> 00:07:05.100
We're passing the V4 and V6 INET families
here as what we want to listen for.

00:07:05.100 --> 00:07:08.460
And we're telling the socket
create call that we want to be

00:07:08.460 --> 00:07:12.690
able to get callbacks on the,
for any accept events that come in.

00:07:12.690 --> 00:07:15.660
And we'll be called back on
this accept callback function.

00:07:15.660 --> 00:07:19.320
We try and handle some errors well,
providing an NSError that can

00:07:19.320 --> 00:07:20.860
be bubbled up to the user.

00:07:20.860 --> 00:07:24.460
And we set some
configuration options here.

00:07:24.460 --> 00:07:26.860
We set up the V4 endpoint.

00:07:26.860 --> 00:07:29.560
We're letting this,
this has the option to let the

00:07:29.560 --> 00:07:31.220
kernel choose a port for us.

00:07:31.250 --> 00:07:34.780
Once we get through all of this and
get everything successfully set up,

00:07:34.780 --> 00:07:38.460
we'll actually do the same
thing for the V6 endpoint.

00:07:38.460 --> 00:07:40.580
And this is all the same code.

00:07:40.660 --> 00:07:42.840
So you'll see some code that does
some stuff for the V4 endpoint,

00:07:42.860 --> 00:07:44.620
some code that does some things,
the same things for the V6 endpoint.

00:07:44.620 --> 00:07:51.080
And then once we get down
here to a success state,

00:07:51.080 --> 00:07:51.080
we'll be able to get the V4 endpoint.

00:07:52.080 --> 00:07:58.000
Once the two sources are set up,
we schedule these on the run loop

00:07:58.070 --> 00:08:03.900
and then in the main program we'll
actually start going on the run loop.

00:08:03.900 --> 00:08:06.090
If we were given a type,
we'll go ahead and publish this

00:08:06.090 --> 00:08:08.550
on Bonjour and that's just a
matter of making sure that we're

00:08:08.560 --> 00:08:12.320
publishing the correct domain with
the right name and then we just

00:08:12.320 --> 00:08:16.500
alloc and init the net service and
go ahead and tell it to publish.

00:08:16.500 --> 00:08:20.060
Okay, so the TCP server just
starts all this stuff up.

00:08:20.060 --> 00:08:22.140
It's a fairly straightforward class.

00:08:22.590 --> 00:08:28.260
And if we stop the service,
then we have to stop the net service,

00:08:28.260 --> 00:08:31.590
invalidate the sockets,
and just basically clean

00:08:31.590 --> 00:08:33.500
up after ourselves.

00:08:34.150 --> 00:08:36.740
Let's take a look at
dispatching that callback.

00:08:36.900 --> 00:08:40.410
When we get the accept event,
the TCP server accept callback

00:08:40.460 --> 00:08:43.390
is a function that gets called
through CF as a result of the

00:08:43.390 --> 00:08:47.020
CF socket getting an accept event.

00:08:47.020 --> 00:08:50.000
And we just go through and set up
some additional information to be

00:08:50.010 --> 00:08:51.580
able to pass it off to the client.

00:08:51.580 --> 00:08:54.810
You can go take a look at some of
the documentation for things like

00:08:54.810 --> 00:08:57.260
get peer name and what this is doing.

00:08:57.300 --> 00:08:59.700
And that's all on the developer CD.

00:08:59.700 --> 00:09:04.350
We create a pair with socket here with
CF stream create pair with socket.

00:09:04.370 --> 00:09:06.300
But once these streams are created,
we're going to take advantage of the

00:09:06.300 --> 00:09:09.920
toll-free bridge and start referring
to those as NS input streams and

00:09:09.940 --> 00:09:13.580
NS output streams once this gets moving.

00:09:13.580 --> 00:09:13.580
So, let's see.

00:09:13.980 --> 00:09:17.660
And here is where this callback calls
handle new connection from address.

00:09:17.660 --> 00:09:21.300
And this is where we can override.

00:09:21.360 --> 00:09:23.620
So if we look at that.

00:09:23.820 --> 00:09:25.080
This is pretty simple.

00:09:25.080 --> 00:09:26.230
Let me make this bigger.

00:09:26.240 --> 00:09:29.200
Get a little more text
on the screen here.

00:09:30.980 --> 00:09:34.270
All this does is if the delegate
implements the appropriate method,

00:09:34.270 --> 00:09:35.770
we go ahead and call it.

00:09:35.860 --> 00:09:39.400
So this will be where we subclass
things in the Echo server.

00:09:39.400 --> 00:09:44.110
So the TCP server class is just a basic
wrapper for all the stuff that you have

00:09:44.190 --> 00:09:46.400
to do to get a server up and running.

00:09:46.540 --> 00:09:53.360
So let's take a look at
the Cocoa Echo server here.

00:09:53.890 --> 00:09:56.160
Just fire things up on the Echo server.

00:09:56.360 --> 00:10:00.900
We have a main function here,
which just gives it a, we set up a name,

00:10:00.900 --> 00:10:03.920
a type, and we just ask it to start.

00:10:03.940 --> 00:10:07.200
So this is the TCP server start
method that gets fired up.

00:10:07.200 --> 00:10:11.580
Whenever this gets a new connection,
okay, we're actually overriding

00:10:11.600 --> 00:10:13.260
in Cocoa Echo server

00:10:14.700 --> 00:10:16.530
use the pop-up here.

00:10:16.610 --> 00:10:20.970
"Handle new connection from address."
So this is where we override this

00:10:20.980 --> 00:10:24.190
to do our own connection management,
and I'm just creating a dictionary

00:10:24.190 --> 00:10:26.920
if it's not already there,
and I put the--and I set up the

00:10:26.920 --> 00:10:28.900
input stream and the output stream.

00:10:28.900 --> 00:10:31.010
This method just goes ahead
and it opens the streams up,

00:10:31.060 --> 00:10:33.730
schedules them on a run loop
and it also sets this class as

00:10:33.820 --> 00:10:36.250
the delegate of these streams,
okay?

00:10:36.250 --> 00:10:39.670
And that's all the setup input
stream and output stream method does.

00:10:39.910 --> 00:10:42.510
But now every time an event
occurs on one of these streams,

00:10:42.510 --> 00:10:47.010
this instance is going to get callbacks
on the stream handle event method.

00:10:47.300 --> 00:10:51.400
And that's, oddly enough,
the next method in the example code.

00:10:51.430 --> 00:10:53.300
Whenever the input stream
has bytes available,

00:10:53.300 --> 00:10:59.690
you get an NSStreamHasBytesAvailable
event as the stream event parameter

00:10:59.690 --> 00:11:01.280
here to stream handle event.

00:11:01.320 --> 00:11:06.980
And all we do here is look up the
corresponding output stream and then

00:11:06.980 --> 00:11:11.200
read in everything from the input stream
because it has those bytes available.

00:11:11.200 --> 00:11:14.690
And we turn around and we just write
them back out on the output stream.

00:11:14.810 --> 00:11:18.740
And if the end is encountered,
then we do some cleanup here.

00:11:18.740 --> 00:11:23.080
So every time I hit one of the, you know,
when I type in the text and I hit return,

00:11:23.080 --> 00:11:27.770
the server is getting that data from the
client and this is where it handles that.

00:11:30.560 --> 00:11:33.980
And in the client,
the client code is this

00:11:34.050 --> 00:11:36.570
echo client app delegate.

00:11:38.930 --> 00:11:45.120
So when things start up,
we just start a browser going.

00:11:45.120 --> 00:11:48.360
And I'm using bindings here in order
to get the stuff into the service list,

00:11:48.360 --> 00:11:50.360
so you can play around with that.

00:11:50.360 --> 00:11:54.460
But when a server is clicked,
we actually use this-- when somebody

00:11:54.500 --> 00:11:58.440
clicks on a server in that table view,
we use this selected service,

00:11:58.650 --> 00:12:01.360
get input stream, output stream.

00:12:02.010 --> 00:12:04.560
So if anybody's looked at
the picture sharing examples,

00:12:04.560 --> 00:12:06.600
when we wrote that,
we had to go through and construct

00:12:06.610 --> 00:12:09.980
a file handle and hook it up on an
FD and do all this stuff in order to

00:12:09.990 --> 00:12:11.450
be able to set up all the callbacks.

00:12:11.470 --> 00:12:14.250
This is a one-line method in order
to get the two streams to the other

00:12:14.470 --> 00:12:16.440
end of this discovered service.

00:12:16.500 --> 00:12:18.650
So you can just call that and
get the streams immediately.

00:12:18.650 --> 00:12:22.500
And then we go ahead
and open those streams.

00:12:22.500 --> 00:12:26.020
So and now, once again,
we're seeing stream handle events.

00:12:26.020 --> 00:12:29.920
So we get the event in here
when we get bytes available.

00:12:29.920 --> 00:12:33.580
We go ahead and read those in
until we see a carriage return.

00:12:33.580 --> 00:12:34.980
And at that point, we get

00:12:35.310 --> 00:12:40.920
Create the string, set the string value,
put it in that bottom field,

00:12:40.920 --> 00:12:43.020
and display the result to the user.

00:12:43.100 --> 00:12:47.450
And then if the remote side closes it,
then we just clean up and

00:12:47.450 --> 00:12:49.340
close these streams up.

00:12:50.540 --> 00:12:55.670
So the HTTP,
the Cocoa Echo server rather,

00:12:55.670 --> 00:12:59.260
also does the sending the text when I hit

00:13:00.300 --> 00:13:01.380
Send Text Method.

00:13:01.380 --> 00:13:04.020
When I hit the return
key in the top field,

00:13:04.080 --> 00:13:06.640
this actually just gathers
up the string and writes

00:13:06.640 --> 00:13:08.700
everything to the output string.

00:13:08.700 --> 00:13:13.090
We actually sit there and write
everything out until it's done.

00:13:15.470 --> 00:13:17.630
And that's it for the TCP server.

00:13:17.630 --> 00:13:20.900
If I could have the slides back, please.

00:13:20.900 --> 00:13:24.460
So again, it's been a while since
we've seen this slide,

00:13:24.460 --> 00:13:28.010
but what they do is they try very
carefully to do things on both v4 and

00:13:28.010 --> 00:13:31.160
v6 and publish stuff on Bonjour so that
your users can discover these things

00:13:31.160 --> 00:13:32.660
without having to go to too much trouble.

00:13:32.760 --> 00:13:34.610
We're not blocking the run
loop because we're going to

00:13:34.610 --> 00:13:36.940
handle events asynchronously,
but they're also not

00:13:36.940 --> 00:13:38.840
doing specific things.

00:13:38.840 --> 00:13:42.990
And one of them is not resolving
the discovered services,

00:13:43.000 --> 00:13:43.700
right?

00:13:43.830 --> 00:13:45.920
Causing too much network traffic
is something that makes everybody's

00:13:45.950 --> 00:13:47.470
network administrator yell at them.

00:13:47.470 --> 00:13:51.570
So if you can do this without actually
doing a full net service resolve on that,

00:13:51.570 --> 00:13:56.520
you can use the streams get
net service code to do that.

00:13:56.520 --> 00:13:57.920
So we're going to use this code.

00:13:57.920 --> 00:14:00.620
We're going to use the
TCP server code now to take a

00:14:00.620 --> 00:14:02.330
look at a basic HTTP server.

00:14:02.340 --> 00:14:06.340
You want me to get that?

00:14:06.610 --> 00:14:08.540
It subclasses TCP Server.

00:14:08.680 --> 00:14:11.860
We're going to override the handle
new connection method again.

00:14:11.910 --> 00:14:15.500
And we're going to do its
own HTTP connection object.

00:14:15.500 --> 00:14:17.600
So rather than just using a
dictionary to manage our connections,

00:14:17.600 --> 00:14:20.180
we'll use an actual full object
that's going to become the

00:14:20.180 --> 00:14:21.390
delegate of these streams.

00:14:21.510 --> 00:14:23.750
So every time a new
HTTP request comes in,

00:14:23.750 --> 00:14:26.640
we'll get one of these
new connection objects.

00:14:26.640 --> 00:14:29.120
And it inherits all the
other TCP server behavior.

00:14:29.120 --> 00:14:31.020
So this will get published on Bonjour.

00:14:31.020 --> 00:14:31.930
We'll see that.

00:14:31.930 --> 00:14:34.650
It will do it on both v4 and v6.

00:14:34.670 --> 00:14:36.480
And you'll be able to
connect that way as well.

00:14:36.500 --> 00:14:38.940
So every time one of these
new connection comes in,

00:14:38.980 --> 00:14:41.470
we're going to look at an
HTTP connection object.

00:14:41.490 --> 00:14:42.640
So the server fires up.

00:14:42.640 --> 00:14:44.310
It just listens for new connections.

00:14:44.510 --> 00:14:45.550
A new connection comes in.

00:14:45.550 --> 00:14:47.320
We create an HTTP connection object.

00:14:47.320 --> 00:14:50.960
This will produce
HTTP server request objects.

00:14:50.990 --> 00:14:52.620
And it will inform the
delegate about them.

00:14:52.620 --> 00:14:54.880
So it has a delegate also.

00:14:54.880 --> 00:14:59.630
It's going to offer to send
those responses over there.

00:14:59.640 --> 00:15:03.920
The responses are processed in the
order that the requests were received.

00:15:03.980 --> 00:15:05.700
Because that's what the
protocol says we have to do.

00:15:05.700 --> 00:15:06.480
But they may not necessarily be the same.

00:15:06.500 --> 00:15:09.360
It may not necessarily be the order
the delegate chooses to fulfill them.

00:15:09.360 --> 00:15:11.080
So there may be some
additional tracking here.

00:15:11.080 --> 00:15:13.320
We have some default behavior
built into this example.

00:15:13.320 --> 00:15:14.360
That's pretty nice.

00:15:14.360 --> 00:15:17.700
Basic get method processing is
done if no delegate is present.

00:15:17.700 --> 00:15:18.860
And that's the default behavior.

00:15:18.860 --> 00:15:20.800
So if you don't actually
assign a delegate,

00:15:20.810 --> 00:15:22.960
we'll just do some
basic fulfillment here.

00:15:22.960 --> 00:15:26.580
And this example actually,
specifically the HTTP connection class,

00:15:26.610 --> 00:15:28.940
shows some more sophisticated
asynchronous handling.

00:15:28.940 --> 00:15:32.260
And it involves buffering
up the bytes that come in.

00:15:32.280 --> 00:15:34.040
And we'll see that as well.

00:15:34.040 --> 00:15:37.880
The server now has...
It is subclass TCP server.

00:15:37.880 --> 00:15:40.570
So we're not going to see a whole
lot of API from the BSD sockets

00:15:40.570 --> 00:15:42.250
layer or from core foundation.

00:15:42.260 --> 00:15:45.440
But in CF network,
we're going to be using CF HTTP message

00:15:45.440 --> 00:15:50.010
refs as just a way to store things
in the server request objects.

00:15:50.020 --> 00:15:52.230
And this URL will be seen a
little bit in order to set up

00:15:52.240 --> 00:15:53.900
the document root for the server.

00:15:53.900 --> 00:15:55.510
But it's not part of the networking code.

00:15:55.520 --> 00:15:59.900
And the server just creates...uses all
of those to wrap these three classes.

00:15:59.900 --> 00:16:01.690
So...

00:16:02.470 --> 00:16:07.080
When an HTTP server fires up,
it's going to get a connection event.

00:16:07.080 --> 00:16:10.180
So it's going to get an incoming
connection which consists of

00:16:10.180 --> 00:16:13.740
somebody typing in something
into a browser and the browser is

00:16:13.740 --> 00:16:15.510
going to make the network request.

00:16:15.550 --> 00:16:18.300
At that point,
it creates an HTTP connection object.

00:16:18.300 --> 00:16:21.650
That HTTP connection object is
handling all those bytes that are

00:16:21.690 --> 00:16:25.240
being presented to it as a request for,
you know,

00:16:25.310 --> 00:16:28.180
a GET or a HEAD request from HTTP.

00:16:28.180 --> 00:16:32.280
When that request comes in,
it's going to service all of those bytes,

00:16:32.280 --> 00:16:35.620
pick them up all off the wire,
collect them into an HTTP server

00:16:35.620 --> 00:16:39.050
request object and send it off
to the delegate if one's present.

00:16:39.160 --> 00:16:41.540
If it isn't present,
we'll actually do some

00:16:41.570 --> 00:16:43.520
default processing for this.

00:16:43.520 --> 00:16:47.390
So let's take a look at the
code and do a quick demo.

00:16:49.000 --> 00:16:55.010
Close out our Cocoa Echo example
here and kill that.

00:16:55.910 --> 00:17:00.440
So I fired up just a little
Cocoa HTTP server here.

00:17:00.440 --> 00:17:05.050
And it says that it
started on port 49167.

00:17:05.100 --> 00:17:13.590
So let's go over here to
Safari and take a look here.

00:17:17.240 --> 00:17:21.650
If there were a Bonjour listing here,
you could click on it and you'd

00:17:21.680 --> 00:17:23.340
see the Cocoa HTTP server.

00:17:23.340 --> 00:17:27.940
You should be able to do that with the
code that's on your example code here.

00:17:27.940 --> 00:17:33.480
But let's just take a quick
look at how this works.

00:17:33.480 --> 00:17:33.480
If I go to localhost.com,

00:17:33.890 --> 00:17:39.460
We've configured the document
root of this server to be root.

00:17:39.460 --> 00:17:41.400
So we haven't implemented
any security on this.

00:17:41.400 --> 00:17:45.070
So you can happily go ahead using this
thing the way it's configured right now

00:17:45.070 --> 00:17:47.300
and get Etsy password off this computer.

00:17:47.300 --> 00:17:49.400
I'm not going to show you that.

00:17:49.400 --> 00:17:53.380
But I can look at Etsy host config,
let's say.

00:17:53.780 --> 00:18:00.220
And we see that this actually
does return that file.

00:18:01.150 --> 00:18:04.840
Apparently we're starting up a
bunch of things automatically.

00:18:04.870 --> 00:18:07.050
Let's take a look at the code.

00:18:07.360 --> 00:18:12.780
There are actually in http
server.h three classes declared.

00:18:12.960 --> 00:18:15.160
The first is this http server class.

00:18:15.160 --> 00:18:18.430
All this is,
it has a very small role in this code.

00:18:18.430 --> 00:18:21.660
It just fires up and
listens for connections.

00:18:21.660 --> 00:18:29.260
You'll see here that we actually override
the handle new connection method.

00:18:29.260 --> 00:18:32.560
We have a little set document
root method here as well.

00:18:32.560 --> 00:18:37.460
That's how we configure it to point at
a particular location on the hard drive.

00:18:37.460 --> 00:18:42.580
We look at the interface
for http connection.

00:18:42.580 --> 00:18:43.690
We've got some streams here.

00:18:43.690 --> 00:18:46.160
That's what's going to be doing
the talking to the web browser or

00:18:46.160 --> 00:18:48.320
the client that's talking to us.

00:18:48.320 --> 00:18:50.310
We have some buffering going on,
an input stream,

00:18:50.320 --> 00:18:51.560
an input buffer and an output buffer.

00:18:51.560 --> 00:18:54.320
This is where we're going to keep
the bytes as we service them and then

00:18:54.320 --> 00:18:57.690
when events come in on the stream,
that's when we'll actually

00:18:57.700 --> 00:19:00.290
touch off the reads and writes.

00:19:00.410 --> 00:19:05.270
There's some other bookkeeping here,
but we won't cover that.

00:19:05.340 --> 00:19:08.290
And this HTTP server request object,
I'm not going to talk too much about

00:19:08.350 --> 00:19:13.690
this because this is basically just a
model object to hold and encapsulate

00:19:13.690 --> 00:19:16.720
the request as it's being processed.

00:19:16.720 --> 00:19:21.950
So this will contain things like the body
and the header and things like that for

00:19:21.950 --> 00:19:25.160
the actual handling of the HTTP messages.

00:19:25.160 --> 00:19:30.090
So these are what get
handed off to the delegate

00:19:30.250 --> 00:19:36.530
Let's take a look at HTTP Server.

00:19:36.530 --> 00:19:40.110
We're going to handle
new connections here.

00:19:41.020 --> 00:19:46.530
and HTTP Server just by
creating a new HTTP connection.

00:19:46.840 --> 00:19:52.740
Setting the connections delegate
as the server's delegate.

00:19:52.740 --> 00:19:55.820
And then just saying if the
delegate responds to the selector

00:19:55.890 --> 00:20:01.380
HTTP did make new connection,
then we send that message off.

00:20:01.380 --> 00:20:03.700
But at this point we've got
this HTTP connection around.

00:20:03.700 --> 00:20:07.800
It's going to take care of doing
all the heavy lifting for us.

00:20:07.870 --> 00:20:13.060
So let's take a look at that.

00:20:14.150 --> 00:20:21.460
The streams are the delegate here and
when we get a stream handle event,

00:20:21.460 --> 00:20:23.570
the input stream will tell us, "Hey,
I've got bytes available."

00:20:23.570 --> 00:20:26.090
A get request is coming in.

00:20:26.990 --> 00:20:33.570
So we go through and read as many bytes
as we can from that and then just go

00:20:33.580 --> 00:20:36.220
in here to self-process incoming bytes.

00:20:36.220 --> 00:20:41.530
And all processing incoming bytes does is
construct an HTTP server request object.

00:20:41.590 --> 00:20:43.920
So it's building up bytes
as a request comes in.

00:20:44.030 --> 00:20:47.690
For a big request,
it might come in in three or four reads.

00:20:49.050 --> 00:20:54.080
So Process Incoming Bytes
really just goes through and

00:20:54.080 --> 00:20:56.320
collects all of this information.

00:20:56.320 --> 00:20:59.520
So it collects the headers,
the content length.

00:20:59.520 --> 00:21:01.420
If it's a post,
it will actually collect all of that

00:21:01.420 --> 00:21:05.360
body information although we're not going
to use that in this particular example.

00:21:05.390 --> 00:21:08.670
And then once we've got a full request,
we create one of these server

00:21:08.710 --> 00:21:11.770
request objects and we hand
it off to the delegate.

00:21:11.950 --> 00:21:14.420
So the delegate is going to either
get--if there is a delegate,

00:21:14.420 --> 00:21:16.360
it will get a chance to handle it.

00:21:16.360 --> 00:21:18.620
If not, we'll do this default request

00:21:18.810 --> 00:21:22.980
Okay, so we've gotten bytes,
we've built up the server request object,

00:21:23.180 --> 00:21:28.610
we're going to hand it off to our
default request handling method.

00:21:29.120 --> 00:21:34.530
Which really just sort of crawls
through the CFHGTV message ref and

00:21:35.160 --> 00:21:39.600
here's the interesting bit here where
it's if method is equal to get or head.

00:21:39.600 --> 00:21:42.620
So we've made it, we had a get or a head
request made of us.

00:21:42.620 --> 00:21:46.190
We grab all those bytes,
copy some information out,

00:21:46.310 --> 00:21:50.920
set up the response and just
try to write those bytes out.

00:21:50.920 --> 00:21:54.910
And that's actually, I'm going

00:22:02.800 --> 00:22:06.320
Let's see my note here.

00:22:06.320 --> 00:22:13.030
So the default request handling,
that was this method here and then

00:22:13.920 --> 00:22:18.260
That just queues up all
the bytes into a buffer.

00:22:18.360 --> 00:22:20.640
So we've got them all set here,
but we haven't actually put them

00:22:20.640 --> 00:22:22.280
back out to the outgoing wire.

00:22:22.280 --> 00:22:25.420
So Safari,
the web browser that we're using,

00:22:25.420 --> 00:22:27.250
hasn't actually gotten a
chance to see these bytes yet.

00:22:27.260 --> 00:22:29.890
When an output stream
is available to write,

00:22:30.020 --> 00:22:33.750
it has space available,
you'll get this has space available

00:22:33.750 --> 00:22:36.110
event on the stream handle event.

00:22:36.110 --> 00:22:39.210
And all that does is it
calls process outgoing bytes.

00:22:40.620 --> 00:22:43.460
Process outgoing bytes just goes
through and says I've got all this data,

00:22:43.820 --> 00:22:46.430
write as big a chunk
as I can and get out.

00:22:46.440 --> 00:22:48.980
So it may actually take two or
three different writes to be

00:22:48.980 --> 00:22:50.310
able to get all this data out.

00:22:50.320 --> 00:22:54.090
So every time a new stream event
comes in that says I've got bytes,

00:22:54.250 --> 00:22:57.010
I have space available,
I'm going to go ahead and

00:22:57.020 --> 00:22:58.350
write those bytes out.

00:22:58.360 --> 00:22:59.570
So we buffer the stuff up.

00:22:59.570 --> 00:23:01.780
Every time a new event comes in,
we just write as many

00:23:01.780 --> 00:23:02.700
bytes out as we can.

00:23:06.170 --> 00:23:07.400
And that's really about it.

00:23:07.400 --> 00:23:12.960
We do some cleanup for when an error
occurs or when the streams end,

00:23:12.960 --> 00:23:17.470
but it's pretty straightforward as
far as the networking code goes.

00:23:17.500 --> 00:23:20.190
So there are things to keep
in mind there about it.

00:23:20.190 --> 00:23:24.750
But most of the work is going to be
touched off by stream events coming in.

00:23:24.830 --> 00:23:28.940
So if I could have the slides back,
please.

00:23:31.310 --> 00:23:34.140
This is not a complete HTTP server.

00:23:34.210 --> 00:23:37.670
No, you cannot try and serve your
website off of this and expect

00:23:37.670 --> 00:23:40.730
it to survive a slash dotting.

00:23:40.910 --> 00:23:44.300
It hands off most of the
processing to the delegate.

00:23:44.300 --> 00:23:47.140
So if there is a delegate,
it can do most of the heavy lifting,

00:23:47.140 --> 00:23:51.530
populate the server request object,
and then allow that to be sent back

00:23:51.630 --> 00:23:53.500
to the connection for processing.

00:23:53.500 --> 00:23:58.120
So it doesn't do things like, you know,
it doesn't handle chunk transfer coding,

00:23:58.130 --> 00:24:00.120
so you can't do stuff in series.

00:24:00.120 --> 00:24:03.190
But if you do want to make this
into the next Apache killer,

00:24:03.190 --> 00:24:05.160
first of all, more power to you.

00:24:05.170 --> 00:24:06.410
Knock yourselves out.

00:24:06.960 --> 00:24:10.760
RFC 2616 describes the HTTP 1.1 protocol.

00:24:10.860 --> 00:24:13.720
So this server actually does
do some Keepa lifestyle stuff.

00:24:13.720 --> 00:24:19.710
But this is, it's about as entertaining
reading as you might expect,

00:24:19.720 --> 00:24:21.900
but it's where you have to go to do this.

00:24:21.990 --> 00:24:24.590
So at this point,
I'd like to invite Doug Davidson up

00:24:24.680 --> 00:24:27.340
on stage to talk about
updating your application.

00:24:27.340 --> 00:24:30.200
He's going to do some
stuff for NSURL download.

00:24:34.800 --> 00:24:36.200
Thank you, Chris.

00:24:36.260 --> 00:24:40.020
So what we've just seen
covers how to handle general

00:24:40.020 --> 00:24:42.440
networking at a fairly low level.

00:24:42.460 --> 00:24:45.900
What I want to talk about is
how Cocoa makes it easy to deal

00:24:45.900 --> 00:24:49.800
with some standard net protocols
at a rather higher level.

00:24:49.800 --> 00:24:54.300
And naturally we have a sample
application to demonstrate this.

00:24:54.570 --> 00:24:58.980
And the problem that we've chosen to
tackle is that of having an application

00:24:59.520 --> 00:25:03.800
check for updates to itself over
the network and then download them.

00:25:04.860 --> 00:25:07.680
And we're not going to deal
with all of that problem.

00:25:07.810 --> 00:25:11.700
We're mostly ignoring questions
like when you schedule checking for

00:25:11.700 --> 00:25:15.790
updates and how you actually install
the updated version once it arrives.

00:25:15.950 --> 00:25:20.490
We're really just going to deal
with the networking aspects of this.

00:25:21.710 --> 00:25:26.680
So what is the minimum that
you need to do updating?

00:25:26.700 --> 00:25:29.420
Well, first of all,
you have to start somewhere.

00:25:29.420 --> 00:25:31.540
So you're going to have
to have some net address,

00:25:31.640 --> 00:25:35.220
some URL that's hard-coded
into your application.

00:25:35.330 --> 00:25:38.330
And you're going to have to have
a server living at that address

00:25:38.560 --> 00:25:41.300
for the lifetime of your app.

00:25:41.450 --> 00:25:46.900
You will have to have built into your
1.0 version of the app some basic set

00:25:46.900 --> 00:25:51.380
of policies for when and how to update.

00:25:51.380 --> 00:25:55.800
You'll have to supply some version info
so you can determine whether to update.

00:25:55.800 --> 00:25:58.760
If you use licensing,
you provide licensing

00:25:58.760 --> 00:26:00.480
info as well possibly.

00:26:00.530 --> 00:26:04.310
And some user interface to
present this to the user.

00:26:05.710 --> 00:26:08.330
But of course, the critical question
for this session is,

00:26:08.390 --> 00:26:11.200
what networking APIs are
you going to use?

00:26:11.290 --> 00:26:13.700
As I said earlier,
what we want is something that will

00:26:13.700 --> 00:26:18.270
allow us to deal with standard net
protocols at a fairly high level.

00:26:18.380 --> 00:26:22.290
And what we're recommending here
is the use of the NSURL loading

00:26:22.290 --> 00:26:25.280
classes in Foundation.

00:26:25.280 --> 00:26:28.800
These are the classes that
WebKit uses when it loads a

00:26:28.800 --> 00:26:30.730
web page or other resource.

00:26:30.860 --> 00:26:35.120
So they're designed to deal with the
network as a modern browser does with

00:26:35.120 --> 00:26:38.120
all the complexity that that entails.

00:26:38.200 --> 00:26:41.580
But they make it simple
because almost all of it will

00:26:41.580 --> 00:26:43.780
be dealt with automatically.

00:26:43.870 --> 00:26:48.140
You deal only with the parts
you're specifically interested in.

00:26:48.140 --> 00:26:50.200
What are the classes I'm talking about?

00:26:50.200 --> 00:26:58.140
NSURL request, NSURL response,
NSURL connection, and NSURL download.

00:26:58.140 --> 00:27:03.670
The protocols I handle, HTTP, HTTPS, FTP,
a few other minor ones,

00:27:03.670 --> 00:27:05.110
but those are the major ones.

00:27:08.070 --> 00:27:11.400
So you're probably already
familiar with NSURL,

00:27:11.410 --> 00:27:14.450
which represents a general
URL with all the various

00:27:14.550 --> 00:27:17.460
components that a URL can have.

00:27:17.680 --> 00:27:22.550
Well, NSUR-Request starts with a URL,
but it also includes all the

00:27:22.550 --> 00:27:26.600
other information that might go
into specifying a load request,

00:27:26.600 --> 00:27:31.470
a timeout interval, caching policy for
HTTP requests in particular,

00:27:31.470 --> 00:27:34.740
the request method, the headers,
the body.

00:27:34.900 --> 00:27:37.500
Now, as I said,
most of this is going to be

00:27:37.500 --> 00:27:41.590
generated automatically for you,
but there is a mutable subclass,

00:27:41.680 --> 00:27:46.120
NSMutableUrlRequest that lets you
change any of this if you want to.

00:27:46.120 --> 00:27:50.870
I'm not going to show that the
next portion of this talk will.

00:27:52.020 --> 00:27:53.760
Then NSUR Response.

00:27:54.080 --> 00:27:59.080
That represents the metadata associated
with a response to a load request.

00:27:59.230 --> 00:28:02.000
It might come from cache,
it might come from the network.

00:28:02.000 --> 00:28:05.480
This is things like the
URL that's finally loaded,

00:28:05.490 --> 00:28:10.010
the MIME type, content length, encoding,
and so on and so forth.

00:28:10.740 --> 00:28:12.420
So that's the metadata.

00:28:12.420 --> 00:28:15.080
What about the data?

00:28:15.080 --> 00:28:18.740
The data is the responsibility of the
class that actually does the loading.

00:28:18.740 --> 00:28:24.080
And there are two of those,
NSURLConnection, and NSURLDownload.

00:28:24.080 --> 00:28:25.830
Why two classes?

00:28:25.850 --> 00:28:32.160
Well, NSURLConnection corresponds to the
standard browser operation of loading a

00:28:32.170 --> 00:28:35.200
web page or other resource into memory.

00:28:35.200 --> 00:28:39.680
NSURLDownload corresponds to
the alternative operation of

00:28:39.680 --> 00:28:42.060
downloading a file to disk.

00:28:42.060 --> 00:28:46.090
They have a number of differences,
some obvious and some subtle.

00:28:46.260 --> 00:28:49.820
NSURLConnection, as I say,
downloads into memory.

00:28:49.820 --> 00:28:53.820
NSURLDownload to a file on disk.

00:28:53.820 --> 00:28:56.560
NSURLConnection can do caching.

00:28:56.560 --> 00:29:00.270
NSURLDownload doesn't,
but it has other features like

00:29:00.580 --> 00:29:03.140
the possibility of resumption
of interrupted downloads.

00:29:03.140 --> 00:29:06.840
NSURLDownload is probably the best
choice if you have huge amounts of data,

00:29:06.840 --> 00:29:07.640
for example.

00:29:07.640 --> 00:29:10.170
And there are some other minor
differences you can look through

00:29:10.180 --> 00:29:12.120
the documentation for those.

00:29:12.150 --> 00:29:14.470
What I want to emphasize, though,
is that they both operate

00:29:14.640 --> 00:29:16.650
fundamentally in the same way.

00:29:16.750 --> 00:29:22.000
And that is they message their
delegate asynchronously for

00:29:22.000 --> 00:29:28.570
all the various things that may
happen as a load request proceeds.

00:29:29.380 --> 00:29:34.370
And the delegate responds to as few
or as many of those as it wishes.

00:29:34.490 --> 00:29:38.720
So NSURL connection, for example,
sends the data directly to the delegate.

00:29:38.820 --> 00:29:42.150
NSURL download sends the data
to a file on disk and then

00:29:42.150 --> 00:29:44.120
tells the delegate about it.

00:29:44.250 --> 00:29:49.250
Your responsibility as a client
of either of these classes is to

00:29:49.900 --> 00:29:54.380
implement a delegate that will
handle whichever of the delegate

00:29:54.380 --> 00:29:54.380
methods you are interested in.

00:29:55.820 --> 00:29:58.360
There are a number of other
advanced topics that I'm

00:29:58.360 --> 00:29:59.860
not going to go into today.

00:29:59.950 --> 00:30:02.660
For those of you who are interested,
there's another session after lunch,

00:30:02.830 --> 00:30:07.330
Best Practices in Networking,
that will discuss some of the more

00:30:07.610 --> 00:30:12.450
interesting things that you may
encounter in real-world networks.

00:30:12.450 --> 00:30:14.400
It's an excellent session.

00:30:14.400 --> 00:30:16.490
I highly recommend it.

00:30:18.500 --> 00:30:21.720
So how is the sample
application going to work?

00:30:21.740 --> 00:30:26.660
The way we've chosen to implement this
is that the initial check to see if

00:30:26.660 --> 00:30:34.380
there are updates available is made with
an NSURL connection using an HTTP URL.

00:30:34.380 --> 00:30:37.450
And we've decided to encode the
version info for the current

00:30:37.530 --> 00:30:42.280
running version of the application
in the query string of that URL.

00:30:42.300 --> 00:30:44.300
Then we send it to the server that way.

00:30:44.340 --> 00:30:45.780
The server then responds.

00:30:45.780 --> 00:30:47.720
It's a very simple response.

00:30:47.740 --> 00:30:52.870
If there is an update available,
the response contains a URL from which

00:30:52.870 --> 00:30:56.290
the updated version is to be downloaded.

00:30:56.430 --> 00:31:01.320
We present this to the user and
ask if the user wishes to update.

00:31:01.560 --> 00:31:05.190
And if the user agrees,
then we use an NSURL download to

00:31:05.340 --> 00:31:09.790
download the updated version of
the application from that URL.

00:31:09.790 --> 00:31:11.490
It might be an HTTP URL.

00:31:11.490 --> 00:31:12.870
It might be an FTP.

00:31:12.870 --> 00:31:14.710
It's all handled the same

00:31:15.880 --> 00:31:18.490
Now,
there's one thing I think I must mention,

00:31:18.500 --> 00:31:21.370
that is, if you are going to do
something like this for real,

00:31:21.460 --> 00:31:25.000
you do have to take
security into consideration.

00:31:25.110 --> 00:31:30.390
My general recommendation is that this
is usually best handled end to end,

00:31:30.530 --> 00:31:34.560
probably with some sort of digital
signature so that you can make sure,

00:31:34.600 --> 00:31:37.120
however the update
arrives on the machine,

00:31:37.270 --> 00:31:41.230
that you can verify it's authentic
before you try to use it.

00:31:41.310 --> 00:31:43.190
Just as a caution.

00:31:44.150 --> 00:31:46.620
Now,
let's confirm where we are on the stack.

00:31:46.940 --> 00:31:51.350
We're using foundation
APIs to deal with the network,

00:31:51.550 --> 00:31:55.420
and then our application
sits on top of those.

00:31:55.510 --> 00:31:56.850
So now let's take a look at some code.

00:31:56.850 --> 00:31:59.900
If we could go over to demo one.

00:32:05.790 --> 00:32:06.500
It's very simple.

00:32:06.500 --> 00:32:09.560
There's only one class that's going
to act as a delegate for both the

00:32:09.560 --> 00:32:14.140
URL connection and the URL download.

00:32:14.550 --> 00:32:15.640
Here's where we start off.

00:32:15.770 --> 00:32:17.550
Here's our one hard-coded URL.

00:32:17.720 --> 00:32:21.200
Did you notice that we're encoding
in the query string the current

00:32:21.200 --> 00:32:25.190
version of the application to
send it to the server that way?

00:32:25.360 --> 00:32:28.090
And when we start off,
when the user chooses

00:32:28.220 --> 00:32:32.310
to check for updates,
we first of all create a

00:32:32.310 --> 00:32:35.130
URL request with that URL.

00:32:35.420 --> 00:32:39.360
And then URL connection
with that request.

00:32:39.360 --> 00:32:41.500
And then we fire it off.

00:32:43.820 --> 00:32:47.040
Now, as I said,
what's important are the delegate

00:32:47.100 --> 00:32:49.910
methods for the URL connection.

00:32:49.910 --> 00:32:52.400
And let's take a look at those.

00:32:53.210 --> 00:32:56.970
So the first one is the
didReceiveResponse delegate method

00:32:57.130 --> 00:32:59.940
when initial response comes back.

00:32:59.940 --> 00:33:05.130
And we're just making a note of
that and changing our status string.

00:33:06.590 --> 00:33:09.920
And then there's the did
receive data method that will

00:33:09.970 --> 00:33:12.720
be sent when data arrives.

00:33:12.820 --> 00:33:15.180
Now as I said,
the oral connection delivers the

00:33:15.190 --> 00:33:16.450
data directly to the delegate.

00:33:16.520 --> 00:33:17.500
We're the delegate.

00:33:17.500 --> 00:33:18.500
We're responsible for it.

00:33:18.500 --> 00:33:22.490
We hang on to it and we do it with
immutable data to which we append it.

00:33:23.730 --> 00:33:26.180
And then finally,
one of two things will happen.

00:33:26.280 --> 00:33:30.590
The load will either succeed,
finish loading, or it will fail,

00:33:30.600 --> 00:33:31.840
fail with error.

00:33:31.940 --> 00:33:35.880
And in either case,
we're going to present that to the user.

00:33:36.090 --> 00:33:38.690
If it succeeded,
then we're going to look at the response

00:33:38.750 --> 00:33:42.960
to the data we've accumulated and
see if it does represent the URL from

00:33:42.960 --> 00:33:45.540
which we could download the update.

00:33:45.630 --> 00:33:51.920
And if it did, we'll create that URL and
then we'll go and ask the user

00:33:51.940 --> 00:33:54.550
whether they wish to download.

00:33:54.740 --> 00:33:58.470
And if they do,
the process is very similar.

00:33:58.540 --> 00:34:02.690
We'll create a URL request with that URL.

00:34:03.300 --> 00:34:08.430
And then a URL download with
that request and fire it off.

00:34:08.430 --> 00:34:13.240
And we set a location on the
disk for that file to go.

00:34:14.320 --> 00:34:19.630
And again, the important things are
the delegate methods.

00:34:20.700 --> 00:34:23.500
Again, we have a did receive
response delegate method.

00:34:23.550 --> 00:34:27.630
When the initial response is received,
we'll make a note of that.

00:34:27.890 --> 00:34:31.900
And then, as I said,
NSURLDownload sends the data to the file

00:34:31.900 --> 00:34:34.330
and disk and tells the delegate about it.

00:34:34.440 --> 00:34:39.480
Now, ordinarily here in this,
we have an indefinite progress indicator

00:34:39.480 --> 00:34:43.750
showing that something is going on,
but while we're downloading the update,

00:34:43.750 --> 00:34:46.340
we want to present a definite
progress indicator to show

00:34:46.340 --> 00:34:47.800
the user how it's progressing.

00:34:47.800 --> 00:34:52.800
So, the URL download just tells
us how many bytes came in.

00:34:52.800 --> 00:34:56.800
We keep track of that and we compare the
total number of bytes that have come in

00:34:56.800 --> 00:35:01.160
to the expected length from the header,
and that tells us the progress that

00:35:01.160 --> 00:35:04.210
we can set on our progress indicator.

00:35:05.550 --> 00:35:07.840
Then again,
ultimately one of two things can happen.

00:35:07.840 --> 00:35:10.060
We either succeed or fail.

00:35:10.470 --> 00:35:14.140
And in either case we
present that to the user.

00:35:14.140 --> 00:35:18.200
So let's give this a try.

00:35:18.200 --> 00:35:20.410
Here's our application.

00:35:22.130 --> 00:35:27.310
Really,
it does almost nothing but update itself.

00:35:28.660 --> 00:35:32.030
So in this case,
we've set it up so the user

00:35:32.030 --> 00:35:34.100
chooses one to check for updates.

00:35:34.100 --> 00:35:34.990
So let's try it.

00:35:34.990 --> 00:35:36.500
We're connecting to our server.

00:35:36.500 --> 00:35:39.690
I have a bit of a slow server here.

00:35:40.530 --> 00:35:43.960
So there is an update available
and the choice is presented.

00:35:43.960 --> 00:35:45.800
Shall we try to update?

00:35:45.870 --> 00:35:47.900
No, let's go for it.

00:35:47.930 --> 00:35:49.030
Okay.

00:35:49.100 --> 00:35:51.590
Connecting, it's trying again.

00:35:52.900 --> 00:35:55.010
The response has been received,
now it's getting data.

00:35:55.150 --> 00:35:58.400
As the bytes come in,
we keep track of the number,

00:35:58.460 --> 00:36:03.610
we increment the progress indicator,
and it proceeds up.

00:36:04.420 --> 00:36:05.620
finished.

00:36:05.650 --> 00:36:07.850
And actually,
the thing that we downloaded

00:36:07.850 --> 00:36:09.120
here is a disk image.

00:36:09.250 --> 00:36:11.450
And so it's been opened for us.

00:36:11.580 --> 00:36:17.580
And so let's quit this
version of the application.

00:36:17.580 --> 00:36:17.580
And

00:36:19.850 --> 00:36:22.040
Go and look for version two.

00:36:22.040 --> 00:36:22.850
Let's try launching it.

00:36:23.010 --> 00:36:24.910
Oh, there it is.

00:36:26.800 --> 00:36:28.840
Version two, we've succeeded.

00:36:28.840 --> 00:36:31.910
Okay, so let's go back to the slides.

00:36:32.990 --> 00:36:35.900
Let me summarize.

00:36:35.900 --> 00:36:39.680
The NSUR Loading Classes
Foundation make it easy for you

00:36:39.680 --> 00:36:44.900
to deal with some standard network
protocols at a fairly high level.

00:36:44.900 --> 00:36:47.600
NSUR Connection, NSUR Download.

00:36:47.660 --> 00:36:52.790
Your responsibility as a client of
either of these classes is to implement

00:36:52.890 --> 00:36:58.170
a delegate that will handle as few or as
many of the delegate methods as you wish.

00:36:59.400 --> 00:37:01.940
So now I'd like to turn the
stage over to Chris Kane,

00:37:01.940 --> 00:37:05.880
who's going to talk to you
about Soap in the final portion.

00:37:05.960 --> 00:37:07.870
Thank you, Doug.

00:37:12.150 --> 00:37:13.840
Soap.

00:37:13.920 --> 00:37:18.000
Buzzword probably many of you have
heard over the last few years.

00:37:18.010 --> 00:37:22.120
Soap is a framework for exchanging
messages on the Internet.

00:37:22.120 --> 00:37:24.030
That's all it is.

00:37:24.230 --> 00:37:29.240
Now I'm using the word framework here
in a way that we're not typically

00:37:29.240 --> 00:37:30.660
using it here at this conference.

00:37:30.660 --> 00:37:36.030
When we talk about a framework,
we talk about a library and its APIs.

00:37:37.040 --> 00:37:45.230
In the case I'm using it here,
framework means the W3C has defined

00:37:45.230 --> 00:37:50.320
a spec which lays out the ground
rules by which a sender of a

00:37:50.320 --> 00:37:56.930
message and a receiver of a message
must follow in order to be able

00:37:56.940 --> 00:37:58.460
to communicate back and forth.

00:37:58.460 --> 00:38:02.430
So that's the sense in which
I'm using framework here.

00:38:02.600 --> 00:38:08.180
Now, I don't have nearly enough time to
go through and actually explain Soap.

00:38:08.620 --> 00:38:12.030
We would need probably several hours.

00:38:12.030 --> 00:38:17.290
And frankly, it's pretty boring stuff to
get down into all the details.

00:38:17.290 --> 00:38:22.070
So I'm going to be covering
things at a very sort of fast

00:38:22.070 --> 00:38:24.900
and high level here right now.

00:38:25.060 --> 00:38:30.430
So, Soap is a type of message
exchange protocol.

00:38:30.430 --> 00:38:37.970
And the typical use you find today
on the Internet is that a web service

00:38:38.120 --> 00:38:47.490
will expose its various functionalities
as Soap messages which you can send

00:38:47.620 --> 00:38:52.600
to the service in order to invoke
the service and produce some result.

00:38:52.730 --> 00:38:55.020
For example, Google.com.

00:38:55.060 --> 00:38:59.880
This web search site offers a
Soap API which you can use to

00:38:59.950 --> 00:39:06.230
send a message to Google and do a
search just like you would by say

00:39:06.260 --> 00:39:11.680
going to Google.com in Safari.

00:39:12.260 --> 00:39:22.000
Now, we could put Soap underneath
distributed objects in Cocoa.

00:39:22.000 --> 00:39:27.720
You know, one could implement using
the DO transport layer APIs,

00:39:27.840 --> 00:39:29.200
Soap as a transport layer.

00:39:29.200 --> 00:39:31.620
But in fact,
that would be a lot of work and

00:39:31.710 --> 00:39:33.720
really wouldn't buy you very much.

00:39:33.720 --> 00:39:36.260
So I'm not going to be
showing you that today.

00:39:36.820 --> 00:39:39.930
And of course,
one can use the Web Services Core APIs in

00:39:39.930 --> 00:39:41.830
the Core Services Framework.

00:39:41.910 --> 00:39:47.050
And those are there, you know,
fully realized in Panther and Tiger,

00:39:47.090 --> 00:39:49.880
introduced originally in Jaguar.

00:39:49.880 --> 00:39:53.150
So, you know,
if you're doing Soap things,

00:39:53.150 --> 00:39:57.030
one might typically go and
look at those first in order

00:39:57.030 --> 00:39:59.620
to implement their Soap thing.

00:39:59.620 --> 00:40:02.620
But I'm not going to use those
either because those have been

00:40:02.620 --> 00:40:06.350
shown before and there's plenty of
documentation on the web for those.

00:40:08.930 --> 00:40:19.670
Now, SOAP via HTTP and using XML is what
one may typically think of as SOAP.

00:40:19.670 --> 00:40:22.870
If you have experience
with the SOAP protocol,

00:40:22.970 --> 00:40:25.800
that's what you may think of SOAP as.

00:40:25.800 --> 00:40:31.510
A blob of XML sent over HTTP and
you get an HTTP response back

00:40:31.580 --> 00:40:36.800
with another blob of XML,
which is the SOAP response.

00:40:36.800 --> 00:40:40.940
But in fact,
SOAP is a very open and flexible API and

00:40:40.950 --> 00:40:47.100
this is probably because it was trying
to serve many different masters and a

00:40:47.170 --> 00:40:50.800
big huge committee of people who all
wanted it to do various different things

00:40:50.800 --> 00:40:54.300
and so they had to make it very open.

00:40:54.570 --> 00:41:02.000
And the end result is that, no, XML is,
you know, the text version of XML,

00:41:02.000 --> 00:41:05.640
XML 1.0,
is not actually required for Soap.

00:41:05.720 --> 00:41:09.320
You can use a binary form of XML,
for example.

00:41:09.320 --> 00:41:14.590
HTTP is not required
to do Soap messaging.

00:41:14.600 --> 00:41:20.050
You can use some other protocol or just
be writing raw XML bytes on a socket,

00:41:20.050 --> 00:41:21.280
for example.

00:41:22.920 --> 00:41:28.770
So, the, as a client of a web service,
the impact of this is that, well,

00:41:28.780 --> 00:41:33.490
you just have to do whatever
the web service has laid out as,

00:41:33.510 --> 00:41:35.900
here's how you contact us.

00:41:35.900 --> 00:41:42.760
The Google web service does
use XML 1.0 format messages,

00:41:42.760 --> 00:41:47.860
and we'll see an example of that,
over HTTP.

00:41:47.860 --> 00:41:51.980
But a web service could decide
that it wants to do something else.

00:41:52.240 --> 00:41:55.050
And as a client,
you simply have to do whatever the web

00:41:55.210 --> 00:42:00.560
service has laid out as the rules for
contacting and using the web service.

00:42:02.380 --> 00:42:06.330
In our particular example today,
we're going to simply cover

00:42:06.580 --> 00:42:08.830
Soap Messaging with Objective-C.

00:42:08.950 --> 00:42:13.300
That is, I'm going to wrap the Soap
Messaging in an Objective-C class.

00:42:13.300 --> 00:42:17.220
On the server side,
if we can go to the demo machine,

00:42:17.290 --> 00:42:20.640
I'm not going to actually
show you--oh wait,

00:42:20.640 --> 00:42:24.690
no, let me go back to the slides.

00:42:24.840 --> 00:42:25.980
I forgot to explain this.

00:42:26.160 --> 00:42:31.260
I'm not going to actually show you
the server side of things today,

00:42:31.790 --> 00:42:35.800
but all I did was reuse
the HTTP server example.

00:42:35.800 --> 00:42:38.720
On the client side,
as you can see in the slides,

00:42:38.720 --> 00:42:44.800
all I have is a simple SoapAdder class,
and the reason for that name

00:42:44.800 --> 00:42:46.800
will become clear in a moment.

00:42:47.000 --> 00:42:53.350
And all it does is use the NSXMLDocument
class to actually parse and serialize

00:42:53.350 --> 00:42:56.800
the XML that comprises the Soap message.

00:42:56.800 --> 00:43:01.890
And it uses the NSURL connection
and its related classes to do the

00:43:01.890 --> 00:43:04.790
HTTP component of the messaging.

00:43:05.060 --> 00:43:07.800
Now if we could go to the demo machine.

00:43:09.730 --> 00:43:18.940
I called it the Soap Adder Class because,
in fact, all it does, this example does,

00:43:18.940 --> 00:43:24.750
is take two arguments, two numbers,
send them off to the server and

00:43:24.890 --> 00:43:29.360
all the service does is add the
two numbers and return the result.

00:43:29.360 --> 00:43:32.540
So it's an extremely trivial activity.

00:43:33.580 --> 00:43:37.760
What I'm going to show you,
I'm going to try to go through

00:43:37.760 --> 00:43:42.500
the code in the order in which
the execution proceeds here.

00:43:42.700 --> 00:43:47.190
So we begin with the
client program in main.

00:43:48.120 --> 00:43:52.000
Well the first thing I do
is I make sure I have enough

00:43:52.000 --> 00:43:53.350
arguments on the command line.

00:43:53.350 --> 00:43:55.990
This is a very trivial tool.

00:43:56.440 --> 00:44:00.020
But the interesting stuff begins here.

00:44:00.070 --> 00:44:06.660
I create my SoapAdder class,
an instance of my SoapAdder class, and

00:44:08.230 --> 00:44:12.360
Parse the arguments off the command line.

00:44:12.470 --> 00:44:20.440
Call the method add to result in error,
which is the method I created to

00:44:20.440 --> 00:44:25.100
encapsulate the logic of sending
the soap message off and getting

00:44:25.100 --> 00:44:27.200
the reply back from the server.

00:44:27.200 --> 00:44:31.390
So at this point,
the main function is a client

00:44:31.390 --> 00:44:35.660
of this API and to the client,
the client doesn't know

00:44:35.680 --> 00:44:40.200
where this operation,
this add operation is going to go on.

00:44:40.200 --> 00:44:45.200
All that logic is encapsulated and
hidden off in the Soap Adder class.

00:44:45.200 --> 00:44:51.200
If I get success back from this method,
that is I get a response,

00:44:51.250 --> 00:44:52.200
I simply log it out.

00:44:52.200 --> 00:44:57.200
Otherwise I log the error out
and then the program exits.

00:44:57.200 --> 00:45:01.200
So there's really nothing much to that.

00:45:04.460 --> 00:45:07.760
The Soap Adder Class is
very straightforward.

00:45:07.800 --> 00:45:11.370
Again, nothing much to it either.

00:45:11.870 --> 00:45:15.560
I take the two arguments,
which I decided to call doubles,

00:45:15.600 --> 00:45:18.040
and I return a double by reference.

00:45:18.130 --> 00:45:22.140
I return a Boolean indicating
success or failure.

00:45:22.160 --> 00:45:27.490
And if there is a failure,
that is if the return value is no,

00:45:27.710 --> 00:45:37.200
then there will be an NSError returned
by reference in the last out parameter.

00:45:39.310 --> 00:45:42.370
What do I do in SoapAddr?

00:45:42.610 --> 00:45:47.270
Well, the only thing I did in the client
was I created a SoapAddr and

00:45:47.270 --> 00:45:49.820
then I sent it the add method.

00:45:50.300 --> 00:45:55.020
When I create a Soap Adder,
I need to look up the web service or,

00:45:55.090 --> 00:45:57.960
you know, get access to the web service.

00:45:58.090 --> 00:46:04.400
Now, normally, for, say,
using the Google web service,

00:46:04.400 --> 00:46:09.520
you wouldn't be using Bonjour to look up,
you know, Google.

00:46:09.520 --> 00:46:12.940
You'd just simply know, oh,
I need to use this particular URL.

00:46:12.940 --> 00:46:15.130
In this particular case,
I'm going to start my

00:46:15.130 --> 00:46:19.650
server on the local machine,
and I need to get the port number and the

00:46:19.650 --> 00:46:25.930
address of that to construct a NSURL that
I can use with NSURL connection.

00:46:27.510 --> 00:46:31.420
So I'm not going to go
through the details of,

00:46:31.420 --> 00:46:33.500
you know, resolving the net,
creating and resolving

00:46:33.500 --> 00:46:34.720
the net service here.

00:46:34.720 --> 00:46:37.740
I'm just going to skip
quickly through that.

00:46:37.740 --> 00:46:42.660
And the main point is that the main
product of the init method is simply

00:46:42.740 --> 00:46:49.280
to create the URL with the host
name and port number inside of it.

00:46:49.770 --> 00:46:52.600
The Add Method is where
the interesting stuff,

00:46:52.600 --> 00:46:57.570
if there's anything interesting here,
where the interesting stuff goes on.

00:46:58.380 --> 00:47:01.590
I'm using a very,
very simple technique here.

00:47:01.600 --> 00:47:03.930
I'm going to marshal my own arguments.

00:47:04.010 --> 00:47:07.850
I'm going to send the
message off on the Internet.

00:47:07.950 --> 00:47:12.800
I'm going to unpack then the arguments,
the result when it comes back.

00:47:12.960 --> 00:47:18.620
So I'm simply using a template
string here to marshal my arguments

00:47:18.620 --> 00:47:21.740
into a Soap compatible message.

00:47:21.740 --> 00:47:25.490
And so, you know,
I don't have time to go through

00:47:25.490 --> 00:47:30.580
all the details of what comprises
a Soap compatible message.

00:47:30.620 --> 00:47:33.510
But the main point here
is that here is the body,

00:47:33.630 --> 00:47:35.750
the actual goodies in the message.

00:47:35.990 --> 00:47:42.110
And what I'm going to do is I'm
going to invoke the method name,

00:47:42.110 --> 00:47:48.790
add service on my particular
server and pass it to parameters.

00:47:49.640 --> 00:47:54.390
The %f's then are going to be substituted
with those two double arguments

00:47:54.390 --> 00:47:57.240
that I passed to the add method.

00:47:59.180 --> 00:48:05.750
I'm using an NSXML document
here to simply

00:48:06.410 --> 00:48:14.530
How to serialize the
XML into the NNS data,

00:48:14.530 --> 00:48:19.410
which I'm going to write out
then as part of the HTTP request.

00:48:23.760 --> 00:48:30.830
So I created an NSMutable URL request
and I set its method to post.

00:48:30.860 --> 00:48:35.600
I want to include a body,
which is the Soap message in this case,

00:48:35.750 --> 00:48:37.470
with the request.

00:48:37.470 --> 00:48:39.510
So I need to use the post method.

00:48:39.600 --> 00:48:42.570
I set the body, which is my data.

00:48:42.570 --> 00:48:46.810
That's what I got back
from the NSXML document.

00:48:46.810 --> 00:48:49.750
And because there's a
body on the HTTP request,

00:48:49.750 --> 00:48:55.860
I need to make sure that there's
a content length header field set

00:48:55.860 --> 00:49:02.490
properly with the length of the
data on the NSMutable URL request.

00:49:02.490 --> 00:49:05.580
So I do that here.

00:49:07.870 --> 00:49:11.300
Then I create an NSURL connection.

00:49:11.300 --> 00:49:14.850
Actually,
I'm using a little tiny subclass with

00:49:14.850 --> 00:49:17.200
some convenience methods I added.

00:49:17.280 --> 00:49:19.980
But basically this is
an NSURL connection.

00:49:20.320 --> 00:49:23.150
I create it with the request.

00:49:23.780 --> 00:49:26.610
I wait until it has a response.

00:49:26.740 --> 00:49:31.410
Creating the NSURL request
sends the request off as part of

00:49:31.410 --> 00:49:39.630
creating the NSURL connection.

00:49:39.770 --> 00:49:42.290
I'm waiting for the response,
and this is one of the little

00:49:42.380 --> 00:49:45.040
convenience methods that I've added.

00:49:45.330 --> 00:49:48.210
Running the run loop while I wait.

00:49:49.010 --> 00:49:55.420
When I get a response back,
then I use NSXML document to

00:49:55.600 --> 00:49:57.980
parse out the data for me.

00:49:58.110 --> 00:50:05.210
Use XPath to go and retrieve
the particular node out

00:50:05.420 --> 00:50:07.120
of the XML that I want.

00:50:07.170 --> 00:50:12.750
In this case, it's a node buried three
levels deep called EX_result.

00:50:13.660 --> 00:50:19.670
And the result simply contains a
string which is the added number.

00:50:21.180 --> 00:50:25.480
This is a string representation
of the added number.

00:50:25.480 --> 00:50:30.190
So when I get a node back
from the XPath successfully,

00:50:30.280 --> 00:50:35.810
I go and get its object value and get
this double value out of that string.

00:50:36.050 --> 00:50:40.410
So let me,
well let's actually take a look here.

00:50:40.700 --> 00:50:41.730
We've got a little bit of time.

00:50:41.950 --> 00:50:45.500
Let's take a look here
at my URL connection.

00:50:47.730 --> 00:50:50.510
So what do I do here?

00:50:50.640 --> 00:50:55.360
Well, basically, my URL connection,
I just created a little subclass in

00:50:55.360 --> 00:51:01.980
order to collect the data for me and
keep track of when I get a response.

00:51:01.980 --> 00:51:04.540
So what do I do here?

00:51:04.540 --> 00:51:09.650
You saw in the previous segment that
Doug did the delegate methods of

00:51:09.710 --> 00:51:12.900
NSURL connection being implemented.

00:51:13.040 --> 00:51:16.590
Well, my little subclass implements
the delegate methods for me.

00:51:16.600 --> 00:51:21.680
And as data blocks come in here with
the did receive data delegate method,

00:51:21.680 --> 00:51:24.600
I simply append them,
accumulate them in an

00:51:24.620 --> 00:51:26.550
NSMutable data in memory.

00:51:26.560 --> 00:51:34.000
When I get the did finish loading method,
delegate method, then what I do is I just

00:51:34.030 --> 00:51:36.870
set my finished flag to yes.

00:51:36.880 --> 00:51:39.560
So then has response will return yes.

00:51:43.040 --> 00:51:47.310
Oh yeah, where is terminal?

00:51:51.510 --> 00:51:54.060
So let's go over to my project here.

00:51:54.060 --> 00:51:57.340
I've got a example already built.

00:51:57.550 --> 00:51:59.590
Let's blow this up.

00:52:09.060 --> 00:52:10.960
So I'm simply going to start my server.

00:52:10.960 --> 00:52:14.100
Now my server,
I just took the HTTP server example

00:52:14.100 --> 00:52:18.650
that you saw half an hour ago,
and I slapped a little, you know,

00:52:18.700 --> 00:52:22.430
Soap server on top,
which all it does is use NSXML document

00:52:22.430 --> 00:52:27.490
to parse the data in the Soap message,
add the two numbers,

00:52:27.490 --> 00:52:29.820
and create the Soap response.

00:52:29.860 --> 00:52:36.100
Let's see, what did I do wrong here?

00:52:36.100 --> 00:52:38.110
Oh, I didn't see the--

00:52:50.500 --> 00:52:55.390
Okay,
so server started up and client program,

00:52:55.390 --> 00:53:03.640
let's add 2.3 and 3.25
and comes back with 5.55,

00:53:03.640 --> 00:53:05.900
the sum of the two numbers.

00:53:06.030 --> 00:53:08.100
Nothing very interesting in that.

00:53:08.210 --> 00:53:13.400
In fact, I've just spent now, what,
a few million cycles to compute what

00:53:13.400 --> 00:53:19.070
normally you can do in about 10 or so,
add two floating point numbers.

00:53:19.300 --> 00:53:23.180
And, you know,
obviously that's not a very

00:53:23.180 --> 00:53:26.510
compelling example of a web
service in and of itself.

00:53:26.680 --> 00:53:32.410
But, you know, serves for the purposes of
my example because it's very

00:53:32.410 --> 00:53:34.320
simple and straightforward.

00:53:34.430 --> 00:53:40.660
Let me just quickly look at, let's see,
do I have it here?

00:53:40.770 --> 00:53:41.290
Yes.

00:53:41.410 --> 00:53:43.900
Do Google search.

00:53:45.330 --> 00:53:52.040
Here's an example of the Soap,
a Soap message which is invoking

00:53:52.040 --> 00:53:55.690
the Google Web Search service.

00:53:56.030 --> 00:53:59.220
Here we have the body, again,
of the message.

00:53:59.220 --> 00:54:02.780
And so this is the, you know,
sort of method invocation, if you will.

00:54:02.780 --> 00:54:06.010
And the method name, you know,
or the function that you're

00:54:06.010 --> 00:54:09.160
trying to invoke here is
the Do Google Search method.

00:54:09.160 --> 00:54:10.920
Here are the parameters.

00:54:10.920 --> 00:54:14.500
And of course, you know,
they've named the parameters

00:54:14.500 --> 00:54:18.440
very mnemonically,
you know, key and queue and, you know,

00:54:18.440 --> 00:54:20.880
who knows what LR and IER and so on.

00:54:21.390 --> 00:54:23.620
That's all part of their documentation.

00:54:23.800 --> 00:54:27.190
You simply have to, you know,
provide the data they want in the,

00:54:27.270 --> 00:54:29.280
you know, format that they want.

00:54:29.320 --> 00:54:32.180
But this would be, you know,
this is fairly straightforward.

00:54:32.180 --> 00:54:36.010
Again, you can see where you would just
substitute the parameters in here

00:54:36.010 --> 00:54:38.820
that you wanted to search for in,
you know,

00:54:38.820 --> 00:54:42.410
the same kind of way that I did it,
if you were just trying to be fast and

00:54:42.470 --> 00:54:44.950
loose and quick and dirty about it,
as I was.

00:54:44.960 --> 00:54:48.400
So let's go back to the slides.

00:54:56.350 --> 00:54:59.190
So, you know,
obviously my example could be abstracted

00:54:59.280 --> 00:55:00.840
further and generalized further.

00:55:00.840 --> 00:55:04.460
I just had the one method,
very uninteresting, Soap Service.

00:55:04.460 --> 00:55:06.360
Nothing much to that.

00:55:06.360 --> 00:55:10.180
I used a technique,
the marshalling my own arguments

00:55:10.180 --> 00:55:14.200
and parsing the return values,
right out of the 1980s.

00:55:14.200 --> 00:55:16.300
There's nothing interesting in that.

00:55:16.300 --> 00:55:19.940
I didn't use XDR,
and I'm not using SunRPC here.

00:55:19.940 --> 00:55:22.990
I'm using XML and Soap,
which are technologies

00:55:22.990 --> 00:55:25.300
of the 21st century,
but otherwise.

00:55:25.640 --> 00:55:28.510
It's basically the same kind
of thing that one has seen

00:55:28.520 --> 00:55:30.350
for the last two decades.

00:55:30.360 --> 00:55:32.340
It's just in new clothing.

00:55:34.110 --> 00:55:38.930
The key point though is that it's really
the underlying technologies that help me

00:55:38.930 --> 00:55:41.000
do this that eliminated most of my work.

00:55:41.000 --> 00:55:44.000
If I didn't have
NSXML document to do that,

00:55:44.000 --> 00:55:48.770
if I had to go down to an
XML parser API like a SACS parser

00:55:48.770 --> 00:55:52.000
API like NSXML parser and
do all the XML parsing myself,

00:55:52.000 --> 00:55:55.000
would I have done that
example the way I did it?

00:55:55.000 --> 00:55:57.990
No, I wouldn't have done that because
it would have been a lot of work.

00:55:58.000 --> 00:56:04.220
I would have done something else like
use the Web Services Core API which

00:56:04.400 --> 00:56:07.990
does the XML parsing and takes
care of all those details for you.

00:56:08.000 --> 00:56:11.990
Of course, the Web Services API,
if you're familiar with it,

00:56:11.990 --> 00:56:18.000
will also generate stubs for
you in C and Objective-C.

00:56:18.000 --> 00:56:22.000
I'm not sure if it generates
any C++ stubs today,

00:56:22.000 --> 00:56:28.000
but it'll generate stubs for
you from the so-called WSDL.

00:56:28.000 --> 00:56:31.870
You can use the WSDL descriptions
of Web Services if you

00:56:31.960 --> 00:56:34.030
have such a description.

00:56:35.100 --> 00:58:53.600
[Transcript missing]

00:58:54.160 --> 00:59:00.680
Before I conclude finally and go to QA,
I want to remind you, as Doug did,

00:59:00.680 --> 00:59:03.970
about the Best Practices in
Network Programming talk,

00:59:03.990 --> 00:59:07.440
just down the hall here in
Presidio after lunch at 2:00.
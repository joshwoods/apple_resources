WEBVTT

00:00:00.200 --> 00:00:01.600
My name's Dave O'Rourke.

00:00:01.600 --> 00:00:03.360
We're going to be talking about
Xgrid here for a little bit.

00:00:03.490 --> 00:00:06.160
A little later on,
I'm going to be bringing up my coworker,

00:00:06.220 --> 00:00:08.700
David Kraemer,
and he's going to be doing some demos

00:00:08.700 --> 00:00:10.590
and showing you some sample code.

00:00:10.890 --> 00:00:13.140
Those are our names.

00:00:13.310 --> 00:00:17.280
So, as with most presentations,
we're going to start

00:00:17.290 --> 00:00:18.990
out with an overview.

00:00:19.100 --> 00:00:23.310
I'm going to give you a quick,
brief introduction where

00:00:23.370 --> 00:00:27.390
Apple positions Xgrid,
what we think it's good for,

00:00:27.390 --> 00:00:30.120
and generally try to bring people
up to speed that may not have

00:00:30.120 --> 00:00:30.120
dealt with the previous previews.

00:00:30.120 --> 00:00:30.120
We had a technical
preview and a preview 2.

00:00:30.120 --> 00:00:30.120
We'll cover that in a bit.

00:00:30.270 --> 00:00:31.160
So what will you learn today?

00:00:31.160 --> 00:00:32.300
First of all,
we're going to have an overview.

00:00:32.300 --> 00:00:33.190
I've discussed that.

00:00:33.200 --> 00:00:35.820
We're going to go a little
bit into the architecture.

00:00:35.870 --> 00:00:37.850
Not everyone's familiar
with grid architecture,

00:00:37.860 --> 00:00:40.880
so we're going to do some diagrams
for you and hopefully show you

00:00:40.880 --> 00:00:43.540
guys how the grid and actually
how simple it actually is but how

00:00:43.540 --> 00:00:45.260
much power you can derive from it.

00:00:45.280 --> 00:00:47.210
We'll then go into administration.

00:00:47.310 --> 00:00:50.280
We have a host of administration
tools that we've included with Tiger.

00:00:50.280 --> 00:00:53.740
That makes things a lot easier to set up,
manage, maintain, and monitor.

00:00:53.740 --> 00:00:56.300
We'll be talking about job submission.

00:00:56.300 --> 00:00:58.320
There is no grid without job submission.

00:00:58.370 --> 00:00:59.430
It's an important topic.

00:00:59.560 --> 00:01:02.680
We'll be diagramming the workflow for you
there and hope to give you a mental model

00:01:02.680 --> 00:01:06.640
of how the grid's actually taking code
and executing it out on someone's iMac.

00:01:08.050 --> 00:01:10.350
We're going to talk about how to develop.

00:01:10.370 --> 00:01:21.370
You will leave this room with sample code
for a grid-enabled Cocoa application.

00:01:21.370 --> 00:01:21.370
The sample code's on the DVD.

00:01:21.370 --> 00:01:21.370
You guys can play along while
we're coding up here on screen.

00:01:22.080 --> 00:01:22.770
So, introduction.

00:01:22.830 --> 00:01:25.890
X Grid is Apple's distributed
computing solution.

00:01:25.890 --> 00:01:28.860
The slide says that,
you didn't need me to say that.

00:01:28.940 --> 00:01:32.510
But what it does is we've built
this into the operating system.

00:01:32.520 --> 00:01:35.920
So by saying it's Apple's grid solution,
you as a developer and you as a system

00:01:35.930 --> 00:01:38.520
administrator can rely on it being there.

00:01:38.520 --> 00:01:43.130
This allows distributed processing of
grid jobs to make workflow go faster.

00:01:43.130 --> 00:01:45.060
Hopefully that's what people realize.

00:01:45.060 --> 00:01:47.300
If you're going to grid
enable your software,

00:01:47.300 --> 00:01:50.400
you're going to do things to try to
take advantage of the grid resources

00:01:50.400 --> 00:01:52.170
and make things go much quicker.

00:01:52.170 --> 00:01:55.220
Again, the emphasis here is this
is now built into Tiger.

00:01:55.220 --> 00:01:57.390
It's Apple's solution for grid computing.

00:01:57.420 --> 00:01:59.660
You can start relying on this
technology being present.

00:01:59.660 --> 00:02:02.660
Tiger's server comes with X Grid.

00:02:02.660 --> 00:02:05.660
The X Grid agent is on
every Tiger machine.

00:02:05.660 --> 00:02:08.850
And we have also provided an
agent install for Panther.

00:02:08.880 --> 00:02:11.830
So you have a mixed environment,
some Panther machines,

00:02:11.860 --> 00:02:13.250
some Tiger workstations.

00:02:13.250 --> 00:02:16.470
You can install the X Grid agent on
Panther and you can fully utilize

00:02:16.470 --> 00:02:17.840
your entire computing network.

00:02:19.290 --> 00:02:22.040
The Tiger development tools
are also included and support

00:02:22.140 --> 00:02:24.940
all the XGrid frameworks,
all the XGrid functionality.

00:02:24.940 --> 00:02:28.260
We'll be going into that in a lot more
detail later on in the presentation.

00:02:28.260 --> 00:02:32.860
But you can use Tiger with Xcode to
develop grid-enabled software today.

00:02:32.860 --> 00:02:34.490
There's nothing else
you need to download.

00:02:34.500 --> 00:02:38.080
For those of you who have been
with XGrid a little longer,

00:02:38.080 --> 00:02:41.180
we thought we'd put up a timeline to
kind of orient you as to where we are.

00:02:41.180 --> 00:02:44.920
Back in January 2004,
we had a technical preview.

00:02:44.920 --> 00:02:45.620
That came out.

00:02:45.620 --> 00:02:47.800
A lot of people jumped on it and
immediately started using it.

00:02:47.880 --> 00:02:49.060
Gave us some excellent feedback.

00:02:49.060 --> 00:02:51.240
We love the feedback we got
from the technical preview.

00:02:51.240 --> 00:02:53.620
That led to technical preview 2.

00:02:53.620 --> 00:02:57.320
Again,
the community got a little bigger then,

00:02:57.320 --> 00:03:00.100
got a little more feedback,
and a lot of the feedback from technical

00:03:00.130 --> 00:03:04.200
preview 2 is now being delivered to you
in commercial quality form in Tiger.

00:03:04.200 --> 00:03:06.860
So this is an ongoing effort.

00:03:06.860 --> 00:03:10.020
We hope to get some feedback at the end
of this session and ongoing feedback

00:03:10.090 --> 00:03:13.000
as more and more people adopt XGrid
and now that it's built into Tiger.

00:03:13.000 --> 00:03:16.930
This is just the beginning for Apple,
and we think the grid-enabled

00:03:16.960 --> 00:03:17.840
technology is a core.

00:03:17.860 --> 00:03:22.040
or differentiator for our operating
system to come with standard.

00:03:22.220 --> 00:03:25.000
So what sort of solutions
does Xgrid enable?

00:03:25.120 --> 00:03:27.090
Well,
the first solution it enables is--we

00:03:27.170 --> 00:03:30.100
wanted to do what Apple always does,
is we wanted to make this so

00:03:30.100 --> 00:03:31.940
average humans can set grids up.

00:03:31.940 --> 00:03:34.280
I don't know about you,
but I didn't know how to

00:03:34.280 --> 00:03:37.220
set up a grid 12 months ago,
and I can set up an Xgrid.

00:03:37.220 --> 00:03:40.080
I've seen a lot of people who
didn't think they could set up

00:03:40.100 --> 00:03:41.540
a grid able to set up a grid.

00:03:41.540 --> 00:03:45.360
So Apple not only built grid-enabled
software into their operating system,

00:03:45.530 --> 00:03:48.940
which I'm surprised, you know,
there isn't more call-out for that,

00:03:49.040 --> 00:03:52.100
but we've made it so that
mere mortals can set it up.

00:03:52.470 --> 00:03:54.270
We've built the support
into Tiger Desktop.

00:03:54.360 --> 00:03:56.050
We've built the support
into Tiger Server.

00:03:56.060 --> 00:03:58.840
You need nothing else to deploy a grid.

00:03:59.010 --> 00:04:01.580
The administration tools are
provided with Tiger Server.

00:04:01.580 --> 00:04:04.200
They're integrated into the
Tiger Server administration tools,

00:04:04.200 --> 00:04:07.370
so there's no separate set of
administration tools for configuring

00:04:07.420 --> 00:04:09.660
the grid or managing the controller.

00:04:09.700 --> 00:04:11.660
Xgrid Agent is available
for install in Panther,

00:04:11.660 --> 00:04:14.450
as I mentioned earlier,
so this eases your deployment burdens.

00:04:14.460 --> 00:04:16.900
You don't have to upgrade your
entire network to Tiger all at once,

00:04:16.900 --> 00:04:19.260
although we highly recommend
that and get a site license.

00:04:19.270 --> 00:04:21.690
Ernie can talk to you
after the conference.

00:04:21.780 --> 00:04:25.020
But if you can't do that or
aren't willing to do that,

00:04:25.020 --> 00:04:27.850
we do provide the grid agent for Panther.

00:04:28.380 --> 00:04:31.520
We also wanted to make sure that
if the grid agent's enabled,

00:04:31.520 --> 00:04:34.390
that it just doesn't take
over the user's machine.

00:04:34.400 --> 00:04:37.140
If the user's volunteering their
machine to be part of the grid,

00:04:37.140 --> 00:04:39.840
they still want iPhoto to work well,
they want Pages to work well,

00:04:39.840 --> 00:04:42.960
they want Keynote to work well,
they want Final Cut Pro to work well.

00:04:42.980 --> 00:04:48.020
So the grid has knowledge and
accommodations into it to not do grid

00:04:48.320 --> 00:04:50.780
tasks when users are using the computer.

00:04:50.780 --> 00:04:52.180
This is obviously configurable.

00:04:52.180 --> 00:04:52.940
You can turn it off.

00:04:53.000 --> 00:04:54.200
We'll go over that later.

00:04:54.200 --> 00:04:58.000
But the goal was to allow people
to be part of the grid without it

00:04:58.140 --> 00:04:59.880
dominating their daily workflow.

00:04:59.880 --> 00:05:05.160
We support various grid computing styles.

00:05:05.160 --> 00:05:09.560
For those of you who were here last year,
I wasn't up on stage last year.

00:05:09.560 --> 00:05:11.860
That's because I wasn't the
XGrid manager last year.

00:05:11.860 --> 00:05:15.800
So when I inherited XGrid,
one of the first things that David Kramer

00:05:15.800 --> 00:05:18.980
sat down and did was tell me that we
supported various computing styles.

00:05:19.020 --> 00:05:20.130
I didn't know what those were.

00:05:20.140 --> 00:05:22.620
So this will be a quick tutorial.

00:05:22.620 --> 00:05:23.500
It was useful for me.

00:05:23.500 --> 00:05:24.590
Hopefully it's useful for you.

00:05:24.600 --> 00:05:27.390
The first and most obvious
computing style for a grid

00:05:27.450 --> 00:05:29.310
is dedicated participants.

00:05:29.400 --> 00:05:31.530
That's represented by the grid
over here you see in the gray

00:05:31.600 --> 00:05:32.740
box on the end of the stage.

00:05:32.740 --> 00:05:35.170
This is sometimes referred
to as the Beowulf model.

00:05:35.180 --> 00:05:39.080
This is writing a check to
Apple Computer for a very small

00:05:39.080 --> 00:05:41.400
sum of money for a very large
amount of compute power to buy

00:05:41.400 --> 00:05:45.860
20 rack machines and dedicating
those to doing some DNA analysis,

00:05:45.860 --> 00:05:48.000
doing some financial analysis
or something like that.

00:05:48.000 --> 00:05:49.960
XGrid fully supports that model.

00:05:49.960 --> 00:05:54.130
This is racks of XSERVs
or closets of Mac minis.

00:05:54.200 --> 00:05:56.800
Yes, we've had questions with people
wanting to run Mac minis as well.

00:05:56.830 --> 00:05:57.440
We've had questions with people
wanting to run Mac minis.

00:05:57.440 --> 00:06:01.080
They're great space saving utility.

00:06:01.140 --> 00:06:05.280
I personally like the G5 for the big
heavy iron stuff a little bit better.

00:06:05.280 --> 00:06:08.060
But yes, XGrid would fully support
a closet full of Mac minis.

00:06:08.060 --> 00:06:09.510
I actually haven't done the math.

00:06:09.590 --> 00:06:11.780
I wonder how many minis you
could fit in the average closet.

00:06:11.800 --> 00:06:14.640
Part time participants.

00:06:14.730 --> 00:06:15.860
How many of you run SETI at home?

00:06:15.860 --> 00:06:17.320
Okay.

00:06:17.320 --> 00:06:20.050
This is -- you're volunteering
your computer resources but

00:06:20.050 --> 00:06:21.140
you're not using your computer.

00:06:21.140 --> 00:06:23.010
XGrid fully supports this model as well.

00:06:23.060 --> 00:06:26.590
This, you know,
people can volunteer their computer.

00:06:26.640 --> 00:06:29.760
The grid will know about it and if
it gets any jobs it will schedule

00:06:29.760 --> 00:06:30.920
it on the volunteer's computer.

00:06:30.920 --> 00:06:32.680
So we support that type
of computing model.

00:06:32.680 --> 00:06:37.970
This is great for underutilized
office and university computers.

00:06:37.980 --> 00:06:42.300
Think of how much compute power is
on your campus or your work site or

00:06:42.400 --> 00:06:46.780
your data center on the weekends when
everybody breaks on Friday at 3:00 p.m.

00:06:46.780 --> 00:06:48.420
and doesn't come until
Monday at 10:00 a.m.

00:06:48.420 --> 00:06:51.140
You know, there's a lot of compute
power over the weekend.

00:06:51.140 --> 00:06:52.780
There's a lot of compute power.

00:06:52.780 --> 00:06:56.420
So this is a great way to more
fully utilize your computer.

00:06:56.420 --> 00:06:59.650
You can also use your computer resources
by running weekend jobs or running

00:06:59.650 --> 00:07:02.500
overnight jobs even when people break
at 5:00 and don't come back to the

00:07:02.500 --> 00:07:04.480
next morning until 9:00 or 8:30.

00:07:04.480 --> 00:07:08.000
Idle cycle recovery on a
global scale or -- yeah,

00:07:08.010 --> 00:07:09.620
on a global scale.

00:07:09.700 --> 00:07:12.400
We can recover idle cycles from Japan.

00:07:12.570 --> 00:07:16.780
My manager, Kazoo,
is like setting up a grid and

00:07:16.780 --> 00:07:20.860
his grandmother apparently is
donating her computer from Japan.

00:07:20.860 --> 00:07:26.210
And he runs grid jobs on her computer so
he can harvest that extra 1.8 gigahertz

00:07:26.220 --> 00:07:27.360
G5 all the way across the country.

00:07:27.410 --> 00:07:28.330
But we can do that.

00:07:28.400 --> 00:07:30.180
It's all based on TCP/IP.

00:07:30.250 --> 00:07:32.570
The agents can be located
anywhere in the world.

00:07:34.290 --> 00:07:35.440
So who can benefit from X-Rit?

00:07:35.440 --> 00:07:38.700
The first thing that we've done with the
grid computer is by building it into 10

00:07:38.700 --> 00:07:41.680
server and building it into the desktop,
we've made grid computing

00:07:41.680 --> 00:07:42.860
like a print service.

00:07:42.860 --> 00:07:45.930
It's a service that the
IT department can set up,

00:07:46.010 --> 00:07:48.220
maintain,
but they don't have to write the jobs,

00:07:48.340 --> 00:07:49.130
they don't have to do it.

00:07:49.150 --> 00:07:51.440
It's a service that they can
make available to a department,

00:07:51.440 --> 00:07:53.860
and yet they can host
it in the data center,

00:07:54.000 --> 00:07:54.960
they can manage it.

00:07:55.120 --> 00:07:56.740
They don't have to know
anything about grid computing,

00:07:56.740 --> 00:07:58.880
but they can put the data in it.

00:07:58.960 --> 00:08:00.370
So it's just like mail, file, or print.

00:08:00.510 --> 00:08:03.680
Grid is now an option that you can deploy
right after you set up your mail server.

00:08:03.680 --> 00:08:08.650
So the IT department can host it,
manage it, but the scientists can use it,

00:08:08.770 --> 00:08:10.450
just like the scientists
use the color printers.

00:08:10.460 --> 00:08:12.620
Software developers.

00:08:12.620 --> 00:08:16.190
If you're a software developer,
you can use the grid to make

00:08:16.190 --> 00:08:20.510
your software run faster,
or in some cases, not even run faster,

00:08:20.510 --> 00:08:21.610
but do more options.

00:08:21.660 --> 00:08:23.570
An idea we're kicking around is,
you know,

00:08:23.570 --> 00:08:27.340
what if you were to render things and
render multiple copies of the same

00:08:27.340 --> 00:08:31.300
thing so that when you get it back,
you can actually review multiple copies.

00:08:31.320 --> 00:08:34.180
A graphics converter,
if that developer's in the audience,

00:08:34.180 --> 00:08:35.840
you know,
he could do multiple conversions

00:08:35.840 --> 00:08:39.920
in parallel on the grid,
and convert a JPEG to all,

00:08:39.920 --> 00:08:42.480
to five different formats,
and do it much faster by distributing

00:08:42.480 --> 00:08:43.420
the work out to the grid.

00:08:43.420 --> 00:08:46.150
Scientists and engineers,
this is the most obvious

00:08:46.150 --> 00:08:47.310
and historic market.

00:08:47.320 --> 00:08:51.050
The scientists and engineers
like the grid because we built

00:08:51.050 --> 00:08:52.620
in a lot of features for them.

00:08:52.620 --> 00:08:55.200
One of the features they wanted was
persistent job queue submission.

00:08:55.200 --> 00:08:57.050
Something that people
don't quite realize,

00:08:57.110 --> 00:08:59.290
and I'll point it out when we go
through the architecture slides,

00:08:59.320 --> 00:09:02.050
is when you submit a job,
the computer that submitted

00:09:02.060 --> 00:09:03.240
the job to the grid can be,
you can slap the computer in the face,

00:09:03.240 --> 00:09:03.480
and it'll do it.

00:09:03.500 --> 00:09:03.500
You can slap the computer in the face,
and it'll do it.

00:09:03.500 --> 00:09:03.540
You can slap the computer in the face,
and it'll do it.

00:09:03.570 --> 00:09:05.840
You can slap the lid closed
and take off for the weekend.

00:09:05.840 --> 00:09:07.650
The grid will continue
working on your job.

00:09:07.720 --> 00:09:10.080
So the job queue, just like a print job,
is persistent.

00:09:10.080 --> 00:09:12.650
The grid will continue working the job,
it will collect the results,

00:09:12.720 --> 00:09:15.930
and it will hold the results
until that computer reconnects

00:09:15.930 --> 00:09:18.460
to the grid and collects the
results back from the controller.

00:09:18.460 --> 00:09:19.680
This is fantastic.

00:09:19.720 --> 00:09:23.240
Big compute job,
going to work for several hours

00:09:23.240 --> 00:09:25.790
or several days on the grid,
going to do a lot of computation.

00:09:25.800 --> 00:09:28.560
I don't want to have to have my
power book where I submitted the job

00:09:28.900 --> 00:09:30.250
sitting there for that entire time.

00:09:30.260 --> 00:09:31.860
I'm going to close it,
I'm going to take it home,

00:09:31.860 --> 00:09:33.720
and I'm going to play World of Warcraft,
and I'm going to put a link on it.

00:09:33.740 --> 00:09:38.290
So the grid works on your job while
you're away or while you sleep.

00:09:39.730 --> 00:09:40.600
Creative professionals.

00:09:40.600 --> 00:09:43.140
Apple being so strong
in the creative market,

00:09:43.140 --> 00:09:47.700
we feel there's huge opportunity for
third-party developers to start treating

00:09:47.700 --> 00:09:53.610
the grid as a built-in support component
for developers' creative applications.

00:09:53.620 --> 00:09:55.540
There's so much you can do with the grid.

00:09:55.560 --> 00:10:01.420
If you can assume you have 5, 10, 15, 20,
200 computers at your disposal,

00:10:01.420 --> 00:10:03.980
you can start doing things
you never even considered.

00:10:03.980 --> 00:10:07.000
We have Cocoa APIs,
we have Objective-C APIs.

00:10:07.000 --> 00:10:09.750
You can build it right into your
application so that the user doesn't

00:10:09.750 --> 00:10:11.390
even have to know they're using a grid.

00:10:11.400 --> 00:10:13.770
You can just make your
application go faster.

00:10:15.280 --> 00:10:17.590
Terminology,
when you're sitting down and talking

00:10:17.590 --> 00:10:20.250
about a new technology like X-Grid,
it's always useful to get

00:10:20.260 --> 00:10:23.330
the terminology out so that
everyone's talking the same things.

00:10:23.340 --> 00:10:26.440
X-Grid's simple but, you know,
the terms will help us

00:10:26.440 --> 00:10:29.750
have a further conversation
throughout this presentation.

00:10:29.800 --> 00:10:33.730
So the first terminology that we
tend to throw around is the client.

00:10:33.740 --> 00:10:35.870
Now,
for the purposes of this presentation,

00:10:35.870 --> 00:10:40.140
the client is any computer on the net
that's doing a job submission to a grid.

00:10:40.200 --> 00:10:44.590
That's the equivalent of the user
choosing print and submitting it to

00:10:44.590 --> 00:10:46.190
the print spool or that's the client.

00:10:46.240 --> 00:10:49.860
User choosing send my job to the grid,
they're the client.

00:10:51.800 --> 00:10:53.640
These are the people that have
work that needs to be done.

00:10:53.640 --> 00:10:55.320
The controller.

00:10:55.320 --> 00:10:59.220
The controller accepts the job,
parses the job, and figures out, well,

00:10:59.220 --> 00:11:00.910
who can I get to schedule this work on?

00:11:00.920 --> 00:11:03.320
It figures out, okay,
I've got 200 computers.

00:11:03.320 --> 00:11:05.100
This task has 10 things.

00:11:05.100 --> 00:11:07.280
All right, how many computers do
I need to use to do that?

00:11:07.280 --> 00:11:09.740
It does all the matching
or all the brokering for,

00:11:09.740 --> 00:11:11.730
you know, given a job,
how do I make it all,

00:11:11.780 --> 00:11:15.440
get it all scheduled and get all
the results out and collected.

00:11:15.440 --> 00:11:19.290
So it manages the job scheduling,
the data movement, and the agents.

00:11:20.110 --> 00:11:22.240
The agents are the computers that
have been joined to the grid,

00:11:22.240 --> 00:11:24.160
and they're the ones that are
going to do the actual work.

00:11:24.280 --> 00:11:27.650
These are the idle G5s in your
computer labs at universities.

00:11:27.660 --> 00:11:29.300
They join the grid.

00:11:29.300 --> 00:11:32.660
They are now available to the
grid to schedule works that

00:11:32.660 --> 00:11:34.200
the clients submit as jobs.

00:11:34.200 --> 00:11:37.710
So these can be anything from
high-end dual 2.7 G5s to older

00:11:37.820 --> 00:11:41.650
underutilized blue and white G3s
or even a closet full of Mac minis.

00:11:41.660 --> 00:11:44.740
So the agent is the place where
the job actually executes,

00:11:44.740 --> 00:11:46.580
where the computational
resources are consumed,

00:11:46.580 --> 00:11:47.840
the results are collected from.

00:11:49.160 --> 00:11:52.920
work is scheduled and
executed on the agent.

00:11:53.100 --> 00:11:57.100
If your grid job has been properly
composed into multiple jobs,

00:11:57.100 --> 00:12:00.060
the grid will execute as much
work in parallel as possible.

00:12:00.210 --> 00:12:04.230
So you're not submitting a job to the
grid and just having it execute Task 1

00:12:04.350 --> 00:12:08.100
on Agent 1 and then waiting for that
to finish and Task 2 goes on Agent 2.

00:12:08.230 --> 00:12:12.000
The grid will figure out as much work as
possible that can be done in parallel.

00:12:12.110 --> 00:12:15.100
This is where you pick up the
grid's performance capabilities.

00:12:15.100 --> 00:12:17.100
You can have the grid working
on things in parallel.

00:12:17.100 --> 00:12:20.100
Huge, huge computational benefit.

00:12:20.100 --> 00:12:22.010
Client, which we discussed.

00:12:22.100 --> 00:12:25.100
You have the controller
and you have agents.

00:12:25.100 --> 00:12:28.100
But hopefully with your grid,
this is a lot of overhead

00:12:28.100 --> 00:12:29.090
just to have one agent.

00:12:29.100 --> 00:12:31.090
Hopefully you have more than one agent.

00:12:31.100 --> 00:12:34.100
You have as many agents as
you can lay your hands on.

00:12:34.100 --> 00:12:36.090
And you don't have just one client.

00:12:36.130 --> 00:12:38.100
There's not just one scientist,
one financial analysis,

00:12:38.100 --> 00:12:42.090
or one creative content
professional doing renders.

00:12:42.100 --> 00:12:45.860
There are multiple people that are
using the grid and they don't have to

00:12:45.860 --> 00:12:47.100
worry about how many agents there are.

00:12:47.100 --> 00:12:49.100
They don't have to worry
about where the controller is.

00:12:49.100 --> 00:12:51.100
They don't have to worry about
what jobs are running local,

00:12:51.100 --> 00:12:52.100
what jobs are running remotely.

00:12:52.100 --> 00:12:55.630
They can just use the grid as a
resource to make their workflow go

00:12:55.630 --> 00:12:59.040
faster or to accomplish a task such as,
you know,

00:12:59.100 --> 00:13:03.100
calculating pi to the 10 billionth
digit or something along those lines.

00:13:03.100 --> 00:13:07.100
Or something much more
meaningful such as curing cancer.

00:13:07.350 --> 00:13:12.080
The terminology for the grid is the
grid is a set of agents and a job queue.

00:13:12.100 --> 00:13:15.100
The job queue controls
the list of workers.

00:13:15.100 --> 00:13:18.100
It controls the list of work that's
going to be scheduled on the agent.

00:13:18.430 --> 00:13:18.970
There are jobs.

00:13:19.100 --> 00:13:22.100
A job is a set of tasks that
are definable and atomic.

00:13:22.100 --> 00:13:25.080
It's a collection of
input and output data.

00:13:25.100 --> 00:13:29.100
This is huge because we put
all the data onto the agents.

00:13:29.100 --> 00:13:30.030
And a task.

00:13:30.230 --> 00:13:32.100
This is the smallest piece of work to do.

00:13:32.100 --> 00:13:35.100
And this is the little thing that takes,
you know, a number,

00:13:35.100 --> 00:13:38.100
runs a fast Fourier transform on it,
and transforms it into something else.

00:13:38.100 --> 00:13:40.020
These are command line executables.

00:13:40.100 --> 00:13:41.100
They can take arguments.

00:13:41.100 --> 00:13:43.100
They take working directory files.

00:13:43.100 --> 00:13:44.090
And they also work with standard input.

00:13:44.100 --> 00:13:48.370
So with the three-tier architecture,
not only do you have clients,

00:13:48.470 --> 00:13:51.100
controllers, and agents,
you can subdivide the agents,

00:13:51.100 --> 00:13:53.100
if you want to, into virtual grids.

00:13:53.100 --> 00:13:56.100
So you could take all of your
computing resources on campus,

00:13:56.100 --> 00:14:00.100
join them to the controller,
and I can dedicate, you know,

00:14:00.100 --> 00:14:04.100
the top three iMacs to the physics grid,
the middle to the biology grid,

00:14:04.210 --> 00:14:09.000
and finance can have all the iMac
minis in the closet at the bottom.

00:14:09.100 --> 00:14:11.290
Or you can combine all the
resources into one uber grid and

00:14:11.290 --> 00:14:13.100
use all the resources you want.

00:14:13.100 --> 00:14:15.100
The point is,
you as the administrator have

00:14:15.100 --> 00:14:18.060
control over how the agents are
used and how they're scheduled.

00:14:20.000 --> 00:14:20.890
So what does xGrid do?

00:14:20.900 --> 00:14:24.300
It groups agents into grids,
as seen by the previous slide.

00:14:24.300 --> 00:14:26.380
It monitors agent availability.

00:14:26.380 --> 00:14:27.620
This is very big.

00:14:27.620 --> 00:14:29.610
While the agents are
a member of the grid,

00:14:29.620 --> 00:14:32.830
the grid controller knows whether
the agent is currently awake,

00:14:32.850 --> 00:14:34.410
asleep, idle, so on and so forth.

00:14:34.420 --> 00:14:36.070
So the controller,
when it receives a job,

00:14:36.140 --> 00:14:39.770
already knows what agents are
available for it to schedule work on.

00:14:39.820 --> 00:14:40.660
This is a huge deal.

00:14:40.660 --> 00:14:43.210
This means we're not farming
tasks out to agents that have

00:14:43.210 --> 00:14:44.580
been put to sleep ages ago.

00:14:44.580 --> 00:14:46.290
We know that the agent's up.

00:14:46.410 --> 00:14:47.040
We know it's alive.

00:14:47.040 --> 00:14:47.930
We know it's ready to work.

00:14:48.890 --> 00:14:50.780
It manages queues of jobs
and their dependencies.

00:14:50.810 --> 00:14:54.280
This is, in my opinion, somewhat obvious,
but that's what the controller does,

00:14:54.340 --> 00:14:55.450
is it manages the jobs.

00:14:55.520 --> 00:14:59.010
There's ways you can describe to xGrid
that this job has to complete before

00:14:59.010 --> 00:15:01.660
this other job's appropriate to run,
so you can manage the dependency.

00:15:01.660 --> 00:15:05.000
The controller makes sure that
everything executes in the proper order,

00:15:05.000 --> 00:15:08.540
and then it has all the necessary data
that it needs to keep everything flowing.

00:15:08.540 --> 00:15:13.960
It schedules runnable jobs,
so it knows which agent has a job.

00:15:13.960 --> 00:15:14.930
It schedules it on it.

00:15:14.940 --> 00:15:17.740
It monitors the agent's results and
collects them when they're done.

00:15:18.800 --> 00:15:22.560
And I can't emphasize
this fifth bullet enough.

00:15:22.600 --> 00:15:25.000
We on xGrid handle the data staging.

00:15:25.000 --> 00:15:29.270
One of the big things about
grid computing is getting the

00:15:29.310 --> 00:15:31.470
input data onto the agent,
and there's all sorts of

00:15:31.500 --> 00:15:32.700
different ways to do that.

00:15:32.700 --> 00:15:34.160
Some people set up NFS mounts.

00:15:34.250 --> 00:15:36.160
Other people write FTP scripts,
so on and so forth.

00:15:36.160 --> 00:15:39.020
xGrid's really beautiful
in this particular area.

00:15:39.020 --> 00:15:42.160
We take care of staging the
input data onto the client,

00:15:42.180 --> 00:15:45.330
so you can have a client with
absolutely nothing on it.

00:15:45.530 --> 00:15:48.480
And when someone submits a job to Xgrid,
the Xgrid controller makes sure

00:15:48.480 --> 00:15:51.040
the agent has the executable,
makes sure it has the input data,

00:15:51.040 --> 00:15:52.840
and we collect up all the output data.

00:15:52.840 --> 00:15:55.630
So the agents don't have to have
anything pre-installed on them.

00:15:55.640 --> 00:15:58.040
The Xgrid controller will get
everything down to the agent

00:15:58.040 --> 00:16:00.640
that it needs to run the job,
collect it all up, clean it up,

00:16:00.730 --> 00:16:03.660
and leave the agent clean when
it's all done with the process.

00:16:03.660 --> 00:16:07.100
So you don't have to wander around
to 1,500 machines and pre-install

00:16:07.100 --> 00:16:08.850
all of your grid-enabled software.

00:16:08.920 --> 00:16:11.310
The controller will take care of
getting all of that to the agents.

00:16:11.320 --> 00:16:13.850
So you can take a
Tiger machine out of the box,

00:16:14.540 --> 00:16:16.460
plug it in,
do any additional data install,

00:16:16.460 --> 00:16:18.180
join it to the grid,
and if there's jobs being

00:16:18.180 --> 00:16:20.300
scheduled on that grid,
that agent will immediately

00:16:20.300 --> 00:16:22.900
be put to work if it meets the
criteria for the job scheduling.

00:16:22.900 --> 00:16:24.880
No additional software
installs are required.

00:16:24.880 --> 00:16:28.190
This is a huge thing that goes...
Not only do we think it's obvious,

00:16:28.200 --> 00:16:30.690
but it also is one of the ease-of-use
things that we've put into the grid.

00:16:32.230 --> 00:16:33.800
And it recovers from failures.

00:16:34.030 --> 00:16:36.830
It wouldn't do the scientists a lot
of good if you submitted the job and

00:16:36.860 --> 00:16:39.660
just because one of the agents got put
to sleep or someone tripped over the

00:16:39.790 --> 00:16:41.420
power cord that the job didn't run.

00:16:41.510 --> 00:16:44.500
The controller knows when the job's done,
it knows the job was scheduled.

00:16:44.550 --> 00:16:48.540
If the job doesn't finish
executing and the agent goes away,

00:16:48.540 --> 00:16:51.520
it'll reschedule the
job on another agent.

00:16:51.520 --> 00:16:56.080
So we are always working--we always
make a best effort to fully execute

00:16:56.270 --> 00:16:59.650
the jobs as they are submitted,
and because we have the agent status,

00:16:59.650 --> 00:16:59.650
we can do that.

00:17:01.020 --> 00:17:02.590
What are the new features in Tiger?

00:17:02.650 --> 00:17:07.410
This is mostly a slide for people that
were familiar with Technical Preview

00:17:07.410 --> 00:17:09.820
1 and Technical Preview 2.

00:17:09.960 --> 00:17:11.570
The first thing we added
was authentication.

00:17:11.600 --> 00:17:14.550
Well, grids are a computing resource.

00:17:14.700 --> 00:17:17.790
So, you might not want everyone on
your campus being able to submit

00:17:17.840 --> 00:17:20.530
a job to the grid so we've added
Kerberos based authentication so

00:17:20.530 --> 00:17:23.720
that you can restrict the grid to
only being used by certain people.

00:17:23.720 --> 00:17:26.880
This fits in with open directory
and ties in with the rest

00:17:26.900 --> 00:17:28.660
of the server architecture.

00:17:28.810 --> 00:17:31.650
Cocoa Developer APIs,
you can now as a Cocoa Developer very

00:17:31.720 --> 00:17:35.370
easily integrate the grid into your
Cocoa application such that using

00:17:35.370 --> 00:17:37.450
the grid is seamless to your user.

00:17:37.540 --> 00:17:41.500
We'll be going through a code
example later in this presentation.

00:17:41.640 --> 00:17:44.000
Server administration integration,
I mentioned this earlier.

00:17:44.080 --> 00:17:47.050
We provide a full suite of server
administration tools to administer

00:17:47.050 --> 00:17:49.300
the agents and the controller.

00:17:49.350 --> 00:17:53.840
Xgrid Admin Application,
this is what lets you monitor your jobs,

00:17:53.870 --> 00:17:56.790
excuse me,
lets you monitor your jobs and see

00:17:56.800 --> 00:17:58.720
their job status and so on and so forth.

00:17:58.720 --> 00:18:01.040
Multiple task per job, didn't have that.

00:18:01.100 --> 00:18:03.990
We now allow a single job to
say I need to do multiple tasks.

00:18:04.000 --> 00:18:06.520
This seems kind of obvious but
we previously didn't have that.

00:18:06.580 --> 00:18:09.760
So, we now can have multiple
tasks be part of a single job.

00:18:09.910 --> 00:18:12.190
Task and job dependencies
is a huge feature.

00:18:12.200 --> 00:18:14.950
This way you can post a single job
that has a number of dependencies

00:18:14.950 --> 00:18:16.340
and needs to be run in segments.

00:18:16.430 --> 00:18:20.320
The controller won't schedule the
jobs before they're ready to be run.

00:18:20.410 --> 00:18:21.950
Where are the components?

00:18:22.110 --> 00:18:24.980
Well, Tiger comes with the
agent already installed.

00:18:25.080 --> 00:18:27.250
How many of you have
Tiger on your power book?

00:18:27.360 --> 00:18:28.750
If you open -- oh, wow.

00:18:28.850 --> 00:18:31.130
Thank you, thank you very much.

00:18:31.300 --> 00:18:34.120
If you open up sharing,
you'll see Xgrid on the sharing panel.

00:18:34.120 --> 00:18:35.910
Xgrid's installed on Tiger desktop.

00:18:36.070 --> 00:18:38.600
If I gave you the password to the
controller up here on campus you could

00:18:38.600 --> 00:18:41.480
all become agents and we'd schedule
all sorts of jobs on your power books

00:18:41.480 --> 00:18:43.260
while you're doing this presentation.

00:18:43.350 --> 00:18:46.080
We have a client framework
and CLI tool and their code

00:18:46.080 --> 00:18:48.000
examples and the developer tools.

00:18:48.070 --> 00:18:50.360
In addition,
Tiger server comes with the controller

00:18:50.360 --> 00:18:51.640
and all the administration tools.

00:18:51.690 --> 00:18:54.070
So if you have Tiger desktop
you already have an agent.

00:18:54.140 --> 00:18:57.540
If you have Tiger server you already have
everything you need to set up a grid.

00:18:57.630 --> 00:18:59.460
So what are you waiting for?

00:18:59.570 --> 00:19:03.060
And again,
for those of you who can't go to

00:19:03.160 --> 00:19:07.460
Tiger but you still have Panther,
we do have an agent available

00:19:07.460 --> 00:19:09.300
for install on Panther.

00:19:09.410 --> 00:19:12.270
David, is that in the install on
the Tiger server or do they

00:19:12.270 --> 00:19:14.350
download that from the web?

00:19:14.450 --> 00:19:15.460
Download?

00:19:15.460 --> 00:19:16.770
Yeah,
so you download the Panther agent as

00:19:16.770 --> 00:19:17.990
an installer package from the web.

00:19:18.000 --> 00:19:19.170
Amen.

00:19:19.520 --> 00:19:21.130
We do support message passing.

00:19:21.230 --> 00:19:24.560
For those of you who do grid programming,
MPI is a very big deal.

00:19:24.670 --> 00:19:27.560
We have sample codes to show
how to submit Mac MPI jobs,

00:19:27.560 --> 00:19:30.640
which is a legacy or
pre-existing grid technology.

00:19:30.640 --> 00:19:32.800
Those are at this URL.

00:19:32.800 --> 00:19:35.110
And OpenMPI,
a big grid consortium of people

00:19:35.150 --> 00:19:38.310
who do a lot of MPI development,
have actually modified their

00:19:38.310 --> 00:19:39.900
MPI run command to use Xgrid.

00:19:39.900 --> 00:19:43.500
You can get more information
about that from www.openmpi.org.

00:19:43.510 --> 00:19:44.980
They're big fans of Xgrid.

00:19:44.980 --> 00:19:47.920
We've been working with them,
and we're looking forward

00:19:47.920 --> 00:19:49.180
to their feedback.

00:19:50.670 --> 00:19:52.910
So at this point in time,
I'd like to bring up the author

00:19:52.910 --> 00:19:55.940
and primary contributor to Xgrid,
David Kraemer,

00:19:55.980 --> 00:20:01.090
and he'll be taking you through some
demos and additional information.

00:20:01.090 --> 00:20:01.090
Thank you.

00:20:03.110 --> 00:20:04.100
Thank you.

00:20:04.100 --> 00:20:06.220
Thank you, Dave.

00:20:06.310 --> 00:20:10.390
So I'm going to talk to you
about Xgrid architecture.

00:20:10.540 --> 00:20:13.250
So as Dave mentioned,
it's a three-tier architecture.

00:20:13.260 --> 00:20:16.500
There's a client,
a controller and an agent.

00:20:16.500 --> 00:20:17.670
The controller is the heart.

00:20:17.700 --> 00:20:19.460
It's in the center.

00:20:19.460 --> 00:20:24.020
It's the one that does the splitting and
the monitoring and collects the results.

00:20:24.020 --> 00:20:26.500
And when the client is ready
to download the results,

00:20:26.540 --> 00:20:27.220
it can get them.

00:20:27.220 --> 00:20:28.960
So here's your client.

00:20:29.010 --> 00:20:30.280
It's detachable.

00:20:30.280 --> 00:20:32.760
As Dave mentioned,
you can shut the lid on the PowerBook,

00:20:32.810 --> 00:20:36.500
take it home, and the job remains
queued on the controller.

00:20:36.500 --> 00:20:38.920
Having the jobs queued on the
controller with no one to do

00:20:38.920 --> 00:20:40.250
the work isn't very useful,
though.

00:20:40.300 --> 00:20:42.180
So of course, you can have agents.

00:20:42.180 --> 00:20:44.460
We have the full-time agents.

00:20:44.480 --> 00:20:46.460
It's our rack right here.

00:20:46.470 --> 00:20:48.240
You can have part-time agents.

00:20:48.240 --> 00:20:51.800
That's your computer labs,
your workstations that

00:20:51.800 --> 00:20:52.860
aren't used at night.

00:20:53.030 --> 00:20:56.990
They can come when the user isn't
using the computer and join the grid.

00:20:57.150 --> 00:20:58.930
And then finally,
you sort of have another

00:20:58.950 --> 00:21:02.040
kind of part-time agents,
which are the internet agents.

00:21:02.040 --> 00:21:06.570
And these are the volunteers across the
world who are participating in your grid

00:21:06.570 --> 00:21:09.440
and helping you solve your problems.

00:21:11.010 --> 00:21:13.030
So let's talk about security.

00:21:13.040 --> 00:21:15.820
A lot of people have questions
about how secure Xgrid is,

00:21:15.820 --> 00:21:18.960
or what the model is,
and how it controls access.

00:21:19.050 --> 00:21:21.520
So first, there's the authentication.

00:21:21.520 --> 00:21:23.290
And you have three choices.

00:21:23.290 --> 00:21:24.130
One is none.

00:21:24.130 --> 00:21:26.390
This is not very secure, of course.

00:21:26.390 --> 00:21:29.940
But it is an option if you're
doing development or testing,

00:21:29.940 --> 00:21:33.620
or you have a private network
that might be suitable for you.

00:21:33.780 --> 00:21:35.940
There's also password and Kerberos.

00:21:35.950 --> 00:21:38.930
And I will talk more about these
authentication methods in the next slide.

00:21:39.100 --> 00:21:40.890
There's also privilege separation.

00:21:41.010 --> 00:21:45.750
So the controller runs as its own user,
and so does the agent.

00:21:45.750 --> 00:21:50.550
But the tasks that get run by
the agent don't run as that user.

00:21:50.690 --> 00:21:55.750
And so the agent uses a helper
tool that runs as root to launch

00:21:55.750 --> 00:22:00.680
the tasks as an unprivileged user,
or in the case of using

00:22:00.680 --> 00:22:05.110
Kerberos authentication,
you can have the task run actually

00:22:05.110 --> 00:22:05.110
as the user who submitted it.

00:22:05.960 --> 00:22:09.390
So the task privileges, as I said,
runs Nobody under password

00:22:09.390 --> 00:22:12.300
authentication or no authentication.

00:22:12.320 --> 00:22:15.300
Otherwise, they run as a submitting user.

00:22:16.810 --> 00:22:19.300
So no password.

00:22:19.330 --> 00:22:22.720
Suitable for private networks only.

00:22:22.720 --> 00:22:25.960
I use this in my own testing,
because it's more convenient

00:22:25.960 --> 00:22:26.940
not to enter a password.

00:22:26.940 --> 00:22:30.260
However, if you go to Kerberos,
then you've got single sign-ons,

00:22:30.290 --> 00:22:34.030
so you only need to enter your password
once at the beginning of the session,

00:22:34.030 --> 00:22:36.800
and then it's just as easy
to use as no password.

00:22:36.900 --> 00:22:39.960
So I would highly recommend
getting Tiger Server,

00:22:39.960 --> 00:22:42.860
setting up an open directory master,
turning on Kerberos,

00:22:42.860 --> 00:22:44.820
and using that with X-Rid.

00:22:44.820 --> 00:22:48.030
that will be most secure and you'll
get the most benefit out of that.

00:22:49.410 --> 00:22:52.310
In the password case,
we don't send a password in

00:22:52.310 --> 00:22:53.530
the clear over the network.

00:22:53.600 --> 00:22:56.400
There's a two-way random
challenge response,

00:22:56.400 --> 00:22:58.900
mutual authentication protocol used.

00:22:58.920 --> 00:23:04.560
One more thing to mention about this
password is that it's a single password.

00:23:04.560 --> 00:23:05.670
It's not per user.

00:23:05.680 --> 00:23:10.230
So if you want ten people
to be able to use the grid,

00:23:10.230 --> 00:23:12.640
you're going to give all ten
people the same password.

00:23:12.640 --> 00:23:16.070
This may not be what you want,
in which case, if you want to go to

00:23:16.070 --> 00:23:20.780
per user authentication,
you need to go to Kerberos.

00:23:22.410 --> 00:23:24.540
As I said, Kerberos is the most secure.

00:23:24.810 --> 00:23:30.130
It also provides confidentiality,
so we do encrypt all communication

00:23:30.130 --> 00:23:36.810
going over the wire if you
use Kerberos authentication.

00:23:36.810 --> 00:23:40.570
So you don't have to worry that
someone else is sniffing your

00:23:40.570 --> 00:23:40.570
results from your thesis project that
you're going to publish next week.

00:23:41.510 --> 00:23:49.780
This requires a directory
system and a KDC.

00:23:49.780 --> 00:23:49.780
We recommend Open Directory Master.

00:23:49.780 --> 00:23:49.780
However,
it does work also with Active Directory.

00:23:49.950 --> 00:23:55.190
The client access is controlled by ACLs.

00:23:55.510 --> 00:23:59.650
So you can specify exactly which
users or groups are allowed to

00:23:59.680 --> 00:24:04.300
connect to the controller and
submit jobs and retrieve results.

00:24:04.370 --> 00:24:08.920
The agent access is also controlled,
but it's only controlled by the presence

00:24:08.920 --> 00:24:11.090
of a principal in the KDC database.

00:24:11.230 --> 00:24:15.430
So if the agent has a principal,
it will be able to connect at this point.

00:24:15.430 --> 00:24:19.590
There is no way to specify that only
certain agents are able to connect.

00:24:21.330 --> 00:24:24.780
So I mentioned the
privilege separation before.

00:24:24.790 --> 00:24:32.990
The Xgrid agent starts
as the user Xgrid agent,

00:24:33.000 --> 00:24:34.990
and it's launched by launchd at startup,
or you can start it manually

00:24:34.990 --> 00:24:34.990
using the xgrid-kiddle command.

00:24:35.360 --> 00:24:37.640
immediately,
because it's launched by LaunchD,

00:24:37.640 --> 00:24:40.790
it starts as root,
but it immediately lowers its privileges.

00:24:40.890 --> 00:24:44.390
But before doing that,
it launches a helper tool,

00:24:44.500 --> 00:24:47.740
and that helper tool also runs as root,
and it remains running as root.

00:24:47.840 --> 00:24:50.760
So the helper tool doesn't have
any sockets open on the network.

00:24:50.760 --> 00:24:53.640
It's not talking to anyone else
except the extroordination,

00:24:53.710 --> 00:24:55.910
so you've got a little
bit more separation there,

00:24:56.080 --> 00:24:57.250
a little bit more protection.

00:24:57.440 --> 00:25:01.940
When the tasks actually run,
they get started by the helper,

00:25:02.030 --> 00:25:04.680
they run as nobody or as the
submitting user in the case

00:25:04.770 --> 00:25:07.830
of Kerberos authentication,
and the results actually get

00:25:07.880 --> 00:25:09.940
sent directly back to the agent.

00:25:10.050 --> 00:25:12.840
There's not an extra copy going
through the helper because of the

00:25:12.840 --> 00:25:16.150
wonders of BSC file descriptor PASA.

00:25:17.910 --> 00:25:23.600
So the discovery and authentication
is also an area where people

00:25:23.610 --> 00:25:25.140
wonder about how it works.

00:25:25.140 --> 00:25:29.240
They a lot of times think that maybe
they need to connect directly to the

00:25:29.300 --> 00:25:32.940
agent to tell the agent what to do,
or they want to go out on the

00:25:32.940 --> 00:25:35.140
network and gather all the agents.

00:25:35.140 --> 00:25:36.960
And that's not how XSRID works.

00:25:36.960 --> 00:25:40.340
The way XSRID works is that
the controller is the one that

00:25:40.340 --> 00:25:42.220
opens the socket on the network.

00:25:42.270 --> 00:25:44.230
It's the only one that
accepts network connections.

00:25:44.330 --> 00:25:46.170
Everyone else has to find the controller.

00:25:46.170 --> 00:25:49.160
So the first thing the controller
does when it starts up is it

00:25:49.440 --> 00:25:53.810
advertises via Bonjour and says that,
"Hey, I'm here on the network."

00:25:53.990 --> 00:25:56.490
Now the agents can be configured
to connect to this service,

00:25:56.620 --> 00:26:00.690
or they can be configured to connect
to an IP address or a DNS name.

00:26:00.690 --> 00:26:04.240
But using Bonjour,
they get instant notification

00:26:04.240 --> 00:26:07.670
that the controller is available
and that they can connect.

00:26:07.780 --> 00:26:12.000
Once they connect,
the mutual authentication occurs.

00:26:14.200 --> 00:26:17.780
And both the controller and the agent
determine whether they are talking

00:26:17.780 --> 00:26:20.490
to who they expect to be talking to.

00:26:20.680 --> 00:26:23.190
The same thing happens with
the client in parallel.

00:26:23.250 --> 00:26:27.590
The client gets the notification
that there's a controller online.

00:26:27.600 --> 00:26:33.180
Presumably, if it's an application,
you've got some sort of browser,

00:26:33.190 --> 00:26:37.380
or it's been pre-configured
to use that controller.

00:26:37.380 --> 00:26:41.020
And so, again, the authentication occurs.

00:26:41.020 --> 00:26:42.030
It's visual.

00:26:42.030 --> 00:26:42.030
And everyone's happy at this point.

00:26:42.030 --> 00:26:42.030
We're all connected,
and we're ready to actually do some work.

00:26:43.110 --> 00:26:47.240
So the workflow follows a
mantra that we call the "Submit,

00:26:47.240 --> 00:26:49.390
Monitor, and Retrieve."

00:26:50.090 --> 00:26:53.420
So the first thing is the client has
some work to do and packages it up as a

00:26:53.420 --> 00:26:59.740
job and sends it off to the controller.

00:26:59.780 --> 00:27:06.190
And the controller splits the
job up into tasks and sends

00:27:06.190 --> 00:27:06.190
the tasks off to the agents.

00:27:06.190 --> 00:27:06.190
So now that the agents get the work,

00:27:07.420 --> 00:27:09.280
They start doing the work,
and once they're done

00:27:09.330 --> 00:27:11.640
spinning the little icons,
they presumably have

00:27:11.640 --> 00:27:18.270
finished the computation,
and they can send the results back.

00:27:18.370 --> 00:27:24.550
But in the meantime,
if one of these agents had gone offline,

00:27:24.550 --> 00:27:25.570
the controller all this time
is monitoring the progress of

00:27:25.570 --> 00:27:25.570
these computations and will
reschedule the work if necessary.

00:27:25.730 --> 00:27:30.060
Once all the work is done,
it gets sent back to the controller.

00:27:30.060 --> 00:27:32.540
The controller collects
the results and stores it,

00:27:32.550 --> 00:27:34.970
waiting for the client
to retrieve the results.

00:27:35.000 --> 00:27:37.880
It notifies the client as soon
as the results are available,

00:27:37.880 --> 00:27:39.980
so the client doesn't
have to keep polling,

00:27:39.980 --> 00:27:41.390
asking, "Are we there yet?

00:27:41.390 --> 00:27:42.320
Are we there yet?

00:27:42.520 --> 00:27:44.190
Are we there yet?"

00:27:44.900 --> 00:27:54.880
So you retrieve the results,
and that's the entire workflow-- submit,

00:27:54.880 --> 00:27:54.880
monitor, retrieve.

00:27:54.880 --> 00:27:54.880
And--sorry.

00:28:04.340 --> 00:28:12.540
We'll get there.

00:28:12.540 --> 00:28:13.240
Almost there.

00:28:13.270 --> 00:28:13.640
All right.

00:28:13.740 --> 00:28:18.550
And now I have a demo to show you
of doing audio encoding on the grid.

00:28:18.630 --> 00:28:21.250
So can I have demo one, please?

00:28:23.140 --> 00:28:26.890
So we have this little demo
app that we put together.

00:28:26.960 --> 00:28:30.090
And the first thing it does is it allows
us to browse for controllers here.

00:28:30.100 --> 00:28:34.590
And so we're going to connect to the
top exer-- over in our rack here.

00:28:34.780 --> 00:28:37.760
And we've got a job queue up there.

00:28:37.760 --> 00:28:40.040
Not much going on yet.

00:28:40.040 --> 00:28:41.740
We're going to drag some
audio files in there.

00:28:41.740 --> 00:28:42.840
And they're AIF.

00:28:42.860 --> 00:28:45.700
And we're going to encode them into AAC.

00:28:45.700 --> 00:28:49.800
We're using the AF Convert
sample code that should come in

00:28:49.870 --> 00:28:52.070
with all your developer tools.

00:28:52.080 --> 00:28:53.310
Nothing real special going on.

00:28:53.320 --> 00:28:54.600
We're just doing the encoding.

00:28:54.640 --> 00:29:00.220
I ran the encoder on my machine last
night to see how long it took to do

00:29:00.220 --> 00:29:02.680
these files serially on one computer.

00:29:02.680 --> 00:29:09.010
And it took about 2 and 1/2 minutes to
encode 600 megabytes of AIF on a G5.

00:29:15.190 --> 00:29:18.770
So, presumably on this XServe rack,
we're going to go a little bit

00:29:18.770 --> 00:29:21.590
faster than two and a half minutes.

00:29:21.590 --> 00:29:26.220
Hopefully all the lights
are lighting up over there,

00:29:26.220 --> 00:29:30.420
and we can see all the
jobs have started running,

00:29:30.420 --> 00:29:35.560
and hopefully a little progress
will go by on a few of them.

00:29:35.560 --> 00:29:38.520
And they keep going, and it looks like a
couple of them are done.

00:29:38.520 --> 00:29:38.520
Looks like they're just about all done.

00:29:39.380 --> 00:29:40.190
Almost.

00:29:40.290 --> 00:29:41.140
Getting there.

00:29:41.300 --> 00:29:49.730
So instead of two and a half minutes,
it looks like we got this down

00:29:49.730 --> 00:29:49.730
to about 20 or 30 seconds.

00:29:49.730 --> 00:29:49.730
So that's the power of using the grid.

00:29:53.980 --> 00:29:56.640
And there you go,
you see we've got our AIFs

00:29:56.660 --> 00:30:01.890
and we've got our AACs,
which are about 10 times smaller.

00:30:01.950 --> 00:30:04.330
Alright, let's go back to the slides.

00:30:11.570 --> 00:30:14.360
So now, how do you administer your grid?

00:30:14.360 --> 00:30:16.600
It's clear how to submit jobs.

00:30:16.600 --> 00:30:19.640
You just drag files into a window, right?

00:30:19.690 --> 00:30:23.320
But administering is a
little bit more complicated.

00:30:23.320 --> 00:30:27.210
You want to think about how you
want to partition your resources up

00:30:27.210 --> 00:30:31.140
and also how to just have them all
configured to find the controller,

00:30:31.150 --> 00:30:32.360
because that's the one thing.

00:30:32.360 --> 00:30:34.550
Everyone needs to know where
the controller is or at least

00:30:34.560 --> 00:30:36.520
know the name of the controller.

00:30:36.580 --> 00:30:40.760
So we have various
administration avenues.

00:30:40.820 --> 00:30:44.580
The first is the sharing preferences,
which configure the Tiger agent.

00:30:44.670 --> 00:30:48.540
There's also the separate pref pane
that configures the Panther agent.

00:30:48.640 --> 00:30:51.210
There's the server admin application,
which you use to actually

00:30:51.210 --> 00:30:53.430
start the processes,
to start the controller

00:30:53.430 --> 00:30:55.820
and start the agent.

00:30:55.820 --> 00:30:58.000
You also can configure it,
and it gives you the same

00:30:58.000 --> 00:31:02.700
configuration options for the agent
as the sharing preferences pane.

00:31:02.750 --> 00:31:04.240
And I'll go into the details more later.

00:31:04.240 --> 00:31:07.560
There's also the XGrid admin application,
and this is the one you use once you've

00:31:07.560 --> 00:31:11.680
started the controller and configured
all the agents to find the controller.

00:31:11.680 --> 00:31:14.710
You then use XGrid admin to
partition the agents into grids,

00:31:14.710 --> 00:31:18.340
to monitor the job queue,
to see how much of the

00:31:18.400 --> 00:31:21.640
performance you're utilizing,
just to get a broad overview.

00:31:21.640 --> 00:31:26.400
It's the administration application
to monitor the grid while it's in use.

00:31:26.400 --> 00:31:30.060
So here's a screenshot from
the sharing preferences.

00:31:30.060 --> 00:31:33.090
Down there at the bottom,
you've got the XGrid item,

00:31:33.090 --> 00:31:34.340
and that's selected.

00:31:34.340 --> 00:31:38.950
And so you've got a start/stop
button and a configure button.

00:31:39.040 --> 00:31:39.340
Pretty simple.

00:31:39.340 --> 00:31:44.680
When you configure things,
these are your choices.

00:31:44.930 --> 00:31:47.500
You specify the controller.

00:31:47.500 --> 00:31:52.770
You can either enter a Rendezvous or,
excuse me, Bonjour service name,

00:31:52.770 --> 00:31:56.350
or a DNS name or an IP address.

00:31:56.620 --> 00:32:00.500
You also get to specify whether it's
a part-time or dedicated resource.

00:32:00.570 --> 00:32:03.730
In the part-time case,
when you only accept tasks

00:32:03.950 --> 00:32:07.270
when the computer is idle,
idle is determined by 15

00:32:07.390 --> 00:32:09.490
minutes of no user activity.

00:32:09.490 --> 00:32:12.050
It doesn't look at
network or disk access.

00:32:12.110 --> 00:32:15.570
It looks purely at mouse and
keyboard activity to determine

00:32:15.610 --> 00:32:17.130
if the computer is idle.

00:32:17.130 --> 00:32:20.490
If a user comes back and moves
the mouse or types something

00:32:20.490 --> 00:32:23.560
after a task has started,
that task will complete,

00:32:23.560 --> 00:32:26.490
but no new tasks will be
accepted by the agent.

00:32:27.710 --> 00:32:31.370
And then finally, you get to choose which
authentication method you want to

00:32:31.370 --> 00:32:33.910
use to connect to the controller.

00:32:33.910 --> 00:32:38.090
And this gives you the choice of none,
password, and Kerberos.

00:32:38.630 --> 00:32:43.370
In Server Admin, you get some of the same
agent configuration controls,

00:32:43.380 --> 00:32:51.480
but you also get an overview of
both the controller and the agent,

00:32:51.480 --> 00:32:56.640
as well as settings to
set for the controller.

00:32:56.640 --> 00:32:56.640
So first, you've got to add your
server with Server Admin.

00:32:56.640 --> 00:32:56.640
You select the service

00:32:57.130 --> 00:32:58.990
You choose which tab you want to look at.

00:32:58.990 --> 00:33:04.880
In this case,
we're looking at the Overview.

00:33:04.880 --> 00:33:12.230
There's also the Logs,
which lets you see the messages that

00:33:12.230 --> 00:33:12.230
are put in the system log by Xgrid,
and then the actual settings

00:33:12.230 --> 00:33:12.230
where you get to set up the
agent and the controller.

00:33:12.780 --> 00:33:14.860
And then finally, once you've set up the
agent and controller,

00:33:14.860 --> 00:33:16.660
you need to press the Start button.

00:33:16.710 --> 00:33:20.440
In this case, it's already started,
so you would click the

00:33:20.510 --> 00:33:22.810
Stop button to stop the services.

00:33:23.630 --> 00:33:26.590
On the Overview tab here,
we see at the top,

00:33:26.590 --> 00:33:30.400
you've got your agent information,
and at the bottom,

00:33:30.400 --> 00:33:34.090
you've got the statistics
about the controller.

00:33:34.680 --> 00:33:37.810
So once you've actually gone
to the Settings tab and you

00:33:37.810 --> 00:33:41.400
choose the Agent Settings,
you can enable the agent.

00:33:41.400 --> 00:33:46.280
You can set the exact same settings
as in the sharing prefs--dedicated,

00:33:46.280 --> 00:33:49.700
part-time,
and which authentication method.

00:33:50.700 --> 00:33:52.370
The controller settings are very similar.

00:33:52.470 --> 00:33:54.810
You can enable,
and then you get to choose the

00:33:54.810 --> 00:33:58.230
authentication method used for
clients and the authentication

00:33:58.230 --> 00:33:59.840
method used for the agents.

00:33:59.840 --> 00:34:01.700
And these can be different if you want.

00:34:01.820 --> 00:34:06.980
If you do want to have the
Kerberos support for running

00:34:06.980 --> 00:34:12.290
tasks as the user that submitted,
you need end-to-end

00:34:12.290 --> 00:34:14.150
Kerberos authentication,
so both clients and agents

00:34:14.150 --> 00:34:14.150
need to be using Kerberos.

00:34:15.400 --> 00:34:19.800
One more thing to talk about in
Server Admin is the Service Ackles.

00:34:19.800 --> 00:34:28.350
These allow you to control which clients
can connect to the Xgrid controller.

00:34:28.350 --> 00:34:28.350
So you select the server,

00:34:28.850 --> 00:34:34.190
You choose the settings,
you choose access, you choose the Xgrid

00:34:34.220 --> 00:34:37.570
service from the services,
and then over here on the right,

00:34:37.570 --> 00:34:40.480
you get to add the users and
the groups that you want to

00:34:40.480 --> 00:34:42.110
allow to use the service.

00:34:42.980 --> 00:34:44.870
Next is the Xgrid Admin Application.

00:34:44.890 --> 00:34:48.160
This is the one you're going to
use to actually monitor the status

00:34:48.160 --> 00:34:50.000
of the grid while it's running.

00:34:50.650 --> 00:34:54.580
This is the overview
tab of the application.

00:34:54.580 --> 00:35:00.960
We've got a tachometer here that gives
you the currently active CPU power of the

00:35:00.960 --> 00:35:04.780
grid-- all the grids in your controller,
in this case.

00:35:04.790 --> 00:35:08.970
The CPU power is simply the
sum of the gigahertz of the

00:35:09.140 --> 00:35:12.040
clock CPUs of all the CPUs.

00:35:12.050 --> 00:35:16.410
So if you've got a dual 2.0,
that's 4 gigahertz of CPU power.

00:35:16.480 --> 00:35:20.320
If you've got a G4 400,
that's 400 megahertz of CPU power,

00:35:20.320 --> 00:35:22.790
one-tenth this amount.

00:35:23.550 --> 00:35:29.420
You get to add the server--the controller
you want to connect to with this app.

00:35:29.420 --> 00:35:32.830
Then you get a list of all the grids.

00:35:32.830 --> 00:35:35.130
You can add more grids.

00:35:35.440 --> 00:35:37.670
You can rename the grids.

00:35:37.670 --> 00:35:40.390
You can choose which
grid is the default grid.

00:35:40.390 --> 00:35:40.390
When someone submits a job to the
controller and doesn't specify

00:35:40.390 --> 00:35:40.390
which grid they want to use,
it goes to the default grid.

00:35:41.020 --> 00:35:44.830
And then you've got the overview,
the agents list, and the jobs list,

00:35:44.870 --> 00:35:48.960
and I will show you those in a moment.

00:35:48.960 --> 00:35:56.430
On the overview tab,
in addition to the statistics,

00:35:56.430 --> 00:35:57.060
you have the tachometer, as I said.

00:35:57.060 --> 00:35:57.060
The statistics are very similar
to what you saw in Server Admin.

00:35:58.330 --> 00:36:01.290
When you go to the Agents tab,
you get a list of the agents

00:36:01.290 --> 00:36:06.360
that are in the grid or being
managed by the entire controller.

00:36:10.000 --> 00:36:14.020
You can use the search widget up there
in the toolbar to narrow the list if you

00:36:14.060 --> 00:36:18.380
have a lot of agents and you're looking
for the status of a particular one.

00:36:19.160 --> 00:36:21.520
And then down at the bottom,
when you select an agent,

00:36:21.520 --> 00:36:24.000
you get a little bit more
information about that agent,

00:36:24.020 --> 00:36:26.180
how many processors it has,
and how many of those

00:36:26.180 --> 00:36:27.410
are currently in use.

00:36:27.830 --> 00:36:32.340
And then the job queue,
probably the most interesting

00:36:32.340 --> 00:36:36.460
part of this application,
lets you actually see

00:36:36.510 --> 00:36:38.660
which jobs are running.

00:36:38.680 --> 00:36:42.720
It shows you the progress,
when they started,

00:36:42.720 --> 00:36:47.090
when they finished that they finished,
or whether they failed or were canceled.

00:36:47.090 --> 00:36:47.090
And you have control to pause
jobs and cancel them using the

00:36:47.090 --> 00:36:47.090
buttons down at the bottom.

00:36:47.650 --> 00:36:48.620
So you have the job list.

00:36:48.640 --> 00:36:50.440
Again,
you can use the search widget to find a

00:36:50.440 --> 00:36:52.240
job you're particularly interested in.

00:36:52.240 --> 00:36:55.590
And then down at the bottom,
you get the statistics about the job.

00:36:55.600 --> 00:37:00.330
One thing to notice here is that
you can look at and see what

00:37:00.330 --> 00:37:01.980
the identifier of the job is.

00:37:01.980 --> 00:37:04.620
And the identifier is just the
string used by the controller

00:37:04.620 --> 00:37:06.110
to uniquely identify the job.

00:37:06.140 --> 00:37:09.160
This normally doesn't need
to be exposed to the user,

00:37:09.160 --> 00:37:12.760
but if you're going to use the command
line tool to work with the grid,

00:37:12.760 --> 00:37:17.210
this allows you to figure out
how to talk about this particular

00:37:17.210 --> 00:37:19.920
job using the command line tool,
you would use the identifier

00:37:19.920 --> 00:37:21.140
when using the command line tool.

00:37:22.730 --> 00:37:25.300
Now I'm going to do a little demo.

00:37:25.300 --> 00:37:27.880
I'm going to actually write
some code for you up on stage,

00:37:27.880 --> 00:37:34.600
show you how to make your own job
submission interface using the Cocoa API.

00:37:36.060 --> 00:37:42.710
So, last year I think I showed
people how to run Calendar.

00:37:42.730 --> 00:37:47.150
CAL is a simple tool that
takes a couple arguments,

00:37:47.150 --> 00:37:50.790
the month and the year,
and then it calculates a text

00:37:51.270 --> 00:37:52.870
calendar and prints it out.

00:37:52.870 --> 00:37:54.300
Let me show you.

00:37:56.550 --> 00:37:59.070
It doesn't take very long.

00:37:59.080 --> 00:38:02.950
But I would like you to ignore the
computational power of this and think

00:38:02.950 --> 00:38:06.950
more in terms of how you would factor
your own computations out into a separate

00:38:07.070 --> 00:38:12.280
small executable that takes various
arguments and depending on the arguments

00:38:12.280 --> 00:38:16.490
does different things and presumably
if you can submit the same executable

00:38:16.490 --> 00:38:19.860
to the grid with slightly different
arguments and run them in parallel,

00:38:19.860 --> 00:38:22.050
you can get a lot of results
back that you can use.

00:38:22.050 --> 00:38:25.510
This -- scientists might think
of this as a parameter study,

00:38:25.540 --> 00:38:29.130
but for video encoding you can
imagine maybe different frames,

00:38:29.160 --> 00:38:32.530
the number of frames -- the range of
frames as the argument to the tool

00:38:32.530 --> 00:38:36.000
and then maybe also the file name
that you're going to be transcoding.

00:38:39.160 --> 00:38:42.230
So first,
I have this grid calendar example,

00:38:42.230 --> 00:38:47.500
which I haven't made any changes to,
really, from the sample code

00:38:47.530 --> 00:38:49.830
that came with Xcode.

00:38:49.970 --> 00:38:55.990
So connects--let's get rid of
these guys from our last demo.

00:38:58.090 --> 00:38:59.150
And create a new job.

00:38:59.160 --> 00:39:02.260
This is just grid sample, basically,
with the name change to

00:39:02.260 --> 00:39:03.500
Grid Calendar so far.

00:39:03.500 --> 00:39:07.150
I haven't made any code changes.

00:39:07.680 --> 00:39:11.620
What this allows you to do,
the sample code lets you submit a job

00:39:11.620 --> 00:39:16.450
that just runs shell with whatever
you type in the command field here

00:39:16.450 --> 00:39:18.900
as the argument to -c of shell,
of sh.

00:39:18.980 --> 00:39:23.290
So I can type echo
'world', submit the job,

00:39:23.290 --> 00:39:29.400
it runs, it finishes,
and I see the results in there.

00:39:29.400 --> 00:39:31.270
It echoed 'hello world' out.

00:39:31.270 --> 00:39:33.830
Not too exciting, but at least it works.

00:39:33.970 --> 00:39:38.450
However, for your own application,
you probably don't want to force

00:39:38.570 --> 00:39:43.080
people to type a command line into
a text field to submit to the grid.

00:39:43.250 --> 00:39:48.080
You'd like there to be a more interesting
user interface that is problem specific.

00:39:48.080 --> 00:39:50.380
So in this case,
we're going to use the new date

00:39:50.510 --> 00:39:54.760
picker control that's in Tiger to
choose which months and which years

00:39:54.760 --> 00:39:56.780
we want to get the calendars for.

00:39:56.800 --> 00:40:04.300
So, first thing I'll do.

00:40:07.240 --> 00:40:14.070
is adding code to these files,
which don't have any code in them yet.

00:40:14.070 --> 00:40:17.930
So this is the application delegate.

00:40:17.930 --> 00:40:25.300
It's just a subclass of the grid sample
application delegate that's already

00:40:25.300 --> 00:40:26.390
in your developer tools examples.

00:40:26.390 --> 00:40:26.390
In case you're wondering, it's in
/developer/examples/xgrid/gridsample.

00:40:29.260 --> 00:40:30.400
That was the interface.

00:40:30.400 --> 00:40:32.490
We're not declaring any
new instance variables,

00:40:32.500 --> 00:40:35.520
so there's really nothing there to show.

00:40:35.520 --> 00:40:40.640
Here we're overriding one method
just to choose a new class for the

00:40:40.640 --> 00:40:43.040
job submission interface controller.

00:40:43.150 --> 00:40:46.130
This is just the way the grid
sample project is set up.

00:40:46.180 --> 00:40:49.780
It's very easy to override the class
that's going to be the window controller

00:40:49.790 --> 00:40:54.470
for the user interface so that we can
create our own method that responds to

00:40:54.470 --> 00:40:58.980
the submit button and takes what's in
the user interface and turns it into a

00:40:58.980 --> 00:41:02.180
job specification to submit to the grid.

00:41:07.420 --> 00:41:14.560
I'm also going to fill in the stubs
on the new window controller here.

00:41:15.330 --> 00:41:17.750
And now in this case,
we're going to--the interface is going

00:41:17.750 --> 00:41:20.990
to have a start date and an end date
that we're going to use to determine

00:41:20.990 --> 00:41:22.940
which months to calculate with Cal.

00:41:28.670 --> 00:41:32.160
I'm going to leave the
implementation empty for now.

00:41:32.160 --> 00:41:35.340
We're just going to make sure
I didn't introduce any typos.

00:41:35.390 --> 00:41:37.550
Everything still builds.

00:41:38.430 --> 00:41:42.170
And I need to change a couple
classes in the nib file now.

00:41:42.170 --> 00:41:45.720
So I created a new application delegate.

00:41:48.500 --> 00:41:51.800
So I need to change
the class of this guy.

00:41:51.870 --> 00:41:57.340
It's currently
GridSampleApplicationDelegate.

00:41:57.340 --> 00:42:02.970
I want it to be
GridCalendarApplicationDelegate.

00:42:02.970 --> 00:42:06.190
That's it for the main menu.

00:42:11.550 --> 00:42:14.920
And then we have the New Job Nib.

00:42:15.010 --> 00:42:18.640
And this is the one that actually
gets shown when you choose

00:42:18.690 --> 00:42:23.210
"Click New Job" from the toolbar.

00:42:23.210 --> 00:42:29.980
This looks pretty good,
but we don't actually want to

00:42:30.100 --> 00:42:31.910
specify the name or the command.

00:42:31.910 --> 00:42:31.910
So we can get rid of these guys.

00:42:31.910 --> 00:42:31.910
We want a start date.

00:42:34.990 --> 00:42:37.940
We want an end date.

00:42:38.070 --> 00:42:39.920
And we need a date picker.

00:42:40.060 --> 00:42:44.340
So we got one of these.

00:42:44.510 --> 00:42:46.160
Another one of these.

00:42:48.010 --> 00:42:57.340
And... let's see, we don't need any time,
since we're just choosing

00:42:57.340 --> 00:42:57.340
months and years.

00:43:05.730 --> 00:43:08.530
So that's about it for the window.

00:43:08.770 --> 00:43:12.720
I also need to change the
file's owner class here.

00:43:12.760 --> 00:43:18.300
It's currently
GridSampleNewJobWindowController.

00:43:18.300 --> 00:43:18.300
I want it to be
GridCalendarNewJobWindowController.

00:43:21.720 --> 00:43:24.250
And so it looks like that
nib's looking pretty good.

00:43:24.310 --> 00:43:31.680
However, nothing's connected yet,
so I'm going to use Cocoa Bindings to

00:43:31.730 --> 00:43:39.610
bind these controls directly to the
instance variables that I defined.

00:43:39.610 --> 00:43:39.610
So we've got the owner object,
we've got a start date,

00:43:43.570 --> 00:43:47.330
End date.

00:43:47.360 --> 00:43:49.480
And that should be it for our new job.

00:43:49.500 --> 00:43:52.740
So, before I write any code,
let's just make sure

00:43:52.740 --> 00:43:54.680
I didn't make any mistakes.

00:43:54.680 --> 00:43:55.980
We'll run the app.

00:43:56.010 --> 00:43:58.930
And sure enough,
it looks like everything's

00:43:58.930 --> 00:44:00.330
working just fine.

00:44:00.330 --> 00:44:04.740
So now, we have to actually take what's
in the user interface and turn

00:44:04.830 --> 00:44:06.730
it into a job specification.

00:44:06.870 --> 00:44:10.690
A job specification is a
dictionary that contains a number

00:44:10.690 --> 00:44:12.740
of well-known keys and values.

00:44:15.240 --> 00:44:22.620
So the way this code is set up is that
it will call a job specification method

00:44:22.620 --> 00:44:24.930
when the submit button is clicked.

00:44:25.120 --> 00:44:27.770
But before that,
we need to set up some initial

00:44:27.830 --> 00:44:31.280
values so that the user
interface is just ready to go.

00:44:31.280 --> 00:44:35.970
So it's a good demo just to click
Submit without having to enter anything.

00:44:35.970 --> 00:44:39.390
So in this case,
we're just creating a new start date,

00:44:39.390 --> 00:44:42.210
a new end date,
and setting them as the initial

00:44:42.210 --> 00:44:43.160
values for those instance variables.

00:44:44.700 --> 00:44:49.160
We also need to manage our memory,
as all good Cocoa programmers know.

00:44:49.160 --> 00:44:52.530
And finally,
this is the interesting method here.

00:44:52.530 --> 00:44:56.340
We're going to return the job
specification from this method

00:44:56.340 --> 00:44:59.030
using what's in the user interface.

00:44:59.110 --> 00:45:03.840
So, first thing I'm going to do is
put the dates in ascending order,

00:45:03.840 --> 00:45:06.540
just for programming convenience.

00:45:06.570 --> 00:45:11.030
So if the user enters a start date
that comes after the end date,

00:45:11.030 --> 00:45:11.790
we'll just swap them.

00:45:11.790 --> 00:45:11.790
It's very easy to do.

00:45:12.110 --> 00:45:16.100
We have to do this conversion
here because the date picker

00:45:16.100 --> 00:45:19.850
instance variables are NSDate,
but it's much easier to work

00:45:19.890 --> 00:45:24.320
with NSCalendarDate when all you
care about are months and years.

00:45:24.750 --> 00:45:28.920
Then we just compare them,
and if they're in descending order,

00:45:28.920 --> 00:45:32.570
we swap the order so that
they're in ascending order.

00:45:34.900 --> 00:45:37.150
The next thing we're going to do
here is create the name of the job.

00:45:37.210 --> 00:45:39.690
So rather than have the user
enter the name of a job,

00:45:39.780 --> 00:45:43.460
we're just going to calculate
it based on which the structure

00:45:43.460 --> 00:45:44.840
of the job specification.

00:45:44.930 --> 00:45:47.310
The first thing we do is we
create the task prototype.

00:45:47.420 --> 00:45:51.130
Since we're going to submit a
single job that does say 12 months,

00:45:51.130 --> 00:45:54.220
we're going to have each month
be a separate task so that

00:45:54.220 --> 00:45:55.760
they can run in parallel.

00:45:55.760 --> 00:45:59.800
And -- but since each task is going to
be running exactly the same command,

00:45:59.860 --> 00:46:03.070
it's convenient to set up a
prototype that all of the tasks

00:46:03.080 --> 00:46:05.360
that we submit are based on.

00:46:05.360 --> 00:46:07.040
In this case,
it's a very simple prototype.

00:46:07.080 --> 00:46:09.430
We're just specifying an
absolute path that we know

00:46:09.430 --> 00:46:11.040
exists on all of the computers.

00:46:11.160 --> 00:46:15.370
However, you could include input data,
the actual command data

00:46:15.370 --> 00:46:18.360
with this task prototype,
which makes it much more

00:46:18.470 --> 00:46:19.460
efficient to submit.

00:46:19.460 --> 00:46:22.500
If you're submitting a thousand
tasks that all run the same command,

00:46:22.500 --> 00:46:25.500
you don't want to submit that
command a thousand times.

00:46:25.500 --> 00:46:28.340
You don't want to submit the
executable code a thousand times.

00:46:28.410 --> 00:46:31.680
You just want to submit it once
and have them all use that.

00:46:31.820 --> 00:46:34.950
So here we create the specification.

00:46:35.690 --> 00:46:41.290
We set the command using
the command key and...

00:46:41.740 --> 00:46:46.710
We create a prototype identifier,
which is just the name of

00:46:46.780 --> 00:46:52.190
the command in this case,
because we only have one prototype.

00:46:52.320 --> 00:46:55.920
It doesn't really
matter what the name is.

00:46:56.170 --> 00:46:59.730
But you can have any
number of prototypes,

00:46:59.730 --> 00:47:00.540
all keyed off a different name,
and then you can have some tasks

00:47:00.540 --> 00:47:00.540
are based on one prototype,
other tasks based on another prototype.

00:47:07.740 --> 00:47:11.540
So now with the prototype,
I'm going to create a test specification.

00:47:11.570 --> 00:47:14.920
So again,
we start with the empty dictionary.

00:47:15.040 --> 00:47:18.440
We've got those integers for
the start year and the start

00:47:18.440 --> 00:47:22.520
month that we determined before
when we were creating the name.

00:47:22.520 --> 00:47:25.680
We're going to use it now as a counter,
so we're going to assign

00:47:25.680 --> 00:47:27.080
it to a current variable.

00:47:27.080 --> 00:47:29.920
And we've got this while loop here,
and we're just going

00:47:29.920 --> 00:47:33.000
to keep looping over,
creating tasks, and then we're going

00:47:33.010 --> 00:47:35.740
to increment the month,
and then we'll increment the

00:47:35.740 --> 00:47:37.690
year when we get to December.

00:47:38.410 --> 00:47:40.710
So in this case,
we turn the month and the

00:47:40.790 --> 00:47:44.520
year into strings because
arguments are always strings.

00:47:44.700 --> 00:47:47.670
We put them in an array,
then we create the

00:47:47.710 --> 00:47:49.940
specification in this case.

00:47:49.940 --> 00:47:53.740
We're saying that it's based
on that task prototype that we

00:47:53.850 --> 00:47:57.510
generated a few lines up and we're
going to use those arguments.

00:47:57.510 --> 00:48:02.340
So each task is going to have unique
arguments but the same command.

00:48:02.340 --> 00:48:05.980
Then, task identifier is any identifier
you want to use to identify

00:48:05.980 --> 00:48:07.450
the task within the job.

00:48:07.450 --> 00:48:11.940
It must be unique within the job but it
doesn't need to be unique across jobs.

00:48:11.940 --> 00:48:16.460
It's solely for the person submitting
or the application submitting to be able

00:48:16.460 --> 00:48:20.840
to then refer back to specific results
when you do retrieve the results and you

00:48:20.840 --> 00:48:25.660
want to find the results of task 7 or
task B or whatever you called the task.

00:48:25.700 --> 00:48:28.340
The identifier is an opaque string.

00:48:29.170 --> 00:48:34.490
We add the task specification to the
larger task specifications dictionary

00:48:34.490 --> 00:48:37.340
using the task identifier as the key.

00:48:37.340 --> 00:48:41.430
And then we look for the end condition.

00:48:41.510 --> 00:48:46.270
If we're not there,
we increment the month.

00:48:46.270 --> 00:48:52.840
If we're off into month 13,
we're probably really meant to

00:48:52.940 --> 00:48:54.690
be in January of the next year.

00:48:54.690 --> 00:48:54.690
So we handle that, too.

00:48:54.860 --> 00:48:57.420
Almost all of it,
the last part is putting it all

00:48:57.420 --> 00:48:59.540
together into a job specification.

00:48:59.560 --> 00:49:05.090
So you can specify an application
identifier when you submit jobs.

00:49:05.090 --> 00:49:08.780
You can also specify when you
write an application using the

00:49:08.780 --> 00:49:13.380
Cocoa API that you are only interested
in jobs with a particular identifier.

00:49:13.450 --> 00:49:17.180
And this means that your job list in
your application if you do have a job

00:49:17.180 --> 00:49:21.020
list will only be displaying the ones
that are relevant to that application

00:49:21.020 --> 00:49:25.560
and not ones that were submitted by other
applications or by the command line tool.

00:49:25.560 --> 00:49:27.860
So we set the name that
we determined before,

00:49:27.880 --> 00:49:31.480
we set the application identifier,
we set the prototypes and we set

00:49:31.500 --> 00:49:33.390
the specifications and that's it.

00:49:33.480 --> 00:49:36.580
That's the whole job specification
that we've put together.

00:49:36.580 --> 00:49:39.400
So let's see how that works.

00:49:45.870 --> 00:49:49.070
So we've got my start
conditions in here already.

00:49:49.150 --> 00:49:51.040
Let's do three years here.

00:49:51.040 --> 00:49:52.960
We're going to try.

00:49:52.960 --> 00:49:56.020
From January 2005 to December 2007.

00:49:56.110 --> 00:49:58.080
Submit the job.

00:49:58.300 --> 00:50:01.790
So you see the name was
generated based on that.

00:50:02.050 --> 00:50:04.150
And you see the progress is going by.

00:50:04.170 --> 00:50:07.060
As each task finishes,
the controller recognizes

00:50:07.060 --> 00:50:10.380
that and increments the
progress a little bit further.

00:50:10.460 --> 00:50:13.230
It's just going purely by.

00:50:13.230 --> 00:50:18.350
If there's 36 tasks and
18 of them are done,

00:50:18.470 --> 00:50:21.490
we're at 50%. So this
is going pretty quick.

00:50:21.490 --> 00:50:21.490
As you saw,
CAL doesn't take any time to run.

00:50:21.640 --> 00:50:23.440
But we can look at the results now.

00:50:23.580 --> 00:50:24.360
And here they all are.

00:50:24.360 --> 00:50:27.670
We've got January 2005 at the top.

00:50:27.920 --> 00:50:29.960
And we've got December 2007
at the bottom.

00:50:30.010 --> 00:50:35.250
So that's really how easy it is to
create your own user interface in your

00:50:35.250 --> 00:50:37.800
Cocoa apps to submit jobs to the grid.

00:50:37.800 --> 00:50:40.590
And that is it for that demo.

00:50:49.100 --> 00:50:51.240
That pretty much wraps up our talk today.

00:50:51.290 --> 00:50:56.210
I think I'll invite Ernie
Prabacher and Dava back up on

00:50:56.210 --> 00:50:59.110
stage to take any questions.

00:50:59.170 --> 00:51:02.110
But before we do,
let's just remind you to take a look

00:51:02.110 --> 00:51:04.060
at the session website for this.

00:51:04.060 --> 00:51:07.660
The grid calendar final code is
available on the session site,

00:51:07.660 --> 00:51:11.680
as well as some documentation for
the Xgrid Foundation frameworks.

00:51:11.680 --> 00:51:14.990
To see more how those are used,
I highly recommend looking

00:51:14.990 --> 00:51:18.410
at the example code that does
come with the developer tools.
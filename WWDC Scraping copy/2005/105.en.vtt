WEBVTT

00:00:10.760 --> 00:00:13.100
Okay, good afternoon.

00:00:13.100 --> 00:00:16.940
Welcome to session 105,
the Tiger HIToolbox.

00:00:16.940 --> 00:00:17.820
My name's Eric Schlegel.

00:00:17.820 --> 00:00:19.980
I'm an engineer in the
HIToolbox group at Apple.

00:00:19.980 --> 00:00:25.620
And I'm going to be talking to you
today about what's new in the HIToolbox,

00:00:25.620 --> 00:00:28.180
HI services,
and navigation services frameworks.

00:00:28.180 --> 00:00:32.840
I'm going to emphasize mostly what's
new since last year at the developers

00:00:32.840 --> 00:00:36.520
conference since we did talk about those
and what was new in Tiger and those

00:00:36.520 --> 00:00:38.790
frameworks a bit last year as well.

00:00:39.300 --> 00:00:42.060
So to start out with,
I'd like to cover some of the things

00:00:42.060 --> 00:00:43.960
we've been doing since last year.

00:00:43.960 --> 00:00:47.220
It's been a pretty busy year
for the HIToolbox group.

00:00:47.220 --> 00:00:49.890
We've had a number of
deliverables in 2005,

00:00:49.950 --> 00:00:53.620
starting with Evan Prusha,
son of our engineer Brian Prusha,

00:00:53.710 --> 00:00:57.320
followed by Ewan McLeod,
son of our engineer David McLeod.

00:00:57.740 --> 00:00:59.550
We also have a Fullerton
to be named later,

00:00:59.550 --> 00:01:03.040
son of our engineer Guy Fullerton,
coming out soon.

00:01:03.070 --> 00:01:05.240
And finally,
we have a Rothart to be named later,

00:01:05.340 --> 00:01:08.700
son of our engineer Kurt Rothart,
also coming out soon.

00:01:08.780 --> 00:01:10.710
So you can see of the
six people in this group,

00:01:10.990 --> 00:01:13.300
four of them are new
parents in recent months.

00:01:13.300 --> 00:01:15.940
And that explains why I'm the
one up here on this stage giving

00:01:15.940 --> 00:01:18.080
you this presentation today.

00:01:18.080 --> 00:01:20.670
They're all busy taking
care of their kids.

00:01:20.970 --> 00:01:23.820
So we did do one other thing.

00:01:23.820 --> 00:01:25.300
We shipped Tiger.

00:01:25.300 --> 00:01:28.250
So that's what I'm going
to talk to you about today.

00:01:28.800 --> 00:01:30.860
Here's what I'm going to cover today.

00:01:30.920 --> 00:01:35.950
I'll start with a review from last year,
some of the things that we talked

00:01:36.060 --> 00:01:39.160
about at last year's developers
conference that were new in the

00:01:39.280 --> 00:01:41.240
toolbox already at that point.

00:01:41.370 --> 00:01:44.750
I'll cover in much more depth
what's new this year and the things

00:01:44.790 --> 00:01:47.230
that we've done since last year.

00:01:47.280 --> 00:01:51.290
Then Brian Prusa will come up and
tell you about the HI archive API,

00:01:51.290 --> 00:01:54.560
which is a way to save out
HI objects of various forms as

00:01:54.560 --> 00:01:58.860
well as other core foundation
data types to memory or to disk.

00:01:58.860 --> 00:02:02.100
And also give you a little bit
of information about what's

00:02:02.160 --> 00:02:04.020
new in navigation services.

00:02:04.020 --> 00:02:06.270
Then I'll be talking a bit
about compatibility tips,

00:02:06.270 --> 00:02:09.960
ways to make your applications
run well on Tiger.

00:02:10.010 --> 00:02:12.950
And then some other changes in Tiger,
changes in other parts of the

00:02:13.020 --> 00:02:16.740
operating system that can still
affect your Carbon application.

00:02:16.740 --> 00:02:18.990
And then finally we'll have some Q&A.

00:02:19.610 --> 00:02:22.340
Okay, so what is HIToolbox?

00:02:22.340 --> 00:02:24.580
At the most literal level,
it's a framework.

00:02:24.580 --> 00:02:26.840
It lives in system library frameworks.

00:02:26.940 --> 00:02:29.720
But it's not really an
application framework,

00:02:29.740 --> 00:02:34.020
like PowerPlant or AppKit or Mac app
or Mac Zoop or many of these others.

00:02:34.100 --> 00:02:36.590
It's more of a user interface tool kit.

00:02:36.660 --> 00:02:39.450
It's something you use to
build your user interface,

00:02:39.470 --> 00:02:43.080
but it doesn't have a document
architecture or an undo

00:02:43.100 --> 00:02:45.520
model or things like that.

00:02:45.520 --> 00:02:49.490
So as we think about what to do
with toolbox in the future and

00:02:49.490 --> 00:02:51.300
where we want to go with it.

00:02:51.470 --> 00:02:53.870
We tend to think about who are
some of the typical clients

00:02:54.220 --> 00:02:56.960
for the application toolbox.

00:02:56.960 --> 00:02:59.430
One of the big clients for the
toolbox are developers doing

00:02:59.430 --> 00:03:03.860
cross-platform development,
people writing applications that

00:03:03.950 --> 00:03:09.980
run both on Mac OS and on Windows,
maybe on versions of UNIX or Linux.

00:03:09.980 --> 00:03:13.490
And these developers have told us
commonly that having a procedural API on

00:03:13.490 --> 00:03:19.020
Mac OS X is a good thing because it gives
a good corresponding API for things that

00:03:19.030 --> 00:03:21.670
they've used on other platforms as well.

00:03:21.800 --> 00:03:26.160
Another set of important clients
for HIToolbox and the Carbon API are

00:03:26.160 --> 00:03:30.290
developers using a proprietary or
third-party application framework.

00:03:30.410 --> 00:03:33.290
Often these developers have millions
of lines of code that they've already

00:03:33.360 --> 00:03:36.780
written to their custom framework,
and it's very difficult or

00:03:36.790 --> 00:03:40.130
impossible for them to move to
some Apple-provided framework

00:03:40.220 --> 00:03:42.640
or other third-party frameworks.

00:03:42.720 --> 00:03:45.800
Another set of clients are
those of you who are still doing

00:03:45.810 --> 00:03:47.630
development for classic Mac OS.

00:03:47.700 --> 00:03:50.790
This is getting smaller every year,
I know, but there are still a number of

00:03:50.790 --> 00:03:54.830
people who are doing development that
needs to run on classic Mac OS for

00:03:54.900 --> 00:03:57.800
the education market and for other
markets where there's still an

00:03:57.810 --> 00:04:00.290
installed base of these machines.

00:04:00.970 --> 00:04:05.240
and having the ability to write
an application that works both

00:04:05.240 --> 00:04:08.740
on the CarbonLib shared library
on classic Mac OS and on the

00:04:08.740 --> 00:04:13.480
Carbon frameworks on Mac OS X is
really valuable to these developers.

00:04:13.480 --> 00:04:16.790
Another set of clients are those
of you who are using a code

00:04:16.920 --> 00:04:21.270
base that may be incompatible or
difficult to use with Objective-C.

00:04:21.440 --> 00:04:24.710
We have lots of developers still who
are using languages such as Lisp,

00:04:24.810 --> 00:04:29.880
Pascal, Fortran, Modula 2 or Real Basic,
languages where it's a little

00:04:29.880 --> 00:04:32.930
awkward to call into Objective-C but
somewhat easier to call into a

00:04:32.930 --> 00:04:35.770
procedural API such as Carbon.

00:04:36.340 --> 00:04:38.780
And finally, but I hope not least,
I hope a lot of you use

00:04:38.780 --> 00:04:40.940
Carbon because you just like it.

00:04:40.940 --> 00:04:44.840
We've tried hard to build an API that's
easy to use and that's enjoyable and

00:04:44.840 --> 00:04:48.230
that can help you get your job done,
and I hope you agree.

00:04:48.370 --> 00:04:52.530
So we try to keep all of these developer
clients in mind as we think about where

00:04:52.570 --> 00:04:54.790
the toolbox should go in the future.

00:04:56.420 --> 00:05:00.200
As we planned the work for Tiger,
we thought about some overarching

00:05:00.400 --> 00:05:05.710
themes to give us some guidelines about
what kind of work we wanted to do.

00:05:05.790 --> 00:05:08.250
And to give you sort of a
mental framework for what I'm

00:05:08.430 --> 00:05:11.120
going to be talking about,
I want to cover some of those

00:05:11.130 --> 00:05:14.560
themes with you so you have an
idea of where I'm coming from.

00:05:14.590 --> 00:05:17.780
One of the big themes for Tiger in
the Toolbox group was to continue

00:05:17.780 --> 00:05:20.040
the transition to compositing mode.

00:05:20.070 --> 00:05:23.040
Hopefully you all know by now
that compositing mode is a new way

00:05:23.040 --> 00:05:27.860
of drawing your window content,
which we introduced in Mac OS 10.2.

00:05:27.860 --> 00:05:30.630
And in this mode,
all of your window content

00:05:30.780 --> 00:05:34.890
is drawn as part of a custom
control or custom HI view.

00:05:35.200 --> 00:07:10.000
[Transcript missing]

00:07:10.630 --> 00:07:13.750
Another theme for Tiger was
support for voiceover.

00:07:13.880 --> 00:07:17.360
That's our technology for
doing spoken user interfaces.

00:07:17.570 --> 00:07:20.500
We have sort of two tracks for voiceover.

00:07:20.500 --> 00:07:24.870
The first track is supporting the
accessibility APIs in the toolbox

00:07:25.010 --> 00:07:27.500
itself and in our standard controls.

00:07:27.600 --> 00:07:30.500
So we've tried very hard to make
sure that all the standard controls,

00:07:30.500 --> 00:07:33.550
all the standard widgets and
user interface provided by

00:07:33.550 --> 00:07:36.500
HIToolbox is accessible in Tiger.

00:07:36.500 --> 00:07:41.150
And the other track is providing
APIs and Carbon events so that your

00:07:41.150 --> 00:07:46.590
application can become accessible itself
and make your own content accessible.

00:07:47.570 --> 00:07:50.990
Fourth theme for Tiger was
support for Spotlight.

00:07:51.220 --> 00:07:55.430
We don't really have any APIs or
Carbon events to support Spotlight,

00:07:55.430 --> 00:07:59.630
but we do have user interface changes
so that you can do Spotlight searches

00:07:59.740 --> 00:08:03.810
directly from within navigation
services open and save dialogs.

00:08:04.380 --> 00:08:07.800
Another theme was to improve
Carbon-COCO integration.

00:08:07.800 --> 00:08:11.420
We know that a lot of you are
trying to use Cocoa technologies

00:08:11.430 --> 00:08:14.120
in your application,
and we think that's great.

00:08:14.270 --> 00:08:15.930
We want you to continue doing that.

00:08:15.930 --> 00:08:19.040
We see the future of
Mac OS X application development as

00:08:19.120 --> 00:08:22.530
really being one where applications
aren't really Carbon applications

00:08:22.530 --> 00:08:26.570
or Cocoa applications,
they're just Mac OS X applications,

00:08:26.570 --> 00:08:29.640
and they use whatever API is
applicable or suitable for

00:08:29.770 --> 00:08:31.810
their particular task at hand.

00:08:31.870 --> 00:08:36.370
So our goal is to make it much easier
for you to use Cocoa technologies

00:08:36.370 --> 00:08:39.200
in a Carbon application and
indeed vice versa as well,

00:08:39.200 --> 00:08:43.850
so that you can choose the right
API for the problem you have.

00:08:44.830 --> 00:08:47.070
And finally,
we want to always continue to

00:08:47.220 --> 00:08:49.700
solve common developer problems.

00:08:49.720 --> 00:08:51.970
Those things that you run
into every time you build a

00:08:51.970 --> 00:08:54.700
Mac OS X application using Carbon,
the things that are annoying

00:08:54.700 --> 00:08:56.200
every time you do it.

00:08:56.290 --> 00:08:58.750
We just want to solve those,
get it out of the way,

00:08:58.790 --> 00:09:01.210
so that you never have
to deal with it again.

00:09:06.980 --> 00:09:10.380
So a quick review of what we talked
about at last year's developers

00:09:10.390 --> 00:09:13.000
conference for the HIToolbox.

00:09:13.040 --> 00:09:14.400
We covered resolution independence.

00:09:14.400 --> 00:09:18.350
As I said, there are three modes,
framework scaled mode, app scaled mode,

00:09:18.350 --> 00:09:20.280
and the default magnified mode.

00:09:20.280 --> 00:09:22.400
We covered some expanded HIView APIs.

00:09:22.400 --> 00:09:26.860
We're trying to increase the
set of HIView APIs available in

00:09:26.920 --> 00:09:31.430
HIView.h and make sure that for
each API that is in controls.h that

00:09:31.500 --> 00:09:35.140
still makes sense that you want to
have an HIView equivalent of that.

00:09:35.140 --> 00:09:38.470
So that instead of having to go back
and forth between controls.h and

00:09:38.470 --> 00:09:42.170
HIView.h and figure out which API set
applies in this particular instance,

00:09:42.170 --> 00:09:45.940
you just have one consistent
HIView set that's easy to learn,

00:09:45.940 --> 00:09:49.740
that makes sense in all cases,
makes it easier to document,

00:09:49.740 --> 00:09:52.210
easier to apply in your applications.

00:09:52.500 --> 00:09:55.400
Along with this,
we also talked about introducing

00:09:55.440 --> 00:09:59.200
some APIs to do mouse tracking
regions at the HIView level

00:09:59.200 --> 00:10:01.540
rather than at the window level.

00:10:01.540 --> 00:10:04.930
A mouse moves into and out of the
tracking region are sent directly to

00:10:04.930 --> 00:10:06.980
the view rather than to the window.

00:10:07.250 --> 00:10:09.910
And second, if you need to move a
view inside your window,

00:10:09.920 --> 00:10:13.720
say you're scrolling or you're just
repositioning a view back and forth,

00:10:13.720 --> 00:10:16.980
by using the new HIView
tracking area APIs in Tiger,

00:10:16.990 --> 00:10:20.550
the tracking area moves along with
the view rather than you having

00:10:20.560 --> 00:10:23.050
to move it explicitly yourself.

00:10:23.540 --> 00:10:26.600
We also talked about
some HIShape support.

00:10:26.600 --> 00:10:30.310
HIShape is a new data type,
floating point data type,

00:10:30.310 --> 00:10:33.480
that replaces the
QuickDraw region handle.

00:10:33.480 --> 00:10:36.880
And we're adopting that across the
HIViewManager so that we can use

00:10:36.880 --> 00:10:40.930
HIShapes to specify control regions,
structure regions, content regions,

00:10:40.980 --> 00:10:42.860
things like that.

00:10:42.860 --> 00:10:45.170
And finally,
a request that we've heard a lot from

00:10:45.180 --> 00:10:50.420
developers over the last few years is
the ability to easily be notified before

00:10:50.420 --> 00:10:55.750
and after changes to an editing field,
and edit text control, let's say.

00:10:55.950 --> 00:10:58.820
and we talked about last year
that we were introducing some

00:10:58.930 --> 00:11:02.410
Carbon events that would be sent in
these two cases before and after.

00:11:02.630 --> 00:11:05.940
Those weren't completely functional
in last year's release of Tiger,

00:11:05.940 --> 00:11:07.700
the developer preview release.

00:11:07.730 --> 00:11:13.540
But the good news is that in Tiger GM,
those text change notification events

00:11:13.660 --> 00:11:16.760
are sent regardless of whatever
change is being made to an edit field.

00:11:16.790 --> 00:11:17.930
They're always being sent.

00:11:17.960 --> 00:11:20.960
The only exception would be if
you explicitly set the text of an

00:11:20.960 --> 00:11:22.520
edit field with set control data.

00:11:22.690 --> 00:11:24.880
But they aren't set in that
case because we figure you

00:11:24.880 --> 00:11:26.320
know what you're doing then.

00:11:26.410 --> 00:11:30.520
So those text change notifications
are fully functional now and I think

00:11:30.520 --> 00:11:35.000
that will help make your life a lot
easier in a lot of different cases.

00:11:35.040 --> 00:11:38.660
Okay, so now I'm going to go right
into what's new from last year.

00:11:38.680 --> 00:11:42.010
And I'll just go manager by
manager and give you some details,

00:11:42.090 --> 00:11:45.150
some highlights of the things that
we think you will want to know

00:11:45.160 --> 00:11:48.420
about for your Carbon application
when you're running on Tiger.

00:11:48.660 --> 00:11:50.860
The appearance manager.

00:11:50.890 --> 00:11:52.660
The thing we're trying to do with the
appearance manager is to make sure that

00:11:52.660 --> 00:11:52.660
the application is running on Tiger.

00:11:52.660 --> 00:11:55.120
And the purpose of the appearance
manager really is to make it easy

00:11:55.120 --> 00:11:57.590
to use the appearance manager to
draw with core graphics and to use

00:11:57.770 --> 00:12:00.620
core graphics drawing in conjunction
with appearance manager drawing.

00:12:00.620 --> 00:12:04.120
So to that end,
we have some new APIs here.

00:12:04.120 --> 00:12:07.270
HIThemeSetStrokeColor,
HIThemeSetFillColor,

00:12:07.270 --> 00:12:11.280
and HIThemeSetTextFillColor which
take a theme brush or theme text

00:12:11.520 --> 00:12:15.900
color and put the corresponding color
or pattern into a CG context so that

00:12:15.900 --> 00:12:20.710
you can draw into the context using
that theme brush or theme text color.

00:12:20.860 --> 00:12:22.610
Previously,
there wasn't any way to do that.

00:12:22.670 --> 00:12:24.390
You couldn't do this at all, basically.

00:12:24.400 --> 00:12:27.160
And if you needed to draw with a
theme brush or a theme text color,

00:12:27.280 --> 00:12:29.400
you pretty much had to
fall back to Quick Draw.

00:12:29.690 --> 00:12:33.320
Another API we have here is
HITHeamBrushCreatCGColor,

00:12:33.520 --> 00:12:36.440
and that takes a theme brush
and gives you back a CGColorRef.

00:12:36.440 --> 00:12:39.370
The CGColorRef is a core graphics
data type that can then be

00:12:39.420 --> 00:12:41.340
passed around your application.

00:12:41.340 --> 00:12:43.700
It can be applied to
multiple different contexts,

00:12:43.700 --> 00:12:46.430
and that gives you better
performance than using just

00:12:46.430 --> 00:12:49.230
HITHemeSetFillColor each time,
for example,

00:12:49.350 --> 00:12:53.280
because the CGColorRef encapsulates
a lot of the data and avoids some

00:12:53.280 --> 00:12:56.890
of the performance hit of actually
applying and converting a theme

00:12:56.890 --> 00:13:00.220
brush into the context every time.

00:13:00.220 --> 00:13:05.370
We also have some appearance manager
APIs to draw some of the new controls.

00:13:05.700 --> 00:13:08.750
We now allow you to draw
Panther-style tab controls

00:13:08.860 --> 00:13:11.100
using the Appearance Manager,
for example.

00:13:11.100 --> 00:13:12.820
That wasn't previously possible.

00:13:12.920 --> 00:13:18.650
And we have HITHeamDrawSegment to
allow drawing a segmented view.

00:13:18.650 --> 00:13:18.650
Oh dear.

00:13:19.530 --> 00:13:22.350
Please ignore the video errors.

00:13:22.370 --> 00:13:24.340
That's going to be a
little difficult though,

00:13:24.340 --> 00:13:24.900
isn't it?

00:13:26.130 --> 00:13:28.850
All right, well,
I'm going to keep talking.

00:13:28.860 --> 00:13:32.740
Also, HITHeamDrawTextBox now has
some implementation changes

00:13:32.860 --> 00:13:36.500
so that it can work outside
of a 16-bit coordinate range.

00:13:36.500 --> 00:13:39.890
So if you have a window with
a great deal of content,

00:13:39.890 --> 00:13:44.860
maybe you have a large number of
files or a large number of fonts

00:13:44.880 --> 00:13:49.290
that are being scrolled up and down,
HITHeamDrawTextBox can now be

00:13:49.290 --> 00:13:49.290
used to draw that no matter where
you are in that scrolling range.

00:13:49.900 --> 00:13:53.580
Well, I can see the slides here,
but you can't.

00:13:53.580 --> 00:13:56.400
So hopefully my explanations
will be clear enough.

00:13:56.620 --> 00:13:58.770
Carbon Event Manager is
the next slide I'm on.

00:13:58.860 --> 00:14:01.890
And first I'd like to point
out a new Carbon Event,

00:14:01.960 --> 00:14:04.200
KEventWindowGetClick modality.

00:14:04.430 --> 00:14:08.350
And this is an event probably most
of your applications won't use,

00:14:08.520 --> 00:14:13.460
but it's used when you need to customize
the behavior of a click -- yay,

00:14:13.460 --> 00:14:17.050
all right -- of a click in a
window behind a modal dialog.

00:14:17.380 --> 00:14:21.240
Normally the toolbox will just block
that click and emit a sys beep.

00:14:21.240 --> 00:14:22.960
But in some cases,
applications may need to

00:14:23.000 --> 00:14:24.580
actually customize that behavior.

00:14:24.580 --> 00:14:27.380
So you can now use this event to
actually intercept the click or let it

00:14:27.380 --> 00:14:30.500
be passed through to the clicked window.

00:14:30.500 --> 00:14:34.810
We also support a keyboard focus hotkey
for putting focus on a drawer window

00:14:34.820 --> 00:14:36.960
that's attached to the active window.

00:14:37.070 --> 00:14:39.940
And your application doesn't have
to do anything to support that.

00:14:39.940 --> 00:14:41.020
It's all automatic.

00:14:41.020 --> 00:14:42.050
It just happens.

00:14:42.280 --> 00:14:46.760
Finally, a change to menu command event
routing that I want to cover.

00:14:46.760 --> 00:14:50.550
In previous versions of the OS,
when you sent a command event,

00:14:50.620 --> 00:14:56.150
kEvent command process or kEvent
command update status to a submenu

00:14:56.440 --> 00:14:59.380
and the submenu didn't handle it,
the event would then go

00:14:59.380 --> 00:15:00.860
to the user focus target.

00:15:00.890 --> 00:15:04.460
In Tiger, we're changing that somewhat so
that instead of going directly

00:15:04.460 --> 00:15:07.070
to the user focus target,
the event proceeds up the

00:15:07.070 --> 00:15:10.200
parent menu chain until there
are no parent menus anymore.

00:15:10.320 --> 00:15:12.270
Then it goes to the user focus target.

00:15:12.280 --> 00:15:15.540
That could be particularly
useful if you have a menu with a

00:15:15.540 --> 00:15:17.770
number of hierarchical submenus.

00:15:17.780 --> 00:15:21.560
Maybe you have a font menu with a
bunch of submenus and you want to have

00:15:21.560 --> 00:15:24.860
the parent menu be able to control
some of the command updating and

00:15:24.860 --> 00:15:26.690
command processing for the submenus.

00:15:26.740 --> 00:15:29.700
This way you can install your
handlers just on the parent

00:15:29.760 --> 00:15:30.720
menu and not on every submenu.

00:15:30.720 --> 00:15:33.390
every single submenu as well.

00:15:33.610 --> 00:15:34.600
You still see?

00:15:34.600 --> 00:15:34.790
Yes, you can.

00:15:34.790 --> 00:15:36.210
Okay, good.

00:15:36.450 --> 00:15:38.040
HIViewManager.

00:15:38.040 --> 00:15:40.740
We have some new
coordinate conversion APIs,

00:15:40.760 --> 00:15:44.540
HIPointConvert, HIREctConvert,
and HISHapeConvert,

00:15:44.550 --> 00:15:48.520
which are used to take points, wrecks,
and shapes from one view

00:15:48.520 --> 00:15:50.710
system to another view system.

00:15:50.880 --> 00:15:52.930
But they can do more than that,
because we already had

00:15:52.930 --> 00:15:54.200
that capability before.

00:15:54.210 --> 00:15:58.700
They can also go from view coordinates
to global coordinates and vice versa.

00:15:58.710 --> 00:16:01.740
And even more significantly,
they support two different

00:16:01.780 --> 00:16:03.360
global coordinate systems.

00:16:03.390 --> 00:16:05.660
They support a pixel-based
coordinate system,

00:16:05.700 --> 00:16:09.260
but also a 72 DPI point-based
coordinate system.

00:16:09.390 --> 00:16:11.950
And especially as your
applications are modified to

00:16:11.950 --> 00:16:15.540
be more resolution independent,
you may find that the point-based

00:16:15.620 --> 00:16:18.140
coordinate system is useful,
because that is independent of the

00:16:18.140 --> 00:16:23.580
actual display hardware and just gives
you sort of a virtual coordinate space.

00:16:23.930 --> 00:16:28.640
Also, along with the support for HIShape,
we now have support for drawing

00:16:28.640 --> 00:16:31.940
and invalidating views outside
of a 16-bit coordinate space.

00:16:32.000 --> 00:16:35.290
We have additional support for CG images.

00:16:35.290 --> 00:16:39.130
It's been a very common request from
developers to be able to use CG image

00:16:39.130 --> 00:16:41.250
refs with the standard controls.

00:16:41.300 --> 00:16:44.020
So, as you can see,
we now have support for

00:16:44.140 --> 00:16:48.090
CG image refs in push buttons,
round buttons, bevel buttons,

00:16:48.090 --> 00:16:52.580
pop-up buttons, data browser headers,
and I think a few others as well.

00:16:52.600 --> 00:16:57.850
Another CG image change in
the HIV manager is a new API,

00:16:57.980 --> 00:17:00.950
HICreateTransformCGImage.

00:17:01.100 --> 00:17:06.550
Some developers have found when they're
writing custom controls that display

00:17:06.550 --> 00:17:10.100
images that they want to be able
to directly imitate the appearance

00:17:10.100 --> 00:17:14.930
that the toolbox will give when a
control is selected or disabled.

00:17:15.130 --> 00:17:18.500
So for example, on the left side we
have an original image.

00:17:18.500 --> 00:17:20.580
In the middle we have a disabled image.

00:17:20.590 --> 00:17:24.300
And on the right side we have that
image drawn in a selected state.

00:17:24.440 --> 00:17:27.520
And previously there wasn't
any good way to take a CG image

00:17:27.520 --> 00:17:31.100
and apply those transforms to
it to get the resulting ones.

00:17:31.160 --> 00:17:35.310
We now have an API to let you do that
so that you can write custom views that

00:17:35.310 --> 00:17:37.910
exactly match the toolbox appearance.

00:17:38.000 --> 00:18:56.000
[Transcript missing]

00:18:57.100 --> 00:18:58.700
The Data Browser.

00:18:58.700 --> 00:19:03.050
We've added some long requested
features ever since ITunes came out.

00:19:03.180 --> 00:19:05.970
People have wanted support
for alternating row colors

00:19:06.000 --> 00:19:07.230
in the Data Browser.

00:19:07.230 --> 00:19:09.860
And we now have support
for that built in.

00:19:10.000 --> 00:19:15.990
Another thing that we have now built
into the Data Browser is column dividers.

00:19:16.010 --> 00:19:20.000
And you can see it's column divider is
just a vertical line between columns.

00:19:20.000 --> 00:19:22.440
Both of those are accessed
via a new set of APIs,

00:19:22.440 --> 00:19:24.990
Data Browser, Get, and Change attributes.

00:19:25.000 --> 00:19:30.000
So these are just attribute bits
like many other Toolbox APIs use.

00:19:30.000 --> 00:19:35.270
We have a slight change to the
appearance of the popup button

00:19:35.270 --> 00:19:38.000
cell in a Data Browser cell.

00:19:38.000 --> 00:19:41.190
The old appearance drew the
actual popup button control,

00:19:41.190 --> 00:19:44.660
which was kind of bulky and didn't
really fit into the appearance

00:19:44.660 --> 00:19:46.000
of a ListView cell very well.

00:19:46.000 --> 00:19:49.090
So we now have this new
buttonless popup menu appearance,

00:19:49.090 --> 00:19:50.000
which is un-matched.

00:19:50.000 --> 00:19:54.700
And it's much sleeker and doesn't
really take up as much space and

00:19:54.700 --> 00:20:00.000
just generally fits into the general
table appearance much better.

00:20:00.000 --> 00:20:03.890
And finally we have some new APIs,
Data Browser, Get, and Set Metric,

00:20:04.000 --> 00:20:08.970
which allow you to change the amount
of white space and separation around

00:20:08.970 --> 00:20:11.490
text and icons in a ListView cell.

00:20:12.990 --> 00:20:17.040
Interface Builder has a bunch of new
features I want to run through here.

00:20:17.170 --> 00:20:20.570
Support for the Placker, Window Header,
and Segmented Views.

00:20:20.590 --> 00:20:26.500
You can see those are highlighted in
the Interface Builder screenshots here.

00:20:26.500 --> 00:20:28.810
We have support for
Control Text Foreground

00:20:28.930 --> 00:20:31.600
Colors and Justification,
so you can now set those directly

00:20:31.620 --> 00:20:32.980
inside Interface Builder.

00:20:32.980 --> 00:20:37.060
Also some new Window Attributes,
specifically the resolution

00:20:37.060 --> 00:20:40.260
independent Window Attributes,
the Framework Scaled and

00:20:40.260 --> 00:20:43.500
Application and scaled attributes,
but also in window menu

00:20:43.500 --> 00:20:45.600
and does not cycle.

00:20:46.100 --> 00:20:48.920
Window resizing limits,
the minimum and maximum sizes

00:20:49.030 --> 00:20:52.120
for a window can now be set
directly in Interface Builder.

00:20:52.120 --> 00:20:55.440
And one last feature I want to highlight,
which is pretty cool,

00:20:55.490 --> 00:20:58.910
which is automatic window
positioning based on display size.

00:20:58.910 --> 00:21:02.210
So the problem this is solving is
that you're designing your user

00:21:02.370 --> 00:21:06.510
interface on your 12-inch PowerBook,
and you have your window positioned

00:21:06.750 --> 00:21:09.590
halfway across the screen and
two-thirds of the way down,

00:21:09.590 --> 00:21:12.350
and you run your app on
your 12-inch PowerBook,

00:21:12.350 --> 00:21:13.490
and it works great.

00:21:13.490 --> 00:21:15.960
That's where the window comes up.

00:21:16.820 --> 00:21:19.680
But then you transfer your app
over to your desktop system with

00:21:19.680 --> 00:21:23.460
your 30-inch cinema display,
should you be so lucky as to have one.

00:21:23.630 --> 00:21:26.640
And you run your application and
the window is way up there in the

00:21:26.770 --> 00:21:28.200
top left corner of the screen.

00:21:28.370 --> 00:21:31.670
And that's because IB is just saving
the absolute coordinates of the

00:21:31.670 --> 00:21:34.810
window bounds and they don't change.

00:21:35.000 --> 00:21:38.130
So using this automatic window
positioning in the window inspector,

00:21:38.130 --> 00:21:42.080
there's a new little section there where
you set springs and rods on a window.

00:21:42.080 --> 00:21:46.000
And that can let you specify that
a window should be proportionally

00:21:46.000 --> 00:21:50.320
located on the display where it's
loaded relative to its location on

00:21:50.450 --> 00:21:52.730
the display where it was designed.

00:21:52.760 --> 00:21:55.900
So if you put the window halfway
across and two-thirds of the

00:21:55.900 --> 00:21:59.200
way down when you design it,
and you open it on a much larger

00:21:59.230 --> 00:22:02.400
display or on a much smaller display,
it'll still be at that

00:22:02.410 --> 00:22:03.900
same proportional location.

00:22:12.470 --> 00:22:17.160
The Menu Manager doesn't have any
new Carbon events or APIs this year,

00:22:17.260 --> 00:22:20.740
but it does have some user interface
changes that I'd like to highlight

00:22:21.010 --> 00:22:23.190
so you're not surprised by them.

00:22:23.200 --> 00:22:25.400
The first one is Menu Bar Type Selection.

00:22:25.400 --> 00:22:28.600
We now support being able
to type select a menu title.

00:22:28.610 --> 00:22:31.490
Previously we just supported
menu item type selection.

00:22:31.630 --> 00:22:35.360
So when you first put focus on the
menu bar using the keyboard hotkey,

00:22:35.410 --> 00:22:38.880
only the Apple menu title gets
highlighted and the entire

00:22:38.880 --> 00:22:40.580
menu does not get opened.

00:22:40.680 --> 00:22:45.240
Then if you type something, type ARR,
you'll end up selecting

00:22:45.240 --> 00:22:46.470
the Arrange menu title.

00:22:46.640 --> 00:22:50.200
At this point you can press Return or
Enter or Spacebar and the entire menu

00:22:50.200 --> 00:22:52.230
will open and you can type select.

00:22:52.270 --> 00:22:56.080
Of course this particular thing
isn't quite a Carbon specific thing

00:22:56.090 --> 00:22:59.810
because since Cocoa also uses the
Carbon Menu Manager you get this

00:22:59.810 --> 00:23:02.280
effect in Cocoa applications as well.

00:23:02.350 --> 00:23:06.030
And the other change is
Pop-up Menu Selection.

00:23:06.200 --> 00:23:10.840
This is especially useful if you are
using the keyboard to access your

00:23:10.840 --> 00:23:14.100
menus or to open pop-up menu controls.

00:23:14.100 --> 00:23:17.450
So if there's a pop-up button
control and the menu has a

00:23:17.500 --> 00:23:21.810
particular item that is checkmarked,
when that menu comes up,

00:23:21.860 --> 00:23:25.300
that particular checkmarked item is going
to be pre-highlighted now so that you

00:23:25.300 --> 00:23:28.690
can use the arrow keys to move directly
to the next item or the previous item

00:23:28.720 --> 00:23:33.610
very easily without having to start
from the top or the bottom of the menu.

00:23:34.090 --> 00:23:37.150
MLTE, the Multilingual
Text Editor or TextEntion,

00:23:37.150 --> 00:23:38.700
also has some new APIs.

00:23:38.740 --> 00:23:41.000
There's going to be a whole
session about this tomorrow,

00:23:41.000 --> 00:23:43.640
I think, so you can go and find
out more about this,

00:23:43.790 --> 00:23:45.220
but I'll just give you
some highlights here.

00:23:45.220 --> 00:23:47.800
MLTE now supports the
Cocoa Spellchecking Panel,

00:23:47.800 --> 00:23:50.860
so you can very easily build
spellchecking support into your

00:23:50.860 --> 00:23:52.500
application that uses MLTE.

00:23:52.500 --> 00:23:56.400
It also supports the
Cocoa Font and Typography Panels.

00:23:56.400 --> 00:24:00.950
It has some new APIs to let you do more
sophisticated scrolling behavior when

00:24:01.010 --> 00:24:03.370
text is inserted into an MLTE field.

00:24:04.980 --> 00:24:08.560
It has some new APIs to do more
sophisticated undo group support to

00:24:08.560 --> 00:24:12.400
control how different actions are
grouped together and then undone.

00:24:12.440 --> 00:24:16.170
And finally,
some new features to allow you to

00:24:16.200 --> 00:24:18.910
read from and write to a CFURLRef.

00:24:19.600 --> 00:24:23.760
Universal access is sort of
a general term for a bunch of

00:24:23.770 --> 00:24:27.850
different features in Mac OS X that
support the use of the operating

00:24:27.850 --> 00:24:30.230
system by users with disabilities.

00:24:30.410 --> 00:24:34.730
And one of those features is the
zooming feature that is meant

00:24:34.760 --> 00:24:39.960
for use by users with visual
disabilities with low sight abilities.

00:24:40.030 --> 00:24:44.290
And it magnifies the entire
screen by a user-specified amount.

00:24:44.380 --> 00:24:47.870
Now the problem, of course,
is that if you magnify the entire screen,

00:24:47.870 --> 00:24:50.460
well, some part of the screen is going
to get forced off of the edges

00:24:50.500 --> 00:24:53.230
of your physical display space.

00:24:53.350 --> 00:24:55.820
So the question is,
how do you actually determine which

00:24:55.930 --> 00:24:59.170
part of the screen should be displayed
on your physical hardware device?

00:24:59.530 --> 00:25:03.520
For example, let's see,
here we have a screenshot from

00:25:03.520 --> 00:25:05.960
a magnified version of TextEdit.

00:25:06.010 --> 00:25:09.680
And you can see the insertion
point is kind of right at

00:25:09.680 --> 00:25:11.990
the right edge of the screen.

00:25:12.110 --> 00:25:14.300
So if the user were to
press the right button,

00:25:14.300 --> 00:25:16.910
or the right arrow key a few times,
that insertion point would move

00:25:17.040 --> 00:25:19.970
off the right side of the screen,
and you'd lose it.

00:25:20.010 --> 00:25:22.740
It would be off the
physical display hardware.

00:25:22.770 --> 00:25:27.210
So to prevent that problem,
the zooming feature in

00:25:27.210 --> 00:25:31.720
Universal Access scrolls the entire
zoomed area of the screen off to the

00:25:31.950 --> 00:25:36.260
left to keep that insertion point
visible on the physical display device.

00:25:36.260 --> 00:25:38.660
Now, how does it know where
the insertion point is?

00:25:38.660 --> 00:25:40.800
Well, someone has to tell it.

00:25:40.800 --> 00:25:44.300
In the case of the
built-in operating system,

00:25:44.300 --> 00:25:47.000
the editing engines,
we already do that for you.

00:25:47.030 --> 00:25:50.300
So we're already telling the zoom
feature where the insertion point is.

00:25:50.350 --> 00:25:54.540
But if your application offers its own
keyboard accessible user interface,

00:25:54.540 --> 00:25:58.480
then you need to explicitly tell
the zoom feature yourself where the

00:25:58.520 --> 00:26:02.490
current focus of the user's attention
is so that the zoom feature can stay

00:26:02.670 --> 00:26:05.090
focused on that particular point.

00:26:05.230 --> 00:26:07.360
So we have some new APIs here.

00:26:07.390 --> 00:26:11.620
UA Zoom enabled tells you whether the
Zoom feature is currently enabled.

00:26:11.760 --> 00:26:16.060
UA Zoom change focus is what you'll use
to give the global coordinates where the

00:26:16.060 --> 00:26:18.400
user's locus of attention currently is.

00:26:18.400 --> 00:26:23.360
That's an assertion point or some other
way of indicating where the focus is.

00:26:23.360 --> 00:26:25.300
So typical uses,
if you're writing your own

00:26:25.300 --> 00:26:28.760
word processor or spreadsheet,
these often provide keyboard access

00:26:28.760 --> 00:26:31.310
to objects inside the document,
some kind of other

00:26:31.310 --> 00:26:35.050
graphical object editor,
or really the whole idea is anything

00:26:35.050 --> 00:26:39.170
where the user isn't using the mouse
to indicate where their attention

00:26:39.230 --> 00:26:42.360
is because the Zoom feature already
knows how to track the mouse,

00:26:42.360 --> 00:26:45.390
but is using some other modality
to indicate their attention,

00:26:45.390 --> 00:26:48.080
which might be keyboard,
but it could even be speech

00:26:48.160 --> 00:26:49.770
or something else like that.

00:26:49.820 --> 00:26:51.920
In those cases,
you'd want to use these APIs to tell

00:26:51.920 --> 00:26:56.930
the Zoom feature where the area that it
should be paying attention to should be.

00:26:57.500 --> 00:26:58.850
Okay, Carbon-COCO integration.

00:26:58.900 --> 00:27:03.080
We've made a bunch of changes
here to solve a lot of the common

00:27:03.080 --> 00:27:05.960
problems that developers run into
when using Cocoa technologies

00:27:06.030 --> 00:27:07.400
inside their Carbon application.

00:27:07.400 --> 00:27:12.400
One of the biggest ones is the use of
unified Core Graphics window levels.

00:27:12.400 --> 00:27:16.370
Carbon and Cocoa used to use
different Core Graphics window levels

00:27:16.390 --> 00:27:17.400
for floating and modal windows.

00:27:17.400 --> 00:27:21.400
We now use the same window levels for
those particular types of windows.

00:27:21.400 --> 00:27:23.480
So that solves a lot of
problems where a Carbon window,

00:27:23.490 --> 00:27:26.160
Carbon floating window,
couldn't come in front of a

00:27:26.160 --> 00:27:29.220
Cocoa floating window and modal dialogs
got in front of floating windows

00:27:29.220 --> 00:27:31.400
or vice versa and things like that.

00:27:35.980 --> 00:27:39.820
Those of you who have run into those
problems probably appreciate this fix.

00:27:39.820 --> 00:27:47.700
KHICommandSelectWindow is a command
ID for a command event which is sent when

00:27:47.700 --> 00:27:52.900
you click on a window if that window is
using the standard window event handler.

00:27:52.900 --> 00:27:57.190
We are now sending that command event
for all clicks on windows that use

00:27:57.190 --> 00:28:01.980
the standard window event handler
even if the window is already active.

00:28:01.980 --> 00:28:04.670
That makes sure that if you have
a Carbon document window and a

00:28:04.670 --> 00:28:08.120
Cocoa document window in the same
application that the Carbon window

00:28:08.130 --> 00:28:11.550
is always going to order in front of
the Cocoa window when it's clicked.

00:28:13.410 --> 00:28:15.900
We've also made some changes
that are focus-related.

00:28:15.980 --> 00:28:18.680
We had seen some problems
where if you had,

00:28:18.680 --> 00:28:21.240
say,
the focus on a Carbon document window and

00:28:21.240 --> 00:28:24.540
you clicked into a COCA floating window,
sometimes the focus

00:28:24.540 --> 00:28:26.850
wouldn't move properly,
or maybe it wouldn't move

00:28:26.850 --> 00:28:28.600
properly back the other direction.

00:28:28.600 --> 00:28:31.770
So you could wind up with two different
blinking insertion points or two

00:28:31.870 --> 00:28:35.700
different controls in different windows
that both drew their focus rings.

00:28:35.700 --> 00:28:39.940
Properly from one window to another and
released by the window that it's leaving.

00:28:39.940 --> 00:28:44.290
And also some changes to the standard
controls in Carbon so that they only

00:28:44.290 --> 00:28:49.140
draw focus rings if their owning window
is the current user focus window.

00:28:49.140 --> 00:28:51.740
And finally,
auto-release pools are an issue

00:28:51.740 --> 00:28:54.920
that a lot of developers run into
when trying to use Cocoa technology

00:28:55.010 --> 00:28:56.740
in their applications.

00:28:56.740 --> 00:29:01.520
Cocoa requires the establishment of an
auto-release pool before you call into

00:29:01.520 --> 00:29:05.490
Cocoa code because it's used for memory
management for properly keeping track of

00:29:05.570 --> 00:29:08.060
objects that need to be released later.

00:29:08.060 --> 00:29:11.900
And it was awkward and sometimes really
very hard to establish those pools,

00:29:11.900 --> 00:29:14.240
if you were using, say,
run application event loop,

00:29:14.240 --> 00:29:16.690
because you didn't have any
control over that core loop,

00:29:16.790 --> 00:29:19.690
the core event loop,
the toolbox ran that loop for you.

00:29:19.750 --> 00:29:23.490
So we now establish auto-release
pools for you in several cases,

00:29:23.510 --> 00:29:27.160
including in run application event loop,
in run app modal loop for window,

00:29:27.160 --> 00:29:29.740
modal dialog,
and when drawing the content

00:29:30.040 --> 00:29:31.720
of a compositing window.

00:29:31.740 --> 00:29:37.580
In all those cases,
you can rely on the pool being present.

00:29:38.530 --> 00:29:40.940
The Cocoa team as well
has made some changes.

00:29:40.940 --> 00:29:43.760
I'd just like to highlight
some of them here.

00:29:43.760 --> 00:29:46.920
We've improved the behavior
of floating windows.

00:29:46.920 --> 00:29:50.170
Previously, if you had, let's say,
a font picker window,

00:29:50.280 --> 00:29:52.710
a Cocoa font picker window
in a Carbon application,

00:29:52.710 --> 00:29:56.580
that font picker window was
essentially treated as a document

00:29:56.930 --> 00:30:00.200
window to the extent that the
Carbon APIs dealt with it,

00:30:00.200 --> 00:30:02.550
which meant that it would
steal activation away from

00:30:02.550 --> 00:30:03.840
your document windows.

00:30:03.840 --> 00:30:06.990
It could become active when
your application was active.

00:30:07.140 --> 00:30:10.030
So that's changed now,
and those Cocoa floating windows

00:30:10.030 --> 00:30:13.160
are now really treated as
Carbon floating windows as well.

00:30:13.290 --> 00:30:16.550
So they don't steal activation,
they don't appear in the Windows menu,

00:30:16.640 --> 00:30:19.130
and they properly hide when the
application is hidden as well.

00:30:20.900 --> 00:30:25.210
The Cocoa team has also made some
changes to improve focus behavior so

00:30:25.210 --> 00:30:30.710
that the Carbon user focus and the
Cocoa key window status properly track

00:30:30.710 --> 00:30:32.420
each other as they move back and forth.

00:30:32.520 --> 00:30:35.630
So when the Carbon user focus changes,
the key window status

00:30:35.630 --> 00:30:37.050
changes and vice versa.

00:30:37.060 --> 00:30:39.820
And finally,
if you've tried to use KEvent

00:30:39.820 --> 00:30:43.520
class application events
in your Cocoa application,

00:30:43.520 --> 00:30:47.430
you may have noticed that your
handlers simply weren't called.

00:30:47.860 --> 00:30:51.160
And that's now been fixed as well
so that you can now use KEvent class

00:30:51.260 --> 00:30:55.170
application events inside a Cocoa app
and your handlers will be called.

00:30:57.730 --> 00:31:00.600
Okay, one little note here.

00:31:00.640 --> 00:31:05.040
Due to changes for the auto-release
pools and also for the HIArchive API that

00:31:05.040 --> 00:31:09.230
we're going to be talking about later,
the HIToolbox framework now always

00:31:09.230 --> 00:31:13.150
loads the foundation framework
and the Objective-C runtime.

00:31:13.140 --> 00:31:15.460
That's a change from previous
versions of the operating system

00:31:15.460 --> 00:31:19.670
where those frameworks and runtimes
weren't loaded unless you explicitly

00:31:19.750 --> 00:31:21.400
called code that used them.

00:31:21.410 --> 00:31:24.630
Well, we are explicitly calling code that
uses them now because the auto-release

00:31:24.830 --> 00:31:29.450
pool API comes from Foundation,
and the HIarchive API uses the

00:31:29.450 --> 00:31:32.760
NSKeedArchiver API from Foundation.

00:31:32.760 --> 00:31:35.510
So those things are going to be
loaded into your applications,

00:31:35.510 --> 00:31:38.060
but you shouldn't see any
runtime changes from that.

00:31:38.270 --> 00:31:42.460
And I'd also like to point out one
little difference in the implementation

00:31:42.460 --> 00:31:45.360
is that HIObjects are actually,
in a sense,

00:31:45.450 --> 00:31:50.470
derived from NSObjects now and can
be treated as an NSObject at runtime.

00:31:50.580 --> 00:31:52.800
So although we don't -- we're
not currently saying that

00:31:52.800 --> 00:31:56.710
we officially support this,
it is possible to say, you know,

00:31:56.740 --> 00:32:02.050
"My HIObject retain" or "My HIObject
release" using the Objective-C syntax.

00:32:03.340 --> 00:32:06.590
Okay, that's it for the
beginning of my session,

00:32:06.590 --> 00:32:08.810
and I'd like to bring
up Bryan Prusha now,

00:32:08.810 --> 00:32:13.310
and he's going to talk about some
navigation services and HIarchive.

00:32:17.760 --> 00:32:20.020
All right, thank you, Eric.

00:32:20.060 --> 00:32:22.530
I'd like to begin talking about
some of the changes that we've made

00:32:22.630 --> 00:32:24.730
for navigation services in Tiger.

00:32:24.870 --> 00:32:28.330
The first and most obvious
change is support for Spotlight.

00:32:28.490 --> 00:32:32.350
You can see in the upper
right-hand portion of the dialog

00:32:32.350 --> 00:32:34.530
that we have a search field.

00:32:35.310 --> 00:32:38.640
and also a finder style scope
bar which can be used for

00:32:38.640 --> 00:32:41.530
narrowing your spotlight search.

00:32:41.800 --> 00:32:47.070
and support in the sidebar
for finder save searches.

00:32:48.090 --> 00:32:51.340
And of course, as you support the
Navigation Services API,

00:32:51.350 --> 00:32:52.640
you'll get all of that for free.

00:32:52.640 --> 00:32:55.300
No code change is necessary.

00:32:55.310 --> 00:32:59.240
Now, the next thing that we
did is added a new API,

00:32:59.250 --> 00:33:02.700
specifically for filtering
in Navigation Services.

00:33:02.760 --> 00:33:05.120
So traditionally,
we've only offered the ability to

00:33:05.120 --> 00:33:08.350
filter based on an array of OS types.

00:33:08.800 --> 00:33:10.660
And this worked for a long time, but,
you know,

00:33:10.660 --> 00:33:15.560
along came Mac OS X and extensions,
and that paradigm began to break down.

00:33:15.660 --> 00:33:19.180
So we wanted to go one step further
than just adding extension support.

00:33:19.300 --> 00:33:23.360
So now with the
NavSetFilterTypeIdentifiers API,

00:33:23.430 --> 00:33:26.720
we've added support for you to
pass an array of uniform type

00:33:26.800 --> 00:33:29.360
identifiers to Navigation Services.

00:33:29.480 --> 00:33:31.480
So this has multiple features.

00:33:31.730 --> 00:33:36.000
It subsumes the behavior of both OS type
filtering and extension filtering,

00:33:36.040 --> 00:33:41.050
as well as offering the advanced uniform
type identifier conformance hierarchy.

00:33:41.390 --> 00:33:45.500
And in addition,
UTIs all have a display name.

00:33:45.610 --> 00:33:51.530
And so we can just provide that
for users in the enabled pop-up.

00:33:52.140 --> 00:33:55.600
In this case, you can see that I've
passed this nav dialog,

00:33:55.780 --> 00:33:58.000
public.image and public.text.

00:33:58.090 --> 00:34:02.640
These are meta types in uniform
type identifier hierarchy.

00:34:02.700 --> 00:34:07.930
And so they refer to all types
of images and all types of text.

00:34:08.240 --> 00:34:11.920
So as you can see in the dialogue,
because I'm filtering by images,

00:34:11.920 --> 00:34:14.740
you can see GIFs, pings,
all sorts of image formats

00:34:14.870 --> 00:34:17.860
being filtered at the same time,
very simply.

00:34:17.880 --> 00:34:20.820
Now let's say I want to
sort by text instead.

00:34:20.830 --> 00:34:22.390
Oh, but wait a second.

00:34:22.430 --> 00:34:27.920
There's been this longstanding bug
where when you change the enable popup,

00:34:28.000 --> 00:34:30.940
some of the icons will update,
but the text doesn't.

00:34:31.060 --> 00:34:32.540
And this has been confusing for users.

00:34:32.730 --> 00:34:34.690
And it's kind of subtle.

00:34:35.100 --> 00:34:38.670
and this subtlety is really
part of the main problem.

00:34:38.670 --> 00:34:41.880
So we've gone ahead and made sure that
since we're working with filtering,

00:34:41.950 --> 00:34:46.240
we wanted to make sure that the nav
dialog updates properly in all cases.

00:34:46.380 --> 00:34:50.100
So your users will no longer
have any confusion in this case.

00:34:51.830 --> 00:34:55.030
There were 33 duplicates on this bug,
so there's at least 30

00:34:55.030 --> 00:34:56.440
of you that are happy.

00:34:56.440 --> 00:34:57.440
All right.

00:34:57.440 --> 00:34:59.380
That's enough for navigation
services right now.

00:34:59.500 --> 00:35:01.780
I'd like to move on to HIArchive.

00:35:01.910 --> 00:35:07.060
As has been mentioned a couple times now,
HIArchive is a new API for Tiger,

00:35:07.140 --> 00:35:09.910
and it's wrapped around
NSKeyedArchiver that Ali talked

00:35:10.000 --> 00:35:14.940
about in the previous talk,
if you were here for that.

00:35:15.070 --> 00:35:18.440
So it's a mechanism for
taking live objects in memory,

00:35:18.530 --> 00:35:23.100
whether HI objects, so HIViews, windows,
menus,

00:35:23.170 --> 00:35:28.100
or core foundation property list types,
like collections, like arrays,

00:35:28.150 --> 00:35:33.740
or CFString, CFNumber, things like this,
flattening out into a CFData,

00:35:33.790 --> 00:35:38.710
an architecture-independent
binary format.

00:35:38.950 --> 00:35:41.820
Now this binary format is very small,
compact, does some cool things

00:35:41.820 --> 00:35:44.710
like string unique-ing,
and offers a table of contents

00:35:44.800 --> 00:35:47.460
for quick access to your objects.

00:35:47.640 --> 00:35:50.340
Now later on,
when you want to pull information

00:35:50.390 --> 00:35:51.760
back out of the archive,

00:35:53.790 --> 00:35:57.120
Your objects will all be reinstantiated
with the same state they had when they

00:35:57.120 --> 00:35:59.520
were written out into the archive.

00:36:00.380 --> 00:36:03.220
So for a lot of people,
the word binary will

00:36:03.310 --> 00:36:05.110
throw up some alarms.

00:36:05.230 --> 00:36:08.490
And so I wanted to make sure that
you knew that you could use the

00:36:08.650 --> 00:36:14.770
PLUtil property list utility to
convert your binary archives into text

00:36:14.770 --> 00:36:17.540
XML if you want to use that format.

00:36:17.580 --> 00:36:22.450
But I highly recommend maintaining
the binary format for deployment,

00:36:22.450 --> 00:36:24.800
just for performance reasons.

00:36:25.010 --> 00:36:29.400
Now, Interface Builder does not support
archive-based nibs at this time.

00:36:29.400 --> 00:36:31.910
But it will in future releases.

00:36:32.710 --> 00:36:36.610
To that end, we've added support in
the existing Nib APIs,

00:36:36.610 --> 00:36:41.680
iBCarbonRuntime,
to look into the Nib and see if

00:36:41.680 --> 00:36:45.990
there is an archive format sitting
next to the traditional XML format

00:36:46.110 --> 00:36:48.490
for interface builders' information.

00:36:48.500 --> 00:36:50.870
If that exists, it will prefer that.

00:36:50.940 --> 00:36:57.370
So in a future version of Mac OS X where
you can write out archive-based Nibs,

00:36:57.910 --> 00:37:01.460
those Nibs will be backwards
compatible to Tiger.

00:37:03.250 --> 00:37:07.460
Let's talk a little bit about how
you as a client will use HIarchive.

00:37:07.480 --> 00:37:12.250
The two main tasks you want to do are
encode your data and decode your data,

00:37:12.400 --> 00:37:14.340
pull all your objects back out.

00:37:14.490 --> 00:37:18.030
So in order for the encoding step,
you'll call HIarchive

00:37:18.030 --> 00:37:19.760
create for encoding.

00:37:19.860 --> 00:37:22.640
This will give you an HIarchive
ref that is used explicitly

00:37:22.640 --> 00:37:24.340
in the encoding set of APIs.

00:37:24.460 --> 00:37:26.960
So don't try and pass it
into the decoding APIs.

00:37:27.110 --> 00:37:28.950
You'll get an error.

00:37:29.880 --> 00:37:33.970
Now with this HIarchiveRef,
you'll pass each of your objects in

00:37:33.970 --> 00:37:37.000
turn to HIarchiveEncode's CF type.

00:37:37.140 --> 00:37:40.430
In addition,
you'll pass a string which uses a key,

00:37:40.830 --> 00:37:44.580
like the key value pairing
used in CFDictionary's.

00:37:46.270 --> 00:37:50.200
This key is important because it will be
used to pull information back out later.

00:37:50.200 --> 00:37:52.810
So when you're done writing all
your information into the archive,

00:37:52.810 --> 00:37:55.700
go ahead and call HIArchive
Copy Encoded Data.

00:37:55.880 --> 00:37:57.940
This will take all the information
that you've written in,

00:37:58.050 --> 00:38:00.320
squish it down in that
nice little binary format,

00:38:00.320 --> 00:38:02.200
and pass it back to you as a CFData.

00:38:02.200 --> 00:38:05.080
Now when you have the CFData,
you can write it out to disk,

00:38:05.270 --> 00:38:07.200
put it on a pasteboard,
send it to another application,

00:38:07.200 --> 00:38:08.170
do whatever you want.

00:38:08.450 --> 00:38:10.070
It's just data.

00:38:10.730 --> 00:38:13.220
Now later on, your application will want
to pull this back out.

00:38:13.370 --> 00:38:17.460
If you've written a bunch of views
in Windows as your user interface,

00:38:17.460 --> 00:38:20.130
you'll want to load
this up at launch time,

00:38:20.180 --> 00:38:22.140
something along those lines.

00:38:22.230 --> 00:38:27.570
So you call HIarchive create for
decoding with the CFData that

00:38:27.570 --> 00:38:30.670
contains your binary HIarchive.

00:38:30.830 --> 00:38:35.400
This will pass back another
HIarchive ref that is used explicitly

00:38:35.400 --> 00:38:37.540
for the decoding set of APIs.

00:38:37.600 --> 00:38:41.370
Then for each one of your objects,
call HIarchive copy decoded CF type

00:38:41.640 --> 00:38:46.030
using the CFString keys that you
wrote into the archive to begin with.

00:38:46.290 --> 00:38:49.380
And then each of your objects
one by one will be reinstantiated

00:38:49.380 --> 00:38:51.140
with the state it had initially.

00:38:51.850 --> 00:38:57.500
Now the HIarchiveRef is a CF type,
so make sure to use call

00:38:57.500 --> 00:39:00.140
CF release on it when you're done.

00:39:01.760 --> 00:39:05.230
I've mentioned that you can use
HIarchive with core foundation property

00:39:05.340 --> 00:39:07.040
list types as well as HIobjects.

00:39:07.040 --> 00:39:13.460
So let's talk about how you can support
the HIarchive protocol in your HIobjects.

00:39:13.570 --> 00:39:17.130
There are two events,
kevent-hiobject-encode and

00:39:17.130 --> 00:39:19.640
kevent-hiobject-initialize.

00:39:19.700 --> 00:39:23.960
Each of these will hand you a
kevent-param-hia-archive parameter.

00:39:24.090 --> 00:39:29.720
So this is the HIarchive ref that you
will use to write your information into

00:39:30.160 --> 00:39:33.010
the archive and pull back out later.

00:39:33.400 --> 00:39:36.830
So when the client requests
for you to encode your data,

00:39:36.830 --> 00:39:40.480
you'll identify your
object's persistent state,

00:39:40.750 --> 00:39:45.900
And write that into the archive
using the APIs that I just went over.

00:39:45.900 --> 00:39:48.870
And then make sure to call your next
event handler so your superclass

00:39:48.900 --> 00:39:50.760
gets a chance to encode its data.

00:39:50.760 --> 00:39:53.660
For instance, if you're in HIView,
you want to make sure that the base

00:39:53.700 --> 00:39:57.860
HIView class can write out things
like your size and position and title,

00:39:57.860 --> 00:40:00.470
all those kind of common features.

00:40:02.000 --> 00:40:06.510
Then later when the client requests that
you pull yourself out of the archive,

00:40:06.520 --> 00:40:07.520
you'll get the initialize event.

00:40:07.620 --> 00:40:11.300
Now this is the same initialize
event that you are sent normally now

00:40:11.300 --> 00:40:13.930
when somebody calls HIObjectCreate.

00:40:14.130 --> 00:40:17.600
The difference being that when
you are given the HIarchive ref,

00:40:17.660 --> 00:40:25.040
you want to instantiate your object
from the archive rather than by default.

00:40:25.420 --> 00:40:30.000
Now, the great thing with writing
information out by key is that,

00:40:30.100 --> 00:40:31.830
first of all, not all of the information
has to be there.

00:40:31.900 --> 00:40:34.540
If a key doesn't exist,
assume that you're using

00:40:34.950 --> 00:40:36.100
the default format.

00:40:36.140 --> 00:40:39.910
So you can just use a default
initializer in that case.

00:40:40.740 --> 00:40:46.440
Now, if you have a newer version of your
object that writes some information out,

00:40:46.440 --> 00:40:48.690
you might write out three keys.

00:40:48.820 --> 00:40:51.880
But if you move that back to an older
version of your application that

00:40:51.880 --> 00:40:54.840
only understands two of those keys,
it can just ignore the third key.

00:40:54.940 --> 00:40:58.190
And so there's a great amount of
backwards and forwards compatibility

00:40:58.260 --> 00:40:59.660
with the archive format.

00:40:59.770 --> 00:41:01.410
And again,
make sure to call your next event

00:41:01.410 --> 00:41:06.190
handler so that it can have a chance
to initialize itself from the archive.

00:41:06.610 --> 00:41:10.770
Once you handle the HIarchive protocol,
make sure to call hiobject

00:41:10.930 --> 00:41:12.900
setArchivingIgnored to false.

00:41:12.900 --> 00:41:16.700
It sounds a little backwards,
but it's useful.

00:41:16.740 --> 00:41:20.400
This tells the toolbox that you
handled the archiving protocol,

00:41:20.460 --> 00:41:23.400
and it knows that it can
send these messages to you.

00:41:23.420 --> 00:41:27.300
The reason why it's settingIgnored
to begin with is because

00:41:27.300 --> 00:41:29.660
clients can call this also.

00:41:29.750 --> 00:41:33.180
Typically, you will call this within
your initialization event,

00:41:33.350 --> 00:41:39.990
but clients at any time can call
this API on subviews in a window to

00:41:39.990 --> 00:41:46.760
guarantee that those pieces don't get
archived out and can be pulled back

00:41:46.790 --> 00:41:49.700
and can be initialized later manually.

00:41:49.790 --> 00:41:52.090
Now, this is important because you
want to keep your HIarchive small.

00:41:52.100 --> 00:41:54.300
The smaller they are,
the faster they load from disk.

00:41:54.390 --> 00:41:55.190
So keep that in mind.

00:41:55.200 --> 00:41:59.680
Don't write out too much data,
only as much data as you really need.

00:42:00.260 --> 00:42:04.380
Now, I'll go more in depth on
this in a session tomorrow,

00:42:04.450 --> 00:42:07.020
session 116, building a custom HIV.

00:42:07.210 --> 00:42:09.600
In that case, we'll be dealing with
an HIV specifically,

00:42:09.600 --> 00:42:11.360
not HIObjects in general.

00:42:11.360 --> 00:42:13.360
And there will be plenty
of sample code available.

00:42:13.380 --> 00:42:15.380
It's a hands-on session.

00:42:15.520 --> 00:42:17.240
So the last thing
I just want to touch on,

00:42:17.240 --> 00:42:21.400
if your application-- or in your
application you want to edit HIArchives,

00:42:21.460 --> 00:42:25.660
you might take advantage of the
HIObject set custom archive data API.

00:42:25.850 --> 00:42:31.140
This allows you to add some custom
bits to an object that will get written

00:42:31.140 --> 00:42:32.590
out into the archive automatically.

00:42:32.750 --> 00:42:36.880
So an interface builder style
application might use this to write

00:42:36.880 --> 00:42:38.980
out initialization parameters.

00:42:39.990 --> 00:42:46.260
And so you can check out hiobject.h
and hiarchive.h for more documentation

00:42:46.300 --> 00:42:49.370
on these specific features,
as well as documentation

00:42:49.370 --> 00:42:50.770
on the ADC website.

00:42:51.790 --> 00:42:55.840
Now with this,
I'd like to move to a demo of HIBuilder.

00:42:55.840 --> 00:42:59.560
HIBuilder is some sample code that
we've been working on that takes

00:42:59.610 --> 00:43:02.490
advantage of the HIarchive APIs.

00:43:02.580 --> 00:43:05.080
Now, to begin with,
I'd actually like to show

00:43:05.130 --> 00:43:06.900
you interface builder here.

00:43:06.960 --> 00:43:10.190
I'm going to create a new nib.

00:43:10.280 --> 00:43:14.730
We have a window in there,
and I will add a menu.

00:43:15.930 --> 00:43:19.780
I'm just going to make sure we don't
have the default information here.

00:43:19.800 --> 00:43:21.940
Let's do something mildly interesting.

00:43:22.000 --> 00:43:23.220
Let's add some buttons and so on.

00:43:23.260 --> 00:43:27.730
All right.

00:43:28.060 --> 00:43:30.290
I'm saving this to the desktop.

00:43:35.480 --> 00:43:38.360
And I'm quitting Interface Builder.

00:43:38.390 --> 00:43:41.090
Now I'm launching HIBuilder.

00:43:43.200 --> 00:43:48.730
And HIBuilder has a feature
where you can open NIBs.

00:43:49.920 --> 00:43:54.140
What it does is it does some very
simple parsing of the XML data,

00:43:54.170 --> 00:43:58.360
identifies all the top level objects,
and uses the existing IB Carbon runtime

00:43:58.360 --> 00:44:00.600
APIs to pull the information out.

00:44:00.660 --> 00:44:04.740
So you can see that we have
the menu that I modified and

00:44:04.740 --> 00:44:08.700
the window with all its pieces.

00:44:08.710 --> 00:44:11.970
Next, I'm going to save this archive.

00:44:13.160 --> 00:44:19.930
I'm going to save this
archive back into the Nib.

00:44:20.100 --> 00:44:24.290
I'm going to save it with a special name.

00:44:28.090 --> 00:44:30.660
objects.aib.

00:44:30.700 --> 00:44:35.420
So this mirrors the objects.xib
file that it sits next to.

00:44:35.600 --> 00:44:39.040
Now, again, this is what will cause
your existing code,

00:44:39.260 --> 00:44:43.220
your existing IBCarbon runtime code,
to pull your information out of

00:44:43.460 --> 00:44:45.740
the archive rather than the nib.

00:44:45.870 --> 00:44:48.420
So you can get some
performance enhancements.

00:44:49.340 --> 00:44:52.160
Now I could just save this archive
out separately and load it manually

00:44:52.260 --> 00:44:54.700
through the HIarchive APIs as well.

00:44:56.140 --> 00:44:59.830
So I'd like to show you some things
you can do with HIArchives that

00:44:59.830 --> 00:45:02.140
you can't currently do with NIBs.

00:45:02.680 --> 00:45:08.530
For one thing, you can take all kinds of
HI objects and archive them.

00:45:08.610 --> 00:45:11.750
This is just a base HI object.

00:45:18.490 --> 00:45:21.630
and you'll eventually be
able to add parameters.

00:45:21.630 --> 00:45:26.510
We'll be releasing the source code
shortly after the developer conference.

00:45:26.900 --> 00:45:30.110
But because it's an archive,
we can also write out core

00:45:30.160 --> 00:45:34.280
foundation property list types,
so strings and arrays and so on.

00:45:39.610 --> 00:45:42.770
and something that a lot of people
have wanted for a long time.

00:45:42.860 --> 00:45:46.820
This is specifically useful
for navigation services.

00:45:46.820 --> 00:45:52.400
Navigation services has a custom area,
and typically, when you mock up your

00:45:52.400 --> 00:45:56.770
interface in Interface Builder,
you have to put all your

00:45:56.780 --> 00:45:59.270
custom views into a window.

00:45:59.500 --> 00:46:02.620
So you pull the window out of the Nib,
using the i.b.

00:46:02.620 --> 00:46:07.080
Carbon Runtime APIs,
and then pull out all your custom views,

00:46:07.080 --> 00:46:09.530
destroy the window,
and then take those views and put

00:46:09.900 --> 00:46:13.820
them into Navigation Services.

00:46:13.840 --> 00:46:18.980
Now you can just have an
HII view as a top-level object.

00:46:19.040 --> 00:46:21.770
Now I'm going to say it allows subviews.

00:46:24.970 --> 00:46:30.190
And now I can just start loading
it up with all my custom interface.

00:46:30.320 --> 00:46:32.040
And so again,
I'll save this out to an archive.

00:46:32.090 --> 00:46:35.450
And then at runtime,
I can just messing around with a window.

00:46:36.320 --> 00:46:39.490
So I hope that gives you an
idea of what HIBuilder can do.

00:46:39.490 --> 00:46:41.690
And again,
the sample code will be available

00:46:41.690 --> 00:46:44.330
shortly after the developer conference.

00:46:44.520 --> 00:46:47.750
So with that,
I'd like to hand things back to Eric.

00:46:55.410 --> 00:46:59.420
The last bit of the presentation covers
some compatibility tips and other

00:46:59.530 --> 00:47:03.640
changes in other parts of the operating
system that may affect your application.

00:47:03.640 --> 00:47:06.880
So,
compatibility tips are generally things

00:47:06.970 --> 00:47:12.520
where we have changed something about
the implementation or maybe we fixed

00:47:12.640 --> 00:47:17.150
a bug in the toolbox and we found
that this affects applications in

00:47:17.160 --> 00:47:20.560
ways that they may not have expected
because they were not expecting that

00:47:20.690 --> 00:47:25.160
particular bit of implementation or
that particular bug fix to change.

00:47:25.160 --> 00:47:28.130
They're not generally things where
there's a defined behavior in the

00:47:28.130 --> 00:47:32.040
API that we're changing but more
something that happens inadvertently.

00:47:32.130 --> 00:47:34.300
The first one of these is
a good example of this.

00:47:34.300 --> 00:47:39.380
Add event types to handler is an API in
the Carbon Event Manager that lets

00:47:39.380 --> 00:47:43.660
you add extra event types to an event
handler to be handled by that handler.

00:47:43.660 --> 00:47:47.090
And it turns out, we found out recently,
that this API has had

00:47:47.120 --> 00:47:49.080
a bug in it since 10.2.

00:47:49.100 --> 00:47:53.620
It worked properly in 10.0 and 10.1
and we rewrote some stuff in 10.2 and

00:47:53.620 --> 00:47:54.920
broke the way that it behaves slightly.

00:47:54.940 --> 00:48:00.420
So that events added to a handler got
dispatched in slightly the wrong order.

00:48:00.790 --> 00:48:03.140
So we fixed that for Tiger.

00:48:03.140 --> 00:48:05.880
But it also turns out that some
applications have come to depend

00:48:05.880 --> 00:48:08.810
on the particular behavior
that it had in 10.2 and 10.3.

00:48:09.100 --> 00:48:11.850
These apps were never
actually run on 10.0 or 10.1,

00:48:11.920 --> 00:48:14.100
so they were never tested
against the correct behavior.

00:48:14.100 --> 00:48:17.100
They were only tested against
the incorrect behavior.

00:48:17.100 --> 00:48:21.220
So I'm not going to go into explicit
detail about exactly how this changes

00:48:21.220 --> 00:48:24.100
the order of event dispatching,
because I kind of need a blackboard

00:48:24.100 --> 00:48:27.100
and a piece of chalk and lots
of diagrams to explain it.

00:48:27.100 --> 00:48:30.180
But we have detail in the
HITooLbox release notes about

00:48:30.180 --> 00:48:32.100
exactly what's changed here.

00:48:32.300 --> 00:48:35.270
And if you use this API,
you probably want to take a look

00:48:35.270 --> 00:48:38.160
at the release notes and read
about exactly what's changed,

00:48:38.160 --> 00:48:42.230
and that'll help you understand whether
it may be affecting your application.

00:48:42.910 --> 00:48:45.440
The menu bar window is another
example of something that's changed

00:48:45.440 --> 00:48:48.800
in the implementation that's
affecting a lot of applications.

00:48:48.890 --> 00:48:52.800
The menu bar in Tiger is now
drawn into a real window ref

00:48:52.800 --> 00:48:55.500
using a compositing HIView.

00:48:55.500 --> 00:48:57.800
The window ref is a compositing window.

00:48:57.830 --> 00:49:01.030
And that's done so that we can get
resolution independence for free for

00:49:01.030 --> 00:49:05.340
the menu bar because the menu bar
window is using framework scaled mode,

00:49:05.340 --> 00:49:06.930
as I mentioned earlier,
and then the toolbox does

00:49:06.960 --> 00:49:09.800
all the work for making it
resolution independent for you.

00:49:09.800 --> 00:49:13.130
But a lot of applications don't
expect to see a menu bar showing up

00:49:13.130 --> 00:49:14.800
in their window list right at the top.

00:49:14.800 --> 00:49:17.020
They think that the first window
in the window list is going to

00:49:17.030 --> 00:49:18.800
be their active document window,
for example,

00:49:18.800 --> 00:49:22.610
which hasn't really ever been a great
assumption because you could always

00:49:22.610 --> 00:49:25.740
have other windows in the window list,
say a text services manager bottom

00:49:25.740 --> 00:49:28.800
line input window or help tag
window or various other things.

00:49:28.800 --> 00:49:32.800
But a lot of apps have
gotten away with this so far.

00:49:32.890 --> 00:49:35.800
So to maintain compatibility
with existing applications,

00:49:35.800 --> 00:49:39.800
what we're doing here is
for the get window list,

00:49:39.800 --> 00:49:45.800
and get front window of class APIs for
existing CFM and Mako applications,

00:49:45.800 --> 00:49:49.800
we will silently ignore the menu
bar window and just skip over it.

00:49:49.890 --> 00:49:52.800
So you won't see that window
come back from those APIs.

00:49:52.800 --> 00:49:57.810
But if you have a Mako application that
you rebuild on Tiger and relink against

00:49:57.810 --> 00:50:01.230
the Tiger versions of the frameworks,
we'll remove those compatibility

00:50:01.230 --> 00:50:04.420
workarounds on the assumption that
you've then had a chance to deal with the

00:50:04.460 --> 00:50:06.800
problem and fix it in your applications.

00:50:06.800 --> 00:50:09.240
So that at that point,
get window list and get front

00:50:09.240 --> 00:50:12.410
window of class will start returning
the menu bar window since it is a

00:50:12.410 --> 00:50:14.670
window and it's in the window list.

00:50:14.840 --> 00:50:20.080
So if your application is using get
window list or get front window of

00:50:20.080 --> 00:50:25.590
class or the front window API to figure
out what the front most document window

00:50:25.690 --> 00:50:29.490
is or the active document window,
we recommend using the active

00:50:29.510 --> 00:50:33.800
non-floating window or front
non-floating window APIs instead.

00:50:33.800 --> 00:50:37.630
Another change that's tripped up
a few applications is the change

00:50:37.650 --> 00:50:39.800
to the standard window levels.

00:50:39.880 --> 00:50:42.800
That are used by the
standard window groups.

00:50:42.800 --> 00:50:45.100
As I mentioned earlier,
we're now using the same core

00:50:45.230 --> 00:50:47.800
graphics window levels as Cocoa.

00:50:47.800 --> 00:50:51.790
It turns out that some applications have
been manually changing the window levels

00:50:51.810 --> 00:50:53.800
used by the standard window groups.

00:50:53.810 --> 00:50:56.800
And they aren't expecting us
to be changing them as well.

00:50:56.800 --> 00:51:00.700
So the message here is if you
are changing the window levels

00:51:00.840 --> 00:51:03.410
of the standard window groups,
you probably don't need

00:51:03.510 --> 00:51:04.800
to do that on Tiger.

00:51:04.830 --> 00:51:08.120
And also avoid making assumptions
about the window levels that are

00:51:08.210 --> 00:51:09.800
used by the standard window groups.

00:51:09.910 --> 00:51:13.180
You can call get window group level
to find out the level that the toolbox

00:51:13.340 --> 00:51:15.800
has provided for a window group.

00:51:15.800 --> 00:51:20.000
And there's actually some other
new APIs to let you find out the

00:51:20.000 --> 00:51:23.800
window levels that are used when an
application is active or inactive

00:51:23.800 --> 00:51:25.800
because in some cases it can change.

00:51:25.800 --> 00:51:29.570
And try to dynamically set your
own window levels based on the

00:51:29.570 --> 00:51:31.800
ones that the toolbox is using.

00:51:32.540 --> 00:51:37.570
The sending of command events
containing the KHICommandSelectWindow

00:51:37.570 --> 00:51:41.410
event to all windows,
even when they're active,

00:51:41.410 --> 00:51:44.010
if they're clicked,
has caused problems for a few apps

00:51:44.020 --> 00:51:46.860
that handle this event themselves.

00:51:46.860 --> 00:51:50.800
So the key here probably is that if
you handle the KHICommandSelectWindow

00:51:50.800 --> 00:51:54.130
command ID in your command event handler,
check to see if the

00:51:54.130 --> 00:51:55.560
window is already active.

00:51:55.580 --> 00:51:58.140
And if it is already active,
you can probably just pass the

00:51:58.250 --> 00:52:02.860
event through and you don't need to
update your own application state.

00:52:02.860 --> 00:52:09.070
Finally, the HIViewRender API has changed
behavior slightly between Panther and

00:52:09.070 --> 00:52:13.880
Tiger in the sense of how it validates
other views that are being drawn

00:52:13.930 --> 00:52:19.180
in conjunction with the view being
the view that was passed to the API.

00:52:19.280 --> 00:52:23.140
The Tiger behavior is actually
more correct in that we validate

00:52:23.140 --> 00:52:26.200
less of the other views,
only the portions of views

00:52:26.200 --> 00:52:27.450
that actually get redrawn.

00:52:27.570 --> 00:52:29.620
Panther validated too much.

00:52:29.620 --> 00:52:32.580
But again, it turns out that some
applications accidentally

00:52:32.580 --> 00:52:35.240
depended on the Panther behavior.

00:52:35.240 --> 00:52:38.880
So our recommendation here is twofold.

00:52:39.040 --> 00:52:45.280
First, we highly recommend that you only
use the HIViewRender API with

00:52:45.290 --> 00:52:47.940
the root view of a window.

00:52:47.940 --> 00:52:51.470
The root view will have the
same validation behavior

00:52:51.470 --> 00:52:52.980
on both Panther and Tiger.

00:52:52.980 --> 00:52:54.980
So that will avoid the whole problem.

00:52:55.150 --> 00:52:59.070
And second, if you do need to pass a
non-root view to HIViewRender,

00:52:59.090 --> 00:53:00.530
which should be -- which
should be extremely rare,

00:53:00.530 --> 00:53:04.210
just take a look at the release
notes which talk in more detail

00:53:04.230 --> 00:53:08.180
about exactly how the validation
behavior has changed and see if

00:53:08.180 --> 00:53:10.630
that might affect your application.

00:53:11.980 --> 00:53:15.670
Some other changes in
Tiger that I want to cover here.

00:53:15.800 --> 00:53:18.670
First, the Carbon Core framework,
which provides the

00:53:18.670 --> 00:53:21.150
Carbon File Manager and
many other managers,

00:53:21.320 --> 00:53:25.260
has a new file copying API,
which is the same API that

00:53:25.260 --> 00:53:27.500
the Finder uses to copy files.

00:53:27.650 --> 00:53:31.710
And this entirely replaces all the sample
code that Apple has released in the past,

00:53:31.710 --> 00:53:36.170
fs copy object and things like that,
for doing file copying.

00:53:36.290 --> 00:53:39.090
So we highly recommend that you
look at this API and adopt it

00:53:39.090 --> 00:53:42.620
in your applications if you need
to do file copying yourself.

00:53:42.620 --> 00:53:47.270
And that's because the file copy engine
in Tiger knows how to copy some of the

00:53:47.270 --> 00:53:51.820
metadata that can be attached to a file,
such as the extended attributes

00:53:51.820 --> 00:53:53.940
or the access control lists.

00:53:53.940 --> 00:53:57.330
And any of your existing file
copying code just isn't going

00:53:57.330 --> 00:53:59.930
to copy that stuff at all,
because it was written before

00:53:59.930 --> 00:54:02.460
APIs existed in order to do that.

00:54:02.520 --> 00:54:06.400
So you can use this API in both
synchronous and asynchronous modes.

00:54:06.400 --> 00:54:09.060
In the synchronous mode,
you just call fs copy

00:54:09.060 --> 00:54:10.060
object sync or fs move.

00:54:10.080 --> 00:54:14.430
And in the asynchronous mode,
you create one of these fs operation

00:54:14.430 --> 00:54:16.420
refs and then run it asynchronously.

00:54:16.420 --> 00:54:19.920
And you can get progress
updates and status notifications

00:54:19.920 --> 00:54:22.240
in that case as well.

00:54:22.240 --> 00:54:27.460
Another change in Tiger I'd like to
highlight is the status of Quick Draw.

00:54:27.460 --> 00:54:29.950
And we've been telling you for
quite a while-- and we certainly

00:54:29.950 --> 00:54:33.550
reiterated it earlier this week at
the Graphics and Media State of the

00:54:33.940 --> 00:54:39.640
Union-- that you want to move off of
Quick Draw and start using core graphics.

00:54:39.640 --> 00:54:44.520
And to make that official in Tiger,
Quick Draw is officially deprecated.

00:54:44.520 --> 00:54:48.360
Its status as an API has
become deprecated in Tiger.

00:54:48.480 --> 00:54:51.210
This doesn't mean we're
removing the API entirely.

00:54:51.220 --> 00:54:52.200
It's still there.

00:54:52.200 --> 00:54:53.780
Your applications can still call it.

00:54:53.780 --> 00:54:55.680
They'll still run.

00:54:55.680 --> 00:54:59.840
And in fact, it's still there on
Mac OS X for Intel as well.

00:54:59.840 --> 00:55:03.710
But it does mean that we are putting
you on notice that we're not going

00:55:03.710 --> 00:55:07.480
to do any more performance changes or
performance enhancements to Quick Draw.

00:55:07.480 --> 00:55:09.350
Those are all going into core graphics.

00:55:09.530 --> 00:55:11.740
We're not going to fix any
more bugs in Quick Draw,

00:55:11.740 --> 00:55:14.910
except for things that are
absolutely required for compatibility

00:55:14.920 --> 00:55:16.790
to keep applications running.

00:55:16.910 --> 00:55:19.800
So what you see right now is
what you're going to get for as

00:55:19.800 --> 00:55:21.720
long as Quick Draw is supported.

00:55:21.720 --> 00:55:23.890
There's not going to be
any improvements there.

00:55:24.040 --> 00:55:26.510
So you definitely want to,
if you haven't already,

00:55:26.670 --> 00:55:29.480
start moving off of
Quick Draw and onto core graphics.

00:55:29.480 --> 00:55:31.600
The other big advantage of
moving to core graphics,

00:55:31.600 --> 00:55:33.530
of course,
is that it will make it much easier for

00:55:33.540 --> 00:55:37.880
your application to become resolution
independent in the future as well.

00:55:38.020 --> 00:55:42.430
HImovieView is a new HIview
that the QuickTime team has

00:55:42.430 --> 00:55:44.100
asked me to talk a little about.

00:55:44.460 --> 00:55:49.960
It's a view that is provided in
QuickTime 7 when it's running on Tiger.

00:55:50.360 --> 00:55:54.790
and it is now the preferred way to put
QuickTime movies into Carbon Windows if

00:55:54.790 --> 00:55:58.200
you're using one of the standard
views built into the system.

00:55:58.200 --> 00:56:00.360
So it's a full-featured HIView.

00:56:00.360 --> 00:56:04.180
It's been rewritten to use Carbon events
and use all the standard functionality.

00:56:04.210 --> 00:56:06.160
You can load them from Nib files.

00:56:06.190 --> 00:56:08.190
You can put them in composited windows.

00:56:08.260 --> 00:56:09.160
You can scroll them around
inside a scroll view,

00:56:09.270 --> 00:56:10.200
that sort of stuff.

00:56:10.200 --> 00:56:13.290
It uses the visual context
API in QuickTime 7,

00:56:13.290 --> 00:56:16.200
so that gives you some performance
advantages when you're doing

00:56:16.200 --> 00:56:19.810
live resizing and really helps
the QuickTime playback system

00:56:19.820 --> 00:56:23.200
leverage the GPU rather than
putting the playback on the CPU.

00:56:23.200 --> 00:56:26.670
And so just in general,
on Tiger you want to be looking

00:56:26.670 --> 00:56:30.200
at using HIMovieView rather than
the older Carbon Movie Control,

00:56:30.200 --> 00:56:33.600
which is essentially just static
at this point and won't see any

00:56:33.600 --> 00:56:36.200
significant improvements going forward.

00:56:37.440 --> 00:56:42.730
Coalesced updates is something that the
core graphics team has done in Tiger that

00:56:42.820 --> 00:56:45.610
may have effects on your application.

00:56:47.100 --> 00:56:51.280
You may have also heard it
called deferred updates.

00:56:51.280 --> 00:56:56.210
And I want to sort of explain
how updates work generally to

00:56:56.210 --> 00:56:58.830
give you some background here.

00:56:58.930 --> 00:57:02.910
When you draw into a window,
windows are double buffered on Mac OS X,

00:57:02.940 --> 00:57:05.860
so you're actually drawing into
the window's off-screen buffer.

00:57:05.960 --> 00:57:09.930
And the bits that you've changed
don't get displayed on the physical

00:57:10.010 --> 00:57:13.740
hardware until Core Graphics comes
along and takes those bits and sends

00:57:13.790 --> 00:57:15.250
them out to the display hardware.

00:57:15.340 --> 00:57:17.860
That's a process called flushing.

00:57:17.950 --> 00:57:21.540
Now the flushing process happens
in most cases automatically because

00:57:21.540 --> 00:57:25.370
both HIToolbox and AppKit will
automatically flush your windows

00:57:25.400 --> 00:57:27.400
when you hit the event loop.

00:57:27.520 --> 00:57:30.590
So if you're calling into the
event loop on a regular basis,

00:57:30.680 --> 00:57:33.740
then all your windows are
going to be flushed by default.

00:57:33.920 --> 00:57:37.930
However, some of your applications may be
explicitly flushing as well if you're

00:57:37.930 --> 00:57:40.630
doing things that draw into a window,
but then you don't run the

00:57:40.640 --> 00:57:41.560
event loop for a while.

00:57:41.560 --> 00:57:44.850
You need to explicitly flush to make
sure those changes come to the screen.

00:57:45.260 --> 00:57:50.460
So pre-Tiger,
when a flush request happened,

00:57:50.640 --> 00:57:53.120
Core Graphics immediately grabbed
the bits out of the windows

00:57:53.160 --> 00:57:56.220
off-screen buffer and sent them
off to the display hardware.

00:57:56.220 --> 00:57:59.300
And that's fine,
except that if you have lots of

00:57:59.300 --> 00:58:04.220
applications all doing this at once,
you wind up with a serialization effect.

00:58:04.240 --> 00:58:07.360
So each application has to wait for
the flush request of all the other

00:58:07.360 --> 00:58:09.420
applications that got in before it did.

00:58:09.420 --> 00:58:13.910
And that can have some significant
performance degradation.

00:58:14.130 --> 00:58:16.680
So in Tiger,
what the Core Graphics team has

00:58:16.680 --> 00:58:21.160
done is they are now coalescing
all these flush requests together.

00:58:21.280 --> 00:58:24.340
So no matter how many
applications you have running,

00:58:24.340 --> 00:58:26.940
all of their flush requests are
going to get batched together,

00:58:26.940 --> 00:58:31.330
and they'll all be delayed until
the next display refresh cycle.

00:58:31.610 --> 00:58:33.760
And at that point,
all of them will be sent

00:58:33.760 --> 00:58:35.320
out to the display hardware.

00:58:35.560 --> 00:58:38.730
So this improves performance when
you have lots of applications

00:58:38.730 --> 00:58:39.840
all flushing at once.

00:58:39.850 --> 00:58:43.690
It eliminates the tearing that
may have been seen in the past.

00:58:43.860 --> 00:58:48.190
But it can also reduce
performance for some applications.

00:58:48.200 --> 00:58:53.280
Applications that are explicitly
flushing and doing so very often can see

00:58:53.280 --> 00:58:55.570
a reduction in performance due to this.

00:58:55.750 --> 00:59:00.750
Because previously, once they flushed,
if they drew again after the flush,

00:59:00.800 --> 00:59:02.960
the flush would happen pretty quickly.

00:59:03.020 --> 00:59:06.890
The drawing operation gets blocked
until the flush is finished because you

00:59:06.990 --> 00:59:09.660
can't draw while Core Graphics is taking
the bits out of the window buffer.

00:59:09.660 --> 00:59:12.820
You need to wait until the
buffer has been properly updated

00:59:12.820 --> 00:59:14.540
off to the display hardware.

00:59:14.670 --> 00:59:17.710
But as long as the flush happens quickly,
your draw operation can

00:59:17.740 --> 00:59:19.460
continue pretty quickly too.

00:59:19.540 --> 00:59:22.330
On Tiger, however,
the flush operation gets delayed

00:59:22.330 --> 00:59:23.900
until the next refresh cycle.

00:59:23.970 --> 00:59:27.500
And that means your next drawing
operation after the flush gets displayed

00:59:27.500 --> 00:59:29.500
until the next refresh cycle as well.

00:59:29.600 --> 00:59:32.140
So if you have a loop where you're
doing a flush and then a draw

00:59:32.140 --> 00:59:35.760
and then a flush and then a draw
and then a flush and then a draw,

00:59:35.820 --> 00:59:38.660
a lot of your drawing operations
are going to get blocked.

00:59:38.740 --> 00:59:41.780
And you're going to wind up being
held to the display refresh rate

00:59:41.860 --> 00:59:46.580
where you might have been able to run
faster on previous versions of 10.

00:59:46.820 --> 00:59:49.770
So because of this potential
issue for some applications,

00:59:49.810 --> 00:59:53.680
the Coalesced Updates feature is
only enabled for new applications,

00:59:53.680 --> 00:59:57.930
Mac OS applications that are
linked on Tiger and later.

00:59:57.950 --> 01:00:00.380
It's not enabled for any
existing applications.

01:00:00.380 --> 01:00:04.000
All of your CFM applications,
all of your Mac OS applications

01:00:04.000 --> 01:00:09.080
that were linked on Panther do not
get the Coalesced Updates change.

01:00:09.080 --> 01:00:11.350
However,
when you take your Mac OS application

01:00:11.350 --> 01:00:13.990
and relink it on Tiger,
you are going to start seeing

01:00:13.990 --> 01:00:15.670
the effects of Coalesced Updates.

01:00:15.670 --> 01:00:18.090
So you will need to deal
with this as you move

01:00:19.800 --> 01:00:22.040
So we have some
recommendations here for you,

01:00:22.040 --> 01:00:25.000
for how to best work in a
world of coalesced updates.

01:00:25.020 --> 01:00:27.740
And the first recommendation
is pretty simple.

01:00:27.760 --> 01:00:30.070
Don't flush explicitly
if you don't have to.

01:00:30.240 --> 01:00:32.880
The HIToolbox already is
flushing on your behalf.

01:00:32.880 --> 01:00:36.180
And in most cases,
you don't need to flush yourself.

01:00:36.190 --> 01:00:37.780
But sometimes you do.

01:00:37.790 --> 01:00:40.590
And in that case,
the next recommendation is just

01:00:40.840 --> 01:00:42.570
don't flush too frequently.

01:00:42.820 --> 01:00:46.600
You don't need to flush more often
than the display refresh rate.

01:00:46.720 --> 01:00:49.260
The display isn't going to be
redrawn more often than that anyways.

01:00:49.260 --> 01:00:51.440
So if you flush more often
than the display refresh rate,

01:00:51.440 --> 01:00:52.700
it's not going to do you any good.

01:00:52.700 --> 01:00:55.740
You're not actually going to see
anything that you're flushing anyways.

01:00:55.990 --> 01:00:58.960
So you can ask for the display
refresh rate for the main

01:00:58.960 --> 01:01:00.940
display from Core Graphics.

01:01:00.940 --> 01:01:03.820
And if you need to flush explicitly,
just keep track of the

01:01:03.820 --> 01:01:05.660
time that you last flushed.

01:01:05.660 --> 01:01:09.220
And if the amount of time since
then that has elapsed is less

01:01:09.220 --> 01:01:12.150
than the display refresh rate,
don't flush again.

01:01:12.190 --> 01:01:17.930
Just wait until that next refresh
rate interval has elapsed.

01:01:18.050 --> 01:01:21.130
Also, you don't need to draw too often.

01:01:21.210 --> 01:01:24.080
If your display is refreshing
at 80 cycles a second,

01:01:24.080 --> 01:01:27.000
80 hertz,
and you're drawing at 200 hertz,

01:01:27.040 --> 01:01:30.170
half of your frames aren't going to
show up on the display because they'll

01:01:30.170 --> 01:01:33.210
get overwritten by the next frame and
the user isn't even going to see them.

01:01:33.430 --> 01:01:35.300
So you really don't need
to draw any faster than the

01:01:35.300 --> 01:01:36.650
display refresh rate either.

01:01:36.660 --> 01:01:43.240
Finally, if you want to explore what the
effects of coalesced updates may

01:01:43.300 --> 01:01:48.300
be on your application even before
you rebuild it as Mac OS on Tiger,

01:01:48.300 --> 01:01:52.760
you can use the Quartz Debug application
to explicitly turn on coalesced

01:01:52.770 --> 01:01:55.460
updates for all apps across the system.

01:01:55.580 --> 01:01:58.360
Now that's not a mode you
might typically want to run in,

01:01:58.360 --> 01:02:01.390
but it's useful for performance
testing to just see how your

01:02:01.410 --> 01:02:05.480
application is going to behave once
coalesced updates is enabled for it.

01:02:06.990 --> 01:02:08.540
So here's our summary.

01:02:08.760 --> 01:02:10.580
The goals of the HIToolbox team.

01:02:10.760 --> 01:02:12.770
Well, we're here for you, basically.

01:02:12.950 --> 01:02:15.190
We want to address your requests.

01:02:15.320 --> 01:02:18.060
We want to do the things that
you need us to do to make it

01:02:18.060 --> 01:02:20.120
easy to write your applications.

01:02:20.220 --> 01:02:23.290
We want to support new technologies
as they come out from Apple so

01:02:23.290 --> 01:02:26.840
that those technologies can be
integrated into your applications.

01:02:26.840 --> 01:02:29.190
In general,
we just want to make it easy to

01:02:29.190 --> 01:02:31.330
write a great Mac OS X application.

01:02:31.390 --> 01:02:34.790
Carbon's a great API for doing that,
and we want to continue to see you

01:02:34.810 --> 01:02:36.900
writing those Carbon applications.

01:02:37.320 --> 01:02:41.060
What we want from you,
we want you to write custom HI views.

01:02:41.060 --> 01:02:44.000
And when you're doing that,
we want you to use compositing

01:02:44.000 --> 01:02:45.300
mode and core graphics.

01:02:45.440 --> 01:02:52.680
That will give you better performance,
and it will make it much easier

01:02:52.680 --> 01:02:52.680
for your applications to become
resolution independent in the future.

01:02:52.810 --> 01:02:55.080
We want you to make your
application accessible.

01:02:55.280 --> 01:02:58.870
That's not only for the needs of
users with visual disabilities,

01:02:58.870 --> 01:03:02.760
but as you saw in one of the State of
the Union addresses yesterday,

01:03:02.760 --> 01:03:07.190
accessibility is a really cool feature
for other things like scriptability and

01:03:07.230 --> 01:03:11.960
inspection and being able to introspect
about what's going on in an application.

01:03:12.070 --> 01:03:16.510
And it can really add a lot of value
to your application if it's accessible.

01:03:16.590 --> 01:03:19.450
And finally,
please tell us what you need.

01:03:19.450 --> 01:03:21.260
We're not mind readers.

01:03:21.260 --> 01:03:24.060
You may be butting up against
this particular problem

01:03:24.110 --> 01:03:26.990
every day and thinking,
darn, haven't they fixed this already?

01:03:27.180 --> 01:03:30.420
But if you don't tell us about it,
we're not going to know.

01:03:30.420 --> 01:03:33.610
So please, tell us what you need,
file bugs,

01:03:33.610 --> 01:03:36.780
put feature requests in radar as well.

01:03:36.780 --> 01:03:39.450
We also have this email
address for feedback,

01:03:39.540 --> 01:03:43.260
HIToolebox-feedback@group.apple.com.

01:03:43.320 --> 01:03:46.220
This replaces an older address,
toolbox@apple.com,

01:03:46.220 --> 01:03:48.690
which is no longer in service.

01:03:49.040 --> 01:03:52.460
So if you have specific bugs
or specific feature requests,

01:03:52.470 --> 01:03:54.000
please put those in Radar.

01:03:54.000 --> 01:03:57.660
But if you just have general conceptual
feedback or general questions,

01:03:57.660 --> 01:04:02.180
this is a great address and we'll
try to answer your questions there.

01:04:03.390 --> 01:04:06.940
More information can be found
in the HIToolbox release notes,

01:04:06.960 --> 01:04:11.100
which go into a lot of detail about
what's changed in the toolbox in Tiger.

01:04:11.190 --> 01:04:13.880
Those are on developer.apple.com,
the most recent versions

01:04:13.940 --> 01:04:16.520
on developer.apple.com,
and also in the Xcode

01:04:16.980 --> 01:04:20.590
documentation update that was
released a month or so ago.

01:04:20.850 --> 01:04:27.100
There's also a Q&A that DTS has put out
about how to use HIMovieView on Tiger.

01:04:28.330 --> 01:04:29.690
Let's see.

01:04:29.810 --> 01:04:33.800
And some other sessions coming
up that you may want to go to.

01:04:33.800 --> 01:04:35.840
Right after this one,
it's going to be voiceover

01:04:35.840 --> 01:04:39.280
and Carbon applications,
talking about how to use accessibility to

01:04:39.330 --> 01:04:41.800
make your Carbon application accessible.

01:04:41.940 --> 01:04:45.440
There will be a session on
HITextView and MLTE and the new

01:04:45.440 --> 01:04:48.350
features available there in TIGR.

01:04:48.380 --> 01:04:50.230
And tomorrow,
we'll have an in-depth session

01:04:50.230 --> 01:04:51.660
on building a custom HIView.

01:04:51.690 --> 01:04:55.180
And we're going to go into -- we're going
to cover a lot of issues that we haven't

01:04:55.180 --> 01:04:58.640
covered in previous years when we've
given sessions about building HIViews,

01:04:58.730 --> 01:05:03.460
things like doing text input and
keyboard focus and accessibility.

01:05:03.460 --> 01:05:05.930
We have a feedback forum on
Thursday where you should all

01:05:05.940 --> 01:05:10.340
come and tell us what we're doing
right and what we're doing wrong.

01:05:10.340 --> 01:05:14.320
And also the application
technologies lab is open all week.

01:05:14.490 --> 01:05:17.840
I'm going to be there tonight and
I'll probably be there tomorrow

01:05:17.840 --> 01:05:20.870
night and we'll have other
people there during the week.

01:05:20.980 --> 01:05:25.000
That's not -- despite the title,
it's not just about HIView.

01:05:25.000 --> 01:05:27.830
You can really come in and ask us
any kind of HIToolbox question.

01:05:27.840 --> 01:05:30.000
and we'll see what we
can do to help you out.
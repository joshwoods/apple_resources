WEBVTT

00:00:01.250 --> 00:00:05.840
Good morning, everybody,
and thank you so much for getting

00:00:05.960 --> 00:00:07.480
up early and coming to this session.

00:00:07.480 --> 00:00:11.790
You know,
I didn't know quite what to expect.

00:00:11.940 --> 00:00:16.820
It was announced as a hands-on session,
but I was worried it was going

00:00:16.820 --> 00:00:18.950
to be a hangover session.

00:00:19.800 --> 00:00:25.880
My name is supposedly on the
screen together with a nickname.

00:00:25.890 --> 00:00:28.300
And please be careful with
pronouncing the nickname.

00:00:28.300 --> 00:00:31.260
Yesterday evening,
I overheard somebody talk

00:00:31.570 --> 00:00:33.660
about the Quartz Barbarian.

00:00:33.810 --> 00:00:35.690
That's not good.

00:00:36.750 --> 00:00:39.800
Let's get right into it.

00:00:39.940 --> 00:00:43.320
We have something for everybody
to know that's not quite true.

00:00:43.320 --> 00:00:48.310
We have a restricted audience,
as you can see by looking around you,

00:00:48.310 --> 00:00:51.690
which means that nearly everybody
has already moved to Quartz,

00:00:51.690 --> 00:00:55.630
and there is no need for me to stand
up and to come back anymore next year.

00:00:55.630 --> 00:01:00.790
So, Carbon developers who still have not

00:01:01.180 --> 00:01:05.120
Finish the move to replace
QuickDraw by Quartz.

00:01:05.950 --> 00:01:08.800
There's one serious thing,
among all the jokes,

00:01:08.820 --> 00:01:10.310
that I want to point out.

00:01:10.410 --> 00:01:15.320
We really, really recommend that in this
process you also consider

00:01:15.320 --> 00:01:17.820
adopting the HIVU architecture.

00:01:17.970 --> 00:01:21.030
I know many of you have
made the step already,

00:01:21.030 --> 00:01:26.200
and those who did will agree with me
that it's a real good recommendation.

00:01:26.200 --> 00:01:31.080
It will make your code so much cleaner,
and it's just a natural environment.

00:01:31.100 --> 00:01:37.190
To adopt the Quartz API and use it.

00:01:37.610 --> 00:01:41.890
By something for everybody,
I meant that we start out really

00:01:41.890 --> 00:01:47.630
simple with some hand-holding for
those of you who should have never

00:01:47.630 --> 00:01:53.580
started getting their feet wet in
the Quartz API or their hands dirty,

00:01:53.600 --> 00:01:55.270
if I dare say so.

00:01:55.280 --> 00:02:01.970
So this is going, and that's going to
be the just draw step.

00:02:04.040 --> 00:02:07.830
But then we advance fast,
and I will bring up

00:02:07.830 --> 00:02:11.450
Ted Jucevic from DTS on stage.

00:02:11.460 --> 00:02:15.560
He is the DTS doctor who
deals with your incidents,

00:02:15.560 --> 00:02:18.290
and he knows the answers to that.

00:02:18.420 --> 00:02:23.280
He knows your questions,
and he presents his answers in a sample

00:02:23.280 --> 00:02:26.710
application called Carbon CG Compositor.

00:02:26.720 --> 00:02:31.800
And I will come back with,
under the theme, mouse tracking,

00:02:31.800 --> 00:02:33.960
where I want to cover a lot of things.

00:02:34.100 --> 00:02:38.040
So, we have a lot of background,
and mouse tracking is just the

00:02:38.040 --> 00:02:39.660
theme that holds it all together.

00:02:39.680 --> 00:02:42.150
So, how about this just draw?

00:02:42.180 --> 00:02:46.770
The idea was to make it as simple,
as basic as possible,

00:02:46.970 --> 00:02:51.030
and to just have to get the start,
to try out.

00:02:51.060 --> 00:02:55.100
Main points,
we show how to get the CG context.

00:02:55.160 --> 00:03:00.780
We work with the HIVU coordinate
system and have to spend some time

00:03:01.700 --> 00:03:03.540
explaining around with coordinates.

00:03:05.150 --> 00:03:08.820
And then,
the first not completely trivial

00:03:08.870 --> 00:03:12.220
step is how to replace a drawstring.

00:03:12.230 --> 00:03:17.070
And I think everybody who moves
from the QuickDraw API to Quartz

00:03:17.160 --> 00:03:22.240
sooner or later runs into this need,
and we need to spend some time on it.

00:03:22.430 --> 00:03:24.550
How about the coordinates?

00:03:25.030 --> 00:03:28.840
Well, we have the left-handed system
and the right-handed system.

00:03:28.840 --> 00:03:33.830
The origin either at the top left,
as we have been used to by QuickDraw,

00:03:33.920 --> 00:03:34.980
or the bottom right.

00:03:35.080 --> 00:03:41.790
The pictures below show how
to move from one to the other.

00:03:41.980 --> 00:03:44.980
The X coordinate doesn't change
the horizontal coordinate,

00:03:45.000 --> 00:03:47.260
and the Y needs to be
flipped and shifted.

00:03:47.260 --> 00:03:53.310
In Quartz parlance,
this means we apply an affine transform

00:03:53.420 --> 00:03:56.540
to scale the Y axis by minus one.

00:03:56.540 --> 00:03:59.850
It flips it up,
but then we have to shift it back down.

00:03:59.850 --> 00:04:03.350
Otherwise,
you wouldn't see anything in your view,

00:04:03.400 --> 00:04:06.690
which is shaded,
where the drawing happens.

00:04:06.740 --> 00:04:09.740
The good news is that it
doesn't matter if you go from

00:04:09.740 --> 00:04:14.170
QuickDraw coordinates to Quartz,
native Quartz coordinates, or back.

00:04:14.290 --> 00:04:15.920
It's always the same transform.

00:04:15.920 --> 00:04:20.510
And instead of building it
up by transform scale and

00:04:20.510 --> 00:04:25.430
then a transform translate,
we just will make a simple

00:04:25.430 --> 00:04:29.190
transform that contains everything.

00:04:29.200 --> 00:04:31.860
So, just draw as simple as possible.

00:04:31.860 --> 00:04:34.860
The only thing is a piece of
diagonal line so we know where the

00:04:34.860 --> 00:04:36.630
origin is and in which direction.

00:04:36.740 --> 00:04:41.130
The Y is oriented, and then a drawstring.

00:04:41.500 --> 00:04:42.710
So, we have some real work to do.

00:04:42.730 --> 00:04:44.300
Let's go.

00:04:44.310 --> 00:04:47.630
Can we move to the Xcode machine, please?

00:04:54.000 --> 00:05:00.240
And I certainly wish I wouldn't have to
turn my back to you during all this work.

00:05:00.260 --> 00:05:03.230
So this is one of the two
examples that you find in the

00:05:03.300 --> 00:05:06.630
package that you downloaded,
and you're supposed to work

00:05:06.630 --> 00:05:09.480
along with me on your laptops,
on your powerbooks.

00:05:09.540 --> 00:05:12.460
I have two variants,
the QuikTrav variant and

00:05:12.600 --> 00:05:14.500
the Core graphics variant.

00:05:14.640 --> 00:05:16.000
Let's look at it.

00:05:16.070 --> 00:05:19.080
I promised it to be
as simple as possible.

00:05:19.080 --> 00:05:24.090
If you ask Xcode to come up
with a Carbon application,

00:05:24.330 --> 00:05:26.800
then that's what you get.

00:05:26.800 --> 00:05:31.130
And the only thing I added
was installing a draw handler

00:05:31.130 --> 00:05:33.660
on the Windows content view.

00:05:33.660 --> 00:05:38.400
This is something the HIToolbox
people frown upon a little bit.

00:05:38.420 --> 00:05:42.900
It's not really the real
way to deal with HIViews,

00:05:42.900 --> 00:05:47.840
but it's for now the quick and dirt the
shortest way to get something going.

00:05:47.840 --> 00:05:48.840
And afterwards, I will... Okay.

00:05:49.080 --> 00:05:58.200
I'll fix this and create a correct HIView
to be embedded in the content view.

00:05:58.200 --> 00:06:01.510
So what we're interested
in is the draw handler.

00:06:01.950 --> 00:06:02.840
That gets passed in.

00:06:02.840 --> 00:06:05.740
And by the way, note that the view,
as usual here,

00:06:05.760 --> 00:06:12.520
gets passed in as user data,
such that when our draw

00:06:12.520 --> 00:06:12.520
handler gets called,

00:06:20.910 --> 00:06:25.240
Then we have the user data
that contain our view in case

00:06:25.340 --> 00:06:28.210
we need to get back to it,
and we may have to.

00:06:28.240 --> 00:06:32.370
The first thing I'm doing here
is pulling out the CG context,

00:06:32.370 --> 00:06:37.100
which is one of the event parameters,
and then pass it along to my just

00:06:37.100 --> 00:06:42.020
draw something just to factor it
out while we are tinkering around.

00:06:42.020 --> 00:06:46.200
And our just draw something for
now doesn't use the CG context

00:06:46.200 --> 00:06:50.550
ref yet because I only
have the QuickDraw version.

00:06:50.800 --> 00:06:58.430
But now we are getting to work and
we are replacing this by Quartz.

00:06:59.320 --> 00:07:00.900
Move to, that's an easy one.

00:07:00.910 --> 00:07:04.860
CG context, move to, point.

00:07:09.200 --> 00:07:10.540
Line 2, that's an easy one.

00:07:10.610 --> 00:07:14.850
CG Context, add line to point.

00:07:20.620 --> 00:07:22.640
Okay.

00:07:22.670 --> 00:07:26.080
Well, we are still real beginners,
so we want to see right

00:07:26.080 --> 00:07:27.190
away what happens.

00:07:29.540 --> 00:07:32.540
Oh, this worked well.

00:07:32.570 --> 00:07:36.840
The part that worked well was that we
don't use the QuickDraw code anymore.

00:07:40.250 --> 00:07:43.430
What we are missing here is
that the model is different.

00:07:43.520 --> 00:07:49.180
In order to get something to draw,
we need to tell what we want

00:07:49.390 --> 00:07:54.040
to do with this path that's
current inside the CG context.

00:07:54.060 --> 00:07:57.310
We can either, and we just,
so far we only built the path,

00:07:57.310 --> 00:07:59.040
but we didn't do anything with it.

00:07:59.110 --> 00:08:02.350
We need to ask the context
to stroke the path,

00:08:02.510 --> 00:08:03.460
for example.

00:08:09.360 --> 00:08:11.000
Maybe this will work better.

00:08:11.040 --> 00:08:14.120
And now we have a nice
anti-alias diagonal line,

00:08:14.120 --> 00:08:16.480
just as we expected.

00:08:16.530 --> 00:08:19.600
Next step, the drawstring part.

00:08:20.010 --> 00:08:25.100
While we have text font and text size,
in Quartz this is called

00:08:25.180 --> 00:08:30.330
CG Context Select Font,
and I don't remember the parameters.

00:08:32.010 --> 00:08:34.330
So, yeah,
I could have remembered the context,

00:08:34.420 --> 00:08:38.580
and then we need a C string
as font name and the size.

00:08:38.600 --> 00:08:39.120
We can do that.

00:08:39.120 --> 00:08:42.360
Oh, here it comes.

00:08:42.680 --> 00:08:42.960
Okay.

00:08:47.760 --> 00:08:53.060
Let's try Geneva.

00:08:53.120 --> 00:08:56.160
And Aten, just to match it.

00:08:56.230 --> 00:08:59.040
Oh, and the text encoding thing.

00:08:59.130 --> 00:09:01.390
KCG.

00:09:02.350 --> 00:09:03.290
Is there something?

00:09:03.290 --> 00:09:05.260
No.

00:09:05.300 --> 00:09:05.920
Encoding.

00:09:06.050 --> 00:09:07.380
Oh, yeah.

00:09:07.420 --> 00:09:09.780
Encoding Macroman.

00:09:10.330 --> 00:09:11.440
That fits the bill.

00:09:11.440 --> 00:09:17.270
And in order to show text,
we don't draw the text

00:09:17.400 --> 00:09:18.510
or stroke or whatever.

00:09:18.510 --> 00:09:19.560
We need to show it.

00:09:19.560 --> 00:09:20.930
Show text.

00:09:20.960 --> 00:09:23.110
Now here we have two alternatives.

00:09:23.200 --> 00:09:25.140
Show text or show text at point.

00:09:25.140 --> 00:09:27.800
It's probably safer to take the at point.

00:09:27.800 --> 00:09:31.960
The background story is that
QuickDraw maintains the current

00:09:31.960 --> 00:09:36.190
pen position and uses it also
for the next text drawing call.

00:09:36.760 --> 00:09:40.360
Whereas in Quartz,
we just had built a path internally,

00:09:40.690 --> 00:09:42.360
stroke it, now it's gone.

00:09:42.360 --> 00:09:45.750
And we haven't any pen
position for text drawing.

00:09:45.760 --> 00:09:47.160
So we better specify it.

00:09:47.160 --> 00:09:57.020
I forgot again the parameters.

00:09:57.870 --> 00:09:58.240
No.

00:10:11.400 --> 00:10:15.060
I meant text at point.

00:10:15.080 --> 00:10:17.670
Hitting the wrong keys all the time.

00:10:25.830 --> 00:10:27.420
And our string, ha.

00:10:27.820 --> 00:10:33.310
Now this time we need to set
it up because I use hello

00:10:33.360 --> 00:10:35.840
world as Pascal string.

00:10:36.100 --> 00:10:38.830
So that's where we are with the
beginning of the characters,

00:10:38.830 --> 00:10:43.800
and this, the length is the first byte.

00:10:43.800 --> 00:10:44.880
OK.

00:10:44.930 --> 00:10:49.600
Build and go.

00:10:49.770 --> 00:10:52.310
I did something wrong again.

00:11:01.900 --> 00:11:02.900
Much better.

00:11:02.990 --> 00:11:07.590
Well, not quite finished yet.

00:11:07.800 --> 00:11:09.670
So this is the story
about the coordinates.

00:11:09.710 --> 00:11:14.870
If you remember the little drawing with
the coordinate flipping and drawing,

00:11:14.870 --> 00:11:16.650
there was a little character drawn.

00:11:16.650 --> 00:11:21.070
And flipping, of course,
put the text upside down.

00:11:21.070 --> 00:11:24.680
And that's what we are running into now.

00:11:25.490 --> 00:11:28.220
How can we deal with this?

00:11:28.340 --> 00:11:31.280
One way to deal with this is

00:11:31.600 --> 00:12:14.400
[Transcript missing]

00:12:15.630 --> 00:12:17.860
There is a call, "HIV,
get bounce." And now

00:12:17.860 --> 00:12:23.580
remember that I said,
"HIV, ref." That's the user data.

00:12:23.580 --> 00:12:26.570
And here I get bounce, hopefully.

00:12:26.930 --> 00:12:34.600
And now I use CG Context Concat CTM,
the current transform matrix,

00:12:35.160 --> 00:12:41.130
with a CG-affined
transform that represents

00:12:42.270 --> 00:12:49.600
The combination of flipping across the
vertical coordinates and shifting down.

00:12:49.630 --> 00:12:51.360
Okay, transform make.

00:12:51.500 --> 00:12:53.880
One for the X.

00:12:53.980 --> 00:12:55.600
These are the diagonal elements.

00:12:55.600 --> 00:12:57.520
Minus one for the Y scale.

00:12:57.520 --> 00:13:02.730
We don't move in the X direction,
but we do move in the Y direction

00:13:02.730 --> 00:13:05.190
by the height of the bounds.

00:13:08.700 --> 00:13:12.620
Okay, maybe this builds and runs.

00:13:12.620 --> 00:13:13.550
It does.

00:13:13.550 --> 00:13:17.920
And the text is, as expected,
in the right orientation.

00:13:17.920 --> 00:13:20.480
But now, of course,
the coordinates are wrong.

00:13:20.480 --> 00:13:26.200
So we could fix up all these
coordinates such that we get back to

00:13:26.410 --> 00:13:33.420
the appearance in our QuickDraw content
and still have the correct text.

00:13:33.620 --> 00:13:38.670
But in case you don't want to do this,
we have another alternative.

00:13:38.760 --> 00:13:45.330
And that's the point.

00:13:45.330 --> 00:13:45.330
So either we do this...

00:13:46.400 --> 00:14:04.000
[Transcript missing]

00:14:06.890 --> 00:14:12.130
"The Y-axis." Let's see what happens now.

00:14:12.300 --> 00:14:15.560
So I didn't change anything
in the drawing above.

00:14:15.600 --> 00:14:19.080
We always go to 0, 0, 100, 100.

00:14:19.100 --> 00:14:21.260
We still use--

00:14:21.760 --> 00:14:29.120
The same coordinates as in QuickDraw,
we still use the HIView coordinates,

00:14:29.240 --> 00:14:32.940
but we added instead
this flipped text matrix.

00:14:33.010 --> 00:14:39.360
And now we should see
when we can compile.

00:14:44.780 --> 00:14:46.740
And if... okay.

00:14:46.740 --> 00:14:51.030
If everything was as simple,
now we got what we wanted.

00:14:53.280 --> 00:14:58.210
We should go back to the slides now,
so I get more to talk

00:14:58.210 --> 00:15:01.190
instead of screwing up code.

00:15:02.170 --> 00:15:03.460
The drawstring is missing.

00:15:03.460 --> 00:15:06.140
Well, it's not really missing
anymore because I showed you

00:15:06.140 --> 00:15:09.120
how to do it with CG Context,
Show Text, and so on.

00:15:09.210 --> 00:15:12.300
But you remember there is
this MacRoman encoding.

00:15:12.300 --> 00:15:15.790
If I put in any other constant,
you get garbage.

00:15:15.850 --> 00:15:17.040
It just won't work.

00:15:17.080 --> 00:15:22.010
Which means this Show Texted point
is the most convenient replacement

00:15:22.080 --> 00:15:27.310
for drawstring in those cases where
MacRoman is just about good enough.

00:15:28.200 --> 00:15:33.160
As soon as you go abroad and you
need other text systems or anything,

00:15:33.160 --> 00:15:36.290
or you have other requirements
that go beyond the most

00:15:36.500 --> 00:15:40.620
basic MacRoman text drawing,
that's not good anymore.

00:15:40.620 --> 00:15:45.340
So the next recommendation
is the HITimDraw text box.

00:15:45.340 --> 00:15:50.060
And in the next phase of the next
step of our Just Draw sample,

00:15:50.060 --> 00:15:53.790
I have put in the code
that shows how to use it.

00:15:53.890 --> 00:15:57.800
The good news is HITimDraw text
box has an extra parameter.

00:15:58.020 --> 00:16:01.610
It's called orientation that
allows you to use it in both

00:16:02.080 --> 00:16:04.530
coordinate system orientations.

00:16:04.580 --> 00:16:06.530
It makes it convenient.

00:16:06.610 --> 00:16:11.900
The bad news is you cannot
completely control... Well,

00:16:11.920 --> 00:16:14.710
you can, and that's what I'm doing
actually in the code,

00:16:14.800 --> 00:16:18.580
but with bad consciousness,
with embarrassment.

00:16:18.830 --> 00:16:23.130
Because the only way to get the font
and size that you really want is to

00:16:23.130 --> 00:16:25.490
specify it through a graph board.

00:16:25.580 --> 00:16:27.580
So that's on the other side.

00:16:28.280 --> 00:16:34.150
The benefit is you have symbolic virtual
font ID values in HITimDraw text box,

00:16:34.190 --> 00:16:39.380
which are the right way to
go for the completely high

00:16:39.380 --> 00:16:42.020
resolution screen future and so on.

00:16:42.140 --> 00:16:46.500
And to be completely in line with
the general look and feel of the

00:16:46.500 --> 00:16:49.010
UI if somehow the theme changes.

00:16:49.020 --> 00:16:53.390
And then finally, you know,
ATSUI is the right...

00:16:53.730 --> 00:16:57.350
This is the gold standard
of doing text on the MacÂ OS.

00:16:57.670 --> 00:16:59.410
You get everything.

00:16:59.470 --> 00:17:02.270
And if you look at the last line,
you will understand why

00:17:02.270 --> 00:17:05.490
I'm emphasizing so much the
coordinate flipping all in back.

00:17:05.600 --> 00:17:11.670
Atsui expects you to use a coordinate
system that is native to Quartz that

00:17:11.810 --> 00:17:14.670
has the origin at the bottom left.

00:17:14.800 --> 00:17:18.880
We should go back and look at it in code.

00:17:18.880 --> 00:17:21.620
This will be faster now.

00:17:25.890 --> 00:17:29.980
It's, of course, prepared already.

00:17:30.060 --> 00:17:32.900
So I just walk you through a little bit.

00:17:33.490 --> 00:17:38.300
And I have a little bit more
bells and whistles in here.

00:17:38.360 --> 00:17:42.660
You see we want to flip between
various ways of drawing text,

00:17:42.680 --> 00:17:48.270
either the CG context show text
or the HI theme or the ATSUI mode.

00:17:48.710 --> 00:17:54.260
And then we flip back and forth between
using HI view coordinates or not.

00:17:54.900 --> 00:18:17.830
And a global that's being set in
a little key handler that I added.

00:18:17.830 --> 00:18:17.830
Depending on where I hit the keyboard,
we select one or the other.

00:18:17.830 --> 00:18:17.830
And then when we just draw
something from before,

00:18:17.830 --> 00:18:17.830
it gets called in the same way.

00:18:17.830 --> 00:18:17.830
But if we decided not
to use HIVU coordinates,

00:18:17.830 --> 00:18:17.830
then we do this.

00:18:18.010 --> 00:18:21.660
This additional transform on
the CTM to play everything,

00:18:21.720 --> 00:18:24.000
all our drawing in the native.

00:18:24.990 --> 00:18:27.600
And then there is some additional
thing which you will find in the

00:18:27.600 --> 00:18:30.300
comments and we don't have time
here to go through everything.

00:18:30.300 --> 00:18:34.020
I just run it and...

00:18:34.680 --> 00:18:35.560
through.

00:18:35.600 --> 00:18:40.320
Now the extra thing is that the
title bar shows the current settings.

00:18:40.320 --> 00:18:43.830
Here we have show text
with HIV coordinates.

00:18:43.830 --> 00:18:48.970
I can flip back to the draw string
and forth and you see that the text

00:18:48.970 --> 00:18:54.140
is not being rendered in precisely
the same way and that the diagonal

00:18:54.140 --> 00:18:56.920
line is either anti-aliased or not.

00:18:57.040 --> 00:18:57.520
Okay.

00:18:57.520 --> 00:19:03.390
And then you can flip through and
use hithin draw text with or without,

00:19:03.390 --> 00:19:07.210
sorry,
with or without the HIV coordinates

00:19:07.250 --> 00:19:09.010
and there's no change.

00:19:10.450 --> 00:19:12.300
Why is there no change?

00:19:12.300 --> 00:19:16.120
Well, because I spent hours and
hours to try to get it right.

00:19:17.610 --> 00:19:19.260
And that's it for me.

00:19:19.380 --> 00:19:26.620
The overview at the beginning was about
handing it off to Ted Jucevic now.

00:19:27.010 --> 00:19:30.040
So please welcome Ted.

00:19:30.040 --> 00:19:30.040
Where is he?

00:19:35.250 --> 00:19:37.240
Thank you, Joseph.

00:19:37.330 --> 00:19:40.290
And you're going to need slides, right?

00:19:40.340 --> 00:19:43.070
Let's go back to the slides real quick.

00:19:43.760 --> 00:19:46.290
All right, so my name is Ted Jusovic.

00:19:46.360 --> 00:19:49.570
I'm one of the DTS engineers,
as Joseph described,

00:19:49.690 --> 00:19:55.370
and I've had actually quite a few
questions from people transitioning

00:19:55.510 --> 00:19:57.990
from QuickDraw to Quartz.

00:19:58.260 --> 00:19:59.910
There I am.

00:20:00.180 --> 00:20:03.880
One of the things I've found is a lot of
people are trying to do it incrementally,

00:20:03.920 --> 00:20:07.050
and it seems like what people are
actually trying to do is they're

00:20:07.170 --> 00:20:11.120
going first to Quartz and then
they're moving their code to HIV use.

00:20:11.180 --> 00:20:13.820
And one of the things I've found is
it's actually easier if you first

00:20:13.970 --> 00:20:18.850
transition to HIV use because then your
coordinates are still in the same area,

00:20:19.110 --> 00:20:21.360
you know, it's all real easy that way.

00:20:21.400 --> 00:20:25.170
And then you make your transition
to Quartz if you're going to do

00:20:25.180 --> 00:20:29.270
it incrementally or just do it
all at once and just save yourself

00:20:29.370 --> 00:20:32.610
the hassle of going partially.

00:20:32.710 --> 00:20:38.920
So what I'm going to be showing
is the Carbon CG compositor.

00:20:38.930 --> 00:20:41.190
It's a sample that's kind of
a compilation of a bunch of

00:20:41.190 --> 00:20:42.700
DTS incidents that I've gotten.

00:20:42.700 --> 00:20:49.890
Essentially, I drag in some images,
adjust the image translucency,

00:20:49.890 --> 00:20:55.580
maybe select a masking color,
and so like I'll select a pixel and

00:20:55.580 --> 00:21:01.740
it'll mask out all the pixels that have
a color that's similar to that one.

00:21:01.760 --> 00:21:06.840
And then I can lay images on
top of each other and then drag

00:21:06.840 --> 00:21:09.260
out the results to the finder.

00:21:09.730 --> 00:21:13.560
So what is this going to show us?

00:21:13.600 --> 00:21:19.400
Well, I'm using cgImageSource and
cgImageDestination to bring

00:21:19.400 --> 00:21:22.520
image files in and save them out.

00:21:22.700 --> 00:21:27.230
Cool thing about this is it works
really well with the Pasteboard APIs.

00:21:27.420 --> 00:21:31.410
They both use MIME types,
and it also makes it easy for me

00:21:31.410 --> 00:21:35.510
to just drag in any image source
and not have to care about it.

00:21:35.610 --> 00:21:41.090
As long as cgImageSource supports it,
I automatically get it for free.

00:21:41.230 --> 00:21:43.620
And down the road,
when more image sources

00:21:43.620 --> 00:21:46.330
are actually added,
I'll get those for free.

00:21:46.520 --> 00:21:48.870
The same thing when I'm
dragging out to the system.

00:21:48.900 --> 00:21:52.520
All I have to do is specify
a MIME type and a file name,

00:21:52.560 --> 00:21:59.020
and it'll convert my images
automatically to that image format.

00:21:59.640 --> 00:22:02.590
We're going to talk about
adjusting the translucency.

00:22:02.600 --> 00:22:05.740
There's two kinds of translucency
that we're going to be talking about.

00:22:05.850 --> 00:22:10.320
One is the alpha of the entire image,
and so I'll be adjusting

00:22:10.320 --> 00:22:15.240
that with a slider and then
compositing that over other images.

00:22:15.270 --> 00:22:21.790
And then also creating translucency by
creating an image with masking colors.

00:22:21.900 --> 00:22:25.100
And then I'm also going to
talk about color spaces.

00:22:25.380 --> 00:22:30.990
The really cool thing about color spaces
is it makes color matching just easy.

00:22:30.990 --> 00:22:32.990
It does all the color sync for you.

00:22:33.670 --> 00:22:40.490
Whenever you're drawing in Quartz,
your colors and your destination have

00:22:40.490 --> 00:22:42.800
a color profile that go with them.

00:22:42.820 --> 00:22:44.850
And so if, say,
you're drawing with a color

00:22:45.000 --> 00:22:48.120
that's different from the color
profile that you're drawing to,

00:22:48.120 --> 00:22:50.760
it will actually do
the conversion for you.

00:22:51.900 --> 00:22:54.580
The one thing, though,
is you want to stay away from

00:22:54.580 --> 00:22:58.210
device color spaces because those
essentially mean that you know better

00:22:58.220 --> 00:23:01.960
than the system what colors you need,
and you'll actually, most likely,

00:23:01.960 --> 00:23:04.820
you'll end up with colors
that you're not expecting.

00:23:06.650 --> 00:23:09.920
Going back to the image
source and image destination,

00:23:10.010 --> 00:23:14.980
you don't have to use QuickTime for that.

00:23:14.980 --> 00:23:14.980
And then also with the alpha,

00:23:15.690 --> 00:23:18.190
Alpha is easy with Quartz.

00:23:18.380 --> 00:23:24.170
You essentially get it for free and
almost have to just be aware of it.

00:23:24.550 --> 00:23:28.220
I'm also going to talk about using
some off-screen drawing spaces.

00:23:28.220 --> 00:23:32.250
I'm using CG bitmap context.

00:23:32.350 --> 00:23:36.530
One thing to be aware of is that
when you're using an off-screen

00:23:36.530 --> 00:23:40.740
bitmap like a CG context,
its orientation is different from

00:23:40.780 --> 00:23:42.410
the current HIVU orientation.

00:23:42.420 --> 00:23:45.940
So if you're going to be
compositing that into your HIVU,

00:23:45.990 --> 00:23:48.870
you have to do the flip
like Joseph talked about.

00:23:49.080 --> 00:23:51.820
I'm also going to be talking
about creating images from it.

00:23:51.900 --> 00:23:56.420
That's essentially like the copy bits,
and then using the context to

00:23:56.420 --> 00:24:00.760
scale the images if needed,
and create ones with

00:24:00.760 --> 00:24:03.020
the coordinates I want.

00:24:03.170 --> 00:24:09.450
It turns out that I actually
do have to use a region.

00:24:09.460 --> 00:24:14.400
I get back from HIVU, I get a shape,
an HI shape,

00:24:14.430 --> 00:24:18.560
that I have to convert into a
region to show the drag highlight.

00:24:18.700 --> 00:24:22.580
So there's a few APIs that,
while they're deprecated,

00:24:22.580 --> 00:24:24.260
you still have to use.

00:24:24.260 --> 00:24:29.450
But if you've noticed in Tiger,
there's a lot less of those APIs.

00:24:29.460 --> 00:24:32.350
And then going forward,
we'll even have less of those

00:24:32.390 --> 00:24:36.700
APIs that you still have to use,
even though they're still deprecated.

00:24:36.880 --> 00:24:41.490
And then I'm just going to talk
briefly about premultiplication.

00:24:41.510 --> 00:24:46.260
If you create a CG bitmap context,
you own the bits with it.

00:24:46.260 --> 00:24:48.220
This is an off-screen bitmap context.

00:24:48.330 --> 00:24:52.480
But one thing to be aware of is if
your bitmap context has alpha in it,

00:24:52.690 --> 00:24:57.660
and it's not just a mask,
those bits will be premultiplied alpha.

00:24:57.660 --> 00:25:00.900
And so if you want to get to those bits,
you're going to have to un-premultiply

00:25:01.070 --> 00:25:05.220
them before you manipulate them
and then premultiply them back.

00:25:05.220 --> 00:25:08.750
And I have a function that I can
show you that does exactly that.

00:25:09.280 --> 00:25:11.510
So let's actually look at this sample.

00:25:11.630 --> 00:25:15.570
And you'll have to get the sample
after-- it'll be available on

00:25:15.570 --> 00:25:18.020
our web sometime next week.

00:25:18.090 --> 00:25:20.200
It didn't quite make the big drop.

00:25:20.290 --> 00:25:22.490
So actually, if we could switch to
the other demo machine,

00:25:22.490 --> 00:25:24.490
demo 2.

00:25:29.050 --> 00:25:33.360
So let me just actually show
you what I'm talking about.

00:25:33.570 --> 00:25:35.460
So this is my application.

00:25:35.460 --> 00:25:39.020
It's a simple application
for dragging stuff in.

00:25:39.090 --> 00:25:41.730
And let me just drag in--

00:25:43.430 --> 00:25:44.400
I'm going to show you an image.

00:25:44.400 --> 00:25:50.560
This is Times Square,
the Rockefeller Center.

00:25:50.560 --> 00:25:53.640
And let me just select a masking color.

00:25:53.660 --> 00:26:00.220
So essentially, I just selected a pixel,
and it decided that anything

00:26:00.290 --> 00:26:06.560
that was similar to that pixel,
and I set up a kind of a masking range,

00:26:06.640 --> 00:26:08.290
it went and made essentially translucent.

00:26:08.290 --> 00:26:08.290
But I actually want the full

00:26:08.330 --> 00:26:11.500
I have a picture for my background,
so let me drag in a different one.

00:26:11.500 --> 00:26:13.610
Let me paint this one.

00:26:14.110 --> 00:26:16.350
And that composited to the background.

00:26:16.460 --> 00:26:19.020
And at the same time,
I'm compositing this to what

00:26:19.020 --> 00:26:23.080
I'm calling is my scratch pad,
which is my off-screen bitmap context.

00:26:23.080 --> 00:26:26.670
I'm kind of layering stuff, too.

00:26:26.830 --> 00:26:30.630
So let me bring in the original picture.

00:26:31.240 --> 00:26:34.580
And you can see over here,
I got this slider to adjust

00:26:34.620 --> 00:26:37.380
the translucency of the
picture that I'm overlaying.

00:26:37.500 --> 00:26:40.830
And that's actually--
it's real-- like I said,

00:26:40.830 --> 00:26:42.020
it's real easy in Quartz.

00:26:42.070 --> 00:26:45.440
You get that kind of stuff for free.

00:26:45.520 --> 00:26:49.850
And then I can go ahead and select,
let's say--

00:26:51.550 --> 00:26:55.540
And you can see the water from
the other image showing through.

00:26:55.540 --> 00:27:00.650
And Quartz is mostly doing
this all for me for free.

00:27:00.670 --> 00:27:04.590
I don't have to go through like
you guys did with QuickDraw and

00:27:04.590 --> 00:27:09.180
kind of simulate alpha in that
unused area of a 32-bit pixel.

00:27:09.180 --> 00:27:12.770
So it makes it really easy.

00:27:12.770 --> 00:27:16.130
And then, of course,
now I've created an image,

00:27:16.130 --> 00:27:16.130
dragging it out.

00:27:16.630 --> 00:27:17.840
And I don't know if you can see it.

00:27:17.840 --> 00:27:26.480
I actually have a border around this
image that I used when I drew this HIVU.

00:27:27.550 --> 00:27:31.320
You really can't see it on the stage.

00:27:31.340 --> 00:27:33.440
But I'm actually going to remove that.

00:27:33.440 --> 00:27:38.010
And the reason is because I've
drawn the border in the HIVU.

00:27:38.090 --> 00:27:42.680
And when I'm creating my drag image,
I'm asking the HIVU for its image.

00:27:42.680 --> 00:27:47.200
And so it turns out that border is
coming out along with my drag image.

00:27:47.200 --> 00:27:49.850
And instead of that,
what I'm going to do is create

00:27:49.850 --> 00:27:56.140
my drag image from my original
source off-screen bitmap.

00:27:56.850 --> 00:27:58.760
So enough showing.

00:27:58.760 --> 00:28:01.090
Let's actually get to the code.

00:28:04.550 --> 00:28:10.300
So, like I said, the first step, really,
if you're going to do it incrementally,

00:28:10.320 --> 00:28:15.600
go to the HIVU stuff.

00:28:15.600 --> 00:28:16.680
And then if you're going
to do it all at once,

00:28:16.680 --> 00:28:16.680
just go straight HIVU and...

00:28:20.780 --> 00:28:25.780
So let me look at my Draw Event Handler.

00:28:26.000 --> 00:28:27.910
And essentially,
I've kind of organized things.

00:28:27.960 --> 00:28:30.780
I've got my HIView files.

00:28:30.780 --> 00:28:33.310
These are the ones that have
to do with HIView and events,

00:28:33.320 --> 00:28:34.270
event handling.

00:28:34.270 --> 00:28:38.360
And then I've got my drag-and-drop
files that drag and drop,

00:28:38.370 --> 00:28:39.990
and then my CG files.

00:28:39.990 --> 00:28:44.870
And let's go to this Composite
Images in View Draw Event Handler.

00:28:44.890 --> 00:28:47.920
It's a long name,
but I'm trying to make it

00:28:47.920 --> 00:28:50.570
explicit exactly what it does.

00:28:52.010 --> 00:28:58.140
This is something that's
called by HIToolbox.

00:28:58.140 --> 00:29:00.580
The cool thing about this
is I just tell HIToolbox,

00:29:00.580 --> 00:29:03.620
you need updating, and then it'll call
my draw event handler,

00:29:03.620 --> 00:29:05.220
and I can draw my content.

00:29:05.220 --> 00:29:14.390
I stored in my window,
using the set property, get property, my

00:29:14.720 --> 00:29:21.700
My bitmap context, my overlay picture,
and then a mass picture.

00:29:21.720 --> 00:29:23.420
And then I also store the alpha.

00:29:23.420 --> 00:29:30.720
And so I get those
properties in my HIV draw,

00:29:30.720 --> 00:29:30.720
and I go down and--

00:29:30.970 --> 00:29:33.890
Right here,
you notice I have to actually flip

00:29:34.080 --> 00:29:38.570
the orientation because the bitmap
context I'm pulling my image data

00:29:38.590 --> 00:29:41.800
out of is a CG bitmap context,
so it has the inverted

00:29:42.270 --> 00:29:44.510
orientation from the normal HIVU.

00:29:44.510 --> 00:29:49.390
And then I come down here.

00:29:52.600 --> 00:30:00.240
I composite my image to the
on-screen context with the alpha

00:30:00.240 --> 00:30:02.060
that I've actually selected.

00:30:02.060 --> 00:30:05.970
The first thing-- so let me actually go--

00:30:06.800 --> 00:30:08.440
And look at that function itself.

00:30:08.440 --> 00:30:11.460
And it's actually pretty straightforward.

00:30:11.460 --> 00:30:18.210
I saved my graphics state because when
I apply an alpha to a graphics context,

00:30:18.210 --> 00:30:18.210
that

00:30:18.590 --> 00:30:20.380
"It's sticky.

00:30:20.410 --> 00:30:24.770
But what you can do is use
save state and restore state to

00:30:25.180 --> 00:30:32.060
So that you can actually draw the image
with the alpha and then remove that alpha

00:30:32.060 --> 00:30:36.380
parameter from the context so that future
images that you draw to that context

00:30:36.380 --> 00:30:38.590
won't be affected by that setting.

00:30:38.690 --> 00:30:41.820
And so right here,
I set the alpha for the

00:30:41.820 --> 00:30:44.060
image that I want to draw in.

00:30:44.270 --> 00:30:50.760
I draw the image and
then restore the state.

00:30:53.000 --> 00:30:57.080
So in my-- when I'm doing
some setup in the HIVU,

00:30:57.170 --> 00:30:59.530
I create my off-screen context.

00:30:59.620 --> 00:31:03.970
I have initialized Windows properties.

00:31:04.200 --> 00:31:08.370
So in my-- when I'm doing
some setup in the HIVU,

00:31:08.470 --> 00:31:10.890
I create my off-screen context.

00:31:10.890 --> 00:31:15.280
I have initialized Windows properties.

00:31:34.200 --> 00:31:35.500
I have this function.

00:31:35.520 --> 00:31:38.600
Normally, it would return me a pointer
to the memory because,

00:31:38.600 --> 00:31:40.320
you know,
just like with an off-screen gWorld,

00:31:40.320 --> 00:31:46.240
you have-- you know,
you allocate the memory in this case.

00:31:46.370 --> 00:31:49.340
At some point,
I'll have to free up that memory,

00:31:49.380 --> 00:31:52.140
just like with an off-screen gWorld.

00:31:52.290 --> 00:31:55.830
Nice thing about it is actually
there's a function in here,

00:31:55.890 --> 00:32:02.100
and this is in my window closing handler,
where I can actually--

00:32:04.200 --> 00:32:09.300
Let's see, clean up the mask,
clean up the overlay image.

00:32:09.310 --> 00:32:14.740
I can get the data actually from the
pointer to my data from the context.

00:32:14.740 --> 00:32:21.500
So if you don't have a place that
you can actually save it off,

00:32:21.500 --> 00:32:28.730
you can get to it later and then free
up the pointer or the memory that you

00:32:28.730 --> 00:32:28.730
allocated for the off-screen bitmap.

00:32:30.730 --> 00:32:35.600
Let me just go in real
quick and just point out the

00:32:35.740 --> 00:32:40.080
premultiplied code I have in here.

00:32:40.080 --> 00:32:42.330
This is just kind of as an example.

00:32:42.580 --> 00:32:47.520
I didn't need it for this sample,
but I wanted to include it in.

00:32:47.520 --> 00:32:53.500
I'm assuming in my floats,
the first is the red, green, blue,

00:32:53.530 --> 00:32:55.640
and then the alpha.

00:32:55.640 --> 00:32:59.800
One thing to be aware of is
when you have lossy images

00:33:00.060 --> 00:33:02.690
and you're un-premultiplying,

00:33:02.860 --> 00:33:06.330
you know,
they do a lossy data conversion.

00:33:06.340 --> 00:33:12.980
And so while it's not technically legal,
it's possible that a component value,

00:33:12.980 --> 00:33:15.860
say, like the red value,
would actually have a value

00:33:15.860 --> 00:33:17.280
that's larger than my alpha.

00:33:17.280 --> 00:33:21.080
But the way you get to a
premultiplied pixel is you multiply

00:33:21.080 --> 00:33:22.400
the component by the alpha.

00:33:22.400 --> 00:33:28.220
So if the alpha is, say, 0.5,
even if the pixel for the red was 1,

00:33:28.220 --> 00:33:30.950
it's got to be 0.5 after
it's premultiplied.

00:33:30.960 --> 00:33:33.690
And if it's not like that,
I just go through and

00:33:33.690 --> 00:33:36.530
clean it up right here.

00:33:38.500 --> 00:33:43.210
And then to un-premultiply,
it's just dividing by the alpha.

00:33:43.240 --> 00:33:47.260
And you get your original
RGB pixel values.

00:33:47.260 --> 00:33:53.090
And then you just save off your alpha
for later if you want to premultiply.

00:33:53.420 --> 00:34:01.320
So let's go talk about the drag and
drop and how easy the CG image source

00:34:01.340 --> 00:34:05.770
and image destination makes it for me.

00:34:07.170 --> 00:34:11.350
I have my drag-receive handler,
and this is something that HIToolbox,

00:34:11.350 --> 00:34:13.730
you know, it's very easy to set up.

00:34:13.800 --> 00:34:17.800
You can just set it up for your view,
and it'll call your drag-receive handler.

00:34:17.800 --> 00:34:22.390
And I have this function create
overlay image from pasteboard.

00:34:23.760 --> 00:34:27.880
And so what I'm doing
in here is actually,

00:34:27.890 --> 00:34:30.630
since I'm dragging in files,

00:34:31.460 --> 00:34:36.020
All I'm looking for is
this public file.url type.

00:34:36.020 --> 00:34:38.350
There's a constant also
that goes along with it,

00:34:38.350 --> 00:34:43.170
but this one makes it kind of a
little easier to see on stage.

00:34:44.130 --> 00:34:47.650
And then I go down here
and I have this function,

00:34:47.650 --> 00:34:50.880
create CG image from URL.

00:34:51.400 --> 00:34:55.340
So what I do is I get the URL that
was dragged in and then I just say,

00:34:55.590 --> 00:34:56.920
create an image from that.

00:34:56.930 --> 00:35:01.070
Now, I don't know if that file actually
has an image or not in it,

00:35:01.070 --> 00:35:05.090
but I figure if somebody dragged in,
let's give it a try.

00:35:05.370 --> 00:35:09.090
And in my function, createCgImageFromURL,
it's actually pretty simple and

00:35:09.160 --> 00:35:10.650
straightforward in how it works.

00:35:10.680 --> 00:35:16.880
Three sides lost it, though.

00:35:24.070 --> 00:35:26.760
So I create my image source with the URL.

00:35:26.760 --> 00:35:32.260
And then I can check the
status of that image source.

00:35:32.520 --> 00:35:36.700
And that will tell me if there's
actually an image in it or not.

00:35:36.720 --> 00:35:42.010
If I actually look at the values,
the other values I could get returned,

00:35:42.140 --> 00:35:44.600
essentially they're all errors.

00:35:45.240 --> 00:35:48.430
So if that returns successfully,
then I know for a fact that

00:35:48.430 --> 00:35:49.460
I actually have an image.

00:35:49.460 --> 00:35:51.380
And so I can just create my image.

00:35:51.380 --> 00:35:54.020
And all I'm asking for is the first one.

00:35:54.020 --> 00:35:57.770
In theory, an image file could have
many different images in it.

00:35:57.860 --> 00:35:59.920
But I'm just asking for the first one.

00:35:59.980 --> 00:36:02.480
And it's zero index space.

00:36:02.480 --> 00:36:05.240
And I just release my image
source and return my image.

00:36:05.280 --> 00:36:09.130
And that will work with
any image file type.

00:36:09.280 --> 00:36:12.610
So you don't have to go
back to QuickTime to use it.

00:36:13.040 --> 00:36:15.640
You can just use CG image source.

00:36:15.660 --> 00:36:19.050
And you can load JPEG, TIFF,
whatever I drag in.

00:36:21.660 --> 00:36:26.810
So, and then conversely,
when I'm going the other way,

00:36:27.000 --> 00:36:30.760
Let me get back to my sample.

00:36:30.800 --> 00:36:34.980
When I'm dragging out to the finder,
I essentially create a promise.

00:36:35.060 --> 00:36:39.920
And then in my promise handler,
I go and create.

00:36:40.370 --> 00:36:43.260
"The actual file that's going out.

00:36:43.290 --> 00:36:46.580
In this thing,
I'm actually cheating a little bit

00:36:46.630 --> 00:36:49.890
because I have the file name in here.

00:36:49.890 --> 00:36:52.790
It's kind of hard coded,
so I just kind of overwrite

00:36:52.890 --> 00:36:55.780
the original file.

00:36:55.780 --> 00:36:55.780
But

00:36:56.210 --> 00:37:01.990
All I do is I get from the pasteboard
the location that the drop occurred to.

00:37:02.010 --> 00:37:09.440
And then down here, FS.

00:37:14.310 --> 00:37:15.400
I get the URL graph.

00:37:15.500 --> 00:37:22.510
I'm missing my function
call up here on the screen.

00:37:22.750 --> 00:37:25.810
Write bitmap context
image of type to URL.

00:37:25.960 --> 00:37:30.290
So essentially what I'm doing is I'm
taking the contents of my bitmap and

00:37:30.290 --> 00:37:34.660
writing it to a URL using the type JPEG.

00:37:34.810 --> 00:37:36.850
And actually, you saw I created the JPEG.

00:37:36.870 --> 00:37:39.320
So just for kicks,
let me actually just go

00:37:39.320 --> 00:37:43.560
and convert this to TIFF,
and then let me go and

00:37:43.740 --> 00:37:46.610
take this type JPEG,

00:37:50.000 --> 00:38:06.900
[Transcript missing]

00:38:08.220 --> 00:38:09.320
Dun, dun, dun.

00:38:09.350 --> 00:38:10.580
Oh, and there's one more thing.

00:38:10.580 --> 00:38:14.120
I wanted to show you that HI,
handle track drag.

00:38:14.120 --> 00:38:17.540
This is the region thing.

00:38:18.000 --> 00:38:21.760
Essentially,
when I get back the highlight

00:38:21.760 --> 00:38:25.800
that I've actually gotten--

00:38:26.580 --> 00:38:29.420
The file I'm dragging in is a file that,
you know, it's a file.

00:38:29.420 --> 00:38:32.290
And so it will be accepted by the drag.

00:38:32.290 --> 00:38:34.880
I get...

00:38:35.090 --> 00:38:39.940
From my view, I get my shape of the view.

00:38:39.940 --> 00:38:43.120
And I need this to
show my drag highlight.

00:38:43.430 --> 00:38:46.280
Unfortunately,
ShowDragHighlight only takes a region.

00:38:46.350 --> 00:38:49.570
So what I can do is convert that
shape into a region and then

00:38:49.690 --> 00:38:51.840
call the old QuickDraw function.

00:38:51.840 --> 00:38:57.840
Let's see.

00:39:01.400 --> 00:39:04.190
Oh, yeah, and then one other thing.

00:39:04.590 --> 00:39:11.190
I talked about when I'm
dragging out to the Finder,

00:39:11.190 --> 00:39:11.190
I asked the system for--

00:39:11.290 --> 00:39:14.300
The Views image,
and it's actually right here.

00:39:14.330 --> 00:39:17.290
HIV, Create Offscreen Image.

00:39:17.510 --> 00:39:25.910
And that actually gets me the contents
of the HIV on the screen and creates

00:39:26.000 --> 00:39:30.910
an image for me that I can then use
as my drag image and stuff like that.

00:39:30.910 --> 00:39:30.910
Alternatively,
I can actually create my image

00:39:31.140 --> 00:39:32.890
All right, we've got new documentation,
too.

00:39:33.520 --> 00:39:39.900
From my actual data source.

00:39:40.020 --> 00:39:44.100
And I have this-- it's
kind of interesting.

00:39:44.120 --> 00:39:47.360
When you're setting your
drag image with a CG image,

00:39:47.450 --> 00:39:51.990
it actually uses the bounds of the image,
the actual pixel size of the image.

00:39:52.090 --> 00:39:57.640
So if you remember,
my context I created was 1024 x 1024.

00:39:57.720 --> 00:40:01.290
So if I just created a straight image
from that and used that as my drag image,

00:40:01.380 --> 00:40:04.160
all of a sudden,
I'd have this huge drag image coming

00:40:04.160 --> 00:40:07.500
out of this relatively small HIV.

00:40:07.590 --> 00:40:13.330
And so I use a function,
createCgImageWithBounds from

00:40:13.330 --> 00:40:17.280
bitmap context that I use to
essentially scale it down,

00:40:17.290 --> 00:40:20.760
but it could be used the
same way to scale things up.

00:40:21.230 --> 00:40:24.610
All I do is I create another
bitmap context with the

00:40:24.650 --> 00:40:27.020
size of the image I want.

00:40:27.060 --> 00:40:31.210
And then I just render
my image into that,

00:40:31.250 --> 00:40:34.090
create a new image from that bitmap,

00:40:35.990 --> 00:40:41.240
The temporary bitmap context,
release my context, free my bitmap data,

00:40:41.380 --> 00:40:42.720
and then return.

00:40:45.310 --> 00:40:50.540
The image I created that
has the new bounds and size.

00:40:51.930 --> 00:40:55.990
It just makes it much
better on the screen.

00:40:56.170 --> 00:40:57.420
So let me see.

00:40:57.420 --> 00:40:58.380
Let me make sure.

00:40:58.380 --> 00:41:00.850
I had a lot of things to cover,
and so I wanted to actually

00:41:01.480 --> 00:41:05.600
write down some notes to make
sure I didn't skip anything.

00:41:05.610 --> 00:41:07.600
And--

00:41:08.300 --> 00:41:08.550
Right.

00:41:08.780 --> 00:41:11.890
So the last thing I wanted to talk about,
and I'm actually going to just

00:41:12.010 --> 00:41:19.370
lightly cover this because Joseph is
going to cover it in more detail.

00:41:21.110 --> 00:41:25.730
is when I create my masking image,
essentially what I have to

00:41:25.730 --> 00:41:27.120
do is I have to render it.

00:41:27.120 --> 00:41:30.070
Let me go down to the actual one.

00:41:30.080 --> 00:41:33.130
I have to do a little bit of math,
you know,

00:41:33.270 --> 00:41:37.100
because my view has a limited size,
and then my CG bitmap

00:41:37.100 --> 00:41:39.770
context I'm actually,
you know,

00:41:39.770 --> 00:41:44.190
can hold my data is 1,024 by 1,024.

00:41:44.300 --> 00:41:47.610
So I have to do a little bit of
math to figure out exactly where in

00:41:47.610 --> 00:41:49.720
that bitmap context I have my data.

00:41:51.030 --> 00:41:55.430
And then I render it to a--

00:41:55.570 --> 00:41:59.500
A bitmap context that
doesn't have any alpha.

00:41:59.520 --> 00:42:01.990
The reason for this is
you can't create a mask,

00:42:01.990 --> 00:42:07.330
an image with masking colors,
from an image that has any kind of alpha,

00:42:07.330 --> 00:42:12.520
has a mask associated,
or masking colors associated with it.

00:42:14.370 --> 00:42:19.960
So, um, and then I have a fun-- once
I create that bitmap context,

00:42:20.070 --> 00:42:22.000
I can, uh,

00:42:23.750 --> 00:42:27.130
get the pixel data from
that bitmap context.

00:42:27.150 --> 00:42:31.770
And this is a pixel data for the
actual pixel that I selected.

00:42:31.900 --> 00:42:34.420
I have a function that goes
through and creates a mask,

00:42:34.420 --> 00:42:37.780
it kind of just creates a range
based around those pixels because

00:42:37.780 --> 00:42:41.430
I'm actually using live pictures,
and of course every pixel is

00:42:41.520 --> 00:42:43.340
just right next to each other.

00:42:43.340 --> 00:42:45.170
It's a little different
in the real world.

00:42:45.340 --> 00:42:47.470
They're not all the same.

00:42:47.560 --> 00:42:53.140
And then I just use a temporary
image I created from that context,

00:42:53.160 --> 00:42:55.380
and I create my new image from that.

00:42:55.440 --> 00:42:57.980
And that's all you have to do
to essentially mask out colors.

00:42:57.980 --> 00:43:01.180
And so you get the blue
screen effect for free,

00:43:01.190 --> 00:43:05.290
and Quartz will provide that for you.

00:43:05.870 --> 00:43:09.350
So let's see, I went through,
I made a couple changes.

00:43:09.410 --> 00:43:12.860
So let me just go ahead
and do a build right here.

00:43:12.860 --> 00:43:15.390
And with any luck--

00:43:15.810 --> 00:43:19.680
I didn't actually change
anything I didn't expect to.

00:43:19.720 --> 00:43:25.710
And so now,
let me just drag in this image.

00:43:28.330 --> 00:43:31.330
Let me start with this one.

00:43:31.480 --> 00:43:35.060
Paint this one to the background,
paint this one in,

00:43:35.120 --> 00:43:38.840
and now we got a little bit of
water in Madison Square Gardens and

00:43:38.840 --> 00:43:40.290
some palm trees and stuff.

00:43:40.300 --> 00:43:42.120
Nothing they would expect.

00:43:42.120 --> 00:43:50.880
I can still do the translucency
with that masked image.

00:43:50.880 --> 00:43:50.890
Paint it,
and then when I drag it to my desktop,

00:43:51.500 --> 00:43:52.740
I created TIFF.

00:43:52.740 --> 00:43:57.870
Now, the finder could be fooled
because it could be a JPEG image

00:43:58.080 --> 00:44:00.790
with a TIFF extension because
I changed the name of it.

00:44:00.890 --> 00:44:04.770
So just to make sure,
let's bring it up in preview.

00:44:04.770 --> 00:44:08.570
And you will see this is
actually a TIFF document.

00:44:08.650 --> 00:44:10.950
It's not just TIFF by name.

00:44:12.220 --> 00:44:16.670
So with that,
I've actually shown you my code.

00:44:16.800 --> 00:44:21.820
And these were the kind of issues
that I've been running into in DTS.

00:44:21.820 --> 00:44:27.770
And again, let me just reiterate,
make your transition to the HI Toolbox.

00:44:27.770 --> 00:44:30.110
It makes things much easier.

00:44:30.140 --> 00:44:34.490
And then do your transition
to CG or do it all at once.

00:44:34.490 --> 00:44:34.490
And then

00:44:36.030 --> 00:44:40.540
You can get the features and
the values from the CG for free.

00:44:40.540 --> 00:44:44.210
So let's go back to
the slides real quick.

00:44:46.560 --> 00:44:50.750
So like I said, drag and drop,
CG image source and image

00:44:50.860 --> 00:44:55.330
destination for dragging images
in and out makes it really easy,

00:44:55.560 --> 00:44:58.720
real nice,
and work well with the Pasteboard.

00:44:58.720 --> 00:45:01.700
You don't have to use
Quicktime again for that.

00:45:01.790 --> 00:45:02.870
Copying image data.

00:45:03.160 --> 00:45:07.420
You can just create images
from bitmap contexts.

00:45:07.420 --> 00:45:10.740
If you wanted to just get a
portion of say of an image,

00:45:10.740 --> 00:45:17.020
you can just adjust the transform so that
when you draw into your bitmap context,

00:45:17.050 --> 00:45:19.740
you would actually just draw the
portion of the image that you want.

00:45:19.840 --> 00:45:23.710
There's also subsampling.

00:45:23.700 --> 00:45:27.230
"Color Management is easy.

00:45:27.260 --> 00:45:30.420
I didn't have to do anything
with ColorSync in there.

00:45:30.420 --> 00:45:37.710
When ImageSource brought in my image,
it actually figured out what the

00:45:38.000 --> 00:45:41.560
"The color space and the
profile that went with it.

00:45:41.630 --> 00:45:45.280
And so even if I had multiple
images from multiple profiles,

00:45:45.420 --> 00:45:48.410
the color correction
is automatic for me."

00:45:51.200 --> 00:45:53.730
And so with that,
let me hand this back to Joseph,

00:45:53.750 --> 00:45:56.680
and he'll finish it up with
the mouse tracking demo.

00:45:56.680 --> 00:45:58.780
Thank you.

00:45:58.780 --> 00:46:01.270
Thank you, Ted.

00:46:04.420 --> 00:46:06.900
Why mouse tracking?

00:46:07.070 --> 00:46:12.100
When I started thinking
about a suitable subject for

00:46:12.780 --> 00:46:18.300
For a sample code for this session,
I wanted something nostalgic

00:46:18.300 --> 00:46:24.260
that went back to '83,
'84, something really QuickDrawish.

00:46:24.290 --> 00:46:31.700
And I remembered how fascinated those of
us who were already born at that time.

00:46:32.450 --> 00:46:37.660
How fascinated we were to track
the mouse and do freehand drawing.

00:46:37.790 --> 00:46:39.500
So that's what I wanted to do.

00:46:39.570 --> 00:46:43.080
First, I had to figure out how
to do it in QuickDraw.

00:46:43.500 --> 00:46:46.670
And we will look at it in a way.

00:46:47.170 --> 00:46:50.820
Then I found a reason why I needed
to talk about it here because we are

00:46:50.820 --> 00:46:53.340
again juggling around with coordinates.

00:46:53.470 --> 00:46:56.290
The mouse tracking loop,
the way it's set up,

00:46:56.470 --> 00:47:01.460
requires that we convert from global
coordinates to local coordinates.

00:47:01.500 --> 00:47:08.550
And it's until Tiger, before Tiger,
it wasn't quite obvious how to do

00:47:08.760 --> 00:47:12.640
that without using a QuickDraw call.

00:47:13.020 --> 00:47:17.010
So here we are,
and the HIPointConvert call is the

00:47:17.020 --> 00:47:18.550
one I want to bring to your attention.

00:47:18.550 --> 00:47:21.480
It's a tiger-only API,
but it's really convenient,

00:47:21.480 --> 00:47:24.520
and it's the right thing
to go about these things.

00:47:24.580 --> 00:47:29.090
Here is the mouse tracking loop,
and we will encounter it in various

00:47:29.090 --> 00:47:31.860
contexts over the rest of the session.

00:47:33.200 --> 00:47:38.850
I've wrapped the conversion
function from the global QuickDraw

00:47:38.850 --> 00:47:42.280
point to the local HIPoint.

00:47:42.280 --> 00:47:48.280
I've wrapped it up just to
take into account that we have

00:47:48.280 --> 00:47:53.520
a neat API solution in Tiger,
but a not-so-neat one before.

00:47:53.520 --> 00:47:56.840
And you look at the bottom.

00:47:56.840 --> 00:48:01.420
Throughout the loop,
we call HIPoSETNeedsDisplay,

00:48:01.420 --> 00:48:03.040
such while we are dragging.

00:48:03.200 --> 00:48:08.380
The HIVoSystem will just repaint
everything as we need it.

00:48:09.360 --> 00:48:15.180
So this loop here contains a polygon
because our freehand drawing,

00:48:15.180 --> 00:48:18.080
I just collected in a polygon
and redraw the polygon.

00:48:18.080 --> 00:48:20.660
That's the way to do it in QuickDraw.

00:48:20.700 --> 00:48:23.680
How would we replace this in Quartz?

00:48:23.680 --> 00:48:26.930
We have a CG path,
and we better use a mutable path

00:48:26.960 --> 00:48:29.600
because we are changing it all the time.

00:48:29.600 --> 00:48:31.900
We are building it up on the fly.

00:48:32.720 --> 00:48:38.160
I will show how to use
such a CG path in practice.

00:48:38.550 --> 00:48:45.200
Now, this CG path thing is
really fundamental for

00:48:45.590 --> 00:48:50.670
For many cases where you are wondering
how do I replace this in Quartz,

00:48:50.770 --> 00:48:54.690
it replaces obviously
things like polygons,

00:48:54.910 --> 00:48:58.670
but it replaces also regions,
region handles.

00:48:58.700 --> 00:49:04.570
In many cases where the region is
naturally represented by its outline.

00:49:04.580 --> 00:49:07.980
And in the other cases,
we will work with image masks.

00:49:07.980 --> 00:49:12.350
Ted already has spent some time on this,
and we will come back to this.

00:49:12.580 --> 00:49:17.130
It's a concept that's unavoidable
for any non-trivial work.

00:49:17.240 --> 00:49:20.700
So, get started with house tracking.

00:49:20.700 --> 00:49:24.130
And I need the first machine again,
please.

00:49:36.300 --> 00:49:41.130
Again, this is the second portion
you have on your sample code.

00:49:41.160 --> 00:49:44.440
And this time I have three variants.

00:49:44.460 --> 00:49:48.560
The QuickDraw variant, the first one,
let's first see how it goes.

00:49:50.370 --> 00:49:52.240
Yeah, that's what we wanted.

00:49:52.350 --> 00:49:53.450
See?

00:49:53.470 --> 00:49:57.800
Now you can scribble around as much
as you like and find nice things.

00:49:58.180 --> 00:49:58.480
Okay.

00:49:58.480 --> 00:50:02.640
So there is not much to talk
about it because you have

00:50:02.810 --> 00:50:05.280
seen it on the slide already.

00:50:05.280 --> 00:50:07.440
Only one thing.

00:50:10.910 --> 00:50:17.780
We replace the view by view data to
have room for storing our private stuff,

00:50:17.780 --> 00:50:19.380
to hang it off of it.

00:50:19.380 --> 00:50:24.250
And this file here,
the mouse tracking view,

00:50:24.310 --> 00:50:27.630
is now as views should be done.

00:50:28.720 --> 00:50:32.580
See, this in our main,
it's again the main that you know

00:50:32.580 --> 00:50:36.510
as a default project in Xcode,
but here, once I have created the

00:50:36.650 --> 00:50:40.060
window from the nib,
I create a mouse tracking view.

00:50:40.060 --> 00:50:43.460
And this then is all done separately.

00:50:44.910 --> 00:50:47.670
The next step,
you already have had a sneak peek.

00:50:47.760 --> 00:50:51.300
I want to load an image that comes along.

00:50:51.300 --> 00:50:55.720
This is to replace the picked
resources that we used to add to

00:50:55.720 --> 00:50:58.890
an application and then load the
picked resource and draw a picture.

00:50:58.900 --> 00:51:00.520
So that's how we do it now.

00:51:00.520 --> 00:51:04.310
I could have used a couple lines for
image IO to make it even more flexible,

00:51:04.450 --> 00:51:07.930
but the idea is that these images,
they're part of our main bundle,

00:51:07.930 --> 00:51:11.450
so we know them, we know them by name,
and we know how to call.

00:51:11.450 --> 00:51:14.640
Here I have a PNG image.

00:51:14.800 --> 00:51:15.830
Thank you.

00:51:17.190 --> 00:51:20.180
And in order, because we still have
a lot of work to do,

00:51:20.180 --> 00:51:23.430
I promised to replace regions
and to replace CopyBits and

00:51:23.430 --> 00:51:29.890
CopyDeepMask and all this stuff,
I suggest we...

00:51:30.740 --> 00:51:35.680
You let me jump forward and avoid that
I dabble around in the code again.

00:51:35.870 --> 00:51:40.940
So here we replace this polygon
tracking and drawing by the CG path.

00:51:41.290 --> 00:51:45.340
You see I have made room for
the image as a background

00:51:45.850 --> 00:51:48.170
thing to make it less boring.

00:51:48.760 --> 00:51:51.580
And I have now, instead of the polygon,
a path.

00:51:51.610 --> 00:51:56.740
There's one thing I need to explain.

00:51:56.800 --> 00:52:00.560
There is the path applier.

00:52:00.600 --> 00:52:05.270
This is used here when I draw the view.

00:52:06.200 --> 00:52:20.100
[Transcript missing]

00:52:20.770 --> 00:52:24.910
and depending on one or the other images
that would show up upside down as well,

00:52:24.920 --> 00:52:27.160
but you know that already.

00:52:27.350 --> 00:52:36.730
So once I want to get the path drawn,
I don't have an API to, say,

00:52:36.730 --> 00:52:36.730
stroke the path.

00:52:36.770 --> 00:52:41.100
Because Quartz has a
current path in the context,

00:52:41.140 --> 00:52:44.370
and that's the path that's
used when I stroke it.

00:52:44.480 --> 00:52:48.840
So I somehow need to put this path,
which is an independent path,

00:52:48.940 --> 00:52:50.400
into the context.

00:52:50.400 --> 00:52:54.680
And the same thing,
we want to be generic and universal

00:52:54.680 --> 00:53:00.150
such that I can do whatever I want,
and my path applier only translates

00:53:00.150 --> 00:53:06.140
and carries the separate path over
into the current path in the context.

00:53:06.280 --> 00:53:08.170
And then I can do with
this path what I want.

00:53:08.330 --> 00:53:12.090
For example, stroke it.

00:53:12.090 --> 00:53:12.090
So the path applier

00:53:13.160 --> 00:53:16.100
Just gets,
it gets called for each path element.

00:53:16.100 --> 00:53:21.200
We know our path is a polygon we
only have move to and line to.

00:53:21.200 --> 00:53:22.690
And that's it.

00:53:22.690 --> 00:53:24.880
There's nothing else.

00:53:29.370 --> 00:53:31.770
Should I-- oh, yeah.

00:53:31.890 --> 00:53:35.400
Here's all this boilerplate code.

00:53:36.480 --> 00:53:43.050
I decided not to use the HIV framework
and to keep everything bare bones

00:53:43.050 --> 00:53:45.680
and to do all the legwork myself.

00:53:45.680 --> 00:53:48.130
So here you have all
the boilerplate code.

00:53:48.210 --> 00:53:52.660
Each time you instantiate a view,
you register the view,

00:53:52.660 --> 00:53:58.240
you tell it which events we are handling,
and we have hit test and control

00:53:58.240 --> 00:54:01.170
track in addition to the drawing.

00:54:01.200 --> 00:54:09.870
You can also use the initialize
function to create a new view.

00:54:11.000 --> 00:54:16.430
That's in the hand... That's
where we set up the image,

00:54:16.570 --> 00:54:19.120
load image from main bundle,
and then we keep it around.

00:54:21.690 --> 00:54:26.060
Okay, so this is supposed to work.

00:54:26.060 --> 00:54:30.870
I just picked any picture.

00:54:33.120 --> 00:54:37.670
The picture is positioned
at the bottom left here.

00:54:37.670 --> 00:54:40.530
And those with sharp eyes may
have seen that the reason is

00:54:40.670 --> 00:54:44.280
that my compiled conditional is
flipped to use CG coordinates.

00:54:44.360 --> 00:54:47.960
If I would, and that I,
the destination rectangle,

00:54:47.960 --> 00:54:50.780
I always set it off the origin 0, 0.

00:54:50.780 --> 00:54:56.990
If I would flip this to the
other coordinate system...

00:54:59.850 --> 00:55:04.360
Then, it would be at the top left.

00:55:06.470 --> 00:55:11.300
Now we still can drag around the
mouse and do some scribbling,

00:55:11.300 --> 00:55:14.040
and this gives us an idea.

00:55:17.200 --> 00:55:19.250
Okay, this, yeah, whatever.

00:55:19.260 --> 00:55:26.660
The next thing I want to do is put it in,
paint the background.

00:55:26.660 --> 00:55:29.850
White is just too white.

00:55:31.850 --> 00:55:33.810
Okay, this, yeah, whatever.

00:55:34.270 --> 00:55:41.290
The next thing I want to do is put it in,
paint the background.

00:55:41.400 --> 00:55:44.660
White is just too white.

00:55:50.810 --> 00:55:52.860
Okay, this, yeah, whatever.

00:55:52.860 --> 00:56:00.260
The next thing I want to do is put it in,
paint the background.

00:56:02.000 --> 00:56:30.400
[Transcript missing]

00:56:33.750 --> 00:56:35.760
Okay, this, yeah, whatever.

00:56:35.940 --> 00:56:40.950
The next thing I want to do is put it in,
paint the background.

00:56:41.780 --> 00:56:43.760
Here it comes.

00:56:43.910 --> 00:56:45.580
What's the color space name?

00:56:45.620 --> 00:56:48.150
KCG color space.

00:56:48.280 --> 00:56:49.500
Do we have one?

00:56:49.540 --> 00:56:51.620
Generic RGB.

00:56:51.620 --> 00:56:54.490
Xcode already knew what I wanted.

00:56:55.340 --> 00:57:01.470
And then we set CG context,
set fill color space.

00:57:07.800 --> 00:57:19.000
[Transcript missing]

00:57:19.180 --> 00:57:20.780
Not the RGB fill color anymore.

00:57:21.060 --> 00:57:24.010
Just set RGB fill color.

00:57:24.010 --> 00:57:27.610
And this color is something greenish.

00:57:37.280 --> 00:57:39.950
So green is the dominant thing.

00:57:40.050 --> 00:57:42.040
And of course, it's completely arbitrary.

00:57:42.050 --> 00:57:43.380
It doesn't matter.

00:57:43.410 --> 00:57:45.670
Just want to see how it looks.

00:57:45.690 --> 00:57:50.120
Now, we are going ahead and
drawing the picture again.

00:57:50.130 --> 00:57:57.340
Oh, here I simplified and only
made it with the HIVU system.

00:57:57.340 --> 00:58:01.190
And then we have some
other stuff here around.

00:58:01.190 --> 00:58:01.190
I don't have to change this too.

00:58:14.800 --> 00:58:22.990
In drawing the view,
I should not draw... Where is it?

00:58:30.300 --> 00:58:49.300
[Transcript missing]

00:58:50.770 --> 00:58:52.620
Yeah.

00:58:52.740 --> 00:58:55.450
So this was the point of
introducing a masked image.

00:58:55.500 --> 00:58:58.120
You see, in many cases,
what we want is we want to

00:58:58.220 --> 00:59:00.140
fill the whole background.

00:59:00.200 --> 00:59:02.950
We want to mask out the
background of an image.

00:59:02.990 --> 00:59:05.760
And how would we do that in QuickDraw?

00:59:05.760 --> 00:59:11.170
This is one of those problems,
one of those questions that has been

00:59:11.170 --> 00:59:11.170
asked over the last couple of years.

00:59:11.380 --> 00:59:13.640
With QuickDraw,
we would draw this picture

00:59:13.640 --> 00:59:16.480
into a one-bit off-screen.

00:59:16.730 --> 00:59:19.970
Well, that wouldn't give the right
result the way the colors are

00:59:20.050 --> 00:59:23.050
mapped to black and white,
so we would install a search block

00:59:23.050 --> 00:59:27.320
and then be able to deal with each
pixel with each color and decide

00:59:27.320 --> 00:59:29.330
how to map it to black and white.

00:59:29.420 --> 00:59:34.860
And then on this off-screen bitmap,
we would call bitmap to region,

00:59:34.990 --> 00:59:37.510
and the region is used as masked.

00:59:37.700 --> 00:59:39.700
So how would we replace this in Quartz?

00:59:39.780 --> 00:59:41.640
And that's the whole point here.

00:59:42.220 --> 00:59:44.910
We need to build a masked image.

00:59:44.920 --> 00:59:51.530
And this masked image...

00:59:54.590 --> 01:00:00.060
is being built, of course,
by Create Masked Image.

01:00:02.010 --> 01:00:04.140
Now I have two variants.

01:00:04.140 --> 01:00:08.060
It's a repetition in some
way of what Ted already used.

01:00:08.150 --> 01:00:12.290
It bears repetition in my mind
because you are going to use

01:00:12.560 --> 01:00:16.100
it in practice sooner or later.

01:00:18.740 --> 01:00:23.740
The idea is to mimic the QuickDraw thing,
but we don't have one bit off-screen,

01:00:23.740 --> 01:00:25.760
so we go into a gray level off-screen.

01:00:25.760 --> 01:00:31.750
This is the bit,
the gray level off-screen.

01:00:32.080 --> 01:00:35.700
Bitmap context,
we draw the picture into it

01:00:35.740 --> 01:00:38.280
and create an image off of it.

01:00:38.310 --> 01:00:40.170
Now here is some mystery call.

01:00:40.350 --> 01:00:42.640
Let's remove it for the time being.

01:00:42.690 --> 01:00:46.140
And the masked image gets
produced by the call create,

01:00:46.180 --> 01:00:48.490
CG image create with mask.

01:00:48.590 --> 01:00:52.600
So if we run this,

01:00:53.280 --> 01:00:55.000
Did I set it back to drawing the mask?

01:00:55.230 --> 01:00:56.400
Yeah, I did.

01:00:56.460 --> 01:00:59.970
And Peter, unfortunately,
has a color that looks like

01:00:59.970 --> 01:01:01.490
he's squeezing in the stomach.

01:01:01.520 --> 01:01:04.160
So what is going on?

01:01:04.160 --> 01:01:07.150
Of course,
our mapping of our drawing of the

01:01:07.150 --> 01:01:13.340
image into a gray level off-screen
produces a transparency corresponding

01:01:13.340 --> 01:01:17.520
to the lightness of the image data.

01:01:17.520 --> 01:01:21.350
And we need to fix this.

01:01:23.590 --> 01:01:24.570
And the fix is here.

01:01:24.810 --> 01:01:27.010
We need to fix the opaqueness.

01:01:27.170 --> 01:01:30.640
So this is the equivalent to what
we would have done in a search proc.

01:01:30.960 --> 01:01:35.670
We can go through all the
pixels of this 8-bit bitmap

01:01:35.670 --> 01:01:40.600
off-screen and define a cutoff,
heuristically.

01:01:40.660 --> 01:01:44.590
And as soon as the cutoff is below a
certain-- as soon as the pixel value,

01:01:44.640 --> 01:01:49.010
the gray level, is below a certain value,
we just make it completely

01:01:49.010 --> 01:01:50.380
dark and cut it off.

01:01:50.660 --> 01:01:52.680
And with that,

01:01:53.910 --> 01:01:57.640
Peter looks good again,
and we have masked out the image

01:01:57.640 --> 01:01:59.870
and have a common background.

01:02:00.500 --> 01:02:03.240
For a change,
we should switch back to slides so

01:02:03.240 --> 01:02:06.150
I can talk to slides for a while.

01:02:09.830 --> 01:02:11.500
So what did we learn?

01:02:11.510 --> 01:02:17.200
Replace picked resources,
image create with data provider,

01:02:17.250 --> 01:02:19.520
and internally it already
goes through ImageIO anyway.

01:02:19.520 --> 01:02:23.970
It has been factored out,
so it's all up to you.

01:02:25.840 --> 01:02:30.680
And the whole talk is about replacing
moving from QuickDraw to Quartz.

01:02:30.700 --> 01:02:34.000
Yeah,
notice that we talk about moving now

01:02:34.000 --> 01:02:36.700
and not about transitioning anymore.

01:02:36.750 --> 01:02:40.160
The word transition has been completely
used up on Monday in the keynote.

01:02:42.910 --> 01:02:45.400
Yeah,
so we are moving and replacing all the

01:02:45.400 --> 01:02:46.970
regions and all the CopyBits things.

01:02:50.590 --> 01:02:54.760
And I forgot to show you
how we come back to this,

01:02:55.110 --> 01:03:00.800
how this old-fashioned type of
creating a masked image by going

01:03:01.000 --> 01:03:06.950
through a gray level off-screen
and then creating the masked image,

01:03:07.020 --> 01:03:10.390
we could have replaced it by a
single API call with masking colors.

01:03:10.400 --> 01:03:12.580
And this is the call
that Ted already used,

01:03:12.580 --> 01:03:13.000
too.

01:03:14.410 --> 01:03:17.200
Now, these are Tiger APIs.

01:03:17.200 --> 01:03:21.380
Before, it's feasible, but you need,
again,

01:03:21.380 --> 01:03:25.650
go through a bitmap context and then
walk the alpha manually into the

01:03:25.720 --> 01:03:28.600
alpha channel to mimic the mask thing.

01:03:28.600 --> 01:03:30.920
But there was a good reason
to introduce these APIs,

01:03:30.920 --> 01:03:31.900
at least in Tiger.

01:03:33.980 --> 01:03:35.380
So, the next step.

01:03:35.520 --> 01:03:39.800
We are getting into more copy mask
things and copy deep mask in particular.

01:03:39.800 --> 01:03:43.710
And here's an overview
of what we want to do.

01:03:43.720 --> 01:03:49.020
The CopyBits killer is
CG Context Draw Image.

01:03:49.020 --> 01:03:54.950
Instead of source pixels,
we use the source pixels of the image,

01:03:54.950 --> 01:03:59.660
which are provided by the
image's data provider.

01:04:00.140 --> 01:04:06.140
We are going to do fancy things now,
which don't even need overlay windows.

01:04:06.140 --> 01:04:11.140
I should not forget to show you
again where we do a hit test.

01:04:11.140 --> 01:04:15.880
So, back to my machine here.

01:04:17.130 --> 01:04:22.150
You know, we forgot that we can
still scribble around here.

01:04:22.280 --> 01:04:25.540
And at this point,
I had an idea and I said,

01:04:25.540 --> 01:04:27.300
maybe I should show how to do this.

01:04:27.500 --> 01:04:31.220
That's a really QuickDraw thing.

01:04:31.220 --> 01:04:31.220
See?

01:04:33.430 --> 01:04:34.700
How would you do this in QuickDraw?

01:04:34.700 --> 01:04:37.980
You would need a couple
gWorlds off-screen,

01:04:38.050 --> 01:04:42.300
CopyBits back and forth,
and then use CopyDeepMask

01:04:42.420 --> 01:04:45.260
to a hole in the belly.

01:04:45.950 --> 01:04:50.210
To get the transparent
effect while we are dragging.

01:04:50.210 --> 01:04:53.530
This would be a lot of work to show.

01:04:53.530 --> 01:04:57.860
And it's something really, in my mind,
QuickDraw-ish.

01:04:58.930 --> 01:05:03.470
We cannot translate the
QuickDraw API calls into making

01:05:03.470 --> 01:05:04.970
a Quartz version of that.

01:05:05.210 --> 01:05:08.440
We need to start out
completely differently.

01:05:08.610 --> 01:05:10.250
And it's already all there.

01:05:10.310 --> 01:05:15.500
So the first thing is do the hit test.

01:05:16.950 --> 01:05:20.950
We have two states in this
application as it stands now.

01:05:21.270 --> 01:05:26.140
One state is we are tracking
the mouse to draw the outline.

01:05:26.390 --> 01:05:29.000
Then we are done drawing the outline.

01:05:29.040 --> 01:05:35.580
And as soon as we get into a hit test
that we clicked inside this outline,

01:05:35.650 --> 01:05:38.710
we are in the second stage where
we are dragging around the image.

01:05:38.910 --> 01:05:41.680
So this needs to be
reflected after the hit test.

01:05:41.740 --> 01:05:46.390
Hit testing means we are only
interested in the hit test when we

01:05:46.470 --> 01:05:48.280
are done with building our path.

01:05:48.330 --> 01:05:54.200
And now we create this one by one,
a single pixel bitmap context.

01:05:54.780 --> 01:06:02.570
This single-pixel bitmap context
gets moved to our rear point.

01:06:03.300 --> 01:06:06.030
"Where we want to test the hit.

01:06:06.070 --> 01:06:11.250
Now our path that we remember,
we apply the path such that it,

01:06:11.280 --> 01:06:15.930
this time we pass in our
bitmap context of course.

01:06:16.650 --> 01:06:22.170
The bitmap context now has
our path as current path,

01:06:22.290 --> 01:06:23.730
and we fill it.

01:06:23.920 --> 01:06:26.970
When we fill this path, we check,
did this touch our

01:06:27.020 --> 01:06:29.800
one-pixel bitmap context?

01:06:29.800 --> 01:06:35.250
If it did, then we know our point
was inside this path.

01:06:35.280 --> 01:06:42.280
And then we release things and we return
the result in the field hitSelection.

01:06:44.930 --> 01:06:48.190
And with that,
as soon as we are in this hit selection,

01:06:48.240 --> 01:06:51.000
we go to the tracking.

01:06:51.360 --> 01:06:54.300
And this time we have two tracking
loops depending on whether we

01:06:54.300 --> 01:06:55.730
hit the selection already or not.

01:06:55.730 --> 01:06:59.150
The first one we discussed already.

01:06:59.370 --> 01:07:03.610
The second is drag the
image selection around.

01:07:04.920 --> 01:07:10.200
And it's just a copy-paste of the
original mouse tracking loop instead.

01:07:10.220 --> 01:07:13.680
But instead of redrawing the path,
this time we just keep

01:07:13.820 --> 01:07:16.690
up-to-date the selection offset,
which I added.

01:07:16.690 --> 01:07:20.000
That's where we dragged it to.

01:07:20.000 --> 01:07:24.960
And say we need to redraw
now at the new offset.

01:07:24.960 --> 01:07:29.060
So it's all inside the draw the view.

01:07:31.290 --> 01:07:35.040
Each time we draw the view,
we fill the background.

01:07:35.410 --> 01:07:43.610
We draw the image first into its
original place where it belongs.

01:07:44.220 --> 01:07:48.320
And now we check,
did we hit the selection already?

01:07:48.360 --> 01:07:49.620
There's one thing I want to do.

01:07:49.620 --> 01:07:54.830
I want to paint the selection now white,
the original selection where it was,

01:07:54.830 --> 01:07:57.180
to suggest that we remove
all these pixels here.

01:07:57.180 --> 01:07:58.410
OK, let's fill it with white.

01:07:58.610 --> 01:08:02.680
But in order to do so,
I need to clip to my path.

01:08:02.720 --> 01:08:05.200
And again, you see that it's always
the same mechanism.

01:08:05.200 --> 01:08:11.140
I use my path,
which is kept in my local data.

01:08:11.350 --> 01:08:13.440
I've applied a path to
move it into the context,

01:08:13.440 --> 01:08:15.740
and now I can just clip to it.

01:08:15.750 --> 01:08:20.190
I fill it, but because I clipped,

01:08:22.700 --> 01:08:24.940
I don't even remember what I meant.

01:08:24.940 --> 01:08:26.760
Oh, yeah, that's the-- it's OK.

01:08:26.760 --> 01:08:30.800
So because I clipped and
I want to undo the clip,

01:08:30.800 --> 01:08:34.020
I need to save and restore
the G state around it.

01:08:34.020 --> 01:08:37.380
And now we keep going
in our drawing routine.

01:08:37.380 --> 01:08:39.840
Well,
if we did not hit the selection yet,

01:08:39.840 --> 01:08:42.470
then we have a path,
then we apply the path and stroke it.

01:08:42.750 --> 01:08:46.680
This is the first state
of scribbling around.

01:08:46.710 --> 01:08:49.700
But if we are done with path building,

01:08:50.040 --> 01:08:55.350
Then, we first change the coordinate
system such that we move it to

01:08:55.350 --> 01:08:58.090
where our selection offset is.

01:08:58.490 --> 01:09:00.470
Again, once more,
we need to apply the path

01:09:00.640 --> 01:09:03.270
because we need to clip to this
path now to draw our image.

01:09:04.860 --> 01:09:08.870
Well, and now we draw the image,
except that we want to apply an alpha

01:09:09.250 --> 01:09:12.820
to suggest we are not done yet with
moving it around and to see through.

01:09:13.100 --> 01:09:13.860
And then we draw the image.

01:09:16.340 --> 01:09:20.060
This is pretty simple for what it does.

01:09:20.360 --> 01:09:23.000
If you think about it,
how this would work in QuickDraw,

01:09:23.000 --> 01:09:25.090
how you would have to do
really much more work.

01:09:25.120 --> 01:09:27.540
It was a surprise to myself.

01:09:27.600 --> 01:09:31.720
Is there something else
I forgot to point out?

01:09:31.760 --> 01:09:35.140
No, it's always the same,
and you will find if you compare

01:09:35.200 --> 01:09:38.670
the various stages of the files,
how they grow out of each other,

01:09:38.670 --> 01:09:42.920
how they repeat the same code,
and how everything is pretty minimal.

01:09:45.620 --> 01:09:49.510
With that, I'm ready to go back
to my very last slide.

01:09:49.510 --> 01:09:53.170
Can we move?

01:09:53.170 --> 01:09:53.170
Yeah.

01:09:53.810 --> 01:09:55.820
So here's the summary.

01:09:55.840 --> 01:09:58.160
Honestly, HIV use are the way to go.

01:09:58.190 --> 01:10:03.020
If we can do anything to encourage you,
and you need some encouragement,

01:10:03.090 --> 01:10:04.190
let us know.

01:10:04.520 --> 01:10:08.680
You are convinced now that you need
to get used to the transforms and

01:10:08.680 --> 01:10:10.240
to juggling around with coordinates.

01:10:10.240 --> 01:10:13.370
That's something new,
that's something unavoidable,

01:10:13.370 --> 01:10:18.280
and it may take a while and
a couple of frustrations,

01:10:18.280 --> 01:10:25.020
but it's not so bad as it may appear
the first time you don't get it right.

01:10:25.020 --> 01:10:31.330
CGPathRefs, you need that to replace
polygons and to replace many,

01:10:31.330 --> 01:10:32.490
many regions in your code.

01:10:33.880 --> 01:10:37.490
There is really no need for
CopyBits and CopyDeepMask.

01:10:37.660 --> 01:10:42.750
We can, in an example like this,

01:10:44.070 --> 01:10:46.840
You should be convinced
that this is a good thing.

01:10:46.950 --> 01:10:51.380
So, looks like that's really the
time to get rid of QuickDraw,

01:10:51.380 --> 01:10:54.500
and it's fun,
and it will be really profitable for you,

01:10:54.500 --> 01:10:55.020
too.

01:10:55.020 --> 01:10:56.270
One more thing.

01:10:56.270 --> 01:11:00.810
I didn't talk about Carbon Sketch,
but I have been working on it,

01:11:01.050 --> 01:11:02.170
and I will continue to work on it.

01:11:02.350 --> 01:11:04.350
It's, of course, now HIVU-based.

01:11:04.470 --> 01:11:07.800
It has a couple of new features,
and I will add some more.

01:11:08.140 --> 01:11:10.890
And within the next weeks,
I will be done with it.

01:11:11.000 --> 01:11:14.580
And then it will take its time to go
through the process of being posted,

01:11:14.580 --> 01:11:15.710
but please watch out for it.

01:11:15.890 --> 01:11:19.660
It's there, and it's growing.

01:11:21.600 --> 01:11:22.520
That's it from my side.

01:11:22.640 --> 01:11:25.340
Here are related sessions.

01:11:25.370 --> 01:11:27.040
There's not much left anymore.

01:11:27.070 --> 01:11:32.600
Right after this session
in 15 minutes or 20,

01:11:32.630 --> 01:11:38.010
optimal application graphics,
which is optimization of

01:11:38.240 --> 01:11:40.500
usage of the Quartz API.

01:11:41.040 --> 01:11:45.300
And then please come to
the lab and chat with me,

01:11:45.360 --> 01:11:47.820
bring some food at noon.

01:11:49.650 --> 01:11:53.570
and there is also the lab
session for optimizing.

01:11:53.570 --> 01:11:55.640
And everybody knows Travis.

01:11:55.680 --> 01:11:59.580
That's where all your feedback should go,
all your requests, all your complaints,

01:11:59.580 --> 01:12:00.940
and all your compliments.

01:12:00.990 --> 01:12:02.550
Thank you.
WEBVTT

00:00:00.670 --> 00:00:01.430
Good morning everyone.

00:00:01.490 --> 00:00:04.710
I'm John Montprion from
Apple Developer Technical Support.

00:00:04.740 --> 00:00:07.940
I'm very pleased to
introduce John Comiskey,

00:00:07.940 --> 00:00:11.060
Senior Apple Script Engineer,
who will be guiding you

00:00:11.060 --> 00:00:12.730
through this hands-on session.

00:00:12.730 --> 00:00:15.330
I'd like to point out that
the download materials,

00:00:15.330 --> 00:00:18.660
Sketch 1.1.2,
was not available on the DMG and you

00:00:18.900 --> 00:00:23.740
would have had to download that from
the Secure Developer Conference website

00:00:23.860 --> 00:00:25.600
before this session begins.

00:00:25.620 --> 00:00:28.610
Because of our network situation
today you might not be able to

00:00:28.610 --> 00:00:31.380
download that during the session,
so please just follow along.

00:00:31.380 --> 00:00:33.120
You can download that later.

00:00:33.280 --> 00:00:36.160
But here's John,
maybe give him a round of

00:00:36.180 --> 00:00:37.930
applause and thank you.

00:00:40.470 --> 00:00:41.550
Good morning, thank you very much.

00:00:41.630 --> 00:00:44.530
My name is John Comiskey and I'm an
engineer in the Apple Script Group and

00:00:44.530 --> 00:00:48.650
I'm here to talk to you today about
implementing a scripting interface.

00:00:49.120 --> 00:00:51.530
Before we start,
there are some assumptions that

00:00:51.530 --> 00:00:53.500
we've made about who's here today.

00:00:53.620 --> 00:00:56.980
We're assuming that you know
something about Cocoa and Objective-C.

00:00:57.100 --> 00:01:01.000
It may not be the only language you
use or even the one you use the most,

00:01:01.000 --> 00:01:03.550
but if you're going to do
Cocoa scripting you're going to need

00:01:03.550 --> 00:01:04.990
to know how to write Cocoa code.

00:01:05.000 --> 00:01:09.290
We're also presuming that you've got
an application that's been designed

00:01:09.540 --> 00:01:13.970
and maybe even implemented and that
you want to add scriptability to it.

00:01:14.080 --> 00:01:17.420
Your dictionary, by the time you reach
this point in development,

00:01:17.420 --> 00:01:19.000
should already be designed.

00:01:19.000 --> 00:01:24.160
If you were at session 103 yesterday,
you found out about how to write an SDEF,

00:01:24.590 --> 00:01:28.940
how to express your scripting
implementation or your scripting

00:01:29.000 --> 00:01:33.930
interface in the form of an SDEF,
which then presents to your

00:01:33.930 --> 00:01:36.290
user an AppleScript dictionary.

00:01:37.180 --> 00:01:41.410
We're also presuming that you've
identified one or more real-world test

00:01:41.420 --> 00:01:45.900
cases that are going to prove not only
the functionality of your scripting,

00:01:45.990 --> 00:01:48.100
but its usefulness to your end users.

00:01:48.100 --> 00:01:50.100
This could be some kind
of feature extension,

00:01:50.100 --> 00:01:53.150
something that your program
is capable of doing,

00:01:53.360 --> 00:01:56.050
but only after a certain number
of steps have been performed.

00:01:56.100 --> 00:01:59.780
You want to streamline this,
allow your users to do it all in one step

00:01:59.780 --> 00:02:02.050
and use scriptability as a way to do it.

00:02:02.190 --> 00:02:07.300
You're going to implement that
feature extension in an Apple script.

00:02:07.400 --> 00:02:11.780
and that Apple Script needs
to solve a real-world problem

00:02:11.780 --> 00:02:13.290
that your users actually have.

00:02:13.630 --> 00:02:16.140
Scripting is interesting
as an academic exercise,

00:02:16.200 --> 00:02:18.640
but it's only going to be a
selling point for you if it

00:02:18.640 --> 00:02:21.100
solves your end-user's problems.

00:02:21.250 --> 00:02:24.190
And as John just said,
if you haven't already

00:02:24.190 --> 00:02:27.280
downloaded the sample code,
you may not be able to

00:02:27.280 --> 00:02:29.000
get it during the session.

00:02:29.140 --> 00:02:33.200
But you can follow along and you'll have
ample opportunity to download it later.

00:02:33.320 --> 00:02:37.000
And if you want to come and discuss
it with us in our lab this afternoon,

00:02:37.000 --> 00:02:38.430
you can do that as well.

00:02:38.630 --> 00:02:43.420
This is where you're going to need to
go to get documentation and sample code.

00:02:43.420 --> 00:02:49.560
In addition to the sample
code for this session,

00:02:49.590 --> 00:02:52.540
there's lots of other
interesting things here.

00:02:52.590 --> 00:03:01.250
Documentation that will help you
design your scripting interface and

00:03:01.250 --> 00:03:01.250
implement the code that supports it.

00:03:02.650 --> 00:03:05.920
The procedures that we're going to
cover today are equally applicable

00:03:05.920 --> 00:03:08.480
to both Cocoa and Carbon programs.

00:03:08.510 --> 00:03:13.080
You can use Cocoa scripting in
an otherwise pure Carbon program.

00:03:13.160 --> 00:03:17.160
There is a few things that you
need to do special to hook up

00:03:17.180 --> 00:03:21.150
Cocoa scripting in your main.c file.

00:03:21.280 --> 00:03:23.920
And if you are in that situation
and you want to do that,

00:03:24.130 --> 00:03:25.730
come to the lab and we'll
show you how to do it.

00:03:25.730 --> 00:03:30.280
It's not hard, it's just a little arcane
for presentation here.

00:03:32.310 --> 00:03:34.600
Here's what we're going
to be talking about today.

00:03:34.600 --> 00:03:36.880
We're going to talk about logging.

00:03:36.880 --> 00:03:39.310
Logging has proven to be
invaluable to me as I've

00:03:39.310 --> 00:03:41.480
developed scriptable applications.

00:03:41.480 --> 00:03:46.110
Cocoa scripting calls into your
objects many times in many places.

00:03:46.240 --> 00:03:50.090
The patterns are absolutely
predictable once you get to know them,

00:03:50.090 --> 00:03:53.940
but you have to get to know them,
and logging can help you do that.

00:03:53.940 --> 00:03:56.160
We're going to talk
about element accessors.

00:03:56.160 --> 00:03:57.810
Your application has objects in it.

00:03:57.850 --> 00:04:00.640
The scripters need to be
able to get at those objects,

00:04:00.640 --> 00:04:03.170
and element accessors are
what they use to do that.

00:04:03.190 --> 00:04:07.820
We're going to talk
about property accessors.

00:04:07.820 --> 00:04:10.710
Two objects of the same class
differ from each other in the

00:04:10.710 --> 00:04:12.900
values of their various properties.

00:04:12.900 --> 00:04:15.100
This is what makes scripting
your objects interesting,

00:04:15.170 --> 00:04:17.680
the fact that your users can tell
them apart by looking at their

00:04:17.680 --> 00:04:19.350
properties and seeing what they say.

00:04:19.350 --> 00:04:23.520
A typical property that's going to
tell most objects apart is its name.

00:04:23.890 --> 00:04:26.100
We're also going to talk
about implementing commands,

00:04:26.100 --> 00:04:27.680
and there's two different
ways to do that.

00:04:27.910 --> 00:04:33.230
In Cocoa scripting your commands
can be dispatched to an object which

00:04:33.230 --> 00:04:37.280
knows what to do with that command,
or if the command inherently

00:04:37.280 --> 00:04:41.980
acts on a set of objects,
the command can be dispatched

00:04:42.030 --> 00:04:45.150
directly to a command handler
that collects the relevant objects

00:04:45.240 --> 00:04:47.070
and acts on all of them at once.

00:04:47.220 --> 00:04:49.800
We'll be talking about both of those.

00:04:49.910 --> 00:04:52.800
We'll also be talking about
automated regression testing.

00:04:52.800 --> 00:04:55.170
As you implement your
scripting interface,

00:04:55.190 --> 00:04:58.800
you're going to build up a collection
of small unit test scripts.

00:04:58.800 --> 00:04:59.790
You're going to want to keep those.

00:04:59.790 --> 00:05:01.780
You're going to want
to record the results,

00:05:01.800 --> 00:05:04.940
and you're going to want to run them
over and over again to make sure

00:05:04.940 --> 00:05:06.800
that you haven't broken anything.

00:05:06.800 --> 00:05:09.180
And if you can run your regression
tests over and over again and

00:05:09.180 --> 00:05:11.920
get the same results each time,
you know that the changes you've made to

00:05:11.920 --> 00:05:13.620
your program haven't hurt your scripting.

00:05:13.770 --> 00:05:17.280
And this can be valuable whether
the changes you've made had anything

00:05:17.280 --> 00:05:18.800
to do with scripting or not.

00:05:18.800 --> 00:05:19.920
that.

00:05:20.140 --> 00:05:24.110
We're also going to get back to
testing our real-world test cases.

00:05:24.480 --> 00:05:26.500
This is the value of scriptability.

00:05:26.540 --> 00:05:31.450
If your end users identify
a real-world objective,

00:05:31.630 --> 00:05:35.510
some mission-critical activity
that they need to perform

00:05:35.510 --> 00:05:39.330
over and over and over again,
and they use scriptability and they

00:05:39.330 --> 00:05:45.000
use your application to implement that,
then they are your customer for life.

00:05:45.000 --> 00:05:47.640
As long as they keep using
that automated workflow,

00:05:47.760 --> 00:05:50.560
as long as that's part of their job,
then your application is

00:05:50.560 --> 00:05:52.000
going to be part of their job.

00:05:52.000 --> 00:05:56.150
And that's one of the
greatest benefits to you.

00:05:59.460 --> 00:06:02.790
This is the macro that I use for logging.

00:06:02.890 --> 00:06:03.760
It's very simple.

00:06:03.920 --> 00:06:08.300
Based on a simple if statement,
this macro either expands into

00:06:08.300 --> 00:06:10.200
an NSLog statement or it doesn't.

00:06:10.400 --> 00:06:14.750
Once that switch is turned off,
all of this disappears from your code,

00:06:14.750 --> 00:06:18.480
it adds no overhead at all,
but when you turn that switch on,

00:06:18.480 --> 00:06:22.010
if you change that to if1 instead of if0,
then you can watch what

00:06:22.010 --> 00:06:27.400
Cocoa scripting does as it calls the
various accessors in your program.

00:06:27.440 --> 00:06:29.400
Your logging should be ubiquitous.

00:06:29.400 --> 00:06:31.390
You should put it absolutely everywhere.

00:06:31.390 --> 00:06:33.380
In every accessor,
every element accessor,

00:06:33.430 --> 00:06:36.400
every property accessor,
every event handler.

00:06:36.400 --> 00:06:39.690
And as the event handler becomes
complex and starts to do various

00:06:39.690 --> 00:06:44.280
processing based on its input,
you'll want to log the significant

00:06:44.280 --> 00:06:46.370
events in that as well.

00:06:48.200 --> 00:06:51.900
Element accessors are what allow
scripters to get at the objects

00:06:51.900 --> 00:06:54.280
that live inside your application.

00:06:54.330 --> 00:06:55.440
And there's different kinds.

00:06:55.440 --> 00:06:59.630
There's one very simple--each application
is going to have one very simple accessor

00:06:59.640 --> 00:07:01.240
for the entire collection of objects.

00:07:01.240 --> 00:07:04.840
We're going to be talking about Sketch,
which is a simple graphics program,

00:07:04.840 --> 00:07:08.880
and one of the objects that it
has a collection of is rectangles.

00:07:08.880 --> 00:07:12.420
So an accessor that would fetch
all the rectangles at once would

00:07:12.420 --> 00:07:14.310
simply be called rectangles.

00:07:14.340 --> 00:07:16.340
That's sometimes not terribly efficient.

00:07:16.380 --> 00:07:19.770
In Sketch, a document might have
ten rectangles in it.

00:07:19.800 --> 00:07:21.440
That's not too many.

00:07:21.440 --> 00:07:24.570
In another application,
a database application for instance,

00:07:24.570 --> 00:07:26.500
you might have millions of records.

00:07:26.500 --> 00:07:29.770
Returning the entire collection all
at once isn't terribly practical.

00:07:29.780 --> 00:07:31.720
So there's other ways to handle that.

00:07:31.720 --> 00:07:36.070
There's accelerated accessors that allow
you to get at your objects by name,

00:07:36.070 --> 00:07:39.320
by index, or by unique ID.

00:07:39.320 --> 00:07:41.850
You shouldn't simply grab the
entire collection and look

00:07:42.030 --> 00:07:43.350
for things by name yourself.

00:07:43.380 --> 00:07:45.580
Cocoa Scripting will do that for you.

00:07:45.580 --> 00:07:46.360
You shouldn't have to write
the entire collection.

00:07:46.380 --> 00:07:48.380
You can write that code because
someone else has already written it

00:07:48.480 --> 00:07:50.910
and you don't have to maintain it.

00:07:50.940 --> 00:07:54.510
But if you've got a database
application and you can get at one

00:07:54.510 --> 00:07:59.760
record out of a million and you can do
it really fast by using its unique ID,

00:07:59.760 --> 00:08:03.450
then you should definitely have
an accelerated accessor for that.

00:08:03.460 --> 00:08:06.420
Your scripters will be much happier
with the performance of their scripts

00:08:06.700 --> 00:08:09.280
if you provide this kind of support.

00:08:11.590 --> 00:08:15.340
Element accessors also
include setter-type functions.

00:08:15.340 --> 00:08:18.250
If you're familiar with AppleScript,
you know that you can make new objects.

00:08:18.420 --> 00:08:23.500
You can also delete existing objects
and you can replace objects in place.

00:08:23.620 --> 00:08:25.500
These accessors are what support that.

00:08:25.500 --> 00:08:30.490
You'll notice that there's
two kinds of insert accessors:

00:08:30.510 --> 00:08:33.400
one that inserts at a particular index,
one that does not.

00:08:33.580 --> 00:08:35.500
This depends upon the
nature of your application.

00:08:35.500 --> 00:08:39.500
In some applications the
order of the objects matters.

00:08:39.500 --> 00:08:43.480
For instance, the order of windows in an
application is always front to back.

00:08:43.500 --> 00:08:47.340
In other applications,
order may not be particularly important.

00:08:47.340 --> 00:08:49.500
If you do have a big
random access database,

00:08:49.500 --> 00:08:53.420
the index of a particular
record isn't as important.

00:08:53.510 --> 00:08:55.480
So, creating a new record,
you might just want to

00:08:55.480 --> 00:08:56.500
create it at the end.

00:08:56.500 --> 00:09:01.500
So use whichever of these accessors
is appropriate for the kind of object

00:09:01.500 --> 00:09:03.500
that the scripter would be creating.

00:09:03.500 --> 00:09:08.490
That's a decision that you make based
on your knowledge of your application.

00:09:08.500 --> 00:09:14.500
So now we're going to look at logging
and element accessors on demo 2.

00:09:18.650 --> 00:09:25.600
This is the Sketch project which
is available in the developer

00:09:25.710 --> 00:09:29.400
folder on any machine where you've
installed the developer tools.

00:09:29.480 --> 00:09:33.720
It's an example application,
simple graphics,

00:09:33.860 --> 00:09:38.950
it's already scriptable and we're going
to add scripting capabilities to it.

00:09:47.800 --> 00:09:59.600
[Transcript missing]

00:09:59.960 --> 00:10:03.090
is going to be called "Rectangles"
and so we'll search for a whole word

00:10:03.090 --> 00:10:05.860
and see if we can find exactly that.

00:10:05.860 --> 00:10:07.310
And we have.

00:10:07.900 --> 00:11:46.400
[Transcript missing]

00:11:46.570 --> 00:11:48.000
And we're going to find
that there's some more,

00:11:48.000 --> 00:11:49.980
as a matter of fact.

00:11:50.050 --> 00:11:53.600
That here is the insert accessor.

00:11:53.640 --> 00:11:57.160
When a new rectangle is created,
it's inserted in the

00:11:57.160 --> 00:11:59.740
collection by calling this.

00:12:02.120 --> 00:12:05.370
There's a remove accessor,
so when a rectangle is

00:12:05.370 --> 00:12:11.160
deleted via Scriptability,
this code will be called and

00:12:11.160 --> 00:12:13.190
the rectangle will go away.

00:12:16.260 --> 00:12:20.140
This is the replace accessor,
same thing that replaces an

00:12:20.140 --> 00:12:22.340
existing rectangle in place.

00:12:23.610 --> 00:12:30.090
Back here at the beginning,
I've got a header file

00:12:30.090 --> 00:12:30.090
and in my header file,

00:12:30.620 --> 00:12:34.680
is where I have my macros defined.

00:12:34.690 --> 00:12:36.890
And I'm going to take this switch
and I'm going to change it to a

00:12:36.890 --> 00:12:40.700
1 so that my macros will expand
while we're doing this exercise.

00:12:40.740 --> 00:12:43.880
You would want to make sure that
when you check this into any code

00:12:43.880 --> 00:12:46.760
repository you always have the
switch off so that none of your

00:12:46.760 --> 00:12:49.860
fellow programmers get any surprises.

00:13:02.820 --> 00:13:05.700
So those are element
accessors and logging.

00:13:05.700 --> 00:13:08.930
That's what they look like.

00:13:08.970 --> 00:13:11.880
So let's come back here and build this.

00:13:20.600 --> 00:13:25.040
I usually like to run from the debugger
because then if I find something

00:13:25.040 --> 00:13:28.740
interesting I can just immediately
add a breakpoint and try it again

00:13:28.740 --> 00:13:31.120
and see what's really happening.

00:13:32.910 --> 00:13:36.320
And I like to open the console log
because that allows me to watch

00:13:36.380 --> 00:13:39.190
my logging messages as they go by.

00:13:43.250 --> 00:13:48.480
So we'll run this.

00:13:48.480 --> 00:13:50.200
And here's Sketch.

00:13:50.200 --> 00:13:55.160
And since we're interested in rectangles,
we'll draw a few of them.

00:13:56.500 --> 00:14:00.490
And we'll set that over to the side.

00:14:00.490 --> 00:14:03.850
And I've already got the
script editor running.

00:14:04.160 --> 00:14:08.090
And we want to drive
that simple accessor.

00:14:08.090 --> 00:14:12.480
We want to make it fetch all the
rectangles and see what happens.

00:14:12.960 --> 00:14:15.850
So, I'm going to select Event Log down
here at the bottom because then

00:14:15.850 --> 00:14:19.490
that will show me the results
of each event as they go by.

00:14:19.680 --> 00:14:23.990
I'm going to tell Document 1 that
I want to get every rectangle.

00:14:23.990 --> 00:14:27.970
And I usually put a healthy timeout
in my test scripts because if I am

00:14:27.970 --> 00:14:31.450
debugging and I hit a breakpoint,
I would rather that the script not

00:14:31.550 --> 00:14:36.100
fail because of a timeout while I'm
poking around looking at variables.

00:14:37.600 --> 00:14:39.000
So we'll run that.

00:14:39.010 --> 00:14:42.740
And as you can see,
I've got three rectangles.

00:14:42.750 --> 00:14:45.300
They're untitled at this point.

00:14:45.320 --> 00:14:46.600
They don't have any names.

00:14:46.790 --> 00:14:50.000
And you can also see
down here in the log,

00:14:50.100 --> 00:14:54.050
it's hit my logging message
and it shows up here.

00:14:54.500 --> 00:15:00.910
So now I know when I execute a "get
every rectangle" line of Apple script,

00:15:00.910 --> 00:15:06.440
it's going to call my rectangles
method inside my object.

00:15:06.440 --> 00:15:09.470
And if we can go back to the slides,
please.

00:15:10.830 --> 00:15:16.300
Logging and Element Accessors
No new code there because Sketch is

00:15:16.300 --> 00:15:20.240
already scriptable and already
handles a collection of rectangles.

00:15:20.290 --> 00:15:22.460
Now we're going to talk
about Property Accessors.

00:15:22.520 --> 00:15:26.860
The things that make one particular
instance of a class different

00:15:26.860 --> 00:15:30.100
from another are its properties.

00:15:30.170 --> 00:15:33.040
For a rectangle it's going
to be height and width,

00:15:33.040 --> 00:15:36.110
fill color, stroke color,
other things like that.

00:15:36.330 --> 00:15:38.540
Properties can be of two types.

00:15:38.540 --> 00:15:40.800
They can be read-only or read-write.

00:15:40.840 --> 00:15:43.040
Read-only properties are going to
be things that you can't change.

00:15:43.040 --> 00:15:45.910
For example,
the physical dimensions of a display.

00:15:46.120 --> 00:15:48.680
No matter how much you'd like to write
a line of Apple script that says,

00:15:48.680 --> 00:15:51.730
"Give me a 30-inch cinema
display," you can't do that.

00:15:51.850 --> 00:15:54.680
So that property is
going to be read-only.

00:15:54.750 --> 00:15:58.950
However,
the pixel resolution of a given display

00:15:59.130 --> 00:16:02.200
at any point in time can be changed.

00:16:02.290 --> 00:16:04.340
So that would be a read-write property.

00:16:04.380 --> 00:16:07.910
And you're going to want to implement
the properties in your application

00:16:08.070 --> 00:16:13.000
according to your design as read-only
or read-write as appropriate.

00:16:13.180 --> 00:16:17.380
The property accessors, again,
they leverage the key value coding,

00:16:17.430 --> 00:16:21.290
which is an important technology.

00:16:21.470 --> 00:16:26.030
provides for consistency of access and
that's what Apple Scripts all about.

00:16:26.030 --> 00:16:30.840
We want consistency of access to your
application and across applications.

00:16:30.870 --> 00:16:34.000
So the fact that Cocoa scripting
leverages key value coding

00:16:34.010 --> 00:16:35.440
is highly appropriate.

00:16:35.440 --> 00:16:39.160
It means that all Cocoa scripting
programs are working the same way

00:16:39.160 --> 00:16:41.000
when they go after your objects.

00:16:41.040 --> 00:16:43.660
And that means that your
implementation and everybody

00:16:43.660 --> 00:16:46.800
else's scripting implementation
are going to be more consistent.

00:16:46.810 --> 00:16:53.390
And consistency across applications
is greatly desired by scripters.

00:16:53.600 --> 00:16:56.020
Cocoa Bindings also
leverages key value coding.

00:16:56.110 --> 00:17:00.880
It's an easy way to keep your view
and your model in sync without having

00:17:00.910 --> 00:17:02.760
to write a lot of controller code.

00:17:02.790 --> 00:17:04.720
And less code is less bugs.

00:17:04.720 --> 00:17:07.920
So you should use things
like Cocoa Bindings and

00:17:08.030 --> 00:17:10.050
leverage KVC even further.

00:17:10.200 --> 00:17:14.250
So now we're going to go back to demo
two and look at property accessors.

00:17:29.110 --> 00:17:35.270
We could go in and modify existing files,
and you can do that

00:17:35.270 --> 00:17:38.530
certainly with your project.

00:17:39.400 --> 00:17:42.290
But if you work in a large team
and more than one person might

00:17:42.290 --> 00:17:44.560
be touching the same files,
more than one person might

00:17:44.630 --> 00:17:49.730
be modifying the same object,
you might find it convenient to use a

00:17:49.890 --> 00:18:00.230
Objective C categories instead,
and that's what I've done here.

00:18:00.230 --> 00:18:00.230
And the categories each
live in a separate file.

00:18:00.230 --> 00:18:00.230
So now it's not necessary.

00:18:00.450 --> 00:18:02.370
"It's up to you to modify
the existing files.

00:18:02.400 --> 00:18:05.640
If someone else happens to be working
on the project at the same time as me,

00:18:05.690 --> 00:18:09.780
I can work on scripting,
he can do what he's doing,

00:18:09.780 --> 00:18:13.700
and we won't bother each other.

00:18:13.700 --> 00:18:13.710
So I'm going to add two files.

00:18:13.900 --> 00:19:14.400
[Transcript missing]

00:19:15.350 --> 00:19:16.960
Here's the code.

00:19:17.060 --> 00:19:21.000
If you were in 103 yesterday,
you'll know that orientation is

00:19:21.000 --> 00:19:25.300
one of three enumerated values:
landscape, portrait, and square.

00:19:25.300 --> 00:19:27.300
We're going to support
all three of those.

00:19:27.360 --> 00:19:30.010
Here's the code that does it.

00:19:32.340 --> 00:19:35.660
When we're getting the orientation
it's really pretty easy.

00:19:35.710 --> 00:19:38.320
Something might be a square,
we're not sure.

00:19:38.360 --> 00:19:41.240
So we're going to set the
initial value to square.

00:19:41.270 --> 00:19:45.220
Then we're going to compare the height
and width and if it's taller then

00:19:45.220 --> 00:19:51.490
that's portrait orientation and if it's
wider that's landscape orientation and

00:19:51.490 --> 00:19:53.320
then we're going to return that value.

00:19:53.350 --> 00:19:58.800
You notice that we return the raw
4 byte codes and we say that this

00:19:58.800 --> 00:20:01.260
routine returns an unsigned value.

00:20:01.300 --> 00:20:04.770
Cocoa scripting will take care of
turning that into an NSNumber for

00:20:04.770 --> 00:20:07.820
you and sending it back through
AppleScript and AppleScript will

00:20:07.890 --> 00:20:12.700
take care of turning it back into a
human readable representation of that

00:20:12.700 --> 00:20:19.160
enumerated value and your scripting users
will see a very nice portrait landscape

00:20:19.250 --> 00:20:21.360
square as the possible orientations.

00:20:23.930 --> 00:20:26.750
The setter is a little bit more complex.

00:20:26.750 --> 00:20:31.710
First thing we do is we look at the
incoming orientation to make sure that

00:20:31.760 --> 00:20:33.440
it's one of the ones that we support.

00:20:33.480 --> 00:20:37.520
And if we don't, if it's not one of the
ones that we support,

00:20:37.650 --> 00:20:41.010
down here at the bottom
of this switch statement,

00:20:41.360 --> 00:20:47.850
We set an error because we know that we
can't set something to orientation 9.

00:20:47.850 --> 00:20:49.300
That's not going to work.

00:20:49.360 --> 00:20:52.850
So if it's not one of the valid inputs,
we reject it by generating an error,

00:20:52.850 --> 00:20:55.700
and we'll show you that in a second.

00:20:55.850 --> 00:20:58.190
Otherwise,
if it's one of the orientations

00:20:58.190 --> 00:21:01.200
that we do know about,
we handle it in various ways.

00:21:01.480 --> 00:21:05.060
If someone requests that the
orientation be set to square,

00:21:05.160 --> 00:21:08.300
well, that's not really appropriate
unless it already is a square.

00:21:08.430 --> 00:21:11.900
So if the existing rectangle
is not already square,

00:21:11.900 --> 00:21:15.470
we're going to generate
an error for that as well.

00:21:16.550 --> 00:21:20.920
The one case where something good happens
is if we're changing from portrait to

00:21:20.920 --> 00:21:23.500
landscape or from landscape to portrait.

00:21:23.550 --> 00:21:28.000
And we make that test and verify that
that is in fact what we're doing.

00:21:28.070 --> 00:21:31.910
And if so, we simply set the width to the
height and the height to the width

00:21:32.310 --> 00:21:36.400
and we reverse the orientation.

00:21:42.930 --> 00:21:46.800
Quit the copy that we had running
and build and run a new one.

00:21:46.800 --> 00:21:55.800
Okay, and again, Sketch comes up.

00:21:55.950 --> 00:21:58.640
We draw a couple of rectangles.

00:21:59.350 --> 00:22:02.240
Try hard to draw a square here.

00:22:02.240 --> 00:22:03.230
See how well I did?

00:22:03.450 --> 00:22:05.240
Not too bad.

00:22:05.240 --> 00:22:09.280
And now that's a square.

00:22:11.410 --> 00:22:15.400
We'll go back to the script editor.

00:22:15.400 --> 00:22:17.280
Close that script.

00:22:18.400 --> 00:22:23.900
[Transcript missing]

00:22:31.500 --> 00:22:33.840
That's a little easier to read.

00:22:33.870 --> 00:22:36.300
Here's our test for orientation.

00:22:36.360 --> 00:22:38.260
We're going to look at
what the orientation is,

00:22:38.290 --> 00:22:43.050
which will cause us to
call the "get" accessor,

00:22:43.050 --> 00:22:45.340
and then we're going to
set it to what it wasn't,

00:22:45.340 --> 00:22:48.500
which will cause us to
call the "set" accessor.

00:22:48.500 --> 00:22:53.960
And if everything's working right,
we should see the logging

00:22:53.960 --> 00:22:53.960
happening down here while we do it.

00:22:56.090 --> 00:22:59.390
So, as you can see,
these two rectangles have

00:22:59.390 --> 00:23:01.640
changed their orientation.

00:23:01.640 --> 00:23:06.710
And down here in the log,
we can see that the Rectangles

00:23:06.750 --> 00:23:10.940
accessor is being called,
the Orientation accessor is being called,

00:23:11.000 --> 00:23:14.500
and the Set Orientation
accessor is also being called.

00:23:14.590 --> 00:23:17.300
So everything we expect to have happen,
happened.

00:23:17.420 --> 00:23:21.310
And now we're learning something about
the order in which these things occur,

00:23:21.310 --> 00:23:24.460
and we're learning how to map
what happens in the log back

00:23:24.560 --> 00:23:25.990
to what happens in the script.

00:23:28.490 --> 00:23:31.250
And you can see we even
generated an error.

00:23:31.540 --> 00:23:34.900
We tried to set the orientation
of rectangle 1 to 5.

00:23:34.940 --> 00:23:37.040
That's obviously not going to work.

00:23:37.170 --> 00:23:41.590
And sure enough,
we got an error when we tried to do that.

00:23:41.700 --> 00:23:46.380
And I'll show you exactly
how we saw that error.

00:23:48.870 --> 00:23:54.620
We set a variable to an error
value and then here at the bottom

00:23:57.320 --> 00:24:03.900
We went and found the
"reply" Apple event,

00:24:03.900 --> 00:24:06.100
which is hanging around
ready for your use.

00:24:06.100 --> 00:24:10.390
We went and found that by asking
the Apple Event Manager for

00:24:10.390 --> 00:24:14.170
its single shared instance,
getting the current "reply"

00:24:14.310 --> 00:24:16.950
Apple event from that,
creating a descriptor with

00:24:16.950 --> 00:24:21.440
our error number in it,
and then sticking that in the "reply"

00:24:21.440 --> 00:24:24.290
event with the key error number.

00:24:24.350 --> 00:24:29.180
What happens is Cocoa scripting takes
that and sends it back to the descriptor

00:24:29.180 --> 00:24:32.000
as the result of this operation.

00:24:32.000 --> 00:24:35.270
Since the event has an error in it,
the script editor will report that error.

00:24:38.160 --> 00:24:42.000
Okay,
if we can go back to the slides please.

00:24:42.000 --> 00:24:44.710
Okay, so that's Property Accessors.

00:24:45.690 --> 00:24:47.750
Now commands.

00:24:47.750 --> 00:24:51.230
Apple Script has a set of,
depending upon how you count them,

00:24:51.310 --> 00:24:54.920
13 to 15 built-in verbs.

00:24:54.920 --> 00:24:57.110
And we encourage people

00:24:57.130 --> 00:24:59.430
"To use those to the
greatest extent possible.

00:24:59.450 --> 00:25:03.640
Most of the things you need to do are
going to be accomplished by those verbs.

00:25:03.650 --> 00:25:06.050
As a matter of fact,
Sketch is considered to be a

00:25:06.100 --> 00:25:10.510
fully scriptable application and
it does not add any commands at

00:25:10.510 --> 00:25:14.140
all before today." Get and Set.

00:25:14.280 --> 00:25:16.530
As we just saw,
you can use Get and Set of a

00:25:16.550 --> 00:25:20.100
property like Orientation to actually
change the shape of an object.

00:25:20.100 --> 00:25:22.100
You don't need a Change Shape verb.

00:25:22.100 --> 00:25:26.100
You can just change a property which
would cause it to change its shape.

00:25:26.100 --> 00:25:27.800
That's the way we like you to do things.

00:25:27.880 --> 00:25:29.970
We like you to use Get and
Set as much as possible.

00:25:30.070 --> 00:25:33.100
If you've got some kind of persistent
state that you want to start and stop,

00:25:33.100 --> 00:25:35.100
you don't need a verb to do it.

00:25:35.100 --> 00:25:37.910
You just need a Boolean that
you can turn on and off.

00:25:38.100 --> 00:25:41.820
But, that being said,
every application does something

00:25:41.820 --> 00:25:44.080
that no other application does.

00:25:44.180 --> 00:25:50.090
Every application does something
that isn't in that set of 13 verbs.

00:25:50.090 --> 00:25:53.610
In this case, since we're talking
about a graphics program,

00:25:53.610 --> 00:25:55.090
Rotate is one of them.

00:25:55.100 --> 00:25:56.030
Where did we find Rotate?

00:25:56.140 --> 00:25:57.080
We found it in the menu bar.

00:25:57.080 --> 00:26:00.100
Rotate is a menu command
inside of Sketch.

00:26:00.100 --> 00:26:03.570
It's something that Sketch can do,
but the scripting up until now

00:26:03.570 --> 00:26:05.100
didn't have any name for it.

00:26:05.250 --> 00:26:07.090
Alignment is the same thing.

00:26:07.090 --> 00:26:10.730
Alignment is something that's in
the menu bar of Sketch and now we're

00:26:10.950 --> 00:26:13.100
going to make it scriptable as well.

00:26:13.100 --> 00:26:16.450
The difference here is Rotate
acts on single objects.

00:26:16.450 --> 00:26:19.860
Even if you want Rotate to act
on a collection of objects,

00:26:19.860 --> 00:26:21.830
it can act on each of them singly.

00:26:21.990 --> 00:26:24.100
The objects themselves don't
need to know anything else.

00:26:24.100 --> 00:26:26.510
They don't need to know anything
else other than that they're

00:26:26.510 --> 00:26:28.100
supposed to Rotate and by how much.

00:26:28.100 --> 00:26:31.060
So that's an excellent candidate
for object-first dispatching.

00:26:31.130 --> 00:26:34.130
All we really need to do is tell
each and every object that we

00:26:34.130 --> 00:26:36.100
care about to go ahead and Rotate.

00:26:36.100 --> 00:26:38.100
Alignment is a different deal.

00:26:38.100 --> 00:26:41.100
The alignment has to be to something.

00:26:41.100 --> 00:26:45.280
In the case of Sketch,
the first element in the array,

00:26:45.280 --> 00:26:49.030
which turns out to be the
last graphic that you created,

00:26:49.540 --> 00:26:53.100
is the match point.

00:26:53.100 --> 00:26:55.100
The match point is the line to that.

00:26:55.100 --> 00:26:59.100
But you can't send an align
command to a collection.

00:26:59.100 --> 00:27:01.100
You have to send the
align command somewhere.

00:27:01.100 --> 00:27:02.950
We do it with verb-first dispatching.

00:27:02.950 --> 00:27:05.090
We send the align command
to a verb handler.

00:27:05.090 --> 00:27:08.540
The verb handler finds the collection
of objects that needs to be

00:27:08.610 --> 00:27:14.050
aligned and performs the operation
collectively on all of them at once.

00:27:14.870 --> 00:27:18.820
So, in object-first dispatching
you're going to want to have an

00:27:18.820 --> 00:27:22.970
entry in your SDEF that looks
something along the lines of this.

00:27:22.970 --> 00:27:26.560
And if you were at 103 yesterday
you saw pretty much exactly this.

00:27:26.590 --> 00:27:29.180
The human readable name of this
command is going to be "rotate"

00:27:29.180 --> 00:27:30.670
and that's highlighted up there.

00:27:30.860 --> 00:27:35.630
The kind of object that it's going
to create is an NS script command,

00:27:35.630 --> 00:27:39.170
which is the generic handler
for all incoming verbs.

00:27:39.380 --> 00:27:40.700
This is actually the default.

00:27:40.700 --> 00:27:42.990
We could have just as easily
left it out of this entry,

00:27:43.000 --> 00:27:46.140
but I put it up there to show you
a distinction between this and how

00:27:46.140 --> 00:27:50.040
the verb-first dispatching works,
which we'll see in a moment.

00:27:50.120 --> 00:27:51.950
There's also going to
need to be a parameter,

00:27:51.950 --> 00:27:55.030
"rotate acts on a collection of
objects," but we also need to tell

00:27:55.160 --> 00:27:57.150
them how much we want them to rotate.

00:27:57.250 --> 00:28:01.000
So we also support a parameter,
which in this case is a number,

00:28:01.020 --> 00:28:04.780
the number of degrees through
which to rotate the object.

00:28:06.110 --> 00:28:11.730
Since this is object-first dispatching,
we're going to need to say which

00:28:11.730 --> 00:28:13.390
objects know how to rotate.

00:28:13.480 --> 00:28:19.000
As it turns out,
all Sketch graphics know how to rotate.

00:28:19.000 --> 00:28:22.360
Back in the definition
of the GraphicsObject,

00:28:22.890 --> 00:28:27.110
which is the base class for all
of the various shapes in Sketch,

00:28:27.200 --> 00:28:32.000
we're going to say that GraphicsObjects
respond to the Rotate command.

00:28:32.140 --> 00:28:37.790
They do so by calling the
"Rotate:" method on the object.

00:28:38.000 --> 00:28:43.000
Then, of course, the object itself has to
have a "Rotate:" method.

00:28:43.000 --> 00:28:48.840
You'll notice that the handler for
an object-first dispatch receives

00:28:49.580 --> 00:28:52.770
the NSScript command as its input.

00:28:53.000 --> 00:28:56.580
That's because you'll need to be
able to probe the NSScript command

00:28:57.000 --> 00:29:00.380
to find out what the parameters
are and other information about

00:29:00.380 --> 00:29:01.980
what it is you're supposed to do.

00:29:02.000 --> 00:29:04.960
You only get one input,
but it's one very powerful input

00:29:04.960 --> 00:29:06.990
that has a lot of information in it.

00:29:07.000 --> 00:29:13.000
Now we're going to go back to Demo 2
and look at object-first dispatching.

00:29:25.700 --> 00:29:32.350
So again,
I'm going to add a couple of files.

00:29:32.960 --> 00:29:38.270
To my project,
rectangle rotate .h and .m.

00:29:46.710 --> 00:29:48.750
And as you can see,
what we're going to do is we're

00:29:48.750 --> 00:29:54.050
going to add a single method to the
SKT rectangle object that already exists.

00:29:54.190 --> 00:29:56.840
We're going to do it
by adding a category,

00:29:56.910 --> 00:30:00.140
and the method that we're going
to add is called "rotate:" and its

00:30:00.140 --> 00:30:02.980
sole input is an NSScript command.

00:30:05.200 --> 00:30:06.840
And here's the implementation.

00:30:06.840 --> 00:30:09.950
We have our same definition
for orientations,

00:30:09.950 --> 00:30:14.440
which I'm not sure we're going to use.

00:30:14.440 --> 00:30:18.190
And this is the implementation.

00:30:21.240 --> 00:30:24.310
These two lines show you why you
need that command as an input.

00:30:24.420 --> 00:30:26.680
The command has something
called evaluated arguments,

00:30:26.680 --> 00:30:27.600
and these are very nice.

00:30:27.600 --> 00:30:31.460
Cocoa scripting has already gone through
the incoming arguments and done as much

00:30:31.560 --> 00:30:33.840
resolution on them as it possibly can.

00:30:33.840 --> 00:30:37.000
If one of your incoming
arguments is an object,

00:30:37.190 --> 00:30:41.360
is a scriptable Cocoa object,
it will have already been resolved.

00:30:41.360 --> 00:30:47.440
So instead of getting an Apple descriptor
of which object you should be acting on,

00:30:47.460 --> 00:30:50.430
Cocoa scripting will resolve that and
actually give you the object itself.

00:30:50.530 --> 00:30:54.150
It saves a lot of time,
it saves a lot of messing around.

00:30:54.530 --> 00:30:59.640
Whenever Cocoa scripting can
evaluate an incoming object for you,

00:30:59.710 --> 00:31:00.500
it will.

00:31:00.520 --> 00:31:02.540
Since our incoming
object is just a number,

00:31:02.730 --> 00:31:04.900
there isn't much for
Cocoa scripting to do.

00:31:04.930 --> 00:31:11.770
We get the evaluated arguments
and then from inside the evaluated

00:31:11.770 --> 00:31:11.770
arguments we get the "by degrees"

00:31:11.940 --> 00:31:13.850
"The first step is to
create a scripting object,

00:31:13.850 --> 00:31:14.940
which turns out to be an NSNumber.

00:31:14.970 --> 00:31:17.390
Before we go any farther,
we make absolutely sure

00:31:17.390 --> 00:31:22.390
that it is an NSNumber,
and if so, we pull the value out."

00:31:23.570 --> 00:31:25.940
And then we do some algebra.

00:31:25.940 --> 00:31:28.250
I know you thought you'd
never use your algebra again,

00:31:28.360 --> 00:31:29.600
but you will.

00:31:29.670 --> 00:31:32.340
And we're going to make
some restrictions here.

00:31:32.340 --> 00:31:37.740
We're only going to allow rotation
by even multiples of 90 degrees.

00:31:37.790 --> 00:31:43.130
So this calculation here determines
whether or not we're going to have

00:31:43.130 --> 00:31:45.840
an even number of 90 degree turns.

00:31:45.840 --> 00:31:52.860
And this calculation here normalizes
that to some number between 0 and 4.

00:31:52.890 --> 00:31:56.420
Well, if you rotate something
an even number of turns,

00:31:56.420 --> 00:31:57.420
it doesn't actually change.

00:31:57.450 --> 00:31:59.520
If you rotate a rectangle
an even number of turns,

00:31:59.530 --> 00:32:01.160
it doesn't actually change shape.

00:32:01.180 --> 00:32:04.160
So we're just going to skip
those and not do anything.

00:32:04.180 --> 00:32:08.270
But if we're rotating
an odd number of turns,

00:32:08.330 --> 00:32:09.860
then there's some work to do.

00:32:09.870 --> 00:32:13.410
And what this calculation
here does effectively

00:32:14.220 --> 00:32:19.100
The first thing we'll talk about is
the "Compute Rectangle" function.

00:32:19.100 --> 00:32:23.410
It computes the original center of the
rectangle and puts it back where it

00:32:23.410 --> 00:32:26.100
started originally based on its center.

00:32:26.100 --> 00:32:29.010
As we rotate the rectangle,
it doesn't rotate around

00:32:29.010 --> 00:32:32.100
one of its corners,
it rotates around its own center.

00:32:32.230 --> 00:32:36.610
Again, there's the possibility that we
could get some data in that's not

00:32:36.740 --> 00:32:40.420
going to be meaningful since we're
only allowing 90 degree turns.

00:32:40.420 --> 00:32:47.760
Any number other than 90, 50, 60,
70 isn't going to work.

00:32:47.940 --> 00:32:51.150
If the original input value
was not an NSNumber at all,

00:32:51.150 --> 00:32:55.740
if you had happened to pick an
enumerated value that wasn't applicable,

00:32:55.980 --> 00:32:58.990
that would also generate an error.

00:32:59.160 --> 00:33:01.780
Returning the error is a
little bit simpler here.

00:33:01.780 --> 00:33:05.900
Since we have access
to the command itself,

00:33:05.900 --> 00:33:09.860
all we actually need to do is
tell it to set the error number.

00:33:09.960 --> 00:33:12.810
There's a little bit less work to
do because you've already got the

00:33:12.850 --> 00:33:14.450
command; it's one of your inputs.

00:33:14.690 --> 00:33:24.780
So that's a little bit easier.

00:33:33.100 --> 00:33:37.340
We'll sketch again.

00:33:37.340 --> 00:33:40.100
And we'll draw our rectangles again.

00:33:40.100 --> 00:33:45.700
And we'll move on to our next test.

00:33:56.110 --> 00:33:59.700
So as you can see in this test,
we're going to get the

00:33:59.700 --> 00:34:01.100
orientation of every rectangle.

00:34:01.100 --> 00:34:04.690
We've already implemented that,
so we expect that to work.

00:34:04.940 --> 00:34:07.220
Then we're going to
look at each rectangle.

00:34:07.220 --> 00:34:09.490
We're going to fetch the array,
the entire collection,

00:34:09.490 --> 00:34:14.530
and keep that in an AppleScript variable
called "x". And then we're going to walk

00:34:14.600 --> 00:34:19.940
through that array and tell each of the
objects in it to rotate by 90 degrees.

00:34:20.290 --> 00:34:23.180
Then we're going to tell one of
them to rotate by 80 degrees,

00:34:23.180 --> 00:34:24.660
which should cause an error.

00:34:24.660 --> 00:34:26.660
And then we're going to
get the orientation again,

00:34:26.660 --> 00:34:28.230
and we should see all the
landscapes change to portrait,

00:34:28.230 --> 00:34:30.820
and all the portraits
change to landscape.

00:34:30.820 --> 00:34:32.640
That's the theory.

00:34:33.720 --> 00:34:36.960
And that's pretty much what we got.

00:34:37.070 --> 00:34:38.910
As you can see,

00:34:39.250 --> 00:34:43.080
The orientation started out landscape,
landscape, portrait,

00:34:43.080 --> 00:34:44.960
and now it's portrait, portrait,
landscape.

00:34:44.960 --> 00:34:46.650
That's exactly what we expected.

00:34:46.890 --> 00:34:52.360
And the one erroneous input
value did indeed return an error.

00:34:52.470 --> 00:34:57.500
So our error reporting is working,
our rotating is working,

00:34:57.590 --> 00:34:59.800
and our logging is working.

00:35:00.260 --> 00:35:05.380
We can see that the rotate
command did in fact get called.

00:35:06.020 --> 00:35:11.140
And Cocoa scripting,
since this is a development software,

00:35:11.140 --> 00:35:13.700
will log some of its activities as well.

00:35:13.830 --> 00:35:17.790
So you can see what Cocoa scripting
is doing interleaved with what you're

00:35:17.790 --> 00:35:20.290
doing and that can be very informative.

00:35:21.000 --> 00:35:24.680
So, back to the slides please.

00:35:24.680 --> 00:35:28.420
So that's an object-first
dispatching command.

00:35:29.090 --> 00:35:31.740
There's another kind of command,
verb-first dispatching,

00:35:31.740 --> 00:35:35.600
and that's going to have a slightly
different dictionary entry.

00:35:35.650 --> 00:35:38.540
In this case the verb is going to be
called "align" so the human readable

00:35:38.620 --> 00:35:40.960
term "align" is highlighted there.

00:35:41.030 --> 00:35:44.110
But the Cocoa class that we're
going to use to implement this

00:35:44.110 --> 00:35:48.360
is no longer NSScriptCommand,
it's going to be SKTAlignCommand.

00:35:48.430 --> 00:35:51.330
SKTAlignCommand is going to
inherit from NSScriptCommand,

00:35:51.330 --> 00:35:54.750
but it's going to add some additional
functionality that allows this

00:35:54.750 --> 00:35:56.960
to be a verb-first dispatch.

00:35:57.020 --> 00:35:59.980
We're going to need another parameter,
we need an edge to which

00:35:59.980 --> 00:36:01.220
to align everything.

00:36:01.290 --> 00:36:05.350
If you saw session 103 you know
that that's also implemented as

00:36:05.350 --> 00:36:09.820
an enumeration and gives us six
different choices of how to align.

00:36:12.540 --> 00:36:17.050
When we do our support for
our verb-first dispatching,

00:36:17.090 --> 00:36:19.600
we're going to create a
subclass of NSScriptCommand

00:36:19.820 --> 00:36:23.400
and we're going to override its
"performDefaultImplementation" method.

00:36:23.400 --> 00:36:25.390
And so here's the code to do that.

00:36:25.410 --> 00:36:28.290
We're not going to add any
instance variables to this at all.

00:36:28.290 --> 00:36:33.330
We're just going to override one method.

00:36:33.470 --> 00:36:38.380
And so if we can go back to demo 2,
we'll do some verb-first dispatching.

00:36:48.480 --> 00:36:50.570
One more time.

00:36:50.780 --> 00:36:57.100
We will be adding two
files to our project.

00:37:02.200 --> 00:37:04.560
You can see here pretty much
exactly what you saw on the slide.

00:37:04.560 --> 00:37:10.850
We're creating a subclass of
NSScriptCommand and we're going

00:37:11.360 --> 00:37:17.300
to define one method and that's
performDefaultImplementation.

00:37:22.280 --> 00:37:26.140
So here you can see we've
got six different choices

00:37:26.330 --> 00:37:27.890
of what it is you can do.

00:37:30.120 --> 00:37:32.990
And so as we move down here
we're going to have six

00:37:33.030 --> 00:37:35.130
different ways of handling it.

00:37:35.260 --> 00:37:38.000
But there's some important
stuff that we have to do first.

00:37:38.000 --> 00:37:41.220
In verb-first dispatching,
Cocoa scripting doesn't

00:37:41.220 --> 00:37:43.000
help you out quite so much.

00:37:43.220 --> 00:37:48.000
When you get the direct parameter,
it may not be as fully evaluated

00:37:48.000 --> 00:37:52.000
as it would normally be in
an object-first dispatching.

00:37:52.360 --> 00:37:55.820
Obviously, object-first dispatching,
the direct parameter's been fully

00:37:56.010 --> 00:37:59.740
reconciled by Cocoa scripting because
the direct parameter is the object

00:37:59.870 --> 00:38:01.980
that actually receives the message.

00:38:02.000 --> 00:38:05.000
In verb-first dispatching
it's not so simple.

00:38:05.040 --> 00:38:08.990
So you're going to need to get
the direct parameter yourself.

00:38:09.000 --> 00:38:13.960
When you're doing verb-first dispatching,
you don't get any inputs.

00:38:14.040 --> 00:38:18.560
But you don't need them because
the verb-first dispatching handler

00:38:18.560 --> 00:38:20.760
is itself the NS script command.

00:38:21.110 --> 00:38:24.100
So if you need anything
from NS script command,

00:38:24.100 --> 00:38:26.000
you get it from yourself.

00:38:26.000 --> 00:38:30.000
So anything in object-first dispatching
that would refer to the command,

00:38:30.120 --> 00:38:33.000
in verb-first dispatching
you refer to self instead.

00:38:33.000 --> 00:38:35.930
So you grab your direct parameter
and now we're going to look at it.

00:38:35.990 --> 00:38:40.000
It can be any one of,
and here's an instance of,

00:38:40.000 --> 00:38:42.000
I'm logging something
about what's going on.

00:38:42.000 --> 00:38:44.640
I'm not just logging the
fact that we arrived here.

00:38:44.640 --> 00:38:48.060
I'm logging what my direct parameter
looks like because if I have any

00:38:48.060 --> 00:38:51.410
trouble handling my direct parameter,
it might be because I'm seeing a new

00:38:51.410 --> 00:38:52.930
case that hadn't occurred before.

00:38:53.070 --> 00:38:56.720
So if I log what the direct parameter is,
it's going to help me

00:38:56.720 --> 00:38:58.890
find some bugs later on.

00:38:59.550 --> 00:39:03.230
When I'm done,
I know that what I'm going to end up

00:39:03.640 --> 00:39:06.000
with is an array of graphics objects.

00:39:06.080 --> 00:39:09.680
So I create an empty array here
to collect them as I find them.

00:39:09.890 --> 00:39:11.790
Then there's a couple of possibilities.

00:39:11.890 --> 00:39:16.000
If the direct parameter
is itself an array,

00:39:16.080 --> 00:39:18.450
then I'm going to want to
iterate through that array and

00:39:18.510 --> 00:39:19.870
find out what's inside of it.

00:39:20.060 --> 00:39:20.690
And so I do that.

00:39:20.690 --> 00:39:27.590
I create an enumerator for that array and
I start to walk through the array itself.

00:39:28.680 --> 00:39:35.330
Now what turns out to be inside of this
array is NS Script Object Specifiers.

00:39:35.430 --> 00:39:39.800
What these are is unresolved
pointers to your objects.

00:39:39.910 --> 00:39:42.810
Cocoa scripting hasn't taken a look
at these yet to try to figure out

00:39:42.810 --> 00:39:44.580
which objects they really represent.

00:39:45.110 --> 00:39:48.600
You're receiving an array of
just the pointers themselves.

00:39:48.600 --> 00:39:51.780
But Cocoa scripting is still your friend.

00:39:51.780 --> 00:39:55.600
In one line we can ask
Cocoa scripting to tell us,

00:39:55.600 --> 00:40:00.080
"Okay, resolve this thing and give me the
object that it really points to."

00:40:01.510 --> 00:40:05.530
It could occur that
that itself is an array,

00:40:05.530 --> 00:40:08.680
because there are such
things as range specifiers.

00:40:08.680 --> 00:40:11.370
Every rectangle from 3 to 5.

00:40:11.500 --> 00:40:14.300
That's actually going to give you back
an array of three different rectangles.

00:40:14.400 --> 00:40:16.770
So you're going to want to
notice if that's happening,

00:40:16.880 --> 00:40:19.160
and if that's the case,
you're going to want to add that

00:40:19.160 --> 00:40:22.400
entire array to the end of your
collection as you're building it up.

00:40:22.400 --> 00:40:26.210
And if it's just a single object,
you'll add that to the end of your array.

00:40:26.400 --> 00:40:29.690
So, by the time we get to here,
we actually know the

00:40:30.330 --> 00:40:33.400
collection of objects that
we're going to be working on.

00:40:33.400 --> 00:40:36.400
And that's really the purpose
of verb-first dispatching,

00:40:36.400 --> 00:40:39.400
is we're going to act on a
bunch of objects all at once.

00:40:39.400 --> 00:40:42.220
And it's up to us,
we have to do a little bit of coding

00:40:42.220 --> 00:40:44.400
to find out what those objects are.

00:40:44.400 --> 00:40:48.400
Now we're pretty much back
to where we were before.

00:40:48.400 --> 00:40:50.290
We know the collection
that we're going to act on,

00:40:50.400 --> 00:40:52.380
now we just need to know
what it is we're going to do.

00:40:52.400 --> 00:40:56.400
So we get the evaluated arguments,
and we get the edge arguments.

00:40:56.400 --> 00:40:58.400
And we get the argument from out of that.

00:40:58.400 --> 00:41:03.950
And that should be an NSNumber with a
long value that corresponds to one of

00:41:03.950 --> 00:41:06.400
those 4 byte codes that we defined.

00:41:06.520 --> 00:41:10.390
And there's different,
we're going to switch on that value

00:41:10.390 --> 00:41:12.400
and do one of six different things.

00:41:12.400 --> 00:41:14.400
I'm not going to go
through all six of them.

00:41:14.640 --> 00:41:18.400
But again, you get to use your algebra.

00:41:18.420 --> 00:41:20.310
We're going to...

00:41:20.930 --> 00:41:23.020
I've already done this here.

00:41:23.100 --> 00:41:26.460
I've grabbed the bounds of the
first element of the array.

00:41:26.500 --> 00:41:27.900
That's going to be the master.

00:41:27.900 --> 00:41:30.900
That's the fixed point to which
all the others are going to align.

00:41:31.190 --> 00:41:34.210
Then when I get down here,
I'm going to iterate through

00:41:34.210 --> 00:41:37.650
the entire collection and
align them all to the original.

00:41:37.900 --> 00:41:42.230
The smart students have already
figured out I could have started

00:41:42.230 --> 00:41:44.900
with the second member of the array.

00:41:45.040 --> 00:41:48.670
We do a little bit of algebra here
and we align the objects to the

00:41:48.670 --> 00:41:50.780
first object in the collection.

00:41:50.900 --> 00:41:54.040
As you can see,
we do that one of six different ways,

00:41:54.040 --> 00:41:57.900
depending upon which edge it is
they've asked us to align to.

00:41:57.900 --> 00:42:05.420
Let's build that.

00:42:16.070 --> 00:42:18.970
And this time we're going to go nuts.

00:42:19.110 --> 00:42:22.420
We're going to make some rectangles.

00:42:22.420 --> 00:42:26.250
We're going to make some circles, ovals.

00:42:26.500 --> 00:42:29.240
We're going to add some lines.

00:42:30.900 --> 00:42:36.530
And then we're going to run our
test script to align these things.

00:42:46.100 --> 00:43:57.500
[Transcript missing]

00:44:01.330 --> 00:44:02.610
Run that.

00:44:02.770 --> 00:44:05.440
And sure enough they align part way.

00:44:05.470 --> 00:44:07.940
And then boom,
they align the rest of the way.

00:44:07.940 --> 00:44:10.840
So now all of these objects
are aligned by both their

00:44:10.840 --> 00:44:13.010
vertical and horizontal centers.

00:44:14.000 --> 00:44:19.200
And again,
you can see down here in the log,

00:44:19.230 --> 00:44:22.360
we've got lots of information,
including some that Sketch itself

00:44:22.660 --> 00:44:26.170
logs about the size and
shapes of various objects.

00:44:26.280 --> 00:44:31.670
So again, you can see your scriptability
code running interleaved with

00:44:31.850 --> 00:44:35.530
the Cocoa scripting logging that
goes on in a developer version,

00:44:35.530 --> 00:44:40.970
in a developer install of the OS,
and also any logging that the

00:44:40.970 --> 00:44:45.060
application might already be
doing for its own purposes.

00:44:45.900 --> 00:44:49.180
Again, like I said,
this can be very educational.

00:44:49.200 --> 00:44:52.120
The patterns by which
Cocoa scripting calls your

00:44:52.120 --> 00:44:55.630
accessors are very predictable,
but you need to learn what they are.

00:44:55.860 --> 00:44:58.340
And then when you see
something unpredictable occur,

00:44:58.370 --> 00:45:01.280
that's your hint that maybe
something's going wrong.

00:45:01.480 --> 00:45:05.610
and you need to step more carefully and
more closely through your code and make

00:45:05.650 --> 00:45:08.060
sure it's doing what you want it to do.

00:45:08.320 --> 00:45:11.440
If we can go back to the slides please.

00:45:11.560 --> 00:45:13.550
So that's verb-first dispatching.

00:45:13.550 --> 00:45:17.620
You should use verb-first
dispatching where it's appropriate,

00:45:17.620 --> 00:45:22.200
but you should always try to use
object-first dispatching if you can.

00:45:24.310 --> 00:45:28.120
There are other aspects of handling
commands that may or may not apply

00:45:28.120 --> 00:45:29.660
to your particular application.

00:45:29.660 --> 00:45:34.260
If you've got some long-running process,
if your application is threaded,

00:45:34.260 --> 00:45:37.340
if you have to wait for things
to come in across a network,

00:45:37.400 --> 00:45:42.120
then you might need to suspend an
Apple event while it's in the process

00:45:42.140 --> 00:45:46.140
of being handled and resume it later
on when you've finally got the answer.

00:45:46.160 --> 00:45:48.380
There's a relatively easy way to do that.

00:45:48.460 --> 00:45:52.290
In an object-first dispatch,
you can just say command

00:45:52.290 --> 00:45:53.980
suspend execution.

00:45:54.410 --> 00:45:57.930
And in a verb-first,
you say self suspend execution.

00:45:57.940 --> 00:46:00.800
At some point later,
your program will receive a

00:46:00.810 --> 00:46:03.970
callback from some long-running
function to say I'm done.

00:46:03.980 --> 00:46:06.600
And at that point,
you can simply resume the command

00:46:06.600 --> 00:46:09.710
and pass back whatever response
you would have passed back had

00:46:09.730 --> 00:46:11.450
you handled it synchronously.

00:46:11.460 --> 00:46:13.970
If you need to do this kind of thing,
come to the lab.

00:46:14.100 --> 00:46:15.280
We can show you how to do it.

00:46:15.280 --> 00:46:18.630
It's not hard, but it can be very,
very important for certain

00:46:18.630 --> 00:46:20.080
kinds of applications.

00:46:23.710 --> 00:46:26.130
As we've been going along here,
I've been showing you

00:46:26.220 --> 00:46:27.220
little test scripts.

00:46:27.580 --> 00:46:30.960
When you write these test scripts,
you're going to want to cover your

00:46:30.960 --> 00:46:32.840
code as much as you possibly can.

00:46:33.070 --> 00:46:36.410
When you're writing a test
script to access elements,

00:46:36.540 --> 00:46:39.920
you want to get those elements,
and you want to get them as

00:46:40.060 --> 00:46:41.840
many different ways as you can.

00:46:42.000 --> 00:46:45.030
You'll want to get every
element of a certain kind.

00:46:45.030 --> 00:46:47.430
That'll call your simple accessor.

00:46:47.620 --> 00:46:51.830
You'll also want to get elements by name,
by ID, and by index.

00:46:51.840 --> 00:46:54.000
If you've provided the
accelerated accessors,

00:46:54.020 --> 00:46:54.870
they'll get called.

00:46:55.220 --> 00:46:57.660
If you haven't,
Cocoa scripting will do the

00:46:57.660 --> 00:46:59.500
necessary look-ups for you.

00:47:00.790 --> 00:47:04.800
You're also going to want to
call your setting accessors.

00:47:04.870 --> 00:47:06.730
You're going to want to make
sure that you make a new object

00:47:06.730 --> 00:47:08.240
of each kind that you support.

00:47:08.390 --> 00:47:10.390
You're going to want to make
sure that you delete an object

00:47:10.400 --> 00:47:11.570
of each kind you support.

00:47:11.740 --> 00:47:13.440
You're going to want to
delete from the beginning,

00:47:13.440 --> 00:47:15.080
the end,
and the middle of your collection.

00:47:15.130 --> 00:47:16.590
Make sure that all works.

00:47:16.750 --> 00:47:22.260
You're going to want to do
a replace in place if that's

00:47:22.260 --> 00:47:22.260
something that you support.

00:47:22.260 --> 00:47:22.260
Not every application does.

00:47:23.430 --> 00:47:25.400
For properties, the same thing.

00:47:25.400 --> 00:47:27.520
You're going to want to get
all the properties all at once

00:47:27.520 --> 00:47:32.350
by using "getProperties" which
is something Cocoa scripting,

00:47:32.350 --> 00:47:34.000
again, is your friend.

00:47:34.000 --> 00:47:37.080
"getProperties" is not something
that you define in your code,

00:47:37.400 --> 00:47:41.600
but if an Apple script comes in that
says "getProperties" Cocoa scripting will

00:47:41.600 --> 00:47:46.120
call your object over and over again,
once for each property accessor,

00:47:46.170 --> 00:47:48.930
make a record out of that
and pass it back to the user.

00:47:49.040 --> 00:47:50.640
But you want to make
sure that that works.

00:47:50.640 --> 00:47:52.320
You want to make sure
that Cocoa scripting is

00:47:52.320 --> 00:47:53.700
calling the right routines.

00:47:53.790 --> 00:47:57.410
You'll also want to get at each
of the properties by their name.

00:47:57.490 --> 00:47:59.100
So you're going to want to
get the height of a rectangle,

00:47:59.100 --> 00:48:00.560
you're going to want to get the width,
you're going to want

00:48:00.700 --> 00:48:01.580
to get the fill color.

00:48:01.700 --> 00:48:04.230
You want to exercise
each one of those things.

00:48:04.270 --> 00:48:07.300
Make sure that you touch each
of the leaves in the tree.

00:48:08.410 --> 00:48:11.300
You're going to want to write
test scripts that set your values,

00:48:11.300 --> 00:48:13.120
but you're going to want
them to be repeatable.

00:48:13.140 --> 00:48:16.690
So you're going to want to do a "get
set reset" kind of pattern where you

00:48:16.690 --> 00:48:18.190
leave things the way you found them.

00:48:18.300 --> 00:48:20.720
So that this script can be run
over and over and over again

00:48:20.720 --> 00:48:22.060
and give the same results.

00:48:22.290 --> 00:48:25.620
You're going to want to take a
copy of the event log and keep

00:48:25.750 --> 00:48:30.000
that so that you can compare it to
the results you got the last time.

00:48:30.000 --> 00:48:32.640
So that you can make sure that
you haven't regressed anything.

00:48:32.700 --> 00:48:35.710
This can be very valuable whether
you're working on scripting or not.

00:48:35.710 --> 00:48:38.200
If you're making any kind of
changes to your model objects,

00:48:38.230 --> 00:48:40.530
you're going to want to
run these tests over again.

00:48:40.600 --> 00:48:44.070
Make sure that you haven't damaged
the model objects in any such way that

00:48:44.400 --> 00:48:46.220
these tests don't pass any longer.

00:48:46.340 --> 00:48:48.560
You're going to want to drive
your program to the edges.

00:48:48.560 --> 00:48:50.810
Like I said, delete the first object
in the collection,

00:48:50.810 --> 00:48:51.670
delete the last.

00:48:51.710 --> 00:48:54.970
Well you're also going to
want to set your values to the

00:48:54.970 --> 00:48:57.090
entire range that they support.

00:48:57.200 --> 00:48:59.020
And you're also going to
want to generate error cases.

00:48:59.020 --> 00:49:01.500
You're going to want to set your values
to things that they don't support.

00:49:01.600 --> 00:49:02.590
And make sure that something
is in the right place.

00:49:02.600 --> 00:49:04.200
Make sure that something
sensible happens.

00:49:04.240 --> 00:49:08.200
That depending upon your design,
you may want to fail silently.

00:49:08.200 --> 00:49:10.800
You may want to provide an error message.

00:49:10.810 --> 00:49:14.490
It's up to you what you think
your scripting users are

00:49:14.490 --> 00:49:16.770
going to expect you to do.

00:49:17.460 --> 00:49:19.230
For the commands,
you're going to want to exercise

00:49:19.250 --> 00:49:20.310
them thoroughly as well.

00:49:20.340 --> 00:49:22.350
For their parameters,
you're going to want to

00:49:22.350 --> 00:49:24.980
pass them parameters,
but you're also going to want to skip

00:49:24.980 --> 00:49:28.200
passing them parameters and see what
happens when they take their defaults.

00:49:28.390 --> 00:49:30.820
Make sure that that works
the way you expected it to.

00:49:30.820 --> 00:49:33.340
Again, you're going to want to
drive these commands all the

00:49:33.340 --> 00:49:35.320
way up to their edge cases,
and then you're going to

00:49:35.320 --> 00:49:37.560
want to drive them past the
edge cases and create errors.

00:49:37.640 --> 00:49:40.100
Make sure that they get handled
in a reasonable fashion.

00:49:40.100 --> 00:49:44.270
Record the results, hang on to them,
and the next time you make changes,

00:49:44.270 --> 00:49:46.620
run the scripts again and make
sure you get the same results.

00:49:47.050 --> 00:49:50.870
or if you get the differences,
you get the differences that you wanted.

00:49:53.110 --> 00:49:56.830
Then the final proof here that
you've really created something

00:49:56.830 --> 00:49:59.180
valuable is to test your use cases.

00:49:59.290 --> 00:50:03.800
You need to have at least one
and hopefully several real-world

00:50:03.860 --> 00:50:08.260
use cases that your application's
users are going to care about.

00:50:08.360 --> 00:50:10.360
Things that people have
called you up and said,

00:50:10.360 --> 00:50:13.510
gee, it would be really easy if
I had a menu command to do this.

00:50:13.520 --> 00:50:16.740
And you realize, eh,
only one guy wants that.

00:50:16.800 --> 00:50:19.180
I'm not going to make it a menu command,
but I am going to make it

00:50:19.180 --> 00:50:20.900
accessible through scriptability.

00:50:21.630 --> 00:50:24.820
And once I've done that,
I know I've got a customer out there

00:50:24.980 --> 00:50:29.860
that's depending upon that working just
as much as if it were a menu command.

00:50:29.860 --> 00:50:34.080
He's going to consider my application
to be broken if that script breaks

00:50:34.080 --> 00:50:38.280
just as much as some other user is
going to consider my application

00:50:38.350 --> 00:50:41.670
to be broken if they pull down
the print menu and it won't print.

00:50:41.740 --> 00:50:44.210
Once you've added a feature
through scriptability,

00:50:44.220 --> 00:50:48.010
you have to preserve that feature just
like any other feature of your program.

00:50:48.020 --> 00:50:51.480
So you're going to want to test your
real-world cases over and over again.

00:50:51.480 --> 00:50:53.010
Make sure they're repeatable.

00:50:53.160 --> 00:50:56.790
Make sure that they set themselves back
the way they were when they started.

00:50:56.860 --> 00:50:58.510
And when you run them
over and over again,

00:50:58.510 --> 00:51:00.740
you want to get the same
results over and over again.

00:51:03.290 --> 00:51:05.690
So, to review,
here's what we talked about today.

00:51:05.740 --> 00:51:06.720
We talked about logging.

00:51:06.850 --> 00:51:08.600
I think it's very important.

00:51:08.720 --> 00:51:12.490
It's hard to know what Cocoa scripting
is asking of you unless you

00:51:12.490 --> 00:51:16.200
log your activities when you
respond to Cocoa scripting.

00:51:16.210 --> 00:51:18.260
We talked about element accessors.

00:51:18.280 --> 00:51:22.200
This is how the scripter gets at
the objects inside your application.

00:51:22.200 --> 00:51:25.090
Element accessors are what make
AppleScript object-oriented.

00:51:25.790 --> 00:51:29.590
Property accessors are important
because one object is pretty much the

00:51:29.590 --> 00:51:33.400
same as another except for its size,
shape, color, etc.

00:51:34.100 --> 00:51:37.140
We've talked about commands
and the two different kinds:

00:51:37.140 --> 00:51:39.800
object-first dispatching
and verb-first dispatching.

00:51:39.800 --> 00:51:42.430
You will find instances of
both in your program and you'll

00:51:42.430 --> 00:51:44.000
need to learn to support both.

00:51:44.000 --> 00:51:47.340
We've talked about the importance
of automated regression testing,

00:51:47.340 --> 00:51:50.110
how it can help you make sure
your scriptability works.

00:51:50.160 --> 00:51:53.260
It can also help you make sure
that other parts of your program

00:51:53.320 --> 00:51:55.970
haven't regressed when you're
making changes that have nothing

00:51:55.970 --> 00:51:58.000
whatsoever to do with scriptability.

00:51:58.000 --> 00:52:01.900
And the real payoff:
testing those real-world use cases

00:52:01.900 --> 00:52:06.900
that prove that your scriptability
is of real value to your end users.

00:52:06.950 --> 00:52:12.000
Once you're locked in to an automated
workflow at your end user's site,

00:52:12.070 --> 00:52:13.920
they will never get rid of your program.

00:52:14.080 --> 00:52:17.910
They may augment your application with
others that do things differently,

00:52:17.910 --> 00:52:20.580
but as long as you're part
of an automated workflow,

00:52:20.580 --> 00:52:23.910
you're part of their collection
of applications forever.

00:52:25.340 --> 00:52:29.770
If you want to get documentation or
the sample code that I used today,

00:52:29.770 --> 00:52:33.690
you can go to this site later
today or when you get home.

00:52:33.700 --> 00:52:37.290
There's a wealth of information there
about this session and all the others.

00:52:37.320 --> 00:52:40.750
You'll be going back to this
site over and over again,

00:52:40.750 --> 00:52:41.580
I'm sure.

00:52:42.760 --> 00:52:45.780
We have a lab this
afternoon at 2 o'clock.

00:52:45.810 --> 00:52:47.760
I'm not sure exactly
physically where it is,

00:52:47.840 --> 00:52:49.700
but it's called the Apple Script Lab.

00:52:49.780 --> 00:52:52.670
And we'll be there to help
you bring your application,

00:52:52.700 --> 00:52:55.870
bring your source code,
and we'll try to help you make it

00:52:55.870 --> 00:53:00.540
scriptable at least a little bit right
here at the conference this week.

00:53:00.560 --> 00:53:03.400
And then when you go home next
week you can finish the job.

00:53:03.430 --> 00:53:04.780
Once you get started it's not hard.

00:53:04.940 --> 00:53:08.140
Once you've got a few things
working it's pretty easy to make

00:53:08.160 --> 00:53:09.760
more things work the same way.

00:53:09.760 --> 00:53:12.120
So come to the lab,
we'll get you started,

00:53:12.120 --> 00:53:15.780
and in a short period of time you'll
have a scriptable application.

00:53:16.330 --> 00:53:20.300
There are some people that you may
want to contact if you have questions

00:53:20.300 --> 00:53:22.220
after we leave here this week.

00:53:22.260 --> 00:53:26.460
Sal Segoyans, our marketing manager,
many of you probably already met him.

00:53:26.590 --> 00:53:30.580
He can tell you almost
everything you need to know.

00:53:30.620 --> 00:53:32.290
And if you need more
technical information,

00:53:32.290 --> 00:53:38.220
if you need more direct access to us,
you can contact my boss, Todd Fernandez.

00:53:38.220 --> 00:53:40.800
He's the manager of the
Apple Script and Automator group.

00:53:40.810 --> 00:53:42.420
And there's a mailing list.

00:53:42.680 --> 00:53:45.210
You can send your questions
to the mailing list.

00:53:45.420 --> 00:53:48.460
I see several people here today
that are very active on the mailing

00:53:48.960 --> 00:53:51.080
list that will help you out.

00:53:51.090 --> 00:53:53.940
People from Apple chime in,
but for the most part this is

00:53:53.990 --> 00:53:56.270
a developer community exercise.

00:53:56.450 --> 00:53:59.710
You put your question on the
Apple Script Implementers list and

00:53:59.710 --> 00:54:03.300
you'll get one or more responses from
people that have done this kind of work

00:54:03.300 --> 00:54:05.320
before and they can really help you out.
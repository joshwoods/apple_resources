WEBVTT

00:00:11.350 --> 00:00:12.320
Good morning.

00:00:12.390 --> 00:00:16.470
I'm Michael Brouwere,
engineer in the Data Security Group.

00:00:16.680 --> 00:00:21.330
I'm going to talk to you about
Smart Cards in Mac OS X today and what

00:00:21.660 --> 00:00:24.830
the state of Smart Card support is.

00:00:27.000 --> 00:00:30.990
So first I'd like to cover what
this session is going to be about.

00:00:31.110 --> 00:00:35.190
We're going to cover the
use of Smart Cards in OS X.

00:00:35.400 --> 00:00:38.140
As of Tiger,
we actually have native support

00:00:38.280 --> 00:00:41.000
for a number of different cards,
and we're going to show you

00:00:41.170 --> 00:00:45.000
where we've gotten since the
last time we presented to you.

00:00:45.000 --> 00:00:48.560
I'm going to talk about what you can
do if any of you here are -- how many

00:00:48.560 --> 00:00:50.990
of you here are application developers?

00:00:52.140 --> 00:00:56.110
So, I'm going to tell you what you need
to do if your application does any

00:00:56.130 --> 00:01:00.000
security work to have Smart Card support
enabled in your applications.

00:01:00.000 --> 00:01:06.060
And then, how many of you here are
developers of Smart Card solutions

00:01:06.060 --> 00:01:07.990
or Smart Card vendors?

00:01:09.190 --> 00:01:11.360
Alright,
so the majority of the presentation

00:01:11.410 --> 00:01:14.700
is going to go talking about
how to add support for new

00:01:14.790 --> 00:01:17.290
types of cards to Mac OS X.

00:01:17.860 --> 00:01:21.080
For which, if you application
developers do the work right,

00:01:21.080 --> 00:01:25.110
the people writing the support for
Smart Cards will have their cards

00:01:25.110 --> 00:01:27.070
just work with any application.

00:01:28.490 --> 00:01:32.970
So, first I'd like to show you the
progress we've made since last year,

00:01:33.080 --> 00:01:36.370
and to do that,
I'd like to start off with a demo,

00:01:36.370 --> 00:01:39.590
and I'm going to bring
John Hurley up on stage for that.

00:01:48.400 --> 00:01:57.400
[Transcript missing]

00:01:57.600 --> 00:03:58.400
[Transcript missing]

00:04:05.180 --> 00:04:09.020
So one of the things that is different
on Tiger is as you plug in the reader,

00:04:09.420 --> 00:04:19.110
PCS CD, which operates PCS C,
will notice that, or

00:04:19.400 --> 00:04:28.100
[Transcript missing]

00:04:29.660 --> 00:04:34.100
First, I think what I'll do is insert
the... This is a Department of

00:04:34.180 --> 00:04:37.210
Defense common access card.

00:04:37.350 --> 00:04:41.060
So insert that card.

00:04:41.160 --> 00:04:44.570
And I'm going to go to Keychain Access.

00:04:50.030 --> 00:04:55.180
And you'll see that it just
shows up like a keychain.

00:04:56.440 --> 00:05:00.080
So the really interesting thing
about this from the application

00:05:00.080 --> 00:05:03.940
developer's point of view,
what we've been telling developers

00:05:04.330 --> 00:05:10.260
for actually several years now at
WWDC is unless you actually are

00:05:10.700 --> 00:05:16.960
writing drivers for a reader or you
have to support a new type of card,

00:05:17.020 --> 00:05:18.900
you don't even have to
worry about Smart Cards.

00:05:18.900 --> 00:05:23.670
So what you should do is write
to the high-level security APIs,

00:05:23.670 --> 00:05:26.830
as Michael will talk about,
and then everything

00:05:26.840 --> 00:05:28.020
else should just work.

00:05:28.070 --> 00:05:31.430
So here, this is just showing up just
like a regular keychain.

00:05:31.440 --> 00:05:35.540
I have a couple of certificates in there.

00:05:35.600 --> 00:05:38.190
It's all what you'd expect to see.

00:05:41.860 --> 00:05:45.950
Okay, now I'm going to remove that one.

00:05:46.040 --> 00:05:50.210
This is another card that's very
similar to the DoD Common Access Card,

00:05:50.210 --> 00:05:56.580
the Department of Homeland Security card
that they're going to be issuing soon.

00:06:04.600 --> 00:06:06.810
I'm going to launch
Keychain Access again.

00:06:06.940 --> 00:06:10.800
Now you'll see that card show up.

00:06:11.550 --> 00:06:13.000
It takes a little bit of time.

00:06:13.000 --> 00:06:15.870
What it's doing now is actually
reading the certificates,

00:06:16.000 --> 00:06:19.740
but the way things are written,
after those certificates are read once,

00:06:19.740 --> 00:06:22.740
if they're not part of
the PIN-protected data,

00:06:22.800 --> 00:06:23.800
those things are cached.

00:06:23.800 --> 00:06:30.180
So you'll notice actually quite a
good performance improvement over

00:06:30.180 --> 00:06:33.510
what we had in previous releases.

00:06:35.400 --> 00:06:39.480
So here,
these are standard certificate dialogues.

00:06:39.580 --> 00:06:42.180
You can see some of the
things that are on the card.

00:06:42.200 --> 00:06:46.620
Now, okay, keychain access by itself is
not particularly interesting.

00:06:46.670 --> 00:06:49.350
What are some of the other
things that we've done

00:06:49.990 --> 00:06:51.990
We said that we would
integrate it into the system,

00:06:51.990 --> 00:06:52.650
and we've done it.

00:06:52.760 --> 00:06:57.780
So here is Internet Connect application,
right?

00:06:57.780 --> 00:07:04.420
This is what you'd use
to hook up through VPN.

00:07:04.420 --> 00:07:04.420
And if I...

00:07:04.880 --> 00:07:10.400
Just create a configuration and
click on 'Other'. You'll see that

00:07:10.780 --> 00:07:18.110
here it's giving me a choice of
certificates to choose to use with VPN.

00:07:22.180 --> 00:07:24.790
So here would be a certificate.

00:07:25.080 --> 00:07:27.860
I'm not connected to the network here,
so I'm not going to actually

00:07:27.860 --> 00:07:29.540
show how this part works.

00:07:29.830 --> 00:07:32.500
But the main point is,
the people that wrote the

00:07:32.500 --> 00:07:34.930
Internet Connect application
didn't have to do anything

00:07:34.930 --> 00:07:36.240
special with Smart Cards either.

00:07:36.390 --> 00:07:40.330
They just wrote to the
high-level security APIs.

00:07:43.540 --> 00:07:47.160
Okay,
so we're going to cancel out of that.

00:07:47.190 --> 00:07:50.790
Now, let's go to another application.

00:07:59.260 --> 00:08:03.880
Before I show you
what's going on in Mail,

00:08:04.160 --> 00:08:07.200
another application that I'm not
going to demonstrate but there's

00:08:07.200 --> 00:08:10.060
built-in support for is Safari.

00:08:10.200 --> 00:08:15.720
It's worth pointing out that if you
need your Smart Card to work with

00:08:16.380 --> 00:08:20.950
client-side authentication in Safari,
the method that Michael is

00:08:21.020 --> 00:08:24.200
going to describe is the only
way that we support to do it.

00:08:24.200 --> 00:08:25.180
So there's no other way.

00:08:25.230 --> 00:08:28.410
You just have to act like you're
a keychain and then it'll work

00:08:28.420 --> 00:08:30.050
automatically with Safari.

00:08:30.200 --> 00:08:42.270
Okay, so here in Mail,
let me just compose a message.

00:08:55.230 --> 00:08:59.000
And what you'll notice is,
over on this side of the screen,

00:08:59.040 --> 00:09:00.260
there's two icons.

00:09:00.260 --> 00:09:02.790
There's a little lock icon,
which is grayed out,

00:09:02.850 --> 00:09:06.710
and there's this kind of checkmark icon.

00:09:07.000 --> 00:09:11.610
That means that I can
digitally sign the message.

00:09:12.210 --> 00:09:16.690
Those icons are just there because
it's seen that I have a Smart Card and

00:09:16.700 --> 00:09:21.090
it realizes that I have a credential
on there that I can use to sign with.

00:09:21.100 --> 00:09:24.120
So it's very, very low key,
but it's very tightly

00:09:24.120 --> 00:09:26.100
integrated into the system.

00:09:31.400 --> 00:09:34.760
and I think at this point,
Michael's going to come back up and then

00:09:34.760 --> 00:09:38.950
I have another demo in a minute or two,
right?

00:09:46.070 --> 00:09:48.100
Thank you, John.

00:09:48.540 --> 00:09:55.360
So, as you've seen,
what we have since Mac OS 10.3,

00:09:55.460 --> 00:09:58.290
we've done a number of things.

00:09:58.310 --> 00:10:02.000
We support Smart Card login,
but not just login.

00:10:02.000 --> 00:10:04.560
Actually, if you configure a system
that allows Smart Card login,

00:10:04.880 --> 00:10:08.680
you can also use Smart Cards
for authorization dialogues and

00:10:08.680 --> 00:10:12.000
for unlocking the screen if you
have the screen locker enabled.

00:10:12.000 --> 00:10:17.650
So, anything that normally requires a
password and uses the authorization

00:10:17.760 --> 00:10:21.000
APIs will work with Smart Cards in OS X.

00:10:21.000 --> 00:10:23.180
In Tiger, sorry.

00:10:23.750 --> 00:10:27.540
Email, you can do signing,
John demoed that, although he didn't

00:10:27.540 --> 00:10:29.470
actually send the mail.

00:10:29.540 --> 00:10:30.500
That does work.

00:10:30.520 --> 00:10:34.580
You can do encryption,
or actually rather decryption,

00:10:34.580 --> 00:10:35.370
using the Smart Card.

00:10:35.460 --> 00:10:38.890
So if someone sends you an
encrypted message using one of

00:10:38.900 --> 00:10:42.700
the certificates that have an
associated key on your Smart Card,

00:10:42.700 --> 00:10:46.870
Mail will, if the Smart Card is inserted,
Mail will find that key and know how to

00:10:46.870 --> 00:10:50.700
decrypt the message and ask you for your
PIN and it will decrypt the message.

00:10:50.700 --> 00:10:54.840
So, SSL client-side auth works in Safari.

00:10:54.840 --> 00:10:57.830
The VPN example you showed
is actually similar,

00:10:57.830 --> 00:10:59.700
although it's not identical.

00:10:59.700 --> 00:11:02.200
802.1X is another thing.

00:11:02.200 --> 00:11:04.700
There's an option in
Internet Connect to use 802.1X.

00:11:04.700 --> 00:11:08.700
Also supports certificate-based
authentication methods.

00:11:09.100 --> 00:11:12.070
Also works with Smart Cards.

00:11:12.120 --> 00:11:14.380
What's interesting is that actually

00:11:14.670 --> 00:11:16.840
Apart from login,
none of these other applications

00:11:16.840 --> 00:11:21.510
actually had any Smart Card related
changes during Tiger.

00:11:21.850 --> 00:11:27.020
And so the question is,
what do you as app developers need to do

00:11:27.020 --> 00:11:29.670
to get Smart Card support in your app?

00:11:29.760 --> 00:11:32.630
Well, hopefully the answer is nothing.

00:11:32.730 --> 00:11:36.680
If you have listened to us for the past,
I don't know, five years,

00:11:36.680 --> 00:11:39.830
if you're using CDSA or
you're using the sec.

00:11:39.960 --> 00:11:44.620
Keychain APIs or higher level APIs,
then your application should

00:11:44.630 --> 00:11:46.040
just work with Smart Cards.

00:11:46.250 --> 00:11:51.060
And to show you an example of that,
I'd like to bring John back up on stage.

00:11:51.190 --> 00:11:55.140
And he's going to show you how to add
Smart Card support to an existing app.

00:11:59.920 --> 00:12:04.490
Michael, so he's slightly misstated it.

00:12:04.690 --> 00:12:07.800
It's not really adding
it to an existing app.

00:12:07.800 --> 00:12:14.800
The demo that I'm going to do now is,
I think it was really a great success for

00:12:14.800 --> 00:12:16.760
what we had done in terms of Smart Cards.

00:12:16.790 --> 00:12:20.500
So as we've mentioned,
we've been talking about, you know,

00:12:20.500 --> 00:12:24.300
just use the very high level
APIs and stuff should just work.

00:12:24.360 --> 00:12:27.170
And one of the companies
that was interested in having

00:12:27.180 --> 00:12:29.780
Smart Cards work was Microsoft,
the Mac business.

00:12:29.800 --> 00:12:37.380
And they really wanted to be able to sign
emails using Smart Cards in Entourage.

00:12:37.380 --> 00:12:44.080
And they, it's not an official feature,
partly because there's not really big

00:12:44.080 --> 00:12:47.860
deployments of Smart Cards out there yet.

00:12:47.900 --> 00:12:50.870
But when we were talking
to them about that,

00:12:50.870 --> 00:12:54.240
we said, well, okay,
we don't actually have any

00:12:54.240 --> 00:12:57.900
Smart Card support that
you can use in Entourage.

00:12:57.900 --> 00:12:59.780
But if you write to these companies,
you can use Smart Cards.

00:12:59.790 --> 00:13:03.010
So you do things like
SecFind Certificate,

00:13:03.010 --> 00:13:06.960
SecFind Identity,
use those high level things.

00:13:06.960 --> 00:13:11.330
Then when the Smart Card stuff comes out,
hopefully it'll all work.

00:13:11.480 --> 00:13:17.440
So they released
Office 2004 in June of 2004.

00:13:17.440 --> 00:13:21.460
And in September or October,
we had a Smart Card kitchen

00:13:21.510 --> 00:13:26.330
and they sent somebody with one
of their internal Smart Cards.

00:13:26.330 --> 00:13:29.760
And they spent a day
writing their token D.

00:13:29.760 --> 00:13:34.110
And hooked it up and they said, hey,
you're right, it does, it just works.

00:13:34.290 --> 00:13:40.720
So let me show you what support
they have for that in Entourage.

00:13:45.780 --> 00:13:47.780
What's particularly
interesting about this,

00:13:47.890 --> 00:13:53.090
you'll notice that there's
no Smart Card specific

00:13:53.420 --> 00:13:54.900
terminology in here at all.

00:13:55.050 --> 00:14:05.340
So in preferences, account creation,
we'll find it there.

00:14:05.380 --> 00:14:08.090
Okay, so in account settings,

00:14:12.810 --> 00:14:18.580
There's a tab called 'Security' and
you can choose a certificate there.

00:14:21.330 --> 00:14:22.770
And they didn't change any code.

00:14:22.800 --> 00:14:25.300
They just said, "Okay,
let's do a find certificate." It's

00:14:25.300 --> 00:14:28.140
seeing this card in the reader,
and it says, "Okay,

00:14:28.140 --> 00:14:31.180
you can use that certificate
to sign things with."

00:14:37.500 --> 00:14:48.800
[Transcript missing]

00:14:53.200 --> 00:14:56.220
Under the message menu,
they have a security thing

00:14:56.300 --> 00:14:58.800
and we can digitally sign it.

00:14:58.800 --> 00:15:03.200
So I'm not connected,
but I can send it and

00:15:03.200 --> 00:15:06.760
you'll see it show up.

00:15:14.100 --> 00:15:15.780
Well,
I'm not sure why that's not sending,

00:15:15.800 --> 00:15:19.980
but fortunately I'd sent one
before when I was trying this out.

00:15:21.020 --> 00:15:25.870
So here's, this is one that I sent before
with the same card and it's just

00:15:25.880 --> 00:15:30.820
in my outbox and it says that this
message has been digitally signed.

00:15:30.840 --> 00:15:33.920
And if I view the details,
it shows all the details

00:15:33.940 --> 00:15:36.830
about this message.

00:15:37.000 --> 00:15:39.810
And I can view the sender's certificate.

00:15:39.900 --> 00:15:46.100
[Transcript missing]

00:15:50.600 --> 00:16:39.600
[Transcript missing]

00:16:49.130 --> 00:16:53.650
The existing Mac OS X entourage,
an existing Mac OS X application,

00:16:53.650 --> 00:16:58.240
and it was written well before we
actually had Smart Card support,

00:16:58.360 --> 00:17:00.900
and it just works with Smart Cards.

00:17:00.900 --> 00:17:04.340
And Microsoft actually didn't have to
make any changes at all to entourage.

00:17:04.340 --> 00:17:09.400
This is just the version
that shipped in June of 2004.

00:17:09.400 --> 00:17:14.700
John talked a little bit earlier about
Microsoft having to write a 'tokend',

00:17:14.700 --> 00:17:20.900
which is to support a new kind of card,
which I'll talk about in a little bit.

00:17:21.030 --> 00:17:23.510
So, like I said,
how do you get this level

00:17:23.520 --> 00:17:25.540
of integration in your apps?

00:17:25.540 --> 00:17:28.580
How do you get support for Smart Cards?

00:17:28.650 --> 00:17:35.560
If you use CDSA or the
CDSA-based APIs in Mac OS X,

00:17:35.560 --> 00:17:37.870
you'll get Smart Card support.

00:17:38.180 --> 00:17:45.540
The best thing to do if
you're looking for a key is

00:17:45.540 --> 00:17:48.200
to use SecKeyRef and Friends.

00:17:48.200 --> 00:17:51.900
Friends being SecCertificateRef,
as John already mentioned.

00:17:51.900 --> 00:17:55.010
And there's a class called SecIdentity.

00:17:55.070 --> 00:17:58.760
SecIdentities are actually
pairs of keys and certificates.

00:17:58.760 --> 00:18:03.680
So if you just search the system for
all available identities that can sign,

00:18:03.780 --> 00:18:06.650
for example,
it'll come up with identities

00:18:06.650 --> 00:18:10.730
both in user keychains and
identities on Smart Cards.

00:18:10.900 --> 00:18:44.900
[Transcript missing]

00:18:46.540 --> 00:18:50.440
So how do you implement
Smart Card support for

00:18:50.650 --> 00:18:53.240
new Smart Cards in Tiger?

00:18:54.360 --> 00:18:57.250
We thought about this and we
thought about what we wanted and

00:18:57.250 --> 00:19:01.300
how we got to Smart Card support.

00:19:01.530 --> 00:19:07.300
And we made a number of
choices when we designed this.

00:19:07.430 --> 00:19:12.070
And those choices were based on some
of these goals that I'm listing here.

00:19:12.400 --> 00:19:14.200
First,
and I think the most important goal was,

00:19:14.360 --> 00:19:17.110
we wanted zero user configuration.

00:19:17.630 --> 00:19:22.310
That means that the end user shouldn't
have to install any drivers or

00:19:22.310 --> 00:19:25.300
configuration thingies or whatever.

00:19:25.330 --> 00:19:28.290
Someone who gets a laptop
and has a Smart Card,

00:19:28.290 --> 00:19:30.290
it should just work.

00:19:30.330 --> 00:19:33.290
And that is the state of Tiger today.

00:19:33.300 --> 00:19:37.530
If you're someone who has one of
the supported Smart Cards in Tiger,

00:19:37.530 --> 00:19:42.300
which today are the CAC cards,
which the DoD uses,

00:19:42.330 --> 00:19:44.300
the Belgian Identity Cards,
which John showed,

00:19:44.300 --> 00:19:47.300
and we also have support
for Japanese National Cards,

00:19:47.300 --> 00:19:51.300
and the National ID Card,
which is being rolled out soon.

00:19:51.300 --> 00:19:55.300
If you have one of those cards and
you plug it into a Tiger machine,

00:19:55.340 --> 00:19:57.340
Mail and all these other
apps that John demoed,

00:19:57.480 --> 00:20:00.300
and any apps that
correctly use the Sec APIs,

00:20:00.340 --> 00:20:02.300
will just work with that Smart Card.

00:20:02.300 --> 00:20:04.270
The user doesn't have
to configure anything.

00:20:04.300 --> 00:20:05.190
The only exception is login.

00:20:05.300 --> 00:20:09.980
You have to configure allowing
a particular account to

00:20:10.080 --> 00:20:12.370
login with a Smart Card.

00:20:13.910 --> 00:20:20.700
Another goal was to work with
existing Mac OS X applications.

00:20:20.700 --> 00:20:22.480
For everyone here that's
actually followed our advice

00:20:22.500 --> 00:20:25.940
and used the Sec APIs,
we wanted to make sure that those

00:20:25.940 --> 00:20:29.580
applications could leverage the
Smart Card support we put into Tiger.

00:20:29.590 --> 00:20:33.940
What we explicitly didn't want is
for each application to be aware of

00:20:33.940 --> 00:20:38.980
Smart Cards and have to do specific
things to support specific Smart Cards.

00:20:40.210 --> 00:20:43.800
And last, and this is something we
didn't really show you,

00:20:43.900 --> 00:20:45.500
but that's actually
something we've achieved,

00:20:45.530 --> 00:20:47.690
is Single Sign-On.

00:20:47.700 --> 00:20:51.320
The Smart Card solution in Tiger,
if you use a card to log in

00:20:51.320 --> 00:20:54.180
and you use that same card for
sending mail and you use that same

00:20:54.210 --> 00:20:57.090
card for connecting to the VPN,
you don't have to enter your PIN in

00:20:57.090 --> 00:20:58.890
every app that uses the card.

00:20:58.940 --> 00:21:01.960
You can enter your PIN once
and you can use that card

00:21:01.960 --> 00:21:03.940
in all these different apps.

00:21:04.650 --> 00:21:08.480
We examined some of
the different options.

00:21:08.890 --> 00:21:12.660
Given that we're using CDSA,
and CDSA is supposed to be this

00:21:12.830 --> 00:21:17.340
pluggable security architecture,
the first and most

00:21:17.390 --> 00:21:22.590
obvious choice to us was,
well, we'll just write a CSPDL,

00:21:22.590 --> 00:21:26.720
which is a cryptographic service
provider and a data store library,

00:21:26.930 --> 00:21:29.920
for each card and load
that into each app.

00:21:30.010 --> 00:21:32.740
So that way,
each app that wants to talk to a

00:21:32.770 --> 00:21:37.500
particular Smart Card loads this
plug-in and can talk to the card.

00:21:37.680 --> 00:21:40.380
And obviously,
we could abstract that using the higher

00:21:40.380 --> 00:21:42.440
level APIs to automatically do this.

00:21:42.500 --> 00:21:45.140
That meets two out of the three goals.

00:21:45.140 --> 00:21:48.530
What it doesn't meet is
the single sign-on goal.

00:21:48.920 --> 00:21:54.050
It also means that applications
using the lower level CDSA have

00:21:54.070 --> 00:22:00.920
to be aware of these new CSPDLs,
but the biggest problem was the

00:22:01.230 --> 00:22:06.620
absence of having single sign-on and
not having the ability to do that.

00:22:07.050 --> 00:22:09.890
There's another problem with that,
and that's how would you

00:22:09.890 --> 00:22:13.780
integrate the UI for getting
a pin if this application was,

00:22:13.830 --> 00:22:17.470
let's say, a faceless application,
like a background process trying

00:22:17.470 --> 00:22:19.780
to sign a message for you.

00:22:19.820 --> 00:22:23.890
That's another thing in our
current architecture we solve.

00:22:24.370 --> 00:22:28.270
Another option,
which I'm sure anyone here doing

00:22:28.270 --> 00:22:32.290
Smart Cards is familiar with,
is PXS 11.

00:22:32.300 --> 00:22:38.010
We write a PXS 11 driver for
each card type and use that.

00:22:38.300 --> 00:22:41.670
Again,
the application would load that PXS 11

00:22:41.760 --> 00:22:44.300
driver and talk to the card to do that.

00:22:44.310 --> 00:22:48.300
It has the same problem as a CSPDL,
but in addition,

00:22:48.300 --> 00:22:52.300
it doesn't mesh with our existing APIs.

00:22:52.300 --> 00:22:56.510
The APIs we've been telling
you as developers to use for

00:22:56.510 --> 00:22:58.300
all these years have been CDSA.

00:22:58.300 --> 00:23:02.300
PXS 11 is similar in
functionality to a CSPDL,

00:23:02.300 --> 00:23:04.130
but with a slightly different API.

00:23:04.300 --> 00:23:08.300
Given that we never
had Smart Card support,

00:23:08.300 --> 00:23:11.240
we'd be introducing a completely
new API for application developers

00:23:11.240 --> 00:23:13.300
to deal with Smart Cards.

00:23:13.300 --> 00:23:17.710
Meaning, an application that worked fine
with encryption and Mail would

00:23:17.710 --> 00:23:20.300
have to rev to support Smart Cards.

00:23:20.300 --> 00:23:22.300
It's actually something
we wanted to avoid.

00:23:22.300 --> 00:23:28.100
Our solution was to use a PXS 11
driver for all of our applications.

00:23:28.850 --> 00:23:30.300
Horizontal Smart Card support.

00:23:30.330 --> 00:23:34.740
We wanted a solution that
works across the entire system,

00:23:34.740 --> 00:23:40.750
not just a vertical app like, let's say,
you ship your app that supports

00:23:40.860 --> 00:23:44.700
just one particular card and it
works through the PCSC stack.

00:23:44.870 --> 00:23:47.620
That's pretty much the solutions
we've seen on Windows today.

00:23:47.680 --> 00:23:50.700
All are fairly vertical solutions.

00:23:50.700 --> 00:23:54.700
They'll support a card in a
particular app through the stack.

00:23:54.700 --> 00:23:58.040
We wanted it to work with login,
authorization, mail, Safari,

00:23:58.090 --> 00:24:00.650
screen locking,
anything using authorization,

00:24:00.810 --> 00:24:05.700
any apps that correctly
use the SEC and CDSA APIs.

00:24:05.700 --> 00:24:08.910
We wanted single sign-on,
and more importantly,

00:24:08.910 --> 00:24:13.700
because single sign-on without
ACL support would be somewhat insecure.

00:24:13.700 --> 00:24:18.190
So we wanted ACL support,
which is the access control list

00:24:18.280 --> 00:24:20.630
that CDSA and keychains use.

00:24:20.730 --> 00:24:24.700
How many of you are familiar
with the keychain APIs here?

00:24:26.920 --> 00:24:27.800
Not a lot?

00:24:27.800 --> 00:24:32.940
Well, I'll go into a little more detail
about ACLs later on in the session.

00:24:33.090 --> 00:24:37.990
So, like I said previously,
all we had was vertical solutions.

00:24:38.060 --> 00:24:41.420
There were maybe two or three
vendors out there that actually

00:24:41.510 --> 00:24:44.120
provided a vertical solution,
but everyone had to do their own

00:24:44.120 --> 00:24:46.900
integration with Login Window and
their own integration with Mail and

00:24:46.900 --> 00:24:50.510
their own integration with Safari,
which I don't think anyone out here had

00:24:50.610 --> 00:24:53.000
a product that worked across the board.

00:24:53.020 --> 00:24:55.390
So we wanted to enable that.

00:24:56.940 --> 00:24:59.080
So, how did you do this?

00:24:59.610 --> 00:25:08.990
Well, so rather than actually having
a plug-in for... Interesting.

00:25:10.920 --> 00:25:12.540
I don't get a mouse.

00:25:12.640 --> 00:25:17.760
Rather than having a plug-in
for each application,

00:25:17.760 --> 00:25:23.020
we have a single generic
plug-in called the SD-CSPDL,

00:25:23.030 --> 00:25:30.130
whichever application loads,
and that's the SecurityD CSPDL.

00:25:30.220 --> 00:25:36.080
What that does is, to the application,
it looks like a regular CDSA plug-in,

00:25:36.080 --> 00:25:40.420
but what it does in reality is it
talks to SecurityD and forwards

00:25:40.420 --> 00:25:45.510
all the API calls you make into
that to SecurityD using Mach RPCs.

00:25:47.110 --> 00:25:54.110
SecurityD then will load
one or more tokenDs.

00:25:54.200 --> 00:25:58.480
Each tokenD represents a card or a token.

00:25:58.490 --> 00:26:01.240
So when someone inserts
a token into the system,

00:26:01.330 --> 00:26:05.490
a tokenD is loaded to
support that particular card.

00:26:05.600 --> 00:26:26.400
[Transcript missing]

00:26:26.500 --> 00:27:16.700
[Transcript missing]

00:27:17.860 --> 00:27:21.770
So, each tokend in turn that uses
PCSC to talk to the actual reader

00:27:22.130 --> 00:27:26.130
and then for each reader inserted
there will be a reader driver,

00:27:26.300 --> 00:27:29.120
which is the part on the right.

00:27:30.300 --> 00:27:35.390
So, I mentioned 'tokend'. Now,
what is 'tokend'? Well, like I said,

00:27:35.390 --> 00:27:38.880
it's loaded for each card that
is inserted in the system.

00:27:38.880 --> 00:27:43.800
There's a process that knows
how to talk to that card.

00:27:44.290 --> 00:27:48.970
It's actually entirely up to you
as a developer that were to develop

00:27:49.060 --> 00:27:51.190
a 'tokend' how it does that.

00:27:51.200 --> 00:27:54.240
I mean, typically,
it would be using PCSC,

00:27:54.240 --> 00:27:58.200
but we've had some developers that
had solutions that actually use

00:27:58.200 --> 00:28:00.200
different communication channels.

00:28:00.200 --> 00:28:00.660
and

00:28:01.910 --> 00:28:07.230
So, tokend implements an interface
that security invokes.

00:28:07.230 --> 00:28:09.700
It's like a callback interface.

00:28:10.940 --> 00:28:15.100
That callback interface is
basically driven by security.

00:28:15.100 --> 00:28:18.500
When a client makes a call to security,
security will ask tokend to

00:28:18.510 --> 00:28:20.300
perform a particular operation.

00:28:20.410 --> 00:28:24.490
Tokend never initiates
anything on its own.

00:28:25.210 --> 00:28:28.490
For events like token
insertion and token removal,

00:28:28.520 --> 00:28:31.460
SecurityD actually talks
directly to PCSCD to listen

00:28:31.460 --> 00:28:33.370
for those types of events.

00:28:33.370 --> 00:28:39.070
So SecurityD knows when the token that a
particular tokenD represents is removed,

00:28:39.210 --> 00:28:42.370
and then SecurityD will
just tell TokenD to go away.

00:28:43.120 --> 00:28:49.390
The interface to 'tokend'
is actually part of Darwin,

00:28:49.470 --> 00:28:53.790
and one of the reasons for that
is that we want your feedback

00:28:53.860 --> 00:28:58.510
into making it better and making
it perfect before we make this a

00:28:58.510 --> 00:29:01.810
fully committed and supported API.

00:29:01.900 --> 00:29:24.100
[Transcript missing]

00:29:24.620 --> 00:29:27.940
As I mentioned before,
there's a single 'tokend'

00:29:27.960 --> 00:29:30.020
for each token in the system.

00:29:30.030 --> 00:29:32.890
So if you insert four cards
into four different readers,

00:29:32.910 --> 00:29:35.500
you'll end up with four
running 'tokend' processes.

00:29:35.500 --> 00:29:39.380
Unlike, let's say,
a PKSS 11 library that has to

00:29:39.380 --> 00:29:43.640
be able to deal with multiple
cards and multiple tokens,

00:29:43.930 --> 00:29:47.930
SecurityD deals with all the multiplexing
of tokens to cards to people,

00:29:47.990 --> 00:29:48.490
etc.

00:29:48.500 --> 00:29:51.490
'tokend' has a really simple job.

00:29:51.530 --> 00:29:54.890
It's just, you know,
talk to this one card and deal with it.

00:29:55.710 --> 00:29:59.600
From the higher-level
API's point of view,

00:29:59.600 --> 00:30:02.420
each token looks like a keychain.

00:30:02.420 --> 00:30:08.050
So a normal app talking to
the Sec keychain APIs or above

00:30:08.050 --> 00:30:13.310
will actually just see a new
keychain that got inserted.

00:30:14.610 --> 00:30:18.050
Those keychains actually show
up in a search list that is

00:30:18.200 --> 00:30:21.460
called the dynamic search list.

00:30:22.060 --> 00:30:23.590
There's a number of different
keychain search lists.

00:30:23.660 --> 00:30:26.260
The most obvious one that you'd
see if you launch Keychain

00:30:26.260 --> 00:30:29.530
Access is the user search list,
which typically contains your

00:30:29.620 --> 00:30:31.410
login keychain by default.

00:30:31.530 --> 00:30:35.490
If you create additional keychains,
those get added to the user search list.

00:30:35.520 --> 00:30:39.090
The dynamic search list automatically
gets appended to the user search

00:30:39.160 --> 00:30:42.500
list with any dynamic keychains
that are present at that time.

00:30:42.500 --> 00:30:45.180
The keychains that are inserted
into the system get appended

00:30:45.230 --> 00:30:46.400
to each user search list.

00:30:46.600 --> 00:30:48.470
That doesn't mean the user has
access to the items on them,

00:30:48.490 --> 00:30:51.490
because to do that they'd
need to know the PIN.

00:30:51.500 --> 00:30:53.900
So even in the context
of fast user switching,

00:30:53.930 --> 00:30:57.500
unless you know the PIN to the token,
you still can't access it.

00:30:58.910 --> 00:31:05.680
They're, like I said,
they're searched after the user's list.

00:31:05.680 --> 00:31:08.530
So first all the user-configured
keychains are searched and then

00:31:08.530 --> 00:31:10.400
any additional tokens are searched.

00:31:10.440 --> 00:31:14.340
So because of how that works
and because of normally when

00:31:14.340 --> 00:31:19.550
people make keychain API calls,
you just specify the default search list,

00:31:19.550 --> 00:31:22.820
which is null,
you'll automatically end up searching

00:31:22.870 --> 00:31:24.710
any cards that get inserted.

00:31:25.450 --> 00:31:29.810
So, if any of you have applications
using the Keychain APIs and you're

00:31:29.900 --> 00:31:34.250
specifically searching one Keychain,
you'll have to change your

00:31:34.320 --> 00:31:36.750
application to actually do less,
which is just not care

00:31:36.970 --> 00:31:38.910
about which Keychain you're
searching and search them all,

00:31:39.060 --> 00:31:41.300
which is actually the
recommended behavior.

00:31:41.480 --> 00:31:46.670
And doing that,
you'll actually find things on

00:31:46.670 --> 00:31:47.690
Smart Cards as well as any user
Keychains that the user has configured.

00:31:49.740 --> 00:31:57.340
So, now I'm going to talk about how
you could write your own tokend.

00:31:57.340 --> 00:32:00.850
This is mostly for those of
you who are looking to support

00:32:00.930 --> 00:32:04.460
a new type of card or token,
but it could be interesting for

00:32:04.460 --> 00:32:08.290
the rest of you here as well,
just to understand how some

00:32:08.290 --> 00:32:09.880
of the guts of this work.

00:32:10.760 --> 00:32:15.300
So like I said,
the interface is a C callback interface.

00:32:15.500 --> 00:32:19.270
It's actually in a header
called 'sec_tokend.h' in the

00:32:19.270 --> 00:32:22.120
Security Token D framework.

00:32:22.120 --> 00:32:25.380
So to find the C callback interface,
you'd have to go to the

00:32:25.660 --> 00:32:30.370
Security Token D project in
Darwin and look for that header.

00:32:31.970 --> 00:32:37.100
There's a C++ layer on top of
that C interface that we use

00:32:37.100 --> 00:32:39.270
to implement our own tokenDs.

00:32:39.270 --> 00:32:43.900
And if you're comfortable with using C++,
I definitely recommend you use that

00:32:44.080 --> 00:32:47.540
because it helps implement a lot
of the features that your tokenD

00:32:47.540 --> 00:32:49.900
needs to support to be a keychain.

00:32:50.360 --> 00:32:59.600
The C interface is more
like a CSPDL interface,

00:32:59.660 --> 00:33:05.560
which is fairly low level.

00:33:05.560 --> 00:33:05.560
In order for a CSPDL to
be able to be a keychain,

00:33:05.560 --> 00:33:05.560
it needs to support a number
of different features,

00:33:05.560 --> 00:33:05.560
which are

00:33:05.600 --> 00:33:26.500
[Transcript missing]

00:33:26.600 --> 00:33:53.000
[Transcript missing]

00:33:53.550 --> 00:33:57.680
and there are source code there
both for the CAC tokend and for

00:33:57.680 --> 00:34:00.460
the Belgian Identity Card tokend.

00:34:00.460 --> 00:34:03.500
So you have two examples
of actual working tokends.

00:34:03.570 --> 00:34:07.790
There's a third tokend in there
which there's sources for,

00:34:07.790 --> 00:34:10.990
but we don't ship,
which is a Muscle Card based tokend,

00:34:11.130 --> 00:34:17.300
which actually would support any
card supported by the Muscle APIs.

00:34:19.660 --> 00:34:21.600
So, what does 'tokend' itself look like?

00:34:21.600 --> 00:34:26.760
Well, on the one hand,
it talks to SecurityD,

00:34:26.760 --> 00:34:28.740
which is not something
you have to code for,

00:34:28.800 --> 00:34:32.240
because the SecurityTokenD framework
is basically what you

00:34:32.240 --> 00:34:33.600
link against as a TokenD.

00:34:33.600 --> 00:34:40.600
And that framework provides basically the
RPC layer between TokenD and SecurityD.

00:34:40.600 --> 00:34:44.140
On the other hand, on the bottom end,
you're most likely to link

00:34:44.140 --> 00:34:46.960
against PCSC framework,
because that's what you

00:34:46.960 --> 00:34:50.430
need to talk to PCSC,
which is the part that lets you

00:34:50.520 --> 00:34:54.850
talk to different readers without
having to worry about which reader

00:34:54.850 --> 00:34:56.910
your card was inserted into.

00:34:57.410 --> 00:34:59.270
and between those two
is your custom code,

00:34:59.330 --> 00:35:04.390
which actually implements 'tokend'.
Now if you're using the C++ framework,

00:35:04.390 --> 00:35:07.830
this picture isn't entirely
accurate because the C++ layer

00:35:08.380 --> 00:35:14.440
is on top of the interface to
security as well as on top of PCLC,

00:35:14.440 --> 00:35:18.260
because there's some abstractions
there too that make you deal

00:35:18.260 --> 00:35:20.080
with the PCLC part easier.

00:35:21.120 --> 00:35:27.690
and in this case your code
becomes most likely a lot smaller.

00:35:28.020 --> 00:35:31.310
How do you write a 'tokend'
? What do you start with?

00:35:31.310 --> 00:35:35.490
Well, every program starts with
'main'. And 'main' in 'tokend'

00:35:35.490 --> 00:35:37.240
looks something like this.

00:35:37.340 --> 00:35:39.530
Actually,
it probably looks exactly like this,

00:35:39.530 --> 00:35:41.810
unless you want to add
some comments or whatnot.

00:35:41.970 --> 00:35:47.340
You call a single function in 'main',
which is 'sec token d main', and you

00:35:47.340 --> 00:35:51.290
pass in your own 'argc' and 'argv' to it,
and it takes two parameters.

00:35:51.350 --> 00:35:54.580
One is an input parameter,
the other is an output parameter.

00:35:54.770 --> 00:35:55.850
Callbacks is the input parameter.

00:35:55.930 --> 00:35:59.310
It contains basically,
it's a struct containing all the callback

00:35:59.520 --> 00:36:04.300
functions that you need to implement that
SecurityD will invoke on your tokenD.

00:36:04.440 --> 00:36:06.500
Some of them are optional,
so you can fill in null and

00:36:06.500 --> 00:36:08.190
they'll just do the default thing.

00:36:08.190 --> 00:36:13.600
But most of them are actually required.

00:36:13.600 --> 00:36:16.440
And then there's a tokenD
support struct that gets filled

00:36:16.440 --> 00:36:20.000
in when you make this call,
which gets filled in immediately

00:36:20.120 --> 00:36:22.740
before your first callback is invoked.

00:36:22.760 --> 00:36:26.350
So you can assume that once you're
in one of your callbacks that that

00:36:26.350 --> 00:36:29.580
tokenD support structure is populated.

00:36:29.580 --> 00:36:35.520
The most important thing in the support
structure is there's a function there

00:36:35.520 --> 00:36:41.380
to get the PCSC slot number for which
you are responsible as a tokenD.

00:36:41.380 --> 00:36:44.140
Because again, there could be multiple
readers in the system,

00:36:44.140 --> 00:36:48.510
and when the tokenD gets launched,
it's launched to serve a

00:36:48.510 --> 00:36:50.780
card in a particular reader.

00:36:50.780 --> 00:36:54.760
And so which reader that is,
you can get by calling this

00:36:54.940 --> 00:36:57.610
function in the support structure.

00:36:57.620 --> 00:36:59.940
There's a number of other
functions in the support structure,

00:36:59.940 --> 00:37:08.080
like allocators that you're supposed to
use when you return memory to the system.

00:37:08.080 --> 00:37:09.680
So you don't just use malloc and free.

00:37:09.680 --> 00:37:13.130
There's actually a malloc
for data and a free for data.

00:37:13.140 --> 00:37:16.050
And there's a special secure
malloc and secure free,

00:37:16.050 --> 00:37:18.340
which you're supposed to use for keys.

00:37:20.900 --> 00:37:26.190
So, there's a number of callbacks listed,
and I'm going to walk through

00:37:26.190 --> 00:37:27.340
the most important ones.

00:37:27.360 --> 00:37:29.230
There's one called
'initialize', which is called,

00:37:29.290 --> 00:37:32.200
but none of our tokenies actually use it.

00:37:32.350 --> 00:37:36.110
'Initialize' is called after that
support structure is filled in,

00:37:36.110 --> 00:37:38.620
but before probe,
and it's basically a chance

00:37:38.630 --> 00:37:41.670
for you to do any additional
initialization you might want to do.

00:37:42.040 --> 00:37:45.780
However, just because your token has been
launched and you've been told

00:37:45.780 --> 00:37:49.840
to service a particular slot,
doesn't mean you're going to be the

00:37:49.840 --> 00:37:54.420
token to ultimately talk to that card,
because there might be multiple

00:37:54.420 --> 00:37:58.580
tokenies on the system,
and there's a scoring system in place,

00:37:58.590 --> 00:38:01.700
which basically,
each token is asked whether or not

00:38:01.800 --> 00:38:06.730
they want to support that card,
and if they do, what score they give to

00:38:06.730 --> 00:38:09.310
their level of support.

00:38:09.460 --> 00:38:12.340
So for example,
if there's a generic muscle token

00:38:12.350 --> 00:38:15.700
D on the system that supports a
particular card through muscle,

00:38:15.700 --> 00:38:19.350
it would probably give a lower score
than a token D that was written

00:38:19.350 --> 00:38:21.810
specifically for that one type of card.

00:38:23.170 --> 00:38:27.080
The main job of Probe is to
figure out whether you are

00:38:27.080 --> 00:38:29.400
able to support this card.

00:38:29.400 --> 00:38:31.370
One thing to note is,
before Probe is called,

00:38:31.560 --> 00:38:35.110
and actually after Probe is called,
you are not allowed to

00:38:35.170 --> 00:38:37.790
talk to PCSC on that slot.

00:38:37.840 --> 00:38:41.110
You're only allowed to
do this during Probe,

00:38:41.110 --> 00:38:44.920
up until the next call,
which I'll go into next.

00:38:45.170 --> 00:38:47.780
Besides figuring out whether
you support the card,

00:38:47.780 --> 00:38:50.840
Probe has one other job,
and that's to provide a

00:38:50.850 --> 00:38:53.000
unique ID for a token.

00:38:53.270 --> 00:38:56.850
That's an optional step,
but it's required if you

00:38:56.980 --> 00:39:01.990
want to leverage the type of
caching that John talked about,

00:39:01.990 --> 00:39:01.990
which is...

00:39:02.320 --> 00:39:04.910
In a lot of cases,
cards allow users to freely

00:39:04.910 --> 00:39:07.990
read certificates off the card,
and in most cases,

00:39:08.050 --> 00:39:10.200
certificates are immutable.

00:39:10.370 --> 00:39:18.190
So if your token is a pre-populated card,
like most of the cards

00:39:18.240 --> 00:39:22.290
that we support today are,
then it's kind of pointless to

00:39:22.320 --> 00:39:24.750
read the certificate off the
card over and over again every

00:39:24.760 --> 00:39:26.200
time the user inserts the card.

00:39:26.630 --> 00:39:33.260
Because the certificate is
small by today's standards,

00:39:33.340 --> 00:39:34.800
it's only a few K usually,
but to read it from a card

00:39:34.800 --> 00:39:36.150
actually takes a couple of seconds.

00:39:36.220 --> 00:39:40.300
So if you can make up a
unique ID for the token that

00:39:40.300 --> 00:39:44.690
uniquely identifies your token,
then later on you'll be

00:39:44.690 --> 00:39:47.770
given a cache directory,
which will be the same between

00:39:47.830 --> 00:39:52.370
insertions of that token,
to which you can freely store things.

00:39:55.420 --> 00:40:02.300
Once the system finishes
probing all available tokenDs,

00:40:02.300 --> 00:40:06.060
one of them is selected, or none.

00:40:06.100 --> 00:40:08.680
If none of them return a
score higher than zero,

00:40:08.690 --> 00:40:10.160
then the card isn't supported.

00:40:10.360 --> 00:40:13.900
If one or more of them return
a score higher than zero,

00:40:13.900 --> 00:40:17.300
then the one with the
highest score is selected.

00:40:17.350 --> 00:40:19.300
All the other tokenDs are killed.

00:40:19.480 --> 00:40:23.300
The one with the highest score
gets an established call.

00:40:23.540 --> 00:40:26.000
After you return from probe and
up until established is called,

00:40:26.000 --> 00:40:29.230
you're not allowed to talk to the
card anymore because the other tokenDs

00:40:29.230 --> 00:40:31.300
are at this point scanning the card.

00:40:31.300 --> 00:40:34.260
So you don't own the card
until established is called.

00:40:34.500 --> 00:40:37.290
Once established is called,
you are now in full control of the card.

00:40:37.300 --> 00:40:39.290
SecurityD won't bug you anymore.

00:40:39.290 --> 00:40:42.290
The system, you own that resource.

00:40:45.250 --> 00:40:49.020
Establish has a number of parameters.

00:40:49.020 --> 00:40:52.790
The most important one being the,
well not the most important one,

00:40:52.850 --> 00:40:56.500
but the cache directory being one of
the ones that I talked about earlier,

00:40:56.500 --> 00:40:59.050
which is if you make a
unique ID for the token,

00:40:59.190 --> 00:41:03.360
and actually even if you don't,
the cache directory is a directory in

00:41:03.360 --> 00:41:08.290
which you can store things that you want,
that you read off the token

00:41:08.350 --> 00:41:11.100
that you don't want to have
to read over and over again.

00:41:11.110 --> 00:41:14.340
If you didn't make up a unique
ID for the token in probe,

00:41:14.400 --> 00:41:18.080
then your cache directory will
be empty and different every

00:41:18.180 --> 00:41:20.270
time the token is inserted.

00:41:20.300 --> 00:41:23.020
If you did somehow manage
to come up with a unique ID,

00:41:23.110 --> 00:41:27.530
which in most cases you do by reading,
let's say, the chip ID off the card or

00:41:27.600 --> 00:41:29.330
the serial number or something.

00:41:29.530 --> 00:41:34.310
Most tokens that we've worked with
have some kind of unique ID on them.

00:41:34.370 --> 00:41:38.570
If you manage to read that off the card,
then that cache directory will

00:41:38.570 --> 00:41:40.630
be the same between insertions.

00:41:41.650 --> 00:41:48.490
There's another parameter,
which is the print name,

00:41:48.580 --> 00:41:50.500
which is an output parameter.

00:41:50.500 --> 00:41:53.550
And the print name is what you
get to fill in as the human

00:41:53.880 --> 00:41:55.490
readable name of the card.

00:41:55.490 --> 00:41:59.500
If you leave the print name unpopulated,
your card will be named by the system,

00:41:59.500 --> 00:42:02.010
and it will be named
Smart Card number something,

00:42:02.220 --> 00:42:04.720
like you saw with most of
the cards we demoed today.

00:42:04.740 --> 00:42:15.730
Then the other output
parameter is the MDS directory.

00:42:15.730 --> 00:42:15.730
That one is fairly important in that

00:42:15.870 --> 00:42:18.750
MDS is the,
not to be confused with Spotlight,

00:42:19.020 --> 00:42:22.500
which also has used the
name MDS internally.

00:42:23.810 --> 00:42:26.110
MDS is the Module Directory Services.

00:42:26.410 --> 00:42:30.530
It's a part of CDSA,
which allows modules to

00:42:30.660 --> 00:42:33.160
identify their capabilities.

00:42:33.180 --> 00:42:37.710
Well, during establish,
it's your responsibility as tokend

00:42:37.880 --> 00:42:42.100
to actually build up a list of
MDS capabilities for your token.

00:42:42.100 --> 00:42:47.170
And you'll have to build a capability
list both for the datastore library part,

00:42:47.170 --> 00:42:51.520
for the DL part of your token,
and for the CSP part of your token.

00:42:51.550 --> 00:42:57.470
So the DL part would look something like,
you know, supports queries with AND and

00:42:57.510 --> 00:43:02.140
OR conjunctives and with equal and
less than and greater than operators,

00:43:02.190 --> 00:43:02.640
etc.

00:43:02.730 --> 00:43:07.690
So you'd list all the capabilities
of your tokend in MDS.

00:43:07.810 --> 00:43:14.230
That directory is a directory
containing the files,

00:43:14.230 --> 00:43:14.230
which

00:43:14.530 --> 00:43:20.880
If you don't fill that in,
the MDS info files will be pulled

00:43:20.890 --> 00:43:25.760
out of the resources folder of your
tokenD by securityD automatically.

00:43:25.760 --> 00:43:28.760
So if your tokenD only
supports one kind of token,

00:43:28.760 --> 00:43:30.900
and that token always has
the same capabilities,

00:43:31.140 --> 00:43:34.440
then you just hard code
these MDS info files,

00:43:34.440 --> 00:43:37.090
stick them in the resources
folder of your tokenD,

00:43:37.090 --> 00:43:39.800
and the system will pick
them up automatically.

00:43:40.150 --> 00:43:45.130
If for some reason you support lots
of different tokens in your tokend,

00:43:45.130 --> 00:43:48.180
and those tokens have
varying capabilities,

00:43:48.180 --> 00:43:50.190
then this is the point where
you have to go query the token,

00:43:50.310 --> 00:43:52.940
figure out what the
token's capabilities are,

00:43:52.990 --> 00:43:55.700
and produce that MDS record.

00:43:55.780 --> 00:44:00.590
Now, if you're smart and you actually
have a unique ID for that token,

00:44:00.590 --> 00:44:03.760
you can probably cache that information.

00:44:04.780 --> 00:44:07.880
So,
if for some reason you want info files

00:44:07.880 --> 00:44:12.190
that aren't in the resources folder,
that's when you fill

00:44:12.190 --> 00:44:14.870
in the MDS directory.

00:44:15.880 --> 00:44:22.000
Other than that,
you get passed in the GUID of the CSP,

00:44:22.060 --> 00:44:24.640
which is actually used when you
return key objects to the caller.

00:44:24.640 --> 00:44:29.830
You're supposed to fill in the
GUID of the key using this GUID.

00:44:29.900 --> 00:44:34.550
And then the subservice ID,
which is essentially the

00:44:34.550 --> 00:44:40.020
virtual slot number that your
token represents in the system.

00:44:40.970 --> 00:44:45.530
So, once establish has happened,
your token's ready to go and

00:44:45.530 --> 00:44:49.430
the system will most likely
start querying your token,

00:44:49.460 --> 00:44:50.340
etc., etc.

00:44:51.580 --> 00:44:55.370
The way to get things off,
everything on a token

00:44:55.370 --> 00:44:57.500
is some form of object.

00:44:57.500 --> 00:45:03.080
The different types of objects that we
support or that are expected to be on

00:45:03.150 --> 00:45:07.490
a token would be X.509 certificates,

00:45:07.620 --> 00:45:13.050
different types of keys-- public keys,
private keys, symmetric keys.

00:45:13.090 --> 00:45:18.140
You could have generic objects on there,
which generic objects won't be

00:45:18.140 --> 00:45:21.260
used by the security stack per se.

00:45:21.260 --> 00:45:26.200
But you can use CDSA to find those
generic objects on your token.

00:45:26.200 --> 00:45:30.430
And as an example,
those common access cards that

00:45:30.470 --> 00:45:36.690
John demoed actually have a
personnel record object on there.

00:45:36.720 --> 00:45:39.560
There's a specific app we
ship called the CAC Viewer,

00:45:39.560 --> 00:45:45.550
I think, Common Access Card Viewer,
that reads those generic records and

00:45:45.550 --> 00:45:49.320
can display things like your salary
scale and your medical benefits and

00:45:49.370 --> 00:45:52.060
all this other information that's
stored on the card but doesn't fall

00:45:52.060 --> 00:45:54.080
into one of these other categories.

00:45:54.110 --> 00:45:59.460
Similarly, the Belgian Identity Card has
Social Security-type information,

00:45:59.460 --> 00:46:02.160
has a picture of the
person who owns the card,

00:46:02.160 --> 00:46:03.000
et cetera.

00:46:03.000 --> 00:46:08.780
Those can all be basically served
up to the system as generic records.

00:46:09.140 --> 00:46:12.660
Because there's so much
variation in what they are,

00:46:12.660 --> 00:46:16.360
there's no real standardized app
at the app level that knows how to

00:46:16.360 --> 00:46:18.180
deal with those generic records.

00:46:18.180 --> 00:46:21.940
But if you provide a custom app
to view records for that card,

00:46:21.940 --> 00:46:27.840
you can go through the normal security
APIs to get those records off your card.

00:46:27.960 --> 00:46:30.890
You don't have to directly
talk to the card in your app.

00:46:32.660 --> 00:46:35.800
and you can have custom types.

00:46:36.140 --> 00:46:38.820
Usually if you're thinking
about doing a custom type,

00:46:38.820 --> 00:46:40.600
you probably should just use generic.

00:46:40.800 --> 00:46:44.300
One thing where I could think would
maybe be an exception would be,

00:46:44.300 --> 00:46:47.640
let's say,
your card supports PGP certificates.

00:46:47.730 --> 00:46:51.600
You would want to use a PGP certificate
type there and not just generic.

00:46:51.770 --> 00:46:58.900
Or if you support some other totally
different type of object that wouldn't

00:46:58.900 --> 00:46:58.960
fall into one of these categories.

00:46:59.380 --> 00:47:02.430
Pins are actually not
objects on our cards.

00:47:02.540 --> 00:47:05.540
I'll talk a little bit
more about that later.

00:47:05.750 --> 00:47:10.030
We've already had some comments
from developers about this,

00:47:10.120 --> 00:47:15.400
and we're more than willing to take
additional comments about this later.

00:47:17.410 --> 00:47:22.740
So, now we're actually going to go
into some of the other callbacks,

00:47:22.860 --> 00:47:26.480
and those are the ones to
retrieve attributes and data

00:47:26.900 --> 00:47:28.650
off objects on the card.

00:47:28.800 --> 00:47:33.550
And there are really only three ways to
get attributes and data off the card,

00:47:33.740 --> 00:47:38.530
and that's either Find First, Find Next,
or Find Record Handle.

00:47:38.630 --> 00:47:45.380
Attributes and data are returned using
the allocators in the support call box.

00:47:45.760 --> 00:47:51.200
Certificates and keys have to
have very specific attributes

00:47:51.840 --> 00:47:56.380
associated with them in order for
the rest of the security stack to

00:47:56.380 --> 00:47:58.200
recognize them as keychain items.

00:47:58.230 --> 00:48:02.060
So that the schema for a certificate
and the schema for a key item

00:48:02.060 --> 00:48:06.200
have to have particular attributes
that must be there for it to work.

00:48:06.280 --> 00:48:09.570
And there's also,
in the case of a public key and a cert,

00:48:09.790 --> 00:48:12.860
or a private key and a cert,
more importantly,

00:48:12.860 --> 00:48:17.300
a certificate has an attribute
called the hash of the public key.

00:48:17.370 --> 00:48:21.360
And a private key also has an attribute
called the hash of the public key.

00:48:21.450 --> 00:48:25.610
Those two have to match in order
for the system to recognize that

00:48:25.610 --> 00:48:28.130
key is associated with that cert.

00:48:28.410 --> 00:48:30.320
or for that matter,
to associate a private

00:48:30.330 --> 00:48:33.530
key with a public key,
because they're two separate objects.

00:48:33.530 --> 00:48:37.700
By having the same hash,
they're paired up as a single key pair.

00:48:40.350 --> 00:48:58.180
and Michael Broewer, John Hurley.

00:48:58.730 --> 00:48:58.730
All of that is a lot of work,
and that's actually where the

00:48:58.730 --> 00:48:58.730
C++ layer helps you a lot.

00:48:58.730 --> 00:48:58.730
Another type of objects that I didn't
talk about yet in the previous section,

00:48:58.730 --> 00:48:58.730
which the system will
also make these calls on,

00:48:58.730 --> 00:48:58.730
are schema objects.

00:48:58.980 --> 00:49:05.960
Each object type in a Smart Card has
to have a schema describing

00:49:05.960 --> 00:49:07.900
which attributes it supports.

00:49:07.900 --> 00:49:12.890
So all the schema information
needs to be queryable using the

00:49:12.890 --> 00:49:15.900
same APIs as the regular data.

00:49:15.900 --> 00:49:21.680
Again, the C++ layer actually handles
all the schema tables for you.

00:49:24.520 --> 00:49:27.400
So, first one, find first.

00:49:27.500 --> 00:49:30.450
Starts a new query,
think about it like creating a

00:49:30.450 --> 00:49:34.830
database cursor or query or whatever.

00:49:35.230 --> 00:49:38.350
Unlike PCSS 11,
there's no limit on how many outstanding

00:49:38.350 --> 00:49:41.310
queries you can have at one time,
and the system will

00:49:41.320 --> 00:49:43.500
sometimes do nested queries.

00:49:43.620 --> 00:49:47.450
So you need to make sure that
you support that in your tokend.

00:49:48.100 --> 00:50:02.400
[Transcript missing]

00:50:03.100 --> 00:50:24.700
[Transcript missing]

00:50:24.840 --> 00:50:36.230
and Michael Dinklage will show
you how to use the C++ layer.

00:50:36.230 --> 00:50:36.700
The C++ layer actually handles the
entire query machinery for you.

00:50:36.700 --> 00:50:36.700
It supports all the optional features,
etc.

00:50:38.220 --> 00:50:41.340
So the other argument
is the search handle,

00:50:41.340 --> 00:50:45.330
which is output from this function,
and then there's the data itself,

00:50:45.440 --> 00:50:53.710
which is shown in this structure,
which the data contains the attributes,

00:50:53.710 --> 00:50:53.710
the data,

00:50:53.800 --> 00:50:58.800
and the record handle and
key handle for the record.

00:50:58.850 --> 00:51:01.190
Normal records only have a record handle.

00:51:01.460 --> 00:51:04.030
Keys are special in that they
actually return two handles.

00:51:04.150 --> 00:51:08.500
If you search a token and
you find a key object,

00:51:08.500 --> 00:51:11.520
you'll get back both the key
handle and the record handle.

00:51:11.690 --> 00:51:15.970
and the Key Handle is what you
use for cryptographic operations.

00:51:15.970 --> 00:51:19.130
The Record Handle is what you'd
use to retrieve additional

00:51:19.130 --> 00:51:21.360
attributes and data from the object.

00:51:21.530 --> 00:51:26.190
Find Next finds the next object
in a query that you've started.

00:51:27.340 --> 00:51:31.500
Find Record Handle isn't really
'find', it's kind of misnamed,

00:51:31.520 --> 00:51:36.860
but what it is is it retrieves additional
attributes or data from an object for

00:51:36.890 --> 00:51:38.540
which you already have the handle.

00:51:38.600 --> 00:51:41.850
Which really the only way to get
the handle is either by doing

00:51:41.850 --> 00:51:43.170
a 'find first' or 'find next'.

00:51:45.080 --> 00:51:47.150
So, like I said before,
I was going to talk a bit

00:51:47.370 --> 00:51:50.880
about access control lists.

00:51:51.480 --> 00:51:55.470
Tokens have to support a number
of access control list calls,

00:51:55.470 --> 00:51:59.710
and access control lists are
actually how we've implemented pins.

00:52:00.480 --> 00:52:05.300
There's get-owner, get-ackle,
change-owner, and change-ackle calls,

00:52:05.720 --> 00:52:08.680
where the star in between
is either a database,

00:52:08.740 --> 00:52:09.900
an object, or a key.

00:52:09.930 --> 00:52:15.370
This is where we differ from the
regular CSPDL spec in that in CSPDL,

00:52:15.420 --> 00:52:17.200
objects don't have ackles.

00:52:17.320 --> 00:52:21.130
For tokens, they do,
because it turns out a lot of Smart Cards

00:52:21.130 --> 00:52:25.870
actually have pins protecting generic
type objects and not just keys.

00:52:27.400 --> 00:52:35.440
An ACL consists of a number of entries.

00:52:35.450 --> 00:52:38.840
Each entry in an ACL consists
of the following three pieces.

00:52:38.840 --> 00:52:40.500
It consists of a tag,
which is really just a

00:52:40.500 --> 00:52:44.480
string describing the ACL,
or label.

00:52:44.760 --> 00:52:50.410
It has one or more authorizations,
which are the operations that

00:52:50.450 --> 00:52:52.700
that ACL entry authorizes.

00:52:52.740 --> 00:52:56.930
Which could be, you know, allows read,
allows write, allows encrypt, sign,

00:52:56.930 --> 00:52:57.700
whatever.

00:52:57.930 --> 00:52:59.640
And it has a subject.

00:52:59.710 --> 00:53:02.480
The subject is actually a
linked list that can get fairly,

00:53:02.750 --> 00:53:04.690
fairly complicated.

00:53:04.700 --> 00:53:08.700
Some examples of subjects
would be a protected password

00:53:08.700 --> 00:53:12.700
or a threshold subject,
which is a K of N.

00:53:12.700 --> 00:53:15.160
It could be an and or an or.

00:53:15.820 --> 00:53:21.330
or a PreAuth subject.

00:53:21.330 --> 00:53:21.330
I'll talk a little bit about
some other subjects later.

00:53:22.400 --> 00:53:24.900
Some subjects can recurse and
contain additional subjects.

00:53:24.980 --> 00:53:28.400
For example, a threshold subject,
you could say,

00:53:28.400 --> 00:53:34.170
here's an ACL that has a 1 of 2,
which essentially contains

00:53:34.300 --> 00:53:37.150
two other subjects,
one of which has to evaluate to

00:53:37.150 --> 00:53:39.610
true in order to satisfy that ACL.

00:53:40.020 --> 00:53:43.400
Subjects can also contain
one or more values.

00:53:43.660 --> 00:53:46.500
There are public and private values.

00:53:46.630 --> 00:53:48.990
Private values can't be
retrieved using the get calls,

00:53:48.990 --> 00:53:51.250
they can only be set using a change call.

00:53:51.450 --> 00:53:54.580
So an example of a private
value would be a pin,

00:53:54.860 --> 00:53:58.570
where you can set the pin
using a change ACL call,

00:53:58.570 --> 00:54:01.220
and when you get the ACL,
you get back the fact

00:54:01.220 --> 00:54:03.050
that it's a pin ACL,
but you don't get back what

00:54:03.180 --> 00:54:06.010
the value of the pin is,
because that would be silly.

00:54:09.340 --> 00:54:13.440
So, like I said before,
these are the entities that have ACLs.

00:54:13.450 --> 00:54:16.480
The database itself has an ACL.

00:54:16.490 --> 00:54:19.200
Each token represents a single database.

00:54:19.360 --> 00:54:22.890
The database is the card.

00:54:23.180 --> 00:54:27.200
Each key has an ACL and
objects can also have ACLs,

00:54:27.230 --> 00:54:33.000
which is unique to tokenD because
CDSA doesn't otherwise have that.

00:54:33.780 --> 00:54:38.700
Pin ACLs,
and this is how we've implemented pins.

00:54:38.860 --> 00:54:48.100
Typically, the entity that represents
a pin will be an ACL entry,

00:54:48.100 --> 00:54:52.590
usually on the database,
that has subject type, ACL subject type,

00:54:52.590 --> 00:54:54.080
preauth, source.

00:54:54.910 --> 00:54:58.760
Other ACLs, like the object, let's say,
so the database would have a preauth

00:54:58.760 --> 00:55:03.740
source type ACL with the tag pin 1,
giving it the name pin 1.

00:55:03.740 --> 00:55:07.040
Other ACLs, like an ACL on a key,
might require,

00:55:07.040 --> 00:55:10.630
in order to sign with this key,
you need to use that ACL over there.

00:55:10.790 --> 00:55:16.050
And it can refer to that ACL by
using ACL subject type preauth with

00:55:16.050 --> 00:55:18.790
the same tag as the source ACL.

00:55:19.570 --> 00:55:25.890
I mentioned pin 1, because in order for
an ACL to be a pin ACL,

00:55:26.080 --> 00:55:32.100
the tag has to start with the letters
PIN in caps and be followed by a number.

00:55:32.800 --> 00:55:37.200
If your card has a notion of
a user pin or a default pin,

00:55:37.400 --> 00:55:39.640
you'd want to call that pin 1.

00:55:39.900 --> 00:55:43.510
Because pins aren't first class objects,
there are some issues,

00:55:43.570 --> 00:55:46.540
which is pins can't refer to each
other and they're not special.

00:55:46.670 --> 00:55:48.920
There's no such thing
as a supervisor pin,

00:55:48.920 --> 00:55:52.120
and we currently don't have a way
to express that the supervisor

00:55:52.160 --> 00:55:53.650
pin unblocks some other pin.

00:55:53.650 --> 00:56:00.850
Pins can just allow or
disallow certain operations,

00:56:00.850 --> 00:56:02.000
and what those operations are,
are actually listed in CDSA.

00:56:04.820 --> 00:56:11.430
Some tips if you're writing a 'tokend':
Before each operation that

00:56:11.430 --> 00:56:17.430
uses an object from the token,
the read authorization is

00:56:17.430 --> 00:56:20.240
checked on the database ACL.

00:56:20.260 --> 00:56:26.230
So if you want anyone to read
anything from your token at all,

00:56:26.650 --> 00:56:31.350
then you have to allow read,
otherwise you won't be able to

00:56:31.350 --> 00:56:33.160
get any objects off the token.

00:56:33.160 --> 00:56:36.380
If there are any objects on the token
that don't require authorization,

00:56:36.380 --> 00:56:40.920
then the read ACL on the database
should be subject type any,

00:56:40.920 --> 00:56:43.130
which means anyone can read.

00:56:43.160 --> 00:56:47.810
You can then subsequently,
the ACL on the item itself is checked,

00:56:47.850 --> 00:56:50.230
so if you want to limit access
to particular objects and

00:56:50.240 --> 00:56:54.170
not allow them to be read,
you can set an ACL on the object itself.

00:56:55.230 --> 00:56:57.500
The read ACL on the database
actually applies to both the

00:56:57.580 --> 00:57:01.670
attributes and the data of an object,
whereas the read ACL on an

00:57:01.670 --> 00:57:03.570
object only applies to its data.

00:57:03.580 --> 00:57:07.830
If you can read the database,
you can read all objects' attributes.

00:57:10.380 --> 00:57:12.190
and Michael Broewer, John Hurley.

00:57:12.300 --> 00:57:18.300
So,
make sure that you make keys readable.

00:57:18.360 --> 00:57:20.660
That's a common mistake is to think,
"Well,

00:57:20.660 --> 00:57:22.280
I don't want my keys to be readable.

00:57:22.350 --> 00:57:24.590
I don't want people to
read my keys." Well,

00:57:24.590 --> 00:57:26.300
readable doesn't apply extractable.

00:57:26.300 --> 00:57:28.300
Readable means you can read
the key at the database level,

00:57:28.330 --> 00:57:30.300
which actually returns,
when you read a key,

00:57:30.360 --> 00:57:37.810
you get back a CSSM key structure
that tells you what the key is.

00:57:38.500 --> 00:57:41.630
But it's a reference to the key,
not the actual key bits themselves,

00:57:41.660 --> 00:57:43.900
which you obviously can't read.

00:57:44.460 --> 00:57:48.640
Finally, wrap up: ACLs.

00:57:48.640 --> 00:57:51.100
TokenD is responsible
for enforcing the ACLs.

00:57:51.100 --> 00:57:53.890
The system makes assumptions,
SecurityD makes assumptions about

00:57:53.890 --> 00:57:58.450
the ACLs and will pre-flight the
UI for you to get all the pins

00:57:58.450 --> 00:58:03.550
needed to satisfy what you claim
in your ACL structure you need.

00:58:03.630 --> 00:58:06.890
But it's still ultimately the
responsibility of TokenD to

00:58:06.890 --> 00:58:09.400
enforce the ACL rules.

00:58:09.400 --> 00:58:22.350
Michael Brouwere, John Hurley

00:58:23.760 --> 00:58:29.560
So then I got the last part,
Crypto Operations.

00:58:30.310 --> 00:58:33.450
There's three major
operations you can do on keys.

00:58:33.460 --> 00:58:35.580
There's a couple more,
but I'm not going to go into them.

00:58:35.810 --> 00:58:39.870
There's Decrypt, Generate Signature,
Unwrap Key.

00:58:40.010 --> 00:58:42.420
They're very similar
to the CSP operations,

00:58:42.470 --> 00:58:43.050
the same name.

00:58:43.080 --> 00:58:46.620
So if you look at the
CDSA documentation for these calls,

00:58:46.680 --> 00:58:48.780
that pretty much applies.

00:58:49.960 --> 00:58:54.740
RAPKEY and ENKRYPT are also there,
but you don't normally have to

00:58:54.810 --> 00:58:57.900
implement them on a token because
they're only meant for public keys.

00:58:57.900 --> 00:59:01.300
And the way the system is set up,
it'll use the built-in

00:59:01.300 --> 00:59:03.460
CSP for public key operations.

00:59:03.570 --> 00:59:07.500
It'll extract the public key from the
token and then just use the built-in CSP,

00:59:07.500 --> 00:59:08.900
which is faster.

00:59:08.900 --> 00:59:13.260
If you support symmetric keys,
then you will have to implement those,

00:59:13.260 --> 00:59:14.410
most likely.

00:59:14.910 --> 00:59:19.160
DeCrypt gets a key handle,
which is a handle that was obtained

00:59:19.280 --> 00:59:23.190
through one of those find calls,
which is not the object

00:59:23.210 --> 00:59:25.200
handle but the key handle.

00:59:25.360 --> 00:59:30.600
The context contains all the additional
information like what mode to use,

00:59:30.660 --> 00:59:33.480
padding, algorithm type, etc.

00:59:33.480 --> 00:59:33.480
The rest is

00:59:34.100 --> 00:59:39.790
and Michael Broewer, John Hurley.

00:59:40.320 --> 00:59:48.510
Generate signature,
very similar to decrypt.

00:59:48.510 --> 00:59:48.510
Of course, you're not doing any

00:59:48.790 --> 01:00:01.940
Unwrap key is needed if you want
to support SMIME decryption.

01:00:01.970 --> 01:00:04.460
A lot of tokens that we've
supported only support signing.

01:00:04.460 --> 01:00:06.400
If you need decryption,
you're going to have

01:00:06.400 --> 01:00:07.580
to support unwrap key.

01:00:07.580 --> 01:00:10.620
And in particular,
you'll need to support unwrapping

01:00:10.700 --> 01:00:14.560
a symmetric key with a private key,
according to the way the

01:00:14.620 --> 01:00:16.840
SMIME standard specifies it.

01:00:18.000 --> 01:00:29.370
and Michael Broewer, John Hurley.

01:00:29.450 --> 01:00:29.450
These three operations will make
all the applications we just

01:00:29.450 --> 01:00:29.450
showed you work with your token.

01:00:29.750 --> 01:00:37.260
Summary What tokend does is it allows
shared access to a Smart Card or token.

01:00:37.260 --> 01:00:41.580
It's fairly simple to implement,
especially with the C++ layer.

01:00:41.580 --> 01:00:45.980
You can get a token up and
running in probably a day or two,

01:00:45.980 --> 01:00:50.100
because you really only need
to implement about five or six

01:00:50.140 --> 01:00:53.320
commands to talk to your card.

01:00:53.320 --> 01:00:55.740
It's not PKS 11.

01:00:56.190 --> 01:00:59.790
It's possible to implement
a tokend on top of PICSS11,

01:00:59.790 --> 01:01:04.640
except for probe, which is not something
PICSS11 normally supports.

01:01:05.600 --> 01:01:09.830
We don't have any tokend's that
we've written on top of PICSS11,

01:01:09.880 --> 01:01:13.600
because it turns out that the
complexity of PICSS11 just makes

01:01:13.600 --> 01:01:16.760
it more work to write a tokend than
just implementing these four or

01:01:16.790 --> 01:01:18.300
five calls you have to implement.

01:01:18.410 --> 01:01:21.690
Which is all you have to do
when you're using the C++ layer.

01:01:22.260 --> 01:01:24.330
So in most cases,
it's a lot less work to write

01:01:24.330 --> 01:01:28.080
a 'tokend' than it is to
write a 'Pecosys 11' library.

01:01:28.830 --> 01:01:34.080
I didn't talk about the
SPIs to modify a token,

01:01:34.120 --> 01:01:36.770
to generate a key or insert a new record,
etc.

01:01:37.140 --> 01:01:40.050
Those callbacks are there
and you can look those up,

01:01:40.220 --> 01:01:45.360
but we don't currently have tokenies
that we ship that support that,

01:01:45.360 --> 01:01:46.990
although it should work.

01:01:49.060 --> 01:01:53.640
So, last thing,
existing Smart Card solutions, well,

01:01:53.640 --> 01:01:57.900
existing vertical apps
should continue to work.

01:01:57.930 --> 01:02:00.200
Last year,
if any of you were at my presentation,

01:02:00.240 --> 01:02:03.890
we presented what we thought the
Smart Card architecture was going to be.

01:02:04.120 --> 01:02:07.060
Well,
everything we said last year was true,

01:02:07.210 --> 01:02:09.740
except the part where we said that
your vertical apps wouldn't work.

01:02:09.770 --> 01:02:11.000
It turns out they will.

01:02:11.000 --> 01:02:14.240
So, all the other things we
promised actually happened,

01:02:14.270 --> 01:02:17.280
and we managed to do it in such
a way that your existing apps

01:02:17.360 --> 01:02:20.980
should still work and be able to
coexist with the tokend system.

01:02:21.000 --> 01:02:24.060
And the reason is we don't take
exclusive access to the card,

01:02:24.060 --> 01:02:25.500
but we use transactions.

01:02:25.500 --> 01:02:29.970
So, as long as tokend doesn't--isn't
in the middle of a transaction,

01:02:29.970 --> 01:02:32.570
you should be able to access the card.

01:02:33.620 --> 01:02:39.740
And with that,
I'd like to bring up the Q&A panel.

01:02:40.500 --> 01:02:43.000
and I'm sure you've
seen this slide before.

01:02:43.000 --> 01:02:45.220
There's one other
session related to this,

01:02:45.220 --> 01:02:48.740
which is the Security Feedback Forum,
and we'd really appreciate to hear

01:02:48.740 --> 01:02:55.730
your feedback if we run out of time
today in the Q&A on token-D issues,

01:02:55.730 --> 01:02:55.730
etc.
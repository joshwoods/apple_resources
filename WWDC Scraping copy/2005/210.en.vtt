WEBVTT

00:00:02.610 --> 00:00:05.070
Hello everyone and
welcome to session 210,

00:00:05.070 --> 00:00:09.600
the Essential Ingredients for
Mac OS X Imaging Solutions.

00:00:09.730 --> 00:00:15.170
Today I will talk about some

00:00:15.370 --> 00:00:20.300
things that really come out
of the box with Mac OS X.

00:00:20.300 --> 00:00:26.520
And it's basically a simple
application that we want to

00:00:26.520 --> 00:00:28.900
create during this session.

00:00:28.960 --> 00:00:35.200
It's called "My Photo." No resemblance
to any other package that you may know.

00:00:35.200 --> 00:00:40.070
We will do it in a couple of steps,
basically going from zero to

00:00:40.160 --> 00:00:42.300
"My Photo" in eight steps.

00:00:42.300 --> 00:00:46.240
And we will focus on a
couple of technologies that

00:00:46.460 --> 00:00:51.900
are coming with Mac OS X,
mainly image capture and image I/O.

00:00:51.900 --> 00:00:57.340
For image capture, it's important,
of course, that whenever you want

00:00:57.340 --> 00:01:01.110
to talk with a device,
you really want to get to know,

00:01:01.110 --> 00:01:05.280
is there an image capture
device connected or not?

00:01:06.000 --> 00:01:11.250
We, for that MyPhoto application,
we are very interested in cameras only.

00:01:11.330 --> 00:01:15.840
So how do we find out whether
a camera is connected or not?

00:01:15.860 --> 00:01:17.150
Well, very simple.

00:01:17.180 --> 00:01:18.700
We jump directly into the APIs.

00:01:18.810 --> 00:01:21.740
We have two APIs that will do that.

00:01:21.770 --> 00:01:26.440
And the first one is ICA Get Device List.

00:01:26.470 --> 00:01:30.640
And the other one is the
ICA Copy Object Property Dictionary.

00:01:30.640 --> 00:01:33.820
That's on the hit list
for the longest API name,

00:01:33.820 --> 00:01:34.820
but we didn't make it quite.

00:01:35.550 --> 00:01:41.130
So, for all Image Capture APIs,
it's important to remember

00:01:41.380 --> 00:01:43.190
we have two parameters.

00:01:43.270 --> 00:01:49.840
The first parameter is a parameter block,
where we fill in certain information.

00:01:49.930 --> 00:01:53.000
And the second one is
a callback function,

00:01:53.070 --> 00:01:54.860
which could be null.

00:01:54.930 --> 00:01:58.630
In that case,
you're making a synchronous call.

00:01:58.820 --> 00:02:02.000
However, for most of the calls,
I would really recommend that

00:02:02.000 --> 00:02:03.300
you are doing asynchronous calls.

00:02:03.300 --> 00:02:04.360
Very simple.

00:02:04.360 --> 00:02:08.810
It may take some time to get
information back from the device.

00:02:08.820 --> 00:02:13.040
It could be a slow USB connection,
or you could have thousands of images,

00:02:13.040 --> 00:02:15.080
for example, on your iPod photo.

00:02:15.080 --> 00:02:17.890
And it takes some time to
get the information back.

00:02:17.960 --> 00:02:20.160
You do not want to pluck your UI.

00:02:20.160 --> 00:02:22.600
You could do it in separate threads.

00:02:22.600 --> 00:02:23.820
Yes, that's possible.

00:02:24.470 --> 00:02:27.540
But I will show you today that
you can very easily do it by

00:02:27.590 --> 00:02:29.760
just using asynchronous calls.

00:02:31.660 --> 00:02:35.330
And here, important to notice that these
calls are available on the

00:02:35.330 --> 00:02:40.100
PowerPC variant of Mac OS X,
but also on the Intel.

00:02:40.150 --> 00:02:45.610
And there's really no difference
for you in coding practice.

00:02:45.960 --> 00:02:50.310
If you look at the first
ICA Get Device List,

00:02:50.570 --> 00:02:58.500
the first API,
this API returns an opaque ICA object.

00:02:59.310 --> 00:03:01.360
Interesting thing is,
it returns it always,

00:03:01.520 --> 00:03:03.490
also meaning you have
no device connected.

00:03:03.500 --> 00:03:08.030
You always get back that
IC object for the device list.

00:03:09.260 --> 00:03:16.200
And this is, you can see that as a root
of an object hierarchy.

00:03:18.650 --> 00:03:22.380
So if you have, for example,
two cameras connected,

00:03:22.380 --> 00:03:27.210
then the hierarchy, if you look at it,
would look like we have a device

00:03:27.270 --> 00:03:35.170
list object at the top and
two camera ICA objects below.

00:03:35.500 --> 00:03:40.400
And in order to find out, well,
how many cameras do I have connected,

00:03:40.400 --> 00:03:45.170
I'm using the second,
the ICA Copy Object Property Dictionary

00:03:45.170 --> 00:03:49.220
call to return a dictionary
with that information.

00:03:50.180 --> 00:03:57.530
Now, for the device list object,
this API returns a dictionary that has,

00:03:57.530 --> 00:04:05.200
for each connected device, the name,
the type, whether it's camera, scanner,

00:04:05.500 --> 00:04:08.710
It has a path to the device module.

00:04:08.800 --> 00:04:10.900
It could be interesting for
your application to know,

00:04:10.900 --> 00:04:14.080
oh, it's a mass storage device,
so in my UI,

00:04:14.300 --> 00:04:19.830
I can actually bring up an eject
button or an eject UI element.

00:04:19.830 --> 00:04:26.960
And you can, via, for example,
Cocoa Calls,

00:04:26.960 --> 00:04:26.960
you can unmount the device volume.

00:04:26.960 --> 00:04:26.960
Very easy to do.

00:04:28.180 --> 00:04:30.330
And as last thing,
you'll get extra information

00:04:30.330 --> 00:04:31.780
about the connection info.

00:04:31.780 --> 00:04:34.970
For example,
is it a USB or is it FireWire?

00:04:35.310 --> 00:04:38.590
Is it SCSI or whatever?

00:04:40.290 --> 00:04:45.520
The supported device types, again,
both on PowerPC and Intel,

00:04:45.520 --> 00:04:50.240
are mainly mass storage and PTP.

00:04:50.330 --> 00:04:53.540
And years ago we were suggesting
to all device vendors,

00:04:53.590 --> 00:04:56.850
"Hey,
really think about PTP." Because PTP,

00:04:56.960 --> 00:05:00.550
the picture transfer protocol,
has a lot of advantages.

00:05:01.450 --> 00:05:06.300
Sure, it's probably very easy to
implement a mass storage camera,

00:05:06.300 --> 00:05:08.400
but all you can do in
that case is really,

00:05:08.400 --> 00:05:09.630
you can download the images.

00:05:09.700 --> 00:05:12.180
There's no way,
nothing you can do with the device.

00:05:12.200 --> 00:05:14.140
You cannot control it.

00:05:14.140 --> 00:05:19.610
PTP, on the other side, allows you to,
for example, send a message,

00:05:20.010 --> 00:05:23.610
take picture, or delete,
or synchronize clock,

00:05:23.610 --> 00:05:26.100
or a couple of other things.

00:05:26.380 --> 00:05:32.390
And actually today, for our MyPhoto app,
we will use the PDP camera and we

00:05:32.390 --> 00:05:36.880
will use some of the nice commands,
for example, take picture,

00:05:36.880 --> 00:05:38.910
and integrate that into the app.

00:05:39.000 --> 00:05:46.260
So let's go to the demo and just...

00:05:48.050 --> 00:05:51.200
I want to show you, we have in step one,
which by the way,

00:05:51.200 --> 00:05:53.390
you can download these sources.

00:05:53.530 --> 00:06:00.600
We probably have them already if you
downloaded the WWDC developer package.

00:06:01.170 --> 00:06:07.140
So step one, let me quickly go to the
Nib file that we have.

00:06:07.140 --> 00:06:13.490
Should launch Interface Builder.

00:06:17.560 --> 00:06:18.740
Thanks, okay.

00:06:18.890 --> 00:06:23.960
So, we will have a single window.

00:06:24.110 --> 00:06:29.500
In that window we will have a
table view on the left side.

00:06:29.500 --> 00:06:34.390
And the right side we will put
in a tab view where we can switch

00:06:34.390 --> 00:06:39.000
the content depending on what's
selected in the table view.

00:06:40.540 --> 00:06:47.810
The data source and the delegate of this
NS TableView is our ICA Handler class,

00:06:47.810 --> 00:06:53.700
which will be instantiated when
we launch and load the Nib.

00:06:54.350 --> 00:06:58.740
Okay, that's on interface builder.

00:06:58.950 --> 00:07:02.590
Now, let's look at the classes,
the code we have.

00:07:02.660 --> 00:07:07.320
Well, we have only two source files,
just the ICA handler.h and .m.

00:07:07.320 --> 00:07:12.190
And the .h file,
we just have the handler,

00:07:12.520 --> 00:07:15.980
which has an outlet to a table view,
a window.

00:07:15.980 --> 00:07:21.620
We keep track of the device list object,
and we have an array with

00:07:21.620 --> 00:07:23.760
all the device names.

00:07:26.640 --> 00:07:31.050
On the application side,
we have one very nice thing you

00:07:31.050 --> 00:07:36.500
probably want to do in single-window,
non-document-based applications.

00:07:36.510 --> 00:07:39.440
You want to quit whenever
the last window is closed.

00:07:39.450 --> 00:07:41.830
All you have to do in
Cocoa to do that is overwrite.

00:07:41.900 --> 00:07:44.540
Application should terminate
after the last window is closed.

00:07:44.690 --> 00:07:48.160
Return yes,
and it will handle that for you.

00:07:48.960 --> 00:07:52.400
Let's look at our Awake from Nib call.

00:07:52.560 --> 00:07:58.100
In that, we allocate a mutable
array for the device names.

00:07:58.400 --> 00:08:03.790
And the next step would be to find
out what devices are connected.

00:08:03.800 --> 00:08:06.770
Well, if you go to that one,
it's exactly what I told you.

00:08:06.880 --> 00:08:09.930
It's just a single
API IC Get Device List.

00:08:09.930 --> 00:08:12.910
But note in this case,
for the first two steps,

00:08:12.910 --> 00:08:14.800
we actually will do synchronous calls.

00:08:14.840 --> 00:08:18.430
Just get feel for the API,
the way to call it,

00:08:18.440 --> 00:08:22.840
and then we will start off
with asynchronous calls.

00:08:23.150 --> 00:08:27.010
So if the ICA-GET device
list returns null,

00:08:27.200 --> 00:08:34.000
no error, sorry, then the PB object is
the device list object.

00:08:34.400 --> 00:08:40.700
Keep that in our data member and get
the device list property dictionary.

00:08:40.730 --> 00:08:41.920
Now this dictionary

00:08:43.600 --> 00:08:44.740
Load it here.

00:08:44.780 --> 00:08:50.210
After setting up the parameter block,
just use the MDeviceList object.

00:08:50.700 --> 00:08:58.700
[Transcript missing]

00:08:59.120 --> 00:09:05.940
Now, this is just another dictionary
for each device that is connected,

00:09:06.070 --> 00:09:07.760
that's available.

00:09:07.930 --> 00:09:12.690
And all we do is we iterate,
create an iterator,

00:09:13.500 --> 00:09:22.500
[Transcript missing]

00:09:22.880 --> 00:09:29.840
The entry with the iFill item
file name to our device names.

00:09:29.970 --> 00:09:32.520
And at the end, we just say, well,
table reload,

00:09:32.520 --> 00:09:34.460
so we update the table view.

00:09:35.890 --> 00:09:40.480
Now,
as a data source for an NS TableView,

00:09:40.510 --> 00:09:43.730
there's one thing you have to implement,
and that's the number

00:09:43.730 --> 00:09:45.590
of rows in TableView.

00:09:47.500 --> 00:09:51.500
Note that we are always
returning at least one.

00:09:51.600 --> 00:09:54.300
The reason for that is if
there's no camera connected,

00:09:54.350 --> 00:09:56.180
we just don't want to
have an empty table.

00:09:56.230 --> 00:09:59.940
We really want to clearly say, "Hey,
there's no camera connected."

00:10:00.260 --> 00:10:05.000
And in order to do that,
it's basically return one or the

00:10:05.000 --> 00:10:09.480
actual count of devices connected.

00:10:09.510 --> 00:10:17.070
And then when asked for the object value,
what we do is if we have a count,

00:10:17.070 --> 00:10:22.730
so we do have a device,
then we return the item,

00:10:22.730 --> 00:10:28.200
the object at index row
out of our device names.

00:10:28.240 --> 00:10:31.750
And when asked for the icon,
we currently return null.

00:10:32.600 --> 00:10:40.610
If the device name "count" is zero,
well then we just return the fixed string

00:10:40.610 --> 00:10:45.230
"no camera connected". So let's run this.

00:10:46.150 --> 00:10:49.790
Well, as expected,
we have no camera connected.

00:10:49.910 --> 00:10:54.190
The table view shows up
as no camera connected.

00:10:54.820 --> 00:10:56.570
Now, let's quit this.

00:10:56.690 --> 00:10:59.140
Turn on the camera.

00:10:59.460 --> 00:11:03.400
And one thing that we were
using in the past years,

00:11:03.410 --> 00:11:07.550
but actually today with the new
Image Capture SDK that will be

00:11:07.550 --> 00:11:11.250
posted either today or tomorrow,
you can download these new tools.

00:11:11.510 --> 00:11:15.090
The ICA Launcher, for example,
is a small tool that shows

00:11:15.090 --> 00:11:19.100
you which of the Image Capture
component is currently running.

00:11:19.240 --> 00:11:21.540
The first one here is a
faceless background application,

00:11:21.540 --> 00:11:23.790
the Image Capture extension.

00:11:24.280 --> 00:11:27.950
Now,
this Image Capture extension is loaded

00:11:27.990 --> 00:11:33.920
automatically whenever there's a device
connected or whenever a client would

00:11:35.150 --> 00:11:39.960
launch and make an Image Capture request.

00:11:40.070 --> 00:11:45.250
So now,
if the camera is connected and I... Oh,

00:11:45.300 --> 00:11:48.340
okay, camera was not connected.

00:11:48.360 --> 00:11:50.630
So I connect the camera.

00:11:51.510 --> 00:11:56.100
Make sure PDP is showing up.

00:11:56.100 --> 00:11:58.590
I launch this.

00:11:58.630 --> 00:12:00.600
It still says no camera connected.

00:12:01.220 --> 00:12:03.590
Well, why is that?

00:12:04.580 --> 00:12:11.050
Let's see, we can have a look at this,
whenever you run into this situation.

00:12:11.190 --> 00:12:15.880
We have a new tool that's
called ICA API Tester.

00:12:16.030 --> 00:12:21.310
ICA API Tester is something
that lists all the Image Capture

00:12:21.310 --> 00:12:25.370
APIs in a table view,
and all you do is you can

00:12:25.430 --> 00:12:30.480
select the API that you want
to look at and execute it.

00:12:30.530 --> 00:12:34.250
So it's basically a single-step thing.

00:12:34.660 --> 00:12:38.860
Now we get a device list
and now we could use the

00:12:38.860 --> 00:12:44.280
ICA Copy Object Property Dictionary
for that device list object.

00:12:44.370 --> 00:12:48.730
And we see there's still no device,
so there's something wrong

00:12:48.840 --> 00:12:50.270
with my connection here.

00:12:50.930 --> 00:12:54.930
But this here is really
executing an API at a time.

00:12:55.060 --> 00:12:58.220
And let me see.

00:13:07.850 --> 00:13:10.300
Turning on the camera.

00:13:10.300 --> 00:13:14.530
And an interesting thing on the
side here is it actually shows

00:13:14.560 --> 00:13:16.040
you the contents of the camera.

00:13:16.080 --> 00:13:20.470
So if I would do for the device list,

00:13:20.800 --> 00:13:25.910
"Execute the copy object
property dictionary call again.

00:13:26.220 --> 00:13:27.930
Then you see actually what this returns.

00:13:27.940 --> 00:13:30.700
And this here is the device
array I was talking about.

00:13:30.770 --> 00:13:34.520
So that's the information
that I get per device."

00:13:35.170 --> 00:13:40.570
It's very handy to have this tool
around because you can really verify,

00:13:40.570 --> 00:13:43.300
is something wrong with my
application or is really the

00:13:43.310 --> 00:13:45.800
connection broken or whatever.

00:13:45.950 --> 00:13:50.840
So this also means that if I run
the Step 1 application here,

00:13:50.950 --> 00:13:55.270
okay, now we get correctly the D70.

00:13:55.530 --> 00:13:57.940
Okay, let's go back to the

00:14:00.100 --> 00:14:07.360
The problem with the
very first step here was,

00:14:07.520 --> 00:14:13.790
while we run and do the initial
query for the device dictionary,

00:14:13.980 --> 00:14:18.810
But we will not react on
any change on the bus.

00:14:19.030 --> 00:14:21.120
So you turn on the camera,
turn off the camera,

00:14:21.120 --> 00:14:24.070
nothing in the application
will be updated automatically.

00:14:24.100 --> 00:14:28.900
So how can we make sure
that this will change?

00:14:28.900 --> 00:14:33.200
Well, there's an API called
ICA Register Event Notification.

00:14:34.490 --> 00:14:38.690
If you use that,
then you can register for

00:14:38.690 --> 00:14:41.730
a single specific event,
for example,

00:14:42.100 --> 00:14:43.730
device added or device removed.

00:14:43.900 --> 00:14:46.970
Or you can register for all events.

00:14:49.410 --> 00:14:53.380
So in our case where we have a device
list and two cameras connected,

00:14:53.390 --> 00:14:55.340
this could actually
match if camera one is,

00:14:55.430 --> 00:14:59.760
for example, a PDP camera,
this camera two is a mass storage device.

00:14:59.790 --> 00:15:05.620
Then that would internally type,
we have also another user space,

00:15:05.630 --> 00:15:10.600
faceless background application that
takes care of the different protocols.

00:15:10.710 --> 00:15:15.070
So let's say we
disconnect the PDP camera.

00:15:15.260 --> 00:15:20.450
So then the IC object for that and
also the module that is running

00:15:20.890 --> 00:15:24.690
the PDP code would disappear.

00:15:25.420 --> 00:15:28.140
And by registering for
these device notifications,

00:15:28.140 --> 00:15:30.990
your application will
actually get notified,

00:15:30.990 --> 00:15:33.230
as we will see in step two.

00:15:37.680 --> 00:15:42.960
So step two,
what we are going to do is we,

00:15:42.960 --> 00:15:45.910
in our Awake from Nib,

00:15:46.320 --> 00:15:50.340
We will call register
for device notification.

00:15:50.380 --> 00:15:57.690
Now, this registration, as I said before,
could be, and we would recommend that,

00:15:57.690 --> 00:16:00.570
you would do it for all objects,
all types.

00:16:00.750 --> 00:16:05.920
So specifying a zero for object
and notification type simply

00:16:05.920 --> 00:16:08.390
means do it for all types.

00:16:08.600 --> 00:16:14.900
[Transcript missing]

00:16:15.370 --> 00:16:19.480
Now,
this device notification callback will

00:16:19.480 --> 00:16:25.540
get called whenever something happens,
whenever there's notification from

00:16:25.540 --> 00:16:27.800
the device module up to the clients.

00:16:27.920 --> 00:16:33.150
And the simplest case could
be device added or whatever.

00:16:33.890 --> 00:16:38.660
So what we do in here is
we take the RefCon that we

00:16:39.220 --> 00:16:46.060
specified on the register call,
use that to go back to the ICA handler,

00:16:46.060 --> 00:16:50.970
so we do not need a global for that,
and call the handler with

00:16:50.970 --> 00:16:56.640
the device notification.

00:16:58.710 --> 00:17:05.000
For the device notification,
what we do is we check the event type.

00:17:05.020 --> 00:17:12.360
And if the event type is either
device removed or device added,

00:17:12.380 --> 00:17:17.400
then we just get the device
list property dictionary again.

00:17:17.600 --> 00:17:21.960
We made just from step
one just a slight change,

00:17:21.960 --> 00:17:27.950
because for step one we were not
anticipating that we had to be called,

00:17:27.980 --> 00:17:31.480
to be saved, to be called multiple times.

00:17:31.540 --> 00:17:38.020
So we would just add device
names to it over and over again.

00:17:38.340 --> 00:17:44.420
So we clean up first,
and then we loop over the device

00:17:44.420 --> 00:17:48.000
array to get the information.

00:17:48.200 --> 00:17:51.190
So that simply means if I run this,

00:17:56.400 --> 00:18:01.950
We should now have our small My Photo,
which in this case it starts

00:18:02.090 --> 00:18:04.340
up with the camera connected.

00:18:04.340 --> 00:18:08.980
I turn the camera off and immediately
it says "no camera connected". So,

00:18:09.410 --> 00:18:14.680
kind of easy to get to that state
that we will get notified whenever

00:18:14.680 --> 00:18:19.700
there's a change in number of devices.

00:18:19.900 --> 00:18:21.930
Back to the slides, please.

00:18:24.430 --> 00:18:27.360
Now, how do we get more
information about a device?

00:18:27.500 --> 00:18:32.380
For example, it would be interesting
if we look at our iPhoto.

00:18:32.500 --> 00:18:34.490
Actually,
whenever you have a device connected,

00:18:34.580 --> 00:18:39.680
you will see a text saying,
"Device full connected and we

00:18:39.890 --> 00:18:42.570
have 57 images to download."

00:18:42.940 --> 00:18:45.270
So, we want to do a similar thing.

00:18:45.270 --> 00:18:50.130
So, we want to display the number of
images that we have on the device,

00:18:50.130 --> 00:18:54.140
and as before, the same thing we did
with the device list,

00:18:54.240 --> 00:18:58.830
ICA Copy Object Property Dictionary
allows you to get information

00:18:58.830 --> 00:19:00.680
about an ICA object.

00:19:00.800 --> 00:19:02.670
And if you use that
with the device object,

00:19:02.670 --> 00:19:04.750
you'll get information about the device.

00:19:04.750 --> 00:19:08.960
For example, you get, again, the name,
the type, device module,

00:19:09.020 --> 00:19:12.790
the connection info,
but you get additional information.

00:19:13.020 --> 00:19:15.790
You will get the device capabilities.

00:19:15.830 --> 00:19:19.800
For example,
is this device able to take pictures?

00:19:20.240 --> 00:19:23.800
Unfortunately,
not all PDP cameras allow you to do that.

00:19:23.800 --> 00:19:27.180
I really hope that more
vendors put that in because,

00:19:27.180 --> 00:19:31.690
really, it's a standard PDP command,
and it would be so nice.

00:19:31.690 --> 00:19:38.090
You could do so many cool things
if the camera would support that.

00:19:39.110 --> 00:19:40.960
And then two important entries.

00:19:41.020 --> 00:19:44.310
These are the data array
and the tree dictionary.

00:19:44.400 --> 00:19:51.220
The data array actually is a
flattened out array with images,

00:19:51.240 --> 00:19:53.890
movies, and sound files.

00:19:54.220 --> 00:19:58.240
So, but just looking at that array and
looking at the count of that array,

00:19:58.240 --> 00:20:02.930
you know exactly how many images
do you have on that device.

00:20:04.080 --> 00:20:07.290
For each image or for each
entry you will have a name,

00:20:07.570 --> 00:20:11.490
a size, the ICE object,
and a couple of flags.

00:20:11.580 --> 00:20:12.890
For example, is it locked?

00:20:13.080 --> 00:20:17.330
Is it a raw image file?

00:20:17.330 --> 00:20:17.330
And that?

00:20:17.990 --> 00:20:23.290
and so so normal case normal situation
it's it's fine to just look at the

00:20:23.290 --> 00:20:29.070
data array there might be some cases
where you really want to have knowledge

00:20:29.070 --> 00:20:33.660
about the structure like what folder
what sub directory is this image

00:20:33.910 --> 00:20:40.530
in or are there additional files
for example firmware files or depof

00:20:40.530 --> 00:20:46.560
information things that are just
represented as a file on the camera file

00:20:46.560 --> 00:20:51.170
system but are not that are not images

00:20:51.740 --> 00:20:54.900
In this case,
you can use the Tree Dictionary

00:20:55.020 --> 00:20:57.160
to get to that information.

00:20:59.450 --> 00:21:03.480
One additional thing would be really
nice is if you could display the same

00:21:03.480 --> 00:21:07.590
way Image Capture application does it,
display an icon for that device.

00:21:07.660 --> 00:21:08.850
So how are you doing that?

00:21:09.060 --> 00:21:11.750
Well, there's a new

00:21:12.110 --> 00:21:15.600
We have a new API,
ICA Copy Object Thumbnail,

00:21:15.600 --> 00:21:23.640
that will return the device
thumbnail in different flavors.

00:21:23.640 --> 00:21:30.360
So you can request the thumbnail,
for example, as JPEG image, as TIFF,

00:21:30.530 --> 00:21:37.720
or as the uncompressed RGB data,
which is our old ICA thumbnail format.

00:21:38.720 --> 00:21:41.520
For device icons,
I would really recommend to use the

00:21:41.520 --> 00:21:45.600
TIFF flavor because it has the advantage,
it has the alpha channel.

00:21:45.830 --> 00:21:52.330
And most of the camera icons
that you will have are ICNS-based

00:21:52.330 --> 00:21:55.600
images with alpha information.

00:21:55.700 --> 00:22:00.230
So just drawing that, it's way easier,
it looks better if you use TIFF.

00:22:00.860 --> 00:22:05.980
So let's go to the next
variants of our application.

00:22:06.440 --> 00:22:16.090
And in step three, we are adding a few
things to the ICA handler.

00:22:17.810 --> 00:22:25.050
We switch, instead of having just
the array of device names,

00:22:25.050 --> 00:22:32.600
we want to have an array with actually
the device dictionary and also a

00:22:32.630 --> 00:22:37.350
device list array that is more or
less the device array that we get

00:22:37.360 --> 00:22:44.450
from the ICA copy object property
dictionary for the device object,

00:22:44.490 --> 00:22:47.320
for the device root object.

00:22:49.780 --> 00:22:52.340
What we do is we,
in the device list array,

00:22:52.340 --> 00:22:56.670
so we just copy the devices.

00:22:58.100 --> 00:23:04.500
[Transcript missing]

00:23:04.940 --> 00:23:14.070
An item in our table view,
if there was a selection,

00:23:14.070 --> 00:23:14.070
which simply means that selected
row is not equal to negative one,

00:23:14.240 --> 00:23:17.700
In that case,
we want to do something special.

00:23:17.700 --> 00:23:23.120
We really want to display the number
of images that are on this device.

00:23:24.540 --> 00:23:27.590
And the easiest thing to do it is,
as I said,

00:23:27.640 --> 00:23:36.430
is really do an IC copy object property
dictionary for the device object.

00:23:37.090 --> 00:23:41.000
In this case, you notice that we are
doing an asynchronous call.

00:23:41.180 --> 00:23:43.590
Simply means after

00:23:43.810 --> 00:23:50.160
We send this off, we immediately return,
and UI will be responsive.

00:23:50.940 --> 00:23:55.360
We will get called with
GodDevice dictionary.

00:23:55.590 --> 00:24:02.460
GodDevice dictionary,
very thin global function that just

00:24:02.670 --> 00:24:07.750
dispatches back to our ICA handler.

00:24:08.160 --> 00:24:14.140
In our ICA handler,
we look at the data array.

00:24:14.830 --> 00:24:20.300
Get the count and update
our UI to display ready to

00:24:20.300 --> 00:24:23.080
import so and so many images.

00:24:24.220 --> 00:24:28.140
If the count is zero, let me just say,
hey, there are no images on that device.

00:24:31.900 --> 00:24:37.500
[Transcript missing]

00:24:37.960 --> 00:24:42.420
We know now the number of
images that are on this device.

00:24:42.640 --> 00:24:46.600
We want to get the camera thumbnail.

00:24:47.240 --> 00:24:54.440
Very simple to do is just go ahead,
specify as thumbnail format, you specify,

00:24:54.440 --> 00:24:58.810
oh yeah,
you want to have the TIFF variant.

00:25:00.110 --> 00:25:10.600
You fill in the object,
the ICA object for the device.

00:25:10.600 --> 00:25:14.240
And you call ICA copy object thumbnail.

00:25:17.230 --> 00:25:19.420
Callback function.

00:25:19.420 --> 00:25:23.860
And callback functions are
just three lines of code

00:25:24.170 --> 00:25:26.930
dispatched back to the IC object.

00:25:27.090 --> 00:25:29.330
And what we do is very simple.

00:25:29.330 --> 00:25:31.490
We want to display that.

00:25:32.450 --> 00:25:38.280
"We have a camera icon, the thumbnail,
and all we do is we get the data,

00:25:39.400 --> 00:25:43.590
Out of that parameter block,
allocate an NS image,

00:25:43.710 --> 00:25:46.210
initialize that with the data.

00:25:46.820 --> 00:25:54.530
We show the NSImageView, set the image,
release the image, and release the data,

00:25:54.540 --> 00:25:55.940
and we're done.

00:25:56.070 --> 00:25:58.090
Now let's run this.

00:26:01.100 --> 00:26:08.060
So, we have a camera connected
and now we do select this row.

00:26:08.060 --> 00:26:12.390
And you see we have already
the number of images.

00:26:12.680 --> 00:26:15.440
"And the camera icon, very nicely.

00:26:15.440 --> 00:26:19.310
So we are about ready to import."

00:26:20.350 --> 00:26:27.270
Now, in step four, we want to enhance,
based on the APIs that

00:26:27.270 --> 00:26:29.800
we were talking about,
we want to enhance the

00:26:29.800 --> 00:26:31.640
application just slightly.

00:26:31.640 --> 00:26:37.040
And let me run it first,
then we look at what we are doing.

00:26:37.180 --> 00:26:39.600
So same behavior.

00:26:39.660 --> 00:26:44.020
But now we want to do something
special when the user double clicks.

00:26:44.060 --> 00:26:48.850
Well, what we want to do is we want to
give the user the choice to select

00:26:48.850 --> 00:26:52.360
the images that are on the device.

00:26:52.450 --> 00:26:56.580
And so before downloading.

00:26:57.390 --> 00:27:00.400
So you don't have to
download all the images.

00:27:00.560 --> 00:27:02.740
Just select the ones
that are on the device.

00:27:02.750 --> 00:27:07.370
And for example,
just select the last three,

00:27:07.370 --> 00:27:09.390
and we will update the UI.

00:27:09.550 --> 00:27:12.780
Three out of nine are
selected and all that.

00:27:13.300 --> 00:27:15.710
So how do we do that?

00:27:15.870 --> 00:27:19.210
Well, for step four,
there was not much to do.

00:27:19.510 --> 00:27:24.170
First thing we have to do is
we have to special handle the

00:27:24.170 --> 00:27:27.220
double click on the table row.

00:27:27.330 --> 00:27:31.870
In order to do that, all you have to set
up is a double action.

00:27:32.640 --> 00:27:36.660
So this simply means when
double-clicking on a row,

00:27:36.660 --> 00:27:37.840
execute this.

00:27:37.840 --> 00:27:40.200
Execute browse device.

00:27:40.390 --> 00:27:46.190
So browse device,
all we do is we have a tab view.

00:27:46.400 --> 00:27:52.610
Where we switch away from the
plank area and switch in to

00:27:52.610 --> 00:28:00.950
another table view where we display
each image that's on the device.

00:28:02.670 --> 00:28:06.760
And since we have now
a second table view,

00:28:06.830 --> 00:28:10.590
we have to update our number
of rows in table view.

00:28:11.350 --> 00:28:14.240
Now we have to handle,
really to distinguish between the,

00:28:14.240 --> 00:28:17.010
is it the original one
where we had the devices,

00:28:17.010 --> 00:28:20.600
or is it the one where we
are showing the images?

00:28:21.300 --> 00:28:23.270
If you're looking at
the one for the devices,

00:28:23.280 --> 00:28:25.340
nothing has changed.

00:28:25.390 --> 00:28:30.300
The ones with the images, well,
all we do is we just look at the data

00:28:30.960 --> 00:28:33.480
array and return the count of that.

00:28:34.420 --> 00:28:39.290
For now actually
displaying the information,

00:28:39.290 --> 00:28:45.050
what we do is,
if it's the main table view,

00:28:45.100 --> 00:28:48.690
nothing has changed,
same as in the previous step.

00:28:49.590 --> 00:28:59.160
For the image view, in case of the row,
we just return a number.

00:29:00.260 --> 00:29:02.890
We're going to start with the
string with the row number.

00:29:02.980 --> 00:29:06.980
Everything else,
we make it very easy because

00:29:07.500 --> 00:29:09.470
what we do is we use the

00:29:11.700 --> 00:29:17.800
[Transcript missing]

00:29:18.770 --> 00:29:21.940
I'm going to do an
ICA Copy Object Property Dictionary.

00:29:21.980 --> 00:29:25.700
And this here actually
shows us the data array.

00:29:25.700 --> 00:29:28.600
And, well, that's the date.

00:29:28.660 --> 00:29:32.100
This here is the file size.

00:29:32.330 --> 00:29:34.690
The ICAO is the ICA object.

00:29:34.780 --> 00:29:37.500
We have the name.

00:29:37.610 --> 00:29:43.040
So all we do is we set up in our
Nib file the identifier for each

00:29:43.040 --> 00:29:46.830
column to match one of these keys here.

00:29:47.140 --> 00:29:48.580
And we're done.

00:29:49.560 --> 00:29:52.560
So very easy.

00:29:52.580 --> 00:29:57.680
Now one thing I want to mention
is really when I was stressing it,

00:29:57.690 --> 00:30:01.140
you should use asynchronous calls.

00:30:01.810 --> 00:30:07.260
Another handy feature of the
ICA API tester is it actually will

00:30:07.260 --> 00:30:10.180
allow you to create code for you.

00:30:10.180 --> 00:30:13.040
So instead of the run mode,
you can go to the coding mode,

00:30:13.100 --> 00:30:17.460
and what you do is you
just select an API,

00:30:17.460 --> 00:30:22.480
like ICA Copy Object Property Dictionary,
and you can specify what flavor

00:30:22.580 --> 00:30:24.190
you want to generate the code in.

00:30:24.220 --> 00:30:30.390
So you can use the same code
to create code for your app,

00:30:30.890 --> 00:30:37.790
and you can also use the same
code to create code for your app.

00:30:37.920 --> 00:30:42.740
And control slash will actually
jump to the place where you

00:30:42.780 --> 00:30:44.080
have to do some modification.

00:30:44.080 --> 00:30:47.040
And actually,
that's very simple to update your code.

00:30:47.090 --> 00:30:51.080
And it's, yeah, we were using that to
create the different steps.

00:30:51.080 --> 00:30:53.920
And you will find it quite handy.

00:30:53.920 --> 00:30:58.030
Okay, back to the slides, please.

00:31:01.290 --> 00:31:06.690
So step three and four,
we were looking at the images,

00:31:06.760 --> 00:31:09.710
the number of images, the names.

00:31:09.950 --> 00:31:11.980
But now, actually,
it would be nice to do something that

00:31:12.070 --> 00:31:14.540
the Image Capture application does.

00:31:14.650 --> 00:31:18.150
We want to have more
information before downloading.

00:31:18.830 --> 00:31:23.880
So, for example, we want to get metadata.

00:31:24.490 --> 00:31:30.100
And the way to do it is use the same
ICA Copy Object Property Dictionary.

00:31:30.170 --> 00:31:33.930
In this case,
we're using it for an image object.

00:31:34.800 --> 00:31:39.770
So we already had from the
data array or tree dictionary,

00:31:39.800 --> 00:31:43.400
we had the name and size.

00:31:43.900 --> 00:31:48.040
Now we get the date and
additional EXIF information.

00:31:48.160 --> 00:31:52.370
So, for example, we get the color space,
we get the EXIF orientation,

00:31:52.370 --> 00:31:54.890
and for those who were
attending session 209,

00:31:54.890 --> 00:31:58.790
where David and Luke were
talking about ImageIO,

00:31:58.910 --> 00:32:02.930
yeah, you will see and you will find
it more important on Mac OS X to

00:32:02.970 --> 00:32:07.930
really honor the EXIF orientation,
and a lot of applications, Preview,

00:32:07.990 --> 00:32:11.740
Adobe Photoshop,
and other applications just honor that.

00:32:11.810 --> 00:32:15.260
So when opening an image
with an EXIF orientation,

00:32:15.260 --> 00:32:17.330
it will display correctly.

00:32:20.370 --> 00:32:21.460
Getting to the thumbnails.

00:32:21.570 --> 00:32:24.490
Image thumbnails, well, same thing.

00:32:24.500 --> 00:32:30.610
We have the ICA object,
ICA copy object thumbnail API.

00:32:30.610 --> 00:32:34.320
And you know already
from the device case,

00:32:34.480 --> 00:32:40.580
it returns a thumbnail in either JPEG,
TIFF, or uncompressed RGB.

00:32:40.970 --> 00:32:45.650
So for the device thumbnail,
it was nice to use the TIFF variant

00:32:45.650 --> 00:32:47.690
to get the alpha channel.

00:32:47.820 --> 00:32:52.550
You'll see that for images,
it is actually nice to use

00:32:52.550 --> 00:32:53.940
JPEG for a couple of reasons.

00:32:54.170 --> 00:32:56.600
First of all, it's smaller.

00:32:56.670 --> 00:33:01.050
It's the smallest of the three,
size-wise.

00:33:01.220 --> 00:33:06.160
But JPEG and TIFF actually
allow you to get thumbnails of

00:33:06.160 --> 00:33:10.790
the images up to 160 pixels,
where ICA Thumbnail has

00:33:10.790 --> 00:33:12.740
the limitation of 128.

00:33:12.740 --> 00:33:15.410
So if you want to have like
little bit larger images,

00:33:15.410 --> 00:33:19.390
larger thumbnails in your application,
I would really strongly recommend

00:33:19.970 --> 00:33:22.940
to use either JPEG or TIFF,
and in the image case,

00:33:23.020 --> 00:33:25.610
really use JPEG variant.

00:33:26.540 --> 00:33:33.980
So back to the demo machine where we are
going to enhance our small application.

00:33:38.160 --> 00:33:46.020
And in step five,
we want to get-- let me run it

00:33:46.020 --> 00:33:49.040
first and see what's going on.

00:33:50.550 --> 00:33:57.740
We want to get image thumbnails
and more image metadata.

00:33:57.830 --> 00:34:00.540
So just selecting that looks the same.

00:34:00.590 --> 00:34:02.270
Double clicking.

00:34:02.950 --> 00:34:08.870
You see, we first get all the thumbnails
and then additional information.

00:34:08.980 --> 00:34:14.300
So for example, we get the size,
the color space, one means it's sRGB,

00:34:14.340 --> 00:34:17.540
whether you get information
whether the flash was on or not.

00:34:17.790 --> 00:34:19.680
If you look at the EXIF spec,
you will get actually

00:34:19.690 --> 00:34:20.540
detailed information.

00:34:20.540 --> 00:34:24.840
So 31 is not only saying it was on,
but also what mode the flash was,

00:34:24.870 --> 00:34:27.660
was it red eye reduction or whatever.

00:34:28.200 --> 00:34:30.100
You get information
about the exposure time,

00:34:30.120 --> 00:34:33.530
the F number, model, and much more.

00:34:34.960 --> 00:34:42.700
And then again, you can select one or
multiple and then we would,

00:34:42.700 --> 00:34:42.700
in the, um,

00:34:42.830 --> 00:34:48.800
Application just updates the
number of selections and we are

00:34:48.800 --> 00:34:51.590
more or less ready to download.

00:34:52.140 --> 00:34:57.740
So before I go into the
code changes for step five,

00:34:57.740 --> 00:35:08.540
let me just quickly show you
if we run this in our test app,

00:35:08.540 --> 00:35:08.540
just pick whatever

00:35:08.880 --> 00:35:13.080
I say object and let's do an
ICA Copy Property Dictionary.

00:35:13.080 --> 00:35:14.930
It returns this array.

00:35:14.930 --> 00:35:20.040
So for example, you get the maker node
and model information.

00:35:20.220 --> 00:35:23.160
You'll get creation date and time.

00:35:23.160 --> 00:35:28.000
All these numbers up front,
check out the EXIF spec.

00:35:28.000 --> 00:35:32.030
These are basically the numbers
that are defined in the EXIF spec.

00:35:33.640 --> 00:35:36.490
Let's quickly look at the
ICA copy object thumbnail.

00:35:36.560 --> 00:35:42.380
So if I take the same ICA object,
I can get the thumbnail for

00:35:42.380 --> 00:35:44.700
this in different variants.

00:35:44.720 --> 00:35:54.200
So this, for example, is the raw format,
128 by 96 pixels width and height.

00:35:54.400 --> 00:35:57.700
And the data size, it's uncompressed,
it's like 49K.

00:35:57.700 --> 00:36:00.690
If I get the same thing as a JPEG,

00:36:01.360 --> 00:36:06.020
Then, you see it's 160 by 120,
but we are only using 11K.

00:36:06.220 --> 00:36:09.830
So it's larger, but uses less space.

00:36:13.350 --> 00:36:17.060
So back to our My Photo app.

00:36:17.060 --> 00:36:22.510
And what we do in--

00:36:24.500 --> 00:36:33.100
[Transcript missing]

00:36:33.410 --> 00:36:38.990
Metadata we do is,
whenever we were selecting,

00:36:39.480 --> 00:36:44.700
By double-clicking,
executing the browse device method,

00:36:44.740 --> 00:36:50.270
whenever we were selecting a camera,
we start fetching image thumbnails.

00:36:50.440 --> 00:36:55.390
Now fetching image thumbnails,
all I'm doing is

00:36:55.900 --> 00:37:01.040
I look at an array that
has the current thumbnails.

00:37:02.120 --> 00:37:06.420
That's the thumbnail count up to date.

00:37:06.510 --> 00:37:11.600
And the image array is just the data
array out of the device dictionary,

00:37:11.600 --> 00:37:15.670
which, as I said before,
has the total number of

00:37:15.730 --> 00:37:18.630
images for that device.

00:37:19.990 --> 00:37:25.680
So if our thumbnail count,
thumbnails that we already got,

00:37:26.040 --> 00:37:30.390
that's less than the image array count,
which simply means we have

00:37:30.390 --> 00:37:32.500
to get more thumbnails.

00:37:33.460 --> 00:37:35.800
Then we ask for the next thumbnail.

00:37:35.920 --> 00:37:39.890
In this case, we ask for JPEG format.

00:37:40.280 --> 00:37:45.310
We put in the correct ICA object.

00:37:45.840 --> 00:37:52.160
Out of the image dictionary,
which is at this thumbnail count index,

00:37:52.180 --> 00:37:59.040
execute the copy object
thumbnail call and

00:37:59.690 --> 00:38:03.250
On the callback,
we just dispatch back to fetch

00:38:04.020 --> 00:38:07.560
image thumbnail callback.

00:38:07.580 --> 00:38:10.320
In case we run into an error,
it should not happen,

00:38:10.320 --> 00:38:15.480
but for whatever reason,
Image Capture may not create a

00:38:15.480 --> 00:38:17.900
thumbnail for a corrupted file or so.

00:38:17.940 --> 00:38:26.940
What we want to do is we just use
the NS Workspace icon for file type,

00:38:26.940 --> 00:38:29.560
where we specify JPEG as file type.

00:38:29.610 --> 00:38:34.040
Just give me a generic icon,
and we would add that

00:38:34.040 --> 00:38:36.330
to our thumbnail array.

00:38:36.760 --> 00:38:41.310
In case everything was
working without problems,

00:38:41.310 --> 00:38:45.270
then we get the thumbnail data.

00:38:46.780 --> 00:38:49.600
And out of the thumbnail data,
we create an NS image.

00:38:49.630 --> 00:38:52.900
We add that to our array.

00:38:53.100 --> 00:38:59.300
[Transcript missing]

00:39:00.030 --> 00:39:01.600
After that, we start.

00:39:01.620 --> 00:39:05.140
We just call fetch
image thumbnails again.

00:39:05.730 --> 00:39:10.660
Which would, in case we are not done,
so image thumbnail count is still

00:39:10.660 --> 00:39:13.960
less than the number of thumbnails,
we would start over again,

00:39:13.960 --> 00:39:19.610
get the thumbnail for the next IC object.

00:39:20.010 --> 00:39:25.680
But eventually that will be done,
which simply means the

00:39:25.680 --> 00:39:30.370
thumbnail count will become
equal to the image rate count.

00:39:30.620 --> 00:39:35.370
In that case,
we start looking for metadata.

00:39:35.500 --> 00:39:38.010
So fetching metadata.

00:39:38.950 --> 00:39:44.430
At this point, simply,
that's the same thing now instead

00:39:44.430 --> 00:39:48.380
of doing it for thumbnails,
we do it for metadata.

00:39:48.570 --> 00:39:52.480
So we have the metadata
count of this array.

00:39:52.850 --> 00:39:58.380
If this is less than the image count,
use the same array to compare against.

00:39:58.420 --> 00:40:01.430
And then instead of
getting the thumbnail,

00:40:01.520 --> 00:40:03.790
we get the property dictionary.

00:40:05.660 --> 00:40:09.960
With this callback, again,
dispatches to us.

00:40:10.000 --> 00:40:12.280
It's straightforward, more or less.

00:40:12.280 --> 00:40:15.920
You did it once,
and you can do it very easily

00:40:15.920 --> 00:40:17.550
for the next properties to get.

00:40:20.930 --> 00:40:27.640
So, in case there was an error, again,
should not happen, we just put in or add

00:40:27.640 --> 00:40:30.060
an empty dictionary.

00:40:30.060 --> 00:40:35.610
Otherwise, we add the metadata.

00:40:36.300 --> 00:40:42.340
That we get back from this
ICA Copy Object Property Dictionary call.

00:40:42.390 --> 00:40:47.370
We again reload the table view
so it should now update the

00:40:48.250 --> 00:40:54.850
The metadata and ask
it to do the next one.

00:40:55.810 --> 00:40:59.400
Again, this here will eventually end,
so we will be done.

00:40:59.400 --> 00:41:02.840
And whenever we are done, we're done.

00:41:02.840 --> 00:41:04.900
I mean, there's nothing else to do.

00:41:05.040 --> 00:41:07.000
So let me run it again.

00:41:07.080 --> 00:41:08.560
Just...

00:41:08.950 --> 00:41:12.500
This double click and you see
there's really no need to do

00:41:12.550 --> 00:41:14.400
any threading or whatever.

00:41:14.400 --> 00:41:18.770
Just the fact that we do asynchronous
calls while it's getting these.

00:41:18.780 --> 00:41:21.930
So if this camera would have
like hundreds of images,

00:41:22.050 --> 00:41:24.110
it would still be able to interact.

00:41:24.230 --> 00:41:27.160
We could resize the window,
we could do whatever we want,

00:41:27.170 --> 00:41:29.850
and everything would just work.

00:41:32.510 --> 00:41:36.060
Okay,
so at this point we are almost there,

00:41:36.360 --> 00:41:38.150
almost ready to download the images.

00:41:38.180 --> 00:41:40.590
If you go back to the slides, please.

00:41:41.660 --> 00:41:47.610
The next thing would just be the way,
how do we really download the images?

00:41:49.250 --> 00:41:54.120
There's an API called ICEDownloadFile
that does not only download images,

00:41:54.220 --> 00:41:56.880
but any other files as well.

00:41:57.090 --> 00:42:01.670
So everything that is represented
by an IC object can be downloaded.

00:42:01.910 --> 00:42:05.530
All you have to do is you
specify a download folder,

00:42:05.590 --> 00:42:07.870
you specify a couple of flags.

00:42:07.990 --> 00:42:12.290
For example, you can, for images,
create custom icons,

00:42:12.290 --> 00:42:16.640
ICNS resources that we would
add to that image file.

00:42:17.130 --> 00:42:23.970
It could be handy if you really need the
images like in column view or whatever,

00:42:25.160 --> 00:42:30.850
or list view in Finder
to display these files.

00:42:31.030 --> 00:42:33.750
You can specify to rotate,
and David was mentioning

00:42:33.750 --> 00:42:38.020
that in session 209,
that with Tiger, beginning with Tiger,

00:42:38.020 --> 00:42:43.120
Image Capture is no longer manipulating
the pixels when doing the rotate.

00:42:43.160 --> 00:42:47.440
So all we do is we update
the EXIF orientation tag.

00:42:47.440 --> 00:42:51.000
So we are not touching and
we are not decompressing,

00:42:51.000 --> 00:42:52.150
recompressing the images.

00:42:52.160 --> 00:42:54.720
Because that was a complaint
from a lot of customers saying,

00:42:54.720 --> 00:42:58.290
"Well, I rotate this image in
the Image Capture app,

00:42:58.290 --> 00:43:00.920
then downloaded it,
and then the size was different.

00:43:01.030 --> 00:43:02.990
Why is that?"

00:43:03.480 --> 00:43:06.840
All it was just because
we had to decompress,

00:43:06.840 --> 00:43:09.530
recompress the image to get it done.

00:43:09.640 --> 00:43:12.500
But now,
since more and more applications are

00:43:12.970 --> 00:43:18.820
really using the EXIF orientation tag,
that's really no longer needed.

00:43:20.820 --> 00:43:23.160
Other interesting options
are delete after download.

00:43:23.210 --> 00:43:26.830
So whenever you want to just get
in the images and want to free

00:43:26.840 --> 00:43:31.290
up the memory card on the camera,
you can very easily do that

00:43:31.290 --> 00:43:33.140
by just specifying that flag.

00:43:33.250 --> 00:43:38.500
And we will, only in the case that the
download was successfully done,

00:43:38.610 --> 00:43:41.620
we will delete the image.

00:43:41.870 --> 00:43:45.890
A very nice, convenient way is really
just the creation date.

00:43:45.960 --> 00:43:50.830
That simply means that we look at
the exit information inside the

00:43:50.850 --> 00:43:55.790
image and update the file creation
date on disk after downloading.

00:43:55.890 --> 00:43:58.720
So in Finder,
you could just do a list view,

00:43:58.770 --> 00:44:03.620
sort by date, and then you know exactly
when you took these images.

00:44:05.860 --> 00:44:10.820
"Mode devices that you can use by just
going into the Image Capture application

00:44:10.820 --> 00:44:13.530
and share your devices on one machine.

00:44:13.540 --> 00:44:15.560
Then you can go to another machine.

00:44:15.640 --> 00:44:19.030
And that should work
for cameras pretty well,

00:44:19.180 --> 00:44:25.770
even if the machine one is your Intel box
and the other one is the PowerPC variant.

00:44:25.800 --> 00:44:29.920
So that's something we
are taking care of."

00:44:31.180 --> 00:44:34.640
The download images also takes
care of color management.

00:44:34.770 --> 00:44:37.050
Color management in the sense,

00:44:37.200 --> 00:44:51.700
[Transcript missing]

00:44:52.100 --> 00:44:56.130
In order to find out
what profile that is,

00:44:56.240 --> 00:45:00.820
you just go to your utility folder,
application utility, ColorSync utility,

00:45:00.950 --> 00:45:06.360
launch that, and then in the device tab,
you will be able to select the camera

00:45:06.360 --> 00:45:09.210
or scanner that you have connected.

00:45:09.400 --> 00:45:14.700
And you can see what profile
was registered for that device.

00:45:14.800 --> 00:45:18.480
You can override that,
so if you want to use your own

00:45:18.790 --> 00:45:21.130
profile that you did create.

00:45:21.300 --> 00:45:23.420
Then we will use that.

00:45:23.470 --> 00:45:27.340
And we will have a special
handling for EXIF 2.2 files,

00:45:27.410 --> 00:45:31.250
where the file itself has
enough information to generate a

00:45:31.250 --> 00:45:34.380
ColorSync profile automatically.

00:45:35.700 --> 00:45:39.280
So let's go back to the demo machine
and then in step six we are now really

00:45:39.280 --> 00:45:43.080
adding the download functionality.

00:45:45.710 --> 00:45:48.250
And we want to do it
in two different ways.

00:45:48.330 --> 00:45:51.050
One is have a download all.

00:45:51.120 --> 00:45:53.020
So if you just--

00:45:53.280 --> 00:45:54.740
Let's run it.

00:45:54.740 --> 00:45:57.910
And you noticed I was adding
now already a little bit more

00:45:58.340 --> 00:46:01.360
towards the final My Photo.

00:46:01.380 --> 00:46:05.140
So you will have later on the
library or if you want you can do

00:46:05.140 --> 00:46:08.000
your own last role implementation.

00:46:08.020 --> 00:46:11.110
And so we have the camera.

00:46:11.600 --> 00:46:14.880
And on this mode,
we can just press the import

00:46:14.970 --> 00:46:20.200
to download all the files or,
as I said before, double-click,

00:46:20.240 --> 00:46:22.310
select an image,

00:46:22.710 --> 00:46:26.040
And you can import this one.

00:46:26.140 --> 00:46:28.990
And you see it actually did work.

00:46:29.830 --> 00:46:35.490
Or at least it brought up a progress bar,
and there was something going on.

00:46:35.860 --> 00:46:41.140
Now, it does not open the file
and nothing else yet.

00:46:41.590 --> 00:46:47.890
But if we go to our...

00:46:50.100 --> 00:47:05.800
[Transcript missing]

00:47:07.400 --> 00:47:11.000
Six images.

00:47:11.000 --> 00:47:14.700
And this time it takes a little
bit longer because previous time

00:47:14.700 --> 00:47:18.560
these images were already on disk
and Image Capture is smart enough,

00:47:18.560 --> 00:47:21.770
not double downloading image files,
just checks, oh,

00:47:21.770 --> 00:47:27.000
is there an image with the same name,
same exif creation date?

00:47:27.000 --> 00:47:29.840
If that's the case, then there's no need
to download it again,

00:47:29.840 --> 00:47:32.110
and it just skips those.

00:47:32.260 --> 00:47:38.510
But now we see the six images
that were selected are downloaded

00:47:38.510 --> 00:47:40.750
and are on our hard drive.

00:47:40.820 --> 00:47:45.180
Okay, so what do we have to do?

00:47:45.210 --> 00:47:48.100
Well, for the import all case,

00:47:52.850 --> 00:48:00.130
What we do is we look
again at our data array,

00:48:00.130 --> 00:48:02.920
and then we put everything

00:48:05.020 --> 00:48:14.160
In a special mutable set,
mutable index set, all the indices that

00:48:14.220 --> 00:48:16.160
we are going to import.

00:48:16.170 --> 00:48:21.060
Well, in this case,
it's basically all indices in

00:48:21.060 --> 00:48:24.070
the range zero up to the count.

00:48:25.870 --> 00:48:31.880
And we will update some
progress information.

00:48:31.880 --> 00:48:34.920
For example,
you saw that we are displaying

00:48:34.920 --> 00:48:38.350
a text while downloading,
and we have a progress

00:48:38.480 --> 00:48:40.960
indicator while downloading.

00:48:41.040 --> 00:48:42.460
So we set this up.

00:48:42.600 --> 00:48:45.950
And then we just call import images.

00:48:46.370 --> 00:48:49.890
Now this is very similar
to the import selected,

00:48:49.890 --> 00:48:56.410
except the way to get to
the indices is different.

00:48:57.130 --> 00:49:00.340
In this case,
all we do is we ask the table view,

00:49:00.370 --> 00:49:07.080
give me an NS index set of selected rows.

00:49:08.820 --> 00:49:13.570
And we use that,
store that in our data member,

00:49:13.670 --> 00:49:19.690
set up the progress handling,
and call in to import images.

00:49:19.720 --> 00:49:23.280
In import images, all we do is, well,
we have the index set.

00:49:23.420 --> 00:49:25.100
This is basically a mutable set.

00:49:25.220 --> 00:49:31.850
It has all the indices of
the outstanding downloads.

00:49:32.970 --> 00:49:36.770
Simply meaning,
if the count of that one is zero,

00:49:36.780 --> 00:49:37.300
then we are done.

00:49:37.300 --> 00:49:39.490
We have everything downloaded.

00:49:39.930 --> 00:49:43.680
Simply meaning,
if the count of that one is zero,

00:49:43.680 --> 00:49:44.200
then we are done.

00:49:44.200 --> 00:49:46.400
We have everything downloaded.

00:49:53.680 --> 00:49:57.480
Simply meaning,
if the count of that one is zero,

00:49:57.480 --> 00:49:58.000
then we are done.

00:49:58.000 --> 00:50:00.200
We have everything downloaded.

00:50:04.910 --> 00:50:12.030
Which points to our
tilde/pictures/myphoto.

00:50:13.600 --> 00:50:21.700
[Transcript missing]

00:50:23.600 --> 00:50:32.130
We specify the IC object
and we specify our options.

00:50:32.330 --> 00:50:34.950
In this case,
the only options that we have are

00:50:34.950 --> 00:50:37.300
really the Create Custom Icon.

00:50:37.330 --> 00:50:42.920
So in Finder,
we will see the custom icon.

00:50:43.850 --> 00:50:47.830
And we really want to
adjust the creation date.

00:50:47.900 --> 00:50:53.200
So in Finder, you would see that I took
these images yesterday.

00:50:55.750 --> 00:51:04.950
And then we call ICA download file,
specify a callback proc.

00:51:05.380 --> 00:51:09.240
Callback proc, same thing as before for
all asynchronous calls.

00:51:09.240 --> 00:51:14.360
We just patch back to the ICA handler.

00:51:14.420 --> 00:51:19.400
And in this case, all we do is, like,
the file was downloaded.

00:51:19.900 --> 00:51:26.360
And what we want to do is update the UI.

00:51:26.850 --> 00:51:32.920
We, uh, the progress indicator,
just increment that by one,

00:51:32.920 --> 00:51:39.170
and the string value,
we just want to display the

00:51:39.170 --> 00:51:39.170
number of images remaining.

00:51:39.700 --> 00:51:44.540
And call the next import images.

00:51:44.590 --> 00:51:46.610
Remember that was...

00:51:48.920 --> 00:51:53.000
This is done until the
count gets down to zero.

00:51:53.150 --> 00:51:57.780
In this case,
we are going to hide the progress

00:51:57.850 --> 00:52:01.340
indicator and also the progress text.

00:52:02.730 --> 00:52:10.170
Okay, so up until this point,
we are able to display connected devices.

00:52:10.290 --> 00:52:14.800
We are able to display the
images on those devices.

00:52:14.940 --> 00:52:18.270
User can select what files to download.

00:52:18.520 --> 00:52:21.370
User can actually download the files.

00:52:21.700 --> 00:52:24.420
Now, if you go back to the slides,

00:52:25.790 --> 00:52:30.200
Next thing that would be kind of nice
is really controlling the device.

00:52:30.270 --> 00:52:34.490
So for example, how do you tell the
device to take a picture?

00:52:34.680 --> 00:52:40.200
Well, there's an
ICA Object Send Message API that

00:52:40.200 --> 00:52:42.310
allows you to do various things.

00:52:42.460 --> 00:52:47.300
For example, it allows you,
if the device supports it,

00:52:47.520 --> 00:52:54.300
to send an ICA message, "Camera,
capture new image" message.

00:52:54.690 --> 00:52:58.690
The interesting thing about this
way of talking to the device is

00:52:58.780 --> 00:53:02.940
really the IC object send message
call will return immediately.

00:53:03.100 --> 00:53:08.510
So it will not wait until the
camera has the image and is

00:53:08.580 --> 00:53:13.740
done processing the image,
saved it on the internal memory card.

00:53:13.860 --> 00:53:16.260
It will return immediately.

00:53:16.320 --> 00:53:20.260
And you will get a notification
whenever that's done.

00:53:23.800 --> 00:53:30.900
[Transcript missing]

00:53:31.410 --> 00:53:36.060
For example,
a lot of vendors are going to the

00:53:36.150 --> 00:53:45.790
PDP over IP protocol to have kind
of airport wireless 8211-based

00:53:45.790 --> 00:53:53.150
devices where you can go around,
pair that with your computer, go around,

00:53:53.250 --> 00:53:58.680
take pictures, and the computer will
actually get notified,

00:53:58.770 --> 00:54:00.930
oh, there's a new picture.

00:54:01.190 --> 00:54:06.380
So all you have to do in order to
work with this model is you have

00:54:06.380 --> 00:54:08.420
to register for event notification.

00:54:08.460 --> 00:54:13.640
So you have to be prepared that
there's an ICA object added

00:54:13.640 --> 00:54:16.770
message sent to your application.

00:54:17.110 --> 00:54:19.300
And you can update the UI.

00:54:19.300 --> 00:54:23.400
You can add an extra entry.

00:54:23.530 --> 00:54:28.900
And now, step seven,
we will enhance the application.

00:54:30.650 --> 00:54:33.840
And I'll show you how to do that.

00:54:33.860 --> 00:54:37.890
So let's run it first.

00:54:44.310 --> 00:54:47.200
And it should look like
exactly the same way as before.

00:54:47.200 --> 00:54:53.730
But notice that when I select the camera,
there's a new "Take Picture" button.

00:54:54.750 --> 00:55:00.010
The "Take Picture" button
just brings up a new window.

00:55:00.300 --> 00:55:05.070
And it actually allows you to,
and I can show you how

00:55:05.360 --> 00:55:07.320
the setup looks up here.

00:55:07.320 --> 00:55:11.800
So I can go to this button
here and say take picture.

00:55:11.800 --> 00:55:15.810
That's not bright enough, it is.

00:55:24.200 --> 00:55:28.340
Can you actually bring up
the light a little bit?

00:55:28.340 --> 00:55:29.200
Yep.

00:55:29.200 --> 00:55:33.160
I think it doesn't want to.

00:55:36.200 --> 00:55:59.600
[Transcript missing]

00:56:01.690 --> 00:56:09.200
Take a picture and it
actually updates the screen.

00:56:09.200 --> 00:56:13.950
And now just imagine you do
that with your wireless camera.

00:56:14.410 --> 00:56:21.010
You have a 30-inch display,
or maybe a set of 30-inch displays,

00:56:21.010 --> 00:56:23.030
and then just walk around, take pictures.

00:56:23.050 --> 00:56:31.060
That would be a really nice way to
entertain people at a party or so.

00:56:33.450 --> 00:56:35.040
Okay.

00:56:35.130 --> 00:56:36.370
Now, interesting thing.

00:56:36.580 --> 00:56:40.500
See, I turn off the camera,
and this window goes away.

00:56:41.750 --> 00:56:47.350
And so what did we do in
order to get that to work?

00:56:48.830 --> 00:56:53.920
First of all,
when getting the device dictionary,

00:56:53.920 --> 00:56:57.330
we have to check the capability array.

00:56:58.090 --> 00:57:01.500
Basically find out what
does this camera support.

00:57:01.640 --> 00:57:03.950
Does it support take picture?

00:57:04.180 --> 00:57:09.080
And this capability array is
just encoded the OS types,

00:57:09.090 --> 00:57:13.840
in this case the KICA message
camera capture new image.

00:57:13.840 --> 00:57:21.570
If that's part of that array, then we...

00:57:22.970 --> 00:57:29.230
"We unhide the take picture button,
so we show it and the user can select it.

00:57:29.430 --> 00:57:35.620
Now if the user selects it,
then all we do is we use a new class,

00:57:35.620 --> 00:57:40.110
we have a new ICA take picture handler.

00:57:41.020 --> 00:57:44.860
We're asked to show the UI.

00:57:44.970 --> 00:57:48.520
Show the UI is kind of
straightforward because we get

00:57:48.650 --> 00:57:51.770
passed in an ICA device object.

00:57:52.800 --> 00:57:58.520
We load the new bundle,
that's the window that

00:57:58.520 --> 00:57:58.520
we are going to display.

00:57:59.380 --> 00:58:01.800
Keep reference to the device object.

00:58:01.810 --> 00:58:05.250
Go with that window to
kind of full screen.

00:58:05.670 --> 00:58:09.330
So we get the main
screen's visible frame,

00:58:09.540 --> 00:58:15.090
set the Windows frame to that,
and make it key and order front.

00:58:15.510 --> 00:58:22.150
Then, next thing is really we
register for event notification.

00:58:24.840 --> 00:58:32.430
And whenever the user presses
now the "Take Picture" button,

00:58:32.440 --> 00:58:37.320
we send off a message
to this device object,

00:58:37.440 --> 00:58:42.230
"I see message camera capture new image."

00:58:42.950 --> 00:58:46.280
And as callback,
we actually ignore it because

00:58:46.380 --> 00:58:50.060
there's nothing useful that
comes back from that API.

00:58:50.510 --> 00:58:55.720
I told you that IC object send message
returns immediately and the image

00:58:55.900 --> 00:58:58.940
is still not captured at that point.

00:59:00.400 --> 00:59:07.300
[Transcript missing]

00:59:07.880 --> 00:59:12.980
We look at the event type
of event object added.

00:59:13.680 --> 00:59:17.190
We get notified when the image was saved.

00:59:17.300 --> 00:59:19.800
In this case, we just download.

00:59:19.960 --> 00:59:27.100
But notice also here that in
case of the event device removed,

00:59:27.110 --> 00:59:29.180
we actually want to close the
window because it makes no sense

00:59:29.180 --> 00:59:32.700
to keep that window up when
there's no device connected.

00:59:32.750 --> 00:59:35.700
So let's look at the download object.

00:59:36.130 --> 00:59:40.500
Very similar to what we had before,
except in this case we just

00:59:40.610 --> 00:59:43.030
download to the temp folder.

00:59:43.280 --> 00:59:45.700
And since we do not want
to fill up in this mode,

00:59:45.780 --> 00:59:48.070
we do not want to fill
up the memory card,

00:59:48.410 --> 00:59:53.310
what we do is just specify
the lead after download.

00:59:54.650 --> 01:00:00.990
Once the image was downloaded, again,
the small wrapper, the...

01:00:02.150 --> 01:00:04.140
Callback.

01:00:04.190 --> 01:00:07.660
Once the image was downloaded,
what we do is we create a

01:00:07.660 --> 01:00:15.980
reference to the downloaded file,
FS-Spec, make a path out of it.

01:00:16.200 --> 01:00:19.750
And create an NS image,
initialize that with

01:00:19.920 --> 01:00:21.410
the contents of file.

01:00:21.780 --> 01:00:27.480
And all we do is we have an image view
in that window and set the image and

01:00:27.500 --> 01:00:29.940
we release the image and we're done.

01:00:31.410 --> 01:00:34.900
Okay, so we can handle take picture.

01:00:34.900 --> 01:00:37.410
Go back to the slides, please.

01:00:39.110 --> 01:00:42.800
What do we have to do
to work with RAW files?

01:00:42.890 --> 01:00:46.340
Now, more and more camera
vendors are using RAW files,

01:00:46.340 --> 01:00:48.980
and a lot of users are going
to use RAW files because

01:00:49.290 --> 01:00:52.560
quality seems to be better.

01:00:53.490 --> 01:00:55.440
So how do we handle these?

01:00:55.470 --> 01:00:59.090
Well, the good news is we don't care
about that because there's a new

01:00:59.120 --> 01:01:04.970
ImageIO framework that ships with Tiger,
and that takes care of a lot of things.

01:01:05.110 --> 01:01:09.990
For example,
with applications like Image Capture,

01:01:10.120 --> 01:01:18.870
Preview, Safari or so, they are able to,
by just using ImageIO framework, they are

01:01:19.390 --> 01:01:23.150
Automatically supporting file formats,
image file formats like TIFF, JPEG,

01:01:23.210 --> 01:01:28.060
and all these, but also camera RAW files.

01:01:28.400 --> 01:01:32.140
Automatically supporting file formats,
image file formats like TIFF, JPEG,

01:01:32.140 --> 01:01:35.530
and all these, but also camera RAW files.

01:01:36.220 --> 01:01:43.410
We just use ImageIO to
create CG image refs for us,

01:01:43.410 --> 01:01:47.170
and we just display those.

01:01:47.610 --> 01:01:52.290
ImageIO does not only deal
with the actual image data,

01:01:52.290 --> 01:01:54.920
but also supports metadata.

01:01:55.460 --> 01:02:00.260
So all kind of metadata
variants are supported.

01:02:00.260 --> 01:02:06.060
And the really cool thing about that
is it's the same set of APIs no matter

01:02:06.060 --> 01:02:08.450
what image file format you have.

01:02:09.500 --> 01:02:14.260
So all kind of metadata
variants are supported.

01:02:14.260 --> 01:02:20.060
And the really cool thing about that
is it's the same set of APIs no matter

01:02:20.060 --> 01:02:20.150
what image file format you have.

01:02:21.920 --> 01:02:26.390
Main things,
reading and writing in ImageIO.

01:02:26.580 --> 01:02:31.120
For both variants,
they have special objects

01:02:31.200 --> 01:02:33.800
like CG image source.

01:02:33.850 --> 01:02:41.150
The image source can be created by
passing in a URL or some data that

01:02:41.440 --> 01:02:44.490
you have or a CG data provider.

01:02:44.890 --> 01:02:47.810
And I just want to point out,
because in step eight,

01:02:47.810 --> 01:02:54.840
we are going to use ImageIO to display
images that we just downloaded.

01:02:55.000 --> 01:03:00.530
We mainly focus on the image source,
create image at index.

01:03:01.610 --> 01:03:06.340
Which just gives you,
for a given image source,

01:03:06.390 --> 01:03:09.110
a CG image ref pack.

01:03:10.170 --> 01:03:16.730
A very nice and powerful, as we will see,
API is the Create Thumbnail Ad Index.

01:03:17.390 --> 01:03:25.070
Because it allows you for all images,
even those that do not have

01:03:25.070 --> 01:03:25.070
originally embedded a thumbnail,
it allows you to create a thumbnail.

01:03:25.480 --> 01:03:27.930
And there are some nice
options that you can pass in.

01:03:28.040 --> 01:03:31.560
For example, you can specify,
create this thumbnail

01:03:31.700 --> 01:03:34.280
with this maximum size.

01:03:34.340 --> 01:03:39.960
And we'll see that we are using that
for thumbnails that are a little bit

01:03:39.980 --> 01:03:46.240
larger than what you would expect,
larger than the 160 pixels or whatever.

01:03:46.290 --> 01:03:50.610
And the other nice thing really
is getting to all the metadata.

01:03:51.030 --> 01:03:53.570
On the writing side,
actually our step 8 is not

01:03:53.610 --> 01:03:56.870
going to support writing,
but after looking at the

01:03:56.870 --> 01:04:01.740
samples from session 209,
you will be very surprised

01:04:01.740 --> 01:04:07.130
how little code is needed and
you can very easily add that,

01:04:07.130 --> 01:04:14.530
integrate that into this app and you
have your full functional image browsing,

01:04:14.530 --> 01:04:18.400
editing, and exporting application.

01:04:18.400 --> 01:04:20.010
So let's go to step 8 and

01:04:20.580 --> 01:04:29.310
Let's see how ImageIO framework
can help us to display images that

01:04:29.310 --> 01:04:32.900
are inside our download folder.

01:04:33.010 --> 01:04:35.860
Well, first of all,
we have two new classes

01:04:35.860 --> 01:04:37.670
that we are going to use.

01:04:37.740 --> 01:04:43.790
One is a file browser view,
and the other one is an image view.

01:04:44.830 --> 01:04:48.420
For the file browser view,
what we do is whenever there's

01:04:48.420 --> 01:04:52.240
a table view selection that
changes in our main table.

01:04:52.350 --> 01:04:56.940
So remember, that was the table where
we have the camera and then

01:04:56.950 --> 01:04:59.160
the last role and library.

01:05:00.120 --> 01:05:03.230
So whenever we are not
selecting a device,

01:05:03.230 --> 01:05:05.820
then we switch our main tab.

01:05:06.200 --> 01:05:20.800
[Transcript missing]

01:05:21.790 --> 01:05:28.230
So the File Browser view, when created,
actually just has in images just

01:05:28.230 --> 01:05:35.320
a mutable dictionary that's empty
and gets filled in update files.

01:05:35.730 --> 01:05:40.710
The folder we are
interested in is "My Photo".

01:05:41.220 --> 01:05:46.340
We ask the file manager for
the contents at this path.

01:05:46.540 --> 01:05:55.690
In this array, we get a list of all the
files inside that path.

01:05:57.600 --> 01:06:04.620
The images that we already
have imported are in M-images.

01:06:04.650 --> 01:06:09.500
So we get all keys and create a
mutable set with all the keys,

01:06:09.550 --> 01:06:12.700
with all the file names
that we already have.

01:06:13.030 --> 01:06:14.700
And now we just do two things.

01:06:14.770 --> 01:06:19.080
We remove the images that
are no longer on disk,

01:06:19.080 --> 01:06:23.500
because the user may have
in Finder removed something.

01:06:23.640 --> 01:06:28.280
And we're going to add
images that are on disk,

01:06:28.280 --> 01:06:34.780
but not in our internal data structure,
in our My Images.

01:06:36.560 --> 01:06:46.320
After that, the only thing we do is,
doing it really lazily, in DrawRect,

01:06:46.320 --> 01:06:49.500
we blindly draw all thumbnails.

01:06:49.590 --> 01:06:53.230
Now, really, you have to know this is not
like shipping code because

01:06:53.690 --> 01:06:54.970
this could really be optimized.

01:06:55.030 --> 01:06:57.380
What we do is, like,
we iterate over all the images

01:06:57.400 --> 01:07:02.350
and we are not taking care of,
for example, is this thumbnail visible?

01:07:02.700 --> 01:07:04.860
So we are drawing always
all the thumbnails.

01:07:05.060 --> 01:07:11.380
You, in your shipping application,
hopefully will test the rect

01:07:11.700 --> 01:07:16.050
that will get passed in to the
draw rect and draw only those

01:07:16.150 --> 01:07:18.980
thumbnails that are inside that one.

01:07:21.000 --> 01:07:30.640
So, in case we look at the M-Images
object for that current name,

01:07:30.730 --> 01:07:33.030
if our dictionary

01:07:33.970 --> 01:07:38.660
The M-Images dictionary
has already an entry.

01:07:38.700 --> 01:07:39.740
And we are fine.

01:07:39.790 --> 01:07:44.170
But we start off, as we said,
we do a lazy initialization.

01:07:44.490 --> 01:07:48.280
We start off with no entries,
no information about a given file.

01:07:48.280 --> 01:07:51.740
So what we want to do is we
want to get information and

01:07:51.780 --> 01:07:54.050
get the thumbnail for a file.

01:07:54.080 --> 01:07:56.360
And we use ImageIO to do that.

01:07:56.960 --> 01:08:05.190
So what we basically do is we get a URL,
create an image source with that URL,

01:08:06.170 --> 01:08:11.360
And now we use the
Create CG Image Source Create Thumbnail

01:08:11.360 --> 01:08:12.390
at Index.

01:08:12.390 --> 01:08:14.720
Note that we specify a couple of things.

01:08:14.820 --> 01:08:19.850
For example,
we specify the maximum pixel size.

01:08:20.060 --> 01:08:22.760
"Which is just defined
that we have somewhere,

01:08:22.760 --> 01:08:25.160
and in our case I guess it's 600 or so.

01:08:25.380 --> 01:08:27.290
So, a fairly large one."

01:08:28.130 --> 01:08:33.880
Then, this one here is very interesting
because it helps you to just

01:08:34.140 --> 01:08:35.800
draw a thumbnail without

01:08:36.120 --> 01:08:42.750
A need to look at the
EXIF orientation tag.

01:08:42.750 --> 01:08:42.750
So for thumbnails, you get that for free.

01:08:43.470 --> 01:08:45.100
You will get the thumbnail.

01:08:45.150 --> 01:08:50.750
The image will be rotated in a
way so that it looks correct.

01:08:51.320 --> 01:08:53.700
And in our case,
we always want to create it,

01:08:53.780 --> 01:08:58.540
even though the image itself
may have an embedded thumbnail,

01:08:58.540 --> 01:09:03.800
we always want to create it because
our max pixel size is very large.

01:09:05.470 --> 01:09:13.370
Now, when we have that,
on the drawing side, well, all we do is,

01:09:13.370 --> 01:09:14.990
like, we get the icon,

01:09:15.200 --> 01:09:17.630
Get the thumbnail.

01:09:17.770 --> 01:09:24.330
Since we have our browsing view flipped,
we just have to set up the

01:09:24.330 --> 01:09:25.960
CTM to take care of that.

01:09:25.980 --> 01:09:31.990
So we flip and offset
that and draw the image.

01:09:33.020 --> 01:09:38.730
One nice thing we can easily do
is actually we can allow the user

01:09:38.740 --> 01:09:41.260
to change the thumbnail size.

01:09:41.360 --> 01:09:43.580
So if I run this,

01:09:46.040 --> 01:09:48.810
I see, oh, these are the images that we
have in our download folder,

01:09:48.810 --> 01:09:52.700
and yes, we are able to resize.

01:09:52.710 --> 01:09:57.650
And it's speed-wise okay,
but it could be faster

01:09:57.720 --> 01:09:59.540
when just taking care of.

01:09:59.600 --> 01:10:05.130
I mean, there's really no need to display
more than one thumbnail in this case,

01:10:05.140 --> 01:10:08.180
if I have enlarged it,
something like that.

01:10:08.270 --> 01:10:13.560
But you will also see that the thumbnail,
this, the first one here,

01:10:13.560 --> 01:10:15.200
is auto-rotated.

01:10:15.320 --> 01:10:19.440
So, without doing anything,
just specifying that option,

01:10:19.640 --> 01:10:23.200
everything is handled correctly.

01:10:23.340 --> 01:10:24.780
Now,

01:10:26.980 --> 01:10:31.650
On a double click, so mouse down,
double click,

01:10:31.670 --> 01:10:36.940
what I want to do is I want to find
out in a loop what thumbnail that was,

01:10:36.990 --> 01:10:41.550
and then ask the ICA handler,
show the image.

01:10:42.630 --> 01:10:45.210
So, show the image,
for the handler simply

01:10:45.210 --> 01:10:47.970
means go yet to another tab,

01:10:48.200 --> 01:10:54.740
"Hide the thumbnail slider and call
back into the file browser view,

01:10:54.870 --> 01:10:58.850
show image at index,
which just sets up a path,

01:10:59.000 --> 01:11:03.320
has an image view, and now we are back to
our original image view,

01:11:03.330 --> 01:11:11.040
sets the image path, and very simple,
use ImageIO,

01:11:11.040 --> 01:11:11.040
CG image source create with URL.

01:11:11.630 --> 01:11:18.630
We use a dictionary where we
specify "yes", do cache this image,

01:11:18.770 --> 01:11:20.800
and allow float.

01:11:21.060 --> 01:11:24.360
We create the CG image.

01:11:24.710 --> 01:11:30.100
We'll cover the fine details on
how to support digital cameras

01:11:30.100 --> 01:11:32.720
and scanner with ImageIO.

01:11:32.720 --> 01:11:32.720
Learn how to take your application to the
next level of performance and capability.

01:11:33.530 --> 01:11:36.940
So we create that, the properties.

01:11:36.970 --> 01:11:42.960
We just keep a reference to the image,
the metadata, and draw it.

01:11:43.000 --> 01:11:47.400
When drawing, all we do is we draw the
background with gray,

01:11:47.450 --> 01:11:50.010
and now draw the actual image.

01:11:51.260 --> 01:11:55.460
And actually,
this is the same code that you get

01:11:55.550 --> 01:11:59.540
from the Image app from session 2.9.

01:11:59.540 --> 01:12:02.540
So I will not talk much about this.

01:12:02.540 --> 01:12:07.720
The only change I made can be useful
in your app is if you want to have

01:12:07.720 --> 01:12:11.860
a little bit faster live resizing,
what you can do is actually

01:12:11.860 --> 01:12:15.850
you can take advantage of the
notifications that your view gets

01:12:15.850 --> 01:12:18.400
when the user starts live resizing.

01:12:18.400 --> 01:12:25.130
And there is a "will start live
resize" and "view did end live resize."

01:12:25.250 --> 01:12:31.340
We just keep a flag and at the end
of "did end" we just re-display.

01:12:31.400 --> 01:12:36.820
Now in our drawing code,
we just honor that flag.

01:12:36.890 --> 01:12:41.500
If we are in a live resizing mode,
then what we could do is set the

01:12:41.790 --> 01:12:45.810
interpolation quality to none,
which actually allows for a

01:12:45.810 --> 01:12:47.390
little bit faster drawing.

01:12:47.400 --> 01:12:48.500
Thank you.

01:12:48.790 --> 01:12:52.100
You will notice that, for example,
I double-click on this one,

01:12:52.100 --> 01:12:56.500
that while I'm doing this,
it's actually pretty snappy,

01:12:56.580 --> 01:13:00.260
but if I release it, then it's very fast,
it's a very small image,

01:13:00.310 --> 01:13:04.280
but whenever I release the mouse button,
done with the resizing,

01:13:04.280 --> 01:13:08.750
then you would see it redraws
with better interpolation quality.

01:13:08.760 --> 01:13:14.450
Okay, so I guess this is from zero
to my photo in eight steps,

01:13:14.860 --> 01:13:20.440
and let's quickly go back to the slides.

01:13:21.990 --> 01:13:23.650
We have some more samples for you.

01:13:23.750 --> 01:13:27.030
Actually,
the new Image Capture SDK will be

01:13:27.130 --> 01:13:28.730
posted either today or tomorrow.

01:13:28.930 --> 01:13:33.040
Hopefully,
really by the end of this week you

01:13:33.040 --> 01:13:38.170
will have the new SDK that has not
only the tools that I was showing,

01:13:38.340 --> 01:13:45.320
but also some interesting new samples,
for example the time lapse, which is...

01:13:45.730 --> 01:13:50.640
Just focusing on the same things we did,
but for cameras that allow,

01:13:50.640 --> 01:13:55.170
like PDP camera,
that allow to take pictures,

01:13:55.230 --> 01:14:00.080
what it really does,
it takes the picture, saves it off,

01:14:00.080 --> 01:14:02.900
and creates a quick time movie out of it.

01:14:02.900 --> 01:14:07.100
And if you have enough time,
I will quickly show you the movie

01:14:07.100 --> 01:14:10.900
that we did last year from WWC,
the event on campus.

01:14:10.900 --> 01:14:15.900
And the other new sample
code is the Copy Machine,

01:14:15.900 --> 01:14:17.290
which is a small scanning app.

01:14:17.400 --> 01:14:22.880
It can be used as a real copy machine
because it takes care of the button

01:14:22.880 --> 01:14:24.900
press that you have on your scanner.

01:14:24.900 --> 01:14:26.900
You can press a button on your scanner.

01:14:26.900 --> 01:14:29.970
This small application will get
launched if you specify it in

01:14:29.970 --> 01:14:30.900
the Image Capture application.

01:14:30.900 --> 01:14:34.270
Launch this app when
this button is pressed.

01:14:34.270 --> 01:14:38.800
And what it does,
it makes a full scan and prints it out.

01:14:38.900 --> 01:14:40.900
You have the sample code for that.

01:14:41.120 --> 01:14:45.840
And then the last thing I want to mention
is really Image Capture and Automata.

01:14:45.900 --> 01:14:47.400
They are two acts.

01:14:47.400 --> 01:14:48.950
And...

01:14:49.610 --> 01:14:51.500
It's very easy to do.

01:14:51.500 --> 01:14:55.190
So for more information,
I just have to refer

01:14:55.260 --> 01:14:58.500
to the developer page.

01:14:58.500 --> 01:15:02.570
Related sessions, well,
as I mentioned before, session 209.

01:15:02.600 --> 01:15:05.500
Unfortunately,
that was already just before this one.

01:15:05.500 --> 01:15:09.730
Then there's lab tomorrow
and on Friday the graphics

01:15:09.730 --> 01:15:12.200
and imaging feedback session.

01:15:12.500 --> 01:15:19.490
For any kind of questions,
go over to Travis.

01:15:19.490 --> 01:15:19.500
And I guess we go to Q&A and one more.
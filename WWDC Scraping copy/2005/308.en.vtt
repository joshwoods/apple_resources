WEBVTT

00:00:08.910 --> 00:00:11.680
Hello,
welcome to the FxPlug in Depth session.

00:00:11.680 --> 00:00:14.890
Sorry we started a little late,
but Pete's plane showed up about

00:00:14.970 --> 00:00:17.670
five minutes late on Tuesday,
so we've just been off

00:00:17.810 --> 00:00:19.800
a little bit since then.

00:00:19.940 --> 00:00:23.810
We're going to talk about some
advanced topics that we didn't get to

00:00:23.810 --> 00:00:27.100
cover on yesterday's FxPlug session,
the overview.

00:00:27.550 --> 00:00:31.330
and do some demos and talk
about OpenGL and so on.

00:00:31.550 --> 00:00:32.290
I'm Dave Howell again.

00:00:34.530 --> 00:00:38.250
In this session we will talk
about how you can do retiming,

00:00:38.250 --> 00:00:40.550
how you can,
when it's time to render a frame,

00:00:40.560 --> 00:00:45.490
you can get an input frame for a filter
that comes from a different time.

00:00:45.550 --> 00:00:50.500
So you can do a video reverb style effect
or motion blur or something like that.

00:00:50.550 --> 00:00:54.300
We will talk about the two
optional parameter types that

00:00:54.370 --> 00:00:58.820
some hosts might support,
the gradient and the histogram.

00:00:58.820 --> 00:01:02.980
And custom parameter types,
which we kind of briefly talked

00:01:02.980 --> 00:01:05.930
about in yesterday's session,
but we will talk more about how you can

00:01:05.990 --> 00:01:10.330
implement custom parameter type and what
the requirements and restrictions are.

00:01:10.640 --> 00:01:15.500
and custom parameter UI which is often
associated with a custom parameter type.

00:01:15.500 --> 00:01:22.140
We will also talk about how to do on
screen controls in OpenGL where you

00:01:22.170 --> 00:01:27.830
put your controls directly into the
canvas and let people manipulate the

00:01:27.940 --> 00:01:33.110
parameters of a filter by dragging
or drawing or that sort of thing,

00:01:33.110 --> 00:01:34.550
or key presses.

00:01:34.550 --> 00:01:41.280
And we will talk about some of the
details of using OpenGL in an FX plug.

00:01:43.000 --> 00:01:46.650
So when you do retiming,
this is only for filters,

00:01:46.820 --> 00:01:52.970
for generators you can get all
of your input parameters that

00:01:52.970 --> 00:01:54.600
you want at any time you want.

00:01:54.600 --> 00:01:58.140
You can find out what the value
say of a slider is at the current

00:01:58.140 --> 00:02:00.460
time or at some other frame time.

00:02:00.460 --> 00:02:04.530
But for filters, in order to get an input
frame at a different time,

00:02:04.530 --> 00:02:10.220
you need to use the FXTemporalImage API,
host API methods.

00:02:10.300 --> 00:02:39.700
[Transcript missing]

00:02:40.920 --> 00:02:43.900
and also you can get the input
as a bitmap or a texture.

00:02:43.900 --> 00:02:47.600
So in your hardware render method
normally you would get the texture

00:02:47.600 --> 00:02:50.780
and in your software method
you usually get the bitmap.

00:02:53.770 --> 00:02:59.290
So I'll just really quickly show you the,
those methods for getting the

00:02:59.480 --> 00:03:01.850
inputs at different times.

00:03:01.860 --> 00:03:04.770
There's one called getSourceBitmap.

00:03:05.500 --> 00:03:07.230
and get input bitmap.

00:03:07.510 --> 00:03:13.900
The source is the unfiltered and the
input one is the filtered version.

00:03:13.900 --> 00:03:19.600
The time value is a frame time,
but it's a floating point value,

00:03:19.600 --> 00:03:21.170
so you can give it a

00:03:22.650 --> 00:03:25.200
and the same thing,
there is a get source texture

00:03:25.640 --> 00:03:26.940
and a get input texture.

00:03:29.730 --> 00:03:33.110
and in each of these the render
information is passed in,

00:03:33.110 --> 00:03:37.350
in your render function you're given
a render info structure which you

00:03:37.390 --> 00:03:41.110
then can pass back into these methods.

00:03:42.110 --> 00:03:45.130
So to show you what kind of
things you can do with retiming,

00:03:45.130 --> 00:03:48.240
here is Pete Warden,
graphics coder extraordinaire

00:03:48.240 --> 00:03:49.000
from Motion Team.

00:03:49.000 --> 00:03:51.130
Hey, thanks Dave.

00:03:51.280 --> 00:03:54.000
Okay,
so I'm just going to give you a little

00:03:54.000 --> 00:03:58.000
demonstration of what we've actually been
talking about with all the code here.

00:03:58.000 --> 00:04:12.910
So if I actually bring up some footage
and just get this actually playing back.

00:04:16.260 --> 00:04:18.200
I will change the project length here.

00:04:18.500 --> 00:04:27.460
If I enable a filter that
lets me scrub in time,

00:04:29.120 --> 00:04:32.440
If I just stop the playback,
you can see that you can

00:04:32.440 --> 00:04:36.490
actually access the input,
which can be footage or which can be

00:04:36.500 --> 00:04:40.420
anything that has gone through the
motion render engine with any effects

00:04:40.560 --> 00:04:42.900
applied or anything else like that.

00:04:42.900 --> 00:04:48.500
You can just say, "Okay,
I want the footage at 10 frames a go,

00:04:48.500 --> 00:04:52.520
30 frames a go,
just purely random access."

00:04:54.300 --> 00:04:59.360
and you can see it's very useful.

00:04:59.360 --> 00:05:01.430
Back to slides.

00:05:04.000 --> 00:05:07.400
As I said,
there are two optional parameter types:

00:05:07.400 --> 00:05:10.070
histograms and gradients.

00:05:10.100 --> 00:05:12.330
And the reason they're
called optional is that while

00:05:12.340 --> 00:05:15.940
Motion does support both of those,
some other hypothetical host

00:05:15.940 --> 00:05:19.490
app in the ProApp Suite might
not support these types.

00:05:19.990 --> 00:05:22.590
So when the support
is added to Final Cut,

00:05:22.600 --> 00:05:25.720
we don't guarantee that
these will be there.

00:05:27.270 --> 00:05:31.280
and Dave Howell, Pete Warden.

00:05:31.300 --> 00:05:34.180
Just like the way that you
create regular parameters,

00:05:34.180 --> 00:05:37.540
the standard parameter types,
and you get their values

00:05:37.540 --> 00:05:41.220
and you set their values,
there are analogous

00:05:41.220 --> 00:05:49.400
host APIs for creating,
getting and setting values for

00:05:49.400 --> 00:05:49.400
the optional parameter types.

00:05:50.560 --> 00:05:56.370
So the histogram is used
in one Motion plugin,

00:05:56.370 --> 00:05:59.180
the Levels plugin.

00:05:59.180 --> 00:06:02.420
It may not be too useful for general use,
but it's there if you want

00:06:02.420 --> 00:06:03.810
to use it in your plugin.

00:06:03.820 --> 00:06:07.870
You can see that it has a very
simple interface that can be expanded

00:06:07.870 --> 00:06:13.470
and a user can go into quite a
bit of depth with the levels.

00:06:15.250 --> 00:06:23.840
So to create these you use the
API manager to get an object

00:06:24.320 --> 00:06:26.980
that's a member of a class that
implements the protocol called

00:06:26.980 --> 00:06:30.700
FxOptionalParameterCreationAPI.

00:06:30.700 --> 00:06:36.900
And that creator object then has
methods addHistogramWithName and another

00:06:36.900 --> 00:06:41.200
one for making a gradient parameter.

00:06:41.210 --> 00:06:44.180
You can see in this example,
most of the examples I've given have just

00:06:44.180 --> 00:06:47.590
had the default flag for the parm flag,
so I've set some flags in here just

00:06:47.610 --> 00:06:52.200
to give you a flavor for what kind of
things there are in the parameter flags.

00:06:52.200 --> 00:06:55.600
And the levels, you probably actually
would want to save this,

00:06:55.600 --> 00:06:59.030
but if you're using the histogram
just for displaying levels and

00:06:59.030 --> 00:07:03.070
not really interacting with them,
you might not want to save the values.

00:07:03.800 --> 00:07:15.800
[Transcript missing]

00:07:17.400 --> 00:07:29.100
[Transcript missing]

00:07:31.890 --> 00:07:35.050
and setting the histogram
levels is similar.

00:07:35.080 --> 00:07:37.450
So you can get the levels, you can change

00:07:39.470 --> 00:07:45.670
Here's the gradient parameter,
the other optional one

00:07:45.670 --> 00:07:45.670
shown closed and open.

00:07:46.040 --> 00:07:50.120
and this is probably more generally
useful to plugin developers.

00:07:50.120 --> 00:07:55.490
You can use gradients which
you can see the little pop-up

00:07:56.240 --> 00:07:59.980
and Dave Howell, Pete Warden.

00:08:00.190 --> 00:08:02.690
So let's get started.

00:08:02.690 --> 00:08:09.520
So I'm going to start with a
quick demo of the new FxPlug SDK.

00:08:09.520 --> 00:08:12.620
It's a very cool new tool.

00:08:12.680 --> 00:08:16.860
I think this is a very popular tool.

00:08:16.860 --> 00:08:20.210
It's called the FxPlug SDK.

00:08:20.210 --> 00:08:24.480
It's a very popular tool,
and it's a very popular

00:08:28.140 --> 00:08:32.540
So to show you what those look
like we'll go to the demo machine.

00:08:32.540 --> 00:08:39.740
Yeah, I'll just, again,
I'll drag over the same footage.

00:08:42.000 --> 00:08:47.310
and Dave Howell, Pete Warden.

00:08:48.900 --> 00:08:56.500
[Transcript missing]

00:08:56.900 --> 00:08:58.900
and Dave Howell, Pete Warden.

00:08:58.920 --> 00:08:59.990
I will start with a nice little
widget letting you do all the things

00:08:59.990 --> 00:09:05.960
that you would expect to do with
a Levels color correction tool.

00:09:05.960 --> 00:09:17.110
Now if I actually go over and
select gradient color eyes while

00:09:17.110 --> 00:09:23.390
I have got the image selected.

00:09:29.100 --> 00:09:50.470
and Dave Howell, Pete Warden.

00:09:50.470 --> 00:09:50.470
You can see this whole gradient
UI widget that you basically get.

00:09:50.470 --> 00:09:50.470
You really don't have to
do any work for this on the

00:09:50.470 --> 00:09:50.470
FxPlug side as Dave was saying.

00:09:50.470 --> 00:09:50.470
All you do is request a
gradient parameter and we set

00:09:50.470 --> 00:09:50.470
all of this stuff up for you.

00:09:50.470 --> 00:09:50.470
For example, I can put a, you know,

00:09:53.880 --> 00:09:59.470
and Dave Howell, Pete Warden.

00:10:00.910 --> 00:10:02.600
and Dave Howell, Pete Warden.

00:10:02.600 --> 00:10:06.680
It really is very straightforward to
actually be using this in the code.

00:10:07.200 --> 00:10:08.500
and Dave.

00:10:08.760 --> 00:10:10.790
Back to slides.

00:10:10.880 --> 00:10:13.720
So custom parameters.

00:10:14.630 --> 00:10:18.720
You create a custom parameter the same
way as you create the other parameters

00:10:18.760 --> 00:10:23.320
with the addCustomParameterWithName
method which is one of the methods in

00:10:23.320 --> 00:10:26.400
the standard parameter creation API.

00:10:26.720 --> 00:10:29.420
But the interesting thing here
is that the default value is

00:10:29.430 --> 00:10:31.600
an object of your custom class.

00:10:31.600 --> 00:10:34.960
So the type can be any
class that you want,

00:10:35.110 --> 00:10:42.520
except that it needs to conform
to the NSCoding protocol.

00:10:42.670 --> 00:10:50.160
So, and that's used for motion to be able
to flatten your custom data when it's

00:10:50.160 --> 00:10:56.090
saving a project or for duplicating a set
of parameters from one track to another,

00:10:56.100 --> 00:10:57.120
that sort of thing.

00:10:58.770 --> 00:11:02.680
So here you can see we instantiate
something called MyDataClass with

00:11:02.680 --> 00:11:05.990
the empty data method.

00:11:06.380 --> 00:11:08.460
and this is the NSCoding method.

00:11:08.460 --> 00:11:10.800
You can see it's really straightforward.

00:11:10.800 --> 00:11:14.390
Obviously it will get complex
if your custom class is complex,

00:11:14.390 --> 00:11:16.300
but it's just two methods
that you need to implement:

00:11:16.300 --> 00:11:19.610
encodeWithCoder and initWithCoder.

00:11:24.100 --> 00:11:33.500
[Transcript missing]

00:11:33.800 --> 00:11:52.500
[Transcript missing]

00:11:52.890 --> 00:11:54.610
and Dave Howell, Pete Warden.

00:11:54.640 --> 00:11:58.590
I've added another restriction which
is that you have to do keyed coding

00:11:58.590 --> 00:12:00.750
with your NSCoding implementation.

00:12:00.760 --> 00:12:04.510
It needs to use encode object for
key and decode object for key.

00:12:05.390 --> 00:12:06.710
and as long as you do
that you'll be fine.

00:12:06.780 --> 00:12:10.740
You can't just use NSString which
does conform to NSCoding,

00:12:10.740 --> 00:12:15.210
you have to make it use keyed coding.

00:12:16.340 --> 00:12:25.830
So when you do custom parameter UI,
what you do is you create an NSView and

00:12:26.310 --> 00:12:32.390
and tell the host app that using the
FxPlug protocols that that's to be the

00:12:32.400 --> 00:12:35.990
control for one of your parameters.

00:12:36.380 --> 00:12:39.290
and it can be any subclass of NSView.

00:12:39.380 --> 00:12:44.540
It could be a subclass of
NSOpenGLView or your own thing.

00:12:44.540 --> 00:12:48.290
Here's an example that is
NSTextEditView which is really

00:12:48.290 --> 00:12:52.290
pretty simple to implement.

00:12:52.450 --> 00:12:54.300
You get the standard methods.

00:12:54.300 --> 00:12:57.100
You can use the standard
NSTextEditView methods to get the

00:12:57.100 --> 00:12:59.300
value of the string inside the view.

00:12:59.300 --> 00:13:02.410
The other thing you can do
with the NSView is you can

00:13:02.410 --> 00:13:06.450
create an interface builder,
save it in a nib and because

00:13:06.450 --> 00:13:09.950
an FxPlug is a bundle,
you can look inside your resources

00:13:09.950 --> 00:13:11.290
folder and load that nib.

00:13:11.300 --> 00:13:15.140
It will be localized
and all that good stuff.

00:13:18.830 --> 00:13:26.690
Another thing you need to do when you
use the custom parameter view host

00:13:27.090 --> 00:13:45.630
and Dave Howell, Pete Warden.

00:13:45.630 --> 00:13:46.580
The first thing you need to do is add the
name of that API to the list of protocols

00:13:46.580 --> 00:13:46.580
that you implement in your plug-in.

00:13:46.580 --> 00:13:46.580
Here is the example from the
Info.plist of a generator that has

00:13:46.800 --> 00:14:01.800
[Transcript missing]

00:14:02.000 --> 00:14:33.200
[Transcript missing]

00:14:34.300 --> 00:14:58.400
[Transcript missing]

00:14:59.220 --> 00:15:03.360
So in Motion your custom view
appears in the inspector.

00:15:03.360 --> 00:15:06.350
You can make your view resizable,
although you might notice that

00:15:06.420 --> 00:15:09.260
in Motion right now the resizing
will only be horizontally.

00:15:09.470 --> 00:15:11.480
There's a fixed height.

00:15:11.750 --> 00:15:15.200
Whatever height you create your view as,
it's going to always be that height.

00:15:15.200 --> 00:15:19.990
There's no control for
resizing that in the app.

00:15:22.270 --> 00:15:26.790
You can also use any subclass of NSView,
and I just made a silly example of

00:15:26.850 --> 00:15:29.670
something you might do in a custom view,
but it can really be any

00:15:29.680 --> 00:15:31.090
kind of graphical stuff.

00:15:32.360 --> 00:15:35.920
and of course you can use
Core Image and Core Graphics

00:15:35.920 --> 00:15:38.950
and all of that for preview.

00:15:39.850 --> 00:15:45.020
Now, you get the methods,
you would override methods in

00:15:45.020 --> 00:15:51.670
NSView and NSResponder classes to get
mouse down events and anything else,

00:15:51.750 --> 00:15:54.440
key events, even complex tablet events.

00:15:54.490 --> 00:16:00.800
If you use the tablet events for
things like angle and whether you're

00:16:00.800 --> 00:16:05.420
using the eraser or the pen tip,
then you would get those events too.

00:16:06.700 --> 00:16:10.900
and of course a scroll event.

00:16:10.900 --> 00:16:16.450
You can also assign a contextual menu to
your view so when the user right clicks

00:16:16.450 --> 00:16:19.650
or control clicks you can present a menu.

00:16:21.970 --> 00:16:25.360
One thing to note though is that
unlike any other of the methods

00:16:25.410 --> 00:16:36.290
that you implement in your plugin,
the custom parameter UI methods are

00:16:36.960 --> 00:16:40.840
they're called -- I'm sorry -- the
NSView and NSResponder methods are

00:16:40.840 --> 00:16:43.480
going to be called by the system,
not by FXplug.

00:16:43.480 --> 00:16:48.760
So the host app might not be in a state
where you can access parameter values,

00:16:48.760 --> 00:16:53.030
get and set parameters or change
the state of parameters like

00:16:53.030 --> 00:16:57.350
hiding them or deactivating some,
that sort of thing.

00:16:57.370 --> 00:17:01.720
So in order to access your parameters,
you need to use the action API.

00:17:01.720 --> 00:17:07.260
You get that host API from
the ProPlug API for protocol

00:17:07.260 --> 00:17:11.120
method and just make two calls.

00:17:11.120 --> 00:17:15.810
One is start action before you start
accessing the parameter values and

00:17:15.930 --> 00:17:18.720
then end action when you're done.

00:17:18.720 --> 00:17:24.700
Pretty simple, but if you don't do it,
you'll suffer heinous results.

00:17:24.970 --> 00:17:27.960
The other thing that's in the
Custom Parameter Action API is one

00:17:27.960 --> 00:17:29.900
method for getting the current time.

00:17:29.900 --> 00:17:34.190
And that's just because, of course,
when you get a mouse down event,

00:17:34.190 --> 00:17:36.900
you don't know what the
time in the timeline is.

00:17:36.900 --> 00:17:39.640
It's the current time in the timeline,
not the system time

00:17:39.640 --> 00:17:40.900
or anything like that.

00:17:40.900 --> 00:17:44.110
If you want to know what frame you
were on when the user clicked or

00:17:44.110 --> 00:17:47.190
dragged or pressed a key or something,
then you just use that and

00:17:47.190 --> 00:17:48.900
get the current time value.

00:17:48.960 --> 00:17:51.670
And then when you go to
get a parameter value,

00:17:51.670 --> 00:17:54.720
you can pass that frame number,
that time in.

00:17:56.480 --> 00:17:59.780
So you probably want to see
what these things look like.

00:17:59.780 --> 00:18:00.620
Okay.

00:18:00.620 --> 00:18:01.670
Should we go to the demo machine?

00:18:02.890 --> 00:18:07.670
I'm Pete Warden,
I'm an engineer with the Motion Team,

00:18:07.780 --> 00:18:11.400
and I'm going to be talking about
on-screen controls initially.

00:18:11.400 --> 00:18:13.990
But what I want to really do is
just give you an idea of what

00:18:14.060 --> 00:18:17.260
we're actually talking about,
what the motivation is

00:18:17.260 --> 00:18:20.400
here to be doing this.

00:18:20.400 --> 00:18:25.560
So,
if I go over to our Kaleidoscope filter,

00:18:25.640 --> 00:18:29.130
and you pay attention to
the thing that I'm actually

00:18:29.130 --> 00:18:32.810
dragging around with the mouse,
Um...

00:18:32.960 --> 00:18:38.090
This whole UI widget is actually
a custom UI widget that we

00:18:38.090 --> 00:18:40.740
are drawing through FxPlug.

00:18:40.740 --> 00:18:46.260
You get control over a whole
bunch of segment angle things,

00:18:46.260 --> 00:18:53.210
you can drag the center of this around,
you can actually change the rotation you

00:18:53.280 --> 00:18:57.910
have got for the kaleidoscope filter,
all through just one

00:18:57.910 --> 00:18:59.660
fairly simple widget.

00:18:59.660 --> 00:19:03.270
And this is really something
that our users have been very

00:19:03.680 --> 00:19:08.920
keen on and very impressed by,
and it is something that if you

00:19:08.920 --> 00:19:14.990
are writing your own filter,
if you can find a way to give users this

00:19:14.990 --> 00:19:20.200
sort of control over what you are doing,
they are going to be very

00:19:20.200 --> 00:19:24.730
happy and there is going to be,
you know, people are definitely

00:19:24.740 --> 00:19:27.880
going to look at this,
you know,

00:19:27.950 --> 00:19:32.380
buy it if there is this sort of high
level of user interaction there.

00:19:32.380 --> 00:19:34.180
Do you want to come over to slides?

00:19:34.180 --> 00:19:35.380
Yeah, if you have got the, yeah.

00:19:35.380 --> 00:19:37.380
Some slides for on screen controls.

00:19:37.380 --> 00:19:40.660
Yeah,
so now that I have given you the kind of,

00:19:40.660 --> 00:19:44.970
you know, the 10,000 foot view of
what on screen controls are,

00:19:44.970 --> 00:19:48.650
I am just going to go over some of the
details of actually implementing these,

00:19:48.650 --> 00:19:51.940
the sort of stuff that you will
need to know if you are planning

00:19:51.940 --> 00:19:54.940
on doing this in your own plug-ins.

00:19:56.600 --> 00:21:45.300
[Transcript missing]

00:21:45.970 --> 00:21:48.320
and Dave Howell, Pete Warden.

00:21:48.320 --> 00:21:53.860
As far as user interaction,
we have our own custom API that

00:21:53.880 --> 00:21:57.100
gives you mouse and keyboard events.

00:21:57.600 --> 00:22:02.800
As Dave was saying about
the set parameter stuff,

00:22:02.800 --> 00:22:06.260
when you actually get those events,
what you should be doing is calling

00:22:06.370 --> 00:22:12.740
set parameter on the parameters for
your filter and doing control over

00:22:12.740 --> 00:22:15.330
your filter in that sort of way.

00:22:15.600 --> 00:22:29.200
[Transcript missing]

00:22:30.600 --> 00:22:37.230
A way of drawing into the screen
buffer where instead of using

00:22:37.230 --> 00:22:44.000
textures you actually draw in
IDs of the user interface elements

00:22:44.000 --> 00:22:45.600
that you are actually drawing.

00:22:45.600 --> 00:22:52.410
And then we take that screen buffer
and we read the ID when we want to

00:22:52.460 --> 00:22:58.370
figure out which object or which
part of your filters UI the user

00:22:58.370 --> 00:23:00.600
has just clicked on and selected.

00:23:00.780 --> 00:23:06.270
So you do the same thing as you would do
to actually draw the UI except instead

00:23:06.270 --> 00:23:14.100
of setting colors or textures you just
set an ID saying which part of the UI you

00:23:14.100 --> 00:23:15.600
are actually drawing at the current time.

00:23:15.600 --> 00:23:17.190
time.

00:23:18.900 --> 00:23:25.010
Well, that's just been a quick
skip over on screen controls.

00:23:25.010 --> 00:23:29.150
Now I'm going to go into some of
the really kind of dark and dingy

00:23:29.220 --> 00:23:33.900
corners of the OpenGL rendering side.

00:23:34.370 --> 00:23:40.500
The first thing that I want
to talk about is pbuffers.

00:23:40.890 --> 00:23:42.700
What is a pbuffer?

00:23:42.890 --> 00:23:45.570
A pbuffer stands for pixel buffer.

00:23:45.620 --> 00:23:47.190
It is an OpenGL term.

00:23:47.460 --> 00:23:54.240
What you can think about is if you ever
need a temporary image to draw into,

00:23:54.240 --> 00:23:57.920
if you ever need intermediate
results in your filter,

00:23:57.920 --> 00:24:01.410
if you ever need to be doing
multi-pass rendering at all,

00:24:01.550 --> 00:24:05.800
then you are going to have to start
to get to grips with pbuffers.

00:24:05.960 --> 00:24:13.050
You can do simple filters such as color
correction that you can fit into a single

00:24:13.060 --> 00:24:16.800
fragment program without using pbuffers.

00:24:16.800 --> 00:24:22.120
As I was saying in the introductory talk,
you can just set up your

00:24:22.140 --> 00:24:24.800
fragment program and draw a quad.

00:24:24.800 --> 00:24:29.250
But we find for the majority
of our more complex plugins,

00:24:29.250 --> 00:24:32.800
we actually end up
doing things like blurs,

00:24:32.800 --> 00:24:35.800
we actually end up having to
render out intermediate results.

00:24:35.800 --> 00:24:38.650
And then use those intermediate
results in further stages.

00:24:39.000 --> 00:24:42.160
And in those cases,
you really need to be getting

00:24:42.160 --> 00:24:43.800
to grips with pbuffers.

00:24:46.530 --> 00:24:51.880
Now, we have some example code that
we give out about pbuffers

00:24:51.880 --> 00:24:55.520
for the creation and deletion.

00:24:55.520 --> 00:24:57.720
I just want to go over
some of the policy,

00:24:57.720 --> 00:25:01.270
some of the things that you
really should know if you're

00:25:01.270 --> 00:25:04.740
actually looking at using pbuffers.

00:25:04.740 --> 00:25:11.920
One of them is pbuffer
creation and deletion.

00:25:11.920 --> 00:25:17.700
We really highly recommend that you
make sure that you just create pbuffers

00:25:17.890 --> 00:25:24.320
once in your render function and then
you actually keep them around for that

00:25:24.380 --> 00:25:28.320
plugin's instance for as long as you can.

00:25:28.320 --> 00:25:33.640
The pbuffer creation is a
very expensive operation.

00:25:33.640 --> 00:25:40.070
There's a whole bunch of system
resources and on the OpenGL driver level,

00:25:40.110 --> 00:25:41.880
there's an awful lot of work.

00:25:41.880 --> 00:25:46.800
It has to go in every time you
create or delete a pbuffer.

00:25:46.830 --> 00:25:52.030
It makes a massive difference to your
rendering performance if you can just

00:25:52.060 --> 00:25:58.500
do that creation or deletion once and
then just have them sitting there.

00:25:58.500 --> 00:26:02.810
This gets a little bit more
complicated when you're dealing

00:26:03.490 --> 00:26:08.800
with a situation where a filter is
on something that's changing size,

00:26:08.800 --> 00:26:11.680
for example, a particle system.

00:26:12.050 --> 00:26:19.200
You really need to be creating pbuffers
that fit the size that you've been given.

00:26:19.200 --> 00:26:23.210
Especially particle systems
are really a pathological case,

00:26:23.210 --> 00:26:28.180
but it comes up in a lot of other
situations as well where something's

00:26:28.180 --> 00:26:30.760
continuously changing size.

00:26:30.760 --> 00:26:34.160
If you're not careful,
you end up actually recreating those

00:26:34.160 --> 00:26:39.800
pbuffers that you're using within
your filter every single frame.

00:26:39.800 --> 00:26:41.360
One of the things that we have been
doing is we've been doing a lot

00:26:41.390 --> 00:26:42.750
of work on the pbuffer rendering.

00:26:42.840 --> 00:26:43.790
We've been doing a lot of
work on the pbuffer rendering.

00:26:43.800 --> 00:26:44.800
We've been doing a lot of
work on the pbuffer rendering.

00:26:44.800 --> 00:26:45.530
One of the things that we've been
doing is using various strategies

00:26:45.530 --> 00:26:49.100
to over-allocate pbuffers so that
we actually allocate pbuffers larger

00:26:49.320 --> 00:26:54.590
than we need at the current time so
that we're able to deal with some

00:26:54.590 --> 00:26:58.320
growth before we have to reallocate.

00:26:58.320 --> 00:27:02.000
That's actually been a big part
of our optimization strategy.

00:27:02.000 --> 00:27:06.550
That's made a real difference to
our performance with the filters.

00:27:08.810 --> 00:27:16.500
Now, when you actually come to trying to
do some rendering using PBuffers,

00:27:16.500 --> 00:27:22.880
the way that it works is you
call some sort of PBuffer begin

00:27:22.880 --> 00:27:29.200
function which redirects all of your
OpenGL drawing into the PBuffer context,

00:27:29.240 --> 00:27:34.130
all of your rendering calls then
get rendered into that PBuffer

00:27:34.220 --> 00:27:40.340
and then you call some sort of
PBuffer end which returns you to

00:27:40.400 --> 00:27:43.460
the context that you were in before.

00:27:43.480 --> 00:27:48.380
Once you've done that,
really you can call some sort of use

00:27:48.380 --> 00:27:54.790
function on the PBuffer and that just
lets you use that exactly like a texture.

00:27:55.090 --> 00:28:01.110
There really is no difference from
the actual user point of view.

00:28:01.100 --> 00:29:01.600
[Transcript missing]

00:29:01.720 --> 00:29:04.340
any of the other things you'd
really like to be doing there.

00:29:04.340 --> 00:29:09.170
I mean there are some limited
ways that you can use the geo

00:29:09.170 --> 00:29:15.640
blending to do accumulation into the
pBuffer that you're drawing into,

00:29:15.640 --> 00:29:24.040
or to do simple compositing but there
really isn't a good way of accessing your

00:29:24.090 --> 00:29:27.240
current pBuffer that you're drawing into.

00:29:27.240 --> 00:29:32.000
So the scheme that we always use,
we use an awful lot,

00:29:32.000 --> 00:29:36.680
is the ping pong as we call it,
or the double buffer

00:29:36.910 --> 00:29:42.190
approach where we draw some,
do some rendering into a buffer and then

00:29:42.550 --> 00:29:48.820
when we need to reference that to do
some further processing on it we go to a,

00:29:48.880 --> 00:29:55.360
we switch over to a second buffer and
use the first pBuffer as a texture,

00:29:55.420 --> 00:29:59.980
as an input into the fragment program.

00:30:00.020 --> 00:30:03.140
And with two buffer you can pretty
much do all of that you want,

00:30:03.140 --> 00:30:08.380
you just switch back and forth
for every stage that you're doing.

00:30:11.060 --> 00:30:13.760
So I've covered pixel buffers there.

00:30:13.760 --> 00:30:18.470
Now what I want to talk about
is some pixel shader stuff.

00:30:18.520 --> 00:30:23.290
Just some of the sort of things
I want you really to know about

00:30:23.320 --> 00:30:29.780
fragment programs and some of the funky
little details of using our fragment

00:30:29.780 --> 00:30:32.490
program within FX plug filters.

00:30:32.540 --> 00:30:39.940
As I said, fragment programs,
pixel shaders, there's a lot of different

00:30:39.940 --> 00:30:41.420
terms for all of these things.

00:30:41.420 --> 00:30:48.370
What they involve is calling
assembler-like functions on every

00:30:48.370 --> 00:30:52.610
pixel that you're drawing through
the OpenGL rendering engine.

00:30:55.760 --> 00:31:03.880
We have some code up as part of our Xcode
template that demonstrates how to create

00:31:03.880 --> 00:31:09.400
and delete these R fragment programs,
it really isn't that much code.

00:31:09.410 --> 00:31:13.970
And as far as using them,
if you're used to using

00:31:13.970 --> 00:31:19.690
textures for OpenGL rendering,
it's very much the same syntax.

00:31:19.760 --> 00:31:24.540
All you do is you bind the
fragment program just before

00:31:24.540 --> 00:31:28.930
you're ready to draw your quad,
and then when you actually

00:31:28.930 --> 00:31:33.660
call the rendering routines,
the fragment program gets called on every

00:31:33.660 --> 00:31:37.990
pixel that you render using that quad.

00:31:38.010 --> 00:31:44.530
And I also briefly want to talk about
some of the possible alternatives.

00:31:44.560 --> 00:31:49.260
I mean, one of the things you can do as
well is if you have a filter that

00:31:49.260 --> 00:31:56.840
will fit into the core image idea,
then that's definitely something

00:31:56.840 --> 00:32:04.040
that you can do within your FX plug
filter using core image filters,

00:32:04.040 --> 00:32:09.540
chaining them together, that's a very,
very viable way of approaching this.

00:32:09.540 --> 00:32:15.440
Another thing we have
looked at is using CG,

00:32:15.440 --> 00:32:20.640
using--because we really-- we
know that our fragment program

00:32:20.640 --> 00:32:25.030
is a pretty low level language,
so it would be nice if we actually

00:32:25.050 --> 00:32:30.140
had a more high level way of
approaching writing our pixel shaders.

00:32:30.140 --> 00:32:37.440
So we have looked at trying to
use CG within our FX plug filters.

00:32:37.440 --> 00:32:41.730
And we've had some success.

00:32:41.740 --> 00:32:50.340
We also have run into some problems
with the Mac CG implementation.

00:32:50.340 --> 00:32:54.440
So it's something to think about,
but we really have turned back to

00:32:54.440 --> 00:32:59.840
just using our fragment program as
our main implementation language

00:32:59.840 --> 00:33:04.040
for all of the filters in motion,
just because it's a fairly stable,

00:33:04.040 --> 00:33:07.540
it's a fairly well understood system.

00:33:07.570 --> 00:33:11.740
And it also lets us do some of the
stuff that we need to do to run on,

00:33:11.740 --> 00:33:15.910
for example, ATI cards,
which happen to have a lot of

00:33:15.910 --> 00:33:19.030
restrictions on the sort of
programs that they can run.

00:33:19.040 --> 00:33:22.830
It's a lot easier to actually be
dealing at the assembler level with

00:33:22.830 --> 00:33:27.330
those sort of restrictions rather than
trying to figure it out from compiled

00:33:27.330 --> 00:33:30.600
output of a more high level language.

00:33:33.610 --> 00:33:36.930
Another thing that I'm going
to talk about is the floating

00:33:36.930 --> 00:33:40.500
point support within Motion,
and the floating point

00:33:40.500 --> 00:33:45.010
support in OpenGL in general.

00:33:45.170 --> 00:33:48.990
There is some floating
point support in Panther,

00:33:49.190 --> 00:33:55.100
but in general it's a Tiger-only feature.

00:33:55.110 --> 00:33:59.930
That's where it's really been, you know,
all of the bugs have been ironed out and

00:33:59.930 --> 00:34:05.260
it really seems to be working well on
all of the cards that Motion ships on,

00:34:05.260 --> 00:34:13.250
all the way from the MV34
up to the newer cards.

00:34:14.560 --> 00:34:19.980
It doesn't actually make much of
a difference to simple filters.

00:34:20.020 --> 00:34:25.740
Since our Fragment program
runs internally at floating

00:34:25.740 --> 00:34:29.900
point depth anyway,
as long as you're just doing

00:34:29.900 --> 00:34:36.680
a single pass fragment shader,
pixel shader plugin,

00:34:36.720 --> 00:34:41.000
then the conversion is
kind of handled for you.

00:34:41.030 --> 00:34:43.950
It's handled outside of
the R Fragment program.

00:34:44.210 --> 00:34:48.690
When it pulls in the texture and
when it writes out your final result,

00:34:48.690 --> 00:34:55.390
it converts down to whatever bit
depth you happen to be rendering to.

00:34:55.600 --> 00:36:45.300
[Transcript missing]

00:36:49.100 --> 00:36:53.080
This is another question that
we get asked an awful lot is,

00:36:53.080 --> 00:36:55.760
"Okay, I want to do some 3D rendering.

00:36:55.760 --> 00:36:58.210
Where's my ZBuffer?"

00:36:58.560 --> 00:37:07.020
When we call an FxPlug plugin,
we call you in a context that doesn't

00:37:07.020 --> 00:37:09.910
actually have a depth buffer attached.

00:37:10.620 --> 00:37:14.710
That's a conscious decision on our
part because most plugins don't

00:37:14.710 --> 00:37:18.410
actually need the depth buffer,
and every time you use the

00:37:18.470 --> 00:37:23.840
depth buffer it takes up VRAM,
it takes up system resources.

00:37:23.890 --> 00:37:28.510
So if we can avoid rendering
using a depth buffer,

00:37:28.520 --> 00:37:32.500
that really does speed
things up a fair bit.

00:37:32.560 --> 00:37:37.780
So what do you do if you actually
need a Z-buffer for your rendering,

00:37:37.780 --> 00:37:44.040
if you're doing some sort of 3D
rendering within your plugin?

00:37:44.400 --> 00:37:51.180
Well, you just create a P-buffer
internally to your plugin,

00:37:51.180 --> 00:37:58.820
render into that with a Z-buffer
attached to that P-buffer,

00:37:58.820 --> 00:38:03.820
and then you take the results from that
P-buffer and use it as a texture to

00:38:03.820 --> 00:38:06.980
draw into the context that we give you.

00:38:07.970 --> 00:38:13.810
Now one thing I should
mention is that you will,

00:38:13.810 --> 00:38:16.760
especially in this space,
if you're doing 3D,

00:38:16.760 --> 00:38:24.250
using a Z-buffer to handle intersections
that tends to show up some really

00:38:24.250 --> 00:38:33.640
nasty artifacts that people in the
motion graphics industry really

00:38:33.640 --> 00:38:37.340
don't expect to see the sort of
jagginess that you end up using

00:38:37.340 --> 00:38:40.290
just a standard Z-buffer implementation.

00:38:40.440 --> 00:38:47.640
So some sort of anti-aliasing,
some sort of improvement to the

00:38:48.030 --> 00:38:51.260
quality there is very recommended.

00:38:57.700 --> 00:39:00.920
Another thing to be aware of,
or hopefully we take care

00:39:00.920 --> 00:39:04.280
of most of this for you,
but just in case you ever

00:39:04.410 --> 00:39:07.090
run into this situation,
I want to go over some of

00:39:07.200 --> 00:39:13.440
the limits to the texture and
pbuffer sizes you can have.

00:39:14.190 --> 00:39:21.690
On current ATI cards,
you can go up to 2048x2048 for a

00:39:21.690 --> 00:39:26.660
single texture or for a pbuffer
that you're rendering into.

00:39:26.670 --> 00:39:37.350
The same is true on NV34 cards,
the 64MB NVIDIA cards that are out there.

00:39:37.350 --> 00:39:44.140
But for all other NVIDIA cards you
can actually go up to 4096x4096.

00:39:44.170 --> 00:39:46.250
I

00:39:47.470 --> 00:39:51.660
This is the situation for 8-bit,
and this is just a hardware

00:39:51.660 --> 00:39:53.800
limitation of the cards.

00:39:53.820 --> 00:39:58.760
Now, for float it gets a little bit more
complicated because you start to run

00:39:58.760 --> 00:40:01.900
into the VRAM limits on the card.

00:40:01.930 --> 00:40:06.650
You can only fit so many
P-buffers and so many textures

00:40:06.650 --> 00:40:09.100
on the card at the same time.

00:40:09.120 --> 00:40:14.030
And it gets kind of variable
depending on even stuff like if

00:40:14.030 --> 00:40:19.130
people have two monitors attached,
that actually splits the VRAM in

00:40:19.130 --> 00:40:24.000
half and gives half to each monitor.

00:40:24.000 --> 00:40:29.590
So there's a whole bunch of calculations
we end up having to do to figure out,

00:40:29.590 --> 00:40:34.690
okay, what's the maximum size that we
can have for textures and P-buffers

00:40:34.700 --> 00:40:38.340
if you're at higher bit depths.

00:40:39.540 --> 00:40:43.670
Now, as I said,
we try and handle this for you.

00:40:44.110 --> 00:40:50.710
We will always clamp our input and
output sizes to be legal sizes.

00:40:50.710 --> 00:40:53.800
We do a lot of calculation,
we do a lot of work to actually

00:40:53.800 --> 00:41:00.320
make sure that we never call any
plugins asking for output or output

00:41:00.340 --> 00:41:05.390
sizes that they can't deliver,
or giving input textures

00:41:05.390 --> 00:41:07.400
that are illegal sizes.

00:41:07.540 --> 00:41:10.690
So, um...

00:41:11.200 --> 00:41:13.240
and Dave Howell, Pete Warden.

00:41:13.240 --> 00:41:16.840
The place where this gets tricky is,
as I was saying about

00:41:16.900 --> 00:41:21.280
on the Z-buffer side,
trying to do multi-sampling or trying

00:41:21.450 --> 00:41:23.270
to do anti-aliasing to improve quality.

00:41:23.270 --> 00:41:28.100
Then very often what you want to do
is create a P-buffer that is larger

00:41:28.100 --> 00:41:36.770
than your input so you can render into
it and then use that as a multi-sample

00:41:36.830 --> 00:41:39.890
buffer to improve the quality.

00:41:41.720 --> 00:41:42.640
gets very tricky.

00:41:42.640 --> 00:41:47.750
You really have to be careful that
you're not running into these size

00:41:47.750 --> 00:41:51.920
limits I've just been talking about
when you're actually doing that sort of

00:41:51.920 --> 00:41:57.160
allocation of p-buffers that are larger
than the input that we're giving you.

00:41:57.160 --> 00:42:00.570
So we don't have a
magic solution for this,

00:42:00.800 --> 00:42:04.360
but we want to make sure that
if you're seeing corruption,

00:42:04.360 --> 00:42:09.040
if you're seeing issues and you
are allocating p-buffers that are

00:42:09.040 --> 00:42:14.000
larger than the input or the output,
that this is something that you

00:42:14.000 --> 00:42:16.920
talk to us about and this is
something that you're aware of.

00:42:19.900 --> 00:42:24.900
Okay,
well I'll just pass back to Dave here.

00:42:24.900 --> 00:42:27.890
I wanted to point out one
other thing that because

00:42:27.900 --> 00:42:32.570
FxPlug plugins are CFBundles,
NSBundles,

00:42:33.370 --> 00:42:37.840
and they have resource folders,
while you can use the standard

00:42:37.960 --> 00:42:41.560
CI filters built into Core Image,
all the regular

00:42:41.560 --> 00:42:44.160
Core Image filters should work,
but you can also make your own

00:42:44.260 --> 00:42:46.900
image units and they can sit
inside your resource folders,

00:42:46.900 --> 00:42:48.900
you can load them when needed.

00:42:48.900 --> 00:42:52.840
And there's a method,
you give a partial path name

00:42:52.840 --> 00:42:56.100
or file name and you say,
use the standard bundle

00:42:56.230 --> 00:42:59.230
method for getting that file,
the file with that path out

00:42:59.230 --> 00:43:00.900
of your resource folder.

00:43:00.900 --> 00:43:07.900
And you can use the type of image unit
that has actual Objective-C code in it,

00:43:07.900 --> 00:43:09.980
or you can do the
script only image units,

00:43:09.980 --> 00:43:10.900
those will work great.

00:43:10.900 --> 00:43:13.910
too.

00:43:15.390 --> 00:43:20.500
Another thing that I want to talk about
is Intel-based Macs and this whole thing.

00:43:20.500 --> 00:43:24.490
Of course,
we don't have the SDK revved yet.

00:43:24.570 --> 00:43:28.700
You wouldn't be able to use it anyway
until Motion is running on Intel-based,

00:43:28.700 --> 00:43:31.650
on the transition kit.

00:43:31.680 --> 00:43:36.970
But it will come and we'll let
you know what the strategy is.

00:43:37.000 --> 00:43:40.060
Just keep watching the website.

00:43:40.060 --> 00:43:45.230
There is a list of
links on the developer,

00:43:45.350 --> 00:43:47.560
the WWDC page.

00:43:47.560 --> 00:43:54.610
It has,
as I said in the session yesterday,

00:43:55.080 --> 00:44:01.350
the place to go to
download the FxPlug SDK.

00:44:01.400 --> 00:44:04.090
You can download it and you can look
at the headers and check out the

00:44:04.090 --> 00:44:08.080
Xcode templates and the examples and
read the documentation and all that.

00:44:08.080 --> 00:44:08.580
But to actually run and
execute the FxPlug SDK,

00:44:08.590 --> 00:44:09.410
you can download it and you can look
at the headers and check out the Xcode

00:44:09.420 --> 00:44:11.380
templates and the examples and read
the documentation The only host app,

00:44:11.380 --> 00:44:15.010
of course, is Motion, and only Motion 2.

00:44:16.790 --> 00:44:22.750
There is a 30-day trial version
of Motion available too,

00:44:22.800 --> 00:44:26.410
so if you want to just check
out the SDK for a while,

00:44:26.410 --> 00:44:27.830
you can do that.

00:44:28.020 --> 00:44:49.250
and Dave Howell, Pete Warden.

00:44:49.250 --> 00:44:50.420
So we'll take questions
at the microphone there,

00:44:50.420 --> 00:44:50.420
but there's also afterwards a lunch
at 12:45 upstairs in the pro audio

00:44:50.420 --> 00:44:50.420
and pro video connection room.

00:44:50.420 --> 00:44:50.420
So grab a lunch and come
on up and we'll talk more.

00:44:52.580 --> 00:44:56.010
and also if you have any,
if you want to contact us we

00:44:56.040 --> 00:45:00.520
have a mailing list that's
proappsdk@group.apple.com.

00:45:02.840 --> 00:45:03.730
and Phil Fitts.

00:45:03.750 --> 00:45:07.550
It's a list of maybe a dozen people
at Apple who are working on FxPlug

00:45:07.560 --> 00:45:10.940
and we'll be glad to answer questions.
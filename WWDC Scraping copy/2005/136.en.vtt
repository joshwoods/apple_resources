WEBVTT

00:00:00.560 --> 00:00:01.200
Hello.

00:00:01.520 --> 00:00:03.080
Good afternoon, everyone.

00:00:03.110 --> 00:00:05.290
Welcome to session 136.

00:00:05.410 --> 00:00:10.280
This is going to be the Getting the
Most Out of Cocoa Binding session.

00:00:10.280 --> 00:00:11.680
My name is Ron Luu-Saang.

00:00:11.690 --> 00:00:14.880
I work on Core Data and Cocoa Bindings.

00:00:14.880 --> 00:00:18.680
And Thursday is actually the best
day for me during the conference.

00:00:18.850 --> 00:00:21.240
I'm just sleep deprived
enough that I'm having fun,

00:00:21.400 --> 00:00:23.720
but I can still stand on both my feet.

00:00:23.720 --> 00:00:30.200
And everybody's been to the beginning,
the primary binding session by Malcolm?

00:00:30.290 --> 00:00:31.440
Show of hands.

00:00:31.440 --> 00:00:33.640
Everybody's--ah, very good.

00:00:33.860 --> 00:00:34.610
Excellent.

00:00:34.700 --> 00:00:36.280
Everybody saw the
Core Data session this morning?

00:00:36.280 --> 00:00:38.340
Oh, even better.

00:00:38.340 --> 00:00:39.610
Excellent.

00:00:39.870 --> 00:00:41.480
Okay.

00:00:41.480 --> 00:00:44.340
The format for this session
is we're going to skip all of

00:00:44.340 --> 00:00:46.090
the--this is model view controller.

00:00:46.090 --> 00:00:48.300
We're going to skip over
all the beginner stuff.

00:00:48.440 --> 00:00:52.150
Assume that you've taken the plunge,
started working with bindings at least,

00:00:52.180 --> 00:00:54.610
and we'll go over a grab bag of-- Yeah.

00:00:54.780 --> 00:00:56.400
--life topics that maybe we
haven't had a good chance to

00:00:56.510 --> 00:00:59.040
tell everybody about before.

00:00:59.040 --> 00:01:02.150
So the roadmap will look like this.

00:01:03.020 --> 00:01:06.740
We're going to go over some details
about using the array controller,

00:01:06.740 --> 00:01:09.900
which is the controller
that most everybody uses

00:01:09.900 --> 00:01:11.660
at least once in their app.

00:01:11.660 --> 00:01:14.450
We'll also talk about
Tiger's new tree controller.

00:01:14.690 --> 00:01:17.000
And then Andreas is
going to come on stage,

00:01:17.000 --> 00:01:21.270
and he'll bring up a list
of advanced topics related

00:01:21.420 --> 00:01:25.110
to master-detail interfaces,
binding up selections,

00:01:25.120 --> 00:01:30.210
like if anybody's had trouble
binding pop-up buttons.

00:01:30.290 --> 00:01:33.530
We'll also talk about
target and action bindings,

00:01:33.730 --> 00:01:35.560
target argument bindings rather.

00:01:35.580 --> 00:01:37.210
And then we'll finish up the session.

00:01:37.220 --> 00:01:40.250
I'll come back and talk
about some really short,

00:01:40.360 --> 00:01:47.120
detailed topics, basically core data,
debugging, and error presentation.

00:01:48.120 --> 00:01:52.500
So I'll start off with, as I said,
the controllers,

00:01:52.540 --> 00:01:55.360
the array controllers specifically.

00:01:55.360 --> 00:01:57.760
Everybody's probably used
the array controller by now,

00:01:57.760 --> 00:01:59.100
has an idea of what it does.

00:01:59.100 --> 00:02:00.760
It controls an array of objects.

00:02:00.760 --> 00:02:05.690
And when you use the array controller,
typically you'll use at least

00:02:05.910 --> 00:02:09.340
one of these three proxies,
one of these three accessors,

00:02:09.350 --> 00:02:13.020
either arranged objects,
the selection proxy,

00:02:13.020 --> 00:02:15.510
or the selected objects array.

00:02:18.250 --> 00:02:21.440
So I'll talk about each
of these three in turn,

00:02:21.440 --> 00:02:26.430
and then also some details about how
IB actions work with the controllers,

00:02:26.430 --> 00:02:29.600
with the array controller,
and how they're new to Tiger.

00:02:29.600 --> 00:02:32.980
So first, the arranged objects proxy.

00:02:32.980 --> 00:02:37.980
If you ask an array controller
for its arranged objects,

00:02:37.980 --> 00:02:42.200
you'll get back an object
that looks like an NSArray.

00:02:42.200 --> 00:02:45.790
And I guess it's bad for me to
say it looks like an NSArray,

00:02:45.790 --> 00:02:48.060
because it really is an NSArray.

00:02:48.100 --> 00:02:52.280
But it's a special NSArray that
provides a view to the underlying

00:02:52.280 --> 00:02:54.440
content of your controller.

00:02:54.440 --> 00:02:59.340
This view can be sorted differently
from the underlying content,

00:02:59.340 --> 00:03:02.790
and can often be filtered,
so it'd be a subset of the content

00:03:02.790 --> 00:03:04.540
that your controller's managing.

00:03:04.540 --> 00:03:09.760
So you can imagine the look of it,
sort of the content underneath,

00:03:09.760 --> 00:03:13.550
and your controller in the middle,
providing you with this view,

00:03:13.550 --> 00:03:16.460
this arranged objects view
of all of your content.

00:03:19.750 --> 00:03:23.670
So when I say it's a proxy array,
that means that as you work

00:03:23.760 --> 00:03:27.970
with the array controller,
the contents of the array will change.

00:03:28.100 --> 00:03:32.470
So while you're changing the
filtering on the array controller,

00:03:32.470 --> 00:03:36.800
or if you change the sort descriptors,
if your user is pressing

00:03:36.840 --> 00:03:40.470
add and remove buttons,
or if you change the content,

00:03:40.470 --> 00:03:43.480
the binding for the content
of the controller changes,

00:03:43.530 --> 00:03:48.730
all these things will affect the
arranged objects proxy array.

00:03:48.970 --> 00:03:52.250
So that means that while you're using it,
the count could actually change,

00:03:52.250 --> 00:03:54.690
for instance,
or objected index might not be

00:03:54.690 --> 00:03:59.320
the same from one call to another.

00:03:59.360 --> 00:04:03.390
If you need this functionality where
things won't change underneath you,

00:04:03.500 --> 00:04:05.940
simply make a copy of the
arranged objects proxy.

00:04:05.940 --> 00:04:08.940
Those copies won't change underneath you.

00:04:10.300 --> 00:05:19.800
[Transcript missing]

00:05:21.300 --> 00:05:23.490
Okay, so that's arranged objects.

00:05:23.560 --> 00:05:28.070
The second proxy that I want to
talk about is the selection proxy.

00:05:30.530 --> 00:05:33.440
You ask an array controller
for its selection,

00:05:33.460 --> 00:05:34.960
and it'll return a single object.

00:05:34.960 --> 00:05:39.740
And this single object gives
you a way to do key value coding

00:05:39.940 --> 00:05:44.780
operations on all of the objects in
the array controller's selection.

00:05:44.780 --> 00:05:48.630
So that means you can do
setValueForKey or getValueForKey,

00:05:48.740 --> 00:05:52.940
just value for key, on the selection,
and it'll be interpreted based

00:05:53.270 --> 00:05:57.340
on which objects are selected
in the array controller.

00:05:58.240 --> 00:06:00.880
This also implies that it'll
handle multiple selection.

00:06:00.880 --> 00:06:05.360
And something about the selection proxy,
it's KVO compliant,

00:06:05.460 --> 00:06:10.040
so that you can actually observe
through the selection proxy.

00:06:10.040 --> 00:06:13.320
If you add yourself as an
observer for selection.name,

00:06:13.320 --> 00:06:17.250
you'll get notified any time the
controller's selection changes,

00:06:17.250 --> 00:06:21.340
or any time the name of the selected
item in the controller changes.

00:06:24.400 --> 00:06:27.770
So ordinarily, you'd see something like
this in a simple UI,

00:06:27.930 --> 00:06:28.170
right?

00:06:28.170 --> 00:06:32.440
A table view fed by an array controller
and a text field underneath fed by

00:06:32.440 --> 00:06:34.220
the selection of the array controller.

00:06:34.220 --> 00:06:39.590
In this case,
it'd be bound to selection.lastname.

00:06:39.960 --> 00:06:44.030
But what happens when there
isn't exactly one item selected

00:06:44.290 --> 00:06:46.610
in the array controller?

00:06:47.250 --> 00:06:52.790
If you were to ask selection
value for key name,

00:06:53.950 --> 00:06:57.150
The selection proxy is smart
enough to return a special marker.

00:06:57.350 --> 00:07:00.540
This is an NS controller marker.

00:07:00.540 --> 00:07:04.730
And ordinarily,
the views in AppKit handle

00:07:04.730 --> 00:07:07.660
these markers in a special way.

00:07:08.010 --> 00:07:11.620
They can convert them into
placeholders that you can

00:07:11.620 --> 00:07:14.050
specify on a per-binding basis.

00:07:14.690 --> 00:07:19.360
So if we look specifically at each case,
I don't know how well

00:07:19.360 --> 00:07:20.720
you guys can read it.

00:07:20.960 --> 00:07:24.140
In the case that there are multiple
values selected in the controller,

00:07:24.180 --> 00:07:27.020
there's a special place for
a multiple values marker.

00:07:27.020 --> 00:07:33.410
We also handle whether there's no
selection at all in the controller.

00:07:34.190 --> 00:07:40.580
And if the object that's selected doesn't
respond to the key that you're bound to,

00:07:40.580 --> 00:07:44.180
for in this case,
it doesn't return to middle name,

00:07:44.180 --> 00:07:48.300
it doesn't respond to middle name,
for instance.

00:07:48.930 --> 00:07:54.320
And also, in the case of if there's
no value at all to be had,

00:07:54.320 --> 00:07:58.350
you can set a special placeholder in
the case that nil is returned from a

00:07:58.350 --> 00:08:00.320
value-for-key call on the selection.

00:08:04.560 --> 00:08:10.900
Other cool things that work with KVC on
the selection proxy are KVC operators.

00:08:10.900 --> 00:08:12.940
You might have seen these
if you've looked at NSArray,

00:08:12.940 --> 00:08:15.500
which also supports KVC operators.

00:08:15.500 --> 00:08:19.790
This is basically asking value
for key path and using a special

00:08:20.210 --> 00:08:22.500
key starting with an @ symbol.

00:08:22.500 --> 00:08:26.480
Here I've shown the @average operator.

00:08:26.520 --> 00:08:29.060
What that'll do is go through
all of the objects that are

00:08:29.060 --> 00:08:31.450
selected in the controller,
ask for its salary,

00:08:31.490 --> 00:08:35.500
ask it for value for key salary,
and then the controller's

00:08:35.500 --> 00:08:38.750
selection proxy,
as well as any NSArray,

00:08:38.750 --> 00:08:43.500
will create an average of those salaries.

00:08:43.500 --> 00:08:45.500
Here are a couple of other
constants that we support.

00:08:45.500 --> 00:08:49.960
If you find one that's defined
on NSArray for these operators,

00:08:49.960 --> 00:08:53.450
the selection proxy
will also support this.

00:08:56.860 --> 00:08:59.260
So that's using the selection proxy.

00:08:59.270 --> 00:09:01.950
There are a couple of things
that you can do if you want

00:09:01.990 --> 00:09:05.580
to affect how the selection is
handled on the array controller.

00:09:05.590 --> 00:09:07.060
There are four flags.

00:09:07.060 --> 00:09:11.740
The first two handle basically
adding and removing cases.

00:09:11.740 --> 00:09:16.040
So selects inserted objects
and avoids empty selection.

00:09:16.040 --> 00:09:18.690
And the last two here,
preserve selection and always

00:09:18.710 --> 00:09:20.780
uses the multiple values marker.

00:09:20.780 --> 00:09:24.340
Those are important if you're
dealing with thousands,

00:09:24.340 --> 00:09:28.260
tens of thousands of objects
and large selections.

00:09:28.260 --> 00:09:33.980
I'll go over each of these in turn,
starting with selects inserted objects.

00:09:35.540 --> 00:09:39.280
If you check out IB and bring
up the attributes inspector

00:09:39.280 --> 00:09:42.580
for your array controller,
you've probably seen this flag.

00:09:42.580 --> 00:09:45.910
Selects inserted objects
does what it says.

00:09:45.910 --> 00:09:49.160
Every time an object
is added or inserted,

00:09:49.160 --> 00:09:51.970
it tries to select that new object.

00:09:53.630 --> 00:09:56.440
The next one is avoids empty selection.

00:09:56.580 --> 00:10:02.520
In this case, when the selected object is
removed from the array controller,

00:10:02.520 --> 00:10:06.070
if there's nothing left selected,
if all of the selected

00:10:06.070 --> 00:10:07.440
objects are removed,
basically,

00:10:07.440 --> 00:10:14.680
the controller will try to select the
first object in the arranged objects.

00:10:17.420 --> 00:10:22.630
The third option, Preserve Selection,
tells the controller that

00:10:22.980 --> 00:10:26.500
if your content changes,
if the controller's content changes,

00:10:26.500 --> 00:10:29.690
it should take a look at which
objects are selected before

00:10:29.850 --> 00:10:34.030
the content change happens,
and then find those objects in the new

00:10:34.030 --> 00:10:36.620
set of content that's handed to it.

00:10:36.900 --> 00:10:39.970
This is really handy for,
actually really nice

00:10:39.970 --> 00:10:43.910
for a general UI thing,
so that when somebody's working with a

00:10:44.000 --> 00:10:47.870
specific object in your array controller,
if the content changes

00:10:47.920 --> 00:10:50.410
out from underneath them,
but the same object is

00:10:50.490 --> 00:10:53.510
there in the new content,
they won't lose their place.

00:11:00.110 --> 00:11:06.330
When I say this has performance impact,
it's because for very large collections

00:11:06.330 --> 00:11:10.210
of objects and for very large selections,
this could be pretty expensive

00:11:10.250 --> 00:11:13.990
since we're scanning through the
whole new content array trying to

00:11:13.990 --> 00:11:16.460
find the exact selected objects.

00:11:16.520 --> 00:11:19.060
So if you turn this off,
you might find you'll get a

00:11:19.060 --> 00:11:21.420
performance boost for very,
very large tens,

00:11:21.520 --> 00:11:25.440
hundreds of thousands of objects
in your array controller.

00:11:27.060 --> 00:11:30.300
And the fourth flag I want to
talk about is the Always Uses

00:11:30.380 --> 00:11:32.690
Multiple Values marker.

00:11:32.940 --> 00:11:37.340
With this turned on,
asking the selection proxy

00:11:37.660 --> 00:11:41.950
value for key path for some key,
some key path,

00:11:43.110 --> 00:11:47.880
If there are multiple objects selected,
that value for key call will always

00:11:47.880 --> 00:11:49.780
return the multiple values marker.

00:11:49.780 --> 00:11:54.830
This may seem obvious,
but normally when this is off,

00:11:54.830 --> 00:11:58.520
the selection proxy tries to figure out,
well, what are the values for

00:11:58.520 --> 00:11:59.860
each selected object?

00:11:59.860 --> 00:12:03.450
So it'll go through every object that's
selected in the array controller,

00:12:03.890 --> 00:12:07.360
getting its value for key,
and if they happen to match,

00:12:07.510 --> 00:12:09.800
if everybody that's selected
has the same first name,

00:12:09.800 --> 00:12:13.470
for example,
then it'll return that common name.

00:12:13.480 --> 00:12:17.860
And again, the performance impact
of this should be clear.

00:12:17.860 --> 00:12:20.430
We're going to go through
every object doing a value for

00:12:20.580 --> 00:12:22.080
key operation and comparing.

00:12:22.080 --> 00:12:27.720
So turning this on, turning this flag on,
could save you a lot of time when

00:12:27.900 --> 00:12:31.580
you're dealing with large selections
and lots and lots of content objects.

00:12:34.660 --> 00:12:36.860
So that's influencing selection.

00:12:37.110 --> 00:12:41.510
The third accessor I want to talk
about is the selected objects accessor.

00:12:42.480 --> 00:12:48.420
Asking an array controller for its
selected objects returns just a plain

00:12:48.490 --> 00:12:52.020
array of objects corresponding to
all of the objects that are selected.

00:12:52.040 --> 00:12:54.110
Pretty plain.

00:12:54.680 --> 00:12:57.770
Now this is important because
this is a regular array with

00:12:57.960 --> 00:12:59.400
real content objects in them.

00:12:59.400 --> 00:13:01.570
It's not a proxy.

00:13:03.720 --> 00:13:08.210
And so it differs in functionality
from the selection proxy,

00:13:08.300 --> 00:13:13.360
since this is really useful for handing
off to worker classes or worker methods

00:13:13.750 --> 00:13:20.490
or using in the target argument bindings
or for master-detail interfaces.

00:13:21.730 --> 00:13:25.140
But since it is different
from the selection proxy,

00:13:25.160 --> 00:13:28.950
it's important to note that you
shouldn't bind or observe through

00:13:29.130 --> 00:13:31.690
the selected objects accessor.

00:13:31.750 --> 00:13:35.490
It's much cheaper,
it's much faster to bind or observe

00:13:35.490 --> 00:13:37.860
through the selection proxy.

00:13:37.960 --> 00:13:41.730
So to give you an idea,
binding to just selected

00:13:41.730 --> 00:13:45.440
objects to find out when all of
the selected objects changes,

00:13:45.500 --> 00:13:47.130
that's fine.

00:13:47.310 --> 00:13:51.630
But binding or observing selected
objects dot name can be way more

00:13:51.630 --> 00:13:56.540
expensive than simply binding
or observing selection dot name.

00:13:59.230 --> 00:14:00.800
Okay, so those are the accessors.

00:14:00.800 --> 00:14:03.780
And the last thing I want to
talk about specific to the

00:14:03.780 --> 00:14:05.650
array controller are IB actions.

00:14:05.670 --> 00:14:09.910
I've had a lot of people asking
about this case where they've,

00:14:09.910 --> 00:14:13.640
in their code,
gone through and changed the way,

00:14:13.640 --> 00:14:16.600
or I'm sorry,
and added an object to the array

00:14:17.040 --> 00:14:21.520
controller programmatically,
calling like array controller add colon.

00:14:23.060 --> 00:14:25.630
And I think that's something
to note using these add,

00:14:25.630 --> 00:14:27.250
insert, and remove actions.

00:14:27.290 --> 00:14:29.800
In Tiger,
all of these are performed delayed,

00:14:29.860 --> 00:14:39.470
so you won't see the effect directly
in your code after calling them.

00:14:39.610 --> 00:14:39.610
It's best to use, oh, actually,
wrong slide.

00:14:39.970 --> 00:14:45.540
I want to mention can add, can insert,
and can remove quickly.

00:14:45.590 --> 00:14:49.800
These are really nice for binding up
UIs to make sure that you can only add,

00:14:49.800 --> 00:14:52.730
remove, or insert when the controller
thinks it's correct.

00:14:52.950 --> 00:14:58.530
So if there's no selection,
then you shouldn't have

00:14:58.630 --> 00:15:00.370
your remove button enabled.

00:15:03.120 --> 00:15:09.060
Okay, and here you can see I have a
UI where I've bound the remove

00:15:09.060 --> 00:15:15.990
buttons enabled binding to the
controller's can remove controller key.

00:15:18.190 --> 00:15:21.100
This is what I had wanted to
talk about in the first place.

00:15:21.100 --> 00:15:24.600
Yes, IB actions are performed delayed
for all of the controllers.

00:15:24.600 --> 00:15:27.580
This is new in Tiger,
and this is because we want to be

00:15:27.580 --> 00:15:31.090
able to present sheets when something
goes wrong during these actions.

00:15:31.100 --> 00:15:36.270
So if you want to do an add or
insert or remove in your code,

00:15:36.340 --> 00:15:41.970
it's better and much more
performant to use these methods.

00:15:42.490 --> 00:15:46.510
You can simply call add object,
insert object at arranged object index,

00:15:46.690 --> 00:15:49.500
remove object at arranged object index.

00:15:49.500 --> 00:15:52.170
There are multiple,
there's a singular and a plural

00:15:52.170 --> 00:15:53.630
version of each of these.

00:15:53.640 --> 00:15:58.710
And you should know that the controllers
are optimized for these cases as far

00:15:58.820 --> 00:16:01.360
as when content underneath changes.

00:16:01.360 --> 00:16:05.410
So it's better for you to call these
methods on the array controller than it

00:16:05.550 --> 00:16:08.820
is to take the underlying content array,
mutate it,

00:16:08.970 --> 00:16:10.600
and then send a KVO notification.

00:16:11.450 --> 00:16:14.050
We'll do much less work if
you simply tell us directly,

00:16:14.050 --> 00:16:15.760
I want to add or remove an object.

00:16:17.910 --> 00:16:20.200
Okay,
so to recap on the array controller,

00:16:20.200 --> 00:16:27.440
something that I skipped actually,
even though the arranged objects

00:16:27.440 --> 00:16:31.300
proxy is liable to change as you
work with the array controller,

00:16:31.300 --> 00:16:33.720
don't think that you
should mutate it directly.

00:16:33.720 --> 00:16:35.340
It's not a mutable array.

00:16:35.340 --> 00:16:39.680
So never try to mutate the
arranged objects proxy.

00:16:41.180 --> 00:16:44.010
And similarly,
you should note that mutating

00:16:44.120 --> 00:16:48.260
the underlying content,
you really have to send a notification

00:16:48.260 --> 00:16:51.420
so that the array controller knows
that you've changed something.

00:16:51.440 --> 00:16:54.090
Otherwise, you're making changes behind
the array controller's back

00:16:54.090 --> 00:16:55.320
and it can't keep up with you.

00:16:55.320 --> 00:16:59.170
And something else to note,
when you're putting together your

00:16:59.170 --> 00:17:03.280
model objects that you're going
to put in your array controller,

00:17:03.280 --> 00:17:06.900
if you're going to bind to some
property on these model objects,

00:17:06.910 --> 00:17:09.190
it really needs to be KVO compliant.

00:17:09.200 --> 00:17:11.560
Otherwise, things will... go wrong.

00:17:13.690 --> 00:17:16.950
Further recap, remember,
selected objects,

00:17:16.950 --> 00:17:21.280
binding through selected
objects is a bad idea.

00:17:21.280 --> 00:17:23.590
Binding through selection
is a better option.

00:17:23.600 --> 00:17:25.550
Same thing with content.

00:17:25.590 --> 00:17:29.740
When I say that you shouldn't
bind or observe the content,

00:17:29.740 --> 00:17:33.600
or through the content
accessor on the controller,

00:17:33.610 --> 00:17:35.940
that's different from
when I say binding to,

00:17:35.940 --> 00:17:38.600
or binding the content
of the array controller.

00:17:38.600 --> 00:17:41.750
That of course is totally supported,
totally fine.

00:17:43.150 --> 00:17:45.100
Okay, so that's the array controller.

00:17:45.100 --> 00:17:47.100
Huh, thirsty.

00:17:47.100 --> 00:17:51.540
Next I want to talk about the
object and the tree controller.

00:17:56.150 --> 00:17:59.180
The slide I have for the object
controller is pretty simple.

00:17:59.400 --> 00:18:03.900
But first, the controllers in general,
you should feel comfortable

00:18:03.900 --> 00:18:06.130
using the object,
the array, and the tree controller.

00:18:06.310 --> 00:18:09.380
They all kind of have the
same design principles.

00:18:09.380 --> 00:18:13.130
You'll find selection on
all of these controllers.

00:18:13.210 --> 00:18:15.820
The array and the tree controller
have an arranged objects proxy,

00:18:15.820 --> 00:18:18.120
and these all work pretty much the same.

00:18:18.150 --> 00:18:23.410
And similarly for IB actions,
all of the actions for all of these

00:18:23.410 --> 00:18:25.270
controllers are performed delayed.

00:18:25.340 --> 00:18:29.780
So with that,
thinking about the object controller,

00:18:29.900 --> 00:18:31.560
something to note,
the object controller is

00:18:31.560 --> 00:18:35.550
the superclass for the array
controller and the tree controller.

00:18:35.850 --> 00:18:39.220
But it just manages a
single content object.

00:18:39.340 --> 00:18:43.400
It's most useful when you're putting
together master-detail interfaces.

00:18:43.540 --> 00:18:48.780
You can use it as a proxy
for another object in IB.

00:18:48.850 --> 00:18:51.120
So simple class.

00:18:51.230 --> 00:18:54.460
When we talk about the tree controller,
it, of course, manages a tree.

00:18:54.460 --> 00:18:57.050
It manages a tree of objects.

00:18:57.140 --> 00:19:00.980
This is a little different
from the way you work with the

00:19:00.980 --> 00:19:05.000
array controller and NSArrays,
since we don't have an

00:19:05.000 --> 00:19:07.170
NS tree class in Cocoa.

00:19:07.210 --> 00:19:11.380
So instead, we ask you to simply
configure the tree controller,

00:19:11.430 --> 00:19:14.690
telling it how to traverse
your tree of objects.

00:19:16.020 --> 00:19:19.470
So again, the Tree Controller uses an
Arranged Objects Accessor.

00:19:19.480 --> 00:19:24.540
It has a selection accessor that works
just the same as the Array Controllers.

00:19:24.600 --> 00:19:27.770
And its primary use, though,
is to display objects in an

00:19:27.770 --> 00:19:29.600
Outline View or an NS Browser.

00:19:29.810 --> 00:19:34.390
It's really there just for Outline
View and browsers to be bound to.

00:19:35.990 --> 00:19:39.480
And when you're using the NS3
controller with an outline view,

00:19:39.480 --> 00:19:44.440
it should feel just like binding a
table view to an array controller.

00:19:44.570 --> 00:19:48.120
Similar thing with the way
sort descriptors are applied.

00:19:50.130 --> 00:19:54.370
So about that configuration thing,
all you have to do is tell us

00:19:54.460 --> 00:20:00.140
the key path to follow for all
child objects in your tree,

00:20:00.230 --> 00:20:02.380
in your object graph.

00:20:02.440 --> 00:20:04.660
Optionally,
you can tell us about whether or

00:20:04.690 --> 00:20:13.220
not a special object is a leaf node,
or you can return the count of the number

00:20:13.220 --> 00:20:16.680
of children of a particular object.

00:20:17.130 --> 00:20:21.620
When you give us the key paths that we
should use when traversing your tree,

00:20:21.770 --> 00:20:24.790
you just set them up
in Interface Builder.

00:20:24.960 --> 00:20:28.100
The children key path is
the one that's required.

00:20:28.140 --> 00:20:32.640
But if you give us more information,
we can do more for you as far

00:20:32.640 --> 00:20:36.490
as how to display things in the
outline view or the browser.

00:20:38.160 --> 00:20:41.280
I want to talk a little bit more
about each of these key paths.

00:20:41.360 --> 00:20:46.700
So you just set the key path in the tree
controller as which key path to use,

00:20:46.770 --> 00:20:47.540
right?

00:20:47.660 --> 00:20:53.280
So we assume that all of the objects
in your tree respond to this key path.

00:20:53.300 --> 00:20:55.950
And it is a key path, not just a key.

00:20:56.240 --> 00:20:58.140
And yes, it is really required.

00:20:58.260 --> 00:21:04.430
If you see an error saying
so-and-so couldn't work with,

00:21:04.470 --> 00:21:07.880
work without a children keypath set,
then you've forgotten

00:21:07.930 --> 00:21:09.280
to set this keypath.

00:21:09.780 --> 00:21:12.590
And the easiest thing to do is
usually just to write a category,

00:21:12.590 --> 00:21:15.580
or if you have the source,
to write a simple accessor,

00:21:15.690 --> 00:21:20.250
a cover method,
to return objects based on this key.

00:21:21.860 --> 00:21:26.720
If by design certain objects aren't
supposed to have child objects,

00:21:26.800 --> 00:21:30.500
you can use the
isLeafKeyPath and set that.

00:21:31.020 --> 00:21:34.310
What Isleaf does,
the Isleaf keypath being set,

00:21:34.330 --> 00:21:39.090
prevents the tree controller
from snooping for child objects.

00:21:40.810 --> 00:21:45.570
If an object returns yes
for is leaf key path,

00:21:45.640 --> 00:21:50.640
value for key, this leaf key path,
then we won't ask for child objects.

00:21:50.640 --> 00:21:54.040
It is totally optional,
but you might want to use it just

00:21:54.040 --> 00:21:58.640
so you can customize the way that
the outline view or the browser

00:21:58.640 --> 00:21:59.860
shows disclosure triangles.

00:21:59.860 --> 00:22:02.410
You can see the logic here.

00:22:02.420 --> 00:22:03.280
It's pretty simple.

00:22:03.280 --> 00:22:06.400
If it's a leaf, then we'll never show
a disclosure triangle,

00:22:06.420 --> 00:22:09.490
but if it's not,
we'll always show a disclosure triangle.

00:22:10.560 --> 00:22:14.040
While this takes precedence,
you can also set the count key

00:22:14.140 --> 00:22:15.580
path for the tree controller.

00:22:15.620 --> 00:22:18.360
And this way,
you can return the number of objects

00:22:18.500 --> 00:22:23.840
that are the children of a given object.

00:22:23.890 --> 00:22:27.470
This also affects the way disclosure
triangles are displayed in the

00:22:27.470 --> 00:22:29.450
outline view or the NS Browser.

00:22:29.650 --> 00:22:33.360
Basically, it's make sure that the number
of children is greater than zero.

00:22:33.410 --> 00:22:36.160
Then it will always show
a disclosure triangle.

00:22:37.220 --> 00:22:41.870
Side note that because you're
telling us explicitly how many

00:22:41.870 --> 00:22:47.780
objects there are as a child,
as children for an object, this

00:22:48.310 --> 00:22:53.260
Setting the count key path tells the tree
controller not to ever enable the add,

00:22:53.260 --> 00:22:55.410
insert, or remove actions.

00:22:55.490 --> 00:22:59.070
This prevents what the tree
controller thinks should be true

00:22:59.250 --> 00:23:03.940
from being out of sync with what's
actually true in your model objects.

00:23:05.190 --> 00:23:06.590
Okay.

00:23:06.690 --> 00:23:09.900
And IB actions for the
NS Tree Controller,

00:23:09.900 --> 00:23:13.660
we've added add child
as well as insert child.

00:23:13.660 --> 00:23:17.080
These go along with the add, remove,
and insert actions that you're familiar

00:23:17.080 --> 00:23:19.560
with on the NSArray Controller.

00:23:19.740 --> 00:23:24.830
And we've also added the enabling keys
for can-add-child and can-insert-child.

00:23:24.840 --> 00:23:30.100
So let's do a quick demo.

00:23:30.100 --> 00:23:34.810
Let's have IB running.

00:23:35.000 --> 00:23:41.030
Create a new nib.

00:23:46.650 --> 00:23:50.600
I just want to show you how to
set up a tree controller briefly.

00:23:50.600 --> 00:23:58.690
So here I set the children keypath.

00:24:02.300 --> 00:24:08.310
We'll add an outline view,
resize our window.

00:24:13.480 --> 00:24:16.920
So again,
it's supposed to feel a lot like binding

00:24:16.920 --> 00:24:19.260
a table view to an array controller.

00:24:19.570 --> 00:24:24.210
So you simply go to your
outline views column bindings.

00:24:24.650 --> 00:24:34.510
Bind its value, let's say name,
let's say here diameter.

00:24:34.610 --> 00:24:37.200
And we can also drag in a browser.

00:24:41.130 --> 00:24:44.070
And the browser bindings
are a little different from

00:24:44.080 --> 00:24:46.780
those for the outline view,
since there's always just one

00:24:46.780 --> 00:24:48.730
value shown inside the browser.

00:24:48.950 --> 00:24:53.380
So we'll bind the content to the
tree controller's arranged objects.

00:24:54.130 --> 00:24:56.690
The content values will
be Tree Controller,

00:24:56.800 --> 00:25:00.590
Arranged Objects,
and then the value we want to display.

00:25:02.390 --> 00:25:06.930
And then we'll bind the selection index
paths of the browser to the selection

00:25:06.930 --> 00:25:09.970
index paths of the tree controller.

00:25:12.310 --> 00:25:17.950
And let's add some buttons
so we can actually add stuff.

00:25:25.200 --> 00:25:26.500
And we can connect these.

00:25:26.500 --> 00:25:29.540
You see here we have Add,
just like the ArrayController has.

00:25:29.910 --> 00:25:32.490
And then there's Add Child.

00:25:34.340 --> 00:25:38.400
And yeah, I think that's it.

00:25:38.590 --> 00:25:40.370
Let's try that.

00:25:44.400 --> 00:25:48.280
So you see there's no disclosure triangle
here because our logic simply says,

00:25:48.420 --> 00:25:50.510
well, there aren't any child objects.

00:25:50.640 --> 00:25:57.610
So not until we actually add one
will we show a disclosure triangle.

00:25:57.900 --> 00:26:02.280
Let's see, and if you watch here,
you can do lots of

00:26:02.280 --> 00:26:04.870
selection handling here.

00:26:04.900 --> 00:26:07.900
You can add lots of child objects.

00:26:07.900 --> 00:26:14.900
We all keep everything in
sync between these two.

00:26:14.900 --> 00:26:18.900
Let's see, let's add one last thing.

00:26:18.900 --> 00:26:24.900
Talking about the selection proxy.

00:26:29.450 --> 00:26:34.300
Using the display pattern value,
I'll go through the selection diameter.

00:26:34.300 --> 00:26:45.810
So I can give you an
idea of how this works.

00:26:49.330 --> 00:26:54.820
Oh, I have to turn on
multiple selection first?

00:26:54.870 --> 00:26:55.240
Sorry.

00:26:55.240 --> 00:26:55.940
Okay.

00:26:55.940 --> 00:26:57.000
There we go.

00:27:03.570 --> 00:27:06.000
So complex math, all in IB.

00:27:06.150 --> 00:27:08.780
It's a fantastic thing.

00:27:08.780 --> 00:27:10.850
And that's it.

00:27:14.600 --> 00:27:20.100
Andreas will come up and talk a little
bit more about advanced binding configs.

00:27:27.670 --> 00:27:29.260
So good afternoon.

00:27:29.260 --> 00:27:31.780
My name is Andreas Wendker,
and I manage the Xcode

00:27:31.780 --> 00:27:33.930
and Core Data frameworks.

00:27:34.580 --> 00:27:36.840
The vast majority of bindings
that you use in an application

00:27:36.840 --> 00:27:38.000
are pretty straightforward.

00:27:38.000 --> 00:27:41.940
You bind some kind of property of a
view to some property of a model object.

00:27:41.980 --> 00:27:45.820
So let's say the value of a text
field to the name of a person.

00:27:45.820 --> 00:27:49.420
But to get the most out of bindings
for the more complicated cases,

00:27:49.420 --> 00:27:52.910
you often have to use combinations
of multiple bindings and a variety of

00:27:53.000 --> 00:27:55.740
options for these bindings to really get,
you know,

00:27:55.740 --> 00:27:57.780
to unleash the full power of bindings.

00:27:57.780 --> 00:28:01.110
So I want to focus on three topics:
master-detail interfaces,

00:28:01.110 --> 00:28:05.210
selection control bindings,
and and target argument bindings.

00:28:05.930 --> 00:28:09.080
Let's start with master-detail bindings.

00:28:09.100 --> 00:28:11.860
So what is a master-detail interface?

00:28:11.940 --> 00:28:16.100
A master-detail interface is a situation
where you have two types of model

00:28:16.100 --> 00:28:18.800
objects that are related to each other.

00:28:18.800 --> 00:28:21.810
And you partition your user interface
in a way that you have one part in

00:28:21.810 --> 00:28:25.870
the UI that is responsible for showing
information about one type of object.

00:28:26.110 --> 00:28:29.720
You have a second part that is
responsible for showing information

00:28:29.720 --> 00:28:31.280
about the other type of object.

00:28:31.330 --> 00:28:35.550
And you're making the content of
that second part dependent on what

00:28:35.550 --> 00:28:37.260
is selected in the first part.

00:28:37.260 --> 00:28:39.390
So essentially,
you have a UI that you see

00:28:39.390 --> 00:28:43.620
objects through a relationship
of a selected root object.

00:28:45.500 --> 00:28:48.640
So just to give you some examples
that you might be familiar with.

00:28:48.640 --> 00:28:50.840
In Xcode,
there's a groups and files view,

00:28:50.840 --> 00:28:53.400
and if you select a group,
you see the files in that

00:28:53.400 --> 00:28:54.370
group in the list view.

00:28:54.550 --> 00:28:56.740
That's what we would call
a master-detail interface.

00:28:56.740 --> 00:28:59.550
Other examples are the
iTunes playlists view,

00:28:59.550 --> 00:29:03.740
where you select a playlist and you
see the different kind of songs.

00:29:03.810 --> 00:29:06.840
In Mail,
the mailboxes and the messages view.

00:29:06.840 --> 00:29:11.260
And in the core recipes application,
which is the example we used

00:29:11.320 --> 00:29:15.480
throughout all the core data
sessions at this conference,

00:29:15.480 --> 00:29:16.700
the groups and recipes.

00:29:16.750 --> 00:29:20.660
All these are good examples for what
we call master-detail interfaces.

00:29:22.110 --> 00:29:24.000
So how do you set them up with bindings?

00:29:24.020 --> 00:29:25.960
How do you solve this kind
of problem with bindings?

00:29:25.960 --> 00:29:27.570
It's actually pretty straightforward.

00:29:27.580 --> 00:29:29.360
You use two kinds of controllers.

00:29:29.360 --> 00:29:31.710
One we call the master controller,
the other one we call

00:29:31.710 --> 00:29:32.840
the detail controller.

00:29:32.840 --> 00:29:36.550
And then you just make the content of
the detail controller dependent on the

00:29:37.140 --> 00:29:38.880
selection of the master controller.

00:29:38.880 --> 00:29:43.310
And you simply do that by binding the
content of the detail controller to a key

00:29:43.310 --> 00:29:47.010
path like selection.yourrelationshipkey.

00:29:47.020 --> 00:29:48.870
That's pretty much all you have to do.

00:29:49.420 --> 00:29:51.660
And then what happens is that
the detail controller starts

00:29:51.820 --> 00:29:54.800
displaying what's in the relationship
of the selected root object.

00:29:54.820 --> 00:29:57.160
And not only does it
display it correctly,

00:29:57.160 --> 00:30:00.600
if you insert or remove objects
in the detail controller,

00:30:00.600 --> 00:30:02.550
it will actually mutate the relationship.

00:30:02.560 --> 00:30:06.820
So with the two controllers and
the content binding in between,

00:30:06.820 --> 00:30:09.300
you can fully display and
edit relationships between

00:30:09.330 --> 00:30:10.840
different types of objects.

00:30:14.620 --> 00:30:16.810
The type of content bindings you
find on the controllers depend

00:30:16.920 --> 00:30:18.000
on the type of the controller.

00:30:18.000 --> 00:30:21.030
Not every controller has all the
content bindings I list on this slide.

00:30:21.200 --> 00:30:24.940
But basically, depending on the type,
you find three types of content bindings.

00:30:25.080 --> 00:30:27.610
And they're just there
for three different types,

00:30:27.690 --> 00:30:30.240
or three different ways of
organizing your model objects.

00:30:30.240 --> 00:30:32.960
So depending on what type
of relationship you have,

00:30:33.110 --> 00:30:35.810
you use a different
kind of content binding.

00:30:36.460 --> 00:30:38.980
For ordered-to-many relationships,
relationships that are

00:30:38.980 --> 00:30:42.270
represented as NSArrays,
use the content array binding.

00:30:42.320 --> 00:30:45.340
For unordered relationships,
unordered-to-many relationships,

00:30:45.340 --> 00:30:48.100
which by the way are the ones that
Core Data is supporting right now,

00:30:48.110 --> 00:30:49.820
use the content set binding.

00:30:49.820 --> 00:30:52.400
And for to-one relationships,
use the content object binding.

00:30:52.400 --> 00:30:54.510
It's all pretty straightforward.

00:30:55.260 --> 00:30:59.160
One thing that you might wonder about is
that if you know our controller classes,

00:30:59.200 --> 00:31:01.590
you know that we have
controllers for single objects,

00:31:01.640 --> 00:31:02.980
for arrays, and for trees.

00:31:03.190 --> 00:31:04.730
We don't have a controller for a set.

00:31:04.920 --> 00:31:06.560
There's no NSSet controller.

00:31:06.580 --> 00:31:09.260
Instead, you have a content set binding
on the array controller.

00:31:09.260 --> 00:31:10.620
Why is that?

00:31:10.710 --> 00:31:13.480
Well, the answer is that whenever
you go into the UI,

00:31:13.670 --> 00:31:16.860
you really want to have some kind
of a stable order for the objects.

00:31:16.950 --> 00:31:19.940
It's really terrible for the user
to see a UI where the order of

00:31:19.940 --> 00:31:22.080
the objects constantly changes.

00:31:22.080 --> 00:31:24.830
So the first thing you want to do
if you have an unordered chip is

00:31:24.830 --> 00:31:27.780
you want to apply some sort order
for it and then stick with it.

00:31:27.780 --> 00:31:29.740
And that's what the array
controller gives us.

00:31:29.740 --> 00:31:32.440
If you bind to a set and you
populate the controller with a set,

00:31:32.630 --> 00:31:35.490
then it will just put it in a
fixed order and will try to keep

00:31:35.490 --> 00:31:37.820
that order as stable as possible.

00:31:40.320 --> 00:31:41.630
Let's look at how this looks in IB.

00:31:41.770 --> 00:31:45.600
So what you see here on the screen is
a typical Nib file with one window.

00:31:45.640 --> 00:31:48.910
And on the left side in that window,
you see an outline view for groups.

00:31:49.070 --> 00:31:52.040
And on the right side of that window,
you see a table view, let's say,

00:31:52.040 --> 00:31:52.880
for recipes.

00:31:52.880 --> 00:31:55.360
And then in the file window down there,
you see that there are

00:31:55.380 --> 00:31:58.050
also two controllers,
a tree controller for the groups and

00:31:58.050 --> 00:32:00.450
an array controller for the recipes.

00:32:02.440 --> 00:32:06.670
What you see in the inspector there
right now is the content binding

00:32:06.670 --> 00:32:08.520
of the recipes detail controller.

00:32:08.590 --> 00:32:10.560
And as you can see,
it's bound to the groups controller

00:32:10.970 --> 00:32:13.260
with the key path selection.recipes.

00:32:13.320 --> 00:32:18.470
So our recipes controller always shows
all the recipes selected in that group,

00:32:18.580 --> 00:32:21.010
all the recipes of the selected group.

00:32:23.830 --> 00:32:26.900
And then what the screen
doesn't really show you is that,

00:32:26.900 --> 00:32:28.500
of course,
you would have additional bindings

00:32:28.950 --> 00:32:31.470
for the right side of that window
that shows the recipes that

00:32:31.560 --> 00:32:32.660
go to the recipes controller.

00:32:32.660 --> 00:32:35.070
And you would have additional
bindings from the tree view

00:32:35.070 --> 00:32:36.390
to the groups controller.

00:32:41.380 --> 00:32:44.050
So one interesting case that you
will probably encounter is that

00:32:44.060 --> 00:32:48.390
the user might select multiple
objects in the master controller.

00:32:48.640 --> 00:32:51.960
And if you followed what Ron said
about the selection proxy,

00:32:51.980 --> 00:32:55.500
then you know that the master
controller will then indicate

00:32:55.500 --> 00:32:59.540
multiple selections through the
multiple selection marker object.

00:32:59.540 --> 00:33:01.950
So when the detail controller
asks for its content,

00:33:01.950 --> 00:33:05.520
then all it gets is a marker object,
and it really doesn't know what to do.

00:33:05.540 --> 00:33:08.220
So by default,
you just empty the detail controller.

00:33:08.220 --> 00:33:10.590
But we can do a lot better
if you help it a little bit.

00:33:10.620 --> 00:33:14.090
There's a second binding that is
an alternative binding for the

00:33:14.200 --> 00:33:16.700
multi-selection case that you can bind.

00:33:16.700 --> 00:33:19.600
So there's a chance for you to
provide a separate key path,

00:33:19.690 --> 00:33:22.580
a separate value transformer,
or the other types of options

00:33:22.680 --> 00:33:25.260
you find on bindings just for
this multiple selection case.

00:33:26.830 --> 00:33:29.950
And why this is so nice is,
the reason why this is so

00:33:29.950 --> 00:33:34.820
nice is that for the arrays,
like Ron also mentioned already before,

00:33:34.820 --> 00:33:39.800
we have operators that you can put in the
key path to do something with the values.

00:33:39.820 --> 00:33:43.380
And there are a bunch of interesting
operators for this case here,

00:33:43.380 --> 00:33:45.200
which are listed in the table.

00:33:45.200 --> 00:33:47.330
And I won't read them
all to you in detail,

00:33:47.330 --> 00:33:51.040
but essentially they are operators
to form a union of multiple arrays,

00:33:51.040 --> 00:33:52.150
of multiple sets.

00:33:52.940 --> 00:33:56.630
So what you can do is you can just
take all these selected recipes

00:33:56.650 --> 00:33:59.930
of all groups and form them all
together in one large array that's

00:33:59.930 --> 00:34:01.340
then used for the detail controller.

00:34:01.340 --> 00:34:03.360
Let me give you a
concrete example of that.

00:34:03.400 --> 00:34:08.620
So like before, we would bind the content
set to selection.recipes,

00:34:08.620 --> 00:34:12.220
and the second binding,
content array for multiple selection,

00:34:12.220 --> 00:34:17.530
we would bind to
selection.atUnionOfSets.recipes.

00:34:17.540 --> 00:34:20.980
So now even in the multi-selection case,
you still have a good array that you can

00:34:20.980 --> 00:34:22.910
use to populate the detail controller.

00:34:22.940 --> 00:34:23.940
Thank you.

00:34:35.360 --> 00:34:41.150
There are two more options that I'd like
to point you to for the content bindings.

00:34:41.410 --> 00:34:45.720
and one is called Handles
Content as Compound Value.

00:34:45.740 --> 00:34:48.640
The other one is called
Selects All in Setting Content.

00:34:48.670 --> 00:34:52.080
And those two options are a little
bit on the complicated side,

00:34:52.080 --> 00:34:55.200
so I try to cover them
with one slide each.

00:34:55.370 --> 00:34:58.600
For the first one,
Handles Content as Compound Value.

00:34:58.620 --> 00:35:02.430
That option is typically used
when you have a value transformer

00:35:02.530 --> 00:35:04.140
on your content binding.

00:35:04.260 --> 00:35:05.400
Why would you do that?

00:35:05.470 --> 00:35:08.960
Well, sometimes you want to edit
something as an array in the table

00:35:08.960 --> 00:35:12.630
view with an array controller,
but you are not actually storing the

00:35:12.630 --> 00:35:14.900
data as an array on the master object.

00:35:14.900 --> 00:35:19.320
I've seen people using value
transformers to take an NSDictionary and

00:35:19.380 --> 00:35:21.900
transform the dictionary,
the key value pairs of the dictionary,

00:35:21.900 --> 00:35:24.900
into an array of individual line
items that are then displayed

00:35:24.900 --> 00:35:26.880
and added in an array controller.

00:35:27.070 --> 00:35:29.500
Other things I've seen is that
people are just archiving the

00:35:29.500 --> 00:35:33.390
entire array and storing it as
an NSData on the master object.

00:35:33.800 --> 00:35:38.080
So the display part of that
works just fine without any help.

00:35:38.130 --> 00:35:41.300
You just use the value transformer,
you apply it to the entire content,

00:35:41.300 --> 00:35:43.520
you get an array,
you can display everything.

00:35:43.750 --> 00:35:46.500
Now for the editing part,
the array controller will

00:35:46.590 --> 00:35:50.400
actually try to mutate the
relationship in the intended way,

00:35:50.430 --> 00:35:54.580
which is to use the key value
coding array mutator objects.

00:35:54.600 --> 00:35:58.180
So it will ask the master object
mutable array value for key,

00:35:58.210 --> 00:36:01.960
which gives us an array proxy
to mutate the relationship.

00:36:02.000 --> 00:36:04.420
And then we'll start inserting
and removing and adding

00:36:04.420 --> 00:36:06.590
objects to that array.

00:36:07.070 --> 00:36:09.080
Unfortunately,
if you don't store the data as

00:36:09.080 --> 00:36:12.060
an array on the master object,
that will, of course, fail.

00:36:12.130 --> 00:36:15.480
So with this option here,
Handles Content as Compound Value,

00:36:15.540 --> 00:36:18.660
you can force the controller to
bypass the normal relationship

00:36:18.680 --> 00:36:22.290
manipulation mechanism and instead
just use simple set and get methods,

00:36:22.290 --> 00:36:24.440
just normal key-value coding,
just set value for key

00:36:24.440 --> 00:36:25.560
and get value for key.

00:36:25.640 --> 00:36:27.440
So then what happens is
that the entire array,

00:36:27.550 --> 00:36:30.850
the entire content, if it's mutated,
is taking its sense of the value

00:36:30.910 --> 00:36:35.090
transformer and just a simple set
invocation on the master object.

00:36:35.310 --> 00:36:38.020
So the rule of thumb is pretty
much whenever you use a value

00:36:38.060 --> 00:36:41.570
transformer for the content binding,
you want to set this option.

00:36:45.980 --> 00:36:48.320
The other one is selects
all when setting content.

00:36:48.480 --> 00:36:50.060
The name is actually pretty obvious.

00:36:50.100 --> 00:36:53.770
All it does is that whenever the
controller is populated with new objects,

00:36:53.770 --> 00:36:55.440
it will select them all.

00:36:55.500 --> 00:36:57.880
And this is useful in a
variety of situations.

00:36:57.900 --> 00:37:01.280
And the most common one is probably
when you write an inspector.

00:37:01.420 --> 00:37:04.220
So let's say you're in an
application like Sketch.

00:37:04.260 --> 00:37:08.000
You have multiple documents open,
and each document has a bunch

00:37:08.090 --> 00:37:11.140
of graphics objects that you
want to edit in an inspector.

00:37:11.170 --> 00:37:13.560
And you want to, of course,
allow editing multiple graphics

00:37:13.560 --> 00:37:15.460
objects at the same time.

00:37:15.530 --> 00:37:18.310
So what you would probably do is
you would go into Interface Builder,

00:37:18.440 --> 00:37:22.690
create a new Nib file,
and start creating your inspector window.

00:37:22.730 --> 00:37:25.690
So you'd place text fields
for the x and y coordinates.

00:37:25.790 --> 00:37:27.970
You would put text fields
for width and height.

00:37:28.220 --> 00:37:30.400
And you place an array
controller in that window,

00:37:30.410 --> 00:37:34.150
or in that Nib file,
to which you bind the text fields.

00:37:35.190 --> 00:37:38.130
And then essentially what you do
is that you just need to make sure

00:37:38.490 --> 00:37:41.800
that the array controller is always
populated with all the selected

00:37:41.800 --> 00:37:45.330
objects in the current main window,
in the current document.

00:37:46.300 --> 00:37:50.240
And then together with this option here,
the controller will make sure that

00:37:50.240 --> 00:37:52.760
all the objects are always selected,
which means that all the text fields

00:37:52.760 --> 00:37:55.630
that you bound to the selection
in the array controller will

00:37:55.710 --> 00:37:57.290
always edit all objects in there.

00:37:57.340 --> 00:38:00.820
So to give you the key path
that a lot of people have asked

00:38:00.950 --> 00:38:03.430
me for for this situation is,
so you're in a

00:38:03.530 --> 00:38:04.820
document-based application.

00:38:04.850 --> 00:38:07.230
You would bind to the
NSApplication object,

00:38:07.340 --> 00:38:09.760
and you would use the
key path main window,

00:38:09.760 --> 00:38:12.870
which gives you the current document,
.delegate,

00:38:12.870 --> 00:38:15.090
which is the actual NSDocument object.

00:38:15.640 --> 00:38:17.580
Let's assume that one
has a controller outlet.

00:38:17.580 --> 00:38:18.880
That's the third component.

00:38:18.880 --> 00:38:22.260
And then you just bind to the
selected objects of that controller.

00:38:22.260 --> 00:38:25.500
So the key path main window, .delegate,
.controller,

00:38:25.600 --> 00:38:28.940
.selected objects will make sure
that your array controller is

00:38:28.940 --> 00:38:33.110
always populated with the currently
selected items in the main document.

00:38:39.170 --> 00:38:42.280
Let's talk about selection
control bindings.

00:38:42.410 --> 00:38:45.660
The typical situation is that you
have some kind of pop-up button,

00:38:45.720 --> 00:38:48.530
and you want to manage the selected
item in that pop-up button,

00:38:48.530 --> 00:38:51.700
usually to modify it to one relationship.

00:38:52.030 --> 00:38:55.420
So in some form, you want to control the
selection in the pop-up,

00:38:55.560 --> 00:38:59.080
typically based on the
represented object,

00:38:59.180 --> 00:39:02.180
maybe based on the tag or the
index of the items in the pop-up,

00:39:02.220 --> 00:39:04.950
or maybe just by display value.

00:39:05.770 --> 00:39:07.810
In addition to controlling the selection,
of course, you need to make sure

00:39:07.820 --> 00:39:11.100
that the actual values,
the available choices,

00:39:11.100 --> 00:39:12.480
are populated into the pop-up button.

00:39:12.480 --> 00:39:13.740
And you can do this in two ways.

00:39:13.800 --> 00:39:16.850
You can either do it manually in IB,
just by going there and typing

00:39:16.960 --> 00:39:18.450
all the different values.

00:39:19.810 --> 00:39:23.460
More commonly,
you can dynamically set or dynamically

00:39:23.460 --> 00:39:26.160
determine the content runtime.

00:39:26.780 --> 00:39:31.020
So the bindings,
the pop-up buttons have two types

00:39:31.020 --> 00:39:32.980
of bindings to solve these problems.

00:39:33.190 --> 00:39:37.180
There's a set of selected bindings
that use to control the selected item.

00:39:37.250 --> 00:39:39.860
And there's a set of content
bindings that use to populate

00:39:39.860 --> 00:39:41.730
the available choices.

00:39:41.770 --> 00:39:44.000
And of course, all that works,
like with all the bindings

00:39:44.100 --> 00:39:45.200
for the various controls.

00:39:45.260 --> 00:39:48.640
It works with standalone controls,
so a simple NS button, pop-up button.

00:39:48.700 --> 00:39:51.010
It also works with cells and table views.

00:39:51.120 --> 00:39:54.270
So if you put a pop-up button
cell in the table view column,

00:39:54.400 --> 00:39:57.480
you can actually populate
each pop-up in each row with

00:39:57.480 --> 00:39:59.490
a different kind of content.

00:40:01.750 --> 00:40:05.320
So the four selected bindings that are
available are pretty straightforward.

00:40:05.320 --> 00:40:10.610
Selected object controls the selection
on top of the represented object.

00:40:10.730 --> 00:40:14.420
Selected tag, selected index,
controlled by tag and by index.

00:40:14.490 --> 00:40:16.700
Selected value controls
it by display value,

00:40:16.700 --> 00:40:20.000
by the title of the menu
items in the pop-up button.

00:40:21.470 --> 00:40:25.720
Now to populate the pop-up
with the available choices,

00:40:25.720 --> 00:40:27.820
use a combination of
multiple content bindings.

00:40:27.890 --> 00:40:32.120
There are three of them-- content,
content values, and content objects.

00:40:32.160 --> 00:40:35.580
They all sound very similar.

00:40:35.580 --> 00:40:38.790
The ones you choose pretty
much just depends on how your

00:40:38.790 --> 00:40:40.070
model objects are organized.

00:40:40.120 --> 00:40:42.770
And there are four cases
that are interesting.

00:40:43.130 --> 00:40:46.060
Case one is,
you simply have an NSArray of strings,

00:40:46.110 --> 00:40:48.180
and you just want to put
all these strings as display

00:40:48.180 --> 00:40:49.500
values into the pop-up button.

00:40:49.500 --> 00:40:51.840
So for that,
you have the content values binding.

00:40:51.840 --> 00:40:54.610
Simply bind the content values
to that array of strings,

00:40:54.610 --> 00:40:56.400
and then they will show up there.

00:40:56.400 --> 00:40:57.900
Now,
since you don't give us anything else,

00:40:57.930 --> 00:40:59.940
just strings,
there won't be any represented objects.

00:41:00.020 --> 00:41:02.460
But at least you can still
use the selected tag,

00:41:02.460 --> 00:41:05.200
selected index,
and selected value bindings.

00:41:05.200 --> 00:41:08.360
The selected object binding won't
be very meaningful because there are

00:41:08.360 --> 00:41:10.190
no represented objects behind that.

00:41:12.220 --> 00:41:17.080
The second case is that you have
an array of represented objects.

00:41:17.130 --> 00:41:19.140
For that, you use the content binding.

00:41:19.420 --> 00:41:22.040
So you bind the content to
the represented objects.

00:41:22.070 --> 00:41:24.380
There's a menu item for
each object in that array.

00:41:24.380 --> 00:41:28.440
And since we don't know any better,
we just use the description method of

00:41:28.440 --> 00:41:30.950
the objects to create a title to display.

00:41:31.380 --> 00:41:32.930
So now,
what you have is you can actually use

00:41:33.010 --> 00:41:36.640
the selected object binding to edit
your relationship directly because you

00:41:36.640 --> 00:41:38.400
have a meaningful represented object.

00:41:41.600 --> 00:41:44.060
Now the most common
case is the third case,

00:41:44.110 --> 00:41:47.330
which is the case where you have
an array of represented objects,

00:41:47.370 --> 00:41:50.460
but each represented object also
has a dedicated key that you can

00:41:50.460 --> 00:41:52.330
use to display a nice value for it.

00:41:52.420 --> 00:41:54.300
So you could have an
array of person objects,

00:41:54.300 --> 00:41:56.530
and each person has a name.

00:41:56.960 --> 00:41:59.370
So in this case,
you'd bind two bindings at the same time.

00:41:59.490 --> 00:42:01.960
You'd bind first the content binding,
and you'd bind the

00:42:02.060 --> 00:42:03.060
content values binding.

00:42:03.270 --> 00:42:06.990
The content binding points to
the array of represented objects.

00:42:07.020 --> 00:42:09.320
The content values binding,
on top of that,

00:42:09.360 --> 00:42:11.680
points to the display values.

00:42:12.000 --> 00:42:14.310
So this gives you actually
the best of both worlds.

00:42:14.360 --> 00:42:17.540
You can use the selected object
binding based on the represented

00:42:17.610 --> 00:42:20.310
objects from the content,
and you can still have a

00:42:20.310 --> 00:42:22.330
nice display value in the UI.

00:42:25.840 --> 00:42:28.300
So a concrete example,
you have an array controller

00:42:28.300 --> 00:42:29.400
with person objects.

00:42:29.590 --> 00:42:31.620
You would bind the
content to just the-- oh,

00:42:31.620 --> 00:42:33.760
so you have an array
controller with person objects,

00:42:33.760 --> 00:42:36.680
and you want all the person objects
to show up in the pop-up button.

00:42:36.820 --> 00:42:41.100
So you bind the content to the arranged
objects of your person controller,

00:42:41.100 --> 00:42:44.550
and the content values to
the arranged objects .name.

00:42:48.450 --> 00:42:53.380
The only limitation here is that you
need to be able to reach the display

00:42:53.380 --> 00:42:55.180
value through the represented object.

00:42:55.330 --> 00:42:58.240
You can't have two parallel arrays,
one that stores all the

00:42:58.240 --> 00:43:01.120
represented objects,
one that stores all the display names.

00:43:01.150 --> 00:43:03.740
You need to make sure that the
display name can be reached through

00:43:03.940 --> 00:43:06.250
the represented object itself.

00:43:16.060 --> 00:43:19.090
Case number four is a little different.

00:43:19.200 --> 00:43:22.060
In case number four,
you store the represented

00:43:22.060 --> 00:43:25.690
object and the name in parallel
within a container object.

00:43:25.700 --> 00:43:27.720
So typically you have an
array of dictionaries,

00:43:27.870 --> 00:43:30.700
and each dictionary has
two key value pairs.

00:43:30.900 --> 00:43:35.300
One for the name, for the display value,
and one for the represented object.

00:43:35.300 --> 00:43:37.700
So in this case you
bind all three bindings.

00:43:37.860 --> 00:43:40.700
Content points to the
array of dictionaries.

00:43:40.930 --> 00:43:44.300
Content values points to the
display property within there.

00:43:44.310 --> 00:43:47.640
and content objects that
represented objects.

00:43:49.880 --> 00:43:53.490
So again, you can use the selected object
binding because we have a

00:43:53.490 --> 00:43:56.040
meaningful represented object.

00:43:56.070 --> 00:43:58.180
This time, though,
the represented object is based

00:43:58.250 --> 00:44:01.920
on the content object's binding,
not on the content binding.

00:44:01.920 --> 00:44:05.650
And you also have a nice display value
through the content values binding.

00:44:05.680 --> 00:44:07.410
And the same limitation applies.

00:44:07.510 --> 00:44:10.170
The content values and content
object bindings need to be

00:44:10.170 --> 00:44:11.970
based on the content bindings.

00:44:12.000 --> 00:44:14.480
You need to bind it to the same object.

00:44:14.480 --> 00:44:17.520
And the key path for the content
binding needs to be the start of the

00:44:17.520 --> 00:44:20.380
key path for the other two bindings.

00:44:23.180 --> 00:44:25.220
So here's a table that
summarizes all this.

00:44:25.380 --> 00:44:27.930
I'm not going to read it again,
but if you ever kind of

00:44:27.980 --> 00:44:29.890
get a hold of the slides,
this might be good reference

00:44:29.980 --> 00:44:31.060
material for the future.

00:44:31.060 --> 00:44:38.710
There are a few more options I want to
point you to for the content binding.

00:44:43.800 --> 00:44:48.900
The most interesting one is the
inserts-null-placeholder binding option.

00:44:48.900 --> 00:44:51.600
Inserts-null-value.

00:44:51.620 --> 00:44:53.460
God, I can't even read this.

00:44:53.460 --> 00:44:55.570
Inserts-null-placeholder.

00:44:56.230 --> 00:44:58.780
In combination with the null
placeholder value that you can

00:44:58.780 --> 00:45:03.010
also enter in the inspector,
what this does is that then the binding

00:45:03.010 --> 00:45:08.130
will create an explicit item in the
pop-up to represent the null state.

00:45:08.140 --> 00:45:12.250
So you pretty much can create a menu item
that the user can choose to explicitly

00:45:12.250 --> 00:45:15.140
deselect the value for the relationship.

00:45:18.160 --> 00:45:21.480
Now we have the same kind of bindings
that I just described for pop-up buttons,

00:45:21.480 --> 00:45:22.430
also for NSMatrix.

00:45:22.470 --> 00:45:26.590
So you can have an NSMatrix
with radio or checkbox buttons.

00:45:26.600 --> 00:45:29.660
And then we will create the
individual items in the matrix for

00:45:29.660 --> 00:45:31.540
you based on the content bindings.

00:45:31.540 --> 00:45:34.010
And you typically want to place
the matrix in a scroll view

00:45:34.010 --> 00:45:36.740
because you don't know exactly
how many items you will have.

00:45:36.800 --> 00:45:40.070
For the selected bindings,
it will depend on the mode of that matrix

00:45:40.070 --> 00:45:42.360
what kind of bindings you have available.

00:45:42.820 --> 00:45:46.360
In the default mode, the radio mode,
where just one set can

00:45:46.390 --> 00:45:49.410
be selected at a time,
you have the exact same bindings

00:45:49.410 --> 00:45:50.820
as the pop-up button has.

00:45:50.820 --> 00:45:53.790
But if you put the matrix in
the highlight or list mode,

00:45:53.790 --> 00:45:57.720
which then allows multiple selections,
you get two different bindings.

00:45:57.720 --> 00:46:00.030
You get selected objects
and selected values,

00:46:00.260 --> 00:46:03.300
which represent arrays of all
the currently selected items.

00:46:08.140 --> 00:46:09.870
Let's talk about target
argument bindings.

00:46:09.940 --> 00:46:16.000
The situation I believe a
lot of us are in every now

00:46:16.000 --> 00:46:19.280
and then is that we're in IB,
and we want to invoke some arbitrary

00:46:19.280 --> 00:46:23.640
method on some arbitrary object with
some arbitrary number of arguments.

00:46:23.660 --> 00:46:25.820
Now, unfortunately,
IB doesn't really give us a good,

00:46:25.820 --> 00:46:29.140
convenient way to do that,
at least not in the traditional

00:46:29.140 --> 00:46:30.330
form without bindings.

00:46:30.480 --> 00:46:33.500
So typically in the past,
you had to go ahead and create

00:46:33.500 --> 00:46:35.940
some target action method,
which means that you're limited

00:46:36.040 --> 00:46:39.300
to just one single argument
with the sender of the argument.

00:46:39.310 --> 00:46:42.250
You would create a bunch of outlets to
the different kind of UI elements that

00:46:42.250 --> 00:46:43.960
you want to read the arguments from.

00:46:43.960 --> 00:46:46.310
And then you go on your files owner,
implement that method there.

00:46:46.370 --> 00:46:49.200
And it's kind of a bit of ugly
code to kind of put all this

00:46:49.200 --> 00:46:51.140
together just to invoke a method.

00:46:51.140 --> 00:46:56.200
So fortunately, with bindings,
there's a simpler solution.

00:46:56.200 --> 00:47:00.290
You will use a combination of target
and argument bindings on an NMS button.

00:47:00.300 --> 00:47:02.460
And there's pretty much three steps.

00:47:02.530 --> 00:47:05.040
First of all,
you bind the target binding,

00:47:05.040 --> 00:47:07.980
and it will identify the object
the method is invoked on.

00:47:07.980 --> 00:47:10.730
And as part of the target binding,
you specify an option,

00:47:10.730 --> 00:47:14.210
which is the selector name of
the method you want to invoke.

00:47:14.690 --> 00:47:16.960
And then as the third step,
for each argument of

00:47:17.050 --> 00:47:19.520
that method invocation,
you use an argument binding.

00:47:19.520 --> 00:47:22.530
The argument binding is one of these
funny bindings that are enumerated.

00:47:22.540 --> 00:47:25.670
So once you bind the first one,
you get a second one, argument two.

00:47:25.680 --> 00:47:28.320
Once you bind that one,
you get the next one, argument three,

00:47:28.420 --> 00:47:28.920
and so on.

00:47:36.100 --> 00:47:38.580
In addition to NSButton,
the target argument bindings,

00:47:38.580 --> 00:47:41.000
we also implemented the same
functionality for double clicks

00:47:41.000 --> 00:47:43.000
on NSTableViews and OutlineViews.

00:47:43.010 --> 00:47:45.000
The bindings are named
a little differently.

00:47:45.000 --> 00:47:47.120
They are called DoubleClickTarget
and DoubleClickArgument,

00:47:47.120 --> 00:47:50.450
but they behave exactly the
same way as the NSButton target

00:47:50.710 --> 00:47:53.020
argument bindings behave.

00:47:55.100 --> 00:47:57.400
So let's look at an example.

00:47:57.440 --> 00:48:00.480
Let's say you want to invoke a
method open info panels for groups

00:48:01.130 --> 00:48:03.140
on your application delegate.

00:48:03.190 --> 00:48:05.380
And you want to take the argument,
the groups,

00:48:05.510 --> 00:48:08.190
from the selection of a table view.

00:48:08.300 --> 00:48:10.130
So there's two bindings.

00:48:10.320 --> 00:48:13.870
The target binding is bound to
the shared application instance

00:48:14.030 --> 00:48:15.540
with a delegate key path.

00:48:15.590 --> 00:48:18.960
So the delegate of the application
is the receiver of the method.

00:48:19.150 --> 00:48:21.590
And the argument binding is to
the array controller that you'll

00:48:21.700 --> 00:48:23.360
probably use for that table view.

00:48:23.410 --> 00:48:25.680
And simply the key path selected objects.

00:48:25.790 --> 00:48:28.320
And then when the button is pressed,
you invoke this method on the

00:48:28.320 --> 00:48:33.200
application's delegate with the currently
selected items in the group's controller.

00:48:34.080 --> 00:48:37.000
So an IB that would look like this,
you would have a button

00:48:37.000 --> 00:48:39.280
with a table view,
and then you'd have two bindings.

00:48:39.280 --> 00:48:41.430
As you can see,
the target binding is bound

00:48:41.430 --> 00:48:43.920
to the shared application,
keypath delegate,

00:48:43.920 --> 00:48:49.870
and the argument binding is bound to the
group's controller for selected objects.

00:48:52.340 --> 00:48:56.520
Another more complicated example,
let's say you want to invoke a method,

00:48:56.790 --> 00:48:59.760
add keywords to pictures,
show progress indicator,

00:48:59.760 --> 00:49:01.440
just because I had to
make a Boolean argument.

00:49:01.440 --> 00:49:04.440
So you would want to invoke
that on a files owner.

00:49:04.440 --> 00:49:06.930
The keywords are just an array
of strings that you want to

00:49:07.020 --> 00:49:09.280
read from one table view,
the currently selected

00:49:09.330 --> 00:49:10.480
strings in one table view.

00:49:10.480 --> 00:49:13.630
The picture objects are selected
objects in another table view,

00:49:13.670 --> 00:49:16.750
and maybe that flag you want
to read from the user defaults.

00:49:16.800 --> 00:49:18.500
So there are four bindings.

00:49:18.500 --> 00:49:21.380
Target binding goes to the files owner.

00:49:22.020 --> 00:49:24.480
And interestingly,
you can use self as a key path.

00:49:24.540 --> 00:49:26.540
So you don't have to actually
go to another object.

00:49:26.540 --> 00:49:28.640
You can just use self as key
path to invoke the method

00:49:28.720 --> 00:49:29.870
on the files owner itself.

00:49:29.900 --> 00:49:34.320
The first argument binding goes to
the array controller for the keywords.

00:49:34.320 --> 00:49:38.430
You would probably use something like
selected objects dot name as a key path.

00:49:38.500 --> 00:49:41.280
For the argument two binding,
you would bind to the other array

00:49:41.280 --> 00:49:43.030
controller for the picture objects.

00:49:43.120 --> 00:49:45.070
Selected objects would be your key path.

00:49:45.160 --> 00:49:48.380
And for the last argument binding,
you would bind to the shared

00:49:48.420 --> 00:49:50.060
user defaults controller.

00:49:50.060 --> 00:49:54.350
And the key path would be something like,
values dot my default name.

00:49:54.360 --> 00:49:56.700
So as you can see,
you have a lot of flexibility

00:49:56.700 --> 00:50:00.630
with how you pull the different
arguments together and to what kind

00:50:00.630 --> 00:50:02.710
of object you actually send it.

00:50:02.790 --> 00:50:06.320
Everything you can reach through a
key path on an object that you can

00:50:06.320 --> 00:50:10.150
bind to is a potential target or a
potential argument for the method.

00:50:13.270 --> 00:50:17.810
So the selector name is in
the-- you specify in the

00:50:17.810 --> 00:50:20.880
options area of the bindings,
but it's really not an option.

00:50:20.880 --> 00:50:23.020
It's really a required option.

00:50:23.020 --> 00:50:26.570
Your application won't be very
happy if you forget listing this.

00:50:27.430 --> 00:50:31.440
For the argument bindings,
there are a bunch of interesting options.

00:50:31.440 --> 00:50:34.030
The first one I want to point
out is the value transformer.

00:50:34.040 --> 00:50:36.750
Most of you probably know that
the value transformer is available

00:50:36.840 --> 00:50:37.960
for pretty much all bindings.

00:50:37.960 --> 00:50:40.660
It's particularly useful
for the argument bindings,

00:50:40.670 --> 00:50:43.630
because often you don't have control
over the APIs of the objects you

00:50:43.730 --> 00:50:45.340
want to invoke your method on.

00:50:45.340 --> 00:50:47.920
So the value transformers might
just be the right choice to kind

00:50:47.980 --> 00:50:51.300
of transform the representation of
the argument into the form that the

00:50:51.300 --> 00:50:53.570
receiver of the method expects it.

00:50:55.960 --> 00:50:59.510
There's an option, allows null argument.

00:50:59.630 --> 00:51:01.860
So here you can decide whether
you actually want to allow the

00:51:01.860 --> 00:51:05.220
method invocation if one of
the arguments is still null.

00:51:05.220 --> 00:51:09.030
And in combination with the other option,
conditionally sets enabled,

00:51:09.050 --> 00:51:12.270
which also is on by default,
the binding will even automatically

00:51:12.270 --> 00:51:15.500
enable and disable the button based
on the availability of the arguments.

00:51:15.500 --> 00:51:17.490
So you can pretty much say
that as long as the user hasn't

00:51:17.590 --> 00:51:20.070
specified an argument yet,
you don't want to allow the invocation,

00:51:20.190 --> 00:51:21.460
the button should be disabled.

00:51:23.210 --> 00:51:26.000
And then the last option is invoke
separately with array objects.

00:51:26.160 --> 00:51:27.690
This is a little more specialized.

00:51:27.770 --> 00:51:30.840
But if you don't have control
over the API of the receiver,

00:51:31.010 --> 00:51:34.340
you might not have an API that
takes multiple objects.

00:51:34.340 --> 00:51:37.100
But you still want to allow an
invocation for all the objects in

00:51:37.100 --> 00:51:38.960
some selection of the table view.

00:51:39.050 --> 00:51:41.500
So then you can pretty much
split up the invocations into

00:51:41.500 --> 00:51:43.570
one invocation each per object.

00:51:43.690 --> 00:51:46.200
And that's what you can
use this option here for.

00:51:48.500 --> 00:51:50.420
And as a last step,
before I hand back to Ron,

00:51:50.420 --> 00:51:54.380
I'd just like to quickly give you a
demo for how that could look like.

00:52:00.570 --> 00:52:03.960
So here's an application
that I have up and running.

00:52:03.980 --> 00:52:06.590
It's based on the
Core Data Recipes example,

00:52:06.660 --> 00:52:07.980
but that doesn't really matter.

00:52:07.980 --> 00:52:11.600
It was just the most convenient
way for me to fit in the data here.

00:52:11.630 --> 00:52:14.180
So as you can see,
I have a master-detail relationship,

00:52:14.200 --> 00:52:18.210
recipes in the upper table,
and then ingredients in the bottom one.

00:52:18.270 --> 00:52:21.100
Depending on what I select
in the upper table,

00:52:21.130 --> 00:52:24.540
the content changes in the detail table.

00:52:24.540 --> 00:52:26.700
And as you can see,
it handles multiple selectors

00:52:26.700 --> 00:52:30.560
nicely by showing all ingredients
of all selected recipes.

00:52:30.580 --> 00:52:34.280
I have a matrix here with
the selected cuisines,

00:52:34.280 --> 00:52:36.780
and I can just go edit that.

00:52:37.930 --> 00:52:39.850
As you can see, there are pop-up buttons.

00:52:39.960 --> 00:52:42.270
In the table view,
we use the abbreviation

00:52:42.310 --> 00:52:43.400
of the measurement.

00:52:43.400 --> 00:52:47.510
And down here, we have the full name,
like cup, tablespoon, ounces.

00:52:47.560 --> 00:52:49.960
So there's a bunch of pop-up buttons.

00:52:49.960 --> 00:52:53.450
And we even created a little method
on the file zone that we want to

00:52:53.450 --> 00:52:56.470
invoke that will kind of tell us
how much we have to go shopping

00:52:56.610 --> 00:52:58.080
for for all the selected recipes.

00:52:58.080 --> 00:53:01.390
So for 10 servings,
I can click on this button to get

00:53:01.400 --> 00:53:04.880
the list of other things I need
to buy into this pop-up button.

00:53:06.160 --> 00:53:07.540
So I wouldn't say this
makes a lot of sense,

00:53:07.540 --> 00:53:08.480
but it's a good example.

00:53:08.480 --> 00:53:12.900
So let's take a look at the Nib file.

00:53:14.710 --> 00:53:16.790
So there are a bunch of controllers
in here for all the different

00:53:16.830 --> 00:53:18.780
kind of areas in your UI.

00:53:18.780 --> 00:53:21.880
There is the recipes controller,
which is the master controller.

00:53:21.880 --> 00:53:23.500
You have an ingredients controller.

00:53:23.500 --> 00:53:26.180
And if you look at the bindings here,
you can see that I bound the

00:53:26.210 --> 00:53:30.460
content set to the ingredients,
selection of ingredients of the recipes.

00:53:30.460 --> 00:53:33.700
And I also bound the second alternative
binding for the multi-selection case.

00:53:33.730 --> 00:53:37.160
And I'm using this
union of sets operator.

00:53:37.780 --> 00:53:40.380
The other thing that might be
interesting is to show the pop-up button.

00:53:40.440 --> 00:53:42.510
There's content and content values.

00:53:42.630 --> 00:53:44.360
So I can show all the measurements.

00:53:44.400 --> 00:53:46.580
The measurement objects are
the represented objects.

00:53:46.590 --> 00:53:49.580
The name of the measurement
is what the display value is.

00:53:49.600 --> 00:53:51.790
And I also bound the
selected object binding.

00:53:51.900 --> 00:53:53.560
So I'm using all three
bindings together to,

00:53:53.580 --> 00:53:58.340
first of all, populate the pop-up button,
and to secondly control the selection.

00:53:58.340 --> 00:54:01.550
And here for the content values,
I'm using the name

00:54:01.650 --> 00:54:03.810
right on the table view.

00:54:04.930 --> 00:54:09.250
I'm using the abbreviation,
so you can even tune this a little bit.

00:54:09.510 --> 00:54:11.860
And then last, for the button here,
as you can see,

00:54:11.860 --> 00:54:15.510
the target goes to the files
owner with the key path save.

00:54:15.580 --> 00:54:18.410
So we invoke the method on
the files owner with all the

00:54:18.450 --> 00:54:19.860
different kind of arguments.

00:54:20.060 --> 00:54:23.430
And just to show you the code for that--
it's not particularly interesting--

00:54:23.540 --> 00:54:24.840
but here's the method declaration.

00:54:24.840 --> 00:54:27.890
So I can pretty much invoke arbitrary
methods on my files owner with

00:54:27.890 --> 00:54:29.900
all different kinds of arguments.

00:54:29.940 --> 00:54:31.280
And that's all I wanted to show you.

00:54:31.380 --> 00:54:34.210
And with that, back to Ron.

00:54:40.390 --> 00:54:41.300
Thanks, Andreas.

00:54:41.300 --> 00:54:42.300
It's over there.

00:54:42.300 --> 00:54:43.300
Sorry.

00:54:43.300 --> 00:54:45.290
I love that demo.

00:54:45.300 --> 00:54:47.640
Okay.

00:54:47.950 --> 00:54:50.640
So everybody knows
everything about content,

00:54:50.760 --> 00:54:55.340
objects, values, content,
content objects, content values,

00:54:55.380 --> 00:54:58.140
content value objects.

00:54:58.140 --> 00:55:02.180
But I think you did a really
good job explaining that.

00:55:04.350 --> 00:55:08.340
Okay,
so going back to the rest of our talk,

00:55:08.490 --> 00:55:11.860
just go over a couple of small things,
starting off with the changes

00:55:11.860 --> 00:55:15.400
we've made to controllers in
order to work well with core data.

00:55:15.400 --> 00:55:18.160
The main thing we've
done is now the object,

00:55:18.160 --> 00:55:21.020
the array,
and the tree controller have a few new

00:55:21.280 --> 00:55:25.660
features like having an entity mode,
as well as the content set binding

00:55:25.710 --> 00:55:27.940
that we've seen throughout the show.

00:55:28.980 --> 00:55:32.540
And also,
controllers can fetch content themselves,

00:55:32.700 --> 00:55:36.100
so you don't have to programmatically
set a controller's content.

00:55:36.410 --> 00:55:39.620
They can fetch from a
managed object context.

00:55:39.800 --> 00:55:43.590
A little detail about
each of these things.

00:55:43.590 --> 00:55:46.730
First, the content set binding.

00:55:47.140 --> 00:55:49.340
The content set binding really
only makes sense for the

00:55:49.340 --> 00:55:53.140
array and the tree controller,
so it's available there.

00:55:53.310 --> 00:55:57.880
And the reasoning behind it is, first,
in core data,

00:55:57.920 --> 00:55:59.680
relationships aren't modeled as arrays.

00:55:59.760 --> 00:56:03.960
They're supposed to be unordered
and not allow duplicates.

00:56:03.960 --> 00:56:05.960
So they're best modeled as NS sets.

00:56:06.020 --> 00:56:09.710
So in order to use an
NS set with the controllers,

00:56:09.710 --> 00:56:11.800
we came up with the content set binding.

00:56:11.800 --> 00:56:15.890
What happens is we'll convert sets
into whatever is appropriate for

00:56:16.060 --> 00:56:18.080
the controller you bound it with.

00:56:18.120 --> 00:56:22.960
So arrays for the array controller and
trees of objects for the tree controller.

00:56:25.060 --> 00:56:29.080
If you try to bind content
set and you pass in an array,

00:56:29.090 --> 00:56:32.040
or you bind content array
and you pass in a set,

00:56:32.080 --> 00:56:35.170
the controller will yell
at you and tell you this.

00:56:35.350 --> 00:56:39.560
So you can check your debug or run
log and look for this if something in

00:56:39.560 --> 00:56:42.400
your UI isn't working as you expected.

00:56:45.390 --> 00:56:49.750
There are four steps to configuring
a controller to fetch its content.

00:56:50.060 --> 00:56:51.050
Four simple steps.

00:56:51.070 --> 00:56:54.180
The two that are listed here
at the top are required.

00:56:54.370 --> 00:56:57.290
The two at the bottom, of course,
are optional.

00:56:57.390 --> 00:57:02.380
The first required step is setting
an entity name for the controller.

00:57:04.300 --> 00:57:08.960
All you have to do is switch the
controller into entity mode as opposed

00:57:09.030 --> 00:57:14.370
to class mode that you're probably
used to and give it an entity name.

00:57:14.830 --> 00:57:19.230
This entity is,
the name of this entity tells it which

00:57:19.230 --> 00:57:24.890
objects to fetch from its data store,
and it also defines which entity

00:57:24.890 --> 00:57:28.700
of objects will be created
during insert or add actions.

00:57:28.700 --> 00:57:33.840
Step two, if you're going to make a
controller fetch its own content,

00:57:33.840 --> 00:57:36.700
is give it some place to fetch from.

00:57:36.700 --> 00:57:40.490
So typically people will just
bind the managed object context

00:57:40.490 --> 00:57:46.700
of your controller to files owner
or some common place in your nib.

00:57:49.000 --> 00:57:53.360
The first of the two-- actually, yeah,
I should mention,

00:57:53.390 --> 00:57:57.280
when new objects are created by
the controllers in entity mode,

00:57:57.400 --> 00:58:01.380
normally they're just created and
inserted into a managed object context.

00:58:01.540 --> 00:58:04.500
But they're not assigned to
any store that you would,

00:58:04.500 --> 00:58:06.530
by default, have control over.

00:58:06.820 --> 00:58:12.000
If you have multiple stores hooked up
to the coordinator of your application,

00:58:12.270 --> 00:58:15.370
We'll just go through and find
the first store that's writable,

00:58:15.370 --> 00:58:19.090
and your new object will be
inserted into that store.

00:58:19.860 --> 00:58:22.940
And the same,
a similar thing happens during fetches.

00:58:22.940 --> 00:58:26.040
The controller just fetches
from all available stores,

00:58:26.090 --> 00:58:28.700
if you have multiple stores
hooked up to your coordinator.

00:58:28.710 --> 00:58:30.650
If you want to customize
this functionality,

00:58:30.660 --> 00:58:34.370
you should consider subclassing
the array or the tree controller

00:58:34.370 --> 00:58:37.860
or the object controller,
and override new object in the

00:58:37.990 --> 00:58:42.670
case of when you want to assign
objects to a specific store.

00:58:42.780 --> 00:58:47.700
You can override this and simply
assign the object to a specific store.

00:58:47.700 --> 00:58:51.700
Or in your subclass,
you could override fetch with request,

00:58:51.700 --> 00:58:55.040
as you see here,
and set the affected stores for

00:58:55.040 --> 00:59:00.690
the fetch request that's passed
in when you override this method.

00:59:03.860 --> 00:59:04.790
Okay.

00:59:04.890 --> 00:59:08.460
Step three,
one of the optional steps for having

00:59:08.480 --> 00:59:12.730
a controller fetch its content,
is setting a fetch predicate.

00:59:12.730 --> 00:59:19.790
This is something that you'll only see
when the controller is in entity mode.

00:59:19.790 --> 00:59:19.790
Normally, on the

00:59:20.280 --> 00:59:21.180
You're right.

00:59:21.240 --> 00:59:28.260
You'll see the keys that the
controller has when it's in class mode.

00:59:28.810 --> 00:59:30.680
Oops.

00:59:30.790 --> 00:59:34.170
When it's in entity mode,
you'll see a box down here for editing

00:59:34.340 --> 00:59:39.100
the fetch predicate that's used when
the controller fetches its content.

00:59:41.450 --> 00:59:45.240
So if you notice,
we've talked about fetch predi--

00:59:45.400 --> 00:59:50.280
about predicates twice in this talk,
both in relation to the array

00:59:50.300 --> 00:59:53.780
controller's filter predicate,
and also now for the more

00:59:53.780 --> 00:59:57.730
general case of a fetch predicate
on an-- on an NS controller.

00:59:57.930 --> 01:00:00.750
That means there are two
places to set a predicate,

01:00:00.850 --> 01:00:06.470
but they're not used in the same way.

01:00:06.470 --> 01:00:06.480
The fetch predicate--

01:00:07.510 --> 01:00:11.410
The fetch predicate affects which
objects from your stores become

01:00:11.410 --> 01:00:14.000
part of the controller's content.

01:00:14.130 --> 01:00:17.780
So this is the underlying content
array for the array controller.

01:00:17.890 --> 01:00:22.510
The filter predicate is set separately
and affects which objects show

01:00:22.510 --> 01:00:24.700
up in the arranged objects array.

01:00:24.800 --> 01:00:27.450
So remember that proxy array
that we talked about earlier.

01:00:27.570 --> 01:00:30.560
So this should emphasize that
the arranged objects is always

01:00:30.560 --> 01:00:35.110
going to be a subset of the
array controller's content array.

01:00:35.870 --> 01:00:40.360
Okay, back to setting up the
controller to fetch.

01:00:40.360 --> 01:00:42.790
You can optionally enable
what we call live updating.

01:00:42.790 --> 01:00:46.750
This means that whenever the
managed object context sends

01:00:46.750 --> 01:00:50.150
out its notifications for a
new object has been inserted,

01:00:50.160 --> 01:00:54.320
a new object's been deleted,
or an existing object's been deleted,

01:00:54.320 --> 01:00:58.540
or some object's been updated,
some value's been updated,

01:00:58.540 --> 01:01:01.580
the context normally
sends out a notification.

01:01:02.560 --> 01:01:06.390
When the controller is set up to
listen for these notifications,

01:01:06.390 --> 01:01:11.390
it'll automatically update its content,
and you don't have to worry about it.

01:01:11.740 --> 01:01:14.590
Everything that happens in the managed
object context will be reflected

01:01:14.590 --> 01:01:16.180
immediately in the controller.

01:01:16.180 --> 01:01:19.730
And even though we call
it enabling live updates,

01:01:19.730 --> 01:01:24.460
the checkbox for it is called
automatically prepares content.

01:01:24.460 --> 01:01:27.940
Normally in class mode,
automatically prepares

01:01:28.180 --> 01:01:31.860
content tells the controller,
well, when we start up.

01:01:32.100 --> 01:01:35.600
In Awake from Nib,
we'll create one of these,

01:01:35.600 --> 01:01:39.260
for in this case,
mutable dictionary automatically

01:01:39.440 --> 01:01:40.670
if our content is nil.

01:01:40.680 --> 01:01:43.420
That guarantees that there's
always something there.

01:01:43.420 --> 01:01:46.740
That's why we started off with
automatically prepares content.

01:01:48.290 --> 01:01:50.690
But now that we have
entity mode controllers,

01:01:50.740 --> 01:01:52.260
we can reuse this flag.

01:01:52.310 --> 01:01:55.260
And during a wake from nib,
if automatically prepares

01:01:55.260 --> 01:01:58.500
content is set to yes,
then the controller will

01:01:58.500 --> 01:02:02.150
automatically fetch immediately
right there in a wake from nib.

01:02:02.220 --> 01:02:06.370
And this also triggers the live
updating functionality I talked about.

01:02:06.450 --> 01:02:08.220
This really provides a
lot of functionality.

01:02:08.220 --> 01:02:11.670
It's a lot less work for you to
keep objects in your context in

01:02:11.670 --> 01:02:14.180
sync with what's in your controller.

01:02:16.070 --> 01:02:21.370
So that is the content set
and the entity mode thing and

01:02:21.370 --> 01:02:23.490
fetching the content of the match.

01:02:23.510 --> 01:02:25.500
Okay, all right,
so we're done with that part.

01:02:25.500 --> 01:02:29.500
Next I wanted to talk about
a couple of small items.

01:02:29.500 --> 01:02:34.660
First, the enabled, hidden,
and editable bindings we

01:02:34.660 --> 01:02:36.500
call availability bindings.

01:02:36.500 --> 01:02:41.500
And then we'll mention something about
how errors are presented with bindings

01:02:41.500 --> 01:02:44.540
and then some tips on debugging.

01:02:46.700 --> 01:02:50.110
So our availability bindings,
we mentioned these earlier when

01:02:50.110 --> 01:02:53.670
I talked about the can add,
can remove keys on the array

01:02:53.750 --> 01:02:55.380
controller or the tree controller.

01:02:55.380 --> 01:02:58.860
You can bind the enabled
binding of some object,

01:02:58.970 --> 01:03:02.460
usually a text field or
a button or an NS menu,

01:03:02.460 --> 01:03:06.040
to your controller or some object.

01:03:06.100 --> 01:03:11.660
And as soon as you bind enabled,
a second binding becomes available,

01:03:11.740 --> 01:03:13.020
enabled two.

01:03:13.020 --> 01:03:16.020
These are what we call
enumerated bindings.

01:03:16.300 --> 01:03:18.590
You saw these also in
Andreas' talk related to the

01:03:18.590 --> 01:03:20.320
target and argument bindings.

01:03:22.210 --> 01:03:25.400
What happens is,
for the enabled and the editable cases,

01:03:25.470 --> 01:03:29.100
we'll AND all of the results
for those bindings together.

01:03:29.190 --> 01:03:34.430
So only if all of the enabled bindings
return "yes" for a control will

01:03:34.440 --> 01:03:37.310
we actually enable that control.

01:03:37.410 --> 01:03:43.590
And it's OR-ed for the hidden case,
so that only if at least one of

01:03:43.720 --> 01:03:50.380
the hidden bindings returns "yes,"
then the object will be hidden.

01:03:53.120 --> 01:03:56.980
Now on to error presentation.

01:03:57.100 --> 01:04:00.760
If you're familiar with the
way commit editing works,

01:04:00.760 --> 01:04:04.470
this should be very interesting
for you because now with

01:04:04.590 --> 01:04:10.000
commit editing with delegate,
we can present sheets when something

01:04:10.000 --> 01:04:12.400
goes wrong committing edits from the UI.

01:04:12.400 --> 01:04:16.870
What happened in Panther is if you
sent the message commit editing to

01:04:16.870 --> 01:04:21.780
a controller and some text field,
for instance, was editing a bound value

01:04:21.780 --> 01:04:25.790
for that controller,
telling that controller commit editing

01:04:25.790 --> 01:04:30.390
would have it tell its view that it
should commit all of its edits as well.

01:04:30.400 --> 01:04:33.260
And if anything went wrong,
we'd just return no.

01:04:33.390 --> 01:04:35.850
This wasn't so great for
presenting errors since we'd

01:04:35.850 --> 01:04:37.400
always present them modally.

01:04:37.400 --> 01:04:39.530
Now using the present error
API that's new for Tiger,

01:04:39.530 --> 01:04:41.400
we can present errors in a different way.

01:04:42.400 --> 01:04:42.400
Now on to error presentation.

01:04:42.400 --> 01:04:42.400
If you're familiar with the
way commit editing works,

01:04:42.400 --> 01:04:42.400
this should be very interesting
for you because now with

01:04:42.400 --> 01:04:42.400
commit editing with delegate,
we can present sheets when something

01:04:42.400 --> 01:04:42.400
goes wrong committing edits from the UI.

01:04:42.400 --> 01:04:46.800
tiger, and this new method,
commitEditingWithDelegate,

01:04:46.810 --> 01:04:50.760
bound controllers as well as
NSManagedObjectContext can

01:04:50.760 --> 01:04:56.370
respond to this call by presenting
sheets if something goes wrong,

01:04:56.470 --> 01:05:00.000
commit and edit in the related editor.

01:05:02.130 --> 01:05:04.830
The last thing I want to
talk about is debugging.

01:05:05.030 --> 01:05:08.080
A lot of people have brought up
debugging as a source bot for bindings.

01:05:08.080 --> 01:05:11.440
And really,
the most common thing that will happen is

01:05:11.440 --> 01:05:13.950
somebody's bound an incorrect key path.

01:05:14.020 --> 01:05:17.620
And usually you'll see something,
an error like this in your run log.

01:05:17.620 --> 01:05:23.200
Another common error for the core
data side of things is you're

01:05:23.200 --> 01:05:27.200
using a controller in entity mode,
but you haven't given it a managed

01:05:27.200 --> 01:05:28.910
object context to work with.

01:05:29.580 --> 01:05:33.710
And then the controller will
yell at you and say this.

01:05:34.890 --> 01:05:37.460
But if you want to get some
more debugging information,

01:05:37.680 --> 01:05:42.640
for Tiger we've added a default
called the NSBindingDebugLogLevel.

01:05:42.640 --> 01:05:46.680
There's only one debug log level so far,
so you can just set it to one.

01:05:46.680 --> 01:05:51.000
And watch your debug log or your run log,
and you'll see some more detailed

01:05:51.050 --> 01:05:54.640
information whenever an undefined
key exception is raised.

01:05:54.640 --> 01:05:59.620
You'll see some information basically
the key path that was bound to

01:05:59.790 --> 01:06:03.750
when the exception was raised,
as well as the controller

01:06:03.750 --> 01:06:07.130
involved in the binding,
and the object that was

01:06:07.130 --> 01:06:09.300
bound to the controller.

01:06:09.300 --> 01:06:12.960
So this will help you hunt down where
a bad key path or a bad binding was

01:06:12.960 --> 01:06:14.830
set up a lot faster in your nib.

01:06:18.410 --> 01:06:24.310
And for more information,
check out the sample code.

01:06:24.590 --> 01:06:25.610
Oh, OK.

01:06:25.670 --> 01:06:27.250
Related sessions to this.

01:06:27.340 --> 01:06:29.930
Tomorrow morning,
come in bright and early

01:06:29.970 --> 01:06:31.450
and give us your feedback.

01:06:31.520 --> 01:06:33.780
We're really excited to
see so many people here.

01:06:33.930 --> 01:06:37.820
And we all want to hear your ideas,
your feedback.

01:06:37.820 --> 01:06:41.710
So there's a Cocoa and
Core Data feedback forum.

01:06:41.830 --> 01:06:45.900
And tomorrow afternoon,
there's advanced core data usages.

01:06:45.900 --> 01:06:50.110
It looked like everybody here
was also interested in core data.

01:06:50.130 --> 01:06:54.580
And I think we might have already
missed writing Cocoa Automator Actions.

01:06:54.580 --> 01:06:56.220
Oh, no, that's coming up.

01:06:56.240 --> 01:07:00.790
So you can also check that out,
because Automator Actions in

01:07:00.840 --> 01:07:03.960
Cocoa makes use of bindings as well.

01:07:03.960 --> 01:07:06.080
And next.

01:07:06.380 --> 01:07:07.100
Who to contact?

01:07:07.100 --> 01:07:10.420
You can email Matt all of your ideas,
all of your gripes,

01:07:10.440 --> 01:07:11.640
all of your feedback in general.

01:07:11.640 --> 01:07:13.260
And please, use Cocoa Dev.

01:07:13.290 --> 01:07:15.300
We take a look at that.

01:07:15.300 --> 01:07:17.860
We try and help people on the list there,
too.
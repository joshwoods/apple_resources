WEBVTT

00:00:07.320 --> 00:00:10.290
Good morning.

00:00:10.420 --> 00:00:12.880
Okay, in this session,
we will present ways to help you

00:00:12.880 --> 00:00:15.100
enhance the security of your software.

00:00:15.210 --> 00:00:19.350
We're explicitly not covering security
from a system administration standpoint,

00:00:19.450 --> 00:00:23.300
since that's a whole separate topic
and we want to focus on developers.

00:00:23.550 --> 00:00:29.300
There are companies who provide multi-day
courses on application security.

00:00:29.430 --> 00:00:32.970
So the best we can hope to do in this
brief session is to give you a few

00:00:32.970 --> 00:00:35.300
signposts to help you along the way.

00:00:35.300 --> 00:00:39.500
Also presenting will be Richard Murphy,
manager of the Data Security Group,

00:00:39.540 --> 00:00:43.290
as well as Aaron Sigel and
Simon Cooper from Product Security.

00:00:43.290 --> 00:00:47.300
And we'll be available after the
session for any further questions.

00:00:51.160 --> 00:00:54.300
So we will cover security
threats and trends,

00:00:54.310 --> 00:00:57.760
discuss the multi-user environment
in which your application runs,

00:00:57.800 --> 00:01:02.000
give you some tips on data handling,
cover common coding pitfalls,

00:01:02.240 --> 00:01:06.940
and mention a few system services to help
enhance the security of your application.

00:01:06.980 --> 00:01:08.740
So let's begin.

00:01:09.160 --> 00:01:11.910
In this section,
we'll talk about how systems can be

00:01:11.950 --> 00:01:14.660
compromised as well as attack trends.

00:01:14.660 --> 00:01:19.700
And the topics here can apply to
any commercial operating system.

00:01:21.090 --> 00:01:25.320
When we talk about a security attack,
one of the first things we ask is,

00:01:25.550 --> 00:01:30.250
"What is being attacked?" The points
of attack are going to be the main

00:01:30.250 --> 00:01:33.040
elements in the entire system,
which is comprised of

00:01:33.040 --> 00:01:36.160
various software layers,
as well as multiple users

00:01:36.260 --> 00:01:38.010
and their information.

00:01:38.110 --> 00:01:42.490
Most systems connect to the network,
making it an element to consider

00:01:42.490 --> 00:01:44.610
when designing for security.

00:01:45.610 --> 00:01:48.410
Let's look at the main
classes of attacks.

00:01:48.520 --> 00:01:51.420
The first is an attack
from a remote entity.

00:01:51.510 --> 00:01:54.970
We've seen this happen through
enabling a service such as

00:01:54.970 --> 00:01:57.830
SSH and not using good passwords.

00:01:57.840 --> 00:02:02.730
Or through built-in vulnerabilities
such as buffer overflows and

00:02:02.730 --> 00:02:05.260
network-based applications.

00:02:05.390 --> 00:02:09.320
The remote entity can then insert
malicious code to control the

00:02:09.340 --> 00:02:11.500
system and access information.

00:02:11.500 --> 00:02:14.000
What does this mean to you?

00:02:14.000 --> 00:02:18.300
If your application opens
and listens on a port,

00:02:18.440 --> 00:02:23.740
or allows itself to be updated,
or processes input from the network,

00:02:23.880 --> 00:02:29.160
or registers a URL handler to run
functions without explicit user action,

00:02:29.160 --> 00:02:32.860
or reveals information in
response to network queries,

00:02:32.860 --> 00:02:37.080
then your application could be
a gateway for a remote attack.

00:02:37.280 --> 00:02:40.290
Another type of attack is a local attack.

00:02:40.430 --> 00:02:43.900
Here, a user on the system could
take advantage of a weakness

00:02:44.210 --> 00:02:46.640
to gain elevated privileges.

00:02:46.780 --> 00:02:50.170
Alternatively,
a user's information that they

00:02:50.630 --> 00:02:56.020
thought was private could actually be
accessed by other users on the system,

00:02:56.020 --> 00:02:59.150
including the system administrator.

00:02:59.560 --> 00:03:03.120
With a social engineering attack,
a user on the system is influenced

00:03:03.120 --> 00:03:07.730
to install malicious software
or divulge sensitive information

00:03:07.740 --> 00:03:10.650
that can lead to further attacks.

00:03:10.790 --> 00:03:14.660
The social engineering attack can
be viewed as a bridge that turns

00:03:14.660 --> 00:03:18.590
a local vulnerability into one
that can be exploited remotely,

00:03:18.780 --> 00:03:23.330
blurring the lines between local
and remote vulnerabilities.

00:03:23.440 --> 00:03:27.720
Things to consider with the local or
social engineering attacks include:

00:03:27.770 --> 00:03:31.960
Does your application even briefly
run with elevated privileges?

00:03:32.050 --> 00:03:37.510
Does it allow code plug-ins or store
potentially valuable user information?

00:03:38.050 --> 00:03:40.430
We've talked about
several types of attacks.

00:03:40.480 --> 00:03:43.310
Now let's look at a few trends.

00:03:44.960 --> 00:03:49.800
The first is that systems are becoming
more networked at higher speeds and for

00:03:49.800 --> 00:03:53.010
longer periods of time wherever they go.

00:03:53.100 --> 00:03:56.820
This presents an increased
window of opportunity for remote

00:03:56.820 --> 00:03:59.300
and social engineering attacks.

00:03:59.410 --> 00:04:04.090
It also elevates the scope of
threats from a hacked system.

00:04:04.370 --> 00:04:07.480
Second trend: botnets.

00:04:07.480 --> 00:04:11.400
It's no longer the sole hacker
going after a single system.

00:04:11.540 --> 00:04:16.400
Automated tools are freely obtainable
to exploit vulnerabilities in

00:04:16.400 --> 00:04:19.270
remote services or weak passwords.

00:04:19.770 --> 00:04:22.860
These botnets are self-replicating.

00:04:22.960 --> 00:04:27.750
Individuals with little or no programming
skills can build a network of around

00:04:27.910 --> 00:04:31.070
1,000 hacked systems within a week.

00:04:31.170 --> 00:04:34.500
We have reports of organized
crime groups running networks

00:04:34.670 --> 00:04:37.810
of 50,000 to 80,000 bots.

00:04:40.200 --> 00:04:44.530
Sophisticated rootkits are then
used to secure a hacked system,

00:04:44.600 --> 00:04:49.000
protecting it from being taken
over by competing botnets.

00:04:49.000 --> 00:04:52.800
These rootkits will gather sensitive
information through various means

00:04:52.800 --> 00:04:57.960
and set up communication channels for
propagation and further instructions.

00:04:57.960 --> 00:05:01.360
A group that tracks botnets
has reported the following

00:05:01.380 --> 00:05:03.600
statistics over the last week.

00:05:03.600 --> 00:05:05.800
So this is just over the last week.

00:05:05.800 --> 00:05:11.170
Number of newly infected
systems by unique IP address.

00:05:11.770 --> 00:05:18.990
2,915,791 newly infected
systems just over the past week.

00:05:19.420 --> 00:05:24.240
They're seeing around 981 active
botnets and they're finding

00:05:24.240 --> 00:05:29.140
around 25 new botnets each day.

00:05:29.140 --> 00:05:32.900
The following is an example
of a 100,000 system botnet

00:05:32.920 --> 00:05:34.850
that was recently discovered.

00:05:35.330 --> 00:05:38.940
And in case people can't read this,
I'll read it for you.

00:05:39.070 --> 00:05:42.700
It's dated March 30th, and it says,
"Chinese authorities said

00:05:42.700 --> 00:05:47.890
they've arrested a man accused of
hacking into 100,000 computers.

00:05:47.960 --> 00:05:52.730
Coordinated attacks were manipulated
by the hacker after he gained access

00:05:52.730 --> 00:05:55.260
to the PCs through the use of a virus.

00:05:55.320 --> 00:06:00.060
Up to 40,000 of the affected
machines may be abroad."

00:06:02.270 --> 00:06:08.360
So with botnets, the attack trends have
evolved beyond pure OS-level

00:06:08.400 --> 00:06:12.840
attacks to denial-of-service
attacks for fun and profit,

00:06:12.840 --> 00:06:16.520
with the highest activity and
focus on information theft.

00:06:16.700 --> 00:06:20.940
A lot more could be said about this,
and it's a thriving underground market.

00:06:21.200 --> 00:06:25.400
Banks and businesses are writing
off huge sums of money due to fraud.

00:06:25.480 --> 00:06:29.580
Certain groups are also going
after industry trade secrets,

00:06:29.580 --> 00:06:33.870
as well as classified government
and military information.

00:06:34.870 --> 00:06:38.000
Another trend is the growth of exploits.

00:06:38.100 --> 00:06:41.430
It only takes a single
person to create an exploit.

00:06:41.540 --> 00:06:45.820
That's nothing new, but with Botnets,
the exploit can now be plugged

00:06:45.820 --> 00:06:51.500
into various bot tools for rapid
propagation within a matter of hours.

00:06:51.900 --> 00:06:55.770
We're seeing exploits for
publicly disclosed issues appear

00:06:55.940 --> 00:07:00.320
faster and a decrease in the
grace period after notification

00:07:00.320 --> 00:07:02.980
before an exploit is released.

00:07:03.100 --> 00:07:08.360
Having said that, most problems come from
exploits attacking old,

00:07:08.400 --> 00:07:10.200
unpatched systems.

00:07:10.260 --> 00:07:13.980
So I guess this might be a system
administration talk after all.

00:07:14.060 --> 00:07:18.260
So to summarize,
attacks can be in the form of remote,

00:07:18.260 --> 00:07:21.090
local, or social engineering.

00:07:21.140 --> 00:07:25.090
Social engineering attacks can turn
a vulnerability that you thought

00:07:25.100 --> 00:07:27.990
was only local into a remote one.

00:07:28.060 --> 00:07:31.780
The window of opportunity for remote
attacks is increasing with more

00:07:31.780 --> 00:07:34.870
pervasive and faster networking.

00:07:35.390 --> 00:07:39.290
Botnets with tens of thousands
of systems are out there.

00:07:39.380 --> 00:07:43.420
More and more, attacks are focusing in
increasingly sophisticated ways

00:07:43.510 --> 00:07:46.100
to get valuable information.

00:07:46.280 --> 00:07:49.680
Attack tools are easily obtainable,
and it only takes one

00:07:49.680 --> 00:07:53.660
person to create an exploit,
which is then shared and quickly

00:07:53.660 --> 00:07:57.690
disseminated across a large
range of attacking systems.

00:07:58.110 --> 00:08:01.460
So with those happy thoughts in mind,
I'll now turn it over to

00:08:01.490 --> 00:08:05.930
Richard Murphy to talk about
the multi-user environment.

00:08:05.930 --> 00:08:05.930
Thank you.

00:08:07.900 --> 00:08:10.690
Hello.

00:08:10.860 --> 00:08:14.700
So I'm here to talk about
Mac OS X being multi-user,

00:08:14.870 --> 00:08:16.700
but I'm really kind of curious.

00:08:16.870 --> 00:08:20.700
When we started off doing this session,
we'd originally wanted to make it

00:08:20.720 --> 00:08:25.300
to help out application developers
make their applications more secure.

00:08:25.740 --> 00:08:30.170
In particular,
we had some requests to make of you that

00:08:30.200 --> 00:08:35.000
would help us out in our job to help make
OS X one of the most secure OSs we have.

00:08:35.110 --> 00:08:40.230
Because if you look at the environment,
the environment of Mac OS X is not only

00:08:40.230 --> 00:08:43.450
the OS and the apps that we provide,
but the apps that all

00:08:43.450 --> 00:08:44.740
of you guys provide.

00:08:44.850 --> 00:08:50.940
How many saw Bertrand and
Scott Forstall's meeting yesterday?

00:08:52.310 --> 00:08:56.210
Okay, you notice how they went 11 down
through one of all the things

00:08:56.320 --> 00:08:58.300
to make your applications great?

00:08:59.270 --> 00:09:00.870
Everybody?

00:09:01.280 --> 00:09:02.360
Okay, we're all programmers here.

00:09:02.360 --> 00:09:04.200
We know there has to be a zero.

00:09:04.250 --> 00:09:06.840
Number zero, please make it secure.

00:09:07.010 --> 00:09:10.300
So as we go through this,
keep in mind all of these things

00:09:10.300 --> 00:09:13.160
as you're making your applications.

00:09:16.800 --> 00:09:19.910
Okay, so Mac OS X has home directories.

00:09:20.010 --> 00:09:23.950
This is a key component
in having a multi-user OS.

00:09:24.130 --> 00:09:28.820
Home directories are places for
people to keep all of their stuff.

00:09:29.000 --> 00:09:31.640
In Mac OS 9,
it used to be kind of ad hoc.

00:09:31.680 --> 00:09:35.460
People would make certain directories,
and they'd put their documents there,

00:09:35.500 --> 00:09:39.090
and sometimes applications would
adhere to where they put their

00:09:39.090 --> 00:09:42.200
documents using nav services,
and sometimes they'd just bury it

00:09:42.200 --> 00:09:44.790
inside the applications folder.

00:09:46.460 --> 00:09:50.290
Mac OS X,
we actually partitioned or preformatted

00:09:50.300 --> 00:09:52.500
a home directory for users.

00:09:52.530 --> 00:09:55.830
The first thing we did is we
made a documents directory.

00:09:56.080 --> 00:09:59.380
So if you have an application
that deals with document formats,

00:09:59.390 --> 00:10:03.500
like Word, or possibly an accounting
program or something like that,

00:10:03.540 --> 00:10:07.000
this is a place we expect
you to put the user's data.

00:10:08.840 --> 00:10:12.810
Library is actually used
to keep the preferences,

00:10:12.830 --> 00:10:16.170
logs, caches,
and anything else that needs to have

00:10:16.170 --> 00:10:18.400
a little bit more restricted access.

00:10:18.560 --> 00:10:22.010
Documents might want to be shared,
but preferences usually you

00:10:22.010 --> 00:10:23.520
don't want to have shared.

00:10:23.690 --> 00:10:26.120
You don't want to have other
people messing with it unless

00:10:26.120 --> 00:10:28.150
it's a managed environment.

00:10:29.040 --> 00:10:31.540
Finally, we have the public directory.

00:10:31.700 --> 00:10:35.940
This is the place where we explicitly
made it to put shared documents.

00:10:36.050 --> 00:10:38.690
You actually have the Dropbox in there.

00:10:39.540 --> 00:10:41.940
Finally, we have music and movies.

00:10:41.940 --> 00:10:43.500
We partition that out.

00:10:43.590 --> 00:10:46.600
iTunes keeps its music
in the music directory.

00:10:46.640 --> 00:10:49.500
If you have other applications,
it would be a good place to keep music.

00:10:49.660 --> 00:10:52.100
And same thing with movies.

00:10:56.990 --> 00:10:59.650
Mac OS X has a couple
home directory types.

00:10:59.780 --> 00:11:01.200
There's normal home directories.

00:11:01.260 --> 00:11:05.300
These are the ones that are
created by default for every user.

00:11:05.400 --> 00:11:08.030
If you want to be a
little bit more secure,

00:11:08.030 --> 00:11:11.440
or a lot more secure,
you can make a FileVault home directory.

00:11:11.520 --> 00:11:16.400
FileVault home directories aren't ever
mounted till the user actually logs in.

00:11:16.490 --> 00:11:17.620
They're encrypted on disk.

00:11:17.770 --> 00:11:23.070
They're actually a disk image,
an encrypted disk image using AES-128.

00:11:24.030 --> 00:11:26.120
If you store your files
into a file vault,

00:11:26.190 --> 00:11:27.900
it adds a lot of protection.

00:11:28.040 --> 00:11:32.740
However, if an application keeps its
temporary files in other places

00:11:33.100 --> 00:11:35.980
other than the home directory,
you have to wonder a little

00:11:35.980 --> 00:11:37.900
bit how safe that actually is.

00:11:38.020 --> 00:11:41.990
So one of the things as an application
developer is make sure that if you're

00:11:41.990 --> 00:11:46.010
dealing with users' document data,
you keep temporary files somewhere

00:11:46.010 --> 00:11:48.210
within the user's home directory.

00:11:49.270 --> 00:11:54.200
By default, FileVault is unreadable by
any other users on the system.

00:11:54.260 --> 00:11:57.150
One of the other things to keep
in mind is it isn't available

00:11:57.260 --> 00:11:58.700
if the user's logged out.

00:11:58.760 --> 00:12:00.910
So if you want to have
a long-running process,

00:12:01.100 --> 00:12:03.790
you'll need to make special arrangements.

00:12:04.060 --> 00:12:06.560
Also, there's network home directories.

00:12:06.620 --> 00:12:10.740
Network home directories are used
a lot at various institutions.

00:12:10.780 --> 00:12:12.940
They have really different
operating semantics.

00:12:13.010 --> 00:12:16.350
One of the things about a networked home
directory is that it can be used by two

00:12:16.520 --> 00:12:19.280
different computers at the same time.

00:12:19.400 --> 00:12:22.070
If a user has two
computers at their desk,

00:12:22.190 --> 00:12:24.330
or three or four,
they can actually log into the same

00:12:24.330 --> 00:12:26.320
home directory at the same time.

00:12:26.360 --> 00:12:29.150
This obviously creates some
data integrity issues if

00:12:29.150 --> 00:12:31.510
you don't program for that.

00:12:33.630 --> 00:12:37.000
Make sure that you play well
with the user's home directory.

00:12:37.130 --> 00:12:39.500
Don't change permissions on files.

00:12:39.620 --> 00:12:46.500
We've seen some applications at times
whose installers will actually go out and

00:12:46.500 --> 00:12:49.370
just because it's a little bit easier,
they make permissions 777.

00:12:49.500 --> 00:12:53.500
It's really easy to dump files
into places that are 777.

00:12:53.680 --> 00:12:56.490
Unfortunately,
it isn't real safe for the user's files.

00:12:56.500 --> 00:13:00.430
So, pay attention to the permissions the
user set in their home directory.

00:13:00.490 --> 00:13:01.500
Work well with them.

00:13:01.500 --> 00:13:04.980
Don't change them spuriously.

00:13:05.320 --> 00:13:10.020
And by the way, if you change them to 777
and then put them back,

00:13:10.230 --> 00:13:11.340
is that safe?

00:13:13.100 --> 00:13:14.660
It still leaves it open.

00:13:14.660 --> 00:13:18.500
There's always that little bit of time
where it's open for a little bit while

00:13:18.500 --> 00:13:22.140
you're fiddling with the permissions
that you've left the user exposed.

00:13:22.160 --> 00:13:25.030
So make sure you play
well for the whole time.

00:13:31.420 --> 00:13:33.600
Use the provided
directories where you can.

00:13:33.740 --> 00:13:37.300
Don't just make things just because
we're a little bit different.

00:13:37.300 --> 00:13:41.180
If you want to make something special
for the user to keep their documents in,

00:13:41.310 --> 00:13:44.300
put it into the documents directory.

00:13:44.440 --> 00:13:48.710
So if you want to group all of your
applications' files and data files,

00:13:48.800 --> 00:13:50.280
that's a good way to do it.

00:13:50.390 --> 00:13:54.780
But don't, in the home directory,
make another directory to keep them in.

00:13:56.470 --> 00:13:57.400
This will help out the user.

00:13:57.400 --> 00:13:59.600
It helps them organize their files.

00:13:59.650 --> 00:14:02.860
I know that we want to go with
Spotlight to the nested folders

00:14:02.860 --> 00:14:06.180
don't really matter anymore,
but if you're backing up,

00:14:06.250 --> 00:14:08.020
nested folders do a little bit.

00:14:08.020 --> 00:14:12.010
It really helps you find things
that you want to back up.

00:14:13.710 --> 00:14:18.140
The user actually controls all of
their data in their home directory.

00:14:18.190 --> 00:14:20.010
Make sure you keep this in mind.

00:14:20.120 --> 00:14:22.430
Don't help them out
because you know better.

00:14:22.520 --> 00:14:25.560
Don't help them out because it
makes your application easier.

00:14:25.610 --> 00:14:28.760
Make sure you adhere to their policies.

00:14:31.550 --> 00:14:33.830
Fast User Switching.

00:14:33.830 --> 00:14:36.550
We introduced fast user
switching in Panther.

00:14:37.200 --> 00:14:41.340
And we had some growing pains
while we were doing that.

00:14:41.410 --> 00:14:44.330
All of a sudden we found a few
applications that actually used shared

00:14:44.330 --> 00:14:48.900
memory regions that were global to
the whole system when you used them.

00:14:49.040 --> 00:14:52.210
If you actually had two users
on the system accessing the

00:14:52.210 --> 00:14:55.380
same application at once,
they were having data integrity

00:14:55.380 --> 00:14:58.300
problems because the shared
memory regions were colliding.

00:14:58.450 --> 00:15:02.300
The other thing is that a shared memory
region used in this way could be used

00:15:02.300 --> 00:15:05.990
as a way to actually ship data between
two users that the administrator

00:15:05.990 --> 00:15:07.900
might not want to have happen.

00:15:07.900 --> 00:15:10.890
Or it could be a way of eavesdropping.

00:15:13.400 --> 00:15:15.400
So while you're developing
your application,

00:15:15.460 --> 00:15:19.800
keep in mind fast user switching,
the fact that you might be backgrounded,

00:15:19.810 --> 00:15:24.300
the fact that multiple users might want
to use your application at the same time.

00:15:24.460 --> 00:15:28.020
Sometimes you might not want to allow
that for licensing restrictions,

00:15:28.020 --> 00:15:30.380
and sometimes you might
want to play off of that.

00:15:30.740 --> 00:15:34.090
These are all business
decisions you need to make.

00:15:36.600 --> 00:15:43.700
[Transcript missing]

00:15:44.750 --> 00:15:48.440
Some applications actually
are really system resources.

00:15:48.460 --> 00:15:52.550
Most backup applications, for instance,
are actually a full system resource.

00:15:52.690 --> 00:15:56.240
They need to be able to see the whole
system image while they do their work.

00:15:56.260 --> 00:15:59.400
In these cases,
it's far better off not to actually

00:15:59.500 --> 00:16:04.400
have to have a user logged in in order
for the application to actually work.

00:16:04.420 --> 00:16:08.760
When you're put into that kind of a case,
you need to demonize and move

00:16:08.760 --> 00:16:11.040
yourself into the root bootstrap.

00:16:11.040 --> 00:16:16.040
You have to be very careful about
when you actually put up dialogues.

00:16:16.060 --> 00:16:19.760
We have a lot of cases right now
of dialogues popping up over the

00:16:19.850 --> 00:16:24.330
login window and exploits of that
where people actually gain root.

00:16:24.380 --> 00:16:26.340
We're trying to close all of these down.

00:16:26.500 --> 00:16:28.380
Some of this is our problem.

00:16:28.550 --> 00:16:30.840
Some of this is third-party problems.

00:16:30.860 --> 00:16:34.080
And so keep this in mind while you're
working with your applications.

00:16:34.080 --> 00:16:38.940
And of course, we'll be working on our
problems on that route as well.

00:16:39.080 --> 00:16:41.040
Startup items.

00:16:41.570 --> 00:16:46.680
/library/startupitems permissions
have actually been changed in Tiger.

00:16:46.990 --> 00:16:53.040
We won't blindly launch startup items
that are actually writable by admin.

00:16:53.300 --> 00:18:11.500
[Transcript missing]

00:18:11.800 --> 00:18:14.200
You can either disable it,
or you can fix the

00:18:14.200 --> 00:18:15.700
permissions on the spot.

00:18:15.810 --> 00:18:19.400
If you disable it,
what happens right now is a .disabled

00:18:19.400 --> 00:18:23.690
file gets created in the startup item,
which can be later on removed.

00:18:23.700 --> 00:18:25.840
It's a little bit clunky,
but it actually works,

00:18:25.840 --> 00:18:28.700
and it helps us stop the security hole.

00:18:28.910 --> 00:18:34.700
In the future, we'd just like to not
see this happen at all.

00:18:34.700 --> 00:18:38.830
So the other thing is
admin and normal users.

00:18:44.110 --> 00:18:46.400
When we started out on Cheetah,
all users,

00:18:46.500 --> 00:18:51.580
we actually created an admin account and
we created a separate normal account.

00:18:52.770 --> 00:18:56.700
And this really,
it didn't fit well with the whole,

00:18:56.700 --> 00:19:00.420
we're kind of like Mac OS 9 and now
we have Mac OS X and it runs about

00:19:00.740 --> 00:19:03.740
everything at least as good as Mac OS 9.

00:19:03.800 --> 00:19:08.020
And so we've kind of gone along
making admin users the default.

00:19:08.250 --> 00:19:11.530
A lot of people are seeing that this
is actually a little bit of a problem,

00:19:11.530 --> 00:19:16.770
since we offer so many opportunities
for admin users to rewrite things.

00:19:16.930 --> 00:19:20.100
So, a lot of users are doing what
we did in the first place.

00:19:20.240 --> 00:19:23.550
They're creating an admin account,
then they're creating

00:19:23.550 --> 00:19:25.400
a normal user account.

00:19:25.550 --> 00:19:29.740
Normal user accounts can simply
escalate privilege to do things.

00:19:29.850 --> 00:19:33.010
You actually have to supply
an admin login and an admin

00:19:33.010 --> 00:19:35.610
password in order to do so.

00:19:36.030 --> 00:19:39.980
Normal users aren't in group admin,
so they don't have access to

00:19:39.980 --> 00:19:44.100
some of the writable directories
that we've left out there.

00:19:44.210 --> 00:19:47.570
Unfortunately,
what we found is a lot of applications

00:19:47.570 --> 00:19:50.200
don't deal well with non-admin users.

00:19:50.310 --> 00:19:53.170
Either their installers
don't do the right things as

00:19:53.170 --> 00:19:55.700
far as authorization goes,
or the application,

00:19:55.700 --> 00:19:59.750
once it's installed by an admin user,
the user's actually backed out,

00:19:59.760 --> 00:20:03.800
used their admin account to install it,
and come back in as a normal user,

00:20:03.940 --> 00:20:06.870
The application just plain doesn't work.

00:20:07.070 --> 00:20:09.240
Usually,
this is a matter of the application

00:20:09.240 --> 00:20:13.460
hasn't used the right directories
in the user's home directory.

00:20:14.010 --> 00:20:17.080
If there's other reasons that
your application doesn't work,

00:20:17.080 --> 00:20:21.380
contact your developer relations person
to help give you some advice on how to

00:20:21.380 --> 00:20:23.200
make things work a little bit better.

00:20:23.260 --> 00:20:29.000
We'd really like to see the normal user
operation be very good in most cases.

00:20:31.520 --> 00:20:34.620
One of the tools you can actually
use to help yourself out in

00:20:34.620 --> 00:20:37.890
this is the authorization APIs.

00:20:38.180 --> 00:20:41.240
If you actually need to
temporarily escalate privilege,

00:20:41.240 --> 00:20:44.640
you can actually make an
authorization call to do it.

00:20:44.770 --> 00:20:48.400
The documentation for this
is at the developer website.

00:20:49.000 --> 00:20:52.470
The other thing is that the
authorization APIs actually tie

00:20:52.470 --> 00:20:54.700
into the authorization dialogues.

00:20:54.820 --> 00:20:58.200
The authorization dialogues
aren't put up by your application.

00:20:58.290 --> 00:21:01.440
They're actually put up as a
client of the security daemon.

00:21:02.370 --> 00:21:06.490
The coolest thing about this is,
if we add different ways to authenticate,

00:21:06.530 --> 00:21:10.340
like smart cards or biometrics
or voice recognition,

00:21:10.430 --> 00:21:13.690
you'll get that all for
free in your application.

00:21:13.940 --> 00:21:18.520
So, you can future-proof your application
by using the Sec APIs whenever you

00:21:18.520 --> 00:21:22.630
have to do privilege escalation.

00:21:22.750 --> 00:21:24.480
Keychains.

00:21:30.460 --> 00:21:33.000
So normal keychains are per user.

00:21:33.060 --> 00:21:36.200
Every user that has an
account gets a keychain.

00:21:36.260 --> 00:21:39.580
And by default,
the password for that keychain is

00:21:39.580 --> 00:21:42.240
synced with the login password.

00:21:42.260 --> 00:21:44.920
Hence, we call it the login keychain.

00:21:45.350 --> 00:21:49.190
In Panther and in Tiger,
the actual name of that

00:21:49.330 --> 00:21:51.590
keychain is login.keychain.

00:21:51.740 --> 00:21:55.470
Previous to Panther,
it was named after the user account.

00:21:55.780 --> 00:22:00.290
You can safely change the
name of that login keychain to

00:22:00.390 --> 00:22:06.830
login.keychain and it essentially
becomes a Panther/Tiger keychain.

00:22:07.190 --> 00:22:10.200
But users may have
more than one keychain.

00:22:10.300 --> 00:22:12.000
Matter of fact,
a lot of users are beginning to find

00:22:12.000 --> 00:22:13.800
that they like to group their data.

00:22:13.890 --> 00:22:17.100
They like to keep secure notes
in the secure note keychain.

00:22:17.210 --> 00:22:21.540
Or they might want to move off their
certificates into a certificate keychain.

00:22:21.650 --> 00:22:26.410
Or they might have specific web passwords
that they want to put into a separate

00:22:26.410 --> 00:22:29.300
keychain that has tighter controls on it.

00:22:29.840 --> 00:22:34.190
So,
when you're saving passwords for a user,

00:22:34.260 --> 00:22:37.690
if you pass a null to the
setKeychainItemCreate call,

00:22:37.790 --> 00:22:40.360
it'll actually save it to what's
called the default keychain.

00:22:40.440 --> 00:22:43.260
I'll go back into that
a little bit more later.

00:22:44.010 --> 00:22:47.040
So, some users might be a little
bit more security conscious,

00:22:47.050 --> 00:22:50.400
and they might use multiple
keychains to group these.

00:22:50.540 --> 00:22:53.400
So,
let's look at the special keychain types.

00:22:53.400 --> 00:22:57.910
There's the login keychain,
which is automatically unlocked at login.

00:22:58.910 --> 00:23:01.200
There's a thing called
the default keychain.

00:23:01.330 --> 00:23:04.500
This is the place where the
user wants to put new items.

00:23:04.620 --> 00:23:08.440
This is why you'd make that
call to item create with null.

00:23:08.530 --> 00:23:09.390
Don't change that.

00:23:09.650 --> 00:23:11.840
Don't hardwire the login keychain.

00:23:11.930 --> 00:23:13.660
If the user set a default
to a different place,

00:23:13.810 --> 00:23:16.140
they probably know where they want it.

00:23:17.430 --> 00:23:20.770
An important system-wide
keychain is X.509 Anchors.

00:23:21.020 --> 00:23:24.540
This includes all the
root certificates for CAs.

00:23:24.540 --> 00:23:29.140
This is actually kept in
/system/library/keychains

00:23:29.210 --> 00:23:32.530
and contains all the root
certificates that we've vetted.

00:23:32.960 --> 00:23:37.010
Finally, there's a system keychain,
which is used by system demons in

00:23:37.010 --> 00:23:40.520
order to keep passwords and other
private things that they need,

00:23:40.570 --> 00:23:46.210
basically, even if there's no user
logged into the system at all.

00:23:48.930 --> 00:23:50.840
User Keychains.

00:23:50.850 --> 00:23:53.910
An important thing to
remember about user keychains,

00:23:53.910 --> 00:23:57.740
this is almost like an admin note more
than an application developer's note,

00:23:57.770 --> 00:24:02.500
is that you can't reset a password
on a user's keychain if you

00:24:02.500 --> 00:24:05.060
don't know the original password.

00:24:05.110 --> 00:24:08.870
There was some documentation
or some article out of,

00:24:08.890 --> 00:24:12.350
I think it was in Macworld,
where somebody said,

00:24:12.370 --> 00:24:18.990
Change your login keychain password
immediately because if the admin actually

00:24:18.990 --> 00:24:23.100
gets in and changes your password,
they can get into your keychain.

00:24:23.170 --> 00:24:24.890
That's not true.

00:24:25.000 --> 00:24:29.590
The admin doesn't have whatever you
have set for your login and that

00:24:29.680 --> 00:24:31.900
keychain memorized somewhere else.

00:24:31.920 --> 00:24:33.400
They can't get into your login keychain.

00:24:33.500 --> 00:24:36.900
Now, if you didn't change your
login password immediately,

00:24:36.900 --> 00:24:40.450
yes, the admin presumably could
actually get at that.

00:24:40.870 --> 00:24:44.170
The other thing is that the
security daemon acts as the

00:24:44.170 --> 00:24:46.840
arbiter of keychain access control.

00:24:47.010 --> 00:24:49.810
When a process actually wants
to get at a keychain item,

00:24:49.930 --> 00:24:53.140
it actually makes a request
to the security daemon.

00:24:53.300 --> 00:25:00.790
The security daemon evaluates an
ACL that's set on a keychain item.

00:25:00.790 --> 00:25:00.790
This has existed since at least Cheetah.

00:25:01.270 --> 00:25:05.000
and it determines whether or not
that particular application is

00:25:05.070 --> 00:25:07.850
allowed to have access to the item.

00:25:08.150 --> 00:25:10.910
There's never a point where a whole
keychain is read into the process

00:25:10.910 --> 00:25:13.380
address space of the calling process.

00:25:13.420 --> 00:25:17.370
It's all arbitrated through
the security daemon.

00:25:18.360 --> 00:25:22.260
All private key operations themselves,
for SMIME and SSL and

00:25:22.260 --> 00:25:24.360
all that kind of stuff,
are actually performed

00:25:24.360 --> 00:25:28.470
within the security daemon,
not within the user address space.

00:25:30.560 --> 00:25:34.240
So user keychains are excellent
places to keep passwords.

00:25:34.240 --> 00:25:35.600
We've made them pretty darn safe.

00:25:35.600 --> 00:25:37.700
They're triple-des protected.

00:25:37.710 --> 00:25:43.000
And they're cryptographically strong
for the private portion of the item.

00:25:43.000 --> 00:25:45.600
If you'll notice,
if you ever dump a keychain,

00:25:45.600 --> 00:25:48.790
you'll have the label portion,
which might include the website,

00:25:48.800 --> 00:25:53.300
but the password, the private portion,
is actually encrypted.

00:25:53.320 --> 00:25:58.700
And that brings us up to data
handling with Aaron Sigel.

00:25:58.700 --> 00:25:59.540
Thanks.

00:25:59.540 --> 00:26:01.860
Hey, Er.

00:26:01.900 --> 00:26:03.070
Hey.

00:26:11.800 --> 00:26:13.500
Hi, I'm Ron Dumont,
and I'm here to talk to

00:26:13.500 --> 00:26:15.510
you about data handling.

00:26:15.830 --> 00:26:19.700
Basically, why should you care
what I'm about to say?

00:26:19.950 --> 00:26:24.170
Your reputation is on the line not
only as an application developer,

00:26:24.170 --> 00:26:25.610
but your company and also your product.

00:26:25.700 --> 00:26:27.700
So, what are we talking about?

00:26:27.810 --> 00:26:29.700
We're talking about two things here.

00:26:29.700 --> 00:26:33.700
One of them is privacy,
and the other one is protection.

00:26:33.700 --> 00:26:37.700
Both of them have
slightly different goals.

00:26:37.880 --> 00:26:39.700
First, privacy is about keeping
your data secret.

00:26:40.170 --> 00:26:43.700
Protection is more about stopping
someone from modifying your data

00:26:43.700 --> 00:26:45.700
or someone from destroying it.

00:26:45.700 --> 00:26:48.820
So, we'll go into the two first,
and then I'll show some

00:26:48.830 --> 00:26:50.730
examples of employing them.

00:26:51.160 --> 00:26:52.900
Privacy.

00:26:53.100 --> 00:26:56.600
What we're talking about
is what to keep private.

00:26:56.680 --> 00:27:00.100
Well, financial data,
intellectual property, all those things,

00:27:00.120 --> 00:27:00.140
right?

00:27:00.200 --> 00:27:02.720
But in a greater sense,
it's really anything you wouldn't

00:27:02.770 --> 00:27:05.550
want to have on a billboard
on the side of the highway,

00:27:05.550 --> 00:27:05.760
right?

00:27:05.840 --> 00:27:09.030
I mean,
you don't want everyone to see things.

00:27:09.120 --> 00:27:11.630
So where do people go wrong
when they're trying to employ

00:27:11.690 --> 00:27:13.630
privacy in their applications?

00:27:13.670 --> 00:27:15.990
Well, first of all,

00:27:16.130 --> 00:27:19.200
If you don't use the
right file permissions,

00:27:19.200 --> 00:27:22.290
then it's sort of game over unless
you're using encryption too.

00:27:22.300 --> 00:27:23.400
We'll talk about that.

00:27:23.510 --> 00:27:26.000
So basically,
if you want to keep a file secret,

00:27:26.010 --> 00:27:29.940
you shouldn't have it world readable
unless the contents are encrypted.

00:27:29.980 --> 00:27:35.470
Now, you shouldn't assume that the file
is not going to be accessed by anyone

00:27:35.880 --> 00:27:39.040
because the system administrator can
override any BSD file permissions.

00:27:39.100 --> 00:27:42.540
So if you're trying to protect
something beyond the scope

00:27:42.540 --> 00:27:44.830
of the system administrator,
then you should probably

00:27:44.840 --> 00:27:46.060
look into encryption.

00:27:46.530 --> 00:27:50.640
Another place where people fall short
is by logging too much information

00:27:50.640 --> 00:27:54.420
or providing error messages
with secret information in them.

00:27:54.490 --> 00:27:57.220
So you have to make sure that if
you're about to log something into,

00:27:57.260 --> 00:28:00.660
let's say, a world-readable location,
you're not about to log some sort

00:28:00.670 --> 00:28:02.560
of secret credential in there.

00:28:02.920 --> 00:28:06.620
Some people do employ some encryption,
but there are two places

00:28:06.620 --> 00:28:08.800
where applications go wrong.

00:28:08.820 --> 00:28:13.800
The first one is by not using encryption,
period.

00:28:13.800 --> 00:28:16.800
But if they do,
sometimes they use the wrong encryption.

00:28:16.800 --> 00:28:20.840
They think if they come up with their
own algorithm to obfuscate the data,

00:28:20.960 --> 00:28:21.800
that's fine.

00:28:21.800 --> 00:28:24.800
But it turns out that most of
the time people get it wrong.

00:28:24.800 --> 00:28:26.800
It's very hard to write a
secure crypto algorithm,

00:28:26.800 --> 00:28:31.730
and so basically you should stick
to the things that are out there,

00:28:31.790 --> 00:28:33.770
which I'll talk about in a minute.

00:28:33.850 --> 00:28:35.800
And finally, if you're going to handle
sensitive information,

00:28:35.800 --> 00:28:39.810
like someone's banking information,
you should make sure you actually

00:28:39.810 --> 00:28:41.790
employ some form of security.

00:28:41.800 --> 00:28:44.800
You'd be surprised at the number of
applications where people just expect

00:28:44.800 --> 00:28:48.780
that they're getting something secure,
and clear text sensitive information

00:28:48.790 --> 00:28:52.710
is being written in world-readable
locations on their home directory.

00:28:53.160 --> 00:28:55.590
So that's privacy.

00:28:55.640 --> 00:28:58.710
And protection has to do
with the destruction and

00:28:58.710 --> 00:29:00.500
modification of your data.

00:29:00.590 --> 00:29:02.400
So you want to make
sure you're protecting,

00:29:02.400 --> 00:29:09.360
obviously, important information,
reports, anything along those lines.

00:29:09.450 --> 00:29:12.920
But you also have to make sure you're
protecting your system configuration

00:29:12.980 --> 00:29:17.240
files and any resource that can
modify your system configuration.

00:29:17.380 --> 00:29:19.620
Because obviously,
if somebody can modify your

00:29:19.620 --> 00:29:22.440
system to make it less secure,
then your system can

00:29:22.440 --> 00:29:24.030
be compromised easier.

00:29:24.040 --> 00:29:26.330
And finally,
you should make sure that you're

00:29:26.390 --> 00:29:29.600
protecting the content that
your application is creating.

00:29:29.600 --> 00:29:32.740
You don't want to have a user,
another user on a system,

00:29:32.740 --> 00:29:36.270
come along and blow away all of
the content that someone's just

00:29:36.290 --> 00:29:37.250
created with your application.

00:29:37.280 --> 00:29:41.320
So once again, where people fall short
with protection is,

00:29:41.480 --> 00:29:46.240
first of all, just in the implementation
of the BSD file permissions.

00:29:47.010 --> 00:29:48.550
Um...

00:29:48.790 --> 00:29:52.300
So the first thing is you need to make
sure you have good file permissions,

00:29:52.300 --> 00:29:54.700
and you have to make sure that
you're also protecting users from,

00:29:54.710 --> 00:29:57.680
make sure that a piece of
data hasn't been modified.

00:29:57.720 --> 00:30:00.320
Then you want to make sure you
sign it and that you've kept

00:30:00.320 --> 00:30:03.300
your keys secret and all that.

00:30:03.750 --> 00:30:07.000
In addition,
you want to make sure that obviously you

00:30:07.080 --> 00:30:11.690
do error checking and input validation,
but Simon will talk more about those.

00:30:11.700 --> 00:30:15.460
So we've hit privacy and protection,
and the question is sort of how

00:30:15.540 --> 00:30:17.700
does that relate to the real world?

00:30:17.700 --> 00:30:21.670
So here's a sample, you know,
install of an application,

00:30:21.720 --> 00:30:24.690
and where privacy and
protection come into play.

00:30:24.700 --> 00:30:29.690
So you can see protection has that icon,
and privacy has the little

00:30:29.800 --> 00:30:34.200
confidential folder,
so that'll come into play here.

00:30:34.480 --> 00:30:37.770
So first we have the application itself.

00:30:37.770 --> 00:30:40.540
And you install it into its
directory in /applications.

00:30:40.620 --> 00:30:44.170
And the important thing to notice here
is we have a little protection icon on it

00:30:44.320 --> 00:30:47.290
because it's not writable by other users.

00:30:47.390 --> 00:30:49.290
It's only writable by root.

00:30:49.440 --> 00:30:53.400
So the reason why this is important
is because you want to make sure that

00:30:53.400 --> 00:30:57.570
if something comes along and tries to
replace the content of this application,

00:30:57.700 --> 00:31:02.400
like Trojan it or install some bundles
inside it or anything like that,

00:31:02.400 --> 00:31:04.760
that it's going to have
to be authorized first.

00:31:04.870 --> 00:31:08.600
So that's a level of protection
you have against a piece of malware

00:31:08.600 --> 00:31:12.670
coming along or another user and
just monkeying with what you have.

00:31:14.610 --> 00:31:17.280
Murph mentioned startup items.

00:31:17.570 --> 00:31:21.990
This is the exact same reason why
you'd want to secure your application.

00:31:22.000 --> 00:31:24.000
Your startup item is also executed.

00:31:24.070 --> 00:31:26.290
It's executed as root, usually.

00:31:26.500 --> 00:31:29.660
And if you don't have the
right permissions on it,

00:31:29.810 --> 00:31:32.100
then it actually won't start now.

00:31:32.100 --> 00:31:34.870
You'll have to deal
with the security fixer,

00:31:35.210 --> 00:31:38.100
which we can talk about later.

00:31:38.220 --> 00:31:41.300
And this is also anecdotally,
this is where Opener attacked.

00:31:41.480 --> 00:31:46.380
So Murph mentioned that there were
issues with people inserting Trojans

00:31:46.380 --> 00:31:48.100
into startup items directories.

00:31:48.160 --> 00:31:50.320
This is how it happened,
because there were

00:31:50.320 --> 00:31:51.930
insecure permissions here.

00:31:53.970 --> 00:31:57.620
Now, obviously,
Murph mentioned that you can store

00:31:57.620 --> 00:32:00.740
cryptographically secure information,
like you can secure private

00:32:00.740 --> 00:32:02.420
information using the keychain.

00:32:02.440 --> 00:32:05.190
That's where we think you
should store all credentials.

00:32:05.190 --> 00:32:07.670
Not only because it's
cryptographically secure and it

00:32:07.670 --> 00:32:10.500
won't be storing any passwords,
clear text on disk,

00:32:10.540 --> 00:32:13.300
but it also has some other benefits,
like, you know,

00:32:13.480 --> 00:32:17.040
if somebody's got it inside their
home directory in their keychain,

00:32:17.040 --> 00:32:18.840
then they can take it with
them wherever they go,

00:32:18.840 --> 00:32:22.640
and it's also only available when they're
mounted if they're using FileVault.

00:32:22.720 --> 00:32:28.530
And unfortunately, though,
it's only appropriate for, you know,

00:32:28.620 --> 00:32:31.140
passwords or secure notes, small things.

00:32:31.270 --> 00:32:34.110
So for larger content,
you can actually create

00:32:34.110 --> 00:32:36.660
encrypted disk images,
which are just disk

00:32:36.660 --> 00:32:40.240
images that are encrypted,
similar to how FileVault gets

00:32:40.320 --> 00:32:44.440
your home directory secure,
and it provides you a

00:32:44.440 --> 00:32:45.930
level of privacy on,

00:32:46.190 --> 00:32:48.260
on your secure content.

00:32:48.440 --> 00:32:51.240
So where does everything else live?

00:32:51.240 --> 00:32:53.900
This is inside the user's home directory.

00:32:53.900 --> 00:32:57.440
Inside, their preferences should be
stored in the user domain.

00:32:57.440 --> 00:33:00.520
The log files should be stored
in the user's log files.

00:33:00.600 --> 00:33:03.760
Temporary items and caches should
all live in the user's cache,

00:33:03.760 --> 00:33:05.950
and the reason for this is because,
first of all,

00:33:05.960 --> 00:33:08.500
library has more restrictive
permissions by default,

00:33:08.500 --> 00:33:11.870
so you don't have to worry about
other users coming in there and,

00:33:11.870 --> 00:33:16.280
you know, modifying those files,
because this is a place where that user

00:33:16.280 --> 00:33:19.690
specifically should be storing content.

00:33:19.920 --> 00:33:23.200
Also, remember that just because
you've got content living inside

00:33:23.200 --> 00:33:26.020
the user's home directory,
and it might be inside a directory

00:33:26.020 --> 00:33:28.550
that's got good permissions,
you still want to make sure that you

00:33:28.550 --> 00:33:31.460
encrypt anything that would be bad for,
let's say,

00:33:31.460 --> 00:33:33.100
the administrator to come along and read.

00:33:33.380 --> 00:33:36.350
You also want to make sure you're
encrypting other content just in

00:33:36.430 --> 00:33:38.290
case the system gets compromised.

00:33:38.460 --> 00:33:44.320
Privacy and protection:
There might be some resources

00:33:44.320 --> 00:33:48.300
you'd like to have system-wide.

00:33:48.300 --> 00:33:50.300
They should live in /library.

00:33:50.300 --> 00:33:55.300
You shouldn't be writing
to this as a regular user.

00:33:55.300 --> 00:33:58.300
This shouldn't have any
user-specific content in it.

00:33:58.300 --> 00:34:04.500
Make sure you don't set it up so that
users have to replace content in these

00:34:04.590 --> 00:34:07.300
directories or that anything in these
directories is considered secure.

00:34:07.300 --> 00:34:11.080
By definition,
they're system-wide and meant to

00:34:11.080 --> 00:34:13.620
be shared with multiple users.

00:34:14.420 --> 00:34:20.060
That was just one case of privacy and
protection in the file system case,

00:34:20.060 --> 00:34:24.270
but we actually have several different
technologies available to you to provide

00:34:24.270 --> 00:34:29.560
privacy and protection on the network
and also with other forms of local data.

00:34:29.560 --> 00:34:32.580
Obviously, there are different solutions,
and the right one, you know,

00:34:32.580 --> 00:34:34.500
there are multiple
choices for each thing,

00:34:34.500 --> 00:34:36.360
so you'd see what's appropriate
for your application.

00:34:36.360 --> 00:34:39.700
But the important thing is
that on the technologies,

00:34:39.710 --> 00:34:44.040
you can search for any of those on
developer.apple.com and get a lot of

00:34:44.040 --> 00:34:45.460
information about how to use them.

00:34:45.460 --> 00:34:49.260
This is a quick sheet that shows you
the breakdown of what they provide.

00:34:49.260 --> 00:34:51.860
And these are all technologies
that we think you should

00:34:51.870 --> 00:34:55.500
probably be implementing in your
application because by doing that,

00:34:55.500 --> 00:34:56.860
you get a lot more security.

00:34:56.860 --> 00:35:03.010
And so implementation is a large section
of an application that gets developed,

00:35:03.010 --> 00:35:05.160
sorry, specification.

00:35:05.160 --> 00:35:06.360
You want to specify what
you're going to use.

00:35:06.360 --> 00:35:09.360
You want to specify using
these in your application.

00:35:09.420 --> 00:35:13.930
But to actually talk about security
holes and how they implement themselves

00:35:13.940 --> 00:35:17.460
when you actually go to code,
here's Simon Cooper.

00:35:19.610 --> 00:35:22.360
I listed up there.

00:35:22.420 --> 00:35:25.300
Thank you, Aaron.

00:35:25.380 --> 00:35:28.010
So here's what I'm going
to talk about today.

00:35:28.230 --> 00:35:31.480
I'm going to talk a little bit about
where security problems come from,

00:35:31.550 --> 00:35:33.400
some common coding design pitfalls.

00:35:33.400 --> 00:35:35.800
I'm going to cover buffer
overflows and issue overflows,

00:35:35.890 --> 00:35:38.500
temporary file problems
with race conditions,

00:35:38.500 --> 00:35:41.200
some feature combining
things that can happen,

00:35:41.200 --> 00:35:45.190
and finally some
installation considerations.

00:35:46.110 --> 00:35:49.340
So, my colleagues have been talking
about decisions you make when

00:35:49.340 --> 00:35:52.600
you're designing your program,
the specification of your program.

00:35:52.730 --> 00:35:56.170
So, when you actually come
and build a program,

00:35:56.330 --> 00:35:59.550
you have a build program,
when you combine the

00:35:59.560 --> 00:36:02.640
specification and implementation,
they're never exactly going to match.

00:36:02.760 --> 00:36:05.710
There's always going to be some gaps.

00:36:06.080 --> 00:36:11.270
Now, on the left-hand side here,
that's the area that your QA organization

00:36:11.280 --> 00:36:15.230
or you will work on to eliminate,
you'll make that area smaller because

00:36:15.240 --> 00:36:17.240
it's what the program is not doing.

00:36:17.330 --> 00:36:20.900
You have a design for your program
and it's not meeting the expectations.

00:36:20.900 --> 00:36:23.140
It doesn't quite make it.

00:36:23.220 --> 00:36:24.330
So what's this other area?

00:36:24.430 --> 00:36:26.730
This other area on the right.

00:36:26.740 --> 00:36:29.630
This other area on the right
is things your program does,

00:36:29.630 --> 00:36:32.830
extra things that your program does,
that you may not be aware of.

00:36:33.040 --> 00:36:35.270
This is the area that
the bad guys work in.

00:36:35.540 --> 00:36:39.970
This is the area where if you designed
a program to handle some string and

00:36:39.970 --> 00:36:45.060
you pass it a really long string,
it behaves differently.

00:36:48.620 --> 00:36:53.940
So if you take all types of
exploits and all types of problems,

00:36:54.060 --> 00:36:57.090
buffer overflows are
the number one problem.

00:36:57.180 --> 00:37:01.070
And their experience and time
shows that about 50% of all

00:37:01.190 --> 00:37:03.500
problems are buffer overflows.

00:37:03.630 --> 00:37:05.400
So they're a big area.

00:37:05.470 --> 00:37:07.500
They've been there for a long, long time.

00:37:07.500 --> 00:37:11.100
The first buffer overflow was in 1998.

00:37:11.230 --> 00:37:12.880
That's a really long time ago.

00:37:13.050 --> 00:37:15.690
And things aren't really
getting any better.

00:37:16.500 --> 00:37:20.900
So the first thing to remember about
a buffer is it always has size.

00:37:20.980 --> 00:37:22.960
And that size is always
greater than or equal to zero.

00:37:23.070 --> 00:37:25.800
You can't have a negatively sized buffer.

00:37:27.700 --> 00:37:30.040
So if you don't obey these rules,
what things go wrong?

00:37:30.100 --> 00:37:33.680
Well, in a stack overflow,
you can modify the execution path and

00:37:33.840 --> 00:37:35.600
you can take control of the program.

00:37:35.600 --> 00:37:39.270
You can change function
arguments and you can modify

00:37:39.270 --> 00:37:43.310
local data so that the program,
if it was going to go and do something

00:37:43.310 --> 00:37:46.730
and store one piece of information,
will store something else.

00:37:47.450 --> 00:37:55.170
Stack Overflows are
usually trivial to exploit.

00:37:55.170 --> 00:37:55.170
That includes the PowerPC platform
as well as the Intel architecture.

00:37:55.650 --> 00:37:57.500
Heap overflows.

00:37:57.500 --> 00:38:00.500
They can also be exploited
in a very similar way.

00:38:00.500 --> 00:38:01.400
It's a little harder.

00:38:01.620 --> 00:38:05.490
You can modify program data and you
can change the flow of a program.

00:38:05.490 --> 00:38:09.500
And I'll give you an example of how
you can change the flow of a program.

00:38:09.810 --> 00:38:13.290
And they are very dangerous for C++ code.

00:38:14.160 --> 00:38:16.960
And finally,
and you have to remember this,

00:38:16.980 --> 00:38:21.030
the result of mallocing zero is not zero.

00:38:21.530 --> 00:38:23.540
I'll come back to that.

00:38:23.630 --> 00:38:27.780
So here's a typical
Mac OS X PowerPC stack frame.

00:38:27.830 --> 00:38:30.440
And you can see that the
stack frame goes down.

00:38:30.470 --> 00:38:33.880
And we have the caller,
we have parameter area,

00:38:33.900 --> 00:38:35.400
and a linkage area.

00:38:35.600 --> 00:38:37.940
And then it saves,
there's an area for saving registers,

00:38:37.970 --> 00:38:39.620
and then there's local variables.

00:38:39.660 --> 00:38:42.310
Now in this example,
we're gonna place a buffer

00:38:42.530 --> 00:38:46.260
in the local variables area.

00:38:46.290 --> 00:38:50.420
And when you overflow that,
what actually happens

00:38:51.450 --> 00:38:57.200
The buffer overflow grows up in address,
and overwrites saved registers,

00:38:57.200 --> 00:39:06.790
the linkage area, and the parameter area
of the calling routine.

00:39:08.740 --> 00:39:10.290
So that's a stack problem.

00:39:10.380 --> 00:39:12.470
Now, the Intel architecture is very,
very similar.

00:39:12.860 --> 00:39:15.880
You just shuffle these
things around a little bit.

00:39:18.330 --> 00:39:19.800
So here's a heap overflow.

00:39:19.940 --> 00:39:25.640
Now,
the malloc routines on Mac OS X are a

00:39:25.640 --> 00:39:27.540
little different than traditional Unixes.

00:39:28.010 --> 00:39:35.990
The control areas actually have their
data stored separately from the area

00:39:35.990 --> 00:39:38.630
that manages the allocation of space.

00:39:38.760 --> 00:39:44.270
This has some advantages in that if,
for example, you're doing double freeze,

00:39:44.600 --> 00:39:49.460
the Mac platform is usually resistant to
that kind of problem because you do not

00:39:49.460 --> 00:39:53.720
corrupt the heat pointers because the
heat pointers are not stored the same way

00:39:53.720 --> 00:39:55.560
as they would on a traditional platform.

00:39:55.560 --> 00:40:00.020
However, if you do have a buffer
that gets overflowed,

00:40:00.020 --> 00:40:02.170
you can cause problems.

00:40:02.210 --> 00:40:05.930
So in the bottom area
here on this diagram,

00:40:06.390 --> 00:40:08.640
there is a virtual C++ object.

00:40:08.720 --> 00:40:12.720
which will have function pointers in it,
and if you do a heap overflow

00:40:12.720 --> 00:40:16.260
into the next object,
then when you come and redirect through

00:40:16.260 --> 00:40:19.790
those virtual function pointers,
you will change the flow of the program.

00:40:19.800 --> 00:40:24.180
So you can exploit C++ programs
that are using virtual function

00:40:24.180 --> 00:40:28.790
pointers with a heap overflow.

00:40:31.690 --> 00:40:35.800
So what can you do to avoid
buffer and integer overflows?

00:40:35.910 --> 00:40:39.240
So I'm going to cover C mainly,
and then I'm going to talk a little

00:40:39.240 --> 00:40:44.100
bit about C++ and Objective-C,
and using some framework

00:40:44.530 --> 00:40:47.210
support to handle strings.

00:40:47.280 --> 00:40:48.770
And there's a little key here.

00:40:49.020 --> 00:40:50.590
The green stuff is things you should use.

00:40:50.830 --> 00:40:53.350
The red stuff is things you should avoid.

00:40:53.420 --> 00:40:56.470
So for safer buffer handling,
we're going to talk

00:40:56.510 --> 00:40:58.730
about some C functions.

00:40:58.830 --> 00:41:04.100
Everything you see here on the left
is something you shouldn't use.

00:41:04.280 --> 00:41:05.690
Things on the right are
things you should use.

00:41:05.700 --> 00:41:08.700
So there's the standard strcat, strcopy.

00:41:08.700 --> 00:41:10.700
Don't use those functions.

00:41:10.700 --> 00:41:15.020
You'll also notice that I've
listed strncat and strncopy

00:41:15.020 --> 00:41:16.700
on the left-hand side.

00:41:16.700 --> 00:41:20.660
And I'll talk about why those
functions are not so good in a minute.

00:41:20.700 --> 00:41:27.680
Also there's sprintf and vsprintf
and the old favorite gets.

00:41:27.910 --> 00:41:31.670
Now going briefly back to sprintf,
most people when they want to restrict

00:41:31.850 --> 00:41:38.700
the size of a string that they're
printing will use something like %10s.

00:41:38.900 --> 00:41:40.700
That's actually incorrect.

00:41:40.700 --> 00:41:44.070
What that really says there is the
minimum width that I'm going to

00:41:44.070 --> 00:41:45.700
allocate for that string is 10.

00:41:45.700 --> 00:41:47.700
It's not the maximum width.

00:41:47.700 --> 00:41:50.700
So if you actually had a string
which was 20 characters long,

00:41:50.700 --> 00:41:53.700
it would continue to
write into that area.

00:41:53.700 --> 00:42:01.090
What you really mean in
sprintf is percent 0.10s.

00:42:01.350 --> 00:42:07.220
To avoid that problem,
if you accidentally make that mistake,

00:42:07.230 --> 00:42:09.200
you can use snprintf,
as is indicated on the right-hand side.

00:42:09.300 --> 00:42:17.500
Now we're going to compare strcat
functions with strncat and strlcopy.

00:42:17.610 --> 00:42:22.030
One last thing:
always use unsigned variables

00:42:22.030 --> 00:42:24.300
for calculating sizes.

00:42:26.750 --> 00:42:30.740
So here we have a very
small program snippet.

00:42:30.750 --> 00:42:34.150
We're going to have a destination buffer,
which has space for five characters.

00:42:34.210 --> 00:42:35.800
We have a source buffer.

00:42:35.840 --> 00:42:39.300
And to start out,
we're going to put something tiny in it.

00:42:41.150 --> 00:42:47.050
So what happens when we use STR copy
from the source to the destination?

00:42:47.330 --> 00:42:50.360
What happens when we use STR in copy?

00:42:50.380 --> 00:42:53.370
And what happens when we use STR in copy?

00:42:53.740 --> 00:42:56.800
Well, in all three of these cases,
what actually happens is

00:42:57.130 --> 00:43:00.780
Tiny gets copied into the buffer,
and the gray area on the

00:43:00.780 --> 00:43:03.550
slide is the safe area,
and the red area would

00:43:03.550 --> 00:43:05.340
indicate a buffer overflow.

00:43:07.800 --> 00:43:11.550
So what happens when we change that
and we now use a larger string?

00:43:11.700 --> 00:43:17.780
So in the case of strCopy, well,
it's game over, right?

00:43:17.870 --> 00:43:20.810
You lost,
because you overflowed the buffer.

00:43:22.010 --> 00:43:25.680
With strncopy,
something slightly different happens.

00:43:25.690 --> 00:43:29.000
strncopy will copy the
characters into the buffer,

00:43:29.050 --> 00:43:31.790
but it won't zero-terminate the buffer.

00:43:32.030 --> 00:43:35.280
So you can still end up with a
problem in your code because the

00:43:35.310 --> 00:43:36.540
string won't be zero-terminated.

00:43:36.630 --> 00:43:38.900
If you then go and try and
use a pointer to that string,

00:43:38.900 --> 00:43:44.050
you will walk off into the red area,
you may dereference unallocated memory,

00:43:44.270 --> 00:43:45.880
or you may copy extra things.

00:43:45.900 --> 00:43:48.150
For example,
if you store the password after that,

00:43:48.360 --> 00:43:51.900
you may end up storing the password or
sending the password out somewhere else.

00:43:51.900 --> 00:43:54.030
So that's pretty bad.

00:43:55.520 --> 00:43:58.540
So what happens when you use strlcopy?

00:43:58.640 --> 00:44:01.640
Well, strlcopy does the perfect thing.

00:44:01.640 --> 00:44:04.340
It actually copies as much
of the buffer as it can,

00:44:04.400 --> 00:44:05.370
and then it zero terminates.

00:44:05.420 --> 00:44:08.450
And it guarantees that
it will zero terminate.

00:44:09.220 --> 00:44:13.100
One last thing with STRL copy,
which is not true with STRN copy,

00:44:13.160 --> 00:44:18.250
is you cannot detect in the STRN copy
case when you've got the situation

00:44:18.330 --> 00:44:20.100
where it did not zero terminate.

00:44:20.100 --> 00:44:23.080
So you always manually have to
add a zero termination in the

00:44:23.100 --> 00:44:25.020
case where you're using STRN copy.

00:44:25.100 --> 00:44:30.060
STRL copy, you don't need to do that,
and it actually returns the number

00:44:30.400 --> 00:44:33.100
of characters that it wrote up to.

00:44:33.100 --> 00:44:36.550
So it's much,
much safer to use STRL copy.

00:44:40.000 --> 00:44:43.150
So now we're going to talk a
little bit about coding styles to

00:44:43.150 --> 00:44:46.040
avoid and coding styles to use.

00:44:46.100 --> 00:44:48.640
So on the left-hand side,
there's a couple of coding

00:44:48.640 --> 00:44:50.700
styles that are not so good.

00:44:50.740 --> 00:44:52.160
For example, we have a buffer.

00:44:52.380 --> 00:44:54.460
It's 1,024 characters in size.

00:44:54.500 --> 00:44:57.420
And then some point later in the code,
we actually make sure

00:44:57.500 --> 00:44:59.200
that we're less than 1023.

00:44:59.200 --> 00:45:01.730
We make sure there's room
for the trading zero there.

00:45:01.740 --> 00:45:05.640
So we've done the right thing,
but we've used a fixed constant.

00:45:05.680 --> 00:45:08.240
And we've used a constant that,
for example,

00:45:08.240 --> 00:45:12.370
if we went ahead and changed it and said,
"Well, we don't actually need 1,024

00:45:12.370 --> 00:45:15.410
characters because nobody
ever passes 1,024 characters,

00:45:15.530 --> 00:45:17.920
and we need to reduce the
memory footprint of our program,

00:45:18.020 --> 00:45:22.530
so we're going to change the
allocation on the stack to 512." Now,

00:45:22.530 --> 00:45:25.270
the problem here is that there's
somewhere else in the code that

00:45:25.270 --> 00:45:27.320
doesn't follow that change.

00:45:28.670 --> 00:45:35.480
Also, so in the two cases,
we're using a number which is related to,

00:45:35.500 --> 00:45:39.340
the number is related in the two cases,
but there's nothing in the code

00:45:39.390 --> 00:45:41.200
that actually indicates that.

00:45:41.530 --> 00:45:46.400
So on the right-hand side are two ways
to actually do this a little better.

00:45:46.400 --> 00:45:51.400
You can either use a hash define
and then use that definition.

00:45:51.620 --> 00:45:54.780
And in the second case,
you can actually use the sizeof

00:45:54.780 --> 00:45:59.400
operator to automatically calculate,
the compiler will calculate that for you.

00:45:59.400 --> 00:46:02.350
Now in the second case,
there's a fledgling

00:46:02.350 --> 00:46:07.350
industry growing right now,
which is looking at source code analysis.

00:46:07.420 --> 00:46:13.890
If you use things on the right-hand side,
then those tools will have a much better

00:46:13.890 --> 00:46:18.180
chance of detecting and eliminating
that what you've written is safe.

00:46:18.400 --> 00:46:21.200
If you do things on the left-hand side,
it will have a little harder

00:46:21.200 --> 00:46:23.400
time figuring out whether
or not things are safe.

00:46:23.400 --> 00:46:27.400
And the big problem with these tools
right now is that they're not very good.

00:46:27.400 --> 00:46:28.370
They're still under development.

00:46:28.400 --> 00:46:30.390
So they will bring up
lots of false positives.

00:46:30.390 --> 00:46:33.870
So the more help you give them,
the easier it is if

00:46:33.870 --> 00:46:35.990
you're using these tools.

00:46:37.340 --> 00:46:41.040
So another kind of style that
I see quite a lot is where

00:46:41.650 --> 00:46:43.870
you have a little function,
it doesn't do very much,

00:46:43.960 --> 00:46:46.340
it just adds a suffix onto a buffer.

00:46:47.020 --> 00:46:50.820
Well, when you do this,
and you do this in multiple places,

00:46:50.990 --> 00:46:54.040
you're almost guaranteed to get
one case where you're going to

00:46:54.040 --> 00:46:56.560
overrun the size of the buffer,
because you're not going to take into

00:46:56.560 --> 00:47:00.550
account that when you're copying the
file name from some user-supplied

00:47:00.550 --> 00:47:04.660
data into the original file variable,
that you're going to allocate and say,

00:47:04.660 --> 00:47:06.430
well,
I need to make sure that there's enough

00:47:06.430 --> 00:47:08.060
room for the extension to be added on.

00:47:09.350 --> 00:47:12.160
So, the easy thing to remember here is
that if you're going to use strlcopy,

00:47:12.280 --> 00:47:13.850
you're going to need to have a size.

00:47:13.940 --> 00:47:17.500
So, you need to pass that size when
you're calling the extra function.

00:47:17.500 --> 00:47:23.740
So, on the right-hand side here,
we pass the size through.

00:47:26.550 --> 00:47:29.490
So now I'm going to talk
a little bit about C++,

00:47:29.550 --> 00:47:32.000
Objective-C, and frameworks.

00:47:32.170 --> 00:47:36.100
So for C++ you can use the
STL string handling functions to

00:47:36.160 --> 00:47:41.400
do the allocation of memory for
you and the manipulation of memory.

00:47:41.550 --> 00:47:43.200
But there are some problems.

00:47:43.360 --> 00:47:45.990
And there are some problems
with encoding type,

00:47:45.990 --> 00:47:51.340
whether you're using a char or a wchar,
and if you need to convert between

00:47:51.590 --> 00:47:55.000
different encoding types when
you're converting back to using,

00:47:55.000 --> 00:47:59.490
say, for example, a POSIX API,
where you need a particular

00:47:59.490 --> 00:48:00.700
type of C string.

00:48:00.860 --> 00:48:03.690
For Objective-C, you can use NSString.

00:48:03.780 --> 00:48:08.830
Again, you need to care when you're
actually converting to C strings,

00:48:09.100 --> 00:48:11.800
because if you don't
zero terminate correctly,

00:48:11.800 --> 00:48:16.010
you can end up with problems,
and NSString will treat blobs,

00:48:16.180 --> 00:48:19.690
and you won't necessarily get a zero
termination if you're not careful.

00:48:19.810 --> 00:48:24.500
So when you're parsing to POSIX APIs,
there can also be some issues with

00:48:24.500 --> 00:48:29.690
converting that string into something
that the POSIX API actually wants.

00:48:29.740 --> 00:48:33.700
But in this particular case,
I've given an example,

00:48:33.700 --> 00:48:37.600
you can actually ask NSString to make
sure that the encoding type actually

00:48:37.600 --> 00:48:39.700
matches what the file system wants.

00:48:40.630 --> 00:48:42.500
Foundation has CFString.

00:48:42.500 --> 00:48:46.200
It's very similar to NSString,
and you can interchange

00:48:46.200 --> 00:48:47.730
those strings together.

00:48:47.730 --> 00:48:49.600
It can be used in plain C code.

00:48:49.850 --> 00:48:50.840
It's a little bit messy.

00:48:51.130 --> 00:48:55.000
It's probably not the best
string handling functions.

00:48:55.110 --> 00:48:58.500
But it is there if you want to use it,
and you don't want to have to handle

00:48:58.580 --> 00:49:00.590
the management of buffers yourself.

00:49:02.560 --> 00:49:05.200
So if you remember way back,
right at the very bottom

00:49:05.200 --> 00:49:08.220
of one of the slides,
I said the malloc of zero

00:49:08.410 --> 00:49:11.180
The problem with buffer
overflow is that it is not zero.

00:49:11.180 --> 00:49:14.240
There's another class of problems
which is very common and is

00:49:14.240 --> 00:49:17.700
related to buffer overflows,
and that's an integer overflow.

00:49:17.870 --> 00:49:19.990
And that is,
when you have a signed number,

00:49:20.030 --> 00:49:23.500
a very large signed number,
and you add another

00:49:23.560 --> 00:49:26.880
signed number to that,
it can actually go negative.

00:49:28.870 --> 00:49:32.900
So if you're using signed arithmetic,
and you're doing pointer manipulation,

00:49:32.920 --> 00:49:36.140
and you're adding things together,
all of a sudden,

00:49:36.140 --> 00:49:39.020
if you start checking to see
whether you've reached a limit,

00:49:39.050 --> 00:49:43.110
you can end up violating that limit
just by adding positive things together.

00:49:43.150 --> 00:49:46.780
It seems kind of wacky,
but that really does happen.

00:49:48.010 --> 00:49:51.670
Also, when you multiply numbers together,
you can wrap around if

00:49:51.670 --> 00:49:53.900
you're using a 32-bit number.

00:49:54.010 --> 00:49:59.900
So, for certain sets of N and M here,
you can actually get N and M to come out

00:49:59.900 --> 00:50:03.450
so that when you multiply them together,
it comes out to be zero.

00:50:07.270 --> 00:50:11.000
So the big problem is if
N and M is under user control.

00:50:11.020 --> 00:50:14.930
So if you've got some kind of
multimedia file that's got,

00:50:14.970 --> 00:50:20.350
let's say, an object of size M,
and you've got N of these objects,

00:50:20.350 --> 00:50:24.860
and you carefully, in the format,
at the beginning of the format, you say,

00:50:24.860 --> 00:50:28.940
well, there's an unsigned int for this
and an unsigned int for that,

00:50:28.980 --> 00:50:32.400
then the user could actually
supply values in that file that

00:50:32.540 --> 00:50:36.520
actually made it look like there
was zero objects in that file.

00:50:36.690 --> 00:50:39.710
when in fact there was
actually some real data.

00:50:40.110 --> 00:50:43.000
So to avoid this,
and this has happened by the way,

00:50:43.000 --> 00:50:46.650
this really has happened in real code,
what you need to do is put

00:50:46.740 --> 00:50:50.060
some checks in to make sure
that the user-supplied N and M,

00:50:50.060 --> 00:50:52.560
when you're doing the arithmetic,
is not zero.

00:50:53.000 --> 00:50:54.990
In both cases, the N and M.

00:50:54.990 --> 00:50:58.570
And also that when you come up
with the result and you divide

00:50:58.570 --> 00:51:02.000
it by one of the factors,
you find the other factor.

00:51:02.000 --> 00:51:05.350
If that comes out to be true,
if that test comes out to be true,

00:51:05.360 --> 00:51:07.990
then you can go ahead
and allocate the space.

00:51:08.000 --> 00:51:11.000
You're not going to end up
with an integer overflow.

00:51:11.710 --> 00:51:13.980
The other really,
really easy way to avoid this

00:51:14.000 --> 00:51:18.590
problem is to put user-supplied
limits on the M and M variables.

00:51:18.690 --> 00:51:22.930
So you say, well, N and M can't ever be
bigger than 1024 each,

00:51:23.090 --> 00:51:23.600
right?

00:51:23.610 --> 00:51:25.600
And you know that if you
multiply N and M together,

00:51:25.600 --> 00:51:29.470
the maximum that could be is 1 megabyte,
and that's going to fit

00:51:29.540 --> 00:51:30.600
into a 32-bit number.

00:51:30.600 --> 00:51:32.600
So there's not a problem there.

00:51:34.660 --> 00:51:38.680
So now we come to temporary files.

00:51:38.710 --> 00:51:40.670
Temporary files come up a lot.

00:51:40.730 --> 00:51:44.440
People use scratch files,
and they always want to pick the name

00:51:44.440 --> 00:51:46.690
of that file they're going to use.

00:51:46.740 --> 00:51:51.390
If you actually write a file into
a known location with a known

00:51:51.610 --> 00:51:56.340
name that's publicly writable,
somebody else can get there before

00:51:56.600 --> 00:52:00.810
you and either put a symbolic link or
put different content there that you

00:52:00.810 --> 00:52:03.590
may read or you may end up writing.

00:52:04.890 --> 00:52:07.140
It's actually very,
very hard to write a piece of code

00:52:07.490 --> 00:52:12.380
that actually checks and is safe
when you're writing into a publicly

00:52:12.410 --> 00:52:16.830
writable space with a fixed name.

00:52:17.160 --> 00:52:21.100
I've got an example on the next slide
which shows how difficult that is.

00:52:21.100 --> 00:52:25.230
So, with symbolic links,
there's a problem of when you check,

00:52:25.240 --> 00:52:27.210
so for example,
a way to avoid this would be to say,

00:52:27.210 --> 00:52:29.100
a naive way to avoid
this would be to say,

00:52:29.130 --> 00:52:31.870
"I'm going to check to see whether
the symbolic link exists." Right?

00:52:32.120 --> 00:52:34.160
So, I'm going to say,
I'm going to do a stat call,

00:52:34.160 --> 00:52:37.310
actually I'm going to do an Lstat call,
and I'm going to see whether or

00:52:37.460 --> 00:52:39.100
not there's a symbolic link there.

00:52:39.100 --> 00:52:42.200
If there's a symbolic link there, well,
I'm going to try and erase it,

00:52:42.200 --> 00:52:43.920
and then I'm going to create my file.

00:52:44.100 --> 00:52:46.100
And that way I'm going to be safe.

00:52:46.100 --> 00:52:49.250
Well, you won't be safe,
because between those two operations,

00:52:49.380 --> 00:52:54.100
somebody else can come in and insert
a symbolic link back there again.

00:52:55.390 --> 00:52:58.020
This is particularly a problem
when you're running as root

00:52:58.480 --> 00:53:02.540
and you're offering services
on behalf of a particular user,

00:53:02.610 --> 00:53:06.300
because you will have permission
to write to any file on the system.

00:53:06.300 --> 00:53:09.310
So you have to be very, very, very,
very careful if you're running as

00:53:09.370 --> 00:53:11.300
root and you're using temporary files.

00:53:11.580 --> 00:53:13.150
Very careful.

00:53:14.080 --> 00:53:16.820
So, as I said,
it's very difficult for security

00:53:16.920 --> 00:53:19.740
creating fixed-name files
in world-writable places.

00:53:19.870 --> 00:53:23.330
It's also dangerous to create
directories in world-writable

00:53:23.330 --> 00:53:25.000
places with fixed names.

00:53:25.000 --> 00:53:27.000
Now,
there's a very easy solution to this,

00:53:27.000 --> 00:53:30.110
and there's a set of
functions called MakeSTemp,

00:53:30.110 --> 00:53:33.710
and there's a set of related functions,
which will create a temporary

00:53:33.710 --> 00:53:37.500
file with a random name,
which means that an attacker will not

00:53:37.500 --> 00:53:41.300
be able to guess that name in advance
and place a symbolic link there and

00:53:41.300 --> 00:53:43.500
make you go off and do something bad.

00:53:43.890 --> 00:53:47.930
Now this function takes a
template string that you fill out,

00:53:48.050 --> 00:53:51.550
and this template string has a
number of X characters in it,

00:53:51.640 --> 00:53:54.560
and those X characters get
placed with random numbers.

00:53:54.560 --> 00:53:57.720
And there's an example here on
the bottom of the slide where

00:53:57.720 --> 00:53:59.560
you're creating a temporary file.

00:53:59.910 --> 00:54:01.970
In this example here,
it's actually giving you a file

00:54:02.030 --> 00:54:03.440
descriptor back to that file.

00:54:03.440 --> 00:54:06.320
It will already be open for you to use.

00:54:08.470 --> 00:54:09.940
So as I said,
I was going to give you an example

00:54:09.940 --> 00:54:15.360
of how to write a fixed-name file
in a publicly-writable place.

00:54:15.410 --> 00:54:19.000
This is the code for doing that,
and we will make this available

00:54:19.230 --> 00:54:22.740
to you after the conference.

00:54:22.780 --> 00:54:24.690
You can actually Google this and find it.

00:54:24.690 --> 00:54:25.900
This has been very well-known.

00:54:26.080 --> 00:54:27.830
And it appears in all
the secure coding books.

00:54:27.830 --> 00:54:29.470
If you buy one of those
secure coding books,

00:54:29.600 --> 00:54:32.300
you'll find a snippet of code
like this in a secure coding book.

00:54:32.370 --> 00:54:34.290
So I'm not going to go over this.

00:54:34.340 --> 00:54:37.000
I don't have enough time to go over this.

00:54:37.960 --> 00:54:40.500
So finally, we come to feature combining.

00:54:40.540 --> 00:54:41.860
So what is feature combining?

00:54:41.970 --> 00:54:45.000
Well, feature combining is
where you take a really,

00:54:45.000 --> 00:54:50.890
really awesome feature and you combine
it with a really wonderful feature.

00:54:51.450 --> 00:54:54.690
and you end up coming up with an
awesomely wonderful security hole.

00:54:54.690 --> 00:54:56.040
And that's really horrible.

00:54:56.090 --> 00:54:58.160
Now, Apple has suffered from this.

00:54:58.440 --> 00:55:02.640
Last year, for example,
we had cases of being able to

00:55:02.640 --> 00:55:07.610
automatically download disk images and
then be able to use URI handlers and

00:55:07.610 --> 00:55:10.540
redirect through those URI handlers.

00:55:10.600 --> 00:55:14.610
And you had a combination of those
two wonderful features and you ended

00:55:14.680 --> 00:55:17.060
up with a whole raft of exploits.

00:55:18.590 --> 00:55:21.230
So what you need to be careful
with is if you're using a framework

00:55:21.480 --> 00:55:24.980
that has a set of capabilities,
you need to be aware of all those

00:55:25.070 --> 00:55:28.500
capabilities and the side effects
that those capabilities might have.

00:55:28.560 --> 00:55:31.240
So for example,
if you're using WebKit and

00:55:31.240 --> 00:55:35.120
you're loading a piece of HTML,
you need to make sure that if

00:55:35.120 --> 00:55:38.390
you're not using JavaScript,
you don't have that bit

00:55:38.450 --> 00:55:40.000
turned on in WebKit.

00:55:44.900 --> 00:55:47.840
So finally,
one of the big things that really

00:55:47.840 --> 00:55:50.080
gets security is complexity.

00:55:50.080 --> 00:55:53.600
The more code you have,
the more bugs it's going to have.

00:55:53.650 --> 00:55:56.030
And you can view security
bugs as like a small subset

00:55:56.320 --> 00:55:59.510
of just regular types of bugs.

00:55:59.840 --> 00:56:01.690
So the more bugs you have,
the more security bugs

00:56:01.740 --> 00:56:02.800
you're going to have.

00:56:02.800 --> 00:56:04.730
So if you want to make
less security bugs,

00:56:04.730 --> 00:56:06.620
you just make your code smaller, right?

00:56:07.140 --> 00:56:08.600
Very simple.

00:56:10.090 --> 00:56:13.810
One of the other problems is
that if you have to create code

00:56:13.810 --> 00:56:19.370
that's backward compatible,
you need to have two sets of code.

00:56:19.470 --> 00:56:22.160
Well, in that situation,
how many times are you actually

00:56:22.160 --> 00:56:25.040
checking the code paths
when you make modifications?

00:56:25.150 --> 00:56:30.560
So testing becomes a big problem when
you start to have legacy support.

00:56:30.630 --> 00:56:34.020
So advice is try and make your
things as simple as possible.

00:56:34.080 --> 00:56:38.120
And if you can avoid generating
situations where you require

00:56:38.150 --> 00:56:40.920
backwards compatibility,
rather than saying,

00:56:40.920 --> 00:56:43.710
"I have a migration process
forwards," then please do.

00:56:43.970 --> 00:56:49.350
Avoid having to support
multiple versions of something.

00:56:51.450 --> 00:56:53.650
So finally, you've created your program.

00:56:53.710 --> 00:56:56.840
There's no security bugs in it anymore
because we've done all these things.

00:56:56.890 --> 00:56:59.700
And there are, of course,
a whole raft of other security problems,

00:56:59.700 --> 00:57:02.380
and we unfortunately don't have time
to go through all of them today.

00:57:02.390 --> 00:57:05.410
We would take up several days' worth
of talking to talk about all the

00:57:05.410 --> 00:57:07.400
different types of security problems.

00:57:07.400 --> 00:57:10.980
But now you have, let's assume you've got
a wonderful program now,

00:57:10.980 --> 00:57:14.400
and you want to package it up
and deliver it to your customers.

00:57:14.610 --> 00:57:17.370
Well, security doesn't end with
just writing your program.

00:57:17.490 --> 00:57:20.050
It actually,
there are security considerations

00:57:20.050 --> 00:57:22.880
when you're actually
delivering it to customers.

00:57:23.170 --> 00:57:26.330
So, my colleagues talked a little
bit earlier about using secure

00:57:26.330 --> 00:57:28.090
permissions when installing.

00:57:28.200 --> 00:57:30.530
So when you're dumping
things down onto the disk,

00:57:30.620 --> 00:57:32.510
you shouldn't be saying, "Oh,
it doesn't really matter

00:57:32.510 --> 00:57:33.340
what the permissions are.

00:57:33.340 --> 00:57:34.340
We're going to make it writable.

00:57:34.400 --> 00:57:37.260
We'll let the user clean
that up." That's bad.

00:57:37.340 --> 00:57:39.100
People don't like that.

00:57:39.210 --> 00:57:43.490
So, make sure you look at all of the
permissions that you're laying down.

00:57:43.610 --> 00:57:47.010
If directories don't exist,
make sure that those directories get

00:57:47.080 --> 00:57:50.610
created with sensible permissions
and have sensible owners.

00:57:51.820 --> 00:57:54.650
Do not allow modification
to your application bundle.

00:57:54.740 --> 00:57:56.400
We can't say that enough times.

00:57:56.510 --> 00:57:59.820
If you write inside your bundle,
all sorts of nasty things

00:57:59.820 --> 00:58:01.170
are going to happen.

00:58:01.580 --> 00:58:15.220
Don't modify the permissions
of system components.

00:58:15.220 --> 00:58:15.220
That can really cause some
interesting side effects if you,

00:58:15.220 --> 00:58:15.220
for example,
need to write something into, let's say,

00:58:16.920 --> 00:58:18.830
I didn't think of an example,
I'm sorry about that.

00:58:18.980 --> 00:58:21.400
So, library startup items.

00:58:21.470 --> 00:58:23.210
Supposing you say,
I need to write something

00:58:23.210 --> 00:58:26.290
into library startup items,
and I want everybody to be able to

00:58:26.300 --> 00:58:28.530
modify that because I'm going to
store a preference file in there,

00:58:28.540 --> 00:58:31.010
and I want every user to
be able to modify that.

00:58:31.050 --> 00:58:35.260
If you change the permissions
on that directory,

00:58:35.260 --> 00:58:40.250
well, the system now has a defense,
and it won't let you do that.

00:58:40.250 --> 00:58:40.250
But if you do that in other areas,
you can create security problems.

00:58:41.900 --> 00:58:43.000
Securely.

00:58:43.000 --> 00:58:47.800
And if you ever use a temporary
file in an install script,

00:58:47.850 --> 00:58:50.290
you've got to use the
makeSTemp functions.

00:58:50.410 --> 00:58:52.430
Otherwise,
you're going to end up with the same

00:58:52.440 --> 00:58:57.790
kinds of security problems that occur
when your application is running,

00:58:58.540 --> 00:59:03.870
because the installer quite frequently
will be running with elevated privileges.

00:59:06.420 --> 00:59:08.240
So now I'm going to wrap everything up.

00:59:08.570 --> 00:59:10.940
So we talked about attack trends.

00:59:11.040 --> 00:59:13.390
So they're getting
increasingly sophisticated.

00:59:13.430 --> 00:59:15.320
They're automated.

00:59:15.490 --> 00:59:17.640
The bad guys are going
after the user's data.

00:59:17.730 --> 00:59:21.150
There's money in that data,
and they're going after it.

00:59:22.520 --> 00:59:25.560
Only one person needs
to create an exploit.

00:59:25.680 --> 00:59:29.400
They share that exploit,
then everybody can do it.

00:59:29.540 --> 00:59:34.970
So it may be hard, a problem may be very,
very hard for two years,

00:59:35.230 --> 00:59:36.960
and then somebody
figures out how to do it.

00:59:37.090 --> 00:59:40.130
Then everybody can do it,
and every exploit that comes out

00:59:40.130 --> 00:59:43.320
after that uses the knowledge
that somebody's gained.

00:59:44.870 --> 00:59:47.630
Mac OS X is a multi-user environment.

00:59:47.720 --> 00:59:49.390
This means there's things
going on in the background,

00:59:49.400 --> 00:59:51.370
there are other users using the system.

00:59:51.440 --> 00:59:52.310
It's not just you.

00:59:52.610 --> 00:59:56.780
Use the correct locations to store
persistent and temporary data.

00:59:56.860 --> 01:00:02.350
Use the key chain to store passwords,
secrets, and credentials.

01:00:02.430 --> 01:00:04.060
It's a very, very good mechanism.

01:00:04.130 --> 01:00:07.430
And if we get it wrong, well,
you can blame us, right?

01:00:07.520 --> 01:00:09.550
If you write your own
crypto and you get it wrong,

01:00:09.560 --> 01:00:12.510
well, it's gonna be your problem,
not our problem.

01:00:13.320 --> 01:00:17.230
Mac OS X system services
can provide information,

01:00:17.400 --> 01:00:22.150
privacy, and protection,
so FileVault and encrypted disk images.

01:00:22.900 --> 01:00:24.990
and File Permissions.

01:00:25.060 --> 01:00:26.790
And finally, secure coding.

01:00:26.790 --> 01:00:29.170
Buffer overflows are
the number one floor.

01:00:29.240 --> 01:00:32.300
If you can reduce the number of
buffer overflows that you have,

01:00:32.320 --> 01:00:35.050
then you're going to reduce the
number of problems in your code

01:00:35.050 --> 01:00:38.800
by maybe up to 50%. They really,
really do occur that often.

01:00:38.920 --> 01:00:41.260
So coding safely provides
enhanced security,

01:00:41.320 --> 01:00:43.760
and it does improve
your software quality.

01:00:43.790 --> 01:00:47.780
On that original slide where I had
the specification and implementation,

01:00:47.820 --> 01:00:50.270
you can get those two things
to come closer together if you

01:00:50.290 --> 01:00:52.790
take care and code securely.

01:00:53.960 --> 01:00:56.900
And finally, installation is part of
the security process.

01:00:56.900 --> 01:00:59.020
It's an end-to-end thing you
have to take care of when

01:00:59.020 --> 01:01:01.900
installing your applications.

01:01:01.900 --> 01:01:06.260
So thank you very much,
and for more information,

01:01:06.260 --> 01:01:09.880
you should... Oh,
I haven't seen this slide.

01:01:09.930 --> 01:01:10.730
Okay.

01:01:10.900 --> 01:01:14.970
So for more information,
the person to contact is Craig Keithley.

01:01:14.970 --> 01:01:17.850
He's the security technology evangelist,
and his email address is up there.

01:01:18.090 --> 01:01:20.870
And I think we can probably
put that slide back up again,

01:01:21.100 --> 01:01:22.900
but now we're going to switch to Q&A.
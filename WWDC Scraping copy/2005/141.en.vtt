WEBVTT

00:00:09.000 --> 00:00:11.650
I'm going to be talking today
to you about how to take

00:00:11.750 --> 00:00:14.480
your application global.

00:00:14.500 --> 00:00:19.310
That means providing the same
quality of user experience that

00:00:19.390 --> 00:00:23.490
you provide to your users here in
the US and other English speaking

00:00:23.980 --> 00:00:26.080
markets to users around the world.

00:00:27.660 --> 00:00:32.200
Let's think first of all about why you
care and why Apple cares about this.

00:00:32.280 --> 00:00:33.800
Take a look at this pie chart.

00:00:33.850 --> 00:00:37.860
It shows a recent
breakdown of our revenues.

00:00:38.190 --> 00:00:40.780
As you can see,
a big chunk of our revenues are

00:00:40.780 --> 00:00:43.590
now coming from outside of the US.

00:00:44.380 --> 00:00:46.940
So we want to sell more systems.

00:00:46.950 --> 00:00:49.940
We need your applications
to sell those systems.

00:00:49.980 --> 00:00:52.220
And a lot of those systems
are going to be sold and are

00:00:52.350 --> 00:00:55.020
sold now outside of the US.

00:00:55.020 --> 00:00:57.320
You want to sell more applications.

00:00:57.330 --> 00:01:01.050
You want a lot more Mac systems out
there to sell your applications on.

00:01:01.230 --> 00:01:04.770
So you need to think about your
customers outside of the US too.

00:01:06.790 --> 00:01:09.980
Let me first talk a little bit about
what it is we're talking about.

00:01:09.980 --> 00:01:12.130
Let's define some terms.

00:01:12.260 --> 00:01:17.000
There are two related disciplines
involved in taking an application global.

00:01:17.320 --> 00:01:19.240
One is localization.

00:01:19.270 --> 00:01:22.940
Localization is essentially
preparing your application to

00:01:22.960 --> 00:01:27.760
be used in a particular market,
making the user experience good

00:01:27.760 --> 00:01:32.110
enough and natural enough so users
will want to buy your application.

00:01:32.480 --> 00:01:37.040
Internationalization is a
discipline that requires,

00:01:37.040 --> 00:01:39.110
it's a design,

00:01:39.200 --> 00:01:42.140
methodology,
and it's a set of services you provide,

00:01:42.150 --> 00:01:46.060
or that we provide through the system,
that enable you to take your

00:01:46.060 --> 00:01:48.690
application to a particular market.

00:01:49.440 --> 00:01:53.670
So for example, say you want to take your
application to the Middle East.

00:01:53.780 --> 00:01:57.930
Well, if you haven't built your
application so that it can handle

00:01:58.590 --> 00:02:03.740
complex bidirectional text,
even if you send it out to be localized,

00:02:03.740 --> 00:02:05.680
it's not just a matter of
localizing the strings.

00:02:05.760 --> 00:02:09.520
Your text has to be able to
display those strings in Arabic.

00:02:09.790 --> 00:02:12.750
So it's more than just a
translation of user interface.

00:02:12.750 --> 00:02:18.850
It's also a cultural awareness and
sensitivity to users in your markets.

00:02:19.040 --> 00:02:23.160
Apple learned this a long time ago
when we first shipped HyperCard.

00:02:23.200 --> 00:02:26.270
We shipped a stack that contained

00:02:26.560 --> 00:02:29.680
A number of things that people
thought represented fun.

00:02:29.900 --> 00:02:32.830
One of those things was a
woman in a bikini on a beach

00:02:32.910 --> 00:02:34.320
playing with a beach ball.

00:02:34.600 --> 00:02:37.740
Well, that may be fun to many people
here in the United States,

00:02:37.790 --> 00:02:42.090
but in other countries that
can be a source of outrage.

00:02:42.220 --> 00:02:48.890
So you have to attune the
content of your application to

00:02:48.890 --> 00:02:52.970
users in a particular market.

00:02:52.970 --> 00:02:53.570
Avoid cultural faux pas.

00:02:57.580 --> 00:03:00.040
So let's look at a typical case.

00:03:00.060 --> 00:03:01.960
You start out,
you've written your application.

00:03:01.960 --> 00:03:04.580
You have a window that
displays a list of names.

00:03:04.600 --> 00:03:06.560
You've done everything,
probably done everything right.

00:03:06.560 --> 00:03:09.120
Maybe using Cocoa,
it's very easy to display the text,

00:03:09.160 --> 00:03:10.870
bring up the window.

00:03:11.960 --> 00:03:17.020
This is the way your application
should look to a Japanese user.

00:03:17.080 --> 00:03:19.060
Now, in many cases,

00:03:19.340 --> 00:03:23.100
This will just happen for you,
but say there's a point where you're

00:03:23.100 --> 00:03:26.140
getting data from the internet somewhere.

00:03:26.370 --> 00:03:30.420
and you didn't know how to translate
that data correctly into Unicode.

00:03:30.420 --> 00:03:33.780
Your application could
end up looking like this.

00:03:34.500 --> 00:03:39.790
So these are some of the points we're
going to cover today and show you

00:03:39.790 --> 00:03:42.650
how to avoid this kind of situation.

00:03:44.850 --> 00:03:47.620
So what is the ideal global application?

00:03:47.660 --> 00:03:51.780
Basically,
it's really the same application

00:03:51.780 --> 00:03:55.960
that you've developed in the US,
but it's an application that feels

00:03:55.970 --> 00:04:00.160
natural and provides a pleasing
experience to users in any country.

00:04:00.160 --> 00:04:04.340
So you've considered the
different content of the language.

00:04:04.340 --> 00:04:10.100
You've set it up so it can be localized
without having to change the software.

00:04:10.740 --> 00:04:15.690
If you have to completely rebuild your
application to take it to a new market,

00:04:16.120 --> 00:04:22.130
that's really a very expensive
process and it's not a good design.

00:04:22.490 --> 00:04:25.630
If you want to take it to
any market around the world,

00:04:25.640 --> 00:04:30.240
especially growing markets
in the Middle East,

00:04:30.470 --> 00:04:36.300
South Asia, then you have to be able to
handle complex and bidirectional

00:04:36.840 --> 00:04:40.960
scripts such as Arabic,
Devanagari used for Hindi,

00:04:40.960 --> 00:04:43.000
and other languages.

00:04:43.200 --> 00:04:46.490
And finally,
you have to be able to present

00:04:46.850 --> 00:04:50.640
data in formats that people
understand intuitively.

00:04:50.840 --> 00:04:55.960
Date/time formats, number formats,
they vary around the world.

00:04:56.900 --> 00:04:58.770
So the ideal we're
presenting is very high,

00:04:58.800 --> 00:05:02.880
but fortunately we provide you
with a great set of comprehensive

00:05:02.880 --> 00:05:05.560
and powerful APIs to do this.

00:05:08.520 --> 00:05:11.480
So these are the things that
we're going to cover today.

00:05:11.520 --> 00:05:14.720
We're going to cover basically
everything you need to know to

00:05:14.720 --> 00:05:17.240
create that ideal application.

00:05:17.310 --> 00:05:19.240
There are a lot of
things we have to cover.

00:05:19.290 --> 00:05:21.250
We're going to cover the high points.

00:05:21.250 --> 00:05:23.370
We'll point out the important things.

00:05:23.410 --> 00:05:24.720
You'll know everything that's there.

00:05:24.720 --> 00:05:27.920
You won't know the details,
but you'll know where to go to the

00:05:27.920 --> 00:05:31.610
Apple Developer Connection to find
out the details when you actually

00:05:31.610 --> 00:05:35.580
sit down and try to solve some of
these problems in your application.

00:05:37.100 --> 00:05:40.020
So it's going to be a whirlwind overview,
but it will be complete.

00:05:43.830 --> 00:05:46.760
Before going on to our overview,
let's talk about what

00:05:46.760 --> 00:05:49.010
we've introduced in Tiger.

00:05:53.330 --> 00:05:58.520
So one of the big features
is OpenType layout.

00:05:58.550 --> 00:06:04.830
Now, the layout tables are the tables
in the font that allow you

00:06:04.910 --> 00:06:10.690
to do high-end typographical
things like compose ligatures,

00:06:10.690 --> 00:06:16.920
select variants in a glyph,
swash variants for positional

00:06:16.920 --> 00:06:21.650
settings in a glyph,
numbers, old style number formats,

00:06:21.670 --> 00:06:22.700
for example.

00:06:23.530 --> 00:06:28.460
Now we supported the
OpenType font format itself,

00:06:28.470 --> 00:06:33.480
the outline format,
almost from day one in OS X.

00:06:33.800 --> 00:06:34.900
We've heard from you.

00:06:34.910 --> 00:06:37.200
We know that OpenType
layout is important.

00:06:37.210 --> 00:06:39.250
We've begun to add it in Tiger.

00:06:39.340 --> 00:06:41.800
We're starting with Roman and Japanese.

00:06:41.870 --> 00:06:47.670
We will eventually work our way
through the full set of UniCode.

00:06:47.670 --> 00:06:51.810
We'll provide ways for you to
implement that if we don't.

00:06:53.490 --> 00:06:57.940
So now if you bring your nice
Adobe font with all of the high-end

00:06:57.940 --> 00:07:01.180
typographical features onto OS X,
it'll just work.

00:07:01.250 --> 00:07:04.750
And you don't have to do anything extra,
because our APIs handle it,

00:07:04.770 --> 00:07:08.500
as long as you're using system
APIs to do line layout and rendering.

00:07:10.910 --> 00:07:13.890
We've also provided some
other features in Tiger,

00:07:13.980 --> 00:07:15.450
for example, string translation.

00:07:15.680 --> 00:07:20.290
You can now take a string of Chinese text
in Han characters and convert them

00:07:20.360 --> 00:07:23.790
into the corresponding pinyin,
for example.

00:07:24.730 --> 00:07:26.900
Unicode type selection.

00:07:26.900 --> 00:07:33.000
This has been available in the Finder
already as an SPI since Panther.

00:07:33.320 --> 00:07:36.120
Now we're making it available to
application developers who want to do

00:07:36.120 --> 00:07:41.490
their own navigation through lists,
etc.

00:07:43.530 --> 00:07:49.920
We've greatly extended the set of UniCode
characters covered in our basic fonts.

00:07:49.930 --> 00:07:54.300
These are Times,
Helvetica now contain fairly complete

00:07:54.300 --> 00:07:59.430
repertoires covering extended Latin,
Greek, Cyrillic,

00:07:59.460 --> 00:08:02.470
and other symbols and things.

00:08:02.610 --> 00:08:05.390
We're continuing our
language support extensions.

00:08:05.510 --> 00:08:09.000
We added Tamil and Tiger.

00:08:09.380 --> 00:08:13.190
No jokes about the Tamil Tigers.

00:08:14.000 --> 00:08:28.700
[Transcript missing]

00:08:31.300 --> 00:08:43.200
[Transcript missing]

00:08:43.360 --> 00:08:44.970
et cetera.

00:08:45.010 --> 00:08:48.750
And this is due to our participation
in an organization called

00:08:48.960 --> 00:08:54.990
the Common Locale Depository,
which is hosted by the

00:08:55.420 --> 00:08:58.140
UniCode Consortium.

00:08:58.330 --> 00:09:00.840
We're active members in this.

00:09:00.940 --> 00:09:05.690
We get data from them.

00:09:05.690 --> 00:09:05.690
We provide data back.

00:09:09.710 --> 00:09:15.040
We've considerably beefed up the support
for manipulating some of these formats,

00:09:15.040 --> 00:09:18.360
including numbers, date times, et cetera.

00:09:18.430 --> 00:09:22.130
You can now spell out the number
the way you say it in English,

00:09:22.130 --> 00:09:23.160
for example.

00:09:23.200 --> 00:09:26.910
There are new classes
to manipulate calendars,

00:09:26.920 --> 00:09:31.640
NS Calendar, CF Calendar,
and the Cocoa and Carbon Worlds.

00:09:31.860 --> 00:09:35.860
So for example,
you can pick a Japanese emperor's

00:09:35.860 --> 00:09:38.700
reign and iterate through
back to the previous emperor,

00:09:38.740 --> 00:09:41.700
if you want to find out who that was.

00:09:41.720 --> 00:09:45.670
There's also a NSDate Picker
that provides a user interface

00:09:45.820 --> 00:09:48.670
for selecting calendar dates.

00:09:52.030 --> 00:09:57.310
Another big feature is we now
support calendars other than the

00:09:57.310 --> 00:10:02.320
standard Gregorian format that
most of us are familiar with.

00:10:02.340 --> 00:10:06.780
Here's an example of those calendars:
Japanese, Thai Buddhist,

00:10:07.080 --> 00:10:14.520
Islamic and Hebrew, a date from each,
shown as localized to the U.S.

00:10:14.520 --> 00:10:15.790
English locale.

00:10:15.900 --> 00:10:21.950
Note that the calendar is
orthogonal to how you present

00:10:21.950 --> 00:10:24.920
it for a particular locale.

00:10:26.930 --> 00:10:30.100
Now I'm going to turn over
the session to John Jenkins,

00:10:30.200 --> 00:10:33.390
who's going to give you a demo
of some of these new features.

00:10:45.800 --> 00:11:06.800
[Transcript missing]

00:11:06.900 --> 00:11:31.000
[Transcript missing]

00:11:31.230 --> 00:11:34.470
You'll see that the ligatures are forming
automatically just as you would expect.

00:11:34.470 --> 00:11:37.430
And in point of fact,
if I bring down the set of ligature

00:11:37.820 --> 00:11:40.710
features that are available in the font,
you'll see that the common

00:11:40.710 --> 00:11:41.970
ligatures are on by default.

00:11:41.980 --> 00:11:47.800
So I can select the text,
I can turn that off, turn that back on.

00:11:47.800 --> 00:11:47.800
I can...

00:11:49.100 --> 00:11:59.400
[Transcript missing]

00:12:00.300 --> 00:12:04.180
The first example here is if I turn
on historical forms and ligatures,

00:12:04.200 --> 00:12:06.750
I'm getting long S's.

00:12:06.750 --> 00:12:11.600
And if I turn on rare ligatures,
I get an actual long S, long SI ligature,

00:12:11.600 --> 00:12:13.280
which is present in Minion Pro.

00:12:13.280 --> 00:12:16.640
And for all of this,
we also have letter casings,

00:12:16.800 --> 00:12:18.640
so I can turn on small caps.

00:12:18.640 --> 00:12:21.560
I can turn on small caps from capitals.

00:12:21.560 --> 00:12:23.680
These are all features which
are built into the font,

00:12:23.790 --> 00:12:25.530
and I'm getting them without any effort.

00:12:26.160 --> 00:12:32.740
One last thing I'd like to show in
terms of the OpenType support here is

00:12:32.740 --> 00:12:36.640
the number case and number spacing.

00:12:36.640 --> 00:12:40.920
So typically, numbers are monospaced
for lining purposes.

00:12:40.920 --> 00:12:43.740
I can make them proportional if I want.

00:12:43.750 --> 00:12:46.590
I can switch to old-style
numerals if I want,

00:12:46.670 --> 00:12:48.120
which looks better.

00:12:48.120 --> 00:12:53.030
Interestingly enough,
Minion is set up so that small caps

00:12:53.030 --> 00:12:56.120
turns on the old-style numerals.

00:12:56.120 --> 00:12:59.260
And I can override that and force
them back to be lining if I want.

00:12:59.260 --> 00:13:01.400
And again,
I can make them monospaced or I can

00:13:01.480 --> 00:13:03.660
make them proportional just as I desire.

00:13:03.740 --> 00:13:07.220
So all of these features
are defined in the font.

00:13:07.220 --> 00:13:09.880
These are percolating up to the user.

00:13:09.960 --> 00:13:13.110
And if you're using the
Unicode Drawing APIs,

00:13:13.200 --> 00:13:16.290
all of this will happen automatically.

00:13:16.990 --> 00:13:19.690
For the internationalization,
we have here a simple application.

00:13:19.700 --> 00:13:24.500
This is a Cocoa application
to do diary stuff.

00:13:24.500 --> 00:13:27.200
And it's very simple, straightforward.

00:13:27.200 --> 00:13:28.820
I can put down,
what is the weather today?

00:13:28.820 --> 00:13:30.340
It's a little cloudy.

00:13:30.340 --> 00:13:34.400
And I can talk about what
I did and navigate back and

00:13:34.700 --> 00:13:37.200
forth just as you would expect.

00:13:37.200 --> 00:13:39.820
Now this is, as I say,
is a Cocoa application.

00:13:39.820 --> 00:13:42.700
The focus of this session
is on core foundation.

00:13:42.820 --> 00:13:44.180
But in some sense, that's irrelevant.

00:13:44.180 --> 00:13:48.300
Core foundation and Cocoa are
very heavily toll-free bridged,

00:13:48.300 --> 00:13:51.280
which means that you can freely
intermingle the two technologies.

00:13:51.280 --> 00:13:53.820
And in point of fact,
even though this application

00:13:53.820 --> 00:13:56.060
was written for Cocoa,
it makes extensive use

00:13:56.110 --> 00:13:57.280
of core foundation.

00:13:57.280 --> 00:14:02.150
And the main things that are different
from this application and a real live

00:14:02.150 --> 00:14:06.820
application is the fact that I have
a locale menu and a calendar menu.

00:14:07.200 --> 00:14:10.020
And I've done this simply
because for demo purposes,

00:14:10.020 --> 00:14:13.380
ordinarily an application would
use whatever the user has set in

00:14:13.390 --> 00:14:15.400
the international preferences.

00:14:15.400 --> 00:14:17.510
Let's look at the locale menu first.

00:14:17.510 --> 00:14:20.960
And the first thing you'll notice
is that this is a big menu.

00:14:20.960 --> 00:14:24.410
In point of fact,
it's so big that I'm organizing it by

00:14:24.420 --> 00:14:27.320
language and it's still a very big menu.

00:14:27.320 --> 00:14:31.030
Now there are a couple of differences
between this and the locale menu that

00:14:31.030 --> 00:14:33.160
you see in international preferences.

00:14:33.160 --> 00:14:37.160
The first thing is that you have
the umbrella language locale.

00:14:37.160 --> 00:14:41.930
This is available so that you don't have
to do a localization over and over again.

00:14:42.390 --> 00:14:45.920
For a language like French,
if I wanted to localize,

00:14:45.920 --> 00:14:49.870
I can do a generic French locale
and then I can localize and override

00:14:49.920 --> 00:14:53.150
that as necessary for Belgium,
Canada, Switzerland, France,

00:14:53.150 --> 00:14:54.160
and Luxembourg.

00:14:54.160 --> 00:14:56.120
So that's different.

00:14:56.180 --> 00:14:58.160
And the other thing that I'm doing
differently is just to be fancy,

00:14:58.160 --> 00:15:03.160
I'm getting the name of the locale
as displayed in the locale itself.

00:15:03.160 --> 00:15:07.120
International preferences
uses the system locale.

00:15:07.120 --> 00:15:09.050
So I can do this fancy text and stuff.

00:15:09.230 --> 00:15:13.570
So if I switch to, let's go to Gaelic.

00:15:14.200 --> 00:19:00.000
[Transcript missing]

00:19:00.560 --> 00:19:03.400
Now that we have support
for additional calendars,

00:19:03.400 --> 00:19:06.760
if I switch to another calendar, okay,
now this is my own date picker,

00:19:06.760 --> 00:19:10.960
because NSDate picker is a little
too small for our purposes here.

00:19:10.960 --> 00:19:14.260
But you'll notice that it has done,
first of all, it switched the number

00:19:14.290 --> 00:19:15.360
of days in the month.

00:19:15.400 --> 00:19:18.250
It knows what day of the
month the month starts on.

00:19:18.250 --> 00:19:19.740
It knows how many days
there are in the month.

00:19:19.900 --> 00:19:22.760
So I've been able to query the system
and get all of this information.

00:19:22.760 --> 00:19:26.030
And in doing data arithmetic,
if I want to go back a month,

00:19:26.030 --> 00:19:30.050
it leaves me on the 26th of the month,
just as you would expect it to do,

00:19:30.170 --> 00:19:33.600
because I'm using the system
calls to do the date calculations.

00:19:33.600 --> 00:19:35.180
Same thing for the year.

00:19:35.190 --> 00:19:39.380
It leaves me on IR26 as I go
back and forth through the years.

00:19:39.380 --> 00:19:41.360
So all of this is
happening automatically.

00:19:41.360 --> 00:19:42.640
I'm using the system calls.

00:19:42.670 --> 00:19:44.600
I'm getting all of this functionality.

00:19:44.600 --> 00:19:46.900
And now that you've seen some
of the things that you can do,

00:19:46.900 --> 00:19:49.880
I'm going to turn it back to Lee,
and he will show you how to do them.

00:19:49.900 --> 00:19:51.080
Thank you.

00:19:56.400 --> 00:19:56.840
Thank you, John.

00:19:56.840 --> 00:20:00.880
Now all those ancient dates I remember
from Roman history will be of use.

00:20:03.600 --> 00:20:07.010
So, taking your application global.

00:20:07.010 --> 00:20:09.620
The place you begin this
is at the lowest level,

00:20:09.670 --> 00:20:12.000
text storage and access.

00:20:14.550 --> 00:20:17.870
In OS X, text means Unicode text.

00:20:18.010 --> 00:20:20.240
At the high levels, that's UTF-16.

00:20:20.370 --> 00:20:24.510
At the lower level, BSD,
that can be UTF-8.

00:20:25.740 --> 00:20:29.660
We use UniCode because it's
comprehensive and of all the solutions,

00:20:29.660 --> 00:20:32.700
well it's also a standard,
international and industry,

00:20:32.850 --> 00:20:36.040
and of all the solutions out there,
it does a great job given the

00:20:36.720 --> 00:20:38.580
complexity of the problem.

00:20:41.070 --> 00:20:46.800
Now the one thing to think about UniCode
is it's not simply a 16-bit ASCII.

00:20:46.820 --> 00:20:48.030
The problem is too complex.

00:20:48.100 --> 00:20:51.620
In fact, it's not even 16 bits anymore.

00:20:52.570 --> 00:20:57.750
The current version of UniCode now
contains over 96,000 characters.

00:20:57.750 --> 00:21:03.710
And it breaks that 64K wall to get
into that larger character set space by

00:21:03.940 --> 00:21:06.160
using something called surrogate pairs.

00:21:06.160 --> 00:21:10.270
These are well-defined
ranges of UniCode characters,

00:21:10.270 --> 00:21:15.790
16-bit units, that can be paired together
into a surrogate pair.

00:21:16.390 --> 00:21:22.500
For example, we see such a surrogate pair
for a Chinese character here.

00:21:23.500 --> 00:21:27.590
So the main thing to think about
here is that a UniCode code point

00:21:28.060 --> 00:21:31.070
is not simply a 16-bit unit.

00:21:31.870 --> 00:21:38.730
Another interesting feature is that the
things that a user sees as characters,

00:21:38.870 --> 00:21:44.290
on the screen and in a document are not
necessarily the things that are stored

00:21:44.290 --> 00:21:47.040
in the backing store of your text.

00:21:47.040 --> 00:21:51.230
So for example,
a base letter with an acute accent,

00:21:51.230 --> 00:21:57.990
as in resume or the Vietnamese word viet,
it's backing store could actually

00:21:57.990 --> 00:22:01.230
be multiple Unicode characters.

00:22:01.260 --> 00:22:05.450
So when you're looking at--even if
you're looking at Unicode code points,

00:22:05.450 --> 00:22:09.250
you still have to consider that
maybe what the user sees as a

00:22:09.290 --> 00:22:13.300
character is different from what
you're seeing in the memory.

00:22:13.300 --> 00:22:16.110
We provide ways for you to manage this.

00:22:16.920 --> 00:22:21.520
Finally,
for primarily historical reasons,

00:22:21.530 --> 00:22:26.400
Unicode has allowed multiple encodings
of some of these combinations

00:22:26.400 --> 00:22:29.050
of base letters and accents.

00:22:29.140 --> 00:22:33.580
So for example, all of the commonly
used accented letters,

00:22:33.590 --> 00:22:38.800
E with an accent, A with an umlaut,
et cetera, all have two representations

00:22:38.800 --> 00:22:40.090
within Unicode.

00:22:40.150 --> 00:22:46.710
both as a pre-composed single
UniCode code point and as multiple

00:22:46.770 --> 00:22:50.980
code points representing the
base letter and the accent.

00:22:51.020 --> 00:22:56.160
And in the future,
all extensions to these kind

00:22:56.330 --> 00:23:01.800
of pairs or triples of letters
will come through composition,

00:23:01.800 --> 00:23:03.980
not through pre-composition.

00:23:03.990 --> 00:23:10.850
A side effect of this though is
that you can encounter multiple

00:23:10.850 --> 00:23:13.980
spellings in a document.

00:23:14.230 --> 00:23:17.460
has a one-to-one correspondence
with what's in the backing store,

00:23:17.460 --> 00:23:19.720
as we see with the word resume.

00:23:19.740 --> 00:23:21.900
It may be fully composed, UniCode.

00:23:21.930 --> 00:23:25.290
It may be fully decomposed,
or it may be a mixture.

00:23:25.480 --> 00:23:29.630
You have to be prepared
to handle this case.

00:23:29.760 --> 00:23:31.320
So that's UniCode in 60 seconds.

00:23:31.320 --> 00:23:36.130
If you keep these points in mind when
you are working with UniCode as text,

00:23:36.130 --> 00:23:40.650
directly as text, not doing line layout,
higher level functions,

00:23:40.650 --> 00:23:43.790
you'll probably avoid
a lot of common errors.

00:23:46.420 --> 00:23:51.130
So this is UniCode as you look at the
data types that support it in the system.

00:23:51.230 --> 00:23:57.010
At the lowest level you
have a UTF-16 UniCode unit,

00:23:57.120 --> 00:24:03.130
Unichar, with mixed caps or all lower
case if you're working in Cocoa.

00:24:03.300 --> 00:24:07.800
Now Unichar, arrays of Unichars are
fine for storing text,

00:24:07.900 --> 00:24:14.300
for passing text around the system,
especially large chunks of text.

00:24:14.540 --> 00:24:19.230
But when you need to actually
process a single UniCode code point,

00:24:19.320 --> 00:24:24.300
which could be one of these surrogate
pairs or even a 32-bit value,

00:24:24.300 --> 00:24:26.420
you need to look at it differently.

00:24:27.650 --> 00:24:30.160
That's where you need to
actually extract a UniCode code

00:24:30.160 --> 00:24:33.480
point from your Unichart array.

00:24:34.260 --> 00:24:38.590
This single UniCode code
point is called-- has a type,

00:24:38.820 --> 00:24:43.630
UniCode scalar value, or UTF-32 care.

00:24:44.040 --> 00:24:46.290
Now this is, now for example,
if you want to find out the

00:24:46.450 --> 00:24:48.770
property of a character,
you want to know if a

00:24:48.770 --> 00:24:52.580
character is a number,
if it's a punctuation point, etc.

00:24:52.580 --> 00:24:58.050
You first need to get the Unicode
scalar value from your Unichar array,

00:24:58.050 --> 00:24:59.870
and then do the test.

00:24:59.920 --> 00:25:02.920
And we provide ways in the
system for you to do this easily.

00:25:04.780 --> 00:25:07.460
At the higher level are string classes.

00:25:07.550 --> 00:25:12.850
John mentioned we have corresponding
string classes for both core

00:25:12.900 --> 00:25:15.670
foundation and for the Cocoa world.

00:25:15.700 --> 00:25:18.560
And they're toll-free bridge,
as John mentioned, which means that you

00:25:18.570 --> 00:25:19.660
can mix them together.

00:25:20.110 --> 00:25:23.850
These are CF StringRef,
CF Mutable StringRef,

00:25:23.910 --> 00:25:30.560
and Nu and Tiger CF Attributed StringRef,
which allows you to associate

00:25:30.560 --> 00:25:37.140
arbitrary attributes to any string
or any ranges within a string.

00:25:38.750 --> 00:25:42.040
Now, given that we all now know that
we're going into this beautiful

00:25:42.120 --> 00:25:47.880
world of having to deal with very
different processor architectures,

00:25:47.930 --> 00:25:50.820
when you're dealing with Unicode,
you have to keep a few things in

00:25:51.780 --> 00:25:55.480
mind about the ordering of the bytes.

00:25:55.520 --> 00:26:00.390
All Unicode strings in memory
are assumed to be native Indian.

00:26:00.940 --> 00:26:03.550
So on Intel,
it's going to be little Indian.

00:26:03.600 --> 00:26:06.170
On PowerPC, that'll be big Indian.

00:26:06.790 --> 00:26:11.640
The external representation of UniCode
is always going to be either marked

00:26:11.940 --> 00:26:15.590
with a UniCode byte order mark,
that's the bomb there.

00:26:16.180 --> 00:26:18.910
or it's going to be
assumed to be big Indian.

00:26:18.910 --> 00:26:21.320
And this is important,
whether you're getting the

00:26:21.320 --> 00:26:25.280
data from a file or you're
getting it off the pasteboard.

00:26:25.530 --> 00:26:30.500
It could be in a byte order different
from that which you expect based on

00:26:30.610 --> 00:26:33.820
what your application is running as.

00:26:37.650 --> 00:26:39.580
So how do you store your text?

00:26:39.670 --> 00:26:44.200
Well, the most convenient way
to store text is CFString,

00:26:44.350 --> 00:26:46.730
mutable string,
or if you want attributes on it,

00:26:46.850 --> 00:26:49.330
the new CF attributed string.

00:26:49.900 --> 00:26:53.800
Now it's pretty easy to create
a CFString from a Unichar array.

00:26:53.910 --> 00:26:57.900
Just call CFString,
create with characters.

00:26:57.970 --> 00:27:01.250
Now if you have Uni, Unicode text,
that's really easy.

00:27:01.610 --> 00:27:04.560
An associated problem is how you
figure out what the encoding of your

00:27:04.630 --> 00:27:06.290
text is if it's not UniCode text.

00:27:06.300 --> 00:27:09.050
I'll talk about that in a few minutes.

00:27:10.340 --> 00:27:14.500
Now one thing to think about when you're
using a CFString is that there can be

00:27:14.530 --> 00:27:20.220
some inefficiencies if you try to access
each character through one by one.

00:27:20.360 --> 00:27:26.110
So a useful function inside
of CFString is a function

00:27:26.120 --> 00:27:27.920
that allows you to get the

00:27:28.230 --> 00:27:30.240
characters out from what's
called an inline buffer.

00:27:30.240 --> 00:27:34.590
This is the fastest way to iterate
through the contents of a CFString.

00:27:35.260 --> 00:27:38.240
And then finally, as I mentioned,
we have ways for constructing

00:27:38.670 --> 00:27:43.550
and for querying the attributes
of the new CF attributed string.

00:27:43.750 --> 00:27:46.900
These attributes can be any
arbitrary attribute you want

00:27:46.900 --> 00:27:52.130
to associate it with it,
including font name, font size,

00:27:52.170 --> 00:27:55.990
language attributes, et cetera.

00:27:59.350 --> 00:28:03.980
So given that the thing
that the user sees,

00:28:03.980 --> 00:28:08.700
the character cluster or the grapheme,
as UniCode calls it,

00:28:08.700 --> 00:28:11.500
may be different from what's
in your backing store,

00:28:11.500 --> 00:28:17.830
you need to be sensitive to this
question when you're allowing a user to

00:28:17.830 --> 00:28:22.500
select or to cursor through a string.

00:28:22.570 --> 00:28:26.360
Because you want the user to
be able to select a character

00:28:26.360 --> 00:28:28.950
in the same unit that they see.

00:28:29.040 --> 00:28:34.060
So if they see a single accented letter,
they typically expect to cursor

00:28:34.240 --> 00:28:36.540
over that as a single unit.

00:28:37.070 --> 00:28:39.660
So we provide ways for you to do this.

00:28:39.680 --> 00:28:44.130
Now I want to first note that
this is not for line breaking.

00:28:44.140 --> 00:28:46.900
It's only for processing
or cursor movement.

00:28:46.900 --> 00:28:50.660
And the way you do this is
you call CFString get range of

00:28:50.710 --> 00:28:52.900
composed characters at index.

00:28:52.900 --> 00:28:58.080
So for example,
if you wanted to break after a cluster,

00:28:58.080 --> 00:29:02.980
what you would do is start
at a known cluster boundary,

00:29:02.980 --> 00:29:07.190
call this function,
get a cfrangeback that will tell you

00:29:07.190 --> 00:29:11.900
the origin of the beginning of the
cluster that you're at and the length,

00:29:11.900 --> 00:29:13.720
sum those two together,
and then you'll be on the

00:29:13.720 --> 00:29:14.810
other side of the cluster.

00:29:14.890 --> 00:29:16.900
It's pretty easy.

00:29:20.820 --> 00:29:26.170
So a big issue actually is not
dealing with Unicode proper,

00:29:26.170 --> 00:29:32.600
but dealing with legacy and external
text that's not in a Unicode encoding.

00:29:32.900 --> 00:29:38.140
This is very typical when you're dealing
with older non-Unicode documents or

00:29:38.140 --> 00:29:39.920
text that comes off the internet.

00:29:39.920 --> 00:29:45.420
So the basic problem is to figure
out what encoding you can pass to

00:29:45.460 --> 00:29:49.740
one of the functions that creates
a CFString or just converts the

00:29:49.740 --> 00:29:53.460
Unicode directly as a Unichar array.

00:29:53.460 --> 00:30:00.410
And there are four basic scenarios
that we commonly encounter

00:30:00.540 --> 00:30:05.430
where you need to be careful
in choosing your text encoding.

00:30:05.590 --> 00:30:10.700
The first scenario is you've got a string
that you use internally to your program,

00:30:10.700 --> 00:30:13.940
say to identify a resource
within your bundle,

00:30:13.940 --> 00:30:14.640
say a file.

00:30:14.950 --> 00:30:18.050
This string is never going
to be seen by an end user.

00:30:18.100 --> 00:30:20.600
It does not need to be localized.

00:30:20.700 --> 00:30:24.360
So the most appropriate
encoding for that is ASCII,

00:30:24.370 --> 00:30:26.420
or if you want to be more general, UTF-8.

00:30:26.650 --> 00:30:29.710
Don't try to use the system encoding
because you can actually create problems,

00:30:29.830 --> 00:30:31.990
not find that resource.

00:30:33.290 --> 00:30:35.360
In this case,
you already know what the string is,

00:30:35.360 --> 00:30:41.390
so you don't have to call an API to
determine it-- to determine the encoding.

00:30:42.020 --> 00:30:46.540
The next case is when you're
dealing with a plain text document.

00:30:46.560 --> 00:30:49.900
Now there's no way,
I mean there are very complex algorithms

00:30:49.900 --> 00:30:53.900
that will try to test what the
encoding of a plain text document is,

00:30:53.900 --> 00:30:57.130
but there's no really foolproof way.

00:30:57.340 --> 00:31:01.700
Currently, our recommended way of doing
this is to query the system for

00:31:01.700 --> 00:31:03.840
the current system encoding.

00:31:03.860 --> 00:31:08.290
The system encoding corresponds to the
preference that the user has picked

00:31:09.290 --> 00:31:14.090
in the international preferences
panel for his or her language.

00:31:14.830 --> 00:31:18.200
So when you encounter
that plain text document,

00:31:18.330 --> 00:31:22.080
call CFString, get system encoding,
and that will return a text encoding

00:31:22.480 --> 00:31:27.880
that you can then pass to one of
these functions to create a CFString.

00:31:28.520 --> 00:31:30.700
That will work most of the time.

00:31:30.770 --> 00:31:34.470
Now if you have style text,
you have somewhat better information,

00:31:34.610 --> 00:31:38.950
especially if it comes from
an older Macintosh system.

00:31:39.310 --> 00:31:43.900
Because on the old,
in the OS 9 encoding system,

00:31:43.900 --> 00:31:46.880
every encoding corresponded to,
or every font had a

00:31:46.880 --> 00:31:48.840
corresponding encoding.

00:31:48.930 --> 00:31:53.720
So you can map that font information
to generate a text encoding.

00:31:53.830 --> 00:31:57.470
And for that we provide
ATS font get family,

00:31:57.480 --> 00:32:01.920
get encoding family,
ATS font family get encoding.

00:32:02.040 --> 00:32:07.030
So for each style run within
that style text document,

00:32:07.650 --> 00:32:11.640
You just grab the font,
map it to a text encoding,

00:32:11.640 --> 00:32:16.410
and then encode that run,
create a CFString,

00:32:16.410 --> 00:32:23.340
or translate it to Unichars
using the returned encoding.

00:32:23.950 --> 00:32:26.500
Finally,
if you're getting data from the internet,

00:32:26.500 --> 00:32:31.560
we assume that you know how to get the
MyIM Charset information from that data,

00:32:31.690 --> 00:32:35.350
whether it's mail or HTML.

00:32:35.510 --> 00:32:36.720
And that will come as a string.

00:32:36.970 --> 00:32:39.300
You pass that string to
one of our functions,

00:32:39.440 --> 00:32:43.630
CFString,
convert IANA Charset to encoding.

00:32:43.890 --> 00:32:47.710
And that will return an encoding
appropriate for the internet

00:32:47.820 --> 00:32:50.390
data that you're working with.

00:32:54.400 --> 00:32:58.060
Now let me talk about how you set up
your application for localization.

00:32:58.060 --> 00:33:04.790
So the way localization works

00:33:05.140 --> 00:33:07.820
on OS X is probably in a way
you're very familiar with.

00:33:07.820 --> 00:33:11.830
It's the same mechanism used
to package your application.

00:33:11.880 --> 00:33:14.760
It's part of the CFBundle mechanism.

00:33:17.320 --> 00:33:21.440
You already know that you can put
resource files associated with your

00:33:21.440 --> 00:33:25.980
application into your bundle and
CFBundle will find them for you.

00:33:26.260 --> 00:33:30.970
Well, a further step to that is
to add lproj directories.

00:33:30.970 --> 00:33:36.650
And lproj corresponds to each
localization that you want to implement.

00:33:37.290 --> 00:33:40.030
CFBundle will then find,
when the user has selected

00:33:40.140 --> 00:33:44.480
a particular language,
CFBundle will find the resources

00:33:44.550 --> 00:33:47.240
that correspond to that lproj.

00:33:47.350 --> 00:33:51.710
Here we have examples of English,
Japanese, and I'm sure some of you in the

00:33:51.890 --> 00:33:56.390
audience will be able to identify
the third lproj directory.

00:33:59.490 --> 00:34:01.810
Now,
a very convenient way to package up your

00:34:01.810 --> 00:34:06.240
API is to use what are called Nib files,
which I believe stand for

00:34:06.240 --> 00:34:07.940
Next Interface Builder.

00:34:08.020 --> 00:34:10.670
Because it's built,
Nib files can be built and

00:34:10.670 --> 00:34:13.280
edited using Interface Builder.

00:34:14.070 --> 00:34:19.180
Nib files contain whole
UI elements such as menus.

00:34:19.870 --> 00:34:23.280
You can use them either
in Carbon or in Cocoa.

00:34:23.320 --> 00:34:27.310
Here are some functions
you can call to create

00:34:27.690 --> 00:34:31.680
to load nib files in Carbon.

00:34:31.730 --> 00:34:35.160
And the beauty of the nib
file is it can be localized.

00:34:35.180 --> 00:34:38.420
It's a complete
localization for an element.

00:34:38.460 --> 00:34:42.730
And it can handle issues like different
string links that you encounter

00:34:42.730 --> 00:34:44.360
when you move between languages.

00:34:44.480 --> 00:34:47.060
So you have one nib you
would localize for English,

00:34:47.070 --> 00:34:48.060
another for German.

00:34:48.320 --> 00:34:51.800
And the much longer German strings
would be handled by the nib.

00:34:51.850 --> 00:34:55.720
And also you can farm out your nib
work to third parties if you want,

00:34:55.820 --> 00:35:02.150
because you do not have to be a
programmer to build and edit a nib.

00:35:04.870 --> 00:35:08.580
Now there will always be times
when you need to use strings,

00:35:08.620 --> 00:35:11.200
localized strings in your application.

00:35:11.230 --> 00:35:14.020
NIBs may not always be sufficient.

00:35:14.170 --> 00:35:18.670
So the way you do that is you
create a localized strings file.

00:35:19.020 --> 00:35:24.130
Now, a localized.strings file is
simply a set of key value pairs.

00:35:24.190 --> 00:35:27.950
The key is a key that you determine
when you call a function within

00:35:27.950 --> 00:35:29.900
your program to get that string.

00:35:29.900 --> 00:35:32.890
The value is the localized string.

00:35:33.220 --> 00:35:39.500
Here are examples for string files
from US English and from Japanese.

00:35:41.250 --> 00:35:47.240
Now inside of your code you'd call a
function like CF copy localized string.

00:35:47.250 --> 00:35:50.980
You call it with the key
and then with a very,

00:35:51.140 --> 00:35:56.900
what should be a useful comment
about how the string is being used.

00:35:57.540 --> 00:36:00.540
The reason for the comment is both
for you as a programmer when you're

00:36:00.540 --> 00:36:03.520
looking at your source code to
remember what the string is for,

00:36:03.600 --> 00:36:07.740
but also there's a tool called GenStrings
that you can run over your source code

00:36:07.880 --> 00:36:16.300
that will output all of the localized
strings as a localized .strings file.

00:36:16.320 --> 00:36:20.650
And the output will contain
the key and the comment.

00:36:20.830 --> 00:36:25.470
You can then pass that to a localizer
who can read the comment and know how

00:36:25.880 --> 00:36:28.800
to translate it into the target local.

00:36:28.800 --> 00:36:32.080
And things over to Deborah Goldsmith
who will tell you about a

00:36:32.110 --> 00:36:35.090
lot more things like drawing,
etc.

00:36:39.250 --> 00:36:40.140
Thank you, Lee.

00:36:40.160 --> 00:36:43.440
I'm going to take over as your tour
guide for the second part of our

00:36:43.440 --> 00:36:47.150
whirlwind tour of international APIs.

00:36:47.300 --> 00:36:49.690
So let's keep on going.

00:36:51.150 --> 00:36:52.000
Okay, there we go.

00:36:52.000 --> 00:36:54.750
The next topic we're going to
cover is drawing and editing

00:36:54.750 --> 00:36:57.390
the text in your application.

00:36:57.960 --> 00:37:01.940
Now, the easiest way to take care of text
in your application is to use one

00:37:01.940 --> 00:37:06.230
of the text editing engines that is
built into Mac OS X instead of doing

00:37:06.230 --> 00:37:08.580
all the drawing and editing yourself.

00:37:08.600 --> 00:37:11.900
And for Carbon applications,
they're all based on MLTE,

00:37:11.900 --> 00:37:13.920
the Multilingual Text Engine.

00:37:13.940 --> 00:37:16.880
Now,
MLTE is a very rich and powerful API,

00:37:16.890 --> 00:37:21.320
and we're not going to have time
to go into it in detail today.

00:37:21.900 --> 00:37:24.920
There's great documentation
in the ADC reference library,

00:37:24.920 --> 00:37:30.400
which is installed on your system and
also available at developer.apple.com.

00:37:30.400 --> 00:37:34.800
You should start off with handling
Unicode text editing with MLTE.

00:37:34.800 --> 00:37:39.530
A new feature for Tiger that I'd like
to point out is that now if you're

00:37:39.660 --> 00:37:44.440
importing or exporting plain text files,
you can control the encoding that

00:37:44.440 --> 00:37:47.780
gets used instead of having it
always use the system encoding.

00:37:49.700 --> 00:37:54.160
MLTE is great to use,
but an easier way of using

00:37:54.760 --> 00:37:57.980
it is some of the prepackaged
versions of MLTE that we have.

00:37:58.170 --> 00:38:02.980
One is HITextView that wraps
MLTE up in an HIView object,

00:38:03.050 --> 00:38:06.090
which can be part of an HIView hierarchy.

00:38:06.220 --> 00:38:08.820
If you're using controls,
you want to use the

00:38:08.880 --> 00:38:12.420
EditUnicodeTextControl,
which is also based on MLTE.

00:38:12.810 --> 00:38:16.100
You want to use that instead
of the older EditTextControl,

00:38:16.100 --> 00:38:18.920
which is not capable of handling Unicode.

00:38:19.020 --> 00:38:24.790
And there are APIs available for
creating all of those versions.

00:38:26.400 --> 00:38:29.100
One thing that we recommend
that you not do is try to

00:38:29.100 --> 00:38:31.910
render UniCode text yourself.

00:38:32.230 --> 00:38:36.040
UniCode is not 16-bit ASCII,
and converting UniCode into

00:38:36.040 --> 00:38:40.270
glyphs to be displayed on the
screen is a very complex process.

00:38:40.430 --> 00:38:42.820
Lee already mentioned
the normalization issues,

00:38:42.960 --> 00:38:47.500
whether a given string consists
of pre-composed characters,

00:38:47.610 --> 00:38:51.380
or base letters and combining marks,
or a mixture of the two.

00:38:51.520 --> 00:38:54.130
So any rendering engine
has to handle that.

00:38:54.380 --> 00:38:57.410
In addition, some scripts are
so-called complex scripts,

00:38:57.410 --> 00:39:01.790
and the way that individual characters
get mapped into the glyphs that display

00:39:01.790 --> 00:39:04.250
on the screen can be very complicated.

00:39:04.330 --> 00:39:08.300
Here we've got an example from Hindi,
and you can see that the glyphs,

00:39:08.300 --> 00:39:11.680
the characters don't wind up
in the same order once they

00:39:11.680 --> 00:39:15.300
get translated for display on
the screen or the printed page.

00:39:15.300 --> 00:39:18.920
In addition, languages like Arabic and
Hebrew are bidirectional,

00:39:18.990 --> 00:39:22.300
that is, there are some parts of the
text that go left to right,

00:39:22.300 --> 00:39:24.890
and other parts that go right to left,
and that's very

00:39:24.980 --> 00:39:26.300
complicated to figure out.

00:39:26.300 --> 00:39:29.300
We'll say a little bit more
about that in a moment.

00:39:29.300 --> 00:39:32.300
Even for so-called simple
languages like English,

00:39:32.330 --> 00:39:35.800
you can have ligatures and typographic
features in high-end fonts,

00:39:35.800 --> 00:39:38.300
as we saw earlier in the demonstration.

00:39:38.300 --> 00:39:40.950
Here's an example of a
ligature in our Zapfino font,

00:39:40.950 --> 00:39:44.290
where the word "Zapfino" becomes
a very elaborate ligature.

00:39:44.320 --> 00:39:48.300
So all in all, this is something that we
recommend you stay away from.

00:39:51.210 --> 00:39:55.150
Let's talk a little bit more
about handling bidirectional text.

00:39:55.410 --> 00:39:58.340
UniCode uses something called
the bidirectional algorithm in

00:39:58.340 --> 00:40:01.260
order to figure out which parts
of the text go left to right and

00:40:01.260 --> 00:40:03.180
which parts go right to left.

00:40:03.240 --> 00:40:06.280
Now, Arabic and Hebrew are normally
written right to left,

00:40:06.500 --> 00:40:12.330
but they're usually written together
with other languages and also with

00:40:12.420 --> 00:40:14.270
numbers that go left to right.

00:40:14.380 --> 00:40:17.760
So you're always going to have
two directions of text when you're

00:40:17.760 --> 00:40:19.620
dealing with those languages.

00:40:19.690 --> 00:40:23.880
In order to figure-- the process
of mapping those pieces of text

00:40:23.950 --> 00:40:28.030
to where they wind up in the final
display is rather complicated.

00:40:28.230 --> 00:40:33.020
You can have text at the end of a
paragraph that can affect how the pieces

00:40:33.050 --> 00:40:37.300
at the beginning of the paragraph get
laid out and what direction they go in.

00:40:37.420 --> 00:40:41.270
So in order to figure this out,
you need to look at an

00:40:41.350 --> 00:40:43.620
entire paragraph of text.

00:40:43.660 --> 00:40:45.940
Now, the system will take
care of this for you,

00:40:45.990 --> 00:40:48.640
but in order for it to
do its job correctly,

00:40:48.700 --> 00:40:49.620
you have to give it an
entire paragraph of text.

00:40:49.690 --> 00:40:56.160
In older systems, using Quick Draw,
you might have used an approach

00:40:56.240 --> 00:40:59.600
where you took a run of text
that was all in the same font,

00:40:59.740 --> 00:41:03.530
drew it with one call,
then moved to the end of that

00:41:03.650 --> 00:41:07.280
and drew the next run of text,
and that approach won't work

00:41:07.340 --> 00:41:09.620
for handling bidirectional text.

00:41:09.620 --> 00:41:12.640
You have to let the system look at
an entire run of text in order to

00:41:12.640 --> 00:41:14.620
figure out where everything goes.

00:41:14.620 --> 00:41:17.710
Once it's done that,
you can then break that up into

00:41:17.810 --> 00:41:19.620
pieces and draw them yourself.

00:41:19.630 --> 00:41:23.450
but it needs the whole paragraph
to figure out where things go.

00:41:25.560 --> 00:41:27.160
Now fortunately,
you don't have to worry about

00:41:27.160 --> 00:41:31.800
this most of the time because the
system APIs will do it for you.

00:41:31.800 --> 00:41:33.800
If you're drawing short strings,
for example,

00:41:33.800 --> 00:41:38.810
if you've got a drawing program
like Illustrator and you want

00:41:39.050 --> 00:41:42.930
to draw short snippets of text,
then there are several

00:41:42.930 --> 00:41:44.570
APIs available for doing that.

00:41:44.880 --> 00:41:47.240
If you're okay with
using the theme fonts,

00:41:47.390 --> 00:41:50.400
for example, if you're drawing a
user interface element,

00:41:50.520 --> 00:41:53.400
you can use HithinDrawTextBox.

00:41:53.530 --> 00:41:59.450
If you want a little bit more
control over the fonts and rotation,

00:41:59.520 --> 00:42:03.510
CG context stuff,
then you can use one of the

00:42:03.510 --> 00:42:06.200
two text box APIs shown here.

00:42:06.390 --> 00:42:10.700
One works with text in a CFString,
and the other works with text

00:42:10.700 --> 00:42:13.490
stored as arrays of unicars.

00:42:17.510 --> 00:42:19.610
If you're drawing a lot of text,
for example,

00:42:19.750 --> 00:42:24.600
if you're implementing a word processor
or a web browser or something that has

00:42:24.600 --> 00:42:29.400
to do a lot of complex text operations,
then if you're working in Carbon,

00:42:29.400 --> 00:42:33.050
the APA that you want to use is Atsui,
the Apple-type services

00:42:33.100 --> 00:42:34.620
for Unicode imaging.

00:42:34.620 --> 00:42:38.280
And again, Atsui is a very powerful
and very rich set of APIs,

00:42:38.280 --> 00:42:42.300
and we're not going to be going
into detail about it here today.

00:42:43.120 --> 00:42:46.050
There's a document,
Rendering Unicode Text with Atsui,

00:42:46.050 --> 00:42:49.890
which is in the ADC Reference Library,
and I highly recommend that as

00:42:49.890 --> 00:42:53.310
a starting point for learning
about what Atsui can do.

00:42:53.320 --> 00:42:57.940
I will give a very brief overview
of the architecture of Atsui.

00:42:57.940 --> 00:43:01.710
The two most important objects
when dealing with the Atsui

00:43:01.840 --> 00:43:06.820
APIs are the text layout object,
which represents one or more paragraphs,

00:43:06.820 --> 00:43:10.350
and the style object,
which lets Atsui know where

00:43:10.520 --> 00:43:15.260
your style run boundaries are,
and what typographic attributes you

00:43:15.260 --> 00:43:17.400
have on a particular run of text.

00:43:17.420 --> 00:43:20.040
Not just the font, size,
and style that you may be

00:43:20.040 --> 00:43:22.810
familiar with from Quickdraw,
but also things like

00:43:22.810 --> 00:43:25.060
typographic features,
such as whether to turn

00:43:25.110 --> 00:43:26.200
ligatures on or not.

00:43:26.240 --> 00:43:29.910
Atsui is very powerful
and very customizable.

00:43:30.000 --> 00:43:34.530
When I say that you give it
an entire paragraph of text,

00:43:34.610 --> 00:43:36.840
that doesn't mean you give it
the paragraph and it takes care

00:43:36.870 --> 00:43:38.370
of making all the decisions.

00:43:38.380 --> 00:43:41.230
You can do a lot of customization
and figure out where all the

00:43:41.230 --> 00:43:43.800
pieces of that paragraph,
wind up.

00:43:43.880 --> 00:43:49.710
You can even get, rather than drawing,
you can even get a glyph array out

00:43:49.920 --> 00:43:52.700
as an end result to the process,
and then you can use that

00:43:52.700 --> 00:43:55.760
glyph array with core graphics
and do all sorts of effects,

00:43:55.840 --> 00:44:01.000
or you can even get curves and use
those with OpenGL or other sets of APIs.

00:44:07.250 --> 00:44:10.540
Well, the flip side of drawing
text is inputting text.

00:44:10.540 --> 00:44:15.400
If you're not using a prepackaged
text editing engine or a text control,

00:44:15.430 --> 00:44:19.360
you'll need to handle text input
coming from the user as the user types.

00:44:19.460 --> 00:44:23.500
Now, if you're already supporting
languages like Chinese or

00:44:23.500 --> 00:44:28.000
Japanese in your application,
then you probably know about TSM,

00:44:28.000 --> 00:44:29.380
the Text Services Manager.

00:44:29.400 --> 00:44:33.330
TSM is the set of APIs that
an application uses in order

00:44:33.330 --> 00:44:37.520
to support inline input,
the ability to type a language like

00:44:37.630 --> 00:44:41.900
Japanese right in your document instead
of having to do it in a separate window.

00:44:41.900 --> 00:44:46.030
If you're already supporting
TSM in your application,

00:44:46.150 --> 00:44:49.890
then it's very easy to
support Unicode as well.

00:44:49.900 --> 00:44:54.440
Just when you create your TSM document,
you just indicate that it's a Unicode

00:44:54.450 --> 00:44:56.780
document instead of an older variety.

00:44:56.900 --> 00:44:58.900
You also want to use the TSM document
to support your application.

00:44:58.900 --> 00:45:03.980
You want to use the text input class of
Carbon events to receive your input and

00:45:04.340 --> 00:45:07.570
not the lower level keyboard events,
because if you work at the

00:45:07.670 --> 00:45:10.850
level of individual keystrokes,
the input method doesn't

00:45:10.890 --> 00:45:14.230
have a chance to do its job,
and input won't work correctly

00:45:14.230 --> 00:45:16.360
for users that use input methods.

00:45:16.400 --> 00:45:20.890
So you want to use the -- if you're
using that class of Carbon events,

00:45:21.000 --> 00:45:24.900
really the only one you have to worry
about is the Unicode for Key event,

00:45:24.900 --> 00:45:27.800
which has a string of Unicode
text coming from either a

00:45:27.930 --> 00:45:28.400
keyboard or an input method.

00:45:28.400 --> 00:45:30.270
an input method.

00:45:30.740 --> 00:45:35.500
In order to support inline
input from an input method,

00:45:35.520 --> 00:45:37.850
you just use the same
Carbon events that you would use

00:45:37.850 --> 00:45:41.180
in a non-Unicode application,
and I won't go into detail on that.

00:45:41.190 --> 00:45:45.290
You can learn about that
in the TSM documentation.

00:45:46.120 --> 00:45:50.800
In order to support inline
input from an input method,

00:45:50.800 --> 00:45:53.020
you just use the same
Carbon events that you would use

00:45:53.180 --> 00:45:56.510
in a non-Unicode application,
and I won't go into detail on that.

00:45:56.650 --> 00:46:00.590
You can learn about that
in the TSM documentation.

00:46:30.600 --> 00:46:30.600
In order to support inline
input from an input method,

00:46:30.600 --> 00:46:30.600
you just use the same
Carbon events that you would use

00:46:30.600 --> 00:46:30.600
in a non-Unicode application,
and I won't go into detail on that.

00:46:30.600 --> 00:46:30.600
You can learn about that
in the TSM documentation.

00:46:46.000 --> 00:46:49.350
Carbon events in your application.

00:46:51.830 --> 00:46:56.810
Okay, let's move on to analyzing
and modifying text,

00:46:56.810 --> 00:47:00.780
or maybe poking and prodding would
be a better way of putting it.

00:47:02.500 --> 00:47:33.000
[Transcript missing]

00:47:33.290 --> 00:47:38.310
Okay, let's move on to analyzing
and modifying text,

00:47:38.310 --> 00:47:42.300
or maybe poking and prodding would
be a better way of putting it.

00:48:03.200 --> 00:48:16.310
So if you're sorting a
large amount of text,

00:48:16.310 --> 00:48:19.310
that can make it go much faster
because you're only doing the

00:48:19.310 --> 00:48:20.880
prep work once for each string.

00:48:20.880 --> 00:48:25.770
If you need to look for a
substring inside of another string,

00:48:25.800 --> 00:48:29.730
you can use CFStringFind,
and there's also a version of

00:48:29.730 --> 00:48:33.060
that that looks for characters
in a given character set.

00:48:34.290 --> 00:48:37.000
and CFString can do much, much more,
but we don't have time

00:48:37.000 --> 00:48:41.360
to go into that today,
so I'd encourage you to

00:48:41.360 --> 00:48:41.360
look at the documentation.

00:48:42.810 --> 00:48:47.200
One thing that CFString can do that's
new in Tiger is transliterate text

00:48:47.200 --> 00:48:48.960
and do other transformations on it.

00:48:49.290 --> 00:48:53.790
This is something that we had available
in the script manager in world script,

00:48:53.810 --> 00:48:55.400
and now we've got a Unicode version.

00:48:55.400 --> 00:49:00.770
It can do things like strip diacritics
or translate text that's in a mixture

00:49:01.590 --> 00:49:07.030
of different writing systems into
the Latin script or go back and forth

00:49:07.700 --> 00:49:10.200
between various writing systems.

00:49:10.200 --> 00:49:16.750
It can even replace non-ASCII
characters by the numeric entities

00:49:16.750 --> 00:49:19.480
that you use in HTML or XML.

00:49:19.700 --> 00:49:24.180
And it has other capabilities besides,
and again, you can find out more by

00:49:24.190 --> 00:49:26.150
reading the documentation.

00:49:28.510 --> 00:49:33.640
If you put together lists or tables,
you might be in a situation

00:49:33.640 --> 00:49:38.730
where you have text that's too
wide to fit in a given space.

00:49:38.940 --> 00:49:43.190
Again, figuring out where to truncate the
text is something that needs to be

00:49:43.190 --> 00:49:47.030
done in a language sensitive way,
and there are APIs in the system

00:49:47.160 --> 00:49:48.750
that can help you do that.

00:49:49.150 --> 00:49:53.550
If you're using HITHeemDrawTextBox,
that has an option to truncate

00:49:53.600 --> 00:49:57.160
the text to a given width.

00:49:57.160 --> 00:50:01.120
But it doesn't modify the text
that's actually stored in memory.

00:50:01.230 --> 00:50:03.980
It actually only truncates
it as it's drawing it,

00:50:03.980 --> 00:50:06.500
so the original text is unchanged.

00:50:06.650 --> 00:50:11.000
If you're using HITHeemDrawTextBox,
that has an option to truncate

00:50:11.090 --> 00:50:14.590
the text to a given width.

00:50:14.660 --> 00:50:18.500
But it doesn't modify the text
that's actually stored in memory.

00:50:18.500 --> 00:50:21.480
It actually only truncates
it as it's drawing it,

00:50:21.580 --> 00:50:24.000
so the original text is unchanged.

00:50:36.610 --> 00:50:38.150
If you're using HITHeamDrawTextBox,

00:50:40.950 --> 00:50:44.540
Okay, we talked earlier,
Lee talked earlier about finding a

00:50:44.540 --> 00:50:48.320
place where you can break without
breaking up a user character,

00:50:48.320 --> 00:50:52.520
but it's also important to find
things like line and word boundaries.

00:50:52.520 --> 00:50:55.880
For example, if you're doing
Word Wrap or double click.

00:50:56.030 --> 00:50:59.960
And in fact, line break and word break
are two different things.

00:50:59.960 --> 00:51:02.680
Line break is a place
where you can do Word Wrap.

00:51:02.770 --> 00:51:06.400
Word break is used for things like
double click or for doing whole

00:51:06.400 --> 00:51:08.560
word search in an application.

00:51:08.560 --> 00:51:10.240
If you've got an editor
and say find entire words,

00:51:10.240 --> 00:51:10.880
you can do that.

00:51:10.900 --> 00:51:15.480
And because of that,
they give slightly different results.

00:51:15.520 --> 00:51:18.190
For example, if you look at the
French example at the bottom,

00:51:18.390 --> 00:51:21.480
you can see it's okay to have
a line break after the hyphen,

00:51:21.480 --> 00:51:25.490
but if you're double clicking or
if you're doing whole word search,

00:51:25.540 --> 00:51:29.130
you want to treat that hyphenated
form as an entire word.

00:51:31.410 --> 00:51:35.560
So the APIs for finding word
or line breaks operate at

00:51:35.560 --> 00:51:37.800
the array of Unicar level.

00:51:38.030 --> 00:51:42.550
And the way you do that is you create
a text break locator object and specify

00:51:42.550 --> 00:51:47.210
the kinds of breaks that you want to do,
whether you're looking for word breaks

00:51:47.220 --> 00:51:49.410
or line breaks or what have you.

00:51:49.870 --> 00:51:54.590
You can then call UC Find Text Break,
give it an index to start from,

00:51:54.650 --> 00:51:59.490
and search backwards or forwards
for the next word or line break.

00:51:59.510 --> 00:52:02.090
If you're looking for
cluster breaks in particular,

00:52:02.230 --> 00:52:04.680
CFString can handle that,
but at the moment there

00:52:04.680 --> 00:52:08.610
isn't a CFString API for
doing word or line breaking.

00:52:12.340 --> 00:52:15.740
Lee also talked earlier about
finding the properties of

00:52:15.850 --> 00:52:20.390
characters and how when you do that,
it's important to make sure you

00:52:20.390 --> 00:52:22.620
get both parts of a surrogate pair.

00:52:22.760 --> 00:52:26.690
So you may have a 16-bit character
or you may have a 32-bit character,

00:52:26.830 --> 00:52:30.040
and to get the properties correctly,
you need to get both halves

00:52:30.040 --> 00:52:31.550
of a 32-bit character.

00:52:31.560 --> 00:52:37.010
Examples of properties are things like,
is this character a letter?

00:52:37.050 --> 00:52:38.300
Is it a number?

00:52:38.300 --> 00:52:40.450
Is it a kind of dash?

00:52:40.450 --> 00:52:41.670
And so on.

00:52:43.910 --> 00:52:47.220
So there are two
APIs available for doing that.

00:52:47.480 --> 00:52:54.120
One is CF Character Set,
which will take a given character

00:52:54.160 --> 00:52:56.480
and test it for membership in a set.

00:52:56.600 --> 00:53:00.380
Another is UC Get Car Property,
which can return different

00:53:00.380 --> 00:53:01.590
kinds of properties.

00:53:01.760 --> 00:53:06.080
For example, if you have a character that
is known to be a decimal digit,

00:53:06.250 --> 00:53:10.480
UC Get Car Property can tell you
what the value of that digit is.

00:53:11.240 --> 00:53:14.020
In order to put surrogate
pairs back together,

00:53:14.020 --> 00:53:17.070
there are three very
useful macros you can use.

00:53:17.070 --> 00:53:21.470
There are two that are used for
testing whether a character is a high

00:53:21.470 --> 00:53:24.100
or a low member of a surrogate pair.

00:53:24.100 --> 00:53:27.440
If you determine that you've got a
high surrogate character followed

00:53:27.560 --> 00:53:31.020
by a low surrogate character,
you can then call UC get Unicode

00:53:31.020 --> 00:53:35.470
scalar value for surrogate pair,
take a deep breath when you say that,

00:53:35.540 --> 00:53:40.160
and put those two halves back together
and get the Unicode scalar value.

00:53:40.160 --> 00:53:43.400
Once you've got that,
you can call something like

00:53:43.400 --> 00:53:47.610
CF character set is long character
member in order to find out whether a

00:53:47.610 --> 00:53:49.790
character's got a different property.

00:53:49.800 --> 00:53:52.580
So in this case,
we're getting a predefined

00:53:52.710 --> 00:53:57.790
character set from CF character set,
the character set of decimal digits.

00:53:57.800 --> 00:54:02.120
And we then test our character,
our 32-bit character,

00:54:02.140 --> 00:54:04.790
to see if it's a member of that set.

00:54:08.370 --> 00:54:10.290
Okay, moving right along.

00:54:10.420 --> 00:54:13.830
Everybody take a deep breath,
do some stretching exercises.

00:54:14.000 --> 00:54:17.400
It's time to move on to dates, times,
numbers, and calendars.

00:54:17.460 --> 00:54:20.170
So Lee talked earlier about locales.

00:54:20.260 --> 00:54:21.540
John talked about them also.

00:54:21.540 --> 00:54:27.140
A locale is basically a package
of data that represents how they

00:54:27.140 --> 00:54:29.880
do things in a certain country
and in a certain language.

00:54:29.880 --> 00:54:33.280
Dates, times, numbers, calendars,
and so on.

00:54:33.390 --> 00:54:36.040
What currency they use, you name it.

00:54:36.040 --> 00:54:38.300
This is different from the UI language.

00:54:38.450 --> 00:54:42.460
You may remember that
in John's demonstration,

00:54:42.460 --> 00:54:45.660
at no time was the user
interface language changed.

00:54:45.660 --> 00:54:47.540
He was always running in English.

00:54:47.540 --> 00:54:49.420
The menus were always in English.

00:54:49.580 --> 00:54:53.980
However, he was able to change his dates,
times, and so on to different locales.

00:54:53.980 --> 00:54:57.400
So the locale is not the same
thing as the UI language.

00:54:58.180 --> 00:55:01.600
It's also not the same thing as
the collation order because the

00:55:01.720 --> 00:55:05.520
user can set that separately too,
or the text break behavior.

00:55:05.650 --> 00:55:12.240
So the most important API to remember
for locales is CFLocale.copy.current.

00:55:12.240 --> 00:55:15.820
That will give you a CFLocale object
that represents the user's

00:55:15.820 --> 00:55:19.250
current locale preferences,
including any customizations

00:55:19.330 --> 00:55:20.940
they may have done.

00:55:20.970 --> 00:55:24.360
And there's lots of different things
you can do on a locale object.

00:55:24.360 --> 00:55:26.480
I'm not going to go into detail on them.

00:55:26.480 --> 00:55:30.960
But two of the more important
ones I'll mention are to get

00:55:30.960 --> 00:55:32.760
data associated with the locale.

00:55:33.010 --> 00:55:35.290
For example, you can say,
what is the currency

00:55:35.290 --> 00:55:38.200
string for this locale,
or what is the decimal point

00:55:38.300 --> 00:55:40.470
character or decimal point string?

00:55:40.660 --> 00:55:44.150
Another thing that you can do with
a locale that's new in Tiger is

00:55:44.350 --> 00:55:46.150
get localized names for things.

00:55:46.290 --> 00:55:52.710
So for example, the ISO language code JA,
the localized display name for

00:55:52.710 --> 00:55:54.760
that in English is Japanese.

00:55:54.890 --> 00:55:59.020
The localized display name for
the country code JP is Japan.

00:55:59.190 --> 00:56:05.800
And the localized display name for the
currency code USD is the dollar sign.

00:56:06.930 --> 00:56:10.210
And you can find out more about
what you can do with CFLocale by

00:56:10.210 --> 00:56:12.870
looking at the documentation.

00:56:14.800 --> 00:56:18.040
We're going to go into a little bit
more detail on how to deal with dates,

00:56:18.040 --> 00:56:20.370
times, and numbers.

00:56:20.710 --> 00:56:23.540
For dates,
there's a core foundation object

00:56:23.550 --> 00:56:27.780
called the CFDateFormatter,
and that will convert a string

00:56:27.780 --> 00:56:32.760
that represents an end user
date to an internal number

00:56:32.850 --> 00:56:35.880
or go in the other direction.

00:56:36.140 --> 00:56:38.270
In addition to that,
you can set properties on a

00:56:38.270 --> 00:56:42.420
date/time formatter that will
control how it does that process.

00:56:42.550 --> 00:56:44.340
So here's an example.

00:56:44.340 --> 00:56:46.100
We'll create a CFDate formatter.

00:56:46.100 --> 00:56:50.860
And you see we're calling CFLocale copy
current to get the current locale that

00:56:50.860 --> 00:56:52.820
represents the user's preferences.

00:56:52.870 --> 00:56:56.290
And we're specifying that
we want the long style.

00:56:56.540 --> 00:57:00.140
Next, we set the property on this
date formatter to indicate

00:57:00.230 --> 00:57:02.530
that we want lenient parsing.

00:57:02.900 --> 00:57:05.860
So if we're converting a
date string to a number,

00:57:05.900 --> 00:57:07.780
we'll be more lenient
about what we'll accept.

00:57:07.930 --> 00:57:13.460
It won't complain if it doesn't
exactly match what the format says.

00:57:13.570 --> 00:57:17.090
And finally,
we call CFDate formatter to convert

00:57:17.340 --> 00:57:20.340
a string into an absolute time.

00:57:20.380 --> 00:57:24.940
Now here's two examples of what a long
style date string might look like.

00:57:24.940 --> 00:57:26.170
They're both for June 6.

00:57:26.270 --> 00:57:30.760
The first is in the US English locale,
and the second one is

00:57:30.810 --> 00:57:32.330
in an Arabic locale.

00:57:32.710 --> 00:57:37.900
And you can see that the Arabic locale
does not use the same ASCII digits,

00:57:37.920 --> 00:57:38.880
for example.

00:57:38.990 --> 00:57:41.390
If you use CFDate formatter,
you don't need to worry

00:57:41.390 --> 00:57:42.400
about any of this.

00:57:42.490 --> 00:57:45.280
The system takes care of it for you.

00:57:47.670 --> 00:57:52.840
As was mentioned earlier,
new in Tiger is calendar support.

00:57:52.840 --> 00:57:55.180
We had Gregorian calendar
support before this,

00:57:55.310 --> 00:57:58.070
but now we support different
kinds of calendars.

00:57:58.210 --> 00:58:02.600
And you can do the kinds of operations
that you saw John doing in his demo.

00:58:02.600 --> 00:58:05.280
You can convert between
calendar components,

00:58:05.280 --> 00:58:09.080
that is a year number, a month number,
and so on, and an absolute time,

00:58:09.080 --> 00:58:10.600
or go in the other direction.

00:58:10.680 --> 00:58:17.350
You can say add one month, add one year,
or subtract one day.

00:58:17.970 --> 00:58:20.590
You can find out the
first day of the week.

00:58:20.790 --> 00:58:22.900
In some countries,
the first day of the week is Monday.

00:58:22.900 --> 00:58:25.490
In other countries, it's Sunday.

00:58:25.600 --> 00:58:28.400
And you can also find out
the shape of the calendar.

00:58:28.400 --> 00:58:31.200
That is, for a given month,
how many days does it have

00:58:31.240 --> 00:58:32.430
and what are the range?

00:58:32.640 --> 00:58:37.380
For example, you can ask CF Calendar,
what is the range of

00:58:37.380 --> 00:58:39.650
days in February 2000?

00:58:39.650 --> 00:58:43.690
And the answer is 1 through 29,
because that was a leap year.

00:58:44.230 --> 00:58:48.180
CF Calendar can do much more and
you can find out about it again in

00:58:48.180 --> 00:58:51.390
the developer reference library.

00:58:53.800 --> 00:58:58.110
Numbers are handled in a way
that's very analogous to dates

00:58:58.250 --> 00:59:02.890
and times using an analogous
object called CFNumberFormatter.

00:59:03.250 --> 00:59:06.940
Again, it converts a string to a
number or a number to a string.

00:59:06.940 --> 00:59:08.860
It goes in both directions.

00:59:09.120 --> 00:59:12.770
And again,
you create it using the current locale.

00:59:13.200 --> 00:59:16.550
CFNumber Formatter also lets you
set a format string if you want to

00:59:16.550 --> 00:59:21.160
format numbers in a particular way,
as opposed to using the user's

00:59:21.160 --> 00:59:23.690
preference for number formats.

00:59:23.780 --> 00:59:25.060
So here's an example.

00:59:25.310 --> 00:59:26.870
We'll create a number formatter object.

00:59:26.980 --> 00:59:30.570
Again,
that's done using the current locale.

00:59:30.740 --> 00:59:34.360
and we in this time we say
we want a currency style.

00:59:34.360 --> 00:59:40.170
We have a double which has the value 42
which represents an amount of currency

00:59:40.170 --> 00:59:45.890
and we call CFNumber formatter to
convert that value into a string.

00:59:45.970 --> 00:59:48.440
And here's two examples
that you might get.

00:59:48.470 --> 00:59:54.140
The first is for the German locale
I believe and we get 42 euros.

00:59:54.140 --> 01:00:00.170
The second is for the Hindi locale in
India and in this case we get 42 rupees

01:00:00.170 --> 01:00:05.400
and again using non-ASCII digits because
that's the way things are done in India.

01:00:05.460 --> 01:00:08.500
If you use core foundation
CFNumber formatter you don't

01:00:08.500 --> 01:00:09.940
need to worry about this.

01:00:09.940 --> 01:00:12.100
It's all taken care of for you.

01:00:14.110 --> 01:00:17.890
Okay,
we're at the end of our whirlwind tour,

01:00:17.890 --> 01:00:21.000
so again, everybody take a deep breath.

01:00:21.120 --> 01:00:23.940
Before we get to the Q&A,
there's a couple of other

01:00:23.940 --> 01:00:25.700
things I'd like to cover.

01:00:26.310 --> 01:00:30.610
If you have more questions
that we didn't answer here,

01:00:30.640 --> 01:00:33.820
Xavier's name is last,
but he's the person you should try first.

01:00:34.060 --> 01:00:37.740
He's the contact in Worldwide
Developer Relations,

01:00:37.740 --> 01:00:38.900
Xavier Legault.

01:00:39.040 --> 01:00:43.730
Or you can contact myself or
Lee Collins if you have questions that

01:00:43.740 --> 01:00:50.000
the documentation doesn't answer or that
you can't get answered on a mailing list.

01:00:52.310 --> 01:00:56.260
For more information,
you can follow the links on

01:00:56.260 --> 01:01:01.180
the More Information page
for WWDC for documentation,

01:01:01.180 --> 01:01:02.950
sample code, and other things.

01:01:03.060 --> 01:01:09.620
So just go to the main WWDC page,
then go to the Extra Information page

01:01:09.620 --> 01:01:14.900
for this session,
and you'll see all sorts of links

01:01:14.900 --> 01:01:15.300
you can follow to find out more
about what we've talked about today.
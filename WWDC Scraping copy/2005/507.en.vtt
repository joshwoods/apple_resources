WEBVTT

00:00:01.540 --> 00:00:05.220
Hello everybody and
welcome to session 507,

00:00:05.220 --> 00:00:08.690
Building 64-bit Solutions for Tiger,
or you could say,

00:00:08.700 --> 00:00:09.640
Living in a Double Wide.

00:00:09.660 --> 00:00:16.070
My name is Stan Shebs and
they tell me I worked on this.

00:00:16.170 --> 00:00:20.680
They said last year, a couple months ago,
you know, it says we want you to

00:00:20.680 --> 00:00:22.130
give a talk on 64-bit Macs.

00:00:22.270 --> 00:00:24.000
And I said, that's really cool.

00:00:24.000 --> 00:00:25.320
That's like an $8 Mac.

00:00:25.320 --> 00:00:26.640
That's really low cost.

00:00:26.640 --> 00:00:28.990
I didn't think we'd
gotten quite that low.

00:00:30.270 --> 00:00:33.640
And they said, no, no, no,
that's not what 64-bit means.

00:00:33.780 --> 00:00:37.370
So then after several weeks of
intensive psychotherapy and a

00:00:37.570 --> 00:00:40.830
small amount of electroshock,
it came back to me that I actually

00:00:40.880 --> 00:00:43.250
had participated in it somewhat.

00:00:43.420 --> 00:00:46.770
And so I'm still not entirely convinced.

00:00:46.850 --> 00:00:51.560
I was looking at last year's video and
I thought I saw editing artifacts around

00:00:51.560 --> 00:00:54.390
the image of me talking about this stuff.

00:00:55.310 --> 00:00:57.740
But I'm going to pretend.

00:00:57.840 --> 00:01:00.180
So we start off,
we'll talk about what exactly

00:01:00.210 --> 00:01:03.000
it is we mean by 64-bit.

00:01:03.930 --> 00:01:06.980
We're going to talk about what
Tiger is actually offering

00:01:07.080 --> 00:01:09.140
for 64-bit applications.

00:01:09.320 --> 00:01:11.540
Talk about when you
should actually do 64-bit.

00:01:11.540 --> 00:01:15.700
It's not something that you automatically
want to do for everything in sight.

00:01:15.860 --> 00:01:18.870
The kinds of considerations when
you're actually talking about porting

00:01:19.010 --> 00:01:25.000
your program to 64-bit or bringing
it over from a different platform.

00:01:25.140 --> 00:01:27.990
And what to do about providing a GUI.

00:01:28.470 --> 00:01:33.460
And then finally, well,
to answer the question about

00:01:33.550 --> 00:01:35.560
the elephant in the room,

00:01:35.600 --> 00:01:41.990
We have nothing to say
about Intel and 64-bit.

00:01:42.270 --> 00:01:44.600
So, yes, I can see everybody
getting up to leave now.

00:01:44.600 --> 00:01:49.520
So, actually, there is something, though,
is that as I go through the talk,

00:01:49.590 --> 00:01:53.800
you look at each slide and ask yourself,
what on the slide is actually

00:01:53.800 --> 00:01:57.850
specific to Intel versus PowerPC,
or what is actually

00:01:57.990 --> 00:02:00.130
generically applicable?

00:02:00.140 --> 00:02:03.950
And I think you'll find that most of
what I'm going to talk about today

00:02:03.960 --> 00:02:08.940
is actually completely the same for
PowerPC or Intel or whatever architecture

00:02:08.970 --> 00:02:13.060
we might happen to use in the future,
that fourth and fifth transition.

00:02:15.510 --> 00:02:15.870
Oops!

00:02:15.950 --> 00:02:19.330
Sorry, I gave that away.

00:02:19.430 --> 00:02:20.830
You didn't hear that.

00:02:20.970 --> 00:02:22.380
Confidential session, right?

00:02:22.400 --> 00:02:24.390
So what is it we mean?

00:02:24.400 --> 00:02:25.400
We hear 64-bit a lot.

00:02:25.400 --> 00:02:28.960
And we've been hearing about 64-bit,
this and that, and various operating

00:02:29.030 --> 00:02:32.100
systems for quite some time.

00:02:32.240 --> 00:02:35.580
And you hear about some days
it's the savior of everything,

00:02:35.580 --> 00:02:38.200
and others it doesn't
really matter that much.

00:02:38.310 --> 00:02:41.480
So for us,
what it means is the ability to

00:02:41.560 --> 00:02:44.480
do 64-bit integer math natively.

00:02:44.650 --> 00:02:51.430
So the processor is able to do
the 64-bit arithmetic with single

00:02:51.430 --> 00:02:54.660
instructions rather than with,
say, subroutine calls.

00:02:54.950 --> 00:03:00.480
It also means support for more than
4 gigabytes of physical memory.

00:03:01.570 --> 00:03:04.620
And then finally,
the thing that's most exciting is

00:03:04.620 --> 00:03:08.500
the support for virtual address
spaces larger than 4 gigabytes.

00:03:08.630 --> 00:03:12.890
And it wasn't that many years ago that
4 gigabytes sounded like infinite space,

00:03:12.890 --> 00:03:15.580
but with the growth of
applications and so forth,

00:03:15.580 --> 00:03:19.610
it's actually turned out that
it doesn't seem so big anymore.

00:03:19.950 --> 00:03:25.080
So I'll quickly summarize what our
64-bit architecture looks like for OS X.

00:03:25.450 --> 00:03:28.800
First of all,
32-bit programs are unaffected.

00:03:28.800 --> 00:03:29.800
We don't do anything about them.

00:03:29.800 --> 00:03:32.790
They work in the same
way they always have.

00:03:34.060 --> 00:03:37.920
We don't allow mixing
of 32 and 64-bit tasks.

00:03:37.920 --> 00:03:40.860
So if you have a 64-bit program,
you have to have a 64-bit

00:03:40.860 --> 00:03:43.990
version of each and every library
that it might make use of.

00:03:44.000 --> 00:03:47.590
So the alternative might have been
to do some kind of ugly thunking

00:03:47.590 --> 00:03:50.600
thing and we thought about,
you know, just exactly what it would

00:03:50.600 --> 00:03:54.550
involve stuffing a 64-bit
pointer in a 32-bit box and said,

00:03:54.550 --> 00:03:58.890
there's no good solution,
so we're just not going to go that way.

00:04:00.230 --> 00:04:04.080
And it turns out that universal
binary thing that we've heard so

00:04:04.120 --> 00:04:09.140
much about recently turns out to be
very handy also for packaging 32-

00:04:09.140 --> 00:04:12.270
and 64-bit programs and libraries.

00:04:12.320 --> 00:04:15.290
And so we actually get a,
and now that we can talk

00:04:15.290 --> 00:04:19.310
about the Intel code,
we actually have three-way binaries,

00:04:19.310 --> 00:04:22.110
sort of a menage a trois of file formats.

00:04:22.180 --> 00:04:28.700
And if you look closely around on your
system with the Intel stuff installed,

00:04:28.700 --> 00:04:30.110
you can probably find a few of those.

00:04:30.200 --> 00:04:31.340
Thank you.

00:04:34.470 --> 00:04:38.370
And then finally,
we use a single 32-bit kernel.

00:04:38.370 --> 00:04:41.260
This is at a certain advantage.

00:04:41.300 --> 00:04:45.040
For instance, there's no rebooting into
a 64-bit system necessary.

00:04:45.040 --> 00:04:46.910
Keep using that already.

00:04:46.910 --> 00:04:49.350
All your existing
drivers continue to work.

00:04:49.440 --> 00:04:53.310
Drivers that want to work
with 64-bit address spaces,

00:04:53.310 --> 00:04:57.840
they already use IO memory descriptors,
essentially an abstraction

00:04:57.960 --> 00:04:59.610
of the memory space.

00:04:59.620 --> 00:05:01.300
So the driver doesn't have to change.

00:05:01.300 --> 00:05:04.000
It can continue to work with
the 64-bit applications.

00:05:08.580 --> 00:05:14.500
Now technically, somewhere around 1027
when G5s were introduced,

00:05:14.500 --> 00:05:17.700
64-bit showed up on the Mac.

00:05:17.700 --> 00:05:23.980
And this first version consisted
of 64-bit instructions and data.

00:05:24.290 --> 00:05:25.710
And it was available to all programs.

00:05:25.780 --> 00:05:30.030
If you wanted to write a load double
instruction into your code using an

00:05:30.030 --> 00:05:33.200
Asm block or something like that,
you could do that.

00:05:33.200 --> 00:05:37.400
Now, in practice, it had a fair number
of restrictions on it.

00:05:37.520 --> 00:05:40.390
For instance,
the ABI wasn't structured so

00:05:40.390 --> 00:05:44.200
that you could pass the full
contents of the 8-byte register.

00:05:44.200 --> 00:05:48.970
So you could do a 64-bit add or whatever,
but then you couldn't get the

00:05:49.350 --> 00:05:51.390
result back from the function.

00:05:54.660 --> 00:06:02.240
Let's also introduce the greater than
4 gigabyte physical memory support.

00:06:02.240 --> 00:06:05.900
So this is good for the hardware guys.

00:06:05.940 --> 00:06:08.000
The software guys were sort of, yeah,
whatever, a lot of memory.

00:06:08.000 --> 00:06:11.680
More than we personally can afford,
so we didn't ever get to see it.

00:06:11.760 --> 00:06:16.380
But we were told that that worked.

00:06:16.460 --> 00:06:20.420
And our rich application developers
got to use lots of memory.

00:06:21.790 --> 00:06:23.600
Anyway,
that did allow the caching of large

00:06:23.710 --> 00:06:25.640
application data sets in memory.

00:06:25.640 --> 00:06:31.830
But without any kind of software support,
you had to do something special in your

00:06:31.830 --> 00:06:33.700
program to actually make use of it.

00:06:35.100 --> 00:06:38.620
And of course all this is G5 only.

00:06:38.830 --> 00:06:43.190
Basically I actually did experiment for
a couple days with trying to get some

00:06:43.190 --> 00:06:47.680
kind of 64-bit thing working on G4,
but then somebody pointed out to me

00:06:47.680 --> 00:06:50.740
that in fact it wasn't going to be
able to address any additional memory,

00:06:50.740 --> 00:06:51.620
so it was kind of pointless.

00:06:51.620 --> 00:06:53.320
And I said, yeah, that's a good point,
it is pointless.

00:06:56.670 --> 00:07:00.040
So in the large datasets,
just a quick example.

00:07:00.100 --> 00:07:03.860
So if you had a 4-gigabyte
application and 7-gigabyte data file,

00:07:03.860 --> 00:07:06.720
you could actually map
that to physical RAM.

00:07:06.820 --> 00:07:09.020
If you had the 8
gigabytes of physical RAM,

00:07:09.020 --> 00:07:10.800
VM would take care of all of it.

00:07:10.830 --> 00:07:14.700
But from your application,
you would only be able to manipulate

00:07:14.700 --> 00:07:17.160
a small block of that at a time.

00:07:17.160 --> 00:07:20.600
And so the idea is that you'd
essentially move this kind

00:07:20.600 --> 00:07:22.220
of a window of data around.

00:07:22.250 --> 00:07:24.730
Now, I personally don't know of
any application that actually

00:07:24.730 --> 00:07:27.830
went to that much trouble,
you know, that was actually possible

00:07:27.840 --> 00:07:29.870
in the Panther days.

00:07:31.860 --> 00:07:34.810
Now in Tiger, we jumped all this up.

00:07:34.940 --> 00:07:40.890
We defined a new PowerPC ABI and
the most important thing about it

00:07:40.890 --> 00:07:44.670
is that the full width of the 64-bit
registers is actually being used.

00:07:44.810 --> 00:07:51.210
It's pushing the data back and
forth in and out of functions.

00:07:51.610 --> 00:07:55.430
We had defined a 64-bit version
of the Mac OS file format.

00:07:55.430 --> 00:07:58.490
And this is basically the
same Mac OS file format

00:07:58.490 --> 00:07:59.930
that's been in use all along.

00:07:59.930 --> 00:08:03.650
It's been extended so that some
of the fields are wider and the

00:08:03.740 --> 00:08:06.280
relocations are bigger and so forth.

00:08:09.090 --> 00:08:13.600
And then most interestingly,
we have the big address space.

00:08:13.610 --> 00:08:16.930
And this is a big flat address space,
so you can actually allocate a

00:08:17.040 --> 00:08:21.580
single block at 2 to the 49th,
the 512 terabytes.

00:08:21.620 --> 00:08:24.800
And you can actually call
malloc with that and it works.

00:08:24.860 --> 00:08:29.280
Now, if you try and touch
every byte in that block,

00:08:29.280 --> 00:08:31.570
that will not go so well.

00:08:31.930 --> 00:08:37.030
You'll go from the textbook discussion
of VM thrashing to personal observation.

00:08:41.150 --> 00:08:43.100
Still G5 only.

00:08:43.100 --> 00:08:47.130
So, how big is the 64-bit address space?

00:08:47.220 --> 00:08:49.990
Well, the technical term is 16 exabytes.

00:08:49.990 --> 00:08:54.680
Nobody knows what exabytes means,
so we say 16 billion billion bytes.

00:08:54.860 --> 00:08:59.270
Or if you're European,
we say 16 milliard milliard bytes,

00:08:59.270 --> 00:09:01.190
or something like that.

00:09:02.300 --> 00:09:03.200
How big is that?

00:09:03.200 --> 00:09:06.830
Well, it's 16,000 internet archives.

00:09:06.970 --> 00:09:11.220
It turns out we don't have enough pixels
on the screen to quite get it to scale.

00:09:12.850 --> 00:09:15.430
The equivalent to a million
libraries at Congress.

00:09:15.510 --> 00:09:17.100
And you thought the
Library of Congress was big.

00:09:17.100 --> 00:09:18.900
Well, not really.

00:09:20.390 --> 00:09:24.380
And it's equivalent to 3 billion DVDs.

00:09:24.480 --> 00:09:28.420
So that's a lot of space to work with.

00:09:30.480 --> 00:09:34.080
So what that means then is that you can
still take that 7-gigabyte data file

00:09:34.080 --> 00:09:39.430
as we showed before and it conveniently
fits in a corner of your big address

00:09:39.430 --> 00:09:44.920
space and the VM still manages it with
the physical RAM just as it did before.

00:09:48.130 --> 00:09:54.900
So, the future of 64-bits is now
thrown into some confusion,

00:09:54.910 --> 00:09:56.400
perhaps, with the whole Intel thing.

00:09:56.400 --> 00:10:00.670
Oh, well.

00:10:00.680 --> 00:10:03.590
It's nothing like getting upstaged
by your CEO two days before

00:10:03.670 --> 00:10:05.940
your presentation that you've
been working on for a month.

00:10:06.000 --> 00:10:07.850
Oh, well.

00:10:07.860 --> 00:10:15.960
So, the way we've done this is we've
rolled out a... Back up a moment.

00:10:15.980 --> 00:10:16.640
Okay.

00:10:17.290 --> 00:10:24.000
So, we've introduced a limited set of
64-bit libraries this time in Tiger,

00:10:24.000 --> 00:10:28.780
and then future versions we'll be
bringing on more of the software

00:10:28.780 --> 00:10:31.380
stack available as 64-bit.

00:10:31.380 --> 00:10:34.460
And part of that depends
on what you guys want.

00:10:34.560 --> 00:10:36.970
So, if you say, well,
Objective-C is most important,

00:10:36.970 --> 00:10:40.540
we want that first, that will certainly
bump up the Objective-C,

00:10:40.540 --> 00:10:42.690
64-bit Objective-C priority.

00:10:42.700 --> 00:10:45.600
Similarly,
if you're most interested in Carbon,

00:10:46.400 --> 00:10:48.320
or most interested in OpenGL,
what have you.

00:10:48.360 --> 00:10:52.470
Now, at the same time,
the open source world has already

00:10:52.470 --> 00:10:55.760
been picking up some of the
activity of porting to 64-bit.

00:10:55.850 --> 00:10:59.210
You can get X11 client
libraries out there now.

00:10:59.510 --> 00:11:04.380
And so, they're actually going along and
porting quite a lot of things.

00:11:09.170 --> 00:11:12.300
Okay, so the trade-offs for 64-bit.

00:11:12.400 --> 00:11:15.960
64-bit is not always a win.

00:11:16.240 --> 00:11:19.100
You have twice as much data
that you're pushing around,

00:11:19.100 --> 00:11:24.100
twice as much operations,
caches fill up faster.

00:11:24.110 --> 00:11:29.000
So there's sometimes where it's good
and sometimes where it's not so good.

00:11:29.330 --> 00:11:31.200
Now if you have something
that's compute intensive,

00:11:31.200 --> 00:11:35.400
something involving long integers,
long long integers, 64-bit integers,

00:11:35.580 --> 00:11:37.090
that's pretty much a definite win.

00:11:37.200 --> 00:11:41.260
We have one example, I'm told,
one of the chess programs

00:11:41.260 --> 00:11:46.220
called Crafty that runs quite
a bit faster in 64-bit than 32.

00:11:48.520 --> 00:11:51.050
Now, conversely,
if you have a program that is, say,

00:11:51.050 --> 00:11:54.310
pointer-intensive,
manipulating a lot of blocks of memory,

00:11:54.350 --> 00:11:57.100
but a relatively small
amount of data overall,

00:11:57.100 --> 00:11:59.970
well, it's just not going to win as much.

00:11:59.980 --> 00:12:01.950
We wouldn't like to say
lose in this context,

00:12:02.090 --> 00:12:03.490
but you're going to win less.

00:12:03.500 --> 00:12:08.720
So, yeah, so basically you're pushing
around twice as much data,

00:12:08.720 --> 00:12:12.690
but you're not getting
anything in return for it.

00:12:12.800 --> 00:12:15.430
So in that case,
you really wouldn't say that you'd

00:12:15.430 --> 00:12:17.710
want to do that as a 64-bit program.

00:12:19.890 --> 00:12:23.790
Now if you started shifting up to having
very large amounts of data and memory,

00:12:23.790 --> 00:12:26.090
most likely you're going to
win because now you can start,

00:12:26.220 --> 00:12:28.280
the VM system is going
to start kicking in,

00:12:28.280 --> 00:12:29.990
it's going to start
managing things for you.

00:12:30.000 --> 00:12:33.600
It has better access to
the disk IO subsystem,

00:12:33.600 --> 00:12:37.310
reserve space in the
swap space and so forth.

00:12:37.470 --> 00:12:41.310
It can actually do a certain amount
of paging and management that would

00:12:41.320 --> 00:12:43.530
be very hard for you to do yourself.

00:12:43.540 --> 00:12:47.160
So at that point you're going to
start to see your 64-bit program do

00:12:47.160 --> 00:12:49.480
better than a 32-bit counterpart.

00:12:49.800 --> 00:12:55.750
And of course if you're using 64-bit
Windows we just can't help you.

00:12:57.810 --> 00:13:00.910
Hey, it went through all these stages of
review and nobody told me to take it out,

00:13:01.030 --> 00:13:01.670
so there it is.

00:13:06.570 --> 00:13:10.740
Okay, so let's get down a little bit
more to the nuts and bolts.

00:13:10.740 --> 00:13:14.370
So, to get 64-bit code,
it's pretty easy in Xcode.

00:13:14.480 --> 00:13:18.920
You go to the build configurations,
is that what they call it this week,

00:13:19.010 --> 00:13:20.100
build configurations?

00:13:20.430 --> 00:13:24.080
And, bad attitude.

00:13:25.040 --> 00:13:26.230
My manager's not laughing.

00:13:26.240 --> 00:13:27.070
That's not a good sign.

00:13:27.080 --> 00:13:30.590
Yeah, he's scowling over there.

00:13:30.680 --> 00:13:32.820
Now he's smiling.

00:13:32.820 --> 00:13:34.260
He's thinking about what
he's going to do to me.

00:13:34.840 --> 00:13:37.280
Okay.

00:13:37.280 --> 00:13:42.550
Anyway,
so fairly simple to get the 64-bit stuff.

00:13:42.650 --> 00:13:47.700
The string,
the keyword to remember is PPC64.

00:13:47.840 --> 00:13:51.260
So PPC is implicitly 32-bit.

00:13:51.260 --> 00:13:53.170
It's the term you've
been using all along.

00:13:53.640 --> 00:13:55.100
And then you can add PPC64.

00:13:55.200 --> 00:13:59.310
And if you want to do that
three-way universal binary thing,

00:13:59.320 --> 00:14:01.880
then you can add the Intel to this also.

00:14:01.880 --> 00:14:06.230
So it'll read PPC64 by 386.

00:14:10.400 --> 00:14:12.900
So, specific considerations.

00:14:12.970 --> 00:14:16.700
The first thing to understand
is about our data model.

00:14:16.710 --> 00:14:22.540
And so, the basic deal is that if you
think about C family languages,

00:14:22.540 --> 00:14:23.780
and this is really what
we're talking about,

00:14:23.780 --> 00:14:24.960
we're talking about the C family now.

00:14:26.930 --> 00:14:29.890
You have the,
C has always been very flexible

00:14:29.920 --> 00:14:33.860
in that you can take pointers
and treat them as integers and

00:14:33.860 --> 00:14:35.500
integers and treat them as pointers.

00:14:35.500 --> 00:14:38.950
And you can add two integers and say,
well, actually, this is really a pointer,

00:14:38.950 --> 00:14:40.560
go and find a piece of memory with it.

00:14:40.620 --> 00:14:44.320
Well, it gets to be a little bit of a
problem in the 64-bit world because if

00:14:44.320 --> 00:14:46.770
you're going to have a 64-bit pointer,
well,

00:14:46.770 --> 00:14:49.010
what integer does that correspond to?

00:14:49.010 --> 00:14:51.910
And different people have
chosen different things.

00:14:52.000 --> 00:14:56.650
So, now, just to start off with,
the old style model.

00:14:56.680 --> 00:14:59.680
The conventional model is called ILP32.

00:14:59.680 --> 00:15:02.920
That's integer, longs, and pointers,
all 32 bits.

00:15:02.920 --> 00:15:05.560
And so,
the model is that integers are 32 bits,

00:15:05.560 --> 00:15:06.680
longs are 32 bits.

00:15:07.160 --> 00:15:11.170
Longs are 64,
and that's most people have set up long,

00:15:11.170 --> 00:15:15.560
long to mean 64-bit integer value,
and pointers are 32 bits.

00:15:15.770 --> 00:15:18.330
That's pretty much what everybody does.

00:15:18.800 --> 00:15:22.390
Now in the early days of 64-bit,
a certain couple platforms,

00:15:22.400 --> 00:15:24.760
name of the alphas and craze,
how many people have

00:15:24.840 --> 00:15:26.010
done alphas or craze?

00:15:26.010 --> 00:15:28.080
A few, okay.

00:15:28.080 --> 00:15:32.440
So you've probably personally experienced
what it means to have an all 64-bit,

00:15:32.440 --> 00:15:33.640
all the time system.

00:15:33.640 --> 00:15:38.630
They call that IOP64 and it sounds
really great until you actually

00:15:38.630 --> 00:15:41.070
try and get something working.

00:15:41.070 --> 00:15:46.170
And what happens is that now an integer
is twice as large as you thought it was.

00:15:46.330 --> 00:15:47.290
Every integer is.

00:15:47.950 --> 00:15:51.420
And so, any bit of code that says, well,
I can stick four cares in an

00:15:51.420 --> 00:15:53.160
integer and pass that somewhere.

00:15:53.160 --> 00:15:55.290
Okay, well,
the integer is only half full.

00:15:55.290 --> 00:15:57.840
Or you stuck eight characters
in there and some of the code

00:15:57.930 --> 00:15:59.450
only thought there was four.

00:15:59.460 --> 00:16:03.250
So in practice,
it actually turned out not to be

00:16:03.250 --> 00:16:08.470
a really great idea because it's
just too different from the normal

00:16:08.600 --> 00:16:11.280
metal model of C programmers.

00:16:11.280 --> 00:16:15.470
And so most Unix systems since then
have settled on a sort of a compromise,

00:16:15.470 --> 00:16:17.600
you might say, called LP64.

00:16:19.700 --> 00:16:24.400
So longs and pointers are
64-bits and integers remain 32.

00:16:24.580 --> 00:16:27.520
And that's pretty much
typical for the Unix world.

00:16:27.520 --> 00:16:28.780
That's what Tiger does.

00:16:28.780 --> 00:16:33.500
And then finally, just for completeness,
we have a completely different

00:16:33.500 --> 00:16:38.620
way of doing things called P64 or
sometimes you might see it as LLP64.

00:16:38.640 --> 00:16:43.670
And, well,
it's a side effect of Windows's

00:16:43.680 --> 00:16:48.680
long legacy where once upon a time,
ints were 16-bits.

00:16:48.700 --> 00:16:49.700
And longs were 32.

00:16:49.830 --> 00:16:53.660
And then when it went to a 32-bit system,
well,

00:16:53.660 --> 00:16:56.970
longs were kind of still stuck at 32.

00:16:56.970 --> 00:17:01.090
And so Microsoft said, well,
and we'll just say pointers are 64-bit.

00:17:01.090 --> 00:17:02.790
And, well,
we can't do anything about longs.

00:17:02.790 --> 00:17:03.910
We have to leave them alone.

00:17:03.930 --> 00:17:08.390
So you have this interesting programming
model where you have to use long longs

00:17:08.390 --> 00:17:10.540
to hold pointers or you just lose.

00:17:12.640 --> 00:17:16.800
So anyway, that's, and that's,
as far as I know, it's unique to Windows.

00:17:16.800 --> 00:17:18.000
Nobody else goes that way.

00:17:20.000 --> 00:17:24.550
So the thing to keep in mind on
this is certain invariants that

00:17:24.690 --> 00:17:28.900
will help for portability if it's
something you have to worry about.

00:17:29.090 --> 00:17:32.290
First of all,
if you have something that absolutely

00:17:32.300 --> 00:17:35.760
has to be 64-bits no matter what,
use long-long.

00:17:36.120 --> 00:17:37.900
That's 64-bit all across the board.

00:17:37.900 --> 00:17:39.900
Every platform does it the same way.

00:17:42.190 --> 00:17:45.830
Similarly,
if you want something that absolutely

00:17:45.970 --> 00:17:49.950
has to be 32-bit for whatever reason,
use ints, unless you're on alphas.

00:17:49.950 --> 00:17:52.360
But, you know, we don't want to think
about alphas anymore.

00:17:54.270 --> 00:17:56.100
Was that a clap there?

00:17:56.100 --> 00:18:02.090
So you can count on integers
being 32-bit in size.

00:18:02.250 --> 00:18:07.090
And then longs and pointers are
the two things that will vary.

00:18:10.830 --> 00:18:13.910
So, we're actually bringing
a program up on 64-bits.

00:18:14.040 --> 00:18:17.350
You may have to make some source changes.

00:18:18.460 --> 00:18:21.660
And there's certain practices
that you have to worry about now

00:18:21.660 --> 00:18:22.700
that you didn't have to before.

00:18:22.700 --> 00:18:25.730
First of all, ints cannot hold pointers.

00:18:25.740 --> 00:18:26.300
I just said that.

00:18:26.300 --> 00:18:29.590
Well, that's actually,
that is the high order bit

00:18:29.590 --> 00:18:34.540
of programming in the 64-bit
world that ints in C family,

00:18:34.540 --> 00:18:36.550
they just sneak in all over the place.

00:18:36.550 --> 00:18:39.530
And they sneak in in unions,
they sneak in in structs,

00:18:39.720 --> 00:18:43.320
they sneak in in function arguments,
all kinds of different places.

00:18:43.320 --> 00:18:46.060
So there's just a lot of
things to watch out for.

00:18:46.060 --> 00:18:49.350
If you don't know what the problem is,
you're going to have to

00:18:49.460 --> 00:18:50.220
figure out how to do it.

00:18:50.220 --> 00:18:51.540
So, if you're going to do it,
you're going to have to

00:18:51.540 --> 00:18:52.220
figure out how to do it.

00:18:52.220 --> 00:18:52.850
And if you're going to do it,
you're going to have to

00:18:52.850 --> 00:18:53.260
figure out how to do it.

00:18:54.380 --> 00:18:58.740
You also get to learn about
the integral constant suffixes.

00:18:58.740 --> 00:19:01.480
And this is something that's actually
been in C for a while and most

00:19:01.480 --> 00:19:03.300
people haven't had to worry about it.

00:19:03.350 --> 00:19:08.300
But if I just say 101, that's an integer.

00:19:08.350 --> 00:19:10.300
What if I want a long 101?

00:19:10.300 --> 00:19:13.300
I actually have to write that as 101L.

00:19:13.300 --> 00:19:16.920
And you can use lowercase
L or uppercase L,

00:19:16.920 --> 00:19:20.300
I believe, but please use uppercase L.

00:19:20.300 --> 00:19:24.300
We only get like one pixel difference
in our fonts between L and 1,

00:19:24.300 --> 00:19:28.300
so let's use something
that's a little more legible.

00:19:29.160 --> 00:19:31.800
So to go along with that,
there's actually a UL,

00:19:31.800 --> 00:19:36.970
which makes an unsigned logint,
and then also LL and ULL.

00:19:37.990 --> 00:19:40.060
We like UL the best because
it's the most pronounceable,

00:19:40.060 --> 00:19:40.200
right?

00:19:40.200 --> 00:19:43.210
You can say 101-ul.

00:19:44.620 --> 00:19:49.140
Also, we have printf directives that you
all may or may not have seen before.

00:19:49.140 --> 00:19:52.920
PercentD is no good because
the way printf works,

00:19:53.020 --> 00:19:56.760
the directives in the format
string tell it how many bytes

00:19:56.910 --> 00:19:58.830
to peel off the argument list.

00:19:58.880 --> 00:20:02.070
And if you say percentD, it says, oh,
well, he just wants an integer.

00:20:02.080 --> 00:20:04.260
So it peels off four bytes.

00:20:04.340 --> 00:20:09.020
And if you pass an 8-byte object, as in,
say, a long or a pointer, okay, well,

00:20:09.080 --> 00:20:10.550
it peels off one half of it.

00:20:10.600 --> 00:20:13.470
And the next thing that printf
prints peels off the other

00:20:13.570 --> 00:20:15.310
half of your 8-byte thingy.

00:20:15.340 --> 00:20:18.810
So that gets very interesting results.

00:20:18.910 --> 00:20:24.430
And if you're a bad programmer and are
using printf to debug instead of GDB...

00:20:24.610 --> 00:20:26.500
Nobody does that, right?

00:20:26.680 --> 00:20:27.290
No, no.

00:20:27.540 --> 00:20:28.260
Nobody's using it.

00:20:28.260 --> 00:20:28.940
This is good.

00:20:28.940 --> 00:20:32.540
Will anybody admit to using printf
instead of GDB for debugging?

00:20:32.540 --> 00:20:34.630
Bad programmers.

00:20:34.630 --> 00:20:36.630
Take their names.

00:20:36.670 --> 00:20:40.620
Take names.

00:20:40.910 --> 00:20:44.050
Yeah,
so if in fact you can't help yourself

00:20:44.050 --> 00:20:49.800
and are using printf for debugging,
be aware that if you're printf,

00:20:49.800 --> 00:20:51.500
if you're not using the
right printf directives,

00:20:51.880 --> 00:20:53.310
printf will be lying to you.

00:20:53.400 --> 00:20:56.690
What you think is an accurate
representation data is in fact

00:20:56.690 --> 00:20:58.800
something completely different.

00:20:58.800 --> 00:21:02.290
I should remind you that GDB in
fact does all this correctly,

00:21:02.390 --> 00:21:03.760
well most of the time.

00:21:03.870 --> 00:21:10.490
GDB knows about displaying 64-bit
values and will do that correctly.

00:21:11.130 --> 00:21:15.340
Now, to go along with this,
we have some things to watch out for.

00:21:15.420 --> 00:21:17.910
And there's a lot of ways to lose.

00:21:18.080 --> 00:21:21.250
For instance,
casting can destroy your data.

00:21:21.250 --> 00:21:24.140
And it will quietly destroy your data.

00:21:24.420 --> 00:21:27.620
Sign extensions will confuse your data.

00:21:27.640 --> 00:21:30.540
Function calls will just lose your data.

00:21:30.610 --> 00:21:34.060
64-bit to 32-bit conversion can scramble
your data and we'll see a couple

00:21:34.060 --> 00:21:36.640
examples of how to do that right.

00:21:36.670 --> 00:21:40.100
And finally,
alignment rules can hole your data.

00:21:42.480 --> 00:21:46.000
So, once again,
signing pointers to ints just

00:21:46.000 --> 00:21:48.540
throws away half of your value.

00:21:48.910 --> 00:21:53.320
And if you're lucky, it'll throw away the
lower half of the value,

00:21:53.440 --> 00:21:55.460
so when you expect it
to get a non-zero value,

00:21:55.470 --> 00:21:58.460
it gives you a zero and your
program crashes right away,

00:21:58.460 --> 00:22:00.070
and you can then fix it.

00:22:00.180 --> 00:22:03.310
If you're unlucky,
you'll lose the upper half of the data,

00:22:03.320 --> 00:22:07.280
and that will work until your program
gets out in the customer's hands,

00:22:07.280 --> 00:22:11.400
and then they allocate that 8
gigabytes of data that you forgot

00:22:11.400 --> 00:22:15.410
to test for back in the lab,
and then the program crashes for them,

00:22:15.510 --> 00:22:18.860
and it doesn't crash for you,
and you get to make a lot of excuses.

00:22:20.980 --> 00:22:25.620
So now in this case, we take a malloc,
we get back a big pointer.

00:22:25.630 --> 00:22:26.840
Now the compiler will warn us.

00:22:26.840 --> 00:22:29.780
If we ask for our usual set of warnings,
it will say assignment makes

00:22:29.780 --> 00:22:32.210
integer from pointer without a cast.

00:22:32.230 --> 00:22:35.810
Now has everybody seen
this message before?

00:22:37.410 --> 00:22:39.300
Nobody seen this message before?

00:22:39.300 --> 00:22:41.300
Okay, well, a few people.

00:22:41.300 --> 00:22:42.510
It happens a lot.

00:22:42.730 --> 00:22:45.890
And up to now, you've been able to say,
yeah, yeah, whatever, you know.

00:22:45.900 --> 00:22:48.440
So I'm integers, pointers, same size,
no big deal.

00:22:48.440 --> 00:22:51.420
Well, now the compiler is telling you
just threw away half your pointer.

00:22:51.420 --> 00:22:54.640
Print out the integer value,
you get just one half of it.

00:22:54.710 --> 00:22:57.590
You do it to a long, nothing,
everything works great.

00:23:01.020 --> 00:23:03.910
Now, casting is something
that people often do.

00:23:04.080 --> 00:23:07.500
There's sometimes a
misconception about casting.

00:23:07.640 --> 00:23:10.280
Casting doesn't do
anything in the compiler.

00:23:10.280 --> 00:23:13.040
All it does is make the compiler shut up.

00:23:13.050 --> 00:23:15.620
You're telling the compiler, yeah, yeah,
I know these types are

00:23:15.620 --> 00:23:17.520
not really compatible,
but I know what I'm doing,

00:23:17.600 --> 00:23:19.740
so just don't say anything.

00:23:19.790 --> 00:23:21.240
Trust me.

00:23:21.310 --> 00:23:24.760
So anyway, so the same thing happens
as in the previous thing.

00:23:24.760 --> 00:23:26.660
It's just now the
compiler did it silently,

00:23:26.710 --> 00:23:29.350
drops off the wrong half of your data.

00:23:34.650 --> 00:23:37.360
Now, when you start playing around with
signed values and unsigned values,

00:23:37.360 --> 00:23:40.290
you can get some interesting
things to happen.

00:23:40.950 --> 00:23:46.680
Because an unsigned integer can
end up looking an awful lot like

00:23:46.680 --> 00:23:53.000
a very large unsigned number.

00:23:53.000 --> 00:23:55.590
So the example here is
a little bit convoluted,

00:23:55.700 --> 00:23:58.740
but the key thing at the top
is to see we have an unsigned

00:23:58.740 --> 00:24:00.940
integer value of 9 bajillion.

00:24:00.940 --> 00:24:04.380
And the key thing about that
is the topmost bit is set.

00:24:04.400 --> 00:24:06.060
They say, well, so what?

00:24:06.790 --> 00:24:11.490
Well, what happens is that if we take
that and if we assign that now

00:24:11.490 --> 00:24:15.100
to an unsigned long variable,
okay,

00:24:16.660 --> 00:24:20.610
What'll happen is that it'll
extend with zeros and that's great.

00:24:20.680 --> 00:24:25.120
But now if we take that unsigned long
and then we assign it to an integer

00:24:25.120 --> 00:24:30.660
and then look at the value and then
assign that now to a unsigned long,

00:24:30.660 --> 00:24:33.770
it's a little bit twisted here,
but it's not that unusual

00:24:33.770 --> 00:24:35.030
in code to have happen.

00:24:35.040 --> 00:24:41.130
What's happened is that the
integer variable now has been said,

00:24:41.200 --> 00:24:43.950
well,
I want to assign to an unsigned value,

00:24:43.950 --> 00:24:45.720
but it's a signed number.

00:24:45.870 --> 00:24:47.510
And so what I'm going to do
is what the compiler says,

00:24:47.560 --> 00:24:50.020
I have to sign extend first
and then assign the value.

00:24:50.080 --> 00:24:53.760
And so if you look at the variable then,
the unsigned long variable,

00:24:53.760 --> 00:24:56.910
you have a really large number.

00:24:57.680 --> 00:24:59.670
And you say, well,
that's kind of a weird number.

00:24:59.680 --> 00:25:00.800
Where did that come from?

00:25:00.800 --> 00:25:06.560
Well, where it came from was the compiler
sign-extended the 9 bajillion to

00:25:06.570 --> 00:25:08.920
have a lot of Fs on the front.

00:25:09.700 --> 00:25:12.350
So this is something that, for instance,
you don't want to end up

00:25:12.410 --> 00:25:14.690
sticking into an iteration loop.

00:25:14.920 --> 00:25:19.170
It might have ran a reasonable
amount of time in 32 bits,

00:25:19.180 --> 00:25:22.560
and you run it in 64 bits,
and it seems very slow for some reason.

00:25:22.560 --> 00:25:24.920
It's not the compiler's
fault in this case.

00:25:27.800 --> 00:25:34.030
Function calls are another variation
on the losing your data routine.

00:25:34.030 --> 00:25:38.700
Again, quietly drops it off in the
process of passing to the function.

00:25:38.700 --> 00:25:42.700
This is mainly a problem
for unprototyped functions.

00:25:42.740 --> 00:25:45.900
The rules of C are that if a
function doesn't have a prototype,

00:25:45.970 --> 00:25:48.890
it's just going to assume that
you're passing in integers

00:25:48.980 --> 00:25:50.860
and you're returning integers.

00:25:51.490 --> 00:25:53.020
And so this is what you get.

00:25:53.070 --> 00:25:56.360
You look inside and the compiler
says it has no reason to say

00:25:56.360 --> 00:25:59.330
anything because you told it what
to do and it just followed along.

00:25:59.340 --> 00:26:04.170
So prototypes are really important
and you should be asking the compiler

00:26:04.440 --> 00:26:07.240
to warn you about prototypes in
case there's some that you thought

00:26:07.240 --> 00:26:08.510
were there and really weren't.

00:26:13.930 --> 00:26:17.980
So I talked about 64-
to 32-bit extraction.

00:26:18.000 --> 00:26:19.360
There's a lot of ways to do this.

00:26:19.360 --> 00:26:21.380
There's right ways and wrong ways.

00:26:21.380 --> 00:26:24.820
There's a whole long list of wrong ways,
but in the interest of space and time,

00:26:24.820 --> 00:26:27.000
I didn't include all of those.

00:26:27.010 --> 00:26:30.200
So I just have a couple
examples how to do it right.

00:26:30.200 --> 00:26:35.490
One way to do it right is to create a
union that consists of a long on one side

00:26:35.490 --> 00:26:37.760
and a pair of ints on the other side.

00:26:37.760 --> 00:26:42.080
And then you can take a long variable,
assign it to the union,

00:26:42.080 --> 00:26:45.020
and then look at the separate integers.

00:26:45.020 --> 00:26:52.580
Now, this has a certain disadvantage in
that this is Indian-ness sensitive.

00:26:52.580 --> 00:26:56.360
And prior to a couple of days ago,
I didn't know we were going to have

00:26:56.360 --> 00:26:58.840
to talk about Indian-ness that much.

00:26:58.880 --> 00:27:03.880
But anyway, this is actually one of the
places where you are vulnerable.

00:27:03.880 --> 00:27:07.290
If this data is coming to and
from a file and you're on a little

00:27:07.290 --> 00:27:11.940
Indian machine that's 64-bit,
this code will behave differently.

00:27:12.430 --> 00:27:17.650
Now another way to do that that finesses
the problem is to do it with arithmetic.

00:27:17.650 --> 00:27:20.630
And in this case,
the second example down below,

00:27:20.760 --> 00:27:24.250
we can do an ampersand to
extract out the low half of

00:27:24.250 --> 00:27:28.250
the integer of the long value,
and we can do a shift to

00:27:28.250 --> 00:27:30.250
extract out the high end.

00:27:30.700 --> 00:27:56.500
[Transcript missing]

00:27:58.640 --> 00:28:01.480
Okay, so writing compatible code.

00:28:01.480 --> 00:28:04.740
Unfortunately, the slides seem to, oh,
no, sorry.

00:28:04.740 --> 00:28:08.260
We get, yeah, okay,
a little bit backwards here.

00:28:08.370 --> 00:28:10.530
So I mentioned about
alignments and holes.

00:28:10.530 --> 00:28:15.220
And this is a, this was actually an
interesting little example.

00:28:15.300 --> 00:28:18.240
This is like one slide that
actually wasn't in last year's talk,

00:28:18.240 --> 00:28:19.600
if you were at last year's.

00:28:19.640 --> 00:28:24.950
Because this actually came up when
I was testing the GCC by compiling

00:28:25.280 --> 00:28:27.920
itself as a 64-bit program.

00:28:28.600 --> 00:28:31.570
When you run the compiler
on your systems right now,

00:28:31.570 --> 00:28:34.860
on your Tiger systems,
it's running as a 32-bit program

00:28:34.860 --> 00:28:36.890
even if you're asked for 64-bit code.

00:28:36.910 --> 00:28:39.490
You're asked for 64,
it's effectively acting as a

00:28:39.490 --> 00:28:40.780
cross-compiler in that case.

00:28:40.780 --> 00:28:43.800
But I said, well,
it would be a good test to

00:28:43.940 --> 00:28:49.260
configure GCC itself as a 64-bit
program and then make it bootstrap.

00:28:49.320 --> 00:28:53.110
And if a compiler bootstraps correctly,
it'll generate a lot of code

00:28:53.470 --> 00:28:56.690
and the compiler will be
exactly the same byte for byte.

00:28:56.760 --> 00:28:58.360
And that's a standard test.

00:28:58.440 --> 00:28:58.580
So I'm going to show you
a little bit of a test.

00:28:58.600 --> 00:28:59.840
compiler correctness.

00:29:00.000 --> 00:29:03.560
But anyway, so I did all this,
sort of made up of fake keys, you know,

00:29:03.560 --> 00:29:06.520
run it as a 64-bit program.

00:29:06.520 --> 00:29:09.280
And well, it didn't work.

00:29:09.280 --> 00:29:11.560
And not only didn't it work,
but it didn't work in

00:29:11.560 --> 00:29:12.660
a rather amusing way.

00:29:12.660 --> 00:29:15.590
You look at the preprocessor output,
and the same token kept

00:29:15.590 --> 00:29:17.600
showing up over and over again.

00:29:17.600 --> 00:29:21.180
I had like, you know,
55 functions all named div di 3

00:29:21.180 --> 00:29:26.130
coming out of the preprocessor,
so that was kind of an interesting bug.

00:29:26.790 --> 00:29:30.500
And so after some poking around,
I discovered that, in fact,

00:29:30.530 --> 00:29:33.840
the bug only kicked in when the
code was being compiled optimized.

00:29:33.900 --> 00:29:38.980
If I compiled GCC itself unoptimized,
then everything was fine.

00:29:39.600 --> 00:29:42.650
So it took a little poking around
to figure out what had happened.

00:29:42.650 --> 00:29:45.500
And in the preprocessor,
they had the tokens.

00:29:45.740 --> 00:29:49.660
The tokens in GCC's preprocessor
are represented as a union.

00:29:49.660 --> 00:29:52.700
You can see on the 32-bit side,
it's a union,

00:29:52.920 --> 00:29:55.160
and there's two halves of the union.

00:29:55.160 --> 00:29:58.340
One half, which is just a pointer,
like for a token, that's a string.

00:29:58.340 --> 00:30:02.220
And the other one is a struct
consisting of an integer,

00:30:02.280 --> 00:30:05.550
which is like a type tag,
and then a char star,

00:30:05.550 --> 00:30:08.610
which is a pointer to some blob of data.

00:30:10.470 --> 00:30:14.300
So, anyway,
when this got compiled 64-bit,

00:30:14.470 --> 00:30:19.510
the alignment rules for 64-bit
required that things be 8-byte aligned.

00:30:19.600 --> 00:30:23.920
And what this did was very quietly
opened up a little hole between that

00:30:23.920 --> 00:30:28.900
4-byte integer and the char star,
which was 8 bytes.

00:30:29.380 --> 00:30:34.880
Now, the reason this mattered
was because the GCC hacker,

00:30:34.880 --> 00:30:38.560
who shall remain nameless,
that initialized the union,

00:30:38.560 --> 00:30:43.820
assigned to the integer and to
the char star side of the union,

00:30:43.820 --> 00:30:47.140
two assignment statements,
assigned zeros to both of them, says,

00:30:47.210 --> 00:30:48.240
well, that's good enough.

00:30:48.330 --> 00:30:50.600
That clears the token for me.

00:30:52.460 --> 00:30:56.780
And so what happened then
is that the compiler then,

00:30:56.780 --> 00:31:01.050
when it's compiling unoptimized,
the compiler generated two 8-byte loads,

00:31:01.050 --> 00:31:04.080
clearing the integer and the
hole on the 64-bit side and

00:31:04.080 --> 00:31:05.680
then clearing the char star.

00:31:05.680 --> 00:31:09.180
And then when you turn the optimized,
the optimized says, well, hey,

00:31:09.240 --> 00:31:10.460
I'm clearing a hole.

00:31:10.460 --> 00:31:11.290
I don't need to do that.

00:31:11.500 --> 00:31:16.830
So it turned the 8-byte write of
the first half into a 4-byte write.

00:31:17.760 --> 00:31:22.280
So that if any part of the code wanted to
look at the char star side of the union,

00:31:22.280 --> 00:31:25.950
it saw whatever was left
there from the previous token.

00:31:25.960 --> 00:31:28.600
And hilarity ensued.

00:31:31.130 --> 00:31:34.300
So, in a classic illustration,
the open source world,

00:31:34.390 --> 00:31:37.060
it took me about a day or so to
figure out what had happened.

00:31:37.060 --> 00:31:40.220
And then I wasn't quite
sure I liked the fix for it,

00:31:40.350 --> 00:31:43.090
so I sat on it for a day
and did other things.

00:31:43.120 --> 00:31:46.190
And then I came back and updated
my GCC sources and somebody

00:31:46.290 --> 00:31:49.070
else had actually run into
the same bug and fixed it.

00:31:49.180 --> 00:31:52.220
So, saved me a little time and trouble.

00:31:55.460 --> 00:31:59.340
Now, back up a moment here,
a little slide rearrangement.

00:31:59.390 --> 00:32:01.990
Okay, so in order to--

00:32:02.430 --> 00:32:04.960
Sorry,
this is more than a little scrambling.

00:32:04.980 --> 00:32:09.300
Okay, so we have some API changes.

00:32:09.550 --> 00:32:14.850
The most important thing to keep in
mind should you need to distinguish

00:32:14.850 --> 00:32:21.940
between 32 and 64-bit code is
a macro called double_lp64__.

00:32:22.330 --> 00:32:26.500
This is true when you're
compiling 64-bit and it's not

00:32:26.500 --> 00:32:29.200
defined when you're compiling 32.

00:32:29.380 --> 00:32:31.700
And this is true for all architectures.

00:32:31.780 --> 00:32:35.160
A few days ago I planned to
do a wink wink nudge nudge

00:32:35.160 --> 00:32:38.910
about other architectures,
but now I can say that

00:32:38.910 --> 00:32:44.650
if we do a 64-bit Intel,
I will commit us to making LP64

00:32:44.750 --> 00:32:49.590
defined correctly for a 64-bit
Intel architecture as well.

00:32:50.330 --> 00:32:55.520
Now if you want to be PowerPC specific,
we have a double underscore

00:32:55.520 --> 00:32:57.700
PPC64 double underscore.

00:32:57.830 --> 00:33:03.010
And what that is,
it's defined for compiling PowerPC 64-bit

00:33:03.120 --> 00:33:07.040
and the traditional macro that
we've had all along for that,

00:33:07.170 --> 00:33:09.460
the double underscore
PPC double underscore,

00:33:09.460 --> 00:33:10.380
is not defined.

00:33:10.550 --> 00:33:12.760
So the two of them are
actually either/ors.

00:33:12.910 --> 00:33:16.550
We had a lot of arguing back and
forth and the either/or people

00:33:16.560 --> 00:33:18.480
won out over the or people.

00:33:18.830 --> 00:33:23.050
And so what that means is that if you
want to have a piece of code that's

00:33:23.390 --> 00:33:28.110
the same for both PPC and 64-bit PPC,
you need to say something like,

00:33:28.160 --> 00:33:31.900
if defined, PPC64 or defined PPC.

00:33:33.740 --> 00:33:38.790
We've had a few unfortunate
cases where both of them were not

00:33:38.790 --> 00:33:45.660
defined and the code claimed that
there was no PPC64 stuff at all.

00:33:46.300 --> 00:33:48.440
Now I have an example here
of how you might use it.

00:33:48.440 --> 00:33:50.930
Of course,
there's more and less clever ways.

00:33:51.040 --> 00:33:54.940
There's just a simple if-def,
and the whole point is to use

00:33:55.100 --> 00:34:00.380
an int in the LP64 case as the
last argument to get at our list,

00:34:00.470 --> 00:34:02.210
which is actually out of our system.

00:34:03.820 --> 00:34:07.600
But if you're not doing LP64,
you want to keep that as a long because

00:34:07.600 --> 00:34:12.140
that keeps stability in the 32-bit API.

00:34:12.720 --> 00:34:14.920
and finally for you assembly
language programmers,

00:34:14.960 --> 00:34:17.090
any assembly language programmers?

00:34:17.200 --> 00:34:18.000
Not very many.

00:34:18.070 --> 00:34:20.550
Oh, there's one.

00:34:21.120 --> 00:34:25.880
We do have a new directive called .quad
which just allocates out an 8-byte

00:34:25.880 --> 00:34:29.040
block and stuffs it just like .long.

00:34:29.580 --> 00:34:34.380
Some additional features
and facilities we give you.

00:34:34.380 --> 00:34:40.240
We have standard types and macros,
size T, intPTRT, all those you probably

00:34:40.240 --> 00:34:41.730
looked at and said,
yeah, whatever, who cares.

00:34:41.760 --> 00:34:43.150
Well, now they really matter.

00:34:43.160 --> 00:34:46.550
IntPTRT, for instance,
guarantees to give you a size of

00:34:46.550 --> 00:34:51.890
integer big enough to hold a pointer
whether you're doing 64-bit or 32-bit.

00:34:52.120 --> 00:34:53.860
Similarly,
Unix has defined some of its own

00:34:53.860 --> 00:34:56.070
types in the same general vein.

00:34:56.110 --> 00:34:58.400
And you should also look at,
especially if you're working with

00:34:58.400 --> 00:35:00.510
open source code that's already
been ported around a bunch,

00:35:00.910 --> 00:35:05.320
quite likely it already has some
macros to support 32 versus 64.

00:35:05.320 --> 00:35:11.270
A popular example, for instance,
is a way to macrify

00:35:11.270 --> 00:35:14.270
the printf directives.

00:35:14.460 --> 00:35:17.080
Because you'll get a situation where,
and the compiler will

00:35:17.080 --> 00:35:20.260
complain about this,
if you say use %LLD on something

00:35:20.260 --> 00:35:23.260
that's not actually long,
long, and say, oh, you're not using the

00:35:23.260 --> 00:35:24.180
right printf directive.

00:35:24.200 --> 00:35:27.340
So people do a thing where they
make a macro and then kind of

00:35:27.340 --> 00:35:30.680
have the macro pasted in the
middle of the format string.

00:35:34.100 --> 00:35:37.020
Okay, so it's just a sampling
of the kinds of things,

00:35:37.080 --> 00:35:40.140
and we'll have a time after
a lab right after this,

00:35:40.140 --> 00:35:43.810
so I'll be happy to answer more
questions about recommended

00:35:43.810 --> 00:35:46.840
ways to make 64-bit code work.

00:35:50.380 --> 00:35:54.000
So, as I alluded to before,
we don't have the full

00:35:54.000 --> 00:35:56.280
stack 64-bit right now.

00:35:56.400 --> 00:35:59.380
What we did was we focused
on those things that are

00:35:59.380 --> 00:36:02.730
needed by 64-bit programs,
programs that really need

00:36:02.730 --> 00:36:06.870
the 64-bit capabilities,
and those basically consist of servers,

00:36:06.870 --> 00:36:08.300
databases, compute engines.

00:36:08.300 --> 00:36:11.570
These will generally
be written in C or C++.

00:36:11.570 --> 00:36:16.300
They'll be command-line,
and they may be launched by plug-ins.

00:36:16.460 --> 00:36:21.300
Okay, we've made it possible for them
to be launched by plug-ins.

00:36:21.300 --> 00:36:24.300
But they're generally things that
kind of run in the background.

00:36:24.300 --> 00:36:27.180
And all they really need
is they need lib system,

00:36:27.240 --> 00:36:32.240
system facilities, and if they do math,
we have the Accelerate framework,

00:36:32.340 --> 00:36:34.300
aka VecLib.

00:36:34.300 --> 00:36:36.570
That's also 64-bit.

00:36:39.040 --> 00:36:46.640
So the basic deal here is
that you can have a lot of

00:36:47.020 --> 00:36:49.480
We have this ability to map
a huge amount of memory,

00:36:49.510 --> 00:36:55.790
but in fact you still have to think about
exactly how you want to structure that.

00:36:56.250 --> 00:37:03.500
So our general optimal behavior is
with a relatively small but still

00:37:03.500 --> 00:37:05.350
greater than 4 gigabyte space.

00:37:05.350 --> 00:37:08.400
So I said, laughed about it, yeah,
you can allocate 500 terabytes,

00:37:08.400 --> 00:37:11.230
but probably that's not
going to be a big winner.

00:37:11.240 --> 00:37:15.160
What we're really looking at is
something that supports thousands

00:37:15.290 --> 00:37:17.110
of mappings per address space.

00:37:19.060 --> 00:37:23.500
And again, a lot of this is all about
giving convenient access to

00:37:23.500 --> 00:37:24.900
large amounts of physical memory.

00:37:24.900 --> 00:37:29.040
If I have something where I need
a 500 terabyte swap space,

00:37:29.040 --> 00:37:32.520
I'm keeping the disk real
busy and I'm not really going

00:37:32.520 --> 00:37:34.640
to get any win at that point.

00:37:35.820 --> 00:37:39.190
So, let's see.

00:37:39.190 --> 00:37:41.310
And as we said, not the whole stack.

00:37:41.390 --> 00:37:44.610
Now we actually lied a little
bit about the 64-bit part.

00:37:45.010 --> 00:37:49.270
The OS guys, being the way they are,
actually kept some of the

00:37:49.270 --> 00:37:50.500
address space for themselves.

00:37:50.500 --> 00:37:55.430
So, so we actually only get,
really only get 2 to the 51 at this,

00:37:55.430 --> 00:37:57.280
at this point in Tiger.

00:37:57.280 --> 00:38:02.420
And things like P-thread stacks and so
forth will be consuming some of the,

00:38:02.520 --> 00:38:03.990
the higher space.

00:38:04.880 --> 00:38:08.570
But I'm, I'm assuming that everybody can,
can think of a lot of things

00:38:08.570 --> 00:38:10.610
they can do with 2 to the 51.

00:38:13.410 --> 00:38:16.310
And finally, no GUI frameworks.

00:38:16.310 --> 00:38:18.020
So what's that all about?

00:38:18.580 --> 00:38:20.300
Well, I mean, there's the porting part,
right?

00:38:20.300 --> 00:38:21.500
We have a lot of code.

00:38:21.830 --> 00:38:26.930
We have all the same 64-bit issues
that everybody else does in their code.

00:38:27.880 --> 00:38:32.660
So the strategy we're looking at for
people that need 64-bit right now,

00:38:32.660 --> 00:38:38.480
and they're also looking at GUIs,
is to set up the ability to communicate

00:38:38.480 --> 00:38:46.560
with a 32-bit GUI front end using any
of several various IPC mechanisms.

00:38:46.560 --> 00:38:50.510
And so to talk about that,
we have Jim McGee.

00:38:56.500 --> 00:39:03.000
[Transcript missing]

00:39:03.500 --> 00:39:04.910
What could be so hard, right?

00:39:04.910 --> 00:39:08.630
Just a little black line
connecting two applications,

00:39:08.630 --> 00:39:10.110
you know, what could be so hard?

00:39:10.140 --> 00:39:13.160
What was even worse with this
quote was in terms of how to

00:39:13.160 --> 00:39:16.280
implement that black line,
not necessarily how to use it.

00:39:16.300 --> 00:39:24.230
So what we've done in IPC in 64-bit
space was try to address some of the

00:39:24.230 --> 00:39:28.610
key requirements from those set of
applications we just talked about.

00:39:29.090 --> 00:39:32.880
The ones that we expect to be the
first arrivers on the 64-bit space.

00:39:32.880 --> 00:39:37.590
So what do we need to provide
for IPC services in 64-bit space?

00:39:37.600 --> 00:39:41.700
Well, we needed to be able to solve
that picture you just saw.

00:39:41.700 --> 00:39:44.380
We need to be able to
take a 64-bit backend,

00:39:44.380 --> 00:39:48.340
so a compute engine or a database engine,
and we need to be able to put a

00:39:48.340 --> 00:39:50.240
32-bit GUI on the front of it.

00:39:50.300 --> 00:39:55.730
So we needed 32, 64 kinds of IPC,
things that those backends

00:39:55.730 --> 00:39:58.090
would need to be able to do,
right?

00:39:58.100 --> 00:40:01.510
And would have the facilities to do,
and the ability to communicate

00:40:01.590 --> 00:40:03.580
those with 32-bit frontends.

00:40:04.960 --> 00:40:07.340
and your particular ones.

00:40:07.440 --> 00:40:10.880
But we also needed the ability,
if you've ever noticed

00:40:10.880 --> 00:40:13.400
on a Mac OS X system,
it's not just a kernel

00:40:13.550 --> 00:40:14.900
and a bunch of apps.

00:40:15.040 --> 00:40:19.010
There's dozens,
hundreds sometimes of servers

00:40:19.010 --> 00:40:21.460
running in the background,
little helper applications.

00:40:21.460 --> 00:40:24.270
64-bit apps are clients of those.

00:40:24.300 --> 00:40:27.100
They have to do network lookups,
so they have to communicate

00:40:27.100 --> 00:40:29.260
with LookupD and other
services throughout the system.

00:40:29.260 --> 00:40:32.240
So we needed to be able to provide
the ability not only for you to

00:40:32.240 --> 00:40:37.540
write a custom 32-bit front end that
works with your 64-bit application,

00:40:37.540 --> 00:40:40.010
but also the ability to
have it talk to the system

00:40:40.010 --> 00:40:41.310
services throughout the system.

00:40:41.320 --> 00:40:44.260
And so we've done that
heavy lifting for you.

00:40:44.260 --> 00:40:48.170
All that is largely hidden inside
of the current lib system that

00:40:48.170 --> 00:40:49.580
communicates to those facilities.

00:40:49.580 --> 00:40:51.980
That stuff just works.

00:40:51.980 --> 00:40:53.210
Thank you.

00:40:53.460 --> 00:40:54.350
All right.

00:40:54.420 --> 00:40:57.500
And we also needed the ability,
if you are going to create, let's say,

00:40:57.500 --> 00:41:01.460
a server that needs to fork itself
or to create multiple 64-bit servers,

00:41:01.460 --> 00:41:03.560
you obviously need communication
between the two of them.

00:41:05.280 --> 00:41:08.940
So if you look at what we had
as far as services available,

00:41:08.960 --> 00:41:13.250
I mean this is a small sampling of the
IPC services available in Mac OS X.

00:41:13.260 --> 00:41:15.890
There's many layers above this.

00:41:15.890 --> 00:41:19.800
The layers above the gray line
are those that are typically

00:41:19.800 --> 00:41:22.350
provided by services at user space.

00:41:22.380 --> 00:41:26.380
The ones below are things that the
kernel provides for IPC services.

00:41:26.380 --> 00:41:29.840
There's many additional things that
could be sitting up on top of there.

00:41:29.840 --> 00:41:32.300
There's distributed objects
and all of those things.

00:41:32.300 --> 00:41:35.790
But these are the core ones that
people typically focused on using.

00:41:35.800 --> 00:41:39.230
And so in Mac OS X you have all of
these services available to you.

00:41:39.240 --> 00:41:40.270
Which ones do you choose?

00:41:40.280 --> 00:41:44.400
Well, if we give you a little map
of what the 64-bit space

00:41:44.470 --> 00:41:49.400
looks like currently in Tiger,
we're helping you solve that real tough

00:41:49.840 --> 00:41:52.450
decision by removing a bunch of them.

00:41:55.370 --> 00:41:59.810
So there's a set of services that are
just not available in 64-bit space.

00:41:59.940 --> 00:42:01.050
Why?

00:42:01.510 --> 00:42:03.970
Mostly because they're
implemented by frameworks that

00:42:03.970 --> 00:42:06.150
we haven't ported to 64-bit yet.

00:42:06.250 --> 00:42:08.200
So they're not available to you.

00:42:08.200 --> 00:42:12.130
You can't use Apple Events directly
from a 64-bit application.

00:42:12.200 --> 00:42:16.200
You know, we don't have a lot of those
GUI kind of facilities.

00:42:16.340 --> 00:42:20.200
User notifications,
CF user notifications, CF message port,

00:42:20.200 --> 00:42:21.200
that kind of thing.

00:42:21.200 --> 00:42:24.210
They're not there yet,
but as you can see,

00:42:24.290 --> 00:42:27.200
there's still quite a bit that is left.

00:42:27.330 --> 00:42:31.200
There's another set of services which
we provide to 64-bit applications,

00:42:31.200 --> 00:42:34.350
but we've kind of
limited what they can do,

00:42:34.350 --> 00:42:37.190
where they have some small restrictions.

00:42:37.200 --> 00:42:40.190
And what are those?

00:42:40.340 --> 00:42:46.600
Well, the POSIX thread synchronizers,
they've never been able

00:42:46.600 --> 00:42:49.200
to cross task boundaries.

00:42:49.200 --> 00:42:51.200
And that hasn't changed in the past.

00:42:51.200 --> 00:42:53.200
They're still in the 64-bit space.

00:42:53.200 --> 00:42:57.490
So you can't use shared Pthread mutex
or something like that in order to

00:42:57.490 --> 00:42:59.910
implement cross address space IPC.

00:43:00.200 --> 00:43:04.190
It was true in 32-bit,
still true in 64-bit.

00:43:04.200 --> 00:43:07.200
So those aren't really available
for that kind of communication.

00:43:07.200 --> 00:43:10.180
They work great in a process.

00:43:10.210 --> 00:43:13.350
System 5 shared memory,
as many of you have

00:43:13.350 --> 00:43:15.200
probably tried to use those.

00:43:15.200 --> 00:43:21.200
The System 5 IPC services were
really provided as a last ditch,

00:43:21.200 --> 00:43:23.160
and they're now in the
POSIX thread synchronizer.

00:43:23.250 --> 00:43:25.200
So we're able to use those.

00:43:25.200 --> 00:43:27.550
And we're also able to use
the POSIX thread synchronizer.

00:43:27.730 --> 00:43:30.810
So they're very limited in
how you can use them and what

00:43:30.890 --> 00:43:33.590
kind of-- the number of them,
the size of them.

00:43:33.830 --> 00:43:37.940
When you then try to scale that and try
and use it in a 64-bit address space,

00:43:37.940 --> 00:43:42.440
right, you're just-- they become very
unmanageable very quickly.

00:43:42.610 --> 00:43:45.710
So we--they tend not to be so useful.

00:43:46.080 --> 00:43:49.080
Uh, and Mach IPC is actually one
of the things we use a lot,

00:43:49.150 --> 00:43:51.880
but there are some
restrictions in that space.

00:43:51.960 --> 00:43:55.680
Um, one of the restrictions is
that an individual piece of

00:43:55.680 --> 00:43:58.940
data that you can send back and
forth is limited to 4 gigabytes.

00:43:58.940 --> 00:44:02.530
So if you have two 64-bit
address spaces and you want to

00:44:02.530 --> 00:44:06.250
have a communication with them,
you can't send a terabyte

00:44:06.250 --> 00:44:08.890
in as a single unit,
as a single piece of data

00:44:08.950 --> 00:44:12.940
in a Mach message between
two 64-bit address spaces.

00:44:13.060 --> 00:44:16.930
You can break it up or you can create
handles and send handles across,

00:44:16.930 --> 00:44:18.750
but you can't do it as one.

00:44:18.940 --> 00:44:23.940
It's hard to call this a limitation as
far as doing 32 to 64-bit communication.

00:44:23.940 --> 00:44:27.080
You couldn't ever do this anyway.

00:44:28.550 --> 00:44:32.030
What you're left with is a fairly
rich set of services anyway.

00:44:32.030 --> 00:44:39.540
They fall into the somewhat BSD category
of services or kernel services because

00:44:39.650 --> 00:44:43.660
that's essentially what facilities are
there for 64-bit applications anyway.

00:44:45.000 --> 00:44:47.920
Almost all of them are
provided by the kernel.

00:44:47.920 --> 00:44:53.080
There's one service that's available
that's provided by UserLand Services.

00:44:53.080 --> 00:44:54.760
It's the Notify Demon.

00:44:54.760 --> 00:45:00.460
It's actually used for a lot of
asynchronous kind of notifications.

00:45:00.460 --> 00:45:04.160
One of the common ones in the
system is time or time zone changes.

00:45:04.160 --> 00:45:08.030
It used to be that every time an app
would go to try and look at the time,

00:45:08.030 --> 00:45:12.120
it would have to read a file to try and
figure out what the current time zone

00:45:12.120 --> 00:45:14.700
was and determine how to display that.

00:45:15.000 --> 00:45:18.300
And that was very expensive and things
that would display time frequently.

00:45:18.340 --> 00:45:22.050
So Notify Demon actually has a
notification that will let you

00:45:22.050 --> 00:45:24.440
know whether time zone has changed.

00:45:24.760 --> 00:45:27.230
Almost never fires,
so you can run with a cached

00:45:27.230 --> 00:45:30.560
version of the time zone
service and everything works.

00:45:30.700 --> 00:45:33.940
And you can use it for your own
kind of notifications as well,

00:45:33.940 --> 00:45:35.940
and it's a wonderful little service.

00:45:35.940 --> 00:45:41.020
But the rest of these services are,
you know, essentially the kernel

00:45:41.020 --> 00:45:42.830
services that do IPC.

00:45:43.850 --> 00:45:49.040
So what do we recommend you do, right,
as far as putting a GUI front end

00:45:49.040 --> 00:45:53.550
and then having communication or
IPC between them and your 64-bit app?

00:45:53.620 --> 00:46:00.020
Well, there have been many demonstrations
or examples of how to embed a

00:46:00.090 --> 00:46:03.780
tool into a GUI application,
something to go off and maybe

00:46:03.780 --> 00:46:08.280
read the process data stuff and
return a result into the GUI tool.

00:46:09.340 --> 00:46:12.720
Build your app the same way,
just that your tool now is

00:46:12.730 --> 00:46:14.580
going to be a 64-bit tool.

00:46:17.620 --> 00:46:23.040
and that tool is again largely
limited to the POSIX layer,

00:46:23.120 --> 00:46:27.000
the BSD layer of services in the system.

00:46:27.000 --> 00:46:28.820
So those are the ones you're going
to want to take advantage of.

00:46:28.860 --> 00:46:32.430
You also want to use the easiest,
simplest,

00:46:32.430 --> 00:46:37.430
whatever IPC mechanism available,
the most cooked version of

00:46:37.430 --> 00:46:39.980
IPC that you can get away with.

00:46:40.890 --> 00:46:42.960
Obviously it has to fit your needs.

00:46:42.960 --> 00:46:46.610
Some are really good at sending
small amounts of data back

00:46:46.840 --> 00:46:48.680
and forth very efficiently.

00:46:48.680 --> 00:46:51.330
Others,
like shared memory kind of facilities,

00:46:51.330 --> 00:46:53.520
are meant for huge amounts of data.

00:46:55.610 --> 00:46:59.600
But you have to choose one from those
set that's available both 32 and 64.

00:47:02.320 --> 00:47:08.030
One of the interesting possibilities,
and it's one that we're going to

00:47:08.030 --> 00:47:10.160
use in an example we're going to
show you in just a little bit,

00:47:10.160 --> 00:47:13.300
is you can actually combine 64 and,
I mean,

00:47:13.300 --> 00:47:16.810
you can combine using higher-level
services with the lower-level

00:47:16.810 --> 00:47:18.830
primitives that they're built on.

00:47:18.860 --> 00:47:22.720
So you can take a CF application
and you can use the higher-level

00:47:22.720 --> 00:47:25.500
service like a CF socket,
and you can embed that

00:47:25.500 --> 00:47:26.970
in your GUI application.

00:47:26.980 --> 00:47:28.340
It gives you lots of advantages.

00:47:28.340 --> 00:47:31.930
It can interact with the run loop
instead of having to be a dedicated

00:47:32.310 --> 00:47:36.120
facility that you use just in a
POSIX style from a single thread.

00:47:36.120 --> 00:47:38.180
So you can move that into the run loop.

00:47:38.220 --> 00:47:42.110
But you can also use the raw
facility underlying that,

00:47:42.110 --> 00:47:46.500
like the raw socket,
inside of the 64-bit application.

00:47:46.500 --> 00:47:49.930
So that the 64-bit application
has available what it can use,

00:47:50.140 --> 00:47:53.880
and yet the 32-bit can still
use the higher-level facilities.

00:47:58.840 --> 00:48:01.660
So what else can you do
to make this simpler?

00:48:01.700 --> 00:48:05.980
Well, one of the simplest things you
can do is to take advantage of

00:48:05.980 --> 00:48:07.670
a parent-child relationship.

00:48:07.700 --> 00:48:11.810
The little tool,
or the 64-bit tool that's going to

00:48:11.810 --> 00:48:16.300
be back-ending your GUI application,
if you make that the child

00:48:16.310 --> 00:48:19.380
of the GUI application,
lots of things come in for

00:48:19.380 --> 00:48:20.680
free as a result of that.

00:48:20.760 --> 00:48:24.700
One of the biggest ones is inheritance.

00:48:24.700 --> 00:48:28.610
When you create a child process,
lots of things are inherited

00:48:28.750 --> 00:48:32.810
across between the parent-child,
your 32-bit GUI application,

00:48:32.810 --> 00:48:36.530
and the backend, the child,
the 64-bit tool.

00:48:36.700 --> 00:48:41.700
File descriptors, those file descriptors
can be just regular data.

00:48:41.700 --> 00:48:47.380
They could be shared memory regions that
you can then map later on inside of the

00:48:47.380 --> 00:48:49.700
GUI application to get shared memory.

00:48:49.700 --> 00:48:50.680
That way, you can get a lot of data.

00:48:50.720 --> 00:48:51.030
way.

00:48:51.030 --> 00:48:54.630
They can be semaphores.

00:48:54.850 --> 00:48:58.190
They can be, you know, pipes.

00:48:58.300 --> 00:49:00.360
That's actually one of the best ones,
right?

00:49:00.360 --> 00:49:02.640
Standard in, standard out,
standard error is one of the

00:49:02.680 --> 00:49:06.290
simplest things you can do,
right, is set those up in the parent in

00:49:06.300 --> 00:49:10.650
the GUI application so that when
you fork off your child and it

00:49:10.650 --> 00:49:17.060
execs its 64-bit application binary,
it has its standard in, standard out,

00:49:17.060 --> 00:49:19.180
that it can communicate
right back to the parent.

00:49:19.180 --> 00:49:23.330
Works great if you have long
computations with fairly small data

00:49:23.330 --> 00:49:25.360
results going back the other way.

00:49:25.380 --> 00:49:27.140
All right, just stream them back.

00:49:28.590 --> 00:49:31.600
But you can also use inherited memory.

00:49:31.600 --> 00:49:34.130
So you have your GUI application.

00:49:34.140 --> 00:49:36.160
It allocates some chunk of memory.

00:49:36.160 --> 00:49:41.130
You can actually use the POSIX inherit
APIs to set the inheritance

00:49:41.140 --> 00:49:42.630
attribute on that chunk of memory.

00:49:42.640 --> 00:49:47.000
Then you go ahead and exec your child,
your 64-bit tool.

00:49:47.000 --> 00:49:51.810
That memory shows up inside of the
64-bit tool sitting there shared.

00:49:51.810 --> 00:49:54.200
And you can use that
memory for communications.

00:49:55.010 --> 00:49:57.310
Especially if you combine it
with something like a semaphore,

00:49:57.310 --> 00:49:59.340
then you can go ahead and
do that pretty nicely.

00:50:01.300 --> 00:50:04.350
One of the disadvantages of
this whole split is now you

00:50:04.350 --> 00:50:06.180
have to manage your child,
right?

00:50:06.180 --> 00:50:09.000
This tool is now a second process
part of their application.

00:50:09.000 --> 00:50:13.480
So you've got this burden to manage it.

00:50:13.620 --> 00:50:15.660
One of the nice things is
a lot of these facilities,

00:50:15.660 --> 00:50:19.160
especially if you use like the
CF socket kind of facility built into,

00:50:19.160 --> 00:50:22.540
you know, its ability to integrate
with the run loop,

00:50:22.620 --> 00:50:25.480
it actually has an invalidation
callback that will automatically

00:50:25.520 --> 00:50:27.520
trigger if the child goes away,
right?

00:50:27.520 --> 00:50:30.150
And so you can clean up nicely that way.

00:50:31.690 --> 00:50:35.170
You also have Sig Child,
which can-- it's a little trickier to

00:50:35.170 --> 00:50:39.400
deal with Sig Child in a GUI application,
but not too bad.

00:50:40.440 --> 00:50:42.400
Right, so what are we going to do?

00:50:42.400 --> 00:50:43.700
What do we recommend you do?

00:50:43.700 --> 00:50:45.240
Well, here's a real simple example.

00:50:45.240 --> 00:50:49.060
We're setting up an example where
you have a GUI front end and it

00:50:49.420 --> 00:50:54.540
just opens a 64-bit application,
launches a 64-bit tool in the background,

00:50:54.540 --> 00:50:57.520
and uses the standard in,
standard out facility in order

00:50:57.530 --> 00:50:59.280
to get its data back and forth.

00:51:00.260 --> 00:51:05.000
So inside of your 64-bit tool,
in this case, right,

00:51:05.010 --> 00:51:06.800
you're going to be doing
things very simply.

00:51:06.800 --> 00:51:09.540
It's, as far as you know,
you're just getting things off the

00:51:09.580 --> 00:51:11.570
command line and sending them back.

00:51:11.620 --> 00:51:14.680
Right, so you're going to scan data
in off the command line,

00:51:14.680 --> 00:51:18.380
off the standard in,
and you're going to go ahead

00:51:18.380 --> 00:51:21.830
and print F data out and
send it out to standard out.

00:51:21.870 --> 00:51:25.780
Right, a very simple example,
but if something is hooked

00:51:25.780 --> 00:51:27.050
up on the other end,

00:51:27.330 --> 00:51:30.850
Like your GUI application,
it can catch it and display the results.

00:51:30.860 --> 00:51:36.950
So here's a set of code that
shows how to essentially get a

00:51:36.960 --> 00:51:40.360
tool launched in a very simple,
rudimentary way inside of

00:51:40.370 --> 00:51:42.570
a 32-bit GUI application.

00:51:42.580 --> 00:51:47.640
So you go ahead and you use the
CFBundle APIs to try and find the tool.

00:51:47.640 --> 00:51:50.730
So the tool will normally be
embedded inside your bundle,

00:51:50.730 --> 00:51:53.870
down inside the executable path.

00:51:54.750 --> 00:52:01.660
And so you can use the CFBundle copy
auxiliary executable URL.

00:52:01.900 --> 00:52:32.900
[Transcript missing]

00:52:33.180 --> 00:52:42.830
You can get the regular Unix
file representation from that,

00:52:43.280 --> 00:52:46.080
because those are URLs in
the file system code,

00:52:46.080 --> 00:52:49.290
and the BSD calls take
file system representation,

00:52:49.290 --> 00:52:51.040
not necessarily the full URL.

00:52:51.040 --> 00:52:52.680
So you have to extract that out.

00:52:52.730 --> 00:52:57.830
Then you can call the standard
POSIX BSD P-open call.

00:52:58.450 --> 00:53:03.420
P-open creates a pipe between
you and the executable

00:53:03.420 --> 00:53:05.360
identified by the path variable.

00:53:05.360 --> 00:53:08.660
So it's going to actually
launch that executable.

00:53:10.100 --> 00:53:14.180
That executable happens
to be your 64-bit tool,

00:53:14.180 --> 00:53:18.900
and it sets up a pipe
between you and that tool,

00:53:18.900 --> 00:53:21.040
and it returns that to
you in the GPipe file.

00:53:21.040 --> 00:53:25.630
So now you've got a pipe or a
socket between you and your child.

00:53:27.130 --> 00:53:32.030
And then you go ahead and need
to hook that up to the run loop,

00:53:32.030 --> 00:53:32.150
right?

00:53:32.170 --> 00:53:34.200
Because now you're in
this 32-bit application.

00:53:34.200 --> 00:53:35.640
You need to be able to do that.

00:53:38.060 --> 00:53:41.000
So here's real simple little code
to hook that up into a run loop.

00:53:41.000 --> 00:53:42.930
You use CF socket, right?

00:53:43.090 --> 00:53:46.640
You can create a
CF socket with that pipe.

00:53:46.640 --> 00:53:50.090
You have to pull a file descriptor
out of the pipe first and then call

00:53:50.100 --> 00:53:53.200
the CF socket create with native.

00:53:53.330 --> 00:53:56.660
But that'll go ahead and create
you a CF socket that you can then

00:53:56.790 --> 00:53:59.020
create a run loop source from.

00:53:59.090 --> 00:54:02.820
And then you can finally add that
run loop source to your run loop.

00:54:02.910 --> 00:54:05.950
So now in your run loop for
your 32-bit application,

00:54:05.950 --> 00:54:07.690
you have a pipe.

00:54:07.750 --> 00:54:14.040
That's connected from
the 64-bit backend tool.

00:54:14.060 --> 00:54:15.840
And so it can receive asynchronous data.

00:54:15.890 --> 00:54:19.010
So you can go ahead and continue to
receive mouse down events and all of

00:54:19.010 --> 00:54:20.700
those things inside of your 32-bit app.

00:54:20.940 --> 00:54:27.980
But you can also receive the events and
results back from your 64-bit backend.

00:54:28.600 --> 00:54:31.210
And to give a demonstration of that,
George Werner from

00:54:31.210 --> 00:54:35.390
Developer Tech Support is
going to show you an example.

00:54:46.700 --> 00:54:47.760
You guys have to bear with me.

00:54:47.760 --> 00:54:49.180
I was a last-minute replacement.

00:54:49.180 --> 00:54:51.350
Apparently,
they had Vanna White to do this,

00:54:51.350 --> 00:54:55.040
but she had a better agent than I did.

00:54:57.600 --> 00:55:02.430
So the first thing I want to do here is,
well, let's look at the target settings.

00:55:02.440 --> 00:55:06.550
I just want to show you
that this is indeed...

00:55:11.850 --> 00:55:13.340
There's our architecture right there.

00:55:13.360 --> 00:55:19.920
PPC 64, we're all on the same page.

00:55:22.200 --> 00:55:24.640
We want to go ahead and
open the source to this.

00:55:24.640 --> 00:55:29.760
And I think I got set up for this,
because they advised me to

00:55:29.760 --> 00:55:31.860
use printfs for debugging.

00:55:34.600 --> 00:56:46.700
[Transcript missing]

00:56:55.720 --> 00:56:58.220
This is the first one.

00:56:58.220 --> 00:57:02.290
This is our pointer here.

00:57:06.100 --> 00:57:08.440
Step over.

00:57:08.490 --> 00:57:12.540
There's a nice 64-bit number.

00:57:12.560 --> 00:57:16.720
We'll view it as hexadecimal,
we'll view it as decimal.

00:57:17.440 --> 00:57:22.710
You can see that it's about 4 gig.

00:57:23.570 --> 00:57:26.900
We can step over.

00:57:26.940 --> 00:57:29.700
We just blocked on the scan F.

00:57:30.720 --> 00:57:33.950
Go to our standard I/O log.

00:57:33.950 --> 00:57:34.540
Terrible font.

00:57:34.540 --> 00:57:35.100
You won't be able to read it.

00:57:35.100 --> 00:57:37.200
Hopefully you can trust me.

00:57:37.200 --> 00:57:39.460
I'll type in what I say.

00:57:42.170 --> 00:57:45.060
It's a nine-digit hexadecimal number,
so it's a little bit bigger

00:57:45.060 --> 00:57:46.700
than a 32-bit number.

00:57:46.700 --> 00:57:49.200
It won't fit in a 32-bit number.

00:57:49.460 --> 00:57:51.210
And there's our count there.

00:57:51.310 --> 00:57:51.940
Got returned.

00:57:51.940 --> 00:57:54.100
We'll go over to hex decimal to see.

00:57:54.100 --> 00:57:57.590
There's 1, 2, 3, 4, 5, 6, 7, 8, 9 digits.

00:57:58.790 --> 00:58:03.190
Okay, step over, print F, our output.

00:58:03.200 --> 00:58:04.680
We'll switch over to our output window.

00:58:04.750 --> 00:58:07.080
You probably can't read that, but...

00:58:10.800 --> 00:58:11.780
We're at Malloch Barrie.

00:58:11.800 --> 00:58:13.190
Second one, here is this one.

00:58:13.200 --> 00:58:15.440
Now this one was close to our 4 gig.

00:58:15.580 --> 00:58:17.300
This one is up around 8 gig.

00:58:17.300 --> 00:58:21.800
I'll show it in decimal
just to make sure.

00:58:21.800 --> 00:58:21.800
It's around 8 gig.

00:58:22.760 --> 00:58:27.070
"So it's doing a 64-bit number there,
64-bit pointer.

00:58:27.070 --> 00:58:32.230
Step over, it's going to flush it out,
it'll loop back around.

00:58:33.800 --> 00:58:38.850
and this time we'll enter zero.

00:58:40.380 --> 00:58:43.700
This time our program will terminate.

00:58:43.760 --> 00:58:45.090
And that's pretty much our backend tool.

00:58:45.100 --> 00:58:48.680
That's for demo purposes.

00:58:48.750 --> 00:58:50.630
Here, Vanna's code was a lot
prettier than mine,

00:58:50.660 --> 00:58:50.970
too.

00:58:50.980 --> 00:58:55.390
OK.

00:58:58.930 --> 00:59:04.300
Okay, we're going to switch our
target over to our GUI.

00:59:04.410 --> 00:59:05.300
This is the source code.

00:59:05.300 --> 00:59:09.590
Now, I pretty much wrote the minimum
Carbon app that I could get away with.

00:59:09.700 --> 00:59:11.720
It's nib-based.

00:59:11.940 --> 00:59:15.800
We're going to load from the Nib,
load the Nib, set a menu bar from Nib,

00:59:15.800 --> 00:59:18.800
create a window from Nib,
standard Carbon type stuff.

00:59:18.800 --> 00:59:21.800
We're going to install an event handler.

00:59:21.800 --> 00:59:24.300
We have a little button in our
window that we hit OK and the command

00:59:24.300 --> 00:59:26.730
process is our event handler for that.

00:59:26.730 --> 00:59:29.910
I'll show you that code when I debug it.

00:59:30.460 --> 00:59:32.570
That's the same code that you saw him.

00:59:32.670 --> 00:59:34.400
It gets the auxiliary executable.

00:59:34.400 --> 00:59:38.710
Our tool is Tool 64.

00:59:39.800 --> 00:59:40.800
Okay.

00:59:40.800 --> 00:59:46.560
And file system, there's the P open and
when I first demoed this,

00:59:46.560 --> 00:59:51.800
I had three Unix guys reviewing this,
reviewing my presentation that fainted.

00:59:52.030 --> 00:59:55.560
Apparently P open isn't
the API of choice here.

00:59:55.590 --> 00:59:58.540
There's security holes
involved with using P open.

00:59:58.540 --> 01:00:03.030
I didn't have time to rewrite it,
but they told me the correct answer

01:00:03.120 --> 01:00:05.500
is fork exec and to duplier pipes.

01:00:05.500 --> 01:00:08.180
If you know what that means,
then you're ahead of me, so.

01:00:09.800 --> 01:00:11.790
Okay.

01:00:12.450 --> 01:00:15.730
He kind of brushed over the install code.

01:00:15.740 --> 01:00:18.600
I showed the install code,
but I'll show the socket call when

01:00:18.620 --> 01:00:21.280
we actually get down to running it.

01:00:21.330 --> 01:00:22.900
And then run application event loop.

01:00:22.900 --> 01:00:25.900
So it's minimal Carbon app.

01:00:26.230 --> 01:00:31.560
This is the command for
the button in our window.

01:00:31.630 --> 01:00:33.520
I'm going to set a breakpoint on it.

01:00:36.600 --> 01:00:37.900
This is the callback code.

01:00:37.900 --> 01:00:40.940
I think he stepped through it.

01:00:41.010 --> 01:00:44.720
His was cleaned up a
little nicer than mine.

01:00:44.800 --> 01:00:46.940
Okay, pretty straightforward stuff.

01:00:46.940 --> 01:00:48.020
And this is the callback.

01:00:48.090 --> 01:00:50.090
This is what will get
called when I receive a

01:00:50.100 --> 01:00:52.070
communication from the backend.

01:00:52.070 --> 01:00:54.710
And we'll set a breakpoint here.

01:00:54.710 --> 01:00:55.700
Okay.

01:00:55.700 --> 01:00:58.640
So the other thing,
other mistake I made in my demo

01:00:58.640 --> 01:01:03.290
originally was I demoed it in
GDB and the very first question

01:01:03.290 --> 01:01:08.040
I got was what you can't,
you can't debug in Xcode in

01:01:08.040 --> 01:01:13.240
64 and so I had to change my
presentation to appease that crowd

01:01:13.240 --> 01:01:16.770
but what I'm going to do now.

01:01:17.530 --> 01:01:21.610
This is my build directory
where the project is.

01:01:21.620 --> 01:01:25.400
There's the GUI app,
there's the 64-bit tool.

01:01:25.400 --> 01:01:29.490
I'm actually going to
go down into the tool.

01:01:34.120 --> 01:01:35.870
And there's the actual
executables for those.

01:01:35.870 --> 01:01:38.180
I can run GDB.

01:01:38.180 --> 01:01:40.150
I don't need to go there yet.

01:01:40.160 --> 01:01:42.390
If I do a PS...

01:01:48.880 --> 01:01:55.320
Just to make sure it's not running yet,
switch back over to Xcode.

01:02:00.060 --> 01:02:00.840
There's our P open.

01:02:00.840 --> 01:02:05.000
I want to set a breakpoint there.

01:02:05.050 --> 01:02:07.930
And now let's go and debug.

01:02:12.600 --> 01:02:15.220
Okay, so there's our P open.

01:02:15.220 --> 01:02:16.600
Let's switch back over to GDB.

01:02:16.600 --> 01:02:19.030
We'll do that grep for the, for running.

01:02:19.040 --> 01:02:21.190
Now you can see the application running.

01:02:21.220 --> 01:02:23.600
That's this one here.

01:02:23.750 --> 01:02:24.600
Nothing else.

01:02:24.600 --> 01:02:27.830
We step over.

01:02:29.680 --> 01:02:31.000
Do it again.

01:02:31.030 --> 01:02:36.300
Now we have both the GUI application
running and the 64-bit tool.

01:02:36.310 --> 01:02:38.100
All right.

01:02:38.260 --> 01:02:39.860
Still that PID.

01:02:40.020 --> 01:02:42.520
I can GDB.

01:02:44.300 --> 01:02:48.380
There's our source code.

01:02:48.380 --> 01:02:49.780
There's the same thing we've seen there.

01:02:49.780 --> 01:02:56.450
I'm going to set a breakpoint
here on the malloc.

01:02:59.500 --> 01:03:07.100
[Transcript missing]

01:03:08.120 --> 01:03:10.100
This is our first callback.

01:03:10.100 --> 01:03:14.920
He printed that printf at the
beginning of the source of the tool.

01:03:15.000 --> 01:03:17.480
This is catching his output coming back.

01:03:17.680 --> 01:03:22.240
All this code is going to do is
take the data that's returned.

01:03:22.750 --> 01:03:25.630
Get the length of it,
malloc a little buffer for it,

01:03:25.630 --> 01:03:28.170
pull the bytes out of it,
null terminate it.

01:03:28.170 --> 01:03:29.400
It's basically the printf string.

01:03:29.400 --> 01:03:34.470
You actually see part of it right there.

01:03:34.800 --> 01:03:38.270
We're going to get our HIV,
which is our Carbon window,

01:03:38.270 --> 01:03:40.600
pull out its existing text.

01:03:40.690 --> 01:03:45.320
We're going to pin the new text to that
text and then set it back into the view.

01:03:45.820 --> 01:03:49.600
Release our string,
free our memory buffers, and return.

01:03:49.680 --> 01:03:52.580
Before I return,
I'll clear that breakpoint.

01:03:56.300 --> 01:03:58.230
Let's switch over to our app.

01:03:58.430 --> 01:03:59.710
Here's my little app.

01:03:59.780 --> 01:04:02.400
It's just a little window created in Nib.

01:04:02.400 --> 01:04:06.190
We have a little text entry box
where you can type a number in,

01:04:06.190 --> 01:04:10.950
an OK button, and then this captured the
output coming back from the tool.

01:04:10.970 --> 01:04:15.720
It's the hello world, size of void,
star is 8, and please enter a size.

01:04:15.750 --> 01:04:17.290
That was our prompt.

01:04:18.280 --> 01:04:20.230
We hit our OK button.

01:04:20.280 --> 01:04:23.420
This is the handler for the OK button.

01:04:23.420 --> 01:04:28.740
What this code does,
it finds our HI view.

01:04:31.490 --> 01:04:36.720
It creates an empty
string and sets the H.I.

01:04:36.720 --> 01:04:37.180
view.

01:04:37.300 --> 01:04:39.490
I just kind of stepped
a little fast there.

01:04:39.590 --> 01:04:40.100
Set the text.

01:04:40.100 --> 01:04:43.110
That cleared the box on the view.

01:04:43.880 --> 01:04:47.210
Now we're down to the, we find the,
this is the text,

01:04:47.280 --> 01:04:50.680
the edit text control that
we type the number into.

01:04:50.770 --> 01:04:53.010
We get its text out.

01:04:53.660 --> 01:04:59.840
And then we write it to
the pipe to the child.

01:04:59.840 --> 01:05:03.320
And I'm going to squeeze this up a
little bit here so we can see it.

01:05:10.200 --> 01:05:13.820
There we do the write,
and as soon as I do the flush, boom,

01:05:13.870 --> 01:05:15.780
GDB just broke over here.

01:05:15.930 --> 01:05:18.900
He received it from the front-end tool.

01:05:18.930 --> 01:05:21.840
We can do a back trace.

01:05:21.840 --> 01:05:24.560
We can look at the count.

01:05:30.800 --> 01:05:32.920
There's what-- so we got the
message from the front end.

01:05:32.920 --> 01:05:33.600
We parsed it.

01:05:33.600 --> 01:05:36.000
It's put it into the account.

01:05:36.000 --> 01:05:39.380
When we step over-- oops, sorry, not GD.

01:05:39.380 --> 01:05:41.420
This is not Max Bug.

01:05:43.240 --> 01:05:45.440
Flashback.

01:05:45.440 --> 01:05:46.200
OK.

01:05:46.750 --> 01:05:51.000
Now we step over and look at--

01:05:51.670 --> 01:05:58.750
PTR1 And there's a nice 1, 2, 3, 4, 5, 6,
7, 8, 9 digit number.

01:05:58.960 --> 01:06:01.600
Pretty confident that
won't fit into 32 bits.

01:06:01.750 --> 01:06:04.550
So there that is.

01:06:04.600 --> 01:06:05.970
Oops.

01:06:06.140 --> 01:06:07.590
Did it again.

01:06:10.510 --> 01:06:12.000
And back around to our prompt.

01:06:12.000 --> 01:06:14.000
I'm going to delete our breakpoints.

01:06:14.000 --> 01:06:18.910
And just while we're here,

01:06:19.240 --> 01:06:20.600
Dump out a bunch of registers here.

01:06:20.600 --> 01:06:27.100
You can see here's the,
that's definitely a 64-bit number there.

01:06:27.150 --> 01:06:28.800
A couple more back up there.

01:06:28.950 --> 01:06:33.400
There's a stack pointer there.

01:06:34.210 --> 01:06:36.420
Backtrace.

01:06:36.420 --> 01:06:37.920
Interesting, argv is on the stack.

01:06:37.920 --> 01:06:39.160
You can tell that.

01:06:39.170 --> 01:06:42.270
So let's continue.

01:06:57.400 --> 01:07:01.700
I'm going to clear my
breakpoint on that one.

01:07:01.700 --> 01:07:03.730
And we'll continue and switch
over to the application.

01:07:03.890 --> 01:07:07.110
And so, now you can see it printing
out the value here,

01:07:07.180 --> 01:07:11.920
and every time I hit it,
it jumps up about 4 gig.

01:07:13.200 --> 01:07:23.500
[Transcript missing]

01:07:23.900 --> 01:07:41.800
[Transcript missing]

01:07:45.590 --> 01:07:49.340
Okay,
and that's pretty much the demo there.

01:07:49.400 --> 01:07:51.340
Okay.

01:07:51.560 --> 01:07:53.370
So...

01:07:54.500 --> 01:08:00.250
Our next speaker is Rob Regge-Scofield.

01:08:00.250 --> 01:08:00.250
I hope I got his name from Mathematica.

01:08:06.080 --> 01:08:08.130
Hi.

01:08:08.230 --> 01:08:11.880
Starting later this month,
we are going to ship Mathematica 5.2,

01:08:11.880 --> 01:08:16.840
which has been 64-bit optimized to
run on G5 systems running Tiger.

01:08:16.840 --> 01:08:19.360
And the way we did this, surprise,
surprise,

01:08:19.360 --> 01:08:23.770
is using the exact techniques that have
been described so far in this session.

01:08:23.780 --> 01:08:28.570
We have a 32-bit GUI front-end
process that talks to a 64-bit

01:08:28.890 --> 01:08:33.480
computation engine using some
of the IPC mechanisms mentioned.

01:08:35.090 --> 01:08:38.110
It uses shared memory, pipes, TCP,
whatever is most appropriate

01:08:38.160 --> 01:08:39.160
for the situation.

01:08:39.160 --> 01:08:42.580
And our GUI front-end even
uses CF socket to integrate the

01:08:42.580 --> 01:08:46.100
communication into the run loop,
so we can do that efficiently.

01:08:47.450 --> 01:08:52.220
So, there's two big benefits to
having a 64-bit version of

01:08:52.490 --> 01:08:57.500
Mathematica for our users,
in that certain mathematical

01:08:57.570 --> 01:08:59.000
operations are faster.

01:08:59.000 --> 01:09:01.650
Arbitrary precision math
is one example of that.

01:09:01.700 --> 01:09:05.860
And I don't know,
was there supposed to be a slide of that,

01:09:05.860 --> 01:09:06.910
or...

01:09:13.100 --> 01:09:18.540
This is the slide from the science
talk yesterday talking about some

01:09:18.540 --> 01:09:21.570
of the Mac OS X technologies,
and this is what I was looking for.

01:09:21.670 --> 01:09:26.180
So this is an example calculating
the first million digits of pi.

01:09:26.180 --> 01:09:30.900
In the same computation running on
a 64-bit version of Mathematica,

01:09:30.900 --> 01:09:34.620
it takes just a little over
five seconds to complete,

01:09:34.620 --> 01:09:37.580
four and a half seconds maybe.

01:09:37.580 --> 01:09:40.430
Doing the same thing in a
32-bit version of Mathematica

01:09:40.430 --> 01:09:42.830
takes about seven and a half,
eight seconds.

01:09:43.460 --> 01:09:46.780
So it's just,
it's almost twice as fast for

01:09:46.790 --> 01:09:48.940
that particular type of operation.

01:09:48.940 --> 01:09:53.620
And the other big benefit is
addressing large amounts of memory.

01:09:53.620 --> 01:09:56.220
So can we cut to demo machine two here?

01:09:56.220 --> 01:10:02.020
And I have some,
a pre-rendered simulation here,

01:10:02.020 --> 01:10:07.230
which unfortunately takes a few hours,
so I can't do it in real time.

01:10:09.850 --> 01:10:13.960
What this is showing is going to
highlight the differences between the

01:10:13.960 --> 01:10:16.800
32-bit process and the 64-bit process.

01:10:16.950 --> 01:10:19.800
This one right here was
done on a 32-bit system.

01:10:19.800 --> 01:10:21.800
It's a simulation of a tsunami.

01:10:21.900 --> 01:10:28.460
The wave that's starting in the middle
of the sea here is going to be affected

01:10:28.570 --> 01:10:30.800
by the mountains on the sea floor.

01:10:30.800 --> 01:10:33.260
That's going to cause
disturbances all the way back

01:10:33.270 --> 01:10:34.800
up to the surface of the sea.

01:10:34.830 --> 01:10:39.800
If we just run this,
we see how the simulation plays out.

01:10:39.800 --> 01:10:42.810
What we did on this 32-bit system
is that we had to decrease the

01:10:42.810 --> 01:10:47.310
resolution of this simulation so
that the amount of memory required

01:10:47.680 --> 01:10:50.800
would be less than the 4 GB maximum.

01:10:50.800 --> 01:10:53.770
As you can see,
due to the lower resolution,

01:10:53.820 --> 01:10:59.630
there's actually artifacts that
appear that really aren't there.

01:10:59.980 --> 01:11:06.790
Certain variations in the results at
that point are being... exaggerated

01:11:06.800 --> 01:11:07.760
just because of the lower resolution.

01:11:07.800 --> 01:11:11.940
If we do the exact same
simulation on a 64-bit system,

01:11:11.940 --> 01:11:13.800
we can increase the resolution.

01:11:13.800 --> 01:11:16.800
This was done using about 6 GB of memory.

01:11:16.800 --> 01:11:22.800
You see the simulation looks about the
same except we don't see the artifacts

01:11:22.800 --> 01:11:25.640
that we got in the 32-bit case.

01:11:25.860 --> 01:11:32.780
The 64-bit support for computations
involving large amounts of memory

01:11:32.830 --> 01:11:34.800
is a big win for customers who
are using the 64-bit system.

01:11:34.800 --> 01:11:44.770
That's all I have.

01:11:56.320 --> 01:11:56.990
Thank you very much.

01:11:57.060 --> 01:11:58.440
My name is Matthew Formica.

01:11:58.440 --> 01:12:02.040
I'm the 64-bit software
evangelist in developer relations.

01:12:02.040 --> 01:12:06.200
For more information,
you can go to the WWC portal.

01:12:06.200 --> 01:12:10.090
There's a lot of great documentation
associated with this session.

01:12:10.090 --> 01:12:13.180
Sample code available or coming soon.

01:12:13.910 --> 01:12:16.060
There are a few upcoming sessions.

01:12:16.060 --> 01:12:20.330
The most important thing is the lab
that is coming up actually right after

01:12:20.330 --> 01:12:23.320
this session in the performance and
tools lab down on the second floor.

01:12:23.320 --> 01:12:26.850
We don't have time for Q&A here,
but you can get all your questions

01:12:26.850 --> 01:12:28.840
answered from the team in that lab.

01:12:28.850 --> 01:12:31.630
They'll walk there right
after this session.

01:12:33.750 --> 01:12:36.990
You can contact me, send me an email.

01:12:37.030 --> 01:12:40.290
As I said, we don't have time for Q&A,
but you can meet us in the labs.

01:12:40.390 --> 01:12:41.300
So thank you very much.
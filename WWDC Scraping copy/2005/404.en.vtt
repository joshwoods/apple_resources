WEBVTT

00:00:05.450 --> 00:00:06.900
Good afternoon.

00:00:06.950 --> 00:00:12.090
So, I'm Geoffrey Keating,
and this talk is Moving to gcc 4.0,

00:00:12.130 --> 00:00:15.190
talk 404, session not found.

00:00:22.330 --> 00:00:25.200
So we have a new compiler.

00:00:25.200 --> 00:00:27.480
You've probably already noticed.

00:00:27.730 --> 00:00:32.780
gcc 4.0 shipped with TigerGM,
and you have a slightly newer

00:00:33.280 --> 00:00:38.490
version on the DVDs that were
handed out to you earlier.

00:00:39.400 --> 00:00:43.780
So I'm going to talk
a bit about it today.

00:00:43.780 --> 00:00:45.880
So I'm going to cover three basic topics.

00:00:45.940 --> 00:00:49.440
First, why should you move to 4.0?

00:00:49.620 --> 00:00:54.170
What new features or speed
improvements or bug fixes are in 4.0

00:00:54.350 --> 00:00:56.700
that might make you want to move?

00:00:56.740 --> 00:01:03.340
And of course, what new features might
cause you to need to move,

00:01:03.670 --> 00:01:05.310
even if you're not particularly
enthusiastic about it?

00:01:05.690 --> 00:01:08.760
We're also going to talk about
some of the consequences of all of

00:01:08.760 --> 00:01:10.600
the improvements that we've made.

00:01:10.600 --> 00:01:14.000
Some of the new features are things
that really might affect you,

00:01:14.000 --> 00:01:17.790
things that you might want to use,
or things that maybe now you can

00:01:17.790 --> 00:01:22.430
take away some of the workarounds
that you've been using before.

00:01:22.600 --> 00:01:24.600
I'm also going to talk about bug fixes.

00:01:24.600 --> 00:01:26.510
We have a lot of bug fixes in gcc 4.0.

00:01:26.620 --> 00:01:29.460
It's a really incredibly stable compiler.

00:01:29.600 --> 00:01:34.420
But some of the bug fixes are things
where the compiler was improperly

00:01:34.430 --> 00:01:38.600
accepting code that really it
shouldn't have ever been accepting.

00:01:38.600 --> 00:01:42.660
And so I'm going to go through a
bunch of those and show you how to

00:01:42.660 --> 00:01:47.450
fix your code if you've accidentally
been using some of these cases.

00:01:48.940 --> 00:01:53.240
The -- probably the most important
reason why you might want to move

00:01:53.240 --> 00:01:57.560
to gcc 4.0 is because it is the
only supported compiler for building

00:01:57.560 --> 00:02:00.140
Intel applications at present.

00:02:00.140 --> 00:02:04.040
There are going to be other
compilers from third-party vendors,

00:02:04.510 --> 00:02:07.100
but this is Apple's compiler.

00:02:10.290 --> 00:02:15.040
Another reason why you might need to
move to 4.0 is because it's required

00:02:15.040 --> 00:02:17.390
for building 64-bit executables.

00:02:17.400 --> 00:02:23.380
So Intel or 64-bit, if you need it,
you have to use 4.0.

00:02:28.470 --> 00:02:32.690
A reason that you might want to
move to 4.0 is because it's faster.

00:02:32.790 --> 00:02:37.230
Gcc 4.0 is a noticeably
quicker compiler than gcc 3.3.

00:02:37.230 --> 00:02:40.320
We've been continuing our
program of speed improvements.

00:02:40.320 --> 00:02:44.330
You can see from the graphs there,
it's between 15% faster and

00:02:44.330 --> 00:02:48.230
about 5%, depending on what
kind of code you're using.

00:02:48.230 --> 00:02:50.200
So these are significant improvements.

00:02:50.200 --> 00:02:52.360
It's 15% is big enough to be noticeable.

00:02:52.360 --> 00:02:55.920
So if you move to 4.0,
your productivity will improve a bit

00:02:56.110 --> 00:02:58.040
because of the faster turnaround times.

00:02:58.050 --> 00:03:01.760
And so that in itself is, you know,
a reason to consider moving.

00:03:02.880 --> 00:03:06.690
Gcc 4.0 also has slightly
better code generation.

00:03:06.740 --> 00:03:11.560
We've completely rewritten
many of the optimizers.

00:03:11.560 --> 00:03:16.610
In Xcode 2.0, shipped with Tiger,
it was about the same speed as 3.3,

00:03:17.110 --> 00:03:17.560
right?

00:03:17.700 --> 00:03:24.020
And we've been continuing to improve it,
and now it's slightly faster on a random

00:03:24.090 --> 00:03:26.990
industry standard benchmark that just
happens to come in floating flavors.

00:03:29.760 --> 00:03:34.180
Another big feature with 4.0
is the shared C++ runtime.

00:03:34.310 --> 00:03:40.770
It's available in Panther 10.3.9 with the
software update and in Tiger and later.

00:03:41.040 --> 00:03:43.430
The big benefit of the shared
C++ runtime is a significant

00:03:43.440 --> 00:03:48.720
reduction in application size,
between 200K and a megabyte or so.

00:03:48.800 --> 00:03:53.180
This gives you faster app loading and
faster switching between applications,

00:03:53.290 --> 00:03:59.300
which is a significant improvement to the
user responsibility of your application.

00:03:59.300 --> 00:04:02.200
It also, because there's now a
single dynamic library,

00:04:02.200 --> 00:04:05.740
it means we can occasionally fix bugs
in your operating system releases

00:04:05.940 --> 00:04:09.200
and automatically transfer those
improvements to your application.

00:04:09.200 --> 00:04:11.720
And it also means we could do some
things which were only possible

00:04:11.720 --> 00:04:16.200
when you had a single bunch of
code managing the C++ runtime.

00:04:16.200 --> 00:04:18.900
In particular,
we've improved correctness with streams.

00:04:18.900 --> 00:04:22.990
So now output from multiple dynamic
libraries in your application

00:04:23.020 --> 00:04:24.960
gets interleaved properly.

00:04:26.240 --> 00:04:29.830
So I said that was available
only on 10.3.9 and later.

00:04:30.040 --> 00:04:35.700
So let's talk about what gcc 4.0
will actually build code for.

00:04:35.700 --> 00:04:41.420
You can see there the big target of gcc
4.0 is that you can use gcc 4.0 with the

00:04:41.420 --> 00:04:44.960
universal SDK to build Intel binaries.

00:04:44.960 --> 00:04:50.620
gcc 4.0 also supports 10.4 and 10.3.9,
either using the Mac OS X deployment

00:04:50.680 --> 00:04:54.620
target method or using the SDKs.

00:04:54.840 --> 00:05:02.140
And it also goes back to 10-- well,
in theory to 10.0 for C and Objective-C.

00:05:02.140 --> 00:05:04.830
Once you go back to Jaguar,
there's a few bugs that need

00:05:04.840 --> 00:05:06.780
workarounds and that kind of thing.

00:05:07.120 --> 00:05:12.130
We don't have C++ support for
gcc 4.0 on early versions of

00:05:12.320 --> 00:05:14.450
Panther on Jaguar on Puma.

00:05:14.960 --> 00:05:17.720
You can compare this to the
other columns in the table,

00:05:17.720 --> 00:05:21.260
and you see that 3.3 doesn't
support Intel binaries,

00:05:21.260 --> 00:05:25.440
and previous versions of the
compiler are no longer really

00:05:25.440 --> 00:05:27.880
supported for using the new SDKs.

00:05:27.880 --> 00:05:30.940
They still continue to work
fine when using SDKs for old

00:05:30.940 --> 00:05:33.070
versions of the operating system.

00:05:37.080 --> 00:05:43.160
So another consequence of the switch over
to the Dynamics C++ standard library is

00:05:43.160 --> 00:05:47.670
that you might notice when the first time
you try to build your app with 4.0 is

00:05:47.670 --> 00:05:53.420
that a lot of the old templates used to
include libs to C++.a directly as part of

00:05:53.420 --> 00:05:56.900
the list of Xcode libraries to link in.

00:05:56.960 --> 00:06:00.500
This is no longer necessary and, in fact,
no longer possible because a .a

00:06:00.560 --> 00:06:02.210
file is not a shared library.

00:06:02.520 --> 00:06:05.010
So you'll see it comes
up in Xcode as red,

00:06:05.090 --> 00:06:07.820
meaning the file is no longer there,
and so what you should

00:06:07.840 --> 00:06:08.780
simply do is just delete it.

00:06:08.910 --> 00:06:10.780
You don't need it anymore.

00:06:10.780 --> 00:06:13.310
The compiler will automatically
link in the C++ standard

00:06:13.310 --> 00:06:16.210
library when you link C++ code.

00:06:20.960 --> 00:06:25.320
Another big feature in gcc
4.0 is 128-bit long double.

00:06:25.410 --> 00:06:28.950
It gives you 53 extra bits of precision
compared to the regular double

00:06:28.950 --> 00:06:30.900
precision floating point values.

00:06:30.900 --> 00:06:34.900
This is going to be part of the
permanent API on PowerPC Mac OS,

00:06:34.930 --> 00:06:38.900
and the support functions are
available in 10.3.9 and later.

00:06:38.990 --> 00:06:42.900
Compilers before gcc 4.0 warned
on every use of long double,

00:06:42.900 --> 00:06:45.030
so long as you didn't
switch the warning off,

00:06:45.030 --> 00:06:47.900
you shouldn't have any
instances of that in your code.

00:06:47.960 --> 00:06:50.900
So the switchover will be
relatively transparent to you.

00:06:50.900 --> 00:06:54.890
Unfortunately, this is not the same as
the Intel long double,

00:06:54.900 --> 00:06:59.020
which, although it's 128 bits
on a Macintosh platform,

00:06:59.020 --> 00:07:01.990
is only really an 80-bit
floating point value inside,

00:07:01.990 --> 00:07:03.890
and a completely
different internal format.

00:07:03.900 --> 00:07:08.160
So you can't just copy
structures and such between the

00:07:08.160 --> 00:07:10.880
two systems and have them work.

00:07:13.400 --> 00:07:17.200
Another of the big improvements
in GCC 4.0 is better CPU support.

00:07:17.200 --> 00:07:21.660
We have automatic vectorization starting
to become useful for real applications.

00:07:21.660 --> 00:07:28.240
We have vectorized inline memory
operations like memset and memcopy

00:07:28.260 --> 00:07:31.440
so that when you switch on,
so that if you allow the compiler

00:07:31.510 --> 00:07:34.540
to use vector instructions,
it'll automatically use vectorized

00:07:34.630 --> 00:07:37.740
versions of these when it inlines
so you don't have to go back to

00:07:37.740 --> 00:07:39.130
scalar code for the inline versions.

00:07:39.880 --> 00:07:43.440
Obviously, if you use the out-of-line
copies in the system,

00:07:43.440 --> 00:07:46.200
that'll work just fine,
and that'll be vectorized just

00:07:46.310 --> 00:07:48.710
fine anyway because the system
will have the latest versions.

00:07:50.920 --> 00:07:58.710
In Xcode 2.0 in Panther,
we added a nice UI so that you can create

00:07:58.780 --> 00:08:01.560
universal executables for each processor.

00:08:01.670 --> 00:08:04.930
So in previous talks,
you'll have heard about how you can

00:08:04.930 --> 00:08:10.950
create a universal executable that
has both PowerPC and Intel code on it.

00:08:11.240 --> 00:08:14.700
You don't have to just stop
at one flavor of PowerPC.

00:08:14.780 --> 00:08:18.590
You can have 64-bit PowerPC,
you can have PowerPC that's

00:08:18.590 --> 00:08:22.850
32-bit and tuned for g3,
g4, or g5, and you can have Intel code

00:08:23.000 --> 00:08:24.340
all in the same binary.

00:08:24.440 --> 00:08:28.590
So that would give you what we
call a five-way universal binary.

00:08:28.780 --> 00:08:31.080
That might be going a little bit too far,
unless you have a really

00:08:31.080 --> 00:08:34.710
performance-critical application
where it really matters that

00:08:34.710 --> 00:08:37.080
g5 and g4 are different.

00:08:38.290 --> 00:08:44.960
You can access this support in Xcode
2.0 by finding the architecture

00:08:44.960 --> 00:08:48.200
build setting and double-clicking
on it or clicking on edit.

00:08:48.300 --> 00:08:51.200
And that pops up this dialog box,
which is not to scale.

00:08:51.240 --> 00:08:54.200
And so you can simply pick
what architectures you want.

00:08:54.520 --> 00:08:59.380
Unfortunately, in Xcode 2.1,
this support was simplified to make

00:08:59.380 --> 00:09:02.190
it easier to find the Intel settings.

00:09:02.200 --> 00:09:06.280
So in Xcode 2.1,
the dialog box only offers PowerPC,

00:09:06.280 --> 00:09:10.060
which is 32-bit G3, and Intel support.

00:09:10.200 --> 00:09:16.200
But you can still hit enter on the
field and add the other targets by hand.

00:09:16.200 --> 00:09:19.640
So for instance,
you can add PPC64 to build your

00:09:19.760 --> 00:09:22.200
program as a 64-bit executable.

00:09:22.200 --> 00:09:24.180
And you can add a range of other targets.

00:09:24.190 --> 00:09:29.200
You can add PPC970, meaning a G5,
and so on.

00:09:29.200 --> 00:09:31.200
And so you can simply add
all five settings in there.

00:09:31.200 --> 00:09:34.620
And Xcode will automatically
build your executable and tune

00:09:34.920 --> 00:09:37.200
it for each target individually.

00:09:37.230 --> 00:09:40.100
This lets you use
autovectorization most efficiently.

00:09:40.240 --> 00:09:43.790
With autovectorization,
the compiler really needs to be

00:09:43.850 --> 00:09:46.200
told that it's allowed to use
all of the vector instructions.

00:09:46.210 --> 00:09:48.200
Otherwise,
it can't autovectorize anything.

00:09:50.530 --> 00:09:57.860
So what we recommend is that you do
try to tell the compiler that the

00:09:57.860 --> 00:10:01.610
whole object file is only going to run
on a g4 or only going to run on a g5,

00:10:01.620 --> 00:10:04.560
if that's what the case actually is.

00:10:04.560 --> 00:10:08.600
So if you have an object file
that contains all of your AlteVec

00:10:08.810 --> 00:10:12.980
code and then the rest of your app
calls into that but only on a g4,

00:10:12.980 --> 00:10:18.390
then tell the compiler that this file can
run -- that it's allowed to use AlteVec

00:10:18.400 --> 00:10:21.470
instructions throughout that file.

00:10:22.610 --> 00:10:26.060
We would prefer that you try not to
switch on the Altevec intrinsics for

00:10:26.140 --> 00:10:28.500
files that are supposed to run on a g3.

00:10:28.500 --> 00:10:31.190
To do this,
the compiler assumes that some

00:10:31.190 --> 00:10:34.500
of the code is obviously Altevec
and therefore has to run on a g4,

00:10:34.500 --> 00:10:37.270
and then some of the code is not
Altevec and therefore it mustn't

00:10:37.270 --> 00:10:40.180
have any Altevec instructions in
it because it's running on a g3.

00:10:40.470 --> 00:10:43.480
And so the compiler has to disable
some optimizations to do that.

00:10:43.670 --> 00:10:47.910
So it's better to try and separate
your code so you have Altevec

00:10:47.910 --> 00:10:52.500
in one file and not Altevec or
can run on a g3 in other files.

00:10:53.450 --> 00:10:56.440
Another big advantage of this compiler
is we have new and better warnings.

00:10:56.480 --> 00:10:57.340
Lots of them.

00:10:57.410 --> 00:10:59.660
Lots and lots of them.

00:11:00.040 --> 00:11:03.100
So we know there's a lot,
but please read them.

00:11:03.550 --> 00:11:07.150
A lot of these warnings really are trying
to point out problems in your code.

00:11:07.290 --> 00:11:11.660
So you should look at them and you
should try and fix them if possible.

00:11:11.660 --> 00:11:13.640
Because there are so many new warnings,
you may not be able to

00:11:13.640 --> 00:11:15.180
fix them all right away.

00:11:15.180 --> 00:11:17.900
So if you have a W error,
warnings as errors,

00:11:17.910 --> 00:11:21.620
in your build settings,
you might want to consider

00:11:22.050 --> 00:11:28.280
temporarily removing it to get
your program going with gcc 4.0.

00:11:28.280 --> 00:11:30.700
We have a new warning for
Objective C that warns about

00:11:30.940 --> 00:11:33.010
strict selector matching.

00:11:33.180 --> 00:11:36.460
If at all possible,
you should switch this on.

00:11:36.630 --> 00:11:40.480
It catches a bunch of real bugs,
and we're particularly highlighting it

00:11:40.480 --> 00:11:44.820
because a lot of the bugs are otherwise
difficult to find in your program.

00:11:44.820 --> 00:11:47.080
You should also watch
for warnings that say,

00:11:47.080 --> 00:11:50.670
if this code is reached,
the program will abort.

00:11:50.840 --> 00:11:54.060
It means that your program really
will abort when it reaches that code.

00:11:54.130 --> 00:11:57.630
So what you need to do is either
remove the warning or check to see

00:11:57.680 --> 00:11:59.950
that the code is never executed.

00:12:01.280 --> 00:12:03.900
While you're looking
at your build settings,

00:12:03.900 --> 00:12:07.160
there are some really old flags
that no longer do anything.

00:12:07.270 --> 00:12:10.200
So you might want to
consider removing them.

00:12:10.200 --> 00:12:12.020
For instance, wno-precomp.

00:12:12.380 --> 00:12:16.320
We haven't had precomp support
in the compiler since gcc 3.1,

00:12:16.410 --> 00:12:19.400
so you don't need to disable
any warnings about it.

00:12:19.400 --> 00:12:21.420
Those warnings are long gone.

00:12:21.770 --> 00:12:24.280
There are a collection of
flags about coalescing.

00:12:24.550 --> 00:12:30.700
Coalescing is the internal
linkage system that gcc uses to

00:12:30.700 --> 00:12:34.200
ensure that in a C++ application,
the duplicate function

00:12:34.200 --> 00:12:36.300
definitions are removed.

00:12:36.630 --> 00:12:37.450
It's the default.

00:12:37.740 --> 00:12:40.450
It's been the default
for quite some time now,

00:12:40.550 --> 00:12:43.760
and the flags to switch it on and
off are -- the flags to switch

00:12:43.760 --> 00:12:47.360
it on are no longer necessary,
and they have been removed.

00:12:47.610 --> 00:12:51.500
Also, if you've been tweaking the
optimization settings in your project,

00:12:51.500 --> 00:12:55.500
so for instance, you've been changing
the inlining parameters,

00:12:55.680 --> 00:12:59.100
then you really want to
revisit that for gcc 4.0.

00:12:59.190 --> 00:13:01.630
We've completely revised
all the optimizers,

00:13:01.830 --> 00:13:05.780
so what these parameters mean now
is no longer what they used to mean,

00:13:05.860 --> 00:13:08.500
and some of these parameters
have been removed altogether.

00:13:08.500 --> 00:13:12.900
So you probably want to start by removing
all of those settings and then adding

00:13:12.900 --> 00:13:17.500
them back in as you find performance
problems with probably new settings.

00:13:20.680 --> 00:13:23.790
So let's talk about
Code Warrior Assembler because I know

00:13:23.850 --> 00:13:28.290
that's a topic that people really
seem to like in gcc 3.3 especially if

00:13:28.380 --> 00:13:32.440
you have to move from Code Warrior to
gcc 4.0 in a single jump.

00:13:32.470 --> 00:13:34.720
So we've improved the support a bit.

00:13:34.850 --> 00:13:37.560
We've improved it a bit,
some in Xcode 2.0, and we've further

00:13:37.560 --> 00:13:39.560
improved it in Xcode 2.1.

00:13:39.590 --> 00:13:42.760
Gcc now better analyzes
the instruction streams,

00:13:42.760 --> 00:13:47.020
so it knows which registers are used,
it knows what instructions you're using,

00:13:47.060 --> 00:13:52.600
it has an idea of which registers are
outputs and which registers are inputs.

00:13:52.640 --> 00:13:55.670
So a lot of bugs in that
area have gone away.

00:13:57.380 --> 00:14:03.000
The big Objective C++ improvement is that
instance variables now run constructors.

00:14:03.610 --> 00:14:08.250
So, you can take all of those complex C++
types from the C++ standard library and

00:14:08.310 --> 00:14:10.580
put them inside your Objective C objects.

00:14:11.200 --> 00:14:14.880
So, this is a significant advance if
you're using Objective C++ a lot.

00:14:15.130 --> 00:14:18.690
It does require you to
switch on a new flag,

00:14:18.690 --> 00:14:22.900
which is named something
almost intuitive.

00:14:22.900 --> 00:14:26.410
And unfortunately,
because this requires the

00:14:26.560 --> 00:14:30.630
Objective C runtime to
actually call the constructors,

00:14:30.750 --> 00:14:33.030
it requires support from it.

00:14:33.160 --> 00:14:34.940
And that support's only
available in Tiger.

00:14:34.940 --> 00:14:40.700
So, you can use this immediately if
you're only targeting Tiger or later.

00:14:41.160 --> 00:14:44.010
Otherwise,
you'll have to wait until you can.

00:14:45.860 --> 00:14:51.680
So we also made a bunch of improvements
involving symbol visibility.

00:14:51.910 --> 00:14:56.620
First of all, the old syntax of private
extern is still available.

00:14:56.630 --> 00:15:00.850
It actually works a bit better
than it ever used to before.

00:15:00.970 --> 00:15:06.740
But the recommended syntax is that
you use gcc standard attribute syntax.

00:15:06.740 --> 00:15:10.860
You get two choices, hidden,
which means private extern, and default,

00:15:10.860 --> 00:15:14.390
which means not.

00:15:14.540 --> 00:15:18.310
But we don't recommend that you
go through and individually attach

00:15:18.440 --> 00:15:21.680
the hidden attribute to all of the
things you don't want exported.

00:15:21.710 --> 00:15:26.130
Normally, from a management perspective,
it's a lot easier if you make

00:15:26.250 --> 00:15:30.540
everything hidden by default and
only make visible the things that

00:15:30.550 --> 00:15:33.340
you really expected to make visible.

00:15:33.340 --> 00:15:37.640
So there's a checkbox in Xcode,
symbols hidden by default,

00:15:37.640 --> 00:15:39.480
a very intuitive name.

00:15:39.480 --> 00:15:42.680
And then to make the things visible,
you just add the attribute and

00:15:42.680 --> 00:15:45.340
you say the visibility is default.

00:15:45.690 --> 00:15:50.390
The big improvement that we've made is
that this also now works on C++ classes.

00:15:50.390 --> 00:15:53.460
So when you have your
framework that's exporting C++

00:15:53.460 --> 00:15:57.270
classes to your application,
you can use this to control which

00:15:57.270 --> 00:15:59.610
classes really get exported.

00:16:01.830 --> 00:16:05.710
We also switched it on by default
for applications because if the

00:16:05.710 --> 00:16:09.990
linker and the dynamic linker know
that this symbol can't be exported,

00:16:10.170 --> 00:16:12.670
then it can use a
faster calling sequence,

00:16:12.720 --> 00:16:16.520
which actually significantly
improves your app's performance.

00:16:16.520 --> 00:16:19.360
This worked great except
in two situations.

00:16:19.500 --> 00:16:23.200
If you have plug-ins that actually try to
reference symbols from your application,

00:16:23.200 --> 00:16:25.240
then this isn't going to
work if they're hidden.

00:16:25.380 --> 00:16:29.160
And if you use dynamic cast
between classes that are in the

00:16:29.160 --> 00:16:32.850
inner framework and also possibly
defined in your application,

00:16:32.850 --> 00:16:36.700
they'll be treated as different classes
and therefore it won't work right.

00:16:36.700 --> 00:16:39.310
So if you want to do that,
you need to switch it off.

00:16:39.410 --> 00:16:42.260
And you can do this in Xcode.

00:16:42.260 --> 00:16:44.830
These two buttons here,
and in particular the top one,

00:16:44.830 --> 00:16:47.690
symbols hidden by default,
will be on by default for an application,

00:16:47.820 --> 00:16:49.590
so you just switch it off.

00:16:49.780 --> 00:16:52.850
If you do that,
you probably also want to make

00:16:52.930 --> 00:16:56.620
sure that the inline functions
hidden checkbox is switched on.

00:16:56.640 --> 00:16:59.410
Unless you're actually comparing the
address to the address of the function

00:16:59.470 --> 00:17:04.180
between a dial and your application,
then it's much more efficient

00:17:04.270 --> 00:17:06.740
to have the functions -- to
have inline functions be hidden.

00:17:06.740 --> 00:17:10.100
It means the linker can make a direct
call to them instead of having to

00:17:10.100 --> 00:17:11.600
potentially look at a framework.

00:17:13.540 --> 00:17:17.180
You can find these two by typing
hidden into the fairly large code

00:17:17.210 --> 00:17:20.430
generation set of compiler options.

00:17:23.950 --> 00:17:25.290
I said earlier we fixed bugs.

00:17:25.470 --> 00:17:26.200
We fixed lots of bugs.

00:17:26.200 --> 00:17:29.300
We fixed maybe thousands of bugs.

00:17:29.300 --> 00:17:31.730
Most of these bugs you will never
notice that they were fixed,

00:17:31.730 --> 00:17:33.950
or if you do,
it's only as a relief that you can

00:17:33.950 --> 00:17:35.960
finally stop worrying about it.

00:17:35.960 --> 00:17:39.170
Some of the bugs, as I said before,
are about code that was

00:17:39.190 --> 00:17:43.260
accepted before incorrectly,
that should never have been accepted,

00:17:43.510 --> 00:17:45.840
and that now we've managed,
and that now the compiler properly

00:17:45.840 --> 00:17:48.220
creates an error message for.

00:17:48.220 --> 00:17:50.500
So I'm going to run you
through a bunch of examples.

00:17:50.590 --> 00:17:53.570
Although this is not
really a hands-on talk,

00:17:53.580 --> 00:17:55.990
we do have sample code
for each of the examples,

00:17:55.990 --> 00:17:59.070
so you don't need to take
notes for each example.

00:17:59.080 --> 00:18:02.390
You can get the sample code
at the URL at the bottom,

00:18:02.390 --> 00:18:05.340
and you may -- and -- but you
don't need to get it right now.

00:18:05.340 --> 00:18:08.820
We're going to be -- I'm going to be
showing you them all on the screen.

00:18:11.030 --> 00:18:14.730
So the first example that I'm
going to talk about is the one

00:18:14.730 --> 00:18:16.900
that most people seem to hit.

00:18:17.050 --> 00:18:19.980
It's about dependent name lookup.

00:18:19.980 --> 00:18:24.920
So C++ has this concept when you're
using templates of a dependent name.

00:18:25.160 --> 00:18:29.300
The different--a dependent name
is something that in some way

00:18:29.450 --> 00:18:32.130
depends on a template parameter.

00:18:32.130 --> 00:18:35.690
So in this case,
the template parameter is T.

00:18:35.750 --> 00:18:38.020
If a name is dependent
on a template parameter,

00:18:38.040 --> 00:18:41.750
then the compiler can't--then the
compiler can't and in fact mustn't look

00:18:41.920 --> 00:18:44.550
it up until the template is instantiated.

00:18:44.620 --> 00:18:48.020
If it's not dependent,
the compiler looks it up right away.

00:18:48.050 --> 00:18:50.980
Previous versions of the compiler
didn't get this quite right.

00:18:50.980 --> 00:18:53.240
It would tend to delay looking
up nearly everything until

00:18:53.240 --> 00:18:54.680
the template was instantiated.

00:18:54.710 --> 00:18:59.730
This meant that names which were not
dependent would be--would sometimes

00:18:59.730 --> 00:19:02.650
be looked up in the wrong context.

00:19:02.650 --> 00:19:04.780
Gcc now gets this right.

00:19:05.610 --> 00:19:08.110
In this example here, though,
this is an example of some code

00:19:08.220 --> 00:19:12.150
that would have been accepted with
3.3 and that is no longer accepted,

00:19:12.280 --> 00:19:13.300
and you get an error message.

00:19:13.300 --> 00:19:17.720
As you can see there, class local was not
declared in this scope.

00:19:17.980 --> 00:19:22.480
When that happens-- so the
problem here is that class local

00:19:22.630 --> 00:19:29.290
is dependent-- is not explicitly
dependent on the template parameter t.

00:19:29.580 --> 00:19:34.410
and is not otherwise visible because
it's only visible in this other class,

00:19:34.560 --> 00:19:39.800
"SomeClass," which itself is dependent,
and therefore not part of the names

00:19:39.800 --> 00:19:42.300
that the compiler will look up.

00:19:42.300 --> 00:19:44.650
So what you have to do to fix
this is you've got to make

00:19:44.700 --> 00:19:47.060
"classLocalBe" a dependent name.

00:19:47.280 --> 00:19:49.320
And at this point,
you can probably forget most

00:19:49.320 --> 00:19:51.060
of that long explanation.

00:19:51.230 --> 00:19:54.500
All you really need to know is that
when you get this error message,

00:19:54.780 --> 00:19:58.060
you need to insert this
in front of the name.

00:19:58.320 --> 00:20:00.460
Nine times out of ten,
that will fix your problem,

00:20:00.460 --> 00:20:03.410
and you don't need to
think about it any further.

00:20:06.300 --> 00:20:08.100
Along with the other
template improvements,

00:20:08.410 --> 00:20:13.320
we've now-- gcc now properly
checks for the presence or

00:20:13.380 --> 00:20:14.690
absence of the type name keyword.

00:20:14.740 --> 00:20:17.080
And in fact,
it won't parse your class properly

00:20:17.080 --> 00:20:18.700
if you don't have it there.

00:20:18.750 --> 00:20:27.390
So it does give a helpful error message
to basically tell you to use type name.

00:20:27.820 --> 00:20:30.130
And so you actually do need to do that.

00:20:30.130 --> 00:20:30.130
And of course, you just add it in.

00:20:32.930 --> 00:20:38.270
Likewise, gcc needs proper use of
the template keyword.

00:20:38.310 --> 00:20:42.630
When you have an example here of--when
you have a case here of a template

00:20:42.630 --> 00:20:47.830
function inside a class--sorry,
inside an expression like that,

00:20:47.830 --> 00:20:53.040
the C++ standard requires that you use
the template keyword before the function

00:20:53.040 --> 00:20:57.570
to let the compiler know that the thing
that is the template is the function

00:20:57.570 --> 00:21:01.990
and that this zero is not supposed
to be attached to something else.

00:21:02.040 --> 00:21:07.260
And so, simply add it.

00:21:07.260 --> 00:21:07.260
Let's see.

00:21:14.620 --> 00:21:18.740
So another case where the compiler
is improved in C++ is that it's now

00:21:18.770 --> 00:21:25.470
better at detecting--it now properly
implements the C++ rules for in-class

00:21:25.470 --> 00:21:28.400
initialization of static members.

00:21:28.400 --> 00:21:30.860
There are two rules that you
need to be particularly aware of.

00:21:30.860 --> 00:21:33.110
First of all,
you're only allowed to have a

00:21:33.200 --> 00:21:38.190
static constant member like this
in a class with an initializer.

00:21:38.510 --> 00:21:41.930
If the actual type is an integer type,
as an extension,

00:21:41.930 --> 00:21:44.240
gcc allows floating point types.

00:21:44.240 --> 00:21:50.680
It does not allow pointers or other such
-- or classes or anything like that.

00:21:50.870 --> 00:21:53.940
So what you need to do is,
if you have code that does this,

00:21:53.970 --> 00:21:56.370
the compiler will tell you
that you can't do that,

00:21:56.370 --> 00:22:00.200
and you need to take the
initialization out of the class.

00:22:00.460 --> 00:22:02.960
So you simply remove the
initializer from the class and

00:22:02.960 --> 00:22:04.500
then place it in the definition.

00:22:08.630 --> 00:22:13.240
Another case where the compiler is
improved is in the case of members

00:22:13.250 --> 00:22:15.170
which actually are integers.

00:22:15.180 --> 00:22:15.960
So here we have an int.

00:22:16.010 --> 00:22:16.970
You're allowed to do this.

00:22:17.010 --> 00:22:18.520
That's fine.

00:22:18.740 --> 00:22:23.720
However,
this is not a definition of the variable.

00:22:23.730 --> 00:22:26.480
It just declares that the
variable exists and that it's

00:22:26.480 --> 00:22:29.300
always going to have that value.

00:22:29.550 --> 00:22:32.960
So GCC has become
better about optimizing.

00:22:32.980 --> 00:22:34.650
And so now,
sometimes you're going to see an

00:22:34.730 --> 00:22:38.960
error message from the linker saying
that this variable is undefined.

00:22:39.030 --> 00:22:39.960
And it's actually right.

00:22:39.960 --> 00:22:41.720
You haven't provided a definition.

00:22:41.750 --> 00:22:43.960
So you need to make sure you provide one.

00:22:43.980 --> 00:22:46.320
And the syntax for that looks like this.

00:22:46.320 --> 00:22:49.820
You don't continue to add the
initializer because you've

00:22:49.820 --> 00:22:50.840
already got one in the class.

00:22:50.930 --> 00:22:53.570
But you do need to mention it somewhere.

00:23:01.250 --> 00:23:08.040
Another case where the compiler better
adheres to this standard is in the case

00:23:08.040 --> 00:23:14.250
of access checking and copy constructors.

00:23:14.250 --> 00:23:14.250
So, let's see.

00:23:15.770 --> 00:23:22.350
So here we have a case where we have a
private copy constructor for the class A.

00:23:22.470 --> 00:23:26.360
So whenever the compiler needs
to make a temporary for a class

00:23:26.550 --> 00:23:30.530
and copy the old -- and copy some
other copy of the class into it,

00:23:30.530 --> 00:23:32.950
it needs to use the copy constructor.

00:23:33.020 --> 00:23:34.920
Making it private says that
it's not allowed to do this,

00:23:35.000 --> 00:23:38.920
that there shouldn't be temporaries
floating around that are generated

00:23:38.920 --> 00:23:43.080
by the compiler or by the user,
that you want to in some way

00:23:43.080 --> 00:23:46.030
control the use of this class.

00:23:46.270 --> 00:23:49.390
So in this case here,
we have a function which takes a

00:23:49.400 --> 00:23:53.030
reference to one of these classes,
and it's being called

00:23:53.160 --> 00:23:55.440
with a newly created copy.

00:23:55.790 --> 00:24:01.360
Iso C++ says that when this happens,
an extra temporary is created.

00:24:01.360 --> 00:24:04.040
So first you get a copy created
with the default constructor,

00:24:04.160 --> 00:24:10.660
then you get another temporary created,
and that's what's actually passed--

00:24:10.720 --> 00:24:13.420
that's what the reference is taken,
and that's what the reference to is

00:24:13.420 --> 00:24:13.420
taken and is passed to the function.

00:24:14.570 --> 00:24:17.300
The ISO C++ standard also says
that you don't have to actually

00:24:17.300 --> 00:24:18.460
call the copy constructor.

00:24:18.460 --> 00:24:20.390
You can just use the one copy.

00:24:20.710 --> 00:24:25.430
But it says that if the copy
constructor may not be called,

00:24:25.630 --> 00:24:29.310
then the compiler must
not accept this code.

00:24:30.130 --> 00:24:32.930
Previously,
gcc 3.3 was eliminating the extra

00:24:33.020 --> 00:24:36.920
copy and then also forgetting to check
that the copy constructor could still

00:24:37.010 --> 00:24:39.400
have been called if it needed to.

00:24:39.500 --> 00:24:41.380
So gcc 4.0 no longer does this.

00:24:41.470 --> 00:24:45.140
It properly verifies that the
copy constructor is visible.

00:24:45.400 --> 00:24:48.510
So if you have code like this,
what you need to do to fix it is to

00:24:48.620 --> 00:24:51.860
avoid the creation of the temporary
copy to make sure that all of

00:24:51.920 --> 00:24:54.400
your copies are actually named.

00:24:54.400 --> 00:24:56.400
And that's easy enough to do.

00:24:56.400 --> 00:24:58.990
You simply have a variable,
a named variable that's going

00:24:59.000 --> 00:25:01.300
to be the thing that's created,
and you pass that to

00:25:01.300 --> 00:25:02.400
the function instead.

00:25:02.400 --> 00:25:06.040
That way there's only one copy
of this class and the copy

00:25:06.050 --> 00:25:08.390
constructor need not be called.

00:25:11.800 --> 00:25:14.130
Another thing that the
ISO C++ standard says,

00:25:14.240 --> 00:25:17.170
which is a little pedantic,
but it does say it,

00:25:17.170 --> 00:25:20.950
is that there is only one acceptable
syntax for making a function

00:25:20.950 --> 00:25:23.940
an abstract virtual function.

00:25:23.980 --> 00:25:27.630
You say virtual int,
and then you declare the function,

00:25:27.760 --> 00:25:29.900
and then you say equals 0.

00:25:29.980 --> 00:25:34.200
Things that are not exactly the same as
equals 0 are not acceptable substitutes.

00:25:34.340 --> 00:25:37.980
So you can't say 0 plus 0,
and you can't say null.

00:25:38.100 --> 00:25:41.900
So gcc now correctly checks
for this and will give you a

00:25:41.900 --> 00:25:45.490
convenient warning message saying
it really expected to see a 0 there.

00:25:45.580 --> 00:25:47.610
And the answer is very simple.

00:25:47.880 --> 00:25:50.990
If it needs a 0 there,
that's what you should put.

00:25:54.040 --> 00:25:58.940
Another thing that is involved in
the syntax of C++ that's a little bit

00:25:58.940 --> 00:26:07.200
more serious is that when you call
new and you're creating a new array,

00:26:07.590 --> 00:26:10.640
The syntax of C++ doesn't
permit you to put parentheses

00:26:10.890 --> 00:26:13.440
around the name of the class.

00:26:13.510 --> 00:26:15.730
If you do put parens around,
that's actually trying to be a

00:26:15.730 --> 00:26:19.460
slightly different syntax where
the placement new operator.

00:26:19.460 --> 00:26:24.520
So gcc 4.0 now correctly detects
this case and doesn't let you do it.

00:26:24.520 --> 00:26:27.000
And the solution is very simple.

00:26:27.000 --> 00:26:31.300
Simply delete the parentheses,
and then the compiler will be happy.

00:26:33.940 --> 00:26:37.510
Another case where the compiler
has become more strict about a C++

00:26:37.510 --> 00:26:40.640
construct is default parameters.

00:26:40.730 --> 00:26:46.220
In C++, you're only allowed to declare
a default parameter once.

00:26:46.220 --> 00:26:49.690
You can declare it -- ideally,
you should declare it the

00:26:49.850 --> 00:26:54.130
first time you mention the
function that has the parameter.

00:26:54.130 --> 00:26:56.680
That way it can be used later on.

00:26:56.710 --> 00:26:58.990
What you can't do is
do it in both places.

00:26:59.080 --> 00:27:02.040
So in this case here,
we've got a function that

00:27:02.050 --> 00:27:05.830
has a default parameter,
and it's got it twice.

00:27:05.840 --> 00:27:07.950
And ISO C++ says you can't do that.

00:27:07.980 --> 00:27:11.340
Once you've said that a function -- once
you've given a default parameter once,

00:27:11.340 --> 00:27:14.380
afterwards, you need to simply just
declare the parameter,

00:27:14.380 --> 00:27:17.430
and just declare that parameter,
and the default will be taken from the

00:27:17.430 --> 00:27:20.230
previous time the function was seen.

00:27:22.910 --> 00:27:27.510
Another place where gcc now more
correctly interprets the standard in an

00:27:27.510 --> 00:27:30.890
important way is in reinterpret cast.

00:27:30.960 --> 00:27:34.550
The compiler used to allow a reinterpret
cast that was a no operation.

00:27:34.680 --> 00:27:36.780
So if you had an int and
you cast it again to an int,

00:27:36.930 --> 00:27:38.160
it would let that happen.

00:27:38.180 --> 00:27:40.130
C++ doesn't permit you to do this.

00:27:40.230 --> 00:27:44.880
It requires that a reinterpret
cast actually do something.

00:27:44.880 --> 00:27:49.650
The thing that a reinterpret cast
-- a cast that doesn't do anything

00:27:49.650 --> 00:27:53.480
is a static cast or a cast that
casts between two integer types.

00:27:53.480 --> 00:27:54.940
So we now correctly check for that.

00:27:57.600 --> 00:28:01.890
Finally, one more place the C++ compiler
became more strict is in the

00:28:01.890 --> 00:28:04.940
use of the offsetof expression.

00:28:04.940 --> 00:28:06.600
Offsetof is supposed to be a constant.

00:28:06.650 --> 00:28:10.630
You can see in this example,
which was accepted by gcc 3.3,

00:28:10.730 --> 00:28:15.390
that the actual offset is going to depend
on this index parameter to the function,

00:28:15.520 --> 00:28:17.500
which is not really constant at all.

00:28:17.540 --> 00:28:21.000
So gcc now correctly detects this case.

00:28:21.000 --> 00:28:23.260
To fix this,
you need to actually make the

00:28:23.260 --> 00:28:26.460
computation of the index part yourself.

00:28:26.640 --> 00:28:30.500
So instead of putting the index
inside the offsetof construct,

00:28:30.500 --> 00:28:34.910
you need to move it out and
multiply it by the appropriate

00:28:34.910 --> 00:28:37.050
size to get the right value.

00:28:40.410 --> 00:28:45.580
Um, so you've already ported your
app to gcc 4.0 using xcode

00:28:45.630 --> 00:28:47.900
2.0 that shipped with Tiger.

00:28:47.910 --> 00:28:49.750
And you're done, right?

00:28:50.250 --> 00:28:53.830
Well,
we did make one change to xcode 2.1.

00:28:54.000 --> 00:28:56.400
It's a trivial change,
and it shouldn't be much of a problem,

00:28:56.400 --> 00:28:58.860
but it is a small change.

00:28:59.470 --> 00:29:02.520
When you first declare
something in a namespace,

00:29:02.560 --> 00:29:05.970
you're supposed to just use the
name as a thing that you declare.

00:29:05.970 --> 00:29:10.270
You're not allowed to use
the double colon operator.

00:29:10.440 --> 00:29:15.630
So gcc now correctly checks for this
as part of wider changes to interpret

00:29:15.680 --> 00:29:20.080
the colon colon operator properly,
and now doesn't let you do it.

00:29:20.290 --> 00:29:22.300
And the solution to that is very simple.

00:29:22.340 --> 00:29:24.740
You're already in this namespace,
you're declaring something

00:29:24.740 --> 00:29:26.900
in the namespace,
you don't need to qualify it.

00:29:26.950 --> 00:29:29.300
You can just delete it.

00:29:29.450 --> 00:29:32.370
And that will make the
error message go away.

00:29:34.030 --> 00:29:36.870
So that was the C++
part of this talk done,

00:29:36.910 --> 00:29:39.000
almost.

00:29:39.000 --> 00:29:40.940
But we still have some
KEXT issues to talk about.

00:29:41.110 --> 00:29:43.980
KEXT didn't change
significantly in the compiler,

00:29:43.980 --> 00:29:45.970
but there are two things
that you should know about.

00:29:46.210 --> 00:29:49.850
First of all,
static local variables like this.

00:29:49.970 --> 00:29:54.980
You can see here we've got a
variable named x inside a function.

00:29:54.980 --> 00:29:58.980
And it's of type class 1,
and class 1 has a constructor.

00:29:58.980 --> 00:30:00.980
Not a particularly trivial
constructor either,

00:30:00.980 --> 00:30:02.980
it actually does some computation.

00:30:02.980 --> 00:30:08.900
So in gcc 4.0,
this constructor is now thread safe.

00:30:09.410 --> 00:30:13.590
If you're doing this in an application,
gcc will carefully lock around the

00:30:13.710 --> 00:30:17.120
first initialization of the variable x,
make sure that x is

00:30:17.120 --> 00:30:20.170
only initialized once,
and so on.

00:30:20.610 --> 00:30:22.490
In an app, this is great.

00:30:22.730 --> 00:30:26.650
In a KEXT, you probably don't want the
compiler inserting random locks

00:30:26.950 --> 00:30:28.500
in the middle of your KEXT.

00:30:28.670 --> 00:30:33.730
The compiler can't really
actually make the locks do the

00:30:34.160 --> 00:30:37.490
right thing inside the kernel,
and it's really impossible for it to try.

00:30:37.560 --> 00:30:39.560
I mean,
this could be in some interrupt routine,

00:30:39.560 --> 00:30:44.560
and it really can't lock or
block or wait or do anything.

00:30:44.720 --> 00:30:48.360
So for KEXTs, we didn't put in the
runtime support for this.

00:30:48.460 --> 00:30:52.450
So you'll get two undefined symbols,
cxa guard acquire and cxa guard release.

00:30:52.610 --> 00:30:54.740
What this means is you've
got a static initializer,

00:30:54.740 --> 00:30:58.600
and the compiler would like to
make it thread-safe but can't.

00:30:58.600 --> 00:31:01.100
So there's two possible
solutions to this.

00:31:01.340 --> 00:31:05.720
One solution,
simply move the static variable out so

00:31:05.720 --> 00:31:07.900
that it's no longer inside the function.

00:31:08.300 --> 00:31:10.390
Then it gets initialized
at KEXT load time,

00:31:10.470 --> 00:31:14.100
and everything's fine because
KEXT load time is single-threaded.

00:31:14.230 --> 00:31:17.760
Another possible solution is that
if you really know that this is safe

00:31:17.940 --> 00:31:20.460
and you don't want to move it out,
you can use the no thread

00:31:20.460 --> 00:31:22.840
safe statics option,
which is available as a

00:31:22.960 --> 00:31:24.600
checkbox in Xcode 2.1.

00:31:24.600 --> 00:31:28.580
Of course, if you do this,
you do run the risk that you

00:31:28.580 --> 00:31:34.270
might have two threads going
through the initialization,

00:31:34.270 --> 00:31:35.790
producing results which
are at best indeterminate,

00:31:35.790 --> 00:31:35.790
so you want to make sure
that it's really safe.

00:31:37.430 --> 00:31:41.050
The other kext-related change
involves member function pointers.

00:31:41.190 --> 00:31:43.190
Previously,
the compiler would let you take

00:31:43.190 --> 00:31:47.490
the address of a member function,
and you'd kind of get something very

00:31:47.490 --> 00:31:51.640
much like a real function pointer,
but not quite.

00:31:51.640 --> 00:31:55.420
That wasn't working very well,
so it was removed.

00:31:55.420 --> 00:31:58.910
So in this case here,
we have--we're trying to pass

00:31:58.910 --> 00:32:03.460
an interrupt handler to a
routine that will actually call

00:32:03.460 --> 00:32:05.860
it when the interrupt happens.

00:32:05.890 --> 00:32:10.600
And you can see we're taking the
address of a member function.

00:32:10.600 --> 00:32:16.210
So in the new scheme,
this is done with a macro.

00:32:20.790 --> 00:32:25.480
The macro is called osMemberFunctionCast,
and all you need to do is

00:32:25.500 --> 00:32:29.200
instead of--is--and it takes
a pointer to member function.

00:32:29.200 --> 00:32:34.700
So--and it takes a pointer to member and
returns a simple pointer to function.

00:32:34.880 --> 00:32:38.760
You do need to pass it the actual
root--the object that you're taking--an

00:32:38.760 --> 00:32:43.220
example of an object that you're taking
the address of the member function in.

00:32:43.220 --> 00:32:47.000
This is so it can find which virtual
function out of a class hierarchy

00:32:47.000 --> 00:32:50.700
is the actual one to call--is
the actual correct one to call.

00:32:53.510 --> 00:32:55.900
So, that's the C++ stuff done.

00:32:55.900 --> 00:32:59.810
If you've been asleep waiting
for me to talk about C,

00:32:59.910 --> 00:33:03.060
now is your time to wake up.

00:33:03.190 --> 00:33:06.620
There are a few simple C changes as well.

00:33:06.750 --> 00:33:09.800
First of all,
local static function declarations.

00:33:09.860 --> 00:33:12.420
You used to be able to
write code like this.

00:33:12.440 --> 00:33:17.080
And what we eventually worked out
that gcc was doing when you did this

00:33:17.230 --> 00:33:20.400
was that it would be binding--it
would look for some other function

00:33:20.430 --> 00:33:22.330
as a file scope static function.

00:33:22.330 --> 00:33:25.180
This is not exactly the same
as what happens if you have a

00:33:25.240 --> 00:33:30.320
static variable inside a function,
so--and it caused some other problems,

00:33:30.380 --> 00:33:34.160
so this extension has now been removed.

00:33:34.160 --> 00:33:37.750
So if you have code that does this,
you need to make a very simple change,

00:33:37.850 --> 00:33:41.910
which is instead of putting the static
function declaration inside the function,

00:33:41.960 --> 00:33:43.670
just move it out.

00:33:43.670 --> 00:33:48.920
So this is now standard C and
will work fine everywhere.

00:33:51.230 --> 00:33:56.650
Another change that was made to better
support interprocedural optimizations,

00:33:56.650 --> 00:34:03.790
in standard C,
once you're not permitted to declare

00:34:03.900 --> 00:34:06.940
something extern and then later static.

00:34:08.940 --> 00:34:13.410
So GCC no longer permits this
and will give you a helpful error

00:34:13.410 --> 00:34:14.940
message saying that you've done this.

00:34:14.960 --> 00:34:18.300
And there are two possible
solutions to this again.

00:34:18.300 --> 00:34:23.370
One possible solution is to simply
remove the previous external definition,

00:34:23.460 --> 00:34:25.250
so you just declare it
static the first time.

00:34:25.260 --> 00:34:28.390
Another possible solution
is to interchange the two.

00:34:28.400 --> 00:34:32.700
If you say static and later extern,
then in standard C that

00:34:32.970 --> 00:34:35.040
means it's still static.

00:34:38.220 --> 00:34:44.160
Another simple syntax change that we made
is about labels at the end of a block.

00:34:44.160 --> 00:34:46.730
In standard C syntax,
you're not allowed to have a label

00:34:46.730 --> 00:34:48.170
as the very last thing in a block.

00:34:48.220 --> 00:34:51.200
You have to have a label is
always followed by a statement.

00:34:51.240 --> 00:34:55.960
If you don't have any particular
statement to put there,

00:34:56.130 --> 00:35:01.100
there's a statement that does nothing,
the null statement,

00:35:01.100 --> 00:35:02.320
which is just represented
by a single semicolon,

00:35:02.320 --> 00:35:02.320
and that's what you should use.

00:35:10.890 --> 00:35:12.640
Let's talk about L values.

00:35:12.670 --> 00:35:16.500
L values are things that are on the
left-hand side of an assignment operator,

00:35:16.610 --> 00:35:17.800
thus the L.

00:35:17.910 --> 00:35:21.020
Previously,
gcc had this fairly interesting

00:35:21.020 --> 00:35:24.800
extension where it would let you put
all kinds of things on the left-hand

00:35:24.800 --> 00:35:26.800
side of an assignment operator.

00:35:26.800 --> 00:35:29.200
It would let you put casts,
it would let you put

00:35:29.360 --> 00:35:33.180
conditional expressions,
it would let you put comma expressions,

00:35:33.200 --> 00:35:36.370
and it would, in each of these cases,
it would do something

00:35:36.680 --> 00:35:37.800
that mostly made sense.

00:35:37.840 --> 00:35:40.800
For instance, in the example of the
conditional expression,

00:35:40.820 --> 00:35:45.350
it would pick one of the
two and assign to it.

00:35:45.660 --> 00:35:50.350
The problem with this is that in C++,
this doesn't do what

00:35:50.350 --> 00:35:52.130
it used to do anymore.

00:35:52.440 --> 00:35:57.110
It doesn't guarantee that standard
behavior continues to work the same way.

00:35:57.120 --> 00:36:00.540
In certain cases,
temporaries wouldn't get created.

00:36:00.540 --> 00:36:04.900
In certain cases, the wrong overloaded
function would be chosen.

00:36:04.930 --> 00:36:06.980
So we had to take it out.

00:36:07.450 --> 00:36:14.390
It's available in the current gcc 4.0
in C and I believe in C++ as a warning.

00:36:14.610 --> 00:36:17.580
In the future,
it will go away completely.

00:36:17.580 --> 00:36:19.070
So now is a great time to fix this.

00:36:22.250 --> 00:36:24.860
So the fix is always very simple.

00:36:24.920 --> 00:36:29.800
Instead of having full variables in
these expressions on the left-hand side,

00:36:29.930 --> 00:36:32.950
simply take their address,
do your conditional operation

00:36:33.050 --> 00:36:37.860
or your cast or your comma
operation to the address,

00:36:37.920 --> 00:36:40.070
and then dereference it.

00:36:40.240 --> 00:36:43.790
So what that looks like is you add
a bunch of ampersands and stars.

00:36:48.070 --> 00:36:50.910
So as I said, gcc 4.0,
we have a new optimization

00:36:50.920 --> 00:36:53.380
infrastructure using tree SSA.

00:36:53.380 --> 00:36:54.680
We think it's great.

00:36:54.680 --> 00:36:57.510
It's going to be -- in the future,
it's going to lead us to significant

00:36:57.510 --> 00:37:00.240
improvements in performance.

00:37:00.240 --> 00:37:03.850
But because we rewrote everything,
some things that were never --

00:37:03.880 --> 00:37:08.660
are never really defined by the
C standard or by the C language now

00:37:08.810 --> 00:37:11.210
no longer do what they used to do.

00:37:11.340 --> 00:37:14.270
They're still not defined,
and now they're not defined and

00:37:14.270 --> 00:37:16.120
they do something different.

00:37:16.120 --> 00:37:19.920
You don't really want to be having
not defined behavior in your program.

00:37:19.920 --> 00:37:23.010
So in this case here is an
example of a place where you

00:37:23.010 --> 00:37:25.280
might have accidentally done this.

00:37:25.280 --> 00:37:29.700
This is not -- gives undefined behavior
because you're only allowed to reference

00:37:29.730 --> 00:37:33.890
a variable in -- between sequence points,
which is a complicated term

00:37:33.940 --> 00:37:37.280
defined in the ISOC standard,
to give it the same value.

00:37:37.660 --> 00:37:42.510
So in this example, the question is,
does the plus plus happen before or

00:37:42.520 --> 00:37:45.320
after the first I parameter is evaluated?

00:37:46.260 --> 00:37:46.280
And the answer is, it's not defined.

00:37:46.280 --> 00:37:48.370
It can be either one.

00:37:48.370 --> 00:37:51.380
It can be -- it can even be both.

00:37:51.380 --> 00:37:54.840
So occasionally, your code's behavior may
change if you have this.

00:37:55.020 --> 00:37:58.850
The best way to find such
cases is to switch on warnings.

00:37:58.890 --> 00:38:01.330
GCC will give you a
very convenient warning.

00:38:01.420 --> 00:38:03.900
Operation on I might be undefined.

00:38:04.070 --> 00:38:07.220
When you say such a warning,
it means you've done something like this.

00:38:07.270 --> 00:38:09.680
So what you want to do is you want
to split this up into multiple

00:38:09.680 --> 00:38:13.320
statements so that the compiler knows
what order things should be done in.

00:38:13.380 --> 00:38:17.270
So in this example here,
you see that the code is not defined.

00:38:17.390 --> 00:38:20.350
You just want to move the I plus plus out
to either before or pos -- to after or

00:38:20.450 --> 00:38:23.990
possibly before the call of the function.

00:38:25.490 --> 00:38:29.500
Um, another case where the optimizers
have now become smarter,

00:38:29.510 --> 00:38:32.970
and that might lead to
different behavior in your code,

00:38:32.970 --> 00:38:34.500
is this case here.

00:38:34.500 --> 00:38:38.840
We have a variable named "x" that
hasn't been declared volatile.

00:38:38.840 --> 00:38:43.180
We have a cast to make it to
the address of the variable,

00:38:43.180 --> 00:38:46.020
with a typo on the slide, sorry.

00:38:46.020 --> 00:38:49.000
We have a cast of the address of
the variable to make it volatile,

00:38:49.000 --> 00:38:52.520
but the compiler still knows that it
can look through the cast and it can see

00:38:52.550 --> 00:38:55.730
the original variable is not volatile,
so it knows that the original

00:38:55.850 --> 00:38:57.840
variable can't change behind its back.

00:38:57.840 --> 00:39:00.560
So it will compile this
code into an infinite loop,

00:39:00.580 --> 00:39:04.180
when what you probably wanted was for
it to actually test "x" every time,

00:39:04.190 --> 00:39:06.520
so that you could say,
"Change x in the debugger and

00:39:06.520 --> 00:39:10.510
let the program continue."
The solution to this is very simple.

00:39:10.600 --> 00:39:15.040
If you need a variable to be volatile,
just declare it as volatile originally,

00:39:15.100 --> 00:39:17.490
and then everything will just work.

00:39:22.410 --> 00:39:26.900
The last change that we made is that,
well, we changed the version number.

00:39:26.900 --> 00:39:29.500
The version number is 4.0.

00:39:29.500 --> 00:39:32.200
If you've been testing for
different GCC version numbers,

00:39:32.200 --> 00:39:35.480
you might have accidentally been
using a construct like this,

00:39:35.490 --> 00:39:37.540
where you check to see if
the minor version number is

00:39:37.630 --> 00:39:39.800
greater than or equal to 1.

00:39:39.800 --> 00:39:46.580
Well, so 4.0 is greater than 3,
but .0 is not greater than 1.

00:39:46.670 --> 00:39:48.280
So if you were using
a construct like this,

00:39:48.280 --> 00:39:49.040
it won't work.

00:39:49.040 --> 00:39:50.840
So be aware of this in your code.

00:39:50.840 --> 00:39:53.410
If you see anything like this,
you need to change it to

00:39:53.450 --> 00:40:00.950
explicitly check that it's 3.1 or
higher than .1 or higher than 3.

00:40:05.660 --> 00:40:08.500
So, that's the end of the code examples,
and remember they are

00:40:08.500 --> 00:40:10.680
all in the sample code,
so you don't need to panic if

00:40:10.680 --> 00:40:12.830
you missed one in the middle,
with an explanation that's even

00:40:12.830 --> 00:40:13.920
better than the one I just gave you.

00:40:15.530 --> 00:40:20.680
So we made a few minor changes as well.

00:40:20.980 --> 00:40:26.620
Framework header searching now
actually searches for frameworks.

00:40:26.810 --> 00:40:29.800
First of all, a framework is supposed
to be an atomic unit.

00:40:29.870 --> 00:40:32.680
There's no such thing as an
override framework or a delta

00:40:32.680 --> 00:40:34.780
framework or part of a framework.

00:40:34.930 --> 00:40:39.190
So when GCC finds a framework,
it stops looking for files

00:40:39.360 --> 00:40:41.180
in that framework later on.

00:40:41.280 --> 00:40:44.400
So if you've been overriding
system headers or system frameworks

00:40:44.400 --> 00:40:48.570
by copying one header file and
then into a framework structure,

00:40:48.570 --> 00:40:52.280
your program will no longer
work because it'll find that

00:40:52.280 --> 00:40:54.510
one header file no problems,
but it won't find anything

00:40:54.510 --> 00:40:55.450
else in the framework.

00:40:55.590 --> 00:40:59.810
So you need to either copy the whole
framework or use some other mechanism.

00:40:59.980 --> 00:41:03.770
Another improvement that we made is that
gcc no longer searches for frameworks

00:41:03.880 --> 00:41:07.660
in directory specified with -i,
and it no longer searches for regular

00:41:07.660 --> 00:41:11.180
headers in frameworks specified with -f.

00:41:11.180 --> 00:41:13.740
So -i and -f are no
longer the same thing.

00:41:13.740 --> 00:41:16.990
They now actually mean look for
frameworks or look for headers.

00:41:17.030 --> 00:41:19.600
This helps to reduce the number of
headers that are accidentally found,

00:41:19.600 --> 00:41:22.150
but it does mean that if you've
been using them interchangeably,

00:41:22.340 --> 00:41:25.490
you need to now work out
which ones hold which.

00:41:28.850 --> 00:41:30.440
And there were some minor changes.

00:41:30.440 --> 00:41:33.780
So Objective C now properly
detects selector matching.

00:41:33.820 --> 00:41:37.450
I mentioned the warning flag earlier,
but there's also other detection

00:41:37.780 --> 00:41:42.120
involved that -- where it actually --
where the runtime behavior is improved.

00:41:42.120 --> 00:41:45.550
We made some changes about better
detection of things that were

00:41:45.550 --> 00:41:48.920
supposed to be void and aren't,
functions that were supposed

00:41:48.920 --> 00:41:52.100
to return void and that were
actually trying to return a value,

00:41:52.100 --> 00:41:55.900
functions that were supposed to return
a value and are actually returning void.

00:41:55.900 --> 00:41:58.480
Zero messages for these are all really
straightforward and more or less

00:41:58.490 --> 00:42:00.020
paraphrase what's on the screen there.

00:42:04.740 --> 00:42:11.130
So we should also mention that one of
the significant changes in Xcode 2.1 is

00:42:11.140 --> 00:42:14.150
that it's based on final fsf gcc 4.0,
which,

00:42:14.300 --> 00:42:19.490
as at the time the CDs were printed,
was the latest gcc version -- the latest

00:42:19.570 --> 00:42:22.340
fsf gcc release that you could get.

00:42:22.340 --> 00:42:26.280
And we should also mention that
it's a fully open source project.

00:42:26.390 --> 00:42:33.700
The source code is available at the --
with all the other WWDC 2005 sources.

00:42:33.700 --> 00:42:37.610
And we should -- and if you want
to make some small minor change

00:42:37.610 --> 00:42:41.500
that -- to your local copy,
you can download the source and build it.

00:42:41.550 --> 00:42:43.810
Of course,
we caution that we're not going

00:42:44.080 --> 00:42:48.830
to maintain your local change,
so that's kind of your responsibility.

00:42:48.850 --> 00:42:52.300
So we caution against making significant
changes and then trapping yourself

00:42:52.370 --> 00:42:54.870
into one version of the compiler.

00:42:56.490 --> 00:43:00.820
So, in summary, move to gcc 4.0.

00:43:00.820 --> 00:43:02.780
Not only does it let
you build Intel apps,

00:43:02.780 --> 00:43:06.390
build 64-bit apps, run faster,
it also has thousands of bug fixes in it.

00:43:06.520 --> 00:43:10.400
It has better optimizations
and it runs faster.

00:43:10.530 --> 00:43:12.400
So it's our best compiler yet.

00:43:13.580 --> 00:43:16.380
You may have to adjust
your code a little bit,

00:43:16.600 --> 00:43:19.400
but the changes--the long
list that I've added,

00:43:19.400 --> 00:43:20.400
most of those problems are rare.

00:43:20.400 --> 00:43:24.590
There have been large projects
built that have had none of these

00:43:24.600 --> 00:43:26.390
problems and that have just worked.

00:43:26.400 --> 00:43:30.150
When you do find these problems,
as you can see from the examples,

00:43:30.150 --> 00:43:32.400
many of these are really easy to fix.

00:43:32.400 --> 00:43:33.400
You just add a couple of characters.

00:43:33.400 --> 00:43:37.000
So--and hopefully you can remember
some of those error messages and

00:43:37.000 --> 00:43:40.400
some of those situations and go
back and look at the sample code.

00:43:40.600 --> 00:43:42.350
And with any luck, you'll get it.

00:43:42.400 --> 00:43:45.350
you'll be able to see what
those few character changes are.

00:43:48.040 --> 00:43:50.730
So at this point,
I believe we have plenty

00:43:50.730 --> 00:43:53.790
of time for questions.

00:43:53.930 --> 00:43:55.320
Oh, but first,

00:43:55.470 --> 00:44:01.400
So if the presentation didn't fully
answer your problems with gcc 4.0

00:44:01.400 --> 00:44:05.140
or if you have further questions,
first of all,

00:44:05.140 --> 00:44:07.880
don't forget the sample code.

00:44:07.890 --> 00:44:09.620
I know I've mentioned
it three times already,

00:44:09.620 --> 00:44:11.440
but it's really very helpful.

00:44:11.560 --> 00:44:16.560
That's available on the WDC website at
the same URL as all the other sample

00:44:16.560 --> 00:44:19.540
code documentation and other resources.

00:44:19.580 --> 00:44:23.820
There's also the gcc 4.0 release notes.

00:44:23.880 --> 00:44:29.830
There's also information
about the new C++ ABI and what

00:44:29.830 --> 00:44:33.800
you can rely on in that ABI.

00:44:33.800 --> 00:44:36.250
There's the gcc manual,
which tells you all

00:44:36.290 --> 00:44:38.570
of these option names,
what they exactly do,

00:44:38.570 --> 00:44:41.520
and a large number of other
options that there's far too little

00:44:41.530 --> 00:44:43.960
time for me to talk about here.

00:44:43.960 --> 00:44:46.590
So that's all available at the website.

00:44:48.230 --> 00:44:50.770
In addition,
there are some related sessions

00:44:50.970 --> 00:44:53.100
that I should particularly mention.

00:44:53.100 --> 00:44:56.940
There is a lab, the Xcode and Tools lab.

00:44:57.300 --> 00:44:59.200
It's just across the way.

00:44:59.200 --> 00:45:01.410
All you have to do is
walk across the corridor,

00:45:01.410 --> 00:45:03.680
and there will be people
there who can help you.

00:45:04.460 --> 00:45:06.330
In addition,
if none of that seems to help

00:45:06.340 --> 00:45:09.230
or you just want to tell us
how wonderful the compiler is,

00:45:09.310 --> 00:45:14.890
there's the Development Tools Feedback
Forum Friday at 5:00.

00:45:17.570 --> 00:45:25.110
And finally, if all else fails,
you can contact Matthew, who is not me.

00:45:25.760 --> 00:45:30.810
or anybody else in or we
have or DTS in general,

00:45:30.810 --> 00:45:33.440
ADC in general,
we have lots of people who

00:45:33.440 --> 00:45:35.900
are quite happy to help you
to take your bug reports,

00:45:35.900 --> 00:45:40.480
to assist you with migration,
to suggest strategies.
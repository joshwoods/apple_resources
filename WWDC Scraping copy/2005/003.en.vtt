WEBVTT

00:00:02.750 --> 00:00:04.020
Hi there.

00:00:04.050 --> 00:00:04.700
I'm Eric Albert.

00:00:04.760 --> 00:00:06.260
Over there is Ronnie Misra.

00:00:06.260 --> 00:00:08.970
We're members of Apple's
Core Technologies team.

00:00:09.040 --> 00:00:12.470
And today we're going to talk to you
about extending your application to

00:00:12.470 --> 00:00:17.180
run on the Intel-based Macintoshes
that we just announced yesterday.

00:00:17.180 --> 00:00:21.150
So what this means is we're going to
take you through the entire process

00:00:21.610 --> 00:00:26.190
of taking an application whose authors
actually hadn't even contemplated

00:00:26.220 --> 00:00:28.020
the existence of such machines.

00:00:28.080 --> 00:00:35.420
And we're going to make it build,
move it to GCC4, make it run,

00:00:35.420 --> 00:00:41.050
take you through the debugging process,
through the testing process,

00:00:41.050 --> 00:00:44.840
and then talk about all of the things
that we ran into along the way and a

00:00:44.840 --> 00:00:47.760
few additional things that you might
run into when you try to move your

00:00:47.840 --> 00:00:51.780
applications to our Intel-based systems.

00:00:52.180 --> 00:00:54.610
So first of all,
the things that you may have to

00:00:54.610 --> 00:00:57.240
do when moving any application,
or that you're going to have to

00:00:57.240 --> 00:00:58.260
do when moving any application.

00:00:58.260 --> 00:01:00.130
Step one, make it build.

00:01:00.180 --> 00:01:05.400
In a lot of cases, actually,
this is the most challenging thing,

00:01:05.750 --> 00:01:09.200
because the first step
here is move it to GCC 4.

00:01:09.200 --> 00:01:11.810
And if you're building
with CodeWare today,

00:01:11.810 --> 00:01:16.340
or if you're building with GCC 3.3,
then actually you can do this today

00:01:16.340 --> 00:01:19.560
without even installing Xcode 2.1.

00:01:19.560 --> 00:01:21.520
You can do it on the
shipping version of Tiger.

00:01:21.520 --> 00:01:24.640
You can do it in Xcode 2.1
without building Universal.

00:01:24.640 --> 00:01:28.520
But you have to move your
application to GCC 4.

00:01:28.520 --> 00:01:31.710
And whether you do that with
an Xcode or with Makefiles,

00:01:31.820 --> 00:01:35.060
whatever works for your
project as you build today.

00:01:35.060 --> 00:01:38.770
Second,
you have to make your build environment

00:01:38.770 --> 00:01:41.810
work on our Intel-based systems.

00:01:41.900 --> 00:01:45.240
So if you're using Xcode,
that's really simple.

00:01:45.240 --> 00:01:45.960
It works.

00:01:45.960 --> 00:01:47.900
Just install Xcode 2.1.

00:01:47.900 --> 00:01:48.620
Everything's there.

00:01:48.620 --> 00:01:53.130
If you are not using Xcode, however,
if you're using configure

00:01:53.130 --> 00:01:57.900
scripts or Makefiles,
or if you have custom build tools to pre-

00:01:57.900 --> 00:02:00.720
or post-process files or to construct
parts of your build environment,

00:02:00.720 --> 00:02:04.100
then you're going to have to make those
work before you can actually get to the

00:02:04.120 --> 00:02:06.050
point of making your application work.

00:02:06.120 --> 00:02:08.270
In some cases,
you may be able to run some

00:02:08.270 --> 00:02:09.820
build tools translated.

00:02:09.820 --> 00:02:13.500
But in a lot of cases,
you're just going to have to rebuild

00:02:13.510 --> 00:02:18.310
them for Intel-based systems or
rebuild them as Universal binaries.

00:02:18.620 --> 00:02:19.640
And then go from there.

00:02:19.660 --> 00:02:23.200
And once that's done,
to actually get your application

00:02:23.200 --> 00:02:27.100
to build on Intel-based systems
or with the 10.4 Universal SDK,

00:02:27.150 --> 00:02:30.210
we have a few small API changes.

00:02:30.220 --> 00:02:34.540
And when I say small here, I really,
honestly, truly mean small.

00:02:34.560 --> 00:02:38.250
Just a couple targeted things
that affect a few people that you

00:02:38.250 --> 00:02:43.670
may have to adopt to allow your
applications to work on these systems.

00:02:43.720 --> 00:02:47.610
Once all of that's done and you
have an application that builds,

00:02:47.680 --> 00:02:48.380
then you can start
building your application.

00:02:48.380 --> 00:02:48.570
And then you can start
building your application.

00:02:48.670 --> 00:02:49.110
And that's great.

00:02:49.140 --> 00:02:51.030
You can then go ahead and run it.

00:02:51.080 --> 00:02:53.640
And chances are reasonably
good that it'll just launch.

00:02:53.680 --> 00:02:55.620
And then you see what breaks.

00:02:55.620 --> 00:02:58.570
Unfortunately,
there isn't any sort of magic pixie dust

00:02:58.570 --> 00:03:02.470
that you can drop on your application to
find all of the endiness problems that

00:03:02.470 --> 00:03:04.200
you might run into or anything like that.

00:03:04.220 --> 00:03:07.640
Instead, really, you run through it.

00:03:07.640 --> 00:03:08.980
You do a full QA pass.

00:03:08.980 --> 00:03:10.700
You test all of the features.

00:03:10.700 --> 00:03:13.810
And you see what works and what doesn't,
what draws correctly and what doesn't.

00:03:13.820 --> 00:03:16.120
Ideally, all of it will be just fine.

00:03:16.120 --> 00:03:18.460
But, you know,
chances are there might be.

00:03:18.570 --> 00:03:20.600
There's a couple of things here and
there that you need to patch up.

00:03:20.720 --> 00:03:23.570
And the way to do that is just
to run through everything.

00:03:23.620 --> 00:03:27.070
So how hard is all of this?

00:03:28.030 --> 00:03:29.470
Well.

00:03:30.520 --> 00:03:32.640
It's not very hard at all.

00:03:32.640 --> 00:03:35.720
You heard at the keynote, of course,
about Mathematica,

00:03:35.720 --> 00:03:37.460
and that was two hours.

00:03:37.460 --> 00:03:38.740
That was exceptional.

00:03:38.740 --> 00:03:41.860
I know I've talked to a lot of
people who have actually moved their

00:03:41.860 --> 00:03:45.480
applications over to our Intel-based
systems already and have said,

00:03:45.660 --> 00:03:48.470
wow, how on earth did it take the
Mathematica people so long?

00:03:48.480 --> 00:03:49.600
Mine came up in 15 minutes.

00:03:51.100 --> 00:03:52.260
Well, for some people, that may be true.

00:03:52.260 --> 00:03:54.710
For others,
it may take a little bit longer.

00:03:54.710 --> 00:03:57.690
So I'm not going to stand up
here and say this is incredibly

00:03:57.690 --> 00:03:59.340
easy or anything like that.

00:03:59.490 --> 00:04:01.090
For some people, it may be simple.

00:04:01.090 --> 00:04:03.320
For others,
it may be a larger amount of work.

00:04:03.420 --> 00:04:06.030
It really depends on your code base,
depends on what your

00:04:06.030 --> 00:04:07.220
application is doing.

00:04:07.220 --> 00:04:09.990
But in general, it just isn't that hard.

00:04:10.000 --> 00:04:12.380
Like Steve said,
this is not the Mac OS 9 to

00:04:12.380 --> 00:04:14.360
Mac OS X transition all over again.

00:04:14.370 --> 00:04:16.450
It should be a lot easier than that.

00:04:17.700 --> 00:04:21.740
So, what we're actually going to do...
...is show you today is Firefox.

00:04:21.780 --> 00:04:24.870
We're going to move Firefox to
our Intel-based systems.

00:04:24.880 --> 00:04:27.770
So if you aren't familiar with Firefox,
it's probably the world's

00:04:27.970 --> 00:04:29.600
second most popular web browser.

00:04:29.630 --> 00:04:33.320
It comes from the Mozilla Foundation.

00:04:33.340 --> 00:04:37.220
The reason why we could work on it
is because it's entirely open source.

00:04:37.220 --> 00:04:39.540
So you can actually go
and grab the source code.

00:04:39.590 --> 00:04:42.400
In fact, after this,
you can go and grab the source code and

00:04:42.410 --> 00:04:44.100
make the changes that we talk about here.

00:04:44.100 --> 00:04:48.390
And then you'll actually be able
to bring it up on our systems.

00:04:49.180 --> 00:04:51.860
So Firefox consists of
four million lines of code.

00:04:51.940 --> 00:04:55.940
The authors, of course,
never had to think about these systems.

00:04:56.040 --> 00:05:00.940
So there isn't really anything
in there that would contemplate

00:05:01.020 --> 00:05:03.540
being run on Mac OS X on Intel.

00:05:03.540 --> 00:05:06.520
And with that much code,
you'd think that there

00:05:06.620 --> 00:05:08.070
are a lot of problems.

00:05:08.180 --> 00:05:09.860
But in fact,
we're actually going to take you through

00:05:09.990 --> 00:05:11.350
it over the course of this session.

00:05:11.440 --> 00:05:13.950
So, step one.

00:05:14.040 --> 00:05:17.420
When you go to the Mozilla website
and you grab the Firefox source code,

00:05:17.420 --> 00:05:18.620
...so, step one.

00:05:18.620 --> 00:05:20.620
When you go to the Mozilla website
and you grab the Firefox source code,

00:05:20.620 --> 00:05:22.870
...then the first thing that you
have to do is actually download and

00:05:22.930 --> 00:05:26.070
install something called "Think"
...and then install a bunch of open

00:05:26.070 --> 00:05:27.620
source libraries that come from Think.

00:05:27.710 --> 00:05:30.380
If you aren't familiar with Think,
it's a package management system

00:05:30.630 --> 00:05:34.620
...that lets you install a
variety of open source packages,

00:05:34.620 --> 00:05:39.620
applications, libraries,
and other things like that on Mac OS X.

00:05:39.620 --> 00:05:42.620
It isn't the only package
management system.

00:05:42.730 --> 00:05:47.630
There are others which are
either easier or harder,

00:05:47.630 --> 00:05:48.860
depending on a variety of things,
...to make run on our

00:05:48.860 --> 00:05:49.780
Intel-based systems.

00:05:49.780 --> 00:05:51.770
But since Think is the
one that Firefox uses,

00:05:52.060 --> 00:05:54.780
then that's the one that
we're going to show you.

00:05:54.780 --> 00:05:58.020
And when you download the Think code
and you start the install,

00:05:58.020 --> 00:06:00.780
then, well, you get this right away.

00:06:00.780 --> 00:06:05.070
Checking system i386 Apple Darwin 8.1.0,
Think is currently not

00:06:05.070 --> 00:06:06.770
supported on x86 Darwin.

00:06:06.780 --> 00:06:07.780
Darn it.

00:06:07.780 --> 00:06:10.890
Various parts of Think hardcode
PowerPC and assume to run on a

00:06:10.890 --> 00:06:12.780
PowerPC-based operating system.

00:06:12.780 --> 00:06:14.780
Use Think on this
system at your own risk.

00:06:14.780 --> 00:06:16.780
That just isn't to please me.

00:06:16.930 --> 00:06:18.780
That just isn't too promising.

00:06:18.780 --> 00:06:20.780
We don't really like the sound of that.

00:06:20.780 --> 00:06:24.770
So,
step one is to make this stop happening.

00:06:25.010 --> 00:06:29.280
When you get error messages like this,
and Ronnie will cover some similar

00:06:29.360 --> 00:06:32.170
cases in the Firefox code later,
...the easiest thing to do,

00:06:32.170 --> 00:06:34.210
or the best thing to
do when you start out,

00:06:34.720 --> 00:06:36.770
is search through the source code,
...figure out where this

00:06:36.770 --> 00:06:38.620
error message is coming from,
find the case that's

00:06:38.620 --> 00:06:41.780
actually triggering it,
...fix that case, and then move on.

00:06:41.780 --> 00:06:43.780
Hopefully things will run a lot better.

00:06:43.780 --> 00:06:47.780
In this case,
we search for the error message,

00:06:47.860 --> 00:06:49.780
find it in a Perl module
file inside the Think code.

00:06:49.790 --> 00:06:52.750
Think actually largely
consists of Perl code.

00:06:52.780 --> 00:06:56.780
And we see here there's this case where
they check the host name of the system.

00:06:56.780 --> 00:07:01.470
And they say, "Okay,
if we're running on any random version

00:07:01.470 --> 00:07:05.780
of this Darwin x86 thing that Apple has
provided for a number of years,

00:07:05.780 --> 00:07:08.720
...which not all that many
people have actually used,

00:07:08.830 --> 00:07:12.780
then we're going to say, 'Okay,
it isn't supported,' and slightly worse,

00:07:12.780 --> 00:07:16.750
...as far as we're concerned,
we're going to default to trying

00:07:16.800 --> 00:07:21.780
to act like we're on Jaguar." But,
well, this isn't Jaguar anymore.

00:07:21.880 --> 00:07:25.780
This is Mac OS X on Intel-based
Macintoshes running Tiger.

00:07:25.780 --> 00:07:27.750
So we have to add a new case for this.

00:07:27.830 --> 00:07:32.780
And it says, "Okay,
if our platform is actually Darwin 8.1.0,

00:07:32.780 --> 00:07:36.810
then copy what Think currently
has for Tiger," ...which says

00:07:36.830 --> 00:07:39.780
this brand new system is still
being tested but should work.

00:07:39.780 --> 00:07:41.780
And hopefully it'll work once we're done.

00:07:41.780 --> 00:07:47.780
And then use the current
Think Tiger distribution.

00:07:47.780 --> 00:07:51.220
So when we add that,
we get past that first

00:07:51.220 --> 00:07:52.780
stage and we move on.

00:07:52.830 --> 00:07:54.750
And Think starts compiling.

00:07:54.810 --> 00:07:56.780
We get past the configure script.

00:07:56.780 --> 00:07:58.780
And it's building and
we get a compiler error.

00:07:59.140 --> 00:08:02.000
And this error,
"Array type has incomplete

00:08:02.000 --> 00:08:05.780
element type," Well,
this is not Intel-specific.

00:08:05.780 --> 00:08:10.580
In fact, this is just something
that needs a fix for GCC4.

00:08:11.120 --> 00:08:13.780
Today doesn't entirely know about GCC4.

00:08:13.780 --> 00:08:16.700
GCC4 is the compiler for
Intel-based Macintoshes.

00:08:16.780 --> 00:08:18.760
So we're going to have to fix this.

00:08:18.780 --> 00:08:21.740
And when we fix that and move on,
that's it.

00:08:22.110 --> 00:08:23.780
We're done.

00:08:23.780 --> 00:08:26.780
So an entire package
management system for Mac OS X.

00:08:26.790 --> 00:08:27.730
Two changes.

00:08:27.800 --> 00:08:28.770
One to the configure script.

00:08:28.780 --> 00:08:30.780
One to one of the files.

00:08:30.780 --> 00:08:36.130
And at this point, actually,
we have -- we can install the

00:08:36.150 --> 00:08:38.710
four libraries that Firefox needs.

00:08:38.860 --> 00:08:39.780
We can build them for Intel.

00:08:39.780 --> 00:08:42.780
And then we can move
on to Firefox itself.

00:08:42.780 --> 00:08:45.780
And now then over to Ronnie.

00:08:45.780 --> 00:08:46.970
All right.

00:08:47.930 --> 00:08:52.300
So I wish I could say that it
was as easy to port Firefox,

00:08:52.300 --> 00:08:56.100
just two changes, but unfortunately,
that's not the case.

00:08:56.100 --> 00:08:58.930
Let's see what actually happens
when we start to compile it.

00:08:59.000 --> 00:09:06.610
We're going to need to switch
to the computers to see this.

00:09:07.880 --> 00:09:15.600
So, I guess I should have given this
introduction while we were all waiting.

00:09:15.780 --> 00:09:18.640
I'm not actually going to compile
most of the code right here,

00:09:18.640 --> 00:09:21.050
right now,
because that would take forever.

00:09:21.280 --> 00:09:25.600
Instead, I have sort of canned
output from Make Files,

00:09:25.640 --> 00:09:28.930
and I already have diffs
ready for us to see.

00:09:29.030 --> 00:09:33.080
So I just wanted to point that out right
now so that you guys don't think that I'm

00:09:33.080 --> 00:09:34.980
trying to pull the wool over your eyes.

00:09:34.990 --> 00:09:36.650
It does take a while to build Firefox.

00:09:36.700 --> 00:09:40.340
I think it takes about half
an hour for a full build.

00:09:40.370 --> 00:09:42.580
And I have to do this several
times over the presentation.

00:09:42.580 --> 00:09:47.590
So with that, let's see what happens
when we just type make.

00:09:55.000 --> 00:10:04.000
[Transcript missing]

00:10:04.400 --> 00:10:50.500
[Transcript missing]

00:10:54.520 --> 00:11:00.000
So here's the file merge output for
my changes to the configure script.

00:11:00.030 --> 00:11:02.280
As you can see,
the changes are pretty small.

00:11:02.600 --> 00:11:09.760
I basically just copied the PowerPC case
and changed the architecture for i386.

00:11:09.800 --> 00:11:16.540
So I'll turn it back
over to Eric who can...

00:11:18.700 --> 00:12:42.100
[Transcript missing]

00:12:46.500 --> 00:12:51.340
Okay, so here's that same bit of code.

00:12:51.340 --> 00:12:54.430
Instead of accessing the fields directly,
I'm using these APIs called

00:12:54.430 --> 00:12:59.150
getAliasSizeFromPointer to access
the size of an alias record.

00:12:59.160 --> 00:13:03.000
Unfortunately,
these APIs are relatively new.

00:13:03.000 --> 00:13:04.200
They don't exist on Panther.

00:13:04.200 --> 00:13:08.740
So if you want your code to continue
to compile and run on Panther,

00:13:08.740 --> 00:13:12.600
you'll want to make a
macro to do the same thing.

00:13:12.600 --> 00:13:15.900
Here I've done that using
the availability macros.

00:13:15.900 --> 00:13:18.680
I define a macro called
getAliasSizeFromPointer,

00:13:18.680 --> 00:13:21.320
which does the same thing
that this code used to do.

00:13:21.460 --> 00:13:29.370
So this allows you to continue
to compile on earlier OSs.

00:13:29.900 --> 00:15:24.500
[Transcript missing]

00:15:24.910 --> 00:15:28.260
Firefox builds this internal
tool called ASDecode,

00:15:28.260 --> 00:15:32.320
which is used to decode
Apple single files.

00:15:32.400 --> 00:15:34.420
It throws an assertion.

00:15:34.420 --> 00:15:38.400
So let's figure out
what's going on there.

00:15:38.400 --> 00:15:40.210
Here's the bit of code
that throws the assertion.

00:15:40.220 --> 00:15:46.200
You can see that it's not finding
the magic number that it expects.

00:15:46.250 --> 00:15:50.780
If we look slightly earlier in the code,
you can see here's a structure.

00:15:50.780 --> 00:15:52.440
It has multi-byte types.

00:15:52.440 --> 00:15:56.600
These types in Apple single files
are defined to be Big-Endian.

00:15:56.720 --> 00:15:59.480
So when running ASDecode
on this platform,

00:15:59.630 --> 00:16:04.610
it sees the little-Endian version -- or,
sorry, it sees a swapped

00:16:04.610 --> 00:16:07.800
version of those fields.

00:16:07.800 --> 00:16:07.800
So --

00:16:09.610 --> 00:16:14.390
In the next phase,
we'll make the changes required for

00:16:14.390 --> 00:16:16.960
proper Endian access to these fields.

00:16:16.960 --> 00:16:20.500
You'll see that I'm using
the OS swap routines.

00:16:20.500 --> 00:16:27.400
OS swap big to host int32 takes in an
integer that's known to be big Endian

00:16:27.400 --> 00:16:31.390
and converts it to the host Endianness,
whether that be little or big.

00:16:31.400 --> 00:16:38.190
So the interesting thing to note here is
it does absolutely nothing on PowerPC,

00:16:38.200 --> 00:16:43.950
so there's no performance impact to
using this in your existing PowerPC code.

00:16:43.960 --> 00:16:49.600
So I don't have header guards
around this to say if big Endian.

00:16:49.600 --> 00:16:55.700
So I had to use these macros
a couple places in the code.

00:16:55.700 --> 00:16:59.800
Here's using the 16-bit version
instead of the 32-bit version.

00:16:59.800 --> 00:17:04.780
The prototypes come from this header,
which you'll want to include.

00:17:04.820 --> 00:17:07.600
We also--well,
Eric will talk more about this.

00:17:07.600 --> 00:17:08.690
Amen.

00:17:13.500 --> 00:17:16.990
So what he was showing
here is swap as needed.

00:17:17.120 --> 00:17:20.150
And when you have to swap data,
there are actually four different

00:17:20.150 --> 00:17:23.650
headers in the system that
define various swapping APIs.

00:17:23.910 --> 00:17:25.940
So there's nsbyteorder.h in Foundation.

00:17:26.000 --> 00:17:31.220
There's endian.h, which is in CarbonCore,
cfbyteorder.h in Core Foundation,

00:17:31.220 --> 00:17:35.540
and osbyteorder.h,
which is in user include libkern.

00:17:36.310 --> 00:17:39.800
Essentially,
they all end up calling the same thing.

00:17:39.800 --> 00:17:42.300
You can call whichever one
you're the most comfortable with.

00:17:42.300 --> 00:17:44.150
So if you're writing Objective-C code,
for example,

00:17:44.230 --> 00:17:47.740
then you may want to use nsbydoordor.h
just because that's part of foundation.

00:17:47.740 --> 00:17:51.220
If you're writing Carbon code,
then you can use ndn.h.

00:17:51.780 --> 00:17:56.290
The important thing here is use
the functions and macros that we

00:17:56.350 --> 00:18:00.740
provide for swapping because when
we sit down and take a look at

00:18:00.750 --> 00:18:05.320
performance on the system and work on
improving it in a variety of places,

00:18:05.320 --> 00:18:07.110
these are the things that we optimize.

00:18:07.120 --> 00:18:11.320
If you write your own swapping code,
then it may turn out to be slower.

00:18:11.320 --> 00:18:14.430
And particularly in those rare cases,
or hopefully rare cases,

00:18:14.490 --> 00:18:16.830
where you have to swap a lot,
then you really want

00:18:16.830 --> 00:18:18.120
to be using our APIs.

00:18:19.850 --> 00:18:23.760
The second thing here, again,
is we recommend that you

00:18:23.870 --> 00:18:27.270
don't add #if statements for
big-endian or little-endian when

00:18:27.270 --> 00:18:28.630
you write your swapping code.

00:18:28.750 --> 00:18:32.900
Because all of these,
if you are swapping from a

00:18:32.900 --> 00:18:37.100
target architecture that's the
same as your host architecture,

00:18:37.160 --> 00:18:39.520
will do absolutely nothing.

00:18:39.520 --> 00:18:41.680
The compiler will simply
optimize that out.

00:18:41.680 --> 00:18:43.100
It'll vanish from your code.

00:18:43.100 --> 00:18:46.250
And then you'll have much
cleaner code than you would if

00:18:46.250 --> 00:18:51.230
you actually said if big-endian,
then swap else little-endian do

00:18:51.230 --> 00:18:54.260
nothing or something like that.

00:18:54.300 --> 00:18:56.240
So now that we have
our swapping straight,

00:18:56.270 --> 00:18:58.040
then on to Ronnie for the next step.

00:18:58.550 --> 00:18:58.860
Okay.

00:18:58.940 --> 00:19:02.840
So after making this change,
we get past the ASD code problem.

00:19:02.860 --> 00:19:05.990
And we encounter this error.

00:19:06.080 --> 00:19:11.880
The build system is mostly makefiles,
but they build some of

00:19:11.880 --> 00:19:13.440
their targets with Xcode.

00:19:13.450 --> 00:19:18.050
And makefiles driving Xcode and scripts
driving Xcode will not be the same.

00:19:18.050 --> 00:19:19.500
So the scripts driving
Xcode will probably have to

00:19:19.510 --> 00:19:22.520
be adapted for Xcode 2.1.

00:19:22.520 --> 00:19:26.100
Xcode 2.1 has support for build
configurations that require a

00:19:26.100 --> 00:19:29.850
change to where build targets
actually land in the build directory.

00:19:29.930 --> 00:19:36.980
So let's take a look at what
those changes look like.

00:19:39.860 --> 00:19:42.880
Now again, Firefox is an open source app,
and they want people to compile

00:19:42.880 --> 00:19:44.430
it on all sorts of OSes.

00:19:44.550 --> 00:19:49.560
So I wanted to make these changes work,
continue to work on older versions of

00:19:49.560 --> 00:19:51.160
the OS and older versions of Xcode.

00:19:51.160 --> 00:19:55.680
So you'll see here I've introduced
a new variable called builder,

00:19:55.680 --> 00:20:00.160
which is by default dot,
and if I detect that the Xcode version

00:20:00.160 --> 00:20:04.240
is greater than or equal to 620,
which is the build number

00:20:04.240 --> 00:20:07.210
that Xcode reports,
then I use the appropriate

00:20:07.240 --> 00:20:10.010
directory for the build style.

00:20:10.020 --> 00:20:15.950
And here I've made the changes that
actually reference that variable.

00:20:17.370 --> 00:20:18.950
And after that, we actually get a binary.

00:20:19.030 --> 00:20:23.270
And here I'm running that binary in GDB,
just sort of expecting

00:20:23.270 --> 00:20:24.970
that it's going to crash.

00:20:28.700 --> 00:21:09.600
[Transcript missing]

00:21:09.600 --> 00:21:14.600
RegParm isn't supported
on our platform right now.

00:21:14.650 --> 00:21:18.100
If you do intro library calls,
some of the registers get corrupted.

00:21:18.100 --> 00:21:24.120
And so for now,
I'm just going to turn that off.

00:21:30.130 --> 00:21:32.960
So here are the diffs to turn it off.

00:21:33.010 --> 00:21:36.000
Basically,
I've just added a section to the end

00:21:36.000 --> 00:21:40.190
of their--or added a check to the end
of their pound diffs to make sure that

00:21:40.190 --> 00:21:43.880
we're not on Mac OS when using regparm.

00:21:44.570 --> 00:21:46.900
And after that,
we compile again and we run again.

00:21:46.900 --> 00:21:48.530
You'll see I'm running it in GDB again.

00:21:48.540 --> 00:22:03.580
That takes a little while to
launch because it runs-- or

00:22:03.580 --> 00:22:05.740
it uses a lot of libraries.

00:22:18.000 --> 00:22:19.000
And look at that.

00:22:19.000 --> 00:22:21.540
Back there,
there's actually a Firefox window.

00:22:21.540 --> 00:22:26.380
So we've brought it up with
relatively few changes,

00:22:26.470 --> 00:22:29.560
but of course,
I wouldn't ship it at this point because

00:22:29.560 --> 00:22:31.900
we haven't really done any testing.

00:22:31.900 --> 00:22:39.690
The first thing we're going to
try to do is access some plug-ins.

00:22:39.690 --> 00:22:39.690
I've got this bookmarked already.

00:22:40.100 --> 00:23:06.600
[Transcript missing]

00:23:06.720 --> 00:23:10.350
EBP minus 56 is this value.

00:23:10.580 --> 00:23:15.380
And one thing that I should
mention about the ROS is our

00:23:15.380 --> 00:23:17.620
stacks are 16-byte aligned.

00:23:17.620 --> 00:23:21.710
The OS actually requires that
because we use these instructions

00:23:21.780 --> 00:23:27.530
in various bits of code in ROS,
and so code that manipulates the

00:23:27.790 --> 00:23:30.390
stack has to be aware of this.

00:23:30.390 --> 00:23:32.430
Firefox is not aware.

00:23:32.430 --> 00:23:37.020
If we look in the back trace -- oops,
wrong window.

00:23:40.130 --> 00:23:47.020
There's this JavaScript invoke stuff
which calls into their XPC layer,

00:23:47.040 --> 00:23:51.100
which we will see here,
manipulates the stack.

00:23:51.100 --> 00:23:56.990
XPTC invoke by index sets up
a custom stack before calling

00:23:56.990 --> 00:24:00.560
out to JavaScript code.

00:24:00.680 --> 00:24:05.470
And we're going to have to change that
to be where to keep the stack aligned.

00:24:10.800 --> 00:24:12.100
So those changes are here.

00:24:12.100 --> 00:24:20.190
I've added support for saving the
stack away and making sure that it's 16

00:24:20.190 --> 00:24:23.270
byte aligned and restoring the stack.

00:24:23.320 --> 00:24:25.000
Again,
this probably won't affect most of you,

00:24:25.000 --> 00:24:29.930
but I just wanted to point it out here
for those of you that it does affect.

00:24:30.000 --> 00:24:33.660
But the more general
problem of optimizing code,

00:24:33.940 --> 00:24:39.200
you may have a lot of code that you've
optimized for other Intel-based operating

00:24:39.560 --> 00:24:42.000
systems or even for Mac OS X on PowerPC.

00:24:42.000 --> 00:24:45.330
You'll want to reexamine some
of those optimizations because

00:24:45.330 --> 00:24:48.480
some of your assumptions may
not be true on this platform,

00:24:48.480 --> 00:24:50.570
and Eric will talk more about that.

00:24:53.150 --> 00:24:59.700
So we went through actually two
significantly different steps here.

00:24:59.700 --> 00:25:03.060
The first one is adopting
build configurations.

00:25:03.060 --> 00:25:06.530
And hopefully we can get
the slides back up here.

00:25:07.100 --> 00:25:10.630
I can talk about them anyway.

00:25:10.700 --> 00:25:15.270
So as Ronnie mentioned,
the new build configurations

00:25:15.560 --> 00:25:19.970
feature of Xcode 2.1,
which actually satisfies a need

00:25:20.110 --> 00:25:22.660
that a lot of people have been
asking for for a long time,

00:25:22.660 --> 00:25:29.110
which is to keep different copies for
debug and release builds of your binary

00:25:29.120 --> 00:25:32.710
around so when you change that setting,
then you don't have to rebuild

00:25:33.500 --> 00:25:35.000
everything from scratch.

00:25:35.190 --> 00:25:38.400
It's absolutely terrific,
but it can be a little bit tricky

00:25:38.400 --> 00:25:41.710
at times if you have projects
that use Makefiles that need to

00:25:41.710 --> 00:25:44.350
reference things out of the build,
or if you have shell scripts

00:25:44.350 --> 00:25:47.070
that need to reference things
that have already been built.

00:25:47.190 --> 00:25:55.180
So if you have either of those and they
interact with your Xcode build results,

00:25:55.180 --> 00:25:57.750
then you may have to make some
slight changes to them to actually

00:25:57.750 --> 00:25:57.750
adopt build configurations.

00:25:58.570 --> 00:26:02.760
And next, after that,
adhere to the Mac OS X ABI.

00:26:02.840 --> 00:26:07.180
So there's some documentation about the
ABI in the universal binary programming

00:26:07.180 --> 00:26:10.450
guidelines that you've now all received.

00:26:10.520 --> 00:26:13.040
The two things that we
covered here-- first,

00:26:13.110 --> 00:26:15.940
don't use the regparm attribute today.

00:26:16.010 --> 00:26:20.280
It doesn't work on our current systems,
and that's something that certainly

00:26:20.280 --> 00:26:22.520
we'll take a look at in the future.

00:26:22.530 --> 00:26:25.220
And secondly,
maintain 16-byte stack alignment.

00:26:25.290 --> 00:26:28.200
So if you do any custom
stack manipulation,

00:26:28.200 --> 00:26:32.980
if you're doing custom code to call
between languages or anything like that,

00:26:32.980 --> 00:26:36.780
then you may have code,
like what Ronnie showed with Firefox,

00:26:36.780 --> 00:26:39.560
that ends up manipulating the stack.

00:26:39.600 --> 00:26:41.180
And essentially,
the stack always has to be

00:26:41.180 --> 00:26:43.960
16-byte aligned at the point
of the call instruction.

00:26:43.990 --> 00:26:47.280
Otherwise, because the compiler actually,
for us,

00:26:47.360 --> 00:26:52.580
generates vector instructions by default,
then subsequent code may crash because

00:26:52.580 --> 00:26:56.000
it's assuming that the stack is aligned,
and therefore that it can use the aligned

00:26:56.000 --> 00:26:57.900
versions of the vector instructions.

00:26:57.900 --> 00:27:02.110
Now, back to Ronnie for the next step.

00:27:02.480 --> 00:27:08.350
Okay, so I'm launching the
executable again in GDB.

00:27:34.790 --> 00:27:41.480
So the next thing I want to
look at is plug-in support.

00:27:42.980 --> 00:27:45.200
It seems like plugins sort of just work.

00:27:45.210 --> 00:27:48.900
And as you can see,
it found the QuickTime plugin.

00:27:48.900 --> 00:27:51.300
It found its default plugin.

00:27:51.350 --> 00:27:53.340
But if we look down at
the bottom of the list,

00:27:53.340 --> 00:27:55.140
it also found the Shockwave plugin.

00:27:55.140 --> 00:27:59.550
Shockwave is only built
for PowerPC currently,

00:27:59.550 --> 00:28:05.570
so we want to change the code in
Firefox to detect that it's not a

00:28:05.570 --> 00:28:08.390
legal plugin for this architecture.

00:28:08.390 --> 00:28:12.400
So let's take a look at that code.

00:28:16.800 --> 00:28:22.570
So here's the code in Firefox to detect
whether something is a plugin file.

00:28:22.680 --> 00:28:28.120
It already has some checks to make sure
that it has the right creator type and

00:28:28.520 --> 00:28:29.780
: Thank you, Eric.

00:28:29.790 --> 00:28:34.510
I'm going to start off by saying thank
you to all of you for joining us today.

00:28:47.230 --> 00:28:51.100
So I've included some new headers,
and I've added this new function

00:28:51.100 --> 00:28:54.710
called isPluginLoadable,
which takes a--

00:28:54.900 --> 00:29:06.200
[Transcript missing]

00:29:06.700 --> 00:29:13.800
[Transcript missing]

00:29:14.420 --> 00:29:22.420
we cause the code that supports
CFM plug-ins to not be turned on for

00:29:22.420 --> 00:29:28.330
the native build on Intel because
we don't support CFM on native

00:29:28.970 --> 00:29:31.690
processes running plug-ins.

00:29:31.860 --> 00:29:37.670
CFM apps will continue to run under
the translator and CFM plug-ins

00:29:37.860 --> 00:29:40.400
will work there but not here.

00:29:40.400 --> 00:29:44.210
And here I've added in a check to
my new function to make sure that we

00:29:44.380 --> 00:29:47.920
check the architecture before adding
any plug-in to our plug-in list.

00:29:50.700 --> 00:29:53.000
So with that,
I'll hand it back over to Eric.

00:29:53.000 --> 00:29:53.500
ERIC ALTER: OK.

00:29:53.530 --> 00:29:55.580
So again,
what he showed you here was load

00:29:55.580 --> 00:29:57.320
the right plugins for the system.

00:29:57.320 --> 00:30:00.770
So an application can only load
plugins of the same architecture

00:30:00.770 --> 00:30:03.440
as the application itself,
which means that if your

00:30:03.500 --> 00:30:07.520
application is running translated,
then it can load PowerPC plugins.

00:30:07.520 --> 00:30:11.100
If your application is running natively,
then it can load Intel plugins.

00:30:11.100 --> 00:30:15.780
And if you try to actually call
NSBundleLoad or CFBundleLoad executable

00:30:15.780 --> 00:30:21.220
on a bundle of the wrong architecture,
one that you can't load, then, well,

00:30:21.360 --> 00:30:23.550
it'll simply fail to load,
and you'll probably get an

00:30:23.550 --> 00:30:24.870
error message in the console.

00:30:24.880 --> 00:30:28.110
And just your application's
behavior won't be quite as

00:30:28.110 --> 00:30:29.620
nice as it would otherwise be.

00:30:29.630 --> 00:30:34.010
So the best thing to do then is
to actually check the type of the

00:30:34.010 --> 00:30:35.540
plugin that you're trying to load.

00:30:35.540 --> 00:30:41.700
And don't try to load
CFM plugins in your Intel build.

00:30:41.700 --> 00:30:48.290
And don't try to load Maco PowerPC thin
plugins when running natively.

00:30:48.670 --> 00:30:52.050
So unfortunately, as he showed you,
the code for that is

00:30:52.120 --> 00:30:53.360
currently a little bit messy.

00:30:53.360 --> 00:30:55.480
You have to poke at the Mac OS headers.

00:30:55.530 --> 00:30:57.220
Hopefully,
we'll have a better solution for you

00:30:57.220 --> 00:31:00.900
in the future where you can actually
determine what architectures are

00:31:00.900 --> 00:31:03.440
contained within an executable file.

00:31:03.440 --> 00:31:05.720
And now that we have the
right plugins loading,

00:31:05.720 --> 00:31:07.080
then off to the next step.

00:31:07.720 --> 00:31:08.120
Okay.

00:31:08.120 --> 00:31:13.320
Well, so here I'm running the app,
and you see the plugins actually work.

00:31:13.320 --> 00:31:20.080
Here's a QuickTime trailer that
I cached from our trailer site.

00:31:20.300 --> 00:31:39.900
[Transcript missing]

00:31:42.300 --> 00:31:45.030
We can go to some of the news sites.

00:31:45.070 --> 00:31:47.270
You can see that people were
talking about Apple's big

00:31:47.270 --> 00:31:49.700
move when I cached this page.

00:31:49.900 --> 00:31:54.110
But when we browse to some of
the other sites on Google News,

00:31:54.350 --> 00:31:56.880
we get a crash.

00:31:56.880 --> 00:32:00.620
So this is a crash in font handling code.

00:32:00.620 --> 00:32:02.580
If we look at the code,

00:32:03.630 --> 00:32:04.960
It's parsing font data.

00:32:04.960 --> 00:32:11.690
One of the things that we mention
in our guide is that font data is

00:32:11.690 --> 00:32:14.250
always big endian on this platform.

00:32:14.310 --> 00:32:18.240
So when you have code that
directly references fields

00:32:18.240 --> 00:32:22.840
for low-level parts of a font,
you'll want to adapt those to

00:32:23.030 --> 00:32:25.070
properly deal with endianness.

00:32:25.100 --> 00:32:27.660
We'll take a look at
the changes to do that.

00:32:30.490 --> 00:32:35.900
So here I'm making use of
the OS swap macros again.

00:32:38.450 --> 00:32:43.800
With these changes,
we're pretty much done.

00:32:43.800 --> 00:32:46.330
I'm going to run the binary again.

00:32:58.890 --> 00:33:00.900
Of course, when I say done,
we haven't really done

00:33:00.900 --> 00:33:01.940
any extensive testing.

00:33:01.940 --> 00:33:07.270
And after we go to more websites,
we'll probably find more problems.

00:33:07.400 --> 00:33:12.970
But all in all, it was a relatively easy
process to port this app.

00:33:13.230 --> 00:33:18.630
And it's generally pretty stable now.

00:33:27.660 --> 00:33:30.600
Here we can go to that Google News page,
which crashed before.

00:33:30.600 --> 00:33:43.340
And just to be more thorough,
I found this font test page on the web.

00:33:47.400 --> 00:33:59.300
[Transcript missing]

00:34:06.570 --> 00:34:08.870
So this last step here,
read and write data in

00:34:08.870 --> 00:34:10.740
the right Endianness.

00:34:10.740 --> 00:34:14.160
So some data is always Big Endian.

00:34:14.160 --> 00:34:17.620
I was trying to think of any cases
in the system where we have data

00:34:17.620 --> 00:34:21.180
that's always Little Endian today,
but I don't believe we do.

00:34:21.180 --> 00:34:23.710
At least I'm pretty certain
that we haven't--if we do,

00:34:23.800 --> 00:34:27.030
we haven't introduced any
new ones with this release.

00:34:27.210 --> 00:34:30.630
So the data that's always Big Endian,
all of this is mentioned in the

00:34:30.630 --> 00:34:32.760
Universal Binary Programming Guide.

00:34:32.760 --> 00:34:36.360
So low-level font data,
and by that I mean if you're actually

00:34:36.390 --> 00:34:42.420
poking at the font fields directly rather
than using the higher-level ATS APIs.

00:34:42.440 --> 00:34:47.380
ColorSync profile element
data is always Big Endian.

00:34:47.380 --> 00:34:50.310
Very low-level finder information,
and by that I mean if you're

00:34:50.310 --> 00:34:54.100
calling get-attr-list,
not if you're calling fscatalog-info

00:34:54.100 --> 00:34:56.010
or anything above that.

00:34:56.020 --> 00:34:58.640
And as I mentioned before,
QuickDraw picture bounds,

00:34:58.670 --> 00:35:01.250
which you may notice if you
haven't actually updated your code

00:35:01.250 --> 00:35:03.340
to call QD get-picture bounds.

00:35:06.020 --> 00:35:07.220
So that's it.

00:35:07.220 --> 00:35:09.750
At that point, we have a web browser.

00:35:09.760 --> 00:35:14.420
We have a major Mac OS X application that
we have been extended to run on Intel.

00:35:14.420 --> 00:35:18.880
So to run once more through the steps
that you should follow to bring your

00:35:19.120 --> 00:35:25.770
application over to our platform,
first, again, move it to GCC 4.

00:35:26.000 --> 00:35:43.600
[Transcript missing]

00:35:44.080 --> 00:35:44.990
Really?

00:35:45.130 --> 00:35:46.090
Just run through everything?

00:35:46.280 --> 00:35:47.230
See what you've got?

00:35:47.340 --> 00:35:49.380
I mean,
like the example that Ronnie showed,

00:35:49.530 --> 00:35:52.790
you hand it out to people
and they will find bugs,

00:35:52.790 --> 00:35:53.760
and then you'll fix them.

00:35:53.760 --> 00:35:55.790
And in general,
the fixes just aren't all that hard.

00:35:55.800 --> 00:35:57.810
It's, "Oh, okay,
so we crash here because this

00:35:57.880 --> 00:35:59.120
needs to be bytes swapped.

00:35:59.230 --> 00:35:59.430
Great.

00:35:59.510 --> 00:36:00.860
Here's a bytes swap.

00:36:00.910 --> 00:36:01.660
Wonderful.

00:36:01.700 --> 00:36:03.970
You're pretty confident
that it works." I mean,

00:36:04.050 --> 00:36:07.200
one of the wonderful things
that we've found in making

00:36:07.550 --> 00:36:09.150
changes for this platform is that

00:36:09.600 --> 00:36:27.400
[Transcript missing]

00:36:28.500 --> 00:36:33.000
So a few other common issues that
I wanted to touch on that we actually

00:36:33.000 --> 00:36:37.350
didn't hit in the process of moving
Firefox to our Intel-based systems.

00:36:37.360 --> 00:36:40.400
First of all,
file formatting compatibilities.

00:36:40.400 --> 00:36:45.780
So if you don't use
NS Coding or Cocos Archiving,

00:36:45.780 --> 00:36:48.480
if you don't use a
text-based file format,

00:36:48.480 --> 00:36:51.930
if you don't already have cross-platform
code to read and write files,

00:36:52.120 --> 00:36:55.510
then you may have to do some work
to ensure that you always write your

00:36:55.510 --> 00:36:59.270
file formats in exactly the same
way when running on PowerPC-based

00:36:59.270 --> 00:37:01.100
systems or on Intel-based systems.

00:37:01.100 --> 00:37:02.860
Because, you know,
it would be really nice if

00:37:02.860 --> 00:37:05.310
your users could actually copy
those files between the two.

00:37:05.320 --> 00:37:08.210
Second, networking issues.

00:37:08.220 --> 00:37:12.480
One thing that we've seen all the
time is that people assume that,

00:37:12.480 --> 00:37:16.420
or have been able to assume for years,
that, hey, PowerPC byte order is the

00:37:16.420 --> 00:37:18.900
same as networking byte order,
so I don't actually need to

00:37:18.900 --> 00:37:20.930
do any sort of byte swapping
when dealing with the network.

00:37:21.820 --> 00:37:24.330
That's no longer the case,
or still the case.

00:37:24.340 --> 00:37:25.680
PowerPC byte order is the same.

00:37:25.680 --> 00:37:29.420
But on Intel-based systems,
the byte ordering is different

00:37:29.420 --> 00:37:31.980
from network byte order,
so you may have to add

00:37:31.980 --> 00:37:33.300
some swapping code there.

00:37:33.300 --> 00:37:35.440
Integer divide by zero.

00:37:35.440 --> 00:37:38.120
Because Firefox is
already cross-platform,

00:37:38.120 --> 00:37:41.360
then presumably they've already
taken care of all of these cases.

00:37:41.360 --> 00:37:46.700
But integer divide by zero is
fatal on all Intel systems.

00:37:46.700 --> 00:37:49.750
And so in those cases,
you just have to check for

00:37:49.850 --> 00:37:53.550
zero and return zero I'm sorry.

00:37:53.850 --> 00:37:55.760
Some color drawing problems.

00:37:55.850 --> 00:37:59.640
So we were rather fortunate that
we didn't see any with Firefox.

00:37:59.670 --> 00:38:05.350
But OpenGL, Core Graphics, and Quickdraw,
all of those APIs,

00:38:05.530 --> 00:38:09.400
if you have color drawing problems,
you may need some changes.

00:38:09.440 --> 00:38:13.110
All of this is covered, again,
in our documentation.

00:38:13.400 --> 00:38:17.070
But in a lot of cases,
drawing code will simply

00:38:17.140 --> 00:38:18.170
work out of the box.

00:38:18.280 --> 00:38:19.920
If it doesn't,
there are a few small things

00:38:19.960 --> 00:38:21.820
that you may need to tweak.

00:38:21.850 --> 00:38:23.800
Undefined or implementation-defined code.

00:38:23.800 --> 00:38:27.140
So things that the compiler doesn't
necessarily warn you about doing.

00:38:27.210 --> 00:38:29.880
Things that are undefined
with numeric calculations.

00:38:29.950 --> 00:38:33.930
Things that are out of range
can return different results

00:38:34.010 --> 00:38:35.700
than they used to on PowerPC.

00:38:35.700 --> 00:38:38.910
And in those cases, well, hey,
it's a great way to track down these

00:38:39.000 --> 00:38:41.790
bugs that may have been in your
application for a long time where

00:38:41.790 --> 00:38:43.880
you were getting unexpected values.

00:38:44.110 --> 00:38:47.240
Custom resources, Apple events,
or pasteboard types.

00:38:47.270 --> 00:38:52.400
I'm not sure if anyone so far has
actually talked about the Core NDE and

00:38:52.400 --> 00:38:55.730
APIs for flipping resources,
Apple events, or pasteboard data.

00:38:55.750 --> 00:39:01.060
All of that's covered pretty thoroughly
in the universal binary guide.

00:39:01.100 --> 00:39:05.360
But if you have custom resource types,
not ones that are standard in the system,

00:39:05.480 --> 00:39:09.270
or if you have custom
Apple event or pasteboard types,

00:39:09.270 --> 00:39:12.280
then you may need to write some
additional code to deal with

00:39:12.280 --> 00:39:16.410
those either between processes
or when reading them off of disk.

00:39:16.690 --> 00:39:21.380
And finally, we hit this all the time,
remember to test the

00:39:21.380 --> 00:39:22.900
result on both architects.

00:39:22.920 --> 00:39:26.040
We are providing,
or we will be providing,

00:39:26.040 --> 00:39:29.560
either both systems for a long time.

00:39:29.560 --> 00:39:33.100
And so you actually have to
run your app in both cases.

00:39:33.100 --> 00:39:36.580
It's quite possible that when you make
a change to run better on Intel-based

00:39:36.580 --> 00:39:40.640
systems that you inadvertently say,
swap all the time.

00:39:40.640 --> 00:39:43.280
And then you move back
to PowerPC and realize,

00:39:43.410 --> 00:39:45.780
well, actually swapping all the time
was wrong because the data

00:39:45.780 --> 00:39:46.900
was right in the first place.

00:39:46.900 --> 00:39:52.040
And so now you get your $4 billion
value on a PowerPC-based system instead.

00:39:52.100 --> 00:39:52.530
So.

00:39:52.920 --> 00:39:54.040
So that's the first thing.

00:39:54.040 --> 00:39:56.760
The second thing is that you
can actually do some more work.

00:39:56.760 --> 00:39:58.520
So you can do some more work on your own.

00:39:58.520 --> 00:40:00.160
You can do some more work on your own.

00:40:00.160 --> 00:40:02.050
And then you can do some
more work on your own.

00:40:02.060 --> 00:40:04.350
So that's the first thing.

00:40:04.790 --> 00:40:08.320
So more information throughout
the rest of the week.

00:40:08.550 --> 00:40:09.770
We have documentation.

00:40:09.780 --> 00:40:10.820
This says sample code.

00:40:10.820 --> 00:40:14.200
I'm not sure how much, if any,
sample code we have specifically

00:40:14.200 --> 00:40:16.330
dealing with this transition online yet.

00:40:16.430 --> 00:40:17.940
But I presume we'll have some soon.

00:40:17.940 --> 00:40:21.160
We have other resources at that page.

00:40:21.160 --> 00:40:24.070
We have a few other related sessions
that I really do want to call out,

00:40:24.070 --> 00:40:28.060
because these are really important if
you're thinking-- as you're working

00:40:28.060 --> 00:40:29.700
on transitioning to this platform.

00:40:29.790 --> 00:40:31.920
So first, moving to GCC 4.

00:40:32.020 --> 00:40:34.300
If you aren't currently
building with GCC 4,

00:40:34.300 --> 00:40:38.010
there's a session tomorrow at 5:00
that will be incredibly helpful.

00:40:38.030 --> 00:40:39.560
I strongly suggest going.

00:40:39.700 --> 00:40:42.330
It's a wonderful compiler,
but there are some changes that you

00:40:42.460 --> 00:40:44.500
may have to make as you move to it.

00:40:44.900 --> 00:40:48.010
Code with Apple's Image and
Signal Processing APIs for

00:40:48.020 --> 00:40:49.530
Maximum Performance.

00:40:49.560 --> 00:40:51.420
I don't know how they got that
many letters in their title.

00:40:51.420 --> 00:40:57.920
But this is a session on Friday that's
going to talk about all kinds

00:40:58.020 --> 00:41:01.920
of performance-related issues,
but one of them is migrating

00:41:01.920 --> 00:41:05.700
AltaVec code to SSE,
SSE2, and SSE3.

00:41:05.700 --> 00:41:08.180
And if you have AltaVec
code in your products today,

00:41:08.180 --> 00:41:10.140
then that'll be very, very helpful.

00:41:10.600 --> 00:41:11.490
Swimming with Shark.

00:41:11.530 --> 00:41:14.960
Shark runs great for us on
our Intel-based systems.

00:41:14.960 --> 00:41:17.660
If you go to the session,
then hopefully you'll get to

00:41:17.660 --> 00:41:19.200
see what it's like on there.

00:41:19.200 --> 00:41:23.740
And finally, our Universal Binary Lab,
which is downstairs on the first floor,

00:41:23.740 --> 00:41:25.240
which is going to be open all week.

00:41:25.300 --> 00:41:26.900
I believe it's open
until midnight tonight.

00:41:26.900 --> 00:41:30.270
This is a great opportunity
for you to bring your code by,

00:41:30.270 --> 00:41:34.360
and a lot of us are there helping
people move their applications.

00:41:34.360 --> 00:41:38.940
And it's been just wonderful so far to
see all kinds of people come by and say,

00:41:38.940 --> 00:41:42.650
Hey, you know, in 15 minutes... or half
an hour or an hour or so,

00:41:42.680 --> 00:41:43.940
then I was able to get
everything running.

00:41:43.980 --> 00:41:46.300
So hopefully you'll get
a chance to do the same.
WEBVTT

00:00:01.530 --> 00:00:04.040
Good morning.

00:00:04.050 --> 00:00:09.900
Welcome to the weather in England.

00:00:09.900 --> 00:00:11.160
My name is Malcolm Crawford.

00:00:11.160 --> 00:00:13.860
I'm a technical writer at Apple.

00:00:13.920 --> 00:00:16.680
And this morning we're going
to talk about bindings.

00:00:17.250 --> 00:00:20.720
Can I just do a level check quickly?

00:00:20.720 --> 00:00:20.720
Can everybody hear me in the back?

00:00:20.860 --> 00:00:23.740
"Can you raise a hand if
you can hear me at the back?

00:00:23.830 --> 00:00:24.870
Good, excellent.

00:00:24.980 --> 00:00:28.800
Today is not a hands-on session,
it's going to be a hands-up session.

00:00:28.800 --> 00:00:31.120
I want to check to see
how everybody's doing.

00:00:31.370 --> 00:00:34.550
Can everybody who's got
a hand raise a hand?"

00:00:35.660 --> 00:00:36.500
Excellent.

00:00:36.500 --> 00:00:36.940
A few missing.

00:00:37.050 --> 00:00:37.340
Shame.

00:00:37.340 --> 00:00:39.560
Sorry.

00:00:39.560 --> 00:00:42.320
So, what are we going to do today?

00:00:43.050 --> 00:00:47.570
Roughly, we're going to talk about
what are Cocoa bindings,

00:00:47.700 --> 00:00:51.270
what's a problem they solve,
and in particular,

00:00:51.270 --> 00:00:54.460
a slightly different tack on things.

00:00:54.460 --> 00:00:58.270
We're going to look to see how do
bindings actually work underneath.

00:00:58.450 --> 00:01:01.130
Can we see another
hand-raising opportunity here?

00:01:01.200 --> 00:01:03.920
Who's actually used
Cocoa bindings already?

00:01:05.500 --> 00:01:09.110
and keep your hands raised if
you're still mystified by them.

00:01:12.170 --> 00:01:15.570
Okay, so what we want to try to do this
morning is engage in some sort

00:01:15.570 --> 00:01:17.680
of a demystification process.

00:01:17.970 --> 00:01:23.460
So what I'm hoping is that if everybody
understands how bindings work,

00:01:23.460 --> 00:01:28.900
and in particular sees that there's no
magic involved in how bindings work,

00:01:29.050 --> 00:01:33.210
then there'll be somewhat
less of a mystery.

00:01:33.210 --> 00:01:33.210
So,

00:01:33.950 --> 00:01:36.010
We'll see how they work and
then we'll also take a quick

00:01:36.090 --> 00:01:40.520
nod at what are controllers and
what are value transformers.

00:01:40.580 --> 00:01:44.370
So, what we'll learn is first of
all how to establish bindings,

00:01:44.370 --> 00:01:46.200
that's a word I'm going
to come back to later,

00:01:46.200 --> 00:01:49.770
establish both in Interface
Builder and in code.

00:01:49.850 --> 00:01:51.390
We'll also look at the
underlying technologies.

00:01:51.400 --> 00:01:53.270
There are three main
underlying technologies:

00:01:53.390 --> 00:01:57.190
key value binding, key value coding,
and key value observing.

00:01:57.390 --> 00:01:59.680
In order to illustrate how
bindings actually work,

00:01:59.860 --> 00:02:04.280
we'll go through the principles
of how you would actually go about

00:02:04.280 --> 00:02:07.090
implementing a bindings-enabled view.

00:02:07.380 --> 00:02:08.800
We won't actually look at it in detail.

00:02:08.800 --> 00:02:11.440
There is some sample code that
will be available afterwards for

00:02:11.470 --> 00:02:13.470
you to have a look at in detail,
but we're not going to

00:02:13.470 --> 00:02:14.600
go through the details.

00:02:14.600 --> 00:02:20.110
We're just going to
look at the principles.

00:02:20.110 --> 00:02:26.480
We'll have a little look
at the role of controllers,

00:02:26.480 --> 00:02:26.750
and then we'll look
at value transformers.

00:02:26.750 --> 00:02:26.750
To address the first question, though,

00:02:27.380 --> 00:02:29.600
What are Cocoa Bindings?

00:02:29.600 --> 00:02:38.520
For those who are still mystified,
the simplest way of describing bindings

00:02:38.520 --> 00:02:44.760
is as a set of technologies that
keep models and views synchronized.

00:02:47.050 --> 00:02:48.750
Is anybody still mystified by that?

00:02:48.750 --> 00:02:52.270
I was trying to see if I could find any
shorter number of words to describe it,

00:02:52.580 --> 00:02:57.390
but in principle, all you've got is some
sort of view widget,

00:02:57.420 --> 00:03:00.800
some sort of model or
data-bearing object,

00:03:00.860 --> 00:03:05.000
and values in both of them,
and you want to keep them synchronized.

00:03:05.030 --> 00:03:07.000
That's all bindings is about.

00:03:07.020 --> 00:03:10.000
So I hope as a concept,
that's very straightforward.

00:03:10.000 --> 00:03:13.000
Quick tangent on this
one while we're here.

00:03:13.140 --> 00:03:18.910
Notice that I am saying models
and views should be kept in sync.

00:03:19.000 --> 00:03:22.270
There is a temptation, I notice,
for some people to try to keep model

00:03:22.330 --> 00:03:26.740
objects in sync with each other or
to bind two view objects together.

00:03:27.420 --> 00:03:28.720
Please don't do that.

00:03:29.060 --> 00:03:30.000
That's not the way that it's designed.

00:03:30.000 --> 00:03:32.980
Things won't work as you
expect if you do that.

00:03:33.000 --> 00:03:36.990
So that may address one particular
issue that some people are having.

00:03:37.000 --> 00:03:39.860
So what problem is it
then that bindings serve?

00:03:40.000 --> 00:03:41.390
solve.

00:03:43.330 --> 00:03:48.000
Imagine a very, very simple application.

00:03:48.040 --> 00:03:51.240
We've got a window on screen
that has two UI widgets,

00:03:51.240 --> 00:03:54.270
a text field and a slider.

00:03:54.500 --> 00:03:59.530
Somewhere floating around we have a
data object that has a single value,

00:03:59.530 --> 00:04:00.790
a number.

00:04:01.180 --> 00:04:04.900
We want to keep the value
of the data object's number,

00:04:04.910 --> 00:04:09.860
the value of the slider represents,
and the value of the text field in sync.

00:04:10.470 --> 00:04:13.400
Typically,
that's just--can anybody-- if you're

00:04:13.510 --> 00:04:17.860
just writing normal Cocoa code,
can everybody figure-- who would be

00:04:17.870 --> 00:04:22.400
absolutely blown away by trying to
implement this using normal Cocoa?

00:04:22.770 --> 00:04:24.360
Has this left anybody behind?

00:04:24.430 --> 00:04:28.190
Can anybody not figure out how they
would do this in normal Cocoa code?

00:04:28.190 --> 00:04:30.010
I'm going to show it afterwards.

00:04:30.010 --> 00:04:30.440
Okay.

00:04:30.460 --> 00:04:33.100
So, trivial,
you'd have a whole load of outlets,

00:04:33.190 --> 00:04:36.610
or a couple of outlets at least,
some update code, some glue code.

00:04:36.760 --> 00:04:39.930
It would be trivial to do,
but it's really tedious work.

00:04:40.780 --> 00:04:42.380
It's not stuff that you want
to have to do every day.

00:04:42.630 --> 00:04:45.960
And on a simple user interface like this,
it's easy enough.

00:04:46.050 --> 00:04:47.720
But when you have 17
different text fields,

00:04:47.800 --> 00:04:54.400
when you have three table views,
when you have your own custom view,

00:04:54.400 --> 00:04:59.000
an outline view, and all the rest of it,
suddenly it becomes a much bigger

00:04:59.000 --> 00:04:59.000
exercise and a lot more complicated.

00:04:59.670 --> 00:05:04.560
So, we'll illustrate in a moment
how to go through that.

00:05:04.560 --> 00:05:10.350
The other aspect of bind--the other
bonus that you get with bindings

00:05:10.350 --> 00:05:14.130
though is user interface friendliness.

00:05:14.330 --> 00:05:19.950
One of the other things that you may
want to do when putting together a full

00:05:19.950 --> 00:05:19.950
featured application is ensure that

00:05:20.650 --> 00:05:27.020
The users presented with a
meaningful interface for all

00:05:27.020 --> 00:05:27.020
values of all of your model data.

00:05:27.810 --> 00:05:31.060
It may be helpful if you have a nil
value where the user is required to

00:05:31.060 --> 00:05:34.070
actually enter a value if you place
a placeholder into a text field,

00:05:34.100 --> 00:05:37.300
for example,
to tell them that's what's required.

00:05:37.460 --> 00:05:40.790
If they've selected multiple
values that are all supposed to be

00:05:40.790 --> 00:05:43.960
presented into the same text field,
it may be useful to present them

00:05:44.100 --> 00:05:46.250
with a multiple value marker.

00:05:46.650 --> 00:05:50.570
All of these things are possible
using traditional Cocoa development,

00:05:50.570 --> 00:05:53.080
but they're fiddly.

00:05:53.120 --> 00:05:54.940
With bindings,
in addition to just keeping

00:05:54.940 --> 00:05:58.310
everything synchronized,
you get this behavior for free.

00:06:00.230 --> 00:06:04.310
So, I'll now do a quick demo.

00:06:04.590 --> 00:06:07.820
So, it's going to be one of the most
trivial demos that you'll see ever,

00:06:07.820 --> 00:06:10.850
I think,
at this conference of showing three

00:06:10.920 --> 00:06:17.100
different approaches to keeping the
slider and the text field in sync.

00:06:17.100 --> 00:06:24.370
For the data object,
we're just going to keep things very

00:06:24.370 --> 00:06:24.410
simple and use a mutable dictionary.

00:06:24.410 --> 00:06:24.410
So,

00:06:30.370 --> 00:06:38.170
To start off with,
a very simple Cocoa application.

00:06:38.420 --> 00:06:44.570
imagine to be named and all
I'm going to do is to add

00:06:47.100 --> 00:06:54.300
[Transcript missing]

00:06:54.560 --> 00:06:58.740
Some of you, who here was ever involved
in the Next community?

00:06:58.740 --> 00:06:59.500
Anybody?

00:06:59.500 --> 00:07:00.280
Wow.

00:07:00.290 --> 00:07:01.310
Who here actually saw Mr.

00:07:01.310 --> 00:07:03.990
Jobs demonstrate this
a decade and a bit ago?

00:07:04.050 --> 00:07:05.430
Okay, so some people,
for some people this is

00:07:05.430 --> 00:07:06.000
going to be familiar.

00:07:06.000 --> 00:07:10.090
So imagine yourselves in pretty much
this exact location displaced by about

00:07:10.090 --> 00:07:12.720
300 yards about a dozen years or so ago.

00:07:12.860 --> 00:07:18.360
This is the demo that
Steve Jobs gave back then,

00:07:18.360 --> 00:07:19.520
and you can connect these
two widgets together.

00:07:24.090 --> 00:07:27.700
with take value, float value from,
connect them together.

00:07:27.720 --> 00:07:31.500
Ooh.

00:07:31.500 --> 00:07:36.220
Now, of course, when he did it,
he got a huge round of applause, but...

00:07:39.450 --> 00:07:43.740
That was because that was a big
deal back a dozen or so years ago.

00:07:43.740 --> 00:07:46.400
Nobody else was doing this.

00:07:46.450 --> 00:07:47.840
I haven't even compiled anything.

00:07:47.840 --> 00:07:50.400
I haven't got any sleeves
to have any code up.

00:07:50.400 --> 00:07:54.240
So this was actually
quite magical back then.

00:07:55.660 --> 00:07:58.210
Nowadays,
that's of course fatally flawed.

00:07:58.330 --> 00:08:01.510
The two widgets are kept in sync,
but the data object

00:08:01.510 --> 00:08:02.520
doesn't appear anywhere.

00:08:02.630 --> 00:08:04.800
If we actually want to record the
value that's being set anywhere,

00:08:04.800 --> 00:08:09.990
we've still got to reach
out into the user interface.

00:08:09.990 --> 00:08:09.990
So, today,

00:08:14.860 --> 00:08:20.550
We will draft an application
that looks rather more like this,

00:08:20.550 --> 00:08:20.550
where we have

00:08:24.120 --> 00:08:31.050
An interface with text field and slider
connected up to a controller object,

00:08:31.070 --> 00:08:38.140
which manages then the underlying
data object and action messages.

00:08:39.100 --> 00:08:42.760
So we've got target action set up for
the text field and for the slider,

00:08:42.760 --> 00:08:45.710
and connections outlets

00:08:45.950 --> 00:08:49.150
from the controller going
out into the user interface.

00:08:49.150 --> 00:08:50.940
Anybody mystified by that?

00:08:50.960 --> 00:08:52.490
Straightforward.

00:08:55.580 --> 00:09:00.530
In the Controller object,
we have two outlets, our data object,

00:09:00.530 --> 00:09:05.570
model object, an action method,
and some accessor methods.

00:09:05.570 --> 00:09:09.660
And the action method,
very straightforward.

00:09:09.660 --> 00:09:19.420
We get the object value from the
sender and update everything.

00:09:19.420 --> 00:09:22.410
And that works.

00:09:22.410 --> 00:09:23.590
Hooray.

00:09:23.590 --> 00:09:23.590
Okay.

00:09:28.370 --> 00:09:35.240
That's a trivial example, but as I said,
think about this then with a number,

00:09:35.460 --> 00:09:39.020
a large number of different text fields,
sliders, what have you.

00:09:39.100 --> 00:09:42.430
Certainly the number of outlets
that you have to deal with,

00:09:42.550 --> 00:09:45.720
the number of code,
the amount of code that you have

00:09:45.870 --> 00:09:49.520
to write to update everything
and so on becomes much more,

00:09:49.670 --> 00:09:51.590
um, becomes much more of it.

00:09:51.590 --> 00:09:54.730
With bindings, instead,
what we can do is say,

00:09:54.730 --> 00:09:56.680
let's get rid of the outlets.

00:09:56.730 --> 00:09:57.730
I'm not bothered

00:09:59.020 --> 00:10:10.260
about the update method,
the action method.

00:10:10.260 --> 00:10:10.260
So that's code I can delete.

00:10:10.260 --> 00:10:10.260
I'm going to go back to

00:10:13.500 --> 00:10:23.000
[Transcript missing]

00:10:23.710 --> 00:10:27.050
There's no target in action
for the user interface widgets.

00:10:27.340 --> 00:10:30.600
What I want to do -- now,
bear with me for this one at the moment.

00:10:30.600 --> 00:10:33.740
I'm not going to say very much about
controllers during this presentation.

00:10:33.740 --> 00:10:35.440
I'm going to leave that
to the next presentation.

00:10:35.600 --> 00:10:41.580
But a controller here is
serving as an abstraction for

00:10:41.580 --> 00:10:41.580
the underlying data object.

00:10:41.580 --> 00:10:41.580
Just trust me on this one.

00:10:43.060 --> 00:10:46.370
I'm going to add a controller
object here and say that the

00:10:46.370 --> 00:10:49.700
object that it represents,
its content object,

00:10:49.830 --> 00:10:57.390
is bound to the controller's data object.

00:11:00.040 --> 00:11:05.720
The value of this slider
is bound to the number.

00:11:07.330 --> 00:11:12.270
of the underlying data object,
so the underlying mutable dictionary,

00:11:12.270 --> 00:11:15.130
as is the text field.

00:11:19.990 --> 00:11:23.590
If I build and run the application now,
first thing to note,

00:11:23.590 --> 00:11:29.120
if you're watching very carefully,
when I ran the first application,

00:11:29.120 --> 00:11:34.170
the number field was blank, even though

00:11:35.250 --> 00:11:40.600
There was actually a value for
number in the mutable dictionary.

00:11:40.660 --> 00:11:41.900
It didn't appear.

00:11:42.050 --> 00:11:45.590
Now, as I've used bindings,
that number's appeared automatically.

00:11:46.330 --> 00:11:49.380
And the two values are still
kept in sync appropriately,

00:11:49.570 --> 00:11:52.400
this time though with no glue code.

00:11:57.760 --> 00:12:02.500
So that's the simplest example I could
come up with for how bindings work.

00:12:02.560 --> 00:12:04.860
So let's go back and see what we did.

00:12:13.640 --> 00:12:16.760
One of the things I found as
I was putting this presentation

00:12:16.780 --> 00:12:19.600
together was there's a lot
of talk now about unit tests.

00:12:19.600 --> 00:12:23.600
We found out we've actually got unit
tests for bindings presentations.

00:12:23.600 --> 00:12:26.840
And it turns out that bindings
presentations cannot be given without

00:12:26.840 --> 00:12:28.590
a Model-View-Controller slide.

00:12:28.590 --> 00:12:34.230
So this is my Model-View-Controller
slide for the bindings demo

00:12:34.610 --> 00:12:36.960
to get through the test.

00:12:36.960 --> 00:12:37.590
Who's not familiar with the
Model-View-Controller design pattern?

00:12:38.550 --> 00:12:38.990
Excellent.

00:12:39.040 --> 00:12:41.000
I think that--ooh, one person.

00:12:41.000 --> 00:12:41.760
Okay.

00:12:41.880 --> 00:12:44.640
Not sure if that was a genuine
or somebody just exercising

00:12:44.640 --> 00:12:46.500
their rights to raise their hand.

00:12:46.770 --> 00:12:48.740
Okay, excellent.

00:12:49.110 --> 00:12:51.840
So it's a design pattern--I'll
skip through these then.

00:12:51.840 --> 00:12:56.610
The first example that I showed
was basically not an example.

00:12:56.950 --> 00:13:00.470
No ModelViewController design pattern,
simply connecting two UI widgets.

00:13:00.540 --> 00:13:05.920
This is what happens if you simply
bind two View objects together.

00:13:06.210 --> 00:13:12.060
So this is a reason for those
of you who've tried doing this,

00:13:12.060 --> 00:13:12.060
don't do that.

00:13:12.060 --> 00:13:12.060
You're leaving the
Model object out of it.

00:13:13.130 --> 00:13:16.610
Traditional Cocoa binding,
we do have a model, we've got a model,

00:13:16.720 --> 00:13:19.530
we've got a controller class,
a whole load of outlets,

00:13:19.720 --> 00:13:22.540
and in a simple case like
the one I just demonstrated,

00:13:22.550 --> 00:13:30.050
easy enough, more complicated user
interfaces gets more difficult.

00:13:30.050 --> 00:13:30.050
With

00:13:31.380 --> 00:13:37.370
Cocoa bindings we use an
abstraction in the NSController

00:13:38.640 --> 00:13:39.420
I'm lying a little bit.

00:13:39.590 --> 00:13:40.200
No outlets.

00:13:40.320 --> 00:13:42.700
Often there may be still
reasons why you have outlets,

00:13:42.700 --> 00:13:45.250
but in the example I just showed,
there was no need for them.

00:13:45.500 --> 00:13:47.520
There's no target action,
although you can still use target

00:13:47.540 --> 00:13:48.800
action in your applications.

00:13:48.800 --> 00:13:51.570
There's no reason to completely
dispense with target action

00:13:51.670 --> 00:13:52.810
where it's appropriate.

00:13:52.860 --> 00:13:54.210
And there's no glue code.

00:13:56.020 --> 00:13:59.500
So, where bindings fits in
with ModelViewController,

00:13:59.500 --> 00:14:04.160
we've already had ModelViewController
supported by Cocoa up until now,

00:14:04.160 --> 00:14:05.720
so models are reusable.

00:14:06.010 --> 00:14:14.980
The classes that you're given
in the foundation framework,

00:14:14.980 --> 00:14:15.350
views are reusable, app kit classes,
and now controls are reusable.

00:14:16.570 --> 00:14:18.000
Oh, I'm sorry.

00:14:18.000 --> 00:14:22.110
So the controller that I illustrated
was the object controller.

00:14:22.230 --> 00:14:25.170
The one that you'll typically more
often see is the array controller.

00:14:25.420 --> 00:14:33.630
Again, we're not going to talk any more
about these during this presentation.

00:14:33.630 --> 00:14:35.820
Come to the next one to
hear more about these.

00:14:35.820 --> 00:14:35.820
And then there's a special controller
for managing user defaults as well.

00:14:37.060 --> 00:14:40.780
So that might beg the question then,
well, when do I have to do anything?

00:14:40.880 --> 00:14:42.250
If it's all this easy.

00:14:42.430 --> 00:14:43.290
Well, don't worry.

00:14:43.300 --> 00:14:47.220
There's still plenty of scope for
you to add value to your application.

00:14:47.280 --> 00:14:49.860
Clearly,
first thing when you're implementing

00:14:49.890 --> 00:14:51.070
your own business logic.

00:14:51.630 --> 00:14:57.150
You can implement your own model
classes that are rather more useful

00:14:57.230 --> 00:14:58.420
than just a mutable dictionary.

00:14:58.420 --> 00:15:00.640
So plenty of opportunity
there for you to add value.

00:15:00.640 --> 00:15:03.520
You may want to implement
your own custom views.

00:15:03.520 --> 00:15:06.380
Not every application is made
up of sliders and text fields.

00:15:06.380 --> 00:15:09.640
There may be reasons why you want
to subclass Apple's controllers.

00:15:09.640 --> 00:15:13.650
There may occasionally be reasons
why you need to establish bindings

00:15:13.650 --> 00:15:18.580
programmatically and various other
initialization stuff as well.

00:15:18.600 --> 00:15:19.500
So don't worry.

00:15:19.500 --> 00:15:22.520
There's still plenty of work that you're
able to do to another good living.

00:15:24.340 --> 00:15:27.250
So,
with that preamble then out of the way,

00:15:27.260 --> 00:15:31.580
let's turn back to the bindings
themselves and look in more detail at,

00:15:31.610 --> 00:15:34.090
well, first of all, what is a binding?

00:15:36.660 --> 00:15:39.960
Apologies for -- I'm going to
try just reading this definition.

00:15:39.980 --> 00:15:41.600
So I don't like reading
directly from slides,

00:15:41.600 --> 00:15:42.560
but I will in this case.

00:15:42.590 --> 00:15:51.270
A binding, I'd like to suggest,
is a collection of information that

00:15:51.320 --> 00:15:55.150
specifies what attribute of one object
should be kept synchronized with what

00:15:55.150 --> 00:15:55.150
property of another with what options.

00:15:56.620 --> 00:16:03.150
That's a longish sentence,
but conveys the basic idea.

00:16:03.650 --> 00:16:09.130
It simply says that a binding in the
example that we just showed had for

00:16:09.190 --> 00:16:16.360
a value of a text field can be kept
in sync with the number attribute

00:16:16.950 --> 00:16:19.740
or property of a mutable dictionary.

00:16:19.810 --> 00:16:23.630
It says keep this in sync with that.

00:16:23.690 --> 00:16:26.420
The options bit is tagged on at the
end because occasionally there may be

00:16:26.420 --> 00:16:29.760
transformations that you want to make
between the two or you may want to say,

00:16:29.760 --> 00:16:33.480
well, if that value doesn't exist,
show something different up here.

00:16:34.680 --> 00:16:36.970
But in essence,
a binding is simply saying,

00:16:36.970 --> 00:16:40.340
"I've got a widget over here,
a model object over here.

00:16:40.420 --> 00:16:44.010
Keep these two synchronized." And here,
the binding is basically the

00:16:44.010 --> 00:16:47.910
information that tells you how
to keep the two things in sync.

00:16:51.500 --> 00:16:55.820
One of the words that I stressed
earlier was "Bindings are established

00:16:56.260 --> 00:17:01.700
rather than created." And I put
on there "Think target action."

00:17:03.290 --> 00:17:06.990
How many people here-- another
hand-raising opportunity.

00:17:07.100 --> 00:17:11.630
How many people here were mystified
first time you used-- first time you

00:17:11.640 --> 00:17:14.780
used target action in Interface Builder?

00:17:15.890 --> 00:17:19.140
So when you do that "Controll-y Drag-y,"
I've got a widget-y thing over here,

00:17:19.140 --> 00:17:23.470
and then I can Control-click
in this funny gray line.

00:17:24.310 --> 00:17:27.200
So I'm pretty sure that certainly
in all the training that I did,

00:17:27.200 --> 00:17:28.860
most people ended up going, "What?

00:17:29.090 --> 00:17:30.980
What did I just do?"

00:17:31.700 --> 00:17:34.740
And then eventually,
after you got used to it for a while,

00:17:34.800 --> 00:17:38.190
you realized, "Oh, well,
if I look in the documentation," hint,

00:17:38.440 --> 00:17:42.180
If I look in the documentation,
I find that all these widgety

00:17:42.180 --> 00:17:44.630
things inherit from NSControl.

00:17:44.630 --> 00:17:49.270
And NSControl has two instance variables:
target and action.

00:17:49.920 --> 00:17:53.790
All I'm doing when I do that control
draggy clicky thing is actually

00:17:53.800 --> 00:17:56.710
setting those two instance variables.

00:17:57.170 --> 00:18:01.100
All I'm doing when I do that control
draggy clicky thing is actually

00:18:01.100 --> 00:18:04.020
setting those two instance variables.

00:18:09.690 --> 00:18:12.250
Who set up target and action in code?

00:18:12.410 --> 00:18:13.840
Anybody?

00:18:13.960 --> 00:18:17.670
So just send a set target or
set action message to a widget?

00:18:17.950 --> 00:18:21.430
Anybody feel that they
could not do it if asked?

00:18:21.910 --> 00:18:23.600
Okay, it's easy.

00:18:23.870 --> 00:18:25.800
There's no magic there.

00:18:25.930 --> 00:18:28.930
There's simply instance variables
in that control that record the

00:18:29.020 --> 00:18:32.610
information that you're setting when
you do that control draggy thing.

00:18:32.960 --> 00:18:36.500
That's basically an analogous
thing that's happening in bindings.

00:18:36.550 --> 00:18:39.490
You're specifying a
collection of information.

00:18:42.450 --> 00:18:44.990
To complicate things a little bit,
let's go on a tangent on the

00:18:45.030 --> 00:18:48.190
different -- there are two broadly
speaking two types of binding.

00:18:48.200 --> 00:18:52.920
Let's also just quickly go on -- mention
something about single value bindings

00:18:52.920 --> 00:18:57.690
and the example that I just gave,
I just bound the value of a text field.

00:18:57.690 --> 00:19:01.820
You're not constrained just
to using a binding for the

00:19:01.830 --> 00:19:03.970
actual value that's displayed.

00:19:04.230 --> 00:19:06.800
There may be other attributes for
which there are bindings as well.

00:19:06.830 --> 00:19:08.190
We could have bound the color.

00:19:08.190 --> 00:19:09.860
We could have bound the font size.

00:19:09.910 --> 00:19:13.330
We could have bound whether
or not the field is enabled.

00:19:13.550 --> 00:19:17.760
So all of these things are attributes
of the text field that could be bound,

00:19:17.760 --> 00:19:21.690
which is going to concentrate on the
most simple and the most obvious one.

00:19:22.060 --> 00:19:23.740
That's a single value binding.

00:19:23.890 --> 00:19:28.560
There may be occasions where you
have multiple value bindings.

00:19:28.560 --> 00:19:32.230
You may have an attribute of a text field
or an attribute of some other object

00:19:32.570 --> 00:19:38.150
whose value depends on the concatenation
or combination of other values.

00:19:38.300 --> 00:19:41.370
So apologies for the
denseness of the next slide,

00:19:41.410 --> 00:19:43.900
but again, it's reasonably simple.

00:19:44.050 --> 00:19:47.980
Basically, there are three different
types of multivalued bindings:

00:19:48.010 --> 00:19:51.610
pattern value bindings,
value with pattern bindings,

00:19:51.640 --> 00:19:54.660
multiple Boolean bindings,
and multiple value argument bindings.

00:19:54.840 --> 00:19:59.640
So the first one,
value with pattern bindings,

00:19:59.640 --> 00:20:05.350
the canonical example of that
is hash out of hash in a text

00:20:05.350 --> 00:20:08.410
field where you want to build

00:20:08.560 --> 00:20:11.440
"Controller" is a text string
that tells you how many objects

00:20:11.440 --> 00:20:15.210
you've selected from a table view.

00:20:16.180 --> 00:20:20.460
The actual string value is built
from a combination of the number

00:20:20.460 --> 00:20:24.260
of objects selected and the number
of objects in the table view.

00:20:24.380 --> 00:20:29.540
So a binding that's
dependent on multiple values.

00:20:29.860 --> 00:20:33.570
Multiple Boolean value, we may have

00:20:33.770 --> 00:20:36.270
"An enabled binding
of a button that says,

00:20:36.460 --> 00:20:43.680
'This button is only able to be enabled
if...' I've got a selection in here,

00:20:43.680 --> 00:20:43.680
I've got a selection in here,
and this value's null.

00:20:44.920 --> 00:20:47.180
So all of those things,
oh and then sorry,

00:20:47.180 --> 00:20:51.520
multiple value argument bindings,
I'll defer then to Ron's presentation,

00:20:51.520 --> 00:20:55.350
the next bindings presentation,
he'll talk more about those.

00:20:56.070 --> 00:20:59.990
All of these are things that typically,
if you're writing your own code,

00:20:59.990 --> 00:21:01.320
are difficult to do.

00:21:01.320 --> 00:21:05.480
Well, actually not that difficult,
just tedious again to do.

00:21:05.650 --> 00:21:09.430
Bindings makes it very
straightforward with no code involved.

00:21:13.170 --> 00:21:17.820
I mentioned when we were talking
about the definition of a binding,

00:21:17.850 --> 00:21:23.480
keeping this widget value attribute in
sync with this particular data property,

00:21:23.530 --> 00:21:25.680
possibly with some options.

00:21:25.680 --> 00:21:29.080
There's a number of options that
we might set for a binding as well.

00:21:29.080 --> 00:21:32.280
One of them is value transfer,
which we'll talk about later.

00:21:32.280 --> 00:21:36.160
Selection markers allow you to do the
user interface friendliness to say,

00:21:36.160 --> 00:21:39.500
okay, well, if I don't have a value for
this particular attribute,

00:21:39.540 --> 00:21:42.990
what do I want to display
to the user and so on.

00:21:43.180 --> 00:21:45.270
And then there may be various
other parameters that are

00:21:45.450 --> 00:21:47.520
available for a particular binding.

00:21:47.520 --> 00:21:49.370
For those,
read the relevant documentation.

00:21:49.440 --> 00:21:52.360
So there's a huge number of
different options that may be set

00:21:52.360 --> 00:21:54.950
in various different circumstances.

00:21:56.300 --> 00:22:01.180
So, now that we know what
a binding actually is,

00:22:01.200 --> 00:22:03.140
how do they work?

00:22:03.850 --> 00:22:06.780
What I want to do here is
go through what I'm -- well,

00:22:06.780 --> 00:22:08.810
actually,
I think I need to give credit to

00:22:08.810 --> 00:22:13.140
somebody else -- go through a sort of
progressive JPEG-style introduction.

00:22:13.280 --> 00:22:15.850
So what I mean by that is,
where I think a number of people

00:22:15.850 --> 00:22:18.140
have found problems with bindings is
it's actually a number of different

00:22:18.140 --> 00:22:20.500
technologies and aspects of those
technologies that you need to

00:22:20.540 --> 00:22:27.140
understand altogether in order to be
able to figure out what's going on.

00:22:27.140 --> 00:22:30.890
So we've already said there are going
to be three different technologies

00:22:30.890 --> 00:22:33.130
that are required to support bindings.

00:22:33.200 --> 00:22:37.040
I could go into detail about
one of those technologies,

00:22:37.110 --> 00:22:39.310
then another, then another, and so on.

00:22:39.530 --> 00:22:42.780
But as we go through that,
all that's going to mean is that, "Okay,

00:22:42.780 --> 00:22:44.900
well, I understand what this
technology means in isolation,

00:22:44.900 --> 00:22:51.300
but I've got no idea how all of this
fits in together." So imagine a sort

00:22:51.300 --> 00:22:56.800
of progressive JPEG instead where,
when you first start

00:22:56.810 --> 00:22:56.940
downloading a picture,
for example, you see this big picture.

00:22:57.050 --> 00:23:00.720
"There's got some sort of bluish
stuff over the top and some greenish,

00:23:00.720 --> 00:23:05.510
sort of greeny blobby stuff and
maybe some browny bits in the middle.

00:23:07.140 --> 00:23:10.080
You don't know, well you may guess,
but you don't know necessarily that

00:23:10.080 --> 00:23:11.800
that's actually going to be sky,
that's going to be grass,

00:23:11.800 --> 00:23:14.160
and this is grandma's house in
the middle with a sort of smoke

00:23:14.160 --> 00:23:16.000
coming out of it and what have you.

00:23:16.000 --> 00:23:17.990
So what I'm going to try to do is say,
well okay,

00:23:17.990 --> 00:23:21.240
let's at least paint this broad
brush picture and then go into

00:23:21.290 --> 00:23:23.510
details and figure out eventually,
okay,

00:23:23.510 --> 00:23:25.300
that's grandma's house in the middle.

00:23:25.800 --> 00:23:29.570
So we're going to actually
see some of the same slides,

00:23:29.930 --> 00:23:35.210
some of the same concepts revisited on
several occasions as we go through this,

00:23:35.530 --> 00:23:38.490
but in increasing amounts
of detail as we go through.

00:23:41.280 --> 00:23:45.020
So, first of all then, well actually,
well first of all we'll just mention

00:23:45.130 --> 00:23:47.710
a quick word about design principles,
what lies behind this,

00:23:47.710 --> 00:23:49.670
but then we'll talk about,
well how do you actually

00:23:49.670 --> 00:23:50.700
establish bindings?

00:23:50.730 --> 00:23:52.950
What are the technologies
that underlie bindings?

00:23:52.970 --> 00:23:55.730
So how does this thing actually work?

00:23:55.920 --> 00:24:00.020
How are updates propagated
through the system?

00:24:00.100 --> 00:24:05.960
So if you make an edit to something in
either the user interface or in a model,

00:24:05.960 --> 00:24:05.960
to a model value,
how does that change propagated?

00:24:06.200 --> 00:24:10.900
Well then look and see what are
the different parts of a binding.

00:24:10.900 --> 00:24:17.130
So decompose the different aspects of it.

00:24:17.160 --> 00:24:20.170
And then finally, we'll just see, well,
if you were wanting to write

00:24:20.170 --> 00:24:20.170
your own bindings-enabled view,
what would you have to do?

00:24:22.320 --> 00:24:24.230
First, design principles.

00:24:24.510 --> 00:24:27.410
To give a lead into the
technologies that are involved,

00:24:27.410 --> 00:24:30.470
notice the key value parts
to those three technologies,

00:24:30.470 --> 00:24:33.200
key value coding, observing, and binding.

00:24:34.110 --> 00:24:36.940
The main requirement for all of these
technologies is that they should work

00:24:36.940 --> 00:24:39.750
with the code that you already have.

00:24:39.910 --> 00:24:44.960
We don't want to require you to
have to write special-- certainly

00:24:44.960 --> 00:24:48.410
if you're on model classes,
for example,

00:24:48.410 --> 00:24:55.440
we don't want to require you to
write particular accessor methods.

00:24:55.440 --> 00:25:04.440
We don't want our classes to have to know
what your custom methods are and so on.

00:25:04.440 --> 00:25:05.590
We want this to work
with any of your classes.

00:25:05.900 --> 00:25:11.060
So key value coding gives us an
abstraction that facilitates this.

00:25:11.090 --> 00:25:13.540
We'll come back to key
value coding in a moment.

00:25:16.210 --> 00:25:19.080
Turninging then to how do you
actually establish bindings,

00:25:19.130 --> 00:25:20.600
well, there are two ways.

00:25:20.600 --> 00:25:22.940
We just saw one way,
and that was most of you-- or it looked

00:25:22.940 --> 00:25:24.600
like most of you already tried this.

00:25:24.630 --> 00:25:29.090
You can establish bindings
in Interface Builder.

00:25:29.090 --> 00:25:29.090
You can also do it in code.

00:25:30.390 --> 00:25:38.040
In both cases, it comes down to using the
key value binding protocol.

00:25:38.490 --> 00:25:42.160
So, quick hint as to where we're going.

00:25:42.280 --> 00:25:44.470
In both cases,

00:25:45.120 --> 00:25:47.400
We're using the Key-Value
Binding Protocol.

00:25:47.430 --> 00:25:49.600
So,
what is the Key-Value Binding Protocol?

00:25:49.780 --> 00:25:53.310
It consists of a few methods.

00:25:53.500 --> 00:25:57.770
The first one,
bind to object with key path options,

00:25:57.770 --> 00:26:00.820
is the one that's actually
used to establish a binding.

00:26:03.170 --> 00:26:08.630
In some cases, you may actually want
to remove a binding,

00:26:08.630 --> 00:26:08.630
in which case you can
use the unbind method.

00:26:10.420 --> 00:26:14.060
If you're using Interface
Builder and you want to create a

00:26:14.060 --> 00:26:18.340
bindings-enabled view of your own,
in order to advertise to

00:26:18.390 --> 00:26:21.940
Interface Builder what
bindings there are available,

00:26:21.940 --> 00:26:28.000
you can use the "exposeBinding"
and "exposeToBindings" method.

00:26:28.000 --> 00:26:31.800
And in order to make sure that
Interface Builder only allows the

00:26:31.800 --> 00:26:31.800
right sort of thing to be hooked up,
you can use value class binding.

00:26:33.370 --> 00:26:36.080
Most of these,
and there aren't very many to begin with,

00:26:36.080 --> 00:26:41.170
as far as we're concerned as beginners,
are pretty much irrelevant.

00:26:43.170 --> 00:26:46.700
The only one we're really
interested in is this one:

00:26:46.730 --> 00:26:48.520
establishing a binding.

00:26:48.640 --> 00:26:53.010
So that's one method,
not an awful lot to it.

00:26:54.010 --> 00:26:56.620
To see how it works,
I want to go through a slightly

00:26:56.670 --> 00:26:58.220
more complicated example.

00:26:58.340 --> 00:27:02.600
So, this is going to require a little
bit of talking through to begin with.

00:27:04.370 --> 00:27:10.140
Imagine a scenario where you've
written a drawing application.

00:27:10.140 --> 00:27:13.360
In your application,
you have a single graphic object

00:27:14.040 --> 00:27:16.710
that is able to have a shadow.

00:27:17.900 --> 00:27:22.560
In the diagram, the graphic object is
represented by the blue circle,

00:27:22.720 --> 00:27:25.300
the shadow by the gray
circle that lies behind it.

00:27:25.450 --> 00:27:31.270
In your code,
you may have an underlying graphic

00:27:31.320 --> 00:27:34.800
object with two instance variables.

00:27:35.070 --> 00:27:38.790
What you might want to do is to write
some sort of an inspector panel.

00:27:41.000 --> 00:27:54.000
[Transcript missing]

00:27:55.130 --> 00:28:00.760
There are two ways you can do this with
straightforward text fields or you may

00:28:00.760 --> 00:28:05.230
want to create your own custom joystick.

00:28:05.550 --> 00:28:15.540
class.

00:28:15.540 --> 00:28:15.540
So the view, the top,
in the top part of the shadow inspector,

00:28:15.540 --> 00:28:15.540
I'm going to call

00:28:16.790 --> 00:28:20.960
So, in your application,
you may have a graphic

00:28:21.290 --> 00:28:23.800
object that represents

00:28:24.210 --> 00:28:29.410
The circle with shadow offset and
shadow angle instance variables.

00:28:30.150 --> 00:28:34.360
Followinging on from or following
on from the example that just

00:28:34.370 --> 00:28:38.220
the demo gave at the outset,
we may have a controller object

00:28:38.410 --> 00:28:43.340
of some description that manages
that to which we can make bindings.

00:28:43.340 --> 00:28:49.490
The bindings that we want to make
in this case are going to be four.

00:28:49.490 --> 00:28:49.490
The first one

00:28:50.370 --> 00:28:53.100
I'm sorry, there's only five.

00:28:53.180 --> 00:28:58.550
The first one is actually binding
the content of the controller.

00:28:58.980 --> 00:29:13.920
"We want to bind the value of the
offset text field to the shadow offset

00:29:14.360 --> 00:29:19.010
of the underlying graphic object.

00:29:19.010 --> 00:29:19.020
We want to bind the value of the object
to the shadow offset of the underlying

00:29:21.490 --> 00:29:27.190
"The offset of our inspector
of the joystick thing to the

00:29:27.380 --> 00:29:32.680
same value for the angle,
we're going to do something a

00:29:32.730 --> 00:29:35.990
little bit more complicated.

00:29:38.060 --> 00:29:45.570
We're going to bind the value of the
angle text field to the underlying

00:29:45.840 --> 00:29:52.040
shadow offset of that graphic object,
but with a little bit of a difference.

00:29:52.100 --> 00:29:53.990
This time it's going to go
through a value transformer.

00:29:54.000 --> 00:29:56.420
If you look carefully,
the value in the text field and the

00:29:56.440 --> 00:29:59.990
value of the shadow angle as represented
in the graphic object are different.

00:30:00.000 --> 00:30:05.470
Let's imagine that, for whatever reason,
we're representing the angle in

00:30:05.470 --> 00:30:07.970
our graphic object in radians.

00:30:08.030 --> 00:30:11.900
On screen, we want to represent it
to the user in degrees.

00:30:11.900 --> 00:30:16.390
So we'll add a value transformer
to this to make it easier.

00:30:17.980 --> 00:30:23.080
We can do a similar thing for
the angle in the joystick.

00:30:23.280 --> 00:30:26.610
So we're going to bind the angle
attribute of the joystick to

00:30:26.610 --> 00:30:29.670
the selection's shadow offset.

00:30:29.680 --> 00:30:34.780
And again, imagine that the joystick
is using degrees natively.

00:30:34.870 --> 00:30:39.960
So it needs to transform the value
from the underlying graphic object,

00:30:40.050 --> 00:30:43.110
which is in radiance, to degrees.

00:30:43.120 --> 00:30:46.110
So we're going to apply a value
transformer to that as well.

00:30:46.800 --> 00:30:50.690
To begin with,
let's forget though about the joystick

00:30:50.700 --> 00:30:52.770
and concentrate on the more simple.

00:30:56.470 --> 00:31:02.090
task of just setting up the
bindings for the text field.

00:31:02.800 --> 00:31:05.690
So, how do we do this?

00:31:05.750 --> 00:31:13.230
Establishing a binding.

00:31:13.230 --> 00:31:16.580
We want to bind the value of that
angle text field to the shadow angle.

00:31:17.030 --> 00:31:21.510
of the graphic the way that we saw before
was to do that in Interface Builder.

00:31:26.800 --> 00:31:28.940
Straightforward enough-ish?

00:31:28.940 --> 00:31:29.780
Everybody with me on there?

00:31:29.850 --> 00:31:33.490
So we could simply inspect the
binding in Interface Builder,

00:31:33.490 --> 00:31:35.720
set a number of values in there.

00:31:36.040 --> 00:31:40.440
To explain what the values are,
top left hand corner tells us

00:31:40.690 --> 00:31:43.960
what the name of the binding is.

00:31:45.340 --> 00:31:49.270
The slightly confusing thing,
and this is analogous then to the control

00:31:49.350 --> 00:31:53.480
draggy thing that you do in Interface
Builder with target action again,

00:31:53.860 --> 00:31:56.700
is the key path.

00:31:56.810 --> 00:31:58.180
I'm sorry.

00:31:58.190 --> 00:32:03.180
Next we need the object
that you're binding to.

00:32:03.910 --> 00:32:06.140
The slightly confusing
thing is the key path.

00:32:06.270 --> 00:32:12.600
We've actually got two combo boxes
which together can specify the key path.

00:32:12.720 --> 00:32:17.220
So both of these values,
if there are indeed two values there,

00:32:17.460 --> 00:32:21.070
get concatenated.

00:32:21.070 --> 00:32:21.070
And I think this is one of the
things that confuses people.

00:32:21.280 --> 00:32:26.890
In the big block of widgets underneath,
we have a collection of options.

00:32:32.460 --> 00:32:35.400
Imagine that we want to
do the same thing in code.

00:32:35.400 --> 00:32:43.150
If we want to do the same thing in code,
remember that

00:32:43.930 --> 00:32:46.760
Underneath,
bindings are established using

00:32:46.760 --> 00:32:49.110
the key-value binding protocol.

00:32:49.560 --> 00:32:50.990
What did we say there was in that?

00:32:51.140 --> 00:32:52.630
Just one method.

00:32:52.630 --> 00:32:54.400
So if you wanted to set
up this binding in code,

00:32:54.400 --> 00:32:56.900
there's just a single method call.

00:32:56.900 --> 00:33:01.020
We would have to send a message to
the text field to tell it to bind its

00:33:01.240 --> 00:33:04.400
particular attribute to something.

00:33:04.400 --> 00:33:08.290
In this particular case,
we tell it that it's going to

00:33:08.290 --> 00:33:12.890
bind its value to a particular
object using a particular key path

00:33:13.080 --> 00:33:15.830
and with a collection of options.

00:33:17.350 --> 00:33:23.850
So these two ways of establishing
a binding are identical.

00:33:24.690 --> 00:33:27.410
If there's nothing else that
you take away from this talk,

00:33:27.410 --> 00:33:31.830
I'd please like you to try to
remember this particular slide.

00:33:33.410 --> 00:33:39.640
I hope that more than anything this
will help to demystify in particular

00:33:40.150 --> 00:33:43.530
that inspector in Interface Builder.

00:33:43.960 --> 00:33:48.910
Is there anybody here who feels they
could not write one line of code?

00:33:51.860 --> 00:33:56.890
Is there anybody here who feels they
could not write one line of code?

00:34:00.850 --> 00:34:08.900
in Interface Builder, think to yourself,
underneath is just one line of code.

00:34:08.900 --> 00:34:08.900
I can write one line of code.

00:34:08.900 --> 00:34:08.920
That's easy.

00:34:10.290 --> 00:34:13.420
It's just a question of figuring out,
as ever in Cocoa,

00:34:13.420 --> 00:34:15.370
well what is that line of code?

00:34:15.610 --> 00:34:20.550
"So, we now want to see, well, okay,
I think you should have got

00:34:20.550 --> 00:34:23.280
most of the way there already,
but let's then drill down

00:34:23.280 --> 00:34:25.970
into details and see,
well, how would you actually figure out

00:34:25.970 --> 00:34:27.600
what it is that you want to write?

00:34:27.600 --> 00:34:33.510
I also want to have a look then at, well,
what are the other technologies

00:34:33.510 --> 00:34:36.110
that make all this stuff work?

00:34:36.140 --> 00:34:37.610
So it's okay saying, okay,
we're going to establish this binding.

00:34:37.610 --> 00:34:37.610
What do we do after that?

00:34:37.610 --> 00:34:37.610
Editor value.

00:34:38.580 --> 00:34:45.310
Consider what happens when the user
edits a value in the text field.

00:34:45.720 --> 00:34:50.780
What happens is key value coding is
used to push the new value from a

00:34:50.780 --> 00:34:54.740
text field down to the controller,
applying in this case a value

00:34:54.740 --> 00:34:56.890
transformer if we specified one.

00:34:57.760 --> 00:35:01.140
Key value coding is used to push
values from the controller down

00:35:01.170 --> 00:35:03.200
to the underlying graphic object.

00:35:03.260 --> 00:35:07.100
Key value observing is
used to notify objects,

00:35:07.100 --> 00:35:11.000
anybody who's interested
in changes to values.

00:35:11.070 --> 00:35:13.450
Key value observing, and in this case,
again,

00:35:13.460 --> 00:35:17.180
using a value transformer if appropriate,
is used to notify anybody who's

00:35:17.180 --> 00:35:23.450
interested in the other value update.

00:35:23.580 --> 00:35:26.300
So to summarize that,

00:35:29.380 --> 00:35:33.950
Key-value coding is a technology
that's used to push values from the

00:35:33.950 --> 00:35:36.970
user interface down to the model.

00:35:37.080 --> 00:35:41.700
Key-value observing is what's used
to notify anybody who's interested in

00:35:41.740 --> 00:35:45.290
changes to underlying model values.

00:35:45.340 --> 00:35:50.160
And the user interface elements can
then update themselves appropriately.

00:35:52.430 --> 00:36:08.100
Key Value Coding.

00:36:08.100 --> 00:36:08.100
And anybody not come across
KeyValue Coding before?

00:36:08.100 --> 00:36:08.100
Okay, one.

00:36:08.100 --> 00:36:08.100
So KeyValue Coding, very simple API.

00:36:08.100 --> 00:36:08.100
It gives you a means of accessing
an object's properties using a key.

00:36:08.100 --> 00:36:08.100
So

00:36:08.350 --> 00:36:10.460
Maybe I'll just click through
and encourage you to read the

00:36:10.460 --> 00:36:13.450
documentation then on this,
because it's pretty straightforward then.

00:36:13.740 --> 00:36:20.390
The main thing that trips--one
of the things that trips people

00:36:20.850 --> 00:36:26.410
up when using key value coding,
particularly for those of you

00:36:26.410 --> 00:36:26.410
getting on to using core data,
is the key value coding

00:36:26.410 --> 00:36:26.410
for too many relationships.

00:36:26.760 --> 00:36:38.150
Who's not come across these mutable
collection value for keys methods?

00:36:38.150 --> 00:36:38.150
Okay, so this is new for some people.

00:36:38.150 --> 00:36:38.150
So, when you have too many relationships,

00:36:38.590 --> 00:36:41.590
There are two methods:
mutable array value for key,

00:36:41.620 --> 00:36:44.000
mutable set value for key.

00:36:44.000 --> 00:36:48.660
These are methods that you can use
to manipulate the contents of a

00:36:49.250 --> 00:36:51.490
collection using key value coding.

00:36:51.880 --> 00:36:55.330
You can use those methods to
retrieve a proxy which you can

00:36:55.330 --> 00:36:58.100
then send appropriate messages.

00:36:58.110 --> 00:37:04.540
So for those of you who've got
confused as to why some values aren't

00:37:04.540 --> 00:37:11.500
updated or found that it's a little
bit difficult to manipulate arrays

00:37:11.500 --> 00:37:14.260
or sets using key value coding,
have a look at those methods.

00:37:14.260 --> 00:37:14.260
Those may be the ones that you want.

00:37:15.290 --> 00:37:37.210
Keypaths are an extension of key
value coding that allow you to

00:37:37.210 --> 00:37:37.210
follow relationships between objects.

00:37:37.210 --> 00:37:37.210
So imagine you've got an employee
object that has a manager

00:37:37.210 --> 00:37:37.210
that's another employee object,
and an employee has a

00:37:37.210 --> 00:37:37.210
first name property.

00:37:37.210 --> 00:37:37.210
You can ask for an employee's
manager's first name by using value

00:37:37.210 --> 00:37:37.210
for keypath manager.firstname.

00:37:38.260 --> 00:37:40.820
Important to note here that
we're using value for key path

00:37:40.870 --> 00:37:42.380
rather than value for key.

00:37:42.400 --> 00:37:45.110
That's another one that trips people up.

00:37:45.990 --> 00:37:52.290
Similarly, we have set value for
keypath to update the value.

00:37:55.620 --> 00:38:00.620
Another aspect of key value coding,
key value coding validation.

00:38:00.700 --> 00:38:06.040
So coming back to what can you do
to add value to your application,

00:38:06.040 --> 00:38:10.810
this is going to be again
particularly relevant for

00:38:10.830 --> 00:38:15.560
those of you using core data,
but still relevant,

00:38:15.590 --> 00:38:17.700
but still valuable for people writing
your own model classes at the moment.

00:38:17.700 --> 00:38:17.700
KVC validation gives you a

00:38:17.980 --> 00:38:29.800
consistent means of defining validation
methods for individual properties.

00:38:29.800 --> 00:38:29.800
So there's a generic form
of the validation method,

00:38:29.800 --> 00:38:29.800
ValidateValueForKeyError.

00:38:30.060 --> 00:38:36.030
You can in your own model class implement
validate key name error methods.

00:38:36.210 --> 00:38:39.200
In the body of the method,
you can then determine, well,

00:38:39.200 --> 00:38:43.330
is the value that's being passed
in something that I'm happy with?

00:38:43.380 --> 00:38:45.360
If it is, simply return yes.

00:38:45.440 --> 00:38:54.510
If no, then first of all create a new
NSError object and then return no.

00:38:55.130 --> 00:39:00.770
If you look carefully,
the input value is typed there as ID*.

00:39:00.800 --> 00:39:01.970
That's not a typo.

00:39:02.050 --> 00:39:05.000
You're passed in a pointer to an ID.

00:39:05.000 --> 00:39:07.410
So within the body of
a validation method,

00:39:07.410 --> 00:39:11.040
you do actually have the opportunity
to replace the value that's

00:39:11.070 --> 00:39:14.740
passed in and massage it into
something that you actually want.

00:39:14.740 --> 00:39:18.020
Generally, we're discouraging
people from doing that,

00:39:18.230 --> 00:39:21.280
though, because of memory
management implications.

00:39:21.290 --> 00:39:24.180
And again,
the documentation explains why that is.

00:39:24.180 --> 00:39:24.180
So,

00:39:25.030 --> 00:39:29.020
Looking to see how key value
coding works when we send updates.

00:39:29.220 --> 00:39:35.200
Again, user types a new value into
the angle text--into the angle.

00:39:35.310 --> 00:39:40.850
Text field, type a new value in,
key value coding is used to

00:39:40.850 --> 00:39:46.800
pass that value down to the
underlying graphic object.

00:39:46.800 --> 00:39:50.330
The graphic object, if it implements key
value coding validation,

00:39:50.360 --> 00:39:56.610
does have an opportunity to reject
that value if an appropriate

00:39:57.150 --> 00:39:58.850
flag is set for the binding,
otherwise it's updated.

00:40:00.840 --> 00:40:04.700
What do you actually have to do in
order to support key-value coding?

00:40:04.930 --> 00:40:08.310
Well, I hope most of you have
found actually not very much,

00:40:08.360 --> 00:40:09.690
for the most part.

00:40:09.940 --> 00:40:14.200
It's actually really quite difficult
not to be key-value coding compliant.

00:40:15.300 --> 00:40:17.780
"Tipically,
all that's expected is that you implement

00:40:17.780 --> 00:40:19.520
the appropriate accessor methods."

00:40:21.150 --> 00:40:24.040
Please, that's something you
should be doing anyway.

00:40:24.040 --> 00:40:33.060
Writing and using accessor methods
makes memory management a lot easier.

00:40:33.060 --> 00:40:36.900
So if you implement accessor methods,
follow the key--the appropriate naming

00:40:36.900 --> 00:40:36.900
conventions for accessor methods,
life will be an awful lot easier.

00:40:37.920 --> 00:40:40.610
It becomes a little bit
more complicated for arrays,

00:40:40.610 --> 00:40:44.420
so the special array access
methods you may want to implement.

00:40:44.420 --> 00:40:47.490
Again, that's covered in documentation.

00:40:48.240 --> 00:40:52.860
Turn to key value observing the other
technology that supports Cocoa bindings

00:40:52.860 --> 00:40:57.330
in order to actually notify the rest
of your application or notify elements

00:40:57.470 --> 00:41:00.100
of an application of changes to values.

00:41:00.260 --> 00:41:03.390
There are two parts to KVO.

00:41:04.090 --> 00:41:07.920
Think a little bit, think in terms of an
analogous thing here,

00:41:07.920 --> 00:41:09.750
maybe notification centers.

00:41:10.090 --> 00:41:12.810
If you're using notification centers,
there are two parts to

00:41:12.810 --> 00:41:14.280
using a notification center.

00:41:14.460 --> 00:41:16.400
First of all,
you've got to register to say, "Hey,

00:41:16.400 --> 00:41:19.680
I'm interested in this particular
sort of notification." Secondly,

00:41:19.690 --> 00:41:22.270
then,
you've got to receive messages back from

00:41:22.280 --> 00:41:26.890
the notification center if the events
that you're interested in actually occur.

00:41:26.970 --> 00:41:28.460
It's a similar thing with KVO.

00:41:28.460 --> 00:41:31.790
You first have to say, "Hey,
I'm interested in this particular

00:41:31.880 --> 00:41:34.000
property of this particular object."

00:41:35.930 --> 00:41:37.740
Secondly,
you've got to have a means of being

00:41:37.740 --> 00:41:40.330
told that that value has changed.

00:41:40.420 --> 00:41:44.820
So registrations go by addObserver
for the keypath options context.

00:41:44.920 --> 00:41:51.520
The difference between notification
centers and KVO is that whereas with

00:41:51.520 --> 00:41:55.260
notification centers you can specify
the message that's going to get sent

00:41:55.260 --> 00:41:59.630
back to you if the event occurs,
with KVO there is a single method

00:41:59.630 --> 00:42:04.620
that's used as a choke point
for all KVO notifications and

00:42:04.620 --> 00:42:10.340
that's observe value for key
path of object change context.

00:42:10.340 --> 00:42:15.060
So all KVO notifications go
back through this one method.

00:42:15.060 --> 00:42:18.170
So in terms of establishing our binding.

00:42:21.170 --> 00:42:29.120
The different user interface
elements have to first of all,

00:42:29.120 --> 00:42:34.920
in order to get KVO to work,
say what property it is of what

00:42:34.920 --> 00:42:34.920
object they're interested in,
so they have to register as an observer

00:42:34.920 --> 00:42:34.920
of the thing that they're bound to.

00:42:36.770 --> 00:42:41.020
If that value changes,
they get a message back.

00:42:41.060 --> 00:42:46.610
They observe value for key path message.

00:42:48.850 --> 00:42:51.380
So to recap, this is how you register.

00:42:51.460 --> 00:42:54.110
So this is what happens
when a binding is set up.

00:42:54.440 --> 00:42:57.090
This is what happens
when a value changes,

00:42:57.090 --> 00:43:00.310
in this case when a value
changes in the model.

00:43:01.670 --> 00:43:04.830
What do you actually have
to do to support KVO?

00:43:04.930 --> 00:43:10.620
Well, in general, again,
not really very much other

00:43:10.620 --> 00:43:10.620
than simply follow the same

00:43:11.180 --> 00:43:15.490
"Controller layerissippi" is a
key value code that allows you to

00:43:15.490 --> 00:43:18.080
change key value for key value code.

00:43:18.080 --> 00:43:21.100
Support automatically added at runtime.

00:43:21.100 --> 00:43:23.460
So you don't have to do anything.

00:43:23.460 --> 00:43:28.240
If you want to, you can disable automatic
KVO notifications and switch

00:43:28.280 --> 00:43:32.730
on manual notifications,
in which case you can use "Will change

00:43:32.730 --> 00:43:37.210
value for key" and "Did change value
for key," in which case your accessor

00:43:37.210 --> 00:43:37.210
methods might start looking like this.

00:43:38.540 --> 00:43:46.840
Notice that I've put here
the KVO notification methods

00:43:47.180 --> 00:43:49.980
into an accessor methods.

00:43:49.980 --> 00:43:53.570
One of the things I've noticed on the
list in particular is people seem to

00:43:53.570 --> 00:43:57.490
want to just sprinkle KVO notifications
throughout their code and sort

00:43:57.550 --> 00:44:00.880
of hope that bindings then start
working magically as a result.

00:44:00.890 --> 00:44:02.250
No, that's not going to work.

00:44:02.250 --> 00:44:06.600
There's got to be a rational reason
for actually posting KVO notifications

00:44:06.600 --> 00:44:11.710
and typically the place that you
would put these methods is in your

00:44:11.710 --> 00:44:14.360
accessor methods around the place
where the value actually changes.

00:44:16.670 --> 00:44:19.880
So where have we got to?

00:44:20.050 --> 00:44:23.240
Three main technologies,
key value observing, key value coding,

00:44:23.240 --> 00:44:24.460
key value binding.

00:44:24.640 --> 00:44:30.400
You use key value binding to
actually establish the binding,

00:44:30.400 --> 00:44:35.600
key value coding to push values from
the user interface down to the model,

00:44:35.660 --> 00:44:38.140
key value observing to receive
notifications of changes

00:44:38.140 --> 00:44:39.630
of values to the model.

00:44:39.890 --> 00:44:45.660
You don't have to do very much
to actually support KVC and KVO.

00:44:45.750 --> 00:44:48.590
So now, to look at those in more detail.

00:44:52.100 --> 00:44:55.560
Let's have a look and see what you would
actually have to do if you wanted to

00:44:55.560 --> 00:44:58.000
implement your own bindings-enabled view.

00:44:58.000 --> 00:44:59.200
How would you do the joystick thing?

00:44:59.350 --> 00:45:03.770
In this, we're going to concentrate still
on the angle part of things.

00:45:03.970 --> 00:45:07.700
So, first of all, establishing a binding.

00:45:07.850 --> 00:45:10.100
What do we actually have to do?

00:45:10.640 --> 00:45:15.700
Think back, first of all,
to the target action example.

00:45:15.800 --> 00:45:19.570
With target action,
we had a widget that you control dragged,

00:45:19.570 --> 00:45:23.400
and when you control dragged,
you set two instance variables,

00:45:23.400 --> 00:45:24.600
target and action.

00:45:24.630 --> 00:45:30.570
Can I just check,
everybody okay with target and action

00:45:30.570 --> 00:45:31.780
as instance variables of NS control?

00:45:31.780 --> 00:45:31.780
Anybody still sort of mystified by that?

00:45:33.670 --> 00:45:40.380
How many people figured out within
one day that that's what was going on?

00:45:42.600 --> 00:45:47.240
How many people did it take one week?

00:45:47.260 --> 00:45:49.280
How many people did it take a month?

00:45:50.900 --> 00:45:53.310
How many people forget
it out this morning?

00:45:55.890 --> 00:45:58.660
Okay, it's really like,
it's really getting sort of

00:45:58.660 --> 00:46:02.770
hand fatigue or something.

00:46:03.000 --> 00:46:06.520
Okay, so with the control,
when we do that control drag thing,

00:46:06.520 --> 00:46:09.840
we're simply setting
those instance variables.

00:46:10.110 --> 00:46:13.240
So we've got a way of
recording the information.

00:46:13.290 --> 00:46:16.360
What's a good way of recording
information in a class then?

00:46:16.570 --> 00:46:19.240
Well, in instance variables.

00:46:19.380 --> 00:46:31.290
So if we're setting up the angle binding
and other bindings for our joystick,

00:46:31.290 --> 00:46:34.250
there's a whole lot of information
that we need to collect.

00:46:35.140 --> 00:46:40.250
Conceptually, at least,
one way of doing this is simply

00:46:40.250 --> 00:46:43.080
to use instance variables.

00:46:43.080 --> 00:46:47.010
So we can provide our joystick
class with a whole set of

00:46:47.010 --> 00:46:51.100
instance variables in which we
can collect all that information.

00:46:51.430 --> 00:46:52.050
Simple.

00:46:52.110 --> 00:46:55.080
The one thing that's a little
bit complicated at this,

00:46:55.080 --> 00:46:58.590
lurking down at the bottom,
is the angle observation context,

00:46:58.590 --> 00:47:00.500
which I'm going to add to this.

00:47:00.760 --> 00:47:02.700
will come back to that later.

00:47:02.700 --> 00:47:03.770
But at the moment,
the main thing to concentrate on is,

00:47:03.840 --> 00:47:08.320
look, all we've got is a collection
of instance variables in which

00:47:08.380 --> 00:47:11.700
we can store information.

00:47:11.700 --> 00:47:11.700
So,

00:47:12.420 --> 00:47:14.460
What actually happens in our bind method?

00:47:14.490 --> 00:47:18.410
The bind method is sent when
the binding is established,

00:47:18.410 --> 00:47:21.300
so all we have to do is to
collect that information together.

00:47:21.380 --> 00:47:24.390
So the bind method is a little bit long.

00:47:24.620 --> 00:47:29.790
Notice the arguments
highlighted there in orange.

00:47:29.940 --> 00:47:33.260
First thing, which binding is it?

00:47:33.530 --> 00:47:36.300
In this case, we're wanting to set
up the angle binding,

00:47:36.300 --> 00:47:40.520
so is the binding name that's being
passed in the one we're interested in?

00:47:40.710 --> 00:47:44.210
Okay, yes if it is, then.

00:47:46.260 --> 00:47:53.390
We must register as an observer
of the object whose property

00:47:54.000 --> 00:47:56.900
This particular attribute is bound to.

00:47:56.900 --> 00:47:59.950
So if we're saying, okay,
joystick's angle's got to be kept

00:47:59.950 --> 00:48:05.030
in sync with this object's whatever,
the joystick has got

00:48:05.030 --> 00:48:07.000
to observe this thing.

00:48:07.120 --> 00:48:09.190
That's all that that's doing.

00:48:09.840 --> 00:48:14.940
So Joystick is saying, "Hey,
Model Object, I'm interested in this

00:48:14.940 --> 00:48:16.480
particular property.

00:48:18.190 --> 00:48:22.600
The angle identifier,
angle binding identifier is

00:48:22.650 --> 00:48:24.690
important here because that...

00:48:25.320 --> 00:48:33.310
particular variable will be sent
back to you in the observed message.

00:48:33.430 --> 00:48:37.450
So what you're saying with
by providing that context is,

00:48:37.950 --> 00:48:40.500
When you tell me that
that value has changed,

00:48:40.570 --> 00:48:45.400
also pass back this context so that
I know what it is you're talking about.

00:48:45.470 --> 00:48:48.800
Remember everything's channeled back
through that one single observe message.

00:48:49.080 --> 00:48:52.190
So you've got to have a
means of disambiguating.

00:48:52.950 --> 00:48:55.660
Other than that,
the next three things are simply

00:48:55.660 --> 00:48:57.760
recording the other information.

00:48:57.780 --> 00:49:01.040
So, we need to record, well,
what is--what object is it

00:49:01.050 --> 00:49:04.740
we're actually being bound to,
so that if our value is updated,

00:49:04.820 --> 00:49:06.300
push that through.

00:49:06.490 --> 00:49:10.640
What's the key path to the
property that we're interested in?

00:49:10.690 --> 00:49:13.850
And then, is there any value transformer?

00:49:13.850 --> 00:49:18.570
So, in the options, the only thing we're
actually interested in,

00:49:18.570 --> 00:49:20.250
in this particular example,
is a value transformer.

00:49:21.580 --> 00:49:26.120
So, if there's a value transformer,
record that as well.

00:49:26.120 --> 00:49:26.630
And that's it.

00:49:29.300 --> 00:49:34.400
[Transcript missing]

00:49:34.680 --> 00:49:38.800
for any of the other bindings
that we might want to set up,

00:49:38.830 --> 00:49:41.950
but they all follow pretty
much the same pattern.

00:49:43.520 --> 00:49:46.460
The bind method arguments tell you
everything that you're interested in.

00:49:46.650 --> 00:49:49.320
So you say, "Okay,
I need to observe that particular

00:49:49.320 --> 00:49:52.080
property of that object,
and then I need to record that

00:49:52.080 --> 00:49:54.790
information." And that's it.

00:49:56.720 --> 00:49:58.920
What actually happens
when there are updates,

00:49:59.010 --> 00:49:59.600
though?

00:49:59.600 --> 00:50:02.040
There are two ways in
which updates might happen.

00:50:02.040 --> 00:50:05.940
First of all, view initiated,
so if somebody clicks within the joystick

00:50:06.280 --> 00:50:08.590
to move the shadow angle and offset.

00:50:08.620 --> 00:50:10.590
Or, say if something's
initiated above the model.

00:50:10.590 --> 00:50:14.490
So maybe if somebody had clicked
in the text field and there'd

00:50:14.510 --> 00:50:18.600
been an update to the model and
it had propagated its update.

00:50:18.600 --> 00:50:23.720
So, for a view initiated update,
imagine that somebody clicks

00:50:23.720 --> 00:50:28.710
somewhere inside the view,
and we channel all of those,

00:50:28.730 --> 00:50:32.080
so say mouse dragged, mouse down,
mouse up, and so on,

00:50:32.080 --> 00:50:35.200
through an updateForMouseEvent method.

00:50:35.200 --> 00:50:40.370
So we're going to look at the
implementation of our updateForMouseEvent

00:50:40.620 --> 00:50:45.110
method and see how we would then
deal with that using bindings.

00:50:47.590 --> 00:50:56.620
What we're going to have
to do is update the model,

00:50:56.620 --> 00:51:01.890
or update the object
to which we're bound.

00:51:02.870 --> 00:51:07.830
Remembering first of all how the binding
was established in Interface Builder

00:51:07.830 --> 00:51:10.600
and what code was associated with that.

00:51:10.630 --> 00:51:16.550
If we have a look at the code,
bind to object with key path options

00:51:17.100 --> 00:51:24.550
From the perspective of an update
that's handled by the view itself,

00:51:24.550 --> 00:51:24.550
the bind argument tells you

00:51:26.020 --> 00:51:31.760
"What attribute of your own is it
going to be updated?" The "ToObject"

00:51:31.760 --> 00:51:36.000
argument tells you what remote
object you need to update.

00:51:36.180 --> 00:51:42.610
The "WithKeyPath" argument
tells you what property it is

00:51:42.610 --> 00:51:50.310
of that object and options,
whatever other options are specified.

00:51:50.310 --> 00:51:50.310
So, in our updateForMouseEvent method,

00:51:50.500 --> 00:51:51.860
The first thing that we
need to do is calculate,

00:51:51.860 --> 00:51:55.100
okay, what's the new angle for
this particular example?

00:51:55.100 --> 00:52:00.160
Then, first of all, check to see,
are we actually observing anything?

00:52:00.160 --> 00:52:03.940
If we haven't actually been,
if bindings haven't been established,

00:52:03.940 --> 00:52:05.310
then don't bother.

00:52:05.320 --> 00:52:08.040
So, are we actually observing anything?

00:52:08.040 --> 00:52:13.570
If so, then, for the options that
we're allowed to be set,

00:52:13.670 --> 00:52:14.880
do we have a value transformer?

00:52:14.880 --> 00:52:22.520
If there is a value transformer,
Apply it.

00:52:26.610 --> 00:52:31.190
And then simply update the remote
value of the observed object's

00:52:31.220 --> 00:52:34.900
value using key value coding.

00:52:34.900 --> 00:52:37.980
And that's it.

00:52:37.990 --> 00:52:40.290
Really, it just boils down to--

00:52:41.650 --> 00:52:43.920
"That penultimate line,
not an awful lot to it,

00:52:43.920 --> 00:52:47.030
and then you can do
everything else you want."

00:52:47.650 --> 00:52:53.060
So pretty simple, I think.

00:52:53.120 --> 00:52:57.700
Conversely, if the model's updated,
remember everything in key-value

00:52:57.700 --> 00:53:02.600
observing then gets channeled
through this one observe method.

00:53:02.600 --> 00:53:10.690
So from the perspective of the bindings,
we can rearrange the order of

00:53:10.690 --> 00:53:14.590
the bind method a little bit
to figure out what's going on.

00:53:14.750 --> 00:53:18.310
What the bind method means from the
perspective of key-value observing

00:53:18.390 --> 00:53:21.580
is if the property defined by
the argument to the withKeyPath

00:53:21.590 --> 00:53:27.980
part of the method changes on
the object that we're observing,

00:53:28.130 --> 00:53:32.730
update whatever attribute it
is internally that's defined by

00:53:34.160 --> 00:53:38.400
the binding name and apply any
options that were specified.

00:53:39.620 --> 00:53:43.780
So in our Observe method,
the first thing that we want

00:53:43.780 --> 00:53:49.160
to do is check to see what the
context is that's coming back.

00:53:49.210 --> 00:53:50.300
What is it that we're interested in?

00:53:50.300 --> 00:53:52.600
We specify the context when we register.

00:53:52.600 --> 00:53:54.450
So remember,
the context is going to be sent

00:53:54.450 --> 00:53:55.920
back to us in the Observe method.

00:53:55.920 --> 00:53:59.910
So this is what we can use
to disambiguate different

00:54:00.090 --> 00:54:14.710
observation notifications.

00:54:14.710 --> 00:54:14.710
If it's the one that we're interested in,
an apologies then for using

00:54:14.710 --> 00:54:14.710
short variable names here,
but it was the only way everything

00:54:14.710 --> 00:54:14.710
could fit onto one slide.

00:54:14.710 --> 00:54:14.710
First of all,
find out what the new value is.

00:54:16.400 --> 00:54:20.820
Secondly, so there's one little bit
of a new API here for Tiger.

00:54:21.250 --> 00:54:24.380
Figure out first of all,
is it one of these multiple

00:54:24.440 --> 00:54:26.190
value marker things?

00:54:27.130 --> 00:54:30.980
If it's not,
then if there's a value transformer,

00:54:31.040 --> 00:54:37.050
apply it to the new value,
and then simply update your own value,

00:54:37.690 --> 00:54:40.430
update the display, and so on.

00:54:43.980 --> 00:54:47.650
Paul's from over there.

00:54:47.650 --> 00:54:51.000
Again,
the long method names and the long,

00:54:51.390 --> 00:54:55.020
Long variables may make things
a little bit more confusing,

00:54:55.020 --> 00:54:59.400
but really there are only about two
lines of important code in there.

00:54:59.400 --> 00:55:02.620
I don't think that should be
beyond anybody in this room

00:55:02.620 --> 00:55:04.410
if you've paid to come here.

00:55:08.480 --> 00:55:12.970
Is that straightforward enough?

00:55:13.130 --> 00:55:16.540
Does anybody look-- oh,
can we just all sort of turn

00:55:16.540 --> 00:55:18.380
around and just do that?

00:55:19.040 --> 00:55:21.110
This is my signal that
there's five minutes left.

00:55:21.340 --> 00:55:24.000
Yay, I saw.

00:55:24.120 --> 00:55:26.640
So, where have we got to?

00:55:30.060 --> 00:55:32.680
To summarize,
we've got three main technologies:

00:55:32.680 --> 00:55:35.480
key value coding, key value observing,
key value binding.

00:55:35.480 --> 00:55:39.590
Key value binding used to
actually establish the bindings.

00:55:39.910 --> 00:55:45.490
What I have gone through
today thus far is enough

00:55:46.040 --> 00:56:06.990
in principle for you to
understand how bindings,

00:56:06.990 --> 00:56:06.990
how you can actually create
your own bindings-enabled view.

00:56:06.990 --> 00:56:06.990
I hope that what you have
seen from this is there's

00:56:06.990 --> 00:56:06.990
actually not an awful lot to it.

00:56:06.990 --> 00:56:06.990
Is anybody still completely
mystified by this?

00:56:06.990 --> 00:56:06.990
That's encouraging.

00:56:09.360 --> 00:56:14.480
Is it simpler than some people
thought it was going to be?

00:56:14.510 --> 00:56:17.740
Who still thinks it is
horribly complicated?

00:56:17.740 --> 00:56:21.900
Who still thinks it's a
little bit complicated?

00:56:23.750 --> 00:56:26.600
That's fair.

00:56:26.780 --> 00:56:30.510
The main thing is it's
not horribly complicated,

00:56:30.510 --> 00:56:30.510
so that's the--

00:56:31.950 --> 00:56:34.110
Actually,
one of the analogies I didn't make

00:56:34.320 --> 00:56:37.580
at the outset that some of you
probably have heard me make before

00:56:37.660 --> 00:56:39.100
is that of emergent behavior.

00:56:39.100 --> 00:56:42.900
So one of the analogies I sometimes
like to make is that of an ant hill.

00:56:42.900 --> 00:56:46.380
I've never actually seen an ant hill,
but I would imagine that

00:56:46.410 --> 00:56:48.870
looking at an ant hill,
it's horribly complicated.

00:56:48.910 --> 00:56:51.590
You have all this stuff going on,
all these ants scurrying

00:56:51.590 --> 00:56:53.150
around and what have you,
and trying to make sense of how

00:56:53.190 --> 00:56:55.890
they actually built the thing,
how all the passages work,

00:56:55.950 --> 00:56:57.860
how they figure out where to go
and food and all the rest of it.

00:56:57.900 --> 00:57:00.690
It looks horribly, horribly complicated.

00:57:01.060 --> 00:57:04.390
From the perspective
of an individual ant,

00:57:04.420 --> 00:57:08.400
though, an individual ant is never
going to win a Nobel Prize.

00:57:08.430 --> 00:57:10.260
They're not very complicated animals.

00:57:10.280 --> 00:57:13.280
They don't do an awful lot individually.

00:57:14.380 --> 00:57:18.480
Put a whole load of them together though
and you get this emergent behavior.

00:57:18.600 --> 00:57:20.500
Things look complicated.

00:57:20.620 --> 00:57:23.300
What I'd like you to try to think
of when you look at bindings is,

00:57:23.300 --> 00:57:26.160
well actually the technologies
that I just went through are

00:57:26.160 --> 00:57:29.140
individually all very simple.

00:57:29.150 --> 00:57:31.620
It shouldn't have been beyond
the wit of anybody in this room

00:57:31.660 --> 00:57:35.220
certainly to understand any of
the technologies individually.

00:57:35.900 --> 00:57:41.220
Putting them together makes really
interesting things happen though.

00:57:41.220 --> 00:57:44.850
Sometimes I admit that the
way the manifestation of that

00:57:44.870 --> 00:57:47.930
combination can be confusing.

00:57:48.440 --> 00:57:50.400
But underneath,
just dig through it a little bit,

00:57:50.460 --> 00:57:52.390
step back and think,
well each of those things

00:57:52.400 --> 00:57:53.720
individually are simple.

00:57:54.050 --> 00:57:55.820
There's not much to it.

00:57:56.430 --> 00:57:58.180
Anyway,
coming back then to the main thing,

00:57:58.220 --> 00:58:00.350
because I'm going to overrun
now by two minutes again,

00:58:00.350 --> 00:58:01.270
sorry.

00:58:01.270 --> 00:58:06.970
A quick talk about Value Transformers,
and then I'll give a

00:58:07.070 --> 00:58:08.970
quick heads up again about

00:58:09.220 --> 00:58:09.790
controllers.

00:58:09.800 --> 00:58:11.790
But both of these are going to be
covered in the following talks.

00:58:11.810 --> 00:58:14.180
So I mentioned value transformers,
what are value transformers.

00:58:14.180 --> 00:58:17.760
You can think of value transformers
as being a little bit like formatters

00:58:17.760 --> 00:58:20.520
but lightweight sort of a formatter.

00:58:20.520 --> 00:58:24.610
If you want to use value transformers
in instance interface builder you

00:58:24.620 --> 00:58:26.250
have to register them by name.

00:58:26.550 --> 00:58:28.920
Foundation gives you a
set of three of them.

00:58:28.930 --> 00:58:32.730
Cocoa gives you a set of three of
them by default for testing for

00:58:32.730 --> 00:58:34.900
nil values and archiving and so on.

00:58:34.900 --> 00:58:37.540
But you can create and register your own.

00:58:37.540 --> 00:58:41.480
So there's not an awful lot
to the value transformers API.

00:58:41.480 --> 00:58:44.890
A method to tell you what class
it is that you're dealing with,

00:58:45.230 --> 00:58:48.520
whether or not it transforms by
direct--accepts bidirectional

00:58:48.520 --> 00:58:53.890
transformation and then methods to
actually transform an incoming value.

00:58:54.420 --> 00:58:57.710
If you want to use an Interface Builder,
you have to register a new

00:58:57.710 --> 00:59:00.200
instance for a particular name,
and you typically do this

00:59:00.230 --> 00:59:01.490
in an initialized method.

00:59:01.500 --> 00:59:06.190
But other than that,
this is the implementation of a

00:59:06.190 --> 00:59:10.870
Radiance Degrees Value Transformer.

00:59:13.340 --> 00:59:19.180
Not very much to it.

00:59:19.180 --> 00:59:19.180
Again,
shouldn't be beyond anybody in this room.

00:59:22.870 --> 00:59:28.300
"Controllers" mentioned basically I'm
just going to say very quickly that there

00:59:28.300 --> 00:59:31.980
are three different sorts of controller:
object controller, array controller,

00:59:31.980 --> 00:59:34.300
and preferences controller
that I mentioned before.

00:59:34.340 --> 00:59:37.040
Ron's going to talk a bit
more about these in his talk.

00:59:37.050 --> 00:59:40.640
One of the questions that comes up is,
though,

00:59:40.640 --> 00:59:43.730
is why do we actually want controllers?

00:59:43.810 --> 00:59:45.090
What do they do?

00:59:45.310 --> 00:59:47.630
Well, one of the most important things
is that the controllers give

00:59:47.630 --> 00:59:47.630
you a degree of abstraction.

00:59:48.520 --> 00:59:50.530
So rather than binding
directly to a model object,

00:59:50.530 --> 00:59:54.230
the controller gives you a means
of changing the model object

00:59:54.230 --> 00:59:59.050
out from underneath whatever
it is that you're bound to.

00:59:59.050 --> 00:59:59.050
So you're not

01:00:01.030 --> 01:00:04.170
hard wiring bindings for
a particular text field,

01:00:04.240 --> 01:00:06.720
for example, to a particular model.

01:00:06.730 --> 01:00:11.470
More importantly,
there are two other protocols that

01:00:11.520 --> 01:00:15.710
Controls implement-- an Editor and
an Editor-editor registration-- which

01:00:15.710 --> 01:00:19.310
help to ensure that if a user's part
way through typing values into a

01:00:19.650 --> 01:00:24.220
text field when a window's closed,
those values are committed down to the

01:00:24.220 --> 01:00:27.020
model if the window's closed or whatever.

01:00:27.040 --> 01:00:31.010
And they also provide
the selection markers.

01:00:31.090 --> 01:00:35.900
So please, please,
please do always use controllers.

01:00:35.900 --> 01:00:39.400
May not seem like you need them,
but they're very useful.

01:00:39.400 --> 01:00:43.110
Selection markers, I just mentioned,
are the special

01:00:43.400 --> 01:00:58.900
[Transcript missing]

01:00:59.780 --> 01:01:04.220
So all of those are going to be
things that are covered in the

01:01:04.220 --> 01:01:10.100
next talk and in the documentation,
various other samples, and so on.

01:01:10.190 --> 01:01:16.330
So I would encourage you to
go to the following session.

01:01:17.700 --> 01:01:22.320
And if appropriate,
Matthew Formica is very happy to

01:01:22.370 --> 01:01:26.500
personally answer any question
that you have on bindings directly,

01:01:26.500 --> 01:01:30.100
so please email him directly
with all of your questions.

01:01:30.220 --> 01:01:32.190
An alternative,

01:01:32.730 --> 01:01:35.290
is to use the Cocoa Developeroper list.

01:01:35.290 --> 01:01:39.420
So a number of you have already
taken advantage of that option.

01:01:39.480 --> 01:01:43.300
But in the interim,
the joystick example that I gave is

01:01:43.300 --> 01:01:46.930
now officially part of the sample code.

01:01:46.930 --> 01:01:51.220
Read through, have a look at that.

01:01:51.220 --> 01:01:51.220
Have a look at the documentation
and other resources.
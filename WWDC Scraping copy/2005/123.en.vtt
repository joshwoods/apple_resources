WEBVTT

00:00:05.100 --> 00:00:09.220
Good evening, and welcome to session 123,
Introduction to Core Data.

00:00:09.300 --> 00:00:11.410
My name is Matthew Firlik,
and I am the manager of the

00:00:11.410 --> 00:00:13.570
Core Data engineering team.

00:00:13.910 --> 00:00:14.880
Show of hands to start with.

00:00:14.880 --> 00:00:17.200
How many people know
nothing about Core Data?

00:00:17.270 --> 00:00:18.800
Zip, zilch, nada, zero.

00:00:18.930 --> 00:00:20.960
Wow, you are in the right place.

00:00:21.020 --> 00:00:23.590
How many people of you have used
Core Data a little bit and want

00:00:23.590 --> 00:00:25.310
to know more information about it?

00:00:25.760 --> 00:00:26.600
Decent.

00:00:26.600 --> 00:00:28.400
Now, be honest,
how many of you people know a lot

00:00:28.400 --> 00:00:32.440
about Core Data and are here to ask the
really difficult questions in the Q&A?

00:00:33.050 --> 00:00:34.960
Thank you for being honest.

00:00:34.960 --> 00:00:37.340
You can leave.

00:00:37.340 --> 00:00:40.920
All right, so introduction to Core Data.

00:00:40.930 --> 00:00:43.810
First question, what is Core Data?

00:00:44.300 --> 00:00:46.190
You may have actually looked online,
seen websites,

00:00:46.200 --> 00:00:49.640
seen lots of descriptions of Core Data,
and they're a mouthful.

00:00:49.730 --> 00:00:55.710
Lots of words like model view control,
object graph management, persistency.

00:00:55.720 --> 00:00:58.250
These are very, very,
very sophisticated terms,

00:00:58.250 --> 00:01:00.350
and we certainly do all of these things.

00:01:00.350 --> 00:01:02.470
But let's actually just
take it down to basics.

00:01:02.480 --> 00:01:04.080
What does Core Data do?

00:01:04.100 --> 00:01:09.030
So it's a framework that allows
you to interact with your data.

00:01:09.030 --> 00:01:11.400
And we're going to break that
up into three different parts.

00:01:12.230 --> 00:01:14.650
First is the visualization
and the display of your data.

00:01:15.050 --> 00:01:17.050
Obviously, you have something interesting
and you want to display it

00:01:17.150 --> 00:01:18.140
through your application.

00:01:18.160 --> 00:01:21.070
That could be physically
putting strings on the screen

00:01:21.140 --> 00:01:24.120
in text fields and table views,
or that could be using lots

00:01:24.120 --> 00:01:26.920
of numerical information to
represent some kind of graphic.

00:01:26.940 --> 00:01:28.560
But you want to visualize your data.

00:01:28.580 --> 00:01:32.750
Second thing is you want to create,
modify, and delete your data.

00:01:32.770 --> 00:01:35.470
Data is more interesting
when we do things with it.

00:01:35.520 --> 00:01:38.430
And then the last thing is you want
to save and retrieve your data.

00:01:38.430 --> 00:01:41.440
Take all this stuff that you've put
in your application and bring it back.

00:01:42.860 --> 00:01:45.980
So these are the fundamental
tenets of Core Data.

00:01:46.200 --> 00:01:48.200
And as you start to look at
some of the descriptions,

00:01:48.200 --> 00:01:51.180
we'll actually go through and
we talk about modifying objects

00:01:51.200 --> 00:01:52.140
and creating and deleting.

00:01:52.330 --> 00:01:54.040
That's really the object
graph management part.

00:01:54.290 --> 00:01:57.200
So when you see that term,
that's really what that refers to.

00:01:57.380 --> 00:02:01.200
And when we talk about persistency,
it's the saving and the retrieving part.

00:02:01.200 --> 00:02:02.750
It's figuring out what to do
with your data and how to get

00:02:02.750 --> 00:02:04.200
it back to you when you want it.

00:02:04.200 --> 00:02:06.370
It's important, though,
to remember that Core Data is

00:02:06.370 --> 00:02:08.200
all three of these things.

00:02:08.200 --> 00:02:11.190
And you don't necessarily have
to use all three of these things.

00:02:11.200 --> 00:02:15.200
You can use any mix of these to
provide benefits to your application.

00:02:15.280 --> 00:02:18.200
So don't think just because, "Oh,
I already have my data in a file,

00:02:18.200 --> 00:02:19.700
and I don't really need any of this.

00:02:19.700 --> 00:02:22.700
This isn't useful to me." You're
going to be very surprised.

00:02:22.700 --> 00:02:23.910
So...

00:02:26.520 --> 00:02:26.850
Down to the basics.

00:02:26.930 --> 00:02:29.100
So we're talking about taking a piece of
data and putting it in an application.

00:02:29.130 --> 00:02:31.200
In this example here,
we're going to talk about a

00:02:31.210 --> 00:02:33.300
little bit of XML and we want
to put it into an interface,

00:02:33.300 --> 00:02:35.500
maybe something looking like iTunes.

00:02:36.060 --> 00:02:39.030
The framework provides you the benefit
of doing this through something

00:02:39.080 --> 00:02:40.490
which we call managed objects.

00:02:40.490 --> 00:02:43.100
And you'll start to hear this
word "managed" going through

00:02:43.100 --> 00:02:44.470
the entire presentation.

00:02:45.150 --> 00:02:48.570
Managed objects give you the power of
taking data from somewhere and getting

00:02:48.670 --> 00:02:51.500
into your application and using it very,
very quickly.

00:02:52.100 --> 00:02:53.910
So to describe this,
we're going to take a look at

00:02:53.910 --> 00:02:55.490
the Core Data architecture.

00:02:55.500 --> 00:02:57.580
We're going to call this
the persistence stack.

00:02:57.580 --> 00:03:00.500
And we're going to burn this into
your memory by the time you're done.

00:03:01.110 --> 00:03:04.500
And if you can remember this,
you've got Core Data pretty much down.

00:03:04.500 --> 00:03:06.890
So we're going to call this the
persistence stack and we're going

00:03:06.890 --> 00:03:09.500
to walk through this for pretty
much the rest of the presentation.

00:03:10.120 --> 00:03:13.500
So let's start at the top and we're
talking about managed objects.

00:03:13.500 --> 00:03:15.010
These are objects that
encapsulate your data,

00:03:15.010 --> 00:03:18.490
encapsulate behavior, encapsulate logic,
that give your application power,

00:03:18.500 --> 00:03:21.500
power to do something interesting,
power to do something compelling.

00:03:21.780 --> 00:03:24.420
The framework also provides you
things called fetch requests,

00:03:24.420 --> 00:03:27.550
which pretty much, as the name implies,
allows you to ask the framework,

00:03:27.550 --> 00:03:28.860
how do I get something?

00:03:28.920 --> 00:03:31.580
Go find something for me and bring
it back so I can work with it.

00:03:31.650 --> 00:03:32.860
So you don't have to
keep track of things.

00:03:32.860 --> 00:03:35.200
You can let the framework
do that for you.

00:03:35.760 --> 00:03:38.500
There's a managed object context,
as the graphic implies.

00:03:38.540 --> 00:03:40.010
It's kind of a drafting table.

00:03:40.200 --> 00:03:43.000
It's a scratch pad for you
to work with your objects,

00:03:43.080 --> 00:03:44.910
create them, modify them, delete them,
throw them away,

00:03:44.920 --> 00:03:45.810
do whatever you want with them.

00:03:45.820 --> 00:03:48.110
But that's kind of your playground.

00:03:49.860 --> 00:03:51.970
Another important element
is the managed object model.

00:03:52.120 --> 00:03:53.290
This is a blueprint.

00:03:53.380 --> 00:03:58.630
It's kind of your contract between your
application data and the framework that--

00:03:58.870 --> 00:04:01.660
along with the persistent store
coordinator figures out how to take

00:04:01.660 --> 00:04:04.890
your data from your application
and put it somewhere interesting

00:04:04.890 --> 00:04:06.300
and then get it back to you.

00:04:06.330 --> 00:04:09.520
And obviously, on the very, very bottom,
we're talking about the persistent store.

00:04:09.550 --> 00:04:12.010
This is where your data
is physically stored.

00:04:12.160 --> 00:04:14.100
So that's the Core Data stack
in a nutshell.

00:04:14.110 --> 00:04:16.830
And we're going to go through this
for the rest of the presentation.

00:04:16.860 --> 00:04:19.180
In the upper right-hand corner,
you're going to see a small

00:04:19.180 --> 00:04:21.880
graphic of this as we go through
with little sections highlighted.

00:04:21.880 --> 00:04:24.600
So in case you get lost or in
case you want to see exactly where

00:04:24.600 --> 00:04:28.160
this lays within the architecture,
you can follow along there.

00:04:28.490 --> 00:04:32.880
Now we're also going to be talking about
a lot of things that Core Data does.

00:04:32.970 --> 00:04:36.760
So from the undo management to
working with Cocoa bindings,

00:04:36.840 --> 00:04:41.420
grouping and filtering, validation,
integrity management, persistence,

00:04:41.500 --> 00:04:43.750
putting stuff into SQL,
putting stuff into XML,

00:04:43.880 --> 00:04:44.820
it does a lot of things.

00:04:44.820 --> 00:04:46.320
And it does them all very well.

00:04:46.360 --> 00:04:50.510
But I want to reiterate the point of use
as much as you need from this framework.

00:04:50.510 --> 00:04:52.890
This framework provides
a lot of functionality,

00:04:53.010 --> 00:04:54.570
but it's not totally inclusive.

00:04:54.630 --> 00:04:56.120
You don't have to use all of it.

00:04:56.120 --> 00:04:58.400
So please remember that as we go through.

00:04:58.890 --> 00:05:01.220
You're going to start to see a
theme though as we go through.

00:05:01.220 --> 00:05:05.450
If you look in the WWDC sample code,
there's a section called Core Recipes.

00:05:05.650 --> 00:05:08.430
That is the Core Data section
for the conference and

00:05:08.430 --> 00:05:10.650
includes a number of really,
really handy things.

00:05:10.760 --> 00:05:13.700
One of them is all the hands-on samples
that you're going to use for the 9:00

00:05:13.700 --> 00:05:17.680
AM session tomorrow that you're all
going to be at to look at Core Data.

00:05:17.770 --> 00:05:20.860
Includes command line and
GUI applications that use Core Data.

00:05:21.160 --> 00:05:22.920
There's also something
called Core Recipes,

00:05:22.970 --> 00:05:26.770
which is our iTunes-like application to
allow you to manage recipe information.

00:05:26.890 --> 00:05:28.920
And in addition to using
Core Data and bindings,

00:05:28.920 --> 00:05:32.140
it's got some spotlight integration
and it's got an automator action.

00:05:32.150 --> 00:05:35.560
And then there's also a migration
example to talk about how to take stuff

00:05:35.560 --> 00:05:38.840
from one schema and move it to another
for those people that have already

00:05:38.840 --> 00:05:41.420
reached that pinnacle of Core Data.

00:05:42.830 --> 00:05:46.150
Let's get started and talk
about the persistent store.

00:05:46.270 --> 00:05:50.360
So the persistent store is
obviously where your stuff is saved.

00:05:50.490 --> 00:05:53.330
And logically,
it's a file or a collection of files

00:05:53.780 --> 00:05:56.100
where all of your information is stored.

00:05:56.180 --> 00:05:58.260
Now for the most part,
the persistent store is

00:05:58.260 --> 00:06:01.940
transparent to both the
developer and to the application.

00:06:02.030 --> 00:06:04.500
So there is some information
about the persistent store.

00:06:04.610 --> 00:06:08.300
Core Data remembers a unique ID about
the store and also knows about a type.

00:06:08.390 --> 00:06:09.660
We'll get to that in a little bit.

00:06:09.770 --> 00:06:12.010
But there's no API on
the persistent store.

00:06:12.350 --> 00:06:15.580
Please don't go look for NS persistent
store in the class hierarchy.

00:06:15.580 --> 00:06:16.780
It's not there.

00:06:16.780 --> 00:06:19.290
What you want to do is
use the store coordinator.

00:06:19.430 --> 00:06:21.730
That's where all the power is.

00:06:22.750 --> 00:06:25.080
Now, you have a number of options
when we talk about stores.

00:06:25.310 --> 00:06:26.530
There's different types,
and there's different

00:06:26.590 --> 00:06:28.700
characteristics of those stores.

00:06:28.980 --> 00:06:30.940
We'll talk about the first one,
which is XML.

00:06:31.000 --> 00:06:34.210
How many of you have
actually used XML before?

00:06:35.670 --> 00:06:37.080
All right, so XML is good.

00:06:37.160 --> 00:06:38.310
It's very human readable.

00:06:38.410 --> 00:06:40.060
You can actually go ahead and look at it.

00:06:40.060 --> 00:06:43.100
And it provides actually
decent speed for Core Data.

00:06:43.130 --> 00:06:45.150
We also have a store
that's a binary store,

00:06:45.150 --> 00:06:49.640
which uses an NSKeyed archiver format
to go ahead and store your data.

00:06:49.640 --> 00:06:52.280
Little bit better
performance than the XML.

00:06:52.300 --> 00:06:57.740
Now, both the XML and binary stores
use what we call atomic access.

00:06:57.890 --> 00:07:00.750
Obviously because these stores
represent an encapsulation of data

00:07:00.850 --> 00:07:05.350
is that we need to read the entire
file in when we load the store.

00:07:07.620 --> 00:07:09.830
It also means that when we save data,
we need to write the entire store out.

00:07:09.940 --> 00:07:12.700
So you can imagine if you
have a big graph of data and

00:07:12.700 --> 00:07:15.080
you want to save one thing,
change one thing, and it's in XML,

00:07:15.330 --> 00:07:19.360
we need to write the entire XML file
out or the entire binary store out.

00:07:19.480 --> 00:07:21.610
So obviously this has
performance implications and

00:07:21.610 --> 00:07:22.600
it has speed implications.

00:07:27.610 --> 00:07:28.100
So we offer another store type,
which is a SQLite store.

00:07:28.110 --> 00:07:28.600
The SQLite store does not
have these limitations.

00:07:28.600 --> 00:07:30.720
We can read it in just the small bits.

00:07:30.790 --> 00:07:33.770
It offers extremely good performance
because we can actually use

00:07:33.770 --> 00:07:36.600
some of the benefit of SQLite
to perform some operations.

00:07:38.650 --> 00:07:41.420
So for extreme scalability,
you want to go to the SQLite side,

00:07:41.420 --> 00:07:44.380
but you may want to start with the
XML store when you start working so

00:07:44.400 --> 00:07:47.710
you can actually look at the data
that Core Data is creating for you.

00:07:48.870 --> 00:07:50.840
It's important to note that just
because you start with one store

00:07:50.840 --> 00:07:52.840
doesn't mean you can't move to another.

00:07:52.990 --> 00:07:56.440
So there is API to migrate data
from one store version to another,

00:07:56.540 --> 00:07:59.840
so you could start with XML and
end up in SQLite without having

00:07:59.840 --> 00:08:01.530
to do that much heavy lifting.

00:08:02.730 --> 00:08:06.740
One of the unsung heroes, though,
of Core Data is the in-memory store.

00:08:06.780 --> 00:08:09.170
So as the name implies,
this is a store with no

00:08:09.170 --> 00:08:10.720
physical backing on disk.

00:08:10.740 --> 00:08:12.850
So when you put stuff into
the store and you save,

00:08:12.950 --> 00:08:15.220
it's just staying in
memory where you put it.

00:08:15.220 --> 00:08:16.990
But when you think
about this for a second,

00:08:17.080 --> 00:08:19.800
this is an extremely powerful feature,
because that means all of

00:08:19.800 --> 00:08:21.980
you out there right now that
have existing file formats,

00:08:21.980 --> 00:08:24.780
existing pieces of data,
can actually go ahead and create

00:08:25.150 --> 00:08:28.360
managed objects out of those and
put them into the in-memory store.

00:08:28.390 --> 00:08:31.160
So you can take your persistent file,
put it in an in-memory store,

00:08:31.170 --> 00:08:33.380
and take all the benefits of
Core Data-- undo management,

00:08:33.380 --> 00:08:36.080
integration with Cocoa bindings,
everything you need.

00:08:36.080 --> 00:08:38.580
And then when you use the
framework to get the notifications

00:08:38.860 --> 00:08:41.570
when your information is saved,
you can go ahead and

00:08:41.570 --> 00:08:43.040
write that stuff back out.

00:08:43.090 --> 00:08:44.920
So this is one way you
can leverage Core Data,

00:08:44.920 --> 00:08:47.560
even if you have an
existing file format today.

00:08:48.580 --> 00:08:51.680
So there's the question of, well,
how many stores do I want to use?

00:08:51.820 --> 00:08:54.400
So there are applications
like iTunes and Address Book,

00:08:54.490 --> 00:08:55.860
where it's a collection of data.

00:08:55.920 --> 00:08:58.160
All the data is stored in one place,
and in some cases,

00:08:58.160 --> 00:08:59.500
it's related to one another.

00:08:59.550 --> 00:09:01.620
Core Data allows you to do that very,
very easily.

00:09:01.620 --> 00:09:04.350
But when you think about it,
these applications also use

00:09:04.350 --> 00:09:06.760
many stores collaboratively.

00:09:06.810 --> 00:09:08.210
You share your Address Books.

00:09:08.270 --> 00:09:10.320
You share your iTunes music.

00:09:10.410 --> 00:09:13.370
So it's using the same blueprint of data,
the same kind of data,

00:09:13.540 --> 00:09:17.230
and putting multiple things together
so to the developer or to the user,

00:09:17.230 --> 00:09:18.780
it looks like one thing.

00:09:18.820 --> 00:09:21.660
Core Data makes this very,
very easy to do.

00:09:21.670 --> 00:09:25.510
Additionally, we also provide you the
ability to use separate stores,

00:09:25.510 --> 00:09:27.860
for example,
in a document-based application,

00:09:28.020 --> 00:09:30.100
where your information isn't
related to anything else.

00:09:30.180 --> 00:09:31.860
It's all just one piece of data.

00:09:31.900 --> 00:09:33.570
Core Data provides you that as well.

00:09:33.780 --> 00:09:35.540
And if you're interested in
document-based applications

00:09:35.540 --> 00:09:38.200
or you have one now,
there's a class called NS Persistent

00:09:38.200 --> 00:09:40.190
Document that you're going
to want to take a look at,

00:09:40.290 --> 00:09:42.540
because we've implemented a lot
of the heavy lifting for you,

00:09:42.550 --> 00:09:45.390
and you can just go ahead and
leverage that with Core Data.

00:09:46.890 --> 00:09:48.990
So then there's question of,
how many stores should

00:09:48.990 --> 00:09:50.180
I use in my application?

00:09:50.200 --> 00:09:52.800
And the answer is, it really depends on
what you're designing.

00:09:52.800 --> 00:09:55.650
So if you have an application
that's just using a small collection

00:09:55.650 --> 00:09:59.180
of data that's all interrelated,
you're going to want to use one store.

00:09:59.200 --> 00:10:02.000
But then you might want to consider,
is it necessary or is it possible

00:10:02.000 --> 00:10:03.300
to share this information?

00:10:03.300 --> 00:10:06.160
Can I have people keeping copies
of their own libraries or groups

00:10:06.160 --> 00:10:09.180
of information and having the
application pull it together?

00:10:09.190 --> 00:10:10.820
You want to consider that.

00:10:10.860 --> 00:10:13.500
When you do so,
remember about dependencies,

00:10:13.510 --> 00:10:16.360
is that when you start creating stores
that depend on other stores being there,

00:10:16.360 --> 00:10:19.320
that's where your application
gets a little more complex.

00:10:19.320 --> 00:10:20.900
So be aware about that.

00:10:20.900 --> 00:10:23.640
But then document-based stores are
really good for applications where

00:10:23.710 --> 00:10:26.150
I just want to create a document,
I want to allow my users to create

00:10:26.230 --> 00:10:28.640
things over and over and over again,
and they really don't interrelate.

00:10:31.730 --> 00:10:32.640
Let me give you an example.

00:10:32.660 --> 00:10:34.680
When we were creating our
Core Recipes application,

00:10:34.690 --> 00:10:36.160
this is an application to manage recipes.

00:10:36.160 --> 00:10:38.210
We're putting information
into the application and

00:10:38.210 --> 00:10:39.620
allow people to look at it.

00:10:39.660 --> 00:10:42.020
So the question is,
how do we design this?

00:10:42.070 --> 00:10:44.250
So we first thought about,
what about separate documents?

00:10:44.420 --> 00:10:45.700
Kind of makes sense.

00:10:45.720 --> 00:10:47.580
You're working with something like Word.

00:10:47.580 --> 00:10:50.040
You want to just create a document,
type in the recipe.

00:10:50.060 --> 00:10:51.090
All makes sense.

00:10:51.210 --> 00:10:53.960
But then we came upon the problem of,
well, what about chefs?

00:10:54.080 --> 00:10:55.790
What about the people
that create the recipes?

00:10:55.930 --> 00:10:58.160
If I have four or five
recipes from the same chef,

00:10:58.360 --> 00:10:59.810
I don't really want to have
to type in the chef name

00:10:59.910 --> 00:11:01.500
over and over and over again.

00:11:01.520 --> 00:11:04.060
Makes more sense to just type
that in once and be able to use

00:11:04.060 --> 00:11:05.740
that information over and over.

00:11:05.790 --> 00:11:09.030
So we decided to put
stuff into one store.

00:11:09.160 --> 00:11:13.150
But then we realized that even better was
a lot of people want to share recipes.

00:11:13.390 --> 00:11:15.930
So we want to be able to
have separate applications,

00:11:15.970 --> 00:11:18.420
instances, one for you, one for me,
one for somebody else.

00:11:18.440 --> 00:11:21.260
Or I could take your recipe file
and just bring it in my application

00:11:21.260 --> 00:11:22.790
and it loads it automatically.

00:11:22.940 --> 00:11:26.080
So the example that you'll find on
your CD actually is an implementation

00:11:26.080 --> 00:11:29.190
using multiple stores with one model.

00:11:30.380 --> 00:11:31.960
So I just mentioned Managed Object Model.

00:11:31.960 --> 00:11:33.840
Let's talk about that.

00:11:34.020 --> 00:11:36.510
So your Managed
Object Model is the blueprint.

00:11:36.760 --> 00:11:38.470
It's the blueprint for your data.

00:11:38.590 --> 00:11:42.260
So it helps Core Data understand
what the high-level schema is,

00:11:42.260 --> 00:11:44.350
or high-level view of your data is.

00:11:44.430 --> 00:11:48.120
And if we look at the two
top-level elements within a model,

00:11:48.250 --> 00:11:51.440
they are entities and
they are properties.

00:11:51.490 --> 00:11:54.300
Entities represent a
classification of object,

00:11:54.390 --> 00:11:57.110
if you want to think of it
as a runtime representation.

00:11:57.340 --> 00:12:01.580
And entities also have properties,
which are characteristics of entities.

00:12:01.630 --> 00:12:03.400
And a property can be one of two kinds.

00:12:03.510 --> 00:12:05.680
It can be an attribute,
which you can think of as

00:12:05.730 --> 00:12:07.690
just an instance variable.

00:12:07.780 --> 00:12:09.540
And it also has relationships.

00:12:09.610 --> 00:12:14.310
And relationships are managed
references to other entities.

00:12:14.590 --> 00:12:16.420
And those can be in the single form.

00:12:16.550 --> 00:12:19.760
So one object is related
to a single other object.

00:12:19.910 --> 00:12:23.710
Or they can be in the too-many form,
where one object is related

00:12:23.830 --> 00:12:25.850
to many other objects.

00:12:26.030 --> 00:12:28.490
Let's take a concrete example from this,
and we're going to use

00:12:28.490 --> 00:12:29.730
the idea of our recipes.

00:12:29.850 --> 00:12:33.440
So you're looking at a book of recipes,
and you've got a recipe here.

00:12:33.520 --> 00:12:36.580
It's got a name, it's got a chef,
it's got ingredients,

00:12:36.650 --> 00:12:38.240
and it's got a description.

00:12:38.350 --> 00:12:39.260
So how would we model this?

00:12:39.360 --> 00:12:42.620
How would we go ahead and create a
blueprint for our application to use?

00:12:42.620 --> 00:12:46.080
So the first thing we might do is say,
well, let's just create a recipe entity,

00:12:46.130 --> 00:12:47.690
and let's just put a
bunch of attributes on it.

00:12:47.880 --> 00:12:50.980
It's going to put the name,
we'll put the chef name, some directions,

00:12:51.000 --> 00:12:53.800
maybe a cooking time,
and go ahead and represent

00:12:53.830 --> 00:12:55.020
our data this way.

00:12:55.140 --> 00:12:57.680
But as we start to look at this,
we notice a couple things.

00:12:57.800 --> 00:12:59.890
First is the chef name.

00:12:59.930 --> 00:13:03.620
I just got done mentioning that if I have
a number of recipes from the same chef,

00:13:03.700 --> 00:13:06.740
I don't want to type this information
in over and over and over again.

00:13:06.760 --> 00:13:07.900
Doesn't make sense.

00:13:07.900 --> 00:13:10.410
It's very difficult if, for example,
the chef gets married and

00:13:10.440 --> 00:13:12.900
changes her last name,
I have to go and change it in every

00:13:12.900 --> 00:13:15.220
single place that that chef is placed.

00:13:15.250 --> 00:13:18.500
What we really should do is instead

00:13:41.990 --> 00:13:41.990
So, in this case,
the white line indicates that's a

00:13:41.990 --> 00:13:41.990
relationship from the recipe to the chef.

00:13:41.990 --> 00:13:41.990
And it looks to the developer
like it's another property.

00:13:41.990 --> 00:13:41.990
So, if you ask for the recipe
and you ask for its name,

00:13:41.990 --> 00:13:41.990
it will probably return you a string.

00:13:41.990 --> 00:13:41.990
But if you ask the recipe for its chef,
it's going to return you a chef entity.

00:13:42.500 --> 00:13:44.970
So, continuing to look at our recipe,
we also decided to put

00:13:44.970 --> 00:13:47.720
ingredient list on our recipe,
which doesn't make any sense at all,

00:13:48.010 --> 00:13:49.140
because it's a collection of things.

00:13:49.150 --> 00:13:51.240
It's a big grouping of things,
and we should probably

00:13:51.240 --> 00:13:52.110
separate these out.

00:13:52.140 --> 00:13:56.740
So, in this case, we're going to create a
relationship called ingredients,

00:13:56.740 --> 00:14:01.140
and ingredients is going to go to a
relationship to an ingredient entity,

00:14:01.140 --> 00:14:02.900
and the ingredient is
going to have the name,

00:14:02.900 --> 00:14:05.180
the amount, and the measure,
like teaspoons or cups.

00:14:05.790 --> 00:14:07.900
But in this case,
you see the double arrow that

00:14:07.900 --> 00:14:10.040
indicates it's a too-many relationship.

00:14:10.040 --> 00:14:12.900
So, a recipe in this case will
have many ingredients,

00:14:12.900 --> 00:14:13.720
but one chef.

00:14:15.570 --> 00:14:18.430
So the managed object model gives us
the ability to provide this kind of

00:14:18.510 --> 00:14:21.540
blueprint to our application to say,
this is what I want my data to look like.

00:14:21.710 --> 00:14:25.160
This is how I want my data
to be used in my application.

00:14:25.810 --> 00:14:28.140
Now, it's important to remember,
I just talked about

00:14:28.200 --> 00:14:29.640
too many relationships.

00:14:29.720 --> 00:14:32.940
Too many relationships are
returned to you as sets.

00:14:32.960 --> 00:14:35.240
They are not returned to you as arrays.

00:14:35.240 --> 00:14:36.130
Think about that.

00:14:36.340 --> 00:14:36.820
They're sets.

00:14:36.880 --> 00:14:38.310
They're completely unordered.

00:14:38.370 --> 00:14:40.790
So if order is important to you,
you need to consider that when

00:14:40.790 --> 00:14:43.460
you create relationships and
when you create your entities.

00:14:43.480 --> 00:14:46.300
And you'll hear more on that
in some of the later sessions.

00:14:47.190 --> 00:14:48.370
So what happens at runtime?

00:14:48.470 --> 00:14:52.260
We take this blueprint,
we grab some of the data from the store,

00:14:52.260 --> 00:14:54.060
and we actually go ahead and
create something that if you

00:14:54.060 --> 00:14:57.180
printed the description out,
it would look like this.

00:14:57.270 --> 00:14:59.340
So this may look like a little
bit of a gnarly information,

00:14:59.340 --> 00:15:00.760
but it's basically saying,
this is a recipe.

00:15:00.840 --> 00:15:02.420
It's an entity for Core Data.

00:15:02.470 --> 00:15:03.800
And you can see it has some attributes.

00:15:03.860 --> 00:15:05.830
It has a name,
and it has some cooking time.

00:15:05.900 --> 00:15:09.120
And you'll see that in certain places,
like the ingredients and the chef,

00:15:09.160 --> 00:15:11.900
it looks like it's
referencing another entity.

00:15:11.970 --> 00:15:14.810
So this is how your information
will look when you work with it.

00:15:15.980 --> 00:15:18.060
If you spent more time on this model,
you might get something

00:15:18.140 --> 00:15:20.470
that looks like this,
which is the representation as

00:15:20.490 --> 00:15:23.720
you'll see it within Xcode when
you design a Core Data model.

00:15:23.790 --> 00:15:26.040
So you can see here,
you can create a relatively sophisticated

00:15:26.040 --> 00:15:29.740
view of recipes and cuisines,
ingredients and measures,

00:15:29.820 --> 00:15:31.700
all sorts of things.

00:15:32.260 --> 00:15:34.570
If you want to take a look at this
in the Core Recipes application,

00:15:34.570 --> 00:15:37.120
there's a Core Recipes model that'll
give you a complete view of what

00:15:37.120 --> 00:15:39.430
we created for our application.

00:15:40.570 --> 00:15:42.940
And it's important to note that a
model actually does more than just

00:15:43.060 --> 00:15:44.460
define entities and attributes.

00:15:44.510 --> 00:15:46.500
It actually defines quite a bit more.

00:15:46.530 --> 00:15:49.080
You can define default attribute values.

00:15:49.160 --> 00:15:50.940
For example,
every time I create a recipe,

00:15:50.980 --> 00:15:53.940
I want the name to automatically
start out as new recipe.

00:15:54.140 --> 00:15:56.900
This is great for giving users
hints on things they need to change.

00:15:56.940 --> 00:15:59.750
It's also great for filling out
attributes that they may want to change,

00:15:59.750 --> 00:16:01.350
but in most cases, they don't need to.

00:16:01.410 --> 00:16:05.010
So you can provide them the benefit
of not having to change those values.

00:16:05.160 --> 00:16:07.660
The model also provides you with
the ability to set up rules,

00:16:07.740 --> 00:16:10.680
things like validation rules,
what things have to be there,

00:16:10.700 --> 00:16:14.310
has to be between a certain value
range to be able to be saved.

00:16:14.420 --> 00:16:15.820
Things like deletion rules.

00:16:15.870 --> 00:16:19.140
If I delete a recipe,
should I delete the chef too?

00:16:19.180 --> 00:16:21.950
Answering some of those questions and
even customizing the model to store

00:16:22.020 --> 00:16:26.530
custom information that you want to use
in your application based on the entity.

00:16:28.600 --> 00:16:32.810
All models are represented by a class
called the NSManagedObjectModel.

00:16:32.840 --> 00:16:34.980
You can create these in Xcode,
but you can also create

00:16:35.070 --> 00:16:36.080
them programmatically.

00:16:36.080 --> 00:16:38.220
And there are some number of
examples where we do create

00:16:38.250 --> 00:16:41.680
models programmatically and the
number of benefits to doing that.

00:16:42.960 --> 00:16:47.030
I can't stress this enough though,
is that your model is absolutely critical

00:16:47.670 --> 00:16:49.080
to the success of your application.

00:16:49.180 --> 00:16:51.580
When you think about it,
it's the contract between you and

00:16:51.580 --> 00:16:55.560
Core Data that sets up guidelines
and policies for how things work.

00:16:55.670 --> 00:16:58.840
It sets up how your data is
related and how data interacts.

00:16:58.920 --> 00:17:01.740
It also helps the framework
maintain integrity on what things

00:17:01.740 --> 00:17:03.500
are supposed to be in what ways.

00:17:03.600 --> 00:17:05.800
So your model is really,
really important.

00:17:05.870 --> 00:17:10.460
Your model needs to be designed with
both function and performance in mind.

00:17:10.550 --> 00:17:12.120
So when you think about
designing a model,

00:17:12.270 --> 00:17:15.740
think about what does my information
look like and how do I want to use it?

00:17:15.740 --> 00:17:18.520
You can imagine if you put all of
your attributes in a single entity,

00:17:18.520 --> 00:17:20.900
it makes it very easy to get at,
because you can just fetch one

00:17:21.200 --> 00:17:22.560
thing and it's all right there.

00:17:22.620 --> 00:17:25.440
But from a performance perspective,
that's not really good for searching.

00:17:25.480 --> 00:17:27.510
Because if I want to search
on just one thing and see some

00:17:27.560 --> 00:17:31.190
quick references in a table view,
I've got to fetch the entire entity back.

00:17:31.260 --> 00:17:34.510
So you want to think about both
performance and function for your

00:17:34.600 --> 00:17:35.980
model when you're creating them.

00:17:36.000 --> 00:17:38.890
And there'll be more on this
in some of the later sessions.

00:17:39.170 --> 00:17:40.140
But never fear.

00:17:40.160 --> 00:17:43.100
The more complicated your model,
the better Core Data does.

00:17:43.120 --> 00:17:45.560
Trust me, the framework is really
good at dealing with models.

00:17:45.600 --> 00:17:47.230
And the more complex
things you can throw at us,

00:17:47.380 --> 00:17:49.340
the more power you're going
to see out of the framework.

00:17:49.380 --> 00:17:51.900
So don't be afraid to create something
that looks a little scary if it's

00:17:51.900 --> 00:17:54.070
really what your application needs.

00:17:55.450 --> 00:17:57.240
So I'm going to get this out of the way.

00:17:57.250 --> 00:18:00.360
What about making changes to my model?

00:18:00.550 --> 00:18:03.560
So when you create a model,
as I said before, it's a blueprint.

00:18:03.570 --> 00:18:06.450
And we use that to go ahead and
create the underlying store.

00:18:06.670 --> 00:18:09.170
If you go ahead and you create
a blueprint and you use that

00:18:09.170 --> 00:18:13.160
blueprint to put data into a store,
application works just fine.

00:18:13.160 --> 00:18:15.700
Now you go ahead and you
make changes to the model.

00:18:15.720 --> 00:18:18.140
And then you start your
application back up.

00:18:18.190 --> 00:18:19.990
Core Data now says, huh?

00:18:21.700 --> 00:18:23.520
Because the Blueprint is now different.

00:18:23.570 --> 00:18:26.480
It now expects something completely
different based on the Datastore

00:18:26.480 --> 00:18:29.480
does not match the Blueprint,
and we get a little confused.

00:18:29.560 --> 00:18:30.220
So consider that.

00:18:30.220 --> 00:18:32.040
It's actually something good to
consider when you actually just

00:18:32.040 --> 00:18:34.060
create your own application,
about versioning.

00:18:34.060 --> 00:18:35.060
I create version 1 today.

00:18:35.060 --> 00:18:37.430
I'm going to create version
2.0 maybe six months from now,

00:18:37.450 --> 00:18:39.150
and my data may look very different.

00:18:39.350 --> 00:18:40.500
How do I deal with that?

00:18:40.640 --> 00:18:42.760
How do I deal with the fact that
my model may need to change,

00:18:42.760 --> 00:18:45.000
and my application may need
to be smart enough to say,

00:18:45.050 --> 00:18:46.600
this is what my data was before.

00:18:46.810 --> 00:18:49.370
This is what my data looks like now.

00:18:49.790 --> 00:18:50.500
You're just in luck.

00:18:50.500 --> 00:18:53.540
We actually happen to have sample code
that actually deals with some of this.

00:18:53.540 --> 00:18:55.420
There's an example called the migration.

00:18:55.420 --> 00:18:58.860
It has a generator and a migrator,
which actually will generate

00:18:58.860 --> 00:19:00.580
some data in one model,
create a new model,

00:19:00.580 --> 00:19:02.900
and show you how to migrate
the data from one to the next.

00:19:02.900 --> 00:19:05.310
So please feel free to
take a look at that.

00:19:06.010 --> 00:19:06.780
But enough of my talking.

00:19:06.780 --> 00:19:09.360
Let's actually look at a real
demonstration of building a model.

00:19:09.380 --> 00:19:11.340
And so for that,
I'm going to invite Adam Swift,

00:19:11.340 --> 00:19:13.670
a Core Data engineer,
to show you creating

00:19:13.770 --> 00:19:15.120
a model within Xcode.

00:19:15.120 --> 00:19:16.520
Adam?

00:19:19.800 --> 00:19:26.900
Okay, so we've got recipes and we want to
build an application to manage them.

00:19:27.110 --> 00:19:31.940
So I'm going to open up Xcode 2.1,
which provides some tools to do that.

00:19:31.950 --> 00:19:34.360
There are a variety of
templates for projects.

00:19:34.390 --> 00:19:37.400
I'm going to choose the
Core Data Application project because

00:19:37.400 --> 00:19:40.110
this isn't a document-based project.

00:19:43.110 --> 00:19:46.430
The first thing we see when
we open up the project is it's

00:19:46.430 --> 00:19:51.160
created some code in the classes,
some models, and some other resources

00:19:51.250 --> 00:19:53.140
that I'll use later.

00:19:54.120 --> 00:19:55.900
For now, I want to create the model.

00:19:55.990 --> 00:19:59.500
So the first step is to open
up the Model Design Tool.

00:19:59.830 --> 00:20:03.300
And you can see this window is
divided into two major parts.

00:20:03.300 --> 00:20:05.690
At the bottom,
we've got a graphical view,

00:20:05.740 --> 00:20:09.480
which shows a sort of bird's
eye view of our data model.

00:20:09.510 --> 00:20:11.320
I'll bring that up a little closer.

00:20:11.410 --> 00:20:15.020
And then in the top half,
we've got some detailed lists and tables,

00:20:15.070 --> 00:20:19.600
which allow us to edit the data model.

00:20:19.860 --> 00:20:22.170
A lot of these controls,
and you can see there

00:20:22.170 --> 00:20:24.730
are a lot on screen,
are available through the menu

00:20:25.250 --> 00:20:28.500
using the design data model menus.

00:20:29.750 --> 00:20:32.560
To make it a little easier
to follow what I'm doing,

00:20:32.560 --> 00:20:36.940
I've customized the toolbar on
this window to add the entity,

00:20:36.940 --> 00:20:40.850
add attribute,
and add relationship buttons.

00:20:43.710 --> 00:20:50.290
So the first thing we want to model
with our recipes is the recipe itself.

00:20:50.340 --> 00:20:52.920
And as Matt described, that's an entity.

00:20:52.990 --> 00:20:54.370
So I'm going to create an entity here.

00:20:54.400 --> 00:20:57.990
I'll go ahead and rename that.

00:21:00.310 --> 00:21:05.200
And you can see in the entity list
that name change is reflected.

00:21:05.200 --> 00:21:08.270
And the first thing I want
to do with this is add the

00:21:08.340 --> 00:21:11.580
attributes that define my recipe.

00:21:11.580 --> 00:21:15.780
The most obvious would
be the recipe name.

00:21:17.890 --> 00:21:21.080
Now,
when I select the recipe entity here,

00:21:21.080 --> 00:21:24.850
you can see in the property list it
has the name listed as an attribute,

00:21:25.010 --> 00:21:28.100
but the type is not defined.

00:21:28.200 --> 00:21:32.000
The name should be a string,
so I'm going to go ahead and set that.

00:21:34.130 --> 00:21:39.210
Some other attributes of a
recipe are the directions and

00:21:39.210 --> 00:21:40.590
the last time I prepared it.

00:21:40.640 --> 00:21:44.430
I'll go ahead and set those.

00:21:52.920 --> 00:21:55.910
Directions is another string.

00:21:55.910 --> 00:21:59.960
And the last prepared date
I'll configure as a date.

00:22:01.720 --> 00:22:03.320
So that's a start.

00:22:03.360 --> 00:22:08.520
Now another part of my model,
the data of my recipes, is the chefs.

00:22:08.580 --> 00:22:12.020
And we decided that a chef
is a complicated enough piece

00:22:12.050 --> 00:22:15.840
of the model that I wanted to
make it an entity all its own.

00:22:15.900 --> 00:22:17.840
And also, I want to add the ingredients.

00:22:17.840 --> 00:22:23.470
I'll go ahead and rename these.

00:22:29.230 --> 00:22:33.150
And I'll set up the chef
with a first and last name.

00:22:40.400 --> 00:22:43.380
And one of the nice features
of the tool here is if I select

00:22:43.380 --> 00:22:47.030
both of these attributes,
I can modify their type

00:22:47.350 --> 00:22:50.190
together to set them to string.

00:22:52.030 --> 00:22:55.500
For the ingredient,
something like one cup of sugar,

00:22:55.520 --> 00:23:01.110
I need to add the amount, the name,
and the measure.

00:23:09.160 --> 00:23:12.060
The amount is a number,
so I'll select decimal.

00:23:12.090 --> 00:23:13.550
Name is a string.

00:23:13.610 --> 00:23:18.630
And again, measure something like a cup
or a tablespoon is a string.

00:23:19.390 --> 00:23:21.620
So now I've got my major entities here.

00:23:21.620 --> 00:23:24.480
I'm using a simpler model
than Matt suggested for

00:23:24.550 --> 00:23:25.890
the purpose of the demo.

00:23:26.160 --> 00:23:29.360
But the recipe doesn't know its chef,
and the recipe doesn't

00:23:29.360 --> 00:23:30.820
know its ingredients.

00:23:30.850 --> 00:23:32.990
So I'm going to use a--

00:23:33.150 --> 00:23:39.430
The button here on top to add a
relationship to Chef from recipe.

00:23:39.880 --> 00:23:43.440
And you can see in the property list,
it's created a new entry

00:23:43.480 --> 00:23:45.810
here called New Relationship.

00:23:46.520 --> 00:23:52.230
I'm going to rename that Chef,
and I want my Chef relationship

00:23:52.390 --> 00:23:54.580
to be to the Chef entity.

00:23:54.600 --> 00:23:57.570
And you can see when I select the entity,

00:23:57.660 --> 00:24:02.970
updated the graphical view below with
an arrow connecting recipe to chef.

00:24:04.680 --> 00:24:06.530
To connect the ingredients,
I'm going to use another

00:24:06.660 --> 00:24:11.850
feature of the graphical tool,
which allows me to draw the

00:24:11.870 --> 00:24:15.880
connection from recipe to ingredient,
where it automatically fills

00:24:15.880 --> 00:24:21.000
in the destination entity
based on the connection I drew.

00:24:21.030 --> 00:24:23.540
I'll name that ingredients.

00:24:24.920 --> 00:24:30.240
And because, except for boiled water,
I always have more than one ingredient,

00:24:30.240 --> 00:24:33.500
I'm going to set that to
be a too many relationship.

00:24:33.570 --> 00:24:37.130
This means that a single recipe
will have multiple ingredients,

00:24:37.130 --> 00:24:40.090
will be able to know about
multiple ingredients.

00:24:43.860 --> 00:24:48.080
So right now I have the basic
information for my recipe.

00:24:48.080 --> 00:24:52.600
I have a chef,
I have a list of ingredients,

00:24:52.640 --> 00:24:56.460
I've got a name and some directions,
but I want to be able to do some

00:24:56.460 --> 00:24:59.220
other things with the relationship
between the chef and the recipe.

00:24:59.220 --> 00:25:02.940
For example, if I have a chef,
I'd like to know all the recipes

00:25:02.940 --> 00:25:05.210
that the chef is responsible for.

00:25:05.210 --> 00:25:12.990
So I'm going to create a relationship
from chef to recipe called recipes.

00:25:16.910 --> 00:25:20.340
I set the destination to be recipe.

00:25:20.340 --> 00:25:25.320
And now you can see in the window below,
it's created that connection.

00:25:25.320 --> 00:25:29.620
I'm going to set that to be a
multiple-- a too many relationship.

00:25:29.620 --> 00:25:34.580
And now you can see that my chef
knows about multiple recipes.

00:25:34.580 --> 00:25:38.430
When I think about it, though,
the recipes I've got

00:25:38.660 --> 00:25:45.120
The chef-to-recipe relationship is
really two sides of the same connection.

00:25:45.590 --> 00:25:50.210
Now, one of the things I can do in
the modeling tool is to inform

00:25:50.210 --> 00:25:53.820
my model that these relationships
are really representing two

00:25:53.820 --> 00:25:55.860
sides of the same connection.

00:25:55.960 --> 00:26:00.210
And I can do that using the
inverse relationship here.

00:26:00.450 --> 00:26:03.620
When I make that change,
you can see in the graphical view

00:26:03.700 --> 00:26:08.460
that the two connections have
become one with two endpoints.

00:26:08.730 --> 00:26:11.900
It's still two relationships,
one from chef to recipe and

00:26:11.900 --> 00:26:15.480
one from recipe to chef,
but it's represented as one

00:26:15.580 --> 00:26:19.280
thing because they're connected.

00:26:21.050 --> 00:26:24.740
So I've got a basic
working model right now,

00:26:24.740 --> 00:26:27.260
and I could leave it as it is.

00:26:27.390 --> 00:26:30.510
But there's some other nice things
I can do with the modeling tool that

00:26:30.510 --> 00:26:34.440
will help me build a better interface
and help my users understand the

00:26:34.440 --> 00:26:36.550
data that they're working with.

00:26:38.140 --> 00:26:43.310
So if I select the recipe and
select the name attribute,

00:26:43.840 --> 00:26:48.500
I might want to put in a
default value for the name,

00:26:48.510 --> 00:26:51.090
such as recipe name.

00:26:51.970 --> 00:26:56.960
And I might want to enforce a rule
that the recipe has to have a name,

00:26:56.960 --> 00:27:01.220
so I can check off optional
to ensure that a recipe can't

00:27:01.340 --> 00:27:03.930
be saved without a valid name.

00:27:05.870 --> 00:27:10.900
Another thing I can do is make
my directions non-optional and

00:27:11.070 --> 00:27:15.820
also set a minimum length for the
directions to be five characters

00:27:16.710 --> 00:27:18.470
and a maximum length to be 5,000.

00:27:18.540 --> 00:27:23.460
This will assure that the directions
are always a reasonable size.

00:27:23.880 --> 00:27:31.090
I'll set a default value to say,
please fill in the directions here.

00:27:31.640 --> 00:27:34.900
And now I've got a pretty reasonable
basic model that I can work with,

00:27:34.910 --> 00:27:37.730
and I'm ready to get started on the
next step of building my application.

00:27:37.760 --> 00:27:40.850
Thanks, Matt.

00:27:47.810 --> 00:27:49.270
Thanks, Adam.

00:27:49.470 --> 00:27:52.640
So we've just seen
creating a simple model.

00:27:52.720 --> 00:27:55.640
Now the question is,
what do we do with this model?

00:27:55.730 --> 00:27:57.540
Well,
the model is one of the crucial pieces

00:27:57.740 --> 00:28:00.470
for the persistent store coordinator.

00:28:00.800 --> 00:28:04.460
The Persistent Store Coordinator is
essentially the framework's middleman.

00:28:04.550 --> 00:28:06.940
This is,
as the object is named appropriately,

00:28:07.000 --> 00:28:09.760
it coordinates moving objects
between the stores that we just

00:28:09.840 --> 00:28:14.170
saw before and the developer,
so the managed object context that

00:28:14.170 --> 00:28:15.730
we'll hear about in a little bit.

00:28:15.830 --> 00:28:18.900
We were commonly referred
to this as the PSC,

00:28:18.900 --> 00:28:22.390
so if you hear that phrase,
that's what we mean.

00:28:22.750 --> 00:28:25.260
The Persistent
Store Coordinator synchronizes access

00:28:25.860 --> 00:28:27.800
to all of the persistent stores.

00:28:27.870 --> 00:28:30.940
So this means if your application
has more than one store and you're

00:28:30.940 --> 00:28:33.600
using one persistent coordinator,
it's the one that synchronizes

00:28:33.600 --> 00:28:36.770
all the information back and
forth between those stores.

00:28:37.390 --> 00:28:41.110
When you're using a managed object
model and you're using multiple stores,

00:28:41.140 --> 00:28:45.150
you can actually specify which
stores contain which pieces of data.

00:28:45.230 --> 00:28:46.620
Now,
you could actually save the same pieces,

00:28:46.680 --> 00:28:49.360
same kinds of data across all the stores,
so you could basically create a

00:28:49.360 --> 00:28:53.500
striping design where lots of pieces
of information that all look the

00:28:53.500 --> 00:28:56.180
same are stored in different places,
but there is no support

00:28:56.270 --> 00:28:57.500
for mirroring right now.

00:28:57.590 --> 00:29:00.910
So you can't create a copy
of one store in another.

00:29:01.760 --> 00:29:03.740
So the persistent store
coordinator basically is the

00:29:03.740 --> 00:29:05.280
facade in front of the stores.

00:29:05.360 --> 00:29:07.770
So it basically works by taking
the managed object model and we

00:29:07.860 --> 00:29:09.780
plug it into the coordinator.

00:29:09.820 --> 00:29:12.400
And at this point,
the coordinator allows us

00:29:12.400 --> 00:29:14.690
to go ahead and load stores.

00:29:15.310 --> 00:29:17.270
Now, as I just said,
the managed object model represents the

00:29:17.270 --> 00:29:18.700
kind of data that we're working with.

00:29:18.700 --> 00:29:21.560
And so you can use the same
model and the same coordinator

00:29:21.970 --> 00:29:24.600
to load more than one store.

00:29:24.760 --> 00:29:26.290
So I'm going to reiterate that again.

00:29:26.390 --> 00:29:29.810
You could actually keep the same
kinds of data in multiple stores

00:29:30.100 --> 00:29:52.900
[Transcript missing]

00:29:53.420 --> 00:29:54.670
So we load one by default.

00:29:54.800 --> 00:29:56.920
But you'll note in the left-hand view,
there's this little

00:29:56.920 --> 00:29:59.310
section called imported.

00:29:59.350 --> 00:30:03.060
What we do is we've actually
defined a UTI type for our stores.

00:30:03.090 --> 00:30:05.140
And using the wonders
and powers of Spotlight,

00:30:05.200 --> 00:30:08.090
we actually create a Spotlight query
that knows how to go and find all

00:30:08.090 --> 00:30:10.260
of those stores based on the UTIs.

00:30:10.300 --> 00:30:12.480
And we automatically load them.

00:30:13.230 --> 00:30:15.790
So in essence,
what this allows you to do is take

00:30:15.840 --> 00:30:18.980
your Core Recipes application,
go ahead and put some recipes in it.

00:30:19.010 --> 00:30:22.180
Now copy your recipe
store onto a shuffle,

00:30:22.180 --> 00:30:25.340
walk over to somebody else's computer
who's using Core Recipes app,

00:30:25.350 --> 00:30:27.140
and just plug your shuffle right in.

00:30:27.250 --> 00:30:30.310
Spotlight is going to tell the
application when that store comes up,

00:30:30.310 --> 00:30:33.390
when the store is found,
and our application is automatically

00:30:33.390 --> 00:30:35.110
going to load it and bring it in.

00:30:35.170 --> 00:30:36.770
So it's a really,
really neat integration of both

00:30:36.770 --> 00:30:39.700
Spotlight and the ability to load
stores within Core Data to show you

00:30:39.700 --> 00:30:42.200
how to interact with application data.

00:30:42.770 --> 00:30:45.400
While we're talking about Spotlight,
what is this metadata thing?

00:30:45.440 --> 00:30:48.690
How many of you guys have
written Spotlight importers yet?

00:30:48.770 --> 00:30:50.690
How many of you want to?

00:30:51.630 --> 00:30:53.390
Come on,
there's got to be more than that.

00:30:53.460 --> 00:30:55.500
It's a cool thing.

00:30:55.520 --> 00:30:57.500
So Spotlight and
Core Data are complementary.

00:30:57.590 --> 00:31:00.080
They're both dealing with data,
but in very different ways.

00:31:00.120 --> 00:31:02.790
Core Data is about the data
inside of your application,

00:31:02.820 --> 00:31:04.160
all the nuts and bolts.

00:31:04.160 --> 00:31:05.940
Where Spotlight is more
about the metadata.

00:31:05.940 --> 00:31:08.390
It's these small,
interesting tidbits about your

00:31:08.390 --> 00:31:11.660
application that you want other
people to be able to search on.

00:31:11.660 --> 00:31:13.780
The Persistent
Store Coordinator provides very,

00:31:13.780 --> 00:31:18.660
very easy API to read and write metadata
that you can then use with an importer.

00:31:18.660 --> 00:31:21.090
So you can actually go ahead
and look at the NS Persistent

00:31:21.100 --> 00:31:22.340
Store Coordinator API for that.

00:31:22.480 --> 00:31:23.480
It's very, very simple.

00:31:23.610 --> 00:31:25.600
It's metadata for Persistent Store.

00:31:25.730 --> 00:31:28.380
And you can actually look in, again,
the Core Recipes application.

00:31:28.380 --> 00:31:33.190
We have a Spotlight importer target that
creates an importer for our application.

00:31:33.300 --> 00:31:35.800
Now, at this point,
I need to add a standard caveat,

00:31:35.800 --> 00:31:40.050
which is there's always a question
of how much metadata do I store?

00:31:40.170 --> 00:31:43.120
When you think about it,
if your application has a lot of data

00:31:43.120 --> 00:31:47.000
and you want to create a lot of metadata,
you now have two copies of your data.

00:31:47.030 --> 00:31:49.970
Your store may actually be very,
very big if you store a lot of metadata

00:31:49.970 --> 00:31:50.960
alongside of your regular data.

00:31:50.960 --> 00:31:52.270
data.

00:31:52.510 --> 00:31:54.940
You may be tempted to say, you know what?

00:31:55.040 --> 00:31:57.640
Maybe I don't actually store
my metadata ahead of time.

00:31:57.760 --> 00:31:59.740
Maybe I just go ahead and
create a Core Data persistence

00:31:59.740 --> 00:32:02.780
stack inside my importer,
go ahead and figure out all the data,

00:32:02.780 --> 00:32:05.260
and go and shove that off to Spotlight.

00:32:05.620 --> 00:32:07.780
You may be thinking that,
but I would encourage you not to,

00:32:08.060 --> 00:32:11.840
in that creating a persistent stack is
not necessarily an inexpensive operation,

00:32:11.960 --> 00:32:15.000
and your importers need to be very,
very thin and very, very fast.

00:32:15.100 --> 00:32:21.490
So consider very,
very carefully when you're creating your

00:32:21.490 --> 00:32:21.490
spotlight importers about how much data
you're saving and how you're doing it.

00:32:22.920 --> 00:32:24.840
So once we've got our
data from our store,

00:32:24.840 --> 00:32:26.360
and we've got it through
the persistent store query,

00:32:26.360 --> 00:32:27.800
now we want to do something with it.

00:32:27.800 --> 00:32:29.300
So how do we do that?

00:32:29.300 --> 00:32:31.960
We do that through the
managed object context.

00:32:31.980 --> 00:32:34.090
And the managed object context is,
as it says,

00:32:34.120 --> 00:32:36.000
it's a drafting table for your data.

00:32:36.030 --> 00:32:38.220
This is the workspace of the framework.

00:32:38.420 --> 00:32:40.050
When you ask for objects
from the framework,

00:32:40.180 --> 00:32:42.170
it's going to give them to you
in a managed object context.

00:32:42.380 --> 00:32:44.630
When you want to save them or you
want to revert them or undo them,

00:32:44.810 --> 00:32:46.980
you do so in a managed object context.

00:32:47.050 --> 00:32:50.340
And the context is kind of the gatekeeper
of all the notifications that happen when

00:32:50.380 --> 00:32:52.360
things get saved or things get deleted.

00:32:52.390 --> 00:32:54.400
That's where you're going to get them.

00:32:54.420 --> 00:32:57.280
You should consider it a scratch
pad for working with your data,

00:32:57.330 --> 00:32:59.950
because you can undo and revert
changes at any time you want.

00:33:00.140 --> 00:33:03.620
So you can go ahead and make five, six,
or seven changes, back out three of them,

00:33:03.860 --> 00:33:06.080
make a couple more,
and then throw them all away.

00:33:06.130 --> 00:33:09.740
So it really is the place where you do
a lot of your manipulation of your data.

00:33:09.760 --> 00:33:11.510
We commonly refer to this as the Mach.

00:33:11.690 --> 00:33:15.400
So you have two terms, Mach and PSC.

00:33:16.880 --> 00:33:19.100
So when we think about it,
we're going to talk about going ahead

00:33:19.100 --> 00:33:20.920
and grabbing data from our object store.

00:33:20.920 --> 00:33:24.780
The persistent store coordinator is
going to go ahead and take those objects,

00:33:25.030 --> 00:33:26.790
hand them over,
and put them into the Manage

00:33:26.790 --> 00:33:28.360
Object Context for us to use.

00:33:28.400 --> 00:33:30.680
Now we can go ahead and we
can create changes with these,

00:33:30.680 --> 00:33:34.590
make changes, add new ones, delete them,
and at any point in time, to reiterate,

00:33:34.700 --> 00:33:36.440
we can go ahead and
just throw those away.

00:33:36.470 --> 00:33:38.740
Don't want those, just throw them away.

00:33:38.740 --> 00:33:42.090
However, we can also keep those changes,
tell the context to save,

00:33:42.100 --> 00:33:45.000
which in turn is going to hand them back
to the persistent store coordinator,

00:33:45.050 --> 00:33:47.920
and it's going to go ahead and just
put those right back into our store.

00:33:47.950 --> 00:33:49.200
It really is that simple.

00:33:49.300 --> 00:33:52.210
And it's all just telling the Manage
Object Context what you want to

00:33:52.480 --> 00:33:54.300
save and when you want to save it.

00:33:55.700 --> 00:33:57.240
We've talked about multiple stores.

00:33:57.370 --> 00:34:00.900
Let's talk about multiple
Managed Object Contexts.

00:34:00.990 --> 00:34:03.150
So in this case,
you'll see we have lots of stores here.

00:34:03.240 --> 00:34:07.500
But you can go ahead and use multiple
mocks when you create your application.

00:34:07.520 --> 00:34:10.280
Now you may have a question of
why would I want to do that?

00:34:10.320 --> 00:34:12.760
Well, let's take another example
of our Recipes application.

00:34:12.940 --> 00:34:15.480
We have an interface that
lists all of our recipes.

00:34:15.480 --> 00:34:17.520
But I want to go ahead and
double-click on a recipe,

00:34:17.530 --> 00:34:20.280
and I can look at it,
and I can make modifications.

00:34:20.310 --> 00:34:25.360
We use one Managed Object Context
per Editor window for a recipe.

00:34:25.420 --> 00:34:28.060
Now the benefit to this is that
we can edit any recipe we want

00:34:28.490 --> 00:34:32.540
and save it and know that we're
just saving that piece of data.

00:34:32.600 --> 00:34:35.880
You can imagine that if we started out,
we had one Managed Object Context,

00:34:35.930 --> 00:34:37.760
and I say I want to
work with three recipes.

00:34:37.820 --> 00:34:39.120
I open up each one.

00:34:39.170 --> 00:34:42.020
I make changes to two of them
that I'm not quite done with.

00:34:42.060 --> 00:34:42.780
I open up a third.

00:34:42.780 --> 00:34:45.200
I make the changes I want, and I save.

00:34:45.200 --> 00:34:47.500
You're saving the third one
because you're done with that,

00:34:47.500 --> 00:34:50.570
but you're also saving the
other two because they're in

00:34:50.570 --> 00:34:52.070
your Managed Object Context.

00:34:52.160 --> 00:34:56.010
So you want to use multiple Managed
Object Contexts when you want to

00:34:56.010 --> 00:34:59.700
segregate your work so that you can work
on separate things in separate places,

00:34:59.850 --> 00:35:03.500
and then you can commit your data
at whenever point in time you want.

00:35:03.670 --> 00:35:05.710
Now there's some heady things
that go along with this about what

00:35:05.710 --> 00:35:09.800
happens if I'm working with the same
object in multiple contexts at once.

00:35:09.920 --> 00:35:13.510
Framework really knows what to do,
so don't be worried about that.

00:35:14.860 --> 00:35:16.520
So we've talked about the
persistent-stork-reward-enter.

00:35:16.520 --> 00:35:18.340
We've talked about the
manage-object-context.

00:35:18.340 --> 00:35:20.020
Let's talk about fetch requests.

00:35:20.020 --> 00:35:21.720
And fetch requests are
how you get objects,

00:35:21.740 --> 00:35:23.500
how you find them.

00:35:23.660 --> 00:35:26.300
So the fetch request is, as it states,
it's kind of the bloodhound

00:35:26.470 --> 00:35:27.320
for your objects.

00:35:27.320 --> 00:35:30.490
It's your ability to specify a
query for the framework to go

00:35:30.500 --> 00:35:32.520
ahead and find things for you.

00:35:32.520 --> 00:35:35.290
Now, fetch request has three pieces
of important information.

00:35:35.410 --> 00:35:36.620
The first is the entity.

00:35:36.650 --> 00:35:39.660
So it's the piece from your
model that you're looking for.

00:35:39.850 --> 00:35:43.420
It has a set of search criteria,
the ability to specify exactly what

00:35:43.510 --> 00:35:46.160
you want to the framework so you don't
have to sort through a bunch of things.

00:35:46.300 --> 00:35:48.320
And it also has things
called sort descriptors,

00:35:48.360 --> 00:35:51.360
which allow you to sort the results when
they come back in a particular order,

00:35:51.360 --> 00:35:52.790
if you're interested.

00:35:53.070 --> 00:35:55.790
You can actually go ahead and create
fetch requests inside of the model.

00:35:55.800 --> 00:35:58.840
We didn't show you that today,
but you will see that in later sessions.

00:35:58.880 --> 00:36:02.500
So you can go ahead and templatize,
if you will, your fetch requests.

00:36:02.540 --> 00:36:04.860
And you can include variable
substitution in those.

00:36:04.920 --> 00:36:07.860
So you can make really,
really complex fetch requests,

00:36:07.920 --> 00:36:10.600
storm in your model,
and then at runtime just pull them back,

00:36:10.640 --> 00:36:12.750
substitute in your variables, and go.

00:36:12.960 --> 00:36:16.650
Now fetch requests are evaluated
in the store wherever possible.

00:36:16.760 --> 00:36:19.710
So we want to go ahead and make sure
that we're evaluating things in the

00:36:19.710 --> 00:36:22.310
place where there's the most performance.

00:36:23.090 --> 00:36:26.040
Now, one of those things that I talked
about was specifying search criteria.

00:36:26.260 --> 00:36:28.320
And we do those through
the use of predicates.

00:36:28.490 --> 00:36:30.700
How many people in the room
know about NSPredicate?

00:36:30.720 --> 00:36:32.660
How many have used them before?

00:36:32.860 --> 00:36:34.660
You guys have a bunch of reading to do.

00:36:34.880 --> 00:36:36.840
Predicates are really,
really handy things to do.

00:36:36.840 --> 00:36:38.980
And they're not useful in just Core Data.

00:36:39.030 --> 00:36:41.430
They're useful in a lot of other places.

00:36:41.450 --> 00:36:43.470
So you can create a
predicate programmatically.

00:36:43.670 --> 00:36:47.500
We talked about defining them in your
model as part of a fetch request.

00:36:47.530 --> 00:36:49.060
They're often based on user input.

00:36:49.240 --> 00:36:51.890
So you take things that the user type in,
create a predicate out of it,

00:36:51.990 --> 00:36:54.520
and go ahead and specify it
to you in your fetch request

00:36:54.520 --> 00:36:55.960
to go ahead and search on.

00:36:55.960 --> 00:36:57.940
They're used outside of Core Data,
as I just mentioned.

00:36:58.010 --> 00:37:04.240
There's API on the NSArray to go ahead
and use predicates to filter them.

00:37:04.500 --> 00:37:08.180
The metadata API, the spotlight API,
uses them heavily.

00:37:08.230 --> 00:37:10.710
So when I talked about our
application being able to go and

00:37:10.880 --> 00:37:14.000
find stores of our particular type,
we created a predicate

00:37:14.000 --> 00:37:15.590
that matches our UTI type.

00:37:15.600 --> 00:37:17.790
They're also used in the array
controllers very heavily.

00:37:17.810 --> 00:37:20.590
So if you use bindings,
go take a look at predicates.

00:37:20.660 --> 00:37:22.960
And predicates come in
three kinds of flavors.

00:37:22.980 --> 00:37:25.880
There's the abstract class NS predicate.

00:37:25.900 --> 00:37:29.340
There's the comparison predicate,
which is just doing a simple comparison.

00:37:29.520 --> 00:37:34.320
And there's also the compound predicate,
which takes multiple predicates together.

00:37:34.370 --> 00:37:36.040
So you don't necessarily
have to create this one big,

00:37:36.040 --> 00:37:38.160
long predicate that has a
bunch of information in it.

00:37:38.170 --> 00:37:41.120
You can create multiple predicates
and put them all together.

00:37:41.250 --> 00:37:43.320
So what can you do with predicates?

00:37:43.360 --> 00:37:47.680
Well, you can do simple comparisons,
like name equals soup.

00:37:47.680 --> 00:37:51.380
You can do things like case
insensitive or diacritic insensitive.

00:37:51.420 --> 00:37:52.650
You can do logical operations.

00:37:52.680 --> 00:37:55.960
So I can start looking at attributes,
first name like something

00:37:55.960 --> 00:37:57.860
or last name like something.

00:37:57.890 --> 00:37:59.520
You can use predicates for relationships.

00:37:59.540 --> 00:38:02.430
So it's not just about objects,
but you can walk across a relationship

00:38:02.550 --> 00:38:05.140
to figure out from a recipe,
I'm looking for ingredients

00:38:05.140 --> 00:38:06.200
with a certain name.

00:38:06.300 --> 00:38:09.220
Or I'm looking for ingredients
that have a certain amount.

00:38:09.220 --> 00:38:11.010
You can also do operations on them.

00:38:11.070 --> 00:38:14.950
So if our ingredients had, for example,
a price, we could go ahead and,

00:38:15.110 --> 00:38:20.730
if you look at the key path here,
sum the array of all the ingredients

00:38:20.740 --> 00:38:22.280
with their price attribute.

00:38:22.280 --> 00:38:24.250
So if we put an attribute
on the ingredients called

00:38:24.370 --> 00:38:27.090
price and filled it all out,
that operation would tell us how

00:38:27.090 --> 00:38:30.100
much all of the ingredients cost.

00:38:30.100 --> 00:38:31.800
Or actually, not how much they cost,
much they cost,

00:38:31.800 --> 00:38:35.800
but find them all the ones
that cost less than $50.

00:38:37.580 --> 00:38:39.500
If you want to look at the
application we provide you,

00:38:39.500 --> 00:38:41.740
we actually use predicates
quite extensively.

00:38:41.740 --> 00:38:43.690
The filter field at the
top uses a predicate,

00:38:43.750 --> 00:38:48.550
so we can go ahead and filter
the table view of recipes.

00:38:48.870 --> 00:38:50.790
We also include something
called a Smart Group,

00:38:50.790 --> 00:38:52.600
which shows you a group of recipes.

00:38:52.720 --> 00:38:54.550
And we've included a nice
little API to go ahead and

00:38:54.550 --> 00:38:57.740
create predicates on the fly,
so a nice little graphical interface.

00:38:57.740 --> 00:39:01.640
We use a predicate, as I said,
for using Spotlight to find our stores.

00:39:01.640 --> 00:39:03.820
And there's also something
called an inference core,

00:39:03.840 --> 00:39:06.330
which is kind of a rules
system that we've put in that

00:39:06.340 --> 00:39:07.440
uses predicates very heavily.

00:39:07.440 --> 00:39:10.130
So if you want to take a look at those,
take a look in the App Delegate or

00:39:10.190 --> 00:39:14.810
take a look in the Inference Core to
find more information about those.

00:39:14.980 --> 00:39:15.940
So enough about predicates.

00:39:15.940 --> 00:39:17.620
Let's get back to the fetch request.

00:39:17.670 --> 00:39:19.010
How does a fetch request work?

00:39:19.110 --> 00:39:21.400
So again, as I said,
the fetch request comes out,

00:39:21.420 --> 00:39:24.620
and it's going to specify an entity,
potentially a predicate,

00:39:24.650 --> 00:39:26.520
and potentially sort descriptors.

00:39:26.670 --> 00:39:28.240
So you create one of these,
and you create them in your

00:39:28.240 --> 00:39:30.680
managed object context,
and you say fetch.

00:39:30.790 --> 00:39:31.600
So what happens?

00:39:31.640 --> 00:39:34.680
Managed object context takes that,
hands it off to its

00:39:34.680 --> 00:39:37.640
persistent store coordinator,
who then goes and figures out,

00:39:37.650 --> 00:39:40.190
based on the blueprint,
which are the stores that has the

00:39:40.190 --> 00:39:42.120
kind of data you're interested in,
which stores have the

00:39:42.120 --> 00:39:46.040
entity you're interested in,
and passes the request off to those.

00:39:46.080 --> 00:39:50.330
Each one of those will actually go
ahead and perform the fetch request

00:39:50.330 --> 00:39:52.460
and get the objects that match.

00:39:53.490 --> 00:39:55.100
In return,
the stores will hand it back to

00:39:55.100 --> 00:39:57.700
the persistent store coordinator,
which coalesces all

00:39:57.700 --> 00:40:00.990
those objects together,
takes them from their persisted

00:40:00.990 --> 00:40:03.770
form into their managed object form,
and hands them back

00:40:03.770 --> 00:40:05.060
to you for you to use.

00:40:05.140 --> 00:40:07.080
So again,
the power of using multiple stores.

00:40:07.080 --> 00:40:10.120
But a fetch request is just very simply
taking a request that you had and

00:40:10.160 --> 00:40:12.590
pulling information from out of a store.

00:40:15.670 --> 00:40:18.640
So let's talk about the Managed Object.

00:40:18.870 --> 00:40:20.830
The Managed Object is
your data workhorse.

00:40:20.860 --> 00:40:25.660
It's the unit of data that
you use to work in Core Data.

00:40:25.660 --> 00:40:27.230
It's the thing that
you're going to fetch.

00:40:27.370 --> 00:40:29.000
It's the thing that
you're going to insert.

00:40:29.000 --> 00:40:31.310
It's the thing you're going to save
and the thing you're going to delete.

00:40:31.450 --> 00:40:35.030
These are the things that are created
as a result of you defining your model.

00:40:35.130 --> 00:40:38.640
So you actually create Managed
Objects yourself when you want

00:40:38.640 --> 00:40:39.970
to go ahead and insert them.

00:40:40.240 --> 00:40:43.830
The framework returns Managed
Objects to you when you fetch things.

00:40:43.890 --> 00:40:45.800
important thing to remember.

00:40:46.120 --> 00:40:48.560
Each managed object is
described by a single entity.

00:40:48.640 --> 00:40:51.260
So when you fetch something
out of the database,

00:40:51.300 --> 00:40:52.830
when you fetch something
out of your store,

00:40:52.890 --> 00:40:56.470
to be clear,
it's defined as by a single entity.

00:40:56.550 --> 00:40:59.950
It's associated with a single context.

00:40:59.960 --> 00:41:01.850
It's very important
when you think about it.

00:41:01.970 --> 00:41:04.410
When you pull a piece of information out,
your managed object,

00:41:04.410 --> 00:41:05.620
it is in one context.

00:41:05.620 --> 00:41:07.940
That's not to say you can't
work with the same piece of

00:41:07.940 --> 00:41:10.320
data in more than one context.

00:41:10.390 --> 00:41:12.750
But at that point,
you'll have two separate managed objects.

00:41:12.830 --> 00:41:15.780
So an object only is in
one context at a time.

00:41:15.840 --> 00:41:18.670
And it has a unique identifier,
unique ID.

00:41:18.740 --> 00:41:20.480
Core Data provides a basic class.

00:41:20.490 --> 00:41:23.020
It's called the NSManagedObject.

00:41:23.020 --> 00:41:26.100
And that implements both key value
coding and key value observing.

00:41:26.100 --> 00:41:29.280
How many people are familiar with key
value coding and key value observing?

00:41:29.280 --> 00:41:30.280
OK, good.

00:41:30.280 --> 00:41:33.140
We provide a base class, NSManagedObject,
that provides you a lot

00:41:33.140 --> 00:41:34.320
of facility with those.

00:41:34.320 --> 00:41:36.680
Even so far as you define
attributes and relationships,

00:41:36.680 --> 00:41:39.700
and you don't have to write any
code at all if you want to use them.

00:41:39.700 --> 00:41:42.610
We go ahead and use key value coding
based on the information in the model

00:41:42.630 --> 00:41:44.810
to allow you to get that information.

00:41:46.550 --> 00:41:49.370
When you create your objects, again,
as I said, this is the workhorse.

00:41:49.380 --> 00:41:50.490
This is where you're going
to do most of your work.

00:41:50.570 --> 00:41:53.800
So it's important to consider options,
all of your options,

00:41:53.800 --> 00:41:55.970
when you're adding smarts
to your application.

00:41:56.150 --> 00:41:59.500
So your managed objects can actually
inherit from other managed objects.

00:41:59.650 --> 00:42:01.660
So you can create a very
large inheritance hierarchy

00:42:01.660 --> 00:42:02.640
in your application.

00:42:02.820 --> 00:42:04.800
You can create your own
custom base class if you want.

00:42:04.830 --> 00:42:08.780
You could subclass NSManageObject and
implement a lot of functionality there.

00:42:08.810 --> 00:42:12.560
Or you could actually create custom
subclasses for each of your entities.

00:42:12.610 --> 00:42:15.600
So in our example before,
we could have created custom subclasses

00:42:15.680 --> 00:42:19.170
for recipe that maybe knows how to
generate the RTF for the recipe,

00:42:19.370 --> 00:42:22.700
custom classes for ingredients that know
how to do something interesting there,

00:42:22.730 --> 00:42:25.670
like put themselves in a shopping cart,
and a custom class for a chef

00:42:25.910 --> 00:42:29.180
that knows how to go find a home
page or something like that.

00:42:29.480 --> 00:42:32.040
So it's important to remember that
you have a lot of options when adding

00:42:32.070 --> 00:42:34.200
smarts to your managed objects.

00:42:34.200 --> 00:42:36.360
You can use custom managed
objects for a lot of things.

00:42:36.380 --> 00:42:38.760
Validation is a very,
very good one if you want to

00:42:38.760 --> 00:42:40.520
add custom validation rules.

00:42:40.520 --> 00:42:43.010
Working with derived values,
if you want to have a complex

00:42:43.090 --> 00:42:47.510
attribute of some kind that's
generated by another set of values,

00:42:47.580 --> 00:42:49.160
you can use those.

00:42:49.160 --> 00:42:50.540
And reacting to state changes.

00:42:50.540 --> 00:42:52.960
If something changes,
especially something that's related,

00:42:53.020 --> 00:42:54.490
you may want to do something interesting.

00:42:54.490 --> 00:42:57.490
So you may want to create
custom classes for those.

00:43:01.240 --> 00:43:03.860
What about referring to managed objects?

00:43:03.900 --> 00:43:09.310
Each managed object has related to it
something called a managed object ID.

00:43:09.650 --> 00:43:11.810
It's a unique identifier
that Core Data uses to,

00:43:12.060 --> 00:43:15.690
as it pretty much sounds like,
identify the object.

00:43:16.980 --> 00:43:19.660
What about referring to managed objects?

00:43:19.660 --> 00:43:25.400
Each managed object has related to it
something called a managed object ID.

00:43:25.400 --> 00:43:27.820
It's a unique identifier
that Core Data uses to,

00:43:27.820 --> 00:43:31.500
as it pretty much sounds like,
identify the object.

00:43:46.900 --> 00:43:50.260
So, I can save data anywhere I want,
but I can specify an identifier

00:43:50.260 --> 00:43:52.650
so my application knows
exactly what I'm referring to,

00:43:52.690 --> 00:43:56.300
when I'm referring to it,
and how to get back to it.

00:43:56.300 --> 00:44:01.180
But it's important to note
that URIs are temporary.

00:44:01.650 --> 00:44:02.600
I misspoke myself.

00:44:02.610 --> 00:44:06.590
It's important to note that the URI for
a temporary object is temporary.

00:44:06.800 --> 00:44:09.830
So if you create a new recipe
and you try to take the URI for

00:44:09.830 --> 00:44:13.550
that and hand it to someone,
if you've saved that recipe,

00:44:13.630 --> 00:44:16.980
by the time they click on it,
URI is no longer valid.

00:44:17.070 --> 00:44:22.230
So temporary object, temporary URI,
saved object, valid URI.

00:44:22.350 --> 00:44:24.120
Important thing to remember.

00:44:24.860 --> 00:44:26.590
So what I'd like to do is
actually bring Adam back up here,

00:44:26.590 --> 00:44:28.260
and we're going to show you how
to put some of these other things

00:44:28.360 --> 00:44:31.340
together and create a quick
application using Core Data.

00:44:31.340 --> 00:44:32.670
Adam?

00:44:38.150 --> 00:44:39.700
Okay.

00:44:39.840 --> 00:44:43.120
So I've done the work to
put together a decent model,

00:44:43.120 --> 00:44:46.120
and now I want to build
an interface for it.

00:44:47.070 --> 00:44:51.440
I'm going to go back to my project,
make sure I save my model.

00:44:51.490 --> 00:44:56.560
And the project builder template,
or Xcode template,

00:44:56.630 --> 00:45:02.000
for this project created
a interface file for me.

00:45:02.000 --> 00:45:03.500
I'll bring that up.

00:45:03.530 --> 00:45:07.340
And you can see there's
the project window,

00:45:07.340 --> 00:45:12.630
an empty window it created for me,
and a menu.

00:45:12.660 --> 00:45:14.900
Bring up an inspector.

00:45:17.700 --> 00:45:23.050
So what I'd really like to do,
I've spent a decent amount of time

00:45:23.160 --> 00:45:26.650
defining a pretty reasonable model here.

00:45:27.530 --> 00:45:31.380
I'll close this to focus
on the part I want to show.

00:45:31.390 --> 00:45:35.630
I'd really like to be able to take all
the information I put in about my recipe

00:45:35.710 --> 00:45:38.370
and build a model directly from that.

00:45:38.690 --> 00:45:41.000
The good news is that's
exactly what I can do.

00:45:41.280 --> 00:45:45.470
I'm going to option drag my recipe entity
from the graphical view and drop it

00:45:45.470 --> 00:45:48.020
right on the interface builder window.

00:45:49.670 --> 00:45:51.210
When I do this,
it's going to ask me what kind

00:45:51.310 --> 00:45:52.620
of interface I want to create.

00:45:52.620 --> 00:45:57.170
I want to create an interface
for managing many recipes,

00:45:57.170 --> 00:45:59.730
so I'll select many objects.

00:46:00.000 --> 00:46:02.590
And when I do this,
it's going to put together a

00:46:02.770 --> 00:46:05.300
fully working interface for me.

00:46:05.340 --> 00:46:06.260
It's really powerful.

00:46:06.260 --> 00:46:07.900
This isn't a canned thing.

00:46:07.960 --> 00:46:12.180
It's actually doing a lot of
work that I could do by hand.

00:46:17.810 --> 00:46:22.460
I'd like to explain some of the
things that happened right there.

00:46:22.490 --> 00:46:25.080
So let's look at the left side.

00:46:25.110 --> 00:46:31.080
There's a recipe array controller,
which is going to be used to provide

00:46:31.090 --> 00:46:34.690
the values from the data store.

00:46:35.380 --> 00:46:37.120
in the interface.

00:46:37.230 --> 00:46:41.250
And I defined,
if I look at what this really is,

00:46:41.250 --> 00:46:45.130
it's a basic array controller
using bindings configured

00:46:45.130 --> 00:46:47.040
to use the recipe entity.

00:46:47.040 --> 00:46:52.340
And because in my model I defined
some values like directions,

00:46:52.340 --> 00:46:57.120
when it was last prepared,
the name and the chef,

00:46:57.170 --> 00:47:01.400
it's put together a usable interface
for me including these items.

00:47:01.590 --> 00:47:02.350
Now, I can go ahead.

00:47:02.360 --> 00:47:04.170
This is a standard table view.

00:47:04.170 --> 00:47:05.640
I can reorder the items.

00:47:05.640 --> 00:47:06.430
I can resize.

00:47:06.520 --> 00:47:09.840
I can manipulate them to make my
interface look the way I'd like.

00:47:09.840 --> 00:47:17.300
And everything's going to
work just the way it should.

00:47:17.300 --> 00:47:22.080
For example, I might want to have the
name above the directions.

00:47:22.080 --> 00:47:22.080
And

00:47:36.590 --> 00:47:36.590
And there are some other parts in this
interface that I had put together for me.

00:47:36.590 --> 00:47:36.590
For example, this add button.

00:47:38.150 --> 00:47:41.330
is actually connected to
the recipe controller,

00:47:41.370 --> 00:47:43.740
so it will automatically ask
the controller to create a

00:47:43.740 --> 00:47:46.190
new recipe entity for me.

00:47:46.500 --> 00:47:49.740
is actually connected to
the recipe controller,

00:47:49.740 --> 00:47:52.140
so it will automatically ask
the controller to create a

00:47:52.140 --> 00:47:54.600
new recipe entity for me.

00:48:01.790 --> 00:48:05.900
So I think I'm ready to go ahead
and try out my application.

00:48:05.900 --> 00:48:09.060
Oh,
there's one other thing I'd like to do.

00:48:09.090 --> 00:48:12.120
The application will
automatically save when I quit,

00:48:12.160 --> 00:48:15.850
but I'd like to set up control
to save when I want to.

00:48:15.950 --> 00:48:21.720
So I'm going to connect the Save button
to the action on my application delegate.

00:48:21.720 --> 00:48:24.360
OK, now I'm ready to go.

00:48:24.450 --> 00:48:27.610
Go back to Project Xcode.

00:48:28.810 --> 00:48:31.330
Historical problem.

00:48:31.600 --> 00:48:35.800
And go ahead and build
and run my application.

00:48:35.800 --> 00:48:40.560
Okay, when I click the build and go,
it's going to compile the data model,

00:48:40.560 --> 00:48:45.490
the class files, and the interface into
a real live application,

00:48:45.610 --> 00:48:48.980
and I can go ahead and
start adding recipes.

00:48:50.660 --> 00:48:53.320
Historical problem.

00:48:53.450 --> 00:48:57.600
And go ahead and build
and run my application.

00:48:57.600 --> 00:49:02.300
Okay, when I click the build and go,
it's going to compile the data model,

00:49:02.380 --> 00:49:06.980
the class files, and the interface into
a real live application,

00:49:06.980 --> 00:49:06.980
and I can go ahead and
start adding recipes.

00:49:07.410 --> 00:49:18.110
And set the directions to ask
mom nicely to make French toast.

00:49:18.140 --> 00:49:19.460
And there we go.

00:49:19.460 --> 00:49:20.620
We've got one recipe.

00:49:20.620 --> 00:49:22.780
Let's add another one.

00:49:22.780 --> 00:49:25.730
We'll make that boiled egg.

00:49:26.380 --> 00:49:31.060
And the directions are boil and egg.

00:49:31.060 --> 00:49:32.660
OK.

00:49:32.660 --> 00:49:36.090
Now I can go ahead and hit the Save.

00:49:36.710 --> 00:49:38.390
And we'll save my data.

00:49:38.620 --> 00:49:39.010
I quit.

00:49:39.040 --> 00:49:42.750
Run my application again,
and there you go.

00:49:43.070 --> 00:49:47.090
Saved my names and recipes.

00:49:48.110 --> 00:49:53.600
So to prove that this is actually doing
something other than faking a demo,

00:49:53.600 --> 00:49:57.080
I'm going to go and look at
the data file that it created.

00:49:58.610 --> 00:50:01.410
Which by default is stored in
the application support directory

00:50:02.230 --> 00:50:04.510
under the application name.

00:50:04.740 --> 00:50:08.770
And I've chosen to use
the default data store,

00:50:09.000 --> 00:50:11.130
which is an XML file.

00:50:11.170 --> 00:50:13.040
When I bring this up,

00:50:13.420 --> 00:50:18.930
You can see there's my French toast
and there's my boiled egg.

00:50:19.880 --> 00:50:25.090
I can edit the data in here if I want to,
to say French toast.

00:50:25.380 --> 00:50:27.790
No, I want pancakes.

00:50:32.110 --> 00:50:36.680
"I save that data file,
and when I rerun my application,

00:50:36.690 --> 00:50:39.680
you can see I've got pancakes,
which I can ask mom for."

00:50:42.090 --> 00:50:46.790
So if you remember when
I set up my data model,

00:50:47.040 --> 00:50:50.440
I spent some time adding some
rules about what were required

00:50:50.570 --> 00:50:55.480
fields and what limits there were
on what data could go into them.

00:50:55.590 --> 00:51:00.870
So if I go ahead and just delete
the name and I try to save,

00:51:02.400 --> 00:51:05.660
It's going to tell me that
name is a required value.

00:51:05.660 --> 00:51:07.780
Again, this is with no code.

00:51:07.780 --> 00:51:10.160
It just followed the
rules from my data model,

00:51:10.160 --> 00:51:14.460
and thanks to bindings,
gave me some useful feedback.

00:51:14.510 --> 00:51:17.310
So I'll put that back to pancakes.

00:51:20.390 --> 00:51:24.330
And I'll change the directions to some,
I'll delete the directions.

00:51:24.380 --> 00:51:26.500
Again, if I save,

00:51:32.900 --> 00:51:37.320
It tells me that directions
is a required value.

00:51:37.350 --> 00:51:41.470
Also, if I tried to set directions
to be something short,

00:51:43.780 --> 00:51:46.560
is going to tell me that
directions is too short.

00:51:46.560 --> 00:51:49.060
That's because I set the rule
that directions had to be

00:51:49.060 --> 00:51:51.370
at least five letters long.

00:51:56.930 --> 00:51:58.400
Okay.

00:51:58.540 --> 00:51:59.520
So now I can save.

00:51:59.520 --> 00:52:03.530
And there we go.

00:52:03.860 --> 00:52:05.090
We've got a working application.

00:52:06.480 --> 00:52:07.970
Thank you, Matt.

00:52:13.540 --> 00:52:14.960
Thanks, Adam.

00:52:15.040 --> 00:52:17.790
So as you guys can see, it's very,
very easy to create a

00:52:17.790 --> 00:52:20.500
managed object model,
drag it into Interface Builder,

00:52:20.500 --> 00:52:22.320
and start creating your application.

00:52:22.360 --> 00:52:25.800
And to reiterate Adam's point,
this is not a toy application.

00:52:25.840 --> 00:52:28.100
It looks like it's not a widget
that you can't configure.

00:52:28.100 --> 00:52:29.850
This is doing the heavy lifting for you.

00:52:29.910 --> 00:52:31.680
It's taking in the
power of Cocoa bindings,

00:52:31.770 --> 00:52:34.360
the power of the array controllers,
the wonderful benefits

00:52:34.360 --> 00:52:36.860
of Interface Builder,
and all the wonderful,

00:52:37.250 --> 00:52:39.390
wonderful stuff you get
from key value coding,

00:52:39.420 --> 00:52:41.340
and just creating the interface for you.

00:52:41.370 --> 00:52:43.420
And you can imagine if you
spent just a little more time,

00:52:43.450 --> 00:52:46.050
you could create applications that
are actually pretty much fully

00:52:46.050 --> 00:52:48.500
functional to get you up and running.

00:52:50.200 --> 00:52:53.980
I want to cover two common
questions that people probably

00:52:53.980 --> 00:52:56.240
have in their mind about Core Data.

00:52:56.240 --> 00:52:57.580
I'd like to ask a question first.

00:52:57.580 --> 00:52:59.900
How many people in the
audience think they have lots

00:52:59.990 --> 00:53:01.780
of data for their application?

00:53:01.780 --> 00:53:03.550
Lots of data.

00:53:05.190 --> 00:53:07.340
So the first question
on your mind might be,

00:53:07.360 --> 00:53:10.150
is Core Data fast enough?

00:53:10.980 --> 00:53:13.400
To answer that question,
in our general performance tests,

00:53:13.400 --> 00:53:18.320
we're able to get about 30,000
objects per second in a fetch request.

00:53:18.420 --> 00:53:20.540
Now to put that in perspective,
when you think about what

00:53:20.540 --> 00:53:23.690
does 30,000 things mean,

00:53:23.790 --> 00:53:26.610
With the exception of the
completely enthused in music,

00:53:26.660 --> 00:53:29.660
that's probably more songs
than people have in iTunes.

00:53:29.660 --> 00:53:32.400
It's probably more addresses
than people have in Address Book.

00:53:32.480 --> 00:53:35.040
And for those people that actually
delete mail every now and then,

00:53:35.150 --> 00:53:38.990
it might actually be more mail
messages than people have in Mail.

00:53:39.110 --> 00:53:42.580
Now, the idea here is not to say that
we create applications that work

00:53:42.580 --> 00:53:44.320
within these particular cases.

00:53:44.440 --> 00:53:47.180
The idea is that in most
of these applications,

00:53:47.180 --> 00:53:52.240
you're typically not dealing
with 30,000 things all at once.

00:53:52.250 --> 00:53:54.260
The framework provides
you lots of benefits,

00:53:54.350 --> 00:53:58.380
lots of facilities for going ahead and
figuring out exactly what it is you want,

00:53:58.440 --> 00:54:01.610
either creating a fetch request with a
predicate that's very specific to find

00:54:01.610 --> 00:54:04.380
just the things you want to work with,
creating relationships

00:54:04.570 --> 00:54:07.500
to objects that says,
you know, I'm on this recipe.

00:54:07.500 --> 00:54:08.730
I only want these ingredients.

00:54:08.740 --> 00:54:10.380
I don't need to fetch them
all and filter through them.

00:54:11.350 --> 00:54:13.750
So the idea here is that while
we will always continue to

00:54:13.750 --> 00:54:16.170
improve performance in Core Data,
use the other API the

00:54:16.170 --> 00:54:17.310
framework gives you.

00:54:17.320 --> 00:54:20.890
Use the smarts that are in your model
to keep your working set as lean

00:54:21.070 --> 00:54:24.100
and mean as possible because you'll
get a lot of performance benefit

00:54:24.120 --> 00:54:26.960
there just by using the framework and
the way it was designed to be used.

00:54:28.390 --> 00:54:31.230
So the second question is, well,
what if I have lots of objects?

00:54:31.340 --> 00:54:33.240
Is this thing going to
require a lot of memory?

00:54:33.310 --> 00:54:35.920
Because we all know that we all
put more memory in our machines

00:54:35.920 --> 00:54:39.000
than our managers say we should,
but our users sometimes

00:54:39.000 --> 00:54:40.140
don't have as much.

00:54:40.230 --> 00:54:43.670
The framework keeps around only
the objects that are needed.

00:54:43.760 --> 00:54:47.400
So as objects are no longer needed,
we're going to go ahead and release them.

00:54:47.430 --> 00:54:49.600
And we grow the graph on demand.

00:54:49.640 --> 00:54:50.480
What does this mean?

00:54:50.480 --> 00:54:52.520
It means that as we start
to need information,

00:54:52.560 --> 00:54:54.590
we're going to go ahead and pull it in.

00:54:54.670 --> 00:55:00.860
So the framework only creates objects
when it's absolutely necessary.

00:55:00.940 --> 00:55:04.600
So for example, when Adam was going ahead
and fetching all the recipes,

00:55:04.600 --> 00:55:07.810
when the framework brings those back,
it actually does something

00:55:07.810 --> 00:55:09.040
which is create a fault.

00:55:09.130 --> 00:55:11.520
So it actually hands you the recipe,
but to the framework,

00:55:11.560 --> 00:55:12.670
it looks like a fault.

00:55:12.710 --> 00:55:15.250
It basically is an unresolved
piece of information that says,

00:55:15.320 --> 00:55:17.280
mm, they're going to want this.

00:55:17.280 --> 00:55:20.600
But until they actually ask for it,
until they actually do something with it,

00:55:20.640 --> 00:55:22.500
mm, let's only do a little bit of work.

00:55:22.610 --> 00:55:24.600
When you ask for information,
when you ask the recipe for an attribute,

00:55:24.660 --> 00:55:26.550
or a relationship,
or something interesting,

00:55:26.620 --> 00:55:28.790
we convert the fault into a real object.

00:55:28.880 --> 00:55:31.400
This means that there's one
underlying cache for all of

00:55:31.400 --> 00:55:32.470
your pieces of information.

00:55:32.570 --> 00:55:35.000
You could fetch the same
recipe 40,000 times,

00:55:35.000 --> 00:55:37.990
and there's only going to be one
underlying cache for that recipe.

00:55:38.210 --> 00:55:39.990
But we try and keep it lean and mean.

00:55:40.070 --> 00:55:44.200
So we do a lot of work for you to
keep your memory footprint low.

00:55:45.610 --> 00:55:49.380
So in summary,
burn this into your memory.

00:55:49.500 --> 00:55:50.820
Create a postcard.

00:55:50.840 --> 00:55:51.860
Make a pillowcase.

00:55:51.940 --> 00:55:52.800
Do whatever you want.

00:55:52.800 --> 00:55:56.260
But this is a very,
very important thing for Core Data,

00:55:56.270 --> 00:55:58.800
is the architecture of working
with your managed objects,

00:55:58.820 --> 00:56:01.650
working with a managed object context,
creating fetch requests

00:56:01.650 --> 00:56:03.880
that are important,
creating a managed object model-- again,

00:56:03.880 --> 00:56:07.400
I can't stress enough-- that is really,
really tuned for your application

00:56:07.460 --> 00:56:09.110
and working with the data.

00:56:09.500 --> 00:56:12.050
Lots of features,
lots of things to provide you

00:56:12.060 --> 00:56:13.550
to work with your application.

00:56:13.630 --> 00:56:16.640
The undo and redo support is really,
really handy.

00:56:16.640 --> 00:56:18.890
One of the things Adam didn't
demo was we could actually

00:56:18.890 --> 00:56:21.740
go ahead in this application,
make some changes, just hit Control-Z.

00:56:21.760 --> 00:56:23.140
It's automatically bound up.

00:56:23.230 --> 00:56:25.800
We're going to back out your changes
so you could back out anything

00:56:25.800 --> 00:56:28.150
and save at any point in time.

00:56:28.330 --> 00:56:31.180
You saw the automatic validation,
you saw the grouping and filtering,

00:56:31.250 --> 00:56:33.120
you saw the automatic storing.

00:56:33.120 --> 00:56:34.990
We didn't have to do anything
and it just automatically

00:56:34.990 --> 00:56:36.780
saved into an XML file for you.

00:56:36.800 --> 00:56:39.240
Part of that is the template code,
admittedly, but there's a lot of things

00:56:39.240 --> 00:56:41.240
the framework provides for you.

00:56:41.240 --> 00:56:43.210
And you're going to see a lot
of those later on this week.

00:56:43.270 --> 00:56:47.170
So for more information,
take a look at the sample code that's

00:56:47.170 --> 00:56:50.270
provided by the developer resources.

00:56:50.730 --> 00:56:53.140
All right at your fingertips though,
already on your Tiger machines

00:56:53.140 --> 00:56:54.710
are lots of information.

00:56:54.830 --> 00:56:56.650
Is Malcolm Crawford here?

00:56:57.780 --> 00:57:02.420
all the way over there, Malcolm Crawford,
god on high for technical documentation,

00:57:02.420 --> 00:57:04.420
writes all the
documentation for Core Data.

00:57:04.550 --> 00:57:06.600
Everyone should give him a
round of applause for us having

00:57:06.620 --> 00:57:08.890
really great documentation.

00:57:13.520 --> 00:57:15.560
All of your clapping means
that you've all read it,

00:57:15.560 --> 00:57:16.700
right?

00:57:16.700 --> 00:57:18.320
Otherwise,
you wouldn't know if it's good,

00:57:18.320 --> 00:57:20.790
so don't be liars.

00:57:21.090 --> 00:57:24.910
The other thing is there's examples
on your CD and actually on your disk.

00:57:24.930 --> 00:57:27.000
On the disk in developer
examples Core Data,

00:57:27.010 --> 00:57:28.870
outline edit, the tile puzzle,
event managers,

00:57:28.880 --> 00:57:31.970
lots of different samples of data.

00:57:31.990 --> 00:57:35.280
Also take a look at the Core Recipe
samples that we gave you on your CD.

00:57:35.280 --> 00:57:36.890
You'll see the hands-on stuff tomorrow.

00:57:36.940 --> 00:57:39.160
Who's coming to the 9
o'clock session tomorrow?

00:57:39.210 --> 00:57:39.930
Come on.

00:57:40.140 --> 00:57:41.940
Come on.

00:57:42.560 --> 00:57:43.110
You're missing out.

00:57:43.270 --> 00:57:44.620
It's going to be a fun time.

00:57:44.820 --> 00:57:47.160
Hands-on session tomorrow,
working with Command Line and

00:57:47.160 --> 00:57:48.260
GUI apps with Core Data.

00:57:48.410 --> 00:57:49.980
Also take a look at the Core Recipes app.

00:57:49.980 --> 00:57:53.980
We've done a pretty decent job of
documenting everything that's in there.

00:57:54.010 --> 00:57:56.060
And also look at the migration sample.

00:57:56.090 --> 00:57:59.420
I would also-- how many people have
used the Quick Model feature in Xcode?

00:57:59.420 --> 00:58:00.640
Anybody know that it's there?

00:58:00.650 --> 00:58:02.040
Ooh, very, very few.

00:58:02.190 --> 00:58:07.210
So as you saw, we actually took a look at
the Core Data modeling side.

00:58:07.330 --> 00:58:10.010
But there's actually a corresponding
feature for class modeling,

00:58:10.010 --> 00:58:13.460
which allows you to select something that
builds a class hierarchy and take a look

00:58:13.460 --> 00:58:16.200
at it in the same modeling construct.

00:58:16.240 --> 00:58:20.190
To do this, go into your project,
go into the Frameworks group,

00:58:20.260 --> 00:58:22.600
and find the Core Data Framework.

00:58:22.630 --> 00:58:24.980
Go back up under the Design menu
that we saw at the top.

00:58:25.080 --> 00:58:27.140
Go under Class Model and say Quick Model.

00:58:27.290 --> 00:58:32.020
And you'll get an entire class model
of the Core Data Framework hierarchy.

00:58:32.050 --> 00:58:33.600
So you can actually go ahead
and look at all the methods,

00:58:33.600 --> 00:58:34.850
see how they're all implemented.

00:58:34.920 --> 00:58:36.930
It makes it very easy for
navigating the framework.

00:58:37.030 --> 00:58:40.480
So please use the power of
Xcode to help you out with this.

00:58:40.890 --> 00:59:02.680
And there are tons of sessions
and labs for Core Data.

00:59:02.680 --> 00:59:02.680
Tomorrow morning at 9:00 is the hands-on.

00:59:02.680 --> 00:59:02.680
We have two labs tomorrow,
one at 12:00 and one at 3:30.

00:59:02.680 --> 00:59:02.680
There's more Cocoa binding
stuff tomorrow.

00:59:02.680 --> 00:59:02.680
And there's also the Cocoa and
Core Data feedback on Friday and the

00:59:02.680 --> 00:59:02.680
always popular advanced Core Data usages,
which is actually going to

00:59:02.680 --> 00:59:02.680
be really great this year.

00:59:02.680 --> 00:59:02.680
We've got a lot of really
good stuff to show you.

00:59:03.660 --> 00:59:04.710
Who to contact?

00:59:04.730 --> 00:59:06.980
Matthew Formica is the
Cocoa and Core Data evangelist.

00:59:07.040 --> 00:59:11.400
But there's also the email lists
and everybody I know files bugs.

00:59:11.450 --> 00:59:12.660
So please use the website.
WEBVTT

00:00:05.070 --> 00:00:07.450
Welcome to Best Practices
for Networking Programming,

00:00:07.460 --> 00:00:09.560
Session 133.

00:00:09.840 --> 00:00:11.000
My name is Becky Willrich.

00:00:11.000 --> 00:00:15.550
I'm the tech lead for CFNetwork
and for the NSURL technologies.

00:00:15.790 --> 00:00:18.790
And here's the scenario I want
to take you through today.

00:00:18.920 --> 00:00:19.940
You had this great idea.

00:00:19.940 --> 00:00:22.020
You have the next great web app.

00:00:22.260 --> 00:00:23.960
You finish the prototype.

00:00:24.000 --> 00:00:26.300
You showed it to the boss,
and he's stoked.

00:00:26.440 --> 00:00:27.880
He wants to ship this.

00:00:27.930 --> 00:00:31.400
Only problem is he wants
to ship it next week.

00:00:31.570 --> 00:00:32.850
So what do you do?

00:00:33.150 --> 00:00:36.450
What do you do to take this networking
application from something that

00:00:36.640 --> 00:00:40.320
works well in the lab under a
controlled networking situation

00:00:40.680 --> 00:00:43.790
and get it ready for deployment?

00:00:44.950 --> 00:00:47.840
Well, in terms of networking,
getting ready for deployment

00:00:47.840 --> 00:00:51.950
mostly means you need to get your
networking code ready for a wide

00:00:51.950 --> 00:00:53.860
variety of network configurations.

00:00:53.860 --> 00:00:57.700
You're used to running it in the lab
over a nice fast link to a server

00:00:57.700 --> 00:00:59.880
sitting right next to the client.

00:00:59.880 --> 00:01:01.770
Everything works great at that rate.

00:01:01.990 --> 00:01:05.270
But out there, once your app is deployed,
it's going to be used

00:01:05.390 --> 00:01:06.640
on slow connections.

00:01:06.640 --> 00:01:09.630
It's going to be used in places
where some bozo set up the

00:01:09.630 --> 00:01:11.520
network and it doesn't work.

00:01:11.520 --> 00:01:15.140
It's going to be used in companies
that are protected from the

00:01:15.310 --> 00:01:18.540
internet at wild with firewalls.

00:01:18.540 --> 00:01:21.540
And it's going to be used in places
where you need to use a username and

00:01:21.540 --> 00:01:23.660
password just to get to the server.

00:01:23.660 --> 00:01:25.680
That's what we're going
to be talking about today.

00:01:25.700 --> 00:01:29.540
We're going to be talking about what you
need to do to make sure your application

00:01:30.120 --> 00:01:32.600
works in all of these situations.

00:01:33.410 --> 00:01:37.140
So here's the one sentence,
one bullet answer to each of these.

00:01:37.370 --> 00:01:41.170
To deal with slow connections,
use an asynchronous download.

00:01:41.270 --> 00:01:45.960
To deal with misconfigured networks,
add Net Diagnostic support.

00:01:46.190 --> 00:01:48.850
To deal with firewalls,
make sure you support

00:01:48.850 --> 00:01:50.480
proxy configurations.

00:01:50.480 --> 00:01:55.860
And to deal with authenticated servers,
well, add support for authentication.

00:01:55.900 --> 00:01:59.790
Did I mention I'm a new mom?

00:02:01.710 --> 00:02:04.460
So this is the application we're
going to talk about and we're

00:02:04.510 --> 00:02:05.900
going to use in the prototype.

00:02:05.940 --> 00:02:07.600
It's the image client application.

00:02:07.810 --> 00:02:09.770
All it does is you type in a URL.

00:02:09.800 --> 00:02:12.440
It expects to find 100
pictures at that location,

00:02:12.440 --> 00:02:14.270
and it chooses one at
random and shows it.

00:02:14.350 --> 00:02:17.480
You can see two library
buttons at the bottom,

00:02:17.480 --> 00:02:20.350
one for CFNetwork, one for Foundation.

00:02:20.350 --> 00:02:24.440
That's just so we can choose
which loading library to use.

00:02:26.240 --> 00:02:29.520
Now, I hope you all got a chance
to pick up the sample code.

00:02:29.650 --> 00:02:32.750
When you look in that code you're
going to see an image client

00:02:32.810 --> 00:02:35.610
version for each of these different
steps that we're going to take.

00:02:35.750 --> 00:02:37.990
We're going to start out
with a first prototype.

00:02:38.130 --> 00:02:41.780
First thing we're going to do is convert
it to use asynchronous downloads.

00:02:41.900 --> 00:02:46.620
Next thing we're going to do is add
support for diagnosing network failures.

00:02:46.730 --> 00:02:48.550
Then we're going to look
at supporting proxies.

00:02:48.730 --> 00:02:50.790
Then we're going to spend
a long time on a variety of

00:02:50.790 --> 00:02:53.600
different authentication methods.

00:02:53.800 --> 00:02:57.010
And then finally we're going to crown
off with an application that's prepared

00:02:57.150 --> 00:03:00.530
for authenticating firewalls as well.

00:03:01.750 --> 00:03:04.660
Like I said, I hope you all had a chance
to download the sample code.

00:03:04.890 --> 00:03:07.700
You'll find a bunch of image
client applications there.

00:03:07.700 --> 00:03:09.200
All the code is there.

00:03:09.440 --> 00:03:13.900
I encourage you to follow along
by bringing the old step and

00:03:13.900 --> 00:03:15.180
the new step up in File Merge.

00:03:15.180 --> 00:03:19.060
And you can see exactly the
code diffs we're looking at.

00:03:19.170 --> 00:03:24.260
Now, we meant to have configuration files
on that in the sample code as well,

00:03:24.260 --> 00:03:26.220
so you can set up a server yourself.

00:03:26.360 --> 00:03:28.120
Unfortunately,
there was a glitch in pushing

00:03:28.120 --> 00:03:30.210
that out to the WWDC servers.

00:03:30.330 --> 00:03:31.900
So that's not there right now.

00:03:31.900 --> 00:03:36.010
I was just told that they're going to
do a new push sometime early next week.

00:03:36.180 --> 00:03:38.820
So I encourage you to go and get it then.

00:03:38.820 --> 00:03:41.420
Or if you'd rather,
there's a big lab tomorrow morning,

00:03:41.420 --> 00:03:43.360
Networking Lab 9:00 to noon.

00:03:43.360 --> 00:03:45.860
We can hand out the
configuration files then.

00:03:45.860 --> 00:03:48.030
I also encourage you to come
there with any networking

00:03:48.130 --> 00:03:50.060
questions that you might have.

00:03:50.060 --> 00:03:52.040
We will be there,
but there will also be a couple

00:03:52.040 --> 00:03:56.360
people from CoreOS if you have some
basic low level networking questions.

00:03:56.360 --> 00:03:58.800
And we got some people
from Cocoa coming as well,

00:03:58.860 --> 00:04:02.240
so that they can answer some
Cocoa networking questions.

00:04:03.500 --> 00:04:05.280
OK, with that,
I'm going to introduce you to

00:04:05.320 --> 00:04:07.600
the Image Client application.

00:04:07.600 --> 00:04:09.940
The architecture is real simple.

00:04:09.940 --> 00:04:11.600
We've got a window at the front.

00:04:11.600 --> 00:04:12.940
It's talking to a controller.

00:04:12.940 --> 00:04:15.440
The controller is the Image Client class.

00:04:15.450 --> 00:04:18.340
To actually perform the downloads,
it's talking to a loader

00:04:18.340 --> 00:04:19.880
class at the back end.

00:04:19.920 --> 00:04:23.770
So when Image Client detects
it needs to load a URL,

00:04:23.920 --> 00:04:26.400
it sends the load
URL message to the loader.

00:04:26.400 --> 00:04:28.380
Or if it needs to cancel
a load in progress,

00:04:28.380 --> 00:04:30.020
it calls cancel load.

00:04:30.030 --> 00:04:31.780
The loader is going to
perform the download.

00:04:31.780 --> 00:04:33.960
And when it's done,
it's going to send one of these two

00:04:33.960 --> 00:04:39.720
messages back to the Image Client,
either set image data or error occurred.

00:04:39.920 --> 00:04:42.990
But of course, we actually are showing
two different libraries.

00:04:43.050 --> 00:04:46.880
We're showing using CFNetwork or
NSURL to perform the downloads.

00:04:46.940 --> 00:04:49.600
So the actual architecture
looks like this.

00:04:49.720 --> 00:04:53.040
At any given time,
only one of the two loaders is active,

00:04:53.080 --> 00:04:56.110
but both are there
inside the running code.

00:04:56.690 --> 00:05:00.060
So that sort of begs the question,
why are there two libraries for this,

00:05:00.060 --> 00:05:00.590
right?

00:05:00.690 --> 00:05:04.350
Which library do I want to use,
CFNetwork or NSURL?

00:05:04.350 --> 00:05:07.390
And I like to explain it in terms
of the pictures on the left.

00:05:07.510 --> 00:05:10.440
NSURL provides prefab components.

00:05:10.440 --> 00:05:11.610
It's feature rich.

00:05:11.610 --> 00:05:15.520
It's got everything nice and easy
and all put together for you to use.

00:05:15.520 --> 00:05:19.090
But if what you need to do isn't
in one of the prefab components,

00:05:19.110 --> 00:05:21.540
you're kind of going to be in trouble.

00:05:21.540 --> 00:05:25.020
CFNetwork, on the other hand,
is the lower level library that

00:05:25.020 --> 00:05:26.580
the NSURL library is employing.

00:05:26.600 --> 00:05:27.740
It's more flexible.

00:05:27.950 --> 00:05:29.830
It gives you all the raw tools.

00:05:29.830 --> 00:05:32.280
But it's raw,
so you're going to have to do

00:05:32.280 --> 00:05:34.360
more work if you use CFNetwork.

00:05:34.410 --> 00:05:37.620
So I've just given you a list
here of some of the features

00:05:37.620 --> 00:05:40.240
NSURL supports that CFNetwork doesn't.

00:05:40.290 --> 00:05:43.980
We've got automatic proxy support,
a caching infrastructure,

00:05:43.980 --> 00:05:47.560
a stronger authentication and
credentials infrastructure,

00:05:47.560 --> 00:05:49.570
and integration with cookies.

00:05:49.580 --> 00:05:52.190
CFNetwork,
I've listed some of the things that

00:05:52.190 --> 00:05:56.440
you can do with CFNetwork that are,
at best, difficult to do with NSURL.

00:05:56.600 --> 00:05:59.830
You've got much finer
threading control in CFNetwork.

00:05:59.840 --> 00:06:02.280
You can configure the proxy settings.

00:06:02.280 --> 00:06:05.910
And in general, you just have a lot more
access to the details of how

00:06:05.910 --> 00:06:07.350
the download is taking place.

00:06:07.360 --> 00:06:10.270
And for those of you who don't
want to link in foundation,

00:06:10.270 --> 00:06:13.080
CFNetwork is free of the
Objective-C dependency.

00:06:13.080 --> 00:06:15.480
I should also add one more thing here.

00:06:15.480 --> 00:06:17.270
CFNetwork is open source.

00:06:17.270 --> 00:06:18.300
NSURL is not.

00:06:18.370 --> 00:06:20.860
CFNetwork is in Darwin as of Tiger.

00:06:23.670 --> 00:06:25.720
All right, so let's get into the code.

00:06:25.950 --> 00:06:29.570
Here's the loadURL method
for the NSURL loader.

00:06:29.610 --> 00:06:30.900
Real simple.

00:06:30.900 --> 00:06:32.020
It's passed a URL.

00:06:32.020 --> 00:06:34.240
It calls resource data using cache.

00:06:34.240 --> 00:06:35.620
It gets back some data.

00:06:35.620 --> 00:06:38.840
If the data is good,
it calls said image data on image client.

00:06:38.840 --> 00:06:40.840
If not, it passes back an error.

00:06:40.840 --> 00:06:42.790
Nothing to it.

00:06:43.180 --> 00:06:45.340
Here's the same code in CFNetwork.

00:06:45.350 --> 00:06:47.630
Now, I didn't need to break
this into two methods,

00:06:47.750 --> 00:06:50.750
but I went ahead and did to ease
the transition moving forward.

00:06:50.760 --> 00:06:55.080
So all loadURL does is create
an HTTP request for the URL,

00:06:55.080 --> 00:07:00.000
and then it goes off to load
request to do the actual download.

00:07:00.000 --> 00:07:02.640
Load request looks like this.

00:07:02.800 --> 00:07:06.300
create a read stream from the request,
open the stream,

00:07:06.300 --> 00:07:08.640
and then sit in a loop reading bytes.

00:07:08.640 --> 00:07:12.020
As we read the bytes,
we look at the return value.

00:07:12.040 --> 00:07:13.470
More than zero, we got data.

00:07:13.590 --> 00:07:15.180
Zero, we're done.

00:07:15.390 --> 00:07:18.790
Less than zero,
and an error has taken place.

00:07:19.410 --> 00:07:22.460
Once that's all done,
we have a little bit of cleanup code.

00:07:22.490 --> 00:07:25.890
Close the stream, release it,
set it to null.

00:07:27.700 --> 00:07:28.820
And that works.

00:07:28.820 --> 00:07:29.980
It works just fine.

00:07:29.980 --> 00:07:33.290
I can-- in the lab,
I can launch this version of imageClient,

00:07:33.300 --> 00:07:35.180
and it will load the images properly.

00:07:35.300 --> 00:07:37.960
But there are a bunch
of problems with it.

00:07:37.960 --> 00:07:41.360
It seems to hang when it's
used over a modem line.

00:07:41.560 --> 00:07:44.080
When something goes wrong,
you just get this sheet that says,

00:07:44.180 --> 00:07:47.350
something's wrong,
and there's really no recourse for the

00:07:47.460 --> 00:07:49.500
user to figure out what's going on.

00:07:49.500 --> 00:07:51.600
It'll break if used behind a firewall.

00:07:51.600 --> 00:07:54.780
And if those images are sitting
on a password protected server,

00:07:54.780 --> 00:07:57.200
it's not going to be
able to retrieve them.

00:07:57.200 --> 00:08:00.060
And those are the problems
we're going to look at solving.

00:08:00.090 --> 00:08:03.140
First thing we want to
do is add asynchrony.

00:08:03.140 --> 00:08:07.760
And on our platform,
that means integrating with the run loop.

00:08:07.800 --> 00:08:09.600
So why asynchronous?

00:08:09.600 --> 00:08:10.760
This is all basic stuff.

00:08:10.760 --> 00:08:12.320
We should all know this.

00:08:12.320 --> 00:08:15.150
Asynchronous download, if it hangs,
is going to bring up the

00:08:15.150 --> 00:08:17.380
spinning wheel of doom,
and that's bad.

00:08:17.380 --> 00:08:20.980
User actions can't take
place in that state.

00:08:21.000 --> 00:08:24.680
So we want to go
asynchronous to avoid that.

00:08:24.750 --> 00:08:28.400
And remember,
any download could be lengthy.

00:08:28.400 --> 00:08:32.400
I hear this all the time from
developers all over the place.

00:08:32.450 --> 00:08:36.140
Well,
I'm only downloading 256 bytes or 10K,

00:08:36.140 --> 00:08:39.360
and it's on a really fast server,
so I'm not going to bother.

00:08:39.360 --> 00:08:42.060
I'm not going to worry about
making this asynchronous.

00:08:42.060 --> 00:08:44.620
Well, it turns out any download
at all could be lengthy,

00:08:44.630 --> 00:08:47.860
and your program needs
to be prepared for that.

00:08:47.860 --> 00:08:49.720
Well, why could it be lengthy?

00:08:49.720 --> 00:08:51.550
Maybe you're suddenly
connected over a modem.

00:08:51.560 --> 00:08:53.650
You always figure your
app would run over a nice,

00:08:53.780 --> 00:08:56.270
fast LAN, but it's not.

00:08:56.420 --> 00:08:59.720
Or maybe the connection's fast,
it just happens that right now the

00:08:59.720 --> 00:09:02.860
user's downloading 10 gig of pictures.

00:09:03.740 --> 00:09:06.550
Or maybe the DNS server's down,
so even if you could get

00:09:06.650 --> 00:09:08.860
to the networking part,
you could download the bytes,

00:09:09.020 --> 00:09:12.240
but you're stuck waiting
for a DNS response.

00:09:12.580 --> 00:09:15.290
Or maybe that nice,
fast server is just overloaded because

00:09:15.290 --> 00:09:19.690
suddenly there are 10 million hits
when you only expected 1 million.

00:09:21.090 --> 00:09:23.940
So now why would I choose to use
the RunLoop to support asynchrony?

00:09:23.940 --> 00:09:25.670
There are some other
models you could use.

00:09:25.810 --> 00:09:28.000
The RunLoop is the one we recommend.

00:09:28.110 --> 00:09:33.510
And the main reason why is you can avoid
an extra thread in almost all cases.

00:09:33.580 --> 00:09:35.420
We'll talk about the
limitation on that in a moment.

00:09:35.420 --> 00:09:38.400
But by and large,
if you integrate with the RunLoop,

00:09:38.400 --> 00:09:39.350
no threading.

00:09:41.040 --> 00:09:44.340
You're avoiding busy waiting
from a solution like polling.

00:09:44.340 --> 00:09:47.610
You're never going to be using
the CPU unless there's actually

00:09:47.630 --> 00:09:49.640
data that needs to be processed.

00:09:49.640 --> 00:09:53.580
And perhaps most importantly, actually,
is that you will integrate well

00:09:53.580 --> 00:09:57.060
with all the other event-based
activity in your application.

00:09:57.060 --> 00:10:00.040
User events coming in,
Mach messages coming in,

00:10:00.040 --> 00:10:04.400
all of this is designed to work well
inside the context of the RunLoop.

00:10:04.460 --> 00:10:08.100
And if you play in that pool, too,
then the network events are

00:10:08.100 --> 00:10:10.970
going to come in and flow
smoothly along with the run loop.

00:10:13.040 --> 00:10:16.270
So now the caveat on
avoiding an extra thread.

00:10:16.270 --> 00:10:19.810
It is possible that you
would need an extra thread.

00:10:19.810 --> 00:10:23.320
In order to do it,
you have to be shifting bytes so fast

00:10:23.380 --> 00:10:28.440
from the networking card that the
CPU has no time to do anything else.

00:10:29.200 --> 00:10:31.300
So far,
he chooses to use an extra thread.

00:10:31.300 --> 00:10:34.020
I can't think of any other
application that actually puts

00:10:34.090 --> 00:10:35.910
enough load on the networking card.

00:10:35.910 --> 00:10:38.090
In fact,
Safari doesn't need the extra thread

00:10:38.170 --> 00:10:40.160
except in the most extreme cases.

00:10:41.640 --> 00:10:43.680
So if you think you need an extra thread,
think again,

00:10:43.680 --> 00:10:46.070
because you really have to be
shifting the bytes terribly

00:10:46.190 --> 00:10:47.400
fast for that to be an issue.

00:10:50.430 --> 00:10:52.810
Alright, so let's look at the code here.

00:10:53.030 --> 00:10:56.530
Here's the NSURL loader,
and here's the new loadURL method.

00:10:56.530 --> 00:11:00.160
We used to just call url data
and ask it directly for the data.

00:11:00.280 --> 00:11:03.600
Now instead we're going to
use the NSURL loading system.

00:11:03.600 --> 00:11:06.820
So we're going to start off
by creating a request for the

00:11:06.820 --> 00:11:08.640
URL we're going to download.

00:11:08.640 --> 00:11:12.540
Once we have that request,
we're going to create a connection.

00:11:13.040 --> 00:11:13.760
And that's it.

00:11:13.760 --> 00:11:14.370
We're done.

00:11:14.370 --> 00:11:17.670
That's going to cause the connection
to start the download right away.

00:11:17.670 --> 00:11:19.800
Now how do I get information back?

00:11:19.940 --> 00:11:22.190
That's what this delegate
argument at the end is.

00:11:22.190 --> 00:11:26.420
The delegate just specifies which object
should be informed as data arrives,

00:11:26.420 --> 00:11:28.180
and we're just passing self.

00:11:28.180 --> 00:11:30.250
So now let's look at the callbacks.

00:11:30.250 --> 00:11:33.680
Here are the three main callbacks
you need in order to process

00:11:33.680 --> 00:11:35.820
bytes coming off the connection.

00:11:35.820 --> 00:11:38.960
Did receive data tells you
when chunks of data arrive.

00:11:38.960 --> 00:11:42.740
Here we're just appending it to
immutable data to look at later.

00:11:43.040 --> 00:11:47.380
Did finish loading tells you
when a successful download

00:11:47.380 --> 00:11:49.110
of data has completed.

00:11:49.270 --> 00:11:52.600
And didFailWithError tells you
when something bad has happened.

00:11:52.610 --> 00:11:55.980
And the details are
inside this error object.

00:11:58.610 --> 00:12:03.220
Now we have to do a little bit more
work when we cancel the load now.

00:12:03.390 --> 00:12:06.570
If we've got a connection,
we need to cancel it, then release it,

00:12:06.780 --> 00:12:09.020
and then set the
instance variable to nil.

00:12:09.020 --> 00:12:10.420
Why cancel it first?

00:12:10.600 --> 00:12:13.600
Well,
any time you put something in a run loop,

00:12:13.750 --> 00:12:15.480
you have to explicitly clean it out.

00:12:15.540 --> 00:12:18.750
Just releasing it isn't enough,
because someone else may have taken a

00:12:18.750 --> 00:12:20.620
retain on it at some point or another.

00:12:20.620 --> 00:12:23.560
So when you're really done with
something like a connection,

00:12:23.560 --> 00:12:25.890
and you don't want to
receive any more callbacks,

00:12:25.940 --> 00:12:27.380
make sure to call cancel.

00:12:30.360 --> 00:12:34.080
OK, so now let's look at
the CFNet Workloader.

00:12:34.150 --> 00:12:36.540
Here's that load request method.

00:12:36.550 --> 00:12:40.230
So instead of just opening
the stream and continuing on,

00:12:40.380 --> 00:12:43.550
what we're going to do first
is set a client on the stream.

00:12:43.670 --> 00:12:47.880
The client is the object that's going to
be called as events happen on the stream.

00:12:47.880 --> 00:12:51.010
It's the same as the
delegate in the NSURL case.

00:12:51.160 --> 00:12:53.120
So we set the client,
and then we schedule the

00:12:53.120 --> 00:12:54.460
read stream on the run loop.

00:12:54.600 --> 00:12:57.560
You didn't have this option
with NSURL because it has chosen

00:12:57.640 --> 00:12:59.030
a threading model for you.

00:12:59.170 --> 00:13:01.500
But with CFNetwork,
you have a choice of where

00:13:01.500 --> 00:13:03.020
you want your stream to run.

00:13:03.190 --> 00:13:06.000
In this case, we're just going to put it
on the current run loop,

00:13:06.090 --> 00:13:09.870
and we're going to receive
events any time that run loop

00:13:09.870 --> 00:13:11.780
is running in the common modes.

00:13:11.830 --> 00:13:15.990
Having done that,
now we're ready to open and return.

00:13:16.900 --> 00:13:19.560
So now let's look at the callback.

00:13:19.600 --> 00:13:21.560
You recognize this code?

00:13:21.590 --> 00:13:24.560
This is the old synchronous
load request method.

00:13:24.650 --> 00:13:26.910
And what I've done is I've
highlighted the sections of the

00:13:26.950 --> 00:13:31.100
code that show where you're actually
processing data and making decisions.

00:13:31.200 --> 00:13:34.510
Well, what we're going to find is that
those move directly to the callback.

00:13:34.590 --> 00:13:37.600
So this first chunk where you're
reading the bytes becomes the body

00:13:37.600 --> 00:13:42.180
of the callback when we receive
the hasBytes available event.

00:13:42.490 --> 00:13:45.160
The next one is what we're
going to execute when we get

00:13:45.160 --> 00:13:46.600
the endEncountered event.

00:13:46.640 --> 00:13:49.660
And finally,
when we get the errorOccurred event.

00:13:49.760 --> 00:13:52.510
So now the callback looks like this.

00:13:54.460 --> 00:13:56.900
The highlighted chunks
of code have not changed.

00:13:56.900 --> 00:13:59.950
All we're doing is when we
get the stream event in,

00:13:59.950 --> 00:14:03.220
we're going to look at the
type of the event and execute

00:14:03.220 --> 00:14:05.430
the appropriate block of code.

00:14:07.380 --> 00:14:11.220
Now, this was the cleanup code we had
at the bottom of load request.

00:14:11.240 --> 00:14:14.430
Now that we're asynchronous,
we need to put that in the

00:14:14.440 --> 00:14:16.520
cancel load method instead.

00:14:16.560 --> 00:14:18.800
But in addition,
we need to do a little more cleanup

00:14:19.000 --> 00:14:20.530
because we're in the run loop now.

00:14:20.720 --> 00:14:24.800
So we need to clear out the client,
so we call set client null.

00:14:24.820 --> 00:14:29.780
And we need to unschedule from
the run loop we scheduled in.

00:14:29.900 --> 00:14:32.400
And with that,
I want to bring Jeremy Wild up on stage,

00:14:32.400 --> 00:14:34.880
and he's going to give you a short demo.

00:14:38.410 --> 00:14:40.130
demo one.

00:14:40.270 --> 00:14:43.520
So basically what I'm going to show
you here is just a little bit of

00:14:43.530 --> 00:14:48.210
getting familiar with the application,
kind of see how it works,

00:14:48.360 --> 00:14:51.320
how you interact with it, and so forth.

00:14:51.350 --> 00:14:53.200
Just build and go.

00:14:53.270 --> 00:14:55.980
And so this is the application
Becky was talking about.

00:14:56.090 --> 00:15:01.000
Simple place to put the URL and then
two buttons here that allow us to

00:15:01.000 --> 00:15:02.790
switch which loader is actually running.

00:15:02.800 --> 00:15:08.180
So we can tell it to use CFNetwork
loading code or use the NSURL methods.

00:15:08.580 --> 00:15:12.740
And so what we'll do is we have
a server running on this machine.

00:15:12.740 --> 00:15:17.340
It's just serving up a set of files
that's in a directory on the machine.

00:15:17.340 --> 00:15:20.220
And hopefully,
you'll get these same configuration files

00:15:20.220 --> 00:15:22.210
maybe tomorrow if you stop by the lab.

00:15:22.210 --> 00:15:26.110
And all this is all put together
for you so you can simply just run

00:15:26.110 --> 00:15:28.440
this and test your apps yourself.

00:15:28.440 --> 00:15:30.900
So I'm just going to go to HTTP.

00:15:30.900 --> 00:15:32.820
We'll go to local host.

00:15:32.960 --> 00:15:37.000
And we've got these running
on port 16,000 right now.

00:15:37.000 --> 00:15:38.480
And this is just Apache.

00:15:38.510 --> 00:15:39.920
And this is just Apache server
running in the background.

00:15:39.920 --> 00:15:43.610
So the app's going to download
new pictures every 15 seconds

00:15:43.610 --> 00:15:45.040
or something like that.

00:15:45.040 --> 00:15:46.660
We can go back and forth between the two.

00:15:46.660 --> 00:15:47.840
And that's all it does.

00:15:47.850 --> 00:15:49.710
Loading pictures, go back and forth.

00:15:49.710 --> 00:15:51.790
We're invoking the different loaders.

00:15:51.790 --> 00:15:53.930
There's nothing special going on here.

00:15:53.930 --> 00:15:58.140
So that was just a bit of an
introduction to Image Client.

00:15:58.420 --> 00:16:01.140
And we'll go through some more later.

00:16:01.140 --> 00:16:02.560
Back to Becky.

00:16:06.240 --> 00:16:08.680
Okay, so now that we've seen the
basic application and we've

00:16:08.770 --> 00:16:11.210
got it running asynchronous,
we're going to go to the next step,

00:16:11.210 --> 00:16:14.390
which is going to be
adding NetDiagnostics.

00:16:15.310 --> 00:16:17.450
So what is CFNetDiagnostics?

00:16:17.560 --> 00:16:20.600
It's new in Tiger.

00:16:21.100 --> 00:16:24.830
And the problem we're trying to address
is the problem of setting up networks.

00:16:24.850 --> 00:16:26.600
Networks are easy to misconfigure.

00:16:26.600 --> 00:16:27.880
They're fragile.

00:16:27.880 --> 00:16:32.880
If a router goes down,
that's it for the network in some cases.

00:16:32.880 --> 00:16:34.280
And it's difficult to debug.

00:16:34.280 --> 00:16:36.620
It's difficult to find
that router that's down.

00:16:38.350 --> 00:16:43.280
So what CFNetDiagnostics does is provide
you with an API that you can call when

00:16:43.280 --> 00:16:45.960
something networky has gone wrong.

00:16:46.040 --> 00:16:46.880
You don't know what.

00:16:47.010 --> 00:16:50.070
It would take a lot of code to
try and figure out what it is.

00:16:50.070 --> 00:16:53.600
So instead, call us,
and NetDiagnostics will take care of it.

00:16:53.700 --> 00:16:55.230
It's a very small API.

00:16:55.370 --> 00:16:57.430
This is all of the public calls.

00:16:58.970 --> 00:17:01.760
And when you use it,
what you're going to do is first create

00:17:01.790 --> 00:17:06.810
a net diagnostics object after some kind
of a networking failure has taken place.

00:17:06.910 --> 00:17:14.710
You can either create the
object from a stream if you're

00:17:14.770 --> 00:17:17.070
working with a failed CF stream,
or you can create it from a URL if

00:17:17.070 --> 00:17:17.070
you have failed to access a URL.

00:17:17.460 --> 00:17:22.120
You can use it to display a diagnostic
string to the user inside the context

00:17:22.140 --> 00:17:26.720
of your own application by calling
copy network status passively.

00:17:26.770 --> 00:17:32.300
Or you can call diagnose problem
interactively to lead the user

00:17:32.300 --> 00:17:37.750
out of your application to the
net diagnostics application,

00:17:37.750 --> 00:17:42.610
which will walk the user through
the basic steps of configuring the

00:17:42.610 --> 00:17:42.610
network and finding out what is wrong.

00:17:44.130 --> 00:17:47.250
So how are we going to
change the architecture here?

00:17:47.410 --> 00:17:50.660
Well, now instead of just sending
an error occurred message,

00:17:50.750 --> 00:17:53.240
the loader is going to
add an argument to that.

00:17:53.310 --> 00:17:56.980
And the argument is going to
be a CFNetDiagnostics object.

00:17:57.060 --> 00:18:01.160
That will allow the image
client to lower a sheet on the

00:18:01.160 --> 00:18:02.780
window to show the failure.

00:18:02.980 --> 00:18:06.770
And it's going to add this button,
the Network Diagnostics button.

00:18:06.980 --> 00:18:10.040
And if the user clicks on that,
it's going to bring up the

00:18:10.040 --> 00:18:13.100
NetDiagnostics application,
which will examine the network

00:18:13.400 --> 00:18:17.150
and prompt the user if it
discovers something that's wrong.

00:18:18.960 --> 00:18:20.610
So how do we do that?

00:18:20.730 --> 00:18:22.380
Here's the NSURL side.

00:18:22.560 --> 00:18:24.730
Little extra code to save the URL now.

00:18:24.740 --> 00:18:27.750
We didn't even bother to save
the URL in the simple case.

00:18:27.860 --> 00:18:29.040
Now we do.

00:18:29.200 --> 00:18:33.040
And then when we receive a did fail
with error message from the connection,

00:18:33.040 --> 00:18:38.240
we create a diagnostic object from
the URL that just failed to download.

00:18:38.530 --> 00:18:41.500
Having done that,
we pass it back to image client

00:18:41.560 --> 00:18:44.140
using error occurred loading image.

00:18:45.420 --> 00:18:48.870
On the CFNetwork loader side,
we have a stream, not a URL.

00:18:48.870 --> 00:18:51.760
So we call net diagnostics
create with streams.

00:18:51.830 --> 00:18:54.700
If we had a write stream
as well as the read stream,

00:18:54.760 --> 00:18:59.120
we would put that in the third argument,
but we only have a read stream.

00:18:59.140 --> 00:19:03.790
Once we've got the diagnostics object,
again, we just call image client.

00:19:04.170 --> 00:19:06.710
So now what does Image Client do?

00:19:06.950 --> 00:19:11.260
If you look at the diffs in File Merge,
you'll see a bunch of UI changes to

00:19:11.430 --> 00:19:13.360
bring down the sheet in the new form.

00:19:13.460 --> 00:19:15.070
But here's the heart of the matter.

00:19:15.180 --> 00:19:17.860
When the sheet is dismissed,
we're going to receive this

00:19:17.860 --> 00:19:19.550
ErrorSheetDidEnd message.

00:19:19.660 --> 00:19:21.850
And all we're going to do
is look at the return code.

00:19:21.860 --> 00:19:24.280
That'll tell us which button was clicked.

00:19:24.320 --> 00:19:28.390
And if it was the default return, well,
that means the user clicked

00:19:28.390 --> 00:19:30.000
the Diagnose button.

00:19:30.050 --> 00:19:33.430
And we're going to call
DiagnoseProblem interactively.

00:19:33.780 --> 00:19:35.720
And that's all there is to it.

00:19:35.720 --> 00:19:40.030
So now I'm going to bring Jeremy back
up here to demonstrate that.

00:19:40.910 --> 00:19:42.040
All right.

00:19:42.170 --> 00:19:45.800
So this time I'm just
going to run the same app.

00:19:45.860 --> 00:19:52.560
But this time what I'm going to do is,
you know, we got the dumb old user, me.

00:19:52.650 --> 00:19:56.200
And I'm walking along and, whoop,
I just tripped over the network.

00:19:56.260 --> 00:20:04.400
So now when I run this, though,
and I go to another server, right,

00:20:04.500 --> 00:20:08.310
I'm going to run the same app.

00:20:15.040 --> 00:20:17.120
I just-- something happened.

00:20:17.120 --> 00:20:18.120
I don't know what.

00:20:18.310 --> 00:20:21.720
So what we wanted to do and what
Becky showed you was the fact

00:20:21.720 --> 00:20:24.930
that with network diagnostics,
it'll help us get through

00:20:24.930 --> 00:20:26.560
that a little bit better.

00:20:26.600 --> 00:20:30.730
More importantly,
it offloads calls from your customers

00:20:31.350 --> 00:20:38.320
from your call center so that they can
figure some of this stuff out at home.

00:20:38.360 --> 00:20:41.300
Going to go to the same server.

00:20:46.820 --> 00:20:49.140
Okay, got a network error.

00:20:49.500 --> 00:20:53.200
Gives me this option here
to diagnose what's going on.

00:20:53.200 --> 00:20:55.390
And yeah,
I've connected to the net before.

00:20:55.560 --> 00:20:57.140
Let's go ahead and continue.

00:20:57.250 --> 00:20:59.400
Yeah, I used the Ethernet before.

00:21:00.030 --> 00:21:02.410
Yeah, I want to use the built-in one.

00:21:02.470 --> 00:21:05.700
And so it'll go off and
it's going to-- hopefully,

00:21:05.720 --> 00:21:08.920
there it goes-- starts
bringing up the green lights.

00:21:10.320 --> 00:21:13.380
And now I can get
connected to the network.

00:21:13.710 --> 00:21:15.880
Now, if we were a good app,
we would have recognized that the

00:21:15.880 --> 00:21:18.640
network configuration had changed,
and we would have automatically loaded.

00:21:18.640 --> 00:21:21.360
So hopefully you will do
that in your applications.

00:21:21.360 --> 00:21:25.620
Thank you, Becky.

00:21:28.790 --> 00:21:31.150
So I just want to highlight a
couple things that Jeremy said.

00:21:31.350 --> 00:21:34.130
First of all,
the reason why you really want to add the

00:21:34.130 --> 00:21:38.520
NetDiagnostic support is this is going
to save your helpline support calls.

00:21:38.680 --> 00:21:43.230
You're not going to have to pay
for the user calling into the

00:21:43.230 --> 00:21:48.170
site just because they forgot
to plug in the ethernet cable.

00:21:48.170 --> 00:21:50.630
And that's money in the bank.

00:21:50.630 --> 00:21:52.250
Secondly, what he mentioned about being a
good app and detecting the change,

00:21:52.250 --> 00:21:52.250
we'll get there.

00:21:52.350 --> 00:21:55.310
OK, next step is navigating firewalls.

00:21:55.380 --> 00:21:58.940
And what a firewall is is a
proxy configuration to the user,

00:21:58.940 --> 00:22:00.210
essentially.

00:22:00.320 --> 00:22:03.560
The user, when he is told by a
system administrator,

00:22:03.560 --> 00:22:06.210
or someone does it for them,
that there's a firewall in place

00:22:06.240 --> 00:22:09.620
so they have to set their proxy
settings to a particular way.

00:22:09.760 --> 00:22:12.140
They're going to do that by
going into network preferences

00:22:12.180 --> 00:22:13.860
and set the proxies there.

00:22:13.930 --> 00:22:17.890
That proxy information is then
stored inside system configuration.

00:22:17.960 --> 00:22:21.140
And as programmers,
your access to that is through the

00:22:21.160 --> 00:22:23.550
system configuration framework.

00:22:23.690 --> 00:22:25.980
And I've highlighted
a couple points there.

00:22:26.220 --> 00:22:28.970
First of all,
dynamic store copy proxies is the

00:22:28.970 --> 00:22:32.770
basic call which gets the proxy
settings and gives it to you.

00:22:32.840 --> 00:22:37.390
And secondly, in order to register for
notifications of network changes,

00:22:37.390 --> 00:22:41.700
sc_dynamic_stores is the object
that will give it to you.

00:22:43.430 --> 00:22:46.460
So with the NSURL loader,
there's nothing to do here,

00:22:46.490 --> 00:22:50.690
because NSURL always looks at
the current proxy settings,

00:22:50.690 --> 00:22:55.710
always applies them, always notices when
those settings change.

00:22:56.420 --> 00:22:59.140
However, with CFNetwork,
there's a little bit of work.

00:22:59.200 --> 00:23:01.800
There are a couple different
approaches to this in CFNetwork.

00:23:01.870 --> 00:23:03.790
What I've got up here is
the quick and dirty way.

00:23:04.080 --> 00:23:08.290
All you do is call dynamic store copy
proxies that returns a proxy dictionary.

00:23:08.460 --> 00:23:12.790
You apply it to the stream,
calling read stream set property,

00:23:12.830 --> 00:23:14.980
specifying the HTTP proxy.

00:23:15.610 --> 00:23:19.680
And this code will work fine,
but it has some limitations.

00:23:19.700 --> 00:23:21.560
It works, but it's expensive.

00:23:21.590 --> 00:23:24.430
And it's expensive because it's
going to recreate the dynamic

00:23:24.690 --> 00:23:26.860
store on the back side every time.

00:23:26.970 --> 00:23:31.240
It's going to reestablish the connection
back to system configuration every time.

00:23:31.330 --> 00:23:35.040
And it's not going to keep track
of any remembered state for you.

00:23:35.200 --> 00:23:39.210
So this is perfectly appropriate
code if you're doing just a

00:23:39.210 --> 00:23:40.590
one-off or a rare download.

00:23:40.600 --> 00:23:43.690
The only time you're going to do
a download is if the user needs to

00:23:43.780 --> 00:23:45.680
update to a new version of the app.

00:23:45.680 --> 00:23:46.740
That's fine.

00:23:46.780 --> 00:23:49.840
Or if you know that the download
is going to be very lengthy,

00:23:49.840 --> 00:23:53.000
and the length of the transfer is
going to swamp the time that it took

00:23:53.000 --> 00:23:57.040
to talk to system configuration,
then it's fine to use it in that case,

00:23:57.040 --> 00:23:57.480
too.

00:23:57.480 --> 00:23:59.780
But Image Client isn't
in either of these cases.

00:23:59.780 --> 00:24:03.620
It's in this third case where we're going
to be performing a frequent download.

00:24:03.620 --> 00:24:06.220
We're downloading every 15 seconds.

00:24:06.220 --> 00:24:08.620
This code, incidentally,
is also not appropriate for any

00:24:08.680 --> 00:24:13.160
performance-critical regions precisely
because you're losing all that remembered

00:24:13.160 --> 00:24:15.310
state and having to rebuild it.

00:24:16.390 --> 00:24:19.820
So now let's talk about the robust way.

00:24:19.840 --> 00:24:23.760
What you're going to do is first create
a single persistent dynamic store.

00:24:23.780 --> 00:24:28.710
This is going to represent your
connection back to system configuration.

00:24:28.930 --> 00:24:30.820
Once you've got it,
you're going to put it in the

00:24:30.870 --> 00:24:35.710
run loop so that it can notify
you any time the proxy changes.

00:24:36.320 --> 00:24:39.880
And at that point in the setup phase,
you're going to go and get the

00:24:40.070 --> 00:24:42.590
latest proxy settings from it.

00:24:43.870 --> 00:24:44.960
Then you just sit back and wait.

00:24:45.110 --> 00:24:49.060
If you ever get the callback telling
you that the proxy has changed,

00:24:49.090 --> 00:24:51.600
you're going to update your local copy.

00:24:51.860 --> 00:24:54.630
And then finally, when you're all done,
you need to clean up and

00:24:54.750 --> 00:24:55.960
dispose the Dynamics store.

00:24:58.700 --> 00:25:01.620
So here it is step by step in the code.

00:25:01.890 --> 00:25:03.800
Here we're just creating
the dynamic store.

00:25:03.850 --> 00:25:06.980
The context is used to specify
which object to message

00:25:07.140 --> 00:25:08.680
as changes are detected.

00:25:08.910 --> 00:25:11.330
So again, we're passing self.

00:25:13.740 --> 00:25:18.740
Now, we need to tell the dynamic store
what changes we're interested in.

00:25:18.860 --> 00:25:20.980
Well, we're interested in proxy changes.

00:25:20.980 --> 00:25:25.970
So we call dynamic store key create
proxies to get the correct key

00:25:25.970 --> 00:25:28.980
for registering for proxy changes.

00:25:29.010 --> 00:25:31.640
Once we've got that,
we marshal it into an array because

00:25:31.640 --> 00:25:33.200
that's the argument we need.

00:25:33.200 --> 00:25:36.610
Then we call dynamic store set
notification keys to tell the

00:25:36.780 --> 00:25:39.810
dynamic store that this is the key,
the proxy key is the one

00:25:39.940 --> 00:25:42.080
we're interested in watching.

00:25:42.680 --> 00:25:44.360
Then we add it to the run loop.

00:25:44.390 --> 00:25:47.370
This is a slightly different
model than the read stream

00:25:47.470 --> 00:25:48.930
calls to add to a run loop.

00:25:48.930 --> 00:25:52.350
What we have to do here is actually
fetch the run loop source out

00:25:52.350 --> 00:25:56.150
of the dynamic store and then
add the run loop source manually.

00:25:57.220 --> 00:25:58.640
Okay.

00:25:58.640 --> 00:26:01.900
So then we preload our data,
and we do that by simply calling

00:26:01.900 --> 00:26:05.480
dynamic store copy proxies,
passing the dynamic

00:26:05.720 --> 00:26:07.720
store that we just built.

00:26:09.170 --> 00:26:12.090
So now what happens
when the proxy changes?

00:26:12.210 --> 00:26:17.010
Well, we just make that same call again,
dynamic store copy proxies,

00:26:17.110 --> 00:26:19.780
and we'll get the new proxy settings.

00:26:21.510 --> 00:26:23.680
Now, how do we apply that
proxy data on the stream?

00:26:23.750 --> 00:26:27.340
Well, this is the same as the
quick and dirty way.

00:26:27.510 --> 00:26:33.360
It's just we have the proxy data sitting
in the proxy dictionary all along.

00:26:35.880 --> 00:26:38.150
So the last step,
clean it up when we're all done.

00:26:38.300 --> 00:26:44.620
So again, we need to get the run loop
source out of the dynamic store.

00:26:44.700 --> 00:26:47.240
We need to get that run loop
source out of the run loop.

00:26:47.250 --> 00:26:50.480
The way we do that is by calling
run loop source invalidate.

00:26:50.480 --> 00:26:52.780
Once we've done that,
we can do the rest of our cleanup

00:26:52.780 --> 00:26:53.840
and just release the objects.

00:26:53.900 --> 00:27:00.310
OK, and one more demo.

00:27:03.640 --> 00:27:08.220
Okay, so this one, this demo requires a
little bit of background.

00:27:08.510 --> 00:27:10.990
So what we have here is a
machine that's on its own net.

00:27:11.310 --> 00:27:13.250
It's not connected to
the network in general.

00:27:13.470 --> 00:27:15.790
I can bring up Safari,
you'll see that we don't

00:27:15.790 --> 00:27:16.780
have network connectivity.

00:27:16.780 --> 00:27:22.410
We go and we look at the network panel,
we'll see that, oh,

00:27:22.740 --> 00:27:24.280
It's on its own network.

00:27:24.630 --> 00:27:26.900
So we have no DNS, nothing.

00:27:26.900 --> 00:27:30.070
Nothing available to us.

00:27:30.170 --> 00:27:35.050
So we bring up the image client proxy.

00:27:39.000 --> 00:27:43.170
And I know that I've got
the server run over here,

00:27:43.220 --> 00:27:50.230
and if we try going to demo one, 16,000,
well, we get nothing.

00:27:50.230 --> 00:27:52.300
We get our failure, right?

00:27:52.400 --> 00:27:54.960
And I'm not going to step through that.

00:27:55.780 --> 00:28:00.300
What we're going to do is we've got a
known proxy that this guy sits behind.

00:28:00.300 --> 00:28:02.600
So we've created his firewall.

00:28:02.830 --> 00:28:05.240
We'll go set up this guy's proxy.

00:28:05.310 --> 00:28:09.160
And the proxy's just
sitting on port 18,000.

00:28:09.360 --> 00:28:11.500
We go ahead and apply it.

00:28:12.510 --> 00:28:13.470
Oh, what do you know?

00:28:13.740 --> 00:28:15.390
Foundation automatically applied it.

00:28:15.480 --> 00:28:17.310
CFNetwork automatically applied it.

00:28:17.440 --> 00:28:20.610
Simply by watching for that
key change to take place,

00:28:20.720 --> 00:28:23.090
once we hit Apply All, it picked it up.

00:28:23.180 --> 00:28:24.800
We'll go back to Foundation.

00:28:24.910 --> 00:28:26.690
We'll let it run a little bit.

00:28:26.950 --> 00:28:28.800
And we'll drop that guy again.

00:28:28.800 --> 00:28:29.830
No proxy again.

00:28:30.030 --> 00:28:33.160
And you'll notice that
he'll stop updating.

00:28:33.160 --> 00:28:38.710
So there you have it.

00:28:38.730 --> 00:28:41.680
He fails.

00:28:51.400 --> 00:28:57.760
to the slides.

00:28:57.760 --> 00:28:58.240
All right, so the next step is
handling authentication.

00:29:00.050 --> 00:29:02.050
You need to handle
authentications because servers

00:29:02.130 --> 00:29:05.750
require passwords sometimes,
proxies require passwords sometimes,

00:29:05.800 --> 00:29:08.060
and if you don't support it,
you can't traverse those things.

00:29:08.060 --> 00:29:11.040
You cannot hit the server,
you can't get your request

00:29:11.040 --> 00:29:12.470
out through the proxy.

00:29:12.900 --> 00:29:16.100
And the basic architecture,
or architecture,

00:29:16.180 --> 00:29:19.300
the basic flow of data in
an authenticated transaction

00:29:19.300 --> 00:29:20.480
looks something like this.

00:29:20.480 --> 00:29:23.370
The client sends a request to the server.

00:29:23.500 --> 00:29:26.710
The server looks at the request and says,
hey, you don't have credentials for this.

00:29:26.850 --> 00:29:28.860
So it sends a challenge
back to the client saying,

00:29:28.860 --> 00:29:30.800
prove to me you have
the right for this data.

00:29:30.800 --> 00:29:33.550
At that point,
the client marshals the request,

00:29:33.620 --> 00:29:37.320
this time adding credentials that
presumably it got from the user,

00:29:37.320 --> 00:29:39.420
and sends that back to the server.

00:29:39.420 --> 00:29:41.310
At this point,
the server and the client are

00:29:41.310 --> 00:29:42.780
going to enter a negotiation.

00:29:42.800 --> 00:29:47.440
It could take several legs back and forth
before the authenticated channel is open.

00:29:47.440 --> 00:29:52.820
But once that's open,
the server will finally send back the

00:29:52.820 --> 00:29:55.800
response that the client is requesting.

00:29:58.130 --> 00:30:00.820
Here's how it's going to
look in our application.

00:30:01.050 --> 00:30:06.400
The loader will detect that it's received
a server challenge and needs credentials.

00:30:06.450 --> 00:30:09.580
It'll send a message to the image client,
authorization needed.

00:30:09.580 --> 00:30:13.700
That'll cause the image client to
bring down this sheet for the user

00:30:13.790 --> 00:30:15.980
and ask for a name and password.

00:30:15.980 --> 00:30:18.720
Once it's got that name and password,
it's going to go back

00:30:18.780 --> 00:30:21.560
to the loader and say,
OK, resume with credentials.

00:30:21.560 --> 00:30:24.150
At that point,
the loader will ask the image

00:30:24.150 --> 00:30:27.800
client for the username,
password, and account domain.

00:30:29.000 --> 00:30:30.230
The loader will then send a
message to the image client that

00:30:30.230 --> 00:30:31.200
the image client just received.

00:30:31.200 --> 00:30:35.110
And using that information,
it'll allow the request to continue.

00:30:38.160 --> 00:30:40.630
So in NSURL Loader,
this is pretty straightforward,

00:30:40.630 --> 00:30:45.400
because the engine does all the work of
detecting the challenge and marshalling

00:30:45.850 --> 00:30:47.960
it into a useful form for you.

00:30:47.970 --> 00:30:50.460
You're going to receive a
Did Receive Authentication

00:30:50.480 --> 00:30:54.160
Challenge message from the connection.

00:30:54.590 --> 00:31:01.210
That second argument, new challenge,
contains all of the information about

00:31:01.210 --> 00:31:01.210
what the server is asking you for.

00:31:01.420 --> 00:31:05.300
So what we're going to do is hold on
to the challenge for future reference,

00:31:05.320 --> 00:31:07.330
and then we're going to fetch
the protection space out.

00:31:07.350 --> 00:31:14.410
The protection space represents that part
of the server that you need access to.

00:31:15.800 --> 00:31:18.810
In particular,
it includes the host and the realm,

00:31:18.810 --> 00:31:21.930
which we are now going to pass
on to Image Client via the

00:31:21.990 --> 00:31:24.030
authorization needed message.

00:31:24.210 --> 00:31:26.460
OK,
so that causes Image Client to go off,

00:31:26.460 --> 00:31:28.780
ask for their username and password,
and then eventually it's going

00:31:28.780 --> 00:31:32.520
to come back with this message,
resume with credentials.

00:31:32.900 --> 00:31:35.130
Well,
to set the credentials on the connection

00:31:35.130 --> 00:31:38.620
and allow the connection to proceed,
what we need to do is create an

00:31:38.750 --> 00:31:43.500
NSURL credential object from the
username and password we received.

00:31:43.510 --> 00:31:47.600
Once we have that credential object,
we just send it back to

00:31:47.600 --> 00:31:49.990
whoever sent us the challenge.

00:31:50.000 --> 00:31:55.310
So we say, challenge sender,
use these credentials for this challenge.

00:31:55.830 --> 00:31:58.000
And that'll allow the
connection to proceed normally,

00:31:58.000 --> 00:32:01.750
and from that point forward,
you'll receive the old data callbacks

00:32:01.750 --> 00:32:04.530
or the data delegate methods.

00:32:05.740 --> 00:32:08.290
In the CFNetwork Loader,
it's a little more complicated.

00:32:08.390 --> 00:32:12.910
Remember I said that NSURL connection
provided you with a slightly

00:32:12.910 --> 00:32:16.640
richer infrastructure for
handling authentication.

00:32:17.090 --> 00:32:18.510
So here's what we're going to do.

00:32:18.620 --> 00:32:26.790
The server response is going to come
back for the unauthenticated request.

00:32:27.010 --> 00:32:28.970
We're going to look at
that response and say,

00:32:29.050 --> 00:32:31.350
hey, is this a challenge?

00:32:31.580 --> 00:32:34.220
If it's not a challenge,
then we'll just keep

00:32:34.250 --> 00:32:35.980
going like we did before.

00:32:36.220 --> 00:32:38.800
But if it is a challenge,
then we need to go and

00:32:38.800 --> 00:32:40.470
modify the request.

00:32:40.560 --> 00:32:44.770
Once we've modified the request,
we can issue the new changed

00:32:45.700 --> 00:32:48.500
request and go back to waiting
for the server response.

00:32:48.610 --> 00:32:52.860
And remember, the server can challenge us
as many times as it wants to,

00:32:52.860 --> 00:32:56.380
so you have to be prepared
to re-enter this code path.

00:32:58.210 --> 00:33:02.000
So the first step in this is
recognizing the challenge.

00:33:02.130 --> 00:33:03.210
It's pretty straightforward.

00:33:03.480 --> 00:33:06.080
What we're going to do is the
first time we look at the headers,

00:33:06.080 --> 00:33:09.220
we're going to call
isAuthorizationFailure to figure out

00:33:09.220 --> 00:33:10.770
if it's an authorization failure.

00:33:10.950 --> 00:33:13.080
And if it is,
we're going to go into this other method,

00:33:13.080 --> 00:33:15.120
retry after authorization failure.

00:33:15.250 --> 00:33:18.960
The one thing I want to highlight on
this slide is that you have to check at

00:33:19.130 --> 00:33:23.030
both endEncountered and bytes available,
because if there are no

00:33:23.030 --> 00:33:25.830
data bytes in the response,
you'll never get a bytes available.

00:33:25.870 --> 00:33:28.430
So make sure to check both places.

00:33:31.170 --> 00:33:34.340
So how do we know if it's
an authorization failure?

00:33:34.340 --> 00:33:37.100
All we need to do is
get the HTTP response.

00:33:37.100 --> 00:33:39.440
We do that by calling
read stream copy property,

00:33:39.450 --> 00:33:42.190
passing a property of
the HTTP response header.

00:33:42.200 --> 00:33:43.880
This gives us the response header.

00:33:43.880 --> 00:33:45.160
We look at the status code.

00:33:45.160 --> 00:33:48.320
If it's a 401,
that means it's a server challenge.

00:33:48.320 --> 00:33:50.760
When we get to proxy support,
we'll add 407s,

00:33:50.770 --> 00:33:52.920
for those of you that are like,
don't you have to check for both?

00:33:53.130 --> 00:33:55.010
But for right now,
we're just going to look for

00:33:55.010 --> 00:33:58.680
origin server challenges,
which come back as 401s.

00:34:00.010 --> 00:34:02.840
Okay, so we've done this first step,
figure out if it's an

00:34:02.840 --> 00:34:04.540
authentication challenge.

00:34:04.600 --> 00:34:07.320
Now we're going to modify the request.

00:34:10.440 --> 00:34:13.000
Just like handling proxies,
there's a quick and dirty way,

00:34:13.000 --> 00:34:14.280
and there's a robust way.

00:34:14.400 --> 00:34:16.630
The quick and dirty way
I've got here in pseudocode.

00:34:16.670 --> 00:34:21.540
It's also in the sample
code commented out.

00:34:21.630 --> 00:34:27.300
Just call CFHTTP message,
add authentication, pass it the request,

00:34:27.320 --> 00:34:30.630
the challenge response you just received,
and the credentials.

00:34:30.730 --> 00:34:34.950
It will modify the request directly,
and then you can send that request again.

00:34:37.170 --> 00:34:39.710
But like the quick and
dirty way with proxies,

00:34:39.710 --> 00:34:41.090
it has some problems.

00:34:41.250 --> 00:34:43.940
There's not going to be any
remembered state if you issue

00:34:43.940 --> 00:34:45.980
several requests to the same server.

00:34:45.980 --> 00:34:49.120
That means that for some
authentication methods like digest,

00:34:49.120 --> 00:34:51.360
where there's a lot of
upfront computation,

00:34:51.360 --> 00:34:54.370
you're going to be redoing
that computation every time.

00:34:54.370 --> 00:34:58.110
There's no support here for
multi-leg authentications.

00:34:58.160 --> 00:35:00.750
Those are authentication methods
where you're going to have to go back

00:35:00.830 --> 00:35:03.780
and forth with the server several
times before getting a clear channel.

00:35:03.780 --> 00:35:06.480
In particular, that includes NTLM.

00:35:06.650 --> 00:35:10.180
So if you use the quick and dirty method,
you will not have support

00:35:10.180 --> 00:35:12.600
for NTLM servers and proxies.

00:35:12.780 --> 00:35:14.560
And in general,
the performance is just poor.

00:35:14.560 --> 00:35:18.140
And all of these things together
mean that this method is not really

00:35:18.210 --> 00:35:20.090
suitable for deployment code.

00:35:20.090 --> 00:35:22.620
You want to bring up a prototype fast,
go for it.

00:35:22.620 --> 00:35:24.780
But know that before
you have to deploy it,

00:35:24.780 --> 00:35:26.560
you need to move off of this API.

00:35:28.300 --> 00:35:30.880
So what is the robust choice?

00:35:30.900 --> 00:35:34.660
The robust choice is to
use CFHTTP authentication,

00:35:34.660 --> 00:35:39.050
which is an object that encapsulates all
the information you need to process an

00:35:39.140 --> 00:35:42.160
authentication request from a server.

00:35:42.160 --> 00:35:45.100
It tracks the dialogue with
the server so it knows how

00:35:45.190 --> 00:35:47.240
much has already been computed.

00:35:47.240 --> 00:35:50.980
It enables things like NTLM,
where you're going to have to have a

00:35:50.980 --> 00:35:53.480
lengthy conversation with the server.

00:35:54.140 --> 00:35:57.810
It keeps as much data as is
necessary to streamline future

00:35:57.810 --> 00:35:59.900
requests to the same server.

00:36:00.190 --> 00:36:03.080
However, it does not actually
hold the credentials.

00:36:03.080 --> 00:36:07.120
It is your job to hold those credentials
somewhere and to supply them on demand.

00:36:08.140 --> 00:36:12.140
So then how do you go about
applying it to the request?

00:36:12.140 --> 00:36:16.070
Well, you take the request,
you take the HTTP authentication object.

00:36:16.180 --> 00:36:18.140
If it's needed,
you also take the credentials

00:36:18.140 --> 00:36:21.810
and you put them all together
and apply the authentication and

00:36:21.810 --> 00:36:24.020
the credentials to the request.

00:36:24.020 --> 00:36:24.020
So then how do you go about
applying it to the request?

00:36:24.020 --> 00:36:24.020
Well, you take the request,
you take the HTTP authentication object.

00:36:24.020 --> 00:36:24.020
If it's needed,
you also take the credentials

00:36:24.020 --> 00:36:24.020
and you put them all together
and apply the authentication and

00:36:24.020 --> 00:36:24.020
the credentials to the request.

00:36:24.140 --> 00:36:28.220
and we're gonna go ahead,
we will show it to you in code,

00:36:28.220 --> 00:36:31.740
but first I'm gonna show you
a flow of how the data moves.

00:36:32.230 --> 00:36:34.450
But first I'm going to tell
you the three basic rules of

00:36:34.450 --> 00:36:37.400
using CFHTTP authentication.

00:36:37.400 --> 00:36:40.580
It can be a little tricky to
use CFHTTP authentication.

00:36:40.580 --> 00:36:43.260
It's tricky because there are
so many different authentication

00:36:43.260 --> 00:36:44.720
mechanisms out there.

00:36:44.720 --> 00:36:50.750
And NTLM is nothing like Kerberos,
and Kerberos is nothing like Digest.

00:36:51.030 --> 00:36:54.250
So here are the three rules
to see you safely through.

00:36:54.370 --> 00:36:58.260
Once you have an authentication object,
keep using it until it

00:36:58.260 --> 00:37:00.170
reports that it is invalid.

00:37:01.070 --> 00:37:05.360
With one authentication object,
always use one set of credentials.

00:37:05.480 --> 00:37:07.450
When you throw away one,
throw away the other.

00:37:07.450 --> 00:37:09.890
They come together as a pair.

00:37:10.360 --> 00:37:13.220
And when the authentication
object does become invalid,

00:37:13.330 --> 00:37:15.820
try and create a new one,
because the server may allow

00:37:15.820 --> 00:37:18.800
you to try multiple times
with different credentials.

00:37:18.970 --> 00:37:21.500
One of three things is going to happen.

00:37:21.650 --> 00:37:22.900
You might get null back.

00:37:22.900 --> 00:37:25.370
If you get null back,
that means CFNetwork could not

00:37:25.370 --> 00:37:27.200
understand the server's challenge.

00:37:27.300 --> 00:37:30.590
Maybe they're asking for an
authentication method we don't support.

00:37:30.690 --> 00:37:32.810
Maybe the response is not parsable.

00:37:32.980 --> 00:37:36.630
But CFNetwork can't handle this response.

00:37:37.410 --> 00:37:40.550
You might get an
HTTP authentication object back

00:37:40.710 --> 00:37:42.210
that is invalid from the get-go.

00:37:42.550 --> 00:37:44.750
What this means is that
the server shuts you down.

00:37:44.840 --> 00:37:47.170
The server's like, no,
you've tried long enough.

00:37:47.210 --> 00:37:49.300
I'm not going to give you access.

00:37:49.300 --> 00:37:50.480
Just forget it.

00:37:51.320 --> 00:37:54.850
But you might get a valid
CFHTTP authentication object.

00:37:55.010 --> 00:37:57.030
If you do, that means you can try again.

00:37:57.280 --> 00:38:01.310
You just need to get a new
copy of the credentials.

00:38:03.630 --> 00:38:08.620
So what does it take to modify a
request using CF HTTP authentication?

00:38:08.630 --> 00:38:10.530
Here's that flow chart.

00:38:11.130 --> 00:38:16.120
First thing you have to do is find
a valid HTTP authentication object.

00:38:16.190 --> 00:38:19.710
Once you have that object, ask it,
do you need credentials before

00:38:19.810 --> 00:38:21.250
you can modify a request?

00:38:21.490 --> 00:38:22.110
You might not.

00:38:22.290 --> 00:38:28.420
Kerberos, for instance,
once you've got a valid

00:38:28.420 --> 00:38:31.030
Kerb ticket on the system,
you don't need a username

00:38:31.030 --> 00:38:31.030
and password from the user.

00:38:31.030 --> 00:38:31.030
It's all set up.

00:38:31.990 --> 00:38:36.140
If you do need credentials, though,
go and get them.

00:38:36.170 --> 00:38:38.280
Once you've got them,
take the credentials

00:38:38.410 --> 00:38:42.040
plus the authentication,
apply them to the request,

00:38:42.110 --> 00:38:44.400
and that'll give you the new
request so you're ready to go.

00:38:44.450 --> 00:38:46.980
If you didn't need credentials,
you're doing essentially the same thing.

00:38:46.980 --> 00:38:51.180
You apply the authentication
to the old request.

00:38:51.230 --> 00:38:55.250
It's just you don't have
credentials this time.

00:38:55.280 --> 00:38:56.980
Either way, you're done,
and you're ready to issue

00:38:56.980 --> 00:38:56.980
the modified request.

00:38:58.620 --> 00:39:01.400
So let's take this step by step,
finding a valid

00:39:01.480 --> 00:39:04.840
CF HTTP authentication object.

00:39:05.060 --> 00:39:08.480
And I've got a pretty flow
chart for you for this one too.

00:39:09.760 --> 00:39:12.040
Start out by looking and
seeing if you already have one.

00:39:12.040 --> 00:39:14.140
If you already have one, terrific.

00:39:14.140 --> 00:39:16.460
If not, create one.

00:39:16.460 --> 00:39:24.290
Once you've created it--
if you can't create it,

00:39:24.290 --> 00:39:24.290
we're in the situation where
CFNetwork can't understand the

00:39:24.290 --> 00:39:24.290
response and you have to fail.

00:39:25.630 --> 00:39:27.640
But if you succeed,
you're going to go through the same

00:39:27.640 --> 00:39:30.130
path as if you started with one.

00:39:30.340 --> 00:39:33.490
Check to see if the
authentication is valid.

00:39:33.780 --> 00:39:35.020
If it is valid, you're done.

00:39:35.250 --> 00:39:35.700
Terrific.

00:39:35.700 --> 00:39:38.880
This is the authentication
object you will use.

00:39:39.400 --> 00:39:43.300
But if it's not valid,
then you need to throw it away and throw

00:39:43.350 --> 00:39:46.590
away any credentials that go with it.

00:39:46.920 --> 00:39:49.520
Once you've done that,
you can look and see why the

00:39:49.520 --> 00:39:55.250
authentication object became invalid.

00:39:55.350 --> 00:40:01.130
If it's because the credentials were bad,
if you simply have the

00:40:01.130 --> 00:40:01.130
wrong password-- all right.

00:40:01.590 --> 00:40:05.290
If that's not the case,
then you've got to fail because that

00:40:05.290 --> 00:40:07.530
means the servers just shut you down.

00:40:07.610 --> 00:40:09.360
No new credentials will help.

00:40:09.540 --> 00:40:12.400
It's just decided that it's had enough.

00:40:12.530 --> 00:40:14.760
But if the problem was that
the credentials were bad,

00:40:14.760 --> 00:40:18.790
you can try again with a brand new
CFH-GTP authentication and see if just

00:40:18.900 --> 00:40:20.620
getting new credentials will work.

00:40:20.740 --> 00:40:23.770
So you go back up and create a new one.

00:40:25.140 --> 00:40:27.180
Here's that same flow
chart in pseudocode.

00:40:27.180 --> 00:40:31.180
And now we're going to walk through it
and show you what it looks like in code.

00:40:31.180 --> 00:40:32.470
So we'll start with this one.

00:40:32.570 --> 00:40:34.050
If you don't have an
authentication object,

00:40:34.100 --> 00:40:34.700
create one.

00:40:34.720 --> 00:40:36.500
If you don't have an
authentication object,

00:40:36.500 --> 00:40:40.480
get the response header from the stream,
and then create an authentication

00:40:40.480 --> 00:40:43.140
object from that response header.

00:40:44.820 --> 00:40:48.320
Now we check to see if we don't
have an authentication object.

00:40:48.330 --> 00:40:51.610
Well, if we don't,
we just call error occurred.

00:40:52.570 --> 00:40:53.940
Now for the interesting bit.

00:40:53.940 --> 00:40:56.330
Look to see if the
authentication object is valid,

00:40:56.620 --> 00:41:00.140
and if not, figure out what to do.

00:41:00.800 --> 00:41:05.280
So if the authentication is not valid,
first thing we do is destroy the

00:41:05.280 --> 00:41:06.780
credentials and authentications.

00:41:06.780 --> 00:41:09.080
I've spared you all the CF releases here.

00:41:09.120 --> 00:41:11.500
Now we're going to look and
see what the failure was.

00:41:11.680 --> 00:41:17.740
You can see that the is valid call took
an error argument that is passing out.

00:41:17.770 --> 00:41:18.660
Well, we look at the error.

00:41:18.660 --> 00:41:23.060
If the domain is HTTP and the error code
is either bad username or bad password,

00:41:23.060 --> 00:41:26.940
that meant we had bad credentials,
and we're going to try again.

00:41:26.940 --> 00:41:30.670
We re-enter the same function
calling retry after authorization.

00:41:30.700 --> 00:41:30.840
We're going to try again.

00:41:30.840 --> 00:41:31.230
We re-enter the same function
calling retry after authorization.

00:41:31.320 --> 00:41:32.240
We're going to try again.

00:41:32.240 --> 00:41:32.320
We re-enter the same function
calling retry after authorization.

00:41:32.420 --> 00:41:33.830
Otherwise, we're dead.

00:41:33.920 --> 00:41:36.880
The server doesn't want
to talk to us anymore.

00:41:36.890 --> 00:41:40.310
And so we call image
client error occurred.

00:41:42.130 --> 00:41:43.800
OK.

00:41:43.920 --> 00:41:48.330
So now let's move on to actually using
the valid authentication object we got.

00:41:48.730 --> 00:41:50.820
Well, what part of this flow chart is it?

00:41:50.880 --> 00:41:52.940
It's everything else.

00:41:55.400 --> 00:41:57.840
So we go through all that code
that I just showed you to get

00:41:57.840 --> 00:42:00.480
a valid authentication object.

00:42:01.190 --> 00:42:04.840
Now we look to see if either we
already have credentials or if

00:42:04.840 --> 00:42:08.830
the authentication object tells
us we don't need credentials.

00:42:08.960 --> 00:42:12.440
If either of those are the case,
we're good to go, and we'll just call

00:42:12.560 --> 00:42:14.180
resume with credentials.

00:42:14.700 --> 00:42:18.300
But if not,
we need to get credentials from the user.

00:42:18.300 --> 00:42:25.710
OK, so first we need to see if the
authentication object provided a Realm.

00:42:25.780 --> 00:42:30.050
So Realm--

00:42:31.860 --> 00:42:33.790
Sorry.

00:42:34.100 --> 00:42:36.900
The authentication object may
require an account domain.

00:42:36.900 --> 00:42:39.670
This is something that's
special to NTLM predominantly,

00:42:40.030 --> 00:42:43.640
where the server is going to
ask you to tell it which part of

00:42:43.640 --> 00:42:45.840
the server you want access to.

00:42:45.870 --> 00:42:51.040
If we don't need an account domain, well,
then we have a valid realm

00:42:51.090 --> 00:42:53.050
and we'll pass that out.

00:42:53.050 --> 00:42:56.240
An image client knows the difference,
and that's how it decides whether

00:42:56.240 --> 00:42:56.240
to prompt you for an account domain.

00:42:58.770 --> 00:43:03.200
Okay, so then image client asks
the user for the credentials.

00:43:03.210 --> 00:43:05.000
What do we do next?

00:43:05.040 --> 00:43:09.490
It'll call back into the loader
with resume with credentials,

00:43:09.540 --> 00:43:10.790
and at this point,

00:43:11.100 --> 00:43:13.500
What we're going to do is
create a credential dictionary.

00:43:13.500 --> 00:43:16.480
We just grab the username and password,
shove it in there.

00:43:16.610 --> 00:43:19.260
Once we've built up that
credential dictionary,

00:43:19.570 --> 00:43:22.700
we call http message apply
credential dictionary.

00:43:22.700 --> 00:43:27.100
We pass the request we want modified,
the authentication object tracking

00:43:27.100 --> 00:43:31.220
this communication with the server,
and the credentials dictionary

00:43:31.220 --> 00:43:33.000
carrying the credentials.

00:43:35.770 --> 00:43:37.880
And that's the modify request phase.

00:43:38.090 --> 00:43:41.060
So now what about this last part,
issuing the new request?

00:43:41.100 --> 00:43:43.200
Well, turns out that's really simple.

00:43:43.260 --> 00:43:44.420
Just call selfload request.

00:43:44.630 --> 00:43:48.690
Just go back in and start the
request as if it were a new one.

00:43:50.600 --> 00:43:53.540
And now I'm going to bring Jeremy back
on stage to show you what that looks

00:43:53.680 --> 00:43:56.440
like in the running application.

00:43:56.550 --> 00:43:57.800
Jeremy Lin All right.

00:43:57.850 --> 00:43:59.770
Demo one.

00:44:03.300 --> 00:44:10.780
So what we'll do is we'll go look
at one of our earlier ones here.

00:44:11.710 --> 00:44:16.070
On this same server we've been using,
we now have another port that's

00:44:16.070 --> 00:44:20.300
opened up that's just simply
wanting basic authentication.

00:44:21.190 --> 00:44:26.980
And in this case, we'll see that we're
not so prepared for it.

00:44:27.300 --> 00:44:29.620
And again,
we get the network diagnostics failure.

00:44:29.620 --> 00:44:33.340
It doesn't understand what in the
world we're talking about here.

00:44:33.730 --> 00:44:39.770
So let's go over to the
simple authentication.

00:44:41.390 --> 00:44:44.750
Now,
I would have shown the Foundation one,

00:44:44.750 --> 00:44:47.840
but like she said earlier,
Foundation does all this

00:44:47.840 --> 00:44:49.550
stuff magically for you.

00:45:05.690 --> 00:45:07.280
That was for Chris.

00:45:07.380 --> 00:45:10.090
So here we get the prompt that tells us,
hey,

00:45:10.090 --> 00:45:12.060
we need to provide some credentials here.

00:45:12.290 --> 00:45:18.520
So we set this up as
WWDC demo basic auth.

00:45:19.370 --> 00:45:21.980
And now we get our load.

00:45:22.060 --> 00:45:26.140
And if I hop over to Foundation,
same sort of thing.

00:45:27.180 --> 00:45:29.680
wants us to do it.

00:45:29.770 --> 00:45:33.410
But wait,
we had told CFNetwork that we gave it,

00:45:33.500 --> 00:45:35.750
and it didn't remember this stuff.

00:45:35.820 --> 00:45:38.400
And so one of the things that
we're going to show next will

00:45:38.400 --> 00:45:40.230
be saving those credentials.

00:45:40.300 --> 00:45:42.830
Now, one of the other things
I'm going to try here,

00:45:43.080 --> 00:45:43.710
bear with me.

00:45:43.730 --> 00:45:48.070
This is my home PC running
Windows that I punched a hole

00:45:48.260 --> 00:45:50.870
in my firewall this morning.

00:45:50.870 --> 00:45:55.830
So it's been running for eight hours,
so it may be full of VIRAI by now.

00:45:56.090 --> 00:46:00.360
Okay, so we notice that it's doing
NTLM authentication because it's

00:46:00.360 --> 00:46:03.120
also prompting for a domain.

00:46:03.120 --> 00:46:09.000
Now this happens to not be a domain user,
and I put in a password so the

00:46:09.420 --> 00:46:15.440
rest of you hooligans out there
wouldn't go crashing on my server.

00:46:15.440 --> 00:46:20.760
But there it does,
doing NTLM authentication.

00:46:21.250 --> 00:46:23.340
from CFNetwork.

00:46:23.400 --> 00:46:29.030
And now Becky will go into holding
credentials so that we can retry later.

00:46:32.800 --> 00:46:36.250
Okay, so as we saw,
Image Client was not remembering the

00:46:36.250 --> 00:46:39.400
credentials from download to download,
so as soon as it went to

00:46:39.400 --> 00:46:42.140
download the next image,
it had to prompt you again.

00:46:42.150 --> 00:46:45.210
We're going to talk
about reusing them now.

00:46:45.610 --> 00:46:48.900
Okay, so you reuse credentials so you
don't have to pop the username

00:46:48.900 --> 00:46:51.100
and password sheet down endlessly.

00:46:51.100 --> 00:46:56.100
Just a warning to make sure to
watch out for security issues

00:46:56.100 --> 00:46:57.400
anytime you store a password.

00:46:57.400 --> 00:47:01.000
And here we're going to walk you
through storing those credentials

00:47:01.000 --> 00:47:04.270
in two different places,
in memory and in the keychain.

00:47:04.270 --> 00:47:07.070
Now, I'm going to talk about the
in-memory portion right now,

00:47:07.070 --> 00:47:09.490
and I'm going to gloss through
it kind of quick because,

00:47:09.530 --> 00:47:12.280
frankly, the keychain is the
more interesting store.

00:47:12.280 --> 00:47:15.290
So I'm just going to walk
through the basics of this.

00:47:15.690 --> 00:47:19.050
With NSURL Loader, you're already done.

00:47:19.260 --> 00:47:21.090
Well, why are you already done?

00:47:21.330 --> 00:47:25.150
Because in this method,
Resume with Credentials,

00:47:25.250 --> 00:47:28.470
you created an NSURL credential.

00:47:28.470 --> 00:47:28.470
And when you did,

00:47:29.710 --> 00:47:31.790
We specified a persistence.

00:47:31.840 --> 00:47:36.060
We said, make this password
persistent for the session.

00:47:36.200 --> 00:47:39.900
So that'll hold the credential
in memory for the length

00:47:39.900 --> 00:47:42.140
of the running application.

00:47:42.580 --> 00:47:45.530
In the CFNetwork loader, though,
it's a little more complicated because

00:47:45.530 --> 00:47:50.420
there we're using CFHTTP authentication,
and HTTP authentication will not

00:47:50.460 --> 00:47:52.610
hold the credentials for you.

00:47:53.750 --> 00:47:56.980
So first thing we do is create
a store that's going to hold all

00:47:56.980 --> 00:47:58.610
of our authentication objects.

00:47:58.730 --> 00:48:01.820
So where we used to hold
a single authentication,

00:48:01.820 --> 00:48:05.310
instead we're going to hold
a mutable array of them.

00:48:05.890 --> 00:48:07.830
Next,
we're going to need to create a mapping

00:48:07.980 --> 00:48:12.190
from the authentication objects to the
credentials we've received from the user.

00:48:12.320 --> 00:48:17.050
So we've replaced the single credentials
dictionary with a credentials dict

00:48:17.280 --> 00:48:19.430
that's going to hold all of them.

00:48:20.050 --> 00:48:24.210
Finally, you just maintain and use these
everywhere that you maintained

00:48:24.210 --> 00:48:28.500
and used the authentication or
single credential object before.

00:48:28.630 --> 00:48:32.050
So here, where we used to simply
release the credentials because

00:48:32.050 --> 00:48:35.210
they were stale or whatever,
instead we're going to end up

00:48:35.210 --> 00:48:39.090
removing the credentials from
the dictionary we're maintaining.

00:48:41.960 --> 00:48:45.720
Finding authentication
objects and credentials.

00:48:45.810 --> 00:48:47.350
So I've got a request.

00:48:47.420 --> 00:48:48.980
I'm issuing it for the first time.

00:48:48.980 --> 00:48:53.540
I need to know if I have any
authentication objects that apply to it.

00:48:53.560 --> 00:48:57.040
There are many interesting algorithms
for figuring out how to do this.

00:48:57.110 --> 00:49:00.480
Here we're just showing you
iterating through the array.

00:49:00.480 --> 00:49:02.960
And the call I want to
highlight is the one in yellow.

00:49:03.050 --> 00:49:05.880
CFHTTP authentication applies to request.

00:49:05.880 --> 00:49:09.500
You're asking the authentication object,
can you handle this request?

00:49:09.500 --> 00:49:11.640
Do you apply to it?

00:49:11.640 --> 00:49:13.980
If the answer is yes,
then this is the authentication

00:49:13.980 --> 00:49:14.960
object we should use.

00:49:14.960 --> 00:49:18.690
If not,
continue on to try and find another one.

00:49:20.660 --> 00:49:23.790
Before prompting the user,
look to see if you have credentials

00:49:23.840 --> 00:49:25.500
already in the dictionary.

00:49:25.620 --> 00:49:29.860
So here we go to the credentials
dict and see if anything is filed

00:49:29.860 --> 00:49:32.530
under the authentication object.

00:49:34.470 --> 00:49:36.120
One word of warning, though.

00:49:36.410 --> 00:49:40.160
Never apply the credentials before
you've received a server challenge.

00:49:40.230 --> 00:49:43.540
The reason for this is that
the server may have changed,

00:49:43.540 --> 00:49:48.190
or you may be routing out through
some new proxy or through some

00:49:48.410 --> 00:49:53.470
new chain of hosts in the network,
and you may never get that challenge.

00:49:54.070 --> 00:49:56.860
Well, if you don't get the challenge
and you shipped out credentials,

00:49:56.860 --> 00:49:58.630
you've just created a security leak.

00:49:58.630 --> 00:50:01.220
So for this reason,
don't apply the credentials

00:50:01.220 --> 00:50:04.680
before you've received a server
challenge from that server.

00:50:07.950 --> 00:50:10.110
Okay,
that's as much as I want to say about

00:50:10.110 --> 00:50:12.300
keeping the credentials in memory.

00:50:12.440 --> 00:50:16.500
Now we're going to talk about
keeping credentials in the keychain.

00:50:17.160 --> 00:50:19.700
So what does the keychain
provide you with?

00:50:19.730 --> 00:50:21.790
First of all,
it's secure and it's persistent,

00:50:21.790 --> 00:50:24.380
so you don't have to worry about
all of the security headaches

00:50:24.400 --> 00:50:25.760
of storing the password.

00:50:25.760 --> 00:50:30.220
Secondly,
this is where all of Apple's apps

00:50:30.290 --> 00:50:34.360
keep the passwords for their own use.

00:50:34.740 --> 00:50:37.630
Safari, Mail,
and WebDAV are three examples of that.

00:50:37.670 --> 00:50:41.220
So if you use the keychain as well,
you can automatically get the passwords

00:50:41.220 --> 00:50:43.020
that have been entered in Safari.

00:50:43.020 --> 00:50:46.260
Safari can automatically get the
passwords that you've entered.

00:50:46.790 --> 00:50:50.050
It all means fewer prompts for the user.

00:50:50.480 --> 00:50:53.660
Once we've moved to the keychain,
the in-memory storage

00:50:54.030 --> 00:50:57.930
becomes merely a local cache,
and the keychain becomes the

00:50:57.990 --> 00:51:01.470
persistent store that we're
going to use for the passwords.

00:51:02.790 --> 00:51:05.860
So here are the changes
on the NSURL loader side.

00:51:05.880 --> 00:51:09.660
We're going to add this
checkbox to the password sheet.

00:51:09.660 --> 00:51:12.080
Remember this password in my keychain.

00:51:12.080 --> 00:51:15.280
The state of that checkbox is going
to be returned by a new method

00:51:15.280 --> 00:51:18.180
on image client save credentials.

00:51:18.510 --> 00:51:22.380
So now, in NSURL Loader,
when we create the credentials,

00:51:22.520 --> 00:51:26.150
we're just going to look at
the state of that checkbox and

00:51:26.270 --> 00:51:28.940
determine what persistence to use.

00:51:29.080 --> 00:51:31.730
If we pass credentials
persistence permanent,

00:51:31.760 --> 00:51:36.700
that tells the connection loader to
store the credentials permanently.

00:51:36.700 --> 00:51:38.940
That means in the keychain.

00:51:41.270 --> 00:51:44.690
In the CFNetwork Loader,
we're going to add two new methods.

00:51:44.830 --> 00:51:47.440
The first one,
Find Credentials for Authentication,

00:51:47.440 --> 00:51:51.040
is going to look through our local
store and try and find the credentials.

00:51:51.150 --> 00:51:54.710
If it can't find it there,
it's going to go out to the keychain

00:51:54.710 --> 00:51:56.770
and look for credentials there.

00:51:56.910 --> 00:52:00.320
The second one,
Save Credentials for a Request,

00:52:00.320 --> 00:52:04.530
is going to take the credentials
that we've just used and save

00:52:04.810 --> 00:52:06.430
them out to the keychain.

00:52:06.430 --> 00:52:09.230
We're going to walk through those now.

00:52:09.230 --> 00:52:09.290
Finding Credentials.

00:52:09.560 --> 00:52:11.340
First things first,
check your local store.

00:52:11.340 --> 00:52:14.600
If you have it in your local cache,
that's great.

00:52:14.770 --> 00:52:17.290
If you don't have the
credentials in your local cache,

00:52:17.420 --> 00:52:21.010
you're going to call seckeychain
findinternetpassword.

00:52:21.040 --> 00:52:23.820
That's going to go to the
keychain and try to find a

00:52:23.870 --> 00:52:28.160
seckeychain item that matches the
request that you're transmitting.

00:52:28.160 --> 00:52:30.630
Now,
you'll see this when we go to the code.

00:52:30.810 --> 00:52:34.000
The seckeychain item takes
a bunch of arguments.

00:52:34.020 --> 00:52:36.230
Most of those arguments, well,
all the arguments are

00:52:36.230 --> 00:52:39.000
fairly straightforward,
but you need to know where to get them.

00:52:39.640 --> 00:52:41.770
Most of them are going to
be taken out of the URL.

00:52:41.770 --> 00:52:44.570
They're things like the host name
that you're trying to access and

00:52:44.610 --> 00:52:46.260
the port you're trying to access.

00:52:46.300 --> 00:52:48.640
A couple of them come from the
authentication object because

00:52:48.720 --> 00:52:51.620
they have to do with the type of
authentication you're performing.

00:52:51.620 --> 00:52:55.770
Those two are the realm and
the authentication method.

00:52:55.770 --> 00:53:00.570
The authentication method is
digest versus basic versus NTLM.

00:53:00.830 --> 00:53:06.110
Once you've got that keychain item,
you can call copy content to get

00:53:06.250 --> 00:53:09.270
the actual value of the password.

00:53:10.720 --> 00:53:12.480
So let's look at it in code.

00:53:12.530 --> 00:53:14.200
First, check your local store.

00:53:14.210 --> 00:53:16.290
That's not too tough.

00:53:18.200 --> 00:53:23.600
If you didn't find one,
call seckeychain find internet password.

00:53:23.660 --> 00:53:26.210
I warned you there were
a lot of arguments.

00:53:26.400 --> 00:53:31.530
So first we pass the server name,
then the security domain.

00:53:31.750 --> 00:53:35.000
We're not passing an account name because
we don't know what the account name is.

00:53:35.110 --> 00:53:37.680
We're asking the keychain,
do you have any credentials

00:53:37.810 --> 00:53:40.560
that match this hostname query?

00:53:41.200 --> 00:53:44.360
The path that we're trying to access,
the port we're talking over,

00:53:44.490 --> 00:53:48.340
what protocol we're using,
what kind of authentication we're using,

00:53:48.370 --> 00:53:52.810
and then we're not supplying a password
because that's what we're trying to get.

00:53:54.720 --> 00:53:59.800
Once we have the key chain item
called copy content-- so copy content

00:53:59.800 --> 00:54:03.700
takes an attribute list specifying
what attributes we're interested in.

00:54:03.970 --> 00:54:08.260
The attribute we're interested
in is sec account item adder.

00:54:08.520 --> 00:54:10.400
So we pass that in to copy content.

00:54:10.400 --> 00:54:14.720
We pass the item we got
back from find item.

00:54:14.840 --> 00:54:16.720
We pass in the attribute list.

00:54:16.730 --> 00:54:21.620
And then lengthen out data are parameters
that are going to be passed out to us.

00:54:21.630 --> 00:54:26.100
And in specific, what we get out is the
username and password.

00:54:26.100 --> 00:54:28.840
The username is stored in
the modified attribute list,

00:54:28.840 --> 00:54:30.580
so we go into there to get it out.

00:54:30.710 --> 00:54:34.080
The password came out
in the out arguments.

00:54:34.100 --> 00:54:37.180
Once we found those and have
created CFStrings from them,

00:54:37.180 --> 00:54:41.320
we need to free it up because those
were objects Keychain created for us.

00:54:41.380 --> 00:54:44.820
And so we call
secKeychainItemFreeContent.

00:54:44.840 --> 00:54:45.960
Then we proceed as before.

00:54:46.010 --> 00:54:47.320
We've got credentials.

00:54:47.320 --> 00:54:50.250
We create the credential
dictionary and go.

00:54:53.910 --> 00:54:57.600
must have stepped out of range.

00:54:57.600 --> 00:54:58.400
There we go.

00:54:58.400 --> 00:55:01.400
All right,
so let's look at the storing side.

00:55:01.400 --> 00:55:03.940
Well, pieces of this look a lot
like the finding side.

00:55:03.940 --> 00:55:07.070
We're going to start by calling
findInternetPassword to find the

00:55:07.070 --> 00:55:08.560
correct item in the keychain.

00:55:08.560 --> 00:55:12.220
That's going to look just like
the call that we made to find a

00:55:12.390 --> 00:55:15.100
credential in the first place,
except this time we

00:55:15.100 --> 00:55:17.210
have the account name,
so we're going to supply it.

00:55:17.260 --> 00:55:20.410
And what we're looking for is a
keychain item that's an exact match for

00:55:20.490 --> 00:55:23.000
the credentials we've got right now.

00:55:23.000 --> 00:55:25.320
If we find an item,
all we're going to do is update

00:55:25.330 --> 00:55:30.590
the password entry itself,
calling setKeychainItemModifyContent.

00:55:30.710 --> 00:55:33.600
But if we didn't find an item,
we're going to create a new one

00:55:33.900 --> 00:55:37.120
by calling addInternetPassword.

00:55:37.890 --> 00:55:41.640
Okay, so here's the modified find
internet password call,

00:55:41.670 --> 00:55:45.790
and you can see all we've done is add
the username argument to specify that

00:55:45.960 --> 00:55:48.670
that's the account we're going to modify.

00:55:50.280 --> 00:55:55.960
Assuming we did find an entry,
we're going to set up our attribute list.

00:55:55.960 --> 00:55:58.520
Again,
we're modifying sec account item adder.

00:55:58.680 --> 00:56:01.640
And then we're going
to call modify content,

00:56:01.640 --> 00:56:06.640
passing the adder list and marshaling
the password as the data to be set.

00:56:08.240 --> 00:56:11.240
If not,
we're going to call addInternetPassword

00:56:11.350 --> 00:56:14.710
and pass all those arguments again.

00:56:14.880 --> 00:56:17.030
Now,
why don't we just do this all the time?

00:56:17.040 --> 00:56:19.260
If we know that the old
credentials are bad,

00:56:19.260 --> 00:56:21.200
why don't we just call
addInternetPassword and

00:56:21.210 --> 00:56:22.340
blast over the top of them?

00:56:22.460 --> 00:56:26.200
Well, because as a keychain item
lives on in the system,

00:56:26.210 --> 00:56:28.440
it collects a lot of metadata.

00:56:28.440 --> 00:56:35.240
And that metadata is valuable and should
not be discarded unless it's necessary.

00:56:35.240 --> 00:56:40.050
In particular,
if you modify the existing Internet item,

00:56:40.050 --> 00:56:44.400
then those are other times,
other prompts that you're saving

00:56:44.400 --> 00:56:46.590
your user later down the road.

00:56:48.300 --> 00:56:50.850
And Jeremy,
we've got one more demo for you,

00:56:50.920 --> 00:56:57.280
yet one more.

00:56:57.280 --> 00:56:57.280
JEREMY CHO: Sorry,
I got distracted by sirens.

00:56:57.720 --> 00:56:59.320
I'm like a dog.

00:56:59.340 --> 00:57:00.070
Okay.

00:57:00.180 --> 00:57:02.460
So, same sort of thing.

00:57:02.460 --> 00:57:09.990
I've got to make sure I have
my proxy set up again.

00:57:10.100 --> 00:57:11.070
Okay.

00:57:11.070 --> 00:57:11.070
We're using the proxy.

00:57:15.500 --> 00:57:18.150
So just like before, we log in.

00:57:18.170 --> 00:57:20.770
We're going to go over to--

00:57:21.540 --> 00:57:23.450
Demo 1 again.

00:57:23.580 --> 00:57:30.550
And the authenticated port was 16,001.

00:57:30.990 --> 00:57:32.600
And we're going to get prompted.

00:57:32.630 --> 00:57:40.560
And we showed WWDC demo,
and that was basic auth.

00:57:41.860 --> 00:57:44.470
And now it's holding
it in our memory cache.

00:57:44.790 --> 00:57:49.720
So in another 15 seconds or so,
we should get another load.

00:57:49.830 --> 00:57:51.650
Or I can just hit Return again.

00:57:51.720 --> 00:57:54.720
OK, so we know we're reusing.

00:57:54.960 --> 00:58:00.740
But if we run it again,
we'll see that it's

00:58:00.810 --> 00:58:02.990
going to prompt us again.

00:58:06.340 --> 00:58:10.270
Because we didn't save
that username password,

00:58:10.270 --> 00:58:11.080
right?

00:58:11.170 --> 00:58:14.830
So we'll enter it again.

00:58:16.170 --> 00:58:21.430
But this time we'll check,
tell it to save, and there we have it.

00:58:21.490 --> 00:58:25.570
And if we go over to Who,

00:58:26.380 --> 00:58:32.670
Safari and we say demo one,
we'll go to the same port and

00:58:32.840 --> 00:58:38.380
we're going to ask for zero JPEG.

00:58:38.380 --> 00:58:39.890
And it didn't work.

00:58:39.890 --> 00:58:40.570
Nice.

00:58:40.680 --> 00:58:41.540
That's really nice.

00:58:41.540 --> 00:58:50.100
Well, we'll go look at Keychain and find
out what it has in there for us.

00:59:03.120 --> 00:59:06.200
Nice.

00:59:06.340 --> 00:59:09.510
So what we'll do is we'll
ignore that that ever happened.

00:59:14.280 --> 00:59:16.940
And we'll remove that.

00:59:17.060 --> 00:59:20.590
Now we'll get it added correctly.

00:59:23.550 --> 00:59:28.880
We'll verify that indeed the
path came across correctly so

00:59:28.880 --> 00:59:38.730
that when we go over here-- man,
who wrote this?

00:59:49.100 --> 00:59:51.550
I stink.

00:59:52.300 --> 00:59:56.100
Well,
it should have been much like this guy.

00:59:56.100 --> 01:00:02.040
If we run him again,
we'll see that he gets it.

01:00:02.040 --> 01:00:04.390
And I will have to figure
out why that didn't work,

01:00:04.390 --> 01:00:04.390
and we'll have to update

01:00:04.700 --> 01:00:16.800
[Transcript missing]

01:00:20.040 --> 01:00:25.260
But one more thing I wanted to show
you is that what I'm going to do is

01:00:25.260 --> 01:00:29.110
we're going to approve this thing,
say, always loud.

01:00:29.140 --> 01:00:32.560
So keychain access is always
loud to get to this username,

01:00:32.560 --> 01:00:34.180
password, and show it.

01:00:34.270 --> 01:00:38.330
And that is now metadata on this.

01:00:38.880 --> 01:00:39.680
keychain item.

01:00:39.860 --> 01:00:42.560
So then we can see who's
allowed to access this.

01:00:42.590 --> 01:00:46.040
And if we were always creating
and destroying these things,

01:00:46.070 --> 01:00:47.540
this metadata would be lost.

01:00:47.540 --> 01:00:50.260
And so every time,
if you were always adding a

01:00:50.260 --> 01:00:53.330
new internet keychain password,
that metadata would be lost.

01:00:53.340 --> 01:00:58.730
Which means every time a user would
relaunch mail or something like that,

01:00:58.760 --> 01:01:02.740
it would ask them, just like it did for
me for keychain access,

01:01:02.740 --> 01:01:05.920
whether that application
should have access.

01:01:06.140 --> 01:01:09.260
And so you don't want to always cause
the user to have to retype and say

01:01:09.260 --> 01:01:11.020
yes and so forth to those things.

01:01:11.040 --> 01:01:14.980
So make sure to use the modify calls.

01:01:15.010 --> 01:01:19.640
But what I'm going to do here is actually
we're going to give it a bad password.

01:01:19.640 --> 01:01:22.240
I'm going to save it.

01:01:22.290 --> 01:01:27.180
And now when we run this,
because it pulls that out of

01:01:30.010 --> 01:01:34.750
The keychain,
it knew that the username password was

01:01:34.860 --> 01:01:38.340
bad because it failed to authenticate.

01:01:38.340 --> 01:01:42.280
And so now what we'll do again is--

01:01:47.360 --> 01:01:51.660
We'll tell it the right password,
tell it to save again,

01:01:51.730 --> 01:01:53.540
and now when we go look
at this thing again,

01:01:53.770 --> 01:01:54.440
show password.

01:01:54.440 --> 01:01:57.850
I didn't get prompted again
because the access control list was

01:01:57.850 --> 01:02:00.860
saved because we used the modify
entry opposed to the add entry.

01:02:00.860 --> 01:02:05.280
So we played nice with keychain.

01:02:09.700 --> 01:02:10.400
Back to you.

01:02:10.410 --> 01:02:10.780
OK.

01:02:10.900 --> 01:02:15.710
One last programming topic.

01:02:16.050 --> 01:02:19.670
Of course, origin servers aren't the only
things that require authentication.

01:02:19.830 --> 01:02:22.200
Firewalls do as well.

01:02:23.020 --> 01:02:25.430
When they do,
there's a couple pieces of news.

01:02:25.640 --> 01:02:29.410
The good news is that the code
we've written so far is largely

01:02:29.490 --> 01:02:31.450
going to work for the proxies.

01:02:31.450 --> 01:02:33.570
There are a few small changes,
and I'll show you those.

01:02:33.570 --> 01:02:36.410
However, there's also some bad news.

01:02:36.490 --> 01:02:40.060
And the bad news is that every
request that you make is going to

01:02:40.060 --> 01:02:43.810
have to go through both code paths,
one for the origin server,

01:02:43.810 --> 01:02:45.030
one for the proxy.

01:02:45.180 --> 01:02:47.350
Because, of course,
you may have to authenticate twice.

01:02:47.350 --> 01:02:49.370
It may be that the proxy
is going to challenge you,

01:02:49.370 --> 01:02:51.290
and then when you finally
get to the origin server,

01:02:51.290 --> 01:02:52.880
it's going to challenge you as well.

01:02:52.900 --> 01:02:54.320
well.

01:02:55.000 --> 01:02:57.360
So every request needs
to be checked for both.

01:02:57.520 --> 01:03:01.250
You're going to need separate stores for
the proxy and the origin server data.

01:03:01.400 --> 01:03:02.650
A couple good reasons for this.

01:03:02.840 --> 01:03:04.700
First of all,
you're going to use the proxy

01:03:04.700 --> 01:03:07.980
credentials over and over and over again.

01:03:08.200 --> 01:03:11.790
And again,
you may need two sets of credentials.

01:03:12.160 --> 01:03:16.470
If the proxy settings change,
just discard the proxy

01:03:16.490 --> 01:03:18.390
credentials you have.

01:03:18.740 --> 01:03:21.530
And then one final note,
once you've successfully

01:03:21.530 --> 01:03:24.830
navigated the proxy,
make sure and save your credentials then.

01:03:24.830 --> 01:03:28.590
Do not wait until you've gotten
something back from the origin server,

01:03:28.650 --> 01:03:31.300
because something could
go wrong past the proxy,

01:03:31.300 --> 01:03:35.030
and you don't want to prevent
that from saving your credentials.

01:03:35.930 --> 01:03:37.800
So here are the basic differences.

01:03:37.940 --> 01:03:40.300
First of all,
your user prompt should be different.

01:03:40.300 --> 01:03:43.010
The user needs to know whether
it's validating the proxy or

01:03:43.070 --> 01:03:45.110
validating the origin server.

01:03:45.310 --> 01:03:48.700
Proxy challenges are 407s, not 401s.

01:03:48.800 --> 01:03:50.980
And then when you make
your keychain calls,

01:03:51.070 --> 01:03:55.070
the arguments are going to come from
the description of the proxy host,

01:03:55.070 --> 01:03:59.350
not from the URL which
describes the origin server.

01:03:59.910 --> 01:04:01.400
And that's it.

01:04:01.430 --> 01:04:05.490
And we have one last demo-- yay,
Jeremy-- which is going to be the

01:04:05.640 --> 01:04:08.500
full image client application.

01:04:09.500 --> 01:04:11.160
Okay.

01:04:11.160 --> 01:04:14.810
So now the gods will frown upon me again.

01:04:14.950 --> 01:04:18.520
But this time,
we're going to go -- instead of

01:04:18.520 --> 01:04:22.930
-- we've been running through
that proxy that was wide open,

01:04:22.930 --> 01:04:27.000
and a lot of times corporations
don't like to do that.

01:04:27.000 --> 01:04:32.750
So we are going to go ahead
and say different port,

01:04:32.750 --> 01:04:38.640
it's basic authentication,
and this time when I go to --

01:04:39.300 --> 01:04:43.380
Demo 1, 16,000.

01:04:43.380 --> 01:04:47.230
This is the one that's
wide open on the server.

01:04:47.240 --> 01:04:50.010
We're going to get the proxy prompt.

01:04:50.880 --> 01:04:52.420
And there it goes.

01:04:52.420 --> 01:04:56.230
It tells us we're going to
connect to proxy 10.0.1.2.

01:04:56.330 --> 01:05:02.120
So same password scheme that
we've been using all along.

01:05:02.780 --> 01:05:05.630
And I'm going to add it to the
keychain so we don't get prompted.

01:05:05.890 --> 01:05:10.240
And so now we're making it
through the authenticated proxy.

01:05:10.310 --> 01:05:16.280
And because we have the
keychain items saved for that

01:05:16.400 --> 01:05:20.170
server for the authentication,
we're going to get a

01:05:20.170 --> 01:05:22.520
failure under the covers.

01:05:22.580 --> 01:05:23.700
Nice.

01:05:23.830 --> 01:05:25.200
Under the covers.

01:05:25.260 --> 01:05:30.350
And what it's going to do
is get the failure 401.

01:05:30.450 --> 01:05:33.200
It'll go looking for the
credentials in the keychain.

01:05:33.240 --> 01:05:35.180
It'll apply those.

01:05:35.260 --> 01:05:39.560
Plus it applied the proxy authentication
and went through both authenticated.

01:05:39.640 --> 01:05:42.690
And so we end up getting
through everything.

01:05:43.090 --> 01:05:49.100
And if we go look at
keychain access again,

01:05:49.200 --> 01:05:51.310
we'll see that--

01:05:54.840 --> 01:05:58.090
It didn't save it right.

01:05:58.180 --> 01:06:00.570
So don't use the code up on the website.

01:06:00.700 --> 01:06:01.640
It's the wrong code.

01:06:01.690 --> 01:06:03.210
You guys need some new code.

01:06:03.210 --> 01:06:04.490
Come see us at the lab.

01:06:04.550 --> 01:06:05.700
So there you have it.

01:06:05.930 --> 01:06:07.400
Thank you.

01:06:11.980 --> 01:06:15.100
You tired of seeing
pictures of my baby yet?

01:06:15.100 --> 01:06:17.600
All right, quick wrap up for you.

01:06:17.620 --> 01:06:20.300
Documentation sample code,
there's all kinds of stuff

01:06:20.300 --> 01:06:22.400
up on developer.apple.com.

01:06:22.410 --> 01:06:26.870
I'll also say that if you
go to the tech resources,

01:06:26.900 --> 01:06:29.340
the documentation site
at developer.apple.com

01:06:29.340 --> 01:06:30.960
and do a quick search,
there's a fair bit of

01:06:31.080 --> 01:06:33.530
sample code there as well.

01:06:34.040 --> 01:06:35.430
Some related sessions.

01:06:35.610 --> 01:06:37.650
First and foremost,
the lab tomorrow morning.

01:06:37.710 --> 01:06:38.690
We're all going to be there.

01:06:38.730 --> 01:06:40.190
We got people coming from CoreOS.

01:06:40.320 --> 01:06:41.940
We got people coming from Cocoa.

01:06:41.990 --> 01:06:43.180
It's going to be a party.

01:06:43.380 --> 01:06:45.240
Also,
we're running a little short on time now,

01:06:45.240 --> 01:06:47.080
so the Q&A is going to be cut short.

01:06:47.130 --> 01:06:50.090
You can take further
questions to the lab.

01:06:50.310 --> 01:06:54.460
Other sessions that are interesting,
implementing networking using the

01:06:54.520 --> 01:06:56.360
Cocoa classes happened this morning.

01:06:56.360 --> 01:06:58.800
If you get a chance,
take a look at the slides and

01:06:58.880 --> 01:07:02.000
take a look at the demo apps that
they put up on the website because

01:07:02.000 --> 01:07:03.920
they had some great demos there.

01:07:03.920 --> 01:07:08.110
And then in this room in just a moment,
designing network-friendly applications.

01:07:08.110 --> 01:07:11.040
We'll talk about what it takes
to write an application that's

01:07:11.130 --> 01:07:13.140
not particularly network-savvy.

01:07:13.140 --> 01:07:15.530
Networking isn't at
the heart of its work,

01:07:15.530 --> 01:07:19.360
but it needs to be ready to work
inside networking environments.

01:07:21.800 --> 01:07:28.390
Contact information-- Xavier and
Mark are fabulous people out of WWDR.

01:07:28.750 --> 01:07:31.720
And now, unfortunately,
Mark couldn't be here today.

01:07:31.880 --> 01:07:33.640
So I'll be running the Q&A.

01:07:33.770 --> 01:07:36.020
And I'm going to invite the
rest of the team to come up.

01:07:36.070 --> 01:07:38.230
And we'll take some questions.
WEBVTT

00:00:07.420 --> 00:00:10.200
Good morning, everybody.

00:00:10.260 --> 00:00:14.030
Welcome to session 116,
Building a Custom HIView.

00:00:14.090 --> 00:00:15.110
I'm Bryan Prusha.

00:00:15.270 --> 00:00:18.280
I'll be doing some quick overviews
of some of the features we're

00:00:18.280 --> 00:00:19.870
going to be talking about today.

00:00:19.950 --> 00:00:24.960
And Curt Rothert will be coming up
to provide demos and sample code.

00:00:25.860 --> 00:00:28.790
We're going to be covering
a lot of territory today.

00:00:29.030 --> 00:00:30.960
Something I wanted to mention
is this is a hands-on session,

00:00:30.960 --> 00:00:34.300
so if you don't have your code ready
and you'd like to follow along with us,

00:00:34.560 --> 00:00:37.760
we'll be looking at the
Image Browser View sample code.

00:00:38.410 --> 00:00:40.580
Also,
at this point we're assuming that most

00:00:40.580 --> 00:00:43.300
of you had experience with Carbon Events.

00:00:43.300 --> 00:00:46.300
So we're not going to be going
in-depth on how to handle those today.

00:00:46.300 --> 00:00:48.410
If you haven't had a lot of
experience and want to review,

00:00:48.500 --> 00:00:50.300
just go ahead and check
out the sample code.

00:00:50.380 --> 00:00:52.300
There's lots of examples there.

00:00:53.400 --> 00:00:56.660
We have a lot of material,
so I just want to jump right into it.

00:00:56.800 --> 00:01:00.700
The first thing you want to do
when creating a Custom HIView is

00:01:00.880 --> 00:01:06.410
subclass from the base HIView.

00:01:06.570 --> 00:01:11.140
The toolbox is really
pervasively object-oriented.

00:01:11.340 --> 00:01:15.370
Even though we export our APIs through C,
we still use an H object

00:01:15.370 --> 00:01:18.120
subclassing model,
which I'm going to discuss.

00:01:18.230 --> 00:01:20.520
You may be familiar
with C++ or Objective-C,

00:01:20.610 --> 00:01:22.760
other object-oriented languages.

00:01:22.810 --> 00:01:25.930
We try and do everything
those do at compile time.

00:01:26.000 --> 00:01:28.450
We need to do that at runtime.

00:01:29.580 --> 00:01:33.260
So to subclass,
we use the API HIObjectRegisterSubclass.

00:01:33.260 --> 00:01:39.860
This is similar in C++ to
using the class keyword.

00:01:41.300 --> 00:01:43.830
I want to concentrate on
the first two parameters,

00:01:43.940 --> 00:01:46.380
the Class ID and Super Class ID.

00:01:46.590 --> 00:01:50.300
The Class ID is what the client
uses to instantiate one of your

00:01:50.300 --> 00:01:53.420
objects using haObject create.

00:01:53.620 --> 00:01:56.720
So we want this to be a unique string.

00:01:57.520 --> 00:02:01.470
So often we suggest that you use
the reverse domain name scheme,

00:02:01.470 --> 00:02:06.100
something along the lines
of com.mycompany.myview.

00:02:06.700 --> 00:02:09.180
And in this case,
we will specifically be subclassing

00:02:09.260 --> 00:02:12.100
from the HIView class ID.

00:02:12.960 --> 00:02:15.540
And again, in the C++ case,
this is analogous to

00:02:15.870 --> 00:02:18.230
declaring your subclass.

00:02:21.080 --> 00:02:25.440
Next, now that we've registered,
we need to pass a set of events

00:02:25.440 --> 00:02:27.270
that we will be handling.

00:02:28.550 --> 00:02:30.400
These are Carbon Events.

00:02:30.740 --> 00:02:33.320
Specifically,
any HIObject subclass must handle

00:02:33.480 --> 00:02:35.900
HIObject Construct and Destruct.

00:02:35.900 --> 00:02:39.900
I've also offered HIObject
Initialize and Control Draw here

00:02:39.900 --> 00:02:41.900
just for an illustration.

00:02:42.740 --> 00:02:45.400
Now we pass these events and
pass the count of the events.

00:02:45.400 --> 00:02:52.740
And in C++, this is like declaring
your class methods.

00:02:55.350 --> 00:02:57.100
Now that we've registered
for all these events,

00:02:57.100 --> 00:02:59.400
we need to handle them in
a Carbon Event Handler.

00:02:59.400 --> 00:03:03.110
This is where the toolbox
will send these events to you,

00:03:03.340 --> 00:03:06.930
we listen, or the view listens,
and then does what's

00:03:06.930 --> 00:03:08.860
appropriate for each event.

00:03:09.660 --> 00:03:10.990
and his C++.

00:03:11.050 --> 00:03:15.230
This is just like implementing
each of your class methods.

00:03:15.300 --> 00:03:18.300
So you can see the
models are very similar.

00:03:19.540 --> 00:03:22.730
Now that we've covered the basics,
I'd like to hand things off to

00:03:22.730 --> 00:03:25.190
Curt Rothert for a demonstration.

00:03:27.370 --> 00:03:31.330
Bryan, so first of all,
I want to thank all of you for

00:03:31.380 --> 00:03:32.660
coming out to see the session.

00:03:32.810 --> 00:03:36.000
There's some really cool technology,
and I think you'll be excited

00:03:36.000 --> 00:03:38.530
if you haven't taken advantage
of the HIViews already.

00:03:38.540 --> 00:03:43.740
So the view that we've chosen to
implement is just an image browser view,

00:03:43.740 --> 00:03:46.120
as Bryan mentioned,
and this image browser is

00:03:46.190 --> 00:03:48.540
a collection of images,
and it will display one of those

00:03:48.540 --> 00:03:51.870
images within the bounds of that view.

00:03:52.420 --> 00:03:56.550
So in order to see what the target is,
let's see the completed project.

00:03:56.630 --> 00:03:59.060
Now as Bryan mentioned,
this sample code is already available.

00:03:59.060 --> 00:04:00.580
You can download it and
play with it yourself.

00:04:00.780 --> 00:04:04.900
But let's just look at what
the app will look like.

00:04:05.580 --> 00:04:07.990
So as you can see here,
the image in the middle of the

00:04:07.990 --> 00:04:10.300
window is our image browser view.

00:04:10.300 --> 00:04:13.500
It displays an image,
here specifically a desktop image.

00:04:13.500 --> 00:04:16.500
And it supports such
features as tracking areas.

00:04:16.500 --> 00:04:18.380
As I move the mouse in,
you can see these different

00:04:18.380 --> 00:04:19.500
parts become available.

00:04:19.500 --> 00:04:25.500
Tracking, hit testing, library size.

00:04:25.500 --> 00:04:29.020
It also handles such
things as keyboard focus.

00:04:29.020 --> 00:04:31.500
So I can focus the image itself.

00:04:31.500 --> 00:04:34.670
And when the image is focused,
it handles keyboard input.

00:04:34.670 --> 00:04:37.500
So I can navigate between
the various images.

00:04:37.670 --> 00:04:42.970
And if full keyboard focus is on,
you can bore into the different

00:04:42.970 --> 00:04:45.500
parts of that view as well.

00:04:45.500 --> 00:04:48.620
So you can see that,
actually this might not be

00:04:48.620 --> 00:04:50.420
a good image to see that.

00:04:52.900 --> 00:04:58.040
You can see that the various parts
are highlighted as they have focus.

00:04:58.250 --> 00:05:02.910
And then I can use the keyboard
spacebar key to navigate as well.

00:05:04.360 --> 00:05:09.290
This view also supports Accessibility,
so if you can see...

00:05:14.750 --> 00:05:16.350
Here are the various parts.

00:05:16.500 --> 00:05:19.820
This will act as a button that
an accessibility application

00:05:19.820 --> 00:05:23.270
such as VoiceOver can interact
with your view as well.

00:05:24.800 --> 00:05:30.770
Other features this view will implement
are such things as Drag-and-Drop,

00:05:32.600 --> 00:05:35.410
So you can take an image and
drag it onto the view and it

00:05:35.410 --> 00:05:37.100
will respond to drag-and-drop.

00:05:37.150 --> 00:05:38.920
And also archiving,
which is a new feature that

00:05:38.970 --> 00:05:40.240
Bryan will be going through.

00:05:40.290 --> 00:05:42.790
But it allows you to save the persistent
state of your view so you can,

00:05:42.800 --> 00:05:46.610
it's like freeze drying
and then flash thawing it.

00:05:47.280 --> 00:05:50.540
So let's go straight into
implementing a project.

00:05:50.610 --> 00:05:54.440
Now I'm just gonna do this in Xcode
starting out with a default template,

00:05:54.470 --> 00:05:56.920
and then we'll just build from there.

00:05:59.920 --> 00:06:02.370
In order to prevent me
from making any errors,

00:06:02.380 --> 00:06:05.560
I'm using a service utility
which is called DemoMonkey.

00:06:05.560 --> 00:06:09.320
So if there's any errors in typing,
it's the monkey's fault, not mine.

00:06:09.320 --> 00:06:18.110
So we first launch Xcode,
create a new project, Carbon Application,

00:06:18.130 --> 00:06:20.590
and we'll call this Image Browser.

00:06:23.580 --> 00:06:24.900
Placing it on the desktop.

00:06:24.900 --> 00:06:30.970
Now this creates the
default Carbon template.

00:06:31.080 --> 00:06:35.190
So what we'll do now is we'll
create the image browser interface

00:06:35.190 --> 00:06:38.750
and implementation files,
and we'll use the main.c file as

00:06:38.750 --> 00:06:41.620
a test harness to make sure that
our view is working correctly.

00:06:41.620 --> 00:06:46.280
So in order to create the files,
we go back up and say new file.

00:06:47.120 --> 00:06:48.600
Make it a Carbon C file.

00:06:48.600 --> 00:06:52.110
And we'll call this Image Browser View.

00:06:52.200 --> 00:06:58.100
We also tell Xcode to create the
corresponding header file as well.

00:06:59.210 --> 00:07:01.770
And here we have our header.

00:07:02.020 --> 00:07:05.730
So as Bryan mentioned,
in order to get started,

00:07:05.740 --> 00:07:09.400
we have to have a class ID,
which is a unique way to reference this

00:07:09.400 --> 00:07:11.500
particular class that we're implementing.

00:07:11.530 --> 00:07:13.100
So let's start off with that now.

00:07:13.210 --> 00:07:15.290
Demo monkey, don't fail me.

00:07:18.030 --> 00:07:22.760
So this is just a CFString that's using
the reverse DNS naming convention.

00:07:22.800 --> 00:07:25.630
And then we want to implement
an API so the client,

00:07:25.650 --> 00:07:29.410
in this case, main,
will be able to register our class

00:07:29.590 --> 00:07:33.240
with the HI object subclassing system.

00:07:33.320 --> 00:07:38.880
So we define an API,
which is just ImageBrowserView register.

00:07:39.140 --> 00:07:45.320
And now let's go to the implementation
file and get started there.

00:07:48.150 --> 00:07:50.100
So most views,
to do anything very interesting,

00:07:50.100 --> 00:07:51.840
have to have a data
structure of some type.

00:07:52.030 --> 00:07:54.420
In our case,
since we're implementing an image browser

00:07:54.430 --> 00:07:58.240
and we have a collection of images,
we'll implement that as an array of

00:07:58.240 --> 00:08:02.990
images with an index specifying which
image is to be shown within that array.

00:08:03.130 --> 00:08:07.490
So we define our data
structure initially here.

00:08:07.910 --> 00:08:12.790
You can see that we maintain
a reference to the HIView ref,

00:08:12.790 --> 00:08:15.350
which corresponds to this instance.

00:08:15.690 --> 00:08:18.900
This is so that we can use
HIView APIs such as getting

00:08:18.900 --> 00:08:22.990
the bounds or HIView set frame,
for example.

00:08:23.050 --> 00:08:28.710
We also have our array of images
and the index into the array.

00:08:31.210 --> 00:08:38.770
Now to make my file easily navigable,
I add some sections so we could get

00:08:38.770 --> 00:08:41.880
these up in the function pop-up.

00:08:42.240 --> 00:08:44.080
which you'll see later.

00:08:44.260 --> 00:08:45.480
So we implement our function.

00:08:45.500 --> 00:08:47.890
This is our registration API.

00:08:48.740 --> 00:08:50.900
The Registration API,
all we do is we specify what

00:08:50.900 --> 00:08:52.960
events we're interested in,
and this is typical if

00:08:52.960 --> 00:08:55.670
you've done this before,
you register what events

00:08:55.680 --> 00:08:57.790
you're interested in,
and then call the

00:08:57.790 --> 00:08:59.600
HIObjectRegisterSubclass API.

00:08:59.600 --> 00:09:03.600
You pass in our class ID,
which we defined in the header.

00:09:03.600 --> 00:09:07.600
We tell what we're subclassing from,
which in this case is a HIView class.

00:09:07.600 --> 00:09:09.600
There's no options.

00:09:09.600 --> 00:09:13.300
We specify an event handler,
which we haven't yet implemented,

00:09:13.310 --> 00:09:15.470
and I'll get to that in just a moment.

00:09:15.470 --> 00:09:21.490
And then we pass in the count and the
array of events that we're interested in.

00:09:21.800 --> 00:09:24.440
This function will
return a class reference,

00:09:24.470 --> 00:09:27.090
which we store in this
static variable here.

00:09:27.160 --> 00:09:31.200
Now, the reason we do this is because
we only want to register once.

00:09:31.230 --> 00:09:34.700
So if our internal
API is called many times,

00:09:34.700 --> 00:09:37.730
of course, this will be non-null after
the first registration,

00:09:37.800 --> 00:09:40.570
and the registration only happens once.

00:09:41.760 --> 00:09:46.330
So now let's go implement our
Event Handler that deals with

00:09:46.330 --> 00:09:48.350
those events we've specified.

00:09:51.800 --> 00:09:53.930
This is just a standard
Carbon Event Handler.

00:09:53.950 --> 00:09:57.400
If you've been using Carbon Events,
this is just how you deal with it,

00:09:57.400 --> 00:10:01.140
where we deal with the specific
class and kind of that event,

00:10:01.170 --> 00:10:02.050
and we switch off of that.

00:10:02.200 --> 00:10:07.180
So this first section here is
the HIObject class handling,

00:10:07.180 --> 00:10:10.750
and we deal with such things as
construction and destruction here.

00:10:10.790 --> 00:10:12.830
And to deal with that,
I'm going to implement a

00:10:12.830 --> 00:10:17.490
function that will construct
and destruct our instance data.

00:10:27.980 --> 00:10:29.400
It's very odd typing standing up.

00:10:29.400 --> 00:10:31.900
I don't know if you actually
have done that before.

00:10:31.900 --> 00:10:36.540
So here we just deal with construction.

00:10:36.570 --> 00:10:41.110
And this is just when the HIView
system wants you to instantiate

00:10:41.130 --> 00:10:42.910
an instance of your class.

00:10:42.920 --> 00:10:44.790
You...

00:10:45.680 --> 00:10:48.900
You allocate enough memory
for your data structure,

00:10:48.900 --> 00:10:51.960
and one of the parameters in
that construction event is the

00:10:51.960 --> 00:10:54.250
HIObjectInstance parameter.

00:10:54.310 --> 00:10:57.600
This is the HIView that your
instance corresponds to.

00:10:57.660 --> 00:11:01.400
And so we're storing that
within our instance data.

00:11:01.800 --> 00:11:05.090
And finally, prior to leaving,
we set the HIObject instance

00:11:05.120 --> 00:11:08.680
data to be of type Avoid Pointer,
and this will be a

00:11:08.680 --> 00:11:10.800
reference to your instance.

00:11:10.880 --> 00:11:15.500
This is so that subsequent calls
to your event handler have a

00:11:15.580 --> 00:11:17.230
reference to your instance data.

00:11:17.370 --> 00:11:22.940
And you can see that that's passed in
as the user data from the event handler.

00:11:23.330 --> 00:11:27.020
So we can cast that into our
internal data and then use that

00:11:27.020 --> 00:11:29.110
in subsequent event handlers.

00:11:29.220 --> 00:11:33.020
So for example, when we deal with the
HIObjectDestruct event,

00:11:33.060 --> 00:11:35.320
we have that data available
that we can destroy.

00:11:35.320 --> 00:11:40.410
Let's go ahead and implement
that destruct handler as well.

00:11:42.940 --> 00:11:43.730
So this is very simple.

00:11:43.740 --> 00:11:45.980
We just clean up our
internal data structure.

00:11:45.980 --> 00:11:49.040
If there are any images that
are in our internal array,

00:11:49.080 --> 00:11:50.170
we free that up.

00:11:50.220 --> 00:11:54.540
And finally,
we free up our instance to avoid leaking.

00:11:54.980 --> 00:11:57.110
So those are the required events
to just get up and running.

00:11:57.220 --> 00:12:02.250
Let's go to the main.c file as the
test harness and get this thing going.

00:12:05.580 --> 00:12:08.490
So the first thing to do, of course,
is to include the header.

00:12:08.500 --> 00:12:12.080
And then during your
initialization of your application,

00:12:12.080 --> 00:12:17.410
you will want to register the subclasses
with the HIObject subclassing system.

00:12:17.420 --> 00:12:21.660
So we do that here.

00:12:21.880 --> 00:12:25.720
Perform some housekeeping.

00:12:31.330 --> 00:12:35.140
Next, since this is just the default
template that Xcode came up with,

00:12:35.140 --> 00:12:38.480
I want to remove the window creation
code from the main file and break

00:12:38.480 --> 00:12:42.290
that out into a separate function
so we can create an instance of our

00:12:42.290 --> 00:12:44.440
view and embed it in the window.

00:12:44.440 --> 00:12:49.310
So I'll remove our code that deals
with window creation and display.

00:12:58.950 --> 00:13:03.520
Clara Prototype,
make the code look nicer,

00:13:03.520 --> 00:13:08.490
and then implement that function.

00:13:14.910 --> 00:13:20.230
So what this does is it does pull
out the default window from the Nib.

00:13:20.360 --> 00:13:24.150
But then we want to create an instance
of the view that we've registered.

00:13:24.200 --> 00:13:28.200
So we call the API, hiobjectcreate,
passing in our class ID,

00:13:28.250 --> 00:13:31.160
and this will return an
instance of that class.

00:13:31.240 --> 00:13:34.490
The rest of the code in this function
deals with embedding it in the window,

00:13:34.510 --> 00:13:37.190
setting its bounds,
and making it visible.

00:13:37.250 --> 00:13:39.420
Since we haven't dealt with drawing yet,
there's not gonna be anything

00:13:39.420 --> 00:13:41.500
that's visible when we run this app.

00:13:41.540 --> 00:13:43.400
But let's go ahead and do that.

00:13:48.280 --> 00:13:51.690
Build, Run, ah, good thing I ran it.

00:13:51.820 --> 00:13:54.520
One thing I did forget was to
actually call this function.

00:13:54.600 --> 00:13:56.130
From Maine.

00:14:03.250 --> 00:14:06.120
So now you can see that it just looks
like the standard application that's

00:14:06.120 --> 00:14:09.740
created from the template because we've
loaded it in the window from the nib.

00:14:09.790 --> 00:14:11.740
But behind the scenes,
what we've done is we've created

00:14:11.740 --> 00:14:13.770
an instance of this class,
embedded it in the window,

00:14:13.770 --> 00:14:15.060
but we're not dealing with drawing yet.

00:14:15.100 --> 00:14:16.630
So let's talk about that.

00:14:16.640 --> 00:14:18.020
Bryan.

00:14:18.070 --> 00:14:18.860
Thank you, Curt.

00:14:18.860 --> 00:14:22.140
Back to slides.

00:14:23.890 --> 00:14:24.800
Great.

00:14:24.800 --> 00:14:26.700
We have a view.

00:14:26.700 --> 00:14:31.040
It doesn't draw, but that can be used for
something like a grouping view.

00:14:31.080 --> 00:14:33.430
But we already have a user pane,
so let's do something a

00:14:33.430 --> 00:14:34.900
little more interesting.

00:14:34.900 --> 00:14:36.720
So, drawing.

00:14:37.010 --> 00:14:41.300
Drawing in the modern HIToolbox
is based on a compositing model.

00:14:41.300 --> 00:14:43.510
What compositing means is
that we can -- if you give the

00:14:43.660 --> 00:14:46.710
toolbox enough information,
it can really optimize when your

00:14:46.720 --> 00:14:48.540
view actually needs to draw.

00:14:48.610 --> 00:14:52.430
To provide this information,
use HIView set needs to display

00:14:52.490 --> 00:14:54.240
to invalidate your view.

00:14:54.290 --> 00:14:56.820
So invalidation is very lightweight.

00:14:56.860 --> 00:15:00.690
You can very quickly say on
any particular state change,

00:15:00.760 --> 00:15:02.790
I will need to draw based on this change.

00:15:02.840 --> 00:15:07.640
So the toolbox will let the toolbox know,
and the next time through the event loop,

00:15:07.640 --> 00:15:12.310
the toolbox will coalesce all these
lightweight invalidations and request

00:15:12.310 --> 00:15:23.990
that you draw once by sending you
a K event control draw message.

00:15:26.740 --> 00:15:29.700
I'm sorry, one thing I forgot to mention.

00:15:29.700 --> 00:15:33.510
You can set kWindowCompositingAttribute
onto your window so that

00:15:33.510 --> 00:15:34.520
it supports compositing.

00:15:34.540 --> 00:15:38.090
So compositing is a window
by window attribute.

00:15:39.490 --> 00:15:41.290
Now let's go back to Curt for drawing.

00:15:41.300 --> 00:15:43.430
Okay, thank you.

00:15:43.510 --> 00:15:45.740
So prior to,
before we get into drawing actually,

00:15:45.740 --> 00:15:49.280
I wanted to talk about initialization
because this is important for a client

00:15:49.320 --> 00:15:55.780
to be able to initialize a view or an
object with some information initially.

00:15:55.840 --> 00:15:57.690
One of the parameters
to HI Object Create is

00:15:57.690 --> 00:16:00.420
initialization Carbon Event.

00:16:00.660 --> 00:16:03.410
Now this is important because
the client can then set event

00:16:03.490 --> 00:16:06.480
parameters in that event,
which the view can then pull

00:16:06.480 --> 00:16:08.390
out during initialization.

00:16:09.000 --> 00:16:11.600
The client, if it wants to support
this type of feature,

00:16:11.670 --> 00:16:14.860
it needs to advertise what
types of parameters it will

00:16:14.860 --> 00:16:16.080
get during initialization.

00:16:16.120 --> 00:16:18.910
So let's do that in our Views header.

00:16:22.510 --> 00:16:28.070
So I have two constants here,
and one represents an image array.

00:16:28.270 --> 00:16:31.500
So this is the view advertising
that during initialization,

00:16:31.560 --> 00:16:35.130
it will attempt to pull
out an array of images.

00:16:35.180 --> 00:16:37.280
This is really just a
four-character code.

00:16:37.340 --> 00:16:41.320
And also we define what type we
expect that to be and a description.

00:16:41.380 --> 00:16:46.620
So we expect it to be a CFArrayRef of
CFURLRefs to images that are on disk.

00:16:46.620 --> 00:16:49.490
Additionally,
this view will attempt to pull out

00:16:49.560 --> 00:16:51.940
the image URL Carbon Event parameter.

00:16:52.400 --> 00:16:55.920
Which it will expect to be a CFStringRef,
which represents a

00:16:55.920 --> 00:16:57.380
path to a file on disk.

00:16:57.470 --> 00:16:59.340
Now the client would plug into this.

00:16:59.340 --> 00:17:01.820
If I go back to the main file,

00:17:07.660 --> 00:17:11.280
The client would plug into
this by providing a string,

00:17:11.280 --> 00:17:16.260
creating a variable that's
an initialization event.

00:17:16.280 --> 00:17:18.990
It will create that initialization event.

00:17:25.600 --> 00:17:29.530
Set that parameter in the event,
and then provide that

00:17:29.720 --> 00:17:34.810
initialization event as the
parameter into hiobject.create.

00:17:39.580 --> 00:17:40.760
So that's all that we do on the client.

00:17:40.840 --> 00:17:45.320
Oh, next of course is to release
that event so we don't leak.

00:17:47.700 --> 00:17:51.640
So let's go ahead and implement
support for initialization.

00:17:51.740 --> 00:17:53.710
From our function pop-up,

00:17:56.860 --> 00:18:00.010
Function Pop-up doesn't seem to
be working correctly right now.

00:18:00.070 --> 00:18:03.470
So let's go ahead and we now
indicate that we're interested

00:18:03.480 --> 00:18:05.250
in the initialization event here.

00:18:05.260 --> 00:18:10.110
We go back up to our event handler.

00:18:13.700 --> 00:18:17.610
handle that event,
and then we go about implementing the

00:18:17.610 --> 00:18:20.160
function to deal with initialization.

00:18:24.600 --> 00:18:27.000
Since we are subclassing
from another class,

00:18:27.000 --> 00:18:29.100
it's important that we allow
the superclass an opportunity

00:18:29.100 --> 00:18:30.100
to initialize itself.

00:18:30.180 --> 00:18:32.900
So in this case, the HIView superclass.

00:18:32.900 --> 00:18:36.400
So we call next event handler
to allow that to happen.

00:18:36.400 --> 00:18:39.800
I go about initializing my instance data.

00:18:39.800 --> 00:18:43.020
And then I attempt to pull out
those initialization parameters.

00:18:43.020 --> 00:18:46.060
So initially we tried to
pull out the URL array.

00:18:46.060 --> 00:18:49.570
Now in this example,
the main.c file hasn't provided that.

00:18:49.610 --> 00:18:53.420
So this function will return an
error and not touch this variable.

00:18:53.920 --> 00:18:55.370
We've already initialized it to null.

00:18:55.380 --> 00:18:57.560
So if it doesn't touch it,
we're golden here.

00:18:57.560 --> 00:19:01.270
If the array is available,
we create a mutable copy of

00:19:01.270 --> 00:19:02.540
that and store it internally.

00:19:02.540 --> 00:19:06.090
Otherwise, we create an empty array that
we'll store images into later.

00:19:09.590 --> 00:19:14.500
Next, we attempt to pull out the image
URL Carbon Event parameter.

00:19:14.560 --> 00:19:17.600
And this is defined in the
header to be a CFStringRef,

00:19:17.600 --> 00:19:20.500
and we put it in the image path variable.

00:19:20.510 --> 00:19:25.000
If that exists, since it does represent
a file on disk as a URL,

00:19:25.000 --> 00:19:29.100
we create a CFURLRef out of it,
add it to our internal array,

00:19:29.130 --> 00:19:30.800
and then release it.

00:19:30.810 --> 00:19:33.400
The other thing to note here
is that during initialization,

00:19:33.400 --> 00:19:36.710
we're calling HIViewChangeFeatures,
and we're turning on

00:19:36.710 --> 00:19:38.400
the isOpaque feature.

00:19:38.430 --> 00:19:42.020
This can be a performance optimization
because the view system assumes

00:19:42.080 --> 00:19:43.600
that your view is non-opaque.

00:19:43.630 --> 00:19:48.190
So it must draw the views behind
your view prior to drawing your view.

00:19:48.200 --> 00:19:49.500
If we know our view
is going to be opaque,

00:19:49.510 --> 00:19:52.260
which we do in this particular case,
since we're implementing it,

00:19:52.330 --> 00:19:54.610
we can set this feature and
the view system will not

00:19:54.610 --> 00:19:55.690
draw the views behind you.

00:19:55.700 --> 00:19:59.930
This can be a performance win because
it's just going to be overdrawn anyway.

00:20:01.310 --> 00:20:03.890
Now that we've done that,
let's go back to our handler,

00:20:03.890 --> 00:20:11.500
or our array of event types that
we handle and deal with drawing.

00:20:21.900 --> 00:20:26.160
We handle the Draw Carbon Event,
and then we implement the function

00:20:26.160 --> 00:20:28.680
that actually deals with drawing.

00:20:31.850 --> 00:20:34.520
Now this of course is going
to be specific to your view,

00:20:34.520 --> 00:20:37.250
but I'll just describe
what we're doing here.

00:20:37.330 --> 00:20:43.510
Basically, we pull out the CG context
from the Draw Carbon Event,

00:20:43.620 --> 00:20:47.160
We fill it with black,
and then if there are any images that

00:20:47.210 --> 00:20:49.990
are stored in our internal array,
we create a CG image out of it

00:20:50.080 --> 00:20:52.870
and blast it to that context.

00:20:54.370 --> 00:20:57.860
If you note here,
I'm using some constants here,

00:20:57.870 --> 00:21:00.740
so I must add that to the
top of my file as well.

00:21:00.740 --> 00:21:04.660
So, hope this doesn't make you
dizzy as I navigate around.

00:21:09.710 --> 00:21:16.450
Now finally, as Bryan mentioned,
the view model, it uses an invalidation

00:21:16.450 --> 00:21:18.060
method of redrawing.

00:21:18.110 --> 00:21:20.880
So for example,
if I want to draw differently,

00:21:20.920 --> 00:21:25.540
if the view is inactive,
then rather than dealing

00:21:25.540 --> 00:21:28.100
with the deactivate event
and then drawing right then,

00:21:28.120 --> 00:21:30.510
which is called out of band
drawing because it's not being

00:21:30.510 --> 00:21:33.760
requested by the view system,
we want to just invalidate.

00:21:33.790 --> 00:21:37.470
So just as an example,
let's go back and deal with that as well.

00:21:40.620 --> 00:21:44.200
So we add support for deactivate
and deactivate Carbon Events.

00:21:44.200 --> 00:21:49.490
Handle those in our Event Handler.

00:21:50.510 --> 00:21:55.100
And we handle that by calling
the API HIView Set Needs Display.

00:21:55.120 --> 00:21:57.740
This just invalidates and
at the best opportunity,

00:21:57.740 --> 00:22:02.910
the view system will then
call our draw handler to draw.

00:22:03.300 --> 00:22:05.200
Since we want to draw
differently based on whether

00:22:05.200 --> 00:22:08.430
the view is active or inactive,
we must deal with the state

00:22:08.440 --> 00:22:09.850
within the draw handler as well.

00:22:10.020 --> 00:22:14.770
So if you had some keen eyes,
you may have noticed in the draw handler,

00:22:14.770 --> 00:22:17.400
I had this little section that
dealt with the state of the view.

00:22:17.400 --> 00:22:19.220
If it's active,
go ahead and draw it one way.

00:22:19.260 --> 00:22:22.080
Otherwise, draw it a different way.

00:22:22.110 --> 00:22:24.120
Let's go ahead and build.

00:22:26.010 --> 00:22:31.220
We're drawing the image that
was first passed into our

00:22:31.220 --> 00:22:33.510
view during initialization.

00:22:33.750 --> 00:22:34.920
So this is all fine and dandy.

00:22:35.020 --> 00:22:37.790
In the test harness,
we were able to create an instance of

00:22:37.790 --> 00:22:40.760
our view and embed it programmatically,
but you can also do this

00:22:40.760 --> 00:22:42.540
in an interface builder,
which makes it a lot easier.

00:22:42.540 --> 00:22:45.730
So I just wanna briefly talk
about doing that as well.

00:22:46.990 --> 00:22:52.820
First, you can open up the Nib and
from this toolbar window,

00:22:52.850 --> 00:22:58.290
if you go to the Enhanced Controls,
there's an item here for HIView.

00:23:05.420 --> 00:23:08.880
Up in the Tools menu,
there is a Show Inspector window.

00:23:08.900 --> 00:23:13.440
And one of the fields in this
Inspector window is a Class ID field.

00:23:13.520 --> 00:23:16.080
This is really just the
Class ID of your instance,

00:23:16.100 --> 00:23:17.650
which we have defined.

00:23:17.670 --> 00:23:21.890
So let's go back to our header file,
pull out the contents

00:23:21.890 --> 00:23:26.130
of that class string,
go back to Interface Builder,

00:23:27.000 --> 00:23:28.360
Plug it in there.

00:23:28.410 --> 00:23:31.570
So now when this nib is loaded,
it will create an instance of our view

00:23:31.640 --> 00:23:33.430
embedded in that window automatically.

00:23:33.460 --> 00:23:35.560
We don't have to write
any code to do that.

00:23:35.810 --> 00:23:40.100
Now also in our main.c file,
in our test harness anyway,

00:23:40.130 --> 00:23:42.900
we are providing an
initialization parameter as well.

00:23:42.960 --> 00:23:45.830
Well,
you can do that in Interface Builder too.

00:23:45.860 --> 00:23:48.720
So first let's go ahead
and add a parameter.

00:23:49.180 --> 00:23:53.270
It takes the name,
which really is one of these constants.

00:23:53.300 --> 00:23:57.220
So I take the four character code
that represents this constant.

00:23:58.740 --> 00:24:01.100
So what I'm trying to do right
now is just mimic exactly

00:24:01.100 --> 00:24:02.380
what our code was doing.

00:24:02.380 --> 00:24:06.120
I add the four character constant there.

00:24:06.140 --> 00:24:09.320
The type we identified to be a CFString.

00:24:09.330 --> 00:24:10.160
I selected that.

00:24:10.160 --> 00:24:12.180
You may notice that Interface
Builder has a bug on Tiger,

00:24:12.180 --> 00:24:15.310
that it doesn't update the UI here,
but you can tell that it

00:24:15.310 --> 00:24:16.620
is a CFStringRef here.

00:24:16.660 --> 00:24:18.960
And the value will be
the path to the image.

00:24:18.990 --> 00:24:23.080
So the image path we
have in our main file.

00:24:37.900 --> 00:24:39.860
So now since we're doing this
all in Interface Builder,

00:24:39.860 --> 00:24:43.920
all of this code that we
wrote to create and initialize

00:24:43.920 --> 00:24:46.660
this view can just go away.

00:24:48.500 --> 00:24:51.850
That.

00:24:51.850 --> 00:24:54.320
Don't need any of this.

00:24:56.620 --> 00:24:58.200
Nor do we need this.

00:24:58.200 --> 00:25:04.280
Ah, another cool thing about NIBs, well,
another cool thing about views

00:25:04.280 --> 00:25:06.380
in general is that you can
affect the layouts of them.

00:25:06.380 --> 00:25:08.510
You can bind the layout
of a view to its parent,

00:25:08.590 --> 00:25:09.220
for instance.

00:25:09.360 --> 00:25:12.540
You can do this programmatically
using the HIView layout APIs,

00:25:12.580 --> 00:25:14.120
but it's so much easier to
do in Interface Builder,

00:25:14.120 --> 00:25:16.130
I don't know why you wouldn't want to.

00:25:16.150 --> 00:25:19.430
So if you go back to the
Inspector and go to the Layout menu,

00:25:19.460 --> 00:25:21.870
you can bind this to the parent.

00:25:23.300 --> 00:25:29.400
[Transcript missing]

00:25:30.770 --> 00:25:33.580
So let's build, run.

00:25:33.600 --> 00:25:38.530
Now you can see that our view has
been added by loading in the nib.

00:25:38.580 --> 00:25:41.490
We didn't write any code at
this point to get this up and

00:25:41.730 --> 00:25:44.020
running from the test harness.

00:25:44.060 --> 00:25:48.100
And then it handles such things
as live resize automatically.

00:25:48.100 --> 00:25:48.940
So that's pretty cool.

00:25:48.990 --> 00:25:51.480
And now we're ready to move on to
adding some more functionality,

00:25:51.480 --> 00:25:53.470
which Bryan will talk about now.

00:25:54.250 --> 00:25:55.590
Thank you, Curt.

00:25:55.610 --> 00:25:57.200
As you can see,
our view is really beginning to

00:25:57.200 --> 00:25:59.100
look like a view now that we draw.

00:25:59.100 --> 00:26:03.800
But again, we already have an image view,
so it's very important not to try and do,

00:26:03.800 --> 00:26:07.100
again, reinvent the wheel for views
that the toolbox already handles.

00:26:07.100 --> 00:26:09.070
Make sure to use those where necessary.

00:26:09.130 --> 00:26:11.860
So let's go ahead and start
adding some more features so that

00:26:11.860 --> 00:26:13.610
we can differentiate ourselves.

00:26:14.880 --> 00:26:18.900
So now that the user can see the view,
they may want to interact with it.

00:26:18.970 --> 00:26:21.620
The basic way to do this
is through mouse tracking.

00:26:21.660 --> 00:26:25.670
And to begin mouse tracking,
we'll talk about hit testing.

00:26:25.830 --> 00:26:31.130
to handle the K Event Control hit test is
to allow the toolbox to ask the question,

00:26:31.130 --> 00:26:34.840
"What part of your view is under
the current point?" Typically the

00:26:34.840 --> 00:26:36.890
mouse moving over your view.

00:26:36.960 --> 00:26:39.490
And when I say part here,
I mean an actual enumerated

00:26:39.560 --> 00:26:40.600
part of your view.

00:26:40.600 --> 00:26:42.690
So let me talk about that a little bit.

00:26:43.000 --> 00:26:43.890
Let's look at the scroll bar.

00:26:44.000 --> 00:26:45.390
The scroll bar has lots of pieces to it.

00:26:45.400 --> 00:26:50.900
It has a scroll thumb,
page up and down parts,

00:26:51.140 --> 00:26:52.160
scroll arrow parts.

00:26:52.160 --> 00:26:56.010
So each one of these five pieces are
enumerated parts within the scroll view.

00:26:56.040 --> 00:27:00.760
These could be implemented
as actual embedded subviews,

00:27:00.760 --> 00:27:03.420
but that's a little heavyweight,
and we really don't need that

00:27:03.420 --> 00:27:05.000
kind of support in this case.

00:27:05.160 --> 00:27:08.220
So the scroll bar itself knows
where each of these parts are,

00:27:08.220 --> 00:27:14.060
how large they are, how to draw them,
and how to react to tracking across them.

00:27:14.060 --> 00:27:17.240
So we want to do the same thing with
the Image Browser View Sample Code.

00:27:17.260 --> 00:27:20.860
Here you can see in the
green ring are our parts,

00:27:20.860 --> 00:27:25.010
forward and backward part,
and delete image part.

00:27:26.290 --> 00:27:29.640
Now that we handle hit testing,
the very basic tracking is

00:27:29.690 --> 00:27:33.200
actually kind of half handled
for us by the toolbox already.

00:27:33.200 --> 00:27:36.220
If you handle hit testing,
the toolbox can ask the question,

00:27:36.290 --> 00:27:38.770
"What part is under the mouse?"
If somebody clicks on our part

00:27:38.820 --> 00:27:41.150
and tracks on and off of it,
the toolbox will automatically

00:27:41.240 --> 00:27:45.270
set the highlight state to
that part or from that part,

00:27:45.270 --> 00:27:47.140
depending on whether the
mouse is tracked on or off.

00:27:47.200 --> 00:27:52.300
So all our view needs to do is react
to the Control Highlight Changed event,

00:27:52.300 --> 00:27:56.530
invalidate, and then when we go back
through the event loop and

00:27:56.530 --> 00:28:00.200
our view is requested to draw,
we just look at our highlight state

00:28:00.200 --> 00:28:03.830
and draw our part accordingly.

00:28:03.990 --> 00:28:06.740
Then when the mouse comes up,
we can receive the

00:28:06.740 --> 00:28:10.390
K event control hit event,
and this will allow you to react to

00:28:10.390 --> 00:28:13.490
that mouse click after it has occurred.

00:28:14.420 --> 00:28:18.300
Now, often you might want to handle,
do some more custom tracking.

00:28:18.320 --> 00:28:22.240
So for this, you will want to handle the
K event control track event.

00:28:22.340 --> 00:28:26.970
And this will be sent when the user
mouses down and drags across your view.

00:28:28.800 --> 00:28:32.010
Something that you may have in
existing C-DEFs in your code is

00:28:32.010 --> 00:28:34.300
Still Down within a Wow Loop.

00:28:34.340 --> 00:28:36.140
This is something we've talked
about for a couple years now,

00:28:36.140 --> 00:28:43.090
and I just want to reiterate
that Still Down is a polling API.

00:28:43.800 --> 00:29:21.600
[Transcript missing]

00:29:22.240 --> 00:29:24.490
and second,
it's completely compatible with

00:29:24.640 --> 00:29:29.250
the compositing model on the
window and will run the run the

00:29:29.300 --> 00:29:30.890
quickly every time you call it.

00:29:30.970 --> 00:29:34.990
So any invalidations that you've
performed will cause a draw

00:29:34.990 --> 00:29:37.580
event to be sent to your view.

00:29:39.320 --> 00:29:41.910
All right,
now that we handled basic mouse tracking,

00:29:41.910 --> 00:29:43.170
let's go to the next step.

00:29:43.280 --> 00:29:46.330
For users of the keyboard,
whether people who just

00:29:46.580 --> 00:29:50.650
prefer it or by necessity,
talk about keyboard navigation.

00:29:50.890 --> 00:29:54.730
As you tab through the
views in your window,

00:29:54.740 --> 00:30:01.160
your view will be sent the K event
control set focus part event.

00:30:01.480 --> 00:30:04.440
and it will be, you'll leave the review,
one of the enumerated parts of

00:30:04.440 --> 00:30:08.840
review to set focus or a meta part,
the next part of your view,

00:30:08.840 --> 00:30:14.510
the previous part or no part if the
toolbox is telling you to lose focus.

00:30:15.100 --> 00:30:18.960
Now, so we can see an example here.

00:30:18.990 --> 00:30:22.870
Tabbing from an
Edit Text field to our view.

00:30:23.340 --> 00:30:26.200
And then if they were
handed the next event part,

00:30:26.200 --> 00:30:29.690
even tab to the subparts
within your view.

00:30:29.930 --> 00:30:35.300
Now many views, like the Edit Text field,
accept focus when the user clicks on it.

00:30:35.370 --> 00:30:39.130
If you want to handle this in your view,
set the Get Focus on Click feature,

00:30:39.340 --> 00:30:42.980
and your view will automatically
be requested to set its focus.

00:30:43.980 --> 00:30:46.700
Now that your view is focused,
the whole point of focusing is

00:30:46.700 --> 00:30:51.000
that your view can then receive
text events from the keyboard.

00:30:51.150 --> 00:30:54.780
So you can handle these through the
KEvent class Text Input suite of events.

00:30:54.790 --> 00:30:57.460
And specifically in this case,
we'll be talking about KEvent

00:30:57.540 --> 00:30:59.800
Text Input Unicode for Key Event.

00:31:00.110 --> 00:31:07.800
You may see in the suite of events,
KEventRawKeyDown.

00:31:07.800 --> 00:31:07.800
This is something you want to
try and avoid if at all possible.

00:31:08.170 --> 00:31:10.360
and I will be talking about the
It gives you the naked raw key

00:31:10.360 --> 00:31:11.540
event that the user pressed.

00:31:11.590 --> 00:31:15.170
And it doesn't allow the toolbox to
do some work for you on your behalf,

00:31:15.200 --> 00:31:18.560
like send the event through
a Text Input method first,

00:31:18.570 --> 00:31:19.470
for instance.

00:31:19.520 --> 00:31:23.260
So make sure to handle the
Unicode for key event instead.

00:31:24.040 --> 00:31:29.350
So you can use the arrow keys to then,
in addition to tabbing through your view,

00:31:29.370 --> 00:31:31.540
if you can see the updating there.

00:31:31.620 --> 00:31:35.110
And when the user hits the space bar,
this means that you should

00:31:35.170 --> 00:31:36.820
simulate a click on a part.

00:31:36.880 --> 00:31:40.640
To do this,
receive the spacebar key event

00:31:40.690 --> 00:31:44.920
and call HIView simulate click on
the part that's currently focused.

00:31:45.550 --> 00:31:48.750
"HIV Simulate Click" is really
great because it will actually

00:31:48.750 --> 00:31:51.510
highlight that part of your view.

00:31:52.460 --> 00:31:57.380
and then it will behave as if the
toolbox will simulate an actual mouse

00:31:57.780 --> 00:31:59.540
click on your view on that part.

00:31:59.600 --> 00:32:02.520
And so your existing mouse tracking
code can just handle that event

00:32:02.690 --> 00:32:05.820
and you don't need to worry about
it anymore in your text handler,

00:32:05.860 --> 00:32:07.480
or text input handler.

00:32:07.550 --> 00:32:12.730
So in this case,
it continues on to click the part and

00:32:12.730 --> 00:32:15.310
you can see the image was deleted.

00:32:16.880 --> 00:32:19.590
The third stage,
and something that is really important

00:32:19.700 --> 00:32:22.800
to reach as many people as you can,
as many users,

00:32:22.800 --> 00:32:24.560
is to support Accessibility.

00:32:24.630 --> 00:32:27.560
I'm just going to go over
this very quickly here.

00:32:27.630 --> 00:32:29.380
You can handle Accessibility
through the K-Event

00:32:29.670 --> 00:32:31.800
Class Accessibility suite of events.

00:32:31.900 --> 00:32:34.790
Accessibility is concerned
with three main topics:

00:32:34.840 --> 00:32:37.080
A parent-child hierarchy,

00:32:37.410 --> 00:32:42.300
Attributes of your view,
some information about your view,

00:32:42.300 --> 00:32:44.900
and then Actions,
what does your view actually do?

00:32:44.960 --> 00:32:50.730
And this is information that can be sent
back to VoiceOver for disabled users.

00:32:52.110 --> 00:32:54.570
Now, we don't have a lot of time to go
into that in this particular session.

00:32:54.700 --> 00:32:58.630
I hope you were able to see the
Carbon Accessibility session yesterday.

00:32:58.720 --> 00:33:02.790
If not, if you have other questions,
visit the Accessibility Lab on

00:33:02.930 --> 00:33:03.890
Friday from 2:00 to 5:00.

00:33:03.950 --> 00:33:06.780
We'll have engineers there to help you.

00:33:08.850 --> 00:33:10.850
- All right, and with that,
I want to pass things off to

00:33:10.850 --> 00:33:13.620
Curt for a demo on user interaction.

00:33:13.620 --> 00:33:15.230
- Great, thanks, Bryan.

00:33:15.280 --> 00:33:18.750
So this is where the meat of
our view creation really is.

00:33:18.780 --> 00:33:22.980
It's dealing with user input so they
can interact with your view and get at

00:33:23.290 --> 00:33:26.650
some of the features that it implements.

00:33:27.500 --> 00:33:32.620
- So if you recall, of course, the draw,
you only draw in the draw method

00:33:32.620 --> 00:33:34.320
or in the draw event handler.

00:33:34.430 --> 00:33:38.580
So what we wanna do is since
we're adding multiple parts,

00:33:38.600 --> 00:33:40.810
we wanna be able to draw focus
around those different parts.

00:33:40.930 --> 00:33:45.170
So I need to maintain some state in my
data structure so I know during drawing

00:33:45.170 --> 00:33:47.500
which part is to currently be focused.

00:33:47.500 --> 00:33:50.340
So let's go ahead and add
some functionality now.

00:33:53.290 --> 00:33:56.860
So I add a current focus part
so I can maintain that state.

00:33:56.930 --> 00:34:02.100
And additionally,
I'm going to be adding these three

00:34:02.110 --> 00:34:03.810
fields which deal with image caching.

00:34:03.820 --> 00:34:06.200
This isn't strictly
necessary for user input,

00:34:06.260 --> 00:34:08.890
but I'm just going to implement
this now because it makes drawing

00:34:08.890 --> 00:34:11.690
faster and resize faster as well.

00:34:14.080 --> 00:34:19.130
Next, I'm adding constants that deal with
the different parts now because

00:34:19.270 --> 00:34:23.000
each of those parts have a size,
a margin, and some padding between them.

00:34:23.060 --> 00:34:25.000
So I add those constants there.

00:34:25.000 --> 00:34:28.400
And finally, I add an enumeration of
what those parts are.

00:34:28.400 --> 00:34:30.620
So you can see here that
we have the image part,

00:34:30.620 --> 00:34:32.100
which is the image itself.

00:34:32.110 --> 00:34:36.710
We'll have a back part, a forward part,
and a delete image part.

00:34:37.650 --> 00:34:40.010
Now since we've added some
fields to our data structure,

00:34:40.010 --> 00:34:42.100
we have to make sure to
initialize those as well.

00:34:42.100 --> 00:34:46.620
So back in our initialize function.

00:34:56.810 --> 00:34:58.200
We initialized that out.

00:34:58.200 --> 00:35:11.020
Next, we wanna make sure that
we draw these new parts.

00:35:11.080 --> 00:35:17.430
So we modify our draw function and deal
with the different parts and the focus.

00:35:17.470 --> 00:35:21.050
So I'll add that additional
code in here and I'll just

00:35:21.050 --> 00:35:23.130
describe briefly what I've done.

00:35:25.110 --> 00:35:27.760
The beginning part of this
function is essentially the same.

00:35:27.760 --> 00:35:30.840
We're just making sure that there's
an image in our array and then

00:35:30.840 --> 00:35:33.800
we're drawing that using CGImageRef.

00:35:33.940 --> 00:35:36.850
The additional code that we added
in here was just dealing with that

00:35:36.850 --> 00:35:39.000
image cache for performance reasons.

00:35:39.030 --> 00:35:40.860
So let's skip that part for now.

00:35:40.860 --> 00:35:44.390
Move down to this next block here.

00:35:45.740 --> 00:35:49.040
This just looks at our internal
state and determines what part is

00:35:49.040 --> 00:35:53.910
currently focused and draws a focus
box around that part if necessary.

00:35:55.160 --> 00:35:58.830
This next block actually deals with
drawing those additional parts.

00:35:58.890 --> 00:36:01.240
So we have a section here
that draws the back part,

00:36:01.240 --> 00:36:04.550
which is a triangle, a forward part,
which is also a triangle,

00:36:04.600 --> 00:36:07.430
and a delete part,
which is that X display

00:36:07.430 --> 00:36:09.250
that you probably saw.

00:36:09.340 --> 00:36:13.270
So it looks dense,
but it's not really that dense.

00:36:16.580 --> 00:36:19.330
Now let's go add some
support for user input.

00:36:19.340 --> 00:36:25.960
So let's start off with
just the hit test handler.

00:36:26.030 --> 00:36:29.100
So we specify that we're
interested in hit testing.

00:36:35.410 --> 00:36:36.840
Add a Handler for Hit Testing.

00:36:36.840 --> 00:36:43.590
Then I go up to my Event Handling section
and add a function to deal with that.

00:36:45.000 --> 00:36:48.500
What this function does is it
pulls out the mouse location event

00:36:48.520 --> 00:36:50.700
parameter from the Carbon Event.

00:36:50.720 --> 00:36:53.980
It determines what part that
mouse point corresponds to.

00:36:53.990 --> 00:36:57.640
I should note that that mouse
point is in View Local Coordinates.

00:36:57.670 --> 00:36:59.280
Determines whether the part's available.

00:36:59.420 --> 00:37:02.320
And then finally,
it notifies the system what part

00:37:02.320 --> 00:37:07.810
was hit by setting the control
part event parameter to that part.

00:37:08.020 --> 00:37:09.750
So that's pretty simple.

00:37:09.800 --> 00:37:13.690
Let's go back and add some
support for more user interaction.

00:37:15.550 --> 00:37:20.060
As you notice,
as we incrementally improve on our view,

00:37:20.060 --> 00:37:21.140
we're just taking three steps.

00:37:21.270 --> 00:37:26.320
We basically add an event type to
our main array to tell the system

00:37:26.370 --> 00:37:28.880
which events we're interested in.

00:37:28.940 --> 00:37:30.940
Then we add a handler for that
in our main event handler,

00:37:30.980 --> 00:37:33.220
and then we just implement a
function to do that functionality.

00:37:33.220 --> 00:37:39.320
So here I will add handlers for tracking,
hitting, setting, and getting the focus,

00:37:39.350 --> 00:37:41.800
and dealing with the highlight changed.

00:37:44.000 --> 00:37:44.840
Step one.

00:37:44.840 --> 00:37:49.500
Step two is to add handlers for
those different Carbon Events.

00:37:56.110 --> 00:37:59.470
And then finally,
implement those functions by going up to

00:37:59.470 --> 00:38:02.050
the Event Handler section of our code.

00:38:03.200 --> 00:38:07.280
We'll start with the Carbon Events.

00:38:07.280 --> 00:38:11.610
We'll set the Control Part Parameter.

00:38:11.610 --> 00:38:17.080
As with all Carbon Events,
if you return no error,

00:38:17.090 --> 00:38:22.870
you're indicating that
you've handled the event.

00:38:22.940 --> 00:38:26.420
In this particular case,
we tell the View System that if the

00:38:26.620 --> 00:38:29.840
user is trying to track the image,
don't do anything.

00:38:29.840 --> 00:38:30.420
We've handled it.

00:38:30.470 --> 00:38:33.530
That's because we don't actually
handle tracking the image.

00:38:33.680 --> 00:38:35.180
But we do handle tracking the parts.

00:38:35.180 --> 00:38:37.030
At this point,
we'll be returning event not

00:38:37.120 --> 00:38:40.480
handled for those additional parts,
and the default tracking will

00:38:40.490 --> 00:38:42.540
be handled by the View System.

00:38:42.540 --> 00:38:47.420
Let's add the next handler.

00:38:50.200 --> 00:38:53.900
This is the view hit handler,
and this is where we react

00:38:53.900 --> 00:38:56.130
to a hit on one of our parts.

00:38:56.140 --> 00:38:59.660
So we pull out what part was hit,
make sure it's available,

00:38:59.790 --> 00:39:01.610
and then deal with that part being hit.

00:39:01.640 --> 00:39:04.300
So if the back part was hit,
we go to the previous

00:39:04.450 --> 00:39:05.930
image and et cetera.

00:39:05.950 --> 00:39:07.320
I haven't implemented
these functions yet.

00:39:07.340 --> 00:39:10.510
Those will go in in
just a moment as well.

00:39:15.780 --> 00:39:18.480
Next, we implement this function
which may look kind of long,

00:39:18.480 --> 00:39:20.140
which is to set the focus.

00:39:20.210 --> 00:39:22.420
This is when the view system is
telling us that one of our parts

00:39:22.810 --> 00:39:24.290
has been requested to focus.

00:39:24.310 --> 00:39:28.890
It can be one of the part IDs itself
or one of the meta parts such

00:39:28.940 --> 00:39:30.730
as the next or previous part.

00:39:30.810 --> 00:39:33.930
So this large switch statement
here is really just our view

00:39:33.930 --> 00:39:38.730
determining what is the next part
that should be selected or focused.

00:39:41.200 --> 00:39:45.000
- Then we set which
part has been focused.

00:39:45.020 --> 00:39:47.830
And then this block down here
just deals with invalidation

00:39:47.860 --> 00:39:50.310
because if the focus has changed,
we wanna make sure that

00:39:50.310 --> 00:39:51.220
we draw differently.

00:39:51.240 --> 00:39:56.870
We want to remove the focus from one part
and enable it over another part as well.

00:40:01.100 --> 00:40:03.980
Next is to handle the GetFocus part.

00:40:04.280 --> 00:40:07.300
This is just the view system wanting to
know which part is focused right now.

00:40:07.300 --> 00:40:13.830
And we just returned the control part
event parameter with our internal state.

00:40:13.840 --> 00:40:20.170
And the last handler we'll do
right now is the HighlightChanged.

00:40:23.590 --> 00:40:25.450
Highlight Change is basically
the view system saying,

00:40:25.450 --> 00:40:28.100
"Hey, your highlights changed." And so
the only thing of importance in here

00:40:28.100 --> 00:40:29.950
is that we're just invalidating.

00:40:29.960 --> 00:40:33.400
We're calling the HIViewSetNeedsDisplay
variant of the API.

00:40:33.440 --> 00:40:35.720
This code here is just as an
optimization because we don't

00:40:35.720 --> 00:40:36.680
want to invalidate the whole view.

00:40:36.680 --> 00:40:39.230
If we don't have to,
we just want to invalidate

00:40:39.230 --> 00:40:40.390
parts of the view.

00:40:41.590 --> 00:40:45.400
I noticed that we had some
utility functions as well,

00:40:45.400 --> 00:40:48.500
so I'm going to go add those right
now and explain what those do.

00:40:48.500 --> 00:40:53.210
So I add a new section to my code.

00:40:59.400 --> 00:41:01.210
and go ahead and add those.

00:41:01.220 --> 00:41:06.240
Hold on as I page up.

00:41:08.990 --> 00:41:11.000
So there's a utility
to get the part frame.

00:41:11.000 --> 00:41:12.960
This is just get the box
around one of those parts,

00:41:12.960 --> 00:41:15.060
like the back, or forward,
or delete parts.

00:41:15.060 --> 00:41:20.290
I've added a function to determine
whether one of those parts is available.

00:41:20.850 --> 00:41:23.130
There's three functions that
deal with the image cache,

00:41:23.140 --> 00:41:26.800
which aren't of importance in this
particular area that we're talking about,

00:41:26.850 --> 00:41:33.140
but we have an invalidate release and
converting the image into a bitmap image,

00:41:33.140 --> 00:41:34.870
but I won't go into that.

00:41:35.270 --> 00:41:41.270
There's a function here that returns the
part that corresponds to a mouse point.

00:41:42.100 --> 00:41:46.820
and then we have four functions to
deal with going to the previous,

00:41:46.830 --> 00:41:49.740
next, adding images, deleting images.

00:41:49.740 --> 00:41:52.780
These are just utilities that
our viewer will be using.

00:41:52.850 --> 00:41:54.040
The previous and next are very simple.

00:41:54.040 --> 00:41:58.750
They just decrement or increment the
index respectively and then invalidate

00:41:58.750 --> 00:42:01.320
by using the HIView set news display.

00:42:03.150 --> 00:42:06.000
So this is how we would deal
with input from the mouse.

00:42:06.030 --> 00:42:08.560
Now, as Bryan mentioned,
we also want to add

00:42:08.560 --> 00:42:10.390
support for keyboard input.

00:42:11.300 --> 00:42:13.300
So I go back to my registration API.

00:42:13.440 --> 00:42:17.310
Hope I'm not missing anything.

00:42:17.560 --> 00:42:21.740
and add support for the Text Input
class of events and register

00:42:21.740 --> 00:42:24.100
for the Unicode for key events.

00:42:24.150 --> 00:42:26.520
Back up in my Event Handler.

00:42:28.280 --> 00:42:31.490
will handle that event
by calling this function,

00:42:31.490 --> 00:42:33.380
which we'll define now.

00:42:39.210 --> 00:42:40.400
for me as I scroll up.

00:42:40.400 --> 00:42:44.550
So at this point,
we're just getting the Unicode

00:42:44.560 --> 00:42:47.620
character out of this text input event,
and we're dealing with that.

00:42:47.620 --> 00:42:50.870
So for example,
if one of the parts was focused and

00:42:50.870 --> 00:42:55.520
the user hits the keyboard character,
or the space bar,

00:42:55.520 --> 00:42:59.420
we wanna leverage all of the code
that we've already done for tracking,

00:42:59.420 --> 00:43:01.240
hit testing, et cetera.

00:43:01.570 --> 00:43:04.280
So we just use this API,
HIVU simulate click.

00:43:04.300 --> 00:43:07.110
This will just simulate a click,
and that will highlight the

00:43:07.120 --> 00:43:11.770
part that is to be clicked,
and then send out the hit event.

00:43:15.890 --> 00:43:17.460
So now we've added keyboard input.

00:43:17.460 --> 00:43:19.360
So we have mouse input
and keyboard input.

00:43:19.430 --> 00:43:21.910
Now, this is neat because we've
added these parts to navigate

00:43:21.910 --> 00:43:24.490
between different images,
but currently we only have one

00:43:24.490 --> 00:43:26.580
image that's stored in there,
and that was passed in by

00:43:26.590 --> 00:43:27.990
the initialization event.

00:43:28.040 --> 00:43:31.430
So let's go ahead and add an
API that's specific to our

00:43:31.450 --> 00:43:34.130
view to add additional images.

00:43:34.140 --> 00:43:38.190
Let's go to the header.

00:43:40.200 --> 00:43:47.160
In this little API section,
I'm adding an API to allow the client to

00:43:47.160 --> 00:43:51.100
add images and passes in the HIView ref,
which corresponds to our view,

00:43:51.100 --> 00:43:57.200
and an array of CFURLRefs,
which are paths to images on disk.

00:43:57.200 --> 00:43:58.910
Let's implement that function.

00:43:58.950 --> 00:44:01.380
Go back to the implementation file.

00:44:03.850 --> 00:44:07.350
Function pop-up,
I go down to my API section of the code,

00:44:07.350 --> 00:44:11.790
and add that API.

00:44:13.500 --> 00:44:16.840
Again, as I said, the client has an
HIView reference to you,

00:44:16.850 --> 00:44:20.920
but you deal with your image data,
or your image browser view data,

00:44:21.120 --> 00:44:22.190
instance data.

00:44:22.250 --> 00:44:25.000
So we need a way of getting
that data from an HIView ref,

00:44:25.030 --> 00:44:28.600
and you do that by using this API,
hiobjectdynamiccast.

00:44:28.650 --> 00:44:32.700
Passing in the HIView and
the class of that view.

00:44:32.730 --> 00:44:34.150
This will return your instance data.

00:44:34.190 --> 00:44:38.160
You can now deal with that as we've been
dealing with it in the other handlers.

00:44:38.170 --> 00:44:42.390
So in this case, we add the images to our
internal array and we invalidate.

00:44:45.290 --> 00:44:49.390
Let's add some support in the test
harness to make sure we can add

00:44:49.530 --> 00:44:52.200
additional images into that view.

00:44:52.230 --> 00:44:54.150
If I go back to main.

00:44:55.240 --> 00:44:58.620
If you recall,
initially we were creating the instance

00:44:58.620 --> 00:45:01.260
on our own by calling hObjectCreate
and getting a reference to our view.

00:45:01.360 --> 00:45:03.590
Well now we're using the
interface builder and we're

00:45:03.900 --> 00:45:07.800
having it load automatically
with the window as it's loaded.

00:45:07.880 --> 00:45:10.300
So we don't at this point
have a reference to that view.

00:45:10.410 --> 00:45:13.800
So I need to make sure I add
support to do that as well.

00:45:13.800 --> 00:45:17.300
So back here I will add a Control ID.

00:45:17.860 --> 00:45:23.460
and or an HIView ID, their equivalent,
which is a signature and an

00:45:23.460 --> 00:45:26.870
ID that allows you to uniquely
identify a view in a window.

00:45:26.890 --> 00:45:30.720
So let's make sure that that
is added in our nib as well.

00:45:31.100 --> 00:45:34.320
So I go back to Interface Builder,
select my view,

00:45:34.320 --> 00:45:38.160
and in the Control pane of this window,
you can see that there are

00:45:38.160 --> 00:45:39.740
fields for Signature and ID.

00:45:39.740 --> 00:45:43.220
This is, we have to make sure
that these are in sync.

00:45:43.220 --> 00:45:45.560
I am BR, I am BR.

00:45:47.330 --> 00:45:49.450
Make sure I saved it.

00:45:49.470 --> 00:45:52.610
Now in our creation function,

00:45:53.140 --> 00:45:56.920
I will add some support to get
the image browser reference,

00:45:56.920 --> 00:46:01.020
and then some fields
here for some images.

00:46:01.100 --> 00:46:11.270
After the window's loaded,
I add some code to create an array.

00:46:17.900 --> 00:46:22.100
Stuff those URLs into that array.

00:46:22.140 --> 00:46:25.500
Get a reference to our view
using the HIView find by ID API,

00:46:25.520 --> 00:46:28.640
passing in that control ID that
we specified above so we

00:46:28.640 --> 00:46:30.500
get a reference to our view.

00:46:31.110 --> 00:46:33.600
And then we add the images
to the view by calling the

00:46:33.740 --> 00:46:36.680
ImageBrowserViewAddImages API,
which we defined.

00:46:36.680 --> 00:46:42.070
Lastly, of course,
release that array so we don't leak.

00:46:43.960 --> 00:46:45.950
So now,
as I'll show you in just a moment,

00:46:45.950 --> 00:46:49.500
we do deal with mouse input,
keyboard input, and the last step is to

00:46:49.500 --> 00:46:51.320
add Accessibility support.

00:46:51.800 --> 00:46:56.130
I'm not really going to go into the
specifics of adding Accessibility

00:46:56.140 --> 00:47:01.040
because there's this great Accessibility
lab you can attend which is 1024

00:47:01.040 --> 00:47:02.700
and that's going to be on Friday.

00:47:02.890 --> 00:47:05.390
But just for completeness,
I will add support for

00:47:05.390 --> 00:47:06.990
that in the review as well.

00:47:10.810 --> 00:47:14.320
I add support for the
Accessibility Suite of events.

00:47:14.320 --> 00:47:17.930
Back up in our handler.

00:47:18.120 --> 00:47:21.800
I handle those events.

00:47:24.100 --> 00:47:30.140
and I create a new section in my code
to deal with creating and dealing

00:47:30.140 --> 00:47:32.670
with that accessibility hierarchy.

00:47:37.120 --> 00:47:38.900
Let's go ahead and build and run this.

00:47:38.900 --> 00:47:43.710
Now you can see that we've added
some of these additional features.

00:47:43.760 --> 00:47:47.200
These new parts show
up in the draw handler.

00:47:47.200 --> 00:47:52.070
It handles hit testing and tracking.

00:47:53.480 --> 00:47:56.740
Handles Mouse Input,
because now I can navigate between

00:47:56.740 --> 00:48:00.200
the various images that were
added by that API we specified.

00:48:00.290 --> 00:48:03.140
And we also handle Keyboard Input.

00:48:03.150 --> 00:48:06.620
If I focus the view,
you can see that there's this

00:48:06.780 --> 00:48:08.460
focus border drawn around the view.

00:48:08.500 --> 00:48:11.440
And as long as full
keyboard access is enabled,

00:48:11.460 --> 00:48:15.040
I can bore down into the
various parts and use the

00:48:15.040 --> 00:48:17.010
keyboard to interact with that.

00:48:17.700 --> 00:48:20.470
Since we've also added
Accessibility Support,

00:48:20.470 --> 00:48:24.550
a non-sighted user or an Accessibility
application such as VoiceOver can

00:48:24.560 --> 00:48:26.500
interact with your view as well.

00:48:26.580 --> 00:48:28.920
So now at this point,
we do have a pretty full featured

00:48:28.920 --> 00:48:31.600
view and there's just some advanced
features that we can go through.

00:48:31.600 --> 00:48:35.400
So I'd like to take it back
to Bryan to go through that.

00:48:36.170 --> 00:48:37.240
Back to the slide.

00:48:38.580 --> 00:48:41.320
All right,
Curt has shown us a great demo,

00:48:41.320 --> 00:48:44.460
and we've had a lot of features.

00:48:44.460 --> 00:48:47.930
For many of your views,
maybe subclassing, drawing,

00:48:48.010 --> 00:48:51.610
and basic user interaction
is all you need.

00:48:52.160 --> 00:48:55.870
But I'd like to go one step further
and show you a couple other advanced

00:48:55.880 --> 00:48:58.100
features that you may want to add.

00:48:58.230 --> 00:49:00.480
First of which is Drag-and-Drop.

00:49:02.630 --> 00:49:06.900
To enable Drag-and-Drop in your view,
you need to do two things.

00:49:06.900 --> 00:49:09.740
Your client, the client of your view,
needs to call

00:49:09.740 --> 00:49:13.060
SetAutomaticControlDragTrackingEnabledFor
Window.

00:49:13.110 --> 00:49:17.520
Now, the reason this is,
we need to make sure that the toolbox

00:49:17.630 --> 00:49:21.600
has drag tracking event handlers,
drag tracking handlers

00:49:21.640 --> 00:49:23.200
installed on your window.

00:49:23.350 --> 00:49:26.060
Now, the reason we can't do this
automatically is because we don't

00:49:26.060 --> 00:49:28.900
want to interfere with any drag
tracking you may already have.

00:49:28.900 --> 00:49:31.650
So we need you to adopt this explicitly.

00:49:32.280 --> 00:49:35.790
And once that's set,
you'll call Set Control Drag Tracking

00:49:35.790 --> 00:49:38.520
Enabled on your view
during its initialization.

00:49:38.580 --> 00:49:41.570
And this tells the toolbox
you handle the drag protocol,

00:49:41.570 --> 00:49:44.560
and it should send you these events.

00:49:44.710 --> 00:49:47.020
Now the drag protocol
consists of four events:

00:49:47.090 --> 00:49:50.550
Drag Enter, Within, Leave, and Receive.

00:49:50.610 --> 00:49:55.490
Now these mirror very closely the
existing drag manager messages.

00:49:56.430 --> 00:50:00.540
Each one of these will pass you
a drag graph as a parameter.

00:50:00.540 --> 00:50:04.150
You can go ahead and interrogate
that drag reference with the existing

00:50:04.150 --> 00:50:07.490
Drag Manager and Pasteboard Manager APIs.

00:50:07.800 --> 00:50:12.120
The event I want to focus on
here is the Drag-Enter Event.

00:50:12.120 --> 00:50:18.510
This is what you'll receive when the
user first drags a drag over your view.

00:50:18.970 --> 00:50:22.080
At this point, you'll get the message,
you'll look at the drag ref,

00:50:22.250 --> 00:50:27.290
decide whether you like this drag or not,
whether your view can accept it.

00:50:27.350 --> 00:50:30.590
And you'll fill out the
KEVENT_PARAM_CTRL_WOULD_ACCEPT_DROP

00:50:30.650 --> 00:50:31.850
parameter.

00:50:31.910 --> 00:50:36.480
Now, this is very important because
if you fill this out with false,

00:50:36.630 --> 00:50:40.910
or let me say this another way,
you must fill it out with true

00:50:41.320 --> 00:50:44.890
and return no error from your
event handler to guarantee that

00:50:44.890 --> 00:50:46.800
you will receive more events.

00:50:47.100 --> 00:50:50.140
As a tip, if you're having trouble
getting Drag-and-Drop to work,

00:50:50.280 --> 00:50:53.430
make sure that you're handling
this parameter properly.

00:50:53.610 --> 00:50:56.830
Now, if your view doesn't
want to handle the drag,

00:50:56.870 --> 00:51:00.370
you can just pass a false back
and you won't get any more events.

00:51:00.370 --> 00:51:02.330
You don't need to worry about the drag.

00:51:03.490 --> 00:51:09.470
The second feature is HIV Archive,
which is a new feature for Tiger.

00:51:10.150 --> 00:51:14.070
Archiving consists of the ability
to take your live objects in memory,

00:51:14.070 --> 00:51:18.840
so whether your HI objects or multiple
core foundation property list types,

00:51:18.840 --> 00:51:22.250
get the persistent
information for those objects,

00:51:22.250 --> 00:51:26.290
write that out to a binary archive
that's provided to you in a CFData.

00:51:26.440 --> 00:51:29.600
You can write that out to disk or send it
across the wire to another application.

00:51:29.600 --> 00:51:31.300
It doesn't matter.

00:51:31.380 --> 00:51:32.710
It's just a CFData.

00:51:33.410 --> 00:51:36.180
And then later on,
you can request that all those objects

00:51:36.310 --> 00:51:40.090
be pulled back out of the archive
and reinstantiated to the state that

00:51:40.090 --> 00:51:42.320
they had when they were written out.

00:51:42.900 --> 00:51:46.590
To support archiving in an
HI object or your HIV specifically,

00:51:46.590 --> 00:51:48.690
you need to handle the
archiving protocol.

00:51:48.770 --> 00:51:53.400
This consists of the HI object encode
and HI object initialize events.

00:51:53.560 --> 00:51:57.110
Each of these events is passed
an HI archive ref as a parameter,

00:51:57.420 --> 00:52:01.700
which you will use to write your
persistent state into or read it out of.

00:52:01.820 --> 00:52:04.820
So in the case where a client
has requested you encode all your

00:52:04.820 --> 00:52:10.180
information into an archive for storage,
use the HI archive encode CF type

00:52:10.260 --> 00:52:12.800
API to write out your persistent state.

00:52:12.890 --> 00:52:14.850
And you'll write it out by key.

00:52:15.020 --> 00:52:16.600
The key is a CFString.

00:52:16.680 --> 00:52:21.600
This is very similar to the key
value scheme used in dictionaries,

00:52:21.600 --> 00:52:23.490
so it should be fairly familiar.

00:52:23.540 --> 00:52:26.500
Now you want these keys to be
unique so that you can pull the

00:52:26.500 --> 00:52:30.600
information back out by key later on
when you're asked to re-instantiate.

00:52:31.350 --> 00:52:36.540
There are Boolean and Number Convenience
Wrappers for ENCODE CF type.

00:52:37.300 --> 00:52:40.920
Now, what you want to do is make sure
that you call your superclass,

00:52:40.970 --> 00:52:43.860
so call the next event handler,
so it can write out its attributes.

00:52:43.950 --> 00:52:45.880
In the case of a view,
you may write out your

00:52:45.880 --> 00:52:49.120
specific information,
but the HIView-based class will

00:52:49.120 --> 00:52:53.130
write out things like the title
and position and size of your view,

00:52:53.130 --> 00:52:56.200
so you don't need to
worry about those pieces.

00:52:56.690 --> 00:52:58.590
Later on,
your client will request that you

00:52:58.600 --> 00:53:03.170
decode yourselves from the archive and
reinstantiate to your existing state.

00:53:03.200 --> 00:53:06.090
In this case, you'll be past the
HIObjectInitialize event.

00:53:06.180 --> 00:53:08.700
This is an event that you
may already be handling.

00:53:08.700 --> 00:53:12.700
When somebody calls
HIObjectCreate with your class ID,

00:53:12.700 --> 00:53:18.320
this message is sent to you,
and you'll initialize your

00:53:18.320 --> 00:53:20.530
view to a default state.

00:53:21.020 --> 00:53:24.010
In the case where the
HIarchiveRef parameter is present,

00:53:24.010 --> 00:53:27.180
you want to make sure to pull out all
your information from the archive.

00:53:29.200 --> 00:53:33.800
You can do this again by calling
hi-archive-copy-decoded-cftype.

00:53:33.830 --> 00:53:37.560
And again, there are Boolean and number
wrappers for this API.

00:53:37.660 --> 00:53:42.800
So you pull out all of your state
and then call the next event

00:53:42.800 --> 00:53:47.460
handler to allow your superclass
to pull its information out.

00:53:48.920 --> 00:53:50.740
Once you handle the protocol,
make sure to call

00:53:50.740 --> 00:53:57.800
hiObject.setArchivingIgnored
with false during initialization.

00:53:57.940 --> 00:54:00.800
This will tell the toolbox that yes,
you handled the archiving protocol

00:54:00.800 --> 00:54:03.190
and you should receive these events.

00:54:03.390 --> 00:54:04.800
So to recap quickly,
I'll just show you here.

00:54:04.800 --> 00:54:12.260
You can take your existing view,
identify its persistent state,

00:54:12.290 --> 00:54:14.880
write those into the archive by key,

00:54:15.470 --> 00:54:18.360
and once the client has the archive,
they can do whatever they want with it.

00:54:18.450 --> 00:54:21.470
Later on,
they'll pull your information back out

00:54:21.930 --> 00:54:26.060
You'll request it by key again
and reinstantiate your object with

00:54:26.060 --> 00:54:29.570
the state that it had previously.

00:54:31.810 --> 00:54:33.680
With that,
I'd like to pass it back to Curt to

00:54:33.700 --> 00:54:36.240
show you those two features in the demo.

00:54:36.240 --> 00:54:39.900
So these are the last features
that we'll be implementing for

00:54:39.950 --> 00:54:41.420
this view during this session.

00:54:41.420 --> 00:54:43.730
So let's get started on that.

00:54:43.760 --> 00:54:47.190
Now, as Bryan mentioned,
in order to handle Drag-and-Drop,

00:54:47.220 --> 00:54:52.640
the client needs to make sure that
dragging is enabled for that window.

00:54:52.640 --> 00:54:54.940
Now, the code that's available
to you actually has the view

00:54:54.940 --> 00:54:57.240
turning this on for the window,
and that's incorrect.

00:54:58.260 --> 00:55:00.080
Yeah,
the window does not belong to the view.

00:55:00.080 --> 00:55:01.640
It belongs to the client application.

00:55:01.640 --> 00:55:04.060
So we've updated the sample code,
and we'll make that available

00:55:04.060 --> 00:55:05.290
to you after the conference.

00:55:05.300 --> 00:55:08.000
But I'll do it correct here.

00:55:09.660 --> 00:55:14.710
So back in our main file,
after the window is created,

00:55:16.410 --> 00:55:21.860
We enabled drag tracking
for that window there.

00:55:23.820 --> 00:55:27.490
Similar to drawing a focus
around the different parts,

00:55:27.490 --> 00:55:31.620
we need to be able to provide user
feedback to the user while they're

00:55:31.620 --> 00:55:34.190
dragging items over your view.

00:55:34.240 --> 00:55:37.760
So again, since we're only drawing
during our draw function,

00:55:37.760 --> 00:55:40.580
we need to maintain some state
associated with whether we're

00:55:40.620 --> 00:55:42.580
tracking or not currently.

00:55:42.630 --> 00:55:47.120
So let's go ahead and add some
data to our data structure.

00:55:55.150 --> 00:55:55.840
Bad Monkey.

00:55:55.840 --> 00:56:04.940
Since we've now added another
field to our data structure,

00:56:04.940 --> 00:56:07.460
we need to make sure we
initialize that correctly.

00:56:07.460 --> 00:56:10.030
So back in my initialize function.

00:56:14.900 --> 00:56:23.900
[Transcript missing]

00:56:33.150 --> 00:56:36.230
Next,
we want to deal with drawing differently

00:56:36.240 --> 00:56:37.370
whether we are currently tracking.

00:56:37.380 --> 00:56:38.860
We added this field
to our data structure.

00:56:38.860 --> 00:56:43.340
Now, if we are currently tracking a drag,
we want to make sure that we draw

00:56:43.340 --> 00:56:46.960
this highlight around the whole image
to provide feedback to the user.

00:56:47.030 --> 00:56:49.860
So I'll modify the draw function.

00:56:49.910 --> 00:56:51.560
Forgive me for all the page downing.

00:56:51.560 --> 00:56:57.640
And I add a section here which
will draw this highlight if

00:56:57.680 --> 00:56:58.940
we're currently tracking.

00:57:02.740 --> 00:57:06.560
So let's go ahead and
implement support for that now.

00:57:10.010 --> 00:57:12.950
We'll work in our main event type block.

00:57:12.960 --> 00:57:21.260
We add support for, as Ryan mentioned,
there's four drag events in the suite,

00:57:21.290 --> 00:57:24.500
but we're only gonna handle the Enter,
Leave, and Receive event.

00:57:24.500 --> 00:57:27.460
Then back up in our event handler.

00:57:27.460 --> 00:57:32.400
We'll handle those events.

00:57:32.400 --> 00:57:39.690
And then implement the
functions to deal with that.

00:57:43.900 --> 00:57:45.300
That's why it's not showing up.

00:57:45.300 --> 00:57:54.470
So the first function we implement
is the Drag-Enter Event Handler.

00:57:54.500 --> 00:57:58.060
What this does is it gets the
pasteboard associated with the drag,

00:57:58.060 --> 00:58:00.660
determines if there are
any URLs on that drag,

00:58:00.680 --> 00:58:04.640
and if so,
adds the Would Accept Drop to the event.

00:58:04.670 --> 00:58:09.370
So the event system will then send
subsequent drag events to that control.

00:58:09.630 --> 00:58:13.530
If it would accept,
we enable our flag and we invalidate.

00:58:13.580 --> 00:58:15.360
This is so the next time
through the draw loop,

00:58:15.400 --> 00:58:18.620
we'll make sure to draw that
highlight around the image.

00:58:20.000 --> 00:58:23.720
Next,
we implement the Drag-Leave function.

00:58:23.780 --> 00:58:27.370
Again, we just toggle the flag,
whether we're tracking or not,

00:58:27.410 --> 00:58:28.410
and invalidate.

00:58:28.440 --> 00:58:30.900
This is so the highlight will go away.

00:58:31.570 --> 00:58:36.460
And finally,
we implement the Receive Event Handler.

00:58:36.510 --> 00:58:41.700
This will pull out the Pasteboard
from the drag and then iterate

00:58:41.700 --> 00:58:45.820
through that Pasteboard,
pulling out the image URLs and add

00:58:45.820 --> 00:58:48.580
that to our internal data structure.

00:58:50.230 --> 00:58:52.490
I'm also using some
additional utility functions,

00:58:52.520 --> 00:58:54.070
which I haven't implemented just yet.

00:58:54.160 --> 00:58:58.770
So I'm gonna go back up to the
utility section of my code.

00:59:06.900 --> 00:59:09.900
and I'll be working on the next step,
which is to add the utilities.

00:59:09.900 --> 00:59:12.890
The utilities that I've added are,
as I mentioned before,

00:59:12.980 --> 00:59:19.370
to determine whether there is
a URL on the drag-paste board.

00:59:21.260 --> 00:59:24.740
I added a function to grab the
Pasteboard from the Drag Event.

00:59:24.790 --> 00:59:28.260
And then also, or actually the first
function I showed you,

00:59:28.260 --> 00:59:31.040
it was actually to iterate the
Pasteboard and pull out the URLs.

00:59:31.180 --> 00:59:34.410
This is the function that determines
whether there is a URL on that Drag.

00:59:34.420 --> 00:59:37.570
So let's go ahead and build.

00:59:37.600 --> 00:59:40.200
Run.

00:59:43.320 --> 00:59:46.700
Now you can see that it just
looks like it did before,

00:59:46.700 --> 00:59:50.490
but now it supports drag-and-drop.

00:59:51.140 --> 00:59:54.880
So if I take a bunch of images
and I drag it over our view,

00:59:54.880 --> 00:59:56.690
we will get a Drag-Enter event.

00:59:56.750 --> 00:59:59.300
We set that we are currently
tracking and invalidate.

00:59:59.300 --> 01:00:02.260
So the next time through the loop,
we draw this highlight around the view.

01:00:02.290 --> 01:00:04.920
And likewise,
when we drag out of the view,

01:00:04.960 --> 01:00:07.220
we don't draw that highlight anymore.

01:00:07.260 --> 01:00:10.550
And if I drop those images on,
we get the Receive event,

01:00:10.680 --> 01:00:14.120
pull those URLs off of the drag,
add it to our internal data structure,

01:00:14.120 --> 01:00:16.250
and we're good to go.

01:00:22.200 --> 01:00:25.990
The last feature that
we'll add is HI Archiving.

01:00:26.030 --> 01:00:28.660
Now, as Bryan mentioned,
this requires a key.

01:00:28.660 --> 01:00:31.410
So what you need to do prior
to implementing this is figure

01:00:31.410 --> 01:00:34.410
out what is the persistent
state that I'm interested in.

01:00:34.520 --> 01:00:37.220
In our case,
we have an array and an index

01:00:37.320 --> 01:00:38.840
that we really care about.

01:00:38.840 --> 01:00:42.770
And what we'll do is we'll
define some keys for that.

01:00:45.570 --> 01:00:50.370
- In my constants area,
I define these new keys.

01:00:50.370 --> 01:00:57.290
One, it corresponds to the array,
which is the URLs archive, or the URLs,

01:00:57.300 --> 01:01:02.710
and the other corresponds to the index,
which is the image index constant.

01:01:05.140 --> 01:01:09.580
As Bryan mentioned,
if we need to notify the system that

01:01:09.580 --> 01:01:16.740
we handled the archiving protocol,
we need to call during initialization,

01:01:22.540 --> 01:01:27.040
The HIObjectSetArchivingIgnored
function passing the false.

01:01:27.040 --> 01:01:31.270
This says we do understand the archiving
protocol and we are interested in

01:01:31.270 --> 01:01:33.250
receiving these types of events.

01:01:33.880 --> 01:01:39.300
Next, we add support for archiving by
going down to our main array.

01:01:42.700 --> 01:01:45.820
and adding an Event Type for
the Encode Event.

01:01:45.820 --> 01:01:47.880
Go back up to my Event Handler.

01:01:47.880 --> 01:01:51.910
This is the second one of my
three main steps for doing this.

01:01:52.800 --> 01:01:57.700
In the HIObject class handler,
I add a handler for the encode event.

01:01:57.850 --> 01:02:05.110
And then we implement the function
that deals with that encoding.

01:02:08.080 --> 01:02:10.430
So as Bryan mentioned,
since we are subclassing the view,

01:02:10.430 --> 01:02:13.080
we want to make sure that the
superclass has an opportunity to

01:02:13.080 --> 01:02:17.400
encode itself because it knows
things such as the view's position,

01:02:17.460 --> 01:02:20.140
its size, its title, etc.

01:02:20.220 --> 01:02:24.220
Next, we pull out the hi-archive
event parameter,

01:02:24.220 --> 01:02:27.750
which is this encoder,
and then we encode our persistent

01:02:27.750 --> 01:02:29.920
state using those keys that we defined.

01:02:29.920 --> 01:02:30.950
So it's very simple.

01:02:30.960 --> 01:02:34.360
We just store out our internal
state as these CF types,

01:02:34.360 --> 01:02:35.830
and we're good to go.

01:02:36.400 --> 01:02:40.300
There's no corresponding Decode Event,
as Bryan mentioned, because normally,

01:02:40.300 --> 01:02:43.350
well, always when you're decoding,
you'll be doing this during

01:02:43.350 --> 01:02:46.740
initialization because you're
creating from an archive.

01:02:46.820 --> 01:02:51.970
So we handle this in
the Initialize Event.

01:02:53.500 --> 01:02:58.610
I had another variable for a decoder.

01:02:59.400 --> 01:03:02.140
And then towards the beginning,
before I start extracting

01:03:02.190 --> 01:03:06.190
event parameters,
I just check to see if there

01:03:06.190 --> 01:03:08.630
is a decoder available.

01:03:08.860 --> 01:03:16.550
If the decoder exists,
then we unarchive from that.

01:03:20.940 --> 01:03:26.480
and that means that we're being
requested to instantiate from an archive.

01:03:26.490 --> 01:03:30.650
If the decoder is not present,
we go about and do our normal

01:03:30.920 --> 01:03:33.370
initialization processing.

01:03:38.350 --> 01:03:39.500
And now we're good to go.

01:03:39.500 --> 01:03:44.500
So I haven't implemented this in the test
harness for the purposes of this demo,

01:03:44.500 --> 01:03:47.920
since we're running out of time,
but you can see in the sample code

01:03:47.920 --> 01:03:51.660
that's provided to you how there
is the ability to actually archive

01:03:51.660 --> 01:03:55.660
out the window and its contents
and then unarchive that as well.

01:03:55.660 --> 01:03:56.860
So, Bryan.

01:03:56.860 --> 01:03:57.700
- Great.

01:03:57.710 --> 01:03:58.460
Thank you, Curt.

01:03:58.460 --> 01:04:00.290
Back to slides.

01:04:00.500 --> 01:04:06.650
Slides, please.

01:04:10.710 --> 01:04:11.540
Thank you.

01:04:11.540 --> 01:04:12.910
All right.

01:04:13.000 --> 01:04:15.400
As Curt, I'm sorry.

01:04:15.420 --> 01:04:18.200
What we've given you today is a lot
of information about how to create

01:04:18.200 --> 01:04:20.440
a custom HIView from the ground up.

01:04:20.440 --> 01:04:23.230
And I want to talk about
one more thing that might be

01:04:23.250 --> 01:04:25.990
helpful in your use of HIView.

01:04:28.300 --> 01:04:29.260
That's HIFramework.

01:04:29.480 --> 01:04:31.800
HIFramework is some sample
code that we provide,

01:04:31.800 --> 01:04:35.290
which is a series of C++ wrappers
around HIToolbox functionality,

01:04:35.370 --> 01:04:38.850
specifically HIObject
and HIView subclassing.

01:04:39.280 --> 01:04:42.620
So this is a very simple thin wrapper.

01:04:42.620 --> 01:04:45.260
And so it should be very familiar to
you if you're familiar with these APIs.

01:04:45.300 --> 01:04:49.600
But you may be more familiar with C++ and
want to use its subclassing mechanism.

01:04:49.730 --> 01:04:54.130
And so it'll be much more C++ friendly.

01:04:54.400 --> 01:04:57.180
We're going to give you
today HIV framework 1.1,

01:04:57.180 --> 01:04:59.030
which is a new version,
and I want to talk about

01:04:59.050 --> 01:05:00.400
some of the differences.

01:05:00.440 --> 01:05:02.620
In the original HIV framework,
we just had a single Tview

01:05:02.760 --> 01:05:04.400
for view subclassing.

01:05:04.400 --> 01:05:07.390
We've added a little bit to the
inheritance hierarchy there,

01:05:07.430 --> 01:05:10.400
a TEventHandler and a TObjectSuperclass.

01:05:10.400 --> 01:05:12.920
And we specifically wanted
to add TObjectSuperclass

01:05:12.990 --> 01:05:15.400
to support accessibility,
because accessibility support

01:05:15.400 --> 01:05:19.430
can be added to any HIVobject,
Windows and menus included,

01:05:19.430 --> 01:05:20.700
not just views.

01:05:21.680 --> 01:05:24.560
Now again,
this is available with a sample code,

01:05:24.560 --> 01:05:27.820
and there's a second target in the
project which will allow you to

01:05:27.820 --> 01:05:29.800
build using the HIFramework version.

01:05:29.840 --> 01:05:35.040
We've created a second copy of
the HIView implementation that

01:05:35.040 --> 01:05:39.680
performs all the same features,
but using the HIFramework sample

01:05:39.680 --> 01:05:43.550
code rather than the strict C API.

01:05:44.350 --> 01:05:46.280
I've given you a lot
of information today.

01:05:46.330 --> 01:05:50.100
What can you do with
this information now?

01:05:50.180 --> 01:05:52.160
So we'd like you to go home,
or I'm sorry, not home,

01:05:52.310 --> 01:05:56.980
go back to your hotel room tonight and
just play around with the sample code.

01:05:56.980 --> 01:05:57.740
Experiment with it.

01:05:57.740 --> 01:06:00.200
Try implementing some new features.

01:06:00.200 --> 01:06:03.490
We didn't do very much in
the custom tracking event,

01:06:03.490 --> 01:06:06.870
so maybe try dragging --
using that to create a drag,

01:06:06.890 --> 01:06:11.190
track drag, and pull the image out and
drag it up to the desktop,

01:06:11.190 --> 01:06:12.590
something like that.

01:06:12.650 --> 01:06:14.260
Or implement a new part.

01:06:14.270 --> 01:06:19.300
Perhaps a part that will allow you
to do a view for all the images.

01:06:19.300 --> 01:06:19.300
Say, you've got a new image.

01:06:22.920 --> 01:06:27.190
will be here to go through and do
a slide show for all your images,

01:06:27.200 --> 01:06:28.620
something like that.

01:06:28.620 --> 01:06:30.800
Once you're familiar with
the HIView sample code,

01:06:30.920 --> 01:06:34.280
go ahead and look at your own
code and try to convert some of

01:06:34.280 --> 01:06:36.960
your existing C-DEFs to HIViews.

01:06:36.960 --> 01:06:43.080
This will allow you to support
compositing in your Windows,

01:06:43.080 --> 01:06:43.080
which is the first step towards
resolution independence.

01:06:45.910 --> 01:06:48.700
So if you have some feedback on the
things that you've learned today,

01:06:48.790 --> 01:06:51.870
features that you'd like to see,
go ahead and contact us at

01:06:51.910 --> 01:06:56.070
hitoolbox-feedback@group.apple.com.

01:06:56.600 --> 01:06:59.140
And for more information,
you can go to the

01:06:59.140 --> 01:07:02.900
ADCdeveloperApple.com website.

01:07:02.900 --> 01:07:07.380
And for this session specifically,
you can see sample code that

01:07:07.380 --> 01:07:11.800
we've been demonstrating today
and references to documentation.

01:07:11.840 --> 01:07:15.200
And as always,
you can go to the header documentation

01:07:15.280 --> 01:07:18.390
for each one of the HIToolbox's managers.

01:07:18.460 --> 01:07:22.360
So we do put in a lot of effort
to give you a good overview at the

01:07:22.410 --> 01:07:27.340
top of the header file and document
each one of our APIs as we add them.

01:07:29.980 --> 01:07:33.090
So for the rest of the roadmap,
there's the Carbon and HI Toolbox

01:07:33.090 --> 01:07:35.820
Feedback Forum on Thursday.

01:07:35.880 --> 01:07:39.340
And there's a lab going on all week,
so bring in your HIViews and talk to

01:07:39.340 --> 01:07:44.940
the toolbox engineers and developer
technical support folk to get some help.

01:07:45.000 --> 01:07:47.480
And I also mentioned earlier that
there's an Accessibility Lab on

01:07:47.480 --> 01:07:50.030
Friday for your accessibility questions.
WEBVTT

00:00:06.230 --> 00:00:07.380
Hello, everyone.

00:00:07.490 --> 00:00:10.000
Welcome back after lunch.

00:00:10.070 --> 00:00:11.340
My name is Matthew Formica.

00:00:11.340 --> 00:00:13.810
I'm the Cocoa and
Developer Tools Evangelist

00:00:14.020 --> 00:00:17.290
here at Apple Computer,
and welcome to Cocoa Today.

00:00:18.500 --> 00:00:21.750
So people stopped me in the halls
earlier today and were asking me,

00:00:21.840 --> 00:00:23.120
so what's Cocoa Today about?

00:00:23.370 --> 00:00:26.270
And I said, well, it's about Cocoa Today.

00:00:26.390 --> 00:00:27.780
And they didn't think
that was very helpful,

00:00:27.890 --> 00:00:30.110
so I'm going to try and explain
it in a little more depth here.

00:00:30.110 --> 00:00:33.140
Cocoa, as you know,
is Apple's rapid application

00:00:33.140 --> 00:00:34.760
development framework.

00:00:34.760 --> 00:00:38.940
It's really the fastest way to
develop new applications on Mac OS X.

00:00:41.490 --> 00:00:45.330
And as for today, well,
where do we stand today with Cocoa?

00:00:45.430 --> 00:00:50.360
We have a rapidly growing
developer community around Cocoa.

00:00:50.360 --> 00:00:53.720
If you are a member of the
Cocoa developers mailing list,

00:00:53.820 --> 00:00:55.840
you know how many
people are on that list,

00:00:55.840 --> 00:00:58.900
and how you can get just about
any obscure question answered,

00:00:59.030 --> 00:01:00.860
or at least someone
will try to answer it,

00:01:01.000 --> 00:01:01.700
on that list.

00:01:02.540 --> 00:01:06.940
One of the reasons why the developer
community continues to grow is

00:01:07.260 --> 00:01:10.500
because of all the great new APIs we
continue to add to Cocoa with

00:01:10.500 --> 00:01:13.030
each new version of Mac OS X,
including Tiger.

00:01:13.040 --> 00:01:16.400
Things like bindings and core data.

00:01:17.420 --> 00:01:21.680
But with all the focus on Tiger,
it may be actually easy to miss

00:01:21.770 --> 00:01:25.510
some of the broader themes in Cocoa,
some of the things we've been

00:01:25.620 --> 00:01:29.180
working on across several
OS versions of Mac OS X that are

00:01:29.290 --> 00:01:30.910
just now really coming to fruition.

00:01:31.660 --> 00:01:36.670
So what we wanted to do in this session
is explain not only some of the high

00:01:36.670 --> 00:01:41.810
points of Tiger with regards to Cocoa,
but also what are some of the design

00:01:41.810 --> 00:01:45.440
decisions that you should be aware of,
some of the overarching themes

00:01:45.440 --> 00:01:48.610
that you should be implementing
in your applications when

00:01:49.010 --> 00:01:52.640
thinking beyond just Tiger,
but to Mac OS X and Cocoa as a whole.

00:01:54.130 --> 00:01:58.560
Now, in part because of some of
the great new APIs that we've

00:01:58.700 --> 00:02:02.800
got in recent OS versions,
a lot of developers are moving to Cocoa,

00:02:02.800 --> 00:02:07.220
and they've been giving us great
feedback about a lot of the features,

00:02:07.220 --> 00:02:08.920
in particular bindings and core data.

00:02:08.920 --> 00:02:12.240
So I just wanted to share a little
bit of that feedback with you.

00:02:12.240 --> 00:02:15.510
Will Shipley,
co-founder of Delicious Monster,

00:02:15.510 --> 00:02:18.540
had this to say when
talking about bindings.

00:02:19.640 --> 00:02:21.870
Now, in part because of some of
the great new APIs that we've

00:02:21.870 --> 00:02:24.450
got in recent OS versions,
a lot of developers are moving to Cocoa.

00:02:24.450 --> 00:02:26.850
So I just wanted to share a little
bit of that feedback with you.

00:02:26.850 --> 00:02:28.780
Will Shipley,
co-founder of Delicious Monster,

00:02:28.890 --> 00:02:30.860
had this to say when
talking about bindings.

00:02:31.770 --> 00:02:35.440
So a lot of code gets to be
thrown away with Cocoa because the

00:02:35.440 --> 00:02:38.020
frameworks are doing more for you.

00:02:38.070 --> 00:02:40.340
He also had this to say,
"Without Cocoa bindings,

00:02:40.370 --> 00:02:42.430
it would have taken another
four or five months,

00:02:42.600 --> 00:02:46.090
maybe more, to finish Delicious Library."

00:02:46.990 --> 00:02:50.510
Another developer also
gave me some good feedback.

00:02:50.840 --> 00:02:53.260
Jerry Halls from Kronos,
maker of Sticky Brain,

00:02:53.260 --> 00:02:57.220
a productivity app, said, "With Cocoa,
we were able to accomplish a lot more,

00:02:57.280 --> 00:02:59.970
more quickly," pointing to
the fact that with Cocoa,

00:02:59.970 --> 00:03:05.470
because you get so much
functionality by default,

00:03:05.470 --> 00:03:09.420
you can spend your time on the value add,
the part of your application

00:03:09.420 --> 00:03:09.420
that's really unique.

00:03:10.820 --> 00:03:13.880
For those of you sitting on the fence,
he had this to add: "Be bold.

00:03:13.940 --> 00:03:19.210
Take the leap." And one of my
favorite quotes is actually from a

00:03:19.330 --> 00:03:23.330
blog out there from a Cocoa developer
who sat down with Core Data and

00:03:23.340 --> 00:03:25.340
was just completely enthralled.

00:03:25.470 --> 00:03:29.190
He said, "I want to marry Core Data and
have its children."

00:03:30.340 --> 00:03:34.060
So,
people are very enthusiastic about Cocoa.

00:03:34.130 --> 00:03:38.190
Hopefully you will be at least this
enthusiastic by the end of this session.

00:03:39.610 --> 00:03:41.640
So what else are we going
to talk about today?

00:03:41.860 --> 00:03:44.860
We're going to talk about some
of the broad scope of Cocoa,

00:03:44.860 --> 00:03:47.940
as I've mentioned, some of the recent
changes and directions,

00:03:48.100 --> 00:03:50.460
things you should be
aware of going forwards.

00:03:50.460 --> 00:03:53.890
And we're going to also have
a testimonial from a developer

00:03:54.000 --> 00:03:58.070
who has done the process of
converting a non-Cocoa app to Cocoa.

00:03:58.240 --> 00:04:02.210
So with that,
I'd like to turn things over to Ali Ozer.

00:04:09.800 --> 00:04:13.560
Good afternoon.

00:04:13.560 --> 00:04:17.880
I'm Ali Ozer,
manager of the Cocoa frameworks.

00:04:17.880 --> 00:04:20.290
Before we talk about the
recent changes and directions,

00:04:20.290 --> 00:04:22.370
which is the main bulk
of this talk today,

00:04:22.490 --> 00:04:26.040
I want to cover the design
architecture and tools.

00:04:26.040 --> 00:04:29.250
Basically, what is Cocoa,
and what's its philosophy, and so on.

00:04:29.270 --> 00:04:31.910
To talk about Cocoa,
it's really interesting to

00:04:31.990 --> 00:04:35.600
talk about Cocoa's goals,
because that's what defines Cocoa.

00:04:35.600 --> 00:04:38.880
The one way we define Cocoa is to say,
simple things simple,

00:04:38.960 --> 00:04:40.660
complex things possible.

00:04:40.660 --> 00:04:41.730
You might have heard this before.

00:04:41.790 --> 00:04:44.550
It's basically how we,
the design philosophy behind Cocoa.

00:04:44.660 --> 00:04:47.230
We want to make things that
are common to all applications,

00:04:47.230 --> 00:04:49.690
the common application behaviors,
we want to make that easy for you,

00:04:49.690 --> 00:04:52.270
so you can achieve them
with little or no code.

00:04:52.270 --> 00:04:55.630
However, things that are more complex,
things that are unique

00:04:55.630 --> 00:04:57.240
to your application,
the way you want to

00:04:57.240 --> 00:05:00.030
differentiate your application,
those things we might not

00:05:00.060 --> 00:05:02.770
have built into Cocoa,
but you can do them by either

00:05:02.770 --> 00:05:05.210
customizing the classes,
the object-oriented

00:05:05.210 --> 00:05:07.500
designs we've given you,
or by extending them by

00:05:07.500 --> 00:05:08.850
adding new things and so on.

00:05:08.860 --> 00:05:10.460
And we make those things possible.

00:05:10.590 --> 00:05:13.480
So you can write the basic
functionality you get for free,

00:05:13.480 --> 00:05:16.250
and you can write the things that
make your app unique on top of that.

00:05:17.770 --> 00:05:19.460
Now, Cocoa is not a separate box.

00:05:19.510 --> 00:05:23.280
Sometimes when people are
thinking object oriented,

00:05:23.330 --> 00:05:25.640
framework, et cetera,
they tend to think of this environment

00:05:25.740 --> 00:05:29.370
that's boxed itself into a corner
that's powerful but not accessible

00:05:29.370 --> 00:05:30.800
from the rest of the world.

00:05:30.840 --> 00:05:32.360
And that's not the case for Cocoa.

00:05:32.420 --> 00:05:34.200
It's not isolated in its own environment.

00:05:34.390 --> 00:05:37.620
And one of the major reasons
for that is because Cocoa is

00:05:37.620 --> 00:05:41.180
implemented in and is accessible
via the language called Objective-C.

00:05:41.230 --> 00:05:44.220
Objective-C is a thin
superset on top of C.

00:05:44.270 --> 00:05:47.850
It's a very thin superset,
which means it can call into C.

00:05:48.100 --> 00:05:50.140
It can call into any
library on the system,

00:05:50.140 --> 00:05:54.460
whether it's Carbon or Mach or
POSIX or any other library

00:05:54.460 --> 00:05:55.730
that you get from the web.

00:05:55.810 --> 00:05:58.980
And it can easily interact with
all these other subsystems because

00:05:58.980 --> 00:06:01.390
it's Objective-C and that's C.

00:06:01.460 --> 00:06:04.100
Now, one thing that Cocoa doesn't
do is to provide an API for

00:06:04.100 --> 00:06:05.610
every technology on the system.

00:06:05.640 --> 00:06:06.960
Sometimes people are surprised.

00:06:07.050 --> 00:06:08.720
Why can't I do this through Cocoa?

00:06:08.810 --> 00:06:11.420
We tend to-- we don't
want to duplicate efforts.

00:06:11.450 --> 00:06:14.370
So we won't provide APIs where
that API might just be-- it

00:06:14.370 --> 00:06:18.000
might be a wrapper or some basic
duplication of functionality.

00:06:18.020 --> 00:06:21.950
We do APIs when there is benefits,
such as abstraction, power,

00:06:22.090 --> 00:06:24.440
rapid development, performance.

00:06:24.440 --> 00:06:28.520
What I mean by that, for instance,
is like NSWorkspace class.

00:06:28.640 --> 00:06:33.380
We had an NSWorkspace class in Cocoa for
pretty much the whole duration of Cocoa.

00:06:33.440 --> 00:06:35.430
Originally,
that class was meant to interact

00:06:35.530 --> 00:06:38.650
with the workspace application
back on the next machines.

00:06:38.700 --> 00:06:42.010
On some other platform, once upon a time,
it interacted with the

00:06:42.110 --> 00:06:43.730
Explorer shell on that platform.

00:06:43.770 --> 00:06:47.720
And currently on Mac OS X,
it actually talks to launch services

00:06:47.720 --> 00:06:49.610
or finder to get its job done.

00:06:49.810 --> 00:06:52.380
Now, throughout all of this,
developers who are using NSWorkspace

00:06:52.430 --> 00:06:55.120
never had to change their code,
but the implementation

00:06:55.120 --> 00:06:58.400
just changed over and over,
depending on the platform.

00:06:58.630 --> 00:07:02.340
And power and rapid development,
if we can save you from writing 20

00:07:02.340 --> 00:07:05.040
lines of code abstracted in one,
that's where Cocoa's

00:07:05.040 --> 00:07:06.460
benefits come through.

00:07:06.500 --> 00:07:09.240
And performance-- so let me
talk a bit about performance,

00:07:09.240 --> 00:07:11.870
since it is an important topic.

00:07:13.810 --> 00:07:17.450
Sometimes, again, when people think
object-oriented framework,

00:07:17.550 --> 00:07:18.940
they think inefficient.

00:07:18.940 --> 00:07:21.470
And again, with Cocoa,
that's not the case.

00:07:21.730 --> 00:07:24.100
Cocoa was developed on machines
that are far less capable

00:07:24.100 --> 00:07:25.620
than the machines of today.

00:07:25.620 --> 00:07:28.260
Four megabytes memory,
that's equivalent to one nice

00:07:28.620 --> 00:07:30.950
dashboard image today or something.

00:07:30.950 --> 00:07:33.140
25 megahertz processors.

00:07:33.140 --> 00:07:35.200
So those were small machines.

00:07:35.240 --> 00:07:37.790
Of course,
Cocoa was a lot less capable back then,

00:07:37.790 --> 00:07:39.040
and it wasn't called Cocoa.

00:07:39.040 --> 00:07:42.000
It was the precursor to Cocoa.

00:07:42.000 --> 00:07:44.280
And since that time,
we've added a lot of new features.

00:07:44.280 --> 00:07:46.050
We've also added a lot
more computing power.

00:07:46.050 --> 00:07:48.160
We've always been vigilant
about performance.

00:07:48.270 --> 00:07:52.080
But one thing that has made Cocoa even
practical on those machines of

00:07:52.080 --> 00:07:55.850
yesteryear is the fact that Objective-C,
the implementation language,

00:07:55.950 --> 00:07:58.260
is object-oriented,
but it has to have low memory

00:07:58.260 --> 00:08:00.310
overhead and low CPU overhead.

00:08:00.390 --> 00:08:01.700
It's very efficient.

00:08:01.780 --> 00:08:05.260
It's designed to be efficient,
take very little memory,

00:08:05.260 --> 00:08:07.600
and also to have the
message-sending system that,

00:08:07.600 --> 00:08:09.810
when caching is going on, is very,
very efficient.

00:08:09.920 --> 00:08:12.200
So that makes it possible.

00:08:12.200 --> 00:08:15.500
And also in Cocoa,
we have object-oriented techniques,

00:08:15.510 --> 00:08:19.420
and we use them to actually
help with performance.

00:08:19.420 --> 00:08:21.820
An example is the way we
hide implementation of,

00:08:21.820 --> 00:08:23.010
say, NSString.

00:08:23.080 --> 00:08:26.800
When you use NSString to store
your character string contents,

00:08:26.930 --> 00:08:28.640
you don't care whether
it uses 8-bit characters,

00:08:28.640 --> 00:08:29.560
16-bit characters.

00:08:29.560 --> 00:08:32.990
You don't care whether it's using
a tree implementation or a flat

00:08:33.090 --> 00:08:35.660
array of characters implementation.

00:08:35.660 --> 00:08:38.630
The truth is NSString does all of these,
depending on how it's being used.

00:08:38.630 --> 00:08:42.140
But again, depending on the situation,
it does the right thing,

00:08:42.140 --> 00:08:44.580
and just gives you one
model to work with.

00:08:44.580 --> 00:08:47.710
And other techniques include we
can cache in some cases where

00:08:47.720 --> 00:08:49.670
an underlying API might not,
et cetera,

00:08:49.690 --> 00:08:51.240
to give you the correct performance.

00:08:51.240 --> 00:08:53.780
So with object-oriented techniques,
sometimes you'll get a boost in

00:08:53.870 --> 00:08:57.240
performance that you might not otherwise
if you actually had to write the 20,

00:08:57.240 --> 00:09:00.510
30 lines to get the
same job done yourself.

00:09:00.700 --> 00:09:03.410
The API of Cocoa,
the Application Programming Interface,

00:09:03.550 --> 00:09:07.610
also really helps define Cocoa because
it's consistent -- it's got consistent

00:09:07.700 --> 00:09:10.660
naming and calling conventions,
which really helps make

00:09:10.670 --> 00:09:13.440
Cocoa easy to understand,
easy to predict,

00:09:13.620 --> 00:09:17.720
and easy for you to extend by
using similar naming schemes.

00:09:17.810 --> 00:09:20.780
We like to call the
APIs impedance matched.

00:09:20.780 --> 00:09:23.040
When you get an API from here and
when you get an API from here,

00:09:23.040 --> 00:09:23.960
they're both Cocoa.

00:09:23.960 --> 00:09:25.370
They will plug in well together.

00:09:25.370 --> 00:09:30.160
You don't have, oh,
110 volts and 220 volts, and oh, oh, oh.

00:09:30.160 --> 00:09:32.260
So, you know, that's -- we like to call
it impedance matching.

00:09:32.260 --> 00:09:34.840
You'll see this over
and over in Cocoa APIs.

00:09:34.840 --> 00:09:38.470
And the other thing is we have a small
number of concepts such as delegation,

00:09:38.610 --> 00:09:40.820
outlets, target action that are
used over and over,

00:09:40.820 --> 00:09:42.840
which makes Cocoa very powerful.

00:09:42.840 --> 00:09:45.510
And as an example,
we recently added the bindings,

00:09:45.510 --> 00:09:49.000
a brand-new concept -- well,
brand-new concept in Panther.

00:09:49.100 --> 00:09:52.640
And we immediately applied it
to all the classes in AppKit so

00:09:52.640 --> 00:09:55.830
that it was widely used and that,
you know, you could take advantage of it

00:09:55.830 --> 00:09:58.640
from any place where it made sense.

00:09:59.300 --> 00:10:00.700
Cocoa is also universal.

00:10:00.700 --> 00:10:02.770
You might have seen the demos
yesterday and heard the talk

00:10:02.820 --> 00:10:03.840
of this universal thing.

00:10:03.840 --> 00:10:06.680
I mean, part of it's because Cocoa's
been through the hoops.

00:10:06.770 --> 00:10:10.020
It was originally on 6830
back in the day and 6840.

00:10:10.020 --> 00:10:14.610
It also was ported to RISC architectures
and it was ported to the 386,

00:10:14.700 --> 00:10:16.000
486, etc.

00:10:16.000 --> 00:10:20.310
RISC taught us how to be aligned
correctly and x86 taught us how

00:10:20.310 --> 00:10:22.390
to go backwards and forwards.

00:10:22.400 --> 00:10:25.570
So we solved a lot of
these problems early on.

00:10:26.020 --> 00:10:28.830
Now, what makes Cocoa universal
is the fact that the APIs are

00:10:28.980 --> 00:10:30.480
architecture independent.

00:10:30.480 --> 00:10:34.980
There's no Indian dependencies or
architecture dependencies in the APIs.

00:10:34.980 --> 00:10:37.410
There are a lot of
abstractions like NSString,

00:10:37.670 --> 00:10:38.840
again, as an example.

00:10:38.840 --> 00:10:42.940
With NSString, you don't care how your
Unicode characters are stored,

00:10:42.940 --> 00:10:45.420
whether the two bytes are stored
little Indian or big Indian.

00:10:45.420 --> 00:10:47.250
You're working with a
higher level of abstraction.

00:10:47.250 --> 00:10:49.640
It's an atomic object
that contains a string.

00:10:49.660 --> 00:10:52.940
Opaque objects, again,
you're not in there dealing

00:10:53.100 --> 00:10:54.870
with the fields of a struct.

00:10:54.970 --> 00:10:56.000
The objects are actually abstracted.

00:10:56.000 --> 00:10:57.560
You're actually hiding all that from you.

00:10:57.560 --> 00:11:00.470
And we have concepts like
archiving where you can read and

00:11:00.500 --> 00:11:03.980
write objects and archives you
create are Indian independent.

00:11:03.980 --> 00:11:07.520
The archives you're creating today and
the archives you've been creating for

00:11:07.520 --> 00:11:10.120
the past five years will work on Intel,
no problem.

00:11:10.160 --> 00:11:14.060
So that's the kind of abstraction
that makes Cocoa universal.

00:11:14.060 --> 00:11:17.770
Now, let me talk a bit about
Objective-C++ because this is a

00:11:17.810 --> 00:11:20.220
topic that interests many people.

00:11:20.390 --> 00:11:26.200
We enable integration of C++ and
Objective-C in the same source file.

00:11:26.200 --> 00:11:29.840
So you can actually use Objective-C and
C++ in the same source file,

00:11:29.840 --> 00:11:31.620
and we call it a peaceful coexistence.

00:11:31.620 --> 00:11:36.060
We want to keep the capabilities
of both systems intact.

00:11:36.060 --> 00:11:40.400
We want to keep the native ABI,
the semantics, the performance intact.

00:11:40.400 --> 00:11:42.120
We don't want to change any of these.

00:11:42.580 --> 00:11:46.100
So we keep both languages as
they are in their standard form,

00:11:46.100 --> 00:11:48.860
but we let you call between each other.

00:11:48.860 --> 00:11:50.540
So one thing that means is we don't,
for instance,

00:11:50.540 --> 00:11:53.640
give you the ability to subclass
a Cocoa object in an S window,

00:11:53.640 --> 00:11:55.270
an S string, using C++.

00:11:55.340 --> 00:11:57.430
However, you can call back and
forth between those.

00:11:57.430 --> 00:11:59.890
You can have instance variables
of either type in each object.

00:12:00.000 --> 00:12:03.360
And what this means is if you
have a large body of C++ code,

00:12:03.360 --> 00:12:05.960
or you want to use C++
in your Cocoa project,

00:12:05.960 --> 00:12:07.650
that's all easily done.

00:12:07.670 --> 00:12:10.370
Just take the C++ code
you're using in your project,

00:12:10.480 --> 00:12:12.540
and it gets most of the code.

00:12:12.560 --> 00:12:14.330
And it gets all developers,
almost all developers,

00:12:14.360 --> 00:12:15.200
exactly what they want.

00:12:15.270 --> 00:12:17.550
It gets it done.

00:12:17.780 --> 00:12:21.610
Now a few words about Cocoa Java.

00:12:22.400 --> 00:12:26.260
So the Cocoa Java is our
APIs to make Cocoa APIs,

00:12:26.260 --> 00:12:30.450
our Java APIs to make
Cocoa available to Java programs.

00:12:30.450 --> 00:12:32.530
And for the most part,
this is transparent.

00:12:32.530 --> 00:12:36.520
Of course, a Java program you write this
way is not cross-platform because

00:12:36.520 --> 00:12:40.510
it's dependent on Cocoa APIs,
which -- and -- but for the most part,

00:12:40.510 --> 00:12:42.360
you can write a Java program.

00:12:42.360 --> 00:12:45.710
It is using Java APIs,
and you can access Cocoa programs.

00:12:45.960 --> 00:12:48.280
However,
we have some downsides to this approach.

00:12:48.280 --> 00:12:52.600
And those of you who use Cocoa Java have
probably noticed this and known this.

00:12:52.690 --> 00:12:55.080
The maintaining and setting
up of the bridging isn't free.

00:12:55.180 --> 00:12:57.990
Every time we add a new class,
every time we add a new method,

00:12:58.010 --> 00:13:00.300
we need to go and decide what
the Java interface looks like,

00:13:00.340 --> 00:13:03.620
because we want to make sure
the Java interface is good and

00:13:03.760 --> 00:13:05.770
it fits the Java guidelines.

00:13:07.510 --> 00:13:09.280
The bridging itself
is not also toll-free.

00:13:09.280 --> 00:13:12.560
It's not free for objects to cross
between Java and Objective-C,

00:13:12.560 --> 00:13:14.190
so there's always a
little performance hit.

00:13:14.220 --> 00:13:17.070
And finally,
the applications written this

00:13:17.070 --> 00:13:20.230
way have slower startup times
and larger footprints than

00:13:20.230 --> 00:13:21.400
their Objective-C counterparts.

00:13:21.400 --> 00:13:23.360
So when you're developing
such an application,

00:13:23.360 --> 00:13:25.640
if you want to get it to the
next level of performance,

00:13:25.640 --> 00:13:27.380
at some point,
the truth is you want to maybe

00:13:27.380 --> 00:13:29.640
put aside the Java version
and rewrite an Objective-C.

00:13:29.640 --> 00:13:33.140
So as a result of these,
very few developers are actually

00:13:33.140 --> 00:13:35.100
using Java to program Cocoa.

00:13:36.390 --> 00:13:39.220
And, you know, with that,
we're saying that we will not make

00:13:39.220 --> 00:13:41.430
additional Cocoa APIs available in Java.

00:13:41.440 --> 00:13:44.250
So the ones that are available today,
which is a large subset

00:13:44.250 --> 00:13:46.660
of AppCode and Foundation,
but not the other frameworks,

00:13:46.660 --> 00:13:47.420
will be available.

00:13:47.420 --> 00:13:50.870
But any new APIs, any new frameworks,
are not going to be available in Java.

00:13:53.290 --> 00:13:55.760
Cocoa-Carbon Interaction, again,
another topic that's of

00:13:55.760 --> 00:13:58.190
interest to a lot of developers.

00:13:58.530 --> 00:14:01.400
Now, developers want to be able to,
you know, they have Carbon source bases,

00:14:01.400 --> 00:14:03.120
they want to start
using Cocoa components,

00:14:03.120 --> 00:14:05.680
they want to migrate slowly,
or they have Cocoa programs and they

00:14:05.680 --> 00:14:07.810
want to be able to use Carbon plug-ins,
or so on.

00:14:07.840 --> 00:14:09.490
This is what we want to enable.

00:14:09.500 --> 00:14:12.420
So what we support,
so one thing we support

00:14:12.420 --> 00:14:13.890
is the non-UI code.

00:14:13.950 --> 00:14:18.650
Now, as I said earlier, Objective-C, C,
calling conventions, all same,

00:14:18.650 --> 00:14:21.940
so you can call into any
Carbon API which is non-UI.

00:14:21.940 --> 00:14:25.150
You know, you can call FSRefs,
you can call launch services, all that.

00:14:25.220 --> 00:14:27.540
Sometimes there's no,
the impedance match is, you know,

00:14:27.540 --> 00:14:30.670
not perfect, so you have to convert
FSRef into a URL or a path,

00:14:31.080 --> 00:14:33.580
but, you know, you do it,
it's straightforward, no problems.

00:14:33.580 --> 00:14:37.120
Another thing that's supported is
modal panels in the other environment.

00:14:37.200 --> 00:14:41.930
You can put up a Cocoa modal panel from
a Carbon application and vice versa.

00:14:41.940 --> 00:14:45.800
Now, also supported is just putting up
windows in the other environment.

00:14:45.860 --> 00:14:48.040
So you can put up a Carbon window
from a Cocoa application

00:14:48.040 --> 00:14:49.040
or the other way around.

00:14:49.450 --> 00:14:50.700
However, there are some caveats.

00:14:50.700 --> 00:14:52.880
Sometimes, you know,
there are some edge cases

00:14:52.880 --> 00:14:55.260
or if you push the envelope,
there might be bugs.

00:14:55.280 --> 00:14:57.340
Now, if you're trying to do
this and you run into bugs,

00:14:57.340 --> 00:15:00.520
let us know,
and these are things that we want to fix.

00:15:00.520 --> 00:15:04.810
Now, there's also the area of things that
don't work and they're not supported.

00:15:04.850 --> 00:15:08.620
That's basically hosting views within
windows of the other environment.

00:15:08.620 --> 00:15:10.740
So you cannot put an
HIV in a Cocoa window,

00:15:10.740 --> 00:15:13.950
you cannot put an NS control
in a Carbon window.

00:15:14.350 --> 00:15:17.430
Similarly with sheets
and drawers as well.

00:15:18.570 --> 00:15:21.430
Okay, so before I start talking about,
before we get to that

00:15:21.430 --> 00:15:23.930
section of the talk,
just an overview of what the

00:15:23.990 --> 00:15:27.220
Cocoa frameworks look like in
a simple architecture diagram.

00:15:27.220 --> 00:15:30.580
There are three core Cocoa frameworks,
Foundation, Core Data,

00:15:30.580 --> 00:15:31.790
and Application Kit.

00:15:32.310 --> 00:15:36.530
Foundation is our non-UI framework,
contains objects like collections,

00:15:36.680 --> 00:15:38.790
file manager, thread, etc.

00:15:38.800 --> 00:15:42.080
Core Data is our new framework,
it's new in Tiger.

00:15:42.080 --> 00:15:45.360
It gives you facilities for
object lifecycle management,

00:15:45.360 --> 00:15:48.960
basically object persistence, undo,
relationships, Andreas will talk about

00:15:48.960 --> 00:15:49.820
that in a few minutes.

00:15:49.820 --> 00:15:52.830
And the Application Kit,
which is the UI layer of Cocoa,

00:15:52.830 --> 00:15:57.060
which includes Windows, Events,
the text system, the document subsystem,

00:15:57.060 --> 00:15:57.690
so on.

00:15:57.700 --> 00:16:00.030
Now typically you don't use
these frameworks individually,

00:16:00.030 --> 00:16:01.860
you just go ahead and
use the Cocoa framework,

00:16:02.020 --> 00:16:05.470
and your app is a Cocoa framework,
and you don't care about these

00:16:05.610 --> 00:16:07.310
three frameworks individually.

00:16:07.320 --> 00:16:11.780
There are other frameworks on the system,
which all provide Objective-C APIs.

00:16:12.090 --> 00:16:15.970
And provide good impedance
matching with the Cocoa APIs.

00:16:15.980 --> 00:16:18.630
WebKit and address book are
two frameworks that were

00:16:18.640 --> 00:16:22.070
introduced before Tiger,
and they've been around for a while.

00:16:22.080 --> 00:16:24.250
And the last six are
actually new in Tiger,

00:16:24.250 --> 00:16:31.330
and they provide APIs, rich Cocoa APIs,
rich Objective-C APIs for you to use.

00:16:31.990 --> 00:16:34.140
And one final word about tools.

00:16:34.160 --> 00:16:36.950
The primary development tool, of course,
is Xcode.

00:16:37.090 --> 00:16:39.390
It has great support for
Objective-C and frameworks.

00:16:39.400 --> 00:16:42.340
It has great support for debugging,
great support for indexing,

00:16:42.340 --> 00:16:44.200
great support for editing, and so on.

00:16:44.350 --> 00:16:49.690
And also, new in Tiger,
it's got facilities for class

00:16:49.690 --> 00:16:49.690
modeling and data modeling.

00:16:49.880 --> 00:16:52.800
The other tool for Cocoa development
is Interface Builder.

00:16:52.800 --> 00:16:56.030
And it's the fundamental tool for
creating Cocoa user interfaces.

00:16:56.110 --> 00:16:58.640
Not only does it let you lay out
your user interface elements,

00:16:58.640 --> 00:17:01.090
put a button here, put a slider here,
you can also specify

00:17:01.090 --> 00:17:02.430
connections between them.

00:17:02.500 --> 00:17:04.550
So when this button is pressed,
this object is tickled.

00:17:04.560 --> 00:17:07.570
You can specify the bindings
between them and so on.

00:17:07.650 --> 00:17:13.640
And when you save your interface,
it doesn't generate source code.

00:17:13.640 --> 00:17:14.880
It just generates an archive,
which is then read back in at runtime.

00:17:16.110 --> 00:17:17.840
And finally,
we have the performance tools.

00:17:17.840 --> 00:17:21.760
These are clearly critical tools you
should be using on your applications.

00:17:21.760 --> 00:17:24.200
They let you do performance
analysis of memory,

00:17:24.200 --> 00:17:25.340
CPU, and so on.

00:17:25.340 --> 00:17:27.740
And you should definitely
take a look at these as you're

00:17:27.740 --> 00:17:29.280
developing your applications.

00:17:29.800 --> 00:17:31.490
So at this point,
to talk about the recent

00:17:31.500 --> 00:17:33.050
changes in directions,
I'd like to invite

00:17:33.100 --> 00:17:35.710
Andreas Wendker on stage.

00:17:41.270 --> 00:17:41.660
Thank you, Ali.

00:17:41.780 --> 00:17:44.210
My name is Andreas Wendker,
and I manage the Xcode

00:17:44.290 --> 00:17:45.930
and Codata frameworks.

00:17:46.060 --> 00:17:49.310
So we are constantly trying to raise
the bar for what Cocoa offers to you.

00:17:49.460 --> 00:17:52.100
And so in every release of Mac OS X,
you find a set of new features

00:17:52.100 --> 00:17:54.280
and enhancements that we think
you should seriously consider

00:17:54.370 --> 00:17:57.500
for your own applications,
because they make them more powerful,

00:17:57.500 --> 00:17:59.810
more easy to develop,
and easier to maintain.

00:17:59.870 --> 00:18:02.020
And of course,
we can list all of the changes here,

00:18:02.040 --> 00:18:06.090
but Ali and I picked a few that you'd
like to cover with a few slides each.

00:18:06.660 --> 00:18:09.320
Let's start with bindings and core data.

00:18:09.370 --> 00:18:12.240
These are two of the larger new
features we recently added to Cocoa.

00:18:12.400 --> 00:18:13.820
And they share a lot of goals.

00:18:13.990 --> 00:18:16.260
And the most important one is
to just significantly speed

00:18:16.260 --> 00:18:18.020
up your development process.

00:18:18.080 --> 00:18:21.980
And they do that by taking control of a
lot of the standard default functionality

00:18:21.980 --> 00:18:23.590
that every application has to provide.

00:18:23.660 --> 00:18:26.370
So instead of having to develop
the same kind of infrastructure for

00:18:26.370 --> 00:18:30.460
every application again and again,
you can just let the frameworks drive,

00:18:30.510 --> 00:18:32.820
and just get more functionality,
more powerful,

00:18:32.820 --> 00:18:35.320
more consistent applications
for actually doing less work,

00:18:35.420 --> 00:18:36.470
for writing less code.

00:18:36.580 --> 00:18:40.040
Which means that you can focus on your
own core problem of your application,

00:18:40.130 --> 00:18:42.240
and you get much quicker to market.

00:18:42.520 --> 00:18:44.250
The two technologies are
very tightly integrated.

00:18:44.370 --> 00:18:46.000
They share a lot of the concepts.

00:18:46.110 --> 00:18:47.200
They're often used together.

00:18:47.430 --> 00:18:50.790
But it's important to know that they
are really independent of each other.

00:18:50.870 --> 00:18:55.190
So Bionics were actually introduced
in Panther and Codata in Tiger.

00:18:56.880 --> 00:18:58.680
So what are bindings?

00:18:58.700 --> 00:19:02.040
Bindings automatically
synchronize user interfaces.

00:19:02.040 --> 00:19:04.680
They make sure that without
you doing anything special,

00:19:04.680 --> 00:19:07.160
the user interface obviously
reflects the latest state of

00:19:07.210 --> 00:19:08.360
the underlying data objects.

00:19:08.360 --> 00:19:10.610
There are two parts to Cocoa bindings.

00:19:10.610 --> 00:19:14.430
The first part is a set of controller
classes that you use to manage

00:19:14.430 --> 00:19:16.460
and access your model objects.

00:19:16.460 --> 00:19:18.260
They give you things like
sorting and filtering.

00:19:18.260 --> 00:19:21.750
They give you tools to handle selections,
including a convenient way to

00:19:21.760 --> 00:19:25.250
handle multiple selections or the
different selection states in the UI.

00:19:25.260 --> 00:19:29.260
And they even allow you to easily
display and edit object relationships.

00:19:29.260 --> 00:19:32.250
The other part of the technology
are the actual bindings,

00:19:32.260 --> 00:19:35.600
which define how you synchronize
an element in the UI with

00:19:35.600 --> 00:19:37.760
an underlying data object.

00:19:37.760 --> 00:19:40.730
So most of the time,
you set up bindings code-free

00:19:40.760 --> 00:19:42.360
in Interface Builder.

00:19:42.850 --> 00:19:47.180
And what's really important here is that
bindings aren't limited to object values.

00:19:47.180 --> 00:19:49.330
Bindings are not just a simple
form filler to get a few

00:19:49.330 --> 00:19:50.600
values in the text fields.

00:19:50.600 --> 00:19:53.440
In fact, they are bindings for all
kinds of parameters in your UI.

00:19:53.440 --> 00:19:57.120
You find things like bindings for
enabled and hidden states of your views.

00:19:57.120 --> 00:20:00.060
You find bindings for controlling
display fonts and colors.

00:20:00.100 --> 00:20:03.470
You find bindings for table
sort orders and table width,

00:20:03.470 --> 00:20:08.000
window sizes, even tooltips,
titles of buttons, lots of other things.

00:20:08.000 --> 00:20:11.240
So bindings really give you control
over the entire state of your UI.

00:20:11.240 --> 00:20:12.680
They aren't limited to
just filling some form.

00:20:12.700 --> 00:20:14.310
forms.

00:20:16.240 --> 00:20:18.880
Bindings are based on the model view
controller paradigm and on three

00:20:18.880 --> 00:20:20.430
simple protocols that we introduced.

00:20:20.520 --> 00:20:24.450
K-value coding, K-value observing,
and K-value binding.

00:20:24.820 --> 00:20:27.690
Key value coding allows you to
access properties of an object

00:20:27.920 --> 00:20:30.470
just by specifying the name without
having to know the underlying

00:20:30.560 --> 00:20:31.970
implementation details of the object.

00:20:31.980 --> 00:20:35.500
Key value observing allows you to
register for change notifications

00:20:35.500 --> 00:20:38.700
so that you are automatically told
if a property of an object changes.

00:20:38.720 --> 00:20:40.180
And again,
you just specify the name of the

00:20:40.180 --> 00:20:41.360
property you want to observe.

00:20:42.980 --> 00:20:47.380
and Kevin Binding pretty much combines
the two concepts and creates a definition

00:20:47.380 --> 00:20:50.900
of what kind of property of a view
you want to synchronize with what

00:20:51.040 --> 00:20:53.020
kind of property in a model object.

00:20:53.020 --> 00:20:54.850
And like I said before,
most of the time you just set

00:20:54.850 --> 00:20:56.080
this up in interface builder.

00:20:56.170 --> 00:20:58.950
But you can also do it programmatically,
and the key value binding protocol

00:20:59.140 --> 00:21:01.980
offers a few methods that you can
work with for working with bindings,

00:21:01.980 --> 00:21:05.830
the most important one being the
bindToObjectWithKeyPathInOptions method.

00:21:05.960 --> 00:21:08.380
So this is the method that
actually establishes a binding.

00:21:08.470 --> 00:21:09.660
It has four arguments.

00:21:09.680 --> 00:21:12.060
You send the method to the
view you want to control.

00:21:12.160 --> 00:21:13.660
The first argument is the binding.

00:21:13.660 --> 00:21:15.880
It's the name of the property
of the view you want to control,

00:21:15.970 --> 00:21:18.460
typically the value or the enabled state.

00:21:18.500 --> 00:21:22.440
The second argument,
the observer specifies the model

00:21:22.540 --> 00:21:24.060
object you want to work with.

00:21:24.060 --> 00:21:26.290
So you can either bind
directly to a model object,

00:21:26.290 --> 00:21:29.900
or more commonly actually is that
you bind to a controller in between.

00:21:30.000 --> 00:21:33.820
The third argument, the key path,
specifies the property of the model

00:21:33.820 --> 00:21:35.340
object you want to synchronize with.

00:21:35.350 --> 00:21:38.660
And the options dictionary just allows
you to specify a bunch of parameters to

00:21:38.660 --> 00:21:40.530
influence the behavior of the binding.

00:21:40.670 --> 00:21:43.500
The most important one is probably
the so-called value transformer.

00:21:43.530 --> 00:21:47.080
A value transformer is a simple
translator object that can transform

00:21:47.250 --> 00:21:49.300
values from one state into another one.

00:21:49.430 --> 00:21:52.630
So even if your model object and
your view object don't exactly match,

00:21:52.690 --> 00:21:55.540
if they have slightly different
representations of the data,

00:21:55.540 --> 00:21:57.140
you can just plug in a
little value transformer to

00:21:57.140 --> 00:21:59.180
make the two work together.

00:22:01.140 --> 00:22:03.430
If you would like to adopt
Cocoa bindings for your own application,

00:22:03.430 --> 00:22:05.680
there are two things that
should really help you greatly.

00:22:05.740 --> 00:22:08.520
First of all, we try to make sure that
performance doesn't get in your way.

00:22:08.640 --> 00:22:12.340
We spend a lot of time optimizing the
user interface to refresh the bindings.

00:22:12.380 --> 00:22:14.580
We are trying to make sure that
we only redraw the portions of

00:22:14.690 --> 00:22:16.210
the UI that have actually changed.

00:22:16.300 --> 00:22:18.440
So if possible, for example,
you just redisplay individual

00:22:18.460 --> 00:22:21.960
sales in a table view instead
of redrawing the entire content.

00:22:22.350 --> 00:22:25.830
The second most important thing
is that bindings can very easily

00:22:25.830 --> 00:22:28.920
coexist with the kind of traditional
code that you wrote in the past to

00:22:28.920 --> 00:22:30.660
control your user interface state.

00:22:30.700 --> 00:22:34.230
So you don't have to convert
over your entire application to

00:22:34.340 --> 00:22:36.390
start making use of bindings.

00:22:36.420 --> 00:22:39.080
You can pretty much incrementally
adopt bindings just by going

00:22:39.080 --> 00:22:41.440
from one part of the UI,
from one window to the next.

00:22:41.440 --> 00:22:43.950
And you can also very easily
mix and match bindings with

00:22:44.070 --> 00:22:45.700
the kind of traditional code.

00:22:45.700 --> 00:22:47.960
So even if bindings are lacking
a certain feature that you would

00:22:47.960 --> 00:22:50.670
really like for a certain view,
you can just continue writing

00:22:50.740 --> 00:22:52.680
your own code for that,
and use bindings for all

00:22:52.750 --> 00:22:53.770
the other things around it.

00:22:53.810 --> 00:22:57.020
So it really easily integrates
with the traditional style of

00:22:57.020 --> 00:22:58.700
development for UI in Cocoa.

00:23:01.760 --> 00:23:03.620
Let's talk about Core Data a little bit.

00:23:03.720 --> 00:23:07.960
Core Data is our object-oriented
API to manage data models.

00:23:08.450 --> 00:23:10.640
Both in memory and on disk.

00:23:10.650 --> 00:23:14.090
We often refer to it as a
fine-grained object graph management

00:23:14.090 --> 00:23:15.770
and persistence framework.

00:23:15.830 --> 00:23:18.120
So when you use CodeData,
you get a lot of things for free.

00:23:18.150 --> 00:23:21.620
Our signature feature is
automatic undo and redo.

00:23:21.640 --> 00:23:24.100
That is always complicated to set up.

00:23:24.110 --> 00:23:26.480
And with CodeData, you get it for free.

00:23:26.480 --> 00:23:29.620
You get things like object
value and state validation.

00:23:29.760 --> 00:23:31.700
And of course,
you can do all this with generic

00:23:31.700 --> 00:23:33.400
data objects that we provide for you.

00:23:33.440 --> 00:23:37.580
Or you can plug in your own custom
objects using your own custom code.

00:23:38.050 --> 00:23:40.230
And to write out the objects to disk,
we give you the choice of

00:23:40.340 --> 00:23:43.390
three types of file formats,
or object stores, how we call it.

00:23:43.460 --> 00:23:46.460
You can store your data in
SQL databases on top of SQLite,

00:23:46.490 --> 00:23:49.020
which is a very nice, lightweight,
embedded database.

00:23:49.020 --> 00:23:51.160
It's an open source database
we integrated in Tiger.

00:23:51.160 --> 00:23:53.260
You can store your objects in XML files.

00:23:53.260 --> 00:23:57.260
You can store them in binary files,
pretty much in a keyed archiving scheme.

00:23:57.860 --> 00:24:01.440
So what's interesting with
Cocoa Data is that Cocoa Data owns

00:24:01.440 --> 00:24:03.460
the schemas for all the stores.

00:24:03.480 --> 00:24:06.260
So you don't have to worry at
all about setting up the stores.

00:24:06.290 --> 00:24:08.820
Even in the SQL case,
you don't even have to create the tables.

00:24:08.870 --> 00:24:10.050
Cocoa Data will do that for you.

00:24:10.100 --> 00:24:12.430
So it's just really nice, convenient,
and fast.

00:24:12.430 --> 00:24:16.180
It's a little bit problematic if you want
to continue using existing file formats,

00:24:16.180 --> 00:24:19.950
if you want to continue supporting file
formats that you created in the past.

00:24:19.980 --> 00:24:22.000
In that case,
you will typically just not use the

00:24:22.070 --> 00:24:23.720
persistent side of the framework.

00:24:23.720 --> 00:24:26.730
You will focus on the in-memory side,
still get undo and redo all the

00:24:26.730 --> 00:24:27.840
validation and the other nice things.

00:24:27.860 --> 00:24:30.710
features for free but you
will continue writing your own

00:24:30.710 --> 00:24:32.420
archiving and unarchiving code

00:24:34.830 --> 00:24:39.100
Let's take a look at the different
characteristics of the three stores.

00:24:39.100 --> 00:24:42.660
The fastest and most scalable
store is clearly the SQLite store.

00:24:42.660 --> 00:24:46.930
The reason is that with the SQLite store,
we can pull in only the objects

00:24:46.930 --> 00:24:49.520
that are currently needed by
your application into memory,

00:24:49.520 --> 00:24:52.220
but we leave everything
else externally on the disk.

00:24:52.220 --> 00:24:54.260
So we only fetch objects
from the database on demand.

00:24:54.320 --> 00:24:57.020
With the XML and binary stores,
we read the entire file at once,

00:24:57.020 --> 00:24:59.280
so your memory footprint
is usually larger,

00:24:59.280 --> 00:25:01.570
and response times are a little slower.

00:25:02.130 --> 00:25:05.420
On the other hand,
while the XML store is the slowest one,

00:25:05.420 --> 00:25:08.070
it's human readable,
and it's also easily exported and

00:25:08.070 --> 00:25:10.700
imported by other applications.

00:25:11.320 --> 00:25:14.820
One more thing about the
access pattern for the stores.

00:25:14.850 --> 00:25:18.470
The XML and binary store are the atomic,
or give you atomic reads and writes.

00:25:18.500 --> 00:25:21.310
So they are probably the types
of stores you want to use in a

00:25:21.310 --> 00:25:23.290
typical document-based application.

00:25:23.320 --> 00:25:29.350
The SQLite store is more commonly
used in cases where you have a

00:25:29.370 --> 00:25:35.290
fixed location for the data store,
something like a library,

00:25:35.290 --> 00:25:35.290
maybe for music or photos,
in the user home directory.

00:25:38.480 --> 00:25:40.800
So for data to do its work,
you need to give it a

00:25:40.800 --> 00:25:42.390
description of the data objects.

00:25:42.450 --> 00:25:45.150
You need to give it what
we call a data model.

00:25:45.190 --> 00:25:48.270
Essentially, you have to go into Xcode,
use the data modeling tools,

00:25:48.400 --> 00:25:52.600
and create an entity relationship
diagram of your data objects.

00:25:53.800 --> 00:25:57.040
So entities define the types of
objects you have in your data model.

00:25:57.040 --> 00:25:59.900
And for each entity,
you specify a set of properties.

00:25:59.900 --> 00:26:03.760
And we support three different
types of properties-- attributes,

00:26:03.780 --> 00:26:06.480
relationships, and fetch properties.

00:26:06.490 --> 00:26:09.580
Attributes correspond to the simple
values that are stored in an object,

00:26:09.600 --> 00:26:14.000
something like the name of a person
or the color of a graphics object.

00:26:14.000 --> 00:26:17.920
Relationships correspond to references
between objects of different entities.

00:26:17.920 --> 00:26:21.540
And here we distinguish between
to one and to many relationships.

00:26:21.650 --> 00:26:24.170
For too many relationships at this time,
we only support unordered

00:26:24.170 --> 00:26:27.190
relationships-- relationships
that are represented as NSSets,

00:26:27.300 --> 00:26:29.480
not as ordered NSServies.

00:26:29.490 --> 00:26:31.680
And fetch properties are
something in the middle.

00:26:31.680 --> 00:26:35.300
You can pretty much think about it
as a loosely defined relationship

00:26:35.300 --> 00:26:39.300
on top of an arbitrary query that
is executed in your data store.

00:26:40.410 --> 00:26:43.290
So in addition to just specifying
the structure and all the names

00:26:43.290 --> 00:26:45.840
of the entities and properties,
you specify a lot of parameters

00:26:45.840 --> 00:26:47.380
that refine the work of Core Data.

00:26:47.380 --> 00:26:50.540
In fact, the more time you spend refining
all the other parameters,

00:26:50.610 --> 00:26:53.270
the better of a job Core Data can do.

00:26:53.370 --> 00:26:55.420
Just to give you some idea,
you typically specify a

00:26:55.420 --> 00:26:58.520
lot of validation rules,
something like the length of a string,

00:26:58.590 --> 00:27:01.480
minimum and maximum values of numbers.

00:27:01.780 --> 00:27:04.610
You specify delete rules,
which tell the framework what to do if an

00:27:04.670 --> 00:27:06.450
object gets removed from your data store.

00:27:06.550 --> 00:27:07.990
A good example is a person object.

00:27:08.000 --> 00:27:10.750
If you want to delete a person object,
you usually also want to

00:27:10.750 --> 00:27:13.880
remove the address and contact
information of that person object.

00:27:13.990 --> 00:27:17.410
You'd call that a cascade delete,
and the delete would allow you to

00:27:17.420 --> 00:27:19.740
specify exactly that type of behavior.

00:27:20.000 --> 00:27:35.800
[Transcript missing]

00:27:37.740 --> 00:27:40.050
In the core architecture,
there's a central point,

00:27:40.110 --> 00:27:42.000
the point that you most
commonly interact with,

00:27:42.080 --> 00:27:44.000
and that's the so-called
managed object context.

00:27:44.000 --> 00:27:47.790
The managed object context is a
container for your model objects.

00:27:47.890 --> 00:27:50.190
You can think about it as
something like a scratch pad,

00:27:50.270 --> 00:27:52.500
or the arts and crafts table,
where you kind of put all the

00:27:52.500 --> 00:27:54.460
model objects in the shape
and form you want them to be.

00:27:54.480 --> 00:27:58.270
And then to write them out to disk,
you hook up the managed object context

00:27:58.270 --> 00:28:02.320
to a persistent store coordinator,
which will then, based on the model,

00:28:02.320 --> 00:28:05.540
map the objects from the
memory into the external store,

00:28:05.540 --> 00:28:07.520
into the external type of
file format you want to use.

00:28:07.700 --> 00:28:10.590
And to the UI side,
you just typically use bindings

00:28:10.590 --> 00:28:14.170
and controllers to fill and
populate the user interface.

00:28:15.490 --> 00:28:18.940
So before I hand my clicker back to Ali,
I just want to give you a quick breakdown

00:28:18.940 --> 00:28:21.690
of where in the Cocoa stack we added
the different kind of APIs introduced

00:28:21.700 --> 00:28:22.980
for these two technologies.

00:28:22.980 --> 00:28:25.400
And most of the time,
you don't really worry about this,

00:28:25.460 --> 00:28:28.140
because you just link against
the Cocoa umbrella framework.

00:28:28.160 --> 00:28:30.590
But sometimes you have to
watch your own dependencies if

00:28:30.590 --> 00:28:33.040
you have reusable frameworks,
or if you, for example,

00:28:33.040 --> 00:28:35.680
want to write a UI-free
command line tool with Cocoa.

00:28:36.070 --> 00:28:40.210
So in Foundation, we added a set of
general utility classes,

00:28:40.300 --> 00:28:42.120
for example, predicates,
which are allowed to define

00:28:42.120 --> 00:28:46.160
search criteria for filtering
and searching of objects,

00:28:46.160 --> 00:28:48.560
sort descriptors, and index set.

00:28:48.590 --> 00:28:50.850
Index set is an object that
is highly optimized for

00:28:50.980 --> 00:28:52.640
managing selection information.

00:28:52.710 --> 00:28:54.850
We usually use it to pass
around selection data,

00:28:54.930 --> 00:28:57.230
index information,
and table views and arrays.

00:28:57.240 --> 00:28:58.840
And, of course,
the value transform and the

00:28:58.860 --> 00:29:01.540
value coding observing protocols,
which are very basic, fundamental,

00:29:01.540 --> 00:29:02.590
are also in Foundation.

00:29:03.650 --> 00:29:05.880
In Core Data,
you find all the object graph

00:29:05.970 --> 00:29:07.740
management persistence logic.

00:29:07.780 --> 00:29:11.400
And this managed object is the required
superclass for all the model objects

00:29:11.400 --> 00:29:12.660
you want to manage with Core Data.

00:29:12.660 --> 00:29:16.470
I already explained the managed object
context in the store coordinator.

00:29:16.480 --> 00:29:19.660
There are also a bunch of classes to
represent the data model at runtime,

00:29:19.660 --> 00:29:21.630
so a model with entity
and property descriptions.

00:29:21.640 --> 00:29:24.630
And in AppKit,
you find all the controller classes

00:29:24.650 --> 00:29:26.640
introduced by Cocoa Bindings.

00:29:26.640 --> 00:29:28.500
We have controller classes
for single objects,

00:29:28.500 --> 00:29:29.730
for arrays, even for trees.

00:29:29.740 --> 00:29:32.890
There's even a convenient way to
access user defaults from bindings.

00:29:33.040 --> 00:29:34.320
It's the NSUserDefaultController.

00:29:34.320 --> 00:29:37.300
And then the NSKeyValueBinding
protocol is also defined in AppKit.

00:29:37.320 --> 00:29:41.080
And with that,
I'd like to hand back to Ali to finish.

00:29:41.110 --> 00:29:45.980
Thank you.

00:29:49.930 --> 00:29:50.900
Okay, Spotlight.

00:29:50.900 --> 00:29:53.910
As you know, Spotlight's one of the
highlights of Tiger,

00:29:53.910 --> 00:29:57.400
and we really like to encourage
you to use it in your applications.

00:29:57.400 --> 00:29:59.850
The central class for
Cocoa is NSMetadataQuery.

00:29:59.850 --> 00:30:03.640
NSMetadataQuery basically is the class
for performing Spotlight queries.

00:30:03.650 --> 00:30:06.060
It's bindable,
meaning you can actually bind it to

00:30:06.220 --> 00:30:09.740
user interface elements such as array
controller and table view and so on,

00:30:09.740 --> 00:30:10.830
or tree controller.

00:30:10.830 --> 00:30:13.330
It also has a delegate to
modify query results before

00:30:13.370 --> 00:30:14.930
they're actually displayed.

00:30:14.930 --> 00:30:17.580
So you can tweak the results
and display them in certain

00:30:17.590 --> 00:30:19.880
grouping or certain categories.

00:30:19.900 --> 00:30:23.940
The metadata query object
provides query results.

00:30:24.010 --> 00:30:26.850
It provides attribute values,
so you can optimize it to only

00:30:26.850 --> 00:30:29.430
fetch values for certain attributes,
value lists,

00:30:29.430 --> 00:30:33.910
so it will give you counts of values,
and also hierarchically grouped results.

00:30:34.000 --> 00:30:37.220
So, for instance, like the music lists on
your iPod where there is,

00:30:37.240 --> 00:30:39.500
you know, genre, artist, albums, etc.

00:30:39.500 --> 00:30:43.440
Now, in this here,
you might be wondering, isn't, you know,

00:30:43.440 --> 00:30:46.060
you've probably heard of the
MDQuery APIs for Spotlight,

00:30:46.060 --> 00:30:48.370
and you might be wondering why
we have a class in Cocoa to

00:30:48.370 --> 00:30:49.880
do this when this seems like,
well, it's not really a class.

00:30:49.880 --> 00:30:53.970
Well, there are several reasons.

00:30:53.970 --> 00:30:56.440
One of them is the fact
that the impedance match

00:30:56.440 --> 00:30:58.240
I was talking about earlier.

00:30:58.240 --> 00:30:59.880
These are Cocoa APIs.

00:30:59.880 --> 00:31:02.550
For instance,
these APIs are expressed in terms

00:31:02.670 --> 00:31:06.120
of NSPredicate or NSSortDescriptor
so that they'll fit a lot better

00:31:06.210 --> 00:31:07.620
with the other Cocoa classes.

00:31:07.620 --> 00:31:09.620
In addition, these are bindings-aware.

00:31:09.620 --> 00:31:12.590
You can hook these up and display the
results in a table view immediately,

00:31:12.590 --> 00:31:15.230
you know, without having to write any
or just very minimal code,

00:31:15.230 --> 00:31:15.860
maybe.

00:31:19.920 --> 00:31:21.670
So, you know, the fact that these are
hierarchically grouped results

00:31:21.670 --> 00:31:22.560
is unique to metadata query.

00:31:22.740 --> 00:31:26.470
That's something you can take
advantage of with these APIs.

00:31:26.910 --> 00:31:29.560
Now, we do an example in the
system called Spotlighter.

00:31:29.560 --> 00:31:31.720
It shows you the various
features I talked about.

00:31:31.720 --> 00:31:34.430
You know,
you can do straightforward queries

00:31:34.430 --> 00:31:36.240
and it will find the results.

00:31:36.240 --> 00:31:38.750
And just by hitting that tab,
you can actually look at the

00:31:38.750 --> 00:31:41.210
results in a grouped fashion,
in this case, you know,

00:31:41.210 --> 00:31:44.000
grouped by file type, grouped by size,
and also notice that

00:31:44.010 --> 00:31:46.710
when it groups by size,
it actually collapses the

00:31:46.790 --> 00:31:48.980
every kilobyte together,
so, you know,

00:31:49.000 --> 00:31:51.140
you're grouping by kilobyte sizes.

00:31:51.140 --> 00:31:52.690
So, again, uses that API.

00:31:52.770 --> 00:31:56.800
It's a good example of that API,
if you want to take a look at it.

00:31:56.800 --> 00:31:58.800
So, next topic I want to
cover is error handling.

00:31:58.820 --> 00:32:01.870
Now, error handling might not
seem like such an exciting,

00:32:02.000 --> 00:32:05.100
sexy subject, and it's something,
you know, oh, yeah, error handling,

00:32:05.100 --> 00:32:06.510
that's just, you know, yeah,
we do error handling.

00:32:06.540 --> 00:32:09.690
Well, it is -- we are very excited
about error handling,

00:32:09.690 --> 00:32:11.270
so I want to talk about it.

00:32:11.470 --> 00:32:14.200
We introduced NSError as
a new class in NSPanther,

00:32:14.200 --> 00:32:17.550
and we've greatly enhanced in Tiger.

00:32:17.660 --> 00:32:19.100
Now here,
when I talk about error handling,

00:32:19.100 --> 00:32:22.240
I'm not talking about,
let's get every API in

00:32:22.240 --> 00:32:24.160
Cocoa to return error codes.

00:32:24.160 --> 00:32:25.000
That's not what we mean.

00:32:25.000 --> 00:32:29.480
What we mean is we want to get the
APIs which might have user impact,

00:32:29.480 --> 00:32:31.140
where the user should be alerted.

00:32:31.190 --> 00:32:33.010
We want to get those cases right.

00:32:33.290 --> 00:32:36.060
So our goal is to provide
the user with polished,

00:32:36.160 --> 00:32:38.660
informative, well-crafted error messages.

00:32:38.660 --> 00:32:42.100
In addition, we want to handle common
cases out of the box.

00:32:42.130 --> 00:32:44.060
There are a lot of errors
that occur very commonly,

00:32:44.060 --> 00:32:46.500
you know, errors associated with
maybe reading files,

00:32:46.510 --> 00:32:47.150
writing files.

00:32:47.220 --> 00:32:49.050
Those are very common
to many applications.

00:32:49.050 --> 00:32:52.080
So we want to handle those for you,
and you don't have to

00:32:52.120 --> 00:32:54.020
write any code for that.

00:32:54.020 --> 00:32:56.390
So, for instance,
here's an error alert you

00:32:56.390 --> 00:32:58.100
might get in TextEdit in Tiger.

00:32:58.100 --> 00:33:01.210
You'll notice that it's, you know,
a fairly nice error panel.

00:33:01.310 --> 00:33:02.150
It gives you a file name.

00:33:02.150 --> 00:33:03.170
It gives you what happened.

00:33:03.170 --> 00:33:04.420
It tells you why it happened.

00:33:04.420 --> 00:33:07.120
It even gives you a helpful
suggestion as to how you might fix it.

00:33:07.140 --> 00:33:09.200
Now,
TextEdit -- which is a fairly small app.

00:33:09.200 --> 00:33:11.060
It's not even NSDocument-based yet.

00:33:11.060 --> 00:33:13.170
We've been planning on doing this,
but it's not yet.

00:33:13.270 --> 00:33:15.910
You know, it gets this functionality
with one line of code.

00:33:15.910 --> 00:33:18.640
Now, if it was NSDocument-based,
it would get it with zero lines of code.

00:33:18.680 --> 00:33:20.540
But anyway, one line is not too bad.

00:33:20.540 --> 00:33:24.370
And, you know, you get this error message
when you cannot read a file.

00:33:24.540 --> 00:33:27.560
Similarly, if you're running in French,
you know, the frameworks provide you

00:33:27.560 --> 00:33:29.980
with the French version of
the error panel as well.

00:33:29.980 --> 00:33:31.650
So you get automatic localization.

00:33:32.600 --> 00:36:15.700
[Transcript missing]

00:36:16.210 --> 00:36:18.530
So we've -- clearly,
this error stuff becomes a lot

00:36:18.550 --> 00:36:21.330
more handy when there are more
classes that return errors,

00:36:21.370 --> 00:36:23.980
and we've added a bunch of them,
NSString, AttributedStringData,

00:36:23.980 --> 00:36:25.090
et cetera.

00:36:25.180 --> 00:36:27.230
Now, whenever you're reading
and writing files,

00:36:27.230 --> 00:36:29.900
these will return NSErrors,
so you can actually go ahead

00:36:29.900 --> 00:36:31.780
and then process those.

00:36:31.890 --> 00:36:35.220
KeyValueCoding has had an error
returning method for validation,

00:36:35.220 --> 00:36:38.100
so when the value that the user
type goes to the model object,

00:36:38.110 --> 00:36:41.800
if the validation fails because the
object is out of range or it's invalid,

00:36:41.920 --> 00:36:44.080
you know, you get back an NSError.

00:36:44.130 --> 00:36:46.450
And similarly,
NumberFormatter and DateFormatter

00:36:46.450 --> 00:36:49.900
now have new methods in Tiger to let
you get back errors when parsing of,

00:36:49.970 --> 00:36:51.010
say, a date fails.

00:36:52.980 --> 00:36:55.460
Now, from NSServer to NSDocument.

00:36:55.460 --> 00:36:58.560
NSDocument also has some
exciting new features.

00:36:58.580 --> 00:37:00.240
One of them is error handling.

00:37:00.240 --> 00:37:03.310
I already mentioned that,
and I won't talk about it anymore

00:37:03.310 --> 00:37:06.490
except to mention that tomorrow
there's an advanced document

00:37:06.560 --> 00:37:09.200
techniques talk tomorrow morning,
I believe,

00:37:09.270 --> 00:37:14.620
where Mark Petrelli will cover the error
handling and show you how it works.

00:37:14.620 --> 00:37:17.080
NSPersistentDocument is
a subclass of NSDocument.

00:37:17.090 --> 00:37:19.180
Now,
those of you who have used NSDocument

00:37:19.180 --> 00:37:24.140
know that the way you use NSDocument is
you subclass it and you add your code

00:37:24.440 --> 00:37:28.060
to read and write the document contents,
and everything else is handled for you.

00:37:28.110 --> 00:37:31.720
With NSPersistentDocument,
everything is handled for you,

00:37:31.720 --> 00:37:32.920
so you don't have to do anything.

00:37:32.930 --> 00:37:35.060
It's because it uses core
data behind the scenes and,

00:37:35.060 --> 00:37:39.460
you know, basically saves your document
for you in the format you choose.

00:37:39.460 --> 00:37:42.280
So I won't talk about PersistentDocument
other than saying that.

00:37:42.300 --> 00:37:44.460
The one final feature of
NSDocument is autosaving,

00:37:44.470 --> 00:37:46.620
and again,
Mark Petrelli will show this tomorrow,

00:37:46.640 --> 00:37:49.180
but let me just talk about it because
it also is an exciting new feature.

00:37:49.180 --> 00:37:55.480
It lets NSDocument-based apps
periodically autosave open documents.

00:37:55.480 --> 00:37:57.720
And not only are you
saving open documents,

00:37:57.870 --> 00:38:00.320
you can also even save
untitled documents.

00:38:00.440 --> 00:38:03.470
So the user launches their app,
they type away for eight

00:38:03.470 --> 00:38:05.840
hours without saving,
and the power goes out.

00:38:06.180 --> 00:38:08.540
Well, if you use this feature,
they'll be happy because next

00:38:08.540 --> 00:38:10.500
time they launch the app,
they'll say, "Hey,

00:38:10.620 --> 00:38:14.640
there's an unsaved document." Now,
it takes one call to enable this

00:38:14.810 --> 00:38:17.500
set autosaving delay where you
specify how -- what the delay

00:38:17.500 --> 00:38:19.150
is before the document is saved.

00:38:19.180 --> 00:38:21.480
So,
you can see that the document is saved.

00:38:21.480 --> 00:38:24.930
We tried to make it so you
don't have to call this at

00:38:25.070 --> 00:38:27.240
Different applications really
want different behaviors.

00:38:27.240 --> 00:38:29.960
Some applications might want
to set this to a bigger value.

00:38:29.960 --> 00:38:33.100
Some applications might want to
customize the way they autosave.

00:38:33.170 --> 00:38:37.180
And many applications probably should
provide a UI and let the user choose

00:38:37.210 --> 00:38:39.210
whether autosaving should be enabled.

00:38:39.350 --> 00:38:43.110
So you'll have to call this
with the appropriate value.

00:38:43.110 --> 00:38:47.700
There are a number of other related
methods as well for autosaving.

00:38:47.980 --> 00:38:51.110
For instance, you can customize the way
autosaving happens and not use

00:38:51.110 --> 00:38:51.110
the default way that we do it.

00:38:52.810 --> 00:38:55.170
We have some changes in NS Text.

00:38:55.220 --> 00:38:57.590
If you were at the text
talk at last year's WWDC,

00:38:57.600 --> 00:38:59.860
Doug Davidson did a great
job of covering these.

00:38:59.980 --> 00:39:02.970
I'll just highlight some
of the important ones here.

00:39:03.080 --> 00:39:07.670
We have support for a lot more document
formats and also document properties.

00:39:08.010 --> 00:39:10.900
Now we have a lot more complete
set of document formats we support.

00:39:11.010 --> 00:39:14.090
The ones that we've added in Tiger,
we can now do a much

00:39:14.090 --> 00:39:16.600
better job of reading HTML,
we can save HTML,

00:39:16.600 --> 00:39:20.460
we can also read and write web archive,
which is HTML with images

00:39:20.570 --> 00:39:24.180
and other attachments,
and we can read and write

00:39:24.180 --> 00:39:26.330
Word and WordML documents.

00:39:27.380 --> 00:39:30.520
Now, so this means, for instance,
in TextEdit, which is a fairly simple

00:39:30.570 --> 00:39:32.870
client of the text system,
you can type, type,

00:39:32.870 --> 00:39:35.300
type rich text and save
that as an HTML document.

00:39:35.300 --> 00:39:37.460
And you can open it, save it, open it,
save it, et cetera.

00:39:37.460 --> 00:39:40.300
And it's losslessly
being saved and restored.

00:39:40.490 --> 00:39:43.530
Now, because the HTML document saving,
there are so many options that

00:39:43.530 --> 00:39:47.210
different people would want to apply,
we actually have some ways to tweak,

00:39:47.410 --> 00:39:50.090
change the way the saving occurs.

00:39:50.400 --> 00:39:53.430
You can, for instance,
decide to use style sheets or not,

00:39:53.480 --> 00:39:54.770
and so on and so forth.

00:39:54.920 --> 00:39:58.340
You can decide to lose
white spaces or not.

00:39:58.410 --> 00:40:01.120
In TextEdit,
if you go to the preferences panel,

00:40:01.120 --> 00:40:04.640
you can globally set the way
TextEdit saves HTML documents,

00:40:04.680 --> 00:40:05.610
and you'll see the options.

00:40:05.620 --> 00:40:08.840
You specify what kind of HTML,
what the styling is,

00:40:08.840 --> 00:40:11.130
what encoding to use, and so on.

00:40:12.960 --> 00:40:16.000
So as I mentioned,
the text system now has support for

00:40:16.000 --> 00:40:19.910
document properties like author,
subject, et cetera.

00:40:19.930 --> 00:40:23.580
We will read and write these metadata
in all of the text document formats,

00:40:23.670 --> 00:40:26.920
except for plain text,
which doesn't have support for them.

00:40:26.920 --> 00:40:30.530
The plain text format doesn't
have any place to put these.

00:40:30.550 --> 00:40:33.200
And in TextEdit,
there's a document properties panel,

00:40:33.200 --> 00:40:36.040
which lets you specify these,
and it just puts them

00:40:36.040 --> 00:40:38.040
out to the text document.

00:40:38.040 --> 00:40:41.590
Now, one reason I'm mentioning this here
is because I want to encourage you to

00:40:41.600 --> 00:40:45.400
think about how you can support metadata
like this in your own applications

00:40:45.400 --> 00:40:46.640
and your own document formats.

00:40:46.640 --> 00:40:49.430
Not just text, but any other document
format you might have.

00:40:49.490 --> 00:40:51.790
And then provide appropriate
UI so the user can save them,

00:40:51.800 --> 00:40:53.440
and then your importer can import them.

00:40:53.450 --> 00:40:58.080
And this makes your documents a lot
more easily searchable and findable.

00:40:58.290 --> 00:41:00.210
So other changes in the text
system I won't talk about,

00:41:00.290 --> 00:41:02.860
but there is now support for tables,
there's support for lists.

00:41:02.950 --> 00:41:04.860
This, of course,
also enables us to have the

00:41:04.860 --> 00:41:06.280
better HTML support we now do.

00:41:06.280 --> 00:41:08.290
There's support for multiple selection.

00:41:08.290 --> 00:41:10.300
You can now select a
column of text if you want,

00:41:10.350 --> 00:41:12.620
a rectangle of text,
or you can actually do a search

00:41:12.620 --> 00:41:15.320
in the Find panel and find all
occurrences of a certain word,

00:41:15.320 --> 00:41:16.940
for instance, and modify it.

00:41:17.030 --> 00:41:22.440
There are now standard panels to support
all these features at the user level.

00:41:22.440 --> 00:41:26.020
And there's also improved text layout
for complex international scripts.

00:41:27.280 --> 00:41:30.550
Speaking of internationalization,
we've added two new classes and

00:41:30.550 --> 00:41:34.990
updated some of the existing ones,
and let me just touch up on those.

00:41:35.210 --> 00:41:39.500
NSLocale is a new API.

00:41:39.500 --> 00:41:41.090
We've never had a locale API.

00:41:41.130 --> 00:41:44.810
We always use this model
of an NSDictionary which

00:41:44.940 --> 00:41:47.120
holds locale data together.

00:41:47.160 --> 00:41:50.060
This is a new class,
and it's really there as a

00:41:50.100 --> 00:41:51.550
basis for future improvements.

00:41:51.560 --> 00:41:54.830
Right now, very few classes,
only some of the new APIs we've added,

00:41:54.830 --> 00:41:55.960
uses NSLocale.

00:41:56.050 --> 00:41:59.250
So you can use NSLocale in those APIs,
or you can ask NSLocale for

00:41:59.250 --> 00:42:01.840
various locale data,
is what you can do.

00:42:01.860 --> 00:42:05.040
And the existing locale arguments
in our API still expect the old

00:42:05.040 --> 00:42:06.880
style NSDictionary instances.

00:42:06.970 --> 00:42:10.630
So there's a bit of a transition
period there with NSLocale.

00:42:10.760 --> 00:42:16.170
NSCalendar is a new class which does
all sorts of calendar operations,

00:42:16.240 --> 00:42:21.750
compose, decompose, date components,
date arithmetic, et cetera.

00:42:21.760 --> 00:42:24.340
It's not really designed for
creating your own instance,

00:42:24.370 --> 00:42:28.480
your own subclasses of NSCalendar,
but it does have support for the

00:42:28.480 --> 00:42:32.040
major calendar systems in the world.

00:42:32.110 --> 00:42:34.790
So you can actually create calendar
instances for . I'm going to show

00:42:34.790 --> 00:42:36.010
you how to do that in just a moment.

00:42:36.070 --> 00:42:40.980
So you can create a calendar instance
for a number of different calendars.

00:42:41.000 --> 00:42:42.930
And you can ask it questions like,
how many days are there

00:42:43.100 --> 00:42:46.240
Here you're asking how many days are
there in the month that we're in today,

00:42:46.240 --> 00:42:49.320
and the answer will be
1,31 is the range of days.

00:42:49.420 --> 00:42:52.740
Or you can ask questions like how many,
not shopping days,

00:42:52.790 --> 00:42:56.310
but how many days till Christmas,
which is the next question.

00:42:57.170 --> 00:43:00.350
Date formatter is an existing class,
and we've enhanced it a great deal.

00:43:00.580 --> 00:43:03.730
It now uses ICU,
the International Components

00:43:03.730 --> 00:43:07.060
for Unicode Library,
for doing most of its work.

00:43:07.060 --> 00:43:10.730
And what this means is the
format string has been upgraded

00:43:10.730 --> 00:43:13.140
to accept new format strings.

00:43:13.150 --> 00:43:15.370
Now, because the change is
somewhat incompatible,

00:43:15.370 --> 00:43:18.980
and we don't want to break applications,
we made it so that you only get the

00:43:19.080 --> 00:43:23.280
new features if you actually explicitly
ask for the new formatter behavior,

00:43:23.280 --> 00:43:26.850
which you do with this call here,
set formatter behavior.

00:43:27.450 --> 00:43:30.290
So we encourage you to do
that for your formatters,

00:43:30.290 --> 00:43:34.070
where you really aren't using the old
APIs in a way that would be incompatible.

00:43:34.080 --> 00:43:36.300
Just do this,
and suddenly your formatters

00:43:36.300 --> 00:43:39.340
work for all localizations and
will be a lot more capable.

00:43:39.390 --> 00:43:43.800
The way a date formatter works is you
can specify the style of date and time.

00:43:43.800 --> 00:43:50.090
You can specify it separately,
short date, long time, et cetera.

00:43:50.140 --> 00:43:52.420
Or you can actually go ahead and use
format strings like you could do before.

00:43:53.570 --> 00:43:56.500
Number formatter has gone the
same sort of transformation,

00:43:56.500 --> 00:43:57.860
now uses ICU.

00:43:57.860 --> 00:44:00.410
And again, to take advantage of it,
you have to make a call.

00:44:00.410 --> 00:44:03.060
And once you do that,
you can ask for the different styles,

00:44:03.410 --> 00:44:04.680
decimal currency, et cetera.

00:44:04.680 --> 00:44:07.240
And the last one is sort of cute,
and it even actually

00:44:07.240 --> 00:44:08.790
works in other languages.

00:44:08.790 --> 00:44:11.600
So you can have it read it
out to you or something.

00:44:11.600 --> 00:44:14.270
And both date formatter and number
formatter now have APIs which let

00:44:14.330 --> 00:44:17.790
you convert from string to date,
date to string with just one call.

00:44:17.860 --> 00:44:20.120
So a while before,
the API was geared more

00:44:20.120 --> 00:44:22.030
towards being used with cell.

00:44:22.030 --> 00:44:25.990
Now it's easily -- you can use
easily to convert numbers and dates

00:44:26.010 --> 00:44:28.090
to strings and back and forth.

00:44:28.170 --> 00:44:30.150
Speaking of string,
I'm just going to reemphasize

00:44:30.190 --> 00:44:33.460
something I've said many,
many times before.

00:44:33.460 --> 00:44:37.760
With get off C string APIs,
and we're finally deprecating them.

00:44:37.760 --> 00:44:40.360
I'll just explain what
this means quickly.

00:44:40.360 --> 00:44:43.890
These are the APIs in NSString which
do not specify an explicit encoding.

00:44:44.130 --> 00:44:49.520
So they interpret the bag of bytes,
the C string, you know, the char star,

00:44:49.590 --> 00:44:50.120
to be in the string.

00:44:50.120 --> 00:44:52.700
And then encoding, which is dependent on
the user's language.

00:44:52.700 --> 00:44:55.750
So this means that your
program has ambiguous behavior.

00:44:55.750 --> 00:44:58.350
If you don't test in
some edge case languages,

00:44:58.360 --> 00:45:01.200
your program might work,
but it might break, so on and so forth.

00:45:01.200 --> 00:45:05.700
So these APIs have been -- in general,
they're not a good idea and we'd like

00:45:05.700 --> 00:45:08.030
to -- we've been discouraging them,
and now we'd really like to

00:45:08.030 --> 00:45:09.600
say don't use them anymore.

00:45:09.600 --> 00:45:10.980
So it's these kinds of APIs.

00:45:10.980 --> 00:45:15.620
The last two are also in this boat
because they actually interpret a

00:45:15.750 --> 00:45:17.640
file in the user's default encoding.

00:45:17.640 --> 00:45:20.110
So they're as dangerous
as the C string APIs.

00:45:20.120 --> 00:45:21.120
Thank you.

00:45:21.550 --> 00:45:23.700
The methods you should be
using are methods we've been

00:45:23.700 --> 00:45:27.120
introducing both throughout
Panther and also Bunch and Tiger.

00:45:27.150 --> 00:45:30.280
They're APIs which take an
explicit encoding argument.

00:45:30.430 --> 00:45:33.710
So you say C string using encoding,
so on and so forth.

00:45:33.810 --> 00:45:37.590
The last two, for instance,
will-- you don't specify an encoding,

00:45:37.590 --> 00:45:41.830
but these try to guess the encoding
and return the actual encoding to you.

00:45:41.830 --> 00:45:45.190
They're right now not very sophisticated,
but over time,

00:45:45.190 --> 00:45:48.800
they will-- our intention is to
make them a lot more capable about

00:45:48.910 --> 00:45:50.320
sniffing the encoding used in a file.

00:45:50.540 --> 00:45:51.400
Keyed archiving.

00:45:51.400 --> 00:45:54.160
This is another thing that we've
actually introduced a while ago,

00:45:54.160 --> 00:45:58.520
and I really want to emphasize
the use of this class.

00:45:58.940 --> 00:46:02.160
Keyed archiving is NSKeedArchiving,
NSKeedUnarchiving,

00:46:02.160 --> 00:46:05.690
those classes as opposed to NSArchiver,
which is something we've

00:46:05.690 --> 00:46:06.780
had for a long time.

00:46:06.780 --> 00:46:10.250
Keyed archiving enables creating archives
which are a lot more robust and a lot

00:46:10.250 --> 00:46:12.780
more flexible than what we had before.

00:46:12.780 --> 00:46:15.020
So before,
when you wrote a bunch of stuff out,

00:46:15.020 --> 00:46:18.280
you would say, write this int,
write this string, write this bool.

00:46:18.420 --> 00:46:22.020
And on the way back, you'd have to say,
read the int, read the string,

00:46:22.020 --> 00:46:22.940
read the bool.

00:46:22.940 --> 00:46:26.480
If you read them back in the wrong order,
it was disastrous.

00:46:26.480 --> 00:46:29.570
You couldn't really put new keys and
things in there because old systems

00:46:29.570 --> 00:46:31.330
wouldn't accept them and so on.

00:46:31.450 --> 00:46:34.620
It's like walking around with a box
of punch cards and when you drop it,

00:46:34.620 --> 00:46:35.540
you're dead.

00:46:35.540 --> 00:46:38.900
The order is gone and you don't know
how to resurrect things anymore.

00:46:38.900 --> 00:46:41.020
The new way with keyed archiving,
you basically say,

00:46:41.050 --> 00:46:42.980
write this int and you specify the key.

00:46:43.060 --> 00:46:44.040
That's my age.

00:46:44.040 --> 00:46:46.940
Write this string, it's my name,
and so on.

00:46:46.940 --> 00:46:50.140
And on the way back, you can ask for them
in any order you want.

00:46:50.140 --> 00:46:51.920
You don't have to ask for all the keys.

00:46:51.920 --> 00:46:54.360
There could be extra keys in the
stream that you don't care about.

00:46:54.360 --> 00:46:56.240
I mean, it makes a lot more sense, right?

00:46:56.240 --> 00:46:58.900
And that's why we added it.

00:46:58.900 --> 00:47:02.470
So with this, you can actually save
documents in a new system,

00:47:02.470 --> 00:47:04.940
read them back on the old system,
no problem.

00:47:04.940 --> 00:47:07.550
We even have a feature in keyed archiving
where if you have a new class that

00:47:07.550 --> 00:47:11.100
you've introduced and you're putting
instances of that class in the file,

00:47:11.200 --> 00:47:15.550
you can specify as a hint the name
of the class to be used on the older

00:47:15.560 --> 00:47:18.300
system if this class cannot be found.

00:47:18.300 --> 00:47:20.490
So if you have some less capable
class in an older system,

00:47:20.490 --> 00:47:24.340
you can write out the keys that the
less capable class would accept.

00:47:24.340 --> 00:47:25.900
So you can actually
get your file to load.

00:47:26.010 --> 00:47:29.350
to load with some sort of
fidelity on the older system.

00:47:30.260 --> 00:47:34.130
VoiceOver, again,
it's a highlight feature of Tiger,

00:47:34.280 --> 00:47:38.770
and you hopefully saw a demo of
it yesterday at Bertrand talk.

00:47:38.770 --> 00:47:42.440
It's the built-in accessibility
interface for disabled users,

00:47:42.440 --> 00:47:44.040
and it's ready to go
right out of the box.

00:47:44.100 --> 00:47:46.550
You can either enable
it when you install,

00:47:46.550 --> 00:47:49.070
or you can just hit Command-F5,
do it now,

00:47:49.210 --> 00:47:51.210
and you'll see it start to work.

00:47:51.210 --> 00:47:53.300
Turn off your sound first.

00:47:54.380 --> 00:47:59.280
It makes use of the accessibility APIs,
which we added in Jaguar.

00:47:59.330 --> 00:48:02.920
Now, the accessibility APIs did make
their appearance in Jaguar,

00:48:02.920 --> 00:48:05.610
and they were fairly thorough,
and then since then,

00:48:05.610 --> 00:48:06.860
we've been adding to them.

00:48:06.860 --> 00:48:10.970
Recently in Tiger,
the big change we did there

00:48:11.030 --> 00:48:16.490
was to add the ability to apply
attributes to UI elements.

00:48:16.850 --> 00:48:19.570
and to arbitrary accessible UI elements.

00:48:19.640 --> 00:48:22.610
So what this means is you no
longer have to subclass UI elements

00:48:23.120 --> 00:48:25.560
to add some of these features.

00:48:25.830 --> 00:48:28.580
An example is,
you can now add a description

00:48:28.580 --> 00:48:29.570
to any UI element.

00:48:29.670 --> 00:48:32.260
This is useful, for instance,
for a button which just

00:48:32.260 --> 00:48:33.300
has an image on it.

00:48:33.370 --> 00:48:35.200
Clearly,
a button with an image cannot be read

00:48:35.350 --> 00:48:36.960
back to the user through voiceover.

00:48:36.960 --> 00:48:39.150
However,
if you attach a description to it,

00:48:39.150 --> 00:48:42.160
that description can be read
when voiceover is enabled.

00:48:43.460 --> 00:48:46.420
Another useful attribute
like this is the linkage,

00:48:46.440 --> 00:48:48.520
the linked UI elements attribute.

00:48:48.680 --> 00:48:50.620
In mail,
you have the table of contents on top,

00:48:50.790 --> 00:48:52.840
you have the body of the
mail message at the bottom.

00:48:52.900 --> 00:48:55.690
It's nice to know that there's
a linkage from here to here,

00:48:55.710 --> 00:48:58.270
so the voiceover can guide the
user to go to this next field.

00:48:58.600 --> 00:49:01.050
Although,
maybe in the keyboard navigation,

00:49:01.150 --> 00:49:04.560
it's not the next UI element
when you're tabbing through,

00:49:04.590 --> 00:49:05.700
for instance.

00:49:05.700 --> 00:49:09.300
Interface Builder also has support
for editing these attributes.

00:49:09.300 --> 00:49:11.280
So, in Interface Builder,
you can select your button,

00:49:11.310 --> 00:49:14.210
and you can go ahead and
specify the description for it

00:49:14.210 --> 00:49:15.590
right there and save it out.

00:49:15.670 --> 00:49:18.280
It's really very easy,
and it's really something, you know,

00:49:18.320 --> 00:49:20.690
if you have a button with an image,
no text, you know,

00:49:20.690 --> 00:49:25.730
just consider doing this one extra step
to make your app a lot more accessible.

00:49:26.820 --> 00:49:29.740
Let me talk a bit about NSColor.

00:49:29.870 --> 00:49:32.470
Once upon a time we had this
concept of calibrated colors

00:49:32.480 --> 00:49:34.400
which were device independent.

00:49:34.400 --> 00:49:37.090
And then for the longest
time this didn't work.

00:49:37.320 --> 00:49:38.910
Where they were device dependent.

00:49:39.100 --> 00:49:40.300
And in TIGER they work again.

00:49:40.300 --> 00:49:41.980
So they're device independent.

00:49:41.980 --> 00:49:46.820
So colors you create with calibrated red,
green, blue, or calibrated gray,

00:49:46.870 --> 00:49:50.530
or calibrated hue, saturation,
brightness, those colors now return

00:49:50.530 --> 00:49:51.540
calibrated colors.

00:49:51.540 --> 00:49:54.410
And what we mean by that here is
they correspond to the generic

00:49:54.810 --> 00:49:58.840
color space in quartz which is
basically another very sophisticated

00:49:59.010 --> 00:50:00.950
way to get device independent color.

00:50:00.950 --> 00:50:03.910
Color that looks right or
color that looks similar or

00:50:03.910 --> 00:50:06.630
the same on different devices.

00:50:07.240 --> 00:50:10.960
Now, in addition to this,
in addition to just the two device

00:50:10.960 --> 00:50:14.670
color space and color space,
we now have the ability to have

00:50:15.100 --> 00:50:17.260
arbitrary color space sport in NSColor.

00:50:17.650 --> 00:50:20.000
There's a new class called NSColorSpace.

00:50:20.000 --> 00:50:24.450
It has predefined . In addition,
you can create these color spaces from

00:50:24.490 --> 00:50:27.450
RCC profiles or ColorSync profiles.

00:50:28.090 --> 00:50:29.800
and once you have one
of these color spaces,

00:50:29.800 --> 00:50:33.150
you can go ahead and create a color,
just create this color with

00:50:33.150 --> 00:50:36.160
this color space and specifying
the floating point components

00:50:36.240 --> 00:50:38.040
appropriate for that color space.

00:50:38.060 --> 00:50:41.020
Now we bubble the support
all the way up to the user.

00:50:41.100 --> 00:50:43.550
In Tiger, in the color panel,
you might have noticed that

00:50:43.630 --> 00:50:48.320
there's a new little button to the
left of that slider over there.

00:50:48.350 --> 00:50:51.520
That button, when pressed,
will put up a list of color

00:50:51.520 --> 00:50:54.270
spaces that are appropriate
for the currently chosen model.

00:50:54.350 --> 00:50:58.820
So in this case, generic RGB, device RGB,
and sRGB, and maybe the one for

00:50:58.820 --> 00:51:00.500
your current device.

00:51:00.860 --> 00:51:03.200
Now the implication here
is that for the user,

00:51:03.200 --> 00:51:05.560
the user can actually
now select these colors.

00:51:05.600 --> 00:51:08.370
They can drop them in your documents.

00:51:08.470 --> 00:51:10.520
For instance,
if you're a drawing application,

00:51:10.530 --> 00:51:12.020
these colors can be there.

00:51:12.030 --> 00:51:15.240
Now if you save your documents
using keyed archiving,

00:51:15.260 --> 00:51:17.260
you're in great shape,
because these color space

00:51:17.260 --> 00:51:18.760
information will be saved out.

00:51:18.760 --> 00:51:22.080
On older machines,
it will be properly ignored,

00:51:22.180 --> 00:51:24.320
but the user will still
get the right color.

00:51:24.340 --> 00:51:26.640
On newer machines, of course,
it will be used.

00:51:26.710 --> 00:51:30.020
If you're using archiving to
save your document format,

00:51:30.040 --> 00:51:32.810
the user will still see the right color,
but we have to save it

00:51:32.880 --> 00:51:35.230
without the color space,
because we can't support this

00:51:35.230 --> 00:51:36.700
new feature on the old archives.

00:51:36.700 --> 00:51:39.460
So there's another reason
to move to keyed archiving.

00:51:39.570 --> 00:51:41.680
And if you're using some
other document format,

00:51:41.680 --> 00:51:43.200
whatever,
this is something you should be aware of.

00:51:43.200 --> 00:51:46.340
It's probably a good idea for
you to somehow start saving the

00:51:46.340 --> 00:51:48.190
color space in your documents.

00:51:49.090 --> 00:51:53.480
Okay, so, so far we've been talking about
stuff that you should be doing,

00:51:53.700 --> 00:51:58.590
and now a few words about
stuff you shouldn't be doing.

00:51:59.200 --> 00:52:02.180
One quick thing is 64-bit.

00:52:02.290 --> 00:52:05.180
As you know, in 64-bit,
we don't have to have 64-bit support

00:52:05.210 --> 00:52:08.460
at the high-level frameworks,
only the system framework.

00:52:08.480 --> 00:52:13.170
But in the 64-bit world,
an int is 32 bits, a pointer is 64 bits.

00:52:13.170 --> 00:52:16.910
Therefore,
an int and pointer are different sizes.

00:52:16.910 --> 00:52:19.690
If you ever make the assumption
they're the same size,

00:52:19.690 --> 00:52:21.430
that breaks in the 64-bit.

00:52:22.250 --> 00:52:26.700
So another assumption about
resolution dependence.

00:52:26.700 --> 00:52:30.000
As you know, almost all the
measurements in Cocoa APIs,

00:52:30.450 --> 00:52:34.940
except for window frames,
are in terms of points.

00:52:35.170 --> 00:52:38.020
And points are 1/72 of an inch, roughly.

00:52:38.160 --> 00:52:40.850
So every time we specify
these measurements,

00:52:40.850 --> 00:52:42.160
they're in terms of points.

00:52:42.190 --> 00:52:44.740
And it so happens that we
assume on all the devices,

00:52:44.880 --> 00:52:46.530
one point is equal to one pixel.

00:52:46.640 --> 00:52:49.940
You can imagine, as we move to higher
resolution displays and so on,

00:52:49.940 --> 00:52:52.720
that one point might
start covering two pixels,

00:52:52.720 --> 00:52:55.020
or one and a half pixels, and so on.

00:52:55.020 --> 00:52:58.260
And therefore, if we want to get truly
resolution-dependent drawing

00:52:58.260 --> 00:53:01.170
happening in the future,
it's nice never to make this assumption

00:53:01.170 --> 00:53:03.200
that one point is equal to one pixel.

00:53:03.460 --> 00:53:05.570
So all the measurements,
all the NS rects and

00:53:05.570 --> 00:53:08.930
sizes that pass around,
you know, assume those are points,

00:53:08.930 --> 00:53:09.770
not pixels.

00:53:11.280 --> 00:53:13.800
And assuming APIs return things
other than what they say,

00:53:13.800 --> 00:53:15.710
a simple example of this,
an API might say it

00:53:15.760 --> 00:53:18.160
returns an S dictionary,
but you discover, hey,

00:53:18.160 --> 00:53:20.780
it returns an S mutable dictionary,
so maybe I'll just mutate it.

00:53:20.930 --> 00:53:22.080
That's a bad example.

00:53:22.080 --> 00:53:25.780
I mean, that's a good example of
something that's bad to do.

00:53:25.780 --> 00:53:28.320
Don't go mutating such dictionaries.

00:53:28.320 --> 00:53:32.890
Another recent example that we saw
here was the user defaults change.

00:53:33.140 --> 00:53:36.400
User defaults now saves its
files in a different format,

00:53:36.700 --> 00:53:40.340
which started returning not mutable,
immutable dictionaries and

00:53:40.340 --> 00:53:43.120
such upon reading back,
and some applications were actually

00:53:43.190 --> 00:53:45.400
bitten by that because they
assumed they could mutate those,

00:53:45.400 --> 00:53:46.780
which, of course,
is very dangerous because

00:53:46.850 --> 00:53:48.860
they're actually mutating the
user defaults data structures.

00:53:48.860 --> 00:53:53.330
Another thing you should not be doing is
drawing faster than 60 frames per second.

00:53:53.330 --> 00:53:55.650
I mean, you know, if you can draw it,
sure,

00:53:55.770 --> 00:53:58.190
it's a great thing to be able to say,
you know,

00:53:58.200 --> 00:54:01.550
this app draws 300 frames a second,
but you're really doing

00:54:01.560 --> 00:54:03.080
too much work and,
you know,

00:54:03.080 --> 00:54:06.190
wasting CPU or GPU resources there
because the user can't see it.

00:54:06.260 --> 00:54:08.890
In Tiger,
with the Call List Updates feature,

00:54:08.920 --> 00:54:12.190
if you're drawing faster
than 60 frames a second,

00:54:12.190 --> 00:54:17.400
your drawing will be stalled while
the drawing is -- the previous thing

00:54:17.500 --> 00:54:20.430
is being -- the previous drawing you
did is being flushed to the screen.

00:54:20.440 --> 00:54:24.220
Now, this is only true for applications
which have been linked on Tiger.

00:54:24.230 --> 00:54:26.890
So for previous applications,
for compatibility purposes,

00:54:26.890 --> 00:54:28.080
you actually don't get this.

00:54:28.080 --> 00:54:30.870
However,
if you use Quartz Debug application

00:54:30.870 --> 00:54:34.850
and you can play with these things
and you can check your app to see if

00:54:34.850 --> 00:54:37.200
your app will be impacted by this.

00:54:37.200 --> 00:54:39.430
So basically, you know,
no need to draw faster

00:54:39.430 --> 00:54:40.960
than 60 frames a second.

00:54:40.960 --> 00:54:44.580
You can do computations and so on, but,
you know, make sure you -- you gait

00:54:44.580 --> 00:54:46.160
yourself as you draw.

00:54:46.160 --> 00:54:48.460
And there's a release note on this topic.

00:54:48.460 --> 00:54:51.060
And one final thing you should not
be doing is using private APIs,

00:54:51.170 --> 00:54:51.690
you know.

00:54:51.700 --> 00:54:55.120
It's like we saw -- we
see discussions of private

00:54:55.130 --> 00:54:57.960
APIs sometimes on the mailing lists,
and Objective-C is great.

00:54:57.960 --> 00:55:01.030
It's got great introspection features,
make it easy to find what

00:55:01.030 --> 00:55:02.250
private APIs we have.

00:55:02.320 --> 00:55:04.420
But every time you use private APIs,
you're using something

00:55:04.490 --> 00:55:06.560
that's undocumented,
we might change it at any point,

00:55:06.610 --> 00:55:08.660
it might break,
it might have some side effects.

00:55:08.730 --> 00:55:10.800
It makes life difficult
for both you and us.

00:55:10.870 --> 00:55:12.110
So it's a good idea to avoid those.

00:55:12.200 --> 00:55:15.670
Let us know what APIs we're
missing so we can add them.

00:55:16.000 --> 00:55:18.840
And some universal
considerations to be aware of.

00:55:18.890 --> 00:55:20.960
But first, actually,
I would like to ask a question.

00:55:20.960 --> 00:55:24.380
So how many people had the chance
to try their apps under Intel?

00:55:24.610 --> 00:55:26.170
Is there --

00:55:26.500 --> 00:55:27.580
Yeah, there's a few.

00:55:27.640 --> 00:55:30.340
I heard downstairs that there's
a universal compatibility

00:55:30.340 --> 00:55:32.460
lab in the cafeteria area.

00:55:32.460 --> 00:55:35.480
You can just go there and
compile your application.

00:55:35.480 --> 00:55:37.590
They have a bunch of machines,
a bunch of engineers to help you out.

00:55:37.760 --> 00:55:42.850
I hear there's a good bunch
of good success stories,

00:55:43.010 --> 00:55:47.190
you know, some with no tweaks,
some with one or two small tweaks.

00:55:47.190 --> 00:55:47.190
So, you know, just if you get a chance,
definitely try it.

00:55:47.930 --> 00:55:49.880
Now, I'm just going to talk
a few things about,

00:55:49.880 --> 00:55:52.030
you know,
just add to a little bit what Simon said

00:55:52.030 --> 00:55:54.060
yesterday if you were in Bertrand's talk.

00:55:54.110 --> 00:55:57.380
The biggest issue with Universal that
we've seen is basically file and

00:55:57.510 --> 00:55:59.200
network data byte ordering issues.

00:55:59.210 --> 00:56:01.300
You know, examples are UTF-16 files.

00:56:01.340 --> 00:56:02.780
They have two byte entities.

00:56:02.780 --> 00:56:06.640
They can be little or big Indian, and,
you know, you're making the assumption,

00:56:06.650 --> 00:56:08.620
oh, it's big Indian,
and it turns out it's

00:56:08.660 --> 00:56:09.840
really little Indian.

00:56:09.850 --> 00:56:13.140
Files with ints and structs,
you've actually dumped an int in there,

00:56:13.140 --> 00:56:15.820
or a struct in there,
or bit fields in there, and so on.

00:56:15.820 --> 00:56:17.780
That's another sort of thing.

00:56:17.800 --> 00:56:18.330
That's another source of problem.

00:56:18.330 --> 00:56:23.350
Possible solutions here, again,
include stuff like if you use XML files,

00:56:23.350 --> 00:56:25.700
those are human readable,
and for the most part,

00:56:25.700 --> 00:56:28.710
unless you write data in them,
they are going to be Indian safe,

00:56:28.710 --> 00:56:29.960
Indian independent.

00:56:29.960 --> 00:56:32.530
The keyed archiver and
the archiver classes,

00:56:32.530 --> 00:56:33.920
those are Indian safe.

00:56:33.920 --> 00:56:35.480
They do the right thing.

00:56:35.480 --> 00:56:38.430
Now, if you already have data
structures you've written out,

00:56:38.510 --> 00:56:40.700
and, you know,
let's say you've written them

00:56:40.700 --> 00:56:43.410
out in big Indian format,
and you've got to read those old

00:56:43.410 --> 00:56:46.460
files back in a little Indian machine,
you can use the functions

00:56:46.460 --> 00:56:47.760
in nsbyteorder.h.

00:56:47.840 --> 00:56:50.190
They let you do things like--

00:56:50.510 --> 00:56:52.710
Read a big Indian int from this slot.

00:56:52.860 --> 00:56:54.400
And those functions
are actually very fast.

00:56:54.400 --> 00:56:55.880
They're usually one or
two assembly instructions,

00:56:55.940 --> 00:56:57.670
and on the right architecture,
they actually vanish,

00:56:57.670 --> 00:56:59.070
because they're inline functions.

00:56:59.110 --> 00:57:00.570
So very small overhead.

00:57:00.570 --> 00:57:03.150
And of course,
I'd like to encourage you to use

00:57:03.150 --> 00:57:05.160
the appropriate high-level APIs.

00:57:05.250 --> 00:57:07.810
For instance,
if you use an S string to read and

00:57:07.810 --> 00:57:10.920
write Unicode strings to files,
you never have to worry

00:57:10.920 --> 00:57:12.580
about Indian-less issues.

00:57:12.580 --> 00:57:15.380
Similarly, if you use Core Data,
for instance,

00:57:15.380 --> 00:57:17.910
to read and write your documents, again,
you don't care about the issue at all.

00:57:18.190 --> 00:57:20.100
Other universal considerations.

00:57:20.100 --> 00:57:27.330
One thing, I don't know if you know how,
GC4O, on the, to build universal,

00:57:27.330 --> 00:57:29.600
GC4O is your compiler.

00:57:29.600 --> 00:57:34.760
GC4O is a more strict compiler than GC3,
and it will give you some warnings and

00:57:34.760 --> 00:57:36.500
errors in your code if you had some.

00:57:36.520 --> 00:57:39.350
Now, the good news is, of course,
most of the time those warnings

00:57:39.350 --> 00:57:42.000
and errors are actually warnings
and errors in your program,

00:57:42.000 --> 00:57:44.300
so it's a good thing to fix,
but it might actually be

00:57:44.300 --> 00:57:47.020
something you encounter as you do,
you know, move over.

00:57:48.210 --> 00:57:50.740
Direct use of OpenGL, bitmap context,
et cetera.

00:57:50.740 --> 00:57:52.790
If you're manipulating
bitmap formats directly,

00:57:52.790 --> 00:57:54.380
there might be some end use issues.

00:57:54.380 --> 00:57:55.860
We've seen a few examples of these.

00:57:55.860 --> 00:57:59.290
Now, there are many potential bugs and
undefined behaviors that don't

00:57:59.290 --> 00:58:02.610
exhibit themselves on PowerPC,
such as uninitialized variables,

00:58:02.610 --> 00:58:04.200
invalid memory accesses.

00:58:04.200 --> 00:58:07.040
Those might not be a problem in
your program today on the PowerPC,

00:58:07.040 --> 00:58:10.380
but on Intel, due to different, you know,
memory addressing, whatever,

00:58:10.380 --> 00:58:11.610
you might get errors.

00:58:11.620 --> 00:58:13.850
Integer shift left by 32 is undefined.

00:58:13.850 --> 00:58:16.840
It does one thing on PowerPC,
different thing on Intel.

00:58:17.220 --> 00:58:18.880
Integer divide, you saw this yesterday.

00:58:18.880 --> 00:58:22.140
On the PowerPC, you get the zero, which,
you know, well, you know,

00:58:22.140 --> 00:58:24.400
it's the wrong answer,
but it doesn't crash.

00:58:24.400 --> 00:58:27.360
On Intel, you know, it crashes,
so that's, you know,

00:58:27.380 --> 00:58:29.480
dividing or modding by zero is bad.

00:58:29.480 --> 00:58:33.250
For Objective-C specific,
probably the biggest thing in

00:58:33.250 --> 00:58:37.560
Objective-C got you is the fact
that if you send a message to nil,

00:58:37.560 --> 00:58:41.240
as you know, that just works,
and it returns nil or zero.

00:58:41.240 --> 00:58:43.880
But if you send it and the
return value is a floating point

00:58:43.880 --> 00:58:47.290
number or a double or a struct,
on PowerPC, you might,

00:58:47.350 --> 00:58:51.070
you will get zeros when the struct
is smaller for floats and doubles,

00:58:51.100 --> 00:58:54.180
but on Intel,
you will actually get back garbage.

00:58:54.180 --> 00:58:57.140
So if you rely on that behavior,
you know, that's something to clean up,

00:58:57.140 --> 00:58:59.810
and this is, you know,
this is something we've

00:58:59.830 --> 00:59:01.710
also seen in a few programs.

00:59:02.580 --> 00:59:03.640
Okay, so that's it from my part.

00:59:03.710 --> 00:59:07.110
Now I'd like to invite Mike Rossetti
of Intuit Software on stage

00:59:07.110 --> 00:59:09.600
to talk about his experiences.

00:59:11.980 --> 00:59:14.910
Thank you, Ali.

00:59:18.340 --> 00:59:19.300
Thank you.

00:59:19.360 --> 00:59:23.450
I'd like to tell you a story,
a story involving moving a

00:59:23.450 --> 00:59:26.220
phonebook age application.

00:59:26.510 --> 00:59:28.820
Everybody know what the phonebook is,
right?

00:59:28.820 --> 00:59:32.050
The phonebook age application
called QuickBooks Mac into

00:59:32.180 --> 00:59:35.240
the modern Cocoa era of Tiger.

00:59:35.240 --> 00:59:41.680
Before I do so, I have two things I want
to say about that.

00:59:41.740 --> 00:59:47.080
First of all, it's not going to involve
breaking any body parts.

00:59:47.080 --> 00:59:52.510
The second thing is it's a dubious
distinction being invited to explain how

00:59:52.690 --> 01:00:02.070
you can move a tough case application
that's so old into the Cocoa era.

01:00:02.070 --> 01:00:02.070
But a bit of a

01:00:02.600 --> 01:01:21.400
[Transcript missing]

01:01:23.800 --> 01:01:26.660
All right, so how did we do it?

01:01:26.750 --> 01:01:29.700
First thing we had to do was
get it buildable and running.

01:01:29.700 --> 01:01:33.300
And the way we did that was by
using MetroWorks Code Warrior.

01:01:33.300 --> 01:01:37.090
We made it carbonized by
using Power Plant mostly.

01:01:37.100 --> 01:01:39.020
We aquified the user interface.

01:01:39.020 --> 01:01:41.470
We did a little bit
of refactoring mostly.

01:01:41.470 --> 01:01:43.080
We just groomed the code.

01:01:43.080 --> 01:01:45.240
We introduced
Core Foundation where we could.

01:01:45.250 --> 01:01:47.160
That was the first year.

01:01:47.480 --> 01:01:50.870
The second year,
the really important thing that we

01:01:50.870 --> 01:01:53.260
did was introduce Carbon Events.

01:01:53.260 --> 01:01:54.880
Made it pure Carbon Events.

01:01:54.880 --> 01:01:56.810
We added a few new features.

01:01:57.060 --> 01:02:00.100
We started using C++ in
the standard library.

01:02:00.100 --> 01:02:06.130
And yes, C++ works very,
very well with Cocoa.

01:02:11.300 --> 01:02:17.510
Last year, we took advantage of Apple's
Carbon and Cocoa technology because

01:02:17.510 --> 01:02:21.240
we had a lot of Carbon windows,
a lot of Carbon technology in there,

01:02:21.240 --> 01:02:25.190
and we couldn't just throw
it all out and rework it,

01:02:25.320 --> 01:02:27.920
especially because of the
multiple levels of callback.

01:02:28.020 --> 01:02:33.710
So we used the Carbon and
Cocoa technology,

01:02:33.710 --> 01:02:35.640
helping Apple debug it in the process,
by the way.

01:02:35.640 --> 01:02:35.640
And

01:02:36.340 --> 01:02:40.020
moved over to Xcode,
moved over to Interface Builder,

01:02:40.020 --> 01:02:45.570
and adopted several other enabling
and bridging technologies.

01:02:45.850 --> 01:02:51.490
It was the next year that
we found ourselves able to

01:02:51.800 --> 01:03:31.000
[Transcript missing]

01:03:31.440 --> 01:03:34.050
and next year we're pretty
optimistic about being able

01:03:34.050 --> 01:03:36.470
to move over to core data.

01:03:39.000 --> 01:03:40.690
Okay, so what's the bottom line?

01:03:40.690 --> 01:03:44.160
As you old-timer Mac appers
out there will understand,

01:03:44.160 --> 01:03:46.500
it's the framework that
makes the difference.

01:03:46.540 --> 01:03:50.740
It's the Cocoa framework that's
made this much easier for us to do.

01:03:50.740 --> 01:03:54.000
The environments play nicely together.

01:03:54.000 --> 01:03:56.120
It's fun to use this stuff.

01:03:56.120 --> 01:04:00.460
And once you've embraced
the Cocoa framework,

01:04:00.630 --> 01:04:04.740
you're able to move much faster together.

01:04:05.320 --> 01:04:09.230
Now, what I'd like to do is ask the
QuickBooks team to stand up.

01:04:09.630 --> 01:04:14.860
Right down here, Lucienne, Brooks Bell,
Steven Friedrich, there's Keith Ray.

01:04:14.860 --> 01:04:19.160
You're welcome to talk to any one of
them and get details about what the

01:04:19.160 --> 01:04:24.000
challenges have been that we've had
to go through as we've moved to Cocoa.

01:04:24.020 --> 01:04:28.160
And the moral of the story is,
it's a lot closer than you may expect,

01:04:28.160 --> 01:04:30.320
and the benefits are terrific.

01:04:30.320 --> 01:04:34.470
I'd like to thank the
Apple Engineering Group for not

01:04:34.650 --> 01:04:35.280
only making this a great experience,
but also for making it a

01:04:35.280 --> 01:04:35.280
great experience for us.

01:04:35.280 --> 01:04:38.030
Not just making it fairly
straightforward to do,

01:04:38.140 --> 01:04:39.880
but making it desirable to do.

01:04:39.880 --> 01:04:41.500
It's fun to do this stuff.

01:04:42.260 --> 01:04:43.140
Matthew?

01:04:43.140 --> 01:04:44.490
Matthew?

01:04:52.610 --> 01:04:53.620
Thank you so much, Mike.

01:04:53.620 --> 01:04:57.780
So there are other resources for
you to take a look at this week.

01:04:57.900 --> 01:05:01.640
There's the WWDC portal that's
live this week with a lot of sample

01:05:01.710 --> 01:05:03.480
code and other documentation.

01:05:03.480 --> 01:05:07.520
I am the contact for
Cocoa and developer relations.

01:05:07.600 --> 01:05:11.890
Feel free to send me emails
with the feedback and features

01:05:11.890 --> 01:05:13.980
you want to see in Cocoa.
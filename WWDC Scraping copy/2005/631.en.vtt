WEBVTT

00:00:00.430 --> 00:00:03.630
Okay, welcome to 6:31,
last session of the day.

00:00:03.640 --> 00:00:08.200
My name is Matt Drance,
and I work in DTS, supporting Java,

00:00:08.200 --> 00:00:09.300
among other things.

00:00:09.570 --> 00:00:14.290
So I'm here to talk to you about the JNI.

00:00:14.300 --> 00:00:15.190
What is the JNI?

00:00:15.200 --> 00:00:18.490
I hope everybody here knows, but,
you know, in case you don't,

00:00:18.510 --> 00:00:20.300
it's the Java Native Interface.

00:00:20.300 --> 00:00:23.270
It's a mechanism that's
been around since Java 1.0,

00:00:23.300 --> 00:00:26.280
and it lets you integrate pure
Java code with native code.

00:00:26.310 --> 00:00:30.300
In the case of Mac OS X, that means C,
C++, Objective-C.

00:00:30.300 --> 00:00:32.300
It's got a number of uses.

00:00:32.300 --> 00:00:35.230
In the older days,
it was really heavily used

00:00:35.300 --> 00:00:38.300
for incrementally porting a
native code base over to Java.

00:00:38.300 --> 00:00:42.350
So you want to do it in steps,
keep some of your native code in place,

00:00:42.360 --> 00:00:45.300
and just hook it into the Java code
that you've written so far.

00:00:45.320 --> 00:00:49.550
It's useful still today for
leveraging some legacy or open-source

00:00:49.550 --> 00:00:52.300
libraries that you might run
into if you have a pure Java app,

00:00:52.300 --> 00:00:56.300
and you want to make use of something
that happens to not be written in Java.

00:00:56.300 --> 00:01:00.300
It's also useful for the other
direction of the first point,

00:01:00.300 --> 00:01:02.330
which is if you have
a Java code base that,

00:01:02.420 --> 00:01:04.410
for whatever reason,
you might want to port to

00:01:04.470 --> 00:01:07.300
Cocoa or Core Foundation or
some other native framework,

00:01:07.300 --> 00:01:08.300
you can do that incrementally.

00:01:08.300 --> 00:01:12.960
And it also allows you to provide some
platform-specific features that might be

00:01:12.960 --> 00:01:15.300
absent from the Java 2 Standard Edition.

00:01:15.300 --> 00:01:19.360
Java can't do everything, and, you know,
the JNI can come in to help

00:01:19.360 --> 00:01:21.290
you bridge some of those gaps.

00:01:21.300 --> 00:01:23.240
So what are we going to talk about today?

00:01:23.390 --> 00:01:26.300
We're going to talk about building
a JNI application in Excel.

00:01:26.420 --> 00:01:30.300
We have templates and samples that,
you know, already do this for you,

00:01:30.300 --> 00:01:33.300
but they can kind of be a little
confusing and a little overwhelming,

00:01:33.310 --> 00:01:36.560
so I thought we'd walk through that
and get used to some of the targets

00:01:36.560 --> 00:01:38.130
in Xcode and things like that.

00:01:38.300 --> 00:01:42.980
And then we'll talk about -- most of this
talk is going to be about Java native

00:01:42.980 --> 00:01:47.290
graphical user interface integration,
mixing Java and native components.

00:01:47.310 --> 00:01:52.300
We'll talk about Cocoa Component,
which is one of our extended

00:01:52.300 --> 00:01:56.300
EAWT APIs that lets you go
ahead and embed an NSVP code.

00:01:56.300 --> 00:01:58.300
We'll talk about the Java container.

00:01:58.300 --> 00:01:59.390
We'll talk about the
AWT native interface,

00:01:59.490 --> 00:02:02.080
sometimes called JWT for short.

00:02:02.380 --> 00:02:05.230
And we'll also talk about the threading
implications that come into play

00:02:05.350 --> 00:02:08.300
when you start to play these games.

00:02:08.300 --> 00:02:10.710
All through the talk,
I'll talk about some of the simple

00:02:10.710 --> 00:02:13.990
things that you need to keep in
mind when you're sharing data

00:02:13.990 --> 00:02:15.300
between the Java and native side.

00:02:15.370 --> 00:02:18.510
And we'll briefly touch on
invocation of a virtual machine

00:02:18.510 --> 00:02:20.000
from C and Objective-C apps.

00:02:20.300 --> 00:02:21.630
This is a loaded talk.

00:02:21.630 --> 00:02:23.300
We have a lot to talk about.

00:02:23.300 --> 00:02:24.230
I'm going to try to do it before 5:00.

00:02:24.330 --> 00:02:26.300
So we're going to move kind of fast.

00:02:26.300 --> 00:02:31.250
So let's start with building
JNI projects with Xcode.

00:02:31.440 --> 00:02:33.290
Why Xcode?

00:02:33.340 --> 00:02:35.300
Well, aside from the fact that
this is an Apple conference,

00:02:35.300 --> 00:02:40.590
Xcode has a pretty cool advantage
in terms of JNI development in that

00:02:40.590 --> 00:02:44.050
it's the only IDE that can give
you a single project that will go

00:02:44.050 --> 00:02:48.300
ahead and build your Java code,
your native code, link everything,

00:02:48.300 --> 00:02:51.300
bundle it all together into a
single double-clickable application

00:02:51.300 --> 00:02:54.290
with a single project with
the click of one build button.

00:02:54.400 --> 00:02:56.300
And we're going to show
you how to do that.

00:02:57.330 --> 00:03:00.000
So what goes into creating
a JNI project in Xcode?

00:03:00.000 --> 00:03:02.800
Well, obviously,
you have your Java application,

00:03:02.920 --> 00:03:05.300
your double-clickable,
just like a normal Swing

00:03:05.330 --> 00:03:06.860
or AWT app on Mac OS X.

00:03:06.860 --> 00:03:09.560
You need to create a target to
generate some native headers

00:03:09.560 --> 00:03:11.870
using some command-line JDK tools.

00:03:11.880 --> 00:03:14.120
Then you need to actually create
your native implementation

00:03:14.120 --> 00:03:17.490
using a native target in Xcode,
set up dependencies between

00:03:17.490 --> 00:03:21.540
all of these different targets,
and we go ahead and copy these files

00:03:21.580 --> 00:03:25.390
that are the products of these individual
targets into your final bundled app.

00:03:26.280 --> 00:03:28.700
So let's get hands-on right away.

00:03:28.700 --> 00:03:30.400
Can we go to demo two, please?

00:03:32.720 --> 00:03:37.170
How many of you have downloaded
the supporting DMGs for the

00:03:37.260 --> 00:03:42.100
sessions and had a look at the
projects that came with this talk?

00:03:42.390 --> 00:03:43.520
Okay.

00:03:43.520 --> 00:03:45.380
So those of you who have,
go ahead and feel free

00:03:45.380 --> 00:03:46.770
to work along with me.

00:03:46.800 --> 00:03:50.830
I had initially planned to really
do this from scratch and go from the

00:03:50.830 --> 00:03:55.620
beginning and walk you through it,
but something happened on Monday that

00:03:55.620 --> 00:03:58.470
requires I talk about some extra things.

00:03:58.640 --> 00:04:01.860
So we're going to cut
this one a little short.

00:04:01.860 --> 00:04:04.210
We're just I'm just going
to go ahead and open up

00:04:23.050 --> 00:04:23.050
I'm in Xcode 2.1 here.

00:04:23.050 --> 00:04:23.050
Those of you who are working
in 2.1 may have noticed a

00:04:23.050 --> 00:04:23.050
couple things that changed,
and we'll get to that in a second.

00:04:23.050 --> 00:04:23.050
So I'll just start by running this first.

00:04:23.050 --> 00:04:23.050
And...

00:04:24.250 --> 00:04:26.990
We're going to go ahead and create--
we're going to go ahead and build this.

00:04:27.020 --> 00:04:28.060
And it's going to fail.

00:04:28.220 --> 00:04:33.960
And that's because Xcode 2.1 changed
something in terms of building.

00:04:33.960 --> 00:04:37.650
And so those of you who may have
tried to do this in Xcode 2.1,

00:04:37.660 --> 00:04:38.640
this is a big difference.

00:04:38.640 --> 00:04:41.610
Those of you who have
worked in Xcode in the past,

00:04:41.610 --> 00:04:44.560
the build products have been
broken up into development and

00:04:44.700 --> 00:04:46.400
deployment subdirectories now.

00:04:46.400 --> 00:04:49.090
And we're doing a couple of
references into the build directory.

00:04:49.220 --> 00:04:51.620
And so we're going to have to
change that along the line.

00:04:51.670 --> 00:04:53.360
But let's just start from the beginning.

00:04:53.380 --> 00:04:57.940
And I'll show you what this
project does basically.

00:04:57.940 --> 00:04:59.860
So here's our JNI project.

00:04:59.860 --> 00:05:02.300
And we get through the legalese.

00:05:02.300 --> 00:05:05.400
And we basically want to go
check out the paint method.

00:05:07.720 --> 00:05:11.670
So in the original,
this is basically a straight

00:05:12.230 --> 00:05:16.220
modification of the standard Java swing
application template in Xcode.

00:05:16.220 --> 00:05:18.560
Now, normally,
the paint method goes ahead

00:05:18.560 --> 00:05:21.080
and paints something like
swing application or hello,

00:05:21.080 --> 00:05:21.520
world.

00:05:21.520 --> 00:05:22.750
I can't exactly remember.

00:05:22.990 --> 00:05:26.070
Instead of that, we have this method
called get my full name,

00:05:26.070 --> 00:05:30.050
and we declare this as a native
method that returns a string.

00:05:30.120 --> 00:05:35.010
So this is the first step to hooking
into native services using the JNI.

00:05:35.300 --> 00:05:39.420
So we declare our native method,
and now we're going to have

00:05:39.520 --> 00:05:43.190
to-- in order to write a native
library to implement that method,

00:05:43.250 --> 00:05:47.150
we're going to have to generate some
native headers based on these classes.

00:05:47.280 --> 00:05:49.270
So normally,
I would go up into the project

00:05:49.450 --> 00:05:53.100
menu and create a new target.

00:05:53.900 --> 00:06:27.800
[Transcript missing]

00:06:28.400 --> 00:07:00.800
[Transcript missing]

00:07:01.100 --> 00:07:10.800
[Transcript missing]

00:07:11.630 --> 00:07:15.650
So, the fruit of this shell script phase,
which is going to be a .h file,

00:07:15.650 --> 00:07:18.400
I've added that to the
project just for reference.

00:07:18.630 --> 00:07:21.160
And right now, at the time of,
at press time,

00:07:21.160 --> 00:07:24.600
this was referencing something
from the build directory.

00:07:24.600 --> 00:07:30.780
And we need to actually go ahead and
go into the development subdirectory.

00:07:30.860 --> 00:07:35.790
So that's, if you were having problems
building this in Xcode 2.1,

00:07:35.790 --> 00:07:35.790
that was the problem.

00:07:35.790 --> 00:07:35.790
So go ahead and change that.

00:07:36.400 --> 00:07:40.250
And now let's have a look at this
header file that got generated.

00:07:40.250 --> 00:07:41.650
There we go.

00:07:41.890 --> 00:07:43.530
So there's a lot of noise in here.

00:07:43.600 --> 00:07:46.800
A lot of this stuff,
this is all generated by the Java H tool.

00:07:46.800 --> 00:07:48.900
And now at the bottom,

00:07:49.870 --> 00:07:53.840
Here is our function declaration
for the native method.

00:07:53.970 --> 00:07:56.000
So you can see it's
called myFirstJNIProject,

00:07:56.090 --> 00:07:58.060
which is the class name,
and then getMyFullName.

00:07:58.060 --> 00:08:01.480
And it returns a J string,
which is a Java string.

00:08:01.520 --> 00:08:05.040
And it takes in a JNIEnv pointer,
which is the pointer to the

00:08:05.060 --> 00:08:07.040
Java environment above us.

00:08:07.040 --> 00:08:10.320
And that's going to allow us to make
JNI function calls to do everything

00:08:10.320 --> 00:08:12.040
we need to communicate back and forth.

00:08:12.050 --> 00:08:16.680
And all of the JNI functions that
you create have either a J object or

00:08:16.680 --> 00:08:18.550
a J class passed in as a parameter.

00:08:18.560 --> 00:08:19.730
And that is the caller.

00:08:19.870 --> 00:08:26.200
So this J object is a pointer
representing the Java object that

00:08:26.200 --> 00:08:27.920
made the JNI call down into C.

00:08:27.920 --> 00:08:32.260
In the case of a static method call,
this would be a J class

00:08:32.360 --> 00:08:34.210
reference instead.

00:08:34.920 --> 00:08:37.440
So we've got our header file,
so now we want to go ahead and

00:08:37.440 --> 00:08:38.710
look at the native library.

00:08:38.780 --> 00:08:40.850
And this is actually
very straightforward.

00:08:40.850 --> 00:08:46.550
You can see I just copied and pasted
the signature from the header file.

00:08:46.550 --> 00:08:49.370
And I'm not going to go
into the address book stuff,

00:08:49.520 --> 00:08:52.640
but basically we go ahead and
we get -- we call AB get me,

00:08:52.640 --> 00:08:54.950
which is the currently logged in user.

00:08:54.950 --> 00:09:00.460
And we go ahead and we concatenate
those strings using core foundation,

00:09:00.460 --> 00:09:05.430
and then we go ahead and we create a
Java string that can be returned back.

00:09:05.560 --> 00:09:07.520
So this is the money right here.

00:09:07.520 --> 00:09:10.860
We get our core foundation string,
we get the characters out of it,

00:09:10.860 --> 00:09:14.640
and we create a Java string,
return that back up.

00:09:14.640 --> 00:09:23.800
And now if I go back to the JNI project,
which is the top level thing,

00:09:23.830 --> 00:09:28.760
I should go ahead and build and run.

00:09:28.760 --> 00:09:29.960
Give it a couple seconds.

00:09:29.960 --> 00:09:31.260
There it goes.

00:09:31.300 --> 00:09:31.300
Okay.

00:09:43.170 --> 00:09:43.190
Come on now.

00:09:43.190 --> 00:09:43.190
Okay.

00:09:43.190 --> 00:09:43.190
So now instead of swing example,
it says WWDC 2005, which is...

00:09:46.750 --> 00:09:49.060
which is the name of the
currently logged in user.

00:09:49.210 --> 00:09:52.120
So obviously,
this is not incredibly sexy or special.

00:09:52.410 --> 00:09:55.510
But it's a very simple example
of what you need to do to go down

00:09:55.520 --> 00:10:00.550
into JNI and talk to a native API,
return information back up.

00:10:00.700 --> 00:10:04.200
So I had mentioned that
something happened on Monday.

00:10:04.230 --> 00:10:07.560
And I was as surprised
as you to hear about it,

00:10:07.580 --> 00:10:08.640
believe it or not.

00:10:08.760 --> 00:10:12.000
So we've got some additional
things that we need to talk about,

00:10:12.010 --> 00:10:15.780
namely,
this whole universal binary thing.

00:10:16.000 --> 00:10:21.100
So in order to create a universal binary,
which is something you will need

00:10:21.100 --> 00:10:24.890
to do for your JNI libraries,
if you have a Java application

00:10:25.190 --> 00:10:28.160
that is brought up,
Java obviously is going to be

00:10:28.160 --> 00:10:30.790
native on either hardware platform.

00:10:30.910 --> 00:10:34.240
So it's going to be your responsibility
as well to make sure the JNI libraries

00:10:34.620 --> 00:10:36.840
that Java calls are native as well.

00:10:36.900 --> 00:10:39.450
Because Java is not going
to come up in Rosetta.

00:10:39.530 --> 00:10:41.530
And by the time the
application is launched,

00:10:41.680 --> 00:10:43.960
by the time your
JNI libraries are loaded,

00:10:44.020 --> 00:10:47.090
the option to load Rosetta
has already passed us by.

00:10:47.240 --> 00:10:50.540
So you need to make sure that your
JNI libraries are going to be universal.

00:10:50.740 --> 00:10:53.790
So in order to do that,
we're going to get the information

00:10:53.880 --> 00:10:55.860
on the current project.

00:10:55.880 --> 00:10:59.100
And right now,
there's a cross-development option here.

00:10:59.200 --> 00:11:04.220
And as you can see down here,
there's a Mac OS X 10.4 universal option.

00:11:04.240 --> 00:11:05.760
And it says,
are you sure you want to change?

00:11:05.960 --> 00:11:09.140
Yes, I do want to change the directory.

00:11:09.260 --> 00:11:14.690
So now,
we go over to our JNI lib target here.

00:11:15.070 --> 00:11:17.240
I'm going to go over to the Build tab.

00:11:17.260 --> 00:11:22.510
And there's an architectures item here,
and that needs to be set to Native Arc,

00:11:22.680 --> 00:11:23.990
as you can see here.

00:11:24.100 --> 00:11:27.400
And it really should be that simple.

00:11:27.520 --> 00:11:32.030
So let's go ahead and build this and make
sure we indeed did do the right thing,

00:11:32.030 --> 00:11:34.800
because I'm as new to
this as you guys are.

00:11:35.030 --> 00:11:39.890
So now I want to go
to my build directory.

00:11:40.950 --> 00:11:44.190
Let's go ahead and use the file utility.

00:11:44.190 --> 00:11:46.530
Have a look at this JNI lib.

00:11:48.100 --> 00:11:50.080
And no, I didn't do it correctly.

00:11:50.080 --> 00:11:54.050
Help me out here guys, what am I missing?

00:12:02.320 --> 00:12:04.200
And no, I didn't do it correctly.

00:12:04.200 --> 00:12:07.760
Help me out here guys, what am I missing?

00:12:11.410 --> 00:12:12.300
Build succeeded.

00:12:12.300 --> 00:12:13.300
Now let's just do it again.

00:12:13.300 --> 00:12:15.020
Ah, now we have two files.

00:12:15.090 --> 00:12:16.950
Now we have two lines here.

00:12:16.970 --> 00:12:22.530
So first one is for Architecture PowerPC,
and the second one is for i386.

00:12:22.560 --> 00:12:28.960
So it really is just a matter of checking
a few boxes in Xcode and rebuilding,

00:12:29.030 --> 00:12:35.130
and you'll be ready for these
transitions that we were talking about.

00:12:35.130 --> 00:12:35.170
So I think I've beaten this to death,
so let's go back to the slides.

00:12:37.140 --> 00:12:40.050
Okay, so running through real
quick what we just did.

00:12:40.130 --> 00:12:43.240
Create a Java application target just
like you normally would in Xcode.

00:12:43.290 --> 00:12:44.730
Now, there's a number of ways to do this.

00:12:44.770 --> 00:12:46.440
Some of our examples do
it a little differently.

00:12:46.440 --> 00:12:49.020
Our templates in Xcode do
it a little differently.

00:12:49.020 --> 00:12:51.930
This is an alternate way to do
it using all native targets,

00:12:52.090 --> 00:12:55.820
which is going to be important if you're
going to build a universal binary.

00:12:55.840 --> 00:13:00.120
If you have older legacy targets that
were made with earlier templates,

00:13:00.120 --> 00:13:03.480
you're going to need to upgrade
those to native targets,

00:13:03.480 --> 00:13:07.100
and then that will allow you
to build a universal binary.

00:13:07.980 --> 00:13:10.750
We create our native header target,
which is really just a shell

00:13:10.890 --> 00:13:14.300
script phase that calls Java H to
get the signatures we need.

00:13:14.360 --> 00:13:17.800
Then we create the native library using
the header that was just generated.

00:13:17.800 --> 00:13:21.850
We copy and paste that stuff,
implement the function.

00:13:23.360 --> 00:13:26.220
And the other thing that you see here,
this is in the build

00:13:26.220 --> 00:13:27.860
settings of the JNI library.

00:13:27.860 --> 00:13:28.980
I skipped over this.

00:13:29.410 --> 00:13:32.100
The product name,
which is going to be the

00:13:32.100 --> 00:13:35.690
central part of the file name,
needs to be the same as your

00:13:35.690 --> 00:13:37.670
call to system load library.

00:13:37.720 --> 00:13:41.140
System.load library is what you
do in the static initializer to

00:13:41.180 --> 00:13:43.190
go ahead and load the JNI library.

00:13:43.200 --> 00:13:47.110
So the name that you see here in
product name needs to match the string

00:13:47.190 --> 00:13:49.600
that you pass to system.load library.

00:13:49.600 --> 00:13:54.200
And then you wrap the file in a
lib prefix and a JNI lib suffix.

00:13:54.200 --> 00:14:00.630
So in this case, the file name would
be lib JNI lib.jnilib.

00:14:02.030 --> 00:14:04.850
And target dependencies.

00:14:05.080 --> 00:14:07.920
In the case of the
project that we had there,

00:14:08.040 --> 00:14:11.780
the native target obviously
had to depend on the headers.

00:14:11.890 --> 00:14:15.720
We needed the headers to get
generated in order to use them.

00:14:15.960 --> 00:14:34.390
And the application target,
which is going to be the

00:14:34.390 --> 00:14:34.390
final double-clickable bundle,
also depends on the native library.

00:14:34.390 --> 00:14:34.390
And then that's going to allow us
to build the entire thing in one

00:14:34.390 --> 00:14:34.390
piece once the JNI lib is done.

00:14:34.390 --> 00:14:34.390
Finally,
we need a copy files build phase,

00:14:34.390 --> 00:14:34.390
which is going to

00:14:35.660 --> 00:14:37.990
Move the JNI library
right into the bundle.

00:14:37.990 --> 00:14:42.450
And actually, can we go back to the --
to Demo 2 for a second,

00:14:42.450 --> 00:14:43.270
please?

00:14:44.140 --> 00:14:47.070
I just want to show you
these dependencies in person.

00:14:47.160 --> 00:14:51.230
So the first thing we're doing
is creating the Java headers,

00:14:51.360 --> 00:14:53.240
doing the build script
with the Java headers.

00:14:53.320 --> 00:14:55.470
And here is the information
for our JNI library.

00:14:55.500 --> 00:15:00.240
And you'll see here there's a
dependency to the Java headers target.

00:15:00.250 --> 00:15:03.140
And I'll just remove this real quick
and show you what it means to add one.

00:15:03.160 --> 00:15:05.820
You basically just
click this plus button,

00:15:06.160 --> 00:15:07.030
click Add Target.

00:15:07.100 --> 00:15:11.360
And what this does is it basically
just runs through the list.

00:15:11.360 --> 00:15:14.240
And whichever target you've got
selected up here is the active one.

00:15:14.380 --> 00:15:15.920
It goes and runs through
the dependencies.

00:15:15.920 --> 00:15:19.220
And it says,
if I try to build my first JNI project--

00:15:19.300 --> 00:15:20.440
and let's have a look at that one.

00:15:20.440 --> 00:15:23.400
This is the main one.

00:15:23.420 --> 00:15:24.600
This depends on the library.

00:15:24.710 --> 00:15:26.470
So when we try to build
my first JNI project,

00:15:26.470 --> 00:15:28.940
it's going to say,
has the JNI lib been built?

00:15:28.950 --> 00:15:29.300
No.

00:15:29.370 --> 00:15:31.570
Then we go ahead and build
the JNI library first.

00:15:31.650 --> 00:15:34.380
It's going to go to the
JNI library and say,

00:15:34.380 --> 00:15:36.170
has the headers target been filled?

00:15:36.350 --> 00:15:36.660
No.

00:15:36.870 --> 00:15:38.780
Then we go ahead and build
the headers target first.

00:15:38.980 --> 00:15:41.460
So just make sure that
everything is in the right place.

00:15:41.490 --> 00:15:44.860
And then at the very end,
we have that copy files build phase.

00:15:44.940 --> 00:15:49.180
And we're going to move it
into the Java resources,

00:15:49.180 --> 00:15:49.180
which

00:15:50.840 --> 00:15:52.670
Resources, Java.

00:15:52.670 --> 00:15:58.170
Contents, Resources,
Java inside the application bundle.

00:15:58.370 --> 00:16:01.910
And luckily,
all you have to do is select the

00:16:01.910 --> 00:16:07.300
Java Resources dropdown and just
drag your JNI lib here from the

00:16:07.310 --> 00:16:10.170
products over into copy files.

00:16:10.250 --> 00:16:14.530
And that will do that for
you right before -- right at

00:16:14.530 --> 00:16:14.910
the end of the build phase.

00:16:14.910 --> 00:16:14.910
Okay.

00:16:14.910 --> 00:16:14.910
Back to slides, please.

00:16:16.880 --> 00:16:19.500
So one of the things we did in the
previous example was we went and

00:16:19.500 --> 00:16:22.930
we got a string from address book,
which was a CoreFoundation string,

00:16:22.930 --> 00:16:24.300
and we returned it to Java.

00:16:24.400 --> 00:16:27.260
If those of you who may be
familiar with Live Connect or,

00:16:27.260 --> 00:16:29.850
you know, the web scripting
protocol in Objective-C,

00:16:29.850 --> 00:16:32.100
unfortunately, it's not quite that easy.

00:16:32.100 --> 00:16:38.110
You do have to do a little work to
pass your strings back and forth.

00:16:38.110 --> 00:16:38.110
Thank you for doing that.

00:16:38.110 --> 00:16:38.110
It's a lot better.

00:16:38.200 --> 00:19:28.400
[Transcript missing]

00:19:30.000 --> 00:20:37.800
[Transcript missing]

00:20:37.860 --> 00:20:39.720
Okay,
so now let's talk about the really cool

00:20:39.790 --> 00:20:44.530
stuff that I can't wait to show you guys,
which is the Java GUI integration.

00:20:44.600 --> 00:20:48.030
And first we're going to
talk about Coho Component.

00:20:48.040 --> 00:20:50.890
And Coho Component is something
that's been around since

00:20:50.890 --> 00:20:53.580
our first JDK 1.4 release.

00:20:53.660 --> 00:20:56.510
It's a pure Java class, sort of.

00:20:56.540 --> 00:21:02.280
You extend com.apple, E-A-W-T,
Coho Component.

00:21:02.280 --> 00:21:03.080
It's an Apple API.

00:21:03.080 --> 00:21:06.940
You basically extend this class,
and this is going to allow you to embed

00:21:06.940 --> 00:21:13.220
any Coho NS view that's available to you
on Mac OS X inside a Java AWT container.

00:21:13.220 --> 00:21:17.600
You have to write your native
implementation underneath,

00:21:17.600 --> 00:21:22.580
but this basically allows you to drop
it right into the component hierarchy.

00:21:22.580 --> 00:21:25.700
You can transmit events right through,
or you can stop them using

00:21:25.710 --> 00:21:29.160
standard Java event listeners,
and it's a really lightweight way of

00:21:29.160 --> 00:21:31.790
integrating Java and native components.

00:21:31.800 --> 00:21:36.160
So there are two key things to actually,
doing a Coho Component

00:21:36.160 --> 00:21:37.670
extension or implementation.

00:21:37.890 --> 00:21:41.220
You need to implement first
the create NS view long method,

00:21:41.220 --> 00:21:45.280
which is, this is going to be your hook
between the Java and native world.

00:21:45.340 --> 00:21:47.870
This is where you're going to go ahead,
it's basically going to be

00:21:47.890 --> 00:21:50.940
declared as a native method,
and you're going to create whatever

00:21:50.940 --> 00:21:52.610
NS view you're hoping to embed.

00:21:52.690 --> 00:21:54.870
And when you get that pointer,
that NS view star,

00:21:54.880 --> 00:22:00.420
you return that up as a 64-bit Java long,
or a J long in the JNI world.

00:22:00.440 --> 00:22:04.080
There's also a 32-bit method
called create NS view,

00:22:04.080 --> 00:22:05.010
which returns a J long.

00:22:05.040 --> 00:22:07.020
So if you're using a
J int instead of a J long,

00:22:07.020 --> 00:22:11.020
we've deprecated that as of Tiger,
because the Sun recommendation

00:22:11.020 --> 00:22:13.310
has always been,
no matter what kind of

00:22:13.370 --> 00:22:16.640
system you're actually on,
the recommendation has always been to

00:22:16.660 --> 00:22:19.410
treat your native pointers as J longs.

00:22:19.460 --> 00:22:23.000
And if you need to,
if you're on a 32-bit system,

00:22:23.010 --> 00:22:25.890
you can safely get that
long and cast it to an int,

00:22:25.940 --> 00:22:29.060
and the correct bits will
be chopped off and saved,

00:22:29.120 --> 00:22:31.080
and you will have a legitimate pointer.

00:22:31.080 --> 00:22:33.080
The other one is send message.

00:22:33.330 --> 00:22:36.980
And this is basically a configuration
that you can use to send messages.

00:22:36.980 --> 00:22:40.980
So if you're using a convenience API,
it lets you send really lightweight,

00:22:40.980 --> 00:22:44.740
asynchronous requests to the native side,
rather than polluting all of your source

00:22:44.740 --> 00:22:47.000
code with a bunch of native methods.

00:22:47.000 --> 00:22:49.000
This is a mechanism
that's already in place,

00:22:49.000 --> 00:22:51.830
and all you have to do is just
send different message identifiers

00:22:51.850 --> 00:22:55.470
down and just have a single native
method implementation that maybe

00:22:55.470 --> 00:22:59.000
switches on that identifier,
and then it tells--and then that will

00:22:59.000 --> 00:23:01.000
tell you which task you need to use.

00:23:01.000 --> 00:23:02.970
It's an easy way to do
non-blocking requests.

00:23:03.040 --> 00:23:04.940
The key word is non-blocking.

00:23:04.940 --> 00:23:06.940
And I'm gonna show you how to do that.

00:23:06.940 --> 00:23:08.940
And I'm gonna show you how to do that.

00:23:09.040 --> 00:23:11.940
So let's see what's cool
about that in a little bit.

00:23:11.940 --> 00:23:17.130
So our first demo here is going
to be something called the

00:23:17.140 --> 00:23:20.960
Quartz Composer Cocoa component,
QC Cocoa component.

00:23:20.960 --> 00:23:24.960
It uses the Quartz Composer QC view,
which is a new feature in Tiger.

00:23:24.960 --> 00:23:27.960
And this is basically gonna
let us display Quartz Composer

00:23:28.030 --> 00:23:29.960
compositions in a J frame.

00:23:29.960 --> 00:23:31.960
You already saw that--those of
you who went to the Java overview,

00:23:31.970 --> 00:23:33.940
you saw Scott demo this.

00:23:33.940 --> 00:23:34.900
We're gonna show you
how it actually works.

00:23:34.900 --> 00:23:36.900
So we're gonna go to Java class,
implement the native side,

00:23:36.900 --> 00:23:39.890
and just move along
as you normally would.

00:23:39.940 --> 00:23:42.500
So can we go to demo two, please?

00:23:46.800 --> 00:23:50.160
Okay.

00:23:50.420 --> 00:23:53.450
How many of you were at the
overview and saw this demo?

00:23:53.460 --> 00:23:57.370
About half of you.

00:23:57.370 --> 00:23:57.420
Okay.

00:23:57.420 --> 00:23:57.420
So let's --

00:23:58.680 --> 00:24:02.280
For those who didn't see it,
I will go ahead and demo

00:24:02.280 --> 00:24:04.350
the built product first.

00:24:17.000 --> 00:24:21.960
So up comes our project.

00:24:21.960 --> 00:24:24.920
And by the way, for those of you who are
actually are going around --

00:24:24.920 --> 00:24:28.140
going -- working along with me,
that problem I mentioned

00:24:28.140 --> 00:24:32.700
about the development -- the
development build and -- I'm sorry,

00:24:32.700 --> 00:24:39.270
the development directory for the header,
that's going to happen in every project.

00:24:39.280 --> 00:24:43.580
So we're going to have to go
ahead and do that every time.

00:24:43.580 --> 00:24:43.580
So let me just start with the Java file.

00:24:44.990 --> 00:24:49.360
And like I said in the slides,
the key things here are

00:24:49.360 --> 00:24:53.810
the CreateNSVLong method,
which is going to go down across

00:24:53.810 --> 00:24:57.740
the JNI and create our pointer,
return it back as a Java long,

00:24:57.810 --> 00:25:03.200
and here's our CreateNSV,
which just calls CreateNSVLong,

00:25:03.200 --> 00:25:03.200
cast it to an int.

00:25:04.480 --> 00:25:07.530
And we've declared a few constants here,
and these are going to be

00:25:07.530 --> 00:25:10.400
used for the Send Message API,
which I had mentioned earlier.

00:25:10.400 --> 00:25:13.040
And this is just going to be a
real easy way to go ahead and

00:25:13.210 --> 00:25:15.550
tell the underlying NSView,
do something.

00:25:15.560 --> 00:25:21.130
And then the NSView is going to go ahead
and switch based on these constants,

00:25:21.140 --> 00:25:26.320
rather than have two JNI methods,
two native methods I had to declare,

00:25:26.320 --> 00:25:30.760
more things in the header file,
more implementations to copy and paste

00:25:30.760 --> 00:25:30.760
from the header file to the C file.

00:25:32.580 --> 00:25:36.490
And notice that the sendMessage
method actually isn't defined here.

00:25:36.630 --> 00:25:39.500
That's because it's
part of Cocoa component.

00:25:39.500 --> 00:25:47.370
All the implementation stuff
that does that message send,

00:25:47.370 --> 00:25:48.110
that message, that request transmission,
it's already done for you.

00:25:48.110 --> 00:25:48.110
So you just need to call sendMessage.

00:25:50.020 --> 00:25:55.970
So just like previously,
we have our Java headers target,

00:25:55.970 --> 00:25:55.970
and I think...

00:25:56.510 --> 00:26:00.310
There's another problem here,
which is that a lot of these shell script

00:26:00.310 --> 00:26:03.640
variables changed between 2.0 and 2.1.

00:26:03.920 --> 00:26:08.940
So, those of you who are
working along with me,

00:26:08.990 --> 00:26:13.030
we need to go into the
Java headers target.

00:26:36.330 --> 00:26:36.330
So, now we should be able to successfully
build the Java headers target.

00:26:36.330 --> 00:26:36.330
Now we can retask.

00:26:36.330 --> 00:26:36.330
Now that the header file
has actually been generated,

00:26:36.330 --> 00:26:36.330
we can go ahead and
assign it to our project,

00:26:36.330 --> 00:26:36.330
and we'll be able to build
everything else after that.

00:26:36.330 --> 00:26:36.330
But let's have a look at the
header file for starters.

00:26:37.000 --> 00:26:39.720
It's a lot of the same noise that
you saw in the address book example,

00:26:39.720 --> 00:26:41.660
but there's a couple things
here that are interesting.

00:26:41.660 --> 00:26:47.800
You see these pound defines here
regarding Java QC view load message.

00:26:47.800 --> 00:26:50.150
So it actually not only did
it get the native methods,

00:26:50.160 --> 00:26:52.530
but it went ahead and got
the static constants that

00:26:52.530 --> 00:26:55.790
I declared in the Java file and
defined those on the C side.

00:26:55.800 --> 00:26:57.080
This is actually pretty useful.

00:26:57.080 --> 00:26:59.390
You know,
it's a stylistic difference whether

00:26:59.390 --> 00:27:02.910
people actually go ahead and
import the generated header file or

00:27:03.010 --> 00:27:06.670
because they don't like this noise,
maybe they just copy and paste these

00:27:06.670 --> 00:27:11.240
function declarations into a header
file of their own that's more readable.

00:27:11.240 --> 00:27:13.380
But if you're going to
use send message heavily,

00:27:13.380 --> 00:27:16.790
I would really recommend just importing
this header directly because now you

00:27:16.790 --> 00:27:18.520
have these defines in place for you.

00:27:18.520 --> 00:27:21.100
The alternative would be to
go ahead and define an enum

00:27:21.100 --> 00:27:24.220
in your own implementation,
and then you'd have to make sure

00:27:24.220 --> 00:27:27.670
you updated it every time you
changed something on the Java side.

00:27:27.680 --> 00:27:30.370
If you just use this header directly,
all of these defines are

00:27:30.490 --> 00:27:31.880
going to be updated for you.

00:27:31.880 --> 00:27:35.580
And as you can see,
let's go over to the implementation here.

00:27:36.010 --> 00:27:37.080
This is the .m file.

00:27:37.080 --> 00:27:40.570
This is where we actually create our...

00:27:43.050 --> 00:27:43.660
NSView.

00:27:43.660 --> 00:27:49.240
And here's our create
NSV long implementation.

00:27:49.290 --> 00:27:53.460
And it's just going to do a -- this is,
you know, standard Cocoa stuff, allocate,

00:27:53.550 --> 00:27:58.330
initialize, auto release an object,
and we're going to cast the pointer

00:27:58.400 --> 00:28:01.850
to a Java -- 64-bit Java long,
and that's going to go ahead

00:28:01.980 --> 00:28:05.130
and be used by the underlying
AWT to go ahead and embed this

00:28:05.130 --> 00:28:07.920
guy into the component hierarchy.

00:28:07.920 --> 00:28:11.470
And here is our
AWT message implementation.

00:28:11.550 --> 00:28:16.000
This is the native side of the
Java send message function that's made

00:28:16.270 --> 00:28:18.310
available to you by Cocoa component.

00:28:18.460 --> 00:28:21.790
And you can see we're switching
the message ID and we're using the

00:28:21.790 --> 00:28:24.140
pound defines from the header file.

00:28:24.350 --> 00:28:27.950
So these match the constants that
we declared in the Java source.

00:28:28.080 --> 00:28:30.490
So in the case of a load message,
we're going to go ahead and

00:28:30.570 --> 00:28:33.430
get a composition based on
the string that was passed.

00:28:33.430 --> 00:28:37.740
So here's our Java to native string
conversion that we did in the slides.

00:28:37.830 --> 00:28:41.160
Get the characters out
of the string argument.

00:28:41.350 --> 00:28:43.140
Create a new NSString.

00:28:43.550 --> 00:28:48.150
And load composition from file is
actually just a method in QC view.

00:28:48.170 --> 00:28:50.270
It's not something we declared.

00:28:50.280 --> 00:28:55.310
It's just part of the standard
ports compositor view.

00:28:55.770 --> 00:28:58.470
And then we release the string
characters when we're done,

00:28:58.470 --> 00:28:59.160
of course.

00:28:59.200 --> 00:29:02.380
And then the second message would
be to actually start the animation.

00:29:02.430 --> 00:29:05.540
StartRendering is another
QC view method that we just call.

00:29:05.600 --> 00:29:10.420
I probably could just have
done this all in one message,

00:29:10.430 --> 00:29:15.870
but I wanted to demonstrate the
difference or what it would look

00:29:15.880 --> 00:29:19.950
like to have multiple messages sent
through the AWT message method.

00:29:19.950 --> 00:29:19.950
So let's go ahead and build this thing.

00:29:32.890 --> 00:29:34.040
So it has to do a couple things.

00:29:34.040 --> 00:29:37.660
It has to compile the Java files,
it has to create the header file,

00:29:37.660 --> 00:29:40.800
and then it has to go ahead
and build the native targets.

00:29:40.800 --> 00:29:42.800
So let's see what's missing here.

00:29:42.910 --> 00:29:52.510
I'm guessing that the
header target was not found.

00:29:59.010 --> 00:30:01.540
We're missing our source
files for some reason.

00:30:01.540 --> 00:30:05.420
I wonder where those could have gone.

00:30:12.800 --> 00:30:16.600
Okay, well, when in doubt,
just build it a second time.

00:30:16.630 --> 00:30:21.490
Okay, so now here's our Java frame,
and these are standard Java JButtons,

00:30:21.490 --> 00:30:25.850
and this black thing that you see here,
that is our QC view inside the

00:30:25.850 --> 00:30:27.750
content pane of the JFrame.

00:30:27.990 --> 00:30:29.750
And I click this Load button.

00:30:29.750 --> 00:30:33.050
It's an ActionPerform
standard action listener,

00:30:33.050 --> 00:30:37.710
and the ActionPerform method is going
to go ahead and call sendMessage,

00:30:37.760 --> 00:30:40.010
which you can see right over here.

00:30:40.010 --> 00:30:41.210
We're calling LoadComposition.

00:30:41.480 --> 00:30:45.060
"Which is then going to
be a call to send message.

00:30:45.060 --> 00:30:47.800
And then play is likewise
going to do the same thing.

00:30:47.800 --> 00:30:50.960
The action listener on this
button goes ahead and does a send

00:30:50.960 --> 00:30:53.110
message using that start message."

00:30:53.250 --> 00:30:58.800
And there we have a Quartz Composer
composition playing inside Java.

00:30:58.840 --> 00:31:01.290
It's not as exciting as Scott's demo.

00:31:01.360 --> 00:31:02.900
He kind of one-upped me on it.

00:31:02.960 --> 00:31:07.030
But I wanted this to be a very
simple demonstration of how

00:31:07.030 --> 00:31:11.230
you can use Cocoa component to
just throw something in to a

00:31:11.230 --> 00:31:14.510
Java application with minimal effort.

00:31:16.700 --> 00:31:22.200
And there we have a Quartz Composer
composition playing inside Java.

00:31:22.200 --> 00:31:24.700
It's not as exciting as Scott's demo.

00:31:24.700 --> 00:31:26.300
He kind of one-upped me on it.

00:31:26.300 --> 00:31:30.420
But I wanted this to be a very
simple demonstration of how

00:31:30.430 --> 00:31:34.600
you can use Cocoa component to
just throw something in to a

00:31:34.810 --> 00:31:37.920
Java application with minimal effort.

00:31:46.600 --> 00:31:50.660
the exception of Jstring and
Jclass which respectively

00:31:50.660 --> 00:31:53.620
represent string and class objects.

00:31:53.620 --> 00:31:56.720
So you're going to get Jobjects
pretty much across the board

00:31:56.730 --> 00:31:58.440
no matter what you pass down.

00:31:58.440 --> 00:32:01.540
And if you need to hold on to these
Java objects in the native side,

00:32:01.590 --> 00:32:05.930
your C function might return some value
or just finish what it's doing and then

00:32:05.930 --> 00:32:09.800
maybe you have some callbacks that you're
going to receive on the C side that you

00:32:09.800 --> 00:32:12.180
then want to propagate back up to Java.

00:32:12.230 --> 00:32:12.790
How do you do that?

00:32:12.790 --> 00:32:14.750
You need to hold on to that Java object.

00:32:14.750 --> 00:32:18.360
And when you do that by creating
what's called a global reference.

00:32:18.360 --> 00:32:21.090
And we have these JNI functions
called new global ref.

00:32:21.260 --> 00:32:25.130
There's also new weak global ref
which is basically a weak reference

00:32:25.130 --> 00:32:27.360
if you know what those are in Java.

00:32:27.360 --> 00:32:31.410
The important thing to notice -- to know
when you start working with global refs

00:32:31.410 --> 00:32:33.160
is that they affect garbage collection.

00:32:33.160 --> 00:32:37.030
These are legitimate Java references
on the Java side and the virtual

00:32:37.030 --> 00:32:39.320
machine does keep track of them.

00:32:39.370 --> 00:32:43.240
So you need to use them
sparingly and responsibly.

00:32:43.240 --> 00:32:48.950
When you're done using a global
you need to actually delete it.

00:32:49.330 --> 00:32:53.030
If you don't, your Java object will
not be garbage collected.

00:32:53.040 --> 00:32:55.930
So, again,
all you need to do to create a memory

00:32:55.930 --> 00:32:58.200
leak in Java is write some C code.

00:32:58.250 --> 00:33:03.200
And the easiest way to do this
in the case of native peers,

00:33:03.200 --> 00:33:06.640
which is what we're doing with
this Cocoa component class,

00:33:06.650 --> 00:33:10.200
is just implement the removeNotify
method on the Java side,

00:33:10.200 --> 00:33:13.410
which is a method that gets
called when a component gets

00:33:13.540 --> 00:33:15.310
removed from the hierarchy.

00:33:15.620 --> 00:33:18.690
And in your remove notify method,
if you need to do anything,

00:33:18.690 --> 00:33:21.700
you usually don't need to do
anything in the Java side.

00:33:21.880 --> 00:33:24.900
But you go ahead and call a

00:33:25.030 --> 00:33:31.910
Call down into the native code via JNI,
and that is an opportunity for

00:33:31.960 --> 00:33:38.560
you to delete any global refs that
you may have been holding onto,

00:33:38.870 --> 00:33:41.060
because presumably this thing's
been removed from the hierarchy.

00:33:41.060 --> 00:33:41.060
It's probably not needed anymore,
and it's probably bound due

00:33:41.060 --> 00:33:41.060
to be garbage collected.

00:33:41.680 --> 00:33:44.340
So now we're going to talk
about calling Java methods

00:33:44.440 --> 00:33:46.440
from C or Objective-C or C++.

00:33:46.440 --> 00:33:49.360
A lot of people have
a hard time with this.

00:33:49.360 --> 00:33:52.900
The documentation is hard to find,
and it's even harder to read.

00:33:52.930 --> 00:33:55.810
There are some special codes for,
you know,

00:33:55.810 --> 00:34:00.470
for Java method signatures and the
equivalents in C when you go ahead and

00:34:00.530 --> 00:34:05.270
look up a method in JNI and that you
want to call across the JNI bridge.

00:34:07.220 --> 00:34:08.880
So, you know,
you can use the Java P command line

00:34:08.880 --> 00:34:27.830
tool and pass it the dash S flag,
and this will give you JNI-friendly

00:34:28.600 --> 00:34:30.800
signatures for all your Java methods.

00:34:30.860 --> 00:34:32.680
So if you need to make
a callback into Java,

00:34:32.680 --> 00:34:32.680
use Java P to go ahead and get the method
that you -- the signature that you need,

00:34:32.680 --> 00:34:32.680
and then you can call back into Java.

00:34:33.680 --> 00:34:34.320
So, you know, we're going to talk about
calling Java methods from

00:34:34.320 --> 00:34:34.680
C or Objective-C or C++.

00:34:35.680 --> 00:34:36.360
So, you know, we're going to talk about
calling Java methods from

00:34:36.380 --> 00:34:36.680
C or Objective-C or C++.

00:34:36.680 --> 00:34:39.750
and then grab that and then
in your C code when you want

00:34:39.750 --> 00:34:42.130
to create your callback,
use this string that

00:34:42.130 --> 00:34:43.510
you get out of Java P.

00:34:43.520 --> 00:34:47.260
And you always obtain the
method from the class.

00:34:47.280 --> 00:34:51.860
Even if it's an object method,
you obtain the method definition

00:34:51.860 --> 00:34:54.430
from the class and then
invoke it on the object later.

00:34:54.440 --> 00:34:58.440
You can call find class with
an explicit class string or if

00:34:58.440 --> 00:35:03.050
you have access to a J object,
you can call get object class

00:35:03.060 --> 00:35:04.310
and passing in the object.

00:35:05.460 --> 00:35:10.480
And so right here you see an example
of calling get method ID and class

00:35:10.480 --> 00:35:15.260
is presumably a class that we got
using one of those two functions.

00:35:15.260 --> 00:35:20.740
And so you can see the example here
of the signature at the end there.

00:35:20.740 --> 00:35:24.000
So in this case,
it's a method with no parameters.

00:35:24.000 --> 00:35:27.660
So you have the open and closed parens
there and the capital V means void.

00:35:27.660 --> 00:35:29.550
So that's the return value.

00:35:29.560 --> 00:35:34.410
So you would put the parameter values
inside those open and closed parens and

00:35:34.410 --> 00:35:36.400
then the return value comes at the end.

00:35:36.490 --> 00:35:39.410
And there's also an equivalent
get static method ID if you

00:35:39.470 --> 00:35:40.960
need to call static methods.

00:35:42.320 --> 00:35:45.320
So that brings us to an even
better Cocoa component demo,

00:35:45.420 --> 00:35:47.620
one that we did not show
you in the overview.

00:35:47.720 --> 00:35:50.310
Can we go back to demo two, please?

00:35:51.090 --> 00:35:52.000
Okay.

00:35:52.000 --> 00:35:55.240
So we can start in a bunch
of different places here.

00:35:55.240 --> 00:35:58.790
Has anybody actually
played with these demos?

00:35:58.940 --> 00:36:02.000
Has anybody seen the CW Cocoa component?

00:36:02.170 --> 00:36:02.440
No?

00:36:02.440 --> 00:36:02.980
Okay, good.

00:36:03.000 --> 00:36:04.450
Well, we'll have a surprise then.

00:36:04.580 --> 00:36:04.830
Okay.

00:36:04.950 --> 00:36:07.750
So first I'm going to
bring up this Java example.

00:36:07.760 --> 00:36:11.650
This is a pure
Java application with a JLabel,

00:36:11.700 --> 00:36:15.250
and I'm going to click
this Colors button,

00:36:15.250 --> 00:36:18.960
and it's going to show me
the J2SE color chooser.

00:36:18.960 --> 00:36:18.960
And I'm going to

00:36:19.700 --> 00:36:47.000
[Transcript missing]

00:36:48.480 --> 00:36:53.590
What I'd like to do,
and assuming this guy's running,

00:36:53.590 --> 00:36:56.650
I'll give you a little taste.

00:37:10.070 --> 00:37:10.080
So,
we're going to start off with a little

00:37:10.080 --> 00:37:10.080
bit of a demo of what this looks like.

00:37:10.080 --> 00:37:10.080
And we're going to embed this
thing as a Cocoa component.

00:37:10.080 --> 00:37:10.080
We're going to extend Cocoa component
just like in the previous demo,

00:37:10.080 --> 00:37:10.080
and embed it right into the hierarchy.

00:37:11.700 --> 00:37:14.300
So now instead of this colors button,
you see this color well.

00:37:14.300 --> 00:37:18.300
So that is an NSColorWell native
view that we're creating in

00:37:18.300 --> 00:37:21.440
Objective-C and embedding using
the Cocoa component mechanism.

00:37:21.440 --> 00:37:25.270
And I click on this guy and the
native color picker has shown up.

00:37:25.360 --> 00:37:28.100
And this is not,
I didn't have to do any code to do this.

00:37:28.190 --> 00:37:29.880
This is standard NSColorWell behavior.

00:37:29.880 --> 00:37:31.940
The difference is that
it's inside a J frame.

00:37:31.940 --> 00:37:35.820
Now we're just sitting around
an Objective-C world and,

00:37:35.820 --> 00:37:40.340
you know, if I select these colors,
Cocoa knows about them,

00:37:40.340 --> 00:37:44.060
but we need a way to go ahead and tell
Java that a color selection has changed.

00:37:44.060 --> 00:37:45.970
You know,
this work is not done for us like

00:37:45.970 --> 00:37:47.560
it is with the J color chooser.

00:37:47.560 --> 00:37:48.460
So.

00:37:49.770 --> 00:37:52.450
In order to do that,
we're going to need to call

00:37:52.450 --> 00:37:54.100
back up into Java from C.

00:37:54.160 --> 00:37:56.700
And as you can see, it's working.

00:37:56.730 --> 00:38:02.060
I select brown, I select magenta, green,
got my crayons.

00:38:02.060 --> 00:38:06.270
So to be clear,
the color well change in color,

00:38:06.270 --> 00:38:10.270
that's standard Cocoa behavior,
but this J label is actually

00:38:10.470 --> 00:38:14.520
being changed because we're
creating a callback every time

00:38:14.520 --> 00:38:17.110
the color well receives something.

00:38:17.110 --> 00:38:17.980
So let's show you how that works.

00:38:19.000 --> 00:38:23.720
So here's our, let's see,
I want the Java color well.

00:38:23.970 --> 00:38:27.600
For those of you who
have the project open,

00:38:27.600 --> 00:38:27.600
feel free to follow along.

00:38:28.260 --> 00:38:32.990
The Java color well
has a Create NSV Long,

00:38:33.070 --> 00:38:36.050
just like the Quartz Composer.

00:38:36.260 --> 00:38:40.380
It's got a casted Create NSV,
that's nothing new.

00:38:40.380 --> 00:38:42.980
And we've also got some
generic listener support,

00:38:42.980 --> 00:38:46.480
you know, just like any other
AWT kind of component.

00:38:46.610 --> 00:38:50.000
So we have an array of listeners,
and I've created these color

00:38:50.090 --> 00:38:52.980
selection listener and color
selection event classes.

00:38:52.980 --> 00:38:55.470
And this is going to be the framework
that's going to allow us to actually

00:38:55.580 --> 00:38:57.500
communicate this stuff back to Java.

00:38:57.500 --> 00:39:00.380
We could do it real
lightweight with callbacks,

00:39:00.490 --> 00:39:05.260
but I want it to be a good Java citizen
and create an event structure for this.

00:39:05.260 --> 00:39:12.610
So the key to all of this is
this Cocoa color change method.

00:39:12.610 --> 00:39:12.610
And, you know, I've been working

00:39:14.420 --> 00:39:16.710
This method,
you notice I listed it as private.

00:39:16.720 --> 00:39:20.910
This method is what's going to be
called back from Cocoa when a color

00:39:20.910 --> 00:39:22.970
change occurs in the NSColorWell.

00:39:22.980 --> 00:39:26.060
And so at this point,
there's been a color

00:39:26.060 --> 00:39:28.360
change in the NSColorWell,
and we want to go ahead

00:39:28.360 --> 00:39:29.480
and notify Java of it.

00:39:29.600 --> 00:39:32.000
So this is, I mean, if you've looked at
any of the JDK sources,

00:39:32.000 --> 00:39:33.740
this is very standard stuff.

00:39:33.840 --> 00:39:35.480
We go ahead and we loop
through all the selection,

00:39:35.480 --> 00:39:38.160
through all the listeners,
we create an event,

00:39:38.160 --> 00:39:42.760
and in this case we're past the
RGB and alpha values that came in

00:39:42.760 --> 00:39:44.440
from the new color on the Cocoa side.

00:39:44.440 --> 00:39:48.360
And then we go ahead and slap those
onto the event queue asynchronously,

00:39:48.410 --> 00:39:51.820
which is a key point that I'll
be talking about a little later.

00:39:54.090 --> 00:39:57.020
And I listed this as private
basically because I don't want

00:39:57.020 --> 00:39:58.830
Java code accidentally calling this.

00:39:58.920 --> 00:40:04.760
The only purpose of this is really just
to get a callback from the native code.

00:40:04.950 --> 00:40:09.550
So now we can go check
out our header file.

00:40:13.140 --> 00:40:14.780
And this doesn't look much different.

00:40:14.780 --> 00:40:17.730
You notice we have a
bunch of constants here.

00:40:17.850 --> 00:40:20.580
Close panel, deactivate,
and here's our remove notify.

00:40:20.780 --> 00:40:23.090
And I mentioned that in the slides,
and I'll show you how

00:40:23.100 --> 00:40:24.540
that actually works.

00:40:24.540 --> 00:40:27.960
And we've got a couple
JNI functions here.

00:40:27.960 --> 00:40:29.900
There's this one called init method IDs.

00:40:29.900 --> 00:40:31.540
Actually, I skipped over that.

00:40:31.540 --> 00:40:34.480
I'm going to go back to the
Java class for a second.

00:40:34.480 --> 00:40:36.990
Here's our static initializer
where we load the library,

00:40:37.010 --> 00:40:38.580
just like in all the other examples.

00:40:38.720 --> 00:40:41.350
And then we do another call here
to initialize the method IDs.

00:40:41.350 --> 00:40:43.800
And this is just, you know,
at class load time,

00:40:43.980 --> 00:40:49.320
we go ahead and we look up the callbacks
that we know we're going to need later.

00:40:49.320 --> 00:40:52.760
And the reason we do this is
because the Java method IDs live

00:40:52.760 --> 00:40:54.480
as long as the class does.

00:40:54.640 --> 00:40:57.270
So there's no need to reflectively
look up these callbacks

00:40:57.440 --> 00:40:59.090
every time an event is fired.

00:40:59.120 --> 00:41:01.840
Because as you can imagine,
that's going to really bog

00:41:01.850 --> 00:41:03.010
things down real quickly.

00:41:03.120 --> 00:41:08.000
So we just initialize the callbacks that
we know we need at the very beginning.

00:41:08.000 --> 00:41:10.050
So here, in this case, it's just one.

00:41:10.140 --> 00:41:13.820
It's that color change method
that we declared up in Java.

00:41:13.990 --> 00:41:16.130
And this is how we look it up.

00:41:16.330 --> 00:41:22.130
Because it's a static native method,
we get the class as the caller,

00:41:22.130 --> 00:41:26.380
so we don't need to look it up,
and we go ahead and we request an ID.

00:41:26.380 --> 00:41:28.960
We request a hook to the
CocoaColorChange method,

00:41:28.960 --> 00:41:30.550
and here's the signature.

00:41:30.550 --> 00:41:32.190
Four floats and return a void.

00:41:32.430 --> 00:41:36.760
In this case,
it was actually a very similar,

00:41:36.760 --> 00:41:40.220
I'm sorry, a very simple example.

00:41:40.220 --> 00:41:43.020
Let me show you how I did that.

00:41:43.170 --> 00:41:45.540
I was talking about the Java H.

00:41:47.160 --> 00:41:51.840
The Java H utility a second ago,
I'm sorry, the Java P utility.

00:41:51.840 --> 00:41:53.490
So I'm going to do Java P-S.

00:41:54.080 --> 00:42:04.550
And let's point to this java
headers.jar and Apple VTS sample code.

00:42:06.040 --> 00:42:07.250
CW Cocoa component.

00:42:07.280 --> 00:42:15.020
And I'm just basically, you know,
doing the fully qualified class

00:42:15.020 --> 00:42:15.020
name of the Java color well class.

00:42:16.660 --> 00:42:18.210
and I am blocked.

00:42:18.210 --> 00:42:22.490
I must have some kind of
permissions error here.

00:42:22.490 --> 00:42:24.590
Let me try to fix that.

00:42:35.500 --> 00:42:42.620
So what the Java P utility
should normally do is give

00:42:42.620 --> 00:42:46.500
you a list of all the methods,
all the Java methods,

00:42:46.500 --> 00:42:51.500
but the "-s" flag is going to go
ahead and give you this little piece,

00:42:51.510 --> 00:42:54.290
which is going to be the native
signature that's used by JNI.

00:42:54.300 --> 00:42:59.170
And I basically cut and pasted
this from the Java P output.

00:43:00.780 --> 00:43:04.200
So now let's go take a look
a little further down and see

00:43:04.200 --> 00:43:07.110
what we're actually doing here.

00:43:07.170 --> 00:43:12.920
Here's our general initializer,
our createNSViewLong method.

00:43:13.280 --> 00:43:15.270
which is just going to
initialize a new color well.

00:43:15.440 --> 00:43:17.820
And you notice instead of
just creating it normally,

00:43:17.820 --> 00:43:21.970
we're actually going to pass in
the object that called this method,

00:43:21.980 --> 00:43:25.550
in which case it's the
Java object sitting on top of us,

00:43:25.620 --> 00:43:27.590
the Java peer, if you will.

00:43:27.890 --> 00:43:31.540
And we're actually going to save
this by creating a global reference,

00:43:31.540 --> 00:43:33.850
and we need to do that because
we're going to make a call back

00:43:33.850 --> 00:43:35.140
at some point in the future.

00:43:35.160 --> 00:43:36.220
And we don't know when that is.

00:43:36.340 --> 00:43:38.600
This function inevitably has to return.

00:43:38.620 --> 00:43:41.910
Later on down the line,
we need to inform people that

00:43:41.930 --> 00:43:42.910
this color change occurred.

00:43:42.920 --> 00:43:45.470
And we're going to do that by
holding onto a global reference.

00:43:45.580 --> 00:43:47.880
So that's going to be relevant later.

00:43:50.520 --> 00:44:15.200
After that, we go ahead and, you know,
I had mentioned that you

00:44:15.200 --> 00:44:15.200
need to maintain your global
references when you create them.

00:44:15.200 --> 00:44:15.200
And so I use removeNotify because
it's not really a special thing.

00:44:15.200 --> 00:44:15.200
We don't need to go ahead and do any
kind of parameter passing or anything.

00:44:15.200 --> 00:44:15.200
We've declared removeNotify
as a native -- well,

00:44:15.200 --> 00:44:15.200
we haven't declared
it as a native method.

00:44:15.200 --> 00:44:15.200
We've overridden it from
the standard component.

00:44:15.380 --> 00:44:18.290
And we're just going to call super,
but before we do that,

00:44:18.300 --> 00:44:22.720
we're going to do a send message,
which is that standard Cocoa component

00:44:22.720 --> 00:44:24.570
message transmission API.

00:44:43.540 --> 00:44:43.670
And at that point,
we just go on faith from receiving

00:44:43.670 --> 00:44:43.670
the message that we're done,
we don't need this anymore,

00:44:43.670 --> 00:44:43.670
and we go ahead and delete
the global reference.

00:44:43.670 --> 00:44:43.670
And this will allow the Java object
to be garbage collected later on.

00:44:43.670 --> 00:44:43.670
So where's the real exciting
and interesting stuff?

00:44:43.670 --> 00:44:43.670
Well,

00:44:45.470 --> 00:44:51.410
This is the standard activate
method from the NSColorWell class.

00:44:51.690 --> 00:44:57.350
And we're just going to
bring up an NSColor panel.

00:44:57.830 --> 00:44:58.800
pass it right along.

00:44:58.800 --> 00:45:01.360
The only thing we're doing here
is showing the opacity slider.

00:45:01.360 --> 00:45:03.460
It's obviously not necessary,
it's just something

00:45:03.460 --> 00:45:04.620
I thought would be cool.

00:45:04.640 --> 00:45:09.530
And then the passing up activate to
super inevitably shows the color well,

00:45:09.530 --> 00:45:14.260
I'm sorry, the color picker and ties
it to the active color well.

00:45:14.310 --> 00:45:19.240
And the other thing we did is we
just overrode the set color method.

00:45:19.290 --> 00:45:23.540
So that's every time
I change something here,

00:45:23.540 --> 00:45:27.550
obviously set color is being
called on the NS color well.

00:45:27.570 --> 00:45:30.870
And that's our opportunity to go
ahead and call back to Java and say,

00:45:30.870 --> 00:45:31.960
hey, the color just changed.

00:45:31.960 --> 00:45:35.210
Why don't you go ahead
and change that J label?

00:45:35.280 --> 00:45:37.200
And here's our panel color change method.

00:45:37.280 --> 00:45:40.680
First thing we need to do is get
a valid JNI environment pointer.

00:45:40.680 --> 00:45:43.960
We do that by using this utility
function called attach current thread.

00:45:43.960 --> 00:45:47.780
JNI environment pointers are
only valid for the current

00:45:48.000 --> 00:45:51.940
thread that you're operating in.

00:45:53.290 --> 00:45:56.490
because there's also a Java VM pointer.

00:45:56.520 --> 00:45:58.740
I'm going to scroll up here.

00:45:58.740 --> 00:46:01.400
And the Java VM here
we've declared a static,

00:46:01.400 --> 00:46:03.440
and we basically just
cache it using onLoad.

00:46:03.440 --> 00:46:08.170
The Java virtual machine is always,
you know, a-- basically a singular--

00:46:08.170 --> 00:46:09.660
a singleton instance.

00:46:09.660 --> 00:46:11.960
You can only have one JVM per process.

00:46:11.960 --> 00:46:15.660
And you guys probably know this already.

00:46:15.660 --> 00:46:18.890
So you can cache the VM,
but the Java environment is

00:46:18.890 --> 00:46:20.610
tied to a specific thread.

00:46:20.640 --> 00:46:25.320
So we need to create a fresh
one using attach current thread.

00:46:25.580 --> 00:46:31.850
And then we go ahead and we get the
color from the standard Cocoa callback,

00:46:31.900 --> 00:46:35.010
and we're converting this into
something that basically we know is

00:46:35.010 --> 00:46:37.940
going to be safe for Java to use,
a generic RGB color.

00:46:37.940 --> 00:46:40.390
And then we go ahead and
create four floats out of this,

00:46:40.390 --> 00:46:44.210
red, green, blue, and alpha,
and then we call our color change method.

00:46:44.220 --> 00:46:47.840
So here's the method ID we
cast when we loaded the class,

00:46:47.840 --> 00:46:51.330
and here's the peer that we
saved using global ref when we

00:46:51.610 --> 00:46:53.320
created the ColorWell instance.

00:46:54.280 --> 00:46:55.920
And then we go ahead and we pass along.

00:46:55.920 --> 00:46:57.740
This is obviously a Verargs declaration.

00:46:57.740 --> 00:47:00.060
We pass the red, the green, the blue,
and the alpha.

00:47:00.140 --> 00:47:03.400
So let's go back to the ColorWell,
and I'll show you what we're doing.

00:47:03.400 --> 00:47:04.470
So here's the method.

00:47:04.480 --> 00:47:08.030
It's expecting four floats,
and this is what happens when

00:47:08.030 --> 00:47:12.150
we make that callback and we do
an invoke from the native side.

00:47:12.160 --> 00:47:15.550
This method's going to be called,
and that's going to let us

00:47:15.550 --> 00:47:17.360
go ahead and change things.

00:47:17.510 --> 00:47:19.240
So right now, this is just generic.

00:47:19.240 --> 00:47:23.540
In the actual test case,
I have a color selection listener.

00:47:25.060 --> 00:47:26.900
which

00:47:31.560 --> 00:47:41.440
So, I click on this,
and we get a call to set

00:47:41.530 --> 00:47:45.540
color in the NSColorWell,
and we go ahead and we pull up

00:47:45.660 --> 00:47:49.590
the object and the method ID,
call back to Java, Java goes and fires up

00:47:49.590 --> 00:47:50.500
all of its listeners.

00:47:50.500 --> 00:47:56.390
So, you think this is a lot of work,
and you may be worried about performance,

00:47:56.390 --> 00:47:56.390
but actually it responds
pretty darn well.

00:47:56.720 --> 00:48:00.780
As you can see, every time,
every single one of these little

00:48:01.100 --> 00:48:05.190
color changes is a Cocoa call,
and then a callback across

00:48:05.190 --> 00:48:08.520
the JNI over to Java,
across that bridge,

00:48:08.610 --> 00:48:14.360
and then we're creating AWT events
and putting them asynchronously

00:48:14.370 --> 00:48:20.250
onto the AWT event queue,
and they're being processed pretty well,

00:48:20.250 --> 00:48:21.620
perfectly in time.

00:48:21.620 --> 00:48:21.620
The opacity works fine, too.

00:48:21.620 --> 00:48:21.620
So that...

00:48:24.170 --> 00:48:29.820
I know a lot of people have been kind of
grieving over the standard JColorChooser,

00:48:29.820 --> 00:48:32.600
so I'm hoping people will
get some use out of this.

00:48:32.600 --> 00:48:35.740
And obviously with the
code that you have here,

00:48:36.140 --> 00:48:39.570
which is part of the DMG,
it's not going to be much harder

00:48:39.570 --> 00:48:43.680
to modify this sample to use,
for example, the font panel,

00:48:43.690 --> 00:48:47.880
which is another thorn,
tends to be another thorn in people's

00:48:48.130 --> 00:48:50.370
sides when working with pure Java.

00:48:50.370 --> 00:48:51.170
So I think we're ready to
move back to the slides.

00:48:53.050 --> 00:48:57.790
So, now that we're really getting
into back and forth talking,

00:48:57.790 --> 00:49:01.000
you need to keep in mind, you know,
once you go down this road,

00:49:01.000 --> 00:49:04.520
you are a Cocoa programmer,
and you need to be mindful

00:49:04.520 --> 00:49:06.320
of what that means.

00:49:06.350 --> 00:49:12.060
So, we have the Cocoa AppKit,
which is the event system in Cocoa,

00:49:12.070 --> 00:49:14.860
and we also have the Java AWT.

00:49:14.860 --> 00:49:17.550
Now, these two,
the AWT is built on top of Cocoa,

00:49:17.650 --> 00:49:21.010
as you know, but they really are
separate environments,

00:49:21.020 --> 00:49:22.850
and they can coexist.

00:49:22.900 --> 00:49:25.270
But you need to help them,
and you need to, well,

00:49:25.280 --> 00:49:27.610
not specifically help them,
you need to not stop

00:49:27.620 --> 00:49:28.900
them from coexisting.

00:49:28.900 --> 00:49:32.240
We have two separate event queues,
and they're operating

00:49:32.240 --> 00:49:33.900
on two separate threads.

00:49:33.900 --> 00:49:37.900
And you may have noticed that in
the example that I just showed you,

00:49:37.900 --> 00:49:42.900
we were doing our Java callbacks using
an event queue that invoke later call.

00:49:42.900 --> 00:49:47.900
And this gets us on the correct thread,
and it also does so asynchronously,

00:49:47.900 --> 00:49:51.770
and it allows us to not block one
of these threads against the other.

00:49:52.020 --> 00:49:56.520
So the key is when you're communicating
from one environment to another,

00:49:56.520 --> 00:49:59.060
if you have an action performed
and then you go ahead and need

00:49:59.060 --> 00:50:02.230
to do some AppKit drawing or
some kind of event transmission,

00:50:02.230 --> 00:50:04.320
you need to do that asynchronously.

00:50:04.320 --> 00:50:07.470
And in this case,
if you need some kind of return value,

00:50:07.470 --> 00:50:11.610
you should really set up callbacks,
much like I did in the previous

00:50:11.610 --> 00:50:14.020
example with event transmission.

00:50:14.020 --> 00:50:19.920
And now it is time for the only diagram
you're going to see in this entire talk.

00:50:19.920 --> 00:50:22.760
You go home, you ask your manager,
your manager asks you how

00:50:22.760 --> 00:50:24.190
technical the session was.

00:50:24.240 --> 00:50:27.800
You can tell them there was
only one picture the whole time.

00:50:28.330 --> 00:50:32.860
So we have here the AppKit that
you can see up here running on top,

00:50:32.860 --> 00:50:35.300
and the AWT event queue below.

00:50:35.300 --> 00:50:39.570
So this MyAppKit notification,
let's say your JNI code has registered

00:50:39.580 --> 00:50:43.180
for a notification from AppKit,
and those notifications always

00:50:43.180 --> 00:50:44.790
occur on the main AppKit thread.

00:50:44.800 --> 00:50:49.660
And the AWT is actually busy
processing a resize from either

00:50:49.870 --> 00:50:54.530
the user moving the resize box,
or maybe something on the AWT thread

00:50:54.640 --> 00:50:56.300
explicitly called set size.

00:50:56.300 --> 00:50:59.180
So the app,
our AWT implementation is going to go

00:50:59.320 --> 00:51:02.100
ahead and make a call to set frame,
which is the

00:51:02.100 --> 00:51:04.300
Cocoa equivalent of set size.

00:51:04.300 --> 00:51:09.090
And it's going to wait to get into the,
into the AppKit queue to do that.

00:51:09.280 --> 00:51:12.280
So assuming your,
let's say your notification

00:51:12.310 --> 00:51:15.400
is currently being processed,
and you make a Java call

00:51:15.540 --> 00:51:18.450
back because you want to,
you want to tell the Java world that

00:51:18.510 --> 00:51:22.260
this notification has occurred and
update something in your AWT GUI.

00:51:22.300 --> 00:51:23.560
You make a call to event
queue dot invoke and wait,

00:51:23.590 --> 00:51:24.300
which is halfway there.

00:51:24.300 --> 00:51:30.760
You've at least properly gotten
yourself onto the AWT thread.

00:51:31.820 --> 00:51:36.520
And your AWT callback properly
gets into the AWT event queue.

00:51:36.660 --> 00:51:40.140
The problem is,
because you used invoke and wait,

00:51:40.140 --> 00:51:41.700
you are blocking.

00:51:41.700 --> 00:51:47.140
And none of this is going to return until
your do-AWT-work callback has returned.

00:51:47.140 --> 00:51:51.880
Unfortunately, it can't do that,
because it's still waiting for the

00:51:51.880 --> 00:51:55.130
resize implementation to be finished.

00:51:55.350 --> 00:51:57.660
That can't do it,
because you have blocked

00:51:57.780 --> 00:52:01.130
up the AppKit loop with
your notification handler.

00:52:01.400 --> 00:52:07.020
And the result here is our famous friend,
the spinning beach ball.

00:52:07.020 --> 00:52:10.140
So what can you do about this?

00:52:10.450 --> 00:52:13.970
Well,
when you're calling the AWT from AppKit,

00:52:14.130 --> 00:52:19.030
we really strongly recommend you
use the event queue.invoke later.

00:52:19.140 --> 00:52:21.110
And the difference here
is that it will not block.

00:52:21.140 --> 00:52:23.740
It will put you on the thread,
on the AWT thread,

00:52:23.740 --> 00:52:26.690
just like invoke and wait does,
but it will not wait.

00:52:26.740 --> 00:52:30.960
It will simply post what it needs to,
the runnable that you pass,

00:52:30.960 --> 00:52:34.460
onto the AWT thread to be executed,
and then returns.

00:52:34.610 --> 00:52:37.290
And it allows you to get out of the way.

00:52:38.600 --> 00:53:44.700
[Transcript missing]

00:53:45.320 --> 00:53:46.740
So let's see the difference.

00:53:46.840 --> 00:53:50.410
So here's the same setup as before,
but now instead,

00:53:50.410 --> 00:53:54.090
our notification handler is going
to actually call Invoke Later.

00:53:54.370 --> 00:53:56.400
And you can see the dotted
line we've done differently,

00:53:56.400 --> 00:53:57.970
meaning that it's non-blocking.

00:53:58.120 --> 00:54:03.270
So we get our callback on the queue,
and then Invoke Later is

00:54:03.270 --> 00:54:05.370
able to return immediately.

00:54:05.590 --> 00:54:06.820
Nothing has really changed.

00:54:06.880 --> 00:54:08.620
You're still going to
get your callback done,

00:54:08.730 --> 00:54:12.370
but this is going to allow your
notification to get out of the way.

00:54:12.550 --> 00:54:15.220
So that resize can get processed.

00:54:15.260 --> 00:54:17.870
The set size call can
get off the AWT queue,

00:54:17.870 --> 00:54:21.100
and then your AWT callback
can finally get done.

00:54:21.150 --> 00:54:23.560
And this is a happy JNI application.

00:54:25.700 --> 00:56:54.900
[Transcript missing]

00:56:57.060 --> 00:57:01.270
Okay, so I'm going to open up this
fourth demo with the incredibly

00:57:01.270 --> 00:57:04.480
revealing title of JSheets.

00:57:05.100 --> 00:57:10.060
So here is a pure Java application,
and you may be used

00:57:10.060 --> 00:57:12.420
to the J file chooser.

00:57:12.670 --> 00:57:15.210
Best friend to some, not to others.

00:57:15.210 --> 00:57:17.370
And so this is a very simple demo.

00:57:17.720 --> 00:57:20.260
It's just going to let me choose a file.

00:57:20.260 --> 00:57:23.530
I'm going to open the J file chooser,
and now I'm going to show

00:57:23.530 --> 00:57:26.670
a J option pane saying,
here's the file you selected.

00:57:29.510 --> 00:57:32.040
So, a lot of people don't
like the J file chooser,

00:57:32.040 --> 00:57:34.380
they'd like to do more,
they don't think the AWT file

00:57:34.480 --> 00:57:36.400
dialogue is a viable solution.

00:57:36.400 --> 00:57:45.140
So, maybe, just maybe,
we could do something different,

00:57:45.140 --> 00:57:45.140
like say,

00:57:47.860 --> 00:57:53.920
So, this is a standard Cocoa NSOpenPanel
that we have attached to a JFrame.

00:57:53.920 --> 00:57:58.150
And let me go ahead and
show you what we have done.

00:57:58.630 --> 00:58:00.280
Select another file.

00:58:00.280 --> 00:58:02.880
Now I'm going to click Open here.

00:58:02.900 --> 00:58:07.170
And then the Cocoa panel goes away
and our J option pane shows up.

00:58:07.300 --> 00:58:10.760
So this was a Cocoa component
that came down.

00:58:10.780 --> 00:58:13.590
We got a call back from it
receiving the file name.

00:58:13.600 --> 00:58:16.200
And then we went ahead
and posted it to AWT.

00:58:16.360 --> 00:58:18.830
We passed the string across the JNI.

00:58:19.080 --> 00:58:22.510
And then AWT was able to react
to it by showing up a dialog.

00:58:22.630 --> 00:58:26.140
So how do we do all of this?

00:58:26.180 --> 00:58:30.150
Let's open up the Xcode project.

00:58:32.170 --> 00:58:37.920
And we have this JSheet delegate class,
and we've got a bunch of, uh,

00:58:38.350 --> 00:58:42.860
The real star here is the
native show sheet method.

00:58:42.860 --> 00:58:47.600
And we're passing an integer
for the type open save.

00:58:47.600 --> 00:58:49.680
We pass the component that
we want to be the parent,

00:58:49.720 --> 00:58:52.410
and this is going to be where
we start using our JWT code.

00:58:52.410 --> 00:58:54.670
And we're also going
to pass in a listener,

00:58:54.670 --> 00:58:57.370
which is basically going
to be our callback handler

00:58:57.370 --> 00:58:59.020
for when the sheet closes.

00:58:59.610 --> 00:59:03.890
The thing about JWT is that the
sheets in Cocoa don't behave like file

00:59:03.890 --> 00:59:06.240
choosers or file dialogs do in Java.

00:59:06.460 --> 00:59:09.770
When you create a J file
chooser or a file dialog in AWT,

00:59:09.770 --> 00:59:13.640
you basically assign an int value,
you basically wait for it

00:59:13.660 --> 00:59:15.250
to return an int value.

00:59:15.250 --> 00:59:18.180
Let me,
I've got my J file chooser code in here,

00:59:18.270 --> 00:59:20.430
and let's have a look at it.

00:59:24.520 --> 00:59:26.580
So right,
so here's your pure Java code that

00:59:26.660 --> 00:59:28.580
calls JFileChooserShowSaveDialog.

00:59:28.670 --> 00:59:31.690
This is going to show the save dialog,
it's going to block,

00:59:31.780 --> 00:59:35.100
and then when the user dismisses
it or clicks cancel or OK,

00:59:35.210 --> 00:59:37.270
we get an integer result value.

00:59:37.280 --> 00:59:38.680
This is the pure Java example.

00:59:38.680 --> 00:59:42.220
Well, because of that big
diagram I just showed you,

00:59:42.220 --> 00:59:45.380
this may be a problem,
blocking against Java,

00:59:45.380 --> 00:59:48.660
waiting for AppKit to
return something to us.

00:59:49.020 --> 00:59:52.930
Luckily, Cocoa makes it easy for us,
or depending on how you want to say it,

00:59:53.060 --> 00:59:56.420
forces it down our throat,
because the sheet model with

00:59:56.420 --> 00:59:59.920
NSOpenPanel does not block like
that and return a value anyway.

00:59:59.920 --> 01:00:04.340
Even if you're just doing pure Cocoa,
you have to specify a callback that is

01:00:04.340 --> 01:00:06.250
then called when the sheet is dismissed.

01:00:06.260 --> 01:00:09.840
So that part is taken care of for us,
and I'll show you in a second.

01:00:09.840 --> 01:00:13.420
But here's our method, showSheet.

01:00:13.870 --> 01:00:18.320
And we have wrappers for it,
show open sheet, show save sheet,

01:00:18.320 --> 01:00:22.800
and we've tied those to the action
listeners on our JMenu items.

01:00:22.800 --> 01:00:29.470
So let's go over to
the Objective-C world.

01:00:32.930 --> 01:00:36.590
And here's our sheet
delegate implementation.

01:00:36.640 --> 01:00:38.850
Let's start moving down.

01:00:39.350 --> 01:00:43.050
And now you can see the value of
the init method ID's function.

01:00:43.080 --> 01:00:46.440
The earlier example with the color well,
we only had one callback.

01:00:46.590 --> 01:00:49.470
Now it's starting to get a little hairy,
and there's a bunch of different

01:00:49.470 --> 01:00:51.870
things that we may need to do in
case it was the beginning of --

01:00:51.890 --> 01:00:55.050
in case it was the end of a save,
in case it was the end of an open,

01:00:55.050 --> 01:00:56.140
if it was a cancel.

01:00:56.260 --> 01:00:59.100
So now we can do all
these things in one place,

01:00:59.100 --> 01:01:02.190
and then just know later
-- and know later on with

01:01:02.190 --> 01:01:04.290
confidence that we have them.

01:01:04.290 --> 01:01:07.640
So here's our native show
sheet implementation.

01:01:07.820 --> 01:01:09.100
And we're going to --

01:01:10.580 --> 01:01:13.200
This is where the JWT comes in.

01:01:13.200 --> 01:01:20.580
This getWindowFromComponent is a function
that I have created right further down.

01:01:20.790 --> 01:01:23.500
And now you get into standard JWT code.

01:01:23.500 --> 01:01:26.000
A lot of this may look very
familiar to those of you who

01:01:26.000 --> 01:01:27.440
have seen the JWT example.

01:01:27.680 --> 01:01:29.570
It's almost identical.

01:01:30.600 --> 01:01:33.160
These JWT drawing surface
and drawing surface info,

01:01:33.250 --> 01:01:38.570
these are standard structures that are
part of the Sun AWT Native Interface API.

01:01:38.800 --> 01:01:42.200
And then there's this Mac OS X drawing
surface info that's part

01:01:42.270 --> 01:01:43.900
of our own implementation.

01:01:43.900 --> 01:01:46.350
And you can see that.

01:01:47.790 --> 01:01:54.610
: So, we have a JVM header file here.

01:01:54.610 --> 01:01:54.610
Here we've implemented the
JWT machine-dependent header.

01:01:55.430 --> 01:02:00.190
Okay, so going back, we get the AWT,
we get the drawing surface

01:02:00.650 --> 01:02:03.520
from the parent component,
in this case,

01:02:03.690 --> 01:02:08.390
the component that we passed into
the native show sheet method.

01:02:08.710 --> 01:02:11.770
We get the drawing surface info,
and we go ahead and we get

01:02:11.810 --> 01:02:13.640
the platform-specific struct.

01:02:13.640 --> 01:02:17.050
From there, our implementation provides
you with an NSView,

01:02:17.210 --> 01:02:20.460
and this is the NSView corresponding
to the component that you

01:02:20.460 --> 01:02:22.150
passed in to the request.

01:02:22.160 --> 01:02:25.340
So once we get that,
we can just call viewWindow.

01:02:25.340 --> 01:02:28.110
This is a standard Cocoa call,
and that's going to give us the

01:02:28.110 --> 01:02:29.550
NSWindow pointer that we need.

01:02:29.560 --> 01:02:33.050
Now, granted,
I'll admit that this may not be what the

01:02:33.050 --> 01:02:35.640
founding fathers had in mind for JWT.

01:02:36.100 --> 01:02:38.440
You know, like I said earlier,
this is really supposed to

01:02:38.440 --> 01:02:41.080
be a native drawing thing,
but everything we're doing

01:02:41.080 --> 01:02:44.800
here is completely legitimate,
and as you saw earlier with

01:02:44.910 --> 01:02:47.640
the example we showed you,
it works.

01:02:49.720 --> 01:02:52.790
So now we have our NSWindow,
and we just switch.

01:02:52.800 --> 01:02:55.590
This is a similar, you know,
kind of a similar

01:02:55.590 --> 01:02:58.040
example to send message.

01:02:58.040 --> 01:03:01.030
We switch whether it's an open panel,
the calls are slightly different.

01:03:01.170 --> 01:03:06.010
We go ahead and we call performSelector
on main thread to show either

01:03:06.010 --> 01:03:08.540
an open panel or a saved panel.

01:03:08.700 --> 01:03:18.800
[Transcript missing]

01:03:21.300 --> 01:03:24.660
Create an NSOpenPanel,
set it to allow multiple selection,

01:03:24.660 --> 01:03:28.200
round of applause, native file dialogs
with multiple selection.

01:03:28.410 --> 01:03:31.200
Okay, so you're too kind.

01:03:31.500 --> 01:03:35.210
And then we go ahead and
we show this as a sheet.

01:03:35.520 --> 01:03:39.320
We start at the home directory,
obviously you could customize this.

01:03:39.320 --> 01:03:41.430
And now we have this delegate,
which is the self,

01:03:41.560 --> 01:03:42.900
and the did end selector.

01:03:42.900 --> 01:03:46.300
So this is the callback that's going
to happen in Cocoa when the user either

01:03:46.300 --> 01:03:48.000
selects a file or cancels the sheet.

01:03:48.010 --> 01:03:52.530
And in this case,
it's open panel did end.

01:03:53.420 --> 01:03:57.410
So now, at this point,
when this method is called,

01:03:57.410 --> 01:03:59.910
the user has dismissed the
sheet one way or another.

01:03:59.910 --> 01:04:01.910
And we check the return code.

01:04:01.910 --> 01:04:04.940
We get a valid JNI environment again.

01:04:04.940 --> 01:04:07.920
If it was an okay,
meaning something was selected,

01:04:07.930 --> 01:04:10.200
we go ahead and enumerate
through the file names.

01:04:10.200 --> 01:04:11.410
We create an array.

01:04:11.470 --> 01:04:13.260
So this is something that's
a little different that we

01:04:13.260 --> 01:04:14.280
didn't talk about before.

01:04:14.280 --> 01:04:18.910
You create an array of
objects in JNI using this new

01:04:18.910 --> 01:04:22.100
object array method function.

01:04:23.240 --> 01:04:25.710
There are also primitive array
functions like new int array,

01:04:25.710 --> 01:04:27.220
new long array, so on and so forth.

01:04:27.330 --> 01:04:31.840
So we create this array,
and we do our standard string conversion.

01:04:31.840 --> 01:04:38.110
We get the characters out,
cast it to a JCAR, and call new string.

01:04:38.910 --> 01:04:41.130
And now we make this call
to set object array element.

01:04:41.200 --> 01:04:44.900
Working with Java objects across
the JNI is not as easy as just

01:04:44.900 --> 01:04:47.830
referencing them using open and
closed brackets like you're used to.

01:04:48.060 --> 01:04:51.590
You have to actually set
object array element in here.

01:04:52.090 --> 01:04:55.180
So, we do this for every case.

01:04:55.180 --> 01:04:59.550
Now you can set,
you can pass in one element in here,

01:04:59.550 --> 01:05:01.070
or you can pass in a series of elements.

01:05:01.200 --> 01:05:03.700
There's matching functions
for both of those.

01:05:03.770 --> 01:05:06.450
And when we're done here,
we go ahead and we delete

01:05:06.460 --> 01:05:08.200
the local ref to the string.

01:05:08.200 --> 01:05:14.270
This is different from a global ref,
but it's more cleanup work that's

01:05:14.270 --> 01:05:14.270
necessary when you're creating objects.

01:05:14.750 --> 01:05:17.130
And now we do our callback.

01:05:17.150 --> 01:05:20.730
And much like we had the
Cocoa color change callback,

01:05:20.730 --> 01:05:23.140
we have the open finish method.

01:05:23.280 --> 01:05:24.930
And we're going to
call that back in Java,

01:05:24.930 --> 01:05:26.870
and I'll show you up here
what that looked like.

01:05:27.390 --> 01:05:28.570
Fire Open Sheet Finish.

01:05:28.670 --> 01:05:31.700
So let's see what that
looks like on the Java side.

01:05:31.700 --> 01:05:34.550
We're jumping back and forth.

01:05:34.740 --> 01:05:36.830
So here is...

01:05:38.100 --> 01:05:50.900
[Transcript missing]

01:05:51.070 --> 01:05:53.940
"But, just for fun, we'll do it again.

01:05:54.310 --> 01:05:55.840
And you can see I've got some stuff here.

01:05:55.840 --> 01:05:58.000
So I'll show you what I was
talking about with that diagram.

01:05:58.000 --> 01:06:00.620
It may have been a lot to
swallow the first time,

01:06:00.650 --> 01:06:03.670
but we'll show you exactly
what we mean in a second."

01:06:08.400 --> 01:06:12.540
And as soon as this comes up,
I can show you when I just

01:06:12.540 --> 01:06:14.530
do Command-O for open.

01:06:14.630 --> 01:06:19.210
And you notice because of the
asynchronous stuff that we've done here,

01:06:19.210 --> 01:06:23.680
I can still resize this window despite
the fact that we have gone ahead and

01:06:23.690 --> 01:06:26.950
shown a sheet using a Java callback.

01:06:26.970 --> 01:06:32.810
If we were doing-- if we were failing
to block-- if we were blocking in our

01:06:32.810 --> 01:06:36.830
performSelector on main thread call,
this would give us some problems

01:06:36.830 --> 01:06:40.060
because the resize would
not be able to be processed.

01:06:40.170 --> 01:06:43.270
We're busy waiting for
this sheet to go away.

01:06:43.830 --> 01:06:48.480
And so, I click open,
that asynchronous call on the Cocoa side

01:06:48.600 --> 01:06:53.980
for open panel did end gets called,
which goes ahead and checks whether

01:06:54.130 --> 01:06:58.440
I cancelled or selected a file,
and then we see down here

01:06:58.440 --> 01:07:00.400
user cancelled open save.

01:07:01.040 --> 01:07:04.860
So let's see what I was talking
about earlier with these.

01:07:05.010 --> 01:07:09.950
I have this handy call
here called deadlock.

01:07:11.200 --> 01:07:15.380
And what we're going to do instead of the
good citizen thing of an invoke later,

01:07:15.380 --> 01:07:19.320
we're just going to call back
our open sheet finished handler,

01:07:19.320 --> 01:07:21.310
which is, again,
going to show that J option

01:07:21.410 --> 01:07:22.870
pane with our return value.

01:07:22.880 --> 01:07:25.370
So we're just going to do that
from wherever we happen to be

01:07:25.370 --> 01:07:26.660
when we get this call back.

01:07:26.660 --> 01:07:30.360
And we already know that this call
back occurs on the app kit thread.

01:07:30.560 --> 01:07:31.380
So here we are.

01:07:31.380 --> 01:07:35.010
We're getting a call back from app kit,
and we're going to try to show an

01:07:35.010 --> 01:07:40.100
AWT dialogue from the app kit thread,
a blocking one.

01:07:40.100 --> 01:07:40.900
Let's build again.

01:07:40.980 --> 01:07:41.910
And I have an error.

01:07:41.940 --> 01:07:43.730
What did I do wrong?

01:07:51.890 --> 01:08:00.800
One more time.

01:08:00.800 --> 01:08:02.800
Luckily, I'm a little ahead of time,
so if we have a problem,

01:08:02.800 --> 01:08:07.790
we can just do this again.

01:08:07.790 --> 01:08:07.790
Okay.

01:08:08.470 --> 01:08:09.370
This side's clean.

01:08:09.380 --> 01:08:10.630
We haven't changed anything here.

01:08:10.640 --> 01:08:13.520
Now what we're changing is the callback.

01:08:13.620 --> 01:08:17.750
Now when I click this Open function,
we get that callback from Cocoa.

01:08:17.810 --> 01:08:21.170
And when we talk to Java again,
we're no longer doing the

01:08:21.170 --> 01:08:22.220
event queue invoke later.

01:08:22.360 --> 01:08:24.520
So we're going to go ahead
and try to show a J option

01:08:24.560 --> 01:08:26.880
pane from the AppKit thread.

01:08:26.910 --> 01:08:30.940
And yeah,
we're not going to get too far there.

01:08:30.960 --> 01:08:33.240
And there's our trusty friend,
the beach ball.

01:08:33.290 --> 01:08:39.130
And so the reason this is happening is,
let's go ahead and have a look.

01:08:39.260 --> 01:08:42.150
If you were at the develop, debug,
and deploy session this morning,

01:08:42.360 --> 01:08:44.740
you would have learned how to do this.

01:08:44.740 --> 01:08:47.660
We can get our JSheets process ID, 1170.

01:08:47.660 --> 01:08:51.000
And I do a kill-quit 1170.

01:08:51.000 --> 01:08:51.500
Is that right?

01:08:51.500 --> 01:08:52.930
Was that the right PID?

01:08:52.940 --> 01:08:54.340
We'll find out.

01:08:54.340 --> 01:08:56.590
And here's our thread dump.

01:08:57.120 --> 01:08:59.900
Now let's see what's going on here.

01:08:59.900 --> 01:09:01.200
Here's our event queue.

01:09:01.200 --> 01:09:03.420
It's doing some kind of
container validation.

01:09:03.420 --> 01:09:04.920
That's not something that we did.

01:09:05.000 --> 01:09:09.120
That's just something that's normally
going on in the AWT right now.

01:09:09.120 --> 01:09:13.800
And here's what I told
you to look out for.

01:09:13.800 --> 01:09:19.520
You don't ever want to see your code
sitting on the AWT-AppKit thread,

01:09:19.520 --> 01:09:19.520
because what has ended up
happening was here is our

01:09:19.770 --> 01:09:25.430
Here's our open sheet
finished callback from Cocoa.

01:09:25.430 --> 01:09:30.260
And we've gone ahead and
shown a Joption pane,

01:09:30.260 --> 01:09:36.330
which is going to go ahead and
try to get the AWT-TrueLock,

01:09:36.640 --> 01:09:41.580
which unfortunately is being
held by the AWT-Queue already.

01:09:41.580 --> 01:09:41.580
And because we're busy blocking
the AppKit thread with this,

01:09:41.910 --> 01:09:50.180
AWT cannot go ahead down
into the Cocoa world and do

01:09:50.180 --> 01:09:50.180
this component validation.

01:09:50.180 --> 01:09:50.180
So there's your classic deadlock.

01:09:51.390 --> 01:09:52.270
Oops.

01:09:52.430 --> 01:09:54.190
All settled by using an invoke later.

01:09:54.350 --> 01:09:57.340
So let's see the opposite,
or not the opposite,

01:09:57.420 --> 01:09:59.280
but the other way around.

01:09:59.300 --> 01:10:01.850
Let's change this back to false.

01:10:04.400 --> 01:10:05.610
So here's the Cocoa example.

01:10:05.660 --> 01:10:13.380
Now instead of doing a perform
selector on main thread,

01:10:13.380 --> 01:10:16.760
we're just going to go ahead and
call the show open panel directly.

01:10:16.760 --> 01:10:18.680
And again,
this is in response to an action

01:10:18.740 --> 01:10:21.060
performed on that J menu item.

01:10:21.100 --> 01:10:23.800
So we're going to go ahead and just
right from our action performed,

01:10:23.800 --> 01:10:26.980
right from the AWT thread,
call into AppKit to

01:10:27.040 --> 01:10:28.170
try to show this sheet.

01:10:28.180 --> 01:10:31.200
And let's see how that goes.

01:10:31.200 --> 01:10:32.500
That goes pretty well.

01:10:32.500 --> 01:10:40.770
I wonder if I-- make sure
I actually built the bad stuff.

01:10:58.800 --> 01:11:02.990
Oh, yeah,
so I was expecting to see a sheet,

01:11:03.130 --> 01:11:05.800
and instead I saw a crash.

01:11:05.800 --> 01:11:12.900
So you get the general idea of, you know,
whether it be a hang or a crash,

01:11:12.900 --> 01:11:18.040
if you don't play by these rules,
you're not going to

01:11:18.040 --> 01:11:20.500
get what you expected.

01:11:20.500 --> 01:11:22.050
That's practically guaranteed.

01:11:22.050 --> 01:11:22.050
And I think we can go
back to the slides now.

01:11:24.310 --> 01:11:27.300
Okay, so troubleshooting our deadlocks.

01:11:27.300 --> 01:11:31.800
You know,
you saw the kill-dash-quit command.

01:11:31.800 --> 01:11:33.700
You saw it this morning in Develop,
Debug, Deploy.

01:11:33.700 --> 01:11:35.680
You saw me do it right there.

01:11:35.680 --> 01:11:39.470
In order to troubleshoot the native side,
if you end up locking

01:11:39.470 --> 01:11:42.580
up your native code,
you need to use GDB.

01:11:42.580 --> 01:11:46.890
And there's a couple useful commands,
namely the backtrace.

01:11:47.120 --> 01:11:50.300
command, which gives you a dump
of the current thread,

01:11:50.300 --> 01:11:55.450
which is, in the case of a deadlock,
possibly the one that you want to see,

01:11:55.630 --> 01:11:56.900
see where it is.

01:11:56.900 --> 01:11:59.620
And then there is the thread
apply all backtrace command

01:11:59.620 --> 01:12:01.370
or T-A-A-B-T in shorthand.

01:12:01.370 --> 01:12:04.780
And this will print everything,
all of the native threads.

01:12:04.780 --> 01:12:08.000
So that will be able to tell you
maybe where your code is hung up

01:12:08.000 --> 01:12:10.400
and where you may have gone wrong.

01:12:10.400 --> 01:12:13.700
And even from GDB,
you can get that kill-dask-quit

01:12:13.940 --> 01:12:17.060
style right from the same utility.

01:12:17.060 --> 01:12:20.530
If you pass in the call void PS,
just like you see it here,

01:12:20.660 --> 01:12:23.540
you type that into GDB,
the PS command will give you a

01:12:23.540 --> 01:12:28.720
backtrace of the current Java thread,
which may or may not be useful.

01:12:28.720 --> 01:12:32.130
In the classic deadlock case,
the Java thread that's hung is

01:12:32.340 --> 01:12:35.700
probably the one where you forgot to
do your invoke later or are holding

01:12:35.700 --> 01:12:37.100
on to something you shouldn't be.

01:12:37.130 --> 01:12:40.500
And then also if you want
to print all of the threads,

01:12:40.500 --> 01:12:43.720
you just call PSS,
which gives you all of them.

01:12:43.720 --> 01:12:44.860
So some tips.

01:12:44.940 --> 01:12:48.920
To store your native pointers, again,
use longs.

01:12:48.920 --> 01:12:53.370
And the creatensview kind of hits
the creatensview long function

01:12:53.370 --> 01:12:55.740
kind of hits this point home.

01:12:55.740 --> 01:12:58.270
But if you're just doing other
things to create native structs or

01:12:58.270 --> 01:13:01.490
whatever and you need to pass those
back up to Java for later use,

01:13:01.490 --> 01:13:03.820
make sure you store them as Java longs.

01:13:03.820 --> 01:13:07.110
Create a cache at class load time
when system load library is called.

01:13:07.110 --> 01:13:10.140
It will save you a lot of
time and trouble for when you

01:13:10.140 --> 01:13:12.100
need those callbacks later.

01:13:12.100 --> 01:13:15.820
And because the JMethodIDs are
valid as long as the class does,

01:13:15.820 --> 01:13:17.520
you can safely cache them.

01:13:17.520 --> 01:13:19.540
And be careful with your global refs.

01:13:19.760 --> 01:13:22.070
Make sure everywhere you
have a clear creation point,

01:13:22.070 --> 01:13:24.450
there is a clear deletion point
that you know will be hit.

01:13:24.820 --> 01:13:27.800
Otherwise, you're going to start leaking
objects on the Java side.

01:13:27.800 --> 01:13:30.650
If you have a component,
you can do this in remove notify.

01:13:30.740 --> 01:13:36.110
It's a very reliable and clean
and sensible place to do it.

01:13:36.280 --> 01:13:40.800
So doing specific work with Mac OS X,
if you are down in the native side,

01:13:40.800 --> 01:13:44.280
you need to get something inside --
from inside your Java application,

01:13:44.540 --> 01:13:49.550
your first thought might be to pass this
huge URL string down into -- across the

01:13:49.670 --> 01:13:52.410
JNI that you then had to parse using C.

01:13:52.410 --> 01:13:55.780
In fact, you can just go ahead and
use the CFBundle APIs.

01:13:55.850 --> 01:13:58.030
If you have something that
you know is in contents,

01:13:58.100 --> 01:14:00.740
resources, Java,
go ahead and pass in the resources

01:14:00.740 --> 01:14:05.360
constant to the appropriate CFBundle API,
and it will get what you need.

01:14:05.360 --> 01:14:07.400
And again,
once you start playing these games,

01:14:07.450 --> 01:14:10.150
you are a Cocoa programmer,
so you need to remember all the memory

01:14:10.150 --> 01:14:13.410
management stuff that goes along,
not just the threading, but the retain,

01:14:13.410 --> 01:14:15.620
the release, the auto-release.

01:14:15.620 --> 01:14:17.560
The one exception is Cocoa component.

01:14:17.560 --> 01:14:21.720
You need to go ahead and retain
that for us as long as we need it.

01:14:21.720 --> 01:14:26.140
Threads that you created need to
have an auto-release pool in them.

01:14:26.230 --> 01:14:28.480
And you may -- if you look
into the JSheets code,

01:14:28.600 --> 01:14:31.340
you'll see that when we go
ahead and create our sheets,

01:14:31.340 --> 01:14:35.470
we actually create an auto-release pool
there because we can't necessarily be

01:14:35.470 --> 01:14:38.060
guaranteed that there is one in place.

01:14:38.060 --> 01:14:42.090
The only exception for that is
create NSView and AWT message

01:14:42.220 --> 01:14:46.560
because we know that those are
happening on the AppKit thread.

01:14:46.600 --> 01:14:49.410
And another quick tip,
you can use the throw

01:14:49.540 --> 01:14:51.060
new function in JNI.

01:14:51.120 --> 01:14:53.010
If you're doing
Objective-C exception handling,

01:14:53.010 --> 01:14:56.080
you can go ahead and create a
Java exception and throw that back up,

01:14:56.160 --> 01:14:59.070
you know,
with whatever message it may contain.

01:15:00.300 --> 01:15:04.330
So VM invocation, real quick,
I think I just hit zero.

01:15:04.470 --> 01:15:08.700
So it's a very standard call,
JNI create Java VM.

01:15:08.700 --> 01:15:12.290
This is pretty standard to
do across multiple platforms.

01:15:12.320 --> 01:15:15.620
It's C code,
so it's not compile portable.

01:15:15.620 --> 01:15:17.240
But the code should be very similar.

01:15:17.240 --> 01:15:19.890
You create a struct of
VM initialization args.

01:15:20.030 --> 01:15:23.230
You pass in JNI version
1.4 if you want 1.4.

01:15:23.440 --> 01:15:26.850
The key on Mac OS X is to make
sure you not start the virtual

01:15:26.850 --> 01:15:28.200
machine on the main thread.

01:15:28.200 --> 01:15:29.760
Don't do it from your main method.

01:15:29.970 --> 01:15:33.500
So if you're in a CoCoL application,
go ahead and call detached

01:15:33.630 --> 01:15:35.320
new thread with selector.

01:15:35.510 --> 01:15:37.920
And in this case,
your selector is going to be the method

01:15:37.920 --> 01:15:41.230
that actually calls JNI create Java VM.

01:15:41.290 --> 01:15:44.890
Now for 1.5, we have an environment
variable that you need to set.

01:15:45.000 --> 01:15:46.840
Just do a simple set end.

01:15:46.860 --> 01:15:52.630
And you set Java JVM version
to J2SE5 or 1.5.

01:15:52.670 --> 01:15:55.770
And our updated samples
code simple Java launcher,

01:15:56.090 --> 01:15:58.500
which uses core foundation
to start up a Java VM,

01:15:58.650 --> 01:16:01.020
and Java splash stream,
which has a Cocoa example,

01:16:01.170 --> 01:16:04.200
both of those have been updated
to do the new 1.5 invocation.

01:16:04.390 --> 01:16:06.630
So take a look at those.

01:16:07.090 --> 01:16:11.490
And again, I just want to talk a little
bit about the Intel transition,

01:16:11.490 --> 01:16:15.260
we did that in front of
you in the first demo.

01:16:15.260 --> 01:16:19.570
But start building your
JNI libraries as universal now.

01:16:19.700 --> 01:16:22.920
If you go home today and you're
interested in doing this JNI work,

01:16:22.920 --> 01:16:25.250
go ahead and start checking those boxes.

01:16:25.260 --> 01:16:27.610
I know it's a lot of work.

01:16:27.770 --> 01:16:29.660
Check the check boxes,
build the libraries,

01:16:29.710 --> 01:16:33.280
and you'll be ready to go
for the foreseeable future.

01:16:33.390 --> 01:16:36.890
Something to keep in mind,
if you are writing a native launch

01:16:37.010 --> 01:16:41.760
or using JNI Create Java VM,
that will not work in Rosetta.

01:16:41.760 --> 01:16:45.570
You need to have a universal binary if
you're building a native application

01:16:45.580 --> 01:16:47.520
that's going to start a Java VM.

01:16:47.620 --> 01:16:49.880
So if that's something you
are interested in doing,

01:16:49.880 --> 01:16:52.570
the message here, and I'm sure it's been
the message everywhere,

01:16:52.570 --> 01:16:54.700
is build universal binaries.

01:16:54.730 --> 01:16:56.400
And for the most part,
you don't really need to be

01:16:56.530 --> 01:16:58.490
too worried about your data.

01:16:58.550 --> 01:17:01.260
But there are big endian
versus little endian issues,

01:17:01.290 --> 01:17:03.230
depending on the kind of
data that you're passing.

01:17:03.380 --> 01:17:06.900
So if you're going to be packing--
you saw when I did my color

01:17:06.900 --> 01:17:14.310
notification across the bridge from
the NSColorWell to the J label,

01:17:14.310 --> 01:17:19.160
I passed each of those RGBA values
independently as floats.

01:17:19.200 --> 01:17:20.630
That's the better thing to do.

01:17:20.680 --> 01:17:23.990
The alternative may have been to
go ahead and pack all of those

01:17:24.040 --> 01:17:25.800
into a single Jint or Jlong.

01:17:26.030 --> 01:17:28.200
And if you're going to go
ahead and start packing things,

01:17:28.300 --> 01:17:31.200
then you're going to run into
endian issues when you go

01:17:31.200 --> 01:17:34.320
across different architectures.

01:17:34.320 --> 01:17:36.800
We'll be talking about this
in more detail in tomorrow's

01:17:36.950 --> 01:17:39.950
virtual machine exposed session,
which I don't think is on your calendar

01:17:39.950 --> 01:17:41.750
because it was a secret session.

01:17:41.890 --> 01:17:44.060
So if you really have
concerns about this stuff,

01:17:44.240 --> 01:17:46.580
come to the session tomorrow.

01:17:46.840 --> 01:17:51.630
And for more information,
Alan Samuel is our Java evangelist,

01:17:51.630 --> 01:17:54.000
and Wiley is our Java product manager.

01:17:54.100 --> 01:17:55.160
He's the marketing man.

01:17:55.230 --> 01:17:58.200
You can contact either of these
guys for questions or concerns.

01:17:58.250 --> 01:18:03.850
And if you're real confused about
all this stuff I was talking about,

01:18:03.850 --> 01:18:08.320
then you probably need to
talk to me or my counterpart,

01:18:08.320 --> 01:18:11.800
Ted Jouzevic, who you saw this morning.

01:18:11.800 --> 01:18:12.520
And you can get a hold of us
by going to DTS@apple.com.

01:18:12.720 --> 01:18:13.760
Related sessions.

01:18:13.950 --> 01:18:16.600
Well, unfortunately,
these have all happened.

01:18:16.600 --> 01:18:20.160
But when you guys have access
to your online content,

01:18:20.160 --> 01:18:22.600
you can go ahead and look at these.

01:18:22.870 --> 01:18:24.600
There's two of them, actually.

01:18:24.600 --> 01:18:32.090
The Java Performance and
Graphics Tuning is tomorrow at 9,

01:18:32.090 --> 01:18:33.710
followed by the
VM Performance session at 10:30,

01:18:33.710 --> 01:18:33.710
which is actually a lab.

01:18:34.090 --> 01:18:35.950
and sample code other resources.

01:18:35.960 --> 01:18:40.640
There are a lot of resources that I'd
like to point you to for this session.

01:18:40.640 --> 01:18:44.420
Obviously the samples
that came with the talk.

01:18:44.460 --> 01:18:48.060
There are other things like
the OS X adapter sample,

01:18:48.070 --> 01:18:50.840
which one of the things you'll notice
when you look at these samples,

01:18:50.840 --> 01:18:54.640
the ones that are applicable,
like the J Color Chooser and the Sheets,

01:18:54.640 --> 01:18:57.940
those are actually detecting
what platform they're on,

01:18:58.160 --> 01:19:00.700
and in the case that it's
not on Mac OS X Tiger,

01:19:00.870 --> 01:19:03.690
it doesn't even load the
class with the JNI content.

01:19:03.700 --> 01:19:05.440
So in other words,
these built applications

01:19:05.550 --> 01:19:07.970
will run on Windows,
despite the fact that

01:19:07.970 --> 01:19:10.560
they have JNI libraries,
because the libraries won't even

01:19:10.560 --> 01:19:12.380
be loaded on the other platforms.

01:19:12.460 --> 01:19:19.200
So you can write platform-specific code
without sacrificing your portability,

01:19:19.200 --> 01:19:20.940
and these examples will
show you how to do that.

01:19:20.940 --> 01:19:24.120
We also have debugging Tech Notes.

01:19:24.240 --> 01:19:27.200
We have other porting Tech Notes that
you're gonna want to look at,

01:19:27.200 --> 01:19:29.440
and you can see them
linked to this session.
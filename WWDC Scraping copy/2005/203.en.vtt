WEBVTT

00:00:00.530 --> 00:00:03.840
My name is Chris Rogers and
Michael Hopkins and I are going

00:00:03.840 --> 00:00:07.960
to show you how to make an effect
Audio Unit and a really nice

00:00:07.960 --> 00:00:10.700
Cocoa view to go along with it.

00:00:12.800 --> 00:00:15.090
But first,
for those of you who don't really

00:00:15.100 --> 00:00:18.900
know what Audio Units are about,
and for those who do, it won't take long,

00:00:18.900 --> 00:00:23.630
I'm going to take a brief tour
through what an Audio Unit is.

00:00:23.700 --> 00:00:29.550
So, an Audio Unit is a plug-in
specification for OS X.

00:00:29.550 --> 00:00:33.930
It's packaged as a component,
and as such,

00:00:33.930 --> 00:00:38.910
an Audio Unit host would use a
component manager to discover the

00:00:38.910 --> 00:00:44.120
component's Audio Units available
on the system and load them up.

00:00:47.100 --> 00:00:49.380
Why should you write an Audio Unit?

00:00:49.470 --> 00:00:53.200
Well, first of all,
it's a specification that's supported

00:00:53.200 --> 00:00:56.820
by all the top audio applications,
or most of them,

00:00:56.840 --> 00:01:01.170
and quite a large number of
other interesting applications.

00:01:01.210 --> 00:01:04.450
So if your application isn't listed here,
your favorite application,

00:01:04.450 --> 00:01:05.400
then don't be offended.

00:01:05.400 --> 00:01:08.430
There are quite a lot of
really cool ones out there.

00:01:09.980 --> 00:01:12.900
And it adds value to your technology.

00:01:12.910 --> 00:01:17.420
If you have a look at any of the
audio forums out there on the web,

00:01:17.620 --> 00:01:22.200
you'll see that musicians
who use OS X are really,

00:01:22.240 --> 00:01:26.920
really hungry for new plug-ins
to run in their Audio Unit hosts.

00:01:27.040 --> 00:01:31.180
So they know all about Audio Units
and they want people to write them.

00:01:31.190 --> 00:01:37.550
So it's a good money-making possibility,
too.

00:01:38.690 --> 00:01:41.040
So there are a variety of
different types of Audio Units,

00:01:41.040 --> 00:01:45.700
and the type that we're going to
concentrate on today is the effect type.

00:01:45.700 --> 00:01:47.230
But there are a number
of other different types,

00:01:47.230 --> 00:01:51.440
and we'll take a quick walk
through those different types.

00:01:51.480 --> 00:01:55.440
So the effect type, first of all,
just takes audio input,

00:01:55.510 --> 00:01:57.490
processes it in some way.

00:01:57.540 --> 00:02:01.360
Example is a reverb for
simulating a concert hall,

00:02:01.600 --> 00:02:06.840
graphic EQ for changing
frequencies around bass and treble.

00:02:06.840 --> 00:02:10.660
Instruments are for
simulating synthesizers,

00:02:10.820 --> 00:02:12.380
software synthesizers.

00:02:12.390 --> 00:02:15.330
Couple different examples there.

00:02:15.670 --> 00:02:19.400
A new type of Audio Unit in Tiger is
a generator that takes no input,

00:02:19.480 --> 00:02:21.060
but it just produces output.

00:02:21.120 --> 00:02:27.840
And we ship a couple of those in Tiger,
the file player and AUNet receive, which,

00:02:27.940 --> 00:02:32.480
along with AUNet send,
is able to stream high-quality

00:02:32.480 --> 00:02:35.500
audio across the network.

00:02:36.030 --> 00:02:39.510
There's another type, Mixer, which,
as its name implies,

00:02:39.630 --> 00:02:42.950
it just takes a bunch of audio
streams and mixes in some way.

00:02:43.180 --> 00:02:47.660
And there are a couple different
types that we support on Tiger.

00:02:47.660 --> 00:02:53.800
The 3D Mixer is, for example,
used as a basis of our

00:02:53.800 --> 00:03:01.350
Open AL implementation,
which Bob Aaron is going to talk

00:03:01.350 --> 00:03:01.620
about in a later presentation.

00:03:02.760 --> 00:03:06.200
Output Unit is used to
talk to audio hardware,

00:03:06.200 --> 00:03:10.730
so it would be the final stage
in a graph of these Audio Units

00:03:10.830 --> 00:03:12.200
that are chained together.

00:03:12.410 --> 00:03:16.200
Format Converter can do things
like sample rate conversion,

00:03:16.200 --> 00:03:21.200
bit depth conversion, or time stretching,
that type of operation.

00:03:21.420 --> 00:03:28.200
And finally, Offline Unit will process
audio in a non-linear manner,

00:03:28.200 --> 00:03:32.070
perhaps even backwards,
like an Audio Unit that would

00:03:32.070 --> 00:03:35.010
take a file and reverse it.

00:03:35.480 --> 00:03:38.840
So, why don't we actually see
what an Audio Unit looks

00:03:38.840 --> 00:03:41.470
like running in a demo here.

00:03:41.580 --> 00:03:44.990
So, could we switch to the demo machine,
please?

00:03:56.620 --> 00:04:00.570
I'm going to be using the
AU Lab hosting application,

00:04:00.830 --> 00:04:04.840
which actually ships on your system.

00:04:04.840 --> 00:04:05.970
You should have it installed there.

00:04:06.100 --> 00:04:11.120
I'm going to launch a
document that I made--oops.

00:04:11.550 --> 00:04:12.130
Wrong icon.

00:04:12.240 --> 00:04:16.980
This is the AU Lab document.

00:04:16.980 --> 00:04:17.000
Okay.

00:04:18.470 --> 00:04:21.550
So what we see here is
three separate windows.

00:04:21.790 --> 00:04:24.060
There's a mixer window here.

00:04:24.180 --> 00:04:27.890
Here I have a window which is the
user interface to the file player,

00:04:27.890 --> 00:04:29.820
which I mentioned before.

00:04:30.070 --> 00:04:37.840
And right here, we have a generic view
on a filter effect,

00:04:37.870 --> 00:04:41.840
which is actually what we're going
to be taking you through today,

00:04:41.840 --> 00:04:45.320
showing you how to build this
resonant low-pass filter.

00:04:45.320 --> 00:04:50.320
And this is--this right here
is just a basic user interface.

00:04:50.320 --> 00:04:51.650
It's called a generic view.

00:04:52.020 --> 00:04:57.500
And the generic view is able to--to, um,

00:04:57.990 --> 00:05:00.740
To work with any effect Audio Unit.

00:05:00.930 --> 00:05:06.140
So even if you don't write a custom UI,
the system is capable of

00:05:06.140 --> 00:05:07.900
bringing up a generic view.

00:05:07.990 --> 00:05:11.010
So why don't I play a loop
here and I'll just play with

00:05:11.180 --> 00:05:14.640
the filter for a little while.

00:05:14.740 --> 00:05:18.630
Sweep the cutoff frequency.

00:05:25.800 --> 00:05:30.080
Okay.

00:05:30.560 --> 00:05:33.400
Also, we can add another effect.

00:05:33.400 --> 00:05:36.440
If you click over here,
it brings up a pop-up menu of all

00:05:36.440 --> 00:05:40.040
of the different effect Audio Units
that are installed on the system.

00:05:40.240 --> 00:05:44.930
So I'm going to add a reverb
here just really quickly.

00:05:45.370 --> 00:05:46.500
That's also a generic view.

00:05:46.500 --> 00:05:50.860
You see that the reverb has more
parameters than the filter does.

00:05:59.690 --> 00:06:05.100
So, that's pretty simple.

00:06:05.660 --> 00:06:10.000
The user interface for our filter,
though, it's a little bit boring,

00:06:10.000 --> 00:06:13.600
so maybe we can do something
more interesting than that.

00:06:13.600 --> 00:06:14.830
We'll see a little bit later.

00:06:14.850 --> 00:06:19.160
Mike will show us how
to make a custom view.

00:06:19.160 --> 00:06:23.080
Can we go back to slides, please?

00:06:27.380 --> 00:06:32.230
So, I'd like to take a little
bit more of a step back,

00:06:32.230 --> 00:06:36.900
look more abstractly at how
hosts deal with Audio Units.

00:06:37.060 --> 00:06:42.300
So, off to the left we see
the AU Lab mixer window,

00:06:42.300 --> 00:06:46.190
but this could represent
any host application.

00:06:46.330 --> 00:06:50.200
When I chose the reverb,
I added a reverb effect from a list

00:06:50.200 --> 00:06:58.050
of Audio Units in a pop-up menu.

00:06:59.040 --> 00:06:59.130
What the host does at
that time is it will

00:06:59.330 --> 00:07:02.200
It will open the component,
the Audio Unit component,

00:07:02.200 --> 00:07:07.210
using the Component Manager and then
call Audio Unit Initialize on it in

00:07:07.260 --> 00:07:10.650
order to initialize the Audio Unit.

00:07:11.490 --> 00:07:14.740
It will then typically,
in a hosting application,

00:07:14.770 --> 00:07:18.500
bring up a window for the user interface.

00:07:18.830 --> 00:07:20.540
And in this case,
it's showing the generic

00:07:20.650 --> 00:07:21.640
view that we just saw.

00:07:21.720 --> 00:07:24.310
But if the Audio Unit supports
a custom view,

00:07:24.310 --> 00:07:28.590
then the host will instantiate the
custom view in the window instead.

00:07:28.690 --> 00:07:33.640
And the way that the host knows
if the Audio Unit supports a

00:07:33.640 --> 00:07:36.000
custom view is by asking it.

00:07:36.260 --> 00:07:40.000
And we'll see exactly how it
does that in a little while.

00:07:40.780 --> 00:07:44.350
The host gives a reference
to the Audio Unit,

00:07:44.560 --> 00:07:47.830
or a reference to the view.

00:07:48.370 --> 00:07:52.900
It gives it a link to the Audio Unit so
that the viewer is able to communicate

00:07:52.900 --> 00:07:56.880
with the Audio Unit to display
its parameters and manipulate

00:07:56.880 --> 00:07:59.170
the Audio Unit in various ways.

00:08:01.700 --> 00:08:05.170
Another type of Audio Unit that
I talked about briefly was the

00:08:05.250 --> 00:08:07.440
Instrument Software Synthesizer.

00:08:07.440 --> 00:08:10.250
So if you're a musician,
you could be playing on a MIDI keyboard

00:08:10.680 --> 00:08:13.770
and those MIDI events that you're
playing on the keyboard would

00:08:13.780 --> 00:08:15.570
go through the Core MIDI system.

00:08:15.840 --> 00:08:23.100
The host would receive those
Core MIDI events and dispatch

00:08:23.100 --> 00:08:23.100
them to the instrument.

00:08:24.560 --> 00:08:28.330
A mixer audio unit could be used as
a basis of a mixing engine in a host,

00:08:28.510 --> 00:08:33.500
which it is, in fact, in AU Lab.

00:08:33.760 --> 00:08:39.060
And then the output of that mixer
is sent to the output unit and

00:08:39.060 --> 00:08:47.600
then on to the Core Audio HAL,
down through the drivers and

00:08:47.600 --> 00:08:47.600
to the audio device itself.

00:08:49.730 --> 00:08:54.580
So a component is packaged
as a bundle on OS X.

00:08:54.580 --> 00:08:55.730
An audio unit is a component.

00:08:55.940 --> 00:08:59.640
So it has a .component extension.

00:08:59.810 --> 00:09:03.880
And in the finder,
it just appears as a simple file.

00:09:03.970 --> 00:09:05.100
But it's actually a directory.

00:09:05.100 --> 00:09:08.510
And inside of there,
there are several files which are

00:09:08.620 --> 00:09:10.840
kind of interesting to look at.

00:09:10.840 --> 00:09:15.400
And many of these files are the
same for any type of bundle.

00:09:15.460 --> 00:09:17.890
Some are specific to audio units.

00:09:17.990 --> 00:09:23.680
The Info.plist file contains
the bundle identifier and

00:09:24.110 --> 00:09:27.840
version number of the bundle,
some other information.

00:09:27.840 --> 00:09:32.000
Inside of the Mac OS directory
is the executable,

00:09:32.020 --> 00:09:36.080
where the code of the audio unit lives.

00:09:36.080 --> 00:09:41.670
Inside of the resources folder,
if there's a custom view,

00:09:41.670 --> 00:09:42.580
the view can go there.

00:09:42.580 --> 00:09:45.880
And we see there,
Cocoa Filter View Bundle.

00:09:45.880 --> 00:09:47.500
There's some localized resources.

00:09:47.520 --> 00:09:53.080
And in the .rsrc file,
there's some component information,

00:09:53.160 --> 00:09:57.650
such as a component type, subtype,
manufacturer, component name,

00:09:57.650 --> 00:09:59.930
and that type of thing.

00:10:00.410 --> 00:10:04.270
The audio unit, once it's built,
it must be installed in

00:10:04.270 --> 00:10:05.800
a particular location.

00:10:05.930 --> 00:10:08.620
And there are two main
places that that could go,

00:10:08.890 --> 00:10:12.800
either in the ~/library or /library.

00:10:12.800 --> 00:10:16.650
And the only difference is
that in the ~/library location,

00:10:16.650 --> 00:10:20.650
the audio unit will only be
visible to that particular user.

00:10:20.800 --> 00:10:24.960
So if you have multiple users on the
machine and somebody else logs in,

00:10:24.960 --> 00:10:26.880
they won't see the audio unit.

00:10:26.880 --> 00:10:30.500
If you install it in a /library location,
then it will be visible system-wide

00:10:30.500 --> 00:10:33.510
no matter which user is logged on.

00:10:35.180 --> 00:10:40.160
So as a step in developing
your Audio Unit,

00:10:40.470 --> 00:10:43.550
it's really important to
validate that it works correctly.

00:10:43.560 --> 00:10:46.390
In the past,
digital audio workstation applications

00:10:46.590 --> 00:10:51.660
have had tremendous problems
with plugins crashing the system,

00:10:51.660 --> 00:10:52.860
really unstable plugins.

00:10:52.860 --> 00:10:58.250
And if you load up 10 or 15
various plugins into a hosting

00:10:58.860 --> 00:11:02.590
application and one of them crashes,
it's difficult to even know which

00:11:02.590 --> 00:11:04.260
one is crashing the system sometimes.

00:11:04.260 --> 00:11:06.080
It can be quite difficult.

00:11:06.210 --> 00:11:11.530
So we've put some effort into developing
a command line tool called AUVAL,

00:11:11.530 --> 00:11:17.260
which will put your Audio Unit through
kind of a torture test and really

00:11:17.320 --> 00:11:20.940
make sure that it will work
robustly in your host application.

00:11:20.980 --> 00:11:25.180
And we'll be using this command
line tool in a little while to

00:11:25.180 --> 00:11:32.310
actually see how we can validate
the filter Audio Unit that I demoed.

00:11:33.200 --> 00:11:36.940
So, covered a bit of background
about Audio Units in general.

00:11:36.950 --> 00:11:42.350
Why don't we see if we can move
on to actual code and looking at

00:11:42.350 --> 00:11:46.100
methods and that type of thing.

00:11:46.100 --> 00:11:50.110
Before we do that,
we would have to set up a project,

00:11:50.110 --> 00:11:50.820
an Xcode.

00:11:51.100 --> 00:11:55.600
Easiest way to do that is just
say "New Project" and then there's

00:11:55.670 --> 00:11:59.600
an Audio Unit template available
so you can choose that your new

00:11:59.730 --> 00:12:01.100
project is going to be an Audio Unit.

00:12:01.280 --> 00:12:05.100
Or, Audio Unit with a view,
either Carbon or Cocoa.

00:12:05.100 --> 00:12:09.310
It will set up your project with
all of the relevant source files so

00:12:09.460 --> 00:12:13.100
you can just essentially build and
you'll have a working Audio Unit.

00:12:13.100 --> 00:12:16.100
It doesn't do very much, but it works.

00:12:16.100 --> 00:12:19.080
Before you build though,
there are a couple things

00:12:19.130 --> 00:12:20.930
that you'll need to configure.

00:12:21.100 --> 00:12:24.760
In the resource file,
you'll need to set your component,

00:12:24.760 --> 00:12:27.100
subtype, manufacturer, and name.

00:12:27.280 --> 00:12:29.100
And I'll show you how to do
that in Xcode in a few minutes.

00:12:29.100 --> 00:12:35.760
And also, you'll need to configure
the Info.plist file so that

00:12:35.760 --> 00:12:41.100
the bundle identifier has
your company name in there.

00:12:42.860 --> 00:12:45.910
And some of you may be wondering, well,
what are the implications about building

00:12:45.910 --> 00:12:50.180
an Audio Unit on the Intel platform?

00:12:50.430 --> 00:12:52.600
Essentially, it just works.

00:12:52.790 --> 00:12:57.130
If you use our SDK-based
classes and support files,

00:12:57.590 --> 00:13:00.860
It will do all the right
things and build it for you.

00:13:00.930 --> 00:13:03.990
At Apple,
when we were working on porting our

00:13:04.000 --> 00:13:07.510
Audio Units over to the Intel platform,
we had to change, I think,

00:13:07.580 --> 00:13:10.490
one line in a resource file or something
like that to make this all work.

00:13:10.500 --> 00:13:15.290
So you'll be able to get this
up and running pretty quickly.

00:13:17.340 --> 00:13:20.540
So what kind of custom
code do you need to write?

00:13:20.540 --> 00:13:24.870
I mean, if we have all these
base classes and stuff,

00:13:25.640 --> 00:13:27.420
does most of the work,
but you still are going to have

00:13:27.510 --> 00:13:29.600
to implement some custom code,
of course.

00:13:29.740 --> 00:13:34.100
And the custom code mainly revolves
around dealing with parameters,

00:13:34.170 --> 00:13:37.600
properties, and signal processing.

00:13:37.600 --> 00:13:41.590
And I'll talk about each
of those in some detail.

00:13:42.910 --> 00:13:46.260
This is what the base
class hierarchy looks like.

00:13:46.260 --> 00:13:50.140
And we're mainly interested in
subclassing two of these classes,

00:13:50.240 --> 00:13:54.060
the AU kernel base and
the AU effect base.

00:13:54.550 --> 00:13:57.960
This is what the base
class hierarchy looks like.

00:13:57.960 --> 00:14:01.840
And we're mainly interested in
subclassing two of these classes,

00:14:01.840 --> 00:14:05.760
the AU kernel base and
the AU effect base.

00:14:17.200 --> 00:14:20.200
So getting into more
detail with AU Effect Base,

00:14:20.200 --> 00:14:22.340
when you subclass that,

00:14:23.380 --> 00:14:28.130
You're overriding methods for parameters,
properties, and factory presets,

00:14:28.220 --> 00:14:29.210
potentially.

00:14:29.320 --> 00:14:35.910
And what AU Effect Base does is
it instantiates several instances

00:14:36.360 --> 00:14:39.660
of your AU Kernel Base subclass.

00:14:39.790 --> 00:14:45.130
So AU Effect Base assumes that it's
doing end-to-end channel processing.

00:14:45.290 --> 00:14:47.940
So, for example,
two channels are two channels, stereo in,

00:14:48.050 --> 00:14:51.160
stereo out, or one-to-one, mono in,
mono out.

00:14:51.240 --> 00:14:56.740
If your Audio Unit is not like that,
such as maybe a stereoizer effect,

00:14:56.790 --> 00:15:01.240
it's mono in, stereo out,
then you wouldn't want

00:15:01.270 --> 00:15:02.580
to use AU Effect Base.

00:15:02.640 --> 00:15:09.180
You would subclass AU Base instead.

00:15:10.000 --> 00:15:14.240
In AU Kernel Base,
this is where you put your actual DSP,

00:15:14.270 --> 00:15:16.680
your signal processing code.

00:15:17.270 --> 00:15:21.000
And as I said,
AU Effect Base instantiates N different

00:15:21.060 --> 00:15:26.490
instances of your A kernel base subclass,
one per channel.

00:15:28.810 --> 00:15:30.580
So I mentioned parameters in passing.

00:15:30.640 --> 00:15:35.580
What parameters do is provide
real-time control on the processing.

00:15:35.580 --> 00:15:38.230
They're floating point values.

00:15:38.560 --> 00:15:44.740
They have a name, unit type, min, max,
default value, flags.

00:15:44.770 --> 00:15:49.300
And some examples are filter cutoff,
like we saw in the low

00:15:49.410 --> 00:15:50.980
pass filter that I demoed.

00:15:51.030 --> 00:15:54.420
And since that's a frequency,
it's a cutoff frequency,

00:15:54.460 --> 00:15:57.650
it would have a unit type of hertz.

00:15:57.980 --> 00:16:03.450
If you had a delay effect,
the delay time parameter would probably

00:16:03.690 --> 00:16:07.680
be unit type of milliseconds or seconds.

00:16:11.360 --> 00:16:14.830
To define a parameter,
you need to override the

00:16:15.060 --> 00:16:20.080
get parameter info method in
your AU Effect Base subclass.

00:16:20.080 --> 00:16:22.500
And in there,
what you do is you define the name,

00:16:22.640 --> 00:16:25.420
the unit type, the min, max,
default value, and flags.

00:16:25.460 --> 00:16:28.860
In addition to that,
in the constructor to your

00:16:28.860 --> 00:16:32.940
subclass to AU Effect Base,
you'll need to call set parameter

00:16:32.940 --> 00:16:34.460
for each of your parameters.

00:16:34.460 --> 00:16:37.450
And this has dual purpose.

00:16:37.650 --> 00:16:40.460
First of all, it defines the parameter.

00:16:40.550 --> 00:16:43.810
And second of all,
it gives it the initial value.

00:16:46.360 --> 00:16:53.320
Properties are a very versatile way
of getting information back and forth

00:16:53.500 --> 00:16:59.570
between audio unit and host or view.

00:16:59.640 --> 00:17:03.500
There are a bunch of required properties
that are implemented by the base classes,

00:17:03.620 --> 00:17:06.280
so you don't have to worry too
much about implementing those.

00:17:06.280 --> 00:17:09.300
Those are handled in
AU_Base and AU_EffectBase.

00:17:09.320 --> 00:17:15.150
But you're able to define custom
properties for passing arbitrary

00:17:15.210 --> 00:17:19.100
information back and forth between
your audio unit and your custom view.

00:17:19.100 --> 00:17:22.390
And we'll do exactly that in a minute.

00:17:23.320 --> 00:17:25.850
To define a property,
there are two methods that

00:17:25.850 --> 00:17:29.200
you'll need to subclass:
GetPropertyInfo and GetProperty.

00:17:29.200 --> 00:17:33.310
They're both methods of AU effect base.

00:17:35.760 --> 00:17:40.100
So I want to talk a little bit about
rendering because it's actually kind

00:17:40.100 --> 00:17:43.980
of at the crux of what Audio Units do.

00:17:44.170 --> 00:17:47.690
In a typical scenario,
rendering occurs on a

00:17:47.690 --> 00:17:52.620
continuous stream of audio,
continuous uninterrupted stream of audio.

00:17:52.760 --> 00:17:59.220
And what the host does is call
Audio Unit Render successively,

00:17:59.290 --> 00:18:05.000
time after time, multiple times,
to process slices of that audio stream.

00:18:05.200 --> 00:18:09.990
So when the host calls Audio Unit Render,
it provides a number of

00:18:09.990 --> 00:18:11.500
sample frames to process.

00:18:11.580 --> 00:18:16.040
So it may ask the Audio Unit to
render 512 sample frames.

00:18:16.070 --> 00:18:18.770
And then it will call the
Audio Unit again and ask

00:18:18.920 --> 00:18:21.470
to render the next 512,
and so on.

00:18:21.600 --> 00:18:25.680
But you shouldn't assume that it's
going to be 512 or any particular value,

00:18:25.720 --> 00:18:29.360
or that the number is going to
be the same from call to call.

00:18:29.690 --> 00:18:31.380
That's for the host to decide.

00:18:31.390 --> 00:18:34.070
And the Audio Unit is required
to render exactly the number

00:18:34.080 --> 00:18:37.510
that the host asks for.

00:18:37.570 --> 00:18:42.180
Also, the host is going to be
calling Audio Unit Render in

00:18:42.180 --> 00:18:44.540
a particular thread context.

00:18:44.630 --> 00:18:48.280
That may be in a real-time thread
talking to an audio device,

00:18:48.310 --> 00:18:51.100
or it may be in a
secondary feeder thread,

00:18:51.140 --> 00:18:57.040
or it may be in an offline context,
just processing a file.

00:18:57.450 --> 00:19:01.500
As an Audio Unit,
you are completely unaware of what

00:19:01.600 --> 00:19:03.480
thread context you're running in.

00:19:03.480 --> 00:19:08.770
And you shouldn't make any assumptions
about the thread that you are running in.

00:19:09.940 --> 00:19:14.760
Your job really is just to render the
audio and put the results into the audio

00:19:14.760 --> 00:19:17.570
buffer list that the host gives you.

00:19:17.940 --> 00:19:20.860
And for effects,
what happens is the Audio Unit,

00:19:20.920 --> 00:19:25.110
first of all, gets its input,
it pulls its input, and processes it,

00:19:25.200 --> 00:19:28.660
and then writes the output
into the audio buffer list.

00:19:28.670 --> 00:19:32.130
Now, I said that processing occurs
on a continuous stream of

00:19:32.200 --> 00:19:34.990
audio in a typical scenario.

00:19:35.130 --> 00:19:39.800
But what happens if the stream
is interrupted for some reason?

00:19:39.800 --> 00:19:44.040
And a case where that might be true
is in a digital audio workstation.

00:19:44.040 --> 00:19:45.100
You have a timeline change.

00:19:45.100 --> 00:19:46.360
You're playing along,
and all of a sudden,

00:19:46.360 --> 00:19:51.260
the user moves the timeline to
maybe the start of the track.

00:19:51.530 --> 00:19:55.420
Well, that's an interruption in
the continuity of the stream.

00:19:55.560 --> 00:19:58.630
So in that case,
the host is expected to call

00:19:58.950 --> 00:20:05.690
Audio Unit Reset on the Audio Unit,
muting or unmuting a track in

00:20:05.690 --> 00:20:08.100
a digital audio workstation.

00:20:08.100 --> 00:20:10.050
That's another example.

00:20:12.760 --> 00:20:18.640
So when the host calls Audio Unit Render,
your process method is called.

00:20:18.640 --> 00:20:24.770
And process is a method of
your AU kernel base subclass.

00:20:24.900 --> 00:20:29.360
That's where you do the
interesting signal processing,

00:20:29.360 --> 00:20:31.590
your specialized code that
makes your Audio Unit special,

00:20:31.600 --> 00:20:35.780
gives it that really distinctive sound.

00:20:36.020 --> 00:20:39.980
Your reset method gets called when
the host calls Audio Unit Reset.

00:20:40.010 --> 00:20:46.640
That's where the continuity of the
audio stream is being broken and you're

00:20:46.660 --> 00:20:48.640
expected to reset your filter state.

00:20:48.660 --> 00:20:51.340
If you're a reverb,
clear out all of your delay buffers

00:20:51.430 --> 00:20:55.520
and all that type of stuff so you don't
have this giant reverb tail that keeps

00:20:55.680 --> 00:20:59.630
playing out even though you're playing
at a different part of the timeline.

00:21:01.140 --> 00:21:04.530
Factory presets are something
that you can decide to put in

00:21:04.530 --> 00:21:06.280
your Audio Unit if you want.

00:21:06.330 --> 00:21:12.940
And it's basically a set of parameter
values that are useful to the user.

00:21:13.100 --> 00:21:17.030
So for example, in a reverb,
there might be a set of parameters

00:21:17.040 --> 00:21:21.840
that make up a cathedral setting or
a large room or something like that.

00:21:21.860 --> 00:21:25.600
And we're going to make a couple
factory presets in the filter.

00:21:27.310 --> 00:21:31.030
In order to do that,
there are basically two methods

00:21:31.040 --> 00:21:36.530
that you're going to need to
override in AU Effect Base.

00:21:36.660 --> 00:21:41.740
The Get Presets method is what gets
called when the host is interested in

00:21:41.740 --> 00:21:46.260
determining what presets are available,
what factory presets are available.

00:21:46.370 --> 00:21:47.660
So you give it a list of those.

00:21:47.790 --> 00:21:50.170
That's a CF over ARAF.

00:21:50.700 --> 00:21:53.890
And there's the new
factory preset set method,

00:21:53.900 --> 00:21:58.850
which gets called when the host decides
to set a particular preset on you.

00:22:01.570 --> 00:22:07.700
So I'd like to go to the demo machine,
please, and actually show you

00:22:08.090 --> 00:22:10.890
in Xcode some of this

00:22:12.280 --> 00:22:16.000
Now, even though you may have
this code on your machine,

00:22:16.000 --> 00:22:19.830
you may be looking at it,
it probably isn't really very efficient

00:22:19.850 --> 00:22:24.330
for you to follow along as I move
quickly through the different files here.

00:22:24.430 --> 00:22:29.340
But we can-- we can look at all of this
in more detail in the lab tomorrow,

00:22:29.340 --> 00:22:32.120
if any of you have additional
questions or if you have,

00:22:32.190 --> 00:22:36.040
like, some particularly difficult things
that you need to do with audio

00:22:36.040 --> 00:22:39.940
units that we don't cover today.

00:22:40.050 --> 00:22:43.530
The first thing that you should do
when you create a new project using the

00:22:43.530 --> 00:22:50.790
Audio Unit Template is configure some
basic information about your component.

00:22:50.890 --> 00:22:55.070
Now this is FilterVersion.h.

00:22:55.070 --> 00:23:00.080
And we need to give the component a
unique identifier so that it can be

00:23:00.220 --> 00:23:05.280
uniquely identified as being different
from other Audio Units on the system.

00:23:05.460 --> 00:23:08.700
And the way the Component Manager does
that is through ComponentType,

00:23:08.770 --> 00:23:10.290
SubType, and Manufacturer.

00:23:10.300 --> 00:23:12.760
The type is already
determined for an effect.

00:23:12.760 --> 00:23:16.290
It's a four-character code,
which is AUFX.

00:23:16.300 --> 00:23:19.300
The subtype, we're free to choose.

00:23:19.300 --> 00:23:27.160
And for the purposes of this project,
we'll call the type FILT,

00:23:27.310 --> 00:23:28.800
all capital letters.

00:23:28.800 --> 00:23:31.300
And you need to choose a
four-character code that has at

00:23:31.300 --> 00:23:34.360
least one uppercase character,
because four-character codes

00:23:34.360 --> 00:23:38.990
with lowercase characters
are reserved for Apple's use.

00:23:39.390 --> 00:23:43.190
After making the subtype,
you should define a four-character

00:23:43.200 --> 00:23:45.050
code for your company.

00:23:45.050 --> 00:23:48.290
And it has to be a unique
four-character code,

00:23:48.290 --> 00:23:52.280
and it's recommended that you register
your company's four-character code with

00:23:52.280 --> 00:23:54.400
Apple if you don't already have one.

00:23:55.700 --> 00:24:01.180
Aside from the subtype of manufacturer,
the Audio Unit has a name.

00:24:01.280 --> 00:24:05.540
So when we were in AU Lab and we looked
in the pop-up menu of available effects,

00:24:05.590 --> 00:24:07.600
it gave a list of names.

00:24:07.820 --> 00:24:16.600
So you should, first of all,
put your company name here, colon,

00:24:16.750 --> 00:24:19.400
and then make up a name
for your Audio Unit.

00:24:19.650 --> 00:24:21.600
We're going to call this Filter.

00:24:21.600 --> 00:24:23.760
Pretty boring name,
but I'm sure that you guys

00:24:23.800 --> 00:24:29.580
have some much more interesting
effects that you can show us.

00:24:29.610 --> 00:24:36.360
After that, in the targets,

00:24:39.020 --> 00:24:42.300
If you look at the information
for the target and you go

00:24:42.300 --> 00:24:46.950
to the properties setting,
there's an identifier here and it says

00:24:47.060 --> 00:24:50.480
com.apple_demo_audiounit.filter_demo.

00:24:50.630 --> 00:24:59.120
And what you need to do is make that
say com.yourcompany_name.audiounit.

00:24:59.510 --> 00:25:01.100
Your Audio Unit Name.

00:25:01.180 --> 00:25:06.050
So instead of Filter Demo,
it would be Migrate Reverb or whatever.

00:25:08.900 --> 00:25:25.100
[Transcript missing]

00:25:25.600 --> 00:25:27.260
Your Audio Unit Name.

00:25:27.260 --> 00:25:31.950
So instead of Filter Demo,
it would be Migrate Reverb or whatever.

00:25:33.670 --> 00:25:38.780
This is a method of AU Effect Base and
Filter is our subclass of that.

00:25:38.940 --> 00:25:43.500
And we're defining two parameters,
cutoff frequency and resonance.

00:25:43.540 --> 00:25:45.580
We're giving a name.

00:25:46.470 --> 00:25:53.390
And this is a constant here,
which is a CFStringRef.

00:25:53.920 --> 00:25:57.400
So you can localize this to a
particular language if you want.

00:25:57.400 --> 00:26:01.110
We do the same for resonance.

00:26:02.300 --> 00:26:10.480
We give it a unit type of hertz, minimum,
maximum, default value, and some flags.

00:26:10.480 --> 00:26:14.980
Since we're publishing this
parameter as having units of hertz,

00:26:14.980 --> 00:26:18.850
we also give it a flag telling
it to display logarithmic.

00:26:18.860 --> 00:26:22.070
So in the generic view,
when it creates a slider

00:26:22.650 --> 00:26:26.990
for changing this parameter,
it will be on a log scale,

00:26:26.990 --> 00:26:29.710
which is how we want
to control frequency.

00:26:31.550 --> 00:26:33.590
So similarly,
we set up all this information

00:26:33.680 --> 00:26:35.880
for the resonance parameter.

00:26:35.920 --> 00:26:40.000
So it's just a single method here that
we have to worry about for parameters.

00:26:40.020 --> 00:26:43.980
And also, in the constructor,
as I mentioned,

00:26:43.980 --> 00:26:47.230
you need to call set parameter initially,
just to define the parameter.

00:26:47.320 --> 00:26:51.670
So we call it for the two parameters,
and that defines the parameter

00:26:51.670 --> 00:26:54.150
and gives the initial value.

00:26:55.070 --> 00:26:57.820
Okay, that takes care of parameters.

00:26:57.940 --> 00:27:00.340
Why don't we go and look at
the signal processing code?

00:27:00.390 --> 00:27:03.220
And that's in a different class.

00:27:03.350 --> 00:27:11.380
It's our filter kernel class where
the actual signal processing goes on.

00:27:12.140 --> 00:27:15.500
The process method is probably
the most important method there.

00:27:15.530 --> 00:27:21.340
That's where we do the
interesting filtering.

00:27:21.500 --> 00:27:25.300
And we're given a source buffer,
a destination buffer,

00:27:25.300 --> 00:27:27.920
and a number of frames to process.

00:27:29.410 --> 00:27:35.500
So, the first thing we do is we
get the two parameter values.

00:27:36.100 --> 00:27:40.870
We do some kind of bounds
checking stuff here.

00:27:40.870 --> 00:27:44.380
And then what we do is
given those parameters,

00:27:44.530 --> 00:27:48.590
the cutoff frequency and resonance,
we need to calculate some internal

00:27:48.590 --> 00:27:53.210
coefficients for our filter,
which is a biquad filter.

00:27:53.280 --> 00:27:56.410
It's not, you don't have to
understand how that works.

00:27:57.250 --> 00:28:03.740
But this is the method that we call
to calculate our internal coefficients

00:28:03.740 --> 00:28:06.890
given the frequency and the resonance.

00:28:08.420 --> 00:28:10.930
Once again,
the math isn't really that important

00:28:10.930 --> 00:28:12.900
unless you're interested in that.

00:28:12.950 --> 00:28:16.290
Finally, we've got the source buffer,
destination buffer,

00:28:16.300 --> 00:28:17.800
number of frames to process.

00:28:17.820 --> 00:28:20.760
All we're doing is going
through a loop here,

00:28:20.940 --> 00:28:29.050
getting the input sample,
doing the filtering operation,

00:28:29.050 --> 00:28:29.260
and writing the output to
the destination buffer.

00:28:30.990 --> 00:28:36.780
I mentioned Audio Unit Reset,
and when the host calls Audio Unit Reset,

00:28:36.890 --> 00:28:40.700
Our reset method is called,
and that's where we clear

00:28:40.700 --> 00:28:42.940
out our filter state.

00:28:43.180 --> 00:28:45.860
And as I said,
for a reverb or a delay effect,

00:28:45.860 --> 00:28:50.970
you would clear out your
delay buffers at that point.

00:28:53.580 --> 00:28:59.450
Um, finally in the code,
I'd like to go over quickly how, um,

00:28:59.640 --> 00:29:01.790
How factory presets work.

00:29:01.790 --> 00:29:05.440
So, we have two methods that I mentioned.

00:29:05.440 --> 00:29:07.910
Get presets.

00:29:07.910 --> 00:29:12.940
And this is what the host calls to get
a list of the available factory presets.

00:29:12.980 --> 00:29:17.980
We just create a CFArray here
and we go through a loop and

00:29:18.220 --> 00:29:20.750
append a structure to the array.

00:29:20.750 --> 00:29:24.750
And what the structure looks like is

00:29:25.160 --> 00:29:26.550
It's called AUPreset.

00:29:26.550 --> 00:29:29.430
It's a structure called AUPreset.

00:29:29.430 --> 00:29:33.930
And it's defined in
AudioUnitProperties.h.

00:29:34.390 --> 00:29:37.940
It only has two member variables.

00:29:37.940 --> 00:29:43.140
The preset number, just an integer,
and the name, which is a CFStringRef.

00:29:43.300 --> 00:29:49.480
And that can be localized to a particular
language since it's a CFStringRef.

00:29:52.930 --> 00:29:56.560
Okay, so here we're just defining
two factory presets.

00:29:56.560 --> 00:30:02.430
And we're going to call the first one
Preset 1 and the second one Preset 2.

00:30:02.560 --> 00:30:07.080
Of course, if you had a real effect,
interesting, like a reverb or something,

00:30:07.240 --> 00:30:09.710
you could give those
names like Concert Hall,

00:30:09.710 --> 00:30:12.480
Small Room, and stuff like that.

00:30:14.700 --> 00:30:18.870
Okay,
so we're just returning a CFArray of

00:30:18.870 --> 00:30:22.390
our list of factory presets.

00:30:22.390 --> 00:30:24.210
That's the discovery mechanism.

00:30:24.370 --> 00:30:26.870
When the host decides to
choose a particular preset,

00:30:26.870 --> 00:30:29.430
we call the new factory preset set.

00:30:29.440 --> 00:30:34.270
With an AU preset structure,
we get the preset number here,

00:30:34.270 --> 00:30:37.950
first of all,
and we go through in a loop and we

00:30:37.950 --> 00:30:43.360
find the one that matches the preset
number that they want selected.

00:30:43.360 --> 00:30:46.630
And the way I've done it here
is I just have a simple switch

00:30:46.710 --> 00:30:53.220
statement and I set the parameters
a particular way for preset one,

00:30:53.380 --> 00:30:56.200
cutoff frequency is 200
and resonance is minus 5.

00:30:56.200 --> 00:30:59.470
And for the second preset, preset two,
I give it cutoff

00:30:59.520 --> 00:31:02.270
frequency of 1,000 and 10.

00:31:02.540 --> 00:31:04.630
You don't have to implement
this with a switch statement.

00:31:04.640 --> 00:31:12.440
You could use the chosen preset
number as an index into an array.

00:31:16.320 --> 00:31:19.800
So that's pretty much all the
code that we're going to look at.

00:31:19.810 --> 00:31:24.510
I want to show you how to
install the Audio Unit.

00:31:26.550 --> 00:31:32.570
I mentioned that there are two
locations where you can install it.

00:31:33.940 --> 00:31:37.650
The Audio Unit is built in the
build directory here of our project,

00:31:37.650 --> 00:31:38.920
Filter Demo.

00:31:38.940 --> 00:31:41.800
It's called FilterDemo.Component.

00:31:41.940 --> 00:31:46.020
And I'm gonna put it in--

00:31:46.980 --> 00:31:50.560
The user's home directory,
Bob Aaron in this case.

00:31:50.560 --> 00:31:55.350
Library, Audio, Plugins, Components.

00:31:55.640 --> 00:31:57.480
That's where it goes.

00:31:58.000 --> 00:31:59.560
Copy it there.

00:31:59.570 --> 00:32:02.710
Well, it's already there,
but I'll say replace.

00:32:02.960 --> 00:32:04.000
Okay.

00:32:04.040 --> 00:32:05.660
So we've installed it.

00:32:05.730 --> 00:32:07.950
Now let's see if it
shows up in the system.

00:32:08.000 --> 00:32:13.910
So I'm going to call up the, um,
the terminal here,

00:32:13.910 --> 00:32:21.700
and we're going to use AUVAL to see
if the Audio Unit is on the system.

00:32:21.700 --> 00:32:21.740
And the way to do that is
use the -A option with AUVAL.

00:32:22.090 --> 00:32:27.880
And lo and behold, among all of these
Apple--built-in Apple Audio Units,

00:32:28.350 --> 00:32:33.900
we see that ours shows up right
there with the name that we gave it.

00:32:34.350 --> 00:32:37.300
Now I want to put this
Audio Unit through its paces.

00:32:37.300 --> 00:32:42.900
I mentioned AUVALS being a validation
tool that puts the Audio Unit through

00:32:43.110 --> 00:32:46.390
a kind of a torture test,
so let's actually do that.

00:32:47.480 --> 00:32:50.990
Use the -v option for validation.

00:32:51.000 --> 00:32:54.040
The component type is AUFX.

00:32:54.190 --> 00:32:55.540
Subtype is FILT.

00:32:55.540 --> 00:32:57.570
That's what we gave it.

00:32:58.070 --> 00:33:03.550
and APPL, that's the manufacturer name.

00:33:04.440 --> 00:33:06.160
Oh, it printed out quite
a lot of stuff there.

00:33:06.160 --> 00:33:09.900
Let's go up and see what it did.

00:33:09.900 --> 00:33:09.900
Okay.

00:33:10.180 --> 00:33:14.940
First thing it does is it gives
you the name of the Audio Unit,

00:33:14.940 --> 00:33:17.840
the version number,
and tells you how long it

00:33:17.840 --> 00:33:19.950
takes to open your Audio Unit.

00:33:20.680 --> 00:33:23.420
And then it gives you some
information about the stream

00:33:23.470 --> 00:33:25.240
format for the input and output.

00:33:25.240 --> 00:33:31.860
And the stream format is two channels,
44 kilohertz, linear PCM, 32-bit.

00:33:35.150 --> 00:33:38.530
It validates some of the built-in
properties which are mostly taken

00:33:38.530 --> 00:33:42.010
care of for you in the base classes.

00:33:43.820 --> 00:33:48.210
and AU Effect Base also takes
care of some of this other stuff.

00:33:48.710 --> 00:33:53.360
Actually, if you look more closely
in the filter.cpp file,

00:33:53.360 --> 00:33:57.450
you'll see that we support the
latency property tail time.

00:34:03.700 --> 00:34:10.440
So here it's telling us information about
custom views that Audio Unit supports.

00:34:10.450 --> 00:34:15.700
Zero Carbon views supported,
so there are no custom Carbon views,

00:34:15.830 --> 00:34:20.110
but there's one Cocoa view
that's supported.

00:34:20.320 --> 00:34:22.740
Here it tells us information
about presets that we have.

00:34:22.880 --> 00:34:26.020
So we have our preset 1 and preset 2.

00:34:26.590 --> 00:34:32.700
Further on it talks about the
parameters where it gives us information

00:34:32.700 --> 00:34:36.780
about the unit type and minimum,
max, default value and so on and

00:34:36.780 --> 00:34:38.150
the flags that we gave it.

00:34:38.570 --> 00:34:42.570
So, AUVAL is actually a useful
tool to see if we've published

00:34:42.600 --> 00:34:46.500
our parameters correctly or,
you know, with all this information

00:34:46.500 --> 00:34:48.820
that we're getting,
we can practically tell almost

00:34:49.100 --> 00:34:50.500
everything about the Audio Unit.

00:34:50.500 --> 00:34:54.110
So, we can tell if we're doing things
correctly in our code just by using

00:34:54.110 --> 00:34:57.340
AUVAL before we even run it in a host.

00:34:58.610 --> 00:35:01.720
So after the parameters,
it checks the channel handling.

00:35:01.720 --> 00:35:07.540
And being subclass of AU Effect Base,
it handles end-to-end processing,

00:35:07.540 --> 00:35:08.100
as I mentioned.

00:35:08.200 --> 00:35:11.500
So it should be able
to handle one-to-one,

00:35:11.500 --> 00:35:12.640
that's mono.

00:35:13.310 --> 00:35:21.190
Stereo Processing, 4-4 channels, 5-5,
6-6, 8-8, AUVAL checks all of those.

00:35:22.620 --> 00:35:29.530
Um, it's testing rendering at various
sample rates and processing

00:35:30.210 --> 00:35:30.210
various numbers of frames.

00:35:34.000 --> 00:35:37.350
At the very bottom here, it says,
"AU Validation Succeeded," and

00:35:37.450 --> 00:35:40.090
that's the message that you
want to see on your Audio Unit,

00:35:40.240 --> 00:35:47.210
because some hosts actually require
that validation succeeds or they

00:35:47.210 --> 00:35:50.380
won't even be allowed to run.

00:35:50.380 --> 00:35:50.380
So...

00:35:52.610 --> 00:35:59.130
That's pretty much it for building
Audio Unit and validating it and so on.

00:35:59.130 --> 00:36:02.500
I'd like to call Michael Hopkins up
and he's going to show you how to make

00:36:02.500 --> 00:36:07.790
a nice Cocoa view for the Audio Unit.

00:36:12.010 --> 00:36:12.900
Thanks Michael.

00:36:13.060 --> 00:36:14.900
Thank you very much Chris.

00:36:14.900 --> 00:36:18.290
Could we go back to slides please?

00:36:18.950 --> 00:36:23.070
As Chris showed you,
when you create an Audio Unit and

00:36:23.070 --> 00:36:26.710
load it in a host such as AU Lab,
you're already provided

00:36:26.710 --> 00:36:27.940
with a generic view.

00:36:28.020 --> 00:36:32.210
But there are many rationales for
going one step beyond that and

00:36:32.220 --> 00:36:34.510
creating your own custom view.

00:36:36.100 --> 00:36:40.500
For example,
there may be some unwanted detail

00:36:40.500 --> 00:36:43.890
that you want to hide for your user,
or you may just want to customize the

00:36:43.890 --> 00:36:46.100
order that your parameters appear in.

00:36:46.180 --> 00:36:50.250
Or you have the flexibility to
choose the user interface element

00:36:50.250 --> 00:36:55.100
that you use to represent that,
for example, a knob instead of just the

00:36:55.200 --> 00:36:58.090
slider and text field that
you get with the generic view.

00:36:58.190 --> 00:37:00.430
Additionally,
you have the flexibility to provide

00:37:00.430 --> 00:37:02.650
the appropriate amount of eye candy.

00:37:03.330 --> 00:37:07.100
And you can also provide a
branding experience to your user

00:37:07.100 --> 00:37:11.170
so that if you are creating many
different types of Audio Units,

00:37:11.200 --> 00:37:14.670
you can use common interface
elements and graphics to give a

00:37:14.770 --> 00:37:17.100
uniform look to all of your plugins.

00:37:17.100 --> 00:37:23.760
But perhaps the best way to make this
point is to look at what you get with

00:37:23.780 --> 00:37:27.100
our filter demo in the generic view.

00:37:27.100 --> 00:37:27.640
And you can see that the filter
demo is a little bit more

00:37:27.640 --> 00:37:28.090
complex than the generic view.

00:37:28.130 --> 00:37:32.100
And compare that to the custom view that
we're going to be developing here today.

00:37:32.390 --> 00:37:37.160
And as you can see here,
the custom view shows the same amount

00:37:37.160 --> 00:37:42.760
of information as the generic view,
but we're also adding this beautiful

00:37:42.760 --> 00:37:45.080
display of the response curve.

00:37:45.130 --> 00:37:47.620
And instead of just showing
you a picture of this,

00:37:47.620 --> 00:37:51.100
let me go ahead and run a demo to
show you how that works in real time.

00:37:51.100 --> 00:37:55.260
So if I could switch to demo station two,
please.

00:38:01.040 --> 00:38:03.880
I'm going to launch the
same AU Lab document that

00:38:03.880 --> 00:38:05.560
Chris showed you earlier.

00:38:05.580 --> 00:38:09.820
And as you recall, there was a generic
view for the Audio Unit.

00:38:09.840 --> 00:38:12.880
I'm going to open a second
view on the same Audio Unit,

00:38:12.880 --> 00:38:14.680
which is our custom view.

00:38:14.720 --> 00:38:18.160
And this resizes in the same
manner that the generic view does,

00:38:18.340 --> 00:38:21.440
except that curve updates in real time.

00:38:21.480 --> 00:38:25.480
And I can go ahead and change
the values of these parameters by

00:38:25.480 --> 00:38:30.100
typing in a text field directly,
which upstates the graph, as you can see.

00:38:30.140 --> 00:38:36.320
Or I can click and drag in that view to
move the response curve in real time.

00:38:37.940 --> 00:38:42.540
You'll also notice that if I go to
the generic view and I change one

00:38:42.540 --> 00:38:46.760
of the parameters in that view,
that is updating my custom

00:38:46.760 --> 00:38:48.640
view at the same time.

00:38:48.660 --> 00:38:52.900
And this is occurring because our
generic view is changing the value of

00:38:52.900 --> 00:38:56.610
that parameter in the Audio Unit and
then sending a notification that

00:38:56.680 --> 00:38:58.940
that parameter value has changed.

00:38:58.950 --> 00:39:02.710
Our custom view listens for that
notification and in response to that,

00:39:02.810 --> 00:39:04.700
updates its curve.

00:39:04.710 --> 00:39:08.040
And that also will occur with
the resonance parameter too.

00:39:08.040 --> 00:39:10.380
And of course,
it's our responsibility when

00:39:10.380 --> 00:39:14.140
we write our custom view to do
the same thing so that when we

00:39:14.140 --> 00:39:18.580
update the curve in our custom UI,
that we send a notification that

00:39:18.580 --> 00:39:22.310
those parameters are changing
so the custom view can update

00:39:22.310 --> 00:39:24.900
its view of that data as well.

00:39:24.910 --> 00:39:27.580
And you'll notice one
other thing occurring here,

00:39:27.580 --> 00:39:31.240
and that's that the cutoff
frequency and resonance parameters

00:39:31.470 --> 00:39:33.740
are highlighted in blue.

00:39:33.760 --> 00:39:34.700
And this is because our custom view is
changing the value of that parameter.

00:39:34.700 --> 00:39:38.140
And that's because our custom view is
sending what's known as a begin gesture.

00:39:38.170 --> 00:39:43.290
And Hosts use this for automation,
but the generic view is using that to

00:39:43.290 --> 00:39:46.080
highlight which parameters are changing.

00:39:46.230 --> 00:39:49.050
And you'll notice both
parameters are highlighted,

00:39:49.050 --> 00:39:52.600
and that's because we have a
two-dimensional view that's capable of

00:39:53.080 --> 00:39:55.900
updating both of those at the same time.

00:39:55.970 --> 00:39:59.940
And when we release the mouse,
we send what's known as an

00:39:59.940 --> 00:40:02.730
end gesture notification,
indicating that we're no

00:40:02.730 --> 00:40:04.090
longer editing that parameter.

00:40:05.080 --> 00:40:08.580
Now let's go ahead and listen to that.

00:40:13.070 --> 00:40:19.100
As I change the cutoff frequency,
we can hear the change in the audio,

00:40:19.190 --> 00:40:22.560
but we also have this beautiful
curve that is really giving us

00:40:22.660 --> 00:40:25.990
a visual representation of what
that sound is going to sound like.

00:40:26.090 --> 00:40:29.790
So this really gives the user
a lot of extra information

00:40:29.790 --> 00:40:31.750
than just a generic view.

00:40:35.310 --> 00:40:37.250
OK, could I switch back to slides,
please?

00:40:37.360 --> 00:40:46.910
So now let's take a look at how
the view that we are writing fits

00:40:46.910 --> 00:40:49.660
into the audio unit structure.

00:40:49.780 --> 00:40:52.210
First of all,
views can be written using either

00:40:52.220 --> 00:40:54.710
the Carbon or the Cocoa API.

00:40:54.720 --> 00:40:57.380
That interface could be
created programmatically,

00:40:57.380 --> 00:40:59.880
or loaded via a NibFile.

00:40:59.880 --> 00:41:03.390
In either case,
the view is retrieved directly from

00:41:03.390 --> 00:41:05.920
the audio unit via a get property call.

00:41:05.920 --> 00:41:08.380
And you see the two
identifiers there on the slide,

00:41:08.380 --> 00:41:11.230
whether using Carbon or Cocoa.

00:41:11.930 --> 00:41:15.430
Regardless of which API you use,
the host will always provide

00:41:15.430 --> 00:41:17.340
that window context for you.

00:41:17.340 --> 00:41:20.880
And if you're a Carbon view,
you're a control ref and

00:41:20.880 --> 00:41:25.840
you'll be embedded in that
host in the main control,

00:41:26.050 --> 00:41:26.800
in the root control.

00:41:26.800 --> 00:41:30.560
If you're a Carbon view,
your view is an NSView derivative

00:41:30.570 --> 00:41:34.530
class and you'll be placed in
the content pane of that window.

00:41:34.800 --> 00:41:36.110
Drawing is up to you.

00:41:36.110 --> 00:41:40.240
You have an open canvas to do whatever
you want in the API that's most

00:41:40.240 --> 00:41:42.800
appropriate for your type of view.

00:41:43.030 --> 00:41:45.720
And the same thing goes
with event handling.

00:41:45.810 --> 00:41:48.800
If you're a Carbon view,
you'll use the Carbon event manager.

00:41:48.800 --> 00:41:52.590
And if you're a Cocoa view,
instead you use the methods

00:41:52.590 --> 00:41:56.800
in NSView that are inherited
from the NSResponder class.

00:41:56.800 --> 00:41:59.950
So I'm not going to cover any
of these items anymore in the

00:41:59.950 --> 00:42:04.800
remainder of my presentation since
these are merely API specific.

00:42:04.820 --> 00:42:08.410
Instead,
I'd like to concentrate on those unique

00:42:08.410 --> 00:42:13.800
pieces that you'll need to write in
order to interface with the Audio Unit.

00:42:14.540 --> 00:42:17.000
So let's take a look at that now.

00:42:17.000 --> 00:42:20.010
As you'll recall,
Chris mentioned that the Audio Unit is

00:42:20.140 --> 00:42:22.200
contained in a component file.

00:42:22.270 --> 00:42:27.310
And inside that component
is the filter bundle.

00:42:27.570 --> 00:42:31.410
And that is where the Cocoa View resides.

00:42:31.630 --> 00:42:34.380
So let's focus on that right now.

00:42:34.490 --> 00:42:37.440
Inside that bundle,
similar to the component,

00:42:37.490 --> 00:42:41.250
is an Info.plist that
defines the main class name,

00:42:41.380 --> 00:42:43.980
the name of the nib,
and the name of the bundle,

00:42:43.980 --> 00:42:47.000
and also provides a bundle identifier.

00:42:47.000 --> 00:42:51.530
There's a Mac OS directory where your
Cocoa View executable code lives,

00:42:51.530 --> 00:42:55.640
and a resources directory where
you'll find all the localized

00:42:55.740 --> 00:43:00.820
resources used by your view,
which in this case is a nib file.

00:43:00.870 --> 00:43:06.040
We also have added a TIFF file
that we use as a background image.

00:43:07.400 --> 00:43:13.060
Okay, now let's look at what the host
does when it loads a CocoaView.

00:43:13.060 --> 00:43:16.290
In this case,
it's going to call the getProperty

00:43:16.350 --> 00:43:19.800
method with a CocoaUI identifier.

00:43:20.040 --> 00:43:23.400
And this method,
or this call returns a structure

00:43:23.400 --> 00:43:28.290
that specifies first a URL to
the location of the bundle,

00:43:28.290 --> 00:43:31.790
and then a string,
which is the name of that main class.

00:43:31.790 --> 00:43:36.940
And the bundle location is a URL to the
location that's within the component.

00:43:39.040 --> 00:43:43.190
Now we're going to go ahead and look
at the source code in the filter class

00:43:43.270 --> 00:43:45.400
that's required to support that property.

00:43:45.590 --> 00:43:48.300
And for the remainder of my presentation,
I'm going to be showing

00:43:48.300 --> 00:43:49.860
that code in slides.

00:43:50.000 --> 00:43:54.970
But you'll notice that there's an icon at
the bottom of the slide indicating which

00:43:55.210 --> 00:43:57.060
source file that code is contained in.

00:43:57.400 --> 00:43:59.700
And I encourage you to,
at your leisure later on,

00:43:59.780 --> 00:44:02.160
take a look and go through
that code in more detail,

00:44:02.160 --> 00:44:04.530
because some of it's pretty interesting.

00:44:04.540 --> 00:44:08.870
To implement the get property info call,
we specify that that

00:44:08.870 --> 00:44:11.160
property is not writable.

00:44:11.160 --> 00:44:15.370
And then we also specify the size
of that structure and return it.

00:44:16.210 --> 00:44:21.400
To implement the Get Property call,
we first need to provide the

00:44:21.400 --> 00:44:26.900
location or URL of that bundle,
which we do by getting the bundle

00:44:26.900 --> 00:44:29.540
with the component identifier.

00:44:29.650 --> 00:44:34.980
And then we, further on down in the code,
find the Cocoa View bundle within

00:44:34.980 --> 00:44:38.810
that component and get the URL for it.

00:44:39.590 --> 00:44:43.450
Once we have that URL,
we take the name of the class in the URL,

00:44:43.700 --> 00:44:47.560
copy it into the structure,
and then return that information.

00:44:49.090 --> 00:44:53.810
Okay,
when the host is loading that bundle,

00:44:53.860 --> 00:44:57.000
it's going to be loading first the
main class to instantiate that.

00:44:57.000 --> 00:45:00.100
And there are a few rules about the way
that main class needs to be structured.

00:45:00.100 --> 00:45:06.110
The first is that that bundle's
principal class needs to implement

00:45:06.110 --> 00:45:09.200
the AU Cocoa UI-based protocol.

00:45:09.890 --> 00:45:13.760
And this protocol specifies that
that view class is a factory method

00:45:14.250 --> 00:45:18.720
that returns an NSView subclass
via this specific property

00:45:18.720 --> 00:45:21.560
method you'll see on the slide,
which is the UI view for

00:45:21.560 --> 00:45:22.930
Audio Unit with size.

00:45:23.000 --> 00:45:26.850
That method will take
an Audio Unit parameter,

00:45:26.940 --> 00:45:31.110
store it in the view along
with a suggested size,

00:45:31.470 --> 00:45:36.130
and then return a view with that
that implements that protocol.

00:45:36.160 --> 00:45:39.880
If you're using a nib file
like we are in the example,

00:45:39.910 --> 00:45:45.570
you need to make sure that the owner
of that nib file is this factory class.

00:45:47.670 --> 00:45:52.520
Okay, now I'd like to talk a little
bit about communication between

00:45:52.520 --> 00:45:54.600
the Audio Unit and its view.

00:45:54.670 --> 00:45:59.400
These two objects are really
separate entities and as such you

00:45:59.400 --> 00:46:03.110
need to be really careful because
they may not necessarily even be

00:46:03.120 --> 00:46:04.760
living in the same address space.

00:46:04.870 --> 00:46:08.320
So you want to make sure that you
don't do things like pass pointers

00:46:08.320 --> 00:46:10.600
back and forth or other skankiness.

00:46:10.600 --> 00:46:14.560
Instead,
we recommend that you use a discrete way

00:46:14.780 --> 00:46:19.780
of communicating with the Audio Unit that
Chris previously discussed,

00:46:19.910 --> 00:46:23.460
which is via the parameters
and the properties.

00:46:23.600 --> 00:46:27.400
When the view is first loaded,
it needs to know what to display

00:46:27.550 --> 00:46:31.600
and it does that simply by getting
the current parameter values

00:46:31.600 --> 00:46:33.600
via Audio Unit Get Parameter.

00:46:33.600 --> 00:46:39.600
Once it's updated that information,
if the user changes the user interface,

00:46:39.650 --> 00:46:43.090
it needs to notify the Audio Unit that
that value has changed,

00:46:43.170 --> 00:46:46.600
which it does simply by setting
the value of that same parameter.

00:46:46.600 --> 00:46:49.590
And the same goes if it's
using any custom property.

00:46:49.600 --> 00:46:54.920
Now we also saw in the demo earlier
that our custom view needs to

00:46:54.920 --> 00:46:58.750
update its state if another object,
such as another view,

00:46:58.790 --> 00:47:01.600
changes the value of that property.

00:47:01.600 --> 00:47:05.200
And there's a notification mechanism
built into Core Audio called

00:47:05.330 --> 00:47:06.600
the AU Event Listener.

00:47:06.600 --> 00:47:08.600
And this mechanism will inform
the Audio Unit that the value

00:47:08.600 --> 00:47:08.600
of that property is changing.

00:47:08.800 --> 00:47:11.730
And this mechanism will inform
our view of any parameter

00:47:11.800 --> 00:47:13.600
changes or property changes.

00:47:13.790 --> 00:47:18.480
This mechanism is thread safe,
allows us to do things like control

00:47:18.480 --> 00:47:20.600
the granularity of the notifications.

00:47:20.870 --> 00:47:25.600
And this mechanism is used
both by hosts and by views.

00:47:25.600 --> 00:47:29.600
Let's look at the API now
in a little bit more detail.

00:47:29.600 --> 00:47:34.650
When we create a listener or
register that we're interested in

00:47:34.650 --> 00:47:39.330
listening to a specific parameter,
we can use the AU Event Listener

00:47:39.350 --> 00:47:40.600
to create a function.

00:47:40.600 --> 00:47:43.540
And similarly,
when we're no longer interested,

00:47:43.660 --> 00:47:46.600
we dispose of that event listener.

00:47:47.350 --> 00:47:51.800
Once we've created that listener,
we need to specify all the types of

00:47:51.800 --> 00:47:56.150
events that our view is interested
in receiving for each parameter.

00:47:56.340 --> 00:48:00.320
So if we're interested
in the value change,

00:48:00.320 --> 00:48:04.170
that's a specific event type
that we register interest in by

00:48:04.170 --> 00:48:06.780
using AU EventListener@EventType.

00:48:06.800 --> 00:48:11.610
And similarly,
we can remove interest in events as well.

00:48:14.070 --> 00:48:21.000
Okay, when a listener notifies us that a
particular parameter has changed,

00:48:21.020 --> 00:48:22.800
we get notified.

00:48:22.800 --> 00:48:28.600
And that occurs via the notification
mechanism that I previously talked about.

00:48:28.600 --> 00:48:33.560
It's our responsibility as a view,
however, to also make sure that we're

00:48:33.560 --> 00:48:37.000
doing notification of listeners
whenever we change our values.

00:48:37.000 --> 00:48:41.170
And that's done by calling
AU Event Listener Notify.

00:48:41.170 --> 00:48:43.990
And there's also a convenience
method that's provided

00:48:43.990 --> 00:48:46.000
specifically for parameters.

00:48:46.200 --> 00:48:49.830
And this will not only set the value
of the parameter in the Audio Unit,

00:48:49.960 --> 00:48:52.910
but it also will perform
the same notification.

00:48:53.440 --> 00:48:58.610
And we'll see this in the code that
I'm about to go over in a little bit.

00:48:59.410 --> 00:49:05.220
Now I'd like to take a look at the view
code that's in our filter demo project.

00:49:05.220 --> 00:49:09.300
And this filter demo project was
created with the Audio Unit template.

00:49:09.300 --> 00:49:14.070
And so there were a couple of minor
housekeeping details that we had to

00:49:14.070 --> 00:49:18.180
do in order to prepare that project
before we started our development.

00:49:18.750 --> 00:49:22.870
The first thing we did is we went
through all the source files and

00:49:22.870 --> 00:49:26.430
we renamed them to unique names to
make sure that we didn't have any

00:49:26.430 --> 00:49:31.290
namespace collisions with other classes
that were based on this template.

00:49:31.430 --> 00:49:35.090
We additionally updated the
Cocoa UI Xcode target to

00:49:35.090 --> 00:49:39.860
change the name of the bundle,
the identifier of the nib, excuse me,

00:49:39.860 --> 00:49:42.830
the identifier of the bundle,
the nib name,

00:49:42.920 --> 00:49:45.640
and also to specify the principal class.

00:49:45.640 --> 00:49:49.320
And then we added that image
resource to our project as well.

00:49:49.470 --> 00:49:53.280
So we've done all this for you in
the project that's on your desk.

00:49:53.980 --> 00:49:57.780
When we updated the Cocoa UI,
we went into Xcode,

00:49:58.070 --> 00:50:01.170
clicked on that target,
went to the properties tab,

00:50:01.320 --> 00:50:07.200
and then specified the identifier class
name and then file in that dialog.

00:50:09.230 --> 00:50:11.610
Once that is completed
and we renamed our class,

00:50:11.670 --> 00:50:15.530
we need to make sure that we
update our nib file so that the

00:50:15.530 --> 00:50:18.290
interface builder matches as well.

00:50:18.510 --> 00:50:21.700
And I'm going to show an example of
how we changed the principal class,

00:50:21.840 --> 00:50:24.340
which as you recall is our factory class.

00:50:24.580 --> 00:50:29.560
First, I went into that nib file,
clicked on the file zone or object,

00:50:30.000 --> 00:50:34.430
then opened the inspector,
went to the custom class tab,

00:50:34.550 --> 00:50:37.320
and changed that class to
our view factory class.

00:50:37.340 --> 00:50:42.760
For the demo, we did the same thing for
the view class as well.

00:50:44.110 --> 00:50:47.860
The template provides us with
a default user interface.

00:50:47.860 --> 00:50:50.940
That's not really useful for
our particular audio unit,

00:50:51.090 --> 00:50:55.980
so we removed that information
and replaced it with a user

00:50:55.980 --> 00:51:01.330
interface that is more appropriate,
which in this case was a parameter

00:51:01.330 --> 00:51:05.760
text field for the cutoff frequency
parameter and a resonance text field.

00:51:05.780 --> 00:51:09.360
Additionally, we created a generic,
excuse me,

00:51:09.360 --> 00:51:13.150
a custom view in the center for
displaying our frequency curve.

00:51:15.230 --> 00:51:20.370
Now I'd like to take a look at
the steps that occur when the host

00:51:20.370 --> 00:51:23.100
loads our view for the first time.

00:51:23.100 --> 00:51:28.260
The host initially gets the view
by calling Audio Unit getProperty.

00:51:28.300 --> 00:51:31.730
It then gets back the bundle
URL and the main class name,

00:51:31.930 --> 00:51:35.100
loads the bundle,
and instantiates that class.

00:51:35.330 --> 00:51:39.750
Once that class is instantiated,
it calls the method in the

00:51:40.180 --> 00:51:45.470
protocol UIViewForAudiUnitWithSize,
which will then load the nib file,

00:51:45.870 --> 00:51:49.030
initialize the view,
create and initialize the view,

00:51:49.090 --> 00:51:52.100
and then it also returns the view.

00:51:52.240 --> 00:51:58.310
In the process of creating that view,
it will call the method in our code,

00:51:58.310 --> 00:52:03.070
setAU, which caches the Audio Unit,
creates and adds any listeners

00:52:03.100 --> 00:52:05.100
that we need for parameters.

00:52:05.100 --> 00:52:08.980
and then returns.

00:52:09.350 --> 00:52:13.520
So now let's go ahead and take
a look directly in the code.

00:52:13.570 --> 00:52:16.090
As I mentioned earlier,
our first step is to create a

00:52:16.150 --> 00:52:21.200
listener for those parameters that
we're interested in knowing about.

00:52:21.240 --> 00:52:24.950
This is done directly from the
setAU method I just showed you.

00:52:25.460 --> 00:52:29.920
And here we're registering a specific
dispatcher method that will be the main

00:52:29.920 --> 00:52:33.200
funnel for all event notifications.

00:52:33.250 --> 00:52:37.170
So anytime a parameter changes,
that method will be called.

00:52:37.280 --> 00:52:40.780
We specify the run loop and
the mode so we don't have to

00:52:40.780 --> 00:52:42.200
worry about threading issues.

00:52:42.320 --> 00:52:47.080
And then set up some
granularity and interval values.

00:52:47.810 --> 00:52:53.780
Our first step is to add a listener
to the cutoff frequency parameter.

00:52:53.780 --> 00:52:59.330
So we set up that parameter and then
specify the begin parameter change

00:52:59.350 --> 00:53:05.860
gesture event type and then call au event
listener at event type to register that

00:53:05.860 --> 00:53:09.020
we're interested in that specific event.

00:53:09.090 --> 00:53:12.330
And similarly,
we do the same thing for the end change

00:53:12.550 --> 00:53:17.070
gesture and the value change event.

00:53:20.090 --> 00:53:24.070
Our Event Dispatcher call,
which we registered previously,

00:53:24.090 --> 00:53:27.930
simply calls through to a Cocoa method,
which we will then handle

00:53:28.030 --> 00:53:29.460
those events directly.

00:53:29.510 --> 00:53:32.780
And that method, first of all,
looks at the event type.

00:53:32.820 --> 00:53:36.380
And if the type is a value change,
we need to make sure that

00:53:36.390 --> 00:53:37.940
we then update our UI.

00:53:37.990 --> 00:53:42.580
And we do that by,
if it's a cutoff frequency parameter,

00:53:42.640 --> 00:53:48.560
setting the float value of that field
to the parameter value that we get.

00:53:48.560 --> 00:53:51.010
Additionally,
we need to tell the graph to update its

00:53:51.070 --> 00:53:53.950
view as well for the frequency change.

00:53:53.980 --> 00:53:56.490
Resonance is handled in
exactly the same way,

00:53:56.490 --> 00:54:00.520
except we need to update a different
text field and notify the graph that

00:54:00.520 --> 00:54:05.110
the resonance parameter has changed,
passing the value in there.

00:54:06.160 --> 00:54:10.790
Handling the begin gesture is
done in exactly the same spot.

00:54:10.800 --> 00:54:14.490
As you recall from the demonstration,
we need to make sure that we highlight

00:54:14.490 --> 00:54:18.670
our crosshair to indicate that that
parameter value is being changed in

00:54:18.670 --> 00:54:20.980
a view other than our custom view.

00:54:20.990 --> 00:54:25.890
And we do that simply by telling
the graph view to update its state.

00:54:25.930 --> 00:54:29.770
And we handle the end parameter
change gesture the same way.

00:54:32.480 --> 00:54:39.880
Okay, that was quite a bit of code,
but we only have a little bit more to do.

00:54:39.940 --> 00:54:42.410
Primarily,
now we need to make sure that we

00:54:42.410 --> 00:54:46.400
can update the Audio Unit when the
user has changed our user interface,

00:54:46.400 --> 00:54:51.860
as opposed to changing our user interface
to reflect external value changes.

00:54:51.860 --> 00:54:56.400
So the user can interact with
our interface in two main ways:

00:54:56.400 --> 00:55:00.150
directly changing a text field value,
as I showed in my demo,

00:55:00.710 --> 00:55:02.360
or clicking and dragging in our graphs.

00:55:02.360 --> 00:55:06.300
So to handle the first
type of interaction,

00:55:06.470 --> 00:55:10.670
we've registered a method
that gets called via an

00:55:10.670 --> 00:55:12.890
IB action in Interface Builder.

00:55:13.410 --> 00:55:17.050
And here we simply need to get the
text value that's in our interface

00:55:17.050 --> 00:55:22.790
and call au_parameter_set to
not only set the value of the

00:55:22.800 --> 00:55:25.700
Audio Unit for that parameter,
but also to notify any

00:55:25.700 --> 00:55:28.070
listeners that that's occurred.

00:55:29.990 --> 00:55:34.170
For our custom view,
we are doing the same exact thing,

00:55:34.170 --> 00:55:37.640
but we have the capability of handling
two different parameters at a time,

00:55:37.760 --> 00:55:41.180
so we need to call
AU parameter set on both.

00:55:41.180 --> 00:55:43.590
Otherwise, the code's the same.

00:55:45.830 --> 00:55:50.260
When the user has clicked in our view,
we need to make sure that we

00:55:50.260 --> 00:55:53.500
notify any other listeners
that a gesture has occurred.

00:55:53.510 --> 00:55:56.990
And we do that by first
creating a parameter,

00:55:56.990 --> 00:56:00.610
and then setting the event type,
begin parameter, change gesture,

00:56:00.840 --> 00:56:05.280
and then notifying other
listeners that that has occurred.

00:56:05.290 --> 00:56:08.770
We do the same thing for
the resonance parameter.

00:56:09.690 --> 00:56:11.880
End-to-end gesture is
handled the same way,

00:56:11.910 --> 00:56:14.710
except the event type is different.

00:56:16.960 --> 00:56:19.520
Okay, right now we're almost finished.

00:56:19.710 --> 00:56:22.800
Our UI really can handle a lot of stuff.

00:56:22.850 --> 00:56:28.490
We can handle parameter changes that are
coming from other notification sources,

00:56:28.490 --> 00:56:32.230
as well as changes that are done
directly in our user interface

00:56:32.320 --> 00:56:37.440
via a text field change or via
interaction with our graph view.

00:56:37.800 --> 00:56:41.580
But we're really not quite there yet.

00:56:41.630 --> 00:56:45.330
We don't have the capacity to draw
that beautiful curve because we

00:56:45.330 --> 00:56:47.520
don't have access to that data.

00:56:47.540 --> 00:56:50.280
That data is generated in the Audio Unit.

00:56:50.450 --> 00:56:53.440
So how do we go from this view--

00:56:53.680 --> 00:56:56.180
to one that does have that information.

00:56:56.180 --> 00:56:59.910
Well, Chris is fortunately going to come
up and get us out of our dilemma.

00:57:00.170 --> 00:57:01.790
So Chris?

00:57:04.870 --> 00:57:11.280
So what we have here basically is
a curve that depends on both the

00:57:11.380 --> 00:57:12.910
cutoff frequency and the resonance.

00:57:13.060 --> 00:57:15.790
So if you drag that control point around,
of course,

00:57:15.790 --> 00:57:17.640
the shape of the curve will change.

00:57:17.730 --> 00:57:21.420
So we need to find out what the
curve is for a specific value of

00:57:21.530 --> 00:57:23.160
cutoff frequency and resonance.

00:57:23.170 --> 00:57:26.860
And the Audio Unit is the one that
knows what that curve looks like.

00:57:26.860 --> 00:57:33.210
And the view has to ask
the Audio Unit about that.

00:57:34.090 --> 00:57:37.490
Basically, the curve is just a
function of the frequency.

00:57:37.760 --> 00:57:38.900
It's a response value.

00:57:39.200 --> 00:57:43.400
Here it's plotted on a decibel scale.

00:57:43.460 --> 00:57:47.230
And the way that the view is going
to get that information from the

00:57:47.230 --> 00:57:50.190
Audio Unit is by using a custom property.

00:57:50.280 --> 00:57:55.040
Now, properties are basically just a
general way of passing information

00:57:55.040 --> 00:57:59.880
back and forth between an
Audio Unit and a host or a view.

00:58:00.130 --> 00:58:02.550
And the information is passed
with a void star pointer,

00:58:02.570 --> 00:58:06.900
so it can point to any type of data,
arbitrary data, and a length parameter,

00:58:07.020 --> 00:58:11.440
so it can be arbitrarily long or short.

00:58:12.950 --> 00:58:16.900
Inside of the Audio Unit,
there are two basic methods that

00:58:16.900 --> 00:58:23.770
we're going to be interested in today,
the Get Property Info and Get Property.

00:58:24.400 --> 00:58:27.300
And it's probably easier
just to look at the code,

00:58:27.300 --> 00:58:28.070
the next code.

00:58:28.380 --> 00:58:31.080
So if we could go to the demo machine,
please.

00:58:43.300 --> 00:58:47.770
Okay.

00:58:47.820 --> 00:58:52.570
Let's have a look at the property
stuff here in our filter class.

00:58:54.560 --> 00:58:59.700
So, first of all, get property info.

00:58:59.700 --> 00:59:06.120
We're giving information about a custom
property that we're going to define

00:59:06.120 --> 00:59:08.500
called Filter Frequency Response.

00:59:08.550 --> 00:59:10.360
That's just an integer.

00:59:10.650 --> 00:59:13.770
It's typed after Audio Unit Property ID.

00:59:13.860 --> 00:59:15.190
Let's see how we find that.

00:59:15.200 --> 00:59:20.230
We've given it a value of 65,536.

00:59:20.230 --> 00:59:26.050
Custom properties must have a value of
64,000 or greater because values below

00:59:26.050 --> 00:59:28.200
that are reserved for Apple's use.

00:59:28.200 --> 00:59:33.200
So, we've defined a property ID,
and while we're in this file,

00:59:33.200 --> 00:59:35.200
why don't we just have a
look at this structure here.

00:59:35.200 --> 00:59:38.640
I've defined a structure
called Frequency Response,

00:59:38.640 --> 00:59:43.200
which has two members,
the frequency and the magnitude response

00:59:43.200 --> 00:59:45.200
that corresponds to that frequency.

00:59:45.200 --> 00:59:49.360
So, what's going to happen is
the view is going to pass an

00:59:49.420 --> 00:59:53.200
array of these structures,
filling out all of the frequency

00:59:53.200 --> 00:59:56.820
values that it's interested in,
from the low frequencies

00:59:56.850 --> 00:59:58.690
up to the high frequencies.

00:59:59.100 --> 01:00:04.080
And then the Audio Unit is going
to calculate the magnitude response

01:00:04.220 --> 01:00:06.430
at that particular frequency value.

01:00:06.580 --> 01:00:16.080
And we're going to pass an array of 512,
size of 512, so 512 of these structures.

01:00:16.610 --> 01:00:19.160
And by the way,
this header file that we're looking at,

01:00:19.160 --> 01:00:24.530
this is a header file that's shared
by the UI and the Audio Unit.

01:00:24.610 --> 01:00:26.500
They both build off of this header file.

01:00:26.550 --> 01:00:27.700
There's no code being shared.

01:00:27.700 --> 01:00:31.530
It's just definitions.

01:00:31.820 --> 01:00:35.590
Okay, so we return the size
of the property here.

01:00:35.680 --> 01:00:38.190
It's not a writable property.

01:00:38.200 --> 01:00:39.490
It's just a readable property.

01:00:39.500 --> 01:00:43.430
And the size of the property is
the number of frequency responses,

01:00:43.490 --> 01:00:45.150
which we saw was 512.

01:00:45.290 --> 01:00:48.200
It's an array, size 512,
times the size of the structure.

01:00:48.200 --> 01:00:51.020
Okay?

01:00:52.170 --> 01:00:52.170
The second method

01:00:52.280 --> 01:00:59.350
To actually get the property information
is the get property method and well

01:00:59.350 --> 01:01:03.460
right here we have the Cocoa UI property
which Michael ran you through.

01:01:03.600 --> 01:01:07.420
That gets the information about
the Cocoa view but the one

01:01:07.420 --> 01:01:09.600
we really care about is the

01:01:10.090 --> 01:01:12.490
The new custom property
that we've defined,

01:01:12.490 --> 01:01:16.590
the filter frequency response property.

01:01:17.630 --> 01:01:19.660
One of the first things that we
do is we check to make sure that

01:01:19.660 --> 01:01:24.480
the Audio Unit is initialized,
because in this particular case,

01:01:24.480 --> 01:01:28.290
we require that the
AU kernel-based subclass,

01:01:28.380 --> 01:01:31.440
the filter kernel, be available.

01:01:31.440 --> 01:01:33.640
And that happens at initialization time.

01:01:33.640 --> 01:01:37.360
So if somebody tries to call for this
property when it's not initialized,

01:01:37.500 --> 01:01:39.010
then we return this error.

01:01:39.240 --> 01:01:41.500
And the custom view will check for that.

01:01:41.620 --> 01:01:45.850
And if it gets an error back,
it won't attempt to display a curve.

01:01:46.450 --> 01:01:50.220
So, as I said,
the information for a property is

01:01:50.220 --> 01:01:55.100
passed through a void star pointer,
and that's one of the arguments

01:01:55.100 --> 01:01:57.620
to our function right here.

01:01:57.620 --> 01:01:57.620
And,

01:01:58.580 --> 01:02:00.040
Okay.

01:02:00.130 --> 01:02:06.150
And what we do is we're -- I'm casting
that to a pointer to our structure,

01:02:06.370 --> 01:02:12.260
our frequency response structure
that we saw has two member variables.

01:02:12.260 --> 01:02:17.500
And basically what we're going to do is
we're just going to go through in a loop.

01:02:18.410 --> 01:02:22.140
512 times 'cause that's
the size of the array.

01:02:22.140 --> 01:02:27.130
Um, we're gonna get the frequency
that-- that Michael has asked

01:02:27.130 --> 01:02:29.000
about and wants to display.

01:02:29.040 --> 01:02:31.890
And then we're gonna ask
the signal processing code,

01:02:31.980 --> 01:02:34.900
which happens inside of
the-- the filter kernel,

01:02:35.030 --> 01:02:37.860
and call its get
frequency response method,

01:02:37.920 --> 01:02:41.600
asking it what the response is
for that particular frequency.

01:02:41.600 --> 01:02:45.520
And then we're gonna
put the result in the,

01:02:45.520 --> 01:02:49.740
um, member variable-- the
magnitude member variable.

01:02:49.890 --> 01:02:52.730
Let's just have a really quick
look at the get frequency response

01:02:52.730 --> 01:02:55.760
method to see what the signal
processing code does there.

01:02:55.960 --> 01:02:59.480
Um, so it's given the frequency.

01:02:59.490 --> 01:03:01.630
It gets the sample rate,
and then it does some

01:03:01.630 --> 01:03:05.200
mathematics that's--that's
particular to a biquad filter,

01:03:05.200 --> 01:03:08.120
which isn't-- you don't
have to understand that.

01:03:08.200 --> 01:03:13.500
The point is, is that it calculates, uh,
response value and returns that value.

01:03:13.500 --> 01:03:16.480
And after doing that 512 times, um,
it's gonna get the sample rate.

01:03:16.480 --> 01:03:16.480
And then it does some mathematics
that's particular to a biquad filter,

01:03:16.480 --> 01:03:16.480
which isn't-- you don't
have to understand that.

01:03:16.480 --> 01:03:16.480
The point is, is that it calculates, uh,
response value and returns that value.

01:03:16.480 --> 01:03:16.480
And after doing that 512 times,
And after doing that 512 times,

01:03:16.480 --> 01:03:20.810
in this loop, it returns,
and Michael now knows what

01:03:20.810 --> 01:03:22.920
the curve should look like.

01:03:23.160 --> 01:03:27.480
So, lastly,
Michael is going to take you through a

01:03:27.480 --> 01:03:30.070
little bit about how that's displayed.

01:03:30.080 --> 01:03:37.070
Michael Hopkins: Thank you, Chris.

01:03:37.320 --> 01:03:40.500
Can we go back to slides, please?

01:03:48.590 --> 01:03:52.870
So the user interface is
responsible for a couple of things.

01:03:53.040 --> 01:03:58.060
Firstly, it actually holds that frequency
response data and therefore

01:03:58.060 --> 01:04:01.000
needs to allocate the memory,
which we do in the source

01:04:01.010 --> 01:04:03.320
code via calling malloc.

01:04:03.320 --> 01:04:08.390
Once it's been allocated in the
setAU method that we saw earlier,

01:04:08.540 --> 01:04:13.350
we initialize the data with the
frequency values for each pixel

01:04:13.350 --> 01:04:18.970
location where we need to be able to
draw a corresponding decibel value.

01:04:19.110 --> 01:04:23.750
Once we have initialized that data,
we can then retrieve the frequency

01:04:23.800 --> 01:04:28.180
response curve from the Audio Unit by
calling AudioUnit.getProperty.

01:04:28.210 --> 01:04:30.680
And then finally, we can draw that curve.

01:04:30.930 --> 01:04:33.160
So let's take a look at the code there.

01:04:33.170 --> 01:04:35.490
Again, that's all on your CD,
so I encourage you to

01:04:35.590 --> 01:04:38.380
take a look at it later.

01:04:38.450 --> 01:04:45.660
The initialization occurs exactly once,
when the Audio Unit is initialized.

01:04:45.680 --> 01:04:50.920
It also can occur when
the window changes size,

01:04:51.120 --> 01:04:55.280
but primarily that data is very static.

01:04:55.280 --> 01:04:58.620
And we don't need to update
it every time we redraw.

01:04:58.730 --> 01:05:03.240
So we do a little bit of math to
calculate those pixels and the

01:05:03.240 --> 01:05:05.140
values that we need to display.

01:05:05.170 --> 01:05:08.880
And then we have a loop very similar
to what you just saw in Chris's code,

01:05:09.040 --> 01:05:13.160
where we compute the frequency value
for each of our pixel locations

01:05:13.520 --> 01:05:15.580
and stick that in the structure.

01:05:15.580 --> 01:05:15.700
here.

01:05:18.380 --> 01:05:23.420
Then we need to retrieve that data every
time we're ready to plot our curve.

01:05:23.440 --> 01:05:27.670
And that occurs right in our
event listener funnel where

01:05:27.670 --> 01:05:29.150
our notifications are handled.

01:05:29.770 --> 01:05:33.780
And that's because every time
we get a parameter value change,

01:05:33.800 --> 01:05:37.350
we then need to say, hey, Audio Unit,
please give me the new curve

01:05:37.350 --> 01:05:39.280
data because I need to redraw.

01:05:39.300 --> 01:05:43.570
And we do that by calling
Audio Unit get property.

01:05:46.060 --> 01:05:48.570
Once we've had that
information filled out,

01:05:48.640 --> 01:05:51.930
we can then ask the
GraphView to plot that curve.

01:05:51.930 --> 01:05:54.950
And that's pretty much
all there is to it.

01:06:01.860 --> 01:06:05.100
So there are a couple of other
sessions that are occurring here

01:06:05.100 --> 01:06:08.340
at the conference that I encourage
you to go to if you have a chance.

01:06:08.340 --> 01:06:12.720
There's an excellent session immediately
following this one on 3D audio,

01:06:12.720 --> 01:06:14.900
and there's a bunch of
really great demos there,

01:06:14.900 --> 01:06:16.640
so I encourage that.

01:06:16.640 --> 01:06:22.000
I also would like to stress our lab
that's occurring tomorrow at noon.

01:06:22.000 --> 01:06:25.890
And any of you that have any questions
about Audio Units or if you've had a

01:06:25.940 --> 01:06:30.740
chance to go through that sample code
and would like to get more information,

01:06:30.740 --> 01:06:32.480
we'll help you out with that.

01:06:32.480 --> 01:06:35.160
Also, during the beer bash,
we have a special event,

01:06:35.160 --> 01:06:39.230
which is our Plug Fest,
and that occurs at 6:00 on Thursday,

01:06:39.370 --> 01:06:41.670
so please come to that.

01:06:41.780 --> 01:06:49.350
And there's a lot of excellent resources
out there for people such as Bill Stort,

01:06:49.360 --> 01:06:53.260
who will be coming up in
a second to do the Q&A.

01:06:53.640 --> 01:06:57.040
But I also have a couple of
minor tips for you when you're

01:06:57.040 --> 01:06:59.330
developing your own Audio Unit.

01:06:59.470 --> 01:07:03.230
First, make sure that you use those Xcode
Audio Unit templates that we ship.

01:07:03.380 --> 01:07:06.040
You can download those from the ADC site.

01:07:06.070 --> 01:07:10.040
Make sure you register your
manufacturer code with us.

01:07:10.130 --> 01:07:13.450
Please use AUVAL to validate
your Audio Unit and make sure

01:07:13.460 --> 01:07:16.260
that you catch all your problems.

01:07:16.260 --> 01:07:18.740
And also make sure that
you make use of AULAB,

01:07:18.740 --> 01:07:23.150
which is in Developer Applications Audio,
to test your Audio Unit view.
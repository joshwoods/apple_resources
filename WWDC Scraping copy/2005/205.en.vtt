WEBVTT

00:00:00.860 --> 00:00:03.100
Good afternoon.

00:00:03.160 --> 00:00:05.430
Welcome to 3D
Environmental Audio with OpenAL.

00:00:05.440 --> 00:00:07.540
My name is Elliot Sedegah,
and I'm going to give you

00:00:07.540 --> 00:00:09.900
a brief overview to OpenAL.

00:00:10.090 --> 00:00:13.430
And hopefully by the end of this session,
you have a great understanding of how

00:00:13.430 --> 00:00:16.290
OpenAL works and how you can begin
integrating it into your application

00:00:16.420 --> 00:00:20.120
so you can get great surround
sound for your 3D environment.

00:00:20.780 --> 00:00:22.760
So, what is OpenAL?

00:00:22.940 --> 00:00:25.940
OpenAL is a cross-platform
2D and 3D audio API.

00:00:25.940 --> 00:00:28.950
The API is originally designed
for games but can be used in

00:00:28.960 --> 00:00:30.340
many other applications as well.

00:00:30.340 --> 00:00:33.540
It's a great companion to OpenGL,
so if you have existing

00:00:33.540 --> 00:00:36.790
OpenGL code out there,
it's a great API choice that you can

00:00:36.840 --> 00:00:39.710
take and integrate into your code,
and then you're off and

00:00:39.810 --> 00:00:42.130
running with great surround
sound for your 3D environment.

00:00:42.900 --> 00:00:45.460
It's also open source,
so you can go to the OpenAL website,

00:00:45.460 --> 00:00:48.250
download the latest sources,
and take a look and see how it's

00:00:48.250 --> 00:00:51.400
supported for all the existing
platforms that it's out there for.

00:00:51.400 --> 00:00:54.070
And another little bit of good
news is it's now shipping as a

00:00:54.090 --> 00:00:57.040
pre-installed framework for Tiger,
so it's going to be there for

00:00:57.040 --> 00:00:58.900
all your users using 10.4.

00:00:58.900 --> 00:01:01.010
And if you're looking for
support earlier than that,

00:01:01.010 --> 00:01:03.800
it goes as far back as 10.28,
so that's pretty good news.

00:01:06.030 --> 00:01:07.750
Let's talk about some of
the main features of OpenAL.

00:01:08.050 --> 00:01:10.900
With OpenAL,
you get stereo and surround sound.

00:01:11.080 --> 00:01:13.900
This is great for your 3D environment,
so you're not limited to just a stereo

00:01:13.990 --> 00:01:15.340
with the right and left channels.

00:01:15.340 --> 00:01:18.180
You get surround sound using
all your speakers up to 5.0.

00:01:18.180 --> 00:01:21.490
And you get positional audio,
so you can localize sound

00:01:21.490 --> 00:01:23.330
in three-dimensional space.

00:01:23.330 --> 00:01:25.710
For example,
if you had an object on the right

00:01:25.790 --> 00:01:29.010
side of your screen and you wanted
your user to experience sound

00:01:29.010 --> 00:01:31.900
coming from the right speaker,
you can easily do that by

00:01:31.900 --> 00:01:34.060
supplying coordinates to OpenAL.

00:01:34.060 --> 00:01:37.490
And if you can move this object
around from right to left,

00:01:37.500 --> 00:01:40.370
and then you get a panning-like
effect moving from the right

00:01:40.370 --> 00:01:41.440
speaker to the left speaker.

00:01:41.590 --> 00:01:43.480
And you can move it back
and forth in a distance,

00:01:43.510 --> 00:01:45.450
and depending on the distance
it is from a listener,

00:01:45.450 --> 00:01:47.090
the sound will be attenuated.

00:01:47.090 --> 00:01:49.200
So it will be sounding a
little bit softer or louder

00:01:49.210 --> 00:01:50.530
depending on the distance.

00:01:50.540 --> 00:01:54.680
You can change the pitch, too,
and you can do all this while it's

00:01:55.010 --> 00:01:57.090
playing without much work at all.

00:01:58.090 --> 00:02:00.880
OpenAL uses the same exact
coordinates as OpenGL.

00:02:01.020 --> 00:02:04.730
So OpenGL uses a 3D Cartesian
coordinate system using the X,

00:02:04.730 --> 00:02:05.990
Y, and Z planes.

00:02:06.000 --> 00:02:08.000
So if you look at the
chart on your screen here,

00:02:08.000 --> 00:02:11.840
you can see a point in
three-dimensional space at 0.5,

00:02:11.840 --> 00:02:13.000
5, and 0.

00:02:13.000 --> 00:02:17.000
If you wanted to specify
this point using OpenGL code,

00:02:17.000 --> 00:02:19.000
many of you might be already
familiar with OpenGL,

00:02:19.000 --> 00:02:22.840
and you would use a GL vertex
command with the floats 5,

00:02:22.840 --> 00:02:24.000
5, and 0.

00:02:24.000 --> 00:02:26.270
In OpenAL,
if you wanted to attach a sound source to

00:02:26.380 --> 00:02:30.680
this object in three-dimensional space,
this could be an explosion,

00:02:30.680 --> 00:02:34.000
this could be a plane flying overhead,
it could be a car driving by,

00:02:34.000 --> 00:02:37.980
whatever you want it to be in your game,
you can use the AL source command

00:02:38.000 --> 00:02:42.000
and use the same exact coordinates
that you're using in OpenGL space,

00:02:42.000 --> 00:02:45.400
so you can see how your variables
can be reused and you can add

00:02:45.400 --> 00:02:49.000
sound and integrate it into
your game or your application.

00:02:50.820 --> 00:02:54.630
Another interesting thing to point
out here is that OpenAL also uses

00:02:54.640 --> 00:02:58.100
the same API conventions as OpenGL.

00:02:58.240 --> 00:03:01.210
So you can see the three
F here in GL space.

00:03:01.300 --> 00:03:04.760
Most of you guys are familiar with it,
knowing that this is supposed

00:03:04.760 --> 00:03:07.950
to specify you needed to add
three floats to this method.

00:03:08.040 --> 00:03:11.080
The same exact thing is done in OpenAL,
and this convention is

00:03:11.250 --> 00:03:12.360
followed throughout.

00:03:12.480 --> 00:03:17.260
So it'll be easy for you
GL programmers to pick up on this,

00:03:17.260 --> 00:03:18.090
and you'll be up and running in no time.

00:03:22.390 --> 00:03:26.000
OpenAL is built with
Core Audio for Mac OS X.

00:03:26.000 --> 00:03:28.180
So it's built entirely with Core Audio.

00:03:28.180 --> 00:03:31.480
Core Audio is used to interface to
all of the user's audio devices,

00:03:31.480 --> 00:03:35.400
so FireWire, USB,
stereo or surround sound,

00:03:35.400 --> 00:03:39.040
everything that the user can support,
OpenAL is going to get that.

00:03:39.080 --> 00:03:41.940
And it's combined with
the power of audio units,

00:03:41.940 --> 00:03:45.300
the 3D mixer audio unit,
which is used to localize your

00:03:45.360 --> 00:03:47.570
sound in three-dimensional space.

00:03:47.660 --> 00:03:50.530
So you can have your objects just mixed,
and you don't have to worry

00:03:50.530 --> 00:03:52.010
about all the hard work there.

00:03:52.300 --> 00:03:55.170
The OpenAL implementation
is going to do that for you,

00:03:55.450 --> 00:03:58.410
because the 3D mixer handles
the localization and it

00:03:58.410 --> 00:04:01.680
handles speaker configurations,
sample rate conversions,

00:04:01.730 --> 00:04:04.120
a lot of the really difficult
work that it takes to get a good

00:04:04.330 --> 00:04:05.560
sound engine up and running.

00:04:05.560 --> 00:04:08.370
And it's packaged inside a nice,
easy-to-use API,

00:04:08.380 --> 00:04:11.500
so you can just use that code
and you're up and running.

00:04:13.660 --> 00:04:14.500
It's also cross-platform.

00:04:14.500 --> 00:04:17.080
So the code that you write for us,
you can use it other places as well.

00:04:17.300 --> 00:04:20.340
Mac OS X's implementation
is done in Core Audio,

00:04:20.340 --> 00:04:24.270
and that same code can be used in
other platforms that you care about,

00:04:24.280 --> 00:04:29.400
such as Windows and Linux,
other game platforms as Sony PS2,

00:04:29.400 --> 00:04:31.600
GameCube, Xbox, just to name a few.

00:04:31.600 --> 00:04:34.300
There's a large listing of
platforms that are supported,

00:04:34.300 --> 00:04:36.980
and if you're interested in what
their underlying implementation is,

00:04:37.070 --> 00:04:41.520
you can go to the OpenAL website,
and it has details on the website,

00:04:41.630 --> 00:04:45.400
So you can make that in your decisions
when you're making your game.

00:04:46.360 --> 00:04:49.500
Here's a list of a few games that
we have that are running OpenAL.

00:04:49.500 --> 00:04:52.000
I mean, there's a longer list than this,
but we just took out a few

00:04:52.000 --> 00:04:53.440
just to illustrate a point.

00:04:53.440 --> 00:04:55.560
And as you can see,
these are major titles.

00:04:56.400 --> 00:04:57.750
Really big.

00:04:57.760 --> 00:04:59.740
The list has been growing
over the past year.

00:04:59.740 --> 00:05:03.960
You can see on here that a lot
of these are also cross-platform.

00:05:03.960 --> 00:05:05.980
And OpenAL is a big reason for this.

00:05:06.000 --> 00:05:07.800
Because of the
cross-platform code nature,

00:05:07.900 --> 00:05:10.880
you really had to make maybe a
few changes just to get it running

00:05:10.880 --> 00:05:12.510
on several different platforms.

00:05:12.520 --> 00:05:15.900
And if you look on here,
you can see Blender 3D.

00:05:16.240 --> 00:05:18.180
And that's not a game.

00:05:18.180 --> 00:05:21.420
And you can see that this is
not limited just to games.

00:05:21.420 --> 00:05:25.350
So if you have an application
that's 3D and you want 3D sound,

00:05:25.360 --> 00:05:26.720
OpenAL is a great choice.

00:05:28.380 --> 00:05:30.260
Game engines and libraries are
also hopping into the action,

00:05:30.360 --> 00:05:30.930
too.

00:05:30.940 --> 00:05:33.640
Many popular ones that I'm sure
many of you could be using,

00:05:33.640 --> 00:05:39.140
Agent AE, Torque, and Unreal,
they're all adopting to use OpenAL now,

00:05:39.140 --> 00:05:40.920
mainly because of their
cross-platform nature,

00:05:40.940 --> 00:05:44.690
some reasons because of the performance,
many different reasons

00:05:44.690 --> 00:05:46.210
why you should use OpenAL.

00:05:46.710 --> 00:05:52.070
Now that you know how OpenAL works,
just the overall 30,000 feet view of,

00:05:52.250 --> 00:05:56.500
hey, this is what it does,
I'd like to invite Ryan Gordon,

00:05:56.500 --> 00:06:00.110
freelance software
developer on the stage,

00:06:00.110 --> 00:06:05.450
give you a brief story about how
his experience is using OpenAL.

00:06:07.450 --> 00:06:09.750
Can you hear me?

00:06:09.820 --> 00:06:11.100
Okay, good.

00:06:11.260 --> 00:06:12.280
Hi, my name is Ryan Gordon.

00:06:12.280 --> 00:06:13.840
I'm a freelance game developer.

00:06:13.840 --> 00:06:19.290
Mostly I specialize in porting
games from Windows to Mac OS and

00:06:19.440 --> 00:06:20.480
Linux and things like that.

00:06:20.510 --> 00:06:23.260
So what we're going to show
you on the screen back here is

00:06:23.270 --> 00:06:24.930
a game called Feeding Frenzy.

00:06:25.070 --> 00:06:28.560
The OpenAL is a game piloted
by the talented Rich Hernandez,

00:06:28.560 --> 00:06:30.990
who is a feeding frenzy ninja.

00:06:30.990 --> 00:06:33.000
Basically, this game is very simple.

00:06:33.000 --> 00:06:38.880
What I want to talk to you about
is mostly we talk in OpenAL in

00:06:38.880 --> 00:06:42.980
terms of positional audio,
3D space, and...

00:06:43.500 --> 00:07:17.900
[Transcript missing]

00:07:18.050 --> 00:07:21.600
So, what we're looking at
here with Feeding Frenzy,

00:07:21.600 --> 00:07:22.140
it's very simple.

00:07:22.140 --> 00:07:23.840
You've probably already picked
up the rules of this game.

00:07:23.840 --> 00:07:26.690
You move a fish around the screen,
you eat smaller fish,

00:07:26.690 --> 00:07:28.380
you avoid the bigger fish,
and as you get bigger,

00:07:28.440 --> 00:07:29.670
you eat the bigger fish too.

00:07:29.790 --> 00:07:32.510
It's a little bit of
Darwinism in your video game.

00:07:32.510 --> 00:07:35.310
But it's simple, it's non-intrusive,
it's non-threatening.

00:07:35.320 --> 00:07:36.950
You could give this to your
grandmother and she would love it.

00:07:37.050 --> 00:07:41.920
And by the way,
it's on sale now at gamehouse.com.

00:07:41.990 --> 00:07:45.390
So, this was originally a Windows title.

00:07:45.580 --> 00:07:48.400
When we first started working with this,
it was Windows that used DirectX.

00:07:48.410 --> 00:07:50.830
Specifically for audio,
it used 2D direct sound,

00:07:50.830 --> 00:07:52.160
not even direct sound 3D.

00:07:52.160 --> 00:07:54.250
And looking at options
to move this to the Mac,

00:07:54.250 --> 00:07:56.720
we thought about Core Audio,
we thought about SDL,

00:07:56.720 --> 00:07:59.360
we thought about SDL Mixer, you know,
higher-level things.

00:07:59.360 --> 00:08:04.580
And we found that OpenAL was actually
the best choice for a number of reasons.

00:08:06.070 --> 00:08:10.820
When you look at the original game,
as you are now, when you look at this,

00:08:10.820 --> 00:08:14.680
it only wanted to do things at the
source code level at a high level,

00:08:14.680 --> 00:08:17.470
in higher-level stuff.

00:08:17.520 --> 00:08:21.330
For example, they wanted to do, you know,
play this sound, just fire this sound

00:08:21.330 --> 00:08:22.650
off and forget about it.

00:08:22.680 --> 00:08:24.670
We want to stream music,
but we don't really want to do

00:08:24.670 --> 00:08:27.270
anything but play it in the background,
nothing fancy like that.

00:08:27.340 --> 00:08:30.080
At most, in terms of positional audio,
it wants to pan things left

00:08:30.080 --> 00:08:32.580
and right on stereo speakers,
but it doesn't really want to

00:08:32.580 --> 00:08:33.850
think about it beyond that.

00:08:33.890 --> 00:08:35.920
In that sense,
OpenAL worked incredibly well.

00:08:35.940 --> 00:08:38.900
Because that maps very
closely to the API.

00:08:38.900 --> 00:08:42.340
Instead of talking about a 3D thing,
you just talk about things on one plane.

00:08:42.340 --> 00:08:46.940
But otherwise, you use the API exactly as
you would in a 3D sense.

00:08:46.940 --> 00:08:52.400
So when we started working on this,
we moved it from direct sound to OpenAL.

00:08:52.400 --> 00:08:54.000
And instead of trying
to re-engineer stuff,

00:08:54.000 --> 00:08:56.500
anyone who's ever reported a video game,
reported any software,

00:08:56.500 --> 00:08:58.090
knows you don't want to
touch the original source

00:08:58.090 --> 00:08:59.060
any more than you have to.

00:09:00.450 --> 00:09:01.680
Okay, maybe you haven't done that.

00:09:01.760 --> 00:09:04.280
So we started working on this.

00:09:04.280 --> 00:09:07.190
Instead of trying to re-engineer things,
say, how can we make this work best

00:09:07.250 --> 00:09:11.380
with an alien audio API and such,
we moved it over.

00:09:11.380 --> 00:09:15.320
We just copied the file one, you know,
just directly copied the C file that

00:09:15.520 --> 00:09:18.080
implemented all the direct sound stuff
and just went through it line by line,

00:09:18.080 --> 00:09:20.680
cutting out the direct sound stuff,
leaving the higher level structure

00:09:20.680 --> 00:09:22.800
there and just replacing it
line for line with OpenAL.

00:09:22.800 --> 00:09:26.440
So we did a word count,
a line count on this the other day

00:09:26.440 --> 00:09:27.960
to see just where this turned out,
you know,

00:09:27.970 --> 00:09:29.760
now that everything's done and debugged.

00:09:30.400 --> 00:09:34.360
Changing it from direct sound
to OpenAL took about a day,

00:09:34.380 --> 00:09:38.130
and that's to write it and debug
it and play it and be done with it.

00:09:38.280 --> 00:09:41.360
That worked out incredibly nicely because
no one wants to spend time working.

00:09:41.360 --> 00:09:42.610
I don't, I don't know.

00:09:42.730 --> 00:09:46.260
So after that was done and
after spending a day on it,

00:09:46.260 --> 00:09:49.990
I looked at the line counts,
and the direct sound code...

00:09:50.210 --> 00:09:56.100
Went from about 3,500 lines of C code,
just straight, no-nonsense C++ code,

00:09:56.100 --> 00:09:57.600
3,500 lines.

00:09:57.600 --> 00:09:58.740
When we were done with
the OpenAL version,

00:09:58.740 --> 00:10:00.060
it was about 1,000 lines.

00:10:00.060 --> 00:10:08.940
So literally, it was three and a half
times less code to deal with,

00:10:08.940 --> 00:10:10.190
which is wonderful in terms of debugging
and maintenance and such like that.

00:10:10.600 --> 00:10:12.290
So,
some of the other basic benefits here,

00:10:12.290 --> 00:10:14.750
just to run down this very quickly,
and you're going to hear some

00:10:14.750 --> 00:10:17.180
of these things again and
again throughout this session,

00:10:17.180 --> 00:10:18.850
but it was cross-platform.

00:10:18.860 --> 00:10:22.040
The exact same OpenAL code,
when we were done replacing

00:10:22.040 --> 00:10:25.780
the direct sound code,
ran on Windows, Linux, and Mac OS.

00:10:25.780 --> 00:10:28.600
Out of the box, there was exactly zero
if-defs in the code.

00:10:28.600 --> 00:10:30.080
There's none at all.

00:10:30.080 --> 00:10:31.560
Just the exact same
code worked everywhere.

00:10:31.560 --> 00:10:33.320
Now, to be fair,
there are zero if-defs in the

00:10:33.380 --> 00:10:35.530
direct sound code as well,
but that's only going to run

00:10:35.530 --> 00:10:37.120
on Windows for obvious reasons.

00:10:38.260 --> 00:10:40.040
So, that worked out incredibly well.

00:10:40.040 --> 00:10:42.250
In terms of maintenance,
there's less to look at,

00:10:42.510 --> 00:10:43.350
less to figure out.

00:10:43.430 --> 00:10:45.720
There's no corner cases
in it where you think,

00:10:45.720 --> 00:10:48.680
you know, geez,
did I set up this primary direct sound

00:10:48.680 --> 00:10:50.740
buffer to be in cooperative mode?

00:10:50.770 --> 00:10:52.540
And what happens if
they change users on me?

00:10:52.540 --> 00:10:54.530
Will it stop playing
music and such like that?

00:10:54.570 --> 00:10:56.240
And those things became a non-issue.

00:10:56.240 --> 00:10:59.550
We never had to look at this
in terms of a byte-wise buffer.

00:10:59.640 --> 00:11:02.730
We never had to think, okay,
we have 10 bytes left in this buffer,

00:11:02.760 --> 00:11:06.120
then we have to wrap around the
beginning and start writing stuff there.

00:11:06.120 --> 00:11:09.010
You know, with OpenAL, you just say,
"Hey, I have this much more data.

00:11:09.120 --> 00:11:12.130
Please play it when you get a chance."
With the buffer queuing mechanism,

00:11:12.250 --> 00:11:13.420
and it works great.

00:11:13.420 --> 00:11:16.870
Another benefit, and this is true in the
direct sound version too,

00:11:16.950 --> 00:11:18.920
is that the Windows version
is stereo only.

00:11:18.920 --> 00:11:21.120
And, you know, like I said,
we're not using positional audio,

00:11:21.120 --> 00:11:22.640
but it's always nice
to know that on a Mac,

00:11:22.640 --> 00:11:25.130
when you're using OpenAL,
if you have eight speakers

00:11:25.130 --> 00:11:27.320
hooked up to your machine,
if you have a five-speaker

00:11:27.320 --> 00:11:29.800
setup or whatever,
if you have more than two speakers,

00:11:29.900 --> 00:11:31.320
it's just going to work right.

00:11:31.320 --> 00:11:33.320
I don't have to be like, "Well,
all but your first two

00:11:33.370 --> 00:11:34.420
speakers are going to be quiet.

00:11:34.420 --> 00:11:36.420
Sorry,
there's nothing we can do about it."

00:11:36.420 --> 00:11:38.070
That was a huge benefit for that.

00:11:38.480 --> 00:11:40.130
Um,

00:11:40.630 --> 00:11:41.340
That's pretty much it.

00:11:41.400 --> 00:11:43.150
Otherwise,
it was just in terms of man-hours

00:11:43.150 --> 00:11:46.780
and maintenance and code size
and readability and usability,

00:11:46.780 --> 00:11:47.660
all of those things.

00:11:47.660 --> 00:11:51.640
OpenAL was just incredibly
better for us than DirectSound.

00:11:51.640 --> 00:11:54.940
And to be fair,
if you look at most APIs out there,

00:11:54.940 --> 00:11:58.540
you're going to find that if you'd
moved it to any other API such as SDL,

00:11:58.540 --> 00:12:02.040
you're going to find a lot of these
same benefits that OpenAL gave you.

00:12:02.040 --> 00:12:04.420
You find that you'd
have these same fights.

00:12:04.450 --> 00:12:06.140
I don't want to blame
DirectSound specifically,

00:12:06.140 --> 00:12:08.340
although I know it's easy to
do at a Macintosh conference.

00:12:08.660 --> 00:12:12.400
But in those senses,
it worked out very well for us.

00:12:12.430 --> 00:12:15.020
I would definitely use it.

00:12:15.110 --> 00:12:17.260
This is the first 2D
game I'd used OpenAL on.

00:12:17.260 --> 00:12:19.070
I didn't expect it to be this easy.

00:12:19.070 --> 00:12:21.090
I thought it worked out really well.

00:12:21.120 --> 00:12:24.780
Mostly before now,
my OpenAL usage was on 3D

00:12:24.780 --> 00:12:26.540
games for obvious reasons.

00:12:26.540 --> 00:12:28.780
But even on a 2D game,
it worked out great.

00:12:28.910 --> 00:12:32.980
So don't be intimidated to use this API,
even if you don't have a big,

00:12:32.980 --> 00:12:37.620
grand-scale, multi-million-dollar, 3D,
immersive, complicated game.

00:12:37.850 --> 00:12:40.380
Even for independent developers
or small-scale developers

00:12:40.380 --> 00:12:43.020
or puzzle game developers,
it works out wonderfully.

00:12:43.020 --> 00:12:44.410
I'd highly recommend it to anyone.

00:12:44.420 --> 00:12:46.290
So that's what I have to say.

00:12:46.360 --> 00:12:47.800
Thank you, Rich, for helping us out here.

00:12:47.800 --> 00:12:50.900
I'm going to give the
microphone over to Bob now,

00:12:50.900 --> 00:12:53.120
who's a core audio engineer,
and he's going to talk some more

00:12:53.230 --> 00:12:54.290
about the specifics of OpenAL.

00:12:54.320 --> 00:12:56.070
Thank you.

00:12:57.930 --> 00:12:58.900
Yeah, that was great.

00:12:58.900 --> 00:13:00.050
Thanks.

00:13:00.290 --> 00:13:01.620
Good afternoon.

00:13:01.820 --> 00:13:05.900
My name is Bob Aaron,
and I work at Apple as

00:13:05.900 --> 00:13:07.640
a Core Audio engineer.

00:13:07.680 --> 00:13:12.140
And I'm gonna talk a little
bit about how to use OpenAL.

00:13:12.140 --> 00:13:15.880
So if we can get back to the slides,
please.

00:13:18.960 --> 00:13:20.340
Okay,
so the main thing I want you to take

00:13:20.340 --> 00:13:23.240
away from my part of the session
really is an understanding of

00:13:23.250 --> 00:13:26.420
what the OpenAL architecture looks
like and how the APIs are used.

00:13:26.500 --> 00:13:30.500
And secondly, as Ryan and Elliot have
already alluded to,

00:13:30.500 --> 00:13:35.080
to see what the benefit really is for
you to use OpenAL in your application.

00:13:35.080 --> 00:13:38.550
By letting OpenAL do all
the difficult audio work,

00:13:38.550 --> 00:13:44.630
such as optimized audio processing and
dealing with the devices on your user

00:13:44.680 --> 00:13:47.570
system and multi-speaker configurations.

00:13:49.660 --> 00:13:52.900
So if we take just a top-level view
of what the architecture looks like,

00:13:52.950 --> 00:13:57.500
we can see that OpenAL basically
is divided up into five components.

00:13:57.580 --> 00:14:01.100
And the first thing you'll want to
do when you're adding OpenAL into

00:14:01.100 --> 00:14:03.820
your application is you have to
do a little bit of initializing.

00:14:03.820 --> 00:14:08.220
And so the first component we'll
talk about is the OpenAL device.

00:14:08.220 --> 00:14:13.230
Now the OpenAL device is the component
that basically is going to deliver your

00:14:13.260 --> 00:14:16.180
rendered audio data out to some hardware.

00:14:17.140 --> 00:14:22.290
And on Mac OS X,
this device is the default output device

00:14:22.310 --> 00:14:25.680
that your user sets up in their system
preferences or in the audio MIDI setup.

00:14:25.680 --> 00:14:27.970
And what's really nice
about this mechanism is,

00:14:28.100 --> 00:14:30.200
again,
your application doesn't have to know

00:14:30.200 --> 00:14:33.440
anything about the hardware on your
system or the speakers or anything.

00:14:33.440 --> 00:14:36.780
It's just going to work and render out
to what your user has already selected.

00:14:39.060 --> 00:14:42.680
Now the next component you'll need to
do-- to look at when you are doing some

00:14:42.680 --> 00:14:44.900
initializing is the OpenAL Context.

00:14:44.980 --> 00:14:47.190
Now this is your rendering context.

00:14:47.290 --> 00:14:51.700
It's basically your virtual space,
or your environment for your

00:14:51.700 --> 00:14:53.340
game or your application.

00:14:53.490 --> 00:14:57.340
Now it contains some objects
that are moving around in space,

00:14:57.340 --> 00:14:58.670
making sound.

00:14:58.710 --> 00:15:01.960
An object that moves also around
in space that it can observe

00:15:01.970 --> 00:15:03.720
all those sound making objects.

00:15:04.000 --> 00:15:08.300
And it defines some parameters on
how all of those things are rendered.

00:15:08.420 --> 00:15:15.410
And then ultimately delivers the
rendered audio out to the OpenAL device.

00:15:16.500 --> 00:15:18.470
So these are what the APIs look like,
basically,

00:15:18.560 --> 00:15:22.940
for opening and closing devices and
creating and destroying context.

00:15:22.980 --> 00:15:26.400
But instead of walking through
the APIs parameter at a time,

00:15:26.400 --> 00:15:28.810
let me just show you
a little bit of code.

00:15:29.830 --> 00:15:33.720
So I'm going to run a
small demo in a little bit,

00:15:33.720 --> 00:15:37.360
and I'll show you all the OpenAL code
that's needed to run this.

00:15:37.360 --> 00:15:38.860
And so we'll start out here.

00:15:38.860 --> 00:15:42.850
The first line there that the arrow's
pointing to is a call to ALC OpenDevice.

00:15:43.000 --> 00:15:46.060
Now, you notice that it's passing null.

00:15:46.060 --> 00:15:49.750
The reason we're doing
that on Mac OS X is null,

00:15:49.750 --> 00:15:53.630
this is the device name string,
but since we're always using

00:15:53.710 --> 00:15:56.080
the default output device,
we can just pass null.

00:15:56.400 --> 00:15:59.580
That sort of indicates to
use the system device or the

00:15:59.590 --> 00:16:01.890
default device for the user.

00:16:02.740 --> 00:16:05.690
Now,
once we actually have that device back,

00:16:05.790 --> 00:16:08.840
we need to pass it to
a create context call.

00:16:08.890 --> 00:16:11.600
And the context call,
you can have multiple contexts,

00:16:11.600 --> 00:16:14.520
and they always render to that device,
so you have to pass the device in.

00:16:14.600 --> 00:16:17.120
Now, you notice that there's
a second parameter,

00:16:17.120 --> 00:16:17.580
zero.

00:16:17.670 --> 00:16:19.100
That's actually an attribute list.

00:16:19.200 --> 00:16:21.600
On Mac OS X,
you don't have to pass any attributes.

00:16:21.600 --> 00:16:23.970
You can just pass zero there.

00:16:24.660 --> 00:16:28.650
And then lastly, as I mentioned,
you can have multiple contexts

00:16:28.650 --> 00:16:32.570
or multiple spatial environments,
but you have to have one that's

00:16:32.700 --> 00:16:34.800
designated as the current context.

00:16:34.840 --> 00:16:37.960
That's the context that
will receive changes.

00:16:37.980 --> 00:16:43.060
You have to have it defined already so
that as you make changes to parameters,

00:16:43.060 --> 00:16:46.350
the API knows which context
you're talking about.

00:16:47.690 --> 00:16:50.460
Okay, so now that we have our
device and our context,

00:16:50.460 --> 00:16:53.580
the next object we'll talk
about is the OpenAO listener.

00:16:53.600 --> 00:16:56.540
Now,
the listener is implicit to your context.

00:16:56.610 --> 00:17:00.460
Each context has a single listener,
and it can be moved around in space,

00:17:00.460 --> 00:17:02.360
just like the objects
that are making sound.

00:17:02.460 --> 00:17:06.860
And it's really the object that
represents how your user is going

00:17:06.860 --> 00:17:10.460
to experience your application
when they're running it,

00:17:10.480 --> 00:17:14.430
and so for you GL programmers,
it would equate, basically, to a camera.

00:17:14.500 --> 00:17:19.720
It's, again, the way that your user is
going to experience this.

00:17:21.980 --> 00:17:24.740
So one of the most important
attributes you'll be setting for your

00:17:24.740 --> 00:17:27.700
OpenAL listener is the orientation.

00:17:27.720 --> 00:17:30.700
Now again, in GL terms,
your orientation is like making

00:17:30.700 --> 00:17:32.200
a call to GL you look at.

00:17:32.470 --> 00:17:36.850
It defines which way your listener
is looking in your virtual space.

00:17:37.110 --> 00:17:42.270
And so it's defined as two vectors,
an at vector and an up vector.

00:17:42.380 --> 00:17:45.280
And those are XYZ vectors,
and they must be

00:17:45.280 --> 00:17:46.700
orthogonal to each other.

00:17:46.730 --> 00:17:49.800
That's defined in the specification.

00:17:50.540 --> 00:17:52.430
And if you look at the little
code box at the bottom,

00:17:52.500 --> 00:17:56.150
again, you're going to see some
conventions that are similar to GL.

00:17:56.400 --> 00:18:00.400
We have an AL listener FV, F for float,
V for vector.

00:18:00.400 --> 00:18:07.420
And we're going to pass in
those at and up XYZ vectors.

00:18:08.240 --> 00:18:11.300
Now to demonstrate sort of
how the orientation works,

00:18:11.460 --> 00:18:12.590
let me just show you a diagram.

00:18:12.810 --> 00:18:15.920
So on the left-hand side there,
we have a virtual space,

00:18:16.010 --> 00:18:17.500
and it contains some objects.

00:18:17.680 --> 00:18:19.740
And in the center is our listener.

00:18:19.840 --> 00:18:22.460
And then the circles,
the blue and the red circles,

00:18:22.460 --> 00:18:26.200
are some graphical objects that
you may have in your application.

00:18:26.230 --> 00:18:31.470
And then the text there for car
horn and dog barking sort of

00:18:31.480 --> 00:18:34.560
represents some objects that may be
making sound in your environment.

00:18:34.730 --> 00:18:37.730
This is a top-down view on
the X and Z coordinates.

00:18:37.820 --> 00:18:41.240
If we look on the right-hand
side of the screen,

00:18:41.240 --> 00:18:43.910
this would represent the user
sitting in front of their monitor.

00:18:44.230 --> 00:18:47.680
They can experience that blue object,
they can see it in their monitor,

00:18:47.740 --> 00:18:51.900
but they can localize the car horn
and the dog barking appropriately

00:18:51.900 --> 00:18:54.570
in front and to the rear right.

00:18:54.600 --> 00:18:57.600
I just wanted to point
out one more thing.

00:18:57.720 --> 00:19:01.600
This is the default orientation for your
listener when your context is created.

00:19:01.600 --> 00:19:03.430
It's looking down the negative Z axis.

00:19:03.600 --> 00:19:06.470
So if we wanted your
listener to experience,

00:19:06.740 --> 00:19:09.600
be able to experience the
other graphical objects,

00:19:09.600 --> 00:19:14.520
we can now turn around your,
the sign on your Z axis,

00:19:14.600 --> 00:19:17.280
and now he's looking this way.

00:19:17.410 --> 00:19:21.960
And so now if we see what the user is
looking at in front of this machine,

00:19:21.960 --> 00:19:24.000
you can now see that red circle.

00:19:24.330 --> 00:19:28.570
But you notice that the audio objects now
are being localized in a different place.

00:19:28.800 --> 00:19:31.090
The dog barking is now
to their front left,

00:19:31.280 --> 00:19:33.360
and the car horn is to their right.

00:19:33.510 --> 00:19:37.060
And the reason I wanted to show this
is there's one sort of main difference,

00:19:37.160 --> 00:19:40.990
I think, between graphical objects
and audio objects.

00:19:41.170 --> 00:19:44.530
And that's that graphical objects
you're only experiencing while you're

00:19:44.530 --> 00:19:48.930
viewing them with your camera or however
you're representing those to the screen.

00:19:49.060 --> 00:19:51.970
But the audio objects can be rendered
and experienced all the time.

00:19:52.190 --> 00:19:54.350
So it's really important that
they're localized correctly in

00:19:54.360 --> 00:19:57.100
your user's speaker configuration.

00:19:57.590 --> 00:20:06.230
OpenAL is a great way to
create a multi-channel audio

00:20:06.310 --> 00:20:12.170
experience for your application.

00:20:12.980 --> 00:20:17.590
OpenAL is a great way to
create a multi-channel audio

00:20:17.590 --> 00:20:17.590
experience for your application.

00:20:17.780 --> 00:20:22.730
And there are several attributes
to change on the listener so

00:20:22.740 --> 00:20:24.880
that they can all be rendered,
you know,

00:20:25.010 --> 00:20:26.130
appropriately for what they are.

00:20:26.130 --> 00:20:30.110
And I'll walk through a few
of those as we go along here.

00:20:33.400 --> 00:20:37.170
So here are the APIs for
generating and deleting a source.

00:20:37.380 --> 00:20:40.640
Now you'll notice that both
of them-- except the first

00:20:40.640 --> 00:20:42.520
parameter is a size parameter.

00:20:42.570 --> 00:20:45.080
That's to indicate how many
sources do you want to create,

00:20:45.150 --> 00:20:46.780
how many sources do you want to delete.

00:20:47.020 --> 00:20:51.420
And the second parameter for both
of those APIs are integer arrays,

00:20:51.540 --> 00:20:55.440
appropriately the same size as whatever
you've passed into the size parameter.

00:20:55.520 --> 00:20:59.940
And when you're creating sources,
basically upon the call returning,

00:21:00.160 --> 00:21:03.080
that array will be filled out with
some integer names representing

00:21:03.080 --> 00:21:06.010
the source names that you'll be
using to reference as you want to

00:21:06.240 --> 00:21:08.220
change attributes for those sources.

00:21:08.270 --> 00:21:10.310
And then the second,
the delete sources call,

00:21:10.420 --> 00:21:13.870
you'll see you pass in an array,
and you fill that in with the

00:21:13.940 --> 00:21:16.340
sources that you want to delete,
telling the library, OK,

00:21:16.340 --> 00:21:17.400
I don't need these anymore.

00:21:17.500 --> 00:21:20.450
So in that case,
we filled it in with 100 and 102,

00:21:20.450 --> 00:21:22.560
tell the library we
don't need these anymore,

00:21:22.840 --> 00:21:24.880
and the library will delete them.

00:21:25.930 --> 00:21:29.050
So an important attribute for
both sources and listener is

00:21:29.150 --> 00:21:30.860
the AL position attribute.

00:21:30.870 --> 00:21:35.790
This is the way that you move your
objects around in your virtual space,

00:21:35.790 --> 00:21:38.530
and they can be applied
both to listener and source,

00:21:38.530 --> 00:21:39.260
as I said.

00:21:39.300 --> 00:21:43.900
And they're defined in world coordinates,
x, y, z coordinates, where 0, 0,

00:21:43.900 --> 00:21:45.270
0 is your center.

00:21:45.400 --> 00:21:48.060
And they're just like OpenGL,
they use a right-handed

00:21:48.480 --> 00:21:50.670
Cartesian coordinate system.

00:21:50.860 --> 00:21:54.140
So if you do that trick with
your right hand and you pass,

00:21:54.140 --> 00:21:59.580
you point your thumb to your right
and your index finger straight up

00:22:00.030 --> 00:22:02.090
and your middle finger toward you,
that'll tell you the

00:22:02.140 --> 00:22:04.190
positive directions on the x,
y, z axes,

00:22:04.190 --> 00:22:06.600
if you want to know that little trick.

00:22:08.590 --> 00:22:10.060
So one of the things
that you'll want to do,

00:22:10.260 --> 00:22:14.700
possibly, since you can now position
your objects around in space,

00:22:14.700 --> 00:22:18.580
is have them behave as they
would in a physical world.

00:22:18.620 --> 00:22:21.070
In other words,
they should attenuate as the

00:22:21.070 --> 00:22:23.350
distance changes from your listener.

00:22:23.360 --> 00:22:26.020
And so there's two parts
to doing that in OpenAL.

00:22:26.020 --> 00:22:29.000
First,
we set a distance model on the context.

00:22:29.470 --> 00:22:35.490
And what that means is we're going to
set a model that will be applied to

00:22:35.490 --> 00:22:38.890
all the sources that are moving around
and rendering audio in your context.

00:22:38.900 --> 00:22:43.440
I'll talk about the inverse distance
and distance clamped models in just

00:22:43.440 --> 00:22:45.900
a second on some subsequent slides.

00:22:45.930 --> 00:22:48.890
But just to point out, the AL none,
if you use that distance model,

00:22:48.990 --> 00:22:53.150
basically you're just telling OpenAL,
don't do any distance attenuation

00:22:53.150 --> 00:22:55.480
for the sources in this context.

00:22:57.100 --> 00:23:01.840
Next, you have to set some parameters
on the source itself.

00:23:02.030 --> 00:23:05.260
And so those first three,
the reference distance, max distance,

00:23:05.420 --> 00:23:07.630
and roll-off factor,
I'll talk to those again in

00:23:07.670 --> 00:23:09.180
the next following slides.

00:23:09.510 --> 00:23:16.290
If you want to have a source,
not have any distance attenuation,

00:23:16.300 --> 00:23:20.420
then you would use the
AL source relative token,

00:23:20.420 --> 00:23:20.420
and you can turn distance
attenuation on or off.

00:23:21.370 --> 00:23:22.200
So let me show you the slide.

00:23:22.320 --> 00:23:27.720
So what you're seeing right here is
an inverse distance square log curve.

00:23:27.800 --> 00:23:31.510
And this is the default curve
that distance attenuation

00:23:31.630 --> 00:23:34.690
will be using for your source.

00:23:34.780 --> 00:23:37.760
Now you'll see there's a green
line on the left-hand side.

00:23:37.830 --> 00:23:39.520
That's the reference distance.

00:23:39.530 --> 00:23:43.660
And what the reference distance is,
you'll see how it crosses 0 dB,

00:23:43.660 --> 00:23:47.160
where it crosses 0 dB
with the orange curve.

00:23:47.520 --> 00:23:49.720
That's the point where,
that's the distance at which

00:23:49.790 --> 00:23:52.470
your source will have no
amplification or attenuation.

00:23:52.480 --> 00:23:55.790
And that's set,
that's a settable attribute.

00:23:55.790 --> 00:23:59.360
You can set it to whatever's appropriate
for the units of measurement in

00:23:59.360 --> 00:24:03.470
your game or on a per-source basis.

00:24:05.720 --> 00:24:08.030
So here's an example of
how we would get that.

00:24:08.130 --> 00:24:10.780
Since you can change it
on a per-source basis,

00:24:10.780 --> 00:24:12.600
you may want to change that.

00:24:12.600 --> 00:24:14.830
And so here's an example
of how you would get it.

00:24:15.040 --> 00:24:18.240
In this case,
we're going to get back a value of 1.0.

00:24:18.260 --> 00:24:23.070
This happens to be the default
setting when your source is created.

00:24:24.220 --> 00:24:27.500
Okay, so the next thing we'll talk about
here is the maximum distance.

00:24:27.500 --> 00:24:32.460
So the curve as it is right now,
your sound will continue attenuating and

00:24:32.460 --> 00:24:37.150
approach out toward negative infinity,
but long before it would

00:24:37.150 --> 00:24:42.850
ever get way out there,
your source is going to stop being

00:24:42.850 --> 00:24:48.290
heard because you'll get a decibel
level of attenuation that's quite low.

00:24:48.300 --> 00:24:52.360
So you may have a source in
your application that you

00:24:52.360 --> 00:24:54.490
want always to be heard.

00:24:54.500 --> 00:24:58.300
Now, you may want some attenuation to
occur as you're moving around,

00:24:58.300 --> 00:24:59.800
but you may always want it to be heard,
say,

00:24:59.800 --> 00:25:01.780
a generator in another room or whatever.

00:25:01.780 --> 00:25:04.090
And so you may want some attenuation.

00:25:04.090 --> 00:25:06.270
Well,
the way that we do that is by setting

00:25:06.270 --> 00:25:08.160
the maximum distance property.

00:25:08.160 --> 00:25:12.300
So if I executed this line of code
that's in the box there to 16,

00:25:12.300 --> 00:25:15.500
you'll see how the code,
how the curve would change.

00:25:15.500 --> 00:25:18.280
And that's now how your
attenuation is going to be.

00:25:18.300 --> 00:25:18.870
So you can see that the distance
property is going to be the same as the

00:25:18.870 --> 00:25:19.300
distance that you're going to be hearing.

00:25:19.300 --> 00:25:22.240
All distances past 16 now
will be stuck at that,

00:25:22.370 --> 00:25:27.170
I think it's a negative
30 dB attenuation.

00:25:30.740 --> 00:25:32.560
OK, so we've talked about
some source settings.

00:25:32.760 --> 00:25:34.340
Now let's look at the distance model.

00:25:34.470 --> 00:25:37.480
The curve, as you're seeing it right now,
has been using the

00:25:37.480 --> 00:25:39.950
inverse distance model.

00:25:40.030 --> 00:25:43.160
And the difference between that
and the clamped model that you

00:25:43.230 --> 00:25:49.130
see in the code box is the clamped
model will actually disallow any

00:25:49.220 --> 00:25:53.900
amplification between a distance
of 0 and your reference distance.

00:25:54.010 --> 00:25:57.900
So by executing this line of code,
where we change the distance model,

00:25:57.900 --> 00:26:00.440
you'll see how the curve
is going to change.

00:26:00.510 --> 00:26:02.200
And there's a clamping there.

00:26:02.270 --> 00:26:05.060
Now to be fair, on OS X,
that clamping's happening

00:26:05.060 --> 00:26:06.440
in both distance models.

00:26:06.630 --> 00:26:10.720
We don't actually do any amplification
from 0 to the reference distance.

00:26:10.850 --> 00:26:13.280
But you should still set that if
that's how you want to behave,

00:26:13.480 --> 00:26:16.820
just in case you're running
on a different implementation

00:26:16.820 --> 00:26:19.720
on a different platform where
that amplification may occur.

00:26:19.850 --> 00:26:22.150
So make sure that you set that.

00:26:24.910 --> 00:26:26.620
Okay,
so now one last thing that you'll want to

00:26:26.620 --> 00:26:32.320
do to make each source behave differently
is potentially change the curve itself.

00:26:32.460 --> 00:26:35.750
So what we've been looking at is
just a straight inverse square law,

00:26:35.760 --> 00:26:40.340
but you may want your source to
attenuate either faster or slower as

00:26:40.500 --> 00:26:42.480
it moves out towards maximum distance.

00:26:42.480 --> 00:26:45.300
And so we're looking at
the default setting of 1.0,

00:26:45.300 --> 00:26:48.540
but for instance,
if we changed it now to 2.0,

00:26:48.540 --> 00:26:51.820
you'll see how the curve changes,
where attenuation occurs more quickly,

00:26:52.320 --> 00:26:54.380
and then when it reaches
that maximum distance,

00:26:54.410 --> 00:26:58.080
you'll also notice that its attenuation
is actually at a lower level.

00:26:58.100 --> 00:27:03.300
And so those are all the attributes and
properties you'll be changing for setting

00:27:03.880 --> 00:27:07.400
your distance attenuation behavior.

00:27:08.980 --> 00:27:11.950
Okay, so the next thing we'll
talk about is AL gain.

00:27:12.130 --> 00:27:16.570
AL gain is just an attribute
for scaling the amplitude of

00:27:16.570 --> 00:27:19.160
the audio samples themselves.

00:27:19.260 --> 00:27:23.240
Now, 1.0 just basically is
saying don't do any scaling,

00:27:23.240 --> 00:27:26.310
play the audio samples
just exactly as they are,

00:27:26.310 --> 00:27:29.070
and a zero basically means play silence.

00:27:29.080 --> 00:27:33.200
Now, it's important that since
you cannot go above 1.0,

00:27:33.200 --> 00:27:36.750
it's important that you make sure
that when you create your audio

00:27:36.860 --> 00:27:39.880
for your game or your application
that you use the full bandwidth.

00:27:39.880 --> 00:27:42.230
You can always scale down,
but you can't scale up,

00:27:42.230 --> 00:27:45.600
so it's important really to use
the full bandwidth that you can

00:27:45.610 --> 00:27:47.030
use for those audio samples.

00:27:47.040 --> 00:27:49.710
Now, setting listener gain,
listener gain also,

00:27:49.710 --> 00:27:52.730
what that basically does is it
will affect the gain of all the

00:27:52.730 --> 00:27:54.360
sources that are being rendered.

00:27:54.360 --> 00:27:58.180
And then you'll see also that there's
a min and max bounding properties that

00:27:58.180 --> 00:28:00.130
you can use on a per-source basis.

00:28:00.160 --> 00:28:03.950
Now,
the API is quite simple for setting this.

00:28:03.980 --> 00:28:07.170
You use the AL source F call,
indicate the source that you

00:28:07.260 --> 00:28:08.860
want to change and the token.

00:28:08.860 --> 00:28:12.120
pass it in a float value, and off you go.

00:28:13.460 --> 00:28:16.640
Okay, so the next one we'll
talk about is AL pitch.

00:28:16.640 --> 00:28:19.700
This is the property that
Elliot mentioned before,

00:28:19.700 --> 00:28:22.400
how you can change
pitch for your sources.

00:28:22.530 --> 00:28:24.290
Again, this is just a rate scaler.

00:28:24.390 --> 00:28:30.400
1.0 indicates do not do any pitch change,
and it's settable while you're rendering.

00:28:30.400 --> 00:28:36.010
And so here's an example of how
you could double the pitch of a

00:28:36.010 --> 00:28:38.610
particular source's audio data just
by setting it to a value of 2.0.

00:28:40.020 --> 00:28:43.720
Okay, so now you have your source,
your context, your listener, your device.

00:28:43.750 --> 00:28:46.400
Your sources need some data to play.

00:28:46.400 --> 00:28:48.660
And so here's the last
of those five components,

00:28:48.690 --> 00:28:50.500
and that's the OpenAL buffer.

00:28:50.500 --> 00:28:54.040
Now,
OpenAL buffers are just buckets of data.

00:28:54.050 --> 00:28:58.150
They can be whatever data is
supported by the implementation.

00:28:58.160 --> 00:29:01.260
And the library actually
makes its own copy,

00:29:01.260 --> 00:29:04.350
so once you pass it in,
you can dispose the copy

00:29:04.390 --> 00:29:05.280
that you've passed in.

00:29:05.280 --> 00:29:07.390
And I'll show you how that
works in just a second.

00:29:07.390 --> 00:29:09.120
Also, they're reusable.

00:29:09.120 --> 00:29:11.480
So in other words,
you can generate a buffer,

00:29:11.480 --> 00:29:13.200
fill it with some audio data.

00:29:13.200 --> 00:29:15.290
Sometime down the road
in your application,

00:29:15.460 --> 00:29:17.660
you decide, "Oh,
I don't need that anymore.

00:29:17.660 --> 00:29:20.030
Let's reuse this." Pass it some new data.

00:29:20.170 --> 00:29:24.790
The library will purge the old
data and then copy in the new.

00:29:24.900 --> 00:29:28.820
And unlike the OpenAL sources,
the buffers are not attached

00:29:28.820 --> 00:29:30.630
to a particular context.

00:29:30.660 --> 00:29:34.660
They can be shared by all available
OpenAL sources across any application.

00:29:34.660 --> 00:29:38.070
across any number of OpenALE contexts.

00:29:39.920 --> 00:29:43.000
So here are the APIs for
the OpenAL buffers.

00:29:43.030 --> 00:29:47.330
You'll notice they look very similar
to the generate and delete source APIs.

00:29:47.650 --> 00:29:50.000
Again,
they take a size indicating how many

00:29:50.000 --> 00:29:53.900
buffers you want to create or delete,
and then an array of integers,

00:29:54.280 --> 00:29:57.570
both either to be filled in
upon creating or to specify the

00:29:57.610 --> 00:29:59.760
buffers that you no longer need.

00:29:59.960 --> 00:30:03.210
Now, once you've created some buffers,
you need to add some data to them,

00:30:03.260 --> 00:30:06.800
and we use the AL Buffer
Data API to do that.

00:30:06.800 --> 00:30:08.330
So the first parameter
there is the buffer,

00:30:08.330 --> 00:30:10.800
of course,
that you're adding the data to.

00:30:10.820 --> 00:30:12.800
And then the next one is the format.

00:30:12.800 --> 00:30:16.290
The reason I want to point out the
format is this is actually a constant

00:30:16.290 --> 00:30:19.800
that would be defined in your header
files or possibly by an extension,

00:30:19.900 --> 00:30:22.800
and I'll talk about
extensions in a little bit,

00:30:22.800 --> 00:30:25.800
to define what type of data you're
actually handing to the library.

00:30:25.800 --> 00:30:29.210
Now, the box there that just popped
up shows the formats that are

00:30:29.350 --> 00:30:33.800
required to be supported by OpenAL,
any OpenAL implementation,

00:30:33.800 --> 00:30:36.800
and these are integer--
these are integer PCM files.

00:30:36.800 --> 00:30:38.480
formats.

00:30:38.770 --> 00:30:41.290
Next, you pass in a buffer of
data and how big it is.

00:30:41.450 --> 00:30:44.000
And then lastly,
there's a frequency parameter.

00:30:44.000 --> 00:30:46.680
That's the sample rate
of your audio data.

00:30:46.910 --> 00:30:49.760
One other note about your audio data.

00:30:49.820 --> 00:30:54.070
If you're passing in stereo data,
stereo data won't be localized

00:30:54.230 --> 00:30:55.060
in your virtual space.

00:30:55.150 --> 00:30:57.300
It always gets rendered to
your front left/right speakers

00:30:57.300 --> 00:31:00.080
if you have a surround system,
or it's going to be in your left and

00:31:00.080 --> 00:31:03.080
right speaker of your stereo system.

00:31:04.820 --> 00:31:07.810
So there are a couple of
different ways typically that

00:31:07.810 --> 00:31:11.310
Open-AL sources will play buffers.

00:31:11.720 --> 00:31:16.160
Either kind of a one shot or
play this sound on this event,

00:31:16.240 --> 00:31:19.100
or maybe a particular buffer
that just loops through.

00:31:19.180 --> 00:31:23.850
Or you may actually want to have a
queue of buffers chained together that

00:31:23.850 --> 00:31:26.640
can be modified as you're going along,
maybe changed as events are

00:31:26.640 --> 00:31:28.180
changing in your application.

00:31:28.270 --> 00:31:30.570
And so there's a couple of
different ways to do that.

00:31:30.770 --> 00:31:35.690
The Open-AL--the AL buffer token's
typically used for a one shot--

00:31:35.970 --> 00:31:39.700
a one shot sound when you're
adding that to your source.

00:31:39.770 --> 00:31:42.100
And then the queue buffers
are for manipulating that.

00:31:42.100 --> 00:31:45.700
And I'll walk through an example
of how you would use those calls.

00:31:45.800 --> 00:31:49.930
Now if you are manipulating a queue,
there's also a couple of tokens for

00:31:49.930 --> 00:31:53.850
identifying some state about your queue.

00:31:54.100 --> 00:31:58.490
Both one for finding out how many
buffers have been processed or actually

00:31:58.600 --> 00:32:00.230
how many buffers are in the queue.

00:32:00.430 --> 00:32:01.770
And then, like I said,
you can also use a single shot

00:32:01.770 --> 00:32:03.600
buffer to loop continuously.

00:32:03.600 --> 00:32:05.600
And so there's a property
for turning that on and off.

00:32:05.600 --> 00:32:08.110
And then lastly,
you may want your queue or even your

00:32:08.110 --> 00:32:09.000
single shot buffer to loop continuously.

00:32:09.600 --> 00:32:10.450
So here's an example.

00:32:10.500 --> 00:32:12.490
Let me just walk through a
little usage of how you can

00:32:12.680 --> 00:32:14.360
manipulate your buffer queue.

00:32:14.540 --> 00:32:17.060
We'll start out with a source that
has a couple of buffers in it,

00:32:17.290 --> 00:32:19.410
buffers 1 and 2.

00:32:19.680 --> 00:32:21.300
And then it's playing
along and you've decided,

00:32:21.300 --> 00:32:22.940
"Oh,
I need to add some more buffers." So you

00:32:23.430 --> 00:32:28.820
use the AL Source Queue Buffers API,
and you fill in an array with

00:32:28.820 --> 00:32:32.600
the buffer names that you want to
append to the end of your queue.

00:32:32.600 --> 00:32:35.920
Now, in this case,
we've added three-- buffer 1, buffer 3,

00:32:35.920 --> 00:32:39.710
buffer 4-- and I wanted to point out,
too, that you'll notice that

00:32:39.710 --> 00:32:40.600
buffer 1 is being used twice.

00:32:40.600 --> 00:32:43.570
There's no limitation on
which buffers can be in there.

00:32:43.640 --> 00:32:47.370
It's just going to play these
buckets of data in a sequence.

00:32:48.410 --> 00:32:51.470
Okay, so now this is the way that you
would check your queue length.

00:32:51.560 --> 00:32:52.360
You've added some buffers.

00:32:52.420 --> 00:32:54.300
Maybe you're not keeping
that state yourself.

00:32:54.450 --> 00:32:57.300
You can query to see how many
buffers are in your queue.

00:32:57.300 --> 00:33:02.500
And in this case, we have five,
so that's the value we're going

00:33:02.500 --> 00:33:02.500
to get back from that call.

00:33:02.990 --> 00:33:07.300
And your buffer cue's been playing along,
and the gray boxes there denote some

00:33:07.300 --> 00:33:08.770
buffers that have already been played.

00:33:08.950 --> 00:33:10.640
Now we're playing the third one there.

00:33:10.680 --> 00:33:13.150
And you want to find out which
ones have been played so that you

00:33:13.240 --> 00:33:16.140
can find out which ones can be
deleted off the front of the cue.

00:33:16.240 --> 00:33:19.350
So you're going to get back a value of 2,
and this lets you know I can take

00:33:19.350 --> 00:33:23.820
off one buffer or I can take off
two buffers with the un-cue call.

00:33:23.920 --> 00:33:25.100
And so here's an example.

00:33:25.100 --> 00:33:29.220
We're going to remove one buffer
from your queue using this

00:33:29.220 --> 00:33:31.800
AL source on queue buffers call.

00:33:31.980 --> 00:33:35.260
And we pass in an array of size 1,
since that's how many we're deleting,

00:33:35.450 --> 00:33:38.250
and when the call completes,
that array gets filled in with the

00:33:38.250 --> 00:33:40.800
buffer name that was just removed
off the front of your queue.

00:33:40.800 --> 00:33:43.190
So in this case, that would be buffer 1.

00:33:45.480 --> 00:33:49.360
Okay, so there's nothing really special
here about the playback control calls.

00:33:49.410 --> 00:33:52.660
I'll just let those speak for themselves.

00:33:59.320 --> 00:34:01.860
Okay,
so back to our initializing routine.

00:34:01.860 --> 00:34:05.240
Again, this is some code we're going
to run in just a second.

00:34:05.240 --> 00:34:07.210
Other than setting up your
device in your context,

00:34:07.770 --> 00:34:11.560
typical usage might be that you
would generate some buffers and

00:34:11.560 --> 00:34:14.560
some sources at some non-critical
time in your application,

00:34:14.560 --> 00:34:18.190
either when you're knitting at the
beginning or maybe between some

00:34:18.210 --> 00:34:20.460
levels or at some non-critical time.

00:34:20.460 --> 00:34:24.460
So here we have usage of
the ALGenBuffers call.

00:34:24.460 --> 00:34:27.450
We happen to be generating
four buffers in this app.

00:34:27.610 --> 00:34:30.450
And then a call to ALGenSources.

00:34:30.450 --> 00:34:33.460
Again, we're going to put one
buffer in each source,

00:34:33.460 --> 00:34:35.450
so you'll see how that works.

00:34:39.100 --> 00:34:42.830
Okay, so now that we have our buffers,
we need to initialize-- need

00:34:42.830 --> 00:34:45.560
to do some initializing of
them by passing them some data.

00:34:45.560 --> 00:34:48.610
Now, the reason that the line is in
gray here next to the red arrow

00:34:48.730 --> 00:34:50.340
is this is not an open AL call.

00:34:50.340 --> 00:34:52.860
Your application will have to have
some way of getting your audio data

00:34:52.860 --> 00:34:56.160
either out of a file or maybe you've
stored it in some other fashion,

00:34:56.160 --> 00:35:00.750
but ultimately you have to get a buffer
of data to then pass to the library.

00:35:00.770 --> 00:35:04.540
So you get your data,
then you call "aobuffer_data"

00:35:04.540 --> 00:35:07.360
and pass the-- pass the data in.

00:35:07.360 --> 00:35:10.130
And then again, to reiterate,
you don't need that data anymore.

00:35:10.190 --> 00:35:13.140
The buff--the open AL library
has made a copy of it,

00:35:13.260 --> 00:35:16.600
so it's going-- you can
release your copy now.

00:35:17.640 --> 00:35:22.290
Okay, now lastly, we need to set up some
attributes on our sources.

00:35:22.440 --> 00:35:25.220
So in our example here,
we need to attach a

00:35:25.300 --> 00:35:27.090
buffer to each source.

00:35:27.340 --> 00:35:29.340
We need to turn looping on
because we want all of our

00:35:29.340 --> 00:35:32.540
sounds to play continuously.

00:35:32.780 --> 00:35:36.460
We need to set a position in our space.

00:35:36.460 --> 00:35:39.240
We need to set a reference distance
that is appropriate for the

00:35:39.240 --> 00:35:40.930
virtual space that we've created.

00:35:40.990 --> 00:35:43.390
In this case, we're setting it to 5.0.

00:35:43.670 --> 00:35:45.460
And then we need to start playing.

00:35:45.590 --> 00:35:52.580
So if we could switch to Demo Machine 2,
let me run the code that I've

00:35:52.580 --> 00:35:55.610
shown you in those three methods.

00:36:14.550 --> 00:36:17.060
Okay, so also the code for this app,
I think,

00:36:17.100 --> 00:36:22.300
can be found on the WWDC web pages and,
you

00:36:22.580 --> 00:36:23.450
So you can check that out.

00:36:23.530 --> 00:36:25.770
There's just very little
bit more OpenAL code than

00:36:25.770 --> 00:36:27.000
what I've just showed you.

00:36:27.040 --> 00:36:29.630
Basically, the only difference,
the only thing I haven't showed

00:36:29.670 --> 00:36:32.550
you are the set calls that we're
going to make as we manipulate

00:36:32.550 --> 00:36:34.180
the sources and the listener.

00:36:34.310 --> 00:36:42.270
So what we have right here right now
is four sources denoted by the red.

00:36:43.700 --> 00:36:47.020
By the red dots,
these are four different sources.

00:36:47.050 --> 00:36:49.290
We can move them in space.

00:36:49.490 --> 00:36:52.910
And in the center we have a blue
dot that denotes our listener.

00:36:52.910 --> 00:36:55.180
And you can see that there's
an arrow there pointing out.

00:36:55.250 --> 00:36:58.040
That tells you which
orientation our listener has.

00:36:58.040 --> 00:37:02.940
And again, this is a top-down view,
an XZ plane view of this thing.

00:37:05.610 --> 00:37:08.510
Alright, so we have our things,
we should be hearing

00:37:08.510 --> 00:37:10.920
those all around the room.

00:37:10.950 --> 00:37:13.720
And if we change the orientation,

00:37:13.900 --> 00:37:18.410
We ought to be hearing all of those
particular sources move around.

00:37:18.420 --> 00:37:22.170
And this is just by making
one single orientation call.

00:37:23.400 --> 00:37:27.100
"And the library does all the
rest of the work for you." Okay,

00:37:27.190 --> 00:37:30.100
so we have that,
and so we can move the orientation.

00:37:30.140 --> 00:37:31.940
Now all those sounds are
behind your listener,

00:37:31.940 --> 00:37:34.560
so they all ought to be
in the back of the room.

00:37:34.620 --> 00:37:37.440
So maybe we want to bring
them up to the front.

00:37:37.450 --> 00:37:41.250
And so we'll orient this way,
and here they are up front.

00:37:42.150 --> 00:37:45.690
Now let's say we have some,
maybe we don't like the

00:37:45.690 --> 00:37:48.930
sound of that monkey,
let's turn him down.

00:37:48.930 --> 00:37:52.260
That's an AL gain set call.

00:37:52.260 --> 00:37:56.700
And we want the electric sound
to be a little higher pitched,

00:37:56.830 --> 00:37:57.310
change the pitch.

00:37:57.440 --> 00:38:02.760
So these are just calls to AL pitch,
AL gain, orientation,

00:38:02.830 --> 00:38:07.340
and we can turn all the sources down
by setting the listener gain to zero.

00:38:07.730 --> 00:38:10.650
And then these are just,
moving these around are

00:38:10.730 --> 00:38:17.320
just calls to AL position,
either for the listener.

00:38:18.700 --> 00:38:20.700
"Or for the source.

00:38:20.700 --> 00:38:23.140
Oh, we've got that one down.

00:38:23.140 --> 00:38:27.070
So we can see how we can
move that around the room.

00:38:27.210 --> 00:38:28.700
So that's all there is to the app.

00:38:28.700 --> 00:38:31.330
It's kind of a simple app,
but it should get you started if you

00:38:31.430 --> 00:38:33.010
want to take a look at that code.

00:38:33.190 --> 00:38:35.970
So if we can go back to the slides,
please."

00:38:38.930 --> 00:38:42.960
One last thing about the
OpenAL architecture is that there

00:38:43.130 --> 00:38:48.590
is an extension mechanism so that
if you could check out the sources,

00:38:48.590 --> 00:38:53.550
they are available at the Creative site,
and add a feature that you may need

00:38:53.580 --> 00:38:55.600
that maybe isn't in the Core APIs.

00:38:55.800 --> 00:38:59.470
And the way that you would do that is
by adding an extension and defining

00:38:59.470 --> 00:39:02.770
a name for that extension and some
names for your function pointers,

00:39:02.800 --> 00:39:04.610
if that's appropriate.

00:39:04.800 --> 00:39:08.540
And then there are some APIs for
querying at render time whether

00:39:08.540 --> 00:39:10.800
your extension is present or not.

00:39:10.850 --> 00:39:12.930
Now, there are some common
extensions out there,

00:39:12.930 --> 00:39:16.800
and typically what would happen
is you may propose an extension

00:39:16.800 --> 00:39:19.590
to the OpenAL community,
and there may be some documentation

00:39:19.590 --> 00:39:22.780
on the OpenAL website,
and so you can get information

00:39:22.780 --> 00:39:24.800
about that in that fashion.

00:39:24.870 --> 00:39:30.290
And then there are occasions where
that extension may be rolled into the

00:39:30.510 --> 00:39:33.800
OpenAL Core APIs via a new specification.

00:39:33.970 --> 00:39:34.800
That's actually happening
in the Core APIs.

00:39:34.800 --> 00:39:37.390
So we're running right now with
the 1.1 specification that's

00:39:37.390 --> 00:39:41.050
being developed at this time,
and it's rolling in some

00:39:41.050 --> 00:39:44.670
capture APIs that were only
available as an extension before.

00:39:44.820 --> 00:39:46.800
And so these are what the APIs look like.

00:39:46.800 --> 00:39:51.240
Again, they both take const strings,
one for querying whether

00:39:51.350 --> 00:39:54.460
the extension is present,
and if it is,

00:39:54.460 --> 00:39:57.800
then you can go and get function
pointers into that extension.

00:39:58.680 --> 00:40:03.960
Okay, so I've talked about the Core APIs,
and you've heard the great story

00:40:03.960 --> 00:40:07.020
of why it makes your life easy,
but it's still really important for

00:40:07.020 --> 00:40:09.460
you to have an efficient audio system.

00:40:09.460 --> 00:40:12.750
Many of you are developing
games that have really highly

00:40:12.760 --> 00:40:16.570
computational graphic work and things,
and you don't really want to be

00:40:16.570 --> 00:40:18.210
spending a lot of time doing audio.

00:40:18.220 --> 00:40:20.870
And the way we've done that in
the Mac OS X implementation is

00:40:20.870 --> 00:40:22.620
by using these Core Audio pieces.

00:40:23.140 --> 00:40:25.960
And I'll talk about these three,
the 3D Mixer Audio Unit,

00:40:25.960 --> 00:40:29.730
the Default Output Audio Unit,
and the Audio Converter

00:40:29.830 --> 00:40:31.470
APIs one by one here.

00:40:34.390 --> 00:40:38.080
So the 3D Mixer Audio Unit sort
of equates to your OpenAO context.

00:40:38.130 --> 00:40:42.180
It's the piece in the
implementation that is doing all

00:40:42.180 --> 00:40:44.420
the mixing of your audio sources.

00:40:44.430 --> 00:40:46.910
It's doing all the
spatial rendering work.

00:40:47.190 --> 00:40:49.880
And it's been optimized,
so it's quite efficient.

00:40:49.900 --> 00:40:54.110
And the other thing that it does for
the implementation is it defines which

00:40:54.180 --> 00:40:56.920
speaker configurations your user can use.

00:40:57.060 --> 00:41:00.800
So currently,
the 3D Mixer Audio Unit supports stereo,

00:41:00.870 --> 00:41:03.000
quadraphonic, and 5.0 rendering.

00:41:03.080 --> 00:41:07.050
So if there is some point in the
future where 7.1 was appropriate

00:41:07.050 --> 00:41:11.790
and the 3D Mixer might support that,
the OpenAO library would just work.

00:41:11.820 --> 00:41:15.000
You wouldn't have to do
any changing on your part.

00:41:15.190 --> 00:41:17.860
Now, the next piece are the
audio converter APIs.

00:41:17.980 --> 00:41:21.810
These sort of--these equate, basically,
to your OpenAO sources.

00:41:22.100 --> 00:41:24.750
Each source has its own data
that it's going to be rendering,

00:41:24.980 --> 00:41:26.750
and eventually,
it has to get the data that you've

00:41:26.840 --> 00:41:30.860
passed to the library into the
native data format for Mac OS X,

00:41:31.200 --> 00:41:34.800
which happens to be 32-bit float samples.

00:41:34.920 --> 00:41:38.430
So it's really important for you to
have efficient into-float glitters,

00:41:38.440 --> 00:41:41.630
and that-- you'll get that
with the audio converter APIs.

00:41:41.670 --> 00:41:45.750
The other side benefit is,
since it's--the audio converter

00:41:45.840 --> 00:41:49.920
APIs can decode as well,
it's--it'll be a trivial to add support

00:41:49.920 --> 00:41:55.410
to decode any particular formats that
are supported on the Mac OS X platform.

00:41:56.740 --> 00:42:00.090
Now, the last Core Audio piece
is the default output unit.

00:42:00.220 --> 00:42:05.260
Now, this is the piece that does all
the tracking for your user's audio

00:42:05.260 --> 00:42:06.580
device that they're rendering to.

00:42:06.820 --> 00:42:09.980
And what's nice about this
setup is your application,

00:42:10.040 --> 00:42:13.010
again, doesn't have to know anything
about the hardware or the state

00:42:13.010 --> 00:42:16.580
of the hardware or what speakers
are connected to the hardware.

00:42:16.600 --> 00:42:20.020
You're basically, you're,
the default output unit is

00:42:20.100 --> 00:42:23.600
going to do the tracking for
which device is being used,

00:42:23.600 --> 00:42:27.330
whether that's your user has
changed it or possibly they're

00:42:27.330 --> 00:42:31.600
using a FireWire or a USB box,
maybe it gets unplugged by accident.

00:42:31.600 --> 00:42:35.820
OpenAL, the library's just going to keep
rendering because the default output

00:42:35.910 --> 00:42:39.590
unit's going to find a new device
and then start rendering to that.

00:42:39.780 --> 00:42:43.590
The other thing that can change on your
user's device are its stream formats.

00:42:43.600 --> 00:42:45.440
So there could be a change in
the amount of channels that

00:42:45.440 --> 00:42:46.600
you're going to be rendering.

00:42:46.600 --> 00:42:48.520
There could be a change in the
amount of channels available to

00:42:48.520 --> 00:42:49.600
render to or the sample rate.

00:42:49.600 --> 00:42:53.230
Maybe your user's changed the sample
rate in some software application

00:42:53.580 --> 00:42:55.600
or flipped a switch on their box.

00:42:55.600 --> 00:42:58.030
So, again,
the default output audio unit does

00:42:58.090 --> 00:43:01.600
all that tracking and does all
that work for the implementation.

00:43:02.990 --> 00:43:04.740
So we've been talking about performance.

00:43:04.770 --> 00:43:09.970
This is a little piece of information
here that shows you just really how

00:43:09.970 --> 00:43:13.960
much the Core Audio implementation
is a win for you.

00:43:14.190 --> 00:43:19.060
On the right-hand column are some
CPU load numbers for running a test

00:43:19.060 --> 00:43:24.290
in OpenAL while we've been playing
64 PCM sources simultaneously.

00:43:24.360 --> 00:43:26.910
And as you can see,
the numbers are quite low,

00:43:27.080 --> 00:43:30.440
and that's for running
both in stereo and 5.0,

00:43:30.480 --> 00:43:36.340
on maybe a low-end G4
PowerBook platform or a 2.5-gig G5.

00:43:36.500 --> 00:43:40.800
And so you can see that those
CPU loads are not going to be a

00:43:40.800 --> 00:43:42.700
real bad problem for your game.

00:43:42.760 --> 00:43:45.000
Now, on the left-hand side,
you can see what we were using

00:43:45.000 --> 00:43:50.420
before we had added these 3D mixer
and the Core Audio implementation

00:43:50.450 --> 00:43:52.430
that we have right now.

00:43:53.570 --> 00:43:55.320
So there's a couple other
things that we've added.

00:43:55.400 --> 00:43:58.660
Since we have this
Core Audio implementation,

00:43:58.660 --> 00:44:02.270
we thought it would be good
to expose some of these pieces

00:44:02.370 --> 00:44:03.660
through the OpenAL APIs.

00:44:03.870 --> 00:44:06.280
And so let me talk
about a couple of these.

00:44:06.420 --> 00:44:08.520
First, the spatial rendering quality.

00:44:08.590 --> 00:44:12.950
The 3D Mixer actually has the ability
to have a setting for how good

00:44:13.100 --> 00:44:15.370
the quality that you render to is.

00:44:15.670 --> 00:44:19.780
And so there's a tradeoff between how
good is the quality and how much CPU does

00:44:20.130 --> 00:44:24.380
it take versus you want something that
sounds good but doesn't take as much CPU.

00:44:24.450 --> 00:44:27.550
And so we've added some
rendering quality settings,

00:44:27.590 --> 00:44:28.360
a low and a high.

00:44:28.600 --> 00:44:31.180
Now the default is the low setting,
which is an equal power panning.

00:44:31.180 --> 00:44:33.400
And it sounds great.

00:44:33.400 --> 00:44:37.850
But you may have a case where your
user's on a real high-end system,

00:44:37.940 --> 00:44:41.380
maybe they're using-- yeah,
they're on a high-end system and

00:44:41.430 --> 00:44:45.510
you can afford some CPU hit to give
them a better audio experience.

00:44:45.770 --> 00:44:49.840
You could then give them
that high quality HRTF.

00:44:49.940 --> 00:44:54.100
And so this-- this feature only works
when you're rendering to stereo.

00:44:54.150 --> 00:44:57.840
Whenever you're rendering to
a multi-speaker configuration,

00:44:57.840 --> 00:45:01.000
the 3D Mixer always uses
the sound field setting.

00:45:01.130 --> 00:45:05.740
So this might-- the high quality
HRTF may be appropriate for a

00:45:05.740 --> 00:45:12.810
headphone setting when your user
has a powerful platform system.

00:45:12.950 --> 00:45:13.900
So you see the blue boxes.

00:45:13.960 --> 00:45:16.060
Those are the numbers that
we saw on the previous slide.

00:45:16.100 --> 00:45:20.060
Now I've added one more platform there,
a G5 iMac,

00:45:20.090 --> 00:45:23.320
that's sort of in the middle in
terms of speed and what's available.

00:45:23.320 --> 00:45:27.760
And so you can see on the right-hand
column what the HRTF numbers look like.

00:45:27.930 --> 00:45:31.850
Now 33% on a G4 is probably
a little intimidating.

00:45:31.860 --> 00:45:34.400
Maybe you're not-- maybe you're
not going to want to use that.

00:45:34.490 --> 00:45:36.730
But again, this is rendering 64 sources.

00:45:36.920 --> 00:45:40.770
That may be more than you're
actually rendering anyway.

00:45:40.860 --> 00:45:46.030
But if we--if we start looking at the
numbers for 48 sources and 32 sources,

00:45:46.060 --> 00:45:49.040
you can see that we're getting
to a number now where rendering

00:45:49.040 --> 00:45:53.750
32 sources on a high-end system,
you can probably still afford to use that

00:45:53.760 --> 00:45:59.570
HRTF and really give your users a good
audio-- an even better audio experience.

00:46:01.110 --> 00:46:03.580
Okay, the next thing we'll talk about
is the render channel count.

00:46:03.600 --> 00:46:10.500
Now, the render channel count is there
so you can force a stereo rendering.

00:46:10.500 --> 00:46:14.100
And the reason you might want
to do this is the way that the

00:46:14.100 --> 00:46:18.630
OpenAL implementation works is the
default output unit discovers how many

00:46:18.630 --> 00:46:22.940
channels are available on the hardware
device your user has set up and then

00:46:23.080 --> 00:46:25.030
tries to render to the richest number.

00:46:25.130 --> 00:46:29.100
So in other words if there's five or
more channels available to render to,

00:46:29.600 --> 00:46:32.600
the OpenAL library is going
to try and then render to 5.0.

00:46:32.600 --> 00:46:35.100
If there's four channels
available on your device,

00:46:35.190 --> 00:46:36.100
it's going to render to quad.

00:46:36.420 --> 00:46:38.100
Otherwise it'll render to stereo.

00:46:38.100 --> 00:46:42.100
Well, your user may have a nice 5.1
system that they're using,

00:46:42.100 --> 00:46:45.100
but maybe it's late at night
and they have to turn down.

00:46:45.100 --> 00:46:47.950
But they don't want-- and so
they plug some headphones in.

00:46:48.100 --> 00:46:53.100
So by using this, you can allow your user
to just render to stereo.

00:46:53.100 --> 00:46:56.920
You don't have to do anything other
than set this property and your user

00:46:56.990 --> 00:46:59.100
does not have to go and reconfigure
how many speakers they have.

00:46:59.100 --> 00:47:02.230
You can also set how many speakers
they're rendering to in their

00:47:02.230 --> 00:47:06.600
default settings when they set up
their multi-speaker configuration.

00:47:06.600 --> 00:47:12.090
And so we do that by using the
AL_SET_INT and the GET_INT calls.

00:47:12.970 --> 00:47:16.800
And just by turning,
you can force it to be stereo

00:47:16.800 --> 00:47:19.660
or render to the richest,
the multi-channel,

00:47:19.660 --> 00:47:21.530
which is the richest amount
of channels possible.

00:47:24.060 --> 00:47:26.540
Okay, and lastly we'll talk about
the mixer output rate.

00:47:26.600 --> 00:47:29.290
The mixer output rate is here,
and this is really a

00:47:29.290 --> 00:47:30.920
mileage may vary property.

00:47:30.940 --> 00:47:33.540
It just depends on how many
sources you're rendering,

00:47:33.580 --> 00:47:37.120
what the sample rates of
your sources happen to be at,

00:47:37.360 --> 00:47:40.930
what the sample rate of the hardware
your user is rendering is at.

00:47:41.020 --> 00:47:43.640
And so it's a little easier
to describe in a diagram,

00:47:43.640 --> 00:47:44.750
so I'll do that in the next slide.

00:47:44.760 --> 00:47:47.820
But just so you see,
you use the AL set double and get

00:47:47.820 --> 00:47:50.220
double APIs in order to set it.

00:47:50.340 --> 00:47:53.360
In this case, we're setting it to 22K.

00:47:53.430 --> 00:47:57.510
And so I can show you a little more
clearly what this really means is

00:47:57.510 --> 00:48:03.800
here we have an example where when the
default output unit and the 3D mixer

00:48:03.800 --> 00:48:07.420
audio unit are set up at a Nib time,
what happens is the default output

00:48:07.470 --> 00:48:11.960
unit goes and discovers the sample
rate of the user's hardware.

00:48:12.020 --> 00:48:15.950
And that sample rate gets
propagated down into the 3D mixer.

00:48:16.070 --> 00:48:18.850
And so what the 3D mixer
will do by default is take

00:48:18.850 --> 00:48:22.020
all of that incoming data,
all those red boxes at

00:48:22.020 --> 00:48:25.560
the top-- in this case,
they all happen to be 22K-- and

00:48:25.560 --> 00:48:31.260
what it does is it upsamples to that
48K rate before it does any mixing.

00:48:31.390 --> 00:48:33.660
And the reason you may
want to change this is,

00:48:33.730 --> 00:48:38.380
since we've gone from a 22K to a 48K,
you're now pushing around more than twice

00:48:38.380 --> 00:48:44.620
as much data as is necessary in order
to deal and process with those samples.

00:48:44.630 --> 00:48:49.350
So by setting the property at the 22K,
as we saw on the previous slide,

00:48:49.380 --> 00:48:52.080
now what happens is there's
no sample rate conversion.

00:48:52.080 --> 00:48:54.460
And by the way,
the sample rate conversion that gets

00:48:54.520 --> 00:48:56.470
done is a cheap linear conversion.

00:48:56.580 --> 00:49:00.100
It's not expensive, but still,
the case really here is more

00:49:00.100 --> 00:49:03.740
about how much data you're
pushing around in the 3D mixer.

00:49:03.750 --> 00:49:07.320
So by setting it to 22K,
what we do now is do all

00:49:07.360 --> 00:49:11.740
our processing at 22K,
and then the mixed data is then

00:49:11.740 --> 00:49:15.330
passed to the default output
unit and then upsampled at that

00:49:15.330 --> 00:49:18.810
point instead of beforehand.

00:49:19.530 --> 00:49:21.790
And so that's my part of the talk.

00:49:21.800 --> 00:49:25.430
I would like to bring up
Glenda Adams from Aspire Media,

00:49:25.430 --> 00:49:31.080
and she's going to talk a
bit about Doom 3 and OpenAL.

00:49:40.680 --> 00:49:44.600
Let's see if we can switch
over to the demo machine here.

00:49:45.680 --> 00:49:49.430
Okay, there we go.

00:49:49.540 --> 00:49:52.770
I'm Glenda Adams, I'm the Director of
Development with Aspire Media,

00:49:52.830 --> 00:49:56.610
and I'm really excited to be here today
to show you a first kind of public

00:49:56.670 --> 00:50:00.190
unveiling of Doom 3 running under OpenAL.

00:50:00.580 --> 00:50:02.800
We don't really need to see that.

00:50:03.250 --> 00:50:05.810
Oops, did we disappear?

00:50:12.480 --> 00:50:14.400
It's demo two.

00:50:14.400 --> 00:50:15.660
We were on there for a second, I think.

00:50:15.660 --> 00:50:22.510
I don't know if we lost our video
signal because we switched resolutions.

00:50:26.100 --> 00:50:27.190
We can hear it at least.

00:50:27.190 --> 00:50:30.940
Maybe that's all we need
for an audio demonstration.

00:50:30.940 --> 00:50:33.560
Do you want me to switch
it back to the other?

00:50:33.560 --> 00:50:36.580
Yeah, I can switch it back to
the other resolution.

00:51:04.190 --> 00:51:05.100
There we go.

00:51:05.100 --> 00:51:06.950
Okay.

00:51:07.210 --> 00:51:10.380
So when we shipped Doom 3
about three months ago,

00:51:10.380 --> 00:51:15.810
it actually shipped with only stereo
output because there really wasn't

00:51:15.810 --> 00:51:19.720
any good way for us to do 5.1 output,
even though the game came from

00:51:19.720 --> 00:51:24.100
its original platform with a
full 5.1 environmental audio.

00:51:24.310 --> 00:51:26.360
So we shipped it,
and it really just didn't sound that,

00:51:26.360 --> 00:51:28.450
I mean, it didn't sound bad,
but it didn't sound nearly

00:51:28.560 --> 00:51:29.580
as good as it could have.

00:51:29.580 --> 00:51:33.940
Now that OpenAL is available under Tiger,
we decided to go ahead and

00:51:33.940 --> 00:51:38.540
move it to OpenAL so that we
actually could do full 5.1 audio.

00:51:38.540 --> 00:51:40.760
So we're going to jump
into the game here.

00:51:40.760 --> 00:51:42.590
This is a later part of the game.

00:51:42.590 --> 00:51:46.420
If you don't know anything about Doom 3,
you're actually kind of chasing

00:51:46.420 --> 00:51:49.900
demons through a Mars base and
then eventually down into hell.

00:51:49.900 --> 00:51:52.560
And this is later in the game where
you've actually gone down in to chase

00:51:52.590 --> 00:51:54.220
the demons back to their homeworld.

00:51:54.220 --> 00:52:01.780
And this is the game where you've
actually gone down in to chase the

00:52:01.800 --> 00:52:05.790
demons back to their homeworld.

00:52:05.800 --> 00:52:13.380
And this is the game where you've
actually gone down in to chase the

00:52:13.380 --> 00:52:17.690
demons back to their homeworld.

00:52:20.200 --> 00:52:22.720
You really can tell it,
as much as the graphics are

00:52:22.730 --> 00:52:25.770
quite amazing in Doom 3,
the audio really adds a lot when

00:52:25.770 --> 00:52:29.400
you've got a full environmental
sound that's going all around you.

00:52:29.400 --> 00:52:32.340
And as you're running through the levels,
it really adds to the immersive

00:52:32.340 --> 00:52:33.500
experience of the game.

00:52:39.100 --> 00:52:42.820
It's a little bit dark,
but we can kind of go up into here.

00:52:42.820 --> 00:52:46.060
As we jump down into this level,
this is a good place where you're

00:52:46.060 --> 00:52:52.560
sinking down into a lower level,
and you can kind of see some of the

00:52:52.560 --> 00:52:57.850
positional audio as this cage kind of
flies out and hits you and surrounds you

00:52:57.850 --> 00:52:57.850
as you're falling down into this pit.

00:53:01.900 --> 00:53:04.860
Now we'll actually get to see a
little bit of the bad guys that

00:53:04.860 --> 00:53:06.440
we've been chasing around here.

00:53:06.440 --> 00:53:09.010
And this is the point where you can
kind of tell that the positional

00:53:09.010 --> 00:53:11.700
audio actually really makes
an effect in playing the game.

00:53:11.720 --> 00:53:15.330
Because now you can kind of hear
somebody sneaking out from behind you

00:53:15.330 --> 00:53:19.490
and realize that you better pay attention
or you're going to be in bad shape.

00:53:25.660 --> 00:53:28.360
As you basically run around the
game and it's using OpenAL to

00:53:28.360 --> 00:53:36.150
play all these positional sounds,
we're letting basically OpenAL and

00:53:36.150 --> 00:53:41.720
Core Audio do all the audio mixing
for us so we don't have to actually

00:53:41.720 --> 00:53:41.720
try to figure out where we want to
pan and move all the sounds around.

00:53:43.260 --> 00:53:44.550
So that was our little demo of that.

00:53:44.550 --> 00:53:52.160
We actually were able to port OpenAL from
the Windows code for Doom 3 relatively

00:53:52.160 --> 00:53:54.880
quickly because it's an open standard.

00:53:54.880 --> 00:53:56.620
There really wasn't
much we had to change.

00:53:56.630 --> 00:53:58.930
It pretty much just came
up and running on the Mac.

00:53:59.000 --> 00:54:01.100
And it really was a nice
addition to the game.

00:54:01.130 --> 00:54:03.420
It makes it a much more
immersive experience.

00:54:03.420 --> 00:54:06.770
They spent a lot of time really
making the audio fit in with

00:54:06.780 --> 00:54:10.540
the story and give you a much
more immersive feel to the game.

00:54:10.620 --> 00:54:12.020
It makes it a much scarier game.

00:54:12.020 --> 00:54:16.280
I couldn't play it at night before with
stereo and I can't play it any at all

00:54:16.400 --> 00:54:19.160
now with the 5.1 during the day even.

00:54:19.160 --> 00:54:20.160
It's too scary for me.

00:54:20.160 --> 00:54:23.010
So we're really excited about
having OpenAL in Tiger and

00:54:23.010 --> 00:54:24.680
it's really a great addition.

00:54:24.740 --> 00:54:28.040
We're looking forward to using it
for future games and we're going

00:54:28.040 --> 00:54:31.420
to release a patch for Doom 3
that enables OpenAL for everybody.

00:54:31.420 --> 00:54:33.580
Hopefully shortly in the next few weeks.

00:54:33.580 --> 00:54:34.270
Thank you.

00:54:41.630 --> 00:54:43.360
Back to slides, please.

00:54:43.370 --> 00:54:43.600
Thanks.

00:54:43.600 --> 00:54:50.280
Well, we can thank Glenda for
that great demo with Dune 3,

00:54:50.280 --> 00:54:52.780
showing you the power of
what you can do with OpenAL.

00:54:52.780 --> 00:54:56.250
If you're looking for more information,
though, so where you get started,

00:54:56.250 --> 00:54:57.810
how to get started,
and how you can get up

00:54:57.810 --> 00:55:01.420
and running with this,
you can get some documentation

00:55:01.420 --> 00:55:03.560
up on the WWDC website.

00:55:03.560 --> 00:55:09.100
And you can also come to tomorrow's
lab at noon in the Graphics and

00:55:09.140 --> 00:55:11.980
Media Lab right around the corner,
and if you're working on

00:55:11.990 --> 00:55:14.400
your game already and you got
started and you want some help,

00:55:14.550 --> 00:55:17.860
like right now, you can go over there
tomorrow around noon.

00:55:17.860 --> 00:55:19.250
We'll be there from noon to 6.

00:55:19.260 --> 00:55:23.660
Stop in there, talk to me, Bob,
or any of the Core Audio engineers,

00:55:23.660 --> 00:55:24.700
and we might be able to help you.

00:55:25.920 --> 00:55:27.660
Here's some contact information.

00:55:27.660 --> 00:55:28.720
Here's my email.

00:55:28.720 --> 00:55:31.440
Rich Hernandez, marketing games engineer.

00:55:31.440 --> 00:55:33.700
And Bob Barron, the Core Audio engineer.

00:55:33.700 --> 00:55:39.650
You heard much about how to
use the OpenAL implementation.

00:55:40.050 --> 00:55:43.910
And you can also contact Garen
Herbert from Creative Labs.

00:55:44.020 --> 00:55:46.100
This is the CVS repository owner.

00:55:46.100 --> 00:55:51.270
If you're writing games using OpenAL,
contact him and let him know that, hey,

00:55:51.270 --> 00:55:54.030
I wrote a game using OpenAL,
and he'll add you to the long list

00:55:54.030 --> 00:55:55.680
of growing games using OpenAL.

00:55:56.600 --> 00:56:01.000
Here's a list for the OpenAL website,
and we also have an OpenAL mailing list.

00:56:01.210 --> 00:56:07.510
When you start with your implementations
and you have API questions that,

00:56:07.510 --> 00:56:09.530
hey, I'm doing this,
and am I supposed to use

00:56:09.700 --> 00:56:12.800
this buffer with this method,
this is a great list.

00:56:12.870 --> 00:56:14.970
It's very active,
so you can get a lot of help that way.

00:56:14.980 --> 00:56:18.110
You can also contact DTS if you
need specific help with your game,

00:56:18.110 --> 00:56:18.500
too.
WEBVTT

00:00:05.030 --> 00:00:10.200
Welcome to our USB session for WWDC.

00:00:10.250 --> 00:00:12.570
My name is Fernando Urbinia,
and I'm part of the

00:00:12.800 --> 00:00:15.330
USB team here at Apple.

00:00:16.980 --> 00:00:20.100
This year we decided to do
something a little bit different

00:00:20.320 --> 00:00:22.580
than what we've done in the past.

00:00:22.750 --> 00:00:28.600
In previous years we've just come
and given you slide after slide after

00:00:29.500 --> 00:00:34.420
slide of dry code and stuff that
we've been doing that was exciting

00:00:34.420 --> 00:00:40.620
for us but maybe not that hands-on
for you and in the spirit of the whole

00:00:40.630 --> 00:00:45.380
WWDC session this year we are going to,
for the most part of

00:00:45.440 --> 00:00:50.240
the presentation today,
go through some of our sample code and

00:00:50.890 --> 00:00:54.780
use the demo machines to show you how to

00:00:55.000 --> 00:00:58.700
Get at your devices, how to access,
how to start some reads,

00:00:58.770 --> 00:01:02.130
and hopefully this will

00:01:02.850 --> 00:01:11.620
Before doing that, though,
I thought that it would be

00:01:11.620 --> 00:01:15.820
nice to highlight a couple
of the issues that we've had,

00:01:15.820 --> 00:01:19.210
or the highlights for Tiger.

00:01:20.130 --> 00:01:23.520
If you've been with us
for the last few years,

00:01:23.520 --> 00:01:27.380
you probably have seen this diagram,
which is part of the

00:01:27.480 --> 00:01:32.030
Common Class Specification,
and it shows what our matching criteria,

00:01:32.180 --> 00:01:34.480
and in this case for USB devices, is.

00:01:34.480 --> 00:01:37.260
And this is just the way
that we rank drivers,

00:01:37.280 --> 00:01:40.870
and so if you specify the
different fields of the device

00:01:40.870 --> 00:01:44.520
descriptor in your matching
dictionary if you're in user space,

00:01:44.520 --> 00:01:48.820
or in your personality
for kernel extensions,

00:01:48.820 --> 00:01:55.660
depending on what fields are there,
we rank your drivers and

00:01:55.660 --> 00:02:00.440
we load those drivers,
and this hasn't changed at all.

00:02:02.080 --> 00:02:05.400
However,
with Tiger we have wildcard matching.

00:02:05.400 --> 00:02:09.830
This has been a request over the
years and it sort of never got up

00:02:09.940 --> 00:02:16.560
in the priority queue in our stuff
and finally for Tiger we did it.

00:02:16.610 --> 00:02:19.100
And what is wildcard matching?

00:02:19.250 --> 00:02:23.000
Well, some of you developers have
a need to support multiple

00:02:23.000 --> 00:02:26.600
devices from the same vendor.

00:02:26.940 --> 00:02:31.900
And the way to do that is
if you're in the kernel,

00:02:32.350 --> 00:02:36.430
you have to create a
personality for each device,

00:02:36.600 --> 00:02:40.480
cut and paste,
and you can have a lot of personality

00:02:40.700 --> 00:02:43.560
depending on how many devices you have.

00:02:43.600 --> 00:02:51.070
The personalities are probably just
the same except for the USB product ID,

00:02:51.170 --> 00:02:55.600
but it's cut and paste
and it's error prone.

00:02:55.600 --> 00:03:02.600
So, it's not very nice when a new
device comes from the same vendor,

00:03:02.600 --> 00:03:05.780
then you have to go and update your
KEXT or if you're in your user space,

00:03:05.890 --> 00:03:09.230
you have to look,
change your code to look

00:03:09.230 --> 00:03:11.600
for that new product ID.

00:03:11.610 --> 00:03:15.880
So,
what wildcard matching allows you to do,

00:03:15.880 --> 00:03:21.270
and it's no big surprise,
is that you can specify a wildcard

00:03:21.380 --> 00:03:24.600
for one or more of those fields.

00:03:24.600 --> 00:03:32.000
So, when you do use a wildcard,
we decrease the probe score so that

00:03:32.000 --> 00:03:37.790
a driver that fully specifies all the
fields will still win in the driver

00:03:38.440 --> 00:03:40.600
matching than yours that has a wildcard.

00:03:40.600 --> 00:03:44.600
But it allows you to have it.

00:03:44.600 --> 00:03:48.370
And we also have what I call
the partial wildcard and this

00:03:48.510 --> 00:03:53.600
is a little bit more esoteric,
but it allows a product ID.

00:03:53.600 --> 00:03:56.900
product ID to have a mask.

00:03:57.320 --> 00:04:02.950
For example,
at Apple we have divided our product IDs

00:04:03.100 --> 00:04:21.700
[Transcript missing]

00:04:22.490 --> 00:04:27.560
So again, this is the matching
criteria for a device driver.

00:04:27.560 --> 00:04:31.220
And if you specify the
vendor and the product ID,

00:04:31.220 --> 00:04:34.040
you have a vendor-specific driver.

00:04:34.410 --> 00:04:38.690
In order to make it wildcard,
all you do is create a,

00:04:38.750 --> 00:04:42.670
instead of putting a number for
the product ID in this case,

00:04:42.830 --> 00:04:45.050
you put a star.

00:04:45.160 --> 00:04:50.930
Later in the demo I'm going to actually
use that and show you how it all works.

00:04:51.670 --> 00:04:55.600
One more slide that
I wanted to put in was,

00:04:55.600 --> 00:05:01.600
it's nothing new,
but it was a highlight of an issue

00:05:01.600 --> 00:05:05.400
that affects you as developers,
but should not affect your users.

00:05:05.480 --> 00:05:11.340
And that is the bus topology in USB,
especially as related to

00:05:11.680 --> 00:05:16.490
full-speed devices that are
attached to a high-speed hub.

00:05:16.950 --> 00:05:20.370
When you have that situation,
a full-speed device attached

00:05:20.370 --> 00:05:24.650
to a high-speed hub,
USB works in what is called

00:05:24.730 --> 00:05:26.140
split transaction mode.

00:05:26.210 --> 00:05:30.200
That means that the high-speed
controller talks to the high-speed

00:05:30.200 --> 00:05:35.990
hub with the high-speed protocol,
and the high-speed hub then goes and

00:05:36.020 --> 00:05:44.380
translates those high-speed commands
into full-speed or low-speed commands.

00:05:44.380 --> 00:05:48.920
As a user, this should just work.

00:05:48.920 --> 00:05:51.760
In reality, it just works.

00:05:51.760 --> 00:05:56.380
However, it's a lot more complicated
in terms of the software.

00:05:56.380 --> 00:06:06.380
The idea of this slide is that when you
have an issue with one of your users,

00:06:06.380 --> 00:06:11.890
and if they have connected your full or
low-speed device into a high-speed hub,

00:06:11.940 --> 00:06:18.600
you should ask them to... ...connect
it to the root hub of the computer,

00:06:18.740 --> 00:06:23.190
directly to the computer,
so that it acts as a full-speed

00:06:23.190 --> 00:06:26.330
device and there's no translation.

00:06:26.490 --> 00:06:29.440
And you can isolate things that way,
of course.

00:06:29.540 --> 00:06:33.290
If there is a bug,
then you go to bugreporter.apple.com

00:06:33.290 --> 00:06:37.360
and report it to us,
and we try to figure out what's going on.

00:06:37.480 --> 00:06:41.400
When running in split transaction mode,

00:06:41.600 --> 00:06:47.940
One of the things that we did in
10.3.9 and in Tiger is we improved

00:06:49.130 --> 00:06:52.850
periodic transactions in this mode.

00:06:52.940 --> 00:06:56.530
Periodic transactions include
not only ISOC in and out,

00:06:56.630 --> 00:06:58.380
but also interrupt transactions.

00:06:58.380 --> 00:07:13.560
The whole bandwidth allocation for these
split transactions has been revamped.

00:07:14.220 --> 00:07:19.190
Timing, especially for Isochronos,
has changed quite a bit.

00:07:19.420 --> 00:07:23.740
And in fact,
our Apple USB Audio driver had to change

00:07:23.740 --> 00:07:26.550
in order to satisfy these new timings.

00:07:26.580 --> 00:07:33.070
And what changed was the fact that
the isochronous out transactions would

00:07:33.760 --> 00:07:40.380
go out in 1039 and in Tiger towards
the end of the one millisecond frame.

00:07:40.380 --> 00:07:44.480
Whereas in the past,
it usually went out at the beginning.

00:07:44.480 --> 00:07:48.980
And you would think that
that would matter too much,

00:07:49.020 --> 00:07:53.240
but especially in audio situations,
it did.

00:07:53.600 --> 00:07:58.460
If you at some point use the
Apple USB audio driver as a source

00:07:58.460 --> 00:08:05.080
for your own vendor-specific driver,
I would encourage you to go and take a

00:08:05.080 --> 00:08:12.540
look at the source for 1039 or Tiger for
that driver and see what changed.

00:08:12.640 --> 00:08:18.260
Because chances are that your
driver won't work as well.

00:08:19.870 --> 00:08:25.400
Final point there is that all
our machines right now use the

00:08:25.410 --> 00:08:30.370
NEC controller for high speed,
and that controller has two

00:08:30.370 --> 00:08:33.300
companion OHCI controllers.

00:08:33.300 --> 00:08:37.560
And that's why I said that when you
plug it into the back of the machine,

00:08:37.560 --> 00:08:43.290
if it's a full or low speed device,
you will get it connected

00:08:43.360 --> 00:08:45.700
directly to an OHCI controller.

00:08:45.740 --> 00:08:50.550
Interestingly enough,
the developer transition systems

00:08:51.330 --> 00:08:57.180
have an EHCI controller with
UHCI companion controllers.

00:08:57.250 --> 00:09:02.510
If you remember last year,
we talked about having

00:09:02.510 --> 00:09:06.400
UHCI support in the IOUSBFamily.

00:09:06.470 --> 00:09:10.600
We've had a lot more work
on it over the past year,

00:09:10.610 --> 00:09:13.500
and at least those systems now have it.

00:09:13.500 --> 00:09:15.410
It should be transparent.

00:09:15.510 --> 00:09:17.250
It works.

00:09:17.500 --> 00:09:22.120
You can always go,
if you don't have a transition system,

00:09:22.260 --> 00:09:27.300
test with a PCI card that has
UHCI companion controllers.

00:09:29.360 --> 00:09:34.930
Okay, so now we come to the live
debugging part of the session.

00:09:34.940 --> 00:09:42.380
I'm going to use a couple of devices to
go through discovering the interfaces,

00:09:42.380 --> 00:09:46.510
setting up the matching dictionary.

00:09:47.020 --> 00:09:50.700
Finding the endpoints,
getting the properties and

00:09:51.120 --> 00:09:53.210
reading from the endpoints.

00:09:53.530 --> 00:09:57.490
Then I'm also, at the end,
going to demonstrate,

00:09:57.490 --> 00:10:00.660
and this is very simple,
but I think it's useful

00:10:00.660 --> 00:10:04.780
to at least some of you,
how to do bulk reads,

00:10:04.780 --> 00:10:09.540
or how to do chain reads, rather,
in order to improve the

00:10:09.540 --> 00:10:11.470
performance of your driver.

00:10:11.830 --> 00:10:16.660
One thing to remember is that you can
issue however many reads you want.

00:10:16.840 --> 00:10:21.260
The controller will
execute them in order.

00:10:21.260 --> 00:10:29.100
And this allows you to work in situations
where the latency might be high.

00:10:29.100 --> 00:10:34.720
At the extreme case,
we could have a USB network server,

00:10:34.720 --> 00:10:37.880
like the one from Keyspan,
that the USB transaction is

00:10:37.880 --> 00:10:41.660
actually going over the bus.

00:10:41.660 --> 00:10:46.100
Or sometimes the workload latency
that we've talked about in the

00:10:46.280 --> 00:10:50.370
past will be high enough that
if you only issue one read,

00:10:50.380 --> 00:10:52.480
then you're going to be
starving your device and your

00:10:52.480 --> 00:10:55.340
performance will not be as high.

00:10:57.330 --> 00:11:00.600
The first tool that we use,
and I'm hoping that most of

00:11:00.600 --> 00:11:04.060
you are familiar with it,
is the logging version

00:11:04.060 --> 00:11:06.040
of the IOUSBFamily.

00:11:06.070 --> 00:11:07.130
What is the logging version?

00:11:07.200 --> 00:11:12.180
When we are developing before a release,
we have all these logs,

00:11:12.320 --> 00:11:17.590
all these print tabs, essentially,
in our family to let us

00:11:17.610 --> 00:11:24.020
know how things are going,
and we use it to debug problems, etc.

00:11:24.200 --> 00:11:28.020
Once we are close to GM,
we strip all those logs out

00:11:28.200 --> 00:11:32.200
because they take space,
they take wired memory,

00:11:32.200 --> 00:11:36.160
and wired memory in the
kernel is very expensive.

00:11:36.200 --> 00:11:41.530
So, shortly after a release,
be it a software update

00:11:41.530 --> 00:11:47.360
or a major release,
we go and we post the logging version of

00:11:47.360 --> 00:11:51.200
the IOUSBFamily at that URL over here.

00:11:51.460 --> 00:11:56.430
And we encourage you to go and download
that and install it and run Prober,

00:11:56.640 --> 00:12:02.130
as we'll see later,
to debug not only our stuff,

00:12:02.210 --> 00:12:06.890
but to learn what we're doing,
but also to use USB logs in your code.

00:12:08.240 --> 00:12:12.460
One interesting bit is that this is
also a way for you to get any new

00:12:12.460 --> 00:12:18.600
headers that we might have changed
since the last major release.

00:12:18.690 --> 00:12:22.050
Software update,
when there's a software update,

00:12:22.320 --> 00:12:25.860
it only updates the
binaries in the system.

00:12:25.860 --> 00:12:27.700
It doesn't update any headers.

00:12:27.760 --> 00:12:32.450
So you have no other way to get
those headers until there is a

00:12:32.450 --> 00:12:37.200
release of Xcode that installs all
the headers in the system again.

00:12:37.350 --> 00:12:45.200
Or, in our case,
you can download our family package.

00:12:45.280 --> 00:12:49.900
You could also go for those projects
that are open source and build them

00:12:49.900 --> 00:12:52.200
yourselves and install headers yourself,
etc.

00:12:52.200 --> 00:12:55.360
But that's a little bit more of a pain.

00:12:56.480 --> 00:13:00.900
Sometimes USB logs are not enough.

00:13:00.930 --> 00:13:06.980
I was in the session yesterday
for FireWire and that FireWire

00:13:06.980 --> 00:13:11.300
SDK 20 has the KPrintf stuff.

00:13:11.520 --> 00:13:18.300
These are essentially printfs from your
code that could go out the FireWire bus.

00:13:18.310 --> 00:13:24.760
Fernando Urbinan I've been using it
lately to debug some enumeration issues

00:13:24.760 --> 00:13:29.260
during startup when we don't have a
USB log that we can take a look at.

00:13:29.820 --> 00:13:35.750
Fernando Urbinan We've also used it
in the past to debug sleep/wake issues

00:13:35.780 --> 00:13:42.090
because sometimes the network drivers
go to sleep and they're not available

00:13:42.090 --> 00:13:45.210
to do too much debugging at that point.

00:13:45.520 --> 00:13:48.300
Fernando Urbinan It is very handy if you
need to debug something for your device.

00:13:48.340 --> 00:13:51.300
Fernando Urbinan But it's not a good idea
to have a USB log that's not available.

00:13:51.480 --> 00:13:54.280
Fernando Urbinan So take a look
at that SDK and download it.

00:13:55.620 --> 00:14:00.900
Now I'm going to go through USB Prover.

00:14:00.900 --> 00:14:02.820
Most of you are probably
familiar with it,

00:14:02.820 --> 00:14:07.970
but I want to still go and
show you a little bit about it.

00:14:10.150 --> 00:14:12.470
I have a device here.

00:14:12.610 --> 00:14:16.180
It's a prototype device,
and it actually had bad firmware

00:14:16.970 --> 00:14:21.040
that I contacted the manufacturer.

00:14:21.340 --> 00:14:23.700
USB Prober has four panes.

00:14:23.700 --> 00:14:25.180
I'm going to start here
with the left mode,

00:14:25.250 --> 00:14:29.450
the bus probe pane.

00:14:29.750 --> 00:14:37.440
gives you a listing and decoding
of all the descriptors manually.

00:14:37.480 --> 00:14:43.690
We try to use the least amount
of the USB stack in the kernel

00:14:44.030 --> 00:14:46.030
in order to get at them.

00:14:46.060 --> 00:14:51.530
So we don't use any of the properties
that are in the IO registry,

00:14:51.650 --> 00:14:53.500
for example, for the product name.

00:14:53.500 --> 00:14:57.430
We go and we issue the device
request to get that length and

00:14:57.440 --> 00:14:59.480
then the full device request.

00:14:59.600 --> 00:15:04.100
And for example,
this device you can see right here

00:15:04.290 --> 00:15:11.900
that we have written that the device
did not respond to a request for the

00:15:11.900 --> 00:15:15.610
first four bytes of a descriptor.

00:15:15.800 --> 00:15:21.300
[Transcript missing]

00:15:21.500 --> 00:15:42.100
[Transcript missing]

00:15:42.340 --> 00:15:46.200
The length of the descriptor
is in bytes 3 and 4.

00:15:46.320 --> 00:15:51.120
And that's all the information we need
in order to then issue a request for

00:15:51.240 --> 00:15:53.200
the full configuration descriptor.

00:15:53.200 --> 00:15:57.080
This device doesn't respond to it.

00:15:57.470 --> 00:16:01.200
However,
we realize that and then we go ahead

00:16:01.200 --> 00:16:05.200
and we request the whole thing.

00:16:05.200 --> 00:16:08.360
The USB Prober will also
show you the whole length,

00:16:08.390 --> 00:16:12.200
or sorry, the whole config
descriptor in raw format.

00:16:12.470 --> 00:16:20.790
And then it goes and decodes all the
different descriptors that it encounters.

00:16:20.990 --> 00:16:23.300
Some of these descriptors,
like the video descriptor

00:16:23.300 --> 00:16:26.830
and the audio descriptors,
the specs are huge and there's a

00:16:26.830 --> 00:16:31.070
gazillion formats and sometimes

00:16:31.730 --> 00:16:34.460
We don't, we might have bugs in there.

00:16:34.580 --> 00:16:37.120
So if you are an audio developer,
video developer,

00:16:37.120 --> 00:16:40.480
and realize that we are not
decoding and you're pretty sure,

00:16:40.510 --> 00:16:44.710
just submit a bug and we will fix it.

00:16:45.300 --> 00:16:51.550
You get bonus points if you fix the
bug by going to Darwin and downloading

00:16:51.550 --> 00:16:54.670
USB Prover and just send us the diffs.

00:16:55.550 --> 00:16:58.400
I like those kind of bugs.

00:16:58.420 --> 00:17:01.100
I was mentioning earlier
about the config descriptor,

00:17:01.100 --> 00:17:08.680
like in the sense that bytes three
and four are where the length byte is.

00:17:09.290 --> 00:17:15.850
And this reminded me about our
transition to Intel-based Macs.

00:17:16.290 --> 00:17:19.470
We are sort of in a very good
position in terms of USB because

00:17:19.530 --> 00:17:24.200
USB is a little Indian system,
just like Intel.

00:17:24.350 --> 00:17:27.180
And the Mac is obviously,
the PowerPC is big Indian.

00:17:27.200 --> 00:17:34.310
So we already had to, when dealing with
quantities on the USB bus,

00:17:34.420 --> 00:17:38.200
do the translation and use
the byte ordering macros.

00:17:38.200 --> 00:17:39.400
So,

00:17:40.680 --> 00:17:44.010
As far as you are concerned,
if you are doing device requests

00:17:44.100 --> 00:17:49.400
and things at the low level USB,
you won't have to change anything.

00:17:49.400 --> 00:17:52.920
We use the macros that know what
architecture we're running on,

00:17:52.920 --> 00:17:55.590
if it's Little Indian or Big Indian,
and we will do the

00:17:55.950 --> 00:17:58.350
translation when appropriate.

00:17:58.360 --> 00:18:13.400
Fernando Urbinan

00:18:14.520 --> 00:18:19.120
The next tab is just the kernel
extensions and it shows you USB kernel

00:18:19.120 --> 00:18:26.230
extensions and this is just the
output of KEXTAD from the system.

00:18:26.800 --> 00:19:18.400
[Transcript missing]

00:19:18.910 --> 00:19:20.940
For example, this USB camera.

00:19:20.940 --> 00:19:25.580
And you see here that the
IOUSB composite driver

00:19:26.360 --> 00:19:32.490
loaded for the device even
though it is not a composite -

00:19:32.650 --> 00:19:36.020
it is not a composite device,
but I have a personality that

00:19:36.030 --> 00:19:40.770
matches a miscellaneous class
device to the composite driver.

00:19:40.830 --> 00:19:44.200
I didn't change the font for the details
so it's hard to read but here you could

00:19:44.220 --> 00:19:49.990
find the probe score for this driver
and of course there's the different

00:19:49.990 --> 00:19:56.260
interfaces and these are actually video
control and video streaming interfaces.

00:19:56.260 --> 00:19:59.860
We do this all from user space
and so there are no kernel

00:20:01.110 --> 00:20:04.520
extensions matched to it.

00:20:04.520 --> 00:20:13.850
The final tab is USB logger and this is
where the USB logs from the system go.

00:20:14.380 --> 00:20:19.140
I have loaded the login version
of the IOUSB family in this

00:20:19.470 --> 00:20:22.120
machine and so I can look at a - -

00:20:23.480 --> 00:20:27.560
"Level 6, let's do level 5 because
it's not as verbose.

00:20:27.760 --> 00:20:33.110
Start it and then if I unplug
the device we'll see all the

00:20:33.980 --> 00:20:45.510
One thing that I do that might be handy
for you and I always tell our testers

00:20:45.510 --> 00:20:49.700
to do is to go to the bus probe window.

00:20:50.030 --> 00:20:53.690
Fernando Urbinan:
And uncheck the refresh automatically

00:20:53.810 --> 00:20:57.520
when you are getting USB logs
because when you're doing plugs

00:20:57.660 --> 00:21:02.060
and unplugs and that checkbox is on,
it will automatically try to,

00:21:02.060 --> 00:21:05.760
when it sees a new device,
issue device requests to try to

00:21:05.770 --> 00:21:08.250
get the information for USB prober.

00:21:08.250 --> 00:21:10.190
And that might confuse you.

00:21:10.190 --> 00:21:14.600
It certainly sometimes confuses me
when I'm looking at logs and I see

00:21:14.600 --> 00:21:17.800
stuff that I don't know who's doing it.

00:21:17.900 --> 00:21:24.200
Fernando Urbinan:
So that's just one handy

00:21:25.700 --> 00:21:35.600
[Transcript missing]

00:21:41.280 --> 00:21:47.920
So that is what I talked about.

00:21:47.920 --> 00:21:51.070
One thing that I did not mention
is that Level 7 is really,

00:21:51.080 --> 00:21:52.520
really verbose.

00:21:52.520 --> 00:21:57.620
And I only use it for a very
short amount of time when I want

00:21:57.620 --> 00:22:00.760
to know a lot of what happened.

00:22:00.760 --> 00:22:03.700
If you use it for long periods of time,
you can overrun the buffer.

00:22:03.700 --> 00:22:08.650
And then you lose logs,
and you don't know what happened.

00:22:11.060 --> 00:22:15.500
Sometimes it comes to machine debugging,
and if you're doing kernel extensions

00:22:15.500 --> 00:22:19.170
and you cannot get around that,
I won't do it.

00:22:19.180 --> 00:22:21.820
We tried for like two or
three years to do it on stage,

00:22:21.820 --> 00:22:25.140
and that was a bad idea.

00:22:25.450 --> 00:22:31.640
Yesterday there was a session by the
IO-Kit team that was very useful in

00:22:31.720 --> 00:22:35.300
terms of doing kernel extensions.

00:22:35.300 --> 00:22:37.190
I mention it here in
case you didn't attend,

00:22:37.190 --> 00:22:43.080
you can go when the slides come
out or the DVD or whatever it is.

00:22:43.080 --> 00:22:48.970
And if you did not attend,
I encourage you to look at it again.

00:22:49.200 --> 00:22:54.600
And sometimes you get panics and the
only way to know what's going on is to

00:22:54.660 --> 00:23:02.470
actually debug the panic and figure out
where in your code it's bailing out.

00:23:02.660 --> 00:23:05.140
You can,
if you're doing kernel extensions,

00:23:05.170 --> 00:23:10.270
you won't be able to get away from
understanding panics and decoding panics.

00:23:10.900 --> 00:23:13.000
Of course, user space,
like we've said all along,

00:23:13.000 --> 00:23:14.440
is a lot better.

00:23:14.440 --> 00:23:16.270
It's much easier to debug.

00:23:16.560 --> 00:23:20.290
It's easier on your machine
because you don't keep panicking.

00:23:20.400 --> 00:23:23.010
Symbolic debugging is great.

00:23:23.510 --> 00:23:27.430
Over the last year,
I've been developing the

00:23:28.050 --> 00:23:33.260
USB Video Class Driver,
which is a QuickTime digitizer.

00:23:33.640 --> 00:23:36.860
It's a lot better than
debugging things in the kernel.

00:23:36.860 --> 00:23:42.940
So in my case, sometimes I have to
modify the IOUSB library,

00:23:43.000 --> 00:23:48.610
and I can build a debug version of it,
install it live,

00:23:48.840 --> 00:23:54.700
step into it from my application,
and it's all there.

00:23:54.860 --> 00:23:57.640
It's a lot better.

00:23:57.720 --> 00:24:01.500
In some cases,
you still need to use printf's,

00:24:01.500 --> 00:24:08.650
and in my case, I have this high priority
threads running on the callbacks.

00:24:08.780 --> 00:24:16.300
There's other threads doing other stuff,
and so stopping the program

00:24:16.300 --> 00:24:21.100
just disturbs the flow,
and you have to resort to printf's.

00:24:21.180 --> 00:24:26.540
The new Xcode 2.1,
I was on the session yesterday morning,

00:24:26.540 --> 00:24:32.110
and it allows you to create a breakpoint,
print something, and continue so that it

00:24:32.110 --> 00:24:33.580
actually doesn't stop.

00:24:33.580 --> 00:24:38.380
And so that's going to
be really handy to use.

00:24:39.520 --> 00:24:44.180
Finally, like I know if you've
lived on the USB list,

00:24:44.180 --> 00:24:48.620
you've heard it a lot before,
is sometimes you just need to

00:24:48.620 --> 00:24:50.790
know what's going on in the bus.

00:24:51.510 --> 00:24:57.160
This Q&A that I mentioned there has
a little section on the different

00:24:57.930 --> 00:25:00.350
models of USB bus analyzers.

00:25:00.440 --> 00:25:02.400
They're all at different price points.

00:25:02.820 --> 00:25:07.350
Right here for our demo,
I have a CATSI mobile high speed,

00:25:07.470 --> 00:25:11.200
which is just a PC card that
goes into a Windows laptop.

00:25:11.400 --> 00:25:17.240
But when you can't figure out things,
you need to know what's

00:25:17.240 --> 00:25:19.350
going on in the bus.

00:25:19.500 --> 00:25:22.400
Did the controller actually
put the transaction on the bus?

00:25:22.400 --> 00:25:25.280
Was it the right format
that you were expecting?

00:25:25.400 --> 00:25:30.800
Did the device respond to
that transaction in the manner

00:25:30.800 --> 00:25:33.210
that you thought it was?

00:25:33.400 --> 00:25:40.400
The only way to know the answers to
these questions is to look at the bus.

00:25:40.400 --> 00:25:41.570
Thanks.

00:25:43.760 --> 00:25:49.560
Okay,
now we're going to move to demo two,

00:25:49.560 --> 00:25:50.530
if you will, please.

00:25:51.810 --> 00:25:56.140
And...excuse me a second.

00:26:00.200 --> 00:26:09.200
[Transcript missing]

00:26:11.990 --> 00:26:15.560
This is a little device from one of
our developers from Code Mercenaries,

00:26:15.560 --> 00:26:17.920
and it's the IO Warrior 40.

00:26:17.920 --> 00:26:22.670
And we're going to use this to
do what I mentioned earlier,

00:26:22.680 --> 00:26:24.830
look at the device,
discover the interfaces,

00:26:24.860 --> 00:26:27.140
and start reading from it.

00:26:27.240 --> 00:26:31.020
So, of course,
since I had it not refresh automatically,

00:26:31.050 --> 00:26:32.680
I have to go over here.

00:26:32.680 --> 00:26:36.050
And first of all,
I just want to go and show

00:26:36.050 --> 00:26:38.240
you what the device has.

00:26:38.240 --> 00:26:41.550
This is just a device
descriptor over there.

00:26:42.210 --> 00:26:43.340
The interesting

00:26:44.960 --> 00:26:49.350
The configuration descriptor
only has one interface.

00:26:49.700 --> 00:26:55.230
There are two interfaces,
both HitClass interfaces.

00:26:56.430 --> 00:27:01.700
This first one has an
interrupt input endpoint,

00:27:01.730 --> 00:27:05.780
and the last, the second one,
also has another

00:27:05.780 --> 00:27:09.960
interrupt input endpoint.

00:27:10.300 --> 00:27:15.890
I'm gonna use this demo monkey
assistant that allows me to

00:27:16.800 --> 00:27:28.400
[Transcript missing]

00:27:31.390 --> 00:27:36.480
I don't like to work in this mode,
so I'm going to change the

00:27:36.480 --> 00:27:44.650
preferences to be condensed,
and then I'm going to

00:27:44.780 --> 00:27:46.210
open the project again.

00:27:54.220 --> 00:27:57.900
This is our file.

00:27:57.900 --> 00:27:59.180
We go here to the main.

00:27:59.340 --> 00:28:01.000
It's very easy.

00:28:01.200 --> 00:28:05.610
First thing we're going to do is
just look for the device interfaces.

00:28:06.500 --> 00:28:07.940
And that is right up here.

00:28:07.940 --> 00:28:11.220
I'm not going to go through every
single line and show you one thing,

00:28:11.360 --> 00:28:16.760
but we know, or I know,
from the common class specification that

00:28:16.800 --> 00:28:23.960
in order to match to a USB interface,
you have to specify, if you're doing a

00:28:23.960 --> 00:28:27.890
vendor-specific dictionary,
you have to specify

00:28:27.890 --> 00:28:33.510
the vendor product ID,
B configuration value,

00:28:33.510 --> 00:28:34.010
and interface number.

00:28:34.440 --> 00:28:39.760
I have here the vendor
ID and the product ID.

00:28:39.840 --> 00:28:44.990
I'm creating those numbers and setting
them in our matching dictionary,

00:28:45.070 --> 00:28:51.510
but I have not done our configuration
value and interface number.

00:28:55.180 --> 00:29:00.470
This is the official font,
so I don't want to mess with that.

00:29:00.710 --> 00:29:02.160
Sorry.

00:29:05.400 --> 00:29:18.200
[Transcript missing]

00:29:21.200 --> 00:29:22.910
I didn't think that was it.

00:29:23.010 --> 00:29:26.630
But let's go to--

00:29:29.700 --> 00:29:30.940
128.

00:29:31.130 --> 00:29:33.400
No.

00:29:33.400 --> 00:29:34.100
Let's see.

00:29:34.260 --> 00:29:35.970
Did that do it?

00:29:38.610 --> 00:29:40.600
Let's see, is this any better?

00:29:40.600 --> 00:29:45.800
I go back to... Is that any better?

00:29:46.380 --> 00:29:47.870
Okay.

00:29:49.160 --> 00:29:52.600
Okay, sorry about that.

00:29:52.660 --> 00:29:57.040
As I said, we have the vendor ID and the
product ID matching dictionary.

00:29:57.130 --> 00:30:05.030
Now, I'm going to add the configuration
value and the interface number.

00:30:09.730 --> 00:30:16.840
You can see that I am using now
the wildcard matching criteria.

00:30:16.980 --> 00:30:19.440
And I don't have to create
a number or anything,

00:30:19.440 --> 00:30:25.900
I just said the dictionary
value with a value of the

00:30:25.900 --> 00:30:29.260
wildcard character right there.

00:30:29.370 --> 00:30:31.980
So what this is going to do actually,
it's not only going to

00:30:31.980 --> 00:30:34.450
match to my first interface,
but it's also going to match

00:30:34.560 --> 00:30:37.760
to the second interface
that we saw for this device.

00:30:37.880 --> 00:30:43.900
If we have multiple configurations,
then it would match to all the

00:30:43.900 --> 00:30:47.550
interfaces in every configuration.

00:30:50.000 --> 00:30:55.660
Then, once we discover,
we set the matching dictionary,

00:30:55.660 --> 00:31:00.570
we look for any IO services
that match that dictionary

00:31:00.810 --> 00:31:02.800
and get a device iterator.

00:31:02.800 --> 00:31:07.420
And with a device iterator,
we can open the connection to the

00:31:07.420 --> 00:31:11.940
IOUSB interface object in the kernel.

00:31:11.940 --> 00:31:13.920
And I'm not going to
go through all of that.

00:31:13.940 --> 00:31:19.590
But once we have that object,
we can go and work with that interface.

00:31:20.060 --> 00:31:23.840
So we'll go up there and we see that
right now it's not doing anything.

00:31:23.870 --> 00:31:29.140
But the first thing we're
going to do is let's do a save.

00:31:29.140 --> 00:31:32.920
And so all I'm doing here is
trying to open that interface.

00:31:32.920 --> 00:31:36.700
We'll build.

00:31:37.500 --> 00:31:53.330
Fernando Urbinan: Hello,
I'm Fernando Urbinan,

00:31:53.330 --> 00:31:53.330
and I'm going to show you how
to use the IOUSBFamily KEXT.

00:31:54.770 --> 00:31:56.870
What it says here,
and I'm sorry I couldn't figure

00:31:56.870 --> 00:31:58.780
out how to make this font bigger.

00:31:58.780 --> 00:32:02.700
I have some of the assert
macros and I'll show you here.

00:32:02.700 --> 00:32:04.610
It's right here.

00:32:04.690 --> 00:32:06.700
It requires string.

00:32:06.700 --> 00:32:12.920
It says if the string is
not IO return success,

00:32:13.180 --> 00:32:18.740
we jump to exit and then
we print a string value.

00:32:18.800 --> 00:32:20.700
And I have this USB to error string.

00:32:20.700 --> 00:32:27.200
All this does is a function up here
that will take an IO return and actually

00:32:27.200 --> 00:32:30.650
return a string with the error name.

00:32:30.650 --> 00:32:32.700
And that is very handy after a while.

00:32:32.700 --> 00:32:37.420
I don't know what the 2C5 or
2C7 or which one is which.

00:32:37.690 --> 00:32:42.960
So going back to the run,
what it says here is debug assert

00:32:42.960 --> 00:32:50.700
WWC demo KR equals equals KIO return
success exit KIO return exclusive error.

00:32:50.700 --> 00:32:51.780
Thank you.

00:32:51.850 --> 00:32:58.300
Ah, we go to Prober,
we can go to the IO registry window,

00:32:58.580 --> 00:33:03.800
look for our device, which is right here,
look at the interface,

00:33:03.940 --> 00:33:06.720
and we see that the
IOUSB HIT driver has matched to it.

00:33:06.800 --> 00:33:14.250
And that is because it's a HIT device
and the kernel driver matches to it

00:33:14.250 --> 00:33:18.400
before anybody in user space can use it.

00:33:18.800 --> 00:33:21.800
Of course, at this point,
if this was a real thing,

00:33:21.800 --> 00:33:27.790
you can use the HIT manager to actually
get at the raw data coming from the

00:33:27.790 --> 00:33:35.800
interrupt pipe and interface to that
device using an IOUSB HIT interface

00:33:35.800 --> 00:33:37.800
instead of an IOUSB interface interface.

00:33:37.800 --> 00:33:42.800
However,
we have had requests in the past,

00:33:42.800 --> 00:33:44.710
and I think it is an important
demo of how you can make a device

00:33:44.830 --> 00:33:45.800
that is really easy to use.

00:33:45.800 --> 00:33:47.800
And I think it is an important
demo of how you can make a device

00:33:47.800 --> 00:33:48.800
that is really easy to use.

00:33:48.800 --> 00:33:53.100
An important demo of how you can
prevent a kernel extension from

00:33:53.100 --> 00:33:55.640
matching to one of your interfaces.

00:33:56.010 --> 00:34:02.910
And the solution is to actually create
a codeless kernel extension that matches

00:34:03.160 --> 00:34:09.750
to your device or your interface and
uses the IOService class as the driver.

00:34:09.970 --> 00:34:13.140
The IOService class itself,
all it does in its start

00:34:13.140 --> 00:34:14.530
method is return true.

00:34:14.840 --> 00:34:18.150
And that is enough to
prevent other drivers,

00:34:18.240 --> 00:34:21.770
especially class drivers
like the HIT driver,

00:34:21.900 --> 00:34:25.800
to match to your device because your
vendor-specific codeless extension

00:34:25.800 --> 00:34:27.800
will have a higher probe score.

00:34:27.900 --> 00:34:36.560
So,
I have a sample of that kernel extension.

00:34:41.520 --> 00:34:46.860
And you can see, hopefully,
that there is no code.

00:34:46.880 --> 00:34:50.160
We just have some
resources and the product.

00:34:50.200 --> 00:34:52.590
There's just an Info.plist.

00:34:54.460 --> 00:34:58.720
I'm not going to go through the
whole thing of the info playlist.

00:34:58.800 --> 00:35:04.330
It's very standard,
but the first couple of key values

00:35:05.150 --> 00:35:13.320
right here are telling I/O Kit that the
CFBundle that we're going to use for

00:35:13.320 --> 00:35:16.840
this driver is actually I/O Kit itself.

00:35:16.890 --> 00:35:21.970
And that is where the
I/O Service class lives.

00:35:22.170 --> 00:35:26.240
We also tell it that the
class to use for our driver,

00:35:26.240 --> 00:35:30.940
i.e., where the start method is,
is I/O Service.

00:35:31.590 --> 00:35:35.270
Fernando Urbinan: In this case,
our provider class is an interface,

00:35:35.280 --> 00:35:38.500
and then we have our matching criteria.

00:35:38.500 --> 00:35:42.580
In this case, again,
I'm going to use the wildcard

00:35:42.580 --> 00:35:49.000
matching criteria to match to
all the interfaces in our device.

00:35:49.200 --> 00:35:53.400
You can see, however-- not however,
but you can see that

00:35:54.130 --> 00:35:56.700
they are not numbers,
but strings.

00:35:56.820 --> 00:36:02.110
Just like in the-- in user space,
we use a CFString to pass the

00:36:02.110 --> 00:36:05.550
value to the matching dictionary,
for I/O Kit personalities,

00:36:05.550 --> 00:36:06.980
we have to specify a string.

00:36:07.300 --> 00:36:11.900
Of course, if this was an integer,
it would not work.

00:36:12.210 --> 00:36:15.970
So we go ahead, build it.

00:36:17.810 --> 00:36:20.430
And I think it built.

00:36:20.460 --> 00:36:24.770
Yep, it did.

00:36:24.770 --> 00:36:24.770
Then...

00:36:25.400 --> 00:36:35.800
[Transcript missing]

00:36:36.380 --> 00:36:42.300
"Directory" It has to have
the right permissions.

00:36:43.710 --> 00:36:45.250
So...

00:36:47.000 --> 00:36:53.200
[Transcript missing]

00:36:57.300 --> 00:37:04.590
Fernando Urbinan:
And we see that at least the

00:37:04.590 --> 00:37:04.590
top level is indeed root wheel,
so I think that it takes.

00:37:04.590 --> 00:37:04.590
And now,

00:37:05.060 --> 00:37:12.990
I'm going to load that kernel extension,
sudo kextload -v.

00:37:14.100 --> 00:37:35.400
[Transcript missing]

00:37:36.380 --> 00:37:38.340
Clear and Replug.

00:37:38.450 --> 00:37:44.270
The reason that I'm unplugging is
to give the new driver a chance to

00:37:44.340 --> 00:37:47.300
compete when I plug in the device.

00:37:47.300 --> 00:37:50.680
If I didn't unplug,
the device or the interface already

00:37:50.680 --> 00:37:57.800
had a kernel extension attached to it
and it wouldn't load the new driver.

00:37:59.340 --> 00:38:04.340
At level 5,
we do print some information on

00:38:04.340 --> 00:38:10.270
drivers that are loaded for a
particular device or interface.

00:38:10.370 --> 00:38:13.690
And we can see right here,

00:38:14.030 --> 00:38:21.230
that we found a driver
with a score of 88,000.

00:38:21.480 --> 00:38:25.100
Fernando Urbinan:
And a wildcard value of two.

00:38:25.250 --> 00:38:29.360
As you recall,
we had a wildcard for the configuration

00:38:29.360 --> 00:38:32.010
value and the interface number.

00:38:32.100 --> 00:38:38.710
Usually a vendor-specific device at
this level has a score of 90,000.

00:38:38.830 --> 00:38:44.120
We reduced it by 2,000 because
there were two wildcards.

00:38:44.120 --> 00:38:48.870
If we go now to the IO registry,
we have the refresh automatically

00:38:49.320 --> 00:38:51.300
set here and open our

00:38:52.610 --> 00:39:00.750
Interfaces.

00:39:00.750 --> 00:39:00.750
We see that the IOUSB HIT driver
is not loaded for it anymore

00:39:00.750 --> 00:39:00.750
and now it's IO Service.

00:39:01.470 --> 00:39:11.530
Now if we go back to our previous project
where we got the exclusive access error,

00:39:13.510 --> 00:39:20.080
Fernando Urbinan:
So this showed you how we could use

00:39:20.080 --> 00:39:29.860
a vendor-specific codeless KEXT to
prevent a class driver from grabbing

00:39:30.000 --> 00:39:34.660
your interfaces or your devices.

00:39:34.770 --> 00:39:39.830
And it comes handy in lots of cases.

00:39:40.330 --> 00:39:45.130
Especially when you want to deal with
the data by yourself and you don't

00:39:45.130 --> 00:39:49.960
want anybody else to be using it.

00:39:51.700 --> 00:39:58.380
Now let's actually go and
do something with this data.

00:39:59.890 --> 00:40:05.440
Let me clean up here a little bit
so I can see where I need to go.

00:40:05.490 --> 00:40:12.020
This is just another
version of the same program.

00:40:12.780 --> 00:40:17.300
Fernando Urbinan:
And if we go to work with the interfaces,

00:40:17.310 --> 00:40:22.110
we see that I actually have the
interface open routine here.

00:40:22.360 --> 00:40:25.220
I don't have the close because
now we're going to actually try

00:40:25.340 --> 00:40:26.940
to do something asynchronously.

00:40:26.940 --> 00:40:31.440
We're going to try to go ahead
and read from the interrupt pipes.

00:40:31.990 --> 00:40:36.410
Fernando Urbinan: We have, as you recall,
two interrupt in pipes,

00:40:36.410 --> 00:40:38.190
one for each interface.

00:40:38.190 --> 00:40:41.700
So we're going to set it
up so that we can do that.

00:40:41.700 --> 00:40:46.130
My iterator is already looking
through all the interfaces that

00:40:46.140 --> 00:40:50.700
match our matching dictionary.

00:40:50.700 --> 00:40:53.310
Fernando Urbinan:
So it's going to call the work

00:40:53.320 --> 00:40:56.790
for interfaces routine twice,
once for each dictionary.

00:41:02.590 --> 00:41:08.130
I go back to our demo monkey stuff here.

00:41:08.600 --> 00:41:11.890
The first thing we need to do,
because we need to use the

00:41:11.890 --> 00:41:17.600
interface number later on,
is get our interface number,

00:41:17.600 --> 00:41:22.890
and these are just calls through the
IOUSB library into the interface objects.

00:41:23.390 --> 00:41:26.740
We then need to get the
number of endpoints.

00:41:26.780 --> 00:41:31.030
As we saw earlier, this device only has
one interrupt endpoint,

00:41:31.040 --> 00:41:34.490
but if you had more,
then you need to know how many so that we

00:41:34.560 --> 00:41:41.280
can iterate through all of them and get
the endpoint that we are interested in.

00:41:42.140 --> 00:41:51.020
So, we'll show here that we're going
to iterate through all the pipes.

00:41:52.300 --> 00:42:25.130
The idea to take away here is that
there is always by the USB spec

00:42:25.230 --> 00:42:33.580
a default control endpoint and
that has a pipe reference of zero.

00:42:33.580 --> 00:42:37.180
And that belongs to
the actual USB device.

00:42:37.260 --> 00:42:42.300
Interfaces have endpoints and we create
pipes for each of those endpoints.

00:42:42.300 --> 00:42:46.920
And those are the things that have
pipe references higher than zero.

00:42:47.000 --> 00:42:52.670
I'm starting at zero here just for,
so that we can see how the

00:42:52.750 --> 00:42:54.260
control endpoint looks.

00:42:54.260 --> 00:42:59.190
But you would probably just start
at one because that's all you need.

00:42:59.240 --> 00:43:04.040
If you were going to do a control
request from you via the IOUSB interface,

00:43:04.160 --> 00:43:07.560
it's going to ask you for
a pipe reference and you're

00:43:07.560 --> 00:43:12.040
going to specify pipe zero,
pipe reference zero.

00:43:12.040 --> 00:43:18.500
Then while we're inside this loop,
we go and we get the

00:43:18.500 --> 00:43:20.940
pipe properties for each.

00:43:22.090 --> 00:43:22.450
pipe

00:43:24.930 --> 00:43:29.540
And this just gives you all
the information for the pipe,

00:43:29.660 --> 00:43:35.880
the interval, if it's in or out,
the max packet size,

00:43:35.910 --> 00:43:37.760
what type of pipe it is.

00:43:37.960 --> 00:43:42.220
So once we get that information,
we want to actually look for our

00:43:42.360 --> 00:43:49.060
interrupt in pipe and do a read to it.

00:43:49.070 --> 00:43:52.290
So what I do here.

00:43:54.250 --> 00:44:00.190
is verified that it is indeed
an interop in-pipe and then

00:44:00.190 --> 00:44:03.820
called read from pipe async.

00:44:04.500 --> 00:44:20.500
[Transcript missing]

00:44:21.700 --> 00:44:24.420
Fernando Urbinan:
And since I want to keep

00:44:24.430 --> 00:44:29.980
reading from this pipe,
what I need to do is in my callback,

00:44:29.980 --> 00:44:31.200
reissue the read.

00:44:31.200 --> 00:44:40.570
So I need some global data in this case
to access when my callback is issued.

00:44:40.790 --> 00:44:44.590
And so I'll create a handy
little structure here that

00:44:44.670 --> 00:44:45.670
has the pertinent data.

00:44:45.720 --> 00:44:49.700
Of course, in real life you
probably have more to it.

00:44:49.720 --> 00:44:52.960
Fernando Urbinan:
And it has the interface interface that

00:44:52.960 --> 00:44:56.920
we need to access the IOUSB library,
the number, the pipe reference,

00:44:56.950 --> 00:44:59.670
etc., etc., and where to put the data.

00:44:59.670 --> 00:45:08.460
And then I create a global one for
each of the interfaces in our device,

00:45:08.570 --> 00:45:12.320
because I know that we have
two interfaces and we're

00:45:12.360 --> 00:45:14.490
going to be called twice.

00:45:17.100 --> 00:45:29.190
Then we go back to our read from
PyPageSync and we actually now need to

00:45:32.200 --> 00:45:47.500
[Transcript missing]

00:45:49.750 --> 00:45:57.700
The read, now this read_py_pay_sync
is an IOUSB interface call.

00:45:57.700 --> 00:45:59.700
And you can look at all the parameters.

00:45:59.700 --> 00:46:03.290
Essentially,
we have the callback function.

00:46:03.580 --> 00:46:08.680
and a void star that can be our
RefCon data and that is just

00:46:08.910 --> 00:46:14.370
going to be passed into our
callback when the read completes.

00:46:15.330 --> 00:46:17.260
We're almost there.

00:46:17.290 --> 00:46:20.860
Now we have to go and

00:46:22.150 --> 00:46:30.370
Go to our asynchronous callback function
that is right here and look at the

00:46:30.370 --> 00:46:34.190
data and then issue the read again.

00:46:35.330 --> 00:46:39.100
The callback function will
have three parameters.

00:46:39.100 --> 00:46:43.640
The first one is the void start that
was passed in the original call.

00:46:43.660 --> 00:46:48.050
Then we have an IO return
that specifies the error,

00:46:48.110 --> 00:46:50.920
the result of the callback.

00:46:50.920 --> 00:46:56.520
And there's another void
start that is arg0 here,

00:46:56.520 --> 00:47:04.890
and that is the number of bytes that
were transferred by the USB read.

00:47:05.200 --> 00:47:12.380
In some cases, if you're reading,
for example, from a bulk pipe or

00:47:12.380 --> 00:47:17.840
writing to a bulk pipe,
you're gonna request 64K of data and

00:47:17.840 --> 00:47:21.880
the device might only send you 23K.

00:47:21.890 --> 00:47:23.440
That is perfectly valid.

00:47:23.440 --> 00:47:25.030
It's a valid transaction on the bus.

00:47:25.040 --> 00:47:26.580
There was no errors.

00:47:26.580 --> 00:47:32.980
It is ended by a short packet,
but you want that data.

00:47:32.980 --> 00:47:39.460
So what we would have in that
situation is that the number of

00:47:39.460 --> 00:47:45.460
bytes transferred here would be 23K,
even though you had requested 64K.

00:47:45.460 --> 00:47:48.900
So that is passed to
you by the USB stack.

00:47:48.900 --> 00:47:53.400
Once we are in the callback,

00:47:58.200 --> 00:48:01.560
I have a printf that I'm forgetting here.

00:48:01.560 --> 00:48:03.510
This is this one.

00:48:08.500 --> 00:48:19.400
[Transcript missing]

00:48:19.740 --> 00:48:25.040
Once we do that,
we would re-issue the read.

00:48:25.090 --> 00:48:29.200
Now, something to note here is that
I'm not chaining reads yet.

00:48:29.240 --> 00:48:32.740
I'm issuing a read,
and once that completes,

00:48:32.790 --> 00:48:34.380
I'm re-issuing that read.

00:48:34.450 --> 00:48:38.280
So we -- if the device
was sending a lot of data,

00:48:38.370 --> 00:48:41.020
because of the inherent
work loop latencies,

00:48:41.020 --> 00:48:45.550
like I mentioned earlier,
we might not be polling

00:48:45.560 --> 00:48:49.600
that device fast enough.

00:48:49.730 --> 00:48:51.740
And your performance will suffer.

00:48:52.090 --> 00:48:57.500
But in this case,
it's an I-sync -- or an interrupt device.

00:48:57.500 --> 00:49:00.980
I forget what the polling interval is,
but it doesn't matter.

00:49:01.280 --> 00:49:10.220
Okay, so let's build and then run it.

00:49:10.220 --> 00:49:12.910
Oh, yeah, I remembered this last night.

00:49:16.370 --> 00:49:18.250
Let's just remove that
because there is no exit.

00:49:18.270 --> 00:49:22.300
So we'll build again.

00:49:22.440 --> 00:49:27.100
And now let's run it.

00:49:27.210 --> 00:49:32.090
And see what... Whoa, okay.

00:49:32.130 --> 00:49:33.890
I'll stop it.

00:49:35.250 --> 00:49:40.520
I cannot make this bigger, unfortunately,
but I'll go through it quickly.

00:49:40.520 --> 00:49:48.300
It says that, you know,
it's just all my printfs from my program.

00:49:48.340 --> 00:49:50.500
Interface number zero has one endpoint.

00:49:50.500 --> 00:49:54.480
The endpoint zero actually
is a control endpoint.

00:49:54.480 --> 00:49:59.050
It has the any direction,
because control can be host

00:49:59.050 --> 00:50:01.250
to device or device to host.

00:50:02.320 --> 00:50:06.720
A max packet of eight,
and the polling interval

00:50:06.720 --> 00:50:07.840
doesn't matter here.

00:50:07.840 --> 00:50:14.220
Now, for interface number zero,
endpoint one is an interrupt endpoint

00:50:14.340 --> 00:50:19.440
with a max packet size of four and
a 10 millisecond interrupt interval.

00:50:19.440 --> 00:50:29.300
We then go and discover the other
interrupt pin in the second endpoint.

00:50:29.440 --> 00:50:34.720
And then we have issuing a
read pipe for interface zero.

00:50:34.720 --> 00:50:37.040
And then, like I said,
we're iterating through

00:50:37.040 --> 00:50:38.040
all the interface.

00:50:38.040 --> 00:50:43.600
So later on, we show an asynchronous read
for interface number one.

00:50:44.230 --> 00:50:48.140
And my callback function gets called.

00:50:48.300 --> 00:50:51.320
And the result is return success.

00:50:51.320 --> 00:50:56.940
It tells us that it was
interface zero that we got.

00:50:56.940 --> 00:50:57.890
And transfer number one.

00:50:58.020 --> 00:50:58.020
And then we have a callback function.

00:50:58.020 --> 00:50:58.020
And the result is return success.

00:50:58.020 --> 00:50:58.020
It tells us that it was
interface zero that we got.

00:50:58.020 --> 00:50:58.020
And transfer number one.

00:50:58.020 --> 00:50:58.850
And then we have a callback function.

00:50:58.920 --> 00:50:59.650
And transfer number one.

00:50:59.660 --> 00:51:05.480
In this case, we're not chaining read,
so that does not change.

00:51:05.500 --> 00:51:07.660
And bytes transfer was zero.

00:51:07.980 --> 00:51:10.310
And these are the first four bytes of it.

00:51:10.490 --> 00:51:14.120
As it turns out,
I'm actually not sending any commands

00:51:14.210 --> 00:51:19.380
to this device to start sending
data from interface number one.

00:51:19.470 --> 00:51:22.500
So that's all it's going to do.

00:51:22.820 --> 00:51:25.910
And I stopped it.

00:51:26.790 --> 00:51:32.080
It demonstrates that we were issuing the
reads from both pipes and we were getting

00:51:32.080 --> 00:51:37.040
the data and reissuing the read and this
would have continued on and on and on.

00:51:37.150 --> 00:51:41.950
So that's a simple example.

00:51:42.260 --> 00:51:45.000
Now we're going to

00:51:45.870 --> 00:51:49.140
I'm going to add another device,
and actually we're going to

00:51:49.140 --> 00:51:53.960
use essentially the same code,
but this other device is

00:51:54.670 --> 00:52:02.800
this digital camera that has
a USB video class interface.

00:52:02.800 --> 00:52:09.790
And I know that it is a bulk pipe camera
as opposed to an isochronous camera.

00:52:09.800 --> 00:52:14.470
So let me plug it in.

00:52:17.610 --> 00:52:19.280
You know what I'm going to do, actually?

00:52:19.340 --> 00:52:23.510
I'm going to plug it in through my CATSI.

00:52:23.670 --> 00:52:28.960
And so at the end of the program,
I can actually show you the data

00:52:28.960 --> 00:52:34.730
coming in through the-- and being
decoded by the USB bus analyzer.

00:52:34.840 --> 00:52:40.680
So the first thing I want to do is
make sure that we saw that device.

00:52:40.680 --> 00:52:44.550
So I go to USB Prober here.

00:52:45.040 --> 00:53:00.190
Fernando Urbinan: Do a refresh,
and here it is.

00:53:00.190 --> 00:53:00.190
It's a USB PC camera, and as you can see,
it has a bulk input.

00:53:04.430 --> 00:53:06.370
On highlight-- oh, sorry.

00:53:06.460 --> 00:53:10.040
Is it there?

00:53:10.040 --> 00:53:10.740
Now it is.

00:53:10.750 --> 00:53:12.420
Sorry about that.

00:53:12.650 --> 00:53:14.870
It works in the other, in Xcode.

00:53:15.130 --> 00:53:23.690
Okay, so I get now version
4 of my demo program.

00:53:29.800 --> 00:53:32.800
The first thing we have to do,
I didn't show you before,

00:53:32.800 --> 00:53:42.980
is that we need to change the vendor
and product IDs to the new camera.

00:53:44.550 --> 00:53:51.340
As an aside,
with Xcode 2.0 and native targets,

00:53:51.340 --> 00:53:51.340
now you have to

00:53:51.940 --> 00:53:53.710
specify the Info.plist.

00:53:53.720 --> 00:54:00.680
It opens in just a regular
Xcode window editor,

00:54:00.680 --> 00:54:07.180
or you can open it with the plist editor.

00:54:07.200 --> 00:54:12.710
I've discovered that you can input a
hex number instead of just a decimal

00:54:12.710 --> 00:54:16.240
number by prefacing it with 0x,
and it'll take it and

00:54:16.240 --> 00:54:17.860
it'll do the right thing.

00:54:18.080 --> 00:54:20.790
So that's kind of handy.

00:54:22.340 --> 00:54:27.500
So again,
we now have our vendor and product ID,

00:54:27.500 --> 00:54:31.560
and we want to not only look
for any interrupt in pipes,

00:54:31.580 --> 00:54:34.420
and I didn't show you,
but this device actually has

00:54:34.500 --> 00:54:36.660
an interrupt in pipe as well.

00:54:36.710 --> 00:54:41.200
But we also want to look
for the bulk in pipe.

00:54:45.420 --> 00:54:49.200
We come and here where we're looking at,
we're iterating through

00:54:49.200 --> 00:54:56.660
all our endpoints,
we're going to go ahead and add the

00:54:58.700 --> 00:55:00.890
Bulk.

00:55:00.890 --> 00:55:04.260
That's not where I wanted it.

00:55:04.260 --> 00:55:04.260
Let's put it--

00:55:14.460 --> 00:55:17.450
Okay,
so we're going to look for a pipe that

00:55:17.450 --> 00:55:26.170
is either an interrupt pipe or a bolt
pipe and the direction being USB in.

00:55:29.530 --> 00:55:35.730
Then, with this device,
what we want to do

00:55:35.950 --> 00:55:41.230
is actually read,
issue more than one read

00:55:41.600 --> 00:55:47.400
[Transcript missing]

00:55:48.210 --> 00:55:53.660
So let me actually go and
modify my data structure here.

00:55:55.400 --> 00:56:08.000
[Transcript missing]

00:56:19.200 --> 00:56:27.450
Let's go back to Work with Interfaces,
I believe.

00:56:28.790 --> 00:56:29.700
You know what?

00:56:29.700 --> 00:56:32.640
Let me go to the one that
I have everything there,

00:56:32.640 --> 00:56:41.300
because we're running out of
time and it'll be a lot easier.

00:56:41.300 --> 00:56:41.300
Go home.

00:56:42.900 --> 00:56:49.000
You see I have the checkpoint versions,
just in case.

00:56:54.680 --> 00:56:56.340
Let's go back to work with interfaces.

00:56:56.400 --> 00:57:04.730
As you can see, we are looking for the
interrupt and the bolt pipe,

00:57:04.730 --> 00:57:06.400
like I was saying earlier.

00:57:06.420 --> 00:57:13.000
Now when we go to read pipe async,
what we want to do is create

00:57:13.040 --> 00:57:15.900
data for each of the reads
that we're going to issue.

00:57:15.900 --> 00:57:19.790
And that is my number of
concurrent transfers that

00:57:19.790 --> 00:57:22.200
I'm going to issue at a time.

00:57:22.220 --> 00:57:29.030
I modify my global to be a
two-dimensional array with the interface

00:57:29.030 --> 00:57:31.200
number and the transfer number.

00:57:31.240 --> 00:57:36.770
And I remember the transfer
number right there.

00:57:38.230 --> 00:57:39.940
Calls are the same.

00:57:39.940 --> 00:57:44.930
The calls to read PipeASync,
they need a pointer to the buffer

00:57:45.070 --> 00:57:50.620
where we're going to put the data,
what the max packet size is, etc.

00:57:50.880 --> 00:57:53.110
So that doesn't change.

00:57:53.360 --> 00:57:57.120
And because we are in this for loop,
we're actually going to

00:57:57.440 --> 00:58:00.400
issue the call twice.

00:58:02.100 --> 00:58:05.860
If we go back to our callback function,
as you can see,

00:58:06.000 --> 00:58:09.580
it looks the same as before.

00:58:09.580 --> 00:58:12.320
And if I was actually typing,
you could see that I wasn't

00:58:12.460 --> 00:58:14.720
going to change it at all.

00:58:14.890 --> 00:58:17.550
At the beginning,
once we get the callback,

00:58:17.550 --> 00:58:21.830
we only have to reissue that one read,
because we're going to get

00:58:21.850 --> 00:58:24.000
another callback later on.

00:58:24.010 --> 00:58:34.760
And that's how we keep the
bus primed with our reads.

00:58:34.760 --> 00:58:34.760
And of course, up here, I

00:58:35.420 --> 00:58:41.180
Let's modify this to be
the two-dimensional array.

00:58:41.210 --> 00:58:44.510
Let's build this.

00:58:50.600 --> 00:59:09.200
[Transcript missing]

00:59:16.600 --> 00:59:25.500
[Transcript missing]

00:59:25.670 --> 00:59:33.670
Fernando Urbinan: So,
you can actually see right here that,

00:59:33.670 --> 00:59:36.250
and I'm not going to go
through all the things,

00:59:36.360 --> 00:59:38.800
but we discovered the
interrupt in endpoint,

00:59:38.850 --> 00:59:47.520
we discovered the bulk endpoint,
and we created two reads at a time.

00:59:47.530 --> 00:59:52.960
And we can see that we're
getting callbacks with 64 bytes,

00:59:52.960 --> 00:59:56.570
and transfer zero, and then transfer one.

00:59:56.630 --> 01:00:00.540
If we could go to the
Windows machine just for a second,

01:00:00.540 --> 01:00:04.120
and we have...

01:00:04.990 --> 01:00:07.200
This is the Cat C software.

01:00:07.210 --> 01:00:15.520
We're going to set it up to record,
and I'm going to run the program again.

01:00:18.300 --> 01:00:22.260
Let's make sure that... Okay,
it's running.

01:00:22.290 --> 01:00:24.250
I'll stop.

01:00:29.100 --> 01:00:34.730
Let's see, let's do a stop but
preserve uploaded data.

01:00:36.600 --> 01:00:44.370
And here you can see, view, zoom out, no,
zoom in.

01:00:49.640 --> 01:00:56.940
Fernando Urbinan: Let's do one more.

01:00:56.940 --> 01:00:57.680
Yes, yes, I know I'm running out of time.

01:00:57.680 --> 01:00:59.600
You can see that 64 bytes at a time,
but we were so close.

01:00:59.850 --> 01:01:03.090
And I can just continue.

01:01:03.100 --> 01:01:05.820
And you see actually in this
case we haven't talked about it,

01:01:05.840 --> 01:01:09.560
but you see the data toggle
actually toggling between

01:01:09.560 --> 01:01:15.510
zero and one in each transfer.

01:01:15.600 --> 01:01:21.590
And at some point we're
probably going to see

01:01:22.730 --> 01:01:25.970
Here, that device gave us as
much data as it could,

01:01:26.000 --> 01:01:32.000
and now it's starting to knack the read.

01:01:32.200 --> 01:02:03.400
[Transcript missing]

01:02:03.840 --> 01:02:08.690
In knowing how to start with USB,
and that's why we did

01:02:08.690 --> 01:02:10.900
this demo like this.

01:02:10.900 --> 01:02:16.210
Of course, there's the URL where all the
information about WWDC is.

01:02:16.210 --> 01:02:18.100
The related sessions.

01:02:18.100 --> 01:02:23.210
Tomorrow, we have a kernel extension
lab next door where FireWire,

01:02:23.310 --> 01:02:26.200
USB, I/O Kit people are going to be.

01:02:26.200 --> 01:02:31.760
There is also a lab for adding
HIT support to your applications,

01:02:31.760 --> 01:02:36.410
and our HIT guru, Rob Yepeza,
is going to be there.

01:02:36.570 --> 01:02:40.490
I encourage you to
take advantage of that.

01:02:42.110 --> 01:02:50.190
Craig Keithley over here is
going to come for the Q&A.

01:02:50.190 --> 01:02:50.190
He is our evangelist,
our technology evangelist.

01:02:50.530 --> 01:03:00.100
Of course, if you don't know about the
USB list at http://list.apple.com,

01:03:00.180 --> 01:03:00.550
join it.

01:03:00.550 --> 01:03:03.000
We always read it.

01:03:03.160 --> 01:03:06.670
Sometimes, depending on our workload,
we don't answer as

01:03:06.670 --> 01:03:12.060
fast as you might want,
but we are there, so please use it.
WEBVTT

00:00:00.920 --> 00:00:01.850
Let me introduce myself.

00:00:01.960 --> 00:00:03.010
I'm Ralph Bruhner.

00:00:03.050 --> 00:00:07.300
I manage the Quartz Composer
Core Image and Core Video projects,

00:00:07.400 --> 00:00:11.480
and Core Image is, well,
what this session here is all about.

00:00:15.610 --> 00:00:20.100
So let me give you a brief
overview of what's going to happen.

00:00:20.100 --> 00:00:22.780
So yeah, there's a short description
of what core image is,

00:00:22.780 --> 00:00:25.920
just in case you have missed
last year's session or didn't get

00:00:25.920 --> 00:00:28.020
around to read the documentation.

00:00:28.130 --> 00:00:30.570
But that's going to be very brief,
so I kind of assumed that you have

00:00:30.840 --> 00:00:33.380
heard about it in the meantime.

00:00:33.380 --> 00:00:38.210
Then I will do a short description
of some of the sample code

00:00:38.310 --> 00:00:40.340
you find on the TigerDVD.

00:00:40.340 --> 00:00:44.590
And essentially just pointing out
what -- where to look if you're having

00:00:44.590 --> 00:00:47.600
a specific certain type of problem.

00:00:47.650 --> 00:00:51.880
And then we go to the star of the day,
which is the CI annotation app,

00:00:51.880 --> 00:00:55.580
which is the actual hands-on
part of this session,

00:00:55.690 --> 00:00:58.570
which Frank Dubke will do that part.

00:00:58.700 --> 00:01:02.320
And then Mark Zimmer will come
up and demonstrate to you how to

00:01:02.400 --> 00:01:06.510
build two Image Units from scratch,
and then we're going to

00:01:06.520 --> 00:01:10.200
show you how to use them,
in this case in motion.

00:01:10.200 --> 00:01:18.680
And after a bunch of demos,
depending on how much time we have,

00:01:18.680 --> 00:01:19.300
there will be pointers to arrays of
sessions to where to go to learn more.

00:01:20.090 --> 00:01:22.640
So, about Core Image.

00:01:22.640 --> 00:01:24.770
Well, Core Image is a new image
processing framework.

00:01:24.850 --> 00:01:28.770
It was introduced in Tiger,
and the goal of it is to do

00:01:28.770 --> 00:01:31.200
image processing on the GPU.

00:01:31.200 --> 00:01:34.300
It has a full floating-point pipeline,
and it's fully color managed.

00:01:34.420 --> 00:01:41.790
It comes with a set of 100 filters,
and there is this concept of Image Units,

00:01:41.790 --> 00:01:44.120
which is essentially a plug-in
architecture so that developers

00:01:44.120 --> 00:01:44.120
can extend the base set.

00:01:45.360 --> 00:01:53.490
If an adequate GPU is not available
so that the Core Image cannot

00:01:53.490 --> 00:02:02.130
do the processing on the GPU,
it will compile on the fly to the CPU,

00:02:02.130 --> 00:02:02.190
and it will actually
produce AlteVec code,

00:02:02.190 --> 00:02:02.190
or it will produce SSE3
code to execute your filter.

00:02:04.530 --> 00:02:09.150
Okay,
so what are you going to do with it?

00:02:09.210 --> 00:02:13.240
I'd like to encourage you to use
Core Image wherever you can because,

00:02:13.240 --> 00:02:15.720
well, that's my agenda.

00:02:16.640 --> 00:02:19.100
If you have applications
that do in-place,

00:02:19.100 --> 00:02:21.900
would have a place for
in-place image editing,

00:02:21.900 --> 00:02:24.250
then you should consider doing that.

00:02:24.320 --> 00:02:27.530
So, for example,
if you do a word processor,

00:02:27.610 --> 00:02:30.460
images are probably not your
primary type of data you deal with,

00:02:30.620 --> 00:02:34.030
but somebody can drag in an image and
you should do something decent with it.

00:02:34.510 --> 00:02:40.500
So, one option is to give the user an
inspector where they can change

00:02:40.500 --> 00:02:43.420
the properties of this image,
like brightness, contrast,

00:02:43.540 --> 00:02:45.520
the usual stuff,
so that the user doesn't have to

00:02:45.520 --> 00:02:49.140
switch to another app to get that
functionality for simple edits.

00:02:49.140 --> 00:02:53.290
And the key thing to remember is...

00:02:54.590 --> 00:02:59.560
Core Image is built around the idea
of doing everything in real time.

00:02:59.560 --> 00:03:02.250
So you do your image processing
in the display pipeline.

00:03:02.400 --> 00:03:04.610
The opposite of that is
essentially doing it offline.

00:03:04.620 --> 00:03:06.720
So you take your image,
you apply a filter,

00:03:06.730 --> 00:03:09.930
and you write out bits,
and you keep these bits around for, well,

00:03:09.930 --> 00:03:12.150
however long your application lives.

00:03:13.780 --> 00:03:17.900
This is not the right model if
you want real-time feedback.

00:03:17.930 --> 00:03:21.780
So the right model is actually when
you draw the rest of your document,

00:03:21.950 --> 00:03:25.480
you also draw the image through
the filter and have the filter

00:03:25.530 --> 00:03:29.310
applied just at the time,
well, at draw time.

00:03:29.490 --> 00:03:33.820
And that essentially means there
is no apply button and there is

00:03:33.920 --> 00:03:37.520
no progress bar that comes up that
lets you wait until it's done.

00:03:37.630 --> 00:03:40.530
Plus it makes things like multi-level
undo really easy because you're no

00:03:40.540 --> 00:03:45.130
longer having to store megabytes of bits,
you're just storing these three

00:03:45.130 --> 00:03:47.120
parameters for this filter.

00:03:47.320 --> 00:03:50.480
Anyway,
if your application works with video,

00:03:50.480 --> 00:03:54.250
then, well,
think about putting up color controls,

00:03:54.380 --> 00:03:59.140
again, brightness, saturation,
the bread and butter stuff.

00:03:59.140 --> 00:04:02.410
And you get a good example of
that in the QuickTime player

00:04:02.440 --> 00:04:05.680
where you can go to the menu,
get the color controls,

00:04:05.680 --> 00:04:08.720
and do essentially color
adjustment in real time,

00:04:08.720 --> 00:04:12.150
which, in fact, is using Core Image.

00:04:13.450 --> 00:04:18.160
Further, if it makes sense for your
application to host image units,

00:04:18.160 --> 00:04:19.880
then please do so.

00:04:19.880 --> 00:04:23.330
And that might not be a totally
obvious thing in some cases.

00:04:23.370 --> 00:04:27.130
Clearly, it's an obvious thing if all
you're doing is image processing,

00:04:27.130 --> 00:04:30.540
then you probably want to have
some kind of plugin architecture.

00:04:30.550 --> 00:04:32.300
But let's say you have
a very specialized app.

00:04:32.530 --> 00:04:36.310
Say you're looking at satellite imagery
and you're probably grabbing something

00:04:36.310 --> 00:04:40.020
from Google Maps or what do I know?

00:04:40.020 --> 00:04:43.700
And you have basic image
processing abilities in there,

00:04:43.700 --> 00:04:46.160
maybe false coloring and stuff like that.

00:04:46.160 --> 00:04:50.020
It might not be obvious that you
should host all image units because

00:04:50.020 --> 00:04:52.890
you look at what comes with Tiger and
see things like bump distortion

00:04:52.890 --> 00:04:54.700
and twirl effects and then you say,
well,

00:04:54.700 --> 00:04:57.640
that doesn't really make sense in my app,
so I don't do it.

00:04:57.640 --> 00:05:01.580
Well, by hosting image units,
you give an opportunity to an

00:05:01.580 --> 00:05:04.160
other third-party developer
to actually extend your app.

00:05:04.340 --> 00:05:06.900
So if somebody builds
an image unit that can,

00:05:06.900 --> 00:05:09.870
say, detect roads and do some skinning.

00:05:09.940 --> 00:05:10.020
.

00:05:24.280 --> 00:05:26.490
And, yeah,
if you write your own custom filters,

00:05:26.570 --> 00:05:29.720
consider writing them as an
Image Unit so that other Image Unit hosts

00:05:29.720 --> 00:05:31.320
can actually make use of them.

00:05:31.320 --> 00:05:37.860
And last but not least, you can also use
Core Image to do UI effects.

00:05:37.860 --> 00:05:41.920
You can think of the most wacky
things like putting particles on

00:05:41.920 --> 00:05:43.920
buttons and spotlights and whatever.

00:05:43.920 --> 00:05:46.180
Please apply some taste when doing that.

00:05:46.290 --> 00:05:52.130
But, I mean, having a smooth,
rich user interface is definitely

00:05:52.140 --> 00:05:54.910
for a consumer app a plus,
So you should consider

00:05:54.940 --> 00:05:56.710
looking into this as well.

00:05:58.110 --> 00:06:00.280
So how does this all work?

00:06:00.390 --> 00:06:04.830
Well, us in the Core Image team,
we are essentially a

00:06:04.830 --> 00:06:06.050
bunch of lazy bastards.

00:06:06.230 --> 00:06:08.430
So whenever...

00:06:08.680 --> 00:06:10.510
Whenever you ask
Core Image to do something,

00:06:10.550 --> 00:06:12.320
chances are it will actually not do it.

00:06:12.320 --> 00:06:16.510
It will write a little note saying,
"Well, at one point I'll have to do this

00:06:16.510 --> 00:06:18.510
because somebody asked me to."

00:06:18.710 --> 00:06:23.780
And that's a good thing.

00:06:23.780 --> 00:06:23.780
Sorry about that.

00:06:25.170 --> 00:06:30.840
So the only time that Core Image actually
does work is when you render the image.

00:06:30.840 --> 00:06:33.290
So when you take an image
and you apply a filter,

00:06:33.290 --> 00:06:36.190
what's really happening is
there is a note being added,

00:06:36.190 --> 00:06:38.090
this filter needs to be applied.

00:06:38.090 --> 00:06:40.560
And then you apply the next filter
and you just append to that,

00:06:40.560 --> 00:06:42.220
okay, after this, do this as well.

00:06:42.220 --> 00:06:45.890
And when you go to draw,
there is a just-in-time compiler

00:06:45.890 --> 00:06:49.700
that will take these different
pieces that you requested,

00:06:49.770 --> 00:06:54.660
compile them into a single program,
and does all the processing in one step.

00:06:58.000 --> 00:07:00.000
I think I skipped a point here.

00:07:00.000 --> 00:07:00.760
Okay.

00:07:00.760 --> 00:07:02.640
So, and why is this a good thing?

00:07:02.730 --> 00:07:12.640
So, if you take your
top-of-the-line G5 today,

00:07:12.640 --> 00:07:13.290
the time it takes to get a
single floating-point value

00:07:13.290 --> 00:07:13.290
from memory into the CPU

00:07:14.200 --> 00:07:50.500
[Transcript missing]

00:07:50.700 --> 00:07:55.550
So using Core Image in this
way by actually letting it to

00:07:55.550 --> 00:07:59.210
concatenate filters is usually
a huge performance gain.

00:08:01.700 --> 00:08:04.130
I have to talk about color
management as well a bit.

00:08:04.330 --> 00:08:08.580
So as I mentioned before, Core Image,
the full pipeline is color managed,

00:08:08.580 --> 00:08:11.970
which means when an image comes in,
it has a certain

00:08:11.970 --> 00:08:13.580
ICC profile attached to it.

00:08:13.670 --> 00:08:17.040
It gets mapped into a
working color space.

00:08:17.090 --> 00:08:21.880
All the different filters are actually
applied in that working color space.

00:08:21.880 --> 00:08:26.320
And then when you go to the destination,
this another color matching operation

00:08:26.320 --> 00:08:29.480
is happening where the working color
space gets matched to the display,

00:08:29.530 --> 00:08:32.510
for example, if you draw to display or
whatever the target is.

00:08:32.520 --> 00:08:36.340
And there is a working color
space is something you can set

00:08:36.460 --> 00:08:40.410
when you create the context,
but there is a default one

00:08:40.410 --> 00:08:45.460
which tends to work pretty well,
which is we chose generic RGB HDR.

00:08:45.460 --> 00:08:50.280
So what that means is it's
the primaries of generic RGB.

00:08:50.280 --> 00:08:53.670
So it's very close to what you
usually be used to in terms of

00:08:53.670 --> 00:08:55.740
full red is still full red in that.

00:08:55.740 --> 00:09:01.680
So full red is one zero zero in this,
this working color space,

00:09:01.700 --> 00:09:06.300
which is useful, but it is light linear
and has an infinite gamut.

00:09:06.320 --> 00:09:11.190
So infinite gamut means we actually allow
values that are above one or negative.

00:09:11.230 --> 00:09:13.540
So that way you don't have
any gamut clipping by doing

00:09:13.540 --> 00:09:15.280
these color space conversions.

00:09:15.280 --> 00:09:20.480
Okay, so with that,
I will go to the demo.

00:09:24.660 --> 00:09:30.930
and give you a little walkthrough
through some of the sample code.

00:09:30.930 --> 00:09:30.930
So the simplest

00:09:31.650 --> 00:09:35.590
Sample code we have is
the CI exposure sample.

00:09:35.620 --> 00:09:40.580
Let me just run this.

00:09:40.580 --> 00:09:40.580
Make this a bit bigger.

00:09:44.610 --> 00:09:46.740
This is kind of the hello
world of Core Image.

00:09:46.740 --> 00:09:52.810
It's probably about 20 lines of code,
and all it does,

00:09:52.810 --> 00:09:57.610
it gives you a slider to adjust
the exposure value on this image.

00:09:57.610 --> 00:09:57.610
And I will show you in
a minute how this works.

00:09:59.950 --> 00:10:05.780
So this is the source code for
CI ExposureView with a really large font.

00:10:05.980 --> 00:10:09.250
And everything magic is happening
in the draw-rect method when

00:10:09.250 --> 00:10:10.900
we actually draw the image.

00:10:10.900 --> 00:10:12.860
So the first thing we do,
we get the CI context.

00:10:12.910 --> 00:10:17.350
In this case, we use the one that
AppKit allocates for you.

00:10:18.020 --> 00:10:21.180
And then there's a bunch of
initialization happening here,

00:10:21.180 --> 00:10:22.820
which I will go into in a minute.

00:10:22.830 --> 00:10:25.490
And then the actual filter is
being applied at the bottom.

00:10:25.490 --> 00:10:30.140
So first we take the value from
the slider and set it to that

00:10:30.140 --> 00:10:32.780
input EV input of the filter.

00:10:32.970 --> 00:10:35.930
And then we go to the context,
say draw image,

00:10:36.010 --> 00:10:40.190
we ask the filter for its output image,
and then there's essentially

00:10:40.200 --> 00:10:43.630
a bunch of coordinates,
which piece from the source needs to

00:10:43.630 --> 00:10:45.950
go to which piece in the destination.

00:10:46.400 --> 00:10:47.730
And that's pretty much all there is.

00:10:47.860 --> 00:10:51.990
So the piece that I didn't explain
is the actual initialization part.

00:10:52.110 --> 00:10:56.400
So here,
these two lines load the image from disk,

00:10:56.400 --> 00:10:59.160
in this case, the ROSE.jpg.

00:10:59.810 --> 00:11:03.500
And this line creates the actual filter.

00:11:03.500 --> 00:11:06.560
It uses the exposure adjust filter here.

00:11:06.800 --> 00:11:10.880
And it presets one of the
inputs right on creation time.

00:11:10.880 --> 00:11:14.100
In this case, it sets the input image to
the rows image we just loaded.

00:11:14.100 --> 00:11:16.810
Because during moving the slider,
the image doesn't change,

00:11:16.810 --> 00:11:19.200
so we can just do that
during initialization time.

00:11:19.200 --> 00:11:23.620
Okay, so this is essentially the
simplest filter you can have

00:11:23.620 --> 00:11:28.620
and simplest use of Core Image,
and this is a good starting point.

00:11:28.940 --> 00:11:34.680
So let me show you a second
example called Micropaint.

00:11:37.710 --> 00:11:40.990
MicroPoint is similarly
something like 30 lines of code,

00:11:40.990 --> 00:11:42.360
and it's a small paint program.

00:11:42.360 --> 00:11:44.990
It's really, really simple.

00:11:45.030 --> 00:11:45.800
Looks like this.

00:11:45.800 --> 00:11:48.350
You can set the color.

00:11:52.800 --> 00:11:54.160
And a brush size.

00:11:54.210 --> 00:11:58.160
And clearly I'm drawing
a masterpiece here.

00:11:58.160 --> 00:12:02.390
So let me show you the code,
how this actually works.

00:12:05.280 --> 00:12:11.840
Okay,
there's again a bunch of initialization

00:12:11.840 --> 00:12:11.840
that is not terribly interesting,
so let's go to the interesting part.

00:12:13.190 --> 00:12:14.600
We create a brush filter.

00:12:14.640 --> 00:12:17.160
A brush filter is, we use here,
is a radial gradient.

00:12:17.170 --> 00:12:20.900
So we put the opaque color in the center,
we start off with black,

00:12:20.910 --> 00:12:28.070
and we let it fade out to the rim
of the brush to a translucent color.

00:12:28.200 --> 00:12:33.050
So we allocate radial gradient,
and it has this input color one,

00:12:33.050 --> 00:12:34.090
input radius.

00:12:36.330 --> 00:12:40.680
Some of these pieces get pre-initialized
and then overwritten slightly later,

00:12:40.680 --> 00:12:42.100
so let me show you that.

00:12:42.130 --> 00:12:45.580
How the brush, the DAB,
is actually put into the canvas,

00:12:45.600 --> 00:12:48.410
we use a composite filter,
so that is this piece here.

00:12:48.440 --> 00:12:50.740
So we use a source over
compositing filter to take the

00:12:50.740 --> 00:12:54.980
current state of the canvas and
the brush and merge it together.

00:12:58.340 --> 00:13:03.960
So the key ingredient for the micropaint
example is that CI accumulator,

00:13:04.090 --> 00:13:05.140
this guy here.

00:13:06.760 --> 00:13:11.400
So an eCMI accumulator,
think of it as a buffer.

00:13:11.460 --> 00:13:15.130
You can take the state out of the
eCMI accumulator and you get an image.

00:13:15.160 --> 00:13:18.030
You apply a filter to that image
and you can write that result

00:13:18.170 --> 00:13:19.940
back into the eCMI accumulator.

00:13:19.940 --> 00:13:23.700
So this gives you that feedback
loop so you can accumulate change.

00:13:23.700 --> 00:13:28.020
So creating a eCMI accumulator
is essentially this call here.

00:13:28.140 --> 00:13:30.690
You give it a size and
you give it a format.

00:13:33.110 --> 00:13:35.960
And we initialize it using
a constant color generator.

00:13:35.960 --> 00:13:38.490
We take a constant color
generator with white,

00:13:38.490 --> 00:13:41.580
and this is the first image
we stash into our accumulator.

00:13:41.650 --> 00:13:45.830
So the canvas starts out with white,
which seems like a reasonable default.

00:13:46.670 --> 00:13:49.230
And then yeah, exactly here,
this sets the image back

00:13:49.230 --> 00:13:51.780
into the accumulator,
the white image.

00:13:54.010 --> 00:13:59.180
Okay, so the actual drawing happens
in this mousetrap method here.

00:14:01.570 --> 00:14:08.640
So we take the values from the UI,
in this case we take the brush

00:14:08.640 --> 00:14:12.570
size from the slider and set
that to our brush filter.

00:14:12.690 --> 00:14:17.800
We allocate a color, again from the UI,
and set that on the brush filter.

00:14:17.950 --> 00:14:21.580
And last but not least,
we set the brush filter center to the

00:14:21.640 --> 00:14:24.430
XY coordinate that we get from the mouse.

00:14:26.060 --> 00:14:28.540
And then there's a bunch of
concatenation happening here.

00:14:28.560 --> 00:14:31.500
So first we take the output
image of the brush filter.

00:14:31.500 --> 00:14:36.960
So this is the DAP and set it as the
input image of the composite filter.

00:14:37.000 --> 00:14:39.400
And the second image that
goes into composite image,

00:14:39.450 --> 00:14:42.190
the background image,
is the state of the accumulator.

00:14:42.220 --> 00:14:45.240
So we take the state of the canvas,
we take the DAP,

00:14:45.240 --> 00:14:48.600
and the composite filter puts all
of these on top of each other.

00:14:48.640 --> 00:14:51.220
And at the very end,
that resulting image needs to

00:14:51.220 --> 00:14:52.500
go back into the accumulator.

00:14:52.500 --> 00:14:55.560
So this is this set image call here.

00:14:56.800 --> 00:15:03.660
Take the output image of the composite,
put it back in.

00:15:04.040 --> 00:15:04.820
And there's an interesting optimization
going on down here when we do

00:15:05.220 --> 00:15:07.230
This set image call is
actually in the super class,

00:15:07.280 --> 00:15:12.600
which I haven't showed here yet,
which essentially just draws a CI image.

00:15:12.610 --> 00:15:16.870
This guy actually passes a dirty rack,
so we only update the part that has

00:15:16.870 --> 00:15:20.230
changed by putting down the DAP,
so we are a bit more efficient

00:15:20.230 --> 00:15:23.080
in terms of updating the screen.

00:15:24.320 --> 00:15:30.500
Okay, so let me point out something
here in this little example.

00:15:30.730 --> 00:15:33.300
One flaw of this is if you
move the mouse fast enough,

00:15:33.400 --> 00:15:37.140
you get individual dabs and
you don't get a connected line,

00:15:37.140 --> 00:15:38.840
what you probably would expect.

00:15:38.860 --> 00:15:44.710
And a bit later in this session,
there will be an example how to

00:15:44.710 --> 00:15:48.000
do a proper connected drawing.

00:15:49.680 --> 00:15:53.420
Another example I have is
the CI transition example.

00:15:53.460 --> 00:15:56.760
And this is essentially running
nine different transition

00:15:56.770 --> 00:15:58.680
effects at the same time.

00:15:59.200 --> 00:16:14.800
[Transcript missing]

00:16:15.460 --> 00:16:19.840
You can explore different types
of UI doing stuff like this.

00:16:19.840 --> 00:16:25.620
So the idea is if you have to put
a UI up to let the user select a

00:16:25.620 --> 00:16:28.910
different type of transition effect for,
say, I don't know,

00:16:28.910 --> 00:16:33.030
a presentation app perhaps,
one way to do it is have a little

00:16:33.040 --> 00:16:37.250
pop-up that lists wipe left,
wipe right, ripple, and so on.

00:16:37.260 --> 00:16:40.100
Or you can just show the user
by making little thumbnails of

00:16:40.140 --> 00:16:42.050
the actual transition going.

00:16:42.060 --> 00:16:44.080
So naturally it wouldn't
make them that big,

00:16:44.200 --> 00:16:46.370
but it makes a better demo,
so I did it that way.

00:16:46.400 --> 00:16:47.920
Okay.

00:16:49.810 --> 00:16:57.470
So, additional source code,
there is also a WebKit problem,

00:16:57.470 --> 00:16:57.470
a WebKit plugin.

00:16:57.710 --> 00:17:00.060
So, we have a new version
of Core Image available,

00:17:00.060 --> 00:17:03.980
which shows you how to put an image into
a web page and have filters on that one,

00:17:04.010 --> 00:17:09.350
so you can get that from the ADC website.

00:17:09.360 --> 00:17:13.340
And with that,
we're going to start with the actual...

00:17:14.250 --> 00:17:18.970
Ladies and gentlemen,
this is Frank Dupke, who will guide you

00:17:19.080 --> 00:17:20.980
through this exciting--

00:17:25.320 --> 00:17:28.640
Can we go back to slides?

00:17:28.650 --> 00:17:29.900
Thank you.

00:17:29.920 --> 00:17:30.980
Thanks all for coming.

00:17:30.980 --> 00:17:33.100
My name is Frank DÃ¶pke,
and I will show now

00:17:33.360 --> 00:17:36.770
the CI Annotation app,
which is our hands-on

00:17:36.770 --> 00:17:38.800
part of the session.

00:17:39.790 --> 00:17:41.650
So let me tell you what
we'll actually be looking at.

00:17:41.850 --> 00:17:45.060
The CI Notation app,
we looked at like satellite images,

00:17:45.060 --> 00:17:48.070
and they have, these days,
a little bit of a problem.

00:17:48.300 --> 00:17:51.620
They're really, really big,
and they offer lots of little details.

00:17:51.690 --> 00:17:58.780
So to show them, you either have to scale
them down to see everything,

00:17:58.780 --> 00:18:01.710
but then you don't see
the juicy details anymore,

00:18:01.710 --> 00:18:01.710
or if you blow it up,
then you kind of lose your track.

00:18:01.870 --> 00:18:05.110
So this is the one part that we
wanted to show in this application,

00:18:05.110 --> 00:18:06.660
how we can get around this.

00:18:06.670 --> 00:18:08.900
And the other part is also
that you want to put out like,

00:18:09.010 --> 00:18:11.070
you know,
you remember like on the old postcards,

00:18:11.150 --> 00:18:12.880
this was my hotel room where we stayed.

00:18:13.070 --> 00:18:15.730
You want to do some
markings on these images,

00:18:15.730 --> 00:18:18.300
so that's what we want
to do here as well.

00:18:18.340 --> 00:18:22.060
But we don't want to
touch the original image,

00:18:22.060 --> 00:18:27.170
so we will show actually how to
do stuff on top of these images.

00:18:27.170 --> 00:18:27.780
And with this,
I would like to go to the demo machine.

00:18:34.990 --> 00:18:37.230
Demo, hello.

00:18:37.350 --> 00:18:39.240
Thank you.

00:18:39.410 --> 00:18:45.200
Okay, so the image that we will be
looking at is actually an image from

00:18:45.710 --> 00:18:47.600
Washington, DC.

00:18:47.640 --> 00:18:50.720
So I hope that you all filled out
the security form that's under

00:18:50.720 --> 00:18:52.640
your seat for the department.

00:18:52.640 --> 00:18:53.940
OK, we don't have to do that.

00:18:53.940 --> 00:18:55.390
Good.

00:19:03.070 --> 00:19:05.620
So this image will take a little
moment to load because it's

00:19:05.620 --> 00:19:08.500
like 10,000 by 5,000 pixels.

00:19:08.910 --> 00:19:12.500
So what we have here is
now our view of Washington,

00:19:12.500 --> 00:19:14.800
D.C., and we can color correct this.

00:19:14.800 --> 00:19:17.550
I would say this could
be a little bit brighter,

00:19:17.550 --> 00:19:19.230
a little bit darker.

00:19:19.300 --> 00:19:23.140
We can change the saturation,
make this a little bit more nicer green.

00:19:23.140 --> 00:19:25.750
It looks a little bit juicier this way.

00:19:26.410 --> 00:19:27.890
So now I can look at this image.

00:19:27.890 --> 00:19:29.500
I can actually scroll it around.

00:19:29.500 --> 00:19:31.180
This is also a nice part that we have.

00:19:31.380 --> 00:19:33.910
So I have a good overview of everything.

00:19:34.630 --> 00:19:37.240
Then you see in the middle,
we have this big, big circle.

00:19:37.240 --> 00:19:39.340
And this is actually our lens
in which we now can actually

00:19:39.340 --> 00:19:40.780
look at the more detailed part.

00:19:40.780 --> 00:19:43.520
As you can see, I can move this around.

00:19:43.530 --> 00:19:45.060
And see, oh, what's going on there?

00:19:45.060 --> 00:19:46.740
Okay, there's like a big traffic jam.

00:19:46.740 --> 00:19:48.900
This is like one of the things.

00:19:48.900 --> 00:19:51.680
Now I can use my marker here and say,
whoa, this is

00:19:51.910 --> 00:19:54.360
There we have a big kind of traffic jam.

00:19:54.360 --> 00:19:57.620
We can also put some text on top of this.

00:19:59.930 --> 00:20:02.800
Okay,
what else do we see in this image here?

00:20:02.800 --> 00:20:06.500
Let me finish up the text.

00:20:06.700 --> 00:20:12.400
Aha, there's something down here,
so let's see.

00:20:13.760 --> 00:20:15.460
A little pointy thingy here.

00:20:15.540 --> 00:20:16.560
Anybody knows what that is?

00:20:17.730 --> 00:20:20.090
Very good.

00:20:21.250 --> 00:20:23.440
Okay,
then we can look a little bit further.

00:20:23.440 --> 00:20:26.190
Then we have this building here.

00:20:26.210 --> 00:20:28.160
There's a very famous garden around it.

00:20:28.230 --> 00:20:30.190
So what is that, of course?

00:20:30.280 --> 00:20:33.290
That is, of course, Busch Gardens.

00:20:37.980 --> 00:20:40.230
So let's have a look at
this incredible rooftop.

00:20:40.240 --> 00:20:40.980
It's very smooth.

00:20:40.980 --> 00:20:43.780
I wonder how that happened.

00:20:44.770 --> 00:20:46.660
So you can see,
that's like the nice part,

00:20:46.660 --> 00:20:50.140
you can see all the juicy little details,
but we still have a good overview of

00:20:50.140 --> 00:20:52.120
at least this section of Washington.

00:20:52.560 --> 00:20:55.850
Now I said that I can also do
this without actually really

00:20:55.850 --> 00:20:59.790
destroying the original image,
and for that part, actually we can peel

00:20:59.880 --> 00:21:01.480
this whole thing off.

00:21:02.940 --> 00:21:05.350
And you see actually there's a
little bug that I've done here.

00:21:05.450 --> 00:21:07.640
So it's like the whole image
turns a little bit gray.

00:21:07.640 --> 00:21:10.440
So this is not because I didn't
sacrifice a sheep to the demo gods.

00:21:10.440 --> 00:21:14.890
There's actually a bug in the code,
which I'll show how to fix that later.

00:21:15.590 --> 00:21:17.770
So this is what this application can do.

00:21:17.820 --> 00:21:22.410
And now let's have a look into the code,
what we actually did here.

00:21:22.770 --> 00:21:25.900
And this is all available
on the WWC website.

00:21:26.160 --> 00:21:29.670
You should also have all
access to the source code.

00:21:30.220 --> 00:21:33.490
And let me go first to the
slides to explain a little bit

00:21:33.520 --> 00:21:37.120
how this whole thing looks like.

00:21:37.120 --> 00:21:39.230
So we have, can we go back to slides?

00:21:39.490 --> 00:21:40.910
Thank you.

00:21:40.910 --> 00:21:40.910
Okay.

00:21:42.520 --> 00:21:44.160
So we have our application.

00:21:44.160 --> 00:21:47.020
It has a single document
Cocoa application.

00:21:47.180 --> 00:21:51.280
We have a controller, some documents,
and we have a view that just

00:21:51.280 --> 00:21:53.250
handles our mouse handling part.

00:21:53.260 --> 00:21:55.490
And then as I showed already,
there is some stuff like

00:21:55.550 --> 00:21:56.940
stacked on top of each other.

00:21:56.940 --> 00:21:59.940
So we work with layers,
and these layers have a CI layer,

00:21:59.940 --> 00:22:01.980
which is our abstract base class.

00:22:01.980 --> 00:22:03.780
We have one layer for the painting part.

00:22:03.780 --> 00:22:04.940
That was my red marker.

00:22:04.940 --> 00:22:06.550
We have one for the text.

00:22:06.550 --> 00:22:09.180
Well, I could write stupid
comments onto the image.

00:22:09.650 --> 00:22:12.990
And then we have the actual image layer
in which we really handle the real image.

00:22:13.040 --> 00:22:17.180
Then you also find some utility
functions in the sample code.

00:22:17.180 --> 00:22:19.590
And there's especially
interesting the part,

00:22:19.590 --> 00:22:21.430
the sample-CL scroll view.

00:22:21.510 --> 00:22:24.260
For those who have looked
at our original sample code,

00:22:24.350 --> 00:22:26.940
I want to show you what
the difference is there.

00:22:29.670 --> 00:22:33.440
When we look a little bit closer,
you saw that I was able to scroll.

00:22:33.440 --> 00:22:36.630
For those who played around
with original sets of sample

00:22:36.630 --> 00:22:39.960
code that is on the Tiger disk,
it was always the question, OK,

00:22:39.960 --> 00:22:40.620
we have this.

00:22:40.620 --> 00:22:45.550
This is an OpenGL view,
but how can I do scrolling

00:22:45.550 --> 00:22:48.210
when I have a bigger image?

00:22:48.430 --> 00:22:49.330
And this is exactly what we've done here.

00:22:49.330 --> 00:22:49.330
I will show you in the code what
actually made this view scroll.

00:22:49.390 --> 00:22:52.800
Then you see actually that we've done
some text editing on top of the OpenGL,

00:22:52.800 --> 00:22:55.260
so for that I don't want to
go into too many details here

00:22:55.260 --> 00:22:57.290
as we're not a Cocoa session,
really.

00:22:57.560 --> 00:23:01.580
There's just some child window that we
had to put on top to do the text editing,

00:23:01.580 --> 00:23:03.300
for those who are curious.

00:23:03.300 --> 00:23:06.070
Then we look at how we did
the image import and export,

00:23:06.140 --> 00:23:10.300
because we can actually save the image,
I will show that in a moment as well.

00:23:10.300 --> 00:23:13.870
And then we look a little bit
further into the compositing part.

00:23:16.180 --> 00:23:20.040
As I mentioned already, there's something
special about this view.

00:23:20.040 --> 00:23:23.160
So far we already kind of
propagated the sample CI view.

00:23:23.160 --> 00:23:26.040
And you saw that, for instance,
in the transition

00:23:26.040 --> 00:23:27.680
sample that Ralf showed.

00:23:27.680 --> 00:23:30.280
It is very easy for you to use,
so you don't have to deal with

00:23:30.280 --> 00:23:32.570
the OpenGL underpinnings of it.

00:23:32.580 --> 00:23:36.080
And it supports that you can
just do a selective drawing.

00:23:36.080 --> 00:23:38.760
And that helps you actually
quite a bit on this part.

00:23:38.760 --> 00:23:41.510
Now if you look at the
sample CI scroll view,

00:23:41.520 --> 00:23:44.870
it has the same bells and
whistles as the sample CI view,

00:23:44.870 --> 00:23:46.460
but it allows you scrolling.

00:23:46.460 --> 00:23:50.420
And we do this by actually setting
the autographic projection matrix of

00:23:50.420 --> 00:23:52.670
OpenGL to really move your view around.

00:23:52.680 --> 00:23:56.730
So this is one of the things that
we will be looking at into the code.

00:23:57.960 --> 00:24:00.240
And then we look at the compositing part.

00:24:00.290 --> 00:24:02.980
So I again use the
CI source over compositing,

00:24:02.980 --> 00:24:07.020
which helps me to put this different
stuff on top of each other.

00:24:07.080 --> 00:24:09.420
And this is important to use
this rather than just drawing

00:24:09.420 --> 00:24:12.340
the images on top of each other,
because as Ralph mentioned,

00:24:12.360 --> 00:24:15.280
it gives you the chance that
these filters actually can

00:24:15.280 --> 00:24:19.560
collapse into one pipeline and
therefore be faster executed.

00:24:19.590 --> 00:24:21.610
And the other part is where we
go a little bit more creative.

00:24:21.700 --> 00:24:24.510
You saw that I used the transition,
actually the peel-off transition

00:24:24.910 --> 00:24:26.140
to do also compositing.

00:24:26.140 --> 00:24:30.140
So this is just a little bit different
way of doing some compositing,

00:24:30.140 --> 00:24:32.390
giving some spice to it.

00:24:33.780 --> 00:24:37.190
The layers that we want to look at
actually is the real interesting part.

00:24:37.270 --> 00:24:41.100
So we have a paint layer where
we again use the annotation part.

00:24:41.100 --> 00:24:43.160
And I will show you a little
bit difference with the filter.

00:24:43.160 --> 00:24:47.470
Then I'll show you actually that we
scaled down the image and we applied

00:24:47.470 --> 00:24:49.090
a filter that again scaled it up.

00:24:49.190 --> 00:24:51.280
This is the next important thing.

00:24:51.290 --> 00:24:53.460
And then we look in last but
not least at the document.

00:24:53.460 --> 00:24:55.220
This is actually what
brings everything together,

00:24:55.220 --> 00:24:56.800
brings it onto the screen.

00:24:56.800 --> 00:25:00.350
And it actually does also like the
output when we save out the file.

00:25:02.080 --> 00:25:05.500
And with this, I would like to go back
to the demo machine.

00:25:09.630 --> 00:25:12.230
Okay, so as promised,
we look now at some code stuff.

00:25:12.300 --> 00:25:16.440
So the CI layer, that is our first part.

00:25:16.440 --> 00:25:18.180
This is just as I said
the abstract base class.

00:25:18.180 --> 00:25:20.240
We init, it was a delegate.

00:25:20.240 --> 00:25:23.490
The delegate is actually our document,
which gives us the chance that we

00:25:23.490 --> 00:25:26.460
can really talk back to the document,
making it redraw.

00:25:26.460 --> 00:25:28.640
It does the mouse handling.

00:25:28.640 --> 00:25:30.040
It returns an image.

00:25:30.040 --> 00:25:31.940
So this is like the result of our layer.

00:25:31.940 --> 00:25:34.990
And it has a rectangle,
which gives us the size.

00:25:35.000 --> 00:25:36.870
This is kind of the part
that we wanted to look at.

00:25:39.240 --> 00:25:42.100
Okay, then let's have a look
into the text layers,

00:25:42.100 --> 00:25:43.990
our first real layer here.

00:25:45.520 --> 00:25:47.960
So how do I do the text rendering?

00:25:48.050 --> 00:25:52.430
The interesting part first
is if we create a text layer,

00:25:53.180 --> 00:25:57.780
I have two ways of this,
and this is like for the demo purposes.

00:25:57.810 --> 00:26:00.190
To render text,
we need some kind of a CG context.

00:26:00.260 --> 00:26:02.580
We use CG for the actual text drawing.

00:26:02.910 --> 00:26:07.940
I can do this by either using a CG layer,
which gives us an advantage

00:26:08.020 --> 00:26:10.980
because I can use the CG layer
coming from the CI context.

00:26:10.980 --> 00:26:12.640
It has the proper color
space attached to it,

00:26:12.710 --> 00:26:15.540
and therefore is faster with the
rendering as we don't have to do

00:26:15.540 --> 00:26:17.740
any color transformations there.

00:26:17.740 --> 00:26:20.330
But if you have already lots
of like rendering in your code,

00:26:20.330 --> 00:26:22.700
and you don't always have
access to the CI view,

00:26:22.700 --> 00:26:26.190
you can also create a bitmap context,
and this is what I'm doing

00:26:26.190 --> 00:26:28.550
here in the second part.

00:26:28.950 --> 00:26:31.230
That allows me, again,
I create a CG bitmap context,

00:26:31.270 --> 00:26:34.180
and I will then transform
that into a CI image later on.

00:26:34.210 --> 00:26:37.000
So I can render into this
bitmap context for those who

00:26:37.000 --> 00:26:38.840
are familiar with CG drawing.

00:26:39.770 --> 00:26:40.200
OK.

00:26:40.200 --> 00:26:42.200
Then when we look into
the real rendering part,

00:26:42.200 --> 00:26:45.540
there is again the same
piece that we have here.

00:26:45.620 --> 00:26:48.470
So right now I actually
can use the CI layer part,

00:26:48.480 --> 00:26:50.980
which makes the code much, much easier.

00:26:51.040 --> 00:26:54.060
After I've drawn my text,
which is actually happening here,

00:26:54.140 --> 00:26:57.960
all the little text objects
draw themselves into this layer.

00:26:58.010 --> 00:27:00.630
And all what I have to do is
I create a CI image out of it.

00:27:00.660 --> 00:27:04.460
And that is the one that I want to
return then as the result of this layer.

00:27:04.550 --> 00:27:08.500
If I'm working with a bitmap context,
then it's slightly more complicated.

00:27:08.510 --> 00:27:12.450
As I first have to create a CG image
from this bitmap context and then

00:27:12.450 --> 00:27:14.700
a CI image out of this again.

00:27:15.710 --> 00:27:19.180
So this is how text
draws in our application.

00:27:19.220 --> 00:27:22.250
Now we have a look at how painting works.

00:27:23.030 --> 00:27:24.610
Let me show you what filters are.

00:27:24.760 --> 00:27:27.190
You saw already we used an accumulator.

00:27:27.290 --> 00:27:29.490
We have a brush filter.

00:27:29.720 --> 00:27:32.430
and a composite filter,
those are the main pieces that

00:27:32.430 --> 00:27:34.100
bring everything together.

00:27:34.150 --> 00:27:37.140
I used a static CI color here
and also the static brush size,

00:27:37.140 --> 00:27:39.960
feel free to play around with it,
it just makes the code a

00:27:40.040 --> 00:27:41.600
little bit easier for me.

00:27:41.600 --> 00:27:45.590
So how did we do it again?

00:27:45.600 --> 00:27:49.110
We set up a bunch of stuff
in our initialization.

00:27:50.530 --> 00:27:55.200
So as I said,
we have fixed color and fixed brush size.

00:27:55.230 --> 00:27:57.660
Now the brush filter,
you see there's a paint filter.

00:27:57.700 --> 00:27:59.770
This is actually an
Image Unit that I'm loading.

00:27:59.880 --> 00:28:01.940
This is a special filter that we set up.

00:28:01.970 --> 00:28:05.400
And we will show a little bit
later how this filter really works.

00:28:05.420 --> 00:28:09.190
Then again, I set up my composite
filter and my accumulator,

00:28:09.300 --> 00:28:12.060
clean my accumulator,
and I'm ready to draw.

00:28:12.110 --> 00:28:13.300
And then it's very much the same thing.

00:28:13.300 --> 00:28:16.510
When we look into our
mouse down handling,

00:28:18.250 --> 00:28:21.670
I just, the only difference here is like
in comparison to the paint part,

00:28:21.700 --> 00:28:25.030
I'm not just getting one point,
I'm remembering the last coordinate

00:28:25.030 --> 00:28:28.260
from the mouse and just a new one,
and therefore just can

00:28:28.260 --> 00:28:30.350
draw basically a line,
so which gives me a

00:28:30.390 --> 00:28:31.840
continuous brush stroke.

00:28:31.840 --> 00:28:35.620
That's why I have to actually set
two values on the brush filter,

00:28:35.630 --> 00:28:40.570
it's like for my last point,
and the new point, and then just add this

00:28:40.570 --> 00:28:44.480
together into my accumulator,
and then I'm just telling the

00:28:44.480 --> 00:28:47.140
document something has changed,
please redraw.

00:28:48.330 --> 00:28:50.510
So that's the painting part.

00:28:52.330 --> 00:28:55.700
Now let's have a look
at what the image does.

00:28:55.820 --> 00:28:58.900
On the image layer, as I said,
we need to scale it down.

00:28:58.900 --> 00:29:01.800
We have this big, big image,
and we want to scale that down

00:29:01.860 --> 00:29:03.540
so that we have a scale filter.

00:29:03.610 --> 00:29:08.570
Then you saw the lens,
which was our little

00:29:08.570 --> 00:29:11.780
magnifier that we had on top.

00:29:11.780 --> 00:29:11.780
And you saw that I did
some color corrections.

00:29:11.780 --> 00:29:11.780
That is actually the color filter.

00:29:12.860 --> 00:29:16.540
And we have the resulting image,
so I'm having this as here as well.

00:29:16.560 --> 00:29:19.900
Okay, so how does this code look like?

00:29:20.120 --> 00:29:24.700
Again, going into the initialization.

00:29:27.330 --> 00:29:32.860
The CI Color Controls is
your absolute standard for

00:29:33.030 --> 00:29:35.000
Setting up the color values on this.

00:29:35.010 --> 00:29:37.110
And then I use the CI Affine Transform.

00:29:37.120 --> 00:29:40.000
This is actually where I scale the image.

00:29:40.020 --> 00:29:43.210
The important part is actually that
I apply the Affine Transform after

00:29:43.210 --> 00:29:46.400
the color controls and right
before I use my next filter,

00:29:46.400 --> 00:29:48.390
which is the Lens filter.

00:29:48.530 --> 00:29:50.760
You can actually see from the name again,
this is not a standard filter.

00:29:50.760 --> 00:29:53.880
This is again an Image Unit that
we provided and we'll show

00:29:53.880 --> 00:29:56.350
later on how that will work.

00:29:58.170 --> 00:30:00.440
And I just have to set up my lens field.

00:30:00.440 --> 00:30:02.460
And you see,
I'm not setting every single parameter.

00:30:02.460 --> 00:30:04.930
The lens field actually has a few
different parameters that I can set,

00:30:04.980 --> 00:30:07.780
and Mark Zimmer will talk
about this in a moment.

00:30:07.830 --> 00:30:09.680
So, but I'm not setting
everyone specifically,

00:30:09.680 --> 00:30:12.100
so it's a good idea in that
moment to call setDefaults,

00:30:12.100 --> 00:30:15.340
so that the filter is
initialized with good values.

00:30:15.340 --> 00:30:19.410
So, unless you set every
parameter of your filter,

00:30:19.420 --> 00:30:21.260
please call setDefaults.

00:30:21.940 --> 00:30:24.420
Here I'm now after that
setting the sum parameters of

00:30:24.480 --> 00:30:27.640
this filter and making sure,
okay, how big is really my image

00:30:27.660 --> 00:30:30.330
that I want to bring up,
and that's actually the

00:30:30.330 --> 00:30:31.690
size of my document.

00:30:34.980 --> 00:30:37.790
So, and again,
when we come into the mouse down part,

00:30:37.790 --> 00:30:42.290
all I have to do here is
that I actually find out,

00:30:42.290 --> 00:30:49.040
like, where was the old lens,
and now I move it with the

00:30:49.040 --> 00:30:51.850
mouse to a different position,
calculate the unified rectangle from it,

00:30:51.850 --> 00:30:51.850
and then I can let the
layer redraw with this part.

00:30:53.270 --> 00:30:57.610
So that is all we needed
to do for our filter.

00:30:57.620 --> 00:31:00.190
And now we can look
into the document part.

00:31:00.300 --> 00:31:05.160
This is a little small.

00:31:09.030 --> 00:31:10.400
You can see my eyesight is really bad.

00:31:10.400 --> 00:31:12.000
I need a big font to read this stuff.

00:31:12.000 --> 00:31:16.960
Okay, so what I'm doing in the
setting up part is like I create

00:31:16.960 --> 00:31:18.000
a whole bunch of filters.

00:31:18.000 --> 00:31:24.000
So I create my layers,
which is first the background image.

00:31:24.000 --> 00:31:26.910
That actually tells me how
big my document will be.

00:31:27.030 --> 00:31:30.000
I create my text layer, my paint layer.

00:31:30.000 --> 00:31:33.000
And then I said I use
the page curl transition.

00:31:33.000 --> 00:31:35.990
This is for the peeling off part.

00:31:37.000 --> 00:31:40.000
I make sure, okay, that it's initialized.

00:31:40.000 --> 00:31:43.390
And I use actually like a
transfer the coordinates of

00:31:43.390 --> 00:31:45.000
my mouse later on to the time.

00:31:45.000 --> 00:31:46.900
Normally transitions,
you'd think in terms

00:31:46.900 --> 00:31:48.000
of time that passes by.

00:31:48.000 --> 00:31:52.890
So I have like my peel time,
but this is like just transferred

00:31:52.890 --> 00:31:54.690
from the mouse coordinates.

00:31:56.580 --> 00:31:59.100
So there's a whole bunch of
parameters that I have to set on this

00:31:59.100 --> 00:32:02.060
filter to make this look correctly.

00:32:04.370 --> 00:32:07.610
And then I need a couple
of composite filters.

00:32:07.610 --> 00:32:11.160
And the first one is there to
actually composite my painting

00:32:11.200 --> 00:32:14.450
together with the text,
so that I have one image

00:32:14.450 --> 00:32:16.260
layer coming out of that.

00:32:16.270 --> 00:32:19.060
As that goes on one side of my filter.

00:32:19.060 --> 00:32:22.430
And then we have a second part,
and that's actually a little

00:32:22.430 --> 00:32:24.000
bit also where my bug sits.

00:32:24.040 --> 00:32:26.340
We have this parchment backing image.

00:32:26.380 --> 00:32:30.430
My idea was if I peel off
this transparent layer,

00:32:30.430 --> 00:32:32.670
which just had the text,
it looked a little bit

00:32:32.670 --> 00:32:33.640
goofy if there was nothing.

00:32:33.640 --> 00:32:36.880
So the idea was that on the
back side we have a slightly

00:32:37.390 --> 00:32:39.420
transparent image that I want to use.

00:32:39.440 --> 00:32:42.500
And that's actually where
my little problem was,

00:32:42.500 --> 00:32:44.470
that I forgot to do one thing.

00:32:44.490 --> 00:32:49.620
So I'm actually using here a
color generator as my filter.

00:32:49.620 --> 00:32:53.430
And when I do that,
that basically has an infinite extent.

00:32:53.510 --> 00:32:55.540
So this image is huge.

00:32:55.540 --> 00:32:58.800
And that is causing our little
problem in the part where we

00:32:58.810 --> 00:33:00.680
actually now want to correct.

00:33:00.680 --> 00:33:02.980
And actually,
since I don't have to type so much,

00:33:02.980 --> 00:33:04.580
I prepared this a little bit

00:33:06.510 --> 00:33:10.080
So we will crop the image,
and therefore make sure that it

00:33:10.080 --> 00:33:13.600
has the same size actually as
the front side of our transition.

00:33:13.640 --> 00:33:15.400
So let me actually try to fix this here.

00:33:15.400 --> 00:33:18.960
So bear with me and hope that our
demo gods are with us this time.

00:33:21.800 --> 00:33:27.880
So I insert a crop filter, set it to be,
so the input of this filter is

00:33:27.880 --> 00:33:30.500
again the output of my color filter.

00:33:31.430 --> 00:33:37.370
Then I set the size of the crop filter
to be the rectangle of my document.

00:33:38.050 --> 00:33:41.840
And all I have to do now is actually,
instead of the output

00:33:41.840 --> 00:33:45.870
of the color filter,
we use the output of my crop filter.

00:33:47.330 --> 00:33:48.800
That should fix my problem.

00:33:48.800 --> 00:33:50.330
Let's have a look quickly
at the application,

00:33:50.340 --> 00:33:53.850
if it does know what
I'm expecting it to do.

00:34:04.500 --> 00:34:06.240
"Anytime, there we go.

00:34:06.400 --> 00:34:13.800
Load our image.

00:34:14.750 --> 00:34:18.300
This is what our image is about.

00:34:18.300 --> 00:34:21.080
And now you can see the
peels off much nicer.

00:34:21.080 --> 00:34:24.060
Debugging right in front of your eyes.

00:34:24.060 --> 00:34:27.980
Thank you."

00:34:31.980 --> 00:34:34.400
So that was the first part that we
wanted to look at in the document.

00:34:34.400 --> 00:34:37.680
Now, how does the document actually
put everything together?

00:34:37.840 --> 00:34:40.840
And for that part,
we actually have to look at

00:34:40.840 --> 00:34:43.090
how we create our output image.

00:34:46.400 --> 00:34:48.560
So as I said,
I'm putting together the text and

00:34:48.560 --> 00:34:50.290
the paint layers into one image.

00:34:50.310 --> 00:34:53.080
So for that, I use a composite filter.

00:34:53.780 --> 00:34:55.460
And what I've done
here to a special case,

00:34:55.460 --> 00:34:57.350
like when I'm doing all
the interaction with it,

00:34:57.390 --> 00:34:59.380
I actually don't use the peel-off filter.

00:34:59.380 --> 00:35:02.330
So I have the special case
if there's no peeling off,

00:35:02.330 --> 00:35:04.050
then I just skip that part.

00:35:04.080 --> 00:35:06.610
Otherwise,
and it's the more interesting part,

00:35:06.610 --> 00:35:09.200
so I'm using actually then
the output of the layers,

00:35:09.260 --> 00:35:12.020
put those as the input
images of my peel-off filter,

00:35:12.020 --> 00:35:14.180
together with the backing image of it.

00:35:14.240 --> 00:35:18.960
And as a result, I use the output of the
peel-off filter right here.

00:35:18.960 --> 00:35:21.140
That is the image that I really
want to bring on screen.

00:35:21.870 --> 00:35:24.890
And this is again where we just
use the set image part on the,

00:35:24.890 --> 00:35:28.900
well, our little subclass
of the CI sample view.

00:35:28.900 --> 00:35:31.840
And that is the next part that
we can just have a look at.

00:35:31.900 --> 00:35:33.050
And that is the next part that
we can just have a look at.

00:35:41.310 --> 00:35:45.920
So the interesting part here is again,
this is our sample CI scrollable view,

00:35:45.920 --> 00:35:47.960
which is very,
very similar to the original one.

00:35:47.960 --> 00:35:49.360
You do a set image on it.

00:35:49.400 --> 00:35:52.520
The only difference is if you
look at it and compare those,

00:35:52.520 --> 00:35:54.390
it's in the update matrices.

00:35:54.520 --> 00:35:59.440
So here what we actually do is we look
at the mapped rectangle that you get

00:35:59.440 --> 00:36:01.660
from the enclosing scrollable view.

00:36:01.710 --> 00:36:06.500
And we set up the viewport and
the glAuto for this to actually

00:36:06.500 --> 00:36:08.100
map now to this moved rectangle.

00:36:08.180 --> 00:36:10.710
And that's how our drawing
is simply then mapped,

00:36:10.870 --> 00:36:13.000
and and therefore we can scroll.

00:36:14.760 --> 00:36:20.770
Okay, so the last part that we want to
look at here in the document again,

00:36:21.210 --> 00:36:23.800
Now we've done everything on screen.

00:36:23.850 --> 00:36:26.340
I can actually save this image
because this was also a question

00:36:26.340 --> 00:36:28.520
that came up very often.

00:36:28.710 --> 00:36:33.600
And to do that, actually,
all I have to do is I create a URL.

00:36:33.600 --> 00:36:36.680
So if somebody is telling me, okay,
I want to save it in this place.

00:36:36.680 --> 00:36:40.520
So I have a URL which tells me, like,
the destination of it.

00:36:40.580 --> 00:36:45.620
And now Image.io exposes a new
set of APIs in Tiger that we

00:36:45.620 --> 00:36:47.660
actually have available through CG.

00:36:47.660 --> 00:36:51.000
And what I'm creating is
actually an image destination.

00:36:51.000 --> 00:36:52.000
This is the part here.

00:36:52.000 --> 00:36:55.960
And I'm setting it up to be
public JPEG in this moment.

00:36:55.960 --> 00:36:58.380
I want to write on a JPEG file,
but there are many other file

00:36:58.380 --> 00:37:00.720
formats that you can use.

00:37:01.520 --> 00:37:04.400
So I have now my destination,
and the next part is,

00:37:04.400 --> 00:37:08.560
so I'm from my context,
I'm getting a CG image.

00:37:08.640 --> 00:37:12.240
So I simply ask CI, okay,
give me an output image in form of

00:37:12.240 --> 00:37:14.540
a CG that I get from your context.

00:37:14.540 --> 00:37:19.020
I add it to my destination,
and with finalized advice on the file,

00:37:19.020 --> 00:37:19.720
I'm done.

00:37:19.970 --> 00:37:21.500
That's all I have to do.

00:37:23.150 --> 00:37:25.530
And we can have a look at
this a little bit later.

00:37:25.760 --> 00:37:28.330
So, that is how I can save out the file.

00:37:28.340 --> 00:37:32.290
There's one more thing that
kind of bothered me a little

00:37:32.290 --> 00:37:33.680
bit in this application.

00:37:33.730 --> 00:37:37.780
When you saw the text actually did not
show that clearly on the satellite image.

00:37:37.810 --> 00:37:42.450
So, let's actually have another look in
what we can do with the text part.

00:37:42.580 --> 00:37:45.560
So, let me bring up my text layer.

00:37:45.560 --> 00:37:51.790
And my little notes.

00:37:54.420 --> 00:37:59.610
So what I wanted to do for the text layer
is actually that I need a few things.

00:38:00.460 --> 00:38:03.740
I wanted to actually make a
little glow behind the text.

00:38:04.160 --> 00:38:07.160
The way I actually tried that out
is I used our Funhaus application,

00:38:07.160 --> 00:38:10.040
which you also find on the TigerDisc,
so I can play around with the parameters.

00:38:10.040 --> 00:38:13.270
And I found that if I actually
put a white glow behind the text,

00:38:13.270 --> 00:38:16.170
then it better distinguishes
itself from the image.

00:38:16.240 --> 00:38:20.020
So what I did is actually I take
this black text that I'm writing,

00:38:20.020 --> 00:38:23.590
invert it, so I get a white text,
and then I'm blurring it out

00:38:23.590 --> 00:38:25.260
by using a Gaussian blur.

00:38:25.260 --> 00:38:28.310
And then I composite again
my black text on top of it.

00:38:28.880 --> 00:38:31.750
So I need three filters:
an invert filter, a blur filter,

00:38:31.750 --> 00:38:34.240
and last but not least, again,
I need to composite it.

00:38:34.300 --> 00:38:37.450
So we have three filters.

00:38:42.300 --> 00:38:50.800
[Transcript missing]

00:38:51.240 --> 00:38:53.210
So as I said, I'm doing an invert.

00:38:53.250 --> 00:38:55.340
That's my first part.

00:38:55.400 --> 00:38:57.600
I need a blur filter and
I use CI Gaussian Blur.

00:38:57.600 --> 00:39:00.010
And as I said,
I played around with the Funnels app

00:39:00.080 --> 00:39:04.040
to find out the other three is a good
radius for what I wanted to achieve.

00:39:04.150 --> 00:39:06.460
And I need a composite filter.

00:39:06.550 --> 00:39:13.860
So I put this into my initialization.

00:39:13.880 --> 00:39:15.990
Of course I want to save it.

00:39:23.450 --> 00:39:26.300
Just in the end of my layer,
I add these three filters.

00:39:26.320 --> 00:39:30.080
And of course, since I retain those,
remember to release those

00:39:30.080 --> 00:39:31.590
in the dialog part as well.

00:39:31.800 --> 00:39:35.040
Wanna be good citizens here.

00:39:35.750 --> 00:39:37.350
And now comes the part in the rendering.

00:39:37.350 --> 00:39:38.360
We need to change this.

00:39:38.360 --> 00:39:43.000
So what I'm doing is in
the rendering of the text,

00:39:43.000 --> 00:39:44.900
let me scroll down here.

00:39:45.060 --> 00:39:48.620
As a result,
I normally just have this text image.

00:39:48.620 --> 00:39:52.620
Oh no, it gets really dark there.

00:39:52.620 --> 00:39:52.620
I actually put this...

00:39:53.390 --> 00:39:54.540
Lost the screen.

00:39:54.540 --> 00:39:56.600
Okay.

00:39:56.700 --> 00:39:58.020
Sorry about that.

00:39:58.050 --> 00:40:01.360
I just thought everybody
was getting dark here.

00:40:02.920 --> 00:40:06.190
Okay, so I put this text image
into my invert filter,

00:40:06.340 --> 00:40:08.500
this gives me the white text.

00:40:08.520 --> 00:40:14.390
I run my blur on it,
then I composite those two together.

00:40:14.440 --> 00:40:16.940
That's basically my effect.

00:40:18.440 --> 00:40:22.940
I'm putting that at the
end of my rendering part.

00:40:22.970 --> 00:40:25.310
And then last but not least,

00:40:25.750 --> 00:40:27.740
The function that
returns the layer image,

00:40:27.880 --> 00:40:31.080
instead of just returning the text image,
I need to return the result

00:40:31.080 --> 00:40:32.600
of our composite filter.

00:40:32.730 --> 00:40:34.810
So we need to change this.

00:40:39.200 --> 00:40:47.400
[Transcript missing]

00:40:57.680 --> 00:41:00.600
Looks much better, right?

00:41:00.600 --> 00:41:02.600
So that's how simple it
is to change something.

00:41:02.600 --> 00:41:03.600
Thank you.

00:41:06.000 --> 00:41:07.780
and I promise you this
application can save.

00:41:07.780 --> 00:41:12.390
It actually can print,
but that's so 20th century.

00:41:12.930 --> 00:41:17.110
So let me actually save this image out
and just put this here on the desktop.

00:41:17.140 --> 00:41:19.490
Always good to clutter the desktop.

00:41:22.960 --> 00:41:26.460
It opens it up in preview,
and there's our regular JPEG image.

00:41:26.470 --> 00:41:27.950
There we go.

00:41:31.700 --> 00:41:35.180
So now to go a little bit more
into the depths of the filters,

00:41:35.220 --> 00:41:38.540
I actually would like to bring
Mark Zimmer up on stage to talk about

00:41:38.960 --> 00:41:41.360
the Image Units that we have here.

00:41:41.360 --> 00:41:45.290
Thanks, Frank.

00:41:48.140 --> 00:41:51.340
Can we go to the slides?

00:41:51.340 --> 00:41:53.630
All right.

00:41:53.680 --> 00:41:57.440
Okay, so no matter what you
need in image processing,

00:41:57.500 --> 00:42:01.940
you may be able to take existing
Core Image filters and put them together,

00:42:01.940 --> 00:42:04.780
Image Units, put them together,
or you may be required to make new ones,

00:42:04.780 --> 00:42:08.310
as the two Image Units, in this case,
the one for painting that

00:42:08.310 --> 00:42:11.920
produces continuous strokes,
and the lens filter were

00:42:12.000 --> 00:42:15.360
produced as Image Units.

00:42:16.600 --> 00:42:18.840
Okay, in the Paint Image Unit,
the first thing is that

00:42:18.850 --> 00:42:22.940
when you saw micro paint,
we're employing CI Image Accumulator

00:42:22.950 --> 00:42:26.800
so that you can accumulate
the results of your painting.

00:42:28.610 --> 00:42:31.190
But the problem that we had is
that they weren't continuous.

00:42:31.270 --> 00:42:33.280
In fact,
in order to make them continuous,

00:42:33.280 --> 00:42:36.250
you have to do something special.

00:42:36.290 --> 00:42:38.130
Basically,
rendering a lozenge instead of a

00:42:38.130 --> 00:42:40.590
circle is a quick way to do that.

00:42:41.320 --> 00:42:43.100
So let's talk about how we do that.

00:42:43.100 --> 00:42:45.600
Well, instead of one point,
we input two points

00:42:45.600 --> 00:42:47.790
to make it continuous.

00:42:48.480 --> 00:42:51.490
Then,
what we do is we make sure that it has

00:42:51.490 --> 00:42:53.890
a given width and width on the end.

00:42:53.900 --> 00:42:56.340
We use circular end caps to ensure that.

00:42:56.410 --> 00:43:00.130
So we have a variable input
width that controls that.

00:43:01.200 --> 00:43:04.500
What we do to actually make this
work is we need to evaluate a

00:43:04.500 --> 00:43:08.170
composite distance function that
has a different value in the three

00:43:08.170 --> 00:43:10.370
different half spaces that you see.

00:43:12.780 --> 00:43:16.220
So we'll use a 2D dot product to
get the half spaces on either side,

00:43:16.230 --> 00:43:19.730
on the side of input point
one and input point two.

00:43:20.190 --> 00:43:23.000
And we'll use a Euclidean distance
in those half spaces to make

00:43:23.000 --> 00:43:25.410
the circular distance function.

00:43:25.580 --> 00:43:30.600
A 2D cross product is a simple
technique to get distance from a line.

00:43:30.600 --> 00:43:33.940
We'll employ that in the
space nearest the line.

00:43:34.750 --> 00:43:37.820
Once we have our distance function,
we just threshold it to

00:43:37.820 --> 00:43:40.490
make a lozenge alpha,
and then we apply color

00:43:40.490 --> 00:43:42.180
to it and we're done.

00:43:43.200 --> 00:43:52.500
[Transcript missing]

00:43:55.320 --> 00:44:00.340
Okay, so let's look first at the,
oh I hate when this happens.

00:44:00.440 --> 00:44:02.540
Let's look first at the paint filter.

00:44:02.540 --> 00:44:05.380
You can see we've got the two points,
a width and a color.

00:44:05.380 --> 00:44:08.280
Just really not a lot of details to this.

00:44:08.280 --> 00:44:12.030
Turns out it's pretty simple.

00:44:12.330 --> 00:44:17.010
When we're actually putting it together,
the main thing is all you need to

00:44:17.020 --> 00:44:20.200
do is just bring in the kernel like
you do in every other image unit.

00:44:20.200 --> 00:44:24.220
So if I had the CI demo image unit,
I could just take that and

00:44:24.230 --> 00:44:28.000
modify that to make this,
and all I really would be changing was

00:44:28.100 --> 00:44:31.520
paint.cikernel and paintfilter here.

00:44:32.420 --> 00:44:33.900
The custom attributes
are straightforward.

00:44:33.900 --> 00:44:36.790
Again, two points, a width, and a color.

00:44:36.830 --> 00:44:38.630
And here we're giving
them default values.

00:44:38.750 --> 00:44:49.000
So if you happen to bring this into
Core Image Funhouse or into Motion,

00:44:49.000 --> 00:44:49.000
you can actually see the parameters
with the appropriate values.

00:44:49.510 --> 00:44:51.710
Okay, now in output image,
there's only one trick.

00:44:51.710 --> 00:44:54.790
Because this is a generator,
it inputs no images.

00:44:54.790 --> 00:44:57.720
All you really do,
all you really need to know

00:44:57.720 --> 00:44:59.340
is the domain of definition.

00:44:59.340 --> 00:45:01.110
In other words,
the area that you're rendering.

00:45:01.110 --> 00:45:04.080
And to calculate the area
that you're rendering,

00:45:04.080 --> 00:45:07.750
all I really do is put a rectangle
around the two input points,

00:45:07.750 --> 00:45:09.380
outsize it by the radius.

00:45:09.380 --> 00:45:12.270
That's the opposite of insetting,
I suppose.

00:45:12.270 --> 00:45:16.150
And probably this section of code
could be rewritten to be like two

00:45:16.150 --> 00:45:19.060
lines of code with a CG rect inset,
sorry.

00:45:19.400 --> 00:45:26.030
And then I evaluate the vector
here so that I can end up doing

00:45:26.030 --> 00:45:29.270
dot products to calculate inside
or outside of the two half spaces.

00:45:29.280 --> 00:45:31.020
And I pass that in as v01.

00:45:31.420 --> 00:45:33.300
And then I call the kernel.

00:45:34.000 --> 00:45:36.980
Okay, so let's have a look
at the kernel itself.

00:45:37.250 --> 00:45:42.580
It's being passed 0.1, 0.2, the radius,
the vector for the dot products,

00:45:42.600 --> 00:45:43.720
and the color.

00:45:47.030 --> 00:45:48.650
The kernel is also quite simple.

00:45:48.700 --> 00:45:52.330
So, remember how I said to evaluate
a composite distance function?

00:45:52.470 --> 00:45:56.460
Well, what that means is you'll evaluate
three distance functions and then you'll

00:45:56.460 --> 00:45:58.730
composite them together using compares.

00:45:58.820 --> 00:46:01.010
So, why are we doing that?

00:46:01.110 --> 00:46:04.980
Because the kernel is evaluated
for every pixel in every working

00:46:04.980 --> 00:46:06.730
space pixel in the output.

00:46:06.910 --> 00:46:10.550
And so what that means is you have to
decide what's going to happen in that,

00:46:10.690 --> 00:46:13.000
evaluate all the possibilities,
and then select from them.

00:46:13.150 --> 00:46:15.690
That's how to get that information.

00:46:15.870 --> 00:46:18.510
The absolute value of the
Z of the cross product gives

00:46:18.510 --> 00:46:20.230
us the distance to the line.

00:46:20.390 --> 00:46:22.840
If I didn't do absolute value,
it would be positive on

00:46:22.840 --> 00:46:25.140
one side of the line,
negative on the other.

00:46:25.350 --> 00:46:29.320
The space closest to point
zero is evaluated here,

00:46:29.380 --> 00:46:32.660
and it also will take that distance
and decide whether or not the

00:46:32.660 --> 00:46:36.570
dot product is less than zero and
choose one distance over the other.

00:46:36.570 --> 00:46:39.670
So that gives you one
level of compositing,

00:46:39.670 --> 00:46:43.840
that gives you one half space
and the mid space of the line.

00:46:44.480 --> 00:46:48.620
And then we do the same with P1,
exactly the same kind of code.

00:46:49.130 --> 00:46:51.400
You'll notice that Dist 2
and Dist 1 are switched.

00:46:51.400 --> 00:46:56.290
That's because the dot products on either
half space point the opposite directions.

00:46:56.300 --> 00:47:01.940
And then, this is a trick that we pull
several times in this demo.

00:47:01.940 --> 00:47:06.470
Once I have a distance function,
I can subtract radius minus that

00:47:06.470 --> 00:47:09.460
distance function and clamp it to 0,
1.

00:47:09.480 --> 00:47:13.390
And what that'll do is it'll give
me a function that's between 0 at

00:47:13.390 --> 00:47:16.100
exactly radius and 1 at radius minus 1.

00:47:16.100 --> 00:47:18.390
And that gives me the anti-aliased edge.

00:47:19.100 --> 00:47:20.700
I'll multiply that by the color.

00:47:20.700 --> 00:47:23.740
Remember, we use pre-multiplied
color in Core Image.

00:47:23.740 --> 00:47:27.880
And that is the result that
we're returning for the paint.

00:47:27.880 --> 00:47:34.790
Okay, so now let's go back to the slides.

00:47:38.340 --> 00:47:40.840
Slides, please.

00:47:40.840 --> 00:47:42.700
Thank you.

00:47:42.710 --> 00:47:45.540
Okay, the Lens Image Unit was
a bit more complicated.

00:47:45.640 --> 00:47:48.100
With the Lens Image Unit,
we have to do various things.

00:47:48.140 --> 00:47:50.340
We have to magnify without blurring.

00:47:50.360 --> 00:47:54.380
We'll talk about how we
actually achieve that.

00:47:54.400 --> 00:47:56.560
I'm embedding it in a ring to
give it a little bit of weight

00:47:56.660 --> 00:47:58.710
so it looks like a real object.

00:47:58.720 --> 00:48:00.680
It needs a shine on it, too.

00:48:00.680 --> 00:48:03.590
There's other things that you
could do that would extend this

00:48:03.640 --> 00:48:05.100
and make it look more interesting.

00:48:05.100 --> 00:48:07.560
If you have an app that you need
to use something like this in,

00:48:07.560 --> 00:48:10.460
you may want to pull some of
these things out of the hat.

00:48:10.510 --> 00:48:13.640
Chromatic aberration is
something that you could do.

00:48:13.640 --> 00:48:18.270
These are exercises for you, the user.

00:48:18.540 --> 00:48:19.990
Reader.

00:48:20.190 --> 00:48:42.240
Watcher.

00:48:42.240 --> 00:48:42.240
Some distortion inside the magnifier.

00:48:42.240 --> 00:48:42.240
Yeah, there's,
whenever I use a magnifier,

00:48:42.240 --> 00:48:42.240
I notice there's some distortion,
especially near the edge.

00:48:42.240 --> 00:48:42.240
That's a trick that you
could make it do as well.

00:48:42.240 --> 00:48:42.240
You could put a caustic under the lens.

00:48:42.240 --> 00:48:42.240
That's just like you're trying
to magnify or burn those ants.

00:48:42.240 --> 00:48:42.240
Remember,
I used to do that when I was a kid.

00:48:42.240 --> 00:48:42.240
I was a bad boy.

00:48:42.700 --> 00:48:43.800
And there's other things you could do.

00:48:43.800 --> 00:48:46.800
Like you put a little shadow behind it,
too, with a Gaussian blur.

00:48:46.800 --> 00:48:53.090
You saw exactly how to do that,
only in reverse, with the text before.

00:48:53.480 --> 00:48:55.920
So now let's talk about the
details of how it really works.

00:48:56.000 --> 00:49:00.330
The first parameter is input image,
and no, it's not capitalized.

00:49:00.340 --> 00:49:02.670
Sorry about that.

00:49:03.810 --> 00:49:05.530
All right.

00:49:05.640 --> 00:49:10.500
So in order to magnify inside,
there's a trick that you have to play.

00:49:10.620 --> 00:49:13.780
The image, remember he told you it was
like 5,000 by 10,000 pixels?

00:49:13.780 --> 00:49:18.190
Well, what you do is you do use a view
transform using a CIFI transform

00:49:18.190 --> 00:49:20.280
to make it smaller on screen.

00:49:20.280 --> 00:49:26.660
And then what happens is I will
use a counteracting transform

00:49:26.660 --> 00:49:30.510
to zoom it back in so I can see
inside the lens at full resolution.

00:49:31.110 --> 00:49:34.450
Okay, so I'll use an additional
CI sampler with its own affine

00:49:34.450 --> 00:49:36.030
transform for the magnified data.

00:49:36.030 --> 00:49:37.910
That's the trick.

00:49:38.270 --> 00:49:40.680
So, adjust it to counteract
the view transform and get

00:49:40.680 --> 00:49:41.640
to the individual pixels.

00:49:41.640 --> 00:49:44.120
In other words,
if it's exactly the opposite scale,

00:49:44.280 --> 00:49:46.200
then you get one-to-one pixels on screen.

00:49:46.200 --> 00:49:48.880
Exactly the visual trick we want.

00:49:50.500 --> 00:49:55.600
[Transcript missing]

00:49:57.250 --> 00:49:59.290
To define the lens,
we're going to need input

00:49:59.290 --> 00:50:01.610
center and input width,
just two parameters that

00:50:01.610 --> 00:50:03.200
clearly just define a circle.

00:50:03.200 --> 00:50:07.500
That's the area in which
we do our magnification.

00:50:08.590 --> 00:50:12.520
What we do with this is we
overlay a shine with it using

00:50:12.530 --> 00:50:14.560
what we call a shine map.

00:50:14.620 --> 00:50:17.500
Shine map is basically
a map that's circular,

00:50:17.500 --> 00:50:20.980
that has alpha in it,
and the alpha will tell it the

00:50:21.060 --> 00:50:23.060
parts that are opaque and the
parts that are transparent,

00:50:23.060 --> 00:50:26.630
the parts that overlay 100%, and
the parts that only overlay a little

00:50:26.630 --> 00:50:28.330
bit to make it lighter or darker.

00:50:28.340 --> 00:50:30.660
And you can see there,
it does make the lens

00:50:30.660 --> 00:50:32.370
lighter and darker as well.

00:50:33.500 --> 00:50:36.810
And input roundness is used to
control how much of that gets

00:50:36.880 --> 00:50:40.690
loaded into the circle of the lens.

00:50:41.640 --> 00:50:46.300
Premultiplied alpha, of course,
is the rule for Core Image.

00:50:46.440 --> 00:50:48.300
Now,
when we're putting the lens on around it,

00:50:48.300 --> 00:50:51.840
it's a ring,
we actually have to render that ring,

00:50:51.970 --> 00:50:53.730
and we're going to fill it
with an environment map,

00:50:53.740 --> 00:50:58.900
in this case, a material,
which is the reflections of a globe.

00:50:59.880 --> 00:51:03.560
So I captured that with a digital camera,
and then I resized and blurred

00:51:03.560 --> 00:51:06.630
it so it was the right size
for use inside of Core Image.

00:51:06.640 --> 00:51:11.730
The right answer is to really use
a sharp map and then blur it inside

00:51:11.740 --> 00:51:14.860
using map width over fillet width,
using CI Gaussian blur.

00:51:15.060 --> 00:51:18.420
That would have been much better,
but I didn't want to

00:51:18.420 --> 00:51:20.400
waste the time to do that,
sorry.

00:51:20.660 --> 00:51:23.780
Okay, to create the ring is a
little bit challenging.

00:51:23.940 --> 00:51:34.990
So what I did with the ring is we have
an inside fillet and an outside fillet.

00:51:37.290 --> 00:51:40.570
Okay, so here we have the inside
fillet and the outside fillet.

00:51:40.580 --> 00:51:44.520
The outside fillet goes from outer radius
minus fillet radius to outer radius,

00:51:44.520 --> 00:51:44.880
etc.

00:51:44.880 --> 00:51:48.240
And what we want to do with this,
specifically,

00:51:48.270 --> 00:51:52.610
is to create a 2D normal vector
for every pixel on the ring.

00:51:52.640 --> 00:51:55.280
It's actually pretty easy to compute.

00:51:55.280 --> 00:51:58.860
Normally, it's easy to compute just
like the distance field.

00:51:58.860 --> 00:52:01.600
You subtract the center
from the current point,

00:52:01.600 --> 00:52:04.540
and then you normalize it
to give it a unit vector.

00:52:04.540 --> 00:52:06.890
Okay, but it typically points outwards.

00:52:07.200 --> 00:52:13.640
So what I'll do is I'll scale the normal
vector inward for the inner fillet.

00:52:13.640 --> 00:52:16.840
Interesting language there.

00:52:16.840 --> 00:52:18.880
In the ring interior,
the normal should be scaled to

00:52:18.880 --> 00:52:23.980
zero length so that you just
get the center pixel of the map.

00:52:24.470 --> 00:52:27.200
And here's the surface shape
function that I'm going to use.

00:52:27.220 --> 00:52:31.530
It goes from minus one on the inner
radius to zero in the middle of the ring,

00:52:31.550 --> 00:52:33.300
and then back up to one
in the outer radius.

00:52:33.380 --> 00:52:35.400
And that's,
I'm just going to multiply that

00:52:35.400 --> 00:52:38.570
normalized vector by this value,
and that will give me the appropriate

00:52:38.690 --> 00:52:41.830
two-dimensional normal vector
for every point on the ring.

00:52:44.200 --> 00:52:45.880
Okay.

00:52:46.310 --> 00:52:50.850
Now, the environment map is just a file,
just a texture.

00:52:50.850 --> 00:52:54.370
So it has a given height and width,
and what we want to do is we want

00:52:54.410 --> 00:52:58.200
to take the 2D normal vectors,
which always go from minus one, plus one,

00:52:58.270 --> 00:53:01.630
minus one, plus one in both axes,
to zero dot width to zero dot h.

00:53:01.630 --> 00:53:05.800
And so we end up doing a little
bit of scaling inside there,

00:53:05.800 --> 00:53:10.430
and you'll see when we get into
the program exactly what it does.

00:53:10.450 --> 00:53:14.200
We're going to need a
specific width for the ring.

00:53:16.880 --> 00:53:19.200
The fillet radius,
typically when you use it,

00:53:19.200 --> 00:53:23.040
is going to be half the ring width.

00:53:23.100 --> 00:53:24.830
The edges of the ring
have to be anti-alias,

00:53:24.910 --> 00:53:29.840
and we'll pull that same basic trick out
of our hat that we used for the paint.

00:53:29.910 --> 00:53:33.110
Okay, let's go back to the demo machine.

00:53:37.300 --> 00:53:39.360
Okay, so as you can see,
the Lens Image Unit is

00:53:39.360 --> 00:53:41.840
a bit more complicated.

00:53:41.880 --> 00:53:50.290
It has, it inputs,
it's the image that we're magnifying,

00:53:50.290 --> 00:53:50.290
the center of the lens,
the width of the lens,

00:53:50.450 --> 00:53:53.340
The width of the ring, etc., etc.

00:53:53.360 --> 00:54:02.180
And then we've got various things,
magnification, fillet radius of the ring,

00:54:02.180 --> 00:54:02.550
the roundness, and the shine opacity,
which allows to control the

00:54:02.550 --> 00:54:02.550
various elements of its appearance.

00:54:08.350 --> 00:54:11.210
Inside of here,
probably the only difference between

00:54:11.210 --> 00:54:14.790
this and an init procedure you'll
see in CI Demo Image Unit is the fact

00:54:14.790 --> 00:54:17.140
that we're bringing in images as well.

00:54:17.200 --> 00:54:20.910
And also the fact that our kernel,
we bring in two kernels instead of one.

00:54:20.970 --> 00:54:24.610
So this is an example of
a multi-pass Image Unit.

00:54:25.670 --> 00:54:28.240
So here we're just getting our path,
we're getting a URL,

00:54:28.240 --> 00:54:30.900
we're bringing in the ring material
image and the lens shine image,

00:54:30.900 --> 00:54:34.600
the two ancillary images that
are required by this filter.

00:54:34.600 --> 00:54:37.040
The custom attributes,
we have a lot of attributes,

00:54:37.100 --> 00:54:38.770
so I won't bore you with
the details of that.

00:54:38.870 --> 00:54:42.620
You can see you just need
to set up their parameters.

00:54:43.710 --> 00:54:47.600
For the lens,
you need a region of interest for this.

00:54:47.600 --> 00:54:51.780
We'll talk about that a little later,
but let's just comfort ourselves with

00:54:51.860 --> 00:54:55.600
the concept that we need to provide
the entire extent of the shine image

00:54:55.600 --> 00:54:59.790
because it's something that you never
know which pixel you're going to load,

00:54:59.790 --> 00:55:02.230
so this is a trick that
you end up playing.

00:55:02.480 --> 00:55:06.320
And then the area of the original
image that we use inside the magnifier,

00:55:06.320 --> 00:55:09.070
really all you have to do
is subtract off the center,

00:55:09.080 --> 00:55:12.340
multiply it by the magnification,
and then create a rectangle

00:55:12.410 --> 00:55:15.420
based on the width of the lens,
and you have the area of the

00:55:15.420 --> 00:55:17.470
original image that gets used.

00:55:17.500 --> 00:55:21.740
So the region of interest really is
the amount of the sampler that you're

00:55:21.740 --> 00:55:24.200
using in order to render your result.

00:55:27.210 --> 00:55:31.140
Okay, there's also an ROI for the ring,
which is only provided

00:55:31.140 --> 00:55:36.400
because the material map with
the Chrome needs an extent.

00:55:36.430 --> 00:55:39.670
It needs to know the entire
extent of the material map.

00:55:40.440 --> 00:55:43.270
Okay, sort of the complex part,
Output Image,

00:55:43.300 --> 00:55:46.710
is the way you define how the filters
and the kernels get strung together

00:55:47.050 --> 00:55:49.140
in order to produce your image result.

00:55:49.290 --> 00:55:51.370
And in this case here,

00:55:51.650 --> 00:55:54.510
What we're going to do is we're
going to first set up that

00:55:54.600 --> 00:55:57.430
sampler that's the non-magnified,
first the source is the

00:55:57.430 --> 00:55:59.540
non-magnified sampler for the image.

00:55:59.560 --> 00:56:03.860
This is the image under
transform that was done outside.

00:56:04.150 --> 00:56:07.110
But because it's Core Image,
we can apply a transform to that

00:56:07.110 --> 00:56:10.590
and they'll cancel each other
out because of lazy evaluation.

00:56:10.590 --> 00:56:12.600
Remember, we're lazy bastards.

00:56:12.600 --> 00:56:14.700
We are.

00:56:15.300 --> 00:56:16.300
Okay.

00:56:16.650 --> 00:56:21.180
Seems like a lot of code though.

00:56:21.180 --> 00:56:21.180
Okay.

00:56:21.600 --> 00:56:24.260
"It's just the way I write code.

00:56:24.570 --> 00:56:26.500
Alright, so here's the magnified source.

00:56:26.500 --> 00:56:30.330
Again, all I did is create a,
I input the magnification float value,

00:56:30.330 --> 00:56:33.580
created a transform associated with it,
and all it does is

00:56:33.650 --> 00:56:36.590
translate to the center,
magnify, and translate back.

00:56:36.760 --> 00:56:40.500
It's really,
really no complexity to it at all.

00:56:40.830 --> 00:56:45.300
Then I create the source,
and it's ready to use.

00:56:45.800 --> 00:56:48.780
Now, you'll need to calculate a
rectangle for these effects

00:56:48.870 --> 00:56:52.360
because the domain of definition
is required for these at any rate.

00:56:52.550 --> 00:56:57.530
The lens actually is partly a distortion
effect and partly a generator.

00:56:57.560 --> 00:57:02.460
So that complicates matters slightly,
but not a huge amount.

00:57:02.620 --> 00:57:06.940
So all I have to do is calculate
a rectangle for the lens effect,

00:57:07.010 --> 00:57:12.770
and that rectangle ends up getting used
with the source definition as the domain

00:57:12.770 --> 00:57:12.890
of definition for the lensed image.

00:57:13.150 --> 00:57:16.020
So here the lens kernel is applied
with the various parameters.

00:57:16.020 --> 00:57:19.640
Now the ring is applied
as a separate item,

00:57:19.640 --> 00:57:23.120
and then I use our old friend CI source
over compositing to put them together.

00:57:23.120 --> 00:57:25.410
And here's where the ring is applied.

00:57:25.420 --> 00:57:27.640
So I'll get the material
map for the ring.

00:57:27.640 --> 00:57:31.750
I'll memorize the ring width,
which is used in calculating the

00:57:31.750 --> 00:57:33.860
domain of definition here for the ring.

00:57:33.860 --> 00:57:40.520
The domain of definition is passed in
here as part of the apply for the ring,

00:57:40.520 --> 00:57:42.000
and then the ring kernel is called.

00:57:42.350 --> 00:57:47.040
Now one thing that we're doing also
is if we have an ROI procedure,

00:57:47.040 --> 00:57:52.280
we have to assign an ROI selector
here before the kernel.

00:57:52.280 --> 00:57:57.550
And in fact, you pass the kernel in
to that to bind them.

00:57:57.580 --> 00:58:03.940
And then later we'll do in the apply,
we'll say apply option user info and

00:58:03.940 --> 00:58:05.840
then pass whatever object you want.

00:58:05.910 --> 00:58:07.500
This can be an array of other objects.

00:58:07.500 --> 00:58:10.630
Turns out it's important to do that
because you never know if your instance

00:58:10.630 --> 00:58:14.260
variables are really still going to
be around and set to the same values

00:58:14.640 --> 00:58:16.130
when the filter is actually evaluated.

00:58:17.760 --> 00:58:21.840
Okay, and that's why we passed the user,
the information for the

00:58:21.860 --> 00:58:23.910
ROI in with the user info.

00:58:24.070 --> 00:58:27.580
Okay, so there it applies the ring
kernel and we're pretty much done.

00:58:27.650 --> 00:58:33.370
All we need to do is have a look at the
kernels and you'll see what it's about.

00:58:33.460 --> 00:58:38.530
So, the lens kernel is the first thing.

00:58:38.580 --> 00:58:40.480
It's what does the magnification.

00:58:40.480 --> 00:58:40.480
It doesn't really have a lot to it.

00:58:41.140 --> 00:58:44.090
The destination coordinate here,
this is our current coordinate

00:58:44.090 --> 00:58:45.640
and working coordinates.

00:58:45.640 --> 00:58:48.330
We subtract the center, take length,
and normalize,

00:58:48.390 --> 00:58:52.400
which is our standard breakout
for calculating a distance

00:58:52.860 --> 00:58:54.850
field with a unit vector.

00:58:55.540 --> 00:59:01.220
Then, I do a little extra work to
decide how much of the map,

00:59:01.220 --> 00:59:04.540
in other words the shine map,
is going to get applied to this.

00:59:04.540 --> 00:59:07.040
And then I'll evaluate
the shine map pixel.

00:59:07.040 --> 00:59:13.150
Over here I take highlight size,
which is the width and height

00:59:13.210 --> 00:59:16.480
of the highlight shine map,
and multiply it by the unit

00:59:16.580 --> 00:59:22.330
vector times this map distance
here plus 1 divided by 2.

00:59:22.340 --> 00:59:26.820
And that's how you get from -1, +1, -1,
+1 to 0.

00:59:26.820 --> 00:59:28.010
. . width and 0.

00:59:28.010 --> 00:59:30.400
. . h of the map.

00:59:30.400 --> 00:59:33.250
So there's the trick that's used.

00:59:33.510 --> 00:59:37.560
Okay, then I get the two pixels,
the undistorted and the distorted pixels.

00:59:37.630 --> 00:59:40.460
Remember,
all the work for Magnify has been

00:59:40.460 --> 00:59:44.630
done by the sampler and using
the counteracting transform.

00:59:44.730 --> 00:59:47.840
Then I apply the highlight,
and this is very much like what you

00:59:47.840 --> 00:59:52.520
would do in CI Source over compositing,
but because I'm a lazy mm-hmm,

00:59:52.580 --> 00:59:55.090
I decided to do it here instead.

00:59:55.330 --> 00:59:57.840
And then I mix the results together.

00:59:57.840 --> 01:00:02.000
And here,
I'm creating the alpha for the lensed

01:00:02.070 --> 01:00:06.730
area by taking radius minus distance
once again and clamping it to 01.

01:00:06.740 --> 01:00:11.130
This is exactly the same trick
I used in the paint filter.

01:00:11.370 --> 01:00:12.540
All right.

01:00:12.660 --> 01:00:15.000
For the ring,
which is a bit more complicated,

01:00:15.000 --> 01:00:18.240
it seems like it's shorter,
it shouldn't be more complicated,

01:00:18.240 --> 01:00:18.900
but it is.

01:00:18.980 --> 01:00:21.430
We do the same thing with the
distance field at the beginning.

01:00:21.550 --> 01:00:27.680
So I create distance and V0.

01:00:27.680 --> 01:00:27.680
V0 normal vector, distance,
distance from the center.

01:00:27.920 --> 01:00:31.140
Then I create that function
for the surface shape lookup,

01:00:31.140 --> 01:00:37.270
and I evaluate some
linear functions here.

01:00:37.590 --> 01:00:41.600
And then I mix them together
using this comparison.

01:00:41.660 --> 01:00:44.940
And so that gives me the graph
that you were looking for,

01:00:45.040 --> 01:00:46.390
looking at before.

01:00:47.590 --> 01:00:50.350
Then I multiply the unit
vector by that number,

01:00:50.350 --> 01:00:56.260
and that gives me a two-dimensional
normal for lookup into the material map.

01:00:56.450 --> 01:00:59.950
Then I have to,
now I do a little digression to

01:01:00.050 --> 01:01:02.140
create the alpha for the ring.

01:01:02.140 --> 01:01:04.280
It uses the same basic
trick that we used before,

01:01:04.280 --> 01:01:07.200
except it's kind of one is
positive and the other is negative.

01:01:07.240 --> 01:01:11.560
Then I multiply them together and that
gives me the correct alpha for the ring.

01:01:12.230 --> 01:01:15.580
Finally,
I do the lookup into the material map.

01:01:15.810 --> 01:01:20.400
So here's the completely undistorted
view of how you take that normal

01:01:20.400 --> 01:01:22.720
and turn it into a material map,
lookup coordinate.

01:01:22.870 --> 01:01:25.280
And then you do the lookup here.

01:01:25.940 --> 01:01:29.740
Finally, we multiply the color of the
material map by the alpha,

01:01:29.740 --> 01:01:31.490
and that's it for the ring.

01:01:31.610 --> 01:01:35.520
That's all we have to do,
because we're pre-multiplied alpha.

01:01:35.790 --> 01:01:40.460
Okay, so now I'd like to turn
it back over to Ralph,

01:01:40.480 --> 01:01:42.700
and thanks very much.

01:01:52.700 --> 01:01:54.700
Okay, back to the slides please.

01:01:54.700 --> 01:02:03.300
Okay, so I'd like to encourage you again,
write Image Units.

01:02:03.300 --> 01:02:08.100
As Mark was explaining, it's really easy,
and if not, well, something to learn.

01:02:08.100 --> 01:02:16.780
If you're using Core Image,
consider being a host for Image Units.

01:02:16.780 --> 01:02:20.200
And there's actually a logo program,
so if there is a validation

01:02:20.270 --> 01:02:24.120
tool on the ADC website,
where you can run your

01:02:24.120 --> 01:02:25.730
Image Unit through,
and it will tell you whether it

01:02:25.740 --> 01:02:28.780
conforms to some reasonable standards.

01:02:28.780 --> 01:02:31.540
And if you conform to that,
then you can actually use this

01:02:31.540 --> 01:02:35.510
Image Unit logo on your packaging
and tell the world that you're a good

01:02:35.580 --> 01:02:38.390
citizen when it comes to Image Units.

01:02:40.900 --> 01:02:48.600
So with that,
I just use the rest of the time

01:02:48.600 --> 01:02:48.600
with a bunch of more demos because,
well, we have some time.

01:02:53.910 --> 01:02:58.140
Okay,
so the first demo I'd like to show is,

01:02:58.140 --> 01:03:01.880
remember the Image Unit that Mark did,
that essentially was

01:03:01.880 --> 01:03:03.510
a two-pass Image Unit?

01:03:03.540 --> 01:03:04.920
Demo machine, please.

01:03:04.920 --> 01:03:08.870
Okay.

01:03:16.210 --> 01:03:20.980
So this is Motion,
and Motion is a host for Image Units.

01:03:21.030 --> 01:03:30.170
So I took the Image Unit that Mark did
and put it into a little Motion project.

01:03:30.170 --> 01:03:30.170
So let me deselect.

01:03:31.840 --> 01:03:34.910
Looks like this,
and there is a lens zipping across.

01:03:34.950 --> 01:03:41.780
So this is,
there is no additional code once

01:03:41.780 --> 01:03:41.780
you have the image unit in there,
so you can actually go look at the lens.

01:03:43.370 --> 01:03:45.790
Here is the lens layer.

01:03:45.810 --> 01:03:48.420
You can inspect it, filters.

01:03:48.830 --> 01:03:52.480
So you see in motion you
have now the ring width,

01:03:52.490 --> 01:03:55.930
parameter, magnification, and so on.

01:03:55.960 --> 01:03:59.040
So everything that
Mark was talking about.

01:03:59.720 --> 01:04:05.160
So, for the people in the audience that
have motion on their laptops right now,

01:04:05.160 --> 01:04:06.970
you have to be careful.

01:04:07.060 --> 01:04:10.030
There is actually a bug that prevents
that Image Unit from running with

01:04:10.030 --> 01:04:11.550
the version of motion you have.

01:04:11.730 --> 01:04:16.490
So there will be a bug-fixed
release coming shortly so

01:04:16.490 --> 01:04:16.490
that it actually works well.

01:04:18.500 --> 01:04:26.740
Okay, so the next example I have is
actually something I borrowed

01:04:27.390 --> 01:04:27.450
from another session.

01:04:28.340 --> 01:04:31.530
There is an advanced new
techniques with AppKit session

01:04:31.540 --> 01:04:33.330
which uses Core Image as well.

01:04:33.390 --> 01:04:35.500
And I would like to use that app.

01:04:35.610 --> 01:04:38.040
There is a long discussion about
how that app works and what

01:04:38.040 --> 01:04:40.300
it all does in that session,
which is on Friday.

01:04:40.300 --> 01:04:41.660
So go there if you're interested.

01:04:41.660 --> 01:04:49.460
The reason I'm having it here is they
use an Image Unit as an effect in UI.

01:04:49.460 --> 01:04:53.020
So for example, when they switch between
the inspector panes here,

01:04:53.020 --> 01:04:55.720
you see there's a little
ripple effect going on.

01:04:57.000 --> 01:04:59.950
It turns out it's actually really
easy to write and go to that

01:04:59.960 --> 01:05:01.460
session to learn how to do it.

01:05:01.680 --> 01:05:07.670
And remember what I mentioned about
applying taste when doing these things?

01:05:11.100 --> 01:05:16.300
[Transcript missing]

01:05:16.890 --> 01:05:21.800
Everybody likes Google Maps,
so I have a short example of this.

01:05:21.800 --> 01:05:33.220
So this is going out to the... Come on.

01:05:33.270 --> 01:05:35.160
It's going out to the network,
which apparently stalls

01:05:35.160 --> 01:05:37.150
every now and then.

01:05:41.430 --> 01:05:47.600
Okay, let me talk about what's going on
while we're waiting for a server.

01:05:48.300 --> 01:05:54.190
So this is a little CI app
which creates an image,

01:05:54.190 --> 01:05:58.390
and it's an image provider,
which essentially means you're

01:05:58.490 --> 01:06:02.290
creating an image without
providing the backing bits,

01:06:02.370 --> 01:06:06.030
and then you get a callback
where you can provide tiles

01:06:06.120 --> 01:06:08.270
of your image data on demand.

01:06:08.270 --> 01:06:12.970
And that callback, in this case,
goes out to the Google Maps server

01:06:12.970 --> 01:06:14.820
and requests the appropriate tiles.

01:06:14.820 --> 01:06:14.820
So if I zoom in here...

01:06:19.790 --> 01:06:25.200
So you can go look at things,
look at details.

01:06:27.160 --> 01:06:31.700
Now, the really cool thing about that is
the code for this is extremely short.

01:06:31.780 --> 01:06:39.510
Essentially what you do,
and it sounds really cool,

01:06:39.510 --> 01:06:39.510
is you create an image
the size of the continent,

01:06:39.510 --> 01:06:39.510
and...

01:06:41.220 --> 01:06:46.400
Remember using double
precision for the coordinates.

01:06:46.400 --> 01:06:48.740
And then when you get the callback
which tile is actually needed,

01:06:48.740 --> 01:06:54.440
you go essentially build a URL,
request the JPEG file, and show it.

01:06:54.440 --> 01:06:55.520
And that's pretty much all.

01:06:55.520 --> 01:06:57.710
So the stuttering you see is
every now and then it goes out

01:06:57.710 --> 01:07:01.260
to the network and requests a
new tile as I'm moving through.

01:07:01.260 --> 01:07:04.900
And as I mentioned,
the network isn't too fast at the moment.

01:07:05.370 --> 01:07:07.790
So this is really cool,
but it's actually more of a demo for

01:07:07.850 --> 01:07:12.650
Google Maps than for XIV Core Image,
so we decided we have to put

01:07:12.650 --> 01:07:12.650
something else on top of it.

01:07:13.280 --> 01:07:15.960
So, let me zoom out a little bit more.

01:07:16.000 --> 01:07:23.300
So, Frank had the idea of taking a
database of California earthquakes

01:07:23.300 --> 01:07:28.460
with the locations and give you a
little bar you see on the side there.

01:07:28.470 --> 01:07:30.990
So, in each date and the
magnitude is in there.

01:07:31.000 --> 01:07:32.090
It's probably hard to read.

01:07:32.100 --> 01:07:34.440
It's a bit small.

01:07:34.500 --> 01:07:39.300
So, for example,
there was an earthquake in -- Okay,

01:07:39.300 --> 01:07:41.060
we are going to the network again.

01:07:41.060 --> 01:07:42.510
Oops.

01:07:44.960 --> 01:07:49.740
So we put a little ripple
effect and a red glow,

01:07:49.740 --> 01:07:52.770
which is really comforting.

01:07:53.620 --> 01:07:58.640
On top, so this is an earthquake in 1986,
so if you zoom out a little bit more,

01:07:58.640 --> 01:08:01.670
you actually see it's very
close to the Bay Area,

01:08:01.670 --> 01:08:04.570
and had quite significant magnitude.

01:08:06.370 --> 01:08:10.990
Okay, so again,
the app here is really simple.

01:08:10.990 --> 01:08:14.230
It takes an image,
which is the continent,

01:08:14.230 --> 01:08:19.810
and it zooms it up and renders it at
whatever display resolution we have.

01:08:19.870 --> 01:08:23.570
And then we append the ripple
filter and put a Gaussian dot on

01:08:23.570 --> 01:08:27.830
top with some red glow to make it
stand out a bit more because the

01:08:27.890 --> 01:08:31.320
ripple alone wasn't too visible.

01:08:31.320 --> 01:08:31.320
Okay.

01:08:32.440 --> 01:08:38.820
So with that, I'm pretty much done,
so let's go back to the slides.

01:08:43.350 --> 01:08:45.160
Where to go from here?

01:08:45.160 --> 01:08:48.800
So there's a lab starting at
noon developing image units.

01:08:48.800 --> 01:08:55.350
If you go to the Tiger lab,
you will be able to talk to us

01:08:55.350 --> 01:08:55.350
and bring your code and we can
look at it if you have problems.

01:08:55.790 --> 01:08:58.590
Tomorrow morning,
there is the Core Video and

01:08:58.600 --> 01:09:07.020
QuickTime High Performance Video in
MacÂ OSÂ X Tiger session.

01:09:07.350 --> 01:09:09.970
So, essentially, if you're interested in
integrating Core Image with video,

01:09:09.970 --> 01:09:09.970
then that's the session
where you have to go to.

01:09:10.200 --> 01:09:15.330
There is also a session about FXPlug,
which will talk a little bit about

01:09:15.330 --> 01:09:18.020
how to use Image Units in motion.

01:09:18.030 --> 01:09:25.770
The general story is it will just work,
but there are definitely some guidelines

01:09:25.770 --> 01:09:25.770
to obey that to make it work well.

01:09:26.610 --> 01:09:29.990
For UI effects and
AppKit integration with Core Image,

01:09:29.990 --> 01:09:34.530
you can go to the session on Friday,
Advanced View Techniques in Cocoa,

01:09:34.530 --> 01:09:38.130
which was a set that Reducer
App I was showing you before will

01:09:38.130 --> 01:09:40.460
be explained in great detail.

01:09:40.460 --> 01:09:44.670
There's definitely a lot more
Core Image in there than I was showing.

01:09:45.210 --> 01:09:49.120
And there's another Image Units
in Motion FX plug in depth,

01:09:49.160 --> 01:09:51.030
if you want to go really deep.

01:09:51.250 --> 01:09:54.500
That's on Friday at 10.

01:09:55.450 --> 01:10:03.950
Okay, so that's pretty much
it for this session.

01:10:04.000 --> 01:10:09.350
If you have a question,
contact Travis Brown,

01:10:09.350 --> 01:10:09.350
Graphics and Image Evangelist,
or come to the lab right

01:10:09.350 --> 01:10:09.350
after this session.
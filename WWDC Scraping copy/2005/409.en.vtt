WEBVTT

00:00:04.200 --> 00:01:55.800
[Transcript missing]

00:01:56.370 --> 00:01:59.660
Once you have your goals,
establish specific,

00:01:59.660 --> 00:02:03.960
precise benchmarks for what you
would like to hit with those so

00:02:03.960 --> 00:02:09.350
you can add in measurement code in
the right areas of your application

00:02:09.350 --> 00:02:15.370
and measure the time or measure the
memory use on a systematic basis.

00:02:15.580 --> 00:02:19.080
We really recommend that you follow
through this process throughout your

00:02:19.080 --> 00:02:21.300
development from the very beginning.

00:02:21.300 --> 00:02:25.500
Don't try to tack performance on as a
thing in the last week before you ship.

00:02:25.620 --> 00:02:28.460
You might have painted
yourself into a corner by then.

00:02:29.310 --> 00:02:33.150
So, a lot of times you can get
relatively inconsistent results.

00:02:33.200 --> 00:02:36.550
So, we really recommend trying
to isolate your system,

00:02:36.550 --> 00:02:40.930
take it off the network if necessary,
if you're not dependent upon it.

00:02:40.930 --> 00:02:44.650
Make sure that spotlight indexing
isn't going on in the background while

00:02:44.660 --> 00:02:46.720
you're trying to measure your time.

00:02:46.720 --> 00:02:51.400
Typically, measure several runs,
drop out the high and low, average out.

00:02:51.400 --> 00:02:53.950
And again,
don't allow regressions throughout

00:02:53.950 --> 00:02:55.580
your development period.

00:02:55.580 --> 00:02:57.750
But if you have any,
then go in and focus on

00:02:57.750 --> 00:02:59.260
those and hit the button.

00:02:59.280 --> 00:03:02.180
Hit those hot spots
using the various tools.

00:03:02.180 --> 00:03:07.160
So, just an example of why this
kind of thing is important.

00:03:07.160 --> 00:03:09.000
Think about a spotlight importer.

00:03:09.000 --> 00:03:13.550
For each user ID on the system,
for example, Dave P.

00:03:13.550 --> 00:03:18.800
on my system, there's a single MD import
process that runs.

00:03:18.800 --> 00:03:22.420
It runs all the importer plug-ins
for all the different document types.

00:03:22.420 --> 00:03:29.180
So, if your importer is slow or if it
crashes or uses a lot of resources,

00:03:29.280 --> 00:03:32.280
then the MD import is
running in background.

00:03:32.280 --> 00:03:37.280
It's supposed to gather the data quickly
so that apps can run queries quickly.

00:03:37.280 --> 00:03:41.950
So, if you crash,
then the MD import has to be restarted.

00:03:41.960 --> 00:03:45.100
So, anyway, make sure you're fast,
robust.

00:03:45.100 --> 00:03:49.640
Don't load in additional parts of
your application that you might

00:03:49.640 --> 00:03:51.280
not need for just importing.

00:03:51.300 --> 00:03:53.840
So, many frameworks you might not need.

00:03:53.840 --> 00:03:56.990
A lot of fonts if you're not
going to index that data.

00:03:57.000 --> 00:03:58.800
Don't read the file multiple times.

00:03:58.860 --> 00:04:04.400
Don't start up multiple threads if you're
not going to be using them for importing.

00:04:04.430 --> 00:04:08.730
And then come up with a
systematic way to test your code.

00:04:09.060 --> 00:04:12.210
So, in this case,
you could use MD import dash

00:04:12.520 --> 00:04:16.140
P on a large directory that you
consistently use with a complex

00:04:16.140 --> 00:04:19.590
set of representative data files.

00:04:20.310 --> 00:04:23.640
So some things to look at in
the areas of benchmarking:

00:04:23.720 --> 00:04:26.370
time, memory size, I/O, graphics.

00:04:26.620 --> 00:04:29.170
Let's look at them in
a little more detail.

00:04:29.230 --> 00:04:32.110
For time,
you probably have some ideas of what

00:04:32.110 --> 00:04:35.520
are the most important areas that you
want to run fast in your application,

00:04:35.520 --> 00:04:38.630
but also look at things like how
fast is your application launch?

00:04:38.710 --> 00:04:45.710
Can you defer things from the time you
launch to later on in the application?

00:04:45.790 --> 00:04:48.530
When your application
isn't doing anything,

00:04:48.530 --> 00:04:52.590
hopefully you're not polling,
hopefully your CPU usage is zero.

00:04:52.760 --> 00:04:55.380
And responsiveness,
when the user does live

00:04:55.400 --> 00:04:58.840
resize of your Windows,
is that snappy and efficient?

00:04:58.880 --> 00:05:00.350
Does it feel fast?

00:05:00.530 --> 00:05:04.070
We're going to focus most of
our attention in this session

00:05:04.070 --> 00:05:06.690
on the memory size issues,
both static,

00:05:06.690 --> 00:05:09.810
what is the memory use right now,
and dynamic.

00:05:09.840 --> 00:05:12.060
If I do an operation,
does it pop up and then

00:05:12.060 --> 00:05:15.370
back down in that operation,
because that can be expensive.

00:05:15.550 --> 00:05:17.580
And are you leaking memory over time?

00:05:17.580 --> 00:05:20.750
It might look good now,
but if you have it running all

00:05:20.750 --> 00:05:25.260
night and people hammering on it,
does it get much bigger overnight?

00:05:25.320 --> 00:05:28.830
I/O, so we tend to think of
a file on our system,

00:05:28.950 --> 00:05:33.340
but remember, it might be out on the
network these days.

00:05:33.340 --> 00:05:38.740
Look at the opens and closes, reads,
writes, stats, get at or list calls,

00:05:38.740 --> 00:05:42.060
but specifically look at are
you causing lots of paging,

00:05:42.060 --> 00:05:45.320
are you reading the same
file multiple times?

00:05:45.400 --> 00:05:49.090
How many files do you
have open at one time?

00:05:51.940 --> 00:05:52.580
Graphics.

00:05:52.580 --> 00:05:55.350
A lot of these problems
can be pretty subtle.

00:05:55.350 --> 00:05:58.860
The systems are so fast that it
can be hard to tell that you're

00:05:58.860 --> 00:06:02.600
drawing the same graphics onto
the screen more than one time.

00:06:02.600 --> 00:06:05.800
Or drawing areas that
don't need to be redrawn.

00:06:05.800 --> 00:06:09.730
Quartz Debug is a great
tool for looking at that.

00:06:09.770 --> 00:06:14.520
OpenGL can help look at some of
the things like frame rates of

00:06:14.530 --> 00:06:17.480
games and OpenGL applications.

00:06:17.480 --> 00:06:20.640
We won't focus on that much more here.

00:06:21.060 --> 00:06:24.200
But we do provide a lot of
tools is the message here.

00:06:24.200 --> 00:06:28.530
You definitely want to explore the tools,
read the documentation about them,

00:06:28.660 --> 00:06:31.860
take advantage of them to
make your applications fast.

00:06:31.860 --> 00:06:35.920
The tools are all included, free,
of course, with Mac OS X,

00:06:35.960 --> 00:06:37.620
with the Xcode tools.

00:06:37.620 --> 00:06:40.390
They're in developer
applications performance tools,

00:06:40.390 --> 00:06:41.410
the graphical ones.

00:06:41.490 --> 00:06:43.480
There's also some command line ones.

00:06:43.480 --> 00:06:48.000
The tools do work on your
developer transition kit systems.

00:06:48.000 --> 00:06:50.140
So they work on Intel.

00:06:50.320 --> 00:06:55.570
They can look properly at
Intel binaries as well as all

00:06:55.590 --> 00:06:58.320
the Mac OS X PowerPC binaries.

00:06:58.950 --> 00:07:03.880
Support all the initiatives, Cocoa,
Carbon, Unix.

00:07:04.090 --> 00:07:07.640
Some of the tools look at Java,
Shark especially.

00:07:07.640 --> 00:07:10.580
Not so much the ones I'll
be talking about here today.

00:07:10.580 --> 00:07:12.920
We look at the C-based
languages with these.

00:07:12.920 --> 00:07:16.110
But in general,
you don't need to recompile for

00:07:16.110 --> 00:07:18.280
GPROF or anything like that.

00:07:18.280 --> 00:07:19.580
These tools just work.

00:07:19.580 --> 00:07:25.330
And the graphical tools are integrated
with Xcode as we'll see throughout

00:07:25.330 --> 00:07:27.920
this session in various ways.

00:07:28.430 --> 00:07:34.300
The tools can be grouped in various
ways for both looking at memory use,

00:07:34.360 --> 00:07:39.610
execution time, resources,
how many files you're using, etc.

00:07:39.690 --> 00:07:44.220
You can both monitor to just get a
general sense of do things look okay,

00:07:44.320 --> 00:07:47.370
is there anything unusual
that I need to look at,

00:07:47.440 --> 00:07:49.690
or to analyze in more detail.

00:07:49.700 --> 00:07:52.990
So,
three tools that we're going to look at

00:07:52.990 --> 00:07:58.190
some in this session are ObjectAlloc,
malloc-debug, and Shark.

00:07:58.200 --> 00:08:00.370
These are all graphical applications.

00:08:00.370 --> 00:08:03.180
There are some command line equivalents.

00:08:03.180 --> 00:08:06.540
The heap tool is similar to
ObjectAlloc in some ways.

00:08:06.540 --> 00:08:10.000
Leaks does some of the same
things as malloc-debug.

00:08:10.000 --> 00:08:13.070
And, for example,
the sample command is a quick

00:08:13.070 --> 00:08:14.880
way of sampling your CPU.

00:08:14.880 --> 00:08:19.680
The sampler application has similar
functionality to Shark that I show here.

00:08:19.700 --> 00:08:19.840
Amen.

00:08:21.300 --> 00:08:23.490
So some of the primary
differences in looking at

00:08:23.490 --> 00:08:25.770
memory with these applications.

00:08:25.950 --> 00:08:31.160
Object Alloc is very good at looking at
the dynamic memory of your application.

00:08:31.220 --> 00:08:35.590
How are you using specific types
of objects in specific ways?

00:08:35.640 --> 00:08:38.980
How are you retaining and
releasing those at various times?

00:08:38.980 --> 00:08:43.260
You can look at specific instances
and the call trees of those.

00:08:43.270 --> 00:08:47.350
malloc-debug and shark both
can provide you a call tree

00:08:47.390 --> 00:08:50.790
of your entire application and
where memory is being allocated.

00:08:51.120 --> 00:08:55.420
malloc-debug is unique among these
three in that it has a leaks mode.

00:08:55.420 --> 00:08:58.700
It can tell you where the
leaks in your memory are.

00:08:59.290 --> 00:09:06.360
But Shark, one of the really interesting
features of it is it also provides

00:09:06.360 --> 00:09:10.730
a timeline of over time where,
for example,

00:09:10.730 --> 00:09:14.720
where your malloc calls made,
what was the call depth of those,

00:09:14.720 --> 00:09:17.350
which really lets you see
calling patterns there.

00:09:18.440 --> 00:09:22.380
So let's dive into analyzing
application memory use.

00:09:22.550 --> 00:09:25.970
So the general approach, again,
know your target audience.

00:09:25.980 --> 00:09:30.380
What size hardware are they
typically going to have?

00:09:30.380 --> 00:09:35.520
Are you aiming at real consumer systems
with 256 or 512 megabytes of memory?

00:09:35.660 --> 00:09:38.180
If so,
you definitely want to test on that.

00:09:38.210 --> 00:09:41.880
But one thing to know is once
the resident memory use of your

00:09:41.880 --> 00:09:45.530
application gets to a certain level,
if you do start paging,

00:09:45.820 --> 00:09:49.400
you're gonna flatten out on the,
the resident size of your

00:09:49.400 --> 00:09:50.940
application at that point.

00:09:50.990 --> 00:09:54.220
And this is the amount
that's actually in RAM,

00:09:54.260 --> 00:09:57.240
but your app might be
needing more than that.

00:09:57.260 --> 00:09:59.890
And you'd need to know how
much more so that you know

00:10:00.090 --> 00:10:01.880
how far you need to reduce it.

00:10:01.920 --> 00:10:06.660
So you might also want to test on large
memory configuration systems so you

00:10:06.660 --> 00:10:10.160
can get a feel for the peak memory use.

00:10:10.180 --> 00:10:16.250
So definitely want to try to prevent
paging because if you have to go out to

00:10:16.370 --> 00:10:20.720
disk in trying to access this memory,
that's gonna really slow things down.

00:10:20.740 --> 00:10:23.880
Again, general guidelines,
allocate lazily,

00:10:24.160 --> 00:10:30.470
avoid repetition of the same
events over and over again.

00:10:30.820 --> 00:10:33.100
Some techniques here on this.

00:10:33.100 --> 00:10:36.260
You can look at things
with the top application.

00:10:36.410 --> 00:10:39.270
Top, Big Top,
and Activity Monitor are all

00:10:39.270 --> 00:10:42.900
ways of looking at what's going
on in the system as a whole and

00:10:43.000 --> 00:10:44.760
multiple different processes.

00:10:44.860 --> 00:10:49.310
VM Map will talk about a fair
amount on a way to analyze the

00:10:49.310 --> 00:10:52.580
memory regions of your application.

00:10:54.790 --> 00:11:00.500
Then we'll look in more detail at some
of the tools for tracing in depth.

00:11:00.590 --> 00:11:03.600
And another technique that I find
useful sometimes is to actually be

00:11:03.600 --> 00:11:08.500
stopped in the debugger and looking
at the data in something like Top,

00:11:08.550 --> 00:11:11.700
and then stepping through my code,
and I step over a routine,

00:11:11.700 --> 00:11:15.680
and I see a big spike in the
virtual size of my application.

00:11:15.880 --> 00:11:16.500
Whoa!

00:11:16.520 --> 00:11:18.290
What happened down inside that routine?

00:11:18.300 --> 00:11:21.100
Let's explore that in more depth.

00:11:21.190 --> 00:11:26.730
So looking at Top, on the screen here,
you see some of the things that I tend

00:11:26.730 --> 00:11:28.100
to take a look at a fair amount.

00:11:28.100 --> 00:11:33.920
This is output from running Top-U,
which sorts the output in order

00:11:33.920 --> 00:11:36.900
of most expensive CPU time.

00:11:36.930 --> 00:11:40.300
So I look at the percentage of CPU.

00:11:40.310 --> 00:11:44.100
I look at the resident private,
the middle column here,

00:11:44.100 --> 00:11:46.800
and the virtual size of my application.

00:11:46.830 --> 00:11:49.200
Some of the other things,
like resident shared,

00:11:49.200 --> 00:11:52.900
includes the framework data that
you're sharing with other processes.

00:11:52.900 --> 00:11:55.970
So it's a little hard for you to
get a feel for how much of that

00:11:56.300 --> 00:11:59.900
you alone are responsible for,
and how to reduce that.

00:11:59.940 --> 00:12:03.790
This can also show you paging
information and information

00:12:03.790 --> 00:12:05.300
about the number of threads.

00:12:05.300 --> 00:12:10.600
If you're on a dual processor system
and expecting to be multi-threaded

00:12:10.600 --> 00:12:13.990
and you only see one thread,
maybe there's a problem there,

00:12:13.990 --> 00:12:15.670
and that type of thing.

00:12:15.780 --> 00:12:20.700
Big Top is a great way to see
short spikes in memory use.

00:12:20.700 --> 00:12:24.700
Or just trends over time.

00:12:24.700 --> 00:12:28.490
Sometimes just reading the output
of the Top command in terminal,

00:12:28.710 --> 00:12:31.700
your eyes can glaze over a
little bit and miss details.

00:12:31.910 --> 00:12:34.700
But Top shows you trend graphs.

00:12:34.700 --> 00:12:36.700
So I mentioned VM Map.

00:12:36.700 --> 00:12:41.700
This is a command line tool that can
show you what the various different

00:12:41.700 --> 00:12:46.700
memory regions of your application are,
why they were allocated.

00:12:46.700 --> 00:12:49.490
So some of them are
binary image sections,

00:12:49.490 --> 00:12:50.500
text, data, link edit.

00:12:50.500 --> 00:12:58.500
This now in Tiger shows you the names
of mapped files in your process.

00:12:58.500 --> 00:13:04.450
Shows you which parts are malloc blocks
that you would analyze with other tools.

00:13:04.530 --> 00:13:08.500
Some applications do their
own VM allocates of regions.

00:13:08.500 --> 00:13:10.500
So this shows you that as well.

00:13:10.500 --> 00:13:14.350
And also things like stacks and
what we identify certain other

00:13:14.350 --> 00:13:16.500
framework allocated regions.

00:13:16.500 --> 00:13:20.620
So typically you just run this on the
command line with a VM map and you

00:13:20.620 --> 00:13:22.300
can see the name of your application.

00:13:22.300 --> 00:13:24.300
If there's more than one
process of that name,

00:13:24.300 --> 00:13:26.300
use a process ID.

00:13:26.300 --> 00:13:29.460
There's some new arguments
for this in Tiger.

00:13:29.460 --> 00:13:34.300
Specifically the dash resident
flag shows both the resident

00:13:34.300 --> 00:13:35.390
size and the virtual size.

00:13:35.500 --> 00:13:39.490
And you can show that in
either pages or kilobytes.

00:13:40.370 --> 00:13:44.100
One way to use this, for example,
would be to run VM map once,

00:13:44.120 --> 00:13:48.220
save the output into a file,
do the operation in your application,

00:13:48.260 --> 00:13:51.700
run it again, save into a file,
and look at the

00:13:51.700 --> 00:13:54.180
differences in file merge.

00:13:54.530 --> 00:14:01.370
So let's switch to demo two and
see an example of this in action.

00:14:02.090 --> 00:14:06.510
So I've written a little
application here called FontTest.

00:14:06.520 --> 00:14:11.370
Now inside this application is
some code that a third-party

00:14:11.370 --> 00:14:13.480
developer asked us about.

00:14:13.500 --> 00:14:17.350
Said, why am I seeing so many mapped
files in my application?

00:14:17.360 --> 00:14:18.910
What is that?

00:14:19.000 --> 00:14:20.910
Can you give me more information?

00:14:21.030 --> 00:14:25.920
So if we run BigTop, we can say, okay,
let's select,

00:14:25.920 --> 00:14:31.070
you can either do the system as a whole,
or you can select specific processes.

00:14:31.150 --> 00:14:35.480
So I'm going to watch the resident size,
which in this application we currently

00:14:35.510 --> 00:14:38.220
see is static at about 1.3 megabytes.

00:14:38.430 --> 00:14:42.380
The virtual size is about 350 meg.

00:14:42.390 --> 00:14:46.090
Now remember that's lots of, you know,

00:14:46.320 --> 00:14:49.260
is the founder of the
Google Chrome browser.

00:14:49.290 --> 00:15:04.230
He's been working on the
web-based application.

00:15:05.390 --> 00:15:05.390
He's been working on the
web-based application.

00:15:05.390 --> 00:15:05.390
He's been working on the
web-based application.

00:15:05.390 --> 00:15:05.390
We'll talk about that in a minute.

00:15:06.510 --> 00:15:09.720
Bring Big Top back up to
the front and font test.

00:15:09.810 --> 00:15:13.260
So now let's do a list fonts
here and see what happens.

00:15:13.260 --> 00:15:18.130
Well, we kind of had a big spike
in virtual memory here.

00:15:18.130 --> 00:15:19.380
Was this what we expected?

00:15:19.380 --> 00:15:25.960
We've gone from about 350 up
to about 400 megabytes here.

00:15:25.960 --> 00:15:31.720
The resident size has also
had some change in there.

00:15:31.720 --> 00:15:35.550
So now we can come in with VM Map again.

00:15:36.500 --> 00:15:40.480
Run the same command again.

00:15:42.350 --> 00:15:48.500
and look at some of the
differences in file merge here.

00:15:53.200 --> 00:15:55.660
And I thought I'd changed
the fonts before we got here.

00:15:55.660 --> 00:16:02.920
Wrap text, excellent.

00:16:06.280 --> 00:16:09.280
Okay, so here we see a lot of the output.

00:16:09.300 --> 00:16:12.700
We can see that, in fact,
let me hide this for a second

00:16:12.700 --> 00:16:14.600
and look at it in terminal.

00:16:14.600 --> 00:16:17.500
Less of before.txt.

00:16:17.500 --> 00:16:21.600
So we can see that, for example,
page zero is page zero.

00:16:21.600 --> 00:16:24.080
Read or write that,
you're going to crash.

00:16:24.080 --> 00:16:28.050
The application typically
gets loaded at 1,000 hex.

00:16:28.050 --> 00:16:33.160
We see several mapped files and
a shared memory region here.

00:16:33.980 --> 00:16:38.320
Then a lot more frameworks and DYLD.

00:16:38.320 --> 00:16:43.500
See a bunch of data regions,
VM allocations, et cetera.

00:16:43.500 --> 00:16:47.410
So if we look at the file merge output.

00:16:49.180 --> 00:16:54.180
We can see now that we're
starting to get a lot more mapped

00:16:54.480 --> 00:16:56.080
files in here this time around.

00:16:56.080 --> 00:17:01.820
In fact, these look like they were
mapped from Library Cache's ATS.

00:17:01.820 --> 00:17:04.660
So it's font data being mapped in.

00:17:04.660 --> 00:17:08.560
Can we get a sense of
what that's all about?

00:17:08.560 --> 00:17:13.240
So if we go down to the bottom also,
we also see a couple other

00:17:13.240 --> 00:17:14.580
frameworks brought in.

00:17:14.580 --> 00:17:16.920
Carbon Core was brought in for this.

00:17:16.920 --> 00:17:21.120
It's kind of unusual since my
impression was this was supposed

00:17:21.180 --> 00:17:22.210
to be a Cocoa application.

00:17:22.220 --> 00:17:24.940
But they share things under the covers.

00:17:24.940 --> 00:17:30.200
So here we can see that the amount
of mapped file information has gone.

00:17:30.200 --> 00:17:33.990
The virtual size went from about
20 megabytes up to 82 megabytes.

00:17:34.050 --> 00:17:39.060
And the resonant size from
about 8.2 meg to about 12.2.

00:17:39.060 --> 00:17:42.300
It's kind of unusual for just
getting the names of the fonts.

00:17:44.170 --> 00:17:48.090
So one quick thing we can do
to analyze this further is

00:17:48.700 --> 00:17:54.070
look at this again with Shark,
the new system trace

00:17:54.200 --> 00:17:56.680
facility in Shark 4.2.

00:17:56.760 --> 00:17:59.580
So we'll flip over to Shark.

00:17:59.900 --> 00:18:03.590
System trace of the whole system.

00:18:03.590 --> 00:18:05.970
Run font test again.

00:18:06.170 --> 00:18:10.740
Use the option escape to
start our system trace,

00:18:10.740 --> 00:18:14.800
list the fonts, stop the system trace.

00:18:17.990 --> 00:18:20.700
So the reason I'm doing this
is we didn't see a tremendous

00:18:20.700 --> 00:18:23.090
change in the resident size,
but we saw a lot of change

00:18:23.090 --> 00:18:24.260
in the virtual size.

00:18:24.260 --> 00:18:28.180
This might be able to show us some
more about what was going on here.

00:18:28.180 --> 00:18:30.940
So we can see that a lot
of the time was idle,

00:18:30.940 --> 00:18:33.740
but there was some user time,
system time.

00:18:33.740 --> 00:18:38.900
BigTop itself was taking some time,
but FontTest had a fair amount.

00:18:38.900 --> 00:18:42.450
We also see ATS Server has a fair amount.

00:18:43.320 --> 00:18:48.610
So if we look at system calls
and go down here to FontTest,

00:18:49.530 --> 00:18:53.130
We can see that we've got a
lot of VM copies going on.

00:18:53.130 --> 00:18:54.890
And I can expand this out.

00:18:54.900 --> 00:18:57.320
This is a reverse call tree from main.

00:18:57.320 --> 00:19:03.080
We go through a number of layers
of ATS down to a VM copy here.

00:19:03.080 --> 00:19:07.440
Now one thing, we can do a little bit of
data mining using the advanced

00:19:07.480 --> 00:19:12.270
settings window and say,
well, let's flatten the system libraries.

00:19:12.270 --> 00:19:14.790
Collapse that down again.

00:19:16.020 --> 00:19:20.090
So now we can see that List Fonts,
Font Test Controller List Fonts is

00:19:20.090 --> 00:19:26.840
calling to ATS font get table directory,
which underneath there is

00:19:26.840 --> 00:19:29.480
what's causing the VM changes.

00:19:29.500 --> 00:19:35.790
We can also see that in a
top-down fashion as follows.

00:19:37.700 --> 00:19:41.950
So, list fonts, ATS, get font directory.

00:19:42.170 --> 00:19:46.780
So if we look at this project in Xcode,
we see that actually this code

00:19:46.780 --> 00:19:51.640
is using some low level ATS calls
to iterate through the fonts.

00:19:51.830 --> 00:19:54.260
We get the name, which that's not bad.

00:19:54.340 --> 00:19:56.450
Get a CFString back from that.

00:19:56.460 --> 00:19:58.070
We're releasing that, that's good.

00:19:58.220 --> 00:20:01.780
We build up a font list string,
but this code that we got from the

00:20:01.840 --> 00:20:05.050
third-party developer is making
these additional calls that,

00:20:05.080 --> 00:20:07.350
you know, for example,
this might be a library routine.

00:20:07.550 --> 00:20:10.410
This is getting much more detailed
information about the fonts

00:20:10.460 --> 00:20:12.120
that causes us to map them in.

00:20:12.150 --> 00:20:15.070
We really don't need
that data at this point.

00:20:15.240 --> 00:20:20.140
So in this case,
for just getting a list of the fonts,

00:20:20.140 --> 00:20:23.260
I can eliminate all that
code from this path,

00:20:23.280 --> 00:20:27.220
and we would eliminate a lot of
paging and additional VM regions here.

00:20:31.200 --> 00:20:39.800
[Transcript missing]

00:20:48.700 --> 00:20:50.260
And where did I leave the clicker?

00:20:50.260 --> 00:20:57.680
All right, I've mentioned ObjectAlloc
a couple of times.

00:20:57.680 --> 00:20:59.860
I'm gonna go into some
more detail on that.

00:20:59.860 --> 00:21:04.020
This application excels at
helping you look at specific

00:21:04.020 --> 00:21:06.170
object types of your application.

00:21:06.180 --> 00:21:10.300
It's got a lot of built-in
support where the frameworks,

00:21:10.320 --> 00:21:14.920
core foundation and foundation,
talk to the allocation and the

00:21:14.920 --> 00:21:20.000
logging routines so that we know what
types of objects are being allocated.

00:21:20.000 --> 00:21:23.640
We can find out about the retain
and release calls of them.

00:21:23.690 --> 00:21:27.900
But in addition,
it now shows the malloc blocks,

00:21:27.930 --> 00:21:31.380
which might include, for example,
C++ objects,

00:21:31.390 --> 00:21:35.470
where C++ new calls into malloc.

00:21:35.580 --> 00:21:37.940
So it's dynamic.

00:21:37.940 --> 00:21:39.860
It watches your application as it runs.

00:21:39.860 --> 00:21:43.090
So it's great for seeing
dynamic memory use.

00:21:43.200 --> 00:21:46.940
You can look at specific
instances of objects in this,

00:21:46.940 --> 00:21:51.210
which can be really
revealing in some cases.

00:21:51.340 --> 00:21:55.890
So let's go ahead and take
a look at this as well.

00:22:00.650 --> 00:22:03.250
Now for this,
I'm going to use an application

00:22:03.250 --> 00:22:04.600
that I pulled off of the web.

00:22:04.600 --> 00:22:08.660
This is an open source
application called AquaLess.

00:22:08.660 --> 00:22:13.680
In the previous demo,
you watched me use the Less Unix pager to

00:22:13.680 --> 00:22:17.380
page down through the information there.

00:22:18.260 --> 00:22:29.010
So I've already built this application.

00:22:29.010 --> 00:22:38.000
I'm going to go ahead and run it.

00:22:38.000 --> 00:22:38.000
It doesn't do anything,
just sitting here, but I can...

00:22:43.100 --> 00:22:47.640
So I'm just going to do an ls -lr/system.

00:22:47.650 --> 00:22:51.900
Now it's got a command line
command called aless for Aqualess.

00:22:51.920 --> 00:22:56.530
This takes the information in from
the Unix pipe and redirects it

00:22:56.530 --> 00:23:02.980
out through distributed objects
out to the Aqualess window here.

00:23:03.230 --> 00:23:04.480
So pretty interesting.

00:23:04.480 --> 00:23:10.260
But let's take a look at whether there's
anything interesting going on here.

00:23:10.260 --> 00:23:13.870
Sometimes it helps to just run your
apps under the performance tools to

00:23:13.870 --> 00:23:16.190
see if there's anything unexpected.

00:23:16.430 --> 00:23:22.660
So you can do that directly from
Xcode with going into the debug menu,

00:23:22.660 --> 00:23:25.340
launch using performance tool,
and in this case,

00:23:25.430 --> 00:23:28.310
we'll choose object alloc.

00:23:29.720 --> 00:23:32.510
So back to Object Alloc.

00:23:32.590 --> 00:23:37.500
I can just go ahead and
start my application.

00:23:37.690 --> 00:23:39.180
It gives me a few options here.

00:23:39.270 --> 00:23:42.840
I'm just going to keep
backtraces at this point.

00:23:42.980 --> 00:23:47.710
So let's say okay.

00:23:47.710 --> 00:23:47.710
So now...

00:23:49.510 --> 00:23:51.440
Nice, pretty bar charts here.

00:23:51.440 --> 00:23:55.800
We can change the scale with
the slider on the bottom here.

00:23:55.800 --> 00:24:00.130
On the left, let's see, I'm not sure,
I don't think I have a

00:24:00.130 --> 00:24:01.840
font size thing on those.

00:24:01.840 --> 00:24:02.700
Hopefully that's readable.

00:24:02.700 --> 00:24:05.780
But on the left,
we have various different types

00:24:05.780 --> 00:24:07.800
of memory allocations here.

00:24:07.800 --> 00:24:14.500
So we can see CFArrays of various types,
CFDatas, CFDictionary's.

00:24:15.070 --> 00:24:18.060
Now, because core foundation
objects are toll-free bridged

00:24:18.060 --> 00:24:20.720
with foundation objects,
we don't actually know whether

00:24:20.720 --> 00:24:23.760
these were NSStrings when we
created them or CFStrings.

00:24:23.760 --> 00:24:26.090
But we can sort by that name.

00:24:26.090 --> 00:24:30.650
We can sort by the current
number of objects of any type.

00:24:30.660 --> 00:24:33.280
We can sort by the peak
that we've ever had,

00:24:33.280 --> 00:24:35.120
or we can sort by the total.

00:24:35.120 --> 00:24:38.580
I'll explain this in a little
more detail as we go through here.

00:24:38.580 --> 00:24:42.770
Let's go ahead and start some output up.

00:24:44.060 --> 00:24:48.230
We're getting a lot of
data generated here.

00:24:48.370 --> 00:24:51.480
Things are running a bit more
slowly under ObjectAlloc.

00:24:51.550 --> 00:24:53.490
Now we're getting something interesting.

00:24:53.550 --> 00:24:58.530
Let's pause the
application and sort again.

00:24:58.710 --> 00:25:05.820
Now we can see that I've got
120,000 immutable CFStrings created.

00:25:06.110 --> 00:25:09.660
I've got 5000 CFStrings.

00:25:09.660 --> 00:25:11.990
This is total that were ever created.

00:25:12.130 --> 00:25:18.000
The current number is much lower than
that at 4000 immutable CFStrings.

00:25:18.000 --> 00:25:20.000
The peak was a bit higher.

00:25:20.100 --> 00:25:22.090
But the total, what is going on?

00:25:22.340 --> 00:25:23.660
And why the colors?

00:25:23.910 --> 00:25:26.690
Well,
the colors are very informative in that,

00:25:26.770 --> 00:25:29.650
in fact,
let me change the scale here because

00:25:29.650 --> 00:25:31.660
we appear to be way off the side.

00:25:33.050 --> 00:25:37.940
If a bar is red,
that means that the current number of

00:25:37.940 --> 00:25:43.450
this type of object that we still have
live is less than 10% of the total that

00:25:43.450 --> 00:25:45.720
we've ever had of that type of object.

00:25:45.720 --> 00:25:50.490
So apparently we're creating lots
more CFStrings than we're actually

00:25:50.490 --> 00:25:53.220
retaining for long periods of time.

00:25:53.220 --> 00:25:57.160
Another thing here is we can
look at this count in bytes.

00:25:57.740 --> 00:26:03.210
We can see that we've created
over 2 million bytes of CFStrings,

00:26:03.210 --> 00:26:09.140
but right now we're using about
111,000 bytes of immutable CFStrings.

00:26:09.140 --> 00:26:12.920
So let's go back to counts.

00:26:12.920 --> 00:26:19.760
So take note here that the second
highest is CFString stores.

00:26:19.760 --> 00:26:24.010
We've got more than 20 times that
many objects there right now.

00:26:24.020 --> 00:26:27.080
We can look at specific
instances of these.

00:26:27.740 --> 00:26:32.390
and the allocation events of
those with the backtraces.

00:26:33.190 --> 00:26:36.550
Or we can go into the
call stacks and say,

00:26:36.570 --> 00:26:38.650
well, I want to see not just
the current objects,

00:26:38.650 --> 00:26:41.540
but apparently we've got a
problem with the total objects.

00:26:41.580 --> 00:26:46.340
So let's select CFString immutable
and descend the maximum path here.

00:26:46.380 --> 00:26:51.140
So this shows us where the
biggest counts of these were

00:26:51.140 --> 00:26:54.150
allocated in my source code.

00:26:55.430 --> 00:26:58.820
So we see the actual
allocation happen down here.

00:26:58.850 --> 00:27:03.200
And this is coming from apparently
a factory method of NSString,

00:27:03.200 --> 00:27:07.920
string with characters length,
that's called from this routine here.

00:27:07.920 --> 00:27:11.300
And it has a very handy little
link that can take me back

00:27:11.440 --> 00:27:13.270
to the source code and Xcode.

00:27:13.280 --> 00:27:16.790
So commit character with style.

00:27:17.100 --> 00:27:19.270
What's going on here?

00:27:19.280 --> 00:27:21.030
I thought I was calling NSString.

00:27:21.040 --> 00:27:25.380
So I've looked at this code a bit.

00:27:25.380 --> 00:27:29.190
I can look at the command,
double-click to go to

00:27:29.190 --> 00:27:31.060
the definition of this.

00:27:31.070 --> 00:27:34.000
And what's happening here is that
we've got a macro definition.

00:27:34.140 --> 00:27:36.420
This is the original code.

00:27:37.110 --> 00:27:43.080
We're taking one Unicode byte in
from the input from the pipe that was

00:27:43.080 --> 00:27:44.860
coming across the distributed objects.

00:27:44.860 --> 00:27:48.300
One Unicode byte,
and we're trying to append it

00:27:48.300 --> 00:27:50.400
to an accumulation buffer here.

00:27:50.400 --> 00:27:55.940
To do that, the append string routine
takes an NSString argument,

00:27:55.940 --> 00:27:57.930
so we're creating one.

00:27:58.100 --> 00:28:03.300
We're doing this using a factory method
that creates an auto-released object,

00:28:03.710 --> 00:28:08.200
which is generating lots of auto-released
objects that aren't being freed

00:28:08.200 --> 00:28:11.900
until the next auto-release pool pop.

00:28:11.900 --> 00:28:16.530
So that could cause choppy
behavior in your application when

00:28:16.630 --> 00:28:19.300
the objects get auto-released.

00:28:19.730 --> 00:28:23.600
So a somewhat better way to do this
is my version number two of this code,

00:28:23.600 --> 00:28:27.680
which this is identical code
except for I changed from using

00:28:27.680 --> 00:28:32.580
the factory method to using an
explicit allocation and release.

00:28:32.580 --> 00:28:37.510
So that does a much better job of
keeping me constant with the number of

00:28:37.640 --> 00:28:40.310
objects I have live at any one time.

00:28:40.560 --> 00:28:44.340
I'm not accumulating them,
waiting for them to be auto-released,

00:28:44.340 --> 00:28:49.670
but at the same time,
it's still generating a lot of objects.

00:28:49.680 --> 00:28:53.720
And maybe we don't need to do that
at all for what we're doing here.

00:28:53.720 --> 00:28:59.750
So I have a version two of this code
where the Unicode character comes in,

00:28:59.750 --> 00:29:04.690
and here I just assign that as
byte zero of a two-byte Unicode

00:29:04.780 --> 00:29:07.840
character buffer that I created.

00:29:07.840 --> 00:29:10.540
And I created one.

00:29:10.560 --> 00:29:15.440
So I have one CFString that says I'm
going to use that external buffer,

00:29:15.570 --> 00:29:17.520
and I'm managing the memory of it.

00:29:17.520 --> 00:29:19.880
I know it's a two-byte buffer.

00:29:19.880 --> 00:29:22.730
I don't need to explicitly
allocate it or free it.

00:29:22.850 --> 00:29:28.180
I'm just going to take that to create my
CFString to pass it through a pen string.

00:29:28.180 --> 00:29:32.210
So don't create any objects
dynamically on the fly.

00:29:32.220 --> 00:29:36.580
So if we go and build my
version two of the code here.

00:29:39.530 --> 00:29:44.490
- First, let's quit the application
as it's currently running.

00:29:44.500 --> 00:29:47.470
We're paused in ObjectAlloc.

00:29:47.720 --> 00:29:52.490
We can go ahead and quit
that and quit ObjectAlloc.

00:29:53.500 --> 00:30:06.200
[Transcript missing]

00:30:07.000 --> 00:30:08.980
Let's go ahead and do the same thing.

00:30:09.180 --> 00:30:14.100
We'll start our same output coming out.

00:30:15.490 --> 00:30:21.790
And we can see that that
is generating output.

00:30:22.020 --> 00:30:26.800
So remember it was CFString immutable
that we had so many of last time around.

00:30:26.870 --> 00:30:29.960
Sorting by total at this point,

00:30:31.790 --> 00:30:37.940
We can see that now the second place,
CFStringStore, is looking expensive,

00:30:38.070 --> 00:30:41.420
but it's down in the 80,000
range at this point as opposed to

00:30:41.440 --> 00:30:44.520
the 200,000 that we had before,
the 20 times more.

00:30:44.520 --> 00:30:49.440
So apparently we completely eliminated
the use of one type of object there.

00:30:49.440 --> 00:30:52.720
So we could walk down through all
of these red ones and look for

00:30:52.720 --> 00:30:56.620
opportunities to reduce the dynamic
memory use of this application,

00:30:56.620 --> 00:31:01.680
which may also then help it run faster
and help the rest of the system.

00:31:01.700 --> 00:31:05.200
run faster.

00:31:07.800 --> 00:31:11.780
Cleaning up after this one.

00:31:11.780 --> 00:31:13.900
And back to slides, please.

00:31:15.640 --> 00:31:18.280
All right,
so we've looked at analyzing the

00:31:18.390 --> 00:31:21.160
memory use of the application.

00:31:24.100 --> 00:31:26.240
Now let's talk about
finding memory leaks.

00:31:26.240 --> 00:31:30.320
This can often be a favorite topic
internally at Apple because we

00:31:30.320 --> 00:31:34.290
want to try to get all the leaks
out of our frameworks so that

00:31:34.290 --> 00:31:36.540
you don't get hit by those leaks.

00:31:38.020 --> 00:31:41.580
So, the standard techniques that we've
got for finding memory leaks,

00:31:41.580 --> 00:31:44.390
there's the malloc-debug application.

00:31:45.230 --> 00:31:51.550
There's the leaks command line tool,
which if you use that with an environment

00:31:51.680 --> 00:31:57.700
variable that causes your running
application to generate stack logging,

00:31:57.700 --> 00:32:01.880
then the leaks command line tool
can show you a stack backtrace

00:32:01.880 --> 00:32:04.690
as to where allocations happened.

00:32:05.070 --> 00:32:08.920
But I'm also going to show a third
technique here that's a little advanced

00:32:08.920 --> 00:32:12.380
with our current state of the tools.

00:32:12.470 --> 00:32:18.280
I can combine the use of leaks command
with the retain release mechanisms of

00:32:18.280 --> 00:32:23.890
object alloc to find leaks that may
be more associated with not releasing

00:32:23.990 --> 00:32:29.920
things enough times or over retaining
them as opposed to just allocating.

00:32:29.930 --> 00:32:33.360
Now, one thing to be careful of,
and we sometimes run into this,

00:32:33.360 --> 00:32:36.760
is occasionally there's a
mysterious leak up in the highest

00:32:36.760 --> 00:32:40.330
levels of the application,
so the programmer fixes it by

00:32:40.330 --> 00:32:44.300
putting an extra release in up there.

00:32:44.360 --> 00:32:47.560
Later on, a framework programmer
comes along and says,

00:32:47.560 --> 00:32:49.290
oh, my framework is leaking.

00:32:49.560 --> 00:32:50.870
I'd better stop that.

00:32:50.890 --> 00:32:54.690
So the framework programmer puts
a release in and gets tested on

00:32:54.690 --> 00:32:58.920
many different ways and says,
great, things are leaking less.

00:32:58.950 --> 00:33:01.580
Until we get to the application,
where the smart application

00:33:02.020 --> 00:33:06.770
programmer had fixed it,
and now they crashed because they're

00:33:06.770 --> 00:33:09.840
getting an over release of an object.

00:33:09.860 --> 00:33:13.600
So you want to make sure that you're
testing things fairly thoroughly

00:33:13.600 --> 00:33:15.830
and actually looking for root cause.

00:33:15.930 --> 00:33:17.820
If you aren't the thing
that's leaking it,

00:33:17.820 --> 00:33:19.820
maybe you shouldn't be trying to fix it.

00:33:19.880 --> 00:33:23.840
You should be trying to find what
the actual cause of the leak is.

00:33:24.140 --> 00:33:30.120
So malloc-debug,
this application shows a full call tree

00:33:30.160 --> 00:33:34.320
from the top of your application down of
where all your memory is being allocated.

00:33:34.320 --> 00:33:37.160
This is the memory
that's currently in use.

00:33:37.160 --> 00:33:42.960
But it also has a mode to say, well,
let's find the leaked memory and show

00:33:43.100 --> 00:33:46.050
how much is being leaked from where.

00:33:47.060 --> 00:33:50.980
There were some limitations with
malloc-debug in the past where

00:33:51.210 --> 00:33:58.330
if you had an application that
required two-level namespace,

00:33:58.330 --> 00:33:58.330
so that's the default
is two-level namespace.

00:33:58.630 --> 00:34:03.480
But if your application required it,
it couldn't work with malloc-debug

00:34:03.480 --> 00:34:08.070
because malloc-debug used
to require flat namespace.

00:34:08.510 --> 00:34:12.420
What this means is if you have
two separate libraries linked

00:34:12.420 --> 00:34:16.160
into your application and they
each declare the same symbol,

00:34:16.250 --> 00:34:17.990
that normally works fine.

00:34:18.040 --> 00:34:22.120
It didn't used to work when working with
malloc debug and the app would crash.

00:34:22.170 --> 00:34:23.180
That should now work.

00:34:23.200 --> 00:34:27.650
Another enhancement is if you
have an application that forks

00:34:27.880 --> 00:34:33.960
and execs other processes,
that fork and exec now properly works.

00:34:33.960 --> 00:34:39.920
The child processes inherit
the lib malloc debug setting,

00:34:39.920 --> 00:34:45.420
and you can then in mallocdebug.app
attach to those child processes.

00:34:45.420 --> 00:34:48.880
So I tried this, for example,
with terminal.

00:34:48.880 --> 00:34:52.050
I said run terminal under malloc debug,
and then I could attach

00:34:52.060 --> 00:34:53.100
to all the shells.

00:34:53.200 --> 00:34:57.480
or things that were
started from the shells.

00:34:58.470 --> 00:35:02.560
The second mechanism here,
the leaks command line

00:35:02.560 --> 00:35:06.400
tool with the malloc stack
logging environment variable.

00:35:06.530 --> 00:35:10.700
What you want to do here is when
you're launching your application,

00:35:10.700 --> 00:35:13.400
your target application,
is set this environment variable

00:35:13.400 --> 00:35:18.370
that changes the behavior of
the system malloc to say record

00:35:18.460 --> 00:35:20.900
where all the allocations occur.

00:35:20.900 --> 00:35:23.400
What are the backtraces of all of those?

00:35:23.400 --> 00:35:27.830
I'll explain a little more on
how to do this on the next slide.

00:35:28.000 --> 00:35:31.550
But one thing I want to
talk about is in general,

00:35:31.550 --> 00:35:36.900
how does our leak detection work
with both leaks and malloc debug?

00:35:36.910 --> 00:35:42.660
What we do is we walk through all of the
malloc regions of your code and we say,

00:35:42.770 --> 00:35:45.900
okay, these are all the malloc blocks.

00:35:46.120 --> 00:35:51.400
Then we walk through all of the memory
that your application is accessing.

00:35:51.400 --> 00:35:57.380
So all of the allocated code,
all of your stack information,

00:35:57.400 --> 00:35:59.400
and we look for pointers
to the malloc blocks.

00:35:59.580 --> 00:36:04.510
Any block that's being pointed to from
things that are actually accessible

00:36:04.510 --> 00:36:09.400
from the top levels of your application
is considered to not be leaked.

00:36:09.400 --> 00:36:14.400
And any malloc blocks that are left over
at the end are considered to be leaked.

00:36:14.650 --> 00:36:20.570
And we do detections of cycles of
leaked objects and things like this.

00:36:21.160 --> 00:36:27.160
There can be some issues here in that
4-byte blocks looking like pointers,

00:36:27.160 --> 00:36:29.680
well,
maybe they're not actually pointers.

00:36:29.680 --> 00:36:34.110
Some things that can happen,
you could allocate memory but

00:36:34.210 --> 00:36:38.810
not have initialized it yet,
and maybe it had some leftover data in

00:36:38.810 --> 00:36:41.170
there that was a pointer to a block.

00:36:41.720 --> 00:36:45.220
If you were to set the
malloc_prescribble and

00:36:45.220 --> 00:36:52.540
malloc_scribble environment variables,
those say write into memory

00:36:52.540 --> 00:36:55.590
when we initialize it or
write into it when we free it,

00:36:55.730 --> 00:36:58.500
write a certain known bit
pattern that cannot be a pointer.

00:36:58.500 --> 00:37:02.450
So this can make your leak information
a little bit more consistent.

00:37:02.460 --> 00:37:07.270
And also try to stress test your
application over a long period of time,

00:37:07.270 --> 00:37:11.220
which can give you larger
amounts of leak information.

00:37:12.980 --> 00:37:15.470
So I say setting Unix
environment variables.

00:37:15.540 --> 00:37:18.280
Now, I'm an old Unix geek.

00:37:18.470 --> 00:37:20.740
I've been doing that for 20 years,
but for those of you

00:37:20.740 --> 00:37:25.050
who may be new to that,
there are some nuances here.

00:37:27.210 --> 00:37:31.530
So the first thing to note is actually
the default shell when you create a new

00:37:31.530 --> 00:37:34.880
user on Mac OS X is now the bash shell.

00:37:34.880 --> 00:37:40.190
And the syntax for setting environment
variables in bash is a little different

00:37:40.190 --> 00:37:44.840
than with the syntax I gave previously,
which is for the shell I use still,

00:37:44.840 --> 00:37:45.800
which is TCSH.

00:37:45.800 --> 00:37:49.910
So what you do in bash is say exports,
and then the name of the

00:37:49.910 --> 00:37:54.850
environment variable,
malloc stack logging, equals the value.

00:37:54.860 --> 00:37:56.520
In this case, you want one.

00:37:57.200 --> 00:37:59.940
Then you need to launch your
application in the context of

00:38:00.020 --> 00:38:02.020
that environment variable setting.

00:38:02.020 --> 00:38:04.650
So you need to launch it
from that terminal session.

00:38:04.660 --> 00:38:07.660
So you go out to the command line,
you change directory to

00:38:07.660 --> 00:38:10.860
where the application lives,
but it's not sufficient

00:38:11.010 --> 00:38:12.760
to just say Safari.app.

00:38:12.760 --> 00:38:16.810
Because what we need to do is actually
get down to the application binary

00:38:16.810 --> 00:38:19.100
itself down inside the app wrapper.

00:38:19.100 --> 00:38:25.840
So we can say .safari.app.contents
Mac OS Safari.

00:38:26.860 --> 00:38:31.660
The other syntax that I'm using to try to
be consistent here and show that they're

00:38:31.660 --> 00:38:34.150
environment variables is this setenv.

00:38:36.780 --> 00:38:39.630
So I'm not actually going
to run leaks in demo here,

00:38:39.630 --> 00:38:42.200
but this is what you
might see if you ran it.

00:38:42.460 --> 00:38:46.360
This is the example
application I'm going to use.

00:38:46.360 --> 00:38:47.340
I'll explain that in a second.

00:38:47.340 --> 00:38:49.120
So this is a typical output.

00:38:49.270 --> 00:38:53.150
It lists some information about
how many malloc nodes you have

00:38:53.150 --> 00:38:57.350
and how many bytes they have,
and then how much is being leaked.

00:38:57.720 --> 00:39:01.450
Now, in this case, it's not a lot,
but over the course of time,

00:39:01.510 --> 00:39:02.520
it could add up.

00:39:02.520 --> 00:39:08.080
So it then shows the pointer
where that leaked block is,

00:39:08.080 --> 00:39:11.350
what its size is,
and makes an attempt to tell

00:39:11.350 --> 00:39:15.260
you what type of block it is,
and then show you the contents,

00:39:15.260 --> 00:39:16.900
the initial contents of it.

00:39:16.970 --> 00:39:21.620
Now, because we had the malloc stack
logging environment variable set

00:39:21.620 --> 00:39:25.820
when we launched this application,
now I see the call trace.

00:39:25.880 --> 00:39:30.160
If you don't get the environment...
environment variables set properly,

00:39:30.160 --> 00:39:31.750
you won't see this.

00:39:33.280 --> 00:39:37.880
So the call stack here,
what I usually do is walk

00:39:38.020 --> 00:39:39.950
sort of from the bottom up.

00:39:39.960 --> 00:39:42.520
I look at the CFAllocate
or allocate and say,

00:39:42.520 --> 00:39:44.200
well, I didn't call that.

00:39:44.250 --> 00:39:48.000
CFRuntimeCreateInstance, well,
I didn't call that either.

00:39:48.040 --> 00:39:51.290
CFUR,
I just go backwards up to where I start

00:39:51.360 --> 00:39:53.760
to get to code that I'm familiar with.

00:39:53.760 --> 00:39:57.630
And this can take some exploring around.

00:39:57.640 --> 00:39:59.900
It can be a little bit
easier with malloc-debug,

00:39:59.900 --> 00:40:01.600
as we'll see in a second.

00:40:01.640 --> 00:40:05.900
But in this case,
maybe that add text to the text view,

00:40:05.900 --> 00:40:09.140
where that sounds different
than everything that's

00:40:09.140 --> 00:40:13.000
core foundation below it,
where we're copying a resource URL.

00:40:13.000 --> 00:40:18.440
And because it says it's an instance
of NSURL that's been leaked,

00:40:18.450 --> 00:40:22.790
that's a decent guess as
to where the leak might be.

00:40:23.700 --> 00:40:28.140
So this third technique I'm going
to talk about came specifically

00:40:28.260 --> 00:40:33.000
from trying to work out the leaks
in this MLTE showcase example.

00:40:33.010 --> 00:40:37.280
Now the MLTE showcase is a
standard developer examples,

00:40:37.300 --> 00:40:40.200
Carbon example on your system.

00:40:40.200 --> 00:40:45.010
This is the multilingual text
editor of the Carbon world.

00:40:45.090 --> 00:40:51.020
So I ran into a leak in this where,
as you'll see,

00:40:51.020 --> 00:40:56.020
the object was actually allocated
when the application said,

00:40:56.020 --> 00:40:59.700
load in my nib file,
and about 18 levels deep,

00:40:59.710 --> 00:41:02.470
it allocates an object
and it's being leaked.

00:41:03.160 --> 00:41:07.140
Well, I had no way of even
getting to that object,

00:41:07.140 --> 00:41:08.700
I didn't think.

00:41:08.700 --> 00:41:12.350
So it turns out this was
a retain release match.

00:41:12.550 --> 00:41:17.000
So I was able to launch the target
application under object alloc,

00:41:17.000 --> 00:41:21.160
turn on the reference counting so
that it would also be able to see and

00:41:21.160 --> 00:41:26.420
also record the retains and releases
in addition to allocates and frees.

00:41:26.450 --> 00:41:30.680
And then run the target application.

00:41:30.680 --> 00:41:35.190
In a terminal window, I ran leaks,
and then I could get the

00:41:35.220 --> 00:41:39.170
pointer of the leaked object,
find that in object alloc,

00:41:39.170 --> 00:41:41.550
and examine the retain release.

00:41:41.660 --> 00:41:44.540
So it's kind of an advanced
technique that we could probably

00:41:44.540 --> 00:41:47.650
make a bit easier in the future,
but it could be useful to you now.

00:41:47.860 --> 00:41:50.970
So let's see a demo here at this point.

00:41:50.980 --> 00:41:52.300
Thanks.

00:41:53.880 --> 00:41:57.920
So we'll shift over to the
MLTE showcase application.

00:41:58.200 --> 00:42:02.780
Now I've actually added a little
bit of code in here to exercise

00:42:03.270 --> 00:42:06.390
my application multiple times.

00:42:06.600 --> 00:42:08.450
I'm gonna run this under malloc-debug.

00:42:08.750 --> 00:42:12.640
It's already,
let's go ahead and do a build.

00:42:12.860 --> 00:42:14.710
Yep, it's built.

00:42:14.940 --> 00:42:18.240
Run this under malloc-debug.

00:42:20.240 --> 00:42:25.400
We can open this window
up a bit and say launch.

00:42:25.400 --> 00:42:28.170
So you see the window flash five times.

00:42:28.600 --> 00:42:35.280
This is one of our test team's favorite
techniques of using Apple scripts

00:42:35.460 --> 00:42:38.480
to control our applications to
do the same thing over and over

00:42:38.480 --> 00:42:40.200
and over again all night long.

00:42:40.200 --> 00:42:46.700
And then they say,
"I hammered your application

00:42:46.880 --> 00:42:54.110
all night like this,
and this problem resulted." So this

00:42:54.110 --> 00:42:54.110
is a very short mechanism of saying,
"Well, what would happen if the user..."

00:42:55.900 --> 00:43:08.700
[Transcript missing]

00:43:09.310 --> 00:43:15.380
So, as I've mentioned, this shows,
by default, a top-down view of how much

00:43:15.380 --> 00:43:20.590
memory got allocated where in the
call tree of your application.

00:43:21.500 --> 00:43:26.390
I can flip that around and I can say,
well, I want to see the bottom up.

00:43:26.540 --> 00:43:30.620
But instead, what I want to do is
come over here and say,

00:43:30.620 --> 00:43:32.640
well, actually, I want to see the leaks.

00:43:32.640 --> 00:43:34.640
Are there any leaks in this application?

00:43:34.640 --> 00:43:39.030
So it goes off and does this
static analysis of the state

00:43:39.120 --> 00:43:41.460
of the memory right now.

00:43:41.460 --> 00:43:46.270
We can walk down through and see, well,
it's leaking 424 bytes.

00:43:47.300 --> 00:43:50.880
Well, I can walk down through,
for example, quite a bit.

00:43:50.990 --> 00:43:55.920
But what I like to do
is invert the call tree.

00:43:55.920 --> 00:43:59.130
So those of you familiar with Shark,
this is equivalent to

00:43:59.190 --> 00:44:00.900
bottom up or the heavy view.

00:44:00.900 --> 00:44:03.980
And I can see that here's where
the actual allocation occurred.

00:44:03.980 --> 00:44:09.640
And here we can see the full name
of the function that I've selected.

00:44:09.660 --> 00:44:14.360
So walking backward,
we see a CFURL alloc.

00:44:14.360 --> 00:44:16.820
Core foundation.

00:44:17.330 --> 00:44:21.040
Core Foundation, Core Foundation.

00:44:21.880 --> 00:44:27.490
Okay,
so here we see CFBundleCopyResourceURL.

00:44:27.490 --> 00:44:29.640
That's the same as we
saw in the leaks output.

00:44:29.640 --> 00:44:34.030
And that is being called from AddImage.

00:44:34.030 --> 00:44:38.270
There's a little icon here next to
AddImage that shows us that we have

00:44:38.270 --> 00:44:39.620
source code available for that.

00:44:39.690 --> 00:44:44.370
So I can double click on that,
bring up the source code in Xcode.

00:44:44.470 --> 00:44:50.230
Now that was,
appears to be a URL that we're leaking,

00:44:50.240 --> 00:44:52.760
CFBundleCopyResourceURL.

00:44:52.760 --> 00:44:56.680
So it's just telling me that
somewhere in this function,

00:44:56.680 --> 00:45:02.120
we're calling CFCopyBundleResourceURL.

00:45:02.120 --> 00:45:05.780
Can I do that?

00:45:05.920 --> 00:45:06.200
Fine.

00:45:06.200 --> 00:45:13.120
Let me say, copy resource,
and you can probably already see it.

00:45:16.130 --> 00:45:21.000
So image URL here being
returned by CF Copy Bundle.

00:45:21.000 --> 00:45:25.980
So there's a copy going on here.

00:45:25.980 --> 00:45:29.550
If I select this, hmm.

00:45:29.900 --> 00:45:32.370
So we're copying,
but we're not releasing.

00:45:32.580 --> 00:45:35.500
So this one actually
appears to be fairly simple.

00:45:35.540 --> 00:45:40.440
So I can just add in a CF release
after our last use of this,

00:45:40.440 --> 00:45:42.990
and that will probably fix that issue.

00:45:43.020 --> 00:45:47.110
Before I rebuild,
is there anything else that's

00:45:47.110 --> 00:45:48.460
gonna be easy to fix here?

00:45:49.170 --> 00:45:56.330
Walking back this other path,
we see the CGColorCreate is being called.

00:45:56.710 --> 00:46:04.020
from down inside HITextView initialized,
and on and on.

00:46:04.310 --> 00:46:08.000
Now this is the one that's actually
coming out of the IB Carbon Runtime

00:46:08.170 --> 00:46:11.200
after we load the nib for a new window.

00:46:11.300 --> 00:46:14.200
Ooh, that sounds hard.

00:46:14.200 --> 00:46:16.290
I'll come back to that.

00:46:19.800 --> 00:46:24.700
So there's one other one here,
which is right in my code,

00:46:24.700 --> 00:46:28.280
CMLTE view data operator new.

00:46:28.540 --> 00:46:32.300
So apparently a C++
object being allocated.

00:46:32.540 --> 00:46:38.190
I want to see actually
the call site of that.

00:46:43.880 --> 00:46:48.800
So, operator new is being called
from this set up the text view.

00:46:48.800 --> 00:46:54.720
So, again,
since it wasn't too handy and didn't

00:46:54.720 --> 00:46:57.140
tell me exactly where it did the new.

00:46:57.140 --> 00:47:00.140
Okay, so again,
this example is copied straight

00:47:00.140 --> 00:47:02.160
out of developer examples Carbon.

00:47:02.380 --> 00:47:08.300
We do, when we set up a text view,
we're putting some data onto

00:47:08.300 --> 00:47:10.860
the side of that text view.

00:47:10.870 --> 00:47:14.470
And there's a big comment here that,
don't forget to dispose this

00:47:14.540 --> 00:47:17.380
when HITextView destructs.

00:47:17.390 --> 00:47:21.320
Well, if you build this example,
you'll actually find that the

00:47:21.320 --> 00:47:26.520
destructor never gets called because
they dispose the window without

00:47:26.600 --> 00:47:34.500
going to the trouble of finding,
of pulling the object back out and doing

00:47:34.500 --> 00:47:38.800
a delete on the data that we added to it.

00:47:38.960 --> 00:47:42.720
So I added a tear down
the text view method here.

00:47:42.720 --> 00:47:51.080
That gets the text view from the window,
retrieves the instance data

00:47:51.240 --> 00:47:54.000
and does a delete on that.

00:47:56.860 --> 00:48:00.320
And I've actually commented my
call out to that previously,

00:48:00.320 --> 00:48:03.990
so I'll uncomment that, save that.

00:48:04.020 --> 00:48:10.040
And so now I think that I've
fixed two leaks out of three.

00:48:10.220 --> 00:48:13.220
So let's go ahead and
quit out of the tools.

00:48:13.250 --> 00:48:17.360
Sorry, build.

00:48:20.780 --> 00:48:24.930
Oops, that got ran there.

00:48:24.940 --> 00:48:27.340
Build.

00:48:27.380 --> 00:48:31.060
Okay, let's run under malloc-debug again,
see how we did.

00:48:37.480 --> 00:48:41.500
For leaks,
so before we had about 428 bytes,

00:48:41.660 --> 00:48:43.460
now we've got 48.

00:48:43.500 --> 00:48:46.480
That's pretty good.

00:48:47.020 --> 00:48:52.000
So specifically, ooh,
it's that CGColorCreate.

00:48:52.000 --> 00:48:55.920
All I'm doing is loading the nib file in.

00:48:56.120 --> 00:49:00.110
So let's try a different approach.

00:49:00.940 --> 00:49:03.540
My allocation appears to be okay.

00:49:03.540 --> 00:49:09.020
I don't think I'm getting
that color myself.

00:49:12.270 --> 00:49:16.280
So let's run it under object alloc.

00:49:16.280 --> 00:49:23.920
This time through, we want to record the
reference counting as well.

00:49:23.920 --> 00:49:27.910
So the retain release calls,
and I'll also record the

00:49:27.910 --> 00:49:30.950
general allocations by library.

00:49:33.760 --> 00:49:36.160
So it runs a bit more
slowly under Object Alloc.

00:49:38.460 --> 00:49:40.970
And here we go.

00:49:41.060 --> 00:49:45.120
So now if I come into a terminal
window and run leaks on MLTE,

00:49:45.120 --> 00:49:48.360
I should find the right
application there.

00:49:48.360 --> 00:49:50.600
So there's a couple of them there.

00:49:50.600 --> 00:49:53.980
Let's grab one of these pointers.

00:49:54.540 --> 00:49:58.680
Now, one of the things that ObjectAlloc
does is it actually keeps these

00:49:58.680 --> 00:50:00.980
as events all the way through.

00:50:00.980 --> 00:50:04.500
So up here at the very top,
let me go ahead and

00:50:04.500 --> 00:50:05.940
pause the application.

00:50:05.940 --> 00:50:13.130
There's a scroller here at the top that
lets you scroll back and forth through

00:50:13.130 --> 00:50:15.460
the event history of the application.

00:50:15.460 --> 00:50:19.700
So you can actually make
these bars go back and forth.

00:50:20.040 --> 00:50:25.980
So I want to find the last
allocation event for this pointer.

00:50:26.300 --> 00:50:31.030
- So I can do a previous,
and we see that it was

00:50:31.040 --> 00:50:34.040
way back here in time.

00:50:35.300 --> 00:50:41.850
Bring up the inspector and I can
see what the call tree of that is.

00:50:42.110 --> 00:50:46.970
It's a CG color that's being released.

00:50:47.000 --> 00:50:51.150
It's a CF release event
at this point in the code.

00:50:52.840 --> 00:50:57.800
So if I were to say,
I want to sort by that.

00:50:57.800 --> 00:51:02.660
Now we can see that having checked,
show me the allocations by library.

00:51:02.660 --> 00:51:04.950
There's a lot of ATS there, for example.

00:51:04.960 --> 00:51:08.620
This should be a current object.

00:51:08.970 --> 00:51:15.380
So if I come down here to CG color,
somewhere in there is going to be,

00:51:15.380 --> 00:51:20.830
and we'll try to integrate this
functionality better in the future.

00:51:21.960 --> 00:51:27.350
But eventually you'd see that there
was a retain release happening from

00:51:27.350 --> 00:51:34.530
here where we copy the background
color into previous color.

00:51:34.900 --> 00:51:40.060
We create a different color with a
modified alpha from that new color.

00:51:40.440 --> 00:51:43.200
We set the background color,
which will release the old one,

00:51:43.200 --> 00:51:47.620
retain the new one,
and then we're releasing the new color.

00:51:48.120 --> 00:51:53.420
We did a copy to get the old color,
but we never released the

00:51:53.420 --> 00:51:55.090
old color after we copied it.

00:51:55.100 --> 00:51:57.100
This is pretty subtle.

00:51:57.100 --> 00:52:01.770
This is in my application code here,
where I didn't allocate this object,

00:52:01.790 --> 00:52:03.090
but I did copy it.

00:52:03.100 --> 00:52:07.280
It required a somewhat more
advanced technique to come in

00:52:07.280 --> 00:52:09.530
and find what the issue was.

00:52:13.740 --> 00:52:18.700
So I can release previous color,
quit the app,

00:52:19.480 --> 00:52:25.660
which is paused and object-alic.

00:52:27.170 --> 00:52:34.400
Now if I build again and run it,
let's say, under malloc-debug,

00:52:34.400 --> 00:52:38.740
hopefully we'll see no
leaks this time around.

00:52:38.740 --> 00:52:43.990
No leaks.

00:52:54.080 --> 00:52:56.660
So, memory usage problems.

00:52:56.660 --> 00:52:58.000
There's a variety of other things here.

00:52:58.000 --> 00:53:01.490
There's not so much performance issues,
but if you have buffer overruns or

00:53:01.490 --> 00:53:06.040
underruns or access uninitialized
memory or freed memory,

00:53:06.040 --> 00:53:11.380
those can be nasty problems to find
because they're very often intermittent.

00:53:11.380 --> 00:53:15.940
It depends on what the content of
memory is or what you overrun into.

00:53:15.940 --> 00:53:19.080
Those can be really hard problems to fix.

00:53:19.800 --> 00:53:23.860
So, what we really want to do is try
to make them happen all the time.

00:53:23.860 --> 00:53:25.460
Then you can debug them.

00:53:25.480 --> 00:53:28.560
So,
some techniques that Mac OS X provides

00:53:28.560 --> 00:53:32.930
to help you with this is the
GuardMalloc debugging library,

00:53:32.930 --> 00:53:36.630
some environment variables
on the Malloc system,

00:53:36.630 --> 00:53:41.660
and watchpoints in GDB that might
help you find memory stompers.

00:53:41.660 --> 00:53:45.700
Watchpoints are a relatively
new feature for us.

00:53:45.700 --> 00:53:47.490
I'm not going to go
into it in detail here,

00:53:47.490 --> 00:53:49.480
but you can read the Xcode documentation.

00:53:49.800 --> 00:53:52.110
about that.

00:53:53.210 --> 00:53:58.210
So the way guard malloc works is
that each and every allocation that

00:53:58.210 --> 00:54:02.460
your application makes goes onto
a separate virtual memory page.

00:54:02.600 --> 00:54:05.440
So each page is 4K.

00:54:05.970 --> 00:54:11.170
So if you're doing a 16 byte allocation,
that gets 4K allocated.

00:54:11.380 --> 00:54:17.170
It leaves the page before that and
the page after that unallocated.

00:54:17.280 --> 00:54:22.980
So, and then when the block is freed,
we deallocate that page.

00:54:23.000 --> 00:54:26.520
And if your code tries to
access a deallocated page,

00:54:26.520 --> 00:54:29.000
you'll get an immediate crash.

00:54:29.080 --> 00:54:32.650
So unfortunately this causes
your application to run a lot

00:54:32.720 --> 00:54:38.320
slower because it's using a lot
more pages of virtual memory,

00:54:38.380 --> 00:54:43.080
but hopefully that'll save you human
time of attempting to figure out a

00:54:43.080 --> 00:54:45.960
way to find this problem yourself.

00:54:46.490 --> 00:54:51.070
So by default,
it's set up to catch buffer overruns.

00:54:51.170 --> 00:54:56.700
It aligns allocations with the end
of the page because buffer overruns

00:54:56.700 --> 00:54:58.710
are more common than underruns.

00:54:58.800 --> 00:55:00.900
So if you walk off the
end of that VM page,

00:55:00.900 --> 00:55:05.010
then you get to the
unallocated page after that,

00:55:05.010 --> 00:55:06.940
and you get a crash.

00:55:07.430 --> 00:55:20.200
If you need to catch a buffer under run,
you might try setting an environment

00:55:20.200 --> 00:55:20.220
variable to say malloc protect before.

00:55:20.300 --> 00:55:23.410
Some of our system frameworks,
some applications don't really

00:55:23.410 --> 00:55:28.110
like to work with memory that we
have pre-initialized to odd values.

00:55:28.120 --> 00:55:30.220
So we don't do this
next one all the time,

00:55:30.220 --> 00:55:34.620
but you can set an environment variable
that says fill the newly allocated

00:55:34.720 --> 00:55:40.540
memory with values that would cause a
crash if they were used inappropriately.

00:55:41.640 --> 00:55:46.620
And if you do call free
twice on the same block,

00:55:46.660 --> 00:55:49.300
or if you try to free a block
that was never allocated,

00:55:49.300 --> 00:55:53.950
we've changed guard malloc so that it
immediately crashes into the debugger.

00:55:55.410 --> 00:55:58.730
So because we're trying to help
you have it crash all the time,

00:55:58.730 --> 00:56:01.340
you'll normally want to
use this from a debugger.

00:56:01.340 --> 00:56:07.580
Easiest way is from within Xcode in
the debug menu item to say enable guard

00:56:07.660 --> 00:56:11.340
malloc and then just debug as normal.

00:56:11.800 --> 00:56:17.080
If you're using GDB at the command line,
you can set the environment

00:56:17.090 --> 00:56:23.460
variable there with the GDB syntax,
set space, env space, variable value.

00:56:23.460 --> 00:56:28.330
So this is saying insert the guard
malloc library into the application.

00:56:28.340 --> 00:56:32.910
So that's userlib libg malloc.dileb.

00:56:32.920 --> 00:56:38.180
So as with malloc debug,
you no longer need flat namespace.

00:56:38.180 --> 00:56:41.310
So if you were using this before
and setting that variable,

00:56:41.500 --> 00:56:42.720
you no longer need to do that.

00:56:42.740 --> 00:56:47.380
So the libg malloc man page has
much more information about this.

00:56:48.780 --> 00:56:55.020
I've mentioned environment variables
that control the malloc system.

00:56:55.020 --> 00:56:57.380
These are all documented
on the malloc man page.

00:56:57.380 --> 00:57:01.000
Previously I mentioned
malloc pre-scribble that

00:57:01.000 --> 00:57:05.010
says when I allocate a block,
then write a certain sort

00:57:05.010 --> 00:57:07.750
of garbage value into that.

00:57:08.640 --> 00:57:11.900
When I'm freeing a block,
then malloc scribble

00:57:11.900 --> 00:57:13.600
says write into that.

00:57:13.790 --> 00:57:17.260
If you are somehow trashing
the memory pointers,

00:57:17.260 --> 00:57:22.290
the metadata of the malloc heap itself,
we can help to catch that.

00:57:22.360 --> 00:57:25.570
And for the large blocks,
there's a way to put

00:57:25.610 --> 00:57:30.760
guard pages around that,
but again, that's only the large blocks.

00:57:30.760 --> 00:57:33.810
So this won't help catch
nearly as many problems,

00:57:33.810 --> 00:57:37.550
but it runs at the full speed
of your application at least.

00:57:37.580 --> 00:57:38.600
So.

00:57:38.640 --> 00:57:41.330
It could be helpful
in some circumstances.

00:57:41.490 --> 00:57:44.020
So anyway,
I've given you a kind of a whirlwind

00:57:44.020 --> 00:57:48.480
tour of a variety of aspects here,
reviewed the performance

00:57:48.480 --> 00:57:49.550
analysis process.

00:57:49.730 --> 00:57:53.000
We encourage you to be
disciplined about looking at the

00:57:53.040 --> 00:57:55.360
performance of your application.

00:57:55.360 --> 00:57:57.010
There's a lot of tools that you've seen.

00:57:57.020 --> 00:58:00.400
These plus others,
read the documentation.

00:58:00.400 --> 00:58:03.300
They can really help you
analyze your memory use,

00:58:03.680 --> 00:58:08.620
find memory leaks,
and debug hard-to-catch memory problems.

00:58:08.640 --> 00:58:13.110
So with those,
we help you continue to turn out great

00:58:13.120 --> 00:58:17.590
applications for both PowerPC and Intel.

00:58:26.470 --> 00:58:30.800
So, for more information,
the standard page here.

00:58:30.860 --> 00:58:33.140
You've probably seen that a lot of times.

00:58:33.140 --> 00:58:37.430
There's a feedback form
immediately after this at 5:00.

00:58:37.740 --> 00:58:39.640
for developer tools.

00:58:39.770 --> 00:58:42.920
Contact information,
you can contact Xavier Legros,

00:58:42.920 --> 00:58:44.080
our technology manager.

00:58:44.080 --> 00:58:50.050
You can also send feedback to the
performance tools feedback list at

00:58:50.220 --> 00:58:56.040
perf tools-feedback@group.apple.com
or the Xcode feedback list

00:58:56.390 --> 00:58:58.180
or the Xcode users list.

00:58:58.510 --> 00:59:00.560
So there's a lot of helpful
resources out there.
WEBVTT

00:00:02.920 --> 00:00:04.370
Okay, Python.

00:00:04.740 --> 00:00:06.950
Does everyone here know what Python is?

00:00:07.060 --> 00:00:10.800
Python is one of the
old scripting languages,

00:00:10.850 --> 00:00:12.880
but it's very cool.

00:00:12.940 --> 00:00:16.030
It's dynamically typed,
just like Objective-C is,

00:00:16.230 --> 00:00:19.400
except it's entirely done at runtime.

00:00:19.400 --> 00:00:23.030
It's a powerful high-level language,
so high-level that it often is

00:00:23.030 --> 00:00:24.940
identical to this pseudocode.

00:00:25.080 --> 00:00:27.860
integrates extremely
well with Objective-C,

00:00:27.860 --> 00:00:31.650
so well that PyObjC applications
are completely indistinguishable

00:00:31.830 --> 00:00:35.700
from their Objective-C counterparts,
even to Interface Builder.

00:00:35.750 --> 00:00:37.930
You can use it to quickly develop,
extend,

00:00:38.030 --> 00:00:39.880
and test applications for Mac OS X.

00:00:39.880 --> 00:00:43.110
Because it's so dynamic,
you can change things at runtime.

00:00:44.300 --> 00:00:48.440
In this session,
you'll learn why you should use Python,

00:00:48.510 --> 00:00:51.970
where you can find it on Mac OS X,
Python syntax for

00:00:51.970 --> 00:00:56.000
Objective-C programmers,
Cocoa applications in Python,

00:00:56.080 --> 00:01:01.990
mixed Python Objective-C applications,
and writing plugins entirely in Python.

00:01:03.400 --> 00:01:04.660
Why Python?

00:01:04.950 --> 00:01:07.290
Python saves you time.

00:01:07.740 --> 00:01:10.940
Python is interpretive, interactive,
object-oriented.

00:01:11.190 --> 00:01:14.390
The syntax is very powerful,
but also very clear.

00:01:14.470 --> 00:01:16.780
It's got excellent support
for data structures:

00:01:16.850 --> 00:01:19.440
dictionaries, lists, sets, everything.

00:01:19.440 --> 00:01:20.540
It's all there.

00:01:20.680 --> 00:01:23.710
It's dynamically typed,
and it's garbage collected.

00:01:23.820 --> 00:01:25.680
You don't have to wait
for Objective-C to get it.

00:01:25.680 --> 00:01:27.680
You can have it now.

00:01:28.970 --> 00:01:32.690
Python on Mac OS X has unparalleled
integration with Objective-C.

00:01:32.850 --> 00:01:35.360
The bridge actually works.

00:01:37.760 --> 00:01:41.500
is already used in real
shrink-wrapped applications,

00:01:41.500 --> 00:01:45.500
and it's cross-platform
when you want it to be,

00:01:45.500 --> 00:01:45.500
even with this Intel stuff.

00:01:47.880 --> 00:01:48.670
Less code.

00:01:48.880 --> 00:01:51.870
Since Python syntax is so powerful,
and it does a whole

00:01:51.970 --> 00:01:55.400
lot of things for you,
you'll have shorter development cycles,

00:01:55.450 --> 00:01:58.800
fewer bugs, better tests,
and more features.

00:01:58.930 --> 00:02:01.870
A lot of people, even if they have
Objective-C applications,

00:02:01.870 --> 00:02:06.100
are now writing their tests in Python,
because it's so much clearer.

00:02:07.260 --> 00:02:08.300
Where is it?

00:02:08.350 --> 00:02:10.580
Python ships with Mac OS X.

00:02:10.730 --> 00:02:16.480
Mac OS 10.4 comes with
Python 2.3.5 as a framework build

00:02:16.570 --> 00:02:18.700
in system library frameworks.

00:02:18.730 --> 00:02:24.950
It comes with WXPython, TkEnter,
it comes with an Apple proprietary

00:02:24.950 --> 00:02:27.940
core graphics extension,
but it's missing some

00:02:27.940 --> 00:02:33.060
useful things like BSDDB,
the Berkeley DB wrapper, and Readline,

00:02:33.090 --> 00:02:36.760
because that's got that
GPL thing going on.

00:02:38.110 --> 00:02:41.960
The current Python version
is not Python 2.3.5.

00:02:42.030 --> 00:02:44.840
The current Python is 2.4.1.

00:02:44.890 --> 00:02:47.560
Python 2.4 has a lot
of cool new features,

00:02:47.710 --> 00:02:53.330
decorators, built-in set type,
and a lot of good things

00:02:53.330 --> 00:02:54.440
that you probably want.

00:02:54.440 --> 00:02:57.430
So,
if you want to get the latest Python 2.4,

00:02:57.430 --> 00:03:00.260
you can get the installer
from Python.org,

00:03:00.390 --> 00:03:03.100
and this is also a framework build,
just like the Apple one,

00:03:03.240 --> 00:03:07.000
except it's the latest,
least amount of bugs, etc., etc.

00:03:07.260 --> 00:03:12.570
This one comes with a working TK-Enter,
but it also comes with a working

00:03:12.570 --> 00:03:15.040
BSTDB and a working readline.

00:03:15.220 --> 00:03:17.980
So, if you press up in the
command interpreter,

00:03:18.200 --> 00:03:21.900
you'll get the last command
and not some ASCII garbage.

00:03:24.350 --> 00:03:26.800
You can, of course,
install the readline extension

00:03:26.930 --> 00:03:29.170
for the Apple Python,
and that's available at

00:03:29.320 --> 00:03:31.440
pythonmac.org/packages.

00:03:31.440 --> 00:03:32.780
We'll get to that later.

00:03:32.920 --> 00:03:38.540
So, you can use this Python 2.4 to
create Mac OS 10.3 compatible apps.

00:03:38.540 --> 00:03:42.170
Currently, Python does not have good
integration with the SDKs,

00:03:42.300 --> 00:03:46.790
so in order to build X.3
compatible apps on X.4,

00:03:46.790 --> 00:03:49.300
you need to build everything on X.3.

00:03:49.370 --> 00:03:53.420
You can assemble your application on X.4,
but all of its constituent

00:03:53.450 --> 00:03:57.770
components that include compiled
stuff needs to be compiled on X.3.

00:03:57.940 --> 00:04:00.530
Fortunately,
I've done a lot of that for you guys,

00:04:00.530 --> 00:04:04.210
and I have a wealth of extensions
on pythonmac.org/packages,

00:04:04.210 --> 00:04:08.190
and also the Python 2.4.1
build is available,

00:04:08.350 --> 00:04:10.140
and that's built on X.3.

00:04:10.400 --> 00:04:13.830
This one gets installed into the user,
not the user location,

00:04:13.830 --> 00:04:17.860
the system location for administrators
in library frameworks Python,

00:04:17.860 --> 00:04:19.300
and a couple of sim
links to the internet.

00:04:19.300 --> 00:04:22.470
interpreter and use your local bin.

00:04:24.300 --> 00:05:36.600
[Transcript missing]

00:05:37.600 --> 00:05:38.700
Python data structures.

00:05:38.790 --> 00:05:41.500
Here's where I get into all
the Objective-C Python stuff.

00:05:41.650 --> 00:05:44.100
Python data structures are a
lot like the data structures

00:05:44.100 --> 00:05:45.700
you'll find in Foundation.

00:05:45.800 --> 00:05:48.170
You've got the list,
which is a mutable type

00:05:48.410 --> 00:05:50.350
that's not hashable.

00:05:50.750 --> 00:05:54.910
The list syntax is square brackets
and commas between the elements.

00:05:55.010 --> 00:05:59.820
So it's just like C array,
but it's a lot more convenient to

00:05:59.900 --> 00:06:04.570
do than the NSMutable array version,
as you can see.

00:06:04.920 --> 00:06:09.930
The list has quite a few methods, append,
etc.

00:06:10.350 --> 00:06:12.640
They're not named the same
as the Objective-C ones.

00:06:12.710 --> 00:06:15.040
They're often more terse.

00:06:15.130 --> 00:06:17.640
But it's equivalent.

00:06:17.750 --> 00:06:20.110
The tuple is the immutable version.

00:06:20.290 --> 00:06:26.040
It's hashable only if its contents are,
and it's just like a normal NSArray.

00:06:26.200 --> 00:06:32.430
The syntax for a tuple is the comma.

00:06:32.730 --> 00:06:36.520
The parentheses are only used
for clarity and unambiguity,

00:06:36.750 --> 00:06:39.600
but really, the operator to create
a tuple is the comma.

00:06:39.720 --> 00:06:43.320
So if you want a tuple with one element,
you still need that comma.

00:06:43.380 --> 00:06:46.660
So typically,
if you have a tuple with one element,

00:06:46.690 --> 00:06:53.450
it's going to be:
. That confuses a lot of people early on,

00:06:53.450 --> 00:06:54.990
but you get used to it.

00:06:55.830 --> 00:06:58.940
The dictionary in Python is
one of the types that the

00:06:58.940 --> 00:07:00.700
language is basically based on.

00:07:00.850 --> 00:07:04.740
All objects have a dictionary for its
instance variables and its methods,

00:07:04.800 --> 00:07:06.100
and classes have the same.

00:07:06.240 --> 00:07:09.100
The namespace for modules,
it's all based on dictionaries.

00:07:09.250 --> 00:07:12.400
Therefore, the Python dictionary
implementation is very,

00:07:12.420 --> 00:07:13.000
very fast.

00:07:13.130 --> 00:07:15.600
And it's very good and easy to use.

00:07:15.690 --> 00:07:19.690
It's a mutable type, not hashable,
and unlike the NSMutable

00:07:19.760 --> 00:07:23.270
dictionary and NSDictionary,
it does not copy its keys.

00:07:23.350 --> 00:07:26.350
So the keys in a Python dictionary
must be hashable.

00:07:26.510 --> 00:07:29.730
So that can cause you some
slight issues if you're bridging

00:07:29.730 --> 00:07:32.790
Python and Objective-C code,
if you pass Python dicks around,

00:07:32.840 --> 00:07:35.180
because those Python dicks
are not going to copy the keys

00:07:35.660 --> 00:07:37.300
of your Objective-C stuff.

00:07:37.370 --> 00:07:42.110
However,
since we do bridge the mutable string

00:07:42.220 --> 00:07:48.560
as a Python hashable immutable string,
it's not often a problem.

00:07:49.650 --> 00:07:52.500
The Unicode object in Python is
what you use to store text.

00:07:52.680 --> 00:07:55.200
Unfortunately,
it's not the only thing that

00:07:55.200 --> 00:07:56.420
can be used to store text.

00:07:56.500 --> 00:07:59.410
The Unicode object stores characters,
not bytes.

00:07:59.480 --> 00:08:02.370
To denote a Unicode object,
it's a string literal

00:08:02.370 --> 00:08:03.450
with a "u" in front of it.

00:08:03.500 --> 00:08:07.860
The Unicode object syntax supports
quite a few different ways to escape it.

00:08:07.860 --> 00:08:11.090
You've got the hexadecimal escape,
you've got the Unicode

00:08:11.110 --> 00:08:13.870
hexadecimal escape,
and then you've got the nice

00:08:13.880 --> 00:08:16.830
named Unicode literal syntax,
which makes it really obvious which

00:08:16.850 --> 00:08:20.530
character you're putting in there,
because you have to name it out.

00:08:23.000 --> 00:08:26.660
The string type in Python,
unfortunately named,

00:08:26.660 --> 00:08:30.050
is an immutable type that stores bytes.

00:08:30.090 --> 00:08:32.000
But these bytes can act like characters.

00:08:32.150 --> 00:08:35.710
Hopefully this is due
to just legacy reasons,

00:08:35.770 --> 00:08:41.990
because Python prior to 1.6 did not
have any Unicode support at all.

00:08:42.000 --> 00:08:45.280
So they had this bytes type,
which is only really

00:08:45.280 --> 00:08:49.290
good for doing English,
because the encoding is

00:08:49.290 --> 00:08:51.500
completely ambiguous.

00:08:51.610 --> 00:08:54.090
So you want to avoid this
if you're representing text,

00:08:54.110 --> 00:08:56.950
unless it's just some sort of
literal in your source code,

00:08:57.040 --> 00:08:58.840
like the name of a method
or something like that.

00:08:59.030 --> 00:09:02.250
Because still those are
based on the str type,

00:09:02.260 --> 00:09:06.740
so you can't have a method
named the copyright character.

00:09:06.740 --> 00:09:08.760
It still has to be regular strings.

00:09:09.090 --> 00:09:11.750
These are equivalent to
initializing an enterprise.

00:09:11.760 --> 00:09:13.760
So you can't have an
NSString with a C string,

00:09:13.760 --> 00:09:15.760
but they're also equivalent to an NSData.

00:09:15.800 --> 00:09:17.760
It really depends on how you use it.

00:09:17.760 --> 00:09:20.740
So if you're bridging data
types over to Objective-C,

00:09:20.800 --> 00:09:21.760
you can't just use the str type.

00:09:21.760 --> 00:09:24.500
You'll have to wrap that in a buffer.

00:09:25.340 --> 00:09:28.640
When we bridge these stereotypes,
we bridge them as the

00:09:28.640 --> 00:09:33.010
default foundation encoding,
which can be whatever.

00:09:33.260 --> 00:09:37.900
But typically, as defined in the
documentation right now,

00:09:37.900 --> 00:09:40.110
the default is Mac Roman.

00:09:41.460 --> 00:09:42.420
Python numbers.

00:09:42.720 --> 00:09:44.460
Integers and floats are a mutable type.

00:09:44.750 --> 00:09:47.860
The extent of a
Python integer is a C-long.

00:09:48.000 --> 00:09:50.340
The Python float is a C-double.

00:09:50.450 --> 00:09:56.340
The syntax for using these
is just the obvious syntax.

00:09:56.340 --> 00:09:58.890
You write the number down.

00:09:59.760 --> 00:10:03.630
If you add floats and ints together,
that works.

00:10:03.640 --> 00:10:08.140
If you divide an integer by an integer,
you don't get a float yet,

00:10:08.200 --> 00:10:09.580
but you will soon.

00:10:09.950 --> 00:10:14.880
If you want that behavior now,
you can do from future import division.

00:10:14.930 --> 00:10:18.030
If you want the integer behavior back,
you simply use the

00:10:18.140 --> 00:10:22.350
double division operator,
the // which is integer division.

00:10:24.320 --> 00:10:27.500
The bool type in
Python is just an integer,

00:10:27.500 --> 00:10:30.940
except there's two singletons of it,
true and false,

00:10:30.940 --> 00:10:34.410
that have a nice representation
if you print it out.

00:10:36.400 --> 00:10:40.140
And the long type in Python is
an immutable number type.

00:10:40.140 --> 00:10:43.660
It has no C equivalent because
it has infinite extent.

00:10:43.660 --> 00:10:46.020
You can use this to represent
really large numbers,

00:10:46.020 --> 00:10:47.940
as large as you want to.

00:10:47.940 --> 00:10:53.290
There's no limit to it other than the
memory that you have and your patience.

00:10:53.830 --> 00:10:57.010
To denote a long number,
you simply put a big fat L on the end,

00:10:57.240 --> 00:10:58.300
and then it's long.

00:10:58.500 --> 00:11:01.790
Python will automatically promote
numbers to longs if they get big enough.

00:11:01.860 --> 00:11:03.800
Well, integers anyway.

00:11:03.860 --> 00:11:08.200
But that behavior is relatively recent.

00:11:08.260 --> 00:11:11.910
But Mac OS 10.4 ships
with a recent Python.

00:11:12.850 --> 00:11:18.240
The NUN type is a mutable singleton
which is used like the NSNULL,

00:11:18.240 --> 00:11:21.040
but other times it's
used like nil or null,

00:11:21.130 --> 00:11:24.400
though it won't receive messages
like it does in Objective-C.

00:11:24.460 --> 00:11:31.890
The NUN is just used as a placeholder,
like void, it denotes nothing there.

00:11:34.600 --> 00:11:36.200
Okay, Python syntax.

00:11:36.210 --> 00:11:41.140
Python syntax is a little foreign because
it doesn't use those squiggly braces

00:11:41.220 --> 00:11:43.940
for anything but dictionary syntax.

00:11:44.020 --> 00:11:49.900
Okay, and you're going to use
indentation instead of braces.

00:11:51.000 --> 00:11:53.270
Colons and indentation denote blocks.

00:11:53.390 --> 00:11:55.700
So you put a colon there,
and then you indent,

00:11:55.740 --> 00:11:56.660
and that's your block.

00:11:56.660 --> 00:12:00.120
It's equivalent to your curly braces,
except you type a little less.

00:12:00.220 --> 00:12:02.700
Because in other languages,
you're going to be doing

00:12:02.700 --> 00:12:05.400
the indentation anyway,
so it saves you the trouble.

00:12:05.590 --> 00:12:08.340
It also makes it nice and easy to read,
because you don't have those

00:12:08.340 --> 00:12:11.680
extra characters flannel around,
and if the indentation is wrong,

00:12:11.680 --> 00:12:13.500
your program simply won't run.

00:12:13.680 --> 00:12:18.290
So, if it looks good,
it probably works good too.

00:12:19.100 --> 00:12:21.100
Python variables.

00:12:21.140 --> 00:12:24.150
There's no type declaration,
and everything is an object,

00:12:24.180 --> 00:12:26.740
even those integers and
none and everything else.

00:12:26.850 --> 00:12:29.420
There's no value types,
everything is an object,

00:12:29.420 --> 00:12:31.310
everything is done by reference.

00:12:31.430 --> 00:12:34.400
It's just like everything
was an id and Objective-C.

00:12:34.420 --> 00:12:36.760
That's how you would do it in Python.

00:12:39.230 --> 00:12:41.100
Functions are first-class objects.

00:12:41.190 --> 00:12:42.700
That means that you
can pass them anywhere.

00:12:42.700 --> 00:12:46.280
You don't have to pass these silly
invocation objects around that bind an

00:12:46.280 --> 00:12:47.960
object and a selector and all that stuff.

00:12:47.960 --> 00:12:50.720
You simply just pass the
reference to the function.

00:12:50.720 --> 00:12:55.820
This means that Python functions
are instance variables because

00:12:55.820 --> 00:12:59.970
they're just first-class objects,
so there was no reason to have separate

00:12:59.970 --> 00:13:02.220
namespaces for methods and IVARs.

00:13:02.220 --> 00:13:05.750
So that's another thing that you
have to take note of if you're

00:13:05.750 --> 00:13:09.130
bridging Python and Objective-C,
is that Python does not have a

00:13:09.130 --> 00:13:12.790
separate namespace for selectors,
so you're not going to be writing

00:13:12.790 --> 00:13:16.270
these accessors that have the
same IVAR name as the method name.

00:13:16.280 --> 00:13:20.070
So what you do in Python is
you have these cool first-class

00:13:20.070 --> 00:13:24.390
objects called descriptors,
which can basically return something

00:13:24.390 --> 00:13:26.790
else if you get them off of an object.

00:13:26.800 --> 00:13:31.670
So you have the convenience
of the getItem syntax,

00:13:31.670 --> 00:13:34.950
like object.property,
but you have the power

00:13:34.980 --> 00:13:36.520
of using an accessor.

00:13:36.520 --> 00:13:42.380
So it's effectively like any
attribute reference in Python can

00:13:42.380 --> 00:13:45.090
be a key-value coding path.

00:13:46.570 --> 00:13:51.250
And Python functions take
positional and/or keyword arguments.

00:13:51.370 --> 00:13:54.300
Positional arguments are like
what you have in Objective-C or C.

00:13:54.510 --> 00:13:57.130
The arguments have to
be all there in a row.

00:13:57.200 --> 00:14:00.580
You also have keyword arguments,
which are similar in

00:14:00.660 --> 00:14:03.730
concept to selectors,
except they can be given in

00:14:03.730 --> 00:14:07.350
any order like a dictionary,
which also means we can't use

00:14:07.510 --> 00:14:13.570
that as the syntax for the bridge,
because the order is arbitrary,

00:14:13.570 --> 00:14:16.500
since it's however it
ends up being hashed.

00:14:16.620 --> 00:14:21.270
To denote positional
arguments of variable length,

00:14:21.270 --> 00:14:22.820
you can just put a
star in front of there.

00:14:22.870 --> 00:14:26.480
You don't have to do dot dot
dot and grab things off of this

00:14:26.480 --> 00:14:30.970
crazy built-in compiler local,
any of that stuff.

00:14:32.020 --> 00:14:33.370
Classes in Python.

00:14:33.410 --> 00:14:35.230
The classes in Python have
their interface and

00:14:35.230 --> 00:14:37.200
implementation as the same thing.

00:14:37.270 --> 00:14:39.990
You don't have to write your class twice.

00:14:40.100 --> 00:14:44.320
Methods are instance variables,
and in every method you define

00:14:44.320 --> 00:14:46.580
the self variable explicitly.

00:14:46.720 --> 00:14:49.460
This is because methods
are just functions.

00:14:49.460 --> 00:14:52.170
They just happen to be living
on classes at the time.

00:14:52.340 --> 00:14:54.670
So,
it's very explicit as to what happens.

00:14:54.750 --> 00:14:56.900
There's nothing magical involved.

00:14:57.020 --> 00:15:01.210
It's just the first argument is self.

00:15:02.690 --> 00:15:05.200
Iteration in Python is very nice.

00:15:05.380 --> 00:15:09.560
You have all of these iteration
concepts bundled into one thing:

00:15:09.560 --> 00:15:11.280
the iterator protocol.

00:15:11.360 --> 00:15:14.700
The iterator protocol are these
objects that have a next method,

00:15:14.790 --> 00:15:17.770
and the next method returns the
next object that's expected.

00:15:17.900 --> 00:15:22.090
So rather than having a couple
different ways to write loops,

00:15:22.090 --> 00:15:25.570
for loops and while loops,
to iterate over something,

00:15:25.710 --> 00:15:27.040
you just have one.

00:15:27.150 --> 00:15:31.400
And the syntax for that
is for item in iterable.

00:15:31.520 --> 00:15:34.980
So if you're going to do
a for loop with numbers,

00:15:35.090 --> 00:15:39.730
like for zero, end here, step this way,
you'll just use a range

00:15:39.730 --> 00:15:43.170
object or an x range object,
which is basically the

00:15:43.170 --> 00:15:44.760
same as the C syntax.

00:15:44.840 --> 00:15:49.230
The range object takes a length, a start,
and a stop,

00:15:49.450 --> 00:15:51.970
just like the C iteration syntax does.

00:15:52.230 --> 00:15:54.680
But the other cool thing is
these same for loops can be

00:15:54.680 --> 00:15:56.310
used to iterate over anything.

00:15:56.410 --> 00:16:00.850
You can iterate over lists,
you can iterate over dictionary keys,

00:16:00.930 --> 00:16:02.860
you can iterate over iterable objects.

00:16:03.010 --> 00:16:05.600
And you can build these
iterable objects yourself.

00:16:05.640 --> 00:16:11.790
You can iterate over generators,
which are very cool Python objects.

00:16:11.930 --> 00:16:15.350
If you define a function and you
write the word yield in there,

00:16:15.470 --> 00:16:19.340
the statement yield,
and you do that several times,

00:16:19.340 --> 00:16:21.960
and when you call it,
you get this generator object.

00:16:22.020 --> 00:16:25.670
And then every time you iterate over that
generator object by calling its next,

00:16:25.680 --> 00:16:30.020
implicitly or explicitly,
implicitly with the syntax like this,

00:16:30.050 --> 00:16:34.180
it'll return the next
value that you yielded.

00:16:34.180 --> 00:16:37.720
So you can use this to build
something like coroutines with a

00:16:37.820 --> 00:16:41.000
little more safety than you'll get
if you do it in C with set jump,

00:16:41.090 --> 00:16:43.840
long jump, and all that craziness.

00:16:44.740 --> 00:16:48.540
Getting items out of dictionaries and
lists in Python uses the same syntax.

00:16:48.650 --> 00:16:50.890
It's just the square bracket syntax.

00:16:51.020 --> 00:16:56.500
So you get the first item out of a list
with list . Last item out of a list,

00:16:56.600 --> 00:17:00.280
you can do -1,
or you can get the length of the list -1.

00:17:00.360 --> 00:17:02.690
The syntax for dictionaries is the same.

00:17:02.760 --> 00:17:05.800
You just put the key inside
of the square brackets.

00:17:05.970 --> 00:17:09.860
In Objective-C,
you have the methods obj.inx and

00:17:09.860 --> 00:17:12.360
valueForKey and all that stuff.

00:17:12.490 --> 00:17:16.440
But in Python, it's the same concept,
and you do it the same way.

00:17:16.580 --> 00:17:20.080
Unlike JavaScript,
the arrays and dictionaries

00:17:20.080 --> 00:17:22.280
are actually different types.

00:17:22.380 --> 00:17:24.790
So you don't have lists
with holes in them,

00:17:24.800 --> 00:17:27.080
because you don't have nice syntax.

00:17:27.180 --> 00:17:30.610
The lists are the same.

00:17:32.500 --> 00:17:35.210
Slicing is available for lists
and anything that wants to

00:17:35.270 --> 00:17:36.480
implement the slicing protocol.

00:17:36.500 --> 00:17:40.380
Slicing is basically unlike anything
you've ever seen anywhere else,

00:17:40.380 --> 00:17:43.640
unless you've used very
esoteric languages.

00:17:43.640 --> 00:17:47.210
Slicing is an extension
to this getitem syntax,

00:17:47.390 --> 00:17:52.260
where you can specify the start, stop,
and step of what you want.

00:17:52.260 --> 00:17:55.230
So if you want every item
but the first element,

00:17:55.230 --> 00:17:56.780
you can say one colon.

00:17:56.780 --> 00:18:01.540
That means you start at the first item,
not the zero, the first index,

00:18:01.660 --> 00:18:05.720
and then you go until the
end with a step of one.

00:18:05.730 --> 00:18:10.500
If you want the first two or less items,
you do the same thing,

00:18:10.510 --> 00:18:14.410
except you put colon two,
which means start at the

00:18:14.650 --> 00:18:16.590
beginning and end at two.

00:18:16.620 --> 00:18:20.090
If you want the list backwards,
you can do ::-1,

00:18:20.100 --> 00:18:25.000
which means start at the beginning,
end at the end, at a step of -1.

00:18:25.000 --> 00:18:27.770
And if you just want a
quick way to copy a list,

00:18:27.770 --> 00:18:32.130
a shallow copy, you can just do a colon
in the getitem syntax,

00:18:32.130 --> 00:18:36.600
and that'll start at the beginning,
end at the end, and iterate by 1.

00:18:36.600 --> 00:18:39.550
So you'll get a shallow
copy of the entire list with

00:18:39.550 --> 00:18:41.400
a three-character syntax.

00:18:41.400 --> 00:18:43.340
In Objective-C,
you'd have to imagine how you

00:18:43.360 --> 00:18:47.570
would write all these things,
and I guarantee it would not be pretty.

00:18:49.380 --> 00:18:50.540
Modules in Python.

00:18:50.540 --> 00:18:55.940
Unlike Objective-C,
the Python namespace is not flat.

00:18:56.000 --> 00:18:59.410
That's another thing you'll have to
take note of when you're bridging.

00:19:00.020 --> 00:19:02.630
Python modules are namespaces for stuff.

00:19:02.910 --> 00:19:05.860
One module corresponds to one file.

00:19:06.060 --> 00:19:10.940
But unlike many other languages,
these modules are executed

00:19:10.940 --> 00:19:13.870
at the same time that all
their symbols are parsed out.

00:19:14.000 --> 00:19:17.480
So if you do a circular import
where you have interdependencies

00:19:17.540 --> 00:19:22.150
between these two modules,
then it simply just won't work.

00:19:22.240 --> 00:19:27.010
You can't define two classes in one
module and two classes in another

00:19:27.010 --> 00:19:30.920
module with interdependencies
on each other at the module

00:19:30.920 --> 00:19:33.900
level of code and have it work.

00:19:33.950 --> 00:19:35.930
It just doesn't do that.

00:19:36.260 --> 00:19:41.540
And Python namespaces,
using Python namespaces are explicit.

00:19:41.540 --> 00:19:46.080
To bring a namespace into your namespace,
you simply type import and

00:19:46.080 --> 00:19:47.920
then the name of that module.

00:19:47.990 --> 00:19:52.060
And to use functions and methods and
all that stuff from that namespace,

00:19:52.150 --> 00:19:56.540
you just use the getitem syntax,
object.property.

00:19:56.630 --> 00:20:00.380
Okay, you can also bring specific items
from another namespace into your

00:20:00.450 --> 00:20:03.170
namespace with the from import syntax.

00:20:03.450 --> 00:20:05.960
From another module,
import another function.

00:20:05.990 --> 00:20:08.520
There's an extension to
this where you can say,

00:20:08.570 --> 00:20:13.040
from another module, import star,
which is just generally frowned upon

00:20:13.130 --> 00:20:17.400
because it kind of makes it hard to tell
where symbols came from in your module,

00:20:17.440 --> 00:20:21.890
but it gets you the same feel
that you have in C or Objective-C,

00:20:21.980 --> 00:20:24.840
where if you do an import statement,
you get everything.

00:20:25.020 --> 00:20:29.240
And this is awfully convenient
if you're doing bridged code,

00:20:29.240 --> 00:20:32.920
because you can simply import from
an Objective-C framework wrapper,

00:20:32.980 --> 00:20:35.210
and you'll get all the symbols,
and it's just like

00:20:35.210 --> 00:20:36.990
doing it in Objective-C.

00:20:37.890 --> 00:20:42.220
PyObjC is a great, awesome,
magical bridge that makes

00:20:42.310 --> 00:20:44.490
Python and Cocoa work together.

00:20:44.620 --> 00:20:46.960
Unlike the other bridges,
where you have all

00:20:46.960 --> 00:20:50.180
these crazy edge cases,
PyObjC bridge does

00:20:50.930 --> 00:20:53.470
everything pretty much right.

00:20:55.400 --> 00:20:57.810
The bridge lets you use
Objective-C from Python,

00:20:57.810 --> 00:21:00.010
and it lets you use
Python from Objective-C,

00:21:00.010 --> 00:21:01.480
and there's no glue required.

00:21:01.670 --> 00:21:05.160
You don't have to
code-generate little things,

00:21:05.160 --> 00:21:09.820
and you don't have to
read other documentation.

00:21:09.840 --> 00:21:18.950
It simply just works,
and it's done in a very consistent way,

00:21:18.950 --> 00:21:20.930
so you don't have to
go crazy learning it.

00:21:21.800 --> 00:21:25.000
The selectors bridged from
Objective-C to Python,

00:21:25.000 --> 00:21:28.680
you need to deinterleave the
arguments from the selector,

00:21:28.810 --> 00:21:33.400
which basically means replacing the
colons in the selector with underscores.

00:21:33.500 --> 00:21:37.630
This is done because Python uses
colons for something else.

00:21:37.760 --> 00:21:41.130
You can't use a colon in a method name,
because that would mean you're

00:21:41.130 --> 00:21:43.730
trying to start a block or
something crazy like that.

00:21:43.840 --> 00:21:47.230
And also,
because Python's keyword syntax can't

00:21:47.230 --> 00:21:51.600
be used since the keys are not ordered,
you have to do it similar to

00:21:51.660 --> 00:21:53.540
the Java and JavaScript bridges.

00:21:53.630 --> 00:21:57.310
And basically every language
bridge worth its salt does this,

00:21:57.440 --> 00:22:01.240
because other languages
simply can't denote that

00:22:01.240 --> 00:22:04.180
Objective-C syntax in a clear way.

00:22:04.180 --> 00:22:08.670
So it's different, but it's equivalent.

00:22:09.140 --> 00:22:12.940
And the thing is here is that you really
do replace colons with underscores,

00:22:12.940 --> 00:22:15.190
even if it only takes one argument.

00:22:15.390 --> 00:22:17.540
So if you have...

00:22:18.230 --> 00:22:27.010
So, if you want to say append object,
it's going to be append

00:22:27.010 --> 00:22:28.330
object underscore,
parenthesis, and then the object

00:22:28.330 --> 00:22:28.330
you're going to append.

00:22:30.080 --> 00:22:35.270
Subclassing Objective-C classes from
Python works just as you'd expect it to.

00:22:35.370 --> 00:22:40.000
You subclass the object with
the normal class syntax.

00:22:40.170 --> 00:22:45.600
What this does here is that it has to
follow the same rules as Objective-C,

00:22:45.800 --> 00:22:49.240
which means that no matter
what module it's done in,

00:22:49.400 --> 00:22:54.650
you can only have one class of that name
if it has an Objective-C superclass.

00:22:54.770 --> 00:22:57.100
So that's another thing
you have to be wary of.

00:22:57.200 --> 00:23:00.620
However, this gives you a full class
bridge to Objective-C,

00:23:00.690 --> 00:23:02.780
so if you want to find that
class from Objective-C,

00:23:02.840 --> 00:23:06.770
you can use NSClass from String
and the name of the class.

00:23:06.870 --> 00:23:10.150
As long as that Python code has been run,
you'll be able to find it.

00:23:10.250 --> 00:23:13.730
And you can even do it from the
NSBundle syntax if you happen to be

00:23:13.730 --> 00:23:16.010
loading Python stuff from a bundle.

00:23:17.890 --> 00:23:21.090
In PyObjC,
rather than just bridging method calls,

00:23:21.170 --> 00:23:24.800
we also bridge lots of other things too
to make it really convenient to use.

00:23:24.900 --> 00:23:29.460
You have the NSString type and
chair pointers are bridged to

00:23:29.560 --> 00:23:31.560
the Python Unicode and str types.

00:23:31.650 --> 00:23:35.730
And this bridge is bidirectional,
so you can take a Python string literal,

00:23:35.730 --> 00:23:38.300
pass it over the bridge through
a method call or in a collection

00:23:38.300 --> 00:23:41.150
or something like that,
and it will be bridged right

00:23:41.150 --> 00:23:43.070
over to an NSString subclass.

00:23:43.310 --> 00:23:46.730
And if the Objective-C selector
says that it takes a chair pointer,

00:23:46.950 --> 00:23:49.850
then the str type will
be bridged right over,

00:23:49.850 --> 00:23:50.800
no problem.

00:23:50.910 --> 00:23:56.150
The data types in Objective-C are
bridged a little strangely,

00:23:56.240 --> 00:24:01.000
because in Python you'd kind of expect
a data type to be bridged as a str,

00:24:01.050 --> 00:24:04.230
but we can't do that and also
bridge text types correctly.

00:24:04.370 --> 00:24:08.000
So what we do here is we bridge
data types as a buffer-like

00:24:08.080 --> 00:24:09.690
object and vice versa.

00:24:09.900 --> 00:24:14.340
So if you get an NSData from Objective-C,
you'll have an object that

00:24:14.340 --> 00:24:16.080
implements the buffer protocol.

00:24:16.090 --> 00:24:20.660
And that lets you do cool things
like use it to initialize an array

00:24:20.660 --> 00:24:25.280
object or like a numeric array or a
pill buffer or something like that.

00:24:25.310 --> 00:24:29.000
And if you want to pass a
data over to Objective-C,

00:24:29.020 --> 00:24:34.110
rather than having to initialize NSData,
data with bytes, and a Python string,

00:24:34.240 --> 00:24:37.160
you can simply wrap it with
the Python buffer object,

00:24:37.190 --> 00:24:40.650
which saves you a copy if nothing else.

00:24:40.700 --> 00:24:42.680
The array types are
bridged to list and tuple.

00:24:42.680 --> 00:24:49.800
Since the implementation of
NSArray doesn't really specify

00:24:50.090 --> 00:24:53.240
if it's going to be a mutable
array or an immutable array,

00:24:53.440 --> 00:24:56.590
they're all bridged as list types,
so you can't check to see

00:24:56.590 --> 00:24:59.560
if it's instance tuple to
see if it's mutable or not.

00:24:59.670 --> 00:25:04.280
You really just have to try it
and see if it lets you mutate it.

00:25:04.320 --> 00:25:07.760
The dictionary types are bridged to dict,
but there is that caveat

00:25:07.870 --> 00:25:09.710
of not copying keys at all.

00:25:09.840 --> 00:25:12.400
The number types, NSNumber,
are bridged to dict.

00:25:12.400 --> 00:25:16.090
The number types, NSNumber,
and also the C value types, bool, int,

00:25:16.090 --> 00:25:19.150
float, double, all that stuff,
are bridged to the

00:25:19.150 --> 00:25:22.800
Python types equivalently,
int, long, float, etc.

00:25:22.860 --> 00:25:25.420
However,
if you get one of these NSNumbers,

00:25:25.490 --> 00:25:29.020
these NSNumbers don't really
correctly describe themselves as

00:25:29.060 --> 00:25:31.550
to what number they actually are.

00:25:31.650 --> 00:25:36.010
Currently in the foundation,
if you initialize an

00:25:36.010 --> 00:25:40.040
NSNumber with an unsigned integer,
and you ask it what type it is,

00:25:40.230 --> 00:25:42.090
it'll tell you what signed type it is.

00:25:42.120 --> 00:25:46.520
And so that gives you some
strange behavior if you bridge

00:25:46.520 --> 00:25:47.510
it right over to Python.

00:25:47.600 --> 00:25:52.500
But what we do is we bridge the
NSNumbers over to subclasses of int,

00:25:52.550 --> 00:25:53.560
long, and float.

00:25:53.600 --> 00:25:59.600
And what that does is it gives you the
same methods that you had on NSNumbers.

00:25:59.600 --> 00:26:01.520
So if you get one of these
things over the bridge,

00:26:01.590 --> 00:26:05.060
you can call its float value or
unsigned int value or whatever,

00:26:05.090 --> 00:26:08.510
and you'd get the same behavior
that you'd get in Objective-C,

00:26:08.520 --> 00:26:10.210
meaning that if you
call the right method,

00:26:10.210 --> 00:26:11.840
you get the right value,
and everything works correctly.

00:26:11.890 --> 00:26:16.110
But if you don't, and you just use it as
a regular Python object,

00:26:16.220 --> 00:26:20.630
it supports all the number stuff,
but it might give you the wrong value

00:26:20.680 --> 00:26:23.070
if it's supposed to be unsigned.

00:26:23.260 --> 00:26:28.810
You've got these NSDecimal numbers
in Foundation that are bridged

00:26:28.930 --> 00:26:31.100
to a custom number-like wrapper.

00:26:31.180 --> 00:26:34.440
In Python 2.4, we could have bridged it
to the decimal object,

00:26:34.570 --> 00:26:38.060
but the decimal object has
very precise semantics,

00:26:38.060 --> 00:26:41.090
especially if you'd ask
somebody like Tim Peters.

00:26:41.270 --> 00:26:45.780
And we decided to have a separate wrapper
rather than trying to bridge it to

00:26:45.860 --> 00:26:48.840
something semantically non-equivalent.

00:26:48.990 --> 00:26:53.020
And also, for some of the Carbon types,
like FSRef objects,

00:26:53.140 --> 00:26:55.960
those are bridged right
over to the Python type,

00:26:55.960 --> 00:26:58.360
rather than getting this
ugly little struct thing.

00:26:58.360 --> 00:27:03.370
You'll get an FSRef object in Python,
and that supports the normal FSRef

00:27:03.400 --> 00:27:06.040
methods and whatnot that you have.

00:27:07.710 --> 00:27:09.800
Wrapped frameworks.

00:27:10.020 --> 00:27:15.540
Frameworks in Objective-C are
wrapped as Python packages.

00:27:15.650 --> 00:27:19.000
So that means if you have the
AppKit framework and you want

00:27:19.050 --> 00:27:22.500
to get symbols out of it,
you can do from AppKit import *.

00:27:22.650 --> 00:27:26.400
But this only works because we
made special wrappers for them.

00:27:26.530 --> 00:27:28.060
You can't do that for anything.

00:27:28.190 --> 00:27:32.030
You can't do from Omni
Foundation import *,

00:27:32.050 --> 00:27:34.900
because there isn't a
package already for that.

00:27:35.010 --> 00:27:37.520
But there are packages for
everything that ships with this

00:27:37.520 --> 00:27:40.300
system that we've wrapped so far,
which is basically all

00:27:40.300 --> 00:27:42.800
of the useful ones:
AppKit, Foundation, CoreData,

00:27:42.800 --> 00:27:44.300
etc., etc., etc.

00:27:44.320 --> 00:27:48.090
If you want to get the frameworks
that we haven't wrapped yet,

00:27:48.180 --> 00:27:52.310
we have the NSBundle API,
which you can use to do it

00:27:52.310 --> 00:27:55.600
the same way you would load
it dynamically in Objective-C.

00:27:55.690 --> 00:28:00.660
Or you can use our API,
the objc.loadbundle,

00:28:00.710 --> 00:28:03.500
loadbundle variables,
loadbundle functions,

00:28:03.530 --> 00:28:07.400
that let you pick stuff out of the
bundle and import it into a namespace,

00:28:07.400 --> 00:28:10.730
which gets you all the symbols
at once rather than having to

00:28:10.960 --> 00:28:13.260
NSClass from string them all.

00:28:13.720 --> 00:28:19.030
There's also ways to generate
Python packages from frameworks.

00:28:19.070 --> 00:28:22.460
However, we haven't quite released
something that we like a lot yet.

00:28:22.610 --> 00:28:29.040
So that's not quite a public API,
but it's going to be as soon as

00:28:29.040 --> 00:28:32.890
we get our Objective-C header
parser and all that jazz to

00:28:32.890 --> 00:28:32.890
work as well as we'd like it to.

00:28:33.740 --> 00:28:35.500
We also have Xcode templates.

00:28:35.600 --> 00:28:39.440
A lot of you like Xcode,
and everyone should be using Xcode,

00:28:39.440 --> 00:28:40.600
especially now.

00:28:40.600 --> 00:28:43.720
But it's not the greatest thing
in the world for Python yet.

00:28:43.900 --> 00:28:46.600
Xcode doesn't have a lot
of Python support built in.

00:28:46.770 --> 00:28:51.790
And in Xcode 2.0 at least,
the target support didn't let us

00:28:51.790 --> 00:28:55.600
do what we needed to do natively,
so we had to add a little magic

00:28:55.600 --> 00:28:59.600
with some shell scripts and some
Xcode file parsing and stuff.

00:28:59.600 --> 00:29:03.550
So the Xcode templates work,
and they do the right thing,

00:29:03.550 --> 00:29:06.510
but they might be a little fragile.

00:29:06.600 --> 00:29:09.600
However, if it breaks, we'll fix it.

00:29:09.600 --> 00:29:13.260
The magic that we used here is
that we made development and

00:29:13.330 --> 00:29:15.330
deployment different targets.

00:29:15.600 --> 00:29:20.600
And we used py2app to build instead
of asking Xcode to do anything.

00:29:20.600 --> 00:29:25.720
The build step is simply a shell
script that runs a setup py,

00:29:25.720 --> 00:29:28.600
just like you would build
any other Python application.

00:29:28.600 --> 00:29:32.940
And that py2app script will
read the Xcode project file,

00:29:32.940 --> 00:29:35.600
look in your groups,
pick out the Python files,

00:29:35.600 --> 00:29:38.620
pick out the resources,
and instruct py2app to

00:29:38.620 --> 00:29:39.600
build the application.

00:29:39.600 --> 00:29:43.290
And a future version of Xcode,
possibly even Xcode 2.1,

00:29:43.290 --> 00:29:46.600
will be able to rework these
templates to be cleaner.

00:29:46.600 --> 00:29:50.500
What py2app does is a lot
of very nice things for you.

00:29:50.500 --> 00:29:53.590
It'll take care of all
your Python dependencies.

00:29:53.610 --> 00:29:55.600
It looks at your Python files
and your scripts,

00:29:55.600 --> 00:29:57.600
it analyzes the bytecode,
and looks for import statements.

00:29:57.600 --> 00:30:02.000
And then it looks through your
Python module namespace to find all

00:30:02.000 --> 00:30:04.600
those dependencies that you have.

00:30:04.600 --> 00:30:08.580
And it makes all that
stuff go into your bundle.

00:30:08.650 --> 00:30:10.330
So you don't have to
figure out what you use,

00:30:10.330 --> 00:30:11.590
it'll figure it out for you.

00:30:11.600 --> 00:30:15.090
It's not 100% reliable,
but the only thing you have to do to

00:30:15.220 --> 00:30:19.590
fix it is put an import statement in
your code if it doesn't find something.

00:30:19.600 --> 00:30:23.370
However, it is quite reliable as long as
you're using import statements

00:30:23.370 --> 00:30:26.600
and not the special underscore,
underscore, and so on.

00:30:26.810 --> 00:30:31.380
So you can use the import
statement in Python to import

00:30:31.980 --> 00:30:34.600
something with a dynamic name.

00:30:35.090 --> 00:30:38.960
It also automatically finds all
dependent frameworks and and dial-ups.

00:30:39.050 --> 00:30:42.330
So if you have this Python extension
that links to something

00:30:42.340 --> 00:30:46.650
crazy that's third-party,
it'll actually find that you do that,

00:30:47.090 --> 00:30:49.640
and it'll copy it in,
and it'll rewrite the load commands.

00:30:49.640 --> 00:30:52.890
So no install name tool,
no copy files phases,

00:30:52.970 --> 00:30:55.700
it does all that for you automatically.

00:30:55.780 --> 00:30:58.470
And it gives you the bundle
relative install names,

00:30:58.560 --> 00:31:01.930
so you don't have to have
these crazy set-em dial-ed

00:31:01.930 --> 00:31:04.510
scripts or any mess like that.

00:31:04.900 --> 00:31:07.840
It just does it all for you,
hopefully correctly.

00:31:07.930 --> 00:31:11.940
Some of this technology that's
in here can actually be used

00:31:12.360 --> 00:31:16.020
for regular Objective-C projects
or any other language,

00:31:16.020 --> 00:31:16.760
basically.

00:31:16.890 --> 00:31:21.810
There's a shell script that you
can just run on your application,

00:31:21.810 --> 00:31:25.460
and it'll make it standalone by doing
this whole dial-ed find process.

00:31:25.720 --> 00:31:29.980
And I actually used that, heretically,
possibly,

00:31:30.050 --> 00:31:34.070
to build the Frozen Bubble application,
which depends on Perl and a bunch

00:31:34.170 --> 00:31:36.780
of stuff from Darwin ports and SDL.

00:31:36.860 --> 00:31:38.130
And it just worked.

00:31:38.350 --> 00:31:42.300
So cool stuff in PyDA app,
and you should look into it,

00:31:42.490 --> 00:31:44.480
even if you're not
doing Python stuff yet.

00:31:44.600 --> 00:31:46.920
Because it can save you all
the trouble of doing the copy

00:31:47.000 --> 00:31:48.430
files phases and all that stuff.

00:31:48.620 --> 00:31:53.200
And the tool that it ships with to
do that is called mako_standalone.

00:31:54.190 --> 00:31:57.420
All right, excuse me.

00:31:57.460 --> 00:31:59.850
So,
some demos of all the stuff in action.

00:31:59.900 --> 00:32:02.930
And as Bob says, I mean, you know,
we're going to do a lot

00:32:02.930 --> 00:32:06.100
of PyOpc related demos,
but Python and Mac OS X with

00:32:06.100 --> 00:32:09.930
PyOpc installed,
the Py2App stuff is just brilliant.

00:32:09.940 --> 00:32:12.580
It lets you package up any
standard Python modules,

00:32:12.580 --> 00:32:14.300
a double clickable dot package.

00:32:14.430 --> 00:32:18.290
So, if you're distributing standard
portable Python across a fleet of Macs,

00:32:18.290 --> 00:32:20.820
packaging and installation
is now trivial.

00:32:20.820 --> 00:32:21.350
Oh, yay.

00:32:21.360 --> 00:32:22.840
I still have bits.

00:32:22.840 --> 00:32:23.360
Excellent.

00:32:23.640 --> 00:32:26.040
So,
this application that's running on the

00:32:26.040 --> 00:32:30.110
screen now is actually the outline edit
example from the core data examples

00:32:30.190 --> 00:32:33.830
that are provided on your machine,
ported to Python and PyOpc.

00:32:33.860 --> 00:32:37.060
As you can see, it all just works.

00:32:37.060 --> 00:32:41.490
And what's interesting about this
is just works means KVO works,

00:32:41.590 --> 00:32:47.590
key value observation, key value coding,
subclassing, delegation, nib loading,

00:32:47.590 --> 00:32:49.550
the entire Cocoa stack.

00:32:49.580 --> 00:32:52.150
Now, what does this look
like under the covers?

00:32:53.180 --> 00:32:54.250
So, I'm going to go ahead and quit this.

00:32:54.270 --> 00:32:57.390
And where did I put it?

00:32:57.440 --> 00:32:59.580
Okay.

00:32:59.760 --> 00:33:00.200
Desktop.

00:33:00.280 --> 00:33:02.910
See the examples.

00:33:02.960 --> 00:33:03.980
Okay.

00:33:05.700 --> 00:33:06.700
Data.

00:33:06.700 --> 00:33:10.540
As you can see, PyObjC has a boatload
of examples with it.

00:33:10.550 --> 00:33:12.580
We go now outline edit.

00:33:12.580 --> 00:33:18.610
The actual app wrapper looks
like a standard app wrapper,

00:33:18.610 --> 00:33:25.980
but because of the magic of py2app,
everything, all the dependencies,

00:33:25.980 --> 00:33:25.980
dialyps, everything's wrapped up inside.

00:33:25.980 --> 00:33:25.980
Let me go ahead and open up my document.

00:33:26.500 --> 00:33:30.380
This is actual Python code
written against Cocoa.

00:33:30.400 --> 00:33:32.430
In particular, you'll see this.

00:33:32.440 --> 00:33:33.250
This is interesting.

00:33:33.340 --> 00:33:37.000
This demonstrates the dynamism of
Objective-C in combination with

00:33:37.100 --> 00:33:39.370
a scripted language like Python.

00:33:39.380 --> 00:33:41.870
In this case,
this is the document class for

00:33:41.870 --> 00:33:44.080
the outline edit application.

00:33:44.080 --> 00:33:46.430
How many Cocoa programmers are here?

00:33:46.710 --> 00:33:48.940
Okay, so the standard Cocoa paragraph.

00:33:49.060 --> 00:33:53.060
What this is actually doing is reading
the definition of the document,

00:33:53.140 --> 00:33:58.170
my document class from the nib file,
defining the subclass on the fly,

00:33:58.280 --> 00:34:02.070
and setting it all up,
and then instantiating it

00:34:02.070 --> 00:34:04.230
from within the nib file.

00:34:04.330 --> 00:34:07.940
You can also see, you know, there's,
this is straight

00:34:07.970 --> 00:34:12.740
Objective-C more or less,
calling methods, etc.

00:34:12.920 --> 00:34:16.100
It all really does just work.

00:34:16.100 --> 00:34:19.270
What's our-- can we go back
to slides for a second?

00:34:21.900 --> 00:34:24.900
What's the next one?

00:34:24.900 --> 00:34:29.700
The next demo is PyObjc
Mixed Applications.

00:34:30.360 --> 00:34:33.600
This demo is a cool little
application called RestEdit.

00:34:33.640 --> 00:34:38.270
RestEdit is a text editing application
for editing a special kind of

00:34:38.270 --> 00:34:39.870
text called restructured text.

00:34:40.000 --> 00:34:44.270
Restructured text is a text
format that's kind of like

00:34:44.270 --> 00:34:48.720
Markdown if you've ever used it,
but it's used for basically

00:34:48.720 --> 00:34:54.560
writing Python documentation
and various other documents.

00:34:54.650 --> 00:35:00.030
It can be translated to LaTeX and
HTML and all kinds of cool stuff.

00:35:00.130 --> 00:35:03.320
Can we get the demo machine, please?

00:35:04.410 --> 00:35:06.230
So it's unfortunate the
font's a little small,

00:35:06.240 --> 00:35:09.800
but on the left-hand pane there,
you'll see that this is a text document

00:35:09.830 --> 00:35:12.640
with some pretty minor ASCII markup,
but on the right side is

00:35:12.640 --> 00:35:13.940
the rendered form of it.

00:35:13.970 --> 00:35:18.120
Now again, this is actually a mixed
Python and Objective-C application,

00:35:18.200 --> 00:35:22.300
so like the split view here was
an open source split view that

00:35:22.400 --> 00:35:24.060
I found that was really useful.

00:35:24.090 --> 00:35:25.960
There's kernel queues being used in here.

00:35:25.960 --> 00:35:28.680
There's several other things
happening from Objective-C that

00:35:28.680 --> 00:35:32.280
is integrated with Python,
and then is also using a number

00:35:32.280 --> 00:35:34.360
of third-party Python modules.

00:35:34.390 --> 00:35:38.060
And one of those third-party
Python modules is

00:35:50.500 --> 00:35:52.500
for the second one.

00:35:52.970 --> 00:35:57.280
PyObjC survived the upgrades too,
by the way.

00:35:59.030 --> 00:36:01.390
I think it's still reading
the old Xcode project,

00:36:01.510 --> 00:36:01.990
though.

00:36:02.010 --> 00:36:06.990
So... Well, yeah,
but we can gloss over that

00:36:06.990 --> 00:36:06.990
for the next hour or so.

00:36:07.390 --> 00:36:12.180
Okay, so what we have here is the Xcode
project for restructured text.

00:36:12.270 --> 00:36:15.100
This isn't the one that's used in the
release version of restructured text,

00:36:15.120 --> 00:36:18.980
but I refactored it to use
the new Xcode templates.

00:36:19.150 --> 00:36:24.370
The new Xcode templates, as I said,
you have separate development

00:36:24.370 --> 00:36:27.880
and deployment targets that
build the application in

00:36:27.930 --> 00:36:29.930
development or deployment mode.

00:36:30.040 --> 00:36:33.170
The cool thing about py2app's
development mode is that it

00:36:33.170 --> 00:36:35.240
doesn't really compile anything.

00:36:35.340 --> 00:36:37.690
Basically, it just makes symlinks
to your source code,

00:36:37.710 --> 00:36:39.610
and it runs it straight out of the tree.

00:36:39.750 --> 00:36:41.690
So you can just make a
change to the source,

00:36:41.690 --> 00:36:43.580
and then restart your application.

00:36:43.640 --> 00:36:46.710
It takes like two seconds
to start your application,

00:36:46.710 --> 00:36:49.590
rather than however long it would
take you to recompile everything,

00:36:49.590 --> 00:36:52.340
or recompile just the unit,
or what have you.

00:36:52.450 --> 00:36:55.270
When you switch to deployment,
it'll do all that crazy stuff

00:36:55.270 --> 00:36:56.830
that I talked about before.

00:36:56.840 --> 00:36:59.880
All the dependency finding,
the framework finding,

00:36:59.880 --> 00:37:02.180
the header rewriting, all that stuff.

00:37:02.250 --> 00:37:05.780
And what I didn't mention
before is that when you build a

00:37:05.780 --> 00:37:10.430
standalone deployment application,
it really is standalone.

00:37:10.530 --> 00:37:13.800
If you're using a third-party Python,
like Python 2.4.1,

00:37:13.800 --> 00:37:15.410
it'll include Python itself.

00:37:15.510 --> 00:37:16.820
It'll include PyObjective-C.

00:37:16.820 --> 00:37:19.220
It'll include everything you use.

00:37:19.310 --> 00:37:21.520
And you don't really
have to think about it,

00:37:21.520 --> 00:37:23.260
because it does it all for you.

00:37:23.640 --> 00:37:27.200
And the way this Xcode template
works is it has special groups,

00:37:27.200 --> 00:37:30.340
and these groups do different
slightly magical things.

00:37:30.390 --> 00:37:36.300
The resources group are the resources
that end up in your application.

00:37:36.400 --> 00:37:39.510
So all your nibs, all that stuff,
just throw in the resources folder

00:37:39.850 --> 00:37:41.630
and it'll end up in your application.

00:37:41.860 --> 00:37:45.520
The classes thing,
what it does is it'll actually import

00:37:45.520 --> 00:37:50.540
all these classes in the order that
they are listed in the Xcode project.

00:37:50.700 --> 00:37:54.390
So if your nib depends on something,
you don't have to worry about

00:37:54.400 --> 00:37:56.060
importing it somewhere in the code.

00:37:56.060 --> 00:37:59.310
You just put it in this
group and it'll be imported.

00:37:59.750 --> 00:38:01.790
And this is the mixed template.

00:38:02.050 --> 00:38:06.300
So what we have here is another target,
which is all the Objective-C stuff.

00:38:06.420 --> 00:38:10.030
And all this Objective-C stuff is
compiled as Xcode normally compiles it.

00:38:10.200 --> 00:38:15.730
Takes all this RB split view stuff,
the KQ wrapper, and it puts it all into

00:38:15.730 --> 00:38:19.310
a nice little plugin,
and that plugin ends up

00:38:19.310 --> 00:38:21.800
in the resources folder.

00:38:21.970 --> 00:38:26.570
What we have here is this automatically
generated Python script that

00:38:26.570 --> 00:38:30.150
uses the objc load bundle API.

00:38:31.330 --> 00:38:35.040
and it picks up the bundle and
it imports all the classes.

00:38:35.060 --> 00:38:39.530
And this gets imported automatically,
so basically you have this mixed target,

00:38:39.630 --> 00:38:42.360
you write some Objective-C code,
you write some Python code,

00:38:42.380 --> 00:38:45.780
and you don't write any glue
code because this is it,

00:38:45.790 --> 00:38:48.660
and this is automatically
generated for you.

00:38:48.670 --> 00:38:51.970
And to use it from your Python code,

00:39:11.330 --> 00:39:17.570
Okay, to use it from your Python code,
you simply import it and...

00:39:19.320 --> 00:39:20.180
There it is.

00:39:20.400 --> 00:39:22.690
That's the Objective-C code
in the project.

00:39:22.760 --> 00:39:25.060
We're using the KQ wrapper.

00:39:25.230 --> 00:39:27.540
The split view stuff,
we're not even using in the code.

00:39:27.540 --> 00:39:28.970
We're just using in the nib.

00:39:29.000 --> 00:39:31.910
So we don't have to do
anything in the code for that,

00:39:31.910 --> 00:39:35.510
because it's automatically imported,
because the plugin loader that's

00:39:35.550 --> 00:39:39.740
automatically generated loads it for you,
and then the nib finds it,

00:39:39.740 --> 00:39:40.860
and then that's it.

00:39:40.950 --> 00:39:44.500
So mixing Objective-C and
Python code is really simple.

00:39:44.500 --> 00:39:47.520
You basically just select
the right Xcode template,

00:39:47.610 --> 00:39:49.280
and the rest is done for you.

00:39:49.300 --> 00:39:52.640
If you want to do that by hand,
it's really not that hard.

00:39:52.640 --> 00:39:56.020
You can just look at the Xcode
template and see what it does,

00:39:56.170 --> 00:39:57.670
and bring it over to another template.

00:39:57.700 --> 00:40:01.340
There's not too much magic
involved with the plugin stuff.

00:40:04.910 --> 00:40:06.900
Okay, PyObjC plugins.

00:40:06.950 --> 00:40:09.590
The next demo will be a
PyInterpreter palette.

00:40:09.820 --> 00:40:12.220
Go for it, Bob.

00:40:12.280 --> 00:40:14.920
Okay, so in this,
in the previous example,

00:40:15.030 --> 00:40:19.800
we had an Objective-C plugin
loaded by a Python application.

00:40:19.910 --> 00:40:22.110
It's sitting on the desktop.

00:40:24.500 --> 00:40:25.970
I made sure it runs in Interface Builder.

00:40:26.040 --> 00:40:26.820
It's already built.

00:40:26.820 --> 00:40:28.740
You can just run Interface
Builder if you wanted.

00:40:28.740 --> 00:40:29.820
- Okay.

00:40:29.830 --> 00:40:33.690
So what we have here is an
Interface Builder plugin written

00:40:33.690 --> 00:40:36.440
entirely in Python with PyObjC.

00:40:36.440 --> 00:40:40.640
And it's this nice palette
with a nice big blue thing.

00:40:40.640 --> 00:40:49.520
And what we'll do here is we'll
create a new Cocoa application nib.

00:40:51.220 --> 00:40:53.500
Drag over this guy.

00:40:53.500 --> 00:40:57.940
And this is our PyInterpreterView class.

00:40:57.940 --> 00:41:01.580
We can inspect this,
and we'll check this box to

00:41:01.590 --> 00:41:06.370
import Objective-C classes,
and we'll test it to see if it works.

00:41:06.390 --> 00:41:10.190
And what we have here is a
Python interpreter inside

00:41:10.200 --> 00:41:11.970
of Interface Builder.

00:41:11.980 --> 00:41:16.710
And we can, since we imported all these

00:41:18.270 --> 00:41:20.920
So now this is interesting because
what this means is that you can

00:41:20.920 --> 00:41:24.380
use Python via PyObjC to write
a plugin for any application on

00:41:24.380 --> 00:41:26.380
Mac OS X that supports a plugin API.

00:41:26.410 --> 00:41:29.140
So screen savers, preference panes, etc.

00:41:29.200 --> 00:41:33.500
Well, that also includes anything like
the administrative apps that have

00:41:33.500 --> 00:41:35.680
the plugin APIs or anything else.

00:41:35.740 --> 00:41:40.030
So Python is obviously a wonderful
cross-platform administrative tool,

00:41:40.270 --> 00:41:44.930
and now you can integrate it with
the GUI apps for the admin stuff,

00:41:44.930 --> 00:41:45.520
too.

00:41:46.200 --> 00:41:47.820
And it's great for testing,
because you can put

00:41:47.820 --> 00:41:51.240
this right in your app,
even if it's just an Objective-C app.

00:41:51.300 --> 00:41:53.620
You can drop this
interpreter palette in there,

00:41:53.620 --> 00:41:56.100
and you can inspect all your
classes and call methods on things,

00:41:56.100 --> 00:42:02.090
like I can call the
NSApplicationSharedApp.

00:42:15.290 --> 00:42:16.700
Oh, that's interesting.

00:42:16.740 --> 00:42:20.300
I'd be returned something else if you
do NSApplication shared application.

00:42:20.420 --> 00:42:22.820
Yeah, sorry.

00:42:22.930 --> 00:42:24.040
But that's my typical demo.

00:42:24.040 --> 00:42:26.160
If I put this in something,
I'll just kill it,

00:42:26.180 --> 00:42:29.050
because that's the only
selector on NSApplication that

00:42:29.050 --> 00:42:31.070
I really remember very well.

00:42:33.010 --> 00:42:36.380
And so that is a plugin
written in Python,

00:42:36.380 --> 00:42:44.040
and that's using the same Xcode template,
just slightly modified to build a

00:42:44.070 --> 00:42:46.180
plugin instead of an application.

00:42:49.900 --> 00:42:52.860
And this is basically just
the PyInterpreter example

00:42:52.880 --> 00:42:55.330
modified to be a plugin.

00:42:55.340 --> 00:42:58.740
To build a plugin instead of
an application with py2app,

00:42:58.740 --> 00:43:03.000
you simply specify plugin
instead of app in your setup UI.

00:43:03.000 --> 00:43:07.620
But the setup UIs in the Xcode templates
are basically just done automatically for

00:43:07.620 --> 00:43:10.310
you and contain a little bit of magic.

00:43:10.820 --> 00:43:13.010
However,
if you're building a plugin instead of

00:43:13.010 --> 00:43:15.580
an application with the Xcode template,
we currently don't

00:43:15.670 --> 00:43:16.770
ship a plugin template.

00:43:17.040 --> 00:43:20.240
So what you'll have to do here
is if you're building a plugin,

00:43:20.340 --> 00:43:23.280
you go into the setup UI,
and you make some small

00:43:23.280 --> 00:43:24.200
changes to the end.

00:43:24.250 --> 00:43:28.630
There's a setup options, Xcode, py2app,
setup options.

00:43:28.780 --> 00:43:33.990
You get the plugin dictionary,
and then you change that

00:43:35.300 --> 00:43:37.900
to change the extension to palette.

00:43:38.140 --> 00:43:42.900
And we'll have these examples
up for you later today,

00:43:42.900 --> 00:43:46.040
and you'll be able to play with
it and look to see how it's done.

00:43:46.050 --> 00:43:48.300
But this is all Python code.

00:43:48.320 --> 00:43:50.620
I'm not hiding any Objective-C code here.

00:43:50.620 --> 00:43:55.680
It's all Python stuff, no C code,
but it's loaded as a plug-in

00:43:55.680 --> 00:43:57.520
into an Objective-C application.

00:43:57.520 --> 00:44:01.140
So that means you can
integrate it with anything.

00:44:01.140 --> 00:44:03.560
You can make a Colloquy plug-in,
a Quicksilver plug-in,

00:44:03.560 --> 00:44:08.500
an Interface builder plug-in,
an Xcode plug-in, a Safari plug-in.

00:44:08.500 --> 00:44:13.580
Like when Safari 1.3 came out,
I took this PyInterpreter thing and

00:44:13.580 --> 00:44:16.850
I made a WebKit plug-in out of it,
which is really kind of funny because you

00:44:16.860 --> 00:44:19.360
can have it talk to JavaScript and stuff.

00:44:19.360 --> 00:44:22.240
Because JavaScript can talk
to Objective-C as well,

00:44:22.240 --> 00:44:25.660
though not quite as
cleanly as Python does.

00:44:25.990 --> 00:44:31.140
So, and speaking of the interpreter,
so this is subathedit.

00:44:31.140 --> 00:44:32.660
subathedit is up and running.

00:44:32.660 --> 00:44:36.920
It knows absolutely nothing about
PyObjC or Python or anything.

00:44:37.030 --> 00:44:39.840
There's an example that's
included that injects the

00:44:39.840 --> 00:44:41.840
interpreter into running processes.

00:44:41.870 --> 00:44:45.520
So if I hit return now,
this is actually a Python interpreter

00:44:45.520 --> 00:44:47.240
that's running inside of subathedit now.

00:44:47.460 --> 00:44:50.790
So I can actually --

00:44:51.560 --> 00:44:56.890
import the app kit,
and if I do nsapp.delegate, you'll see,

00:44:56.900 --> 00:44:58.590
sure enough,
it came back as app controller,

00:44:58.600 --> 00:45:01.900
which is the app delegate for subf edit.

00:45:01.900 --> 00:45:04.610
And this does not work on Intel yet.

00:45:05.300 --> 00:45:09.580
This barely worked on Tiger.

00:45:09.580 --> 00:45:11.230
But it'll be there.

00:45:11.290 --> 00:45:12.300
So that's that.

00:45:12.300 --> 00:45:13.190
Now what's the next demo?

00:45:13.190 --> 00:45:15.050
The code importer.

00:45:15.320 --> 00:45:16.300
Yeah.

00:45:16.420 --> 00:45:17.300
Okay, cool.

00:45:17.470 --> 00:45:22.300
So we also do integration
of Python with Spotlight,

00:45:22.300 --> 00:45:27.330
and in this case I wrote an
importer of Objective-C code,

00:45:27.400 --> 00:45:29.250
though it's got hooks in
it for Java and Python.

00:45:29.350 --> 00:45:32.300
Hint, hint if anyone wants to
do the parsing there.

00:45:32.300 --> 00:45:36.300
So what the code importer does is,
this is actually a completely

00:45:36.300 --> 00:45:38.300
different way of doing this.

00:45:38.300 --> 00:45:42.410
This is embedding the Python interpreter
directly without using PyObjC,

00:45:42.410 --> 00:45:44.290
and as Bob put it,
writing a whole bunch of code

00:45:44.310 --> 00:45:45.300
you didn't have to write.

00:45:45.300 --> 00:45:48.240
But, you know,
this is the pure Python form of it.

00:45:48.240 --> 00:45:52.300
There's not really much of anything
terribly interesting in this.

00:45:52.300 --> 00:45:54.200
What's interesting is
what happens when it runs.

00:45:54.300 --> 00:45:58.600
Unless you find lots of C code doing
very hairy things with global interpreter

00:45:58.850 --> 00:46:01.300
states and threads and all that stuff.

00:46:01.300 --> 00:46:01.940
Unless you find lots of C code doing
very hairy things with global interpreter

00:46:01.950 --> 00:46:02.300
states and threads and all that stuff.

00:46:02.300 --> 00:46:02.900
If you find that interesting,
then this example would be

00:46:02.900 --> 00:46:03.290
quite interesting to you.

00:46:03.410 --> 00:46:04.300
Yeah.

00:46:04.300 --> 00:46:04.650
So now that this importer is
installed and up and running,

00:46:04.660 --> 00:46:04.810
if I go to -- where did I put it?

00:46:04.840 --> 00:46:04.880
Here it is.

00:46:04.890 --> 00:46:05.290
Omni Foundation.

00:46:05.300 --> 00:46:12.940
I went and I grabbed all the Omni Group's
wonderful bodies of code and threw it

00:46:13.090 --> 00:46:17.300
on my machine and let it chug overnight.

00:46:17.300 --> 00:46:26.700
So now that I've done that,
I can do this.

00:46:27.410 --> 00:46:31.600
You'll see that I'm getting
metadata about the implementations

00:46:31.600 --> 00:46:33.140
contained in the files.

00:46:33.210 --> 00:46:35.240
So in this case,
it's telling me the programming

00:46:35.240 --> 00:46:38.080
language is Objective-C,
and that there's one implemented

00:46:38.080 --> 00:46:39.720
class inside of this file.

00:46:39.860 --> 00:46:42.710
Now, where this gets to be
interesting is I can ask some

00:46:42.710 --> 00:46:48.200
much more difficult questions,
like, I don't know if... I guess

00:46:48.200 --> 00:46:51.690
every Objective-C programmer's
experienced this.

00:46:51.760 --> 00:46:53.860
I've got an NSArray,
I've linked against a

00:46:53.860 --> 00:46:56.670
bunch of frameworks,
maybe some of them third-party.

00:46:56.830 --> 00:46:59.710
Someone somewhere has
added a method to my class,

00:46:59.730 --> 00:47:02.160
I don't know where the hell it is,
and I don't know what it

00:47:02.160 --> 00:47:03.560
does or why it's there.

00:47:03.650 --> 00:47:05.630
Let me find that implementation file.

00:47:05.780 --> 00:47:08.250
Python doesn't natively let you do this,
by the way.

00:47:08.410 --> 00:47:10.990
Python does not support
categories on itself.

00:47:11.080 --> 00:47:15.820
So, this is actually a query that asks
to find all of the files on the

00:47:15.820 --> 00:47:19.440
system that contain an implementation
of an Objective-C category

00:47:19.440 --> 00:47:21.660
that adds methods to NSArray.

00:47:21.790 --> 00:47:25.700
And as you can see, I mean,
this is really a Spotlight demo.

00:47:25.780 --> 00:47:29.300
The code for the code importer
was pretty straightforward.

00:47:29.390 --> 00:47:33.300
It's advertising the metadata,
the keys by name,

00:47:33.300 --> 00:47:36.500
you can set up your custom queries,
you can do all that.

00:47:36.600 --> 00:47:40.570
So, yes, we support Spotlight, too.

00:47:42.100 --> 00:47:49.570
And then finally, one last demo, is that,
okay, we'll use this terminal

00:47:49.580 --> 00:47:51.520
since it's so nice and big.

00:47:51.550 --> 00:47:54.730
You can do interpretive Objective-C too.

00:47:54.700 --> 00:47:59.700
So I can do from obc import,
from foundation import.

00:47:59.700 --> 00:48:05.380
And so, yeah, I'm just interpreting
Objective-C at this point.

00:48:05.380 --> 00:48:08.580
And since we can inject the interpreter,
great debugging tool, et cetera.

00:48:08.590 --> 00:48:12.300
To drive home that this is in fact,
you know, really Objective-C and it is

00:48:12.300 --> 00:48:15.330
really dynamic and working great,
I can do things like

00:48:15.340 --> 00:48:18.500
NSBundle.allframeworks.

00:48:18.900 --> 00:48:19.760
I spelled it right.

00:48:19.760 --> 00:48:21.980
You'll see I get back an array.

00:48:22.250 --> 00:48:27.920
It's actually an NSArray,
but because of the transparent bridging,

00:48:27.960 --> 00:48:33.270
I can say for x in A, print x,
and you'll see it just now iterated

00:48:33.340 --> 00:48:38.160
using the Python iteration stuff,
but obviously calling into Objective C.

00:48:38.220 --> 00:48:39.090
Basically, what is it?

00:48:39.120 --> 00:48:42.860
Any class that implements object
enumerator is then iterable?

00:48:42.890 --> 00:48:43.680
- Yep.

00:48:43.680 --> 00:48:47.380
- Yeah, so if you implement your class
with an object enumerator method,

00:48:47.440 --> 00:48:48.870
it will be iterable in Python.

00:48:48.980 --> 00:48:54.350
Now, I can also do some really
frightening things.

00:48:54.940 --> 00:48:57.140
Not that we haven't done any
frightening things already.

00:48:57.140 --> 00:48:57.700
Right.

00:48:57.790 --> 00:49:02.060
Since everything in Python's an object,
and the bridge is just bridging

00:49:02.060 --> 00:49:06.760
Objective-C over as a bunch of objects,
that means methods are objects too.

00:49:06.940 --> 00:49:09.880
So sure enough,
if I do nsobject.description,

00:49:09.900 --> 00:49:13.870
I get back the object that
represents the implementation of

00:49:13.870 --> 00:49:16.340
the description method on nsobject.

00:49:16.370 --> 00:49:20.100
So I can of course define a new function,
and I'm gonna make it print.

00:49:20.100 --> 00:49:24.590
Well, description returns a string, so.

00:49:25.000 --> 00:49:26.190
Oh, nah.

00:49:26.200 --> 00:49:28.040
- You might wanna return
that instead of printing it.

00:49:28.040 --> 00:49:29.200
- Oh yeah, you're right.

00:49:29.200 --> 00:49:31.780
I really do wanna return that, don't I?

00:49:32.910 --> 00:49:35.730
Bob keeps my stuff from crashing.

00:49:35.850 --> 00:49:38.940
It wouldn't crash,
it just would have funny output.

00:49:38.990 --> 00:49:41.040
So yeah, sure, I made a function.

00:49:41.150 --> 00:49:41.620
That's great.

00:49:41.650 --> 00:49:45.480
Now,
before we do anything mean to NSObject,

00:49:45.530 --> 00:49:48.080
you can see that yes,
I can instantiate an NSObject,

00:49:48.090 --> 00:49:50.050
and I get my method backs, etc.

00:49:50.150 --> 00:49:52.650
So now, if I want to actually
override description,

00:49:52.750 --> 00:49:57.050
I just do NSObject.description = fun.

00:49:57.170 --> 00:50:00.420
And once that's done, it's overwritten.

00:50:00.550 --> 00:50:03.880
Now this is actually editing
the Objective-C runtime itself,

00:50:03.900 --> 00:50:07.280
so this will all work
from Objective-C too.

00:50:07.310 --> 00:50:13.170
And it lets you do really frightening
things like NSArray.description equals,

00:50:13.170 --> 00:50:18.280
I don't know, NSDictionary.description.

00:50:18.900 --> 00:50:20.140
Oops.

00:50:20.140 --> 00:50:20.520
Oh.

00:50:20.520 --> 00:50:22.140
Okay.

00:50:22.360 --> 00:50:24.940
So we broke that somewhere.

00:50:24.940 --> 00:50:24.940
But...

00:50:25.720 --> 00:50:28.590
If I were to put the
NSDictionary's description

00:50:28.590 --> 00:50:31.250
into a Python function and then
throw that into the NSRate,

00:50:31.250 --> 00:50:32.000
it'd work fine.

00:50:32.000 --> 00:50:35.990
Well, for some definition of work, fine.

00:50:36.000 --> 00:50:38.270
It would give you a very
interesting GDB backtrace,

00:50:38.290 --> 00:50:38.950
I would say.

00:50:39.000 --> 00:50:40.900
True.

00:50:41.030 --> 00:50:42.970
Exceptions come across,
they're all transparent,

00:50:43.020 --> 00:50:46.000
they get converted to Objective-C,
then to Python, etc.

00:50:46.000 --> 00:50:50.000
And again, I mean,
this just isn't about macho_standalone.

00:50:50.000 --> 00:50:52.920
The py2app stuff,
the automatic packaging stuff

00:50:52.920 --> 00:50:56.000
just makes it so painless to
use Python on the platform.

00:50:56.200 --> 00:51:00.110
Which, before we go to Q&A,
I'm sure one of the first questions is,

00:51:00.110 --> 00:51:02.920
"Why isn't PyObjC shipping
in Tiger?" And the answer

00:51:02.920 --> 00:51:04.950
there is really quite simple.

00:51:05.030 --> 00:51:08.940
We looked at it,
and PyObjC is so painless to install.

00:51:09.000 --> 00:51:12.000
Go grab a package, double-click it,
it works.

00:51:12.000 --> 00:51:13.950
And the development moves rapidly.

00:51:14.000 --> 00:51:18.000
PyObjC is constantly evolving,
it's constantly gaining new capabilities.

00:51:18.000 --> 00:51:21.850
But it's got a ton of unit tests,
which are not only

00:51:21.850 --> 00:51:25.070
guaranteeing the quality,
but are guaranteeing that the prior

00:51:25.150 --> 00:51:28.000
version's contract is maintained.

00:51:28.070 --> 00:51:32.070
And all those things together made it
such that we looked at it and we're like,

00:51:32.070 --> 00:51:33.940
you know, people are going to be
better off just grabbing it,

00:51:34.020 --> 00:51:35.990
double-clicking it, and running with it.

00:51:36.010 --> 00:51:40.080
And because of py2app and the automatic
packaging tools that are there,

00:51:40.260 --> 00:51:43.080
people that are shipping commercial
applications with this stuff,

00:51:43.080 --> 00:51:46.000
of which there are a number,
don't have to worry about someone

00:51:46.000 --> 00:51:46.000
grabbing some random copy and
throwing it on the ground.

00:51:46.000 --> 00:51:50.840
Because py2app will take care of
making sure all dependencies are

00:51:50.840 --> 00:51:54.000
resolved internally to the app wrapper.

00:51:54.970 --> 00:51:57.730
So, you know, it was just,
it was easier to go with a

00:51:57.780 --> 00:52:01.260
third-party solution or leave
it out there in the wild.

00:52:01.340 --> 00:52:06.160
But in any case,
that's Python on Mac OS X.
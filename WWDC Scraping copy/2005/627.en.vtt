WEBVTT

00:00:00.710 --> 00:00:01.350
Thank you for coming.

00:00:01.400 --> 00:00:06.000
My name is Ted Jucevic,
and I'm one of the DTS engineers

00:00:06.040 --> 00:00:08.600
at Apple that does Java support.

00:00:08.760 --> 00:00:13.600
So today we're going to talk about J2ME,
Java 2 Micro Edition.

00:00:13.600 --> 00:00:17.020
And to get things started,
I'm actually going to introduce

00:00:17.020 --> 00:00:22.600
the gentleman here who,
he ported the MIDP 1.0

00:00:22.600 --> 00:00:25.600
emulator over to Mac OS X.

00:00:25.630 --> 00:00:30.590
And we demoed that lightly last year when
we were showing cross-compiling with Ant.

00:00:30.590 --> 00:00:36.600
And then he's brought an SDK for
MIDP 2.0 to the platform also.

00:00:36.600 --> 00:00:42.600
Let me introduce Mike Powers from
MPower Player Incorporated.

00:00:42.600 --> 00:00:45.600
And here he is, Mike Powers.

00:00:45.600 --> 00:00:47.380
Thanks.

00:00:50.950 --> 00:00:52.860
Hi, I'm Michael Powers.

00:00:52.860 --> 00:00:56.560
I'm a Chief Technology Officer of
Empower Player,

00:00:56.560 --> 00:00:57.300
Inc.

00:00:57.300 --> 00:00:58.160
That's my company.

00:00:58.160 --> 00:01:02.150
We make solutions for
consumers to easily find,

00:01:02.150 --> 00:01:06.340
try,
and ultimately buy mobile applications.

00:01:06.340 --> 00:01:09.740
One important part of that
equation is the try function,

00:01:09.740 --> 00:01:11.480
and that's the emulator.

00:01:11.480 --> 00:01:16.310
And it just so happens that our
platform is completely built on J2SE.

00:01:16.330 --> 00:01:19.460
So we have a J2ME implementation on J2SE.

00:01:19.470 --> 00:01:22.650
The neat thing for you guys is that
this is actually a full-on MIDP2

00:01:22.650 --> 00:01:26.610
emulator that runs on the Mac,
and you can use this today to build

00:01:26.610 --> 00:01:29.680
MIDP applications on your Macintosh.

00:01:29.680 --> 00:01:33.000
So what are we going to talk about?

00:01:33.000 --> 00:01:36.310
Mobile development using Xcode
and the Macintosh platform.

00:01:36.310 --> 00:01:39.900
I'm going to basically
cover three things.

00:01:39.900 --> 00:01:43.130
One is why you should care
about mobile development.

00:01:43.130 --> 00:01:48.050
Two is, you know, what J2ME, MIDP,
what that's all about.

00:01:48.080 --> 00:01:48.660
And then the third thing is, you know,
what is the best way to

00:01:48.670 --> 00:01:49.160
build mobile applications?

00:01:49.160 --> 00:01:51.860
And then three, we'll talk about mobile
Java applications,

00:01:51.860 --> 00:01:55.520
you know, the guts of it,
so that when we get to Ted's portion,

00:01:55.520 --> 00:02:00.840
he'll show you how to develop, debug,
and deploy those applications.

00:02:00.840 --> 00:02:02.790
So let's get started.

00:02:03.500 --> 00:06:21.400
[Transcript missing]

00:06:22.100 --> 00:06:27.400
This graph is half backward-looking
and half forward-looking.

00:06:27.400 --> 00:06:30.410
We're right in the middle, in year 2005.

00:06:30.510 --> 00:06:33.960
If you look at the blue line there,
that's the line that may be familiar

00:06:33.960 --> 00:06:35.230
to most of you in this room.

00:06:35.300 --> 00:06:38.130
That's the market for desktop games.

00:06:38.190 --> 00:06:40.140
We're talking Mac, Windows,
and even Linux.

00:06:40.150 --> 00:06:42.390
Those are billions of dollars.

00:06:42.400 --> 00:06:45.660
Those are revenues in the market.

00:06:45.660 --> 00:06:46.800
Look at the red line.

00:06:46.800 --> 00:06:48.430
That's mobile entertainment.

00:06:48.510 --> 00:06:50.790
It's not just all mobile entertainment.

00:06:50.800 --> 00:06:52.940
It's just ringtones.

00:06:52.940 --> 00:06:54.700
These aren't even real songs.

00:06:54.710 --> 00:06:58.110
They're portions of songs that
people are buying for their

00:06:58.110 --> 00:07:00.670
mobile phones to personalize them.

00:07:00.900 --> 00:07:05.700
It's dwarfing the size of the
entire desktop application industry.

00:07:05.700 --> 00:07:07.540
This is why you ought to
be interested in this,

00:07:07.540 --> 00:07:08.890
because look at the green line.

00:07:09.020 --> 00:07:12.070
That's mobile applications,
specifically mobile games.

00:07:12.120 --> 00:07:13.260
You can see that it's growing.

00:07:13.260 --> 00:07:15.460
In the next two years,
it's projected by more

00:07:15.460 --> 00:07:15.640
than one billion people.

00:07:15.640 --> 00:07:19.950
We're going to be the number one
research firm to outpace both desktop

00:07:19.980 --> 00:07:24.320
applications and mobile ringtones
as being the dominant factor,

00:07:24.320 --> 00:07:26.620
the dominant way people
purchase entertainment software.

00:07:26.620 --> 00:07:29.040
That's an exciting place to be.

00:07:29.060 --> 00:07:32.300
We want to help you guys
get into that market.

00:07:32.570 --> 00:07:35.120
So I talked about these
kinds of applications.

00:07:35.160 --> 00:07:40.170
Let me show you a few,
if we can switch to demo one, please.

00:07:41.250 --> 00:07:46.280
I'm going to demo some of these things
using our storefront technology software,

00:07:46.320 --> 00:07:48.470
which lets you see these
things on the desktop,

00:07:48.520 --> 00:07:53.990
which is a great way for us to
show these games to you today.

00:07:54.540 --> 00:08:09.560
and Michael Powers, and I guess,
you know, I talked about web services

00:08:09.560 --> 00:08:09.560
apps and personal apps.

00:08:09.560 --> 00:08:09.560
Let me show you an example of this,
and it just so happens to be an

00:08:09.560 --> 00:08:09.560
application I wrote a few years ago
called Piranha Price Check because it

00:08:09.560 --> 00:08:09.560
neatly demonstrates both of those things.

00:08:09.560 --> 00:08:09.560
If you have a phone, actually,
you can--you

00:08:10.200 --> 00:08:14.200
You can actually download
it from ota.empowers.net.

00:08:14.240 --> 00:08:17.580
It's a free application.

00:08:18.460 --> 00:08:19.300
Here it is.

00:08:19.400 --> 00:08:22.540
And it's a web service that
uses Amazon's web service to let

00:08:22.540 --> 00:08:24.520
you easily browse information.

00:08:24.590 --> 00:08:28.490
And you can see that it plays
like a phone user interface.

00:08:28.540 --> 00:08:31.950
You can go through and browse categories.

00:08:32.000 --> 00:08:35.060
A lot of phones prompt the user
when they have a network connection.

00:08:35.060 --> 00:08:37.740
We'll just say always so we
don't get prompted every time.

00:08:37.890 --> 00:08:38.800
And there you go.

00:08:38.800 --> 00:08:44.730
We're getting live information because
the network is cooperating with us.

00:08:44.740 --> 00:08:46.090
And it's there.

00:08:46.090 --> 00:08:47.800
And these are the features of

00:08:48.400 --> 00:08:49.180
Toronto Price Check.

00:08:49.260 --> 00:08:50.730
This is what you can do with MIDP.

00:08:50.750 --> 00:08:54.280
This is actually a MIDP 1.0 application.

00:08:54.280 --> 00:08:58.510
You get access to user
interface with images,

00:08:58.510 --> 00:08:59.340
text.

00:08:59.340 --> 00:09:01.680
Our implementation actually
is on top of desktop UI,

00:09:01.680 --> 00:09:05.140
so we actually support
things like drag and drop,

00:09:05.250 --> 00:09:06.720
but you never know.

00:09:06.720 --> 00:09:08.160
The nice thing is that
you're abstracted from that.

00:09:08.160 --> 00:09:15.920
You just have to write to the form API,
and you get these things for free.

00:09:15.920 --> 00:09:17.770
That's one application.

00:09:19.510 --> 00:09:20.330
Let me show you another one.

00:09:20.330 --> 00:09:22.480
I talked about casual games.

00:09:22.480 --> 00:09:24.800
This is what I'm talking about.

00:09:24.800 --> 00:09:29.760
This application actually is written
using the-- if the network cooperates,

00:09:29.810 --> 00:09:33.070
we're loading these things
live over the network,

00:09:33.070 --> 00:09:35.590
much like a phone would do over the air.

00:09:35.590 --> 00:09:38.170
This is a simple casual game.

00:09:38.390 --> 00:09:41.700
It's a clone of a popular game.

00:09:41.700 --> 00:09:44.690
I can't remember which one.

00:09:45.020 --> 00:09:49.200
For devices that support
pointing devices like styluses,

00:09:49.200 --> 00:09:54.040
like the Sony Ericsson P800, P900,
you can click on these guys.

00:09:54.040 --> 00:09:56.610
If you don't do that,
Mid-P lets you have access

00:09:56.610 --> 00:09:58.080
to the keyboard as well.

00:09:58.080 --> 00:10:00.820
You can actually go through
and select these guys.

00:10:00.820 --> 00:10:03.430
This is the kind of game that
somebody picks up and puts down.

00:10:03.430 --> 00:10:04.590
It's a casual game.

00:10:04.590 --> 00:10:07.200
These things are selling
like gangbusters.

00:10:07.200 --> 00:10:08.210
All right.

00:10:08.210 --> 00:10:11.110
Let's look at something else here.

00:10:14.100 --> 00:10:27.410
This application,
assuming it comes across the network,

00:10:27.410 --> 00:10:27.410
going very slow.

00:10:27.410 --> 00:10:27.410
I was working fine about 20 minutes ago,
but maybe, you know, you never know.

00:10:29.490 --> 00:10:31.640
This is actually from a
company called Gameloft.

00:10:31.640 --> 00:10:34.600
They're split off of Ubisoft,
which is a huge entertainment

00:10:34.600 --> 00:10:36.540
company that EA is trying to acquire.

00:10:36.690 --> 00:10:42.000
This is their mobile division.

00:10:46.600 --> 00:10:48.440
This is actually like
SIMs for your mobile,

00:10:48.440 --> 00:10:50.670
and this is actually very
popular with a lot of people.

00:10:50.700 --> 00:10:55.720
I mentioned in an earlier slide
something about the demographics.

00:10:55.720 --> 00:10:59.940
You know,
currently in the mobile industry--wow,

00:10:59.970 --> 00:11:02.080
that's really trippy.

00:11:02.080 --> 00:11:02.080
Okay.

00:11:03.760 --> 00:11:05.000
or currently in the
entertainment industry,

00:11:05.000 --> 00:11:07.220
you get a lot of console gamers,
hardcore gamers.

00:11:07.220 --> 00:11:10.620
Well, the nice thing about the mobile
space is that everyone has a phone,

00:11:10.620 --> 00:11:11.740
and if they don't, they will.

00:11:11.740 --> 00:11:14.240
So your demographics are
pretty much like 50-50,

00:11:14.240 --> 00:11:15.600
male, female, young, old.

00:11:15.600 --> 00:11:17.900
It mirrors the population,
generally speaking.

00:11:17.900 --> 00:11:20.050
And so you're going to get more
games that are appealing to lots

00:11:20.050 --> 00:11:21.280
of different kinds of people.

00:11:21.280 --> 00:11:25.860
So this is actually like a Sims kind of
clone that is actually pretty addicting,

00:11:25.860 --> 00:11:27.580
at least with our company.

00:11:27.580 --> 00:11:30.880
And you go around and
you have adventures.

00:11:30.880 --> 00:11:33.500
You're like the Sims, and it's cool,
and it's completely possible,

00:11:33.640 --> 00:11:34.440
on the mobile platform.

00:11:34.440 --> 00:11:37.810
Let me show you another one.

00:11:41.730 --> 00:11:42.720
We showed this one yesterday.

00:11:42.720 --> 00:11:48.000
So you'll see that we get
the... As we're loading,

00:11:48.000 --> 00:11:49.040
we already fetched the metadata.

00:11:49.040 --> 00:11:50.180
I'll get back to that in a second.

00:11:50.180 --> 00:11:51.960
That's something about
the JAD and JAR file.

00:11:51.960 --> 00:11:53.470
Remember I said this,
because you'll see that

00:11:53.470 --> 00:11:54.050
things are loading.

00:11:54.060 --> 00:11:56.260
We see the name of the application,
and we know the size

00:11:56.260 --> 00:11:57.260
before we downloaded it.

00:11:57.280 --> 00:12:00.160
But this is another game from Gameloft.

00:12:00.160 --> 00:12:03.910
Currently in the industry,
there's a lot of... A lot

00:12:03.910 --> 00:12:09.120
of these titles are kind of
migrating from the console world.

00:12:09.120 --> 00:12:10.100
This is a prime example.

00:12:10.300 --> 00:12:12.640
I think some of you may have
played Tom Clancy's Splinter Cell.

00:12:12.640 --> 00:12:16.900
It's a stealth kind of game where you
sneak around and conduct missions.

00:12:16.900 --> 00:12:19.790
But this is the mobile version.

00:12:19.800 --> 00:12:21.370
♪

00:12:22.800 --> 00:12:24.200
"And the sound is great too, right?

00:12:24.200 --> 00:12:26.800
I mean, this is just MIDI, you know,
so it's good stuff."

00:12:31.730 --> 00:12:38.610
We showed this Tuesday at
the Java kickoff session.

00:12:40.410 --> 00:12:43.260
These are platform games.

00:12:43.260 --> 00:12:45.040
These platform games are
actually getting pretty good.

00:12:45.170 --> 00:12:50.080
They're not afraid to show them off
anymore because the games in the

00:12:50.140 --> 00:12:52.160
mobile space don't suck anymore.

00:12:52.160 --> 00:12:54.680
This is what gives you a lot
of hope and promise for those

00:12:54.770 --> 00:12:56.800
projections I was showing you earlier.

00:12:56.800 --> 00:13:02.790
Let's wrap that up.

00:13:02.790 --> 00:13:02.790
Let's go back to the slides, please.

00:13:06.750 --> 00:13:09.460
So, I talked about the mobile industry,
right?

00:13:09.460 --> 00:13:12.300
So,
the mobile space and why it's important.

00:13:12.300 --> 00:13:14.130
Let's talk about how you'd
get involved in that.

00:13:14.140 --> 00:13:19.540
So, Sun is pretty much, you know,
actually playing a very dominant role

00:13:19.540 --> 00:13:22.630
in the -- with Java in the mobile space,
where most of these games

00:13:22.630 --> 00:13:24.580
are written in Java.

00:13:24.580 --> 00:13:26.780
And it's through technologies
that fall under the umbrella of

00:13:26.800 --> 00:13:29.460
the J2ME Micro Java Framework.

00:13:29.460 --> 00:13:31.700
Okay, you're familiar with J2EE.

00:13:31.700 --> 00:13:35.590
That's the server-side stuff,
web services, faceless applications.

00:13:35.590 --> 00:13:39.480
J2SE is like applets, applications,
and Web Start apps.

00:13:39.480 --> 00:13:44.460
J2ME actually runs the gamut of a large,
you know, array of devices.

00:13:44.460 --> 00:13:49.410
We're talking all the way from
like set-top media center boxes

00:13:49.410 --> 00:13:54.160
to kitchen appliances to PDAs,
mobile phones, and all the way down to,

00:13:54.160 --> 00:13:58.100
you know, pagers and fax machines,
things that have one line of text,

00:13:58.100 --> 00:14:00.130
you know, very simple, you know, UIs.

00:14:00.130 --> 00:14:01.960
Okay, these are embedded systems.

00:14:01.980 --> 00:14:04.080
And J2ME is designed
to address that space.

00:14:04.080 --> 00:14:06.820
Now,
this is kind of a complicated diagram,

00:14:06.820 --> 00:14:09.920
but I just want to draw your attention
to one slice of it going down.

00:14:09.920 --> 00:14:15.960
Okay, so draw a line from mobile phones
going down through mid-P and CLDC.

00:14:16.000 --> 00:14:18.000
That's the technology stack
we're talking about here.

00:14:18.000 --> 00:14:18.920
Okay?

00:14:18.920 --> 00:14:23.440
The J2ME world is kind of split up
into profiles and configurations.

00:14:23.440 --> 00:14:23.940
Okay?

00:14:24.010 --> 00:14:26.770
The configurations are across the bottom.

00:14:26.830 --> 00:14:31.110
Mobile phones fall into a category called
connected limited device configuration.

00:14:31.300 --> 00:14:34.760
These are kind of a subset
of the capabilities of the

00:14:34.760 --> 00:14:36.870
higher-end applications.

00:14:36.930 --> 00:14:39.540
And built on this kind of core
foundation layer is the mobile

00:14:39.750 --> 00:14:43.440
information device profile,
which has API specific to mobile phones,

00:14:43.440 --> 00:14:46.380
things like working with keypads
and mobile phone screens,

00:14:46.420 --> 00:14:47.920
that kind of thing.

00:14:47.920 --> 00:14:50.360
That's the technology stack that's
really all these games that you

00:14:50.370 --> 00:14:52.220
just saw is built on top of.

00:14:52.220 --> 00:14:54.980
So let's go into that
into a little more detail.

00:14:55.040 --> 00:14:57.290
So we're drilling

00:14:57.800 --> 00:16:18.400
[Transcript missing]

00:16:19.890 --> 00:16:22.800
So at the very bottom,
the virtual machine layer.

00:16:22.800 --> 00:16:26.070
Okay, so you're familiar with
Java virtual machines,

00:16:26.070 --> 00:16:31.800
but in the embedded space,
many engineers labored to produce

00:16:31.800 --> 00:16:35.800
a Java virtual machine that
runs in an embedded device.

00:16:35.800 --> 00:16:39.800
This is maybe four or five years ago now.

00:16:39.800 --> 00:16:44.800
They were laboring to get this stuff
working in a very limited specification.

00:16:44.800 --> 00:16:48.640
We're talking 32 kilobytes of heap,
aka persistent storage,

00:16:48.640 --> 00:16:50.800
but they ultimately did succeed.

00:16:50.800 --> 00:16:54.780
And the nice thing is that, as I said,
Moore's Law is at work.

00:16:54.800 --> 00:16:57.740
And in the last year, if you look at the
devices that were sold,

00:16:57.800 --> 00:17:01.800
it was hard to walk out of a phone
store with anything less than a device

00:17:01.800 --> 00:17:07.800
that had hundreds of kilobytes of heap,
megabytes of persistent storage,

00:17:07.960 --> 00:17:12.800
hundreds of pixels on a side,
thousands of colors.

00:17:12.800 --> 00:17:14.790
Those are very capable devices.

00:17:14.800 --> 00:17:17.800
And you can actually do
interesting things with them.

00:17:17.930 --> 00:17:19.790
But even more interesting
is looking forward.

00:17:19.800 --> 00:17:21.800
And that's, you know, 2005 and beyond.

00:17:21.800 --> 00:17:24.800
We're seeing quarter VGA,
megabytes of heap.

00:17:24.800 --> 00:17:28.800
We're seeing 2D and 3D
hardware acceleration.

00:17:28.800 --> 00:17:31.800
So it's a compelling platform
for application development.

00:17:32.650 --> 00:17:34.650
So how do you get at these capabilities?

00:17:34.710 --> 00:17:37.840
Well, you work with the Java APIs.

00:17:37.980 --> 00:17:42.900
and we'll talk first about
the core layer which is CLDC.

00:17:42.910 --> 00:17:48.900
This is basically a subset of the things
you find on J2SE's core libraries.

00:17:48.900 --> 00:17:53.300
You have the Java lang, Java IO,
Java util packages.

00:17:53.450 --> 00:17:56.700
But in each package,
each package contains a subset of

00:17:56.700 --> 00:17:59.200
the classes that you'd find on J2SE.

00:17:59.200 --> 00:18:02.700
And each of those classes has
a subset of the methods you

00:18:02.700 --> 00:18:05.010
find on those classes on J2SE.

00:18:05.010 --> 00:18:06.460
It's a clean subset.

00:18:06.630 --> 00:18:10.740
So if you write logic or code that
uses just those APIs and CLDC,

00:18:10.740 --> 00:18:12.660
it is Upworth compatible.

00:18:12.700 --> 00:18:16.960
This is the magic trick that
allows these mobile Java apps to

00:18:16.960 --> 00:18:20.330
actually run on our emulation stack.

00:18:20.840 --> 00:18:23.420
So you're probably
interested in what's missing,

00:18:23.520 --> 00:18:24.390
what can't you do?

00:18:24.400 --> 00:18:25.700
That's easier to think about.

00:18:25.700 --> 00:18:27.920
So let's talk about that.

00:18:27.950 --> 00:18:30.160
First off, reflection is missing.

00:18:30.160 --> 00:18:32.080
Serialization is missing.

00:18:32.080 --> 00:18:35.280
There's no file system,
so you don't get file I/O.

00:18:35.280 --> 00:18:38.360
There's no collections classes, no lists,
sets or maps.

00:18:38.510 --> 00:18:41.120
You have what you always had in Java 1.1.

00:18:41.120 --> 00:18:45.840
You have vector and hash table,
and that's enough.

00:18:45.840 --> 00:18:48.950
Also, you don't have floating point.

00:18:48.950 --> 00:18:48.950
You

00:18:49.070 --> 00:18:50.680
And you don't have weak references.

00:18:50.760 --> 00:18:57.000
However, those two were added to the
CLDC specification in the 1.1 Rev.

00:18:57.000 --> 00:19:01.650
However,
because MIDP doesn't require CLDC 1.1,

00:19:01.850 --> 00:19:06.960
not all devices require -- not
all devices implement CLDC 1.1.

00:19:07.040 --> 00:19:12.340
So if you want to use those features
or you need to use those features,

00:19:12.340 --> 00:19:14.910
keep in mind that you're
going to be addressing a

00:19:14.910 --> 00:19:14.910
different segment of the market.

00:19:16.220 --> 00:19:17.740
So that's the core foundation layer.

00:19:17.740 --> 00:19:21.260
Let's go up a step and actually
look at the device-specific,

00:19:21.260 --> 00:19:22.960
mobile phone-specific APIs.

00:19:22.960 --> 00:19:27.070
That's the MIDP layer,
Mobile Information Device Profile.

00:19:27.470 --> 00:19:32.200
So, MIDP 1.0 is where almost all of
these applications are written to,

00:19:32.200 --> 00:19:38.230
and there are a quarter billion handsets
supporting MIDP 1.0 in use today,

00:19:38.360 --> 00:19:39.010
active use.

00:19:39.090 --> 00:19:42.200
People have these in their pockets
and purses all over the world.

00:19:42.200 --> 00:19:46.210
What kinds of capabilities
does the MIDP specification

00:19:46.210 --> 00:19:47.630
give you in terms of APIs?

00:19:48.560 --> 00:19:53.100
At the low level, fundamentally,
you get access to the screen.

00:19:53.100 --> 00:19:55.460
You have a canvas and you
have a graphics object,

00:19:55.490 --> 00:19:56.710
and you can write to the screen.

00:19:56.710 --> 00:20:00.350
For user input,
you have access to the keys,

00:20:00.550 --> 00:20:04.350
the number pad, the D-pad,
enter or fire key,

00:20:04.360 --> 00:20:07.560
and then you have access
to optional pointing,

00:20:07.570 --> 00:20:11.130
a pointer API, like a mouse-style API,
pointer down, pointer up,

00:20:11.150 --> 00:20:12.760
if the device supports a stylus.

00:20:12.760 --> 00:20:15.930
So, with that, the world is your oyster.

00:20:15.950 --> 00:20:17.010
You can do just about anything.

00:20:17.020 --> 00:20:21.770
And most of these games you just saw were
written just with those low-level APIs.

00:20:21.780 --> 00:20:23.190
But wait, there's more.

00:20:23.270 --> 00:20:26.820
On the high level, a little higher up,
there's a form API.

00:20:27.100 --> 00:20:29.600
That Piranha price check application,
you probably saw those

00:20:29.600 --> 00:20:30.870
were using native widgets.

00:20:31.160 --> 00:20:32.390
That's the form API.

00:20:32.430 --> 00:20:32.900
Okay?

00:20:32.900 --> 00:20:33.810
You have access.

00:20:33.880 --> 00:20:37.360
It's very high level, very simple to use,
and that's how you can generate

00:20:37.360 --> 00:20:38.970
data entry applications.

00:20:39.050 --> 00:20:43.630
And you get things like text fields,
check boxes, lists,

00:20:43.780 --> 00:20:45.730
those kinds of things.

00:20:46.200 --> 00:20:48.620
What's useful about that is that
when you write using those APIs,

00:20:48.720 --> 00:20:50.200
it looks like it belongs on the phone.

00:20:50.220 --> 00:20:51.100
It's not a custom UI.

00:20:51.100 --> 00:20:53.100
It takes on the user
interface of the phone.

00:20:53.100 --> 00:20:55.100
What else is there?

00:20:55.100 --> 00:20:56.100
Networking.

00:20:56.100 --> 00:21:01.090
MIDP defines something called
the General Connection Framework,

00:21:01.170 --> 00:21:04.090
Generic Connection Framework, GCF.

00:21:04.120 --> 00:21:07.070
And that's a real simple API.

00:21:07.110 --> 00:21:08.460
It's in one line of code.

00:21:08.460 --> 00:21:11.400
You can pass in a string URL and
get back an input stream,

00:21:11.400 --> 00:21:13.100
and you're off to the races.

00:21:13.100 --> 00:21:15.040
So it couldn't be easier.

00:21:15.130 --> 00:21:20.420
The actual protocols that are
supported vary from device to device,

00:21:20.420 --> 00:21:24.100
but you're guaranteed
to have at least HTTP.

00:21:24.900 --> 00:21:54.200
[Transcript missing]

00:21:54.540 --> 00:21:55.400
Images.

00:21:55.800 --> 00:21:58.940
Built-in support is
specified for PNG format.

00:21:58.970 --> 00:22:05.680
Some devices support JPEG,
but GIF is right out.

00:22:05.680 --> 00:22:08.830
PNG is pretty good,
and that's good enough for now.

00:22:08.830 --> 00:22:13.270
But the audio support, unfortunately,
is nonexistent.

00:22:13.360 --> 00:22:16.920
There's no audio API in MIDP,
and this is kind of the rub, right?

00:22:16.990 --> 00:22:22.430
So you can tell by this fact alone
that when they developed the MIDP APIs,

00:22:22.430 --> 00:22:25.720
they weren't thinking about games,
because it seems like an odd omission.

00:22:25.870 --> 00:22:32.770
Because of this, this caused some
fracturing in the market,

00:22:32.900 --> 00:22:35.940
because every device manufacturer,
they all supported sound.

00:22:35.940 --> 00:22:39.880
They had to come up with their
own APIs for accessing that sound.

00:22:39.880 --> 00:22:43.460
So you have Nokia APIs for sound,
Motorola APIs for sound,

00:22:43.460 --> 00:22:45.360
Sprint PCS APIs for sound.

00:22:45.380 --> 00:22:49.240
So for that reason,
people like Gameloft have to develop,

00:22:49.240 --> 00:22:52.880
when Prince of Persia:
Warrior Within was released,

00:22:52.880 --> 00:22:57.660
they had to actually develop 155
different versions of that to support

00:22:57.820 --> 00:23:01.970
all of these different handsets and
their own particular sound capabilities.

00:23:02.070 --> 00:23:05.980
So clearly, something had to be done.

00:23:07.850 --> 00:23:09.850
MIDP 2.0.

00:23:09.850 --> 00:23:12.420
Actually,
MIDP 2.0 was released a good while ago,

00:23:12.420 --> 00:23:16.940
and it's pretty common on the
devices that are being sold today.

00:23:16.990 --> 00:23:19.810
But by 2007,
projections indicate that there

00:23:19.810 --> 00:23:22.840
will be a billion MIDP 2.0
handsets out there in the world.

00:23:22.860 --> 00:23:25.820
So it's worth thinking about
targeting the MIDP 2.0 APIs.

00:23:25.820 --> 00:23:30.730
What does MIDP 2.0 add in
addition to what was in MIDP 1.0?

00:23:30.820 --> 00:23:33.820
Well,
let's go through those categories again.

00:23:33.830 --> 00:23:36.520
Most interestingly,
it's like they learned their lesson.

00:23:36.570 --> 00:23:39.820
On the low-level API,
you now have a built-in

00:23:39.820 --> 00:23:42.940
Java-ratified standardized games API.

00:23:42.940 --> 00:23:49.420
In the MIDP 1.0 world,
people had to sweat blood and tears

00:23:49.420 --> 00:23:54.440
to get things to be performant on lots
of different devices using just the

00:23:54.440 --> 00:23:55.720
low-level APIs that were provided.

00:23:55.720 --> 00:24:03.420
With MIDP 2.0, you get sprites, layers,
blitting, direct access to image arrays,

00:24:03.420 --> 00:24:05.580
all the things that
game developers wanted.

00:24:05.690 --> 00:24:09.630
So if you write to those APIs,
you can rest reasonably assured that

00:24:09.700 --> 00:24:13.510
the device manufacturers have taken
the time to optimize those calls.

00:24:13.650 --> 00:24:18.180
So it's a great way to actually save
yourself a lot of effort and time in

00:24:18.180 --> 00:24:21.420
writing these entertainment applications.

00:24:21.630 --> 00:24:25.400
Moving back a bit to the high-level APIs,
in addition to the capabilities

00:24:25.400 --> 00:24:28.950
I described earlier,
you now have the ability to write custom

00:24:28.950 --> 00:24:36.500
form widgets that give you access to
the native themes and the native fonts.

00:24:36.500 --> 00:24:39.380
You can actually make customized
forms that look like the

00:24:39.380 --> 00:24:40.860
native operating system.

00:24:40.860 --> 00:24:43.480
On networking, I mentioned the generic
connection framework.

00:24:43.600 --> 00:24:47.300
Well, apparently it was too generic,
so now they've added interfaces that

00:24:47.300 --> 00:24:51.430
you can cast your connection objects to,
to get access to fine-tune the

00:24:51.430 --> 00:24:53.460
features of your connections.

00:24:53.520 --> 00:24:56.800
Things like for HTTPS,
if you have an HTTPS connection,

00:24:56.800 --> 00:25:01.340
you can cast it and then get access to
the certificate and things like that.

00:25:01.340 --> 00:25:04.490
On persistence,
you have access to record stores

00:25:04.490 --> 00:25:08.790
that are shared across applications,
which enables you as developers to write

00:25:08.810 --> 00:25:13.980
suites of applications that interact
with a common calendar or address book.

00:25:13.980 --> 00:25:16.660
And for audio,
there is now audio support.

00:25:16.670 --> 00:25:17.710
And it's very simple.

00:25:17.720 --> 00:25:19.340
You can, in one line of code,
load and play a sound.

00:25:19.340 --> 00:25:23.060
It couldn't be simpler.

00:25:23.060 --> 00:25:27.340
And in fact,
the specified sound behavior in MIDP2 is

00:25:27.340 --> 00:25:30.620
a subset of a larger API that's optional.

00:25:30.620 --> 00:25:34.500
And we'll talk about the
optional APIs right now.

00:25:34.500 --> 00:25:36.540
So that's MIDP2.

00:25:36.540 --> 00:25:39.960
On top of MIDP2,
you have optional packages,

00:25:39.960 --> 00:25:42.960
one of which I just talked
about is the mobile media API.

00:25:42.960 --> 00:25:45.120
And since a lot of these
devices support media,

00:25:45.120 --> 00:25:46.640
and media is an increasingly important
part of the mobile experience,

00:25:46.670 --> 00:25:47.390
you can use it to create
a mobile experience.

00:25:47.390 --> 00:25:47.820
You can use it to create
a mobile experience.

00:25:47.820 --> 00:25:48.240
You can use it to create
a mobile experience.

00:25:48.240 --> 00:25:49.380
mobile experience.

00:25:49.490 --> 00:25:51.060
There are now APIs to access it.

00:25:51.060 --> 00:25:54.040
And if you're familiar with
the Java media framework,

00:25:54.080 --> 00:25:56.830
the mobile media
API works very similarly.

00:25:56.830 --> 00:26:01.250
It's the same architecture,
just slimmed down, simplified,

00:26:01.250 --> 00:26:04.040
and in my mind, improved over JMF.

00:26:04.090 --> 00:26:04.720
What can you do?

00:26:04.810 --> 00:26:10.670
You can do audio playback, audio capture,
image capture if there's a camera,

00:26:10.680 --> 00:26:14.930
and video playback,
as well as streaming video playback.

00:26:14.930 --> 00:26:17.440
All very interesting capabilities.

00:26:17.440 --> 00:26:19.840
It's an optional API,
but a lot of devices support it.

00:26:19.900 --> 00:26:23.470
But just keep in mind what your target
audience is and what the devices

00:26:23.470 --> 00:26:25.900
are before you start using this API.

00:26:25.900 --> 00:26:28.950
And you can test for
these APIs at runtime,

00:26:28.950 --> 00:26:35.640
so you can kind of keep
your code base simplified.

00:26:35.640 --> 00:26:39.460
Another more specific API that
isn't quite in wide distribution

00:26:39.460 --> 00:26:41.830
is the Scalable 2D Graphics API.

00:26:41.840 --> 00:26:47.430
This is sponsored by Nokia and actually
adopted by Nokia and Sony Ericsson.

00:26:47.430 --> 00:26:48.920
Think about it.

00:26:48.920 --> 00:26:52.910
It's not like Java 2D,
but it's more like Flash because it

00:26:52.910 --> 00:26:56.160
has support for SVG-style animations.

00:26:56.160 --> 00:27:00.200
So you can actually interact,
playback and interact with these things

00:27:00.200 --> 00:27:06.300
in code and give the user an environment
where they can view SVG animations.

00:27:06.300 --> 00:27:09.170
But what's also interesting is
that you can take an SVG object and

00:27:09.280 --> 00:27:12.780
render it to your low-level graphics,
your canvas.

00:27:12.780 --> 00:27:16.190
So that's a great way of getting
images to your canvas because,

00:27:16.210 --> 00:27:17.200
as you all probably know,
vector graphics are a lot

00:27:17.200 --> 00:27:17.760
more complex than a simple,
simple, simple,

00:27:17.760 --> 00:27:21.450
simple their graphics are much smaller
than their raster counterparts and

00:27:21.450 --> 00:27:24.860
they're scalable so you don't have
to worry about whether your graphics

00:27:24.860 --> 00:27:28.350
are the right size for the screen
because in the mobile world every

00:27:28.350 --> 00:27:30.720
device has a different screen size.

00:27:30.720 --> 00:27:33.040
So those are useful capabilities.

00:27:33.040 --> 00:27:34.740
But it's optional.

00:27:34.780 --> 00:27:39.830
Perhaps the most exciting API is
the mobile 3D API because this

00:27:39.830 --> 00:27:44.090
is what's kind of fueling a lot
of the current game development.

00:27:44.090 --> 00:27:49.240
Mobile 3D graphics is supported on
an increasing number of handsets

00:27:49.390 --> 00:27:53.130
and it's a scene graph API,
light Java 3D but again

00:27:53.150 --> 00:27:57.320
simplified and if you like simple,
if you think simple is better,

00:27:57.430 --> 00:27:58.400
it's better.

00:27:58.400 --> 00:28:02.550
It's suitable for games and it
gives you access to writing 3D

00:28:02.570 --> 00:28:05.860
applications in a very simple manner.

00:28:05.860 --> 00:28:08.570
These APIs are supported by
the newer handsets from Nokia,

00:28:08.570 --> 00:28:10.840
Sony Ericsson, Motorola and others.

00:28:10.840 --> 00:28:15.290
I actually want to show you support
that we are actually building right now.

00:28:15.300 --> 00:28:15.400
If we can switch.

00:28:15.660 --> 00:28:20.710
I'm going to switch to demo one
please for mobile 3D graphics

00:28:20.710 --> 00:28:22.640
because we see this as a big deal.

00:28:25.340 --> 00:28:29.140
It's preliminary support,
and actually it's more like a

00:28:29.210 --> 00:28:32.710
proof of concept at this point,
but we're rolling it out

00:28:32.710 --> 00:28:34.540
by the end of the year.

00:28:42.050 --> 00:28:42.980
There you go.

00:28:43.030 --> 00:28:45.330
So what you get is textures.

00:28:45.430 --> 00:28:51.000
It has its own scene graph
serialization format,

00:28:51.000 --> 00:28:56.270
and there's support for animation tracks,
cameras, lights.

00:28:56.650 --> 00:29:00.290
It's not much of a demo,
but it works and it rotates.

00:29:00.380 --> 00:29:02.420
But it's running,
and this is an application

00:29:02.510 --> 00:29:06.070
written for mobile 3D,
and it just works on our player.

00:29:06.120 --> 00:29:09.370
So going forward,
you'll be able to write these

00:29:09.390 --> 00:29:11.180
applications with our software.

00:29:14.000 --> 00:29:17.680
If we could switch back to the slides.

00:29:17.690 --> 00:29:19.680
Okay, so where have we been?

00:29:19.680 --> 00:29:21.240
We talked about the mobile market.

00:29:21.240 --> 00:29:24.000
We talked about the J2ME environment.

00:29:24.000 --> 00:29:30.150
So let's talk about what a
midlet is and how you write one,

00:29:30.150 --> 00:29:33.000
what it feels like.

00:29:33.720 --> 00:29:34.440
What is a midlet?

00:29:34.650 --> 00:29:35.510
Okay, hands-on.

00:29:35.560 --> 00:29:38.930
So a midlet is basically a jar file,
right?

00:29:39.040 --> 00:29:42.710
It contains all of the classes,
the resources, the images, the sounds,

00:29:42.740 --> 00:29:43.230
whatever you need.

00:29:43.290 --> 00:29:44.700
It's all in one jar file.

00:29:44.820 --> 00:29:47.190
Every class in the midlet
needs to be pre-verified.

00:29:47.190 --> 00:29:48.870
We'll get to that in a minute.

00:29:48.880 --> 00:29:54.740
And then one of those classes
in the jar is a subclass of

00:29:54.740 --> 00:29:59.170
JavaX Micro Edition midlet.midlet,
okay?

00:29:59.220 --> 00:30:01.330
That's your entry point, okay?

00:30:01.330 --> 00:30:03.260
That's what makes a midlet.

00:30:03.420 --> 00:30:05.330
Midlets are typically,
in this day and age,

00:30:05.340 --> 00:30:08.320
hundreds of kilobytes in size,
although some devices,

00:30:08.320 --> 00:30:12.670
like the Nokia Series 40 devices,
have an artificial limit of, say,

00:30:12.740 --> 00:30:14.040
64 kilobytes.

00:30:14.040 --> 00:30:18.740
So smaller is better,
but know which devices you're targeting.

00:30:18.740 --> 00:30:22.460
A midlet jar is almost never
seen without its counterpart,

00:30:22.480 --> 00:30:24.060
which is the JAD file.

00:30:24.060 --> 00:30:28.160
JAD, in this case,
stands for Java Application Descriptor.

00:30:28.720 --> 00:30:30.460
It's a properties file.

00:30:30.540 --> 00:30:33.360
It's a text file, like a manifest almost.

00:30:33.360 --> 00:30:35.920
It contains metadata for the application.

00:30:35.920 --> 00:30:39.330
It contains things like the
name of the application.

00:30:39.460 --> 00:30:42.660
Importantly, the entry point,
which of those classes in the

00:30:42.720 --> 00:30:45.280
archive is the main midlet class.

00:30:45.280 --> 00:30:48.710
And it contains important
things for the device,

00:30:48.810 --> 00:30:50.010
like the size of the jar.

00:30:50.020 --> 00:30:51.200
It's like a preview.

00:30:51.200 --> 00:30:53.120
In fact, phones use it as such.

00:30:53.120 --> 00:30:54.900
As you saw in the demo earlier,
our player was actually

00:30:54.900 --> 00:30:56.900
accessing the jar file,
and it was actually using the jar file.

00:30:56.910 --> 00:30:57.310
It's like a preview.

00:30:57.310 --> 00:30:57.910
In fact, phones use it as such.

00:30:57.910 --> 00:30:58.640
As you saw in the demo earlier,
our player was actually

00:30:58.640 --> 00:30:58.640
accessing the jar file,
and it was actually

00:30:58.640 --> 00:30:58.640
accessing the jar file.

00:30:58.640 --> 00:31:02.000
I'm sorry,
the JAD file first to get the preview

00:31:02.000 --> 00:31:06.180
information so it could show something
to you while it was loading the jar.

00:31:06.240 --> 00:31:09.600
And in fact, it knew how big the jar was,
so it can give you a progress indicator.

00:31:09.600 --> 00:31:11.840
That's important on
the phone devices too,

00:31:11.840 --> 00:31:15.500
because the phones will want to get
just the JAD file and then show you how

00:31:15.500 --> 00:31:18.480
big it is so you can determine whether
you have space for it or whether you

00:31:18.480 --> 00:31:23.290
even want it before you click okay,
and then it will bring down the jar file.

00:31:23.340 --> 00:31:24.590
So it's important to have two.

00:31:24.770 --> 00:31:27.180
Those two files make up the midlet.

00:31:27.260 --> 00:31:30.060
So if you are a midlet,
what's your life like?

00:31:30.100 --> 00:31:32.130
Well, it's real simple.

00:31:34.340 --> 00:31:38.780
If a user launches your application,
the first thing that happens is that

00:31:38.800 --> 00:31:42.210
your midlet main class is instantiated.

00:31:42.250 --> 00:31:47.100
At some point thereafter,
you get a call to start app.

00:31:47.150 --> 00:31:51.210
At that point you have control
of the screen and the input

00:31:51.210 --> 00:31:53.470
and you can do what you will.

00:31:53.570 --> 00:31:56.760
At that point, two things can happen.

00:31:56.850 --> 00:32:00.720
The first of which,
the user can put you in the background.

00:32:00.720 --> 00:32:04.200
This happens if they have multitasking
on their device or if they receive

00:32:04.200 --> 00:32:05.820
access and resources as possible.

00:32:05.820 --> 00:32:07.760
You can go into hibernation.

00:32:07.760 --> 00:32:11.120
You're still running but you should
be hibernating until the point

00:32:11.120 --> 00:32:12.760
when the user brings you back.

00:32:12.760 --> 00:32:16.320
You'll get notified because
start app is called again.

00:32:16.320 --> 00:32:19.600
Then again, you're at the forefront.

00:32:19.600 --> 00:32:22.630
When you're active or when you're paused,
the user can do that second thing,

00:32:22.630 --> 00:32:24.020
which is kill your app.

00:32:24.040 --> 00:32:28.120
In either of those cases,
be ready for a destroy app call.

00:32:28.150 --> 00:32:30.680
At that point, you should clean up and
dispose all resources.

00:32:30.700 --> 00:32:33.100
Then exit.

00:32:33.100 --> 00:32:34.720
That's the whole midlet lifecycle.

00:32:34.720 --> 00:32:36.100
Very simple.

00:32:36.100 --> 00:32:36.500
Very easy.

00:32:38.120 --> 00:32:41.180
So, can we build it?

00:32:41.450 --> 00:32:43.740
Yes, we can.

00:32:43.880 --> 00:32:48.270
Let's talk a little bit about how
to actually build these things.

00:32:49.000 --> 00:32:51.970
So you'll build it just like
you do any other project,

00:32:52.020 --> 00:32:56.800
and you'll have a series of class files.

00:32:56.800 --> 00:32:56.800
After that point,

00:32:58.070 --> 00:33:00.640
you'll need to pre-verify
those class files.

00:33:00.650 --> 00:33:02.610
What is pre-verification?

00:33:02.690 --> 00:33:06.670
In the KVM world,
there's not enough resource space

00:33:06.900 --> 00:33:09.530
to include a full bytecode verifier.

00:33:09.670 --> 00:33:13.780
So there's some pre-processing done to
your class files to make them easier

00:33:13.780 --> 00:33:17.550
to digest by KVM's bytecode checker.

00:33:17.620 --> 00:33:19.780
So that's what this step is.

00:33:20.060 --> 00:33:23.590
Pre-verify is actually a
C program that it's available.

00:33:23.600 --> 00:33:26.320
We ported it to Mac OS X,
and it's available as part of

00:33:26.420 --> 00:33:28.100
our software developer kit.

00:33:28.130 --> 00:33:30.380
And it just annotates your class files.

00:33:30.390 --> 00:33:33.660
And it's a simple
process and transparent.

00:33:33.660 --> 00:33:37.880
And once that's done,
once you pre-verify,

00:33:37.890 --> 00:33:40.740
then that's required,
'cause if you don't pre-verify,

00:33:40.750 --> 00:33:43.310
the app won't run on the phone, period.

00:33:43.740 --> 00:33:45.740
The next step is optional,
but it's recommended.

00:33:45.740 --> 00:33:47.050
Obfuscation.

00:33:47.060 --> 00:33:51.460
A lot of people use obfuscation to kind
of hide their intellectual property,

00:33:51.460 --> 00:33:53.950
make it hard to reverse
engineer their stuff.

00:33:53.960 --> 00:33:57.680
But in the mobile space,
obfuscation has an unintended

00:33:57.680 --> 00:34:01.800
and useful side effect in that
when you obfuscate something,

00:34:01.800 --> 00:34:05.070
typically all the class names turn into,
like, letters, like A, B, one character,

00:34:05.070 --> 00:34:06.860
like, you know,
method names and class names.

00:34:06.860 --> 00:34:11.040
Well, it turns out the longer your
method name or class name,

00:34:11.040 --> 00:34:12.080
that stuff takes up space.

00:34:12.240 --> 00:34:14.780
So when you obfuscate something,
it shrinks the size of the

00:34:14.780 --> 00:34:17.960
jar down significantly,
and that's useful for getting under that,

00:34:17.960 --> 00:34:20.840
like,
64K limit on a Nokia Series 40 device.

00:34:20.840 --> 00:34:22.440
So that's a useful step.

00:34:22.520 --> 00:34:26.500
There are free and payware
applications that do obfuscation.

00:34:26.500 --> 00:34:30.280
I use ProGuard myself,
but there are any number of ones.

00:34:30.280 --> 00:34:32.780
You probably are using one already,
so it's just standard.

00:34:32.780 --> 00:34:35.930
Any obfuscator will work for J2ME.

00:34:37.770 --> 00:34:40.940
So after you do those two steps,
then you need to update your JAD file.

00:34:40.960 --> 00:34:46.470
I mentioned before the JAD file has to
have the length of the jar file in there.

00:34:46.570 --> 00:34:49.380
Well, after obfuscation,
your jar size is going to change.

00:34:49.470 --> 00:34:52.910
And so you need to update your
JAD file to stay in sync with that.

00:34:52.960 --> 00:34:56.640
So after you're done with that,
you're ready to run.

00:34:56.970 --> 00:35:02.080
and you can run with our software,
Empower Player.

00:35:02.620 --> 00:35:07.440
What it is, as I mentioned before,
is an implementation of MIDP 2.0,

00:35:07.450 --> 00:35:11.070
including mobile media API,
mobile 2D graphics, mobile 3D graphics,

00:35:11.190 --> 00:35:14.530
Bluetooth support, on top of J2SE.

00:35:14.640 --> 00:35:15.440
So it just runs.

00:35:15.440 --> 00:35:17.140
It's an application.

00:35:17.220 --> 00:35:19.010
Let me tell you what it's not.

00:35:19.100 --> 00:35:21.370
It is not Sun's Wireless Toolkit.

00:35:21.400 --> 00:35:24.030
Sun's Wireless Toolkit has
a number of interesting

00:35:24.030 --> 00:35:28.870
capabilities like packet sniffing,
memory profiling, speed throttling,

00:35:28.950 --> 00:35:31.860
and we don't do any of that stuff.

00:35:31.940 --> 00:35:33.160
And we're not an IDE either.

00:35:33.190 --> 00:35:34.870
We don't compile your code.

00:35:34.900 --> 00:35:38.290
We don't require you to edit
your code in our player.

00:35:38.300 --> 00:35:41.480
We just do one thing,
and we'd like to think we do it well.

00:35:41.480 --> 00:35:44.390
So we integrate with
your existing toolchain.

00:35:44.740 --> 00:35:47.460
and that's what we like to do.

00:35:47.460 --> 00:35:48.450
It's a free download.

00:35:48.450 --> 00:35:51.900
We make it available because
we want you guys to use it.

00:35:51.900 --> 00:35:54.700
To the extent that your applications
are compatible with our emulator,

00:35:54.700 --> 00:35:55.460
it only helps us.

00:35:55.500 --> 00:35:58.540
We think we help you,
so it's a nice relationship.

00:35:58.590 --> 00:36:07.170
I'm also pleased to announce that a
number of development environments have

00:36:07.220 --> 00:36:12.860
people been integrating our support into,
like things like Eclipse, IntelliJ IDEA,

00:36:12.970 --> 00:36:18.000
but the Sun's NetBeans team has actually
integrated EmpowerPlayer with NetBeans.

00:36:18.030 --> 00:36:23.250
And so now they are,
we've agreed that they can

00:36:23.250 --> 00:36:27.400
distribute EmpowerPlayer with
their mobility pack for Macintosh,

00:36:27.460 --> 00:36:30.330
so that there will be a NetBeans
mobility pack for Macintosh,

00:36:30.330 --> 00:36:31.910
which heretofore has not existed.

00:36:32.090 --> 00:36:36.530
So that's a good thing
for the Mac platform.

00:36:36.680 --> 00:36:42.040
But that's what we are,
and I think from this point on,

00:36:42.090 --> 00:36:46.650
Ted will take over and we'll
show you how it's done.

00:36:54.300 --> 00:36:58.550
So, we're going to get down
to the nuts and bolts,

00:36:58.640 --> 00:37:03.540
but actually let's go back
to the slides real quick.

00:37:04.480 --> 00:37:06.430
Some of the things we're
going to talk about.

00:37:06.520 --> 00:37:12.390
We're going to talk about
building and debugging with Xcode,

00:37:12.390 --> 00:37:12.390
but like I said in

00:37:12.720 --> 00:37:17.580
In the previous session on Java,
you can use whatever tools that you like,

00:37:17.620 --> 00:37:22.290
but for this session we're
going to show with Xcode.

00:37:24.420 --> 00:37:27.690
To do it in Xcode,
you have to set up a custom executable

00:37:27.700 --> 00:37:31.410
that will launch the emulator,
pass in the JAD or JAR file and stuff.

00:37:31.440 --> 00:37:36.900
There's actually a template that's
provided in Michael's SDK written

00:37:36.900 --> 00:37:44.430
by another gentleman out there that
I'll have to introduce at some point.

00:37:45.840 --> 00:37:50.520
You debug it like normal
with the Java debugger.

00:37:50.520 --> 00:37:52.170
You don't have to use
any special debugger.

00:37:52.180 --> 00:37:54.990
You can actually debug it
within the emulator using the

00:37:55.000 --> 00:37:56.580
Java debugger within Xcode.

00:37:56.710 --> 00:38:01.150
Just set your breakpoints
just like normal.

00:38:01.490 --> 00:38:05.820
Conversely, it also works with Shark.

00:38:05.850 --> 00:38:10.180
It's a little bit harder to profile in
Shark than with a normal Java application

00:38:10.180 --> 00:38:15.260
because in addition to your midlet,
you also have the emulator and

00:38:15.260 --> 00:38:17.790
then our entire JDK running.

00:38:17.970 --> 00:38:19.400
But it is possible with Shark.

00:38:19.400 --> 00:38:24.800
What you can do is use the data mining
features and exclude the Java AWT,

00:38:24.800 --> 00:38:30.320
the Java X swing classes,
etc., etc., until you get down

00:38:30.380 --> 00:38:33.800
to the MIDP APIs and your APIs.

00:38:33.800 --> 00:38:37.590
You'll see a couple of unknown
classes in there and stuff like that,

00:38:37.640 --> 00:38:41.440
and really what that's saying is,
"I tried to exclude these,

00:38:41.440 --> 00:38:47.800
but they've actually been
called." But now when you're...

00:38:48.030 --> 00:38:50.420
Profiling in the emulator.

00:38:51.030 --> 00:38:54.880
This is not a MIDP device itself.

00:38:54.970 --> 00:39:01.490
There are realities that
Michael talked about.

00:39:02.060 --> 00:39:04.860
Some things may be faster on
the emulator or actually may

00:39:04.860 --> 00:39:06.440
be slower on the emulator.

00:39:06.440 --> 00:39:09.520
But if you run into a
performance issue on your phones,

00:39:09.530 --> 00:39:13.050
running it through the emulator
has a good chance of helping you

00:39:13.050 --> 00:39:14.960
figure out exactly what it is.

00:39:14.960 --> 00:39:18.200
And then additionally,
let me point out the last point,

00:39:18.200 --> 00:39:20.460
is that packages really help.

00:39:20.460 --> 00:39:23.960
In the beginning of MIDP development,
people actually got rid of packages,

00:39:23.960 --> 00:39:26.560
again,
because that extra namespace actually

00:39:26.560 --> 00:39:28.800
took up space in your jar and stuff.

00:39:28.840 --> 00:39:32.390
Now it's not such a big deal,
but if you have a midlet that

00:39:32.390 --> 00:39:35.350
doesn't have any packages,
it's a little harder to

00:39:35.350 --> 00:39:36.390
target them in Shark.

00:39:36.440 --> 00:39:39.200
So go ahead, add some packages,
do your profiling,

00:39:39.200 --> 00:39:42.120
and then if you want to get rid of them,
pull them out.

00:39:43.030 --> 00:39:46.480
Deploying to the device,
there's two ways.

00:39:46.480 --> 00:39:49.300
There's the Bluetooth,
which is what I use for

00:39:49.310 --> 00:39:52.740
doing my development,
and then there's also the HTTP,

00:39:52.740 --> 00:39:55.710
which is commonly referred
to as over-the-air.

00:39:55.910 --> 00:39:57.890
It's closer to the real world.

00:39:57.980 --> 00:40:03.310
With the Bluetooth, all you have to do is
you push over the jar.

00:40:03.310 --> 00:40:03.310
It

00:40:04.090 --> 00:40:06.660
You don't need to update
your JAD file for it,

00:40:06.660 --> 00:40:10.910
and actually, in a lot of cases,
you can't take advantage of the

00:40:10.910 --> 00:40:13.920
JAD features when you're doing
it with the Bluetooth deployment.

00:40:14.100 --> 00:40:18.870
But for most debugging and
testing and stuff like that,

00:40:18.870 --> 00:40:20.890
that is very useful.

00:40:22.050 --> 00:40:24.640
On Mac OS X,
there's a way that you can just

00:40:24.640 --> 00:40:27.780
send a file to a Bluetooth device,
and actually most

00:40:27.870 --> 00:40:30.870
MIDP phones will actually go,
"Oh, wait a minute.

00:40:31.040 --> 00:40:32.340
This is a JAR file.

00:40:32.420 --> 00:40:36.440
Let's see if we can install it and
run it," and you're up and running.

00:40:36.440 --> 00:40:39.000
It's actually very simple.

00:40:39.000 --> 00:40:44.590
With HTTP,
your phone is behind a firewall,

00:40:44.590 --> 00:40:49.740
and it needs to use
DNS to get to your server.

00:40:49.740 --> 00:40:54.310
You need some sort of static
IP address or at least a DNS server.

00:40:54.400 --> 00:40:57.740
addressable address.

00:40:58.220 --> 00:41:02.080
And up on Sun's website,
it actually details what you need to

00:41:02.080 --> 00:41:06.310
change to make it work with Apache,
which of course is a first

00:41:06.310 --> 00:41:08.600
class citizen in Mac OS X.

00:41:09.610 --> 00:41:12.990
So, configuring Apache,
it's actually very simple.

00:41:13.140 --> 00:41:18.630
On Mac OS X, and actually this is
documented on Sun's website,

00:41:18.630 --> 00:41:22.250
except for the Mac OS X part,
which is just where

00:41:22.250 --> 00:41:23.490
the MIME types file is.

00:41:23.490 --> 00:41:26.500
You have to add two
MIME types to the file,

00:41:26.500 --> 00:41:28.420
and you don't have to worry
about writing these down.

00:41:28.420 --> 00:41:31.490
You go to Sun's website,
and it tells you exactly what MIME types

00:41:31.490 --> 00:41:33.460
you need to add to the MIME type file.

00:41:33.460 --> 00:41:39.370
But the file on Mac OS X is
in the etc.httpd folder.

00:41:39.500 --> 00:41:41.690
And it's just called MIME.types.

00:41:41.690 --> 00:41:44.020
There's actually a backup
of the original in there,

00:41:44.020 --> 00:41:47.720
which was useful for me when
I accidentally deleted half of it.

00:41:47.720 --> 00:41:52.070
So, if you make a change in stuff,
and for some reason

00:41:52.070 --> 00:41:55.880
something doesn't work,
you can go back and restore it.

00:41:55.880 --> 00:42:00.010
So, we're going to get into kind
of our hands-on portion.

00:42:00.100 --> 00:42:06.680
We're going to build a game
that's included in the MIDP SDK.

00:42:06.680 --> 00:42:09.300
It uses MIDP 2.0, the game API.

00:42:09.340 --> 00:42:13.270
And then we're going to run
it in the emulator and stuff.

00:42:13.380 --> 00:42:17.430
Put a couple breakpoints,
see that you can actually do that.

00:42:17.970 --> 00:42:21.880
Shark the MIDLIT,
and then deploy it via Bluetooth.

00:42:21.920 --> 00:42:26.200
Now, I'm not actually trying to
teach you the MIDP APIs.

00:42:26.470 --> 00:42:29.010
Michael's actually more
the expert on that one.

00:42:29.220 --> 00:42:33.320
But what we're trying to show you is
how to do your development on Mac OS X.

00:42:33.340 --> 00:42:38.330
So, with that,
let's go over to our demo two.

00:42:39.950 --> 00:42:46.140
And so there's one thing that you have
to do before you actually can do this.

00:42:46.210 --> 00:42:48.280
Let's go to the terminal.

00:42:49.230 --> 00:42:53.510
Because of the way the
SDK is distributed,

00:42:53.510 --> 00:43:00.020
you're actually going to have
to chmod the pre-verified tool.

00:43:00.060 --> 00:43:04.340
If you follow the instructions and
you install it where it said it

00:43:04.340 --> 00:43:08.200
should say to install it in developer,
Java, MMP SDK.

00:43:08.320 --> 00:43:12.270
And so let's just go
into the OS X pre-verify.

00:43:12.320 --> 00:43:19.780
And so it would just be a chmod +x,
and then just drag over.

00:43:20.740 --> 00:43:23.870
And that sets it up so that you
can actually execute it from your

00:43:23.890 --> 00:43:26.670
AMP build scripts and stuff like that.

00:43:27.280 --> 00:43:32.200
So, we're in the SDK, developer, Java,
MMP SDK.

00:43:32.200 --> 00:43:40.800
Let's go back into the
OS X folder and the Xcode.

00:43:41.020 --> 00:43:42.640
There's a couple samples in there.

00:43:42.640 --> 00:43:45.370
Let's open up the Microtank one.

00:43:46.510 --> 00:43:51.400
So let's just open it up and with Xcode,
give it a second.

00:43:51.400 --> 00:44:02.540
This is a pretty simple sample,
but it shows game APIs and such.

00:44:02.560 --> 00:44:09.210
If you look at, let's see,
microtank.java, you'll see the APIs that

00:44:09.210 --> 00:44:12.800
Mike talked about,
the start app, pause app, destroy app,

00:44:12.810 --> 00:44:13.920
and command connection.

00:44:13.920 --> 00:44:15.640
The command connection
is where you get like,

00:44:15.670 --> 00:44:19.240
keyboard pointer events
and stuff like that.

00:44:19.240 --> 00:44:22.160
Let's just go ahead and
actually do a build.

00:44:22.180 --> 00:44:24.660
This is an ant build process.

00:44:24.660 --> 00:44:28.090
The nice thing about that is
that ant actually integrates

00:44:28.120 --> 00:44:31.320
pretty well with Mac OS X,
and then we're using a custom

00:44:31.320 --> 00:44:33.820
executable to launch it.

00:44:34.930 --> 00:44:48.650
and Michael Powers,
the founder of the J2ME JVM team,

00:44:48.650 --> 00:44:48.650
will be presenting the demo on the

00:44:49.370 --> 00:44:54.860
Let me go in and add a
couple packages to this.

00:44:54.860 --> 00:44:54.860
And so for this one,

00:44:55.200 --> 00:45:02.500
[Transcript missing]

00:45:04.930 --> 00:45:09.900
This doesn't have to be very deep,
just something.

00:45:09.900 --> 00:45:13.090
Let me add that to the
next one real quick.

00:45:15.090 --> 00:45:17.930
Copy and paste is my friend.

00:45:17.950 --> 00:45:18.990
And the last one.

00:45:19.140 --> 00:45:22.550
So this puts them all
in the same directory.

00:45:23.340 --> 00:45:25.900
I'm going to do a clean build
real quick just to make sure

00:45:25.900 --> 00:45:27.900
everything gets cleaned up.

00:45:27.920 --> 00:45:30.900
And then let's go ahead
and do another build.

00:45:30.920 --> 00:45:33.460
Now, there's one thing that
actually I need to update.

00:45:33.500 --> 00:45:37.620
Since I moved it into
the micro tank package,

00:45:37.640 --> 00:45:40.890
we also have to go in
and update the manifest.

00:45:43.700 --> 00:45:47.410
This top line,
it gives the name of the midlet.

00:45:47.540 --> 00:45:51.080
This is in the manifest.

00:45:51.930 --> 00:45:55.100
The icon for the midlet,
so like when you look on

00:45:55.100 --> 00:45:57.910
your phone for the game,
that's what the icon is

00:45:57.910 --> 00:45:59.640
that would be displayed.

00:45:59.640 --> 00:46:02.710
And then the actual main midlet class.

00:46:02.790 --> 00:46:10.420
And then you can see that some of
this is actually repeated down here,

00:46:10.420 --> 00:46:10.420
and then what platforms
you actually target.

00:46:11.070 --> 00:46:16.500
In theory,
I should be doing the same thing with

00:46:19.200 --> 00:46:25.400
[Transcript missing]

00:46:26.470 --> 00:46:29.980
What you can do is just go
ahead and open it up and,

00:46:29.980 --> 00:46:33.820
all right, let's just launch TextEdit.

00:46:35.300 --> 00:46:36.930
Let's open up that JAD file.

00:46:37.030 --> 00:46:39.050
Now,
this JAD file is the same kind of thing.

00:46:39.070 --> 00:46:43.420
It's just a text file.

00:46:43.980 --> 00:46:46.780
So now I can go ahead
and run the same game,

00:46:46.800 --> 00:46:49.720
and it should, within theory,

00:46:50.410 --> 00:46:53.570
If I made all the correct changes,
all right, we got the same thing.

00:46:53.720 --> 00:46:56.650
So all we've done is put it in a package.

00:46:56.750 --> 00:47:03.800
What we need to do now to shark
it is just standard Java stuff.

00:47:03.910 --> 00:47:05.860
I should have cleaned
that up before the demo.

00:47:05.920 --> 00:47:11.680
So, all you have to do is
just add the X run shark.

00:47:11.680 --> 00:47:14.170
And this is just standard
for all Java applications.

00:47:14.200 --> 00:47:15.440
This is just a VM parameter.

00:47:15.440 --> 00:47:20.920
It causes the JNI library
shark to be loaded up.

00:47:21.000 --> 00:47:26.880
and the rest of the team will be joined
by the team members of the J2ME JVM team.

00:47:28.610 --> 00:47:32.000
And you actually kind of saw this before.

00:47:32.040 --> 00:47:33.890
Shark for Java is enabled.

00:47:34.000 --> 00:47:38.960
So let me go into our
developer applications.

00:47:41.700 --> 00:47:48.700
Performance Tools,
and let's go ahead and run Shark.

00:47:48.700 --> 00:47:48.700
Now,
one of the things I figured out is that

00:47:49.660 --> 00:47:52.300
The way that Michael wrote this,
it actually runs pretty

00:47:52.300 --> 00:47:53.400
well in the emulator.

00:47:53.520 --> 00:47:57.500
So I'm going to have to go in and
actually dumb it down a little bit.

00:47:57.660 --> 00:48:03.770
Let me just go into this
MicroTake canvas and let's force

00:48:03.770 --> 00:48:07.730
a GC in the middle of the paint.

00:48:07.730 --> 00:48:07.730
Dun dun dun dun.

00:48:17.400 --> 00:48:33.100
[Transcript missing]

00:48:35.290 --> 00:48:36.500
So let's go ahead and run it.

00:48:36.500 --> 00:48:40.950
I'm going to use a Java time trace.

00:48:41.200 --> 00:48:44.200
Shark actually goes, "Hey, you know,
we've got a Java process out there

00:48:44.200 --> 00:48:49.090
that's all set up to be sharked."
You can drive it around a little bit,

00:48:49.090 --> 00:48:51.760
use the option Escape to
start shark sampling.

00:48:51.760 --> 00:48:55.440
And you'll notice that the frame
rates that we're getting on the

00:48:55.540 --> 00:48:58.840
bottom are a little bit less
than what we originally had.

00:48:58.840 --> 00:49:02.680
And so, see,
I can't drive through walls either.

00:49:03.390 --> 00:49:06.810
So let's go ahead and look
at that data real quick.

00:49:07.700 --> 00:49:09.930
So, like I said,
you get all these things called

00:49:09.930 --> 00:49:11.880
like Java AWT and stuff like that.

00:49:11.880 --> 00:49:14.370
Let's charge Java AWT to the callers.

00:49:14.460 --> 00:49:15.940
That should get rid of a lot of stuff.

00:49:16.040 --> 00:49:18.510
Java AWT event, same thing.

00:49:18.660 --> 00:49:20.780
Java X swing.

00:49:21.080 --> 00:49:25.940
and then, let's see, Apple AWT.

00:49:25.970 --> 00:49:31.100
So I'm getting rid of all the stuff
that isn't really MIDP specific.

00:49:31.110 --> 00:49:37.280
So what we're essentially doing
is pulling out the J2SE stuff

00:49:37.340 --> 00:49:39.620
that's running in the background.

00:49:41.550 --> 00:49:47.640
So unfortunately, at this point in time,
that is not--

00:49:50.040 --> 00:49:52.770
It's not saveable,
but I've been talking to the

00:49:52.770 --> 00:49:55.000
Shark people and they think
that would be a great feature.

00:49:55.000 --> 00:49:58.330
And then I can also charge
that to the callers,

00:49:58.330 --> 00:50:00.000
and there's one more in there.

00:50:00.000 --> 00:50:02.810
Oh, okay.

00:50:02.810 --> 00:50:06.190
I think I can do that in Shark.

00:50:07.710 --> 00:50:17.190
Beauty in Mac OS X.

00:50:17.190 --> 00:50:17.190
Was that a little better?

00:50:17.190 --> 00:50:17.190
Cool, thank you.

00:50:17.600 --> 00:50:20.350
So we're getting rid of
all the stuff in here.

00:50:20.360 --> 00:50:25.350
And so, okay, so now we got the adapter.

00:50:25.360 --> 00:50:27.580
Let me see if I get rid of that.

00:50:27.580 --> 00:50:29.430
I should have...

00:50:34.100 --> 00:50:37.540
I didn't get rid of my actual classes.

00:50:37.550 --> 00:50:41.600
So, where are we here?

00:50:41.620 --> 00:50:44.860
So we got SunReflect.

00:50:44.880 --> 00:50:47.100
We got our Microtank classes in here.

00:50:47.190 --> 00:50:51.760
We're taking 84% in this render,
or 34% in this render.

00:50:51.760 --> 00:50:56.270
And a lot of that is the
system GC pulling up.

00:50:56.340 --> 00:50:59.520
We're still,
there's still some stuff that we

00:50:59.520 --> 00:51:03.780
need to do to make Shark an ideal
candidate for MIDP emulation,

00:51:03.780 --> 00:51:04.690
or profiling.

00:51:04.690 --> 00:51:07.080
But as you can see,
there is some stuff that

00:51:07.080 --> 00:51:07.850
you can get out of it.

00:51:07.860 --> 00:51:12.150
And if you're seeing a performance issue,
go ahead and run it through Shark.

00:51:12.150 --> 00:51:13.500
Profile it.

00:51:13.560 --> 00:51:16.280
Try and figure out if Shark can
actually help you with it.

00:51:16.300 --> 00:51:20.780
And it might quite possibly point
out exactly where the issue is.

00:51:20.780 --> 00:51:25.810
And then if you dig deeper into it,
you could actually solve your issue.

00:51:29.210 --> 00:51:32.090
So, let me see.

00:51:32.140 --> 00:51:36.070
Let's look at a couple
of other SD things.

00:51:37.760 --> 00:51:44.610
If you all downloaded the
Sun Wireless Toolkit and installed the

00:51:45.000 --> 00:51:53.560
The Xcode project that was referenced
in our documentation for this site.

00:51:53.560 --> 00:51:57.520
In this apps directory,
the wireless toolkit apps directory,

00:51:57.540 --> 00:52:00.940
there's a bunch of different
demos and stuff like that.

00:52:01.080 --> 00:52:04.640
This UI demo is one we're
actually going to show.

00:52:04.640 --> 00:52:08.340
As you can see,
it doesn't really have -- there's no

00:52:08.340 --> 00:52:11.380
Xcode project or anything like that.

00:52:11.380 --> 00:52:13.990
So let's go ahead and launch Xcode.

00:52:14.800 --> 00:52:18.160
I'm supposed to be showing you guys.

00:52:18.160 --> 00:52:22.670
So, Developer, Applications, Xcode.

00:52:23.330 --> 00:52:28.390
And I've installed the template
that actually comes with the SDK.

00:52:28.400 --> 00:52:32.190
So let's go to New Project,
and it shows up here as

00:52:32.190 --> 00:52:34.710
this AMP-based midlet jar.

00:52:34.840 --> 00:52:38.300
Let's go ahead and the one that I'm
going to actually do is the UI demo.

00:52:38.300 --> 00:52:43.510
I'm actually picking the same name
as the sample itself because if

00:52:43.510 --> 00:52:48.230
you look in this bin directory,
their JAD, their classes,

00:52:48.240 --> 00:52:51.220
all that are based on that same name.

00:52:51.220 --> 00:52:55.210
So let me just go ahead and make
sure that I spell everything right.

00:52:56.490 --> 00:53:15.790
UI demo.

00:53:15.790 --> 00:53:15.790
So this creates a project.

00:53:15.790 --> 00:53:15.790
It's essentially a Hello World project,
but with the name that we want.

00:53:15.790 --> 00:53:15.790
Let's go ahead and open that up and
go ahead and quit Xcode at this point,

00:53:15.790 --> 00:53:15.790
and just drag all this stuff into there.

00:53:15.790 --> 00:53:15.790
And let's replace all.

00:53:16.730 --> 00:53:22.660
So the Xcode template has the
manifest and the JAD file atop folder.

00:53:22.660 --> 00:53:26.190
And so let's go ahead
and actually bring these.

00:53:26.700 --> 00:53:27.700
Let's see.

00:53:27.700 --> 00:53:28.400
Dun dun dun.

00:53:28.400 --> 00:53:30.800
Let me do it from this folder.

00:53:30.980 --> 00:53:33.410
Let's bring over their JAD file.

00:53:34.050 --> 00:53:39.620
and Michael Powers,
the founder of the J2ME JVM team,

00:53:39.620 --> 00:53:43.400
will be joining us for the session.

00:53:47.020 --> 00:53:51.630
Let's go ahead and get rid of
the old one and use the one that

00:53:51.630 --> 00:53:54.340
was included with some sample.

00:53:54.350 --> 00:54:00.010
So now we've essentially brought
the sample into the Xcode project.

00:54:00.140 --> 00:54:04.480
The cool thing about this is
because it's an AMP build,

00:54:04.480 --> 00:54:08.480
we don't have to add all
those source files to it.

00:54:08.590 --> 00:54:11.190
They automatically just
show up right here in Xcode.

00:54:11.190 --> 00:54:11.190
We have these folders
that are just basically

00:54:11.300 --> 00:54:30.800
[Transcript missing]

00:54:31.130 --> 00:54:31.930
I don't know.

00:54:31.940 --> 00:54:33.460
I'm going to pick any one of these.

00:54:33.460 --> 00:54:35.800
These are just UI demos,
so in all honesty,

00:54:35.800 --> 00:54:41.790
they're not 100% exciting,
but they do show the features.

00:54:41.820 --> 00:54:44.400
And it also, in the process,
what I've done is I've shown you

00:54:44.400 --> 00:54:48.130
how easy it is to take some samples,
and pretty much any sample out

00:54:48.210 --> 00:54:52.870
there or application on the web,
and bring it into Xcode and the emulator,

00:54:52.930 --> 00:54:56.700
and actually start being able to run,
debug, and stuff like that.

00:54:56.820 --> 00:55:00.920
So if I was to go ahead and, say, put a

00:55:03.520 --> 00:55:04.940
Let's say a breakpoint right here.

00:55:05.000 --> 00:55:09.890
Let's go ahead and build in bug.

00:55:10.910 --> 00:55:15.170
We should actually,
and I think I have to bring up

00:55:15.170 --> 00:55:18.150
the alert demo portion of that,
is let's go in and...

00:55:23.450 --> 00:55:25.400
Let's see, start app.

00:55:25.400 --> 00:55:28.220
Well,
apparently I missed something in there.

00:55:28.220 --> 00:55:31.940
But it does work for
debugging in the midlet.

00:55:31.940 --> 00:55:42.340
So the next thing we actually want
to do is let's go ahead and take that

00:55:42.670 --> 00:55:43.360
JAD file that we built previously,
and that's in the developer.

00:55:43.730 --> 00:55:48.160
application or Java and Mid-PSDK.

00:55:48.180 --> 00:55:55.620
This is the OS 10 one and
this is the micro tank game.

00:55:55.620 --> 00:55:59.460
The end results are put in
the distribution directory.

00:55:59.460 --> 00:56:02.120
That's what the ANT template does.

00:56:02.120 --> 00:56:06.250
It puts your pre-verified jar
and a copy of the JAD file.

00:56:06.250 --> 00:56:08.820
It doesn't update the JAD file.

00:56:08.820 --> 00:56:10.680
You have to manually do that.

00:56:10.680 --> 00:56:14.800
In theory, you would do that after you
do your obfuscation because

00:56:14.800 --> 00:56:16.650
that would make it smaller.

00:56:16.740 --> 00:56:20.110
Let's take this jar file.

00:56:25.420 --> 00:56:27.890
I'll go ahead and launch,
open up my phone.

00:56:28.180 --> 00:56:35.560
I've actually already paired
my phone with the system.

00:56:35.560 --> 00:56:40.230
This is actually another sample,
just a Java sample that allows us to

00:56:40.230 --> 00:56:44.440
use the QuickTime sequence grabber
from within a Java application.

00:56:44.440 --> 00:56:48.430
And if I don't make you guys too sick.

00:56:50.200 --> 00:56:53.300
I probably should have slowed
down on the coffee this morning.

00:56:53.300 --> 00:56:55.200
Let me send a file.

00:56:55.250 --> 00:56:59.670
And what I'm going to do is send this
JAR file directly over to the phone.

00:57:05.700 --> 00:57:07.530
I'm going to get rid of a
couple of windows so you can

00:57:07.530 --> 00:57:09.700
see actually what's going on.

00:57:09.700 --> 00:57:14.590
I borrowed this phone from Colin.

00:57:14.590 --> 00:57:14.590
So,

00:57:15.700 --> 00:57:16.700
There you go.

00:57:16.700 --> 00:57:19.300
I love the autofocus on the eyesight.

00:57:19.320 --> 00:57:20.550
Receive this message.

00:57:20.580 --> 00:57:23.430
And so essentially it's saying
that something's coming in over

00:57:23.430 --> 00:57:26.450
Bluetooth from this device,
Excellent.

00:57:26.520 --> 00:57:29.620
That's the name I have for this computer.

00:57:29.620 --> 00:57:35.500
And I just said, "Yes,
go ahead." And it should be.

00:57:35.500 --> 00:57:38.930
Yep, it got the message.

00:57:38.930 --> 00:57:38.930
I'm going to show it.

00:57:41.800 --> 00:57:44.230
It's installing the application for me.

00:57:44.240 --> 00:57:46.770
Now you notice I pushed over the jar,
not the JAD file.

00:57:46.910 --> 00:57:49.790
Install Microtank, yep.

00:57:51.630 --> 00:57:52.600
Okay.

00:57:52.600 --> 00:57:54.590
Continue.

00:57:54.600 --> 00:57:55.940
Yeah, I haven't signed it or anything.

00:57:55.940 --> 00:57:57.580
It's not trusted.

00:57:57.600 --> 00:58:02.090
And in this case, I'll put this on the
memory card of this phone.

00:58:05.400 --> 00:58:07.460
So it's copying over the jar right now.

00:58:07.460 --> 00:58:15.190
It's doing its minimal security checks
to make sure that I actually did

00:58:17.200 --> 00:58:23.210
and Michael Powers,
and then the rest of the team.

00:58:24.130 --> 00:58:34.250
and Michael Powers,
and then developing the latest and most

00:58:34.330 --> 00:58:41.590
advanced applications for J2ME JVMs.

00:58:41.590 --> 00:58:41.590
Ted Jucevic, Michael Powers,
and then deploying them

00:58:41.590 --> 00:58:41.590
to embedded J2ME JVMs.

00:58:41.590 --> 00:58:41.590
Ted Jucevic, Michael Powers,
and then deploying them

00:58:41.590 --> 00:58:41.590
to embedded J2ME JVMs.

00:58:45.100 --> 00:58:48.130
Xcode.

00:58:48.170 --> 00:58:50.790
Michael actually pointed this out to me.

00:58:51.100 --> 00:58:55.680
"Recent projects, micro tank.

00:58:55.690 --> 00:58:57.320
I'm going to run it in the emulator.

00:58:57.320 --> 00:59:01.240
So each device, like you said,
has its own screen size.

00:59:01.450 --> 00:59:05.580
But each device tries to adapt them.

00:59:05.650 --> 00:59:10.190
Look there,
that millisecond frame rate and stuff.

00:59:10.480 --> 00:59:12.110
The main reason why I'm talking
about the J2ME JVMs is because

00:59:12.110 --> 00:59:15.760
it's a little bit different
place than it is on the emulator.

00:59:15.770 --> 00:59:21.020
That's because each phone is
trying to adjust the size and

00:59:21.020 --> 00:59:21.020
move things around for you.

00:59:22.440 --> 00:59:25.980
So, you know,
even though you do your own layout,

00:59:26.000 --> 00:59:28.150
just like with layout
managers in pure Java,

00:59:28.150 --> 00:59:32.480
you know, things may get moved around
slightly from what you expect.

00:59:32.560 --> 00:59:34.580
So that's pretty much it.

00:59:34.580 --> 00:59:38.080
We had hoped to actually show
you some over-the-air deployment,

00:59:38.170 --> 00:59:42.240
but it turns out in these inner rooms,
cell phones don't

00:59:42.240 --> 00:59:45.950
actually have much access,
as I'm sure you've all discovered.

00:59:46.180 --> 00:59:51.300
So, at this point,
that's essentially what

00:59:51.460 --> 00:59:54.070
we have to show you.

00:59:54.070 --> 00:59:54.070
Do you guys have any questions?

01:00:04.200 --> 01:00:08.200
There's a normal sample code and
resource directory that you guys

01:00:08.200 --> 01:00:13.240
have been seeing all over this thing.

01:00:13.240 --> 01:00:15.440
And I thought I had
some reference slides.

01:00:15.450 --> 01:00:16.200
Looks like that's it.
WEBVTT

00:00:10.590 --> 00:00:13.770
Hello and welcome to the hands-on
session about performance and

00:00:13.780 --> 00:00:16.100
graphics tuning your Java application.

00:00:16.160 --> 00:00:18.110
So before we begin,
I just want to remind you that

00:00:18.260 --> 00:00:22.880
there is a WWDC survey form
that you can go and fill out,

00:00:22.880 --> 00:00:24.590
and we want your feedback.

00:00:24.700 --> 00:00:28.920
So having said that, let's talk about the
purpose of this session.

00:00:29.110 --> 00:00:30.990
And it's very simple.

00:00:31.100 --> 00:00:32.900
The title says it all.

00:00:32.960 --> 00:00:36.900
We're here to make your
Java apps run faster on Mac OS X.

00:00:36.950 --> 00:00:39.060
So how do you do that?

00:00:39.330 --> 00:00:41.290
Basically,
there are many ways and techniques

00:00:41.300 --> 00:00:43.300
to optimize your application.

00:00:43.320 --> 00:00:45.900
But today we're going
to focus on two areas.

00:00:45.900 --> 00:00:50.200
The first one is going to be we're going
to focus on graphics performance tips.

00:00:50.200 --> 00:00:52.400
And the second area
we're going to focus on,

00:00:52.430 --> 00:00:56.240
we're going to talk about some free
tools that come on the Mac OS X platform

00:00:57.040 --> 00:01:02.080
that you guys can use to profile
and optimize your Java application.

00:01:02.380 --> 00:01:06.500
So if we do our job well today,
you're all going to walk out of

00:01:06.500 --> 00:01:09.580
this session and either during
the break or when you get home or

00:01:09.620 --> 00:01:13.300
when you get to your hotel room,
you're going to spend 15 minutes,

00:01:13.300 --> 00:01:17.240
and within 15 minutes you should be
able to get a clear idea of where the

00:01:17.260 --> 00:01:20.300
bottleneck is in your application.

00:01:20.300 --> 00:01:22.300
And hopefully optimize
it and make it better.

00:01:22.300 --> 00:01:25.220
So we're going to talk about some
tools that will let you do that.

00:01:25.300 --> 00:01:29.300
So let me give you a brief
outline of the session.

00:01:29.300 --> 00:01:32.300
First of all, we're going to talk about
graphics do's and don'ts.

00:01:32.300 --> 00:01:37.980
What that means is that there are
certain APIs in graphics Java APIs or

00:01:38.080 --> 00:01:44.480
Java 2D APIs that if you call the wrong
API as opposed to the right one or the

00:01:44.630 --> 00:01:47.790
right API as opposed to the wrong one,
you're actually going to get an order of

00:01:47.900 --> 00:01:50.680
magnitude speed improvements or decrease.

00:01:50.790 --> 00:01:54.370
So we're going to talk about some of
those areas and what you should keep in

00:01:54.370 --> 00:01:57.700
mind when you write your graphics code.

00:01:57.920 --> 00:02:00.700
Second,
we're going to talk about Quartz debug.

00:02:00.800 --> 00:02:03.170
Many of you might know that,
but if you don't know it,

00:02:03.260 --> 00:02:08.580
it's a very simple tool that you can use
to quickly optimize your Java repaints.

00:02:08.600 --> 00:02:12.100
So you can profile them and
you'll see what areas are

00:02:12.100 --> 00:02:13.600
you painting unnecessarily.

00:02:13.710 --> 00:02:15.600
So we're going to talk
about Quartz debug.

00:02:15.760 --> 00:02:19.600
And third and last, but not the least,
we're going to talk about Shark.

00:02:19.600 --> 00:02:22.600
And Shark is a very cool profiling tool.

00:02:22.600 --> 00:02:25.590
If you haven't used it,
I'm sure you'll love it.

00:02:25.600 --> 00:02:28.600
So last year we had support for Java.

00:02:28.600 --> 00:02:31.830
And we're going to give you a couple
of demos about Shark and how to use

00:02:31.960 --> 00:02:34.600
Shark to profile your Java application.

00:02:34.770 --> 00:02:37.110
So without any further ado,
I'd like to Gerard and come

00:02:37.110 --> 00:02:39.490
to talk to you about graphics.

00:02:41.630 --> 00:02:44.600
Thank you, Kurt.

00:02:44.620 --> 00:02:45.440
Hello, everybody.

00:02:45.440 --> 00:02:46.680
My name is Gerard Ziemski.

00:02:46.680 --> 00:02:48.480
I'm an engineer at Java Classes.

00:02:48.480 --> 00:02:53.050
And today, I'm going to talk to you about
graphics do's and don'ts.

00:02:53.860 --> 00:02:59.490
So for those of you who are new to
developing Java applications on Mac OS X,

00:02:59.490 --> 00:03:04.650
first you need to realize that
the graphics implementation on

00:03:04.650 --> 00:03:07.720
Mac OS X is done on top of Quartz.

00:03:07.950 --> 00:03:13.020
Quartz is the marketing name
for Core Graphics framework.

00:03:13.020 --> 00:03:18.630
So that implies several things
and among them the most important

00:03:18.630 --> 00:03:25.470
is that certain operations,
certain APIs as provided by Java 2D map

00:03:25.930 --> 00:03:28.320
one to one to what Quartz supports.

00:03:28.320 --> 00:03:32.820
And there are some APIs that there
is no direct mapping to Quartz

00:03:33.010 --> 00:03:39.800
and that involves more operations
and that means certain APIs may be

00:03:39.800 --> 00:03:43.390
slower or work slightly different.

00:03:43.840 --> 00:03:51.100
So here I'm going to tell you all
bit about those APIs and point out

00:03:51.100 --> 00:03:54.910
specifically those that you should
try and avoid while developing your

00:03:54.920 --> 00:03:57.970
Java applications for Mac OS X.

00:03:58.190 --> 00:04:05.090
You have to realize that the performance
characteristics of your application

00:04:05.130 --> 00:04:10.500
will differ from the ones you run
on one platform and then you take

00:04:10.500 --> 00:04:12.360
it and run it on another platform.

00:04:12.490 --> 00:04:14.340
This is a two-way street.

00:04:14.410 --> 00:04:21.390
Certain applications may work better on
Mac OS X than on Windows and vice versa.

00:04:23.600 --> 00:04:26.900
So we'll be talking here
about three main things.

00:04:27.080 --> 00:04:30.300
First of all,
we'll talk about buffered images.

00:04:30.380 --> 00:04:34.940
Then we'll talk about
painting from third threads.

00:04:35.040 --> 00:04:39.460
Third thread here is defined
as non-AWT event thread.

00:04:39.460 --> 00:04:42.890
And then I'll briefly talk about XR.

00:04:44.160 --> 00:04:47.860
So let's talk about buffered images.

00:04:48.090 --> 00:04:53.020
First and most important,
you guys have to realize that there

00:04:53.020 --> 00:04:59.820
is no way for you to predict what is
the best image format for you to use.

00:04:59.820 --> 00:05:03.030
Especially right now,
that we're also going to

00:05:03.030 --> 00:05:06.660
support the Intel platform x86.

00:05:06.660 --> 00:05:09.530
It's a little end-to-end
platform as opposed to PPC,

00:05:09.530 --> 00:05:11.240
which is big end-to-end.

00:05:11.250 --> 00:05:16.850
So you really cannot guess what
image format is the one to use.

00:05:16.880 --> 00:05:19.400
Don't hard code your
buffered image types.

00:05:19.400 --> 00:05:22.560
Always use Create Compatible Image.

00:05:23.220 --> 00:05:29.510
Second, you have to realize that because
we're depending on Quartz to

00:05:29.620 --> 00:05:33.780
provide us the functionality for
implementation of Java 2D graphics,

00:05:33.780 --> 00:05:38.610
there are certain things that
limit the way we can use it.

00:05:38.780 --> 00:05:43.720
For example, Quartz insists that the
images are immutable.

00:05:43.720 --> 00:05:48.700
If you look at the Java 2D specification,
a buffered image, you can draw into it,

00:05:48.700 --> 00:05:50.030
you can draw from it.

00:05:50.030 --> 00:05:52.540
Those images are mutable.

00:05:52.540 --> 00:05:56.540
So there is a mismatch
between Java and Quartz.

00:05:56.540 --> 00:05:58.940
What that means is,
if you think about it,

00:05:58.940 --> 00:06:02.910
is that we actually have to
keep two copies of the pixels.

00:06:02.920 --> 00:06:07.760
One copy is on the Java side,
the buffered image, data, raster,

00:06:07.760 --> 00:06:09.490
you know, all that.

00:06:09.490 --> 00:06:13.820
And then on native side,
we actually have to create

00:06:13.820 --> 00:06:18.980
a core graphics image rep,
and we have to copy those pixels

00:06:18.980 --> 00:06:21.880
into the native Quartz image
every time you want to use it.

00:06:21.880 --> 00:06:27.320
So, of course,
that means there's a penalty involved.

00:06:27.320 --> 00:06:32.260
We are trying to avoid that penalty,
and in most cases,

00:06:32.260 --> 00:06:32.260
if you follow the right way,
you will not hit that penalty.

00:06:32.260 --> 00:06:38.650
However, if you do things not quite
as we would like them,

00:06:38.650 --> 00:06:47.420
then you will actually hit that penalty,
and your application will suffer.

00:06:47.780 --> 00:06:53.590
So let's take the GetRGB method
that is defined on BufferedImage.

00:06:53.620 --> 00:06:58.890
What that means is if you call GetRGB,
you're asking for the image pixel value.

00:06:58.890 --> 00:07:03.910
You're on the Java side,
but that image actually

00:07:03.910 --> 00:07:06.930
exists as a native image,
as quartz image,

00:07:06.930 --> 00:07:10.440
and those pixels are actually
defined on the native side.

00:07:10.460 --> 00:07:15.300
So when you call GetRGB,
what has to happen is that we

00:07:15.300 --> 00:07:19.960
cannot really look at the Java side
and look at the pixels because it

00:07:19.960 --> 00:07:21.710
actually exists on the native side.

00:07:21.720 --> 00:07:23.200
So we have to cross the boundary.

00:07:23.200 --> 00:07:24.700
We have to go from Java to native.

00:07:24.700 --> 00:07:28.050
We have to look at the native pixel,
and then we have to

00:07:28.090 --> 00:07:29.700
return it back to Java.

00:07:29.700 --> 00:07:34.300
What's more complicated is
that really quartz doesn't

00:07:34.300 --> 00:07:36.940
want you to see those pixels.

00:07:36.940 --> 00:07:40.440
So there is a lot of work
involved in retrieving that.

00:07:40.460 --> 00:07:46.240
So there's cost associated with it,
but that cost is per call.

00:07:46.260 --> 00:07:53.080
So you call GetRGB, there's a cost,
you come back, and things are fine.

00:07:53.120 --> 00:07:56.990
So there's another one,
Raster GetDataBuffer.

00:07:56.990 --> 00:08:00.730
Now that has much,
much bigger implications from

00:08:00.940 --> 00:08:03.300
the performance point of view.

00:08:03.320 --> 00:08:07.380
What happens is if you
call Raster GetDataBuffer,

00:08:07.380 --> 00:08:10.420
you're requesting an data buffer.

00:08:10.470 --> 00:08:13.800
So you have direct access
to the pixels of the image.

00:08:13.800 --> 00:08:19.950
So from that point on,
we have to turn off our optimizations.

00:08:19.960 --> 00:08:23.860
And then from that point on,
whenever you draw a primitive,

00:08:23.860 --> 00:08:27.940
that primitive gets drawn into
the native side of the image.

00:08:27.940 --> 00:08:31.540
But since on the Java side,
you requested a direct

00:08:31.540 --> 00:08:35.340
access to the pixels,
so that means for every single

00:08:35.340 --> 00:08:38.470
primitive that you draw,
we have to sync pixels

00:08:38.470 --> 00:08:39.900
back from native to Java.

00:08:40.460 --> 00:08:42.460
Back and forth, back and forth.

00:08:42.460 --> 00:08:46.460
So if you don't have to,
avoid calling Raster GetDataBuffer.

00:08:46.460 --> 00:08:49.940
Because from that point on,
the performance of your

00:08:49.990 --> 00:08:52.460
application will really suffer.

00:08:52.460 --> 00:08:57.490
And to demonstrate this particular issue,
here is Scott.

00:08:59.100 --> 00:09:00.140
Great, thanks Gerard.

00:09:00.180 --> 00:09:02.420
So if we can go to the
first demo machine.

00:09:02.510 --> 00:09:08.820
So what we did is we found an applet
online that actually showed this problem.

00:09:09.030 --> 00:09:13.670
And it's this great thing called
the Zombie Infection Application.

00:09:13.910 --> 00:09:15.560
I just took it from an
applet and put it in here.

00:09:15.560 --> 00:09:17.400
So if you've downloaded
all the materials,

00:09:17.430 --> 00:09:19.620
you should have this Xcode project.

00:09:19.620 --> 00:09:23.000
Just open up the
Zombie Infection Xcode project.

00:09:23.030 --> 00:09:25.110
And I just want to run it.

00:09:25.310 --> 00:09:28.960
And so this is a slightly
modified version of what's online.

00:09:28.970 --> 00:09:37.320
And what you'll see happening here is
it will bring up a simulation of a city.

00:09:37.480 --> 00:09:39.360
And the city has a bunch of blue people.

00:09:39.360 --> 00:09:42.140
If you can see these blue
dots all running around here.

00:09:42.140 --> 00:09:45.350
And then these green dots that
show up here are these zombies

00:09:45.350 --> 00:09:47.020
who are infecting the people.

00:09:47.060 --> 00:09:51.250
And so it's simulating how zombies
would realistically infect a city.

00:09:51.320 --> 00:09:54.490
So this is a really important
application for scientists

00:09:54.620 --> 00:09:55.920
who are investigating zombies.

00:09:56.020 --> 00:09:59.750
But the point here is that this was
kind of a cool thing we saw online,

00:09:59.760 --> 00:10:00.750
but it was really slow.

00:10:00.760 --> 00:10:02.820
And we fixed some obvious slow things.

00:10:02.910 --> 00:10:05.180
But then we wanted to look at
it and see what really was slow.

00:10:05.390 --> 00:10:08.340
So I put in a frames per second counter.

00:10:08.340 --> 00:10:10.620
I also wanted to see how
well the zombies are going.

00:10:10.620 --> 00:10:13.350
So I put in some counters
to see these are zombies.

00:10:13.500 --> 00:10:15.860
These are people being
less and less people.

00:10:15.860 --> 00:10:18.320
And then some of the people
fight back and they're corpses.

00:10:18.320 --> 00:10:20.460
So the little red dots are dead zombies.

00:10:20.480 --> 00:10:23.500
So the point here is
that this is working OK,

00:10:23.550 --> 00:10:26.880
but we're on a really beefy 2.7 G5.

00:10:26.880 --> 00:10:29.380
And we should be getting
more than 26 frames a second.

00:10:29.510 --> 00:10:33.000
So I wanted to take a
quick look into the code.

00:10:33.000 --> 00:10:37.010
So if you open up the zombie panel,
this is pretty much the applet

00:10:37.020 --> 00:10:39.600
just embedded right in a J frame.

00:10:39.600 --> 00:10:45.360
If you go into the step method
of the zombie panel here,

00:10:45.380 --> 00:10:47.920
we can look at how this
application actually works.

00:10:47.930 --> 00:10:50.720
And the step is basically one
iteration of the simulation.

00:10:50.720 --> 00:10:52.390
You can tell us by the comment here.

00:10:52.420 --> 00:10:53.120
And it goes through all.

00:10:53.120 --> 00:10:55.210
It goes through all the
beings in the world.

00:10:55.220 --> 00:11:00.680
And what a being does is first
we plot the current location

00:11:00.680 --> 00:11:03.740
of the being to an empty color,
erasing our color.

00:11:03.770 --> 00:11:05.070
Then we step.

00:11:05.140 --> 00:11:08.260
And this lets the being do whatever
it does in its step operation,

00:11:08.390 --> 00:11:11.760
which usually involves looking
to see what's in front of it.

00:11:11.760 --> 00:11:14.000
If it's a person and it sees
a zombie in front of it,

00:11:14.000 --> 00:11:15.300
it might turn around and run.

00:11:15.300 --> 00:11:18.150
It might attack the zombie or something.

00:11:18.630 --> 00:11:20.740
And then that involves looking ahead.

00:11:20.740 --> 00:11:25.000
And then what we do is, in the step,
we'll probably move or do whatever we do.

00:11:25.000 --> 00:11:27.690
And then the last thing we do
is we plot our new location.

00:11:27.700 --> 00:11:31.550
Well,
I factored out the world object here.

00:11:31.560 --> 00:11:35.640
So if we go into the world,
we can see what the plot

00:11:35.640 --> 00:11:37.540
and peak methods do.

00:11:37.540 --> 00:11:41.110
Well, the plot method,
if we look all the way at the end,

00:11:41.140 --> 00:11:45.440
is getting a raster on the image,
and then it's calling setPixel.

00:11:45.440 --> 00:11:46.470
That's okay.

00:11:46.540 --> 00:11:47.640
That's fine.

00:11:48.720 --> 00:11:52.760
The peak method here is
checking an X and Y coordinate,

00:11:52.760 --> 00:11:54.820
and it's trying to see what's
ahead of it in this world,

00:11:54.820 --> 00:11:59.040
and it's doing it by looking at the image
and getting the RGB value of the image.

00:11:59.040 --> 00:12:02.090
So immediately we said, aha,
this is the deal.

00:12:02.090 --> 00:12:05.780
This guy is using the image itself
for storing all of his data,

00:12:05.900 --> 00:12:10.750
and he's calling getRGB to tell what
kind of objects are in this position.

00:12:10.760 --> 00:12:13.490
And so we know this is
hitting a slower path.

00:12:13.490 --> 00:12:18.370
So what we did is we just
did a very simple fix here.

00:12:18.500 --> 00:12:23.390
And we did this by if you just
search for double slash performance,

00:12:23.390 --> 00:12:28.220
I have all the code here so we
don't have to waste too much time.

00:12:28.220 --> 00:12:30.130
Let me start the very first one.

00:12:30.140 --> 00:12:33.300
And so what I did in the world is
I actually created a model for this.

00:12:33.320 --> 00:12:37.300
Instead of using the image as a model,
I just made a little

00:12:37.300 --> 00:12:41.690
inter-ray for the model,
and I initialized my inter-ray.

00:12:41.840 --> 00:12:45.580
and here when I plot,
I set the value for that inter-ray.

00:12:45.620 --> 00:12:48.500
And then when I go to peak,
instead of doing a get RGB,

00:12:48.520 --> 00:12:50.570
I just look things up in the inter-ray.

00:12:50.700 --> 00:12:53.780
And if you remember before,
we got about 26 frames per second,

00:12:53.780 --> 00:12:54.980
I think, something like that.

00:12:54.980 --> 00:12:58.140
So let's see,
let's stop that from running.

00:12:58.450 --> 00:13:01.380
Save and build and run.

00:13:03.370 --> 00:13:05.720
and our new version is
getting 36 frames per second.

00:13:05.790 --> 00:13:11.250
So just by the simple change of going
to a data model and not doing get RGB,

00:13:11.250 --> 00:13:15.250
we got a huge increase with just a
very small change to this whole thing.

00:13:15.270 --> 00:13:17.700
I mean,
this also is a better architecture,

00:13:17.770 --> 00:13:19.400
probably, for your application,
because you could render

00:13:19.400 --> 00:13:22.410
it not just into an image,
but you could render it as something else

00:13:22.530 --> 00:13:24.160
now that you have a data model behind it.

00:13:24.290 --> 00:13:26.540
But it shows that if you
avoid doing the get RGB,

00:13:26.540 --> 00:13:30.260
where we have to take the
native pixel and look at it,

00:13:30.430 --> 00:13:32.570
you'll actually get faster
performance out of it.

00:13:32.640 --> 00:13:33.440
Thank you.

00:13:33.440 --> 00:13:34.970
- Thanks Scott.

00:13:41.400 --> 00:13:47.690
The last thing that I would like to
mention for this issue in particular is

00:13:48.050 --> 00:13:53.280
You should decide whether you want to
use the Java 2D APIs to draw primitives.

00:13:53.280 --> 00:13:56.830
And if they're too slow for you
and you want to implement your own

00:13:56.830 --> 00:14:00.130
draw line or your own fill reg,
you can do that.

00:14:00.200 --> 00:14:02.710
But in order to do that,
then you have to call get raster,

00:14:02.710 --> 00:14:08.900
get data buffer, and from that point on,
you are stealing the Java pixels.

00:14:10.020 --> 00:14:13.010
But from that point on,
if you are going to do that,

00:14:13.010 --> 00:14:18.350
then please stay on that side and then
don't use normal draw line and normal

00:14:18.350 --> 00:14:21.280
draw reg or fill reg Java 2D APIs.

00:14:21.280 --> 00:14:25.250
Mixing those two mechanisms is
what will give you a slowdown.

00:14:25.270 --> 00:14:27.920
If you just stay on one
side or on the other side,

00:14:27.930 --> 00:14:30.390
then the performance will be just fine.

00:14:33.890 --> 00:14:36.540
Can we have a slide, please?

00:14:36.590 --> 00:14:40.480
Right, so let's talk about painting
from the wrong thread.

00:14:40.530 --> 00:14:44.380
You have to realize that windows
on Mac OS X are double buffered.

00:14:44.510 --> 00:14:48.630
They're retained, non-retained,
there are different types, one-shot,

00:14:48.640 --> 00:14:50.360
but all of them are double buffered.

00:14:50.510 --> 00:14:54.730
What that means is whenever you
draw into a window where you

00:14:54.730 --> 00:14:57.760
actually draw is the back buffer.

00:14:57.760 --> 00:15:04.260
So the primitives that you draw do not
appear unless somebody calls flash.

00:15:04.260 --> 00:15:08.470
Now in Java 2D APIs there is
no mechanism for you really to

00:15:08.470 --> 00:15:11.760
control when that flash happens.

00:15:11.760 --> 00:15:15.280
When you draw using the
normal AWT painting mechanism,

00:15:15.440 --> 00:15:20.440
we know when to flash because there
are clear entry points and exit points.

00:15:20.440 --> 00:15:24.260
There is a start of paint method and
there's the exit of paint method.

00:15:24.260 --> 00:15:27.760
So we know when you're done
painting and then we can flash.

00:15:27.760 --> 00:15:33.770
However, if you're drawing from a thread
older than AWT event thread,

00:15:33.830 --> 00:15:40.820
there is really no information
there for us to know when to flash.

00:15:40.820 --> 00:15:45.940
So the best that we can do is have a
heuristic and then we have a mechanism

00:15:45.950 --> 00:15:52.360
that tries and makes sure that we
flash at least 30 times per second.

00:15:52.360 --> 00:15:54.950
Now the problem with that is...

00:15:56.060 --> 00:15:59.210
If you are drawing,
and suppose you have an application,

00:15:59.210 --> 00:16:02.580
and the very first thing that you're
doing is erasing the background,

00:16:02.600 --> 00:16:05.580
so you have a full rack,
and then you start drawing your frame,

00:16:05.580 --> 00:16:10.180
but by erasing the entire frame,
and then you start

00:16:10.180 --> 00:16:12.610
slowly drawing the frame.

00:16:13.000 --> 00:16:16.600
We don't know when to flash,
so that flash will happen

00:16:16.600 --> 00:16:19.960
from another thread,
will happen at different times

00:16:20.430 --> 00:16:22.110
when you draw your frame.

00:16:22.110 --> 00:16:26.600
That means it can happen right
after you just called full rack,

00:16:26.600 --> 00:16:30.080
and right after you
erased your entire frame.

00:16:30.100 --> 00:16:32.740
So what you will see on
screen is just nothing.

00:16:32.740 --> 00:16:34.120
It's just empty frame.

00:16:34.120 --> 00:16:37.800
It can happen somewhere in the
middle of you drawing the frame.

00:16:37.840 --> 00:16:42.840
What that will do is the user will
actually see half of the frame.

00:16:43.000 --> 00:16:44.940
Half of the scenery finished.

00:16:45.190 --> 00:16:47.000
So that's not good.

00:16:47.150 --> 00:16:52.220
And the problem, the flicker,
we'll refer to this problem as a flicker,

00:16:52.220 --> 00:16:55.760
can also occur when drawing into images.

00:16:55.890 --> 00:16:58.710
The scenario is quite similar.

00:16:58.820 --> 00:17:01.620
If you're drawing into an image,

00:17:02.400 --> 00:17:40.400
[Transcript missing]

00:17:45.650 --> 00:17:49.200
So let's open
Animation Flicker on screen.

00:17:49.200 --> 00:17:52.440
We'll take a look at this case first.

00:17:55.690 --> 00:17:58.950
So let's quickly take a look at
how this application is written.

00:17:59.040 --> 00:18:04.100
So we have normal staff here.

00:18:04.110 --> 00:18:05.850
We're setting bounds, visible.

00:18:06.050 --> 00:18:07.560
Here is the interesting part.

00:18:07.560 --> 00:18:14.360
We are creating a thread which
we'll use to render the application.

00:18:14.360 --> 00:18:18.100
So the rendering actually happens
right here on this thread.

00:18:18.100 --> 00:18:21.080
And here is where we're
drawing directly to the screen.

00:18:21.080 --> 00:18:26.190
So let's run and let's see how
this application looks like.

00:18:28.340 --> 00:18:32.750
As you can see, there is not a whole lot
that is happening here.

00:18:32.950 --> 00:18:35.940
Basically, mostly you get blank frame.

00:18:35.940 --> 00:18:38.160
And there's a little
bit of flicker there.

00:18:38.160 --> 00:18:39.720
There's something there.

00:18:39.720 --> 00:18:42.220
But basically, this is unusable.

00:18:42.220 --> 00:18:44.600
And we've seen applications like this.

00:18:44.740 --> 00:18:46.070
We have actually seen them.

00:18:47.380 --> 00:18:49.410
Here is the point.

00:18:49.800 --> 00:18:55.180
Windows,
the actual Windows on Windows platform

00:18:55.810 --> 00:19:03.630
are not double buffered,
or they may not be.

00:19:04.650 --> 00:19:04.650
So those Windows are single buffered.

00:19:04.870 --> 00:19:08.440
If you draw a primitive,
it appears directly on screen.

00:19:08.460 --> 00:19:12.480
So that application run
on Windows platform will

00:19:12.480 --> 00:19:14.240
actually work just fine.

00:19:14.270 --> 00:19:16.920
But on Mac OS X, it will not.

00:19:16.980 --> 00:19:19.580
So how do we fix this?

00:19:20.870 --> 00:19:25.870
The fix is actually very easy, but you,
and as silly as it sounds,

00:19:26.030 --> 00:19:30.940
you actually have to implement your
own double buffering mechanism.

00:19:31.040 --> 00:19:35.220
So, basically what you have to do is
you have to change from drawing

00:19:35.220 --> 00:19:37.480
on screen to drawing off screen.

00:19:37.480 --> 00:19:44.090
So let's implement this method.

00:19:48.550 --> 00:19:50.920
I already have implemented
this method for you,

00:19:50.920 --> 00:19:53.740
so let's take a look at it.

00:19:53.740 --> 00:19:55.320
Here is what it looks like.

00:19:55.320 --> 00:19:58.480
The very first thing that we do
is we'll create a buffered image

00:19:58.480 --> 00:20:00.380
into which we'll be drawing.

00:20:00.380 --> 00:20:04.370
And notice we're using
Create Compatible image here.

00:20:04.560 --> 00:20:08.590
Once we have that image,
we'll obtain the graphics from it,

00:20:08.590 --> 00:20:11.190
and then we'll proceed in
the same fashion as we were

00:20:11.670 --> 00:20:12.880
before drawing on screen.

00:20:12.880 --> 00:20:16.450
We'll use the same method,
except we'll use that method

00:20:16.470 --> 00:20:18.140
to draw into our image.

00:20:18.140 --> 00:20:22.640
And then once we're done with
drawing to that off-screen image,

00:20:22.640 --> 00:20:25.590
we'll take that image and
we bleed it back to screen.

00:20:25.600 --> 00:20:27.230
So this will work.

00:20:31.300 --> 00:20:34.660
See, there's no flicker.

00:20:34.700 --> 00:20:37.070
So this is the on-screen case.

00:20:37.240 --> 00:20:39.910
Let's take a look at the off-screen case.

00:20:49.500 --> 00:20:56.040
So we also have a thread which
we use to render our application.

00:20:56.040 --> 00:20:57.700
So here is the thread.

00:20:57.800 --> 00:21:01.390
We are using off-screen
right here for our rendering.

00:21:01.520 --> 00:21:07.020
So we actually are rendering
off-screen into an image.

00:21:07.020 --> 00:21:11.730
But then, if you see right here,
DrawGameOffScreen,

00:21:11.910 --> 00:21:16.340
What we do here is we ask the component
to repaint itself by calling repaint.

00:21:16.460 --> 00:21:20.440
What that will do is that we
use the AWT paint mechanism.

00:21:20.530 --> 00:21:23.510
So we'll go back to paint right here.

00:21:24.500 --> 00:21:31.040
And that image will be used from the
paint method to draw back to screen.

00:21:31.060 --> 00:21:33.030
So let's run this.

00:21:33.490 --> 00:21:35.580
There is a little flicker.

00:21:35.840 --> 00:21:39.060
Interestingly,
this application will behave much

00:21:39.060 --> 00:21:41.400
better on a single processor machine.

00:21:41.450 --> 00:21:44.540
If you are developing this
application on your laptop,

00:21:44.540 --> 00:21:47.400
you may not get to see the flicker.

00:21:47.400 --> 00:21:52.130
You may be surprised when your
clients are complaining that this

00:21:52.360 --> 00:21:57.400
application does flicker because they
are using a dual processor machine.

00:21:57.400 --> 00:21:58.950
This is a dual processor machine.

00:21:58.950 --> 00:22:00.380
It flickers here a little bit.

00:22:00.970 --> 00:22:03.400
What is the fix?

00:22:03.400 --> 00:22:06.870
The problem here is that the
rendering into off-screen and then

00:22:06.870 --> 00:22:11.400
rendering that off-screen back
on-screen is not synchronized.

00:22:11.400 --> 00:22:14.400
There is a trivial fix.

00:22:14.400 --> 00:22:18.260
All that you need is
just synchronization.

00:22:21.410 --> 00:22:27.540
And we can use the actual image
as a synchronization lock object.

00:22:27.580 --> 00:22:31.020
So we have our paint method synchronized.

00:22:32.590 --> 00:22:37.140
And then the actual rendering
used to be synchronized with that.

00:22:41.750 --> 00:22:42.610
There's no flicker now.

00:22:42.640 --> 00:22:45.880
That is just one way of
fixing this application.

00:22:45.880 --> 00:22:49.180
But this will do.

00:22:49.180 --> 00:22:53.120
Can we go back to slides, please?

00:22:58.890 --> 00:23:00.440
There is one another solution.

00:23:00.620 --> 00:23:03.920
If you remember for the on-screen case,
we implemented a double

00:23:03.920 --> 00:23:05.570
buffering mechanism.

00:23:05.570 --> 00:23:07.220
You don't actually have
to do that yourself.

00:23:07.320 --> 00:23:13.100
There is already a buffer
strategy API in Java 2D APIs.

00:23:13.100 --> 00:23:13.900
You can use that.

00:23:13.940 --> 00:23:17.160
It's much simpler and it works too.

00:23:19.000 --> 00:25:11.300
[Transcript missing]

00:25:12.140 --> 00:25:14.400
Here is an example.

00:25:14.570 --> 00:25:19.260
The first snippet of
the code is using XOR.

00:25:19.290 --> 00:25:23.220
We are setting the color blue,
set XOR mode color black.

00:25:23.260 --> 00:25:26.600
Now guess what color you
will get as a result of this.

00:25:26.750 --> 00:25:28.250
It's some sort of yellow.

00:25:28.300 --> 00:25:35.220
You have no control over the transparency
and it doesn't look just right.

00:25:35.270 --> 00:25:41.110
If you use Alpha Composite,
you have control over the translucency

00:25:41.130 --> 00:25:48.350
of the color and the resulting
look will be more native-like.

00:25:49.690 --> 00:25:53.140
So I'm done,
and I would like to ask Viktor to

00:25:53.160 --> 00:25:54.420
continue with his presentation.

00:25:54.420 --> 00:25:55.860
Thank you.

00:25:59.200 --> 00:26:00.700
Thanks, Gerard.

00:26:00.740 --> 00:26:03.530
So let's talk about Quartz Debug.

00:26:03.710 --> 00:26:06.780
But before we do that,
I want to set up a simple case

00:26:06.780 --> 00:26:09.100
where Quartz Debug might be useful.

00:26:09.140 --> 00:26:11.630
So let's talk about how
you animate a rectangle.

00:26:11.750 --> 00:26:14.860
So we have a rectangle, very simple,
and you want to animate it.

00:26:14.910 --> 00:26:17.200
And we're going to make two assumptions.

00:26:17.200 --> 00:26:19.340
The first one is we're
going to-- let's say,

00:26:19.340 --> 00:26:20.500
subclass component.

00:26:20.540 --> 00:26:25.920
And we're going to do all of
the drawing in the paint method.

00:26:25.920 --> 00:26:30.780
What that means is that we're going to
do the painting on the event thread.

00:26:30.790 --> 00:26:34.820
So the problem is move
from point A to point B.

00:26:34.830 --> 00:26:36.300
Very simple.

00:26:36.300 --> 00:26:39.460
So how would somebody
go about doing that?

00:26:39.520 --> 00:26:42.040
First, if you have the geometry
of the rectangle,

00:26:42.040 --> 00:26:45.440
you would change it from
position A to position B.

00:26:45.440 --> 00:26:48.260
Second, you're going to actually
ask the repaint manager,

00:26:48.350 --> 00:26:50.500
say, hey, we changed our position.

00:26:50.510 --> 00:26:51.480
Please repaint us.

00:26:51.480 --> 00:26:54.400
And then later on,
when the repaint manager is ready,

00:26:54.420 --> 00:26:56.370
he's going to send you a
little repaint request,

00:26:56.540 --> 00:26:58.260
and he's going to call your paint method.

00:26:58.380 --> 00:27:03.220
And at that time, you blit the rectangle
from point A to point B.

00:27:03.230 --> 00:27:05.200
So that is a very simple example.

00:27:05.200 --> 00:27:07.580
And I kind of breezed through that
because it's not that important,

00:27:07.670 --> 00:27:10.540
but I kind of wanted to
set up this question.

00:27:10.540 --> 00:27:13.220
What could go wrong with this example?

00:27:13.220 --> 00:27:17.610
So the two obvious questions that
somebody should ask themselves is,

00:27:17.640 --> 00:27:21.140
well, are we going to repaint
more often than we need to?

00:27:21.150 --> 00:27:24.100
The second question is also,
are we repainting a larger

00:27:24.100 --> 00:27:25.740
area than we need to?

00:27:25.760 --> 00:27:28.160
And just to keep in mind, graphics,
paint, and paint, I think,

00:27:28.160 --> 00:27:29.080
are very different.

00:27:29.080 --> 00:27:30.940
Graphics paints could
sometimes be expensive.

00:27:30.940 --> 00:27:34.840
So if you don't need to paint an area,
don't paint it.

00:27:34.860 --> 00:27:40.280
And these questions will help
you kind of keep that in mind.

00:27:40.320 --> 00:27:43.120
So to answer these questions,
what are the current tools?

00:27:43.220 --> 00:27:45.260
There are several techniques you can do.

00:27:45.270 --> 00:27:48.120
And the one that I used to
use a lot was just print

00:27:48.160 --> 00:27:49.840
statements or debug statements.

00:27:49.870 --> 00:27:51.530
And the other one,
you can run a debugger,

00:27:51.530 --> 00:27:53.470
and you can kind of print the geometry.

00:27:53.660 --> 00:27:55.730
But that's kind of hard,
and it's not visual.

00:27:55.910 --> 00:27:57.120
So Quartz Debug has a
better way of doing that.

00:27:57.230 --> 00:28:00.980
It has a better way of debugging
this kind of repainting issue.

00:28:00.990 --> 00:28:03.880
And just as a reminder,
for those of you who don't know

00:28:03.960 --> 00:28:07.120
where to find Quartz Debug,
you can find it under Developer,

00:28:07.120 --> 00:28:09.910
Applications, Performance Tools.

00:28:10.240 --> 00:28:15.120
So, and now it's a time for a
hands-on demo for course debug.

00:28:15.220 --> 00:28:17.710
Can we switch to demo one, please?

00:28:20.130 --> 00:28:21.760
So this one will be very easy to follow.

00:28:21.760 --> 00:28:25.760
So if you've downloaded the examples,
or you have the disk image, come along,

00:28:25.760 --> 00:28:26.400
follow.

00:28:26.400 --> 00:28:28.300
It should be very easy.

00:28:28.900 --> 00:28:35.670
So let's start by opening the
application called Sky Creator.

00:28:35.830 --> 00:28:38.270
So you have the disk image,
you can just go to the

00:28:38.330 --> 00:28:41.090
Sky Creator folder,
and there's a code for that,

00:28:41.180 --> 00:28:43.300
and I'm not going to actually
walk you through code.

00:28:43.380 --> 00:28:47.600
You can look at it on your
own time when you get home or

00:28:48.200 --> 00:28:50.020
whenever you want to do that.

00:28:50.020 --> 00:28:50.300
But the

00:28:50.520 --> 00:28:52.200
Let's start by running
the Sky Creator app.

00:28:52.200 --> 00:28:55.090
So there's a skycreator.zip.

00:28:55.300 --> 00:28:56.760
You can take a look at it here.

00:28:56.760 --> 00:29:00.060
And if you double-click that,
it's going to unzip it.

00:29:00.070 --> 00:29:02.920
And there should be a
Sky Creator application.

00:29:02.970 --> 00:29:06.910
So what I want you to do is just go ahead
and run this Sky Creator application.

00:29:07.690 --> 00:29:10.880
So what this application does,
I created a very simple

00:29:10.980 --> 00:29:14.160
kind of application that
tries to generate the sky.

00:29:14.230 --> 00:29:18.450
So it has different kind of star sizes,
and then it just kind of

00:29:18.560 --> 00:29:21.760
mixes and matches and randomly
creates an image of a star.

00:29:22.000 --> 00:29:25.440
And just for the fun of it,
you can actually drag the stars around.

00:29:25.580 --> 00:29:27.440
So you can go drag them,
and you can arrange them,

00:29:27.440 --> 00:29:28.600
and you can create your own sky.

00:29:28.690 --> 00:29:30.210
So it's a very simple app.

00:29:30.510 --> 00:29:33.980
But one thing to notice is,
as I'm dragging the star around,

00:29:34.040 --> 00:29:37.380
I'm sure you can see it on the projector,
there's a lag.

00:29:37.580 --> 00:29:43.040
As I'm dragging my star,
the star lags the cursor.

00:29:43.240 --> 00:29:44.760
Now this is a pretty beefy machine.

00:29:44.820 --> 00:29:49.790
It's a dual 2.7 G5,
and it's still very sluggish.

00:29:50.010 --> 00:29:52.430
If you run it on a laptop,
it should be painfully slow.

00:29:52.670 --> 00:29:56.450
So I don't know if you have run it,
but it should be very slow.

00:29:56.610 --> 00:30:01.160
So how do we debug problems like this?

00:30:01.540 --> 00:30:03.400
The first thing I would do,
I would run Shark.

00:30:03.400 --> 00:30:04.860
And I've run Shark on this.

00:30:04.870 --> 00:30:07.440
And it's just going to say, oh,
you spend all the time painting.

00:30:07.440 --> 00:30:10.460
Well, duh, I'm painting a star,
so I'm going to spend

00:30:10.460 --> 00:30:11.940
all the time painting.

00:30:11.940 --> 00:30:14.640
So the second thing I want to
do now is run Quartz Debug.

00:30:14.640 --> 00:30:17.530
And I want to see how much am I painting.

00:30:17.650 --> 00:30:22.410
So if you're following along,
open up the Finder and go to your

00:30:22.410 --> 00:30:28.190
Developers folder under Developers,
Application, Performance Tools,

00:30:28.330 --> 00:30:31.350
and just fire off Quartz Debug.

00:30:31.340 --> 00:30:33.220
So you're going to see
this little pop-up menu.

00:30:33.220 --> 00:30:36.180
And Quartz Debug has many features,
and I'm not going to cover

00:30:36.180 --> 00:30:37.660
any of them except for one.

00:30:37.710 --> 00:30:39.960
I want to cover the Flash Screen Updates.

00:30:39.990 --> 00:30:44.700
So if you just check that box,
what that will do is every time

00:30:44.700 --> 00:30:47.610
there is bleeding on the screen,
there's going to be a yellow rectangle

00:30:48.200 --> 00:30:52.160
that's going to flash and tells
you which area is being repainted.

00:30:52.210 --> 00:30:55.600
So just to give you an example,
if I move the mouse over,

00:30:55.600 --> 00:30:57.470
I see this yellow rectangle here.

00:30:57.480 --> 00:31:01.080
Or if I go over the dock,
I can see what areas

00:31:01.080 --> 00:31:03.470
I'm actually repainting.

00:31:03.600 --> 00:31:08.860
So the obvious thing to do is to drag
a star around and see what happens.

00:31:09.300 --> 00:31:11.360
Whoa, so that's not good.

00:31:11.460 --> 00:31:15.140
So what this tells me that
every time I'm dragging a star,

00:31:15.160 --> 00:31:17.300
I'm actually repainting the whole scene.

00:31:17.340 --> 00:31:18.800
And the scene is pretty complex.

00:31:18.800 --> 00:31:20.680
It's not complex,
but it has a lot of images.

00:31:20.680 --> 00:31:22.600
It has about 1,000 images.

00:31:22.790 --> 00:31:27.680
So let's drag this little tiny star,
and that's pretty bad.

00:31:27.760 --> 00:31:30.190
So let's see how we can fix that.

00:31:30.480 --> 00:31:32.400
So usually what I do,
I just go to course debug

00:31:32.400 --> 00:31:33.140
and turn the flashing.

00:31:33.190 --> 00:31:35.400
So while you're doing all
the debugging and coding,

00:31:35.400 --> 00:31:38.070
you really don't want
all that flashing around.

00:31:38.790 --> 00:31:42.950
So if you just close the Sky Creator app,
and again,

00:31:42.950 --> 00:31:44.200
you can take a look at the code.

00:31:44.200 --> 00:31:46.080
And I'm not going to go over the code,
how to fix that.

00:31:46.120 --> 00:31:49.010
But the obvious fix would be
not to repaint the whole screen.

00:31:49.060 --> 00:31:50.570
Just repaint what's necessary.

00:31:50.670 --> 00:31:55.970
Just repaint the dirty area that you
just invalidated by dragging that star.

00:31:56.460 --> 00:31:57.530
So let's go back to the demos.

00:31:57.660 --> 00:32:00.800
And if you're following along,
just go to the demos and go

00:32:00.800 --> 00:32:02.740
to the Sky Creator directory.

00:32:03.080 --> 00:32:07.290
And then there should be an
application called skycreator.faster.

00:32:07.400 --> 00:32:10.460
So in the DMG,
it's a skycreator.faster.zip.

00:32:10.520 --> 00:32:12.440
So I want you to click and unzip it.

00:32:12.470 --> 00:32:14.740
And that's going to unzip the app.

00:32:14.860 --> 00:32:17.880
And again,
all of this code is in the Xcode project.

00:32:17.880 --> 00:32:21.100
And I hope you'll go home
and take a look at it.

00:32:21.760 --> 00:32:24.740
So this is a Sky Creator faster,
which means we have

00:32:24.740 --> 00:32:26.760
optimized the repainting.

00:32:26.800 --> 00:32:29.300
So if I drag a star around,
as you can see,

00:32:29.300 --> 00:32:31.260
it's clearly following along.

00:32:31.260 --> 00:32:32.990
It doesn't feel sluggish at all.

00:32:33.160 --> 00:32:35.390
So let's drag a smaller star.

00:32:35.800 --> 00:32:37.700
and it's following along perfectly.

00:32:37.700 --> 00:32:39.110
Let's drag a bigger star.

00:32:39.450 --> 00:32:39.920
No problem.

00:32:40.100 --> 00:32:41.150
Feels very zippy.

00:32:41.150 --> 00:32:45.700
And it should feel zippy on your
three-year-old laptop as well.

00:32:45.740 --> 00:32:49.650
Let's run course debug just to verify
that I've indeed fixed the problem.

00:32:49.710 --> 00:32:55.700
So just click on Flash, Screen Updates,
and then let's drag the star around.

00:32:55.700 --> 00:32:59.330
And as you can see,
I'm only painting the area

00:32:59.410 --> 00:33:01.700
that I just invalidated.

00:33:01.720 --> 00:33:02.700
And let's drag a smaller star.

00:33:02.700 --> 00:33:04.700
This will be even more obvious.

00:33:04.700 --> 00:33:05.700
And I'm repainting this area.

00:33:05.700 --> 00:33:09.700
So it's much more efficient than
repainting the whole complex scene.

00:33:09.760 --> 00:33:14.000
And you can see the faster you drag it,
the bigger the region is because

00:33:14.000 --> 00:33:17.700
that's the actual region that
you actually invalidated.

00:33:17.700 --> 00:33:20.110
So I'm going to turn off course debug.

00:33:21.310 --> 00:33:23.890
So just to summarize,
it's a very simple tool.

00:33:23.890 --> 00:33:26.190
And if you're doing a
graphics application,

00:33:26.190 --> 00:33:28.050
please run it before you ship it.

00:33:28.240 --> 00:33:32.250
It will tell you whether you're
doing something very silly.

00:33:32.430 --> 00:33:36.490
So with that in mind,
can we switch back to slides?

00:33:40.100 --> 00:33:44.020
So now I would like to invite
Christy to talk to you about Shark.

00:33:44.140 --> 00:33:45.500
Thanks.

00:33:51.710 --> 00:33:53.030
Good morning, everyone.

00:33:53.100 --> 00:33:55.500
Hope you're enjoying WWDC this week.

00:33:55.600 --> 00:33:57.100
Yeah, I've been.

00:33:57.130 --> 00:33:59.360
I'm here to tell you
about Shark for Java.

00:33:59.400 --> 00:34:01.740
You know, we just added this last year,
and it's gotten good

00:34:01.860 --> 00:34:03.280
response in the community.

00:34:03.280 --> 00:34:05.470
So what is Shark?

00:34:05.470 --> 00:34:08.810
Shark is a profiling tool.

00:34:10.490 --> 00:34:14.480
It lets you profile a running process,
thread, or the entire system.

00:34:14.720 --> 00:34:18.760
For Java, you can only profile
an individual process,

00:34:18.800 --> 00:34:22.370
however, but you can do time
samples to find hotspots,

00:34:22.370 --> 00:34:28.010
you can trace memory allocations to see
patterns of memory usage in your program,

00:34:28.010 --> 00:34:30.810
or even exact trace method calls.

00:34:31.230 --> 00:34:35.650
And for non-Java profiling,
you can do time, memory, function,

00:34:35.750 --> 00:34:38.200
system, your hardware system events.

00:34:38.370 --> 00:34:42.070
And this is useful to say JNI calls,
or if you're running in a heterogeneous

00:34:42.160 --> 00:34:45.870
environment where you have some
Java and some C or other servers,

00:34:46.000 --> 00:34:49.400
it's very useful to see where
the time is being spent.

00:34:49.800 --> 00:35:57.900
[Transcript missing]

00:35:58.940 --> 00:36:02.260
Another really special thing
in Shark is data mining.

00:36:02.320 --> 00:36:03.800
How many of you,
when you've done your profile,

00:36:03.800 --> 00:36:10.000
you don't see times spent in your code,
but in somewhere in AWT, Java, Lang,

00:36:10.040 --> 00:36:10.740
String?

00:36:10.740 --> 00:36:13.030
How many of you have had
that problem when profiling?

00:36:13.030 --> 00:36:14.360
A lot of you.

00:36:14.360 --> 00:36:17.790
Well, with Shark,
you can eliminate what you don't want.

00:36:17.790 --> 00:36:22.150
You can take a package like Java, Lang,
String and charge it to the caller,

00:36:22.620 --> 00:36:26.340
eliminating that from your samples
and seeing who is using Java,

00:36:26.340 --> 00:36:27.550
Lang, String.

00:36:27.560 --> 00:36:30.850
You can also charge a
symbol in a similar fashion.

00:36:30.850 --> 00:36:34.020
The other half of this is to
help you see what you want.

00:36:34.020 --> 00:36:38.140
You can focus on a particular function
in the subtree that comes out from

00:36:38.220 --> 00:36:40.600
it rather than seeing everything
that's going on in your program.

00:36:40.620 --> 00:36:44.340
This helps you narrow down, you know,
the contribution of your data.

00:36:44.340 --> 00:36:46.340
And you can also do a
specific performance problem.

00:36:46.340 --> 00:36:49.100
Similarly, you can focus on a package.

00:36:49.100 --> 00:36:51.860
Let me illustrate these graphically.

00:36:51.860 --> 00:36:55.900
So in charging packages to a caller,
we have a main program here.

00:36:56.120 --> 00:36:58.510
And there's an initialization section.

00:36:58.630 --> 00:37:03.010
Then it calls this main, you know,
function do_example and some cleanup.

00:37:03.430 --> 00:37:07.050
And let's say inside it
calls some function bar.

00:37:07.050 --> 00:37:08.970
It calls into Java util.

00:37:08.970 --> 00:37:14.320
Now, if we were to profile this thing,
we would see samples in Java util.

00:37:14.450 --> 00:37:16.770
And not in bar,
even though bar is the function

00:37:16.770 --> 00:37:18.260
we're calling the most.

00:37:18.290 --> 00:37:21.780
But by charging Java util,
it suddenly pushes all

00:37:21.780 --> 00:37:24.310
those costs up into bar.

00:37:24.450 --> 00:37:27.080
And it shows you what's really going on.

00:37:27.180 --> 00:37:29.890
So with this tool,
you can now see what's going on in

00:37:29.900 --> 00:37:33.640
the middle of the call trees where
the interesting stuff and usually

00:37:33.670 --> 00:37:35.500
the hard to track down stuff is.

00:37:36.400 --> 00:37:40.200
Now in some cases we may want to
not completely remove a package,

00:37:40.200 --> 00:37:43.300
but replace all calls to it
with just the entry point.

00:37:43.420 --> 00:37:47.470
In other words,
if you call into string buffer append,

00:37:47.600 --> 00:37:50.890
you don't want to see all the
Java lang string calls that

00:37:51.360 --> 00:37:55.800
append might happen to use in the
current version of the library.

00:37:55.880 --> 00:37:59.800
But you do want to see how many times
you've called append in your program.

00:38:00.000 --> 00:38:02.790
So we call that flatten a package.

00:38:03.140 --> 00:38:05.500
So in this case,
you get rid of the package,

00:38:05.590 --> 00:38:08.830
but we leave-- in this case,
we're using hash table contains--

00:38:09.000 --> 00:38:11.630
the call to hash table contains.

00:38:11.920 --> 00:38:13.690
So finally, focusing.

00:38:13.910 --> 00:38:16.800
On focus,
we don't care about what's going on

00:38:16.800 --> 00:38:17.800
in the initialization and the cleanup.

00:38:17.800 --> 00:38:20.800
Suppose they're calling a bunch
of stuff to Java Lang String.

00:38:20.800 --> 00:38:23.260
Well,
we want to make sure that the part of

00:38:23.260 --> 00:38:27.700
our program that's doing the work is
also hitting that code really heavily.

00:38:27.800 --> 00:38:31.910
So in this case,
we're going to focus on Do Example,

00:38:31.910 --> 00:38:34.790
and that'll strip away this part of the,
you know,

00:38:34.810 --> 00:38:37.840
the outer parts of the call tree,
leaving us with just the portion

00:38:37.960 --> 00:38:39.800
that we're interested in.

00:38:39.920 --> 00:38:42.800
So without further ado,
I'm going to do a little demo.

00:38:42.800 --> 00:38:45.780
Can we please switch to Demo 1?

00:38:49.750 --> 00:38:55.710
OK, so for those of you following along,
please open the bouncy Xcode project.

00:38:55.820 --> 00:39:04.080
And I'm just going to run the app for
once just to show you what it looks like.

00:39:08.530 --> 00:39:14.640
So, just a cute little demo that shows a
string bouncing around on the screen.

00:39:14.690 --> 00:39:18.230
One of the important things when you're
doing performance in an application

00:39:18.290 --> 00:39:19.980
is you want to create instrumentation.

00:39:19.980 --> 00:39:21.040
We saw several examples.

00:39:21.040 --> 00:39:26.410
Scott with his Zombies program here,
and in some later demos you'll

00:39:26.410 --> 00:39:29.060
see that it's really important
you add some kind of measurements,

00:39:29.190 --> 00:39:32.530
like frames per second or whatever
is useful for your application

00:39:33.330 --> 00:39:35.800
to keep track of how it's doing.

00:39:35.910 --> 00:39:37.400
So we're going to get out of that.

00:39:37.450 --> 00:39:42.830
And now to use Shark for Java,
we have to do a few things.

00:39:43.090 --> 00:39:45.300
There's a command line argument.

00:39:45.370 --> 00:39:52.600
Shark for Java uses the JVMPI API-- or,
sorry, package.

00:39:52.640 --> 00:39:55.940
So you need to add an
XRUN argument to it,

00:39:55.950 --> 00:39:57.990
similar to the one you see here.

00:39:58.000 --> 00:39:59.800
-XRUN shark.

00:39:59.830 --> 00:40:03.900
It's also important that it
goes before any -jar options.

00:40:03.900 --> 00:40:06.480
If you put it afterwards,
if you were to put it down here,

00:40:06.500 --> 00:40:08.700
it won't work,
and it'll mysteriously not work.

00:40:08.700 --> 00:40:11.670
You'll just go, well,
why aren't I seeing this?

00:40:11.900 --> 00:40:16.240
So when we do this,
now we can rerun the application.

00:40:16.240 --> 00:40:18.570
And to verify that
Shark for Java is enabled,

00:40:18.570 --> 00:40:21.920
it will give you this text here,
"Shark for Java is enabled,"

00:40:22.000 --> 00:40:23.700
so you know it's running.

00:40:23.750 --> 00:40:26.960
Now let's go navigate to Shark.

00:40:29.030 --> 00:40:32.600
So it's in Developer, Applications,
Performance Tools.

00:40:32.600 --> 00:40:35.810
It's right next to Quartz Debug.

00:40:36.130 --> 00:40:37.890
We'll launch it.

00:40:37.890 --> 00:40:39.290
And this is the main Shark window.

00:40:39.300 --> 00:40:40.860
It has a start button.

00:40:40.860 --> 00:40:44.450
It has a pop-up menu of different
profiles you can select.

00:40:44.530 --> 00:40:46.660
And there's a lot of different ones,
but we're going to

00:40:46.660 --> 00:40:47.860
choose Java Time Trace.

00:40:47.860 --> 00:40:50.710
And it'll force us to pick a process.

00:40:50.720 --> 00:40:55.840
And then there'll be a list of all the,
you know, JVMPI processes that were

00:40:55.840 --> 00:40:57.620
done with X Run Shark.

00:40:57.620 --> 00:41:01.960
Now another important thing to do,
and those of you following along

00:41:01.970 --> 00:41:05.960
need to do this at this time,
is you go to Search Paths

00:41:05.980 --> 00:41:09.610
in Shark Preferences,
and under Source Files,

00:41:09.860 --> 00:41:13.600
you want to add the path
to your demos bouncy.

00:41:13.600 --> 00:41:18.300
And you just click on the plus sign here,
navigate to that folder in your demos,

00:41:18.300 --> 00:41:20.090
and then just choose Open.

00:41:20.100 --> 00:41:23.460
And once you do that,
we can start sampling.

00:41:23.460 --> 00:41:26.640
And when we sample,
when we're doing time-based sampling,

00:41:26.640 --> 00:41:29.300
you want to sample for
like 5 or 10 seconds,

00:41:29.300 --> 00:41:31.190
so you get a reasonable
number of samples.

00:41:31.190 --> 00:41:35.070
For memory allocations or exact traces,
you want to do it relatively short,

00:41:35.070 --> 00:41:39.160
or you'll just get too many samples,
and it'll be slow.

00:41:39.330 --> 00:41:42.440
So that's enough time for sampling.

00:41:42.470 --> 00:41:43.960
And we get a view here.

00:41:43.990 --> 00:41:46.310
And what this is,
this is a list of all the leaf

00:41:46.440 --> 00:41:50.840
functions that were called and
the percentage of time spent.

00:41:50.890 --> 00:41:53.420
And one useful thing here,
if you click on the lower right,

00:41:53.420 --> 00:41:54.760
there's a little box.

00:41:54.780 --> 00:41:58.040
And you can show a stack view.

00:41:58.040 --> 00:42:00.790
And if you click on a symbol,
you'll see on the right

00:42:00.860 --> 00:42:02.760
here a back trace.

00:42:02.820 --> 00:42:08.280
So C text by dude drawstring
is called by OS X surface data,

00:42:08.300 --> 00:42:10.100
and so on.

00:42:10.340 --> 00:42:14.200
and you can click on different functions
and you'll see the different backtraces.

00:42:14.450 --> 00:42:18.200
So this is a bottoms
up view of the world.

00:42:18.320 --> 00:42:22.200
Now it's also useful
to see a top down view.

00:42:22.200 --> 00:42:26.200
So I just switch via this pop up here.

00:42:26.200 --> 00:42:27.440
You can choose heavy, tree, or both.

00:42:27.760 --> 00:42:30.200
And I'm just going to show both here.

00:42:30.420 --> 00:42:34.200
If you click on this,
you'll see a view from main

00:42:34.260 --> 00:42:38.200
down to somewhere deep and
down it calls bouncy paint.

00:42:38.470 --> 00:42:43.010
Now, getting back to data mining,
if you go to the data mining menu,

00:42:43.010 --> 00:42:46.200
you can say charge library
Java AWT to callers.

00:42:46.200 --> 00:42:52.200
And now that eliminated about half
the calls on the right side here.

00:42:52.360 --> 00:42:54.030
Let's keep doing this.

00:42:54.200 --> 00:42:58.200
So let's get rid of Apple AWT and
let's get rid of Sun AWT.

00:42:58.200 --> 00:43:02.200
So now we have a much simpler view.

00:43:02.200 --> 00:43:05.220
We have paint, paintballs,
it's just in a few steps we've

00:43:05.380 --> 00:43:10.200
reduced the problem from this big
complex world that I can't understand,

00:43:10.200 --> 00:43:14.200
maybe someone in the audience can,
but I can't, to a relatively simple world

00:43:14.200 --> 00:43:18.160
where it's stuff that's familiar
to me since I wrote bouncy.

00:43:18.300 --> 00:43:21.870
Now, you'll notice that bouncy
paint is underlined.

00:43:22.540 --> 00:43:26.840
So we double click on
Bouncy and we see Source.

00:43:26.860 --> 00:43:31.100
And it's marked up with different
color highlights depending

00:43:31.100 --> 00:43:32.460
on how much time was spent.

00:43:32.460 --> 00:43:34.520
And we see that most of the
time was spent in paintballs.

00:43:34.520 --> 00:43:35.380
And that's also underlined.

00:43:35.380 --> 00:43:38.040
So we can click on that like a hyperlink.

00:43:38.060 --> 00:43:40.260
And here, oh, we see our problem.

00:43:40.260 --> 00:43:43.720
Well, I must have been asleep
when I wrote this code.

00:43:43.740 --> 00:43:50.060
I'm allocating a new font every
time I'm drawing one of these balls.

00:43:50.070 --> 00:43:52.220
That seems kind of dumb.

00:43:52.650 --> 00:43:55.960
So, luckily I have this edit button here.

00:43:56.080 --> 00:43:58.380
So, I found my problem.

00:43:58.420 --> 00:43:59.460
I go edit.

00:43:59.530 --> 00:44:02.090
It took me right to the line
of code where I need to change.

00:44:02.090 --> 00:44:02.960
Isn't that handy?

00:44:09.110 --> 00:44:10.980
So we're going to comment these out.

00:44:11.210 --> 00:44:15.300
Luckily, you know, just for this demo,
I had the corrected version here.

00:44:15.340 --> 00:44:17.510
And let's rerun this.

00:44:24.070 --> 00:44:29.570
You'll see, just with that one fix,
it's dramatically faster.

00:44:29.940 --> 00:44:33.460
And the thing is,
this is a little bit of a cooked demo,

00:44:33.470 --> 00:44:38.440
but I've worked on servers
for quite a long time,

00:44:38.440 --> 00:44:41.600
on optimizing Java and
other applications.

00:44:41.600 --> 00:44:46.480
And you'd be amazed at how many
things you find that are this easy.

00:44:46.520 --> 00:44:50.460
And it's just a matter of
profiling your program,

00:44:50.500 --> 00:44:53.380
find the most significant problem,
fix it, profile it,

00:44:53.380 --> 00:44:55.920
and just iterate over and over like that.

00:44:55.950 --> 00:45:00.100
And before you know it,
you'll have your app running two, three,

00:45:00.100 --> 00:45:02.820
even 10 times faster.

00:45:02.840 --> 00:45:04.310
Thank you.

00:45:09.730 --> 00:45:12.160
At this point, let's go back.

00:45:12.160 --> 00:45:13.500
I'm going to hand it over to Josh.

00:45:13.500 --> 00:45:17.950
Thanks, Christy.

00:45:22.060 --> 00:45:26.570
So to show you a little bit
more about Shark for Java,

00:45:26.570 --> 00:45:30.570
we wrote a little demo application
that generates fractals.

00:45:31.170 --> 00:45:36.140
And so this application,
it will generate a fractal data for you,

00:45:36.190 --> 00:45:38.460
and then it will display to the screen.

00:45:38.500 --> 00:45:41.560
And it's displayed as a height map,
which is pretty much like if you looked

00:45:41.560 --> 00:45:44.350
out of a plane down at the ground,
what you would see.

00:45:44.350 --> 00:45:48.680
And it just repeats this process as
many times and as fast as it can.

00:45:48.680 --> 00:45:54.010
And we're going to use Shark to
determine where the hotspots are in it.

00:45:54.470 --> 00:45:57.440
So let's go ahead and actually
just jump right into the demo.

00:45:57.440 --> 00:46:00.840
So Kevin, thank you.

00:46:00.840 --> 00:46:04.310
All right,
let's just close out Balancing here.

00:46:10.060 --> 00:46:14.310
And if you go to your demos folder,
you can find the Fractal

00:46:14.500 --> 00:46:16.830
Performance folder under that.

00:46:16.870 --> 00:46:19.780
And then we're just going
to load up demo number one.

00:46:20.300 --> 00:46:29.500
[Transcript missing]

00:46:30.300 --> 00:46:35.300
and As you can see right off the bat,
this application is pretty slow.

00:46:35.300 --> 00:46:38.780
I mean, in the upper left hand corner
you'll see the number of fractals

00:46:38.870 --> 00:46:40.300
per minute that it's generating.

00:46:40.300 --> 00:46:44.480
And I've also added some more timing
information into this application,

00:46:44.480 --> 00:46:46.810
so if you hit the spacebar once,

00:46:46.990 --> 00:46:50.090
The next time it renders a frame,
it'll show you the amount

00:46:50.090 --> 00:46:53.530
of time that it's spending
in rendering and generation.

00:46:53.530 --> 00:46:58.550
And right now you can see that we're
spending about 3.2 seconds in rendering

00:46:59.060 --> 00:47:01.600
and almost 2 seconds in the generation.

00:47:01.600 --> 00:47:04.120
The problem is, you know,
we don't really know exactly

00:47:04.120 --> 00:47:05.900
where this time is being spent.

00:47:05.930 --> 00:47:08.320
So this is a great use for Shark here.

00:47:09.200 --> 00:47:11.420
So let's go ahead and
bring up Shark again.

00:47:11.420 --> 00:47:15.970
And the first thing I want to do
is I want to go to the preferences,

00:47:15.970 --> 00:47:21.220
make sure that the source code for
this application is in the search path,

00:47:21.220 --> 00:47:25.930
which we already have set up here,
but you'll need to add that.

00:47:26.980 --> 00:47:30.710
And what I want to show
first is an allocation trace.

00:47:31.020 --> 00:47:33.950
So let's go to Java, Alloc Trace.

00:47:34.220 --> 00:47:37.820
Make sure that application
number one is selected.

00:47:37.840 --> 00:47:40.080
And I want to take a really quick trace.

00:47:40.130 --> 00:47:43.960
I want to kind of get a sample at
the beginning of that loop when it's

00:47:43.960 --> 00:47:45.570
starting to generate the fractal.

00:47:45.620 --> 00:47:49.020
So I'm going to wait for it to
start rendering a new screen,

00:47:49.050 --> 00:47:50.640
a new shot.

00:47:51.380 --> 00:47:53.060
and take a really quick sample.

00:47:53.080 --> 00:47:55.770
And now it's generated some
information for me that we're not

00:47:55.790 --> 00:47:56.900
gonna worry about the profile here.

00:47:56.900 --> 00:47:59.930
What's really interesting
is if we go to the chart,

00:48:00.130 --> 00:48:03.510
So if you click on the chart,
we can actually zoom in on this,

00:48:03.510 --> 00:48:05.910
from this little zoom
bar right down here.

00:48:05.990 --> 00:48:08.840
And you'll start to see
this repeating pattern.

00:48:08.840 --> 00:48:11.680
And it's kind of the
heartbeat of the application.

00:48:11.680 --> 00:48:15.530
And this fractal, in particular,
is generated recursively.

00:48:15.530 --> 00:48:18.680
And what happens is,
for every section of the fractal,

00:48:18.770 --> 00:48:20.710
we subcalculate four new sections.

00:48:21.040 --> 00:48:24.150
And you can see that from all
these different peaks here.

00:48:24.150 --> 00:48:26.970
Every peak has four more
peaks sprouting from it.

00:48:27.050 --> 00:48:30.070
And that's actually what we're doing.

00:48:30.100 --> 00:48:32.360
And that's actually the
recursive algorithm,

00:48:32.380 --> 00:48:33.660
the recursive method.

00:48:33.680 --> 00:48:35.700
So let's go ahead and click
on one of these peaks.

00:48:35.700 --> 00:48:38.550
And over on the right,
you'll see a backtrace

00:48:38.670 --> 00:48:40.380
of all that information.

00:48:40.390 --> 00:48:44.500
And you can see here that we're
calling that recursive algorithm.

00:48:44.510 --> 00:48:51.490
So let's go ahead and look in that
code and see what the heck we're doing.

00:48:52.500 --> 00:48:56.680
Well, you see it pops us right
to this allocation here,

00:48:56.680 --> 00:48:58.150
where we're allocating a point object.

00:48:58.270 --> 00:49:02.180
And saying that 50% of the
allocation is due to that.

00:49:02.180 --> 00:49:03.940
And let's go down a little bit more.

00:49:03.940 --> 00:49:04.580
We got some more.

00:49:04.580 --> 00:49:05.490
We have another one.

00:49:05.490 --> 00:49:07.600
Okay,
we're allocating another point object.

00:49:07.630 --> 00:49:11.100
And we're calculating
all these point objects.

00:49:11.160 --> 00:49:14.220
And what it's doing is we're
calculating those so we can actually

00:49:14.220 --> 00:49:18.050
call the recursive method with these
different subsections of the fractals.

00:49:18.890 --> 00:49:22.420
Well, we're not really using much of
the point object in this case.

00:49:22.420 --> 00:49:26.000
All we're using is to define
these corners of these squares.

00:49:26.020 --> 00:49:29.780
Instead of using a point object,
we can actually use integers instead.

00:49:29.780 --> 00:49:32.600
And avoid all this allocation.

00:49:32.600 --> 00:49:35.600
So let's go ahead and close up this demo.

00:49:37.900 --> 00:49:45.400
[Transcript missing]

00:49:49.340 --> 00:49:52.420
and go to Fractal
Performance in folder 2.

00:49:52.450 --> 00:49:56.590
And let's open up 2.xcode,
which is the second demo.

00:49:58.410 --> 00:50:03.640
and let's go ahead and
look at Float Fractal.

00:50:04.150 --> 00:50:11.770
www.virtuals.com/java/src/java/

00:50:13.200 --> 00:50:30.000
[Transcript missing]

00:50:38.600 --> 00:50:42.000
Okay,
so application's still a little bit slow.

00:50:42.010 --> 00:50:43.880
We have increased the
frame rate a little bit.

00:50:44.140 --> 00:50:47.900
If we hit the space bar again once,
we'll see the times again.

00:50:47.900 --> 00:50:52.040
And lo and behold,
time to generate has now reduced from

00:50:52.400 --> 00:50:55.540
almost two seconds to 123 milliseconds.

00:50:55.540 --> 00:50:57.260
So that's a huge improvement.

00:50:57.260 --> 00:51:00.100
But we're still spending a lot
of time in the rendering code.

00:51:00.110 --> 00:51:02.440
We're still spending,
that's where the majority

00:51:02.440 --> 00:51:03.920
of our time is being spent.

00:51:03.920 --> 00:51:08.580
So we're going to use Shark again
now to investigate what's going on.

00:51:08.600 --> 00:51:13.670
So I'm going to go ahead
and bring up Shark again.

00:51:13.950 --> 00:51:17.030
Since this is a different demo,
I want to add the search path

00:51:17.260 --> 00:51:19.630
for this application in here.

00:51:19.710 --> 00:51:24.220
So let's go ahead and do that.

00:51:24.250 --> 00:51:29.000
Going to go to desktop, to the demos,
fractal performance.

00:51:30.430 --> 00:51:37.820
Demo 2, and I'm going to remove Demo
1 so it doesn't get confused.

00:51:39.290 --> 00:51:41.400
All right, so instead of doing an
allocation trace this time,

00:51:41.400 --> 00:51:43.770
let's do a time trace.

00:51:43.870 --> 00:51:48.900
So go to Java Time Trace,
make sure Process 2 is selected.

00:51:48.990 --> 00:51:54.000
And when we do this time trace,
we want to get a good idea,

00:51:54.030 --> 00:51:54.760
a good sample.

00:51:54.760 --> 00:51:57.740
So we're going to let this actually
generate a couple of fractals.

00:51:57.790 --> 00:52:00.960
And make sure it displays to the screen,
goes to the generation code,

00:52:01.090 --> 00:52:03.830
and displays again.

00:52:04.020 --> 00:52:07.260
As it's doing that,
it's gone through about two right now.

00:52:07.260 --> 00:52:09.530
I'll go ahead and stop.

00:52:09.850 --> 00:52:12.730
And now I'll bring up the
profiling information.

00:52:12.760 --> 00:52:19.390
And the top of the chart here is
OS X surface data finish lazy drawing.

00:52:20.000 --> 00:52:32.700
[Transcript missing]

00:52:33.500 --> 00:52:54.200
[Transcript missing]

00:52:54.540 --> 00:52:57.900
So if we double click on this,
it'll bring us to the code.

00:52:57.900 --> 00:53:00.120
We can see exactly what we're doing.

00:53:00.240 --> 00:53:02.200
Well, in the painting code,
what we've done is we've

00:53:02.200 --> 00:53:03.640
generated this fractal.

00:53:03.680 --> 00:53:07.140
And what we want to do is when
we're displaying it to the screen,

00:53:07.140 --> 00:53:10.160
we're generating a color
depending on the height.

00:53:10.190 --> 00:53:14.110
And then we're drawing a
pixel in that position.

00:53:14.520 --> 00:53:18.560
But as you can see here,
we're creating a new color.

00:53:18.620 --> 00:53:21.500
We're generating this color
and filling every single pixel,

00:53:21.500 --> 00:53:23.300
which is extremely slow.

00:53:23.320 --> 00:53:25.740
In fact,
this is just the wrong way to do it.

00:53:25.780 --> 00:53:28.380
There's something called
a writable raster,

00:53:28.380 --> 00:53:31.340
which is a better way of doing this,
where you can give it all of

00:53:31.340 --> 00:53:35.420
your color information for
all of the pixels at once.

00:53:35.460 --> 00:53:38.220
And for the third demo,
this is actually what we've done.

00:53:38.220 --> 00:53:40.700
So I'm gonna go ahead and close this.

00:53:43.320 --> 00:53:54.890
Go back to the Fractal
Performance Demo 3.x code.

00:53:54.920 --> 00:54:01.850
This code is in the Fractal Viewer.

00:54:01.850 --> 00:54:01.850
Double click on that.

00:54:01.850 --> 00:54:01.850
Searching for WWDC.

00:54:04.700 --> 00:54:08.430
Right here, the comment, as it says,
is use a writable raster to draw the

00:54:08.430 --> 00:54:12.010
pixel data rather than creating a
new color and painting each point.

00:54:12.130 --> 00:54:14.280
So what we've done now is
created this huge array with

00:54:14.280 --> 00:54:16.080
all the color information,
and we're just going to pass

00:54:16.150 --> 00:54:18.100
it off to this writable raster.

00:54:18.130 --> 00:54:19.730
And it's in core.

00:54:19.800 --> 00:54:22.580
It's optimized for this type of painting.

00:54:22.750 --> 00:54:25.300
So let's see what kind of
performance increase we get.

00:54:25.300 --> 00:54:28.530
So if you go ahead and hit Build and Go.

00:54:30.560 --> 00:54:31.550
Here we go.

00:54:31.590 --> 00:54:35.540
Now we're getting about
250 fractals per minute.

00:54:35.540 --> 00:54:38.610
And if you hit the space bar again,
you'll see the time difference now.

00:54:38.730 --> 00:54:41.530
Instead of spending three
seconds in the rendering now,

00:54:41.700 --> 00:54:44.520
we're spending only 100 milliseconds.

00:54:44.530 --> 00:54:49.820
So at this particular time, you know,
our demo is sufficiently performant.

00:54:49.820 --> 00:54:51.320
We don't need to move on.

00:54:51.340 --> 00:54:53.920
But the point of the matter is that

00:54:54.790 --> 00:54:57.750
Analyzing your application and
improving the performance is

00:54:57.750 --> 00:55:00.040
a really iterative process.

00:55:00.040 --> 00:55:03.300
And using Shark is a really key
part of that and can get you

00:55:03.300 --> 00:55:06.460
this information even quicker.

00:55:06.460 --> 00:55:08.900
So can we go back to the slides now?

00:55:11.350 --> 00:55:16.750
So for more information,
you can check out the website and sample

00:55:16.820 --> 00:55:22.170
code at developerapple.com/wwdc2005.

00:55:24.920 --> 00:55:27.450
and there's some other
related sessions as well.

00:55:27.480 --> 00:55:31.160
The Maximizing Java Performance,
which is in the lab, right after this,

00:55:31.160 --> 00:55:35.020
will be there to answer your questions
and help you out with your applications.

00:55:35.040 --> 00:55:39.340
And then there's also the Java and
Web Objects Feedback Forum.
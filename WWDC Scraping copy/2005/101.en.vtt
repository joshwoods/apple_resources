WEBVTT

00:00:04.520 --> 00:00:05.400
Good morning.

00:00:05.400 --> 00:00:06.370
I'm Dominic Giampaolo.

00:00:06.410 --> 00:00:09.630
I'm a Spotlight weenie and
member of the Spotlight team.

00:00:09.630 --> 00:00:13.400
And today we're here to talk
about Spotlight importers.

00:00:13.610 --> 00:00:15.400
What are we going to talk about?

00:00:15.610 --> 00:00:17.400
First off, what is Spotlight?

00:00:17.400 --> 00:00:18.400
Well, of course you've all seen it.

00:00:18.400 --> 00:00:19.400
You've used it probably.

00:00:19.400 --> 00:00:21.400
You've seen the keynote presentation.

00:00:21.400 --> 00:00:24.750
But we're going to go into a
little bit more depth about the

00:00:24.860 --> 00:00:27.500
architecture and how it's put together.

00:00:27.700 --> 00:00:30.360
The next thing we're going to
talk about is importer background,

00:00:30.420 --> 00:00:32.160
what you need to know
to write an importer,

00:00:32.160 --> 00:00:35.980
the context in which importers run in,
and some other information

00:00:36.110 --> 00:00:36.820
about importers.

00:00:36.820 --> 00:00:39.340
Then, of course,
we're going to write an importer,

00:00:39.430 --> 00:00:41.300
since this is a hands-on session.

00:00:41.300 --> 00:00:45.950
And then we're going to talk a little bit
about some tips and tricks and debugging,

00:00:45.950 --> 00:00:48.400
performance,
things you need to know about

00:00:48.510 --> 00:00:50.830
importers once you've written one.

00:00:50.860 --> 00:00:54.360
Then we're going to talk
about advanced importers.

00:00:54.740 --> 00:00:58.620
Advanced importers are a little bit more
sophisticated in the things that they do,

00:00:58.620 --> 00:01:00.610
and that will be the second
importer that we write.

00:01:03.390 --> 00:01:05.200
The Spotlight architecture.

00:01:05.330 --> 00:01:06.570
What is Spotlight?

00:01:06.670 --> 00:01:10.480
Well, at the first level,
it's a system for storing, querying,

00:01:10.530 --> 00:01:13.340
and retrieving information about files.

00:01:13.340 --> 00:01:17.120
It's a kind of different lens or
a different view onto the files

00:01:17.120 --> 00:01:18.920
that you have on your hard disk.

00:01:18.930 --> 00:01:21.990
It's an alternate way to look at them.

00:01:22.070 --> 00:01:24.020
What is it made up of?

00:01:24.080 --> 00:01:26.160
Well, at the center, you have a server.

00:01:26.160 --> 00:01:29.690
The server centrally
orchestrates everything.

00:01:29.770 --> 00:01:32.680
There's some daemons that run
on behalf of the server and do

00:01:32.680 --> 00:01:35.360
work for it and help it out.

00:01:35.410 --> 00:01:38.720
The part that we're here to talk
about today are the importers.

00:01:38.810 --> 00:01:41.800
Importers are probably the most
crucial part of the Spotlight system,

00:01:41.800 --> 00:01:44.900
because that's how we get
metadata into the system.

00:01:45.100 --> 00:01:48.390
Spotlight lives and dies by the
quality of the metadata that we have.

00:01:48.490 --> 00:01:51.180
If we don't have good metadata,
we don't have anything.

00:01:51.180 --> 00:01:52.880
We have searching by file names.

00:01:53.000 --> 00:01:56.480
So importers are a very
crucial part of the system.

00:01:57.000 --> 00:01:59.430
And of course,
there's a client API that applications

00:01:59.440 --> 00:02:03.290
use to query the system and to
find out information about files.

00:02:03.340 --> 00:02:06.180
But we're not going to be talking
about that at this session today.

00:02:06.180 --> 00:02:09.230
That will be later on this
afternoon in Javier and

00:02:09.230 --> 00:02:11.250
Vince DiMarco's talk at 2 o'clock.

00:02:13.320 --> 00:02:15.340
So why do you care?

00:02:15.510 --> 00:02:17.610
Spotlight makes your
documents easier to find.

00:02:17.730 --> 00:02:20.380
So when someone remembers
something about their file,

00:02:20.440 --> 00:02:23.690
oh yeah,
I entered this label or this track name,

00:02:23.690 --> 00:02:27.540
they can find it, because Spotlight can
index that information.

00:02:27.670 --> 00:02:30.140
It makes your documents
display more richly.

00:02:30.260 --> 00:02:33.160
So you don't have a display
that's limited to just the name

00:02:33.160 --> 00:02:36.550
and size and last modified time,
which really is irrelevant

00:02:36.700 --> 00:02:37.880
for a lot of documents.

00:02:37.970 --> 00:02:40.760
You can have things such as
the title or the authors or the

00:02:40.760 --> 00:02:45.080
duration of a piece of music,
a lot more rich information about

00:02:45.110 --> 00:02:49.290
it that will help the users to
organize things and to remember

00:02:49.290 --> 00:02:51.600
things about the documents.

00:02:51.650 --> 00:02:59.140
A big point is that it doesn't require
any code changes in your application.

00:02:59.140 --> 00:03:00.490
This is a big point.

00:03:00.500 --> 00:03:02.790
If I got up here and said, well,
Spotlight's going to take you

00:03:02.790 --> 00:03:06.310
six months to work into your
application and to become a part of,

00:03:06.340 --> 00:03:09.480
you'd all take me out
back and beat me up.

00:03:09.480 --> 00:03:10.520
You all have schedules.

00:03:10.520 --> 00:03:11.620
Releases to meet.

00:03:11.700 --> 00:03:13.330
You don't have a lot of extra time.

00:03:13.450 --> 00:03:16.630
What I'm here to tell you is, in fact,
that to be part of the Spotlight system

00:03:17.000 --> 00:03:19.950
doesn't require significant changes,
or doesn't require any

00:03:19.950 --> 00:03:22.770
changes in your application,
doesn't require significant

00:03:22.850 --> 00:03:24.770
investment of effort either.

00:03:24.840 --> 00:03:28.020
It also makes it easier to share
data with other applications.

00:03:28.110 --> 00:03:31.450
So what's good about this is that instead
of having every app have to know about

00:03:31.450 --> 00:03:35.070
every other app's file format to get
just some little piece of information,

00:03:35.070 --> 00:03:39.480
there's a clean and consistent way to
get at that information about files,

00:03:39.520 --> 00:03:40.520
the metadata about files.

00:03:40.520 --> 00:03:43.950
through the spotlight APIs.

00:03:44.460 --> 00:03:45.700
So, let's get graphical.

00:03:45.700 --> 00:03:47.300
What does it look like?

00:03:47.330 --> 00:03:50.630
At the center,
you have the Spotlight server.

00:03:50.680 --> 00:03:54.400
On the left, you have documents,
which are created by applications.

00:03:54.400 --> 00:03:58.470
When those documents are modified,
importers run to extract the information

00:03:58.470 --> 00:04:01.030
and pull it into the Spotlight server.

00:04:01.200 --> 00:04:04.700
The Spotlight server then puts
that information into either the

00:04:04.700 --> 00:04:08.080
metadata store or the content
index store as appropriate.

00:04:08.080 --> 00:04:10.600
We have two separate stores
because there's different

00:04:10.670 --> 00:04:12.240
ways of indexing information.

00:04:12.240 --> 00:04:15.980
The metadata attributes
are stored in one way,

00:04:15.980 --> 00:04:19.800
and the content index is
stored in a format that's

00:04:19.830 --> 00:04:22.540
appropriate for searching it.

00:04:22.570 --> 00:04:25.160
It's more sophisticated
for that kind of search.

00:04:26.020 --> 00:04:28.690
And then on the right-hand side,
you have applications that talk and

00:04:28.800 --> 00:04:30.600
communicate through the Spotlight API.

00:04:31.680 --> 00:04:35.410
So, let's step through it.

00:04:35.490 --> 00:04:38.590
What happens when you write a file?

00:04:38.590 --> 00:04:41.000
Again, at the center,
we have the Spotlight server,

00:04:41.000 --> 00:04:44.340
which is always running in the
background and keeping an eye on things.

00:04:44.340 --> 00:04:48.340
An application, that's you guys,
comes along, writes a document.

00:04:48.340 --> 00:04:52.510
That document gets modified,
the file is closed, the kernel says,

00:04:52.540 --> 00:04:56.590
boom, hey, that file was modified
to the Spotlight server.

00:04:56.590 --> 00:04:59.350
Spotlight server, in turn,
runs an importer.

00:04:59.350 --> 00:05:00.430
That's you guys.

00:05:01.680 --> 00:05:04.710
The importer takes the
information out of the file,

00:05:04.870 --> 00:05:08.090
pulls it into the Spotlight server,
which, of course,

00:05:08.260 --> 00:05:12.230
updates the data stores, and in turn,
sends updates to applications

00:05:12.230 --> 00:05:16.270
that have live queries or are
asking information about that file.

00:05:16.270 --> 00:05:18.590
So, that's kind of, you know,
at a high level,

00:05:18.590 --> 00:05:20.350
how the Spotlight system works.

00:05:22.580 --> 00:05:25.600
What are the concepts behind Spotlight?

00:05:25.660 --> 00:05:28.280
What we're here to talk
about today are importers.

00:05:28.350 --> 00:05:33.250
Importers are plug-ins that are
loaded by the Spotlight system.

00:05:41.100 --> 00:05:45.980
Importers are plug-ins that are loaded
by the Spotlight system and publish

00:05:46.040 --> 00:05:48.600
metadata from a particular file format.

00:05:48.600 --> 00:05:51.020
So an importer handles
some set of file formats,

00:05:51.090 --> 00:05:53.100
knows how to take data
that's in the file,

00:05:53.100 --> 00:05:58.180
metadata, pull it out,
and pass it back to the Spotlight server.

00:05:58.560 --> 00:05:59.900
There's the MD Item.

00:06:00.000 --> 00:06:01.360
Items represent files.

00:06:01.600 --> 00:06:04.150
All items in the Spotlight
system are represented by

00:06:04.150 --> 00:06:06.400
files or correspond to a file.

00:06:06.400 --> 00:06:11.290
Items are made up of attributes,
and attributes are a name,

00:06:11.290 --> 00:06:13.240
a type of data, and a value.

00:06:13.240 --> 00:06:16.240
The value is the data that's
associated with the name.

00:06:18.350 --> 00:06:21.530
There's also a MD Query API,
which is a way to,

00:06:21.630 --> 00:06:22.860
that's how you find items.

00:06:22.880 --> 00:06:25.290
Now, we're not going to talk
about the last two things.

00:06:25.310 --> 00:06:27.350
Again,
that's the talk later this afternoon.

00:06:27.350 --> 00:06:29.050
We're going to focus on importers.

00:06:31.510 --> 00:06:33.530
So, how can you integrate with Spotlight?

00:06:33.690 --> 00:06:35.980
The first level,
if you work with an existing

00:06:35.980 --> 00:06:39.350
file format that already is
supported by the Spotlight system,

00:06:39.400 --> 00:06:42.660
such as JPEG or MP3 or a
variety of other formats,

00:06:42.700 --> 00:06:45.400
put useful metadata into your documents.

00:06:45.400 --> 00:06:46.400
This is a big thing.

00:06:46.400 --> 00:06:49.170
A lot of file formats, like I said,
such as JPEG,

00:06:49.170 --> 00:06:51.380
already have support for metadata.

00:06:51.400 --> 00:06:55.400
And if your app allows the
users to edit that information,

00:06:55.400 --> 00:06:57.400
you're already part of
the Spotlight system.

00:06:57.400 --> 00:07:02.210
You're enabling people to
work with metadata and to be a

00:07:02.290 --> 00:07:05.120
part of the Spotlight system.

00:07:05.350 --> 00:07:10.700
The next level,
if you have a custom file format,

00:07:10.700 --> 00:07:10.700
then write an importer.

00:07:11.320 --> 00:07:15.200
Other things that you can do to help,
don't type files incorrectly.

00:07:15.200 --> 00:07:17.800
We've seen a few cases where
people say they'll go and

00:07:17.800 --> 00:07:22.210
write out this very nice 10,
20, 40, 50 megabyte file of binary

00:07:22.220 --> 00:07:23.890
data and say that it's text.

00:07:23.960 --> 00:07:27.750
That really hurts us because it can
take quite a while to figure out that

00:07:27.850 --> 00:07:32.130
this isn't one of the 20 or 30 different
character set and codings that are out

00:07:32.130 --> 00:07:34.150
there and we can waste a lot of time.

00:07:34.180 --> 00:07:37.000
So make sure that you
type your files correctly.

00:07:37.010 --> 00:07:41.040
If it's actually binary data,
don't type it as text, please.

00:07:41.040 --> 00:07:43.930
Get your temp files where
Spotlight won't index them,

00:07:43.970 --> 00:07:44.990
such as in /temp.

00:07:45.100 --> 00:07:48.140
If you don't already do that,
that's a good place to put things.

00:07:48.140 --> 00:07:51.530
Or if you want to,
put them into a directory whose

00:07:51.530 --> 00:07:53.860
name ends in .noindex or .build.

00:07:53.990 --> 00:07:57.630
This way Spotlight will see that
and not index any of the files

00:07:57.630 --> 00:07:59.240
that are in that subdirectory.

00:07:59.240 --> 00:08:02.130
So this is a good place to put
temporary files that you don't

00:08:02.130 --> 00:08:03.310
want Spotlight messing with.

00:08:05.210 --> 00:08:08.100
Now, I'm going to do a quick little demo.

00:08:08.100 --> 00:08:10.410
Can we switch to demo one?

00:08:11.280 --> 00:08:17.140
Okay, so I'm going to do a search here
for "doc." And you see this pulls

00:08:17.140 --> 00:08:20.780
up a whole wide variety of things,
and it looks pretty nice, right?

00:08:20.780 --> 00:08:25.190
There's some system preferences,
there's folders, there's images,

00:08:25.340 --> 00:08:29.950
and if I click on an image,
there's some information stored for it.

00:08:29.950 --> 00:08:33.530
Oh, not for that one, for a TIFF file.

00:08:36.070 --> 00:08:37.800
I can't do that actually.

00:08:37.800 --> 00:08:39.990
So here we can see the
dimensions and so on.

00:08:40.000 --> 00:08:45.030
There's PDF documents which
have lots of metadata title.

00:08:45.100 --> 00:08:47.150
And you might say, "Wow,
that's really great.

00:08:47.180 --> 00:08:47.810
Look at all that.

00:08:47.880 --> 00:08:50.390
They probably hard-coded
all that stuff." Well,

00:08:50.440 --> 00:08:56.920
what happens if I was to search for,
let's see, 8, 6, 7, 5, 3, 0, 9.

00:08:56.920 --> 00:08:57.680
Okay.

00:08:57.680 --> 00:08:58.500
What do we get here?

00:08:58.500 --> 00:08:59.250
A few of you got that.

00:08:59.250 --> 00:09:00.200
All right.

00:09:00.210 --> 00:09:02.220
This is file badbug.dbg.

00:09:02.240 --> 00:09:03.610
Well, what's that?

00:09:03.610 --> 00:09:05.160
What's a .dbg file?

00:09:05.160 --> 00:09:09.330
Aside from also being my log-in,
it's a little file format that I invented

00:09:09.330 --> 00:09:14.180
for the purposes of this demo where
I record some information about bugs

00:09:14.180 --> 00:09:16.660
that get assigned to me at Apple.

00:09:16.660 --> 00:09:20.120
And so if I click on the info icon,
we can see, oh, debug session name.

00:09:20.120 --> 00:09:22.290
This is about Jenny's file system woes.

00:09:22.290 --> 00:09:23.440
And the radar number.

00:09:23.440 --> 00:09:25.660
Radar is the name of
the bug system at Apple,

00:09:25.660 --> 00:09:27.670
8, 6, 7, 5, 3, 0, 9.

00:09:27.670 --> 00:09:30.160
And there's some keywords
associated with it.

00:09:30.160 --> 00:09:33.420
And what's cool about this is that
this file is seamlessly integrated

00:09:33.460 --> 00:09:35.680
as part of the Spotlight system.

00:09:35.680 --> 00:09:39.850
If I was to do a get info
and pull it up into Finder,

00:09:39.850 --> 00:09:45.120
Finder doesn't know anything about
.dbg files and nor does Spotlight.

00:09:45.120 --> 00:09:48.020
But because of the way I've written
the importer for this file format,

00:09:48.020 --> 00:09:51.850
which is very simple file format,
but the way I've written the importer

00:09:51.920 --> 00:09:56.640
gets my data integrated in a very
clean way into the rest of the system.

00:09:56.640 --> 00:09:58.690
And this is what we're going to
show you how to do later today when

00:09:58.700 --> 00:10:00.680
we go through an advanced importer.

00:10:00.680 --> 00:10:01.510
Okay.

00:10:01.510 --> 00:10:03.670
Back to the slides.

00:10:04.920 --> 00:10:05.800
Slides?

00:10:05.800 --> 00:10:07.560
Thanks.

00:10:07.650 --> 00:10:10.540
So,
Apple ships a whole bunch of importers

00:10:10.550 --> 00:10:15.780
for quite a variety of file formats,
everything from JPEG and Photoshop,

00:10:15.950 --> 00:10:17.840
QuickTime, of course, PDF.

00:10:17.840 --> 00:10:20.870
If you work with these file formats,
your job is done.

00:10:20.870 --> 00:10:22.080
You guys can get up and leave.

00:10:22.160 --> 00:10:23.200
No, stick around.

00:10:24.560 --> 00:10:28.230
There's not much that you have to do,
actually, except for, again,

00:10:28.230 --> 00:10:30.720
putting useful metadata in the documents.

00:10:30.720 --> 00:10:34.470
But if you don't work with those file
formats or you have a custom file

00:10:34.470 --> 00:10:38.240
format in addition to some of those,
then you have to write an importer,

00:10:38.240 --> 00:10:40.430
and that's what we're
going to talk about now.

00:10:41.810 --> 00:10:44.700
So, here's how we're going to do it.

00:10:44.730 --> 00:10:48.300
Some rules of the game,
then we'll go through a simple importer.

00:10:48.300 --> 00:10:51.320
We'll talk about performance,
tips and tricks in debugging,

00:10:51.410 --> 00:10:54.720
and then we'll move on to an
advanced importer that handles that

00:10:54.800 --> 00:10:57.570
.dbg file format I just showed you.

00:10:58.500 --> 00:11:00.330
Some basics.

00:11:00.380 --> 00:11:03.400
Importers need to publish
metadata that helps the user.

00:11:03.400 --> 00:11:04.820
That's what this is all about.

00:11:04.890 --> 00:11:07.530
A lot of times people hear
about Spotlight and they go,

00:11:07.530 --> 00:11:08.840
"Man, this is just great.

00:11:08.940 --> 00:11:13.040
I am gonna publish so many attributes,
you wouldn't believe it." That's

00:11:13.040 --> 00:11:15.070
a little bit too much excitement.

00:11:15.340 --> 00:11:19.060
What's better is to keep in mind you
want to publish things that are going

00:11:19.060 --> 00:11:21.620
to help the user find their document.

00:11:21.620 --> 00:11:24.270
That doesn't mean 75 attributes.

00:11:24.380 --> 00:11:28.140
You want to do things that are gonna
help display the--have--allow the

00:11:28.140 --> 00:11:31.300
document to display more richly.

00:11:31.300 --> 00:11:34.860
So keep that in mind,
keep that in forefront when

00:11:34.860 --> 00:11:39.720
you're making your choices about
what kind of metadata to publish.

00:11:39.720 --> 00:11:43.950
Importers should not use the
Spotlight system to store large blobs

00:11:44.060 --> 00:11:46.210
of binary data or icon previews.

00:11:46.350 --> 00:11:48.320
That's really not what it's about.

00:11:48.340 --> 00:11:51.390
Again, Spotlight is about
searching user metadata.

00:11:51.910 --> 00:11:55.170
And what that comes down to is that
too much noise can confuse the user.

00:11:55.190 --> 00:11:58.930
If your documents show up for pretty
much anything that anyone types,

00:11:58.930 --> 00:12:01.800
because you have attributes
that match everything,

00:12:01.800 --> 00:12:03.580
basically, that's not helpful.

00:12:03.680 --> 00:12:05.560
That doesn't help the
user find their documents.

00:12:05.600 --> 00:12:07.320
That just basically spams them.

00:12:07.320 --> 00:12:11.470
So you want to keep it so that
you have relevant metadata for

00:12:11.470 --> 00:12:13.620
the documents of your type.

00:12:14.170 --> 00:12:17.230
Another aspect is that there's
no user interface to an importer.

00:12:17.300 --> 00:12:20.900
In fact, we disallow it in the context
which an importer is run.

00:12:20.950 --> 00:12:22.880
So you can't pop up a
dialog box that says,

00:12:23.000 --> 00:12:25.200
"Do you want me to publish this
attribute or this attribute?"

00:12:25.350 --> 00:12:32.230
You have to keep everything to be
run silently in the background.

00:12:33.600 --> 00:12:35.060
UTI types.

00:12:35.060 --> 00:12:37.130
This is something that not a
lot of people are familiar with.

00:12:37.190 --> 00:12:40.500
It was in a system that was
introduced in the Panther time frame,

00:12:40.520 --> 00:12:43.000
the Uniform Type Identification System.

00:12:43.000 --> 00:12:47.360
And it's a pretty neat way to
manage type information about files.

00:12:47.360 --> 00:12:54.170
The file name or type,
or file name extension or type

00:12:54.170 --> 00:12:54.170
code determine the file type.

00:12:54.580 --> 00:12:58.680
For any UTI type,
there's only going to be one importer.

00:12:58.730 --> 00:13:02.830
One importer, however,
can handle a variety of UTI types,

00:13:02.830 --> 00:13:07.310
such as our image importer,
which can handle JPEG, TIFF, Photoshop,

00:13:07.310 --> 00:13:08.510
and so on.

00:13:09.020 --> 00:13:11.430
You have to get your
UTI declarations right.

00:13:11.450 --> 00:13:14.640
This is probably the most difficult
part of writing an importer,

00:13:14.730 --> 00:13:16.790
and that's something we're
going to spend a fair bit of

00:13:16.790 --> 00:13:19.580
time on in the coming slides.

00:13:20.620 --> 00:13:21.630
Attributes.

00:13:21.630 --> 00:13:22.790
Well, what are good attributes?

00:13:23.020 --> 00:13:24.940
Things that, again,
the user will associate

00:13:24.940 --> 00:13:25.540
with the document.

00:13:25.540 --> 00:13:30.540
If the user actually bothered to
type in some text for a document,

00:13:30.540 --> 00:13:33.750
then that's probably something
that's a candidate for being

00:13:33.750 --> 00:13:35.410
published as an attribute.

00:13:35.970 --> 00:13:42.550
things like the copyright, the title,
track names, layer names in documents.

00:13:42.650 --> 00:13:45.140
Text content, however,
is a special attribute.

00:13:45.140 --> 00:13:48.380
If you have a file format where,
for example,

00:13:48.380 --> 00:13:53.270
you have a notes field or some
other sort of large body of text,

00:13:53.350 --> 00:13:58.400
that's probably not appropriate to be
published as an individual attribute,

00:13:58.400 --> 00:14:03.170
but it's more likely to be published
as a KMDItemTextContent attribute,

00:14:03.170 --> 00:14:08.030
which is a larger body of text that gets
indexed into the content index store.

00:14:09.980 --> 00:14:13.900
Bad attributes are things like
app-specific implementation details,

00:14:14.030 --> 00:14:14.980
window position.

00:14:15.080 --> 00:14:19.990
People don't search for that window that
I put at x equals 572 and y equals 379.

00:14:20.000 --> 00:14:23.000
That's useful to you,
but that doesn't belong

00:14:23.190 --> 00:14:25.130
in the Spotlight system.

00:14:26.060 --> 00:14:28.890
Here are some attributes
that we have predefined.

00:14:28.900 --> 00:14:31.910
There's some general attributes
such as the KMDItemTitle,

00:14:32.020 --> 00:14:33.800
the authors, and so on.

00:14:33.870 --> 00:14:36.900
We have type-specific
attributes for images,

00:14:36.900 --> 00:14:38.250
movies, audio.

00:14:38.470 --> 00:14:41.700
There's a full list of them
in the mditem.h header file,

00:14:41.700 --> 00:14:45.360
which is part of the metadata framework,
which lives inside of the

00:14:45.360 --> 00:14:46.900
core services framework.

00:14:46.900 --> 00:14:50.070
If you command double click on
any one of those names in Xcode,

00:14:50.070 --> 00:14:53.630
it'll pull up the header file and
there's a whole bunch of HeaderDoc in

00:14:53.630 --> 00:14:56.860
there that explains the types and
what the attributes are about.

00:14:59.300 --> 00:15:02.700
So, writing a basic importer,
what do you have to do?

00:15:02.730 --> 00:15:06.190
First off, you start with the metadata
importer template in Xcode.

00:15:06.360 --> 00:15:10.190
If you pull up a new
project window in Xcode,

00:15:10.210 --> 00:15:15.200
you go down to the Apple Plug-in
section and choose Metadata Importer.

00:15:15.200 --> 00:15:19.800
You edit the Info.plist file
that's in the template file.

00:15:20.200 --> 00:15:24.140
You have to write some code, of course,
and that's done in the GetMetadataForFile

00:15:24.140 --> 00:15:26.640
stub function that we provide.

00:15:26.760 --> 00:15:29.930
And then you install it,
and that's basically all there is to it.

00:15:30.070 --> 00:15:32.380
So let's go through the steps.

00:15:32.600 --> 00:15:35.260
In the Xcode Metadata Importer,
you see there's a standard

00:15:35.260 --> 00:15:39.300
Apple Plug-in section,
and there's Metadata Importer.

00:15:39.300 --> 00:15:43.690
You click Next, give it a name,
and you're ready to go.

00:15:44.380 --> 00:15:47.430
Then you have the Info.plist file.

00:15:47.490 --> 00:15:52.000
Here, if you need to define the
UTI type for your file format,

00:15:52.000 --> 00:15:58.260
you want to edit the UT exported
type declarations key and the

00:15:58.260 --> 00:15:59.340
information that's in there.

00:15:59.340 --> 00:16:02.640
And this is a fairly complicated step,
so we'll go through that

00:16:02.650 --> 00:16:04.340
when we write the importer.

00:16:04.430 --> 00:16:07.330
You have to make sure that your
UT type conforms to section is correct.

00:16:07.350 --> 00:16:13.330
That's, again, very important to get your
documents displayed properly

00:16:13.330 --> 00:16:14.290
in the rest of the system.

00:16:14.300 --> 00:16:18.640
Then, once the UTI is defined,
you need to bind that UTI type to

00:16:18.640 --> 00:16:21.300
the importer that you're writing.

00:16:21.300 --> 00:16:24.280
And that's done in the
LS Item Content Type section.

00:16:24.300 --> 00:16:29.300
Here is where you identify which
UTI types this importer will handle.

00:16:29.300 --> 00:16:34.290
And this is the binding that matches your
importer with a particular file type.

00:16:34.300 --> 00:16:37.950
So when the system sees a
file of that type modified,

00:16:37.950 --> 00:16:40.490
it knows which importer to call.

00:16:40.600 --> 00:16:44.520
Of course, there's a bunch of other
informational fields,

00:16:44.520 --> 00:16:49.340
name, size, name and version number and
so on of the importer bundle.

00:16:49.340 --> 00:16:50.490
You should edit those.

00:16:50.500 --> 00:16:54.700
However, one final warning,
don't just do a global search and replace

00:16:54.700 --> 00:16:57.620
of com.apple and just say com.mycompany.

00:16:57.620 --> 00:17:01.910
That will break the file
format and will not work.

00:17:03.600 --> 00:17:04.500
Implement the code.

00:17:04.500 --> 00:17:07.500
Well, I can't tell you how to do
this for your file format,

00:17:07.500 --> 00:17:10.610
but we have a stub function
called getMetadataForFile that

00:17:10.720 --> 00:17:14.440
wants to efficiently extract the
attributes from your file format

00:17:14.500 --> 00:17:23.430
and put them into a dictionary,
which that's a CFMutable dictionary

00:17:23.430 --> 00:17:24.680
that is used by the system to
then publish those attributes.

00:17:25.450 --> 00:17:28.970
The last thing you have to do
is to install your importer.

00:17:29.080 --> 00:17:31.700
There are a couple of locations
that you can install it.

00:17:31.810 --> 00:17:35.470
You can put it standalone
into /library-spotlight,

00:17:35.470 --> 00:17:37.960
and if you're just releasing
a separate importer by itself,

00:17:38.090 --> 00:17:41.140
that's probably the
most logical location.

00:17:41.250 --> 00:17:46.220
You can put it into the user's home
directory in /library-spotlight.

00:17:46.550 --> 00:17:48.950
Or you can put it in
with your application.

00:17:48.960 --> 00:17:51.100
You can have an app bundle importer.

00:17:51.100 --> 00:17:56.000
If you have foo.app,
you put it into the contents

00:17:56.010 --> 00:17:59.670
library Spotlight folder,
and you put the package or the

00:17:59.750 --> 00:18:03.270
bundle for your importer there,
and then the system will recognize

00:18:03.280 --> 00:18:05.020
that when your app is installed.

00:18:05.080 --> 00:18:06.110
There's a precedence.

00:18:06.300 --> 00:18:09.490
As I mentioned,
you can only have one importer

00:18:09.490 --> 00:18:11.580
for a particular UTI type.

00:18:11.610 --> 00:18:17.100
The precedence that we look at is
/library/users/home/directory/library/sp

00:18:17.240 --> 00:18:23.560
otlight/library/spotlight/system/library/
spotlight/app_bundled_importers.

00:18:24.360 --> 00:18:28.290
So,
let's go on and write a simple importer.

00:18:28.340 --> 00:18:30.180
Demo 1, please.

00:18:32.230 --> 00:18:35.620
As I said, in NextCode,
if you come up to here

00:18:35.620 --> 00:18:38.950
and choose a new project,
and don't worry,

00:18:38.950 --> 00:18:43.990
I'm not going to actually write
all the code by hand here alive.

00:18:44.980 --> 00:18:50.150
I scroll down,
and if I see Metadata Importer Template,

00:18:50.150 --> 00:18:56.750
and choose Next, and give it a name,
Fufu, what we get is a sort of

00:18:56.770 --> 00:19:00.450
standard template that has a
bunch of pre-populated files

00:19:00.460 --> 00:19:02.980
for a metadata importer.

00:19:02.980 --> 00:19:05.310
But, like I said,
we're not going to write the code

00:19:05.310 --> 00:19:06.900
completely from scratch here.

00:19:06.900 --> 00:19:11.680
We're going to start
with the IFF importer.

00:19:11.800 --> 00:19:13.600
demo.

00:19:13.600 --> 00:19:16.640
And the first thing that we do
is pull up the InfoP-List file.

00:19:16.700 --> 00:19:20.860
So this is going to be an importer
for the old Amiga IFF file format.

00:19:20.860 --> 00:19:25.210
I just happened to be browsing around
the developer sample code and found a

00:19:25.210 --> 00:19:29.730
piece of code that Alie Ozer wrote that
knows how to open up these image files.

00:19:29.730 --> 00:19:32.920
And I said, "Oh,
that's great because I don't have to

00:19:32.920 --> 00:19:37.460
do anything." And so I wanted to just
publish the little bit of metadata

00:19:37.460 --> 00:19:39.840
that I could out of these files.

00:19:39.940 --> 00:19:42.620
And so the easiest thing was
just the width and height for

00:19:42.620 --> 00:19:44.880
the purposes of this demo.

00:19:44.880 --> 00:19:49.170
So we're going to go through
the process of what it takes to

00:19:49.170 --> 00:19:53.940
write an importer for this Amiga
interchange file format picture.

00:19:53.940 --> 00:20:00.980
Now, the first thing that we do is the
UT exported type declaration section.

00:20:00.980 --> 00:20:05.850
We have to identify what the UTI type
name is and we're going to call it

00:20:05.850 --> 00:20:10.520
com_amiga_interchange-files.file-format.

00:20:10.520 --> 00:20:14.220
We give it a simple little description,
IFF image file format.

00:20:14.220 --> 00:20:16.520
And now we have to say
what it conforms to.

00:20:16.520 --> 00:20:18.910
And I'm going to talk about
this a little bit more later,

00:20:19.030 --> 00:20:22.660
but for now we can just say this is an
image and so it conforms to public.image

00:20:22.670 --> 00:20:25.900
and that takes care of everything for us.

00:20:25.900 --> 00:20:30.520
We have the OS type which is the
four character code which is unlikely

00:20:30.670 --> 00:20:35.900
to be assigned for this so I just
chose .IFF as a four character code.

00:20:35.900 --> 00:20:38.430
And then we have the file name
extensions which is the most likely

00:20:38.440 --> 00:20:39.440
one to be assigned for this file.

00:20:39.440 --> 00:20:41.200
So we're going to call this .IFF.

00:20:41.200 --> 00:20:46.830
We're going to call this .ILBM.

00:20:46.830 --> 00:20:46.830
And then we're going

00:20:47.320 --> 00:20:51.760
We've also chosen to define a
MIME type for this UTI because

00:20:51.760 --> 00:20:57.090
UTI subsumes MIME types for
character codes and everything,

00:20:57.110 --> 00:20:59.860
and we've called it image/iff.

00:20:59.950 --> 00:21:03.570
So that takes care of
defining the UTI for the

00:21:03.570 --> 00:21:07.770
com.amiga.interchange.file.format type.

00:21:08.150 --> 00:21:13.370
Now, as I said, you have to bind,
you have to connect that UTI type,

00:21:13.470 --> 00:21:15.810
which exists in the UTI space,
with this importer.

00:21:15.820 --> 00:21:19.450
And we've done that with
the LS item content types.

00:21:19.460 --> 00:21:22.070
This is saying,
this Info.plist is declaring

00:21:22.190 --> 00:21:25.390
that this importer,
his role is to handle the

00:21:25.510 --> 00:21:29.270
CommaMegaInterchange file format type.

00:21:29.280 --> 00:21:33.350
I've also edited some of the
other informational fields

00:21:33.350 --> 00:21:37.770
to give the name and so on,
but that's not so interesting.

00:21:40.080 --> 00:21:43.540
Now, in the code,
here we'll pull this up and make

00:21:43.540 --> 00:21:47.140
the window a little bit bigger,
we have the stub function,

00:21:47.140 --> 00:21:49.210
get metadata attributes from file.

00:21:49.240 --> 00:21:53.390
And there's a couple of
parameters that are passed to it,

00:21:53.390 --> 00:21:57.030
but I'm just going to call off to
the Objective-C code that Ali had

00:21:57.030 --> 00:22:02.120
written and that I've wrapped up in
a little stub function and to get it.

00:22:02.270 --> 00:22:04.850
So we have a CFString,
which is the path to the file,

00:22:04.850 --> 00:22:08.020
and an NSMutable dictionary,
which are the attributes.

00:22:08.360 --> 00:22:10.520
These are toll-free
bridged to each other.

00:22:10.520 --> 00:22:14.730
So we call off to the Objective-C code,
and I'll pull this up.

00:22:18.300 --> 00:22:22.080
We're not going to actually
go through the process of

00:22:22.080 --> 00:22:24.050
reading the IFF file format.

00:22:24.090 --> 00:22:26.190
I'll just talk about how it's called.

00:22:26.270 --> 00:22:30.460
So the first thing we do is we create
an NSData object and we say NSData data

00:22:30.460 --> 00:22:34.300
with contents of file and we pass
it the path that we were given.

00:22:34.300 --> 00:22:41.140
We failed to get the file because it
doesn't exist or there was some error.

00:22:41.140 --> 00:22:41.140
We just return false and we're done.

00:22:42.310 --> 00:22:46.900
Once we have the file data,
we have this IFF ILBM info

00:22:46.900 --> 00:22:49.200
structure named PIC.

00:22:49.320 --> 00:22:53.840
And we set up this parsing,
parse the file into this PIC structure,

00:22:53.840 --> 00:22:57.190
and that has the metadata that
we want to publish for this file,

00:22:57.190 --> 00:22:58.900
for the width and height.

00:22:58.900 --> 00:23:03.310
I've actually disabled the
code that decodes the image.

00:23:03.310 --> 00:23:03.310
Dominic Giampaolo

00:23:04.110 --> 00:23:05.890
So then the next thing
that we have to do,

00:23:05.930 --> 00:23:07.560
publish the width and height.

00:23:07.560 --> 00:23:12.330
This variable, pic.bmhd.w,
apologies for the wonderful

00:23:12.330 --> 00:23:16.110
naming conventions,
we create an NSNumber for

00:23:16.120 --> 00:23:18.640
that width variable.

00:23:18.640 --> 00:23:22.440
And then we say, for the key,
kmdItem pixelWidth,

00:23:22.440 --> 00:23:27.580
we're going to set the value num
into this attributes dictionary.

00:23:27.630 --> 00:23:30.560
And then we're going to do the
same thing for the pixel height.

00:23:30.750 --> 00:23:36.560
So for that key, we've created an
NSNumber pic.bmhd.h for the height,

00:23:36.560 --> 00:23:39.230
and we set the value
and push that into the,

00:23:39.230 --> 00:23:42.100
put that into the attributes dictionary.

00:23:42.100 --> 00:23:43.680
We're all done, and we return true.

00:23:43.680 --> 00:23:46.120
If you're actually looking
at this code on the DVD,

00:23:46.120 --> 00:23:49.280
there's two extra releases in
there that shouldn't be there,

00:23:49.280 --> 00:23:53.960
but I didn't make the change
before the DVD cutoff date.

00:23:53.960 --> 00:23:55.850
So that's, we have that.

00:23:55.930 --> 00:23:58.330
Let's build our importer.

00:23:58.900 --> 00:24:00.270
Okay, build succeeded.

00:24:00.300 --> 00:24:02.330
These are very fast machines.

00:24:02.600 --> 00:24:05.930
And now I'm going to pull up a terminal.

00:24:07.000 --> 00:24:12.950
- And now the last step that I have
to do is to install the importer.

00:24:12.970 --> 00:24:16.650
I'm going to copy build IFF importer.

00:24:18.430 --> 00:24:23.470
is the founder of the Spotlight library,
and he's been working on

00:24:23.470 --> 00:24:25.400
a lot of these things.

00:24:48.410 --> 00:24:54.720
Sure enough, if I scroll through this,
we have Users, Apple Library, Spotlight,

00:24:54.720 --> 00:24:55.490
IFF Importer.

00:24:55.770 --> 00:24:58.390
So as a first pass,
we've seen that the Spotlight

00:24:58.390 --> 00:25:02.100
system has found our importer,
and that it was able to load it,

00:25:02.100 --> 00:25:05.890
and so we've got a
first level of success.

00:25:05.920 --> 00:25:10.170
Now, what we're gonna do is see
if we can actually import

00:25:10.180 --> 00:25:12.410
some data from a Spotlight.

00:25:13.000 --> 00:25:41.600
[Transcript missing]

00:25:41.600 --> 00:25:47.480
dash D2 dash F sample image,
we'll get a little bit of output here.

00:25:47.480 --> 00:25:48.690
And let's go through what we got.

00:25:48.820 --> 00:25:51.900
So this is the output from
when I ran that command.

00:25:51.900 --> 00:25:56.970
Says import of sampleImage.IFF
and the type comAmigaInterchange

00:25:57.050 --> 00:25:59.040
dash file dash format.

00:25:59.040 --> 00:26:03.290
And it says it's gonna do it using the
IFF importer that we just installed.

00:26:03.300 --> 00:26:05.340
So this part looks great.

00:26:05.340 --> 00:26:10.000
And it says that it's sending these
attributes for that file to the server.

00:26:10.000 --> 00:26:12.590
There's a bunch of other stuff
such as the content creation

00:26:12.620 --> 00:26:15.940
date and the content type,
which were done for us.

00:26:15.940 --> 00:26:18.160
And then, lo and behold,
there we have our pixel

00:26:18.160 --> 00:26:20.040
width and pixel height.

00:26:20.040 --> 00:26:20.760
Great.

00:26:20.800 --> 00:26:25.710
So with very little effort,
we've done a very simple importer and

00:26:25.790 --> 00:26:28.880
published two attributes for this file.

00:26:28.880 --> 00:26:31.770
Now you say, great, Dominic,
nothing ever goes that smoothly.

00:26:31.840 --> 00:26:39.580
Demos are always nice and everything
works fine the first time you do it.

00:26:39.920 --> 00:26:42.880
Let's say someone comes in and says,
"Dominic, Dominic, Dominic,

00:26:43.060 --> 00:26:43.790
what did you do?

00:26:43.860 --> 00:26:48.800
com_amiga_interchange-file-format."
That's not the right way to declare it.

00:26:48.800 --> 00:26:53.800
You should just say com_amiga.iff
for the UTI type of this file.

00:26:53.800 --> 00:26:55.440
Sure, no problem, Bob.

00:26:55.440 --> 00:26:56.800
I can make that change.

00:26:56.800 --> 00:26:59.800
It's just two strings
that I have to edit.

00:26:59.800 --> 00:27:04.740
What I'm going to do here is introduce
a change into the Info.plist file

00:27:04.880 --> 00:27:08.650
and then show you what can happen
or one of the problems that you can

00:27:08.650 --> 00:27:10.790
run into when you're making changes.

00:27:10.800 --> 00:27:15.640
I saved that, made my two little edits,
and hit Build.

00:27:15.790 --> 00:27:16.740
It's fast.

00:27:16.760 --> 00:27:18.790
It's just the plist file.

00:27:18.800 --> 00:27:22.800
Go back and I'll copy this into place.

00:27:22.800 --> 00:27:24.800
I've installed my importer again.

00:27:24.800 --> 00:27:27.050
I say, "Okay, no problem, Bob.

00:27:27.160 --> 00:27:28.800
Let's take a look here.

00:27:28.800 --> 00:27:29.800
We'll do an MD import.

00:27:29.800 --> 00:27:33.790
-d2-f of that sample image again.

00:27:33.800 --> 00:27:36.800
Ooh, that's not good.

00:27:36.800 --> 00:27:37.800
Let's see.

00:27:37.850 --> 00:27:40.120
So, like I said,
I've purposely introduced a

00:27:40.160 --> 00:27:42.800
problem here to demonstrate how
you would go about and fix it.

00:27:42.800 --> 00:27:48.800
So what we can see happened is it says
com_amiga.interchange-file-format.

00:27:48.800 --> 00:27:49.730
There's no importer for it.

00:27:49.850 --> 00:27:51.800
But wait, I changed my importer.

00:27:51.800 --> 00:27:53.790
I changed the Info.plist file, right?

00:27:53.800 --> 00:27:54.800
So what's going on?

00:27:54.800 --> 00:27:58.800
Well, the problem is that because we just
copied in the importer for the UTI,

00:27:58.800 --> 00:28:02.790
the system didn't notice that
the plist file had changed.

00:28:02.800 --> 00:28:05.060
So what you really need to
do before you install it is

00:28:05.060 --> 00:28:08.500
always remove the previous one.

00:28:08.640 --> 00:28:14.250
I do an RM of the old importer,
and then I copy things in again.

00:28:14.250 --> 00:28:19.590
Now the system will have properly
noticed that the file was changed,

00:28:19.620 --> 00:28:23.160
the InfoP-List file was updated,
and sure enough, there we go,

00:28:23.160 --> 00:28:26.330
our type is now Comm Amiga IFF,
and the pixel width and

00:28:26.330 --> 00:28:28.440
height got published properly.

00:28:29.670 --> 00:28:32.460
So this is one of the things that
you can run into when you make

00:28:32.490 --> 00:28:35.080
changes to the InfoP-List file
that you need to be aware of.

00:28:35.150 --> 00:28:36.640
You don't want to be too clever.

00:28:36.640 --> 00:28:40.590
You always want to remove the
old copy and copy in the new one.

00:28:40.600 --> 00:28:43.590
And as we'll see later on,
you can also run into issues

00:28:43.590 --> 00:28:46.930
if you have multiple copies,
if you have backup versions of

00:28:46.930 --> 00:28:50.600
your importer sitting around,
you need to be careful with that,

00:28:50.600 --> 00:28:54.690
because the old versions can sometimes
mysteriously override things,

00:28:54.690 --> 00:28:57.450
and I'll talk about
how to figure that out.

00:28:57.460 --> 00:29:03.460
So that hints... And that's the
end of writing a simple importer.

00:29:03.540 --> 00:29:05.870
If we go back to the slides...

00:29:10.360 --> 00:29:12.060
Let's recap what we did.

00:29:12.060 --> 00:29:15.580
The first thing was we
edited the Info.plist file.

00:29:15.580 --> 00:29:20.270
We defined the UTI type for the
Comm Amiga interchange file format,

00:29:20.270 --> 00:29:24.960
and we bound that importer to
the UTI type that we defined.

00:29:25.020 --> 00:29:27.600
We had to write the code,
which was easy for us thanks to Oli.

00:29:27.600 --> 00:29:32.460
We just ripped it off and packaged it up,
and then we installed it.

00:29:32.500 --> 00:29:36.660
We ran the mdimport command
and we tested it out.

00:29:38.300 --> 00:29:40.990
Now,
let's start to talk about performance.

00:29:41.030 --> 00:29:43.660
This is a very crucial
topic for importers.

00:29:43.760 --> 00:29:48.160
Importers, like we just ran,
are very simple, straightforward.

00:29:48.160 --> 00:29:50.740
They simply, you know,
you run it against a single file,

00:29:50.740 --> 00:29:54.150
everything looks great, no problem,
I'm done, time to, you know,

00:29:54.200 --> 00:29:56.670
crack open a brewski and call it a day.

00:29:56.990 --> 00:29:59.320
Well, it's not quite that simple.

00:29:59.320 --> 00:30:02.150
You actually need to check your
performance and you need to

00:30:02.150 --> 00:30:04.110
be careful about a few things.

00:30:05.060 --> 00:30:07.670
When you run it against a single file,
like I said,

00:30:07.780 --> 00:30:09.770
it's a very simple sort of scenario.

00:30:09.780 --> 00:30:13.100
However,
MD importers run in different contexts.

00:30:13.100 --> 00:30:15.810
If someone comes along and
plugs in a hard drive that has,

00:30:15.870 --> 00:30:20.290
I don't know, 5,000 or 10,000 instances
of your file format on it,

00:30:20.360 --> 00:30:23.790
your importer is going to run
in a very long-lived context.

00:30:23.800 --> 00:30:26.250
It won't be run for every
single one of those files,

00:30:26.250 --> 00:30:28.530
but it will be run for
many of them at a time,

00:30:28.530 --> 00:30:29.440
repeatedly.

00:30:29.440 --> 00:30:32.900
So if you have a memory leak,
or if you do something that really

00:30:32.900 --> 00:30:36.490
abuses or thrashes the system,
the user is going to notice it.

00:30:36.500 --> 00:30:38.700
So you need to be careful
about performance.

00:30:38.700 --> 00:30:41.510
You need to use caution
when reading large files.

00:30:41.520 --> 00:30:45.810
You don't want to just blindly
suck in 50 megabytes of data

00:30:45.900 --> 00:30:48.020
like that IFF importer did.

00:30:48.040 --> 00:30:51.420
If we were passed a file which
wasn't really an IFF file,

00:30:51.420 --> 00:30:56.080
and we did NSData with contents
of path on a 50 megabyte file,

00:30:57.750 --> 00:31:00.520
"Thrash the machine pretty
thoroughly." So you need to be

00:31:00.520 --> 00:31:02.820
cautious when you read large files.

00:31:02.820 --> 00:31:06.240
Not only should you avoid
reading all the data if you can,

00:31:06.240 --> 00:31:10.310
you should just seek around and use
your knowledge of the file format

00:31:10.340 --> 00:31:13.600
to get the bits that you need,
but you also have to avoid

00:31:13.600 --> 00:31:15.390
allocating lots of memory.

00:31:15.390 --> 00:31:20.630
I just used that because those Amiga
IFF images typically are 320 by 200,

00:31:20.630 --> 00:31:24.970
and I was lazy, it was a simple demo,
but that's not the kind of thing that

00:31:24.970 --> 00:31:25.790
you would do in a production one.

00:31:26.590 --> 00:31:28.200
Don't blindly reuse code.

00:31:28.200 --> 00:31:32.330
This is a frequent thing that's
convenient to do to get a first pass up,

00:31:32.340 --> 00:31:35.920
where you just take your
existing document reading code,

00:31:35.930 --> 00:31:40.730
pull that in to the importer template,
and just inflate your

00:31:40.730 --> 00:31:43.990
full document structure,
pull out the three integers that

00:31:43.990 --> 00:31:47.220
you need to publish or the few
strings that you want to publish,

00:31:47.220 --> 00:31:50.410
and then call it a day.

00:31:50.420 --> 00:31:53.670
That's probably not the right thing,
because if you're re-inflating

00:31:53.740 --> 00:31:56.800
an entire document structure with
all the fields and all the data,

00:31:56.850 --> 00:32:00.300
you're probably using a lot more
system resources than you need to.

00:32:00.300 --> 00:32:04.260
It's much better if you, again,
use your knowledge of the file format

00:32:04.260 --> 00:32:08.300
to find the pieces of data that you
need and get those out efficiently and

00:32:08.300 --> 00:32:10.680
publish those as quickly as you can.

00:32:10.680 --> 00:32:13.720
I've mentioned mdimport-p.

00:32:13.720 --> 00:32:17.120
This is a good thing to do,
where if you take a large directory that

00:32:17.240 --> 00:32:20.400
has a lot of copies of your files in it,
run mdimport.

00:32:20.420 --> 00:32:24.510
mdimport-p and that directory name,
it will go through and iterate

00:32:24.510 --> 00:32:26.350
and import all of those files.

00:32:26.360 --> 00:32:29.980
It will print out some statistics
about how long each file took,

00:32:29.990 --> 00:32:32.080
where you spent a lot of the time.

00:32:32.080 --> 00:32:35.820
This way you can start to diagnose
if you're using too much memory,

00:32:35.830 --> 00:32:38.300
if you're taking too
long to process files,

00:32:38.300 --> 00:32:40.370
and understand what's going on.

00:32:43.240 --> 00:32:46.190
Some tips for importers:
Use standardized attribute

00:32:46.280 --> 00:32:47.350
names where you can.

00:32:47.500 --> 00:32:50.900
Don't invent new things just
to be gratuitous because it's

00:32:50.910 --> 00:32:52.540
KMDItem My Company Title.

00:32:52.620 --> 00:32:55.100
No, it's probably KMDItem Title.

00:32:55.100 --> 00:33:00.100
Use the existing ones that I mentioned
that are in MDItem.h when you can.

00:33:00.100 --> 00:33:03.100
So don't invent new things gratuitously.

00:33:03.100 --> 00:33:06.630
If you have something like a headline,
well, that can probably be

00:33:06.640 --> 00:33:08.100
classified as a title.

00:33:08.100 --> 00:33:10.680
Don't forget text content
when it's applicable.

00:33:10.680 --> 00:33:13.830
We don't all sit around writing
word processors and text editors,

00:33:13.890 --> 00:33:15.850
but a lot of different
applications actually have

00:33:15.850 --> 00:33:17.090
quite a bit of text in them.

00:33:17.090 --> 00:33:20.770
For example, this presentation here has
a fair bit of text in it,

00:33:20.790 --> 00:33:24.860
yet it's not really a word processor,
and so we publish things through

00:33:24.860 --> 00:33:27.100
the KMDItem text content attribute.

00:33:27.100 --> 00:33:30.620
As I mentioned earlier,
if you had a notes field or comments

00:33:30.700 --> 00:33:34.170
or some other large body of strings,
you can publish that

00:33:34.170 --> 00:33:37.100
information as text content,
and it will be associated

00:33:37.100 --> 00:33:37.100
with the document.

00:33:38.100 --> 00:33:41.050
It's a document,
and it'll be indexed efficiently,

00:33:41.050 --> 00:33:44.340
and the document will be found
when a user searches for those

00:33:44.340 --> 00:33:46.090
words that show up in there.

00:33:48.070 --> 00:33:49.440
Don't publish too much.

00:33:49.440 --> 00:33:52.000
Again, there's sometimes a lot
of initial excitement,

00:33:52.000 --> 00:33:54.930
"Oh baby, I can publish all these
attributes." Well,

00:33:54.990 --> 00:33:59.000
it's important to keep in mind what is
going to help the user find the document.

00:33:59.110 --> 00:34:02.590
What are things that they
might be likely to search for?

00:34:03.000 --> 00:34:06.110
If you need to remove attributes,
for example,

00:34:06.110 --> 00:34:10.520
you see that the file has been modified
and now there is no longer copyright

00:34:10.530 --> 00:34:13.790
information that's been taken out,
or the title or the

00:34:13.890 --> 00:34:17.430
author has been deleted,
you can remove it by simply

00:34:17.440 --> 00:34:19.630
not publishing that attribute.

00:34:19.810 --> 00:34:24.980
In the Template Importer project,
there are two files that get included:

00:34:25.110 --> 00:34:26.700
schema.xml and schema.strings.

00:34:26.700 --> 00:34:28.690
We're going to talk
about those in a minute,

00:34:28.690 --> 00:34:32.690
but if you don't use them,
just delete them from the project.

00:34:34.420 --> 00:34:35.840
Now, here's where it gets tricky.

00:34:35.880 --> 00:34:37.850
The find points of the Info.plist file.

00:34:37.850 --> 00:34:40.000
Or I should say, not tricky,
but a little bit more

00:34:40.040 --> 00:34:41.300
advanced and subtle.

00:34:41.630 --> 00:34:43.300
There are a couple of things.

00:34:43.320 --> 00:34:49.300
The UT imported type declarations
instead of UT exported type declarations.

00:34:49.300 --> 00:34:52.500
The difference here is that if you
are defining a UTI type and you

00:34:52.500 --> 00:34:57.300
are the master of that definition,
such as in the IFF importer example,

00:34:57.300 --> 00:35:00.300
you would use UT exported
type declarations.

00:35:00.300 --> 00:35:04.300
That means that you're the master copy
of the definition for that UTI type.

00:35:04.430 --> 00:35:08.190
If you're shipping an importer for
some other file format that you are

00:35:08.190 --> 00:35:11.510
not the controller of or the owner of,
you probably want to use

00:35:11.520 --> 00:35:14.450
UT imported type declarations,
which says,

00:35:14.450 --> 00:35:19.450
if this type declaration does not exist,
then I would like to define it

00:35:19.540 --> 00:35:22.280
and here's the information for it.

00:35:22.360 --> 00:35:25.430
This would be the case if you're
shipping your importer separately from

00:35:25.430 --> 00:35:27.300
your application and then you intend
to import it from the same file format.

00:35:27.300 --> 00:35:30.300
You would want to update your
application with the UTI information,

00:35:30.300 --> 00:35:33.300
the full UTI information later on.

00:35:33.320 --> 00:35:36.470
You can ship the importer
separately and the information

00:35:36.480 --> 00:35:38.300
will get overridden later on.

00:35:39.090 --> 00:35:43.500
Keep all the values that you store for
the keys lowercase when appropriate.

00:35:43.500 --> 00:35:45.720
In the description fields
it's not as important,

00:35:45.790 --> 00:35:49.810
but in the other fields generally
keep everything lowercase.

00:35:50.130 --> 00:35:52.990
Don't forget about the OS type
attribute if you need it.

00:35:53.010 --> 00:35:55.000
That's the four character code.

00:35:55.000 --> 00:35:58.780
So if you use the four character codes,
define the OS type so that that

00:35:58.780 --> 00:36:02.240
way that connection is made,
or that binding exists for

00:36:02.420 --> 00:36:07.080
that way of identifying a
file type with your importer.

00:36:08.020 --> 00:36:12.480
The UT type conforms to section
is pretty important as well.

00:36:12.480 --> 00:36:15.940
There's two notions of
conformance for the UTI system.

00:36:15.940 --> 00:36:19.800
There is the physical hierarchy,
that is how the file is stored,

00:36:19.800 --> 00:36:22.020
and then there's the semantic hierarchy.

00:36:22.040 --> 00:36:23.160
So how is a file stored?

00:36:23.270 --> 00:36:27.250
Well, either it's a plain file, you know,
a stream of bytes like we're all used to,

00:36:27.260 --> 00:36:28.460
or it's a package.

00:36:28.460 --> 00:36:31.680
There are also directories,
but that doesn't really apply here.

00:36:32.220 --> 00:36:37.270
So you have public.data for a flat file,
and you have com.apple.package for things

00:36:37.270 --> 00:36:39.690
that are package-based file formats.

00:36:39.700 --> 00:36:42.870
So that's the physical hierarchy,
and you should say what

00:36:42.870 --> 00:36:45.960
your file conforms to on
the physical side of things.

00:36:45.960 --> 00:36:49.900
The semantic hierarchy is
what is stored in the file.

00:36:49.900 --> 00:36:55.110
So here you have something very generic,
public.content, which just says I've

00:36:55.110 --> 00:36:58.410
got stuff in my file,
or composite content when

00:36:58.420 --> 00:37:02.200
you have mixed media,
such as text and pictures.

00:37:02.200 --> 00:37:03.440
So you have a lot of
different types of pictures,

00:37:03.510 --> 00:37:04.220
as you would in a PDF file.

00:37:04.220 --> 00:37:09.120
And then you have additionally
things for specific data types,

00:37:09.120 --> 00:37:13.460
such as public.image,
if you have a new image format,

00:37:13.460 --> 00:37:16.350
or audio and so on, movies, etc.

00:37:16.360 --> 00:37:20.650
Again, Chris Lynn has a talk,
I think it's at 5:00 today,

00:37:20.710 --> 00:37:24.040
about the UTI system,
and I strongly encourage you

00:37:24.040 --> 00:37:28.120
to check it out to learn more
about that aspect of things.

00:37:29.160 --> 00:37:31.350
As you saw,
I used a couple of command line

00:37:31.360 --> 00:37:35.610
tools to help me with diagnosing or
figuring out whether my importer was

00:37:35.610 --> 00:37:37.250
written correctly and was working.

00:37:37.260 --> 00:37:41.810
The most important one for importers,
strangely enough, is named MD Import,

00:37:41.820 --> 00:37:46.660
which imports files and prints out some
global state about the Spotlight system.

00:37:46.660 --> 00:37:49.910
There's MDLS,
which will list the attributes of a file,

00:37:50.060 --> 00:37:52.590
and MD Find,
which will let you issue a query

00:37:52.680 --> 00:37:56.490
to see if your attributes are being
published properly so that you can

00:37:56.490 --> 00:37:58.090
query against them and find them.

00:37:58.860 --> 00:38:02.670
Read the man pages for the full
list of options for those programs.

00:38:02.670 --> 00:38:04.620
They're definitely very helpful.

00:38:06.580 --> 00:38:09.370
Again, testing and debugging,
what you saw that I did was,

00:38:09.490 --> 00:38:10.580
I started simple.

00:38:10.580 --> 00:38:13.700
I ran mdimport-l,
saw that my importer was listed.

00:38:13.700 --> 00:38:17.130
That's job number one,
did the Spotlight system even see it?

00:38:17.140 --> 00:38:21.930
Then I ran mdimport with dash d1,
or I did dash d2 on a file

00:38:22.000 --> 00:38:24.620
and saw that it was imported.

00:38:25.720 --> 00:38:27.710
Be careful if you have multiple copies.

00:38:27.710 --> 00:38:30.160
As I alluded to,
if you start having multiple

00:38:30.160 --> 00:38:33.580
copies around that you've copied
with the Finder or in the Shell,

00:38:33.580 --> 00:38:37.450
the system can start to find
too many of them and the

00:38:37.450 --> 00:38:40.200
Info.plist files can conflict.

00:38:40.200 --> 00:38:41.790
So you need to be careful with that.

00:38:41.800 --> 00:38:44.840
Always start from a
fresh importer template.

00:38:44.840 --> 00:38:47.860
Sometimes you may have a couple
of different file formats.

00:38:47.970 --> 00:38:50.310
You say, okay, boom,
I got my first one done.

00:38:50.320 --> 00:38:53.440
Now I'm just going to make a copy of
this project and start on the second

00:38:53.450 --> 00:38:55.370
file format and whip through that one.

00:38:55.760 --> 00:38:57.360
And, you know, be done by 5:00.

00:38:57.420 --> 00:39:01.400
You don't want to do that because,
as you saw at the end of the file,

00:39:01.400 --> 00:39:04.480
there are some UUIDs that
are automatically generated

00:39:04.480 --> 00:39:05.790
as part of the template.

00:39:05.800 --> 00:39:10.130
If you just make a copy of it,
those UUIDs will be the same and

00:39:10.130 --> 00:39:15.830
that's not good because that will cause
the plug-in system to get confused

00:39:15.890 --> 00:39:20.610
when two bundles have the same UUID.

00:39:21.510 --> 00:39:27.780
You may need to actually run
the debugger on your importer.

00:39:27.780 --> 00:39:31.080
It would be great if everybody wrote
code that worked the first time,

00:39:31.080 --> 00:39:32.460
like it did in the demo, right?

00:39:32.460 --> 00:39:37.430
Well, it didn't work out that way the
first time when I was writing it,

00:39:37.500 --> 00:39:43.780
so sometimes you have to
run GDB on an importer.

00:39:43.780 --> 00:39:49.160
The way to do that, since it's a plug-in,
is you run GDB on the MD import program,

00:39:49.160 --> 00:39:53.060
and then you can set a future breakpoint,
which will say when this

00:39:53.080 --> 00:39:55.980
function gets defined,
set the breakpoint,

00:39:55.980 --> 00:39:58.050
and then call it when it gets hit.

00:39:58.060 --> 00:40:01.080
So if you just type, you know,
set a breakpoint on

00:40:01.180 --> 00:40:05.160
get metadata for file,
you'll get control of the application of

00:40:05.160 --> 00:40:07.890
MD import when your importer is called.

00:40:07.900 --> 00:40:10.620
You can also do this in Xcode.

00:40:10.620 --> 00:40:13.620
If you set the project
executable to be MD import.

00:40:13.780 --> 00:40:17.290
And then, you know,
set the appropriate command

00:40:17.360 --> 00:40:19.300
line arguments as well.

00:40:22.350 --> 00:40:23.520
when it still doesn't work.

00:40:23.590 --> 00:40:27.800
So this is what happened to me late
last week as I was trying to do the

00:40:27.800 --> 00:40:29.780
final touches on this presentation.

00:40:29.780 --> 00:40:32.330
I just couldn't for the
life of me figure out why,

00:40:32.330 --> 00:40:35.640
you know, when I went through the
example of switching the

00:40:35.650 --> 00:40:39.400
interchange-file-format to IFF,
what was going on?

00:40:39.400 --> 00:40:42.860
Well,
it turned out that there were some issues

00:40:42.930 --> 00:40:47.780
with the LS register knowing about too
many copies of it in the plist file.

00:40:47.780 --> 00:40:51.330
So, the way to diagnose this
is with LS register-dump.

00:40:51.350 --> 00:40:56.230
What this will do is dump out the
full state of the UTI system so that

00:40:56.240 --> 00:41:01.680
you can see who is defining what and
if things are conflicting that you,

00:41:01.680 --> 00:41:04.380
you know, don't want to be that way.

00:41:04.380 --> 00:41:08.390
So with LS register-dump,
you can see who it is that has defined

00:41:08.400 --> 00:41:13.060
all of the UTI types and if there are
multiple definitions for the same UTI.

00:41:13.160 --> 00:41:17.540
If there are,
you can force re-importing a particular

00:41:17.540 --> 00:41:20.340
one with -f -v or you can force
re-importing a particular one with

00:41:20.340 --> 00:41:26.760
-f -v or you can use -kill -seed to get
it to fully recreate its UTI structure.

00:41:26.760 --> 00:41:31.380
The LS register program is part of the
application services framework and it

00:41:31.380 --> 00:41:34.620
lives in that nice long path right there.

00:41:34.620 --> 00:41:39.710
You can run that and it will, you know,
you can use that to clear up any

00:41:39.740 --> 00:41:42.150
potential issues that you have.

00:41:42.250 --> 00:41:45.530
That's again a last resort, however,
it is, you know,

00:41:45.530 --> 00:41:47.670
some to advanced importers.

00:41:47.890 --> 00:41:51.870
In the demo that I did,
you saw how I had this .dbg file format,

00:41:51.870 --> 00:41:54.800
which is, you know,
not known to the system, and yet those,

00:41:54.800 --> 00:41:58.380
the attributes that I published
showed up very cleanly and looked

00:41:58.380 --> 00:42:00.300
like a native part of the system.

00:42:00.480 --> 00:42:02.560
That's what we're going
to talk about now.

00:42:02.560 --> 00:42:04.030
So, how does that happen?

00:42:04.030 --> 00:42:07.950
First off, I defined some new attributes.

00:42:08.870 --> 00:42:12.570
One of the things that I did was
I had to go and edit the attributes

00:42:12.670 --> 00:42:14.950
section of the schema.xml file.

00:42:14.970 --> 00:42:19.120
The schema.xml file is where
you define new attributes.

00:42:19.340 --> 00:42:21.600
So, for example,
I have two of them right here.

00:42:21.600 --> 00:42:26.570
You have attribute name
is comfoo-track-title,

00:42:26.570 --> 00:42:29.620
and I say that it's a CFString,
it's type.

00:42:29.650 --> 00:42:35.670
Another one is, for example, a user ID,
and I say that that's a CFNumber.

00:42:35.930 --> 00:42:40.090
The next part that you have
to modify is the Type section.

00:42:40.140 --> 00:42:45.370
Here,
you add each attribute that your importer

00:42:45.370 --> 00:42:47.130
publishes to the All Adders list.

00:42:47.140 --> 00:42:50.910
So even if it's a standard attribute,
you would want to add it

00:42:50.920 --> 00:42:53.040
to the All Adders section,
in addition to the new

00:42:53.050 --> 00:42:54.340
ones that you're defining.

00:42:54.340 --> 00:42:58.860
If you want an attribute
displayed in the system,

00:42:58.860 --> 00:43:04.400
so for example, I had the K, K,
well I didn't call it K, I said COM,

00:43:04.400 --> 00:43:08.740
debug, debug session name,
or radar number,

00:43:08.740 --> 00:43:11.950
then I add those to the Display Adders,
and then the system will know that these

00:43:12.050 --> 00:43:13.620
are attributes that should be displayed.

00:43:13.620 --> 00:43:16.620
Why would you have an attribute
that you don't actually display?

00:43:16.620 --> 00:43:20.780
Because you might do something
that searches for it on behalf

00:43:20.780 --> 00:43:23.820
of the user to identify things,
but it's not something that

00:43:23.820 --> 00:43:24.320
you would want to display.

00:43:24.320 --> 00:43:27.560
You would want them,
or you would want shown in the

00:43:27.560 --> 00:43:30.070
Finder or in the Spotlight window.

00:43:30.840 --> 00:43:33.800
Don't redefine existing attribute names.

00:43:33.900 --> 00:43:37.500
So you should never have
something that says KMDItemFu

00:43:37.500 --> 00:43:39.550
that we already have in MDItem.h.

00:43:39.550 --> 00:43:44.100
You would never add that as a
new attribute in your schema.xml.

00:43:44.100 --> 00:43:48.300
You might add it to the All Adders
list or the Display Adders list,

00:43:48.330 --> 00:43:51.050
but you would not actually define it.

00:43:51.290 --> 00:43:55.080
You can run md check schema
on the schema.xml file to see

00:43:55.080 --> 00:43:57.100
if you got the syntax right.

00:43:57.100 --> 00:44:01.640
And md import dash x and dash a will
also dump out some state so that you can

00:44:01.640 --> 00:44:07.320
see if once your importer is installed,
did the schema take effect.

00:44:10.210 --> 00:44:13.870
Now, of course,
if we named our attributes com, foo,

00:44:13.870 --> 00:44:16.750
track title,
with all those nice underbars,

00:44:16.790 --> 00:44:18.560
people wouldn't be very happy.

00:44:18.560 --> 00:44:23.390
So there's a way to map from the
internal name of an attribute to the

00:44:23.390 --> 00:44:25.760
external name or the user visible name.

00:44:25.760 --> 00:44:30.690
So you can define human readable
strings in the schema.strings file,

00:44:30.870 --> 00:44:34.190
which is a UTF-16 encoded file,
so you need to use an

00:44:34.190 --> 00:44:35.730
appropriate editor to edit it.

00:44:36.120 --> 00:44:38.270
If you're in Xcode,
you don't have to think about it,

00:44:38.270 --> 00:44:40.740
but you should know that
it's a UTF-16 encoded file.

00:44:40.860 --> 00:44:44.190
So here you can define
the mapping from com,

00:44:44.230 --> 00:44:47.660
foo,
track title to be equal to track title,

00:44:47.660 --> 00:44:49.330
which is what the user would see.

00:44:49.340 --> 00:44:51.990
You can also describe your attributes.

00:44:52.000 --> 00:44:55.560
Now, this is something that's used
if you've ever brought up the

00:44:55.560 --> 00:44:57.520
Finders advanced find window.

00:44:57.770 --> 00:45:02.470
In there, you can bring up the searching
for any kind of attribute,

00:45:02.470 --> 00:45:06.400
and there's a list of attribute names on
the left column and a short description.

00:45:06.400 --> 00:45:07.830
This is that description.

00:45:07.840 --> 00:45:10.370
And in this case,
it's the title of a track,

00:45:10.370 --> 00:45:13.980
which isn't a whole lot more help,
but that's the example.

00:45:13.980 --> 00:45:17.180
You can localize your
attribute names as well.

00:45:17.180 --> 00:45:22.480
So in the individual language .lproj
directory in the schema.strings there,

00:45:22.480 --> 00:45:26.010
you can have, for example,
comfoo track title equals traccia

00:45:26.010 --> 00:45:30.170
titolo if you had the Italian one,
and the associated description.

00:45:34.100 --> 00:45:36.450
If all we had were strings
and numbers for attributes,

00:45:36.520 --> 00:45:39.250
that might not be bad,
but there's some modifiers as

00:45:39.360 --> 00:45:43.000
well that you can apply to an
attribute that are kind of useful.

00:45:43.000 --> 00:45:45.000
You can have a multi-valued attribute.

00:45:45.000 --> 00:45:47.000
So what's a multi-valued attribute?

00:45:47.020 --> 00:45:51.000
This is an example where
you have an attribute name,

00:45:51.000 --> 00:45:55.980
such as "kmdItemKeywords", and
then you have an array of values

00:45:55.990 --> 00:45:58.000
that are stored for that attribute.

00:45:58.000 --> 00:46:02.000
The array of values are independent.

00:46:02.000 --> 00:46:05.000
Each entry is independent of each other.

00:46:05.000 --> 00:46:08.000
So, for example,
if you had kmdItemAuthors,

00:46:08.000 --> 00:46:14.000
if you just had them all glommed
together separated by spaces,

00:46:14.000 --> 00:46:15.990
you might run into a
problem where you have Leon,

00:46:16.000 --> 00:46:18.000
Van, Bon, and Bon, Scott.

00:46:18.000 --> 00:46:22.000
Well, is Van, Bon, and Bon,
which one is which part?

00:46:22.000 --> 00:46:22.000
But by putting them as
separate entries in an array,

00:46:22.000 --> 00:46:22.000
then when you do any matching,
there's no confusion as to

00:46:22.000 --> 00:46:22.000
which one is which part.

00:46:22.000 --> 00:46:23.520
But by putting them as
separate entries in an array,

00:46:23.520 --> 00:46:25.170
then when you do any matching,
there's no confusion as to

00:46:25.190 --> 00:46:26.000
which one is which part.

00:46:26.000 --> 00:46:26.730
But by putting them as
separate entries in an array,

00:46:26.730 --> 00:46:27.510
then when you do any matching,
there's no confusion as to

00:46:27.520 --> 00:46:28.000
which one is which part.

00:46:28.000 --> 00:46:31.070
whether or not you've got two
different pieces just because

00:46:31.070 --> 00:46:32.540
they're separated by spaces.

00:46:32.540 --> 00:46:35.870
So, if you have something for which
there are a set of values,

00:46:35.870 --> 00:46:40.890
like I said, layer names, track titles,
a set of authors, or a set of keywords,

00:46:40.890 --> 00:46:45.720
these are all examples of things
that would be multi-valued.

00:46:45.720 --> 00:46:48.320
The next modifier is called No Search.

00:46:48.320 --> 00:46:51.260
Now, why would you publish metadata
that you don't want to search,

00:46:51.260 --> 00:46:52.020
you would ask?

00:46:52.040 --> 00:46:53.580
Well, that's a good question.

00:46:53.590 --> 00:46:56.450
But there are things that you
would want to search as an

00:46:56.450 --> 00:47:00.600
application that you don't want to
be searched by default by the user.

00:47:00.600 --> 00:47:06.340
So, when we do a search in the
spotlight menu or in the finder,

00:47:06.340 --> 00:47:10.130
we generally search over all the
attributes that are associated

00:47:10.140 --> 00:47:13.600
with the file except for those
that are marked No Search.

00:47:13.660 --> 00:47:17.580
This comes up for us, you know,
with the CamdItemContentType

00:47:17.580 --> 00:47:21.340
attribute which has strings
like public or apple in it.

00:47:21.340 --> 00:47:24.500
And if you search for apple
and every single file matches,

00:47:24.500 --> 00:47:24.500
you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.500
So, you can search for the same thing.

00:47:24.500 --> 00:47:24.580
So, you can search for the same thing.

00:47:24.600 --> 00:47:28.760
matched because of com.apple
is somewhere in the hierarchy,

00:47:28.770 --> 00:47:31.030
you'd be a little bit disconcerted.

00:47:31.110 --> 00:47:34.560
So, however, we do search for things
for KMDItemContentType

00:47:34.580 --> 00:47:36.400
equals a specific value.

00:47:36.400 --> 00:47:40.340
So if you mark an attribute as no search,
what will happen is that

00:47:40.370 --> 00:47:44.100
if you name it explicitly,
then you'll match against it.

00:47:44.100 --> 00:47:47.040
Otherwise,
it won't match in the search over

00:47:47.040 --> 00:47:48.940
all attributes type of query.

00:47:51.070 --> 00:47:55.890
The last modifier is
the Uniqued modifier.

00:47:55.940 --> 00:47:59.050
The Uniqued modifier is useful
when you have a lot of strings

00:47:59.050 --> 00:48:00.890
that have the same values.

00:48:00.910 --> 00:48:02.900
So if you had a set of team names,
for example,

00:48:02.900 --> 00:48:06.430
you wouldn't want to store the
San Francisco Giants 10,000

00:48:06.430 --> 00:48:09.900
times if you could store it in
a more compact representation.

00:48:09.900 --> 00:48:13.860
So when you have something that
has on the order of 10s or 15s,

00:48:13.880 --> 00:48:19.900
10s, 20s, 30s, less than, let's say,
100 values for a particular attribute,

00:48:19.900 --> 00:48:26.550
then you might want to tag it with the
Uniqued equals True modifier so that that

00:48:26.550 --> 00:48:28.900
way it will be stored more efficiently.

00:48:28.900 --> 00:48:31.900
Here we have some examples down below.

00:48:31.900 --> 00:48:35.890
So you have Track Title is multivalued,
and that's a very good example.

00:48:35.900 --> 00:48:38.900
Or you have a private name,
and we say No Search.

00:48:38.900 --> 00:48:39.900
Now that's a good example.

00:48:39.900 --> 00:48:43.320
This is something where if a user,
you have a special UI that

00:48:43.320 --> 00:48:47.890
does searching for things,
and that would, you would set,

00:48:47.980 --> 00:48:50.810
you would do a search for,
one of the clauses might be,

00:48:50.820 --> 00:48:55.380
"Komfu private name is equal to
some value," but normal searches

00:48:55.390 --> 00:48:58.220
wouldn't trip over that attribute.

00:48:58.430 --> 00:49:02.240
Team names, again,
is the example I gave for unique values.

00:49:02.240 --> 00:49:03.080
And you can combine these.

00:49:03.080 --> 00:49:08.120
You can have multi-valued, unique,
if you wanted, and so on.

00:49:09.810 --> 00:49:13.640
This slide is a fairly esoteric topic.

00:49:13.640 --> 00:49:18.800
We use it internally for things like
the display name of an application.

00:49:18.900 --> 00:49:22.700
So we have localized display names
for something like a dress book,

00:49:22.700 --> 00:49:27.930
which can be the Japanese characters for
the name "address book," or in Italian,

00:49:27.940 --> 00:49:32.650
"rubrica indirizzi," or in English,
"address book." When you do a search,

00:49:32.650 --> 00:49:36.350
if you type, for example,
"bibl," you're going to, in French,

00:49:36.450 --> 00:49:39.440
you're going to find
"biblioteque." You won't find the

00:49:39.470 --> 00:49:43.110
"biblereader.app," because that's
going to have a different name,

00:49:43.110 --> 00:49:44.000
a localized name.

00:49:44.020 --> 00:49:47.340
So if you wanted to publish a
localized value for an attribute

00:49:47.390 --> 00:49:51.140
so that it would only be matched
in the user's preferred language,

00:49:51.220 --> 00:49:54.010
the way to do that is
for the attribute name,

00:49:54.020 --> 00:49:56.940
in this case,
"kmditemdisplayname," you publish

00:49:56.980 --> 00:50:01.310
a dictionary that has the mapping
of this language equals this value.

00:50:01.360 --> 00:50:04.810
And then, when a user does a search
in their preferred language,

00:50:04.820 --> 00:50:07.250
or by default it's in
their preferred language,

00:50:07.270 --> 00:50:11.250
it will only be matched
against that language code.

00:50:13.030 --> 00:50:18.340
Now, let's move on to the actual
code of the Advanced Importer.

00:50:18.340 --> 00:50:20.380
Demo 1, please.

00:50:23.100 --> 00:50:27.020
All right, let's go back here.

00:50:27.020 --> 00:50:31.030
We'll pull up this
dbg-importer Xcode definition.

00:50:31.500 --> 00:50:55.800
[Transcript missing]

00:50:58.300 --> 00:51:06.960
Here we have a very simple file format.

00:51:06.960 --> 00:51:12.300
On the left side there is a keyword,
and on the right side is some value.

00:51:12.300 --> 00:51:15.300
I just invented this for
the purposes of this demo.

00:51:15.300 --> 00:51:19.300
We have session: and what the name of
the debug session was,

00:51:19.300 --> 00:51:22.300
some keywords about it,
and a radar number.

00:51:22.300 --> 00:51:25.270
We want to import this file
format into the Spotlight

00:51:25.270 --> 00:51:30.300
system and publish these things,
these keys and values, as attributes,

00:51:30.300 --> 00:51:31.260
which kind of makes sense.

00:51:31.300 --> 00:51:36.640
We're going from a very simple flat
file to something that can be searched

00:51:36.650 --> 00:51:39.700
very easily in the Spotlight system.

00:51:40.270 --> 00:51:43.080
So the first thing I have to do,
because this file format

00:51:43.150 --> 00:51:46.510
doesn't have a UTI type,
is give it a UTI type.

00:51:46.580 --> 00:51:50.080
Again, since I'm going to be the
master of this file format,

00:51:50.080 --> 00:51:53.070
I'm going to use the
UT exported type declarations.

00:51:53.080 --> 00:51:56.770
I've chosen to call
it com.apple.dbg.demo,

00:51:56.780 --> 00:52:01.020
since we use the reverse
DNS naming convention for UTIs.

00:52:01.140 --> 00:52:07.060
And then I've given a reference URL,
which is sort of useless in this case,

00:52:07.060 --> 00:52:09.700
and a simple description of DBG file.

00:52:10.200 --> 00:52:13.280
Now here we have the
UT type conforms to section.

00:52:13.280 --> 00:52:16.130
As I said,
you have the physical conformance

00:52:16.130 --> 00:52:19.820
and the semantic conformance,
or semantic hierarchy.

00:52:19.920 --> 00:52:24.420
And so it's public.data because
it's just a simple flat file,

00:52:24.420 --> 00:52:29.000
and it's public.content for
the semantic hierarchy because

00:52:29.000 --> 00:52:31.200
it's just some generic content.

00:52:33.310 --> 00:52:37.120
The tag specification,
so here we have the OS type,

00:52:37.300 --> 00:52:40.290
which is a four character code,
I just chose dbgz,

00:52:40.300 --> 00:52:42.660
there's not really a four
character code for this file that

00:52:42.660 --> 00:52:44.620
anybody's going to be setting,
but if there was,

00:52:44.620 --> 00:52:45.900
that's what it would be.

00:52:45.910 --> 00:52:49.610
And the file name extension,
which is going to be .dbg,

00:52:49.770 --> 00:52:54.860
and that's the typical way that the
UTI would be associated with the file.

00:52:55.730 --> 00:52:58.300
Then we have to bind our importer.

00:52:58.370 --> 00:53:02.670
Again, this is how we go from the
UTI system and say that this file

00:53:02.670 --> 00:53:05.530
is of this type and that this
is the importer that handles it.

00:53:05.600 --> 00:53:11.910
We have the LS item content types and
I say that I handle com.apple.dbg.demo.

00:53:12.420 --> 00:53:15.860
I've set the name and some
other informational fields.

00:53:15.910 --> 00:53:19.500
Down here are the UUIDs that
were automatically generated

00:53:19.500 --> 00:53:21.240
when I created this project.

00:53:21.240 --> 00:53:23.400
That's what I was talking about earlier.

00:53:23.400 --> 00:53:26.260
These are automatically
created on your behalf,

00:53:26.260 --> 00:53:29.960
so if you were to copy a project,
you need to be careful because you

00:53:29.960 --> 00:53:32.400
don't want to have duplicate UUIDs.

00:53:32.400 --> 00:53:35.500
So that's the Info.plist file.

00:53:36.170 --> 00:53:42.500
Now let's take a look at the XML file,
the schema.xml file that I defined.

00:53:42.500 --> 00:53:46.000
And here we have the Attributes section,
as I mentioned.

00:53:46.000 --> 00:53:50.000
And we have the name,
com.apple.dbg.session_name,

00:53:50.000 --> 00:53:53.000
and the type is just simply a CFString.

00:53:53.000 --> 00:53:56.500
The attribute name,
com.apple.dbg.radar_number,

00:53:56.500 --> 00:53:59.000
and I've chosen just to make it a
string because they can be quite

00:53:59.000 --> 00:54:03.000
long and I don't have to worry about
whether it fits in an int or so on.

00:54:03.480 --> 00:54:07.010
In the Type section,
we have the type name,

00:54:07.010 --> 00:54:09.720
which is com.apple.dbgdemo.

00:54:09.760 --> 00:54:13.390
And now I'm going to associate what
attributes do I want associated

00:54:13.410 --> 00:54:16.780
with this type and which attributes
do I want displayed with this type.

00:54:16.780 --> 00:54:21.490
And here in the All Adders section, I say
com.apple.sessionName.radarNumber.kmdItem

00:54:21.490 --> 00:54:23.850
Keywords,
because these are all the attributes

00:54:23.850 --> 00:54:25.640
that I'm going to publish.

00:54:25.640 --> 00:54:30.150
And I would like that same set of
attributes displayed for that type.

00:54:30.160 --> 00:54:33.160
So that takes care of
the schema.xml file.

00:54:36.170 --> 00:54:41.530
In the schema.strings file is where
I do the mapping from those kind of

00:54:41.530 --> 00:54:47.420
ugly names of com_apple_sessionname
to the pretty names that showed up in

00:54:47.420 --> 00:54:50.140
the UI when I did the get info on it.

00:54:50.140 --> 00:54:52.940
So we have debug session
name and radar number.

00:54:52.960 --> 00:54:57.000
I've also given a short description,
and that's all we have to

00:54:57.010 --> 00:54:58.870
do in the strings file.

00:54:58.930 --> 00:55:01.910
Now let's take a look at the code.

00:55:01.920 --> 00:55:04.960
Get this so it's a
little bit more visible.

00:55:07.390 --> 00:55:11.970
Here we have our stub
function getMetadataForFile.

00:55:12.140 --> 00:55:16.010
And again, the arguments that are
passed are the path,

00:55:16.080 --> 00:55:19.790
the CFStringRef to the path,
the attributes that

00:55:19.790 --> 00:55:23.410
we're going to fill out,
and as well there's a content type UTI.

00:55:23.460 --> 00:55:28.080
So if your file, if your importer handles
multiple file formats,

00:55:28.080 --> 00:55:30.860
this could help you determine,
this would be one way to

00:55:30.860 --> 00:55:34.370
help you determine which
type of file you were passed.

00:55:34.660 --> 00:55:38.280
Now, in the last example,
I used Objective-C and kind

00:55:38.280 --> 00:55:40.400
of went to the other extreme.

00:55:40.400 --> 00:55:42.730
In this example,
I'm going to go the other way

00:55:42.750 --> 00:55:44.090
and just use straight C code.

00:55:44.090 --> 00:55:47.880
So I'm going to convert that
path to the file to a regular

00:55:47.910 --> 00:55:53.540
C string using the function
CFStringGetFileSystemRepresentation.

00:55:53.540 --> 00:55:57.020
And I'm going to do the same
thing for the content type UTI,

00:55:57.020 --> 00:55:59.680
even though I'm not going to use it here.

00:55:59.680 --> 00:56:03.520
And then I call this function
GetDebugInfo on the path and I pass

00:56:03.520 --> 00:56:05.580
it the attributes dictionary.

00:56:05.580 --> 00:56:10.120
This function, GetDebugInfo,
is pretty basic.

00:56:10.200 --> 00:56:14.720
It's just going to open the file
and parse through each of the lines

00:56:14.720 --> 00:56:19.000
and read them in and split apart
the key name on the left side and

00:56:19.000 --> 00:56:21.700
the string value on the right side.

00:56:22.000 --> 00:56:23.540
So, parse the line.

00:56:23.540 --> 00:56:24.650
I'm not going to go into that.

00:56:24.660 --> 00:56:27.500
That's just ripping things apart,
ripping the text apart.

00:56:27.500 --> 00:56:31.500
And I create a CFString with
the C string for the value.

00:56:31.500 --> 00:56:36.990
And I take a look at the key, and I say,
okay, if I got the session keyword,

00:56:36.990 --> 00:56:42.770
then I'm going to do a CFDictionary add
value of com apple dbg session name,

00:56:42.770 --> 00:56:46.440
and I'm going to store the value
that was in the file for that string.

00:56:46.440 --> 00:56:50.870
If I got radar,
if I got the keyword radar, then again,

00:56:50.870 --> 00:56:55.420
I will do CFDictionary add
value on this attribute name,

00:56:55.420 --> 00:56:57.960
and I'll give it that value.

00:56:57.960 --> 00:57:01.980
Now, the last one that we're going to
look at is the keywords attribute.

00:57:01.980 --> 00:57:06.250
And this one's a little bit more tricky,
but is an important thing.

00:57:06.260 --> 00:57:10.750
You have to get the types of the
data that you publish correct.

00:57:10.750 --> 00:57:14.670
If you only had one keyword,
you can't just publish a string,

00:57:14.690 --> 00:57:18.430
because the keywords attribute
is a multi-valued attribute.

00:57:18.440 --> 00:57:23.620
So, what we have to do is create an
array and put our value into it,

00:57:23.620 --> 00:57:28.440
even though it's going to be
the only entry in that array.

00:57:28.440 --> 00:57:32.310
The way we do that,
create a mutable array called keywords,

00:57:32.310 --> 00:57:35.650
and we append the value to it,
which is the value that

00:57:35.650 --> 00:57:37.290
we got out of the file.

00:57:37.850 --> 00:57:44.800
We add the Keywords array for the
KMDItemKeywords attribute name,

00:57:44.800 --> 00:57:46.840
and we add that to the
Attributes dictionary.

00:57:46.840 --> 00:57:48.640
So you see there's a couple of pieces.

00:57:48.670 --> 00:57:53.800
You have the Attributes dictionary,
which contains a key, KMDItemKeywords,

00:57:53.800 --> 00:57:55.920
and for that key is stored an array.

00:57:55.920 --> 00:57:59.160
And in that array,
we in this case only have one value.

00:57:59.170 --> 00:58:02.490
If you had multiple values,
you would append the values to the array,

00:58:02.500 --> 00:58:05.700
and then all of those values
would be associated with that key.

00:58:06.560 --> 00:58:10.120
Once we've done that,
and we've finished iterating the file,

00:58:10.120 --> 00:58:15.170
we return zero for success, and we're...

00:58:16.400 --> 00:58:21.100
Then we return, in this case,
true from getMetadataForFile,

00:58:21.100 --> 00:58:23.600
and that is what we have
to do to publish it.

00:58:23.600 --> 00:58:27.660
We build the importer again.

00:58:28.700 --> 00:58:32.520
It's already installed actually,
but also let's see.

00:58:32.520 --> 00:58:34.520
Spotlight.

00:58:39.600 --> 00:58:48.100
install it, follow the real protocol,
Library Spotlight, DBG importer,

00:58:48.100 --> 00:58:53.290
remove that one,
copy it into library on bad bug.

00:58:53.340 --> 00:58:59.400
What we can see are that we have
the attributes that we published,

00:58:59.400 --> 00:59:05.280
com, apple, dbg, radar number, 8, 6, 7,
5, 3, 0, 9, the session name and so on.

00:59:05.280 --> 00:59:09.380
So our importer got published,
or published the correct metadata.

00:59:09.380 --> 00:59:14.380
We see our keywords are published
correctly and everything's happy.

00:59:14.390 --> 00:59:21.270
So that's basically what you have to
do for more sophisticated importer

00:59:21.270 --> 00:59:23.770
to publish additional attributes.

00:59:23.780 --> 00:59:27.530
So if we go back to the slides.

00:59:29.200 --> 00:59:31.650
So again, what did we do here with
the Advanced Importer?

00:59:31.790 --> 00:59:33.600
We defined some new attributes.

00:59:33.690 --> 00:59:36.280
We had to go into the
schema.strings file,

00:59:36.280 --> 00:59:39.390
or schema.xml file,
define the attributes,

00:59:39.390 --> 00:59:43.000
which in this case was the
DBG session name and radar number,

00:59:43.000 --> 00:59:48.700
declared the human readable forms of
those strings in the schema.strings file,

00:59:48.700 --> 00:59:55.400
and we also went through and showed how
we would export an array-valued item.

00:59:55.400 --> 00:59:55.400
Dominic Giampaolo

00:59:58.870 --> 01:00:01.440
So, what have we gone through today?

01:00:01.540 --> 01:00:04.790
Spotlight uses published metadata
to make documents easier to find.

01:00:04.790 --> 01:00:06.800
They display more richly.

01:00:06.920 --> 01:00:12.700
When you have nice metadata,
the system can display that even if

01:00:12.700 --> 01:00:16.840
it doesn't know anything about that
type before or when Tiger shipped.

01:00:17.100 --> 01:00:20.640
So, nobody knows anything
about the .dbg file format,

01:00:20.690 --> 01:00:23.890
but we were able to publish
data or display those files

01:00:23.890 --> 01:00:25.720
a little bit more nicely.

01:00:25.720 --> 01:00:28.790
Any file can be part of
Spotlight if it has an importer,

01:00:28.790 --> 01:00:30.910
and that's where you guys come in.

01:00:30.920 --> 01:00:35.180
Your file format can be just as
seamlessly integrated as what I've shown

01:00:35.180 --> 01:00:37.790
here today with the .dbg file format.

01:00:39.980 --> 01:00:43.820
Importers publish metadata from files,
and they do this so that users

01:00:43.820 --> 01:00:45.100
can find that information.

01:00:45.120 --> 01:00:47.490
Importers are pretty easy to write.

01:00:47.670 --> 01:00:52.500
That Amiga IFF image file format,
that literally took me, I'd say,

01:00:52.500 --> 01:00:55.260
about 90 minutes,
maybe two hours at the most,

01:00:55.370 --> 01:00:58.300
to cobble together,
and that's getting the code,

01:00:58.310 --> 01:01:00.780
cleaning it up a little bit,
ripping out some stuff,

01:01:00.780 --> 01:01:02.160
and putting it together.

01:01:02.160 --> 01:01:04.550
Clearly,
for a more sophisticated file format,

01:01:04.550 --> 01:01:06.620
it's going to take a
little bit more time,

01:01:06.620 --> 01:01:09.100
but we're not talking about
an enormous investment.

01:01:09.360 --> 01:01:12.440
It's on the order of a few
hours or a couple days,

01:01:12.500 --> 01:01:14.700
not three weeks or two months.

01:01:16.400 --> 01:01:18.400
Be cautious about what you publish.

01:01:18.400 --> 01:01:20.710
Keep in mind,
you want to help users find things,

01:01:20.720 --> 01:01:25.400
not spam them with your files for
everything that they can possibly type.

01:01:25.400 --> 01:01:28.400
Performance is critical.

01:01:28.400 --> 01:01:30.390
This is a very important thing.

01:01:30.390 --> 01:01:33.600
One of the biggest problems we
had with shipping Tiger was that

01:01:33.600 --> 01:01:42.990
importers could cause a significant
impact on the rest of the system,

01:01:42.990 --> 01:01:45.830
so you need to be careful of that.

01:01:47.100 --> 01:01:47.890
What you need to do.

01:01:48.010 --> 01:01:50.000
What's the takeaway
from this presentation?

01:01:50.000 --> 01:01:53.000
If you have a custom file format,
write an importer.

01:01:53.000 --> 01:01:54.000
That's the biggest thing.

01:01:54.000 --> 01:01:56.960
We're going to be here
today in a lab later on.

01:01:57.010 --> 01:01:58.300
We'll have a lab tomorrow morning.

01:01:58.300 --> 01:01:59.250
Come talk to us.

01:01:59.390 --> 01:02:00.120
We'll help you do it.

01:02:00.170 --> 01:02:03.840
I think in a lot of cases you'll find
that it's a pretty simple thing to do,

01:02:03.840 --> 01:02:06.610
and then your files are part
of the Spotlight system.

01:02:07.180 --> 01:02:10.550
Put useful metadata in your
documents for file formats that

01:02:10.550 --> 01:02:13.560
you're writing an importer for,
and for file formats

01:02:13.560 --> 01:02:15.100
that we already support.

01:02:15.100 --> 01:02:19.920
Make sure to put metadata in there that
users will associate with the document.

01:02:19.920 --> 01:02:22.650
And then, like I said,
come visit us in the lab

01:02:22.650 --> 01:02:24.220
so that we can help you.

01:02:26.160 --> 01:02:27.780
A couple other final things.

01:02:27.910 --> 01:02:31.860
If you're looking for more information,
of course, the developer website

01:02:31.860 --> 01:02:34.040
has a whole ton of stuff.

01:02:34.040 --> 01:02:38.320
And there are some related sessions that
I would strongly suggest you check out.

01:02:38.320 --> 01:02:40.690
There's the using the
spotlight query APIs,

01:02:40.690 --> 01:02:44.920
that's the top half of things,
later on today at 2 p.m.

01:02:44.990 --> 01:02:48.140
There's the spotlight
lab that starts at 3:30.

01:02:48.140 --> 01:02:53.380
The UTI talk which is going to be at,
yes, it is 5 o'clock today.

01:02:53.380 --> 01:02:57.220
And the lab that we
have tomorrow morning.

01:02:57.220 --> 01:03:00.910
And with that,
I guess we'll open it up to Q&A.
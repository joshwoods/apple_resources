WEBVTT

00:00:11.929 --> 00:00:14.719
a
>> Welcome to Extending Your Application with JavaScript.

00:00:14.720 --> 00:00:16.750
Introducing JavaScript Core.

00:00:16.750 --> 00:00:20.829
A new framework on Mac OS X. This is Session 157.
W

00:00:20.829 --> 00:00:24.369
I'm Geoff Garen

00:00:24.370 --> 00:00:28.770
I am an engineer here at Apple
and I am fluent in JavaScript, as well as Klingon.

00:00:28.769 --> 00:00:30.989
( Laughter )

00:00:30.989 --> 00:00:35.530
>> My manager is not here today,
so we should have a lot of fun.

00:00:35.530 --> 00:00:42.910
( Applause )

00:00:42.909 --> 00:00:48.439
>> Increasingly, developers are using
internal scripting in their applications.

00:00:48.439 --> 00:00:55.559
This is where you use script to implement essential
features and components of application logic.

00:00:55.560 --> 00:01:02.460
One application that's been in the blog sphere lately that
you may have heard of for doing this is Adobe Lightroom.

00:01:02.460 --> 00:01:09.659
Lightroom uses a scripting language to implement
all or nearly all of its user interface.

00:01:09.659 --> 00:01:14.789
So if you click on a button in Lightroom a
little bit of Lua script runs in response.

00:01:14.790 --> 00:01:20.550
Of course Lightroom is not the first
application to use this technique.

00:01:20.549 --> 00:01:24.689
And Lua is not the first language to be used for it.

00:01:24.689 --> 00:01:29.730
Computer game designers, for example, have been using
internal scripting for some time now to control the behavior

00:01:29.730 --> 00:01:33.700
of non-player characters and also the
animations of parts of the scenery.

00:01:33.700 --> 00:01:35.990
And many of the them invent their own languages.

00:01:35.989 --> 00:01:39.129
Quake invented Quake-C, which you may be familiar with.

00:01:39.129 --> 00:01:40.609
They're a bunch of others.

00:01:40.609 --> 00:01:45.409
Unreal and Unreal Tournament invented
Unreal Script for themselves.

00:01:45.409 --> 00:01:49.789
Conquest of the Aegean uses GameMonkey script,
Age of Empires

00:01:49.790 --> 00:01:55.830
and Age of Mythology invented a custom version of
Lisp, and Never Winter Nights uses NW Scripts.

00:01:55.829 --> 00:01:57.340
There are a bunch more.

00:01:57.340 --> 00:02:05.320
Another series of applications -- another category using
internal scripting is scientific modelling environments.

00:02:05.319 --> 00:02:10.590
These are applications that have an underlying model
engine and then they expose the engine through script.

00:02:10.590 --> 00:02:13.530
And you write your models in the scripting language.

00:02:13.530 --> 00:02:17.580
And you can use these to model a lot
of different scientific phenomenon.

00:02:17.580 --> 00:02:21.530
Evolution, economics, global warming.

00:02:21.530 --> 00:02:25.719
Many of the hippie sciences that we
enjoy studying here in San Francisco.

00:02:25.719 --> 00:02:27.539
There are a bunch of these languages.

00:02:27.539 --> 00:02:33.250
There's Star Logo, which is a custom version of Logo,
with the turtles that you may remember from kindergarten.

00:02:33.250 --> 00:02:37.979
There's Net Logo, which believe it or
not is a custom version of Star Logo.

00:02:37.979 --> 00:02:43.560
Stella, they like at MIT, I suspect because it has
a woman's name, and they don't see that much there.

00:02:43.560 --> 00:02:44.099
( Laughter )

00:02:44.099 --> 00:02:48.989
>> Finally, my favorite is just called Steve.

00:02:48.990 --> 00:02:55.560
Graphical modelling environments are doing this
too, so you see auto cat invented all the o lisp.

00:02:55.560 --> 00:02:59.069
Macromedia Director which we use
here at Apple, using Lingo.

00:02:59.069 --> 00:03:05.750
Maya, another really famous 3-D rendering engine has it's
own scripting language called the Maya embedded language.

00:03:05.750 --> 00:03:12.159
And finally, last but not least, even dinky little IRC
clients are wanting to make themselves scriptable these days

00:03:12.159 --> 00:03:14.159
and having to invent their own languages.

00:03:14.159 --> 00:03:19.079
And MIRC, for example, invented MIRC script.

00:03:19.080 --> 00:03:22.800
Now, these are all great applications.

00:03:22.800 --> 00:03:25.070
And it's great that they're using internal scripting.

00:03:25.069 --> 00:03:28.560
I think that they're better applications for it.

00:03:28.560 --> 00:03:32.430
Individually, these are all great
scripting languages as well.

00:03:32.430 --> 00:03:38.469
I have programmed in a number of them, I've each
worked on the underlying interpreters for some of them.

00:03:38.469 --> 00:03:45.990
But taken as a whole, this plethora of scripting
languages is growing into a minor disaster.

00:03:45.990 --> 00:03:51.629
Think of all the engineering time that could have been
spent making these great applications even greater

00:03:51.629 --> 00:03:55.139
that was instead spent in inventing
a new programming language,

00:03:55.139 --> 00:03:57.309
and then having to implement the underlying interpreter.

00:03:57.310 --> 00:04:00.780
And I can tell you from experience that is not easy.

00:04:00.780 --> 00:04:02.770
That's why I get paid the big bucks.

00:04:02.770 --> 00:04:09.180
Thunk about all the scripting time that could have been
spent writing interesting scripts for these applications

00:04:09.180 --> 00:04:13.780
that was instead spent learning the
hot new scripting language of the day.

00:04:13.780 --> 00:04:19.449
Or not spent at all -- because somebody got
fed up having to learn new scripting languages.

00:04:19.449 --> 00:04:24.659
And finally, consider all the bandwidth and
processing power that was wasted having to download all

00:04:24.660 --> 00:04:28.750
of these interpreters along side their
applications, launch them at the launch time

00:04:28.750 --> 00:04:32.740
of the application, and keep them all resident in memory.

00:04:32.740 --> 00:04:35.100
And new scripting languages are being invented all the time

00:04:35.100 --> 00:04:39.040
to suit different people's interest,
or the ideologies of the day.

00:04:39.040 --> 00:04:42.670
Here's one that I found recently on the Internet.

00:04:42.670 --> 00:04:49.189
It's called LOLCODE, and it was invented for the inevitable
take over of the world by Internet-addicted kittens.

00:04:49.189 --> 00:04:53.939
So you can see how LOLCODE from the
Filezorz example program.

00:04:53.939 --> 00:04:57.430
You begin with the manically Ha!

00:04:57.430 --> 00:04:59.550
There's a Please Open File command.

00:04:59.550 --> 00:05:03.860
So you to have to be polite in
LOLCODE, lest you be scratched.

00:05:03.860 --> 00:05:05.069
Awesome. Thanks.

00:05:05.069 --> 00:05:05.870
More politeness.

00:05:05.870 --> 00:05:08.819
There's an O Noes Clause to catch any errors.

00:05:08.819 --> 00:05:10.649
LOLCODE programmers love that.

00:05:10.649 --> 00:05:11.409
That's a great feature.

00:05:11.410 --> 00:05:15.170
And finally the final Okay, thanks, bye.

00:05:15.170 --> 00:05:26.930
And these guys even have the requisite O'Reilly Book.

00:05:26.930 --> 00:05:31.030
( Applause )

00:05:31.029 --> 00:05:34.789
>> Meow! So in our own software development
at Apple we use internal scripting,

00:05:34.790 --> 00:05:38.790
and we needed to solve this problem
of a plethora of languages.

00:05:38.790 --> 00:05:42.520
And we came up with a solution
that's worked out really well for us.

00:05:42.519 --> 00:05:43.810
JavaScript.

00:05:43.810 --> 00:05:48.240
So that's really what this presentation is about.

00:05:48.240 --> 00:05:53.800
You'll learn how we use JavaScript to give
you some ideas for your own applications.

00:05:53.800 --> 00:05:57.819
Of the benefits that we've seen,
both from internal scripting,

00:05:57.819 --> 00:06:02.740
and from using JavaScript for our internal scripting.

00:06:02.740 --> 00:06:05.250
And finally, you'll learn about JavaScript Core.

00:06:05.250 --> 00:06:08.509
A new framework that we're making available on Mac OS X

00:06:08.509 --> 00:06:12.349
so that you can imbed JavaScript in
your own applications, if you like.

00:06:12.350 --> 00:06:19.129
Here's how JavaScript Core fits in
with the overall Mac OS X technologies.

00:06:19.129 --> 00:06:24.870
You can use it stand-alone, like so, and get just
a JavaScript interpreter in your application.

00:06:24.870 --> 00:06:28.269
You can also use the WebKit framework,
which has been around for some time now.

00:06:28.269 --> 00:06:30.399
And that's the full Web browser in a box.

00:06:30.399 --> 00:06:33.169
So it brings JavaScript Core along with it,

00:06:33.170 --> 00:06:38.550
and provides it's own high level Objective-C
interface to the JavaScript language.

00:06:38.550 --> 00:06:43.900
New with JavaScript Core being a stand-alone framework
with its own API, if you have a WebKit programmer,

00:06:43.899 --> 00:06:49.169
you can now talk directly to the JavaScript engine
to do things that were not previously possible

00:06:49.170 --> 00:06:51.900
through that high level interface in WebKit.

00:06:51.899 --> 00:06:55.169
So that's how this presentation will flow.

00:06:55.170 --> 00:07:01.060
I will talk about using JavaScript Core stand alone,
but if you are a WebKit application developer

00:07:01.060 --> 00:07:05.470
or a widget plug-in developer, don't sleep
through that part of the presentation,

00:07:05.470 --> 00:07:08.630
as Tim Hatcher likes to say, because
it will be relevant to you.

00:07:08.629 --> 00:07:15.680
And I'll show you how to use it in your WebKit
applications and the WebKit plug-ins at the end.

00:07:15.680 --> 00:07:20.240
Okay. So let's get started with how we use JavaScript.

00:07:20.240 --> 00:07:25.829
Probably the place most people are most familiar with
us using JavaScript for internal scripting is Dashboard.

00:07:25.829 --> 00:07:30.159
Dashboard widgets are mini applications,
and the entire application control flow

00:07:30.160 --> 00:07:33.720
and UI response are written in JavaScript.

00:07:33.720 --> 00:07:38.060
Now you might think it's obvious that we might use
JavaScript here, because we're using the Web stack.

00:07:38.060 --> 00:07:41.620
We're using HTML and CSS to render
these mini applications as well.

00:07:41.620 --> 00:07:48.829
But we get requests all the time for why didn't you
choose Python as the programming language in Dashboard.

00:07:48.829 --> 00:07:49.919
That's my favorite language.

00:07:49.920 --> 00:07:55.129
How about Ruby Cocoa, an then I could use
Interface Builder and App Kit in Dashboard.

00:07:55.129 --> 00:07:58.680
I invented a new custom version of Haskel
and I would like to discuss it under NDA,

00:07:58.680 --> 00:08:03.650
because your widgets will be nothing with
without it -- meow, meow, meow, meow.

00:08:03.649 --> 00:08:06.069
( Laughter )

00:08:06.069 --> 00:08:11.339
>> But we went with JavaScript and it's
turned out to be a great success for us.

00:08:11.339 --> 00:08:15.379
Quartz Composer is another application using JavaScript.

00:08:15.379 --> 00:08:21.350
So Dashboard uses JavaScript to control application
control flow like you see in Adobe Lightroom.

00:08:21.350 --> 00:08:26.939
Quartz Composer uses it in a different way to enable
end-user programming in a modelling environment much

00:08:26.939 --> 00:08:30.439
like you see in Stella and Steve and Net Logo and Maya.

00:08:30.439 --> 00:08:33.679
And what you do in Quartz Composer
is you compose bits of graphics

00:08:33.679 --> 00:08:37.469
and logic into larger scale animations
like the ones you see here.

00:08:37.470 --> 00:08:41.930
Quartz Composer shifts with hundreds of predefined
interesting bits that you can plug in together.

00:08:41.929 --> 00:08:46.029
But ultimately, you want to describe
arbitrary transformations.

00:08:46.029 --> 00:08:49.879
So that's what we needed a scripting
language for, and we JavaScript for that.

00:08:49.879 --> 00:08:54.399
If you've been down to the graphics and media lab you
can see some of the great Quartz Composer animations

00:08:54.399 --> 00:08:57.189
that look even better when you put them on, like.

00:08:57.190 --> 00:08:59.690
27 L CD displays next to each other.

00:08:59.690 --> 00:09:02.580
But even if you haven't seen that
you have probably seen some

00:09:02.580 --> 00:09:04.650
of the applications where you are using Quartz Composer.

00:09:04.649 --> 00:09:10.090
So, iChat uses Quartz Composer to
animate the fake backgrounds behind you.

00:09:10.090 --> 00:09:12.980
And Time Machine also animates
all the way back to the beginning

00:09:12.980 --> 00:09:18.399
of time the big magnets itself using
Quartz Composer and JavaScript.

00:09:18.399 --> 00:09:23.100
iDVD uses JavaScript for its menu themes.

00:09:23.100 --> 00:09:26.480
When you pop a DVD into a DVD player
you see an animated menu.

00:09:26.480 --> 00:09:33.519
And redescribe those animations with JavaScript so we can
dump in new animations and see how they look pretty easily.

00:09:33.519 --> 00:09:35.850
And so here, this pretty interesting.

00:09:35.850 --> 00:09:41.550
We're using JavaScript as a kind of an active data
format, where rather than reading in a bunch of data

00:09:41.549 --> 00:09:46.969
about how the animation should work, we just
load the animation in it, and it executes itself.

00:09:46.970 --> 00:09:51.920
This is a lot like game designers where
they load an unclear character into memory

00:09:51.919 --> 00:09:57.110
and it executes itself and the
scenery runs itself along side.

00:09:57.110 --> 00:10:03.519
The installer uses JavaScript throughout installer
packages, and the one that I'll call your attention to is

00:10:03.519 --> 00:10:10.759
that a package decides for itself whether it is capable of
installing on the volumes of your system, as you see here.

00:10:10.759 --> 00:10:14.860
And it's a JavaScript that runs to make that determination.

00:10:14.860 --> 00:10:19.550
So once again here we're kind of using JavaScript
as kind of an active data format, where, you know,

00:10:19.549 --> 00:10:23.889
instead of trying to read in complex registry keys
or any of that other kind of craziness to decide

00:10:23.889 --> 00:10:27.689
for you whether your package can
install on a certain volume.

00:10:27.690 --> 00:10:32.770
We just ask your package, it runs a
script and gives us a yes or no answer.

00:10:32.769 --> 00:10:38.120
Finally, iSync uses JavaScript as
a full-blown plug-in architecture.

00:10:38.120 --> 00:10:41.919
iSync has default behavior for
syncing devices with your Macintosh.

00:10:41.919 --> 00:10:48.559
But if you release a new device that maybe has iTunes play
list, or new kinds of context or notes or things like that.

00:10:48.559 --> 00:10:50.759
You want to write your own plug-in syncing logic.

00:10:50.759 --> 00:10:58.460
So you write that in JavaScript and you use the underlying
syncing framework to do the heavy lifting for you.

00:10:58.460 --> 00:11:06.190
And those are just the uses of JavaScript that
I can tell you about without having to kill you.

00:11:06.190 --> 00:11:08.530
( Laughter )

00:11:08.529 --> 00:11:13.839
>> So we have a demo for you of another application
using JavaScript to try to show you that it's not just us

00:11:13.840 --> 00:11:16.310
at Apple who have drunk the JavaScript punch.

00:11:16.309 --> 00:11:20.889
Third party applications are also integrating
JavaScript, and a great example of that is Colloquy,

00:11:20.889 --> 00:11:23.809
an IRC client that we use on the WebKit team.

00:11:23.809 --> 00:11:28.799
In contrast to MIRC that had to spend all that
time inventing its own scripting language,

00:11:28.799 --> 00:11:35.819
Colloquy just builds on the existing JavaScript
capabilities of Mac OS X. And it was a bit of a pioneer here

00:11:35.820 --> 00:11:39.700
because it using the WebKit framework, which has
been around for some time now in order to do that.

00:11:39.700 --> 00:11:42.210
So without further ado, demo machine, please.

00:11:42.210 --> 00:11:43.540
Here's Brady Eidson.

00:11:43.539 --> 00:11:47.019
( Applause )

00:11:47.019 --> 00:11:51.679
>> Thank you, Jeff.

00:11:51.679 --> 00:11:57.239
As Jeff just mentioned, Colloquy is an IRC client
that the Safari and WebKit team uses to interact

00:11:57.240 --> 00:12:03.779
with the open search community in open pound kit in
free node, but we also use it on a private IRC server

00:12:03.779 --> 00:12:07.589
because we're spread out over many
offices, many towns, even.

00:12:07.590 --> 00:12:11.120
So it helps us get our work done.

00:12:11.120 --> 00:12:16.560
We need to finish up Leopard, we need to talk about new
app features, and most importantly we need to coordinate

00:12:16.559 --> 00:12:20.129
and make sure we go to lunch and
afternoon coffee at the right time.

00:12:20.129 --> 00:12:24.389
So I'm going to go ahead and hop in there really quick.

00:12:24.389 --> 00:12:26.679
This is our super-seeker panel.

00:12:26.679 --> 00:12:32.500
I am going to go ahead and -- uh-oh.

00:12:37.090 --> 00:12:39.100
Little hiccup here.

00:12:39.100 --> 00:12:41.590
Bear with me.

00:12:41.590 --> 00:12:45.300
Relaunch. Just go -- okay.

00:12:45.299 --> 00:12:47.609
This is supposed to look a little better.

00:12:47.610 --> 00:12:49.500
This is where we would talk normally.

00:12:49.500 --> 00:12:54.779
I would say hi here, but to ping everyone in the
room I would normally have to add their name

00:12:54.779 --> 00:12:57.860
and then say, hi, hi, hi, to 15 different people.

00:12:57.860 --> 00:13:02.070
But it's a lot easier if I can just type
one command to greet everyone and say,

00:13:02.070 --> 00:13:06.970
hey, let's do lunch after of the session.

00:13:06.970 --> 00:13:11.830
So this is the slash announce.

00:13:11.830 --> 00:13:13.259
After relaunch.

00:13:13.259 --> 00:13:16.250
I will go ahead and relaunch and make sure everyone can see.

00:13:16.250 --> 00:13:24.240
It's going, it's going, it's going.

00:13:24.240 --> 00:13:28.240
Bear with us here just a second.

00:13:28.240 --> 00:13:29.070
Okay. Here it goes.

00:13:29.070 --> 00:13:31.629
So let me try this one more time.

00:13:33.070 --> 00:13:40.370
Hi. Let's do lunch afterwards.

00:13:40.370 --> 00:13:41.250
Oh dear. Okay.

00:13:41.250 --> 00:13:45.370
So as you can see this quick command easily
appended everyone's name in the room.

00:13:45.370 --> 00:13:46.950
And then added my message.

00:13:46.950 --> 00:13:49.509
Now slash announce is not an IRC command.

00:13:49.509 --> 00:13:51.450
It is not built into Colloquy.

00:13:51.450 --> 00:14:00.590
It is something I wrote myself in JavaScript -- I wrote
myself in JavaScript to augment Colloquy's behavior.

00:14:00.590 --> 00:14:02.940
So let's go ahead and look at the code here.

00:14:02.940 --> 00:14:05.270
As you can see it's pretty simple.

00:14:05.269 --> 00:14:12.009
Colloquy calls this process user command whenever
anyone types a slash, blah-dee-blah-dah thing.

00:14:12.009 --> 00:14:15.529
It's about just under 20 lines of JavaScript code.

00:14:15.529 --> 00:14:18.850
Now there's a few interesting things to notice here.

00:14:18.850 --> 00:14:21.420
Primarily, Colloquy is not a Web browser.

00:14:21.419 --> 00:14:26.990
There is no window here, there is no document
here, I am not using DOS, I am not using the frame.

00:14:26.990 --> 00:14:31.129
Instead I am using Colloquy's own custom object model.

00:14:31.129 --> 00:14:38.179
View here is JV chat view, connection
is an MV chat connection.

00:14:38.179 --> 00:14:43.989
And you can see down here I am actually
dynamically creating a JV mutable chat message

00:14:43.990 --> 00:14:48.810
with the text I have compiled together,
and then I can send it out to the channel

00:14:48.809 --> 00:14:51.629
and then I can echo it on my local display.

00:14:51.629 --> 00:14:57.059
So in under 20 lines of JavaScript I have added
a very useful command to my IRC experience.

00:14:57.059 --> 00:15:02.639
I've written a much more involved plug-in
that does some pretty cool things.

00:15:02.639 --> 00:15:09.990
And despite our experience with what we did last year I
am going to try it again to show you this new plug-in.

00:15:09.990 --> 00:15:12.840
I am going to hop on Pound WebKit from up on stage.

00:15:12.840 --> 00:15:15.070
And I can already see that someone's already messaged me.

00:15:15.070 --> 00:15:16.850
That's exciting.

00:15:18.179 --> 00:15:19.309
Okay. And here I am.

00:15:19.309 --> 00:15:20.969
In Pound WebKit.

00:15:20.970 --> 00:15:22.580
People are talking.

00:15:22.580 --> 00:15:24.410
Fist post, interesting.

00:15:24.409 --> 00:15:26.939
Interestingness aside.

00:15:26.940 --> 00:15:28.370
Okay. Oh my gosh, I am on stage.

00:15:28.370 --> 00:15:34.700
Yes. So a lot of the time in Pound WebKit there's
so much going on -- like now it's starting to go --

00:15:34.700 --> 00:15:37.390
that it's hard to see exactly who you want to talk to.

00:15:37.389 --> 00:15:41.019
So let me go ahead and show you my plug-in.

00:15:41.019 --> 00:15:48.639
I am going to customize Colloquy's tool bar here,
and you can see I'm actually adding a tool bar item.

00:15:48.639 --> 00:15:50.389
And I'm doing this all in JavaScript.

00:15:50.389 --> 00:15:53.169
And I'm going to go ahead and turn filters on.

00:15:53.169 --> 00:15:54.269
Filter is active.

00:15:54.269 --> 00:15:57.679
Okay, this is a little bit better.

00:15:57.679 --> 00:16:02.349
It's still going to be hard to talk to exactly
who I want to talk to, so I can go ahead

00:16:02.350 --> 00:16:04.509
and change the way my filter works a little.

00:16:04.509 --> 00:16:06.750
Now everyone's just completely blocked.

00:16:06.750 --> 00:16:08.500
Another thing I did all in JavaScript.

00:16:08.500 --> 00:16:14.080
It's kind of hard to see, but there's actually a tool
tip here if I want to see what the message actually was.

00:16:14.080 --> 00:16:16.490
And I am going go ahead and talk to Sam.

00:16:16.490 --> 00:16:21.379
So let me go ahead and specifically unblock him.

00:16:21.379 --> 00:16:24.909
And now I think I can talk to Sam.

00:16:24.909 --> 00:16:27.620
Ah. There we go.

00:16:27.620 --> 00:16:33.149
Ready to do all the work on Safari SJ promised

00:16:33.149 --> 00:16:33.860
This is very important.

00:16:33.860 --> 00:16:35.430
I need to ask him this.

00:16:35.429 --> 00:16:37.049
And he's going to reply.

00:16:37.049 --> 00:16:38.079
Okay. Awesome.

00:16:38.080 --> 00:16:40.050
Okay, so this is pretty cool.

00:16:40.049 --> 00:16:47.009
Hopefully I have given you a pretty good idea of
some pretty cool things you can do using -- uh-oh.

00:16:47.009 --> 00:16:49.590
Well, let me go ahead and -- no, never mind.

00:16:49.590 --> 00:16:55.060
So it's a pretty cool example of what you can
do in JavaScript as a plug-in architecture.

00:16:55.059 --> 00:17:02.729
One last thing I am going to do before I hand the
stage back over to Jeff is go ahead and use this one.

00:17:02.730 --> 00:17:05.650
I am slowly going to message everyone in the room.

00:17:05.650 --> 00:17:07.090
A lot of people.

00:17:07.089 --> 00:17:13.970
And back to you, Jeff?

00:17:13.970 --> 00:17:18.089
( Applause )

00:17:18.089 --> 00:17:20.109
>> Thanks Brady.

00:17:20.109 --> 00:17:22.439
So that was the Colloquy IRC client.

00:17:22.440 --> 00:17:25.940
And we showed you that it uses JavaScript
as a full-blown plug-in architecture.

00:17:25.940 --> 00:17:28.240
It provides a custom object model.

00:17:28.240 --> 00:17:33.410
So in JavaScript, inside Colloquy you're interacting
with a chat application and chat messages rather

00:17:33.410 --> 00:17:38.620
than the JavaScript that you may be used to where
you're interacting with a window or a document.

00:17:38.619 --> 00:17:40.500
And it's a third party application.

00:17:40.500 --> 00:17:45.029
So not only Apple is cuckoo for JavaScript.

00:17:45.029 --> 00:17:49.279
Here are the benefits that we've
seen from internal scripting.

00:17:49.279 --> 00:17:52.009
The big one is high level thinking.

00:17:52.009 --> 00:17:54.879
Take the example of a non-player
character in a game of Halo.

00:17:54.880 --> 00:17:57.210
Its behavior is fairly high level.

00:17:57.210 --> 00:18:02.930
You know, it hides behind a rock, waits for you to
show up, jumps out from the rock, goes ah, ah, ah, ah,

00:18:02.930 --> 00:18:04.450
shoots at you, hides behind the rock again.

00:18:04.450 --> 00:18:09.930
So it's nice to be able to describe that sort
of high level logic in a high level program.

00:18:09.930 --> 00:18:13.660
You don't want to have to worry about, you know,
the distance that I jump out from behind the rock is

00:18:13.660 --> 00:18:17.910
that a 32-bit imager or a 64-bit imager, and
is it stored on the stack or on the heap.

00:18:17.910 --> 00:18:22.130
And if it's on the heap did I create it through
malloc, or through new, or through a CF allocator,

00:18:22.130 --> 00:18:25.870
and which CF allocator did I use, and do
I need to release it after I create it.

00:18:25.869 --> 00:18:28.869
Who's retaining it, if I did it through
malloc, how do I know when it's going

00:18:28.869 --> 00:18:31.649
to be deleted and how long I can use it -- et cetera.

00:18:31.650 --> 00:18:33.030
( Laughter )

00:18:33.029 --> 00:18:38.460
>> The ability to leverage non-expert programmers.

00:18:38.460 --> 00:18:41.590
When Al Gore goes out to commission
a study on global warming he wants

00:18:41.589 --> 00:18:44.879
to hire a climate expert, not a C++ expert.

00:18:44.880 --> 00:18:47.100
And very few people are both.

00:18:47.099 --> 00:18:52.309
So it's nice to be able to provide an
environment where non-experts can program.

00:18:52.309 --> 00:18:53.869
We've seen this in Dashboard too.

00:18:53.869 --> 00:19:00.809
There are a lot of non-experts making really
interesting Dashboard widgets for better or for worse.

00:19:00.809 --> 00:19:01.369
You know?

00:19:01.369 --> 00:19:03.739
( Laughter )

00:19:03.740 --> 00:19:09.000
>> Quick and easy iteration, many of the things we've
talked about like the behavior of an unclear character

00:19:09.000 --> 00:19:15.500
or the animation of a scene, it's not easy to tell
in advance what's going to look good or feel good.

00:19:15.500 --> 00:19:19.220
You know, you want to be able to play around,
make this player a little bit more aggressive

00:19:19.220 --> 00:19:22.829
and see whether it kills you right away or see if
it's a little more interesting to play against --

00:19:22.829 --> 00:19:26.679
make this animation faster, make it
slower, use sign instead of could he sign.

00:19:26.680 --> 00:19:32.630
It's nice to be able to experiment with, you know, being
afraid of having to recompile potentially thousands

00:19:32.630 --> 00:19:37.930
of different files or use a render
form or anything like that.

00:19:37.930 --> 00:19:40.140
Finally, end user modifications.

00:19:40.140 --> 00:19:44.009
In an application like Quartz Composer,
end user modifications are a requirement.

00:19:44.009 --> 00:19:46.059
That's the whole point of the application.

00:19:46.059 --> 00:19:50.679
But even in your applications, if they're
not designed for end user modification,

00:19:50.680 --> 00:19:54.470
end user modification can be a really great value add.

00:19:54.470 --> 00:19:59.140
So, in Colloquy, for example, it's nice for
expert programmers to be able to do what they

00:19:59.140 --> 00:20:04.000
like with your application, but they can also
develop a community where they up load their plug-ins

00:20:04.000 --> 00:20:06.720
on line, people talk about them and share them.

00:20:06.720 --> 00:20:11.910
People love to do this with computer games
where they'll design new AI's to play against,

00:20:11.910 --> 00:20:14.519
they'll trade them on the Internet,
they will have tournaments for them.

00:20:14.519 --> 00:20:18.769
And a community can develop around your application,
and your application can continue to growing

00:20:18.769 --> 00:20:25.200
into the future long after you
yourself have stopped working on it.

00:20:26.829 --> 00:20:32.519
For internal scripting, here are the benefits that
we've seen for using JavaScript as a language.

00:20:32.519 --> 00:20:34.900
The big one is everybody knows it.

00:20:34.900 --> 00:20:36.860
JavaScript is the language that powers the Internet.

00:20:36.859 --> 00:20:43.299
So there are literally according to Google billions of
applications that exist that were written with JavaScript.

00:20:43.299 --> 00:20:50.419
The sad truth of it is, you can get on line on any sort of
message board and find thousands and thousands of people

00:20:50.420 --> 00:20:55.539
who haven't really mastered basic
punctuation, grammar, or even politeness.

00:20:55.539 --> 00:21:00.629
But they are experts in JavaScript and
they can do your scripting for you.

00:21:00.630 --> 00:21:04.070
Even if you don't know JavaScript, you know JavaScript.

00:21:04.069 --> 00:21:07.299
Because you know C, or C++, or Java,

00:21:07.299 --> 00:21:12.299
and all the basic control flow primitives
and object access behave the same way.

00:21:12.299 --> 00:21:18.639
So you can write your own interesting scripts even if
you don't know the advanced prototype based inheritance.

00:21:18.640 --> 00:21:23.400
You can write your own interesting scripts without
having much of an introduction to JavaScript at all.

00:21:24.630 --> 00:21:27.140
JavaScript was designed for internal
scripting on the Internet.

00:21:27.140 --> 00:21:30.390
It was designed to script the internal
object model of the Web browser.

00:21:30.390 --> 00:21:35.600
So there are some things built into the
language to support that in your applications.

00:21:35.599 --> 00:21:37.789
It's dynamic and extensible.

00:21:37.789 --> 00:21:45.289
So if you have a function that you all today that takes two
arguments and somebody writes a plug-in for that function.

00:21:45.289 --> 00:21:51.159
And tomorrow you want to upgrade your application, add some
capabilities and start passing three arguments, that's okay.

00:21:51.160 --> 00:21:53.380
The old plug-in isn't going to crash.

00:21:53.380 --> 00:21:54.780
It isn't going to have to recompile.

00:21:54.779 --> 00:21:57.789
It will just work -- and ignore that extra argument.

00:21:57.789 --> 00:22:05.789
The dinism and extensibility includes the very object
model in JavaScript, prototype-based inheritance means

00:22:05.789 --> 00:22:09.450
that the objects themselves and the interfaces are dynamic.

00:22:09.450 --> 00:22:13.850
So there are frameworks on the Internet
like Dojo, Prototype, Scriptalicious,

00:22:13.849 --> 00:22:17.439
that extend the underlying object model of the Web browser.

00:22:17.440 --> 00:22:23.730
Now every time we release a new version of the Web browser
we're extending the underlying object model as well

00:22:23.730 --> 00:22:27.289
to improve compatibility and add
features for Web developers.

00:22:27.289 --> 00:22:31.519
And these two sets of extensions coexist peacefully.

00:22:31.519 --> 00:22:37.180
We don't have to recompile the Internet or anything
like that every time we release a new Web browser.

00:22:37.180 --> 00:22:40.870
And the same is true of your own applications.

00:22:40.869 --> 00:22:42.939
The language is hermetically sealed.

00:22:42.940 --> 00:22:48.220
So by default, JavaScript can talk to nobody but itself.

00:22:48.220 --> 00:22:51.089
In that way it's a lot like many programmers.

00:22:51.089 --> 00:22:53.149
( Laughter )

00:22:53.150 --> 00:22:54.870
>> It can't talk to the file system.

00:22:54.869 --> 00:23:01.289
It can't talk to the network, it can't allocate arbitrary
memory, it can't invoke arbitrary symbols in your binary,

00:23:01.289 --> 00:23:08.119
it can't run through your NS View hierarchy looking for a
specific UI configuration that it wants to push buttons in.

00:23:08.119 --> 00:23:11.699
And this is really important for future
proofing your plug-in architecture.

00:23:11.700 --> 00:23:14.940
We have a plug-in architecture in
the Web browser, and we say, okay,

00:23:14.940 --> 00:23:18.299
plug-in developers, this is how your plug-ins should behave.

00:23:18.299 --> 00:23:23.569
But ultimately the plug-ins are written in lower
level languages, so they can do whatever they want.

00:23:23.569 --> 00:23:24.559
And they do.

00:23:24.559 --> 00:23:31.559
So when we change the underlying user interface in our
application or the binary code that can get us into trouble

00:23:31.559 --> 00:23:34.869
where certain plug-ins start crashing
because the language they were written

00:23:34.869 --> 00:23:37.399
in allowed them to do things we didn't want them to do.

00:23:37.400 --> 00:23:43.800
Well, in JavaScript you are only responsible for
the APIs that you specifically export to the script.

00:23:43.799 --> 00:23:47.490
It doesn't have any native access to anything else.

00:23:47.490 --> 00:23:49.640
The language is garbage collected.

00:23:49.640 --> 00:23:53.110
So you can use your data until you don't
need it any more, an then it goes away.

00:23:53.109 --> 00:23:57.479
And it bridged efficiently with native code.

00:23:57.480 --> 00:23:58.390
This is really important.

00:23:58.390 --> 00:24:03.360
A lot of other scripting languages bridging
to native code was added on top of that.

00:24:03.359 --> 00:24:05.479
So that bridge can be pretty expensive.

00:24:05.480 --> 00:24:09.370
JavaScript was designed for bridging from the
very beginning, so it can often be as cheap

00:24:09.369 --> 00:24:13.859
as a single C function call -- which
is about as cheap as you can get.

00:24:13.859 --> 00:24:19.689
Now , a lot of people when they brag about
their scripting languages and their speed,

00:24:19.690 --> 00:24:24.539
if you'll permit me to use the Conan O'Brien nerd
voice for a moment, they like to say things like,

00:24:24.539 --> 00:24:33.309
my scripting language can compute 563
digits of pi in under 63 seconds --

00:24:35.220 --> 00:24:39.930
well, you're not using script to compute 573 digits of pi.

00:24:39.930 --> 00:24:42.390
You're using script to communicate with your applications.

00:24:42.390 --> 00:24:46.660
So the essential feature of scripting
performance is how fast it can do that.

00:24:46.660 --> 00:24:49.860
And JavaScript can do it fast.

00:24:49.859 --> 00:24:52.259
Finally, JavaScript supports inline object notation.

00:24:52.259 --> 00:24:54.609
We call this JSON -- JavaScript object notation.

00:24:54.609 --> 00:24:56.559
If you don't know what this is, that's okay.

00:24:56.559 --> 00:24:57.329
Forget about it.

00:24:57.329 --> 00:25:03.039
If you do know what it is, for example, if you're a game
designer and you like to use rule sets and lists and tables

00:25:03.039 --> 00:25:08.829
to describe the behavior of characters in different
situations, JavaScript has a rich syntactic support

00:25:08.829 --> 00:25:12.659
for those kinds of lists and tables inline and the language.

00:25:12.660 --> 00:25:19.730
Now that we're introducing JavaScript Core there are even
more benefits to using JavaScript in your application

00:25:19.730 --> 00:25:26.900
on Mac OS X. And the big one is that it's a part
of Mac OS X. So if your end users are using Safari,

00:25:26.900 --> 00:25:32.390
or if they're using the installer, or Dashboard, or iChat,
or Time Machine, or any of these other applications,

00:25:32.390 --> 00:25:37.259
the cost to you for firing up the
JavaScript interpreter is zero.

00:25:37.259 --> 00:25:38.609
Because it's all ready in memory.

00:25:38.609 --> 00:25:40.250
It's a shared framework.

00:25:40.250 --> 00:25:46.440
Similarly, because JavaScript Core is such an essential
component of our operating system and is now available

00:25:46.440 --> 00:25:52.680
on many platforms, such a component of a lot of our
development, we put a lot of development effort into it.

00:25:52.680 --> 00:25:56.660
So as JavaScript Core gets better,
your applications get better.

00:25:56.660 --> 00:25:59.430
Go to sleep, two months later, your application is faster.

00:25:59.430 --> 00:26:01.029
How did that happen?

00:26:01.029 --> 00:26:04.210
Because we weren't sleeping -- ever.

00:26:06.309 --> 00:26:07.399
It's fast.

00:26:07.400 --> 00:26:14.410
We showed you in the key note that JavaScript Core powers
the fastest Web browser in the world according to iBench.

00:26:14.410 --> 00:26:18.680
So I mentioned before that the language
is designed for efficient bridging.

00:26:18.680 --> 00:26:23.340
But of course you need implementation that
takes advantage of that design, and we have one.

00:26:23.339 --> 00:26:25.730
And finally, it's open source.

00:26:25.730 --> 00:26:30.150
So there are a few features that you think would help
out in your application, you don't have to go off

00:26:30.150 --> 00:26:33.120
and invent your own language and write your own interpreter.

00:26:33.119 --> 00:26:39.049
You can if you like just implement the features that
you think would be helpful in the open source project,

00:26:39.049 --> 00:26:42.619
and then they become a part of Mac OS X going forward.

00:26:42.619 --> 00:26:47.169
So that's the sales pitch.

00:26:47.170 --> 00:26:50.120
And the rest of this presentation
is all about teaching you how

00:26:50.119 --> 00:26:54.409
to use the JavaScript Core framework
in your own applications.

00:26:54.410 --> 00:26:58.769
JavaScript Core is a C API in the
style of the Core APIs on Mac OS X.

00:26:58.769 --> 00:27:02.829
So it is the lowest interface to your JavaScript engine.

00:27:02.829 --> 00:27:03.480
It's complete.

00:27:03.480 --> 00:27:07.319
Everything that you find in the E C M A standard
and some things that you don't find there

00:27:07.319 --> 00:27:10.509
but we've found useful you can do through this API.

00:27:10.509 --> 00:27:12.930
And it's light weight.

00:27:12.930 --> 00:27:17.789
It's just the JavaScript and none of the
rest of the Web stacks, it is the JavaScript,

00:27:17.789 --> 00:27:22.089
the whole JavaScript, and nothing but the JavaScript.

00:27:22.089 --> 00:27:28.189
It's thread safe, so you can run your scripts on a
secondary thread in order to keep the UI thread responsive.

00:27:28.190 --> 00:27:33.769
And it requires Tiger with the Safari
3 O update installed -- or greater.

00:27:33.769 --> 00:27:39.329
So we've put a lot of work into making sure that this new
technology works on our older operating system as well

00:27:39.329 --> 00:27:44.779
so you can get a lot of value by adding
it to your application right away.

00:27:44.779 --> 00:27:49.309
Widget plug-ins, however, will require Leopard or greater.

00:27:50.589 --> 00:27:57.259
To begin, before I go into the API itself, I'd like to
give you a brief overview of the JavaScript language.

00:27:57.259 --> 00:28:00.359
I am not going to teach you JavaScript,
there are better resources for that.

00:28:00.359 --> 00:28:04.269
But I do need to introduce you to some core concepts

00:28:04.269 --> 00:28:08.389
so that you can understand how the API
works, because it reflects those concepts.

00:28:08.390 --> 00:28:13.880
And there is no better place to start than the classic
hello world that you'll find in any JavaScript textbook.

00:28:13.880 --> 00:28:17.430
This will bring up an alert in a
Web browser that says, hello world.

00:28:17.430 --> 00:28:23.640
But I am here today to tell you that all
of these text books are dirty rotten liars.

00:28:23.640 --> 00:28:26.390
Alert is not a part of the JavaScript language.

00:28:26.390 --> 00:28:33.230
It has nothing to do with JavaScript and everything to do
with the capabilities of a Web browser to bring up a window.

00:28:33.230 --> 00:28:37.099
So the real JavaScript hello world would look like this.

00:28:37.099 --> 00:28:39.179
JavaScript can create the string hello world.

00:28:39.180 --> 00:28:41.980
It has a rich library for manipulating those strings,

00:28:41.980 --> 00:28:45.180
for processing them with regular
expressions and things like that.

00:28:45.180 --> 00:28:49.090
But ultimately what JavaScript does is it
hands the string off to your application,

00:28:49.089 --> 00:28:52.740
and then your application decides what to do with it.

00:28:52.740 --> 00:28:57.690
So I've drawn you a bit of a key note stick
figure to show you exactly what I mean.

00:28:57.690 --> 00:28:59.830
This is little Jimmy JavaScript.

00:28:59.829 --> 00:29:03.319
Then this is the JavaScript language, just by himself.

00:29:03.319 --> 00:29:10.049
Pretty svelte language, just the basic control
flow and those built in concepts like functions.

00:29:10.049 --> 00:29:15.659
What we showed you earlier in Colloquy was Jimmy
JavaScript dressed up as the Colloquy application.

00:29:15.660 --> 00:29:21.160
It absorbed the Colloquy object model that
was reflected in the script that we used.

00:29:21.160 --> 00:29:27.440
Now what people usually mean when they say JavaScript
is actually Jimmy JavaScript looking like this.

00:29:27.440 --> 00:29:34.630
Where he has absorbed the whole thousands of APIs
that we make available for all Web programming.

00:29:34.630 --> 00:29:37.440
What's important to remember is that
those of a part of the Web browser

00:29:37.440 --> 00:29:39.880
and they're not a part of the JavaScript language.

00:29:39.880 --> 00:29:44.850
So I have a table here to show you
exactly where the dividing line is.

00:29:44.849 --> 00:29:46.829
This is what's part of the JavaScript language.

00:29:46.829 --> 00:29:49.720
Those basic concepts, objects,
arrays, regular expressions --

00:29:49.720 --> 00:29:54.269
anything that you would find in this other
descent programming or scripting language.

00:29:54.269 --> 00:29:58.619
What's a part of the Web browser, which is
separate from JavaScript itself, is the window.

00:29:58.619 --> 00:30:03.209
That window that you see -- that's a Web browser,
that's not necessarily in your application.

00:30:03.210 --> 00:30:06.960
So things that hang off the window are
also not a part of the JavaScript language.

00:30:06.960 --> 00:30:09.750
The document, for example.

00:30:09.750 --> 00:30:17.509
The set time out function that's a part of that window
interface, and XML JPG request, just to name a couple.

00:30:17.509 --> 00:30:21.269
So we have a JavaScript engine that
is just the JavaScript language.

00:30:21.269 --> 00:30:25.269
And if you're an application like Quartz
Composer, you don't want those Web browser things.

00:30:25.269 --> 00:30:29.000
You don't want people making their own time
outs, because you have your own animation timer.

00:30:29.000 --> 00:30:32.799
You don't want people making synchronous
requests over the network in the middle

00:30:32.799 --> 00:30:34.990
of an animation -- and you don't need it.

00:30:34.990 --> 00:30:38.680
So we have your stand alone Java
library for applications like that.

00:30:38.680 --> 00:30:43.110
If you're looking at the slide and you say to
yourself, boy, I don't know what I would do in my life

00:30:43.109 --> 00:30:45.669
without XML HJPG requests -- that's a good sign

00:30:45.670 --> 00:30:49.480
that you actually do want the full Web
browser in a box in your application.

00:30:49.480 --> 00:30:51.789
And that's what the WebKit framework is for.

00:30:51.789 --> 00:30:57.369
We have a demo for you of the most basic
JavaScript interpreter that you can build.

00:30:57.369 --> 00:30:59.009
It's just a few lines of code.

00:30:59.009 --> 00:31:02.789
And for that I will invite to the stage my friend
and colleague Alice Liu.

00:31:02.789 --> 00:31:05.029
Could we have the demo machine please.

00:31:05.029 --> 00:31:09.990
( Applause )

00:31:09.990 --> 00:31:12.150
>> Thanks, Jeff.

00:31:12.150 --> 00:31:16.120
So I will be showing you a JavaScript interpreter.

00:31:16.119 --> 00:31:22.279
And in this app we will be using the newly
available JavaScript Core to execute the statements.

00:31:22.279 --> 00:31:29.879
So keeping in mine with what Jeff has just mentioned about
what statements are supported by the JavaScript language

00:31:29.880 --> 00:31:34.420
as opposed to the window-related
functions that you're so used

00:31:34.420 --> 00:31:37.480
to when you're experimenting with
JavaScript code in the browser.

00:31:37.480 --> 00:31:47.940
I am going execute some statements
that will work and some that won't.

00:31:49.049 --> 00:31:53.009
So here's our JavaScript interpreter.

00:31:53.009 --> 00:31:58.779
And very simple, here's we'll insert the
statements and we'll get our results down here.

00:31:58.779 --> 00:32:03.259
Let's try some really simple statements.

00:32:03.259 --> 00:32:06.150
Let try a date object first.

00:32:06.150 --> 00:32:11.410
And this statement is going to give us I string
that gives us the exact date and time right now.

00:32:11.410 --> 00:32:16.380
That's pretty simple, let's do
some things a little bit different.

00:32:16.380 --> 00:32:18.050
Let's execute a statement.

00:32:18.049 --> 00:32:20.409
And this is called what is today.

00:32:20.410 --> 00:32:25.580
And it's going to use that date object
and give us back just the date string.

00:32:25.579 --> 00:32:31.500
But if I execute this statement here it will give us
just the definition of the function -- which it does.

00:32:31.500 --> 00:32:33.230
So that's good.

00:32:33.230 --> 00:32:37.309
And if I run it, then it will give us just the date string.

00:32:37.309 --> 00:32:39.009
Which is what I expect.

00:32:39.009 --> 00:32:40.420
Okay. So those all work.

00:32:40.420 --> 00:32:42.150
And they're simple enough.

00:32:42.150 --> 00:32:48.550
But just to drive home what Jeff was
just talking about, about hello world.

00:32:48.549 --> 00:32:52.970
The classic alert, hello world, that everyone does --

00:32:52.970 --> 00:32:58.600
and it really is true that this is
not part of the JavaScript language.

00:33:00.000 --> 00:33:05.470
So although my examples were very simple,
surely you can envision the great benefit

00:33:05.470 --> 00:33:09.120
of leveraging the power of the language in your application.

00:33:09.119 --> 00:33:11.019
And doing so is very simple.

00:33:11.019 --> 00:33:15.920
And I'll show you how sample it is
by opening up the Xcode project.

00:33:20.710 --> 00:33:25.610
So this Xcode project does some really basic things.

00:33:25.609 --> 00:33:32.659
The very first thing you need to do is you need to
link JavaScript Core as a framework, which we do here.

00:33:32.660 --> 00:33:35.490
The next thing you need to do is actually use it, right?

00:33:35.490 --> 00:33:40.730
So in this function this is where
we use it, called evaluate script.

00:33:40.730 --> 00:33:43.690
And in evaluate script we do just four simple things.

00:33:43.690 --> 00:33:48.029
We first need to create a string to house the command.

00:33:48.029 --> 00:33:53.170
And next we evaluate that command.

00:33:53.170 --> 00:33:57.060
When -- after we do so, we'll get a
result and we save it in a string.

00:33:57.059 --> 00:34:01.690
And lastly, we need to clean up after
ourselves, which this line does right here.

00:34:01.690 --> 00:34:04.450
And it's really as simple as that.

00:34:04.450 --> 00:34:12.000
Back to you, Jeff.

00:34:12.000 --> 00:34:14.989
( Applause )

00:34:14.989 --> 00:34:16.309
>> Thank you, Alice.

00:34:16.309 --> 00:34:18.969
That was the basic JavaScript interpreter.

00:34:18.969 --> 00:34:20.480
It shows you JavaScript in the buff.

00:34:20.480 --> 00:34:23.199
Jimmy JavaScript dressed up with no clothes at all.

00:34:23.199 --> 00:34:24.579
Just the language itself.

00:34:24.579 --> 00:34:26.940
It's implemented in very few lines of code.

00:34:26.940 --> 00:34:32.400
So we do try to make the easy things easy
for you, and the difficult things possible.

00:34:32.400 --> 00:34:34.039
And we showed that execution can fail.

00:34:34.039 --> 00:34:35.380
You're running arbitrary scripts.

00:34:35.380 --> 00:34:40.750
They may be malformed, so you do need
to check for failure and exceptions.

00:34:40.750 --> 00:34:42.550
Here is the code.

00:34:42.550 --> 00:34:45.970
Once again, and I'll step through it with
you so you'll understand what we're doing.

00:34:45.969 --> 00:34:50.339
At the top we have a JavaScript in a JS string ref.

00:34:50.340 --> 00:34:53.220
So the JavaScript library has its own strings.

00:34:53.219 --> 00:34:54.359
We don't use CF string.

00:34:54.360 --> 00:35:00.660
And this is because JavaScript uses strings in very
different ways that you use in a regular application.

00:35:00.659 --> 00:35:03.039
So everything that we do in this API we do for performance.

00:35:03.039 --> 00:35:07.880
And one of those things is we use our
own internal representation of strings.

00:35:07.880 --> 00:35:16.500
So once you have a string what you do is you call JS Global
context to create, to create a JavaScript execution context.

00:35:16.500 --> 00:35:23.900
You call JS Evaluate Script to evaluate
your script in that execution context.

00:35:23.900 --> 00:35:25.369
And then you get a result back.

00:35:25.369 --> 00:35:26.989
And if you got a result, you can use it.

00:35:26.989 --> 00:35:30.959
If execution failed, if there was an exception
thrown, then the exception will be null.

00:35:30.960 --> 00:35:32.440
And you do need to check for null.

00:35:32.440 --> 00:35:40.190
Because unless an API specifically says that you
can pass null in certain circumstances, you can't.

00:35:40.190 --> 00:35:45.550
Finally, we call JS Global Context
Release to release that execution context

00:35:45.550 --> 00:35:48.600
and all of the resources associated with it.

00:35:48.599 --> 00:35:52.880
Now this result that we get back is a JS Value Ref.

00:35:52.880 --> 00:35:55.730
So what is that?

00:35:55.730 --> 00:35:59.219
Well there are only two JavaScript data types in this API.

00:35:59.219 --> 00:36:02.169
JavaScript's a pretty simple, straight forward language.

00:36:02.170 --> 00:36:04.639
So the base type in JS Value Ref.

00:36:04.639 --> 00:36:06.650
And that means a JavaScript value.

00:36:06.650 --> 00:36:10.369
It could be any kind of JavaScript
data in the JavaScript language.

00:36:10.369 --> 00:36:13.339
The derived type is JS Object Ref.

00:36:13.340 --> 00:36:15.039
That's a JavaScript object.

00:36:15.039 --> 00:36:18.259
And according to the JavaScript
language, all objects are treated equally.

00:36:18.260 --> 00:36:21.700
So we just have one object class.

00:36:21.699 --> 00:36:27.309
So the derived type of object can be used
anywhere you use a JS value without any casting.

00:36:27.309 --> 00:36:31.699
With a JS value you can only perform primitive operations.

00:36:31.699 --> 00:36:34.689
So, converting it to a string, for example.

00:36:34.690 --> 00:36:38.860
However, it may be an object, in which
case you can ask it if it is an object.

00:36:38.860 --> 00:36:42.849
And if it is, you can cast it to a JS Object Ref.

00:36:42.849 --> 00:36:47.920
And then you can perform object operations, like getting
and setting properties or calling it as a function.

00:36:47.920 --> 00:36:51.050
I mentioned that all objects are
created equally in JavaScript,

00:36:51.050 --> 00:36:53.740
so you can even take a regular
expression and call it as a function.

00:36:53.739 --> 00:36:56.059
The API will let you do that.

00:36:56.059 --> 00:36:58.710
Of course the regular expression will just
turn around and say, I am not a function.

00:36:58.710 --> 00:37:00.220
And throw a JavaScript exception.

00:37:00.219 --> 00:37:03.849
But you know, it's safe to do that sort of thing.

00:37:03.849 --> 00:37:07.190
Just kind of silly.

00:37:07.190 --> 00:37:12.139
That's all that you need to understand in order to evaluate
a script in your application but what you really want

00:37:12.139 --> 00:37:16.529
to do is interact with the script, and enable
the script to interact with your application.

00:37:16.530 --> 00:37:21.060
And in order to describe how to do that I am
going to develop a real world example for you.

00:37:21.059 --> 00:37:25.369
I am going to write the A I for a video game in JavaScript.

00:37:25.369 --> 00:37:28.829
I love doing this with Age of Empire,
I became a little bit addicted to it.

00:37:28.829 --> 00:37:30.969
So I'm doing it now in my own application.

00:37:30.969 --> 00:37:36.869
And keeping in mind the theme of WWDC going
back to the beginning of time on the desktop.

00:37:36.869 --> 00:37:42.819
I am going back to the beginning of time in video games
with the original and still the greatest video game -- Pong.

00:37:42.820 --> 00:37:47.800
So on the right we have an AI that's going to
control the behavior of the non player character.

00:37:47.800 --> 00:37:50.200
And that A I is all written in JavaScript.

00:37:50.199 --> 00:37:56.419
On the left is the human character who will inevitably
be crushed by our superior logic and processing power.

00:37:56.420 --> 00:38:02.970
And the first question we have to ask is how does the
A I script community its decisions to our application,

00:38:02.969 --> 00:38:10.599
and how does the application communicate the state of the
game -- of the underlying model of its shapes -- to the A I.

00:38:10.599 --> 00:38:12.670
The answer is simple.

00:38:12.670 --> 00:38:15.559
It's the global object.

00:38:15.559 --> 00:38:19.259
All JavaScript execution occurs
in the context of a global object.

00:38:19.260 --> 00:38:23.970
If you create a global variable in JavaScript
it becomes a property of the global object.

00:38:23.969 --> 00:38:29.199
If you create a function, a global function in
JavaScript, also a property of the global object.

00:38:29.199 --> 00:38:34.949
So the most basic form of communication between
an application and a script is that global object

00:38:34.949 --> 00:38:37.799
where you can get and set properties and so can the script.

00:38:37.800 --> 00:38:41.220
I have drawn you a little diagram here of how that works.

00:38:41.219 --> 00:38:43.389
We have the Pong application in red.

00:38:43.389 --> 00:38:44.849
That's my native code.

00:38:44.849 --> 00:38:47.539
I chose Objective-C because I love Objective-C.

00:38:47.539 --> 00:38:48.090
Very easy.

00:38:48.090 --> 00:38:52.460
And the first thing that we do is we
allocate the JavaScript execution context

00:38:52.460 --> 00:38:56.099
which brings with it a global object in green.

00:38:56.099 --> 00:39:00.599
So next we're going to set up some constants to
ease communication just like you would in any API.

00:39:00.599 --> 00:39:08.599
And we're going to set up and down as global properties
so that the script it tell us which way it wants to move.

00:39:08.599 --> 00:39:12.809
Next, we'll evaluate the JavaScript AI.

00:39:12.809 --> 00:39:17.779
And it will add its own properties to the
global object, like an X move function.

00:39:17.780 --> 00:39:22.200
And that's the function we're going to
call every time it's the AI turn to move.

00:39:22.199 --> 00:39:23.379
So here we go.

00:39:23.380 --> 00:39:28.030
Our timer fires and it's time to
update and we call next move.

00:39:28.030 --> 00:39:29.340
We pass it two arguments.

00:39:29.340 --> 00:39:30.760
A paddle and a ball.

00:39:30.760 --> 00:39:34.650
So it can judge the position of
everything and decide how it wants to move.

00:39:34.650 --> 00:39:37.010
And now, I don't know what this script is going to do.

00:39:37.010 --> 00:39:37.790
That'd the point.

00:39:37.789 --> 00:39:39.009
It can do whatever it wants.

00:39:39.010 --> 00:39:42.820
It may be storing its old moves
in order to adapt to past losses.

00:39:42.820 --> 00:39:47.269
It may be storing your old moves in order
to predict where you're going to go.

00:39:47.269 --> 00:39:53.280
It may be storing the last position of the ball and making
judgments that way to try and see how the ball is moving.

00:39:53.280 --> 00:39:55.960
But it comes up with a decision and it returns me a result.

00:39:55.960 --> 00:39:59.369
And it says, okay, I want to go up.

00:39:59.369 --> 00:40:02.389
Let me show you the code required for that.

00:40:02.389 --> 00:40:06.009
This is how to set the global up constant.

00:40:06.010 --> 00:40:11.290
First we create that string in the
JavaScript API with the name of the constant.

00:40:11.289 --> 00:40:18.159
Then we use JS context get global object to
get the global object in the execution context.

00:40:18.159 --> 00:40:23.589
We make our JavaScript number,
that's the numeric constant for up.

00:40:23.590 --> 00:40:31.340
And we use JS object set property now to set
it as a variable inside that global object.

00:40:31.340 --> 00:40:33.789
Finally, we call JS string release to release that string.

00:40:33.789 --> 00:40:36.460
If you were doing this over and over again
you would probably want to hang on to

00:40:36.460 --> 00:40:38.880
that string instead of allocating it every time.

00:40:38.880 --> 00:40:44.280
Here's the code for calling a global function.

00:40:44.280 --> 00:40:45.360
That next move function.

00:40:45.360 --> 00:40:47.690
Once again we need the name of the function we want to call.

00:40:47.690 --> 00:40:49.309
Which is next move.

00:40:49.309 --> 00:40:53.239
We use JS object get property to get the
next move function from the global object.

00:40:53.239 --> 00:40:56.939
And then we need to do a little bit of type checking.

00:40:56.940 --> 00:40:59.530
We need to make sure we got something back, for example.

00:40:59.530 --> 00:41:01.850
JavaScript supports getter functions.

00:41:01.849 --> 00:41:06.329
So when you get a property, a function may run and it
can throw an exception, and you will get back null.

00:41:06.329 --> 00:41:08.409
So we checked null.

00:41:08.409 --> 00:41:11.019
We also need to check that we got back an object.

00:41:11.019 --> 00:41:12.539
Because the script could be malformed.

00:41:12.539 --> 00:41:16.710
It could have created a variable called
next move, and set it to the number 1.

00:41:16.710 --> 00:41:18.230
We can't call the number 1 as a function.

00:41:18.230 --> 00:41:23.690
So we need to make sure that we have an object,
and then we can cast this value to a JS object ref.

00:41:23.690 --> 00:41:28.730
Now that we have an object we prepare our
array of arguments, the paddle and the ball,

00:41:28.730 --> 00:41:35.079
and we use JS object cause function to call the
function next move, passing the paddle and the ball.

00:41:35.079 --> 00:41:38.739
You'll notice in this example I haven't actually done
anything with the result of this function call in.

00:41:38.739 --> 00:41:44.489
In the real application we take that result
and decide how to move the paddle based on it.

00:41:44.489 --> 00:41:51.509
So if we look back at the diagram one thing I
haven't talked about yet is the paddle and the ball.

00:41:51.510 --> 00:41:53.050
Those are JavaScript objects.

00:41:53.050 --> 00:41:56.269
So let's zoom in on them and get rid of everything else.

00:41:56.269 --> 00:42:01.650
And in order to explain how these work I am going
to bring back our old friend Jimmy JavaScript.

00:42:01.650 --> 00:42:06.460
So JavaScript objects here are just thin
wrappers around my Pong application,

00:42:06.460 --> 00:42:10.289
just like they are in the Web browser or in Colloquy.

00:42:10.289 --> 00:42:15.639
And they have the same properties of my
underlying model of shapes in the application.

00:42:15.639 --> 00:42:17.769
The ball and the paddle are just shapes.

00:42:17.769 --> 00:42:20.550
So there are these properties like
left and right in the shape.

00:42:20.550 --> 00:42:23.160
There are others that I haven't
shown here like top and bottom.

00:42:23.159 --> 00:42:27.960
And when a script asks for left, we just
turn around and we forward the request

00:42:27.960 --> 00:42:30.130
to the underlying model in your application.

00:42:30.130 --> 00:42:36.289
Office why I said before, communicating with your
application can be as cheap as a simple C function call.

00:42:36.289 --> 00:42:38.710
You asked for left, let me go get left.

00:42:38.710 --> 00:42:41.690
You asked for right, let me go get right.

00:42:44.809 --> 00:42:51.059
Here are the data types that you
need to describe those objects.

00:42:51.059 --> 00:42:54.779
99 percent of the time you can use a
static table to describe the properties

00:42:54.780 --> 00:42:56.730
that you want to make available to JavaScript.

00:42:56.730 --> 00:42:58.829
And we support two kinds of tables.

00:42:58.829 --> 00:43:01.179
There's a static value table, which is the most generic.

00:43:01.179 --> 00:43:03.149
It can support any kind of JavaScript data.

00:43:03.150 --> 00:43:08.510
And then we provide a static function table, which
is specifically tailored for making it easy for you

00:43:08.510 --> 00:43:10.440
to describe member functions in your objects.

00:43:10.440 --> 00:43:14.700
We haven't used any member functions in
Pong, but rest assured, they're there.

00:43:14.699 --> 00:43:20.519
The rest of the time you can also
register for optional dynamic call backs

00:43:20.519 --> 00:43:23.360
that are invoked any time your object is used in a script.

00:43:23.360 --> 00:43:27.269
The two you will use most often are initialize and finalize.

00:43:27.269 --> 00:43:32.030
These are called when your object is first created, and
when it's finally destroyed by the garbage collector.

00:43:32.030 --> 00:43:37.910
And you use these to retain and release
the underlying model in your application.

00:43:37.909 --> 00:43:41.579
The lifetime of a garbage collected object is unpredictable.

00:43:41.579 --> 00:43:47.170
So you do need to retain and release any data
that your JavaScript objects are going to use.

00:43:47.170 --> 00:43:52.769
We have a get property call back that you can
use to dynamically describe the properties

00:43:52.769 --> 00:43:55.230
on your objects if you can't do it statically.

00:43:55.230 --> 00:43:59.090
An example of this is if you have an object
that you want to behave like an array.

00:43:59.090 --> 00:44:02.250
You don't know, necessarily, what properties it has.

00:44:02.250 --> 00:44:07.909
So when I ask for the property at index 100, you need
to do a dynamic look up to see if the array is that big,

00:44:07.909 --> 00:44:13.980
and if there is a property there, then respond dynamically,
then you can implement this call back to do that.

00:44:13.980 --> 00:44:18.019
This call has function which is invoked
if your object is used as a function.

00:44:18.019 --> 00:44:19.500
And there are a bunch of others.

00:44:19.500 --> 00:44:21.000
Not very interesting, but they're there.

00:44:21.000 --> 00:44:27.590
And they're all in JS Object Ref dot H.
Here's a little bit of code that describes --

00:44:27.590 --> 00:44:32.260
here's an example of a static value
table to describe one of these shapes.

00:44:32.260 --> 00:44:34.950
So here's the property left.

00:44:34.949 --> 00:44:37.089
What we do first is we provide the name of the property.

00:44:37.090 --> 00:44:38.140
Which is left.

00:44:38.139 --> 00:44:39.940
Next we provide a getter function.

00:44:39.940 --> 00:44:42.480
JS shape get left.

00:44:42.480 --> 00:44:46.349
And that will be invoked when the
script asks for the property left.

00:44:46.349 --> 00:44:50.400
Next, we provide a setter function and a set of attributes.

00:44:50.400 --> 00:44:53.150
And here we've made this property read only.

00:44:53.150 --> 00:44:55.059
And so the setter function is null.

00:44:55.059 --> 00:44:59.219
It doesn't really make sense to have a setter
function for a property that can't be set.

00:44:59.219 --> 00:45:01.989
So this is a design decision that I made in Pong.

00:45:01.989 --> 00:45:07.250
I don't want your API scripts to be able
to arbitrarily set the state of the model

00:45:07.250 --> 00:45:11.909
and move the paddle anywhere they want to the
screen and whack the ball back at the user.

00:45:11.909 --> 00:45:13.489
That's called cheating.

00:45:13.489 --> 00:45:15.429
So my model is read only.

00:45:15.429 --> 00:45:17.839
And then you just decide which way you want to go.

00:45:17.840 --> 00:45:20.400
In your own applications your models might not be read only.

00:45:20.400 --> 00:45:23.300
In the Web browser virtually nothing is read only.

00:45:23.300 --> 00:45:24.560
But you can do that if you want.

00:45:24.559 --> 00:45:27.719
I just haven't done it here.

00:45:27.719 --> 00:45:32.679
So we have another demo for you of that
full blown Pong application in action,

00:45:32.679 --> 00:45:36.219
and I will invite back to the stage
by particular demand Alice Liu.

00:45:36.219 --> 00:45:43.599
Could we have the demo machine, please?

00:45:43.599 --> 00:45:46.199
( Applause )

00:45:46.199 --> 00:45:49.189
>> Sorry. Hi again.

00:45:49.190 --> 00:45:55.139
So I am going to be showing you the JS Pong
application which uses JavaScript Core.

00:45:55.139 --> 00:46:03.039
And also look into the performance of it, with Xray.

00:46:03.039 --> 00:46:05.529
I didn't quit.

00:46:05.530 --> 00:46:11.440
Okay. So here's the Pong game.

00:46:11.440 --> 00:46:14.760
And it's a pretty neat little app.

00:46:14.760 --> 00:46:19.970
Currently, we're running with a logic that makes
the paddle over here, the opponents paddle,

00:46:19.969 --> 00:46:22.750
follow the direction of the ball exactly.

00:46:22.750 --> 00:46:30.269
The moment is being determined by the JavaScript
function which we can see over here, called next move.

00:46:30.269 --> 00:46:31.750
The logic is very simple.

00:46:31.750 --> 00:46:36.590
Basically the paddle's next move will be
the same as where the ball has just moved.

00:46:36.590 --> 00:46:40.070
The only thing I want to show you is this line here.

00:46:40.070 --> 00:46:48.190
Last ball Y. Basically, we're keeping track of the ball's
last Y position so that we can remember it for next time.

00:46:48.190 --> 00:46:53.269
A script -- what you should take from this is us
scripts can keep static in between invocations.

00:46:53.269 --> 00:47:01.789
So one of the great benefits of using JavaScript in your
application is that you don't have to recompile code

00:47:01.789 --> 00:47:03.710
when you want to try something different.

00:47:03.710 --> 00:47:09.099
And this is -- a benefit to you if you need --

00:47:09.099 --> 00:47:14.789
if your application is one in which you need to try
different code quickly to see how something will behavior.

00:47:14.789 --> 00:47:16.570
Like experimentation.

00:47:16.570 --> 00:47:19.039
So this will facilitate experimentation.

00:47:19.039 --> 00:47:27.829
And because Pong is an application like that, let's try
some different -- let's try some different A I models.

00:47:27.829 --> 00:47:33.579
I have another one here called run away.

00:47:36.710 --> 00:47:43.130
So run away was designed it the intention to
move in the exact opposite direction of the ball

00:47:43.130 --> 00:47:45.740
and hopefully lose as quickly as possible.

00:47:45.739 --> 00:47:51.099
But when we run it we see that due to the
geometry of the game field it actually ends

00:47:51.099 --> 00:47:53.889
up intercepting the ball anyway -- which is expected.

00:47:53.889 --> 00:47:55.779
But kind of interesting.

00:47:55.780 --> 00:48:01.060
So if you wanted to run away from the
ball, you know, try to and it didn't work.

00:48:01.059 --> 00:48:02.820
Well, actually that time it worked.

00:48:02.820 --> 00:48:05.070
So let's try something different.

00:48:05.070 --> 00:48:08.210
Since that didn't produce what we actually wanted to do.

00:48:08.210 --> 00:48:10.800
Let's do something different.

00:48:15.269 --> 00:48:17.750
Here's one called semi- random.

00:48:17.750 --> 00:48:22.170
So this introduces randomness into
the position of the paddle.

00:48:22.170 --> 00:48:26.849
And it produces a pretty decent opponent, actually.

00:48:26.849 --> 00:48:32.299
So randomness is often used in AI because
it makes for a more unpredictable opponent,

00:48:32.300 --> 00:48:34.750
which will make it harder to master the game.

00:48:34.750 --> 00:48:39.340
So in your Pong game you can see that the introduction

00:48:39.340 --> 00:48:44.160
of random numbers will cause the opponents
paddle to kind of jiggle up and down.

00:48:44.159 --> 00:48:50.789
And this will cause the ball to -- this will
cause the ball to be hit in more interesting ways.

00:48:50.789 --> 00:48:55.730
And so we just saw the game -- the opponent lose.

00:48:55.730 --> 00:49:01.380
Okay. So Jeff is -- mentioned and also Steve
Jobs has mentioned how fast JavaScript Core is

00:49:01.380 --> 00:49:03.650
by JavaScript and JavaScript Core.

00:49:03.650 --> 00:49:16.880
So let's look at an Xray sample
and we'll see just how fast it is.

00:49:16.880 --> 00:49:19.250
Xray is a new tool for Leopard.

00:49:19.250 --> 00:49:21.730
And -- okay.

00:49:21.730 --> 00:49:26.400
So here we have a sampled 30-second
run of the Pong application.

00:49:26.400 --> 00:49:29.780
And we took this earlier so that
we didn't have to wait for it.

00:49:29.780 --> 00:49:33.970
But what I want to show you is this
line here, Pong AI, next move.

00:49:33.969 --> 00:49:44.969
So Pong AI next move is taking
just 0.2 percent of overall runtime.

00:49:44.969 --> 00:49:50.489
And as Jeff told you earlier, Pong A next
move is that function that invokes JavaScript.

00:49:50.489 --> 00:49:55.559
So we're taking just 0.2 percent of overall runtime.

00:49:55.559 --> 00:49:58.719
And another thing I want to show
you is Pong controller update.

00:49:58.719 --> 00:50:03.849
This function is the function responsible
for updating everything.

00:50:03.849 --> 00:50:08.809
The position of the player, the position of
the ball, and the position of the opponent.

00:50:08.809 --> 00:50:13.449
And this one takes just 0.9 percent of overall runtime.

00:50:13.449 --> 00:50:18.639
So the function that invokes JavaScript
-- JavaScript Core --

00:50:18.639 --> 00:50:23.659
is using less than one-quarter of the
time it takes to update everything.

00:50:23.659 --> 00:50:27.170
And that's a pretty performance PC.

00:50:27.170 --> 00:50:28.329
Okay. Thank you very much.

00:50:28.329 --> 00:50:28.929
( Applause )

00:50:28.929 --> 00:50:36.819
>> Thanks, Alice.

00:50:36.820 --> 00:50:40.460
That was the full Pong application.

00:50:40.460 --> 00:50:44.050
And we showed you JavaScript controlling
a non-player character.

00:50:44.050 --> 00:50:48.960
We showed you quick and easy iterations so
you can experiment with different strategies.

00:50:48.960 --> 00:50:53.070
You saw our strategies still lose
even if the player is doing nothing.

00:50:53.070 --> 00:50:56.950
So maybe as an exercise for the reader
you can implement a better strategy.

00:50:56.949 --> 00:50:58.929
I have a theory that you could implement an AI

00:50:58.929 --> 00:51:02.980
that would calculate the full trajectory
of the ball and literally be unbeatable.

00:51:02.980 --> 00:51:04.650
I hope someone can do that.

00:51:04.650 --> 00:51:08.750
And we also showed you a miniscule
sample count inside JavaScript Core.

00:51:08.750 --> 00:51:12.590
Only 0.2 percent of overall execution time.

00:51:12.590 --> 00:51:16.910
Now there are a number of factors that
contribute to that miniscule sample count.

00:51:16.909 --> 00:51:20.609
One is the JavaScript Core is efficient and its fast.

00:51:20.610 --> 00:51:24.010
Another is that we're using script judiciously.

00:51:24.010 --> 00:51:28.660
We're using it to implement high
level application control flow logic.

00:51:28.659 --> 00:51:30.069
So this model scales.

00:51:30.070 --> 00:51:34.370
Imagine if we had a hundred paddles zooming
around the screen instead of just one.

00:51:34.369 --> 00:51:40.449
Well, your sample count inside JavaScript
Core would still be just about 0.2 percent,

00:51:40.449 --> 00:51:44.789
because you would spend all that
extra time drawing all the panels.

00:51:44.789 --> 00:51:49.150
So scripting in your application
use judiciously, also scales.

00:51:49.150 --> 00:51:56.110
We have a couple of styles that we recommend for
interacting with scripts in your applications.

00:51:56.110 --> 00:51:58.849
We only showed you one possibility inside Pong.

00:51:58.849 --> 00:52:00.019
But there are a couple.

00:52:00.019 --> 00:52:04.750
And I'm going list them from simplest
to most complicated and interesting.

00:52:04.750 --> 00:52:08.570
The simplest thing you can do is execute a one-shot script.

00:52:08.570 --> 00:52:12.880
And the API for that is JS Evaluate Script.

00:52:12.880 --> 00:52:16.320
So if you encounter a script tag in a
Web page, that's what the Web page does.

00:52:16.320 --> 00:52:18.980
One shot script and then it ignores the script after that.

00:52:18.980 --> 00:52:21.949
And that's also what we did on
the simple JavaScript interpreter.

00:52:21.949 --> 00:52:25.929
We just evaluated the script and
did nothing more with it after that.

00:52:25.929 --> 00:52:29.879
Not very interesting, but it's the simplest thing to do.

00:52:29.880 --> 00:52:35.400
Getting a little bit more interesting, you can take a snitch
yet of JavaScript and treat it as the body of a function.

00:52:35.400 --> 00:52:40.840
So your script author just writes a little bit of
JavaScript, and then compile that into a function

00:52:40.840 --> 00:52:44.289
and call that function with whatever
arguments you want to provide.

00:52:44.289 --> 00:52:49.940
So the API for that is J A object make
function, where you pass in the function --

00:52:49.940 --> 00:52:52.440
the script you want to turn into a function.

00:52:52.440 --> 00:52:56.950
And the advantage here is that you
can now call it multiple times.

00:52:56.949 --> 00:52:59.730
And you can pass up arguments.

00:52:59.730 --> 00:53:03.090
Getting a little bit more interesting, you
can have a conically named entry point.

00:53:03.090 --> 00:53:08.710
That's what we did in point where you have a conically
named next move function that we look for in your script

00:53:08.710 --> 00:53:10.900
and then we call that over and over again.

00:53:10.900 --> 00:53:17.590
So the API we use there is JS object get property, where
you ask for the next move function from the global object.

00:53:17.590 --> 00:53:22.800
And the advantage here is that now your
scripts can start saving their own state.

00:53:22.800 --> 00:53:28.350
And finally, you can implement
arbitrarily named entry points.

00:53:28.349 --> 00:53:31.250
And the API name for that is -- well, there is none.

00:53:31.250 --> 00:53:35.940
The point is that the script decides
what the entry points are.

00:53:35.940 --> 00:53:40.610
So you provide a function or a property
that the script can set or pass a value to.

00:53:40.610 --> 00:53:43.059
And that's how it let's you know what its entry points are.

00:53:43.059 --> 00:53:47.610
We do this in the Web browser where you
can set a property, window dot onload,

00:53:47.610 --> 00:53:52.039
and set it to the function you want
called when your page fully loads.

00:53:52.039 --> 00:53:57.070
Or you can call add event listener, and pass
your entry point function as an argument.

00:53:57.070 --> 00:54:03.840
I'm sorry -- the advantage to those arbitrarily
named entry points is that then you don't have

00:54:03.840 --> 00:54:06.660
to pollute the name space for your script author.

00:54:06.659 --> 00:54:12.920
If you have a lot of different entry points you don't
want to require them all to have very predefined names.

00:54:12.920 --> 00:54:17.599
We have a couple of best practices for
you that we've learned over the years.

00:54:17.599 --> 00:54:19.380
Evaluate a script only once.

00:54:19.380 --> 00:54:24.550
When you evaluate a script we have to compile it
and turn it into an abstract syntax tree in memory.

00:54:24.550 --> 00:54:27.480
That can be expensive if you do it over and over again.

00:54:27.480 --> 00:54:31.490
So if you want a simple bit of script that you run
over and over again, we recommend that you compile

00:54:31.489 --> 00:54:36.279
that into a function with JS Object Make Function
and call your function over and over again.

00:54:36.280 --> 00:54:40.460
Then you don't have to start the hamster
running every single time you execute the code.

00:54:40.460 --> 00:54:43.990
Use a model for your application data.

00:54:43.989 --> 00:54:48.809
In Pong we have a model of shapes to
represent everything on the screen.

00:54:48.809 --> 00:54:52.049
And that means that your JavaScript
binding code should be mindless.

00:54:52.050 --> 00:54:53.300
You asked for left.

00:54:53.300 --> 00:54:54.570
Let me go get left.

00:54:54.570 --> 00:54:56.950
We learned this the hard way in the Web browser.

00:54:56.949 --> 00:55:01.089
Where we would have bugs in the underlying object
model of the Web browser and we would fix them

00:55:01.090 --> 00:55:03.789
by fiddling with the JavaScript binding code.

00:55:03.789 --> 00:55:08.460
So our bindings became huge and really
complicated, and our bugs were only half fixed.

00:55:08.460 --> 00:55:12.340
Because if you accessed the model in
a different way it was still broken.

00:55:12.340 --> 00:55:18.180
So we've done a lot of work in Safari 3 to move that logic
out of the binding code to make the bindings mindless,

00:55:18.179 --> 00:55:22.859
and to implement our application
logic inside our application model.

00:55:22.860 --> 00:55:27.840
In fact, your bindings should be so mindless that you
can consider writing a script to auto generate them.

00:55:27.840 --> 00:55:32.760
This has been a boon to us in WebKit
because we have so many JavaScript APIs.

00:55:32.760 --> 00:55:36.080
In your own application, in Pong, for
example, we don't have that many APIs,

00:55:36.079 --> 00:55:39.659
so we write them by hand because that's easier.

00:55:39.659 --> 00:55:41.529
And create convenience types and functions.

00:55:41.530 --> 00:55:42.940
You know, it's a CAPI.

00:55:42.940 --> 00:55:45.539
If you like C, you're weird.

00:55:45.539 --> 00:55:46.509
It's there.

00:55:46.510 --> 00:55:50.050
But if you like C++ I would
recommend, for example, boost auto pointer

00:55:50.050 --> 00:55:52.130
and shared pointer to handle reference counting.

00:55:52.130 --> 00:55:54.800
Same things exist in Objective-C, et cetera.

00:55:54.800 --> 00:55:59.039
Now I have two more subtle topics for you.

00:55:59.039 --> 00:56:02.440
So get a little -- get a little -- shake it out.

00:56:02.440 --> 00:56:02.889
Get ready.

00:56:02.889 --> 00:56:05.420
And the first is memory management.

00:56:05.420 --> 00:56:12.990
Okay? I mentioned that the JavaScript
language is garbage collected.

00:56:12.989 --> 00:56:16.509
We expose that fact in our API for performance.

00:56:16.510 --> 00:56:21.520
If every time we had to pass through a JavaScript value you
had to fiddle with a garbage collector that would be slow.

00:56:21.519 --> 00:56:24.349
And so we garbage collect in the API itself.

00:56:24.349 --> 00:56:29.279
JS Value Ref and JS Object Ref, the two JavaScript
data types are garbage collected.

00:56:29.280 --> 00:56:32.710
They are handled mostly automatically,
you do not need to release them.

00:56:32.710 --> 00:56:36.800
And the mnemonic for remembering that is
that you get these values from functions

00:56:36.800 --> 00:56:40.560
with the words get, make, and to in the name.

00:56:40.559 --> 00:56:41.900
They are handled mostly automatically.

00:56:41.900 --> 00:56:44.680
You do not need to release them.

00:56:44.679 --> 00:56:46.469
I said mostly -- automatically.

00:56:46.469 --> 00:56:48.519
Here's exactly what that means.

00:56:48.519 --> 00:56:51.699
From the script author's perspective,
garbage collection is completely automatic.

00:56:51.699 --> 00:56:55.939
You use your data in a script until you
don't need it any more, an then it goes away.

00:56:55.940 --> 00:56:59.789
From the script embedders perspective,
local variables are automatic.

00:56:59.789 --> 00:57:04.460
So if you have a JS Value Ref or a
JS Object Ref and a local variable,

00:57:04.460 --> 00:57:08.170
the garbage collection knows you're
using it and doesn't delete it.

00:57:08.170 --> 00:57:12.150
That means that global variables are
not automatic, and neither is heap data.

00:57:12.150 --> 00:57:16.550
So if you move a JS Value Ref into a global
or into a structure on the heap you need

00:57:16.550 --> 00:57:19.660
to let the garbage collector know you're still using it.

00:57:19.659 --> 00:57:21.549
We have a simple API for that.

00:57:21.550 --> 00:57:23.640
JS Value Protect and Unprotect.

00:57:23.639 --> 00:57:24.940
These work just like retain and release.

00:57:24.940 --> 00:57:28.380
You protect any number of times,
unprotect an equal number of times,

00:57:28.380 --> 00:57:31.900
and your value becomes eligible
for garbage collection again.

00:57:31.900 --> 00:57:33.460
Here's an example.

00:57:33.460 --> 00:57:36.289
We have a global count that's a JS Value Ref.

00:57:36.289 --> 00:57:38.690
We unprotect the old count when setting a new count.

00:57:38.690 --> 00:57:43.510
And we protect the new count, and
finally perform the assignment.

00:57:45.769 --> 00:57:49.650
The rest of the data types in the API
correspond to the lower level details

00:57:49.650 --> 00:57:52.440
of the engine, and not the JavaScript language itself.

00:57:52.440 --> 00:57:55.429
And so we reference count these for performance.

00:57:55.429 --> 00:57:59.879
And the mnemonic to remember that you've gotten a reference
counted piece of data is that it comes from a function

00:57:59.880 --> 00:58:03.210
with the word copy or create in the name.

00:58:03.210 --> 00:58:06.409
You don't have to know these intimately, really.

00:58:06.409 --> 00:58:08.899
You just need to remember that they're
reference-counted because you got them

00:58:08.900 --> 00:58:13.190
from copy and create -- you need to release them.

00:58:13.190 --> 00:58:16.329
The second more subtle topic is threading.

00:58:16.329 --> 00:58:18.360
Which is always subtle.

00:58:18.360 --> 00:58:23.559
JavaScript thread safe is not thread optimized
so you do not get symmetric multiprocessing

00:58:23.559 --> 00:58:26.139
if you run two JavaScript threads simultaneously.

00:58:26.139 --> 00:58:30.940
You can run them, if that fits your
programming model, does it doesn't help you.

00:58:30.940 --> 00:58:36.800
Your finalizers may be called on any
thread, so they need to be thread safe.

00:58:36.800 --> 00:58:39.590
Don't move JavaScript Core types between threads.

00:58:39.590 --> 00:58:44.309
You can share them, as long as the type is
still live on the thread that created it.

00:58:44.309 --> 00:58:49.639
But if you move it away, the garbage collector no
longer knows you're using it, and will delete it.

00:58:49.639 --> 00:58:53.629
We apply this to everything in the API,
not just the JavaScript data types,

00:58:53.630 --> 00:58:59.380
because we may start garbage collecting more
things in the future if it makes us faster.

00:58:59.380 --> 00:59:03.090
Finally, don't use the JS Global
context ref on multiple threads.

00:59:03.090 --> 00:59:05.760
This is more of a no-brainer than a subtlety.

00:59:05.760 --> 00:59:09.160
The JavaScript execution context
is just like the JavaScript stack.

00:59:09.159 --> 00:59:13.549
So just as you wouldn't execute two C
threads on the same stack at the same time

00:59:13.550 --> 00:59:16.950
because you would explode, the same goes for JavaScript.

00:59:18.849 --> 00:59:21.589
That's it for the JavaScript Core API.

00:59:21.590 --> 00:59:26.360
We do have a brief nugget left for you which is
how to use JavaScript in a WebKit application.

00:59:26.360 --> 00:59:30.599
We have a little bit of API for that.

00:59:30.599 --> 00:59:33.369
If you have a Web frame you can call global context

00:59:33.369 --> 00:59:37.389
to get the JavaScript execution
context corresponding to that frame.

00:59:37.389 --> 00:59:40.529
And if you have a Web script object,
which is the WebKit wrapper

00:59:40.530 --> 00:59:47.190
around a JavaScript Core object you can call JS
object to get back the underlying JavaScript object.

00:59:47.190 --> 00:59:49.340
We also have a new delegate.

00:59:49.340 --> 00:59:51.840
Did clear window object for frame.

00:59:51.840 --> 00:59:56.260
If you are familiar with WebKit programming you
know that you should do your JavaScript programming

00:59:56.260 --> 00:59:59.300
in the window script object available call back.

00:59:59.300 --> 01:00:01.870
Now, window script object available
only gives you a Web view.

01:00:01.869 --> 01:00:05.269
But you need a Web frame to do JavaScript Core programming.

01:00:05.269 --> 01:00:09.550
So we have a new delegate call
back here to supplant the old one.

01:00:09.550 --> 01:00:12.010
It fires at the exact same time.

01:00:12.010 --> 01:00:14.220
And you can also implement both of them.

01:00:14.219 --> 01:00:16.269
In which case we will only call the new one.

01:00:16.269 --> 01:00:22.489
So you can implement both, do the old thing on
Tiger, do the new thing with the new WebKit.

01:00:22.489 --> 01:00:24.969
Here's an example of that.

01:00:24.969 --> 01:00:27.159
You implement , did clear window object for frame.

01:00:27.159 --> 01:00:30.889
You call global context to get
the JavaScript execution context.

01:00:30.889 --> 01:00:34.679
JS object to get that window object
as a JavaScript Core object.

01:00:34.679 --> 01:00:36.369
And then you go to town.

01:00:36.369 --> 01:00:38.139
This is an object that you got back from WebKit.

01:00:38.139 --> 01:00:43.690
So it's a real window object that includes the whole
Web stack like set time out, XML H T P request.

01:00:43.690 --> 01:00:45.050
And you can do anything you want.

01:00:45.050 --> 01:00:51.380
You can add your own custom constructor
functions, et cetera.

01:00:52.730 --> 01:00:58.309
A final note about using JavaScript
Core with WebKit is threading.

01:00:58.309 --> 01:01:00.199
JavaScript Core is thread safe.

01:01:00.199 --> 01:01:03.089
WebKit is not thread safe.

01:01:03.090 --> 01:01:08.690
So do not be tempted by JavaScript Core to take
a JavaScript object that you got from WebKit

01:01:08.690 --> 01:01:10.800
and start using it on a secondary thread.

01:01:10.800 --> 01:01:15.590
Remember, these are only thin wrappers
around the underlying model into WebKit.

01:01:15.590 --> 01:01:16.880
That model is not thread safe.

01:01:16.880 --> 01:01:23.900
So if you use those objects on a secondary thread, kittens
will go flying, babies will be bounced out of the boat --

01:01:23.900 --> 01:01:27.930
and worst of all, your application will crash randomly.

01:01:29.050 --> 01:01:32.000
Use WebKit objects on the main thread only.

01:01:33.260 --> 01:01:39.400
For more information about the WebKit open source project
we have WebKit dot org, and we also have our IRC channel

01:01:39.400 --> 01:01:42.320
which I think you all joined just recently.

01:01:42.320 --> 01:01:49.809
I mentioned that we support a rich object notation called
JSON, and you can read more about that at J-S-on-dot-org.

01:01:49.809 --> 01:01:55.099
Raise your hand if you're still writing anything down.

01:01:55.099 --> 01:02:00.969
Okay. We have a Safari and WebKit
lab at 3:30 today in Lab D, as in dog.

01:02:00.969 --> 01:02:07.269
Okay. So we went through a lot of
API, a lot of interesting stuff.

01:02:07.269 --> 01:02:10.099
Thank you for paying attention the whole time.

01:02:10.099 --> 01:02:11.639
You don't need to memorize all that.

01:02:11.639 --> 01:02:14.059
The slides are available after WWDC.

01:02:14.059 --> 01:02:15.759
Of the sample code is already on line.

01:02:15.760 --> 01:02:18.470
The headers are copiously documented.

01:02:18.469 --> 01:02:24.649
But these are the high level ideas I want you to hang on
to, to consider when you're making your own applications.

01:02:24.650 --> 01:02:27.110
Consider JavaScript for internal scripting.

01:02:27.110 --> 01:02:28.539
It's popular.

01:02:28.539 --> 01:02:30.960
It powers the Web; everybody knows it.

01:02:30.960 --> 01:02:31.730
It's fast.

01:02:31.730 --> 01:02:33.809
It powers the fastest Web browser in the world.

01:02:33.809 --> 01:02:41.849
And it's a part of Mac OS X. For your JavaScript
needs we have the JavaScript Core framework.

01:02:41.849 --> 01:02:44.730
It's light weight, none of the rest of the Web stack.

01:02:44.730 --> 01:02:45.380
It's complete.

01:02:45.380 --> 01:02:48.180
Everything in the UCMA standard, and it's thread safe.
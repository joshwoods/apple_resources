WEBVTT

00:00:11.330 --> 00:00:15.719
>> Hello everyone, I'm Derek, and welcome
to Fundamentals of Kernel Debugging.

00:00:15.720 --> 00:00:21.920
And so, if this is not the session you were
looking for this is your last chance to escape.

00:00:21.920 --> 00:00:22.510
( Laughter )

00:00:22.510 --> 00:00:29.010
And many of you just came over from the Kernel Programming
session and I'm sure that it was very instructive.

00:00:29.010 --> 00:00:33.439
And one thing to notice are that if you don't
keep all of the guidelines you were told about in

00:00:33.439 --> 00:00:36.079
that session in mind, this is what happens.

00:00:36.079 --> 00:00:39.530
( Laughter )

00:00:39.530 --> 00:00:43.660
I'm sure you will all agree that it is a very pretty
screen and it takes up a lot of kernel wide memory,

00:00:43.659 --> 00:00:49.169
so I hope that you all appreciate it,
but it's not a good user experience.

00:00:49.170 --> 00:00:55.370
One thing to notice if you enable kernel debugging you'll
get something less pretty but more useful on the screen.

00:00:55.369 --> 00:01:01.530
A lot of cryptic numbers which in this session
you will learn how to recognize all of you know,

00:01:01.530 --> 00:01:09.409
that stuff on the screen and understand it completely and,
you know, be an expert Kernel Debugger after, or so I hope.

00:01:09.409 --> 00:01:09.769
( Laughter )

00:01:09.769 --> 00:01:18.359
And so what we are going to cover today
are several new topics. So first is how

00:01:18.359 --> 00:01:21.170
to get started with kernel debugging and Mac OS X.

00:01:21.170 --> 00:01:26.049
We do have a considerable matter of kernel debugging
infrastructure on our operating system.

00:01:26.049 --> 00:01:32.640
And also how to go ahead and analyze kernel
panics and hangs so techniques to do all of that,

00:01:32.640 --> 00:01:36.310
and also some knew technologies in Leopard.

00:01:36.310 --> 00:01:40.609
Who should be here? So you know if
you are curious about the kernel, fine,

00:01:40.609 --> 00:01:47.189
but people who will find this session most useful are
Kernel Extension Developers, so if you're writing drivers,

00:01:47.189 --> 00:01:51.730
file systems or other things you know
which operate in the kernel address space

00:01:51.730 --> 00:01:54.780
for Mac OS X, you will find this pretty useful.

00:01:54.780 --> 00:02:00.760
And if you are an application developer interested in
exploring how your application interacts with the kernel

00:02:00.760 --> 00:02:06.760
and if you notice any performance issues
and things like that if you want to figure out how

00:02:06.760 --> 00:02:11.280
to exploit you know the kernel facilities
better, this is a good way to get started,

00:02:11.280 --> 00:02:15.099
just to understand the interaction
with the system as a whole.

00:02:15.099 --> 00:02:20.129
And also if you are a system administrator and you are
experiencing some sort of problem or you want

00:02:20.129 --> 00:02:26.909
to figure out how exactly the kernel works to better
deploy your resources, this is a good way to learn how

00:02:26.909 --> 00:02:28.990
to do first order of triage or that sort of thing.

00:02:28.990 --> 00:02:35.150
And anyone who's interested in understanding
Kernel internals is a large and complex system

00:02:35.150 --> 00:02:41.409
and there are many players in the kernel address space, so
if you are interested in getting to understand what's going

00:02:41.409 --> 00:02:44.680
on in the system, this is a good way to get started.

00:02:44.680 --> 00:02:49.000
And there is a lot of useful Apple documentation

00:02:49.000 --> 00:02:54.750
on the developer dot apple dot com web
site, the ADC Reference Library and so on.

00:02:54.750 --> 00:02:58.009
And the WWDC Attendees sub website.

00:02:58.009 --> 00:03:02.979
I am not going to go through and talk about all of these
but you know you can consult the slides later to figure

00:03:02.979 --> 00:03:07.489
out you know which of these would be useful for
you, but one thing I especially recommend is

00:03:07.490 --> 00:03:15.030
that we put together a head start document for the session
a couple of weeks ago, and that is on the WWDC website,

00:03:15.030 --> 00:03:18.599
and it's a great way to get started with
kernel debugging on this operating system.

00:03:18.599 --> 00:03:23.789
So if you haven't yet looked at our document I
strongly encourage you to go through and go

00:03:23.789 --> 00:03:31.310
through that document and it's sort of a training
exercise cum intro, so you can walk through that

00:03:31.310 --> 00:03:37.500
with your Leopard System and you know really get a good
head start on Getting Started with Kernel Debugging.

00:03:37.500 --> 00:03:43.930
And so there are a number of other titles on the ADC
website which let you get started with kernel debugging.

00:03:43.930 --> 00:03:46.360
And these are some of them.

00:03:46.360 --> 00:03:49.640
You don't have to memorize any of
these you can look at them later.

00:03:49.639 --> 00:03:56.139
And one thing I especially recommend for anyone
who is interested in debugging,

00:03:56.139 --> 00:04:04.569
either user or kernel is to look at this document called
Mac OS X Calling Conventions for both PowerPC and Intel.

00:04:04.569 --> 00:04:09.799
It will really come in handy um not just
you know for kernel debugging but any sort

00:04:09.800 --> 00:04:11.370
of debugging you do on the operating system.

00:04:11.370 --> 00:04:17.550
It's very good to have an understanding what exactly it
is that the processor does when you do a function call

00:04:17.550 --> 00:04:21.699
or when you are you know are looking
at arguments on the stack on so on.

00:04:21.699 --> 00:04:25.979
And it is a good bit of knowledge to have.

00:04:25.980 --> 00:04:32.610
And also there is a pretty good manual for the GNU
source level debugger which is what we will be using

00:04:32.610 --> 00:04:37.150
for most debugging on OS X, and I
recommend that you take a look at that.

00:04:37.149 --> 00:04:43.759
And I also note that some of the technotes do need updates
and those updates will be happening shortly I believe.

00:04:43.759 --> 00:04:51.250
And you know you can consult both this session and the
Head Start document which will have the latest bits.

00:04:51.250 --> 00:04:56.939
What's new in Leopard so the first thing that's new that's
going to affect a lot of you who have been debugging

00:04:56.939 --> 00:05:03.939
on Tiger is the DWARF debugging format and this is the
brave new debugging format which is replacing the old

00:05:03.939 --> 00:05:10.219
and tired stabs debugging format, which was
the default for kernel debugging back in Tiger.

00:05:10.220 --> 00:05:17.940
And so DWARF the name is actually a pun on an object
format that we don't use at Apple, namely ELF.

00:05:17.939 --> 00:05:25.779
I don't know what it is about writers they come up with
names like Mach-0, and ELF and DWARF but I digress.

00:05:25.779 --> 00:05:33.689
So there is a new command called Add kext which replaces
Add symbol file which is what I used to use back in Tiger.

00:05:33.689 --> 00:05:36.980
And that operates on three files.

00:05:36.980 --> 00:05:42.819
The first is the DWARF dSYM bundle that Xcode
will generate for you if you tell it to,

00:05:42.819 --> 00:05:49.990
and then you need to generate the relocated symbol
file for your driver using the kextload command,

00:05:49.990 --> 00:05:53.689
which is what you used to do back in Tiger
as well, so there is nothing new there.

00:05:53.689 --> 00:05:59.860
And there's a kext bundle with debug symbols which is
again something that you should have had back in Tiger.

00:05:59.860 --> 00:06:03.939
So all of these need to be in the same
directory and you will just pass the address

00:06:03.939 --> 00:06:07.060
of your kext bundle with this new Add-kext command.

00:06:07.060 --> 00:06:09.780
And it will do all of the magic to figure things out.

00:06:09.779 --> 00:06:13.699
And there's a detailed description
of this in the Head Start document.

00:06:13.699 --> 00:06:21.779
And one bit of breaking news is that there's a kernel
debug kit with the debug symbols for the mark kernel file

00:06:21.779 --> 00:06:24.719
which you know is the operating system kernel.

00:06:24.720 --> 00:06:30.920
And there is a critical GDB update in that kernel
debug kit which you should apply if you want

00:06:30.920 --> 00:06:33.550
to do kernel debugging using the Leopard Seed.

00:06:33.550 --> 00:06:36.670
There were some last minute changes to
the DWARF parts there and so and so forth

00:06:36.670 --> 00:06:38.670
which are pretty essential to kernel debugging.

00:06:38.670 --> 00:06:41.540
So please download that kernel downloading kit

00:06:41.540 --> 00:06:46.600
and apply that GDB update before getting
started with kernel debugging on the seed.

00:06:46.600 --> 00:06:54.050
You don't need to do that if you are using the old 9A410 but
obviously you want to use the latest and greatest Leopard.

00:06:54.050 --> 00:07:00.509
And so this is a this is a screen shot of
the Xcode bill settings preference pane

00:07:00.509 --> 00:07:04.839
and this is what you'll need to
do to enable DWARF debugging.

00:07:04.839 --> 00:07:09.439
You need to select the DWARF with dSYM file
debug information format.

00:07:09.439 --> 00:07:15.579
And you also need to insure that the generate
debugging information check box is checked

00:07:15.579 --> 00:07:19.209
when you are configuring your driver project in Xcode.

00:07:19.209 --> 00:07:27.599
And that will generate a separate bundle called your kext
name dot dSYM and that's what you'll need to use

00:07:27.600 --> 00:07:31.910
when you're using the Add-kext command in GDB.

00:07:31.910 --> 00:07:38.620
And so new tools in Leopard, there is a new tool called the
Live Kernel Debugger, it lets you look at the running kernel

00:07:38.620 --> 00:07:44.360
on the same system as it's doing its thing so
it can be pretty useful in some situations.

00:07:44.360 --> 00:07:50.840
Especially if you are interested in nondestructively
debugging the kernel you know while it's doing useful

00:07:50.839 --> 00:07:54.649
things, rather than interrupting it with an NMI.

00:07:54.649 --> 00:07:58.449
And there is a fabulous
new tool called DTrace in Leopard.

00:07:58.449 --> 00:08:04.529
There's going to be seven sessions describing that,
but I'll just give you a brief over view of that.

00:08:04.529 --> 00:08:09.809
And there are some specialized tools known as
stackshot and spindump which are also new in Leopard.

00:08:09.810 --> 00:08:14.790
And that if time permits I will describe those briefly.

00:08:14.790 --> 00:08:23.010
And DTrace, I am sure a lot of you have heard of it but if
you haven't it's very useful to get a good look at DTrace

00:08:23.009 --> 00:08:28.839
and see if it can help you with your
driver or other kernel facility.

00:08:28.839 --> 00:08:32.620
It's ported from OpenSolaris and it's a dynamic
tracing facility.

00:08:32.620 --> 00:08:37.259
That means that you don't have to recompile
your kernel or add any instrumentation.

00:08:37.259 --> 00:08:40.360
All of the DTrace instrumentation can be added on the fly

00:08:40.360 --> 00:08:46.230
and that's your customized probes
that you insert into kernel functions.

00:08:46.230 --> 00:08:51.480
And these probes are dynamically inserted and there is a
special scripting language, called the D Scripting Language,

00:08:51.480 --> 00:08:56.000
which let's you customize what exactly
happens when those probes fire.

00:08:56.000 --> 00:09:00.100
And the DTrace model is that it's a
hub of several different providers

00:09:00.100 --> 00:09:05.009
and there are several different kernel providers
including the Function by Retrace provider,

00:09:05.009 --> 00:09:08.759
VM Info, Siskull and IO, and a few others.

00:09:08.759 --> 00:09:15.819
And so these are predefined providers which have
predefined probe points within the kernel that you can use

00:09:15.820 --> 00:09:19.920
to explore VM behavior or system calls and so and so forth.

00:09:19.919 --> 00:09:25.709
And I will note that Kernel Extension support is currently
rather limited but you know it is still pretty useful.

00:09:25.710 --> 00:09:30.740
For example; if you are getting an error from some
layer of the kernel and you want to figure out why it is

00:09:30.740 --> 00:09:34.190
that you are getting this error and
which functions ultimately responsible

00:09:34.190 --> 00:09:36.870
for generating that error you can use DTrace.

00:09:36.870 --> 00:09:41.639
And if you want to figure out what exactly happens
when you call in to the kernel for something,

00:09:41.639 --> 00:09:45.559
this is a good way to get started with that.

00:09:45.559 --> 00:09:51.029
And also, I should note that some of you know
these DTrace probes do have an observer effect,

00:09:51.029 --> 00:09:53.610
so you should keep that in mind.

00:09:53.610 --> 00:09:59.659
And there's a dedicated DTrace Session, Session Number 315,
Tracing Software Behavior With DTrace which I encourage you

00:09:59.659 --> 00:10:07.620
to go to and there's also a very good documentation
on DTrace so it's a good technology to learn

00:10:07.620 --> 00:10:12.639
and there's also front end to DTrace, called
X-Ray, and it's a separate session to that

00:10:12.639 --> 00:10:16.069
and it's very cool looking and very useful.

00:10:16.070 --> 00:10:21.330
And there's also something we've had for
sometime now, Shark, and the CHUD framework,

00:10:21.330 --> 00:10:26.830
it's great for performance analysis, it lets
you do a lot of things and not just limited

00:10:26.830 --> 00:10:29.210
to what I have here on this slide it's pretty complex.

00:10:29.210 --> 00:10:35.330
And you can sta, I should note that you can
statistically sample kernel stacks as well as user stacks

00:10:35.330 --> 00:10:37.100
and this is something that not very many people know.

00:10:37.100 --> 00:10:42.560
So, if you are doing performance analysis, kernel
performance analysis, Shark is a good thing to have.

00:10:42.559 --> 00:10:50.579
And it also lets you examine process of performance counters
and also is aware of select kernel events like system calls

00:10:50.580 --> 00:10:57.800
and pagefulls including copying rights, , page
in page out and lots of other things and it's a great way

00:10:57.799 --> 00:11:02.159
to do performance analysis on Os
10, including For Your Driver.

00:11:02.159 --> 00:11:07.169
And there's a dedicated Shark Session, Session
Number 316 Performance Tuning with Shark.

00:11:07.169 --> 00:11:13.689
And it's a good session to attend
to get a feel of what Shark can do.

00:11:13.690 --> 00:11:22.300
So the primary-interface to kernel debugging on Mac Os
10 on GDB, the open source new source level debugger.

00:11:22.299 --> 00:11:28.870
And we have, we also have a number of Kernel debugging
macros to automate a lot and abstract add a lot

00:11:28.870 --> 00:11:34.860
of useful information of you know to present
a lot of useful information without having

00:11:34.860 --> 00:11:38.529
to grabble through the internals of the system.

00:11:38.529 --> 00:11:43.569
So it's a standard source level debugger
and this is what you will use even

00:11:43.570 --> 00:11:47.050
if you are debugging user space applications with Xcode.

00:11:47.049 --> 00:11:53.599
And the GBD manual is a good way to get started with
understanding this debugger and it contains a lot

00:11:53.600 --> 00:12:01.180
of useful tips and in the kernel debug kit that
we supply you, we supply a lot of GDB and macros

00:12:01.179 --> 00:12:07.979
which you know introspect and what kernel data
structures and let you let you look at thread stakes

00:12:07.980 --> 00:12:14.090
and the schedule stakes for all of the threads and
Kernel wait cues and wait events and all of that.

00:12:14.090 --> 00:12:20.730
And examine panic logs and the kernel system log
ring buffer for I/O Log or print f style messages.

00:12:20.730 --> 00:12:27.220
And there is a comprehensive list of these macros if
you type in Help KGM after loading them within KGB.

00:12:27.220 --> 00:12:33.070
And there is information on how to do all of
this in tech notes that I described earlier.

00:12:33.070 --> 00:12:37.040
And to examine the kernel, there are
three primary mechanisms we have on Os 10.

00:12:37.039 --> 00:12:41.329
The first is the two machines or
interactive debugging environment.

00:12:41.330 --> 00:12:47.720
And this is this is what you'll probably do when you're
actually developing your driver, you want to do quick turn

00:12:47.720 --> 00:12:54.240
around debugging, you connect to The debugger on
the target kernel using either FireWire or Ethernet.

00:12:54.240 --> 00:13:01.379
And the kernel is interrupted at this point either because
it's panicked or you press the NMI or programmers button

00:13:01.379 --> 00:13:04.840
on the system to force it into the debugger.

00:13:04.840 --> 00:13:10.629
And it can you can do this either
either over the Ethernet or FireWire.

00:13:10.629 --> 00:13:13.450
And the second approach is to use kernel crashdumps

00:13:13.450 --> 00:13:18.890
which is essentially a Marco core fold
which encapsulates all of kernel state.

00:13:18.889 --> 00:13:23.129
And this can also be obtained either
on Ethernet or FireWire.

00:13:23.129 --> 00:13:27.200
And the third one is something that is new in
Leopard, which is called the Live Kernel Debugger.

00:13:27.200 --> 00:13:34.840
That is not for post mortem debugging but for examining
the kernel as you go along as it's actually doing work.

00:13:34.840 --> 00:13:38.009
And it's pretty useful in some situations.

00:13:38.009 --> 00:13:45.309
A brief over view of two machine debugging, as
I mentioned it's it will quickly become a staple

00:13:45.309 --> 00:13:47.239
of your developing process.

00:13:47.240 --> 00:13:52.649
And it is an interactive debugger you can set
break points and have step control over kernel

00:13:52.649 --> 00:13:54.829
so you can step over instructions and so on.

00:13:54.830 --> 00:14:00.379
So this is the kernel so you have to remember that you know
that some there are some critical portions to the kernel

00:14:00.379 --> 00:14:05.470
which don't take kindly to this sort of thing so
but most you know your driver code should be immune

00:14:05.470 --> 00:14:08.190
to this sort of thing but something to keep in mind.

00:14:08.190 --> 00:14:13.350
And it can also do a post-mortem debugging,
so if your system is panicked or if it is hung

00:14:13.350 --> 00:14:17.920
for instance you can connect to the system and examine all

00:14:17.919 --> 00:14:22.919
of the kernel data structures and
structures within your driver.

00:14:22.919 --> 00:14:29.019
And there are some things the two machine debugging
can do which aren't available; the other two approaches

00:14:29.019 --> 00:14:32.169
which is letting you examine physical memory directly

00:14:32.169 --> 00:14:36.439
so your positive physical address and can
read the contents of the physical address.

00:14:36.440 --> 00:14:44.110
And you can also set some options to let you look at
memory mapped device space so you can if you want to look

00:14:44.110 --> 00:14:49.370
at the registers on your device for instance,
you can do that using the two machine debugger.

00:14:49.370 --> 00:14:56.019
And also you can look at user pages so if you're if they're
paged in, so if you want to look at the stack trace

00:14:56.019 --> 00:15:01.389
for a user thread that's called in to the kernel for
instance to figure out so if you have a user competent

00:15:01.389 --> 00:15:05.769
to your driver, this is a good way
to find out what exactly it was doing

00:15:05.769 --> 00:15:09.179
to cause whatever situation it was
that you were interested in looking at.

00:15:09.179 --> 00:15:12.469
And this can use both Ethernet and FireWire.

00:15:12.470 --> 00:15:17.009
And crash dumps, there's a pretty good tech note
which describes how to set-up kernel crashdumps.

00:15:17.009 --> 00:15:21.439
So you can get again do this over Ethernet of FireWire.

00:15:21.440 --> 00:15:28.320
And for FireWire, you will need to download a special
program from the FireWire SDK, called FireWire CoreDumper.

00:15:28.320 --> 00:15:33.450
And you will just need to run this on the
host system which you are debugging from.

00:15:33.450 --> 00:15:39.129
And for Ethernet you, there is a special daemon
which will receive all of the kernel debugging

00:15:39.129 --> 00:15:44.820
Kernel crashdump packets from the target. It's called
K dumpd and Leopard ships

00:15:44.820 --> 00:15:51.260
with a preconfigured launch d P list to enable this
K dumpd launch d daemon.

00:15:51.259 --> 00:15:58.789
And on the target system what you would do is either
enable crashdumps permanently via the kernel boot-args

00:15:58.789 --> 00:16:03.659
which are stored in RAM,
or you can enable it indirectively

00:16:03.659 --> 00:16:05.509
after connecting with the two machine debugger.

00:16:05.509 --> 00:16:10.169
So for example, at Apple we don't enable
kernel crashdumps for every system

00:16:10.169 --> 00:16:13.419
on campus because that would not scale very well.

00:16:13.419 --> 00:16:21.019
But we do you know when people tell us that they have a
panic, we do connect to that system with the kernel debugger

00:16:21.019 --> 00:16:27.159
and then interactively trigger a crashdump
so that we can look at the information later.

00:16:27.159 --> 00:16:31.909
And you can enable this either using the NV RAM command

00:16:31.909 --> 00:16:40.389
or on Intel-based Mac you can use the boot
dot P list file to enable this on a participation basis.

00:16:40.389 --> 00:16:50.189
And so a brief comparison of these two techniques
so crashdumps, so if you are receiving information

00:16:50.190 --> 00:16:57.290
from a customer's side for instance you can't easily do
interactive two machine debugging although it is possible

00:16:57.289 --> 00:17:00.099
to debug a machine in Japan, it's not very pleasant.

00:17:00.100 --> 00:17:06.309
And plus they will need to keep it around for you
for however long it takes you to look at the system.

00:17:06.309 --> 00:17:09.269
So what you would tell them to
do is set up a crashdump server

00:17:09.269 --> 00:17:13.019
and have them generate a crashdump and send it over to you.

00:17:13.019 --> 00:17:19.289
I will note that these files seem to be large, so you
probably don't want them having them email these to you,

00:17:19.289 --> 00:17:22.129
so set up an FTP server or something like that.

00:17:22.130 --> 00:17:25.530
And interactive debugging is primarily
useful in the developing phase,

00:17:25.529 --> 00:17:31.799
or if you have an in-house QA team
which is reproducing issues for you.

00:17:31.799 --> 00:17:34.799
It's really good to interactively debug so that you can look

00:17:34.799 --> 00:17:38.509
at your device registers and device
stage and that sort of thing.

00:17:38.509 --> 00:17:42.710
And it also lets you separate points
and you know step through your codes,

00:17:42.710 --> 00:17:46.079
so that is a pretty useful thing to have.

00:17:46.079 --> 00:17:53.009
And in comparison of the two transports FireWire does
have some advantages over Ethernet and some disadvantages

00:17:53.009 --> 00:17:56.869
in that you know you have to be physically
in close proximity to the system.

00:17:56.869 --> 00:18:00.089
But some of the advantages are that it
is available earlier in the boot process.

00:18:00.089 --> 00:18:07.509
Ethernet does have to be configured and the driver for
the network card has to be loaded with Ethernet debugging.

00:18:07.509 --> 00:18:14.509
So FireWire, the FireWire debugging facility is
specifically tailored to load early in the boot process.

00:18:14.509 --> 00:18:17.710
And it also remains available longer during Sleep Wake.

00:18:17.710 --> 00:18:24.049
So if you are debugging sleep wake issues, FireWire
debugging and the FireWire log in facility,

00:18:24.049 --> 00:18:28.399
FireWire K printf, those are good
things to familiarize yourself with.

00:18:28.400 --> 00:18:32.630
And it's also faster, FireWire is a
faster transport, plus it's you know close

00:18:32.630 --> 00:18:35.860
to your machine so it's a sort of a given.

00:18:35.859 --> 00:18:43.139
And it may be an only option when you're debugging
a network device driver, and that driver is bound

00:18:43.140 --> 00:18:50.310
to the primary interface or, if it, you know you don't want
to perturb the state of the network stack too much.

00:18:50.309 --> 00:18:55.720
And it may be preferable for security reasons because
the Ethernet packets are being transported in the clear.

00:18:55.720 --> 00:18:59.930
Whereas FireWire is a point to point
transport and if it's going over the cable

00:18:59.930 --> 00:19:01.279
that you have connected to your machines.

00:19:01.279 --> 00:19:10.660
And so, it's a I will also mention FireWire K Printf
that's a high speed log in facility that is very useful

00:19:10.660 --> 00:19:18.840
for tracing events from within your kernel extension so
that you can log things and look at them as they happen.

00:19:18.839 --> 00:19:24.609
And there's also a specialized tool called
FireWire GDB available from the FireWire SDK.

00:19:24.609 --> 00:19:31.719
This has no analog within the Ethernet transport and that's
basically a facility which uses Fire Wire DMA to look

00:19:31.720 --> 00:19:35.140
at the state of the system after it has panicked.

00:19:35.140 --> 00:19:40.370
And this may be your only option in cases
where your machine is irretrievably hung

00:19:40.369 --> 00:19:46.669
and you can't force the debugger using the NMI button, or
if it's not able to enter the debugger for some reason.

00:19:46.670 --> 00:19:52.710
For instance if the boot processor which is where
Mac OS X services' all external interrupts is hung

00:19:52.710 --> 00:19:59.850
with interrupts mast you can't force it into the debugger
so you might have better luck with FireWire GDB to look

00:19:59.849 --> 00:20:04.669
at all the memory on the system, because it's FireWire DMA.

00:20:04.670 --> 00:20:09.600
One thing to note in Leopard is that you may need
to add the high memory mode equal to one boot-arg.

00:20:09.599 --> 00:20:16.059
That's something we are looking at and it will be addressed
in time for the release but just something to keep in mind

00:20:16.059 --> 00:20:20.750
if you have a 64-bit system width lots of memory.

00:20:20.750 --> 00:20:28.309
And FireWire GDB does disable other, the rest of the
FireWire stack and that's not true of FireWire KDP,

00:20:28.309 --> 00:20:34.589
which is the regular two machine debugging
transport and also the FireWire crashdump facility,

00:20:34.589 --> 00:20:38.250
that doesn't disable other FireWire devices either.

00:20:38.250 --> 00:20:41.940
And so the live kernel debugger is
something that's new in Leopard.

00:20:41.940 --> 00:20:45.140
I am looking for better names to describe this facility.

00:20:45.140 --> 00:20:47.240
So if you have any suggestions feel free to let me know.

00:20:47.240 --> 00:20:50.370
So it's minimally intrusive.

00:20:50.369 --> 00:20:56.000
It doesn't require the target kernel to be stopped and it's
obviously not for post modern debugging but it's a good way

00:20:56.000 --> 00:21:02.029
to explore what's going on with the system right now
without having to pause the system and, you know,

00:21:02.029 --> 00:21:08.079
disrupt whatever its doing and it only requires one machine.

00:21:08.079 --> 00:21:12.629
So this is the way you would go about
configuring, configuring this debugger.

00:21:12.630 --> 00:21:15.380
These instructions will be in a tech note at some point.

00:21:15.380 --> 00:21:19.640
So you would set the MB RAM boot
or kernel boot-arg kmem equal to one.

00:21:19.640 --> 00:21:25.810
It does use the deb kmem
interface to address kernel memory

00:21:25.809 --> 00:21:30.329
and any other kernel debugging
bootargs you might want to add to that,

00:21:30.329 --> 00:21:33.589
to that line is, it's a good place to put those in.

00:21:33.589 --> 00:21:40.259
And you restart and then you start up GDB, you're seeing
the symbols from the Kernel Debug Kit that you will download

00:21:40.259 --> 00:21:45.809
from the attendee website and it does
need to be started as a super user.

00:21:45.809 --> 00:21:49.230
Obviously you're examining kernel
memory so it's a privileged operation.

00:21:49.230 --> 00:21:57.710
You would say target Darwin kernel as opposed to remote
KDP for the two machine debugging case and then attach

00:21:57.710 --> 00:22:01.390
and then you're connected to the debugger on the system.

00:22:01.390 --> 00:22:06.400
Then you would load your driver symbols
and kernel debugging macros as you would

00:22:06.400 --> 00:22:10.090
with the regular two machine or crashdump facility.

00:22:10.089 --> 00:22:16.419
And most kernel debugging macros can be used except the
one that we're actively altering state on the kernel.

00:22:16.420 --> 00:22:21.050
That's something that's not good
to do when the kernel's running.

00:22:21.049 --> 00:22:26.089
Also something you should keep in mind when using
this facility is that all the data you see is not,

00:22:26.089 --> 00:22:31.000
necessarily coherent because it might
be changing actively while you're looking

00:22:31.000 --> 00:22:33.819
at it, especially with kernel stacks.

00:22:33.819 --> 00:22:39.329
So if the thread is blocked for some reason, which
is typically why you would start up this facility,

00:22:39.329 --> 00:22:44.960
to explore why something is stuck in kernel
space, the thread stacks tend to be stable.

00:22:44.960 --> 00:22:51.529
One good way to ensure that things are stable is
just to look at them two or three times in succession

00:22:51.529 --> 00:22:54.079
to ensure that it's not changing actively.

00:22:54.079 --> 00:23:00.859
But a lot of, you know, facilities will be pretty much the
same as two machine debugging and you can explore the state

00:23:00.859 --> 00:23:06.219
of the system using this, this
kind of light kernel debugging.

00:23:06.220 --> 00:23:09.789
And at this rate only we decided to make that
the case because, you know,

00:23:09.789 --> 00:23:14.609
you can seriously compromise the stability
of the system using this facility.

00:23:14.609 --> 00:23:20.809
And unfortunately I have to go through these all over again.

00:23:20.809 --> 00:23:26.690
And it's a great learning tool so if you want to
understand how the kernel reacts to some external event

00:23:26.690 --> 00:23:33.500
or to some user initiated event that you can do
side by side while having this facility running,

00:23:33.500 --> 00:23:38.599
you can just figure out what exactly the kernel
does in response assuming your timing permits that.

00:23:38.599 --> 00:23:43.599
And it also lets you analyze block threads and
analyze kernel data structures, for example,

00:23:43.599 --> 00:23:48.549
to figure out what it is that's
not releasing a certain rough count

00:23:48.549 --> 00:23:52.210
or not letting you unmount a file
system, something like that.

00:23:52.210 --> 00:23:58.250
And it also lets you do low impact logging so you just
have your driver log a lot of data to a ring buffer,

00:23:58.250 --> 00:24:04.990
for instance, in the kernel and you can pull that data out
using this facility and it can be completely non-blocking

00:24:04.990 --> 00:24:11.019
and it's a good way to do, you know,
non-disruptive logging and tracing.

00:24:11.019 --> 00:24:17.160
And it also omits the need for you to
write user interfaces to any statistics

00:24:17.160 --> 00:24:20.750
and other data you might want to export from your driver.

00:24:20.750 --> 00:24:25.890
So if you want to keep statistics on the number of packets
you've sent or processed you don't need to write

00:24:25.890 --> 00:24:31.080
to write a an interface or
ask another interface to pull this out.

00:24:31.079 --> 00:24:33.799
You can just look up kernel memory directly.

00:24:33.799 --> 00:24:39.259
Obviously if you want to ship that to your user that's
not a good idea to tell them to start at the debugger.

00:24:39.259 --> 00:24:47.930
So, you know, it's mostly for interactive, you know,
debugging while you're developing your application.

00:24:47.930 --> 00:24:55.440
And it lets you, lets you introspect, you know, kernel data
structures as they're actively changing non-intrusively.

00:24:55.440 --> 00:24:58.080
So moving on to kernel panics.

00:24:58.079 --> 00:25:05.519
So, so let's go through and look at the type
of panics that could occur on the system

00:25:05.519 --> 00:25:09.519
and what exactly panics are and what they mean.

00:25:09.519 --> 00:25:11.430
So what triggers a panic?

00:25:11.430 --> 00:25:18.039
The first case is a processor generated
exception, which the kernel was unable to service.

00:25:18.039 --> 00:25:23.500
So this could include page faults, for instance, it's
just like user space where you could get a SIGSEGV

00:25:23.500 --> 00:25:28.670
or SIGBUS signal when you're not touching, when
you're touching memory that you haven't pre-allocated,

00:25:28.670 --> 00:25:31.390
you know, the analogy holds for the kernel.

00:25:31.390 --> 00:25:39.730
And if the page is protected or not there you will get a
page fault and the kernel will throw up its hands and say,

00:25:39.730 --> 00:25:45.220
Oh, you don't allocate this memory for me so
this is probably an error, so here's a panic.

00:25:45.220 --> 00:25:54.370
And if you attempt to generate any legal instruction, on
Intel you can often see panics, which are kind of like this

00:25:54.369 --> 00:25:57.849
but because of the variable instruction size
you may end up at an instruction boundary,

00:25:57.849 --> 00:26:03.659
which actually looks to the processor like a valid
instruction but it's not the instruction that you intended

00:26:03.660 --> 00:26:07.850
for the process to execute so you might
get a panic further down the line.

00:26:07.849 --> 00:26:09.759
That's something to keep in mind.

00:26:09.759 --> 00:26:19.109
And so of interest to driver developers, you might
see machine check exceptions and that's typically an error

00:26:19.109 --> 00:26:25.399
in the memory subsystem like, for example, an error on the
transport bus that you're using to access to your device.

00:26:25.400 --> 00:26:30.880
If your device is not ready and doesn't
respond to bus transactions or load history

00:26:30.880 --> 00:26:33.880
from the processor in time you might get a machine check.

00:26:33.880 --> 00:26:36.740
But it also might signal a hardware error.

00:26:36.740 --> 00:26:41.140
Some exotic possibilities include L2
cache parity errors and things like that.

00:26:41.140 --> 00:26:46.480
So it's a, you know, there are documents
from the processor manufacturers like Intel

00:26:46.480 --> 00:26:52.920
and IBM describing exactly what these
machine checks are caused by

00:26:52.920 --> 00:26:55.740
and it's good to look through those documents.

00:26:55.740 --> 00:27:00.460
And in Leopard we do log additional
data about machine checks.

00:27:00.460 --> 00:27:04.220
So it's a good way to understand, you know,

00:27:04.220 --> 00:27:08.670
examining the data to understand what exactly
could have triggered that machine check.

00:27:08.670 --> 00:27:18.220
Typically it happens when you access your device when
it's not yet ready or if it's wedged for some reason.

00:27:18.220 --> 00:27:22.579
And Intel-based Macs you do have a
few other exceptions that could occur.

00:27:22.579 --> 00:27:27.279
So you can have division exceptions, division of
load or divide by zero and things like that.

00:27:27.279 --> 00:27:31.059
You're probably not doing this in your kernel
extension unless you're doing something

00:27:31.059 --> 00:27:33.970
like audio for instance, but it's good to know.

00:27:33.970 --> 00:27:38.319
And general protection faults, those can
be triggered by a variety of conditions.

00:27:38.319 --> 00:27:40.789
I encourage you to look up the processor manual to figure

00:27:40.789 --> 00:27:44.269
out what exactly could have caused
the general protection fault.

00:27:44.269 --> 00:27:49.170
And you can also see, you could also
see double faults in some circumstances.

00:27:49.170 --> 00:27:52.480
Typically that means you have overflowed your kernel stack.

00:27:52.480 --> 00:27:57.599
That's signaled by a double fault because we keep
a guard page at the edge of the kernel stack.

00:27:57.599 --> 00:28:01.619
You can also have assertion style panics.

00:28:01.619 --> 00:28:08.909
Typically this happens when the kernel detects some sort of
inconsistency at one time and it decides it can't proceed

00:28:08.910 --> 00:28:14.290
because of this erroneous condition and it throws
up its hands and says, Ok, assertion failed here.

00:28:14.289 --> 00:28:15.970
We can't continue any further.

00:28:15.970 --> 00:28:20.610
And it's the responsibility of the
driver developer or whatever it is

00:28:20.609 --> 00:28:23.589
that triggered that assertion to fix that issue.

00:28:23.589 --> 00:28:29.750
For example, if you, if you decide to acquire a spin
log, for instance, we do use time spin locks in the kernel

00:28:29.750 --> 00:28:34.470
so if the time out expires on the spin
log acquisition you will get a panic.

00:28:34.470 --> 00:28:37.690
And there are a variety of different
lock manipulation errors,

00:28:37.690 --> 00:28:41.750
which can be signaled by an assertion failure type panic.

00:28:41.750 --> 00:28:45.480
And Mac OS X does have a fully preemptable kernel

00:28:45.480 --> 00:28:51.309
but under certain circumstances kernel preemption
is the disabled such as when you hold a spin lock

00:28:51.309 --> 00:28:55.589
and if you attempt to block from that context
or from an error context, for instance,

00:28:55.589 --> 00:29:01.839
someone asked that in the earlier session, you might
see this sort of panic and out of memory style panics,

00:29:01.839 --> 00:29:05.829
which are typically signaled by a zone allocator panic.

00:29:05.829 --> 00:29:13.109
On Intel based Macs we must maintain TLB coherence
using software generated inner processor interrupts.

00:29:13.109 --> 00:29:17.979
And the curious thing about this is that it
almost acts as a software watchdog so if one

00:29:17.980 --> 00:29:24.809
or more processors are spending way too much time with
interrupts disabled, you will see this sort of issue.

00:29:24.809 --> 00:29:27.299
So here we come to the infamous panic log.

00:29:27.299 --> 00:29:33.730
A lot of you have probably seen this on the screen or, you
know, from the panic report after you restart your machine

00:29:33.730 --> 00:29:40.450
that says, Hi, the system had to restart
unexpectedly and here is this cryptic looking report.

00:29:40.450 --> 00:29:45.319
So we'll go through and, you know, analyze
what exactly is there in this panic log.

00:29:45.319 --> 00:29:52.619
So the first line on this processor generated
exception style panic is the type of exception.

00:29:52.619 --> 00:29:56.389
For instance, this is probably the most common
hardware exception that you will see.

00:29:56.390 --> 00:29:57.800
It's a page fault.

00:29:57.799 --> 00:30:04.379
And, as I mentioned earlier, that's typically caused by
touching an allocated memory or a page zero, for instance,

00:30:04.380 --> 00:30:08.840
which we keep unmapped to catch pointer errors.

00:30:08.839 --> 00:30:15.279
And another thing to note is this is an Intel panic,
there are analogs for all of this on PowerPC.

00:30:15.279 --> 00:30:20.480
On Intel the CR2 register contains the address
of the page that you were trying to load

00:30:20.480 --> 00:30:22.230
or store from when you got the page fault.

00:30:22.230 --> 00:30:30.279
So that can be useful in certain circumstances to figure
out if you caused the panic by touching address zero

00:30:30.279 --> 00:30:32.430
or address something or the other or an offset

00:30:32.430 --> 00:30:37.529
from a certain structure pointer,
which happened to be zero for instance.

00:30:37.529 --> 00:30:43.279
And the most important thing from this register
display is the effective instruction pointer.

00:30:43.279 --> 00:30:47.389
So that's the address of the instruction
which triggered this fault.

00:30:47.390 --> 00:30:54.690
So in this case it might be a load or store to
this, to the address contained in the CR2 register.

00:30:54.690 --> 00:30:59.299
And for all those types of panics
you will, it's still pretty useful

00:30:59.299 --> 00:31:03.289
to know what the effects of instruction pointer was.

00:31:03.289 --> 00:31:12.069
And so you will also notice that in this particular panic
right below the backtrace there is a little display saying

00:31:12.069 --> 00:31:14.579
kernel modules in backtrace.

00:31:14.579 --> 00:31:18.679
And so the names here have been
changed to protect the guilty but,

00:31:18.680 --> 00:31:24.740
So in this case com dot apple dot sum driver
triggered, well could have triggered a panic

00:31:24.740 --> 00:31:28.640
because its addresses appear in the backtrace.

00:31:28.640 --> 00:31:33.630
And you will also, You will notice that
two addresses belong to the range described

00:31:33.630 --> 00:31:39.390
in the com dot apple dot sum driver
line right below the backtrace.

00:31:39.390 --> 00:31:45.960
It doesn't necessarily mean that this particular driver was
the approximate cause of the panic but it's always good,

00:31:45.960 --> 00:31:51.910
you know, to verify that your driver wasn't
performing some sort of erroneous operation,

00:31:51.910 --> 00:31:54.320
which lead in turn to a panic being triggered.

00:31:54.319 --> 00:31:57.839
This is not, This is just a general rule of thumb.

00:31:57.839 --> 00:32:01.500
And in cases of memory corruption and
things like that you have to realize

00:32:01.500 --> 00:32:06.869
that the kernels have large shared address space so
something else entirely could have triggered this issue,

00:32:06.869 --> 00:32:10.789
which shows up later as a panic
with your driver in the backtrace.

00:32:10.789 --> 00:32:17.049
So don't panic if you see this panic with, you know,
the your kext in the backtrace but do take a look

00:32:17.049 --> 00:32:22.769
and make sure it's not the case that your
driver is performing some bad operation.

00:32:22.769 --> 00:32:26.389
So here are a few assertion style panics.

00:32:26.390 --> 00:32:32.480
These are the panic messages that you will see when
these inconsistencies are detected by the kernel.

00:32:32.480 --> 00:32:34.829
So the first one is something I briefly described earlier.

00:32:34.829 --> 00:32:40.849
It contains the string zalloc and
the name of the zone, which was exhausted.

00:32:40.849 --> 00:32:46.549
And the kernel uses a zone allocator, which,
And this is the allocator which backs much

00:32:46.549 --> 00:32:49.309
of the allocations that you're likely to be doing.

00:32:49.309 --> 00:32:54.309
A lot of the allocate, allocators are
backed by the kernel zone allocator.

00:32:54.309 --> 00:32:59.240
This is somewhat similar to a slab allocator, which
you might have seen on other operating systems.

00:32:59.240 --> 00:33:03.799
And what it, Basically it's an out of memory solo session.

00:33:03.799 --> 00:33:12.430
the kernel couldn't find enough pages to satisfy this
allocation request and it threw up its hands and said, Ok,

00:33:12.430 --> 00:33:15.630
out of memory and we can't proceed further.

00:33:15.630 --> 00:33:22.110
And another common sort of issue that you might
see while developing your kernel, hopefully not,

00:33:22.109 --> 00:33:29.990
in release drivers is this particular sort of cryptic
looking message, thread invoke preemption level N,

00:33:29.990 --> 00:33:32.940
and N can be one or two, some low integer.

00:33:32.940 --> 00:33:40.110
And that particularly means that you or someone else
try to block while kernel preemption was disabled

00:33:40.109 --> 00:33:46.389
and that's an illegal operation because something has
previously signaled to the kernel that this is, you know,

00:33:46.390 --> 00:33:51.150
this is an operation that is uninterruptible
by the kernel scheduler and then

00:33:51.150 --> 00:33:54.480
yet that particular thread is trying to block.

00:33:54.480 --> 00:34:03.440
And one common possibility is that you've taken a spin lock
and you're trying to proceed to acquire a kernel mutex or,

00:34:03.440 --> 00:34:09.550
you know, proceeds to do some sort of blocking operation
that directly or indirectly while holding that spin lock

00:34:09.550 --> 00:34:14.070
or you could be trying to block from an interrupt context.

00:34:14.070 --> 00:34:20.070
This could also be signaled by this particular
style of panic and please pay attention to those

00:34:20.070 --> 00:34:25.200
because those are pretty serious errors and, you
know, you may not always see this sort of issue,

00:34:25.199 --> 00:34:31.329
especially if you're trying to, say, acquire a mutex while
preemption is disabled because 99 percent of the time

00:34:31.329 --> 00:34:34.610
that particular mutex might have
been free and only one percent

00:34:34.610 --> 00:34:39.950
of the time it actually caused
the mutex log retain to blocks.

00:34:39.949 --> 00:34:44.399
So it's a good thing to analyze thoroughly.

00:34:44.400 --> 00:34:48.230
As I mentioned earlier kernel spin locks do have deadlines.

00:34:48.230 --> 00:34:53.010
So if you're acquiring a spin lock either
directly or indirectly and for some reason

00:34:53.010 --> 00:34:58.460
that spin lock cannot be acquired you might see this
particular type of panic, simple lock, deadlock detection

00:34:58.460 --> 00:35:06.710
And that means that the spin lock acquisitioned
routine thought that the lock was not held

00:35:06.710 --> 00:35:11.789
for a pretty large interval, 100 plus milliseconds, and
that could be either because someone's holding on to the log

00:35:11.789 --> 00:35:17.940
for too long or there's some sort of memory corruption,
which has caused the log data structure to be corrupted.

00:35:17.940 --> 00:35:24.849
And as I mentioned earlier on Intel we have to maintain
a TLB coherence using inner processor interrupts.

00:35:24.849 --> 00:35:28.159
So, for instance, if one processor
is stuck with interrupts mast

00:35:28.159 --> 00:35:34.639
for too long it will eventually see another processor
which is doing some other operation, say, Ok,

00:35:34.639 --> 00:35:37.859
that processor isn't responding when I try to talk to it

00:35:37.860 --> 00:35:43.920
so this is probably something that's not
good for the system as a whole, let's panic.

00:35:43.920 --> 00:35:49.670
And so one good thing to, one good tool to, you know,
run every so often while you're developing your driver,

00:35:49.670 --> 00:35:54.990
especially if you have a routine that executes
in the primary interrupt filter context.

00:35:54.989 --> 00:35:58.599
So if you have supplied a routine,
as Dean mentioned earlier,

00:35:58.599 --> 00:36:02.599
to design good  shared interrupts,
for instance, that's a typical use.

00:36:02.599 --> 00:36:07.860
But if you're actually doing work in the primary interrupt
context it's good to run this tool called Latency,

00:36:07.860 --> 00:36:12.120
which will show you the systems
interrupt latency as a whole.

00:36:12.119 --> 00:36:18.909
So if you notice that this Latency tool is showing
excessive interrupt latency, typically, you know,

00:36:18.909 --> 00:36:22.670
more than 13 microseconds is kind of high.

00:36:22.670 --> 00:36:28.710
It's good to figure out what exactly your driver
is, if it is your driver, is causing that issue.

00:36:28.710 --> 00:36:34.730
And there is, Latency can generate traces from
the kernel tracing facility to be triggered

00:36:34.730 --> 00:36:38.219
when the successive interrupt latency is detected.

00:36:38.219 --> 00:36:41.689
Latency can also show you, schedule a preemption latency.

00:36:41.690 --> 00:36:44.860
So it's a good tool to run once in a while.

00:36:44.860 --> 00:36:54.820
So here's a typical analysis workflow to, you know, deploy
the kernel debugger and you've detected a panic or a hang.

00:36:54.820 --> 00:37:00.539
So if the system is panicked you would typically try and
connect the debugger assuming it is an accessible system.

00:37:00.539 --> 00:37:06.389
But, you know, if you're getting a panic log from the, from
the field from your customer and you're customer hasn't set

00:37:06.389 --> 00:37:11.900
up kernel crash terms, all you may have
is that little screen we showed earlier.

00:37:11.900 --> 00:37:18.200
And often that's insufficient but in many cases it
might be sufficient to give you a handle on the problem.

00:37:18.199 --> 00:37:22.419
So it's basically the backtrace for
the thread that caused the fault.

00:37:22.420 --> 00:37:27.970
And as I mentioned it's a large shared address space and
there are many threads operating in this address space.

00:37:27.969 --> 00:37:34.759
But, you know, if it's a page fault you can at least
tell which thread caused the page fault and, you know,

00:37:34.760 --> 00:37:40.010
which line of code caused the page fault and you can
eyeball the code and figure out if there are any conditions

00:37:40.010 --> 00:37:43.370
under which, you know, this pointer
could be bad, for instance

00:37:43.369 --> 00:37:50.559
And if you, If that's not sufficient you can
always go ahead and reproduce the issue in house.

00:37:50.559 --> 00:37:54.730
And one little side note about
debugging philosophy, if I may.

00:37:54.730 --> 00:38:02.840
So there's two, You know, you can, you can approach
a debugging issue in one of two ways or both ideally.

00:38:02.840 --> 00:38:09.150
One is the top down approach where you figure out what
exactly was going on at the time of the panic, for instance,

00:38:09.150 --> 00:38:16.119
and then try to instrument those code paths to figure
out the data flow at the time of the panic and, you know,

00:38:16.119 --> 00:38:21.029
approach the problem from, you
know, the user space side of things

00:38:21.030 --> 00:38:24.850
or from the initial point at which
this issue could have occurred.

00:38:24.849 --> 00:38:30.869
And the other approach is the bottom up approach where
you have a panic and you use the debugger to backtrack

00:38:30.869 --> 00:38:35.960
from the time of the panic to what exactly
the root cause of the panic might be.

00:38:35.960 --> 00:38:42.599
And ideally you would employ both approaches, especially for
the harder sort of problem, which isn't readily apparent.

00:38:42.599 --> 00:38:47.049
The best way to solve those problems is to get,
you know, a complete understanding of the picture

00:38:47.050 --> 00:38:53.170
and use both the debugger and your knowledge
of your own code to understand the panic.

00:38:53.170 --> 00:38:54.780
There is no silver bullet to debugging.

00:38:54.780 --> 00:38:59.269
It completely depends on your having
an understanding of your code.

00:38:59.269 --> 00:39:03.840
I'm sure I'm stressing the obvious but it's good to note.

00:39:03.840 --> 00:39:10.059
If the system is hung, in other words, you have a,
you know, a system that's not responsive to, you know,

00:39:10.059 --> 00:39:17.259
user events like mass clicks and keyboard interrupts
and so on and so forth and you can't SSH into the system,

00:39:17.260 --> 00:39:20.280
it could mean that there's a kernel
level hang and, you know,

00:39:20.280 --> 00:39:23.650
it's always good to get those fixed as soon as possible.

00:39:23.650 --> 00:39:28.590
So you would force the debugger, force the
machine into the debugger using the NMI button.

00:39:28.590 --> 00:39:35.730
And depending on the system model at the NMI
button, which is actually a bit of a misnomer,

00:39:35.730 --> 00:39:42.409
might lie at different spots but on most recent machines
once you've configured kernel debugging you would just hit

00:39:42.409 --> 00:39:47.299
the power switch on the machine and that will
tell the kernel to enter the kernel debugger

00:39:47.300 --> 00:39:51.019
and then you would attach with the kernel debugger.

00:39:51.019 --> 00:39:55.130
One very useful kernel debugging macro, which you will find

00:39:55.130 --> 00:39:59.099
that the kernel debug kit mentioned
earlier is the show all stacks macro

00:39:59.099 --> 00:40:04.529
and this will essentially generate a kernel, a
stack trace for all kernel threads on the system.

00:40:04.530 --> 00:40:10.240
And so you can get a complete picture of what all kernel
threads were doing at the time of the panic or hang.

00:40:10.239 --> 00:40:14.319
And one thing to note is that, you
know, we are a Mach descended kernel

00:40:14.320 --> 00:40:18.330
so we do employ this technique called kernel continuation.

00:40:18.329 --> 00:40:23.190
So some threads can discard their
kernel stacks in favor of continuations.

00:40:23.190 --> 00:40:25.300
This helps, you know, save wide memory.

00:40:25.300 --> 00:40:32.690
And also, you know, if at all possible that you can
restart an operation when receiving a certain signal

00:40:32.690 --> 00:40:35.170
without relying on information on the stack.

00:40:35.170 --> 00:40:40.090
You can tell the scheduler that
you're discarding your kernel stack.

00:40:40.090 --> 00:40:47.890
And typically those threads with continuations are not very
interesting from the hang or panic analysis perspective.

00:40:47.889 --> 00:40:50.579
If you're every puzzled about what's
going on, that's what happening.

00:40:50.579 --> 00:40:54.489
I'll be happy to explain that in greater detail later.

00:40:54.489 --> 00:41:02.939
And so I hope this is visible to you. So this is
what you'll see. This is a fragment of the showallstacks

00:41:02.940 --> 00:41:10.670
effort. So, for instance, the first thing I have circled
here is the name, the name of the process to,

00:41:10.670 --> 00:41:13.250
for which the kernel stack that's
being displayed corresponds to.

00:41:13.250 --> 00:41:19.429
So threads, you know, have both a
user space and a kernel competent.

00:41:19.429 --> 00:41:24.569
And if a thread is blocked it will have a
kernel space competent in the kernel stack.

00:41:24.570 --> 00:41:31.400
So this is, for instance, this is the window
server process and this is its process ID.

00:41:31.400 --> 00:41:41.030
So one important thing to note is that most of the kernel
synchronization primitives are backed by condition variables

00:41:41.030 --> 00:41:44.769
and in mock terminology these are wait cues and wait events.

00:41:44.769 --> 00:41:53.230
So whenever you block on a mutex, for instance, it, you
know, signals that it must be woken up by stating that,

00:41:53.230 --> 00:41:56.110
you know, it's waiting for a certain condition variable.

00:41:56.110 --> 00:42:03.260
And when the owner of the mutex unlocks that
mutex it will basically send a signal to the owner

00:42:03.260 --> 00:42:06.530
of the condition variable using the wake up mechanism.

00:42:06.530 --> 00:42:10.470
And when I say signal I don't mean
the user space concept of signal

00:42:10.469 --> 00:42:14.859
but just a notification to the
scheduler to wake up that thread.

00:42:14.860 --> 00:42:19.030
And this is, this is the, basically
the address of that condition variable.

00:42:19.030 --> 00:42:23.850
So if your thread is blocked this is
the condition variable it's waiting on.

00:42:23.849 --> 00:42:26.679
And there can be, If you have a deadlock, for instance,

00:42:26.679 --> 00:42:28.960
there can be numerous other threads
with the same weight event.

00:42:28.960 --> 00:42:31.550
So it's a good way to do first order analysis

00:42:31.550 --> 00:42:37.190
of which particular threads are blocked
on which particular condition variable.

00:42:37.190 --> 00:42:42.909
There's also the scheduler state for the thread,
which is displayed by the show all stacks command

00:42:42.909 --> 00:42:48.969
and in this particular case the W character
indicates that the scheduler thinks

00:42:48.969 --> 00:42:51.669
that this thread is currently in a wait state.

00:42:51.670 --> 00:42:55.050
It's waiting for a wake up basically.

00:42:55.050 --> 00:42:59.280
And this is what I mentioned earlier
with the kernel continuation.

00:42:59.280 --> 00:43:04.150
For example, this is a mock IPC
message queue received continuation.

00:43:04.150 --> 00:43:07.269
So that particular thread has discovered the kernel stack

00:43:07.269 --> 00:43:14.809
and when it's rescheduled it will resume
executing using this continuation routine.

00:43:14.809 --> 00:43:20.079
And, yeah, that's basically the
address of that continuation.

00:43:20.079 --> 00:43:26.789
So, for instance, if you, One good thing to note,
whenever you have a Z ALOC style panic or if you're,

00:43:26.789 --> 00:43:33.650
if you just want to figure out, you know, how much memory
is, you know, break out of the kernel memory and use,

00:43:33.650 --> 00:43:36.230
there's a pretty good macro called Z Print.

00:43:36.230 --> 00:43:41.940
This does have a user space analog that you can run
without entering the kernel debugger also called Z Print.

00:43:41.940 --> 00:43:48.750
And it will display the statistics for the internal zone
allocator describing, you know, basically the breakdown

00:43:48.750 --> 00:43:53.179
of in use elements and maximum
number of elements of for each zone.

00:43:53.179 --> 00:43:59.009
And so a lot of kernel allocation requests
come from the K Alloc allocator

00:43:59.010 --> 00:44:05.610
and that basically has several dedicated
zones sized by the size it's rounded up to.

00:44:05.610 --> 00:44:08.840
So it's a good thing to look at the K Alloc zones too.

00:44:08.840 --> 00:44:16.930
If you, if you think you're using a memory backed
by the K Alloc allocator, especially in situations

00:44:16.929 --> 00:44:20.269
where you have the Z Alloc zone exhaustion type panic.

00:44:20.269 --> 00:44:22.269
This is a good kmount to run.

00:44:22.269 --> 00:44:29.650
There are also some I/O Kit specific kernel debugging
macros like show all I/O Alloc and show all classes,

00:44:29.650 --> 00:44:36.150
which display the I/O Kit resources and the clause
instance counts that your driver is using, for instance.

00:44:36.150 --> 00:44:41.720
So it's a good way to determine
what exactly you're using in terms

00:44:41.719 --> 00:44:46.099
of I/O Kit resources backed by the generic kernel mechanisms.

00:44:46.099 --> 00:44:48.809
There are user space analogs to some of these.

00:44:48.809 --> 00:44:55.719
There's an IO clause count command, which displays the
instant count for, instance count for I/O Kit clauses.

00:44:55.719 --> 00:45:02.779
And going back to the memory allocation issue, there's
a very useful user space command called VM start,

00:45:02.780 --> 00:45:09.160
which displays statistics for the
kernel virtual memory manager.

00:45:09.159 --> 00:45:17.279
One good thing to note is show all stacks just basically
displays macro generated backtrace for each thread.

00:45:17.280 --> 00:45:22.860
If you want to examine the threads state
directly using GDB's backtrace command,

00:45:22.860 --> 00:45:26.769
you can use this kernel debugging
macro called Switch to Act.

00:45:26.769 --> 00:45:33.750
That basically tells the debugger to repoint its context to
the state for the other thread that you're pointing it to

00:45:33.750 --> 00:45:40.130
and you would path the thread address, which you'll obtain
from show all stacks to this kernel debugging macro.

00:45:40.130 --> 00:45:46.309
And then you can use backtrace and commands like frame to
switch down to the stack frame and examine locals and things

00:45:46.309 --> 00:45:49.869
like that using the standard GDB commands.

00:45:49.869 --> 00:45:55.619
If the system is hung, for instance, what you would do
is you would examine all the kernel stacks displayed

00:45:55.619 --> 00:46:01.650
by show all stacks to figure out which threads are
basically blocked waiting for some event to happen.

00:46:01.650 --> 00:46:08.190
And one particular shortcut you can employ to determine
which threads are blocked in the same resources

00:46:08.190 --> 00:46:11.010
to look at the wait events for various threads.

00:46:11.010 --> 00:46:16.710
And if one of those threads is blocked in a particular wait
event and, you know, just several other threads are blocked

00:46:16.710 --> 00:46:22.809
in the same wait event it's possible that all of those
threads will have similar looking stack backtraces

00:46:22.809 --> 00:46:26.460
but you can end up waiting for a
particular resource in multiple ways.

00:46:26.460 --> 00:46:30.460
This is a good shortcut to employ,
just look at the wait events to figure

00:46:30.460 --> 00:46:34.760
out which particular condition variable
they're waiting to be woken up on.

00:46:34.760 --> 00:46:42.560
And you would choose one particular block
thread to analyze and then you can, you know,

00:46:42.559 --> 00:46:48.619
try and figure out which particular resource it's trying
to acquire and figure out the owner of that resource.

00:46:48.619 --> 00:46:52.670
There are many different possibilities for deadlocks.

00:46:52.670 --> 00:46:59.829
You can have the classic circular deadlock where two or
more threads are involved and basically there's a cycle

00:46:59.829 --> 00:47:03.179
and a graph of their resource dependencies.

00:47:03.179 --> 00:47:09.829
And you could be trying to talk to a device that's
unresponsive while holding a lock, for instance,

00:47:09.829 --> 00:47:15.960
and other threads are trying to access that particular
resource or that lock and they're all blocked waiting

00:47:15.960 --> 00:47:18.880
for the thread that's trying to access the device.

00:47:18.880 --> 00:47:28.059
And if you have a user space dependency that the kernel
thread is stuck on, which is not always a good idea.

00:47:28.059 --> 00:47:31.980
You could end up waiting for that
user space dependency to be satisfied.

00:47:31.980 --> 00:47:37.650
You could have a process that's died for some reason in
user space and you're waiting for that to get back to you

00:47:37.650 --> 00:47:40.190
or you could be stalling other kernel events.

00:47:40.190 --> 00:47:42.590
And there are many other possibilities.

00:47:42.590 --> 00:47:45.500
Here's one particular sort of case study.

00:47:45.500 --> 00:47:52.289
It's a classic two way deadlock that was detected
recently by someone on our networking team,

00:47:52.289 --> 00:47:55.279
Adi, whom you might have heard speak earlier.

00:47:55.280 --> 00:48:04.900
So there's, there's a kernel thread from the networking
card, which is trying to acquire a mutex in the UDP layer

00:48:04.900 --> 00:48:08.650
and you will notice that there's
a frame which says UDP lock.

00:48:08.650 --> 00:48:18.590
The UDP lock routine is in turn calling one of the kernel
mutex primitives LCK MTX lock and that mutex is, you know,

00:48:18.590 --> 00:48:24.079
And then the lock acquisition routine
noticed that that mutex is not free

00:48:24.079 --> 00:48:27.539
and it proceeds to block waiting for a wake up.

00:48:27.539 --> 00:48:33.289
So what you would do in this case is you would employ the
Switch to Act command to switch this particular thread.

00:48:33.289 --> 00:48:39.969
The thread hasn't panicked so, you know, or been
interrupted so you would need to switch the debugger away

00:48:39.969 --> 00:48:44.399
from whatever thread it was interrupted
in and switch to this particular thread.

00:48:44.400 --> 00:48:50.190
And then you can switch to the frame, the lock mutex
lock frame with the debugger using the frame command

00:48:50.190 --> 00:48:55.320
and dump out the contents of that lock mutex lock structure.

00:48:55.320 --> 00:49:00.220
We are going to be giving you macros to obstruct
away the internals of this lock structure

00:49:00.219 --> 00:49:04.339
but for now you can just directly
display the contents of this mutex lock.

00:49:04.340 --> 00:49:11.440
And you will notice that there's a field called LCK
MTX D locked and that basically holds the address

00:49:11.440 --> 00:49:13.690
of the thread, which has locked the mutex.

00:49:13.690 --> 00:49:19.639
So you will notice that there's a
number X3912804 in the locked field.

00:49:19.639 --> 00:49:25.710
So subsequently you can, you know, display
the state of that thread which owns that mutex

00:49:25.710 --> 00:49:30.090
and then you can do the same thing
again, switch to act that mutex.

00:49:30.090 --> 00:49:34.980
And you will notice that mutex also
is trying to acquire a mutex lock.

00:49:34.980 --> 00:49:41.690
So when you switch to that thread you will notice
that it's trying to acquire a different mutex lock,

00:49:41.690 --> 00:49:45.750
which is owned by the first thread, which is
trying to acquire a lock held by this thread.

00:49:45.750 --> 00:49:48.079
So this is a classic two way deadlock.

00:49:48.079 --> 00:49:51.779
Pretty simple to analyze but there can
be more complicated variations on this.

00:49:51.780 --> 00:49:57.700
You can have, you know, ten different threads all trying
to sort of chase their tails and trying to acquire mutexes

00:49:57.699 --> 00:50:00.969
which eventually are owned by something else in the chain.

00:50:00.969 --> 00:50:06.299
And so this is how you'll typically
get started trying to analyze hangs.

00:50:06.300 --> 00:50:09.190
There are numerous variations on these.

00:50:09.190 --> 00:50:13.250
I will note that we do have a kernel
debugging lab this evening so if you're dealing

00:50:13.250 --> 00:50:19.280
with some particularly intractable issue we will
be glad to help look at that issue and tell you how

00:50:19.280 --> 00:50:21.830
to go about debugging this sort of thing.

00:50:21.829 --> 00:50:27.639
And one sort of good technique to
employ, which will ease debugging is,

00:50:27.639 --> 00:50:34.159
so whenever you notice an exceptional condition, especially
in the development phase it's good to log that condition.

00:50:34.159 --> 00:50:38.379
It might end up in the system log but if you
panic before that at least you will have access

00:50:38.380 --> 00:50:42.769
to trace messages in the kernel system log ring buffer.

00:50:42.769 --> 00:50:49.170
And, you know, obviously it's not good to be very verbose
so a lot of people are going to be looking at this panic log

00:50:49.170 --> 00:50:55.670
so if your application or driver is very
chatty, that's, you know, kind of annoying.

00:50:55.670 --> 00:51:02.329
There is a kernel routine called OS backtrace, which lets
you dynamically generate stack traces so if, for example,

00:51:02.329 --> 00:51:09.509
if you try to analyze a leak or something, for instance,
or a rough counting issue, you can log a backtrace for,

00:51:09.510 --> 00:51:14.870
you know, each rough count increment, for
instance, to figure out who is not letting go

00:51:14.869 --> 00:51:21.049
of that last reference count, for instance,
or you can employ it in many different ways.

00:51:21.050 --> 00:51:24.420
There is a kernel debugging macro
in Leopard called system log,

00:51:24.420 --> 00:51:28.430
which dumps out the contents of
the kernel's messaging buffer.

00:51:28.429 --> 00:51:34.089
So if you IO log or print from within your
driver, for instance, that's where it'll end up.

00:51:34.090 --> 00:51:39.470
And depending on how verbose the rest of
the system is it might still be in memory.

00:51:39.469 --> 00:51:42.459
If not it might have been pushed out to disk.

00:51:42.460 --> 00:51:49.019
The other thing to note is that, you know, you can't
always rely on the debugger displaying the right thing.

00:51:49.019 --> 00:51:53.400
It's an unfortunate but true sort of aphorism.

00:51:53.400 --> 00:52:00.430
And DWARF is a great step in the right direction,
you know, stabs was kind of inadequate for the component

00:52:00.429 --> 00:52:04.690
debugger to describe the
complexities of automized code.

00:52:04.690 --> 00:52:13.000
Dwarf does have a lot of support for displaying things
like line ray splitting and register motion, all of that,

00:52:13.000 --> 00:52:18.969
to figure out where exactly, If you're interrupted at a
particular point in the function, where exactly your local,

00:52:18.969 --> 00:52:22.549
which might be in a register, lives
in the stack, for instance.

00:52:22.549 --> 00:52:28.949
So things are improving in that area but this is why it's
almost essential to have a good understanding of the ABI

00:52:28.949 --> 00:52:32.460
and calling conventions for the
platforms that you're interested in.

00:52:32.460 --> 00:52:40.559
So, you know, if you notice something looks weird that's
not because of panic it's always good to double check

00:52:40.559 --> 00:52:44.409
that using your knowledge of calling
conventions for the platform.

00:52:44.409 --> 00:52:49.230
And, again, as a general rule of thumb,
you know, always program defensively.

00:52:49.230 --> 00:52:53.980
You know, this might be as simple as checking
the return value of malloc and, you know,

00:52:53.980 --> 00:52:58.199
checking that it's not nulled before trying
to access that thing that you malloc'd.

00:52:58.199 --> 00:53:01.849
But, you know, also more comprehensively, you know,

00:53:01.849 --> 00:53:07.779
try and make sure that you don't have any
assumptions that cannot be relied upon.

00:53:07.780 --> 00:53:13.800
Obviously this takes a backseat to performance so, you know,
you can always have a development version for your driver

00:53:13.800 --> 00:53:17.880
that is sprinkled with lots of
assertions to trigger a run time,

00:53:17.880 --> 00:53:22.079
that you can enable a run time during the development phase.

00:53:22.079 --> 00:53:24.190
And some miscellaneous points.

00:53:24.190 --> 00:53:33.530
So this is stuff that, you know, we didn't cover elsewhere
and doesn't really fit into any predefined category.

00:53:33.530 --> 00:53:38.010
You will notice that a lot of kernel
behavior is controlled by bootargs.

00:53:38.010 --> 00:53:41.840
So kernel behavior can also be
controlled by sys ETLS.

00:53:41.840 --> 00:53:46.269
There's a sisiteal interface to a lot of these things.

00:53:46.269 --> 00:53:50.750
To set kernel boot-args you can use the MB RAM command.

00:53:50.750 --> 00:53:54.329
That does require super user privileges
and it does have a man page.

00:53:54.329 --> 00:54:03.710
So that basically sets rights to an area and the flash
on the device and the kernel or the boot-arg will read

00:54:03.710 --> 00:54:06.510
that on start up and process on to the kernel.

00:54:06.510 --> 00:54:13.530
And on an Intel based Mac you can also pass these
kernel boot arguments using this particular P list.

00:54:13.530 --> 00:54:15.890
The behavior of the kernel debugger is, you know,

00:54:15.889 --> 00:54:19.769
mostly controlled by this one particular
bootarg called the debug bootarg.

00:54:19.769 --> 00:54:24.079
This is a pretty good list of what all the
debug bootargs mean and the kernel crash

00:54:24.079 --> 00:54:28.599
down tech mode 2118, which is !listed earlier.

00:54:28.599 --> 00:54:33.089
Some other useful bootargs to know are the maximum bootarg,

00:54:33.090 --> 00:54:35.660
counts the amount of physical memory
available in the kernel.

00:54:35.659 --> 00:54:41.129
It's a good way to test your application or
driver under low memory situations, for instance,

00:54:41.130 --> 00:54:46.860
without having to actually physically
remove the DIMS on the device.

00:54:46.860 --> 00:54:54.160
And dash V enables verbose boot and, you know, a lot
of the messages generated by the kernel and drivers end

00:54:54.159 --> 00:54:58.969
up on the screen during start up, for
instance, and it's a good thing too.

00:54:58.969 --> 00:55:02.500
Look through, while things are going
on, especially if you're trying

00:55:02.500 --> 00:55:06.820
to determine why exactly your kernel isn't quite booted yet.

00:55:06.820 --> 00:55:10.110
Something might have logged something
and you can look at it on screen.

00:55:10.110 --> 00:55:12.079
And there's another bootarg called CPU's.

00:55:12.079 --> 00:55:16.980
It's an alternative to the CHUD preference frame.

00:55:16.980 --> 00:55:21.590
It basically lets you control the number
of CPU's that are visible of the scheduler.

00:55:21.590 --> 00:55:27.590
So if you want to, if you suspect a sort of a
multi-threaded erase that happens under, you know,

00:55:27.590 --> 00:55:36.070
an MP sort of circumstance you can say CPU is equal to one
and restart the kernel and that basically makes the kernel

00:55:36.070 --> 00:55:40.550
UP at that point and you can figure
out if the behavior of this particular,

00:55:40.550 --> 00:55:44.519
the issue that you're looking at
varies in that circumstance.

00:55:44.519 --> 00:55:51.130
There are a few options that you could
use to ensure that the, you know,

00:55:51.130 --> 00:55:54.720
to trigger run time consistency
checks for the zone allocator.

00:55:54.719 --> 00:56:02.250
One such option is the dash ZC bootarg and that
basically tells the zone allocator to check

00:56:02.250 --> 00:56:06.340
that freed elements aren't being
used after they've been freed.

00:56:06.340 --> 00:56:11.789
It's sort of analogist of what you
would do with malloc and user space.

00:56:11.789 --> 00:56:18.000
And we are working to provide a better sort
of memory analysis facilities for the future.

00:56:18.000 --> 00:56:26.349
And other bootargs, there's a pretty useful bootarg called
IO equals two and the various options that you can set.

00:56:26.349 --> 00:56:28.349
It's basically a bit factor.

00:56:28.349 --> 00:56:32.789
And that controls a lot of I/O Kit debugging facilities.

00:56:32.789 --> 00:56:38.460
You can say IO log should be synchronized or
log all registry modifications, for instance.

00:56:38.460 --> 00:56:46.340
And, you know, there are a lot of options here that can
catch various, you know, I/O Kit level manipulation errors.

00:56:46.340 --> 00:56:48.250
So it's good to explore that.

00:56:48.250 --> 00:56:53.599
And you can look at the slide or look
at the source code when it's available.

00:56:53.599 --> 00:57:01.309
That brings me to another point, and a lot of you are going
to pounce on me for saying this but we do release the source

00:57:01.309 --> 00:57:07.039
for a lot of our kernels, not always
immediately but they do get there eventually.

00:57:07.039 --> 00:57:14.500
So we're available to source as your best documentation
as, you know, Who said use the force, Luke?

00:57:14.500 --> 00:57:16.260
Use the source, Luke.

00:57:16.260 --> 00:57:25.710
And there's also a special kernel configuration called
the debug kernel and this is something we're going to look

00:57:25.710 --> 00:57:31.610
into releasing in the Kernel Debug Kit in the future
but for now the open source kernel you can, you know,

00:57:31.610 --> 00:57:37.289
build it in debug mode and that enables a lot
of run time consistency checks and assertions,

00:57:37.289 --> 00:57:42.230
especially in terms of locking and VM level operations.

00:57:42.230 --> 00:57:48.900
It does catch, you know, a lot of
frequent or over sights like things

00:57:48.900 --> 00:57:52.079
like releasing a mutex that you
don't own and things like that.

00:57:52.079 --> 00:57:58.329
Or if you have a recursive mutex, you know, you
are the only one who is allowed to lock in once

00:57:58.329 --> 00:58:01.889
and if someone else is locking
it for you that will be signaled.

00:58:01.889 --> 00:58:10.000
So for more information you can contact Craig Keithley,
who is the I/O Technology Evangelist for this track.

00:58:10.000 --> 00:58:18.309
And there's documentation for all of this and you can always
download my slides later and look at those and there's also,

00:58:18.309 --> 00:58:24.630
you can always contact DTS or developer
tech support for help with your driver.

00:58:24.630 --> 00:58:31.829
And I do want to stress that there is a kernel debugging
lab this evening and all of you are welcome to stop by and,

00:58:31.829 --> 00:58:39.269
you know, pose questions to us or have us walk through the
kernel debugging process or look at a particular panic or,

00:58:39.269 --> 00:58:44.019
you know, crash that you have
and we will do our best to help you.

00:58:44.019 --> 00:58:51.250
So to summarize, you know, there are several different
approaches you can take to kernel debugging on Mac OS X

00:58:51.250 --> 00:58:54.579
and you can, you know, by understand,
by developing a good understanding

00:58:54.579 --> 00:59:01.170
of these facilities you can really shorten your
workflow and your driver development process.

00:59:01.170 --> 00:59:04.389
It's really essential for post modern
analysis to get a good understanding

00:59:04.389 --> 00:59:08.839
of what exactly happened after
you've had a panic, for instance.

00:59:08.840 --> 00:59:11.730
And there are some new tools in
Leopard, as I mentioned earlier.
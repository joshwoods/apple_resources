WEBVTT

00:00:12.980 --> 00:00:14.200
>> Steve: Good morning.

00:00:14.199 --> 00:00:20.140
Welcome to session 318, Using Xray
and DTrace for In-Depth Analysis.

00:00:20.140 --> 00:00:25.630
My name is Steve Lewallen, and I'm the Performance
Tools Manager within developer technologies at Apple.

00:00:25.629 --> 00:00:31.809
And this is our last installment of a three part series
really this week on Tracing with Xray and DTrace.

00:00:31.809 --> 00:00:36.199
So in today's agenda, we're going to
do a quick overview of Xray and DTrace

00:00:36.200 --> 00:00:39.270
in case any of you missed any of the other sessions.

00:00:39.270 --> 00:00:43.609
Then we're going to go over building
custom DTrace instruments in Xray.

00:00:43.609 --> 00:00:50.469
We'll take a slight turn and then we'll discuss alternate
ways to use Xray other than the normal double click it

00:00:50.469 --> 00:00:56.600
in the finder, etc. Those ways include using quick
start keys, which is a point and shoot mechanism,

00:00:56.600 --> 00:01:02.289
a command line Xray and remote tracing with Xray and DTrace.

00:01:02.289 --> 00:01:08.260
Finally, we're going to talk about inserting
DTrace static probes into your code.

00:01:08.260 --> 00:01:11.850
So let's quickly do an Xray review.

00:01:11.849 --> 00:01:17.519
As you may recall, when you start Xray
you're presented with a template chooser.

00:01:17.519 --> 00:01:25.629
And the template chooser has templates that are subsets of
instruments geared towards solving a particular problem.

00:01:25.629 --> 00:01:32.299
If you don't want to apply instruments in that manner, you
can go to the Xray Instrument Library and choose instruments

00:01:32.299 --> 00:01:35.060
from there and apply them to your document.

00:01:35.060 --> 00:01:41.040
In other case, we then set up your instruments if they
have any other settings that you need to configure,

00:01:41.040 --> 00:01:44.940
we try our best to have good defaults,
but you may want to fiddle with those.

00:01:44.939 --> 00:01:49.409
And finally, you pick a target, what do
you want to trace and gather data on?

00:01:49.409 --> 00:01:55.009
Record it, you gather the date and you use the
different facilities in Xray to mine the data.

00:01:55.010 --> 00:01:59.689
Go in to a call tree view, inverting it,
filtering out different libraries, etcetera.

00:01:59.689 --> 00:02:02.509
That's a very quick overview of Xray.

00:02:02.510 --> 00:02:06.430
So now let's move on to an overview of DTrace.

00:02:06.430 --> 00:02:13.200
So DTrace is a dynamic tracing framework that
Sun developed and open sourced on Solaris.

00:02:13.199 --> 00:02:19.560
Over the past year we have take it, imported
it to our Intel and power PC platforms.

00:02:19.560 --> 00:02:22.629
It's a zero disabled cost tracing mechanism.

00:02:22.629 --> 00:02:28.000
It's always there, but until you use it,
you're not really paying a cost for it.

00:02:28.000 --> 00:02:32.259
After you're done using it, again,
you're not paying a cost for it again.

00:02:32.259 --> 00:02:40.269
Its system wide, so it's available in the kernel on up and
it's on all of our installs, whether that's a user install,

00:02:40.270 --> 00:02:44.670
a developer tools install, or the server.

00:02:44.669 --> 00:02:47.979
And it's scriptable.

00:02:47.979 --> 00:02:51.039
It's scriptable using the D language.

00:02:51.039 --> 00:02:58.599
This language, when you write it, create a script with it,
is compiled down to byte code and interpreted in the kernel.

00:02:58.599 --> 00:03:03.639
Therefore, it's designed to be very
tight and compact, safe and performant.

00:03:03.639 --> 00:03:07.889
So it actually doesn't have loop
structures, for example, or branching.

00:03:07.889 --> 00:03:14.799
You can't define your own user functions or call
out to user space, but it is still very powerful.

00:03:14.800 --> 00:03:17.640
Even variable declarations are optional.

00:03:17.639 --> 00:03:18.469
It's very dynamic.

00:03:18.469 --> 00:03:23.569
You just kind of go with the flow as you
do with a lot of scripting languages.

00:03:23.569 --> 00:03:26.699
So it all centers around the concept of a probe.

00:03:26.699 --> 00:03:32.269
This defines the events that you're
interested in finding information about.

00:03:32.270 --> 00:03:36.170
And you can describe product kits or
conditions upon which the probe fires,

00:03:36.169 --> 00:03:39.339
the actions which should be taken when that happens.

00:03:39.340 --> 00:03:42.280
And to get a list of available probes on the system,

00:03:42.280 --> 00:03:48.819
you can use the DTrace command line
option, -l. So how does DTrace work?

00:03:48.819 --> 00:03:59.669
Well, whether you have a DTrace script or you have created a
DTrace instrument in Xray, that probe is sent to Lib DTrace

00:03:59.669 --> 00:04:04.909
and compiled down to byte code and sent on
to the kernel to the DTrace virtual machine.

00:04:04.909 --> 00:04:11.180
The DTrace Virtual Machine analyzes that and attaches it
to the various providers that you've specified interest in.

00:04:11.180 --> 00:04:23.009
If those providers have information to send back, they do
so back through the virtual machine, back through Lib DTrace

00:04:23.009 --> 00:04:27.730
and out to either the console,
if you ran from the command line,

00:04:27.730 --> 00:04:32.330
or through the DTrace instrument and on to the Xray UI.

00:04:32.329 --> 00:04:37.729
So that's a quick overview of both Xray and DTrace.

00:04:37.730 --> 00:04:42.950
Now let's move on to building custom
instruments in Xray with DTrace.

00:04:42.949 --> 00:04:45.959
Why would you want to do this?

00:04:45.959 --> 00:04:52.449
Well, you know your own code and you can create
domain specific probe points for your own code.

00:04:52.449 --> 00:04:59.300
Maybe you have a database and you want to
track begin and end transaction or something.

00:04:59.300 --> 00:05:01.699
You can also tailor this for different tasks.

00:05:01.699 --> 00:05:08.279
You could be bug hunting, so you're just varying your
scripts, looking for different bugs, following your nose.

00:05:08.279 --> 00:05:15.489
Perhaps your creating an aggression test suite such
that you would run a set of DTrace instruments in Xray

00:05:15.490 --> 00:05:20.220
to gather general performance data
of your app before each release

00:05:20.220 --> 00:05:24.560
to see how memory use has grown or
shrunk and performance, etcetera.

00:05:24.560 --> 00:05:32.110
Or perhaps you're a network administrator who is
creating scripts to monitor system on the network.

00:05:32.110 --> 00:05:36.300
Now what you see before you now is
the DTrace Instrument Builder in Xray.

00:05:36.300 --> 00:05:41.360
To use it, the first thing you need to
do is actually describe your instrument.

00:05:41.360 --> 00:05:48.310
You give it a name, a category, you can use one
of your own or ours, and a good description.

00:05:48.310 --> 00:05:54.149
Now you should make sure that you use good key words
in these fields because this represents your instrument

00:05:54.149 --> 00:05:57.879
in the library, the Xray Library
we just saw during the Xray review.

00:05:57.879 --> 00:06:03.230
And if someone searches in that library, they'll
hit your keywords if you've chosen appropriately.

00:06:03.230 --> 00:06:08.920
So the next thing you want to do
is define the body of your probe.

00:06:08.920 --> 00:06:14.310
You get a chance up front to declare any global
variables, structures, etcetera, you may want to use,

00:06:14.310 --> 00:06:20.280
and you also get a chance in the begin section
to do any initialization or any preflighting.

00:06:20.279 --> 00:06:23.879
And then you come to the body of
your instrument, your probe.

00:06:23.879 --> 00:06:30.800
So the first thing you want to do is describe
the conditions upon which your probe should fire.

00:06:30.800 --> 00:06:34.960
That could be oh, I want it to fire
every second at some frequency.

00:06:34.959 --> 00:06:40.889
Or it could be I want it to fire whenever the foo function
is entered and a first argument is between values A

00:06:40.889 --> 00:06:47.519
and values B, and you can extend
that predicate mechanism further.

00:06:47.519 --> 00:06:50.639
Next you get a chance to take some action.

00:06:50.639 --> 00:06:53.819
Now an action that we use is called recording data.

00:06:53.819 --> 00:07:00.089
And when you record data that means you're sending it from
kernel and out of DTrace to Xray for display to the user.

00:07:00.089 --> 00:07:07.619
A DTrace probe actually has all sorts of data that
it could send, it has the arguments to the functions

00:07:07.620 --> 00:07:15.819
that you're probing in return values, it has DTrace
variables that DTrace provides, such as the process ID,

00:07:15.819 --> 00:07:22.709
the user ID, current working directory of what's
being traced, etcetera, and then you have global data

00:07:22.709 --> 00:07:26.419
in the kernel and your processes that you could access.

00:07:26.420 --> 00:07:32.870
Now before you return data back to Xray, if you've
chosen to do so, you can do some marshalling.

00:07:32.870 --> 00:07:39.720
In this extremely trivial example, let's say that when
the probe fired, the field my integer was of value zero.

00:07:39.720 --> 00:07:46.600
It would be incremented by the value of one and
then one would be returned from DTrace out to Xray.

00:07:46.600 --> 00:07:51.230
And finally you get a chance to do any post
flighting, any clean up that you wish to do.

00:07:51.230 --> 00:07:59.060
So let's go to a demo and see how would use the
DTrace Builder in Xray to build a custom instrument.

00:07:59.060 --> 00:08:07.610
So what I want to do, is I want to build a small
instrument that will measure the CPU load on my system

00:08:07.610 --> 00:08:10.759
and graph it appropriately in the track view.

00:08:10.759 --> 00:08:19.139
So I'm going to open Xray now and I'll
select a blank template and I'm going to go

00:08:19.139 --> 00:08:23.159
to the Instrument Menu and select Build New Instrument.

00:08:23.160 --> 00:08:26.900
So the first thing that I need
to do is describe my instrument

00:08:26.899 --> 00:08:32.949
So I'll say CPU load and I'll put it in the system category.

00:08:32.950 --> 00:08:35.930
That's where I put sampler and all
of those other types of instruments.

00:08:35.929 --> 00:08:43.549
And I'll say measures average CPU load.

00:08:43.549 --> 00:08:44.490
All right.

00:08:44.490 --> 00:08:48.700
Now I said that I wanted to have this CPU Load Graph.

00:08:48.700 --> 00:08:55.330
What I want to do is I want to emit CPU load
every second so I get a nice, even graph.

00:08:55.330 --> 00:09:01.930
So I'll go to my provider types here
and I'll select the profile provider.

00:09:01.929 --> 00:09:05.139
This is a frequency provider, so it
can do things at various frequencies.

00:09:05.139 --> 00:09:09.220
I want to do it every one second.

00:09:09.220 --> 00:09:16.420
Now I need to actually gather the data that
I'm going to use to graph the CPU load.

00:09:16.419 --> 00:09:20.569
Now don't worry if you can't see
this, or it's not very clear,

00:09:20.570 --> 00:09:23.610
we're going to describe it in slides later, in detail.

00:09:23.610 --> 00:09:32.720
But basically, I'm accessing a kernel variable and
stuffing it in the local data variable load one.

00:09:32.720 --> 00:09:39.899
So the next thing I want to do is actually emit
that and record it so it's sent back to Xray.

00:09:39.899 --> 00:09:43.269
So I'll go and I'll say record data.

00:09:43.269 --> 00:09:45.769
It's a custom type.

00:09:45.769 --> 00:09:50.819
And I will use the load one variable I have
there in my script, and I'll give it a name.

00:09:50.820 --> 00:09:55.110
This name is going to represent it in
the detail view and the graph as well.

00:09:55.110 --> 00:10:08.440
I'll just say CPU load average and
I'll give it the type of integer.

00:10:08.440 --> 00:10:13.710
So now I've described my instrument,
I've specified a provider to use,

00:10:13.710 --> 00:10:23.759
that one second frequency profile provider probe, and I've
gathered my data and emitted it, sent it back to Xray.

00:10:23.759 --> 00:10:24.769
Now I hit OK.

00:10:24.769 --> 00:10:30.949
Now I want to actually configure my instrument so I get
the kind of graph style that I want in the Track View.

00:10:30.950 --> 00:10:35.810
I'm going to go to the inspector
in the instrument and click on it

00:10:35.809 --> 00:10:40.009
and I'll select type, sorry, I'll
select style of block graph.

00:10:40.009 --> 00:10:46.669
That'll give me a nice, even, incremental, thick block
graph that you can see back in the back of the room.

00:10:46.669 --> 00:10:50.299
And now I'm going to select the statistic I want to graph.

00:10:50.299 --> 00:11:00.059
So by default, whether it is implicit or explicit, Xray will
list all numeric values it sees coming from that script.

00:11:00.059 --> 00:11:04.359
In this case, we were emitting the
CPU load average, so I have it here.

00:11:04.360 --> 00:11:07.810
So that's what I'm going to use to do my graph.

00:11:07.809 --> 00:11:12.119
I'll hit Done and now I'll go and I'll choose a target.

00:11:12.120 --> 00:11:18.629
Now this is the CPU load of the whole machine, so there
really isn't a target, so we'll say all processes.

00:11:18.629 --> 00:11:23.529
So I'll go back to the target chooser and I'll say
all processes and now I'll use the record button

00:11:23.529 --> 00:11:32.309
in the upper left to gather some data and I'll go
to the terminal and just exercise the machine a bit.

00:11:32.309 --> 00:11:35.159
Do a few things.

00:11:35.159 --> 00:11:40.639
Hit control C and then I'll go back to Xray.

00:11:40.639 --> 00:11:47.679
We can zoom in on the data, I hit stop, and there's an
example of building a custom DTrace instrument in Xray.

00:11:47.679 --> 00:11:51.219
So now let's look at the details of how we did that.

00:11:51.220 --> 00:11:59.810
Let's quit the demo there and we'll go back to the slides.

00:11:59.809 --> 00:12:08.289
So, what I wanted to do was to emit the CPU load
every second, so I used the profile provider,

00:12:08.289 --> 00:12:12.389
which is a frequency based provider, to do that.

00:12:12.389 --> 00:12:17.189
I fetched the data from a global
variable in the kernel called ABE and Run.

00:12:17.190 --> 00:12:22.140
This is actually a variable that is
known in various flavors of UNIX.

00:12:22.139 --> 00:12:28.990
You can actually learn more about it on the web, on various
flavors, and discussions about how best to compute it,

00:12:28.990 --> 00:12:35.730
but the kernel essentially puts the one minute, five
minute and fifteen minute load average into this variable.

00:12:35.730 --> 00:12:39.920
We access that variable with a little
scoping operator called backquote.

00:12:39.919 --> 00:12:42.639
You put that just before the global variable.

00:12:42.639 --> 00:12:46.389
That tells DTrace hey, I have a
variable here, but it's not in my script.

00:12:46.389 --> 00:12:48.620
Look outside for it.

00:12:48.620 --> 00:12:54.190
And finally we stuff the computation of the load
into the load one variable and emitted it back

00:12:54.190 --> 00:12:56.940
to Xray and we had that nice, pretty graph.

00:12:56.940 --> 00:12:59.950
So that was a demo of building a custom instrument.

00:12:59.950 --> 00:13:02.540
Now remember, the scope operators.

00:13:02.539 --> 00:13:04.079
There are two of them actually in that demo.

00:13:04.080 --> 00:13:10.430
One was the back slash to access data outside of
the script itself, in the kernel in this case.

00:13:10.429 --> 00:13:13.859
And the second was this scope operator.

00:13:13.860 --> 00:13:20.810
Now using the this scope operator is a clause local
scoping and it's just the best practice in case

00:13:20.809 --> 00:13:23.739
that variable would be declared
somewhere else in the script,

00:13:23.740 --> 00:13:27.690
you can make sure that it's only known within that probe.

00:13:28.759 --> 00:13:34.960
So now let's take a bit of a turn and let's
talk about alternate ways to invoke Xray outside

00:13:34.960 --> 00:13:38.180
of the common way of double clicking the finder.

00:13:38.179 --> 00:13:45.109
Various of these ways may fit certain circumstances you may
find yourself in and just may be darn convenient for you.

00:13:45.110 --> 00:13:50.990
So the first alternate way to invoke
Xray is called using quick start keys.

00:13:50.990 --> 00:13:55.560
This is a way to instantly invoke
a template, its instruments,

00:13:55.559 --> 00:14:00.629
to start tracing a given process,
even when Xray isn't running.

00:14:00.629 --> 00:14:01.539
So why is this so great?

00:14:01.539 --> 00:14:02.329
Well, it's convenient.

00:14:02.330 --> 00:14:07.400
You don't need to go all the way to the finder and then
developer tools, applications, launch a performance tool

00:14:07.399 --> 00:14:10.439
like Xray, set it up and then trace something.

00:14:10.440 --> 00:14:19.030
But it also can be a necessity in certain circumstances,
for example, you may have an app that begins to malfunction.

00:14:19.029 --> 00:14:25.179
And it does so but because perhaps it's stomping on
memory, and if you deactivate it, you go to the finder

00:14:25.179 --> 00:14:31.179
and therefore it goes to the background, then it may
sort of put, that action may so perturb the target app

00:14:31.179 --> 00:14:37.079
that it actually crashes on you and you don't get
any opportunity to see what was going on whatsoever.

00:14:37.080 --> 00:14:44.530
Or it could that it's simply gone completely nuts and it's
using so many CPU cycles that it makes it very painful

00:14:44.529 --> 00:14:51.379
to go back to the finder and wait a bit and load up
your application and set it up and trace it, etcetera.

00:14:51.379 --> 00:14:56.189
So it's always convenient to use Quick
Start Keys, sometimes it's a necessity.

00:14:56.190 --> 00:15:05.630
So let's take a demo look at that.

00:15:05.629 --> 00:15:06.309
All right.

00:15:06.309 --> 00:15:08.649
I'll close the terminal here.

00:15:08.649 --> 00:15:10.689
All right.

00:15:10.690 --> 00:15:15.890
The first thing I want to do is set up my templates.

00:15:21.490 --> 00:15:32.779
So I will go to Xray preferences and I will select
the Quick Start panel and enter a global hot key.

00:15:32.779 --> 00:15:40.409
I can assign a global hot key to any template, whether it's
templates that are built into Xray or custom templates.

00:15:40.409 --> 00:15:49.639
In this case, I'm going to say control option
command S should launch the CPU sampler template.

00:15:49.639 --> 00:15:54.909
And I will close the preferences
and I will quit the application.

00:15:54.909 --> 00:16:03.149
And now if you've attended WWDC in the last few years
and if you continue to do so and go to my sessions,

00:16:03.149 --> 00:16:07.189
you're going to learn that I don't miss
an opportunity to show off my daughter,

00:16:07.190 --> 00:16:10.890
who I'm so proud of, and this isn't an exception.

00:16:10.889 --> 00:16:13.740
So I have this little app, it's called Baby Viewer.

00:16:13.740 --> 00:16:15.680
And these are pictures of my daughter.

00:16:15.679 --> 00:16:26.489
A cheap attempt for, yeah, so this app deactivates,
stops working when I make it go to the background

00:16:26.490 --> 00:16:31.399
because there's no point in eating up
GPU, CPU cycles if no one's looking at it.

00:16:31.399 --> 00:16:32.480
So how would I trace that?

00:16:32.480 --> 00:16:34.710
Well, I'd use that Quick Start Key.

00:16:34.710 --> 00:16:39.280
So I'll activate the app again, and
now I'm going to hit my global hot key.

00:16:39.279 --> 00:16:44.409
Control Option Command S. Now Xray
wasn't running, but now it is.

00:16:44.409 --> 00:16:47.319
It started in the background and is
actually tracing this application,

00:16:47.320 --> 00:16:50.580
which is incrementing these files about once a second.

00:16:50.580 --> 00:16:56.360
Now to stop this, I can just point at
the application again and stop the trace.

00:16:56.360 --> 00:17:01.100
And if I quite the app, we see that we have sampled
the app at the even increment that we expect to.

00:17:01.100 --> 00:17:06.480
So that's just a convenient, easy way to use Xray.

00:17:06.480 --> 00:17:08.549
So let's go back to the slides.

00:17:08.549 --> 00:17:17.500
And let's review, actually, how we did
that, actually move the demo up here.

00:17:17.500 --> 00:17:24.859
So you use the Xray Preferences Panel to assign a
global hot key to any template, whether it's your own

00:17:24.859 --> 00:17:28.959
or custom templates or built in
templates or custom templates.

00:17:28.960 --> 00:17:32.940
The only caveat here is that all
the instruments in the template have

00:17:32.940 --> 00:17:35.600
to have the ability to attach to a running process.

00:17:35.599 --> 00:17:38.990
Now that actually happens to be just
about all the instruments that we have.

00:17:38.990 --> 00:17:47.700
Any instrument you build with DTrace, object alloc and
links, for example, need to trace only launched processes.

00:17:47.700 --> 00:17:51.180
So you can choose to run with the UI or headless.

00:17:51.180 --> 00:17:57.730
So let's say you like to take traces but you don't want the
UI to pop up, you just want to look at the data later on.

00:17:57.730 --> 00:18:02.360
You can do so by going to the first
preferences panel in Xray

00:18:02.359 --> 00:18:05.289
and changing the default location
for where documents are saved.

00:18:05.289 --> 00:18:12.349
And then you can set a time out, say five seconds, and
then you can trace something and you'll hear a beep,

00:18:12.349 --> 00:18:14.589
it will trace it for five seconds, you'll hear another beep

00:18:14.589 --> 00:18:20.500
and then the document will be placed
in a location you specified.

00:18:20.500 --> 00:18:27.089
So again, all you do is you move your pointer to a
window that is owned by the process you wish to trace,

00:18:27.089 --> 00:18:31.119
you hit your global hot key you've
assigned, that starts the trace,

00:18:31.119 --> 00:18:33.459
and if you want to stop the trace,
you repeat the whole process.

00:18:33.460 --> 00:18:37.740
You point the pointer, your mouse pointer, at
a window owned by the process you want to trace

00:18:37.740 --> 00:18:42.640
and you hit it again and that stops the trace.

00:18:42.640 --> 00:18:44.940
So we've seen the demo, so let's move on.

00:18:44.940 --> 00:18:51.019
So, and another alternate way to use
Xray is view the Xray command line.

00:18:51.019 --> 00:18:57.549
Now you can find out information
about that from the Xray man page.

00:18:58.680 --> 00:19:04.000
And you can use this with either a
trace template, one that we created

00:19:04.000 --> 00:19:06.740
or one that you create for yourself, or a trace document.

00:19:06.740 --> 00:19:11.170
It can already have lots of runs in it
and you can just add a new run to it.

00:19:11.170 --> 00:19:14.670
And you can use this to launch
or attach to an existing process.

00:19:14.670 --> 00:19:21.539
If you're launching a process, you can provide built in
command line arguments and environment variables, etcetera,

00:19:21.539 --> 00:19:24.309
to change the behavior of the app
you're interesting in launching.

00:19:24.309 --> 00:19:27.049
To terminate it you can specify a time out.

00:19:27.049 --> 00:19:32.000
Say you wanted to sample it for five seconds
or look at file activity for five seconds.

00:19:32.000 --> 00:19:34.779
You can do that with the -l Option.

00:19:34.779 --> 00:19:36.779
You can also just hit control C in the terminal

00:19:36.779 --> 00:19:41.049
and that will just stop the trace
and the document will be written out.

00:19:41.049 --> 00:19:44.220
And finally you could also just wait for the process to end.

00:19:44.220 --> 00:19:52.789
In any event, you'll be told when the
trace ends where the document was saved to.

00:19:52.789 --> 00:19:56.259
Moving on, this is an often requested feature

00:19:56.259 --> 00:20:02.930
and our first step towards this is the
ability to trace something remotely with Xray.

00:20:02.930 --> 00:20:11.740
So the first step towards this is to allow you to export
DTrace from Xray and run it on another machine or locally

00:20:11.740 --> 00:20:18.829
on the command line and then import the data that results
back into Xray and use the GUI to look up that data.

00:20:18.829 --> 00:20:20.769
So why would you want to do this?

00:20:20.769 --> 00:20:23.579
Well, Xray isn't available on all systems.

00:20:23.579 --> 00:20:25.149
It's only a developer install.

00:20:25.150 --> 00:20:31.360
But DTrace is available on all machines, a user
install, a developer install, Leopard server.

00:20:31.359 --> 00:20:36.849
You can also use this to take advantage of a
feature in DTrace called anonymous tracing.

00:20:36.849 --> 00:20:45.019
So you could construct a script in DTrace,
in DTrace instruments in Xray, export that,

00:20:45.019 --> 00:20:48.339
install the resulting script in the kernel, reboot,

00:20:48.339 --> 00:20:54.569
and then get that primordial trace data well
before you even get to the log in window.

00:20:54.569 --> 00:20:58.399
And then check that data out and
then import it back into Xray.

00:20:58.400 --> 00:21:01.280
So his would be useful, obviously for us back at Apple,

00:21:01.279 --> 00:21:04.779
but if you were a device driver
writer, this would also be very useful.

00:21:04.779 --> 00:21:11.379
And finally you can just use this feature to learn
about how we build DTrace scripts in our instruments,

00:21:11.380 --> 00:21:13.450
when you manipulate the GUI, what happens.

00:21:13.450 --> 00:21:18.180
You can take a look at the existing instruments
that we ship with Xray that are in DTrace.

00:21:18.180 --> 00:21:22.450
And just learn about scripting and probe construction.

00:21:22.450 --> 00:21:28.220
So to do this, you start out with a trace
document populated only by DTrace instruments.

00:21:28.220 --> 00:21:35.529
Obviously we can't create a DTrace script for say the
object alloc instrument or UR Recorder instrument.

00:21:35.529 --> 00:21:43.990
Next, you use the export menu from the file
menu bar menu and so long as all the instruments

00:21:43.990 --> 00:21:47.519
in your document are DTrace based,
this menu item will be enabled.

00:21:47.519 --> 00:21:52.710
So you select it and you provide a name for your script.

00:21:52.710 --> 00:21:58.019
You also have to tell us what you're going to
trace, what type of target you're going to trace.

00:21:58.019 --> 00:22:04.269
Whether it's all processes, the system, like we say
with the CPU demo or it's a target you will launch

00:22:04.269 --> 00:22:08.819
from DTrace using the DTrace -c
option, or it's an existing process.

00:22:08.819 --> 00:22:13.509
And we need to know this because you slightly
modify DTrace script with different macros,

00:22:13.509 --> 00:22:17.519
etcetera, based on how you're going to use it.

00:22:17.519 --> 00:22:24.910
So once you do that and you've run DTrace with that
script, you can import the data back into Xray.

00:22:24.910 --> 00:22:34.040
Now, one caveat there is you have to remember to import it
back to a trace document in Xray that is of the same form

00:22:34.039 --> 00:22:39.430
that you use to export the script to begin with
so that it has the exact same DTrace instruments.

00:22:39.430 --> 00:22:44.529
Now otherwise, we wouldn't know how to match up the
incoming data with the actual instruments you specified.

00:22:44.529 --> 00:22:49.819
Now we do our best to determine if there's incompatibility
between the trace document you have and what you're trying

00:22:49.819 --> 00:22:56.929
to import will alert you to that and we will stop the
trace, but if you get adventurous and you start tinkering

00:22:56.930 --> 00:23:03.350
with that script and then you generate data and try
to import it back in, results will be unpredictable.

00:23:03.349 --> 00:23:12.980
So let's go to a demo of that now.

00:23:12.980 --> 00:23:16.690
So what I'm going to do is launch Xray again.

00:23:16.690 --> 00:23:20.210
And I'll select a blank template once again.

00:23:20.210 --> 00:23:23.960
Since we're familiar with it, I'm
going to use the CPU load instrument.

00:23:23.960 --> 00:23:32.460
So I will type in CPU, there's my new CPU Load
instrument that we did strictly with DTrace.

00:23:32.460 --> 00:23:36.930
And now I'll go to the file menu
and say DTrace script export.

00:23:36.930 --> 00:23:41.870
And let's just show where that will go.

00:23:41.869 --> 00:23:44.859
I'll put it in the home user account.

00:23:44.859 --> 00:23:48.979
I'm going to give it a target of all processes
since it was the CPU load measuring instrument.

00:23:48.980 --> 00:23:56.670
I'll say cpu.d. And I'll save that
and now I'm going to open up terminal.

00:23:56.670 --> 00:24:00.090
And let's resize this a bit.

00:24:00.089 --> 00:24:09.169
And first, let's just take a look at that script so this
is basically what you get on this very, very simple script.

00:24:09.170 --> 00:24:10.070
It has a header.

00:24:10.069 --> 00:24:15.250
It emits a UID, for example, that we use to
try to match up instruments with the data.

00:24:15.250 --> 00:24:17.619
And then we see the probe that we used.

00:24:17.619 --> 00:24:20.709
We used a profile probe firing every one second.

00:24:20.710 --> 00:24:24.680
And that probe is gathering kernel
level data and emitting it.

00:24:24.680 --> 00:24:25.820
Now back to Xray.

00:24:25.819 --> 00:24:32.399
Now, this script is a bit different than the script
that we used when we controlled the whole widget.

00:24:32.400 --> 00:24:36.840
When we have defined it in Xray and when we run it in Xray.

00:24:36.839 --> 00:24:44.970
When we run it from Xray, we have the opportunity to get
back to data and binary format, we mark up the script.

00:24:44.970 --> 00:24:46.450
There's certain pieces of information.

00:24:46.450 --> 00:24:52.279
In case you made an error, we can tell you
more about the context of that error, etcetera.

00:24:52.279 --> 00:24:59.079
When you run something from DTrace itself, it's all text
based, so the script is just a little bit different.

00:24:59.079 --> 00:25:03.119
But essentially, it's functioning in
the same way, probing the same things.

00:25:03.119 --> 00:25:05.629
So, let's go and run that.

00:25:05.630 --> 00:25:13.180
I need to run DTrace's root, so I'll say pseudo dtrace
-S, my script and I want to output this data

00:25:13.180 --> 00:25:16.210
to a file so I can import that file back.

00:25:16.210 --> 00:25:17.630
So I'll say cpu.out.

00:25:17.630 --> 00:25:23.820
I need to use a .o there to do that.

00:25:23.819 --> 00:25:24.129
All right.

00:25:24.130 --> 00:25:29.960
And now I'll hit enter and, whoa, it's warning me.

00:25:29.960 --> 00:25:31.029
Hang on. Okay.

00:25:31.029 --> 00:25:33.410
Now I have authenticated.

00:25:33.410 --> 00:25:36.259
And let's give the CPU something to do.

00:25:36.259 --> 00:25:39.329
Run everything in slash again.

00:25:39.329 --> 00:25:41.679
And that's enough.

00:25:41.680 --> 00:25:43.009
Control C that.

00:25:43.009 --> 00:25:44.309
Close the terminal window.

00:25:44.309 --> 00:25:50.569
And now to terminate the trace, I'll just hit
control C. And we can briefly look at this data.

00:25:50.569 --> 00:25:59.730
Again, it's data that was, excuse me, taken
once a second, so it's not very voluminous.

00:25:59.730 --> 00:26:00.980
It's all text based.

00:26:00.980 --> 00:26:03.029
We see lots of stack traces, etcetera.

00:26:03.029 --> 00:26:08.940
I could have turned off stack tracing if
I wanted to when I built the instrument.

00:26:08.940 --> 00:26:13.830
And now let's import that data back into the instrument.

00:26:13.829 --> 00:26:19.179
I have my trace document again and it has
the instrument that was used to export it.

00:26:19.180 --> 00:26:26.549
I'll go under the file menu to DTrace data
import and I'll select cpu.out this time

00:26:26.549 --> 00:26:30.269
and it imports the data and there we have our load.

00:26:30.269 --> 00:26:41.420
And I can expand that out and change the style to block
graph and there we have an example of running DTrace outside

00:26:41.420 --> 00:26:46.970
of Xray based on Xray instruments
and then importing it again.

00:26:46.970 --> 00:26:52.240
So if we can go back to the slides.

00:26:52.240 --> 00:26:57.380
So this can be very useful, again, if you
need to look at something on another machine.

00:26:57.380 --> 00:27:01.120
We've had various system administrators
ask for this feature.

00:27:01.119 --> 00:27:06.059
If you need to look at something on a
user install that you don't have Xray on,

00:27:06.059 --> 00:27:10.929
you don't have the developer tools
installed on, and it's just very useful.

00:27:10.930 --> 00:27:16.509
So now I'd like to invite up Dave Payne
to talk to you about DTrace static probes.

00:27:16.509 --> 00:27:21.970
( Applause )

00:27:21.970 --> 00:27:26.140
>> Dave: Thank you, Steve.

00:27:26.140 --> 00:27:33.190
So to give you an idea of DTrace static probes, I'd
first like to paint the context of the categories

00:27:33.190 --> 00:27:41.190
of different DTrace providers out there so you can see how
static probes compare to the other probes on the system.

00:27:41.190 --> 00:27:49.049
Then we'll take a look at adding static probes to a project
and then look at some examples of using static probes.

00:27:49.049 --> 00:27:55.289
So I like to split the DTrace providers on
the system into three primary categories.

00:27:55.289 --> 00:27:58.930
The system wider providers, the per process providers,

00:27:58.930 --> 00:28:03.590
and the user LAN static providers
that we'll be talking about here.

00:28:03.589 --> 00:28:06.899
So let's take a look at each one of these.

00:28:06.900 --> 00:28:13.650
By the system wide providers, I'm referring to those
where we've put the probe points into the kernel.

00:28:13.650 --> 00:28:23.070
In these cases, the provider name when you're
using these probes does not include a process ID.

00:28:23.069 --> 00:28:26.649
So many of these you'll have seen in examples.

00:28:26.650 --> 00:28:35.180
For example, so first off, the column on the left
here is the name that the DTrace system uses.

00:28:35.180 --> 00:28:38.779
The column in the middle is a more
human readable name that we use

00:28:38.779 --> 00:28:41.480
in the Xray instrument builder, if you want to use these.

00:28:41.480 --> 00:28:49.390
So a few primary examples, the SysCall provider is the
interface between your applications and the kernel.

00:28:49.390 --> 00:28:56.550
So you can watch all of the entries and returns from System
Calls and get an idea of their arguments and return values.

00:28:56.549 --> 00:28:59.700
But the probe point for that is in the kernel.

00:28:59.700 --> 00:29:04.180
FBT is the function boundary tracing inside the kernel.

00:29:04.180 --> 00:29:09.330
So you can actually see the activity
that's going on within the kernel itself,

00:29:09.329 --> 00:29:16.119
which could be helpful if you're a
device driver writer, for example.

00:29:16.119 --> 00:29:26.159
The Proc Provider gives the kernel's view of the creation
of, the creation of termination of processes and threads

00:29:26.160 --> 00:29:31.620
and it also informs you of signal
delivery and signal handling activity.

00:29:31.619 --> 00:29:41.139
And the profile and tick providers, as you saw Steve
exercise, you do periodic activities in a DTrace script.

00:29:41.140 --> 00:29:45.050
So there's a couple of others that
we've recently implemented that we don't

00:29:45.049 --> 00:29:53.000
yet have in the Xray instrument builder, but you can go to
custom and just specify the name lock stats for VM info.

00:29:53.000 --> 00:29:58.269
So I mentioned that these are system wide, but a
lot of times you're just interesting in one process

00:29:58.269 --> 00:30:02.410
and you don't want to put the overhead
of having these hit by every process,

00:30:02.410 --> 00:30:07.460
so to do that you can put the process ID in a predicate.

00:30:07.460 --> 00:30:12.930
You can compare the executable name or
the process ID against the variables

00:30:12.930 --> 00:30:16.470
that DTrace provides for you to use in your scripts.

00:30:16.470 --> 00:30:26.470
The process providers let you put probe
points into your application code itself,

00:30:26.470 --> 00:30:32.019
into your applications, your libraries, your plugin modules.

00:30:32.019 --> 00:30:36.599
These are, let you probe functions or Objective-C Methods.

00:30:36.599 --> 00:30:42.519
You can specify entry or return or offsets
within a function, or even an absolute address.

00:30:42.519 --> 00:30:47.779
To use these, you must specify a process ID.

00:30:47.779 --> 00:30:53.500
The primary provider that Sun implemented
in OpenSolaris was the PID Provider,

00:30:53.500 --> 00:30:58.190
but we've also implemented another
one, the Objective-C Provider.

00:30:58.190 --> 00:31:00.900
And I'll show you the difference here.

00:31:00.900 --> 00:31:09.140
So with the PID provider, you have a probe name of the
form provider name module, which would be your library

00:31:09.140 --> 00:31:16.800
or executable name, the function name and then
an actual name, which would be entry or return.

00:31:16.799 --> 00:31:23.440
So for example, if I want to trace all the NSLog function
calls, now that's implemented in foundations,

00:31:23.440 --> 00:31:29.110
which is a Cocoa Library, but it's a C Function essentially.

00:31:29.109 --> 00:31:37.740
So I could say pid273:foundation
is the module, NSLog:entry.

00:31:37.740 --> 00:31:45.279
Whereas for Objective-C provider, it's the provider
name followed by the class name, the method name,

00:31:45.279 --> 00:31:50.690
which can be a class or an instance method,
and then again the name entry or return.

00:31:50.690 --> 00:31:54.090
So if we want to trace all allocations of NS Strings,

00:31:54.089 --> 00:32:03.409
I can use OBJC Process ID 1017, colon
NSString colon plus alloc star.

00:32:03.410 --> 00:32:09.170
I'm using the wildcard of star here because the
method that's actually called is alloc with zone.

00:32:09.170 --> 00:32:13.120
And then again I want the entries there.

00:32:13.119 --> 00:32:19.549
With this, if you wanted to, if you had a method name
that you wanted to examine that was colon separated,

00:32:19.549 --> 00:32:24.519
you would need to use a question mark
or an asterisk wild card to be able

00:32:24.519 --> 00:32:29.549
to specify that in that third method field there.

00:32:29.549 --> 00:32:34.180
So how does user LAN static providers compare?

00:32:34.180 --> 00:32:41.120
Well these are probes that you can put into
your own code that have meaning within your code

00:32:41.119 --> 00:32:46.569
and are no necessarily tied to the names
of any particular functions or methods.

00:32:46.569 --> 00:32:50.119
So these can be semantically meaningful points

00:32:50.119 --> 00:32:55.159
The advantage of that is that if you're changing
the implementation of your application over time

00:32:55.160 --> 00:33:00.170
so that you function names or method
names change, these are nice and stable.

00:33:00.170 --> 00:33:07.050
You're DTrace scripts and your Xray
instruments can continue to work with this.

00:33:07.049 --> 00:33:12.369
So this is a great way to have these probe points
always be there so you can dynamically turn

00:33:12.369 --> 00:33:16.529
on tracing or logging or let your customers do so.

00:33:16.529 --> 00:33:22.639
As with all DTrace probes, these are
zero cost when you're not using them.

00:33:22.640 --> 00:33:25.610
It's just actually a no op in your code.

00:33:25.609 --> 00:33:33.029
A primary distinction between this and the Objective-C
provider is that this provides you a way, because your app,

00:33:33.029 --> 00:33:38.230
you've coded into your application the
knowledge that this is a probe point.

00:33:38.230 --> 00:33:45.759
Now with the PID in Objective-C Providers, DTrace let's
you record the arguments but your code doesn't know

00:33:45.759 --> 00:33:51.000
that the probe is going to be put there so
the kernel says okay, I'll fetch the arguments

00:33:51.000 --> 00:33:54.809
and there's no Objective-C runtime
in the kernel, there's no objectives.

00:33:54.809 --> 00:34:00.220
We can't extract the descriptions
of Objective-C Objects there.

00:34:00.220 --> 00:34:07.140
Whereas with this, you can code in the knowledge
of an Objective-C Object, get it's description,

00:34:07.140 --> 00:34:10.720
and be able to record that as an argument.

00:34:10.719 --> 00:34:19.139
Because these are coded into your application, or let's
say it's a framework, if you have multiple processes using

00:34:19.139 --> 00:34:22.750
that framework, these probe points
are in all those processes.

00:34:22.750 --> 00:34:28.769
So you can write your scripts to focus on just
one of those processes or focus on all of them.

00:34:28.769 --> 00:34:34.829
So for example, core data has static probes
in it as we ship it with Leopard today.

00:34:34.829 --> 00:34:42.239
I can watch all of the begin fetch method calls
or begin fetch operations within core data

00:34:42.239 --> 00:34:48.509
by saying CoreData asterisk for the
process ID colon, colon, colon BeginFetch.

00:34:48.510 --> 00:34:58.370
So some things to think about as your designing static
probes, you want to think about where the interesting points

00:34:58.369 --> 00:35:03.170
in your application that you might
want to probe to see what's happening.

00:35:03.170 --> 00:35:09.500
So, for example, you might have a long operation that's
composed of multiple steps, let's say it's three steps,

00:35:09.500 --> 00:35:13.179
you might want to record the start
and stop of each one of those steps

00:35:13.179 --> 00:35:16.359
so you can see the relative amount
of time that each step takes.

00:35:16.360 --> 00:35:22.980
If you've got an activity that has
particular points of interest along the way,

00:35:22.980 --> 00:35:27.139
you can have a probe point to record progress for that.

00:35:27.139 --> 00:35:31.099
Then you want to think about what arguments to record,

00:35:31.099 --> 00:35:37.339
so here you're providing the raw data
for people to be able to consume later.

00:35:37.340 --> 00:35:42.700
Think about what data you would want to be
able to report in log messages generated

00:35:42.699 --> 00:35:51.480
by a DTrace script that's monitoring your program,
or statistics for graphing in an Xray instrument.

00:35:51.480 --> 00:35:58.099
Then in order for your customers, say your internal
developers, to be able to use these probes,

00:35:58.099 --> 00:36:04.579
you want to tell people what they actually
are and what the arguments of them are.

00:36:04.579 --> 00:36:09.829
So the steps for adding static probes
to a project, we'll go through these.

00:36:09.829 --> 00:36:13.819
Number one is to write a provider description file.

00:36:13.820 --> 00:36:19.930
Number two would be to import that file,
the header that corresponds to that

00:36:19.929 --> 00:36:24.009
into the sources files where you're going to put the probes.

00:36:24.010 --> 00:36:26.610
Now the header doesn't actually exist yet.

00:36:26.610 --> 00:36:32.570
So the third step is to generate the header file, and
we'll talk about why I'm saying this in this order.

00:36:32.570 --> 00:36:38.730
Then the fourth step is to go ahead and
add those probe invocations to your probe.

00:36:38.730 --> 00:36:46.690
To take a look at this, I'm going to be using
the grand perspective project as an example.

00:36:46.690 --> 00:36:49.780
Some of you may have seen this used earlier in the show.

00:36:49.780 --> 00:36:56.950
Grand Perspective let's me point to the directory on my disk
and scan recursively down through all the sub directories,

00:36:56.949 --> 00:37:01.969
gather the size of each one of them and
roll that information back up to be able

00:37:01.969 --> 00:37:06.529
to report the sizes of any directory in that hierarchy.

00:37:06.530 --> 00:37:14.870
So my first step in putting in static probes to monitor
this, I've decided for each directory I want to know the,

00:37:14.869 --> 00:37:18.739
when I start the directory and when I end it.

00:37:18.739 --> 00:37:27.129
So I put in a probe point for start directory scan and I
want to record the directory path and let's say the depth,

00:37:27.130 --> 00:37:32.700
or how deeply nested in the directory hierarchy I am.

00:37:32.699 --> 00:37:39.699
When the directory scan finishes, I
should know the size for that directory.

00:37:39.699 --> 00:37:43.219
And I'm going to record that in kilobytes.

00:37:43.219 --> 00:37:51.069
So I call the provider description file
GrandPerspectiveProbes.d. .d is a standard DTrace suffix,

00:37:51.070 --> 00:37:55.550
and in this case .d is a suffix that Xcode knows about.

00:37:55.550 --> 00:38:02.760
So a couple of important items here.

00:38:02.760 --> 00:38:10.690
When we're recording the probe arguments, these must
actually be C because the header file that gets generated

00:38:10.690 --> 00:38:15.559
for this is going to reflect those arguments
and is going to get compiled into your program.

00:38:15.559 --> 00:38:21.940
This is the DTrace program itself that's
doing this generation of the header file

00:38:21.940 --> 00:38:26.970
so we can record numeric data types like int, short or long.

00:38:26.969 --> 00:38:31.109
It actually has a 64 bit space to record each argument.

00:38:31.110 --> 00:38:39.660
We can record a char star that's a pointer to a
string out in the user space of the application

00:38:39.659 --> 00:38:43.920
or a void star that would be an arbitrary pointer.

00:38:43.920 --> 00:38:50.059
So I had mentioned that we provide a way
to look at Cocoa object descriptions.

00:38:50.059 --> 00:38:57.619
So I can do that by taking my object, myobj, calling the
description method, that of course I've written on that,

00:38:57.619 --> 00:39:04.250
and then making a UTF8String method call
for that so that I can get out a char star

00:39:04.250 --> 00:39:07.360
that I can actually pass down into the kernel.

00:39:07.360 --> 00:39:13.550
So again, I'm doing the interpretation of
my Cocoa objects up in user space here.

00:39:13.550 --> 00:39:20.950
Step two, simply go into the header source code file where
I want to put probe points and import my header file.

00:39:20.949 --> 00:39:26.289
Step three, then, is to generate that header file.

00:39:26.289 --> 00:39:35.650
Now the reason I imported the header file first is because
this tells Xcode when it does it's dependency scanning,

00:39:35.650 --> 00:39:43.010
it says oh, there's a header file here that I don't actually
have, do I have a way to gather this, to generate this?

00:39:43.010 --> 00:39:52.950
Oh, okay, I know that for .d files I can generate those
into a header file using this dtrace -h -s command.

00:39:52.949 --> 00:39:56.779
So the build system will automatically
generate the header file for you

00:39:56.780 --> 00:40:02.790
and then you can use code completion
then to enter in the probe macro names.

00:40:02.789 --> 00:40:09.409
If you have a make based project, you
simply add a rule to your Makefile

00:40:09.409 --> 00:40:13.289
to put that dtrace -h -s in explicitly.

00:40:13.289 --> 00:40:14.980
And that's all you have to do.

00:40:14.980 --> 00:40:22.990
The implementation of the header file has macros
in it that have somewhat complex implementation

00:40:22.989 --> 00:40:29.519
that give the linker directives of what
information to put in with your binary

00:40:29.519 --> 00:40:33.099
so that DTrace will know that these
probes exists in your binary.

00:40:33.099 --> 00:40:36.529
So these header files are not really
meant to be human readable.

00:40:36.530 --> 00:40:45.860
The primary thing that we're interested in is the
probe macro definitions that they put in there.

00:40:45.860 --> 00:40:54.240
So for example, I had written start directory
scan with a char star of the path and the depth.

00:40:54.239 --> 00:41:01.129
So the header file contains macros corresponding to
these, the form of the macro names is always going

00:41:01.130 --> 00:41:06.829
to be the provider name, which in this case
was GRANDPERSPECTIVE, all in uppercase,

00:41:06.829 --> 00:41:12.670
and then _START, _DIRECTORY,
_SCAN.

00:41:12.670 --> 00:41:19.930
And you'll notice the second one here, also, which
is GRANDPERSPECTIVE_START_DIRECTORY_SCAN_ENABLED.

00:41:19.929 --> 00:41:21.199
So why is that?

00:41:21.199 --> 00:41:25.599
Well, we'll talk about that in a couple of minutes.

00:41:25.599 --> 00:41:26.670
Okay. Great.

00:41:26.670 --> 00:41:31.760
So the fourth step is we go ahead and
add the probe implications to our code.

00:41:31.760 --> 00:41:40.300
So in this case, at the top of my method where I'll be
recursively descending down through my directory hierarchy,

00:41:40.300 --> 00:41:45.720
this is called for each directory, I
want to put in a probe point to say okay,

00:41:45.719 --> 00:41:48.939
I'm starting this directory and here's the depth.

00:41:48.940 --> 00:41:58.760
So I'm just going to be kind of extensive about this
and calculate the depth by doing, taking my string,

00:41:58.760 --> 00:42:03.120
getting an NS Array of the path
components and getting a count of that.

00:42:03.119 --> 00:42:09.569
I could have passed it recursively down
through, but hey, let's take more time.

00:42:09.570 --> 00:42:13.670
Then I get my UTF8 path and I make my macro call.

00:42:13.670 --> 00:42:21.210
Then at the end of my function, where I've got the
directory size, I make a corresponding call and record that.

00:42:21.210 --> 00:42:26.900
The audience says, well Dave, you had
said that these were zero cost probes.

00:42:26.900 --> 00:42:30.410
That sure doesn't look zero cost to me.

00:42:30.409 --> 00:42:34.679
Well that's what the is enabled probe is all about.

00:42:34.679 --> 00:42:41.269
This lets you avoid the expensive cost of any
potential argument marshalling that you want to do

00:42:41.269 --> 00:42:50.070
by having a quick test and branch that if the probe is not
actually enabled, it'll just skip right over this code.

00:42:50.070 --> 00:42:56.980
When you do enable the probes, then this test will
success and it will go through the argument marshalling

00:42:56.980 --> 00:43:00.780
and it will make the corresponding macro call.

00:43:00.780 --> 00:43:09.800
So we can see here that it's the same code as before just
using the is enabled to wrap each of the probe points here,

00:43:09.800 --> 00:43:14.300
because gee, I want to avoid the cost of that
divide there on the second one there also.

00:43:14.300 --> 00:43:19.410
Their size divided by 1024.

00:43:19.409 --> 00:43:25.839
Okay. So let's see if the demo gods are
with me to actually show this in action.

00:43:25.840 --> 00:43:31.960
Go ahead and hide terminal.

00:43:31.960 --> 00:43:34.539
I'll bring up my Grand Perspective project.

00:43:34.539 --> 00:43:44.570
So my first step is I'll go down here to other
sources as a place where I want to create my new file.

00:43:44.570 --> 00:43:48.830
So I'm going to create an empty file in
the project for the probe descriptions.

00:43:48.829 --> 00:44:01.190
So we'll call that GrandPerspectiveProbes.d.
So again, the standard .d suffix.

00:44:01.190 --> 00:44:06.230
Finish with that.

00:44:06.230 --> 00:44:10.690
Now I magically type in the same thing
that you saw in the slides before,

00:44:10.690 --> 00:44:15.559
so start directory scan and end directory scan macros.

00:44:15.559 --> 00:44:16.179
All right.

00:44:16.179 --> 00:44:18.179
Probe definitions.

00:44:18.179 --> 00:44:21.669
Now we'll go ahead and save that.

00:44:21.670 --> 00:44:22.769
Make sure we're built.

00:44:22.769 --> 00:44:31.179
Okay. Now I want to go up to the source file where
I'm going to want to put these two probe points.

00:44:31.179 --> 00:44:43.819
I'll just add in the #import
GrandPerspectiveProbes.h. Save again.

00:44:43.820 --> 00:44:51.880
And let's actually bring up the build
panel here so we can see this in action.

00:44:51.880 --> 00:44:54.380
And, whoop, okay.

00:44:54.380 --> 00:44:57.269
For some reason it's failing the first time around.

00:44:57.269 --> 00:45:04.079
But that was actually where it executed
the dtrace -h -s. So anyway,

00:45:04.079 --> 00:45:08.670
trust me, it did that on the first build through.

00:45:08.670 --> 00:45:18.800
So now the header file exists and I can
start using these probe points in my program.

00:45:18.800 --> 00:45:26.680
So I'll go down into the source file, into the
routine that gets called for each directory.

00:45:26.679 --> 00:45:40.359
And I'll go down through here to the point where at the
top I've got the full directory path for the directory.

00:45:40.360 --> 00:45:47.530
And we'll go ahead and magically
type in our probe definition.

00:45:47.530 --> 00:45:54.380
So here again, I'm using the is enabled
probe to test whether it is enabled.

00:45:54.380 --> 00:46:00.119
Doing all the expensive argument
marshalling and then calling the macro.

00:46:00.119 --> 00:46:05.759
At the bottom of my routine, where I've finished
going through the full directory hierarchy scan

00:46:05.760 --> 00:46:14.170
for this directory, I can put in my end directory probe.

00:46:15.269 --> 00:46:18.630
So same thing here as you saw before.

00:46:18.630 --> 00:46:24.670
Let's go ahead and save and build.

00:46:24.670 --> 00:46:34.840
Now if I run this, we can see hey, very nice.

00:46:34.840 --> 00:46:36.309
Very nice.

00:46:36.309 --> 00:46:39.440
But I'd like to be able to see what's going on there.

00:46:39.440 --> 00:46:46.550
So let's actually bring up Xray, I'll choose
the blank template and bring up the library.

00:46:46.550 --> 00:46:57.289
Now in the interest of time, I've already created
an Xray instrument that uses these two probe points.

00:46:57.289 --> 00:47:05.929
So I've got two probe clauses in my
Grand Perspective Xray instrument.

00:47:05.929 --> 00:47:09.369
The first one I named startDirectoryScan.

00:47:09.369 --> 00:47:14.670
I call it type custom, because Xray didn't know about it.

00:47:14.670 --> 00:47:24.369
The provider name is GrandPerspective, and I use the
star wildcard to indicate that I want to gather this

00:47:24.369 --> 00:47:27.659
for all processes that happen to hit this probe.

00:47:27.659 --> 00:47:38.099
And then for the first one I say start directory scan
and I record arg0 as the path, arg1 as the depth

00:47:38.099 --> 00:47:42.369
and in this case, I'll record a
third argument of the directory size

00:47:42.369 --> 00:47:44.989
of zero because I'm just starting the directory.

00:47:44.989 --> 00:47:47.589
I don't know what it is yet.

00:47:47.590 --> 00:47:48.820
We close that down.

00:47:48.820 --> 00:47:50.539
We can take a look at the second one.

00:47:50.539 --> 00:47:51.900
Very similar.

00:47:51.900 --> 00:47:53.900
I call it endDirectoryScan.

00:47:53.900 --> 00:47:55.670
Again, it's custom.

00:47:55.670 --> 00:48:01.320
GrandPerspective star, end_Directory_Scan
as the probe name.

00:48:01.320 --> 00:48:06.050
So again, this matches what I put
in the provider description files.

00:48:06.050 --> 00:48:08.910
This is the lower case version of this.

00:48:08.909 --> 00:48:14.989
So I'm recording arg0, the path, arg1,
the depth, and now I do have argument two

00:48:14.989 --> 00:48:18.299
on this probe, which is the directory size.

00:48:18.300 --> 00:48:30.289
Whoop. So I'm going to go ahead and zoom
this up a little bit so we're seeing that I'd

00:48:30.289 --> 00:48:36.389
like to graph both the depth and
the directory size as we go through.

00:48:36.389 --> 00:48:43.449
I should be able to attach to the Grand Perspective
project, or application that's already running,

00:48:43.449 --> 00:48:46.659
where you can see that the window's still there.

00:48:46.659 --> 00:48:49.619
Go ahead and scan the folder again.

00:48:51.210 --> 00:48:53.300
The applications folder.

00:48:53.300 --> 00:49:12.920
Whoop. It would help to start recording,
as Steve points out.

00:49:16.530 --> 00:49:20.570
Scan folder, applications.

00:49:20.570 --> 00:49:21.920
All right.

00:49:21.920 --> 00:49:27.010
Now we see data coming out and in this
case, the Grand Perspective black screen.

00:49:27.010 --> 00:49:31.020
Oh well. We're here to demo the static probes.

00:49:33.329 --> 00:49:40.449
So we can see lots of data being gathered as we go through.

00:49:40.449 --> 00:49:55.250
At the top we've got, we can see that we're descending
through the directory hierarchy with a depth of two

00:49:55.250 --> 00:50:00.420
and start, start, start, finally an
end, where we get the directory size.

00:50:00.420 --> 00:50:04.389
We can see the path name on each one
that I've recorded from static probes.

00:50:04.389 --> 00:50:13.500
I can go to the end and see that again we descend down
through and finish up slash applications, reports,

00:50:13.500 --> 00:50:18.840
the directory size of almost a
gigabyte in slash applications.

00:50:18.840 --> 00:50:23.470
I can sort by these various columns and there we go.

00:50:23.469 --> 00:50:43.230
Okay. Let's go back to slides please.

00:50:43.230 --> 00:50:51.170
So we've seen how you can add static probes to your
project and I mentioned that we're starting to put them

00:50:51.170 --> 00:50:53.940
into various places in the system as well.

00:50:53.940 --> 00:51:01.409
So we've got static probes in Libsystem, the
plockstat provider is actually one that's documented

00:51:01.409 --> 00:51:08.969
in the openSolaris documentation for
DTrace, so this tells us information

00:51:08.969 --> 00:51:12.669
about what's going on with locking on our P Threads.

00:51:12.670 --> 00:51:17.180
I had mentioned that we've got static probes in core data.

00:51:17.179 --> 00:51:27.129
And in Leopard Beta we're shipping the scripting languages
Ruby, Python and Perl with static probes already embedded

00:51:27.130 --> 00:51:31.840
in them, so each of these defines
their own provider that you can use.

00:51:31.840 --> 00:51:36.579
You can see these using the DTrace
-l command to list the probes.

00:51:36.579 --> 00:51:42.049
You can grep for a specific provider
name or for the process ID to filter

00:51:42.050 --> 00:51:47.890
down because there's thousands
of probe points on the system.

00:51:47.889 --> 00:51:57.170
This is the provider definition file that I've
actually copied out of the core data source code.

00:51:57.170 --> 00:52:06.059
We can see that with this we can track the
begin and end activity of fetching, of faulting,

00:52:06.059 --> 00:52:11.199
of relationship faulting and of saving in core data.

00:52:11.199 --> 00:52:17.379
So you'll notice that that's a .d file because
that's using the d language to define it.

00:52:17.380 --> 00:52:26.880
And then here I give an example of
a DTrace script that I could write

00:52:26.880 --> 00:52:32.269
that could monitor all core data
activity using those probes.

00:52:32.269 --> 00:52:41.280
Again, this is also using the standard .d suffix we
interpret which, whether it's a provider definition

00:52:41.280 --> 00:52:52.490
or a script to use these, we interpret that based on the
context you're using it in and the contents, of course.

00:52:52.489 --> 00:53:01.709
So in the case of Ruby, this is actually the
most extensive of the scripting languages.

00:53:01.710 --> 00:53:07.260
We're taking advantage of some work that was done in
the open source community by a company called Joyer.

00:53:07.260 --> 00:53:16.280
We can see function, entry and returns, garbage
collection begin and end, and the create,

00:53:16.280 --> 00:53:22.340
the start and finish and freeing of object creation.

00:53:22.340 --> 00:53:33.930
So actually, on your systems in developer examples, Ruby,
DTrace, print_calls.d, we have scripts, two scripts there.

00:53:33.929 --> 00:53:40.289
This one that shows the entry and return of
all Ruby functions, printing the file name,

00:53:40.289 --> 00:53:43.190
the line number, the class and function name.

00:53:43.190 --> 00:53:46.860
And this will work for your Cocoa Ruby projects as well.

00:53:46.860 --> 00:53:50.400
And then the second one to observe memory usage

00:53:50.400 --> 00:53:57.820
so we can track garbage collection begin
and end and object creation and freeing.

00:53:57.820 --> 00:54:08.990
So let's go ahead and see a demo of some of
the other static probe activity in the system.

00:54:08.989 --> 00:54:17.769
First, I'd like to go up and go ahead and give
you an idea of if I do the pseudo dtrace -l,

00:54:17.769 --> 00:54:25.340
in case you missed it in the Steve Peters'
DTrace session yesterday, I'll just execute it.

00:54:25.340 --> 00:54:29.150
19,722 probes.

00:54:29.150 --> 00:54:42.059
If I grep for just the core data probes, we can see that
there's a lot of processes that are using core data,

00:54:42.059 --> 00:54:55.119
so process 1326, 1321, 1237, 183, 176, so all
of these probes are already there in the system.

00:54:55.119 --> 00:54:59.190
I could monitor them all at once with one script.

00:54:59.190 --> 00:55:05.880
But what I'm going to do is bring
up the group viewer project.

00:55:05.880 --> 00:55:08.260
Make sure that that's built.

00:55:08.260 --> 00:55:12.600
And this is a simple core databased application.

00:55:12.599 --> 00:55:20.779
I'll go into Xray, again, I'll use a blank template

00:55:20.780 --> 00:55:26.019
and bring in a core data instrument
that I had previously created.

00:55:26.019 --> 00:55:32.480
And in this case, I would also like to
monitor the reads and writes activity.

00:55:35.969 --> 00:55:45.929
So if we look at the core data probe instrument here in
DTrace, in Xray, we can see that I've got two probe points

00:55:45.929 --> 00:55:55.059
on this, one to watch the begins of fault activity
and one to watch the begins of fetch activities.

00:55:55.059 --> 00:56:03.469
In each case I record the string that is the
URI of the object ID of the object in question.

00:56:03.469 --> 00:56:19.879
So I can go ahead and launch the group viewer executable
from Xray and bring up a sample document in it.

00:56:19.880 --> 00:56:28.000
And we can see that we had a fair amount of
read and write activity at the start of it

00:56:28.000 --> 00:56:32.110
and there was also a delay when we open that window up.

00:56:32.110 --> 00:56:44.030
Now, as I scroll through my list of members, I can start
to see core data activity as we begin faulting operations

00:56:44.030 --> 00:56:49.400
to bring in the member data as I
was scrolling through the list.

00:56:49.400 --> 00:56:52.039
So that's kind of interesting.

00:56:52.039 --> 00:56:56.369
Lots of read write activity at the start.

00:56:56.369 --> 00:57:00.869
Fetching activity or faulting activity later on.

00:57:00.869 --> 00:57:08.269
So if you saw my demo on Monday, you might recognize
that we had in the interests of prematurely optimizing

00:57:08.269 --> 00:57:16.480
to give the user good user experience, we had actually
prefetched all this data when we loaded the document

00:57:16.480 --> 00:57:19.289
so that it would be there when you needed it.

00:57:19.289 --> 00:57:25.380
But as our customers started using larger
files, that started to be a performance hit

00:57:25.380 --> 00:57:29.720
and maybe we can do something about that.

00:57:29.719 --> 00:57:39.750
So if I go back into the project, and in
this case, my window has the lists in it,

00:57:39.750 --> 00:57:45.119
the lists are backed by array controllers
that have SQL Light activity.

00:57:45.119 --> 00:57:56.159
I can take a new advantage of a new feature in
Leopard that we've added to the core data array,

00:57:56.159 --> 00:58:01.139
all the controllers in core data,
and this is use lazy fetching.

00:58:01.139 --> 00:58:08.940
So I'll go ahead and turn on lazy fetching and build.

00:58:08.940 --> 00:58:13.210
Now let's go through this again to
see if we get any different behavior.

00:58:13.210 --> 00:58:18.179
So make sure that GroupViewer is not running.

00:58:18.179 --> 00:58:21.599
Okay. Go ahead and run a second time through.

00:58:21.599 --> 00:58:25.110
Load up our document.

00:58:25.110 --> 00:58:29.829
Much less read write activity up front.

00:58:29.829 --> 00:58:33.949
I didn't show it before, but we probably had over 10,000.

00:58:33.949 --> 00:58:36.319
Over 10,000 reads and writes up front here.

00:58:36.320 --> 00:58:38.220
We had 206.

00:58:38.219 --> 00:58:43.989
I go back to GroupViewer, scroll through the list again.

00:58:43.989 --> 00:58:54.109
Now we can see that as I'm doing my faulting in core
data, it's reading the data in just when I need it.

00:58:54.110 --> 00:59:00.890
So you can see the correlation of static
probes that we can define with semantic meaning

00:59:00.889 --> 00:59:03.670
and some of these system probes that are in the system.

00:59:03.670 --> 00:59:07.180
So you can do that for your apps as well.

00:59:07.179 --> 00:59:10.710
Okay? So let's go back to slides.

00:59:14.690 --> 00:59:22.019
So to recap, for adding static probes to your project,
you would write the provider description file,

00:59:22.019 --> 00:59:30.340
you would import the corresponding header file
in the source code where you need that header,

00:59:30.340 --> 00:59:36.530
number three would generate the provider header
file, which XCode will do automatically for you,

00:59:36.530 --> 00:59:40.880
and number four you would add the
probe invocation macros to your code.

00:59:40.880 --> 00:59:48.630
So on the provider description file you
do need to make sure that that is a file

00:59:48.630 --> 00:59:53.880
that is in the source target for your project.

00:59:55.489 --> 01:00:04.529
So in this session we've taken a look, another look, at
the power of Xray in DTrace and the power of them combined.

01:00:04.530 --> 01:00:07.580
We've looked at building customer DTrace instruments.

01:00:07.579 --> 01:00:16.579
We've seen a variety of kind of advanced ways
to invoke Xray for specialized circumstances.

01:00:16.579 --> 01:00:25.079
And we've seen how you can extend the power of this
system by instrumenting your own code with static probes.

01:00:25.079 --> 01:00:30.829
So for more information you can
contact our developer tools evangelist,

01:00:30.829 --> 01:00:35.409
Matt Formica, or
consult the documentation websites.

01:00:35.409 --> 01:00:43.089
You can look at the DTrace documentation
up on Sun's BigAdmin website.

01:00:43.090 --> 01:00:45.110
Just Google for that.
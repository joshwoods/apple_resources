WEBVTT

00:00:21.239 --> 00:00:25.149
>> My name is Mark Piccirelli, I'm
an engineer in the Cocoa Frameworks Group.

00:00:25.149 --> 00:00:31.839
Today we are going to talk about the many improvements
we've made to Cocoa support for scripting in Leopard.

00:00:31.839 --> 00:00:37.039
In particular, support for the .sdef file format
which you use to declare new features, is much improved.

00:00:37.039 --> 00:00:42.780
Cocoa's default behaviors for a lot of the standard commands
and things like that has gotten better and there are a bunch

00:00:42.780 --> 00:00:46.750
of new customization opportunities for your application.

00:00:46.750 --> 00:00:50.229
First of all, I am going to give a brief
introduction to making your apps scriptable.

00:00:50.229 --> 00:00:53.140
A little bit of overlap with what John Comiskey

00:00:53.140 --> 00:00:57.100
and Chris Nebel presented this morning
in making your applications scriptable.

00:00:57.100 --> 00:01:01.310
But I'll go into a little bit more
detail about the why in some things.

00:01:01.310 --> 00:01:08.439
Talk about new features in the .sdef file format,
including and also support for new kinds of types.

00:01:08.439 --> 00:01:13.609
Like custom value types, missing
values and enumerator values.

00:01:13.609 --> 00:01:16.179
I'll talk about improvements to error sensing and reporting,

00:01:16.180 --> 00:01:23.750
a bunch of new APIs since last WWDC
and finish of with some debugging tips.

00:01:23.750 --> 00:01:27.000
Today's sample code, as I use so often, is Sketch.

00:01:27.000 --> 00:01:29.500
Sketch has been completely rewritten for Leopard.

00:01:29.500 --> 00:01:36.379
It's called Sketch 2 now and it's just lousy with
bindings and key-value observing and key-value coding all

00:01:36.379 --> 00:01:44.259
over the place and it uses a lot of these new improvements,
these scripting improvements that I'm going to talk about.

00:01:45.609 --> 00:01:49.510
It's rewritten for Leopard.

00:01:49.510 --> 00:01:53.020
So first thing, declaring your application's scriptability.

00:01:53.019 --> 00:01:58.449
First word of terminology confusion to get out of the way.

00:01:58.450 --> 00:02:05.790
Cocoa and AppleScript both have long histories and
so you know, use some words in different words.

00:02:05.790 --> 00:02:08.950
So first thing, what an AppleScript is called, a property.

00:02:08.949 --> 00:02:13.349
Cocoa programmers usually refer to it
as an attribute or to-one-relationship.

00:02:13.349 --> 00:02:19.689
An element class when I say that when talking about .sdef
or AppleScript, I just mean a to-many relationship.

00:02:19.689 --> 00:02:25.659
You know, if you're familiar with Cocoa bindings or
core data, that's what you know that concept as.

00:02:25.659 --> 00:02:30.750
And one more element of confusion that was
pointed out is the word element is used

00:02:30.750 --> 00:02:33.750
in AppleScript and it's also used in XML.

00:02:33.750 --> 00:02:39.889
So I'll try and say XML element when I'm
talking about the .sdef style file format.

00:02:39.889 --> 00:02:45.209
So there's an old way and a new way to
declare your application's scriptability.

00:02:45.210 --> 00:02:53.879
The really old way is this parafile format that
Cocoa has supported since before Mac OS 10.0,

00:02:53.879 --> 00:02:59.009
called .scriptSuite files and .scriptTerminology
files and they were kind of hard to work with.

00:02:59.009 --> 00:03:07.209
They drew this separation between like the implementation
details and the localized things that you know, the users,

00:03:07.210 --> 00:03:11.210
people who write scripts would see
and that turned out not be that useful

00:03:11.210 --> 00:03:14.610
of a distinction and it made things harder to work with.

00:03:14.610 --> 00:03:18.210
So you know, they're kind of on their way out.

00:03:18.210 --> 00:03:24.800
But of course, they're still supported for compatibility
and you know, they will be for the foreseeable future.

00:03:24.800 --> 00:03:29.910
But what I really want you to do is
investigate this relatively new file format.

00:03:29.909 --> 00:03:34.099
Cocoa introduced support for it in
Tiger, it's called .sdef file format.

00:03:34.099 --> 00:03:35.620
It's much easier to work with.

00:03:35.620 --> 00:03:39.099
It's more compact, it's an XML-based file format.

00:03:39.099 --> 00:03:47.340
It has a really direct mapping of the elements in an .sdef
file to what you see in an AppleScript dictionary.

00:03:47.340 --> 00:03:53.310
The Cocoa-specific implementation
details are in their own XML elements.

00:03:53.310 --> 00:03:54.800
You know, they're kept a little separate.

00:03:54.800 --> 00:03:59.000
So you know just you know, what
only Cocoa is interested in reading.

00:04:00.169 --> 00:04:03.479
So very brief refresher what a
scripting dictionary looks like.

00:04:03.479 --> 00:04:08.030
This is part of Sketches as shown by
script editor's dictionary viewer.

00:04:08.030 --> 00:04:12.490
Just showing you the class, the graphic
class that has a bunch of properties.

00:04:12.490 --> 00:04:18.040
Simple ones like X position, Y position,
width and height and some colors.

00:04:18.040 --> 00:04:21.810
And here's what the .sdef looks
like that corresponds to that.

00:04:21.810 --> 00:04:27.720
I'll go into a little more detail about these different
pieces as I go on, but you know, there's a class XML element

00:04:27.720 --> 00:04:36.410
with a optionally Cocoa XML sub element and property elements
declaring you know, the various pieces of the class.

00:04:36.410 --> 00:04:41.510
So and I'll go through the pieces of .sdef
you know, in showing you the corresponding code

00:04:41.509 --> 00:04:46.250
that you get to write, you know that matches as I go.

00:04:46.250 --> 00:04:47.360
So the code you write.

00:04:47.360 --> 00:04:49.449
I'm just going to keep it pretty simple and quick.

00:04:49.449 --> 00:04:54.129
I'm just going to talk about the code you write to make
our implementations of the standard commands work.

00:04:54.129 --> 00:04:57.120
Get, set, count, exist, make, delete,
duplicate, move, you know,

00:04:57.120 --> 00:05:01.259
these are commands that are supposed
to operate on all sorts of objects.

00:05:01.259 --> 00:05:11.449
If you were in today's making your applications scriptable,
you're encouraged to fix, fit your object model you know,

00:05:11.449 --> 00:05:13.240
into something that works with these commands.

00:05:13.240 --> 00:05:20.629
You can add more if you need to, but
you need to surprisingly and frequently.

00:05:20.629 --> 00:05:26.420
So the first thing you do is when
you declare a class, like graphic,

00:05:26.420 --> 00:05:31.740
one of the things that you specify is the
corresponding Cocoa class, the Objective-C class.

00:05:31.740 --> 00:05:34.439
And in .sdef, you do it like this.

00:05:34.439 --> 00:05:42.269
Cocoa class SKTGraphic and the corresponding code is
not surprisingly a declaration of the SKT graphic class.

00:05:42.269 --> 00:05:45.899
And why does Cocoa care about the classes?

00:05:45.899 --> 00:05:48.379
Why do you have to declare this in .sdef again?

00:05:48.379 --> 00:05:50.379
And well the first thing is the Make command.

00:05:50.379 --> 00:05:56.420
You know, it's one of the standard commands and you
create a you know, you make a new graphic in Sketch

00:05:56.420 --> 00:05:59.540
for instance, by saying you know, make new graphic.

00:05:59.540 --> 00:06:03.530
So and also it's important for type checking.

00:06:03.529 --> 00:06:10.319
When you declare a class, you're declaring a new type that
matters to people that write scripts and also to your code.

00:06:10.319 --> 00:06:19.540
So you know, Cocoa uses that information to make sure that
what's coming in, you know the Apple events that result

00:06:19.540 --> 00:06:24.980
from an AppleScript being interpreted, to make sure
those are valid before it asks your application's code

00:06:24.980 --> 00:06:26.620
to do something.

00:06:28.110 --> 00:06:30.189
Classes have properties.

00:06:30.189 --> 00:06:31.500
Here's a simple one.

00:06:31.500 --> 00:06:36.689
The fill color of a Sketch graphic and
the property declaration looks like that.

00:06:36.689 --> 00:06:42.899
There's a type you have to specify and there's a Cocoa
key and I'll tell you what that's for in a little bit.

00:06:42.899 --> 00:06:44.069
And here's the corresponding code.

00:06:44.069 --> 00:06:52.899
For every, for every property that's readable and writable,
there is a getter and a setter that looks like this.

00:06:52.899 --> 00:06:54.060
And why do you have to do this?

00:06:54.060 --> 00:06:55.790
Well for a couple of reasons.

00:06:55.790 --> 00:06:58.860
Objects specifier evaluation is the main one.

00:06:58.860 --> 00:07:07.139
When somebody writes a script that says graphic
one of document one, what that causes to happen

00:07:07.139 --> 00:07:13.649
in your Cocoa application is a bunch of getter
methods to be invoked and also for the set command.

00:07:13.649 --> 00:07:18.819
When you say set fill color of you
know, of last graphic of front document,

00:07:18.819 --> 00:07:21.879
you know the center method that you saw there is invoked.

00:07:21.879 --> 00:07:24.579
And also, some other places where properties come

00:07:24.579 --> 00:07:29.490
into play is the "with" properties arguments
of the Make and Duplicate commands.

00:07:30.500 --> 00:07:38.389
So back to that same declaration and that same code, if
you notice the type as the scriptor sees it is RGB color

00:07:38.389 --> 00:07:44.659
and your code wants to handle, what's most
natural to do in your code, is to use NSColor.

00:07:44.660 --> 00:07:49.500
That's what you turn as the fill
color and take as the fill color.

00:07:49.500 --> 00:07:52.959
So how do AppleScript types map to Objective-C classes?

00:07:52.959 --> 00:07:55.560
This is a pretty important thing you have to know.

00:07:55.560 --> 00:08:01.810
All of the types that you're using in your
scripting are declared in .sdef files

00:08:01.810 --> 00:08:06.769
when you're using .sdef declared
scriptability which is what I'm focusing on today.

00:08:06.769 --> 00:08:16.049
The standard types, let's see like text and file,
things like that, are declared by foundation itself.

00:08:16.050 --> 00:08:18.990
You don't have to declare them in your application .sdef.

00:08:18.990 --> 00:08:22.970
They're completely documented in
the Cocoa scripting guide nowadays.

00:08:22.970 --> 00:08:28.700
If you want to dig around and see foundation's exact
declarations of these, they're in the resources directory,

00:08:28.699 --> 00:08:33.279
the foundation framework in a file called
intrinsics.sdef and you can add new types

00:08:33.279 --> 00:08:37.189
and I'll tell you how to do that in a little bit.

00:08:37.190 --> 00:08:42.040
The other and going back to this same
declaration and implementation pair,

00:08:42.039 --> 00:08:45.219
you'll see that the declaration has to specify a Cocoa key.

00:08:45.220 --> 00:08:53.269
A fill color in this case and that is used
to identify these corresponding method names.

00:08:53.269 --> 00:08:55.980
fillColor and setFillColor.

00:08:55.980 --> 00:08:58.330
And the questions is, well how did that, how does that work?

00:08:58.330 --> 00:09:01.740
How does AppleScript property
access map to Objective-C messages?

00:09:01.740 --> 00:09:05.610
It uses a mechanism called key-value coding,
which if you've been doing you know,

00:09:05.610 --> 00:09:10.050
a substantial amount of modern Cocoa programming,
you're probably getting pretty familiar with by now.

00:09:10.049 --> 00:09:13.059
Because it's also used by Cocoa bindings and core data.

00:09:13.059 --> 00:09:18.089
So you know, we use these same
underlying mechanisms over and over again.

00:09:18.090 --> 00:09:21.410
You know, the goal being to you
know, make you write less code.

00:09:21.409 --> 00:09:28.219
So and if you read the documentation for key-value coding
and read the header file for in the foundation framework,

00:09:28.220 --> 00:09:32.190
NSKey-valuecoding.h, you'll see there's
lots and lots of implementation options.

00:09:32.190 --> 00:09:37.900
There's direct instance variable access, there's different
method naming schemes that it can find, things like that.

00:09:37.899 --> 00:09:42.289
And of course, all this by the way, just works
automatically with Objective-C 2.0 properties.

00:09:42.289 --> 00:09:48.579
When you declare a property in one of your classes,
it just naturally works with key-value coding.

00:09:48.580 --> 00:09:51.400
So that was properties.

00:09:51.399 --> 00:09:52.899
There's also elements.

00:09:52.899 --> 00:09:56.730
Element classes in .sdef files and here's a simple one.

00:09:56.730 --> 00:09:59.529
Sketch documents have graphics.

00:09:59.529 --> 00:10:02.789
So you declare that fact like this.

00:10:02.789 --> 00:10:06.809
Element type graphic in the document class.

00:10:06.809 --> 00:10:13.149
And I mentioned these Cocoa XML sub elements
before, they're nearly always optional.

00:10:13.149 --> 00:10:15.689
So in this one, we left it out.

00:10:15.690 --> 00:10:23.840
Because Cocoa's .sdef parser can do a pretty good job of
guessing what key-value coding key you want to use for that.

00:10:23.840 --> 00:10:27.340
You know, it finds out the plural
name of the type and gives that a try.

00:10:27.340 --> 00:10:29.280
But that's not what you want.

00:10:29.279 --> 00:10:31.750
You can override it pretty easily.

00:10:33.490 --> 00:10:37.710
The corresponding code looks like
this for a simple case in Sketch.

00:10:37.710 --> 00:10:44.920
There's a method graphics that returns an NSArray
and there's an insertion method that takes an array

00:10:44.919 --> 00:10:50.490
and an IndexSet of you know, where
objects are to be inserted in the array

00:10:50.490 --> 00:10:55.419
and a corresponding re movement
that remove graphics at indexes.

00:10:55.419 --> 00:10:58.899
So and by the way, this might be a little, I
can't remember if this is different or the same

00:10:58.899 --> 00:11:01.909
as what you saw this morning in
Making Your Applications Scriptable.

00:11:01.909 --> 00:11:07.459
But again there's a bunch of options in key-value
coding including you know, single object, insert,

00:11:07.460 --> 00:11:12.210
inner move methods and multiple object,
insert and remove methods like this one.

00:11:12.210 --> 00:11:15.530
And these are, these are about performance by the way.

00:11:15.529 --> 00:11:21.970
So you know, being able to insert like a
whole ton of objects all at once, makes a,

00:11:21.970 --> 00:11:25.050
makes a you know, is a big deal sometimes.

00:11:26.600 --> 00:11:31.670
So how does AppleScript element
access map to Objective-C messages?

00:11:31.669 --> 00:11:35.319
Like when you ask for the you know,
the front document of Sketch

00:11:35.320 --> 00:11:40.240
or the you know, so and so graphics of a Sketch document?

00:11:40.240 --> 00:11:41.830
Well it just more key-value coding.

00:11:41.830 --> 00:11:48.360
Since Panther anyway, key-value coding has
had support for to-many relationships as well

00:11:48.360 --> 00:11:50.019
as attributes in to-many relationships.

00:11:50.019 --> 00:11:56.569
So we just use more of that in scripting and
again, there's many implementation options,

00:11:56.570 --> 00:12:00.460
including some complication caused by history here.

00:12:00.460 --> 00:12:09.250
Before there was this new support in Panther 10.3,
for to-many relationships in regular key-value coding,

00:12:09.250 --> 00:12:15.159
there was this other set of key-value coding methods
and foundations, NS script key-value coding header.

00:12:15.159 --> 00:12:21.870
So you can still use NS scripting key-value
coding methods that are described there

00:12:21.870 --> 00:12:26.350
and follow the method naming patterns that
are described there, but if you want to,

00:12:26.350 --> 00:12:31.129
just use the newer stuff that's in NS key-value coding.

00:12:31.129 --> 00:12:35.059
You know, this concept of scripting key-
value coding, it might be on it's way out.

00:12:35.059 --> 00:12:42.369
There's still, you know, it's still needed in Leopard for
some very scripting specific things like value with name

00:12:42.370 --> 00:12:47.490
and value with unique id, you know
some very scripting-centric concepts.

00:12:47.490 --> 00:12:53.320
But for just regular stuff, use
the regular key-value coding.

00:12:53.320 --> 00:12:59.210
And that will, because that will you know,
you're model objects are more likely to work well

00:12:59.210 --> 00:13:03.230
with Cocoa bindings and core data when you do that.

00:13:05.070 --> 00:13:07.350
So that was the quick overview.

00:13:07.350 --> 00:13:13.019
I didn't go into you know, implementing object
specifier methods, that was mentioned this morning.

00:13:13.019 --> 00:13:15.879
Didn't talk about testing or logging or anything like that.

00:13:15.879 --> 00:13:20.340
So you know, if you want to catch up,
if you're brand new to Cocoa scripting,

00:13:20.340 --> 00:13:24.040
go watch the video of making your
application scriptable when it comes out.

00:13:24.039 --> 00:13:30.059
Right now though, I want to talk about
new stuff in Cocoa scripting in Leopard.

00:13:30.059 --> 00:13:35.259
The first new feature is support for
dynamic .sdef and what this means is

00:13:35.259 --> 00:13:40.139
that you can build your application
scriptability declaration on the fly.

00:13:40.139 --> 00:13:46.179
In Tiger, your only option when you're using
the .sdef file format is to put it's name

00:13:46.179 --> 00:13:50.509
in the applications Info.plist and that's it, it's static.

00:13:50.509 --> 00:13:58.549
It has to be built right into your application and you know,
that's bad if you know, your application supports plug-ins.

00:13:58.549 --> 00:14:02.009
So but what's good now, if your
application supports plug-ins,

00:14:02.009 --> 00:14:06.799
is that you can build your application
scriptability, you know on the fly.

00:14:06.799 --> 00:14:09.729
So and there's more than one way to do it.

00:14:09.730 --> 00:14:12.539
There is to specify it, this is happening.

00:14:12.539 --> 00:14:15.579
I happened to pick this one for this slide.

00:14:15.580 --> 00:14:17.820
OSAScriptingDefinition in your Info.plist.

00:14:17.820 --> 00:14:22.570
Instead of putting the name of a
resource, put the word dynamic.

00:14:22.570 --> 00:14:26.370
And there's another Info.plist entry
who's name I cannot remember now,

00:14:26.370 --> 00:14:34.519
which allows you to make your application's scriptability
static on Tiger, where that's all that's supported.

00:14:34.519 --> 00:14:37.509
But dynamic on Leopard.

00:14:39.200 --> 00:14:47.430
So when you declare that your application's scriptability
is dynamic, what that means is something like AppleScript.

00:14:47.429 --> 00:14:55.159
The AppleScript interpreter, when it needs to you
know, find out what is scriptable in your application,

00:14:55.159 --> 00:15:00.419
it may send your application and get .sdef Apple event.

00:15:00.419 --> 00:15:02.509
And here's one way to handle that.

00:15:02.509 --> 00:15:10.539
In application will finish launching, use the NSAppleEventManager
API, to set an event handler to something

00:15:10.539 --> 00:15:16.429
in your application and then you know, any method
as long as it has a method signature like this one,

00:15:16.429 --> 00:15:22.239
that takes an apple event and also reply apple
event and then you get to do whatever you want.

00:15:22.240 --> 00:15:28.180
You can you know, pick pieces out of plug-in bundles
and things like that and assemble the .sdef yourself

00:15:28.179 --> 00:15:33.500
and you put it in an NSData, so that
you can put it in an apply Apple event.

00:15:33.500 --> 00:15:34.879
You do it this way.

00:15:34.879 --> 00:15:40.679
So by the way, when you're not using dynamic .sdef,
you just have a static .sdef declaration,

00:15:40.679 --> 00:15:47.929
one thing that's new in Leopard, what's old is new again,
is that your application doesn't have to get launched

00:15:47.929 --> 00:15:52.879
for script editor, for instance, to get the .sdef.

00:15:52.879 --> 00:15:58.000
AppleScript has been updated a little bit so it
will just go grab the .sdef data if it's static,

00:15:58.000 --> 00:16:02.720
out of your application so that's nice when
people open up a script in script editor

00:16:02.720 --> 00:16:05.620
and it doesn't launch your application
automatically right away.

00:16:05.620 --> 00:16:08.779
So but when the scriptability is
dynamic, then it really has to to find

00:16:08.779 --> 00:16:14.480
out what's going on with the scriptability right then.

00:16:14.480 --> 00:16:17.990
Something else that's new is includable .sdef.

00:16:17.990 --> 00:16:25.659
So the .sdef file format as you briefly saw, is just
XML and it's good XML with like a DTD and everything.

00:16:25.659 --> 00:16:33.740
With you know, the potential to be validated and there
is a technology in the XML world called XInclude.

00:16:33.740 --> 00:16:37.419
It's been around for a while but now we let you use it.

00:16:37.419 --> 00:16:44.500
The various .sdef parsers in the system
can handle it when you include you know,

00:16:44.500 --> 00:16:48.860
.sdef XML that's in one file, into another.

00:16:48.860 --> 00:16:54.470
So and it might save you some programming time in apps that
support plug-ins when you're, when you're putting together,

00:16:54.470 --> 00:16:58.790
you know an .sdef from scratch, it
might be easier for one .sdef to point

00:16:58.789 --> 00:17:01.779
to other .sdefs that are in like plug-in bundles.

00:17:01.779 --> 00:17:06.539
But in the short term, the more interesting
thing about this includable .sdef is,

00:17:06.539 --> 00:17:09.109
now that we give you something to include for free.

00:17:09.109 --> 00:17:13.659
So you don't' have to go digging around in
skeleton .sdef or find the right version

00:17:13.660 --> 00:17:17.140
of Sketch and pull the .sdef out of that.

00:17:17.140 --> 00:17:22.120
So if you look on your current seeds in
system library scripting definitions,

00:17:22.119 --> 00:17:29.429
there's a file called CocoaStandard.sdef and it
includes declarations of standard commands and classes,

00:17:29.430 --> 00:17:34.330
open, close, save, print, quit, the rest of
the standard ones and some standard classes

00:17:34.329 --> 00:17:40.639
like application document window, that work with Cocoa,
that work with you know, classes like NSApplication,

00:17:40.640 --> 00:17:45.940
NSDocument, NSWindow and are implementations
of those standard commands.

00:17:47.890 --> 00:17:55.800
And when you're importing or including CocoaStandard.sdef,
very often you won't want to include the whole thing.

00:17:55.799 --> 00:18:01.789
For example, if you have an application that's scriptable
but it doesn't print, because that's just not useful,

00:18:01.789 --> 00:18:07.250
it doesn't make any sense, you can leave
our declaration of the print command out.

00:18:07.250 --> 00:18:16.740
So and the way you do that is by using this pretty, pretty
esoteric or at least very sophisticated and complete

00:18:16.740 --> 00:18:20.279
and futureful technology called XPointer,

00:18:20.279 --> 00:18:24.289
that lets you leave out the declarations
you don't want, without discarding them all.

00:18:24.289 --> 00:18:29.559
So and the result of this is less copy and
paste as you're making new applications.

00:18:29.559 --> 00:18:34.720
But there still may be some, because at least for
Leopard, one thing that's not in Cocoa standard

00:18:34.720 --> 00:18:38.500
on .sdef, is declarations of the text suite.

00:18:38.500 --> 00:18:42.220
You still have to grab that from you
know, Sketch or something like that

00:18:42.220 --> 00:18:45.039
if your application's text is scriptable.

00:18:46.289 --> 00:18:50.220
And here's, here's what a sample usage looks like.

00:18:50.220 --> 00:19:00.269
This is the top of Sketch.sdef, maybe not the one
on your seed, but any second now and it's, it specifies,

00:19:00.269 --> 00:19:04.900
you know, uses the XInclude name space and
then actually just at the top of the file,

00:19:04.900 --> 00:19:08.330
imports from CocoaStandard.sdef everything.

00:19:08.329 --> 00:19:14.439
And the way you specify everything, the way .sdef
files are shaped, is by saying every suite

00:19:14.440 --> 00:19:19.730
in every dictionary the .sdef file and
then it goes on to Sketches own stuff.

00:19:19.730 --> 00:19:26.220
So this saves lots of code and not lots
of code, but lots of lines of you know,

00:19:26.220 --> 00:19:30.190
text in the .sdef file that you're
editing for your own application.

00:19:31.450 --> 00:19:37.279
Something that's been defined in .sdef
for awhile but is now supported much better

00:19:37.279 --> 00:19:42.480
in Cocoa are class-extension elements and
they're kind of like Objective-C categories,

00:19:42.480 --> 00:19:46.920
it's a way to add new properties
and elements to scriptable classes.

00:19:46.920 --> 00:19:54.340
And it's again, useful in app support plug-ins and even
in apps that don't have a need for a plug-in architecture,

00:19:54.339 --> 00:19:59.609
they're good as an organizational tool for you know, the
people who have to look at your app scripting dictionary.

00:19:59.609 --> 00:20:01.649
Keeps them a little more organized.

00:20:01.650 --> 00:20:05.660
For example, keep classes like
documents showing in the standard suite.

00:20:05.660 --> 00:20:12.970
The standard suite, you know, the thing that all apps are
supposed to have in common, you know, has a document class

00:20:12.970 --> 00:20:15.839
and if your app has documents, that's where it goes.

00:20:15.839 --> 00:20:17.509
If it doesn't have documents you just leave it out.

00:20:17.509 --> 00:20:19.490
But if it does, that's where it goes.

00:20:19.490 --> 00:20:27.599
But your application's documents you know, presumably
do add something unique to the document class.

00:20:27.599 --> 00:20:30.839
And what you do is you put those in a class extension,

00:20:30.839 --> 00:20:37.789
so that way they show up in you know,
your application's own scripting suite.

00:20:37.789 --> 00:20:41.559
So here's a simple example from Sketch.

00:20:41.559 --> 00:20:45.679
Just class-extension extends= "document".

00:20:45.680 --> 00:20:55.370
This is all there is you know, in
Sketch's .sdef for the document class.

00:20:55.369 --> 00:21:03.579
One important thing to keep in mind or one
important use for this, even when you .sdef,

00:21:03.579 --> 00:21:07.990
so when your application imports CocoaStandard.sdef,

00:21:07.990 --> 00:21:12.519
CocoaStandard.sdef has a
declaration of the document class.

00:21:12.519 --> 00:21:17.150
It specifies as the implementation
class, the Cocoa class, NSDocument.

00:21:17.150 --> 00:21:19.110
That's very often not good enough.

00:21:19.109 --> 00:21:25.459
When the user says you know, make new document,
they want one of you know, your app's documents,

00:21:25.460 --> 00:21:28.210
not some generic object that's not
even really instantiable.

00:21:28.210 --> 00:21:34.789
So one thing we just added to the class
extension XML element is the ability

00:21:34.789 --> 00:21:39.740
in a Cocoa XML sub element, to specify
the implementation class.

00:21:39.740 --> 00:21:43.640
So yes, if more than one class extension tries

00:21:43.640 --> 00:21:47.810
to specify the implementation class,
I don't really know what will happen.

00:21:47.809 --> 00:21:49.240
One of them will win.

00:21:49.240 --> 00:21:54.859
But in the meantime, this is a, you know, this is a
good way to just you know, get the reuse of what's

00:21:54.859 --> 00:22:03.629
in CocoaStandard.sdef while still you know, being
able to easily provide the information you have to provide.

00:22:03.630 --> 00:22:09.860
Synonym elements and by the way, these next two
slides, this is, these are the one bit of bunk

00:22:09.859 --> 00:22:13.099
in today's presentation where it's
not in today's seed at all.

00:22:13.099 --> 00:22:14.069
Even a little bit.

00:22:14.069 --> 00:22:17.710
But they will be in there before we ship.

00:22:17.710 --> 00:22:20.130
So synonym elements are important.

00:22:20.130 --> 00:22:27.250
This is all about compatibility. You're not supposed to,
you're supposed to try not to break existing scripts.

00:22:27.250 --> 00:22:32.130
As you add features to your application's
scriptability, things like that,

00:22:32.130 --> 00:22:36.610
you want you know, existing scripts to keep running.

00:22:36.609 --> 00:22:41.279
John Kamiski (sp?) emphasized that a lot this
morning in Making Your Applications Scriptable.

00:22:41.279 --> 00:22:45.539
You know, when people build work
flows with your application, you know,

00:22:45.539 --> 00:22:48.200
they've got more invested in your application.

00:22:48.200 --> 00:22:54.740
They're kind of locked in and you know, unless
you ruin that by breaking their scripts,

00:22:54.740 --> 00:22:57.069
their work flows, that's a good business.

00:22:57.069 --> 00:23:03.839
So compatibility which has always been pretty
important in you know, Apple scriptability,

00:23:03.839 --> 00:23:08.949
is now getting one step more important
with scripting bridge.

00:23:08.950 --> 00:23:14.130
Because it raises the compatibility bar in
that now other applications are depending

00:23:14.130 --> 00:23:17.560
on your application's scriptability to stand still.

00:23:17.559 --> 00:23:23.569
They're writing Objective-C code that mentions you know,
your application's pieces and parts that you've exposed

00:23:23.569 --> 00:23:30.009
through scriptability by name and if you change that
in your app, you're effectively breaking other apps.

00:23:30.009 --> 00:23:32.629
So this is pretty important.

00:23:32.630 --> 00:23:36.820
So you don't have the option of not
changing your application's scriptability.

00:23:36.819 --> 00:23:39.659
You know, you want to keep it clean.

00:23:39.660 --> 00:23:47.660
For starters, you want to rename things, maybe to match your
UI, maybe just to be cleaner and also you want to do things

00:23:47.660 --> 00:23:50.120
like fixing four-character code mistakes.

00:23:50.119 --> 00:23:54.159
I'm not going to go too much into four-character
codes, it's something you have to deal

00:23:54.160 --> 00:23:58.710
with when you're making your applications
scriptable because that's what NSAppleEvent

00:23:58.710 --> 00:24:02.049
or that's what AppleEvents use to identify different parts.

00:24:02.049 --> 00:24:11.339
So four-character codes are you know, look easy you know,
use any four characters you want except for those four.

00:24:11.339 --> 00:24:18.339
So it's easy to make mistakes here, but you know,
you want to fix them and this helps you fix them.

00:24:18.339 --> 00:24:23.970
By synonym elements, what they do is when you know, when
you have an element of your application's scriptability,

00:24:23.970 --> 00:24:30.960
a property or a command argument or something like that,
you get to use a synonym, you get to change the name

00:24:30.960 --> 00:24:35.289
or the four-character code, but then use a synonym
to specify the old name in four-character code.

00:24:35.289 --> 00:24:39.619
So scripts will still compile and
complied scripts will still run.

00:24:41.049 --> 00:24:47.289
So here's a simple example, something worth
thinking of doing in CocoaStandard.sdef is,

00:24:47.289 --> 00:24:49.389
renaming one of the parameters of the Make command.

00:24:49.390 --> 00:24:54.780
You know, right now it's with data and
you know, that's kind of nerdy and you know,

00:24:54.779 --> 00:24:58.990
scriptors are people too, they're
actual users not programmers.

00:24:58.990 --> 00:25:04.420
So we're thinking of renaming it to "with contents", but
of course lots of lots of scripts in the world you know,

00:25:04.420 --> 00:25:06.910
refer to this parameter, the Make command, as with data.

00:25:06.910 --> 00:25:11.970
So what we're probably going to do is just
rename the parameter but then add a synonym

00:25:11.970 --> 00:25:15.660
"with data", so that existing scripts keep running.

00:25:18.099 --> 00:25:24.139
So another compatibility issue that we let you handle
a little easier now, well the same compatibility issue,

00:25:24.140 --> 00:25:30.950
different kind of fix, we now support in Cocoa, the
"hidden" attribute and this is really in the seed you have.

00:25:30.950 --> 00:25:42.230
Some reasons why you might want to like hide you know,
pieces of your application's scriptability from people

00:25:42.230 --> 00:25:47.500
who are coming to your application new, is that you
know, it's just old cruft that you're leaving in there

00:25:47.500 --> 00:25:57.049
for compatibility. Here's a bit of you know, Cocoa history
from scripting is, we've always had a path property

00:25:57.049 --> 00:26:01.919
on documents and its value is just
typed, you know, its typed text.

00:26:01.920 --> 00:26:05.480
It was a POSIX path string
but that's really not what people

00:26:05.480 --> 00:26:07.589
in the AppleScript community are used to working with.

00:26:07.589 --> 00:26:13.769
So now for example, in CocoaStandard.sdef,
the document class has a,

00:26:13.769 --> 00:26:17.099
has a file property and it's type is file.

00:26:17.099 --> 00:26:19.079
Just a regular AppleScript thing.

00:26:19.079 --> 00:26:24.119
But of course, we don't want to break existing scripts,

00:26:24.119 --> 00:26:28.699
so one thing you can do is leave the old path
property in there and just mark it hidden.

00:26:28.700 --> 00:26:36.380
So you know, people don't have to look at it anymore in
the dictionary viewer but current scripts keep running.

00:26:37.890 --> 00:26:44.450
So those were, those were the kind of
improvements that don't really have much to do.

00:26:44.450 --> 00:26:48.660
There's no corresponding coding work to
do to take advantage of those features.

00:26:48.660 --> 00:26:54.590
This next section is going to be a
bunch of things where what you declare

00:26:54.589 --> 00:26:59.480
in the .sdef file does effect what kind of code you write.

00:26:59.480 --> 00:27:02.700
The first thing is support for custom value types.

00:27:02.700 --> 00:27:09.819
You could declare value, value types in .sdef,
in Tiger, but there are a bunch of limitations.

00:27:09.819 --> 00:27:13.200
You can only do ones that AppleScript understood anyway.

00:27:13.200 --> 00:27:18.259
You know, ones that it found in some other
dictionary or built into the language.

00:27:18.259 --> 00:27:25.099
And you could even implement value types in Tiger, like
this one you know, the one I was talking about before,

00:27:25.099 --> 00:27:30.149
value type RGBColor and Cocoa class NSColor.

00:27:30.150 --> 00:27:35.810
What's different now in Leopard is that we
tell you how to implement custom value types

00:27:35.809 --> 00:27:38.389
and now they'll work even when they're genuinely custom.

00:27:38.390 --> 00:27:42.670
So and here's a pretty simple example.

00:27:42.670 --> 00:27:44.730
Well the declaration you just saw.

00:27:44.730 --> 00:27:49.049
For the RGBColor type, it's not actually
something that's built right into AppleScript.

00:27:49.049 --> 00:27:51.919
So Sketches .sdef declares this.

00:27:51.920 --> 00:27:58.410
When you declare a new value type though, there's, there's
something that has to go on when AppleEventDescriptors

00:27:58.410 --> 00:28:04.990
of that type come into your application, they have
to get converted into Objective-C objects for passing

00:28:04.990 --> 00:28:09.620
around to the implementations of
custom commands or being passed

00:28:09.619 --> 00:28:12.579
into setter methods for properties and things like this.

00:28:12.579 --> 00:28:16.369
So when you add a custom value
type, here's how you make that work.

00:28:16.369 --> 00:28:20.959
You specified a class in the Cocoa class
XML sub element of the value type,

00:28:20.960 --> 00:28:27.789
so in that class implement a class method
who's name follows a pattern like this.

00:28:27.789 --> 00:28:30.309
ScriptingRGB color with the scriptor.

00:28:30.309 --> 00:28:38.450
RGB color is the name of the type with some
extra capitalization and the space is removed.

00:28:38.450 --> 00:28:43.410
So you just implement a method name that looks
like that and inside there you, you know,

00:28:43.410 --> 00:28:48.519
you'll use NSAppleEventEescriptor to pick apart what's
in there and return you know, an object of the right type.

00:28:48.519 --> 00:28:52.869
If you look in the Sketch sample
code today, it has these methods.

00:28:52.869 --> 00:29:01.239
So you can see how it gets from a you know, an
AppleScript style RGBColor into an NSColor.

00:29:01.240 --> 00:29:08.029
Going in the other direction, when one of your
accessors returns an NSColor, how does that get turned

00:29:08.029 --> 00:29:12.000
into an AppleEventDescriptor and it's
with a method that looks like this.

00:29:12.000 --> 00:29:15.099
Scripting RGBColor descriptor.

00:29:15.099 --> 00:29:21.059
So this is very much inspired by key-value coding
where, you know, we take the names that you put

00:29:21.059 --> 00:29:24.859
in you know the .sdef and we make methods out of them.

00:29:24.859 --> 00:29:28.939
And if you get it wrong and you know, these
methods don't exist or their methods there

00:29:28.940 --> 00:29:31.400
that have the wrong name, it throws an exception.

00:29:31.400 --> 00:29:34.700
It says you know, the method's not implemented.

00:29:36.089 --> 00:29:37.679
So missing values.

00:29:37.680 --> 00:29:41.650
Something that's actually pretty important
in AppleScript is support for missing values

00:29:41.650 --> 00:29:44.690
which is distinct from no values by the way.

00:29:44.690 --> 00:29:53.740
For example, here's the declaration of fill color
for Sketch graphics and it uses something that's been

00:29:53.740 --> 00:29:56.539
in .sdef by the way, called complex types.

00:29:56.539 --> 00:30:03.279
A complex type is when the type of a
value can be, can be you know, one,

00:30:03.279 --> 00:30:05.170
you know this type, that type or another type.

00:30:05.170 --> 00:30:06.130
Alternative types.

00:30:06.130 --> 00:30:11.800
So we use that in this example, for the fill color property.

00:30:11.799 --> 00:30:16.720
A fill color can be RGB color or it can be missing value.

00:30:16.720 --> 00:30:23.940
So in Sketch, not all you know, graphics have to be filled.

00:30:25.160 --> 00:30:34.750
And a little background for you, you know is SKT
graphic, you will see properties declared in the header.

00:30:34.750 --> 00:30:40.920
Things like fill color and stroke color
and is drawing fill, is drawing stroke.

00:30:40.920 --> 00:30:43.340
Those are there for use by Cocoa bindings.

00:30:43.339 --> 00:30:49.129
You know, there's a graphics inspector in
Sketch where, you know, there's a color well

00:30:49.130 --> 00:30:51.180
and there's a check box right next to it.

00:30:51.180 --> 00:30:54.259
So you know, in AppleScript you could do the same thing.

00:30:54.259 --> 00:30:58.170
You could say people have to turn on
filling and then set the fill color.

00:30:58.170 --> 00:31:02.480
But you know, that's not convenient
enough for, for people writing scripts.

00:31:02.480 --> 00:31:08.730
So instead we, you know, let them specify either a
color or that there is no color all on the same property

00:31:08.730 --> 00:31:11.360
and here's what the setter would
end up looking like for that.

00:31:11.359 --> 00:31:16.259
setScriptingFillColor, a fill
color is passed in, it might be nil.

00:31:16.259 --> 00:31:23.089
So if it's not nil, you know, there's code that you
know, turns on the filling and then set the fill color.

00:31:23.089 --> 00:31:27.009
But if it is nil, just turn off filling of that graphic.

00:31:27.009 --> 00:31:29.990
So there's a couple different ways to do this by the way.

00:31:29.990 --> 00:31:35.930
For example, in you know Sketch graphic, you can also
have you know, transparent colors and things like that

00:31:35.930 --> 00:31:40.400
or you could have an enumerator that
means no color and things like that.

00:31:40.400 --> 00:31:45.910
I'm just using missing value in Sketch because I have to
demonstrate this concept you know, somewhere simple so.

00:31:45.910 --> 00:31:48.850
Just using fill color for that.

00:31:48.849 --> 00:31:52.539
Missing values are also good for to-one relationships.

00:31:52.539 --> 00:32:00.149
So if you have you know, a class that's modeled that
way, where you know, different scriptable objects point

00:32:00.150 --> 00:32:07.019
to other scriptable objects or maybe they don't, it's
you know, missing value is a good way to indicate

00:32:07.019 --> 00:32:10.619
that this object might point to nothing in this example.

00:32:10.619 --> 00:32:14.849
An implementation note is that you
never have to fool around with NSNull.

00:32:14.849 --> 00:32:20.889
I know some developers have discovered that if they
write a getter method that returns an NSNull object,

00:32:20.890 --> 00:32:29.840
Cocoa scripting for the last several releases, will convert
that to a missing value that shows up in the you know,

00:32:29.839 --> 00:32:34.179
the results of running the AppleScript
and that continues to work.

00:32:34.180 --> 00:32:38.710
But you know, we never published that
because it wasn't, it wasn't that great.

00:32:38.710 --> 00:32:42.130
So you know, NSNulls are just for
putting an NSArrays in dictionaries.

00:32:42.130 --> 00:32:43.550
You know, they're placeholder values.

00:32:43.549 --> 00:32:48.289
For returning from getters or passing
into setters, they don't really belong.

00:32:48.289 --> 00:32:52.450
Because all of a sudden, all sorts of code
has to specify, you know, check for them.

00:32:52.450 --> 00:32:59.850
So if you're doing this that's fine, but going
forward in .sdef using this missing value support,

00:32:59.849 --> 00:33:04.649
you never have to write getters that return NSNull
anymore and the reason you don't want to by the way,

00:33:04.650 --> 00:33:09.150
what's particularly bad about that is it might
confuse your other key-value coding clients.

00:33:09.150 --> 00:33:10.800
Like Cocoa bindings.

00:33:10.799 --> 00:33:12.149
A lot of them will be surprised.

00:33:12.150 --> 00:33:16.370
So by avoiding this whole NSNull issue, you know,

00:33:16.369 --> 00:33:22.069
we keep your getter methods reusable
by different technologies in Cocoa.

00:33:22.069 --> 00:33:27.609
Something else that's new is custom enumerator values.

00:33:27.609 --> 00:33:33.049
.sdef has support for a concept called
enumerations, which is a type that defines

00:33:33.049 --> 00:33:36.849
that the value is you know, one
of a couple different values.

00:33:36.849 --> 00:33:46.109
So and in Tiger when you did that, what was passed to
your setter methods are found in the arguments dictionary,

00:33:46.109 --> 00:33:53.589
one of your commands, was an NSNumber who's value
was a four-character code made into an integer.

00:33:53.589 --> 00:33:55.309
So that's wasn't very convenient.

00:33:55.309 --> 00:34:04.359
So what we've done now is, in the Cocoa XML sub
element of enumerator XML elements in .sdef files,

00:34:04.359 --> 00:34:08.759
you can now specify an integer-value
attribute or a boolean-value attribute

00:34:08.760 --> 00:34:12.140
or a string-value attribute and
this is what your code will see.

00:34:12.139 --> 00:34:17.369
So and this feature by the way, is strictly for
making programming a little easier and you know,

00:34:17.369 --> 00:34:23.219
Cocoa parameters in general get you know, the
old school ones anyway from, from next land,

00:34:23.219 --> 00:34:26.059
get a little grumpy when they see four-character codes so.

00:34:26.059 --> 00:34:31.570
Now there's really no more reason to see them
at all in, in you know, your source code.

00:34:31.570 --> 00:34:35.750
And this turned out to be surprisingly
useful in a couple situations.

00:34:35.750 --> 00:34:43.780
The really neat one was in the
as parameter of the save command.

00:34:43.780 --> 00:34:47.360
The save command has an as parameter, it's optional.

00:34:47.360 --> 00:34:53.550
It's where a person writing a script gets to specify
what file format should be used when saving a document.

00:34:53.550 --> 00:35:01.100
So Sketch for example, can save documents in
PDF format, TIFF format or Sketch's own format.

00:35:01.099 --> 00:35:08.449
And so we want to let scriptors write things that are
pretty natural, save the document in the file as TIFF

00:35:08.449 --> 00:35:13.449
and I guess I'm claiming that this crazy
four-character acronym is pretty natural

00:35:13.449 --> 00:35:14.989
because it's been around for a long time.

00:35:14.989 --> 00:35:19.189
Everybody knows what it means and nobody actually
wants to write out tagged image file format.

00:35:19.190 --> 00:35:25.829
But that string, that's not the kind of
thing that gets passed around in code.

00:35:25.829 --> 00:35:35.420
So one thing that's new in Leopard is the save command,
the default implementation of it, in NSDocument,

00:35:35.420 --> 00:35:40.329
now does a good job of handling this, this as parameter.

00:35:40.329 --> 00:35:47.460
So but what it has to do to do that is to pass to the
code that actually saves the file, a file type name.

00:35:47.460 --> 00:35:49.190
That's the way it works in NSDocument.

00:35:49.190 --> 00:35:53.170
So and for example of a file type
name, something like public.tiff,

00:35:53.170 --> 00:35:57.289
that's a uniform type identifier,
which is the new way to do that.

00:35:57.289 --> 00:36:00.119
We introduced this in Leopard and
talked about it a little bit

00:36:00.119 --> 00:36:03.339
at WWDC last year, the new uniform type identifier system.

00:36:03.340 --> 00:36:10.960
So how do we get from TIFF to public.tiff
for passing around in NSDocument messages?

00:36:10.960 --> 00:36:12.960
Well, Sketch does it this way.

00:36:12.960 --> 00:36:21.490
It declares a type savable file format, it's an
enumeration and then enumerators are Sketch, TIFF and PDF.

00:36:21.489 --> 00:36:29.469
That's what scriptors see, but the values, the
string values, NS strings that Cocoa programmers see

00:36:29.469 --> 00:36:38.369
or Cocoa code sees, is a com.apple.sketch2,
com.adobe.pdf or public.tiff.

00:36:38.369 --> 00:36:40.619
Like that.

00:36:40.619 --> 00:36:42.569
So and where does this type get used?

00:36:42.570 --> 00:36:48.980
Here's the example and the as parameter
of the save command that you just get

00:36:48.980 --> 00:36:52.969
to use the enumeration name as a type "saveable file format".

00:36:52.969 --> 00:36:57.509
So it ended up, it doesn't you know, it doesn't
make any difference to people writing scripts

00:36:57.510 --> 00:37:00.730
but it made the code a lot more convenient.

00:37:00.730 --> 00:37:06.740
So it'll, it'll probably make a few things that
you do in your own code more convenient too.

00:37:06.739 --> 00:37:10.219
So error sensing and reporting.

00:37:10.219 --> 00:37:11.239
A quick quiz.

00:37:11.239 --> 00:37:15.809
When there are no documents open in
Sketch, what will this script return?

00:37:15.809 --> 00:37:18.719
First graphic of front document.

00:37:18.719 --> 00:37:19.719
It's a rhetorical question.

00:37:19.719 --> 00:37:21.279
You don't have to yell anything out.

00:37:21.280 --> 00:37:25.730
It returns bleh. It returns, Sketch got an error,

00:37:25.730 --> 00:37:32.360
NSReceiverEvaluationScriptError
and just to add insult to injury, 4.

00:37:32.360 --> 00:37:35.309
( laughter )

00:37:35.309 --> 00:37:40.849
So you know, if you seen this you are writing
your you know, your scriptable application

00:37:40.849 --> 00:37:45.339
or you're scripting another application,
you know, you are right to be horrified.

00:37:45.340 --> 00:37:49.340
I mean, the reaction is ah that's great.

00:37:49.340 --> 00:37:51.880
Thanks for the help.

00:37:51.880 --> 00:38:00.490
Oh god. So now in Leopard when you do that,
ah, just the regular Apple event error.

00:38:00.489 --> 00:38:03.139
Can't get document. Invalid index.

00:38:03.139 --> 00:38:08.829
So all over Cocoa scripting and
pretty much hundreds of places now,

00:38:08.829 --> 00:38:14.299
where we were returning these strange little error
codes that were defined by NSScript command like,

00:38:14.300 --> 00:38:19.780
cannot create command and receiver evaluation error,
we just used the regular Apple event error codes

00:38:19.780 --> 00:38:23.710
that have been defined for many, many years.

00:38:23.710 --> 00:38:25.639
Like 12 or 15 or whatever.

00:38:25.639 --> 00:38:28.759
( applause )

00:38:28.760 --> 00:38:33.340
So it's, it's, it's, it's definitely
going to make things a little bit better.

00:38:33.340 --> 00:38:37.590
And actually you know, I think,
I think we've been making Cocoa,

00:38:37.590 --> 00:38:40.550
we've been making AppleScript look bad in this regard.

00:38:40.550 --> 00:38:47.870
People go AppleScript is you know, much easier
to read than to write and I think you know,

00:38:47.869 --> 00:38:52.659
a good portion of that is you know, AppleScript itself
has very little error checking and in particular,

00:38:52.659 --> 00:38:59.149
even less type checking you know, saying things like set
the fill color of a graphic to front window you know ah,

00:38:59.150 --> 00:39:03.960
it's pretty happy to you know, bundle that up into
an AppleEvent and send it to the application.

00:39:03.960 --> 00:39:08.619
So you know, the trouble that people
have been having learning AppleScript is

00:39:08.619 --> 00:39:16.000
because we've just been punishing you and you experiment
and get it wrong and you know, we're not doing that anymore.

00:39:16.000 --> 00:39:20.500
So Cocoa now has much better error
checking and in particular, type checking.

00:39:20.500 --> 00:39:26.199
.sdef, the you know, it's much cleaner
file format, more rational where you know,

00:39:26.199 --> 00:39:34.199
everything is pretty clearly defined, allows us
to do better type checking in a lot of cases.

00:39:34.199 --> 00:39:41.969
So and you know, one more upshot in addition to what
scriptors see, your code won't be invoked strangely.

00:39:41.969 --> 00:39:48.379
You know, the error checking that you know, the very
most conscientious among you who've been you know,

00:39:48.380 --> 00:39:56.000
testing your stuff and then and then you know finding your
methods being passed in these crazy objects because you know,

00:39:56.000 --> 00:40:02.030
you put a crazy object in it and you know in the script,
you know, you don't have to worry about that anymore.

00:40:02.030 --> 00:40:07.460
You don't have to do things like invoking is kind of
of class and setter methods to be perfectly safe.

00:40:07.460 --> 00:40:13.570
The error checking moves from the code to where it belongs
and the .sdef, in the declaration of what your code can do

00:40:13.570 --> 00:40:16.550
and now Cocoa scripting will just you know, catch all this.

00:40:16.550 --> 00:40:20.140
And there's a reusability implication here again.

00:40:20.139 --> 00:40:24.819
Your KVC compliance methods, your getters and
setters and insertion and removal methods and things

00:40:24.820 --> 00:40:30.930
like that become a little more reusable because
they're not doing freaky things that you know,

00:40:30.929 --> 00:40:34.710
like peeking in the current NSScript
command and stuff like that.

00:40:34.710 --> 00:40:42.039
Things that you know, you like to keep out of the way of
you know, their use by Cocoa bindings or something like that.

00:40:42.039 --> 00:40:44.739
So a new API.

00:40:44.739 --> 00:40:50.049
Boy you've been making a lot of requests for a new
API and we have been listening to all of them.

00:40:50.050 --> 00:40:53.480
So and we have had some ideas of our own, too.

00:40:53.480 --> 00:40:58.019
So the first one is customizing object specifier evaluation.

00:40:58.019 --> 00:41:01.119
With this new method, scripting value for specifier,

00:41:01.119 --> 00:41:08.909
it's declared in NSObjectScripting.h.
It's sent to the container of specified objects.

00:41:08.909 --> 00:41:20.500
So when somebody writes a script that asks a Sketch document
for every graphic who's fill color you know, is so and so,

00:41:20.500 --> 00:41:27.039
it results in you know, the object specifier being
passed to this method that's sent to the document.

00:41:27.039 --> 00:41:30.739
The container of the things being dug around in.

00:41:30.739 --> 00:41:33.879
So and you get to override it to
do pretty much whatever you want.

00:41:33.880 --> 00:41:37.500
If you don't know what you want, invoke super.

00:41:37.500 --> 00:41:42.820
If you you know, NSScriptObjectSpecifier
has a few different subclasses of it.

00:41:42.820 --> 00:41:48.390
If you recognize a subclass and you know, there's
something you can do with it, then go ahead and do it.

00:41:48.389 --> 00:41:53.420
Otherwise just invoke super and the default
implementation does what Cocoa scripting was going to do anyway.

00:41:53.420 --> 00:42:03.110
So this name, scriptingValueForSpecifier, value here
it's meaning is the key-value coding sense of the word

00:42:03.110 --> 00:42:04.170
and then some.

00:42:04.170 --> 00:42:10.470
And what that means is you know so what, this is
very abstract looking, what am I supposed to return.

00:42:10.469 --> 00:42:13.889
Well, it depends on what's in the object specifier.

00:42:13.889 --> 00:42:18.449
If it's say, if it's a range specifier,
you turn an array of objects.

00:42:18.449 --> 00:42:21.809
If it's an index specifier, you turn one object.

00:42:21.809 --> 00:42:26.980
If it's a whose specifier, you've gotta check
and see what kind of whose specifier it is.

00:42:26.980 --> 00:42:33.429
So the rules aren't that simple but
they are very predictable so you know,

00:42:33.429 --> 00:42:37.389
if you get it right once, you'll keep getting it right so.

00:42:37.389 --> 00:42:40.589
Eventually I think these will probably
be all written down somewhere.

00:42:40.590 --> 00:42:46.519
You know, what kind of object specifier gets
you know results in what being returned.

00:42:46.519 --> 00:42:51.170
So and I keep talking about whose specifier is very
important and powerful piece of AppleScript.

00:42:51.170 --> 00:42:56.450
You know, one of the main reasons that people've been
asking for a method like this is for optimization.

00:42:56.449 --> 00:42:59.059
So they can do fast things with whose specifiers.

00:42:59.059 --> 00:43:02.920
Like convert them to predicates and pass that to core data.

00:43:02.920 --> 00:43:06.940
So all the API you need to do that now is public.

00:43:06.940 --> 00:43:15.869
So one little bit of information in the interest of
full disclosure is, this is not invoked all the time.

00:43:15.869 --> 00:43:20.599
There are still places where Cocoa's
implementation of some standard commands like delete

00:43:20.599 --> 00:43:27.159
and move don't actually want the objects, they
want the indexes at which the object exists,

00:43:27.159 --> 00:43:29.429
so they can you know, delete or move them.

00:43:29.429 --> 00:43:36.539
So if you're doing a really serious customization
and you're overriding the existing indexes of objects

00:43:36.539 --> 00:43:42.550
by evaluating specifier method, you'll probably
want to keep you know, just leave that override in.

00:43:42.550 --> 00:43:47.460
But in a bunch of other cases,
this will be the thing to override.

00:43:47.460 --> 00:43:51.269
The next thing is customizing object creation.

00:43:51.269 --> 00:43:58.739
This new method, new scripting object of class
forValueForKey with contents value properties is sent

00:43:58.739 --> 00:44:04.319
by NSCreateCommand to the future
container of an object being created.

00:44:04.320 --> 00:44:14.800
And after this method is invoked and returns a value,
that value is inserted into the container's relationship,

00:44:14.800 --> 00:44:18.140
identified by that key using regular key-value coding.

00:44:18.139 --> 00:44:23.639
So and we predict this will be good for
overriding and NSManagedObject subclasses.

00:44:23.639 --> 00:44:31.449
Because Cocoa scripting's default behavior is to take the
name of a class or take the class, the implementation class,

00:44:31.449 --> 00:44:38.799
send it in alec method, send it a simple init method
and then you know set contents and properties in it,

00:44:38.800 --> 00:44:42.720
stuff like that and that is not the
right thing to do in a core data app.

00:44:42.719 --> 00:44:49.489
In a core data app you're supposed to use NSManagedObject
init with entity description managed object context.

00:44:49.489 --> 00:44:51.919
So now overriding this is your opportunity to do that.

00:44:51.920 --> 00:44:56.970
And again, if you don't know what to do, you're
customization is not applicable, just invoke super

00:44:56.969 --> 00:45:01.989
and when I say not applicable by the way, as a
general rule when you're overriding key-value code

00:45:01.989 --> 00:45:08.809
or key-value coding style methods like this that take a key,
if you don't recognize the key, if it's not in a set of keys

00:45:08.809 --> 00:45:13.929
that you're customizing, just invoke super and
let the default implementation take care of it.

00:45:13.929 --> 00:45:20.869
In this NSManagedObject example for instance,
not all managed object properties are modeled.

00:45:20.869 --> 00:45:25.119
They might be added you know, by a property
or something like that or a category rather.

00:45:25.119 --> 00:45:34.079
Sorry. So then arguments that are passed to
this, well the first one is the object class.

00:45:34.079 --> 00:45:41.309
And you can ignore it if you don't need it, if you can
infer the class of object that needs instantiation just

00:45:41.309 --> 00:45:44.219
from the you know, the key that identifies relationship.

00:45:44.219 --> 00:45:46.089
But in other cases it is important.

00:45:46.090 --> 00:45:52.280
For example, in something simple like make
new circle at end of graphics in Sketch,

00:45:52.280 --> 00:45:58.790
the to-many relationship key is graphics,
but the class is SKT circle there.

00:45:58.789 --> 00:46:02.320
So very often that object class parameter is useful.

00:46:02.320 --> 00:46:11.269
The contents value and properties parameters correspond
pretty exactly to the make commands with contents

00:46:11.269 --> 00:46:17.880
or with the data still actually parameter
and the with properties parameters.

00:46:17.880 --> 00:46:23.829
So and contents value might be nil because that's an
optional argument to make and the properties dictionary,

00:46:23.829 --> 00:46:25.400
you don't have to worry about that being nil.

00:46:25.400 --> 00:46:31.260
You know, in Cocoa when we're following our own rules, we
don't pass around empty or nil instead of collections,

00:46:31.260 --> 00:46:37.290
we pass empty collections as in this case so.

00:46:37.289 --> 00:46:42.869
Another new method along the same lines,
you can also customize object duplication.

00:46:42.869 --> 00:46:50.429
So copy scripting value for key with properties and
this message might be sent by our default implementation

00:46:50.429 --> 00:46:55.549
of the clone command to the future
container of objects being copied.

00:46:55.550 --> 00:46:57.670
And it's the same sort of thing right.

00:46:57.670 --> 00:47:04.750
It's sent to the container and once it returns
it, it's inserted using regular key-value coding.

00:47:04.750 --> 00:47:10.469
So and this might eventually be used
by the set command also by the way.

00:47:10.469 --> 00:47:16.969
We've noticed a few cases where objects should
really be being copied more than they are.

00:47:16.969 --> 00:47:20.459
So that might, this might start being used there too.

00:47:20.460 --> 00:47:25.470
So and naming-wise again, value in the key-value
coding sense and what that means you know again,

00:47:25.469 --> 00:47:31.739
is that the correct type of the
value is inferable from the key.

00:47:31.739 --> 00:47:38.229
If the key identifies a to-many relationship,
you'll be passed an array of objects to be copied,

00:47:38.230 --> 00:47:42.019
might just be an array of one object,
but the important thing is that you know,

00:47:42.019 --> 00:47:46.360
in methods like this that are you know, meant
to be very flexible and particularly reusable,

00:47:46.360 --> 00:47:51.019
you know there has to be some convention that's easy to get.

00:47:51.019 --> 00:47:57.230
So in this case you know, if the key identifies a
to-many relationship you'll be passed an array.

00:47:57.230 --> 00:48:01.750
If the key identifies an attribute or a to-one
relationship, you know, an AppleScript property,

00:48:01.750 --> 00:48:05.090
then what'll be passed in is a single object.

00:48:05.090 --> 00:48:07.710
So those are the big ones.

00:48:07.710 --> 00:48:12.510
The rest of this is just a grab bag
of things we've, we've you know,

00:48:12.510 --> 00:48:15.260
you've asked for and you know, we've tried to respond to.

00:48:15.260 --> 00:48:17.050
First one is very simple.

00:48:17.050 --> 00:48:21.840
NSScriptClassDescription now has
an implementationClassName method.

00:48:21.840 --> 00:48:30.700
So just sending class name to a ClassDescription
in an app with .sdef declared scriptability,

00:48:30.699 --> 00:48:36.179
returns the human readable name of the class
because that's how they're keyed in .sdef files.

00:48:36.179 --> 00:48:45.759
So one thing you can use this for is if you're doing
your own customization of NSCreateCommand and you send,

00:48:45.760 --> 00:48:52.030
you send the create class description message to find out
what should be created, this is for like really you know,

00:48:52.030 --> 00:48:56.280
really heave customization otherwise you
use one of those methods I just showed you.

00:48:56.280 --> 00:49:00.600
You know, this is how you find out the name
of the Objective-C class to be allocated.

00:49:01.659 --> 00:49:08.799
More new things on NSScriptClassDescription, hasPropertyForKey,
hasOrderedToManyRelationshipsForKey,

00:49:08.800 --> 00:49:12.610
hasReadablePropertyForKey and
hasWritablePropertyForKey.

00:49:12.610 --> 00:49:15.240
If you customize heavily enough, you'll need some of these.

00:49:15.239 --> 00:49:24.339
For example, Cocoa's own default implementation of
scripting value for specifier uses these things.

00:49:24.340 --> 00:49:31.390
Like hasPropertyForKey and hasReadablePropertyForKey
and if you override it, you might have to invoke them also.

00:49:31.389 --> 00:49:35.210
And by the way, one reason we're getting
really good at error checking now,

00:49:35.210 --> 00:49:40.530
so who would ever have to ask hasPropertyForKey
like, shouldn't you have caught that already?

00:49:40.530 --> 00:49:45.000
Well there's a specific case, it's a popular
case though that we always let them go through.

00:49:45.000 --> 00:49:52.639
For example, when you, Sketch has a graphic
class, subclasses like text area and circle,

00:49:52.639 --> 00:49:56.690
you can ask a text area for it's contents.

00:49:56.690 --> 00:50:03.139
So but you don't always have to refer to text
areas as text areas, you can call them graphics.

00:50:03.139 --> 00:50:09.509
So if you ask for the text contents of
graphic one, something has to make sure

00:50:09.510 --> 00:50:15.410
that graphic one is actually a text area and not a
circle for instance, which wouldn't have text contents

00:50:15.409 --> 00:50:21.789
and that's what you know, a method
like this has property for key is for.

00:50:21.789 --> 00:50:26.789
For heavy customization of objects
placement, we've added a couple of accessories

00:50:26.789 --> 00:50:30.670
to NSPositionalSpecifier, like
position in objectSpecifier.

00:50:30.670 --> 00:50:33.789
These just match what's you know,
passed into the initializer

00:50:33.789 --> 00:50:37.409
when we create those from an AppleEventDescriptor.

00:50:37.409 --> 00:50:41.960
So typically if you're doing something with
NSPositionalSpecifier, you ask it to evaluate

00:50:41.960 --> 00:50:47.340
and then you get an insertion container, an insertion
key that identifies the to-many relationship

00:50:47.340 --> 00:50:52.490
and an insertion index that identifies where in that
too many relationship a new object should be put.

00:50:52.489 --> 00:50:57.009
So that should be good, you know good
enough 99% of the time.

00:50:57.010 --> 00:51:00.190
But there's not reason to keep these methods secret anyway.

00:51:00.190 --> 00:51:03.500
So now they're public.

00:51:03.500 --> 00:51:06.190
Taking control of object specifier life cycle.

00:51:06.190 --> 00:51:09.130
First thing is letting you create them.

00:51:09.130 --> 00:51:15.920
NSScriptObjectSpecifier now has a new class
method called ObjectSpecifierWithDescriptor.

00:51:15.920 --> 00:51:21.639
So if you have, if you have an NSScript command, a
current script command or one that's being executed

00:51:21.639 --> 00:51:27.059
and you've asked it for it's Apple event and you're
picking it around in there to get AppleEventDescriptors

00:51:27.059 --> 00:51:31.400
for specific parameters and things like
that and you want to get an object specifier

00:51:31.400 --> 00:51:34.610
but you still want to use Cocoa's object specifier evaluation,

00:51:34.610 --> 00:51:39.690
here's how you get from an AppleEventDescriptor
to an NSScriptObjectSpecifier.

00:51:39.690 --> 00:51:47.470
The other half is given an object specifier, give
me the AppleEventEescriptor that corresponds to it

00:51:47.469 --> 00:51:53.089
and the main reason you might want to do this is because
you're taking fine-grained control over error reporting.

00:51:53.090 --> 00:51:58.519
You're invoking this method and passing
it to the first method in this list.

00:51:58.519 --> 00:52:03.699
setScriptErrorOffendingObjectDescriptor
so and there's also a getter for that

00:52:03.699 --> 00:52:08.869
and there's setScriptErrorExpectedTypeDescriptor
and a getter for that.

00:52:08.869 --> 00:52:14.809
And what these are, if you know a bunch about apple events,
you know what flies back and forth between something

00:52:14.809 --> 00:52:20.730
like script editor that's running the AppleScript
interpreter and your application that's receiving you know,

00:52:20.730 --> 00:52:27.150
commands to do scriptable things, in the ReplyAppleEvent,
in addition to setting an error number,

00:52:27.150 --> 00:52:29.820
there's a couple other things you can set.

00:52:29.820 --> 00:52:36.670
Like an offending object descriptor, an expected type
descriptor and these are things that AppleScript

00:52:36.670 --> 00:52:43.119
or the open scripting architecture actually, these
are things that it uses to make good error messages.

00:52:43.119 --> 00:52:49.489
So these, these things end up getting converted
into text and inserted into the templates

00:52:49.489 --> 00:52:52.039
that correspond to those standard error numbers.

00:52:52.039 --> 00:52:58.059
So we of course, are using these all over the place
now in Cocoa itself and if you're doing you know,

00:52:58.059 --> 00:53:04.269
heavy customization and you know, you want to
continue the new tradition of good error reporting,

00:53:04.269 --> 00:53:08.009
you know Cocoa won't get in your way anymore.

00:53:08.010 --> 00:53:10.820
And to finish up, just some debugging tips.

00:53:10.820 --> 00:53:15.160
Keep your debugger console window open.

00:53:15.159 --> 00:53:24.519
Cocoa's own .sdef parser which gets run when your
application, for example receives an apple event

00:53:24.519 --> 00:53:32.780
that requires the Cocoa scripting machinery to handle,
you know when it parses that .sdef file lazily,

00:53:32.780 --> 00:53:36.650
it's pretty good about logging you
know, errors and also warnings.

00:53:36.650 --> 00:53:38.910
Like this type doesn't make any sense.

00:53:38.909 --> 00:53:42.519
You know, your XML file's syntactically
correct but it's still not going to work.

00:53:42.519 --> 00:53:45.539
So that kind of stuff shows up in the console.

00:53:45.539 --> 00:53:47.820
And also information about exceptions.

00:53:47.820 --> 00:53:55.170
When you're depending on key-value coding, you know, it's
easy to mistype, spell things wrong, stuff like that.

00:53:55.170 --> 00:53:56.599
But you know, we don't crash.

00:53:56.599 --> 00:54:00.900
Key-value coding you know, doesn't
crash much, it throws exceptions.

00:54:00.900 --> 00:54:04.190
And they're supposed to be really
informative to help you debug.

00:54:04.190 --> 00:54:08.960
So, so you want to make sure that
you actually see those exceptions.

00:54:08.960 --> 00:54:15.750
An easy way to do that is to leave you know, that
window open in Xcode while you're debugging.

00:54:15.750 --> 00:54:20.909
Another reason to leave the console window open is
to take advantage of Cocoa's pretty heavy logging.

00:54:20.909 --> 00:54:23.349
About every scriptable command as it's executed.

00:54:23.349 --> 00:54:25.940
So to turn this on, try something like this.

00:54:25.940 --> 00:54:33.110
Default's right and this example is for Sketch and there's a
typo there, it should not have .plist at the end of it.

00:54:33.110 --> 00:54:37.940
com.apple.CocoaExamples.Sketch
NSScriptingDebugLogLevel 1.

00:54:37.940 --> 00:54:40.070
Just turns on this feature in Sketch.

00:54:40.070 --> 00:54:46.460
Personally, because I work on Cocoa scripting and I want to
see everything that's going on in scripting on my machine.

00:54:46.460 --> 00:54:49.539
I discover a lot of bugs in other people's apps this way.

00:54:49.539 --> 00:54:52.599
Defaults write -g in a ScriptingDebugLogLevel.

00:54:52.599 --> 00:54:56.989
-g means you know, the global
domain for our user default system.

00:54:56.989 --> 00:55:00.279
So it just turns it on at every end.

00:55:01.320 --> 00:55:08.510
And in Cocoa, there's this, there's it's a little stronger
than a convention but, there's a method that lots

00:55:08.510 --> 00:55:16.000
of objects can implement called description and in
Cocoa scripting you know, NSScriptClassDescription,

00:55:16.000 --> 00:55:22.400
NSScriptCommandDescription, NSScriptSuiteRegistry,
all these things implement these description methods

00:55:22.400 --> 00:55:29.420
and what that means is that and what these
description methods return is an NSString that's meant

00:55:29.420 --> 00:55:30.740
to be informative to people.

00:55:30.739 --> 00:55:35.909
So what this means is that you can break anywhere
while debugging for example and just type this command

00:55:35.909 --> 00:55:41.609
in the debugger console, po [NSClassFromString
(@NSScriptSuiteRegistry) sharedScriptSuiteRegistry].

00:55:41.610 --> 00:55:49.039
You know, just invoke this public class method and
that will send a description message to the result

00:55:49.039 --> 00:55:52.469
and just a whole ton of stuff will appear
in your console and you can see everything

00:55:52.469 --> 00:55:55.259
that Cocoa thinks it found in your .sdef file.

00:55:55.260 --> 00:55:57.910
It's pretty handy.

00:55:57.909 --> 00:55:58.460
So that's it.

00:55:58.460 --> 00:56:02.780
There are many, many improvements to Cocoa
scripting in Leopard and what I want you

00:56:02.780 --> 00:56:06.130
to come away with is that switch to .sdef.

00:56:06.130 --> 00:56:10.670
If you haven't done that yet, it's,
it's, it's far easier to work with.

00:56:10.670 --> 00:56:16.820
It enables a little bit better error you
know, type checking in your application.

00:56:16.820 --> 00:56:22.519
There's better error checking all over Cocoa scripting,
but it's you know, it's better still in applications

00:56:22.519 --> 00:56:26.789
that declare their scriptability
with this .sdef file format.

00:56:26.789 --> 00:56:33.279
There's a bunch of new customization
opportunities for you, a new API and in Cocoa itself,

00:56:33.280 --> 00:56:36.269
the default behavior, a lot of things has gotten better.

00:56:36.269 --> 00:56:39.230
Especially in the realm of error reporting.

00:56:39.230 --> 00:56:45.460
So for more information send an email to
Deric Horn, derrick@apple.com

00:56:45.460 --> 00:56:49.059
or to Matt Drance, mdrance@apple.com.

00:56:49.059 --> 00:56:53.480
As far as documentation goes, you should
always start out, if you're new to scripting

00:56:53.480 --> 00:56:58.510
with reading Technical Note TN2106
and that is! what you have to type

00:56:58.510 --> 00:57:02.720
into developer.apple.com
search field, if you want to get anywhere.

00:57:02.719 --> 00:57:06.149
TN2106. That's the Scripting Interface Guidelines.

00:57:06.150 --> 00:57:10.170
They tell you, you know, what to do, to do it right.

00:57:10.170 --> 00:57:19.119
The Cocoa Scripting Guide which was updated about a
pretty comprehensively about a year ago still only,

00:57:19.119 --> 00:57:22.489
is where to go for all this stuff about Cocoa scripting.

00:57:22.489 --> 00:57:26.779
Foundation Release Notes is where
we leave the newest information.

00:57:26.780 --> 00:57:33.320
The ones for Leopard describe many, many
things, including you know, a lot of bug fixes

00:57:33.320 --> 00:57:35.760
and stuff like that that I haven't talked about here today.

00:57:35.760 --> 00:57:37.460
And have a look at the Sketch sample code.

00:57:37.460 --> 00:57:40.130
You know, that's what we keep working on.

00:57:40.130 --> 00:57:44.320
That's like, it's not just sample code, it's also
what we test with as we add these new features.

00:57:44.320 --> 00:57:46.220
We make Sketch take advantage of it.

00:57:46.219 --> 00:57:47.819
That's how we know it worked so.
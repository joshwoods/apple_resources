WEBVTT

00:00:15.740 --> 00:00:19.600
This is session 104, Getting Started with
Mac OS X Kernel Programming.

00:00:19.600 --> 00:00:20.600
My name is Nik Gervae.

00:00:20.600 --> 00:00:23.590
I'm a software engineer
with the I/O Kit team.

00:00:24.270 --> 00:00:27.740
Today we're going to be covering the
basics of programming for the kernel.

00:00:27.820 --> 00:00:32.190
That includes packaging your code,
installing as well as runtime

00:00:32.190 --> 00:00:34.800
considerations in the kernel environment.

00:00:34.880 --> 00:00:36.730
Following that,
we're going to get into the kernel

00:00:36.730 --> 00:00:41.500
programming interfaces themselves,
starting with drivers using the I/O Kit,

00:00:41.540 --> 00:00:45.380
and then we'll cover file system
plugins and network kernel extensions.

00:00:46.900 --> 00:00:49.970
This first part, as mentioned,
is developing for the kernel.

00:00:50.070 --> 00:00:51.780
Now, we know there are a lot
of sessions at WWDC,

00:00:51.780 --> 00:00:54.180
so we want to get things
out of the way right away,

00:00:54.220 --> 00:00:56.080
in case there's someplace
else you'd rather be,

00:00:56.150 --> 00:00:58.510
and ask, "Do you need to be here?"

00:01:00.200 --> 00:01:03.220
This is largely because kernel
code runs without the protections

00:01:03.220 --> 00:01:04.820
afforded to user space programs.

00:01:04.900 --> 00:01:08.100
A single mistake can bring the
whole OS down or hang the machine.

00:01:08.100 --> 00:01:10.920
So with that in mind,
we've made a lot of things possible

00:01:10.920 --> 00:01:14.100
from user space that you might
think require kernel access.

00:01:14.100 --> 00:01:16.480
Printer, scanner, and camera drivers,
for example,

00:01:16.690 --> 00:01:18.100
are accessible from applications.

00:01:18.100 --> 00:01:22.100
And a lot of other kernel services,
such as a lot of USB devices,

00:01:22.100 --> 00:01:24.100
are available from user space.

00:01:24.100 --> 00:01:26.880
If you're curious about that,
you can check out documentation

00:01:26.880 --> 00:01:28.100
on the I/O Kit.framework.

00:01:28.100 --> 00:01:32.860
That is a framework that applications
can use to connect to devices.

00:01:33.020 --> 00:01:35.200
We want to stress that you should
check user space facilities

00:01:35.250 --> 00:01:37.370
before resorting to kernel code.

00:01:37.370 --> 00:01:40.960
And do note that running in the kernel
does not make your code run faster.

00:01:41.000 --> 00:01:43.870
That is not really a good
reason to run in the kernel.

00:01:44.430 --> 00:01:48.060
Considering that,
what does typically require kernel code?

00:01:48.220 --> 00:01:51.600
First off is device drivers that
need register access to hardware

00:01:51.600 --> 00:01:53.930
or that need to handle interrupts.

00:01:54.070 --> 00:01:57.030
And more significantly,
drivers that have clients in the kernel,

00:01:57.030 --> 00:01:58.690
of course,
need to run in the kernel so that

00:01:58.690 --> 00:02:00.140
they can communicate directly.

00:02:00.290 --> 00:02:04.010
Also, most file system plugins,
kernel authorization plugins,

00:02:04.010 --> 00:02:07.720
and network stack filters need
to be packaged as kernel code.

00:02:10.530 --> 00:02:13.000
The form of that packaging is a bundle.

00:02:13.020 --> 00:02:15.820
If you're not familiar with that,
it's a scheme we use on Mac OS X to

00:02:15.820 --> 00:02:18.910
package resources together
under a directory that's treated

00:02:18.910 --> 00:02:20.400
in the UI as a single file.

00:02:20.400 --> 00:02:22.400
So a kernel extension is just a folder.

00:02:22.470 --> 00:02:26.240
It's a bundle with a KEXT extension
containing at minimum a

00:02:26.240 --> 00:02:30.590
relocatable object file,
in this case, my driver,

00:02:30.590 --> 00:02:36.400
and an XML file called Info.plist that
contains the bundle's identifier,

00:02:36.400 --> 00:02:40.400
its version, dependencies,
which we'll be covering shortly,

00:02:40.400 --> 00:02:43.500
and whatever other information
might be needed for the

00:02:43.510 --> 00:02:45.390
subtype of kernel extension.

00:02:45.400 --> 00:02:49.540
Xcode makes it easy for you to create
those subtypes with I/O Kit driver and

00:02:49.540 --> 00:02:52.190
generic kernel extension project types.

00:02:55.300 --> 00:02:57.970
The process of loading a kernel,
because the kernel extension

00:02:57.970 --> 00:03:01.440
is basically just a .o file,
we're going to do a static link

00:03:01.460 --> 00:03:04.200
and copy it into the kernel's
address space and start it running.

00:03:04.380 --> 00:03:05.700
This is how it looks.

00:03:05.700 --> 00:03:07.750
In this scenario,
we have the Mach kernel running

00:03:07.930 --> 00:03:11.200
and some other KEXTs already
loaded and running in the kernel.

00:03:11.200 --> 00:03:13.120
Your driver is sitting on
disk and we want to load it.

00:03:13.230 --> 00:03:17.200
So we're going to run the KEXT loader,
which reads that KEXT in that Info.plist,

00:03:17.200 --> 00:03:20.600
which contains the library IDs.

00:03:21.110 --> 00:03:24.520
Using those library IDs, it looks up the
dependencies of that KEXT,

00:03:24.540 --> 00:03:27.400
in this case,
the kernel itself and the library KEXT.

00:03:27.560 --> 00:03:29.450
Once it knows those,
it figures out where they're loaded in

00:03:29.450 --> 00:03:32.320
the kernel so it can do the relocation.

00:03:32.600 --> 00:03:36.930
does it right there,
copies the image into the kernel,

00:03:36.930 --> 00:03:41.010
and then invokes a start routine so
that the Kix can start doing its job.

00:03:43.780 --> 00:03:45.420
Now,
the dependencies that I mentioned earlier

00:03:45.720 --> 00:03:48.280
are declared with OS bundle libraries.

00:03:48.390 --> 00:03:51.170
This is just an XML property
whose keys are bundle IDs and

00:03:51.170 --> 00:03:54.800
values are the versions needed,
as you can see on the bottom there.

00:03:54.930 --> 00:03:56.870
There are two general
kinds of dependencies.

00:03:56.970 --> 00:03:58.600
As far as you're concerned,
they're the same thing.

00:03:58.600 --> 00:04:00.100
You declare them the same way.

00:04:00.250 --> 00:04:03.900
The built-in KPIs are parts of the
kernel that have their own linkage,

00:04:03.990 --> 00:04:04.800
and then there are libraries.

00:04:04.800 --> 00:04:09.500
You can actually load other kernel
extensions at load time as libraries.

00:04:09.610 --> 00:04:11.610
There's a new program in
Leopard called kextlibs,

00:04:11.780 --> 00:04:14.190
so when you build your KEXT,
because all of this stuff

00:04:14.200 --> 00:04:17.240
is handled at load time,
this will tell you what you

00:04:17.240 --> 00:04:20.690
need to declare in your PList
because it isn't done in Xcode.

00:04:21.990 --> 00:04:24.880
The interfaces I mentioned,
there are four of them.

00:04:24.990 --> 00:04:27.020
First is the Mach KPI.

00:04:27.350 --> 00:04:29.740
These are the lowest
level kernel interfaces.

00:04:30.060 --> 00:04:31.840
Above that we have Libkern.

00:04:31.890 --> 00:04:34.240
Those are utilities for
memories and strings,

00:04:34.300 --> 00:04:38.540
atomic operations,
and C++ classes for I/O Kit drivers.

00:04:38.540 --> 00:04:40.630
Above that there are two more KPIs.

00:04:40.710 --> 00:04:41.480
One is BSD.

00:04:41.480 --> 00:04:44.480
This covers interfaces
related to the BSD kernel,

00:04:44.480 --> 00:04:46.900
such as networking and file systems.

00:04:47.080 --> 00:04:50.300
And then I/O Kit is the core
I/O Kit interfaces and classes.

00:04:50.300 --> 00:04:52.580
Now, I/O Kit is really big,
as you're going to find

00:04:52.630 --> 00:04:53.440
out in a little bit.

00:04:53.830 --> 00:04:56.830
So we break out a lot of its
functionality into libraries

00:04:56.830 --> 00:05:00.140
called families that provide
additional interfaces.

00:05:00.200 --> 00:05:05.090
All of these headers are in the kernel
framework under the header subdirectory.

00:05:05.370 --> 00:05:08.690
This is the only framework
that kernel extensions can use,

00:05:08.700 --> 00:05:11.750
and it's only available
to kernel extensions.

00:05:13.060 --> 00:05:15.760
Now, you may be asking,
why are we breaking up the

00:05:15.760 --> 00:05:17.530
kernel into these subdivisions?

00:05:17.790 --> 00:05:19.870
Why not just link to the whole kernel?

00:05:19.970 --> 00:05:22.960
The way we do versioning
kind of dictates that.

00:05:23.160 --> 00:05:26.000
The Mac OS X kernel is really
big and it has a lot of symbols.

00:05:26.000 --> 00:05:29.270
So if you declare your dependency
on the kernel and some symbol

00:05:29.270 --> 00:05:32.970
you're not even using changes,
then your KEXT could fail to load.

00:05:33.000 --> 00:05:35.000
These subsystems do change
from release-to-release.

00:05:35.000 --> 00:05:39.470
The KPI lets you limit that linkage so
that if you're doing a generic KEXT,

00:05:39.470 --> 00:05:43.390
it won't be affected by changes
to the I/O Kit and vice versa.

00:05:46.340 --> 00:05:49.720
I mentioned a startup routine that gets
called earlier in the kextload slide.

00:05:49.820 --> 00:05:53.300
Every KEXT has a startup
function and a shutdown function.

00:05:53.440 --> 00:05:55.290
The I/O Kit gives you these
for free with drivers,

00:05:55.290 --> 00:05:57.240
but generic KEXTs have to implement them.

00:05:57.300 --> 00:06:00.300
When you create your generic KEXT,
Xcode creates placeholders

00:06:00.300 --> 00:06:03.300
and you can just fill in the
code that you need to do.

00:06:03.300 --> 00:06:06.390
These functions are called automatically
when your KEXT is loaded or unloaded,

00:06:06.400 --> 00:06:08.300
and this is where you do
your setup and teardown.

00:06:08.300 --> 00:06:11.270
You register and deregister with
whatever facilities you need,

00:06:11.380 --> 00:06:13.300
create and destroy
your dynamic resources,

00:06:13.300 --> 00:06:16.300
as well as threads for any active
processing you might be doing.

00:06:16.390 --> 00:06:18.300
It's important that these
functions do not block.

00:06:18.300 --> 00:06:22.300
You shouldn't go into a loop
expecting to do long-term work here.

00:06:22.300 --> 00:06:25.290
If you're not going to be doing
active thread processing in your KEXT,

00:06:25.290 --> 00:06:27.300
it can serve as a
library for other KEXTs.

00:06:27.300 --> 00:06:30.130
You can just create a function package.

00:06:31.780 --> 00:06:35.440
The loaders I mentioned,
there's two of them on Mac OS X.

00:06:35.560 --> 00:06:37.840
First is the kernel extension server,
kexty.

00:06:38.060 --> 00:06:42.100
This handles demand loading of
drivers as requested by the kernel,

00:06:42.210 --> 00:06:46.600
basically for I/O Kit drivers in the
system library extensions folder.

00:06:46.770 --> 00:06:48.600
The other program is called kextload.

00:06:48.600 --> 00:06:51.510
This is for explicit loading by
user space facilities and developers

00:06:51.790 --> 00:06:53.500
while you're working on your KEXTs.

00:06:53.580 --> 00:06:56.600
It handles generic kernel extensions
no matter where they're installed,

00:06:56.600 --> 00:07:00.600
as well as I/O Kit drivers that are
not in the system extensions folder.

00:07:00.600 --> 00:07:01.600
The next one is kextload.

00:07:01.600 --> 00:07:04.600
kextload has a lot of development
and debugging options.

00:07:04.810 --> 00:07:07.580
You're going to be using
-t and -n probably a lot,

00:07:07.600 --> 00:07:09.460
because if it fails to load your KEXT,
it's going to print out

00:07:09.530 --> 00:07:10.600
a terse little message.

00:07:10.950 --> 00:07:13.680
These options together
mean test without loading,

00:07:13.890 --> 00:07:16.780
and they will tell you
what's wrong with your KEXT.

00:07:18.620 --> 00:07:23.120
Now, once you've finished developing and
debugging your kernel extension,

00:07:23.140 --> 00:07:25.160
you're going to want to install it,
probably in the system

00:07:25.160 --> 00:07:26.600
library extensions folder.

00:07:26.650 --> 00:07:29.640
Because these things run in the kernel,
you want to make sure that they can't

00:07:29.640 --> 00:07:31.240
be scribbled on by any old user.

00:07:31.420 --> 00:07:35.180
So they need to be owned by the
super user root in group wheel,

00:07:35.180 --> 00:07:37.640
and they have to have their
permissions closed so that they're

00:07:37.640 --> 00:07:39.830
not writable by group or other.

00:07:40.150 --> 00:07:43.440
Again, when you install them,
you want them atomically written

00:07:43.450 --> 00:07:46.170
so that partial keks don't
get loaded into the kernel.

00:07:46.300 --> 00:07:49.860
So copy them to a temporary directory,
change the owner group and permissions,

00:07:49.890 --> 00:07:52.600
and then move them into the
destination folder when you're done.

00:07:52.620 --> 00:07:54.710
Once you've done that,
you can reset the keks system.

00:07:54.960 --> 00:07:57.540
This is particularly important
for drivers so that they can

00:07:57.570 --> 00:07:58.640
get loaded automatically.

00:07:58.670 --> 00:08:02.330
You'll run touch on the extensions folder
to update it and invalidate any caches,

00:08:02.330 --> 00:08:04.460
and then send a HUP signal,
hang up signal,

00:08:04.470 --> 00:08:06.620
to the kernel extension server keksd.

00:08:06.800 --> 00:08:08.990
This is required on
Mac OS X 10.3 and later.

00:08:09.140 --> 00:08:12.670
On early releases, you need to force a
restart of the system.

00:08:14.990 --> 00:08:17.800
Here's a list of the tools that you
might use while developing a KEXT.

00:08:17.880 --> 00:08:21.700
First are the kextload program and
then the counterpart kextunload,

00:08:21.740 --> 00:08:24.880
the kernel extension server kexty,
and then some others that

00:08:24.900 --> 00:08:25.760
you might find helpful.

00:08:25.840 --> 00:08:30.830
kextstat lists the kernel extensions
that are currently running in the kernel.

00:08:30.940 --> 00:08:33.120
kextlibs, mentioned earlier,
lists the libraries you

00:08:33.120 --> 00:08:34.150
need to load your KEXT.

00:08:34.310 --> 00:08:35.940
If you make any changes,
you might want to run that

00:08:35.950 --> 00:08:36.680
again just to be sure.

00:08:36.900 --> 00:08:48.610
And then kextfind is a utility.

00:08:48.610 --> 00:08:48.620
If you need to look up some KEXT,
say something that exports a

00:08:48.620 --> 00:08:48.620
particular symbol or depends on a
particular symbol or has problems,

00:08:48.620 --> 00:08:48.620
you can use that.

00:08:48.620 --> 00:08:48.620
It's kind of like find
for kernel extensions.

00:08:50.320 --> 00:08:54.190
Now we're going to get into what it's
like to programming in the kernel.

00:08:54.300 --> 00:08:58.790
You have to remember that the kernel is
the longest running process in Mac OS X,

00:08:58.790 --> 00:09:00.800
and your keks may be
running nearly as long.

00:09:00.800 --> 00:09:03.080
It might get loaded as soon as
the machine starts up and not get

00:09:03.080 --> 00:09:04.690
unloaded until the machine shuts down.

00:09:04.690 --> 00:09:07.000
So it's really important not to leak.

00:09:07.170 --> 00:09:10.200
Also, any memory you allocate
is wired by default.

00:09:10.290 --> 00:09:13.010
This means it can't be paged to disk,
and it's not available

00:09:13.010 --> 00:09:14.300
to user applications.

00:09:14.490 --> 00:09:17.400
There's also limited
stack space in the kernel.

00:09:17.460 --> 00:09:19.100
When you're programming,
you have to keep that in mind.

00:09:19.100 --> 00:09:22.230
So don't allocate any
1K buffers on the stack,

00:09:22.360 --> 00:09:24.200
and avoid recursion if you can.

00:09:24.320 --> 00:09:26.700
And if you have to use it,
keep it limited.

00:09:26.990 --> 00:09:30.400
There are no floating point or
vector facilities in the kernel.

00:09:30.400 --> 00:09:32.390
Libc-style support is incomplete.

00:09:32.400 --> 00:09:34.700
It's there, but it's pretty minimal.

00:09:34.920 --> 00:09:36.400
And there's no file I/O.

00:09:36.600 --> 00:09:39.190
Finally, debugging is more complicated
than for user programs.

00:09:39.190 --> 00:09:43.190
There's a session in this room after this
one you might want to stick around for.

00:09:45.000 --> 00:09:50.010
Texts within the kernel run within the
kernel's 32-bit virtual address space.

00:09:50.070 --> 00:09:52.470
There's no sandboxing or virtual
address space protection,

00:09:52.510 --> 00:09:56.820
so if you dereference a null pointer
or go into a loop or hit a deadlock,

00:09:57.160 --> 00:10:00.020
you're going to panic or
hang the whole user system.

00:10:00.020 --> 00:10:03.120
All code running within the
kernel is inherently trusted.

00:10:03.160 --> 00:10:05.280
This means it can do pretty
much whatever it wants,

00:10:05.280 --> 00:10:07.150
so be careful of that.

00:10:07.350 --> 00:10:09.840
Again, if you can't implement
your feature in user space,

00:10:09.840 --> 00:10:11.680
please do so.

00:10:12.770 --> 00:10:15.200
For more information on
kernel extensions in general,

00:10:15.320 --> 00:10:18.420
you can contact Craig Keithley,
our IO technology evangelist,

00:10:18.490 --> 00:10:22.850
and check out the WWDC website
for some documentation.

00:10:22.980 --> 00:10:25.440
The specific titles you want to look for
if you're getting started are Accessing

00:10:25.440 --> 00:10:28.760
Hardware from Applications to find out
if you need to write a kernel extension,

00:10:28.850 --> 00:10:31.870
and then the Kernel Programming
Guide and Kernel Extension Concepts,

00:10:31.870 --> 00:10:34.650
which has some really good tutorials
to get you started on writing a generic

00:10:34.650 --> 00:10:39.350
kernel extension with Hello Kernel or
an I/O Kit driver with Hello I/O Kit.

00:10:42.380 --> 00:10:45.220
There's also a lab today
on kernel debugging.

00:10:45.320 --> 00:10:47.410
You might want to check that one out.

00:10:48.810 --> 00:10:51.300
Now we're going to cover the I/O Kit.

00:10:51.410 --> 00:10:54.010
The I/O kit's really big,
so I'm going to give you a

00:10:54.020 --> 00:10:58.160
view from about 10,000 feet,
and you'll probably want to dig into

00:10:58.170 --> 00:11:00.650
the documentation more to learn,
but let's get started with some of the

00:11:00.650 --> 00:11:04.820
basic concepts that you're going to need
to know to understand how things work.

00:11:04.930 --> 00:11:08.300
First off,
the I/O Kit is an object-oriented

00:11:08.300 --> 00:11:10.400
driver model that we use in Mac OS X.

00:11:10.400 --> 00:11:14.900
It's a pretty large set of C++ utility
classes and driver superclasses.

00:11:14.900 --> 00:11:18.440
And much like Cocoa and UserSpace,
this is a framework.

00:11:18.440 --> 00:11:22.460
This means we implement general
driver functionality already for you.

00:11:22.460 --> 00:11:24.460
We've got a set of design
patterns that we use,

00:11:24.460 --> 00:11:26.960
and your driver will fill in the
hardware-specific details within

00:11:26.970 --> 00:11:29.860
those patterns by overriding
established superclass methods to

00:11:29.860 --> 00:11:34.200
do output or input or registering
callbacks for the same purpose.

00:11:34.200 --> 00:11:37.470
The I/O Kit system will call
on your driver to control

00:11:37.470 --> 00:11:39.450
its device and perform I/O.

00:11:41.290 --> 00:11:44.380
As I mentioned,
I/O Kit is implemented in C++,

00:11:44.380 --> 00:11:47.080
but it's a limited subset because
it is running within a kernel.

00:11:47.200 --> 00:11:48.540
This means we can't do exceptions.

00:11:48.610 --> 00:11:50.770
You don't know what thread
your code might be running on,

00:11:50.770 --> 00:11:51.380
actually.

00:11:51.530 --> 00:11:53.940
There's no multiple inheritance.

00:11:53.940 --> 00:11:55.870
The standard RTTI is not included.

00:11:56.060 --> 00:12:00.140
We have one that we have developed
for use within the kernel environment.

00:12:00.300 --> 00:12:02.420
There's also no standard
template library,

00:12:02.470 --> 00:12:06.570
and although we don't use templates,
you can use them in private C++ code.

00:12:06.660 --> 00:12:09.800
You just can't use them in
any of your I/O Kit classes.

00:12:11.880 --> 00:12:17.180
Now, the I/O Kit defines a class
hierarchy much like Cocoa does.

00:12:17.180 --> 00:12:20.230
We have OS object as they have NS object.

00:12:20.330 --> 00:12:22.620
This is the class that provides
all of the basic functionality

00:12:22.930 --> 00:12:27.520
needed to play with I/O Kit objects,
including dynamic typing, introspection,

00:12:27.610 --> 00:12:29.600
reference counting, and lifecycle.

00:12:29.670 --> 00:12:32.690
Any class that you implement as a
subclass of a driver superclass,

00:12:32.750 --> 00:12:35.600
for example,
is going to inherit from OS object.

00:12:35.600 --> 00:12:39.990
If you have a C++ library that is
for use within a kernel environment,

00:12:40.000 --> 00:12:43.550
you can use those privately,
but you can't interface with

00:12:43.550 --> 00:12:45.200
the I/O Kit using those.

00:12:45.310 --> 00:12:48.000
There are also some container and
collection classes from Libkern:

00:12:48.050 --> 00:12:52.200
wrappers for numbers, Boolean values,
data buffers and strings,

00:12:52.200 --> 00:12:58.190
as well as collections
indexed sets and dictionaries.

00:12:59.910 --> 00:13:02.860
Now, we're going to get into
the I/O Kit proper with

00:13:02.860 --> 00:13:06.600
the central superclass that
every driver inherits from.

00:13:06.600 --> 00:13:07.780
It's called I/O Service.

00:13:07.780 --> 00:13:11.190
And this implements the bulk of
general I/O Kit functionality.

00:13:11.220 --> 00:13:13.450
There are basically three kinds
of classes in I/O Kit that

00:13:13.450 --> 00:13:14.520
you're going to work with.

00:13:14.670 --> 00:13:18.090
There's this one, there are the generic
device class superclasses,

00:13:18.120 --> 00:13:20.800
and then there's going to
be your specific class.

00:13:20.800 --> 00:13:22.800
So I/O Service is the root of this.

00:13:22.800 --> 00:13:27.000
And it handles the general functions
of driver lifecycle from matching

00:13:27.000 --> 00:13:30.480
and startup of your driver to tear
down when the device is removed.

00:13:30.550 --> 00:13:34.760
And it also handles automatic
unloading of your KEXT when you

00:13:34.760 --> 00:13:37.360
have no more instances outstanding.

00:13:37.730 --> 00:13:40.900
iOS Service also handles the
general principles of power

00:13:40.900 --> 00:13:43.420
management and access control.

00:13:44.940 --> 00:13:47.390
Below that,
there are a number of families

00:13:47.480 --> 00:13:52.320
that implement generic features
of a bus or device class.

00:13:52.460 --> 00:13:57.530
Families define superclasses such
as IO Ethernet Controller that

00:13:57.860 --> 00:14:01.350
provide the general features of
that class and the abstract methods

00:14:01.360 --> 00:14:02.800
that you're going to be overriding.

00:14:02.950 --> 00:14:04.860
Your driver,
if you have an Ethernet card,

00:14:04.860 --> 00:14:07.000
for example,
you would subclass IO Ethernet

00:14:07.000 --> 00:14:10.090
Controller and implement just the
methods that you need to handle

00:14:10.090 --> 00:14:11.730
IO and device configuration.

00:14:11.800 --> 00:14:15.080
These families are implemented as library
kecks so that if they're not needed,

00:14:15.080 --> 00:14:18.700
they won't be consuming wired memory,
and their headers are in kernel

00:14:18.700 --> 00:14:20.790
framework headers sub-IO kit.

00:14:21.050 --> 00:14:23.880
Down on the bottom there,
you can see a list of the families

00:14:23.880 --> 00:14:25.800
we have available on our system.

00:14:25.800 --> 00:14:28.800
They cover basically any device or
bus that you might see in a Mac.

00:14:31.330 --> 00:14:34.450
Now we're going to get into some
of the actual design patterns

00:14:34.460 --> 00:14:37.660
that we use down at the level
you're going to be working with.

00:14:37.720 --> 00:14:41.220
The first is a distinction
between subclasses of I/O service.

00:14:41.310 --> 00:14:45.690
There are two kinds, and we call this the
device driver pattern.

00:14:45.740 --> 00:14:49.210
The first type of object that gets
created when a device is discovered

00:14:49.220 --> 00:14:52.240
is called a device object or a nub.

00:14:52.360 --> 00:14:54.060
These are completely generic objects.

00:14:54.270 --> 00:14:56.740
They represent the baseline
services for a given bus.

00:14:56.850 --> 00:15:01.120
For example, I/O PCI device knows that
there's a PCI card in that slot.

00:15:01.310 --> 00:15:02.940
It knows nothing else.

00:15:03.230 --> 00:15:06.070
They give access to
that bus to find info,

00:15:06.070 --> 00:15:09.150
and they provide access to
I/O operations using memory map

00:15:09.230 --> 00:15:11.630
registers or whatever that bus provides.

00:15:11.960 --> 00:15:15.440
These are typically created by
bus drivers as they scan the bus

00:15:15.670 --> 00:15:19.630
to represent those devices in a
completely generic manner so that we

00:15:19.720 --> 00:15:22.020
can discover what driver is needed.

00:15:22.050 --> 00:15:24.160
You typically don't subclass these.

00:15:24.200 --> 00:15:28.180
But once we find out what is needed,
we load your driver,

00:15:28.190 --> 00:15:30.060
and that's the driver subclass.

00:15:30.070 --> 00:15:32.820
These provide hardware and
I/O control for a specific device.

00:15:32.890 --> 00:15:36.640
So this is what would know that
that PCI device is actually

00:15:36.640 --> 00:15:38.280
an Ethernet controller,
for example.

00:15:38.500 --> 00:15:41.340
The abstract family classes provide
the structure that you would use,

00:15:41.360 --> 00:15:45.180
and then your driver subclass handles
the details of the specific device,

00:15:45.180 --> 00:15:47.280
for example, my Ethernet controller.

00:15:47.320 --> 00:15:51.000
These are attached to the
nub via programmatic link,

00:15:51.020 --> 00:15:54.750
and then it uses that nub as its
bus connection to do its I/O.

00:15:55.810 --> 00:15:58.830
Here's what the big picture looks like.

00:15:58.900 --> 00:16:03.310
You can see the nub right-- oops,
hang on.

00:16:03.870 --> 00:16:06.430
Right here, that's the IOPCI device.

00:16:06.760 --> 00:16:09.940
In this scenario,
the main logic board driver has

00:16:09.940 --> 00:16:14.380
a number of drivers leading up
to the PCI driver down here.

00:16:15.040 --> 00:16:17.760
And it scans the bus and finds
out there's a card in slot 2,

00:16:17.780 --> 00:16:20.180
so it creates an IO PCI device.

00:16:20.180 --> 00:16:24.000
The I/O Kit then figures out
from the PCI configuration

00:16:24.000 --> 00:16:26.610
space what drivers are needed,
and for that one we need

00:16:26.610 --> 00:16:27.940
my Ethernet controller.

00:16:27.940 --> 00:16:31.920
So it creates an instance of your driver
and attaches it onto that PCI device.

00:16:32.210 --> 00:16:35.890
Your Ethernet controller would
then publish an IO Ethernet

00:16:35.890 --> 00:16:38.750
interface device or nub object,
which then talks to the

00:16:38.750 --> 00:16:42.260
BSD networking stack,
which is outside of the scope of I/O Kit.

00:16:42.260 --> 00:16:45.790
So as you can see,
IO service objects form a chain

00:16:45.990 --> 00:16:48.650
going from the platform driver,
the logic board driver,

00:16:48.750 --> 00:16:51.910
up to whatever other facility in
the kernel might be using them.

00:16:52.030 --> 00:16:55.010
In this scenario,
my Ethernet controller is

00:16:55.010 --> 00:16:59.000
a client of the PCI device,
and this is the provider-client pattern.

00:16:59.000 --> 00:17:02.200
And IO PCI device is a provider
to my Ethernet controller.

00:17:02.270 --> 00:17:06.080
Basically, provider links go up and
client links go down.

00:17:06.330 --> 00:17:08.970
As you can also see from this diagram,
most of these links

00:17:08.970 --> 00:17:10.540
alternate between devices.

00:17:10.580 --> 00:17:12.210
So if you have a driver
and device objects,

00:17:12.210 --> 00:17:16.040
this isn't always the case,
but it's pretty commonly the case.

00:17:16.040 --> 00:17:21.160
Every IO service running in the kernel
is connected in this way in a big graph

00:17:21.160 --> 00:17:23.610
of objects that we call the IO registry.

00:17:23.700 --> 00:17:26.700
And it's not like that other registry,
so don't worry.

00:17:27.290 --> 00:17:30.080
As I mentioned, this is a graph of all
I/O service objects in the kernel,

00:17:30.180 --> 00:17:32.330
basically running drivers.

00:17:32.450 --> 00:17:36.300
Each object has properties that show
the driver's inheritance and state.

00:17:36.570 --> 00:17:40.280
Most of them are derived from the
plist of the KEXT when it got loaded.

00:17:40.400 --> 00:17:43.390
It can be added or modified
to by registry objects,

00:17:43.490 --> 00:17:45.570
including other drivers,
and they contain a lot of

00:17:45.570 --> 00:17:48.220
useful diagnostic information
that you might want to use,

00:17:48.290 --> 00:17:51.360
whether you're reading it from
kernel space or user space.

00:17:51.360 --> 00:17:54.200
In fact, you can use the
I/O registry explorer.app,

00:17:54.250 --> 00:17:57.050
which is rewritten in Leopard,
or the ioReg command line tool

00:17:57.120 --> 00:17:59.390
to see what's in the registry.

00:18:00.250 --> 00:18:03.440
You could learn a lot about the
I/O Kit just exploring the registry.

00:18:03.440 --> 00:18:05.460
If you go fish around in there,
you're going to see a

00:18:05.460 --> 00:18:06.980
lot of interesting stuff.

00:18:08.880 --> 00:18:11.050
Getting outside of the
driver classes themselves,

00:18:11.110 --> 00:18:14.700
we've got some support classes to help
you do the I/O that you want to do.

00:18:14.840 --> 00:18:16.680
First is a group of
memory management classes,

00:18:16.700 --> 00:18:19.520
among them I/O Memory Descriptor
and I/O DMA Command.

00:18:20.080 --> 00:18:22.180
There's also I/O Buffering
Memory Descriptor for

00:18:22.180 --> 00:18:23.700
allocating long-term buffers.

00:18:23.900 --> 00:18:27.310
The main memory management classes
give you structured access to

00:18:27.310 --> 00:18:30.520
the memory at various levels
and in device memory as well.

00:18:30.920 --> 00:18:33.600
They do address-based translation
from user data buffers and handle

00:18:34.080 --> 00:18:37.860
scatter-gather operations as well,
collecting individual smaller buffers

00:18:37.870 --> 00:18:39.620
into one larger I/O operation.

00:18:39.700 --> 00:18:42.150
For synchronization,
and this is pretty important,

00:18:42.150 --> 00:18:45.060
so I'm going to emphasize this,
we have a paradigm that you're

00:18:45.170 --> 00:18:46.700
going to want to work within.

00:18:46.700 --> 00:18:49.230
Much like in user space,
we have CFRN loop,

00:18:49.430 --> 00:18:53.930
in I/O Kit we have I/O Work Loop and
also I/O Event Sources for interrupts,

00:18:53.930 --> 00:18:57.700
timers, and commands,
which are client output requests.

00:18:57.700 --> 00:18:59.700
These handle serialization
of I/O operations.

00:18:59.700 --> 00:19:06.660
They're a key part of the I/O Kit model,
unlike a lot of other OS driver models.

00:19:06.700 --> 00:19:09.500
You really want to avoid rolling
your own or trying to get some

00:19:09.500 --> 00:19:13.800
other locking scheme from an
existing driver working within this,

00:19:13.800 --> 00:19:16.670
because if you try,
you're probably going to get a deadlock.

00:19:16.700 --> 00:19:17.810
So, let's talk about the I/O Kit.

00:19:18.630 --> 00:19:24.740
That said, I want to show you how simple
I/O can be in the abstract here.

00:19:24.870 --> 00:19:27.450
As I mentioned before,
you really just have to subclass

00:19:27.740 --> 00:19:31.270
and override a method to do your
output and register an event

00:19:31.270 --> 00:19:33.040
source to handle your input.

00:19:33.290 --> 00:19:37.350
So when your driver gets created,
you're going to register an event source

00:19:37.350 --> 00:19:41.100
or two or three or however many you need,
maybe one for a timer if you need

00:19:41.150 --> 00:19:45.440
to pull or one for interrupts if
your device is interrupt-driven.

00:19:45.460 --> 00:19:47.900
You'll set those up in your
work loop using the event

00:19:47.900 --> 00:19:49.500
source and service methods.

00:19:49.520 --> 00:19:51.840
And then when you do that,
you provide the address

00:19:51.840 --> 00:19:52.860
of a callback method.

00:19:53.060 --> 00:19:56.470
So whenever that interrupt occurs
or whenever the timer goes off,

00:19:56.530 --> 00:19:57.970
that method will get called.

00:19:58.240 --> 00:20:02.010
Similarly,
output commands coming down from clients

00:20:02.010 --> 00:20:05.540
get set up in a command event source,
and you implement these just

00:20:05.540 --> 00:20:07.950
by overriding an abstract
family output method.

00:20:08.160 --> 00:20:11.680
You know, I/O Ethernet controller,
for example, has output packet.

00:20:11.680 --> 00:20:13.860
In both cases,
these methods are called within a work

00:20:13.940 --> 00:20:15.430
loop synchronization context for use.

00:20:15.440 --> 00:20:17.840
So you don't have to worry
about synchronization.

00:20:17.840 --> 00:20:19.680
It's handled for you.

00:20:19.700 --> 00:20:24.560
If you need to handle optimization,
if you really need to get things working,

00:20:24.560 --> 00:20:27.000
there are some ways to do that,
and you can find that

00:20:27.030 --> 00:20:28.480
in the documentation.

00:20:29.780 --> 00:20:33.200
and that was the
I/O Kit from 10,000 feet.

00:20:33.410 --> 00:20:35.490
We hope you got something out of that.

00:20:35.550 --> 00:20:38.100
If you want to find out more,
you can talk to Craig Keithley,

00:20:38.110 --> 00:20:40.520
and the documentation to check
out on the attendee site would

00:20:40.520 --> 00:20:43.400
include Getting Started with
Hardware and Drivers,

00:20:43.400 --> 00:20:47.290
I/O Kit Fundamentals, and
I/O Kit Device Driver Design Guidelines.

00:20:47.420 --> 00:20:50.490
Those include the view from
probably 50 feet down to zero.

00:20:50.570 --> 00:20:54.540
And if you want a view from 1,000 feet,
last year we had a talk on I/O Kit called

00:20:54.540 --> 00:20:56.400
Writing Device Drivers for Mac OS X.

00:20:56.400 --> 00:21:00.400
That is available at ADC on
iTunes at that URL right there.

00:21:00.610 --> 00:21:01.840
So there we go.

00:21:01.900 --> 00:21:03.320
I'm going to hand things off.

00:21:03.610 --> 00:21:04.900
Well, list of labs.

00:21:04.900 --> 00:21:08.400
We've got a lot of labs, mostly on USB,
Bluetooth, and AirPort.

00:21:10.640 --> 00:21:13.070
and now Ramesh,
Ananthakrishna Ramesh is going to

00:21:13.100 --> 00:21:16.740
come up and talk about file system
plugins and kernel authorization.

00:21:22.610 --> 00:21:23.310
Good morning.

00:21:23.400 --> 00:21:24.820
My name is Ramesh.

00:21:25.100 --> 00:21:27.930
I'm a senior software
engineer in the kernel team.

00:21:28.070 --> 00:21:33.580
Today I'm going to talk about non-IOKit
and the non-networking kernel extensions,

00:21:33.670 --> 00:21:37.270
that is the file system and the
kernel authorization plugins.

00:21:37.440 --> 00:21:39.420
Before I actually start
on either one of them,

00:21:39.420 --> 00:21:43.490
I would like to go over some
of the KPIs which are generic

00:21:43.490 --> 00:21:45.940
for all BSD kernel extensions.

00:21:46.050 --> 00:21:48.890
They may look a little different than
what you're used to in other platforms,

00:21:48.990 --> 00:21:51.710
but they're essentially the same.

00:21:52.110 --> 00:21:55.510
The first thing that I want to go
over is the memory allocation APIs.

00:21:55.660 --> 00:21:58.700
The header file to include
is the libkern os-malloc.h,

00:21:58.790 --> 00:22:02.740
and the dependency to declare
is the libkern symbol set.

00:22:03.070 --> 00:22:07.280
And BSD kernel extensions can
allocate pageable or wire memory,

00:22:07.360 --> 00:22:10.940
and the first thing that
anybody needs to do to allocate

00:22:10.940 --> 00:22:12.910
memory is to allocate a tag.

00:22:13.030 --> 00:22:15.440
To allocate a tag,
you call os-malloc tag-alloc

00:22:15.550 --> 00:22:19.760
and provide a unique string that
represents your kernel extension,

00:22:19.830 --> 00:22:24.050
and then the flags field there
takes whether it's pageable or not.

00:22:24.470 --> 00:22:25.910
This routine returns you a tag.

00:22:26.060 --> 00:22:31.480
You use this tag to go with malloc,
which allocates the memory for

00:22:31.480 --> 00:22:33.280
the size that you're asking for.

00:22:33.330 --> 00:22:38.920
And then you can use os-free to free
this memory that you just allocated.

00:22:38.950 --> 00:22:42.970
And the reason why we use the tag
is to associate the memory that is

00:22:43.050 --> 00:22:47.100
allocated to a kernel extension and
also keep track of how much memory has

00:22:47.190 --> 00:22:48.710
been allocated to a kernel extension.

00:22:51.630 --> 00:22:56.940
The next KPI that I want to talk
about is the locking primitives.

00:22:56.940 --> 00:22:59.970
The kernel provides
three locking primitives,

00:22:59.970 --> 00:23:05.540
the mutexes, simple locks, or spin locks,
or read/write locks.

00:23:05.540 --> 00:23:10.880
The way to allocate a mutex
is lock_mutex_alloc_init,

00:23:10.880 --> 00:23:15.360
which actually returns the
initialized allocated mutex handle.

00:23:15.360 --> 00:23:19.420
And as you notice,
there are two arguments for

00:23:19.420 --> 00:23:23.760
the lock_mutex_alloc_init,
the lock_group_structure and

00:23:23.760 --> 00:23:25.600
the lock_attribute_structure.

00:23:25.600 --> 00:23:30.960
The lock_group_structure is very
similar to the tag that you provide

00:23:30.960 --> 00:23:35.500
a unique string to allocate a group,
and you can also set whether

00:23:35.560 --> 00:23:39.420
you want statistics or not
for that group of locks.

00:23:39.420 --> 00:23:45.120
And the lock attribute is
a way to dynamically use,

00:23:45.120 --> 00:23:47.880
at the runtime,
whether a particular lock should

00:23:47.880 --> 00:23:49.860
be running in a debug mode or not.

00:23:49.860 --> 00:23:52.300
Then once you get the
handle to the lock_mutex,

00:23:52.300 --> 00:23:56.000
you can use lock_mutex_lock_to_lock
and lock_mutex_unlock_to_unlock.

00:23:56.000 --> 00:23:59.550
And then to free the mutex,
you call lock_mutex_free.

00:23:59.660 --> 00:24:04.800
And the spin and the read/write
lock variants are similar.

00:24:04.800 --> 00:24:10.320
The mutexes in Mac OS X actually spin
for a while if the mutex is held by a

00:24:10.320 --> 00:24:12.380
thread that's running on the other core.

00:24:12.400 --> 00:24:14.880
We also do priority
boosting for the mutex.

00:24:14.890 --> 00:24:18.750
So that's actually the
preferred synchronization

00:24:18.750 --> 00:24:22.040
primitive that I recommend.

00:24:22.270 --> 00:24:25.670
The spin locks are strongly
discouraged because they block

00:24:25.790 --> 00:24:27.220
preemption as well as interrupts.

00:24:27.360 --> 00:24:31.600
That could affect the interrupt
latencies on the system as well as

00:24:31.720 --> 00:24:33.940
the response to the real-time threats.

00:24:34.060 --> 00:24:39.690
So I would encourage you to
avoid using the spin lock.

00:24:40.470 --> 00:24:43.240
There are a few more KPIs that
I would like to point out.

00:24:43.320 --> 00:24:47.680
One is the msleep and wakeup,
where it's to do a sleep and wakeup.

00:24:47.830 --> 00:24:53.400
For the msleep, you pass a mutex,
which actually asserts the event and

00:24:53.400 --> 00:24:56.420
then drops the mutex before it blocks.

00:24:56.510 --> 00:24:58.430
And there are two kinds of time routines.

00:24:58.580 --> 00:25:01.930
One is the system time,
and the other is calendar time.

00:25:02.020 --> 00:25:05.570
System time is the time
since the last boot.

00:25:06.000 --> 00:25:08.940
Micro-op time actually gives
the time since the last boot,

00:25:08.940 --> 00:25:12.200
which is a lot faster than
the calendar-based time.

00:25:12.580 --> 00:25:16.880
And if we're just looking for a timestep,
you could use micro-op time

00:25:16.880 --> 00:25:18.700
rather than the calendar time.

00:25:18.760 --> 00:25:20.500
And of course,
the calendar time is actually

00:25:20.500 --> 00:25:25.140
needed for the file systems,
like when a file was created,

00:25:25.170 --> 00:25:27.640
the date and time for the file.

00:25:27.930 --> 00:25:31.980
And if you want to use the timeout
function to set up a timeout,

00:25:31.980 --> 00:25:34.020
you can use the thread call APIs.

00:25:34.360 --> 00:25:37.280
You do a thread call allocate
to allocate a callout structure,

00:25:37.280 --> 00:25:41.680
and then do a thread call enter
to set up your timeout function.

00:25:41.860 --> 00:25:44.700
To do the data movement between
the kernel and the user,

00:25:44.700 --> 00:25:47.100
you can use a copy-in, copy-out.

00:25:47.100 --> 00:25:50.000
What I want to point out
in that is the copy-in,

00:25:50.000 --> 00:25:52.960
copy-out actually take the
64-bit user address space,

00:25:52.960 --> 00:25:57.330
even though the user application that
you may be writing to is just 32-bit.

00:25:57.340 --> 00:26:02.380
So please make sure that you include
the proper prototypes so that you

00:26:02.380 --> 00:26:07.380
don't have any trouble for the bit
sign extension or something like that.

00:26:07.380 --> 00:26:12.260
And the UI Word data structure-- the data
structure is an opaque data structure.

00:26:12.260 --> 00:26:15.020
There are constructors and
deconstructors available in the KPI,

00:26:15.020 --> 00:26:16.830
but I think, generically,
for a file system,

00:26:16.830 --> 00:26:22.190
all they use is the UI move
to copy the data out from

00:26:22.190 --> 00:26:24.590
the kernel of the user space.

00:26:24.660 --> 00:26:28.220
Now I'd like to talk a little
bit about the file system.

00:26:28.650 --> 00:26:33.080
First thing that I want to
talk about is what all-- if one

00:26:33.080 --> 00:26:37.920
wants to implement file system,
what all pieces are necessary.

00:26:38.040 --> 00:26:40.600
There are a few things that
are specific to Mac OS X,

00:26:40.600 --> 00:26:43.840
and then the rest of them
are similar to others.

00:26:44.150 --> 00:26:46.400
I'm going to take an example
of the local file systems,

00:26:46.490 --> 00:26:53.910
because the remote file system almost
somewhat fall into the same pattern.

00:26:54.130 --> 00:26:56.220
Of course,
you would need a kernel extension,

00:26:56.250 --> 00:26:59.860
which resides in system robbery
extension for the file system.

00:26:59.930 --> 00:27:03.560
And along with the kernel extensions,
you also need a file system bundle,

00:27:03.580 --> 00:27:07.430
which is in system robbery file systems.

00:27:07.550 --> 00:27:10.610
And in this bundle, there are two things
that I want to highlight.

00:27:10.700 --> 00:27:15.020
One is the utility function,
and then the Info.plist.

00:27:15.140 --> 00:27:19.800
The utility function for the local
file systems is basically you

00:27:19.800 --> 00:27:22.300
need to support three arguments.

00:27:22.370 --> 00:27:24.710
There's -p, -m, and -u.

00:27:25.150 --> 00:27:26.460
-p is the probe.

00:27:26.690 --> 00:27:31.600
If you give--when the utility
function is invoked with -p option,

00:27:31.600 --> 00:27:35.020
it verifies to see whether
the given volume is supported

00:27:35.020 --> 00:27:36.660
by this file system or not.

00:27:36.720 --> 00:27:41.700
And if it does, it actually returns the
volume name to the caller.

00:27:41.700 --> 00:27:45.020
The Info.plist has
lots of different keys.

00:27:45.070 --> 00:27:47.000
The values that you can write.

00:27:47.020 --> 00:27:49.780
And a few things that I want
to point out is the fsname,

00:27:49.780 --> 00:27:55.020
which is actually the name of the volume
format that the file system supports.

00:27:55.120 --> 00:27:58.210
And then the probe order,
the order in which--if

00:27:58.210 --> 00:28:00.020
a new volume arrives,
you know,

00:28:00.020 --> 00:28:03.200
the order in which the different
file system needs to be probed to

00:28:03.290 --> 00:28:09.360
find out whether that volume is
supported by any of the file systems.

00:28:09.850 --> 00:28:12.870
And of course,
there are in the /sbin directory,

00:28:12.870 --> 00:28:16.750
they will have three boundaries,
the file system checker FSEK,

00:28:16.750 --> 00:28:20.400
which needs to support -q option
just to quickly verify whether

00:28:20.400 --> 00:28:22.280
the volume is clean or dirty.

00:28:22.390 --> 00:28:29.020
And then the new UFS is to layout
in file system on a new volume,

00:28:29.190 --> 00:28:32.080
and then the mount to
mount the file system.

00:28:32.210 --> 00:28:35.440
I just want to quickly go over
and see how all these different

00:28:35.440 --> 00:28:37.160
components work together.

00:28:37.190 --> 00:28:40.920
When the new device volume appears,
I/O Kit notifies the disk

00:28:40.920 --> 00:28:45.850
arbitration demon in the user space,
which then calls the utility

00:28:45.940 --> 00:28:48.200
function with the -p option.

00:28:48.230 --> 00:28:53.060
And if the file system actually is -
the volume has the file system that the

00:28:53.060 --> 00:28:57.410
particular kernel extension supports,
then it returns success

00:28:57.410 --> 00:28:58.880
with the volume name.

00:28:58.910 --> 00:29:03.980
And this is where the provider
for the Info.plist is actually

00:29:03.980 --> 00:29:06.830
used to look one after the other.

00:29:07.160 --> 00:29:12.650
Then the disk arbitration calls
FSEK with -q option to see

00:29:12.760 --> 00:29:15.510
whether it's clean or dirty.

00:29:15.930 --> 00:29:19.550
If it's actually volume is clean,
it actually goes and

00:29:19.550 --> 00:29:21.270
mounts the file system.

00:29:21.470 --> 00:29:25.170
If the volume is not clean,
it actually runs the FSEK to clean up

00:29:25.180 --> 00:29:27.620
the volume before it actually mounts.

00:29:27.840 --> 00:29:32.080
Once the mount is successful,
it actually notifies the finder and

00:29:32.080 --> 00:29:36.680
finder puts the desktop icon on the
sidebar as well with the volume name.

00:29:37.160 --> 00:29:41.690
that was actually passed
from the utility function.

00:29:42.530 --> 00:29:46.950
The unmounting of the file system,
the way it works is once, for example,

00:29:47.020 --> 00:29:51.800
a user drags the icon to the
trash or clicks on the eject,

00:29:51.800 --> 00:29:56.340
the finder notifies the disk arbitration,
which then in turn notifies

00:29:56.340 --> 00:29:58.400
all the clients who are
interested in that volume.

00:29:58.400 --> 00:30:04.520
And the purpose of this is the clients
can actually withhold the unmounting if

00:30:04.520 --> 00:30:08.550
they actually want to hold it for some
particular reason or to drop all the

00:30:08.550 --> 00:30:13.190
references that they have on the volume
so that the volume can be unmounted.

00:30:13.200 --> 00:30:16.380
If there are no dissenters,
then the disk arbitration goes and

00:30:16.380 --> 00:30:18.270
calls the unmount of the file system.

00:30:18.400 --> 00:30:21.700
If the unmount succeeds,
it notifies the finder,

00:30:21.700 --> 00:30:26.040
which then takes the icon out
from the desktop and the sidebar.

00:30:27.870 --> 00:30:31.680
Mac OS X implements
BSD/VFS style file system.

00:30:31.680 --> 00:30:36.250
For some of you who are not familiar,
I'm going to just give you a very

00:30:36.670 --> 00:30:39.970
quick highlight of what that is.

00:30:40.280 --> 00:30:44.120
The user level actions actually
come to kernel as a system

00:30:44.120 --> 00:30:50.570
call to the system call layer,
and then the file system related

00:30:50.570 --> 00:30:55.560
activities comes to a generic layer
in the kernel called VFS layer.

00:30:55.640 --> 00:30:58.760
This generic layer is same
for all the file systems.

00:30:58.820 --> 00:31:06.510
It then calls the corresponding
file system to do a specific action.

00:31:06.510 --> 00:31:06.510
It calls a routine which
does a specific action.

00:31:07.100 --> 00:31:09.030
In fact, the files,
the core of the file system

00:31:09.110 --> 00:31:14.000
is implemented as a set,
series of such routines with each one

00:31:14.000 --> 00:31:17.000
of them doing a specific operation.

00:31:17.110 --> 00:31:18.500
And there are two sets.

00:31:18.640 --> 00:31:21.610
One set that actually operates
on the individual file level,

00:31:21.740 --> 00:31:23.500
which is called VNode Operations.

00:31:23.620 --> 00:31:27.490
The file itself is represented
inside the VFS layer and the

00:31:27.490 --> 00:31:30.000
kernel by a VNodeT data structure.

00:31:30.000 --> 00:31:36.120
And the examples of this is, you know,
the VNode operations open, read, write,

00:31:36.120 --> 00:31:39.000
delete, you know, things like that.

00:31:39.000 --> 00:31:42.000
I actually want to point out
one more VNode operation.

00:31:42.000 --> 00:31:45.140
That's the lookup operation,
which I'm going to use

00:31:45.140 --> 00:31:47.000
in an example in a bit.

00:31:47.250 --> 00:31:52.000
The user opens a file or does an
action in the file with a path name.

00:31:52.000 --> 00:31:55.740
The path name consists of all
the name components separated

00:31:55.740 --> 00:31:57.960
by a separator character slash.

00:31:58.200 --> 00:32:02.120
The lookup operation,
which is the one that performs to

00:32:02.120 --> 00:32:06.000
translate from this name component
to a file system node number,

00:32:06.000 --> 00:32:09.770
and then construct a file system
node and then associates a

00:32:09.770 --> 00:32:13.000
VNode with that particular file.

00:32:13.080 --> 00:32:16.520
And then all further operations
on that file happens using the

00:32:16.520 --> 00:32:19.000
VNodes in the VNode operations.

00:32:19.220 --> 00:32:22.270
The second set of routines,
that is the ones that

00:32:22.270 --> 00:32:26.000
operate on the volume level,
and they're called VFS operations.

00:32:26.140 --> 00:32:30.000
And the volume itself is
represented in the files,

00:32:30.000 --> 00:32:34.000
in the VFS layer and the kernel
by MountT data structure.

00:32:34.000 --> 00:32:38.000
And the examples of that is Mount,
MountVolume and MountVolume,

00:32:38.000 --> 00:32:41.650
write all the dirty data to
the disk for all the files

00:32:41.650 --> 00:32:43.000
that haven't been written yet.

00:32:43.000 --> 00:32:48.000
And of course, lastly,
the file system will also have the

00:32:48.000 --> 00:32:50.000
module start and stop functions.

00:32:50.770 --> 00:32:54.250
There are some few things that
are really very different in

00:32:54.250 --> 00:32:57.550
Mac OS X compared to other file
systems that you may be used to.

00:32:57.650 --> 00:32:59.700
I would like to point a few of them.

00:32:59.820 --> 00:33:02.700
All the generic data structures are
completely opaque to the file system.

00:33:02.700 --> 00:33:07.140
The file system has no,
doesn't know how the data structures are,

00:33:07.710 --> 00:33:09.700
you know, laid out or anything like that.

00:33:09.700 --> 00:33:16.700
There are KPIs to manipulate them and
use them to do the file system work.

00:33:16.700 --> 00:33:18.650
There are three kinds of KPIs.

00:33:18.720 --> 00:33:20.700
There's accessor KPIs.

00:33:20.710 --> 00:33:24.700
You know, which access to individual
fields that are relevant.

00:33:24.700 --> 00:33:28.280
And then there's also functional
which does some particular

00:33:28.310 --> 00:33:29.700
functions in the convenience API.

00:33:29.700 --> 00:33:32.870
So I'll give you a few
examples in the next slide.

00:33:33.460 --> 00:33:35.440
All the vNode operations are symmetric.

00:33:35.510 --> 00:33:38.760
All the vNodes that come to vNode
operations come with a reference

00:33:38.860 --> 00:33:42.300
and they go back of the vNode
operations with the reference.

00:33:42.350 --> 00:33:44.280
And they're all lockless.

00:33:44.390 --> 00:33:46.300
The vNode actually
enters with no lock held.

00:33:46.300 --> 00:33:50.300
There's actually no serialization done
that way for the vNode operations.

00:33:50.580 --> 00:33:53.220
And that brings to my next point.

00:33:53.390 --> 00:33:56.930
The locking that we apply in
the VFS layer is completely

00:33:56.930 --> 00:33:59.300
transparent to the file system.

00:33:59.470 --> 00:34:03.300
The file system doesn't know anything
about locking and the vice versa.

00:34:03.310 --> 00:34:06.300
The VFS layer does not impose
any particular locking scheme

00:34:06.300 --> 00:34:08.140
on the file system nodes.

00:34:08.590 --> 00:34:11.910
File systems are completely
free to implement any locking

00:34:11.910 --> 00:34:16.300
scheme that they want to protect
their own data structures.

00:34:16.300 --> 00:34:18.930
For example,
HFS Extended uses Rediriter locks

00:34:19.050 --> 00:34:22.210
to protect and there are other
file systems that uses mutex to

00:34:22.400 --> 00:34:24.300
protect their file system nodes.

00:34:24.340 --> 00:34:28.300
All the block numbers
in the file system node,

00:34:28.480 --> 00:34:31.270
the file system node numbers,
interfaces between the VFS layer

00:34:31.350 --> 00:34:34.300
and the file systems are all 64 bit.

00:34:34.300 --> 00:34:38.450
And all the vNode operations
are called with the opaque data

00:34:38.730 --> 00:34:43.240
structure called VFS context,
which contains the marker that

00:34:43.240 --> 00:34:48.140
is necessary for authorization
for the user of that particular

00:34:48.520 --> 00:34:51.890
operation at that point of time.

00:34:52.300 --> 00:34:57.080
The header file to the rough interest
here is the sysmode.h from the kernel

00:34:57.080 --> 00:35:04.700
framework for the VFS KPIs and the
vnode.h for the vnode-level KPIs.

00:35:04.760 --> 00:35:07.640
I just want to point out vnode-if.h,
which is actually

00:35:07.640 --> 00:35:10.620
included in the vnode.h,
where it actually provides all the

00:35:10.620 --> 00:35:16.700
descriptors and arguments that are called
for the different vnode operations.

00:35:16.820 --> 00:35:20.920
And the symbol set to declare
is the BST symbol set.

00:35:21.200 --> 00:35:24.690
I'm going to take a sequence of
operations just to give you a overview

00:35:25.210 --> 00:35:27.400
of how the basic file system works.

00:35:27.580 --> 00:35:30.350
The sequence that I'm going to
follow is the file system gets

00:35:30.350 --> 00:35:31.900
loaded and it gets mounted.

00:35:31.990 --> 00:35:37.440
A file gets looked up in the file
system and that file gets deleted and

00:35:37.440 --> 00:35:43.390
the volume gets unmounted and then
eventually the file system gets unloaded.

00:35:44.940 --> 00:35:46.480
First the kex gets loaded.

00:35:46.500 --> 00:35:49.820
When the kex gets loaded,
the file system specific

00:35:49.900 --> 00:35:52.440
start/stop function gets called in.

00:35:52.480 --> 00:35:58.010
And this is the place where the file
system needs to register to the VFS,

00:35:58.010 --> 00:36:00.400
the file system with the KPI VFS FSR.

00:36:00.410 --> 00:36:04.290
It actually provides a list of
the VFS ops and the VNode ops

00:36:04.290 --> 00:36:06.360
that it actually implements.

00:36:06.390 --> 00:36:14.100
And this is a good place to allocate the
malloc tags and the group structures and

00:36:14.150 --> 00:36:19.160
create anything that you need for the
entire file system via data structures.

00:36:19.580 --> 00:36:23.630
When the volume gets mounted,
it comes to the VFS layer,

00:36:23.630 --> 00:36:27.320
which actually creates the mount data
structure and fills in all the few

00:36:27.360 --> 00:36:32.100
fields that are relevant at that point
in time and then calls the file system.

00:36:32.970 --> 00:36:37.950
file system VFS mount VFS up,
and it passes this mount

00:36:37.950 --> 00:36:39.380
data structure to that.

00:36:39.420 --> 00:36:44.200
One of the things that happens in
this is it creates its own file system

00:36:44.200 --> 00:36:48.730
specific to the mount data structures,
and then it calls a KPI to

00:36:48.730 --> 00:36:51.930
associate between the file
system specific data structure to

00:36:51.940 --> 00:36:54.400
the generic mount data structure.

00:36:54.400 --> 00:36:59.590
The KPI is VFS set FS private,
and that sets up an

00:36:59.590 --> 00:37:01.560
association between the two.

00:37:02.140 --> 00:37:06.480
All the VFS hops get called
with the mount T as an argument,

00:37:06.480 --> 00:37:10.230
and to get back from the mount data
structure the file system specific data

00:37:10.230 --> 00:37:15.850
structure you call VFS FS private and
pass the mount data structure to it.

00:37:18.300 --> 00:37:21.360
When a user starts a
file inside the volume,

00:37:21.360 --> 00:37:24.430
then it comes into a
lookup data structure,

00:37:24.430 --> 00:37:28.770
lookup vNode operation,
which then looks up, you know,

00:37:28.900 --> 00:37:31.660
let's assume that actually the
file has never been used before,

00:37:31.660 --> 00:37:34.350
so it's not in the name cache
or in the file system cache.

00:37:34.400 --> 00:37:40.150
It actually translates the name to the
file of FSNode number and then goes,

00:37:40.180 --> 00:37:45.780
reads the FSNode data from a disk,
and then sets up this FSNode completely.

00:37:45.780 --> 00:37:50.290
And in the very end of this operation,
it calls the KPI called vNode

00:37:50.290 --> 00:37:54.570
create and passes the FSNode and the
other relevant information like the

00:37:54.570 --> 00:37:57.300
file type and all kinds of stuff.

00:37:57.530 --> 00:38:00.720
Then the vnode create actually
creates the vnode and associates

00:38:00.960 --> 00:38:03.590
the file system node with the vnode.

00:38:03.590 --> 00:38:06.040
At this point of time,
the vnode is completely

00:38:06.040 --> 00:38:07.310
visible in the system.

00:38:07.400 --> 00:38:08.840
All other operations can happen.

00:38:08.840 --> 00:38:11.790
That's why it's important
to do it in the end.

00:38:12.370 --> 00:38:15.340
All the bnode operations are called
with the bnode as an argument.

00:38:15.340 --> 00:38:22.850
To get back to your file system,
nodeU is a KPI to bnodeFSNode.

00:38:23.050 --> 00:38:28.480
If a user deletes a file,
then it calls a remove

00:38:28.540 --> 00:38:32.540
operation of the file system,
which then basically,

00:38:32.540 --> 00:38:34.800
first thing it does is it
takes it out of the name space.

00:38:34.800 --> 00:38:37.560
It basically purges from the name
cache and the file system cache

00:38:37.560 --> 00:38:39.050
that nobody else can find them.

00:38:39.080 --> 00:38:41.670
There may be still
references to the VNode,

00:38:41.750 --> 00:38:46.080
so all it does is it actually
calls a VNode recycle.

00:38:46.080 --> 00:38:47.760
This slide is slightly wrong.

00:38:47.760 --> 00:38:49.900
It's actually not VNode reclaim,
it's VNode recycle.

00:38:50.540 --> 00:38:55.490
KPI, which then marks the
VNode for termination.

00:38:55.490 --> 00:39:00.910
When all the users of that particular
file are completely out of the system,

00:39:00.910 --> 00:39:06.280
then the VFS layer calls a VNode
operation called reclaim VNode operation,

00:39:06.280 --> 00:39:10.340
which then is free to free
up all the data structures.

00:39:10.340 --> 00:39:13.400
The first thing that it does
is to dissociate between the

00:39:13.400 --> 00:39:16.670
VNode and the file system node,
and then it can free up all the

00:39:16.670 --> 00:39:20.310
file system level data structure
and resources that it has.

00:39:20.440 --> 00:39:24.580
And then the reclaim operation
returns back to the VFS layer,

00:39:24.870 --> 00:39:28.920
which then frees up the generic
data structure and any resources

00:39:28.920 --> 00:39:30.740
that the VFS layer has.

00:39:30.740 --> 00:39:34.400
This is just to show, you know,
the VNode is alive across

00:39:34.400 --> 00:39:37.980
the whole VNode operation,
and VNode is currently to be

00:39:37.980 --> 00:39:42.040
alive when the VNode operation
happens for a file system.

00:39:43.610 --> 00:39:47.320
When the volume gets unmounted,
it comes to the unmount

00:39:47.380 --> 00:39:52.380
VFS operation in the VFS,
which basically first dissociates

00:39:52.380 --> 00:39:56.770
the file system mount data
structure to the generic mount

00:39:56.770 --> 00:40:00.340
data structure by VFS set private,
FS private.

00:40:00.440 --> 00:40:06.840
And then it frees up the file
system level mount data structures.

00:40:06.940 --> 00:40:11.000
And then once this VFS operator,
the VFS layer then cleans

00:40:11.050 --> 00:40:12.690
up everything else,
mount structure and

00:40:13.080 --> 00:40:15.110
rest of the resources.

00:40:15.210 --> 00:40:18.270
When the KEXT itself gets unloaded,
it can actually call,

00:40:18.370 --> 00:40:25.290
its stop function gets called,
which can then re-register the

00:40:25.830 --> 00:40:31.300
The file system for VFS by
calling VFS/CFS remove.

00:40:32.300 --> 00:44:23.200
( Transcript missing )

00:44:26.290 --> 00:44:26.860
Good morning.

00:44:26.860 --> 00:44:27.890
I'm Laurent Dumont.

00:44:27.900 --> 00:44:32.700
I work in the networking in CoreOS,
Mac OS X CoreOS.

00:44:32.810 --> 00:44:35.600
So we're gonna talk about
the networking KPIs.

00:44:35.710 --> 00:44:37.820
And the first thing I wanna, um,
you know,

00:44:37.820 --> 00:44:42.600
look at here is a little bit how the
networking stack is working in Mac OS X.

00:44:42.700 --> 00:44:46.940
So here we got a--a picture that
kind of split some of the layers,

00:44:46.940 --> 00:44:49.910
um, that we have in the kernel--
in the BSD part of the

00:44:49.920 --> 00:44:51.480
kernel for the networking.

00:44:51.620 --> 00:44:54.600
So you can see that at the top,
we get the socket layer,

00:44:54.720 --> 00:44:58.910
which inside the kernel is responding
to the user sockets and also,

00:44:58.910 --> 00:45:02.600
you know, handling, buffering,
and so on for your sockets.

00:45:02.600 --> 00:45:05.590
And in the middle of that,
we get the protocol layer.

00:45:05.880 --> 00:45:10.440
Here we have IP and IPv6 that, you know,
does all the protocol stuff.

00:45:10.620 --> 00:45:15.600
And at the lower, um, level,
we get the interface layer,

00:45:15.600 --> 00:45:19.810
which handle all the particularity of,
you know, Ethernet or, you know,

00:45:19.810 --> 00:45:23.600
PPP and all those kind of tunnels
and all those kind of interface.

00:45:23.600 --> 00:45:28.590
And so-- so we show here that, um,
this is on top of the I/O Kit layer.

00:45:28.600 --> 00:45:32.500
So Nick, uh, earlier talked about,
you know, how to do your Ethernet

00:45:32.500 --> 00:45:35.600
driver in I/O Kit,
and that would be at this level here.

00:45:35.600 --> 00:45:37.600
That would interface
with the interface layer.

00:45:37.600 --> 00:45:41.120
So what we'll see is that
we have different levels of,

00:45:41.120 --> 00:45:45.770
uh, KPI here that, um,
basically give you access at different,

00:45:45.770 --> 00:45:49.990
you know, um, area in the networking, um,
subsystem, if you want.

00:45:50.290 --> 00:45:55.690
So in blue here, you can see socket,
socket filter, IP filters, uh,

00:45:55.820 --> 00:45:59.600
plumbers that are used, you know,
for associating your interface filter,

00:45:59.700 --> 00:46:02.010
and also interface
filter and the interface.

00:46:02.100 --> 00:46:05.880
So we'll--we'll do a quick
overview of all those,

00:46:05.880 --> 00:46:11.940
um, level of KPIs and see how you can,
you know, with your CACs, um, you know,

00:46:12.300 --> 00:46:16.600
plug in in there and--and, you know,
do different--different types of, uh,

00:46:16.600 --> 00:46:20.500
of networking, um, operations.

00:46:20.910 --> 00:46:24.200
So first,
what we want to say here is that

00:46:24.260 --> 00:46:31.960
in the kernel and in the KPI,
all the structures are all opaque.

00:46:32.180 --> 00:46:35.250
So basically,
you'll get some handles and you

00:46:35.250 --> 00:46:41.820
won't be able to see what's inside
a socket or inside any of the other

00:46:41.820 --> 00:46:43.240
things that we have in the kernel.

00:46:43.490 --> 00:46:45.760
And we'll provide some
accessors so that you can,

00:46:45.760 --> 00:46:50.330
let's say, look at what's in an MBuf,
or things like that.

00:46:50.680 --> 00:46:52.640
And we do that for
binary compatibilities.

00:46:52.640 --> 00:46:56.520
That way,
we can make sure that your kex is going

00:46:56.520 --> 00:47:00.480
to work in a subsequent version if we
change something in the structures.

00:47:00.530 --> 00:47:03.570
And for Leopard,
we changed a lot of things.

00:47:03.890 --> 00:47:08.520
And that's why we don't want you to be
able to access inside the structures.

00:47:08.520 --> 00:47:11.120
All the KPI definition we're
going to talk about here are

00:47:11.180 --> 00:47:12.710
all in the kernel frameworks.

00:47:12.950 --> 00:47:19.440
And common to all the KPI for networking,
we use data on the form of MBuf.

00:47:19.520 --> 00:47:22.300
So if you're familiar-- if you're
familiar with BSD networking,

00:47:22.300 --> 00:47:23.350
you know what an MBuf is.

00:47:23.630 --> 00:47:26.510
The difference here is that we'll
have some accessors to look at

00:47:26.580 --> 00:47:30.270
what's going on with the MBuf and
access some of the fields instead

00:47:30.270 --> 00:47:33.050
of directly accessing the MBuf.

00:47:33.120 --> 00:47:34.580
structure.

00:47:34.580 --> 00:47:38.900
So first, we'll look at the socket,
at the socket KPI.

00:47:38.900 --> 00:47:43.550
So the socket KPI pretty much lets
you use sockets in the kernel.

00:47:43.560 --> 00:47:48.700
So you can have an application which
is doing the use for socket like doing,

00:47:48.700 --> 00:47:53.080
you know, read and write and, you know,
your own socket.

00:47:53.080 --> 00:47:55.540
So you can do your own
client in the kernel.

00:47:55.540 --> 00:47:57.470
And it's only for socket clients.

00:47:57.550 --> 00:48:02.230
So you cannot do a listener or a
server in the kernel because we

00:48:02.230 --> 00:48:07.090
don't have support for a lot of
the primitives that we have in user

00:48:07.090 --> 00:48:09.240
land for socket for doing a listen.

00:48:09.240 --> 00:48:12.380
So we don't have things like, you know,
select or something like that.

00:48:12.380 --> 00:48:16.700
So but otherwise,
the life cycle for socket,

00:48:16.700 --> 00:48:18.930
you have pretty much everything you need.

00:48:18.930 --> 00:48:23.140
You can create, set options,
do a connect, do a send, a receive,

00:48:23.170 --> 00:48:24.290
or a close.

00:48:24.470 --> 00:48:28.260
And some, you know,
all those KPIs are in the KPI socket .h.

00:48:28.260 --> 00:48:29.730
stage.

00:48:30.310 --> 00:48:35.680
So here we'll see an example of how
you create a socket in the kernel.

00:48:35.720 --> 00:48:39.140
So you call here the
sock socket function.

00:48:39.170 --> 00:48:44.890
And the difference compared to,
let's say, calling socket in userland is,

00:48:44.890 --> 00:48:47.780
here we're creating a TCP socket.

00:48:48.180 --> 00:48:52.110
And you're going to provide, if you want,
an upcall function,

00:48:52.110 --> 00:48:55.450
which is going to be called back
from the kernel each time we

00:48:55.450 --> 00:48:56.940
have an event for that socket.

00:48:56.940 --> 00:48:59.700
Let's say you get connected
or you get a read.

00:49:00.060 --> 00:49:01.610
You'll get called in that callback.

00:49:01.700 --> 00:49:06.570
You can also provide your own cookie
where you can decide of the state of

00:49:06.580 --> 00:49:10.670
your socket or whatever information you
want to stash away and recognize that

00:49:10.740 --> 00:49:13.840
socket by calling sock socket here.

00:49:14.140 --> 00:49:18.210
Here, it's what's going on when,
let's say, we get the read,

00:49:18.210 --> 00:49:22.500
and we're in the input,
and we're getting some data coming in.

00:49:22.500 --> 00:49:25.820
So we're calling your up call function.

00:49:25.820 --> 00:49:30.760
And here, as you can see here,
you get your cookies.

00:49:30.760 --> 00:49:33.820
So you're looking at, hey,
I'm in a connected state.

00:49:33.820 --> 00:49:37.980
And now you're going to call another KPI,
which is a soc read,

00:49:37.980 --> 00:49:40.510
to do the actual read
and get the data and,

00:49:40.680 --> 00:49:43.740
you know, do whatever you want
with the data after that.

00:49:43.740 --> 00:49:46.420
You have to be a little careful
about locking and all those

00:49:46.420 --> 00:49:49.400
kind of things because here,
you call on the input thread,

00:49:49.520 --> 00:49:53.560
and you need to take care of your
own locking for your own data.

00:49:53.560 --> 00:49:56.420
All the socket state from
the kernel point of view,

00:49:56.420 --> 00:49:58.580
it's all, you know, consistent.

00:49:58.580 --> 00:50:01.960
And we're taking care of
the locking for the socket.

00:50:02.010 --> 00:50:04.730
But you need to make sure that
you're taking care of the locking

00:50:04.730 --> 00:50:09.290
for your own structures that you
manipulate associated with the socket.

00:50:10.000 --> 00:53:05.500
( Transcript missing )

00:53:05.690 --> 00:53:06.750
layer.

00:53:06.760 --> 00:53:14.240
So another layer -- another level of
KPIs that we have here is the IP filter.

00:53:14.450 --> 00:53:17.570
So the IP filter,
it's -- it lets you do a

00:53:17.770 --> 00:53:22.190
certain number of things,
because now you have access to

00:53:22.240 --> 00:53:25.350
data as it's seen by the protocols.

00:53:25.350 --> 00:53:30.470
So you can -- you know,
you have -- you see reassembled inbound

00:53:30.470 --> 00:53:32.790
IP packets when they're coming in.

00:53:32.850 --> 00:53:37.240
And you also see outbound IP packets
when they're going out to the interface.

00:53:37.240 --> 00:53:41.750
You can put your filters there and also,
you know, do that before and after both

00:53:41.850 --> 00:53:45.560
the IPsec encryption and all the
encapsulation if there is any.

00:53:45.560 --> 00:53:49.780
So you got different levels in
the IP filter where you can,

00:53:49.910 --> 00:53:53.170
you know, put your KPI and decide
what to do and manipulate.

00:53:53.240 --> 00:53:56.860
You got full access to
the IP layer header.

00:53:56.860 --> 00:53:58.500
So you can change the checksum.

00:53:58.500 --> 00:54:00.000
You can change the destination.

00:54:00.000 --> 00:54:05.100
You have a lot of possibilities that
you can do in your -- in your text.

00:54:05.160 --> 00:54:07.140
With this KPI.

00:54:07.340 --> 00:54:10.100
The life cycle of the KPI,
you attach and you -- or

00:54:10.100 --> 00:54:12.070
you detach to the IPv4,
IPv6.

00:54:12.070 --> 00:54:14.550
So you decide which kind of
packets you're interested in.

00:54:14.620 --> 00:54:18.300
And then you get called in, you know,
when there's something at your level.

00:54:18.450 --> 00:54:20.140
The locking, you know, same thing.

00:54:20.140 --> 00:54:24.720
You have to drop your locks before
you inject data into the stack.

00:54:24.720 --> 00:54:28.840
And you're responsible
for locking your own data.

00:54:28.880 --> 00:54:32.220
And the framework for it,
the kernel framework,

00:54:32.220 --> 00:54:34.060
it's in the KPI IP filter.

00:54:34.140 --> 00:54:35.860
We're going really fast.

00:54:35.860 --> 00:54:37.380
But there's a lot of KPI.

00:54:37.430 --> 00:54:39.280
So it's just an overview.

00:54:39.280 --> 00:54:46.190
So the other -- the other level here
of -- of KPI we have for networking

00:54:46.190 --> 00:54:48.400
is that the interface filter.

00:54:48.400 --> 00:54:53.030
So the interface filter is a level
down where basically you can access

00:54:53.060 --> 00:54:55.860
data as it's seen for the interface.

00:54:56.020 --> 00:54:59.550
So you can filter inbound
and outbound packets.

00:54:59.640 --> 00:55:01.940
And we're not talking here
before for the IP filter.

00:55:01.980 --> 00:55:03.480
We're talking about IP packets.

00:55:03.650 --> 00:55:04.720
Now we're talking about
front end packets.

00:55:04.880 --> 00:55:10.720
So you can access to the Mac, you know,
link layer and the other depending

00:55:10.720 --> 00:55:13.170
on the type of interface.

00:55:13.180 --> 00:55:16.080
And you get access to the
interface IOCtl in this layer

00:55:16.080 --> 00:55:19.240
also when you do your filter.

00:55:19.240 --> 00:55:22.060
Some of the common use
for that KPI is doing,

00:55:22.060 --> 00:55:26.940
you know, packet layer firewall where you
can have full access to the packet.

00:55:26.940 --> 00:55:29.830
And also things like
virtual packet switch,

00:55:29.850 --> 00:55:34.430
like things like, you know,
like parallel stuff like that.

00:55:34.520 --> 00:55:38.020
They use -- they use interface filters.

00:55:38.020 --> 00:55:44.120
So this -- all the definition for
this is in the KPI interface filter.h.

00:55:44.910 --> 00:55:53.110
Another level of KPI here is to
do your own network interface.

00:55:53.110 --> 00:55:53.110
So,

00:55:53.420 --> 00:55:57.900
You can do a network interface
BSD style which would work with a

00:55:58.000 --> 00:56:01.820
stack which is not an I/O Kit driver
because let's say you're doing

00:56:01.910 --> 00:56:07.910
a tunneling device or something like
that that doesn't really need to have

00:56:07.910 --> 00:56:11.960
any physical access to a media which
sits on top of Ethernet or sits on

00:56:11.960 --> 00:56:14.710
top of let's say PPP or what have you.

00:56:14.990 --> 00:56:19.780
This is how we implement things like the
bounding interface and stuff like that.

00:56:19.890 --> 00:56:24.540
So here what you can do,
you can create your own IF-NET interface.

00:56:24.750 --> 00:56:29.970
So you get access and you get to
provide a function for inputting and

00:56:29.970 --> 00:56:32.420
outputting packets from I/O Kit or not.

00:56:32.600 --> 00:56:36.890
So you get packets from I/O Kit and
you decide to change them or

00:56:36.990 --> 00:56:41.200
if you're sitting on another
interface or another tunnel,

00:56:41.210 --> 00:56:42.780
then you'll get those packets.

00:56:42.930 --> 00:56:48.480
You get to provide a DMUX also so we can
handle the add and remove of protocols.

00:56:48.600 --> 00:56:51.470
So if there's a new protocol coming up,
you need to provide a

00:56:51.470 --> 00:56:53.780
DMUX let's say for IPv6.

00:56:53.850 --> 00:56:58.300
So maybe your interface is handling
IPv6 differently than IPv4.

00:56:58.300 --> 00:57:01.880
So you get to provide
the DMUX or Apple talk.

00:57:02.160 --> 00:57:06.000
You also do the framing for the
outbound packets in that layer.

00:57:06.050 --> 00:57:09.990
So in your interface,
you will be called in and do the framing.

00:57:10.000 --> 00:57:14.600
Also, you have to handle I/O CTLs like
the multicast if it's just something

00:57:14.600 --> 00:57:21.130
like Ethernet and you want to
emulate something like multicast

00:57:21.500 --> 00:57:26.020
on the wire or on your interface,
you get access to the -- you get to

00:57:26.100 --> 00:57:30.380
provide access to the I/O CTL for the
multicast or also for the state change

00:57:30.450 --> 00:57:35.500
if your interface goes down or goes up,
those kind of things.

00:57:35.500 --> 00:57:39.000
The KPI for this is in
the KPI interface.h.

00:57:39.000 --> 00:57:43.060
And there is more interface-related
accessor in that KPI interface,

00:57:43.080 --> 00:57:49.500
things that let you access IF-NET type
stuff like the stats for the interface,

00:57:49.500 --> 00:57:52.710
and add statistics, you know,
because you get some packets that you

00:57:52.780 --> 00:57:54.500
refuse or some packets you filter.

00:57:54.740 --> 00:57:58.090
All that is in KPI interface.h.

00:57:58.330 --> 00:58:03.060
Another level here which is
kind of associated with the

00:58:03.060 --> 00:58:06.970
interface KPI is a plumber KPI.

00:58:06.980 --> 00:58:14.100
So the KPI is basically the glue between
your interface and an existing protocol.

00:58:14.250 --> 00:58:19.610
Let's say you're providing a new
type of interface and you need

00:58:19.720 --> 00:58:23.530
a new form of arping for IP,
you would provide that

00:58:23.530 --> 00:58:25.200
in the protocol plumber.

00:58:25.270 --> 00:58:29.530
So you register your plumb and
unplumb functions with the plumber.

00:58:29.550 --> 00:58:34.200
And so you attach that to
a protocol to an interface.

00:58:34.450 --> 00:58:38.500
And also you get called when you
want to unplumb for detaching

00:58:38.500 --> 00:58:41.100
the protocol from the interface.

00:58:41.200 --> 00:58:47.130
And one word of warning here is that this
is not a KPI for adding new protocols.

00:58:47.220 --> 00:58:49.110
We don't have that.

00:58:49.200 --> 00:58:53.430
So this is for existing protocol but
a different type of interface that has

00:58:53.470 --> 00:58:57.200
different requirements like arping,
I think.

00:58:57.200 --> 00:58:59.200
So mainly.

00:58:59.200 --> 00:59:03.090
And so those are in the KPI protocol.h.

00:59:03.560 --> 00:59:09.250
Also, I want to mention here some
ways for you as a KPI to inject

00:59:09.290 --> 00:59:14.610
new packets you're creating,
let's say, in the protocol layer in your

00:59:14.610 --> 00:59:18.280
interface or any other place
you want to create some packets,

00:59:18.280 --> 00:59:21.160
so you get some packets that you want
to inject because you're a tunnel,

00:59:21.300 --> 00:59:24.980
you're going to call proto input,
which is a function where

00:59:25.120 --> 00:59:26.290
you pass the packet.

00:59:26.490 --> 00:59:30.620
And this is what you call
from the inbound pass,

00:59:30.690 --> 00:59:32.380
so, you know,
simulating something that is

00:59:32.400 --> 00:59:36.340
coming in from the physical,
you know, the driver layer.

00:59:36.440 --> 00:59:42.190
And also, if you're in a kex and you're
trying to send a packet,

00:59:42.260 --> 00:59:45.620
you know, in,
but you're on the outgoing side,

00:59:45.760 --> 00:59:47.470
you're going to call protocol inject.

00:59:47.620 --> 00:59:51.240
And if you're familiar
with the BSD kind of model,

00:59:51.480 --> 00:59:54.980
it replaces a little bit the NetISR.

00:59:55.000 --> 00:59:58.300
This is the protocol inject
that you will call in that case.

00:59:58.300 --> 01:00:02.180
And those are in the KPI protocol.h.

01:00:02.920 --> 01:00:10.770
The other thing that we have here,
which is a KPI that is used for

01:00:10.770 --> 01:00:12.920
communicating with your kegs pretty much.

01:00:12.990 --> 01:00:14.410
It's a kernel control socket.

01:00:14.480 --> 01:00:20.650
So it's a special type of socket that
we use to communicate with user space.

01:00:20.870 --> 01:00:25.810
So you can use that to configure
some setting in your kegs or

01:00:25.810 --> 01:00:27.800
get some information about,
let's say,

01:00:27.800 --> 01:00:32.340
we're talking about earlier about
getting your connect and deciding if we

01:00:32.340 --> 01:00:38.520
wanted to allow or not the application
to connect to a certain address.

01:00:38.610 --> 01:00:42.630
You can use the kernel control
socket to send that information

01:00:42.630 --> 01:00:46.680
back to a daemon in user space and
get that information and get it

01:00:46.750 --> 01:00:48.940
back on the kind of a side channel.

01:00:49.250 --> 01:00:50.590
So they're pretty useful for this.

01:00:50.600 --> 01:00:55.940
There's some locking consideration to
think about is that those kernel sockets,

01:00:55.940 --> 01:00:58.430
control sockets are not serialized.

01:00:58.430 --> 01:01:00.590
So you need to be careful about that.

01:01:00.790 --> 01:01:03.600
But it's safe to send to
your client at any time.

01:01:03.600 --> 01:01:07.020
So whatever context you're getting in,
you can do a send back to your

01:01:07.020 --> 01:01:08.590
client and they will get it.

01:01:08.600 --> 01:01:10.510
And we mentioned it here.

01:01:10.510 --> 01:01:15.320
It's in the kernel control dot H that
you'll see all the KPI associated

01:01:15.320 --> 01:01:17.740
with kernel control sockets.

01:01:18.300 --> 01:03:47.800
( Transcript missing )

01:03:48.330 --> 01:03:51.130
For more information--
that was really fast.

01:03:51.140 --> 01:03:55.240
But for more information,
you can contact Craig Kistley,

01:03:55.240 --> 01:03:57.660
which is the technology evangelist.

01:03:57.840 --> 01:04:03.200
And some documentation,
sample codes are on the website.

01:04:03.200 --> 01:04:09.100
The TCP log NKE is a good
NKE to look at how to do a KPI.

01:04:09.120 --> 01:04:15.630
And the network extension programming
guide is going to give you also some more

01:04:15.630 --> 01:04:18.420
in-depth information than we can do here.
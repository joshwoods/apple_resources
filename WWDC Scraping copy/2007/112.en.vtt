WEBVTT

00:00:11.380 --> 00:00:18.120
>> My name is Curtis Galloway, and welcome to the
Power On to Log In session, number one twelve.

00:00:18.120 --> 00:00:23.280
If that's not the session you think
this is, then turn around now.

00:00:23.280 --> 00:00:28.050
I'll be presenting today with Soren
Spies, he'll do the second half.

00:00:28.050 --> 00:00:33.660
And it looks like there's a lot of people here today, so
I'm very impressed that everyone is interested in booting.

00:00:33.659 --> 00:00:35.809
( Laughter )

00:00:35.810 --> 00:00:37.510
I guess you do it a lot.

00:00:37.509 --> 00:00:39.210
So why this session?

00:00:39.210 --> 00:00:46.990
The purpose of this session is to take some of the mystery
out of the booting process, to help you do better debugging

00:00:46.990 --> 00:00:53.670
when you're you know, debugging something during
that whole sequences, to design your products better

00:00:53.670 --> 00:00:58.480
so that they can interact with the standard
boot process, and to reduce your support costs,

00:00:58.479 --> 00:01:03.469
and the confusion of both you and us, and your users.

00:01:03.469 --> 00:01:10.590
What we'll cover today is basically everything that happens
from when you power on your Mac up to log in window,

00:01:10.590 --> 00:01:15.680
and we'll also cover some of the things that
can go wrong, and how to tell what's going on,

00:01:15.680 --> 00:01:18.200
and get some better information about debugging.

00:01:18.200 --> 00:01:25.950
And we'll cover some places where you're able to hook in to
the boot process and use some supported APIs to do things,

00:01:25.950 --> 00:01:30.370
and also maybe some guidance on
whether you should do that or not.

00:01:30.370 --> 00:01:36.240
And I should note that much of the information
that we present today is informational, you know,

00:01:36.239 --> 00:01:41.109
everything that we show is not necessarily
something that you should hook into and try to use.

00:01:41.109 --> 00:01:49.489
So take care to always use supported interfaces as always,
and although the title of this session might lead you

00:01:49.489 --> 00:01:53.579
to think that it is gonna cover loadable file
systems, we're not really gonna cover that today.

00:01:53.579 --> 00:01:56.939
And so if that's your interest, you
should come and see us afterwards.

00:01:56.939 --> 00:02:01.340
And please read the prospectus carefully
before you invest, or send money.

00:02:03.349 --> 00:02:12.530
So the basic booting process in a nutshell is four different
stages, in OS ten or basically any modern operating system.

00:02:12.530 --> 00:02:18.370
You have the firmware, or the ROM, which is the very
first part that happens when you turn on your computer.

00:02:18.370 --> 00:02:23.620
You have the boot loader, which is part of the
operating system, but is at a very low level.

00:02:23.620 --> 00:02:28.340
You have the kernel, which manages the resources
of the system on behalf of user processes.

00:02:28.340 --> 00:02:34.240
And then you have user processes, like your
applications or the window server, or a log in window.

00:02:34.240 --> 00:02:38.030
And so we'll go through each of these steps in turn.

00:02:38.030 --> 00:02:47.500
And in a little more detail, the EFI boot ROM
section includes both initializing the hardware

00:02:47.500 --> 00:02:49.460
and searching for something to boot.

00:02:49.460 --> 00:02:55.099
The booter loads the kernel environment,
and then switches into the kernel.

00:02:55.099 --> 00:03:01.659
Then the kernel does device discovery and I/O Kit, loading
device drivers, and searching for the root device.

00:03:01.659 --> 00:03:07.180
And then once you're in user level, you have launch D and
log in, and all of the other applications that come up.

00:03:07.180 --> 00:03:13.930
And each of these stages have some
signs that you can use to tell just

00:03:13.930 --> 00:03:16.969
from an external perspective where you are in the process.

00:03:16.969 --> 00:03:21.060
So for example when the light on the
front of the system comes on, you know,

00:03:21.060 --> 00:03:24.379
that EFI has turned on, and is initializing the system.

00:03:24.379 --> 00:03:31.789
And then the boot chime indicates that it's
loading the EFI device drivers and executing them.

00:03:32.930 --> 00:03:38.319
The gray screen that comes up when
the screen lights up is also in EFI,

00:03:38.319 --> 00:03:42.689
and then the Apple logo is actually
drawn by the boot loader.

00:03:42.689 --> 00:03:45.750
So once you see the Apple logo,
you know you're in the booter.

00:03:45.750 --> 00:03:49.780
And then the spinning gear is run by
the kernel, which is the next phase.

00:03:49.780 --> 00:03:55.840
And then of course once the blue screen and log in
window comes up, then you know that you're in user land.

00:03:55.840 --> 00:04:00.729
So we'll go through in more detail in each of the sections
just exactly when these things come up so you'll be able

00:04:00.729 --> 00:04:04.079
to identify more clearly, what's going on.

00:04:04.080 --> 00:04:09.390
So first, let's concentrate on stage one, the ROM.

00:04:09.389 --> 00:04:14.339
The ROM really isn't read only any more, it's
stored in Flash, so it can be modified and updated.

00:04:14.340 --> 00:04:20.129
But conceptually it's the thing that's built into your
system that doesn't go away when you turn off the computer.

00:04:20.129 --> 00:04:26.110
So its job is to initialize the hardware when
there's no software present on the Machine.

00:04:26.110 --> 00:04:32.750
So the very first thing that happens, even before you turn
on your Machine, is there is a processor called the SMC,

00:04:32.750 --> 00:04:35.529
which is sitting there listening to the power button.

00:04:35.529 --> 00:04:40.759
So even without any other power, the SMC
is the thing that does this leap life,

00:04:40.759 --> 00:04:43.099
and sits there and waits for the power button.

00:04:43.100 --> 00:04:49.270
So once you hit the power, the SMC actually sends
the signal to turn on the rest of the processor,

00:04:49.269 --> 00:04:52.039
and memory, and all the rest of the hardware.

00:04:52.040 --> 00:04:57.270
And the processor does the first thing that it's
programmed to do, which is to jump to the reset vector,

00:04:57.269 --> 00:05:04.519
which is common to all Intel processors, and loads a
little bit of code that's built into EFI that knows how

00:05:04.519 --> 00:05:10.949
to get the processor in the right mode, do some
very early initialization, turn on the memory.

00:05:10.949 --> 00:05:16.909
And if you're familiar with the terminology used
by EFI, that's called the pre EFI environment

00:05:16.910 --> 00:05:20.530
It's a very small section of code that's
usually written in assembly language

00:05:20.529 --> 00:05:25.709
that is just the very most basic
initialization to get you up into a state

00:05:25.709 --> 00:05:33.049
where you can run what you'd consider you
know, normal Flash device driver software.

00:05:33.050 --> 00:05:40.620
So once the processor and the chipset and the memory
are initialized, then you go into EFI's Dixie, or D X E,

00:05:40.620 --> 00:05:46.449
which is device execution environment, where
all of the EFI device drivers that are built

00:05:46.449 --> 00:05:51.319
in for the hardware on your Machine will run concurrently.

00:05:51.319 --> 00:05:56.189
Actually, it's a lot like I/O Kit,
things sort of happen asynchronously

00:05:56.189 --> 00:06:01.259
so that they can initialize the Machine
in the least amount of time possible.

00:06:01.259 --> 00:06:08.610
So this is when the boot chime plays for example, one of the
drivers that's the first one to load is the sound driver,

00:06:08.610 --> 00:06:14.250
which starts playing the boot chime while the
other EFI drivers are actually initializing.

00:06:14.250 --> 00:06:18.399
So that all happens in parallel
as your Machine is coming up.

00:06:18.399 --> 00:06:26.439
And any PCI add on cards that have ROM drivers
would be run at this point, they would be found

00:06:26.439 --> 00:06:30.110
and run along with the built in EFI drivers.

00:06:33.689 --> 00:06:36.889
Okay. So what can go wrong at this point?

00:06:36.889 --> 00:06:40.969
Well, the most common failure mode
at this point would be a RAM failure.

00:06:40.970 --> 00:06:46.160
So EFI would detect that during the power
on self test, and would sound a tone,

00:06:46.160 --> 00:06:48.880
and flash the hardware light on the front of the Machine.

00:06:48.879 --> 00:06:53.170
And that's how most of these kind of failures
would be reported, is the flashing light

00:06:53.170 --> 00:06:55.790
and a tone, if the sound hardware is working.

00:06:55.790 --> 00:07:00.840
So EFI's going to check, do a very basic check of
your hardware, and if the initialization of any

00:07:00.839 --> 00:07:04.149
of the pieces fails then it will sound an error.

00:07:04.149 --> 00:07:12.129
Or if EFI itself fails, if you were doing a firmware
update, and something interrupted it half way through,

00:07:12.129 --> 00:07:16.779
or the image was corrupted for some
reason, then EFI would detect that.

00:07:16.779 --> 00:07:23.000
One of its own internal images was faulty and would
abort itself, and then go into a recovery mode

00:07:23.000 --> 00:07:26.009
where it would load a recovering image
from a different part of the Flash,

00:07:26.009 --> 00:07:30.750
so you'd be able to come back up
and retry updating the firmware.

00:07:30.750 --> 00:07:37.389
The EFI environment is a little bit different
than the standard kernel environment.

00:07:37.389 --> 00:07:43.829
The processor is running in a virtual mode, but
physical memory is all mapped one to one directly.

00:07:43.829 --> 00:07:49.449
So all the physical memory gets mapped in
by EFI, and it lives at a certain address,

00:07:49.449 --> 00:07:53.810
loads any programs at some address that it picks.

00:07:53.810 --> 00:07:58.399
And then any devices are mapped in
somewhere in memory the EFI controls.

00:07:58.399 --> 00:08:03.489
So it's sort of similar to operating
system mode, but not exactly.

00:08:03.490 --> 00:08:07.319
Hopefully you won't be writing any EFI
applications, so you won't care about this.

00:08:07.319 --> 00:08:09.750
If you are, see us afterwards.

00:08:09.750 --> 00:08:12.350
We know who you are.

00:08:12.350 --> 00:08:19.000
Since our first Intel Machines we've had EFI
one point oh compliance, and any EFI option runs

00:08:19.000 --> 00:08:23.029
that follow the EFI spec should
just work as you would expect.

00:08:23.029 --> 00:08:29.939
We do encourage you to use EBC, the EFI byte code
compiler, which would give you the ability to run

00:08:29.939 --> 00:08:32.480
on both 32- and 64-bit machineds.

00:08:32.480 --> 00:08:36.310
So that's very important now that we've
started introducing 64-bit EFI

00:08:36.309 --> 00:08:39.159
with the new Macbook Pros that came out recently.

00:08:39.159 --> 00:08:49.219
And in the future we do plan to meet the UEFI two point oh
spec, which if you go to Tianocore.org or UEFI dot org.

00:08:49.220 --> 00:08:54.889
You can download that gigantic spec, and
see just exactly how much work that is.

00:08:54.889 --> 00:08:57.240
But it has some nice features in
it that we've been working on.

00:08:57.240 --> 00:09:01.789
We're a member of the UEFI consortium,
and so we'll be working towards making all

00:09:01.789 --> 00:09:04.230
of our products compliant with that in the future.

00:09:04.230 --> 00:09:09.050
And that also means if you are developing a
graphics card, then we would encourage you

00:09:09.049 --> 00:09:15.259
to use the new graphics output protocol, which is a
replacement for the old UGA, if you know what that is.

00:09:15.259 --> 00:09:19.929
If you don't know what that is,
then that's probably a good thing.

00:09:19.929 --> 00:09:24.539
So EFI's whole job is to do one thing, to boot your system.

00:09:24.539 --> 00:09:25.399
And what does that mean?

00:09:25.399 --> 00:09:29.490
That means to load some program and run it once.

00:09:29.490 --> 00:09:38.080
And to EFI, a program is an EFI application, a PE
(inaudible) executable that has the EFI header on it.

00:09:38.080 --> 00:09:43.180
And so that could be the OS loader, but
it also could be a diagnostic program,

00:09:43.179 --> 00:09:47.079
a partition utility, it could be a firmware updater.

00:09:47.080 --> 00:09:52.670
That's how we update the firmware on your Machine is we
actually execute a separate EFI program that does that.

00:09:52.669 --> 00:09:59.360
Could be a shell, you can download the shell from the
tiana core website, it could be pong, it could be anything.

00:09:59.360 --> 00:10:03.310
But in normal usage it's gonna be the OS loader.

00:10:03.309 --> 00:10:11.829
And the way that EFI finds things is by default
it has a search path built into it to look

00:10:11.830 --> 00:10:14.040
for the one application that it's gonna load.

00:10:14.039 --> 00:10:19.110
So by default it goes through the local
disks and looks at each partition.

00:10:19.110 --> 00:10:22.720
First, if it's an HFS partition
it looks for a blessed file.

00:10:22.720 --> 00:10:29.060
And if you're not familiar with HFS, a blessed file is
just a file that is marked in the volume header in an easy

00:10:29.059 --> 00:10:32.819
to find way for a simple boot loader program.

00:10:32.820 --> 00:10:37.500
Or if there's not a blessed file, then it
looks in a series of paths on the disk,

00:10:37.500 --> 00:10:42.389
and that's also specified by the EFI specification.

00:10:42.389 --> 00:10:51.590
Or if you tell it explicitly what to look for, then you can
set an NV RAM variable that will point directly to the file

00:10:51.590 --> 00:10:57.370
that you want, or to a partition, or to a device
that it will then prefer in its search order.

00:10:57.370 --> 00:11:03.810
Or you can interactively affect the search order
that it uses to look for the boot program by holding

00:11:03.809 --> 00:11:09.969
down the option key to get the boot picker, you can
hold the N key to force it to loon on the network first,

00:11:09.970 --> 00:11:17.680
the C key which used to be CD but now is any optical
media, or the D key to prefer loading a diagnostic program.

00:11:17.679 --> 00:11:25.629
So all of these are ways to sort of affect the
order that EFI itself looks for the boot program.

00:11:25.629 --> 00:11:32.080
Things that could go wrong here are if it can't find
a program, so it could look on all these partitions

00:11:32.080 --> 00:11:36.200
and not find something that looks like an EFI boot program.

00:11:36.200 --> 00:11:43.570
Or you could have pointed it to a partition that didn't have
a blessed file on it, and it couldn't find a file in all

00:11:43.570 --> 00:11:47.140
of the locations that it thought it should look in.

00:11:47.139 --> 00:11:49.759
Or it could load the program, and the program could fail.

00:11:49.759 --> 00:11:56.529
So for example if the boot loader runs, but then can't load
any of its resources, then it will return with an error code

00:11:56.529 --> 00:12:01.980
that then EFI will say oh okay, I'll give up
on that, and then continue on in its boot path.

00:12:01.980 --> 00:12:06.420
So for example, if you had two partitions, and
you load the boot loader from one and it fails,

00:12:06.419 --> 00:12:09.429
then it will fall back to loading from the other partition.

00:12:09.429 --> 00:12:11.229
So it's always trying to find something to do.

00:12:11.230 --> 00:12:15.860
It doesn't give up because it knows that your
Machine isn't very useful sitting there in EFI.

00:12:15.860 --> 00:12:21.620
So EFI's message to you that something
failed is the flashing folder

00:12:21.620 --> 00:12:25.039
with a question mark, which it will flash on every failure.

00:12:25.039 --> 00:12:28.399
And then once it gives up and can't find
anything, that's when you see it sitting there

00:12:28.399 --> 00:12:31.720
with the flashing folder that looks very sad.

00:12:33.389 --> 00:12:37.230
But let's assume that it's able to find
something to boot, which is the normal case.

00:12:37.230 --> 00:12:41.320
We'll move on to stage two, which is the boot loader,

00:12:41.320 --> 00:12:44.760
which is gonna load the kernel
environment and switch to the kernel.

00:12:47.250 --> 00:12:53.710
So the EFI booter is an EFI application
that's actually delivered along with the OS.

00:12:53.710 --> 00:13:00.150
Conceptually its part of the OS, the booter
is on the DVD that you got with Leopard on it.

00:13:00.149 --> 00:13:07.179
And it's responsible for getting the OS
into the real part of the operating system.

00:13:07.179 --> 00:13:14.129
So it's insulation for the kernel and the rest of
the system from knowing too much about how EFI works.

00:13:14.129 --> 00:13:19.649
So most of the knowledge of EFI interfaces
is encapsulated in the boot loader.

00:13:19.649 --> 00:13:24.049
And as I mentioned before, it's the one
that draws the Apple logo on the screen.

00:13:24.049 --> 00:13:27.799
So it uses the frame buffer to draw that
as one of the first things that it does.

00:13:27.799 --> 00:13:33.439
So once you see that, you know that the booter was
found, and it actually was able to execute far enough

00:13:33.440 --> 00:13:36.280
to find the screen and draw something on it.

00:13:36.279 --> 00:13:42.189
And its job is to load the kernel
and the drivers, or kexts,

00:13:42.190 --> 00:13:46.720
and execute them so that you can
actually do something more useful.

00:13:46.720 --> 00:13:53.720
The way that it loads these things
depends on a couple of factors.

00:13:53.720 --> 00:14:00.300
So by default, the booter is gonna look on the same
device that it came from, which is the normal case.

00:14:00.299 --> 00:14:03.819
If you have one partition with the kernel
and the booter and everything else on it,

00:14:03.820 --> 00:14:09.690
then the boot partition is gonna be the same
as the one that you load the kernel from.

00:14:09.690 --> 00:14:16.350
So you can override that and specifically tell it oh
I want you to load the kernel from some other place,

00:14:16.350 --> 00:14:19.100
which is specified as an EFI device path.

00:14:19.100 --> 00:14:21.139
So you can override all of these behaviors.

00:14:21.139 --> 00:14:23.819
But the default is to do kind of the usual thing.

00:14:23.820 --> 00:14:29.430
So it's gonna load the kernel into memory at the place
where the kernel wants to go, which is a specific address,

00:14:29.429 --> 00:14:33.359
and then it's gonna load the drivers
after the kernel in one of three ways.

00:14:33.360 --> 00:14:39.379
Either the kernel and drivers all together as
one package, which is called a kernel cache,

00:14:39.379 --> 00:14:46.129
which is one file with the kernel and all the drivers
with all the symbols resolved, and that's the best,

00:14:46.129 --> 00:14:49.210
that's the fastest and the usual
way when you're booting your system.

00:14:49.210 --> 00:14:54.180
It can load the kernel as a separate file and
then a driver package called an M kext,

00:14:54.179 --> 00:14:59.109
which is basically all of the boot
drivers present on the system.

00:14:59.110 --> 00:15:04.490
And that's the next best way cause it's faster to just
load one file than to pick through and do it the third way,

00:15:04.490 --> 00:15:08.049
which is to load the kernel and then
each driver individually off of the disk.

00:15:08.049 --> 00:15:12.169
So it will actually scan through the
extensions folder, look at each driver's P list,

00:15:12.169 --> 00:15:16.909
decide whether it should be loaded,
and then load its binary into memory.

00:15:16.909 --> 00:15:18.799
I'll discuss each of these ways here.

00:15:18.799 --> 00:15:24.819
So the kernel cache is the preferred
method because it's the fastest.

00:15:24.820 --> 00:15:33.080
It lives in system library caches com dot Apple dot
kernel caches, which if you say it three times fast, no.

00:15:33.080 --> 00:15:35.490
That contains both the kernel and the drivers as I said,

00:15:35.490 --> 00:15:41.360
and the file name of that cache file is
a hash of a couple of different things.

00:15:41.360 --> 00:15:47.519
It has to do with the path of the kernel,
and another value which represents the state

00:15:47.519 --> 00:15:49.710
of the system, which is passed in by EFI.

00:15:49.710 --> 00:15:55.420
And the idea of all that is to make it easy to
determine whether the cache is valid or not,

00:15:55.419 --> 00:16:02.229
because it has to go with the path of the kernel
and the system to know that it represents drivers

00:16:02.230 --> 00:16:04.580
that are okay for the state of this system.

00:16:04.580 --> 00:16:12.780
So the OS builds this once the system is all the way up, and
it examines the current state of the drivers in the system.

00:16:12.779 --> 00:16:16.449
Waits a little while after your system
comes up to give it a chance to settle,

00:16:16.450 --> 00:16:22.750
and then takes all of the currently running drivers and
links them together with the kernel that's present on disk

00:16:22.750 --> 00:16:25.769
on your system, and stores it in this cache file.

00:16:25.769 --> 00:16:30.329
And the result is a set of drivers and the
kernel that's good just for this one Machine.

00:16:30.330 --> 00:16:33.710
So it's intended to be local to that Machine.

00:16:33.710 --> 00:16:40.269
The second method is a multiple kext archive of all
the drivers, which is usually present on your system.

00:16:40.269 --> 00:16:45.039
It gets rebuilt whenever you change
anything in system library extensions,

00:16:45.039 --> 00:16:53.750
and this kext M kext cache is basically all of the drivers
in the extensions folder that have a certain property,

00:16:53.750 --> 00:16:57.970
which is OS bundle required, which
is not equal to safe boot.

00:16:57.970 --> 00:17:01.509
Which sounds kind of counter intuitive,
but really that's right.

00:17:01.509 --> 00:17:07.259
Because it means anything that's needed for a
local route or a network route, or a console.

00:17:07.259 --> 00:17:09.819
So it's any driver that could be
used during the boot process.

00:17:09.819 --> 00:17:16.579
So that would leave out things like sound drivers, or
something else that isn't required to either load a file

00:17:16.579 --> 00:17:21.000
to boot from, or interact with the user at boot time.

00:17:21.000 --> 00:17:28.230
And that is potentially a bigger set of drivers than
are strictly needed for this particular Machine.

00:17:28.230 --> 00:17:34.710
But that's useful because if you have a group of
Machines, like you're net booting all Machines

00:17:34.710 --> 00:17:37.410
that could run Leopard, that's probably what you want.

00:17:37.410 --> 00:17:39.170
So it's good in that case.

00:17:39.170 --> 00:17:45.460
But you may still need to load other drivers later, like
the sound driver that I mentioned is another example,

00:17:45.460 --> 00:17:48.410
something that wouldn't be in the M
kext, but might get loaded at run time.

00:17:48.410 --> 00:17:52.730
And then the worst case is the individual driver loading.

00:17:52.730 --> 00:17:58.650
So if the caches are missing or invalid because you took
the disk and you plugged it into a different Machine,

00:17:58.650 --> 00:18:01.980
or some other reason, or you rearranged
the hardware in your Machines,

00:18:01.980 --> 00:18:05.680
so now the hash of your hardware
state doesn't match any more.

00:18:05.680 --> 00:18:10.380
Then the booter will fall back to loading every
driver that has basically the same criterion

00:18:10.380 --> 00:18:14.200
that the M kext is built with, which is OS
bundke required not equal to safe boot.

00:18:14.200 --> 00:18:16.519
And that's quite slow.

00:18:16.519 --> 00:18:23.339
The HFS implementation in the firmware
is you know, not OS level.

00:18:23.339 --> 00:18:25.349
It's not intended to be.

00:18:25.349 --> 00:18:35.329
So just as a sort of a special case here, let me discuss
safe sleep, which is almost just like regular booting.

00:18:35.329 --> 00:18:37.649
Most operating systems call this hibernation.

00:18:37.650 --> 00:18:42.120
And so you may know that this happens, when you put
your Machine to sleep it writes a hibernation image,

00:18:42.119 --> 00:18:46.019
so in case your battery fails, you'll
be able to come back and recover.

00:18:46.019 --> 00:18:53.150
So when you come back up after that, it's a lot
like a regular boot in that there's a file on disk

00:18:53.150 --> 00:18:57.780
that has the kernel and the drivers, it just
happens to have a lot of other stuff in it too.

00:18:57.779 --> 00:19:04.609
So the booter notices that the kernel set out a special
flag saying hey by the way, this is a hibernation boot.

00:19:04.609 --> 00:19:09.409
So the booter says okay, I know what to do with
that, it goes and finds the hibernation file.

00:19:09.410 --> 00:19:17.310
Loads that into memory in preference to the usual kernel
cache or whatever else, and it's bigger but it loads as much

00:19:17.309 --> 00:19:23.289
of that as it can, and then leaves some notes
behind, shuffles the EFI run time pages a little bit,

00:19:23.289 --> 00:19:26.200
and then jumps into the kernel, a lot like a normal boot.

00:19:26.200 --> 00:19:33.180
So it's really not that much of a special case, except that
the booter does draw that graphic of the grayed out screen

00:19:33.180 --> 00:19:38.360
and the little progress bar, since the kernel
isn't there yet, and it takes a little bit longer

00:19:38.359 --> 00:19:41.949
than would be comfortable if you didn't
know that something was happening.

00:19:41.950 --> 00:19:46.490
From the I/O Kit perspective, looks
just like wake from sleep.

00:19:46.490 --> 00:19:50.309
Your driver says oh I woke up, and
you have to reset your hardware.

00:19:50.309 --> 00:19:53.339
So it's not that much different.

00:19:53.339 --> 00:19:55.529
Net booting is another special case.

00:19:55.529 --> 00:20:00.609
Again, it's real similar to local boot,
because you do the basic same set of things.

00:20:00.609 --> 00:20:03.099
You load the drivers and the kernel and jump to them.

00:20:03.099 --> 00:20:08.209
But because the EFI APIs are a little bit
different for loading files over the network,

00:20:08.210 --> 00:20:11.539
the booter does have to know oh
I'll call these instead of that.

00:20:11.539 --> 00:20:16.299
And it also knows that it's probably not worth trying
to load individual drivers, so it never tries that.

00:20:16.299 --> 00:20:21.889
It only will ever load either the kernel
cache or the M kext, the kernel plus M kext.

00:20:21.890 --> 00:20:25.660
And it does load its configuration
file so you can tell it what to do.

00:20:25.660 --> 00:20:31.380
But other than that, it loads it into memory,
and jumps, and leaves a little extra information

00:20:31.380 --> 00:20:35.950
for the kernel saying oh I net booted and
here's my packet that I got from the server.

00:20:35.950 --> 00:20:39.759
Otherwise the flow of things is pretty much the same.

00:20:39.759 --> 00:20:43.869
So what knobs do you have to turn on the booter?

00:20:43.869 --> 00:20:49.139
As I mentioned before, there's some NV RAM variables
that you can set that control the booter's behavior.

00:20:49.140 --> 00:20:53.390
So boot args you may know about, that's
usually thought of as controlling the kernel.

00:20:53.390 --> 00:21:01.090
But also the booter looks at that to see if you have
set the verbose flag, and it will use that to clear

00:21:01.089 --> 00:21:04.449
out the graphical screen and draw
a text console of what it's doing.

00:21:04.450 --> 00:21:08.940
And if you've never used verbose mode before,
that's a really good debugging tool to use.

00:21:08.940 --> 00:21:13.460
Verbose mode to see what's happening, because then
you can tell very clearly oh did the booter fail?

00:21:13.460 --> 00:21:14.299
Did the kernel fail?

00:21:14.299 --> 00:21:17.970
You know, where am I in the process where
something went wrong, instead of just the screen

00:21:17.970 --> 00:21:20.329
with the spinning gear and that's not very helpful.

00:21:20.329 --> 00:21:27.339
So other things you can set are the paths to the
kernel cache, you can set the path to load the kernel,

00:21:27.339 --> 00:21:34.149
you can set the path to the M kext, and even on Power
PC open firmware you can also set the kernel path.

00:21:34.150 --> 00:21:38.930
This, in case you didn't get it already,
this is mostly about Intel and Leopard.

00:21:38.930 --> 00:21:45.240
So I haven't really said anything about open
firmware, hopefully that's okay with everyone.

00:21:45.240 --> 00:21:51.589
There is also a P list file that the booter will
look at in library preferences system configuration.

00:21:51.589 --> 00:21:57.279
And this P list file can be used to set pretty much all
of the things that you can set with NV RAM variables.

00:21:57.279 --> 00:22:02.859
But the booter will prefer NV RAM over the files so
that you can override them from the command line.

00:22:02.859 --> 00:22:07.189
And normally all of this is set
by the bless command line tool.

00:22:07.190 --> 00:22:13.110
So if you're thinking about trying to do this to you know,

00:22:13.109 --> 00:22:16.959
alter the way that the startup
disk is set, please use bless.

00:22:16.960 --> 00:22:20.789
Bless knows the right thing to do, it has a
pretty good interface for setting all this stuff.

00:22:20.789 --> 00:22:23.899
So check out the bless man page and see what it does.

00:22:23.900 --> 00:22:27.500
It gives you a lot of control over
being able to do things like reboot once

00:22:27.500 --> 00:22:30.210
into a special program, like the firmware updater.

00:22:30.210 --> 00:22:31.630
Check that out.

00:22:31.630 --> 00:22:39.400
But if you know what you're doing, you can set NV
RAM variables explicitly with the NV RAM command.

00:22:39.400 --> 00:22:44.870
Now this deserves a little digression, because the
way NV RAM variables work is a little bit different

00:22:44.869 --> 00:22:46.109
than the days of Power PC.

00:22:46.109 --> 00:22:55.549
EFI defines what it calls non-volatile variables,
which have a name and a value, but also a GUID,

00:22:55.549 --> 00:23:00.019
which is a name space so that you can set a
whole name space of variables and not collide.

00:23:00.019 --> 00:23:03.509
And the intention is that each
vendor will have its own name space.

00:23:03.509 --> 00:23:09.539
So what we did is we set one name space for the
ones that are visible from the operating system.

00:23:09.539 --> 00:23:15.569
So using the NV RAM command from the command
line operates on all the variables in that space.

00:23:15.569 --> 00:23:24.950
But the variables that control for instance how EFI
finds the boot file are in a separate EFI name space.

00:23:24.950 --> 00:23:27.069
So how do you set those things?

00:23:27.069 --> 00:23:30.679
Well the NV RAM driver does a little
bit of magic behind the scenes.

00:23:30.680 --> 00:23:35.400
So if you set a variable with a name starting with EFI,

00:23:35.400 --> 00:23:38.640
then it knows oh this is one that
I need to do something special to.

00:23:38.640 --> 00:23:39.850
And it will do two things.

00:23:39.849 --> 00:23:45.829
One if it's EFI boot device, then it
knows to set the EFI name space variables

00:23:45.829 --> 00:23:57.439
that control how the firmware loads the boot loader, and
also it will translate EFI something to EFI something data

00:23:57.440 --> 00:24:04.440
by taking a matching dictionary that's stored in the
variable, and finding the I/O Kit device for that,

00:24:04.440 --> 00:24:08.090
and then trying to translate that into an EFI device path.

00:24:08.089 --> 00:24:10.990
And I'll show you an example of that.

00:24:10.990 --> 00:24:13.519
And again, bless knows how to do this, so.

00:24:13.519 --> 00:24:20.809
If you want to see an example of it you can go on your own
Machine and set, with startup disk set the startup disk

00:24:20.809 --> 00:24:25.750
for your Machine and see what variables
that bless set for you.

00:24:25.750 --> 00:24:29.779
Maybe you're doing it right now.

00:24:29.779 --> 00:24:30.539
Here's an example.

00:24:30.539 --> 00:24:36.389
If you wanted to boot off of disk zero S three,
then the value of EFI boot device that would get set

00:24:36.390 --> 00:24:40.840
for that is this big ugly matching dictionary thing.

00:24:40.839 --> 00:24:47.959
But basically it's, if you're familiar with using I/O Kit
from user space, it's how you would construct a dictionary

00:24:47.960 --> 00:24:53.049
that would match properties that refer
to a specific device in the device tree.

00:24:53.049 --> 00:24:58.279
So in this case it's a child of an IO
media device with a particular UUID.

00:24:58.279 --> 00:25:05.240
And so the platform expert was able to find that and
translate that into this ugly looking binary thing,

00:25:05.240 --> 00:25:13.819
which if you speak EFI, you would see it refers to
some PCI devices and a partition, and it just works.

00:25:13.819 --> 00:25:18.990
So it will translate this to also a
variable called boot zero zero eight zero

00:25:18.990 --> 00:25:24.380
in the EFI space, which is what EFI is looking for.

00:25:24.380 --> 00:25:26.950
More booter knobs you can do.

00:25:26.950 --> 00:25:32.730
You can hold down command S or command V to tell the
booter that hey I want to boot in either single user

00:25:32.730 --> 00:25:39.599
or verbose mode, and command V is the simplest way
to just see what it's doing, so you can try that.

00:25:39.599 --> 00:25:47.209
And that's interpreted by the booter, and then added to
the boot args variable for the kernel to notice also.

00:25:47.210 --> 00:25:52.350
And that'll switch to the text console
both in the booter and the kernel.

00:25:52.349 --> 00:25:58.199
Shift will set safe mode and cause it to ignore
any caches, like the kernel cache or the M kext.

00:25:58.200 --> 00:26:03.049
And it will also add minus X to the boot
args, so the kernel will know to do that.

00:26:03.049 --> 00:26:09.700
And then other keys are actually interpreted by EFI
itself before the booter, so the N, T, C option key,

00:26:09.700 --> 00:26:17.170
those are all interpreted by EFI itself and not the booter.

00:26:17.170 --> 00:26:21.410
So, this is pretty much the end of the booter story.

00:26:21.410 --> 00:26:25.910
At this point after it's loaded the kernel
and the drivers, it leaves behind some notes

00:26:25.910 --> 00:26:31.970
for the kernel saying the memory map that it
got from EFI, a pointer to the ACPI table,

00:26:31.970 --> 00:26:39.750
which is a standard PC style table that refers to some
of the hardware that you can's actually easily probe

00:26:39.750 --> 00:26:43.039
on the system, where it loaded the drivers in memory,

00:26:43.039 --> 00:26:47.299
the UUID of the boot volume, and
the path that the booter came from.

00:26:47.299 --> 00:26:53.859
It leaves these all in the device tree, along with the
location of the frame buffer and the screen resolution.

00:26:53.859 --> 00:26:58.539
And then it tells EFI all right,
I'm done with you, go kill yourself.

00:26:58.539 --> 00:27:04.509
So EFI closes itself down, frees all the resources
it was using, except for a very tiny amount it uses

00:27:04.509 --> 00:27:11.930
for run time services that are used to run NV RAM,
and maybe some other things, but a very small amount.

00:27:11.930 --> 00:27:17.400
And then it jumps into the kernel, and that's
where the next phase of the story starts,

00:27:17.400 --> 00:27:21.570
which I will turn you over to Soren Spies
for kernel, rooting, and user land.

00:27:21.569 --> 00:27:22.819
( Applause )

00:27:22.819 --> 00:27:30.919
>> Thank you Curtis.

00:27:30.920 --> 00:27:36.710
So, we're up to stage three of the boot process.

00:27:36.710 --> 00:27:39.809
That's we've got the kernel in
memory, and we've just jumped to it,

00:27:39.809 --> 00:27:43.750
and we've gotten a few little hints
about what the system looks like.

00:27:43.750 --> 00:27:50.450
But the main thing that the booter has done for
us is it's loaded the correct Mach-O segment

00:27:50.450 --> 00:27:53.950
out of the mach kernel file, and
jumped to the right starting address.

00:27:53.950 --> 00:27:58.019
So on a PowerPC Machine we'd be executing Power
PC, but we're gonna talk basically on Intel.

00:27:58.019 --> 00:28:00.599
So the good thing it did for us is
it put us into the very beginning

00:28:00.599 --> 00:28:05.059
of a low level assembly, let's
start our Intel initialization.

00:28:05.059 --> 00:28:10.440
So the kernel comes up, it has a few clues, but
basically all that stuff that EFI did is gone, right?

00:28:10.440 --> 00:28:13.910
It tore itself down, all its device
drivers are gone, all that kind of stuff.

00:28:13.910 --> 00:28:17.080
The first thing you're going to see is that little gear.

00:28:17.079 --> 00:28:20.609
So the little gear will start spinning,
and that means that we at least were able

00:28:20.609 --> 00:28:28.339
to find the frame buffer the EFI told us about, and that
we were also able to get scheduling and threads started up.

00:28:28.339 --> 00:28:33.309
So some of the things we have to do is reinitialize
virtual memory to get it more into the model that we want

00:28:33.309 --> 00:28:40.460
for the kernel, we start timers, we install our exception
vectors in case there's any traps that the processor needs

00:28:40.460 --> 00:28:45.430
to take, it'll be able to call the kernel and say hey, we
had this kind of fault, what do you want me to do about it?

00:28:45.430 --> 00:28:49.120
And then we go ahead and we fire up I/O Kit.

00:28:49.119 --> 00:28:53.429
Now some of you who write kexts as
drivers know something about I/O Kit,

00:28:53.430 --> 00:28:57.460
some of you who write user land code
that probes devices know about I/O Kit.

00:28:57.460 --> 00:29:02.789
But the important thing from a booting standpoint
is that I/O Kit goes out and finds devices.

00:29:02.789 --> 00:29:07.700
Meanwhile, the main thread continues on in a BSD init call.

00:29:07.700 --> 00:29:14.990
We've basically started up the scheduler and the mach task
stuff, so we've got multiple threads running in the kernel.

00:29:14.990 --> 00:29:19.089
But the BSD init starts bringing up
more of the BSD part of the world.

00:29:19.089 --> 00:29:23.990
So let's talk a little bit about what I/O Kit
does in order to determine what's on the system.

00:29:23.990 --> 00:29:31.569
So we mentioned that we get the ACPI tables,
among other bits of information, from the booter.

00:29:31.569 --> 00:29:35.809
And basically the whole bunch of threads,
we got the main thread waiting over here,

00:29:35.809 --> 00:29:38.129
cause it can't do anything until I/O Kit finds devices.

00:29:38.130 --> 00:29:41.220
Bunch of threads go out, and they start matching.

00:29:41.220 --> 00:29:47.220
And in this case basically they're saying oh look,
here's a device, the ACPI table as interpreted

00:29:47.220 --> 00:29:50.980
by the platform expert, there's a special
driver that is kind of the first driver.

00:29:50.980 --> 00:29:57.710
And it says here's an ACPI table, and now I'll build some
nice tree of device information that you can look at.

00:29:57.710 --> 00:30:02.960
And then I/O regs or I/O registry explorer will
let you look at that same I/O Kit registry.

00:30:02.960 --> 00:30:07.160
So we start looking at all these devices, and we
say well which drivers want to drive these devices?

00:30:07.160 --> 00:30:12.090
So we brought all those boot drivers into
the kernel, we have all their personalities,

00:30:12.089 --> 00:30:19.240
all their P list data that says well, I'm a USB driver,
or I'm a hard disk driver, or I'm a sound card driver.

00:30:19.240 --> 00:30:23.870
Although the sound card driver is being ignored right
now cause in trying to boot we don't really care

00:30:23.869 --> 00:30:25.509
about sound cards, they're not important for booting.

00:30:25.509 --> 00:30:30.079
The only noise that we made was
the one a long time ago in EFI.

00:30:30.079 --> 00:30:34.389
So we bring up these personalities,
and we look at them, we say oh look,

00:30:34.390 --> 00:30:35.970
these drivers claim to be able to do this thing.

00:30:35.970 --> 00:30:39.670
And then we go over here and our threads are
looking at all these different processes,

00:30:39.670 --> 00:30:41.740
or all these different devices, excuse me.

00:30:41.740 --> 00:30:46.579
And we say aha, this device looks
like this driver, those are a match.

00:30:46.579 --> 00:30:51.309
And we say aha, that driver and this driver
and this device, connect them together.

00:30:51.309 --> 00:30:54.909
So all the threads are connecting
with all of the driver personalities.

00:30:54.910 --> 00:30:59.210
And in some cases we have what's called active matching,
where it's not just the description of the driver

00:30:59.210 --> 00:31:04.360
that matches on the device, but it's actually, your
driver can run a little bit of code and say well I want

00:31:04.359 --> 00:31:07.159
to send a command to that device and
see if it responds in a certain way.

00:31:07.160 --> 00:31:10.090
Is that my, you know, am I the
right vendor or that kind of thing.

00:31:10.089 --> 00:31:11.990
So you can probe it actively.

00:31:11.990 --> 00:31:16.620
But the important thing is these threads
are going on, and devices are appearing.

00:31:16.619 --> 00:31:20.259
Let's take a little picture of this.

00:31:20.259 --> 00:31:28.539
So the important thing to notice here is that unlike
the previous time during EFI, EFI's goal was to boot.

00:31:28.539 --> 00:31:33.849
So the only thing that it wanted to do was get at
RAM, it didn't really, it was one to one mapped,

00:31:33.849 --> 00:31:36.490
it wanted to get at the graphics card so
it could draw a few things on the screen.

00:31:36.490 --> 00:31:40.140
But all it really cared about was the boot path.

00:31:40.140 --> 00:31:46.810
It was saying the shortest number of device drivers I can
get going on the boot path to actually get to my disk.

00:31:46.809 --> 00:31:50.089
The kernel on the other hand, wants
all drivers to match and load.

00:31:50.089 --> 00:31:52.699
So it goes ahead and initializes
everything, all the drivers,

00:31:52.700 --> 00:31:55.110
all the boot drivers anyway are
going ahead and doing their thing.

00:31:55.109 --> 00:31:59.389
So we start bringing up networking card
stuff, and things that we might not need

00:31:59.390 --> 00:32:03.070
to boot this time, but could be needed for boot.

00:32:03.069 --> 00:32:08.869
We do have a four gigabyte address space, and we've begun
mapping in in the more traditional virtual memory style.

00:32:08.869 --> 00:32:12.929
If we need pages from physical RAM, we go
ahead and map them in to the address space

00:32:12.930 --> 00:32:16.820
in a particular spot, and we use them as necessary.

00:32:16.819 --> 00:32:21.389
The video card remains mapped in to a
frame buffer area that we can write to.

00:32:21.390 --> 00:32:25.940
So let's talk a little bit more
about the matching that's going on.

00:32:25.940 --> 00:32:34.130
We got the matching, and what we're waiting for, we have
that description of the boot device that we got from EFI,

00:32:34.130 --> 00:32:36.270
it told, or the EFI environment
where the booter was running.

00:32:36.269 --> 00:32:41.240
The booter said well I booted off of such and
such a volume, and here's a way of describing it,

00:32:41.240 --> 00:32:43.940
or I booted off the network, and
here's a way of describing it.

00:32:43.940 --> 00:32:53.180
So this one thread, this BSD init set comf thread gets
stuck in I/O find BSD root, and it calls wait for service

00:32:53.180 --> 00:32:55.240
with a dictionary that describes a thing.

00:32:55.240 --> 00:32:58.900
So if it was a network device,
it's a network matching dictionary,

00:32:58.900 --> 00:33:01.759
if it's a disk device, it's a disk matching dictionary.

00:33:01.759 --> 00:33:05.150
But this is very similar to the
user land calls that you can make.

00:33:05.150 --> 00:33:08.490
You say well I'm waiting for a certain device
to come online, it looks like a certain thing.

00:33:08.490 --> 00:33:10.750
The kernel does this internally, and it's waiting.

00:33:10.750 --> 00:33:13.009
So threads are going around looking for devices,

00:33:13.009 --> 00:33:18.129
and this one BSD init thread is
waiting for the root device to appear.

00:33:18.130 --> 00:33:26.940
So eventually, ideally, that device does appear, and
you know, the matching continues you know, after that.

00:33:26.940 --> 00:33:28.940
We don't you know, we just let that go.

00:33:28.940 --> 00:33:34.070
But to make progress on the boot, we go ahead and we say
aha, here's our root device, and we take a look at it sort

00:33:34.069 --> 00:33:39.339
of I/O Kit style, and we say well, this has a certain
BSD information, and we'll go ahead and pass that off

00:33:39.339 --> 00:33:45.789
to the BSD code and say here you go BSD,
let's fire up your virtual file systems.

00:33:45.789 --> 00:33:51.069
And you know, here's slash so you can start
going ahead and building up all the things

00:33:51.069 --> 00:33:52.849
that you're gonna put on top of their layer.

00:33:52.849 --> 00:33:56.139
Even though, so we basically are able to do a mount.

00:33:56.140 --> 00:34:00.980
So our HFS volume is now mounted
on slash, normally HFS volume.

00:34:00.980 --> 00:34:05.610
We also go ahead and create slash
dev, and we attach it to I/O Kit.

00:34:05.609 --> 00:34:10.449
So as the I/O Kit matching continues, you'll
see things dynamically appearing in slash dev,

00:34:10.449 --> 00:34:14.569
new disks that you plug in will appear over there.

00:34:14.570 --> 00:34:19.510
If this goes wrong, what you'll tend
to see if you're in a regular boot,

00:34:19.510 --> 00:34:22.880
is you'll just see that gear spin
forever basically, well not forever.

00:34:22.880 --> 00:34:24.789
It spins for quite a long time.

00:34:24.789 --> 00:34:29.889
Eventually the kernel, even though it's still waiting,
just wait, wait, wait, it will put up a circle with a slash

00:34:29.889 --> 00:34:33.639
to it, and it'll say you know, I don't think I'm
ever gonna find anything, but I'm still waiting.

00:34:33.639 --> 00:34:39.779
If you do a verbose boot, you will see every thirty
seconds you know, still waiting for root device.

00:34:39.780 --> 00:34:46.120
And that's cause when they call wait for service, we have
a thirty second time out, but we just keep looping on that.

00:34:46.119 --> 00:34:53.440
So that, we got our root device, which means that
we've got our volume, our HFS volume probably.

00:34:53.440 --> 00:34:58.400
It's mounted, and now we want to
go ahead and start up user land.

00:34:58.400 --> 00:35:02.700
So basically we're gonna get launch D running, and
launch D's gonna take care of running a whole bunch

00:35:02.699 --> 00:35:06.289
of other processes to eventually get us logged in.

00:35:09.570 --> 00:35:16.080
So we know that we have that one address space, you know,
four gigabyte virtual address space, mappings, that's nice.

00:35:16.079 --> 00:35:20.369
And we know, most of us know you
know, we've got

00:35:20.369 --> 00:35:22.960
a separate address space for each
process that we're running.

00:35:22.960 --> 00:35:26.059
And we got to get from here to there.

00:35:26.059 --> 00:35:31.190
So the way that we create user land is sort
of like we pretend that we had a process.

00:35:31.190 --> 00:35:35.380
We say well if we had a process in
user land, what would we want it to do?

00:35:35.380 --> 00:35:39.660
Well we would want it to start up launch D for
us, because that's what we want to have happen.

00:35:39.659 --> 00:35:42.730
And so we go ahead and we set up a second address space.

00:35:42.730 --> 00:35:47.719
We create a process from the BSD standpoint and the task

00:35:47.719 --> 00:35:50.029
from the mach standpoint, and we
go ahead and we give it a thread.

00:35:50.030 --> 00:35:55.519
And we actually, we have an empty address
space with no mappings, and we say hey thread,

00:35:55.519 --> 00:36:00.349
why don't you jump into that process, into
that address space, go run in that space.

00:36:00.349 --> 00:36:06.940
This is generally a bad idea to jump into unmapped address
spaces with your thread, because it's just not gonna work.

00:36:06.940 --> 00:36:14.210
But we also set something called an asynchronous system
trap, which was, it's part of BSD, and it, or came from BSD,

00:36:14.210 --> 00:36:19.449
and it basically lets you run a little bit of
code right before you finish a system call.

00:36:19.449 --> 00:36:22.469
So normally you call in to make a
system call, you do the system call,

00:36:22.469 --> 00:36:25.459
and then you jump back out and you switch contexts.

00:36:25.460 --> 00:36:29.559
So this basically says after you've switched
into the kernel context of this process,

00:36:29.559 --> 00:36:32.190
but we're not actually in the address
space yet, run some code.

00:36:32.190 --> 00:36:36.440
And the code that we run is called load init program.

00:36:36.440 --> 00:36:41.150
And this is the one that's actually
going to magically get us into launch D.

00:36:41.150 --> 00:36:46.280
So what it does is it allocates a little bit
of RAM inside of this space, it's one page.

00:36:46.280 --> 00:36:51.360
It copies the string sbin launch D
out into this otherwise empty address space,

00:36:51.360 --> 00:36:59.470
and then it kind of makes it look as if this empty address
space was gonna call exec. So exec as you probably know

00:36:59.469 --> 00:37:04.250
on Unix, is the way that you can say
well here's my process, and I'm you know,

00:37:04.250 --> 00:37:07.489
I'm the shell, and I really want to run you know, LS.

00:37:07.489 --> 00:37:12.549
So what generally happens is you make a copy of
yourself, and then you call exec, which actually replaces

00:37:12.550 --> 00:37:15.530
that copy with the program you're running.

00:37:15.530 --> 00:37:19.230
So you fork, copy, and then exec LS.

00:37:19.230 --> 00:37:21.059
So LS blows away the shell.

00:37:21.059 --> 00:37:26.199
Now if the shell didn't really want to exist
any more, it could simply directly exec LS

00:37:26.199 --> 00:37:29.039
and it would be erased by the time you return.

00:37:29.039 --> 00:37:36.489
So we go ahead and we call exec DE, so it's almost like
there was a process, and it's got that string out there,

00:37:36.489 --> 00:37:45.319
so it looks as if maybe it had called into us asking
us to exec. And when it returns, it is actually,

00:37:45.320 --> 00:37:49.450
it's gone through the exec path, and the exec
path basically blows away this whole address space

00:37:49.449 --> 00:37:51.489
that barely existed in the first place.

00:37:51.489 --> 00:37:59.539
And it maps in, it reads in the Mach-O stuff, it maps
in the right segment in terms of text to execute,

00:37:59.539 --> 00:38:03.900
and it fires up DYLD, the dynamic
linker to link in all the other libraries.

00:38:03.900 --> 00:38:09.180
So we went from an empty address space, and then we
pretended it called exec, and exec took care of tearing

00:38:09.179 --> 00:38:10.859
down the address space and building us new process.

00:38:10.860 --> 00:38:16.329
So we use the same code to build that first
process as we would to build any other process.

00:38:16.329 --> 00:38:23.110
If this goes wrong, we'll panic here and say
that we couldn't launch process number one.

00:38:23.110 --> 00:38:26.789
Those of you familiar with Unix probably think oops,

00:38:26.789 --> 00:38:31.519
probably think of init as the first
process, and launch D as the new init.

00:38:31.519 --> 00:38:34.710
There's gonna be a session on it later,
you can learn all about how it works.

00:38:34.710 --> 00:38:39.070
We've had it for a little while, it was
in Tiger, but it's even more in Leopard.

00:38:39.070 --> 00:38:44.460
And it has replaced init, and mach init
for that matter, which was a mach thing.

00:38:44.460 --> 00:38:51.260
And what it does when it fires up is it does, checks
for system tuning files that needs to do system tuning,

00:38:51.260 --> 00:38:56.660
it kicks off something called boot cache
which tries to optimize the disk layout of it.

00:38:56.659 --> 00:39:03.389
I mention boot cache because basically you've, let's say
you've got like ten things that need to run to boot system.

00:39:03.389 --> 00:39:06.809
We look at all the, we watch all
the blocks coming off the disk.

00:39:06.809 --> 00:39:11.250
And whichever blocks were needed by those
ten things, on the next boot we go ahead

00:39:11.250 --> 00:39:13.769
and we fetch them all off in order on the disk.

00:39:13.769 --> 00:39:19.599
So if you looked at how launch D launched the jobs, you
might say well I would expect the first job that launched

00:39:19.599 --> 00:39:23.449
to run first, and the second job to you
know, make progress a little bit slower.

00:39:23.449 --> 00:39:28.909
But in fact boot cache is going to cause basically
whoever was on the disk first to get to run,

00:39:28.909 --> 00:39:35.250
because all of these process immediately basically
block waiting for pages to come off the disk to execute.

00:39:35.250 --> 00:39:43.179
So for those of you who don't know anything about launch
D, a very short summary is that there's two kinds of jobs.

00:39:43.179 --> 00:39:47.849
One is on demand, and this is generally the preferred
kind of job, it doesn't run until there's anything to do.

00:39:47.849 --> 00:39:55.869
For example, SSHD, launch D will bind onto a port
for you for example, and when a connection comes

00:39:55.869 --> 00:39:57.989
in it'll actually launch the daemon SSHD.

00:39:57.989 --> 00:40:00.339
The other, but otherwise SSHD doesn't run.

00:40:00.340 --> 00:40:03.090
The other kind of job is called keep alive.

00:40:03.090 --> 00:40:07.090
And keep alive jobs are, there's
a few critical jobs that we have

00:40:07.090 --> 00:40:09.510
to keep running all the time in
order for the system to work.

00:40:09.510 --> 00:40:17.050
One of them in this particular case is kext D. Kext
D is generally the system daemon that's running,

00:40:17.050 --> 00:40:20.820
it talks to the kernel, and if the kernel needs
a kernel extension loader, it'll say hey kext D,

00:40:20.820 --> 00:40:23.680
can you go get that kernel extension for me?

00:40:23.679 --> 00:40:26.659
And at early boot time, kext D has an important job,

00:40:26.659 --> 00:40:32.129
and that is remember we only had boot
personalities, we only had the boot drivers available.

00:40:32.130 --> 00:40:36.590
And so kext D's job at this point in time is to
say hey kernel, here's all the other personalities

00:40:36.590 --> 00:40:41.269
that weren't boot personalities, you might
need them for other devices to get plugged in.

00:40:41.269 --> 00:40:46.889
So at that time, once kext D sends that down,
that's the signal to the kernel that hey,

00:40:46.889 --> 00:40:50.109
user land is running, I can let it fetch kext for me.

00:40:50.110 --> 00:40:54.470
And also we have a busy count that
we decrement at that point,

00:40:54.469 --> 00:40:58.369
so that once all those threads
are done, we know that we're done.

00:40:58.369 --> 00:41:05.009
Cause if you imagine you only have the boot personalities,
and you run around and you find all the things you can drive

00:41:05.010 --> 00:41:08.360
with the boot kexts, you might still be
waiting for that sound card to come online.

00:41:08.360 --> 00:41:12.260
And if somebody in user space managed to look
for the sound card and it wasn't there yet,

00:41:12.260 --> 00:41:15.680
it might look like we had lost it, or it had disappeared.

00:41:15.679 --> 00:41:18.409
But in fact we just hadn't loaded
the driver personality yet.

00:41:18.409 --> 00:41:24.869
So we pretend that the I/O registry is busy until we've
actually sent down the rest of those personalities.

00:41:24.869 --> 00:41:29.619
This is a place also that you can plug
in, in terms of writing launch D jobs

00:41:29.619 --> 00:41:32.460
that run, ideally they should run on demand.

00:41:32.460 --> 00:41:38.260
We take advantage of this, if you look on your systems,
at least on Leopard systems, if you look in PS,

00:41:38.260 --> 00:41:45.640
you will see that the process ID of log in window
is actually lower than the process of window server.

00:41:45.639 --> 00:41:50.809
So log in window gets run out of ETC22IS (sp?)
TTYS, I think it's still there anyway.

00:41:50.809 --> 00:41:53.659
And basically it says okay, I'm
ready to log in on the system.

00:41:53.659 --> 00:41:57.559
So a server might not even run log in window
if it just had you know, text log ins.

00:41:57.559 --> 00:42:03.389
So log in window runs first, and then window
server has simply told launch D, and said hey,

00:42:03.389 --> 00:42:07.889
I'm available if anybody needs me, but I'm gonna stay
on disk, I'm not gonna run until somebody connects.

00:42:07.889 --> 00:42:10.299
So log in window runs, tries to connect to window server,

00:42:10.300 --> 00:42:14.680
and that actually runs the window server,
and you can see that if you look in PS.

00:42:14.679 --> 00:42:19.769
Once we have log in window running, I mean
there's many other demand jobs that come up,

00:42:19.769 --> 00:42:22.909
disk arbitration comes up to mount
the other disks for example.

00:42:22.909 --> 00:42:26.429
But that's not strictly necessary
to get you logged into the Finder.

00:42:26.429 --> 00:42:32.000
So we try to take the short path of log in
window pushing to get all the services it needs,

00:42:32.000 --> 00:42:35.909
so that we can get you logged in and
running apps as soon as possible.

00:42:35.909 --> 00:42:42.589
Now maybe the log in window comes up and makes you log in,
but most people, most users at least have automatic log in,

00:42:42.590 --> 00:42:45.090
and you're running the Finder and any other apps.

00:42:45.090 --> 00:42:51.680
So that sort of gets you through the kernel, we
constructed the launch D, and we got up to user space.

00:42:51.679 --> 00:42:52.960
And here's kind of what that looks like.

00:42:52.960 --> 00:42:58.309
We've got a bunch of address spaces, some might
be 64-bit, most are still thirty two bit.

00:42:58.309 --> 00:43:05.039
We've got our drivers are all matched up, we've got you
know, the video card, everything is available to us.

00:43:05.039 --> 00:43:08.170
But we've got now not just many
to many within one address space,

00:43:08.170 --> 00:43:12.570
but we've got many to many across all of the address spaces.

00:43:14.489 --> 00:43:21.949
So now that we've talked about the basic boot process,
let's talk a little bit more about that rooting thing.

00:43:21.949 --> 00:43:25.929
So we know that we can stop and wait for the root device.

00:43:25.929 --> 00:43:29.879
And we know that basically the thing we're
waiting for was told to us by the booter.

00:43:29.880 --> 00:43:35.230
So if you want to change it, we mentioned earlier
how you can change, I want to load the kernel off

00:43:35.230 --> 00:43:37.809
of a different place, I want to load
the booter off a different place.

00:43:37.809 --> 00:43:40.509
You can also say I want to root off of a different place.

00:43:40.510 --> 00:43:44.140
And you can put this into that boot P list
file, because the booter will read it,

00:43:44.139 --> 00:43:46.359
and then it will adjust the hints that it sends to you.

00:43:46.360 --> 00:43:52.180
You can give it a UUID if you use disk util
info, you'll see a UUID for your volumes.

00:43:52.179 --> 00:43:54.379
That's what it normally gives you.

00:43:54.380 --> 00:43:58.530
But if you store a specific one in your
boot P list, you'll root off of that volume.

00:43:58.530 --> 00:44:02.540
And you can also give it a whole I/O Kit
matching dictionary, if you want it to match

00:44:02.539 --> 00:44:07.230
on some strange device, you can get it to root off of that.

00:44:07.230 --> 00:44:14.469
There's also a sort of single use times, if you just want to
debug, you can use boot dash args again, and V RAM variable.

00:44:14.469 --> 00:44:17.939
You can set the root path to have a
firmware path in it that can point

00:44:17.940 --> 00:44:23.880
out to something like NFS or HTTP for network routing.

00:44:23.880 --> 00:44:28.480
You can also use RD, which is more BSD style name.

00:44:28.480 --> 00:44:33.800
And if you say RD equals UUID, you can put a boot
dash UUID right on the boot args command line,

00:44:33.800 --> 00:44:38.320
either from your EFI shell or from your NV RAM tool.

00:44:38.320 --> 00:44:45.030
So one place we might use this sort of alternate
routing, not just I came off of, booter came off a disk,

00:44:45.030 --> 00:44:52.280
described it to the kernel, kernel comes off the same disk,
or kernel roots off the same disk, net boot could use this.

00:44:52.280 --> 00:44:57.810
So if you wanted to, like I mentioned, you
could point off to some NFS or HTTP server.

00:44:57.809 --> 00:45:03.230
But what normally happens is that we get the name
from the boot services discovery protocol packet,

00:45:03.230 --> 00:45:07.539
which Curtis mentioned earlier, where you have
some net boot server that knows all of the,

00:45:07.539 --> 00:45:10.269
all the roots, all the root images that should be used.

00:45:10.269 --> 00:45:17.099
So this is the classic example of where we're
not just rooting on a basic disk device.

00:45:17.099 --> 00:45:24.569
And so the I/O find DSD root is waiting and then matching
on a network device, and mounting up a root from it.

00:45:24.570 --> 00:45:33.280
So we've talked about how boot and root are independent,
and we've actually formalized that a little bit,

00:45:33.280 --> 00:45:35.600
first with the Mac Pro, and now more in Leopard

00:45:35.599 --> 00:45:39.809
into something we call boot root,
with a not equal sign in the middle.

00:45:39.809 --> 00:45:45.500
So it's a new technology, and it basically takes
advantage of the fact that there's a separation.

00:45:45.500 --> 00:45:50.260
The firmware when it first comes up,
the ROM, it needs to get to the booter,

00:45:50.260 --> 00:45:52.330
but it doesn't really need to do a lot more than that.

00:45:52.329 --> 00:45:57.000
The booter runs with firmware, and it needs to get
to the kernel, so it'd be good to have the booter

00:45:57.000 --> 00:46:03.960
and the kernel together, those should probably live on
HFS to make things simple in the early boot environment,

00:46:03.960 --> 00:46:07.720
but it's not like the firmware
needs to get to the Finder, right?

00:46:07.719 --> 00:46:11.589
It has no use for the Finder, the
Finder is not a firmware app,

00:46:11.590 --> 00:46:14.210
and nor does it help bootstrap
the system like the kernel does.

00:46:14.210 --> 00:46:20.679
So the Finder could live off on some virtual volume,
or some network volume, or some other kind of storage

00:46:20.679 --> 00:46:23.319
that maybe the firmware doesn't know anything about.

00:46:23.320 --> 00:46:32.059
And so we've formalized this distinction with boot root,
and basically we allow the OS to live on an exotic volume,

00:46:32.059 --> 00:46:37.509
so called, whereas the firmware
looks for little helper partitions.

00:46:37.510 --> 00:46:40.140
And as far as the firmware cares, it's got a booter, right?

00:46:40.139 --> 00:46:40.969
That's all it cares about.

00:46:40.969 --> 00:46:43.119
So it says hey look, there's the booter, let's go.

00:46:43.119 --> 00:46:45.839
So it can boot the little helper partitions.

00:46:45.840 --> 00:46:50.620
And in the helper partition we store
a boot P list that gives the UUID

00:46:50.619 --> 00:46:52.739
of the virtual volume that we actually want to boot.

00:46:52.739 --> 00:46:58.459
So you want to boot some virtual volume, you start
the firmware pointed at a little helper partition,

00:46:58.460 --> 00:47:04.159
you put the UUID of the volume in the helper partition,
booter reads it, passes it to I/O find BSD root,

00:47:04.159 --> 00:47:07.069
and you end up rooted off of this other partition.

00:47:07.070 --> 00:47:09.130
So where do we use that?

00:47:09.130 --> 00:47:10.630
Oops, where do we use that?

00:47:10.630 --> 00:47:17.010
Apple RAID, most of you are probably familiar
with having multiple disks kind of acting as one.

00:47:17.010 --> 00:47:22.730
So this is how the Apple RAID partition layout is.

00:47:22.730 --> 00:47:27.710
So basically we've got the Apple under our RAID
partitions, which our Apple RAID kext matches on.

00:47:27.710 --> 00:47:32.889
And that then, it absorbs all of those,
and then it publishes this RAID boot.

00:47:32.889 --> 00:47:34.679
It says here you go system.

00:47:34.679 --> 00:47:36.419
But that's completely at the kernel level.

00:47:36.420 --> 00:47:40.550
So the firmware doesn't have any idea
about RAID boot, it only knows about,

00:47:40.550 --> 00:47:42.980
in this case, these little Apple boot partitions.

00:47:42.980 --> 00:47:47.840
So your firmware is willing to boot off
of basically two kinds of partitions,

00:47:47.840 --> 00:47:51.530
one is Apple underscore boot, and
one is Apple underscore HFS.

00:47:51.530 --> 00:47:59.310
If you hold down the option key on a system like
this, you'll actually see four volumes that look,

00:47:59.309 --> 00:48:04.070
that would say RAID boot one, RAID boot two, RAID boot
three, RAID boot four, representing each of the Apple boots.

00:48:04.070 --> 00:48:07.650
Because from the firmware perspective,
there are in fact four bootable volumes,

00:48:07.650 --> 00:48:09.639
it sees four partitions that it knows how to boot.

00:48:09.639 --> 00:48:11.440
And what do we put in there?

00:48:11.440 --> 00:48:17.720
We put in there the booter, we put in there the kernel so
that the booter can get at it easily, we put that M kext,

00:48:17.719 --> 00:48:24.129
we talked about having all the drivers necessary to
boot, and we put the P list, which has the UUID in it.

00:48:24.130 --> 00:48:28.130
And finally we put the disk label, so if you
have a custom icon for your RAID boot volume,

00:48:28.130 --> 00:48:34.220
we'll in fact see four custom icons in EFI.

00:48:34.219 --> 00:48:36.750
So how does this work?

00:48:36.750 --> 00:48:40.000
Basically we have to automatically rebuild the caches.

00:48:40.000 --> 00:48:44.019
So if you install new drivers, kext D
is actually now watching, it's got a KQ,

00:48:44.019 --> 00:48:47.070
it's watching on system library extensions.

00:48:47.070 --> 00:48:51.480
And anytime you touch system library extensions, which is
what you're supposed to do if you're installing a driver,

00:48:51.480 --> 00:48:58.329
it goes ahead and says aha, there's something new, I'll
fire up kext cache, I'll rebuild your M kext, and you know,

00:48:58.329 --> 00:49:02.579
tell kext cache to update anything needs to be updated,
and kext cache will update all those Apple boots.

00:49:02.579 --> 00:49:08.079
So when you change some system component,
which would normally be a kext, but you know,

00:49:08.079 --> 00:49:13.929
you can touch a mach kernel and it would also oh Mach
kernel changed, better copy it down to the Apple boots.

00:49:13.929 --> 00:49:20.049
Kext D will notice and fire up kext cache,
and it'll go ahead and copy it down.

00:49:20.050 --> 00:49:27.000
This eliminates the need to boot from individual
kexts, because we're always updating that M kext.

00:49:27.000 --> 00:49:30.980
Basically five seconds after you've touched system
library extensions we go ahead and make a new M kext.

00:49:30.980 --> 00:49:34.490
So we're basically always booting from the M kext.

00:49:34.489 --> 00:49:41.349
And we also while we're at it, some of you
may know that if you install a brand new kext,

00:49:41.349 --> 00:49:45.130
you need to send a HUP signal to kext,
you need to say hey, there's a new kext here,

00:49:45.130 --> 00:49:49.030
it's got some new personalities, so
you should now know about my device.

00:49:49.030 --> 00:49:52.550
So some installer scripts will send a SIGHUP
to kext D. That still works,

00:49:52.550 --> 00:50:01.810
but if you touch system library extensions on
Leopard and later, it will take care of that for you.

00:50:01.809 --> 00:50:04.119
The, it should take care of that
for you, but there may be some cases

00:50:04.119 --> 00:50:05.769
where it doesn't, so keep sending SIGHUP.

00:50:05.769 --> 00:50:06.179
( laughter )

00:50:06.179 --> 00:50:09.609
We, talk to me afterwards.

00:50:09.610 --> 00:50:12.099
It just occurred to me.

00:50:12.099 --> 00:50:18.969
So it's important to think of that Apple boot as just
a copy of the stuff that's up in the root partition.

00:50:18.969 --> 00:50:22.939
So you're always installing to the root partition,
and if there's any system bits that need to go

00:50:22.940 --> 00:50:26.409
into the helper partition, we go
ahead and take care of that.

00:50:26.409 --> 00:50:32.099
And if they get destroyed and you can't boot, you can
in fact boot off your DVD, and if you repair the disk,

00:50:32.099 --> 00:50:34.960
we'll go ahead and repopulate those Apple boot partitions.

00:50:34.960 --> 00:50:40.400
But there's never anything in there that's unique
that we can't rebuild from the main root volume.

00:50:40.400 --> 00:50:44.559
And the way that it's enabled for
Apple RAID and other devices

00:50:44.559 --> 00:50:52.409
that have multiple data partitions is you have a
property on your I/O media, which is just a type of object

00:50:52.409 --> 00:50:57.139
in the I/O Kit registry, and it describes
the data partitions that are being used.

00:50:57.139 --> 00:51:03.789
And we, from the data partitions we derive
the Apple boots that we need to update.

00:51:03.789 --> 00:51:06.250
So there's a few new behaviors.

00:51:06.250 --> 00:51:12.050
There's a new flag on kext cache, kext cache dash U will
basically update anything and everything on a volume.

00:51:12.050 --> 00:51:16.019
So you say kext cache dash U, you give it
a volume, and it will update your M kext.

00:51:16.019 --> 00:51:20.590
It does, you may not have noticed but there's a lot of
flags you have to pass to kext cache now to build M kext.

00:51:20.590 --> 00:51:22.519
You got to build all the architectures and stuff.

00:51:22.519 --> 00:51:25.420
This takes care of all that for you.

00:51:25.420 --> 00:51:29.360
Kext D also notices a safe boot, and will
touch system library extensions, which helps,

00:51:29.360 --> 00:51:36.130
it means the safe boot's a little bit stronger of
a method for reinitializing all of your caches,

00:51:36.130 --> 00:51:40.619
not just on that boot, but on subsequent
boots you'll be using fresh caches.

00:51:40.619 --> 00:51:47.190
On boot root volumes we'll be watching your
system library extensions, so it'll go ahead

00:51:47.190 --> 00:51:48.940
and automatically rebuild the M kext for you.

00:51:48.940 --> 00:51:55.030
And also since you can put anything you want in the M kext,
and we're always booting from it now from those Apple boots,

00:51:55.030 --> 00:51:57.610
the kernel actually verifies OS bundle required.

00:51:57.610 --> 00:52:03.039
So if you have a OS bundle required key,
and it's not right or it's not there,

00:52:03.039 --> 00:52:07.009
even if you put something in M
kext, kernel's gonna ignore it.

00:52:07.010 --> 00:52:09.070
We're also dependent on volume IDs.

00:52:09.070 --> 00:52:12.150
So volume IDs are how we identify volumes.

00:52:12.150 --> 00:52:16.380
They're supposed to be unique, all
volumes should have a different volume ID.

00:52:16.380 --> 00:52:24.920
Volume ID is stored in HFS in, at the root node, and
we derive that UUID you see in disk util info from it.

00:52:24.920 --> 00:52:31.940
If the volume IDs are incorrect or inconsistent,
it's possible you'll not be able to root.

00:52:31.940 --> 00:52:39.750
So it's important to be careful about them, not to change
them, and not make disks that have duplicates of them.

00:52:39.750 --> 00:52:45.190
So if you do need to change them for some reason, make
sure to unmount and remount the volume right afterwards,

00:52:45.190 --> 00:52:51.340
because otherwise, remember we store that little
cookie, the boot UUID down in the boot P list.

00:52:51.340 --> 00:52:56.039
And if that's a stale value and we come up here and
we're waiting, we're saying okay where's that device?

00:52:56.039 --> 00:52:56.980
Where's that device?

00:52:56.980 --> 00:52:58.400
I don't see it, you know.

00:52:58.400 --> 00:53:03.380
And the device is here but you changed the UUID
on us without letting us see that it changed,

00:53:03.380 --> 00:53:07.039
then we're gonna wait forever, and
we're not gonna be able to root.

00:53:07.039 --> 00:53:08.679
So where is this used?

00:53:08.679 --> 00:53:15.789
We shipped it first on the Mac Pro, so you'll see Mac Pro
kext cache dash U, it's used for Apple RAID on the Mac Pro,

00:53:15.789 --> 00:53:21.889
and in Leopard it's used for both Apple
RAID on, it's both used on Power PC

00:53:21.889 --> 00:53:24.519
and Intel, and it's also used for K sensitive HFS.

00:53:24.519 --> 00:53:32.570
You may or may not know, but the HFS implementation
on open firmware doesn't understand case sensitive,

00:53:32.570 --> 00:53:38.700
it predates it significantly, and so we have a little Apple
boot partition as a helper for all case sensitive volumes,

00:53:38.699 --> 00:53:42.719
and we're going ahead and doing a full boot
root style, copy the booter, copy the kernel,

00:53:42.719 --> 00:53:44.869
copy the boot P list into that Apple boot.

00:53:44.869 --> 00:53:48.420
If you run disk util list, you
will see the Apple boot partitions

00:53:48.420 --> 00:53:52.579
on your Power PC case sensitive
volumes, or on your Apple RAID setups.

00:53:52.579 --> 00:53:56.210
And this is part of content driver solutions going forward.

00:53:56.210 --> 00:54:01.809
If you have a device, and it's basically just descrambling
that device, you're doing a different partitioning scheme,

00:54:01.809 --> 00:54:08.909
something like that, boot root's gonna be the way that
third parties are going to be able to get their kext loaded.

00:54:08.909 --> 00:54:12.389
So you don't need to be at firmware time, you
don't have to worry about firmware drivers

00:54:12.389 --> 00:54:15.739
for certain classes of content scrambling.

00:54:15.739 --> 00:54:20.569
If you know, we can load the kernel, load the kexts,
you match on your partition, you descramble it,

00:54:20.570 --> 00:54:23.320
and then you present the descrambled version to the OS.

00:54:23.320 --> 00:54:29.039
So this eliminates a certain class
of need to write EFI drivers.

00:54:29.039 --> 00:54:36.940
At this point in time we cannot root from file
systems that are not in Mach-0 kernel.

00:54:36.940 --> 00:54:42.960
So that's mainly a interface issue and a code calling issue,
but there's a couple reasons that we aren't able to root.

00:54:42.960 --> 00:54:47.220
So if you got a file system kext, sure the kext is
in memory, but we can't necessarily get you connected

00:54:47.219 --> 00:54:50.719
as the root volume, so that's not supported.

00:54:50.719 --> 00:54:56.750
So, let's talk a little bit about
the tools, a little overview.

00:54:56.750 --> 00:55:02.170
Boot cache control I mentioned is the tool that
communicates with the driver and the kernel

00:55:02.170 --> 00:55:07.590
for optimizing the disk layout of all the blocks you
need to boot, bless is how you set your device pointers,

00:55:07.590 --> 00:55:10.050
you say well I want to boot on
that or I want to boot on this.

00:55:10.050 --> 00:55:15.970
It can also change you know, volume, the pointers
to the blessed file or the blessed folder.

00:55:15.969 --> 00:55:20.899
Kext D is kind of watching over everything,
responding to requests from the kernel for kexts.

00:55:20.900 --> 00:55:24.360
It's watching system library extensions,
it's rebuilding the M kext

00:55:24.360 --> 00:55:28.809
in the pre-link kernel, and kext
D's worker bee is kext cache.

00:55:28.809 --> 00:55:32.380
So kext D will notice something needs to
be done, something needs to be rebuilt,

00:55:32.380 --> 00:55:34.619
it'll fire off kext cache to do the work.

00:55:34.619 --> 00:55:39.480
And finally we have the NV RAM tool, which if you really
know what you're doing and really want to muck with stuff,

00:55:39.480 --> 00:55:45.860
you can directly set the NV RAM variables for you know,
for example you might want to boot verbosely all the time.

00:55:45.860 --> 00:55:49.720
NV RAM is a, tool is a great way to
add dash V to the boot dash args flag,

00:55:49.719 --> 00:55:56.569
and then you can see all the Unixy goodness pouring
forth from the Mac OS ten kernel and drivers.

00:55:56.570 --> 00:56:00.970
So we've talked about lots of files
and lots of how things work.

00:56:00.969 --> 00:56:08.000
I just want to remind everybody, don't
change the booter, don't change the kernel.

00:56:08.000 --> 00:56:15.119
We want to keep the system increasingly able to heal
itself, and able to verify that the files are correct.

00:56:15.119 --> 00:56:18.079
Software updates come along and they replace these things.

00:56:18.079 --> 00:56:26.519
So you know, play around as much as you want, but don't
make any products rely on changing any system files.

00:56:26.519 --> 00:56:29.110
And basically those Apple boots,
don't get any ideas about that either,

00:56:29.110 --> 00:56:31.940
because essentially we erase them every time we update them.

00:56:31.940 --> 00:56:34.570
But there are some things you can do.

00:56:34.570 --> 00:56:40.900
You can use the debug knobs, you can create on demand launch
D jobs, you can write kexts, if you have drivers that need

00:56:40.900 --> 00:56:47.139
to be written, although there are nice user land
driver models for several things including USB.

00:56:47.139 --> 00:56:50.519
You can make AFI applications if you
want to, if you want that DOS feeling,

00:56:50.519 --> 00:56:54.409
you can go get the shell and you know, run that.

00:56:54.409 --> 00:57:00.569
And if you want to do boot root for exotic device rooting,
or if you want to write EFI ROM drivers, please talk to us.

00:57:00.570 --> 00:57:04.930
It's possible, but there are many
things that you need to know.

00:57:04.929 --> 00:57:07.569
And we will be happy to talk to the, several of you.

00:57:07.570 --> 00:57:10.960
At least one person came up, so I'm excited, sort of.

00:57:10.960 --> 00:57:13.309
( laughter )

00:57:13.309 --> 00:57:19.599
There's at least one, one third party
has adopted it, so it is possible to do.

00:57:19.599 --> 00:57:25.279
Okay. You should now know how to debug like a pro, cause
you know the difference between the Apple and the gear,

00:57:25.280 --> 00:57:27.000
everybody remembers the difference, Apple, gear.

00:57:27.000 --> 00:57:29.329
Apple booter, gear kernel.

00:57:29.329 --> 00:57:31.279
Repeat after me.

00:57:31.280 --> 00:57:31.860
( laughter )

00:57:31.860 --> 00:57:35.039
Booter kernel, booter kernel.

00:57:35.039 --> 00:57:35.509
Okay, good.

00:57:35.510 --> 00:57:42.100
Don't muck with those file system IDs, we use them
for boot root, we also use them for Spotlight.

00:57:42.099 --> 00:57:45.289
And you know, sometimes, it's tempting to
say well I think I know what's going on.

00:57:45.289 --> 00:57:49.099
Just, file system IDs should be unique,
and ideally they shouldn't change.

00:57:49.099 --> 00:57:54.489
If you do install something new, please touch system library
extensions, we like to think of that as our doorbell.

00:57:54.489 --> 00:57:58.509
That's like doorbell to kext D saying ding
dong, something new, go check out things.

00:57:58.510 --> 00:57:59.890
So do that.

00:57:59.889 --> 00:58:03.329
If there's a place where you're building
caches and you're gonna be adopting Leopard,

00:58:03.329 --> 00:58:07.360
feel free to use kext cache dash U to build
those caches for you without you having to figure

00:58:07.360 --> 00:58:08.950
out what all the command lines should be.

00:58:08.949 --> 00:58:10.980
And finally, use bless.

00:58:10.980 --> 00:58:12.079
Bless is really your fried.

00:58:12.079 --> 00:58:19.079
It is the back end of startup disk, and several other
pieces of the system that need to set these NV RAM variables

00:58:19.079 --> 00:58:22.299
to make sure we boot off of this volume or that volume.

00:58:22.300 --> 00:58:29.210
If you need more information, there's our I/O technology
evangelist, there's our desktop hardware evangelist.

00:58:29.210 --> 00:58:36.360
We also have amazingly some documentation on this,
system startup programming topics, the boot process.

00:58:36.360 --> 00:58:41.640
And websites we mentioned earlier, Tianocore
is the open source implementation from Intel of EFI,

00:58:41.639 --> 00:58:45.179
great place to get that DOS feeling from your shell.

00:58:45.179 --> 00:58:52.239
And UEFI is the standards body that is
driving forward EFI adoption, and increase.

00:58:52.239 --> 00:58:53.389
So mailing list.

00:58:53.389 --> 00:58:57.000
There's a new mailing list, boot dash dev at list
dot Apple dot com, you should feel free to join it.

00:58:57.000 --> 00:59:01.969
And there are great man pages installed on your
systems for bless, kext, cache, and NV RAM.
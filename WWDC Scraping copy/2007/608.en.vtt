WEBVTT

00:00:20.109 --> 00:00:22.119
>> Thanks everyone for coming.

00:00:22.120 --> 00:00:26.380
Antoine and I are really very excited
to present some of this stuff to you.

00:00:26.379 --> 00:00:33.219
Hopefully you'll see things that you didn't know were
in Safari and you can start using them both on the web

00:00:33.219 --> 00:00:40.189
and in your apps if you're embedding WebKit in your apps.

00:00:40.189 --> 00:00:46.449
This session, basically, is building
on the features that have been added

00:00:46.450 --> 00:00:50.060
to Safari since it, since it became open source.

00:00:50.060 --> 00:00:53.990
We're focusing on the graphics related features.

00:00:53.990 --> 00:01:00.630
While the topic of this session is vector graphics,
we're actually starting with a little bit of CSS.

00:01:00.630 --> 00:01:05.070
And the reason for this is if you look
at the majority of web pages today,

00:01:05.069 --> 00:01:10.159
the really rich graphical web pages are
using CSS to provide the look and feel.

00:01:10.159 --> 00:01:15.939
Now, Safari 3 is that adds some new CSS features
based on standards that were defined a few years ago

00:01:15.939 --> 00:01:22.450
that allow people to effectively make their pages or their
layout easier because they're using these new features.

00:01:22.450 --> 00:01:30.409
After that I'll give an introduction to Canvas, which is
a way to use JavaScript to draw graphics in the browser.

00:01:30.409 --> 00:01:36.789
And then Antoine will finish it up by giving an
introduction to SVG and show some nice demos.

00:01:36.790 --> 00:01:44.270
So, I just want to start with the, something that I
don't think is being, I haven't seen highlighted too much

00:01:44.269 --> 00:01:48.539
in this conference, is this fantastic
new redesign for Apple.com.

00:01:48.540 --> 00:01:53.770
And if you're a web developer or even if you're not
you should really take a look at the site and, in fact,

00:01:53.769 --> 00:02:00.759
not just look at the site as it is in the browser, view
the source and have a look at the way that they've implemented it.

00:02:00.760 --> 00:02:07.000
While, as this session is actually building on all
the hard work that has been done by the WebKit team

00:02:07.000 --> 00:02:15.409
and the WebKit community, this site is just some
amazing work done by the, by the design team.

00:02:15.409 --> 00:02:18.340
Now, show this next one.

00:02:18.340 --> 00:02:23.840
I assume that everyone knows like when Steve gets up and
gives a key note that afterwards the press and the media

00:02:23.840 --> 00:02:28.620
and the whole world and the blogging community
got to examine nearly every word he goes over

00:02:28.620 --> 00:02:31.789
and really look at what happened in detail.

00:02:31.789 --> 00:02:36.549
Well, the sort of web nerd design
community have the same expectations

00:02:36.550 --> 00:02:40.180
for a company like Apple when they redesign their site.

00:02:40.180 --> 00:02:45.210
If Apple did such a sort of major redesign
as this and still used technologies

00:02:45.210 --> 00:02:48.810
from 2001 that'd probably get lots of negative press.

00:02:48.810 --> 00:02:51.289
But this is just, this is just fantastic.

00:02:51.289 --> 00:02:57.280
Now, you can see sort of how the look and feel
is sort of similar to the, the previous design.

00:02:57.280 --> 00:03:00.590
But what's interesting is they've
used much more semantic mark-up

00:03:00.590 --> 00:03:02.770
to get the effects, and this is one of the benefits of CSS.

00:03:02.770 --> 00:03:10.469
So the toolbar across the top is, in fact, a
list, an HML list and CSS renders it as a toolbar

00:03:10.469 --> 00:03:17.909
and assigns the background, images of the nice gradient
fade and works out which images, which tab has been selected

00:03:17.909 --> 00:03:22.810
as the main tab and colors that a
different, a different background.

00:03:22.810 --> 00:03:29.219
The other things you notice is the current trend today
of, what I sort of think, is like child safe kitchens

00:03:29.219 --> 00:03:32.590
where every corner's been rounded off
so no one's going to hurt themselves.

00:03:32.590 --> 00:03:36.509
I actually looked through the site
and I only found two sharp edges,

00:03:36.509 --> 00:03:38.849
and they're actually on this slide if you look closely.

00:03:38.849 --> 00:03:42.879
But I don't know whether that was just something that
didn't happen or it was intentionally, but I can't,

00:03:42.879 --> 00:03:45.740
I can't complain about the design in anyway.

00:03:45.740 --> 00:03:48.689
Not only is it just doing layout it's
actually got some great interactive features.

00:03:48.689 --> 00:03:53.250
And it's really giving the look
and feel of Apple to the people

00:03:53.250 --> 00:03:55.300
that are visiting the website, and this is really important.

00:03:55.300 --> 00:03:59.260
Here we've got very rich media,
lots of content, lots of graphics.

00:03:59.259 --> 00:04:06.019
We've got some interactivity where you can slide
across and the see the products that Apple make.

00:04:06.020 --> 00:04:17.449
Also with this, is the second half of that page, they've
got QuickTime embedded that has some interactivity to it.

00:04:17.449 --> 00:04:21.849
This section on the left here, if you mouse
over it you get these animated effects.

00:04:21.850 --> 00:04:27.980
Now, people have probably seen animation on the web for
a long while but they, what's new about these websites

00:04:27.980 --> 00:04:31.370
that are coming out now is the animation
is done as a core part of the browser,

00:04:31.370 --> 00:04:33.269
using the features that the browser implemented.

00:04:33.269 --> 00:04:35.709
In this case it's using JavaScript.

00:04:35.709 --> 00:04:41.639
And the other important thing is that because
it's just using JavaScript the content,

00:04:41.639 --> 00:04:45.610
the semantically rich content is being sent to the
browser so if you don't have JavaScript or you're running

00:04:45.610 --> 00:04:51.060
on another device or for example, you're not
even running on something that has a screen,

00:04:51.060 --> 00:04:54.259
you're just having it read to you,
all the content's available.

00:04:54.259 --> 00:04:59.339
A richer experience gets, oh sorry, if you're on a
more powerful browser you get a richer experience.

00:04:59.339 --> 00:05:08.379
This is effectively making the web or video and all
these effects a core piece of the web browser technology.

00:05:08.379 --> 00:05:15.159
Now, unfortunately as they made this beautiful
site they, as Apple.com has to be visible

00:05:15.160 --> 00:05:21.410
to everyone including browsers, including users on a
popular operating system that use a very popular browser,

00:05:21.410 --> 00:05:27.120
they can't necessarily use all the features
of CSS that have been implemented in WebKit.

00:05:27.120 --> 00:05:32.600
So the new features I'm going to talk about
now could have been used by they weren't used.

00:05:32.600 --> 00:05:39.890
And this is actually an important thing to know about
web standards, CSS has passed its tenth birthday.

00:05:39.889 --> 00:05:44.810
But what happens with web technologies
is you, hopefully you'd standardize them

00:05:44.810 --> 00:05:47.160
in some way rather than to start to implement them.

00:05:47.160 --> 00:05:50.520
They get some level of interoperability
and once it reaches a level

00:05:50.519 --> 00:05:55.449
of market penetration then people can
start using it as, as, in their content.

00:05:55.449 --> 00:06:01.699
So here's an example of how they could have, how it could
have been a little bit easier in the Apple redesign.

00:06:01.699 --> 00:06:07.219
So, one of the most common features that people use
is these rounded borders and often you see a sort

00:06:07.220 --> 00:06:11.050
of nice gradient fade on the, on the rectangular area.

00:06:11.050 --> 00:06:15.329
Now, the problem with that is sometimes you have
to, that means you have to wrap your mark-up in,

00:06:15.329 --> 00:06:21.509
in sort of empty elements to provide sort of
extra boxes that you can attach the graphics to.

00:06:21.509 --> 00:06:27.920
Well, the background image tag has been, is being
extended here to be able to take more than one, one image.

00:06:27.920 --> 00:06:35.280
So instead of just saying background image and give
it one pink file, I've given five in this case.

00:06:35.279 --> 00:06:41.409
Now, another great thing to, to mention
about this, this approach is that it's

00:06:41.410 --> 00:06:44.189
it's actually great for backwards compatibility.

00:06:44.189 --> 00:06:46.430
We're not breaking any existing content here.

00:06:46.430 --> 00:06:51.759
If an old browser hits this, this, it's not going to,
your page isn't going to be unrenderable or whatever.

00:06:51.759 --> 00:06:58.120
It's actually using the features in CSS to
add functionality to new versions of CSS.

00:06:58.120 --> 00:07:04.100
Underneath here I, I set a position, background position
for every one of the images and, it's a pretty ugly graphic,

00:07:04.100 --> 00:07:09.910
but it's that, what'll happen is that paragraph
would resize to whatever text is, is placed in it

00:07:09.910 --> 00:07:16.220
and the graphics would align themselves
with the way I, I, the way I position them.

00:07:16.220 --> 00:07:22.130
Another similar property is the ability to set one border
image and have it resize to fit the entire content.

00:07:22.129 --> 00:07:27.240
This is, again, implemented in Safari 3 and
been in WebKit now, at least for a while now.

00:07:27.240 --> 00:07:32.780
So, here again, very similar to the way it's actually
done at the moment, you set a border image property,

00:07:32.779 --> 00:07:37.049
which takes a parameter, the URL to a, to a PNG file.

00:07:37.050 --> 00:07:42.079
And here's the extra bit, was where I set
some four parameters after the image the image

00:07:42.079 --> 00:07:46.250
to specify how it's sliced up, and
I'll show you that in the next slide.

00:07:46.250 --> 00:07:52.959
In this case I did add another, some anti-element
here a div around the paragraph.

00:07:52.959 --> 00:07:58.469
What that means is that no matter what content I
put, I had placed into that div the border is going

00:07:58.470 --> 00:08:02.130
to resize to whatever size the content has taken.

00:08:02.129 --> 00:08:04.370
So let's have a look at how it's done.

00:08:04.370 --> 00:08:06.709
The actual border image can be any size you want.

00:08:06.709 --> 00:08:12.789
So, I mean, here the actual image that's
used to render that, that border is a square.

00:08:12.790 --> 00:08:18.230
But if I go back one you see it's been
resized to, to get the shape of the content.

00:08:18.230 --> 00:08:22.509
Now, with the four parameters here
are specifying basically two,

00:08:22.509 --> 00:08:26.750
four slices that will generate nine
individual pieces of the image.

00:08:26.750 --> 00:08:35.210
And you've got the, the four corners will go to the four
corners of the rectangular area in CSS and, you know,

00:08:35.210 --> 00:08:42.420
the middle pieces, or sorry, middle edges and the middle
of the element itself get resized to fill the space.

00:08:42.419 --> 00:08:48.779
Now, that's all I was going to talk about in CSS.

00:08:48.779 --> 00:08:51.559
Now I'm going to go on to doing Canvas.

00:08:51.559 --> 00:08:56.659
Just before I leave CSS, you know, I didn't want to
talk about the thousands of features that use CSS.

00:08:56.659 --> 00:09:03.399
I'm, instead, going to do the web way and say go to
Apple.com and view source and you can get all the,

00:09:03.399 --> 00:09:05.889
all the tricky ways that I've implemented things so far.

00:09:05.889 --> 00:09:08.059
So, now let's talk about Canvas.

00:09:08.059 --> 00:09:11.419
This is something that is quite cool.

00:09:11.419 --> 00:09:16.860
Of course, again, people have seen graphics in the browser
and animations in the browser but in this case this,

00:09:16.860 --> 00:09:20.830
this functionality is exposed directly
to the, to the engine itself.

00:09:20.830 --> 00:09:24.460
You don't have to call any external plugins or whatever.

00:09:24.460 --> 00:09:27.750
So, Canvas is an HTML element.

00:09:27.750 --> 00:09:34.019
And the HTML element defines the rectangular region of
the page and then also a JavaScript API that allows you

00:09:34.019 --> 00:09:36.689
to do whatever you want with that rectangular image.

00:09:36.690 --> 00:09:44.360
It's been available since Safari 2.0,
which means you can already use today on Tiger.

00:09:44.360 --> 00:09:49.580
It's, there has been some slight
updates to the interface since then.

00:09:49.580 --> 00:09:54.020
It's, you know, been documented in a standards
process and has made some slight tweaks.

00:09:54.019 --> 00:10:00.259
So you should, if you're using Canvas you should check
your Dashboard widget or whatever it is on Safari 3.

00:10:00.259 --> 00:10:07.250
Another interesting thing about it is, what I saw is draw
and forget, is that Canvas just updates pixels in the page.

00:10:07.250 --> 00:10:11.700
If I draw something on it I don't actually
have any memory of the fact that I've drawn it.

00:10:11.700 --> 00:10:17.320
What's happened is that the actual page has been
updated to whatever I've actually sent to the screen.

00:10:17.320 --> 00:10:24.700
This is kind of different to the way typical people, typical
web programming happens, where you have the object model

00:10:24.700 --> 00:10:28.420
of the document there and you use the
JavaScript to examine the document

00:10:28.419 --> 00:10:31.629
and provide some kind of effect
based on what the content is.

00:10:31.629 --> 00:10:36.189
In this case it's purely for just rendering
images, or rendering pixels on the screen.

00:10:36.190 --> 00:10:38.970
The advantage of this is it has
a very low memory footprint.

00:10:38.970 --> 00:10:42.440
If you're going to display thousands and
thousands of objects you don't want to have

00:10:42.440 --> 00:10:44.090
to have a DOM element for every one of those.

00:10:44.090 --> 00:10:50.580
You just draw, draw to the screen using, you know,
JavaScript or generate the graphics using a program.

00:10:50.580 --> 00:10:54.780
This means it's quite high performance and,
furthermore, it's actually a very simple API.

00:10:54.779 --> 00:11:00.199
Now, I'm a pretty simple person so I like simple API's.

00:11:00.200 --> 00:11:02.940
Web, again, it's the way the web
works, is you don't necessarily have

00:11:02.940 --> 00:11:06.140
to deliver something, everything to the user straight away.

00:11:06.139 --> 00:11:10.639
You give something easy and you can build
on that as, as interoperability arrives.

00:11:10.639 --> 00:11:16.330
Actually just before that, of course, you may know
Canvas from such Dashboard widgets as the clock,

00:11:16.330 --> 00:11:25.290
where it's use to rotate the hands and the fantastic flight
path widget where it, it animates the path of the plane,

00:11:25.289 --> 00:11:29.059
which, of course, would be sort of impractical to a
store on, on the data store on the server, you know,

00:11:29.059 --> 00:11:32.989
the thousands of images that you're
required to show every path.

00:11:32.990 --> 00:11:36.480
So where is it available?

00:11:36.480 --> 00:11:42.950
Well, it was, again, invented by Safari and shipped
with Dashboard and, sorry, Safari 2.0 and Dashboard.

00:11:42.950 --> 00:11:50.490
And since then Firefox and Opera
have implemented it interoperably.

00:11:50.490 --> 00:11:55.399
It's also available in IE because people have used a
JavaScript library that effectively mirrors the API

00:11:55.399 --> 00:12:02.870
and then calls some features that are only
implemented on Windows IE to draw the same graphics.

00:12:02.870 --> 00:12:05.929
So it's, it is something you can use
every where with a little bit of work.

00:12:05.929 --> 00:12:12.879
From now on its development has been sent to the
standards bodies, first to the WHATWG,

00:12:12.879 --> 00:12:18.939
which included in HTML file specification and that
specification now is part of the W3C HTML working group.

00:12:18.940 --> 00:12:25.050
So, hopefully what we'll see is, again,
complete interoperability as well

00:12:25.049 --> 00:12:29.620
as some new features coming to later versions of HTML.

00:12:29.620 --> 00:12:35.690
For the core graphics programs out there
the API will be very, very familiar.

00:12:35.690 --> 00:12:38.800
It's got paths, strokes, fills, gradients.

00:12:38.799 --> 00:12:45.709
I'll just mention a few things that maybe web
developers are more or interested in other than that is,

00:12:45.710 --> 00:12:47.720
you know, can do the shawdows automatically.

00:12:47.720 --> 00:12:52.300
Drop shawdows, they're so 2006
now but, maybe they're still used.

00:12:52.299 --> 00:12:57.120
Patents. For the core graphics
programmers there's one major difference,

00:12:57.120 --> 00:13:02.259
is where in core graphics you get a drawing context
and you pass it into the functions you call.

00:13:02.259 --> 00:13:06.319
In this case you get the context and call
methods on the context and set attributes.

00:13:06.320 --> 00:13:10.140
It's the same idea but just a slightly
different of approach.

00:13:10.139 --> 00:13:11.960
So, how do I include it in a web page?

00:13:11.960 --> 00:13:13.370
Here's a typical web page.

00:13:13.370 --> 00:13:14.759
I just have a Canvas element.

00:13:14.759 --> 00:13:16.049
I give it a width and height.

00:13:16.049 --> 00:13:22.169
And that basically reserves this part of the screen,
the blue section in the page, that reserves that part

00:13:22.169 --> 00:13:26.569
of the screen and allows me to
draw into it using JavaScript.

00:13:26.570 --> 00:13:29.560
How do you actually draw?

00:13:29.559 --> 00:13:36.149
Well, like regular DOM programming you use
get element by ID to, in this case I've used,

00:13:36.149 --> 00:13:40.909
I've given the Canvas object, sorry,
the Canvas element an ID Canvas.

00:13:40.909 --> 00:13:45.179
That gives me a reference to the DOM
object that implements the Canvas.

00:13:45.179 --> 00:13:47.779
And then I ask the Canvas for the drawing context.

00:13:47.779 --> 00:13:53.230
The drawing context is a thing that's actually
associated with each individual Canvas on the page

00:13:53.230 --> 00:13:55.960
and allows you to render graphics into the Canvas.

00:13:55.960 --> 00:14:01.190
Now, it's probably worth noting
that you can see a passive parameter

00:14:01.190 --> 00:14:04.310
into the context, to get context call, which is 2D.

00:14:04.309 --> 00:14:06.709
The reason for this is it's designed to be extensible.

00:14:06.710 --> 00:14:10.400
You're just given basically a blank
region of screen or blank canvas.

00:14:10.399 --> 00:14:13.850
There's no reason why you couldn't have
3D graphics in there or any other type

00:14:13.850 --> 00:14:17.320
of graphics you could possibly
imagine or even simpler or harder.

00:14:17.320 --> 00:14:23.129
The idea is that whatever is returned from the
get context call is going to give you something

00:14:23.129 --> 00:14:26.019
that renders into that region of the screen.

00:14:26.019 --> 00:14:29.840
Now, in this case, finally, are calling 2D
because that's the only one that's implemented.

00:14:29.840 --> 00:14:34.730
But you could, hopefully, imagine that maybe later
down the track you'll be able to call, ask for a 3D,

00:14:34.730 --> 00:14:37.750
3D context and, again, render 3D graphics.
=

00:14:37.750 --> 00:14:41.309
Once you've got a context you set attributes on that object.

00:14:41.309 --> 00:14:45.119
And those attributes control the, the
method of drawing, whether it's, you know,

00:14:45.120 --> 00:14:49.070
stroked with a particular color or
it's width or height or opacity.

00:14:49.070 --> 00:14:55.200
And then you call methods on the context objects
actually render shapes onto the, onto the page.

00:14:55.200 --> 00:15:00.150
A quick mention here about what it means to have vectors.

00:15:00.149 --> 00:15:03.740
Because the vectors are described
by a mathematical function here,

00:15:03.740 --> 00:15:07.570
it gives you an easy way to have resolution independence.

00:15:07.570 --> 00:15:13.080
The Canvas, while it's given, it's given its
width and height in terms of the page dimensions,

00:15:13.080 --> 00:15:18.160
that doesn't necessarily mean you can't use a coordinate
system and basically map the model of the graphics

00:15:18.159 --> 00:15:21.519
that you're using into the canvas
system by setting transforms.

00:15:21.519 --> 00:15:27.699
So the Quartz 2D people should- be aware
here that Canvas uses a Y down coordinate system

00:15:27.700 --> 00:15:31.450
which is probably the opposite to
the way most people learn geometry.

00:15:31.450 --> 00:15:39.240
The reason for this is that, the reason it's different
from the typical paid Y up coordinate system is that,

00:15:39.240 --> 00:15:41.769
unfortunately, that's the way that HTML sort of works.

00:15:41.769 --> 00:15:48.710
As you add elements to the page the content moves down the
page and this sort of effectively makes it easier for people

00:15:48.710 --> 00:15:54.810
that are familiar with CSS to use this
similar approach to move into using Canvas.

00:15:54.809 --> 00:15:57.909
And, of course, once I have a coordinate
system I can do whatever I want with it.

00:15:57.909 --> 00:15:59.039
I can translate it.

00:15:59.039 --> 00:16:03.029
And it's not just moving it around,
again, I could also cay rotate the canvas.

00:16:03.029 --> 00:16:06.480
I'm not rotating the canvas, it'll rotate the
graphics that I've got to draw on the canvas.

00:16:06.480 --> 00:16:12.019
In this case squish them in an X direction
and stretch them in height, a Y direction.

00:16:12.019 --> 00:16:16.860
So let's just do a very simple flow through of what happens.

00:16:16.860 --> 00:16:18.350
So imagine this is the Canvas.

00:16:18.350 --> 00:16:24.460
You're actually given a blank canvas to start off with so,
I mean, I'm just using the grid to show what's going on.

00:16:24.460 --> 00:16:31.850
Now, I call this very simple function, fillRect, which is
saying use an X position and a Y position of 100 and a width

00:16:31.850 --> 00:16:36.509
and height of 200 and 300 and its just
got to draw a rectangle on the screen.

00:16:36.509 --> 00:16:42.620
We'll go into this in a little bit more
detail later, actually what's happening here.

00:16:42.620 --> 00:16:51.470
And you can see, again, the Y coordinate
system goes down the, down the, down the page.

00:16:51.470 --> 00:16:57.360
So, once, again, once you, once you've drawn on the Canvas
you've got no knowledge, I mean you can't, you can't look,

00:16:57.360 --> 00:17:00.810
examine it to see what's actually on there as such yet.

00:17:00.809 --> 00:17:03.500
So, if you've got to draw multiple
things on there they're just going

00:17:03.500 --> 00:17:06.329
to start piling on top of each other and obscuring it.

00:17:06.329 --> 00:17:11.289
So, usually the first thing you do is say I want to clear
the Canvas, which is basically just got to wipe the graphics

00:17:11.289 --> 00:17:13.950
out and give you a fully transparent bitmap.

00:17:13.950 --> 00:17:19.490
So, if I'd call the clearRect function, in this case
I'm calling it on the entire Canvas, to remove everything

00:17:19.490 --> 00:17:23.370
and I'm starting back with a, with
a completely empty screen.

00:17:23.369 --> 00:17:27.729
Now the way that fillrect actually was
implemented or, I don't know if implemented

00:17:27.730 --> 00:17:33.420
to say the way you should understand that it's
behaving in the context of paths, again, similar to,

00:17:33.420 --> 00:17:39.680
same to way that even Quartz 2D has
paths and also the Cocoa layer has paths.

00:17:39.680 --> 00:17:42.830
You start by saying a begin path and
then you give it a set of functions.

00:17:42.829 --> 00:17:45.789
You have this knowledge of what the current point is.

00:17:45.789 --> 00:17:51.579
So I begin a path and the first thing I'm going
to do is say move the current point to 100, 100.

00:17:51.579 --> 00:17:57.839
Then I say to it, move the current point to, draw a line
to this particular point and I'm going to go down a bit,

00:17:57.839 --> 00:18:03.399
then I'm going to go along a bit and finally I'm going to say, now
from wherever you are go back to the where we started from,

00:18:03.400 --> 00:18:09.480
and that's going to give you a complete
filled path, sorry, a complete object.

00:18:09.480 --> 00:18:15.190
And then the next thing I do is actually call a drawing
operation on that, which is fill and it uses the path

00:18:15.190 --> 00:18:18.140
and renders, in this case, whatever the
current color is into the, into the path.

00:18:18.140 --> 00:18:23.540
Now, of course, I don't have to have just rectangles.

00:18:23.539 --> 00:18:29.740
I can here dazzle you with my artistic ability and show
you that any curve or shape that can be represented

00:18:29.740 --> 00:18:34.140
by beziers or arcs or whatever
can be added to the path.

00:18:34.140 --> 00:18:38.890
And, again, you just close the path and fill it
and it's going to use whatever the current path is.

00:18:38.890 --> 00:18:45.250
So, how do you set the, the actual attributes of drawing?

00:18:45.250 --> 00:18:48.730
In this case I set the fill color
to, the fill style to be red.

00:18:48.730 --> 00:18:51.640
You can pass in a color value in CSS.

00:18:51.640 --> 00:18:54.100
And I select build a rectangle.

00:18:54.099 --> 00:18:59.259
Now, once that's done I have to update the fill
style here to green and I draw the rectangle in,

00:18:59.259 --> 00:19:01.200
rectangle in a slightly different position.

00:19:01.200 --> 00:19:03.470
You can see that it's obscured the red one.

00:19:03.470 --> 00:19:08.839
In this case I'm setting the color to blue and
I give the, what I say here is the global alpha,

00:19:08.839 --> 00:19:13.209
which means that every drawing operation that
happens now has got to be 50 percent transparent

00:19:13.210 --> 00:19:16.210
So you can see how this blue rectangle
has parts of the green rectangle showing

00:19:16.210 --> 00:19:19.340
through it because it's semi-transparent.

00:19:22.529 --> 00:19:24.950
Stroking, again, very simple.

00:19:24.950 --> 00:19:25.990
You set the stroke style.

00:19:25.990 --> 00:19:27.279
I've set the color to be red.

00:19:27.279 --> 00:19:28.309
I give it a line width.

00:19:28.309 --> 00:19:35.359
And what it's done is traced the path with a line
that's five units wide and you've got a stroke.

00:19:35.359 --> 00:19:37.519
Now, you can control the order in which this happens.

00:19:37.519 --> 00:19:41.690
If you wanted to draw a stroked
rectangle, for example, you can decide,

00:19:41.690 --> 00:19:44.029
in this case, to set the color to blue and fill it.

00:19:44.029 --> 00:19:47.619
Then you'd set the color to be
green and stroke the same rectangle.

00:19:47.619 --> 00:19:50.309
Now, this is sort of the typical way things work.

00:19:50.309 --> 00:19:54.069
You expect the stroke, the stroke actually
is aligned on the middle of the path.

00:19:54.069 --> 00:19:57.740
So you've got half of the stroke is on one
side and half the stroke is on the other side.

00:19:57.740 --> 00:19:59.069
So the order matters here.

00:19:59.069 --> 00:20:03.349
You'd get a different effect if you
did the fill the other way around.

00:20:03.349 --> 00:20:07.469
Draw images, and they're very, very simple here.

00:20:07.470 --> 00:20:09.640
I just set an X and Y point.

00:20:09.640 --> 00:20:14.509
Well, I should actually say the way you actually
reference an image is kind of interesting.

00:20:14.509 --> 00:20:22.779
In this case my, the, the HTML document itself I've put in
an IMG, an image tag and I've referenced a particular URL.

00:20:22.779 --> 00:20:27.700
And then in my JavaScript I use get element
by ID to get a reference to that image object

00:20:27.700 --> 00:20:30.309
and then I can draw it in the, in the Canvas.

00:20:30.309 --> 00:20:36.000
You can also use JavaScript to create a new image object
and you pass in a URL and it'll fetch the image for you.

00:20:36.000 --> 00:20:38.670
Then I tell it to draw on the screen at an XY location

00:20:38.670 --> 00:20:43.769
and it's going to use the default resolution
of the image to draw the screen.

00:20:43.769 --> 00:20:48.389
Now, it's also interesting to note that
the image here appears the right way up.

00:20:48.390 --> 00:20:53.000
So you, There's some things like text where you
don't count your text but you have to realize

00:20:53.000 --> 00:20:57.140
that the coordinate system doesn't always
necessarily work the way you want it to work.

00:20:57.140 --> 00:20:59.250
I can also pass a width and a height to draw the image in.

00:20:59.250 --> 00:21:05.420
In this case it's stretched the rectangle
in the horizontal direction and squished it.

00:21:05.420 --> 00:21:08.880
Now, that's one way to squish and stretch an image.

00:21:08.880 --> 00:21:11.230
But we could have also done it through transformation.

00:21:11.230 --> 00:21:14.990
So in this case I'm going to draw
the same rectangle a few times.

00:21:14.990 --> 00:21:19.720
The first thing I've done is translated the coordinate
system down by 100 units in the X direction and by 100 units

00:21:19.720 --> 00:21:22.200
in the Y direction and then drawn in a rectangle.

00:21:22.200 --> 00:21:26.519
And as far as the context knows, at that
point where I'm drawing the rectangle,

00:21:26.519 --> 00:21:33.299
the whole coordinate system has shifted and I've just got to
use whatever I'm in at the time to draw the, the rectangle.

00:21:33.299 --> 00:21:41.899
So now if I, again, translate the coordinate system
a bit further down I'm also going to apply scale,

00:21:41.900 --> 00:21:47.060
which means that from now as, while I'm
using my same model coordinate system

00:21:47.059 --> 00:21:51.399
when I render the screen all the X
values have been stretched by two.

00:21:51.400 --> 00:21:56.740
So what was a square is now, a 100
by 100 square is now rectangle.

00:21:56.740 --> 00:21:59.640
You can go further that, in fact, you
can then rotate the coordinate system.

00:21:59.640 --> 00:22:05.710
And these transformations, every one that you
apply, it sort of adds the transformation to a stack

00:22:05.710 --> 00:22:12.860
and you get a new coordinate system, and you
can reset the transforms to go back to usual.

00:22:12.859 --> 00:22:21.719
And what I like to do is, or one good approach is
the, the context of the notion of a stack of states.

00:22:21.720 --> 00:22:27.299
So, for example, you want to, you're in a function you
want to call another function that may do some transforms

00:22:27.299 --> 00:22:31.899
but you want to, when the function exits you
want to get back to the state you were before.

00:22:31.900 --> 00:22:38.180
What you do is, in fact, save the state on a stack, call
the function and everything you do to the fill style,

00:22:38.180 --> 00:22:42.529
the stroking and all the drawing
attributes apply to the current context.

00:22:42.529 --> 00:22:47.160
But once I call the restore state
I pop whatever the save, sorry,

00:22:47.160 --> 00:22:50.740
the save context is off the stack
and I'm back to, back to where I was.

00:22:50.740 --> 00:22:57.500
Actually, at this point I'll go do a demo.

00:22:57.500 --> 00:23:01.700
I thought there was a slide that says demo here.

00:23:01.700 --> 00:23:06.240
Just give you an example of what can be done.

00:23:06.240 --> 00:23:14.289
So, in the graphics and media state of the union, Darin
Adler from the WebKit team and Safari team got up

00:23:14.289 --> 00:23:20.379
and said Canvas is a way to do Canvas to
do the current trend of reflected images.

00:23:20.380 --> 00:23:24.740
Let's just have a quick look at how this was done.

00:23:28.849 --> 00:23:35.990
So here I've got a reference to the Canvas object, got a
reference to the context and I basically just draw an image.

00:23:35.990 --> 00:23:39.490
Grass in the name of the image I've got from the document.

00:23:39.490 --> 00:23:41.460
That's going to put the main image on the screen.

00:23:41.460 --> 00:23:43.640
And now I do some transformations on that.

00:23:43.640 --> 00:23:47.080
I'm going to flip the coordinate system
so that the reflection actually happens

00:23:47.079 --> 00:23:50.500
as if, it looks like the physical world would.

00:23:50.500 --> 00:23:55.730
And I also decide to set a bit of
alpha so it's not completely opaque.

00:23:55.730 --> 00:24:01.099
And then I draw a gradient color over the top
of it so that it fades into the background.

00:24:01.099 --> 00:24:05.230
So you can see, basically, here's a rectangle
and by the time it gets to there it's being,

00:24:05.230 --> 00:24:08.380
it's being drawn as if it's the background color.

00:24:08.380 --> 00:24:14.490
Now, what are the type of uses of Canvas?

00:24:14.490 --> 00:24:20.450
This, the thing is because you're actually just rendering
to the Canvas you're not necessarily putting any content

00:24:20.450 --> 00:24:25.490
in the, in the, in the document, means while Canvas
is incredibly useful you've got to be careful

00:24:25.490 --> 00:24:28.450
in the way that you actually use it on a page.

00:24:28.450 --> 00:24:33.380
So, I mean, I was just sort of thinking, well, what
happens if you had a surf shop and you wanted to, say,

00:24:33.380 --> 00:24:39.510
represent the, you know, the current swell or
whatever to the customers that were viewing the page?

00:24:39.509 --> 00:24:44.210
And what's, what's kind of interesting about this
is that it's an effect that people will see, but if,

00:24:44.210 --> 00:24:48.769
if they didn't have support for Canvas or
they're running on a device that doesn't,

00:24:48.769 --> 00:24:52.930
doesn't have the interactivity they're not
going to actually necessarily lose any content.

00:24:52.930 --> 00:24:58.539
They're still getting the same, same data that, some
people are just getting possibly a better experience.

00:24:58.539 --> 00:25:06.849
Although I, this demo isn't so fantastic
that I'd call it a better experience.

00:25:06.849 --> 00:25:10.519
Now, Canvas can be interactive in the same
way that every regular HTML element is.

00:25:10.519 --> 00:25:12.349
I can attach event listeners to it.

00:25:12.349 --> 00:25:15.789
So, I mean, here I'll click on it.

00:25:15.789 --> 00:25:23.049
You know, I'm a demolition company and I'm going old school
and I wanted a splash screen that, that enters into my site

00:25:23.049 --> 00:25:28.649
and is some cool bricks that manage
to hover in the air for a long time.

00:25:28.650 --> 00:25:33.000
But again, that just gives you an
example of the kind of, you know, it's a,

00:25:33.000 --> 00:25:37.990
quite a fast and well performed API you can use.

00:25:37.990 --> 00:25:42.349
In fact, people have implemented 3D
renderers,= sorry ray traces or fake sort

00:25:42.349 --> 00:25:45.319
of 3D engines using Canvas, or even games.

00:25:45.319 --> 00:25:48.279
I've seen lemmings replicated in Canvas.

00:25:48.279 --> 00:25:51.819
And again, you can have these interactive
elements that do things.

00:25:51.819 --> 00:25:53.299
You see opacity there.

00:25:53.299 --> 00:26:04.180
I can click and, and again just getting the current position
on the screen where the mouse is over and drawing a,

00:26:04.180 --> 00:26:06.830
drawing a circle and moving the mouse around.

00:26:06.829 --> 00:26:09.689
I'll go back to the slide.

00:26:09.690 --> 00:26:16.039
So, what you should keep in mind
when using something like Canvas is

00:26:16.039 --> 00:26:18.379
that you have to make sure the content is accessible.

00:26:18.380 --> 00:26:24.480
So, as I was mentioning, you shouldn't, you shouldn't rely
on the fact that people have got to see whatever you draw

00:26:24.480 --> 00:26:28.700
on the Canvas to effectively get to
the content or interact with your site.

00:26:28.700 --> 00:26:33.559
It's purely for giving effects or,
or adding something more to the page.

00:26:33.559 --> 00:26:38.859
Also, this is something that the
web accessibility guidelines say is

00:26:38.859 --> 00:26:40.649
that you should always use animations wisely.

00:26:40.650 --> 00:26:44.509
And there's a number of reasons for that, is
some people, it can actually be very distracting

00:26:44.509 --> 00:26:46.920
to them to have lots of movement on a page.

00:26:46.920 --> 00:26:51.900
Another good reason is that if you've got an
animation running that's just for the sake

00:26:51.900 --> 00:26:57.140
of making your page look cool you realize that,
you know, that's, that thing's hitting the CPU.

00:26:57.140 --> 00:27:01.870
It might not be doing much but if it's animating fast
enough it's, you know, something the CPU has to wake

00:27:01.869 --> 00:27:06.039
up for every time and if you're on a
resource limited device, for example,

00:27:06.039 --> 00:27:08.389
that might mean that the battery can't, I mean, sorry.

00:27:08.390 --> 00:27:10.270
they can't go into low power mode quickly.

00:27:10.269 --> 00:27:13.750
So it's important for sort of mobile devices.

00:27:13.750 --> 00:27:16.309
So that's all I had on, oh, there's the demo slide.

00:27:16.309 --> 00:27:17.339
There we go.

00:27:17.339 --> 00:27:18.730
That's all I had on Canvas.

00:27:18.730 --> 00:27:26.860
So now I'm pleased to invite my BFF, which is Best
French Friend, Antoine Quint on the stage.

00:27:26.859 --> 00:27:29.279
He's going to talk about SVG.

00:27:29.279 --> 00:27:33.440
( Applause )
I'm sorry.

00:27:34.579 --> 00:27:37.119
>> Thanks, thanks Dean.

00:27:37.119 --> 00:27:45.489
So we're going to continue into transoff exploring the
various capabilities that are available to you in Safari 3.

00:27:45.490 --> 00:27:51.140
And here we're really entering a world of
features that is completely new to Safari 3

00:27:51.140 --> 00:27:54.690
that were never supported before
in Safari 2 or previous versions.

00:27:54.690 --> 00:27:58.220
Of course, they've been available to
eager developers for a little while.

00:27:58.220 --> 00:28:02.460
We're downloading nightly bills of
WebKit and etcetera, but these are,

00:28:02.460 --> 00:28:08.069
this is the first time that Safari users will be
able to leverage these features when creating content

00:28:08.069 --> 00:28:11.159
and hosting WebKit within their application.

00:28:11.160 --> 00:28:15.960
A quick introduction to SVG.

00:28:15.960 --> 00:28:22.519
SVG just like HTML and CSS and a host of web
standards that people have grown to love or despise,

00:28:22.519 --> 00:28:26.569
but yet use on the web, is the W3C specification.

00:28:26.569 --> 00:28:30.669
It is fully, It is a full web standard designed as such.

00:28:30.670 --> 00:28:39.100
Currently the version of SVG that we will find implemented
in browsers is SVG 1.1, which really defines a set

00:28:39.099 --> 00:28:45.139
of features for creating rich graphics
specifically designed for the world wide web.

00:28:45.140 --> 00:28:52.080
Looking forward in a couple of years, as Dean highlighted,
it takes a while for technology as web standards

00:28:52.079 --> 00:28:58.329
to really get properly supported in
web browsers in reach a mass market.

00:28:58.329 --> 00:29:00.449
The next version of SVG is already under way.

00:29:00.450 --> 00:29:07.170
It's called SVG 1.2 and it will go more deeply in
the world of rich media and animations and interactivity.

00:29:08.450 --> 00:29:16.289
So the design goals of SVG when it was developed within
the W3C was to really provide flexible technology

00:29:16.289 --> 00:29:22.639
for creating graphics that would be scalable, which is very
important when you're dealing with various sizes for screens

00:29:22.640 --> 00:29:28.470
and resolutions and etcetera, but would also
be rich graphics, interactive and animated.

00:29:28.470 --> 00:29:31.390
And, of course, we're only dealing
here with the two dimensional graphics.

00:29:31.390 --> 00:29:36.759
There is nothing in SVG that will really help you
towards creating 3D worlds or anything like that.

00:29:36.759 --> 00:29:42.049
Another great design goal is that were
SVG to succeed on the web it would have

00:29:42.049 --> 00:29:44.809
to integrate properly with other web technologies.

00:29:44.809 --> 00:29:53.369
And integrating with XML, HTML, CSS, the DOM, JavaScript,
PNG and all other web standards they're using every day

00:29:53.369 --> 00:30:00.119
when designing web applications and web sites
have to be adequate, SVG has to be adequate

00:30:00.119 --> 00:30:02.619
and integrate nicely with those features.

00:30:02.619 --> 00:30:09.419
And Dean highlighted how important view source is when
you're a web developer and you want to learn new techniques

00:30:09.420 --> 00:30:12.230
and etcetera, and certainly SVG is no different to that.

00:30:12.230 --> 00:30:20.059
You're dealing the mark-up language and you can
open any SVG graphics on the web and view the source

00:30:20.059 --> 00:30:24.149
and learn how it was created directly,
which I think, personally,

00:30:24.150 --> 00:30:31.269
is something is a way I learned
a lot of my web design skills.

00:30:31.269 --> 00:30:36.289
Currently, So Safari 3 supports SVG as a new feature.

00:30:36.289 --> 00:30:40.559
Other browsers on the market support SVG as well.

00:30:40.559 --> 00:30:49.269
Firefox and Opera do support SVG and a similar set of
features such as shapes and paths, support for text,

00:30:49.269 --> 00:30:54.069
solid colors and gradients, stroke out
lines, opacity, fine transforms and etcetera,

00:30:54.069 --> 00:30:57.639
but also scripting and scripted animations.

00:30:57.640 --> 00:31:03.400
But we will get into that later when we get into
the more technical part of the presentation.

00:31:03.400 --> 00:31:09.440
The way SVG is being used today on the web, it's
still a very up and coming technology and this is due

00:31:09.440 --> 00:31:13.279
to browsers only starting to support
this technology recently.

00:31:13.279 --> 00:31:18.309
But, I think there are already good interesting
signs on the web of people picking this technology up

00:31:18.309 --> 00:31:24.009
and certainly the whole mindset currently around web
2.0, which is very pragmatic and a, you know,

00:31:24.009 --> 00:31:30.250
whatever means I'll have to import to meet
my end is what, doesn't really matter.

00:31:30.250 --> 00:31:35.910
I just need to do what I need to do and SVG
can be leveraged very well for the people

00:31:35.910 --> 00:31:37.810
who just want to get things done directly.

00:31:37.809 --> 00:31:42.359
So, of course, as an open standard it was
directly picked up in the open source world

00:31:42.359 --> 00:31:47.669
and as a documented format it's really well
suited for dynamic generation on the server,

00:31:47.670 --> 00:31:51.000
just like you would generate HTML dynamically.

00:31:51.000 --> 00:31:57.190
So you will find a few graphics packaging
and matting systems built around PHP, Perl or Java.

00:31:57.190 --> 00:32:01.420
But it also, SVG is also, of course,
a client's side technology.

00:32:01.420 --> 00:32:04.870
And JavaScript libraries are getting
more popular every day.

00:32:04.869 --> 00:32:08.359
There's a few mentioned in this very track at WWDC.

00:32:08.359 --> 00:32:16.559
And a few of those libraries, such as dojo, TIBCO and
Google Web Tool Kit, also using SVG as an abstraction,

00:32:16.559 --> 00:32:22.450
as a backend rendering for their java
script API's to do 2D graphics.

00:32:22.450 --> 00:32:27.450
So this is also a way that you can actually start using
SVG even though you might not use the language yourself,

00:32:27.450 --> 00:32:32.970
it is powered, everything that you'll do
with the API's will be powered by SVG.

00:32:32.970 --> 00:32:39.500
And actually to look at some well known applications
that have already started to use SVG, just to note a few.

00:32:39.500 --> 00:32:43.819
Google Maps and Windows Live Local
both support SVG to draw overlays,

00:32:43.819 --> 00:32:47.329
your little routes over the map of mostly restored data.

00:32:47.329 --> 00:32:52.359
And an interesting product that's just been
acquired by Google, it's called Tonicpoint,

00:32:52.359 --> 00:32:59.809
is really sort of a Power Point kind of
authoring tool on the web, web 2.0 application.

00:32:59.809 --> 00:33:02.039
But SVG goes beyond the web.

00:33:02.039 --> 00:33:08.629
As a standard it can be applied to, it can be applied
to any sort of space that people are interested to,

00:33:08.630 --> 00:33:14.100
in applying it and certainly as a graphics technology.

00:33:14.099 --> 00:33:19.609
And as a document format it is important that there's
graphics authoring tools out there for you to use

00:33:19.609 --> 00:33:25.099
and especially for designers who are not
really expected to code mark-up inscripting.

00:33:25.099 --> 00:33:28.759
And a few tools I'd like to mention
here is, of course, Adobe Illustrator,

00:33:28.759 --> 00:33:33.490
which is the industry standard tool
that has been SVG for years now.

00:33:33.490 --> 00:33:40.660
Lineform, which is Mac OS end tool that won the Apple
Design Award last year, is another tool that supports SVG.

00:33:40.660 --> 00:33:44.900
And in the open source world Inkscape is a
tool, a cross platform tool, that supports SVG.

00:33:44.900 --> 00:33:46.630
It's a vector drawing packet.

00:33:46.630 --> 00:33:52.250
There are many, many more tools from the
CAD world to the mapping world and etcetera.

00:33:52.250 --> 00:33:54.920
These are mostly creative graphics tools

00:33:54.920 --> 00:34:00.340
but lots of industries have already
started to run SVG for content creation.

00:34:00.339 --> 00:34:04.049
But in terms of the web desktop, sorry.

00:34:04.049 --> 00:34:11.289
In terms of desktop usage SVG is already used
also within the KDE and Gnome user interfaces

00:34:11.289 --> 00:34:14.489
to render all the icons that will be rendered on screen.

00:34:14.489 --> 00:34:22.899
Of course, SVG being a vector graphics format it is
really handy, it is very handy to define your icons using

00:34:22.900 --> 00:34:28.639
that format because that means your icon will be able to
scale to whatever the user preference would be set to,

00:34:28.639 --> 00:34:35.859
so if you want small or great big icons you will still
get the same level of details all rendered by SVG.

00:34:35.860 --> 00:34:41.360
And moving into the web, web/
desktop application space, hybrid apps,

00:34:41.360 --> 00:34:44.440
which is another topic that's covered at the WWDC this year.

00:34:44.440 --> 00:34:50.230
A TV application that's launching, currently called
Joost, actually chose to use web technologies

00:34:50.230 --> 00:34:54.119
and more specifically SVG to create
it's whole user interface.

00:34:54.119 --> 00:35:00.359
And what's interesting Joost is that the whole user
interface is scalable so that when you use it on the TV,

00:35:00.360 --> 00:35:08.829
which might be 69 and HD, fulli HD, etcetera or a computer
or any kind of resolution and screen aspect ratio,

00:35:08.829 --> 00:35:15.549
the UI will scale and behave nicely
regardless of your display settings.

00:35:15.550 --> 00:35:19.160
So this is a few of the things, a couple
of screen shots of the application.

00:35:19.159 --> 00:35:25.869
And you can see everything here
is basically rendered using SVG.

00:35:25.869 --> 00:35:30.719
So put back SVG into a context of web development.

00:35:30.719 --> 00:35:37.789
First of all, I think what is really tremendously
great about SVG is that when you use SVG,

00:35:37.789 --> 00:35:42.409
even though it might be a new technology,
you are not entering a foreign territory.

00:35:42.409 --> 00:35:45.799
You are likely going to have a whole
lot of skills that would be directly,

00:35:45.800 --> 00:35:48.620
that you will be able to directly apply to SVG.

00:35:48.619 --> 00:35:53.279
So a few of the main points about SVG and to
meet those design goals I mentioned early.

00:35:53.280 --> 00:35:54.990
SVG uses an XML grammar.

00:35:54.989 --> 00:35:56.769
Everything is basically mark-up.

00:35:56.769 --> 00:36:01.019
So when you draw things you basically
have elements in your document

00:36:01.019 --> 00:36:05.050
that define how things need to be rendered on the screen.

00:36:05.050 --> 00:36:10.940
And just like in HTML when you can use java
script and the DOM to manipulate your content,

00:36:10.940 --> 00:36:14.480
the same concept can be applied directly to SVG.

00:36:14.480 --> 00:36:18.829
CSS, of course, is also useable on SVG.

00:36:18.829 --> 00:36:25.190
And finally, what I think is very important about SVG
is that it can be, as a web standard it can be and is,

00:36:25.190 --> 00:36:28.389
of course, implemented natively by browsers.

00:36:31.510 --> 00:36:40.620
So what it really means in practice is that now you can
author content is the same principle like HTML and CSS.

00:36:40.619 --> 00:36:45.219
You know about mark-up, you know about structuring
your mark-up, you know about semantics around mark-up,

00:36:45.219 --> 00:36:50.359
you know how to apply CSS and selectors and etcetera,
and these exact same things you will be able to apply

00:36:50.360 --> 00:36:55.120
when creating SVG content and developing with SVG content.

00:36:55.119 --> 00:36:59.069
What's really interesting, of course, because of the
mark-up and the fact that it's an open standard is

00:36:59.070 --> 00:37:01.010
that it is integrated right into your web page.

00:37:01.010 --> 00:37:05.820
You're not using a plugin architecture and just
rendering something on the side in a black box.

00:37:05.820 --> 00:37:10.680
You're really, it is a first class citizen
within your web page or in your web application.

00:37:10.679 --> 00:37:16.879
And when it comes to scripting, well, then all
the skill set you've, you've starting to build

00:37:16.880 --> 00:37:20.340
up around AJAX is going to be applied directly also to SVG.

00:37:20.340 --> 00:37:25.500
You'll be using the same programming language, which is JavaScript,
and the same programming API's, which is the DOM.

00:37:25.500 --> 00:37:31.690
So all you really need to know, if I may say
so, is to know about SVG specifics and to learn

00:37:31.690 --> 00:37:34.269
about how you can create graphics using SVG.

00:37:34.269 --> 00:37:39.900
But before we delve into that I just wanted
to say a few things more related to the Mac.

00:37:39.900 --> 00:37:45.210
SVG was not designed for the Mac or for
any platform in particular for that matter.

00:37:45.210 --> 00:37:50.920
But I think it's worth understanding that
SVG really feels like a Mac type technology.

00:37:50.920 --> 00:37:54.369
The way SVG is implemented, for
example, in the WebKit rendering engine

00:37:54.369 --> 00:37:57.210
in Safari is using the Quartz 2D graphics comm-and.

00:37:57.210 --> 00:38:06.130
So Dean showed in Canvas how commands would be mapped very
acute between Quartz 2D and Canvas,

00:38:06.130 --> 00:38:10.220
while SVG, in a way, is a very higher level of
abstraction across those very rich drawing API's.

00:38:10.219 --> 00:38:19.109
And, of course, since everything in SVG is based on vectors
you get by default resolution independence as a feature.

00:38:19.110 --> 00:38:25.059
So when you're dealing with new types of user interfaces,
this is really something that will be tremendously useful.

00:38:25.059 --> 00:38:30.389
All you need to do is change some of the properties of your
SVG document but the scaling will be done automatically.

00:38:31.610 --> 00:38:36.760
So comparing SVG to some other proprietary type of
technologies that are cropping up today or have been

00:38:36.760 --> 00:38:40.950
around the web for a long time now,
well, the core difference, of course,

00:38:40.949 --> 00:38:46.189
is that SVG is a royalty free standard
developed by the W3C and is open.

00:38:46.190 --> 00:38:48.730
You can participate as a developer if you're interested.

00:38:48.730 --> 00:38:52.440
And, of course, it lends itself very
well to open source implementations.

00:38:52.440 --> 00:39:01.809
And a direct benefit of the fact that it's an open royalty
free standard is that standard does not belong to anyone.

00:39:01.809 --> 00:39:08.340
It is vendor neutral and it's not up to a single
company to define where this technology will be going.

00:39:08.340 --> 00:39:13.280
So as a user or as a member of a corporation
you can join the W3C, for example,

00:39:13.280 --> 00:39:18.670
and join the effort of defining the
next, the next steps of the SVG standard.

00:39:18.670 --> 00:39:24.710
But another great benefit is that instead of dealing with
single implementation and possibly a company that would rest

00:39:24.710 --> 00:39:30.389
on its laurels or stop listening its customers because
they have the strategy they want to impose on their users,

00:39:30.389 --> 00:39:35.119
but we're dealing here with the technology that will
be implemented by many implementations and certainly Safari,

00:39:35.119 --> 00:39:37.599
Firefox and Opera are a great example of this.

00:39:37.599 --> 00:39:40.929
And these people will be competing
to provide the best experience.

00:39:40.929 --> 00:39:49.250
So we saw great, that on the web when Internet Explorer was
a great dominant force on the web and slowed development

00:39:49.250 --> 00:39:51.920
for years, it's really slowed down
the innovation on the web.

00:39:51.920 --> 00:39:59.289
And only when new wave browsers such as Safari
cropped up, then the web 2.0 wave happened

00:39:59.289 --> 00:40:02.019
and it opened up a great new world of possibilities.

00:40:02.019 --> 00:40:05.699
So I think this is a tremendous advantage of SVG.

00:40:05.699 --> 00:40:10.319
But, of course, like I said SVG is standards based.

00:40:10.320 --> 00:40:15.480
It's based on mark-up, CSS and JavaScript and
so you will be able to use it at the same level

00:40:15.480 --> 00:40:17.590
as a first class citizen as this technology is.

00:40:17.590 --> 00:40:18.600
You're not dealing with a plugin.

00:40:18.599 --> 00:40:24.099
And not dealing with a plugin means that instead of
dealing with a black box that's rendered on your screen,

00:40:24.099 --> 00:40:29.659
you're dealing with something that shares
the same rendering model as HTML and CSS.

00:40:29.659 --> 00:40:35.889
So if you really want to do precise intricate
compositions, you will have all the flexibility

00:40:35.889 --> 00:40:39.920
that you will need using SVG and other web standards.

00:40:39.920 --> 00:40:47.059
Directly related to this, having a mark-up and a shared
tree means that the same inventing models will be used

00:40:47.059 --> 00:40:50.980
across your HTML and SVG content, whereas if you're dealing

00:40:50.980 --> 00:40:55.539
with a proprietary technology they will probably have a
different inventing model and certainly something

00:40:55.539 --> 00:41:00.420
that would be more local to the little black
box in which you render inside the plugin.

00:41:00.420 --> 00:41:06.730
And another aspect of this shared DOM tree is that you will
be using the same API's and the same scripting environment

00:41:06.730 --> 00:41:14.250
to double up your SVG content and implement interactivity
and animation and we'll see some example of that later on.

00:41:14.250 --> 00:41:18.150
But when you're dealing with plugins and
proprietary technologies then you will certainly have

00:41:18.150 --> 00:41:23.849
to use either a different language or a different iteration
of a language and certainly a different set of API's.

00:41:23.849 --> 00:41:28.880
So, I guess what I really mean to say here is
that SVG really belongs on the web just like HTML

00:41:28.880 --> 00:41:36.010
and CSS's have been developed, this is really something that
should be familiar to anyone who has skills in this area.

00:41:36.010 --> 00:41:39.410
So Dean went through the Canvas features earlier.

00:41:39.409 --> 00:41:44.599
And, of course, these are two technologies
that share some, that have things in common.

00:41:44.599 --> 00:41:51.440
So it is, well, mostly that they are used to create 2D
rich graphics, but they are, however, quite different.

00:41:51.440 --> 00:41:56.200
So it's worth trying to isolate some use cases
in which technology might be more appropriate.

00:41:56.199 --> 00:42:01.009
Of course, your mileage may vary and depending
on your skill set, if you are more interested

00:42:01.010 --> 00:42:09.590
in direct programming using lower level API's or higher
level mark-up then you will definitely make your own choice.

00:42:09.590 --> 00:42:15.570
But for those few use cases, for example, if you're dealing
with a static image, basically a static graphics asset

00:42:15.570 --> 00:42:21.170
that you would want to use to load dynamically in
your document or you want to save an image in SVG.

00:42:21.170 --> 00:42:27.079
Well, SVG is a documented format so it is really meant
to be used in that way, whereas Canvas is a series

00:42:27.079 --> 00:42:33.279
of programatic operations so it does not really,
is not really contained inside a format or anything.

00:42:33.280 --> 00:42:38.630
So if you're creating two static images,
then SVG is probably a better choice.

00:42:38.630 --> 00:42:44.740
When you're dealing with huge number of objects, Dean
highlighted how Canvas is a way to just draw and forget.

00:42:44.739 --> 00:42:49.750
So there's no huge memory footprints
attached to using Canvas.

00:42:49.750 --> 00:42:55.539
So in this case, if you need reperformance and
don't really care about preserving state of objects

00:42:55.539 --> 00:42:59.110
and etcetera, then Canvas is probably a safer bet.

00:42:59.110 --> 00:43:06.599
But when we're dealing with interactivity then SVG really
shines because, exactly because Canvas draws and forgets,

00:43:06.599 --> 00:43:11.630
you do not have the concept of objects or
structure that you will be dealing with.

00:43:11.630 --> 00:43:17.900
Whereas SVG always has anything that's drawn on screen
has a direct live representation in your DOM tree.

00:43:17.900 --> 00:43:22.369
So when you need to do interactivity you can simply
get a handle to one object and update that object,

00:43:22.369 --> 00:43:28.239
whereas in Canvas you would have to rerender the
whole Canvas to change the state of your graphics.

00:43:28.239 --> 00:43:30.429
Same goes for animation basically.

00:43:30.429 --> 00:43:35.669
Since, if you want to do a discreet animation on one
object of your tree, well, in SVG this is simple,

00:43:35.670 --> 00:43:38.930
you can just get a handle to that
rectangle, change its width over time.

00:43:38.929 --> 00:43:41.799
Whereas in Canvas, once again you
would have to compute the animation

00:43:41.800 --> 00:43:46.019
and the rest of the graphics to rerender every time.

00:43:46.019 --> 00:43:51.309
And, of course, if you don't really care about a data
model and just want to draw something and forget about it

00:43:51.309 --> 00:43:55.909
and just display it and let it sit there, then
Canvas is probably also going to be, in that case,

00:43:55.909 --> 00:44:01.210
a better choice because, well, what's the point of
having too many bells and whistles when all you want is

00:44:01.210 --> 00:44:04.110
to display a bunch of pixels on the screen?

00:44:04.110 --> 00:44:08.190
And finally, when you're dealing with server generated
content then, obviously, SVG is the smarter choice

00:44:08.190 --> 00:44:13.950
because it is XML, there are millions of tools out
there on the server sites to deal with XML content

00:44:13.949 --> 00:44:18.480
or even graphic packages, mapping,
etcetera, like I mentioned earlier.

00:44:18.480 --> 00:44:25.329
So basically document format is always going to be
more appropriate for creating content on the server.

00:44:25.329 --> 00:44:28.489
So let's get started into more technical part of SVG.

00:44:28.489 --> 00:44:33.399
We won't get in depth because God knows SVG
is feature rich and it takes a little while

00:44:33.400 --> 00:44:36.840
to really work out its little intricate details.

00:44:36.840 --> 00:44:41.329
But we'll still, however, try to cover the main bases.

00:44:44.250 --> 00:44:50.800
First of all, before drawing anything with SVG you need
to understand how you can integrate SVG in your web page.

00:44:50.800 --> 00:44:53.240
You have severate, several, sorry.

00:44:53.239 --> 00:44:57.959
You have several scenarios as to
how you want to go around doing it.

00:44:57.960 --> 00:45:02.369
First scenario is by using a reference to SVG document.

00:45:02.369 --> 00:45:07.829
So just like in HTML you can use an IFrame to load
an external HTML document, you can use object embed

00:45:07.829 --> 00:45:10.900
or IFrame to point to an external SVG document.

00:45:10.900 --> 00:45:13.619
However, if you're dealing with
more of a scripted environments

00:45:13.619 --> 00:45:17.230
or you want the optimal flexibility
then you will probably want

00:45:17.230 --> 00:45:20.990
to mix the mark-up, HTML and SVG into a single document.

00:45:20.989 --> 00:45:28.129
So in that case you will have to contain all your SVG
graphics within an SVG element within the SVG name space.

00:45:28.130 --> 00:45:34.470
Of course, you don't even have to have any mark-up
already sitting there to create SVG graphics on fly.

00:45:34.469 --> 00:45:42.599
Using script you can directly use the DOM to add
any new SVG assets to your document using the DOM.

00:45:42.599 --> 00:45:48.469
So just to look at pros and cons of
either techniques reference and inclusion.

00:45:48.469 --> 00:45:54.189
Using a reference inclusion will mean that if you're
dealing with maybe a widget, like a stock widget,

00:45:54.190 --> 00:45:57.079
that you would just want to display on your web
page but it's not really part of the contents,

00:45:57.079 --> 00:46:02.750
it's just something you want to have sitting there as
an add on, then you're dealing with an external asset

00:46:02.750 --> 00:46:07.980
and it's probably better to just point to
a URI and let it be and not bother your,

00:46:07.980 --> 00:46:10.059
the rest of your document to deal with this.

00:46:10.059 --> 00:46:16.159
But however, using that technique if you want to get inside
the content and update it, integrate it with the rest

00:46:16.159 --> 00:46:21.710
of your web page then you will have to use
specific DOM accessors to get to the SVG document.

00:46:21.710 --> 00:46:26.289
In that case it is the content document property that
you'll be able to access on the object rendered element.

00:46:26.289 --> 00:46:36.150
Whereas when you're using inclusion you're dealing with a
mixed name space DOM tree, which is also a single DOM tree.

00:46:36.150 --> 00:46:40.889
And that means that you have complete flexibility
as to how you want to structure your contents.

00:46:40.889 --> 00:46:43.519
This also means that you have assured DOM and CSS trees.

00:46:43.519 --> 00:46:49.929
So you can apply styling with a unique style trees to both
SVG and HTML content, which is really, really practical.

00:46:49.929 --> 00:46:54.349
So it's really about if you're dealing with
external assets or you just want to bring in there

00:46:54.349 --> 00:47:00.690
or if you want something very flexible and to have a
unique document to represent both your textual data and,

00:47:00.690 --> 00:47:03.769
and etcetera and HTML and more graphics in SVG.

00:47:03.769 --> 00:47:12.019
So, obviously at that point using a mixed document
it'll be tougher to manage external graphic resources.

00:47:12.019 --> 00:47:18.469
So SVG is, has pretty much all the graphics features
that you would expect from a modern graphics language.

00:47:18.469 --> 00:47:23.319
Vector shapes, obviously it's a vector language
so these are the core basic curves and etcetera.

00:47:23.320 --> 00:47:29.420
Of course, you can also have solid colors but also
gradients and patterns, fill opacity, etcetera.

00:47:29.420 --> 00:47:33.000
These are all features that we're going
to go through by example right now.

00:47:33.000 --> 00:47:39.809
And a second set of features that we'll go around later
on is how you can use the DOM to add interactivity to SVG.

00:47:39.809 --> 00:47:46.070
And this is really where SVG shines and is unique is
leveraging the concept of mark-up and scripting together

00:47:46.070 --> 00:47:50.840
to create really interactive graphics
and even animated graphics.

00:47:50.840 --> 00:47:55.480
So to start things softly the first
thing, the equivalent of hello world

00:47:55.480 --> 00:47:58.199
in the graphics world is to draw a rectangle.

00:47:58.199 --> 00:48:03.799
So, whereas in Canvas, of course, you would use
a set of API's to basically do the same thing,

00:48:03.800 --> 00:48:06.650
in here you're just using a declarative mark-up approach.

00:48:06.650 --> 00:48:14.160
So you have a rectangle drawn witha rect element, set its
graphic properties using the XML attributes XY in width

00:48:14.159 --> 00:48:20.359
and height and it doesn't really take a genius
to work out what is going to happen here.

00:48:20.360 --> 00:48:24.519
Of course, rounded rectangle are also supported.

00:48:24.519 --> 00:48:32.929
You just have to use the RX and RY attributes to define
the corner radius and the X and Y axis for your rectangle.

00:48:32.929 --> 00:48:36.119
Circles are represented by their own elements as well.

00:48:36.119 --> 00:48:43.500
The CX and CY will define the center of the
elements and the R attribute will define the radius.

00:48:43.500 --> 00:48:47.820
Ellipse are pretty similar except you will
have both an RX and RY instead of radiuses

00:48:47.820 --> 00:48:52.330
to deal with the X axis and Y axis radius.

00:48:52.329 --> 00:48:56.250
Polygon is another element where
you can give it a set of points.

00:48:56.250 --> 00:49:01.590
And I think something that's worth mentioning here
is that even though SVG is an XML language all

00:49:01.590 --> 00:49:04.890
of its features are not directly exposed as XML.

00:49:04.889 --> 00:49:12.799
So, in that case, the list of points, which is a flat
structure, is, is just a micro syntax within an attribute.

00:49:12.800 --> 00:49:18.200
So you could have thought that we would
have a set of elements as child of polygon

00:49:18.199 --> 00:49:20.839
to specify points but that's not the way SVG is designed.

00:49:20.840 --> 00:49:26.800
I actually don't think it makes a lot of sense because
XML is very good for a hierarchy, something that has order

00:49:26.800 --> 00:49:31.940
that you might want to reorder, whereas
this is really a flat list of coordinates.

00:49:31.940 --> 00:49:39.599
Path, of course, you need to have optimal
flexibility when dealing with graphics on the web.

00:49:39.599 --> 00:49:44.440
And here again we have micro syntax with
different comments such as, M for move to,

00:49:44.440 --> 00:49:48.329
C for curves and they're lots of other sets of comments.

00:49:48.329 --> 00:49:52.539
You can use a path, for example, to draw the Apple logo.

00:49:52.539 --> 00:50:00.130
And, of course, when you draw things you need to bring color
into the equation to have something render on the screen.

00:50:00.130 --> 00:50:05.000
And so instead of having, like in Canvas,
a context of here's what I'm doing now,

00:50:05.000 --> 00:50:07.889
I'm using red color to fill in stroke and etcetera.

00:50:07.889 --> 00:50:11.960
Here we just have per object properties
to define what color they are.

00:50:11.960 --> 00:50:17.050
So you can use the fill attributes to define what the fill
color is, the stroke attribute to define the stroking.

00:50:17.050 --> 00:50:20.120
Fill and stroke out all on the same
object, which is actually quite handy,

00:50:20.119 --> 00:50:23.000
you don't have to use two separate
things to draw a fill and a stroke.

00:50:23.000 --> 00:50:26.739
And you can use all sorts of values for
these, for these fill and stroke attributes.

00:50:26.739 --> 00:50:33.379
So you can use key words such as blue, an RGB
combination, RGBA actually also if you want

00:50:33.380 --> 00:50:37.650
to have transparency directly expressed in
your fields stroke color, decimal, etcetera.

00:50:37.650 --> 00:50:41.990
All this, the same data types that
you would use in HTML and CSS.

00:50:41.989 --> 00:50:48.459
You can also control fill and stroke capacity
separately from one another or use an opacity attribute

00:50:48.460 --> 00:50:51.610
to compose the whole graphics together
against the background.

00:50:51.610 --> 00:50:58.349
Of course, we can get into more advanced
paint service such as, linear gradients,

00:50:58.349 --> 00:51:00.699
once again, nothing very surprising here.

00:51:00.699 --> 00:51:07.779
We define the linear gradient elements, give it an ID so
we can use it later on to define an object that will use

00:51:07.780 --> 00:51:15.180
that as a fill and you use XY, Y1, X2, Y2
attributes to define the direction of the gradient.

00:51:15.179 --> 00:51:24.559
In that case we have a gradient that's going to
go from the top, well, anyway, you figure it out.

00:51:24.559 --> 00:51:30.460
And to use that linear gradient you
just use URL construct within your fill.

00:51:30.460 --> 00:51:36.550
So that means you can create a set of resources of (unclear)
that can be used by different assets in your document.

00:51:36.550 --> 00:51:40.490
So you can have five different rectangles using
the same gradient and if that gradient changes

00:51:40.489 --> 00:51:42.679
or is animated then the different objects that use

00:51:42.679 --> 00:51:46.679
that gradient will automatically be
kept in sync, which is really handy.

00:51:46.679 --> 00:51:49.519
Radial gradients, of course, pretty much the same way.

00:51:49.519 --> 00:51:53.599
You also define a center for the gradients and a radius.

00:51:53.599 --> 00:51:55.789
You can have, of course, multiple stops.

00:51:55.789 --> 00:52:00.610
Here there's only a first and a last stop, go from
zero to one but you can have as many stops as you want

00:52:00.610 --> 00:52:04.740
with how many colors as you want,
and, of course, you can also set up,

00:52:04.739 --> 00:52:08.409
even though it is not illustrated
here, a stop opacity for each stop.

00:52:08.409 --> 00:52:13.889
So you can have nice little drop
shadows that will fade in gradually.

00:52:13.889 --> 00:52:17.609
Clipping, another very important feature in graphics.

00:52:17.610 --> 00:52:20.030
So a clip path is a shared resource.

00:52:20.030 --> 00:52:24.600
You can use any SVG element as a
child to define your clip pass.

00:52:24.599 --> 00:52:28.239
So it doesn't have to be a rectangle or
rounded rectangle, it can be anything.

00:52:28.239 --> 00:52:29.579
It could be very free form.

00:52:29.579 --> 00:52:31.819
It could be a path, for example.

00:52:31.820 --> 00:52:37.809
In this case we're using an ellipse and we applied a clip
path of the ellipse to a rectangle by using, once again,

00:52:37.809 --> 00:52:41.599
the URL construct applied to the clip path attribute.

00:52:41.599 --> 00:52:50.150
And you can see the rendered area here in between the stroke
lines with the solid fills of blue and the stroke of red.

00:52:50.150 --> 00:52:51.800
And there are, of course, way more features.

00:52:51.800 --> 00:52:53.950
I mentioned here we haven't used any CSS.

00:52:53.949 --> 00:52:56.169
We have only used direct text and attributes

00:52:56.170 --> 00:53:01.700
but in this case we're just demonstrating how we can
use the same attributes as properties so we have fill,

00:53:01.699 --> 00:53:05.980
stroke and stroke width properties,
which are new to CSS for SVG usage.

00:53:05.980 --> 00:53:10.240
And you can create a class, for example, the mr-f class here, which we'll be able to reuse

00:53:10.239 --> 00:53:13.689
across different graphics later
on by using the class attributes.

00:53:13.690 --> 00:53:17.610
You can also define styles inline on
your elements using the style elements

00:53:17.610 --> 00:53:21.090
if that's what you're in to, just like you would in HTML.

00:53:21.090 --> 00:53:25.539
You can draw text very easily by giving it an anchor.

00:53:25.539 --> 00:53:29.389
The baseline will be the lower part
of the text that will be aligned

00:53:29.389 --> 00:53:33.549
with this position and just have you text right here.

00:53:33.550 --> 00:53:39.410
So this is really handy because not only you can draw text
but you can transform text just like any other part of SVG.

00:53:39.409 --> 00:53:43.369
So in this case we rotate the R text by 45 degrees.

00:53:43.369 --> 00:53:50.279
Like I said earlier, we can use class attribute
to define the look and feel of our rectangles.

00:53:50.280 --> 00:53:53.900
In this case we're using the mr-f class that we used earlier.

00:53:53.900 --> 00:54:01.470
And another great feature of SVG is that as long as you
define an element with an ID you will be able to reuse

00:54:01.469 --> 00:54:06.539
that element in any other part of your
document without having to replicate it

00:54:06.539 --> 00:54:09.059
in the DOM tree just by using the use element.

00:54:09.059 --> 00:54:14.630
So in this case we have the Apple logo as a path,
which shows in white at the lower end of the screen,

00:54:14.630 --> 00:54:19.360
and we're going to use it once more with a
transform to scale it and rotate it a little bit,

00:54:19.360 --> 00:54:26.340
apply a class using CSS and, in this case, we're
using the xlink:href attribute to point to that logo.

00:54:26.340 --> 00:54:32.030
So this is really handy when you're dealing with
symbols and etcetera in your, in your, in your content.

00:54:32.030 --> 00:54:37.460
So what, It's really interesting, and I'm not going to
spend a lot of time here because, well, first of all I'm,

00:54:37.460 --> 00:54:43.949
time's running out, but also because as developers I think
this type of things will be very handy for you to pick up.

00:54:43.949 --> 00:54:49.439
And, like I said, SVG is only using the DOM
so all the knowledge you know about HTML,

00:54:49.440 --> 00:54:52.190
scripting HTML is directly applied to SVG.

00:54:52.190 --> 00:54:58.380
So if you need a handle to an SVG element you just use the
getElementById method and pass an ID that you will have set

00:54:58.380 --> 00:55:03.869
in your mark-up as well and you will get a
DOM object pointing to that piece of mark-up.

00:55:03.869 --> 00:55:07.309
You can get elements by tag names, of course,
so if you want to get the list of rectangles

00:55:07.309 --> 00:55:13.769
in your document set the name space to the SVG name
space and rect to be the name of their elements

00:55:13.769 --> 00:55:16.619
and you will get a list of all
the rectangles in your document.

00:55:16.619 --> 00:55:22.589
Of course, you can create SVG document, SVG content on on
the fly just like you can create HTML content on the fly.

00:55:22.590 --> 00:55:25.059
You will use the create element method in that case.

00:55:25.059 --> 00:55:28.119
Just give it the SVG name space, the name
of the element you're going to create,

00:55:28.119 --> 00:55:31.099
and once you have done that you
will want to set its coattributes.

00:55:31.099 --> 00:55:35.089
So if you want to draw rectangle, for
example, create element NS and SVG name space

00:55:35.090 --> 00:55:38.170
and the rect string to create the rect element.

00:55:38.170 --> 00:55:43.349
And once you have a handle to that element use
the set attribute method you set the XY width

00:55:43.349 --> 00:55:44.500
and height and etcetera.

00:55:44.500 --> 00:55:48.630
So you can do all this dynamically
on the fly within the client.

00:55:48.630 --> 00:55:52.380
And you will use the appendChild and
removeChild methods to move content around

00:55:52.380 --> 00:55:54.890
and put it in the right place in your document.

00:55:54.889 --> 00:56:00.609
So I won't go in great detail about this because this is all
sorts of things you will find greatly documented out there

00:56:00.610 --> 00:56:04.660
and everyone uses it to, to program the web content.

00:56:04.659 --> 00:56:08.029
But what's interesting about SVG is
that because it's a graphics technology

00:56:08.030 --> 00:56:13.340
and all of these preceding methods I've mentioned
were all about dealing with an XML structure,

00:56:13.340 --> 00:56:17.350
SVG really needed something to be
able to deal with graphics directly.

00:56:17.349 --> 00:56:22.980
So the first few things that you will have
in SVG and the SVG DOM is you will have a set

00:56:22.980 --> 00:56:26.659
of data types that you can use in the graphic context.

00:56:26.659 --> 00:56:32.399
So SVG point to represent a point, SVG rect
or rectangle SVG matrix for metrics, etcetera.

00:56:32.400 --> 00:56:38.019
Those data types are used, you will encounter them when
you start using methods such as, get (unclear) box,

00:56:38.019 --> 00:56:42.679
you query the getBBox of an element, which might
be complex and not directly replicated in the mark-up.

00:56:42.679 --> 00:56:48.369
So if you're dealing with a path, essentially if you want to
have the bounding box and only had the XML data to figure

00:56:48.369 --> 00:56:52.079
that out you would essentially have
to redraw the path yourself logically.

00:56:52.079 --> 00:56:56.719
So the DOM in SVG will allow special
methods to do that directly.

00:56:56.719 --> 00:57:01.000
So getBBox will return SVG rect
object with the metrics wherever the element is

00:57:01.000 --> 00:57:03.760
in your tree, if it's a group of elements and etcetera.

00:57:03.760 --> 00:57:07.870
You can also query the transformation
matrix applied to an element in,

00:57:07.869 --> 00:57:12.960
in respect to another element using the
getTransformToElement and get the screen,

00:57:12.960 --> 00:57:20.039
the complete transformation matrix all the way up to
the client user space using the getScreenCTM method.

00:57:20.039 --> 00:57:26.980
This method will return a matrix and you can use
this matrix, for example, to take the client X

00:57:26.980 --> 00:57:32.619
and client Y properties of an event and
transform them to get into the user space

00:57:32.619 --> 00:57:37.259
of the current SVG object that you're dealing with.

00:57:37.260 --> 00:57:43.310
So this is really handy and, of course, SVG DOM also has
a set of API's to deal with those micro syntaxes

00:57:43.309 --> 00:57:47.190
that I talked about so path structure,
a list of points and etcetera.

00:57:47.190 --> 00:57:52.039
So you can expect that as an essential tool kit.

00:57:52.039 --> 00:57:59.309
So like I said SVG is really great for interactive content.

00:57:59.309 --> 00:58:03.699
Interactivity is all about reacting
to user interface events.

00:58:03.699 --> 00:58:10.849
And in HTML you will use all of the same types of
techniques and in SVG you can directly use them as well.

00:58:10.849 --> 00:58:16.000
So if you want to, it's not scripting per se, but if
you want to apply a behavioral change, for example,

00:58:16.000 --> 00:58:20.739
mouse over when an element is focused, you
can use the CSS pseudo classes :hover

00:58:20.739 --> 00:58:24.839
and :focus to change the styling
properties of an SVG element.

00:58:24.840 --> 00:58:31.519
Of course, you can also use mark-up based handler
onclick and onmousemove to call a special piece of JavaScript,

00:58:31.519 --> 00:58:34.849
which is really good if you're dealing with pre-defined event handlers.

00:58:34.849 --> 00:58:39.960
And you can add event handlers programmatically
as you are creating your content.

00:58:39.960 --> 00:58:44.659
You can also add listeners directly from JavaScript
using the addEventListener methods,

00:58:44.659 --> 00:58:46.949
which is great for dynamically adding event handlers.

00:58:46.949 --> 00:58:56.179
And animation is basically performed by using
the same methods in the DOM recursively.

00:58:56.179 --> 00:58:59.889
So in this case, for example, I'm using
the set interval function from JavaScript

00:58:59.889 --> 00:59:06.009
that will call another function repeatedly given
a specific interval, and in this case I will want

00:59:06.010 --> 00:59:09.070
to fade an element from opacity one to opacity zero.

00:59:09.070 --> 00:59:14.780
I check the first, the start, the start time
by getting the time from a new data object,

00:59:14.780 --> 00:59:20.740
set the duration to be two seconds 2000 milliseconds,
iterate through that time figure out the offsets

00:59:20.739 --> 00:59:23.919
and apply basically that value as the opacity.

00:59:23.920 --> 00:59:30.329
So using this function, this gives you a way to
animate the opacity of an element across two seconds.

00:59:30.329 --> 00:59:34.730
So let's get to the most interesting part of the
session, which is, of course, demonstrations.

00:59:34.730 --> 00:59:37.699
Switching to demo screens.

00:59:37.699 --> 00:59:43.659
Thanks. So I have three little demos
that are actually pretty simple, I think.

00:59:43.659 --> 00:59:46.329
So this first demo probably doesn't look interesting at all.

00:59:46.329 --> 00:59:50.929
I mean, I'm just here, it's probably
just one of those new HTML five elements,

00:59:50.929 --> 00:59:53.969
which is the input type search, which was an
input invention.

00:59:53.969 --> 01:00:00.269
Instead of just using that element directly I chose, because
I like that kind of stuff, to implement it myself using SVG.

01:00:00.269 --> 01:00:06.769
So you can rescale it and, I guess this is really
smooth when you're dealing with a need for scalable UI.

01:00:06.769 --> 01:00:12.840
If you have a really high DPI screen, and certainly
those new 17 inch Mac Book Pros have very high DPI, well,

01:00:12.840 --> 01:00:16.220
it would be pretty nice to be using
SVG to draw your URL elements.

01:00:16.219 --> 01:00:23.379
So the funky thing here is that actually this part
here is HTML so I can type whatever I want here.

01:00:23.380 --> 01:00:26.180
It's just an input element.

01:00:26.179 --> 01:00:32.659
And the way I draw it is that I have a rectangle here
in the background that you do not see in SVG and I query

01:00:32.659 --> 01:00:37.969
in symmetrics dynamically every time I want
to redraw because the scaling is defined

01:00:37.969 --> 01:00:40.949
by the mark-up and, so this is really, really handy.

01:00:40.949 --> 01:00:48.069
And, of course, I can create my own focus ring
using gradient and, it's pretty, it's pretty neat.

01:00:48.070 --> 01:00:54.789
Another interesting demo, there you go.

01:00:54.789 --> 01:01:03.869
I co-run the web site SVG.org, community
web site and I have a Google Analytics account.

01:01:03.869 --> 01:01:08.609
Google Analytics provides XML feeds
of the contents for statistics.

01:01:08.610 --> 01:01:11.519
And I'm just loading them up in this little piece of SVG.

01:01:11.519 --> 01:01:14.360
So this is a standard SVG document, no HTML in this one.

01:01:14.360 --> 01:01:16.370
So you can see its scales.

01:01:16.369 --> 01:01:19.630
This is all created from AJAX calls, XML http requests.

01:01:19.630 --> 01:01:23.010
So I make it a little bit wide.

01:01:23.010 --> 01:01:29.760
You can see that the little points give
me, I can get the data for given dates.

01:01:29.760 --> 01:01:32.970
Every thing is generically done on the fly.

01:01:32.969 --> 01:01:39.219
I can change the month, go back in time,
animate it, all using SVG scripting.

01:01:39.219 --> 01:01:45.069
And, of course, it wouldn't be a demo at
WWDC if you couldn't run it in slow mo.

01:01:45.070 --> 01:01:46.230
So there you go, so.

01:01:46.230 --> 01:01:46.289
( Applause )

01:01:46.289 --> 01:01:51.809
For example, the text up there is rotated
and opacity is applied so it transforms,

01:01:51.809 --> 01:01:54.179
the points move to the new directions, etcetera.

01:01:54.179 --> 01:01:56.949
So this is actually pretty simple and pretty effective

01:01:56.949 --> 01:02:03.139
and whatever the scaling is everything will be
done regardless of the resolution or anything.

01:02:03.139 --> 01:02:05.879
So I really like that stuff.

01:02:05.880 --> 01:02:12.360
So, for example, launch animation and resize
everything, it will all be done automatically.

01:02:12.360 --> 01:02:15.360
You don't have to worry about taking
care of rescaling anything.

01:02:15.360 --> 01:02:21.769
And finally, another interesting demonstration that I
wanted to make is when you really pull together HTML, CSS,

01:02:21.769 --> 01:02:27.519
SVG all in one big document and to create
some pretty compelling user interfaces so.

01:02:27.519 --> 01:02:30.329
This is all, of course, running in Safari 3.

01:02:30.329 --> 01:02:31.980
So this is a blank Canvas.

01:02:31.980 --> 01:02:39.949
I'm loading my Delicious Library XML database
on the fly perform X path queries, search it.

01:02:39.949 --> 01:02:43.710
So in this case I'll be looking for,
I can look for different things.

01:02:43.710 --> 01:02:47.720
In this case I'll be looking for artist
name that may contain the string WI.

01:02:47.719 --> 01:02:50.659
Can see a list of objects coming up.

01:02:50.659 --> 01:02:51.940
I can have.

01:02:51.940 --> 01:02:59.269
So all of this here is SVG objects within divs that are
directly laid out using CSS contracts of inline blocks.

01:02:59.269 --> 01:03:04.480
Here this is HTML text but the background is an
SVG piece of graphic that scale automatically.

01:03:04.480 --> 01:03:09.530
I have a little drop shadow applied
directly to my SVG rectangle

01:03:09.530 --> 01:03:12.660
so that it doesn't clip too harshly for the graphics.

01:03:12.659 --> 01:03:17.929
And I can, of course, redimension
all the graphics on the screen.

01:03:17.929 --> 01:03:21.129
I did my little custom scroll bars in SVG.

01:03:21.130 --> 01:03:22.570
I can go up and down.

01:03:22.570 --> 01:03:27.960
I just put in some useless effects when you click
on stuff so you can see little animations and,

01:03:27.960 --> 01:03:30.990
of course, you can use slow motion, resize objects.

01:03:30.989 --> 01:03:39.489
Well, it's a bit buggy but, animations
are performed while I redraw and resize

01:03:39.489 --> 01:03:45.689
So I think it's really pretty neat and really opens
up a new set of avenues you can take on using WebKit.

01:03:45.690 --> 01:03:47.659
And, of course, this is not limited to web content.

01:03:47.659 --> 01:03:54.029
WebKit is part of your tool kit as Mac OS X developer
and so this type of interface is going to be directly hosted

01:03:54.030 --> 01:04:00.190
in a Cocoa app, integrated with JavaScript, hook ups,
objective C callbacks, jar scripts and vice versa,

01:04:00.190 --> 01:04:07.119
and I think you have a whole brand new
world of possibilities for your application.

01:04:07.119 --> 01:04:09.569
And that pretty much wraps it up.

01:04:09.570 --> 01:04:13.660
And we'll hand the mike over to George, who
I'd like to thank for hosting this track.

01:04:13.659 --> 01:04:17.219
And before George comes up I would like
also to thank the Safari and WebKit teams

01:04:17.219 --> 01:04:21.279
for implementing all these cool
graphics features and giving developers

01:04:21.280 --> 01:04:26.610
and web authors alike new very
great creative avenues to explore.

01:04:26.610 --> 01:04:27.390
Thanks.

01:04:27.389 --> 01:04:31.929
( Applause )

01:04:31.929 --> 01:04:33.049
>> Awesome.

01:04:33.050 --> 01:04:33.650
Thanks every one.

01:04:33.650 --> 01:04:37.769
And just to summarize detail demonstrations
of the stuff that you just saw,

01:04:37.769 --> 01:04:41.449
Antoine will be hosting this code on his website.

01:04:41.449 --> 01:04:47.230
So by the time all of this information gets posted to
the WWDCADC site we'll have links and you'll be able

01:04:47.230 --> 01:04:51.219
to directly download the sample
code of the demos that you just saw.

01:04:51.219 --> 01:04:53.799
So I want to wrap up with one little note.

01:04:53.800 --> 01:05:00.060
And we're adding this basically one more thing
slides to all the content and media sessions.

01:05:00.059 --> 01:05:03.599
We want to remind everyone what we're
talking about is building AJAX applications.

01:05:03.599 --> 01:05:06.480
And when you're building a desktop
AJAX application, you know,

01:05:06.480 --> 01:05:10.260
that application is going to be able to run on the iPhone.

01:05:10.260 --> 01:05:18.320
With that aspect we want to reiterate what was discussed
in yesterday's session about good design practices.

01:05:18.320 --> 01:05:23.340
We'll be having a rebroadcast of
the iPhone developing for web sites

01:05:23.340 --> 01:05:27.870
for iPhone session tomorrow in North Beach at 3:30.

01:05:27.869 --> 01:05:33.969
So for those of you that were not there or those of you that
were there and would like to take more notes on what you saw

01:05:33.969 --> 01:05:38.809
and what you heard, please, we welcome
you to revisit and rewatch that session.

01:05:38.809 --> 01:05:40.750
So coming to good design practices.

01:05:40.750 --> 01:05:43.369
Essentially column layout.

01:05:43.369 --> 01:05:48.299
When you're building out your design think grid
system, think Swiss grid system and design things

01:05:48.300 --> 01:05:53.900
so that it makes the touch sensitivity on the
device and the multi-touch capabilities, I guess,

01:05:53.900 --> 01:05:57.780
the functionality work better with
the content that you're laying out.

01:05:57.780 --> 01:05:58.780
Size matters.

01:05:58.780 --> 01:06:01.080
You're dealing with edge and you're dealing with wi-fi.

01:06:01.079 --> 01:06:05.679
So when you're building out your content and you're taking
that all into consideration, please keep that in mind

01:06:05.679 --> 01:06:12.069
with the types of imagery or the types of video
that you might be using within your, your contents.

01:06:12.070 --> 01:06:18.039
And also the constructs of the resolution independence
graphics that you might be laying down with CSS 3.

01:06:18.039 --> 01:06:21.869
Media queries, CSS 3 is extremely important.

01:06:21.869 --> 01:06:27.319
This will be able to do the dynamic resizing and
dynamic layout of your web site content based

01:06:27.320 --> 01:06:31.220
on your landscape or portrait views on the actual iPhone.

01:06:31.219 --> 01:06:33.559
And then lastly, optimizing for iPhone.

01:06:33.559 --> 01:06:37.269
The key things you want to remember and
consider when building up this content.

01:06:37.269 --> 01:06:41.369
Remember the view port, the height and
width of landscape and portrait modes

01:06:41.369 --> 01:06:44.199
when you actually put that into your CSS queries.

01:06:44.199 --> 01:06:45.769
Remember the only tag.

01:06:45.769 --> 01:06:52.769
Using the only tag will basically allow non iPhone or,
you know, mobile aware browsers to ignore that context

01:06:52.769 --> 01:06:54.900
of the actual view port that you're assigning.

01:06:54.900 --> 01:07:00.000
Double tap, when you're dealing with your content remember
the different types of DOM events that we had mentioned

01:07:00.000 --> 01:07:06.710
in the session, remember that when you break up you
contents in a grid based layout it makes it easier to deal

01:07:06.710 --> 01:07:09.809
and navigate in and out of that content and construct.

01:07:09.809 --> 01:07:11.940
And then lastly, text size adjustments.

01:07:11.940 --> 01:07:17.119
The device will basically take advantage and deal with a
lot of the logic when you're dealing with your content but,

01:07:17.119 --> 01:07:21.369
again, remember when you build up your
system in a column based sort of schematic

01:07:21.369 --> 01:07:27.219
or your grid based layout remember the type and
the flow of the content so you're not using a div

01:07:27.219 --> 01:07:31.649
and having it completely fill the width of the
page, break it down into, again, column view.

01:07:31.650 --> 01:07:34.920
And then lastly, the events, you know,
dealing with the JavaScript events.

01:07:34.920 --> 01:07:36.780
We'll cover that again in the session tomorrow.

01:07:36.780 --> 01:07:40.150
It is a rebroadcast but there are a
select amount of events that are supported

01:07:40.150 --> 01:07:43.250
on the actual device and get up to speed on that.

01:07:43.250 --> 01:07:44.679
And then lastly, your media.

01:07:44.679 --> 01:07:50.339
Again, edge versus wi-fi, take into consideration
how you're going to actually encode that media,

01:07:50.340 --> 01:07:53.910
the bit rate you're going to be dealing with it and
also your ref movies that you're going to be creating

01:07:53.909 --> 01:07:59.769
when you're dealing with switching out of HTML context
into H.264 context when you're dealing with audio and video.

01:07:59.769 --> 01:08:07.099
For more information, again, go the session tomorrow at
3:30 in North Beach, the internet wwdr contact

01:08:07.099 --> 01:08:09.279
for dealing with iPhone issues right now is Mark Malone.

01:08:09.280 --> 01:08:16.670
We've got a lot of helpful URL's here dealing with
both the user agent detection, dealing with the W3C

01:08:16.670 --> 01:08:20.640
and WHATWG group specifications
around sort of future iterations

01:08:20.640 --> 01:08:24.660
on what the browser will be supporting
as well as CSS 3 media queries.

01:08:24.659 --> 01:08:29.779
And then, oh, right there, that's
actually, is that the URL for your sample?

01:08:29.779 --> 01:08:34.869
Yes. So that URL there you'll be able to download
Antoine and Dean's sample application code.

01:08:34.869 --> 01:08:40.550
Again, this'll be posted to the ADC website for those of
you, quick couple seconds if you want to copy that down.

01:08:40.550 --> 01:08:41.810
>> (inaudible)

01:08:41.810 --> 01:08:45.380
>> It will be posted shortly.

01:08:45.380 --> 01:08:46.480
Go there and look at a blank page.

01:08:46.479 --> 01:08:52.799
And now when you're dealing with media as it relates to
the iPhone Allan Schaffer is your WWDR contact.

01:08:52.800 --> 01:08:56.730
We've got some tutorials and we have a ref movie maker tool

01:08:56.729 --> 01:09:00.049
that you can download in preparation
for your actual content.

01:09:00.050 --> 01:09:05.970
Remember that the type of media that the
device supports is H.264 baseline profile.
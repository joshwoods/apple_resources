WEBVTT

00:00:10.390 --> 00:00:13.019
>> Good afternoon.

00:00:13.019 --> 00:00:15.399
Welcome to the Resolution Independence session.

00:00:15.400 --> 00:00:19.570
My name is Guy Fullerton, and I'm going to show
you the basics for what you need to know

00:00:19.570 --> 00:00:22.480
to make your application resolution independent.

00:00:22.480 --> 00:00:26.320
But before I go into that, let's
talk a little bit about why.

00:00:26.320 --> 00:00:31.899
Lots of technology industries keep giving
you more and bigger for your money,

00:00:31.899 --> 00:00:34.890
and display hardware is no different, right?

00:00:34.890 --> 00:00:38.549
In mass storage we went from megabytes
to gigabytes to terabytes.

00:00:38.549 --> 00:00:42.070
In optical media we go from CDs to DVD to Blu-ray.

00:00:42.070 --> 00:00:46.719
And LCD displays keep getting denser and denser and denser.

00:00:46.719 --> 00:00:52.589
And if we look at what this does, imagine a
23-inch display at a hundred DPI,

00:00:52.590 --> 00:00:57.070
well, you can also imagine two hundred
DPI, or maybe three hundred DPI.

00:00:57.070 --> 00:01:03.299
So really, you can think of high-resolution
displays as kind of HD for the computer desktop.

00:01:03.299 --> 00:01:06.179
Well, what are we going to do with
all of that increased density?

00:01:06.180 --> 00:01:10.390
So again, here's a hundred DPI display
on a 23-inch display.

00:01:10.390 --> 00:01:15.840
If we switch that to a 200 DPI display,
wow, that's a lot of screen real estate, right?

00:01:15.840 --> 00:01:20.049
And a lot of people might be drooling over that if
you're used to doing big image processing and so forth.

00:01:20.049 --> 00:01:24.280
But if you were actually to sit in front of this
23-inch display at 200 DPI,

00:01:24.280 --> 00:01:26.849
you'd probably find the text really hard to read.

00:01:26.849 --> 00:01:30.319
So we've got to do something better
with that increased display density.

00:01:30.319 --> 00:01:34.229
So to show you what I mean, let's zoom in
on the top left corner of that display.

00:01:34.230 --> 00:01:39.109
Okay, so this is Mac OS, well, this is
actually a Tiger screenshot as you know it.

00:01:39.109 --> 00:01:42.959
And if you were to zoom in that close on your own
display, you'd see that it's pretty pixilated.

00:01:42.959 --> 00:01:47.339
Now normally when you're at a regular viewing distance it
looks pretty good, but when you start to scrutinize it,

00:01:47.340 --> 00:01:50.900
you can see some pixilation on the
text and the graphics and so forth.

00:01:50.900 --> 00:01:57.100
So if we instead use all of that increased display
density to increase the sharpness of the text,

00:01:57.099 --> 00:01:59.579
you can get a much better looking interface.

00:01:59.579 --> 00:02:05.989
So again, this is normal resolution,
and this is what high resolution can be.

00:02:05.989 --> 00:02:09.769
So let's talk about a time table.

00:02:09.770 --> 00:02:15.330
In the past we've told you that we expect your applications
to be resolution independent in 2008,

00:02:15.330 --> 00:02:20.710
and you can see we're already moving toward that direction
with our most recent MacBook Pro model that's out.

00:02:20.710 --> 00:02:25.099
It's a 17-inch model that now has an
option for a 133 DPI display.

00:02:25.099 --> 00:02:30.129
Now a 133DPI
is about the maximum display density

00:02:30.129 --> 00:02:33.319
that most people can comfortably
read, and for me it's even a pain.

00:02:33.319 --> 00:02:38.780
So we really need to get software support out there so
that we can go to even denser displays in the future.

00:02:39.810 --> 00:02:44.490
And display density isn't even the only reason
why you might want to go resolution independent.

00:02:44.490 --> 00:02:47.969
Any time you might want to blow up
the interface to make it look crisper

00:02:47.969 --> 00:02:52.030
and sharper is a perfectly valid reason,
even if it's on normal density hardware.

00:02:52.030 --> 00:02:56.770
Say for example you have a 39-inch cinema display,
and you want to give a demo to a bunch of people

00:02:56.770 --> 00:02:58.659
in a room, and they're fifteen to twenty feet away.

00:02:58.659 --> 00:03:04.979
Well, you could use resolution independence to zoom
up your screen, and not use the sort of built-in zoom

00:03:04.979 --> 00:03:10.509
that we already have available on the various OS releases,
but zoom it up and make it look great at the same time.

00:03:10.509 --> 00:03:15.389
Similarly you can think of some possible accessibility
solutions for low-vision users that take advantage

00:03:15.389 --> 00:03:17.659
of resolution independence as well on normal displays.

00:03:17.659 --> 00:03:24.340
So now I want to go into some terminology
that'll help understanding how to adopt.

00:03:24.340 --> 00:03:27.409
The first is the notion of points versus pixels.

00:03:27.409 --> 00:03:33.139
In traditional Mac OS development, most developers
think of points and pixels as the same thing.

00:03:33.139 --> 00:03:38.009
To explain what I mean, let's think about
both a text example and a graphical example.

00:03:38.009 --> 00:03:43.250
When you request a 13 point font,
generally that draws about 13 pixels tall.

00:03:43.250 --> 00:03:46.520
If you have an image that's 100 pixels by 100 pixels,

00:03:46.520 --> 00:03:49.820
generally you plot that in a rectangle that's
100 points by 100 points.

00:03:49.819 --> 00:03:52.269
And that's just the mindset we've had for a long time.

00:03:52.270 --> 00:03:55.730
We need to break that mindset to be resolution independent.

00:03:55.729 --> 00:04:00.109
So this now means that points and pixels
may not map on a one-to-one basis.

00:04:00.110 --> 00:04:03.140
Now the good news is that even though
you need to change your mindset,

00:04:03.139 --> 00:04:06.079
you generally don't need to change
your coding practices, right?

00:04:06.080 --> 00:04:09.140
All of your .nibs are already working in terms of points.

00:04:09.139 --> 00:04:12.799
Just think about when you're laying them out that you're
laying them out in terms of points and not pixels,

00:04:12.800 --> 00:04:19.639
and similarly when you have code that positions or
resizes views, think of that as resizing them in points.

00:04:19.639 --> 00:04:21.139
Now it's not all free.

00:04:21.139 --> 00:04:25.079
Sometimes you actually do need to think in
pixels to get an optimum user experience,

00:04:25.079 --> 00:04:27.620
and I'll talk about some of those
details a little bit later on.

00:04:27.620 --> 00:04:29.209
But this isn't really anything new.

00:04:29.209 --> 00:04:33.469
A lot of applications that print already do
the same kind of thing when they print, right?

00:04:33.470 --> 00:04:38.430
They might look at the density of the printing
device, and choose a different hairline thickness

00:04:38.430 --> 00:04:40.040
for a particular line or something like that.

00:04:40.040 --> 00:04:41.900
So a lot of your code may already do this kind of thing.

00:04:41.899 --> 00:04:47.319
So let me show you a graphical example of what I mean.

00:04:47.319 --> 00:04:52.639
At a normal resolution, when you create a push
button, you ask for it to be 20 points tall,

00:04:52.639 --> 00:04:56.849
and at a normal resolution it ends
up being 20 pixels tall.

00:04:56.850 --> 00:04:59.280
Now let's go to a 3 times resolution.

00:04:59.279 --> 00:05:02.199
Okay, here we have a 3 times resolution
push button that looks a lot crisper.

00:05:02.199 --> 00:05:04.550
We got crisper text, crisper graphics.

00:05:04.550 --> 00:05:09.199
You still request that as a 20 point tall
push button, and it just so happens that it takes

00:05:09.199 --> 00:05:11.740
up 60 pixels of vertical screen real estate.

00:05:11.740 --> 00:05:18.410
So the next piece of terminology
is the concept of a scaling mode.

00:05:18.410 --> 00:05:23.770
A scaling mode is a mechanism for you to mark
a particular window as resolution independent.

00:05:23.769 --> 00:05:26.870
And the best scaling mode is called framework-scaled mode.

00:05:26.870 --> 00:05:29.709
This is the way your window can look its best.

00:05:29.709 --> 00:05:33.049
It's going to give you great looking
text, and great looking graphics,

00:05:33.050 --> 00:05:35.740
all the system controls are going to look fantastic in there.

00:05:35.740 --> 00:05:40.860
All of your custom art, however, needs to be
revved to look fantastic in framework-scaled mode.

00:05:40.860 --> 00:05:45.370
Now don't get me wrong, your custom art is still
going to look okay, it's still going to get scaled

00:05:45.370 --> 00:05:49.720
up to match the system controls in terms
of size, but it won't look as good.

00:05:49.720 --> 00:05:53.660
It's going to be interpolated or a little fuzzy
or grainy, and it may stand out a little bit.

00:05:53.660 --> 00:06:01.189
Now the way we make this work is we see your request for
a window, window size, and we interpret that in points.

00:06:01.189 --> 00:06:07.389
So for example, if you request a 200 point tall window
at a 3 times scale factor,

00:06:07.389 --> 00:06:10.990
a 3 times resolution, that window's
actually going to be 200 pixels tall,

00:06:10.990 --> 00:06:13.170
and the window backing buffer is
going to be 200 pixels tall.

00:06:13.170 --> 00:06:18.240
So since we've got more pixels to render your text
and graphics in there, we can make them crisper,

00:06:18.240 --> 00:06:21.790
and then when it's blit to the
screen, it ends up looking great.

00:06:21.790 --> 00:06:28.030
The next scaling mode is called magnified
mode, and this is for Carbon apps.

00:06:28.029 --> 00:06:33.679
Unmodified Carbon windows, when running in
resolution independence mode, get magnified windows.

00:06:33.680 --> 00:06:40.569
These magnified windows match in terms of size to framework-
scaled windows, but they don't match the crispness.

00:06:40.569 --> 00:06:44.879
The way magnified mode windows work is your
backing buffer is the same size it's always been,

00:06:44.879 --> 00:06:46.680
even at regular resolution.

00:06:46.680 --> 00:06:50.590
And the window server scales up those
contents, so it's going to be interpolated,

00:06:50.589 --> 00:06:53.459
excuse me, interpolated or a little bit grainy.

00:06:53.459 --> 00:06:59.319
Now you can actually get framework-scaled
windows in Carbon, in Carbon applications,

00:06:59.319 --> 00:07:02.769
but I'm going to talk about that in a little bit.

00:07:02.769 --> 00:07:06.620
The third mode isn't really a resolution
independence mode, but I like to include it here.

00:07:06.620 --> 00:07:11.709
It's called small mode, and the reason I have it crossed
out here is because A) you don't want to be in this boat,

00:07:11.709 --> 00:07:13.769
and B) we don't really support it on Leopard.

00:07:13.769 --> 00:07:20.219
A small mode is a fallback compatibility mode for
applications that don't work under resolution independence.

00:07:20.220 --> 00:07:27.090
As we test various applications, we've found that some of
them make very bad assumptions about points equaling pixels,

00:07:27.089 --> 00:07:31.449
or they do some of the bad things that we'll talk about
later in the session, that prevents that application

00:07:31.449 --> 00:07:34.349
from looking at all decent in a resolution independent mode.

00:07:34.350 --> 00:07:37.970
And therefore that app, if it got to
customers, would need to run in small mode.

00:07:37.970 --> 00:07:40.620
It's essentially a completely unscaled window.

00:07:40.620 --> 00:07:47.350
It's 1 point per pixel, but it's going to look very
tiny compared to resolution independent windows.

00:07:47.350 --> 00:07:54.050
So when I say this isn't supported in Leopard, what I
really mean is that we have no way for the user to choose

00:07:54.050 --> 00:07:59.740
to use small mode for your application, and the OS is not
automatically forcing bad applications into small mode.

00:07:59.740 --> 00:08:03.879
When resolution independence actually becomes a user
feature, we're very likely to put a switch in place.

00:08:03.879 --> 00:08:08.550
Think of the Finder Info window switches where you
can run something in Rosetta or a 32-bit mode.

00:08:08.550 --> 00:08:12.400
We'll probably allow the user to pick your
application and say I want to run this in small mode

00:08:12.399 --> 00:08:16.139
because it's got some bug when it's
running in one of the other modes.

00:08:16.139 --> 00:08:22.639
So the next thing I'd like to talk
about is the scale factor.

00:08:22.639 --> 00:08:27.129
Simply, the scale factor is the ratio of pixels to points.

00:08:27.129 --> 00:08:30.469
So at normal resolution, let's say
we've got a 3 point tall window.

00:08:30.470 --> 00:08:32.790
Well, that window's going to be 3 pixels tall.

00:08:32.789 --> 00:08:37.339
But if we use a 3 times scale factor, that
window will end up being 9 pixels tall.

00:08:37.340 --> 00:08:48.430
To set the scale factor, and effectively turn on resolution
independence, we put a new feature into Quartz Debug,

00:08:48.429 --> 00:08:52.159
and I could talk to you about it, but it's
probably easier to see what's going on with a demo.

00:08:52.159 --> 00:08:56.350
So now I'd like to bring up David McCloud to run
us through Quartz Debug and a few other things.

00:08:56.350 --> 00:08:57.330
( Applause )

00:08:57.330 --> 00:08:58.570
>> Thanks, Guy.

00:09:03.929 --> 00:09:09.849
So like Guy said, I'm just going to go
through a few of these topics in action.

00:09:09.850 --> 00:09:11.720
Let's get right into it.

00:09:11.720 --> 00:09:18.170
The first thing I want to show you is how to set the
system scale factor to turn on resolution independence.

00:09:18.169 --> 00:09:24.329
So you go to your Leopard build, into your
Developer directory, in the Applications directory,

00:09:24.330 --> 00:09:29.009
and there's an alias to it in Graphics Tools,

00:09:29.009 --> 00:09:32.840
they moved it to Performance Tools
recently, but you just launch Quartz Debug.

00:09:32.840 --> 00:09:44.350
And up in the Tools menu there's a Show User
Interface Resolution window that you can bring up.

00:09:44.350 --> 00:09:48.540
Well, let's just turn on resolution
independence by setting a scale factor to 2.0.

00:09:48.539 --> 00:09:52.980
You saw the doc jump a little bit there.

00:09:52.980 --> 00:09:58.950
Generally, applications before they'll become resolution
independent and start using the scale factor have to be restarted.

00:09:58.950 --> 00:10:03.620
The doc is a kind of a special exception
cause it's running all the time like that.

00:10:03.620 --> 00:10:09.850
You'll notice in the background the Finder is unaffected,
it stayed at the scale factor it was running at.

00:10:09.850 --> 00:10:14.610
So to get this changed in the Finder,
I'd have to relaunch it.

00:10:14.610 --> 00:10:17.519
So I'm just going to launch TextEdit here.

00:10:17.519 --> 00:10:22.590
So you see TextEdit has come up
and the window is much larger.

00:10:22.590 --> 00:10:25.700
There's actually, like Guy said, a bigger backing buffer,

00:10:25.700 --> 00:10:30.680
there's a lot more pixels sitting there
waiting to be filled up by TextEdit.

00:10:30.679 --> 00:10:33.489
You'll notice the menu bar is bigger,
it's in its own window.

00:10:33.490 --> 00:10:40.399
It's in its own window, and it's also been
scaled up, the big, bigger backing buffer.

00:10:40.399 --> 00:10:47.949
And you'll notice the controls are very
sharp, the text on the controls very sharp.

00:10:47.950 --> 00:10:51.030
Just zoom in on one here, zoop.

00:10:51.029 --> 00:10:56.879
So you can see it's using as many pixels as it
can, it's packing them into that backing buffer.

00:10:56.879 --> 00:11:04.200
And let's just open a document quickly, you
can see text, text renders very crisply.

00:11:04.200 --> 00:11:13.050
So the thing about TextEdit we
all know, TextEdit is a Cocoa app.

00:11:13.049 --> 00:11:16.819
Cocoa apps run in framework-scaled mode by default.

00:11:16.820 --> 00:11:22.790
So most of the work you have to do is done for free.

00:11:22.789 --> 00:11:24.429
Carbon, like Guy said, is a bit more work.

00:11:24.429 --> 00:11:26.909
So let's run a Carbon app.

00:11:26.909 --> 00:11:29.269
I downloaded the BBEdit demo here.

00:11:29.269 --> 00:11:34.899
So I'm not picking on BBEdit.

00:11:34.899 --> 00:11:38.409
I love BBEdit, I use it every day,
I think it's a great text editor.

00:11:38.409 --> 00:11:43.750
But it's a good example of a Carbon app
that's running in magnified scaling mode.

00:11:43.750 --> 00:11:50.309
And what that means is the backing buffer is just the size
it would be at 1.0, and the bits are blown up by CG

00:11:50.309 --> 00:11:53.649
at the last moment to fill up the available area.

00:11:53.649 --> 00:11:59.949
You can see that it's not as crisp, the controls
are a little blurry, text will be a little blurry.

00:11:59.950 --> 00:12:04.020
Let's just open the same text as we had before.

00:12:04.019 --> 00:12:10.629
I'll slide it over so we compare TextEdit and
BBEdit at the same time here.

00:12:10.629 --> 00:12:11.250
Let me zoom in.

00:12:11.250 --> 00:12:18.379
And you can see, things are a lot more
fuzzy in BBEdit running in magnified mode

00:12:18.379 --> 00:12:29.470
than TextEdit running in framework-scaled mode.

00:12:29.470 --> 00:12:33.210
Also like Guy said, you can do
magnified mode in Carbon apps.

00:12:33.210 --> 00:12:36.570
There's a little bit more work, he's going to get into that.

00:12:36.570 --> 00:12:38.000
And I'd like to let him do that.

00:12:38.000 --> 00:12:39.399
Guy?

00:12:39.399 --> 00:12:40.909
>> Thank you, David.

00:12:40.909 --> 00:12:47.240
Okay, back to the slides, please.

00:12:47.240 --> 00:12:47.409
( Applause )

00:12:47.409 --> 00:12:50.919
>> Okay, so let's talk about how Leopard
supports resolution independence.

00:12:50.919 --> 00:12:54.199
In Leopard resolution independence
is still a developer feature.

00:12:54.200 --> 00:12:58.970
We're in the process of revving all the system
controls to support high-resolution artwork.

00:12:58.970 --> 00:13:02.870
The text system supports high resolution
drawing, and we've expanded a number

00:13:02.870 --> 00:13:05.639
of API sets to be more resolution independent.

00:13:05.639 --> 00:13:09.659
Cocoa, in fact, has even added some system
controls in the last couple of releases,

00:13:09.659 --> 00:13:12.879
and, of course, all those new things
are resolution independent.

00:13:12.879 --> 00:13:19.269
Icon Services has been revised to use yet another larger
icon version, so that we can display great looking icons

00:13:19.269 --> 00:13:22.669
in a resolution independent Finder and other places.

00:13:22.669 --> 00:13:27.049
And, of course, even though we're changing all the
system underneath, we need a way to test that.

00:13:27.049 --> 00:13:32.939
So we picked a few of the applications that ship on Leopard,
and we're making those resolution independent savvy as well.

00:13:32.940 --> 00:13:38.590
So if you fire up Quartz Debug, change the scale factor, log
out and log in, you'll see a resolution independent Finder.

00:13:38.590 --> 00:13:42.320
Now interestingly, that will reveal some of
the resolution independence bugs in Leopard.

00:13:42.320 --> 00:13:47.010
We're not done, we expect you to see a lot of
bugs, so please write those up when you see them.

00:13:47.009 --> 00:13:51.960
We also added a bunch of new standard
art, which serves a variety of purposes,

00:13:51.960 --> 00:13:55.509
and one of those main driving reasons
was for resolution independence.

00:13:55.509 --> 00:13:57.759
And we did that via NSImage.

00:13:57.759 --> 00:14:02.409
NSImage has a named image mechanism which traditionally
looks in your bundle for particular named artwork.

00:14:02.409 --> 00:14:07.299
In some cases it actually looks for system-
supplied artwork, so we expanded that batch

00:14:07.299 --> 00:14:10.469
of system-supplied art with a wide variety of things.

00:14:10.470 --> 00:14:16.960
So if you need the standard info icon, or the color panel
icon, or so forth, you can ask for that from NSImage.

00:14:16.960 --> 00:14:19.160
Now there's one important thing to note here.

00:14:19.159 --> 00:14:22.799
Let's say you want the network icon, that's fantastic.

00:14:22.799 --> 00:14:26.939
If you want the network icon, you
can ask for it and draw it.

00:14:26.940 --> 00:14:29.920
But let's say you need a big gray globe for some reason.

00:14:29.919 --> 00:14:33.649
Well I don't want you to ask for the network
icon just because it's a big gray globe.

00:14:33.649 --> 00:14:37.289
I only want you to ask for the network icon
cause you're going to display the network icon.

00:14:37.289 --> 00:14:42.919
So, please, do not use the standard art for what
it looks like, use it for what it's named.

00:14:42.919 --> 00:14:48.569
And we're going to expand the documentation on that, telling
you exactly what purposes the standard art is used for.

00:14:48.570 --> 00:14:52.990
And, of course, the reason for that is it allows
us to change the standard art in system versions

00:14:52.990 --> 00:14:54.990
without breaking your application's usage.

00:14:54.990 --> 00:15:02.519
Some of the standard art we're putting in
place are what we call template images.

00:15:02.519 --> 00:15:07.960
This is essentially black-and-white artwork that's intended
to be colorized, or sometimes engraved or chiseled,

00:15:07.960 --> 00:15:11.580
or various other effects added to it
for display on certain system controls.

00:15:11.580 --> 00:15:13.700
So there's a bunch of those templatized images as well.

00:15:13.700 --> 00:15:22.670
Now as we've mentioned a couple times, Cocoa
automatically gets framework-scaled windows,

00:15:22.669 --> 00:15:26.539
which means adopting resolution
independence in Cocoa is pretty darn easy.

00:15:26.539 --> 00:15:30.759
Most of the Cocoa controls automatically scale
up with great looking text and graphics,

00:15:30.759 --> 00:15:35.350
but your application's own content
may need to be revised to look good.

00:15:35.350 --> 00:15:39.800
And for the most part, your Cocoa app will
just run, and it'll just look great, right?

00:15:39.799 --> 00:15:44.079
So I highly recommend flipping on a higher scale factor,
running your app, and seeing what needs to change.

00:15:44.080 --> 00:15:45.340
It looks pretty good.

00:15:45.340 --> 00:15:49.800
The one major exception in terms of
functionality is NSQuickdrawView.

00:15:49.799 --> 00:15:53.769
QuickDraw is implicitly tied to
the notion that points equal pixels.

00:15:53.769 --> 00:15:56.159
And in resolution independence mode that's just not true.

00:15:56.159 --> 00:16:00.689
So QuickDraw just doesn't work correctly in resolution
independence, and we have no plans to change that.

00:16:00.690 --> 00:16:06.570
So if you're using NSQuickdrawView, you're going to need to
rethink that implementation strategy in your application.

00:16:06.570 --> 00:16:09.930
For Carbon the story's a little bit longer.

00:16:09.929 --> 00:16:12.870
Carbon app windows come up in magnified mode.

00:16:12.870 --> 00:16:19.289
Carbon apps can adopt framework-scaled mode, you just
have to jump through a few more hoops to do that.

00:16:19.289 --> 00:16:20.629
Okay, there we go.

00:16:20.629 --> 00:16:23.950
The first thing to do is eliminate all
QuickDraw drawing, and what that allows you

00:16:23.950 --> 00:16:26.970
to do is switch on HIView compositing mode.

00:16:26.970 --> 00:16:32.190
Once you've done that, now it's safe to turn on
the framework-scaled attribute for your window,

00:16:32.190 --> 00:16:35.760
and that will bring up your Carbon
windows in framework-scaled mode.

00:16:35.759 --> 00:16:41.289
Once you've gotten through all those hurdles, the adoption
strategy is basically the same as a Cocoa application.

00:16:41.289 --> 00:16:49.019
We added a couple new APIs to Carbon
to support resolution independence.

00:16:49.019 --> 00:16:50.779
The main ones have to do with NSImages.

00:16:50.779 --> 00:16:54.549
I'm only showing one of them here,
and that's HIViewDrawNSImage.

00:16:54.549 --> 00:16:59.349
So Carbon apps can use the named NSImages,
fetch your desired piece of artwork,

00:16:59.350 --> 00:17:03.070
and draw it in a particular HIView
coordinate space, and that works just fine.

00:17:03.070 --> 00:17:07.630
It's a great way for Carbon apps to get access to the
standard technology, it allows some Carbon developers

00:17:07.630 --> 00:17:10.180
to start getting their feet wet with Cocoa, and so on.

00:17:10.180 --> 00:17:15.990
If you do need finer grain control over images on the
disk, you can always go down to a lower level service

00:17:15.990 --> 00:17:21.250
like ImageIO, that'll allow you to look at various
attributes of the image in the file and so forth,

00:17:21.250 --> 00:17:26.259
and you can make different decisions if you need to.

00:17:26.259 --> 00:17:29.299
Dashboard has its own notion of framework-scaled mode.

00:17:29.299 --> 00:17:35.319
If you set a scale factor, log out, log in, and bring up
Dashboard, you'll see that the widgets have scaled up.

00:17:35.319 --> 00:17:40.710
Now if a widget uses any system controls,
generally those are going to look pretty good.

00:17:40.710 --> 00:17:45.009
But if a widget uses custom art, which a lot
of widgets do, that custom art is scaled up,

00:17:45.009 --> 00:17:50.309
just like custom art in any other sort of app,
and can look grainy because it's interpolated.

00:17:50.309 --> 00:17:54.819
So if you went to rev your Dashboard widget to
support great looking art and resolution independence,

00:17:54.819 --> 00:18:01.779
you can take advantage of some CSS media query extensions
that -webkit added that allow you to query the scale factor,

00:18:01.779 --> 00:18:06.629
and make intelligent decisions about which
images to supply as part of your widget.

00:18:06.630 --> 00:18:08.780
And, of course, right now these are private extensions.

00:18:08.779 --> 00:18:13.339
You're welcome to use them, we're going to work with the
standards committee, when we can get them standardized,

00:18:13.339 --> 00:18:20.939
you'll see similar extensions, just
without the -webkit in front.

00:18:20.940 --> 00:18:26.620
So now let's take a little step-by-step look at how
an application can become resolution independent.

00:18:26.619 --> 00:18:31.149
The first thing you need to do is dig through your
applications bundle and find all your artwork.

00:18:31.150 --> 00:18:34.440
Once you've got a mess of artwork,
start asking yourself questions.

00:18:34.440 --> 00:18:38.529
Are you using that piece of art to do something
that the system already can do for you?

00:18:38.529 --> 00:18:42.849
If so, that's a great time to adopt a new standard control.

00:18:44.670 --> 00:18:48.789
Maybe you have custom art in your
bundle to do the Info window button.

00:18:48.789 --> 00:18:51.529
Well, now we offer an Info window
button, so if you're running on Leopard,

00:18:51.529 --> 00:18:54.309
you should use the standard art for that.

00:18:54.309 --> 00:18:59.429
Additionally, Icon Services already offers a ton
of different icons that you might be able to use.

00:18:59.430 --> 00:19:02.350
Not everybody knows what's available,
I strongly recommend you take a look

00:19:02.349 --> 00:19:05.159
at the icons.h header to see what's available there.

00:19:05.160 --> 00:19:09.940
And the HITheme APIs are a great
way to draw the Aqua interface

00:19:09.940 --> 00:19:12.440
when you're not in a control, or not in a standard view.

00:19:12.440 --> 00:19:21.259
Now as we looked at our own applications, sometimes we
found a piece of art that was just a simple rectangle fill,

00:19:21.259 --> 00:19:23.579
or maybe it was a frame or something like that.

00:19:23.579 --> 00:19:26.439
Well, it turns out that those are
really easy to draw procedurally,

00:19:26.440 --> 00:19:28.880
so we just switched to that procedural drawing.

00:19:28.880 --> 00:19:31.800
That allows you to scrape that
old artwork out of your bundle,

00:19:31.799 --> 00:19:35.450
and you don't have to have your users downloading
it, you don't have to maintain it and so forth.

00:19:35.450 --> 00:19:39.450
Simplifies your builds and so on.

00:19:39.450 --> 00:19:43.779
So once you've examined all your art,
toss out anything you don't need.

00:19:43.779 --> 00:19:47.279
Now, of course, if you need to run on older system
versions, you're going to need to leave that art in.

00:19:47.279 --> 00:19:52.389
But at least you get to ignore
it for your Leopard code paths.

00:19:52.390 --> 00:19:57.660
Anything that's left needs to be revised, or
at least examined for resolution independence.

00:19:59.589 --> 00:20:02.939
So when you start revising your custom
artwork, there's one main question.

00:20:02.940 --> 00:20:03.850
Do I go to bitmaps?

00:20:03.849 --> 00:20:04.659
Do I use vectors?

00:20:04.660 --> 00:20:06.019
What should I do here?

00:20:06.019 --> 00:20:08.200
Well, the answer is it depends.

00:20:08.200 --> 00:20:10.220
Both formats have advantages.

00:20:10.220 --> 00:20:13.329
Vectors are very small, both on disk and in memory.

00:20:13.329 --> 00:20:18.970
And the cool thing about vectors is they can
scale up to any size and still look pretty good.

00:20:20.069 --> 00:20:28.019
It also, because vectors are easily manipulated, it's
a little easier to write the code that deals with them.

00:20:28.019 --> 00:20:32.799
As you'll see from bitmaps, well, I'll talk
about some of the details a little bit later.

00:20:32.799 --> 00:20:35.680
Let's just jump right into bitmaps.

00:20:35.680 --> 00:20:38.549
Some UI designers love bitmaps.

00:20:38.549 --> 00:20:41.019
There's just no question, they're better for some things.

00:20:41.019 --> 00:20:42.599
UI designers can pixel tweak them.

00:20:42.599 --> 00:20:46.539
A lot of times vectors can't get them exactly
what they want, so they're going to demand bitmaps.

00:20:46.539 --> 00:20:50.139
Of course, bitmaps are the only way to
get something truly photorealistic.

00:20:50.140 --> 00:20:54.759
And sometimes vectors are not appropriate
for very small uses.

00:20:54.759 --> 00:20:57.019
The best example are file system icons.

00:20:57.019 --> 00:21:03.079
Our HI guidelines say that your smallest file system icons
for your documents are not supposed to be as detailed

00:21:03.079 --> 00:21:06.389
as the large icons, they're not
supposed to include all these details

00:21:06.390 --> 00:21:08.910
which when shrunk down would muddy the overall image.

00:21:08.910 --> 00:21:16.769
So these are times when you really do need to use bitmaps.

00:21:16.769 --> 00:21:23.319
So if you decide to use PDF, or another vector format
for some of your art, here's a couple of recommendations.

00:21:23.319 --> 00:21:27.000
We found that it's fantastic for doing monochrome art.

00:21:27.000 --> 00:21:33.980
The named template images that we're adding to NSImage,
most of those are, actually I believe all of those are PDF.

00:21:33.980 --> 00:21:37.339
We found it works fantastic for those kinds of situations.

00:21:37.339 --> 00:21:45.909
And for bitmap, as I mentioned before, Icon Services
icons can go all the way up to 512 by 512.

00:21:45.910 --> 00:21:52.269
Make sure you use lossless compression, and we
recommend that each piece of bitmap art is delivered

00:21:52.269 --> 00:22:00.539
in two resolutions, a normal resolution piece of
art, plus a 4 times the resolution piece of art.

00:22:00.539 --> 00:22:05.720
And we've also found that multi-image .tiff
files are a great way to deliver that art.

00:22:05.720 --> 00:22:09.720
It turns out that .tiff can support multiple images per file.

00:22:09.720 --> 00:22:13.829
So in a single file you can have a normal resolution,
a 4 times resolution, heck, you can have 4

00:22:13.829 --> 00:22:16.079
or 6 resolutions if you need to in there.

00:22:16.079 --> 00:22:18.109
Just be aware of the size concerns.

00:22:18.109 --> 00:22:23.629
If you have a multi-image .tiff that has a normal
resolution and a 4 times resolution piece of art in it,

00:22:23.630 --> 00:22:28.710
that's going to be about 17 times as big as
a single image .tiff at normal resolution, right?

00:22:28.710 --> 00:22:33.759
So if that size is going to be a problem for you, let's say
you have an app that needs to be downloaded as quickly

00:22:33.759 --> 00:22:37.680
as possible, maybe 4 times art is not the right format.

00:22:37.680 --> 00:22:42.910
Maybe it's right for you to do a normal resolution
and a 2 times resolution, and that's perfectly fine.

00:22:42.910 --> 00:22:49.840
NSImage and ImageIO completely support multi-image
.tiff files, so you're going to get full support there.

00:22:49.839 --> 00:22:56.169
If multi-image .tiff is not really the right solution for
you, you can always use .png or various other formats.

00:22:56.170 --> 00:23:00.680
If you use one of those other formats that
doesn't support multiple images per file,

00:23:00.680 --> 00:23:02.970
it's a little bit harder to write
the code to deal with those.

00:23:02.970 --> 00:23:06.559
You're going to have to determine some
naming convention for your own code,

00:23:06.559 --> 00:23:09.089
and figure out which image to load
based on the scale factor.

00:23:09.089 --> 00:23:17.439
And it's just a little bit more hassle that you can
let the system do for you if you use multi-image .tiff.

00:23:17.440 --> 00:23:21.070
So once you've generated a whole bunch
of revised art, it's time to adopt it.

00:23:21.069 --> 00:23:22.129
Some things are really easy.

00:23:22.130 --> 00:23:25.690
You can drop your new Icon Services
icons directly in your bundle.

00:23:25.690 --> 00:23:29.350
If you're not already using NSImage to
draw your other art, go ahead and use it,

00:23:29.349 --> 00:23:33.980
it fully supports .tiff, .png, PDF, and so forth.

00:23:33.980 --> 00:23:40.049
And again, if you need finer grain control than what
NSImage provides, feel free to use a lower level API.

00:23:40.049 --> 00:23:45.799
We added a few tools in Leopard to make your life easier.

00:23:45.799 --> 00:23:51.539
Preview now correctly displays all of the
individual images in a multi-image .tiff file.

00:23:51.539 --> 00:23:56.089
We've revved the Icon Composer application
that lets you build Icon Services icons.

00:23:56.089 --> 00:24:01.519
It now supports 512 by 512 artwork, and adds
a few other convenience features.

00:24:01.519 --> 00:24:06.869
And we have a command-line utility called tiffutil,
that allows you to take individual .tiff files

00:24:06.869 --> 00:24:10.569
and merge them together into a single multi-image .tiff file.

00:24:10.569 --> 00:24:16.730
And it has a -cathidpicheck argument that
you can pass to it that makes sure each of your,

00:24:16.730 --> 00:24:24.960
each of your individual .tiff files is
in a format appropriate for NSImage.

00:24:24.960 --> 00:24:28.620
Once you've adopted all that art, it's time to test.

00:24:28.619 --> 00:24:31.459
Of course 1.0 scale factor is normal resolution.

00:24:31.460 --> 00:24:34.200
You'll still want to test that
because you changed your code paths,

00:24:34.200 --> 00:24:36.789
but the real meat is when you switch to a higher resolution.

00:24:36.789 --> 00:24:41.829
So switch to 2 or 3, but make sure you
also test the nonintegral scale factors,

00:24:41.829 --> 00:24:44.309
particularly 1.25 and 1.5.

00:24:44.309 --> 00:24:50.579
These we think are the key scale factors that will
work well on a wide variety of future displays.

00:24:50.579 --> 00:24:55.099
And in fact testing at 1.25 and 1.5
is going to expose a lot more bugs

00:24:55.099 --> 00:24:56.679
than the integral scale factors.

00:24:56.680 --> 00:25:01.529
Some of the pitfalls I'll talk about later really
only happen at the nonintegral scale factors.

00:25:01.529 --> 00:25:05.089
Now Tiger also supported resolution
independence as a developer feature,

00:25:05.089 --> 00:25:07.149
but we've come a long, long way since then.

00:25:07.150 --> 00:25:09.060
So please test on Leopard.

00:25:09.059 --> 00:25:13.919
Leopard has all of our latest bug fixes for resolution
independence, it has more standard art and so forth.

00:25:13.920 --> 00:25:17.210
So you're kind of wasting your time if you're
testing resolution independence on Tiger,

00:25:17.210 --> 00:25:20.470
cause we're never planning on making
it a user feature on Tiger.

00:25:20.470 --> 00:25:22.610
And when you see bugs in your application, fix them.

00:25:22.609 --> 00:25:25.250
And if you see bugs in the system, please report them to us.

00:25:25.250 --> 00:25:31.539
We love to fix any of the bugs you can find.

00:25:31.539 --> 00:25:37.990
Now when you find bugs, generally the first step in
fixing them is using the scale factor in some fashion.

00:25:37.990 --> 00:25:41.140
Sometimes you'll do it implicitly,
sometimes you need to do that explicitly.

00:25:41.140 --> 00:25:43.880
So we have a couple different ways
of fetching the scale factor.

00:25:43.880 --> 00:25:47.460
The preferred way is to ask a window
what its scale factor is.

00:25:47.460 --> 00:25:51.200
In theory in the future we might want different
windows to have different scale factors.

00:25:51.200 --> 00:25:53.000
Right now there's only a global scale factor,

00:25:53.000 --> 00:25:56.799
but still you should use the window-based
scale factor fetching APIs for now.

00:25:56.799 --> 00:26:02.169
If you do for some reason need to know the global scale
factor, we also have a couple APIs to use for those.

00:26:02.170 --> 00:26:06.029
And for both Carbon and Cocoa applications
these APIs are available.

00:26:06.029 --> 00:26:14.049
Okay, so let's talk about some of the common pitfalls
that you might see while becoming resolution independent.

00:26:14.049 --> 00:26:18.990
The first general class of problems
are coordinate system mismatches.

00:26:18.990 --> 00:26:22.700
Essentially that's where you're assuming
points and pixels are the same thing.

00:26:22.700 --> 00:26:25.980
There's one important thing to note here.

00:26:25.980 --> 00:26:32.220
Window coordinates in Cocoa are pixels, whereas window
coordinates for views in both Carbon and Cocoa are in points.

00:26:32.220 --> 00:26:35.920
So if you're ever taking window coordinates
and trying to apply them to the view,

00:26:35.920 --> 00:26:39.039
you're going to need to do some conversion
in there, or vice versa.

00:26:39.039 --> 00:26:44.190
If you're not doing this conversion, generally what these
problems manifest as is your window coming up too small,

00:26:44.190 --> 00:26:51.860
or a control coming up too big, or a control that's
partly scrolled out of view, or something like that.

00:26:54.549 --> 00:26:57.769
So if you do see one of these problems,
the key is converting.

00:26:57.769 --> 00:27:01.480
We have APIs that you can convert between
points and pixels in various ways.

00:27:01.480 --> 00:27:07.220
You can ask an NSView to convert to window
coordinates, so to go from points to pixels.

00:27:07.220 --> 00:27:10.170
Similarly you can ask NSWindow to do certain conversions.

00:27:10.170 --> 00:27:15.750
And for Carbon applications we have a number of
conversion APIs for points, rectangles, and sizes.

00:27:15.750 --> 00:27:25.009
One concrete case that we see quite a lot of
coordinate conversion problems is with OpenGL.

00:27:25.009 --> 00:27:33.089
Anybody that uses OpenGL directly without going through
some of the standard system behavior will probably need

00:27:33.089 --> 00:27:36.480
to do a conversion when they set the GL surface size.

00:27:36.480 --> 00:27:39.529
The GL surface size is always interpreted in pixels.

00:27:39.529 --> 00:27:43.279
So for example, if you have a view that's
100 points by 100 points,

00:27:43.279 --> 00:27:49.879
and it's running at a 2 times scale factor, and you
ask its glViewport to be 100 by 100,

00:27:49.880 --> 00:27:55.630
that's going to be 100 pixels by 100 pixels,
so it's only going to take up a tiny portion of your view.

00:27:55.630 --> 00:28:04.090
Of course, to fix this, you just need to convert from
points to pixels, and then call the glViewport API.

00:28:04.089 --> 00:28:08.439
So now to show a few problems in an application bring up,

00:28:08.440 --> 00:28:10.769
I'd like to invite David back up,
and he'll run you through that.

00:28:10.769 --> 00:28:12.210
( Applause )

00:28:12.210 --> 00:28:13.970
>> Thank you.

00:28:20.109 --> 00:28:26.069
Forgot to clean up here, so I'm just going to quit BBEdit
and TextEdit, we're not going to mess with them any more.

00:28:26.069 --> 00:28:32.159
But we're going to leave the scale factor window up.

00:28:32.160 --> 00:28:37.390
Okay, I wrote a small sample app that shows some of
the good things that you get for free in your app

00:28:37.390 --> 00:28:41.330
when you turn on resolution independence.

00:28:41.329 --> 00:28:50.759
And it also shows a couple of the pitfalls, and
we'll just go through and fix those really quick.

00:28:50.759 --> 00:28:57.980
So I have a little sample app, we'll just run it at
1.0 without resolution independence turned on.

00:28:57.980 --> 00:29:05.829
And it's just a simple app that has an OpenGL
view, custom control, a couple of system controls.

00:29:05.829 --> 00:29:07.710
And I also have some bitmap images.

00:29:07.710 --> 00:29:11.360
If you look down here in the bottom right,
it's a simulation of a little palette

00:29:11.359 --> 00:29:17.729
to turn on and off some of the sides of a cube.

00:29:17.730 --> 00:29:24.200
The custom control is controlled by a few system
controls here, you can, I'm not an OpenGL expert,

00:29:24.200 --> 00:29:28.980
I thought I would try and do it for fun
to show some of the OpenGL pitfalls.

00:29:28.980 --> 00:29:38.009
But interestingly, let me show you if I change
the user interface resolution to 1.5,

00:29:38.009 --> 00:29:43.579
and run that app again, you see it comes up bigger.

00:29:43.579 --> 00:29:48.740
All the system-provided controls, like
the sliders and the circular slider,

00:29:48.740 --> 00:29:51.430
the dial-looking thing, they look pretty good.

00:29:51.430 --> 00:29:55.269
I can zoom in on them, they look
crisp, just like I showed you earlier.

00:29:56.819 --> 00:30:02.359
Interestingly, when I first started writing
this, previously when we did this in Tiger,

00:30:02.359 --> 00:30:06.229
the OpenGL view was a problem even in NSOpenGL.

00:30:06.230 --> 00:30:12.190
And I was going to show you guys how to fix that, but since
you're using NSOpenGL view already, it just works.

00:30:12.190 --> 00:30:15.370
They've gone ahead and fixed that, that's
one of the bugs we've addressed in Leopard.

00:30:15.369 --> 00:30:23.179
You can still, if you're using your own OpenGL surface
and managing it on your own, not through NSOpenGL,

00:30:23.180 --> 00:30:29.580
or NSOpenGL view, you're going to go ahead and do
that tweak that Guy suggested earlier in the slides.

00:30:36.009 --> 00:30:40.079
You'll notice also something else that
is working nicely is my custom control.

00:30:40.079 --> 00:30:44.159
When I made the custom control, I
kept resolution independence in mind.

00:30:44.160 --> 00:30:49.279
And it's just an arrow and a circle, so rather than
having some bitmap art and doing it in a custom fashion,

00:30:49.279 --> 00:30:52.230
I decided at that point I'm going to
need this resolution in the future,

00:30:52.230 --> 00:30:56.849
I'm going to use some procedural drawing,
and I'm going to draw this in code.

00:30:56.849 --> 00:31:03.709
So this just uses NSBeziers, you can do it
with core graphics and use Quartz directly.

00:31:03.710 --> 00:31:09.529
But these work nicely without you doing any work.

00:31:09.529 --> 00:31:13.329
So that's a few things that look
right, and are working well.

00:31:13.329 --> 00:31:15.929
How about a couple of things that aren't working right.

00:31:15.930 --> 00:31:25.350
Let's go down here and look at some of
the things on the bevel buttons here.

00:31:25.349 --> 00:31:32.889
So you can see the art doesn't
look great when it's been expanded.

00:31:32.890 --> 00:31:37.180
That's cause I had some one X art in a
bitmap, and I put it on a bevel button.

00:31:37.180 --> 00:31:42.029
The other thing that's actually more
important is a pixel rounding problem.

00:31:42.029 --> 00:31:49.230
If you look at the bevel button that has the green icon
on it, the lines of the bevel buttons don't look right,

00:31:49.230 --> 00:31:53.009
they're not like a palette, they're
supposed to be edge to edge.

00:31:53.009 --> 00:32:00.269
So we're going to go ahead and fix
some things with this palette.

00:32:02.369 --> 00:32:05.149
Quit the app.

00:32:05.150 --> 00:32:09.690
First let's go ahead and look at, I'm just
going to quickly show you that custom view I made.

00:32:09.690 --> 00:32:12.960
It's the orientation view.

00:32:12.960 --> 00:32:20.299
It's pretty simple to go ahead and make a circle, fill it
in, and then make an arrow, rotate it the right direction,

00:32:20.299 --> 00:32:22.589
and fill it in just using some Bezier stuff.

00:32:22.589 --> 00:32:27.409
I come from a Carbon background, so I just
took a look at how to do this with Beziers,

00:32:27.410 --> 00:32:30.090
I haven't used Beziers a lot, and
it was very straight forward.

00:32:30.089 --> 00:32:35.309
I've done a lot of core graphics stuff,
but this is just as simple using Quartz.

00:32:35.309 --> 00:32:46.539
So let's go fix those bevel buttons
that I used to make the palettes.

00:32:46.539 --> 00:32:50.980
So the first thing that I want to
address in there is the alignment,

00:32:50.980 --> 00:32:55.250
where that problem was where the
edges weren't touching each other.

00:32:55.250 --> 00:33:00.960
I actually have a method in here called alignFaceButtons
on the controller of the window.

00:33:00.960 --> 00:33:07.680
So once the window is loaded from the .nib, I have
some information about where those bevel buttons are,

00:33:07.680 --> 00:33:12.730
and I'm going to, I just cycled through them and
quickly fixed them, and I'll show you how that works.

00:33:12.730 --> 00:33:19.849
I get the scale factor from the window, and if it's not
1.0, I'm going to do something to fix the problem.

00:33:19.849 --> 00:33:21.809
If it's 1.0 it's going to work great.

00:33:21.809 --> 00:33:25.450
I could refine this to check and
see if it's nonintegral or not.

00:33:25.450 --> 00:33:30.549
Like if it's going to work fine at 2.0
because it won't form any pixel cracks,

00:33:30.549 --> 00:33:36.419
because in this particular case those bevel buttons
are 45 pixels in size, they're squares.

00:33:36.420 --> 00:33:41.630
When you run at scale factor of 1.5,
you multiply 45 by 1.5,

00:33:41.630 --> 00:33:46.460
you know you're going to get some integral value in there,
and that's where the problem with the alignment comes in.

00:33:48.420 --> 00:33:52.130
So for each of those bevel buttons,
I go through and I get its frame.

00:33:53.609 --> 00:33:59.529
And then I convert that frame to window
pixels to find out how many pixels there are.

00:33:59.529 --> 00:34:02.619
And that's the nonintegral value
that's causing the problem.

00:34:02.619 --> 00:34:06.759
So once I get those nonintegral values,
I go ahead and I convert them back

00:34:06.759 --> 00:34:10.889
into a rectangle that's been integralized
in pixels on the window.

00:34:10.889 --> 00:34:15.509
So that'll make them line up afterwards.

00:34:15.510 --> 00:34:20.090
I put those, I convert those back to points.

00:34:20.090 --> 00:34:28.680
Now we started out with integral points, converted them
up to pixels where they were nonintegral, made the,

00:34:28.679 --> 00:34:33.460
made those integral, I'm converting them
back, you're going to get nonintegral points.

00:34:33.460 --> 00:34:38.360
So that later on when the system goes to draw the
bevel button, it's going to up convert the pixels

00:34:38.360 --> 00:34:42.210
to do the drawing of the bevel button, that's
how the control drawing works in the system.

00:34:42.210 --> 00:34:48.650
And it's going to convert those, and they're going to
nicely convert into nice round integralized values.

00:34:48.650 --> 00:34:51.309
And I go ahead and I set the frame on them.

00:34:51.309 --> 00:34:58.469
So I've tuned on this method, I'm just going to
run the app again and see if it worked.

00:34:58.469 --> 00:35:06.839
I zoom in close here, and you can see without doing
much to it, I've lined them all up and they look

00:35:06.840 --> 00:35:10.769
like a palette should look again where
all the edges are touching each other.

00:35:10.769 --> 00:35:19.809
An important thing to note here is you don't
have to do this for every control on your window.

00:35:19.809 --> 00:35:21.579
In this particular case, I need them to line

00:35:21.579 --> 00:35:24.500
up because they're arranged side by
side, and I need the pixel alignment.

00:35:24.500 --> 00:35:29.130
But if you look at the other views, like the
system views, or even the custom view I wrote,

00:35:29.130 --> 00:35:33.650
those might not be at perfect integral
values, but they draw quite fine.

00:35:33.650 --> 00:35:37.500
So you don't really need to mess with them, I've only gone
through and adjusted these ones that are special case.

00:35:37.500 --> 00:35:40.190
So this is not something you have to
do for every view in your whole window,

00:35:40.190 --> 00:35:43.690
or else we would go ahead and do it for you.

00:35:45.820 --> 00:35:49.720
I still have the problem where the icons don't look great.

00:35:49.719 --> 00:35:54.659
I know they're not the fanciest icons in the world,
I'm not an artist, I'm an engineer, and I made them.

00:35:54.659 --> 00:35:59.879
Apple does have some good artists,
so they'll draw that nice UI for you.

00:35:59.880 --> 00:36:05.640
So I'll go through, and I'm going to show you how
to put some 1x and 4x art in so that the,

00:36:05.639 --> 00:36:08.960
I don't know if they're going to look
any better, cause I also drew them.

00:36:08.960 --> 00:36:09.369
( Laughter )

00:36:09.369 --> 00:36:14.059
But I'll at least show you that
you're going to use different art.

00:36:19.619 --> 00:36:22.949
I guess I should stop scaling.

00:36:22.949 --> 00:36:30.369
So I'm going to use the tiffutil that Guy mentioned earlier,
and I'm going to take, I have some different versions

00:36:30.369 --> 00:36:37.339
of the art, and I'm going to catonate them together
and make a multi-image .tiff out of them.

00:36:37.340 --> 00:36:44.470
So it's called tiffutil, and I'm
going to use the special flag, -cat.

00:36:44.469 --> 00:36:48.369
-cat means catonate, I'm going to catonate them all
together, but there's a special version of it

00:36:48.369 --> 00:36:51.829
for high DPI stuff called -cathidpicheck.

00:36:51.829 --> 00:37:02.049
I'm going to work on my yellow image here, and I have a 32
by 32, 72 DPI vers2ion of my image,

00:37:02.050 --> 00:37:04.780
that's the one you've been seeing so far.

00:37:04.780 --> 00:37:10.670
And I'm going to catonate another version I have.

00:37:10.670 --> 00:37:17.030
It's a 128 by 128, that's 4 times the number of
pixels on each axis.

00:37:17.030 --> 00:37:22.510
The important thing is it's a 288 DPI image,
so it's 4 times bigger in pixels,

00:37:22.510 --> 00:37:24.380
but it's a 288 DPI image.

00:37:24.380 --> 00:37:28.700
So that means it's the same size, it's just that
there's more pixels packed into the image.

00:37:28.699 --> 00:37:39.659
And I have to output that to a file where
there are, where it's going to end up so

00:37:39.659 --> 00:37:42.409
that it's a multi-image .tiff with both the images in there.

00:37:42.409 --> 00:37:46.230
This is the image I've been using so far on my
project, so we're just going to recompile the project,

00:37:46.230 --> 00:37:51.750
and it's going to start using this newly overwritten image.

00:37:51.750 --> 00:37:53.710
Two images written, there's a new file.

00:37:53.710 --> 00:37:57.329
So that's .tiff utility telling me everything went well.

00:37:57.329 --> 00:38:03.840
If you do something like you don't have the
dots per inch set properly on your 4x image,

00:38:03.840 --> 00:38:09.059
or your 4x image is not some other way
4 times bigger than your1x image,

00:38:09.059 --> 00:38:11.960
tiffutil will tell you what you need to correct.

00:38:11.960 --> 00:38:14.429
So I've gone ahead and I've changed that one.

00:38:14.429 --> 00:38:16.409
Let's go back, run the app again.

00:38:16.409 --> 00:38:23.559
And when you look at it now, you can see that everything
except for the yellow icon looks the way it used to.

00:38:23.559 --> 00:38:31.659
The yellow icon is drawing with the higher resolution art.

00:38:31.659 --> 00:38:36.250
I can zoom in on it, like I promised
you, it's not perfectly beautiful art,

00:38:36.250 --> 00:38:38.440
but you can see that there's more detail in it to be used.

00:38:38.440 --> 00:38:45.329
So it's taking the 4x image, and it's scaling it
down to fit it into the 1.5 scaled interface.

00:38:45.329 --> 00:38:51.210
Rather than the other ones, which are taking 1x art
and upscaling it, that means it has less information

00:38:51.210 --> 00:38:57.449
to base the new upscaled image on,
and you end up with a better result.

00:38:57.449 --> 00:39:00.750
And that's it for me.

00:39:00.750 --> 00:39:08.199
Let's go back to Guy so he can finish up.

00:39:08.199 --> 00:39:08.539
( Applause )

00:39:08.539 --> 00:39:09.099
>> Thank you, David.

00:39:09.099 --> 00:39:12.329
So one important point from David's
presentation is that he was always,

00:39:12.329 --> 00:39:14.960
he was already forward thinking
about resolution independence.

00:39:14.960 --> 00:39:19.800
He made some art as vectors, because he knew it
would be resolution independent in the future.

00:39:19.800 --> 00:39:23.710
Some of his custom art was already vectors,
and he was also using standard system controls,

00:39:23.710 --> 00:39:27.289
which is always a great thing to do,
cause that means we can fix bugs for you.

00:39:27.289 --> 00:39:32.409
Okay, so let's talk about more
of the problems you're going to see.

00:39:32.409 --> 00:39:34.889
This is something we like to call pixel cracks.

00:39:34.889 --> 00:39:38.579
Pixel cracks, there's a couple different
kinds of pixel cracks in this screen shot.

00:39:38.579 --> 00:39:42.219
The grid that's in the background of the
window, that's one sort of pixel crack.

00:39:42.219 --> 00:39:48.449
There's also a horizontal line on the popup button
that crosses just above the word sizes there.

00:39:48.449 --> 00:39:52.719
And the OK button has a bunch of vertical lines on it.

00:39:52.719 --> 00:39:58.519
So these occur when adjacent images, or
images that should be adjacent are being drawn

00:39:58.519 --> 00:40:03.289
on point values that do not map to integral pixels.

00:40:03.289 --> 00:40:05.670
So let me show you that in a little bit more detail.

00:40:05.670 --> 00:40:12.760
Let's say we have a 5 point tall green line that we
want to draw directly above a 5 point tall red line.

00:40:12.760 --> 00:40:15.940
At normal resolutions, 5 points is 5 pixels,

00:40:15.940 --> 00:40:20.690
so you get a perfect 5-pixel tall green
line above a 5-pixel tall red line.

00:40:20.690 --> 00:40:24.970
Now let's take a look at what it looks like if
we were running at a 1.5 scale factor.

00:40:24.969 --> 00:40:30.089
Well, 10 points at 1.5 scale factor amounts
to 15 pixels.

00:40:30.090 --> 00:40:35.480
So our 5-point tall green line turns into
a 7.5-pixel tall green line,

00:40:35.480 --> 00:40:38.650
and the same is true for the red, the red line

00:40:38.650 --> 00:40:41.849
Now you can't actually draw in 7.5 pixels,

00:40:41.849 --> 00:40:44.980
so that means both of those lines are
going to end up touching 8 pixels.

00:40:44.980 --> 00:40:48.800
And they're going to touch a shared pixel, and
you're going to get a blend of red and green,

00:40:48.800 --> 00:40:51.160
which is going to look somewhat orangey brown like that.

00:40:51.159 --> 00:40:54.039
And that's what a pixel crack is.

00:40:54.039 --> 00:40:56.880
So let's talk about how to fix that.

00:40:56.880 --> 00:41:00.360
Okay, so the first thing we need to do is
we want to make sure that that red line

00:41:00.360 --> 00:41:03.800
and that green line both draw on integral pixel boundaries.

00:41:03.800 --> 00:41:10.230
So we need to calculate what a 5-point tall green
line would draw into in terms of pixel boundaries.

00:41:10.230 --> 00:41:13.300
And like we said, it's going to be
7.5 pixels tall.

00:41:13.300 --> 00:41:14.630
So we need to round one way.

00:41:14.630 --> 00:41:17.990
We're just going to arbitrarily pick
to round that green line up.

00:41:17.989 --> 00:41:22.209
So we're going to round 7.5 pixels up to 8,
and we're going to round,

00:41:22.210 --> 00:41:25.309
for the red line, 7.5 pixels down to 7.

00:41:25.309 --> 00:41:30.659
And then if we draw in those pixel spaces,
you end up getting nicely joined images.

00:41:30.659 --> 00:41:35.529
Now the green line is a little bit bigger than the
red, the red line, but it ends up looking better

00:41:35.530 --> 00:41:37.760
that way than if they were blurred together.

00:41:37.760 --> 00:41:41.530
Let me go into that in a little bit more detail.

00:41:41.530 --> 00:41:48.130
So what you need to do first is take your points space
coordinates and convert them to pixel space coordinates.

00:41:48.130 --> 00:41:50.590
And this shows a little bit of
Cocoa code you can use to convert

00:41:50.590 --> 00:41:53.690
to pixel space coordinates by converting
to the window space.

00:41:53.690 --> 00:41:57.510
Then you use floor() and seal() to find
the nearest integral pixel coordinates.

00:41:57.510 --> 00:42:01.450
And then you convert back from those
pixel coordinates into point coordinates.

00:42:01.449 --> 00:42:06.019
And as David showed you with the bevel button
example, those point coordinates will be nonintegral.

00:42:06.019 --> 00:42:13.190
And that may feel a little bit odd to you, why am I, why
am I drawing a line that's 5.2 points tall?

00:42:13.190 --> 00:42:18.200
And it feels weird, but it's actually correct, cause
it's going to map to an integral number of pixels.

00:42:18.199 --> 00:42:22.599
And then you pass those fractional point coordinates
to the drawing routine, and everything looks great.

00:42:22.599 --> 00:42:28.889
Another common problem are the use of offscreens.

00:42:28.889 --> 00:42:33.599
The frameworks will automatically
scale up windows, especially for Cocoa,

00:42:33.599 --> 00:42:35.190
you're going to get frameworks scaled automatically.

00:42:35.190 --> 00:42:37.880
We automatically make window backing buffers bigger.

00:42:37.880 --> 00:42:40.010
That's not true for the use of offscreens.

00:42:40.010 --> 00:42:43.060
If you're using offscreens in your
application, it's your responsibility

00:42:43.059 --> 00:42:45.799
to make them bigger to match the scale factor.

00:42:45.800 --> 00:42:50.680
So if you want a 3 point tall offscreen,
and you're running at a 3 times scale factor,

00:42:50.679 --> 00:42:53.710
you need to make sure your offscreen
is actually 9 pixels tall.

00:42:53.710 --> 00:42:58.730
So you multiply your desired point height times the
scale factor to get the pixel height that you need.

00:42:58.730 --> 00:43:04.389
If you're doing this wrong, generally what occurs is
you either get too small a drawing in some portion

00:43:04.389 --> 00:43:09.849
of your application, or depending on the routine
you're using to blit your offscreen to the window,

00:43:09.849 --> 00:43:14.799
you may get correctly-sized art,
but it ends up looking blurry.

00:43:17.889 --> 00:43:25.679
Another problem you might see, which is an artifact of
scaling down high-resolution images is banding or jaggy art.

00:43:25.679 --> 00:43:29.489
If this is a problem for you, you've
got a couple possible solutions.

00:43:29.489 --> 00:43:33.939
One thing you can do is use Quartz's
higher quality interpolation.

00:43:33.940 --> 00:43:37.409
You can turn that on via either Cocoa or via the Quartz APIs.

00:43:37.409 --> 00:43:38.719
But, of course, there's a cost.

00:43:38.719 --> 00:43:42.089
Higher quality interpolation is
going to take a little bit more time.

00:43:42.090 --> 00:43:48.539
So if you can't afford that time, if you're rendering
some image for a particularly high performant need,

00:43:48.539 --> 00:43:51.599
the other option is to use additional bitmaps.

00:43:51.599 --> 00:43:55.699
There's nothing wrong with shipping five different
high res bitmaps for a certain piece of art.

00:43:55.699 --> 00:44:01.579
So if you really want your 1.25 scale factor of your
app to look great, ship a normal resolution piece

00:44:01.579 --> 00:44:04.860
of art, a 1.25 piece of art, and a 4 times
piece of art,

00:44:04.860 --> 00:44:11.090
or any number of intermediate pieces that you need.

00:44:11.090 --> 00:44:14.950
Another thing that we've seen a few
applications do which will send you directly

00:44:14.949 --> 00:44:18.089
to the small mode bucket is drawing directly to the screen.

00:44:18.090 --> 00:44:23.120
You can't draw directly to the screen in a resolution
independent fashion unless you jump through more hoops.

00:44:23.119 --> 00:44:26.829
And, well, I don't really want to explain how
you can do it, cause you shouldn't be doing it.

00:44:26.829 --> 00:44:28.429
Don't draw directly to the screen.

00:44:28.429 --> 00:44:31.629
The better approach is to use an overlay window.

00:44:31.630 --> 00:44:35.380
That way it's got its own backing buffer,
you can draw into it as much as you want,

00:44:35.380 --> 00:44:42.470
and you're not going to disturb any
other content on the screen.

00:44:42.469 --> 00:44:49.709
If your application supports plug-ins, you're going to have to
do some work that a system engineers already did for Mac OS.

00:44:49.710 --> 00:44:53.909
We looked at all of our APIs that
communicated in terms of points and rectangles,

00:44:53.909 --> 00:44:59.250
and we had to decide whether a given API was
operating on a point space or a pixel space.

00:44:59.250 --> 00:45:04.099
So if you have the same sort of APIs for your plug-ins,
you're going to want to make those definitions as well,

00:45:04.099 --> 00:45:08.920
so that your plug-in developers know when to
convert their coordinates before calling your APIs.

00:45:08.920 --> 00:45:12.889
Now a harder story is if your plug-in model uses QuickDraw.

00:45:12.889 --> 00:45:16.659
As I said before, QuickDraw just doesn't
work in resolution independence mode.

00:45:16.659 --> 00:45:21.789
So if you have a Quick-Draw-based plug-in API, you're going
to need to give your plug-in developers a new API in order

00:45:21.789 --> 00:45:25.059
for your application to go resolution independent.

00:45:29.389 --> 00:45:34.089
Developers always need their applications to run
earlier than the latest and greatest OS release,

00:45:34.090 --> 00:45:37.260
and we're always telling you to adopt
the latest and greatest OS features.

00:45:37.260 --> 00:45:39.760
Resolution independence is no different.

00:45:39.760 --> 00:45:45.200
So if in the process of becoming resolution independent
you adopt several new controls that are only available

00:45:45.199 --> 00:45:49.489
on Leopard, well you're still going to need to
use your custom controls on older OS releases.

00:45:49.489 --> 00:45:54.239
So you'll probably have to do a runtime version check
and see whether you're running on Tiger or Leopard,

00:45:54.239 --> 00:45:57.069
or earlier, and make the right decisions there.

00:45:57.070 --> 00:46:01.930
If you want to use multi-image .tiff files on
earlier OS releases, go ahead and do that,

00:46:01.929 --> 00:46:06.559
however, you need to make sure your multi-image
.tiff files are correctly assembled with tiffutil.

00:46:06.559 --> 00:46:10.570
And that's one of the jobs of that -cathidpicheck flag.

00:46:10.570 --> 00:46:19.950
So long as your individual images all have the same
size property, they can have different pixel property,

00:46:19.949 --> 00:46:24.579
pixel size properties, and it will look great
using NSImage even on earlier system versions.

00:46:24.579 --> 00:46:31.909
So this is if you don't have your images with the same
size parameter, -cathidpicheck will warn you about that

00:46:31.909 --> 00:46:37.519
so you can fix it, make the changes, and then build
your multi-image .tiff file with the correct art.

00:46:40.429 --> 00:46:41.889
So that's about it.

00:46:41.889 --> 00:46:44.609
It's not really all that hard to
get to resolution independence.

00:46:44.610 --> 00:46:49.380
Clearly you have to spend a lot of time revising your
artwork, and that's going to be a burden on some UI designers,

00:46:49.380 --> 00:46:51.880
but the code changes generally are pretty minimal.

00:46:51.880 --> 00:46:54.890
Carbon developers, of course, have
a few more hoops to jump through.

00:46:54.889 --> 00:47:00.000
So now is another time when Carbon developers need to
look seriously about why they're developing with Carbon.

00:47:00.000 --> 00:47:04.579
Maybe it's the right time, maybe this is a little bit more
of a push to go to Cocoa, and maybe this is the right time

00:47:04.579 --> 00:47:06.099
for those Carbon developers to go to Cocoa.

00:47:06.099 --> 00:47:07.599
So seriously consider that.

00:47:07.599 --> 00:47:12.980
Because if you get to Cocoa first, your resolution
independence path is likely to be a little bit easier.

00:47:12.980 --> 00:47:17.190
And, of course, the Leopard resolution
independence support is not complete.

00:47:17.190 --> 00:47:22.599
It's not going to be a user release for resolution
independence in Leopard, so there are bugs in the system.

00:47:22.599 --> 00:47:25.679
We'd love to hear about any bugs
you find, we don't mind duplicates.

00:47:25.679 --> 00:47:28.429
Even if you're sure somebody's
already filed it, please file it.

00:47:28.429 --> 00:47:31.269
We don't mind marking it as a duplicate,
we'd rather have the issue tracked.

00:47:31.269 --> 00:47:35.380
So, please, file those bugs.

00:47:35.380 --> 00:47:38.210
Deric Horn is the evangelist that
takes care of the frameworks,

00:47:38.210 --> 00:47:44.579
and part of his role is handling resolution independence,
so send him lots of emails about it, not me please.

00:47:44.579 --> 00:47:48.829
And we have a lab immediately following this
session downstairs, so feel free to drop down.

00:47:48.829 --> 00:47:54.179
You can talk to a number of us in person, we can help you
decide which is the best format for artwork and so forth,

00:47:54.179 --> 00:47:57.139
and we'd love to hear feedback about what APIs you need.
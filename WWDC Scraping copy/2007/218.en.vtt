WEBVTT

00:00:20.010 --> 00:00:27.620
>> Welcome to the 3:30 session of the last of
the Objective-C technologies presentations.

00:00:27.620 --> 00:00:32.399
We're going to be talking about
garbage collection this afternoon.

00:00:32.399 --> 00:00:34.250
So I'd like a quick show of hands.

00:00:34.250 --> 00:00:39.789
How many people were perhaps at the garbage
collection talk we gave at last year's WWDC.

00:00:39.789 --> 00:00:44.149
Okay. But a lot of you haven't.

00:00:44.149 --> 00:00:50.259
So this is a slightly revised and
extended version of that talk.

00:00:50.259 --> 00:00:53.769
I am sure that you memorized anything I said last time,

00:00:53.770 --> 00:00:59.260
but I think there will still be a few
things for you to learn this time.

00:00:59.259 --> 00:01:06.700
I -- I have wizard runtimes on my business card and
Bill Bumgarner now takes great pride

00:01:06.700 --> 00:01:09.040
in saying that he's the wrangler of wizards.

00:01:09.040 --> 00:01:14.580
So we'll see how well we do today.

00:01:14.579 --> 00:01:21.109
So, so this talk we're going to go
through sort of the big picture.

00:01:21.109 --> 00:01:25.280
What is garbage collection for Objective-C and Cocoa.

00:01:25.280 --> 00:01:28.939
We'll spend a lot of time talking
about GC design strategies.

00:01:28.939 --> 00:01:36.049
It turns out that any time you take a big
sub system and rewrite it, re-architect it,

00:01:36.049 --> 00:01:39.700
you're going to have to rethink a few things.

00:01:39.700 --> 00:01:44.070
So with garbage collection, you
get some really nice benefits.

00:01:44.069 --> 00:01:46.179
But you have to keep a few things in mind.

00:01:46.180 --> 00:01:50.910
Especially if you're used to programming
in Objective-C without garbage collection.

00:01:50.909 --> 00:01:56.969
So if you're just coming to the platform, if you're
coming to it from Java or from scripting or from something

00:01:56.969 --> 00:02:02.090
like that, maybe -- maybe some of the stuff is not going
to make a lot of sense because you don't do this stuff.

00:02:02.090 --> 00:02:08.400
But if you are a C programmer or an Objective-C programmer
today, I want to go over some things that you really have

00:02:08.400 --> 00:02:12.360
to keep in mind that you don't do
in a garbage collected environment.

00:02:12.360 --> 00:02:17.220
I have a few slides on the last couple of topics.

00:02:17.219 --> 00:02:20.050
Adding GC capability fearlessly.

00:02:20.050 --> 00:02:24.380
I have already heard from several of you
here at the conference that -- why are we --

00:02:24.379 --> 00:02:29.039
why is Apple saying use garbage
collection only for new applications.

00:02:29.039 --> 00:02:32.169
I mean, why can't I do it for my old applications.

00:02:32.169 --> 00:02:34.259
A few people came down to the labs.

00:02:34.259 --> 00:02:35.799
And it's quite possible to do that.

00:02:35.800 --> 00:02:42.180
It's quite possible to upgrade the GC, and I'll tell
you how we've done it inside Apple, and how you can,

00:02:42.180 --> 00:02:45.060
if you think it's appropriate for your application.

00:02:45.060 --> 00:02:50.129
We recommend it though, because we sort of
know that most of you need to ship on Tiger.

00:02:50.129 --> 00:02:54.150
And since it's a Leopard only technology,
we don't want to frustrate you

00:02:54.150 --> 00:02:57.590
by saying convert to it because -- that's kind of silly.

00:02:57.590 --> 00:03:01.210
We'll spend a little bit of time on debugging and tuning.

00:03:01.210 --> 00:03:04.750
I think most of you are in the still adopting it phase.

00:03:04.750 --> 00:03:10.060
But I'll tell you that there are ways -- some
of the tricks we use to debug and to tune.

00:03:10.060 --> 00:03:13.379
And then we'll close with a demo.

00:03:13.379 --> 00:03:16.509
So the big picture.

00:03:16.509 --> 00:03:21.500
To tell the store of garbage collection,
it's sort of like a story.

00:03:21.500 --> 00:03:28.659
So we're going to go to the five Ws that you all learned
in -- somewhere -- middle school about how to tell stories.

00:03:28.659 --> 00:03:31.539
So who is garbage collection for?

00:03:31.539 --> 00:03:32.400
Very simple.

00:03:32.400 --> 00:03:35.210
Garbage collection is for you.

00:03:35.210 --> 00:03:41.110
Inside of Apple, we have a lot of Objective-C code,
but we also have a lot of capability constraints.

00:03:41.110 --> 00:03:45.990
So, for example, the preferences
panel has to load plug-ins and stuff.

00:03:45.990 --> 00:03:51.689
And everything that runs in a garbage collection
application has to be garbage collection aware.

00:03:51.689 --> 00:03:57.129
And so we really can't con overnight preferences over,
we can't -- so we go down the list of your applications,

00:03:57.129 --> 00:04:04.340
it turns out that we -- most of them, automator,
many of them have capability constraints

00:04:04.340 --> 00:04:06.629
such that they can't adopt it internally.

00:04:06.629 --> 00:04:14.829
But in truth, we really wanted with Objective-C
dot O to give you the developers a new platform

00:04:14.830 --> 00:04:18.670
to program on that is just easier and simpler.

00:04:18.670 --> 00:04:22.569
And we will inside Apple adopt it as we can.

00:04:22.569 --> 00:04:26.879
So -- but this is really a labor of
love in some respects for you guys.

00:04:26.879 --> 00:04:33.719
And we really want you to take advantage, use it,
and get your apps to market quicker because of that.

00:04:33.720 --> 00:04:37.150
So what is it?

00:04:37.149 --> 00:04:40.229
Well, last year I talked about a special curry.

00:04:40.230 --> 00:04:41.850
And I'm going to talk about it again today.

00:04:41.850 --> 00:04:43.910
So what is a curry?

00:04:43.910 --> 00:04:55.070
So when I left Iowa a long time ago and -- and found
cuisine, one of the cuisines I discovered was Chinese food.

00:04:55.069 --> 00:04:57.120
And they had this yellow chicken curry.

00:04:57.120 --> 00:04:58.670
And I go. Curry.

00:04:58.670 --> 00:04:59.520
Wow, great.

00:04:59.519 --> 00:05:00.469
I love this stuff.

00:05:00.470 --> 00:05:05.320
And I went to a Thai restaurant and
they had red curries and green curries.

00:05:05.319 --> 00:05:08.009
And I go -- hmm, curries aren't just curries.

00:05:08.009 --> 00:05:09.240
Curries are different.

00:05:09.240 --> 00:05:14.300
And then I went to, of course, Indian
restaurants and just had all kinds of curries.

00:05:14.300 --> 00:05:20.960
And what I found out very quickly though was
that curries are actually a mixture of spices.

00:05:20.959 --> 00:05:23.819
For me there always has to be a little bit of cayenne in it.

00:05:23.819 --> 00:05:28.519
But you know, you take cardamom, you take cumin,
and you mix them all together and you get a curry.

00:05:28.519 --> 00:05:31.310
So everybody's curry is a little bit different.

00:05:31.310 --> 00:05:35.819
So it turns out that were garbage
collectors it's the same kind of story.

00:05:35.819 --> 00:05:41.319
You probably experienced garbage collectors -- I don't
know -- maybe back in your days in school with list

00:05:41.319 --> 00:05:45.310
or Small Talk system, or if you're using Ruby or Python,

00:05:45.310 --> 00:05:49.050
you're getting a little taste of
garbage collection on the side.

00:05:49.050 --> 00:05:52.759
Or if you're using Java or over on
dot net you get garbage collection.

00:05:52.759 --> 00:05:55.180
But it turns out they're all like curries.

00:05:55.180 --> 00:05:59.840
They're all a mixture of different
techniques for different circumstances.

00:05:59.839 --> 00:06:03.899
And so that's exactly what we did for Objective-C.

00:06:03.899 --> 00:06:07.389
What we did, we took three key elements.

00:06:07.389 --> 00:06:11.009
We took the idea of having a conservative collector.

00:06:11.009 --> 00:06:16.579
We added sort of the 1980s innovation of generational stuff.

00:06:16.579 --> 00:06:22.849
And then we threw in a little bit of concurrency as well,
because we don't have to stop all threads and stuff.

00:06:22.850 --> 00:06:27.920
And we end up with what we consider to be, you
know, the garbage collection that's just right

00:06:27.920 --> 00:06:30.830
for Cocoa, it's just right for our platform.

00:06:30.829 --> 00:06:33.719
So let me go into this in a little bit more detail.

00:06:33.720 --> 00:06:34.930
So conservative.

00:06:34.930 --> 00:06:39.110
For those of you not -- sorry.

00:06:39.110 --> 00:06:42.410
I have a prop here I just have to dig out.

00:06:42.410 --> 00:06:52.090
For those of you not as well versed in the book on
garbage collection, what a conservative collector is,

00:06:52.089 --> 00:06:56.399
is one that does not move pointers around.

00:06:56.399 --> 00:07:01.829
You allocate some memory, and it sticks
in the spot that you allocated it at.

00:07:01.829 --> 00:07:04.949
So you can hand it out to C functions
and all kinds of other stuff.

00:07:04.949 --> 00:07:07.389
And it's not going to move underneath you.

00:07:07.389 --> 00:07:16.279
This is very good for sub systems like QuickTime that go
-- go read, you know, lots of data coming in off the fly

00:07:16.279 --> 00:07:21.909
and they stick it in buffers and they can just hand it off
to Cocoa code and they don't have to copy it all around.

00:07:21.910 --> 00:07:29.310
In a scheme like Java or dot net, they have very
fast what they call bump pointer allocators.

00:07:29.310 --> 00:07:35.250
They are super-fast at allocation, and what they don't
tell you is that they're more expensive to keep objects.

00:07:35.250 --> 00:07:42.009
Because they typically have to copy those objects back and
forth, you know, different kinds of schemes until they stick

00:07:42.009 --> 00:07:45.529
around for a long time and they stop moving them so much.

00:07:45.529 --> 00:07:49.199
But that copying is very expensive, because you have to,

00:07:49.199 --> 00:07:52.300
for one thing stop all the other
threads while you're doing that.

00:07:52.300 --> 00:07:53.590
You've got to go update things.

00:07:53.589 --> 00:07:56.299
It makes the language very restrictive.

00:07:56.300 --> 00:08:00.270
You just can't have a pointer to
an object and go whack at the bits.

00:08:00.269 --> 00:08:04.810
You know, you have very limited language
features to get at your pointers and stuff.

00:08:04.810 --> 00:08:11.009
So these are too much for Objective-C. Conservative
collection is the right model for Objective-C.

00:08:11.009 --> 00:08:13.259
Because it is a C language, after all.

00:08:13.259 --> 00:08:17.219
And pointers are our friends and our enemies.

00:08:17.220 --> 00:08:20.690
So generational, however, is a great innovation.

00:08:20.689 --> 00:08:29.009
It allows us or a collector to spend 10 percent of the
time recovering 90 percent of the garbage that's available.

00:08:29.009 --> 00:08:31.120
Now that's -- those are literal numbers.

00:08:31.120 --> 00:08:35.450
And I'll tell you how you can actually
watch that going on in our programs.

00:08:35.450 --> 00:08:36.500
You can validate that.

00:08:36.500 --> 00:08:41.870
And if that's not quite the ratio you see,
you can tune some stuff a little bit later.

00:08:41.870 --> 00:08:48.529
I say mostly concurrent here because well, in
the book there are, like, you know, super --

00:08:48.529 --> 00:08:53.220
super concurrent things and all kinds
of color three-color marking schemes.

00:08:53.220 --> 00:08:55.160
They sort of work for some applications.

00:08:55.159 --> 00:08:58.110
They don't work for general purpose programming.

00:08:58.110 --> 00:09:02.310
But in our scheme, we are concurrent,
we are highly concurrent.

00:09:02.309 --> 00:09:04.909
We have a collector running on a separate thread now.

00:09:04.909 --> 00:09:08.649
That's different than -- than we had last year at WWDC.

00:09:08.649 --> 00:09:13.289
And that allows you to allocate and bump reference
counts and all that kind of stuff most of the time.

00:09:13.289 --> 00:09:17.789
There's a small phase where we do what we know
-- what's known as zeroing our weak references,

00:09:17.789 --> 00:09:22.299
where your threads will kind of jamb up while
we get that little critical section done.

00:09:22.299 --> 00:09:26.809
So that's my only hesitation from saying
this is a fully concurrent allocator.

00:09:26.809 --> 00:09:28.139
It's very concurrent.

00:09:28.139 --> 00:09:30.259
It's very nice.

00:09:30.259 --> 00:09:36.759
A different -- one of the model
differences we have is that in Java

00:09:36.759 --> 00:09:40.319
when your object is done it's sent to finalize message.

00:09:40.320 --> 00:09:42.540
Well, we do the same thing.

00:09:42.539 --> 00:09:46.599
But in Java, for example, your object can come back alive.

00:09:46.600 --> 00:09:48.360
You can hand it out to other things.

00:09:48.360 --> 00:09:53.789
And so what happens in a Java collector is
it sort of has to collect these objects twice

00:09:53.789 --> 00:09:55.490
in order to actually get the memory back.

00:09:55.490 --> 00:10:01.110
The second time it finds it, it doesn't send a
finalized message and it grabs the memory back.

00:10:01.110 --> 00:10:03.779
But you know, that memory latency we didn't like.

00:10:03.779 --> 00:10:07.759
So we decided we're not going to allow objects to resurrect.

00:10:07.759 --> 00:10:11.580
One you get a finalize, you can't keep that thing alive.

00:10:12.649 --> 00:10:19.059
The other modern innovation that we have, is we
have what we call a zeroing weak reference system.

00:10:19.059 --> 00:10:22.039
You can have weak pointers to things.

00:10:22.039 --> 00:10:25.649
Things that will not keep the reference alive.

00:10:25.649 --> 00:10:29.120
And when the garbage collector
collects it, it will zero that pointer

00:10:29.120 --> 00:10:33.789
out so you will not have dangling
references in your programs.

00:10:33.789 --> 00:10:39.409
This clearly is a way to improve the quality of your code.

00:10:39.409 --> 00:10:43.240
On 32-bit systems we have a 4 gigabyte memory limit.

00:10:43.240 --> 00:10:44.669
In other words, there's no limit.

00:10:44.669 --> 00:10:48.529
You can have as much garbage collection
memory as you can allocate.

00:10:48.529 --> 00:10:54.149
On 64-bit systems we decided to put
a somewhat artificial limit in there.

00:10:54.149 --> 00:10:57.829
We decided on 32 gigabytes of 2garbage collecting memory.

00:10:57.830 --> 00:11:03.200
You still have a mall o key for other stuff and code
and all that stuff comes out of other address areas.

00:11:03.200 --> 00:11:07.710
So we think that's a fair -- a fair limit.

00:11:09.289 --> 00:11:12.309
So when can we do garbage collection?

00:11:12.309 --> 00:11:16.369
Well, we've been working on it internally for quite a while.

00:11:16.370 --> 00:11:18.100
It was about half done in Tiger.

00:11:18.100 --> 00:11:21.399
But the simple answer is you can do garbage collection now.

00:11:21.399 --> 00:11:24.429
I saw folks down in the lab just
really playing with the stuff.

00:11:24.429 --> 00:11:27.379
So go for it.

00:11:27.379 --> 00:11:28.039
So, where?

00:11:28.039 --> 00:11:32.250
It is a Leopard only feature.

00:11:32.250 --> 00:11:34.559
We need a lot of support in your frameworks.

00:11:34.559 --> 00:11:39.479
There's a little bit of code that's the garbage
collector, and a lot of code that's the frameworks.

00:11:39.480 --> 00:11:43.860
The frameworks are all garbage collection smart.

00:11:43.860 --> 00:11:51.940
When you run a program, all code that you -- that you
import with bundles and what not have to be GC aware.

00:11:51.940 --> 00:11:58.170
And so since GC is only available in Leopard, it turns out
that we have to build Leopard only applications for this.

00:11:58.169 --> 00:11:59.639
It is not required.

00:11:59.639 --> 00:12:02.559
Objective-C 2.0 does not require garbage collection.

00:12:02.559 --> 00:12:03.409
It's opted in.

00:12:03.409 --> 00:12:12.049
If you already have a well understood program and you just
need to update to some new Leopard idioms or whatever,

00:12:12.049 --> 00:12:15.309
go ahead and keep your program retain release aware.

00:12:15.309 --> 00:12:16.139
That's fine.

00:12:16.139 --> 00:12:20.669
But if you want to garbage collection,
you now have that choice.

00:12:20.669 --> 00:12:21.979
There's everywhere Cocoa.

00:12:21.980 --> 00:12:25.250
All of our Cocoa frameworks are CG capable.

00:12:25.250 --> 00:12:33.320
When you run a program all objects in
that program are collective objects.

00:12:33.320 --> 00:12:35.390
We do not some of them are retain and release.

00:12:35.389 --> 00:12:36.360
No, no, no.

00:12:36.360 --> 00:12:41.019
They're all collected including -- I didn't mention
this here, but we have CF style objects also.

00:12:41.019 --> 00:12:43.429
So if you're worried about that, don't worry.

00:12:43.429 --> 00:12:46.829
CF objects are NS objects as well.

00:12:48.370 --> 00:12:54.960
Last year we did not have a 64-bit
implementation available at WWDC.

00:12:54.960 --> 00:12:57.930
Where 64-bit, 32-bit Intel pow2er PC.

00:12:57.929 --> 00:12:59.370
GC runs everywhere.

00:12:59.370 --> 00:13:00.990
Universal.

00:13:00.990 --> 00:13:14.210
So to augment what I said about Cocoa frameworks we have a
lot of libraries that use sort of this CF type ref style.

00:13:14.210 --> 00:13:19.920
Or Core graphics or whether they're security or,
you know, there's tons of two-letter prefixes

00:13:19.919 --> 00:13:23.689
out there yielding up Core foundation-like objects.

00:13:23.690 --> 00:13:28.890
And all of these frameworks work
fine under garbage collection.

00:13:28.889 --> 00:13:30.830
You start with Objective-C.

00:13:30.830 --> 00:13:32.610
You reach out to these other frameworks.

00:13:32.610 --> 00:13:33.060
They work.

00:13:33.059 --> 00:13:35.949
I will talk about how you interact with them.

00:13:37.929 --> 00:13:40.519
So things it doesn't do.

00:13:40.519 --> 00:13:46.409
There's a lot of research papers that say, oh, here's
how you add garbage collection to C. You replace malloc

00:13:46.409 --> 00:13:52.480
with the collector and everything -- well,
that's what the research paper's about.

00:13:52.480 --> 00:13:53.470
We did not do that.

00:13:53.470 --> 00:13:58.470
Malloc still lives, and you can still malloc and free things.

00:13:58.470 --> 00:13:59.440
You don't want to do that.

00:13:59.440 --> 00:14:02.490
We want garbage collection to be very fast and efficient.

00:14:02.490 --> 00:14:06.299
So we want you to choose where you use garbage collection.

00:14:06.299 --> 00:14:16.120
Similarly, because C Plus Plus you rewriter allocator all
the time, we decided not to go after C Plus Plus head on.

00:14:16.120 --> 00:14:17.789
You can choose to do that though.

00:14:17.789 --> 00:14:26.789
You can choose to, you know, override
new, put in our allocator and have fun.

00:14:26.789 --> 00:14:31.759
We have some C language constructs that will
help the Compiler help you out with that.

00:14:31.759 --> 00:14:36.740
It's clearly, you know, this is not tertiary,
we're, you know, directory supporting.

00:14:36.740 --> 00:14:40.149
But it's possible to do.

00:14:40.149 --> 00:14:48.159
So, why? Well, retain, release, ao releasee, retain count.

00:14:48.159 --> 00:14:56.689
That was the strategy I helped come up with many years ago
at Next and that was the best that we could do at the time.

00:14:56.690 --> 00:15:01.730
It was better than new and free, which was very error prone.

00:15:01.730 --> 00:15:05.050
But the retain counting system with a good compromise.

00:15:05.049 --> 00:15:06.500
Especially with the auto release pool.

00:15:06.500 --> 00:15:09.950
It gave you almost garbage collection-like behavior.

00:15:09.950 --> 00:15:12.540
Especially in a single threaded environment.

00:15:12.539 --> 00:15:14.899
That was 15 years ago.

00:15:14.899 --> 00:15:17.179
Times have changed.

00:15:17.179 --> 00:15:19.599
15 years ago -- this is a little bit more like 20.

00:15:19.600 --> 00:15:25.139
The next box, the next cube retailed for $10,000.

00:15:25.139 --> 00:15:29.929
It had 8 megabytes of memory and one single processor.

00:15:29.929 --> 00:15:38.419
So I priced this out the other day for about
half the price you get a quad Core Mac pro

00:15:38.419 --> 00:15:41.769
with a 30 inch cinema display, and et cetera, et cetera.

00:15:41.769 --> 00:15:43.049
For less money.

00:15:43.049 --> 00:15:48.949
So although that's kind of interesting for the pro
user, the real story is that for the consumers.

00:15:48.950 --> 00:15:59.950
Our entry level products, our iBooks -- I'm sorry -- our
Mac books are dual core processors running at 2 gigahertz.

00:15:59.950 --> 00:16:02.410
This is phenomenal stuff.

00:16:02.409 --> 00:16:10.029
Even that little -- even that little -- that
little guy, that mini has a dual core in it.

00:16:10.029 --> 00:16:11.049
I mean, it's amazing.

00:16:11.049 --> 00:16:15.589
And these are the -- these are the kinds of
machines you folks are writing applications for.

00:16:15.590 --> 00:16:17.070
They have multiple cores on them.

00:16:17.070 --> 00:16:22.790
You should be taking advantage of them because
there's lots of fun stuff to do with CPU.

00:16:22.789 --> 00:16:25.909
But you have to program to it.

00:16:25.909 --> 00:16:30.339
You know, and here's a typical, like, setter getter pattern.

00:16:30.340 --> 00:16:34.110
I took a setter getter pattern because it's common enough.

00:16:34.110 --> 00:16:37.950
And I know that you people don't
code setters and getters this way.

00:16:37.950 --> 00:16:41.480
There's a lock in there because
you need it for multithread access.

00:16:41.480 --> 00:16:45.180
If you want to make your code thread aware, undercontain

00:16:45.179 --> 00:16:49.539
and release strategies you have to
go -- you have to jump through hoops.

00:16:49.539 --> 00:16:52.219
You have to put a lock in there, you've got to retain,

00:16:52.220 --> 00:16:55.170
auto release it from the getter, or
the setter's got to lock it down.

00:16:55.169 --> 00:16:58.789
And I don't each want to mention the threat of exceptions.

00:16:58.789 --> 00:17:02.879
That first release, that humble
release can call out to other releases.

00:17:02.879 --> 00:17:05.740
Because if that was the last release,
it could call arbitrary things.

00:17:05.740 --> 00:17:09.400
And one of them if it threw an
exception would leave that lock locked.

00:17:09.400 --> 00:17:11.380
It's -- difficult.

00:17:11.380 --> 00:17:18.070
What you mentally are trying to do when you write the
setter getter, that's mentally what you're writing, yeah?

00:17:18.069 --> 00:17:22.220
And that's exactly what you get
to write with garbage collection.

00:17:22.220 --> 00:17:30.759
Because we rely on the animosity of the assignment,
for one, and two, rely on the thread machine state

00:17:30.759 --> 00:17:34.299
and scanning the stacks to find
out where all the references are.

00:17:34.299 --> 00:17:41.079
So clearly in this kind of environment you get
simpler designs because -- I didn't mention it --

00:17:41.079 --> 00:17:43.699
but of course you get to have cycles that get recovered.

00:17:43.700 --> 00:17:46.900
You get simpler code because you
don't have all this locking and stuff,

00:17:46.900 --> 00:17:49.930
and concerns about things you never thought about.

00:17:49.930 --> 00:17:56.180
Except when, you know, 10,000 people use your code
and find a couple corner cases you didn't test for.

00:17:56.180 --> 00:18:00.590
You get safer code under garbage collection,
because no more dangling references

00:18:00.589 --> 00:18:03.699
if your, you know, if you do the new style.

00:18:03.700 --> 00:18:06.360
And of course you don't get classical memory leaks.

00:18:06.359 --> 00:18:09.089
I claim this leads to faster delivery.

00:18:09.089 --> 00:18:12.319
Faster program, easier to design.

00:18:12.319 --> 00:18:16.919
And another slide -- I'm not sure I put up last year.

00:18:16.920 --> 00:18:22.250
But we did some studies internally that show
that sometimes up to 10 percent of the CPU cost

00:18:22.250 --> 00:18:25.910
of your program is spent on retain and release.

00:18:25.910 --> 00:18:29.779
Because each call to retain and
release has to go through a lock.

00:18:29.779 --> 00:18:33.970
And on modern CPUs, lock don't get faster.

00:18:33.970 --> 00:18:37.059
They have to coordinate with the
other cores and off chip stuff.

00:18:37.059 --> 00:18:38.720
So locks don't get faster.

00:18:38.720 --> 00:18:41.160
So better to get away from them all together.

00:18:41.160 --> 00:18:44.500
And that's what GC helps you to do.

00:18:44.500 --> 00:18:45.779
How do you get access to it?

00:18:45.779 --> 00:18:46.460
It's very simple.

00:18:46.460 --> 00:18:48.870
You just click a check box.

00:18:48.869 --> 00:18:52.059
That tells the Compiler to do some search stuff.

00:18:52.059 --> 00:18:53.549
What does the runtime do?

00:18:53.549 --> 00:18:56.069
Well, we do a little bit more than that.

00:18:56.069 --> 00:18:57.960
So imagine this is the heap.

00:18:57.960 --> 00:19:00.360
Your GC heap of objects.

00:19:00.359 --> 00:19:07.329
So your heap of objects -- within the heap of objects,
your objects, of course, reference each other.

00:19:07.329 --> 00:19:14.079
Right? You've got global variables, which might
reference, you know, some of those heap objects.

00:19:14.079 --> 00:19:16.599
You've got locals on your stack.

00:19:16.599 --> 00:19:18.059
You may have allocated a string.

00:19:18.059 --> 00:19:22.470
And your stack frame is the only
thing that's referencing that string.

00:19:22.470 --> 00:19:27.930
You might actually have figured out a way to stuff
a pointer to an object into some malloc memory.

00:19:27.930 --> 00:19:31.360
Now I call these externals.

00:19:31.359 --> 00:19:35.309
The collector doesn't know where you stuck these things.

00:19:35.309 --> 00:19:37.389
But it does know you stuck them somewhere.

00:19:37.390 --> 00:19:42.030
But we keep track of the fact that
your objects have external references.

00:19:42.029 --> 00:19:46.129
And so your external references may
be the only thing referencing this.

00:19:46.130 --> 00:19:50.900
So when its time for a collection -- so what
I'm going to talk about is a full collection.

00:19:50.900 --> 00:19:54.530
This is the 1960's style garba`ge collection.

00:19:54.529 --> 00:19:58.740
What happens is -- I knew I was going to forget this.

00:19:58.740 --> 00:20:00.470
Not 1960s.

00:20:00.470 --> 00:20:06.220
In addition to strong references, I also
indicated with white arrows, weak references.

00:20:06.220 --> 00:20:08.240
Which I alluded to earlier.

00:20:08.240 --> 00:20:13.980
Again, a weak reference is a pointer to
an object that will not keep it alive.

00:20:13.980 --> 00:20:17.309
If that's the only, if that's the
last reference to an object,

00:20:17.309 --> 00:20:21.460
a weak reference will not keep it live,
and the collector will zero it out.

00:20:21.460 --> 00:20:27.319
So in this case I have indicated that you could have
a global that has a weak reference to an object,

00:20:27.319 --> 00:20:31.369
and then within objects they can
have weak references to each other.

00:20:31.369 --> 00:20:35.209
So when it's time to do a collection,
the collector starts with the roots.

00:20:35.210 --> 00:20:38.840
Which are those three things I talked about.

00:20:38.839 --> 00:20:43.480
Globals, locals on your stack and
things with external references.

00:20:43.480 --> 00:20:46.769
And it identifies them.

00:20:46.769 --> 00:20:49.629
It puts them into what we call a root set.

00:20:49.630 --> 00:20:50.660
And then reverse.

00:20:50.660 --> 00:20:53.769
We go what can I reach from these objects?

00:20:53.769 --> 00:20:57.410
And so we go through the entire
heap figuring out what's reachable.

00:20:57.410 --> 00:21:01.460
Anything we can't reach, we don't examine.

00:21:01.460 --> 00:21:02.400
We don't go through.

00:21:02.400 --> 00:21:03.960
We deem it garbage.

00:21:03.960 --> 00:21:09.769
So we pull it aside and well, that would
leave some dangling references, wouldn't it?

00:21:09.769 --> 00:21:16.609
So the first thing we do is zero out the weak
references to the things we think of as garbage.

00:21:16.609 --> 00:21:18.039
So they get zeroed out.

00:21:18.039 --> 00:21:23.619
A weak reference -- references something that's
still alive of course we don't zero it out.

00:21:23.619 --> 00:21:31.709
We send finalize to every object in that set of garbage
and we send it -- I don't know, probably in memory order.

00:21:31.710 --> 00:21:35.529
We don't send it to the top of some graph.

00:21:35.529 --> 00:21:39.579
I mean, this could be a cycle of things
are recovered and there is no top.

00:21:39.579 --> 00:21:45.629
We send finalized to each of the objects from
your viewpoint a non deterministic order.

00:21:45.630 --> 00:21:48.330
And then we reclaim the memory.

00:21:48.329 --> 00:21:53.689
I should say at this point that there's two things
I am not really going to talk about too much.

00:21:53.690 --> 00:21:58.230
And that is when we look at things on
the stack, when we look at your locals,

00:21:58.230 --> 00:22:01.700
we never stop all your threads at the same time.

00:22:01.700 --> 00:22:06.769
We peek at your threads, look through
everything they're referencing one at a time.

00:22:06.769 --> 00:22:08.970
We don't even stop them the first time.

00:22:08.970 --> 00:22:15.400
At the very end of GC when we're looked at
everything else, we will stop each thread briefly just

00:22:15.400 --> 00:22:17.480
to make sure we've seen everything on its stack.

00:22:17.480 --> 00:22:24.120
But otherwise while we're collecting we have
other ways of keeping track of graph changes.

00:22:24.119 --> 00:22:29.429
So -- that was fine.

00:22:29.430 --> 00:22:32.380
That was 1960's style.

00:22:32.380 --> 00:22:37.850
That led to machines that would freeze
for seconds at a time while GC occurred.

00:22:37.849 --> 00:22:47.019
In the '80s when Small Talk came into play, a new style of
collection came along called incremental and we love it.

00:22:47.019 --> 00:22:50.690
So the observation was most objects are temporary.

00:22:50.690 --> 00:22:55.610
As my friend Dave Unger (assumed spelling)
would say, most objects die young.

00:22:55.609 --> 00:22:58.799
He was -- he helped put that in Small Talk.

00:22:58.799 --> 00:23:05.809
So the idea is that you can recover only the
most recently allocated garbage much quicker.

00:23:05.809 --> 00:23:09.119
But only the most recently allocated garbage gets collected.

00:23:09.119 --> 00:23:10.229
But that's good.

00:23:10.230 --> 00:23:14.250
The scheme we have is, you know, fairly classic, actually.

00:23:14.250 --> 00:23:18.240
We keep track of the generational age of each object.

00:23:18.240 --> 00:23:27.339
We use something called a write barrier to say, when
you're storing pointers from one object into another, if --

00:23:27.339 --> 00:23:33.470
you know, we keep track of the
destinations for pointers to new objects.

00:23:33.470 --> 00:23:43.200
So we end up marking a sub set of the entire heap
as those potentially pointing to new -- new objects.

00:23:43.200 --> 00:23:47.220
So when we go through garbage collection
we actually only search for new stuff.

00:23:47.220 --> 00:23:50.559
Because that's the only stuff we want to
keep is the new stuff that's reachable.

00:23:50.559 --> 00:23:56.169
And the stuff that's not reachable
among the new is stuff we can reclaim.

00:23:56.170 --> 00:24:03.269
Anything that's -- that we did find
reachable we promote into an older generation.

00:24:03.269 --> 00:24:11.759
So we get to reclaim all the memory that all
of the new objects -- that is not reachable.

00:24:11.759 --> 00:24:14.990
So here's just a quick illustration.

00:24:14.990 --> 00:24:22.029
Again, we start out by -- we start out with this sub
sets of all old objects that have been stored into.

00:24:22.029 --> 00:24:25.559
The way we've been tracking with our write barriers.

00:24:25.559 --> 00:24:31.200
We take a look at all the same places we looked at before
because each of them might be pointing to a reference.

00:24:31.200 --> 00:24:38.289
But what we do is with that root
set we look at just the new objects.

00:24:38.289 --> 00:24:45.039
That's the only set of objects we're going to examine, and
we only look through them for pointers to other new things.

00:24:45.039 --> 00:24:49.009
In this diagram there's only one more object that's found.

00:24:49.009 --> 00:24:50.910
This really works.

00:24:50.910 --> 00:24:54.259
It turns out that this dramatically limits the recursion.

00:24:54.259 --> 00:24:56.539
We don't go sweeping through the whole graph.

00:24:56.539 --> 00:25:01.420
And so we get to pull that stuff off
and do the same things we do before.

00:25:01.420 --> 00:25:04.060
Zero the weak references and reclaim the memory.

00:25:04.059 --> 00:25:08.339
Again, this recovers 90 percent of the
garbage in 10 percent of the effort.

00:25:08.339 --> 00:25:10.029
It's great.

00:25:10.029 --> 00:25:11.609
So that's what the runtime does.

00:25:11.609 --> 00:25:17.569
It doesn't do it without some cooperation
from the language and from the Compiler.

00:25:17.569 --> 00:25:19.299
So let's talk about that.

00:25:19.299 --> 00:25:20.609
So GCC tricks.

00:25:20.609 --> 00:25:22.169
Write barriers.

00:25:22.170 --> 00:25:27.880
So if you have a class, a mumble class
with an I.D., it's got a property,

00:25:27.880 --> 00:25:30.310
and so you're going to have a setter and getter for it.

00:25:30.309 --> 00:25:33.819
So you write your setter and getter
just like I showed you before.

00:25:33.819 --> 00:25:36.460
There's no dealic (Phonetic) necessary, remember.

00:25:36.460 --> 00:25:44.110
What the Compiler does is when you assign the object it
actually substitutes -- rather than just load and store --

00:25:44.109 --> 00:25:47.359
it actually substitutes the assignment
with a helper routine.

00:25:47.359 --> 00:25:50.000
LBGC assign in I bar.

00:25:50.000 --> 00:25:52.329
Now, that's fine.

00:25:52.329 --> 00:25:54.480
That's a very fast routine.

00:25:54.480 --> 00:26:00.390
That helps us keep track of the --
the places that we stored things into.

00:26:00.390 --> 00:26:05.009
For those weak variables we actually
have language construct under weak.

00:26:05.009 --> 00:26:07.390
You can do this on objects.

00:26:07.390 --> 00:26:11.140
And you can have a setter and getter just as before.

00:26:11.140 --> 00:26:17.590
But in this case the Compiler also
puts in a read barrier on these.

00:26:17.589 --> 00:26:21.500
So it goes through a helper routine
to do reads as well as writes.

00:26:21.500 --> 00:26:25.710
So it's a different write barrier as well.

00:26:25.710 --> 00:26:33.299
Finally, if you want to extend garbage collection into
the C world, you use the (Inaudible) strong attribute.

00:26:33.299 --> 00:26:35.690
I'll be talking about both of these more later.

00:26:35.690 --> 00:26:36.940
But you can have a C string.

00:26:36.940 --> 00:26:38.470
It can be a property.

00:26:38.470 --> 00:26:42.190
And here I'll actually go ahead and show you.

00:26:42.190 --> 00:26:45.850
Rather than use malloc you call
the collector to get the memory.

00:26:45.849 --> 00:26:55.159
And in this case because the C string variable was marked
strong, the Compiler knows to do the right barrier also.

00:26:55.160 --> 00:27:03.320
So this is how this all works with objects and with C.
So to summarize, strong can be used almost anywhere.

00:27:03.319 --> 00:27:08.500
In particular, you know, global
variables, instance variables.

00:27:08.500 --> 00:27:09.900
Fields with structures.

00:27:09.900 --> 00:27:12.920
You can have a structure that has an object in it.

00:27:12.920 --> 00:27:16.660
And when you assign the object,
you're going to get a right barrier.

00:27:16.660 --> 00:27:18.850
It can have a strong mark care star (assumed spelling).

00:27:18.849 --> 00:27:22.199
When you do the assignment, it's
going to get a right barrier.

00:27:22.200 --> 00:27:26.220
The stack is sort of a special case for us.

00:27:26.220 --> 00:27:29.460
It's sort of -- everything in it
is sort of considered strong.

00:27:29.460 --> 00:27:30.279
Its conservative.

00:27:30.279 --> 00:27:31.569
The collector will look through it.

00:27:31.569 --> 00:27:37.000
And anything that looks like a pointer to an object we
will leave to be a pointer, even if it's not reachable.

00:27:37.000 --> 00:27:38.849
Even if it's just a bit pattern.

00:27:38.849 --> 00:27:42.659
You know, we'll keep stuff that referenced,
seems to be referenced from the stack.

00:27:42.660 --> 00:27:48.800
There's no write barriers involved in writing to the
stack, so it's just as high performance as it is now.

00:27:50.250 --> 00:27:51.710
That's about it for strong.

00:27:51.710 --> 00:27:54.960
For weak -- weak is a little more restricted.

00:27:54.960 --> 00:27:57.750
This also applies only to garbage collected objects.

00:27:57.750 --> 00:28:01.400
Clearly the big benefit is we zero the
pointer out when the data goes away.

00:28:01.400 --> 00:28:07.600
It is restricted to instance variables
of an object and to globals.

00:28:07.599 --> 00:28:14.189
And this is -- we need to know when that thing goes away
in order to unregister it from the weak reference system.

00:28:14.190 --> 00:28:18.000
So you can use weak on C pointers
if they're an instance variable.

00:28:18.000 --> 00:28:21.849
So you can have a weak care star something or other.

00:28:21.849 --> 00:28:23.959
I will say that they're moderately expensive.

00:28:23.960 --> 00:28:28.110
They take extra storage and extra CPU to maintain them.

00:28:28.109 --> 00:28:32.859
So in general, you don't need a lot of weak references.

00:28:32.859 --> 00:28:35.039
Don't sprinkle them willy nilly.

00:28:35.039 --> 00:28:36.470
Use them judiciously.

00:28:36.470 --> 00:28:38.339
They are very good.

00:28:39.609 --> 00:28:43.369
So for example, you might have a while In Use singleton.

00:28:43.369 --> 00:28:46.799
That would be a great place to have
a weak global pointing to something.

00:28:46.799 --> 00:28:53.460
You know, when your last customer of it stops using
it, the collector will go ahead and get rid of it.

00:28:53.460 --> 00:28:55.420
But while it's there you can read it.

00:28:55.420 --> 00:28:57.380
And if it's there, use it.

00:28:57.380 --> 00:29:02.850
So I'll talk about globally reachable
stuff a little bit later.

00:29:02.849 --> 00:29:04.379
Properties.

00:29:04.380 --> 00:29:06.680
We redesign properties since the last WWDC.

00:29:06.680 --> 00:29:12.960
And as you heard from Patrick on
Wednesday, we made things very orthogonally.

00:29:12.960 --> 00:29:26.250
We made the -- we made the ownership orthogonal
to animosity, orthogonal to the naming and place.

00:29:26.250 --> 00:29:29.400
The biggest change, two big changes that we did,

00:29:29.400 --> 00:29:33.750
we separated out the interface
specification from implementation.

00:29:33.750 --> 00:29:39.380
One of the other things we did, we separated
out GC behavior from retain release behavior.

00:29:39.380 --> 00:29:45.550
And so with properties what you do as you saw in
the example before is use the language component.

00:29:45.549 --> 00:29:52.639
The strong and weak storage specifiers to say
that you have a garbage collected property.

00:29:54.170 --> 00:29:59.289
Atomic behavior is almost free under
garbage collection because we're looking

00:29:59.289 --> 00:30:02.799
at the machine registers and at the stack directly.

00:30:02.799 --> 00:30:07.700
Under non GC atomic behavior is not free.

00:30:07.700 --> 00:30:16.680
Atomic -- as we look forward we think that more and
more programs will be GC, and atomic will be free,

00:30:16.680 --> 00:30:19.930
and that atomic is the way to think about properties.

00:30:19.930 --> 00:30:24.060
And so we're kind of trying to, you
know, ride the wave here a little bit.

00:30:24.059 --> 00:30:30.460
But under non GC, atomic ends up being
expensive, the code synthesized by the runtime.

00:30:30.460 --> 00:30:32.460
Will do all the right things.

00:30:32.460 --> 00:30:38.200
And we've introduced as you've heard from Patrick
the non atomic keyword to kind of -- to trump it.

00:30:38.200 --> 00:30:43.750
To say if you know that you're not going to be using
this more multiple threads then you can get rid

00:30:43.750 --> 00:30:47.319
of that performance issue under non GC.

00:30:47.319 --> 00:30:52.319
The assign property is sort of
our finesse, it's the default.

00:30:52.319 --> 00:30:56.169
It says that a -- a delegate -- it's a delegate style.

00:30:56.170 --> 00:31:01.230
Under non GC we always want the delegates
to hold on to their memory you know,

00:31:01.230 --> 00:31:04.380
because it's an object and you need its delegate around.

00:31:04.380 --> 00:31:07.230
But we couldn't figure out how to deal with the cycles.

00:31:07.230 --> 00:31:09.640
So we made all delegates non retained.

00:31:09.640 --> 00:31:12.530
Well, under garbage collection delegates now are strong.

00:31:12.529 --> 00:31:16.910
They will hold on to their helper objects.

00:31:16.910 --> 00:31:22.870
So. As I said, At Synthesize, generates the collect locking.

00:31:22.869 --> 00:31:24.009
Code under non GC.

00:31:24.009 --> 00:31:32.220
We actually steal a built from the slot where you
hold that pointer to make -- and that is the lock.

00:31:32.220 --> 00:31:40.210
And direct access to that instance
variable under non GC -- is not encouraged.

00:31:42.559 --> 00:31:48.529
Having said that, if you build applications,
your applications or frameworks --

00:31:48.529 --> 00:31:55.210
if you know they're GC, you can compile
them with a dash GC only Compiler flag.

00:31:55.210 --> 00:31:59.210
And the Compiler will generate more efficient code.

00:31:59.210 --> 00:32:03.390
It will not call down to a helper thing in many cases.

00:32:03.390 --> 00:32:07.650
And so you will just get the direct metal that you expect.

00:32:07.650 --> 00:32:11.780
So keep track of that if you are
absolutely building only GC code.

00:32:11.779 --> 00:32:14.720
We don't have a check box for that, we probably should.

00:32:14.720 --> 00:32:23.160
So in summary, strong and weak are used for sealable
stuff, properties respect that sealable stuff.

00:32:23.160 --> 00:32:31.779
And we have the dash FOBJC flag is what
you get from that check box in Xcode.

00:32:31.779 --> 00:32:34.059
GC only gets you faster code.

00:32:34.059 --> 00:32:42.240
And for debugging, the dash W assign Intersept can be used
to help track where all the right barriers get issued

00:32:42.240 --> 00:32:48.660
in case you're a little untrusting of the Compiler.

00:32:48.660 --> 00:32:51.350
So let's talk about what you can do.

00:32:51.349 --> 00:32:53.299
That was sort of what we do for you.

00:32:53.299 --> 00:32:55.809
This is what you do for yourself.

00:32:55.809 --> 00:32:56.649
So the big five.

00:32:56.650 --> 00:33:04.670
When you're designing programs for garbage
collection, you have to remember these five things.

00:33:04.670 --> 00:33:08.380
All this old stuff, these five
methods are literally ignored.

00:33:08.380 --> 00:33:10.070
They're short circuited in the messenger.

00:33:10.069 --> 00:33:16.419
You will never see a line of code ever
executed in a body of any of these methods.

00:33:16.420 --> 00:33:21.300
Try it. It won't happen.

00:33:21.299 --> 00:33:30.779
However, CF retain and CF release, for you savvy toll-free
bridge types, are still honored just as they were before.

00:33:30.779 --> 00:33:35.910
So a CF retain will disable that
object from being collected.

00:33:35.910 --> 00:33:39.040
It will disable the collector for that object.

00:33:39.039 --> 00:33:44.079
And so CF retain and CF release will
hang on to objects, you know, outside --

00:33:44.079 --> 00:33:46.329
will make them inaccessible to the collector.

00:33:46.329 --> 00:33:51.579
So this is a bit of breaking, you know,
or modifying that toll-free bridge story.

00:33:51.579 --> 00:33:56.730
If you're used to doing CF create
strings and then auto release them,

00:33:56.730 --> 00:33:59.210
well you're going to have to take
a look at some of that code.

00:33:59.210 --> 00:34:01.350
You have to clean it up.

00:34:01.349 --> 00:34:07.259
So you cannot store GC pointers
just trivially in the malloc memory.

00:34:07.259 --> 00:34:09.710
Now before you could sort of allocate them.

00:34:09.710 --> 00:34:13.050
Or you could retain them and then
stick them in malloc memory.

00:34:13.050 --> 00:34:16.310
So that was, you know, I say that was non trivial.

00:34:16.309 --> 00:34:19.750
That you had to know that it was
a retained reference in there

00:34:19.750 --> 00:34:24.300
So there is a very simple thing you
can do under GC to make this happen.

00:34:24.300 --> 00:34:26.880
I also say void star here.

00:34:26.880 --> 00:34:32.980
We're teaching the Compiler exactly
where inside objects the pointers are.

00:34:32.980 --> 00:34:34.369
The pointers are to other objects.

00:34:34.369 --> 00:34:37.619
If you have a void star pointer, we're going to ignore it.

00:34:37.619 --> 00:34:44.880
So if you try to stuff an object I.D. into a void star,
the Compiler -- not in the Leopard seed you have now,

00:34:44.880 --> 00:34:48.920
but by of the time we ship that
will not keep your pointer alive.

00:34:48.920 --> 00:34:51.059
Unless it's marked strong.

00:34:51.059 --> 00:34:53.929
Unless you're deliberately trying to do a GC thing.

00:34:53.929 --> 00:34:56.799
So you have to be a lot more --
you have to be a little more honest

00:34:56.800 --> 00:35:00.500
with your declarations in other words to keep GC working.

00:35:02.190 --> 00:35:06.610
So the things you store into there,
unless it's marked strong, have to be --

00:35:06.610 --> 00:35:09.670
the collector needs to be told about that.

00:35:09.670 --> 00:35:15.170
So that no resurrection thing -- how many people
here have like, you know, recoded release to say,

00:35:15.170 --> 00:35:19.139
if rough count equals one go do some magic stuff.

00:35:19.139 --> 00:35:20.969
Well, you don't kind of get to do that.

00:35:20.969 --> 00:35:26.779
How many of you have written plus Alix to kind of
say oh, do I have a cache of objects somewhere.

00:35:26.780 --> 00:35:28.300
You know, bypass the allocators.

00:35:28.300 --> 00:35:34.830
Right. So some of these techniques are not techniques
that are going to work under garbage collection.

00:35:34.829 --> 00:35:38.900
You're going to have to find new
techniques for some of these things.

00:35:38.900 --> 00:35:44.180
The good news is you back pointers, cycles, are now okay.

00:35:44.179 --> 00:35:50.389
And this dramatically simplify your
thinking about certain types of programs.

00:35:50.389 --> 00:35:55.549
And we think that this will, you know,
simplify your design process as well.

00:35:55.550 --> 00:35:59.190
So under non GC back pointers are non retained.

00:35:59.190 --> 00:36:03.269
Under GC they generally become
strong, but that's generally okay.

00:36:03.269 --> 00:36:09.550
The only time that you kind of get in trouble
is if you have this cycle or this mess

00:36:09.550 --> 00:36:11.360
and there's some kind of a global pointer.

00:36:11.360 --> 00:36:13.789
You know, a pointer to a table that references something.

00:36:13.789 --> 00:36:19.340
In that case, that global pointer to your
cycle is going to keep the whole cycle alive.

00:36:19.340 --> 00:36:25.700
So in some cases where you've had back pointers --
especially that are referenced from global table --

00:36:25.699 --> 00:36:29.819
that's where you want to use the zero to weak storage.

00:36:29.820 --> 00:36:34.590
So it will break that cycle and get
the things go away that you want to.

00:36:34.590 --> 00:36:36.670
Finally, the fifth thing.

00:36:36.670 --> 00:36:43.079
Finalize sort of fits in the place of dealloc,
but it's really a completely different beast.

00:36:43.079 --> 00:36:44.809
I claim it's evil.

00:36:44.809 --> 00:36:46.369
Necessary, but evil.

00:36:46.369 --> 00:36:49.940
So let's talk about finalize.

00:36:49.940 --> 00:36:55.539
So as I said before, finalize is called in an
arbitrary order with respect to other garbage.

00:36:55.539 --> 00:37:01.429
In a retain release world, if you're
the owner of this sub graph, you own --

00:37:01.429 --> 00:37:05.690
you get called first, and then you can let
go of your children and then you can --

00:37:05.690 --> 00:37:08.480
you can specify sort of the ordering often.

00:37:08.480 --> 00:37:10.500
Not always, and that's a problem.

00:37:10.500 --> 00:37:13.050
But it's completely random under garbage collection.

00:37:13.050 --> 00:37:22.280
So when you're in a finalize -- if you run a finalize, you
should never ask another object to do something meaningful.

00:37:22.280 --> 00:37:27.430
Because that other object may already have been
finalized and can't do anything meaningful.

00:37:27.429 --> 00:37:32.659
However, you know, if you didn't write all the code
in your system, some other object might be trying

00:37:32.659 --> 00:37:36.210
to call you even after your finalize has been done.

00:37:36.210 --> 00:37:39.920
And so it can be just really a big headache.

00:37:39.920 --> 00:37:45.000
So the idea is try not to use finalizes.

00:37:45.000 --> 00:37:53.000
In particular, memory management -- try not to
piggyback resource reclaimation with memory management.

00:37:53.000 --> 00:37:55.429
That's very tempting under a retain release world.

00:37:55.429 --> 00:37:58.799
But in a garbage collection world,
that really just doesn't work.

00:37:58.800 --> 00:38:03.670
Don't close file distributors, don't close down
your network, don't delete files -- don't --

00:38:03.670 --> 00:38:09.659
I mean there's all kinds of things you can try to do in your
finalize that are just going to come at an arbitrary time

00:38:09.659 --> 00:38:14.929
in respect to the rest of your
application and it's just not a good idea.

00:38:14.929 --> 00:38:19.759
The best thing to do in new applications,
of course, is to design a good-bye kiss.

00:38:19.760 --> 00:38:22.750
Design a close or a stop or something.

00:38:22.750 --> 00:38:28.110
Such that you know when your object, when people
are going to stop using it for things important.

00:38:28.110 --> 00:38:33.820
Stop playing that movie, you know, stop
loading that URL or whatever you're doing.

00:38:35.949 --> 00:38:38.109
So bottom line.

00:38:38.110 --> 00:38:39.900
Avoid finalize.

00:38:39.900 --> 00:38:42.840
It's very different than dealloc.

00:38:42.840 --> 00:38:48.140
So let's go through some deallocs for example,
though, because you know, we code them a lot, right?

00:38:48.139 --> 00:38:51.460
So here's a not a typical dealloc.

00:38:51.460 --> 00:38:56.630
When we went in and looked at the App Kit and the
foundation and stuff we saw these huge deallocs

00:38:56.630 --> 00:39:00.480
and so -- well, you know, they're necessary.

00:39:00.480 --> 00:39:04.719
So you have to get rid of instance variables that you own.

00:39:04.719 --> 00:39:07.529
You have to get rid of your notification center stuff.

00:39:07.530 --> 00:39:13.160
You have to -- sometimes you have these really
complex graphs and you've got to go tell him

00:39:13.159 --> 00:39:15.139
to let go of you, and then you can let go of him.

00:39:15.139 --> 00:39:18.449
Because if you let go of him first
will they still point it to you.

00:39:18.449 --> 00:39:20.379
And I call this the dealloc dance.

00:39:20.380 --> 00:39:25.010
If you're written a complex system you've seen this.

00:39:25.010 --> 00:39:27.590
Decal o occasion can be really tricky.

00:39:27.590 --> 00:39:30.600
So you have this little dance step that you do here.

00:39:30.599 --> 00:39:35.860
If you've got a core foundation object kind of thing,
well -- oh, I forgot to put the "if" check in there.

00:39:35.860 --> 00:39:37.160
Oh no. Not this one.

00:39:37.159 --> 00:39:38.679
I have it in the next one.

00:39:38.679 --> 00:39:47.839
If you have perhaps a weak cache -- maybe you have a very
complex object, and you put it in a set or a dictionary

00:39:47.840 --> 00:39:51.600
such that when the next client comes along
you can say, oh do I already have one.

00:39:51.599 --> 00:39:53.889
And if I do I better hand it out.

00:39:53.889 --> 00:39:58.920
Well, that weak cache is a global table
and you need to clean yourself out of that,

00:39:58.920 --> 00:40:01.539
otherwise it will have, you know, a dangling reference.

00:40:01.539 --> 00:40:05.110
If you've got a CF object, you need to CF release it.

00:40:05.110 --> 00:40:08.559
If you're got your own malloc memory,
you need to get rid of it.

00:40:08.559 --> 00:40:13.549
So -- and we have seen people to
forget to call superdealloc.

00:40:13.550 --> 00:40:18.940
So much so we put a warning in the
Compiler if you don't put a superdealloc in.

00:40:20.219 --> 00:40:26.730
But let's just say for grins you copied
over dealloc and called it a finalize.

00:40:26.730 --> 00:40:30.630
That sort of sometimes halfway works.

00:40:30.630 --> 00:40:32.519
But it's not a good idea.

00:40:32.519 --> 00:40:33.489
So let's go through this.

00:40:33.489 --> 00:40:37.349
What do we need in here for our finalize issue for real?

00:40:37.349 --> 00:40:39.039
So as I said before.

00:40:39.039 --> 00:40:40.559
The sub graph tear down.

00:40:40.559 --> 00:40:43.340
You need to trust the collector.

00:40:43.340 --> 00:40:46.640
We're going to collect everything that's reachable.

00:40:46.639 --> 00:40:49.269
So releases do absolutely nothing.

00:40:49.269 --> 00:40:53.789
We fixed up the notification center such that
it zeros out references to it automatically.

00:40:53.789 --> 00:40:55.969
So that code's not necessary.

00:40:55.969 --> 00:41:04.250
If the do-hicky object has a pointer to you,
then it's dead at the same time you are.

00:41:04.250 --> 00:41:07.829
You will not be in a finalize method
if do-hicky is referencing you.

00:41:07.829 --> 00:41:09.539
Unless do-hicky is dead as well.

00:41:09.539 --> 00:41:12.190
So that's sort of an induction case here.

00:41:12.190 --> 00:41:15.710
So you don't need to clean up do-hicky.

00:41:15.710 --> 00:41:20.220
So that leaves us with a much smaller finalized method.

00:41:20.219 --> 00:41:23.480
So let's take a look at that weak cache.

00:41:23.480 --> 00:41:27.300
Well, that's how it got constructed.

00:41:27.300 --> 00:41:33.820
There's a weak settle or a non retained
nil, nil argument set out there.

00:41:33.820 --> 00:41:36.400
And your object got added to it.

00:41:36.400 --> 00:41:38.970
Well there's a big problem with this.

00:41:38.969 --> 00:41:47.399
Because if it's a global -- if it's a global
variable then the collector might have figured

00:41:47.400 --> 00:41:55.769
out that this object is dead and then some other thread
comes in and looks into that cache and revives it.

00:41:55.769 --> 00:41:58.139
But the collector thinks its dead, but it got revived.

00:41:58.139 --> 00:42:02.960
And you can actually end up in
cases where your object, you know,

00:42:02.960 --> 00:42:07.019
because you revived it when the collector thinks its dead.

00:42:07.019 --> 00:42:15.019
So the right thing to do here is to use our new weak
mapping tables of the so hash table is in fact a weak set.

00:42:15.019 --> 00:42:21.050
And with that API you don't need to do
any clean up in your finalized method.

00:42:21.050 --> 00:42:22.860
Pretty good.

00:42:22.860 --> 00:42:27.349
So now we're down to two things.

00:42:27.349 --> 00:42:30.900
So let's say you have a CF reference
of some kind of Core graphics thing.

00:42:30.900 --> 00:42:35.309
So again, you have some whacky create something or other.

00:42:35.309 --> 00:42:38.900
And you've got to release it later on.

00:42:38.900 --> 00:42:45.110
So actually it turns out that you can CF
release it as soon as you allocate it.

00:42:45.110 --> 00:42:49.450
When you CF release it, it turns out that
we actually don't go and collect the memory.

00:42:49.449 --> 00:42:50.309
We don't do anything.

00:42:50.309 --> 00:42:54.049
We let the collector decide when its done.

00:42:54.050 --> 00:42:58.269
Now some people might look at that
code and go -- that's whacky.

00:42:58.269 --> 00:43:02.500
So -- in fact we've invented a little bit of API.

00:43:02.500 --> 00:43:05.340
It's called CF make collectable.

00:43:05.340 --> 00:43:08.809
But under the covers it actually is doing that CF release.

00:43:08.809 --> 00:43:14.949
If we're garbage collected, we're
doing a CF release if you want.

00:43:14.949 --> 00:43:17.669
But we recommend using CF make collectable.

00:43:17.670 --> 00:43:19.579
It kind of makes more semantic sense.

00:43:19.579 --> 00:43:24.989
But if you do either one of those you clearly
don't have to do the CF release in your finalize.

00:43:24.989 --> 00:43:28.189
And so that makes life simpler.

00:43:28.190 --> 00:43:34.639
As you saw before, if you have some malloc memory
you can convert it over to be garbage collected.

00:43:34.639 --> 00:43:36.009
It's very simple.

00:43:36.010 --> 00:43:37.320
One for one substitution.

00:43:37.320 --> 00:43:40.480
You can get rid of that as well.

00:43:40.480 --> 00:43:46.710
Finally, well, we don't need that finalize method, do we?

00:43:46.710 --> 00:43:50.119
So that simplifies your programming.

00:43:50.119 --> 00:43:52.769
You don't have to worry about tear down.

00:43:52.769 --> 00:43:57.579
That's -- that's something you get to
eventually and it can cause you headaches.

00:43:57.579 --> 00:44:01.360
So let me talk a little bit more
about some of that API I mentioned.

00:44:01.360 --> 00:44:05.740
So in foundation, as of Tiger,
actually, we added a finalized method

00:44:05.739 --> 00:44:07.899
and we added drain to the auto release pool.

00:44:07.900 --> 00:44:12.039
Drain -- I'll show you what drain does in just a moment.

00:44:12.039 --> 00:44:18.529
In Leopard we added in a garbage collector object
and the weak collection classes to foundation.

00:44:18.530 --> 00:44:21.410
So the garbage collector object is very simple.

00:44:21.409 --> 00:44:24.309
I'm only going to talk about the first clump of methods.

00:44:24.309 --> 00:44:29.500
But a vault collector is how you get a hold of the
collector for the few things it knows how to do.

00:44:29.500 --> 00:44:32.860
Under non GC you return nil.

00:44:32.860 --> 00:44:39.450
Okay. So collect needed and collect exhaustively
are our ways to let you tell the collector, hey,

00:44:39.449 --> 00:44:42.599
I know I just finished allocating a lot of stuff.

00:44:42.599 --> 00:44:44.969
I'm done with this operation.

00:44:44.969 --> 00:44:46.319
Go collect if you can.

00:44:46.320 --> 00:44:49.210
I mean, we're not above living to hints.

00:44:49.210 --> 00:44:51.010
So go ahead and hint us.

00:44:51.010 --> 00:44:52.430
Collect if needed.

00:44:52.429 --> 00:44:54.279
Use it freely.

00:44:54.280 --> 00:44:58.590
Because we're not just going to
go collect unless it's needed.

00:44:58.590 --> 00:45:05.350
On the other hand, if you really do know that you are
really done, you're about ready to go to sleep or something.

00:45:05.349 --> 00:45:10.559
Collect exhaustively tells us to ring
every last little bite out of the system.

00:45:10.559 --> 00:45:13.829
And we'll go and we'll really crunch
and you'll get back stuff.

00:45:14.869 --> 00:45:16.940
Disable collector from pointer.

00:45:16.940 --> 00:45:19.170
Enable collector -- I kind of mentioned those before.

00:45:19.170 --> 00:45:22.840
That kind of says for this piece of memory don't collect it.

00:45:22.840 --> 00:45:26.300
I will tell you a little bit more about those.

00:45:26.300 --> 00:45:32.580
So as I said earlier, CF retain, CF release,
you know, we'll really hang on to your object.

00:45:32.579 --> 00:45:34.719
Under the tables they're really just doing that.

00:45:34.719 --> 00:45:37.809
They're really just telling the collector don't do that.

00:45:37.809 --> 00:45:45.210
Don't, you know -- so CF retain is sort of a quicky
way of saying disable the collector for this object.

00:45:45.210 --> 00:45:47.289
Disable collector takes a void star.

00:45:47.289 --> 00:45:49.279
So you can use it on arbitrary memory.

00:45:49.280 --> 00:45:55.470
Whereas obviously CF retain can
only be done on -- on objects.

00:45:55.469 --> 00:45:57.649
The weak pointer classes.

00:45:57.650 --> 00:46:01.599
You know, API -- there's too much API in the world.

00:46:01.599 --> 00:46:04.579
Aren't there enough collections already, you might ask.

00:46:04.579 --> 00:46:07.750
Well, we thought long and hard about this.

00:46:07.750 --> 00:46:11.590
NS array, NS set, NS dictionary
has very rigorous definitions.

00:46:11.590 --> 00:46:14.210
There's lot of code that's been built on top of it.

00:46:14.210 --> 00:46:17.240
They can be turned into property lists,
they can be archived, they can be --

00:46:17.239 --> 00:46:19.149
there's just lots of stuff that's done to them.

00:46:19.150 --> 00:46:24.769
And one thing that can't be done to
them is you can't store nils in them.

00:46:24.769 --> 00:46:29.269
So what would happen in a collector came
in and zeroed out some of their elements.

00:46:29.269 --> 00:46:32.340
Well, arrays would have nulls in them.

00:46:32.340 --> 00:46:34.750
And sets, you might ask it for its count

00:46:34.750 --> 00:46:40.670
and then two milliseconds later some stuff would
be zeroed out and count wouldn't work any more.

00:46:40.670 --> 00:46:43.420
I mean, we thought long and hard about it.

00:46:43.420 --> 00:46:47.230
But we said that, you know, it's just not the same.

00:46:47.230 --> 00:46:53.190
And even if we tried sub classing them, they
wouldn't have the same behaviors of the superclass.

00:46:53.190 --> 00:46:55.400
So we said we can't do that.

00:46:55.400 --> 00:46:56.530
We had CF array.

00:46:56.530 --> 00:46:58.710
CF set, CF dictionary.

00:46:58.710 --> 00:47:00.840
And they were a lot more reliable.

00:47:00.840 --> 00:47:04.110
But they're also very complex already.

00:47:04.110 --> 00:47:09.240
And they have when I looked at the code
what I call an indifferent backing store.

00:47:09.239 --> 00:47:13.269
You know, these things have to have
real memory to stuff your pointers into.

00:47:13.269 --> 00:47:16.480
But under garbage collection, we need to own that memory.

00:47:16.480 --> 00:47:21.400
I mean, we need to have a writer barrier whenever
you store something into a CF set or whatever.

00:47:21.400 --> 00:47:25.720
If it's weak we have to not only
have a different write barrier,

00:47:25.719 --> 00:47:29.099
we also have to have a read barrier when you get stuff out.

00:47:29.099 --> 00:47:34.069
And if you think about it, if you build a
hash table it often has a collision block

00:47:34.070 --> 00:47:36.840
where you know, you collide on the hash slot.

00:47:36.840 --> 00:47:39.820
Well, if one of those hash slots goes to zero, well,

00:47:39.820 --> 00:47:43.990
that kind of breaks your whole hashing,
you know, assumptions and stuff.

00:47:43.989 --> 00:47:46.989
So -- the algorithms change also.

00:47:46.989 --> 00:47:52.129
And for a lot of these reasons we
said we have to have some new stuff.

00:47:52.130 --> 00:47:56.920
Well, turns out there already was some stuff
laying around in our system kind of unused.

00:47:56.920 --> 00:47:59.829
And that was NS hash table and NS map table.

00:47:59.829 --> 00:48:06.630
Now these are really old preceded
-- I don't even want to tell you.

00:48:06.630 --> 00:48:09.289
They're really ugly too.

00:48:09.289 --> 00:48:11.300
You have the CAPI to create them.

00:48:11.300 --> 00:48:14.980
You have this set of call back structures.

00:48:14.980 --> 00:48:22.659
And these are the -- there's three different type
of call backs and this is the set of call backs

00:48:22.659 --> 00:48:26.670
that are predefined for you for the key part of a map table.

00:48:26.670 --> 00:48:28.789
There's a different set for the values.

00:48:28.789 --> 00:48:34.000
And there's a different set for the hash table
keys, even though they're exactly the same.

00:48:34.000 --> 00:48:41.710
So if your use matches what one of those
things is, then you're in pretty good shape.

00:48:41.710 --> 00:48:46.389
If you're not, you have to go create
one of these structures yourself.

00:48:46.389 --> 00:48:52.029
And you have to override the equal function to do
the right thing or the retain function or something.

00:48:52.030 --> 00:48:55.690
I mean, this is kind of the way CF stuff is organized,

00:48:55.690 --> 00:49:02.000
except I don't know too many people
that really fill those structures out.

00:49:02.000 --> 00:49:04.260
So here we've got the value callbacks.

00:49:04.260 --> 00:49:07.570
And they have funky CAPIs also.

00:49:07.570 --> 00:49:10.870
Three different ways to insert things into a map table.

00:49:10.869 --> 00:49:12.239
And look at the bottom two.

00:49:12.239 --> 00:49:17.309
To enumerate them you kind of have this
structure you declare on the stack.

00:49:17.309 --> 00:49:20.909
And you have to have an explicit end of the enumeration.

00:49:20.909 --> 00:49:25.119
And I didn't show you the one -- it's very funky stuff.

00:49:25.119 --> 00:49:28.359
So the plan -- let me back up.

00:49:28.360 --> 00:49:31.680
Note the structure part.

00:49:31.679 --> 00:49:33.109
Type up struct.

00:49:33.110 --> 00:49:35.610
So these are opaque structures.

00:49:35.610 --> 00:49:37.269
And we seized on that.

00:49:37.269 --> 00:49:42.539
And what we did was he said let's
turn those structures into objects.

00:49:42.539 --> 00:49:46.360
So hash table, map table become objects.

00:49:46.360 --> 00:49:52.849
We preserve all the old API and implementation
unchanged because we don't want to touch that stuff.

00:49:52.849 --> 00:49:58.929
But we can create objects out of this
stuff and make a few little changes.

00:49:58.929 --> 00:50:01.759
So we upgrade them to objects.

00:50:01.760 --> 00:50:05.060
Hash table becomes very much like a mutable set.

00:50:05.059 --> 00:50:07.289
Map table becomes very much like a dictionary.

00:50:07.289 --> 00:50:09.009
So you have set object for key and stuff.

00:50:09.010 --> 00:50:12.370
So now you have weak sets and weak
dictionaries by a different name.

00:50:12.369 --> 00:50:15.130
NS hash table and NS map table.

00:50:15.130 --> 00:50:18.320
So the old API works on the new tables.

00:50:18.320 --> 00:50:22.260
And the new API works on the old tables.

00:50:22.260 --> 00:50:23.810
So you can sort of mix and match.

00:50:23.809 --> 00:50:25.549
These are hash tables, after all.

00:50:25.550 --> 00:50:28.530
And they sort of inter operate.

00:50:28.530 --> 00:50:30.260
The new APIs are geared towards objects.

00:50:30.260 --> 00:50:34.600
We figured that's most of what you
guys are going to be wanting to use.

00:50:34.599 --> 00:50:37.339
So we now have three new collection classes.

00:50:37.340 --> 00:50:43.010
We have hash table, map table,
and oh yeah -- we need a raise.

00:50:43.010 --> 00:50:45.310
So we invented this thing called a pointer array.

00:50:45.309 --> 00:50:53.110
And unlike any other foundation class it's got
an explicit count, and that count includes nulls.

00:50:53.110 --> 00:50:59.260
So it's the only foundation class that I know of that
you can stuff a null into directly and it will stick.

00:50:59.260 --> 00:51:01.660
So it's not quite an array.

00:51:02.719 --> 00:51:11.250
You can, of course, have your objects strongly retained that
are non GC, it's retained -- under GC it's simply strong.

00:51:11.250 --> 00:51:12.170
They can be weak.

00:51:12.170 --> 00:51:16.670
Zeroing weak under GC or non retained.

00:51:16.670 --> 00:51:19.780
You can have them be object personality.

00:51:19.780 --> 00:51:24.820
That's what they are by deaf fault meaning we
send a hash message and then an is equal message.

00:51:24.820 --> 00:51:26.840
But often you know that they're pointers.

00:51:26.840 --> 00:51:30.870
You can just do pointer equivalent
on this stuff, and that works also.

00:51:30.869 --> 00:51:35.279
You can copy in the elements as you insert stuff.

00:51:35.280 --> 00:51:37.200
We found that was kind of useful.

00:51:37.199 --> 00:51:39.529
That's what dictionaries do to their keys.

00:51:39.530 --> 00:51:43.710
But we can do it on values on the map tables
if you want, or the arrays or the other stuff.

00:51:43.710 --> 00:51:48.920
And finally, since they're objects they conform
to three of the usually protocols, copying,

00:51:48.920 --> 00:51:54.010
coding for archiving, and the new one, Fast Enumeration.

00:51:54.010 --> 00:51:57.480
So let me elaborate a little bit
on the zeroing weak behavior.

00:51:57.480 --> 00:52:01.269
So imagine that these white pointers
are all pointers of weak references.

00:52:01.269 --> 00:52:06.070
So when a collection comes along,
of course, they get zeroed out.

00:52:06.070 --> 00:52:09.500
Well that kind of leaves a problem for the map table case.

00:52:09.500 --> 00:52:18.360
And they might have, you know, a non-zeroed key in
a zero value or a zeroed key in a zero value and --

00:52:18.360 --> 00:52:22.559
we put a few more tricks in there such
that the key, the corresponding slots

00:52:22.559 --> 00:52:27.049
in the map table also get cleaned
out, so it's a self cleaning table.

00:52:27.050 --> 00:52:29.430
You have no maintenance of it whatever.

00:52:29.429 --> 00:52:37.190
If it stops, if it goes to zero then we'll take away all
the memory for it, and it recovers very, very nicely.

00:52:37.190 --> 00:52:41.809
So let me give you three examples of how we cook these up.

00:52:41.809 --> 00:52:48.840
So weak keys to strong values is -- we have the
three interesting combinations as conveniences.

00:52:48.840 --> 00:52:52.100
If you want to build a dictionary
style you pass in some options.

00:52:52.099 --> 00:52:54.839
The copy in option for the key.

00:52:54.840 --> 00:53:03.130
If you want to have point -- pointers for the keys and
copy in the values -- just set them up with some options.

00:53:03.130 --> 00:53:05.769
Very convenient.

00:53:05.769 --> 00:53:08.280
But if that were it, I wouldn't be content.

00:53:08.280 --> 00:53:11.130
I think I told you mostly about
this stuff last year at WWDC.

00:53:11.130 --> 00:53:14.410
Since then we've added some more.

00:53:14.409 --> 00:53:21.710
It turns out that we can configure these hash tables
and map tables with regular void start stuff as well.

00:53:21.710 --> 00:53:26.510
So we have this sort of euphoria object
with lots of really cool options.

00:53:26.510 --> 00:53:30.320
It's an At Property style set of function pointers.

00:53:30.320 --> 00:53:35.289
And so you can use dot syntax to set up
them if you have really custom stuff.

00:53:35.289 --> 00:53:39.940
But for the most part we split the
functions into two personalities.

00:53:39.940 --> 00:53:43.760
There's the personality functions
that say what kind of a thing is it.

00:53:43.760 --> 00:53:47.590
Like a string or an integer, or a structure.

00:53:47.590 --> 00:53:49.260
And we have sort of a memory option.

00:53:49.260 --> 00:53:50.630
What kind of memory do you store that?

00:53:50.630 --> 00:53:56.450
Is it GC strong memory, is it zeroing and weak,
is it malloc memory, is it Mac virtual memory.

00:53:56.449 --> 00:54:04.409
And so the cross product including copy in leads you to
like 35 different configurations that are interested.

00:54:04.409 --> 00:54:10.329
Out of the bat -- just uses those
little -- using the options.

00:54:10.329 --> 00:54:17.699
And you can reuse those options directly with map
table and hash table to get set them up automatically.

00:54:17.699 --> 00:54:19.359
So it's very cool.

00:54:19.360 --> 00:54:22.400
Obviously they work under GC and non GC.

00:54:22.400 --> 00:54:30.000
And you actually only need these pointer functions
object as if you need to override one of those defaults.

00:54:30.000 --> 00:54:32.650
So -- anyway.

00:54:32.650 --> 00:54:35.490
Very simple example.

00:54:35.489 --> 00:54:37.119
I always have a lot of trouble.

00:54:37.119 --> 00:54:43.489
If you're trying to scan through ASCII stuff and
you need NS strings instead of ASCII strings.

00:54:43.489 --> 00:54:48.069
So here's how you kind of find an ASCII string.

00:54:48.070 --> 00:54:49.080
Is it in the table.

00:54:49.079 --> 00:54:50.750
If it is, great.

00:54:50.750 --> 00:54:54.300
Hand out -- the NS string equivalent to it.

00:54:54.300 --> 00:54:59.060
If I don't have that C string in the table I
create an object for it and stick it in there.

00:54:59.059 --> 00:55:03.480
If I never use that object it gets
pulled out of the table automatically.

00:55:03.480 --> 00:55:10.869
So it's sort of a C string to NS string table that only
keeps its values alive as long as the strings are in use.

00:55:10.869 --> 00:55:15.279
You can set that up, you know, with just some options.

00:55:15.280 --> 00:55:20.920
Oh, I showed you the old C API for it.

00:55:20.920 --> 00:55:25.440
Again, you can use object API to get into that table.

00:55:25.440 --> 00:55:29.590
Again, C API and the object API
work on both types of collections.

00:55:29.590 --> 00:55:32.340
It just works.

00:55:32.340 --> 00:55:40.559
The -- Objective-C is built on C. So sometimes
you need to use C with garbage collection.

00:55:40.559 --> 00:55:43.179
So as I illustrated before, it's pretty simple to do.

00:55:43.179 --> 00:55:45.809
You annotate your pointers with under, under strong.

00:55:45.809 --> 00:55:51.210
That tells the Compiler to, you know,
use write barriers where you can.

00:55:51.210 --> 00:55:55.889
And you use NS allocate collectible.

00:55:55.889 --> 00:56:01.829
Sometimes you have to hand out a
malloc-style, block the memory to people.

00:56:01.829 --> 00:56:04.719
So if you're going to store other
pointers into it, we need to know.

00:56:04.719 --> 00:56:07.149
So tell us using the scanned option.

00:56:07.150 --> 00:56:11.250
So more specifically, it takes two options.

00:56:11.250 --> 00:56:15.079
Either tell us you need memory that's
going to be scanned and maybe --

00:56:15.079 --> 00:56:18.849
it might be needed sort of uncollectable right away.

00:56:18.849 --> 00:56:22.809
Let's go into that one in a little bit more detail.

00:56:22.809 --> 00:56:30.880
So for capability, for inner operable, we
have these things called zones in Cocoa.

00:56:30.880 --> 00:56:33.030
And so every object comes from some zone.

00:56:33.030 --> 00:56:35.170
It's not really used very much.

00:56:35.170 --> 00:56:39.159
But it turns out that the collector is a new zone.

00:56:39.159 --> 00:56:46.619
So if you just get the zone from an object and do zone
malloc on it, you can get memory and then you can free it.

00:56:46.619 --> 00:56:47.380
And that works.

00:56:47.380 --> 00:56:48.970
Even though it came from the collector.

00:56:48.969 --> 00:56:50.409
It's really free.

00:56:50.409 --> 00:56:52.339
It's really freed.

00:56:52.340 --> 00:56:54.559
It's really freed.

00:56:54.559 --> 00:57:01.019
Okay. So if you get some memory from our
collector and use it, if you make it --

00:57:01.019 --> 00:57:07.090
if you disable it once, you can actually free it right away.

00:57:07.090 --> 00:57:09.430
You better know what you're doing.

00:57:09.429 --> 00:57:11.839
You can actually start out that way as well.

00:57:11.840 --> 00:57:13.140
You can just allocate some stuff.

00:57:13.139 --> 00:57:17.839
So this is very useful if you need just a quick
and dirty buffer to stuff some pointers into,

00:57:17.840 --> 00:57:21.030
and then you hand the buffer off to
create array or something like that.

00:57:21.030 --> 00:57:23.540
You absolutely know the lifetime of an object.

00:57:23.539 --> 00:57:26.639
You can actually free it.

00:57:26.639 --> 00:57:27.329
One more thing.

00:57:27.329 --> 00:57:33.090
If you're dealing with P threads, the QuickTime guys
came to us a week or so ago -- no, more than that.

00:57:33.090 --> 00:57:37.620
About a month ago and go, hmm, our P threads
aren't automatically getting registered.

00:57:37.619 --> 00:57:38.239
Why is that?

00:57:38.239 --> 00:57:39.849
We go, oh, we have a bug somewhere.

00:57:39.849 --> 00:57:41.239
So we fixed the bug.

00:57:41.239 --> 00:57:47.989
But if you're allocating P threads,
the collector doesn't know about them.

00:57:47.989 --> 00:57:54.329
The collector might find out about them if
you do an NS thread self on that P thread.

00:57:54.329 --> 00:58:00.980
Or if you do an old-style auto release pull (Inaudible)
net, but if you're going to be doing Objective-C work

00:58:00.980 --> 00:58:05.550
on a P thread you need to tell
us by using one of those is APIs.

00:58:05.550 --> 00:58:11.340
We probably should have our own API but -- if you set
up your own P thread and do Objective-C work on it,

00:58:11.340 --> 00:58:14.860
it has to be known to the collector,
and this is how it gets known.

00:58:14.860 --> 00:58:18.460
So especially if you're passing arguments to that thread.

00:58:18.460 --> 00:58:22.720
Those arguments have to be known to the collector somehow.

00:58:22.719 --> 00:58:26.889
Either they are globally accessed
through -- visible from a global.

00:58:26.889 --> 00:58:30.099
Or they have to be, you know, collector disabled.

00:58:30.099 --> 00:58:37.929
So we talk just a little bit more
about the core foundation style stuff.

00:58:37.929 --> 00:58:43.669
So again, all core foundation style objects
are created sort of collector disabled.

00:58:43.670 --> 00:58:53.909
You need to match your CF creates
with CF make collectibles if you can.

00:58:53.909 --> 00:59:01.170
We discovered a few -- just a few,
maybe three total -- CF style things.

00:59:01.170 --> 00:59:08.300
In this case, CG bit map context ref that didn't
really want to play the CF collectible game.

00:59:08.300 --> 00:59:12.470
And so you still have to CF release it in your finalize.

00:59:12.469 --> 00:59:13.769
But that's the exception.

00:59:13.769 --> 00:59:19.610
For the most part everything that comes out of a
core foundation style API can be CF made collectible,

00:59:19.610 --> 00:59:22.430
and you don't have to have a finalize to get rid of them.

00:59:22.429 --> 00:59:28.210
If you're relying on this sort of toll-free bridging
between strings and arrays and dictionaries,

00:59:28.210 --> 00:59:33.470
you're used to creating them with CF-style
syntax and just handing them out as --

00:59:33.469 --> 00:59:37.799
as foundation NS objects, you're going
to have to do a little bit of work.

00:59:37.800 --> 00:59:40.360
You'll have to keep -- you're going to have to make sure

00:59:40.360 --> 00:59:49.300
that that CF collectible is done
before you try handing it back out.

00:59:49.300 --> 00:59:51.440
So to beat a dead horse.

00:59:51.440 --> 00:59:57.159
The last CF release on one of these objects
merely makes it eligible to be collected.

00:59:57.159 --> 00:59:58.849
The collector still has to find it.

00:59:58.849 --> 01:00:03.099
It will still stay alive until the
collector finds it unreachable.

01:00:03.099 --> 01:00:06.250
CF objects or NS objects.

01:00:06.250 --> 01:00:11.559
The low foundation and core foundation -- the collector --

01:00:11.559 --> 01:00:18.539
we have some API in the runtime that
talks -- that deals with the collector.

01:00:18.539 --> 01:00:21.090
So the runtime is open source.

01:00:21.090 --> 01:00:22.019
It's under Darwin.

01:00:22.019 --> 01:00:24.050
You can go take a look at everything.

01:00:24.050 --> 01:00:31.230
What we have in this header file is the API we use
from foundation to give you that higher level stuff.

01:00:31.230 --> 01:00:35.800
There's some extra stuff we haven't
exposed up at the foundation level yet.

01:00:35.800 --> 01:00:40.930
And so if you have to dig, this would
be the place maybe to dig a little bit.

01:00:40.929 --> 01:00:46.349
The file has stuff that's marked API,
and it also has stuff that's marked SPI.

01:00:47.809 --> 01:00:53.059
But for an API perspective, there's more
options on how to kick off collections.

01:00:53.059 --> 01:00:59.690
You can set what we call our threshold as to how many
bytes have been allocated before we trigger a collection.

01:00:59.690 --> 01:01:00.599
There's a ratio.

01:01:00.599 --> 01:01:05.289
How many generations do we do before we do a full.

01:01:05.289 --> 01:01:09.529
Atomic compare and swap of GC pointers
has come up a few times.

01:01:09.530 --> 01:01:12.890
And so we have some API in there for that.

01:01:12.889 --> 01:01:18.299
When you do memo moves, we need to now.

01:01:18.300 --> 01:01:22.860
And those external references you can manipulate directly.

01:01:22.860 --> 01:01:27.050
Finally, we kick off -- the App Kit
has a hook that kicks off the thread,

01:01:27.050 --> 01:01:29.600
the dedicated collector thread automatically for you.

01:01:29.599 --> 01:01:34.509
But if you're a foundation only kind
of programmer and you want the thread,

01:01:34.510 --> 01:01:37.750
the collector thread to run on
its own, then you have to do this.

01:01:37.750 --> 01:01:45.579
Otherwise we will rely on you to call us with collect
if needed and stuff to get the collections done.

01:01:45.579 --> 01:01:51.110
So you know, if you want to program at
a low-level this is the file to do it.

01:01:51.110 --> 01:01:54.849
And clearly, you can hang yourself
with the SPI that we're going to yank

01:01:54.849 --> 01:01:57.769
out from underneath you if you use those SPI functions.

01:01:57.769 --> 01:02:00.199
Don't do it.

01:02:00.199 --> 01:02:06.689
So how to add GC capability and not get fired.

01:02:06.690 --> 01:02:11.130
So it turns out that living in
both worlds is not all that hard.

01:02:11.130 --> 01:02:17.150
Frameworks and bundles may need to be GC
at some times and non GC at other times.

01:02:17.150 --> 01:02:22.269
So when you mark -- when you compile
things with the dash FOBJC GC,

01:02:22.269 --> 01:02:26.400
what that means to us is it is also retain release aware.

01:02:26.400 --> 01:02:30.150
Because that's -- inside Apple that's the dominant case.

01:02:30.150 --> 01:02:35.019
When you mark it GC only, it says
there's no retain release logic.

01:02:35.019 --> 01:02:44.159
So if you have -- if you have a GC only
framework, say, and a non GC program goes

01:02:44.159 --> 01:02:47.629
to load it, you will get a runtime error on load.

01:02:47.630 --> 01:02:53.610
If you have a, you know, so the right
combinations we detect at runtime.

01:02:53.610 --> 01:02:56.760
And we're moving that into link time as well.

01:02:56.760 --> 01:03:00.550
So the foundation APIs as I talked
about do sensible things under non GC.

01:03:00.550 --> 01:03:04.539
Allocate collectible default to malloc under non GC.

01:03:04.539 --> 01:03:07.179
So you can kind of swap them in right now.

01:03:07.179 --> 01:03:11.889
You can convert all your API use over to
these new weak tables and stuff like that.

01:03:11.889 --> 01:03:20.699
And it could still be a non GC program and only when
you compile that last application does it become GC.

01:03:20.699 --> 01:03:26.269
So what we've done internally is delete nothing.

01:03:26.269 --> 01:03:31.320
We kept all that retain release object
obviously, because it sometimes gets used.

01:03:31.320 --> 01:03:35.190
We copied the dealloc into the
finalize and then we optimized it away.

01:03:35.190 --> 01:03:39.960
The NS View finalize -- yeah, finalize
method used to be about that long.

01:03:39.960 --> 01:03:41.690
It's now about that long.

01:03:41.690 --> 01:03:46.550
And I am still on their case about it.

01:03:46.550 --> 01:03:50.300
You align CF create stuff with CF make collectible.

01:03:50.300 --> 01:03:56.289
As I showed you earlier, you convert
your mallocs to NS allocate collectibles.

01:03:56.289 --> 01:04:01.179
I mean, sometimes if you have to stick an
object into somebody else's malloc memory,

01:04:01.179 --> 01:04:07.149
some void star thing somewhere, CF retain
if for the time it has to go there.

01:04:07.150 --> 01:04:11.160
Or use the disable pointer for collector API.

01:04:12.750 --> 01:04:21.440
Convert your set dictionaries and arrays that
use no call backs to the weak collection classes.

01:04:21.440 --> 01:04:23.070
This is more than a recommendation.

01:04:23.070 --> 01:04:29.840
This is pretty much a requirement because again,
the collector could think that something is dead,

01:04:29.840 --> 01:04:36.350
and if that weak collection -- your weak CF
dictionary yields it up again, you're going to have --

01:04:36.349 --> 01:04:39.360
you're going to have a resurrected dangling pointer.

01:04:39.360 --> 01:04:43.360
And it's going to crash just like it did before.

01:04:43.360 --> 01:04:47.890
So clearly, object caches don't work.

01:04:47.889 --> 01:04:52.190
Here's some SPI -- more API -- SPI API you can use.

01:04:52.190 --> 01:04:55.230
It's a quicky way to find out whether
the collector's running.

01:04:55.230 --> 01:04:58.639
And clearly, you have to debug and tune.

01:04:58.639 --> 01:05:00.349
So let me talk just a little bit about that.

01:05:00.349 --> 01:05:05.049
I know it's probably something
three months away from you guys.

01:05:05.050 --> 01:05:09.210
We give you error messages when the
runtime detects some funny business.

01:05:09.210 --> 01:05:14.519
So we let you break on the point, because
it's usually very obvious what's going wrong.

01:05:14.519 --> 01:05:20.400
So resurrection is when you're in a finalize and
you try and store it into something that's alive.

01:05:20.400 --> 01:05:24.950
Like you try to create a new object
enumerator on a dead dictionary.

01:05:24.949 --> 01:05:26.500
You get a resurrection error.

01:05:26.500 --> 01:05:31.280
So you get a typical message, you
know, in Xcode from the Compiler

01:05:31.280 --> 01:05:35.450
that says pointer la de da -- break on whatever to debug.

01:05:35.449 --> 01:05:37.109
Just follow the instructions.

01:05:37.110 --> 01:05:42.809
Just break on that and find out where you're
being resurrected and you can clean that up.

01:05:42.809 --> 01:05:49.630
You can sometimes somehow -- I don't know -- sometimes
you somehow end up with, you know, a non GC object.

01:05:49.630 --> 01:05:55.410
So you know, you can find that out by
breaking on the appropriate message for that.

01:05:55.409 --> 01:05:59.920
If you do a CF make collectible and
still have a CF release somewhere else

01:05:59.920 --> 01:06:03.400
in your code, you can CF release one too many times.

01:06:03.400 --> 01:06:05.230
That's called an underflow.

01:06:05.230 --> 01:06:07.240
Break on that.

01:06:07.239 --> 01:06:09.189
And occasionally you get exceptions thrown.

01:06:09.190 --> 01:06:11.309
You can break on those.

01:06:11.309 --> 01:06:14.389
So just stop using finalize methods.

01:06:14.389 --> 01:06:16.339
There are some tricks.

01:06:16.340 --> 01:06:19.670
Malloc stack logs is a fabulous tool.

01:06:19.670 --> 01:06:24.490
No compacts make it very easy to
find out who the last user was.

01:06:24.489 --> 01:06:29.639
GDB now can be malloc's stack
logging back traces directly.

01:06:29.639 --> 01:06:36.109
You do info malloc on a pointer, and it will show
you the entire history that pointer in your program.

01:06:36.110 --> 01:06:40.840
If you have stock logging on, as I said
before sign intercept helps you find

01:06:40.840 --> 01:06:44.519
out where the write barriers have been.

01:06:44.519 --> 01:06:50.409
And the write barriers, if you suspect you haven't
gotten them all you can disable generational

01:06:50.409 --> 01:06:52.239
and just rely on full collections.

01:06:52.239 --> 01:06:56.369
If your program runs under full
collections but not under generational,

01:06:56.369 --> 01:06:59.429
that means you're missing a write barrier somewhere.

01:07:01.019 --> 01:07:05.679
For tuning, you need to get rid of leaks.

01:07:05.679 --> 01:07:11.259
Leaks occur -- the new kind of
leaks are unwanted sub graphs.

01:07:11.260 --> 01:07:14.000
And they come from global references.

01:07:14.000 --> 01:07:16.750
And sometimes the stack references dead stuff.

01:07:16.750 --> 01:07:24.719
So sometimes you can clear the stack yourself
or zero out old references, it helps us out.

01:07:24.719 --> 01:07:26.589
GDB has another two tricks.

01:07:26.590 --> 01:07:28.180
It's got GC references.

01:07:28.179 --> 01:07:34.079
So you give it an address, and it will
go run sort of a collection on the side.

01:07:34.079 --> 01:07:37.299
And tell you everything that references that object.

01:07:37.300 --> 01:07:41.900
More interesting from a leaks view
point is the info GC roots command.

01:07:41.900 --> 01:07:45.400
And that will go through -- figure out
all those roots that I mentioned before

01:07:45.400 --> 01:07:48.539
and find the shortest path from the root to your object.

01:07:48.539 --> 01:07:53.449
That's going to tell you what's keeping your object alive.

01:07:53.449 --> 01:08:00.469
We will have -- we'll have better
higher level tool support for that.

01:08:00.469 --> 01:08:05.750
So at the moment we have Xray that will
tell you what's going on with the collector.

01:08:05.750 --> 01:08:10.219
You can turn on this environment
variable for command line monitoring.

01:08:10.219 --> 01:08:16.000
You can prod the collector like I said before,
using explicit API drain or collect if needed.

01:08:16.000 --> 01:08:21.199
You can goose the collector and really
make it happen using collect exhaustively.

01:08:21.199 --> 01:08:26.220
And you can adjust the threshholds
using API or these environment variables

01:08:26.220 --> 01:08:29.350
to kind of make collections happen more often.

01:08:29.350 --> 01:08:32.539
As a last resort, we actually -- there's other API

01:08:32.539 --> 01:08:38.310
that let's you turn off the collector
temporarily and then turn it back on.

01:08:38.310 --> 01:08:40.160
Sometimes you can use that.

01:08:40.159 --> 01:08:42.389
So that's pretty much it for the talk.

01:08:42.390 --> 01:08:44.610
I do have a demo I'd like to show you.

01:08:44.609 --> 01:08:49.519
I thought this was really neat let's see
if we can -- switch to -- yeah, we can.

01:08:49.520 --> 01:08:54.840
So, this is the QT recorder demo app.

01:08:54.840 --> 01:08:58.579
They're source code available.

01:08:58.579 --> 01:09:04.569
It's been converted to be compiled and run under 64-bit.

01:09:04.569 --> 01:09:06.199
With garbage collection.

01:09:06.199 --> 01:09:12.970
And you can sit here and if you push this button it
will actually record this off to some data files.

01:09:12.970 --> 01:09:17.940
Now I could have an arbitrary piece of code up here.

01:09:17.939 --> 01:09:23.569
But in fact I am going show you that
it's running under garbage collection.

01:09:23.569 --> 01:09:25.859
I don't really need that.

01:09:25.859 --> 01:09:35.359
Let me bring up Xray.

01:09:35.359 --> 01:09:40.380
And let's attach to the QuickTime Player.

01:09:40.380 --> 01:09:43.920
At some point -- ah.

01:09:45.109 --> 01:09:49.339
I know I was going to have to do this.

01:09:49.340 --> 01:09:53.829
The real magic is if I can remember what it is.

01:09:53.829 --> 01:09:56.029
I can. Okay.

01:09:56.029 --> 01:09:59.300
So what you see here -- sorry?

01:09:59.300 --> 01:10:07.900
Attached to the wrong thing.

01:10:07.899 --> 01:10:11.359
That's why I'm not seeing anything.

01:10:11.359 --> 01:10:13.509
You're right.

01:10:13.510 --> 01:10:14.800
So much for demos.

01:10:14.800 --> 01:10:16.960
Okay. Let's start over.

01:10:16.960 --> 01:10:17.909
Did I quit Xray?

01:10:17.909 --> 01:10:19.460
Let's quit Xray.

01:10:19.460 --> 01:10:23.510
Let's just start it over.

01:10:23.510 --> 01:10:26.670
Garbage collection.

01:10:26.670 --> 01:10:27.819
Choose that.

01:10:27.819 --> 01:10:30.090
Let's attach to -- boy!

01:10:30.090 --> 01:10:34.840
The pressure of an audience!

01:10:34.840 --> 01:10:37.590
( Laughter )
>> Ah. We had a GC event!

01:10:37.590 --> 01:10:38.369
Right now!

01:10:38.369 --> 01:10:53.859
( Applause )
>> If I zoomed in what you would see is we
actually tell you how many objects got reclaimed,

01:10:53.859 --> 01:10:55.670
how many bytes got reclaimed.

01:10:55.670 --> 01:11:01.449
We have some other stuff in works that will
actually show you the total heap size and what not.

01:11:01.449 --> 01:11:05.829
But we're coming along with Xray,
we have a lot of great ideas for it.

01:11:05.829 --> 01:11:10.680
But this is a 64-bit app runnidng GC capturing video live.

01:11:10.680 --> 01:11:13.220
So I think that's pretty nifty.

01:11:13.220 --> 01:11:14.119
I don't know what you think.

01:11:14.119 --> 01:11:16.510
Back -- I think it's time for Q and A.

01:11:16.510 --> 01:11:23.500
( Applause )
WEBVTT

00:00:19.730 --> 00:00:20.550
>> Good morning.

00:00:20.550 --> 00:00:21.830
How you guys doing this morning?

00:00:21.829 --> 00:00:23.909
It's a little bit early on a Thursday.

00:00:23.910 --> 00:00:27.440
And I'm Geoff Stahl, and I'm going to be
talking about the OpenGL Shading Language.

00:00:27.440 --> 00:00:32.890
One thing I wanted to do at the start of this
presentation is actually kind of see a show of hands on,

00:00:32.890 --> 00:00:35.179
on what people's familiarity with it, because I can,

00:00:35.179 --> 00:00:39.030
I can gauge my talk to how the
audience is, what you guys want to hear.

00:00:39.030 --> 00:00:43.890
So, who has never used GLSL or
OpenGL Shading Language at all?

00:00:43.890 --> 00:00:45.899
So, probably about two-thirds of the room.

00:00:45.899 --> 00:00:46.629
That's good, that's good.

00:00:46.630 --> 00:00:50.429
Who is, who's, say they're pretty familiar with it?

00:00:50.429 --> 00:00:51.619
So, about a third or so.

00:00:51.619 --> 00:00:52.820
So, I, Ok, that's good.

00:00:52.820 --> 00:00:55.310
We can, we can work with that.

00:00:55.310 --> 00:00:58.480
So, the first thing I'm going to talk
about, which will really hit the people

00:00:58.479 --> 00:01:03.349
who have not used it is, what is GLSL and why do you care?

00:01:03.350 --> 00:01:09.510
And I think that what I'm going to show you today will
be, will really show you that if you're coming to OpenGL

00:01:09.510 --> 00:01:14.130
or if you may have traditional GL application or
even if you're thinking about it and you're not sure,

00:01:14.129 --> 00:01:19.439
that GLSL gives you a really good entry into
working with OpenGL and getting the system

00:01:19.439 --> 00:01:22.480
to do exactly what you want it to
do, which is sometimes daunting.

00:01:22.480 --> 00:01:25.939
I think I've, I've talked to people before and one
of the things we've talked about and when you look

00:01:25.939 --> 00:01:30.030
at like core animation and Core Image and
some of those technologies that Apple has,

00:01:30.030 --> 00:01:35.230
we've divided those technologies out as
really easy to enter, easy to use technologies

00:01:35.230 --> 00:01:37.930
but below them they're sitting on OpenGL.

00:01:37.930 --> 00:01:40.590
Sometimes complicated ways, sometimes
not so complicated ways.

00:01:40.590 --> 00:01:45.990
But GLSL is another entry point, which I think really
actually makes it really easy to enter and use the power

00:01:45.989 --> 00:01:50.129
of GPU for your application, whether
it's a 3D app or a 2D app,

00:01:50.129 --> 00:01:55.829
and not have to learn every nuance
of a very thick OpenGL specification.

00:01:55.829 --> 00:02:04.299
So, basically GLSL, OpenGL Shading Language is a high level
C like language and it's integrated into the OpenGL API

00:02:04.299 --> 00:02:06.759
and allows access to the power of the GPU.

00:02:06.760 --> 00:02:09.539
So, first thing we'll do is just
look at a piece of code up here

00:02:09.539 --> 00:02:12.609
and that code gives you an idea
that it looks familiar to you.

00:02:12.610 --> 00:02:15.970
If you're a C programmer, it looks
very similar to what, what you'd see.

00:02:15.969 --> 00:02:19.659
But it has a few kind of specifiers
on the variables of the beginning.

00:02:19.659 --> 00:02:21.759
There's an attribute, a uniform and a varying.

00:02:21.759 --> 00:02:28.799
And what that does is basically is a qualifier to tell the
compiler what you're going to be doing with these variables.

00:02:28.800 --> 00:02:32.100
The attributes are like coming in through the vertex path.

00:02:32.099 --> 00:02:33.759
Uniforms are like constants.

00:02:33.759 --> 00:02:36.719
And varyings come out from a vertex
shader and go into a fragment shader

00:02:36.719 --> 00:02:38.389
and are interpolated when they're in a fragment shader.

00:02:38.389 --> 00:02:40.049
So that's kind of qualifiers there.

00:02:40.050 --> 00:02:41.790
Then there's a main, which you would expect.

00:02:41.789 --> 00:02:45.719
And then we have what you would
really, except for the kind of built

00:02:45.719 --> 00:02:47.469
in function there, something you can really understand.

00:02:47.469 --> 00:02:50.469
It's a... There's a mix function that's built into GLSL.

00:02:50.469 --> 00:02:57.590
We take an input, which is the GL underscores or
all the built ins, and we applied a waiting on it.

00:02:57.590 --> 00:03:01.039
Understand here though that GLSL is a vector language.

00:03:01.039 --> 00:03:03.500
So that's a vec 4 so we have four components there.

00:03:03.500 --> 00:03:06.189
We're mixing across all four components with that wait.

00:03:06.189 --> 00:03:10.289
So it's really nice and you can start
thinking about problems in that way.

00:03:10.289 --> 00:03:16.469
Texture coord, again, it's a GL underscore
so it's a built in and we pull some texture coords out

00:03:16.469 --> 00:03:18.439
and then we have a, we calculate a position.

00:03:18.439 --> 00:03:24.539
The last line is basically what the fixed function pipeline
does in OpenGL to calculate, transform your vertex.

00:03:24.539 --> 00:03:27.519
So it transforms it from 3D space
into basically screen space.

00:03:27.520 --> 00:03:30.150
So that just shows what you're looking at.

00:03:30.150 --> 00:03:32.680
So, why do you care about GLSL

00:03:32.680 --> 00:03:34.620
Why is GLSL interesting to you?

00:03:34.620 --> 00:03:35.599
Why is it easier?

00:03:35.599 --> 00:03:38.239
I mean, some people say it's a
programming language, I don't, you know,

00:03:38.240 --> 00:03:39.850
calling functions might be easier than that.

00:03:39.849 --> 00:03:46.139
But this is, really is, what I've found is with the
tools that we give you, some of the sample code we have

00:03:46.139 --> 00:03:49.199
and some of the stuff out there on the web
and some of the things you can do yourself,

00:03:49.199 --> 00:03:52.179
you really can tailor a solution to your problem.

00:03:52.180 --> 00:03:53.240
So it's approachable.

00:03:53.240 --> 00:03:54.930
It's very easy to use and I'll show you that.

00:03:54.930 --> 00:03:55.710
It's understandable.

00:03:55.710 --> 00:03:57.480
We already said it's a C like language.

00:03:57.479 --> 00:03:59.109
So that's pretty easy.

00:03:59.110 --> 00:03:59.950
It's direct.

00:03:59.949 --> 00:04:02.329
You can directly do what you'd want to do.

00:04:02.330 --> 00:04:06.340
So in some cases in OpenGL you may
have to use the texture combiners

00:04:06.340 --> 00:04:09.780
to actually combine different textures
to get certain effects.

00:04:09.780 --> 00:04:13.479
Well now you can actually just blend them in a C program.

00:04:13.479 --> 00:04:14.469
And it's fast.

00:04:14.469 --> 00:04:15.539
Access is a GPU.

00:04:15.539 --> 00:04:21.240
So the newest features of the newest GPU's, the
way you get them is through GLSL on Mac OS X.

00:04:21.240 --> 00:04:28.199
And it's an industries focus, the ARB Industry Standards
Group is working to improve and expand and continue

00:04:28.199 --> 00:04:31.819
to develop OpenGL Apple as a part,
a very active part of this

00:04:31.819 --> 00:04:34.250
and it's Apple's focus as far as moving forward with GPU.

00:04:34.250 --> 00:04:36.170
So you're on a technology that we move forward.

00:04:36.170 --> 00:04:41.600
Next year when you come here we're talking about
GLSL, the year after we're talking about GLSL.

00:04:41.600 --> 00:04:44.770
Let's jump in to some of the points
and dive a little bit deeper.

00:04:44.769 --> 00:04:46.319
So it's approachable.

00:04:46.319 --> 00:04:49.699
Basically it's simple to set up and easy to experiment with.

00:04:49.699 --> 00:04:51.560
You don't need a lot of OpenGL knowledge.

00:04:51.560 --> 00:04:54.959
And so what I'm going to show is this
little example here and we're going

00:04:54.959 --> 00:04:57.319
to look at this live and show you what it does.

00:04:57.319 --> 00:05:02.430
So, someone out here has an image processing app and
they've seen Core Image and say, hey that's pretty good,

00:05:02.430 --> 00:05:03.990
but I want to write a little bit differently.

00:05:03.990 --> 00:05:05.139
I want to do some of my own stuff.

00:05:05.139 --> 00:05:06.259
So what do I do?

00:05:06.259 --> 00:05:14.539
I can write an edge detection filter in GLSL very
simply and just apply it to a texture and if I look

00:05:14.540 --> 00:05:16.600
and load the texture in I can apply
an edge detection filter.

00:05:16.600 --> 00:05:17.470
And I can modify this.

00:05:17.470 --> 00:05:18.760
I can work with it.

00:05:18.759 --> 00:05:28.029
And so let's go right into a demo and see
how someone could easily bring this up.

00:05:28.029 --> 00:05:33.459
So, there's a piece of sample code on all
year, that's been around for about a year now.

00:05:33.459 --> 00:05:35.039
It's called GLSL Sample Editor.

00:05:35.040 --> 00:05:38.110
And I'm going to use that as kind of the editor example.

00:05:38.110 --> 00:05:41.100
The reason I'm using it is because
you have it on your DVD's.

00:05:41.100 --> 00:05:43.280
It's in the sample code under OpenGL and Cocoa.

00:05:43.279 --> 00:05:46.579
And you can write your GLSL shaders
just like I'm doing on stage here.

00:05:46.579 --> 00:05:52.859
You can write them and experiment with them, you know,
not while the presentation's going on but maybe after.

00:05:52.860 --> 00:05:54.180
So this is the edge detection filter.

00:05:54.180 --> 00:05:58.060
It might be a little bit hard to read but I'll walk
through, I'll talk about what I'm doing with it.

00:05:58.060 --> 00:06:01.160
I'm not sure if this even works.

00:06:01.160 --> 00:06:03.270
I don't think I hooked that up.

00:06:03.269 --> 00:06:05.969
But, so at the beginning I talked about constants.

00:06:05.970 --> 00:06:07.800
In the first line it says sampler 2D rec.

00:06:07.800 --> 00:06:11.250
And all a sampler is is basically
something that accesses a texture.

00:06:11.250 --> 00:06:13.550
It's a 2D rec, so it's a rectangular texture.

00:06:13.550 --> 00:06:14.780
So I have to load that.

00:06:14.779 --> 00:06:18.049
So let's, let's look at our little rendering window,

00:06:18.050 --> 00:06:22.050
or look in the shader program here and
I have a texture tab we put in here.

00:06:22.050 --> 00:06:23.509
This is all in the sample code.

00:06:23.509 --> 00:06:25.250
This is all just compile, run the sample code.

00:06:25.250 --> 00:06:26.829
And there's a texture in here.

00:06:26.829 --> 00:06:27.279
We have a type.

00:06:27.279 --> 00:06:31.979
I'll make it rectangular just so it works with
the shader so it works with the shader I wrote.

00:06:31.980 --> 00:06:32.879
Now what does this shader do?

00:06:32.879 --> 00:06:34.529
It basically, This is a kernel filter.

00:06:34.529 --> 00:06:39.399
It takes the center point that you're sampling, multiply
by negative four and then takes the surrounding,

00:06:39.399 --> 00:06:44.259
takes the X and Y, takes the vertical and
horizontal surrounding pixels and multiplies them

00:06:44.259 --> 00:06:48.279
by one point 0 in this case and does an edge detection.

00:06:48.279 --> 00:06:51.579
So it basically, when it crosses the boundary
you're just going to change the color.

00:06:51.579 --> 00:06:54.149
We have a texture input, we have this.

00:06:54.149 --> 00:06:58.199
What I'm going to do is, this is the
equivalent of calling use program in OpenGL.

00:06:58.199 --> 00:07:04.810
And down here, let's bring this a little
bit bigger so you guys can see it.

00:07:04.810 --> 00:07:14.199
So, I am going to contend that this, that that five lines of
OpenGL in vector space is, makes an edge detection filter.

00:07:14.199 --> 00:07:16.139
Ok, great.

00:07:16.139 --> 00:07:18.259
Well, then I have to type code to change things.

00:07:18.259 --> 00:07:23.860
Well, what's, what's the one thing we can do in
OpenGL or GLSL that I mentioned about constants?

00:07:23.860 --> 00:07:29.290
So if we look at constants we have a constant here, a point
five and a five and we have some of these one point 0's.

00:07:29.290 --> 00:07:33.560
So let's throw something in here to make it a little
bit, show you how easy it is to experiment with this.

00:07:33.560 --> 00:07:42.209
So I'm going to add another uniform and we're compiling on
the fly and I'm going to make it called adjust and I'm going

00:07:42.209 --> 00:07:46.159
to make it, actually I'm going to make it
a vec three because I want three values

00:07:46.160 --> 00:07:49.360
and I'll call it adjust, and so that's my.

00:07:49.360 --> 00:07:56.800
And what I'll do is, remember this is a vector, so I'll
simply paste it in here, make that the X component,

00:07:56.800 --> 00:08:08.090
make that the Y component and I'll make the, the,
how big the kernel is I'll make that the Z component.

00:08:08.089 --> 00:08:10.029
So this is the offset in that texture sampler.

00:08:10.029 --> 00:08:17.949
So I'll make that the Z. There's
a minus one and there's a plus one here

00:08:17.949 --> 00:08:21.019
and there's one more plus one and we do that.

00:08:21.019 --> 00:08:26.979
So now we have this variable that we've added in
that's a constant coming in, your API specifies this.

00:08:26.980 --> 00:08:27.840
And you can adjust this.

00:08:27.839 --> 00:08:32.569
So now we can adjust the intensity, we can adjust an
offset level and we adjust the size of our filter.

00:08:32.570 --> 00:08:35.230
Again, these five lines of code.

00:08:35.230 --> 00:08:39.789
In this sample we have this, You see
adjust came up in our uniform tab.

00:08:39.789 --> 00:08:40.750
We talked about uniforms.

00:08:40.750 --> 00:08:42.580
And so now we have these sliders.

00:08:42.580 --> 00:08:45.800
And so, if you notice, that's my,
the first thing was my base level.

00:08:45.799 --> 00:08:48.859
So that goes from basically black to white.

00:08:48.860 --> 00:08:52.519
And we're doing alpha too so that's
why it goes back to the gray graph.

00:08:52.519 --> 00:08:54.590
We'll put that at 50 percent.

00:08:54.590 --> 00:08:59.759
We'll make the intensity can go to 100
and the offset can go to 10.

00:08:59.759 --> 00:09:10.710
So now, we bring this up and we bring that up and you can
see, we'll make actually this a little bit lower to 15.

00:09:10.710 --> 00:09:12.580
So that's basically what we had before.

00:09:12.580 --> 00:09:16.379
But you can increase the intensity of
your edge detection through the uniform.

00:09:16.379 --> 00:09:18.309
One variable is going down to the GPU right now.

00:09:18.309 --> 00:09:19.719
It's all in the GPU.

00:09:19.720 --> 00:09:24.379
You can, again, control the base line
and you control the size of the kernel

00:09:24.379 --> 00:09:26.950
that you're actually filtering on to get edges.

00:09:26.950 --> 00:09:29.170
So this is real similar to what you would see in Core Image.

00:09:29.169 --> 00:09:31.629
Again, GLSL, real similar.

00:09:31.629 --> 00:09:35.210
Got some basic five lines of code and then
I can play with it and I can experiment.

00:09:35.210 --> 00:09:38.120
I can build that filter or whatever I'm looking at.

00:09:38.120 --> 00:09:46.860
So. And so my point is there is that
GLSL, you didn't need to know any OpenGL,

00:09:46.860 --> 00:09:51.480
except for maybe the texture code, the
rest was your solving your problem.

00:09:51.480 --> 00:09:53.560
It's solving the problem of, hey, I want a kernel filter.

00:09:53.559 --> 00:09:56.009
So I'm going to go back to the slides.

00:09:57.210 --> 00:10:01.500
So it's understandable.

00:10:01.500 --> 00:10:02.980
We've already seen that the code is pretty clear.

00:10:02.980 --> 00:10:04.460
It's straight forward the program.

00:10:04.460 --> 00:10:06.310
I gave the texture combiner example.

00:10:06.309 --> 00:10:09.479
If you're in OpenGL you can do lots of texture combiners.

00:10:09.480 --> 00:10:12.740
But maybe that's not what you want to do,
maybe you just want to blend something.

00:10:12.740 --> 00:10:16.159
So, this was using color mask,
and I wrote this four years ago.

00:10:16.159 --> 00:10:19.299
It may not be the best code in
the world but, oh my God, I mean,

00:10:19.299 --> 00:10:22.389
if I put it on the slide that would be four or five slides.

00:10:22.389 --> 00:10:26.149
Let me tell you how to do a color
mask and turn components on and off.

00:10:26.149 --> 00:10:27.529
Not what I want to do.

00:10:27.529 --> 00:10:35.120
So, let's look at equivalent kind of blend color, color
masking to control, color component control in GLSL.

00:10:35.120 --> 00:10:38.700
So that's the fragment program
that does basically the same thing.

00:10:38.700 --> 00:10:42.170
And what this does basically, if you
notice, is a contribution uniform value.

00:10:42.169 --> 00:10:43.279
We talked about that.

00:10:43.279 --> 00:10:46.829
It does a, It has textural look-up
and does the vector multiply.

00:10:46.830 --> 00:10:47.930
Remember, we're working in vector space.

00:10:47.929 --> 00:10:48.979
And then it gets a color.

00:10:48.980 --> 00:10:52.509
So all you're doing is you have an adjustment
now for the different color components.

00:10:52.509 --> 00:10:55.129
So if you want to have a blender
that changes color components,

00:10:55.129 --> 00:10:57.720
again in like an image processing app, very simple.

00:10:57.720 --> 00:11:04.860
So we'll go back to the demo machine.

00:11:04.860 --> 00:11:09.519
And so we'll use this program and, if
we look at, Again, we go to textures

00:11:09.519 --> 00:11:12.750
and this is a texture rectangle, look at uniforms.

00:11:12.750 --> 00:11:16.960
So the contribution is the only uniform I have
up there and the contribution is all maxed out.

00:11:16.960 --> 00:11:22.970
But let's say I want to turn down the red channel or I
want to turn down the green channel or the blue channel.

00:11:22.970 --> 00:11:26.279
And so you can also can do it this way
and you could do something like this.

00:11:26.279 --> 00:11:28.779
We go turn it up.

00:11:28.779 --> 00:11:37.129
You can see, let me move this, make this bigger, then
you can see that depending, and this is just, you know,

00:11:37.129 --> 00:11:43.820
we're just sending a single uniform in and on the GPU it's
doing the blend itself with a one line shader, get direct.

00:11:43.820 --> 00:11:46.140
You're actually affecting what, It's very clear.

00:11:46.139 --> 00:11:48.039
You're effecting exactly what you want to do.

00:11:48.039 --> 00:11:55.829
And with our, sample editor you can always take any
image you want, dump it in and you can say, you know,

00:11:55.830 --> 00:12:00.060
you want to dim it out, you know,
you want to, sorry, brighten it.

00:12:00.059 --> 00:12:03.449
And I need to redraw it.

00:12:03.450 --> 00:12:11.860
I'll just do this, oops, uniforms, there
we go, back to editing my uniforms, there we go.

00:12:11.860 --> 00:12:13.909
That's what I wanted to do.

00:12:13.909 --> 00:12:14.449
There you go.

00:12:14.450 --> 00:12:16.550
So it works with any image.

00:12:16.549 --> 00:12:18.429
So we'll go back to the slides.

00:12:21.309 --> 00:12:23.649
Says color control and blending.

00:12:23.649 --> 00:12:26.789
The example was you can do a lot of different ways in OpenGL

00:12:26.789 --> 00:12:28.870
and there's probably better ways
than I showed you in the code.

00:12:28.870 --> 00:12:30.149
Obviously I was trying to make a point there.

00:12:30.149 --> 00:12:36.100
But the example is there is a lot of code that you set up
OpenGL state and manipulate state and set contributions.

00:12:36.100 --> 00:12:38.750
In GLSL you actually just write the code you want to write.

00:12:38.750 --> 00:12:40.789
So it's also direct.

00:12:40.789 --> 00:12:43.629
You can accomplish what you, what
you're, what you really want to do.

00:12:43.629 --> 00:12:46.200
And we showed that in the other example.

00:12:46.200 --> 00:12:50.670
But the point here is you can actually
get direct access to features of the GPU.

00:12:50.669 --> 00:12:55.969
So the GPU has improved fragment programs, has looping
and branching and conditionals, has geometry shader.

00:12:55.970 --> 00:12:57.990
All these things are exposed through GLSL.

00:12:57.990 --> 00:13:04.310
So if you want to, for example, do some kind of fractal
pattern where you actually kind of build geometry on the fly

00:13:04.309 --> 00:13:08.399
on the GPU without using the CPU you
can do that using a geometry shader.

00:13:08.399 --> 00:13:12.539
If you want to have a loops and you want
to do conditional discarding of pixels.

00:13:12.539 --> 00:13:18.019
You want to punch holes depending on values coming in
you can do it, but you can do it if my value coming in,

00:13:18.019 --> 00:13:23.029
my texture look-up value is less than point
five for alpha I want to discard that fragment.

00:13:23.029 --> 00:13:23.970
And so you punch a whole through it.

00:13:23.970 --> 00:13:28.230
I mean, it's directly representing what you want to do.

00:13:28.230 --> 00:13:32.980
So, for example, I have this fairly long kind of complicated
thing here, which is actually not that complicated.

00:13:32.980 --> 00:13:35.180
It's actually an interesting little piece of a shader.

00:13:35.179 --> 00:13:39.919
You notice there's some vec three's and it's
greater than and it does basically a texture look-up

00:13:39.919 --> 00:13:44.709
as we've seen before, a surrounding texture look-up,
to get some count, and the count is neighbors.

00:13:44.710 --> 00:13:45.750
How many neighbors do we have?

00:13:45.750 --> 00:13:48.509
It's doing it in three channels,
or four channels at one time.

00:13:48.509 --> 00:13:51.279
So I think, I'm sorry, it's three channels at one time.

00:13:51.279 --> 00:13:52.919
And then it, then there's an if statement.

00:13:52.919 --> 00:13:57.110
If the vec equals three cell gets one, alpha stays the same.

00:13:57.110 --> 00:13:58.759
So some people might be thinking, I've seen this before.

00:13:58.759 --> 00:14:02.970
The key I want to point here is with the conditionals.

00:14:02.970 --> 00:14:09.139
Instead of having to do some kind of funky, you know, tricky
logic, you actually have the ability to get conditionals.

00:14:09.139 --> 00:14:09.919
You have the equal.

00:14:09.919 --> 00:14:14.870
You have the greater than or equal, less or equal, which
is basically the mathematical operation built into GLSL

00:14:14.870 --> 00:14:18.029
that you can use to do conditional,
conditional processing on that.

00:14:18.029 --> 00:14:20.360
So this is the equivalent of having
a number of if statements.

00:14:20.360 --> 00:14:25.139
And I'll get back to what this is, I assume some
of you can probably figure out where that's going.

00:14:25.139 --> 00:14:26.509
It's just an interesting of GLSL.

00:14:26.509 --> 00:14:29.590
The last thing I want to talk about is fast.

00:14:29.590 --> 00:14:32.830
So it's optimized with high and low level compilers.

00:14:32.830 --> 00:14:35.100
We put a compiler technology behind your GLSL program.

00:14:35.100 --> 00:14:36.090
We compile it.

00:14:36.090 --> 00:14:37.960
We send it to the driver vendors.

00:14:37.960 --> 00:14:40.450
They have their own hardware specific compilers.

00:14:40.450 --> 00:14:41.440
They compile it.

00:14:41.440 --> 00:14:44.410
And we really work hard to make
sure the GLSL works really well.

00:14:44.409 --> 00:14:45.600
And that's where we're putting our efforts in.

00:14:45.600 --> 00:14:47.850
So this is something to take, to
leverage, take advantage of.

00:14:47.850 --> 00:14:54.340
You can use more complex constructs and
then take advantage of that in GLSL.

00:14:54.340 --> 00:14:57.590
Power of the GPU.

00:14:57.590 --> 00:15:04.009
The GPU, the X1900, for example, is speced
at 9 giga pixels per second of fill rate.

00:15:04.009 --> 00:15:08.529
This isn't, you know, if you're clearing, this is not
doing complex, this is exactly the high level rill rate.

00:15:08.529 --> 00:15:11.689
And so if we take that and put that on to a 30 inch display.

00:15:11.690 --> 00:15:12.400
What does that give you?

00:15:12.399 --> 00:15:15.509
So a 30 inch display is 2500 by 1600.

00:15:15.509 --> 00:15:19.740
How many frames could you clear, can you actually
write to the memory, how many pixels can clear?

00:15:19.740 --> 00:15:23.139
That's about 24,000, I'm sorry, 2400 frames per second.

00:15:23.139 --> 00:15:26.199
So there's a lot of power in that
card, a lot of power to use.

00:15:26.200 --> 00:15:30.070
Using it wisely and using it well in your
application can really differentiate your application

00:15:30.070 --> 00:15:32.760
and can make you be able to do
things you couldn't do on the CPU.

00:15:32.759 --> 00:15:38.549
I mean, imagine if you had to process
a four mega pixel frame

00:15:38.549 --> 00:15:41.479
on the CPU an upload it across the bus every single time.

00:15:41.480 --> 00:15:48.170
So move that to the GPU, move that to the GPU and I think
you'll see great, great things will happen with your app.

00:15:48.169 --> 00:15:52.990
41 gigabytes in memory bandwidth in our new laptops,

00:15:52.990 --> 00:15:55.440
the fill rate on those is seven
point six giga pixels per second.

00:15:55.440 --> 00:15:57.830
So it's approaching the desktop level of fill rate.

00:15:57.830 --> 00:16:02.230
So large displays well supported,
larger set of pixels well supported.

00:16:02.230 --> 00:16:05.480
So let's go back to the demo machine.

00:16:05.480 --> 00:16:10.590
And I want to do one fairly quick last demo.

00:16:10.590 --> 00:16:18.360
And that is something that I showed you before a piece
of and it's not, you can do a lot more with the GPU

00:16:18.360 --> 00:16:22.740
but it's just an interesting use of directly programming
the GPU and showing kind of what the power is.

00:16:22.740 --> 00:16:26.629
It's running on a laptop and, let me see
if I can get this right and it'll work.

00:16:26.629 --> 00:16:29.899
There's, there we go.

00:16:29.899 --> 00:16:31.819
So that wasn't very interesting.

00:16:31.820 --> 00:16:34.320
That might be interesting.

00:16:34.320 --> 00:16:39.790
This is, If I can zoom in.

00:16:39.789 --> 00:16:47.620
This is Life running entirely on the GPU
and it runs at, for this implementation,

00:16:47.620 --> 00:16:53.429
it's getting about 100 mega pixels per second,
running at 90 frames per second for the entire screen.

00:16:53.429 --> 00:16:55.449
It runs three versions of Life at the same time.

00:16:55.450 --> 00:16:58.030
So each channel has it running simultaneously.

00:16:58.029 --> 00:17:01.169
You see red, green, blue are running
independently and simultaneously.

00:17:01.169 --> 00:17:03.549
The nugget of code I showed you
before was the conditional statement

00:17:03.549 --> 00:17:06.069
that determines whether it's alive
or dead and counts neighbors.

00:17:06.069 --> 00:17:12.579
So the deal here is not, you know, it's a little fun
game but it's an interesting use of the power of the GPU

00:17:12.579 --> 00:17:22.339
to do all on the GPU to do kind of fragment level
processing that is not, so to speak, image processing.

00:17:22.339 --> 00:17:25.269
Let's see if I can get just one more quick one here.

00:17:25.269 --> 00:17:33.269
So you can see we can reseed it at, again, about
100 mega pixels per second running Life on the GPU.

00:17:33.269 --> 00:17:40.400
And this is included in the OpenGL, GLSL
showpiece, which is, again, on your developer DVD.

00:17:40.400 --> 00:17:42.230
It's been on there for about a year.

00:17:42.230 --> 00:17:44.019
It's just an interesting idea for a shader.

00:17:44.019 --> 00:17:44.509
You can look at it.

00:17:44.509 --> 00:17:46.750
You can play with it, get new ideas.

00:17:46.750 --> 00:17:52.650
But again, you can run it on the GPU directly affect,
you know, directly accomplish a task here at hand.

00:17:52.650 --> 00:17:53.950
In this case we're just playing the game of Life.

00:17:53.950 --> 00:17:55.509
So it's kind of fun.

00:17:55.509 --> 00:17:59.559
So we'll go back to the slide machine.

00:17:59.559 --> 00:18:06.649
So that was my, Let's introduce kind of GLSL,
give you a feel for what you can do with it,

00:18:06.650 --> 00:18:12.580
get you thinking about it's not just about drawing
polygons, drawing vertices, drawing fragments.

00:18:12.579 --> 00:18:14.829
So I'm going to cover a bunch of things.

00:18:14.829 --> 00:18:15.889
First I'm going to talk about a shader.

00:18:15.890 --> 00:18:20.080
I'm going to break it down so people who haven't used
GLSL, I'm going to talk about how to get it set up.

00:18:20.079 --> 00:18:24.000
So we gave you some tools that can already do it but
you really want to know how you can write some code.

00:18:24.000 --> 00:18:27.509
You can fool with the shaders by themselves and
then there's some API stuff we'll put in there.

00:18:27.509 --> 00:18:29.170
Then I'll talk about GLSL and Leopard.

00:18:29.170 --> 00:18:32.610
And we'll talk about what we have and where it's going.

00:18:32.609 --> 00:18:36.389
We'll talk about working a little bit with hardware,
which is something that everyone will want to worry about.

00:18:36.390 --> 00:18:40.100
And then we'll talk about fourth generation
shader support, which is now going to be

00:18:40.099 --> 00:18:44.049
in Leopard for our new hardware and on software.

00:18:44.049 --> 00:18:47.629
So let's talk about shaders, jump right in.

00:18:47.630 --> 00:18:53.610
So first thing is this is a image provided by Moto by
Luxology, just to zoom in on one of their renderings.

00:18:53.609 --> 00:18:55.250
Obviously this is not the full rendering.

00:18:55.250 --> 00:19:00.009
You want to kind of look at what constitutes this 3D scene.

00:19:00.009 --> 00:19:01.809
So first thing we're going to add a grid to it.

00:19:01.809 --> 00:19:06.119
So this is the grid of vertices that
is used to draw the 3D geometry.

00:19:06.119 --> 00:19:08.419
Remember each point on here is a vertex.

00:19:08.420 --> 00:19:10.110
Vertex shaders operate on vertices.

00:19:10.109 --> 00:19:17.750
So every single point that is sent to the GPU, the GPU is
going to do, execute your program one time for each vertex.

00:19:17.750 --> 00:19:22.019
So if there's a thousand vertices here, you have
a thousand iterations on that vertex shader.

00:19:22.019 --> 00:19:26.930
If we zoom in a bit you can see that the grid makes
up the geometry and we'll highlight a triangle.

00:19:26.930 --> 00:19:28.250
This is a primitive.

00:19:28.250 --> 00:19:30.859
And a primitive, in this case, is just a simple triangles.

00:19:30.859 --> 00:19:33.439
Triangles are operated on by geometry shaders.

00:19:33.440 --> 00:19:36.480
So the geometry shader operates at a primitive level.

00:19:36.480 --> 00:19:40.599
Three vertices fed into a geometry shader, geometry
shader can decide to put out three vertices,

00:19:40.599 --> 00:19:43.459
decide I want more vertices, decide to put out no vertices.

00:19:43.460 --> 00:19:47.230
So a geometry shader basically is
working on that at the primitive level.

00:19:47.230 --> 00:19:53.440
If we move down and we zoom in even further the primitive
in screen space, so in the space that's facing you

00:19:53.440 --> 00:19:55.920
when you rasterize it, is made up of pixels.

00:19:55.920 --> 00:20:03.519
So if a primitive is very oblique, I guess is the right
word, to you, you have a very, It may only be four

00:20:03.519 --> 00:20:07.569
or fives lines of fragments on the
screen or pixels on the screen.

00:20:07.569 --> 00:20:09.929
As it comes to be plainer it kind of grows in scope.

00:20:09.930 --> 00:20:15.210
The point here I'm making is, is
that the fragment processing operates

00:20:15.210 --> 00:20:18.430
on every single pixel that's included in that primitive.

00:20:18.430 --> 00:20:21.250
So it operates basically scans across.

00:20:21.250 --> 00:20:25.450
Your fragment program operates on every single, The
fragment shader operates on every single one of those.

00:20:25.450 --> 00:20:29.730
So you can imagine if you have a thousand triangles
stacked it still operates on every single one of those.

00:20:29.730 --> 00:20:30.710
You can be blending.

00:20:30.710 --> 00:20:31.819
It needs to get the results.

00:20:31.819 --> 00:20:34.909
So that's when you call depth complexity,
when you have things stacked.

00:20:34.910 --> 00:20:37.009
In this case we're just talking about a single triangle.

00:20:37.009 --> 00:20:39.789
So that's, those are kind of the scope of things.

00:20:39.789 --> 00:20:47.509
Vertices, primitives, fragments and it goes
from a thousand to maybe a million in a scene.

00:20:47.509 --> 00:20:51.029
So understand that when we're thinking
about where you want to do work.

00:20:51.029 --> 00:20:53.460
This is something we're not going to talk about today.

00:20:53.460 --> 00:20:55.579
We're not going to talk about the
OpenGL fix function pipeline.

00:20:55.579 --> 00:20:56.659
Fix function pipeline.

00:20:56.660 --> 00:21:01.500
We put this slide up every year, this is out of
the red book and this is OpenGL, great, yeah.

00:21:01.500 --> 00:21:09.690
It takes some time to talk about this and in reality
a lot of the things in it are things you'll use

00:21:09.690 --> 00:21:13.740
but they're not things that you really want to spend a
lot of time explaining, you know, what a display list is.

00:21:13.740 --> 00:21:15.009
So we're going to talk about a different pipeline.

00:21:15.009 --> 00:21:17.029
We're going to talk about this pipeline.

00:21:17.029 --> 00:21:20.750
So basically this has some vertex attributes
coming in position, for example, color.

00:21:20.750 --> 00:21:25.640
Go through a vertex shader, goes to a
geometry shader, goes to a fragment shader.

00:21:25.640 --> 00:21:30.310
They all can reference texture data and outputs
to the frame buffer, your screen, whatever.

00:21:30.309 --> 00:21:32.879
This is the OpenGL programmable pipeline.

00:21:32.880 --> 00:21:38.650
So there's nuances to it and there's more depth
you could go into, but the point here is that GLSL

00:21:38.650 --> 00:21:44.300
and using shaders allows you to directly manipulate data
and simplify the pipeline and allow you to concentrate

00:21:44.299 --> 00:21:50.740
on what you guys do best rather than learning a 200 page
API spec. It allows you to learn exactly the pieces you know

00:21:50.740 --> 00:21:57.529
and learn to, and code to things that are leverage
work we do to make your problem, solve your problem.

00:21:57.529 --> 00:22:00.970
Additional piece we're going to talk about
a little bit today is transform feedback.

00:22:00.970 --> 00:22:06.049
And that's an additional stage that is new with the
fourth generation shading support and it allows you

00:22:06.049 --> 00:22:09.750
to take the output of a geometry shader,
build new primitives, as we talked about,

00:22:09.750 --> 00:22:13.009
and feed them back in to have kind of
a feedback loop, transform feedback.

00:22:13.009 --> 00:22:16.670
So it's transformed and fed back in.

00:22:16.670 --> 00:22:18.100
So what is a vertex shader?

00:22:18.099 --> 00:22:23.849
I think we've covered a lot of this already but really
it replaces a transform and texture coord and generation.

00:22:23.849 --> 00:22:25.909
Transform, texture coord and generation
and lighting parts of OpenGL.

00:22:25.910 --> 00:22:27.840
So that first piece.

00:22:27.839 --> 00:22:32.759
So calculating the light positions, transforming
the vertices from a 3D space to a 2D space.

00:22:32.759 --> 00:22:37.879
In many cases you can do kind of your, If you're
doing image processing kind of things more

00:22:37.880 --> 00:22:42.050
than vertex processing you can just
drop in a piece of existing code.

00:22:42.049 --> 00:22:43.879
You can also do set up for lighting.

00:22:43.880 --> 00:22:45.370
You can do set up for bump mapping.

00:22:45.369 --> 00:22:47.169
You can do set up for some geometry shader.

00:22:47.170 --> 00:22:50.050
So it's a very worthwhile piece.

00:22:50.049 --> 00:22:56.889
An in a little while I'm going to talk about why you really
want to remember that you do have a vertex shader to use.

00:22:56.890 --> 00:22:59.380
Because forgetting the vertex shader and putting everything

00:22:59.380 --> 00:23:02.080
in the fragment shader sometimes the
economy of scale is not very good.

00:23:02.079 --> 00:23:05.210
And we'll talk about that in a few slides.

00:23:05.210 --> 00:23:09.400
The input is like vertices for vertex data,
which you call attributes,

00:23:09.400 --> 00:23:11.920
which I've covered already and state like uniform.

00:23:11.920 --> 00:23:17.880
So constants, things that change for vertex and the vertices
themselves, which vertices you could say change per vertex.

00:23:17.880 --> 00:23:20.910
But basically the idea here is if you
have a color per vertex you're going

00:23:20.910 --> 00:23:22.850
to get a new color, you're going to get a vertex position.

00:23:22.849 --> 00:23:24.339
You can make it a new texture coordinate.

00:23:24.339 --> 00:23:30.289
And you can use these however you'd
like to use them for your vertex shader.

00:23:30.289 --> 00:23:34.299
And kind of the connection you want to make here
is if you're thinking why is this texture coord

00:23:34.299 --> 00:23:36.950
in an OpenGL and I get data in my vertex shader.

00:23:36.950 --> 00:23:42.730
I'm not, I'm not really sure, you
know, how do I get basic data in?

00:23:42.730 --> 00:23:48.829
Well, you have these, all these things, vertex, vertices,
color, texture coordinates are basic just buckets

00:23:48.829 --> 00:23:50.579
of flow data, buckets of vec four flow data.

00:23:50.579 --> 00:23:53.579
So if you think about them in that way
you can make them generic attributes.

00:23:53.579 --> 00:23:57.980
If I want to put in four float numbers into
my vertex shader I send some vertices in.

00:23:57.980 --> 00:23:59.309
I do a draw arrays call.

00:23:59.309 --> 00:24:03.980
I set up some other arrays that are basically
just have my flow data, just array of flow data.

00:24:03.980 --> 00:24:07.079
And the vertex shader gets them and
you can address them as flow data.

00:24:07.079 --> 00:24:08.779
You can call them whenever you want.

00:24:08.779 --> 00:24:13.660
So you can actually not think about it in
the texture coordinate kind of mentality.

00:24:13.660 --> 00:24:19.000
You can actually think about it in the, I
just have vertices and then I have some data.

00:24:19.000 --> 00:24:25.299
So, in this case, for a simple shader all you're going to
do is get a color value that you're passing on in a varying

00:24:25.299 --> 00:24:29.539
and varying are sent through the geometry
shader to the fragment shader and interpolated.

00:24:29.539 --> 00:24:30.960
That was that interpolation.

00:24:30.960 --> 00:24:32.440
I'll talk to you about that in a minute.

00:24:32.440 --> 00:24:37.240
And then F transform is a built in function that
does the standard fix function vertex transform.

00:24:37.240 --> 00:24:41.960
This could be a vertex shader for many people that
would just do enough of what you want it to do.

00:24:41.960 --> 00:24:45.670
You could probably get away with this for many
functions of GLSL that you're going to play with.

00:24:45.670 --> 00:24:48.250
So you don't need to write a lot of code.

00:24:48.250 --> 00:24:49.009
So geometry shader.

00:24:49.009 --> 00:24:50.759
Geometry shader is new for Leopard.

00:24:50.759 --> 00:24:57.390
It's supported in both software and on the new generation
hardware, new generations of hardware and it's run

00:24:57.390 --> 00:25:04.230
after the vertices are transformed but prior to the color
clamping, flash shading, all the rasterization stage of it.

00:25:04.230 --> 00:25:06.299
So basically it kind of fits in the middle.

00:25:06.299 --> 00:25:12.629
I originally had kind of this, you know, I would
think a geometry shader wants to run first.

00:25:12.630 --> 00:25:15.700
You want it to run like before
everything else and build geometry.

00:25:15.700 --> 00:25:19.750
Well, in this case, you actually want to
do the transform and you have the option

00:25:19.750 --> 00:25:22.400
to modify, build, feedback additional geometry.

00:25:22.400 --> 00:25:23.910
So think about it in that way.

00:25:23.910 --> 00:25:28.560
You have some geometry that you transformed into
screen space and then you can do more things with it.

00:25:28.559 --> 00:25:32.460
I think if you were at the modernizing session
you saw we did some shadow volume stuff.

00:25:32.460 --> 00:25:33.490
You can do extrusion.

00:25:33.490 --> 00:25:34.799
You can draw additional lines.

00:25:34.799 --> 00:25:36.279
You can look at adjacencies.

00:25:36.279 --> 00:25:38.670
And Alex is going to come up at the
end and talk about geometry shaders

00:25:38.670 --> 00:25:40.170
and show you some things that you can do with it.

00:25:40.170 --> 00:25:41.519
It's really, really interesting.

00:25:41.519 --> 00:25:45.660
And it does more than you think it can do because
you've got to remember that you're really working

00:25:45.660 --> 00:25:48.360
with basic building blocks and you can
build them in a lot of different ways.

00:25:48.359 --> 00:25:52.250
So it's part of your construction set,
you know, your modern day tinker toys.

00:25:52.250 --> 00:25:55.049
And it does more than just, you know, build a bridge.

00:25:55.049 --> 00:25:58.109
You can build all kinds of things.

00:25:58.109 --> 00:26:00.189
And it outputs vertices to define the primitive.

00:26:00.190 --> 00:26:05.539
So basically the idea here is that you can, in this
case I have just a very simple triangle geometry shader,

00:26:05.539 --> 00:26:07.889
which is a pass through shader, sets the colors.

00:26:07.890 --> 00:26:12.360
So the color or the colors being put out, the
front color in position are colors that'll come in.

00:26:12.359 --> 00:26:13.740
So if you think about this, the geometry shader,

00:26:13.740 --> 00:26:17.120
instead of having a single vertex come
in has three, in this case triangles.

00:26:17.119 --> 00:26:19.209
So it has a zero one and two in an array.

00:26:19.210 --> 00:26:20.910
It reads each of them and does an emit vertex.

00:26:20.910 --> 00:26:23.529
The emit vertex says send the vertex further out.

00:26:23.529 --> 00:26:28.990
So geometry shaders, you don't, you don't particularly
need to understand how they work if you're not using them.

00:26:28.990 --> 00:26:30.890
But in this case it actually is a pretty simple concept.

00:26:30.890 --> 00:26:34.240
So this, again, this is just a pass through geometry shader.

00:26:34.240 --> 00:26:36.109
Fragment shaders, we've been talking about those.

00:26:36.109 --> 00:26:40.419
I've been manipulating those in the talk, showing
you what kind of things you can do with those.

00:26:40.420 --> 00:26:43.640
And basically they operate on a per
fragment state, per fragment basis.

00:26:43.640 --> 00:26:47.840
So every, every pixel on the screen that you
touch, your fragment shader is operating on it.

00:26:47.839 --> 00:26:50.980
If you draw it twice, your fragment
shader is going to operate twice.

00:26:50.980 --> 00:26:55.099
It replaces but through the rasterization,
kind of fix function rasterization.

00:26:55.099 --> 00:26:58.469
Inputs are transform vertices and associated data.

00:26:58.470 --> 00:26:59.289
They're varyings.

00:26:59.289 --> 00:27:05.839
And why is it called a varying vice, you
know, Why is a position does not come back in?

00:27:05.839 --> 00:27:06.399
Think about this.

00:27:06.400 --> 00:27:12.580
Ok, if you think about the, the triangle we drew and
you show that the line of pixels that comes across it,

00:27:12.579 --> 00:27:16.299
and that is actually, Just think, let's make it a line.

00:27:16.299 --> 00:27:19.960
Let's make one end of the line is a red
color, one end of the line is a blue color

00:27:19.960 --> 00:27:21.930
and you want to draw the fragment shader.

00:27:21.930 --> 00:27:25.720
Well, fragment shaders have to touch every fragment
that's going to be shown on the screen so it interpolates.

00:27:25.720 --> 00:27:30.000
And it turns out that color coming through will
be automatically interpolated by the hardware.

00:27:30.000 --> 00:27:33.200
So at one end you get pure blue, one
end you get pure red and every place

00:27:33.200 --> 00:27:35.180
in between the incoming color is interpolated.

00:27:35.180 --> 00:27:40.100
So if you want to think about that when you get,
If you have a constant color every thing's white.

00:27:40.099 --> 00:27:40.689
You just get white.

00:27:40.690 --> 00:27:44.769
But if you want to, you know, colorize
something you can use that vertex color coming in

00:27:44.769 --> 00:27:49.470
and every fragment may have a different variation
of that vertex color on that interpolation.

00:27:49.470 --> 00:27:55.650
And, So in this case, this is actually the wrong shader.

00:27:55.650 --> 00:27:56.680
I apologize.

00:27:56.680 --> 00:27:58.910
The, We've seen some fragment shaders.

00:27:58.910 --> 00:28:01.730
The idea with the fragment shader is you can
actually put out the frag color at the end.

00:28:01.730 --> 00:28:02.210
And I'll show you one.

00:28:02.210 --> 00:28:06.680
Well, actually why don't we go to the demo machine
so I can show you a better fragment shader.

00:28:06.680 --> 00:28:12.190
We'll show you the one line, the
one liner that I showed you before.

00:28:12.190 --> 00:28:18.779
So, in this case, the key here is this frag color
and that frag color is the output color and then all

00:28:18.779 --> 00:28:20.359
of this is going to do is do a texture look-up.

00:28:20.359 --> 00:28:22.979
So this is a basic fragment shader.

00:28:22.980 --> 00:28:27.309
The frag color is, The texture
coordinate is the incoming, incoming data.

00:28:27.309 --> 00:28:29.129
The frag color is the required output.

00:28:29.130 --> 00:28:32.470
If you don't write the frag color the
output of a fragment shader is undefined

00:28:32.470 --> 00:28:38.559
So we can go back to slides.

00:28:38.559 --> 00:28:41.629
So, let's talk about using the API a little bit.

00:28:41.630 --> 00:28:46.790
In utopian world you guys just all
start coding GLSL and everything works.

00:28:46.789 --> 00:28:50.319
Well, you'll have to do a little bit of OpenGL
API to kind of get things wired together.

00:28:50.319 --> 00:28:52.169
So, extensions.

00:28:52.170 --> 00:29:00.100
In Leopard all the top three extensions and the,
basically the fourth one there are supported.

00:29:00.099 --> 00:29:01.990
But you should still be checking for extensions.

00:29:01.990 --> 00:29:04.359
OpenGL has a core set of features.

00:29:04.359 --> 00:29:05.490
It also has a set of extensions.

00:29:05.490 --> 00:29:08.759
Make sure when you use an extension you actually
check with it so if new hardware comes out,

00:29:08.759 --> 00:29:13.039
maybe something gets replaced, maybe we have a new version
of something, you actually know what version you're using.

00:29:13.039 --> 00:29:16.500
The next one, the fourth generation shader
support is two of the pieces you can use.

00:29:16.500 --> 00:29:19.759
If you want to use GPU shader, which
we'll talk about, or geometry shader,

00:29:19.759 --> 00:29:22.359
those are the extensions you check
for to make sure they're supported.

00:29:22.359 --> 00:29:25.699
Again, our plan is have a hardware support
pretty much across the board for these.

00:29:25.700 --> 00:29:29.049
I'm sorry, software support for across the
board and hardware support on the GPU's

00:29:29.049 --> 00:29:30.829
that actually are able to do geometry shaders.

00:29:30.829 --> 00:29:33.710
So those are the extensions.

00:29:33.710 --> 00:29:37.950
Simple thing here is the three last steps are
basically what you have to do to wire things up.

00:29:37.950 --> 00:29:40.370
You have to create your shaders and load the code.

00:29:40.369 --> 00:29:43.750
You have to create a program object,
which is just a container and you have

00:29:43.750 --> 00:29:45.690
to attach the shaders to that program objects.

00:29:45.690 --> 00:29:52.940
And the program objects basically says I want to operate on
this vertex shader and this fragment shader and I'm going

00:29:52.940 --> 00:29:55.330
to put them in my program object and
I'll bind that to make it current.

00:29:55.329 --> 00:29:58.509
So we can imagine that you have,
like Core Image for example.

00:29:58.509 --> 00:30:04.129
Core image would have different effects and different
shaders and they would bind them all up and they would have,

00:30:04.130 --> 00:30:08.360
They would bind whichever one you've selected
as the one you want to make, make active now.

00:30:08.359 --> 00:30:14.199
When I said use, for example, in the example, that
was the same thing, that was using the shader.

00:30:14.200 --> 00:30:19.200
The, What you can do with this model is you can take,
Let's say you have a single vertex shader that works

00:30:19.200 --> 00:30:22.549
for all your fragment shaders, you have a single vertex
shader and a you have a bunch of fragment shaders

00:30:22.549 --> 00:30:27.379
and you combine, combine them, combine that one
to multiple programs that they can cross over.

00:30:27.380 --> 00:30:29.460
So they're discreet objects.

00:30:29.460 --> 00:30:32.480
And then you're going to link it like
you would do for normal for a program.

00:30:32.480 --> 00:30:36.000
You're going to use it and you're going to draw with it.

00:30:36.000 --> 00:30:37.220
Create and shaders.

00:30:37.220 --> 00:30:38.079
Create shader object.

00:30:38.079 --> 00:30:42.039
You're creating objects as a standard OpenGL API there.

00:30:42.039 --> 00:30:46.629
And you can be like vertex shader,
fragment shader or geometry shader.

00:30:46.630 --> 00:30:47.810
You're going to supply the source code.

00:30:47.809 --> 00:30:51.509
And there's a pointer there, which
basically says this is my text source code.

00:30:51.509 --> 00:30:55.420
At that point you can, after that you can call compile.

00:30:55.420 --> 00:30:56.590
We have logs.

00:30:56.589 --> 00:30:58.139
You either, you can check for errors.

00:30:58.140 --> 00:31:02.080
You can look at the logs if you, Actually, let's
jump back to the demo machine for a second.

00:31:02.079 --> 00:31:04.480
Let me put a error down to show you kind of what it does.

00:31:04.480 --> 00:31:08.880
So if I just, if I just do that
you notice we highlight a red line.

00:31:08.880 --> 00:31:11.470
Well, the simple way we do that is we get the error log.

00:31:11.470 --> 00:31:13.680
The error log, it says EC4 instead of vec 4.

00:31:13.680 --> 00:31:15.230
There's no matching overloaded function.

00:31:15.230 --> 00:31:18.200
It tells me a line number and it
says assigned, it can't convert.

00:31:18.200 --> 00:31:19.430
So it puts an error up.

00:31:19.430 --> 00:31:25.640
So, again, if I make that instead of EC4, I make it
back to vec 4, which it recognizes, the log is empty.

00:31:25.640 --> 00:31:27.500
Ok, back to slides.

00:31:30.019 --> 00:31:34.450
So, the part I don't show you here is
that it's a simple function to get a log.

00:31:34.450 --> 00:31:39.279
It's a text file and we use it, for example, on our
sample code to actually give you that interactive editing.

00:31:39.279 --> 00:31:42.930
You can get it in your program and just make sure that
the compile succeeded and there's no error or you can put

00:31:42.930 --> 00:31:44.880
out to the console, whatever you'd like to do.

00:31:44.880 --> 00:31:47.040
Creating a program object, similar.

00:31:47.039 --> 00:31:50.909
Create a program object, you attach your two shaders
that you're going to use and you're done with that.

00:31:50.910 --> 00:31:52.640
Let's move into linking.

00:31:52.640 --> 00:31:53.509
Link program.

00:31:53.509 --> 00:31:58.200
You have a program object, you have attached your shaders,
you link it, you use your program object, you draw something

00:31:58.200 --> 00:32:01.700
and then you can use null to turn off that GLSL, that's it.

00:32:01.700 --> 00:32:06.319
You obviously have to have some geometry, you have
to have some textures and those kinds of things.

00:32:06.319 --> 00:32:07.480
That's pretty standard OpenGL.

00:32:07.480 --> 00:32:08.259
There's lots of examples.

00:32:08.259 --> 00:32:12.970
You can tear apart our samples and use whatever you
want out of them if you have the basis for that.

00:32:12.970 --> 00:32:17.900
If you're not familiar with those pieces in OpenGL or
you might have a lot of stuff set-up already to do that.

00:32:17.900 --> 00:32:21.890
But, in any case, my point is that it's
not that hard to get from where you are,

00:32:21.890 --> 00:32:25.890
I haven't used GLSL before, to using GLSL.

00:32:25.890 --> 00:32:28.240
We talked about constants.

00:32:28.240 --> 00:32:30.680
There's a uniform API that allows you to set constants.

00:32:30.680 --> 00:32:32.759
This is entirely something new.

00:32:32.759 --> 00:32:37.490
Remember, we have a compiler, we have a linker
and we have symbols on the backend of OpenGL now.

00:32:37.490 --> 00:32:40.430
So how do you tie in stuff in the front?

00:32:40.430 --> 00:32:43.750
Like I have three, I want to put
a three into that, in to fu.

00:32:43.750 --> 00:32:44.640
How do I get fu?

00:32:44.640 --> 00:32:52.450
Well, this is basically called get uniform location, my
uniform is fu and it returns basically an opaque value.

00:32:52.450 --> 00:32:55.059
You don't really need to, You don't
want to iterate on the value.

00:32:55.059 --> 00:32:57.779
There's rules about how you can use this
for a raise and those kinds of things.

00:32:57.779 --> 00:33:03.029
But in this case basically assume it's an opaque value
and then you're going to use the uniform 4FV in this case.

00:33:03.029 --> 00:33:08.680
So this is basically going to set any, a
set of uniforms but it's going to set them

00:33:08.680 --> 00:33:12.799
to the value you have, F. F is a vec 4 there.

00:33:12.799 --> 00:33:16.159
And you're basically going to set
that value using the GL uniform API.

00:33:16.160 --> 00:33:22.269
So this is loading those four values in to a
uniform, which the is again sent to your shading.

00:33:22.269 --> 00:33:23.700
Remember, this is a constant API.

00:33:23.700 --> 00:33:27.309
So what this is, if you have like user time interactions.

00:33:27.309 --> 00:33:31.679
So in user time interactions I was dragging those things
around, you know, once, you know, once every few seconds,

00:33:31.680 --> 00:33:34.570
once every, you know, a few times a second and
those kinds of things, constants can work great.

00:33:34.569 --> 00:33:37.839
If you have things that are running per
vertex you don't want to use a uniform.

00:33:37.839 --> 00:33:41.829
So, for example, if you're trying to do lighting, don't
use uniform because lighting should be in those attributes,

00:33:41.829 --> 00:33:43.480
those things that'll change every vertex.

00:33:43.480 --> 00:33:48.339
So you have to understand that there's a
kind of a, I don't want to say a pipe size,

00:33:48.339 --> 00:33:51.730
but it's kind of a rate of change that's assumed here.

00:33:51.730 --> 00:33:54.980
Uniforms, you can do a lot of things in uniforms
and they're very convenient but you don't want

00:33:54.980 --> 00:33:58.860
to do things that change like on a per vertex basis.

00:33:58.859 --> 00:34:05.259
So, that's kind of brushing across the top
of GLSL as far as getting up and going,

00:34:05.259 --> 00:34:08.900
where do you turn to get more information
about the built in functions,

00:34:08.900 --> 00:34:12.740
the built in variables, attributes, varyings, uniforms?

00:34:12.739 --> 00:34:16.049
OpenGL Shading Language orange book, really good book.

00:34:16.050 --> 00:34:19.700
It's a kind of a combination of the
previous red book and blue book.

00:34:19.699 --> 00:34:24.599
It has a reference in it, which is good for
people who know GLSL but it also has a lot

00:34:24.599 --> 00:34:26.900
about the shading language and a ton of examples in it.

00:34:26.900 --> 00:34:33.139
A lot of the GLSL show piece examples that we have, that you
have on your developer DVD come from this book and they're

00:34:33.139 --> 00:34:34.779
up and running for you so you can play with them.

00:34:34.780 --> 00:34:37.480
They have a good interface and all that kind of stuff.

00:34:37.480 --> 00:34:42.070
So, I would suggest that if you're interested
in GLSL you go out and get the orange book.

00:34:42.070 --> 00:34:45.870
I also always suggest that the spec is a
good thing to have by, download the spec,

00:34:45.869 --> 00:34:50.599
make sure you have it because in the end the orange
book could have a typo or we could have changed the spec

00:34:50.599 --> 00:34:55.440
and it's really important to actually
have that reference with you.

00:34:55.440 --> 00:34:59.599
So let's talk about working with hardware.

00:34:59.599 --> 00:35:05.400
So, one thing that's really apparent once you start
working with GLSL is if you have, let me think of something

00:35:05.400 --> 00:35:11.610
that I don't offend someone in the crowd,
let me, you're, you're first, I got it, the,

00:35:11.610 --> 00:35:19.690
the old Wall Street laptop that's a, that's a, maybe
it's a Rage128, maybe it was a Rage2 processor.

00:35:19.690 --> 00:35:22.300
It's not the same as today's GPU.

00:35:22.300 --> 00:35:29.180
So if you really have some really, really crufty old
hardware you can still work in software but understand

00:35:29.179 --> 00:35:32.789
that you want to, you need to understand what the
hardware's capable of because it really matters

00:35:32.789 --> 00:35:36.509
for what the hardware support for GLSL is.

00:35:36.510 --> 00:35:41.450
( Silence )

00:35:41.449 --> 00:35:46.730
So we're going to do five ways to stay
in hardware and to make your life happy.

00:35:46.730 --> 00:35:51.980
Use Moto (sp?) hardware that gets back to my,
my, the old, the old brown PowerBook that,

00:35:51.980 --> 00:35:55.230
At this point I don't even know if it was brown laptop.

00:35:55.230 --> 00:36:01.199
At this point the new hardware that will come out is
hugely better than what we've had in generations past.

00:36:01.199 --> 00:36:05.029
The brand new hardware on our laptops in now
capable of the fourth generation shading language.

00:36:05.030 --> 00:36:09.500
So really the hardware support is amazing these days.

00:36:09.500 --> 00:36:14.889
So, vertex/fragment program-capable hardware
is required to get hardware GLSL support.

00:36:14.889 --> 00:36:20.500
So if it has vertex or fragment program
support it will have GLSL, basic GLSL support.

00:36:20.500 --> 00:36:23.210
And proof support is on the Radeon 1600 and later.

00:36:23.210 --> 00:36:31.059
So what that means is every Intel iMac, every
Intel MacBook Pro has pretty improved GLSL support.

00:36:31.059 --> 00:36:33.469
There's some things it still can't
do but they work really well.

00:36:33.469 --> 00:36:37.219
Also our desktops, obviously, the desktops with the NV 7300,

00:36:37.219 --> 00:36:42.359
ATIX 1900 or the Quadro (sp?) all
have very good GLSL support.

00:36:42.360 --> 00:36:49.110
NVIDIA 6600 and later again, means all Intel
NVIDIA products have good support.

00:36:49.110 --> 00:36:52.829
The exceptions to this is the MacBook,
which has reasonable support

00:36:52.829 --> 00:36:57.860
but doesn't have the same level support
as the Pro products or as the iMac.

00:36:57.860 --> 00:37:02.120
The fourth generation shading support, which we talked
about a little bit, is available on our newest laptops

00:37:02.119 --> 00:37:09.210
in hardware, which is the Geforce 8600 MGT and in
Leopard you will see that we have hardware support

00:37:09.210 --> 00:37:15.500
for geometry shader, transform feedback, GPU shader and
bindable uniforms, which make up kind of the core of a lot

00:37:15.500 --> 00:37:18.269
of the fourth generation shading extensions.

00:37:18.269 --> 00:37:22.300
We want, I want to emphasize that you want
to test your shaders on the target hardware.

00:37:22.300 --> 00:37:24.750
This is not something that works
everywhere exactly the same.

00:37:24.750 --> 00:37:30.219
You want to make sure that if you have some shader that's
reasonably complicated you want to run it and verify

00:37:30.219 --> 00:37:34.949
that it runs on the hardware that
you're targeting to put your product on.

00:37:34.949 --> 00:37:38.289
One thing you also can do here is to
determine where your shader is executing.

00:37:38.289 --> 00:37:43.590
It may not be clear that, You have a very good software
fall back mechanism and in some of the high end CPU's

00:37:43.590 --> 00:37:49.829
if your vertex shader falls back to software, I
mean, let's do a little sidetrack here.

00:37:49.829 --> 00:37:52.710
So Alex is working on some demos and I
walk into his office and he's running it

00:37:52.710 --> 00:37:54.929
and I'm like, is that running on hardware?

00:37:54.929 --> 00:38:00.169
You don't know because he's working the vertex and geometry
shader side of things and really he's not sending a ton

00:38:00.170 --> 00:38:03.789
of vertices down and geometry shader
runs really fast on a fast CPU

00:38:03.789 --> 00:38:06.190
so you don't really know if it's on hardware or software.

00:38:06.190 --> 00:38:12.289
So the way you can tell is we have these queries that we've
added and they've been in for a while and these allow you

00:38:12.289 --> 00:38:17.059
to determine whether your shaders and any OpenGL
actually is running on hardware or software.

00:38:17.059 --> 00:38:22.059
There's a vertex fragment processing part, is it running
on the GPU and there's a vertex processing query.

00:38:22.059 --> 00:38:25.289
And these will tell you, basically
returning how they are, yes or no.

00:38:25.289 --> 00:38:26.519
In this case they're true or false.

00:38:26.519 --> 00:38:27.920
Sorry, one or zero.

00:38:27.920 --> 00:38:31.059
And it'll tell you whether they actually run on the GPU.

00:38:31.059 --> 00:38:37.409
So you compile, link and bind your shader, you can call
this and it'll tell you where it's going to execute.

00:38:37.409 --> 00:38:40.599
I highlighted this earlier, that
you want to think in vectors.

00:38:40.599 --> 00:38:45.400
So what you want to do is you want to actually expand
your thinking or widen your thinking out to think in,

00:38:45.400 --> 00:38:47.510
try and put your problem into vector space.

00:38:47.510 --> 00:38:50.100
If you can do more work at one time, that's great.

00:38:50.099 --> 00:38:51.529
Life is a good example.

00:38:51.530 --> 00:38:57.210
While it was drawing white on the board it actually is doing
three calculations at a time and some of the other things.

00:38:57.210 --> 00:38:58.980
The color blending is doing three calculations at a time.

00:38:58.980 --> 00:39:03.369
You could easily have done the color blending or the
edge filter, I could have created three uniforms,

00:39:03.369 --> 00:39:07.909
controlled each independently, labeled
one like base and labeled one like offset

00:39:07.909 --> 00:39:10.619
and then labeled one magnitude or something like that.

00:39:10.619 --> 00:39:16.869
But instead I used a single vector and we can actually
pull those in in one piece, which saves, you know,

00:39:16.869 --> 00:39:26.489
kind of saves real estate in the CPU but the big thing
is if you can execute using Y data you should do that.

00:39:26.489 --> 00:39:33.889
So GPU is a vector processor, combine operations,
float/init, going to be wasting, I mean, it's going to be,

00:39:33.889 --> 00:39:37.609
It has these empty components it basically does the
operation, whether you put something in it or not

00:39:37.610 --> 00:39:41.510
or you care about it, it's going to do
the operation in the full vector format.

00:39:41.510 --> 00:39:46.750
So if you have one value you're calculating, the other
values are actually being calculated and just discarded.

00:39:46.750 --> 00:39:53.210
So instead use vec of something or i vec of
something so vec 3, vec 2, vec 3, vec 4, for example,

00:39:53.210 --> 00:39:57.690
the first thing is just doing some math, some valid
code, absolutely valid, no problems with that.

00:39:57.690 --> 00:40:03.000
But you could easily do it by setting some vectors,
adding two vectors together and you get the same values.

00:40:03.000 --> 00:40:06.760
So that's something to keep in mind when you're
doing, you need to crease the number of instructions.

00:40:06.760 --> 00:40:11.700
With the lower end, we talked about hardware, with lower
end GPU's the number of instructions can be limited

00:40:11.699 --> 00:40:14.599
so you want to make sure you have a compact program.

00:40:14.599 --> 00:40:20.319
And if you're in a fragment program remember when I
talked about processing power and talked about fill ray

00:40:20.320 --> 00:40:26.110
and talk about bandwidth, every single time you do
a, do a, you know, go to memory pull it back in,

00:40:26.110 --> 00:40:29.140
send it back out to the GPU memory
that's, that's doing processing.

00:40:29.139 --> 00:40:30.469
So you're throwing away that bandwidth.

00:40:30.469 --> 00:40:34.349
If you have a high, you know, top line
bandwidth, why don't I run so fast?

00:40:34.349 --> 00:40:40.569
Well, if you do three adds instead of one add and
you do it on a million pixels that's, you know,

00:40:40.570 --> 00:40:44.990
three million more adds then, or two
million more adds then you would have had

00:40:44.989 --> 00:40:47.659
to do if you'd just combined them to a vector.

00:40:48.969 --> 00:40:54.509
So use vertex processing when you can.

00:40:54.510 --> 00:40:58.890
It may seem like some of the things I've talked about,
and it is, it's easy to do things in fragment programs

00:40:58.889 --> 00:41:02.819
because they're operating on a per pixel basis, you can
think in that, Oh, it's just a pixel I can change the color.

00:41:02.820 --> 00:41:03.910
It's great.

00:41:03.909 --> 00:41:05.500
I can see what's going on.

00:41:05.500 --> 00:41:07.710
Vertex for programs are really your friend.

00:41:07.710 --> 00:41:14.820
Ok. So if you're calculating something in a fragment
program that is constant across a vertex program,

00:41:14.820 --> 00:41:20.110
or a set of fragments or all your fragments
move that calculation into a vertex program.

00:41:20.110 --> 00:41:23.289
Do whatever you can to get that calculation
moved out of the fragment even if you're,

00:41:23.289 --> 00:41:26.329
Let's say you have a linear interpolation
between two values.

00:41:26.329 --> 00:41:28.079
Think about that and get it out of the fragment.

00:41:28.079 --> 00:41:32.730
You do not want to be linearly
interpolating in your fragment program.

00:41:32.730 --> 00:41:34.039
So Quake 3.

00:41:34.039 --> 00:41:38.360
We're going back a little ways but Quake
3 has about 10,000 vertices per frame.

00:41:38.360 --> 00:41:38.800
Not too bad.

00:41:38.800 --> 00:41:40.330
That's kind of a lot.

00:41:40.329 --> 00:41:41.569
What does a cinema display have?

00:41:41.570 --> 00:41:45.200
A cinema display has four million pixels.

00:41:45.199 --> 00:41:48.429
Let's assume your program has a little bit
of overdraw so you're blending a little bit.

00:41:48.429 --> 00:41:50.730
You're doing, Like the Mac OS X desktop has blending.

00:41:50.730 --> 00:41:51.360
You're doing blending.

00:41:51.360 --> 00:41:51.970
That's overdraw.

00:41:51.969 --> 00:41:54.519
So you touch a pixel twice, 50 percent overdraw.

00:41:54.519 --> 00:41:58.750
You're now touching six million
fragments to draw that 30 inch display.

00:41:58.750 --> 00:42:03.469
So if you're doing something and you're drawing to
the screen, you're drawing six million fragments.

00:42:03.469 --> 00:42:05.969
So how do you think about that?

00:42:05.969 --> 00:42:11.899
If I have to do like calculate value A in a fragment
program and I could have done that calculated value A,

00:42:11.900 --> 00:42:14.789
which is a constant across fragment
programs and vertex programs,

00:42:14.789 --> 00:42:18.489
what's the relative scale of the
work that I'm kind of doing?

00:42:18.489 --> 00:42:29.369
So, the little dot two scale is the relative workload
on your 10,000 vertices, point zero five inches.

00:42:29.369 --> 00:42:34.420
The big thing that doesn't fit on the
screen is your relative fragment load.

00:42:34.420 --> 00:42:38.940
New architectures or unified shader
models, unified execution units,

00:42:38.940 --> 00:42:41.440
it sends execution units where it needs to go.

00:42:41.440 --> 00:42:46.960
So if you were calculating that, my important value,
if you're calculating that every single fragment,

00:42:46.960 --> 00:42:52.030
and it's actually constant, you are, it's 4000 to
one or something like that I calculated in this case.

00:42:52.030 --> 00:42:54.710
You're doing 4000 to one extra calculations.

00:42:54.710 --> 00:42:58.740
You want to move that work into the vertex
processor and only do it a few times.

00:42:58.739 --> 00:43:00.019
So think about your problem in that way.

00:43:00.019 --> 00:43:08.170
If you have some kind of gradient you're calculating that's
interesting, maybe you can make 15 vertices or 15 triangles

00:43:08.170 --> 00:43:14.070
that show, cover the gradient rather than doing some precise
calculation in the fragment program to do the gradient

00:43:14.070 --> 00:43:15.660
that you're actually burning fragment program cycles.

00:43:15.659 --> 00:43:19.529
So when you zoom in you have a huge number
of fragments calculating the same value.

00:43:19.530 --> 00:43:27.970
Think about things in that way, using a mesh, animating on
meshes, using meshes to control geometry can really be a win

00:43:27.969 --> 00:43:31.759
when you're doing, compared to direct fragment
manipulation, if it fits your problem.

00:43:31.760 --> 00:43:37.690
Sometimes you want to really get that, that reflection
of factor, that really nice sheen on that surface

00:43:37.690 --> 00:43:43.480
and you really want that per fragment thing, absolutely do
that on, do that on the fragment shader but think about it

00:43:43.480 --> 00:43:45.230
because you don't want to always be in the fragment shader.

00:43:45.230 --> 00:43:47.369
Fragment shader is not the bucket
for every single calculation.

00:43:47.369 --> 00:43:51.719
Remember the vertex shader, remember it's there,
it operates on a lot less, a lot less vertices.

00:43:51.719 --> 00:43:57.059
A really good example of this is like the Core Image kind
of application where you have all of four vertices total

00:43:57.059 --> 00:43:59.570
and you have the 30 inch display worth of zoomed in thing.

00:43:59.570 --> 00:44:05.180
Aperture has this huge display, well you can do
it four million times or you can do it four times.

00:44:05.179 --> 00:44:06.980
So that's a million to one kind of calculation.

00:44:06.980 --> 00:44:08.490
So think about that when you're coding.

00:44:08.489 --> 00:44:12.339
If it's constant move it to the vertex side.

00:44:12.340 --> 00:44:15.910
Geometry shader, the note here is geometry
shader operates on relative to primitive.

00:44:15.909 --> 00:44:18.309
So every primitive, every set of
three vertices, for example,

00:44:18.309 --> 00:44:20.449
on a triangle is going to be operating geometry shader.

00:44:20.449 --> 00:44:24.509
So geometry, these kinds of vertex shaders
are 10,000 times maybe, 10,000 vertices

00:44:24.510 --> 00:44:29.050
and then maybe the geometry shader
operates on 4000 triangles
@

00:44:29.050 --> 00:44:32.650
and then this fragment shader operates
a million of the pixels.

00:44:32.650 --> 00:44:37.150
One more thing on that is vertex shader you
control the amount of data that you're getting

00:44:37.150 --> 00:44:38.960
into them, how many triangles you have in there.

00:44:38.960 --> 00:44:43.269
Fragment shader if they drag your window bigger your
fragment load goes way up or you can make it smaller.

00:44:43.269 --> 00:44:48.019
So understand that you control one and
the, kind of the user controls the other.

00:44:48.019 --> 00:44:49.989
So let's talk about branching.

00:44:49.989 --> 00:44:51.709
So branch judiciously.

00:44:51.710 --> 00:44:56.820
Branching is not supported overall and
every GPU is not supported very well.

00:44:56.820 --> 00:45:00.260
So I'm going to go into some details for
people who have been using GLSL before.

00:45:00.260 --> 00:45:03.490
If you're new, just breathe for
a little bit and we'll get back

00:45:03.489 --> 00:45:09.309
into some more interesting for
the, for the new folks in a second.

00:45:09.309 --> 00:45:11.840
So dynamic branching.

00:45:11.840 --> 00:45:19.840
Geforce 5200 ATI 9600 and the Intel embedded
processors have less supported branching.

00:45:19.840 --> 00:45:21.559
They don't really have a lot of good branching support.

00:45:21.559 --> 00:45:26.210
So you've got to be really careful using shaders
on, shaders that use branching on those processors.

00:45:26.210 --> 00:45:32.840
All the iMacs, MacBook Pros, any NVIDIA
Intel product have very good branching support.

00:45:32.840 --> 00:45:34.400
It's easy to stay in hardware.

00:45:34.400 --> 00:45:39.579
You still, in some of, everything but our newest
laptops you still may have loop iteration constraints.

00:45:39.579 --> 00:45:40.940
So 255 is a good number.

00:45:40.940 --> 00:45:43.329
So you don't want to really do looping more than 255.

00:45:43.329 --> 00:45:47.289
The newest stuff is, is, really
these days are getting wide open.

00:45:47.289 --> 00:45:56.529
If you get one of the new laptops what you'll really see
is that while it may, you may not see huge improvement

00:45:56.530 --> 00:46:02.130
in drawing a screen but you see a huge massive
improvement in the amount, the length of shaders,

00:46:02.130 --> 00:46:06.450
the branching you can do, the amount
of, the kind of instructions it supports

00:46:06.449 --> 00:46:13.549
and it's just an amazingly more powerful programmable piece
of hardware with the kind of unified execution models.

00:46:13.550 --> 00:46:16.960
So that's where those things, That's
the axis those are progressing on.

00:46:16.960 --> 00:46:19.949
And that actually takes away a lot of this stuff.

00:46:19.949 --> 00:46:20.829
Not so dynamic branching.

00:46:20.829 --> 00:46:22.380
So this is your limited support thing.

00:46:22.380 --> 00:46:23.690
So what do we want to do here?

00:46:23.690 --> 00:46:27.619
We want to do like less than ten iterations
because we're on a loop and roll it.

00:46:27.619 --> 00:46:33.109
So if you're going to do 100 iterations on something that
doesn't have a very large set of instructions it can operate

00:46:33.110 --> 00:46:36.500
on anyway you don't want to, because we're
going to unroll it on these processors

00:46:36.500 --> 00:46:38.239
because they don't support our dynamic branching.

00:46:38.239 --> 00:46:43.839
So the key here is to use supportive loop
forms, limit the number of iterations you have.

00:46:43.840 --> 00:46:47.660
Those two forms are basic, some basic loop forms
that do exactly what you think they would do.

00:46:47.659 --> 00:46:49.039
You basically have an iterator.

00:46:49.039 --> 00:46:53.369
You increment the iterator and you don't
do any other kind of calculations in there.

00:46:53.369 --> 00:46:59.789
So basically you can loop as a constructing program but
we are, in the back end, going to unroll that for you.

00:46:59.789 --> 00:47:02.980
So loop iterator cannot change anywhere in the loop body.

00:47:02.980 --> 00:47:05.550
Conditioning cannot change over the loop.

00:47:05.550 --> 00:47:09.500
Starting any iteration value should be constant
ints so you should you should constants in there.

00:47:09.500 --> 00:47:13.340
So you should start from zero go to ten
or whatever it is, zero less than ten.

00:47:13.340 --> 00:47:15.160
No degation to swizzle.

00:47:15.159 --> 00:47:19.199
So you shouldn't be, Swizzling is
changing the vector pieces around.

00:47:19.199 --> 00:47:24.359
So you shouldn't be having, use X and Y and swizzling
them to actually determine when your loop ends.

00:47:24.360 --> 00:47:27.180
And avoid complex loop parts.

00:47:27.179 --> 00:47:29.750
For example, the first one can be
simplified in to the second one.

00:47:29.750 --> 00:47:34.510
So the first one basically is, I have
kind of the bail out case in my loop.

00:47:34.510 --> 00:47:38.500
So I have the loop iterates five times and then I want
to bail out if something, if some value hits something.

00:47:38.500 --> 00:47:44.619
This is something from, I believe, the man that brought
the shader in the GLSL showpiece and you can make it run

00:47:44.619 --> 00:47:47.500
in hardware by simply moving to the second form.

00:47:47.500 --> 00:47:50.070
The second form basically says
I'm going to iterate five times.

00:47:50.070 --> 00:47:53.470
We're going to unroll those five times and then
we're going to put the five if statements in.

00:47:53.469 --> 00:47:57.609
So you don't want to have that complex loop part.

00:47:57.610 --> 00:47:58.880
So fragment shader branching.

00:47:58.880 --> 00:48:04.750
A less capable GPU is on the same
set of the older NVIDIA products,

00:48:04.750 --> 00:48:11.010
the older kind of PowerPC generation kind
of ATI products and the new, the newer, the MacBooks.

00:48:11.010 --> 00:48:12.890
We have less fragments.

00:48:12.889 --> 00:48:15.049
Fragment shader branching not very supported.

00:48:15.050 --> 00:48:17.920
One of the issues here is they only
have like 96 instructions, for example,

00:48:17.920 --> 00:48:20.920
total with 32 texture instructions, 64 math instructions.

00:48:20.920 --> 00:48:22.559
So you don't have a lot of instructions.

00:48:22.559 --> 00:48:25.929
So let's say your loop is six instructions,
you know, that gives you the ten.

00:48:25.929 --> 00:48:28.799
But let's say you have 15 other
instructions, well then it won't fit.

00:48:28.800 --> 00:48:31.160
So the loop unrolling is going to blow both things up.

00:48:31.159 --> 00:48:35.179
And additionally Sine, Cosine and Tangent,
those kind of things can expand out.

00:48:35.179 --> 00:48:39.839
Some of the instructions can expand to larger set
of instructions so if you have one Syn you could do

00:48:39.840 --> 00:48:43.410
that ten times in a shader and
you're out of instructions basically.

00:48:43.409 --> 00:48:46.949
So remember that when you're working
with less capable hardware.

00:48:46.949 --> 00:48:49.089
Conditionals, kind of same set of hardware.

00:48:49.090 --> 00:48:53.970
I mean, the idea here is basically everything we've
shipped on an Intel, and this is not something, you know,

00:48:53.969 --> 00:48:57.379
we designed it this way, this is where the state
of the hardware is when we did in transition.

00:48:57.380 --> 00:48:59.390
Made a really nice spot for a transition.

00:48:59.389 --> 00:49:05.549
Intel, mostly Intel hardware can really do fairly
well in the ATI and NVIDIA side can do well for GLSL.

00:49:05.550 --> 00:49:11.750
So basically for conditionals you want to avoid
return break continue inside of conditionals.

00:49:11.750 --> 00:49:14.840
And don't use if statements to call the
same function with a set of arguments.

00:49:14.840 --> 00:49:18.870
It's just this is, this is a kind of
be nice to the compiler time, don't,

00:49:18.869 --> 00:49:22.059
don't hurt your compiler, it's trying to be nice to you.

00:49:22.059 --> 00:49:27.150
The first one basically says when we go through the
optimization step we see the two function calls and we have

00:49:27.150 --> 00:49:31.639
to do a lot more work and to understand
that's what you're doing.

00:49:31.639 --> 00:49:33.239
All you're doing is sending a value and calling a function.

00:49:33.239 --> 00:49:36.429
So do the second one, select the value you
want to do and then call the function with it.

00:49:36.429 --> 00:49:40.190
And that's really easy, the second one
is really easy to unroll and really easy

00:49:40.190 --> 00:49:42.470
to work with, especially on these hardware.

00:49:42.469 --> 00:49:45.349
But the latest generation hardware the first one's fine.

00:49:45.349 --> 00:49:48.069
It just works.

00:49:48.070 --> 00:49:53.200
So last thing is in working with
hardware, where is the cool shader stuff?

00:49:53.199 --> 00:49:57.059
Where is that new kind of cool stuff?

00:49:57.059 --> 00:50:02.000
So advanced shader support is on,
We have differencing functions.

00:50:02.000 --> 00:50:03.909
We have some shader texture LOD.

00:50:03.909 --> 00:50:08.149
We have noise functions and we have the final,
the fourth generation shading and support.

00:50:08.150 --> 00:50:10.440
The differencing functions are on again.

00:50:10.440 --> 00:50:12.200
The newest hard, the same set of hardware.

00:50:12.199 --> 00:50:16.029
So it's the...it turns out the 5200, in this
cRase, has it so that drops down a little bit.

00:50:16.030 --> 00:50:20.610
But all the, all the new Intel, ATI and NVIDIA hardware
has a differencing, or has a...I'm sorry, that's,

00:50:20.610 --> 00:50:22.059
that's not, yeah, that's correct, that's correct.

00:50:22.059 --> 00:50:24.130
I was thinking, noise is software only.

00:50:24.130 --> 00:50:24.510
That's correct.

00:50:24.510 --> 00:50:27.590
And the same thing with basically the shader texture LOD.

00:50:27.590 --> 00:50:30.850
And then for noise support right
now we have noises in software only.

00:50:30.849 --> 00:50:33.650
I believe by the time Leopard ships,
and I don't want to promise this,

00:50:33.650 --> 00:50:38.039
but I believe we'll have a noise implementation
because we have enough space to do it, kind of in,

00:50:38.039 --> 00:50:42.019
micro code is not the right word, but in software
what we do with kind of software insertion.

00:50:42.019 --> 00:50:44.610
You call a noise and we're going to put a
block of code in that does the equivalent

00:50:44.610 --> 00:50:48.599
of our software noise on the newest, the 8600.

00:50:48.599 --> 00:50:51.519
But everything else is going to be dropped
to software if you try and do noise.

00:50:51.519 --> 00:50:55.429
The thing you do here instead, which is a standard
technique, is shown even in the orange book is

00:50:55.429 --> 00:50:58.309
to use a noise texture, 3D texture pregenerated noise.

00:50:58.309 --> 00:51:01.659
You do a look up in it based on some values
and it'll give you a good noise function.

00:51:01.659 --> 00:51:05.349
The noise, noise you can get a little bit
deeper but it works, that works pretty well.

00:51:05.349 --> 00:51:10.759
And finally the fourth generation shading
support in hardware on the 8600 MGT and later

00:51:10.760 --> 00:51:14.180
and in software we're going to
look to produce it everywhere.

00:51:14.179 --> 00:51:19.039
So basically what happens is if you don't have hardware
geometry shader support your vertex processing will fall

00:51:19.039 --> 00:51:21.500
back to the CPU, not a bad thing
depending on what you're doing.

00:51:21.500 --> 00:51:26.980
I mean, if you're the latest generation 3D game app
it may not work for you but if you're doing an app

00:51:26.980 --> 00:51:31.579
and you have a little bit CPU overhead, we have
multi-cores, it may work really well for you.

00:51:31.579 --> 00:51:33.610
Again, economy of scale.

00:51:33.610 --> 00:51:38.829
Few vertices, lots of fragments, the vertex and
geometry stuff is not executing a lot and it will base,

00:51:38.829 --> 00:51:46.659
it'll very easily be able to fit it on that hardware
or on the CPU and that should happen automatically.

00:51:46.659 --> 00:51:49.239
So that's what's new in Leopard.

00:51:49.239 --> 00:51:54.399
So basically what we're going, What's new in Leopard,
we covered this last year and some of this has changed

00:51:54.400 --> 00:51:59.000
but it, I just want to add a few things to it.

00:51:59.000 --> 00:52:00.860
Fourth generation shading support,
we've already talked about that.

00:52:00.860 --> 00:52:04.599
That was for geometry and GPU shaders,
binable uniforms, transform feedback.

00:52:04.599 --> 00:52:11.670
We're improving the profiler to give shader
editing and we're adding a new shader builder.

00:52:11.670 --> 00:52:13.180
Shading language one point two.

00:52:13.179 --> 00:52:21.019
So in the shading language one point two stuff
basically all it does is add some new syntax

00:52:21.019 --> 00:52:23.980
or new options to the shading language itself.

00:52:23.980 --> 00:52:25.119
There's new specification out.

00:52:25.119 --> 00:52:26.650
You can look at the details in it.

00:52:26.650 --> 00:52:31.250
Some of the things we have, we have invariance so
you can use fixed function and programming together.

00:52:31.250 --> 00:52:37.530
We have centroid variants for multi-sample, non-square
matrixes and we have additional built in functions.

00:52:37.530 --> 00:52:40.769
Other things we've promoted arrays to first class objects.

00:52:40.769 --> 00:52:43.820
We've added a link thing so you
can iterate over arrays in length.

00:52:43.820 --> 00:52:46.440
There's automatic conversions from in to float.

00:52:46.440 --> 00:52:49.599
So that's something that one point two has,
make it a little bit more convenient for you.

00:52:49.599 --> 00:52:54.069
And finally uniform initializers, which
gives you the ability to have some basic,

00:52:54.070 --> 00:53:01.580
some basic good values for your uniforms that you can
have to start with instead of starting from scratch.

00:53:01.579 --> 00:53:07.059
So shader builder, you do not have it in your
beta but before Leopard ships we'll be seeding it

00:53:07.059 --> 00:53:11.469
and you'll be able to, with, when Leopard
ships you'll have a new shader builder.

00:53:11.469 --> 00:53:14.619
Basically it's kind of a combination between
our editor sample and the old shader builder.

00:53:14.619 --> 00:53:16.769
It combines our programs and shaders.

00:53:16.769 --> 00:53:19.460
It allows automatic compilation
parts in editing as you've seen.

00:53:19.460 --> 00:53:21.900
It has a plug-in architecture of geometry.

00:53:21.900 --> 00:53:23.410
We're going to give some little extensible.

00:53:23.409 --> 00:53:28.049
It won't be the deepest architecture but it allows you to
bring in some of your own models and kind of work with that

00:53:28.050 --> 00:53:30.510
and some of your own information into the vertex pipeline.

00:53:30.510 --> 00:53:33.550
It's going to have much improved texture
handling for cube maps, 3D textures,

00:53:33.550 --> 00:53:35.970
those kind of things and it'll be coming soon.

00:53:35.969 --> 00:53:40.919
At the end I'll put up a CD mail if you're
interested in getting on our OpenGL CD you can do that

00:53:40.920 --> 00:53:43.650
and we'll be CDing it to you at some point.

00:53:43.650 --> 00:53:53.480
So I'm going to jump into a quick demo here
and just show you some debugging with the,

00:53:53.480 --> 00:53:57.510
from OpenGLSL showpiece, which is what I showed you before.

00:53:57.510 --> 00:54:08.490
And I'm going to open GL Profiler and kind of
show you how you can attach and debug a shader.

00:54:08.489 --> 00:54:12.069
So we've attached and what I'm going to do is
I'm going to bring up the break point view.

00:54:12.070 --> 00:54:16.690
And this, we'll talk about this tool more in depth
in one of our sessions on tuning this afternoon.

00:54:16.690 --> 00:54:19.500
I'm going to break on the flush
and so now you see it stopped.

00:54:19.500 --> 00:54:23.610
I have a back trace and what I can do is I
also have a view that's a resources view.

00:54:23.610 --> 00:54:26.250
Resources view contains information about shaders.

00:54:26.250 --> 00:54:28.449
So we click on that and you see a number of shader objects.

00:54:28.449 --> 00:54:33.489
This is a program object that actually is drawing
the teapot and you can see it has the uniforms,

00:54:33.489 --> 00:54:36.609
it has some of the built in uniforms,
it has some attributes.

00:54:36.610 --> 00:54:39.670
We've all talked about that during
the day and has their current values.

00:54:39.670 --> 00:54:45.099
You also can look at that it has actually
the fragment shader we have here in,

00:54:45.099 --> 00:54:48.860
in the...it shows you the code you have.

00:54:48.860 --> 00:54:53.160
So let's say I want to see actually how the
texture coordinates are represented on this teapot.

00:54:53.159 --> 00:54:58.469
What I can do here instead of using the color value I got,
I'm just going to substitute it in, the GL text coord.

00:54:58.469 --> 00:54:59.730
I can hit a compile thing.

00:54:59.730 --> 00:55:01.500
It says compile succeeded.

00:55:01.500 --> 00:55:06.019
And then I'm going to step through a
few frames and see what it shows me.

00:55:06.019 --> 00:55:15.139
So in this case what it did was it basically ran that shader
and basically used the text coords as the output color.

00:55:15.139 --> 00:55:19.039
And so you can use this kind of method to put things
in the output color and see what your shader is doing.

00:55:19.039 --> 00:55:22.769
You can turn things on, turn things off while
you're running, debug your program on the fly

00:55:22.769 --> 00:55:26.639
and so you don't always have to go out to your editor,
change some things and go back in your program.

00:55:26.639 --> 00:55:34.309
So that's the idea here as we allow that
shader builder actually, or allow that.

00:55:34.309 --> 00:55:38.940
You'd use Profiler to actually debug your
shaders without having to actually open

00:55:38.940 --> 00:55:42.090
up your app, recompile your app all the time.

00:55:42.090 --> 00:55:46.289
And we'll talk more about the nuances of using
Profiler, give you the touring, you will tour it,

00:55:46.289 --> 00:55:50.230
talk about all the windows what they actually
do in the tuning session this afternoon.

00:55:50.230 --> 00:55:55.090
And so that's, If you want to go learn more about
actually how to use a tool, we'll talk about it there.

00:55:55.090 --> 00:55:56.680
So back to slides, please.

00:55:56.679 --> 00:56:03.609
And finally I'm going to finish up with a
little bit on fourth generation shading support.

00:56:03.610 --> 00:56:06.769
I don't want to go into too much depth.

00:56:06.769 --> 00:56:08.989
I'm not going to try and teach you these
shading support today but I'll talk

00:56:08.989 --> 00:56:10.449
to you about, give you an idea about what it is.

00:56:10.449 --> 00:56:14.219
I think a lot of this stuff I've already talked
about and then we'll kind of review some of it.

00:56:14.219 --> 00:56:17.769
So geometry shaders, creates new
primitive from existing ones.

00:56:17.769 --> 00:56:20.980
It can be a single point, line or triangle input.

00:56:20.980 --> 00:56:22.460
You also have adjacency information.

00:56:22.460 --> 00:56:26.170
You have information that says what's beside
it so you can actually have a line strip.

00:56:26.170 --> 00:56:28.769
And Alex will show you some things
in a few minutes about that.

00:56:28.769 --> 00:56:29.809
The output is fixed.

00:56:29.809 --> 00:56:31.519
You have to actually decide what it is.

00:56:31.519 --> 00:56:33.880
Going in you have to say this geometry
shader has this kind of output.

00:56:33.880 --> 00:56:35.470
I'm outputting triangles, for example.

00:56:35.469 --> 00:56:40.039
So geometry shaders are kind of designed specifically
for the kind of output they're going to have.

00:56:40.039 --> 00:56:42.050
They don't really on the fly change their output.

00:56:42.050 --> 00:56:45.800
Line, point line strip, triangle strip
and you can output multiple primitives.

00:56:45.800 --> 00:56:48.910
So you can have one set of triangles come
in and you can test light, for example.

00:56:48.909 --> 00:56:53.589
So you can build out multiple primitives so you
can smooth your surface using a geometry shader.

00:56:53.590 --> 00:56:58.300
It's executed after the vertex shader and before
the fragment shader, like we talked about.

00:56:58.300 --> 00:57:02.990
And typical uses, point sprites so you can generate
geometry, you can have a point and generate geometry.

00:57:02.989 --> 00:57:03.909
You can do tessellation.

00:57:03.909 --> 00:57:05.539
You can do extreme shadow volumes.

00:57:05.539 --> 00:57:06.489
We showed that yesterday.

00:57:06.489 --> 00:57:09.269
And you can do some single pass rendering to a cube map.

00:57:09.269 --> 00:57:12.280
The idea here is to get the work to the GPU.

00:57:12.280 --> 00:57:17.330
The two things you need to know in your shader are
very simple, emit vertex and emit end primitive.

00:57:17.329 --> 00:57:21.599
If you're going to do multiple primitives you have to end
primitive after each one, emit vertex for each vertex.

00:57:21.599 --> 00:57:27.569
So the pass through one just goes emit vertex, emit vertex,
emit vertex, the same triangle that came in goes out.

00:57:27.570 --> 00:57:28.950
That's geometry shader.

00:57:28.949 --> 00:57:34.539
You'll be able to play with this. My recommendation
is wait for the next seed because we're going

00:57:34.539 --> 00:57:42.130
to clean some things up and, but it is, it is
on in software right now on the beta you have.

00:57:42.130 --> 00:57:43.820
GPU shader, haven't talked about this a lot.

00:57:43.820 --> 00:57:45.920
It's really a grab bag of a lot of different stuff.

00:57:45.920 --> 00:57:48.590
It allows you to basically do integer textures.

00:57:48.590 --> 00:57:53.050
So it allows you to put a list of integers,
a big array into a texture and access them

00:57:53.050 --> 00:57:55.450
like an integer rather than a floating point value.

00:57:55.449 --> 00:57:58.299
I put the long list of different types it represents.

00:57:58.300 --> 00:58:00.140
It's a huge spec, 38 pages.

00:58:00.139 --> 00:58:03.829
I don't know if that's huge but 38 pages is a pretty
long spec. It has a lot of different stuff to it.

00:58:03.829 --> 00:58:08.179
So what we're going to do is we're going to
implement this in kind of a roll out type fashion.

00:58:08.179 --> 00:58:13.190
So in Leopard you'll see much of the integer operations
kind of just the basic stuff supported and we may roll,

00:58:13.190 --> 00:58:17.980
as developers need it, as people request it and we
see the utility of it, we may roll pieces of it out.

00:58:17.980 --> 00:58:21.920
We'll have dev notes to tell you what, you know, what's
supported and what's not supported but it really,

00:58:21.920 --> 00:58:29.139
This is one of those things where some of the nuances of
it may not be particularly useful to a large audience.

00:58:29.139 --> 00:58:34.859
And my request from you guys, if you have interest in GPU
shader and a particular part of it just send us an email

00:58:34.860 --> 00:58:38.010
and we can take that and we'll take that into
consideration in our implementation plans.

00:58:38.010 --> 00:58:40.620
But we want to get it out there for you, get you using it

00:58:40.619 --> 00:58:44.179
and get some feed back and then
we'll continue to improve it.

00:58:44.179 --> 00:58:45.569
Transform feed back, we talked about that.

00:58:45.570 --> 00:58:46.470
It's pretty simple.

00:58:46.469 --> 00:58:48.480
You can output from the geometry shader.

00:58:48.480 --> 00:58:50.719
You can either output the primitive of geometry shader.

00:58:50.719 --> 00:58:52.269
If you don't have, sorry.

00:58:52.269 --> 00:58:54.509
Transform feed back technically does
not require the geometry shader.

00:58:54.510 --> 00:58:56.110
I should have been clear about that.

00:58:56.110 --> 00:59:01.599
Either the primitives of geometry are outputs our if you
don't have a geometry shader the set of vertices that go

00:59:01.599 --> 00:59:05.860
out will be output and can be used
into a buffer and can be used again.

00:59:05.860 --> 00:59:07.590
So basically rights to a buffer object.

00:59:07.590 --> 00:59:11.350
You can use it as a vertex, the vertex buffer object
or you can use a different kind of buffer object.

00:59:11.349 --> 00:59:13.980
So you can actually write to a buffer
and use it in a lot of different ways.

00:59:13.980 --> 00:59:15.349
You can recover data, for example.

00:59:15.349 --> 00:59:16.610
You can just output and recover data.

00:59:16.610 --> 00:59:20.590
An example of this is you're, in
the C side of things are basically,

00:59:20.590 --> 00:59:22.769
In this case I'm going to say I'm not rasterizing.

00:59:22.769 --> 00:59:24.889
So I'm going to turn off the fragment side of stuff.

00:59:24.889 --> 00:59:28.049
I'm going to set a buffer, buffer object
up and say, hey, here's the offset to it.

00:59:28.050 --> 00:59:29.810
I'm going to begin transform feed back.

00:59:29.809 --> 00:59:30.960
I'm going to draw some stuff.

00:59:30.960 --> 00:59:32.599
And then I'm going to say, end transform feed back.

00:59:32.599 --> 00:59:38.049
So basically what I did was I say, I'm going to short
circuit the API, feed it back through and get that data out.

00:59:38.050 --> 00:59:41.280
So I rendered some stuff through the vertex
geometry shader and recovered some stuff.

00:59:41.280 --> 00:59:45.350
So if I want to tessellate I recovered more
triangles than I put in in the first place.

00:59:45.349 --> 00:59:48.230
Fairly simple concept in transform feed back.

00:59:48.230 --> 00:59:49.900
And finally, bindable uniform.

00:59:49.900 --> 00:59:52.980
Bindable uniform is really simply, it allows uniform sets.

00:59:52.980 --> 00:59:55.570
You can set, It's an object of uniforms.

00:59:55.570 --> 00:59:58.920
You can...Let's say you have a thousand uniforms in your
shader, a really complex shader, a thousand uniforms

00:59:58.920 --> 01:00:03.430
and you have a different sets of uniforms, different
shaders that allows you to put those into an object

01:00:03.429 --> 01:00:05.139
and kind of bind them to different places.

01:00:05.139 --> 01:00:07.779
And since you can bind one set of
uniforms to different shaders it gives you,

01:00:07.780 --> 01:00:11.860
If people are familiar with the program interface
it gives you the program ENV kind of thing.

01:00:11.860 --> 01:00:14.320
One set of uniforms can affect shaders.

01:00:14.320 --> 01:00:20.920
Basically uniform buffer EXT is what you
call to set it up and you're, to set it,

01:00:20.920 --> 01:00:23.940
to set it and then it's only valid after you link.

01:00:23.940 --> 01:00:28.789
So you link, you have a shader using and you can uniform
buffer to actually set the set of bindable uniforms.

01:00:28.789 --> 01:00:33.679
The, May be a little bit confusing about it is
that you actually bind it and you modify values.

01:00:33.679 --> 01:00:35.029
You're actually modifying it live.

01:00:35.030 --> 01:00:36.610
When you unbind it those kind of go with you.

01:00:36.610 --> 01:00:42.650
So it's, it's actually you bind your set of stuff, modify
your stuff and you can then unbind it, bind to another one.

01:00:42.650 --> 01:00:44.539
So, I think that's all I want to talk about.

01:00:44.539 --> 01:00:49.320
I'm going to bring Alex up and talk, and have him demo
some of the things you can do with geometry shaders.

01:00:49.320 --> 01:00:52.559
Geometry shaders are real interesting
because it's not always about lines

01:00:52.559 --> 01:00:55.759
and points, lines and points and triangles.

01:00:55.760 --> 01:01:00.850
You can do a lot of different things
and he'll show you in some of his demos.

01:01:00.849 --> 01:01:02.289
>> Thanks Jeff.

01:01:04.530 --> 01:01:08.390
Ok, I'm going to show a few GLSL demos today.

01:01:08.389 --> 01:01:09.440
Ok, my mic's on now.

01:01:09.440 --> 01:01:09.860
Thanks Jeff.

01:01:09.860 --> 01:01:13.610
I'm going to show a few different GLSL demos
today focusing on two of the new extensions,

01:01:13.610 --> 01:01:16.230
geometry shaders and transform feed back.

01:01:16.230 --> 01:01:18.639
I think two-thirds of you are new to GLSL

01:01:18.639 --> 01:01:21.339
so today's probably the first time
you've ever heard about geometry shaders.

01:01:21.340 --> 01:01:26.300
So before we jump into the demos let's take a
look at the codes, review what it looks like.

01:01:26.300 --> 01:01:30.780
So here I have two really simple shaders.

01:01:30.780 --> 01:01:32.250
Can we get the demo machine, please?

01:01:32.250 --> 01:01:38.300
Ok. So two really simple shaders.

01:01:38.300 --> 01:01:40.780
On the top a vertex shader.

01:01:40.780 --> 01:01:45.890
This is just doing the simplest
possible transform of incoming vertex.

01:01:45.889 --> 01:01:48.809
And remember, vertex shaders work on one vertex at a time.

01:01:48.809 --> 01:01:50.750
They always output one vertex.

01:01:50.750 --> 01:01:57.690
This is a standard transform model view
projection times the incoming vertex position.

01:01:57.690 --> 01:02:00.139
Geometry shaders, there's really
three key points here to keep in mind.

01:02:00.139 --> 01:02:01.769
I'll just recap what Jeff said.

01:02:01.769 --> 01:02:06.969
The first point is that they work on specific types
of inputs and create specific types of outputs.

01:02:06.969 --> 01:02:12.839
So you have to, when you compile and link the
program object together you have to tell it what type

01:02:12.840 --> 01:02:16.890
of input is this geometry shader going to work
on and what type of output is it going to create.

01:02:16.889 --> 01:02:21.460
So it might be working with points or lines or triangles
and it's going to output points or lines or triangles.

01:02:21.460 --> 01:02:25.360
There's also adjacency inputs, lines of
adjacency and triangles with adjacency.

01:02:25.360 --> 01:02:28.380
I'll touch on that a little later in the demo.

01:02:28.380 --> 01:02:34.360
So the second point is that in the geometry
shader you're working on arrays of inputs.

01:02:34.360 --> 01:02:38.960
The vertex shader output the single
position, from the geometry shader's viewpoint

01:02:38.960 --> 01:02:41.769
that thing is an array, is a geo position in.

01:02:41.769 --> 01:02:46.829
And this particular shader works with the
points so I only have to touch index zero.

01:02:46.829 --> 01:02:50.239
If this was lines I'd have zero and one, if
it was triangles I'd have zero, one and two.

01:02:50.239 --> 01:02:52.799
And you could do math between those
things to find the midpoints

01:02:52.800 --> 01:02:57.030
or do any other kind of weighted average you wanted on them.

01:02:57.030 --> 01:02:59.710
Third point is this new function here.

01:02:59.710 --> 01:03:02.880
You have to explicitly emit vertices.

01:03:02.880 --> 01:03:08.880
In a vertex shader you're always implicitly working on
one vertex and you set whatever attributes you care about,

01:03:08.880 --> 01:03:10.570
the color, the texture coordinate, the position.

01:03:10.570 --> 01:03:14.930
And when your shader is executed those
things are done, the vertex comes out.

01:03:14.929 --> 01:03:18.259
In a geometry shader, same thing, you
set up the attributes you care about.

01:03:18.260 --> 01:03:24.000
Here I'm doing texture coordinates in a position, then
I explicitly emit a vertex, change the attributes,

01:03:24.000 --> 01:03:27.559
emit another vertex, change the attributes and so on.

01:03:27.559 --> 01:03:34.960
This shader is taking one point in and it's going to take
a point and kind of project a screen aligned quad around it

01:03:34.960 --> 01:03:39.130
so that it can kind of transform points
into textured billboards basically.

01:03:39.130 --> 01:03:44.610
So there's just some constants here and it just basically
calculates the top left and the lower right and so on.

01:03:44.610 --> 01:03:49.829
And there's hard coded texture coordinates just go from zero
to one and I end up with a textured sprite on the screen.

01:03:49.829 --> 01:03:53.659
So kind of real simple geometry shader example.

01:03:53.659 --> 01:03:57.509
Ok, let's go to a couple demos.

01:03:57.510 --> 01:04:01.040
( Silence )

01:04:01.039 --> 01:04:03.980
So it's everybody's favorite teapot.

01:04:03.980 --> 01:04:05.719
Everyone's seen this before.

01:04:05.719 --> 01:04:07.299
What's new here?

01:04:07.300 --> 01:04:12.120
So this is the natural progression of the teapot.

01:04:12.119 --> 01:04:14.159
It has to emit some steam.

01:04:14.159 --> 01:04:17.889
So what's going on here and what does
this have to do with geometry shader?

01:04:17.889 --> 01:04:21.539
Well, the way this is working is I'm drawing this twice.

01:04:21.539 --> 01:04:24.699
First it's just a regular teapot,
nothing special about this.

01:04:24.699 --> 01:04:27.309
The second time though I draw it again as points.

01:04:27.309 --> 01:04:30.420
And these points are fed into a geometry shader.

01:04:30.420 --> 01:04:34.260
Inside the geometry shader it's a slightly more
complicated version of what I just showed you in code.

01:04:34.260 --> 01:04:41.870
And each point can conditionally emit
zero or one or more screen aligned quads.

01:04:41.869 --> 01:04:47.920
Right? And these quads are actually inside a particle
system implemented inside the geometry shader,

01:04:47.920 --> 01:04:53.849
which has a single input time and as time
progresses I make them go up and they get bigger

01:04:53.849 --> 01:04:56.739
and the color changes and they rotate a little bit.

01:04:56.739 --> 01:05:00.459
So it's just a simple particle system.

01:05:00.460 --> 01:05:02.119
There's a texture applied to those things.

01:05:02.119 --> 01:05:05.509
So the fragment shader can texture each of the quads.

01:05:05.510 --> 01:05:08.910
And the result can be blended into the scene like this.

01:05:08.909 --> 01:05:13.579
Now you notice that only the spout of
the teapot is emitting the steam here.

01:05:13.579 --> 01:05:18.409
Well, it's really simple to do this because
you're working on the incoming vertex position.

01:05:18.409 --> 01:05:24.589
I can simply compare on the shader if the position is
inside this area then emit something, otherwise, don't emit.

01:05:24.590 --> 01:05:28.230
So you can emit zero if you, if you,
zero vertices out if you want to.

01:05:28.230 --> 01:05:30.280
So I'll let this go.

01:05:30.280 --> 01:05:34.510
Over time maybe some more parts of the teapot start to emit.

01:05:34.510 --> 01:05:40.040
( Silence )

01:05:40.039 --> 01:05:41.150
And so there you go.

01:05:41.150 --> 01:05:49.070
A simple example of points in, bill boarded
quads out, the particles in geometry shader.

01:05:49.070 --> 01:05:52.360
Ok, so another demo, slightly different kind of input.

01:05:52.360 --> 01:05:55.680
I call this kind of the paper doll demo.

01:05:55.679 --> 01:05:57.190
What is this going to look like?

01:05:57.190 --> 01:06:00.340
It's going to look something like this.

01:06:00.340 --> 01:06:01.850
So what's going on here?

01:06:01.849 --> 01:06:05.589
This is adaptive tessellation of
an input mesh in a geometry shader.

01:06:05.590 --> 01:06:08.190
In this case the input is lines.

01:06:08.190 --> 01:06:12.610
And so on the left here I have the original
mesh, this is drawn with fix function.

01:06:12.610 --> 01:06:17.680
This has about 30 points in th0e line loop, really
simple, the simplest kind of mesh I could think of.

01:06:17.679 --> 01:06:20.309
And on the right the same thing
but drawn with a geometry shader.

01:06:20.309 --> 01:06:22.079
So how is this working?

01:06:22.079 --> 01:06:28.449
Well, this time the input type is
lines with adjacency information.

01:06:28.449 --> 01:06:32.579
What that means is that the working unit
in the geometry shader is one line segment.

01:06:32.579 --> 01:06:35.949
Let's take the segment that's atop this
guy's head, but you also have access

01:06:35.949 --> 01:06:39.000
to the lines immediately adjacent
on either side of that data.

01:06:39.000 --> 01:06:43.269
So in the array this would be zero,
one, two, three points I can work with.

01:06:43.269 --> 01:06:48.750
If it had those four points accessible I can then
calculate a weighted supply that runs through all of them

01:06:48.750 --> 01:06:55.710
and I can emit as many subdivisions as I want
calculating the points at each subdivision.

01:06:55.710 --> 01:06:56.920
So that's pretty neat.

01:06:56.920 --> 01:06:58.740
What else can I do with this?

01:06:58.739 --> 01:07:03.969
Well, similar to how the teapot was working conditionally
only at certain positions, there's another new built

01:07:03.969 --> 01:07:06.469
in variable in geometry shader called primitive ID.

01:07:06.469 --> 01:07:11.239
Every single primitive that's coming in
here has a unique number associated with it.

01:07:11.239 --> 01:07:16.239
So like if I start drawing this mesh at the guy's neck,
this might be line segment one and two and three and so on.

01:07:16.239 --> 01:07:19.989
That's another variable I can key on in a
shader and conditionally apply effects with.

01:07:19.989 --> 01:07:22.239
That's regardless of the position
like in the teapot example.

01:07:22.239 --> 01:07:26.039
It's, I can rotate the mesh and do
whatever I want, it's still line segment one.

01:07:26.039 --> 01:07:31.719
So maybe I'll displace just the segments in
this guy's head to grow some hair on him.

01:07:31.719 --> 01:07:34.739
And all these things are running
live every time you draw this mesh.

01:07:34.739 --> 01:07:43.159
So if I animate the original mesh the updated mesh is
tessellated appropriately every single time I draw it.

01:07:43.159 --> 01:07:46.489
And as Jeff is getting across this whole entire session,

01:07:46.489 --> 01:07:49.619
you have complete creative control
over every thing you do in the shader.

01:07:49.619 --> 01:07:53.329
So it's really simple to apply any kind
of effects you want to this geometry.

01:07:53.329 --> 01:07:57.769
Let's get this guy's hip shaking, make him
dance around and now it's an iPod commercial.

01:07:57.769 --> 01:08:00.420
( Laughter )

01:08:00.420 --> 01:08:06.780
So this is a simple 2D example with lines but you
can see how, from the CP's point of view here,

01:08:06.780 --> 01:08:14.920
you're only working with 30 points and the CP load on this
just to animate like this guy's hand is almost nothing.

01:08:14.920 --> 01:08:19.730
But on the GP's side you can tessellate this as much as
you want and create thousands or hundreds of thousands

01:08:19.729 --> 01:08:23.179
of vertices on it and make it look really good.

01:08:23.180 --> 01:08:27.000
Ok, so the next demo is a little different.

01:08:27.000 --> 01:08:30.840
I'm using, I'm going to use geometry
shader again and also transform feed back.

01:08:30.840 --> 01:08:33.100
So it's a less complicated one.

01:08:33.100 --> 01:08:35.300
It's one line.

01:08:35.300 --> 01:08:39.869
Actually it's one line and three uniforms.

01:08:39.869 --> 01:08:46.590
So can you guess what's going to happen here?

01:08:46.590 --> 01:08:48.840
Right. So I'm creating a fractal with this.

01:08:48.840 --> 01:08:50.800
So how is this working?

01:08:50.800 --> 01:08:55.739
So it's the same kind of subdivision as a the
previous example where I have one input line segment

01:08:55.739 --> 01:08:59.399
and I'm using these uniforms as the
relative offsets into that line and I break

01:08:59.399 --> 01:09:02.279
up the incoming segment into four line segments coming out.

01:09:02.279 --> 01:09:05.630
But instead of drawing to the screen
I can capture the output positions

01:09:05.630 --> 01:09:08.369
into a VBO with a transfer feed back extension.

01:09:08.369 --> 01:09:08.909
Then guess what?

01:09:08.909 --> 01:09:13.210
I just turn around and I draw that VBO with the same
geometry shader and on the first line when it comes in

01:09:13.210 --> 01:09:16.369
and it gets subdivided again and the second line and so on.

01:09:16.369 --> 01:09:20.359
And I can repeat over that as many
times as I want to build up detail.

01:09:20.359 --> 01:09:27.309
Now what's cool is I can animate the uniforms per frame by
just dragging the points around and now I've got this kind

01:09:27.310 --> 01:09:31.100
of interactive fractal shape that
I can do whatever I want with.

01:09:32.399 --> 01:09:38.179
So that's neat but still drawing this thing as
one line segment isn't as cool as it could be.

01:09:38.180 --> 01:09:44.250
So let's try to be a little more creative and
artistic and see what else we can do with it.

01:09:44.250 --> 01:09:51.029
So the first thing is instead of drawing this as lines,
what if I emit just the points and I feed those points again

01:09:51.029 --> 01:09:54.309
to another geometry shader just like the one
I showed you in the beginning that's going

01:09:54.310 --> 01:09:57.120
to turn each incoming point into a textured quad.

01:09:57.119 --> 01:10:03.420
So there you see I'm just drawing a bunch of textured balls
now, which already makes it look a lot more complicated

01:10:03.420 --> 01:10:06.590
because you can see some interactions
happening with the alpha.

01:10:07.630 --> 01:10:09.029
What else can I do with this?

01:10:09.029 --> 01:10:11.500
Let's try randomizing the point size.

01:10:11.500 --> 01:10:13.989
I can do this with the noise functions in GLSL.

01:10:13.989 --> 01:10:19.399
Here I'm actually using a texture look-up in the
geometry shader to look at some random texture data.

01:10:19.399 --> 01:10:26.269
Remember that texture look-ups are available to
vertex and geometry shaders not just fragment shaders.

01:10:26.270 --> 01:10:30.340
And I could do the same thing with, say,
the color that I pick for each of these.

01:10:30.340 --> 01:10:33.560
So now it's looking a lot more complicated and organic.

01:10:33.560 --> 01:10:38.080
Let's apply a little bit of dot
product magic and a fragment shader.

01:10:38.079 --> 01:10:43.010
So now I've got this much more interesting
looking microorganism kind of thing.

01:10:44.220 --> 01:10:48.380
And to finish this off let's try animating some
more of these attributes like the point size

01:10:48.380 --> 01:10:51.579
and apply some random displacement to everything.

01:10:51.579 --> 01:10:57.220
So now I've got a very complicated looking
scene, which is completely interactive.

01:10:57.220 --> 01:11:03.400
And remember all of this was generated from one line
segment with three uniforms I'm touching per frame.

01:11:03.399 --> 01:11:08.529
All the extra geometry here is being calculated
and animated and actually created on the fly

01:11:08.529 --> 01:11:13.460
in the shader where we can accelerate that on the GPU.

01:11:13.460 --> 01:11:16.430
So I think that's the end of the demo here.

01:11:16.430 --> 01:11:19.800
I just want to say that there's a lot more
of these effects that you can come up with.

01:11:19.800 --> 01:11:22.949
You could be doing the same kind
of tessellation with 3D objects.

01:11:22.949 --> 01:11:25.539
You could be doing shadow extrusion.

01:11:25.539 --> 01:11:27.859
There's just a kind of unlimited
world of possibilities here.

01:11:27.859 --> 01:11:31.259
So please go to OpenGL dot org,
download the specs and read through them

01:11:31.260 --> 01:11:40.850
and try experimenting with all the stuff yourself.

01:11:40.850 --> 01:11:41.190
Thanks.

01:11:41.189 --> 01:11:44.339
( Applause )
>> We'll go back to the slides and I'll finish up here.

01:11:45.970 --> 01:11:50.520
So programmable GPU's are here.

01:11:50.520 --> 01:11:52.330
GLSL ships everywhere.

01:11:52.329 --> 01:11:57.460
It's a, OpenGL Shading Language it
is approachable, understandable,

01:11:57.460 --> 01:12:00.989
direct, fast way to get at the power of the GPU.

01:12:00.989 --> 01:12:04.519
It's our focus and we'd really
like to have it be your focus.

01:12:04.520 --> 01:12:08.320
Moving forward we're going to be doing a C program.

01:12:08.319 --> 01:12:09.939
We're continuing from last year.

01:12:09.939 --> 01:12:11.349
OpenGL C dot Apple dot com.

01:12:11.350 --> 01:12:17.470
What we'ree going to try and do is get you new graphic
drivers, new OpenGL to allow you to work on top of Leopard

01:12:17.470 --> 01:12:19.260
and really give us some feed back on what you have.

01:12:19.260 --> 01:12:22.070
If you find any bugs we can get those quick
turn fixed to you and you can make sure

01:12:22.069 --> 01:12:27.939
that Leopard is a really great thing to use
these new features and use OpenGL and GLSL.

01:12:27.939 --> 01:12:32.619
I don't think we have time for questions
today but I want to bring up Alan's name.

01:12:32.619 --> 01:12:35.380
Alan Schaeffer (sp?) is our 2D, 3D evangelist

01:12:35.380 --> 01:12:39.930
and if you have questions specific you can
go to him for kind of generic questions.

01:12:39.930 --> 01:12:42.860
There's obviously the sample code and resources there
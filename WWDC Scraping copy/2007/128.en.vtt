WEBVTT

00:00:13.720 --> 00:00:14.020
>> Ken: Welcome.

00:00:14.019 --> 00:00:17.899
This is session 128, Cocoa Drawing Techniques.

00:00:17.899 --> 00:00:19.339
My name's Ken Ferry.

00:00:19.339 --> 00:00:25.469
I'm an engineer in the Cocoa Frameworks Group
and I hope you enjoy the talk we have for you.

00:00:25.469 --> 00:00:29.609
So today I want to discuss drawing at the Cocoa level.

00:00:29.609 --> 00:00:32.600
First we're going to talk about just an
overview of what drawing consists of in Cocoa.

00:00:32.600 --> 00:00:33.609
This will be fairly quick.

00:00:33.609 --> 00:00:37.469
It's not intended to teach anybody anything,
it's just to get us all on the same page.

00:00:37.469 --> 00:00:42.869
I will try to emphasize a few areas
that I think are misunderstood.

00:00:42.869 --> 00:00:45.609
The bulk of the talk is going to be about NS Image.

00:00:45.609 --> 00:00:47.280
It's a somewhat misunderstood class.

00:00:47.280 --> 00:00:48.460
People sometimes have some trouble with it.

00:00:48.460 --> 00:00:50.620
I'd like to just talk about the way it works.

00:00:50.619 --> 00:00:53.329
I think it's probably not so bad as you may think.

00:00:53.329 --> 00:00:57.979
And then I'd like to talk about the lower level APIs,
particularly at the Core Graphics level afterwards,

00:00:57.979 --> 00:01:02.919
and we'll just run through and the point of that
section will really to be what all is available,

00:01:02.920 --> 00:01:06.659
under what circumstances might you
want to go look into it in more detail.

00:01:06.659 --> 00:01:09.099
And we'll talk about it and just know what's it good for.

00:01:09.099 --> 00:01:11.209
Okay. So let's start out with the overview though.

00:01:11.209 --> 00:01:16.989
So in the overview there are two
things I want to talk about.

00:01:16.989 --> 00:01:21.000
I want to talk about graphics contexts and
I want to talk about coordinate systems.

00:01:21.000 --> 00:01:26.000
So a graphics context, as you may have heard
in other talks, is a drawing destination.

00:01:26.000 --> 00:01:27.140
It's a canvas.

00:01:27.140 --> 00:01:29.109
It's where the drawing ends up.

00:01:29.109 --> 00:01:33.709
So it's a very fundamental role in any drawing, of course.

00:01:33.709 --> 00:01:37.299
We're going to be mostly talking
about drawing with NS graphic context

00:01:37.299 --> 00:01:40.609
and CG context rep, which are very, very similar objects.

00:01:40.609 --> 00:01:42.359
There are plenty of other contexts in the system.

00:01:42.359 --> 00:01:46.420
There's a CI context, there's an NS
open GL context, there's a CGL context.

00:01:46.420 --> 00:01:49.170
In all cases they are drawing destinations.

00:01:49.170 --> 00:01:50.530
That's always what it means.

00:01:50.530 --> 00:01:52.570
But it's not just a destination.

00:01:52.569 --> 00:01:56.569
The other thing that contexts do for you, the reason
it's called a context instead of just a destination

00:01:56.569 --> 00:02:00.029
or a canvas, is that they hold the properties.

00:02:00.030 --> 00:02:05.489
Where the properties are something that you set into the
context, bits of state and then they affect later drawing.

00:02:05.489 --> 00:02:12.409
For example, you can set an image interpolation quality into
an NS graphics context and what that does is then later,

00:02:12.409 --> 00:02:17.990
if you're drawing an image whose resolution does
not match the resolution of the destination,

00:02:17.990 --> 00:02:23.780
it has an impact on how the resampling is done,
how long it takes and how high quality it is.

00:02:23.780 --> 00:02:26.289
There's plenty of other bits of state that work like that.

00:02:26.289 --> 00:02:32.109
We'll see some of them during the course of the talk, but
then something you might notice with that is if that's

00:02:32.110 --> 00:02:36.700
that way it works if when you set these
properties and then it has affect on later drawing,

00:02:36.699 --> 00:02:39.939
that kind of side effect can be bad in some situations.

00:02:39.939 --> 00:02:43.699
You know, if you call some drawing method, you don't want
it to effect lots of other stuff later in the program.

00:02:43.699 --> 00:02:47.409
So there's some convenience methods
to help manage that sort of thing.

00:02:47.409 --> 00:02:52.609
All of those properties taken together are
called the graphics state in the context,

00:02:52.610 --> 00:02:55.370
and you can save and restore individual states.

00:02:55.370 --> 00:03:00.770
So you issue, and I'm going to point this out because
this is the instance level method, save graphic state,

00:03:00.770 --> 00:03:04.590
restore graphic state, you call a
save, it pushes it onto a stack,

00:03:04.590 --> 00:03:09.920
you call a restore it restores whatever the last thing
you saved was in those nests, that's why it forms a stack.

00:03:09.919 --> 00:03:11.099
And those are exactly the same.

00:03:11.099 --> 00:03:13.939
There's similar functions down at the Core Graphics level.

00:03:13.939 --> 00:03:18.889
CG context save G state and CG context restore
G state, they're exactly the same thing

00:03:18.889 --> 00:03:21.169
as the instance level methods up at Cocoa.

00:03:21.169 --> 00:03:24.780
They can be interchanged, now that
that would be a good thing to do.

00:03:24.780 --> 00:03:30.150
Let's talk a little bit about how
they are different, however.

00:03:30.150 --> 00:03:33.640
Since I've so far emphasized that they are the same thing.

00:03:33.639 --> 00:03:38.009
Oh sorry, I'm still talking about
how they are the same thing.

00:03:38.009 --> 00:03:40.389
So Cocoa drawing really is the same thing as core drawing.

00:03:40.389 --> 00:03:42.729
I've spoken to a few developers
who didn't understand this really.

00:03:42.729 --> 00:03:48.209
They didn't understand NS rect field and CG context
field rect were really the same kind of drawing.

00:03:48.210 --> 00:03:50.080
You can interchange them, you inter sparse them.

00:03:50.080 --> 00:03:52.500
They are not actually bridged classes however.

00:03:52.500 --> 00:03:57.069
If you have an NS context graphics and you need
to do some Core Graphics drawing that needs

00:03:57.069 --> 00:04:01.699
to take a Core Graphics context, what you
do is you issue the graphics port methods

00:04:01.699 --> 00:04:07.549
to the NS graphics context, that'll
get you the CG context rep.

00:04:07.550 --> 00:04:12.570
And then if you need to go in the other direction, there's
a class method, graphics context with graphics port colon.

00:04:12.569 --> 00:04:16.300
There it takes the graphics, or the
CG graphics context and then flipped,

00:04:16.300 --> 00:04:18.530
which I'll discuss that parameter a little bit later.

00:04:18.529 --> 00:04:20.829
You should think of this method as being very cheap.

00:04:20.829 --> 00:04:22.909
It's just an extremely thin wrapper.

00:04:22.910 --> 00:04:25.430
So there are some differences, however.

00:04:25.430 --> 00:04:29.079
So the reason I wanted to really talk about
the save and restore in G state before,

00:04:29.079 --> 00:04:34.129
is because Cocoa has an additional
stack, besides just the G state stack,

00:04:34.129 --> 00:04:36.949
which is that there's actually a stack of graphics contexts.

00:04:36.949 --> 00:04:41.259
There's always a notion of the current graphics
context and you can set the current graphics context

00:04:41.259 --> 00:04:44.060
and the way you deal with the stack,
again, there's a class level method,

00:04:44.060 --> 00:04:48.810
save graphic state class level restore graphic state,
and they're not the same as the instance level.

00:04:48.810 --> 00:04:56.199
It's not just a cover that calls the instance
level method on the current graphics context.

00:04:56.199 --> 00:05:02.189
What it does is it takes the entire context itself and
the context itself will have the stack of states within it.

00:05:02.189 --> 00:05:08.259
It pushes it on to the stack and then you would
call set current context to make a new one current.

00:05:08.259 --> 00:05:12.129
And that's where your Cocoa drawing ends up going.

00:05:12.129 --> 00:05:19.149
So that's the point, so because we have this notion of
the current context in Cocoa, usually it's implicit.

00:05:19.149 --> 00:05:22.889
So at the Cocoa level, if you want to set a color
into the context, you do something like this.

00:05:22.889 --> 00:05:24.050
NS color blue color set.

00:05:24.050 --> 00:05:28.780
At the CG level, you don't see that, you
see explicitly passing in the context.

00:05:28.779 --> 00:05:32.769
And the difference there is because Core Graphics
doesn't have a notion of the current context.

00:05:32.769 --> 00:05:38.479
And often, also, you don't work directly with the
context in Cocoa as much, because often it is implicit.

00:05:38.480 --> 00:05:45.800
If you're drawing an attributed string, one of the
attributes of the string is the foreground color attribute,

00:05:45.800 --> 00:05:50.970
and the mechanics of that are that finally, when it draws,
it's going to have to set that color into the context

00:05:50.970 --> 00:05:56.170
and the draw glyphs with it, but that's hidden
from you, so you don't end up seeing it so much

00:05:56.170 --> 00:06:00.800
But part of the reason for saying this is that sometimes
you really might want to be able to explicitly deal

00:06:00.800 --> 00:06:06.120
with the context and if you do want to deal with that,
then you should look at the header CG context dot H.

00:06:06.120 --> 00:06:11.379
and one of the things that you can see with that is
you'll see all of the various different bits of state

00:06:11.379 --> 00:06:14.839
that actually go into a graphics context, which
are not quite so obvious at the Cocoa level

00:06:14.839 --> 00:06:16.939
because they're distributed all throughout the framework.

00:06:16.939 --> 00:06:19.680
So that's an interesting thing to look at.

00:06:19.680 --> 00:06:25.300
But really the point of that last section was to
note the difference between particularly the stack

00:06:25.300 --> 00:06:29.420
of graphics context and the stack of
graphics states within each state.

00:06:29.420 --> 00:06:29.640
All right.

00:06:29.639 --> 00:06:32.269
Let's talk about coordinate systems a little bit.

00:06:32.269 --> 00:06:35.060
So when you issue a command like this, NS rect field,

00:06:35.060 --> 00:06:39.149
and then you send in a rect, zero,
zero, 100, 100, what does that do?

00:06:39.149 --> 00:06:42.339
Well it's obviously going to fill a rectangle somewhere.

00:06:42.339 --> 00:06:43.239
Where is that rectangle?

00:06:43.240 --> 00:06:46.650
Well, it's with respect to the current coordinate system.

00:06:46.649 --> 00:06:51.599
And the point of this is going to be that don't try
to pretend that there's a universal coordinate system.

00:06:51.600 --> 00:06:55.760
Because really the foundation of Cocoa's resolution
and dependence architecture is that there's not.

00:06:55.759 --> 00:06:56.949
There are lots of coordinate systems.

00:06:56.949 --> 00:06:58.479
There's a screen space.

00:06:58.480 --> 00:06:59.939
There's a window space.

00:06:59.939 --> 00:07:01.660
Every view has its own space.

00:07:01.660 --> 00:07:03.250
Every image has its own space.

00:07:03.250 --> 00:07:05.629
The image space you might be a
little bit less familiar with.

00:07:05.629 --> 00:07:07.100
It comes up a little less often.

00:07:07.100 --> 00:07:11.890
And then there is also, the final place that's
really important when you're actually drawing is

00:07:11.889 --> 00:07:20.419
that the graphics context has a coordinate space within it,
and the way this works is that in the normal view drawing,

00:07:20.420 --> 00:07:26.689
before draw a rect is called, the context in the graphics,
the coordinate system in the context will have been set

00:07:26.689 --> 00:07:31.360
up to match the view context and then
you can modify it from there, possibly.

00:07:31.360 --> 00:07:34.569
Similarly, if you're dealing with
images, the way you draw into an image is

00:07:34.569 --> 00:07:37.269
to issue the lock focus method,
which we'll talk about later.

00:07:37.269 --> 00:07:39.609
And that has the same effect.

00:07:39.610 --> 00:07:47.870
That's going to set up the coordinate system in the current
graphics context to match the native space of the image.

00:07:47.870 --> 00:07:51.780
So it's stored in the graphics context.

00:07:51.779 --> 00:07:55.359
It's one of those properties that is something that
gets saved and restored when you're using those methods.

00:07:55.360 --> 00:08:01.060
It's called the current transformation matrix, is
the way it's stored, which is referred to as the CTM.

00:08:01.060 --> 00:08:03.250
This is worth pointing out because it shows up in the APIs.

00:08:03.250 --> 00:08:07.720
So I wanted to make a little analogy
here to say why I'm harping on this.

00:08:07.720 --> 00:08:11.260
Why is a rectangle like a char star array?

00:08:11.259 --> 00:08:13.310
Like a C string, that is?

00:08:13.310 --> 00:08:18.000
Well, they're similar in that we're all
used to these days that a C string is sort

00:08:18.000 --> 00:08:21.850
of meaningless unless you have this
string encoding that goes along with it.

00:08:21.850 --> 00:08:24.030
Well, really a rectangle is the same way.

00:08:24.029 --> 00:08:26.289
If you just have a bare rectangle and you don't understand

00:08:26.290 --> 00:08:29.780
which coordinate space it replies to,
then you don't have any information.

00:08:29.779 --> 00:08:36.490
And really what you need to do for resolution dependence,
to start getting that right is to always think about that

00:08:36.490 --> 00:08:39.519
and to make sure that you're not trying
to deal with rectangles that are not

00:08:39.519 --> 00:08:42.319
in the same space and comparing them as if they are.

00:08:42.320 --> 00:08:46.960
So the way of dealing with that is
instead you should convert between spaces.

00:08:46.960 --> 00:08:48.550
So there are lots and lots of different methods for this.

00:08:48.549 --> 00:08:52.279
Oh, and this is a good time to mention
the difference between frame and bounds.

00:08:52.279 --> 00:08:56.250
A perennial question for Cocoa developers of all ages.

00:08:56.250 --> 00:09:01.210
Bounds is the location of a view
in its own coordinate system.

00:09:01.210 --> 00:09:04.180
Frame is the location of a view in
its superview's coordinate system.

00:09:04.179 --> 00:09:05.329
That's all there is to it.

00:09:05.330 --> 00:09:11.110
So if you want to move a view in it's super
view, that's when you're calling set frame.

00:09:11.110 --> 00:09:15.769
When you're drawing, the frame is entirely
irrelevant, well, mostly irrelevant anyway.

00:09:15.769 --> 00:09:16.909
I mean, who knows?

00:09:16.909 --> 00:09:17.990
You can do whatever you want.

00:09:17.990 --> 00:09:21.810
But for the most part you only care about your
own coordinate space, and that's the bounds.

00:09:21.809 --> 00:09:27.419
Most of the methods in NS view, if they don't say
anything otherwise, that take points, sizes, rects,

00:09:27.419 --> 00:09:30.990
they're all going to be in the view's own space.

00:09:30.990 --> 00:09:36.950
Okay. And there are just a lot of methods for
converting between these spaces, some of which are new.

00:09:36.950 --> 00:09:40.830
I think it's not really worth going
into these in too much detail.

00:09:40.830 --> 00:09:41.270
They're there.

00:09:41.269 --> 00:09:43.159
Please use them.

00:09:43.159 --> 00:09:43.480
All right.

00:09:43.480 --> 00:09:48.440
So another thing I wanted to talk about was the concept
of flippedness before we get going too much further in.

00:09:48.440 --> 00:09:52.870
you remember in the graphics context method the
way that I said you create an NS graphics context

00:09:52.870 --> 00:09:57.519
if you have a CG level context that
you need to ref, you issue this method,

00:09:57.519 --> 00:09:59.620
graphics context with graphics port flipped.

00:09:59.620 --> 00:10:01.779
Okay. We discussed the first parameter already,

00:10:01.779 --> 00:10:05.899
that's the Core Graphics context, but
what is the flippedness parameter?

00:10:05.899 --> 00:10:13.889
Well a flipped coordinate system is one where we think
of zero, zero, the origin of being at the top left

00:10:13.889 --> 00:10:18.309
and positive number of going down the Y axis as opposed

00:10:18.309 --> 00:10:21.629
to the unflipped coordinate system has
a more mathematical model where zero,

00:10:21.629 --> 00:10:24.100
zero is in the bottom left and positive goes up.

00:10:24.100 --> 00:10:26.269
Now the interesting thing to understand about this is

00:10:26.269 --> 00:10:30.939
that it doesn't actually effect any
drawing unless something looks for it.

00:10:30.940 --> 00:10:32.430
It's just meta data.

00:10:32.429 --> 00:10:38.389
It doesn't necessarily mean that the context is set up that
way, it's just sort of telling anybody who's interesting

00:10:38.389 --> 00:10:41.279
in knowing, yeah, you should think of this context as flipped.

00:10:41.279 --> 00:10:48.480
Okay? So lots of higher level Cocoa constructs like cells do
look at the flippedness of the context and they will adjust

00:10:48.480 --> 00:10:52.340
for it, but lower level things like images do not.

00:10:52.340 --> 00:10:55.540
They'll just draw however they're told to draw.

00:10:55.539 --> 00:11:02.129
Okay. So that's all I have to say about the overview, let's
go ahead and talk about NS image itself for a little while.

00:11:02.129 --> 00:11:04.340
And to do that, though, we need to talk about two classes.

00:11:04.340 --> 00:11:06.990
We need to talk about NS image rep
and we need to talk about NS image.

00:11:06.990 --> 00:11:11.779
To make the distinction, it's easier
to talk about NS image rep first.

00:11:11.779 --> 00:11:13.069
So let's do that.

00:11:13.070 --> 00:11:19.000
So in NS image rep is an abstract
thing that can draw itself.

00:11:19.000 --> 00:11:22.960
But we don't deal with it abstractly,
we always deal with the sub classes.

00:11:22.960 --> 00:11:31.200
For example, we have NS bit map image rep, we have NS
PDF image rep, NS CI image rep, and NS custom image rep.

00:11:31.200 --> 00:11:36.480
Basically what unites these sort of classes, what
you see is that they all have intimate knowledge

00:11:36.480 --> 00:11:39.539
of the data that actually needs to be drawn.

00:11:39.539 --> 00:11:45.360
So when you issue the draw method on an NS PDF image rep,
it's going to go to its PDF data, it's going to interpret it

00:11:45.360 --> 00:11:47.529
and it's going to put the bits in the context.

00:11:47.529 --> 00:11:50.709
That is the job of the NS image rep.

00:11:50.710 --> 00:11:53.360
There are a few things, I guess,
that I thought I should mention

00:11:53.360 --> 00:11:55.789
that are handled all the way up at the abstract level.

00:11:55.789 --> 00:12:01.289
There's a type registration system so that you
can say when you make a new image rep sub class,

00:12:01.289 --> 00:12:04.250
you can say here is the data that
I'm capable of dealing with.

00:12:04.250 --> 00:12:09.289
And then when somebody goes and creates a new
image from the data, if they have the type,

00:12:09.289 --> 00:12:12.059
they don't need to know particularly
which image rep is appropriate.

00:12:12.059 --> 00:12:13.389
But that's what that's for.

00:12:13.389 --> 00:12:16.179
So it's sort of built to be sub classed.

00:12:16.179 --> 00:12:16.959
That's what it's for.

00:12:16.960 --> 00:12:19.700
It's really easy to sub class, not just for us, but for you.

00:12:19.700 --> 00:12:24.480
If you have new image types, this
is how you want to add them.

00:12:24.480 --> 00:12:29.399
So really what you have to do is every image rep has to have
a size, so when you create it you should pass in the size

00:12:29.399 --> 00:12:32.309
in some fashion, and it has to be able to draw itself.

00:12:32.309 --> 00:12:33.079
And that's really it.

00:12:33.080 --> 00:12:37.750
I guess you need to implement NS code and NS copy
so they can be archived to disk or it can be copied.

00:12:37.750 --> 00:12:39.129
But that's about it.

00:12:39.129 --> 00:12:41.820
There are other features you can do if they're appropriate.

00:12:41.820 --> 00:12:46.700
There is, for example, pixel width and pixel height
that you would use if you have a bit map type of image,

00:12:46.700 --> 00:12:49.440
but if you have something that's
resolution independent natively, like a PDF,

00:12:49.440 --> 00:12:52.520
you just actually don't have to deal with them at all.

00:12:52.519 --> 00:12:54.409
We'll discuss how that works.

00:12:54.409 --> 00:12:58.740
In particular I want to suggest that as an
exercise I think it would be really good to go try

00:12:58.740 --> 00:13:01.310
to write your own class that draws CG images.

00:13:01.309 --> 00:13:03.449
And the reason for this is that
it's actually extremely easy.

00:13:03.450 --> 00:13:10.040
You don't have to do it anymore because in Leopard
we've added methods to make it easier to take CG images

00:13:10.039 --> 00:13:13.699
and put them into an NS image without doing any extra work.

00:13:13.700 --> 00:13:19.300
But it's actually really trivial to begin with because
all you have to do is implement this draw method

00:13:19.299 --> 00:13:22.359
in a sub class as hey, draw the CG image.

00:13:22.360 --> 00:13:24.310
So give that a shot.

00:13:24.309 --> 00:13:27.149
The methods, by the way, are NS
bit map, image rep, NS CG image,

00:13:27.149 --> 00:13:30.980
and then the one that returns it
is NS bitmap return CG image.

00:13:30.980 --> 00:13:35.920
You see there at the bitmap image rep level instead
of the NS image level, because CG images, you'll see,

00:13:35.919 --> 00:13:39.939
actually has a, it's more like an image
representation than like an NS image.

00:13:39.940 --> 00:13:43.220
NS image is a much higher level class.

00:13:43.220 --> 00:13:44.820
Okay. So that's NS image rep.

00:13:44.820 --> 00:13:46.430
So what is NS image then?

00:13:46.429 --> 00:13:50.969
Well NS image is also something that can draw
itself, but it is a much, much smarter class.

00:13:50.970 --> 00:13:54.540
So NS image rep is simple because
it's supposed to be easy to sub class

00:13:54.539 --> 00:13:57.949
and so all the smarts get split off into NS image.

00:13:57.950 --> 00:14:01.150
What it really is - it's a container between NS image maps.

00:14:01.149 --> 00:14:03.809
It's going to be able to choose between
them and do lots and lots of other stuff.

00:14:03.809 --> 00:14:05.829
So here are just some of the features of NS image.

00:14:05.830 --> 00:14:10.450
Something that we'll talk about, we'll
talk about this representation selection.

00:14:10.450 --> 00:14:16.040
So when you're asked to draw, how does the image
choose which of the image reps to actually use to draw?

00:14:16.039 --> 00:14:18.809
Because it's always the image reps
that really do the drawing.

00:14:18.809 --> 00:14:21.250
We're going to talk about compositing modes.

00:14:21.250 --> 00:14:22.850
We're going to talk about caching.

00:14:22.850 --> 00:14:23.800
That gives people some trouble.

00:14:23.799 --> 00:14:26.779
We'll talk about how to create new images from a drawing.

00:14:26.779 --> 00:14:34.569
A few things we won't talk about later, so I'll say a few
words about them now, if you want to load images from disk,

00:14:34.570 --> 00:14:36.300
there's some really nice methods for doing that.

00:14:36.299 --> 00:14:41.490
There's image name, which will search
your bundle in a very convenient fashion.

00:14:41.490 --> 00:14:43.860
There's init by referencing file
and init by contents of file.

00:14:43.860 --> 00:14:45.480
What is the difference between these two methods?

00:14:45.480 --> 00:14:48.120
They both take a file and create an image out of it.

00:14:48.120 --> 00:14:51.299
The first one references the file, so it's very lazy.

00:14:51.299 --> 00:14:54.500
It won't actually decode anything until it's asked to draw.

00:14:54.500 --> 00:15:00.710
And if there are multiple representations, if you've done
something at 1X and 4X for higher resolution reasons,

00:15:00.710 --> 00:15:04.970
it won't decode the 4X image unless it needs to.

00:15:04.970 --> 00:15:09.680
So that's how you avoid taking
more memory if you don't need to.

00:15:09.679 --> 00:15:15.009
Init with contents of file, that one actually will
suck the entire file into data, into memory right away.

00:15:15.009 --> 00:15:18.269
That's also necessary sometimes, because
under some circumstances you can't guarantee

00:15:18.269 --> 00:15:20.929
that the file will still be there later.

00:15:20.929 --> 00:15:22.379
So that's why you need to be able to do that.

00:15:22.379 --> 00:15:27.850
There's other meta data associated with an image
that I think might have been covered to some extent

00:15:27.850 --> 00:15:31.370
in the controls talk that was just done,
so you'll have to get that on video,

00:15:31.370 --> 00:15:32.820
I suppose, but you can also ask about it later.

00:15:32.820 --> 00:15:37.390
But I recommend that you go read the headers for things
like the new alignment rect property and for things

00:15:37.389 --> 00:15:41.120
like set template, is another new property
that really has to do with control drawing.

00:15:41.120 --> 00:15:47.370
Okay, let's talk about the primary function of
the image, as I said, it's to contain image reps.

00:15:47.370 --> 00:15:50.870
And when it draws, it needs to select an image rep to draw.

00:15:50.870 --> 00:15:51.960
So how does that work?

00:15:51.960 --> 00:15:55.440
Okay. Well the primary thing it's
going to do has to do with resolution.

00:15:55.440 --> 00:16:00.450
The main image drawing method here, okay, that's
image draw in rect from rep, operation fraction.

00:16:00.450 --> 00:16:04.100
It has a, you have a destination rect in
the context and you have a source rect

00:16:04.100 --> 00:16:06.850
within the coordinate space of the image itself.

00:16:06.850 --> 00:16:11.409
Often, by the way, if you just want to draw the whole
rect, it's very convenient to just pass NS zero rect.

00:16:11.409 --> 00:16:14.610
It's a convenience that will just draw the entire image.

00:16:14.610 --> 00:16:18.789
And then there's implicit piece of data which
is always the case when you're drawing in Cocoa,

00:16:18.789 --> 00:16:22.679
which is you have the current graphics context,
which has it's own coordinate transform.

00:16:22.679 --> 00:16:30.349
Between the destination rect and the current coordinate
transform that's going to figure out a resolution,

00:16:30.350 --> 00:16:34.129
a number of pixels that need to be filled in
in the context and that's going to be used

00:16:34.129 --> 00:16:37.529
to choose an image representation that is appropriate.

00:16:37.529 --> 00:16:40.620
So you may have, if you have a TIFF for
example that you used to create your image,

00:16:40.620 --> 00:16:44.669
there may be multiple resolutions
available and this is how it's going

00:16:44.669 --> 00:16:47.860
to choose the best one, I guess I was going to say.

00:16:47.860 --> 00:16:50.080
There are other factors that used to be more important.

00:16:50.080 --> 00:16:52.480
It can also select based on things like color depth.

00:16:52.480 --> 00:16:59.750
If you have a black and white window, or a fore color window
or say a printer of some sort, it can try to select an image

00:16:59.750 --> 00:17:01.370
that is more suited to that kind of context.

00:17:01.370 --> 00:17:04.230
But these days mostly resolution
independence is the really interesting bit.

00:17:04.230 --> 00:17:05.920
So how does that work?

00:17:05.920 --> 00:17:11.490
So if we look at the NS image rep level, all of the
data for resolution dependence has to already be there,

00:17:11.490 --> 00:17:13.430
because that's what NS image is
going to be able to work with.

00:17:13.430 --> 00:17:16.090
I already discussed that every image rep has a size.

00:17:16.089 --> 00:17:20.669
It has also these optional properties, the
pixel width and the pixel height of the image.

00:17:20.670 --> 00:17:23.789
I guess they're not exactly optional,
I mean they have to do something.

00:17:23.789 --> 00:17:30.079
But the point is that for something like a PDF, what
those methods will return is NS image rep matches device,

00:17:30.079 --> 00:17:33.199
which is basically how it says that whenever you're drawing,

00:17:33.200 --> 00:17:37.200
I'm always perfectly suited for
the context in terms of resolution.

00:17:37.200 --> 00:17:38.590
Okay? That's what that means.

00:17:38.589 --> 00:17:42.099
But if you have a bitmap sort of
image rep, of which we have many,

00:17:42.099 --> 00:17:47.519
for example if you're implementing the CG image rep drawing
sub class, you'd want to report an accurate pixel width

00:17:47.519 --> 00:17:52.680
and pixel height so that the image did a
better job of choosing amongst the resolutions.

00:17:52.680 --> 00:17:54.330
Okay, that's all I have to say about image rep choice.

00:17:54.329 --> 00:17:57.500
Let's talk about caching.

00:17:57.500 --> 00:18:05.730
So NS image is a user interface oriented class, which is
to say that as opposed to sort of doing image processing,

00:18:05.730 --> 00:18:09.610
it's not for applying Photoshop filters, that's
something that Core Image is very, very good for.

00:18:09.609 --> 00:18:15.269
It's not even for writing out data at
the moment in very specific formats.

00:18:15.269 --> 00:18:21.859
If you have something like, I have a JPEG and what I want
to do to it is add an x-if tag that has the GPS information

00:18:21.859 --> 00:18:25.329
in it, that's not something that NS
image is well suited for, today anyway.

00:18:25.329 --> 00:18:26.500
We might want to bring that up.

00:18:26.500 --> 00:18:31.259
But you need to go down to the image I/O level
for that, which is part of Core Graphics.

00:18:31.259 --> 00:18:34.980
Yeah, but the point is that NS image is
more about putting things in buttons,

00:18:34.980 --> 00:18:37.170
it's more about putting things really on the screen.

00:18:37.170 --> 00:18:39.140
And so it's going to cache by default.

00:18:39.140 --> 00:18:41.520
The first time you draw it it's
going to create itself a cache.

00:18:41.519 --> 00:18:47.089
And it's actually even allowed to throw out
the original data, unless you tell it not to.

00:18:47.089 --> 00:18:49.740
If you have something like a PDF, this
is where this really comes into play.

00:18:49.740 --> 00:18:54.299
The first time it draws it takes a really long
time to draw because PDFs are not cheap to draw.

00:18:54.299 --> 00:19:02.250
But it draws into a cache, which is a bitmap, and then
the original PDF data is actually completely thrown away.

00:19:02.250 --> 00:19:06.349
So as long as you're just redrawing it
in the same way, in the same button,

00:19:06.349 --> 00:19:09.629
that's going to be what you want
both for speed and memory purposes.

00:19:09.630 --> 00:19:15.280
But there are situations where that's not going to cut it
for you and so you need to be able to control the cache.

00:19:15.279 --> 00:19:20.710
So for example, if you're using the image in two
places in the interface, you don't want it to lose

00:19:20.710 --> 00:19:25.059
that original backing data if there was more
detail that you lost when you wrote the cache.

00:19:25.059 --> 00:19:29.470
So one way to do that is just to copy the image
if you're using it in two different buttons,

00:19:29.470 --> 00:19:31.160
maybe you'd just like to have a different copy.

00:19:31.160 --> 00:19:32.350
That works fine.

00:19:32.349 --> 00:19:36.709
If you have something more like where the image
is displayed repeatedly in the same place,

00:19:36.710 --> 00:19:39.660
but at different scale factors,
probably what you need to do is you need

00:19:39.660 --> 00:19:42.900
to tell the image don't throw out the original information.

00:19:42.900 --> 00:19:43.990
And that's the magic method.

00:19:43.990 --> 00:19:46.049
This is set data retained, yes.

00:19:46.049 --> 00:19:48.019
So typically when you start looking at caching problems,

00:19:48.019 --> 00:19:51.599
this is really the first thing that
you're going to want to look at.

00:19:51.599 --> 00:19:54.139
We set that automatically for some
kinds of images in Leopard.

00:19:54.140 --> 00:19:56.100
We've added some standard named images.

00:19:56.099 --> 00:20:00.490
I think Elise spoke about them a little
in the Cocoa Today talk yesterday.

00:20:00.490 --> 00:20:05.309
Things like a network icon, or if you want
the gear that shows up in the action pop

00:20:05.309 --> 00:20:07.179
up menus, we have those available for you now.

00:20:07.180 --> 00:20:10.060
And since we do kind of figure they'll
probably be used in more than one place.

00:20:10.059 --> 00:20:12.000
We already set this on them.

00:20:12.000 --> 00:20:18.480
And then the big hammer we need to pull out is NS image
cache never, which just tells it no caching for you.

00:20:18.480 --> 00:20:20.200
Okay. That's all I have to say about that.

00:20:20.200 --> 00:20:22.990
Let's talk a little bit more of these other features.

00:20:22.990 --> 00:20:27.079
So there's a compositing operation, which is one

00:20:27.079 --> 00:20:30.289
of the operations that's passed into
NS image when you tell it to draw.

00:20:30.289 --> 00:20:32.789
It has very good spots.

00:20:32.789 --> 00:20:34.659
You have to type it all the time.

00:20:34.660 --> 00:20:35.680
And what does this have to do with?

00:20:35.680 --> 00:20:41.259
This has to do with different ways of interpreting the alpha
parameter in a color and different ways of blending an image

00:20:41.259 --> 00:20:43.379
with what it's drawing on, which is called the destination.

00:20:43.380 --> 00:20:48.550
The screen shot down here is from a sample app, that's
in developer examples, it's called composite lab.

00:20:48.549 --> 00:20:50.470
It lets you play with these modes.

00:20:50.470 --> 00:20:54.110
So doing it visually is one way to do it, but I
actually like to talk about how you can figure

00:20:54.109 --> 00:20:58.759
out what they do given the mathematics of
how these compositing modes are defined.

00:20:58.759 --> 00:21:04.680
And the mathematics are actually given in the headers,
especially if you look at the CG context dot H,

00:21:04.680 --> 00:21:09.049
you'll see completely spelled out exactly
what all these compositing modes do.

00:21:09.049 --> 00:21:10.519
So let's start on this.

00:21:10.519 --> 00:21:14.629
So usually, like I said, so how is a color
represented, colors that go to the screen?

00:21:14.630 --> 00:21:18.150
There's a red parameter, a green parameter,
a blue parameter and there's alpha.

00:21:18.150 --> 00:21:21.620
And we usually think of the alpha as
meaning opacity, but it doesn't have to.

00:21:21.619 --> 00:21:24.459
And these compositing modes are basically
about different ways of interpreting that.

00:21:24.460 --> 00:21:30.670
First, to understand the math, you have to understand
first what is meant by pre-multiplied alpha.

00:21:30.670 --> 00:21:32.560
It just happens as a convenience.

00:21:32.559 --> 00:21:36.349
Pretty much all the different ways you need to draw,
the first thing you end up needing to do is you need

00:21:36.349 --> 00:21:41.689
to multiply the red, the green and the blue by the
alpha to do all of your different kinds of drawing.

00:21:41.690 --> 00:21:45.880
And because that's always done for all the
different modes, we tend to just do that once

00:21:45.880 --> 00:21:49.290
up front, and that's called pre-multiplied alpha.

00:21:49.289 --> 00:21:53.589
And that just means that the color is stored as R times
alpha, G times alpha, B times alpha and then alpha.

00:21:53.589 --> 00:21:56.829
There's not data lost there, except in precision issues.

00:21:56.829 --> 00:22:01.849
Yeah, but the mathematics already assume
that you have pre-multiplied alpha.

00:22:01.849 --> 00:22:06.839
So the most standard composting mode we
have is called NS composite source over.

00:22:06.839 --> 00:22:11.699
That's actually by itself an important thing to realize,
which is if you want normal, if you don't want to think

00:22:11.700 --> 00:22:16.730
about compositing modes right now, but you need to
pass one in, what you want is NS composite source over.

00:22:16.730 --> 00:22:18.299
Here's how it's defined.

00:22:18.299 --> 00:22:24.039
The result is equal to the source plus
destination times one minus source alpha.

00:22:24.039 --> 00:22:25.339
Okay, what do these words mean?

00:22:25.339 --> 00:22:26.889
Results mean what you get.

00:22:26.890 --> 00:22:29.320
Source is the image that you're drawing.

00:22:29.319 --> 00:22:33.019
Destination is what's already there
in the context when you're drawing it.

00:22:33.019 --> 00:22:38.420
Okay. And what I want to say is the way you understand
one of these formulas is to try to do it by special cases.

00:22:38.420 --> 00:22:42.779
So what would happen for a pixel where the
destination was empty, where it was zero?

00:22:42.779 --> 00:22:46.389
Well it would be result equals source
plus zero times one minus source alpha,

00:22:46.390 --> 00:22:48.450
so you can see you just get the source itself.

00:22:48.450 --> 00:22:51.880
Okay? If the source is empty, what are you going to get?

00:22:51.880 --> 00:22:53.520
Well, you see, you just get the destination.

00:22:53.519 --> 00:22:57.240
And then as the opacity of the source
increases, of the image increases,

00:22:57.240 --> 00:23:01.549
you see it's going to linearly show
more and more of the image itself.

00:23:01.549 --> 00:23:06.269
Okay? So that's the way that I find to be most
useful to understand what these actually do.

00:23:06.269 --> 00:23:11.440
And here are a couple of cases and some of
the ways that we use them within the App Kit.

00:23:11.440 --> 00:23:13.220
So like I said, NS composite source over.

00:23:13.220 --> 00:23:15.350
This is normal.

00:23:15.349 --> 00:23:17.919
Use this in almost all circumstances.

00:23:17.920 --> 00:23:20.480
Okay. NS composite copy.

00:23:20.480 --> 00:23:23.319
The main reason for understanding
this mode is not actually because it's

00:23:23.319 --> 00:23:26.649
so wonderfully useful, it's because Cocoa uses it sometimes.

00:23:26.650 --> 00:23:28.460
NS rect fill, for example, uses this.

00:23:28.460 --> 00:23:33.450
What this does is it just completely
replaces the result with the new image

00:23:33.450 --> 00:23:35.900
that you're drawing, so there's no blending whatsoever.

00:23:35.900 --> 00:23:41.490
So that does not interpret the alpha parameter's opacity
because it just completely replaces whatever you had.

00:23:41.490 --> 00:23:44.910
The alpha is still there, it just
won't act the way you expect.

00:23:44.910 --> 00:23:50.290
Okay. So the main reason to know about that
is to understand when it's bothering you.

00:23:50.289 --> 00:23:55.869
So if you do something like, if you try to set a
color, blue color with an alpha value of point three

00:23:55.869 --> 00:23:59.219
and then you use NS rect fill, it'll end
up drawing that more or less opaquely.

00:23:59.220 --> 00:24:01.920
Okay. So a couple of more interesting ones.

00:24:01.920 --> 00:24:04.279
So how about NS composite source atop?

00:24:04.279 --> 00:24:05.889
What do we end up using that for?

00:24:05.890 --> 00:24:11.980
Well, you've seen probably when you click a
button in Cocoa, if there's an image on it,

00:24:11.980 --> 00:24:16.130
we need to shade the image darker so
that it looks like its pressed hue.

00:24:16.130 --> 00:24:17.320
And this is actually how we do it.

00:24:17.319 --> 00:24:25.399
What we do is we take the image and we draw a
rectangle over it, which is half opaque gray,

00:24:25.400 --> 00:24:28.070
and we draw it with NS composite source atop mode.

00:24:28.069 --> 00:24:33.619
Now if you look at the definition of this mode, you'll
see it's the same as the definition of source over,

00:24:33.619 --> 00:24:38.339
only the source parameter's also
scaled by the destination's alpha.

00:24:38.339 --> 00:24:39.609
So what is that going to mean?

00:24:39.609 --> 00:24:46.069
It's going to mean that where the destination is already
completely transparent, you will not get any new drawing.

00:24:46.069 --> 00:24:47.389
It will stay transparent.

00:24:47.390 --> 00:24:52.830
Where the destination is completely opaque, it's
going to work exactly like normal source over drawing.

00:24:52.829 --> 00:24:58.079
Where the destination is somewhat opaque,
that's where you're going to see some coverage.

00:24:58.079 --> 00:25:00.309
Okay? So it's going to do exactly
what you want for this kind of thing

00:25:00.309 --> 00:25:02.889
if you have anti-aliasing on the edges of your images.

00:25:02.890 --> 00:25:06.170
Okay. And then there's NS composite plus lighter,
which I'm going to go into a little bit more.

00:25:06.170 --> 00:25:06.960
This is a funny mode.

00:25:06.960 --> 00:25:12.759
This just adds just straight up the source
and the destination to get the result.

00:25:12.759 --> 00:25:18.450
And what I want to say about this one is that interestingly
this ends up to be a really good way to draw images flush,

00:25:18.450 --> 00:25:22.890
regions flush without pixel cracks, which is
otherwise fairly hard with anti-aliasing.

00:25:22.890 --> 00:25:24.860
So here's now that ends up working.

00:25:24.859 --> 00:25:28.899
Suppose that you have two non overlapping regions, okay?

00:25:28.900 --> 00:25:31.240
But suppose that they're meeting not on a pixel boundary.

00:25:31.240 --> 00:25:34.740
Let's see what happens if we try to draw
this in the normal compositing modes.

00:25:34.740 --> 00:25:36.480
Okay so here's what we want to draw.

00:25:36.480 --> 00:25:38.730
Here's the formula that gets applied when we draw it.

00:25:38.730 --> 00:25:40.140
And you should expect this.

00:25:40.140 --> 00:25:41.170
You get anti-aliasing.

00:25:41.170 --> 00:25:44.360
So when the middle pixel gets covered
completely, you get full coverage.

00:25:44.359 --> 00:25:47.039
But on the two on the side, you get only half coverage.

00:25:47.039 --> 00:25:50.869
Now the bad thing that happens is what happens
when we go to draw the other rectangle?

00:25:50.869 --> 00:25:54.559
Well exactly the same thing happens,
and the way it works out is

00:25:54.559 --> 00:25:56.789
that you have not completely covered that middle pixel.

00:25:56.789 --> 00:25:58.789
Instead, you drew with half opacity twice.

00:25:58.789 --> 00:26:00.940
That doesn't work.

00:26:00.940 --> 00:26:05.860
And you get these funny looking
pixel cracks all over the image.

00:26:05.859 --> 00:26:08.379
So, here's just something that we
discovered in the course of Leopard drawing.

00:26:08.380 --> 00:26:13.560
A good way to get around that turns out
to be NS composite plus lighter mode.

00:26:13.559 --> 00:26:19.460
Okay? So you draw the first time, it uses this formula
for applying it and you get exactly the same results.

00:26:19.460 --> 00:26:25.200
However, when you go to draw the second rectangle,
okay, look at the way those two are going to add.

00:26:25.200 --> 00:26:27.100
You're just going to get complete
coverage right in the center,

00:26:27.099 --> 00:26:29.490
anti-aliasing on the sides, which is exactly what you want.

00:26:29.490 --> 00:26:32.529
What this ends up doing, yeah, exactly what you want.

00:26:32.529 --> 00:26:39.250
What this ends up doing is that when you're drawing in
normal source over mode, if you have partial coverage

00:26:39.250 --> 00:26:43.039
on a pixel, partial opacity, what
it's going to assume that that means,

00:26:43.039 --> 00:26:48.759
it's going to assume that it's always full coverage
of the pixel with a certain level of opacity.

00:26:48.759 --> 00:26:51.900
When you're drawing in composite plus
lighter mode, this is the difference,

00:26:51.900 --> 00:26:56.530
instead it's assuming that you are
completely covering half of the pixel.

00:26:56.529 --> 00:27:02.950
Okay? And the funny thing is that in our graphics system
that's pixel based at its deepest levels in Core Graphics,

00:27:02.950 --> 00:27:06.529
we can't make that distinction when
you're drawing in source over mode,

00:27:06.529 --> 00:27:08.759
so you end up having these resolution dependence issues.

00:27:08.759 --> 00:27:09.990
So that's a little bit subtle.

00:27:09.990 --> 00:27:13.970
But basically I recommend taking
a look at the compositing modes.

00:27:13.970 --> 00:27:16.440
But that's all I have to say about them for now.

00:27:16.440 --> 00:27:18.690
So let's move on a little bit.

00:27:18.690 --> 00:27:22.330
Let's talk about how you go about
creating a new image from drawing.

00:27:22.329 --> 00:27:25.819
How you encapsulate drawing an image that you
can pass off then to a button or an image rep

00:27:25.819 --> 00:27:29.329
or whatever you want, an image view, I mean.

00:27:29.329 --> 00:27:30.589
Well, you do it like this.

00:27:30.589 --> 00:27:31.199
It's very easy.

00:27:31.200 --> 00:27:37.890
You say NS image alloc init with size, you'd say lock
focus, you do some drawing and then you unlock focus.

00:27:37.890 --> 00:27:39.120
Well that's easy.

00:27:39.119 --> 00:27:42.099
Now you've got an image that contains
the string that you just drew.

00:27:42.099 --> 00:27:43.879
But there's some questions.

00:27:43.880 --> 00:27:47.940
So I've claimed so far that NS image is
primarily a container for its image reps.

00:27:47.940 --> 00:27:48.730
So what just happened?

00:27:48.730 --> 00:27:49.490
What are the image reps?

00:27:49.490 --> 00:27:50.890
What is the resolution of this thing?

00:27:50.890 --> 00:27:53.480
If we want to be resolution independent
we need to understand these things.

00:27:53.480 --> 00:27:59.039
Okay. So the key to understanding this is to understand
what is philosophically going on when you call lock focus.

00:27:59.039 --> 00:28:02.670
This is not what actually happens, but
this is the right way to think of it.

00:28:02.670 --> 00:28:05.779
It'll give you the right intuition.

00:28:05.779 --> 00:28:08.509
You're getting an off screen window, okay?

00:28:08.509 --> 00:28:12.109
There's a view in the window, the
same as any view in any other window.

00:28:12.109 --> 00:28:15.129
You're drawing to that view.

00:28:15.130 --> 00:28:21.190
Lock focus sets up the context so
that you are drawing to the view.

00:28:21.190 --> 00:28:21.740
Then you draw.

00:28:21.740 --> 00:28:25.990
And then when you do unlock focus it rips
the pixels of the place where you just drew

00:28:25.990 --> 00:28:29.240
and assembles them into a new image rep for you.

00:28:29.240 --> 00:28:31.230
Okay? That's what happens.

00:28:31.230 --> 00:28:33.099
So let's go through and figure out a few of those things.

00:28:33.099 --> 00:28:35.959
So first of all, it's going to be a bitmap representation.

00:28:35.960 --> 00:28:37.200
It's not resolution independent.

00:28:37.200 --> 00:28:40.140
It's going to be at the default scale factor.

00:28:40.140 --> 00:28:43.710
The way to think of this is that if you're drawing
in a window, the same as you draw in any window,

00:28:43.710 --> 00:28:51.559
every window always has a default user space scale
factor applied to it, so if the user has selected three

00:28:51.559 --> 00:28:57.440
as the scale factor and what you passed into init
with size for the NS image was three by three,

00:28:57.440 --> 00:29:00.930
the number of pixels you have will be nine by nine.

00:29:00.930 --> 00:29:03.720
And then it's also interesting to note
what it does to the image representations.

00:29:03.720 --> 00:29:04.799
It scraps them.

00:29:04.799 --> 00:29:05.639
All of the other ones.

00:29:05.640 --> 00:29:06.690
It's replacing them.

00:29:06.690 --> 00:29:12.470
So when it draws into the view for the first time, it's
going to use those representations, it's going to pick one,

00:29:12.470 --> 00:29:16.190
it's going to draw it, then you do your
extra drawing and then when you pull it back

00:29:16.190 --> 00:29:19.230
out you have this new representation,
and the others have to be thrown away.

00:29:19.230 --> 00:29:20.400
They really have to be thrown away.

00:29:20.400 --> 00:29:24.210
Something I haven't mentioned yet is
that all of the image representations

00:29:24.210 --> 00:29:27.279
for an image really need to represent the same drawing.

00:29:27.279 --> 00:29:30.190
They can be optimized for different
destinations, but you shouldn't try to do something

00:29:30.190 --> 00:29:35.660
like put an entirely different image up there as the highest
resolution image because you don't really have good control

00:29:35.660 --> 00:29:41.130
over Cocoa deciding to pick it, for some reason, and
there have been, in system preferences, actually,

00:29:41.130 --> 00:29:44.180
was trying to pull tricks like this
and it's causing some problems.

00:29:44.180 --> 00:29:49.410
So, anyway, that's how that works.

00:29:49.410 --> 00:29:52.320
I think I've explained that enough.

00:29:52.319 --> 00:29:54.730
A few caveats though, that are associated with that, then.

00:29:54.730 --> 00:29:56.170
So there's a resolution issue.

00:29:56.170 --> 00:29:59.620
So this lock focus is going to
be good in lots of situations.

00:29:59.619 --> 00:30:03.459
When you're drawing to image into views that
you're not doing any intentional scaling with

00:30:03.460 --> 00:30:06.390
or images that you're not scaling,
but sometimes it might not work.

00:30:06.390 --> 00:30:12.020
Also for performance reasons, even though you think of
a window as a good way to understand what's going on,

00:30:12.019 --> 00:30:17.539
please don't actually call the window method as
a cached image rep, which is actually exposed.

00:30:17.539 --> 00:30:22.099
Because this turns out it's not a very efficient way to do
it with Core Graphics now and we may actually end up having

00:30:22.099 --> 00:30:28.029
to create a window for you when you call this window
method, which is a little expensive, so don't do that.

00:30:28.029 --> 00:30:33.839
Then another interesting issue, which is not at all
specific to NS cached, with lock focus is what happens

00:30:33.839 --> 00:30:37.689
with sub pixel rendering, which is called
font smoothing at the Core Graphics level.

00:30:37.690 --> 00:30:43.830
You've probably seen this if you look really closely at
text, you'll see that it has colored fringes on the edges.

00:30:43.829 --> 00:30:45.129
You'll see red and blue.

00:30:45.130 --> 00:30:50.320
I always used to think that this was just some form of
anti-aliasing where it's just somehow fooling your eye

00:30:50.319 --> 00:30:52.289
with the red and the blue, that's actually not the case.

00:30:52.289 --> 00:30:57.170
What's going on is that it's taking advantage of
the physical layout of the LCDs on your display.

00:30:57.170 --> 00:30:59.840
They lay out from red, green, blue, in that order.

00:30:59.839 --> 00:31:05.250
And if you draw something red, that's going to look
like it's weighted to the left side of the pixel.

00:31:05.250 --> 00:31:08.779
So in a case like this W, you see it looks
much more pixilated on the left than it does

00:31:08.779 --> 00:31:11.240
on the right and that's how it's coming out.

00:31:11.240 --> 00:31:12.410
These are images from Wikipedia.

00:31:12.410 --> 00:31:14.880
They're nicely in the public domain,
so I can put them in my talk.

00:31:14.880 --> 00:31:17.720
But there's a really great article on sub
pixel rendering, I recommend you read.

00:31:17.720 --> 00:31:22.140
But the point of this is it's not going to
work if you're drawing into a transparent image.

00:31:22.140 --> 00:31:26.740
So if you want this to work, you need to do something
like fill with white first, or fill with any color.

00:31:26.740 --> 00:31:31.200
And this is just the technical detail that
you end up needing to be able to track,

00:31:31.200 --> 00:31:35.080
if we wanted this to work you'd
have to have separate red opacity,

00:31:35.079 --> 00:31:37.220
blue opacity and green opacity, and we don't have that.

00:31:37.220 --> 00:31:40.630
We just have a single alpha parameter,
which is why that doesn't work today.

00:31:40.630 --> 00:31:47.230
Anyway, if you need to work around the resolution issue,
the right way to do it is to use NS bitmap image rep instead

00:31:47.230 --> 00:31:49.319
for your drawing, instead of using lock focus.

00:31:49.319 --> 00:31:51.970
The way that works is that there's this class method

00:31:51.970 --> 00:31:56.380
that let's you create a bitmap image
rep just exactly the way you want.

00:31:56.380 --> 00:31:58.030
You have lots and lots of control.

00:31:58.029 --> 00:31:59.549
And then how do you end up drawing to it?

00:31:59.549 --> 00:32:02.289
Well, this was added in Tiger, I believe.

00:32:02.289 --> 00:32:06.019
You can create a graphics context from the bitmap image rep.

00:32:06.019 --> 00:32:09.049
See here, graphic context width bitmap image rep.

00:32:09.049 --> 00:32:14.009
Then you would, and now you pull this stuff I was
talking about earlier, you call save graphics context,

00:32:14.009 --> 00:32:17.450
necessarily the class method, which
will save the current context.

00:32:17.450 --> 00:32:21.460
Then you make the new context you've
made current, then you can draw to it,

00:32:21.460 --> 00:32:23.600
and then you restore back to what was already there.

00:32:23.599 --> 00:32:27.730
Okay? So not so hard.

00:32:27.730 --> 00:32:30.710
Now one issue here that I'd like to
talk about is mutability of NS image.

00:32:30.710 --> 00:32:33.380
So there are quite a few methods that
we've seen which will change an image.

00:32:33.380 --> 00:32:34.590
You can call lock focus.

00:32:34.589 --> 00:32:36.049
You can call set size.

00:32:36.049 --> 00:32:37.149
You can call set flipped.

00:32:37.150 --> 00:32:42.130
We haven't really talked about set flipped
too much yet, but that's the next slide.

00:32:42.130 --> 00:32:45.670
Basically, even though you can
do this, you sort of shouldn't.

00:32:45.670 --> 00:32:49.480
The right way to think of images as if they are immutable.

00:32:49.480 --> 00:32:54.279
You would create it from disk, you would get it set
up properly, then you would stop messing with it.

00:32:54.279 --> 00:32:56.609
It's not something you want to continue changing.

00:32:56.609 --> 00:32:59.439
You might want to change it maybe
at certain times in the future.

00:32:59.440 --> 00:33:02.309
Maybe you say oh, now is the time for
me to change my image for a while.

00:33:02.309 --> 00:33:03.240
But do it in phases.

00:33:03.240 --> 00:33:05.839
Don't just intersperse drawing with changing your images.

00:33:05.839 --> 00:33:09.159
So a good way to see what goes wrong
with this sort of thing is to look

00:33:09.160 --> 00:33:13.029
at the image set flipped method, which
is I think not so well understood.

00:33:13.029 --> 00:33:20.099
So the set flip method describes the flippedness
of the internal coordinate space of an image.

00:33:20.099 --> 00:33:22.309
Okay? External users don't need to know about it.

00:33:22.309 --> 00:33:28.179
So we have this dog cow, and the whole point of this is
that the dog cow on the right is not actually upside down.

00:33:28.180 --> 00:33:33.049
Okay? The image may be flipped, but that just
means that zero, zero is in the top left.

00:33:33.049 --> 00:33:35.399
It doesn't mean that it's an upside down dog cow.

00:33:35.400 --> 00:33:40.390
Okay? Same as for, the right way to think as with
view, some views are flipped, some views aren't.

00:33:40.390 --> 00:33:45.890
That doesn't mean the flipped draw their stuff upside down,
that just means that their origin's in the top left.

00:33:45.890 --> 00:33:46.259
Okay. Yeah.

00:33:46.259 --> 00:33:49.230
So again, it has to do with coordinate
systems that I want to harp on,

00:33:49.230 --> 00:33:52.549
because I would like everybody to
start paying attention to them.

00:33:52.549 --> 00:33:57.480
We have them because this is really a
good way to be able to compose larger,

00:33:57.480 --> 00:33:59.190
more complicated drawing out of smaller things.

00:33:59.190 --> 00:34:04.440
When you're working within an image, you wouldn't want to
need to know how the image is being drawn to the context,

00:34:04.440 --> 00:34:06.730
it may not even be being drawn to the context yet.

00:34:06.730 --> 00:34:08.250
There may be not context.

00:34:08.250 --> 00:34:09.699
So you need to be able to work locally.

00:34:09.699 --> 00:34:11.869
And again, there's no universal space.

00:34:11.869 --> 00:34:17.210
So whenever you have rectangles, just keep track of what
space they're in and make sure you convert it appropriately.

00:34:17.210 --> 00:34:20.349
So when is this internal space used?

00:34:20.349 --> 00:34:21.739
Well, it's used in lock focus.

00:34:21.739 --> 00:34:22.759
That's an obvious time.

00:34:22.760 --> 00:34:24.330
It's also used in NS custom image rep.

00:34:24.329 --> 00:34:26.880
I mentioned this very briefly before,
but I didn't say what it was.

00:34:26.880 --> 00:34:27.750
This is a cool class.

00:34:27.750 --> 00:34:29.780
You should take a look at it if
you're not already familiar with it.

00:34:29.780 --> 00:34:35.560
It takes a delegate and the delegate basically
is supposed to implement a draw method.

00:34:35.559 --> 00:34:41.360
So it wires up an image to work quite a bit more like
a view when the image is asked to draw it's going

00:34:41.360 --> 00:34:44.690
to make this callback, say hey, do the drawing please.

00:34:44.690 --> 00:34:50.019
So it's a nice way to do problematic drawing in an image.

00:34:50.019 --> 00:34:55.050
Okay. So the problem with flipped is not so much
what it's for, as what people thing it's for.

00:34:55.050 --> 00:35:00.460
So people think it's the right way to do right side up
drawing of images in flipped views, and that's not the case.

00:35:00.460 --> 00:35:07.070
So if you try to pull this sort of thing, if
you say self image set flipped, self is flipped,

00:35:07.070 --> 00:35:11.450
the second one that's calling the view method is
flipped, this is not going to do anything very good.

00:35:11.449 --> 00:35:12.369
It's very unreliable.

00:35:12.369 --> 00:35:18.599
If you're trying to use the image in more than
one place, it's going to have weird side effects.

00:35:18.599 --> 00:35:20.730
Okay, so let's see what happens
when you do something like this.

00:35:20.730 --> 00:35:23.090
Suppose the images is originally uncached.

00:35:23.090 --> 00:35:25.070
I love this dog cow.

00:35:25.070 --> 00:35:28.780
So suppose that you brought it in
from this bitmap image rep, okay?

00:35:28.780 --> 00:35:29.510
And you have this image.

00:35:29.510 --> 00:35:31.050
Now you call set flipped on the image.

00:35:31.050 --> 00:35:33.519
That's going to change the internal coordinate space.

00:35:33.519 --> 00:35:38.250
If you think of that cache window I was talking about, it's
basically if you're drawing into a flipped view instead

00:35:38.250 --> 00:35:40.780
of an unflipped view when it goes to cache.

00:35:40.780 --> 00:35:45.970
So when it goes to cache, it's going o take that bitmap
image rep, it's going to call the very simple method

00:35:45.969 --> 00:35:48.459
that we saw on NS image rep, which is draw.

00:35:48.460 --> 00:35:49.980
That doesn't have anything to do with flippedness.

00:35:49.980 --> 00:35:50.909
There's nothing there.

00:35:50.909 --> 00:35:54.929
So the bitmap image rep is going
to end up drawing upside down.

00:35:54.929 --> 00:35:58.469
And what you get is you get an image
which has a single cache image rep

00:35:58.469 --> 00:36:01.209
and the cache is going to have an upside down dog cow in it.

00:36:01.210 --> 00:36:04.960
Now the problem with this is that the
image is now intrinsically upside down.

00:36:04.960 --> 00:36:10.190
So if you go ahead and try to draw the image upside
down in a view, the two upside downs will cancel out

00:36:10.190 --> 00:36:11.869
and it will end up looking right side up.

00:36:11.869 --> 00:36:16.279
But if you try to pass it off to anything else in
Cocoa, we're not going to be able to get it right

00:36:16.280 --> 00:36:22.150
because there's no way for us to know that
this image is intrinsically upside down.

00:36:22.150 --> 00:36:23.170
Okay. So again.

00:36:23.170 --> 00:36:25.900
The rule of thumb here is that you
don't want to be modifying your images.

00:36:25.900 --> 00:36:30.220
And certainly something like calling set flipped,
that's something you very, very rarely want to do.

00:36:30.219 --> 00:36:33.689
You would do that once if you're going to want
to be drawing in it and it's more convenient

00:36:33.690 --> 00:36:35.059
for you to use its flipped coordinate space.

00:36:35.059 --> 00:36:36.199
I didn't even mention that.

00:36:36.199 --> 00:36:38.599
Pretty much the reason we have flipped
coordinate space is that for certain kinds

00:36:38.599 --> 00:36:40.789
of drawing it's just much, much more convenient.

00:36:40.789 --> 00:36:49.300
Okay. So try not to modify the images after their initial
set up, except if you want to, like I said at certain times.

00:36:49.300 --> 00:36:51.000
But don't do it willy nilly.

00:36:51.000 --> 00:36:51.469
All right.

00:36:51.469 --> 00:36:54.989
But now if I'm saying that's not how
you get an image to draw right side

00:36:54.989 --> 00:36:57.729
up in a flipped coordinate space, how should you do it?

00:36:57.730 --> 00:37:01.010
Well, the easiest way to do it is
to transform the coordinate system.

00:37:01.010 --> 00:37:02.940
This is actually not so hard.

00:37:02.940 --> 00:37:08.929
So I'm going to suggest, I'm going to
present a category method added to NS image,

00:37:08.929 --> 00:37:11.569
which takes additional parameter, flippedness.

00:37:11.570 --> 00:37:14.470
So whether or not the image should
be flipped before it's drawn.

00:37:14.469 --> 00:37:17.819
And not I added a prefix to this method
so that it doesn't possible conflict

00:37:17.820 --> 00:37:19.890
with anything AppKit might want to add in the future.

00:37:19.889 --> 00:37:25.940
So the overview of this method is we're going to transform
the coordinate system, if necessary, so the positive is up.

00:37:25.940 --> 00:37:30.480
We're going to express the rectangle
in the new destination coordinates.

00:37:30.480 --> 00:37:34.050
So now that that rectangle's coming in,
again, it's always relative to a space.

00:37:34.050 --> 00:37:37.570
It's relative to the ambient space
at the time the method was drawn.

00:37:37.570 --> 00:37:39.780
If we transform the coordinate system, we also have

00:37:39.780 --> 00:37:43.070
to transform the rectangle so it
still describes the same thing.

00:37:43.070 --> 00:37:44.950
It's the same thing that I've continued to talk about,

00:37:44.949 --> 00:37:47.609
which is what the rectangles are
with respect to the coordinate space.

00:37:47.610 --> 00:37:51.370
And then we have to draw and then we have to restore
the coordinate system so we don't have side effects.

00:37:51.369 --> 00:37:52.960
So here is the complete method.

00:37:52.960 --> 00:37:54.380
I'm not going to do it in this slide.

00:37:54.380 --> 00:37:56.640
I pretty much just wanted to point
out that it's pretty short.

00:37:56.639 --> 00:38:02.920
And if you're to do this, then you would never have problems
with getting images upside down again probably, hopefully.

00:38:02.920 --> 00:38:08.320
Okay. So the first step, as I said, is
we want to modify the coordinate system.

00:38:08.320 --> 00:38:10.500
I haven't actually talked about how you do that yet.

00:38:10.500 --> 00:38:14.929
So up at the Cocoa level, the class that we have
for this is called NS Affine transform.

00:38:14.929 --> 00:38:16.739
And the way it works is you have methods like this.

00:38:16.739 --> 00:38:21.349
You have scale X by, Y by, all right,
and you pass negative one for the Y by.

00:38:21.349 --> 00:38:28.170
That means that you're going to be sending the current
point, zero negative one, to the point zero one.

00:38:28.170 --> 00:38:31.230
The right way to think of that is
it's modifying the axis' themselves.

00:38:31.230 --> 00:38:35.179
Okay? The difference is that it's not modifying the
things that you're drawing, it's modifying the axis'.

00:38:35.179 --> 00:38:40.389
Like if you want to shift all your drawing to the
right, you need to move your axis' to the left.

00:38:40.389 --> 00:38:47.739
Okay. And the way we do that, the way we actually apply it
to the graphics context is to use the concatenate method.

00:38:47.739 --> 00:38:48.019
All right.

00:38:48.019 --> 00:38:49.250
Now this is what I was saying.

00:38:49.250 --> 00:38:53.639
So the original rectangle that was
passed in as a destination with respect

00:38:53.639 --> 00:38:56.339
to the coordinate system that was active at that time.

00:38:56.340 --> 00:39:01.660
Since we have changed coordinate systems, we need
to modify, we need to make ourselves a new rectangle

00:39:01.659 --> 00:39:04.960
that describes the same destination
location in the new space.

00:39:04.960 --> 00:39:05.630
So how does that work?

00:39:05.630 --> 00:39:11.269
So in the old coordinate system, it would
be the way I set it up on this diagram.

00:39:11.269 --> 00:39:16.599
The space from the axis down, that was
the old origin dot Y. and then the size

00:39:16.599 --> 00:39:19.069
of the rectangle was the old size, the height.

00:39:19.070 --> 00:39:22.400
Now the new rectangle, to describe
that we need to pick out the origin.

00:39:22.400 --> 00:39:23.650
Well, where is the origin?

00:39:23.650 --> 00:39:29.970
It's at minus original rect dot origin dot Y and
then minus original rect dot size dot height.

00:39:29.969 --> 00:39:32.500
See, that's why you end up having
to do these sort of transformations.

00:39:32.500 --> 00:39:39.010
And it's not a good idea to try to
just remember like this is what I do.

00:39:39.010 --> 00:39:42.400
It's better to just try to think about the
spaces, that way you won't make so many mistakes.

00:39:42.400 --> 00:39:44.139
All right.

00:39:44.139 --> 00:39:46.769
And then we just draw, which is very straightforward.

00:39:46.769 --> 00:39:50.670
And then we need to put the context back the way it was.

00:39:50.670 --> 00:39:55.700
Now note that actually, in this case, I did
not do the save and restore graphics context.

00:39:55.699 --> 00:40:00.189
Instead, I concatenated the X axis reflection
one more time to put it back the way it was.

00:40:00.190 --> 00:40:02.909
Oh, actually those two images are reversed.

00:40:02.909 --> 00:40:07.829
I concatenated that same transform
to put it back the way it was.

00:40:07.829 --> 00:40:08.500
Why did I do that?

00:40:08.500 --> 00:40:10.639
Well, actually I did it for performance.

00:40:10.639 --> 00:40:17.460
So these days, the way Quartz happens to work, changing
the context is relatively expensive when they switch

00:40:17.460 --> 00:40:21.070
on what's called Quartz GL, which
uses open GL for more of the drawing.

00:40:21.070 --> 00:40:24.350
So you want to avoid modifying
the context more than you have to.

00:40:24.349 --> 00:40:28.960
and saves and restores are relatively expensive next
to things like concatenating a single transformation.

00:40:28.960 --> 00:40:35.630
So that's why, because it was easy in
this case, I chose to just flip again.

00:40:35.630 --> 00:40:39.240
Okay, now that is really the way
you probably want to do this.

00:40:39.239 --> 00:40:42.329
Transforming the coordinate system is the right
way to get your images drawing right side up.

00:40:42.329 --> 00:40:47.599
But just for variety I'm going to explain other methods
and I'm going to show you how to do it using methods

00:40:47.599 --> 00:40:51.690
that are already on NS image, the composite functions.

00:40:51.690 --> 00:40:53.340
So let's look at this.

00:40:53.340 --> 00:40:57.780
So you may have noticed, if you've looked at NS image dot
H that there are these draw functions that we usually use,

00:40:57.780 --> 00:41:00.650
there are also these composite functions
that are very, very similar looking.

00:41:00.650 --> 00:41:07.079
Composite two point from rect operation fraction
versus draw at point from rect operation fraction.

00:41:07.079 --> 00:41:08.880
That's a little strange.

00:41:08.880 --> 00:41:10.190
These are almost the same declarations.

00:41:10.190 --> 00:41:11.710
So what's the difference?

00:41:11.710 --> 00:41:14.510
Well, the composite methods are kind of funny.

00:41:14.510 --> 00:41:19.990
They're older and they actually ignore the
current coordinate system, which is very odd.

00:41:19.989 --> 00:41:26.909
So what they're going to do is they're going
to completely undo everything down to pixels.

00:41:26.909 --> 00:41:29.779
If we had a universal space it
would be pixels, but like I said,

00:41:29.780 --> 00:41:32.230
the right way to think of it is to not think of it that way.

00:41:32.230 --> 00:41:33.510
You just always have spaces.

00:41:33.510 --> 00:41:36.790
And then it's going to scale back
up by the default scaling factor.

00:41:36.789 --> 00:41:42.849
So if you were trying to do something like tip your
dog cow by rotating the coordinate system a little bit,

00:41:42.849 --> 00:41:46.969
then you're going to find that if you use the
composite functions, that's not going to happen.

00:41:46.969 --> 00:41:49.889
Now this is actually pretty convenient though.

00:41:49.889 --> 00:41:56.719
If you have a coordinate system that's
flipped, where positive goes down the Y axis,

00:41:56.719 --> 00:42:01.750
well that won't effect the composite methods,
because composite just always doesn't pay attention

00:42:01.750 --> 00:42:05.019
to the current transformation,
to the current coordinate system,

00:42:05.019 --> 00:42:07.880
which is very convenient, as long
as it's not actually wrong.

00:42:07.880 --> 00:42:12.789
If you were a framework, it would be bad to do this, because
people are supposed to be able to change the way you draw.

00:42:12.789 --> 00:42:16.539
I mean if somebody intentionally modifies
the coordinate system, it should change.

00:42:16.539 --> 00:42:21.869
However, as an application developer you may know,
hey, I'm not doing anything interesting at all.

00:42:21.869 --> 00:42:28.319
These views are always just sitting here just completely
default an the drawing is just always going to be the same,

00:42:28.320 --> 00:42:30.309
in which case you can use composite methods if you want to.

00:42:30.309 --> 00:42:33.449
Thee are other cases where it may be useful.

00:42:33.449 --> 00:42:38.419
An example of that is say you have a graphics
drawing program, something with a canvas on it

00:42:38.420 --> 00:42:46.019
and say you have a graphics object, like in sketch, a
square, and when you select it it has little grab handles,

00:42:46.019 --> 00:42:50.340
well you might want to be able to change the zoom factor
of your canvas so that it gets bigger and smaller,

00:42:50.340 --> 00:42:52.940
but those grab handles, they would never change size.

00:42:52.940 --> 00:42:57.679
so a really convenient way to do that might be to use
the composite methods, because they won't pay attention

00:42:57.679 --> 00:42:59.949
to the fact that the scale factor is changing.

00:42:59.949 --> 00:43:01.929
Okay. That's all I have to say about NS image.

00:43:01.929 --> 00:43:08.069
So at this point I want to go through fairly briefly
and talk about some of the Core Graphics level APIs

00:43:08.070 --> 00:43:13.039
that are available to you that are alternatives to NS
images in some cases, and are compliments in some others.

00:43:13.039 --> 00:43:15.750
So first I want to talk about CG transparency layers.

00:43:15.750 --> 00:43:17.579
These are distinct.

00:43:17.579 --> 00:43:18.599
Maybe I'll go back for a second.

00:43:18.599 --> 00:43:21.039
These are distinct from the other
things we see on the slide.

00:43:21.039 --> 00:43:23.550
They're not the same as CG layer reps, if you've seen them.

00:43:23.550 --> 00:43:25.610
They're not the same as core animation layers.

00:43:25.610 --> 00:43:27.940
The word layer has been reused a few times.

00:43:27.940 --> 00:43:29.579
These are transparency layers.

00:43:29.579 --> 00:43:30.179
What are they for?

00:43:30.179 --> 00:43:35.649
Well I think the easiest way to see this
is to look at an example with focus rings.

00:43:35.650 --> 00:43:37.139
How do you draw focus rings in Cocoa?

00:43:37.139 --> 00:43:38.059
This is the question.

00:43:38.059 --> 00:43:39.949
Okay. Like this.

00:43:39.949 --> 00:43:41.779
We set something into the graphics context.

00:43:41.780 --> 00:43:43.920
We set a bit of state, which is the focus ring style.

00:43:43.920 --> 00:43:47.220
We say NS set focus ring style, focus ring style above.

00:43:47.219 --> 00:43:50.649
And then we draw, say we're trying to draw a
button, okay, and say it's in three pieces of art

00:43:50.650 --> 00:43:52.889
There's a left cap, a right cap and middle part.

00:43:52.889 --> 00:43:55.989
We would draw the left piece, we'd draw the
right piece, we'd draw the middle piece.

00:43:55.989 --> 00:43:56.279
All right.

00:43:56.280 --> 00:43:59.710
the problem is that if you'd do that, the
way the focus ring styles work is that each

00:43:59.710 --> 00:44:03.699
of those pieces drawn separately is going
to get a separate focus ring applied to it.

00:44:03.699 --> 00:44:06.659
Also very interesting to look a this,
from a users point of view you think of it

00:44:06.659 --> 00:44:10.519
as something that just floats above your views

00:44:10.519 --> 00:44:11.960
That's not the way it's implemented.

00:44:11.960 --> 00:44:14.360
They're just pixels drawn like everything else,

00:44:14.360 --> 00:44:18.809
which means that you can't erase a focus
ring, all you can do is draw over it.

00:44:18.809 --> 00:44:21.289
And if you've seen focus rings over
drawn, well that's what's happening,

00:44:21.289 --> 00:44:23.869
they're drawing multiple times and the get darker.

00:44:23.869 --> 00:44:25.690
Yeah, but this is not so good.

00:44:25.690 --> 00:44:27.840
So how do we make this work?

00:44:27.840 --> 00:44:30.110
Well, actually at the Cocoa level, it's fairly hard.

00:44:30.110 --> 00:44:36.170
But in Tiger, I believe, Core Graphics added this
CG context being transparency layer with rect,

00:44:36.170 --> 00:44:38.930
and what this does is it makes sort of a temporary grouping.

00:44:38.929 --> 00:44:42.719
The way to think of this is that here you
have your original context, your destination,

00:44:42.719 --> 00:44:46.109
and then you call this CG context being transparency layer,

00:44:46.110 --> 00:44:50.519
it makes sort of a new temporary
buffer that you're going to draw into.

00:44:50.519 --> 00:44:54.420
You do all your drawing into that buffer and
then when you end the transparency layer,

00:44:54.420 --> 00:44:57.059
everything you drew is going to
be composited down, together.

00:44:57.059 --> 00:45:01.639
And that focus ring will be applied
to all of them at the same time.

00:45:01.639 --> 00:45:06.879
So the way that ends up working is that when
you call the CG transparency layer begin,

00:45:06.880 --> 00:45:10.309
you get exactly the same graphics
state as before, with a few changes.

00:45:10.309 --> 00:45:13.460
It's going to reset your compositing mode back to normal.

00:45:13.460 --> 00:45:15.970
It's going to reset your alpha back to 1.0.

00:45:15.969 --> 00:45:21.219
it's going to reset your style, that's things like
focus rings and shadows, back to nothing at all.

00:45:21.219 --> 00:45:26.869
Okay, so that means that that allows you to
draw without the focus ring to begin with,

00:45:26.869 --> 00:45:30.529
but then when you finish your drawing the
entire layer gets the focus ring applied to it.

00:45:30.530 --> 00:45:31.590
So I already mentioned that case.

00:45:31.590 --> 00:45:32.160
That's one.

00:45:32.159 --> 00:45:35.159
Another interesting case, so I kind
of glossed over something before.

00:45:35.159 --> 00:45:42.179
When I was talking about using that additive compositing
mode to try to draw three part flush regions together

00:45:42.179 --> 00:45:45.379
without pixel cracks, and I was
saying hey, draw in additive mode.

00:45:45.380 --> 00:45:50.660
Well, there's a little problem with that, because if you
draw in additive mode, if there's anything already there

00:45:50.659 --> 00:45:52.929
that you're drawing on top of, it's not going to look right.

00:45:52.929 --> 00:45:53.759
so how do you do that?

00:45:53.760 --> 00:45:55.770
Well, you can do that with transparency layers.

00:45:55.769 --> 00:46:04.099
What you can do is the original compositing operation
would be normal, you start this transparency layer.

00:46:04.099 --> 00:46:08.130
In the transparency layer you set the
compositing operation to be the additive one.

00:46:08.130 --> 00:46:13.140
You do all your drawing there, and then when you finish
the layer, the entire layer, all of your drawing,

00:46:13.139 --> 00:46:16.980
gets composited down in the normal
mode, which is what you were after.

00:46:16.980 --> 00:46:19.349
So it's very, very useful, it's very easy.

00:46:19.349 --> 00:46:20.000
It's very convenient.

00:46:20.000 --> 00:46:25.869
The only thing I want to mention about it that's really
dangerous at all is that you see in this method that I had,

00:46:25.869 --> 00:46:33.440
it takes an additional argument, which is the
rectangle, begin transparency layer with rect.

00:46:33.440 --> 00:46:39.950
This particular method that takes the additional
rect is new in Leopard and what that rect is supposed

00:46:39.949 --> 00:46:44.669
to be is it's calling out the area within the
transparency layer that you're actually going to draw in.

00:46:44.670 --> 00:46:47.430
so it's going to act kind of like an additional clip.

00:46:47.429 --> 00:46:54.339
And if you don't use this new version of the method in
Leopard, or if you don't set the clip to be fairly tight

00:46:54.340 --> 00:46:57.329
to begin with, this transparency layer
will end up being very expensive to draw,

00:46:57.329 --> 00:46:59.360
and we've had some serious problems with that.

00:46:59.360 --> 00:47:02.230
So the new method should really alleviate those concerns.

00:47:02.230 --> 00:47:04.969
And if you have to work on Tiger, just
make sure that the clipping rectangle is

00:47:04.969 --> 00:47:07.329
as tight as you can make it before doing this.

00:47:07.329 --> 00:47:10.150
Okay. That's all I have to say about transparency layers.

00:47:10.150 --> 00:47:13.180
Now let's talk about CG image a little bit.

00:47:13.179 --> 00:47:16.429
So CG image is the primary image
abstraction at the Core Graphics layer.

00:47:16.429 --> 00:47:20.730
It's not actually very similar to NS image.

00:47:20.730 --> 00:47:23.039
It's really quite a bit more like NS bitmap image rep.

00:47:23.039 --> 00:47:24.699
It has an explicit resolution.

00:47:24.699 --> 00:47:28.929
It has a number of pixels and a size.

00:47:28.929 --> 00:47:31.230
That's how it works.

00:47:31.230 --> 00:47:36.210
The main difference from NS bitmap image rep
is that you cannot get at the data, all right?

00:47:36.210 --> 00:47:38.260
Within a bitmap image rep you can always get the byte.

00:47:38.260 --> 00:47:39.280
You can always look at them.

00:47:39.280 --> 00:47:47.140
CG images are completely, well they're opaque type, which
is to say that all you can do with them is draw them,

00:47:47.139 --> 00:47:50.529
you can ask for some certain limited kinds
of information, but not the actual data.

00:47:50.530 --> 00:47:53.440
The reason that's done is it's done for efficiency.

00:47:53.440 --> 00:47:58.769
That means that Core Graphics has lots and lots
of latitude for how it wants to store this,

00:47:58.769 --> 00:48:01.980
when it wants to upload the data to the graphics
card, when it wants to bring the data back

00:48:01.980 --> 00:48:04.449
from the graphics card, if that's something it needs to do.

00:48:04.449 --> 00:48:08.619
So it's very efficient, and that's what it's really for.

00:48:08.619 --> 00:48:10.469
When do I suggest you use it?

00:48:10.469 --> 00:48:15.209
Well, if you're really sure what you're going
for, if you have a very specific context,

00:48:15.210 --> 00:48:18.420
and you're finding NS image is kind of just too smart
for you, because it's defeating what you're trying

00:48:18.420 --> 00:48:20.840
to do, you might want to look at CG image.

00:48:20.840 --> 00:48:24.309
And also it's useful when you're dealing
with APIs that already use CG images

00:48:24.309 --> 00:48:28.630
because otherwise there's an impedance mismatch
and you're just constantly converting everything.

00:48:28.630 --> 00:48:36.470
But do be a little careful with it because if you do decide
to use CG images, then you really have to think about a lot

00:48:36.469 --> 00:48:40.829
of extra things that you would not ordinarily,
for example, resolution independence.

00:48:40.829 --> 00:48:44.559
But these caching things that NS image
does for you, they're really pretty nice

00:48:44.559 --> 00:48:46.289
and you should try to take advantage of them if you can.

00:48:46.289 --> 00:48:48.800
So don't just go down if you don't have to.

00:48:48.800 --> 00:48:49.920
all right.

00:48:49.920 --> 00:48:53.269
like I said, making them is easier than it used to be.

00:48:53.269 --> 00:48:58.019
You can make one from a bitmap image rep and
you can create a bitmap image rep from one.

00:48:58.019 --> 00:49:02.429
It's maybe worth noted that second method,
init CG image, that's a very efficient method.

00:49:02.429 --> 00:49:05.960
It will take the CG image and will not do anything.

00:49:05.960 --> 00:49:06.920
It'll just hold on to it.

00:49:06.920 --> 00:49:12.820
If you ask for the data that backs the NS bitmap image
rep, at that point it will draw the CG image in order

00:49:12.820 --> 00:49:14.950
to create the data, but it will do that lazily.

00:49:14.949 --> 00:49:20.349
So you're not likely to do better than
what we have done by writing it yourself.

00:49:20.349 --> 00:49:23.619
You're welcome to write it yourself
if you want, but you don't need to.

00:49:23.619 --> 00:49:26.789
and then the other thing, however,
since they are completely immutable,

00:49:26.789 --> 00:49:29.610
people sometimes wonder well how do I make a new CG image?

00:49:29.610 --> 00:49:35.450
Okay. The way you do that is actually you create
a CG bitmap context rep and you draw in that.

00:49:35.449 --> 00:49:43.049
And there's a method in CG image context,
which can pull the CG image from it.

00:49:43.050 --> 00:49:45.750
Okay. So let's talk about CG layer rep.

00:49:45.750 --> 00:49:49.659
okay, so this is one of those, I think, relatively unknown.

00:49:49.659 --> 00:49:52.159
It was added in Tiger in Core Graphics.

00:49:52.159 --> 00:49:54.980
It's similar to CG image, but it is mutable.

00:49:54.980 --> 00:50:00.920
So it works really a lot like NS image's lock focus
and it's even the same in that the size that you pass

00:50:00.920 --> 00:50:08.780
into the CG layer rep is the same as the size when
you do NS image init width size and then lock focus,

00:50:08.780 --> 00:50:12.440
and then it's going to be always scaled
up by the default scale factor in terms

00:50:12.440 --> 00:50:16.119
of the number of pixels you end up getting.

00:50:16.119 --> 00:50:17.710
It's easy to instantiate.

00:50:17.710 --> 00:50:21.130
You can see that I have the function
you call right up here at the top.

00:50:21.130 --> 00:50:23.170
It takes a reference context.

00:50:23.170 --> 00:50:28.820
That context is not used for drawing, it's
used to decide things like characteristics.

00:50:28.820 --> 00:50:33.370
That's how when you're drawing to the screen it's going
to look at it and decide what a good pixel format is

00:50:33.369 --> 00:50:39.409
so that it can do that nice RGB LCD text
rendering that we were looking at before.

00:50:39.409 --> 00:50:41.269
So how does this different from NS image rep?

00:50:41.269 --> 00:50:42.889
well, NS image's lock focus?

00:50:42.889 --> 00:50:46.269
Well, you're actually drawing directly to a
texture on the graphics card when you do this.

00:50:46.269 --> 00:50:48.420
And that's relatively exposed.

00:50:48.420 --> 00:50:55.590
So the main difference is that sometimes that original
drawing can be faster if you're drawing to a CG layer rep.

00:50:55.590 --> 00:51:00.170
so if you have something that's already, if you have a CG
image, and you're drawing a CG image into the CG layer,

00:51:00.170 --> 00:51:04.380
if the image has already been uploaded to the
graphics card, that initial drawing can be very fast.

00:51:04.380 --> 00:51:08.329
If you don't have to do things like that, and if
it's not convenient for you for whatever reason,

00:51:08.329 --> 00:51:12.880
CG image is a little bit better, if you have
the choice, if you don't need the mutability,

00:51:12.880 --> 00:51:16.300
because it gives Core Graphics more
latitude to just do whatever it wants.

00:51:16.300 --> 00:51:20.630
And of course, you can stay up at the NS
image level, if that's appropriate for you.

00:51:20.630 --> 00:51:24.309
CI image. This is perhaps a little
bit more clear when it's appropriate.

00:51:24.309 --> 00:51:25.789
It's for image processing.

00:51:25.789 --> 00:51:27.969
I think people probably have that idea at this point.

00:51:27.969 --> 00:51:31.739
But if you want to do things like
apply Photoshop style filters, effects,

00:51:31.739 --> 00:51:35.500
complex compositing, that's what
CI image is really good for.

00:51:35.500 --> 00:51:37.869
It is explicitly bitmap based, again.

00:51:37.869 --> 00:51:43.859
So you're going to have to worry about
resolution dependence issues if you work with it.

00:51:43.860 --> 00:51:44.650
How do you make them?

00:51:44.650 --> 00:51:49.869
Well, there are some new methods added to
Leopard, NS bitmap image rep init width CI image.

00:51:49.869 --> 00:51:51.000
That one's new.

00:51:51.000 --> 00:51:54.329
Again, since CI images are explicitly bitmap based,

00:51:54.329 --> 00:51:57.429
it's more similar to NS bitmap image
rep than it is to NS image itself.

00:51:57.429 --> 00:52:00.279
And the way you'd use this, by the
way, oh, I haven't mentioned that yet.

00:52:00.280 --> 00:52:03.410
So if you have an NS bitmap image rep and you
want to make an image out of it, what do you do?

00:52:03.409 --> 00:52:05.389
You make an image and you add the representation.

00:52:05.389 --> 00:52:07.269
There's a method add representation.

00:52:07.269 --> 00:52:11.139
Okay, and then you can make a CI
image from a bitmap image rep as well.

00:52:11.139 --> 00:52:13.489
And that one was already around in Tiger.

00:52:13.489 --> 00:52:15.959
Last thing I want to talk about,
Core Animation just a little bit.

00:52:15.960 --> 00:52:19.300
And it's actually not so much of
a competitor with these others,

00:52:19.300 --> 00:52:21.990
but people might have questions if I didn't mention it.

00:52:21.989 --> 00:52:26.069
So Core Animation sort of acts like a
merger of the image and view layers.

00:52:26.070 --> 00:52:32.780
So in terms of performance, CA layer is pretty much
like a CG image, but it has sort of an additional,

00:52:32.780 --> 00:52:38.950
all these smarts about invalidation and compositing of
the images for you, they have intrinsic locations relative

00:52:38.949 --> 00:52:41.179
to each other, which is a little
bit like the view hierarchy.

00:52:41.179 --> 00:52:47.699
You can use it, I guess usually if you're using CA layers

00:52:47.699 --> 00:52:52.250
at the Cocoa layer probably all you're doing is
you're sending the method set once layer yes,

00:52:52.250 --> 00:52:55.840
or checking the box in Interface Builder
because that'll make it layer backed.

00:52:55.840 --> 00:53:03.970
But you can use it when it seems better to composite
already created images, rather than redrawing all the time.

00:53:03.969 --> 00:53:07.879
And that seems kind of funny because it seems like
having big images with all those pixels that you have

00:53:07.880 --> 00:53:10.240
to composite, how can that possibly be faster?

00:53:10.239 --> 00:53:15.649
How can that possibly be faster
than just redrawing small regions?

00:53:15.650 --> 00:53:23.480
Well the reason is because graphics cards are kind of crazy
and they're really fast, and that's what it's good for.

00:53:23.480 --> 00:53:25.780
So it turns out that if you cache these things to images

00:53:25.780 --> 00:53:29.860
than the graphics card can do a really good
job of compositing them right at draw time.

00:53:29.860 --> 00:53:34.510
But of course its used for animation because when you have
things moving around a lot, if you can avoid redrawing them

00:53:34.510 --> 00:53:36.330
and instead just composite the layers, that's great.

00:53:36.329 --> 00:53:41.069
So when might you want to use it explicitly instead
of using the NS view stuff like I was mentioning?

00:53:41.070 --> 00:53:44.830
Well, there are some features that
are not exposed to the NS view layer.

00:53:44.829 --> 00:53:49.949
There's some automatic layout stuff that has not yet
been brought up to Cocoa that you might be interested in.

00:53:49.949 --> 00:53:55.829
another thing is if you want to do explicit animation,
what we have in Cocoa is we have the idea of animation

00:53:55.829 --> 00:54:01.860
in response to an action, so if you say set
frame on a view, then it's going to animate

00:54:01.860 --> 00:54:03.900
from it's current location to the new location.

00:54:03.900 --> 00:54:09.809
Well what do you do if you just want to say I want this
to start pulsing or I want it to start spinning right now?

00:54:09.809 --> 00:54:10.509
When should it stop?

00:54:10.510 --> 00:54:12.250
When I tell you to stop.

00:54:12.250 --> 00:54:16.219
That's not something that's really exposed to the view layer
right now, so you can go down to the Core Animation level

00:54:16.219 --> 00:54:19.839
to work with that sort of thing I you want.

00:54:19.840 --> 00:54:21.280
So that's pretty much what I want to say.

00:54:21.280 --> 00:54:23.540
So what are the big points from this talk?

00:54:23.539 --> 00:54:28.599
It's mostly just a lot of little points, but if
there are some big points, coordinate spaces.

00:54:28.599 --> 00:54:29.289
Keep track of them.

00:54:29.289 --> 00:54:32.929
Your rectangles are not just complete by themselves.

00:54:32.929 --> 00:54:36.669
You have to know with what coordinate
space they're relative to.

00:54:36.670 --> 00:54:44.460
NS image, it does a lot for you, it has a lot of features,
it's not so bad as I think it has a reputation for.

00:54:44.460 --> 00:54:47.409
If you understand particularly the
flippedness and if you understand the caching,

00:54:47.409 --> 00:54:49.289
I don't think you'll have very much trouble with it.

00:54:49.289 --> 00:54:55.769
And NS image rep also, it's really pretty easy if you
want to extend NS image to cover more sorts of classes.

00:54:55.769 --> 00:55:02.050
And then the other APIs are also there if you, you might
want to go down either for performance if you have sort

00:55:02.050 --> 00:55:04.780
of specialized needs, or just for interest.
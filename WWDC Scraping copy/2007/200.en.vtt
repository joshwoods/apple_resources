WEBVTT

00:00:10.000 --> 00:00:16.509
>> Announcer: Ladies and gentlemen please welcome senior
vice president software engineering Bertrand Serlet.

00:00:16.510 --> 00:00:25.160
( Applause )

00:00:25.160 --> 00:00:27.280
>> Bertrand: Good afternoon.

00:00:27.280 --> 00:00:33.579
Last year at the developers conference
I concluded the state of the union

00:00:33.579 --> 00:00:39.920
by observing there's been a shift in how
applications have been designed.

00:00:39.920 --> 00:00:45.179
A long time ago application were
designed solely for functionality.

00:00:45.179 --> 00:00:50.329
If you were responding to the spec
that's it you had an application.

00:00:50.329 --> 00:00:52.600
And with the Macintosh, of course, that's changed.

00:00:52.600 --> 00:00:58.100
An application, to be successful, had to be easy to use.

00:00:58.100 --> 00:01:02.890
Over the last couple of years I
think we've gone to the next level.

00:01:02.890 --> 00:01:11.710
Your application needs to amaze its users in
order to be competitive and to be a great success.

00:01:11.709 --> 00:01:20.819
So from this derives our mission, which is
to help you create amazing applications.

00:01:20.819 --> 00:01:24.809
And there's different aspects that
are going to drive our agenda.

00:01:24.810 --> 00:01:33.480
The first one is that for creating an amazing application
you need to really leverage the silicon we are living

00:01:33.480 --> 00:01:37.210
under Moore's Law, which is a great time to live in.

00:01:37.209 --> 00:01:39.929
And the power is amazing.

00:01:39.930 --> 00:01:47.520
But we need to make sure that all the power of the
silicon flows through the API'ss to your application.

00:01:47.519 --> 00:01:49.859
So, that's the first point we'll cover.

00:01:49.859 --> 00:01:55.079
Of course you need to develop your application quickly.

00:01:55.079 --> 00:01:56.399
You want time to market.

00:01:56.400 --> 00:02:04.710
You want to have the right foundations so that you don't
have to reinvent the wheel and so we'll cover those foundations.

00:02:04.709 --> 00:02:12.269
And of course you need to have the right
experience, user experience for your applications.

00:02:12.270 --> 00:02:15.170
And that's our next point.

00:02:15.169 --> 00:02:21.229
Now to cover those three aspects I
have three esteemed colleagues of mine.

00:02:21.229 --> 00:02:29.099
First Simon Patience who heads Core OS
that's pretty much everything non-UI

00:02:29.099 --> 00:02:37.169
in the OS, the kernel things that
layer, the Unix layer and so forth.

00:02:37.169 --> 00:02:42.799
Next I have Peter Graffagnino who heads IMG.

00:02:42.800 --> 00:02:46.830
And IMG's responsible for the audio
and the video on the platform.

00:02:46.830 --> 00:02:55.580
So Peter and his team are saturating your
ears and your eyes, that's their mission.

00:02:55.580 --> 00:03:03.020
Last, Scott Forstall who heads platform
experience at the higher level of the OS.

00:03:03.020 --> 00:03:09.740
That's the system applications,
the HI, the UI frameworks.

00:03:09.740 --> 00:03:15.240
And Scott also heads this other little
project on the side that's called iPhone.

00:03:16.469 --> 00:03:18.180
So, let's start with power.

00:03:18.180 --> 00:03:24.670
Who would have thought that we would be shipping an 8-way config?

00:03:24.669 --> 00:03:25.849
And that's what we've done.

00:03:25.849 --> 00:03:30.599
Just a few months ago I'm sure a number
of you already have that interface,

00:03:30.599 --> 00:03:33.699
MacPro and new MacPro that's an 8-way.

00:03:33.699 --> 00:03:41.449
We've come a long way if you go back in
history to the first days of computing.

00:03:41.449 --> 00:03:47.479
That's the ENIAC in the late 40's, and it was for many a revolution,

00:03:47.479 --> 00:03:52.179
but another revolution came in
of course, with microprocessors.

00:03:52.180 --> 00:03:59.920
And one aspect of the microprocessors is that very quickly
they increased their bit width, 4-bit, 8-bit,

00:03:59.919 --> 00:04:02.530
16-bit, that was of course the era of the PC.

00:04:02.530 --> 00:04:10.120
And then they moved on into 32-bit and
it's only in the last couple of years

00:04:10.120 --> 00:04:15.780
that 64-bit computers have made it
to the mainstream, to the consumer.

00:04:16.879 --> 00:04:26.209
So, to talk about 64-bit and in general some of
the other aspects of power of our modern computers

00:04:26.209 --> 00:04:33.509
and all this power that's derived from Moore's Law and
the silicon, I'd like to ask Simon to come on stage.

00:04:33.509 --> 00:04:40.019
( Applause )

00:04:40.019 --> 00:04:41.569
>> Simon: Good afternoon.

00:04:41.569 --> 00:04:48.409
As Bertrand said I run Core OS which creates
the software that runs at the heart of Mac OS X

00:04:48.410 --> 00:04:53.810
and exploits the power of the CPU board silicon.

00:04:53.810 --> 00:04:57.030
And as he also mentioned we don't do UI.

00:04:57.029 --> 00:05:02.589
Some people say that the lack of a pretty face
extends to me but I don't take any notice of them.

00:05:04.100 --> 00:05:08.530
So, first of all we'll talk about 64-bit.

00:05:08.529 --> 00:05:16.209
Now, the last WWDC we only had the Pro
platforms that had 64-bit capable processes.

00:05:16.209 --> 00:05:17.199
But we've been busy.

00:05:17.199 --> 00:05:22.370
And now if you look at all for quadrants of our
major product lines, the Macbook, the Macbook Pro,

00:05:22.370 --> 00:05:28.050
the iMac and the MacPro, they all have something
in common, which is that they are 64-bit capable.

00:05:28.050 --> 00:05:30.920
They can run 64-bit applications.

00:05:31.970 --> 00:05:35.120
So, why 64-bit?

00:05:35.120 --> 00:05:45.110
Well, with no legacy instruction set the, or legacy,
the instruction set is optimized for fast performance.

00:05:45.110 --> 00:05:50.540
And in addition on Intel there are more registers to use
and so therefore you go back to memory less frequently

00:05:50.540 --> 00:05:54.210
which increases your performance of your application also.

00:05:54.209 --> 00:05:59.939
But perhaps more importantly it's the address
space, the virtual address space of your application.

00:05:59.939 --> 00:06:04.219
With a 64-bit address space there
is much simpler programming model.

00:06:04.220 --> 00:06:10.200
You map all of your data into application and there's no
data window to slide up and down as you saw this morning

00:06:10.199 --> 00:06:14.819
in Steve's keynote, which also can lead, as
well as simplicity, to faster applications.

00:06:14.819 --> 00:06:21.240
The other reason for 64-bit is physical address space.

00:06:21.240 --> 00:06:27.860
With a 64-bit physical address space you can
put in lots of physical memory, lots of RAM.

00:06:27.860 --> 00:06:32.430
And of course, if you have a virtual address
space in the physical address space that's large,

00:06:32.430 --> 00:06:37.780
now your application can be backed by real
memory which increases the performance again.

00:06:39.069 --> 00:06:42.620
So, we have had 64-bit machineds for a while.

00:06:42.620 --> 00:06:46.329
And in Tiger we support the 64-bit
but only at the Unix layer.

00:06:46.329 --> 00:06:52.829
We had the MacPro and the G5 and we
supported 64-bit Unix appldications.

00:06:52.829 --> 00:06:59.250
But now, with Leopard we have 64-bit
all the wday up the stack.

00:06:59.250 --> 00:07:06.790
Now, I also mentioned that there was some exceptions
last time no 64-bit CFM, low level QuickTime API's,

00:07:06.790 --> 00:07:10.670
Sound Manager, QuickDraw, and
we've had to add to that list.

00:07:10.670 --> 00:07:13.400
And so now there's no 64-bit Carbon UI.

00:07:13.399 --> 00:07:17.509
So Cocoa UI is the way to go for the 64-bit world.

00:07:17.509 --> 00:07:22.839
( Applause )

00:07:22.839 --> 00:07:27.539
Now we could have a 64-bit, 32-bit, product.

00:07:27.540 --> 00:07:29.360
But we don't want to do that.

00:07:29.360 --> 00:07:36.379
It's confusing for customers and also it makes it confusing
for the applications which version you want to run on.

00:07:36.379 --> 00:07:40.800
So we have one SKU, a 64-bit version of Leopard.

00:07:40.800 --> 00:07:45.170
It will run on any machine, 64-bit or 32-bit processor.

00:07:45.170 --> 00:07:54.810
And if it's on a 64-bit procesdsor then it will run
either 32-bit or 64-bit applications in one product.

00:07:54.810 --> 00:07:57.720
Now, we want you to do that too.

00:07:57.720 --> 00:08:02.700
For your application, your great app,
we don't want you to have two SKUs.

00:08:02.699 --> 00:08:05.379
We don't want you to confuse your customers.

00:08:05.379 --> 00:08:09.899
And so, consequently we want you also to have a single SKU

00:08:09.899 --> 00:08:15.250
that can run either 64-bit or 32-bit
depending2 on the platform.

00:08:15.250 --> 00:08:18.310
Now, you can do that because we have 64-bit tools.

00:08:18.310 --> 00:08:26.370
Our tools can build a single applications executable which
contains both the 32-bit binary and the 64-bit binary

00:08:26.370 --> 00:08:30.569
in a single package which you can ship to the customers.

00:08:30.569 --> 00:08:36.809
And you can start doing that in
October this year when Leopard ships.

00:08:36.809 --> 00:08:40.039
So that's 64-bit.

00:08:40.039 --> 00:08:50.360
The next thing I want to talk about on the CPU board
is not the processor itself but the Vector engines.

00:08:50.360 --> 00:08:56.850
The Vector engines are a very powerful part
of our processor and help accelerate your app.

00:08:56.850 --> 00:08:58.170
Literally accelerate.

00:08:58.169 --> 00:09:02.789
And the Accelerate Framework is the way that
you can take advantage of these Vector engines.

00:09:02.789 --> 00:09:08.189
Now you're probably thinking well,
you know, what's in there?

00:09:08.190 --> 00:09:11.590
There's four basic components of the Accelerate Framework.

00:09:11.590 --> 00:09:21.399
There's the Vector math library, there's linear algebra,
signal processing and the image processing libraries.

00:09:21.399 --> 00:09:24.620
Now you're probably thinking well, you know, I'm not a PhD.

00:09:24.620 --> 00:09:26.820
I'm not quite sure what to use all these things for.

00:09:26.820 --> 00:09:34.390
So, I thought I'd give you an example of where we use
these libraries and the functionality in our own apps.

00:09:34.389 --> 00:09:40.129
So, for vector math, we use this
extensively in SoundTrack Pro.

00:09:40.129 --> 00:09:50.309
The linear algebra routines are used in junk mail filtering
and in mail and also to process the Japanese Input Method.

00:09:51.419 --> 00:09:55.629
Signal processing, iTunes of course.

00:09:55.629 --> 00:09:59.100
But iTunes calls FFT one million times per hour.

00:09:59.100 --> 00:10:04.450
So, these functions have to be very, very fast, and also,

00:10:04.450 --> 00:10:08.090
in the accelerated speech feature
of our accessibility functions.

00:10:08.090 --> 00:10:14.600
In image processing we use it for scaling in QuickTime.

00:10:14.600 --> 00:10:16.360
as you pull the windows out.

00:10:16.360 --> 00:10:23.310
We use it for raw image conversions from your
camera and also Final Cut Pro in de-interlacing.

00:10:23.309 --> 00:10:26.889
So, we use these functions extensively
in our own applications.

00:10:26.889 --> 00:10:31.600
And we believe if you're doing things like we're
doing then you'll be able to get great advantage

00:10:31.600 --> 00:10:37.659
out of the Accelerate Framework in your own
applications and speed them up significantly.

00:10:37.659 --> 00:10:40.329
So you need to accelerate your application.

00:10:40.330 --> 00:10:48.150
We have a complex functionality, this math functionality
encapsulated behind these API's in accelerate.

00:10:48.149 --> 00:10:52.819
You can think of this as basically being your PHD in a box.

00:10:52.820 --> 00:10:55.410
We have industry leading performance.

00:10:55.409 --> 00:10:59.199
When we compare ourselves to other
implementations we either meet

00:10:59.200 --> 00:11:04.550
or beat an awful lot of these same API's from other places.

00:11:04.549 --> 00:11:07.229
We have a platform independent implementation.

00:11:07.230 --> 00:11:11.570
It doesn't matter if you're on
a PowerPC or you're on Intel.

00:11:11.570 --> 00:11:13.720
We'll pick the appropriate Vector engines.

00:11:13.720 --> 00:11:18.160
It doesn't matter if we've got SSE 2
or SSE 3 or wide instructions.

00:11:18.159 --> 00:11:22.990
Whatever it is that the platform has we'll use it.

00:11:22.990 --> 00:11:31.090
And in addition, we will actually also multi thread
the API's for you to get additional performance.

00:11:31.090 --> 00:11:33.530
And we're future proofing your application.

00:11:33.529 --> 00:11:39.699
The next round of the Intel processors with new and
improved Vector engines, we will make sure that our API's

00:11:39.700 --> 00:11:46.330
and Accelerate Framework extract the last
ounce of performance out of those new features

00:11:46.330 --> 00:11:48.850
and also out of the new CPU's as they come along.

00:11:48.850 --> 00:11:53.990
So, that's the Vector engines.

00:11:53.990 --> 00:12:02.240
So, finally I'd like to talk about
multi cores and more multi cores.

00:12:02.240 --> 00:12:13.700
And the fact that we have now large scale SMP
on a consumer and PC platform, 8-way machines.

00:12:13.700 --> 00:12:17.050
So we'll do another trip back in time.

00:12:18.389 --> 00:12:23.819
We started off with a slow single processor.

00:12:23.820 --> 00:12:27.580
It took about ten years before we
got the first dual processor machine

00:12:27.580 --> 00:12:31.600
and another ten years before the first dual core arrived.

00:12:31.600 --> 00:12:36.840
And then quickly follow up by four
way configuration in the MacPro.

00:12:36.840 --> 00:12:43.180
And then a year later the first dual core on a consumer
platform and then a year later the first quad core

00:12:43.179 --> 00:12:46.929
and the same year we now have an 8-way configuration.

00:12:46.929 --> 00:12:53.239
So, you can see the trend is, toward
multiprocessors is going exponential.

00:12:53.240 --> 00:13:00.919
We are rapidly increasing the number of processors
within a consumer product and a PC product.

00:13:00.919 --> 00:13:03.069
So that's where the hardware's going.

00:13:03.070 --> 00:13:04.270
What about the software?

00:13:04.269 --> 00:13:09.889
Well, for MP hardware you need MP software.

00:13:09.889 --> 00:13:16.740
What we've done about it we have a scalable
OS Core, we have multi-threaded graphics,

00:13:16.740 --> 00:13:20.060
and we've made our applications MP ready.

00:13:21.419 --> 00:13:22.089
So what do I mean?

00:13:22.090 --> 00:13:23.330
Let's look at each of these.

00:13:23.330 --> 00:13:29.350
Scalable OS Core, we have the heart of
Mac OS X we have the Unix operating system

00:13:29.350 --> 00:13:32.769
which is a traditionally very scalable system.

00:13:32.769 --> 00:13:36.870
We've taken things further, in the file system
we've added attribute caching to be able

00:13:36.870 --> 00:13:39.799
to reduce the contention in the file system.

00:13:39.799 --> 00:13:43.829
In networking we have multiple input threads
to be able to support multiple interfaces

00:13:43.830 --> 00:13:50.220
on different CPU's the BSD has gotten better
pthreads faster thread creation and termination.

00:13:50.220 --> 00:13:56.440
We have faster synchronizations primitives.

00:13:56.440 --> 00:13:59.210
The VM is another source of contention in the kernel.

00:13:59.210 --> 00:14:04.519
We have finer grain locking to be able to get through
those VM operations much faster without having

00:14:04.519 --> 00:14:08.079
to coordinate between CPU's and applications.

00:14:08.080 --> 00:14:14.830
Even in power management we have asynchronous interfaces
now so on power events we can actually do multiple things

00:14:14.830 --> 00:14:18.520
on different CPU's because the events are asynchronous.

00:14:18.519 --> 00:14:25.569
And finally in the kernel core we have per CPU run
queues for the scheduler which means we can get hold

00:14:25.570 --> 00:14:29.990
of your application and run it even faster
without having to coordinate across CPU's.

00:14:29.990 --> 00:14:35.470
Now what does that actually mean
when you put it all together?

00:14:35.470 --> 00:14:41.519
Well, if you look at Tiger, so, this is actually a graph
of how much of a CPU do you get when you add an extra CPU?

00:14:41.519 --> 00:14:45.240
And this is a make of a large source space.

00:14:45.240 --> 00:14:52.560
So, if you look at Tiger as we add CPU's we get a smaller
percent of the CPU each time until by the time you add

00:14:52.559 --> 00:14:58.289
in that 8th CPU you're only getting
about 40 percent of the CPU.

00:14:58.289 --> 00:15:03.039
Tiger was never designed to run on machines
that big so that's not really surprising.

00:15:03.039 --> 00:15:07.059
But with all the scaling work we've done with
Leopard we have about a 30 percent increase

00:15:07.059 --> 00:15:10.149
in CPU utilization by the time we get out into the 8th CPU.

00:15:10.149 --> 00:15:13.769
And so, we're now up into the 71, 72 percent oqf the CPU.

00:15:13.769 --> 00:15:17.269
It's actually there for your application to use.

00:15:17.269 --> 00:15:18.720
And this is clearly not the end.

00:15:18.720 --> 00:15:24.269
We'll be continuing to work on that and
improve the amount of CPU utilization

00:15:24.269 --> 00:15:27.750
that your application can have
as you scale up these machines.

00:15:27.750 --> 00:15:30.789
So, we've done our work in that area.

00:15:32.330 --> 00:15:37.750
Multi threaded graphics, OpenGL, Core Animation, Core Image.

00:15:37.750 --> 00:15:42.529
So we'll start with a Tiger OpenGL workload.

00:15:42.529 --> 00:15:47.929
Now, GL is actually executed in the same
context of the same thread of your application.

00:15:47.929 --> 00:15:51.299
So you can see that you don't actually
get it in concurrency until you get

00:15:51.299 --> 00:15:54.649
to the point where you can put the work on the GPU.

00:15:54.649 --> 00:15:59.319
Now, even if you added a second CPU into
this picture it doesn't help, because I said,

00:15:59.320 --> 00:16:02.950
the GL framework is running in the same thread context.

00:16:04.240 --> 00:16:09.860
However, in Leopard we have multi threaded OpenGL.

00:16:09.860 --> 00:16:16.210
And as a consequence when you call into GL it's gone
to thread and now you can do the work in parallel

00:16:16.210 --> 00:16:19.950
with your application which in itself
can be done in parallel with the GPU.

00:16:19.950 --> 00:16:25.310
So, you can get a lot more operations
done in the same given time frame.

00:16:25.309 --> 00:16:29.089
But we haven't just done work in OpenGL.

00:16:30.519 --> 00:16:33.750
We've also multi threaded Core Animation.

00:16:33.750 --> 00:16:42.259
And for this we needed an extra CPU because now when your
application calls a Core Animation function which then goes

00:16:42.259 --> 00:16:49.700
down to OpenGL they're going to all run in parallel because
they all have their own threads to be able to execute in.

00:16:49.700 --> 00:16:57.220
So, you can see that in a given period of time there's
even more work that you can do if you take advantage

00:16:57.220 --> 00:17:05.309
of these multi cores which means that your application could
give a richer experience, visual experience to the end user.

00:17:06.380 --> 00:17:10.050
So that's OpenGL and Core Animation.

00:17:10.049 --> 00:17:14.809
With Core Image we've also put
a lot of parallelism into that.

00:17:14.809 --> 00:17:25.509
and so, consequently in this conic filter with
each CPU we can render almost a linear improvement

00:17:25.509 --> 00:17:26.869
in its scalability.

00:17:26.869 --> 00:17:31.799
So, every time you add a CPU it just gets faster and faster.

00:17:31.799 --> 00:17:36.899
So, you could see throughout our graphics we're MP ready.

00:17:36.900 --> 00:17:42.940
We have the frameworks running in separate threads for
OpenGL, Core Animation renders in a separate thread,

00:17:42.940 --> 00:17:47.789
and Core Image we get a linear scale up for the API's.

00:17:47.789 --> 00:17:51.930
So what about our applications?

00:17:52.950 --> 00:17:55.480
They need to be MP ready.

00:17:55.480 --> 00:17:59.410
But before we talk about that let's
take a look at something else.

00:18:02.490 --> 00:18:10.329
Now, we've all seen these, very rarely of course,
but what actually causes the spinning cursor?

00:18:11.720 --> 00:18:14.930
Well, it's because your event thread is non responsive.

00:18:14.930 --> 00:18:17.600
And it could be non responsive for a couple of reasons.

00:18:17.599 --> 00:18:24.099
The first one is it's picked up something from the run loop
and it's going off and it's processing a long operation.

00:18:24.099 --> 00:18:28.679
Some computation, something that's
really not being done asynchronously.

00:18:28.680 --> 00:18:32.950
And so while it's doing that it
can't respond to the next event.

00:18:32.950 --> 00:18:36.710
Similarly it can go off and be
waiting for synchronous event.

00:18:36.710 --> 00:18:38.750
So, it's actually not even doing anything constructive.

00:18:38.750 --> 00:18:42.559
It's sitting waiting for some network
activity or something like that.

00:18:42.559 --> 00:18:48.069
But it's still not responding to the network events in
the run loop or to the events in the run loop.

00:18:49.089 --> 00:18:50.609
So that's what causes a spinning cursor.

00:18:50.609 --> 00:18:56.709
But it has another effect, it prevents
concurrency if you're sitting doing other stuff

00:18:56.710 --> 00:18:58.880
and more events are arriving you can't be processing them.

00:18:58.880 --> 00:19:05.110
So, there's no opportunity to have concurrency in your
application which actually therefore prevents scaling.

00:19:05.109 --> 00:19:08.399
And when you're on an 8-way that's what you want to do.

00:19:09.750 --> 00:19:12.700
So, you need to make your app MP ready.

00:19:12.700 --> 00:19:15.279
You do that by being event driven off the run loop.

00:19:15.279 --> 00:19:17.369
We all know how to do that.

00:19:17.369 --> 00:19:22.699
But we need to be able to have external
events to react to, so notifications.

00:19:22.700 --> 00:19:25.799
But I think we also need a new MP model.

00:19:26.880 --> 00:19:28.670
So, let's talk about notifications first.

00:19:28.670 --> 00:19:33.820
We know about the Cocoa notifications and
in Tiger we introduced BSD notifications.

00:19:33.819 --> 00:19:37.439
It's a very simple, just a name
to rendezvous and no payload.

00:19:37.440 --> 00:19:41.740
They're extremely fast point to point notifications.

00:19:41.740 --> 00:19:48.539
But it also has an option to do multi cast
notifications by shared memory which are incredibly cheap

00:19:48.539 --> 00:19:55.990
to invalidate the cache of all other processes by just
calling a simple API which does a memory reference

00:19:55.990 --> 00:20:04.539
and then everybody has been notified of the change
of state, very fast, very cheap, very powerful.

00:20:04.539 --> 00:20:09.599
Now, there's another form of notifications
that we've been asked for many times.

00:20:09.599 --> 00:20:14.839
And we've always had difficulty in
working out how to do these efficiently.

00:20:14.839 --> 00:20:17.439
But in Leopard we think we've solved the problem.

00:20:17.440 --> 00:20:21.509
And so we have file system change notifications in Leopard.

00:20:21.509 --> 00:20:27.240
( Applause )

00:20:27.240 --> 00:20:32.950
So, as file system change notifications we
can watch entire hierarchies with one call.

00:20:32.950 --> 00:20:35.130
You only rescan what has changed.

00:20:35.130 --> 00:20:40.540
So you only get to go off and do
the work when the file has changed.

00:20:40.539 --> 00:20:44.649
And the other interesting feature about file system
change notifications is if your process exits

00:20:44.650 --> 00:20:48.280
and restarts it will get all the changes since it last run.

00:20:48.279 --> 00:20:50.819
So you don't have to leave your application lying around.

00:20:50.819 --> 00:20:53.789
( Applause )

00:20:53.789 --> 00:20:58.750
We find this incredibly important and
useful for Finder, for Time Machine.

00:20:58.750 --> 00:21:05.819
These are very powerful API's which we think
you'll be able to leverage to great effect also.

00:21:05.819 --> 00:21:08.839
So, file system change notifications.

00:21:08.839 --> 00:21:13.619
I mentioned an MP model.

00:21:15.109 --> 00:21:17.799
Now, what is today's MP model?

00:21:17.799 --> 00:21:19.879
MP model for today is threads.

00:21:19.880 --> 00:21:24.860
And that's pthreads NSThreads and all
the inherent complexities of threads.

00:21:24.859 --> 00:21:26.819
Which is, how many do you need?

00:21:26.819 --> 00:21:28.599
What do I do if one of them blocks?

00:21:28.599 --> 00:21:36.199
You know, all the synchronization problems associated at
the priority management, very complicated to get right.

00:21:36.200 --> 00:21:41.840
We think we have a better answer for
you and that answer is NSOperation.

00:21:41.839 --> 00:21:45.039
NSOperation is a simple pair of interfaces.

00:21:46.059 --> 00:21:52.740
You basically take the design of your application
and you break it down into work elements.

00:21:52.740 --> 00:21:57.799
You can define the priority to these work elements
and you can create dependencies between them.

00:21:57.799 --> 00:22:01.039
So you make sure that one doesn't run before another.

00:22:01.039 --> 00:22:05.659
And when you've got them all together
you just put them on an operation queue.

00:22:05.660 --> 00:22:09.430
But this is a really quick operation
to be able to queue up a work element.

00:22:09.430 --> 00:22:15.310
So, you don't get that spinning cursor because
you can then go back and wait for the next event.

00:22:15.309 --> 00:22:19.349
Now, NSOperationQ is the thing
that does all the hard work for you.

00:22:19.349 --> 00:22:26.849
And it will schedule all your work on as
many CPU's as you have in the system whatever

00:22:26.849 --> 00:22:31.579
that is or as many as the OS will give you.

00:22:31.579 --> 00:22:36.419
So, NSOperation, we think, is the
new MP model for your application.

00:22:36.420 --> 00:22:43.420
It allows you to simply divide up your work,
queue it up, and then maximize the scalability

00:22:43.420 --> 00:22:45.810
of the machine that you happen to be running on.

00:22:45.809 --> 00:22:50.440
You don't have to worry about whether it's a two
processor four processor, eight processor machine.

00:22:50.440 --> 00:22:55.110
the system will be able to get the maximum concurrency
out of the amount of work that you've given it

00:22:55.109 --> 00:23:04.039
and will handle it all for you, so,
NSOperation, a new model for MP.

00:23:04.039 --> 00:23:12.339
And we've used notifications NSOperation in
our apps both the BSD and the fast system change,

00:23:12.339 --> 00:23:17.039
notifications in our own apps, in
Finder, in Mail, in iCal and others.

00:23:17.039 --> 00:23:22.109
And we find that we both get a better
scaling and a better responsiveness

00:23:22.109 --> 00:23:24.099
from our own applications, which you'll see in Leopard.

00:23:24.099 --> 00:23:27.649
And we believe that you will get them yourself.

00:23:27.650 --> 00:23:36.350
So, scale your application because multi cores are here
and they're going to get there's going to be more of them.

00:23:36.349 --> 00:23:37.829
You need to get your app MP ready.

00:23:37.829 --> 00:23:40.899
And you do this by freeing up your event thread.

00:23:40.900 --> 00:23:45.220
You use notifications and adopt NSOperation.

00:23:45.220 --> 00:23:48.870
And of course, test on an 8-way.

00:23:48.869 --> 00:23:51.269
So ask your boss to buy you an 8-way MacPro.

00:23:51.269 --> 00:24:02.639
( Applause )
So that's MP and the power of the CPU board silicon.

00:24:02.640 --> 00:24:08.360
And next I'd like to invite Peter up here to talk about some
other silicon that's very powerful, the graphics processes.

00:24:08.359 --> 00:24:09.509
>> Peter: Thanks Simon.

00:24:09.509 --> 00:24:15.039
( Applause )

00:24:15.039 --> 00:24:15.930
Good afternoon.

00:24:15.930 --> 00:24:21.560
I'm going to take you on another little trip through time
and look at graphics, in particular game graphics.

00:24:21.559 --> 00:24:27.319
Some great old memories I'm sure fly by for
some of you in the audience as you see these.

00:24:27.319 --> 00:24:31.220
And as time went on we started to get more

00:24:31.220 --> 00:24:36.470
and more 3D immersive environments
starting to employ the GPU to play games.

00:24:36.470 --> 00:24:43.259
And you saw the great demo from John Carmack
this morning of the incredible new technology.

00:24:43.259 --> 00:24:48.129
Now what's going on though with these GPU's versus CPU's?

00:24:48.130 --> 00:24:51.580
I thought I'd do a little graph here.

00:24:51.579 --> 00:24:55.949
So, the CPU is, you know, it's the main processor.

00:24:55.950 --> 00:24:58.059
It has a lot of, it's going more and more parallel.

00:24:58.059 --> 00:25:03.779
But the GPU is really becoming more programmable
and is capable of real computation as well.

00:25:03.779 --> 00:25:05.910
Let's do a little comparison.

00:25:05.910 --> 00:25:11.740
So, compare the number of cores in
a state of the art CPU versus GPU.

00:25:11.740 --> 00:25:16.599
We've got 4 in a CPU and 64 in the latest graphics chips.

00:25:16.599 --> 00:25:19.230
That's 16 times.

00:25:19.230 --> 00:25:21.289
Let's look at giga flops.

00:25:21.289 --> 00:25:29.759
This is a core two duo Pentium 4-way 50
giga flops, 350 giga flops in the latest GPU's

00:25:29.759 --> 00:25:32.619
about the same from NVIDIA and from ATI.

00:25:32.619 --> 00:25:35.929
That's a 7X advantage over the CPU.

00:25:35.930 --> 00:25:45.200
Look at memory band width, six giga bytes per second in a
MacPro, 100 giga bytes per second in a GPU memory system.

00:25:45.200 --> 00:25:48.150
So that's 16 times the efficiency.

00:25:48.150 --> 00:25:55.870
And I don't think it's a wild prediction to say that the
next generation GPU's are going to deliver a Teraflop

00:25:55.869 --> 00:25:58.769
of floating point performance, which is really incredible.

00:25:58.769 --> 00:26:05.079
So if you think of all the competition it's creating
in computer architecture it's really an exciting time

00:26:05.079 --> 00:26:08.460
if you need a lot of computational horsepower.

00:26:08.460 --> 00:26:10.410
And people are starting to notice.

00:26:10.410 --> 00:26:13.310
And it's really not just about games now.

00:26:13.309 --> 00:26:18.759
People are looking at doing scientific
computations on GPU's.

00:26:18.759 --> 00:26:22.960
For example, there's a problem in medical
imaging, which is called image fusion

00:26:22.960 --> 00:26:27.000
where you have 3D data sets fr=om a CAT scan or MRI.

00:26:27.000 --> 00:26:29.480
They may be taken at different times with the same patient

00:26:29.480 --> 00:26:33.720
or may different data sets that
you want to align and analyze.

00:26:33.720 --> 00:26:39.670
And the issue is that things might not quite line up
exactly and you really want to be able to compare things.

00:26:39.670 --> 00:26:47.180
So, you have a big search problem in 3D space with
these huge arrays lots of data really difficult problem.

00:26:47.180 --> 00:26:53.810
Now, there's a pretty popular library out there
that does this on a CPU that people use it takes

00:26:53.809 --> 00:26:58.329
about 30 minutes on today's CPU it's a big computation.

00:26:58.329 --> 00:27:05.029
Some researchers running on Macs at the University of
Calgary in Calgary Scientific implemented their version

00:27:05.029 --> 00:27:10.420
of this algorithm on an NVIDIA GPU and they
were able to do it in eight and a half seconds.

00:27:10.420 --> 00:27:15.980
It's an incredible speed up almost 200 times.

00:27:15.980 --> 00:27:19.440
So, something is really going on here.

00:27:19.440 --> 00:27:25.539
they're using both the CPU and the GPU both running
flat out doing a lot of computation on the GPU,

00:27:25.539 --> 00:27:29.649
all of the high band width computations
there and then a lot of computation

00:27:29.650 --> 00:27:32.460
as well on the CPU running the thread optimizer.

00:27:32.460 --> 00:27:37.370
So, it took a lot of work for them
to kind of re factor their algorithm

00:27:37.369 --> 00:27:41.750
into this computational engine of both CPU and GPU.

00:27:41.750 --> 00:27:43.660
But it really paid off.

00:27:43.660 --> 00:27:50.160
And so I want to try to think a little bit about are
there fundamental differences in CPU's and GPU's?

00:27:50.160 --> 00:27:52.730
Or are GPU's just going to take over the world?

00:27:52.730 --> 00:27:54.269
And I don't think that's true.

00:27:54.269 --> 00:27:56.690
I think these things will remain distinct.

00:27:56.690 --> 00:28:00.870
They may some day be on the same chip together
but they're really two different design points

00:28:00.869 --> 00:28:05.099
in computer architecture and I'd like to cover those.

00:28:05.099 --> 00:28:08.099
The first is sort of random access versus streaming access.

00:28:08.099 --> 00:28:15.219
If you're building streets and you want to get to every house
in the neighborhood, then you've gotta build small streets

00:28:15.220 --> 00:28:18.630
and you've gotta have lots of corners and
usually a grid is relatively efficient.

00:28:18.630 --> 00:28:22.630
If you're building a highway you're only going to
have a few exits, you're going to have lots of lanes.

00:28:22.630 --> 00:28:24.660
So, it's a totally different design point.

00:28:24.660 --> 00:28:30.140
And that's the same when you're designing
architecture for CPU's and GPU's.

00:28:30.140 --> 00:28:32.530
Think about latency versus throughput.

00:28:32.529 --> 00:28:34.619
You can design something that can turn really fast.

00:28:34.619 --> 00:28:36.219
The CPU can take interrupts.

00:28:36.220 --> 00:28:39.269
It can branch its execution really quickly.

00:28:39.269 --> 00:28:41.740
A GPU is more like a bullet train.

00:28:41.740 --> 00:28:43.759
It goes real fast but, you know, if you want it

00:28:43.759 --> 00:28:47.599
to go somewhere else you gotta lay some
more track or turn at the next junction.

00:28:47.599 --> 00:28:53.929
So it's, again, a design trade
off for throughput versus latency.

00:28:53.930 --> 00:28:59.650
Another important difference is how
parallelism is expressed in the API's.

00:28:59.650 --> 00:29:03.470
For a CPU you pretty much have to
tell it every load and store to do.

00:29:03.470 --> 00:29:07.019
so, if you're going to compute an image
you have to say read this pixel write

00:29:07.019 --> 00:29:09.170
that pixel read this pixel write that pixel.

00:29:09.170 --> 00:29:12.269
So if there's any parallelism in
there, you've kind of lost it all

00:29:12.269 --> 00:29:16.440
because you're telling it explicitly
what to do in a serial fashion.

00:29:16.440 --> 00:29:18.910
And any parallelism isn't really implicit.

00:29:18.910 --> 00:29:22.870
Versus, on a GPU, you would just
say compute the whole image.

00:29:22.869 --> 00:29:27.219
And the GPU, because you've expressed
the problem to the GPU in a way

00:29:27.220 --> 00:29:32.779
that has no dependencies it can compute
the image in whatever order it wants.

00:29:32.779 --> 00:29:38.450
And so, this kind of parallel, explicit versus
implicit parallelism is real important to think about.

00:29:38.450 --> 00:29:40.120
Another is the compilation model.

00:29:40.119 --> 00:29:43.729
And this is more of a software historical artifact.

00:29:43.730 --> 00:29:47.599
But CPU's have traditionally been binary compatible.

00:29:47.599 --> 00:29:56.149
So, you can run, you know, an old x86 binary from
1990 assuming the OS is the same and it'll just work.

00:29:56.150 --> 00:29:58.130
So, instruction sets always been the same.

00:29:58.130 --> 00:30:01.350
And nothing can be further from the truth in GPU's.

00:30:01.349 --> 00:30:05.129
The micro architecture in every GPU
generation is radically different.

00:30:05.130 --> 00:30:09.690
And so, what, the graphics driver actually
has a compiler in it that re expresses the

00:30:09.690 --> 00:30:14.160
algorithm and optimizes it for the particular GPU.

00:30:14.160 --> 00:30:20.420
So, one of the issues is with all this stuff
going on parallel processing can't be hidden

00:30:20.420 --> 00:30:23.300
from the programmer, at least the low level programmer.

00:30:23.299 --> 00:30:29.230
Those of us that write a lot of really computationally
intensive algorithms like code X or image processing

00:30:29.230 --> 00:30:33.990
or just numeric computing are going to have to
deal with some complexity in the coming years.

00:30:33.990 --> 00:30:37.910
And I think that's real important and exciting.

00:30:37.910 --> 00:30:41.180
Now, Apple certainly is here to help you.

00:30:41.180 --> 00:30:48.380
We have the API's that Simon talked about NSOperationQ,
plus traditional Unix message passing.

00:30:48.380 --> 00:30:53.840
And we have GPU ready Frameworks talked
about Core Image and Core Animation,

00:30:53.839 --> 00:30:58.859
OpenGL is kind of the low level API to get right at the GPU.

00:30:58.859 --> 00:31:03.269
But there's also a lot of research
going on in parallel computing.

00:31:03.269 --> 00:31:08.910
GPGPU is a general classification of
general purpose computing on a GPU.

00:31:08.910 --> 00:31:14.670
A lot of interest in that, people are looking at
stream computing languages, functional languages,

00:31:14.670 --> 00:31:20.250
and different transactional memory models that are more like
data bases that don't have locks on pthreads everywhere.

00:31:20.250 --> 00:31:26.240
So at the low level I think there's going to
be a lot of, a lot of interesting innovation

00:31:26.240 --> 00:31:30.190
in software approaches to parallel processing as well.

00:31:30.190 --> 00:31:32.440
So, I'll end with a few predictions.

00:31:32.440 --> 00:31:36.320
This one's probably not very controversial:
CPU's will get more cores.

00:31:36.319 --> 00:31:38.329
GPU's will get more programmable.

00:31:38.329 --> 00:31:42.929
They'll be able to take more branches
and do more computation.

00:31:42.930 --> 00:31:49.630
But the fundamental architectural differences
are always going to remain between the GPU and the CPU.

00:31:49.630 --> 00:31:52.830
And we're going to be challenged, those of
us that work close to the metal to come

00:31:52.829 --> 00:31:55.509
up with some new approaches to program these things.

00:31:55.509 --> 00:32:02.129
But as always, our mission at Apple is to try to keep
it as easy as possible for the application writer.

00:32:02.130 --> 00:32:08.720
And so there'll be lots of work to do to kind
of take advantage of all this processing power.

00:32:08.720 --> 00:32:13.779
So, that's all I wanted to talk about today, was
just give you a taste of the innovation going

00:32:13.779 --> 00:32:18.039
on in the architecture field and look
forward to all the great apps you can build

00:32:18.039 --> 00:32:20.299
with all the computational power that's coming.

00:32:20.299 --> 00:32:21.299
So great, thank you.

00:32:21.299 --> 00:32:22.509
Back to Bertrand.

00:32:22.509 --> 00:32:28.369
( Applause )

00:32:28.369 --> 00:32:29.509
>> Bertrand: Thanks Peter.

00:32:29.509 --> 00:32:38.640
So, definitely a lot of interesting silicon in the GPU
as well as in the CPU, but you know, it's never enough.

00:32:38.640 --> 00:32:45.690
People want to have like lots and lots of
silicon, entire rooms filled with silicon here.

00:32:45.690 --> 00:32:49.630
Of course I'm talking about server installation.

00:32:49.630 --> 00:32:55.210
So the server product, Mac OS X Server
has quite a bit of history.

00:32:55.210 --> 00:33:02.130
In fact if you go back to the way it
started it was in the AppleShareIP days.

00:33:02.130 --> 00:33:05.720
If some of you remember, I mean
some of you weren't born then.

00:33:05.720 --> 00:33:09.019
But that's when it all started.

00:33:09.019 --> 00:33:15.829
And the AppleShareIP product was
very simple and in fact that was kind

00:33:15.829 --> 00:33:18.689
of its main differentiator it was easy to use.

00:33:18.690 --> 00:33:20.750
Okay, that was the Apple value.

00:33:20.750 --> 00:33:27.369
And in terms of the services that were
offered, well it had file and print, okay.

00:33:27.369 --> 00:33:29.859
That was pretty much it.

00:33:29.859 --> 00:33:36.609
And that was actually great for a couple of markets,
the creative markets and the education market.

00:33:36.609 --> 00:33:38.199
But that was it.

00:33:38.200 --> 00:33:42.519
What was kind of missing was the element of power.

00:33:42.519 --> 00:33:49.549
And of course with Mac OS X, we had
Mac OS X client, we had a Server version.

00:33:49.549 --> 00:33:54.970
And that had a lot more power because
suddenly you had all the power of Unix.

00:33:54.970 --> 00:34:02.190
And that was one of the premises behind Mac OS X, is to
ally the simplicity of the Mac with the power of Unix.

00:34:02.190 --> 00:34:06.240
And the server definitely benefited tremendously from that.

00:34:06.240 --> 00:34:13.030
And we were about to add new services, things like
Apache okay started out web server on the Internet.

00:34:13.030 --> 00:34:19.590
And so, that in turn opened up kind of new
markets things like Higher Ed or the Enterprise.

00:34:19.590 --> 00:34:23.120
And we iterated over the years with that product.

00:34:23.119 --> 00:34:29.210
Each version of the client OS had a
version, a similar version with the server.

00:34:29.210 --> 00:34:34.090
And the latest that we shipped is, of course, Tiger server.

00:34:34.090 --> 00:34:39.510
Now Tiger server has a pretty extensive
collection of services

00:34:39.510 --> 00:34:44.060
because what's happened is that
we added a whole set of services.

00:34:44.059 --> 00:34:50.090
The services that we have typically come from
Open Source, what the server product has become,

00:34:50.090 --> 00:34:54.900
in the Tiger days is, a container for Open Source services.

00:34:54.900 --> 00:34:57.970
We take the services that are proven and that are reliable

00:34:57.969 --> 00:35:02.929
because Open Source software is always more
reliable than the software you just wrote.

00:35:02.929 --> 00:35:06.419
And we just make sure they work well together.

00:35:06.420 --> 00:35:10.000
We test them and we put a nice user interface.

00:35:10.000 --> 00:35:14.409
And I think this has opened up
yet new markets, more new markets,

00:35:14.409 --> 00:35:18.139
things like small enterprises or big computing centers.

00:35:18.139 --> 00:35:24.329
In fact, we've had quite a bit of success with
Tiger server in terms of high performance computing,

00:35:24.329 --> 00:35:28.769
which is not at all what we had
worked to build in the product.

00:35:28.769 --> 00:35:31.610
It just happened and that was great.

00:35:31.610 --> 00:35:37.070
Now, let's do kind of forward, let's
move forward now to Leopard server.

00:35:37.070 --> 00:35:42.809
And what we're adding with Leopard server is innovation.

00:35:42.809 --> 00:35:46.170
There's a lot of innovation in Leopard server.

00:35:46.170 --> 00:35:53.030
We start with all the services that we have in Tiger
and then we add a new set of innovative services.

00:35:53.030 --> 00:35:58.130
I'm not going to cover them in detail because
that will be covered in this conference.

00:35:58.130 --> 00:36:02.650
But there's things like a new Wiki
server that's really great.

00:36:02.650 --> 00:36:10.710
There's a Spotlight server, there's Podcast Producer
to help you produce Podcasts, lots and lots of innovation.

00:36:10.710 --> 00:36:17.679
And I think we are going to create new markets that
will leverage all this set of server features.

00:36:17.679 --> 00:36:22.529
So, that's Mac OS X Server.

00:36:22.530 --> 00:36:30.840
And it's very pleasing to bring innovation in the server
space where in the past we've been kind of having,

00:36:30.840 --> 00:36:33.910
for the most part a container of open source services.

00:36:33.909 --> 00:36:39.670
That's kind of the new step in the
evolution of the server product.

00:36:39.670 --> 00:36:41.990
So, we've talked a lot about power.

00:36:41.989 --> 00:36:50.009
We talked about power of the CPU 64-bits the
Accelerate Framework and MP, the power of the GPU

00:36:50.010 --> 00:36:55.000
and the large scale power coming from server installations.

00:36:55.000 --> 00:36:57.940
But what you want is not just the power.

00:36:57.940 --> 00:37:01.610
You want the ability to create your applications quickly.

00:37:01.610 --> 00:37:05.300
You want to build applications fast.

00:37:05.300 --> 00:37:11.500
And this has been a preoccupation that we've
had since the beginning of the Macintosh,

00:37:11.500 --> 00:37:18.230
way back in system one in the Mac OS 1 days, I
think it was called system one in those days.

00:37:18.230 --> 00:37:24.880
We've focused on having a Toolbox, in fact the
Macintosh had the first GUI Toolbox in those days.

00:37:24.880 --> 00:37:33.250
And Toolbox is all about reuse of the code that
we do so that you can create fantastic applications.

00:37:33.250 --> 00:37:39.329
And the Toolbox evolved for the years, see, stacks of
inside Macintosh, those of you who were born then,

00:37:39.329 --> 00:37:44.019
grew a little bigger, it grew a little more complex.

00:37:44.019 --> 00:37:51.429
And so with Mac OS X we've took the
opportunity to really simplify all this.

00:37:51.429 --> 00:38:01.859
And that yielded the Carbon Toolbox that was a clean up
of the old Toolbox so that it can last another decade.

00:38:01.860 --> 00:38:06.550
We also added the Classic environment to make sure

00:38:06.550 --> 00:38:14.800
that we can bring along our users
from Mac OS 8 and 9 onto Mac OS X.

00:38:14.800 --> 00:38:23.580
And of course, we added Cocoa, our toolbox for the
future moving forward with object orientation and so forth.

00:38:23.579 --> 00:38:29.769
Now as time went by we stopped
investing in the classic environment.

00:38:29.769 --> 00:38:34.670
There was no need since you had brought all
these native applications onto the platform.

00:38:34.670 --> 00:38:42.409
Then a few years ago we engaged into another
transition that was the Intel transition

00:38:42.409 --> 00:38:44.869
when we switch from PowerPC to Intel.

00:38:44.869 --> 00:38:51.099
And one of the things that we built in which
is really a key for a successful transition was

00:38:51.099 --> 00:38:58.480
this Rosetta Compatibility box to
make sure again we can bring our users along

00:38:58.480 --> 00:39:01.240
and that we have a successful transition.

00:39:01.239 --> 00:39:07.849
Now, I have to tell you that pretty much as soon
as we shipped it we stopped investing in Rosetta.

00:39:07.849 --> 00:39:10.889
We haven't been spending much resources on Rosetta at all.

00:39:10.889 --> 00:39:17.869
We know it's going to fade away notably because you've
brought many universal applications on the platform.

00:39:17.869 --> 00:39:28.420
Now there will be a time in the future when
we will stop investing in Carbon, a lot.

00:39:28.420 --> 00:39:28.990
( Applause )

00:39:28.989 --> 00:39:39.989
A lot of the new energies all the energies
or resources go to Cocoa frameworks.

00:39:39.989 --> 00:39:45.689
Cocoa is our toolbox moving forward
and that's why we decided

00:39:45.690 --> 00:39:52.110
to have the 64-bit UI expressed
only in Cocoa and not Carbon.

00:39:52.110 --> 00:40:00.220
Cocoa is how we implement most of our system at, it's kind
of our little secret for fast implementation of apps.

00:40:00.219 --> 00:40:07.919
And in fact, even the new Cover Flow in finder
is actually a Cocoa object that we reused.

00:40:07.920 --> 00:40:14.000
Now Cocoa, as you know, is best on the
language and that's a very big leverage point,

00:40:14.000 --> 00:40:17.389
the language, because of course it
affects a lot of lines of code.

00:40:17.389 --> 00:40:19.809
So, I'll talk a little bit about the language.

00:40:19.809 --> 00:40:26.799
Then there's all the Cocoa frameworks and of course there's
the tool that much really match with both the language

00:40:26.800 --> 00:40:30.050
and the frameworks to get the full productivity.

00:40:30.050 --> 00:40:32.480
So, I'm going to cover briefly each 3.

00:40:32.480 --> 00:40:36.409
So first let's start with the language.

00:40:36.409 --> 00:40:42.179
The language for Cocoa is Objective-C. Now
Objective-C is really mostly C if you look at the B

00:40:42.179 --> 00:40:52.049
and F it's mostly C. What we added to C is a very thin layer
to do object orientation, to define classes and methods.

00:40:52.050 --> 00:40:57.769
And at the heart of Objective-C you
have the dispatcher, the message dispatcher.

00:40:57.769 --> 00:40:58.960
And that's the Runtime.

00:40:58.960 --> 00:41:02.119
And it's very powerful, very dynamic.

00:41:02.119 --> 00:41:07.500
Now when we look at what features we are going to
add to the language to have more productivity,

00:41:07.500 --> 00:41:11.510
we want to be very careful in adding just a few things.

00:41:11.510 --> 00:41:14.130
But we have a number of goals in mind.

00:41:14.130 --> 00:41:19.730
One of the goals, of course is to have the language
more expressive so that you have less code to write.

00:41:19.730 --> 00:41:24.389
Less code is always a good thing as we
know as long as the function remains the same.

00:41:24.389 --> 00:41:30.170
We want to make sure that the
code is inherently more reliable.

00:41:30.170 --> 00:41:34.530
We want to make sure it runs faster
and I'm sure everyone appreciates that.

00:41:34.530 --> 00:41:40.230
And we know that there are many folks who come
into the platform, we have seen a tremendous growth

00:41:40.230 --> 00:41:43.039
in our developer community over the last few years.

00:41:43.039 --> 00:41:47.289
and those folks typically do not
know Objective-C. So we want

00:41:47.289 --> 00:41:52.429
to make sure we lower the bar to
entry that it's more approachable.

00:41:52.429 --> 00:41:57.169
So, with these goals in mind the first feature that we added

00:41:57.170 --> 00:42:01.590
to Objective-C is we added Garbage
Collection to the Runtime.

00:42:01.590 --> 00:42:06.110
( Applause )

00:42:06.110 --> 00:42:14.410
So, garbage collection is opt-in, an application decides
whether it wants to be garbage collected or not.

00:42:14.409 --> 00:42:20.690
And we actually ship in Leopard two
applications that are garbage collected.

00:42:20.690 --> 00:42:27.360
The whole set of Cocoa frameworks works
both ways, either collected or not collected

00:42:27.360 --> 00:42:32.240
which I think is kind of a first
for garbage collected system.

00:42:32.239 --> 00:42:41.329
And when you use a garbage collector you have
a very modern very efficient garbage collector.

00:42:41.329 --> 00:42:49.079
It does multi-threading correctly it's using all the modern
techniques for being incremental and generational.

00:42:49.079 --> 00:42:54.730
So, obviously with a garbage collector you have way
less code because you don't have, you know,

00:42:54.730 --> 00:42:57.460
all this memory allocations, deallocation code

00:42:57.460 --> 00:43:03.230
And your code is extremely reliable
compared to standard non collected code.

00:43:03.230 --> 00:43:08.860
I mean we all know that many of the
bugs come from allocation issues.

00:43:08.860 --> 00:43:10.309
I'm not going to claim it's faster.

00:43:10.309 --> 00:43:19.480
It's definitely a little bit more work fundamentally to
clean up, to find out what is garbage and stash that away.

00:43:19.480 --> 00:43:22.750
And, it's definitely more approachable.

00:43:22.750 --> 00:43:27.679
In fact, the other few come from languages
like Java or the scripting languages.

00:43:27.679 --> 00:43:33.279
Well, all those languages are garbage collected,
all modern languages are garbage collected.

00:43:33.280 --> 00:43:36.250
So that's the first feature we've added to the language.

00:43:36.250 --> 00:43:43.489
Second feature, a very, very common pattern
is to have collections, collections of things

00:43:43.489 --> 00:43:45.729
and then you want to iterate in that collection.

00:43:45.730 --> 00:43:49.440
So, it used to be a few lines
of code and we just added

00:43:49.440 --> 00:43:54.150
a "for each" construct that enables you to have a single liner.

00:43:54.150 --> 00:43:56.160
It's very conceptually simple.

00:43:56.159 --> 00:44:01.549
It's correct because it's actually way
more expressive, way more readable.

00:44:01.550 --> 00:44:04.789
It's more reliable because it has certain properties

00:44:04.789 --> 00:44:09.429
when you muted the collection
underneath that now it's detected.

00:44:09.429 --> 00:44:17.929
It actually runs faster because we've added a protocol
to each (inaudible) in the arrays in such collections by batches.

00:44:17.929 --> 00:44:21.509
And it makes the code more approachable as well.

00:44:21.510 --> 00:44:32.100
The third feature we added is the pattern to have accessors,
to have like setters and getters.

00:44:32.099 --> 00:44:39.849
So you can take this entire pile of code to do setters and
getters and do it right with the memory allocation.

00:44:39.849 --> 00:44:42.819
And just change that with just one line.

00:44:42.820 --> 00:44:49.450
And that's a properties feature, again,
a lot more expressiveness, more reliable,

00:44:49.449 --> 00:44:53.989
less opportunities to have subtle
errors, and more approachable.

00:44:53.989 --> 00:44:56.209
And last, we have an enhanced Runtime.

00:44:56.210 --> 00:44:59.030
We've totally optimized the Runtime for 64-bits.

00:44:59.030 --> 00:45:05.180
We had no binary constraint, binary
compatibility constraint in the 64-bit world.

00:45:05.179 --> 00:45:12.589
So we took advantage of that to make sure we have
like the speed of light in terms of execution.

00:45:12.590 --> 00:45:20.700
And we also adopted a C++ exception model which
is faster when you don't take an exception.

00:45:20.699 --> 00:45:24.069
So we have a number of features here.

00:45:24.070 --> 00:45:29.510
I mean it's not a huge set of features but they're
very leveraged they impact your code

00:45:29.510 --> 00:45:32.550
if you choose to use those features.

00:45:32.550 --> 00:45:35.650
And so we call that Objective-C 2.0.

00:45:35.650 --> 00:45:38.579
We think it's a sufficient step in function.

00:45:38.579 --> 00:45:43.639
So, that was a brief overview of
what we've done with the language.

00:45:43.639 --> 00:45:46.429
Now, let's talk about the frameworks.

00:45:46.429 --> 00:45:54.219
We've had over the years a number of Cocoa frameworks.

00:45:54.219 --> 00:45:58.279
Some of the frameworks that have been
there from day one our foundation,

00:45:58.280 --> 00:46:03.530
which is kind of the non UI portion of
Cocoa and the AppKit to do a GUI frameworks.

00:46:03.530 --> 00:46:09.360
And I'm not trying to do an exact
picture here of the Cocoa frameworks.

00:46:09.360 --> 00:46:13.170
Now we added a number of frameworks over the years.

00:46:13.170 --> 00:46:21.190
Some that I want to mention because I think they are
significant: our CoreData to deal with persistency,

00:46:21.190 --> 00:46:32.110
CoreImage framework to deal with image transformations,
WebKit to deal with everything web, notably rendering HTML.

00:46:32.110 --> 00:46:38.530
And the AddressBook framework that
enables you to use the same data base

00:46:38.530 --> 00:46:45.220
as the Address Book application is using underneath
which is a per user persistent kind of data base.

00:46:45.219 --> 00:46:53.429
So, in Leopard we're adding more frameworks some of
them that I mentioned, one to do something very similar

00:46:53.429 --> 00:46:58.029
to the AddressBook framework which is
a CalendarStore API that enables you

00:46:58.030 --> 00:47:03.720
to access the data base that iCal is using with the events.

00:47:03.719 --> 00:47:10.929
And ImageKit, which is a framework to
deal with images, collection of images.

00:47:10.929 --> 00:47:15.119
And last but not least CoreAnimation,
to deal with animation.

00:47:15.119 --> 00:47:21.009
So I'm not going to cover all this
there's a lot of sessions that will.

00:47:21.010 --> 00:47:28.830
I just want to put a plug here for ImageKit and CoreAnimation
because I think they are frameworks that many

00:47:28.829 --> 00:47:32.250
of you will be able to use in a number of applications.

00:47:32.250 --> 00:47:35.300
So, first, let's talk about ImageKit.

00:47:35.300 --> 00:47:39.030
ImageKit has a number of facilities.

00:47:39.030 --> 00:47:42.740
One of the facilities is an object
called, a class called BrowserView

00:47:42.739 --> 00:47:48.839
to just display a bunch of images along with the labels.

00:47:48.840 --> 00:47:54.860
And you have all kinds of bells and whistles to
actually control exactly what you want to display.

00:47:54.860 --> 00:47:56.490
It's very fast.

00:47:56.489 --> 00:48:00.699
We've tested it up to a quarter million images.

00:48:00.699 --> 00:48:08.599
And the reason why it's really fast is that we are fairly
optimal in terms of totally leveraging the GPU for rendering

00:48:08.599 --> 00:48:12.159
and making sure we use a minimal amount of memory.

00:48:12.159 --> 00:48:18.969
Obviously if you are loading in
all the memory for all the images

00:48:18.969 --> 00:48:24.859
in your process you are not going to
scale up to a quarter million images.

00:48:24.860 --> 00:48:28.880
Another object you may benefit
from is the slideshow object.

00:48:28.880 --> 00:48:33.519
So now if you have a collection of objects
you can do what we've done in a number ofapps,

00:48:33.519 --> 00:48:36.389
which is provide the user with a slideshow.

00:48:36.389 --> 00:48:45.920
We have a picture taker object so you don't need to learn
how USB and Firewire cameras work or built in cameras.

00:48:45.920 --> 00:48:52.579
You just have a few lines of code and now you
can leverage a camera that's present in nearly all the Macs that we ship.

00:48:52.579 --> 00:48:59.619
And we have an object to let end-users
do simple editing of images.

00:48:59.619 --> 00:49:00.759
This is not Photoshop.

00:49:00.760 --> 00:49:02.980
This is simple image editing.

00:49:02.980 --> 00:49:07.949
But again, it's very easy for you with just a few
lines of code to set up your application

00:49:07.949 --> 00:49:12.399
so that it proposes an image editing panel.

00:49:12.400 --> 00:49:22.300
Next, Core Animation, now you saw Core
Animation this morning, you've seen the wall,

00:49:22.300 --> 00:49:29.050
the Apple TV wall done with Core Animation
done in just a few days for the initial kind of wall.

00:49:29.050 --> 00:49:36.810
And it was fun to see that demo kind of
come together just in the last few weeks.

00:49:36.809 --> 00:49:38.130
And you've seen it in action.

00:49:38.130 --> 00:49:44.460
You've seen Core Animation in action when you saw Time
Machine because that's all implemented using Core Animation.

00:49:44.460 --> 00:49:49.840
Core Animation is to render scenes.

00:49:49.840 --> 00:49:54.280
Now the scenes that it renders, the model
is that you have a hierarchy of layers.

00:49:54.280 --> 00:49:56.710
It's not just a flat set of layers.

00:49:56.710 --> 00:50:03.340
It's a hierarchy which means when you want to move
a portion of a tree everything kind of moves along.

00:50:03.340 --> 00:50:08.570
You have some constraints that you can
express very simply for the layout.

00:50:08.570 --> 00:50:11.870
And you can use that for really two different purposes.

00:50:11.869 --> 00:50:18.279
You can use that for the contents of your
application for the main document if you want,

00:50:18.280 --> 00:50:20.820
which is kind of what we did with the wall.

00:50:20.820 --> 00:50:26.190
Or you can use that for the UI of your
application, or the widgets, or the chrome, kind of, of your app.

00:50:26.190 --> 00:50:38.970
And we have two API's we have the Core Animation API per
say that you use for the contents that's really easy to use.

00:50:38.969 --> 00:50:46.819
That's all implicit so you specify how you want
things to be, you specify the new state of things

00:50:46.820 --> 00:50:52.710
and it automatically derives a
transition that needs to happen in time.

00:50:52.710 --> 00:50:58.210
Or you can use the AppKit API which has
been integrated with the Core Animation API.

00:50:58.210 --> 00:51:08.119
And then your view hierarchy will transform into a scene
hierarchy into a layer hierarchy which will get rendered.

00:51:08.119 --> 00:51:12.750
And we have Interface Builder support for it.

00:51:12.750 --> 00:51:21.090
So this was a very, very brief overview of a
couple of the frameworks there's a lot more.

00:51:21.090 --> 00:51:26.500
But to get the full power of the frameworks
you need to have the tools, the right tools,

00:51:26.500 --> 00:51:30.449
that's really a design with integration in mind.

00:51:30.449 --> 00:51:38.659
And if you go back in time the history of
tools at Apple has been a little checkered.

00:51:38.659 --> 00:51:43.109
You know, sometimes on sometimes off.

00:51:43.110 --> 00:51:49.890
And it's really with Xcode that
we committed big time on tools.

00:51:49.889 --> 00:51:59.670
This is the first time that we decided we'd have a great
set of tools and we've stuck to it and we're sticking to it.

00:51:59.670 --> 00:52:06.800
So after the introduction of Xcode 1.0 we have Xcode
2.0 to make sure it has all the features that you need.

00:52:06.800 --> 00:52:11.480
And of course after that we spent
some time to make sure we prepared

00:52:11.480 --> 00:52:16.460
for the universal binaries for creating universal apps.

00:52:16.460 --> 00:52:22.679
And what's really pleasing is the last year
has been spent mostly on innovative features,

00:52:22.679 --> 00:52:25.019
you know, beyond kind of the nuts and bolts.

00:52:25.019 --> 00:52:29.730
Now that that's done we can move
on onto kind of new features.

00:52:29.730 --> 00:52:40.050
Some of the new features Xray, Xray is an application
to deal with performance and we've had a great collection

00:52:40.050 --> 00:52:44.120
of performance tools, things like
Shark and Sampler and all that stuff.

00:52:44.119 --> 00:52:49.739
But it was very disparate there was no
unity in all those performance tools.

00:52:49.739 --> 00:52:54.549
And now with Xray we've unified all
that with a notion of time kind of passing

00:52:54.550 --> 00:52:57.860
by which is always present in performance.

00:52:57.860 --> 00:53:05.010
Another new app that we have part of
the developement tools is DashCode,

00:53:05.010 --> 00:53:08.710
which enables you to create widgets very simply.

00:53:08.710 --> 00:53:11.889
We have a new Interface Builder.

00:53:11.889 --> 00:53:14.210
Interface Builder that we've rewritten from scratch.

00:53:14.210 --> 00:53:15.570
And it's very, very fresh.

00:53:15.570 --> 00:53:22.059
It has, of course, it has more power with the
Core Animation properties and all that stuff.

00:53:22.059 --> 00:53:23.230
But it's very fresh.

00:53:23.230 --> 00:53:25.469
It really feels very different.

00:53:25.469 --> 00:53:30.250
We have Automator tool in the Lepoard tool set.

00:53:30.250 --> 00:53:35.599
Now Automator 1 we were really
pleased how Automator has done that.

00:53:35.599 --> 00:53:42.679
It enables people to really design simple work flows,
people who are not necessarily hard core programmers.

00:53:42.679 --> 00:53:49.480
And what we've done with Automator 2.0 to work is
retain the simplicity the spirit of Automator 1.0

00:53:49.480 --> 00:53:54.690
but at the same time add quite a bit
of power with things like variables

00:53:54.690 --> 00:53:58.789
so that now you can have work flows
that are a little more complex.

00:53:58.789 --> 00:54:02.039
But there's progressive disclosure here and you are not faced

00:54:02.039 --> 00:54:06.900
as a sophisticated user using Automator
with all that complexity.

00:54:06.900 --> 00:54:11.579
And the last app that's part of the
set of course is Xcode itself.

00:54:11.579 --> 00:54:20.539
We use Xcode both to name the umbrella of the
whole set of development tools as well as the IDE.

00:54:20.539 --> 00:54:27.139
And there's lost of iterated features in X code.

00:54:27.139 --> 00:54:32.719
So, we've talked about language, frameworks, and tools.

00:54:32.719 --> 00:54:39.379
And if you step back this is all about
knowledge, encapsulation and reuse.

00:54:39.380 --> 00:54:46.289
Everything we learned by doing our own
system applications we try to encapsulate

00:54:46.289 --> 00:54:51.250
and put that knowledge in these frameworks and these tools.

00:54:51.250 --> 00:54:54.840
And this is actually what we do across
different product lines as well.

00:54:54.840 --> 00:55:02.420
All the knowledge we've had built in Mac OS X we've been
using that knowledge to build Apple TV and the iPhone.

00:55:02.420 --> 00:55:08.639
Those products were built with the same language
some of the same libraries and the same tools.

00:55:08.639 --> 00:55:13.089
So this is all about building applications fast.

00:55:13.090 --> 00:55:17.320
But of course applications need
to have the right experience.

00:55:17.320 --> 00:55:21.309
And for that I'd like to ask Scott to come on stage, Scott.

00:55:21.309 --> 00:55:21.519
( Applause )

00:55:21.519 --> 00:55:28.780
>> Scott: Thank you friend.

00:55:28.780 --> 00:55:34.750
Alright, I get the pleasure of walking
you through the Leopard user experience.

00:55:34.750 --> 00:55:40.679
But first, let me take you back in
time to the user experience you missed.

00:55:40.679 --> 00:55:43.029
( Applause )

00:55:43.030 --> 00:55:47.269
Now that was a UI, text based, command line.

00:55:47.269 --> 00:55:53.579
And then we screwed it all up in 1984
with this little thing called the Mac.

00:55:53.579 --> 00:55:57.110
So, the Mac really changed everything.

00:55:57.110 --> 00:56:03.579
It, for the first time, brought a graphical user
interface to the consumer with multiple windows,

00:56:03.579 --> 00:56:06.920
true WYSIWYG, all accessible with a mouse.

00:56:06.920 --> 00:56:14.389
Now each subsequent release after the original Mac,
we refined the UI, we added things like MultiFinder,

00:56:14.389 --> 00:56:19.949
we added color, we went a little nuts in color sometimes.

00:56:19.949 --> 00:56:22.730
We love that background I guess.

00:56:22.730 --> 00:56:25.980
We, you know, we added things, we added an apps switcher.

00:56:25.980 --> 00:56:32.119
And by the time we got to Mac OS 9 we
really had, you know, a cacophony of UI's.

00:56:32.119 --> 00:56:35.699
It didn't look like it was all from the same OS.

00:56:35.699 --> 00:56:45.659
And so, with the introduction of Mac OS X we came out
with a new UI called Aqua and we unified everything.

00:56:45.659 --> 00:56:48.889
We had these nice translucent title bars.

00:56:48.889 --> 00:56:53.359
It took Microsoft a good six years to copy that part.

00:56:53.360 --> 00:57:00.240
We had innovations like sheets so
panels associated with their window.

00:57:00.239 --> 00:57:02.339
And of course we added the dock.

00:57:02.340 --> 00:57:11.250
And now with each subsequent release of Mac OS X,
we've continued to iterate and refine the design.

00:57:11.250 --> 00:57:14.340
So, we've experimented with different
levels of transparency.

00:57:14.340 --> 00:57:19.740
We've experimented with different renderings of controls.

00:57:19.739 --> 00:57:22.000
We've had brushed metal.

00:57:22.000 --> 00:57:27.030
We've gone and we've added a sidebar
for fast access to any folder.

00:57:27.030 --> 00:57:32.710
But again, by the time we got to Tiger a lot of
these experiments had gone in different directions.

00:57:32.710 --> 00:57:39.840
And so, for Leopard one of our design decisions was
to go ahead, pick the best elements out of Tiger,

00:57:39.840 --> 00:57:43.940
innovate beyond that, and once
again have a nice unified look.

00:57:43.940 --> 00:57:46.510
And that's exactly what we did.

00:57:46.510 --> 00:57:52.120
( Applause )

00:57:52.119 --> 00:57:53.480
So here is the look of Leopard.

00:57:53.480 --> 00:58:00.440
Again we've added, you know, a three dimensional aspect
to it, it's gorgeous new dock brush metal is gone.

00:58:00.440 --> 00:58:01.659
( Applause )

00:58:01.659 --> 00:58:06.440
And so we've done a lot.

00:58:06.440 --> 00:58:07.579
And let me walk you through it.

00:58:07.579 --> 00:58:12.110
But let me start by just talking about the
window because that's where we started.

00:58:12.110 --> 00:58:13.700
We started with the window.

00:58:13.699 --> 00:58:18.019
We now have a single unified window look across the board.

00:58:18.019 --> 00:58:19.349
It has different flavors of it.

00:58:19.349 --> 00:58:22.869
This is the one if you don't have a toolbar or anything.

00:58:22.869 --> 00:58:28.679
So, a simple title bar, simple single
unified look for Leopard looks like that.

00:58:28.679 --> 00:58:31.549
You can have an optional toolbar.

00:58:31.550 --> 00:58:34.680
And again, we integrated it in to look like a single piece.

00:58:34.679 --> 00:58:38.199
And you can have an optional status bar as well.

00:58:38.199 --> 00:58:42.529
The next problem we wanted to solve was
seeing what is currently the active window.

00:58:42.530 --> 00:58:45.230
Let me pull up a few windows.

00:58:45.230 --> 00:58:52.429
If you were to look at this on Tiger it would
be difficult to tell what the active window is.

00:58:52.429 --> 00:58:55.849
And the reason is for metal windows we
didn't really have an inactive look.

00:58:55.849 --> 00:59:00.259
I mean we took the color out of the buttons
and text went slowly gray on the title bar.

00:59:00.260 --> 00:59:01.720
But that was it.

00:59:01.719 --> 00:59:03.709
But now we have this unified look.

00:59:03.710 --> 00:59:04.690
It has an active look.

00:59:04.690 --> 00:59:06.099
It has an inactive look.

00:59:06.099 --> 00:59:07.259
And we do one more thing.

00:59:07.260 --> 00:59:10.250
We pop out a deep shadow for the front most ap.

00:59:10.250 --> 00:59:16.750
And now as you see when I go around the horn it's
really easy to tell which application is currently key.

00:59:16.750 --> 00:59:22.579
So, very clear what the active
app is what the inactive apps are.

00:59:22.579 --> 00:59:28.179
The next thing we did is take an application
like this, we have standard panels.

00:59:28.179 --> 00:59:35.069
So standard Leopard panels which, again, go along
with the language of the standard unified window look.

00:59:35.070 --> 00:59:40.510
But, we realized we needed to add
a little bit more for panels.

00:59:40.510 --> 00:59:47.160
The reason for that is that there are a number of
applications nowadays which are going full screen.

00:59:47.159 --> 00:59:51.199
And, we think that's a good thing for
three different types of applications.

00:59:51.199 --> 00:59:55.059
So the first type are applications that are media centric.

00:59:55.059 --> 01:00:00.539
Alright, so photo viewing, video viewing, this
is a movie applications, this is QuickTime.

01:00:00.539 --> 01:00:05.949
So for media centric applications there are times
when you want to get everything else out of the way

01:00:05.949 --> 01:00:10.750
so the user can concentrate directly upon the media itself.

01:00:10.750 --> 01:00:17.449
The second type of application we think makes sense
as a full screen app are truly immersive experiences.

01:00:17.449 --> 01:00:19.579
So, an example of that is time machine.

01:00:19.579 --> 01:00:23.920
when you're in Time Machine you don't
want to see today's Finder and today's files.

01:00:23.920 --> 01:00:27.380
You really are in this model immersive experience.

01:00:27.380 --> 01:00:31.590
The third type of application that makes
sense as a full screen application are games.

01:00:31.590 --> 01:00:32.820
So those three makes sense.

01:00:32.820 --> 01:00:34.090
We don't think many others do.

01:00:34.090 --> 01:00:41.910
But when you look at a full screen application
like this, those panels, they stand out.

01:00:41.909 --> 01:00:46.799
And the problem is those panels are
trying to be the stars themselves, right.

01:00:46.800 --> 01:00:54.810
The star of a full screen application and the reason you do
full screen applications is so the content can be the star.

01:00:54.809 --> 01:01:00.150
And so for Leopard we're adding another
panel type called the heads up display look.

01:01:00.150 --> 01:01:01.800
And this is it.

01:01:01.800 --> 01:01:06.580
So, if you have a.

01:01:06.579 --> 01:01:10.139
( Applause )
What these panels let you do is the star is the content.

01:01:10.139 --> 01:01:14.219
It allows you to concentrate on the content
while still having your panels here.

01:01:14.219 --> 01:01:21.899
Now for consistency's sake applications that go full screen
and use panels in full screen can also use these heads

01:01:21.900 --> 01:01:25.559
up displays or HUD look in their window look as well.

01:01:25.559 --> 01:01:31.150
Now, here's another example of an application this
is iPhoto, full screen editing, use the HUD look,

01:01:31.150 --> 01:01:34.720
and they can use it outside the full screen display as well.

01:01:34.719 --> 01:01:43.809
Here's Aperture, again the HUD look allows you to concentrate
on the pictures themselves instead of the panels

01:01:43.809 --> 01:01:52.929
Here's iChat, video chat, again the video effects
picker is a HUD look in an out a full screen time machine.

01:01:52.929 --> 01:01:58.859
The quick look feature we've added uses the HUD
look so you can concentrate on the contents.

01:01:58.860 --> 01:02:01.789
But again, the HUD look is not for everything.

01:02:01.789 --> 01:02:04.099
This here is Pages.

01:02:04.099 --> 01:02:05.849
Pages is not a multimedia app.

01:02:05.849 --> 01:02:07.869
It's not a full screen application.

01:02:07.869 --> 01:02:14.589
So for something like Pages it can use the standard
Leopard panel look same thing's true here for the Finder,

01:02:14.590 --> 01:02:19.620
the inspector panel should use the standard Leopard look.

01:02:19.619 --> 01:02:26.599
So, we think for most applications now we have
this great unified window look across the board

01:02:26.599 --> 01:02:31.539
And for some applications that
go full screen the judicious use

01:02:31.539 --> 01:02:37.269
of HUD panels will really allow you
to concentrate on the content itself.

01:02:37.269 --> 01:02:40.369
Alright, now let's look at a bunch of different windows.

01:02:40.369 --> 01:02:43.369
Here are all the windows you know
and love in Tiger right now.

01:02:43.369 --> 01:02:46.380
Here's one of the older Aqua window looks.

01:02:46.380 --> 01:02:50.000
Here is a unified toolbar title bar look.

01:02:50.000 --> 01:02:53.409
We've got a metal topped window.

01:02:53.409 --> 01:02:56.199
Here's another sort of standard Aqua look.

01:02:56.199 --> 01:03:00.989
Here's a full brushed metal window and a second one.

01:03:00.989 --> 01:03:04.339
And here's the Spotlight window which
is somewhat similar to the Mail window.

01:03:04.340 --> 01:03:07.100
And we have the Find which is another brush metal thing.

01:03:07.099 --> 01:03:14.839
So, let me walk you through what we've done with each of
these apps to go to the new unified Leopard window look.

01:03:14.840 --> 01:03:16.590
Start with brush metal.

01:03:16.590 --> 01:03:18.170
Brush metal is gone.

01:03:18.170 --> 01:03:24.110
So, yeah, I've heard it at the feedback forums each year.

01:03:24.110 --> 01:03:27.019
We love brush metal, get rid of it.

01:03:27.019 --> 01:03:33.030
So, the nice unified look, and again we see we get rid
of some of the interstitial space so you can concentrate

01:03:33.030 --> 01:03:36.970
on the content of the application
instead of the window itself.

01:03:36.969 --> 01:03:38.519
Here's another one with Preview.

01:03:38.519 --> 01:03:45.619
So here we had a separate title bar and toolbar, again
combines beautifully into the new and unified window look.

01:03:45.619 --> 01:03:51.730
Mail, we're experimenting with this new look
in Tiger and it works perfectly in Leopard.

01:03:51.730 --> 01:03:52.789
This is an interesting one.

01:03:52.789 --> 01:03:58.429
We had a Spotlight window and a Finder
window which when you did searching

01:03:58.429 --> 01:04:01.789
in Finder it did pretty much the exact same thing.

01:04:01.789 --> 01:04:05.739
And not only did we have two windows and
two apps which didn't make a lot of sense,

01:04:05.739 --> 01:04:09.159
but we also had completely different UI's for them.

01:04:09.159 --> 01:04:10.649
So, we're doing a couple things here.

01:04:10.650 --> 01:04:14.680
the first thing is we are integrating all
the functionality from the Spotlight window

01:04:14.679 --> 01:04:18.179
into the Finder window so they're not two windows anymore.

01:04:18.179 --> 01:04:23.039
( Applause )

01:04:23.039 --> 01:04:30.090
The next thing we're doing is we start by
brushing out the metal and get the new look.

01:04:30.090 --> 01:04:34.490
We go to our standard sidebar so
we have this new standard sidebar

01:04:34.489 --> 01:04:37.069
with a little bit of color, make it pop a little bit.

01:04:37.070 --> 01:04:40.220
We remove the interstitial space.

01:04:40.219 --> 01:04:48.099
All of the icons which used to be just pure generic
icons are now previews of the documents inside them.

01:04:48.099 --> 01:04:55.319
And of course we've added really nice new view
with cover flow and quick looks on top of that.

01:04:55.320 --> 01:04:58.789
So, we think you're going to absolutely love the new Finder.

01:04:58.789 --> 01:05:01.190
Now, you're asking yourself, let me back up one second here.

01:05:01.190 --> 01:05:04.809
You're asking yourself okay we've changed the UI.

01:05:04.809 --> 01:05:08.000
How much work is it going to be for all of you?

01:05:08.000 --> 01:05:11.940
You all, this is your job and you're wondering
if we've just added a few months of work.

01:05:11.940 --> 01:05:18.099
You know this is good job security
but we want this to be easy

01:05:18.099 --> 01:05:22.150
so you can be implementing the features
that you're being asked to do instead.

01:05:22.150 --> 01:05:30.230
And so the answer is, if you were a good citizen meaning
you're either using Cocoa and letting Cocoa do the drawing

01:05:30.230 --> 01:05:37.760
for you or you're a Carbon application and you're
using the theme API's the new look comes for free.

01:05:37.760 --> 01:05:44.610
So, what we did as a test of this is we downloaded
two random apps off version tracker, ran them on Tiger,

01:05:44.610 --> 01:05:47.780
did a screen shot, ran them on Leopard, did a screen shot.

01:05:47.780 --> 01:05:48.670
And here they are.

01:05:48.670 --> 01:05:56.599
So the first one here, Transmit, a popular FTP tool, this
is just the straight up binary downloaded running on Tiger.

01:05:56.599 --> 01:05:58.069
And here it is running on Leopard.

01:05:58.070 --> 01:06:03.090
No change whatsoever, automatically
picks up the new unified look.

01:06:03.090 --> 01:06:06.170
Here's another one, this is an educational app

01:06:06.170 --> 01:06:09.230
Again this is a metal app with even a metal panel.

01:06:09.230 --> 01:06:11.880
Here's how it looks when running on Tiger.

01:06:11.880 --> 01:06:13.990
And here's how it looks running on Leopard.

01:06:13.989 --> 01:06:15.579
No change whatsoever.

01:06:15.579 --> 01:06:19.590
So, hopefully for most of you you're
letting the Frameworks do the work

01:06:19.590 --> 01:06:23.980
of the drawing and it should just come straight across.

01:06:23.980 --> 01:06:26.380
So, let's put it all together.

01:06:26.380 --> 01:06:30.619
Here's all the different window types that we had on Tiger.

01:06:30.619 --> 01:06:41.139
And this is what it looks like on Leopard, nicely
unified single unified window across the board.

01:06:41.139 --> 01:06:44.940
Now the next thing we did is we changed
out the background to be a photo.

01:06:44.940 --> 01:06:49.280
And we really believe that people
should be customizing their machines.

01:06:49.280 --> 01:06:54.690
We see them customizing their machines and they customize
it with, you know, photos of their kids, of their family,

01:06:54.690 --> 01:06:57.550
of their friends, of nature shots they take.

01:06:57.550 --> 01:07:02.490
And so we want the UI to work beautifully with your photos.

01:07:02.489 --> 01:07:06.819
So the first thing we did here is we add a new menu bar.

01:07:06.820 --> 01:07:10.980
Now, this new menu bar actually plays a number
of tricks, a number of photographic tricks.

01:07:10.980 --> 01:07:13.949
We actually do some burning and some dodging.

01:07:13.949 --> 01:07:18.399
So you'll see the Apple and actually the text
will absorb some of the color from the back.

01:07:18.400 --> 01:07:20.019
And yet it's still readable.

01:07:20.019 --> 01:07:25.670
So there's a whole lot of processing going on to make
sure that this one was gorgeous with your photos.

01:07:25.670 --> 01:07:28.539
The next thing we do is we add a little bit of 3D.
=

01:07:28.539 --> 01:07:32.329
so we pop out the active window with a deeper shadow.

01:07:32.329 --> 01:07:37.610
And then we slide in this brand new three
dimensional dock which actually reflects.

01:07:37.610 --> 01:07:42.519
I know it's hard to see for some of you, this
three dimensional dock which reflects the icons,

01:07:42.519 --> 01:07:46.690
reflects the windows, reflects the icons and gives us more of a 3D look overal=l.

01:07:46.690 --> 01:07:52.349
So again, this is what it looked like on Tiger

01:07:52.349 --> 01:08:01.869
And now with all the changes this
is Leopard, Tiger, and Leopard.

01:08:01.869 --> 01:08:05.130
Now we went one step further.

01:08:05.130 --> 01:08:11.039
We want you to be really to be able to take full
advantage of putting your own photos on the desktop.

01:08:11.039 --> 01:08:15.170
And so part of that means we need to clean up your desktop.

01:08:15.170 --> 01:08:19.109
And we're doing that by adding another feature called stacks.

01:08:19.109 --> 01:08:22.949
So let me add in, a little function now that's
hiding here in the dock which is stacks.

01:08:22.949 --> 01:08:27.109
And we have these stacks and this
one here is a download stack.

01:08:27.109 --> 01:08:34.229
So with this download stack any file that you download
from Safari will go right on the top of this stack,

01:08:34.229 --> 01:08:39.689
stay off of your photo on the desktop and allow
you to see your own photos on the desktop.

01:08:39.689 --> 01:08:44.639
If you are writing an application
today which downloads files,

01:08:44.640 --> 01:08:48.710
make sure that you're downloading it
to the standard download location.

01:08:48.710 --> 01:08:55.239
It'll automatically animate and appear on the top
of our download stack and keep the desktop clean.

01:08:55.239 --> 01:09:01.399
So this right here is the new look of Leopard.

01:09:01.399 --> 01:09:05.069
I think you're absolutely going to love it.

01:09:05.069 --> 01:09:10.299
So as Bertrand said at the top, our agenda first power,

01:09:10.300 --> 01:09:14.670
being able to build really fast
applications take advantage of the hardware.

01:09:14.670 --> 01:09:21.800
Foundations provide the frameworks so you can
easily write great applications really fast.

01:09:21.800 --> 01:09:27.680
And experience, we want you to build
the best applications possible.

01:09:27.680 --> 01:09:29.770
And that really is our job.

01:09:29.770 --> 01:09:37.190
Our job is we want to have as many world class
applications best of breed running on the Mac.

01:09:37.189 --> 01:09:39.569
And we think we've done a pretty good job of that.

01:09:39.569 --> 01:09:48.509
If you look out there today there are over 17,000
native applications for Mac OS X, thank you.

01:09:48.510 --> 01:09:53.989
( Applause )

01:09:53.989 --> 01:10:03.739
17,000, and this really forms a whole
constellation of choices for our collective users.

01:10:03.739 --> 01:10:10.069
On top of that there are another more
than 3,000 widgets, which have been built.

01:10:10.069 --> 01:10:11.960
So thank you for that.

01:10:13.090 --> 01:10:18.069
So this really forms, you know, it
adds to this constellation of choices.

01:10:18.069 --> 01:10:26.869
But nowadays a lot of applications that used to be written
as client applications are written as web applications.

01:10:26.869 --> 01:10:28.359
There's a lot of banking sites now.

01:10:28.359 --> 01:10:33.750
Instead of having a client you go to the
bank's website and do your banking there.

01:10:33.750 --> 01:10:42.680
The amazing thing about this is today there are
over 100 million websites, 100 million websites.

01:10:42.680 --> 01:10:52.200
So there truly are a universe of applications of
people to choose from, some clients some web based.

01:10:52.199 --> 01:10:54.000
I found this chart interesting.

01:10:54.000 --> 01:10:58.020
This is a chart of the growth of websites.

01:10:58.020 --> 01:11:04.350
You'll see today it will actually
up north of 118 million websites.

01:11:04.350 --> 01:11:07.870
You can see what happened during
the dot com bust, which is amazing.

01:11:07.869 --> 01:11:12.289
It was only about a year, year and a half
and it really actually just leveled off.

01:11:12.289 --> 01:11:13.760
It went down slightly.

01:11:13.760 --> 01:11:17.560
But it is once again on a tare upward.

01:11:17.560 --> 01:11:25.400
The great thing is these applications are
available to people running a Mac because of Safari.

01:11:25.399 --> 01:11:27.469
Now we're really, really pleased with Safari.

01:11:27.470 --> 01:11:30.680
We have been investing heavily with Safari.

01:11:30.680 --> 01:11:37.720
And with Safari 3.0 this comes with Leopard and will
go to Tiger as well we're extremely pleased with it.

01:11:37.720 --> 01:11:39.390
And we start with the UI.

01:11:39.390 --> 01:11:48.300
Our design goal with Safari was to build
a web browser which stayed out of the way

01:11:48.300 --> 01:11:54.270
and allowed your websites, your
web applications to be the star.

01:11:54.270 --> 01:11:57.210
Alright, we didn't want the browser
itself to be the star of it.

01:11:57.210 --> 01:11:59.980
And so, we tried to make it very
simple up top and let all the rest

01:11:59.979 --> 01:12:04.069
of the content be your content and yours be the star.

01:12:04.069 --> 01:12:07.849
The next thing we really paid attention to was performance.

01:12:07.850 --> 01:12:10.300
Now this is the iBench benchmark.

01:12:10.300 --> 01:12:11.720
Smaller numbers are better.

01:12:11.720 --> 01:12:14.260
The question is how fast can you perform it.

01:12:14.260 --> 01:12:18.579
And again we are more than twice as fast as the competition.

01:12:18.579 --> 01:12:25.000
So, we have a very, very fast browser that's for
JavaScript, HTML obviously this also important.

01:12:25.000 --> 01:12:28.689
And again we are more than twice as fast.

01:12:28.689 --> 01:12:31.159
Now, we've also been aggressive about adding features.

01:12:31.159 --> 01:12:34.189
And I'll talk about just one.

01:12:34.189 --> 01:12:37.609
We think that people are using more and more tabs nowadays.

01:12:37.609 --> 01:12:41.049
So with the new Safari and Safari
3.0 we allow you to do things

01:12:41.050 --> 01:12:45.820
like grab a tab drag it off, have
it turn into its own window.

01:12:45.819 --> 01:12:50.729
You can also grab a window and put it
into another window so it becomes a tab.

01:12:50.729 --> 01:12:55.509
So, you can really manage multiple
windows and multiple tabs extremely well.

01:12:55.510 --> 01:13:02.730
( Applause )

01:13:02.729 --> 01:13:06.929
We are also huge advocates of open standards.

01:13:06.930 --> 01:13:13.010
We love the fact that the web allows you to write
an application that runs on multiple platforms.

01:13:13.010 --> 01:13:14.289
We think it's a really important thing.

01:13:14.289 --> 01:13:20.829
And so we are active members of the open standard
community and are supporting all of Web 2.0 and Ajax.

01:13:20.829 --> 01:13:25.250
We've added a tremendous amount
of support in the new Safari.

01:13:25.250 --> 01:13:30.119
So, everything across the board
from HTML to CSS to Java script,

01:13:30.119 --> 01:13:33.809
you name it we are adding support
for all the standards out there.

01:13:33.810 --> 01:13:36.970
And a lot of work has gone in in the last year for this.

01:13:36.970 --> 01:13:41.579
What that means is applications
like Google docs which would not run

01:13:41.579 --> 01:13:46.460
in the previous Safari, now run great in the new Safari.

01:13:46.460 --> 01:13:47.840
It also means.

01:13:47.840 --> 01:13:52.180
( Applause )

01:13:52.180 --> 01:13:59.140
Another website that people have been looking at Zillow which
tells you, you can find houses with the Web 2 application.

01:13:59.140 --> 01:14:07.770
It will allow you to find that four bedroom
house in San Francisco for 65 million dollars.

01:14:07.770 --> 01:14:11.300
So, that'll come in useful.

01:14:11.300 --> 01:14:17.690
Now at the heart of Safari at the
heart of the application is the engine.

01:14:17.689 --> 01:14:21.119
And the engine of Safari is WebKit.

01:14:21.119 --> 01:14:24.380
And WebKit is Open Source.

01:14:24.380 --> 01:14:28.500
Web kit has a thriving Open Source community.

01:14:28.500 --> 01:14:33.600
We have a number of contributors from very
large companies many of which are here today.

01:14:33.600 --> 01:14:38.550
We also have a really large number
of individuals who contribute to it.

01:14:38.550 --> 01:14:41.260
So, it has an absolute thriving community.

01:14:41.260 --> 01:14:43.520
And for us, that's really important.

01:14:43.520 --> 01:14:46.200
We want to make it better and better
add more and more standards.

01:14:46.199 --> 01:14:53.189
And we think that's great because for us WebKit
isn't just the heart of Safari, which it is.

01:14:53.189 --> 01:14:56.689
It's also the heart of a lot of
the applications on our system.

01:14:56.689 --> 01:15:01.519
The dictionary app is just a WebKit based application.

01:15:01.520 --> 01:15:07.050
In fact the transcripts you see
in iChat are done using WebKit.

01:15:07.050 --> 01:15:09.770
Our help system is done using WebKit.

01:15:09.770 --> 01:15:15.090
In fact one of the features that we've added
for Leopard is this stationery feature in Mail.

01:15:15.090 --> 01:15:19.010
And it allows you to send beautiful stationery to anyone.

01:15:19.010 --> 01:15:23.369
And they can all read it because
the stationery that comes is HTML.

01:15:23.369 --> 01:15:26.260
Well turns out even in the composed window in Mail

01:15:26.260 --> 01:15:32.720
when you're writing this email you're editing HTML
live we make it feel like it's just a text editor

01:15:32.720 --> 01:15:38.710
so we don't even let you know it's HTML it's
HTML and it's using the WebKit engine.

01:15:38.710 --> 01:15:45.970
And of course Dashboard is built
completely on top of WebKit.

01:15:45.970 --> 01:15:50.490
So, we think that everyone deserves Safari.

01:15:50.489 --> 01:15:57.689
Alright, we got great user interface, great performance,
great features, it's open source, it's open standards.

01:15:57.689 --> 01:16:01.769
We think everyone deserves Safari.

01:16:01.770 --> 01:16:06.120
( Laughter )

01:16:06.119 --> 01:16:13.449
So a couple of weeks ago Steve
was asked about iTunes on Windows.

01:16:13.449 --> 01:16:19.949
And his response was well, we build
iTunes for Windows and a lot of people

01:16:19.949 --> 01:16:23.449
on Windows tell us that iTunes is their favorite app.

01:16:23.449 --> 01:16:25.460
It's the best app on Windows.

01:16:25.460 --> 01:16:34.760
In fact, giving iTunes to someone on Windows is sort
of like giving a glass of ice water to someone in hell.

01:16:34.760 --> 01:16:37.070
( Laughter )

01:16:37.069 --> 01:16:43.179
Now, we think those people stuck
in Windows hell are really thirsty.

01:16:43.180 --> 01:16:45.320
And they deserve a second glass.

01:16:45.319 --> 01:16:45.399
( Laughter )

01:16:45.399 --> 01:16:48.889
And so that's why today.

01:16:48.890 --> 01:16:51.970
( Applause )

01:16:51.970 --> 01:17:04.570
This is why today we announced we are taking Safari from Mac
OS X, we have ported it to Windows to both XP and to Vista.

01:17:04.569 --> 01:17:11.000
It comes across, it is the same WebKit
engine, the same open source WebKit engine

01:17:11.000 --> 01:17:16.579
that powers Safari on the Mac now powers Safari on Windows.

01:17:16.579 --> 01:17:18.289
It has the same performance.

01:17:18.289 --> 01:17:20.109
So let's look at this JavaScript performance.

01:17:20.109 --> 01:17:22.409
Smaller numbers are better.

01:17:22.409 --> 01:17:27.659
We are whupping IE in their own house.

01:17:27.659 --> 01:17:34.529
It's their own OS and we've come over and
in a few months we're whupping them.

01:17:34.529 --> 01:17:39.469
HTML same thing, alright, we have no
hooks into the OS that are special.

01:17:39.470 --> 01:17:44.050
As a third party we are twice as fast as IE on their own OS.

01:17:44.050 --> 01:17:47.029
We have the same features.

01:17:47.029 --> 01:17:52.659
We brought across the same feature
set from Mac OS X to Windows.

01:17:52.659 --> 01:17:57.269
And as I said it is the same open source engine.

01:17:57.270 --> 01:18:03.270
So we've had a thriving open source community
so far with Safari when it's just in the Mac.

01:18:03.270 --> 01:18:08.170
We expect it's just going to explode now that it's on Windows.

01:18:08.170 --> 01:18:14.770
We support the same open standards on
Safari on Windows as we do on the Mac.

01:18:14.770 --> 01:18:19.340
All of Web 2.0 and AJAX and we're
aggressively moving that forward.

01:18:19.340 --> 01:18:25.300
But you know compatibility is about
more than just open standards.

01:18:25.300 --> 01:18:29.239
It's about people using the application
and testing against it.

01:18:29.239 --> 01:18:34.099
And we know there are some sorry souls
out there who just have a Windows PC.

01:18:34.100 --> 01:18:38.900
And they're writing their websites and
they don't know if it runs on Safari.

01:18:38.899 --> 01:18:46.239
Well now, they can download Safari and run it on that
Windows PC we expect the compatibility will go up.

01:18:46.239 --> 01:18:48.909
But we want to go one step further than that.

01:18:48.909 --> 01:18:55.930
We're actually building in tremendous
debugging tools directly into Safari.

01:18:55.930 --> 01:19:00.650
So, as a developer you can turn on
this tool, yeah you're going to love this.

01:19:00.649 --> 01:19:02.279
( Applause )

01:19:02.279 --> 01:19:04.170
As a developer you can turn this on.

01:19:04.170 --> 01:19:10.750
It'll tell you exactly what resources have been downloaded,
which ones haven't, how much time it took to download them,

01:19:10.750 --> 01:19:14.819
if you have and error in your HTML
or your CSS, it'll point that out.

01:19:14.819 --> 01:19:19.569
We're going to make Safari one of the best
debug tools for building a website.

01:19:19.569 --> 01:19:26.809
So my expectation is soon web developers out there on
Windows and the Mac will use Safari not just to test against

01:19:26.810 --> 01:19:31.510
but actually to build their websites
for, and then they'll go test against IE.

01:19:31.510 --> 01:19:38.579
( Applause )

01:19:38.579 --> 01:19:47.399
So, as of yesterday we had Safari on a
single platform now as Mac OS, Mac OS X.

01:19:47.399 --> 01:19:56.039
As of today we have Safari on two
platforms Mac OS X and Windows.

01:19:56.039 --> 01:20:08.109
But, in 18 days we're going to have Safari on a third
platform and that, plat phone, that's and that is iPhone.

01:20:08.109 --> 01:20:18.719
Safari on iPhone runs the exact same
open source engine which is WebKit.

01:20:18.720 --> 01:20:28.520
So we share that same engine between Safari on Mac
OS X, Safari on Windows, and Safari on iPhone.

01:20:28.520 --> 01:20:30.160
It's the same engine.

01:20:30.159 --> 01:20:31.500
So we've been getting these questions though.

01:20:31.500 --> 01:20:33.090
Is the iPhone open?

01:20:33.090 --> 01:20:34.600
Is it an open platform?

01:20:34.600 --> 01:20:39.829
And the fact is because of this icon right
down here, because Safari is on it, it is,

01:20:39.829 --> 01:20:47.010
you can write extensible applications
for iPhone as web applications.

01:20:47.010 --> 01:20:50.550
Now let me show you what this looks like.

01:20:50.550 --> 01:20:53.560
So, we have the same rendering engine across the board.

01:20:53.560 --> 01:21:00.970
So this is what the New York Times looks
like when rendered in Safari on the Mac.

01:21:00.970 --> 01:21:05.890
This is what it looks like rendered in Safari on Windows.

01:21:05.890 --> 01:21:09.900
Here's what it looks like rendered in Safari on iPhone.

01:21:09.899 --> 01:21:14.069
Now, here's what it looks like on
these other, so called, smart phones.

01:21:14.069 --> 01:21:16.389
( Laughter )

01:21:16.390 --> 01:21:25.050
But this is what it looks like on the iPhone, you know.

01:21:25.050 --> 01:21:27.079
( Applause )

01:21:27.079 --> 01:21:29.279
Same thing here for a Google search.

01:21:29.279 --> 01:21:34.719
So here's a Google search result,
Safari on the Mac, Safari on Windows,

01:21:34.720 --> 01:21:38.990
the same Google search result on Safari on iPhone.

01:21:38.989 --> 01:21:41.809
And again, on these

01:21:41.810 --> 01:21:42.950
( Laughter )

01:21:42.949 --> 01:21:44.880
Other devices.

01:21:44.880 --> 01:21:47.199
Let's go back to Safari on the phone.

01:21:47.199 --> 01:21:56.609
One more example the BBC I think is a great news site,
Safari on the Mac, Safari on Windows, Safari on iPhone.

01:21:56.609 --> 01:22:01.529
I really, I don't know what they're trying to do here.

01:22:01.529 --> 01:22:08.739
I mean the more and more you look at it
Safari on iPhone gives you the full Internet.

01:22:08.739 --> 01:22:14.340
But these other phones they're give you
sort of this, I don't know, baby web.

01:22:14.340 --> 01:22:19.210
( Laughter )

01:22:19.210 --> 01:22:27.079
If you want the entire Internet on
your phone you've gotta come to iPhone.

01:22:27.079 --> 01:22:30.600
Now, on top of this, so you can see how it's laid out.

01:22:30.600 --> 01:22:31.760
You can see the entire page.

01:22:31.760 --> 01:22:33.440
It's rendered the same way.

01:22:33.439 --> 01:22:38.989
But to access different parts of it we use the touch
screen interface, so you can double tap on any region.

01:22:38.989 --> 01:22:44.519
We actually do an analysis on that part of the page
and then pull it forward so you can see it full screen.

01:22:44.520 --> 01:22:47.390
You can double tap to zoom back out.

01:22:47.390 --> 01:22:50.789
You can move to different parts of the page.

01:22:50.789 --> 01:22:55.939
If you turn it landscape we actually have an accelerometer
so we know when you've gone landscape versus portraits.

01:22:55.939 --> 01:22:57.679
We can tell this automatically.

01:22:57.680 --> 01:23:00.700
You can zoom out, you can zoom into a story in landscape.

01:23:00.699 --> 01:23:01.989
And scroll through it.

01:23:01.989 --> 01:23:04.099
It works great.

01:23:04.100 --> 01:23:11.360
So our goal has been number one out of the box to make it
so you can view any website out there of those, you know,

01:23:11.359 --> 01:23:15.250
100 million websites on the phone without change.

01:23:15.250 --> 01:23:25.750
But we want to go a step beyond that and enable you to build
applications that are really customized for iPhone itself.

01:23:25.750 --> 01:23:29.149
And to do that there's really three
things you need to consider.

01:23:29.149 --> 01:23:31.769
The first are standards.

01:23:31.770 --> 01:23:34.200
The second is the size of the screen.

01:23:34.199 --> 01:23:37.989
And the third is the fact that we have a touch interface.

01:23:37.989 --> 01:23:41.069
So let me start with the first one.

01:23:41.069 --> 01:23:47.909
This is the exact same rendering engine WebKit as
it is on Safari on the Mac and Safari on Windows.

01:23:47.909 --> 01:23:49.460
And we support all the same standards.

01:23:49.460 --> 01:23:51.480
But, we do not support the extras.

01:23:51.479 --> 01:23:52.959
So, we support Web 2.0 and AJAX.

01:23:52.960 --> 01:23:56.670
We do not support Flash or Java inside it.

01:23:56.670 --> 01:24:02.380
That clapping is not coming from Macromedia.

01:24:02.380 --> 01:24:03.590
( Laughter )

01:24:03.590 --> 01:24:05.869
The next is the size of the screen.

01:24:05.869 --> 01:24:13.380
So one of our design considerations for iPhone
was to have the biggest display possible.

01:24:13.380 --> 01:24:18.409
And that's one reason we didn't mold the
buttons or the key board into the plastic.

01:24:18.409 --> 01:24:22.170
We bring them in when needed and then we can
get rid of it when we don't need it anymore.

01:24:22.170 --> 01:24:28.069
And so, if you look at our screen it's
huge compared to other smart phones.

01:24:28.069 --> 01:24:32.059
It's small compared to the iMac
in the corner of your office.

01:24:32.060 --> 01:24:38.030
So, the best way to layout your websites
is to do it in sort of a newspaper model,

01:24:38.029 --> 01:24:46.579
which is nice columns where when you double tap and zoom in
that fully zoomed in column has a font which is big enough

01:24:46.579 --> 01:24:49.680
to be read without doing horizontal scrolling.

01:24:49.680 --> 01:24:53.720
So, I mean if you've gone to journalism school, the
way they tell you to lay things out for newspapers

01:24:53.720 --> 01:24:56.670
and magazines is always to have relatively thin columns.

01:24:56.670 --> 01:24:59.720
Those work perfectly on iPhone.

01:24:59.720 --> 01:25:04.909
The third thing is your finger is not a mouse.

01:25:04.909 --> 01:25:09.119
So we do a lot of things on the
phone to make sure that, you know,

01:25:09.119 --> 01:25:12.640
as you move around you can scroll and you can tap links.

01:25:12.640 --> 01:25:16.180
And we make this work pretty seamlessly.

01:25:16.180 --> 01:25:21.820
But the fact is there are certain events that you
get on a desktop that we do not get on iPhone.

01:25:21.819 --> 01:25:25.729
We don't get hover events, and we
don't get sort of a moved event, right.

01:25:25.729 --> 01:25:31.339
So, we don't know that your fingers are moving in space
around here and we can't do roll over space in that.

01:25:31.340 --> 01:25:36.529
When you touch the screen and start moving
now we're actually doing scrolling on there.

01:25:36.529 --> 01:25:43.880
And so if you make sure that your website works without
hover or move events, and there's a set of other things

01:25:43.880 --> 01:25:48.650
to think about which will be talked about
at a session tomorrow then you can make it

01:25:48.649 --> 01:25:51.539
so your website works just great.

01:25:51.539 --> 01:25:58.149
And we think by taking these things into account
you can actually build really great applications.

01:25:58.149 --> 01:26:04.769
In fact it's because we have Safari
on here but it's more than that.

01:26:04.770 --> 01:26:11.440
it's the fact that iPhone is basically
an always connected device, right?

01:26:11.439 --> 01:26:14.189
It's not like your portable that sometimes isn't connected.

01:26:14.189 --> 01:26:22.009
Because you have cellular edge connection or you have
wifi connection it's basically an always connected device.

01:26:22.010 --> 01:26:29.670
And so, a web application, which is built for iPhone
and customized for iPhone can have the same look, feel,

01:26:29.670 --> 01:26:36.840
behavior and presence as a built in
application like the one I demoed this morning.

01:26:36.840 --> 01:26:40.720
So let me go ahead and walk you
through a few demos of iPhone.

01:26:44.899 --> 01:26:49.279
Alright, so here again is iPhone.

01:26:49.279 --> 01:26:54.069
I can slide this across to unlock it.

01:26:54.069 --> 01:26:56.829
And here we are at the home screen.

01:26:56.829 --> 01:27:00.510
So again, Safari is right here on what we call our dock.

01:27:00.510 --> 01:27:01.659
Here's the home page.

01:27:01.659 --> 01:27:05.000
But let me take you to say, Google news.

01:27:05.000 --> 01:27:12.489
So here's loading up Google news, and you'll notice that
they've done, you know, they have these nice columns.

01:27:12.489 --> 01:27:17.929
And even while it's loading I can double tap
on a story, it zooms it right in to fill that.

01:27:17.930 --> 01:27:22.480
double tap again to go out, I can double tap on the side.

01:27:22.479 --> 01:27:29.569
So we're actually doing a pretty complex analysis of
the page to make sure that we zoom in on the right part.

01:27:29.569 --> 01:27:33.649
Now, when you have that story here, if
I turn it into a landscape orientation

01:27:33.649 --> 01:27:39.729
with the accelerometer inside we notice you've sort of the normal
to the earth center has changed on it and we rotate.

01:27:39.729 --> 01:27:41.509
And so now you can read this story.

01:27:41.510 --> 01:27:44.730
it's a bigger font because we make it sort of grow.

01:27:44.729 --> 01:27:51.309
The exact same column you're seeing to fit the
screen, turn it back here, works just like that.

01:27:51.310 --> 01:27:56.440
so again, even things that might look like they'd be hard
to hit like the side you can double tap to zoom it in.

01:27:56.439 --> 01:28:02.399
you could, you know tap on something, it
automatically goes out, loads that in.

01:28:02.399 --> 01:28:06.389
so first of all we think that, you know, most websites

01:28:06.390 --> 01:28:10.740
out there are going to work just great
without any change whatsoever.

01:28:10.739 --> 01:28:14.689
We also support media on here.

01:28:14.689 --> 01:28:20.069
so, let me go ahead and go to the
Pixar website for the Incredibles.

01:28:20.069 --> 01:28:30.119
If I tap on this here it'll actually start
streaming over, if I tap on it here, or maybe not,

01:28:30.119 --> 01:28:33.420
maybe they've taken the trailer down right now.

01:28:33.420 --> 01:28:43.270
There we go, it'll start streaming live this
trailer directly from their website, so,

01:28:43.270 --> 01:28:47.290
again video playing over the web to iPhone.

01:28:47.289 --> 01:28:48.769
( Music )

01:28:48.770 --> 01:28:56.500
Now, just like when you're in the web browser if I turn this
sideways we notice that it automatically play it like this.

01:28:56.500 --> 01:29:00.510
And if I double tap we zoom to full screen.

01:29:00.510 --> 01:29:07.449
( Video playing )

01:29:07.449 --> 01:29:09.829
So I can tap here to bring up controls.

01:29:09.829 --> 01:29:14.519
I can actually grab the scrubber on the top and
I'm moving it so I can move to different part

01:29:14.520 --> 01:29:17.540
in the video, automatically scrubs through it.

01:29:17.539 --> 01:29:19.329
( Video playing )

01:29:19.329 --> 01:29:22.550
Can pause, can play, here are the controls.

01:29:22.550 --> 01:29:22.920
( Video playing )

01:29:22.920 --> 01:29:26.510
Go back to the movie aspect ratio.

01:29:26.510 --> 01:29:40.460
( Video playing )

01:29:40.460 --> 01:29:46.560
Yes we have to play either Disney
or Pixar movies at all demos.

01:29:46.560 --> 01:29:47.920
( Laughter )

01:29:47.920 --> 01:29:53.560
So iPhone supports many media types
and in the graphics and media state

01:29:53.560 --> 01:29:59.030
of the union later today they'll go
into more details on exactly which ones.

01:29:59.029 --> 01:30:02.719
But, basically it's, you know, things
like MP3's or anything that we have,

01:30:02.720 --> 01:30:08.890
hardware decode 4 on the device,
we play back, which is just great.

01:30:08.890 --> 01:30:15.510
So we actually think you can build websites and
web applications taking advantage of media as well.

01:30:15.510 --> 01:30:20.840
( Applause )

01:30:20.840 --> 01:30:22.840
And so the last one, this is the
same one I showed you this morning.

01:30:22.840 --> 01:30:29.710
But let me talk a little bit more about it, which is this
application, which is the Apple directory application.

01:30:29.710 --> 01:30:38.399
So our IS department decided they wanted to front
our LDAP data base in an iPhone specific application.

01:30:38.399 --> 01:30:41.479
Now, they didn't have access
to iPhones at the time.

01:30:41.479 --> 01:30:43.209
We were very strict.

01:30:43.210 --> 01:30:49.380
And so they did it by building application knowing
what the dimensions of the device were in Safari.

01:30:49.380 --> 01:30:51.319
And tested the whole thing in Safari.

01:30:51.319 --> 01:30:56.649
And it wasn't until like the last moment we gave them some
artwork and then they made it good look and feel here.

01:30:56.649 --> 01:31:03.189
But there's a lot you can do just by writing your
website, your web page and testing it in Safari itself.

01:31:03.189 --> 01:31:08.539
So again, if I type like, say a single letter here it
should come back with everyone who has that letter in here.

01:31:08.539 --> 01:31:18.310
I can pick someone, so let's go ahead and pick Kathy,
and it goes out and it grabs that person's card.

01:31:18.310 --> 01:31:25.980
And so, again if you tap on things like phone number
there's a telephone URL it's a Tel colon style anchor

01:31:25.979 --> 01:31:29.389
and that automatically offers to call.

01:31:29.390 --> 01:31:31.320
You can tap it goes ahead and calls.

01:31:31.319 --> 01:31:35.519
So you can add these Tel URL's
directly into your web applications

01:31:35.520 --> 01:31:41.070
and integrate with the services provided by iPhone.

01:31:41.069 --> 01:31:45.059
Again things like email, we have a built in email client.

01:31:45.060 --> 01:31:48.990
And we have these panels, these sheets which will slide up.

01:31:48.989 --> 01:31:50.519
There's a standard email URL.

01:31:50.520 --> 01:31:54.410
So if you imbed that in your web
applications it'll do the same thing.

01:31:54.409 --> 01:32:00.439
We actually do some smart things even with like phone
numbers trying to look to see if you've forgotten what

01:32:00.439 --> 01:32:02.809
to tell URL and turn it into a phone number.

01:32:02.810 --> 01:32:06.970
But the best is if you actually use the standard Tel URL.

01:32:06.970 --> 01:32:11.780
And again, I showed several of these things this morning,

01:32:11.779 --> 01:32:15.649
let me show one more which is the maps
thing, which I think' really, really great.

01:32:15.649 --> 01:32:22.159
The fact that we have Google maps
built into the phone, to the iPhone,

01:32:22.159 --> 01:32:24.979
and so it'll show you exactly where this person is.

01:32:24.979 --> 01:32:26.989
You can go into satellite view.

01:32:26.989 --> 01:32:32.559
You can actually take and you can pinch
and zoom in and out just like that.

01:32:32.560 --> 01:32:35.630
so, we have this nice multi touch display.

01:32:35.630 --> 01:32:40.859
In fact, if you're going to go visit the
person you could even turn on traffic,

01:32:40.859 --> 01:32:43.579
it'll show you what the traffic is around there.

01:32:43.579 --> 01:32:54.140
And so, the ability for you to write a great application
specifically for iPhone we think is going to be huge.

01:32:54.140 --> 01:32:58.829
And really it took, you know less
than a person month for this

01:32:58.829 --> 01:33:02.279
and the person didn't even have
access to the iPhone for a long time.

01:33:02.279 --> 01:33:04.759
And it ended up being less than 600 lines of code.

01:33:04.760 --> 01:33:10.600
So it's going to be really easy to write
really, really powerful applications.

01:33:10.600 --> 01:33:13.030
Here's exact, you know, the same demo here.

01:33:13.029 --> 01:33:21.449
walking through it looks the same on the built in
contacts application as it does on the web one.

01:33:21.449 --> 01:33:23.510
And again you can tap to call.

01:33:23.510 --> 01:33:28.409
( Silence )

01:33:28.409 --> 01:33:36.989
>> Bertrand: So to do that we decided to ally
the simplicity of the Mac with the power of Unix.

01:33:36.989 --> 01:33:43.329
And of course that became the Aqua user interface
and the underpinnings that we have today.

01:33:43.329 --> 01:33:49.829
We also, of course, had the two toolboxes
The Carbon Toolbox as a bridge from the past

01:33:49.829 --> 01:33:54.659
and the Cocoa toolbox for forward developments.

01:33:54.659 --> 01:34:02.949
And, the following few years we spent, we have a lot of
hard work to establish Mac OS X to shape the first version

01:34:02.949 --> 01:34:12.079
of Mac OS X in 2001, and after  that, to
rapidly spread in more breadth and shape other releases

01:34:12.079 --> 01:34:15.149
of Mac OS X, Jaguar, Panther, Tiger.

01:34:15.149 --> 01:34:21.000
and over the last few years with that OS solidly established.

01:34:21.000 --> 01:34:26.529
We've been able to spend more resources
on innovative technologies,

01:34:26.529 --> 01:34:35.439
things like Spotlight, Dashboard,
Core Image, Core Animation.

01:34:35.439 --> 01:34:42.960
And it's very pleasing to see that you have
developed lots of applications that take advantage

01:34:42.960 --> 01:34:47.649
of those technologies, over 20
thousand applications to date.

01:34:47.649 --> 01:34:51.389
And that's both kind of native apps as well as widgets.

01:34:51.390 --> 01:34:56.710
So Mac ecosystem is doing great.

01:34:56.710 --> 01:35:02.649
I really look forward to your next
set of 20,000 applications.

01:35:02.649 --> 01:35:07.229
But you know there's another expanding universe out there.

01:35:07.229 --> 01:35:12.569
And that's the universe of web applications.

01:35:12.569 --> 01:35:21.279
And now, I would like to encourage you not just
to develop a traditional native application

01:35:21.279 --> 01:35:32.449
but also to consider developing a web application that
runs great on the Mac, okay on Windows, and great on the iPhone.

01:35:32.449 --> 01:35:34.510
Hope you've enjoyed the conference thank you.

01:35:34.510 --> 01:35:46.710
( Applause )
WEBVTT

00:00:20.519 --> 00:00:24.989
>> See some familiar faces from the introduction session.

00:00:24.989 --> 00:00:33.140
I'm still Dave Howell, FxPlug engineer and at the
introductory session, we talked about some changes

00:00:33.140 --> 00:00:40.490
that have come out in 1.2.1 and the
previous version, 1.2 point of the FxPlug SDK

00:00:40.490 --> 00:00:47.620
and we showed some examples of how to use those things
and we went over the very basics of the FxPlug SDK

00:00:47.619 --> 00:00:53.419
and in this session we're going to go more in depth
about some topics that people ask about quite a bit

00:00:53.420 --> 00:00:59.750
on our mailing list, which is one of the good reasons
to join the mailing list and ask questions there.

00:00:59.750 --> 00:01:03.869
Because we, we can go search through them at the end of
the year and see what people had a lot of questions about

00:01:03.869 --> 00:01:10.079
and have engineers from the Motion and Final Cut
team come in and explain deeper issues.

00:01:10.079 --> 00:01:12.859
So we'll do some of that today.

00:01:12.859 --> 00:01:20.789
First we'll have somebody talking about porting plug-ins
to FxPlug from the After Effects plug-in architecture

00:01:20.790 --> 00:01:26.500
and then we'll talk about FxPlugs in Final Cut Pro,
particularly how to work with digital video images.

00:01:26.500 --> 00:01:32.000
Some of the issues with fielding
and pixel aspects and so on.

00:01:32.000 --> 00:01:39.790
We'll talk about the new FxTimingAPI for getting
information from the host application about the start times,

00:01:39.790 --> 00:01:48.250
durations, frame rates, field information and so
on, about clips and effects and your time line.

00:01:48.250 --> 00:01:57.079
And also demonstrate dynamic parameter hiding and
showing in response to a change in another parameter.

00:01:57.079 --> 00:02:02.259
So it's a way of setting parameter
state based on another parameter change.

00:02:02.260 --> 00:02:06.780
And we'll show how to use a custom UI based on a nib.

00:02:06.780 --> 00:02:15.550
The examples that we've shipped so far have shown how
to, how to create a very simple NSView sub class,

00:02:15.550 --> 00:02:20.260
programatically and this one will be one that
was created in Interface Builder within nib.

00:02:20.259 --> 00:02:24.219
Then what we'll go through some
advanced topics related to openGL,

00:02:24.219 --> 00:02:28.889
in particular b buffers and shaders
and other things as well.

00:02:28.889 --> 00:02:35.569
So to kick off this, this crazy fun, we've
got Darin Cardani from the Motion team

00:02:35.569 --> 00:02:38.949
to talk about porting plug-ins to FxPlug.

00:02:38.949 --> 00:02:39.519
>> Thanks Dave.

00:02:39.520 --> 00:02:41.110
( applause )

00:02:41.110 --> 00:02:46.860
Hello, I'm Darin Cardani, I'm the third-party
liaison for Motion and just like to talk

00:02:46.860 --> 00:02:49.460
to you today about porting your plug-ins.

00:02:49.460 --> 00:02:56.969
I think it was Steve Ballmer from Microsoft who
said and I'm paraphrasing, developers, developers,

00:02:56.969 --> 00:02:59.009
developers, developers or something like that.

00:02:59.009 --> 00:03:00.859
I forget the exact quote.

00:03:00.860 --> 00:03:04.920
But that's a philosophy that I'm
really trying to get Apple to embrace.

00:03:04.919 --> 00:03:09.289
There are a lot of third party developers
out there who have been wanting to do more

00:03:09.289 --> 00:03:12.139
with the pro apps and hopefully you'll be able to now.

00:03:12.139 --> 00:03:17.309
One of the things I'm going to talk about is the
difference between C-based API's that you might use

00:03:17.310 --> 00:03:23.509
in other applications for writing plug-ins and
the Objective C API's that we have with FxPlug.

00:03:23.509 --> 00:03:29.189
I'll talk specifically about the similarities
between After Effects plug-in API and the FxPlug API

00:03:29.189 --> 00:03:34.579
and then I'll show you how you can write some
code that will work in both applications.

00:03:34.580 --> 00:03:39.920
So with a C-based API, you usually have
a single entry point to your plug-in.

00:03:39.919 --> 00:03:47.269
It's your plug-in main function and it will get passed a
selector which will tell you what function you're supposed

00:03:47.270 --> 00:03:52.750
to perform and that selector's generally
something like a frame setup or a render frame

00:03:52.750 --> 00:03:55.479
and you'll get some pointers to some parameters as well.

00:03:55.479 --> 00:04:04.829
If you want your plug-in to talk back to the host app, what
you generally do is call a function that's in a large block

00:04:04.830 --> 00:04:08.910
of function pointers and request
some data or request a service.

00:04:08.909 --> 00:04:13.090
And we'll talk about how that's a little different.

00:04:13.090 --> 00:04:18.280
You may get passed large blocks of data in your plug-in,
because I mean, it's kind of like going through a straw.

00:04:18.279 --> 00:04:24.109
You have a single main function and you're
trying to do everything from that main function,

00:04:24.110 --> 00:04:27.860
whether it's creating parameters
or rendering a frame or whatever.

00:04:27.860 --> 00:04:32.650
So with Objective-c, your plug-ins will
be written to conform to a protocol.

00:04:32.649 --> 00:04:39.560
And a protocol is similar to well,
I'll get into protocols in a minute.

00:04:39.560 --> 00:04:44.589
But basically, it describes all of the
functions that your plug-in performs

00:04:44.589 --> 00:04:48.759
and so the host application will call your render
method rather than calling a dispatch function

00:04:48.759 --> 00:04:50.839
and sending it a selector telling you to render.

00:04:50.839 --> 00:04:52.609
So it cuts out a little bit of the middle man.

00:04:52.610 --> 00:04:55.310
When you need to talk to the host
application, it's a similar thing.

00:04:55.310 --> 00:05:02.300
You ask for an object which implements a particular
protocol and that protocol can be for say retrieving

00:05:02.300 --> 00:05:07.759
or creating parameters and you simply call the
method you need on that object that's returned.

00:05:07.759 --> 00:05:13.920
So you only have a few objects and pieces of data that
are passed between the plug-in and the host application

00:05:13.920 --> 00:05:20.860
and you don't end up with large blocks of data like in After
Effects, you have your in data and out data structures.

00:05:21.939 --> 00:05:23.459
So what are protocols?

00:05:23.459 --> 00:05:26.180
Protocols are abstract descriptions.

00:05:26.180 --> 00:05:31.790
They're interfaces that describe what your, in
this case, what your filter is supposed to do.

00:05:31.790 --> 00:05:38.689
So they aren't classes in and of themselves, just
descriptions of what, what the class should have

00:05:38.689 --> 00:05:44.740
and they're similar to abstract base classes
in C++ or Java and there are three

00:05:44.740 --> 00:05:47.060
of them that you'll be interested in in FxPlug.

00:05:47.060 --> 00:05:50.629
FxFilter, FxGenerator and FxTransition.

00:05:50.629 --> 00:05:54.750
And the host application will also return
objects to you that implement other protocol

00:05:54.750 --> 00:06:00.730
such as the FxParameter retrieval API for getting
the values of parameters that you've created.

00:06:00.730 --> 00:06:02.680
So here's the FxFilter protocol.

00:06:02.680 --> 00:06:10.280
It inherits from the FxBaseEffect protocol and it
asks you things like what is the output width and height

00:06:10.279 --> 00:06:13.759
of your filter given an image that's a certain size.

00:06:13.759 --> 00:06:18.610
It will tell you to set up any memory
you need for rendering a frame.

00:06:18.610 --> 00:06:22.220
It'll ask you to render the actual
frame and then will ask you to clean

00:06:22.220 --> 00:06:24.820
up anything you set up in your frame set up method.

00:06:24.819 --> 00:06:31.659
So rather than going through this dispatch function
and giving you a get output width selector,

00:06:31.660 --> 00:06:36.600
we'll just simply call your plug-ins, get
output width function or method I should say.

00:06:36.600 --> 00:06:43.510
So there's a lot of similarities between the After
Effects API and the FxPlug API and here are just a few.

00:06:43.509 --> 00:06:50.490
In your After Effects plug-in, the main function will
get sent a selector for setting up your parameters.

00:06:50.490 --> 00:06:55.199
Well in FxPlug we just have the addParameters method.

00:06:55.199 --> 00:07:02.849
For sequence data, you'll get a sequence set up selector
passed to you in After Effects and in the FxPlug API,

00:07:02.850 --> 00:07:06.700
you can just set that stuff up in
your, in it with API Manager method,

00:07:06.699 --> 00:07:11.870
because that's what we call every time
we create an instance of your filter.

00:07:11.870 --> 00:07:16.209
Likewise there's, there's equivalence for
setting up the framer rendering and setting down

00:07:16.209 --> 00:07:18.599
and getting notified when a user changes a parameter.

00:07:18.600 --> 00:07:21.640
If you want some other parameter
to also change at the same time.

00:07:21.639 --> 00:07:27.620
For example, you might have a check box
that enables or disables some sliders.

00:07:27.620 --> 00:07:31.970
Okay, so let's look specifically at adding parameters.

00:07:31.970 --> 00:07:37.250
Something that you're going to do in every plug-in
is set up the parameters that the user can use

00:07:37.250 --> 00:07:41.480
to change the output of their, of your filter.

00:07:41.480 --> 00:07:47.400
So in After Effects, you'd call the PF_ADD_FLOAT_SLIDER
macro and then the PF_ADD_POINT, say

00:07:47.399 --> 00:07:51.199
and then the PF_ADD_COLOR macro
and that would tell the host app

00:07:51.199 --> 00:07:54.659
that you need a slider, a point control and a color control.

00:07:54.660 --> 00:07:59.220
Likewise in FxPlug, we have the Fx parameter retrieval

00:07:59.220 --> 00:08:04.120
or parameter creation API and it
implements similar functionality.

00:08:04.120 --> 00:08:07.030
ADDFloatSlider, addPoint, addColor.

00:08:07.029 --> 00:08:11.789
So what it would be nice to do is to only
have to write your parameter set up code once.

00:08:11.790 --> 00:08:14.800
Because it's going to have the
same controls in both applications.

00:08:14.800 --> 00:08:16.160
So I'm going to show you how to do that.

00:08:16.160 --> 00:08:21.010
I'm going to create a little FxHelper class
or not really class, it's an interface.

00:08:21.009 --> 00:08:26.819
I'm going to write it in straight C, because you
can call straight C from C, from C++,

00:08:26.819 --> 00:08:29.319
from Objective-c and from Objective-C++.

00:08:29.319 --> 00:08:34.120
So it should work with any other host app
that you're likely to be writing for as well,

00:08:34.120 --> 00:08:40.549
because most of them have c interfaces or C++
interfaces and it'll work with Objective-c as well.

00:08:40.549 --> 00:08:47.259
So we'll call the Fx addFloatDlider, FXHAddFloatSlider,
FXHAddPoint and FXHAddColor

00:08:47.259 --> 00:08:51.610
and then you've only written it once
and it works in both applications.

00:08:51.610 --> 00:08:57.120
So we start by creating an interface for the different
functions that we're going to need in both plug-ins.

00:08:57.120 --> 00:09:04.049
In this case, we're going to need something that creates a
slider and then something that gets the value of that slider

00:09:04.049 --> 00:09:11.490
and we pass it as the first parameter, you'll notice
that's a pointer to avoid and it's called add specific.

00:09:11.490 --> 00:09:13.720
This is going to be different in each application.

00:09:13.720 --> 00:09:17.830
In the case of After Effects, this is
going to be the pointer to your pf in data.

00:09:17.830 --> 00:09:21.070
In the case of motion, it's going to be a pointer to an object

00:09:21.070 --> 00:09:27.560
which implements the parameter getting
or setting API or creation API.

00:09:27.559 --> 00:09:30.039
So let's go back for one second here.

00:09:30.039 --> 00:09:34.500
You've have this header and you're going to
include this header in both of your plug-ins.

00:09:34.500 --> 00:09:38.019
Your After Effects plug-in and your FxPlug.

00:09:38.019 --> 00:09:44.169
In After Effects, you're going to write the
implementation of these functions for After Effects,

00:09:44.169 --> 00:09:49.000
I called this AEFxHelpers.c and
it does exactly what you'd expect.

00:09:49.000 --> 00:09:53.250
It casts the add specific pointer to a PF_InData pointer.

00:09:53.250 --> 00:09:58.610
It then creates a parameter def structure, clears
it and calls the PF_ADD_FLOAT_SLIDER macro,

00:09:58.610 --> 00:10:03.810
just like you would have done inline in
your After Effects plug-in in the past.

00:10:03.809 --> 00:10:10.789
Likewise, we make a file called FxPlugFxHelpers.mm
and this is

00:10:10.789 --> 00:10:14.019
where you'll implement the same
functionality for your FxPlug.

00:10:14.019 --> 00:10:16.220
So we've got FXHCreateFloatSlider.

00:10:16.220 --> 00:10:23.090
In this case, the app specific parameter is a pointer to
an object that implements the FxParameterCreationAPI

00:10:23.090 --> 00:10:29.720
and we simply cast it and then call it's addFloatSlider
method and you'll notice we pass mostly the same parameters.

00:10:29.720 --> 00:10:34.660
You have a parameter id, a default value, a
minimum and maximum, slider minimum and maximum.

00:10:34.659 --> 00:10:37.259
If we look back at the After Effects
version, it has the same thing.

00:10:37.259 --> 00:10:42.289
Minimum, maximum, slider min and max and things like that.

00:10:43.559 --> 00:10:53.199
So in this case I'm going to show a simple set up function for
a gamma correction plug-in and basically what I've done is,

00:10:53.200 --> 00:10:58.090
I've taken the standard gamma filter
that ships with the After Effects SDK

00:10:58.090 --> 00:11:00.870
and modified it to work in both applications.

00:11:00.870 --> 00:11:07.490
So in your AE plug-in source, you would have as
the param set up method or function I should say,

00:11:07.490 --> 00:11:16.629
it would simply call SetupGammaParameters and pass it the
in data pointer and then do it's accounting that it needs

00:11:16.629 --> 00:11:19.100
to do for After Effects setting the number of parameters.

00:11:19.100 --> 00:11:25.519
Likewise, in your FxPlug, you'll simply get the
api manager for the FxParameterCreation API object

00:11:25.519 --> 00:11:27.779
and you'll pass that to SetupGammaParameters.

00:11:27.779 --> 00:11:33.329
Now you'll notice, we're calling SetupGammaParameters
from our After Effects plug-in and passing it in data

00:11:33.330 --> 00:11:38.690
and we're calling it again in our FxPlug,
but passing it the parameter API object.

00:11:38.690 --> 00:11:42.310
That's because we've written different
actual functionality for those

00:11:42.309 --> 00:11:46.569
in the different applications,
but the interface is the same.

00:11:46.570 --> 00:11:48.750
So here's, here's our SetupGammaParameters.

00:11:48.750 --> 00:11:53.320
We're actually going to write the set up parameters
once and in this case it just creates a float slider

00:11:53.320 --> 00:11:55.520
and then returns the error, if there was any.

00:11:55.519 --> 00:12:00.689
I've never had an error be returned from creating
a parameter in eight years or writing plug-ins

00:12:00.690 --> 00:12:03.590
but (laughs) I suppose it could happen eventually.

00:12:03.590 --> 00:12:09.379
And this will also be included in both your
After Effects plug-in and your FxPlug.

00:12:09.379 --> 00:12:17.110
And of course, the FXH function is different
in each app, so it calls the correct one.

00:12:17.110 --> 00:12:20.610
So that's, that's a simple way that
you can write functionality once.

00:12:20.610 --> 00:12:27.039
You can do the same thing with your render method to
actually do the processing of the pixels and I've included

00:12:27.039 --> 00:12:34.620
on the attendee website, some sample code that
allows you to take the After Effects example

00:12:34.620 --> 00:12:37.990
and modify it so that it'll run in both applications.

00:12:37.990 --> 00:12:43.310
So basically FxPlug implement one of the
protocols, either filter, generator or transition.

00:12:43.309 --> 00:12:47.739
The methods that you would normally call in a C-based API

00:12:47.740 --> 00:12:53.740
or rather in a C-based API you get passed
selectors and have to dispatch them.

00:12:53.740 --> 00:12:58.230
Whereas Objective-c you'll just write the
methods and the host app will call them.

00:12:58.230 --> 00:13:03.800
And you can write most of your code once and have it
work in both applications, saving you a lot of time.

00:13:03.799 --> 00:13:09.500
With that, I'm going to turn it over to Paul Schneider
and he's going to talk a little bit about Final Cut Pro

00:13:09.500 --> 00:13:12.919
and some specifics of things that
you like to do with FxPlugs.

00:13:12.919 --> 00:13:13.599
Thanks.

00:13:13.600 --> 00:13:16.440
( applause )

00:13:16.440 --> 00:13:19.750
>> Hi, I'm Paul Schneider.

00:13:19.750 --> 00:13:22.179
I'm an engineer at apple working on Final Cut.

00:13:22.179 --> 00:13:25.849
Today I'm going to talk about writing
FxPlugs in Final Cut.

00:13:25.850 --> 00:13:29.560
Like Dave said, I'm going to try to answer
some of the most popular questions

00:13:29.559 --> 00:13:31.479
that people have asked us over the past year.

00:13:31.480 --> 00:13:36.860
I'm going to start off with describing
some common problems that people run

00:13:36.860 --> 00:13:40.180
into when they initially start trying
to run their plug-ins in Final Cut.

00:13:40.179 --> 00:13:47.000
Then I'm going to move on to doing more interesting things
that you can do for the first time in Final Cut 6

00:13:47.000 --> 00:13:52.309
and I'm going to use an example plug-in for
most of my talk and it's going to be part

00:13:52.309 --> 00:13:59.029
of the FxPlug 1.2.1
SDK, which we'll be shipping any day now.

00:13:59.029 --> 00:14:03.009
So the first thing I'm going to talk
about is images in Final Cut.

00:14:03.009 --> 00:14:09.159
One of the things that you have to watch out for when
you're writing a plug-in is that when you're writing a plug

00:14:09.159 --> 00:14:15.799
in on image in Final Cut, you're really processing
the pixels as they come out of the camera or codec

00:14:15.799 --> 00:14:19.139
and as they're going to an external device.

00:14:19.139 --> 00:14:24.100
So if you're used to working with
like with a still image like an rgb,

00:14:24.100 --> 00:14:33.279
jpeg or even another motion graphics application, you
might be surprised by how images look in Final Cut.

00:14:33.279 --> 00:14:37.409
So with digital video images, there is a
couple of things you have to watch out for.

00:14:37.409 --> 00:14:39.959
The first one is that your pixels aren't actually square.

00:14:39.960 --> 00:14:43.960
Your pixels are rectangular, there's
a non 1.0 aspect ratio.

00:14:43.960 --> 00:14:48.769
So you need to generally take that into account
if you're doing any kind of geometric effect.

00:14:48.769 --> 00:14:52.000
The second thing that you need to watch
out for is that the images are interlaced.

00:14:52.000 --> 00:14:57.279
You're going to be processing individual
fields rather than a full progressive frame

00:14:57.279 --> 00:14:59.569
and you need to be aware of that as well.

00:14:59.570 --> 00:15:05.530
The third thing is not specific to video,
but it is specific to Final Cut and Motion.

00:15:05.529 --> 00:15:09.589
We will at times render on a low resolution proxy.

00:15:09.590 --> 00:15:17.450
Which means we'll give you a smaller image than, than
would actually, than you think you're working on.

00:15:17.450 --> 00:15:18.870
An example would be like for playback.

00:15:18.870 --> 00:15:25.580
We might switch down to fifty percent to save time, to
play back faster and then we'll scale the result back

00:15:25.580 --> 00:15:31.240
up to full size just to give the user a
lower quality but higher performance preview.

00:15:31.240 --> 00:15:38.320
So your effect needs to be aware of when we do that and
render accordingly so it doesn't look wrong during playback.

00:15:38.320 --> 00:15:41.940
So the first thing you need to be
aware of is like I said, aspect ratio.

00:15:41.940 --> 00:15:48.860
Your pixels won't be square when they appear on the
computer monitor or on an external NTSC or HD device.

00:15:48.860 --> 00:15:53.460
So when you're rendering a plug-in, you need to
know the aspect ration of your image and you do

00:15:53.460 --> 00:16:00.480
that by asking the FxImage what's your
aspect ratio using the pixel aspect selector.

00:16:00.480 --> 00:16:03.310
The second thing are the single field images.

00:16:03.309 --> 00:16:07.369
This is sort of a difference between Final Cut
and other some other applications.

00:16:07.370 --> 00:16:08.669
Not all other applications.

00:16:08.669 --> 00:16:15.860
You can see here, you know two fields are
interlaced together to create the full frame

00:16:15.860 --> 00:16:23.620
and we will pass you one field at a time because the fields
are actually occurring at slightly different points in time.

00:16:23.620 --> 00:16:27.429
The second field is half a frame past the frame temporarily.

00:16:27.429 --> 00:16:34.539
The other thing to be aware of here is that these
fields are half the height of the full assembled frame.

00:16:34.539 --> 00:16:39.809
Some other packages will stretch the fields
to full height to make it easier to process.

00:16:39.809 --> 00:16:42.489
Final cut does not do that for a couple of reasons.

00:16:42.490 --> 00:16:44.090
One is performance.

00:16:44.090 --> 00:16:47.250
This way you only have to work on half
the data and the second one is actually,

00:16:47.250 --> 00:16:51.850
if you're writing an effect that's aware of video
and wants to do interesting things with the field,

00:16:51.850 --> 00:16:58.899
it's better to have the actual fields available
and not some scaled version of the fields.

00:16:58.899 --> 00:17:03.179
So the first thing you need to do is check to see
if you're doing an interlaced render and you can do

00:17:03.179 --> 00:17:10.700
that by asking the FxImage if it represents a field
and that will return and instance of the FxField enum

00:17:10.700 --> 00:17:16.170
which will either be a lower field, the upper field or
field none, which means this is a progressive frame.

00:17:16.170 --> 00:17:18.120
This image does not represent a field.

00:17:18.119 --> 00:17:22.629
The second thing you need to check is whether
the fields have been stretched to full height

00:17:22.630 --> 00:17:25.680
or if they're acting their native half height.

00:17:25.680 --> 00:17:28.430
And you do that using the FxHost capabilities object.

00:17:28.430 --> 00:17:31.650
This is an object that we added
in the FxPlug 1.1

00:17:31.650 --> 00:17:35.870
that lets you check various capabilities of the host.

00:17:35.869 --> 00:17:39.899
You know, which version of which app you're
running in, which work arounds you might need,

00:17:39.900 --> 00:17:46.090
which bugs have been fixed hopefully and one of the
things that you can check for is this upscales field call.

00:17:46.089 --> 00:17:50.289
So you can ask the host whether it
stretches a single field image to full height

00:17:50.289 --> 00:17:54.420
or whether it keeps it at it's native size.

00:17:54.420 --> 00:17:59.920
So one way that you can account for, oh I'm sorry.

00:17:59.920 --> 00:18:02.810
The third thing you have to watch out
for are the low resolution proxies.

00:18:02.809 --> 00:18:10.299
If we were rendering you on a small image that will actually
be scaled up for display or for performance reasons.

00:18:10.299 --> 00:18:16.549
Final Cut will do this during playback, which means it's
something you have to, especially watch out for because,

00:18:16.549 --> 00:18:19.399
it's not a user selectable thing like it is in Motion.

00:18:19.400 --> 00:18:23.880
When the user hits play in Final Cut, we
will probably drop you down to half quality.

00:18:23.880 --> 00:18:29.950
So you check for this using the render info that we
passed to you when we asked you to render a frame.

00:18:29.950 --> 00:18:34.720
The render info struct contains information
about the current render that we've asked you for

00:18:34.720 --> 00:18:39.110
and part of that is what scale
the rendering is happening at.

00:18:39.109 --> 00:18:46.949
So be prepared for a scale X and scale Y of
say 0.5 for half resolution render.

00:18:46.950 --> 00:18:51.759
Now all three of these things, you can interpret this
information any way that makes sense for your plug-in,

00:18:51.759 --> 00:18:57.519
but all three of these things can be thought of
as just a scale distortion on your rendering.

00:18:57.519 --> 00:19:01.789
So here's a little snippet of code that
sort of handles all three at the same time.

00:19:01.789 --> 00:19:06.420
This is also included in the sample plug-in in
the SDK so, don't worry about writing it down.

00:19:06.420 --> 00:19:13.430
You see here, I want to know how I'm going to scale my render
so it'll look correct when Final Cut displays it and I want

00:19:13.430 --> 00:19:20.810
to scale horizontally by the aspect ratio, I want to check
to see if I'm rendering a half height field and if so,

00:19:20.809 --> 00:19:23.669
I want to scale vertically and then I also want to take

00:19:23.670 --> 00:19:30.740
into account any renderInfo.scale
for the low resolution proxy rendering.

00:19:30.740 --> 00:19:32.019
So now I'm just going to run a demo.

00:19:32.019 --> 00:19:37.579
What I just talked about might be sort of hard
to visualize, but it's actually pretty easy

00:19:37.579 --> 00:19:40.429
to see when you watch it happen in practice.

00:19:40.430 --> 00:19:49.350
So here's this example plug-in called scrolling rich text
and this will be part of the FxPlug 1.2 SDK.

00:19:49.349 --> 00:19:55.730
And what this is, it's a generator
and it just simply draws some text

00:19:55.730 --> 00:19:59.789
and scrolls it up and down as you move through time.

00:19:59.789 --> 00:20:05.349
And you can see down and the bottom
here, I've got three controls to handle,

00:20:05.349 --> 00:20:09.119
aspect ratio, half height fields and render scale.

00:20:09.119 --> 00:20:11.489
In your shipping plug-in, you just
want to handle these all the time,

00:20:11.490 --> 00:20:18.130
but for demonstration purposes I'm actually letting you
see what happens when you don't handle it correctly.

00:20:18.130 --> 00:20:20.080
So the first thing is aspect ratio.

00:20:20.079 --> 00:20:25.449
You can see here, if I ignore the aspect ratio
and I just render as if the pixels are square,

00:20:25.450 --> 00:20:29.870
my text is a little distorted horizontally
and a lot of people miss this.

00:20:29.869 --> 00:20:35.899
Because for the format that a lot of people
use, just DV, the pixels are almost square.

00:20:35.900 --> 00:20:40.690
You can see that that's really not that different
from that and if you just saw one in isolation,

00:20:40.690 --> 00:20:43.720
you might not know which was right and which was wrong.

00:20:43.720 --> 00:20:48.559
What I recommend doing is, testing your
plug-in in an anamorphic sequence.

00:20:48.559 --> 00:20:56.139
That's got a more extreme aspect ratio and you can easily
see you know, whether you're handling it correctly or not.

00:20:56.140 --> 00:21:01.430
So here you see the text is pretty obviously
distorted because I'm ignoring the aspect ratio

00:21:01.430 --> 00:21:06.210
and then if I take the aspect ratio into account,
scale my text to render it appropriately,

00:21:06.210 --> 00:21:09.799
it looks correct even with an extreme aspect ratio.

00:21:09.799 --> 00:21:14.200
The second thing you want to take into
account are these half height fields.

00:21:14.200 --> 00:21:15.490
This one's pretty obvious.

00:21:15.490 --> 00:21:22.980
If I ignore it, my text is twice as high as it should be
and the reason for that is I've drawn it at the full height

00:21:22.980 --> 00:21:27.980
into each field and then the fields were interlaced
together creating an image that's twice as high

00:21:27.980 --> 00:21:30.880
and the text is twice as high as it should be.

00:21:30.880 --> 00:21:36.450
So again, I just want to scale my rendering appropriately
so that when Final Cut interlaces the fields together

00:21:36.450 --> 00:21:39.600
to create the final output, the text looks correct.

00:21:39.599 --> 00:21:42.709
And the last one is the one that's easy to miss.

00:21:42.710 --> 00:21:43.680
Which is the render scale.

00:21:43.680 --> 00:21:48.610
You can see here, if I'm just parked on
a frame, there's actually no difference.

00:21:48.609 --> 00:21:55.819
But if I start playback and I'm not listening to the
render scale, the text looks twice as big during playback

00:21:55.819 --> 00:22:02.179
and the reason is is that Final Cut is actually dropped
down to half resolution in order to play back faster

00:22:02.180 --> 00:22:07.210
and so I'm drawing into a smaller
image but I'm using the same text size

00:22:07.210 --> 00:22:09.410
and then Final Cut scales that image up for display.

00:22:09.410 --> 00:22:15.150
So what I want to do whoa, what I want to
do is pay attention to that render scale

00:22:15.150 --> 00:22:19.410
and then during playback, it looks correct.

00:22:19.410 --> 00:22:27.240
So this is the kind of thing where it's easy to see in
practice, it's hard to imagine when we try to explain it

00:22:27.240 --> 00:22:34.079
in email or documentation but it's pretty obvious what's
going wrong when you actually start writing code.

00:22:34.079 --> 00:22:37.139
Now I just want to talk about the other
interesting things that this plug-in

00:22:37.140 --> 00:22:41.340
in does besides render text correctly in Final Cut.

00:22:41.339 --> 00:22:47.599
You can see that it just draws a line of
text that scrolls as I move through time.

00:22:47.599 --> 00:22:55.279
One nice thing about this plug-in is that the animation
always takes up the full duration of the item in a timeline.

00:22:55.279 --> 00:23:01.299
So if I shrink this item down, make it shorter,
the animation knows that and catches up.

00:23:01.299 --> 00:23:05.549
So on the last frame of the generator, the
text is completely off the top of the frame.

00:23:05.549 --> 00:23:11.940
On the first frame of the generator, the text is completely
off the bottom of the frame and it just interpolates

00:23:11.940 --> 00:23:19.269
in the intermediate frames to draw the right thing and
this will work even if I have more than one line of text.

00:23:19.269 --> 00:23:27.960
So if I just copy and paste this a few times, you can
see that it wraps correctly and it scrolls correctly

00:23:27.960 --> 00:23:32.980
and I'm doing my text rendering using
actually code built into the operating system.

00:23:32.980 --> 00:23:40.620
I'm using a class called NSAttributedString
which is a really nice class that it will take,

00:23:40.619 --> 00:23:45.879
supports a string with various
formats in various ranges of the text.

00:23:45.880 --> 00:23:50.300
So NSAttributedString knows how to draw
itself, it knows how to measure itself,

00:23:50.299 --> 00:23:53.960
it knows how to tell you what area
it will take up when you render it.

00:23:53.960 --> 00:23:57.019
So I didn't have to write any code for all that at all.

00:23:57.019 --> 00:23:59.230
And so I have some you know, fairly simple controls here.

00:23:59.230 --> 00:24:04.870
I can enter a line of text, this is using a basic
string parameter which is built into FxPlug.

00:24:04.869 --> 00:24:08.199
I can make the text bigger or smaller
by changing the attributes.

00:24:08.200 --> 00:24:09.140
I can change the color.

00:24:09.140 --> 00:24:17.320
There's a lot more that I can do with the text and it might
be sort of a pain to provide a different parameter setting

00:24:17.319 --> 00:24:23.329
for each type and there's things like you know, I only get
a single line of text entry here, I would like to be able

00:24:23.329 --> 00:24:28.230
to have a little more control over that
and that's where the custom UI comes in.

00:24:28.230 --> 00:24:34.980
So what I can do is, I can switch from my simple
text entry controls to using an external file on disk

00:24:34.980 --> 00:24:42.970
and when I do this, you'll see that the simple text that it
controls disappear and they're replaced with this custom UI

00:24:42.970 --> 00:24:49.289
which I defined myself and what this will do,
this lets me do, I can just pick any rtf file,

00:24:49.289 --> 00:24:53.180
I happen to have one on disk and then
it'll use that for the text rendering.

00:24:53.180 --> 00:24:58.930
So I've got a huge range, I've got a huge text file here,
not huge, but I've got a fairly lengthy text file here,

00:24:58.930 --> 00:25:01.279
simply more than I could have typed in myself in Final Cut.

00:25:01.279 --> 00:25:09.200
It's got different font characteristics, at different
ranges of text, different colors, different spacing.

00:25:09.200 --> 00:25:15.059
This paragraph is you know, center
justified and if I want to edit this,

00:25:15.059 --> 00:25:19.480
I can use a great text editing facility
that comes with the operating system.

00:25:19.480 --> 00:25:21.900
I'll just open it and TextEdit.

00:25:21.900 --> 00:25:29.009
So I can you know, take this, make the
text a lot bigger, type in some more

00:25:31.220 --> 00:25:36.630
and then just use that as my text editing application.

00:25:37.779 --> 00:25:38.579
So that's pretty nice.

00:25:38.579 --> 00:25:46.369
It didn't take me very long to write this plug-in and I get
very rich text editing capabilities that are already there.

00:25:46.369 --> 00:25:50.939
So let's switch back to the slides
and I'll talk about how I did that.

00:25:53.359 --> 00:25:58.500
So the first thing that you might have noticed is that the
generator actually knew how long it was in the timeline.

00:25:58.500 --> 00:26:03.920
So that it was able to animate correctly and I
used that, I did that using the new FxTiming API,

00:26:03.920 --> 00:26:06.580
which we introduced in FxPlug 1.2.

00:26:06.579 --> 00:26:11.069
I'm just going to talk briefly about the timing API,
we talked about it a bit in this morning's session

00:26:11.069 --> 00:26:13.649
and I'm not going to talk about all the things it does.

00:26:13.650 --> 00:26:15.180
I'm just going to give you a taste.

00:26:15.180 --> 00:26:21.180
So the timing API gives you information
about your effect in the timeline.

00:26:21.180 --> 00:26:25.769
You might want to know the frame rate of the timeline
you're in, you might want to know where your effect starts

00:26:25.769 --> 00:26:32.519
in the timeline and how long your effect is in the
timeline and you can find that out with the timing API.

00:26:32.519 --> 00:26:34.670
It'll also tell you about the effects input.

00:26:34.670 --> 00:26:39.110
So you can get information about different
images that Final Cut is feeding you.

00:26:39.109 --> 00:26:43.119
You might want to know the start time of the clip
you've been applied to, if you're a filter,

00:26:43.119 --> 00:26:45.959
the duration of that clip, the field order of the clip.

00:26:45.960 --> 00:26:52.230
If you've got a mixed format situation where your filter
has been applied to a clip that's got a different frame rate

00:26:52.230 --> 00:26:55.430
or field order than the timeline,
you might want to know that information

00:26:55.430 --> 00:27:00.920
so that you can intelligently do something appropriate
if you're doing a retiming effect or something like that.

00:27:00.920 --> 00:27:04.410
And we also give you facilities to do that.

00:27:04.410 --> 00:27:09.850
If you've got a different frame rate in front
of your input than you do on the timeline,

00:27:09.849 --> 00:27:12.559
we'll let you convert between those different times.

00:27:13.650 --> 00:27:20.330
So this is the concrete example, a very
simple one, here's how I wrote my generator.

00:27:20.329 --> 00:27:27.480
I just used the durationForEffect call, to find out how
long the generator was in the timeline and then I looked

00:27:27.480 --> 00:27:32.110
at the current frame, the frame I'm being asked
to render right now, divide that by the duration

00:27:32.109 --> 00:27:35.049
and that's how far through the generator I am right now.

00:27:35.049 --> 00:27:37.169
So I know how far through my animation I should be.

00:27:37.170 --> 00:27:43.330
The one little gotcha here, I had to subtract one off
the duration because, the renderInfo.frame

00:27:43.329 --> 00:27:46.500
that we passed through the current frame, is zero based.

00:27:48.329 --> 00:27:52.369
The other thing you might have noticed that
happened was when I switched that pop up menu,

00:27:52.369 --> 00:27:58.649
I hid some of my parameters and showed some other
parameters and this is something that's new in Final Cut 6.

00:27:58.650 --> 00:28:00.519
It's pretty straightforward.

00:28:00.519 --> 00:28:04.220
The first thing you want to do is create some of
your parameters hidden by default and you do

00:28:04.220 --> 00:28:07.410
that with the parameterFlag_HIDDEN flag.

00:28:07.410 --> 00:28:10.550
So when you create parameters, you pass them some flags.

00:28:10.549 --> 00:28:18.259
One of the flags is I want this parameter to be hidden
on creation and then the next thing you want to do is hide

00:28:18.259 --> 00:28:23.849
and show parameters in response to another parameter
changing and whenever one of your parameter values changes

00:28:23.849 --> 00:28:27.059
in Final Cut, we'll send you a parameter change message.

00:28:27.059 --> 00:28:33.299
So here you can see, I want to know when the menu changes
so I know if I should hide or show a different parameter.

00:28:33.299 --> 00:28:40.039
So I checked to see if a different parameter that
changed was my hide show menu parameter, if it was,

00:28:40.039 --> 00:28:48.529
I get the new value of the hide show pop up and if the
pop up says I should hide my parameter now, I'll set the,

00:28:48.529 --> 00:28:52.710
I'll set the hidden flag on the parameter, the hide
otherwise I will clear the hidden flag on the parameter

00:28:52.710 --> 00:28:56.660
to hide, which means show this parameter if it's hidden.

00:28:58.750 --> 00:29:01.259
And then the final thing was my custom UI.

00:29:01.259 --> 00:29:04.759
Actually created that in Interface Builder with a nib.

00:29:04.759 --> 00:29:12.759
Now from the beginning of FxPlug, we've let you
create custom user interfaces just be returning an NSView

00:29:12.759 --> 00:29:16.470
and we've always said oh, you know, it's an NSView
so you can create it in Interface Builder.

00:29:16.470 --> 00:29:17.829
You can be as fancy as you want.

00:29:17.829 --> 00:29:24.299
But we've never actually shown you how to do that
before so now we have a sample that shows that off.

00:29:24.299 --> 00:29:29.669
So the first thing I do is in my
nib, I define my plug-in class.

00:29:29.670 --> 00:29:33.880
In this case, my plug-in is implemented
by class called ScrollingRichText.

00:29:33.880 --> 00:29:39.360
So I tell Interface Builder that
a class with that name exists.

00:29:39.359 --> 00:29:45.949
The next thing I do is define some properties for the plug-in
class, so I will create an outlet which is just a pointer

00:29:45.950 --> 00:29:49.870
to the custom UI and I'll create two actions.

00:29:49.869 --> 00:29:53.009
One called chooseTextFile and one called editTextFile.

00:29:53.009 --> 00:29:56.400
If you remember the demo, I had two buttons.

00:29:56.400 --> 00:30:01.550
One to let me choose a file on disk and
one that opens that file up in TextEdit.

00:30:01.549 --> 00:30:04.230
So these correspond to those two buttons.

00:30:05.250 --> 00:30:07.630
And then the next thing I will
do is I'll actually make my UI.

00:30:07.630 --> 00:30:13.080
So I'll create a view in the Interface Builder,
I'll drag in the controls I want from the pallet,

00:30:13.079 --> 00:30:16.460
so there's my choose button, my
edit button and a little static text

00:30:16.460 --> 00:30:22.490
that just displays the name of the file that I've chosen.

00:30:22.490 --> 00:30:25.509
Now this stuff is a little bit tricky,
but what I'll do is I'll make the owner

00:30:25.509 --> 00:30:29.660
of the nib in instance of my plug-in class.

00:30:29.660 --> 00:30:34.519
So in this case, my plug-in class is
called ScrollingRichText, so I'll say,

00:30:34.519 --> 00:30:37.539
this nib is owned by the ScrollingRichText class.

00:30:39.359 --> 00:30:42.099
Once I've done that, I can wire up the connections.

00:30:42.099 --> 00:30:48.619
So, I've got in instance of the ScrollingRichText
class in my nib, so I'll wire up it's outlet,

00:30:48.619 --> 00:30:53.009
it's custom view outlet to the view
that I created and then I'll wire

00:30:53.009 --> 00:30:57.529
up the buttons inside the view to the classes actions.

00:30:57.529 --> 00:31:01.879
So that I'll drag that choose text button to so

00:31:01.880 --> 00:31:07.110
that it fires off the choose text file
action and similarly for the edit button.

00:31:07.109 --> 00:31:08.589
So that's all I do in the nib.

00:31:08.589 --> 00:31:11.079
Now it's time to write some code.

00:31:11.079 --> 00:31:14.189
Here's what my plug-in class looks like.

00:31:14.190 --> 00:31:17.820
It's a generator and it's got the
outlet and the action defined.

00:31:17.819 --> 00:31:20.589
These are the ones that created an Interface Builder.

00:31:22.680 --> 00:31:26.759
Now my next step is I will create the custom parameter.

00:31:26.759 --> 00:31:33.279
So in my add parameters function, I'm going to add a
custom parameter, I'm going to give it a default value

00:31:33.279 --> 00:31:36.000
which in this case is just an empty NSString.

00:31:36.000 --> 00:31:43.529
You recall that custom parameters in FxPlug can
be an instance of any Objective-c class that conforms

00:31:43.529 --> 00:31:49.589
to the NSCoding protocol and that's necessary
for reading and writing your data from a project.

00:31:49.589 --> 00:31:56.009
So in most of our sample code, we will define our own
classes and we'll implement the reading and writing routines

00:31:56.009 --> 00:32:00.849
but it turns out that appKit already provides
you with a whole lot of classes that do this for you.

00:32:00.849 --> 00:32:06.819
So if my needs can be met by an NSString or an
NSData or an NSArray,

00:32:06.819 --> 00:32:09.470
I can just use that class as my custom data type.

00:32:09.470 --> 00:32:12.170
I don't need to write my own class.

00:32:12.170 --> 00:32:19.210
And then the final thing is I would set the custom UI
flag on my parameter, to let the host know that the

00:32:19.210 --> 00:32:22.740
plug-in itself will be creating the
user interface for this parameter.

00:32:23.839 --> 00:32:29.119
And when you set that flag as far as the host calls
you back when it's time to create the user interface.

00:32:29.119 --> 00:32:35.269
So in this case, I'm being asked to
create a view for my custom parameter.

00:32:35.269 --> 00:32:42.879
And this is the really cool part because, all I have
to do is load my nib passing myself as the owner.

00:32:42.880 --> 00:32:49.560
You recall that the owner of the nib is an instance of the
ScrollingRchText class, so I pass in myself as the owner

00:32:49.559 --> 00:32:52.569
and loading the nib wires up my outlets and my actions.

00:32:52.569 --> 00:32:59.289
So after I've loaded the nib, my custom view pointer
points to the NSView that I created in Interface Builder.

00:32:59.289 --> 00:32:59.779
So I'm done.

00:32:59.779 --> 00:33:04.309
I just return that view and it's also
the buttons inside the view are wired

00:33:04.309 --> 00:33:09.119
up to my choose text selectors and my edit text selectors.

00:33:10.470 --> 00:33:12.269
And that's it.

00:33:15.400 --> 00:33:20.450
So I'll just show that one last time in
case you forgot how the plug-in works.

00:33:20.450 --> 00:33:27.370
Here's my pop up, I respond to changes in the
pop up by hiding or showing certain parameters,

00:33:27.369 --> 00:33:33.059
in the more complicated example, I've got my user
interface that I created in Interface Builder,

00:33:33.059 --> 00:33:40.639
this choose button is wired up, this edit button is wired up
and that was literally all the code I had to write to do it.

00:33:42.150 --> 00:33:43.150
So that's it for me.

00:33:43.150 --> 00:33:44.720
I'm going to hand it over to Pete Warden now.

00:33:44.720 --> 00:33:45.799
( applause )

00:33:45.799 --> 00:33:47.289
>> Good job.

00:33:50.799 --> 00:33:59.700
So hi, I'm Pete Warden from the motion team and
one of the biggest problems for plug-in developers,

00:33:59.700 --> 00:34:09.309
one of the biggest questions or set of questions
that comes up on the list is dealing with openGL,

00:34:09.309 --> 00:34:14.269
dealing with some of the advanced
operations that you typically want to do

00:34:14.269 --> 00:34:27.769
when you're implementing image processing filters on the
GPU and we figured for these advanced real world filters,

00:34:27.769 --> 00:34:33.259
often times it's not the individual building blocks
of the problem, but it's time to put it all together

00:34:33.260 --> 00:34:40.320
and the best documentation is very often having a
working piece of sample code that you can refer to

00:34:40.320 --> 00:34:48.480
and use to help you figure out problems on your own
and to illustrate some of the, some of the issues.

00:34:48.480 --> 00:34:59.530
So we actually took one of Motion's internal filters, one
of the shipping filters and tied it up, made it stand alone

00:34:59.530 --> 00:35:05.220
and we're going to be shipping that as
sample code with the 1.2 SDK.

00:35:05.219 --> 00:35:09.819
So this means this is code that's been
pretty heavily through our QA mill,

00:35:09.820 --> 00:35:12.580
it's been optimized as much as we're able.

00:35:12.579 --> 00:35:20.549
So it should be quite useful to refer to and it
shows two issues in particular that come up time

00:35:20.550 --> 00:35:24.170
and time again that are really tricky to deal with.

00:35:24.170 --> 00:35:25.440
Rendering to a texture.

00:35:25.440 --> 00:35:31.639
If you've got a complex filter, you're very
likely to have a graph internally to the filter

00:35:31.639 --> 00:35:37.809
of image processing operations where you need
to pass data from one to another and dealing

00:35:37.809 --> 00:35:46.130
with floating point rendering which is a fairly obscure
area of openGL and isn't documented all that well.

00:35:46.130 --> 00:35:51.460
So this is all going to be in the SDK
which we're going to be shipping shortly.

00:35:51.460 --> 00:35:58.909
Now why is the openGL side of
writing an FxPlug so hard?

00:35:58.909 --> 00:36:05.759
It's fundamentally because openGL
was written to be a 3D rendering API.

00:36:05.760 --> 00:36:09.760
It was written to be geometry processing.

00:36:09.760 --> 00:36:18.730
We've had a lot of success using it for image processing,
but some of the very basic features that are building blocks

00:36:18.730 --> 00:36:29.480
of writing image processing filters, do require some API's
and some parts of openGL that are more arcane,

00:36:29.480 --> 00:36:34.260
more obscure, less world documented
and harder to get information on.

00:36:37.090 --> 00:36:46.910
Rendering to an intermediate image is one of the most
common things for more complex filters to have to do

00:36:46.909 --> 00:36:51.369
where you have operations, where you need
to pass image data from one to another,

00:36:51.369 --> 00:37:00.349
where you're building up from individual pieces,
your rendering graph and your drawing multiple passes

00:37:00.349 --> 00:37:04.179
and on the GPU, it's quite different from the CPU.

00:37:04.179 --> 00:37:06.449
On the CPU all you have are images.

00:37:06.449 --> 00:37:11.449
You can usually access the data directly, you can
read from that data or you can write to that data.

00:37:11.449 --> 00:37:14.489
It's all very orthogonal and it's all very flat.

00:37:14.489 --> 00:37:21.679
Whereas on the GPU, the things that you draw into are very
different beasts than the things that you read data from.

00:37:21.679 --> 00:37:27.079
That's fundamentally part of the design of the GPU,
part of the way that they get their massive speed

00:37:27.079 --> 00:37:33.900
up is they've got a very strict pipeline
about what's input and what's output.

00:37:33.900 --> 00:37:40.460
There's several different ways of
rendering into a texture using the GPU.

00:37:40.460 --> 00:37:44.449
I'm going to be focusing on PBuffers.

00:37:44.449 --> 00:37:51.189
One important thing and probably one of the most crucial
things about PBuffers is that they stay in VRAM.

00:37:51.190 --> 00:37:55.950
If you want to get performance out of the GPU,
you really, really, really need to make sure

00:37:55.949 --> 00:37:59.469
that you're operations are staying
on the GPU as much as possible.

00:37:59.469 --> 00:38:05.159
If you're coming from a CPU-based background, it's
very tempting when you're running into issues,

00:38:05.159 --> 00:38:11.569
to try and do a read back from the card and do
some CPU-based processing and then write it back

00:38:11.570 --> 00:38:15.890
up to the card and that's really death for performance.

00:38:15.889 --> 00:38:25.440
It's very, very bad news because the bus between the
graphics card and the CPU isn't all that fast compared

00:38:25.440 --> 00:38:31.320
to how fast the graphics card can process
and it means that the CPU has to wait

00:38:31.320 --> 00:38:37.820
until the GPU has finished whatever operations it's doing
so you no longer get the parallelism that you'd really like.

00:38:37.820 --> 00:38:46.600
So unlike some of the older techniques of rendering
to a texture, this stays entirely in VRAM.

00:38:46.599 --> 00:38:54.029
Frame buffer objects were introduced fairly recently, we're
modified fairly recently but, they also have this advantage

00:38:54.030 --> 00:38:56.550
and they are nicer in some other ways as well..

00:38:56.550 --> 00:39:05.289
They actually have nicer API and we're using
them in some parts of the Motion engine but,

00:39:05.289 --> 00:39:10.769
since almost all of our filters are still using PBuffers,
we wanted to illustrate the way that we're most familiar

00:39:10.769 --> 00:39:14.380
with and that's still working very well for us.

00:39:15.900 --> 00:39:22.599
So within the code sample itself, this is the
small set of utility functions we actually give you

00:39:22.599 --> 00:39:25.289
for doing common operations with PBuffers.

00:39:25.289 --> 00:39:30.159
The first two hopefully are fairly self
explanatory, you use them to create

00:39:30.159 --> 00:39:34.449
and destroy PBuffers to allocate and deallocate PBuffers.

00:39:34.449 --> 00:39:42.019
I am going to talk about some of the hidden gotchas
next about dealing with allocation and deallocation

00:39:42.019 --> 00:39:46.309
because it isn't as trivial as it might appear.

00:39:46.309 --> 00:39:54.049
When you want to start drawing into a PBuffer, when
you start want to start sending drawing operations

00:39:54.050 --> 00:40:01.580
onto a surface, into a texture, you call PBuffer_Begin
and then subsequently all of your GL calls that you make

00:40:01.579 --> 00:40:08.779
after that will go into the surface
that you set up as a PBuffer.

00:40:08.780 --> 00:40:16.480
It sets the current context, the current geo context
to point to the PBuffer surface that you set up.

00:40:16.480 --> 00:40:21.329
And when you've completed all of your drawing and
you have finished up, you can call PBuffer_End

00:40:21.329 --> 00:40:30.480
and that will finalize all of your drawing operations
and will send any subsequent GL calls back to the surface

00:40:30.480 --> 00:40:34.449
that you were drawing into before you
started drawing into the PBuffer.

00:40:34.449 --> 00:40:41.319
And then finally, when you actually want to use the contents
of that PBuffer, when you want to use what you've drawn

00:40:41.320 --> 00:40:50.620
into that PBuffer as a texture, you call PBuffer_Use and
that's actually very similar to using a normal texture.

00:40:50.619 --> 00:40:59.489
So wherever you'd use Fx texture use or do a GL bind
texture, you can just call this PBuffer_Use command

00:40:59.489 --> 00:41:08.369
and it will make the text unit you got as the active
texture use the contents of that PBuffer that you've drawn

00:41:08.369 --> 00:41:17.980
into as a texture so you can use it in fragment programs
or whatever other drawing operations you're using.

00:41:17.980 --> 00:41:27.800
The allocation issues I talked about are
all based around that fact that allocation

00:41:27.800 --> 00:41:32.789
and deallocation of PBuffers is very, very expensive.

00:41:32.789 --> 00:41:42.579
It's not like on the CPU side where allocating an image
and deallocating and image is normally around the same cost

00:41:42.579 --> 00:41:46.480
as a malloc, a fairly lightweight operation.

00:41:46.480 --> 00:41:49.219
It's a kernel level object.

00:41:49.219 --> 00:41:56.419
It involves a lot of housekeeping on the OS side
and it's generally a very expensive operation.

00:41:56.420 --> 00:42:06.559
So in practice, this means that if you're coming from a
CPU background, you're used to writing render function

00:42:06.559 --> 00:42:12.309
where you would actually allocate any intermediate
images you needed at the start of the render function,

00:42:12.309 --> 00:42:17.840
use them as you do the processing and then at
the end of the render function just delete them.

00:42:17.840 --> 00:42:23.730
That is a very bad pattern to use on
the GPU when you're using PBuffers.

00:42:23.730 --> 00:42:27.420
Because, that means you'll be doing
an allocation and a deallocation

00:42:27.420 --> 00:42:30.519
over PBuffer every single frame that you render.

00:42:30.519 --> 00:42:35.869
Instead, what we recommend and
what the sample code demonstrates,

00:42:35.869 --> 00:42:40.170
is trying to keep PBuffers around as long as you can.

00:42:40.170 --> 00:42:47.380
Trying to create PBuffers at the start of your render
function, use them as before but then at the end

00:42:47.380 --> 00:42:53.880
of the render function, have them stored in
member variables so next time you're called,

00:42:53.880 --> 00:43:00.590
you're actually able to check the size and the bit
depth of those PBuffers that you previously created

00:43:00.590 --> 00:43:06.920
and if they're big enough to reuse,
you've completely skipped the allocation

00:43:06.920 --> 00:43:09.289
and deallocation that you were doing before.

00:43:09.289 --> 00:43:13.860
And this to give you an idea of the
magnitude of the difference this can make,

00:43:13.860 --> 00:43:18.250
we've had plug-ins where we've gone from
four or five frames a second up to thirty

00:43:18.250 --> 00:43:21.489
or forty frames a second, just by making this change.

00:43:21.489 --> 00:43:30.279
So it's a bit of extra housekeeping, it has a bit more
complexity, you do need to make sure that you destroy them

00:43:30.280 --> 00:43:38.740
in your dealloc call so that you don't end up leaking,
but it can make a massive difference to performance.

00:43:38.739 --> 00:43:44.899
So it's highly recommended that you actually do
this to get the best performance out of the GPU.

00:43:46.599 --> 00:43:54.699
Paul talked about using proxy resolution within
Final Cut and the same thing happens within Motion.

00:43:54.699 --> 00:44:01.339
Very often when you're writing simple plug-ins, all
that means is that you have to scale the parameters

00:44:01.340 --> 00:44:05.600
that you're using internally by the resolution.

00:44:05.599 --> 00:44:11.469
Once you're rendering into intermediate images,
one trap that we often fall into ourselves

00:44:11.469 --> 00:44:18.759
and that we've seen third party developers fall into,
is still doing your processing at full resolution,

00:44:18.760 --> 00:44:27.480
even though the input and output are actually a
low resolution and the reason this is a problem is,

00:44:27.480 --> 00:44:32.990
the user has switched or the app has automatically
switched for the user to a lower resolution

00:44:32.989 --> 00:44:36.449
so they can sacrifice quality for performance.

00:44:36.449 --> 00:44:44.699
They expect to see complex projects speed up when
you're actually using proxy resolution scales

00:44:44.699 --> 00:44:51.719
and if your filter isn't respecting that and it's
still processing the same number of pixels internally,

00:44:51.719 --> 00:44:56.189
it's going to be a pretty bad experience for
the user and they're going to have a bad day.

00:44:56.190 --> 00:44:59.639
So just another thing to watch out for.

00:44:59.639 --> 00:45:03.519
Just make sure when you switch to a low
resolution that your filter seems to speed up.

00:45:03.519 --> 00:45:10.159
If it doesn't, have a look at the intermediate images
and see if maybe there's something going wrong with that.

00:45:12.730 --> 00:45:22.389
So the final piece of GL arcana that
I'm going to talk about is floating point.

00:45:22.389 --> 00:45:30.109
Now this is obviously a crucial thing if you're going to be
doing high quality rendering and we actually require filters

00:45:30.110 --> 00:45:36.380
to support on the GPU 16-bit and 32-bit float.

00:45:36.380 --> 00:45:42.430
But this is something that was introduced
pretty recently on consumer graphics cards.

00:45:42.429 --> 00:45:50.500
It's only been the past two or three years that cards have
even begun supporting this at all and for technical reasons,

00:45:50.500 --> 00:46:00.360
there's a couple of capabilities that we take for granted on
the 8-bit side, but very many graphics cards don't support.

00:46:00.360 --> 00:46:05.210
Many of the more modern ones actually
support these two at 16-bit float

00:46:05.210 --> 00:46:09.110
but almost no cards support them at 32-bit float.

00:46:09.110 --> 00:46:18.050
And those two capabilities are bilinear filtering where
you're doing a fetch from a non-integral texture coordinate

00:46:18.050 --> 00:46:23.200
and you're expecting to get the weighted
average of the four neighboring pixels

00:46:23.199 --> 00:46:31.679
and blend mode compositing hardware blending on openGL
where you're actually expecting that the text

00:46:31.679 --> 00:46:35.289
that you're drawing will be combined
with the background that's already there

00:46:35.289 --> 00:46:38.789
and then drawn into the background of the Frame-buffer.

00:46:38.789 --> 00:46:46.179
So both of those don't work on many cards,
just the hardware doesn't support them.

00:46:46.179 --> 00:46:54.750
Unfortunately, there isn't any good API for discovering
if the card that you're running on at the moment

00:46:54.750 --> 00:46:58.679
and the bit fetch that you're running
on at the moment supports these.

00:46:58.679 --> 00:47:05.399
These are always supported 8-bit, but once you enter
float, there isn't a good technique for using this.

00:47:05.400 --> 00:47:13.780
Initially we did try doing our own card id checks which
have all the usually problems of new cards coming out,

00:47:13.780 --> 00:47:18.730
id strings changing and just all the
reasons why that's usually a bad idea.

00:47:18.730 --> 00:47:27.570
So what we ended up doing in Motion is actually
running a test at start up for different bit depths.

00:47:27.570 --> 00:47:34.190
We will run operations that rely on bilinear filtering
and operations that rely on blend mode compositing

00:47:34.190 --> 00:47:41.760
and that should produce known values when they're drawn
into a, into a buffer and then we will read back the pixels

00:47:41.760 --> 00:47:45.660
that were actually drawn to tell
if the operation worked or not.

00:47:45.659 --> 00:47:53.369
Now this is obviously pretty scary stuff, pretty complex to
write yourself so we very strongly recommend that you try

00:47:53.369 --> 00:48:00.089
and avoid relying on these two features
of openGL within your GPU FxPlugs.

00:48:00.090 --> 00:48:04.380
If you can, design your algorithms
so that you don't rely on these.

00:48:04.380 --> 00:48:09.349
It will make life a lot simpler,
it will make life a lot easier.

00:48:09.349 --> 00:48:15.159
If like us, you've already written a
lot of your algorithms to rely on these,

00:48:15.159 --> 00:48:17.190
there are some alternatives that you can use.

00:48:17.190 --> 00:48:25.369
There are some work arounds if you're willing to put in
a bit of extra work and deal with some performance loss.

00:48:25.369 --> 00:48:32.549
The sample that we're going to be shipping, the
directional blur sample actually demonstrates this

00:48:32.550 --> 00:48:34.960
for bilinear filtering.

00:48:34.960 --> 00:48:41.340
We have a fragment program that does
four nearest neighbor texture fetches

00:48:41.340 --> 00:48:46.320
and then does the weighted bilinear filtering internally.

00:48:46.320 --> 00:48:54.620
It looks at the factional part and adds them together and
it's actually was surprisingly tricky at least for us to get

00:48:54.619 --> 00:49:01.920
that right, because of the placing of the center
pixels and a lot of the flawing and stuff.

00:49:01.920 --> 00:49:07.039
So hopefully if you're doing any bilinear
filtering that's going to be useful for you guys.

00:49:07.039 --> 00:49:14.210
It does mean four times as many texture accesses,
so it has a serious impact on performance.

00:49:14.210 --> 00:49:20.010
So that's a good incentive to try and avoid it if you can.

00:49:20.010 --> 00:49:22.490
Blending you can also emulate.

00:49:22.489 --> 00:49:29.719
It wasn't needed for this particular filter
so it's not included in the sample code but,

00:49:29.719 --> 00:49:38.789
the way you do that is you actually take one PBuffer that
you're using as a background and the texture that you want

00:49:38.789 --> 00:49:49.259
to blend over that background, put them both as inputs
into a fragment program and because you cannot read

00:49:49.260 --> 00:49:57.880
from the same PBuffer that you're drawing into,
you actually have to draw into a second PBuffer

00:49:57.880 --> 00:50:06.750
after you combine the two original inputs in
the fragment program and then when you want

00:50:06.750 --> 00:50:11.119
to composite something further, you then ping pong
back from the one you've just drawn into using.

00:50:11.119 --> 00:50:16.839
That is the background into the second PBuffer
and just continue doing operations like that.

00:50:16.840 --> 00:50:24.750
So again, you can probably see, this is a pretty heavyweight
operation compared to the normal hardware openGL blending,

00:50:24.750 --> 00:50:27.730
especially if you're trying to
blend a lot of small triangles.

00:50:27.730 --> 00:50:29.880
It rapidly gets very, very costly.

00:50:29.880 --> 00:50:36.559
So again, if you possibly can, try and avoid
using either blending or bilinear filtering.

00:50:36.559 --> 00:50:42.750
It will take you a lot of time to get right
and it really won't give very good performance.

00:50:42.750 --> 00:50:44.909
And that's it.

00:50:44.909 --> 00:50:49.529
I'm hoping you'll get a chance to look through the
directional blur sample code when it's out there

00:50:49.530 --> 00:50:58.490
with the SDK and you'll be able to send plenty of questions
onto us and I don't know if Dave wants to wrap up.

00:50:58.489 --> 00:50:58.879
Thanks.

00:50:58.880 --> 00:51:00.030
( applause )

00:51:00.030 --> 00:51:02.990
>> (Inaudible) Thanks Pete.

00:51:02.989 --> 00:51:08.219
We saw a few things today.

00:51:08.219 --> 00:51:25.849
We saw a brief overview of the FxPlug features that have
been added and we talked about methods for sharing code

00:51:25.849 --> 00:51:28.750
when you're trying to support more
than one plug-in architecture.

00:51:28.750 --> 00:51:36.559
That's also useful for porting, the concepts in there
are good as a reference when you're porting to FxPlug.

00:51:36.559 --> 00:51:45.389
And we saw examples from the directional blur example
and the rich scrolling, ScrollingRichText example

00:51:45.389 --> 00:51:51.980
and those are both in the plug-in examples
in the new FxPlug SDK which will be uploaded

00:51:51.980 --> 00:51:55.769
to developer connections soon so get to know them.

00:51:55.769 --> 00:51:56.650
There's a lot in them.

00:51:56.650 --> 00:52:02.180
It's worth really kind of stepping through and looking at
all the code in there as you're getting started with FxPlug

00:52:02.179 --> 00:52:04.869
or if you're trying to refresh
your knowledge or move on to some

00:52:04.869 --> 00:52:09.230
to attack some difficult problem
that might be covered in them.

00:52:09.230 --> 00:52:14.480
For more information, please do
join the pro-apps-dev mail list.

00:52:14.480 --> 00:52:23.030
This is an open forum that other plug-in developers can
share their wisdom with you on and on the Apple engineers

00:52:23.030 --> 00:52:28.850
from the Motion and Final Cut team do
frequent this list and share information too.

00:52:28.849 --> 00:52:33.619
If you have a confidential topic to discuss,
you can write to an internal group at Apple,

00:52:33.619 --> 00:52:39.440
the proappsdk@group.apple.com.

00:52:39.440 --> 00:52:45.179
And watch for the 1.2.1 FxPlug SDK.

00:52:45.179 --> 00:52:55.069
The code for sharing on After Effects, sharing your
code with After Effects is up on the attendees site

00:52:55.070 --> 00:53:07.170
on the, on WWDC site, so please look for that.
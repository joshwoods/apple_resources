WEBVTT

00:00:23.210 --> 00:00:24.740
>> I'm Bill Bumgarner.

00:00:24.739 --> 00:00:33.379
I'm manager of Objective-C garbage collection and
generally wrangle the wizards that do the runtime.

00:00:33.380 --> 00:00:37.540
And we've got some pretty cool stuff to cover this morning.

00:00:37.539 --> 00:00:41.729
In particular, we're going to look a little
bit at the history of bridging technologies,

00:00:41.729 --> 00:00:47.339
how we can get to Objective-C from some other
technologies and show you exactly what's in Leopard.

00:00:47.340 --> 00:00:52.340
The map of the components and the content within Leopard.

00:00:52.340 --> 00:00:57.620
We're going to focus on metadata and I'm not
going to go into that right now but you'll see

00:00:57.619 --> 00:01:01.890
that this is the underpinnings of everything
we're doing and we're going to look in detail

00:01:01.890 --> 00:01:04.890
at bridging technologies both how the bridges that we have

00:01:04.890 --> 00:01:07.640
in Leopard are implemented as well
as how you can build your own.

00:01:07.640 --> 00:01:11.510
Then we'll look at some high level support
and then we'll wrap up with a little bit

00:01:11.510 --> 00:01:16.060
of errata, some gnarly unfortunate details.

00:01:16.060 --> 00:01:19.260
And then hopefully have some time for QA.

00:01:19.260 --> 00:01:22.630
So let's dive in.

00:01:22.629 --> 00:01:29.629
So bridges have existed between Objective-C
and other languages for a long time.

00:01:29.629 --> 00:01:31.729
More than two decades.

00:01:32.810 --> 00:01:36.659
Objective-C is a very convenient
language to use because it's so flexible

00:01:36.659 --> 00:01:39.390
so of course people have bent it
to all kinds of different things.

00:01:39.390 --> 00:01:46.049
And in Leopard, what we're doing is integrating
a number of these bridges and providing support

00:01:46.049 --> 00:01:48.590
for additional languages and infrastructure.

00:01:48.590 --> 00:01:53.850
So when we talk about a language bridge,
what are we really talking about?

00:01:53.849 --> 00:01:58.599
Well there's a couple of different
kind of levels of bridging.

00:01:58.599 --> 00:02:03.689
And really it's about enabling one language
to execute code from another language.

00:02:03.689 --> 00:02:10.300
It's not translation, it's literally taking
one language and letting it talk to another.

00:02:10.300 --> 00:02:12.689
They can be one way and still be useful.

00:02:12.689 --> 00:02:17.780
You commonly see this in applications that
have embedded scripting languages of their own.

00:02:17.780 --> 00:02:24.099
You know, go tell the app to do this and the app goes
and does that and doesn't really ever tell anything back.

00:02:24.099 --> 00:02:29.299
They're often very restrictive by design but that's a
feature if you look at Lua and what it's done with World

00:02:29.300 --> 00:02:34.680
of Warcraft and the fact that entire user
interfaces can be built in this network

00:02:34.680 --> 00:02:39.730
to massively multi-player online game without cheating.

00:02:39.729 --> 00:02:42.629
That requires a lot of restrictions.

00:02:42.629 --> 00:02:48.900
So good bridges, and we're really going to focus on
Objective-C because, well, that's kind of at the core

00:02:48.900 --> 00:02:55.080
of Mac OS X. Good bridges allow one
programming language to talk to another.

00:02:55.080 --> 00:02:56.360
That's about it.

00:02:56.360 --> 00:02:59.140
It's powerful but it's pretty limited.

00:02:59.139 --> 00:03:06.239
Moving on a better bridge actually allows
the data to flow between the two languages

00:03:06.240 --> 00:03:09.719
and there's some subtlety there
which we'll get into in a minute.

00:03:09.719 --> 00:03:16.990
Finally the best quality bridges, when we talk about
Mac OS X and we talk about Objective-C are ones

00:03:16.990 --> 00:03:21.640
that allow subclassing of Objective-C
classes with full fidelity.

00:03:21.639 --> 00:03:25.189
And that means support for the
idioms provided by the foundation

00:03:25.189 --> 00:03:30.060
by the Objective-C run time, the
AppKit, Core Data, everything else.

00:03:30.060 --> 00:03:34.990
Key value observing, key value
coding, all these other patterns,

00:03:34.990 --> 00:03:42.250
and provide access to the pure
C APIs that underly the Objective-C.

00:03:42.250 --> 00:03:48.590
So Python and Ruby from the open source communities have
provided us with best quality bridges for quite some time.

00:03:48.590 --> 00:03:57.020
And we have adopted and included both of these into Leopard.

00:03:57.020 --> 00:03:59.950
So why Python and Ruby?

00:03:59.949 --> 00:04:03.459
Well, they're object models, they
are both object-oriented languages

00:04:03.460 --> 00:04:09.629
and they're object models pretty
close to Objective-C, unlike Java.

00:04:09.629 --> 00:04:14.000
Likewise both of these languages are designed
to be embedded in other applications.

00:04:14.000 --> 00:04:15.889
Again that's very different than Java.

00:04:15.889 --> 00:04:20.519
The Java virtual machine really wants to
be an operating system into and of itself.

00:04:20.519 --> 00:04:22.829
It wants things embedded in it.

00:04:22.829 --> 00:04:26.819
It doesn't like being embedded inside say a dot app.

00:04:28.410 --> 00:04:33.740
There's a large demand for better Mac OS X-specific
support in these languages.

00:04:33.740 --> 00:04:35.620
We see these requests all the time.

00:04:35.620 --> 00:04:39.910
Access to more of the Mac-specific APIs from the languages.

00:04:39.910 --> 00:04:44.990
And we see the requests all the time for people
to write user facing that is desktop applications,

00:04:44.990 --> 00:04:49.500
double-clickable, drag-and-droppable applications.

00:04:49.500 --> 00:04:54.490
Plus these languages have huge and growing communities.

00:04:54.490 --> 00:05:01.259
One of the things, I'm friends with some of the people at
O'Reilly and they publish their book numbers and it's kind

00:05:01.259 --> 00:05:05.079
of interesting to see that Python and Ruby
are the two book markets that are growing year

00:05:05.079 --> 00:05:08.199
over year consistently in these languages.

00:05:08.199 --> 00:05:12.920
Whereas some of the other languages are
kind of stagnant if not falling off.

00:05:12.920 --> 00:05:14.160
But that's books.

00:05:14.160 --> 00:05:21.530
When we talk about code there's huge amounts of
reusable open source code available for you to recycle.

00:05:21.529 --> 00:05:27.439
As well, there's often kind of research and
development innovative front-line solutions

00:05:27.439 --> 00:05:33.540
that are becoming available first in these languages
because the productivity of using them is so high.

00:05:33.540 --> 00:05:39.840
And there's already shipping applications
or soon to be shipping.

00:05:39.839 --> 00:05:45.319
In Leopard we see the Calendar Server
which is using Python through PyObjC

00:05:45.319 --> 00:05:50.529
and we also see the Podcast Producer
which is using Ruby and RubyCocoa.

00:05:51.660 --> 00:05:55.080
So when we look back a little bit, look at these bridges.

00:05:55.079 --> 00:05:58.589
There is some history here that's kind of interesting.

00:05:58.589 --> 00:06:03.239
PyObjC was originally created in 1993, it
was actually a part of Python that got thrown

00:06:03.240 --> 00:06:07.389
out about the same time NeXT killed their hardware business.

00:06:07.389 --> 00:06:14.219
Subclassing wasn't added until 2002 which I me ntioned as
being interesting just to emphasize that if you're thinking

00:06:14.220 --> 00:06:17.880
about writing your own bridge, subclassing
is kind of hard but you don't have

00:06:17.879 --> 00:06:20.949
to get there and still have something very powerful.

00:06:20.949 --> 00:06:23.829
This is used in commercial apps
and vertical markets all the time.

00:06:23.829 --> 00:06:26.829
There's trading companies on Wall
Street and on the Chicago Boards

00:06:26.829 --> 00:06:35.629
that are maintaining billion-dollar positions using
Python through PyObjC to Objective-C. RubyCocoa,

00:06:35.629 --> 00:06:39.730
a little bit newer bridge, started in 2001.

00:06:39.730 --> 00:06:47.780
Really took off last year, gained tremendous amounts
of performance, much better quality bridging,

00:06:47.779 --> 00:06:51.909
it's really production quality now, great stuff.

00:06:51.910 --> 00:06:56.370
And it was actually the sandbox for a lot
of the technology we'll talk about today.

00:06:56.370 --> 00:07:01.069
There's been some other bridges, there was a Tcl
bridge, CamelBones is an active development,

00:07:01.069 --> 00:07:08.329
there was a Cobol bridge, Objective
Cobol, don't see much interest in that.

00:07:08.329 --> 00:07:13.629
There's a Lua bridge, there's at least two C#
bridges, there's at least one commercial app shipping

00:07:13.629 --> 00:07:22.199
with a C# Objective-C bridge from Mac OS X.
So really these things do work very, very well.

00:07:22.199 --> 00:07:32.229
And I'd like to ask the Checkout folks to come
up and demonstrate exactly how well they work.

00:07:32.230 --> 00:07:34.870
( Applause )

00:07:34.870 --> 00:07:41.180
>> Thanks, Bill.

00:07:41.180 --> 00:07:45.920
I'm Koen. I'm the head developer
with the Dirk of Checkout.

00:07:45.920 --> 00:07:52.439
We are an Amsterdam-based company, Sofa,
and we, and down there are Jasper and Hugo

00:07:52.439 --> 00:07:58.120
and they provide all the cool Cocoa goodness, the
beautiful artwork we use in Checkout all the time.

00:07:58.120 --> 00:08:03.850
We started Checkout about two years ago. I was
doing a lot of veejay work with Hugo in big clubs,

00:08:03.850 --> 00:08:06.750
and we were using this program which was called Modulate.

00:08:06.750 --> 00:08:12.139
And it shipped with a Python scripting language
to influence all the interface features of it.

00:08:12.139 --> 00:08:14.789
And we started to look into it
and we really, really liked it.

00:08:14.790 --> 00:08:20.920
And at the same moment I was working with
Dirk at a big Apple reseller in Amsterdam

00:08:20.920 --> 00:08:24.720
and they were using a very, very bad point-of-sale system.

00:08:24.720 --> 00:08:27.550
And we looked around for a better
solution and there wasn't any.

00:08:27.550 --> 00:08:30.900
And it wasn't really an exception that theirs was so bad.

00:08:30.899 --> 00:08:33.899
So we decided to try to roll around.

00:08:33.899 --> 00:08:40.009
So combining the knowledge we had about Python and the
PyObjC bridge which we discovered we did that.

00:08:40.009 --> 00:08:45.830
And that turned out to be a great
decision for us because we have seen

00:08:45.830 --> 00:08:50.100
like two big advantages of using
Python for point-of-sale app.

00:08:50.100 --> 00:08:55.600
The first one is that it is a scripting
language so you can develop very fast.

00:08:55.600 --> 00:09:01.480
If you read on the Internet about developing in Python,
a lot of people use it for developing prototypes

00:09:01.480 --> 00:09:07.850
but with these fast Intel Macs and the stability
of Python on the Mac and the PyObjC bridge,

00:09:07.850 --> 00:09:12.070
you can actually ship that prototype
as a full-blown app to your customers

00:09:12.070 --> 00:09:15.720
and they won't even know that it's a scripting language.

00:09:15.720 --> 00:09:20.670
The other big advantages is that there
are lots of major libraries for Python.

00:09:20.669 --> 00:09:27.819
So when we started Checkout two years ago, Core Data, I
don't even know if it existed, but we heard from it.

00:09:27.820 --> 00:09:33.110
But we actually wanted to roll a network-
enabled version of a point-of-sale system.

00:09:33.110 --> 00:09:36.789
So at that moment we looked around and
we discovered a great object library

00:09:36.789 --> 00:09:40.419
which was called SQLObjects and we built our app around it.

00:09:40.419 --> 00:09:42.639
And that worked really well for us.

00:09:42.639 --> 00:09:46.059
And the next version of Checkout
is actually going to be built

00:09:46.059 --> 00:09:51.689
on another object relational mapper
which is called SQLAlchemy.

00:09:51.690 --> 00:09:59.370
Together with PG Boss to control a Postgres server
that shares and advertises over Bonjour and users can log in

00:09:59.370 --> 00:10:03.950
and it's really fun to see that you have all
these cool frameworks you can choose from

00:10:03.950 --> 00:10:08.629
and you can incorporate great functionality
within just a few hours sometimes.

00:10:08.629 --> 00:10:15.009
So we're really excited that Apple is treating Python
programmers now as a first-class citizen on the Mac platform

00:10:15.009 --> 00:10:17.850
and Dirk is going to do a small demo of our app.

00:10:17.850 --> 00:10:18.960
>> Thanks, Koen.

00:10:18.960 --> 00:10:26.360
Okay guys, if you look at this window you
wouldn't really know it's not Objective-C.

00:10:26.360 --> 00:10:30.669
I'm going to start with the example store.

00:10:30.669 --> 00:10:34.509
If you look here, this is all Cocoa code.

00:10:34.509 --> 00:10:37.509
This is our own and a split fuse subclass down here.

00:10:37.509 --> 00:10:41.809
And another one down here if I
can reach it to save the feature.

00:10:41.809 --> 00:10:44.779
So basically I'll show you a little bit of how

00:10:44.779 --> 00:10:48.360
the app works and then we'll point out a
couple of cool things we were able to do thanks

00:10:48.360 --> 00:10:51.560
to all the Python frameworks that are out there.

00:10:51.559 --> 00:11:00.979
So normal users would be, I create an order, direct some
stuff in or double click it or do my instant search here,

00:11:00.980 --> 00:11:08.680
I allocate it, I invoice it, oh, need a
serial number for that product, and I pay it.

00:11:08.679 --> 00:11:13.899
And as you can see these are all
native Cocoa interface elements.

00:11:16.460 --> 00:11:22.879
And some of the cool stuff we have been able to do
thanks to Python is, for instance, we have our our own take

00:11:22.879 --> 00:11:27.370
on bookkeeping, we try to shell out
you know that bookkeeping is fun

00:11:27.370 --> 00:11:29.679
and you should make your accountant happy.

00:11:29.679 --> 00:11:33.549
We're hoping eventually if we say
that, if we repeat that long enough,

00:11:33.549 --> 00:11:38.750
it will eventually become so but we're not quite there yet.

00:11:38.750 --> 00:11:43.950
This export button for instance, it took us more
time to layout you know what this should look

00:11:43.950 --> 00:11:48.440
like than to actually implement the native Excel file support.

00:11:48.440 --> 00:11:52.360
So I'll just save document here.

00:11:53.559 --> 00:11:54.379
There it is.

00:11:54.379 --> 00:11:57.370
And how does that quick look thing work again?

00:11:57.370 --> 00:12:00.519
Oh it's not in Excel, mime type.

00:12:00.519 --> 00:12:07.049
Well, just trust me or download the app yourself, you'll
see it just exports plain simple Excel workbooks

00:12:07.049 --> 00:12:10.199
and it was just an hour to implement or something.

00:12:10.200 --> 00:12:16.020
Some other cool stuff we do also in a
manager interface is we leverage WebKit.

00:12:16.019 --> 00:12:18.870
So we really get the best of both worlds, you know?

00:12:18.870 --> 00:12:24.700
We can use open source Python frameworks where
available, where they're best and we can use,

00:12:24.700 --> 00:12:30.190
you know Apple's Cocoa stuff wherever that works best.

00:12:30.190 --> 00:12:36.130
So I think, yeah, that's it and if you want to see,
test for yourself if it really works like a Cocoa app,

00:12:36.129 --> 00:12:40.610
how fast it is, download it yourself, take a look.

00:12:40.610 --> 00:12:44.200
It's available at Checkoutapp.com
and you'll see that it's really, you know,

00:12:44.200 --> 00:12:47.600
it's just that we're here that you know it's a Python app.

00:12:47.600 --> 00:12:50.620
It's 17,000 lines of code.

00:12:50.620 --> 00:12:51.320
>> Thank you.

00:12:51.320 --> 00:12:52.100
>> Thanks, Bill.

00:12:52.100 --> 00:12:57.440
( Applause )

00:12:57.440 --> 00:13:00.490
>> Let's go to the slides, please.

00:13:00.490 --> 00:13:01.600
Thank you.

00:13:01.600 --> 00:13:02.659
So that's pretty cool.

00:13:02.659 --> 00:13:03.759
That's a Cocoa app.

00:13:03.759 --> 00:13:08.399
I mean you know people sitting down and using that
application don't realize that that's a Cocoa app written

00:13:08.399 --> 00:13:14.299
in Python backed by somewhere around twenty
thousand, a little less, lines of Python code.

00:13:14.299 --> 00:13:19.990
You know, a beautiful look and feel and as they said moving
into version two they're able to leverage all that power

00:13:19.990 --> 00:13:25.470
in the Python open source community
to achieve a velocity of development

00:13:25.470 --> 00:13:32.259
that their competitors using some other traditional
database application development environments simply

00:13:32.259 --> 00:13:33.970
cannot meet.

00:13:35.320 --> 00:13:36.960
So as you've seen the bridge works.

00:13:36.960 --> 00:13:43.009
I mean that's an application shipping on Tiger
today, drag-and-drop install works great.

00:13:43.009 --> 00:13:50.039
The languages, they're easy to learn, the bridges are easy
to use, they're highly productive, powerful, and popular.

00:13:50.039 --> 00:13:54.389
We see lots of activity in both the
RubyCocoa and the PyObjC community.

00:13:54.389 --> 00:13:59.600
There's lots of marketing buzz which ultimately
you know we've got to line our pocketbooks somehow.

00:13:59.600 --> 00:14:03.960
And choosing popular technologies is a good way to do that.

00:14:03.960 --> 00:14:10.019
However there's an added benefit: Lots of
cutting-edge, cool front-line code out there.

00:14:10.019 --> 00:14:15.629
You know, the whole Web 2.0 thing is
all scripting languages.

00:14:15.629 --> 00:14:18.600
Got the shrink-wrap apps already shipping,
there's some other apps on your system

00:14:18.600 --> 00:14:20.899
that you may not know have the bridges in them.

00:14:20.899 --> 00:14:26.399
Adobe Lightroom, for example, has an
Objective-C bridge in it from Lua.

00:14:26.399 --> 00:14:33.129
Talking Panda, the guys that do the really cool little
bartending and language translation dictionaries

00:14:33.129 --> 00:14:36.580
for the iPod, they're installers in Python.

00:14:36.580 --> 00:14:40.500
There's lots of vertical markets, some
of our missile defense researchers

00:14:40.500 --> 00:14:44.440
in the United States are using
Python and PyObjC and RubyCocoa.

00:14:45.899 --> 00:14:49.600
So excellent for prototyping and exploration.

00:14:50.799 --> 00:14:54.289
You can grab these foreign tools, you know we
mentioned a couple of them but there's also,

00:14:54.289 --> 00:14:59.169
there's like Twisted which is this amazing, it's
like the app kit for network programming for Python.

00:14:59.169 --> 00:14:59.949
It's just amazing.

00:14:59.950 --> 00:15:04.350
It can be integrated straight into
Cocoa apps so that network events show

00:15:04.350 --> 00:15:07.460
up in the event queue just like mouse events.

00:15:07.460 --> 00:15:12.960
There's Rails from the Ruby community which is a
huge number of different very flexible packages

00:15:12.960 --> 00:15:16.680
and cutting-edge technologies that you can easily integrate.

00:15:16.679 --> 00:15:22.139
So if all these things exist why
are we changing them in Leopard?

00:15:22.139 --> 00:15:27.389
Well, so all the bridges using Objective-C runtime metadata.

00:15:27.389 --> 00:15:35.620
But when that metadata was put together
twenty plus years ago, it wasn't complete.

00:15:35.620 --> 00:15:39.950
There's not enough information
there to do full fidelity bridging.

00:15:39.950 --> 00:15:43.770
In particular you end up having a
lot of hard wired special sauce.

00:15:43.769 --> 00:15:50.370
You got all these things like methods that return Booleans
which the Objective-C runtime says is a character.

00:15:50.370 --> 00:15:51.970
Ruby doesn't like that.

00:15:51.970 --> 00:15:53.700
You've got things like NSErrorPointer pointers.

00:15:53.700 --> 00:15:54.690
Is that going in?

00:15:54.690 --> 00:15:55.500
Going out?

00:15:55.500 --> 00:15:57.860
In, out? Who knows?

00:15:57.860 --> 00:15:59.310
Things like static inlines.

00:15:59.309 --> 00:16:03.529
These only show up a compiled time along with sharp defines.

00:16:03.529 --> 00:16:06.909
Critical pieces of information
for your development experience.

00:16:06.909 --> 00:16:10.699
Not available outside of the compiled environment.

00:16:10.700 --> 00:16:13.100
There's also things like the external references.

00:16:13.100 --> 00:16:20.409
Symbolic references that, global variables
that are very critical to controlling Cocoa.

00:16:20.409 --> 00:16:27.620
And the bridges also tend to expose everything kind
of equally so you'll have things like private API,

00:16:27.620 --> 00:16:32.870
internal API, stuff that was researched that just
got left in the binary, should never be touched.

00:16:32.870 --> 00:16:36.009
It's all bubbled up at the same kind of level.

00:16:36.009 --> 00:16:40.980
And we've seen cases in the, like the PyObjC mailing list
where someone goes off and they call some random method

00:16:40.980 --> 00:16:43.620
and everything blows up, and like, oh, why doesn't that work?

00:16:43.620 --> 00:16:47.399
Well, that method is not supposed to exist.

00:16:47.399 --> 00:16:52.139
And a lot of the stuff has to be
reinvented across each bridge.

00:16:52.139 --> 00:16:56.019
New languages start from scratch or they
start by downloading PyObjC or RubyCocoa

00:16:56.019 --> 00:17:00.850
as the two most mature bridges and then they
go through all the same trials and tribulations

00:17:00.850 --> 00:17:04.190
that these bridges have already gone through.

00:17:04.190 --> 00:17:09.910
So fixing all of this is critical if we want to build
an environment where we can support Cocoa developers

00:17:09.910 --> 00:17:14.160
in these scripting languages for the long
term as well as building a foundation

00:17:14.160 --> 00:17:17.110
for further integration with Objective-C.

00:17:18.200 --> 00:17:22.840
So the solution to this is what
we call metadata-driven bridging.

00:17:22.839 --> 00:17:27.709
That is to provide metadata like the
Objective-C runtime but externally

00:17:27.710 --> 00:17:32.350
that describes everything needed
to do this level of integration.

00:17:32.349 --> 00:17:39.849
It needs to be machine parseable
but human readable is preferable as well.

00:17:39.849 --> 00:17:45.199
More than just the Objective-C APIs is required, you've
got to get all that other detailed stuff that gets passed

00:17:45.200 --> 00:17:48.450
through that Objective-C APIs if you
really want to have full fidelity bridging.

00:17:48.450 --> 00:17:54.660
It needs to be included with the system frameworks,
this is something that because scripting languages are

00:17:54.660 --> 00:18:01.660
so dynamic interpreted on the fly on the user
system, we can't require development tools.

00:18:01.660 --> 00:18:06.340
And you've got to cover the pure C API's because there's
a tremendous number of very important pure C APIs

00:18:06.339 --> 00:18:10.169
in the system, FSEvents, things like that.

00:18:11.259 --> 00:18:18.190
It has to include constants, #defines, type
def enums, structures, definitions, functions,

00:18:18.190 --> 00:18:22.930
class-specific exceptions, inlines, you name it.

00:18:22.930 --> 00:18:29.960
Which means it also needs to have some mechanism via
which you can dynamically load a little bit of glue if required.

00:18:29.960 --> 00:18:31.519
And we've done that, exactly that.

00:18:31.519 --> 00:18:34.470
And actually it was developed in
the BridgeSupport project as a part

00:18:34.470 --> 00:18:38.279
of RubyCocoa and it's available in MacOSXForge.

00:18:38.279 --> 00:18:43.379
It works on Tiger as kind of a preview
state, none of the metadata is included

00:18:43.380 --> 00:18:45.090
with it but you can go generate it yourself.

00:18:45.089 --> 00:18:48.139
And the RubyCocoa bridge is using that on Tiger as well.

00:18:48.140 --> 00:18:53.600
So we've made some promises at WWDC 2006.

00:18:53.599 --> 00:19:00.969
We said we'd have Ruby and Python support, we'd have
some limited Xcode support, limited framework support,

00:19:00.970 --> 00:19:03.670
and we'd have some metadata to
describe the frameworks we were going

00:19:03.670 --> 00:19:08.110
to support which was AppKit, Core Data, Foundation.

00:19:08.109 --> 00:19:15.009
We're delivering in the seed that you got this week
as well as in Leopard the Ruby and Python support.

00:19:15.009 --> 00:19:16.490
Solid Xcode support.

00:19:16.490 --> 00:19:18.359
It's not complete but it's much better.

00:19:18.359 --> 00:19:22.509
You'll see syntax coloring and code sense.

00:19:22.509 --> 00:19:28.129
Lots of frameworks and APIs are supported
with metadatas and tools to support non-Apple.

00:19:28.130 --> 00:19:32.210
And by lots of frameworks, I mean, lots of frameworks.

00:19:35.240 --> 00:19:36.339
So.

00:19:36.339 --> 00:19:44.919
( Applause )

00:19:44.920 --> 00:19:48.460
>> We pretty much have metadata generated
for most of the APIs on the system.

00:19:48.460 --> 00:19:55.730
There's some C++ APIs that, trying
to describe that is difficult.

00:19:55.730 --> 00:20:00.390
And we also have tools such that you can
easily provide metadata for your own code.

00:20:00.390 --> 00:20:05.400
( Applause )

00:20:05.400 --> 00:20:07.950
>> But there's some more stuff too.

00:20:07.950 --> 00:20:13.330
So Perl, the CamelBones bridge, that's
under active development in the community.

00:20:13.329 --> 00:20:17.139
F-Script anywhere is going to be
using BridgeSupport in Leopard.

00:20:17.140 --> 00:20:18.150
( Applause )

00:20:18.150 --> 00:20:23.320
Yeah, they won an Apple design award
last year if I remember correctly.

00:20:23.319 --> 00:20:28.149
There's full metadata, so it's not just the
metadata that's missing from the Objective-C runtime

00:20:28.150 --> 00:20:34.110
but it's actually the full metadata that's described
in these files, which we'll show you in a second.

00:20:34.109 --> 00:20:38.339
Which means this stuff can be used
well beyond just bridging languages.

00:20:38.339 --> 00:20:42.759
You now have a machine-readable description
of a lot of the APIs in the system

00:20:42.759 --> 00:20:46.900
and the ability to generate that description for more.

00:20:49.519 --> 00:20:56.069
There's mechanisms for generating your metadata for the
new APIs that can be integrated into Xcode's build system.

00:20:56.069 --> 00:21:02.099
So it's easy to add a build phase, it
generates the stuff on the fly if you want.

00:21:02.099 --> 00:21:08.679
It's fully documented, including an XML DTD. It is XML.

00:21:08.680 --> 00:21:13.509
And there's full 64-bit support so the
underpinnings lib   FFI as well

00:21:13.509 --> 00:21:17.140
as the bridges have been supported to 64-bit.

00:21:17.140 --> 00:21:19.790
You've even had some testing.

00:21:19.789 --> 00:21:28.899
So when we look at Leopard, this is what the
map of how the stuff fits together looks like.

00:21:28.900 --> 00:21:33.120
So you've got the Python and the Ruby bridges included.

00:21:33.119 --> 00:21:41.859
Perl, F-Script, Lua are coming from third parties, the
double arrows are supposed to mean metadata but it turns

00:21:41.859 --> 00:21:47.009
out by the time between when this
slide was produced and now F-Script

00:21:47.009 --> 00:21:50.799
and Lua have started using the bridge
supporters, starting investigating that.

00:21:50.799 --> 00:21:53.789
So you know, this community moves quickly.

00:21:53.789 --> 00:21:59.079
There's another technology in Leopard called the
ScriptingBridge which I'll talk about in a minute,

00:21:59.079 --> 00:22:04.220
that's a bridge to Apple events from
Objective-C which plays into this quite nicely.

00:22:04.220 --> 00:22:11.120
And then, of course, Objective-C is what most
of the system frameworks are implemented in.

00:22:12.880 --> 00:22:19.480
So the ScriptingBridge I want to talk about that for just
a second because it kind of completes the picture here.

00:22:19.480 --> 00:22:23.860
The ScriptingBridge, if you went to the session that
covered it, I think it was the App Scriptability session,

00:22:23.859 --> 00:22:28.549
it's a bridge, the bridge is between
Objective-C and Apple events.

00:22:28.549 --> 00:22:34.720
Basically it lets you treat any application on your
system that's scriptable like it's an Objective-C object.

00:22:34.720 --> 00:22:40.759
So you can statically generate Objective-C code,
like for example, this chunk of code is almost all

00:22:40.759 --> 00:22:44.700
of what you would need to play a random track from iTunes,

00:22:44.700 --> 00:22:49.740
treat iTunes like an Objective-C
object, talk to it, play a track.

00:22:49.740 --> 00:22:54.279
Which means you can use it from
anything to bridge to Objective-C.

00:22:54.279 --> 00:22:59.500
It can be used from any language
it's already bridged to Objective-C.

00:22:59.500 --> 00:23:05.019
Or the ScriptingBridge can now
dynamically generate classes at runtime

00:23:05.019 --> 00:23:09.970
which means you can do the bridging
without requiring any compilation.

00:23:09.970 --> 00:23:15.569
So it means you can drop into the Python interpreter
or into the Ruby interpreter and talk with applications

00:23:15.569 --> 00:23:18.039
on your system on a user system, no dev tools.

00:23:18.039 --> 00:23:19.139
( Applause )

00:23:19.140 --> 00:23:19.650
>> That's pretty cool.

00:23:19.650 --> 00:23:28.590
So let me show you how that works,
assuming my machine wakes up.

00:23:32.569 --> 00:23:34.480
It does, yay.

00:23:38.269 --> 00:23:40.680
Excellent, gigantic terminal window.

00:23:40.680 --> 00:23:43.150
You always know it's going to be an exciting demo then.

00:23:43.150 --> 00:23:45.700
( Laughter )

00:23:45.700 --> 00:23:53.370
>> So let me go ahead and bring up the Ruby interpreter
and I've got a little cheat app so you don't have

00:23:53.369 --> 00:23:55.989
to watch me type and correct my mistakes.

00:23:55.990 --> 00:23:59.130
I'm going to go ahead and import the
different components required to bring

00:23:59.130 --> 00:24:05.220
up the RubyCocoa bridge including a couple of
extra lines that I see Laurent not liking.

00:24:05.220 --> 00:24:09.400
But it's actually simpler than this.

00:24:09.400 --> 00:24:14.480
And then once I've got that up, I've
brought in the ScriptingBridge framework,

00:24:14.480 --> 00:24:20.700
now I'm going to create the class object for iTunes.

00:24:20.700 --> 00:24:25.819
We've actually dynamically generated an
Objective-C class for the iTunes application

00:24:25.819 --> 00:24:31.679
and now the RubyCocoa bridge has created a
proxy to that class sitting in the Ruby runtime.

00:24:31.680 --> 00:24:35.600
And we've actually created an instance of the iTunes class.

00:24:38.180 --> 00:24:46.410
So once we've got that, let's go and dump the contents
of my library and this is where my manager cringes.

00:24:46.410 --> 00:24:48.769
So it's very safe though.

00:24:48.769 --> 00:24:55.819
So you can see what we've actually done here is
messaged into iTunes, grabbed a list of all the sources,

00:24:55.819 --> 00:24:59.200
grabbed all the playlists, dumped all the contents, etc.

00:24:59.200 --> 00:25:03.009
If I had sound on this machine and the RA double A approval

00:25:03.009 --> 00:25:06.289
to play this stuff I could play it
and control the volume, etc.

00:25:06.289 --> 00:25:08.519
So that's pretty cool.

00:25:09.730 --> 00:25:19.490
So one of the other features of the bridges is
that they, the Python and the Ruby bridges try

00:25:19.490 --> 00:25:23.599
to actually meld the object models of the two languages.

00:25:23.599 --> 00:25:27.250
So and we'll get into this in a
little more detail in a moment.

00:25:27.250 --> 00:25:32.839
So what this means though is let's bring
up Python and what we can do here,

00:25:32.839 --> 00:25:35.319
is we'll go ahead and bring in the Foundation.

00:25:35.319 --> 00:25:45.769
And once we get the Foundation in then we will create a
subclass, pretty straightforward, we're just creating a subclass

00:25:45.769 --> 00:25:48.549
and then this object overrides the description method

00:25:48.549 --> 00:25:53.599
so when I start messaging it you can tell
it's something other than an NSObject.

00:25:53.599 --> 00:25:58.569
We'll create a couple of objects, in this
case we're instantiating one instance

00:25:58.569 --> 00:26:08.159
of our foo class, we're instantiating another instance of
NSObject, make my font a little bigger, then we will go ahead

00:26:08.160 --> 00:26:13.759
and print out the descriptions so you can
see standard Objective-C messaging works,

00:26:13.759 --> 00:26:18.539
doesn't matter if it's the Python
subclass or standard Objective-C.

00:26:18.539 --> 00:26:24.109
Let's go ahead and define a function, a simple function,

00:26:24.109 --> 00:26:29.969
takes one argument that doesn't use it
and just returns a string called howdy.

00:26:29.970 --> 00:26:33.400
But let's do something interesting with it.

00:26:33.400 --> 00:26:37.800
I'm assigning a function to NSObject.description.

00:26:37.799 --> 00:26:45.409
Which means that what I've actually
done is replace the implementation

00:26:45.410 --> 00:26:49.029
of Objective-C method with a pure Python function.

00:26:49.029 --> 00:26:50.690
So that's...

00:26:50.690 --> 00:26:54.650
( Applause )

00:26:54.650 --> 00:26:56.430
>> Then go back to slides please.

00:26:56.430 --> 00:27:01.990
So that's the level of intimacy of bridging that
we're talking about here in best-of-breed bridging.

00:27:01.990 --> 00:27:06.009
So let's look at this code again, just briefly here.

00:27:07.240 --> 00:27:09.420
It's kind of like Objective-C in a lot of ways.

00:27:09.420 --> 00:27:15.410
You see things like, okay, we've got to go and we've got
to grab the different interfaces for what we need to use,

00:27:15.410 --> 00:27:23.130
kind of like a pound import only we don't have a link phase
so this is also linking it effectively into our runtime.

00:27:23.130 --> 00:27:27.690
Then we need to figure out what
we're going to go and talk to.

00:27:27.690 --> 00:27:30.900
So in this case we're getting classForApplicationWithBundleIdentifier

00:27:30.900 --> 00:27:34.019
which is a ScriptingBridge thing to generate that class.

00:27:34.019 --> 00:27:34.920
Pretty straightforward.

00:27:34.920 --> 00:27:41.690
And then you'll see here we're doing some Ruby
construction you'll see that we're actually

00:27:41.690 --> 00:27:49.720
like if you say app.sources.each that's actually
an Objective-C method followed by a Ruby method.

00:27:49.720 --> 00:27:51.890
And then followed by Ruby block.

00:27:51.890 --> 00:27:54.980
We're looping through and printing some stuff out.

00:27:54.980 --> 00:28:00.849
Similarly on the Python example there, include in link.

00:28:00.849 --> 00:28:03.099
Define a class.

00:28:03.099 --> 00:28:04.079
Declare a method.

00:28:04.079 --> 00:28:08.259
Print some stuff out, return the string, etc.

00:28:08.259 --> 00:28:14.150
You see here this is another example of where,
even though we have an Objective-C class,

00:28:14.150 --> 00:28:17.040
that actually supports single inheritance
because we're in Python

00:28:17.039 --> 00:28:19.819
that does have limited support for multiple inheritance.

00:28:19.819 --> 00:28:23.129
Our super invocation reflects that.

00:28:23.130 --> 00:28:26.650
So we've got kind of the best of both worlds there.

00:28:26.650 --> 00:28:31.250
Creating instances, both the bridges, you don't
really have to do retain, release, autorelease

00:28:31.250 --> 00:28:33.329
because the underlying languages are ref counted.

00:28:33.329 --> 00:28:36.619
It's kind of like garbage collection but not really.

00:28:36.619 --> 00:28:40.639
But generally you just don't have to think about it.

00:28:40.640 --> 00:28:41.940
Invoking methods.

00:28:41.940 --> 00:28:44.490
Sure, that just works.

00:28:44.490 --> 00:28:48.490
We can define functions, of course, and then
we can plug those functions in, in Python.

00:28:48.490 --> 00:28:51.359
Python treats methods as first-class objects.

00:28:51.359 --> 00:28:57.750
So you can edit class implementations by simply
replacing the method objects in the class implementation.

00:28:57.750 --> 00:28:59.640
That has been proxied to NSObject.

00:28:59.640 --> 00:29:04.270
There's some gnarly code under the hood that
takes care of this but it's all public API.

00:29:04.269 --> 00:29:09.450
My team insisted I say that.

00:29:09.450 --> 00:29:15.980
Then we can, of course, message those and you'll see you know
just like any other Objective-C thing you override a method

00:29:15.980 --> 00:29:19.559
and sure enough you get the new implementation.

00:29:19.559 --> 00:29:26.609
So when we're talking about bridging the good,
better, best model actually works very, very well.

00:29:26.609 --> 00:29:34.299
A good bridge, let you find that target, let you import
that library, link against it, bring it into your runtime.

00:29:34.299 --> 00:29:36.589
And then allows you to message it.

00:29:36.589 --> 00:29:40.059
In this case we're going and we're grabbing the main bundle.

00:29:41.180 --> 00:29:43.330
And then allows you to call a method.

00:29:43.329 --> 00:29:45.199
Now this is important here.

00:29:45.200 --> 00:29:48.289
As you see I've got a method that takes multiple arguments.

00:29:48.289 --> 00:29:53.339
And I didn't put up both the Python and the Ruby code here
because it's effectively the same. I mean there's some idioms

00:29:53.339 --> 00:29:57.409
for shortening this in either language
which I'll show you in a second.

00:29:57.410 --> 00:30:04.590
But pathsForResourcesOfType_inDirectory, that's a method on NSBundle.

00:30:04.589 --> 00:30:05.500
Takes two arguments.

00:30:05.500 --> 00:30:12.529
Normally in the Objective-C syntax it would all be nicely
interleaved with the arguments in the method name, etc.

00:30:12.529 --> 00:30:20.660
In the scripting languages, do we have
one simple rule for invoking methods?

00:30:20.660 --> 00:30:24.370
Because the scripting languages have
kind of a functional invocation.

00:30:24.369 --> 00:30:33.449
You take the method name, everywhere there's a colon
substitute an underbar including that last one.

00:30:33.450 --> 00:30:39.700
There's no ambiguity, there's no exceptions, there's no
mapping magic which is what the Java bridge did and it ended

00:30:39.700 --> 00:30:42.039
up with an API that didn't look like Cocoa or Java.

00:30:42.039 --> 00:30:45.490
And there's no special cases needed.

00:30:45.490 --> 00:30:49.710
One simple rule and you can talk to any Objective-C object.

00:30:51.809 --> 00:30:55.549
Better bridges though allow sharing
of data with Objective-C.

00:30:55.549 --> 00:31:01.490
In particular, when we talk about languages it's
pretty much useless to talk about the language

00:31:01.490 --> 00:31:07.839
from a getting-things-done perspective and not
talk about the libraries you're going to be using.

00:31:07.839 --> 00:31:13.740
And when you use Python or when you use Objective-C
it's pretty much impossible to write a piece of code

00:31:13.740 --> 00:31:19.349
that doesn't have at least one NSArray and one NSString
or one string and one array or whatever.

00:31:19.349 --> 00:31:22.259
You just don't think that way.

00:31:22.259 --> 00:31:27.150
And every language has this same set of objects:
the strings, the arrays, the dictionaries,

00:31:27.150 --> 00:31:31.190
the things like that, that are almost the same.

00:31:31.190 --> 00:31:36.090
Except for when they aren't for
implementation details the language.

00:31:36.089 --> 00:31:43.309
Conversion across a bridge of these types is tedious,
it's repetitive, and it's extremely error prone.

00:31:43.309 --> 00:31:49.700
It's very difficult to get the impedance
match correct between these various languages.

00:31:49.700 --> 00:31:56.789
So the bridges convert the types they
can automatically, mostly correctly.

00:31:56.789 --> 00:32:02.549
There's a few situations where it can't be done
quite automatically and this is an example of one.

00:32:02.549 --> 00:32:07.730
This little body of code, I'm not going to go into
too much detail on it, but it's actually has a bunch

00:32:07.730 --> 00:32:09.480
of interesting things that it's demonstrating.

00:32:09.480 --> 00:32:14.759
For one you see we're going and we're getting the pathsForResourcesOfType_inDirectory but we have to do

00:32:14.759 --> 00:32:18.690
through so this weird PyObjC underscore class methods thing,

00:32:18.690 --> 00:32:22.910
Python doesn't have class methods,
Objective-C does, so we bridge it that way.

00:32:22.910 --> 00:32:30.940
Once we get that array back, we're using actually
standard Python enumeration to enumerate an NSArray.

00:32:30.940 --> 00:32:34.779
So now NSArrays and Python arrays are interchangeable.

00:32:34.779 --> 00:32:38.069
Same thing you saw earlier with RubyCocoa.

00:32:38.069 --> 00:32:46.220
We can then go and read the data just by simply using
that little line of Python, to get the file, read it,

00:32:46.220 --> 00:32:52.539
that gets us a Python string object back because Python
strings can have arbitrary hunks of data in them.

00:32:52.539 --> 00:32:54.799
Which is why we need to convert it to a buffer.

00:32:54.799 --> 00:32:57.190
Which is just a bag of bytes.

00:32:57.190 --> 00:33:02.269
And the bridge actually knows the difference between the
string and a bag of bytes and if we throw the bag of bytes

00:33:02.269 --> 00:33:05.289
at NSImage.initWithData, we get an image object.

00:33:05.289 --> 00:33:13.279
And then we can do some printouts and stuff about the image
object and you'll see in the bestRepresentationForDevice,

00:33:13.279 --> 00:33:18.990
the second to last code there with the line of
code, we're passing, it wants an NSDictionary.

00:33:18.990 --> 00:33:22.470
But we're actually just creating
an inline Python dictionary.

00:33:22.470 --> 00:33:24.360
There's actually two interesting things going on there.

00:33:24.359 --> 00:33:29.589
One, so we've got a Python dictionary interchangeable
with an NSDictionary, that's pretty cool,

00:33:29.589 --> 00:33:38.039
the second thing is that number two the bridge automatically
sees that and turns it into the appropriate NS number.

00:33:38.039 --> 00:33:43.349
So we've got bridging of scaler types
too in the context where they need it.

00:33:43.349 --> 00:33:47.669
So end result, you can pretty fluidly
write code without having

00:33:47.670 --> 00:33:53.529
to consider this stuff too much and
the bridges will just deal with it.

00:33:53.529 --> 00:33:58.170
Now the best one though is when
you can start doing subclassing.

00:33:58.170 --> 00:34:06.870
Both the Python and the Ruby bridges support subclassing.
Use a typical declarations for a subclass of an NSObject.

00:34:06.869 --> 00:34:12.329
They, of course, support declaration of instance
variables and because in Objective-C unlike Python

00:34:12.329 --> 00:34:16.519
and Ruby doesn't treat everything as
a dictionary, in Objective-C the slots

00:34:16.519 --> 00:34:21.380
of the instance variables is very important so
there's mechanisms for declaring classes such

00:34:21.380 --> 00:34:25.519
that the layout information passes through to Objective-C.

00:34:25.519 --> 00:34:30.969
Both of the bridges support category-like functionality
meaning you can inject new method implementations

00:34:30.969 --> 00:34:33.889
into the runtime as you saw me do earlier.

00:34:33.889 --> 00:34:38.199
I would generally recommend against
not doing what I did there.

00:34:38.199 --> 00:34:42.659
Don't replace the existing implementations, add to them.

00:34:42.659 --> 00:34:46.049
And with Python there is limited
multiple inheritance support.

00:34:46.050 --> 00:34:50.960
Which means you can actually mix in classes into
Objective-C subclasses from the Python side.

00:34:50.960 --> 00:34:59.309
So when we talk about the BridgeSupport lets dive into
the metadata a little bit in detail here and we'll get

00:34:59.309 --> 00:35:02.739
to the actual metadata files in a second.

00:35:02.739 --> 00:35:11.589
The metadata supports 64-bit annotations so you can generate
metadata that describes 32-bit and describes a 64-bit

00:35:11.590 --> 00:35:14.490
and outlines the differences between them.

00:35:14.489 --> 00:35:19.209
There are Endianness-specific annotations.

00:35:19.210 --> 00:35:23.409
So first thing and last, LSB, MSB, all that stuff.

00:35:23.409 --> 00:35:27.219
You can describe that in the APIs and
the differences between the platforms.

00:35:27.219 --> 00:35:30.989
There's very little of that but
some of it does leak through.

00:35:30.989 --> 00:35:34.189
There is a full DTD provided and documentation.

00:35:34.190 --> 00:35:40.889
You'll find the DTD in /System/Library/DTDs. There's a BridgeSupport man page in section five,

00:35:40.889 --> 00:35:47.670
it's quite detailed. And there
is a gen_bridge_metadata tool.

00:35:47.670 --> 00:35:51.090
This is a Ruby script that you'll
find in user bin I believe.

00:35:51.090 --> 00:35:54.850
It generates data for APIs as well as generating dialups.

00:35:54.849 --> 00:36:01.860
It can generate full metadata and it can have
exceptions which means you can provide a chunk of XML

00:36:01.860 --> 00:36:04.460
that will override the automatically generated metadata

00:36:04.460 --> 00:36:10.720
in case you need additional descriptions
that cannot be automatically generated.

00:36:10.719 --> 00:36:14.449
And that has full documentation as well.

00:36:14.449 --> 00:36:20.069
So when we look at the metadata XML
it's as human readable as any XML.

00:36:20.070 --> 00:36:26.390
That's what it normally kind of looks like at first glance.

00:36:26.389 --> 00:36:29.589
So let's look at this in detail though.

00:36:29.590 --> 00:36:35.180
So when you're describing your API, you can declare
that your API depends on some other sets of APIs.

00:36:35.179 --> 00:36:39.079
So if you're subclassing something you
know you can say, hey, I'm subclassing something

00:36:39.079 --> 00:36:42.500
for Foundation so I depend on the Foundation.

00:36:42.500 --> 00:36:47.519
Again, this is all automatically
generated content here but knowing

00:36:47.519 --> 00:36:51.829
about this is important if you do need to do exceptions.

00:36:52.989 --> 00:36:55.099
It also describes structures.

00:36:55.099 --> 00:37:05.519
So in this case we have an NSPoint description which in the
typically readable style of XML has the quote marks encoded.

00:37:05.519 --> 00:37:12.829
Sorry. And there's a 64-bit type versus a 32-bit type.

00:37:12.829 --> 00:37:15.750
So that's demonstrated here.

00:37:15.750 --> 00:37:20.000
This shows that NSPoint is just a
structure that contains an X and a Y element.

00:37:20.000 --> 00:37:27.800
This is what allows you to save P.X and P.Y
in the Ruby or Python side of the bridges.

00:37:27.800 --> 00:37:30.269
There's things called opaque pointers.

00:37:30.269 --> 00:37:37.590
These are references to things that really do not need to
ever be exploded on the Python or Ruby sides of the bridges.

00:37:37.590 --> 00:37:42.120
These are provided so that there's a
way for the bridge to know the type

00:37:42.119 --> 00:37:48.219
of the arguments without having to dive into them.

00:37:48.219 --> 00:37:54.809
There's constants, so in this case this describes an
NSInvalidArgumentException that global variable.

00:37:54.809 --> 00:38:01.579
So as the type isn't an object of some type and gives the
bridge all the detail it needs to go look up the symbol

00:38:01.579 --> 00:38:08.480
and provide a proxy to that on the Python or
Ruby side or whatever bridge you want to build.

00:38:08.480 --> 00:38:14.760
Functions can be bridged in this case this
is the NSAllocateCollectable function.

00:38:14.760 --> 00:38:22.030
And it has a 32-bit and a 64-bit declaration
and you can see the type differences there.

00:38:22.030 --> 00:38:27.220
This gives the bridges the ability to go and get that
symbol and then figure out how to encode the arguments in

00:38:27.219 --> 00:38:38.049
and out of the function or code the arguments as it
goes in, decode the return values as it comes out.

00:38:38.050 --> 00:38:43.620
This is a static inline NSMakeSize.

00:38:43.619 --> 00:38:49.179
Argument type definitions again,
differences between 64- and 32-bit.

00:38:49.179 --> 00:38:56.750
As well as the fact as the return value changes
between the two, between 32-bit and 64-bit.

00:38:57.949 --> 00:39:02.809
So what this will do is that the bridge will actually,
when it finds one of these static inlines in the code,

00:39:02.809 --> 00:39:10.539
it will create a little C stub that can make the
call to that, that is not static and not inline

00:39:10.539 --> 00:39:14.650
so that it can be dynamically loaded and the bridge
can do it's normal bridging magic to get to it.

00:39:14.650 --> 00:39:21.030
NSIntegerMax, here's another
type def, this is a type def enum.

00:39:21.030 --> 00:39:23.019
So it's a constant that goes across.

00:39:23.019 --> 00:39:26.329
As you can see the 64-bit one's a bit bigger.

00:39:29.079 --> 00:39:30.869
Here we have an informal_protocol.

00:39:30.869 --> 00:39:37.409
Now this is pretty interesting so NSKeyValueCoding is
actually an informal_protocol declared on NSObject.

00:39:37.409 --> 00:39:44.230
And the bridges bring that through as this informal
protocol like this so that they have the method signature,

00:39:44.230 --> 00:39:51.690
all that typing information that's needed on the Python
or Ruby sides of the bridge are on the bridge side.

00:39:51.690 --> 00:39:56.190
So that by default everything wants to be an object

00:39:56.190 --> 00:40:01.769
and by providing this information it actually provides
two advantages: one it just makes it just work

00:40:01.769 --> 00:40:07.480
but two it actually means that you now have this
metadata that you can say, oh, NSKeyValueCoding.

00:40:07.480 --> 00:40:10.230
Okay, I need to do that, that means
I need to implement these methods.

00:40:10.230 --> 00:40:15.130
So this actually provides for potential, for additional
validation above and beyond what's possible in the compiler.

00:40:15.130 --> 00:40:19.309
And then we have class annotations.

00:40:19.309 --> 00:40:20.969
There's a slew of different ones.

00:40:20.969 --> 00:40:26.319
This happens to be a method annotation which
is interesting for a number of reasons.

00:40:26.320 --> 00:40:29.150
One it's class_method so it's marked as such.

00:40:29.150 --> 00:40:32.900
So in languages that don't support
class_methods like Python.

00:40:32.900 --> 00:40:36.230
Python kind of does but no one does it.

00:40:36.230 --> 00:40:38.909
You can actually carry that information through.

00:40:38.909 --> 00:40:42.539
But there's another interesting bit of annotation
here and this shows sort of the intimacy

00:40:42.539 --> 00:40:44.980
of the bridging in between these languages.

00:40:44.980 --> 00:40:50.030
In Python and Ruby, it's pretty much impossible to
have a collection of stuff, collection of objects

00:40:50.030 --> 00:40:53.780
or whatever without also knowing the length of it.

00:40:53.780 --> 00:41:02.430
Now on the C side, in Objective-C if you're familiar with
this API, it takes two var arg parameters and account.

00:41:02.429 --> 00:41:07.730
So there's no way for the C side to know that but
we can actually declare in the bridge metadata

00:41:07.730 --> 00:41:13.059
that this is a method for which
the length of the collections

00:41:13.059 --> 00:41:19.759
of the first two arguments must either match
or must be used for the final argument.

00:41:19.760 --> 00:41:29.490
Thus we have automatic validation of things like buffer
sizes and array elements and matching in parody like that.

00:41:29.489 --> 00:41:37.289
Finally, this is a class annotation that's actually
showing the save method on NSManagedObjectContext.

00:41:37.289 --> 00:41:44.219
And this is a method for which the argument that's
returned or I'm sorry the argument that's taken

00:41:44.219 --> 00:41:49.539
as an NSErrorPointer pointer, we're saying that
arguments out only which allows the bridge to know

00:41:49.539 --> 00:41:55.400
that it shouldn't try to pass something into there and that
it can actually interpret the return value as an object.

00:41:55.400 --> 00:42:00.450
So this is one of those annoying, you
know, NSErrorPointer pointer arguments.

00:42:00.449 --> 00:42:05.579
And as well the return value is a Boolean, not
just a character, so that in Ruby you don't have

00:42:05.579 --> 00:42:09.150
to put the question mark on the end of everything.

00:42:09.150 --> 00:42:10.950
So that's the XML in detail.

00:42:10.949 --> 00:42:17.489
So now that we've gotten all that Foundation stuff out of
the way, what is developing Cocoa with Ruby and Python...

00:42:17.489 --> 00:42:18.859
What is that experience like?

00:42:18.860 --> 00:42:24.760
Well, there's Xcode templates provided for
Ruby and for Python Cocoa applications.

00:42:24.760 --> 00:42:29.980
On the Ruby side there's both Cocoa
applications, Cocoa document-based applications,

00:42:29.980 --> 00:42:33.079
Core Data applications and Core Data document-based apps.

00:42:33.079 --> 00:42:40.710
Python side there's a Python Cocoa, Python multi-doc Cocoa,
if you ask me in the lab I've got the Core Data template

00:42:40.710 --> 00:42:45.710
and there will be a document-based Core Data template
as well. I just didn't have time to get that in.

00:42:45.710 --> 00:42:51.990
They are full-blown application templates; you can mix
and match Objective-C and the language of choice in them.

00:42:51.989 --> 00:42:57.409
I would be interested if anyone tries to build one
that does both Python and Ruby at the same time.

00:42:58.760 --> 00:43:02.460
You can also use the new organizer in Xcode as well.

00:43:02.460 --> 00:43:09.720
So if you're using these languages and you want to use
whatever build system, distribution utility, packaging system,

00:43:09.719 --> 00:43:12.779
or whatever that's built into the
language, every language has them,

00:43:12.780 --> 00:43:18.620
you can use the organizer and set
that up to drive that very easy.

00:43:18.619 --> 00:43:20.690
Or you can use whatever IDE you want, of course, just

00:43:20.690 --> 00:43:26.720
like Cocoa programming there's no real magic
associated with Xcode and Xcode projects.

00:43:26.719 --> 00:43:28.029
Everything can be duplicated.

00:43:28.030 --> 00:43:33.590
You can drive TextMate, whatever you want to use.

00:43:33.590 --> 00:43:37.100
Xcode's actually leveraging the metadata.

00:43:37.099 --> 00:43:43.889
So these metadata files exist and Xcode's using it
to do code completion in Python and Ruby as well

00:43:43.889 --> 00:43:49.239
as in the organizer, I believe it's doing some code
completion based on the metadata for Objective-C.

00:43:49.239 --> 00:43:53.199
And InterfaceBuilder actually parses Ruby and Python.

00:43:53.199 --> 00:43:55.369
So when you go and you declare...

00:43:55.369 --> 00:43:59.109
( Applause )

00:43:59.110 --> 00:44:00.380
>> It's very cool.

00:44:00.380 --> 00:44:05.510
When you declare new outlets and new
actions in Python or Ruby and you go

00:44:05.510 --> 00:44:10.240
over to InterfaceBuilder it's automatically
going to reparse those files just like Objective-C

00:44:10.239 --> 00:44:15.659
and will update the inspector panel
and the objects in Interface Builder.

00:44:15.659 --> 00:44:20.529
The script that does the parsing
is actually a little Python script

00:44:20.530 --> 00:44:24.110
that does some really ugly regular expression parsing.

00:44:24.110 --> 00:44:27.910
But if you have a language that you want to
support and you do some regular expressions

00:44:27.909 --> 00:44:32.799
or modify that then file a bug,
add it to it, and we'll consider it.

00:44:34.269 --> 00:44:37.289
So let's look at Xcode-based development.

00:44:45.550 --> 00:44:51.519
Okay. Well, that was exciting.

00:44:51.519 --> 00:44:55.130
No, we don't want Dave Chappelle, that's for sure.

00:44:56.679 --> 00:44:59.109
There's no kids in the audience, right?

00:44:59.110 --> 00:45:03.390
So let's launch Xcode.

00:45:03.389 --> 00:45:09.170
This is the first time I've launched it
so it's bringing in the 64-bit stuff.
d

00:45:09.170 --> 00:45:12.800
Then we'll go ahead and we'll do a new project.

00:45:12.800 --> 00:45:18.570
And let's do a Cocoa-Python application.

00:45:20.239 --> 00:45:23.750
We'll do that and we'll call it BobTheApp

00:45:25.610 --> 00:45:29.349
So you'll see we've got a BobTheApp here.

00:45:29.349 --> 00:45:31.400
Ooh, I don't have the right preferences, I apologize.

00:45:31.400 --> 00:45:34.389
So we've got BobTheApp, it's a standard Cocoa app.

00:45:34.389 --> 00:45:42.219
There's some interesting stuff here. For example,
if we go ahead and let's run BobTheApp,

00:45:42.219 --> 00:45:46.819
it will run it just like a normal
Cocoa application, you'll get a window.

00:45:51.219 --> 00:45:52.409
There. There's the window.

00:45:52.409 --> 00:45:53.619
It's up, it's running.

00:45:53.619 --> 00:45:56.759
You'll see it actually did print out,
the application did finish launching.

00:45:56.760 --> 00:46:03.510
It's because the template does provide
an app delegate implementation--and oops.

00:46:03.510 --> 00:46:08.410
Let's go into our Preferences and make this a lot bigger.

00:46:11.760 --> 00:46:12.700
Where is it?

00:46:12.699 --> 00:46:14.689
Fonts and colors.

00:46:14.690 --> 00:46:15.659
Is there a really big one?

00:46:15.659 --> 00:46:16.429
Oh no, there isn't.

00:46:16.429 --> 00:46:17.579
Okay, fine.

00:46:17.579 --> 00:46:27.250
Let's just do this.

00:46:27.250 --> 00:46:31.019
( Typing )

00:46:31.019 --> 00:46:34.150
There, now it's big.

00:46:34.150 --> 00:46:42.650
So got an AppDelegate, it implements applicationDidFinishLaunching, it's connected in InterfaceBuilder.

00:46:42.650 --> 00:46:47.309
If we were to go back and we were to say--

00:46:50.900 --> 00:46:52.809
Do I have the zooming on?

00:46:56.219 --> 00:47:00.969
Go in here and inspect BobTheAppDelegate.

00:47:05.000 --> 00:47:07.590
Why don't I have zoom on?

00:47:10.809 --> 00:47:14.619
Thought I had Universal Access on too but I don't.

00:47:14.619 --> 00:47:16.500
Let me turn on zooming.

00:47:17.579 --> 00:47:21.519
Off, on. Okay, excellent.

00:47:21.519 --> 00:47:27.360
So let me turn that off so I don't make
myself or you sick while I do this.

00:47:27.360 --> 00:47:36.950
So if we come into here we can say, from objc import IBOutlet, IBAction, so we're going to define an outlet,

00:47:36.949 --> 00:47:45.399
we can say window = IBOutlet(), spelled right,
and if we were going to go back to InterfaceBuilder

00:47:45.400 --> 00:47:52.840
and inspect this guy, you would see
that sure enough the outlet showed up.

00:47:52.840 --> 00:47:59.350
So nice integration between InterfaceBuilder, Xcode, and the scripting languages.

00:47:59.349 --> 00:48:01.469
One other thing I want to show you.

00:48:01.469 --> 00:48:09.419
We happen to be in a project here, this would
work in the organizer too if we go application,

00:48:10.820 --> 00:48:13.920
okay, fine, it's not going to work
for me because this is a demo.

00:48:13.920 --> 00:48:14.849
Oh, there it is.

00:48:14.849 --> 00:48:21.589
So you can actually see that we're doing
method completions in Python as well.

00:48:21.590 --> 00:48:22.789
This works in Ruby.

00:48:22.789 --> 00:48:28.340
It's actually doing the conversion from the
colon style Objective-C notification or notation

00:48:28.340 --> 00:48:32.150
over to the Python or Ruby style use the under bars.

00:48:32.150 --> 00:48:36.539
It will fill in the method parameters
for you, notating the types, etc.

00:48:36.539 --> 00:48:41.079
And it's just a matter of a couple of key
presses to get to the arguments and fill them in.

00:48:41.079 --> 00:48:47.139
Pretty cool stuff.

00:48:47.139 --> 00:48:50.230
( Applause )
>> Can I have slides, please?

00:48:50.230 --> 00:48:52.329
Thank you.

00:48:52.329 --> 00:48:56.650
And there's one other thing that,
it's pretty easy to integrate.

00:48:56.650 --> 00:49:01.780
There's this thing called Pi two app which does
dependency checking in Python so if you use a bunch

00:49:01.780 --> 00:49:07.240
of third-party frameworks, or third-party tools, it will
actually go and it will look at all your Python code,

00:49:07.239 --> 00:49:13.029
figure out all your dependencies and make sure all
that stuff gets copied into your final dot app wrapper.

00:49:13.030 --> 00:49:15.150
That's easy to integrate as well.

00:49:15.150 --> 00:49:21.579
So this stuff is designed to build dot apps
that are drag-and-drop installable too.

00:49:21.579 --> 00:49:25.559
So some of the gnarly details here.

00:49:25.559 --> 00:49:32.529
One of the questions that I often get is can you
subclass a Ruby or Python class from Objective-C?

00:49:32.530 --> 00:49:34.250
The answer is yes, you can.

00:49:34.250 --> 00:49:36.570
But it's largely an academic exercise.

00:49:36.570 --> 00:49:43.240
It's really hard to do and the reason why is because
in Objective-C you need to compile the class.

00:49:43.239 --> 00:49:50.419
In Python or Ruby the class comes into being
at the very last moment right before execution.

00:49:50.420 --> 00:49:55.530
So what you have to do is create a header file that
describes the class good enough for the compiler

00:49:55.530 --> 00:50:00.110
to allow subclassing, that mimics the Python or Ruby side.

00:50:00.110 --> 00:50:04.309
Now this actually turns out in
practice not to be that big of a deal.

00:50:04.309 --> 00:50:08.039
Because when we talk about these
languages what we're largely doing

00:50:08.039 --> 00:50:12.699
in Cocoa is gluing together a bunch
of foundation kind of frameworks.

00:50:12.699 --> 00:50:19.730
And our glue code, this high-level code, it tends
to be exactly that, very high level so Python

00:50:19.730 --> 00:50:22.090
and Ruby is very comfortable in that role.

00:50:22.090 --> 00:50:25.010
You don't tend to have the reverse.

00:50:25.010 --> 00:50:27.820
So it's just not that big of a deal.

00:50:27.820 --> 00:50:35.320
PowerPC 32-bit support is a little bit broken in the
seed. I apologize for that, it was a last-minute mistake.

00:50:35.320 --> 00:50:40.690
But I'm interested in it because if you go to the RubyCocoa
site Laurent has indicated that you know binary is

00:50:40.690 --> 00:50:44.760
to fix that or it's not hard to come up with.

00:50:44.760 --> 00:50:49.820
Native Python or Ruby APIs can
be accessed from Objective-C.

00:50:49.820 --> 00:50:51.280
But it's kind of unnatural.

00:50:51.280 --> 00:50:57.620
Objective-C, one of the biggest advantages
of Objective-C besides its simplicity,

00:50:57.619 --> 00:51:02.429
is its incredible expressiveness
in its declarations and its syntax.

00:51:02.429 --> 00:51:09.949
And that means that the APIs tend to be
verbose descriptive, almost wordy in some cases.

00:51:09.949 --> 00:51:15.359
Go look at NSImage or NSBitmapImageRep in particular.

00:51:15.360 --> 00:51:21.820
But Python and Ruby tend to have very terse APIs and the
end result of which is that if you take a set of Python

00:51:21.820 --> 00:51:28.170
and Ruby classes and try to put those class methods,
the methods of the classes into Objective-C,

00:51:28.170 --> 00:51:30.349
there's just not enough information there.

00:51:30.349 --> 00:51:36.190
So it's actually much more natural to create a shim class.

00:51:36.190 --> 00:51:43.329
With subclasses and Objective-C class like NSObject, so
you get all of the Foundation-level behaviors for free.

00:51:43.329 --> 00:51:50.170
And then either mixes in or wraps the foreign
native, meaning the Python or Ruby APIs.

00:51:51.610 --> 00:52:00.210
For example, when using Twisted, you might create a subclass
of NSObjects that mixes in the twisted.Web class.

00:52:00.210 --> 00:52:04.139
So now you have a NSObject that can do all this web magic.

00:52:04.139 --> 00:52:05.159
Garbage collection support?

00:52:05.159 --> 00:52:08.019
No. It's just not there.

00:52:08.019 --> 00:52:14.150
It actually, it's because both Ruby and Python have a very
strong notion of memory management already built into them

00:52:14.150 --> 00:52:24.380
and they're not really designed to be subverted with another
collector so it's a hard problem, we're looking into it.

00:52:24.380 --> 00:52:29.260
There are other languages out there that
have much more replaceable collectors.

00:52:29.260 --> 00:52:32.140
I believe Lua is like that.

00:52:32.139 --> 00:52:37.239
So we're continuing research on that front.

00:52:37.239 --> 00:52:45.869
So in summary what you've seen is that we have
Python- and Ruby-based Cocoa development with access

00:52:45.869 --> 00:52:48.099
to just about all the APIs in the system.

00:52:48.099 --> 00:52:54.889
One of the bubbles that didn't pop up on that slide earlier
is that someone asked about the accelerate framework

00:52:54.889 --> 00:52:59.769
in the lab earlier in the week and it turned out that
it was pretty easy to generate metadata for that.

00:52:59.769 --> 00:53:04.579
So, yes, it's a lot of the APIs on the system.

00:53:06.260 --> 00:53:15.930
These descriptions of these APIs are machine readable. It's
really easy to generate your own, that's the underpinnings,

00:53:15.929 --> 00:53:20.559
the foundation that supports all of this high-
fidelity bridging that we're doing and allows us

00:53:20.559 --> 00:53:24.360
to build these bridges such that
they can be supported going forward.

00:53:24.360 --> 00:53:29.000
And we have really tried to design this
metadata descriptions such that it can be used

00:53:29.000 --> 00:53:33.329
for much, much more beyond just development work.

00:53:33.329 --> 00:53:36.549
Beyond just coding from these languages.

00:53:37.820 --> 00:53:41.150
There's third-party support for
additional languages in the works already.

00:53:41.150 --> 00:53:49.780
You can do this work on Tiger with the RubyCocoa work on
BridgeSupport as an example and the BridgeSupport project

00:53:49.780 --> 00:53:52.320
which is already in the open source community.

00:53:52.320 --> 00:53:58.700
F-Script Anywhere, which is a wonderful tool, small talk
derived language, embeddable, interpreted, etc.

00:53:58.699 --> 00:54:02.489
It's looking to use the bridge
support Perl with CamelBones.

00:54:02.489 --> 00:54:09.579
Shirm's indicated that he has alpha quality implementation
now and expects better quality to come along very rapidly.

00:54:09.579 --> 00:54:14.759
Lua, I know of at least two maybe three
people that are investigating Lua integration

00:54:14.760 --> 00:54:17.900
and have already started to do some coding work on that.

00:54:17.900 --> 00:54:22.869
And I'm sure there's other people
that are investigating this as well.

00:54:22.869 --> 00:54:30.400
There's a lab this afternoon, the
PyObjC and RubyCocoa Lab, 2 pm.

00:54:30.400 --> 00:54:35.039
RubyCocoa and PyObjC leading developers will
be there as well as a bunch of other people

00:54:35.039 --> 00:54:36.460
to help you out if you have any questions.
WEBVTT

00:00:21.649 --> 00:00:23.649
>> I'm Haroon Sheikh.

00:00:23.649 --> 00:00:27.829
I manage the Core Animation of the Quartz team,
and we've got a great session for you today.

00:00:27.829 --> 00:00:32.239
We're going to be talking about a great new
Leopard innovation called Core Animation

00:00:32.240 --> 00:00:35.260
and see how you can actually get that into your application.

00:00:35.259 --> 00:00:42.489
So many of you were already in the session before this so
this is going to be follow up on most of that same content,

00:00:42.490 --> 00:00:49.020
and for those who are new we'll build up on some core
fundamentals, you know, like introduce Core Animation,

00:00:49.020 --> 00:00:55.480
the layers themselves, talk about the animation model,
and then the bulk of the session will actually go

00:00:55.479 --> 00:01:01.559
over the Core Animation APIs, and we'll
have a few demos through the session itself.

00:01:02.659 --> 00:01:10.219
So it should come as no surprise that over the
last several years we've got this evolution going

00:01:10.219 --> 00:01:13.189
on in terms of the user interface itself.

00:01:13.189 --> 00:01:17.459
More and more applications are
requiring seamless compositing.

00:01:17.459 --> 00:01:20.119
You've got animations and transitions going on.

00:01:20.120 --> 00:01:28.680
A lot of the content is actually quite dynamic in nature and
the UI is actually providing a much richer user experience.

00:01:28.680 --> 00:01:32.870
So I just wanted to talk about an example from Tiger.

00:01:32.870 --> 00:01:40.500
We're got the iChat U+3 as part of iChat AV and
you've got QuickTime sources coming from multiple sources

00:01:40.500 --> 00:01:46.750
and all of that is just animating over time
really seamlessly with great frame rate.

00:01:46.750 --> 00:01:51.299
iTunes Coverflow, you've all seen that,
everyone is used to it and it's a great way

00:01:51.299 --> 00:01:57.509
of visualizing your data through your artwork, album art.

00:01:57.510 --> 00:02:02.439
Finally you've got full-screen applications
like Front Row and consequently Apple TV itself

00:02:02.439 --> 00:02:14.310
where you've got great content coming through from the web,
from your main machine, and just being presented in a nice

00:02:14.310 --> 00:02:21.580
and great way in terms of layers sort of moving across
the screen and with the right quality of animation

00:02:21.580 --> 00:02:28.640
as opposed to too much animation in your face.

00:02:28.639 --> 00:02:32.539
So I'll have a lot more examples of this stuff in Leopard.

00:02:32.539 --> 00:02:37.469
You've already seen some of these at the demo,
in previous demos, and in the keynote itself,

00:02:37.469 --> 00:02:43.969
but what you really should recognize is that you really
want to be part of this wave of applications that are moving

00:02:43.969 --> 00:02:51.280
into this new era, and the way to do that is really,
you want to rethink the way your applications work

00:02:51.280 --> 00:03:01.830
and portray your data and sort of reexamine how you
can portray your data with some hints of animation

00:03:01.830 --> 00:03:07.130
so the presentation is actually really nicely done.

00:03:07.129 --> 00:03:12.469
So, and part of the reason is you really don't
want to be left behind as your competitors,

00:03:12.469 --> 00:03:16.469
or just as the rest of the OS sort of moves in
this direction.

00:03:16.469 --> 00:03:21.159
Trying to get some of this content done
is relatively not hard I would say,

00:03:21.159 --> 00:03:24.870
but it's just that in the past you'd
have to go down into the OpenGL level.

00:03:24.870 --> 00:03:32.450
Most of the examples I showed you already, basically
they had to go through to a step of making sure

00:03:32.449 --> 00:03:38.269
that they could take advantage of OpenGL efficiently,
uploading textures at the right frame rate,

00:03:38.270 --> 00:03:46.629
at the right time to get that seamless animation
through the system and that's where we actually decided,

00:03:46.629 --> 00:03:53.329
let's bring all of the fundamental things in terms of
Core Animation that those animation applications provided,

00:03:53.330 --> 00:04:01.560
and let's bring that into the OS and provide that as a
service to you so that you can do some of those same things.

00:04:01.560 --> 00:04:05.310
So Core Animation, you've heard about it already,

00:04:05.310 --> 00:04:11.310
but the key thing is it's actually a
foundation for both compositing and animation.

00:04:11.310 --> 00:04:16.699
So you could even actually use Core Animation
for the sole purpose of just layer compositing,

00:04:16.699 --> 00:04:21.599
and that's a great functionality in itself, and on
top of that, you can actually animate that content.

00:04:21.600 --> 00:04:30.890
So it is part of the QuartzCore framework and very similar
to what you heard already in terms of all of these layers

00:04:30.889 --> 00:04:41.490
that you briefly were mentioned in the
previous session are very analogous to NSViews .

00:04:41.490 --> 00:04:44.439
The content of these layers can
come from lots of different sources.

00:04:44.439 --> 00:04:51.629
We talked about those already in the previous session, but
it could be Quartz content, it could be OpenGL content,

00:04:51.629 --> 00:04:54.279
even Core Text all sort of coming into the picture.

00:04:54.279 --> 00:05:02.379
You can apply a bunch of layer effects to that, shadow
effects, masking effects, to get really rich content.

00:05:02.379 --> 00:05:08.899
You've got these layers and now the key thing about
Core Animation is it is a declarative animation engine.

00:05:08.899 --> 00:05:15.870
As a result, you don't have to sit there
and program every frame of your application.

00:05:15.870 --> 00:05:18.840
The examples I showed you, they effectively have to do that.

00:05:18.839 --> 00:05:25.189
They have to go through and actually position all of those
layers or their concept of layers and objects and textures

00:05:25.189 --> 00:05:31.279
at the right location at the right time, whereas Core
Animation actually abstracts a lot of that for you,

00:05:31.279 --> 00:05:36.199
and actually, you can use it without
having to worry about much of the details.

00:05:36.199 --> 00:05:45.060
So in terms of the architecture, Core Animation is at the
center, but the key thing is it's sitting on top of OpenGL.

00:05:45.060 --> 00:05:51.220
So to answer the question that was there at the
previous session, Core Animation sits on top of OpenGL

00:05:51.220 --> 00:05:55.560
but it actually can use all of the
Leopard-supported graphics cards.

00:05:55.560 --> 00:06:01.889
So it's actually not restricted to the
programmable GPUs or anything else like that,

00:06:01.889 --> 00:06:06.719
and that's a key reason why you might
actually want to use Core Animation itself.

00:06:06.720 --> 00:06:12.600
In the past, you may have had to go down to OpenGL
trying to get it all done right and correctly

00:06:12.600 --> 00:06:16.560
with the right texture formats,
uploading it at the right time,

00:06:16.560 --> 00:06:19.170
looking at all the hints and tricks
that you need to do there.

00:06:19.170 --> 00:06:23.660
Now you can actually use Core Animation itself,
and it will worry about all of those details.

00:06:23.660 --> 00:06:29.480
So, like I mentioned earlier, if you just use it for the
compositing part of it, I mean that's a great step forward,

00:06:29.480 --> 00:06:32.980
and it will just work across the
graphics cards supported by Leopard.

00:06:32.980 --> 00:06:43.050
We're got all of the other Quartz and media technologies
such as QuickTime also being utilized as part

00:06:43.050 --> 00:06:53.530
of Core Animation itself, and then fundamentally
you can actually also use it at the Cocoa level.

00:06:53.529 --> 00:06:57.619
So our goal was to actually get high
quality and high performing animation,

00:06:57.620 --> 00:07:02.360
so you want to be able to hit that
60 frames a second frame rate.

00:07:02.360 --> 00:07:08.780
We do that by actually making sure that your
application does not have to redraw often.

00:07:08.779 --> 00:07:17.459
Ideally, you are not actually drawing every frame, so
much of your content is actually, you can draw it once.

00:07:17.459 --> 00:07:21.329
Core Animation will actually buffer
that content up for you, reuse it again

00:07:21.329 --> 00:07:26.169
and again unless you specify that
you need to change that content.

00:07:26.170 --> 00:07:30.680
When you're resizing, when you've got
relayout going on, you're moving things around,

00:07:30.680 --> 00:07:34.509
for the most part things are not
necessarily changing in terms of the content.

00:07:34.509 --> 00:07:38.159
I mean they may be animating in terms
of movement or repositioning themselves

00:07:38.160 --> 00:07:40.240
but the content itself is not necessarily changing.

00:07:40.240 --> 00:07:44.759
So ideally, in that case, Core Animation
doesn't necessarily have to call back to you.

00:07:44.759 --> 00:07:51.329
If you've got text views or anything else like
that, yes, they do need to reflow appropriately.

00:07:51.329 --> 00:07:57.439
But here is another way where we can avoid
calling back into the application code itself,

00:07:57.439 --> 00:08:03.689
and we can actually eliminate some of the code
that actually requires you to run at the frame rate

00:08:03.689 --> 00:08:07.779
and that sort of gives us that performance boost.

00:08:07.779 --> 00:08:16.119
And you've heard in many sessions previously that Core
Animation is taking advantage of multicore functionality

00:08:16.120 --> 00:08:21.810
through multithreading, and it actually runs a
complete rendering on a separate thread for you.

00:08:21.810 --> 00:08:28.100
We talked about layers briefly, but what are they?

00:08:28.100 --> 00:08:30.740
And I'll just go through an example, a very simple one.

00:08:30.740 --> 00:08:36.850
But you've got a photo in one layer, another text
layer on top of that followed by a graphic overlay,

00:08:36.850 --> 00:08:39.899
which is yet another image maybe, and as far

00:08:39.899 --> 00:08:47.929
as what the user sees it's just this is
your composited result that gets presented.

00:08:49.350 --> 00:08:52.750
These layers can have content coming from multiple sources.

00:08:52.750 --> 00:08:54.710
We've talked about CoreText.

00:08:54.710 --> 00:09:00.050
OpenGL content, you can actually
draw through a GL context itself.

00:09:00.049 --> 00:09:05.229
QuartzComposer compositions can
be placed as past of these layers.

00:09:05.230 --> 00:09:11.940
You can actually capture movies from QuickTime
and also at the same time playback movies.

00:09:11.940 --> 00:09:16.740
Quartz 2D images in terms of being
able to set a layer's content to come

00:09:16.740 --> 00:09:22.289
from an image source is actually quite
useful, and actually quite used in the system.

00:09:22.289 --> 00:09:26.500
Also, you can actually draw your own
content through Quartz 2D itself.

00:09:26.500 --> 00:09:33.059
Another point about layers themselves are
that they are quite lightweight in nature.

00:09:33.059 --> 00:09:42.109
So you've seen some of the demos and examples, and last year
we had a demo that showed 6,000 layers sort of animating.

00:09:42.110 --> 00:09:46.300
I'll have a video of that for those who haven't seen that.

00:09:46.299 --> 00:09:51.649
But they key is these are very lightweight
data structures and our goal was to make sure

00:09:51.649 --> 00:09:56.529
that you can actually have thousands of these in the system.

00:09:56.529 --> 00:10:00.309
Layers can have transforms on them, and we do that basically

00:10:00.309 --> 00:10:05.089
by allowing a perspective transform,
which is a four-by-four matrix.

00:10:05.090 --> 00:10:09.780
As a result, you can actually get, depth
sorting is handled automatically for you.

00:10:09.779 --> 00:10:15.129
One thing we do not support necessarily
is the ability to have layers intersect,

00:10:15.129 --> 00:10:18.899
and so that is an area that is not defined.

00:10:18.899 --> 00:10:26.579
But that doesn't stop us from doing great animation
like this stuff, this particular one from last year.

00:10:26.580 --> 00:10:37.120
So I'll let that go for a little bit, but you've got
lots of layers present there, all animating over time.

00:10:37.120 --> 00:10:43.840
You've got, a lot of this animation is done through
this concept of hierarchy, a layer tree that you sort

00:10:43.840 --> 00:10:49.930
of modify the root or the parents and
everything sort of follows from that.

00:10:49.929 --> 00:10:54.639
So this layer tree, you've got these
layers, you want to define them into a tree.

00:10:54.639 --> 00:11:00.610
And it is a very simple concept where
every layer can have a sublayer.

00:11:00.610 --> 00:11:04.480
As a result of that, you can actually construct a tree.

00:11:04.480 --> 00:11:06.840
It is a back-to-front composition model in the sense

00:11:06.840 --> 00:11:11.350
that the next thing you add will get
recomposed on top of what was there previously.

00:11:13.090 --> 00:11:21.450
These layers can have Core Image filters applied to them,
onto their content itself and also into the background.

00:11:21.450 --> 00:11:30.590
So the example on the bottom right sort of shows a blur
effect being applied to only a portion to the background,

00:11:30.590 --> 00:11:37.470
but sort of restricted by the layer's
mask to define the area effect.

00:11:41.779 --> 00:11:45.139
You've got layers now in a layer tree,
now you want to actually animate them.

00:11:45.139 --> 00:11:49.289
So there are a lot of layer properties that you can animate.

00:11:49.289 --> 00:11:53.639
We'll talk about all of those properties
a little later in the session.

00:11:53.639 --> 00:12:02.870
These animations are configurable in terms of
what the timing features from a particular point

00:12:02.870 --> 00:12:05.840
to another point specifying the duration.

00:12:05.840 --> 00:12:08.680
You can also customize all of that, apply a keyframe to it,

00:12:08.679 --> 00:12:12.329
apply it along a path, transitions
on them, animation groups.

00:12:12.330 --> 00:12:16.910
So a lot of this was actually discussed
in the previous session.

00:12:16.909 --> 00:12:24.939
The other thing you might want to do with this layer tree
is, the layer tree is animating but you may want to find

00:12:24.940 --> 00:12:32.340
out what's the current value of a particular property and
so we provide a way to query the animation status,

00:12:32.340 --> 00:12:36.210
and it's really useful for hit testing purposes.

00:12:36.210 --> 00:12:39.150
One key thing to remember about
the animation itself is by default

00:12:39.149 --> 00:12:44.600
when you change a property you are triggering an implicit
animation, and let me talk about that a little more.

00:12:44.600 --> 00:12:49.409
So here, I've got a simple example of the
Core Animation icon and the layer effectively,

00:12:49.409 --> 00:12:53.610
and all I really want to do is
set the opacity value to zero.

00:12:53.610 --> 00:12:59.620
Your code executes and effectively what that means is
as far as you're concerned the opacity value is zero,

00:12:59.620 --> 00:13:08.029
but it's actually occurring over a default time period
so that it will actually fade out over its default value.

00:13:09.350 --> 00:13:11.720
Similarly, we're got this concept of transactions.

00:13:11.720 --> 00:13:16.060
You want to make sure that all of
these operations are being done.

00:13:16.059 --> 00:13:24.419
In Atomic updates, I've got a few more layers here, and
what if I wanted to set the blue layer's opacity to zero,

00:13:24.419 --> 00:13:27.789
the size to zero, and the green layers x value to 500?

00:13:27.789 --> 00:13:32.139
And all of that is also done simultaneously
in an Atomic update.

00:13:32.139 --> 00:13:35.919
So you don't actually see partial frames showing up.

00:13:38.190 --> 00:13:41.510
So let me just quickly go through some
of the examples in Leopard itself.

00:13:41.509 --> 00:13:49.590
So I list a few here, and I'll go through a few of
them with more screenshots and with more detail.

00:13:49.590 --> 00:13:55.820
One thing to remember is the Dock on Leopard is
actually a full-blown Core Animation application.

00:13:55.820 --> 00:13:59.390
So it's actually doing all of its
effects through Core Animation.

00:13:59.389 --> 00:14:04.120
So it gives you a sense about the
power of Core Animation right there.

00:14:04.120 --> 00:14:11.399
We've got things like the icons and the
reflections in the Dock itself of the icons.

00:14:11.399 --> 00:14:13.779
Then you've got the stacks feature, which is really great.

00:14:13.779 --> 00:14:20.199
I mean, you sort of specify the animation that
you've seen associated with it, it sort of flows out.

00:14:20.200 --> 00:14:23.910
It's very easy to do with Core Animation itself.

00:14:23.909 --> 00:14:33.169
Start value, end value and let Core Animation
handle it animating across a path for you.

00:14:33.169 --> 00:14:42.979
You've seen Time Machine a few times already at WWDC already,
and here you've got all of these windows, Finder windows,

00:14:42.980 --> 00:14:46.990
they are actually Core Animation layers themselves.

00:14:46.990 --> 00:14:49.700
Preview is yet another great example of this.

00:14:49.700 --> 00:14:56.700
Preview takes advantage of another feature of Core Animation
called tile layers, which is newer than last year's WWDC.

00:14:56.700 --> 00:15:03.250
And what that really allows you to do is handle
large image data set, and so you'll get called back

00:15:03.250 --> 00:15:06.320
to handle each one of these subtiles as needed.

00:15:06.320 --> 00:15:16.050
But it allows you to handle larger than 2K-by-2K
image files across all of the GPUs that we support.

00:15:16.049 --> 00:15:21.279
Preview also has a great slide show for
you to take advantage of in Core Animation.

00:15:22.759 --> 00:15:27.330
Finders Quick Look is also taking
advantage of Core Animation.

00:15:27.330 --> 00:15:28.360
You've seen demos of this.

00:15:28.360 --> 00:15:30.639
I won't go into this in too much detail.

00:15:30.639 --> 00:15:34.139
But Xray, here's another example.

00:15:34.139 --> 00:15:36.689
Xrays got a colorful view itself also.

00:15:36.690 --> 00:15:42.520
You have several runs and you want to sort of visualize
them and sort of see all of them present at the same time.

00:15:42.519 --> 00:15:45.939
Here is a great way of actually
taking advantage of Core Animation.

00:15:45.940 --> 00:15:53.710
So let me actually go over and talk to
you and show you a demo of two things.

00:15:53.710 --> 00:15:59.030
One of them is already available to you
in your seed, which is ConvertFlow,

00:15:59.029 --> 00:16:05.319
which is nothing more than a simple way
of doing Power Flow in your application.

00:16:05.320 --> 00:16:08.210
So you've got access to this already.

00:16:08.210 --> 00:16:15.259
I recommend you play with it to get an
idea of how Core Animation is done directly

00:16:15.259 --> 00:16:18.759
at the Core Animation level as opposed to the AppKit level.

00:16:18.759 --> 00:16:24.889
It's doing nothing more than basically taking
all of your desktop images and you can sort of,

00:16:24.889 --> 00:16:31.449
as you expect you could sort of cycle to
these seamlessly and with high frame rate.

00:16:31.450 --> 00:16:35.600
As an exercise I'd recommend maybe what
you should do is sort of play with it,

00:16:35.600 --> 00:16:38.990
and try changing it so maybe the
center one is a larger size,

00:16:38.990 --> 00:16:44.820
or sort of applying animation to
the entire group of these layers.

00:16:44.820 --> 00:16:48.640
So maybe do something else with it.

00:16:48.639 --> 00:16:51.449
Maybe it could bounce up and down, whatever you want to try.

00:16:51.450 --> 00:16:57.870
But that's left as an exercise for you guys to do.

00:16:57.870 --> 00:17:02.519
The other demo I wanted to show you is Core Animation TV.

00:17:02.519 --> 00:17:07.539
So I want to thank actually the BBC
motion gallery for most of this content.

00:17:07.539 --> 00:17:13.879
So the goal here is you're watching TV, and so you've
got a heads up display that allows you to sort of go

00:17:13.880 --> 00:17:18.780
through different channels and at the
same time different shows on this channel.

00:17:18.779 --> 00:17:21.609
So it shows you the power of Core Animation right there.

00:17:21.609 --> 00:17:30.169
And as you notice, we can do things like have all of
these movies coming in with different transitions.

00:17:30.170 --> 00:17:38.519
At the same time, we could also bring in the
channel list and select any channel you want.

00:17:38.519 --> 00:17:41.059
We've got 4 or 5 or so channels right here.

00:17:41.059 --> 00:17:47.950
Let me go into the selection of, the shows associated
with that channel and then we can sort of choose that.

00:17:47.950 --> 00:17:55.269
So the goal we wanted to show you here was just
QuickTime content being played in the background,

00:17:55.269 --> 00:17:58.289
and then with different content on top of it.

00:17:58.289 --> 00:18:06.099
A lot of this is actually implemented through Core
Animations Scroll Layer feature, which allows us to sort

00:18:06.099 --> 00:18:13.449
of scroll around in this larger space and have
all of these layers sort of show up appropriately.

00:18:13.450 --> 00:18:19.230
So we've got QuartzComposer composition
running in the background here.

00:18:19.230 --> 00:18:23.259
At the same time, we can also start putting in new content.

00:18:23.259 --> 00:18:27.059
So here, we've got a layer, a series of layers.

00:18:27.059 --> 00:18:32.909
I mean, the actual layer itself is actually that thing there
but we actually put other layers on top of that to sort

00:18:32.910 --> 00:18:34.970
of help out with some of these other controls.

00:18:34.970 --> 00:18:41.750
For example, you'll also notice that in here I've got
Core Image filters being applied to some of these buttons.

00:18:41.750 --> 00:18:44.950
So there is a bloom effect sort of being applied there.

00:18:44.950 --> 00:18:50.019
And in this case, the clock is
actually done as a Quartz2D content.

00:18:50.019 --> 00:18:53.990
Every second it's actually drawing
the clock hands appropriately.

00:18:53.990 --> 00:19:05.180
There is other things that you can put in here and after
this session I hope, the stock prices go up to that value.

00:19:05.180 --> 00:19:09.269
Other things here, and then you
could also do GL content in here.

00:19:09.269 --> 00:19:14.089
So let's say I wanted to have that stick around.

00:19:14.089 --> 00:19:20.740
I'm back here, and so it shows a great way of how
some of these different technologies can be sort

00:19:20.740 --> 00:19:25.839
of incorporated together into your applications.

00:19:25.839 --> 00:19:29.799
So, let me go back to slides.

00:19:29.799 --> 00:19:36.490
And at this point, I'd like to invite
John Harper to actually go over some

00:19:36.490 --> 00:19:45.519
of the details associated with Core Animation itself.

00:19:45.519 --> 00:19:46.240
>>Thanks, Haroon.

00:19:46.240 --> 00:19:50.880
Okay, how does this work?

00:19:50.880 --> 00:19:56.830
Okay, so the first thing to bear in mind about Core
Animation is that it's a little different from some

00:19:56.829 --> 00:20:00.519
of the APIs we have in that it's very much data driven.

00:20:00.519 --> 00:20:06.119
And what that kind of means is that most of time you're
not really thinking about the functions of the call

00:20:06.119 --> 00:20:12.729
or imperative type programming, but really how to try to
control and define the description of what you want to see.

00:20:12.730 --> 00:20:18.870
So we talked about layers of animations, and so
this basically means that the layers are just kind

00:20:18.869 --> 00:20:26.369
of a property-based object with a bunch of properties
and a bunch of sublayers and all this kind of stuff,

00:20:26.369 --> 00:20:33.689
and the way you drive the framework is just to set the
properties and configure the objects and let the engine take

00:20:33.690 --> 00:20:36.279
up all the strain and do the work in the background.

00:20:36.279 --> 00:20:40.829
And so we take of a lot of advantage
from the new Objective-C features,

00:20:40.829 --> 00:20:45.139
so all of the API is defined in
terms of Objective-C properties.

00:20:45.140 --> 00:20:49.250
This gives you some nice things in terms of subclassing,

00:20:49.250 --> 00:20:51.859
but mainly you get the nice dots
and tags which we all love.

00:20:51.859 --> 00:20:58.479
And then because it's a data model, we have to
kind of define how this, what this means in terms

00:20:58.480 --> 00:21:03.480
of getting the changes to the screen, and the way we do
that is that we define these things called transactions.

00:21:03.480 --> 00:21:08.799
And a transaction, all you really need to know to start
with is that the transaction includes all your changes

00:21:08.799 --> 00:21:11.029
from each iteration around the event loop.

00:21:11.029 --> 00:21:12.579
So you can change whatever you'd like.

00:21:12.579 --> 00:21:18.439
At the end of the event loop, we collect all these
things up and push them to the screen in a single update.

00:21:18.440 --> 00:21:26.220
So let's go through, in a little more
detail now, how each layer is constituted.

00:21:26.220 --> 00:21:29.660
So first of all, each layer has some geometry.

00:21:29.660 --> 00:21:36.120
So they have a rectangle, which defines their
own kind of coordinate space, the bounds.

00:21:36.119 --> 00:21:41.319
They have a position in the containing space and some other
properties, like they have, you can have a curved corner

00:21:41.319 --> 00:21:46.899
or a chance of putting them into a 3D space and
a few other things, which we'll leave in the header files.

00:21:46.900 --> 00:21:55.000
Once you fill out the geometry then we look at the kind of
the forming things that make up the image of the layer,

00:21:55.000 --> 00:21:58.920
and the first thing which is drawn on the
bottom of the stack is the background color.

00:21:58.920 --> 00:22:03.160
And obviously, the background color sits in
the space, the corner space there and follows

00:22:03.160 --> 00:22:04.590
around the corners and that kind of thing.

00:22:04.589 --> 00:22:09.369
On top of the background, we put the content, and
this is the stuff you draw or the image you give us,

00:22:09.369 --> 00:22:15.029
and there are a number of ways to kind of plan how that
content is mapped into the layer, the layer geometry.

00:22:15.029 --> 00:22:20.049
Because, for example, the image may be bigger or
smaller than the layer itself, so you can tell us align

00:22:20.049 --> 00:22:22.940
to the top left or the bottom right or resize or whatever.

00:22:22.940 --> 00:22:26.440
The content's rect we'll get to later.

00:22:26.440 --> 00:22:30.940
So then, on top of the contents and the
background you get the sublayers; traditional,

00:22:30.940 --> 00:22:35.059
kind of recursive sublayer, subview compositing model.

00:22:35.059 --> 00:22:39.700
The one slightly different thing here is that the
sublayers can actually extend outside their parent.

00:22:39.700 --> 00:22:41.769
You can tell them to clip or not clip.

00:22:41.769 --> 00:22:43.930
We'll get to that later as well.

00:22:43.930 --> 00:22:51.750
Once you've got the sublayers we come to the border, and
the border is not often used but sometimes it's useful,

00:22:51.750 --> 00:22:53.920
and it just gives you a ring around the edge of the layer

00:22:53.920 --> 00:22:56.690
and you can define the color and
the width and that's about it.

00:22:56.690 --> 00:22:58.279
So now, we have this thing.

00:22:58.279 --> 00:23:01.299
We have the background color, the
contents, the sublayers, and the border,

00:23:01.299 --> 00:23:04.220
and this gives us the basic image of the layer.

00:23:04.220 --> 00:23:10.480
So the next set of properties kind of tell us what
to do with that, and the first thing which we talked

00:23:10.480 --> 00:23:12.140
about already is you can apply Core Image filters.

00:23:12.140 --> 00:23:19.230
So you can give us an array of filters which are applied in
order to just kind of take the original image and push it

00:23:19.230 --> 00:23:20.880
through each filter in turn and give us some output.

00:23:20.880 --> 00:23:23.000
In this case, we're using a morphology filter.

00:23:23.000 --> 00:23:32.369
You can also have a shadow, which has
the standard kind of configuration.

00:23:32.369 --> 00:23:35.579
In this case it's red for some reason.

00:23:35.579 --> 00:23:42.369
And once you've got that, the last final
thing you often want to set is the opacity.

00:23:42.369 --> 00:23:47.250
So now we finished with that and we got kind of the
image in isolation, and then the next thing we do

00:23:47.250 --> 00:23:50.079
in the rendering model is we composite
it into the background,

00:23:50.079 --> 00:23:52.939
which is kind of everything which
was drawn up to this point.

00:23:52.940 --> 00:23:56.880
And you can use a filter for that,
like a blend, blur, or something.

00:23:56.880 --> 00:24:02.470
And then finally once you've got this kind of
composited image of the layer into the backdrop,

00:24:02.470 --> 00:24:10.720
we then can use a mask to kind of reclip it
or apply it into the original destination.

00:24:10.720 --> 00:24:15.059
So in this case we used an Apple mask for some reason.

00:24:15.059 --> 00:24:18.970
I mean these are all things that you can
read about later in the documentation.

00:24:18.970 --> 00:24:23.759
So we talked a bit about mixing content,
and the way we do that largely is

00:24:23.759 --> 00:24:25.829
by defining a bunch of different subclasses.

00:24:25.829 --> 00:24:32.059
The CALayer is great for doing the standard
kind of image-based, CGContext-based drawing.

00:24:32.059 --> 00:24:37.409
But if you want larger data, which actually is bigger than
the graphics card can support, then you typically have

00:24:37.410 --> 00:24:44.910
to use the TiledLayer, where if you want OpenGL
data you have to use the OpenGLLayer, and so on.

00:24:44.910 --> 00:24:51.470
Oh, I should say that the ScrollLayer is
just some convenient things for scrolling.

00:24:51.470 --> 00:24:57.920
Okay, so like any other object, the way you
deal with these things is you allocate them.

00:24:57.920 --> 00:25:04.970
First, obviously, give you a pointer, and then you
typically set a bunch of properties on the layer.

00:25:04.970 --> 00:25:10.059
So you can, for example, set the
background color of your layer to white

00:25:10.059 --> 00:25:14.079
and then set its size to 100-by-100 or whatever.

00:25:14.079 --> 00:25:19.879
And then once you've configured it, the next thing you
normally do is add it to an existing superlayer to put it

00:25:19.880 --> 00:25:22.820
into this kind of recursive compositing tree.

00:25:22.819 --> 00:25:30.899
Once it's in the layer tree, assuming its parent of the top
of the tree is visible, then at some point we get this kind

00:25:30.900 --> 00:25:36.610
of transactional-based layout of the drawing
model, which we'll talk about in the next slides.

00:25:36.609 --> 00:25:41.669
So once you've gone through this stage and it has been
committed at the end of the event loop, it's on the screen.

00:25:41.670 --> 00:25:47.630
It's been drawn and you no longer have to really care about
it unless you want to change the properties, and of course,

00:25:47.630 --> 00:25:51.120
finally you may end up removing it, deallocating the layer.

00:25:51.119 --> 00:25:54.979
So we can go through that in a little more detail.

00:25:54.980 --> 00:25:56.900
So the first line is we're going to create that layer.

00:25:56.900 --> 00:26:02.769
We just use the standard kind of
initializer, allocater type convenience method.

00:26:02.769 --> 00:26:07.990
Then in this case we're just going to say give it a
fixed point on screen in its parent's corner space,

00:26:07.990 --> 00:26:11.450
like a little box in the corner in this example.

00:26:11.450 --> 00:26:13.200
And then we're not going to do any custom drawing.

00:26:13.200 --> 00:26:17.319
We're just going to say here's an image which
we presumably loaded off disk or drew earlier,

00:26:17.319 --> 00:26:21.369
and say this is your contents for the layer.

00:26:21.369 --> 00:26:26.329
And in this case, because we haven't told it to do anything
else it will resize to fit the bounds of the layer.

00:26:26.329 --> 00:26:30.439
And then, as I said earlier, we have to add it to
the layer tree so we use this convenience method

00:26:30.440 --> 00:26:33.570
to modify the sublayer's property of my superlayer.

00:26:33.569 --> 00:26:37.950
And once we've done that and my superlayer
is already visible, then we'll get some kind

00:26:37.950 --> 00:26:42.170
of default cross-fade transition,
and it will just appear on the screen.

00:26:42.170 --> 00:26:47.840
Okay, so back to layout and drawing.

00:26:47.839 --> 00:26:52.899
Two of the main things you want to do with
layers once you've created them is position them

00:26:52.900 --> 00:26:54.440
and then draw into them.

00:26:54.440 --> 00:26:58.039
So we kind of wrap that up in a way that makes
it a little more convenient, and it's very similar

00:26:58.039 --> 00:27:02.649
to the NSView drawing model in that we give
you a way to kind of defer all these actions

00:27:02.650 --> 00:27:08.780
until immediately before we commit them onto the screen.

00:27:08.779 --> 00:27:15.200
So layout is the first pass, and this
basically gives you a chance to hook in

00:27:15.200 --> 00:27:19.980
and kind of position all your sublayers
somewhere in the global space.

00:27:19.980 --> 00:27:27.289
And so there is two ways really of defining layout behavior.

00:27:27.289 --> 00:27:32.339
You can subclass the layer, which we will
show later, or you can assign a delegate.

00:27:32.339 --> 00:27:40.629
In both cases, you typically call this -setNeedsLayout method
just to say I need layout, and then in the subclassing

00:27:40.630 --> 00:27:46.340
case you would implement the -layoutSublayers method,
or in the delegate case, you would implement some other kind

00:27:46.339 --> 00:27:49.649
of third-party object which implements
basically the same method.

00:27:49.650 --> 00:27:55.019
And that gets called when you set that as
the layout manager property of the layout.

00:27:55.019 --> 00:27:57.910
Delegates or layout managers are
pretty useful in that you can kind

00:27:57.910 --> 00:28:03.050
of encapsulate reusable layout algorithms, I guess.

00:28:03.049 --> 00:28:07.339
So for example, if you know that a bunch of your
different subclasses all need a grid layout method

00:28:07.339 --> 00:28:11.699
or a box one depacking or whatever, then
you can wrap that up in a layout manager

00:28:11.700 --> 00:28:14.430
and just you know, reuse that for every layer.

00:28:14.430 --> 00:28:22.690
We give you one existing layout manager which is called the
ConstraintLayoutManager, and this is a nice way to kind

00:28:22.690 --> 00:28:27.130
of describe kind of spatial layout constraints.

00:28:27.130 --> 00:28:32.210
So you could say that if I have 5 sublayers,
then the first one, his left edge is relative

00:28:32.210 --> 00:28:36.660
to the right edge of the next one and things like this.

00:28:36.660 --> 00:28:42.230
Finally, if you really want to use the old style
stuff, we also have the autoresizing mask property

00:28:42.230 --> 00:28:45.589
from NSView and that works just like in NSView.

00:28:46.609 --> 00:28:53.319
So drawing is pretty similar to layout, and it runs, but
in this case, you're not positioning things on screen.

00:28:53.319 --> 00:28:56.189
You're actually drawing into the layers.

00:28:56.190 --> 00:28:58.120
I should say here that you don't
have to draw into the layers.

00:28:58.119 --> 00:29:03.839
Like we saw earlier, you could just set the contents of
the layer to be some image, and that works in a lot of cases,

00:29:03.839 --> 00:29:07.449
but also often, you want to do custom CG drawing.

00:29:07.450 --> 00:29:10.279
And so the best way to do that is just
call -setNeedsDisplay on the layer,

00:29:10.279 --> 00:29:16.649
and then implement the drawing context method. And if you do
that we can create a buffer for you in the optimal format

00:29:16.650 --> 00:29:22.150
for the graphics card, the optimal size, set
it all up correctly, reuse the CG context,

00:29:22.150 --> 00:29:23.910
and then just give it to you to draw into.

00:29:23.910 --> 00:29:34.080
So the point of the bottom is very important, you should
never call -setNeedsDisplay unless you're sure you do need

00:29:34.079 --> 00:29:40.289
to display, because if you do, we've seen this
in some cases, you'll end up with a, kind of,

00:29:40.289 --> 00:29:45.740
layer size transparent image just sitting in
the stack taking fill rate for no reason.

00:29:45.740 --> 00:29:52.470
Okay, so now we're going to go through
subclassing in a little more detail.

00:29:52.470 --> 00:29:57.220
One of the main reasons of the subclass is
you want to add properties to layers.

00:29:57.220 --> 00:30:02.710
So, in this case, if we're imaging that we have some kind
of customs drawing code, but we want to reuse the layer,

00:30:02.710 --> 00:30:08.480
so we're going to add a lineWidth property, and
presumably we're going to use this when we actually draw

00:30:08.480 --> 00:30:12.579
into the layer, to kind of use some special behavior.

00:30:12.579 --> 00:30:16.919
So the first thing we'll do is in our header
file we will declare this lineWidth property,

00:30:16.920 --> 00:30:21.009
and we do it in the normal Objective-C 2.0
@property syntax.

00:30:21.009 --> 00:30:28.220
But the thing to, kind of, be aware of is that
for the most optimal behavior you really want

00:30:28.220 --> 00:30:30.680
to let Core Animation implement all the properties.

00:30:30.680 --> 00:30:33.299
So you don't want to do @synthesize
or define your own set

00:30:33.299 --> 00:30:36.009
of getter methods unless you
have a real good reason to.

00:30:36.009 --> 00:30:41.200
The best thing is just say, @dynamic in the
implementation file, which just tells the compiler

00:30:41.200 --> 00:30:47.519
I'm not going to do anything here, and then at runtime
Core Animation can introspect all the classes and see, well,

00:30:47.519 --> 00:30:50.240
this guy didn't implement this
property, so I'm going to do it for him.

00:30:50.240 --> 00:30:54.140
And that basically means we'll create
the setter/getter methods and all that kind

00:30:54.140 --> 00:30:57.520
of stuff, and manage the properties for you.

00:30:57.519 --> 00:31:03.519
So the first thing, after declaring the property,
is typically you want to give it a default value.

00:31:03.519 --> 00:31:07.059
If the default value is zero you don't have to do
anything, we'll do that for you, but if it's not zero,

00:31:07.059 --> 00:31:13.000
the thing to do is override this default value
for key method and then you can check the key,

00:31:13.000 --> 00:31:14.609
and if it's your property, then it just returns on value.

00:31:14.609 --> 00:31:19.959
This doesn't have to be particularly efficient
because we cached the values when we first used the class.

00:31:19.960 --> 00:31:28.150
So once you've given it the default values,
the next thing to be aware of is,

00:31:28.150 --> 00:31:34.960
typically most times you @properties you're doing it
because you want to change the layout or drawing behavior,

00:31:34.960 --> 00:31:38.529
so that means if a property changes,
it's kind of convenient if the layout

00:31:38.529 --> 00:31:40.809
or drawing kind of updates itself automatically.

00:31:40.809 --> 00:31:46.679
So the way we found it's best to do that right now is,
you can override this KVO method to changeValueForKey.

00:31:46.680 --> 00:31:53.830
And, obviously, all property changes will go through
this method, and then the same way for the default value,

00:31:53.829 --> 00:31:57.129
you can just kind of check your key and then do something.

00:31:57.130 --> 00:32:00.870
In this case, we are going to say, if the key is
lineWidth we know we have to redraw the layer

00:32:00.869 --> 00:32:03.069
so we are just going to say -setNeedsDisplay.

00:32:03.069 --> 00:32:10.319
Finally here, since we're going to do some drawing,
we're going to override the drawing context method

00:32:10.319 --> 00:32:12.379
and here we're going to use the @property value.

00:32:12.380 --> 00:32:18.130
You can use your imagination what we're going
to draw, because I was running out of space.

00:32:18.130 --> 00:32:22.100
But, basically, you just say self.property,
and everything kind of works.

00:32:22.099 --> 00:32:25.319
And that's basically how to subclass.

00:32:25.319 --> 00:32:32.559
So, a little kind of sidestep, the CALayers
is great for, you know, normal-sized data,

00:32:32.559 --> 00:32:39.789
and normal is kind of about up to 2000 pixels by 2000
pixels, but if you want more, if you want larger data

00:32:39.789 --> 00:32:44.519
or the data that has, potentially, multiple
levels of resolution, where that means, you know,

00:32:44.519 --> 00:32:49.410
you may have a representation or can generate
one at 50 percent or 25 percent, and so on,

00:32:49.410 --> 00:32:52.000
then you'd probably want to use the TiledLayer.

00:32:52.000 --> 00:32:57.500
The TiledLayer is a really nice way to kind of manage all
this stuff asynchronously, and it doesn't ask you ahead

00:32:57.500 --> 00:33:03.400
of time for the data, it just kind of waits and sees
what's being rendered on the screen, and it will ask you,

00:33:03.400 --> 00:33:10.160
kind of asynchronously, give me the
tiles for region 0,0 or 100, 100.

00:33:10.160 --> 00:33:13.450
And the other thing is, it also manages the level of detail.

00:33:13.450 --> 00:33:20.930
So it sees that you're zoomed right out on this kind of
10,000-by-10,000 pixel layer, then it will probably ask you

00:33:20.930 --> 00:33:25.049
for a level of detail that kind
of ten percent size or something,

00:33:25.049 --> 00:33:27.000
and that means that it can really minimize the amount

00:33:27.000 --> 00:33:29.799
of bandwidth it's using to, kind
of, put that thing on the screen.

00:33:29.799 --> 00:33:38.259
Also, of course, it lets you do whatever kind of filtering
you want, so you probably end up with a better result.

00:33:38.259 --> 00:33:42.640
So, I guess the last point is that
we said earlier you can always assign

00:33:42.640 --> 00:33:44.890
to the contents property, and that's not true here.

00:33:44.890 --> 00:33:48.780
If you do that, you basically make it a non-TiledLayer.

00:33:48.779 --> 00:33:52.430
Okay, so back to animation.

00:33:52.430 --> 00:33:56.070
I guess the previous session talked
a bit about this, but basically,

00:33:56.069 --> 00:34:00.689
we have the CAAnimation Class
to represent all of animations.

00:34:00.690 --> 00:34:06.390
And the way the animation model works is that just like
the layer model where you describe what you want to see

00:34:06.390 --> 00:34:09.000
on the screen, you do the same thing with animation.

00:34:09.000 --> 00:34:11.750
You create the object, you set all
the properties to describe, you know,

00:34:11.750 --> 00:34:15.090
the animation you want to see, and
then you just add it to the layer.

00:34:15.090 --> 00:34:20.079
Once it's been added to the layer, when
it's kind of at the time of purchase,

00:34:20.079 --> 00:34:22.860
the rendering engine would just do everything automatically,

00:34:22.860 --> 00:34:28.780
and then typically the animation will
be removed as soon as it's completed.

00:34:28.780 --> 00:34:35.140
So there's two ways you can actually add the animations
to the layer, either implicitly or explicitly,

00:34:35.139 --> 00:34:40.109
and most of the time we just use the implicit animation,
which basically means that every time you change a property

00:34:40.110 --> 00:34:44.700
on the layer, there's some default animation
which is going to run automatically,

00:34:44.699 --> 00:34:49.079
or implicitly. It's very similar to the Cocoa stuff.

00:34:49.079 --> 00:34:55.690
And the way this is done is by this -actionForKey:
method and its kind of similar class methods.

00:34:55.690 --> 00:35:00.190
And basically, what this does is it calls
this method when the property was changed,

00:35:00.190 --> 00:35:06.139
it kind of gets some default animation which, obviously,
you can override, and then adds it to the layer for you.

00:35:06.139 --> 00:35:14.879
And that often gets you about 90 percent of the way done
with your animations, but some of the time you then want

00:35:14.880 --> 00:35:21.269
to create your more kind of expressive or
complex or whatever explicit animation.

00:35:21.269 --> 00:35:27.860
So in those cases you would probably disable the implicit
animations and then create some set of explicit animations

00:35:27.860 --> 00:35:33.630
which define the property change in more detail
and then just add that directly to the layer.

00:35:33.630 --> 00:35:38.380
I mean, they're both doing, basically, the same
thing, so it doesn't really matter which one you use.

00:35:38.380 --> 00:35:46.860
And then when the animation's over, unless you tell it not
to, it will just automatically disappear from the layer.

00:35:46.860 --> 00:35:48.039
You can also remove them by hand.

00:35:48.039 --> 00:35:54.559
So now, we're going to look at a little more detail
in the classes that let you describe animations.

00:35:54.559 --> 00:36:01.110
So the base class is the CAAnimation, and
this really just has a timing function which defines,

00:36:01.110 --> 00:36:03.970
evens things out, things like that and the delegate.

00:36:03.969 --> 00:36:09.719
The delegate lets you get messages back when the animation
starts and stops, which can be useful in some cases,

00:36:09.719 --> 00:36:14.779
when chaining things or modifying the
layer tree after an animation is finished or whatever.

00:36:14.780 --> 00:36:19.060
The timing protocol, we're not going to
talk a huge amount about, but basically,

00:36:19.059 --> 00:36:23.309
it's a way of describing a timing model
which both layers and animations implement.

00:36:23.309 --> 00:36:28.199
So, and the timing model has things like a
begin time and a duration, the repeat count,

00:36:28.199 --> 00:36:32.279
and that's about all you really need to know.

00:36:32.280 --> 00:36:37.210
So this just means that an animation has
a begin time and a duration, basically.

00:36:37.210 --> 00:36:42.130
So, the most common type of animation that
we deal with are property-based animations,

00:36:42.130 --> 00:36:49.780
and this is basically because the layer
model is very expressive in terms of properties,

00:36:49.780 --> 00:36:54.400
so the natural way to animate things is
typically just to animate the property values.

00:36:54.400 --> 00:36:59.099
So the property animation adds, basically, just
the name of the property that's being animated.

00:36:59.099 --> 00:37:05.549
So deriving from that is the basic animation, which we
also heard about earlier, and a basic animation, basically,

00:37:05.550 --> 00:37:12.019
just let's you set a fromValue and a toValue, so that
you can animate the most common type of property changes,

00:37:12.019 --> 00:37:17.309
which is, for example, change my opacity
from zero to one or one to zero.

00:37:17.309 --> 00:37:25.809
For more detailed property animations, we have a Keyframe
Animation class, and like most, kind of, animation,

00:37:25.809 --> 00:37:32.079
motion graphic type things, the KeyframeAnimation just
lets you specify an array of values the keyframe through,

00:37:32.079 --> 00:37:37.739
and with some kind of percentage timing, so you
can say that this animation has three keyframes,

00:37:37.739 --> 00:37:45.729
like an opacity from 0 to .7 to one or something, and then
you can specify the relative timing of those keyframes.

00:37:45.730 --> 00:37:51.800
One other interesting thing here is that you
can also not specify an array of keyframes,

00:37:51.800 --> 00:37:55.560
just kind of give it a CG path,
and this way you can get kind

00:37:55.559 --> 00:37:59.559
of two dimensional motion path animations working
pretty easily.

00:38:01.420 --> 00:38:07.940
Okay, so the times when you really can't achieve the
behavior you want by animating the properties of the layer,

00:38:07.940 --> 00:38:14.230
we have this transition animation subclass, and
the transition is really an image-based animation,

00:38:14.230 --> 00:38:19.329
so it's something like a cross fade where you can't really
achieve a cross fade just by modifying the properties

00:38:19.329 --> 00:38:24.230
of the layer, so you have to kind of go back to the pixels,
and really generate those pixels and blend between them.

00:38:24.230 --> 00:38:32.860
So there are a number of built-in types of
transitions that cross fade or push left, push right,

00:38:32.860 --> 00:38:37.750
the kind of Keynote-type transitions, and also
you can just give it a CI filter, or sorry,

00:38:37.750 --> 00:38:41.489
a CI filter that implements a transition.

00:38:41.489 --> 00:38:50.459
And this means you can extend this and implement
your own transition types which is kind of neat.

00:38:50.460 --> 00:38:56.730
Finally, we often find that, you know, having one
animation is good, but to get the behavior we want,

00:38:56.730 --> 00:39:01.440
we really want to be able to, kind of, collect
these things up and animate two properties

00:39:01.440 --> 00:39:05.170
at once, so you could just add two animations.

00:39:05.170 --> 00:39:09.909
But the nice thing about the group is that
it lets you kind

00:39:09.909 --> 00:39:13.129
of define a timing model that
all of those animations sit within.

00:39:13.130 --> 00:39:18.590
So just like an animation has a begin time
and a duration, so does the group, which means

00:39:18.590 --> 00:39:23.220
that when you put things inside the group, you no
longer have to care so much about their, you know,

00:39:23.219 --> 00:39:26.769
begin times and end times because
they're sitting within the group.

00:39:26.769 --> 00:39:32.759
So the timing, you can give the group a single
timing function, which means that, you know,

00:39:32.760 --> 00:39:36.480
they will ease in and ease out in the same pattern.

00:39:36.480 --> 00:39:43.440
Okay. So I guess that's, these are basically
just the classes you normally program to,

00:39:43.440 --> 00:39:48.119
I mean you can instantiate the others
but you probably won't see anything useful.

00:39:48.119 --> 00:39:53.069
Okay, so here's a very simple concrete
example of programming the animation model.

00:39:53.070 --> 00:39:56.100
First of all, we're going to, you
know, the same way we did with layers,

00:39:56.099 --> 00:39:58.799
we're going to create this object,
BasicAnimation, and we're going

00:39:58.800 --> 00:40:01.530
to set its properties to describe what we want it to do.

00:40:01.530 --> 00:40:06.870
So in this case, we're going to say, animate the opacity
property of the layer, and we're going to say animate

00:40:06.869 --> 00:40:11.460
from this value one to value zero over one second.

00:40:11.460 --> 00:40:14.900
And that's pretty much the simplest animation you can have.

00:40:14.900 --> 00:40:17.430
Finally, once we've kind of settled the properties

00:40:17.429 --> 00:40:20.429
to describe exactly what we want,
then we just add it to the layer.

00:40:20.429 --> 00:40:26.179
And then as I described earlier, the next time around the
event loop, this will be sent into the rendering thread

00:40:26.179 --> 00:40:30.899
and you'll see the animation kind of
happen for a second and then disappear.

00:40:30.900 --> 00:40:39.139
Okay, so the other thing about animations that's interesting
is they don't modify the layered properties directly,

00:40:39.139 --> 00:40:42.900
they modify what we call the presentation values.

00:40:42.900 --> 00:40:47.769
So when you're kind of configuring the layers
what you're really defining is a model,

00:40:47.769 --> 00:40:54.769
which we then layer the animations on top
of to generate the real screen values.

00:40:54.769 --> 00:41:01.929
So, then that makes things kind of
tricky because often you want to be able

00:41:01.929 --> 00:41:04.549
to say, well, where is the thing on screen now?

00:41:04.550 --> 00:41:07.050
And if it's animating, you know,
you can't ask the layer

00:41:07.050 --> 00:41:12.120
because it has the model value not the
presentation value, I mean the animating value.

00:41:12.119 --> 00:41:16.309
So recently we've added these methods
called -presentationLayer and -modelLayer

00:41:16.309 --> 00:41:20.179
and what -presentationLayer does is
it basically lets you request a copy

00:41:20.179 --> 00:41:26.879
of the current layer you're sending this message to,
but with all the animations applied for the current,

00:41:26.880 --> 00:41:32.380
for basically the current time. And so you can then get
this -presentationLayer and then ask it for its opacity,

00:41:32.380 --> 00:41:37.510
and if the animation we just saw is running, then it
will probably return somewhere between zero and one,

00:41:37.510 --> 00:41:40.980
not one or zero, which is the final states.

00:41:40.980 --> 00:41:43.590
And so there are a couple, couple places
where this is really, really useful.

00:41:43.590 --> 00:41:48.019
The first one is probably hit testing.

00:41:48.019 --> 00:41:51.579
The other kind of interesting thing about the -presentation
Layer is that it is not just one layer, it kind

00:41:51.579 --> 00:41:56.630
of defines a presentation tree because if you ask the
presentation layer for its sublayers or a superlayer,

00:41:56.630 --> 00:42:01.809
then it automatically generates a, the presentation
values of those layers as well and gives them back to you.

00:42:01.809 --> 00:42:07.349
So you can just kind of create the -presentationLayer
and then say hitTest and that will actually hit test

00:42:07.349 --> 00:42:10.799
across the entire presentation tree,
and then will find whichever layer

00:42:10.800 --> 00:42:14.510
in its screen position contains the point you're asking for.

00:42:14.510 --> 00:42:19.220
And so then, we go, we send that result to the -model
Layer message just to get back to kind of the kind

00:42:19.219 --> 00:42:26.730
of things we know because we created them, which are
the, kind of, the object model, the layer tree list.

00:42:26.730 --> 00:42:32.639
And this works because Cocoa defines pretty nice behavior
for sending messages to nil, at least for pointers

00:42:32.639 --> 00:42:40.009
So the other use is that we can ask
a layer for its -presentationLayer

00:42:40.010 --> 00:42:44.650
then query the value of the property we're about to animate.

00:42:44.650 --> 00:42:50.440
So when you change the position of the layer and we go
off and generate the default implicit animation,

00:42:50.440 --> 00:42:55.750
we actually set the firm value of the animation to be
the position from the -presentationLayer. And that's

00:42:55.750 --> 00:43:00.099
because when you, you know, when you change the value
of something we're animating, you don't want to animate

00:43:00.099 --> 00:43:05.329
from where it was, kind of half a second ago,
you want to animate from where it is now.

00:43:05.329 --> 00:43:07.829
So that's that.

00:43:07.829 --> 00:43:12.799
Okay, so now we're getting on to
more kind of low -level things.

00:43:12.800 --> 00:43:20.140
So the first set of points about how to make Core Animation
applications faster, is that since we sit on top

00:43:20.139 --> 00:43:24.789
of OpenGL if you know a little bit about how the
graphics card works and how OpenGl kind of talks

00:43:24.789 --> 00:43:29.800
to the graphics card, you can theorize about
how you might make the application faster.

00:43:29.800 --> 00:43:35.360
So the first thing is that you want to minimize the
amount of geometry that gets sent to the graphics card.

00:43:35.360 --> 00:43:39.710
So the, obviously this means minimize the
number of layers in some cases or also,

00:43:39.710 --> 00:43:45.440
if you don't need to disable the edge antialising, we
do it for you, because this generates more geometry.

00:43:45.440 --> 00:43:49.720
This is typically not a big deal,
but we mention it for completeness.

00:43:49.719 --> 00:43:54.569
More importantly, you really have
to kind of think about overdraw.

00:43:54.570 --> 00:43:58.269
Overdraw is a measure of the number of
times we touch each pixel on the screen.

00:43:58.269 --> 00:44:01.670
So for example, if you have a hundred
layers composited on top of each other

00:44:01.670 --> 00:44:04.710
and the engine doesn't know they are
all opaque, then it's going to draw,

00:44:04.710 --> 00:44:06.960
it's going to touch that pixel a hundred times.

00:44:06.960 --> 00:44:11.139
And that's going to consume a lot fill rate even
on monographics cards.

00:44:11.139 --> 00:44:16.269
So the way to do, o kind of fix this problem is to
either implicitly tell us the layers are opaque

00:44:16.269 --> 00:44:21.550
by giving us an opaque image to put in the layer,
or just, there's a method on the layer called opaque

00:44:21.550 --> 00:44:25.300
which you can kind of override to return
true or set the property or whatever.

00:44:25.300 --> 00:44:29.910
And when we know the layers are opaque, we won't, we'll
try not to draw things underneath it, which, you know,

00:44:29.909 --> 00:44:33.759
drastically minimizes the amount of fill rate.

00:44:33.760 --> 00:44:39.580
Similarly, you want to minimize the amount of
textural image data you send to the graphics card.

00:44:39.579 --> 00:44:43.429
So for example, if you have 1000 layers
and they all have the same image,

00:44:43.429 --> 00:44:45.789
then you shouldn't generate 1000 copies of the same thing.

00:44:45.789 --> 00:44:49.029
You just use one image and set
it as the contents of that layer.

00:44:49.030 --> 00:44:55.230
And then we'll create a single texture which gets past
the graphics card once and assists in the texture cache.

00:44:55.230 --> 00:45:02.469
Another kind of facet to that is that you can take things
further by not saying that if I know that this layer,

00:45:02.469 --> 00:45:07.509
even though it's 1000 by 1000, if I know that when it comes
out on the screen it's only going to be 10 screen pixels

00:45:07.510 --> 00:45:13.760
by 10 screen pixels, you really don't want to give us that
1000-by-1000 image, you want to give us 10-by-10 image.

00:45:13.760 --> 00:45:17.560
Because that way, you know, we're just also
minimizing the amount of texture data.

00:45:17.559 --> 00:45:25.110
Finally, this is a little harder to understand,
but basically OpenGL works a lot better

00:45:25.110 --> 00:45:27.420
if you don't tell it to change all the time.

00:45:27.420 --> 00:45:34.269
So all you really need to know is that if you can,
you can kind of group some model layers together.

00:45:34.269 --> 00:45:39.820
So by that I mean, if you have 100 layers all with the same
image then you might want to kind of put them consecutively

00:45:39.820 --> 00:45:44.890
in the (inaudible) array cause then we don't have to kind of
give OpenGL that image and then another one and then back

00:45:44.889 --> 00:45:50.639
to the first one, and you know, it's kind
of latency generation kind of stuff.

00:45:50.639 --> 00:45:57.789
So that's the kind of basic stuff, but the other big kind
of performance killer that we see is that you can do a,

00:45:57.789 --> 00:45:59.639
you can render things off screen a few times,

00:45:59.639 --> 00:46:07.109
what I mean by that is that often we can't just tell
OpenGL render this layer straight to the screen.

00:46:07.110 --> 00:46:09.590
We may have to render it into an
offscreen buffer or apply some kind

00:46:09.590 --> 00:46:13.050
of manipulation offscreen and then pull it back on screen.

00:46:13.050 --> 00:46:18.940
And that's, it's pretty, I mean it can kind of
cause your performance to drop pretty rapidly.

00:46:18.940 --> 00:46:24.130
So there are number of things you want to avoid if you
want to kind of go for this kind of top-level performance.

00:46:24.130 --> 00:46:28.090
One of which is, you should try to avoid group capacity.

00:46:28.090 --> 00:46:34.030
Group capacity effects are where you have a number of
objects all with a single capacity value applied to them.

00:46:34.030 --> 00:46:38.840
So for example, if you have a layer and it has five
sublayers, but you changed the capacity of the superlayer

00:46:38.840 --> 00:46:43.820
to be .5, then really the only way, the only way we
can render that correctly is by taking those 5 layers

00:46:43.820 --> 00:46:48.230
and rendering them all offscreen into a buffer and
then taking that buffer and blending it back onscreen

00:46:48.230 --> 00:46:52.969
through the opacity, because otherwise
you get a different result.

00:46:52.969 --> 00:46:58.969
Similarly any use of masks can be expensive, especially
mask layers where you have to render the layer offscreen

00:46:58.969 --> 00:47:05.089
to generate the mask or if you just set the mask to bounds
property and the bounds of the layer isn't pixel-aligned.

00:47:05.090 --> 00:47:10.110
By which I mean it's not integral or
it's rotated or something like that.

00:47:10.110 --> 00:47:14.240
It probably doesn't come as much of a
surprise that if you use Core Image filters

00:47:14.239 --> 00:47:19.699
or shadows you also incur some offscreen rendering penalty.

00:47:19.699 --> 00:47:26.669
Finally, if you get into, really into the 3D stuff, then
if you try to put a 3D layer within another 3D layer,

00:47:26.670 --> 00:47:30.030
because of the way we define our
rendering model that will be flattened

00:47:30.030 --> 00:47:33.370
into an offscreen buffer, you
know, between those two transforms.

00:47:33.369 --> 00:47:36.569
So you really want to use one level of 3D only.

00:47:36.570 --> 00:47:43.600
Okay, so here we have a large number of general
kind of hints and tips, just things we've accumulated

00:47:43.599 --> 00:47:49.130
over the past couple of years as
we've been using this stuff.

00:47:49.130 --> 00:47:52.019
The first few really deal with animation.

00:47:52.019 --> 00:47:57.300
We've found the best way to kind of think about animation
then, kind of, how we write our apps is we just kind

00:47:57.300 --> 00:48:00.970
of deal with the properties first and
get it kind of looking right on screen.

00:48:00.969 --> 00:48:05.839
And then we let the implicit animations kind
of do their job and we end up with something

00:48:05.840 --> 00:48:10.120
that probably looks okay, but might
not be exactly what we want.

00:48:10.119 --> 00:48:14.719
So we get 90 percent of the way there just by setting
properties and letting the implicit animation engine run,

00:48:14.719 --> 00:48:20.529
and then when we have to go the extra mile to get exactly
what whoever specified the UI wants, then we can turn off

00:48:20.530 --> 00:48:25.050
some of the implicit animations and kind
of put the explicit things we really,

00:48:25.050 --> 00:48:28.190
really know we need in their places, in their place.

00:48:28.190 --> 00:48:32.610
The way to do that is you can set
properties on the transaction class

00:48:32.610 --> 00:48:35.640
to say disable implicit animations from here to here.

00:48:35.639 --> 00:48:38.299
So it's pretty, pretty common.

00:48:39.610 --> 00:48:47.599
The next point is the timing model is something that's often
overlooked, but you can use it to kind of stagger things,

00:48:47.599 --> 00:48:53.289
and kind of arrange things in time as well as space. And
this lets you kind of take something that looks very simple

00:48:53.289 --> 00:48:57.320
in code, like one animation that does the
same thing, and then apply it to, say,

00:48:57.320 --> 00:49:01.430
a thousand layers with slightly different time
value against something that looks pretty complex.

00:49:01.429 --> 00:49:06.529
This is something that we've used a
lot in the demos we showed at WWDC.

00:49:06.530 --> 00:49:12.980
Similarly, you can take advantage of the fact we
have pretty good codes to interpolate matrices,

00:49:12.980 --> 00:49:19.579
so if you want to kind of animate something through a path
and space, with different orientations and different points,

00:49:19.579 --> 00:49:25.569
then you can often just kind of define the transform
which represents your orientation of those points

00:49:25.570 --> 00:49:31.440
in the keyframe, and then the animation engine
will take those keyframes, and kind of just interpolate

00:49:31.440 --> 00:49:35.019
between them, often in a way that's, that's pretty nice.

00:49:35.019 --> 00:49:38.940
A lot of the kind of camera animations you see
in the 3D demos that we show really are just kind

00:49:38.940 --> 00:49:43.050
of interpolating matrices with
nothing else actually going on.

00:49:43.050 --> 00:49:45.870
So, that leads into the next point,
which is that when we do these 3D demos,

00:49:45.869 --> 00:49:51.599
we really just -se the sublayerTransform property, which
is another 4-by 4 matrix, but applies to the sublayers

00:49:51.599 --> 00:49:58.259
of the layer, and then we use that to kind
apply the 3D perspective on camera transforms.

00:49:58.260 --> 00:50:01.200
It's kind of like the projection
matrix on the model, view matrix,

00:50:01.199 --> 00:50:04.399
kind of combined into one if you're familiar with OpenGL.

00:50:04.400 --> 00:50:11.329
This other type is a little kind of
hard to understand, but basically,

00:50:11.329 --> 00:50:14.659
you often want to animate the removal
of a layer from the scene.

00:50:14.659 --> 00:50:20.679
And so obviously, if you would just add the animation
you want to kind of, you want to see for that removal

00:50:20.679 --> 00:50:26.569
to the layer, and then remove the layer, you're not
going to see anything because, well, the layer's gone.

00:50:26.570 --> 00:50:31.480
So, typically, the way we do this, is we add the
animation, and make sure the animation has a delegate,

00:50:31.480 --> 00:50:35.170
and then the delegate will get the notification
when the animation has finished,

00:50:35.170 --> 00:50:38.210
and then we can go off and remove
the layer from the layer tree.

00:50:38.210 --> 00:50:43.889
There's one more little point to this, which is, if
we just did that, then we'd probably see, excuse me,

00:50:43.889 --> 00:50:50.559
we'd probably see the removal animation run,
and then a flick back to its original state,

00:50:50.559 --> 00:50:56.049
and then the layer get removed because of the
kind of inherent asynchronicity in the model we have.

00:50:56.050 --> 00:51:01.539
So, the timing protocol gives you a way to
fix this, which is you can say this animation,

00:51:01.539 --> 00:51:05.579
it's going to run for some duration, and then
I'm going to set this fillMode property

00:51:05.579 --> 00:51:10.969
which says even though it's over, keep applying the
last state forever, and that just kind of, you know,

00:51:10.969 --> 00:51:16.059
you can animate some removal thing by, you know,
animating the size to 0, or the opacity to 0,

00:51:16.059 --> 00:51:20.690
and then that final state is, is
just kind of clamped in the timeline.

00:51:20.690 --> 00:51:24.840
In conjunction with this, we removedOnCompletion
thing, and then once the delegate fires,

00:51:24.840 --> 00:51:28.050
because it's seen that the animation is finished,
even though it's really still being applied

00:51:28.050 --> 00:51:32.690
because of the fillMode. That's when you can go
off and remove it, and you don't see any glitches.

00:51:32.690 --> 00:51:38.210
Okay. That point is pretty simple.

00:51:38.210 --> 00:51:43.300
Basically, we also, you may not think about it,
but we, because a lot of the color primaries,

00:51:43.300 --> 00:51:49.650
color properties on the layers are defined as CG colors,
in most places, you can take advantage of the full kind

00:51:49.650 --> 00:51:54.300
of expressiveness of the CG color, which
means you can actually create a tiled pattern.

00:51:54.300 --> 00:51:58.380
For example, some image, like a checkerboard
image, which repeats across the plane.

00:51:58.380 --> 00:52:00.349
And you can specify that as the color.

00:52:00.349 --> 00:52:06.389
So, this gives you a nice kind of fairly simple way to
kind of take this, take an, or take some rendered cell

00:52:06.389 --> 00:52:10.599
and repeat it across the background of the layer.

00:52:10.599 --> 00:52:16.679
Finally though, last one is just kind of a gotcha. For
performance reasons, unlike some other Cocoa frameworks,

00:52:16.679 --> 00:52:22.039
we don't actually do the retain order release
thing when we fetch a property for you.

00:52:22.039 --> 00:52:26.050
So, you just have to be aware of that, basically.

00:52:26.050 --> 00:52:29.710
Okay. Okay.

00:52:29.710 --> 00:52:34.789
So, finally, basically two lines of
code to put the layers on the screen.

00:52:34.789 --> 00:52:40.509
Obviously if you are using Cocoa and NSView and
mixing that stuff in, it might be a little more complex,

00:52:40.510 --> 00:52:44.090
but for a lot of the kind of Core Animation only type demos.

00:52:44.090 --> 00:52:50.430
Then we'll basically have one containing View, and we'll
set, we'll create some custom layer tree and then just set

00:52:50.429 --> 00:52:54.989
that layer tree as the layer of the View, and
then tell the view you have to render using layers.

00:52:54.989 --> 00:52:59.679
There is another method which is the CARenderer class,

00:52:59.679 --> 00:53:03.139
and this is a way to drive the
rendering of Core Animation explicitly.

00:53:03.139 --> 00:53:07.369
Typically, you probably won't have to use this at all.

00:53:07.369 --> 00:53:11.159
There's basically two places it might
be useful, one of which is if you want

00:53:11.159 --> 00:53:14.019
to drive the rendering on some external timer.

00:53:14.019 --> 00:53:19.420
So you could say, you know, render every frame
and then export it to a QuickTime movie or something.

00:53:19.420 --> 00:53:23.690
Or secondly you may want to have like a full-
screen OpenGL context, and just, you know,

00:53:23.690 --> 00:53:28.000
give the render of the direct OpenGL context
and render into it.

00:53:28.000 --> 00:53:30.710
And I think that's about it.

00:53:30.710 --> 00:53:37.880
So, I'm going to give a quick demo, and I thought I
would go through some of the stuff we showed on the keynote,

00:53:37.880 --> 00:53:41.890
but for more of a kind of how do we
do it, or did we do it perspective.

00:53:41.889 --> 00:53:45.449
So, you probably saw we had this video wall application,

00:53:45.449 --> 00:53:50.609
where I was trying to replicate the Apple TV
movie, that shows when you start the Apple TV.

00:53:50.610 --> 00:53:58.789
So, the first thing we did was we built this little
application that creates this mesh of layers.

00:53:58.789 --> 00:54:06.360
And, whoops, so you can see this bares some resemblance
to what we showed yesterday, but it's a lot rougher,

00:54:06.360 --> 00:54:14.200
and this is basically the first thing we had in that you
can, you can have this kind of mesh, which is basically kind

00:54:14.199 --> 00:54:19.149
of a, some number of layers mapped onto the face
of a cylinder, each one with its own, you know,

00:54:19.150 --> 00:54:22.960
3D transform defining the position in space, and z position.

00:54:22.960 --> 00:54:28.679
And then some kind of custom layout manager
to define the kind of cylindrical layout,

00:54:28.679 --> 00:54:33.289
and the various parameters we thought
we might want to change for the demo.

00:54:33.289 --> 00:54:39.090
So, so then we can add some color
to this just by doing that,

00:54:39.090 --> 00:54:43.860
and you can see that this is kind of
chunky on the edges of these things.

00:54:43.860 --> 00:54:48.510
So, the next thing is we can turn on the edge
antialiasing to make that kind of clean up a lot.

00:54:48.510 --> 00:54:51.230
And then if I go back a bit, we
can add the reflection layers,

00:54:51.230 --> 00:54:56.400
just to get the nice kind of, uh, pseudo-reflection look.

00:54:56.400 --> 00:55:02.840
And so that's basically the app, and you can see we
have this kind of nice 3D motion, which is like I said,

00:55:02.840 --> 00:55:08.539
is just animating the camera transform, or
the sublayer transform, so when I do this,

00:55:08.539 --> 00:55:12.250
I basically just pick the position in space, you can see
it actually in the bottom right-hand corner of the app.

00:55:12.250 --> 00:55:20.050
And I use this to define my camera matrix, and then set that
into the layer, and then it all just animates automatically.

00:55:20.050 --> 00:55:25.690
And I guess the real trick here is that we knew
we wouldn't be able to animate, oh sorry,

00:55:25.690 --> 00:55:29.429
play back, like a thousand movies simultaneously.

00:55:29.429 --> 00:55:32.480
So, we cheated, basically.

00:55:32.480 --> 00:55:41.719
And what we did is we generated this kind of pseudo-texture
atlas kind of movie in motion, which has 144 tiles,

00:55:41.719 --> 00:55:44.609
each of which has one movie playing back in it.

00:55:44.610 --> 00:55:49.190
And it's like a 20-second repe at loop thing.

00:55:49.190 --> 00:55:57.440
And so you know that's there, and then what I can do
now is I can take this movie, and drop it onto this app,

00:55:57.440 --> 00:56:02.050
and you know, you see the theatrical
kind of video wall start to appear.

00:56:08.909 --> 00:56:13.210
And so I guess the way we do this is we, there's
kind of a nice little trick here which is

00:56:13.210 --> 00:56:19.199
that we can create a single QTMovie layer, and
then we know that, you know, whatever the layer is,

00:56:19.199 --> 00:56:22.480
the only way it really has of communicating
its contents to the render tree

00:56:22.480 --> 00:56:24.670
or the render thread is by this contents property.

00:56:24.670 --> 00:56:28.940
So, what we actually did is then we created like,
if we want a 1000, we create one QTMovie layer

00:56:28.940 --> 00:56:33.079
and 999 just normal layers, and basically
just copy that contents property

00:56:33.079 --> 00:56:35.710
after we know it's been initialized
to all the other layers.

00:56:35.710 --> 00:56:38.550
And so they're basically just kind of sharing this movie.

00:56:38.550 --> 00:56:43.800
And then the other thing we did is that obviously
we don't want the entire movie in every cell,

00:56:43.800 --> 00:56:48.710
so we had this kind of property on the left called contents
rect, which is a way to basically take texture map

00:56:48.710 --> 00:56:51.800
of subregion out of the contents of the layer.

00:56:51.800 --> 00:56:57.019
So each layer is specifying some kind
of subregion of this overall movie.

00:56:57.019 --> 00:57:00.159
And it's basically that.

00:57:00.159 --> 00:57:05.940
Obviously we still have all the nice
fast motion, and all this kind of stuff.

00:57:08.610 --> 00:57:15.079
And this is basically, I think that the
entire demo is about 4000 lines of code.

00:57:15.079 --> 00:57:20.259
Most of that was to do with, you know, the Cover Flow
stuff, and the searching actuallly was the main part,

00:57:20.260 --> 00:57:22.260
and the other little key bits and pieces.

00:57:22.260 --> 00:57:29.710
I mean, I think this, the thing I'm showing you
here is probably only a few hundred lines of code.

00:57:29.710 --> 00:57:33.510
So, okay. I think that is that.

00:57:33.510 --> 00:57:38.890
( Applause )

00:57:38.889 --> 00:57:43.179
And now I think its back to Haroon to finish up.

00:57:43.179 --> 00:57:44.819
>> Thank you.

00:57:47.429 --> 00:57:49.079
Thanks. Thanks, John.

00:57:49.079 --> 00:57:52.949
So, we're actually done, so for most contact
information, you want to talk, you know,

00:57:52.949 --> 00:57:59.779
talk to Alan Shaffer, our evangelist on this part,
and the documentation sample goes to one of the demos

00:57:59.780 --> 00:58:05.320
that I showed earlier is already available. We'll try to
get the other one available to you as soon as possible

00:58:05.320 --> 00:58:11.930
after WWDC, and got a few Labs
to go to, the Core Animation Lab,

00:58:11.929 --> 00:58:14.750
and the 2D Graphics Lab, both at the same time tomorrow.

00:58:14.750 --> 00:58:16.539
You want to go to that.

00:58:16.539 --> 00:58:22.759
The Core Image one obviously, and the also the OpenGL
one given how Core Animation's sort of tied to it.
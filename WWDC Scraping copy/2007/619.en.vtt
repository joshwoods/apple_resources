WEBVTT

00:00:20.039 --> 00:00:25.309
>> We've got an interesting in-depth
technical presentation for you guys.

00:00:25.309 --> 00:00:29.969
It's going to be covering Developing
Rich Media WebKit Applications.

00:00:29.969 --> 00:00:37.200
We have Antoine Quint and Dean Jackson
here with us from Australia and Paris, France.

00:00:37.200 --> 00:00:43.510
So why don't I don't welcome up on stage Dean
Jackson first, so a large round of applause.

00:00:43.509 --> 00:00:49.089
( Applause )

00:00:49.090 --> 00:00:49.870
>> Dean: Bon jour.

00:00:49.869 --> 00:00:53.039
I'm the Australian one.

00:00:53.039 --> 00:01:00.850
So you've noticed from the graphics and media
state of the union and even actually before

00:01:00.850 --> 00:01:05.900
that that there's been a huge emphasis on
very, very interactive rich media content.

00:01:05.900 --> 00:01:10.230
And every time I hear the word rich media, it's like
hearing the word ontology, I want to leave the room.

00:01:10.230 --> 00:01:12.480
Rich media, I think well what do they mean?

00:01:12.480 --> 00:01:21.100
And what we're talking about today is web graphics because
we're basing our WebKit, we're adding video, interactivity,

00:01:21.099 --> 00:01:30.780
scripting, some animation, something that moves, something
that you can hear and something that you can see.

00:01:30.780 --> 00:01:38.390
So the agenda is the first half is I'm going to be going
through QuickTime and how you embed the QuickTime plug-in

00:01:38.390 --> 00:01:43.730
into the web browser and how you interact with
it, and then after that Antoine will be finishing

00:01:43.730 --> 00:01:51.640
up with scalable vector graphics, but he'll also show
how you can link video, QuickTime videos into SVG as well

00:01:51.640 --> 00:01:55.710
and actually interact through them with vector graphics.

00:01:55.709 --> 00:01:59.729
Okay. So I'll start.

00:01:59.730 --> 00:02:04.250
So actually, as I start, I'm going to
say clearly what isn't covered here.

00:02:04.250 --> 00:02:08.289
I'm not going to tell you how to check
whether the plug-in's in the browser,

00:02:08.289 --> 00:02:13.079
I'm not going to tell you point the
user to the plug-in page to download it.

00:02:13.080 --> 00:02:17.780
I'm not going to tell you much about the
JavaScript library that Apple provides.

00:02:17.780 --> 00:02:22.949
They provide a wrapper class for
doing interaction with QuickTime.

00:02:22.949 --> 00:02:24.829
What I am going to do is refer you

00:02:24.830 --> 00:02:29.680
to the developer.apple.com site,
which has a whole bunch of resources.

00:02:29.680 --> 00:02:37.400
And actually, if you just want it all collected into
one easy set of slides, you look at session 611.

00:02:37.400 --> 00:02:41.740
that has everything you need for that.

00:02:41.740 --> 00:02:45.310
So how do you actually embed QuickTime into an HTML page?

00:02:45.310 --> 00:02:53.289
So the way I think about it is that Apple has suggested
that if you want to do interaction with video data rather

00:02:53.289 --> 00:02:57.739
than rely on the interactive features in QuickTime,
which are there, you can still use them of course,

00:02:57.740 --> 00:03:04.670
you should be looking to the future where we're suggesting
that you have your interactivity embedded into the webpage

00:03:04.669 --> 00:03:09.809
because the web's already very interactive media and have
the video linking up with the scripts already in the page.

00:03:09.810 --> 00:03:13.050
So you actually just start by using the embed tag,

00:03:13.050 --> 00:03:17.840
which is very similar to the way other
plug-ins are embedded into the page.

00:03:17.840 --> 00:03:22.379
The important thing is you give it a media type
here, the type attribute, which says video QuickTime.

00:03:22.379 --> 00:03:27.949
That allows the browser to know that the content's
for the QuickTime plug-in and start the browser.

00:03:27.949 --> 00:03:30.479
And you give it a width and a height.

00:03:30.479 --> 00:03:35.280
You also like the image tag, give it a source,
which points to the movie you want to load.

00:03:35.280 --> 00:03:45.430
Once you have that, the movie should appear in
your page in the position you allocated to it.

00:03:45.430 --> 00:03:49.040
That's not all the attributes you
can apply on the embed tag.

00:03:49.039 --> 00:03:52.340
There's also some custom ones that
are specific to the QuickTime plug-in.

00:03:52.340 --> 00:03:57.050
The first one is whether or not you
want to show the little mini controller.

00:03:57.050 --> 00:04:01.570
So I've got examples in my demo of both with
the controller on and with the controller off.

00:04:01.569 --> 00:04:07.629
It's important, of course, to turn the controller off
if you want to provide this really rich experience

00:04:07.629 --> 00:04:12.780
where you've built a custom controller with your
own graphics and your own sliders or whatever

00:04:12.780 --> 00:04:17.459
Also, you have an attribute to
decide to tell the plug-in whether

00:04:17.459 --> 00:04:21.079
or not you should start playing
immediately the data is loaded

00:04:21.079 --> 00:04:22.479
That's pretty obvious.

00:04:22.480 --> 00:04:29.410
Lastly is whether or not you want the QuickTime
plug-in to really work as a part of the page or whether

00:04:29.410 --> 00:04:32.910
to be basically just drawing the video to the screen.

00:04:32.910 --> 00:04:35.730
I'll go into a little bit more detail in the next slide.

00:04:35.730 --> 00:04:41.530
But again, I'll just point you to the developer website
where there's an article, Including QuickTime in a Web Page,

00:04:41.529 --> 00:04:46.579
that has everything you need, an
explanation of all these attributes.

00:04:46.579 --> 00:04:50.430
So what does it mean to have W Mode transparent?

00:04:50.430 --> 00:04:56.120
Well the great thing is that you can set the opacity
on the video so that you can have things that show

00:04:56.120 --> 00:05:00.819
through the video or you can have things on
top of the video that display on top of it.

00:05:00.819 --> 00:05:03.550
So there's these great benefits that
means it's actually a regular part

00:05:03.550 --> 00:05:06.740
of the webpage just like other elements in the webpage.

00:05:06.740 --> 00:05:07.720
Much easier to script.

00:05:07.720 --> 00:05:09.820
You can do a lot more with it.

00:05:09.819 --> 00:05:16.279
But what's really important though is that it
is in fact a very large head on computation.

00:05:16.279 --> 00:05:21.119
It's, what's happening is instead of taking
the QuickTime fast path, where it can,

00:05:21.120 --> 00:05:25.459
it knows where on the screen the video's going to be and
just goes straight to that point, it actually has to render

00:05:25.459 --> 00:05:31.089
into an image and then pass that image to a browser,
where it'll composite it, depending on what other elements

00:05:31.089 --> 00:05:34.889
around it, that means below another
element or on top of another element.

00:05:34.889 --> 00:05:40.310
We found it's okay on Intel Macs,
but you should be definitely careful

00:05:40.310 --> 00:05:43.230
if you're going to be using it out on the web.

00:05:43.230 --> 00:05:49.590
And also, even more careful because this
feature is only supported in Safari.

00:05:51.410 --> 00:05:55.710
So now, let's say how do you actually
interact with the QuickTime plug-in?

00:05:55.709 --> 00:06:02.560
Well, using JavaScript, you do the very well known
JavaScript method, which is getElementByID.

00:06:02.560 --> 00:06:07.019
You get a reference to the embed tag
that returns an HTML embed object.

00:06:07.019 --> 00:06:12.829
But that object has extra parameters or extra
methods on it so that it's specific to QuickTime.

00:06:12.829 --> 00:06:17.209
So here I do a var movie, document.getElementID.

00:06:17.209 --> 00:06:18.989
Give it the ID of the embed element.

00:06:18.990 --> 00:06:25.800
You get multiple movie objects for every embed
you have, so you can control different movies.

00:06:25.800 --> 00:06:33.840
I'll just briefly discuss here the way you'd know
what's happening with the, why'd that put me off?

00:06:33.839 --> 00:06:37.250
Now I can work out what I'm saying.

00:06:37.250 --> 00:06:39.899
Sorry. Where was I?

00:06:39.899 --> 00:06:40.399
Yeah. plug-in.

00:06:40.399 --> 00:06:44.889
So you need to know, as the movie is loading,
you need to know what's happening with it?

00:06:44.889 --> 00:06:46.229
Is it still coming from the data?

00:06:46.230 --> 00:06:47.540
Is it enough to play?

00:06:47.540 --> 00:06:49.379
Is it actually playing?

00:06:49.379 --> 00:06:54.689
There's a method called .GetPluginStatus,
which returns a set of states so that you know

00:06:54.689 --> 00:06:59.209
within your script what the plug-in is actually
doing and then you can update your script.

00:06:59.209 --> 00:07:01.739
There's a new way to do that, which
you don't quite have access to,

00:07:01.740 --> 00:07:04.509
but hopefully you will soon, and I'll cover that soon.

00:07:04.509 --> 00:07:08.050
And of course, you can also access
more data about the video.

00:07:08.050 --> 00:07:16.699
You can ask for the size and check whether you've
got enough flow that you might want to start playing

00:07:16.699 --> 00:07:20.560
or that the video says that there's enough to start playing.

00:07:20.560 --> 00:07:25.120
So let's have a look at the other
methods on the JavaScript API.

00:07:25.120 --> 00:07:33.280
You'll see that in most cases, these mirror, the
QuickTime API's, so that they're fairly familiar

00:07:33.279 --> 00:07:39.619
to QuickTime programmers, play, stop,
obviously those are easy ones to understand,

00:07:39.620 --> 00:07:43.149
rewind just jumps back to the beginning of the movie.

00:07:43.149 --> 00:07:51.779
Step is, in fact, jumping the playback state forward by
some number of frames that you've passed in as a parameter.

00:07:51.779 --> 00:07:53.500
It also pauses the playback.

00:07:53.500 --> 00:07:59.730
GetRate and SetRate, if you're watching
a movie by default we give it a rate of one.

00:07:59.730 --> 00:08:02.140
That means it's going to playback in normal time.

00:08:02.139 --> 00:08:08.740
You can query the rate, or set the rate to be two and the
movies going to playback twice as fast as it was before.

00:08:08.740 --> 00:08:15.569
You can specify whether it should loop, as whether it should
loop once it hits the end it should go back to the start

00:08:15.569 --> 00:08:18.529
or it should go back to backwards, start playing backwards.

00:08:18.529 --> 00:08:21.149
You can also control the volume.

00:08:21.149 --> 00:08:28.259
This, of course, doesn't control the system volume,
so you can't take over the user's volume control,

00:08:28.259 --> 00:08:30.509
set the volume to 11 and blow their speakers.

00:08:30.509 --> 00:08:34.860
But you can, basically that volume's
the ratio within the plug-in itself

00:08:34.860 --> 00:08:37.720
and then the audio gets passed on to the system.

00:08:37.720 --> 00:08:46.029
You can also mute the plug-in which will keep the
volume level the same, but just not output any sound.

00:08:46.029 --> 00:08:51.870
So seeking around the video is a pretty useful thing to do.

00:08:51.870 --> 00:08:57.659
What you've got to be aware of is that the
way you seek is using units, video units.

00:08:57.659 --> 00:09:03.240
And so in every second of video a
number of units display to the screen.

00:09:03.240 --> 00:09:08.769
So you ask the time scale, which will tell you
how many units per second the QuickTime movie has

00:09:08.769 --> 00:09:14.079
and then you can sit and get the time which
tells you the, oops, have I done the right one?

00:09:14.080 --> 00:09:14.480
Yes I did.

00:09:14.480 --> 00:09:17.490
It gets the current time without
effecting the playback pause state.

00:09:17.490 --> 00:09:22.009
So that's, if you're manipulating the,
if you want to set to a particular time

00:09:22.009 --> 00:09:27.939
without turning the video back on if it was paused.

00:09:27.940 --> 00:09:31.900
A QuickTime movie by itself has
potentially a number of tracks in it.

00:09:31.899 --> 00:09:37.730
Typically you have a audio track, I'm sorry, a video track,
which is what you're,seeing, an audio track, which is what
you're hearing.

00:09:37.730 --> 00:09:41.820
But you can also have other audio tracks
or metadata tracks or time text tracks,

00:09:41.820 --> 00:09:45.660
which might be some form of subtitling or whatever.

00:09:45.659 --> 00:09:51.519
By default, the QuickTime plug-in will play
all the tracks that are media related.

00:09:51.519 --> 00:09:56.000
So if you actually have multiple tracks
you've got to be aware that for example,

00:09:56.000 --> 00:10:00.659
let's say that you have some video content with
the regular soundtrack and the directors cut

00:10:00.659 --> 00:10:03.029
or something, they're both going to play by default.

00:10:03.029 --> 00:10:05.259
So in fact, it's kind of confusing.

00:10:05.259 --> 00:10:08.669
But you have to be careful if you have
content like that the when the plug-in loads

00:10:08.669 --> 00:10:13.049
that you query the tracks and set
the right track to be playing.

00:10:13.049 --> 00:10:14.789
There's another example soon.

00:10:14.789 --> 00:10:20.349
So let's have a go through the code samples.

00:10:20.350 --> 00:10:23.860
First off, we got to ask for the
duration of the movie in seconds.

00:10:23.860 --> 00:10:30.550
So I start by getting a reference to the video element, then
again, as I said, I have to get a reference to the number

00:10:30.549 --> 00:10:39.000
of units of video that are played with each second and
what the total duration of the movie is and that allows me

00:10:39.000 --> 00:10:46.039
to divide the total number of units by the total number of
units per second and then I get the duration in seconds.

00:10:46.039 --> 00:10:53.059
The second example, suppose I'm playing back and I want
to skip back 10 seconds or skip forward 10 seconds,

00:10:53.059 --> 00:10:55.309
here I get a reference to the video element again.

00:10:55.309 --> 00:10:57.509
Or I could have kept it ran from the last time.

00:10:57.509 --> 00:11:07.069
I of course tell the movie to play, to skip forward or to
step forward from the current time and then I want to rewind

00:11:07.070 --> 00:11:12.080
in this case by 10, which is the number of
seconds, if I passed in times the number

00:11:12.080 --> 00:11:18.090
of units per second and then I tell the video to play again.

00:11:18.090 --> 00:11:24.389
More examples, if I want to double the playback speed, which
I've got an example later, I just basically set the rate

00:11:24.389 --> 00:11:26.750
to whatever the current rate was times two.

00:11:26.750 --> 00:11:33.580
If I want to enable a particular audio track, in this case I
say let's say I want to enable the audio track of index two,

00:11:33.580 --> 00:11:38.360
I loop through all of the audio tracks until
I find the one that's got the index two

00:11:38.360 --> 00:11:40.320
and just set it to be the enabled one.

00:11:40.320 --> 00:11:51.660
Setting the volume of a video with range control so,
in HTML since, since Safari was released for Tiger,

00:11:51.659 --> 00:11:55.439
there's been an HTML extension element called,

00:11:55.440 --> 00:12:00.680
an input tag where you can say type equals
range down at the bottom of the screen.

00:12:00.679 --> 00:12:06.859
What that means is on every other browser, except for Safari at the
moment, it appears as a regular input text field,

00:12:06.860 --> 00:12:10.289
but on Safari it recognizes that
and gives you a slider control.

00:12:10.289 --> 00:12:15.329
As more browsers implement this extension,
which is now part of the HTML 5 standard,

00:12:15.330 --> 00:12:20.800
you'll get browsers across interpolated
with browsers having the slider control.

00:12:20.799 --> 00:12:25.949
So in this example, I'm going to get
the reference to the video element

00:12:25.950 --> 00:12:28.890
and I just set the volume as a
fraction of the width of the range.

00:12:28.889 --> 00:12:33.049
It's a bit annoying with the range element,
you actually have to know how wide it is

00:12:33.049 --> 00:12:39.870
to set it's proportion along the axis, but
it's not necessarily you setting a percentage,

00:12:39.870 --> 00:12:41.560
you just have to work that out for yourself.

00:12:41.559 --> 00:12:48.119
It's important to note that volume goes from
zero to 256, because we're all computer geeks.

00:12:48.120 --> 00:12:53.669
Okay. So I discussed at the start what the
old method of interacting with a plug-in was,

00:12:53.669 --> 00:12:57.860
which was querying it's state to
work out what is actually happening.

00:12:57.860 --> 00:13:02.750
Well the way people normally program on the web is
they use events, which means you register yourself,

00:13:02.750 --> 00:13:04.899
or you register your function as an event handler.

00:13:04.899 --> 00:13:09.470
And when something happens, whether the event
is a mouse click, your function gets called

00:13:09.470 --> 00:13:13.220
and you do something with whatever you happen to want to do.

00:13:13.220 --> 00:13:19.540
Now in the QuickTime plug-ins there's now coming
up a set of events that you can listen to.

00:13:19.539 --> 00:13:25.189
They're based on something Apple proposed to the
HTML working group within WHATWG and WC3,

00:13:25.190 --> 00:13:29.510
so that hopefully part of the standard and
they'll be implemented by all browsers.

00:13:29.509 --> 00:13:35.659
These are much, much more convenient than using
the state attributes that we were using before.

00:13:35.659 --> 00:13:41.969
So an example is I can register myself for the
loaded event and I get told when the movie is loaded.

00:13:41.970 --> 00:13:45.870
I get my callback invoked when the movie is loaded.

00:13:45.870 --> 00:13:49.330
Or I might get my callback invoked
when the player is paused.

00:13:49.330 --> 00:13:56.139
So for example, I've got an HTML page, a custom
controller and the user has clicked on the video,

00:13:56.139 --> 00:14:01.429
which is going directly to the QuickTime plug-in,
it pauses itself because that's the way it behaves

00:14:01.429 --> 00:14:05.479
and it fires a pause event so that I,
as a webpage, can capture that event

00:14:05.480 --> 00:14:11.580
and set my custom control to look like it's in pause state.

00:14:11.580 --> 00:14:17.800
Another useful thing is you might want to do something
like display some kind of message or have something happen

00:14:17.799 --> 00:14:20.049
at a particular point and time in the video.

00:14:20.049 --> 00:14:25.519
You could, for example, have custom subtitle tracks that you
might have loaded from another source that you might want

00:14:25.519 --> 00:14:30.029
to overlay on the video that's come from
a site that you don't have control over.

00:14:30.029 --> 00:14:35.069
In which case, you could register points to say I want
this function to be called at these particular cue points

00:14:35.070 --> 00:14:40.870
in this time variable that's passed on to the
parameter and that callback method will be invoked

00:14:40.870 --> 00:14:45.549
when that time is being played in the video stream.

00:14:45.549 --> 00:14:48.459
You can also set in the parameters,
say, when you hit this cue point,

00:14:48.460 --> 00:14:51.750
please pause because I might want to do something.

00:14:51.750 --> 00:14:56.509
Okay. So let me give you a demo of some of these things.

00:14:56.509 --> 00:15:02.210
( Pause in speaking. )

00:15:02.210 --> 00:15:10.620
>> So this is just a, here in this case
I've loaded the feed of movie trailers

00:15:10.620 --> 00:15:15.610
that have come from the apple.com/trailers site.

00:15:15.610 --> 00:15:17.909
I can navigate through them.

00:15:17.909 --> 00:15:25.049
I can, let's peek one of my favorite movies here.

00:15:25.049 --> 00:15:31.109
And as I've told the plug-in not to play as
it's loaded, so it starts in the pause state.

00:15:31.110 --> 00:15:32.560
And I can hit play.

00:15:32.559 --> 00:15:34.949
And the movie should play.

00:15:34.950 --> 00:15:37.150
Hopefully.

00:15:37.149 --> 00:15:48.340
Now you see, what's happening here is the slider
beneath the video is an HTML range element, I'm sorry,

00:15:48.340 --> 00:15:51.780
HTML input element with type = range.

00:15:51.779 --> 00:16:01.970
As the plug-in is playing video I receive an event that
tells me what the updated position of time of video is

00:16:01.970 --> 00:16:06.540
and then I set the position of the dot along the slider.

00:16:06.539 --> 00:16:11.929
Now unfortunately the build of QuickTime that's
been shipped to you in Leopard and that's available

00:16:11.929 --> 00:16:15.599
on this computer doesn't capture the events as such.

00:16:15.600 --> 00:16:23.769
So in the newer builds as I press play I captured the
play event and I can do a custom method that sets the name

00:16:23.769 --> 00:16:29.319
of that button back to pause, so I can control
visually what the site of the controller is.

00:16:29.320 --> 00:16:32.530
So let's go back to trailers.

00:16:32.529 --> 00:16:40.889
Did I hit the right button?

00:16:40.889 --> 00:16:45.789
And another movie, in this case I've told the
plug-in not to, to respect the width and height

00:16:45.789 --> 00:16:48.509
of the video and to display the controller.

00:16:48.509 --> 00:16:49.919
So I'll show you here now.

00:16:49.919 --> 00:16:56.269
I'm initiating the playback of the video from within the
plug-in controls and I'm still getting the same events,

00:16:56.269 --> 00:17:01.909
the same events are still getting passed to my HTML page.

00:17:01.909 --> 00:17:08.099
So, this video, apart from being really cool for teenagers,

00:17:08.099 --> 00:17:14.129
also has multiple audio tracks, so
have the audio up just a little bit.

00:17:14.130 --> 00:17:17.360
Here I'll select a different audio track.

00:17:17.359 --> 00:17:22.990
Actually, this might be a bit loud.

00:17:22.990 --> 00:17:29.750
And all I'm doing is using the source code that was there
before to select a particular audio track that I've queried

00:17:29.750 --> 00:17:32.980
to plug-in to the movie is told me what it has.

00:17:34.099 --> 00:17:37.899
I can sneak around the plug-in.

00:17:37.900 --> 00:17:41.040
That's my favorite bit.

00:17:44.029 --> 00:17:46.299
Audio up a bit.

00:17:46.299 --> 00:17:52.509
I think the best way to watch a movie is like this.

00:17:52.509 --> 00:17:57.990
( Loud music.

00:18:03.460 --> 00:18:07.970
>> Lastly, again, this is another movie, Blades of Glory.

00:18:10.970 --> 00:18:21.089
These guys have hooked up a slider
to the volume of the plug-in.

00:18:21.089 --> 00:18:31.879
And again, in this case I don't have anything behind
it, but you can see the background is showing through.

00:18:31.880 --> 00:18:37.510
This is actually.

00:18:37.509 --> 00:18:49.180
( Loud music and movie playing. )

00:18:49.180 --> 00:18:52.509
>> So that's it of the demo.

00:18:52.509 --> 00:18:56.230
( Applause )

00:18:56.230 --> 00:18:59.400
>> I should thank the people behind the content there.

00:18:59.400 --> 00:19:07.850
So again, I just want to reiterate that there's already
been a number of sessions that have introduced this topic,

00:19:07.849 --> 00:19:12.139
so there's lots of data both on the Apple
website and in the media that you can get,

00:19:12.140 --> 00:19:14.380
along with this conference once it's up on the website.

00:19:14.380 --> 00:19:23.950
Session 611, which was called AJAX and QuickTime, or had
AJAX and QuickTime in the title, and also the apple.com,

00:19:23.950 --> 00:19:26.769
introduction to apple.com website has a lot of content.

00:19:26.769 --> 00:19:30.660
They've done an incredible amount
of custom controls of QuickTime.

00:19:30.660 --> 00:19:32.720
Not only that, you can use it as a reference.

00:19:32.720 --> 00:19:40.579
You go to apple.com, find a page that has some movies
in it, it's both on the iPod and iPhone page or the iPod

00:19:40.579 --> 00:19:45.279
and iTunes page, you can see examples where
they're replacing a movie with another movie,

00:19:45.279 --> 00:19:49.049
where they're controlling it with a customer control,

00:19:49.049 --> 00:19:52.639
where they use CSS to style
particular sliders and buttons of the movie.

00:19:52.640 --> 00:19:55.030
It's really quite impressive stuff.

00:19:55.029 --> 00:20:01.509
So with that, I will pass it on to Antoine
who will do similar things, but with SVG.

00:20:01.509 --> 00:20:09.470
( Applause )

00:20:09.470 --> 00:20:10.430
>> Antoine: Hi everyone.

00:20:10.430 --> 00:20:14.060
So first of all, thanks to Dean for
taking care of the stage so far.

00:20:14.059 --> 00:20:19.319
So the topic of this session was about rich media.

00:20:19.319 --> 00:20:22.769
And so far we've seen media, we've
seen a certain amount of richness.

00:20:22.769 --> 00:20:29.039
But HTML and CSS, even though they're pretty
powerful in terms of what you can do and people

00:20:29.039 --> 00:20:33.609
and authors have been taking CSS
and HTML design to the next level,

00:20:33.609 --> 00:20:37.279
and bringing compelling experiences,
such as on the apple.com website.

00:20:37.279 --> 00:20:43.440
But it's still not, at heart, a set of
graphics and really technology is designed

00:20:43.440 --> 00:20:49.059
to do extremely powerful graphics and animations.

00:20:49.059 --> 00:20:56.049
And it turns out that there's another technology out
there that's just brand new to Leopard and Safari 3

00:20:56.049 --> 00:21:04.809
and also the other platforms that Safari 3 is shipped on,
so Tiger and lesser known operating systems.

00:21:04.809 --> 00:21:15.000
And it turns out that this specification new to
Safari is actually made for graphics and rich media.

00:21:16.390 --> 00:21:21.259
So let's go quickly about a first
example of what SVG looks like.

00:21:21.259 --> 00:21:24.769
Before we get into more details,
just briefly what it's meant to do.

00:21:24.769 --> 00:21:31.180
In this case I'm just trying to draw a rectangle with
rounded corners, because that's what the web is like today.

00:21:31.180 --> 00:21:33.100
Everything has rounded corners.

00:21:33.099 --> 00:21:36.839
And we'll going to fill it in with a gradient just
to show we can do a little bit of graphics,

00:21:36.839 --> 00:21:40.109
not just about solid fields and etcetera.

00:21:40.109 --> 00:21:44.279
so an SVG graphics will have an SVG element as it's root.

00:21:44.279 --> 00:21:46.759
Just like in HTML you have an HTML element.

00:21:46.759 --> 00:21:53.079
You set its name space that a browser understands that
this is an SVG markup that you're dealing with.

00:21:53.079 --> 00:22:00.839
You set a view box to explain, to define a set of
local units for your accordance system that you'll use

00:22:00.839 --> 00:22:06.169
in y our composition and from that point on everything
will be specified as the child of the SVG element

00:22:06.170 --> 00:22:11.490
and will be directly handled by
the SVG renderer in your browser.

00:22:11.490 --> 00:22:15.150
In this case I want to define a linear
gradient, a linear gradient element.

00:22:15.150 --> 00:22:15.850
Pretty straight forward.

00:22:15.849 --> 00:22:18.240
You give it an element ID so you'll
be able to reference it later.

00:22:18.240 --> 00:22:22.950
Define it's direction using the X1
and Y1 and X2 and Y2 coordinates

00:22:22.950 --> 00:22:27.279
and then you can set as many number of stops as you wish.

00:22:27.279 --> 00:22:28.690
So in this case we have three stops.

00:22:28.690 --> 00:22:30.080
The first one's red, green and blue.

00:22:30.079 --> 00:22:34.279
Green in the middle with there's an arrow
here, it should be an offset of 0.5.

00:22:34.279 --> 00:22:35.990
apologies for that.

00:22:35.990 --> 00:22:38.650
And once we have defined our gradient
this doesn't reassure anything.

00:22:38.650 --> 00:22:42.660
It's just a paint server that we'll be able
to define and we'll be able to use later on.

00:22:42.660 --> 00:22:47.240
But now we're going to draw a rectangle
just using the rect elements, set the width,

00:22:47.240 --> 00:22:52.559
height and the radius for the corners
using the RX and RY attributes.

00:22:52.559 --> 00:22:55.619
In this case it would be 20 pixel
radius for rounded corners.

00:22:55.619 --> 00:23:02.529
Instead of transform to actually, translated to the center
the accordance system will be centered on the object so at

00:23:02.529 --> 00:23:09.960
that point we can scale it down from its middle, rotate
it 45 degrees and it's translated back to its origin.

00:23:09.960 --> 00:23:14.079
And finally we want to fill it with a gradient
so we register a point to our gradients.

00:23:14.079 --> 00:23:16.429
My gradient is in the URL construct.

00:23:16.430 --> 00:23:25.460
So sure enough, it just shows a rounded rectangle rotated
45 degrees with a nice little gradient, red, green and blue.

00:23:25.460 --> 00:23:29.289
So this is obviously very simple.

00:23:29.289 --> 00:23:33.519
But we'll get into more technical bits about SVG later,

00:23:33.519 --> 00:23:40.839
but I really wanted to spend a little time introducing
what the SVG technology actually was in context on the web.

00:23:40.839 --> 00:23:45.959
So as SVG, just like HTML and CSS, the DOM
and a lot of technologies that web designers

00:23:45.960 --> 00:23:52.410
and web application authors use today is the
standard from the W3C, the World Wide Web Consortium

00:23:52.410 --> 00:23:53.990
This means that it's royalty free.

00:23:53.990 --> 00:23:58.740
You don't have to worry about people
knocking on your door asking

00:23:58.740 --> 00:24:02.329
for crazy patenting money if you're implementing yourself.

00:24:02.329 --> 00:24:09.599
It also means that a variety of browsers are free to
implement this specification without having to take

00:24:09.599 --> 00:24:15.659
into account the strategy of a given company's standard.

00:24:15.660 --> 00:24:24.250
This is open, so just like HTML and CSS you'll find this
supported in Safari, but also in FireFox and also in Opera.

00:24:24.250 --> 00:24:31.380
And I think what is extremely compelling about SVG is that
with some technologies on the web today there are rich media

00:24:31.380 --> 00:24:35.350
and rich graphics and etcetera,
they're often delivered as a plug-in.

00:24:35.349 --> 00:24:41.779
They're often actually proprietary technologies, so it's
hard for browser makers to actually want to use those technologies

00:24:41.779 --> 00:24:46.759
because they don't really belong on the
web with a concept of open standards.

00:24:46.759 --> 00:24:49.359
But SVG is not like that.

00:24:49.359 --> 00:24:52.169
SVG is designed around markup just like HTML.

00:24:52.170 --> 00:24:55.630
It can use CSS for styling, just like HTML.

00:24:55.630 --> 00:24:58.670
If you want to program it you can
use just JavaScript and the DOM.

00:24:58.670 --> 00:25:04.000
They're the same set of API's and programming
language that we use with HTML and CSS.

00:25:04.000 --> 00:25:10.400
So that means that if you already have content out
there and surely anyone has built a web page or blog

00:25:10.400 --> 00:25:16.840
or use the web standards using WebKit and Cocoa
applications, you do not have to start back from scratch.

00:25:16.839 --> 00:25:22.869
You can take what you already have based on markup,
the same architecture, and just add graphics on top

00:25:22.869 --> 00:25:26.669
of that using SVG sporadically just
for the places where you may need it.

00:25:26.670 --> 00:25:29.289
And I think this is what really makes it unique.

00:25:29.289 --> 00:25:33.960
SVG is really at it's core, a web technology.

00:25:33.960 --> 00:25:40.240
So in terms of what SVG was designed for, besides
integrating nicely with markup, other markup languages

00:25:40.240 --> 00:25:46.809
and web standards, it was really here to
fill the need of rich graphics on the web.

00:25:46.809 --> 00:25:54.179
So the core of SVG, scalable vector graphics, sure
enough it's going to be about 2D vector based graphics.

00:25:54.180 --> 00:26:00.220
And on top of that, of course,
everything is representing XML.

00:26:00.220 --> 00:26:02.769
That means you can structure your
graphics any way you want it.

00:26:02.769 --> 00:26:08.839
There's concept of groups in SVG so you can group things
together, convert to symbols so you can define reusable

00:26:08.839 --> 00:26:13.099
assets that you will use further on in your
markup, etcetera.

00:26:13.099 --> 00:26:20.730
and just like HTML or XHTML, each part of the SVG structure
will be directly exposed as a JavaScript object

00:26:20.730 --> 00:26:23.450
which you'll be able to program using the DOM APIs.

00:26:23.450 --> 00:26:29.819
So this is a great difference compared to, for example,
Canvas, which doesn't really have an XML structure.

00:26:29.819 --> 00:26:30.939
There's no way to document format.

00:26:30.940 --> 00:26:33.140
It's more of a problematic API for graphics.

00:26:33.140 --> 00:26:36.860
In this case you really have a documented
model and something that is closer

00:26:36.859 --> 00:26:41.829
to what you're used to doing with web standard HTML.

00:26:41.829 --> 00:26:50.299
So the future of supporting SVG, sort of basic is
really what you expect from a modern graphics language,

00:26:50.299 --> 00:26:54.579
vector shapes, of course, this is SVG, Bezier curves, also.

00:26:54.579 --> 00:27:00.419
You need to be able to draw any kind of path that
you want, quadratic Bezier, cubic Bezier, and etcetera.

00:27:00.420 --> 00:27:02.070
you also have really precise text layout.

00:27:02.069 --> 00:27:07.980
You even have the possibility to define your
own fonts using SVG constructs to ensure

00:27:07.980 --> 00:27:13.160
that your font will have the exact aspect that
you want it to have on the web page when rendered.

00:27:13.160 --> 00:27:17.390
You can use linear radial gradients, you already
have seen how we can use linear gradients.

00:27:17.390 --> 00:27:18.990
Of course you have transparency.

00:27:18.990 --> 00:27:24.180
You can set transparency on the fill or on the stroke
independently or everything as a group that's composited

00:27:24.180 --> 00:27:26.980
against the background as one graphical entity.

00:27:26.980 --> 00:27:32.539
You can, of course, import raster
images either inline or by reference.

00:27:32.539 --> 00:27:37.470
So even though it's mostly a vector based language
you can also apply the concepts of transforms,

00:27:37.470 --> 00:27:42.670
etcetera through your raster graphics
buried inside your SVG composition.

00:27:42.670 --> 00:27:45.550
And we also have more advanced features, of course.

00:27:45.549 --> 00:27:50.589
For example you can draw text on a
curve, so if you need more of an artistic

00:27:50.589 --> 00:27:53.549
or more flexible text layout this
is something you can leverage.

00:27:53.549 --> 00:27:56.789
Like I said earlier, I mentioned
quickly you can use symbols.

00:27:56.789 --> 00:28:02.990
So any time you use a piece of SVG, if you give
it an ID, like a symbol that you'll need to reuse,

00:28:02.990 --> 00:28:07.700
like a legend on a map, or something like this,
you'll be able to reuse this using a simpler construct

00:28:07.700 --> 00:28:13.720
where you will not have to redefine all the
drawing information about this piece of graphics.

00:28:13.720 --> 00:28:16.420
And of course you can clip your
graphics, you can mask your graphics

00:28:16.420 --> 00:28:20.009
with any other shape you can express in the SVG language.

00:28:20.009 --> 00:28:23.730
You can use patterns, once again,
to define SVG to fill your shapes.

00:28:23.730 --> 00:28:30.069
You can use resolution independent filters
or live rendered real time on the browser,

00:28:30.069 --> 00:28:32.429
which will react to scaling and etcetera.

00:28:32.430 --> 00:28:37.000
you can do lightening effects, drop
shadows, embosses and etcetera.

00:28:37.000 --> 00:28:42.309
and of course because it is an interactive language,
it supports the DOM in JavaScripting, etcetera,

00:28:42.309 --> 00:28:46.200
you can also have animation working on all these properties.

00:28:46.200 --> 00:28:49.960
So we'll get to that a bit later, but
first, we need to cover the basics

00:28:49.960 --> 00:28:53.660
and understand what you can do
and how you draw things with SVG.

00:28:53.660 --> 00:28:55.330
So we've already seen an example of rectangle.

00:28:55.329 --> 00:29:01.119
This one is a square, I mean, not fully square
in this case, but sharp edges rectangle.

00:29:01.119 --> 00:29:02.839
It's not rounded.

00:29:02.839 --> 00:29:05.019
X and Y attributes, straight forward enough.

00:29:05.019 --> 00:29:10.059
We'll locate the top left corner of your rectangle.

00:29:10.059 --> 00:29:13.710
In SVG the coordinate system is top, bottom.

00:29:13.710 --> 00:29:17.650
So X20 and Y20 are up there as opposed
to being at the bottom of your screen

00:29:17.650 --> 00:29:20.450
like you would expect from most desktop environments.

00:29:20.450 --> 00:29:23.900
But on the web, things draw from top to bottom.

00:29:23.900 --> 00:29:27.490
So width and height, in this case, is set
up with the width and height attributes.

00:29:27.490 --> 00:29:29.660
So nothing really fancy here.

00:29:29.660 --> 00:29:31.460
However, you've done a rectangle straight away.

00:29:31.460 --> 00:29:32.890
You wouldn't have to program anything.

00:29:32.890 --> 00:29:35.009
It's just directly done by the declarative
markups.

00:29:35.009 --> 00:29:35.779
It's pretty handy.

00:29:35.779 --> 00:29:41.529
For a rounded rectangle, rx and ry,
set the radius for the x and y axis.

00:29:41.529 --> 00:29:49.329
A circle, define the circle center coordinate
using cx and xy and then the radius.

00:29:49.329 --> 00:29:54.859
Ellipse, which is I guess more generic case
of a circle, but as it also about semantics,

00:29:54.859 --> 00:29:59.449
so if you really deal with a circle you can
identify a circle as a circle and not as an ellipse

00:29:59.450 --> 00:30:02.259
that has the matching parameters to define a circle.

00:30:02.259 --> 00:30:08.650
So in this case, the ellipse, just like the circle,
takes a combination of coordinates to define its center

00:30:08.650 --> 00:30:14.980
and defines two different radius' for the
y axis an the x axis, using rx and ry.

00:30:14.980 --> 00:30:22.259
Polygon, this time we're using a list of points, so you'll
notice here that we actually have, instead of using markup

00:30:22.259 --> 00:30:25.750
to define the list of points as other
elements that could be a child of the polygon,

00:30:25.750 --> 00:30:29.160
we're actually stuff them all into
one attribute as a string.

00:30:29.160 --> 00:30:37.200
So some XML purists have questioned this approach, but I
personally feel that, given this is a really flat structure,

00:30:37.200 --> 00:30:42.430
it's just a list of points, boom, boom, boom, you go one
after another, there's really no point in having a hierarchy

00:30:42.430 --> 00:30:45.130
and additional weight in the DOM to represent this.

00:30:45.130 --> 00:30:49.280
So you'll see a few instances like this
in SVG full path data and transforms.

00:30:49.279 --> 00:30:54.680
You use micro synesis into, inside the attribute values.

00:30:54.680 --> 00:31:00.150
In this case, a list of points
and it will draw a lozenge.

00:31:00.150 --> 00:31:03.740
A path, once again, path elements like we expected.

00:31:03.740 --> 00:31:11.809
You can use all kinds of commands using the M command for
move to, C for cubic commands, Zed to close your path.

00:31:11.809 --> 00:31:15.869
There are way more commands that you can draw
any kind of path you can have an imagination for.

00:31:15.869 --> 00:31:21.529
And the kind of path you can draw of course
is something very form like the Apple Logo.

00:31:21.529 --> 00:31:23.529
The code for the Apple Logo would be a bit longer,

00:31:23.529 --> 00:31:27.480
but you get the idea of how you
could just draw a path on the screen.

00:31:27.480 --> 00:31:31.539
So now you know how to draw things but you
also need them to be filled with something

00:31:31.539 --> 00:31:32.759
so that they actually display on the screen.

00:31:32.759 --> 00:31:36.480
So far we kept that out of the
mark-up and just focused on geometry.

00:31:36.480 --> 00:31:40.210
But you can control the fill and
the stroke in SVG separately.

00:31:40.210 --> 00:31:44.440
We can use all kinds of ways to express your color values.

00:31:44.440 --> 00:31:51.460
So you can use a keyword like blue just the same as in CSS,
you can use an RGB construct with absolute values going

00:31:51.460 --> 00:31:55.190
from zero to 255, or actually Ua percentage value.

00:31:55.190 --> 00:31:58.490
You can use hexadecimal values.

00:31:58.490 --> 00:32:02.620
And so fill and stroke are set independently.

00:32:02.619 --> 00:32:07.369
And you can also set the opacity of fill and
stroke independently, using the fill and stroke opacity.

00:32:07.369 --> 00:32:14.559
So for example, the top right, bottom right corner
you can see a rectangle that has a stroke opacity of 0.5

00:32:14.559 --> 00:32:18.220
and you can see the stroke is overlaid
over another transparent fill.

00:32:18.220 --> 00:32:22.660
So you can see the effect of two
things that are semi opaque.

00:32:22.660 --> 00:32:28.360
Linear gradients, we're going to
skip this one because I already said

00:32:28.359 --> 00:32:31.750
in the introduction how you can define a gradient in SVG.

00:32:31.750 --> 00:32:33.130
Radial gradients is very similar.

00:32:33.130 --> 00:32:36.930
Just change the name of the element to be
radial gradient and not a linear gradient.

00:32:36.930 --> 00:32:44.660
We find the center from zero to one in the overall scale
of the gradient and radius as well and there you go.

00:32:44.660 --> 00:32:45.950
You have your radial gradient.

00:32:45.950 --> 00:32:54.350
Once again you could use many stops in a radial gradient
and you can actually also use the stop opacity attribute

00:32:54.349 --> 00:32:57.849
to have your gradient have various opacity along the way.

00:32:57.849 --> 00:33:02.009
So, for example, if you wanted to do like a
simple drop shadow you could have two black stops.

00:33:02.009 --> 00:33:07.539
The first one with a stop opacity of one and
the last one with a stop opacity of zero.

00:33:07.539 --> 00:33:11.710
So I mentioned that you could do clipping in SVG.

00:33:11.710 --> 00:33:17.890
You create first a clip method that does
not render itself, but will define the shape

00:33:17.890 --> 00:33:20.880
of the clip path you'll be able to use later on.

00:33:20.880 --> 00:33:27.460
So in this case we use an ellipse illustrated in the
middle of the screen and we'll apply it to a rectangle

00:33:27.460 --> 00:33:34.529
so the geometry of the rectangle is changed
by the clip once we apply the clip attribute.

00:33:34.529 --> 00:33:37.879
Point it to the original clip that it will
find and it will clip it dramatically.

00:33:37.880 --> 00:33:42.140
So you can see at the bottom of the screen
the results of the actual clipping operation.

00:33:42.140 --> 00:33:46.470
So once again, just like linear and
radial gradients, you can define assets.

00:33:46.470 --> 00:33:47.710
Your clip path is an asset.

00:33:47.710 --> 00:33:53.150
If you want to clip several shapes on your
document using the same clip path, no problem.

00:33:53.150 --> 00:33:56.330
You can always use the URL construct to point to it.

00:33:56.329 --> 00:34:04.000
But as obviously I'm not going to cover all of the graphics
future, you'll, developers and you'll, I'm sure very smart,

00:34:04.000 --> 00:34:09.159
so you'll be able to browse around the web, look at some
examples, look at the specifications if you're really brave

00:34:09.159 --> 00:34:15.949
and courageous and you'll find out all about the vast
array of graphics primitives in the SVG language.

00:34:15.949 --> 00:34:19.059
But before moving on to scripting
and more advanced features,

00:34:19.059 --> 00:34:22.449
I just want to show first of all
how we can use CSS with this.

00:34:22.449 --> 00:34:28.049
So far we've only used XML to define
paints and etcetera in the language,

00:34:28.050 --> 00:34:31.410
but in this case where it can define a
class, just like it would in HTML or CSS.

00:34:31.409 --> 00:34:36.649
This class called mr-f, you define
a fill and a stroke and a stoke width,

00:34:36.650 --> 00:34:38.570
they look the same as the XML attributes.

00:34:38.570 --> 00:34:43.250
They're just mirrored as CSS properties
that you can use in a class

00:34:43.250 --> 00:34:46.010
or you can actually use them in a style attribute as well.

00:34:46.010 --> 00:34:48.080
So in this case, we used the style attribute as opposed

00:34:48.079 --> 00:34:54.539
to a fill attribute we'd just use a fill
property as a value for a style attribute.

00:34:54.539 --> 00:35:00.690
So this is how we can draw text and this is how you
can put text on screen, xy coordinates, pretty simple,

00:35:00.690 --> 00:35:07.280
which will define the bottom left corner,
the baseline of your piece of text.

00:35:07.280 --> 00:35:09.910
This is how you can also apply a transform to your text.

00:35:09.909 --> 00:35:14.089
Of course it's all vector based and your text
will be rendered with vectors in composition

00:35:14.090 --> 00:35:21.400
and you can apply scaling, rotation, whatever comes to your
mind and whatever you need to achieve your graphical effect.

00:35:21.400 --> 00:35:26.079
In this case we show how we can use a
class we defined earlier on a rectangle,

00:35:26.079 --> 00:35:28.329
we just use the class attribute, just like in HTML.

00:35:28.329 --> 00:35:29.400
Very straight forward.

00:35:29.400 --> 00:35:31.730
So the rectangle you see on screen here is in that class.

00:35:31.730 --> 00:35:35.380
The fill and the stroke are respected
and the stroke width as well.

00:35:35.380 --> 00:35:39.710
And to show how we can use, define and use all these assets,

00:35:39.710 --> 00:35:47.559
in this case the first path will be the smaller
Apple Logo displayed on the bottom left in white.

00:35:47.559 --> 00:35:52.489
And we use it afterwards with the use elements, which
means that basically I'm not going to define a new set

00:35:52.489 --> 00:35:55.769
of graphics, I'm just going to reuse
something that's already been defined.

00:35:55.769 --> 00:35:58.349
So I point to the existing piece
of graphics with the xlink:href

00:35:58.349 --> 00:36:05.119
We used a hash to locate a local resource, in this case
going back to the Logo and from that point on I can change,

00:36:05.119 --> 00:36:10.759
its look and feel its transforms etcetera
without changing the original piece of graphics.

00:36:10.760 --> 00:36:13.540
So I'll apply transform, scale
it and rotate it a little bit,

00:36:13.539 --> 00:36:20.869
and I will also use the CSS class I've
already used to define its look and feel.

00:36:20.869 --> 00:36:27.500
So these are a few of the most basic features
of SVG that I really wanted to cover.

00:36:27.500 --> 00:36:31.420
Because this is basically how you draw
things and how you structure things.

00:36:31.420 --> 00:36:36.430
And once you understand what the SVG tree looks like and
what SVG elements look like then you better understand how

00:36:36.429 --> 00:36:42.190
to use the DOM APIs and scripting, you can directly
update things that are rendered on the screen.

00:36:43.579 --> 00:36:48.269
So SVG scripting will allow you to basically add
interactivity and animation to your graphics.

00:36:48.269 --> 00:36:53.780
It's not all about however nice it
is to have this nice XML based language

00:36:53.780 --> 00:36:56.660
to draw graphics, this is not going to cut it for you.

00:36:56.659 --> 00:37:01.019
You want something that has a lot of impact, you
want the user to have a new experience on the web

00:37:01.019 --> 00:37:06.429
and in your web application, and you really
need JavaScripts and animated effects for that.

00:37:06.429 --> 00:37:12.419
So the basic of the DOM scripting is that
it's working against the XML structure.

00:37:12.420 --> 00:37:19.430
The DOM is a set of generic APIs against XML just to
manipulate, update, read and write into your XML structure.

00:37:19.429 --> 00:37:23.519
So these are the same APIs that people use
on the web today in their web applications.

00:37:23.519 --> 00:37:27.539
All the things you hear about AJAX
and etcetera on the AJAX libraries,

00:37:27.539 --> 00:37:29.679
they'll wrappers against these kind of functionalities.

00:37:29.679 --> 00:37:33.929
They will offer high level things but they
undoubtedly will be using that as an interface

00:37:33.929 --> 00:37:36.969
with the XML tree rendered on the screen.

00:37:36.969 --> 00:37:39.179
So each part of the tree is represented by DOM objects.

00:37:39.179 --> 00:37:43.339
So if you have a rect element it will be an
element in which you can set a width and height

00:37:43.340 --> 00:37:47.720
and etcetera to update the geometry of the element.

00:37:47.719 --> 00:37:51.359
This is all expose in JavaScript.

00:37:51.360 --> 00:37:56.470
And you have different classes of APIs
available to you in the core DOM APIs.

00:37:56.469 --> 00:37:57.849
The first one is navigation.

00:37:57.849 --> 00:38:01.069
Before you can reach something
in your document to update it,

00:38:01.070 --> 00:38:03.860
you need to navigate to it and
there are different ways to do that.

00:38:03.860 --> 00:38:09.460
If you want to iterate, if you want to find the parents of
your current element, if you want to remove it, for example,

00:38:09.460 --> 00:38:12.320
or etcetera, you can use a parentNode field.

00:38:12.320 --> 00:38:18.289
If you want to find a list of the nodes that will be a
child of your current element, you can use the childNodes.

00:38:18.289 --> 00:38:21.559
You can use the first child to get to the
first element and then you can iterate

00:38:21.559 --> 00:38:24.239
through them using the childNodes property.

00:38:24.239 --> 00:38:25.659
Oh, what happened there?

00:38:25.659 --> 00:38:27.629
I think I paused it.

00:38:27.630 --> 00:38:31.220
Mishap. You can use the getElementByID
method to point to an object

00:38:31.219 --> 00:38:34.809
that you already identified in markup using an ID attribute.

00:38:34.809 --> 00:38:41.539
Dean already showed that in his demonstration to
get a pointer to a video element, for example.

00:38:41.539 --> 00:38:44.779
And you can also get a list of
elements that match a certain criteria.

00:38:44.780 --> 00:38:50.730
So in this case, with the getElementsByTagNameNS, if I
set the name space to be the SVG name space and the name

00:38:50.730 --> 00:38:55.550
to be rect, for example, I would get a list of all
the rectangles from that point on in the hierarchy

00:38:55.550 --> 00:38:59.120
and I would be able to iterate through them, for
example if I wanted to change their look and feel,

00:38:59.119 --> 00:39:04.869
if I wanted to remove all of them in one go,
etcetera, or add a new piece of interactivity to them,

00:39:04.869 --> 00:39:09.639
I would use these kind of APIs
to navigate through each of them.

00:39:09.639 --> 00:39:14.379
So once you have pointed to elements and you know how
to navigate, you need to do something with the elements.

00:39:14.380 --> 00:39:18.640
You have a pointer, you have a handle, a rectangle,
you want to change it's width or it's height,

00:39:18.639 --> 00:39:22.099
you want to read what its state
is before you do anything to it

00:39:22.099 --> 00:39:25.809
and in that case you'll need to
see what the attribute values are.

00:39:25.809 --> 00:39:30.920
So you can use the getAttributeNS method,
pressing once again a new space in attribute value,

00:39:30.920 --> 00:39:34.159
or you can use the setAttributeNS
method to change the value.

00:39:34.159 --> 00:39:37.789
In that case you'll pass an extra
parameter to set the value.

00:39:37.789 --> 00:39:42.400
And if you're dealing with text content you want
to read what's inside for example a text element

00:39:42.400 --> 00:39:48.119
or to change the value of that text element, then you will
use the textContent fill, which is a read write property.

00:39:49.750 --> 00:39:50.550
But that's not all.

00:39:50.550 --> 00:39:56.519
SVG will not just be about what you already
have in your document when you load scripts.

00:39:56.519 --> 00:40:01.099
It will be about you able to create
a new document on the fly.

00:40:01.099 --> 00:40:03.889
So for example you could create a drawing app in SVG.

00:40:03.889 --> 00:40:08.329
What you originally have in SVG document that's
completely empty and as the user interacts

00:40:08.329 --> 00:40:11.049
with it you can add new elements to the DOM Tree.

00:40:11.050 --> 00:40:16.970
And the way this is done basically is you need to
create a new element, a createElementNS method.

00:40:16.969 --> 00:40:22.709
Once again you'd give it a name space so you could create
both HTML elements and SVG elements and you give it a name.

00:40:22.710 --> 00:40:27.470
once you've done that then you can also create
text nodes which are different from elements.

00:40:27.469 --> 00:40:35.079
So if you want to have a text element, you also need
to create a text node through presets text value.

00:40:35.079 --> 00:40:40.259
And once you, so of course when you've created
an element you can use the setAttribute method

00:40:40.260 --> 00:40:42.850
that I outlined above to set its values.

00:40:42.849 --> 00:40:46.119
And once you have it done you have
to put it in the tree so it renders.

00:40:46.119 --> 00:40:51.710
So now you can use the appendChild method that
will add a new piece of graphics in your tree,

00:40:51.710 --> 00:40:55.510
or you can remove something that's already
in the tree using the removeChild function.

00:40:55.510 --> 00:41:01.880
So these really are the more basic, the most basic
functions you will see used on the web today.

00:41:01.880 --> 00:41:02.840
So some samples.

00:41:02.840 --> 00:41:05.970
In this case I'm creating rectangle elements.

00:41:05.969 --> 00:41:12.299
Now I'm getting a handle to what is probably a
text element that is identified with the mytext id

00:41:12.300 --> 00:41:20.970
and then we'll update it's content to print
Hello World, which I'm sure you're pretty familiar with.

00:41:20.969 --> 00:41:28.129
And in this case I will probably have a handle to a
rectangle elements and it will change it's width to be 100.

00:41:28.130 --> 00:41:33.440
these are really simple ways that you
can update or create content in the DOM.

00:41:33.440 --> 00:41:40.490
In this case I have a function that creates a rectangle
given x y, width and height, create elements,

00:41:40.489 --> 00:41:48.009
(inaudible) space and erects a string to give the element
name of the element I'm creating, setting the attribute xy,

00:41:48.010 --> 00:41:52.810
width height with the parameters I'm giving it and then
return that element then the user will be able to append

00:41:52.809 --> 00:41:57.529
to the tree at whatever location he feels happy to do so.

00:41:57.530 --> 00:41:59.160
Very simple.

00:42:00.929 --> 00:42:04.829
But of course, if we're dealing
with interactivity rich media,

00:42:04.829 --> 00:42:07.340
you want to be able to react to what the user is doing.

00:42:07.340 --> 00:42:12.000
And interactivity is all about this,
it's about how you react to UI events.

00:42:12.000 --> 00:42:17.809
So the first way you can react to UI events is not
actually using SVG script, JavaScripting at all.

00:42:17.809 --> 00:42:23.349
Just like in HTML when you can use CSS pseudo
classes to react to an over state or a focus state,

00:42:23.349 --> 00:42:27.369
you can have nice new hover effects
on your links or whatever,

00:42:27.369 --> 00:42:30.380
in SVG you can actually use the
same thing on any of the elements.

00:42:30.380 --> 00:42:35.079
It is using CSS just like any web technology should.

00:42:35.079 --> 00:42:40.309
So this is really, you should really use this
when you don't need to apply any logic really

00:42:40.309 --> 00:42:43.519
to your change of state, it's just really a behavior.

00:42:43.519 --> 00:42:49.909
So if you have a button that just highlights
when the user has the mouse over it,

00:42:49.909 --> 00:42:52.679
then you can really very easily achieve that using CSS.

00:42:52.679 --> 00:42:53.549
No code required.

00:42:53.550 --> 00:42:58.820
Just updating the property that
will be applied to the element.

00:42:58.820 --> 00:43:03.070
You can, of course, just like in HTML
once again, use marker based handlers.

00:43:03.070 --> 00:43:09.010
So if you know there's already a piece of script
that you would have run on an element always,

00:43:09.010 --> 00:43:14.210
then you can just use that as opposed to adding it
programmatically, which is what you'll really need

00:43:14.210 --> 00:43:18.079
when you start generating graphics and you
need to attach a behavior call by script.

00:43:18.079 --> 00:43:22.150
While in this case, you'll have the most
flexibility, you'll use the addEventListener method,

00:43:22.150 --> 00:43:28.410
you'll be able to add many different handlers for the same
events as opposed to changing it if you change the value

00:43:28.409 --> 00:43:33.049
of the onclick or onmouseover attributes, in
this case you can just add just more handlers one

00:43:33.050 --> 00:43:36.789
by one, just adding them to your element.

00:43:36.789 --> 00:43:41.400
And this is really good when you need to deal with
a really dynamic, and this is a user interface

00:43:41.400 --> 00:43:44.610
and this is really the real way to do
it if you're a JavaScript programmer.

00:43:44.610 --> 00:43:48.150
This is what will give you more flexibility and most power.

00:43:49.820 --> 00:43:56.039
But SVG is pretty different to what HTML is.

00:43:56.039 --> 00:43:59.719
In HTML most of the things are defined either using CSS

00:43:59.719 --> 00:44:04.329
or some of the HTML attributes will be
directly rendered as is on the screen.

00:44:04.329 --> 00:44:09.340
It's easy to make a mapping between the actual value
defined in markup than what happens on the screen.

00:44:09.340 --> 00:44:13.070
But with SVG it's actually, it goes beyond that.

00:44:13.070 --> 00:44:18.920
If you're drawing a path, for example, you'll be
giving the SVG implementation list of commands

00:44:18.920 --> 00:44:22.289
that will automatically handle
and render on the screen for you.

00:44:22.289 --> 00:44:27.440
And if you want to know (inaudible) of this, well there is
no width or height attribute that you could query directly.

00:44:27.440 --> 00:44:33.360
So you really need something that will abstract
all of this to give you real graphics capabilities.

00:44:33.360 --> 00:44:37.990
So the core DOMs only expose the
string values, so this is an issue.

00:44:37.989 --> 00:44:43.159
The SVG language specificities, there's
micro synesis like I talked about before,

00:44:43.159 --> 00:44:47.159
now complex types exposed really a core to graphics.

00:44:47.159 --> 00:44:52.339
And, well, if you're a graphic programmer you're not
going to want to use just string based operation itself,

00:44:52.340 --> 00:44:55.530
you're going to want to have real graphics tools.

00:44:55.530 --> 00:44:58.760
So for this, the SVG language also extends the DOM.

00:44:58.760 --> 00:45:03.080
It defines a new set of APIs called the
SVG DOM that compliment the existing DOM.

00:45:03.079 --> 00:45:06.219
You can always use the preceding APIs I told you about.

00:45:06.219 --> 00:45:06.779
This is fine.

00:45:06.780 --> 00:45:10.790
But if you need a little bit of
graphics oriented programming,

00:45:10.789 --> 00:45:13.869
you'll be able to resort to the other APIs from the SVG DOM.

00:45:13.869 --> 00:45:19.400
So for example you'll have typed access to
attributes, so if you want the width as an integer,

00:45:19.400 --> 00:45:22.720
you'll be able to access this directly
as opposed to parsing a string.

00:45:22.719 --> 00:45:29.980
You'll be able to get access to computed values if you
have, for example, transforms that add on one to another

00:45:29.980 --> 00:45:33.030
through the tree, first to translate
then to scale and rotate.

00:45:33.030 --> 00:45:35.950
You don't want to keep track of
that and climb up and down the tree.

00:45:35.949 --> 00:45:39.799
And SVG will be able to query directly what happens there.

00:45:39.800 --> 00:45:44.690
It'll be the same when you need to know
about a bounding box for example and etcetera.

00:45:44.690 --> 00:45:47.619
so let's see how that works.

00:45:47.619 --> 00:45:50.480
First of all there are built in data types in SVG.

00:45:50.480 --> 00:45:53.429
So vector language will have to
define what a point is, for example.

00:45:53.429 --> 00:45:56.399
This is really basic in vector graphics.

00:45:56.400 --> 00:45:59.970
So we have an SVG point interface in SVG.

00:45:59.969 --> 00:46:04.849
Very simple, give an x and a y
attribute, nothing really fancy there.

00:46:04.849 --> 00:46:08.130
But it gives you also a matrix transform method.

00:46:08.130 --> 00:46:15.440
So other parts of the SVG DOM will feed you back a matrix
from a computed transform matrix applied to an element

00:46:15.440 --> 00:46:19.880
or something like this and you will be able to
apply such a matrix to your points if you need

00:46:19.880 --> 00:46:25.590
to change the coding points of your system for example,
this is definitely what you'll be using, matrixTransform.

00:46:25.590 --> 00:46:32.760
So that's a first example of graphics features
and computations that I exposed in the SVG DOM.

00:46:32.760 --> 00:46:35.480
There's also the SVGRect data type.

00:46:35.480 --> 00:46:37.880
xy within height, pretty simple.

00:46:37.880 --> 00:46:43.110
And the SVGMatrix data type, which we can fit into a
matrix transform call on SVG point and this is the

00:46:43.110 --> 00:46:45.900
type that will always be returned when
you're dealing with a transformed,

00:46:45.900 --> 00:46:50.450
a computer transformed that goes all
the way up to the screen, etcetera.

00:46:50.449 --> 00:46:56.799
it will always be obstructed behind a nice data type,
on which you can call a sort of familiar operations

00:46:56.800 --> 00:47:04.420
so you no longer have to create your own methods about how
you go about computing matrixes and changes to a matrix.

00:47:04.420 --> 00:47:10.619
In this case, if you have the matrix of an element and
just want to rotate it, you can just use a rotate method.

00:47:10.619 --> 00:47:16.670
And the same with scaling, translating, you can invert
your matrix, you can multiply it with another matrix.

00:47:16.670 --> 00:47:21.869
It really caters to all the needs
you have with matrix programming.

00:47:21.869 --> 00:47:24.299
And to obtain those data types that you want to work with,

00:47:24.300 --> 00:47:30.630
they're all available in the SVGSVGElement
interface represents an SVG element.

00:47:30.630 --> 00:47:33.039
All the interfaces in the SVG are prefixed with SVG,

00:47:33.039 --> 00:47:36.679
so in this case here's an SVG interface
for the element with the name SVG.

00:47:36.679 --> 00:47:38.919
It's a pretty funny name, but.

00:47:38.920 --> 00:47:45.430
And you, on this object you'll be able to call
createSVGPoints, quite, createSVGMatrix, createSVGRect

00:47:45.429 --> 00:47:51.679
and etcetera so you can create on the fly
some of those instances of those classes.

00:47:51.679 --> 00:47:55.000
There are more key graphics API building
on top of this data type of course,

00:47:55.000 --> 00:47:58.170
and they're all located on this
interface called SVGLocatable.

00:47:58.170 --> 00:48:05.530
SVGLocatable is a high level interface that's implemented
by each element that will draw something on the screen.

00:48:05.530 --> 00:48:08.480
They're all part of the core functionality
of graphics programming.

00:48:08.480 --> 00:48:11.969
And these functions, for example,
getBBox, you have this element,

00:48:11.969 --> 00:48:14.329
you have a group of elements, it's very complex graphics.

00:48:14.329 --> 00:48:16.579
There may be hundreds of elements surrendered together.

00:48:16.579 --> 00:48:22.039
Call getBBox, it will feed back an SVGRect element
with all the information you need to know about.

00:48:22.039 --> 00:48:23.639
GetTransformToElement.

00:48:23.639 --> 00:48:28.179
This will take you from one piece of
the tree to a higher piece of the tree

00:48:28.179 --> 00:48:32.199
and just give you the transformation
matrix going from one point to another.

00:48:32.199 --> 00:48:37.639
So, for example, you're clicking in the high level
coordinate space and you want to know exactly what

00:48:37.639 --> 00:48:45.529
that coordinate is with respect to a rectangle inside of a
document using this method or actually against getScreenCTM

00:48:45.530 --> 00:48:52.500
which will go all the way up to the host pixel
coding system will help you to convert units.

00:48:52.500 --> 00:48:53.860
Very helpful.

00:48:53.860 --> 00:48:58.150
And this API is really key when you're
building a scalable user interface.

00:48:58.150 --> 00:49:00.740
You don't want to have everything
rendered in the same coordinates system.

00:49:00.739 --> 00:49:06.289
You want something rich and you want something you can
manipulate with transforms and matrices and these kinds

00:49:06.289 --> 00:49:14.070
of methods will extract that all away from you so
that you can just focus on graphics related tasks.

00:49:14.070 --> 00:49:18.690
So for example making use of some
of the functionalities highlighted.

00:49:18.690 --> 00:49:25.820
This function, getMouseCoordsInContext will allow
you to click anywhere on the screen and get the coordinates

00:49:25.820 --> 00:49:31.370
of the mouse not related to the view port of the document,
like you usually have using clientx and clienty,

00:49:31.369 --> 00:49:33.579
but actually getting it within the shape.

00:49:33.579 --> 00:49:37.929
So if you're sitting on the top left corner of the rectangle
that's all the way down, translated and rotated and whatever,

00:49:37.929 --> 00:49:43.219
in your document, you will be able to get the coordinates
that will be like one pixel up and one pixel down.

00:49:43.219 --> 00:49:47.029
So the way you do that is first you create an SVG point.

00:49:47.030 --> 00:49:53.330
Because you will be able to create that point with a matrix,
you've set the x and y coordinates to be the coordinates

00:49:53.329 --> 00:50:00.299
of the events that have been triggered on your
elements and the context is the element that you want

00:50:00.300 --> 00:50:03.780
to have the coordinates returned local to.

00:50:03.780 --> 00:50:06.210
So in this case you call a getScreenCTM function

00:50:06.210 --> 00:50:14.050
on this context it would give you the computer transform
all the way up to the pixel based coordinate system.

00:50:14.050 --> 00:50:19.539
And once you have this matrix inversed, because you
want to go all the way in the opposite direction,

00:50:19.539 --> 00:50:24.079
and you can apply the transformation to your
regional mass coordinates past the matrix

00:50:24.079 --> 00:50:27.340
and return that object to the user.

00:50:27.340 --> 00:50:29.160
Very straight forward.

00:50:30.190 --> 00:50:36.280
So this is how you can do interactivity and you
can program graphically against your SVG content.

00:50:36.280 --> 00:50:37.700
But of course, which media will be about animation?

00:50:37.699 --> 00:50:40.169
This is the number one thing you'll want to do.

00:50:40.170 --> 00:50:44.730
You'll want to be able to react to
the user, to the user's interaction

00:50:44.730 --> 00:50:49.740
and not just change graphic state
discreetly, directly on the screen.

00:50:49.739 --> 00:50:51.369
You'll want to have transitions.

00:50:51.369 --> 00:50:54.839
You'll want to have things fitting in,
fitting out, popping out and etcetera.

00:50:54.840 --> 00:50:58.970
the kind of thing that you see on the web today, and that
you probably didn't think were possible in a browser.

00:50:58.969 --> 00:51:04.839
Well, it turns out with SVG and JavaScript and the DOM
you can really create a pretty compelling presentation.

00:51:04.840 --> 00:51:09.590
So the key to doing animation is using the built
in function in JavaScript called setInterval.

00:51:09.590 --> 00:51:15.590
This will allow you to call a piece of code repeatedly
over time until you figure out the state you wanted has been reached

00:51:15.590 --> 00:51:19.120
and then you can cancel the timer using clearInterval.

00:51:19.119 --> 00:51:24.469
So, for example, a way you would go about
fading an element, you would pass an element

00:51:24.469 --> 00:51:28.209
to this custom function called fade
you would figure out the current time

00:51:28.210 --> 00:51:33.750
so you can tell how long the animation,
when the animation starts.

00:51:33.750 --> 00:51:40.860
In this case we'll set the duration to be 2000 milliseconds,
so two seconds, and at that point we create our interval.

00:51:40.860 --> 00:51:46.840
We keep our pointer to that interval
so that we can cancel later.

00:51:46.840 --> 00:51:51.510
So restoring the variable core interval and we pass
to that set interval function a special function

00:51:51.510 --> 00:51:54.960
that will actually be called to perform that animation.

00:51:54.960 --> 00:51:58.590
So each time we iterate we get the current
time to do the down time between the start time

00:51:58.590 --> 00:52:01.309
and the current time and find out when we over the time.

00:52:01.309 --> 00:52:07.789
Once we over the time and we figure out a process is
beyond one then when we clear interval, the animation will,

00:52:07.789 --> 00:52:10.610
this will be the last iteration of the animation.

00:52:10.610 --> 00:52:15.440
But each time we iterate through that
animation, we will set the opacity attributes

00:52:15.440 --> 00:52:20.820
to be whatever our progress is subtracted from one.

00:52:20.820 --> 00:52:27.390
So basically you will be fading in from opacity
one step by step all the way to opacity zero.

00:52:27.389 --> 00:52:31.920
This is a more advanced effect

00:52:31.920 --> 00:52:36.180
In this one we won't just fade we'll
also apply a snazzy little effect.

00:52:36.179 --> 00:52:39.440
We'll scale the element down and
we'll rotate it so it'll look

00:52:39.440 --> 00:52:45.179
like it just disappears very neatly
and graphically on the screen.

00:52:45.179 --> 00:52:47.569
So in that case we'll have to do a little but more work.

00:52:47.570 --> 00:52:52.880
First of all, if you want to rotate things around their
center in SVG, we'll have to figure out what the center is

00:52:52.880 --> 00:52:58.829
so you can translate the coordinates system to that point
and translate it back so that it's rendered in place.

00:52:58.829 --> 00:53:04.619
So first of all, to find out what the center of that element
is, whatever kind of element it is, it could be path,

00:53:04.619 --> 00:53:09.579
it could be a set of objects, it could be a rectangle,
I don't need to know exactly the semantic of the object.

00:53:09.579 --> 00:53:12.130
All I know is there's a graphic
object and it's good enough for SVG.

00:53:12.130 --> 00:53:15.329
Well just give you the bounding
boxes and the getBBox method.

00:53:15.329 --> 00:53:24.009
Once I know that I will divide the width and the height
of these by two and add the x and the y coordinates

00:53:24.010 --> 00:53:28.050
so that I know what the center is,
store these in tx and ty attributes,

00:53:28.050 --> 00:53:31.830
as I will be using them for translations later on.

00:53:31.829 --> 00:53:35.799
And then I will get a pointer to the
transform of our current element.

00:53:35.800 --> 00:53:39.850
Because the transform is an SVG transform
object, I'll be able to perform special actions on it

00:53:39.849 --> 00:53:45.440
so the transfer will be updated directly
without having to re-serialize in an XML form.

00:53:45.440 --> 00:53:51.929
I also get the matrix from that transform in
consolidating whatever transform parameters you may already have.

00:53:51.929 --> 00:53:56.190
That shape may well already have a
translation to it, a rotation and etcetera.

00:53:56.190 --> 00:54:00.710
I do not want to get rid of that, I just want
that to be available to me in a nice matrix.

00:54:00.710 --> 00:54:04.639
So I consolidate the transform and I
get the matrix form of that transform.

00:54:04.639 --> 00:54:11.329
And from that point on, I have subtracted , in this case,
the animation code we saw in the previous slide in a class

00:54:11.329 --> 00:54:16.349
that will be called animator, which will abstract
the iteration and checking on the time for me,

00:54:16.349 --> 00:54:21.989
so I can focus on the code here, but basically this
animator will run for 2 seconds, 2000 milliseconds,

00:54:21.989 --> 00:54:26.349
and each time it will figure out what the new
scale is, so it will be one minus the progress.

00:54:26.349 --> 00:54:32.480
The rotation angle would be going from zero to thirty
degrees, so we multiply 30 by the progre0ss and we will,

00:54:32.480 --> 00:54:40.360
at that point, reinitialize the transform to be
whatever the matrix, our new matrix that we will apply

00:54:40.360 --> 00:54:45.620
by translating the object to its center then
scale it, then rotate it to our new angles,

00:54:45.619 --> 00:54:48.259
and translate it back so it's nicely in place.

00:54:48.260 --> 00:54:53.310
This will give you an object that will just
scale down and rotate at the same time.

00:54:53.309 --> 00:54:59.059
And of course we (inaudible) so just like in the
previous example, we update the opacity attribute.

00:54:59.059 --> 00:55:05.309
So now this is all about the theory and I'd like
to show you basically what you can do with SVG both

00:55:05.309 --> 00:55:10.070
in a graphics aspect, so you can see first of all
the core things you can do and then integrate it

00:55:10.070 --> 00:55:13.640
with multimedia using the same
QuickTime APIs I told you about earlier

00:55:13.639 --> 00:55:18.420
to create a really compelling graphics
presentation using HTML, CSS, SVG,

00:55:18.420 --> 00:55:23.579
JavaScript, DOM all together in one layer in WebKit.

00:55:23.579 --> 00:55:27.069
It's actually the second demo machine, please?

00:55:27.070 --> 00:55:34.610
Thanks. So I'm just going to run those in Safari 3.

00:55:34.610 --> 00:55:40.200
just either of you can do the same
by either using Leopard or Tiger

00:55:40.199 --> 00:55:44.279
or whatever operating system you may be interested in.

00:55:44.280 --> 00:55:51.320
I'd like to first start with a simple example to show how
SVG can be used for creating scalable user interfaces.

00:55:51.320 --> 00:55:56.059
I just noticed, actually, that there was a section previous
to this one about scalable user interfaces in Leopard.

00:55:56.059 --> 00:56:00.909
Unfortunately I missed it so I'm not
really what he told the audience.

00:56:00.909 --> 00:56:04.920
But SVG is another way to do that certainly using WebKit.

00:56:04.920 --> 00:56:07.590
And remember, WebKit can be used in your Cocoa application.

00:56:07.590 --> 00:56:11.960
It's not just about web sites here, it can be also be
about the future of your application user interface.

00:56:11.960 --> 00:56:18.179
So in this case I have what looks like pretty much the
same kind of fields that are natively supported

00:56:18.179 --> 00:56:21.299
in Safari, the input type search elements.

00:56:21.300 --> 00:56:26.289
But instead of just using the HTML
elements, because I like to replicate things

00:56:26.289 --> 00:56:32.940
and just study how people treat these nice interface
widgets, I actually re-implemented it in SVG.

00:56:32.940 --> 00:56:36.980
And because it's all based on scalable
vector graphics I can just update its size

00:56:36.980 --> 00:56:39.440
on the fly and it will always look crisp.

00:56:39.440 --> 00:56:45.260
So when you're dealing with high DPI displays and you
don't know, with high DPI displays things can get really tiny

00:56:45.260 --> 00:56:48.380
and you don't even see what you're dealing with any more.

00:56:48.380 --> 00:56:54.460
In this case you could just say this thing is going to
be 3 centimeters width, whatever DPI is and etcetera.

00:56:54.460 --> 00:56:57.720
and you just get more details if the DPI is higher.

00:56:57.719 --> 00:57:04.949
And I'm actually, I have a custom focus ring on this
one expressed also in SVG in a nice little gradient

00:57:04.949 --> 00:57:08.969
and this piece here is actually an HTML input element.

00:57:08.969 --> 00:57:11.139
That's just transparent and rendered on top of the SVG.

00:57:11.139 --> 00:57:13.730
Because I don't want to re-implement everything in SVG.

00:57:13.730 --> 00:57:17.570
An input field is actually pretty complex.

00:57:17.570 --> 00:57:21.240
There are internationalization
issues to cater for and etcetera.

00:57:21.239 --> 00:57:26.750
and so in this case I'm like well I just want to take out
the graphics and I'll just overlay this HTML elements,

00:57:26.750 --> 00:57:32.179
scale it at the same time as the SVG, rendering
one layer, so it'll always look nice and sharp.

00:57:32.179 --> 00:57:38.169
So this is very simple demo of how you can
create scalable user interface widgets using SVG.

00:57:38.170 --> 00:57:43.700
In this case we're just creating a standard
(inaudible) document, not mixed with SVG and HTML.

00:57:43.699 --> 00:57:44.759
This is one is just SVG.

00:57:44.760 --> 00:57:51.720
And it's a way to visualize traffic data from Google
Analytics, so I call on a website called svg.org,

00:57:51.719 --> 00:57:57.230
which is a community website for the SVG
community and I have a Google Analytics account.

00:57:57.230 --> 00:58:04.360
I've loaded the different, the last few months
on this desktop from the XML feeds they provide us

00:58:04.360 --> 00:58:10.150
and you can see this graph is rendered on the fly
using XML HTTP  requests to load in the data

00:58:10.150 --> 00:58:15.050
and the DOM functions to create the
graphic representation on the fly.

00:58:15.050 --> 00:58:21.640
So obviously this is SVG so you can scale it up and down,
add a little over states on these buttons expressed in CSS,

00:58:21.639 --> 00:58:26.960
like I told you about earlier, because there's nothing
really too fancy going on here, no point in writing scripts.

00:58:26.960 --> 00:58:32.260
But I will say I've more advanced interactions, so I
have a little info bubble that will briefly animate

00:58:32.260 --> 00:58:33.990
to the new points so that it's really smooth.

00:58:33.989 --> 00:58:40.129
It will display the new data directly represented
in the XML field I gathered information from.

00:58:40.130 --> 00:58:42.900
You'll see that I've dated the
dates and all of that on the fly.

00:58:42.900 --> 00:58:44.820
We can also move to the next month.

00:58:44.820 --> 00:58:50.140
Have a nice little transition between objects,
or use animation expressed with a DOM.

00:58:50.139 --> 00:58:53.519
So basically for each point I'm going
through I create a new animation object

00:58:53.519 --> 00:59:00.670
and I just change it's new y value to be using animation.

00:59:00.670 --> 00:59:05.260
So this is all pretty simply and to get more
detail we can run the animation in slow motion,

00:59:05.260 --> 00:59:10.050
we can see how we can rotate text, change to
fading, translate things on the fly and etcetera.

00:59:10.050 --> 00:59:13.750
All pretty neat, we can resize on the fly.

00:59:13.750 --> 00:59:14.929
It's all done independently.

00:59:14.929 --> 00:59:16.609
The scaling is done automatically.

00:59:16.610 --> 00:59:17.670
You don't have to worry about it.

00:59:17.670 --> 00:59:23.380
You don't have to tell SVG this is the width and height
I want or etcetera, it just scales automatically.

00:59:23.380 --> 00:59:26.309
But this is a session about rich media, right?

00:59:26.309 --> 00:59:28.210
So we have to show video.

00:59:28.210 --> 00:59:30.190
We have to show something more compelling.

00:59:30.190 --> 00:59:36.720
And this is actually a demo that I already showed earlier
in the week on the Vector Graphics and WebKit presentation,

00:59:36.719 --> 00:59:43.289
but I took it to the next level by adding
a QuickTime instance in my presentation

00:59:43.289 --> 00:59:47.179
that will be directly integrated with HTML, CSS and SVG.

00:59:47.179 --> 00:59:53.119
So basically this is a front end to my
Delicious Library database on my system.

00:59:53.119 --> 00:59:57.599
Delicious library is a really neat
tool for measuring your library.

00:59:57.599 --> 01:00:04.690
And it's really nice because it allows you
to have your content available as an XML file

01:00:04.690 --> 01:00:08.539
so you can do all sorts of data mining on this or whatever.

01:00:08.539 --> 01:00:17.380
And in this case, I just load the XML database
into my scripting context using XML requests.

01:00:17.380 --> 01:00:20.869
Just the AJAX Web 2.0 way.

01:00:20.869 --> 01:00:23.569
And I'll be able to query different things on there.

01:00:23.570 --> 01:00:28.840
So for example if I want to find out, looking
for, I think I have records from Wilco.

01:00:28.840 --> 01:00:33.460
Just typing in directs, runs Xpath queries
on the model and it will return a set

01:00:33.460 --> 01:00:36.210
of objects that will translate to an SVG rendering.

01:00:36.210 --> 01:00:39.260
So in this case all these little objects are SVG objects.

01:00:39.260 --> 01:00:43.270
But they're also wrapped into an HTML
div and they're laid out using CSS.

01:00:43.269 --> 01:00:45.780
So, for example, each of them isn't in my block.

01:00:45.780 --> 01:00:51.430
That means instead of having to compute a grid layout,
and express it in SVG, I can just read it in CSS,

01:00:51.429 --> 01:00:52.859
because that's pretty good at doing this.

01:00:52.860 --> 01:00:55.849
So when I resize the window, there it is.

01:00:55.849 --> 01:01:01.519
And on top of that you will see that I can
even have my own scroll bar also defined in SVG

01:01:01.519 --> 01:01:03.530
because I like to have my own look and feel.

01:01:03.530 --> 01:01:04.490
Rich interaction.

01:01:04.489 --> 01:01:05.259
No problem.

01:01:05.260 --> 01:01:08.810
I have little drop shadows here
to overlay the other bits of SVG.

01:01:08.809 --> 01:01:14.929
This is also defined in SVG so it doesn't clip to
harshly where you can see it fading in and out.

01:01:14.929 --> 01:01:19.909
And, of course, because it's SVG, I can just
change the states and width and height of objects.

01:01:19.909 --> 01:01:25.069
So in this case, I've just changed it using this
little slider and just because I like doing that kind

01:01:25.070 --> 01:01:29.309
of stuff I can run gratuitous little
animation on each object when I click on them.

01:01:29.309 --> 01:01:36.869
This is the object that we coded up earlier when it's
scales and rotates at the same time and scales back up.

01:01:36.869 --> 01:01:39.750
So that's all pretty neat.

01:01:39.750 --> 01:01:45.440
But also can search for movies, so for
example I know a bunch of Kubrick movies.

01:01:45.440 --> 01:01:46.139
There they are.

01:01:46.139 --> 01:01:48.670
And actually I've got a bunch more movies.

01:01:48.670 --> 01:01:49.659
I can see a lot of data.

01:01:49.659 --> 01:01:53.440
Everything's pretty smooth even though
I have a lot of data in this case.

01:01:53.440 --> 01:01:55.650
And I might choose to actually watch one of those.

01:01:55.650 --> 01:02:02.590
So I don't have the rights to display everything
here in it's full length, so Apple actually hooked me

01:02:02.590 --> 01:02:06.630
up with a nice little video they made,
which will just show exactly the same thing.

01:02:06.630 --> 01:02:10.349
In this case I will click on object trigger video.

01:02:10.349 --> 01:02:16.819
It will scale up together and it will display straight ahead
on top of my presentation, we've got a nice little border

01:02:16.820 --> 01:02:21.330
and just like any object, I can
actually resize it on the fly directly.

01:02:21.329 --> 01:02:23.610
Pretty simple.

01:02:23.610 --> 01:02:27.430
I can go in full screen mode like so.

01:02:27.429 --> 01:02:30.549
I can scroll within the video.

01:02:30.550 --> 01:02:33.800
Go back and forth in the movie.

01:02:35.389 --> 01:02:37.469
Bring it back to zero level.

01:02:37.469 --> 01:02:40.709
And if you turn the volume up, please, a little bit.

01:02:40.710 --> 01:02:47.559
When I turn it down, when I scale it
down, I will also gradually mute it.

01:02:47.559 --> 01:02:49.840
No real reason for that, you know, for kicks.

01:02:49.840 --> 01:02:52.829
It's something you can do.

01:02:52.829 --> 01:02:54.150
It's really a demo, right?

01:02:54.150 --> 01:02:57.990
So of course, scaling things up and down.

01:02:57.989 --> 01:03:00.959
A couple of bugs in my code, I'm sorry.

01:03:00.960 --> 01:03:02.740
But there you go.

01:03:02.739 --> 01:03:03.649
It's pretty powerful.

01:03:03.650 --> 01:03:05.349
Pretty simple, I think.

01:03:05.349 --> 01:03:09.139
This really shows how you can integrate things all together.

01:03:09.139 --> 01:03:11.339
Put it back in full screen.

01:03:11.340 --> 01:03:12.670
Background fitting in.

01:03:12.670 --> 01:03:16.260
slow motion between the different frames, etcetera.

01:03:16.260 --> 01:03:17.750
very simple.

01:03:17.750 --> 01:03:24.179
So, interesting.

01:03:24.179 --> 01:03:25.690
So that's it for me today, actually.

01:03:25.690 --> 01:03:28.070
This is all I had to show you.

01:03:28.070 --> 01:03:34.260
And I just wanted to remind you before I left
the stage that this is not just web technologies.

01:03:34.260 --> 01:03:37.390
Granted you can use Safari 3 to do
all of these really snazzy things.

01:03:37.389 --> 01:03:41.969
And we have the QuickTime team and the WebKit
Teams and the Safari Teams to thank for that.

01:03:41.969 --> 01:03:47.519
But it's also, WebKit is also just another took
kit for you to use in your Cocoa applications.

01:03:47.519 --> 01:03:53.360
And even though Cocoa has great foundations for
widgets and really cool graphics, APIs and etcetera,

01:03:53.360 --> 01:03:59.400
sometimes you might want to do something a little bit
different and those kind of interfaces are really,

01:03:59.400 --> 01:04:05.769
really pretty cool to work with and I really
hope you feel a little bit inspired to try

01:04:05.769 --> 01:04:07.960
out these things in your own application.

01:04:07.960 --> 01:04:14.139
So I will give it back to George who took care of
organizing this track and he will wrap this up for us.

01:04:14.139 --> 01:04:15.509
Thanks.

01:04:15.510 --> 01:04:20.050
( Applause )

01:04:20.050 --> 01:04:20.450
>> George: Okay.

01:04:20.449 --> 01:04:22.210
There's about 10 minutes left.

01:04:22.210 --> 01:04:25.050
Got some housekeeping to do.

01:04:25.050 --> 01:04:27.140
Raise of hands, we've got to show this slide.

01:04:27.139 --> 01:04:31.949
How many of you guys have seen the iPhone
development websites for iPhones session?

01:04:31.949 --> 01:04:32.669
Pretty much everyone.

01:04:32.670 --> 01:04:32.840
All right.

01:04:32.840 --> 01:04:34.450
Let's just quickly brass through this then.

01:04:34.449 --> 01:04:35.879
This is a recap.

01:04:35.880 --> 01:04:41.630
When you're developing AJAX applications for
iPhone, we are encouraging good design disciplines.

01:04:41.630 --> 01:04:42.700
And what do we mean by that?

01:04:42.699 --> 01:04:45.759
We encourage you to use a column based layout.

01:04:45.760 --> 01:04:49.360
Use divs. Use a grid system for laying out your content.

01:04:49.360 --> 01:04:50.670
Size matters.

01:04:50.670 --> 01:04:53.680
So take that into consideration with the content

01:04:53.679 --> 01:04:58.940
that you will potentially be providing
through and for your AJAX application.

01:04:58.940 --> 01:05:00.519
Media queries.

01:05:00.519 --> 01:05:08.690
We are highly encouraging you to adopt the CSS
based design methodologies for modern web design,

01:05:08.690 --> 01:05:12.400
which means please don't use tables, use everything in CSS.

01:05:12.400 --> 01:05:17.730
And in particular, use CSS media
queries for defining the actual layout,

01:05:17.730 --> 01:05:19.860
the feel and the sort of aesthetic for your site.

01:05:19.860 --> 01:05:25.800
Additionally the media queries will be able to
translate the size and height and width of your content

01:05:25.800 --> 01:05:28.980
as the device renders it onto the actual phone.

01:05:28.980 --> 01:05:31.500
Optimizing for iPhone.

01:05:31.500 --> 01:05:31.969
Viewport.

01:05:31.969 --> 01:05:37.339
Take into consideration the actual total,
you know, region of the actual web page

01:05:37.340 --> 01:05:38.990
or the web application that you're developing.

01:05:38.989 --> 01:05:43.779
That will help the actual device itself
and anticipate how to do the scaling

01:05:43.780 --> 01:05:49.200
when it actually renders the content
within Safari 3 for iPhone.

01:05:49.199 --> 01:05:50.139
Double tap.

01:05:50.139 --> 01:05:52.509
When you're working with your content, when you break stuff

01:05:52.510 --> 01:05:58.100
into the column based layout structure it helps also the
device to designate what area are you actually adding focus

01:05:58.099 --> 01:06:03.569
onto and using the scaling capabilities to
actually do the zooming up on the actual device.

01:06:03.570 --> 01:06:05.880
Text size adjustment.

01:06:05.880 --> 01:06:12.849
Please also don't, try not to or refrain from
having full width of the actual window text flows.

01:06:12.849 --> 01:06:16.250
Put them into divs, again, using the column layout.

01:06:16.250 --> 01:06:25.809
Events. Read up on, or when we actually release
the audio, and the session and the slides

01:06:25.809 --> 01:06:29.000
from the developing websites iPhone session,

01:06:29.000 --> 01:06:33.429
study what actual JavaScript events we
actually support on the actual device.

01:06:33.429 --> 01:06:34.069
And then media.

01:06:34.070 --> 01:06:42.480
Be sure to encode for both Edge and WiFi networks using
QuickTime ref movies, using H.264 baseline profile.

01:06:42.480 --> 01:06:49.519
More information contact Mark Malone, who is the
Internet and Technologies Evangelist for WWDR.

01:06:49.519 --> 01:06:55.210
Handy links, these will also be available in the slide
deck once we publish it to the ADC website as well

01:06:55.210 --> 01:07:02.230
as these links here are currently available with a lot
of documentation on WebKit.org for user agent detection.

01:07:02.230 --> 01:07:09.059
You can read up sort of on CSS3 media queries via the
W3C website as well as some of the work that we're doing

01:07:09.059 --> 01:07:16.690
and pushing the audio tags back within the WHATWG group
as well as the new W3C HTML 5 specification.

01:07:16.690 --> 01:07:21.860
Sample code for the session you just saw,
Developing Rich Media Web Applications,

01:07:21.860 --> 01:07:25.870
is going to be available at this
URL shortly after the session.

01:07:25.869 --> 01:07:28.389
Probably sometime over the weekend.

01:07:28.389 --> 01:07:31.480
Anything audio and video related to iPhone development,

01:07:31.480 --> 01:07:34.619
please contact Allan Schaffer, he
is the point of contact for that.

01:07:34.619 --> 01:07:41.019
And if you need the tool to start developing movies
for handling the Edge versus a WiFi sort of detection,

01:07:41.019 --> 01:07:48.590
you'll need the ref movie tool maker as well as contact
QuickTime seeding to get seeded for the version of QuickTime

01:07:48.590 --> 01:07:51.950
that will have the encoding capabilities for iPhone.

01:07:51.949 --> 01:07:55.059
That is currently not delivered with
the Leopard CD's that you all have.

01:07:55.059 --> 01:08:03.469
seedqt@apple.com, submit your application
for admission into the actual beta program.

01:08:03.469 --> 01:08:06.959
The next session, we have the pleasure
of having Sam Stevenson

01:08:06.960 --> 01:08:10.980
from 37 Signals and also the creator of Prototype here.

01:08:10.980 --> 01:08:14.510
And he's going to be down on Russian
Hill at five p.m. this evening.

01:08:14.510 --> 01:08:21.250
And then in this room here, we have Alex Lindsay
from PixelCorp going to be providing a session

01:08:21.250 --> 01:08:26.000
on Effective Sophisticated Podcasts, which
is highly relevant towards anyone who wants

01:08:26.000 --> 01:08:30.170
to create content for iPod, Apple TV, as well as iPhone.
WEBVTT

00:00:20.530 --> 00:00:21.300
Good afternoon.

00:00:21.300 --> 00:00:22.109
My name is David Black.

00:00:22.109 --> 00:00:23.660
I am an architect in the crafts division.

00:00:23.660 --> 00:00:29.109
And we are going to talk about integrating
applications with Final Cut Pro in today's session.

00:00:29.109 --> 00:00:34.070
And really what this talk is going to focus on
is the various tools and technologies you can use

00:00:34.070 --> 00:00:39.880
to integrate your applications with Final Cut Pro
and also leverage a number of applications together

00:00:39.880 --> 00:00:43.920
to build very powerful workflows
for both you and your customers.

00:00:43.920 --> 00:00:49.100
We are going to start off today with a little bit of
background and talk about some data interchange formats

00:00:49.100 --> 00:00:52.510
and give you an idea of where some
of our technologies came from.

00:00:52.509 --> 00:00:55.739
We are also going to talk about
metadata support for media files.

00:00:55.740 --> 00:00:58.609
Some very new powerful tools we
started to add in the last year.

00:00:58.609 --> 00:01:03.399
And then finally we are going to go into a number
of technologies, specific to Final Cut Pro

00:01:03.399 --> 00:01:11.909
and sort of some tips and tricks about the best methods
to go about using, tie your applications together.

00:01:11.909 --> 00:01:13.959
So Project Data Interchange Formats.

00:01:13.959 --> 00:01:17.939
And really we'll start with the
question of what is Project Data?

00:01:17.939 --> 00:01:22.849
It's seemingly an obvious question but at
times when everyone really seems to understand,

00:01:22.849 --> 00:01:26.549
really Project Data is the structure
that ties elements together.

00:01:26.549 --> 00:01:31.049
If you think about the production for
a television commercial or a film,

00:01:31.049 --> 00:01:32.780
sort of understand that maybe the crews will be

00:01:32.780 --> 00:01:36.310
out in the field a long time shooting
footage, pulling graphics together.

00:01:36.310 --> 00:01:41.189
And certainly when there's a lot of time spent acquiring
those assets there's even more time spent organizing those

00:01:41.189 --> 00:01:45.859
assets, sequencing them together and combining
them to create that compelling content.

00:01:45.859 --> 00:01:50.989
So really in a way this is the data that your
users spend the most time of all creating.

00:01:50.989 --> 00:01:54.729
Of course the challenge with this is
there's much powerful complexity here.

00:01:54.730 --> 00:02:02.579
So this tends to be difficult to exchange beyond
the normal, beyond the very most basic details.

00:02:02.579 --> 00:02:06.909
Legacy formats came about 20, 30 years ago.
0

00:02:06.909 --> 00:02:12.069
Really these formats if you think of it were built
to tie hardware systems together, so hardware switchers.

00:02:12.069 --> 00:02:17.769
Now, effectively banks of tape decks and switching
hardware all running in sequence to assemble a show.

00:02:17.770 --> 00:02:22.930
The two most common examples you'll see and still in
very common use today will be batch list and EDLs.

00:02:22.930 --> 00:02:28.760
And at their core both of these formats are
essentially a list of time codes and clip segments.

00:02:28.759 --> 00:02:34.780
Whereas a batch list is really sort a list of data to
define an individual clip and EDL is really a sequence

00:02:34.780 --> 00:02:39.449
of those elements and time to put together a program.

00:02:39.449 --> 00:02:45.239
Contemporary formats came about really in the late '80s
and early '90s as a number of companies came to market

00:02:45.240 --> 00:02:49.710
with more flexible computer-based
solutions for editing media.

00:02:49.710 --> 00:02:56.580
And really they were built to address the shortcomings of
the legacy formats, add more richness in the entire model.

00:02:56.580 --> 00:03:02.930
But of course then the challenge at that point being
with systems what they were is as opposed to sort

00:03:02.930 --> 00:03:05.700
of plain ASCII text, human readable data.

00:03:05.699 --> 00:03:10.560
These were based around the binary container formats, you
know, pick your favorite hierarchical packaging system

00:03:10.560 --> 00:03:13.379
from the time and someone was using it for media.

00:03:13.379 --> 00:03:18.719
Of course the down fall from this is that you
needed libraries and tools to parse these things.

00:03:18.719 --> 00:03:22.109
And, you know, you needed to keep
computers running to parse these things.

00:03:22.110 --> 00:03:27.760
The two most common examples you'll find out
in the market today are really OMF and AAF.

00:03:27.759 --> 00:03:30.079
Both of these originated from Abbot back in the '90s.

00:03:30.080 --> 00:03:37.320
OMF today really survives in the audio post-production community
around ProTools whereas AAF came about as a consortium

00:03:37.319 --> 00:03:44.069
of companies number of years ago tried to at least
bring some standards into the interchange space.

00:03:45.280 --> 00:03:51.009
Open data formats came about in the last few years
as sort of everyone took the lessons into mind

00:03:51.009 --> 00:03:53.810
from both the legacy formats and contemporary formats.

00:03:53.810 --> 00:03:58.060
And really strove to maintain a lot of
that richness but actually solved some

00:03:58.060 --> 00:04:00.800
of the problems that played implementations.

00:04:00.800 --> 00:04:07.130
You really as you can sort of tell from the name here
the key point here is for open and transparent access.

00:04:07.129 --> 00:04:08.299
You know trying to keep things simple.

00:04:08.300 --> 00:04:09.330
Trying to keep things open.

00:04:09.330 --> 00:04:13.110
Allowing everybody to play allowing
everybody to get to the data.

00:04:13.110 --> 00:04:18.990
also really trying to make these easy
as possible to parse and generate.

00:04:18.990 --> 00:04:23.050
Go ahead and talk about where we
came to with Final Cut Pro in this.

00:04:23.050 --> 00:04:29.770
Because we came into this problem a number of years ago
and we took a look at the lessons from the various formats

00:04:29.769 --> 00:04:34.089
and really took a look at this as an
opportunity to solve an operability problem.

00:04:34.089 --> 00:04:35.989
And of course we started with feedback.

00:04:35.990 --> 00:04:41.540
From customers we heard a lot of common things, you
know, common data formats, want to get projects,

00:04:41.540 --> 00:04:45.170
as well as media, and also building processing pipelines.

00:04:45.170 --> 00:04:51.220
A lot of very sophisticated customers want to build
their own sort of workflows between applications.

00:04:51.220 --> 00:04:56.600
Honestly we heard a lot of the same things from
developers along with wanting to talk to Final Cut Pro,

00:04:56.600 --> 00:05:00.100
write tools and go ahead and integrate
their own processing pipelines

00:05:00.100 --> 00:05:04.180
or at least be friendly to customer-
built processing pipelines.

00:05:05.970 --> 00:05:13.780
We came back from this exercise with what we felt especially
at the time was a very different take on this problem

00:05:13.779 --> 00:05:20.299
in that really this wasn't a problem simply in
interchanging complex data sets between large systems.

00:05:20.300 --> 00:05:27.790
But really it was data manipulation tools and data
manipulation on a large scale as well as a small scale.

00:05:27.790 --> 00:05:32.900
Also making these tools and these formats successful
not only to developers who can deal with, you know,

00:05:32.899 --> 00:05:37.919
writing a lots of codes and potentially processing
libraries but also to power users who might be

00:05:37.920 --> 00:05:45.340
out there using command line tools or web servers or
other tools to basically just parse large data sets.

00:05:45.339 --> 00:05:49.509
And of course trying to minimize our
library requirements as much as possible.

00:05:49.509 --> 00:05:53.769
Making these formats accessible on
multiple platforms not just our own.

00:05:53.769 --> 00:05:58.029
And also taking a shot on a problem we
heard from Hollywood interestingly enough

00:05:58.029 --> 00:06:01.919
in terms of handling long term archival projects.

00:06:03.329 --> 00:06:06.240
From this we came up with our XML interchange format.

00:06:06.240 --> 00:06:08.920
We shipped it initially Final Cut Pro 4.

00:06:08.920 --> 00:06:13.420
And as you can tell we chose XML as encoding for the data.

00:06:13.420 --> 00:06:17.509
It's actually nice, you know, if you ever looked
at XML it's effectively plain text.

00:06:17.509 --> 00:06:20.870
There are a lot of libraries out on
multiple platforms for parsing XML

00:06:20.870 --> 00:06:24.360
so you don't necessarily have to
do all the grunt work yourself.

00:06:24.360 --> 00:06:27.930
But you can also pull it open in
text edit and see the contents.

00:06:27.930 --> 00:06:34.009
And really we built it to encapsulate the
complete contents of a Final Cut Pro Project.

00:06:34.009 --> 00:06:39.719
So everything in that project is relevant to the
construction of that project is encoded in the XML.

00:06:39.720 --> 00:06:44.080
Really doing our best to not have any sort
of black or private data anywhere in there

00:06:44.079 --> 00:06:48.329
because that just frustrates developers and
users trying to create projects from scratch.

00:06:48.329 --> 00:06:53.599
And of course being XML it's really
structured ourselves documenting that way.

00:06:53.600 --> 00:06:59.350
We have plenty of documentation out but if you are taking
an XML file out of Final Cut and open it up text edit,

00:06:59.350 --> 00:07:04.800
you'd be able to figure out pretty quickly what
the essential structures in those files were.

00:07:06.060 --> 00:07:10.740
Here's a really brief snippet of XML just for those
of you who may not have played with it before.

00:07:10.740 --> 00:07:14.269
Now, it's basically we have a definition
for a clip or a media segment.

00:07:14.269 --> 00:07:16.969
And, you know, we just have sort
of these essential pieces here.

00:07:16.970 --> 00:07:22.560
You know we have the name, the duration, some timing
information and also some time code reference information

00:07:22.560 --> 00:07:32.579
to help indicate where this came from an
original piece of source media like a videotape.

00:07:32.579 --> 00:07:38.189
Really when we came to this problem, you know,
trying to address the needs of developers and users,

00:07:38.189 --> 00:07:43.449
we got a lot of feedback about having
access to Common Industry Data Formats.

00:07:43.449 --> 00:07:48.699
And really we felt the most achievable way
toward that solution was to make our XML format

00:07:48.699 --> 00:07:51.719
such that it could be a super set of other formats.

00:07:51.720 --> 00:07:57.830
Again, going back to exposing the complete content
developers this allows other format translaters prebuilt

00:07:57.829 --> 00:08:01.319
using XML as an intermediate.

00:08:01.319 --> 00:08:03.079
Mentioned archival a little bit earlier.

00:08:03.079 --> 00:08:07.469
Now, we talked to a number of people in
Hollywood who had the concern of well, you know,

00:08:07.470 --> 00:08:12.690
if I take a film from the '40s or the '50s
assuming I still have the actually celluloid, you know.

00:08:12.689 --> 00:08:17.920
I have, you know, a list of those edits and I
have that film I could go ahead and recombine that

00:08:17.920 --> 00:08:20.420
and remaster that film 30 or 40 years later.

00:08:20.420 --> 00:08:29.340
If I have videotapes or film and an edit list and a binary
format, unless I took a machine and wrapped it in plastic

00:08:29.339 --> 00:08:35.419
and put it in the closet, chances are it's going to
be very difficult to decode that 30 years from now.

00:08:35.419 --> 00:08:39.819
Putting this data in XML means it's
effectively ASCII text and anyone even

00:08:39.820 --> 00:08:46.860
if the software hasn't survived should be able
to pick out what the data is and make use of it.

00:08:49.080 --> 00:08:53.340
Now, it's been 3 or 4 years since we put this out.

00:08:53.340 --> 00:08:55.160
And who's using it?

00:08:55.159 --> 00:08:57.029
Well, an awful lot of people are using it.

00:08:57.029 --> 00:09:00.959
I wager a large number of people
in this room are actually using it.

00:09:00.960 --> 00:09:05.230
Automatic Duck has built a line of
successful format translaters using it.

00:09:05.230 --> 00:09:11.789
Gallery Systems has done an amazing job with integration
with ProTools and audio applications with File Cut Pro.

00:09:11.789 --> 00:09:16.980
Building4Media and a number of other companies are
building full work station automation play out systems

00:09:16.980 --> 00:09:21.720
and asset manager systems using XML
as that essential interchange glue.

00:09:21.720 --> 00:09:26.930
And this last year Sony actually brought out some
transfer software to basically take the footage

00:09:26.929 --> 00:09:32.949
from their latest high definition Blu-ray-based cam
recorders and bring that directly into Final Cut Pro

00:09:32.950 --> 00:09:38.580
with a very customized compelling interface
that's familiar to the camera operator and having

00:09:38.580 --> 00:09:42.420
that just feed directly into the Final Cut Pro using XML.

00:09:42.419 --> 00:09:46.110
And really there are a lot of people out there
and just way too many to name in the slide.

00:09:46.110 --> 00:09:49.310
These are just a few examples.

00:09:49.309 --> 00:09:51.049
A brief note on versioning.

00:09:51.049 --> 00:09:58.299
You know as we built the file format up and over time
we've seen the need to make small additions to it.

00:09:58.299 --> 00:10:04.259
We introduced v4 with File Pro 6 which actually
was announced at the NAB show a month or two ago.

00:10:04.259 --> 00:10:09.220
The important take home point from this particular side is

00:10:09.220 --> 00:10:12.330
that the XML is forward-compatible
but not backward-compatible.

00:10:12.330 --> 00:10:17.660
Such that you can export a version
one XML file from Final Cut Pro 4.1

00:10:17.659 --> 00:10:21.709
and you can import it all the way
up to Final Cut Pro 6 no problem.

00:10:21.710 --> 00:10:27.360
But if you export a v4 file from Final Cut Pro
6, you are not going to be able to read that back into 4.1.

00:10:27.360 --> 00:10:31.919
However, you can export a v1, v2,
v3 files that are found in Final Cut Pro 6.

00:10:31.919 --> 00:10:34.360
So you can feed get it back if you need to.

00:10:34.360 --> 00:10:38.550
Just be aware of the consequences for
what version you are actually using.

00:10:39.990 --> 00:10:43.259
And we have a plethora of documentation
up on the developer's site.

00:10:43.259 --> 00:10:44.569
It's been there for a while.

00:10:44.570 --> 00:10:48.230
There's a lot of really good tidbits
in that documentation, tips, examples,

00:10:48.230 --> 00:10:54.820
and also information on smaller
technologies we'll touch on in a little while.

00:10:54.820 --> 00:10:58.190
Moving away from Project Data for a
minute I want to talk about Metadata.

00:10:58.190 --> 00:11:03.620
And really this is a big thing and this is
something we began experimenting with last year.

00:11:03.620 --> 00:11:08.750
And we've been putting more support in place
for you, the developers, over this last year.

00:11:08.750 --> 00:11:14.610
But before we get into some of the details sort of step
back a little bit and ask the question of, what is metadata?

00:11:14.610 --> 00:11:19.269
This is one of these questions where potentially asked
12 developers and you'll get 8 different answers.

00:11:19.269 --> 00:11:25.470
So just to make sure we are on the same stage
with the terms really what do we consider it?

00:11:25.470 --> 00:11:33.250
We consider it an arbitrary collection of ancillary
elements, right, attached to a primary data set.

00:11:33.250 --> 00:11:38.690
So you may have a document file for project and you've got
a primary chunk of data that really defines that document.

00:11:38.690 --> 00:11:42.620
But metadata is sort of the optional
little things that you can attach to it

00:11:42.620 --> 00:11:48.230
but don't necessarily require modifications
to applications using that course set.

00:11:48.230 --> 00:11:51.420
And really this collection of elements
is extensible without, you know,

00:11:51.419 --> 00:11:55.490
modifying the core data set or modifying the application.

00:11:55.490 --> 00:11:57.789
Quick little example here.

00:11:57.789 --> 00:12:04.480
Another thing to think about is a particular piece of
data may or may not be considered metadata depending

00:12:04.480 --> 00:12:07.670
on the application context in which it's used.

00:12:07.669 --> 00:12:09.049
You know really briefly here.

00:12:09.049 --> 00:12:15.209
If I have a QuickTime file, there are essential attributes
of that file in terms of the codec and the image size

00:12:15.210 --> 00:12:19.889
and format which are critical to
QuickTime player's use of that file.

00:12:19.889 --> 00:12:27.590
But to finder they are just interesting
attributes displayed at the user.

00:12:27.590 --> 00:12:32.660
Another example everyone here is familiar
with I'm sure is MP3 and AAC files.

00:12:32.659 --> 00:12:37.100
And little ID3 tags that put the
album information in those files.

00:12:37.100 --> 00:12:41.920
And sort of going back to our model, the central
content of that file is the compressed audio data.

00:12:41.919 --> 00:12:47.589
And while the ID3 tags don't have to be there, they
certainly enhance your experience using that file

00:12:47.590 --> 00:12:50.240
by allowing to you find and search music.

00:12:50.240 --> 00:12:55.529
The standard has also grown from its initial incarnation
from just a collection of fields to a repository

00:12:55.529 --> 00:12:59.929
for all sorts information including album art work.

00:12:59.929 --> 00:13:04.269
Now, that we've sort of defined
some generalized terms for metadata,

00:13:04.269 --> 00:13:08.110
let's talk about the QuickTime side of this equation.

00:13:08.110 --> 00:13:14.240
When the QuickTime team released v7, they
introduced support for QuickTime metadata containers.

00:13:14.240 --> 00:13:20.860
And you can think of these containers as the
repository for keys and values tied together.

00:13:20.860 --> 00:13:26.279
These containers currently are supported on
a movie, on a track, or a piece of media.

00:13:26.279 --> 00:13:32.029
And each container uses a particular
key space to identify the keys.

00:13:32.029 --> 00:13:40.000
The point to note here is that the QuickTime architecture
is built up such that you can define different key spaces.

00:13:40.000 --> 00:13:46.980
And, you know, use different identifying values
depending on your particular application.

00:13:46.980 --> 00:13:52.850
Another key point here though is this is not
necessarily a one-to-one key value paring.

00:13:52.850 --> 00:13:57.019
This is really a key contains end values associated with it.

00:13:57.019 --> 00:14:00.079
There's some interesting sort of usage semantics.

00:14:00.080 --> 00:14:02.160
This we will touch on in a few minutes.

00:14:02.159 --> 00:14:06.779
But it just bears noticing keeping in mind.

00:14:08.039 --> 00:14:11.309
The containers themselves are stored in the movie resource.

00:14:11.309 --> 00:14:15.049
Those of who used to work in QuickTime files
understand the concept given in the movie resource

00:14:15.049 --> 00:14:18.689
which defines movie structure and
then you have the sample data.

00:14:18.690 --> 00:14:22.470
All the metadata you put in a movie
will be stored in the movie resource.

00:14:22.470 --> 00:14:25.639
This is the advantage that it goes everywhere that movie is.

00:14:25.639 --> 00:14:30.909
It has the potential disadvantage if that data gets
loaded into memory everytime that movie file is opened.

00:14:30.909 --> 00:14:33.519
We really haven't seen problems with this yet.

00:14:33.519 --> 00:14:36.069
We are look at alternatives for this.

00:14:36.070 --> 00:14:41.640
But the nice thing is there's no real penalty for
querying that metadata once you've opened that movie file.

00:14:41.639 --> 00:14:48.049
And of course this data gets carried in
reference movies independent of the media.

00:14:48.049 --> 00:14:54.839
Another point of confusion we heard after rolling this out
last year is the difference between user data and metadata.

00:14:54.840 --> 00:14:59.009
Certainly a number of developers have
made use of QuickTime user data atoms

00:14:59.009 --> 00:15:01.659
to store their own private data over the years.

00:15:01.659 --> 00:15:07.049
But the difference between the two is that as where user
data atoms are essentially blocks of binary bits identified

00:15:07.049 --> 00:15:13.769
by FourCC code, the metadata containers are really
a key value key space with accessory APIs.

00:15:13.769 --> 00:15:19.149
Of course the advantage is since you type each one of
the metadata volumes, you know what data is in there.

00:15:19.149 --> 00:15:22.579
So you don't sort of have the black
container problem with user data atoms.

00:15:22.580 --> 00:15:27.420
That we touched on earlier with the project data.

00:15:27.419 --> 00:15:30.219
Another point to note talked about key spaces for a minute.

00:15:30.220 --> 00:15:36.000
Really the primary key space that we make use
of is the QuickTime reverse-DNS key space.

00:15:36.000 --> 00:15:39.990
An example of, you know, annoyingly long or
short depending on your view point key there.

00:15:39.990 --> 00:15:44.799
And it's actually very handy because it
helps differentiate your company's data

00:15:44.799 --> 00:15:48.099
from your user's data from other organization's data.

00:15:48.100 --> 00:15:54.550
And even in similar to XMLs plain text advantages
provides by some documentation of what your values are.

00:15:54.549 --> 00:16:00.029
And it gets us out of the namespace
collision problem, which is not a lot of fun.

00:16:00.029 --> 00:16:01.350
Some procedural things here.

00:16:01.350 --> 00:16:04.720
I'm not going to go into complete depth on the APIs.

00:16:04.720 --> 00:16:10.740
But getting a container is a simple matter of
calling the CopyMovie or TrackMetaData API.

00:16:10.740 --> 00:16:15.779
Even though it says copy it's giving you
a reference to that current container.

00:16:15.779 --> 00:16:21.230
If you want to get values, you know, you get a container
and then get iterate using the GetNextItem API.

00:16:21.230 --> 00:16:26.450
You can basically walk through all the values in a
container or give it a key to restrict your search.

00:16:26.450 --> 00:16:31.030
And once you have that item that query will
give you back a QT metadata item handle.

00:16:31.029 --> 00:16:35.629
You can use that with property APIs to get the
data or type or any other interesting information.

00:16:35.629 --> 00:16:40.389
If you want to add a value, again it's simple.

00:16:40.389 --> 00:16:42.669
Get a container and call Add.

00:16:42.669 --> 00:16:44.439
No real surprises here.

00:16:44.440 --> 00:16:50.320
If you want to remove a value, you can call RemoveItemsWithKey
to remove everything associated with the key,

00:16:50.320 --> 00:16:55.160
you know, mentioned a few moments
ago that it's one key to n items.

00:16:55.159 --> 00:16:59.129
If you want to remove a single item thought that means
you'll need to iterate and find that item then call

00:16:59.129 --> 00:17:03.269
and remove the API on that particular item.

00:17:03.269 --> 00:17:05.139
And we'll do a quick demo here.

00:17:05.140 --> 00:17:10.980
Can we have the demo station, please?

00:17:10.980 --> 00:17:11.900
Thank you.

00:17:11.900 --> 00:17:16.930
So I've got a little command line application I wrote
a little while ago to play with QuickTime metadata.

00:17:16.930 --> 00:17:20.320
And my folder here, I have a couple of movie files.

00:17:20.319 --> 00:17:25.299
And this little -- sorry about that.

00:17:25.299 --> 00:17:30.700
If I run my MetaMovieScraper tool
on one of these movie files here,

00:17:30.700 --> 00:17:34.670
excuse me one second I'm just going to turn that off.

00:17:34.670 --> 00:17:38.930
It just goes ahead and does a dump of
the containers on a particular movie.

00:17:38.930 --> 00:17:44.779
If you look here it is basically enumerating the movie and
the track and the media and there's one key in this file.

00:17:44.779 --> 00:17:47.779
Basically a string named OfficeExit.

00:17:47.779 --> 00:17:51.389
Now, this is just a very simple file
that we'll come back to using later.

00:17:51.390 --> 00:17:55.190
But to give you an example of something more interesting.

00:17:55.190 --> 00:17:57.570
I have another file here.

00:17:57.569 --> 00:18:01.419
That, this is actually a file that I
ingested using the current version

00:18:01.420 --> 00:18:05.529
of File Cut Pro from Panasonic P2 memory card.

00:18:05.529 --> 00:18:10.470
And if I dump out the Final Cut of this file,
you'll see there's an awful lot more stuff here.

00:18:10.470 --> 00:18:16.660
The interesting thing about this case is with especially
the solid state-based cameras, manufacturers are putting

00:18:16.660 --> 00:18:19.500
in a great deal of very interesting metadata.

00:18:19.500 --> 00:18:24.680
Everything from MFX-centric media IDs to
information on who shot the footage, etcetera.

00:18:24.680 --> 00:18:28.740
And we're putting all this as metadata in the movie file.

00:18:28.740 --> 00:18:34.099
The nice thing about this is whereas traditionally
this data might have been put into a project file

00:18:34.099 --> 00:18:39.109
and the media file was just the media this
data will now ride wherever that media file goes.

00:18:39.109 --> 00:18:43.509
Can we have the slides again, please?

00:18:43.509 --> 00:18:51.400
( pause )

00:18:51.400 --> 00:18:53.980
Stepping up a level we talked about
metadata support and QuickTime.

00:18:53.980 --> 00:18:58.890
Now, I want to talk about some of the specific
capabilities we put into Final Cut Pro.

00:19:00.109 --> 00:19:07.490
We introduced support last year with Final Cut Pro 5.1.2
and really our support builds on top of QuickTime metadata support.

00:19:07.490 --> 00:19:10.160
So everything we discussed is what this is built on.

00:19:10.160 --> 00:19:12.470
Now we support arbitrary metadata files.

00:19:12.470 --> 00:19:17.769
It's important to note that for now we are only
dealing with metadata at the movie and track levels.

00:19:17.769 --> 00:19:21.879
And we're really only supporting
the QuickTime primary key space.

00:19:21.880 --> 00:19:24.280
So those reverse-DNS strings we talked about.

00:19:24.279 --> 00:19:28.420
And we'll define any of the data we'll support
any of the data types that QuickTime has defined

00:19:28.420 --> 00:19:31.710
in their header files: the strings, numbers, binary, etcetera.

00:19:31.710 --> 00:19:41.700
The other important point to note about Final
Cut support for metadata is because of a couple

00:19:41.700 --> 00:19:43.720
of advantages we will get into that in just a moment.

00:19:43.720 --> 00:19:46.930
The support is really something of a cache.

00:19:46.930 --> 00:19:49.549
And the concept goes something like this.

00:19:49.549 --> 00:19:55.569
If I launch Final Cut Pro, make a new project
and import a metadata-bearing QuickTime file,

00:19:55.569 --> 00:20:02.210
when Final Cut Pro conducts its internal database reference
to that file, it will look for metadata present in the file.

00:20:02.210 --> 00:20:06.440
It finds any, it will read it and it
will cache it in the project file.

00:20:06.440 --> 00:20:12.279
Now, the nice thing about this is you may have a project
where your media file is on disk, you quit and save.

00:20:12.279 --> 00:20:16.180
Next time you come back in that media
file has all of a sudden disappeared.

00:20:16.180 --> 00:20:20.130
Well, if that file is gone, the cache is
still there so the metadata is still there.

00:20:20.130 --> 00:20:27.170
So you still have your metadata in case the file has
gone away this may help and make it easier for you

00:20:27.170 --> 00:20:30.029
to find the file at a point in the future.

00:20:30.029 --> 00:20:36.190
But the another key point of this though is that the
authoritative copy of the data is your media file.

00:20:36.190 --> 00:20:41.820
So if you make a project, import a file, save,
quit and then change the metadata in that file.

00:20:41.819 --> 00:20:48.179
The next time you open that project and it reattaches
and resyncs that file, the cached copy will be taken

00:20:48.180 --> 00:20:53.870
out in favor of the data in that file at that time.

00:20:53.869 --> 00:20:59.119
Now, of course one of the revisions we made
to the XML format was to support metadata.

00:20:59.119 --> 00:21:04.759
What you'll notice is if you have metadata-
bearing files and you export XML from Final Cut,

00:21:04.759 --> 00:21:08.369
you'll see metadata elements in the file definitions.

00:21:08.369 --> 00:21:12.250
This export is based on the cached metadata
repository we talked about a moment ago.

00:21:12.250 --> 00:21:17.809
So even if you're exporting a project file with
off-line media, you will see the metadata there

00:21:17.809 --> 00:21:21.019
as Final Cut's last notice of that media file.

00:21:21.019 --> 00:21:27.490
The import process will pay attention to those elements
but it's a little interesting if you think about it

00:21:27.490 --> 00:21:32.430
because on import Final Cut Pro will parse
the XML, it will create temporarily sort

00:21:32.430 --> 00:21:36.539
of off-line file representations
assuming the media file is not there.

00:21:36.539 --> 00:21:39.889
And of course it will read in all the
metadata elements you define in your XML.

00:21:39.890 --> 00:21:43.680
Of course the minute Final Cut Pro
goes attached to a file on disk,

00:21:43.680 --> 00:21:48.320
it will kill that metadata cache
in favor of the file on disk.

00:21:48.319 --> 00:21:54.859
Now, there are some commands we actually put in
the XML importer so that you could effectively say,

00:21:54.859 --> 00:21:59.000
no I don't want this key to be blown away I want
this key to be actually written in the file.

00:21:59.000 --> 00:22:02.019
These are fully covered in the documentation.

00:22:02.019 --> 00:22:05.339
They make use of the commands to
find for the update behavior key.

00:22:05.339 --> 00:22:13.559
This key is also used for some incremental project
update facilities we introduced last year as well.

00:22:13.559 --> 00:22:17.119
Here is an XML snippet with some metadata.

00:22:17.119 --> 00:22:18.539
And you'll see it right there.

00:22:18.539 --> 00:22:19.599
And it's pretty simple.

00:22:19.599 --> 00:22:22.349
We'll define that it came from QuickTime.

00:22:22.349 --> 00:22:27.779
We've got their reverse-DNS key we've defined as
well as the data type and the actual content.

00:22:27.779 --> 00:22:31.279
Depending on what the content of that key is,
you are either going to see that they are there

00:22:31.279 --> 00:22:33.220
in terms of the case of strings and numbers.

00:22:33.220 --> 00:22:38.170
Or you're going to see, you know, effectively U
encoded byte string there for binary data.

00:22:38.170 --> 00:22:45.410
And we'll switch back to demo station for just a minute.

00:22:45.410 --> 00:22:45.720
All right.

00:22:45.720 --> 00:22:49.410
So we had those files we were playing
with just a minute ago.

00:22:49.410 --> 00:22:55.080
And what I'm going to do now is go over to
Final Cut Pro and I've got an empty project here.

00:22:55.079 --> 00:22:59.439
And I'm just going to go ahead and
drop one of those into Final Cut.

00:22:59.440 --> 00:23:01.200
And we have a clip here.

00:23:01.200 --> 00:23:05.590
Now, this is the clip here in Final Cut
even though this piece of metadata here

00:23:05.589 --> 00:23:07.349
at the moment the user would never know it.

00:23:07.349 --> 00:23:10.469
All these fields are really all the same.

00:23:10.470 --> 00:23:12.509
The interesting part comes when I do an export.

00:23:12.509 --> 00:23:21.309
( Pause )

00:23:21.309 --> 00:23:26.940
And if I come back out here to the finder and open this up,

00:23:26.940 --> 00:23:29.700
you will see the metadata definition
that we talked about before.

00:23:29.700 --> 00:23:34.980
Now of course this is really a simple file in
the case of the P2 file we saw a few moments ago

00:23:34.980 --> 00:23:36.870
There'll be an awful lot of stuff here.

00:23:36.869 --> 00:23:39.509
But the interesting point here is all this data is there.

00:23:39.509 --> 00:23:44.529
So from an application perspective if all you're
doing is something relatively simple, you know,

00:23:44.529 --> 00:23:51.069
basically parsing through XML data, you are going to see
any metadata that anyone else put into those media files.

00:23:51.069 --> 00:23:53.509
If we can have the slides back, please.

00:23:53.509 --> 00:24:00.190
( Pause )

00:24:00.190 --> 00:24:06.080
Okay. So some take-home thoughts
for you about metadata support.

00:24:06.079 --> 00:24:11.649
Really what you want to think about is how you can
leverage metadata to make your customer's lives easier.

00:24:11.650 --> 00:24:16.840
If you have an application that creates
media for use in Final Cut or elsewhere,

00:24:16.839 --> 00:24:21.009
think about embedding interesting
bread crumbs into your media files.

00:24:21.009 --> 00:24:24.519
You know you can tell later on if your
application created a file, you can embed

00:24:24.519 --> 00:24:28.650
telemetry or other interesting ancillary data.

00:24:28.650 --> 00:24:32.330
And really just think about attaching
a relevant data to those files.

00:24:32.329 --> 00:24:38.710
For example, if you are building a backup or an asset tracking
application, you can embed your private IDs as metadata

00:24:38.710 --> 00:24:43.769
in those media files and they'll go wherever
the media file goes they'll go in the project.

00:24:43.769 --> 00:24:49.119
And you can build really simple tools that
finds those links and rebuilds them later on.

00:24:49.119 --> 00:24:52.099
Also think about caching interesting
data for post-production.

00:24:52.099 --> 00:24:54.899
We looked at that P2 source media file earlier.

00:24:54.900 --> 00:24:57.490
There's an awful lot of data there that was interesting.

00:24:57.490 --> 00:25:05.220
There's an awful lot more data that I've certainly heard from
camera operators and basic production crews in the field

00:25:05.220 --> 00:25:09.700
that would like to be able to drop in
their media to use as a reference later on.

00:25:09.700 --> 00:25:13.380
Another interesting point is to
properly label your metadata elements, you know.

00:25:13.380 --> 00:25:17.310
Talked about the nice things about reverse-DNS strings, you know.

00:25:17.309 --> 00:25:18.720
Not having namespace conflicts.

00:25:18.720 --> 00:25:23.190
If I never have to resolve another namespace conflict
with special case code, I will be a happy man.

00:25:23.190 --> 00:25:26.360
You know put your company name in there.

00:25:26.359 --> 00:25:29.569
Do some interesting description data, it's just a string, you know.

00:25:29.569 --> 00:25:35.419
Spend the bytes to actually define what your data
is so you'll know what it is and your customers

00:25:35.420 --> 00:25:38.230
and even other developers will know what your data is.

00:25:40.549 --> 00:25:45.359
So we focused on sort of two big areas of
technology, data interchange and metadata.

00:25:45.359 --> 00:25:51.089
And want to go ahead and talk about some more sort of
lessons that we've learned over the years for working

00:25:51.089 --> 00:25:57.019
with various developers about how to do
good clean interaction with Final Cut Pro.

00:25:57.019 --> 00:26:03.059
Now, of course, where I encourage you to start if you're
beginning this process for the first time is really

00:26:03.059 --> 00:26:09.179
to take a moment and think about for your application
or your workflow how do you really want to operate

00:26:09.180 --> 00:26:12.410
with Final Cut or really what are you doing?

00:26:12.410 --> 00:26:14.570
Are you doing an exchange tool?

00:26:14.569 --> 00:26:16.960
Are you doing an importer or an exporter?

00:26:16.960 --> 00:26:18.740
Are you doing more of an automation tool?

00:26:18.740 --> 00:26:24.269
Sort of build sequences and bins and clips
in Final Cut Pro in an automatic fashion?

00:26:24.269 --> 00:26:27.789
Or are you simply scraping them for interesting data?

00:26:27.789 --> 00:26:32.269
How is your application in Final Cut going
to make use of different media files?

00:26:32.269 --> 00:26:36.599
And also what development tools and
what languages are you going to use?

00:26:36.599 --> 00:26:41.789
That choice can really indicate not
only what XML parsing technologies you use,

00:26:41.789 --> 00:26:50.190
but potentially what interoperability
technologies with Final Cut Pro you make use of as well.

00:26:50.190 --> 00:26:56.269
Start off again with XML and, you know, just
to sort of drive a couple of these points home.

00:26:56.269 --> 00:27:01.180
Think about using XML to really link and
drive different stages in your workflow.

00:27:01.180 --> 00:27:06.370
Right. We talked earlier about, you know, not just moving
data between big complex systems but using it as sort

00:27:06.369 --> 00:27:09.859
of a repository for data throughout a production pipeline.

00:27:09.859 --> 00:27:12.299
You can also think about round-tripping XML.

00:27:12.299 --> 00:27:15.669
This is something we've seen a couple of
developers do really exciting things with.

00:27:15.670 --> 00:27:17.070
But not a whole lot of people yet.

00:27:17.069 --> 00:27:22.899
You think of a workflow where you have a sequence
in Final Cut, you take a piece of XML describing it,

00:27:22.900 --> 00:27:27.170
you run it through your tool and do interesting
modifications to it and then just turn right

00:27:27.170 --> 00:27:30.120
around and send it back into Final Cut Pro.

00:27:30.119 --> 00:27:32.769
You can make use of UUIDs and the update behavior keys.

00:27:32.769 --> 00:27:36.970
So when that XML comes back in, it just
goes ahead and replaces the original element

00:27:36.970 --> 00:27:39.200
in your project and your user will never know.

00:27:39.200 --> 00:27:46.140
And also think about you can do very interesting
and simple things just scraping the XML for data, you konw.

00:27:46.140 --> 00:27:49.620
If you are looking to just tracking
what media your projects are using.

00:27:49.619 --> 00:27:58.559
Another point which I'd hope more people
would have picked up more intuitively but --

00:27:58.559 --> 00:28:02.519
is the XML importer was designed from the beginning

00:28:02.519 --> 00:28:05.089
to support what we call "sparse" XML files.

00:28:05.089 --> 00:28:11.779
If you were to fill out every field on every clip
on every sequence and every bin on a Final Cut Pro project,

00:28:11.779 --> 00:28:15.289
and write that out as XML, you have a lot of data.

00:28:15.289 --> 00:28:20.399
In fact, if you do nothing more than import a
movie file into Final Cut and export an XML file,

00:28:20.400 --> 00:28:24.220
you will see a lot of fields there in that XML.

00:28:24.220 --> 00:28:26.610
You don't need all those keys to be present

00:28:26.609 --> 00:28:29.269
when you are coming back into Final Cut Pro.

00:28:29.269 --> 00:28:33.079
Really you only need to define the fields
with the data that are relevant to you.

00:28:33.079 --> 00:28:39.490
Final Cut Pro is, you know, just going to basically
use defaults for data that you don't put there.

00:28:39.490 --> 00:28:42.950
Anything that it needs to know that
like for example the frame rate

00:28:42.950 --> 00:28:49.150
for a codec potentially it will actually infer those
settings either from parent elements in terms of, you know,

00:28:49.150 --> 00:28:56.220
a clipitem in a sequence or even from the default
sequence preset that gets used on import.

00:28:56.220 --> 00:29:04.059
And don't be too worried about sort of going too far
with this because if you fail to define a key of something

00:29:04.059 --> 00:29:08.389
that is really needed the XML import is going
to throw an error and you're going to see a log

00:29:08.390 --> 00:29:12.650
in the console letting you know what data is missing.

00:29:12.650 --> 00:29:18.330
And really the hope behind all this was to simplify
your code, you know, just be able to keep you focused

00:29:18.329 --> 00:29:23.750
on defining the data you need to play with.

00:29:23.750 --> 00:29:27.660
Another workflow that we've seen some
companies make good use of is the concept

00:29:27.660 --> 00:29:30.390
of swapping media out from underneath a project file.

00:29:30.390 --> 00:29:31.940
Now, you can think of this as doing it on a sort

00:29:31.940 --> 00:29:36.420
of online off-line workflow moving
from low res media to high res media.

00:29:36.420 --> 00:29:39.180
Also think of this if you have a media
processing application that's going

00:29:39.180 --> 00:29:43.680
to take an existing media file, do some
effects on it and write a new one out.

00:29:43.680 --> 00:29:47.799
You can build a tool that will effectively
take an XML definition of a sequence,

00:29:47.799 --> 00:29:53.369
walk through all the file definitions and update the
definitions to point to brand new files on the disk.

00:29:53.369 --> 00:29:57.199
And also, you know, you'll see a file definition
for Final Cut and it will have a lot of information

00:29:57.200 --> 00:30:00.410
in it just like the point of clips and sequences.

00:30:00.410 --> 00:30:05.590
A file definition really only at its
heart needs to have a name and a URL.

00:30:05.589 --> 00:30:10.149
Most everything else assuming a file's there
can be inferred from the media file itself.

00:30:10.150 --> 00:30:15.000
So you don't need to go too insane by
putting all the little details in there.

00:30:15.000 --> 00:30:22.369
Something to watch our for about this though is another
optimization we put it in the XML export was the concept

00:30:22.369 --> 00:30:27.159
of using sort of "id" attributes to share file definitions.

00:30:27.160 --> 00:30:31.509
You'll want to watch out for what clips
you use what file definitions, you know,

00:30:31.509 --> 00:30:36.279
making sure to replace the fully filled out file
definition if you are just touching one file.

00:30:36.279 --> 00:30:39.859
But if you are changing the relationships
between different clips in different files,

00:30:39.859 --> 00:30:47.839
you may need to fill out definitions that are
sparsely defined during the export from Final Cut Pro.

00:30:47.839 --> 00:30:52.549
Another interesting point touched
on a little bit is the use of UUIDs.

00:30:52.549 --> 00:30:58.460
We added UUIDs last year to allow you to
uniquely identify elements in a project.

00:30:58.460 --> 00:31:03.350
These IDs basically get created when a clip
or sequence get made for the first time.

00:31:03.349 --> 00:31:07.929
And unless, you know, duplicate that item where
you have two of the same one in a project,

00:31:07.930 --> 00:31:12.990
that ID is going to stay the same throughout the life of
that project and the elements moved to the new projects.

00:31:12.990 --> 00:31:17.269
Combining the UUID tag with the updatebehavior
key allow you to do the

00:31:17.269 --> 00:31:20.220
in-place updates we talked about a few minutes ago.

00:31:20.220 --> 00:31:27.029
And you can use these commands to do basically
any browser level items, so clips and sequences.

00:31:27.029 --> 00:31:32.509
We'll go ahead and do another demo quick because
I sat down to prepare for this talk this year.

00:31:32.509 --> 00:31:35.990
Can we have the demo computer, please?

00:31:35.990 --> 00:31:36.789
Thank you.

00:31:36.789 --> 00:31:42.490
I sat down to do this talk this year and having
some feedback from a number of developers at NAB

00:31:42.490 --> 00:31:46.259
about, you know, some sample code they wanted to see.

00:31:46.259 --> 00:31:49.640
And, oh, excuse me one second.

00:31:49.640 --> 00:31:52.860
No, I don't want auto save, thank you.

00:31:52.859 --> 00:31:56.240
Where effectively they were trying to
do some very simple XML transformations, you know.

00:31:56.240 --> 00:32:01.529
They had workflows, they had different
tools and they couldn't quite take everything

00:32:01.529 --> 00:32:04.549
in a Final Cut Pro XML document and put it into an older tool.

00:32:04.549 --> 00:32:07.169
So they need to migrate between the two.

00:32:07.170 --> 00:32:11.529
So what I put together is this
application called Time Line to Time Code.

00:32:11.529 --> 00:32:16.039
And this is actually up on the
ADC developer site as sample code.

00:32:16.039 --> 00:32:21.059
And really all this application
does is take File Cut Pro XML.

00:32:21.059 --> 00:32:26.549
It does some minorly intelligent parsing
using XQuery and the NS XML classes

00:32:26.549 --> 00:32:31.009
and effectively takes all the edit times
in a sequence to build an edit list.

00:32:31.009 --> 00:32:36.579
Now, ironically this is somewhat similar to an
ADL but a lot sort simpler and actually is sort

00:32:36.579 --> 00:32:40.669
of oriented toward exactly what someone might
need to do with an interchange application.

00:32:40.670 --> 00:32:46.130
So I drug the XML file to my document or my
application and it went ahead and parseed it

00:32:46.130 --> 00:32:52.160
and just found all the sequences in here. It's displaying a
little bit of interesting information about that sequence.

00:32:52.160 --> 00:32:54.800
And it's got a number of attributes
here that it can go ahead and emit.

00:32:54.799 --> 00:32:57.230
So I'm just going to pick a couple.

00:32:57.230 --> 00:33:03.049
I'm just going to write an edit list.

00:33:05.019 --> 00:33:10.329
And if I drive -- what I'll do just as a comparison is, I'll
take the project I opened and I'll take this edit list

00:33:10.329 --> 00:33:12.639
and I'll drag them both off to BBEdit.

00:33:12.640 --> 00:33:14.759
And this is the edit list, you know.

00:33:14.759 --> 00:33:18.849
It's a very simple something you can
pull into XML, just a tabbed limited list.

00:33:18.849 --> 00:33:21.879
You know, a number of start end duration times.

00:33:21.880 --> 00:33:25.750
And of course this is the XML that it all originated with.

00:33:25.750 --> 00:33:30.730
And it's just a lot of data when you may have
an application which literally just needs this.

00:33:30.730 --> 00:33:34.180
Another piece of code in this sample
that you'll probably want to look

00:33:34.180 --> 00:33:38.070
at is actually some frame count time code conversion code.

00:33:38.069 --> 00:33:41.250
It's actually what gets used to
generate all these numbers you see here.

00:33:41.250 --> 00:33:47.349
Again something that a number of developers
asked to help accelerate their XML development.

00:33:47.349 --> 00:33:50.369
Slides back, please.

00:33:51.509 --> 00:33:58.730
( pause )

00:33:58.730 --> 00:33:59.509
Moving on.

00:33:59.509 --> 00:34:01.180
Let's talk about AppleEvents.

00:34:01.180 --> 00:34:04.740
This is something we haven't mentioned
before in this presentation.

00:34:04.740 --> 00:34:06.370
We introduced this last year.

00:34:06.369 --> 00:34:08.940
Again based on developer requests.

00:34:08.940 --> 00:34:13.559
Developers had certain workflows where
they wanted to automate a couple commands

00:34:13.559 --> 00:34:16.039
in Final Cut Pro just to make things smoother.

00:34:16.039 --> 00:34:19.949
In looking through the problem we
basically came back with building a couple

00:34:19.949 --> 00:34:22.619
of strategic AppleEvent commands in place.

00:34:22.619 --> 00:34:28.299
So that you automate interesting things like opening and
closing projects, getting XML managing selection.

00:34:28.300 --> 00:34:30.710
An important point here another point

00:34:30.710 --> 00:34:35.510
of confusion I had to content with the last year
is that this is AppleEvent support.

00:34:35.510 --> 00:34:38.030
This is not AppleScript support.

00:34:38.030 --> 00:34:41.769
AppleScript is a lot more complex
than what we've done here.

00:34:41.769 --> 00:34:45.920
It's certainly interesting but
it's not something we have today.

00:34:45.920 --> 00:34:51.119
Full documentation for all of the commands
really for this are available actually in the XML

00:34:51.119 --> 00:34:53.670
in the same document that's the XML documentation.

00:34:53.670 --> 00:35:01.940
There's also a number of sample applications
on the Apple developer site illustrating this.

00:35:01.940 --> 00:35:06.200
For importing XML there's an import XML document command.

00:35:06.199 --> 00:35:10.339
Another interesting point and something that we
really didn't document very well in past years.

00:35:10.340 --> 00:35:15.260
Is that we've actually had this wired
up pretty much since the beginning,

00:35:15.260 --> 00:35:21.820
such that you could take an XML document with the right
extension and right type and creater code and drop it

00:35:21.820 --> 00:35:26.530
onto the Final Cut Pro application icon and it would go ahead
and motivate an XML import operation.

00:35:26.530 --> 00:35:31.970
This is really just putting an explicit AppleEvent
in front of that existing functionality.

00:35:31.969 --> 00:35:40.669
Another point here to note is this will just do the
equivalent of the user just going to file, import XML.

00:35:40.670 --> 00:35:47.530
So unless you put an import option scope in
your XML to hide the import UI you will see it.

00:35:47.530 --> 00:35:52.200
Again, the import option scope is also
covered in full detail in the documentation.

00:35:52.199 --> 00:35:59.119
Working with project files, plans to open save and close.

00:35:59.119 --> 00:36:04.369
Note that this command will take a URL to
indicate what project you're working on.

00:36:05.940 --> 00:36:13.590
Go ahead and basically ask for an XML
representation project again using the URL.

00:36:13.590 --> 00:36:15.300
Couple of tips that we found.

00:36:15.300 --> 00:36:20.600
I've written a couple of sample applications using AppleEvents
in working with some developers who have been using it.

00:36:20.599 --> 00:36:29.679
Keep track of, depending on which AppleEvent command you
are using, the particular identifying data you need,

00:36:29.679 --> 00:36:34.839
to use. You know, in some case it could be
UUID, in some case it could be a URL.

00:36:34.840 --> 00:36:39.860
Another point sort of for application
performance and interactivity is to think

00:36:39.860 --> 00:36:44.360
about putting your AppleEvent code on a
separate thread from your main application loop.

00:36:44.360 --> 00:36:49.829
There are times it might take Final Cut Pro a little bit of time to
do something and you might not want your applications

00:36:49.829 --> 00:37:00.150
sort of blocked there or at least sort of hard locked
there waiting for Final Cut Pro to do its processing.

00:37:00.150 --> 00:37:01.780
Move on to metadata.

00:37:01.780 --> 00:37:06.760
Mentioned erlier that we had support for
metadata with Final Cut Pro 5.12, you know,

00:37:06.760 --> 00:37:11.530
the cache model that we talked about, XML accessibility.

00:37:11.530 --> 00:37:17.900
And a point here to think about is that we went through
some trouble to put the metadata editing commands

00:37:17.900 --> 00:37:23.710
in the XML importer but we really would
prefer that especially on a production level

00:37:23.710 --> 00:37:26.240
that you use the QuickTime APIs directly.

00:37:26.239 --> 00:37:30.199
Really those commands were there
for prototyping and help power users out.

00:37:30.199 --> 00:37:34.480
And, you know, while they are there, they function
they are not necessarily the highest performance

00:37:34.480 --> 00:37:39.880
and they are not always going to give you the granularity
of control that you will want in editing your metadata.

00:37:39.880 --> 00:37:47.300
And another point which I forgot to mention earlier

00:37:47.300 --> 00:37:51.320
with XML we found it's really been
powerful to have human readable data there.

00:37:51.320 --> 00:37:57.050
You know so that if something is going wrong and someone
opens a file, you know, search for some text and find

00:37:57.050 --> 00:38:02.210
and fix a problem and this lesson
also really applies to metadata.

00:38:02.210 --> 00:38:08.309
You know, it may be that you have, you know, a chunk of
interesting data you want to store in a movie file,

00:38:08.309 --> 00:38:14.130
and you can squeeze that down into, you know, 32
bytes, 64 byt2es, if just put it in a binary block

00:38:14.130 --> 00:38:22.539
of data. It's really a lot better to break those things
out into individual keys, use strings, use numbers.

00:38:22.539 --> 00:38:27.070
It's going to save your users and other
developers trouble if they need to parse your data.

00:38:27.070 --> 00:38:33.850
And it's also going to save you from sort of platform
issues in terms of struct alignment or byte swapping.

00:38:34.909 --> 00:38:41.969
And with that actually I'd like to ask a colleague
of mine to come up on stage for the moment.

00:38:41.969 --> 00:38:46.859
J.R. Hass came to us a little while ago
working on new application we announced this year called "Color"

00:38:46.860 --> 00:38:49.789
and I'd like to have him give you some of his thoughts.

00:38:49.789 --> 00:38:50.579
>> Thanks, David.

00:38:50.579 --> 00:38:55.690
(applause) Hello, good afternoon.

00:38:55.690 --> 00:38:57.240
My name is J.R. Hass.

00:38:57.239 --> 00:39:02.029
As David mentioned I'm one of the engineers
whose worked on the new Color application.

00:39:03.449 --> 00:39:05.359
So what is Color?

00:39:05.360 --> 00:39:08.099
First and foremost Color is a standalone application.

00:39:08.099 --> 00:39:15.009
It's now part of the new Final Cut Studio
and it's a GPU-based color correction tool.

00:39:15.010 --> 00:39:21.050
So what I mean by color correction is simply
just adjusting the color of a digital movie.

00:39:21.050 --> 00:39:26.680
So a quick example would be say you
have a clip that was shot in the daytime

00:39:26.679 --> 00:39:28.879
and you wanted to give it a night time look and feel.

00:39:28.880 --> 00:39:32.349
Well, you can use Color to achieve that look.

00:39:32.349 --> 00:39:36.319
And being from Apple it of course supports QuickTime.

00:39:36.320 --> 00:39:41.640
And for those in the film space
it also supports DPX sequences.

00:39:42.750 --> 00:39:49.090
With that what is the Color grading workflow
or where does Color fit in the picture?

00:39:49.090 --> 00:39:51.230
Well, this is the digital age.

00:39:51.230 --> 00:39:56.469
We would first expect our users to acquire
some sort of high quality digital media.

00:39:56.469 --> 00:40:02.480
And then using that media they would complete
and edit with a tool such as Final Cut.

00:40:02.480 --> 00:40:09.130
At this point they could then send that edit with their
digital media to Color to have a colorist color correct it,

00:40:09.130 --> 00:40:18.390
make it look good, render it out and then send that
graded project back to the editor for a final output save.

00:40:22.239 --> 00:40:25.639
What were some of the goals we had
when implementing this workflow?

00:40:25.639 --> 00:40:31.750
Well, our primary goal was to streamline
this interaction between Final Cut and Color.

00:40:31.750 --> 00:40:37.570
We really wanted the round trip experience to
be as seamless and as accurate as possible.

00:40:37.570 --> 00:40:40.769
In other words we wanted the editor to worry about editing.

00:40:40.769 --> 00:40:46.409
The Colorist having to worry about coloring but
neither would have to worry about managing media files

00:40:46.409 --> 00:40:50.819
or misplacing files or transferring information.

00:40:53.409 --> 00:40:58.379
A solution that satisfied this goal was Final Cut's XML.

00:40:58.380 --> 00:41:04.010
Using Final Cut's XML in Color we are
able to recreate the Final Cut timeline.

00:41:04.010 --> 00:41:11.830
So this makes it really easy for a colorist to start color
correcting cut and grade the project and make it look good.

00:41:11.829 --> 00:41:21.110
And then we are also able to read in some other information
as well such as the geometry data from Final Cut.

00:41:21.110 --> 00:41:28.050
After the colorist is done, he can then spit out a
new XML file but using the original as a reference

00:41:28.050 --> 00:41:35.000
and send that color graded good looking project
back to the editor for a final output.

00:41:39.130 --> 00:41:43.079
What are some lessons we learned
from implementing this workflow?

00:41:43.079 --> 00:41:48.739
Well, as David's been talking about XML contains
an abundant amount of information compared this

00:41:48.739 --> 00:41:52.519
to other older formats to which just might contain the cuts.

00:41:52.519 --> 00:41:56.050
XML is going to contain the geometry as I mentioned

00:41:56.050 --> 00:42:01.570
but also the transition information
and your plug-ins that you might be using.

00:42:01.570 --> 00:42:07.720
Now, it turns out that Color doesn't
support all of the things that is in the XML

00:42:07.719 --> 00:42:10.819
but that's okay because XML is very scalable.

00:42:10.820 --> 00:42:15.670
So the things that we don't support we just
ignore but that plays an important role

00:42:15.670 --> 00:42:18.460
and we complete that round trip experience.

00:42:18.460 --> 00:42:25.750
Because when we generate a new XML file, that stuff is still
there and it's just applied to the color corrected content.

00:42:25.750 --> 00:42:28.840
So the editor doesn't lose any of his work either.

00:42:28.840 --> 00:42:33.870
And also there are several tools available to parse XML.

00:42:33.869 --> 00:42:39.469
So you'd be really hard pressed to find
a programing language or a platform

00:42:39.469 --> 00:42:43.319
that doesn't already have tools
available for you to parse that XML.

00:42:43.320 --> 00:42:50.440
So you don't need to reinvent the wheel, you
can just worry about processing that data.

00:42:50.440 --> 00:42:53.990
And also as David mentioned XML is just text.

00:42:53.989 --> 00:42:58.929
So as developers it makes it very easy to debug.

00:42:58.929 --> 00:43:06.250
And as a final note I'd just like to mention that even
though Color is from Apple the core technologies we use

00:43:06.250 --> 00:43:12.050
to create the interoperability between Final Cut and
Color are the same ones available to you as developers.

00:43:12.050 --> 00:43:15.140
It's just that XML and AppleEvents APIs.

00:43:15.139 --> 00:43:20.989
So it really is powerful stuff and it played a crucial
role in implementing this workflow that I described in Color.

00:43:20.989 --> 00:43:22.509
I will now give the stage back to David.

00:43:22.510 --> 00:43:33.740
( applause )

00:43:33.739 --> 00:43:34.669
>> The microphone is malfunctioning here.

00:43:34.670 --> 00:43:35.510
Excuse me.

00:43:35.510 --> 00:43:43.490
( background noise )

00:43:43.489 --> 00:43:46.519
All right.

00:43:46.519 --> 00:43:48.360
Clicker would be handy.

00:43:50.309 --> 00:43:53.539
So we'll go ahead and do another demo now.

00:43:53.539 --> 00:43:58.059
This is another application I built to illustrate a
number of concepts we've been talking about today.

00:43:58.059 --> 00:43:59.509
So can we have the demo station, please.

00:43:59.510 --> 00:44:07.620
( background noise )

00:44:07.619 --> 00:44:07.989
All right.

00:44:07.989 --> 00:44:09.519
We'll try this out.

00:44:09.519 --> 00:44:15.480
So we talked about AppleEvents, we talked
about XML and we talked about metadata.

00:44:15.480 --> 00:44:18.840
And really these technologies are built to build workflows.

00:44:18.840 --> 00:44:22.550
So I thought I'd go ahead and show
you a workflow that I went ahead

00:44:22.550 --> 00:44:26.240
and prototyped up using these tools and Final Cut Pro.

00:44:26.239 --> 00:44:30.889
So I have a copy of Final Cut Pro running here
this is the project we were playing with earlier.

00:44:30.889 --> 00:44:37.159
And just for clarity I'm going to go ahead and close it.

00:44:37.159 --> 00:44:40.399
And I've got an application here on
the desktop called Movie Assembler.

00:44:40.400 --> 00:44:48.349
Now, the workflow this is really meant to soft of prototype is
that of sort of an assembly station for a news organization.

00:44:48.349 --> 00:44:51.449
We are just keeping a current cut of the film up to date.

00:44:51.449 --> 00:44:57.099
And the concept here is really that I may have a
project where media is coming in at various times.

00:44:57.099 --> 00:45:01.360
Right. And I need to go ahead and constantly
keep that new media in sync with my project.

00:45:01.360 --> 00:45:06.800
So that at any point the client or the producer
can come in and see the current state of things.

00:45:06.800 --> 00:45:10.810
So I have a project down here, this is just a
short film I'm working on, just going to go ahead

00:45:10.809 --> 00:45:14.090
and drop that onto the Movie Assembler to open it.

00:45:14.090 --> 00:45:17.730
And you'll notice here it's got a list of the sequence here.

00:45:17.730 --> 00:45:21.780
It went ahead and parsed the XML to
infer sort of what the media paths are.

00:45:21.780 --> 00:45:25.769
And it went ahead and opened it up here
in Final Cut Pro in the background.

00:45:25.769 --> 00:45:30.000
Interesting point to note here is
that the project file that I dropped

00:45:30.000 --> 00:45:33.809
onto this application was a Final Cut Pro project file.

00:45:33.809 --> 00:45:40.500
To get the XML it opened up on Final Cut, then
using AppleEvents requested an XML version of it.

00:45:40.500 --> 00:45:46.690
Now, if I come and look at my sequence here, you know,
I have the clips sort of typical comedic office drama.

00:45:46.690 --> 00:45:50.559
And the problem I have here is this clip is wrong.

00:45:50.559 --> 00:45:54.029
I had him sitting down and then
he's walking down the hallway.

00:45:54.030 --> 00:45:56.730
And that's just really not the right media.

00:45:56.730 --> 00:45:59.230
So someone needs to go out and reshoot this.

00:45:59.230 --> 00:46:00.949
So go ahead and come back to Movie Assembler.

00:46:00.949 --> 00:46:04.989
And I'm going to go ahead and tell it to monitor
a watch folder, this incoming folder here.

00:46:04.989 --> 00:46:06.509
So I'll go ahead and start this up.

00:46:06.510 --> 00:46:18.610
( pause )

00:46:18.610 --> 00:46:19.510
Hopefully a little bit better.

00:46:19.510 --> 00:46:20.390
There we go.

00:46:20.389 --> 00:46:23.420
So I've gone ahead and got this monitor in this watch folder.

00:46:23.420 --> 00:46:26.610
And you'll see these basic fields grayed
out indicating it's doing something.

00:46:26.610 --> 00:46:30.360
So when I come back to finder,
and I've got this movie file here.

00:46:30.360 --> 00:46:34.090
Now, in this case I'm going to assume
this media file was the corrected footage.

00:46:34.090 --> 00:46:37.809
So I'm going to go ahead and just put
a copy of it in my incoming folder.

00:46:40.210 --> 00:46:44.340
And after it copied you go ahead and
save, Final Cut Pro will update it.

00:46:44.340 --> 00:46:48.530
And you'll see a message here in the log that it
went ahead and found the file and did an update.

00:46:48.530 --> 00:46:54.610
Now, if I open up the sequence, zoom out a little bit.

00:46:54.610 --> 00:46:59.220
We'll see that it went ahead and replaced
the incorrect footage with the right shot

00:46:59.219 --> 00:47:04.559
of our hero sitting at his desk getting lots of
work, or may be it's bugs I'm not quite sure.

00:47:04.559 --> 00:47:09.079
So this application is also up on the ADC Developer site.

00:47:09.079 --> 00:47:15.619
Makes use of NSXML, XQuery to parse XML,
AppleEvent communication with Final Cut Pro.

00:47:15.619 --> 00:47:18.750
And of course Cocoa to do the UI
and the watch folder monitoring.

00:47:18.750 --> 00:47:20.510
Cab we have slides again, please?

00:47:20.510 --> 00:47:28.570
( pause )

00:47:28.570 --> 00:47:32.780
Okay. So where to go for more information.

00:47:32.780 --> 00:47:37.960
Well, we have a number of example applications
up on the web, up on the Apple Developer site.

00:47:37.960 --> 00:47:44.389
We have the documentation we mentioned up there I know
we just recently updated it for a Final Cut Pro 6. Couple

00:47:44.389 --> 00:47:47.179
of labs and sessions coming up, think about this week.

00:47:47.179 --> 00:47:51.759
Tomorrow there's a QuickTime session
on advanced digital video techniques.

00:47:51.760 --> 00:47:55.870
Actually we're going to talk about a lot of interesting
things in that session, you know, color spaces,

00:47:55.869 --> 00:48:00.719
pixel formats, sort of gotchas that come
up for anyone processing QuickTime media.

00:48:00.719 --> 00:48:06.169
On Friday we have two more sessions for the
Final Cut studio team, focusing on FXPlug.

00:48:06.170 --> 00:48:08.289
Both basic and advanced methods.

00:48:08.289 --> 00:48:13.050
And we also have a Pro Applications lab
running in parallel with the second session.

00:48:13.050 --> 00:48:16.710
And we'll actually have people at that
lab including myself to talk about a range

00:48:16.710 --> 00:48:23.349
of pro apps integration technologies,
if you do have questions.

00:48:23.349 --> 00:48:25.589
So really what's the summary we want you to take home here.

00:48:25.590 --> 00:48:29.700
If you are building tools, leverage
what Final Cut Pro can do, you know.

00:48:29.699 --> 00:48:32.980
If you don't need to reinvent the wheel, please don't.

00:48:32.980 --> 00:48:36.639
Please make use of the things we put together.

00:48:36.639 --> 00:48:37.750
XML is really powerful.

00:48:37.750 --> 00:48:40.119
It's not just for imports and exports.

00:48:40.119 --> 00:48:44.579
You can use AppleEvents as sort of automate
things for you users and simplify things.

00:48:44.579 --> 00:48:47.059
And really think about the metadata angle.

00:48:47.059 --> 00:48:53.590
This is something that certainly more and more customers
are asking for in terms of them wanting to track the media

00:48:53.590 --> 00:48:56.240
within their own workflow and own asset management systems.

00:48:56.239 --> 00:48:59.179
And they are all looking for tools
to really make this happen.
WEBVTT

00:00:16.589 --> 00:00:24.100
>>Good morning everyone, welcome to the certain
last Quartz composition during this WWDC 2007

00:00:24.100 --> 00:00:28.580
so my name's Pierre-Olivier Latour, I am the
Engineering Manager for Quartz Composer

00:00:28.579 --> 00:00:32.549
and today during this session we're going to look
at using Quartz Composer in your applications

00:00:32.549 --> 00:00:35.439
through concrete integration case studies.

00:00:35.439 --> 00:00:40.570
So, what you will learn during these sessions
are first of all we'll do a rapid overview

00:00:40.570 --> 00:00:44.490
of what's new regarding the propers
for Quartz Composer and Leopard.

00:00:44.490 --> 00:00:47.390
And then we'll have a look at those
case studies I just mentioned.

00:00:47.390 --> 00:00:53.030
So there's going to be one where we set up some simple data
visualization directly on the desktop and the other one

00:00:53.030 --> 00:00:58.250
where we look at another way to visualize movies and
the final one we're going to look at how we built

00:00:58.250 --> 00:01:03.670
that Quartz Composer visualizer which you can see
in the graphics and imaging lab downstairs.

00:01:03.670 --> 00:01:07.920
And through those three examples we're
obviously going to build some custom patches

00:01:07.920 --> 00:01:10.829
which is the big news things for you guys.

00:01:10.829 --> 00:01:15.700
We're going to make some assumptions during this session,
three of them basically that you already played

00:01:15.700 --> 00:01:22.549
with Quartz Composer and editor application, that you
played as well a little with the basic Quartz Composer API's

00:01:22.549 --> 00:01:29.299
for example QCView or QCRenderer and also that you are
familiar with the basics of Objective-C 2.0 properties

00:01:29.299 --> 00:01:34.340
because we rely on that for the writing
custom plug-ins, custom patches.

00:01:34.340 --> 00:01:39.689
So first of all, a quick tour of all
the new features that effect developers.

00:01:39.689 --> 00:01:41.179
What is Quartz Composer and Leopard?

00:01:41.180 --> 00:01:43.010
Well, it's truly a matrix technology.

00:01:43.010 --> 00:01:49.410
The first version of Quartz Composer was released in
Tiger and now two years later, there's been a lot of work

00:01:49.409 --> 00:01:56.170
that went in and one of the first things you will notice
is, we've done a lot of work to improve the image processing

00:01:56.170 --> 00:02:02.329
which is usually at the heart of Quartz Composer and that
means concretely the ability to handle very large images,

00:02:02.329 --> 00:02:07.079
high precision data floating point
for instance, very efficiently as well

00:02:07.079 --> 00:02:10.710
as full color matching all the way, correct on everything.

00:02:10.710 --> 00:02:13.860
So it's a big improvement whereas what you had in Tiger.

00:02:13.860 --> 00:02:20.570
Then like I mentioned, the ability for you to write custom
patches, we also have system wide composition repository

00:02:20.569 --> 00:02:26.009
which we mentioned during the first couple of Quartz
Composer sessions, and a bunch of new API's available

00:02:26.009 --> 00:02:28.689
and we're only going to look at a few of them today.

00:02:28.689 --> 00:02:32.770
Now when it comes to development environment
itself, the editor has been redesigned.

00:02:32.770 --> 00:02:38.540
We have lots of changes under the hood and I'm sure
you noticed that if you went to yesterday's session

00:02:38.539 --> 00:02:42.689
and when it comes to the patches
themselves, we also have a lot of new patches

00:02:42.689 --> 00:02:45.120
and many changes on the already existing one.

00:02:45.120 --> 00:02:51.530
So rapidly the new editor template helps you get
started faster, it has a lot of new features in it,

00:02:51.530 --> 00:02:55.210
you are ready to create now it's in the
workspace, I did the parameters in line.

00:02:55.210 --> 00:03:01.870
You can have timelines; we improve the way of
creating patches using that floating window there.

00:03:01.870 --> 00:03:08.950
A lot of changes, so I highly encourage you to look at
it; something that wasn't mentioned so far is the ability

00:03:08.949 --> 00:03:15.359
to edit meta data inside the composition so you can
now attach any kind of regular plist like meta data

00:03:15.360 --> 00:03:23.400
like dictionary string attributes and so forth in
the file and retrieve them from your application

00:03:23.400 --> 00:03:29.819
by using the attributes method on
the QCView or QCRenderer and so on.

00:03:29.819 --> 00:03:36.389
So it's pretty useful, and to integrate better into
your work flow when you develop compositions especially

00:03:36.389 --> 00:03:42.629
if you have source version controlling your environment
where you wouldn't really be able to decomposition directly

00:03:42.629 --> 00:03:50.449
because they are essentially battery files, we now have
a nice composition comparator built inside the editor.

00:03:50.449 --> 00:03:55.929
When it comes to programming inside the Quartz
Composer environment, the Core Image kernel patch

00:03:55.930 --> 00:04:00.590
and the JavaScript patches have been redesigned
completely, they are a lot more powerful and invite you

00:04:00.590 --> 00:04:06.950
to watch yesterday's session if you want more information
about those and also some mention on that slide

00:04:06.949 --> 00:04:10.250
which we have a new GLSL patch as well for programming.

00:04:10.250 --> 00:04:17.800
An interesting new patch for developers is the composition
loader new in Leopard, and what it does is allows you

00:04:17.800 --> 00:04:23.319
to load a composition from what's in a file on disk
into another composition that's currently running.

00:04:23.319 --> 00:04:26.870
So as you can imagine, it's pretty powerful
because it really allows you to instead

00:04:26.870 --> 00:04:32.790
of having a big monolithic composition where you have
absolutely everything in it, you export it in sub pieces

00:04:32.790 --> 00:04:40.550
that are easier to manage or to edit or that your graphic
card is to work with, you can easily modify without risking

00:04:40.550 --> 00:04:43.530
to break the whole scheme or something like that.

00:04:43.529 --> 00:04:48.750
So using the composition loader you can completely
configure the way you want and it's really powerful.

00:04:48.750 --> 00:04:56.610
I also wanted to talk about virtual
patches, something new in Leopard

00:04:56.610 --> 00:05:02.080
and it's basically writing passed custom
patches without having to code in Xcode.

00:05:02.079 --> 00:05:04.359
So what exactly does that mean?

00:05:04.360 --> 00:05:08.830
You start by creating your regular composition
file and you publish inputs and outputs

00:05:08.829 --> 00:05:11.990
at the top level, so nothing changes so far.

00:05:11.990 --> 00:05:17.329
Then what you do with that file is you drop it
into library graphics Quartz Composition patches

00:05:17.329 --> 00:05:19.889
or to dot library graphics Quartz Composer patches.

00:05:19.889 --> 00:05:24.839
Then you relaunch the editor or actually any application
that uses Quartz Composer so that the change is taken

00:05:24.839 --> 00:05:30.719
into account and now your composition file
is actually available as a stand alone patch.

00:05:30.720 --> 00:05:39.960
And you can just drag and drop it like any other patch
that would be native into the workspace and use it

00:05:39.959 --> 00:05:43.930
and it's not a Micro patch, if you double
click on it you won't be able to edit it,

00:05:43.930 --> 00:05:52.090
but it's really kind of a weak link between the file that's
on disk and the inclusion inside the composer composition.

00:05:52.089 --> 00:05:57.679
If you change your file on disk, the changes are reflected,
it has exactly at the plug-in if you open a composition

00:05:57.680 --> 00:06:03.920
and this virtual patch is not in place then you will get an
error, you won't be able to properly load the composition.

00:06:03.920 --> 00:06:08.689
Briefly about the composition repository,
so it's really this idea

00:06:08.689 --> 00:06:13.519
of Quartz Composer becoming the standard web expression
motion graphics and visual effects and the platform

00:06:13.519 --> 00:06:20.159
so now we have a nice area where we can put all those
composition files and share them between applications.

00:06:20.160 --> 00:06:23.800
So this relies on the fact that
we define a number of protocols

00:06:23.800 --> 00:06:27.710
which are a pretty fine set of
inputs and outputs for compositions.

00:06:27.709 --> 00:06:35.379
Any composition file you drop in there will automatically
be taken advantage of by the compatible applications

00:06:35.379 --> 00:06:42.040
and we have a few out of the box in the system for you to
write a lot of them, and some example protocols are filters,

00:06:42.040 --> 00:06:44.129
omission transitions, those kind of things.

00:06:44.129 --> 00:06:48.459
And it comes with an API as you can guess.

00:06:48.459 --> 00:06:54.060
Now let's look at the integration API's and Quartz Composer
so that you can use Quartz Composer in the application.

00:06:54.060 --> 00:06:58.149
There are essentially four of them,
the first one is new for Leopard

00:06:58.149 --> 00:07:02.599
and is a new concept is a QCComposition;
we're going to look at that in a minute.

00:07:02.600 --> 00:07:06.060
We also have another new class which is
the QCComposition layer which allows you

00:07:06.060 --> 00:07:12.459
to integrate seamlessly Quartz Composition
contents inside kernel emission trees, layer trees.

00:07:12.459 --> 00:07:17.569
And finally the old kind of two API's
which run in Tiger, QCView and QCRenderer,

00:07:17.569 --> 00:07:23.610
the first one being for integration nicely, easily, inside
interface builder for instance, Cocoa binding and so forth.

00:07:23.610 --> 00:07:28.170
And the other one, the QCRenderer
really being the overall API,

00:07:28.170 --> 00:07:34.280
so let's look at QCComposition,
what exactly is that new beast?

00:07:34.279 --> 00:07:41.089
It's an abstract class that represents a composition
file and we realize we need it to introduce a new concept

00:07:41.089 --> 00:07:46.119
because we moved this composition around between the
API's and there was no abstraction prior to that.

00:07:46.120 --> 00:07:51.870
You were dealing with the files on disk and introduction
of the repository especially meant that required.

00:07:51.870 --> 00:07:54.649
So how do you get or create those composition files?

00:07:54.649 --> 00:08:01.299
Well the first step, the first possibility, is that you get
them from the repository where you can get a composition,

00:08:01.300 --> 00:08:06.879
a QCComposition instance if you know the item key file
specifically the composition you want in the repository,

00:08:06.879 --> 00:08:12.199
or you can ask the repository for all the composition
that complies so instead of protocols and attributes

00:08:12.199 --> 00:08:15.479
and it will return you an area of QCComposition objects.

00:08:15.480 --> 00:08:21.160
The other possibility is to create then indirectly
for instance, it can them from a file on disk

00:08:21.160 --> 00:08:29.500
or from a data blog and that's interesting to data case
for developers who want to product their compositions,

00:08:29.500 --> 00:08:31.680
because remember they're completely open source.

00:08:31.680 --> 00:08:35.970
So if you want to kind of encrypt them
or you don't want to have your users

00:08:35.970 --> 00:08:39.160
or competitors look at how this composition is designed.

00:08:39.159 --> 00:08:43.689
Well, you can just encrypt them and at the
end of the day what you need to do is decrypt,

00:08:43.690 --> 00:08:51.260
have the data blog be exactly what the content that QC file
is on disk, and you can pass that to composition with data.

00:08:51.259 --> 00:08:55.240
Or you can also transmit composition over
to network frame for instance using that.

00:08:55.240 --> 00:09:00.600
And eventually you have some curing abilities on the
QCComposition object; you know you can get the protocol,

00:09:00.600 --> 00:09:04.399
the attributes, and the least of inputs and outputs.

00:09:04.399 --> 00:09:12.069
The other change we did regarding the API is we now
have QCView, QCRenderer, and QCComposition layer,

00:09:12.070 --> 00:09:16.640
and they're all composition renderers
so in order to simplify the API's,

00:09:16.639 --> 00:09:22.179
we kind of factored out all the common matters between them
and they just all comply to QCComposition renderer protocol.

00:09:22.179 --> 00:09:27.329
So you will find in there as usual the ability to achieve
properties of the composition that's currently loaded

00:09:27.330 --> 00:09:35.750
on the renderer, the ability to read and set the
inputs, the ability to retrieve the output results,

00:09:35.750 --> 00:09:41.720
and here I like to point out we have a new API in Leopard
and as you can see the second line value for output key

00:09:41.720 --> 00:09:48.570
of type, so now you're not limited to the default object
type that you get from the resolute of the composition.

00:09:48.570 --> 00:09:52.920
You can actually say for instance, if you want
to get, if you're composition output's an image,

00:09:52.919 --> 00:10:01.079
you used to only get an NS image out, now you can say I want
that output value of the composition but give me a CG metro,

00:10:01.080 --> 00:10:05.280
CIE metro, whatever is convenient for you to
integrate with the rest of your pipeline.

00:10:05.279 --> 00:10:10.500
So that's really great and it works with other types
as well, for example structures you can get as arrays

00:10:10.500 --> 00:10:17.429
or dictionaries, etc. And finally two new API's of
interest as well on that protocol the ability to save

00:10:17.429 --> 00:10:20.419
in one shot all the current values, all the inputs

00:10:20.419 --> 00:10:23.629
of the composition that's currently
loaded on the renderer or restore them.

00:10:23.629 --> 00:10:28.889
And it sets them in a convenient p list like format so
you can actually look into it and you can also just put

00:10:28.889 --> 00:10:30.659
that directly in a profile or something I bet.

00:10:30.659 --> 00:10:37.769
Now to talk about the Core Animation support, so
it's really nice because you can use all the power

00:10:37.769 --> 00:10:41.750
of Quartz kernels to create motion
graphics or effects, those kind of things

00:10:41.750 --> 00:10:44.820
and bring them seamlessly inside Core Animation on a layer.

00:10:44.820 --> 00:10:50.850
So, really it's one line of good, its composition layer
with file or with a QCComposition object and there you go,

00:10:50.850 --> 00:10:53.269
you have your layer, you insert
it in your tree and you're done.

00:10:53.269 --> 00:10:57.529
And because it's also a QCComposition
renderer object like I just said,

00:10:57.529 --> 00:10:59.970
you have all those regular methods you can use with.

00:11:01.830 --> 00:11:09.090
The QCView has many changes on the API, I'm just going
to point out a few you can pause, yet more precise control

00:11:09.090 --> 00:11:12.980
over the playback so you can pause
and resume rendering for instance.

00:11:12.980 --> 00:11:17.690
A powerful ability now is if you
subtract the QCView you can override it

00:11:17.690 --> 00:11:20.280
so it's not designed so you call
it directly, do not do that.

00:11:20.279 --> 00:11:24.480
It's only for overriding the renderer at
time arguments mattered which is a primitive.

00:11:24.480 --> 00:11:29.080
Every time a frame is valid it goes through that,
so what's the point of overriding it if you want

00:11:29.080 --> 00:11:35.300
to do precise synchronized communication with a
composition for example, only if the inputs just before it's

00:11:35.299 --> 00:11:39.069
about to render are only the ready
outputs after it has rendered.

00:11:39.070 --> 00:11:44.330
And you can also retrieve now the OpenGL context
and pixel format choosing to render this is also not

00:11:44.330 --> 00:11:49.500
so that you can draw with them, but it's that you can
share other OpenGL contexts, for example Core Video,

00:11:49.500 --> 00:11:54.990
or actually QuickTime visual contexts, those
kind of objects, be able to create them properly.

00:11:54.990 --> 00:11:58.269
The QCRenderer, I'm also just going
to point out a few new methods.

00:11:58.269 --> 00:12:07.039
The first one is the ability to create a QCRenderer from
core OpenGL contacts so it doesn't go more lower than that

00:12:07.039 --> 00:12:13.429
in a system level for OpenGL contexts so you can
create it from really any kind of OpenGL contexts now.

00:12:13.429 --> 00:12:19.209
And you can also specify which is a big saying 'the
output quarter space' for rendering output quarter space.

00:12:19.210 --> 00:12:25.269
What this means is you can now say well I want to render
the Quartz Composition contents in the proper color space

00:12:25.269 --> 00:12:26.730
for what I'm going to do with that content.

00:12:26.730 --> 00:12:31.430
For instance if you do video processing, you'll
likely want to have Quartz Composer output to 709

00:12:31.429 --> 00:12:37.799
color space or 170M color space,
it's more like NTSC data, those kind of things.

00:12:37.799 --> 00:12:43.809
If you want to do QC rendering on Tiger you used to have to
create the OpenGLP references for GSL and manage all that.

00:12:43.809 --> 00:12:49.299
Now it's like completely abstracted, you just go any
tell screen with size, color space, and that's it.

00:12:49.299 --> 00:12:54.789
And then you can render frames and you can read
the result from the frames, those kind of things.

00:12:54.789 --> 00:12:59.539
If you want to take a snapshot of the last frame that was
rendered we have now very convenient methods, Snapshota,

00:12:59.539 --> 00:13:04.759
you may just create a snapshot, you may just type in
the case of the type, as usual CG image, CI image,

00:13:04.759 --> 00:13:08.230
see the OpenGL buffer, all those kind of types is supported.

00:13:08.230 --> 00:13:15.810
We have two UI elements that we added, the
first one is a QCComposition parameter view,

00:13:15.809 --> 00:13:23.539
what you use it for is if you want to display using a
standard user interface in your application all the controls

00:13:23.539 --> 00:13:28.079
to editing input parameters of the composition that's
currently loaded on a composition renderer.

00:13:28.080 --> 00:13:31.350
So it's super easy to set up, set
composition renderer, and you're done.

00:13:31.350 --> 00:13:36.850
And it will take care of automatically
updating in those directions.

00:13:36.850 --> 00:13:41.690
Also if you look at your QCComposition repository
we have a nice speaker built in which either works

00:13:41.690 --> 00:13:48.200
as a stand alone version which you can see a nice
shot for instance or an unabated view version

00:13:48.200 --> 00:13:51.600
and the way you use it is you set it up
to display some categories of composition

00:13:51.600 --> 00:13:56.310
and eventually you get notifications where
the user changes set at the composition.

00:13:57.490 --> 00:14:02.490
Finally, like I said, I've uncovered everything
so we encourage you to look at the release now

00:14:02.490 --> 00:14:06.000
that you can easily access from
the help menu in the editor.

00:14:06.000 --> 00:14:13.350
So now onto our first integration case study, and the
problem we're going to look at is monitoring a data source

00:14:13.350 --> 00:14:17.940
that doesn't look that very often, for example we know
ever hour, every couple hours or something like that,

00:14:17.940 --> 00:14:24.570
and to take a more concrete example, it's
actually something we solved in our team,

00:14:24.570 --> 00:14:29.230
we build on a regular basis Quartz Composer as
you can imagine continuously several times a day

00:14:29.230 --> 00:14:32.600
when we have check ins and repository system and so forth.

00:14:32.600 --> 00:14:38.220
And we can go to web page, look at the build results,
we also get emails what would happen but we wanted

00:14:38.220 --> 00:14:43.029
to try some nice way to monitor that without having to
physically having to go to web page and check for emails,

00:14:43.029 --> 00:14:49.809
just have it on your desktop like just hanging around,
you put it since we all have two or three screens,

00:14:49.809 --> 00:14:53.099
just put that somewhere and you just monitor it very easily.

00:14:53.100 --> 00:14:55.170
So an entry is even simple.

00:14:55.169 --> 00:14:57.259
So how would we build something like that?

00:14:57.259 --> 00:15:03.110
If you don't have Quartz Composer experience you might
go the usual route which would be 'I'm going to do Cocoa

00:15:03.110 --> 00:15:07.230
and I'm going to create a window and  NS table
view and set up all the columns, do all that stuff,

00:15:07.230 --> 00:15:11.080
do external downloading and what not' and
it's not like a crucial project for your work,

00:15:11.080 --> 00:15:15.970
it's something really that's an add-on for your productivity
so you don't want to spend too many hours on it either

00:15:15.970 --> 00:15:22.389
so we're going to look at approaching that problem with Quartz
Composer and how we can solve that problem really fast

00:15:22.389 --> 00:15:27.059
and at the same time do something that
looks nice and have some fun while doing it.

00:15:27.059 --> 00:15:28.269
So what are the steps?

00:15:28.269 --> 00:15:32.710
Well you'll see the first one you want to get
the data from that source you want to monitor.

00:15:32.710 --> 00:15:35.250
Then you want to build a composition to display that data

00:15:35.250 --> 00:15:38.100
and finally building the application,
so pretty straightforward.

00:15:38.100 --> 00:15:45.909
In the case of getting the data from the source, we could
remember there's a web page in our concrete examples

00:15:45.909 --> 00:15:50.850
so we could have used the new XML down loader patch
and download that web page, do a lot of heavy parsing

00:15:50.850 --> 00:15:55.000
because HTML is basically XML so I try to extract the data.

00:15:55.000 --> 00:15:59.440
That can be quite a bit of work and also
fragile so in our case it was simpler

00:15:59.440 --> 00:16:05.410
to just have the build system outputs a secondary
file just using basic XML which we're going to call

00:16:05.409 --> 00:16:08.279
for the rest of this talk an XML report thing.

00:16:08.279 --> 00:16:12.169
And as you can see really simple,
there's just a name on the list of items.

00:16:12.169 --> 00:16:17.089
Then each side downsize titles, subtitle, and
caption and also an icon which symbolizes status

00:16:17.090 --> 00:16:21.680
where zero would be a success, one would
be a warning and two would be a failure.

00:16:21.679 --> 00:16:27.829
So in practice this is how it looks like for example in
our case you can see the builds, you can see the success

00:16:27.830 --> 00:16:33.540
and the error, etc. So now onto the demo machine please.

00:16:33.539 --> 00:16:44.069
OK, so the first thing is displayig that XML
composition we talked out, that XML data we talked about.

00:16:44.070 --> 00:16:51.680
So, I have here a sample report, exactly like it was on
the slide and then I'm not going to build the composition

00:16:51.679 --> 00:16:55.539
with you because that wasn't, that's
not the purpose of that session.

00:16:55.539 --> 00:17:00.349
It's really to show the integration steps; however
I'm going to explain to you how it was built.

00:17:01.929 --> 00:17:15.309
So as usual you will notice that the first thing
we do is clear the background the usual color,

00:17:15.309 --> 00:17:19.659
with a constant gray color just so that
we clearly see the text in the viewer.

00:17:19.660 --> 00:17:28.820
Now onto the XML handling, so we use the new XML down
loader patch and we specify usually the URL or the bypass

00:17:28.819 --> 00:17:35.039
to the location of that file, it gets downloaded, nicely
parked and available and the output as a structure,

00:17:35.039 --> 00:17:38.210
which exactly mirrors with the XML contents.

00:17:38.210 --> 00:17:43.680
Now we do two things, we use the structure
accessor to extract the name of that report

00:17:43.680 --> 00:17:51.560
and then we display choosing the usual imagery string and
billboard which you can see at the top of the viewer here

00:17:51.559 --> 00:17:57.039
and then the second step is, as you can
guess, to extract the list of add ins

00:17:57.039 --> 00:18:01.369
which we do using another structure key member
and then you should be fine with your list by now,

00:18:01.369 --> 00:18:08.219
we use the iterator to iterate over each
item in the list and that's the subset here,

00:18:08.220 --> 00:18:14.230
so we extract the proper item corresponding
to the current iteration then remember

00:18:14.230 --> 00:18:20.130
that I'd had contents several numbers so the first
one would be the icons thing and we use a multiplexer

00:18:20.130 --> 00:18:28.310
to choose the right image to display, depending
on that value is a bit of work to display it,

00:18:28.309 --> 00:18:36.419
then we go through constructing the title, do some math
just to position it properly next to the icon and so forth.

00:18:36.420 --> 00:18:41.720
We use the regular imagery string and every thing
connected to billboard so that it renders on screen

00:18:41.720 --> 00:18:45.480
and it's accurate in process for subtitle and the caption.

00:18:45.480 --> 00:18:54.930
Now as you can see I can change that fake report to
wonder would be more realistic, looks like we won't.

00:18:54.930 --> 00:18:58.500
Back to slides please.

00:19:05.230 --> 00:19:14.539
Now how to build, remember second step was building
a composition, first step getting the data,

00:19:14.539 --> 00:19:17.420
building the composition and then
building the little application.

00:19:17.420 --> 00:19:18.910
So what does that mean?

00:19:18.910 --> 00:19:22.580
Well eventually we're going to need a transparent
window, we're going to need to put it on the desktop,

00:19:22.579 --> 00:19:26.339
we're going to use a QCView because it's the
fastest way you can put Quartz Composer playback

00:19:26.339 --> 00:19:29.179
into an application, put that in a window.

00:19:29.180 --> 00:19:33.660
So that's solves most of the problem,
but we still have a few things to do.

00:19:33.660 --> 00:19:38.340
First of all, we need the QCView to ascertain transparency
because remember we have that transparent window

00:19:38.339 --> 00:19:42.059
if it's complete to QCView opaque
then complete it gets to a point.

00:19:42.059 --> 00:19:45.899
Then we also need in ensure the QCView
does not render more often than necessary.

00:19:45.900 --> 00:19:50.350
We're only monitoring a data source
that's a few times for an hour at most,

00:19:50.349 --> 00:19:55.299
there is no point in having the QCView running like sixty
frames per second which is kind of difficult behavior.

00:19:55.299 --> 00:20:00.659
You don't want to slow down your system on a thing like
that, you just want to have something that updates kind

00:20:00.660 --> 00:20:05.300
of like all those status monitoring
things in the menu bar once now and then.

00:20:05.299 --> 00:20:12.839
And finally we need to ensure that whenever that
QCView read rolls, once every few minutes or something,

00:20:12.839 --> 00:20:15.849
it downloads synchronously the latest XML reports

00:20:15.849 --> 00:20:19.179
so that we immediately see the latest one
and know something that has been cached.

00:20:19.180 --> 00:20:23.090
So now back to the demonstration please.

00:20:23.089 --> 00:20:34.480
So let me show you first the concept for the
transparency so if we go to interface builder,

00:20:34.480 --> 00:20:47.799
I'm just going to create a dummy window
here and change its class to be a panel.

00:20:47.799 --> 00:20:52.200
Alright, now I can take advantage because our
application is kind of a full screen application,

00:20:52.200 --> 00:20:56.799
it doesn't even have a menu bar or anything, it's just
full screen and it sends the text over to desktop.

00:20:56.799 --> 00:21:04.200
So we're just going to keep the data running and
take advantage of the new head ability of the window

00:21:04.200 --> 00:21:09.769
so we'll get nice transparency, we don't have to do any
fancy settings on the window itself setting opacity,

00:21:09.769 --> 00:21:12.910
all those API calls on the window, it just works.

00:21:12.910 --> 00:21:22.050
Then as you can guess we need to add a QCView on it so we
look for the QCView object, drag and drop, put it properly,

00:21:22.049 --> 00:21:35.819
size it properly, go and make sure it resides with
the window, and now if I run that it's opaque,

00:21:35.819 --> 00:21:39.419
so how do we get the QCView to be transparent?

00:21:39.420 --> 00:21:46.210
Well there is a little hack here
which is artificially supported

00:21:46.210 --> 00:21:50.600
but not many people actually know
it and it also works on Tiger, same thing

00:21:50.599 --> 00:21:57.079
To make the QCView render with transparency
and not draw over everything that's behind it,

00:21:57.079 --> 00:22:01.199
you want to set the color to
have an alpha value that's not one.

00:22:01.200 --> 00:22:06.809
It's that simple, so then it tells, turns on the setting and
generally that says OK I need to render with transparency

00:22:06.809 --> 00:22:09.440
so in our case we're just going to
go all the way and set it to zero,

00:22:09.440 --> 00:22:14.049
now if I run that you can see the QCView is still
rendered, it's still there but it's not visible.

00:22:14.049 --> 00:22:18.889
Now, how do we get the composition to
render properly with transparency as well?

00:22:18.890 --> 00:22:26.250
Because you don't want the composition to be opaque, so
I have a sample composition here I'm going to show you

00:22:26.250 --> 00:22:32.480
and it's pretty easy to do, all
you need is to do two things.

00:22:32.480 --> 00:22:38.730
You need to clear the background of the view of the
composition using clear patch or something equivalent,

00:22:38.730 --> 00:22:45.230
you need to plant it with a color that's completely
clear so especially the AFP, you want the AFP to be zero.

00:22:45.230 --> 00:22:49.400
So basically that means the enter area here
is actually transparent when it's going

00:22:49.400 --> 00:22:52.330
to be composited over some other background.

00:22:52.329 --> 00:22:59.439
And then all the images you draw on top of that, you need
to draw them with the transparency mode or blending mode set

00:22:59.440 --> 00:23:04.809
to over, so that it composites nicely and it
doesn't, you don't see like a black kind of box

00:23:04.809 --> 00:23:08.809
around the image, everything is composited smoothly.

00:23:08.809 --> 00:23:11.599
So remember just clear the background completely.

00:23:11.599 --> 00:23:21.569
Now if I go back to my IB file, I can load that
demo composition here and now I'm going to run

00:23:21.569 --> 00:23:31.369
and as you can see the composition rendered perfectly with
transparency and there is absolutely no artifacts, nothing.

00:23:31.369 --> 00:23:36.629
So that's the basic thing that we're going to
use to build our application, the best concept,

00:23:36.630 --> 00:23:39.660
so I need to show you what it looks like.

00:23:42.730 --> 00:23:48.309
So here we have our little Xcode project, it's
really basic you know, there's little code in there.

00:23:48.309 --> 00:23:54.879
Just putting some glue between the various
elements, you can find here the neat file obviously

00:23:54.880 --> 00:23:57.100
which is very close to the one we've just built.

00:23:57.099 --> 00:24:02.119
The composition file is there and we just open it and
show it to you because there are a couple of changes.

00:24:02.119 --> 00:24:09.379
It's very close to the one we had before, the
first one we built except for a couple of things.

00:24:09.380 --> 00:24:16.350
Instead of displaying the report and then on screen
we outputted on the report name a string output

00:24:16.349 --> 00:24:20.919
of the compositions so that we can retrieve the
report name from the application and be able

00:24:20.920 --> 00:24:24.300
to set the title of the window from that.

00:24:24.299 --> 00:24:29.029
We also changed the clear, you will notice, to
erase with the completely transparent color.

00:24:29.029 --> 00:24:38.519
The XML down loader has a little change as well, if
you show the inspector settings on it you will notice

00:24:38.519 --> 00:24:44.119
that it has a new option in Leopard
that's called synchronous download,

00:24:44.119 --> 00:24:49.009
so by default the XML down loader will actually use a
background stripe so that it doesn't block the execution

00:24:49.009 --> 00:24:53.589
of the composition and the data is
going to be there at some point there.

00:24:53.589 --> 00:24:58.109
So with the synchronize download option you just say you
want to block actually during the execution of the graph

00:24:58.109 --> 00:25:02.099
and you want to download, wait for the download
to be completed and parsed, then output it.

00:25:02.099 --> 00:25:06.279
And that's what we need here because remember
we're not going to render that QCView very often.

00:25:06.279 --> 00:25:12.490
So we want to add the latest data downloaded and processed
and be visible immediately, not have any kind of data.

00:25:12.490 --> 00:25:18.839
And finally there is one thing left which is that
the XML down loader is kind of smart in the sense

00:25:18.839 --> 00:25:27.429
that it's not going to re-download the XML unless the
URL changes or if you play with the update signal,

00:25:27.430 --> 00:25:33.539
for example you make it go from false to true to
regenerate the download to tell it you want to re-download.

00:25:33.539 --> 00:25:40.159
So remember we want to re-download it every time we render
so an approach could be to have that signal alternatively go

00:25:40.160 --> 00:25:46.730
from zero to one and so forth, so that would work perfectly
fine, but I wanted to show you here a different technique

00:25:46.730 --> 00:25:52.259
to do it which might be used in other cases, it's a
little bit more complex but it's more powerful as well.

00:25:52.259 --> 00:26:00.480
So the trick here is I just wanted to change the URL
constantly so that basically we fool the XML downloader

00:26:00.480 --> 00:26:05.569
and we tell it 'OK we download', so how do
you change a URL without really changing it

00:26:05.569 --> 00:26:07.799
so that you don't end up downloading another file.

00:26:07.799 --> 00:26:16.039
Well it's really simple, you actually just add arguments
to it, so you can see here we have our input URL,

00:26:16.039 --> 00:26:20.099
report that XML or it can be a full
URL and then I've written a few lines

00:26:20.099 --> 00:26:26.809
of JavaScript we simply add the question mark
and a dummy argument just to regenerate that URL

00:26:26.809 --> 00:26:30.649
and the dummy argument simply assists in time
so it's guaranteed to change all the time.

00:26:30.650 --> 00:26:36.759
So with that, every time we render the composition
it downloads the latest version of the report.

00:26:36.759 --> 00:26:43.339
Now let's go back to Xcode, regarding the
info.plist there is a little thing you need to add.

00:26:43.339 --> 00:26:48.480
This application doesn't have a user interface
it doesn't have the menu bar or anything.

00:26:48.480 --> 00:26:52.759
So this is called the background on the application;
it still has a user interface; it's not a daemon

00:26:52.759 --> 00:27:00.019
So the way you tell the system that is by setting
the LSUI element to true in your info.plist.

00:27:00.019 --> 00:27:06.009
Now lets at the implementation in itself, so you have your
usual app control error which is going to handle start up

00:27:06.009 --> 00:27:09.150
and the application figuration those kind of things.

00:27:09.150 --> 00:27:14.940
And we also have a custom subclass of the
QCView so more about that in a minute.

00:27:14.940 --> 00:27:19.769
Now you can see the implementation of the app controller,
it's pretty straight forward, when the app finishes,

00:27:19.769 --> 00:27:25.869
about to finish launching, we set the main panel
which is our window, to be on the desktop directly,

00:27:25.869 --> 00:27:31.779
we load the composition and we set the default report
URL and important; we set the frame rate in that case

00:27:31.779 --> 00:27:35.829
to be one per minute, but we could set it lower or higher.

00:27:35.829 --> 00:27:39.579
Finally when the application has really
finished launching we put the window on screen

00:27:39.579 --> 00:27:44.019
and we start the rendering of the QCView.

00:27:44.019 --> 00:27:52.740
And now the subclass of the QCView, we use the subclass
to do two things, we override the render at time argument

00:27:52.740 --> 00:27:57.339
to know when the composition has rendered
so that we can read from it's output,

00:27:57.339 --> 00:28:01.859
remember we have that report name output
we want to use, so we read the value just

00:28:01.859 --> 00:28:03.899
after it has rendered and we set the windows title.

00:28:03.900 --> 00:28:06.900
See, it's quite basic to do.

00:28:06.900 --> 00:28:13.190
And we also do another thing which is we check for a mouse
down event with the option key down, it's not a very nice UI

00:28:13.190 --> 00:28:19.090
but that's actually the purpose of that demonstration just
so that we could edit the URL that you want to monitor.

00:28:19.089 --> 00:28:22.959
So if you press the option key, if you click
in the view and you have the option key

00:28:22.960 --> 00:28:26.190
down just show the text field and we can enter the URL.

00:28:26.190 --> 00:28:33.590
And the rest of the code here just handles editing that
text field in updating the value in the composition.

00:28:33.589 --> 00:28:36.500
So now let's build and run.

00:28:40.109 --> 00:28:42.379
You can see it's all live.

00:28:47.289 --> 00:28:48.480
There we go.

00:28:48.480 --> 00:28:54.269
And it's not visible because it works
correctly and it's some of that stuff.

00:28:54.269 --> 00:29:01.980
So you can see the little application that was built, is
in those techniques, pretty fast to build and I can set

00:29:01.980 --> 00:29:11.819
to a different URL so let me describe my
example here, which was actually here.

00:29:17.450 --> 00:29:21.970
And now we see what it looks like and obviously it
would work exactly the same as that URL

00:29:21.970 --> 00:29:25.059
on the remote server instead of being on the disk here.

00:29:25.059 --> 00:29:28.399
So let's quit that.

00:29:28.400 --> 00:29:34.340
And back to the slides please.

00:29:38.609 --> 00:29:44.389
So now what about if we want to monitor another type
of data source, I mean kind of similar data source

00:29:44.390 --> 00:29:48.700
that you cannot express you cannot
monitor directly using Quartz Composer.

00:29:48.700 --> 00:29:51.720
For instance it doesn't output in XML or as an RSS feed.

00:29:51.720 --> 00:29:56.500
So you will need to write a custom patch to handle
it, that means using the new QCView plug in API

00:29:56.500 --> 00:30:01.690
which is really powerful because you can write any
type of patches with that and it also takes advantage,

00:30:01.690 --> 00:30:04.860
like I mentioned earlier of Objective-C 2.0,
so let's look into that.

00:30:04.859 --> 00:30:10.269
I have a quick crash course on writing
your own QC plug-ins.

00:30:10.269 --> 00:30:13.119
So that's a QC plug in class and the way it works

00:30:13.119 --> 00:30:16.779
to where you use it is you subclass
and you override the required methods.

00:30:16.779 --> 00:30:23.359
You then define the inputs and outputs for your custom
patch and you use the have to implement the execution.

00:30:23.359 --> 00:30:29.889
A few requirements when you subclass QC plug
in, you need to insure that it works correctly

00:30:29.890 --> 00:30:32.509
if you have multiple instances of your QC plug-in.

00:30:32.509 --> 00:30:38.049
For every instance of the patch there is a composition
there will be an instance of your QC plug in subclass,

00:30:38.049 --> 00:30:41.490
so be careful to share global variables
and things like that.

00:30:41.490 --> 00:30:45.519
Also it has to work correctly, if it's not executed
from the main thread, because Quartz Composer can run

00:30:45.519 --> 00:30:49.359
on any thread, and don't assume there is a run loop around.

00:30:49.359 --> 00:30:54.169
If you need that for download or those kinds
of things, we'll look at the technique later.

00:30:54.170 --> 00:31:03.019
So the basics of QC plug in subclassing, well if you need to
do any kind utilization, destruction, just use any dealloc.

00:31:03.019 --> 00:31:08.889
Now, the real thing is going to happen for the execution of the
plug in, and you can see the primary set of methods there

00:31:08.890 --> 00:31:13.900
which are a conveniently working pair, so yes start
execution stop execution call when the engine start

00:31:13.900 --> 00:31:18.740
and stop, you have unable and visible which
I call where you're instance of the QC plug-

00:31:18.740 --> 00:31:21.079
in start and stop being used by the engine.

00:31:21.079 --> 00:31:27.349
So for example if there is no patch that's currently pulling
data from it then visible application's going to be called

00:31:27.349 --> 00:31:29.779
and when it starts again enable execution going to be called.

00:31:29.779 --> 00:31:37.059
So you can do some precise tuning or usage
of your precise controller of your resources.

00:31:37.059 --> 00:31:44.329
And at the core we have the executive time argument
which is called every time execution needs to happen,

00:31:44.329 --> 00:31:46.509
so let's look at this one a bit more in detail.

00:31:46.509 --> 00:31:53.009
So that method is responsible for first ridding
the values from the input ports of the patch,

00:31:53.009 --> 00:31:58.789
then there from all the computation with those values
and also taking into account the time if necessary,

00:31:58.789 --> 00:32:02.200
which you can see is passed as an argument
to that method so that's a composition

00:32:02.200 --> 00:32:05.019
to current time of the rendering of the composition.

00:32:05.019 --> 00:32:11.420
And then finally write the results of this composition
either on the output ports or if this patch does any kind

00:32:11.420 --> 00:32:17.550
of other type of rendering, sending to an editor,
rendering on screen, we'll perform those actions.

00:32:17.549 --> 00:32:20.289
Now let's look at how to create ports.

00:32:20.289 --> 00:32:27.069
So we rely on dynamic properties which were introduced
in Objective-C 2.0, and what it means is if your subclass

00:32:27.069 --> 00:32:33.329
of QC plug in has dynamic properties that start with an
input or output whose names start with input or output

00:32:33.329 --> 00:32:38.269
and however have the proper type, the
automatically we create ports that match those.

00:32:38.269 --> 00:32:44.579
So in that case you can see a dynamic property of
type double and could value one and that's going to

00:32:44.579 --> 00:32:50.259
to map automatically into an input port of type number and
send for input value two and the same way if you wanted

00:32:50.259 --> 00:32:57.690
to create a string port that would be any
string for the type and here are the results.

00:32:57.690 --> 00:33:04.340
To read and write to those ports you use the corresponding
Objective-C 2.0 syntax, self dot input value one

00:33:04.339 --> 00:33:12.449
so after that the result not that the input properties
are read only and the output properties are write only.

00:33:12.450 --> 00:33:17.130
Now you might not necessarily know up front all
the inputs and outputs that your plug in needs,

00:33:17.130 --> 00:33:21.430
you might want to create them dynamically while the
plug in's running, so we call those custom ports

00:33:21.430 --> 00:33:26.970
and it's quite simple to create and destroy them as you can
see using those API's, you just specify the proper type,

00:33:26.970 --> 00:33:31.430
the key that identified the ports, and
some attributes for the UI and that's it.

00:33:31.430 --> 00:33:37.259
Now, because those do not have corresponding
Objective-C 2.0 properties to read and write to them,

00:33:37.259 --> 00:33:42.450
you have to use custom API value for
input key, set value for output key.

00:33:42.450 --> 00:33:49.809
You can see on that table the correspondence between the
type of an Objective-C 2.0 property as well as the port type

00:33:49.809 --> 00:33:55.829
and the Quartz Composer world and also the type
of value you will get if you create those ports

00:33:55.829 --> 00:33:59.970
in a custom way and called value for input key.

00:34:02.349 --> 00:34:08.719
Finally, once you set up all your QC plug-ins the way
you package it is basically Cocoa bundle you just need

00:34:08.719 --> 00:34:12.969
to have a special entry in the plist that tells
it to plug in classes and then you install it

00:34:12.969 --> 00:34:14.909
to the proper location and it just works.

00:34:14.909 --> 00:34:20.569
You can also put that plug in inside your application,
load it directly from there if you don't want

00:34:20.570 --> 00:34:26.600
to install it system wide and you can even leave the
implementation of the plug in mixed with the rest

00:34:26.599 --> 00:34:31.460
of your source code and call register plug
in class directly or register the class.

00:34:31.460 --> 00:34:35.730
We have a couple things here, we have some very
nice Xcode templates that's a starting point

00:34:35.730 --> 00:34:42.829
to create your own QC plug-ins and also be aware that QC
plug-ins will not load in Quartz Composer set environments,

00:34:42.829 --> 00:34:48.449
so that implies what key for instance Quick Time does scan
over environments, having limitations on what we allow

00:34:48.449 --> 00:34:52.739
to run inside Quartz Composer and the
custom plug-ins because you have no control

00:34:52.739 --> 00:34:57.599
over what they can do, for security reasons we exclude them.

00:34:57.599 --> 00:35:03.779
Now QC plug in and practice, remember we wanted to write a
QC plug in to monitor our custom data source for the sake

00:35:03.780 --> 00:35:13.550
of the example here, I picked SQLite 3 Database,
which is not supported by default by Quartz Composer so only

00:35:13.550 --> 00:35:18.180
as a plug in that allows us to specify the
paths in the database, the query string,

00:35:18.179 --> 00:35:22.489
and that returns us a very nice parsed structure.

00:35:22.489 --> 00:35:25.689
So onto demo machine, please.

00:35:27.340 --> 00:35:43.500
So here I have a simple SQLite that I basically
created which has the same key now as the XML report

00:35:43.500 --> 00:35:52.170
so you know its, and we actually show it to you, its going
to be easier, then the ID column, column for the icon,

00:35:52.170 --> 00:35:59.010
the column for a title, subtitle,
and a caption, so really basic here.

00:35:59.010 --> 00:36:01.760
Now let's look at the plug in itself.

00:36:04.429 --> 00:36:11.589
So as you can see, we subclass QC plug in and we
declare our three inputs and output properties,

00:36:11.590 --> 00:36:16.829
you can see input data that's fast, input query string
are both string properties that we're going to map

00:36:16.829 --> 00:36:21.920
to string ports and output results
structure which we set to be an NS array

00:36:21.920 --> 00:36:25.260
in that case it's going to map to a
structure port in Quartz composer.

00:36:25.260 --> 00:36:27.630
Now let's look at the implementation.

00:36:29.739 --> 00:36:36.500
So first of all, we have some UI thing here so that you know
it appears with a nice name in the Quartz composer interface

00:36:36.500 --> 00:36:43.250
for the plug in itself as well as the inputs and outputs,
we also need to tell the system what type of plug

00:36:43.250 --> 00:36:45.280
in we're building, what type of custom patch.

00:36:45.280 --> 00:36:49.769
So in that case it's a processor, we want to
execute whenever there is a change on the inputs,

00:36:49.769 --> 00:36:57.030
create something new on the output and also this plug in
does not depend on the times so we tell the system so.

00:36:57.030 --> 00:37:01.290
Now let's go to the core of the
implementation which is the execute method.

00:37:01.289 --> 00:37:07.900
So the first thing we do is we read from the database patch
that was given then and we make sure it's valid for now

00:37:07.900 --> 00:37:12.039
and if it's not then we just set the
output to nil and continue execution.

00:37:12.039 --> 00:37:18.969
We don't want to abort the complete execution of the
composition we just, it's kind of an acceptable user error

00:37:18.969 --> 00:37:22.949
in that case, we just return yes and
you set your output to proper values.

00:37:22.949 --> 00:37:29.489
Then to actually read and send a query to the
database, I want to keep that simple so instead

00:37:29.489 --> 00:37:37.739
of using the SQLite API's I just use directly
the SQLite 3 comma line 2 and just collate

00:37:37.739 --> 00:37:40.049
with the proper arguments and force the outputs.

00:37:40.050 --> 00:37:44.410
So what you can see here, and I'm not going to go into
details, you can look at the sample card yourself here,

00:37:44.409 --> 00:37:49.529
it's essentially NFS task stuff, and
so we run the NFS task synchronously

00:37:49.530 --> 00:37:53.240
and then we'll read the output
that comes from it and we parse it.

00:37:53.239 --> 00:37:58.719
And here's a function that parses its output it's
essentially looking for return characters those kind

00:37:58.719 --> 00:38:02.259
of things and building a nice array of results.

00:38:02.260 --> 00:38:09.750
Here we have the NFS task handling which would copy
best from another sample code and that's pretty much it,

00:38:09.750 --> 00:38:13.409
there you go so and let's build and run it.

00:38:13.409 --> 00:38:20.589
And you will notice that our projects, if you create
them from a template, have build and copy target

00:38:20.590 --> 00:38:24.340
which conveniently built and installed
the program at the proper location.

00:38:24.340 --> 00:38:32.320
So that's done, now let's look at that composition
file, it's the same as before just slightly modified

00:38:32.320 --> 00:38:38.480
so that it chooses our new plug in we just wrote,

00:38:38.480 --> 00:38:43.119
so as you can see here replaced the
XML one by the SQLte query plug in.

00:38:43.119 --> 00:38:49.059
The query string has been published as an
input port which we can show here and the pass

00:38:49.059 --> 00:38:55.670
to that database is query to send and it reports
exactly back in the terminal if all the reports are nice,

00:38:55.670 --> 00:39:00.539
which reports to result, nice reports to use as
a structure and then the rest is exactly the same

00:39:00.539 --> 00:39:03.460
because remember the structure had the same formatting.

00:39:03.460 --> 00:39:13.780
So this concludes my demo, I'd like
to look back to the slides please.

00:39:17.230 --> 00:39:25.090
Now a couple of things I didn't have a chance to talk
about, if you need to access resources relatively

00:39:25.090 --> 00:39:31.890
to where the composition file is, call composition URL on
the plug in contact that is passed to every execution method

00:39:31.889 --> 00:39:36.900
of the plug in, however this is not necessarily
going to return a value it may return nil,

00:39:36.900 --> 00:39:39.180
so you need to be prepared to handle that.

00:39:39.179 --> 00:39:45.399
And finally if you need to do any kind of logging
instead of using print F or NS log those kind of things,

00:39:45.400 --> 00:39:50.320
try to use log message on the context
so then we can redirect it properly.

00:39:51.650 --> 00:39:56.480
And finally when it comes to performing background
processing you're going to have to deal with that

00:39:56.480 --> 00:40:00.559
if either you want to do very legthy operations
and you care but not locking the execution

00:40:00.559 --> 00:40:02.840
of Quartz composer or if you need a run loop.

00:40:02.840 --> 00:40:06.010
So what's you're going to have to do
is create a background workers thread.

00:40:06.010 --> 00:40:10.780
And it's not that complex, you can use the nice
NS thread API and what you want to start the thread

00:40:10.780 --> 00:40:14.269
from the start execution, terminate
the thread and stop execution

00:40:14.269 --> 00:40:18.050
and obviously communicate with it during the execute method.

00:40:18.050 --> 00:40:23.250
So you have to be aware of synchronization
issues, you gotta use the locks and mutexes

00:40:23.250 --> 00:40:29.289
to process your common data obviously and it's better if
you actually block and start execution and stop execution

00:40:29.289 --> 00:40:33.860
until the thread is actually finished
starting or finished terminating.

00:40:35.150 --> 00:40:40.920
When it comes to testing your QC plug in , so Leopard
is really for when now you have 32-bit, 64-bit,
d

00:40:40.920 --> 00:40:46.289
garbage collected, not garbage collected, so instead
of writing your own test application to test your plug

00:40:46.289 --> 00:40:50.929
in in all those environments, we have a convenient
feature inside the editor it's already built in,

00:40:50.929 --> 00:40:57.909
you can go to file new and select test in run time and
then the composition that's open will launch under 32-bit

00:40:57.909 --> 00:41:02.480
or 64-bit if your machine supports 64-bit and you
can see that your plug in behaves correctly or not.

00:41:02.480 --> 00:41:06.159
And if you press the option key down when you select
it will indicate to you that it is functioning

00:41:06.159 --> 00:41:10.469
with garbage collection on as well,
so you can test really the 4 cases.

00:41:10.469 --> 00:41:15.789
Now I'd like to invite Kevin on stage to take
us through the second insert case studies.

00:41:15.789 --> 00:41:17.509
Thank you.

00:41:17.510 --> 00:41:25.510
(applause)

00:41:25.510 --> 00:41:30.400
>>Alright, hello everybody so you see this
pretty clear from visualizing in Quartz composer

00:41:30.400 --> 00:41:33.000
in your application and external source of data.

00:41:33.000 --> 00:41:35.719
Now we're going to concentrate on the
novel source of data which is movies.

00:41:35.719 --> 00:41:39.929
So we're going to see a pretty unique way,
pretty cool way of visualizing the movies.

00:41:39.929 --> 00:41:45.519
So here's the problem we try to solve, so you just had this
awesome vacation and you've been at the beach in Hawaii

00:41:45.519 --> 00:41:51.380
and something, and you have all this movie you took with
your digital camera, of fish, of children, everything.

00:41:51.380 --> 00:42:00.380
And so you put these movies on your computer and you
just have this perfect shot, somewhere over there

00:42:00.380 --> 00:42:05.019
and you just can't find it so you have all
this viewfinder, QuickTime, QuickLook,

00:42:05.019 --> 00:42:09.280
and you're looking at this precise shot you exactly
know what looking for what it's looking like,

00:42:09.280 --> 00:42:13.420
but you keep on scrolling and scroll too fast
and so you miss it, and so that's very annoying.

00:42:13.420 --> 00:42:20.800
So there's really no application out there that allows you
to quickly get another view of all the shots in the movie

00:42:20.800 --> 00:42:23.700
so that you can quickly get to the one you're looking for.

00:42:23.699 --> 00:42:27.969
And so we say well what about trying to do this in QC?

00:42:27.969 --> 00:42:33.239
And that's where we go to so because pretty much
you know a movie is nothing more than a 3-D object.

00:42:33.239 --> 00:42:36.299
You have the frames and then you have
the frames that are 2-D, 2 dimensional,

00:42:36.300 --> 00:42:38.539
and then you have time which is a third dimension.

00:42:38.539 --> 00:42:43.769
So what about showing these frames over time and so you
know, we have this kind of view that you see that you see

00:42:43.769 --> 00:42:49.539
on the slide where frames are exported over timing in
the kind of view you see precisely when the shot starts,

00:42:49.539 --> 00:42:54.340
when the shot ends, you pretty much get pretty quickly
an idea of it's content and you can scroll through it

00:42:54.340 --> 00:43:00.630
and select entry output points and
ideally export this shot to disk.

00:43:00.630 --> 00:43:05.099
So yes, that's what we did, so how do we get there?

00:43:05.099 --> 00:43:12.210
Well first of all you need a composition, a Quartz
composition to display the frames but you know

00:43:12.210 --> 00:43:16.400
that you loading these frames might
take a while, especially the movies.

00:43:16.400 --> 00:43:21.190
So you don't want to have your even thread that's
going to be blocked where the frames are being loaded.

00:43:21.190 --> 00:43:25.119
And each uses the building patch in Quartz
composer which is a movie loader patch.

00:43:25.119 --> 00:43:28.859
Well it's going to be the main thread and it's going to
block your UI so it's not going to respond anymore.

00:43:28.860 --> 00:43:32.130
So what you want to do is to delegate the
loading of frames to a background thread.

00:43:32.130 --> 00:43:35.869
So UI is still going to be responsive
while this is happening.

00:43:35.869 --> 00:43:41.119
And so to do this well, we're going to a QC plug in
that's going to do this background frame processing

00:43:41.119 --> 00:43:45.609
and that's going to be the main and
the hardest part of the project

00:43:45.610 --> 00:43:52.380
and then once this composition is ready we're going to put
it in the QCView and put this QCView and edit this QCView

00:43:52.380 --> 00:43:57.360
in the application, and use Cocoa bindings to compilate
so it's pretty easy, just so that the UI's actually come

00:43:57.360 --> 00:43:59.970
through in the view where we will finish the application.

00:43:59.969 --> 00:44:05.829
And that said, well we want to save the entry and output
points when we find the shot and so we need to do,

00:44:05.829 --> 00:44:11.440
we have lots of techniques for doing this, so what
I chose to do is just the QC plug in that use QT tip

00:44:11.440 --> 00:44:15.559
to export a Quick Time movie, reference
movie to disk and it's fine rime with QT tip.

00:44:15.559 --> 00:44:18.099
So this is the easy part, I'm not
going to go into details over that.

00:44:18.099 --> 00:44:25.009
I'm going to concentrate on the plug in, so the
plug in what you will like ideally is so this plug

00:44:25.010 --> 00:44:32.680
in that takes an input back which is the best of the movie
and disk and that returns an array of frames and each index

00:44:32.679 --> 00:44:39.319
in this array is going to be either null, either the
frame in the frame is inverted by the background thread.

00:44:39.320 --> 00:44:42.550
And so then you return this array to QC and
is going to geerate with the natural rate

00:44:42.550 --> 00:44:45.140
or all that kind of stuff, so known techniques.

00:44:45.139 --> 00:44:51.000
So these array of frames is not going to be able to
hold all the frames because the view run is limited,

00:44:51.000 --> 00:44:56.780
we have 256 actual in the best case, so even
in low resolution this is not going to work,

00:44:56.780 --> 00:45:02.140
so first we have to load the frame that carries resolution
and then so that is going to load the old array is going

00:45:02.139 --> 00:45:04.809
to fit in view run we need to skip some frames.

00:45:04.809 --> 00:45:09.849
So that's the thing we have to do on the array.

00:45:09.849 --> 00:45:14.480
So how is the plug in going to work internally?

00:45:14.480 --> 00:45:21.860
Well so we'll have two arrays, an array of frame requests on
one side and an array of available frames on the other side,

00:45:21.860 --> 00:45:27.610
so the array of frames we request is going to be
filled by older requests for the frame that we want

00:45:27.610 --> 00:45:30.269
and the available frames is going to
be the frame that I've been loading.

00:45:30.269 --> 00:45:34.900
And so as prior mentioned the main part
of the QC plug in is the execute method.

00:45:34.900 --> 00:45:39.240
So the execute method is running in the main
thread is going to fill up the array of requests,

00:45:39.239 --> 00:45:45.729
the frames that I want at each time stamp and is going to
check the array of available frames is OK, is going to copy it.

00:45:45.730 --> 00:45:51.809
This one's available; return it to
QC so the QC can do the drawing.

00:45:51.809 --> 00:45:56.940
And so in palette you have the background thread that
will work presently, so he's going to take the request

00:45:56.940 --> 00:46:02.809
so that's what I actually load, he's going to process then
using some QuickTime code and then he's going to put this frame

00:46:02.809 --> 00:46:07.279
and fill them up in the array of available frames.

00:46:07.280 --> 00:46:17.630
And of course because this two array are going to be accessed
by two threads in palette so we need to log them carefully.

00:46:17.630 --> 00:46:23.829
So let me show you a demo and first of
all how all of this code looks like.

00:46:23.829 --> 00:46:27.980
So you have Xcode, let me open the directory of plug-ins.

00:46:27.980 --> 00:46:35.139
So all the sample codes, source code is available
so you're welcome to go and check it out yourself.

00:46:35.139 --> 00:46:43.339
So let me just go directly to the execute method, it's here
so that's where everything's happening so for those of you

00:46:43.340 --> 00:46:49.400
who want to go into details, there is some directories
above the QuickTime code, the threading, the internal stuff,

00:46:49.400 --> 00:46:52.800
we don't want to really go into details about it,
I'm just going to show you the main architecture

00:46:52.800 --> 00:46:54.850
of the plug in, the QC plug in part of it.

00:46:54.849 --> 00:47:00.110
So here's the code that happens whenever the input path
change so what we do here that we set up the thread,

00:47:00.110 --> 00:47:05.190
we set up the movie so we call this little
function and we do some computation with interval.

00:47:05.190 --> 00:47:09.159
And so here you see this function set of thread
which is where the thread is going to be set up,

00:47:09.159 --> 00:47:11.559
I'm just going to come back there in one second.

00:47:11.559 --> 00:47:18.659
And this is the main core, which is we call a function,
and so this function is simply building the array request

00:47:18.659 --> 00:47:23.039
and getting the array of available threads
and returning it so this function returns.

00:47:23.039 --> 00:47:27.949
And then we have other parameters that are going to
be for the later improvement of the plug in,

00:47:27.949 --> 00:47:35.779
and so let me just go quickly in this set up threading that
out so we go there, we create a new thread so that's here,

00:47:35.780 --> 00:47:41.650
the thread is detached over here, using a selector
processing thread, so let me go to selector,

00:47:41.650 --> 00:47:46.660
so that's a pretty interesting technique
so I just want to mention really quickly.

00:47:46.659 --> 00:47:51.170
We have a run loop which is the run up under the
thread and what we're going to do is that we are going

00:47:51.170 --> 00:48:00.809
to attach a run loop source that is linked to a call
back in here and that list call back is going to process

00:48:00.809 --> 00:48:03.190
to do the frame processing to using QuickTime

00:48:03.190 --> 00:48:07.269
and so that's going to be a call back method
whether the frame put them in there direct.

00:48:07.269 --> 00:48:12.559
So that technique is pretty cool because then you attach
this call back to the run loop you can pretty easily work

00:48:12.559 --> 00:48:20.029
up your thread and put it to sleep by
stopping the run loop and waking it up.

00:48:20.030 --> 00:48:28.240
So let me show how it looks like with a simple composition.

00:48:28.239 --> 00:48:37.369
And you see that it's showing, and your UI looks pretty
responsive, it's smooth nothing, you know, it's pretty nice.

00:48:37.369 --> 00:48:42.799
And so here we go so load this movie in and it's pretty
cool because here you can clearly see the different frames,

00:48:42.800 --> 00:48:49.039
the different shots over there, so let me look
at the composition to see how we did this.

00:48:49.039 --> 00:48:53.039
I'm going to zoom in just a little bit, we
have to try both so we can rotate it around,

00:48:53.039 --> 00:48:58.190
then we have a free transformation that's
just three camera position is based

00:48:58.190 --> 00:49:00.579
with this nice perspective at this time.

00:49:00.579 --> 00:49:08.360
And then so let's look again other parameters for later
but here we have the path and the output frames array,

00:49:08.360 --> 00:49:16.519
so all the frames are here, and then images, we use
an iterator to draw these frames over the axis.

00:49:16.519 --> 00:49:25.690
So just some, here we go the images, then we do some
math so aspect ratio of the stripes and then the position

00:49:25.690 --> 00:49:30.130
on this axis simple math and then
we draw it using this part.

00:49:30.130 --> 00:49:35.190
So it's not hard and it' pretty cool, it's pretty nice.

00:49:35.190 --> 00:49:39.659
Alright, so let me go back to slides.

00:49:41.090 --> 00:49:49.269
So that's our first example, now I'm going to show you
how you can leverage QC to enhance the visual impact

00:49:49.269 --> 00:49:58.969
of your composition and its interactivity, so first of
all a pretty cool technique, how to navigate smoothly

00:49:58.969 --> 00:50:01.699
in the QCView so you have different camera position.

00:50:01.699 --> 00:50:07.049
Let's say you have another view camera position and you have
a close up camera position and you want to smoothly look

00:50:07.050 --> 00:50:11.800
from one camera position to the other one, so it's
pretty easy to put in QC, I'm going to show you how.

00:50:11.800 --> 00:50:17.269
Then let's say you want to browse your
movie and you want to define a focus point

00:50:17.269 --> 00:50:19.989
which would be the focus frame of your movie.

00:50:19.989 --> 00:50:25.059
So around this focus frame let's say that you want to
get close to it, you would like to have full resolution

00:50:25.059 --> 00:50:29.750
on the frame itself so lots of more details
and for resolution temporal resolution,

00:50:29.750 --> 00:50:31.670
so you would like to have more frames around.

00:50:31.670 --> 00:50:36.490
So to do this we need to improve the plug in in
exactly the same manner, so we're going to add the thread

00:50:36.489 --> 00:50:39.250
to the four resolutions, they're
going to be exactly the same thing.

00:50:39.250 --> 00:50:44.260
And then because we want to make this focus frame
purely stand out so what I'm going to show you is how

00:50:44.260 --> 00:50:49.410
to do a pretty simple and pretty
cool cover flow like effect.

00:50:49.409 --> 00:50:55.369
And then the reflection is not only for the dock it's also
for QC so we're going to add a little reflection on the frames

00:50:55.369 --> 00:50:57.779
so that everything is going to look pretty good.

00:50:57.780 --> 00:51:04.130
Alright, so I need to go back to the
demo machine to show you this new composition

00:51:04.130 --> 00:51:13.740
so here we go, we have flowers and a pretty good
thing of flowers but that some of you can use,

00:51:13.739 --> 00:51:19.879
so here you have the 3D transformation, you see this
rotation and transition, the position of the camera

00:51:19.880 --> 00:51:25.539
in space is actually coming out of - let me enlarge
it a little bit - a JavaScript patch that is

00:51:25.539 --> 00:51:31.380
out spurning these positions and then this position
rotation and then going through a smooth patch,

00:51:31.380 --> 00:51:40.300
so that's the technique and the JavaScript patch, what
it's going to do, that it's going to store the camera rotation

00:51:40.300 --> 00:51:47.370
and position and return regarding an input index,
the associated position and rotation in the area.

00:51:47.369 --> 00:51:56.589
And because this position or rotation is going to go through
smooth patch we'll have this very nice transition smooth

00:51:56.590 --> 00:52:02.200
and go from there, so we have a very cool look on the
first frame and where this side view is pretty nice.

00:52:02.199 --> 00:52:07.769
So you know you can have different other view on your movie
so then I said let's define a focus frame, so it's here,

00:52:07.769 --> 00:52:14.719
right here you see this little stuff moving around, and
you see the background loading a frame below the gray area.

00:52:14.719 --> 00:52:19.879
So and here you see around this area, every frame
is loaded so that's a thread that's doing that,

00:52:19.880 --> 00:52:23.990
we give it an input index, an input
number location in the movie

00:52:23.989 --> 00:52:28.609
and around this location is going to load
every frame and also at high resolution.

00:52:28.610 --> 00:52:32.640
So if you see from this view, this guy coming,

00:52:32.639 --> 00:52:38.150
so you view up you see you have four resolutions,
so here's your resolution on that point.

00:52:38.150 --> 00:52:42.639
So that's nice but in this stack
there we don't really see up,

00:52:42.639 --> 00:52:46.159
we don't really see anything, so
it's not very useful so much.

00:52:46.159 --> 00:52:56.440
So let me go and add, so here is being inside the
submission then the actuator and this is the function

00:52:56.440 --> 00:53:01.950
that simply computes the position on the
z axis of the frames and nicely in there.

00:53:01.949 --> 00:53:06.339
So it's one give one, two gives
two, and so it's just like that.

00:53:06.340 --> 00:53:09.600
So I'm going to change this by a
little Mac function that you can look

00:53:09.599 --> 00:53:14.610
if the composition is available, just simple, not too hard.

00:53:14.610 --> 00:53:22.220
So and is going to simply explode around the position
so the focus point the frames so let me connect this,

00:53:22.219 --> 00:53:29.669
we're going to turn this function up and you see
here you have, this looks pretty cool you know,

00:53:29.670 --> 00:53:37.110
you can already look at your movies and you already
see this frame over here which is for resolution.

00:53:37.110 --> 00:53:48.750
And every thing's pretty smooth still, we can go here
and see, so another thing now I'm going to add a little,

00:53:48.750 --> 00:53:55.250
here I have this JavaScript patch that kind
of makes the focus point move at the speed

00:53:55.250 --> 00:53:58.550
that would be the play back movie,
the play back speed of the movie.

00:53:58.550 --> 00:54:05.130
And I'm going to insert that in my stream here,
and that's going to be linked to the play button

00:54:05.130 --> 00:54:10.300
and so that's going to give this kind
of very nice plain effect.

00:54:10.300 --> 00:54:16.510
So you can go and move around, but that's
kind of nice and what's pretty cool is

00:54:16.510 --> 00:54:21.240
that you know we recreated the movie in its initial
resolution because the frame, the images in frame,

00:54:21.239 --> 00:54:24.449
are static, is the frames of the movie that
are moving in the free environment

00:54:24.449 --> 00:54:29.369
from this time we create the image of motion
motion, it's not images changing.

00:54:29.369 --> 00:54:35.679
So here it is, last thing add some
reflection so, here we go,

00:54:35.679 --> 00:54:39.629
so that's a reflection which is pretty much
flipping the sprite and adding an effect

00:54:39.630 --> 00:54:41.720
so I we have the reflection effect and up.

00:54:41.719 --> 00:54:50.569
So I'm going to turn that on, the ??? key here, put it on
true, so you see now pretty quickly we get you something

00:54:50.570 --> 00:54:57.680
which is pretty nice and assumes you are active.

00:54:57.679 --> 00:55:05.449
So now let me show you the final application.

00:55:13.630 --> 00:55:22.369
So the code that's pretty much all
Cocoa bindings and stuff like that.

00:55:22.369 --> 00:55:27.829
We're waiting for Xcode, compiling, it's real time demo.

00:55:29.139 --> 00:55:36.750
And so we have all the old nice UI's so I did
a bunch of stuff not so much, but here we go,

00:55:36.750 --> 00:55:42.929
so we have a little library of this movie and we're
trying to locate our shots within that library of movies

00:55:42.929 --> 00:55:45.980
and you see I linked the focus
point to the mouse position here

00:55:45.980 --> 00:55:50.880
so you can scroll here of little
indexes and stuff like that.

00:55:50.880 --> 00:56:00.250
And so camera position here so I can go to camera two
and we zoom in, we have frame by frame, edit here,

00:56:00.250 --> 00:56:05.059
adding to the keys so we can go to look for something.

00:56:05.059 --> 00:56:11.519
This third camera position this I can of like
it does this slow thingy which is a trip thing,

00:56:11.519 --> 00:56:14.349
it's just new function so it's kind of cool.

00:56:14.349 --> 00:56:16.809
(applause)

00:56:16.809 --> 00:56:22.769
And, thanks, so you know it's just another function
on the rotation, we have position and that's

00:56:22.769 --> 00:56:24.480
for rotation, pretty much the same thing.

00:56:24.480 --> 00:56:31.360
So it's nice, it does films to the effect and you still
have the reflection going under it and so we can go

00:56:31.360 --> 00:56:35.340
and look at our new close up and see that
here we have, so it's pretty smooth still,

00:56:35.340 --> 00:56:45.809
and we have the full resolution HD and we have pretty
cool caching system in QC so that you know all the texture

00:56:45.809 --> 00:56:49.559
and everything we manage that for
you in very optimal manner.

00:56:49.559 --> 00:56:59.759
So let me start playing and let's say that I want to
find my movies so I go there, on the fishes because I was

00:56:59.760 --> 00:57:16.270
at the beach so I want to find my shots so let me zoom in
and so you can play and set it up, that's it so I found it.

00:57:16.269 --> 00:57:28.039
Now let me click on start position, so we have an input
point that's over here and let me go to the end position,

00:57:28.039 --> 00:57:40.329
here we go, let's go back, and so we can go in the
overview to see if it's exactly what I want, so yeah, up.

00:57:42.230 --> 00:57:55.409
Yeah, that's it, I recognize the color and the shade so
that's me, so that view we just exported to the desktop

00:57:55.409 --> 00:58:03.429
so it's my....and we have my fish movie and it will go.

00:58:03.429 --> 00:58:06.980
So I set in my shot pretty quick so
just as a reference quick to get movie.

00:58:06.980 --> 00:58:13.510
So I use my application to find my shot
from my awesome vacation at the beach.

00:58:13.510 --> 00:58:21.260
(applause)

00:58:21.260 --> 00:58:26.410
But you know it's pretty easy to experiment and go
even further, I couldn't stop there so I did this slow.

00:58:26.409 --> 00:58:28.159
(laughter)

00:58:28.159 --> 00:58:32.649
So you know you have CI and QC core in there
so you can apply realtime perimeter effects

00:58:32.650 --> 00:58:38.930
so you can adjust the brightness, select the region,
the contrast and everything and let's put a little black

00:58:38.929 --> 00:58:46.119
and white effect, you can do all the images
you want, just an example that's pretty cool.

00:58:46.119 --> 00:58:48.109
So it's pretty back to normal.

00:58:48.110 --> 00:59:00.309
So I'm going to erase that stuff, but I could not just stop
there and you know we have lots of course on those machines

00:59:00.309 --> 00:59:04.130
and so let's say let's have another thread to
show image permission because we have a new way

00:59:04.130 --> 00:59:07.480
of seeing the movies, you have
all this space which is there.

00:59:07.480 --> 00:59:16.300
So let me go back on the flower movie because it has
lots of color and so what about using all this 3 D,

00:59:16.300 --> 00:59:20.760
are we yet to show image histogram,
so information on the images.

00:59:20.760 --> 00:59:25.880
(laughter) So we have this other and it's
pretty nice because you see this little guide,

00:59:25.880 --> 00:59:31.110
you know the histogram's going from one side to the other
as you change the frames so you know you can go check

00:59:31.110 --> 00:59:40.700
out the other camera position if you go close,
you have this stick around, updating in old time.

00:59:40.699 --> 00:59:42.099
So...(applause)

00:59:51.380 --> 00:59:59.530
and there is not much in there of OpenGL,
so let me go back to the slides please.

00:59:59.530 --> 01:00:06.930
Alright, so just imagine the possibilities because I
had to stop because I had to work on my slides (laughter)

01:00:06.929 --> 01:00:14.369
and you know the visual stuff is coming in a second, I
also had to work on that, so imagine the possibilities.

01:00:14.369 --> 01:00:20.519
Let's say that you can, may be the next generation editing,
3D's hot, you can imagine selecting shots

01:00:20.519 --> 01:00:24.989
and all this stuff translating around so you can clearly
show where your shots, where your edit point starts

01:00:24.989 --> 01:00:31.709
and ends, you can export that to QuickTime using
a Quartz composer plug in to final cut format

01:00:31.710 --> 01:00:34.710
so that you can continue editing in Final Cut.

01:00:34.710 --> 01:00:38.800
You kind of say imagine showing image difference and
to show where the shot starts, where the shot ends,

01:00:38.800 --> 01:00:45.730
where you have difference plotting this curve in space
and that's of course thresholding to automatic syncer.

01:00:45.730 --> 01:00:51.320
For the science people you can also, and I thought
it would be pretty nice to do it, you can do a motion

01:00:51.320 --> 01:00:55.970
or object tracking, you could track an
object and you can visual the curve in space

01:00:55.969 --> 01:00:58.129
and see if it's continuous or not continuous.

01:00:58.130 --> 01:01:02.640
So you know you have lots of stuff and QC with
all these new patches are available, the new API,

01:01:02.639 --> 01:01:06.699
you're hardly going to be limited and you're going
to be very efficient so you go very fast doing this.

01:01:06.699 --> 01:01:11.469
And again you have the source code you can check
it out, it's really not a couple of months,

01:01:11.469 --> 01:01:21.869
it's just a couple of weeks, so now let me talk
to you about the Quartz composer visualizer.

01:01:23.269 --> 01:01:32.199
So the Quartz composer visualizer is this wall
of displays, it is the application

01:01:32.199 --> 01:01:36.269
that drives the Quartz composer wall display
that is in the graphics and media lab.

01:01:36.269 --> 01:01:46.170
So this wall is made of nine MacPros with
ATI X1900 XT cards connected to 18 to 30" displays,

01:01:46.170 --> 01:01:52.159
so each MacPro directs two monitors and we need this
card and this power because we have two 30 inch monitors

01:01:52.159 --> 01:01:57.399
so we need the MacPro, but if you have plasma
you can work with all kind of computers.

01:01:57.400 --> 01:02:05.599
And so the Quartz Composer visualizer is the application
that makes this possible so spanning across the composition

01:02:05.599 --> 01:02:10.599
or over multiple displays over network
and that's a new developer tool

01:02:10.599 --> 01:02:13.079
which is in developer application graphics tool.

01:02:13.079 --> 01:02:18.909
And it's free so anything better than
free because the source code is provided.

01:02:18.909 --> 01:02:26.309
So you can hack it yourself, so how does it look?

01:02:26.309 --> 01:02:32.389
Well that's a local case so it's pretty as simple
as you can get, you can span your composition

01:02:32.389 --> 01:02:35.460
over multiple displays connected locally to
your machine, you just drag your composition,

01:02:35.460 --> 01:02:39.090
click on start, and boom it's going to work as expected.

01:02:39.090 --> 01:02:42.519
Then local case so that's the whole
screen chart that we have for the wall,

01:02:42.519 --> 01:02:47.050
so little more option for network synchronization, but
that's pretty much it, you drag composition, you can start

01:02:47.050 --> 01:02:50.730
and it's going to span and we have  a little UI to
position the screen just basically correspond their

01:02:50.730 --> 01:02:52.369
physical location.

01:02:52.369 --> 01:02:57.339
So now I'm going to talk to you how to handle the
root of this application design, so first of all,

01:02:57.340 --> 01:03:02.130
locally how does it work to a standard composition
over multiple displays; and then how to span in just

01:03:02.130 --> 01:03:05.180
like the work configuration over the network?

01:03:05.179 --> 01:03:11.419
So locally you need a Mac and displays, let's
say two, and so first you're going to set

01:03:11.420 --> 01:03:17.389
up one Quartz composition per display then you
set up a full screen of contacts on the display

01:03:17.389 --> 01:03:24.199
and then you create a QCRenderer out of this
composition and full OPenGL context object.

01:03:24.199 --> 01:03:29.500
Then you need to tell this QCRenderer to render
so you can use different techniques timer,

01:03:29.500 --> 01:03:34.170
timer in a separate thread per screen, but the technique
we recommend you use is a Core Video display link

01:03:34.170 --> 01:03:37.849
which is just like the timer in a
separate thread per display but synchronized

01:03:37.849 --> 01:03:40.759
with a different refresh rate so
it's better for performances.

01:03:40.760 --> 01:03:47.500
Then you need to tell 'what is the subregion
that needs to be rendered on these displays',

01:03:47.500 --> 01:03:51.199
and for this you just transform
the OpenGL projection matrix,

01:03:51.199 --> 01:03:55.250
just before coding your render at
time method on your QCRenderer.

01:03:55.250 --> 01:03:59.380
So we just do a frame transform so that
just transect and secure as expected,

01:03:59.380 --> 01:04:02.130
and then you invert that after you use that method.

01:04:02.130 --> 01:04:06.660
So all the drawing is going to be perfect.

01:04:06.659 --> 01:04:14.469
So this stuff is going to work in most cases, but
lets say you have a game where you have 2 states

01:04:14.469 --> 01:04:19.689
and because you have one big state,
which is the lives of the player

01:04:19.690 --> 01:04:23.730
and because you have one composition per screen let's say
that if you die on the left screen that state is going

01:04:23.730 --> 01:04:26.000
to reflect that on the left screen
but you might still be alive

01:04:26.000 --> 01:04:28.670
on the right screen, because you have state kind of stuff.

01:04:28.670 --> 01:04:33.389
So, having a composition per screen in that
kind of particular case, it's not going to work,

01:04:33.389 --> 01:04:40.529
so a solution we took is to spin this composition between
a processing composition, and a rendering composition.

01:04:40.530 --> 01:04:46.930
The processing composition is going to do the composition on
only the game for instance, and keep all the lives

01:04:46.929 --> 01:04:49.619
and the rendering composition is
going to do the drawing only.

01:04:49.619 --> 01:04:52.359
So the composition only on one
side and drawing on the other side,

01:04:52.360 --> 01:04:55.500
and then we're going to have one processing
composition per screen

01:04:55.500 --> 01:05:02.309
sorry, one processing composition per computer
and one drawing renderer per display.

01:05:02.309 --> 01:05:07.750
And this was going to happen as the processing composition
is going to forward its output source to the input source

01:05:07.750 --> 01:05:10.400
of each rendering composition on the displays.

01:05:10.400 --> 01:05:17.740
So then that's going to solve that kind of problem, so now
it met ok, so we have a host computer and we have a bunch

01:05:17.739 --> 01:05:23.489
of clients so the host needs to know where the clients are
so they're going to use BOM so that the host can find them

01:05:23.489 --> 01:05:27.909
and then once it's going to be done we're going to create
a TCP connection between the host and initial client.

01:05:27.909 --> 01:05:32.879
And the TCP connection is going to be used to
send a screen configuration composition files,

01:05:32.880 --> 01:05:35.619
play stop messages from the host to the clients,

01:05:35.619 --> 01:05:40.289
application parameters for instance screen
results and so on.

01:05:40.289 --> 01:05:45.309
So something I would like to say here is that this Quartz
composer visualizer application the technology behind it,

01:05:45.309 --> 01:05:53.599
Quartz composer, is not like the X11 of thing, so in X11
you send an instruction over the network, here it's not this,

01:05:53.599 --> 01:05:59.420
we have the Quartz composition, a recipe for rendering
graphics so we transfer this composition once and for all

01:05:59.420 --> 01:06:04.190
to the clients and then they're are going to be
played locally and then only time is going to be synchronized.

01:06:04.190 --> 01:06:11.730
So what it means is that in that case we're going to have
full performance everywhere, so it's important to say that.

01:06:11.730 --> 01:06:17.050
In the case of processing, rendering, differentiation,
well the processing composition is going to run on the host

01:06:17.050 --> 01:06:21.980
and forward the composition data to every client.

01:06:21.980 --> 01:06:27.659
And yes, so that's pretty much it so you can
go and check out the source code yourself,

01:06:27.659 --> 01:06:30.769
if you want some more details about that.

01:06:30.769 --> 01:06:38.380
So we have first the application directory that
deals with all the events and UI in the interface.

01:06:38.380 --> 01:06:42.840
We have the network directory that deals
with all the Bonjour and TCP connections.

01:06:42.840 --> 01:06:47.769
Then we have the renderers that have the processing
and rendering renderers to see where it's done,

01:06:47.769 --> 01:06:53.059
and then the extras which is just a bunch of
objects for getting rid of screen configurations

01:06:53.059 --> 01:06:56.579
and stuff like that and sending them over the network.

01:06:56.579 --> 01:07:01.269
Alright so go and come check out the wall, you can
have open hours when you can try your own composition

01:07:01.269 --> 01:07:04.259
and if it don't look great at least it looks big.

01:07:04.260 --> 01:07:05.770
(laughter)

01:07:05.769 --> 01:07:07.509
So let me go back here.

01:07:07.510 --> 01:07:14.630
(applause)

01:07:14.630 --> 01:07:18.010
Hello, OK, thanks.

01:07:18.010 --> 01:07:25.610
Thanks Kevin for all of those great
demonstrations, so rapidly a few slides to finish;

01:07:25.610 --> 01:07:31.420
I'd like to talk about optimizing the API usage,
we have a lot of new API's in Quartz composer

01:07:31.420 --> 01:07:33.869
and two big things you can do for performance.

01:07:33.869 --> 01:07:39.929
The first one is be careful of color management , we
now pay strict attention to that new image by applying

01:07:39.929 --> 01:07:45.159
so that your data is not properly tagged or tagged wrongly,
it will not look right or just slow down everything

01:07:45.159 --> 01:07:47.279
because we have to do this for color matching.

01:07:47.280 --> 01:07:52.720
So for, for instance try to stay away from device
core space because it's not always properly defined,

01:07:52.719 --> 01:07:56.500
you should use generate instead; the
NS color, NS bit map another kind

01:07:56.500 --> 01:08:02.420
of object those classes do not necessarily have a well
defined Quartz space either in all cases so it's better

01:08:02.420 --> 01:08:09.110
to use CG color or CG image and so forth and if you
deal with video data we have new profiles built in Leopard

01:08:09.110 --> 01:08:14.910
in the system so that you can tag them properly
with like 709 HD or HD content.

01:08:14.909 --> 01:08:21.689
And also I'd like to point out that to really increase
performances in complex users of Quartz composer,

01:08:21.689 --> 01:08:26.809
you're likely going to have multiple QCView or
QCRenderer and passed data will be between them

01:08:26.810 --> 01:08:30.539
You used to be limited to have to use NSG matrix
which are really not great for performances

01:08:30.539 --> 01:08:34.689
because it might imply downloading from a
GPU, re uploading, all those kind of things.

01:08:34.689 --> 01:08:41.009
So what we have now is through the value for output key of
type new method you can use a special type called QC image

01:08:41.010 --> 01:08:45.789
which will return an opaque object you cannot do
anything with but you can use it as a token to pass

01:08:45.789 --> 01:08:49.289
to another QCRenderer and that's
basically an internal measure composition

01:08:49.289 --> 01:08:52.670
for Quartz composer and super optimal, the best it will be.

01:08:52.670 --> 01:08:57.420
Same thing for passing structures around,
you can ask for a QC structure opaque object,

01:08:57.420 --> 01:09:02.069
for more information Alan Schaffer is our
Graphics Evangelist so please refer to him

01:09:02.069 --> 01:09:06.409
and once again we have a great public
mailing list you're more than welcome to join

01:09:06.409 --> 01:09:09.220
and we're actively participating on that list.

01:09:09.220 --> 01:09:14.150
We have our lab right this afternoon where actually
most of us are going to go right now and during lunch break

01:09:14.149 --> 01:09:16.449
and we'll be there all afternoon
in the graphics imaging lab.

01:09:16.449 --> 01:09:18.849
The OpenGLP pooling core image people will be there as well,

01:09:18.850 --> 01:09:22.230
so it's going to be a great lab please
drop by if you have any questions.

01:09:22.229 --> 01:09:24.189
Now what to remember from these sessions?

01:09:24.189 --> 01:09:29.659
Well, really I'd like you to consider how Quartz
composer can help you in your new project and the fact

01:09:29.659 --> 01:09:35.789
that it's not only for graphics because even it's multi
used for that today, you can definitely build a composition

01:09:35.789 --> 01:09:41.489
that does pure data processing and outputs
other data without rendering in a single screen.

01:09:41.489 --> 01:09:47.269
Also, you can do pretty complex things if you
want to integrate an already existing application

01:09:47.270 --> 01:09:52.850
and a QCRenderer might be your best friend for that
because you really have precise control over the rendering.

01:09:52.850 --> 01:09:59.490
And finally you know it's now completely possible to extend
Quartz composer by writing your own patches and you can do

01:09:59.489 --> 01:10:04.079
that in a simpler way using the virtual
patch technique I described as the beginning,

01:10:04.079 --> 01:10:07.309
or you can write your own plug-ins and this
time you have to use Xcode on Objective-C 2.0.
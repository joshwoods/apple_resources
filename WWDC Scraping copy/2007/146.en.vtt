WEBVTT

00:00:13.160 --> 00:00:22.589
>>Hello, welcome; I'm Perry Kietreiber usually called Perry
the Cynic and this is if I recall something like,

00:00:22.589 --> 00:00:27.500
"Sign your applications to make the world
a better place" and oh a very long title

00:00:27.500 --> 00:00:32.039
but what it really is about is code signing.

00:00:32.039 --> 00:00:34.149
( Pause )

00:00:34.149 --> 00:00:36.119
Yea, that's me.

00:00:37.439 --> 00:00:40.030
So what am I going to tell you?

00:00:40.030 --> 00:00:50.920
What code signing is, how we're using it in Leopard and what
you need to get your application signed and well how to stay

00:00:50.920 --> 00:00:54.490
out of trouble while you get your application signed.

00:00:56.969 --> 00:01:03.179
Those of you who've been here last year, this is
about the same thing and you'll definitely notice

00:01:03.179 --> 00:01:07.480
that I'm telling you the same thing again
because the technology itself hasn't changed;

00:01:07.480 --> 00:01:15.020
the only difference is that it's really here; so what
we promised we pretty much did and a little bit more.

00:01:16.790 --> 00:01:17.950
So what is code signing?

00:01:17.950 --> 00:01:26.189
It's actually about you; it's about the developer;
you get something that you haven't had before.

00:01:26.189 --> 00:01:38.700
You get to define an identity for your code; you get to
give it a real identity and the system from that point

00:01:38.700 --> 00:01:48.000
on forward takes care of finding out if somebody mucked with
your program, changed it and conversely if there's a change

00:01:48.000 --> 00:01:50.299
that happens to your program that you meant to happen

00:01:50.299 --> 00:01:58.250
because you shipped a software update the system
is smart enough to realize that that's okay.

00:01:59.390 --> 00:02:08.409
Once you got your code off on the user system there is
functionality for checking the stuff right there on disk

00:02:08.409 --> 00:02:12.069
to see if its changed, it its still
intact, if it's really yours

00:02:12.069 --> 00:02:19.709
and more importantly running code once your application
has launched the system can check that running code

00:02:19.710 --> 00:02:29.080
and see if it's still what you shipped or if there
was a change...and following the old tradition,

00:02:29.080 --> 00:02:35.230
so what doesn't it do other than save
the universe just like other technologies

00:02:35.229 --> 00:02:38.289
in the security arena that the authorization subsystem.

00:02:38.289 --> 00:02:43.169
It doesn't actually give you any privileges
by itself that you don't already have;

00:02:43.169 --> 00:02:49.589
so just because your application is signed doesn't mean
that it suddenly gets root access or get to do all kinds

00:02:49.590 --> 00:02:55.450
of special things although there
are system components that will look

00:02:55.449 --> 00:02:59.099
at your code signature to decide
whether to let you have stuff.

00:03:00.259 --> 00:03:07.739
Code signing is not about your program having bugs or
not; if you write a buggy application and you sign it,

00:03:07.740 --> 00:03:12.409
it will be a signed buggy application and it'll
have your name on it saying, "We made this."

00:03:12.409 --> 00:03:15.680
The bug will still be there and it
can still erase the users hard drive

00:03:15.680 --> 00:03:20.250
if that's your bug; I recommend against it personally.

00:03:20.250 --> 00:03:29.240
The other thing that code signing doesn't protect the
user from is to trust somebody they shouldn't be trusting

00:03:29.240 --> 00:03:34.379
because this is all about whether
the user trusts the developer.

00:03:34.379 --> 00:03:40.500
If a user says, "I trust Mr. Hackers mail application"
and Mr. Hackers mail application (inaudible) up all

00:03:40.500 --> 00:03:48.560
of the passwords and e-mail addresses and mails them to
him code signing says, "Okay, you said you wanted to."

00:03:48.560 --> 00:04:00.670
So code signing itself does not decide for the user who
to trust; it just lets the user express who to trust

00:04:00.669 --> 00:04:07.479
and who not to trust and they always ask me
to say this is not a copy protection facility

00:04:07.479 --> 00:04:12.229
so if you're making copy protection software
this is not here to put you out of business.

00:04:12.229 --> 00:04:19.349
It does help you figure out whether somebody mucked with
your program; so whether you are doing copy protection

00:04:19.350 --> 00:04:24.450
or not that it will do for you but it doesn't do anything
about somebody copying a program to another system

00:04:24.449 --> 00:04:30.029
and running it there; that's not its job.

00:04:30.029 --> 00:04:38.409
So, last year I told we were just starting to put
this into Leopard; well we have put it into Leopard

00:04:38.410 --> 00:04:41.310
and it's actually in a number of places now.

00:04:41.310 --> 00:04:47.899
The Keychain subsystem uses code signing to identify
clients so every time you make a Keychain call and you say,

00:04:47.899 --> 00:04:56.659
"I want this password because I'm me" code signatures
will get checked and you will have extra problems

00:04:56.660 --> 00:04:59.640
if your signature isn't there or isn't intact.

00:04:59.639 --> 00:05:04.949
Anytime the security server daemon deals
with a client and that includes you

00:05:04.949 --> 00:05:11.089
if you're making authorization calls it will use code
signing to determine who you are, what your name is,

00:05:11.089 --> 00:05:17.009
what your identity is; again there's this
identity thing but you're putting on your code.

00:05:17.009 --> 00:05:21.789
If the administrator turns on parental
controls code signing will be used

00:05:21.790 --> 00:05:28.910
to determine whether a particular application that's on a
list of allowed things to run really is what he claims to be

00:05:28.910 --> 00:05:37.140
so no more just mucking with info P lists to pretend
that Walter Farcraft really is mail dot application.

00:05:37.139 --> 00:05:43.399
There is a new feature in Leopard called the automatic
firewall, you may have heard of it as the outgoing firewall

00:05:43.399 --> 00:05:51.609
or application firewall; that uses code signing in a limited
fashion to decide whether to put up a big dialog saying,

00:05:51.610 --> 00:05:57.710
"Do you really want that application: or if you're
validly signed it won't; it'll just go, Oh, okay,

00:05:57.709 --> 00:06:08.680
you may and those of you who call an obscure system called
call task for PID you pretty much need to be code signed

00:06:08.680 --> 00:06:14.379
in order to make that call in Leopard unless you want to
rely on a legacy facility and nobody here wants to rely

00:06:14.379 --> 00:06:23.800
on a legacy facility, right, good; so all of that is yours
if you sign your code; so you want to sign your code.

00:06:23.800 --> 00:06:28.160
I'll tell you that 3 times and then another 3
times because you really want to sign your code.

00:06:28.160 --> 00:06:30.180
No excuses this time.

00:06:32.110 --> 00:06:39.080
Let me give you sort of the brief flow of
data for how this code signing thing works.

00:06:39.079 --> 00:06:46.689
The vendor on the left that's you; you build your program
like you always do; you take your code, your info P list,

00:06:46.689 --> 00:06:54.000
your resources, whatever else goes in there and you assemble
it in Xcode or with meg files, whichever way you want

00:06:54.000 --> 00:07:00.910
and the extra step is that you take a code signing identity
which is one of those script-o-graphic identity things

00:07:00.910 --> 00:07:05.820
and it gets stored in Keychains because
this is Mac OS X and you feed it

00:07:05.819 --> 00:07:12.709
into a command line call sign that's one of those
command line commands and out pops the modified version

00:07:12.709 --> 00:07:17.409
of your signed code that actually
has a signature embedded in it.

00:07:17.410 --> 00:07:22.010
What it will actually do is modify it in
place by just sticking the signature in.

00:07:22.009 --> 00:07:27.370
You take that signed code instead of the original
and you ship it anyway you want; you know,

00:07:27.370 --> 00:07:33.459
we don't care how you do that, Apple installer, third
party installer, Dragon install, you know Magical network,

00:07:33.459 --> 00:07:37.649
transfer mechanisms, we don't care as
long as the thing on the user system

00:07:37.649 --> 00:07:44.389
when you're all done is exactly the signed code
that you started with and we really pretty much mean

00:07:44.389 --> 00:07:54.620
byte for byte the same application and the user runs it and
through the miracle of code signing if anybody is interested

00:07:54.620 --> 00:08:00.709
in the identity of that running code they call our
verification API and the system basically says,

00:08:00.709 --> 00:08:05.709
"Yea that's it or No that's not it and
that's why" and that's all there is;

00:08:05.709 --> 00:08:10.579
it's really simple unless you have to implement it.

00:08:10.579 --> 00:08:11.149
( Laughter )

00:08:11.149 --> 00:08:20.359
Okay, so as I said, we have the stuff that's sitting on
disk, that's what you're signing, you know, your application

00:08:20.360 --> 00:08:31.030
or your tool or whatever that code is of yours; that's what
carries the signature once you sign it; that's what you ship

00:08:31.029 --> 00:08:38.139
and because that is what we're protecting against
modification it better be immutable and that's another one

00:08:38.139 --> 00:08:40.319
of those, "I'll tell you 3 times things."

00:08:40.320 --> 00:08:46.960
You will get in trouble if you change your code after it's
signed and it increasingly doesn't matter which part of it;

00:08:46.960 --> 00:08:54.030
obviously the code itself, you know, the Mach-O,
instructions but now it also means the info P list

00:08:54.029 --> 00:09:00.870
because it describes to the system things about
your code and I'm also talking about your resources.

00:09:00.870 --> 00:09:06.429
If you have a habit of mucking with the resources
in your programs after they've been installed,

00:09:06.429 --> 00:09:09.349
listen up, I'll tell him what he tells later.

00:09:10.450 --> 00:09:18.440
Obviously code is, you know, tools, Mach-0 binaries,
bundles with Mach-0 binaries but code in the sense

00:09:18.440 --> 00:09:26.300
of code signing also includes a bit more surprising
things like libraries and frameworks and plug ins

00:09:26.299 --> 00:09:33.659
and potentially also scripts, you know, Ruby scripts,
Perl scripts, whatever; in principle scripts are code

00:09:33.659 --> 00:09:42.919
and code signing understands that scripts are code and in
fact code signings notion of what is code is extensible;

00:09:42.919 --> 00:09:52.899
so over time more things will become recognized
as code and become signed and verified as code.

00:09:52.899 --> 00:09:53.639
( Pause )

00:09:53.639 --> 00:09:59.720
Now code signings primary interest isn't
actually on this stuff sitting on disk;

00:09:59.720 --> 00:10:05.259
as long as it sits on disk it's harmless; once
it's running it's dangerous and once its running

00:10:05.259 --> 00:10:11.370
and you know make system calls and RPC calls and ask
for all kinds of stuff like your Keychain password

00:10:11.370 --> 00:10:14.299
for your mail account then it's dangerous.

00:10:14.299 --> 00:10:20.990
So code signing is primarily focused from a verification
point of view; it's actually on running code.

00:10:20.990 --> 00:10:23.820
This is sort of an important point.

00:10:23.820 --> 00:10:31.370
You can run verifications on stuff on disk and it'll work
and it'll give you useful information but that's almost sort

00:10:31.370 --> 00:10:34.669
of a side effect of what this is really about.

00:10:34.669 --> 00:10:43.339
At runtime the system keeps essentially a bit with
every running process; we call it the valid bit

00:10:43.340 --> 00:10:47.800
and it basically says, "As far as
we know so far this thing is okay."

00:10:47.799 --> 00:10:55.149
There are things that flip this validate off,
basically make the identity of this code invalid

00:10:55.149 --> 00:11:02.259
and once it's off it will never come back on; it's a
sticky bit; so when something bad happens to your program

00:11:02.259 --> 00:11:07.789
and it loses it's identity the valid bit goes off;
it's invalid until it dies; if you re-launch it,

00:11:07.789 --> 00:11:11.990
it starts valid again until it does that bad
thing again that made it lose it's validity

00:11:11.990 --> 00:11:18.680
and then there's additional stuff that the system
also keeps, like there is a bit called KILL bit

00:11:18.679 --> 00:11:22.000
which basically says, "If I ever
lose my identity just shoot me."

00:11:22.000 --> 00:11:23.370
( Laughter )

00:11:23.370 --> 00:11:25.769
Yea, that's exactly it.

00:11:25.769 --> 00:11:31.539
That is sticky too; once you set it, it
won't ever clear again for that process.

00:11:31.539 --> 00:11:35.240
That's a useful combination because
if you ever see a process that's valid

00:11:35.240 --> 00:11:38.310
and has the KILL bit set you know it will always be valid

00:11:38.309 --> 00:11:43.489
because if it ever loses it's validity it'll
be dead; so as long as it's alive it's valid.

00:11:43.490 --> 00:11:45.000
Cool feature.

00:11:45.000 --> 00:11:49.259
There's another one called HARD that is
occasionally useful; it basically means "Please

00:11:49.259 --> 00:11:56.659
if I ever have a choice I'd rather not get my resources
than lose my identity because my resources are bad."

00:11:56.659 --> 00:12:00.860
It's sometimes useful, not terribly.

00:12:00.860 --> 00:12:06.019
So, I said this is really about running code

00:12:06.019 --> 00:12:12.340
and well there's a lot more stuff executing
in the system than just processes.

00:12:12.340 --> 00:12:17.930
I mean, every time you run a script;
I mean you run, I don't know,

00:12:17.929 --> 00:12:21.129
Ruby but what you're really running it the Ruby script.

00:12:21.129 --> 00:12:26.220
Ruby the program is just there because
it's necessary to help running the script.

00:12:26.220 --> 00:12:33.430
If you're running a PowerPC binary on an Intel machine it's
actually the Rosetta system that's executing the program

00:12:33.429 --> 00:12:37.449
in very magic and highly patented ways.

00:12:37.450 --> 00:12:42.340
So from the kernels point of view it's dealing with
this thing called translate which is part of Rosetta

00:12:42.340 --> 00:12:46.060
but from you point of view, from the user's
point of view they don't want to know.

00:12:46.059 --> 00:12:51.589
If you've played with the earlier version of the beta once
in a while programs would pop up these odd dialogs that say,

00:12:51.590 --> 00:12:54.120
"Translate wants access to your Keychain password."

00:12:54.120 --> 00:12:57.840
Well, that's actually Rosetta because you were
running a PowerPC binary and at that point

00:12:57.840 --> 00:13:03.899
in time things haven't been hooked up yet, now they
are; so welcome to the beta where this all works.

00:13:03.899 --> 00:13:10.809
So when you were looking at running code things are a lot
more complicated than just processes and just, you know,

00:13:10.809 --> 00:13:18.479
files on disk and the way code signing deals with that
and this is the really, really high level explanation,

00:13:18.480 --> 00:13:26.610
is code signing understands that code is run by other
code; processes are run by the kernel and scripts are run

00:13:26.610 --> 00:13:34.019
by the script interpreter and PowerPC binaries are
run by this Rosetta machinery and hey, CFM binaries,

00:13:34.019 --> 00:13:39.439
yes we still support them, are run by
this launch CFM app thing and so on.

00:13:39.440 --> 00:13:45.470
To which if you're on Intel as the good gentleman in
the front row says, "Yea; so these mechanisms stack;

00:13:45.470 --> 00:13:53.240
you can actually build this theoretically very long chain of
host codes that on guest codes that are in turn host codes

00:13:53.240 --> 00:13:57.960
and we call that the hosting chain;
so even in a general situation you end

00:13:57.960 --> 00:14:03.220
up with this fairly complicated
stack relationship of running codes,

00:14:03.220 --> 00:14:10.570
managing other running codes and it works; it really does.

00:14:10.570 --> 00:14:13.470
So here's a couple of graphical depictions.

00:14:13.470 --> 00:14:18.750
This is the trivial and obvious case where the kernel
is running a process that it fetched from the disk.

00:14:18.750 --> 00:14:20.850
( Pause )

00:14:20.850 --> 00:14:29.519
Here is one that is actually from real life...that had the
kernel using Rosetta to run a PowerPC binary that happens

00:14:29.519 --> 00:14:37.269
to be the launch CFM application helper which actually
manages to run an old CFM program like Microsoft Word,

00:14:37.269 --> 00:14:40.370
until they finally come out with the new version.

00:14:40.370 --> 00:14:44.269
So this ones real; that happens
today if you want to run Word

00:14:44.269 --> 00:14:47.809
or anything else that's a CFM app on your Intel machine.

00:14:47.809 --> 00:15:01.189
Here's a hypothetical one where...yep, where you have
Ruby the interpreter...okay somebody messed this slide up.

00:15:01.190 --> 00:15:02.860
I apologize sincerely.

00:15:02.860 --> 00:15:11.330
I hope it wasn't me; oh, anyway...imagine Ruby running
a Ruby script, that's hypothetical because at this point

00:15:11.330 --> 00:15:21.300
in time we haven't hooked up the API calls in the
Ruby interpreter; eventually we will or you know,

00:15:21.299 --> 00:15:28.549
it's something like 5 lines of C code; it's really
pretty easy; it just requires that...whoever manages

00:15:28.549 --> 00:15:33.909
that particular program knows where the
paths are coming from and when things happen.

00:15:35.750 --> 00:15:46.019
Okay, so here's sort of a bonus that comes along with code
signing; it's there because code signing uses it internally.

00:15:46.019 --> 00:15:54.409
There is this requirement language; it's sort of this
small interpreted programming language that is solely there

00:15:54.409 --> 00:16:01.519
so you can express in a formal way
constraints or restrictions on pieces of code.

00:16:01.519 --> 00:16:11.379
That's there and it's used internally in code signing and
if you're using the verification APIs you can write one

00:16:11.379 --> 00:16:15.189
of those requirements and pass them in and
say, "This is code, satisfy this requirement."

00:16:15.190 --> 00:16:22.370
That's all I'm going to tell you about it
because unfortunately that's not in API

00:16:22.370 --> 00:16:26.720
and Leopard so consider yourself tantalized.

00:16:26.720 --> 00:16:29.879
( Laughter )

00:16:29.879 --> 00:16:37.720
When your signing code you use a cryptographic
signing identity and I've been warned

00:16:37.720 --> 00:16:42.490
because we've got 2 identity words in here;
we have the identity that you assign your code

00:16:42.490 --> 00:16:48.000
which is essentially a name you're giving to you code
and then you put your stamp on and say, "We made this

00:16:48.000 --> 00:16:53.149
and therefore you can believe us" and then there is
this cryptographic identities which are, you know,

00:16:53.149 --> 00:17:03.230
cryptographic keys and digital certificates;
those you use to actually find your code.

00:17:03.230 --> 00:17:06.650
So these are the signing identities that you use to sign.

00:17:06.650 --> 00:17:12.720
We using an industry standard format; there're signed
X5 certificates if you happen to know what that is

00:17:12.720 --> 00:17:19.329
and it's using the standard code signing extension
that's been in that RFC for pretty much forever;

00:17:19.329 --> 00:17:26.199
you can get those by buying them from
commercial certificate authorities,

00:17:26.200 --> 00:17:29.580
that's perfectly fine; that has certain advantages.

00:17:29.579 --> 00:17:36.389
You can make your own; Keychain access the
utility application has a little helper built

00:17:36.390 --> 00:17:39.670
in called the certificate assistant and as of, you know,

00:17:39.670 --> 00:17:45.590
a couple of betas ago it can make you a
code signing certificate fairly painlessly.

00:17:45.589 --> 00:17:48.649
( Laughter )

00:17:48.650 --> 00:17:58.660
Hey, nothings free...and if you happen to have a
Microsoft style authentic code certificate or identity

00:17:58.660 --> 00:18:05.000
that you're using for code signing on that operating system
that shall not be named they will work because, you know,

00:18:05.000 --> 00:18:08.869
at least as far as we know they're
following the standard and so do we.

00:18:10.160 --> 00:18:17.320
Signing identities are stored in Keychains, you don't
get a choice here; so if somebody hands it to you

00:18:17.319 --> 00:18:21.379
in a different format you will have
to import it into your Keychain

00:18:21.380 --> 00:18:26.220
but then everybody has a Keychain whether you
want it or not so you might as well use it.

00:18:26.220 --> 00:18:33.730
Speaking of Keychains...the access control mechanism

00:18:33.730 --> 00:18:42.130
that Keychain items have a major improvement
based on code signing; you've always been able to say

00:18:42.130 --> 00:18:50.420
that say this mail password only can be accessed by mail
dot application but not anybody else except, you know,

00:18:50.420 --> 00:18:55.710
it pops up a dialog and asks you whether you
want to; anyway if it's not pre-approved.

00:18:55.710 --> 00:19:04.779
That used to be an okay mechanism based on essentially
what bytes are in the executable but now its based

00:19:04.779 --> 00:19:10.799
on the code signing identity of programs that are
signed and that's a heck of a lot more flexible

00:19:10.799 --> 00:19:16.740
because among other things it automatically figures out
whether the new version of your program is an update

00:19:16.740 --> 00:19:20.279
to an old version; so certain dialogs
that I'm sure you've all come

00:19:20.279 --> 00:19:23.750
to love will just not happen if
your application is properly signed.

00:19:23.750 --> 00:19:30.900
So there's another reason, sign
your applications, thank you.

00:19:30.900 --> 00:19:35.810
If you've already shipped an application in Tiger obviously
it's not going to be signed and people have used it

00:19:35.809 --> 00:19:44.000
and made Keychain items that are accessible to that
application; if you ship and update of that application

00:19:44.000 --> 00:19:50.250
in Leopard that is signed the system actually
has an upgrade path that it takes automatically

00:19:50.250 --> 00:19:57.769
where it basically edits  ccess control list of the agent
to put a method of extra information in so it understands

00:19:57.769 --> 00:20:01.960
that the signed version of your program
is a continuation of the unsigned version;

00:20:01.960 --> 00:20:09.630
so you will in most circumstances see one last one of those
dialogs that basically says, "This is really an upgrade

00:20:09.630 --> 00:20:14.760
to the previous one" and then it'll shut up as long as
you don't keep flipping back and forth between Leopard

00:20:14.759 --> 00:20:22.170
and Tiger where of course Tiger doesn't understand any of
this and you know, introduces new things that Leopard needs

00:20:22.170 --> 00:20:28.610
to think about; so if your users make a transition
strictly from Tiger to Leopard and then stay there

00:20:28.609 --> 00:20:35.559
after that last instance of those
dialogs things will just shut up.

00:20:35.559 --> 00:20:41.720
If you use the SecAccess
or SecTrusted application APIs

00:20:41.720 --> 00:20:48.960
to make custom access control list the really good news
is that those APIs are still there and they're unchanged

00:20:48.960 --> 00:20:55.620
and they still work and your code is going to continue
to work without you having to make any changes to it

00:20:55.619 --> 00:20:59.299
and it'll use code signing if your application is signed.

00:20:59.299 --> 00:21:05.539
So you'll get all of the extra super benefits without
having to change any codes; we're rather proud of that one.

00:21:07.779 --> 00:21:19.319
Gee, time for a demo. Okay I hope
nobody is afraid of command line commands.

00:21:19.319 --> 00:21:27.379
I made this really small test program called CS Test
for code signing testing and let's just take a look

00:21:27.380 --> 00:21:31.350
at what happens with unsigned programs;
one of the few things CS Test knows how

00:21:31.349 --> 00:21:38.589
to do is it can make a Keychain item and having
made the Keychain item it can retrieve it again;

00:21:38.589 --> 00:21:43.769
since it made the item it has free
access to the item, that's fine;

00:21:43.769 --> 00:21:53.019
now if you've ever made Keychain calls you know
what happens if you make a change to your program.

00:21:53.019 --> 00:22:05.450
Let's say...we make a new version of this with a trivial
change in it...and well the system doesn't really know

00:22:05.450 --> 00:22:14.180
that that new CS Test is a genuine approved by you the
developer real new version of CS Test so you get this dialog

00:22:14.180 --> 00:22:17.160
that basically says, "Hey user I can't figure this out.

00:22:17.160 --> 00:22:24.840
Is this the same kind of CS Test that you had before"
and people say always allow and then you get access

00:22:24.839 --> 00:22:29.639
to your Keychain item again until you change it.

00:22:29.640 --> 00:22:33.910
People hate those dialogs; you hate those dialogs, admit it.

00:22:33.910 --> 00:22:41.180
Okay so this is a command called code sign
in user bin; it's a command line command,

00:22:41.180 --> 00:22:48.990
sorry about that, and you can tell it to sign say CS Test.

00:22:50.339 --> 00:22:59.649
The signing identity is in the Keychain so we
have to unlock it and...now CS Test is signed.

00:23:01.220 --> 00:23:08.390
Dash V for verify and you know dash V for give me more
verbose information; it's a classic Unix thing again

00:23:08.390 --> 00:23:15.940
if you're wondering there's a man page, go read it;
it's actually your best preference to the command.

00:23:15.940 --> 00:23:25.500
Okay...so CS Test, still in the same program of course,
this was the automatic upgrade I was talking about;

00:23:25.500 --> 00:23:33.200
if this was your signing identity you'd get a confirmation
dialog because Apple gets certain privileges here.

00:23:33.200 --> 00:23:34.200
So, let's try this again.

00:23:34.200 --> 00:23:42.029
You know, management comes to you and
says, "You shall put a strict disclaimer

00:23:42.029 --> 00:23:46.470
into our program because our lawyers are sorely afraid."

00:23:46.470 --> 00:24:03.589
So CS Test of course since we just, we built it, isn't
signed so we need to sign it again...and now...it's signed.

00:24:03.589 --> 00:24:08.139
Think about what we just did.

00:24:08.140 --> 00:24:10.190
If this is you, what you just did.

00:24:10.190 --> 00:24:17.450
You basically said, "This is my
program; it's called CS Test and I vouch

00:24:17.450 --> 00:24:20.370
with my digital identity that I really made this."

00:24:20.369 --> 00:24:23.979
This is the same statement you
made about the previous version.

00:24:23.980 --> 00:24:28.809
So rather than the system having to
think about what bytes are in the file

00:24:28.809 --> 00:24:36.740
and what does this all mean now the system can look at
this and go, "Oh, the developer who made the original said

00:24:36.740 --> 00:24:43.500
that this is the same program; so no problem, he said so.

00:24:43.500 --> 00:24:49.210
I mean if you can't trust the developer about
the identity of his program who can you trust?"

00:24:49.210 --> 00:24:58.350
So if we run that thing again, no dialogs
because everybody knows what's going on.

00:24:58.349 --> 00:24:58.639
So...

00:24:58.640 --> 00:25:04.840
( Applause )
Well, thank you.

00:25:04.839 --> 00:25:13.079
In a sense this is sort of the crust of the matter,
you know, it's the absence of dialog isn't just

00:25:13.079 --> 00:25:18.029
that we got tired of putting dialogs in
everybody's face and now we're shutting up,

00:25:18.029 --> 00:25:23.230
it's that we don't need the dialogs anymore because
now the system actually knows what's going on;

00:25:23.230 --> 00:25:26.029
that's the big change.

00:25:26.029 --> 00:25:29.589
Okay, well for those of you who would never be caught dead

00:25:29.589 --> 00:25:36.429
with a command line tool I made a
version of CS Test that's an application.

00:25:36.430 --> 00:25:42.850
It basically does the same thing; it just checks itself
so it can report on what's going on and right now

00:25:42.849 --> 00:25:51.359
since we just made it, it says that
it's not signed; so let's sign it.

00:25:51.359 --> 00:25:52.500
( Pause )

00:25:52.500 --> 00:26:01.349
You'll notice we're signing a bundle here and the signing
mechanism understands what it means to sign a bundle

00:26:01.349 --> 00:26:11.699
so when we run the program now it's valid and
particularly here the dynamic validity of the program is

00:26:11.700 --> 00:26:18.610
on because we haven't done anything to invalidate
it; so let's ask CS Test to access that test item;

00:26:18.609 --> 00:26:24.029
CS the application is a different program from CS
Test the command line tool so you'll get this dialog

00:26:24.029 --> 00:26:29.899
as you should because, Hey it's a new program that
wants access to the Keychain items so let's say okay

00:26:29.900 --> 00:26:36.230
and at this point...yep, now both of
them have access to the Keychain item.

00:26:36.230 --> 00:26:41.700
Now let's turn the dynamic validity of this
thing off; the code is still statically valid;

00:26:41.700 --> 00:26:49.650
the thing on disk is just fine but something happened to
this running program and if it's now trying to get access

00:26:49.650 --> 00:26:54.750
to this Keychain item you're getting a
new dialog that basically says, "You know,

00:26:54.750 --> 00:27:00.809
something is not right with that program as it's running
here; you know, something changed it and do you still want

00:27:00.809 --> 00:27:06.279
to allow access because the pre-approved
entry doesn't apply anymore?"

00:27:06.279 --> 00:27:11.049
You also won't be able to say all was allowed because
at this point it's quite unclear what the identity

00:27:11.049 --> 00:27:14.750
of this program would be since something has mucked with it.

00:27:14.750 --> 00:27:23.190
You can still allow on a one time basis, the user can, and
if you quit it and re-launch it since there's nothing wrong

00:27:23.190 --> 00:27:28.700
with the version on disk it gets
access to the item just fine.

00:27:28.700 --> 00:27:36.069
So, you may wonder what happens if
we make a change to the program.

00:27:36.069 --> 00:27:41.559
I have a little hacking program that let's us
change code but I'm not going to daemonstrate that;

00:27:41.559 --> 00:27:52.220
let's just crawl in here...and...oh, I don't know, change
the info P list; that's how in Tiger the smart kids get

00:27:52.220 --> 00:27:58.630
around parental controls because parental controls
just looks at the CF bundle identifier and what ever

00:27:58.630 --> 00:28:02.160
that says it believes so if you take Walter Farcraft

00:28:02.160 --> 00:28:11.080
and you say it's com dot Apple dot
mail...let's try that...see, easy change.

00:28:11.079 --> 00:28:18.259
Oh, wait, the code signing system actually looks at the
info P list; it basically thinks of it as an extension

00:28:18.259 --> 00:28:22.589
of the code and it notices that that file has been modified;

00:28:22.589 --> 00:28:30.500
so at this point this time the dynamic validity
hasn't been affected but the thing on disk is wrong.

00:28:30.500 --> 00:28:38.829
In that effect it's pretty much the
same...you can't get at the Keychain item.

00:28:38.829 --> 00:28:45.129
If you undo the change since, you
know, you're back petting the thing

00:28:45.130 --> 00:28:51.090
on disk okay remember how I told you it doesn't matter
how you ship your code, how you install your code;

00:28:51.089 --> 00:29:01.449
all that matters is what's there on disk when the
thing is running and if it's intact we're fine.

00:29:01.450 --> 00:29:12.299
Same thing happens to resources; there isn't much resources
in this program of course but let's just add a new resource.

00:29:12.299 --> 00:29:13.059
( Pause )

00:29:13.059 --> 00:29:18.529
Oh, come on, do what I mean.

00:29:18.529 --> 00:29:19.200
( Pause )

00:29:19.200 --> 00:29:32.779
And the system is looking at the resources too; when you
sign a program with, that is a bundle that has resources,

00:29:32.779 --> 00:29:37.920
this has actually built something called a resource
directory that collects information about all

00:29:37.920 --> 00:29:45.590
of these resource files and builds little cryptographic
signatures for each of them; so not only does it tell

00:29:45.589 --> 00:29:50.009
if a file has been modified it can also
tell where the files got edited or removed.

00:29:50.009 --> 00:29:54.849
So in this case we added a resource that wasn't
there; just think about it, it could have been a nib

00:29:54.849 --> 00:30:02.709
or it could have been something that changes the
behavior of the program and well we figured it out

00:30:02.710 --> 00:30:10.509
and again if you remove this you're back into the good,
the valid state of things and you know, we're back.

00:30:10.509 --> 00:30:11.710
( Pause )

00:30:11.710 --> 00:30:20.930
Let's see, alright just as a small bonus
daemonstration, one of the other things that CS Test,

00:30:20.930 --> 00:30:26.350
the command line tool can do is it can
actually simulate being a code host.

00:30:26.349 --> 00:30:33.169
I mean, not simulate, it can be a code host.

00:30:33.170 --> 00:30:41.750
I've got these little scripts called A and B
just to show you what it is; it's a text file;

00:30:41.750 --> 00:30:53.319
it's just a simple text file; there's nothing executable
about it per say but you can teach CS Test to be a code host

00:30:53.319 --> 00:31:03.950
for say A...and access a Keychain
item and what we get is this.

00:31:03.950 --> 00:31:10.860
What happened here is that CS Test called an API that
said, "Hey I'm code host and I'm now acting on behalf

00:31:10.859 --> 00:31:15.329
of this A dot CS Test file over there" and the system said,

00:31:15.329 --> 00:31:21.949
"Okay" and then when CS Test the program
made the Keychain call the system said,

00:31:21.950 --> 00:31:26.360
"Yea but you're not really you;
you're acting on behalf of this A."

00:31:26.359 --> 00:31:34.189
The security daemon got told that the identity of the
requester isn't CS Test, it's A and so the security dialog

00:31:34.190 --> 00:31:43.390
that you're getting is about A dot CS Test; even
though CS Test the tool has pre-approved access

00:31:43.390 --> 00:31:50.950
to the Keychain item it doesn't apply here because it's
not CS Test making the request; it's A making the request.

00:31:50.950 --> 00:31:56.819
So the code signing system in (inaudible) can
deal with things that aren't on process boundaries

00:31:56.819 --> 00:31:59.389
that aren't really processes, they are something else.

00:31:59.390 --> 00:32:07.360
You know, this could be your Ruby script; this will in fact
your program if it's a PowerPC version running on Intel

00:32:07.359 --> 00:32:14.679
with CSF's role being played by Rosetta and there we are.

00:32:14.680 --> 00:32:17.600
Okay...end of demo.

00:32:17.599 --> 00:32:24.500
( Applause )

00:32:24.500 --> 00:32:31.809
There is a lot more to this but this is a one hour session
and I'm also somewhat constrained by the fact that most

00:32:31.809 --> 00:32:35.960
of the APIs aren't going to be APIs in Leopard.

00:32:35.960 --> 00:32:42.630
So primarily what you get to do this time
around is sign your code and watch the show.

00:32:42.630 --> 00:32:53.270
And now the second part of the presentation; I've tried to
sort of explain to you in first part what this is all about

00:32:53.269 --> 00:32:57.019
and now I'll talk about what it all means to you.

00:32:59.140 --> 00:33:05.480
This is one slide if you've been here last
year that you looked at and basically it says,

00:33:05.480 --> 00:33:12.529
"What should you be doing a year ago
and well get ready because it's coming."

00:33:12.529 --> 00:33:17.039
Alright it's a year later it's here, hope you're ready.

00:33:17.039 --> 00:33:21.569
If you're not, if you just thought, "You know
they always talk about this and I'll deal with it

00:33:21.569 --> 00:33:25.029
when it's really here;" it's really here so what do you do.

00:33:25.029 --> 00:33:31.490
There's a set of things you have to do once, just
to set yourself up for that code signing gig.

00:33:33.059 --> 00:33:39.879
You have to figure out who in your outfit,
in your company gets to do the signing.

00:33:39.880 --> 00:33:44.490
If you're a garage shop; if it's just you
and a friend, not a problem, it's you.

00:33:44.490 --> 00:33:48.000
You know who you are, you trust yourself, cool.

00:33:48.000 --> 00:33:53.789
If you're a large company and you have a legal
department or an IT department you want to start talking

00:33:53.789 --> 00:34:01.319
to those folks now; particularly the legal departments
because they usually take months to get back to you.

00:34:01.319 --> 00:34:08.860
The question is, "Who in your company has the authority
to sign your code" because when they put their signature

00:34:08.860 --> 00:34:12.130
on the code they're speaking for your company as a whole.

00:34:12.130 --> 00:34:18.820
They say, "We, Adobe; we Microsoft; we Joe's Garage Shop,

00:34:18.820 --> 00:34:23.120
say that this is our code and we're
proud to call it our code."

00:34:23.119 --> 00:34:30.170
So you don't want to put that sign on some stupid little
hack that somebody in your company cooked up in a corner

00:34:30.170 --> 00:34:35.260
and you definitely don't want to put it on something
that somebody else made that you don't even know.

00:34:35.260 --> 00:34:42.080
So, it is important to figure out who
has the authority to sign your programs;

00:34:42.079 --> 00:34:46.880
then you need to decide what kind
of digital identity you want to use.

00:34:46.880 --> 00:34:52.269
I told you, you have a choice; you can buy one from
a certificate authority or you can make your own

00:34:52.269 --> 00:34:59.940
and there's good sides and bad sides on both sided of this;
so there's trade offs and I can't really go to much into,

00:34:59.940 --> 00:35:05.900
you know, the general nature of cryptographic signatures
and all that because, you know, that's another 2 hours

00:35:05.900 --> 00:35:11.490
but if you're a large company you'll probably
have folks who know about these things

00:35:11.489 --> 00:35:17.459
and if you're a small company you can always start with
one you make yourself and then worry about it later.

00:35:18.730 --> 00:35:21.990
Then you need to set up your signing process.

00:35:21.989 --> 00:35:27.539
You know, you have your work flow; you've got your Xcode
build so you make files or whatever it is that you do

00:35:27.539 --> 00:35:35.070
to build your programs and then typically after that you
package them up together in some way; you're mastering them,

00:35:35.070 --> 00:35:42.490
is the big word, getting it ready to be shipped out, you
know, over the network, burn it on CDs, whatever you do

00:35:42.489 --> 00:35:49.069
and in between there after you finish building and
before you start mastering, that's where you sign.

00:35:49.070 --> 00:35:54.970
So basically you're add a signing step in there and
depending on how automatic you want to be about this;

00:35:54.969 --> 00:35:59.639
we're talking about either adding a shell
script phase into your Xcode builds

00:35:59.639 --> 00:36:04.929
or having something a little bit more official where
people sit down with a glass of wine and you know say,

00:36:04.929 --> 00:36:08.909
"Yea, this ones good here, I'll sign it."

00:36:08.909 --> 00:36:12.819
So set up the process and then test it.

00:36:12.820 --> 00:36:20.990
Not much to test; you set up to sign; you do the signing;
you ship it to your friend who installs it and checks

00:36:20.989 --> 00:36:26.509
out if it's okay; you make an update, you
ship it again and you see if it's still okay.

00:36:26.510 --> 00:36:30.010
If you pass those 2 steps you're pretty much okay.

00:36:30.010 --> 00:36:38.820
I talked about that one so let's
just say that it's your choice.

00:36:38.820 --> 00:36:44.090
Apple doesn't tell you to go buy one;
Apple doesn't tell you not to go buy one;

00:36:44.090 --> 00:36:50.350
we support both types of signing
identities with the same enthusiasm.

00:36:50.349 --> 00:36:56.230
Apple itself we will not sell you or give you
signing identities; that's not our business;

00:36:56.230 --> 00:37:02.900
there isn't really anything we're adding to that
game that other companies can do at least as good;

00:37:02.900 --> 00:37:09.710
so don't look to us for giving you identities although,
you know, we can always try to give you advice.

00:37:11.010 --> 00:37:15.700
This is what you do every time that you
build code that you really want to sign.

00:37:15.699 --> 00:37:22.759
I highlighted the 2 steps, the signing one obviously that's
running code sign with the identity that you built yourself

00:37:22.760 --> 00:37:33.250
or bought yourself; the first highlighted step is maybe
not totally obvious; anytime you sign code you are saying,

00:37:33.250 --> 00:37:41.929
"I made this and I'm proud of it;" so you may want to
think a little bit about what hoops your code needs to jump

00:37:41.929 --> 00:37:45.980
through before you put that stamp
on it that says we're proud of this.

00:37:45.980 --> 00:37:50.150
I wouldn't advise you signing everything
that you build all the time.

00:37:50.150 --> 00:37:54.960
You know, development builds, debug
builds, because if those get out

00:37:54.960 --> 00:38:02.500
and they're signed your signature still says we're proud
of this even though it removes the user's hard drive.

00:38:02.500 --> 00:38:07.480
So...put a little bit of thought in there.

00:38:07.480 --> 00:38:15.280
You know, maybe you only want to sign your GM
releases; maybe you only want to sign your Betas;

00:38:15.280 --> 00:38:20.269
maybe you only want to sign stuff that at least,
you know, one of you has lived on for a week.

00:38:20.269 --> 00:38:25.280
It's your decision; I'm not telling
you what to do but think about it a bit

00:38:25.280 --> 00:38:30.450
because it's worthwhile spending
a bit of time thinking about it.

00:38:30.449 --> 00:38:37.659
The inquisitive ones among you will by now wonder,
"What the hell does this code signing thing do

00:38:37.659 --> 00:38:42.789
to my program anyway and what is it going break?"

00:38:42.789 --> 00:38:49.610
If your program is a Mach-O binary either directly or
because it's a bundle with the Mach-O binary in it,

00:38:49.610 --> 00:38:55.720
most of the signing information will actually go right
in there; so we're going to modify your executable

00:38:55.719 --> 00:38:58.089
by adding a section that contains a bunch of data in it.

00:38:58.090 --> 00:39:02.670
That happens to be a section that nobody
accept the code signing system looks

00:39:02.670 --> 00:39:09.900
at so your program will function the same, just you
know, understand that there's extra stuff in there.

00:39:09.900 --> 00:39:17.380
If your code is not a (inaudible) binary, I told
you we do scripts and all kinds of other stuff

00:39:17.380 --> 00:39:21.860
and then there really isn't any structured
way of sticking this directly into your files

00:39:21.860 --> 00:39:29.880
so what we do instead is we stick it in an extended
attributes; so if you do make code that isn't a file do note

00:39:29.880 --> 00:39:35.869
that we're adding extended attributes to your
executable file and don't use some installer

00:39:35.869 --> 00:39:37.960
that doesn't understand what an extended attribute is

00:39:37.960 --> 00:39:41.289
because it'll probably just leave
it behind...that's not good.

00:39:41.289 --> 00:39:48.940
If you have a bundle then we will also add a file
or 2 to the contents directory of your bundle;

00:39:48.940 --> 00:39:54.429
that's the resource directory; that's the list of all
of your resources and enough information to figure

00:39:54.429 --> 00:40:00.460
out if they have changed; so don't be surprised
if there's a file in your bundle that wasn't there

00:40:00.460 --> 00:40:05.539
when you built your program; if it's
called code resources, that's fine.

00:40:05.539 --> 00:40:11.789
If you are really curious, the code sign
command has an option for "Show me all the files

00:40:11.789 --> 00:40:14.969
that we added and modified when we signed this."

00:40:14.969 --> 00:40:23.599
That'll just give you a list of files so you know what
it did to your code and there's one last note...most

00:40:23.599 --> 00:40:28.210
of you won't have a problem with
this but I'll mention it anyway.

00:40:28.210 --> 00:40:36.369
When some other program is trying to establish whether
your code that is running is valid or not it is going to go

00:40:36.369 --> 00:40:42.779
and read the code signing information in your code, in your
bundle and your executable because it will need to in order

00:40:42.780 --> 00:40:46.930
to figure out who signed this and what it looks like.

00:40:46.929 --> 00:40:56.989
If you're installing your program in such a way that the
verifier can't read it he won' t be able to verify you;

00:40:56.989 --> 00:41:04.959
so if you make your program not world readable then there
will be some users on the system who can't verify your code.

00:41:04.960 --> 00:41:09.480
That's not a problem for things like the Keychain
system because the security daemon runs this route

00:41:09.480 --> 00:41:15.740
and it can pretty much see no matter how much
you try to hide but as time passes on and as more

00:41:15.739 --> 00:41:21.199
and more daemons start using code signing validation
to figure out whether to give you services a lot

00:41:21.199 --> 00:41:26.980
of those don't run as route for security reasons, they
run as some harmless user that doesn't do anything else

00:41:26.980 --> 00:41:30.940
and that harmless user that doesn't do anything
else needs to be able to read your code;

00:41:30.940 --> 00:41:37.389
so my advice would be to make sure
that your code is world readable.

00:41:37.389 --> 00:41:43.779
You don't get any extra security not being world
readable as far as your code is concerned anyway.

00:41:43.780 --> 00:41:53.269
So just to make sure you don't get hassles and weird
bug reports of stuff that only happens to some people

00:41:53.269 --> 00:41:57.449
out there; keep your code world readable.

00:41:57.449 --> 00:42:02.839
What does this all mean about suffer updates you send out?

00:42:02.840 --> 00:42:06.010
Not much actually if you do it right.

00:42:06.010 --> 00:42:10.920
Again I told you; it doesn't matter how your
code gets there as long as what's actually there

00:42:10.920 --> 00:42:15.170
on the disk on the user system is what you signed.

00:42:15.170 --> 00:42:20.559
So if you make a new version of your
program, build your new program,

00:42:20.559 --> 00:42:27.980
sign it and then ship that to the user system somehow;
obviously if you're sending out a drag install

00:42:27.980 --> 00:42:34.340
and you know the idea is that the user just
replaces the program you don't have a problem;

00:42:34.340 --> 00:42:40.850
if you're using the Apple installer or third party installer
for that matter it's not going to be a problem either;

00:42:40.849 --> 00:42:44.900
it will just override the changed parts on the user system.

00:42:44.900 --> 00:42:51.769
If you're using some kind of incremental updater where
you're carefully only shipping the parts that changed,

00:42:51.769 --> 00:42:56.699
that's fine too; just make sure that
what you're comparing in the sense

00:42:56.699 --> 00:43:00.569
of what has changed is the signed old
version of the signed new version.

00:43:00.570 --> 00:43:03.309
Signature obviously will change so
you're shipping the new signature;

00:43:03.309 --> 00:43:09.409
you'll end up with your new program
on the disk, everything will be fine.

00:43:09.409 --> 00:43:14.659
The last entry again, this is sort
of a geeks kind of notice;

00:43:14.659 --> 00:43:20.879
if you replace your main executable
during an update you should be doing it

00:43:20.880 --> 00:43:24.110
by replacing the file, not by overriding it.

00:43:24.110 --> 00:43:28.559
This isn't really...if you're doing
drag installs that'll just be fine;

00:43:28.559 --> 00:43:33.269
if you're using the Apple installer you'll
be just fine because it does the right thing;

00:43:33.269 --> 00:43:38.949
if you're using a third party installer you may want
to give those folks a call and ask them what they do.

00:43:38.949 --> 00:43:48.069
The problem potentially is that if that program is running
at the time you are updating it the system, the kernel,

00:43:48.070 --> 00:43:54.180
may have the old verification information on
that file attached as information in the kernel

00:43:54.179 --> 00:43:59.929
and if you are overriding the file instead of replacing
it, it may still have it when you're done with the updates;

00:43:59.929 --> 00:44:04.919
so you may end applying the old verification
information to the new file and that, you know,

00:44:04.920 --> 00:44:09.690
is not good; just a little implementation note here.

00:44:10.800 --> 00:44:14.080
So what do you sign?

00:44:14.079 --> 00:44:21.259
Well you want to sign all of your code; that obviously
means you're going to sign your beautiful application

00:44:21.260 --> 00:44:30.000
or your nifty tool; if you have a helper tool or a
helper application inside of your application, you know,

00:44:30.000 --> 00:44:36.260
one of those things that the security folks told you
to do because on the little tool does the root things;

00:44:36.260 --> 00:44:42.240
if you have helpers you need to sign the helpers
separately; so that means running code sign more than once;

00:44:42.239 --> 00:44:46.869
once for the bundle itself, once
for the helper inside of the bundle.

00:44:48.820 --> 00:44:57.760
You can sign frameworks and libraries and plug ins
at this point; it works; it's probably a good idea.

00:44:57.760 --> 00:45:06.100
Leopard comes out as a GM will not actually
verify libraries and frameworks and plug ins

00:45:06.099 --> 00:45:11.480
but doing so if your product is one
of those or includes one of those,

00:45:11.480 --> 00:45:16.110
gives you a leg up because eventually
Leopard will start verifying those

00:45:16.110 --> 00:45:21.640
and then if you're already doing it you're fine and if
you're not then you have another deadline to worry about.

00:45:21.639 --> 00:45:28.769
So if it's not too much of a problem
for you just sign those now.

00:45:28.769 --> 00:45:33.590
Anything that is meant to change on the
users system shouldn't be code signed;

00:45:33.590 --> 00:45:40.579
now that includes obviously documents that your application
makes but it also includes things like preference

00:45:40.579 --> 00:45:45.369
and configuration data that the user is meant to change.

00:45:45.369 --> 00:45:50.900
Those things are not code and while
the code sign command will sign just

00:45:50.900 --> 00:45:58.070
about anything it's not meaningful; so don't do that.

00:45:58.070 --> 00:46:00.880
>>So how do you test all of this?

00:46:00.880 --> 00:46:06.050
Well the code sign command is the
Swiss army knife of code signing.

00:46:06.050 --> 00:46:10.570
It can sign but it can also verify; it
can display the contents of a signature;

00:46:10.570 --> 00:46:14.830
it can tell you about hosting chains; it
can do almost anything you want to know.

00:46:14.829 --> 00:46:24.639
So read the man page and knock yourself
out; once you follow your signing process,

00:46:24.639 --> 00:46:30.739
you're mastering process you can just hand run code
sign dash V with your path and it will tell you

00:46:30.739 --> 00:46:37.129
if you accidentally broke the signature because you
did something to your program after you signed it.

00:46:37.130 --> 00:46:45.559
If you don't just want to play around with the command
line tool you can instead use one of the system facilities

00:46:45.559 --> 00:46:49.809
that actually uses code signing to give you access to it.

00:46:49.809 --> 00:46:56.489
Parental controls is the obvious one because parental
controls will simply not let you launch a program unless

00:46:56.489 --> 00:47:01.729
you've approved it and it's code signature is intact; so
make yourself a user account, an administrative account,

00:47:01.730 --> 00:47:09.059
say you want parental controls on it, approve
the use of your program and then launch it.

00:47:09.059 --> 00:47:15.110
If your code signature is somehow damaged parental
controls will not let you; so that's an easy test.

00:47:15.110 --> 00:47:20.640
Obviously if you're making Keychain calls you can
just look for the dialogs and see if you get one

00:47:20.639 --> 00:47:32.289
of those nasty worded dialogs about how the identity of
your program has been modified; that would be a bad sign.

00:47:32.289 --> 00:47:32.420
( Pause )

00:47:32.420 --> 00:47:40.460
I made a small list of things that we at Apple ran into
as we started wrapping this up and I figured I'd tell you

00:47:40.460 --> 00:47:43.769
so you don't have to run into it yourself.

00:47:43.769 --> 00:47:50.280
Xcode makes it really easy to stuff things
into the resources directory of a bundle;

00:47:50.280 --> 00:47:57.970
so easy that people have gotten into the habit of putting
things there that really shouldn't necessarily be there.

00:47:57.969 --> 00:48:05.789
If you find that you have helper tools and
helper applications that you are shipping

00:48:05.789 --> 00:48:11.800
in the resources directory of the main application,
put the elsewhere, they don't belong there.

00:48:11.800 --> 00:48:18.060
There's perfectly nice places for them,
the contents directory is one of them,

00:48:18.059 --> 00:48:23.049
the contents Mac OS directory is another; code
signing really doesn't care where as long as it's not

00:48:23.050 --> 00:48:28.660
in the resources directory because everything in
the resources directory is suppose to be a resource

00:48:28.659 --> 00:48:35.339
and that means that if it changes for any reason,
like for example you're issuing a software update

00:48:35.340 --> 00:48:42.280
for your helper then the main bundle will
look invalid and you don't want to go there.

00:48:42.280 --> 00:48:50.730
Localizations are contents of your resources;
localizations are resources so make sure that all

00:48:50.730 --> 00:48:55.490
of your localizations are in before you sign
because the signature will actually lock

00:48:55.489 --> 00:49:01.009
down what localizations you have and if you
add a localization later it will not be part

00:49:01.010 --> 00:49:05.410
of the signature data and it will look invalid.

00:49:05.409 --> 00:49:13.119
If you farm out localization to some third party
then you pretty much have to get the result back,

00:49:13.119 --> 00:49:15.599
stick it into your bundle and then sign it.

00:49:15.599 --> 00:49:17.730
There's nothing wrong with re-signing your application.

00:49:17.730 --> 00:49:24.019
You'll sign it once with just English and then sign it
again with all kinds of other languages in it but you know,

00:49:24.019 --> 00:49:28.380
don't ship it before you're done with that.

00:49:28.380 --> 00:49:36.940
If your idea of installing your product is having multiple
installation packages...there's nothing intrinsically wrong

00:49:36.940 --> 00:49:40.869
with that as long as you're actually installing them all.

00:49:40.869 --> 00:49:47.599
If you're offering the user the option to install some
of your product but not some other part of your product

00:49:47.599 --> 00:49:55.779
and the user actually ends up doing that, then...if
you actually end up with a half installed product

00:49:55.780 --> 00:50:01.320
on the users hard drive it will probably be violating
the signature because the signature is based on,

00:50:01.320 --> 00:50:04.289
"I know what's here and that file is missing here."

00:50:04.289 --> 00:50:11.139
There is one important special case that
code signing deals with automatically.

00:50:11.139 --> 00:50:16.250
It's alright to strip language resources; so
if you build you program with English, French,

00:50:16.250 --> 00:50:24.789
and German and then you yank the French out after
signing that's okay because well code signing knows

00:50:24.789 --> 00:50:27.579
that people strip language resources all the time.

00:50:27.579 --> 00:50:33.480
That is strictly about stripping them out; adding them
in after the fact is still a violation of the signature.

00:50:35.769 --> 00:50:42.780
There are people who make installers whose post
install script does unpleasant things to the program

00:50:42.780 --> 00:50:46.790
that just got installed like editing
the info P list; don't do that;

00:50:46.789 --> 00:50:51.469
that's a 100 percent dis-qualifier;
your signature will blown immediately.

00:50:51.469 --> 00:50:58.500
There's also people who still think that inside of
the bundle is a really great way to store things

00:50:58.500 --> 00:51:04.409
like preferences; that has never been a good idea and
we've been telling you for about 5 years not to do that

00:51:04.409 --> 00:51:11.839
but now it will actually hurt you; so if you're still
doing that now is an excellent time to stop doing that;

00:51:11.840 --> 00:51:15.420
preferences belong into the library
preferences, not into your bundle.

00:51:15.420 --> 00:51:21.200
Well, if you write self modifying code, I mean the kind

00:51:21.199 --> 00:51:27.159
that actually modifies the executable
on disk, I feel sorry for you.

00:51:27.159 --> 00:51:29.509
( Laughter )

00:51:29.510 --> 00:51:36.470
And here's a few questions that I've gotten more than 3
times so I'll answer them before we go to real questions.

00:51:36.469 --> 00:51:43.469
No, Apple does not decide whether your code is any
good or not, that is not what code signing is about;

00:51:43.469 --> 00:51:50.750
so if you're used to something called code signing
or something similar on other operating systems

00:51:50.750 --> 00:51:54.440
that shall remain nameless this is not like that.

00:51:54.440 --> 00:51:59.710
This is not about Apple approving your
codes; this is not about Apple saying

00:51:59.710 --> 00:52:04.789
that your code is not good unless you
paid for us to sign it; nothing like that.

00:52:04.789 --> 00:52:08.940
Code signing is about a relationship
that you have with the user.

00:52:08.940 --> 00:52:13.820
You promise that this is really your code,
the user says, "Okay, I'll believe you."

00:52:13.820 --> 00:52:16.550
That's what this is about.

00:52:16.550 --> 00:52:21.690
Obviously when we're talking about code that
Apple wrote Apple plays the role of the developer

00:52:21.690 --> 00:52:28.909
and you know Apple says, "We make this and we're proud
of that" but your code is your code and we're just here

00:52:28.909 --> 00:52:33.960
to help facilitate your interaction with the user.

00:52:33.960 --> 00:52:40.449
Mac OS X will run your program just fine if it's unsigned;
there's nothing in the kernel that says that code has

00:52:40.449 --> 00:52:47.339
to be signed to be run as you all have probably have
noticed because you have Betas or early releases

00:52:47.340 --> 00:52:51.260
and your programs didn't mysteriously suddenly
die because you haven't signed them yet.

00:52:51.260 --> 00:52:58.680
As a matter of fact, your program can live a
full life without ever noticing anything bad

00:52:58.679 --> 00:53:05.419
about not being signed unless it calls a system
facility that is interested in code identity

00:53:05.420 --> 00:53:10.849
like the Keychain system or parental
controls or developer access like task

00:53:10.849 --> 00:53:14.380
for (inaudible) or the firewall, you saw all this.

00:53:14.380 --> 00:53:20.789
So the system itself will run your code just
fine and if you lose your identity halfway

00:53:20.789 --> 00:53:25.380
through because your code does something
weird it will still not get killed unless

00:53:25.380 --> 00:53:28.019
that kill flag is on that I told you about.

00:53:28.019 --> 00:53:31.039
( Pause )

00:53:31.039 --> 00:53:39.230
The third one, well, I got that twice...you know, what
"You're telling me I have to go to one of those CAs

00:53:39.230 --> 00:53:43.150
and buy myself a certificate, why
do you make me spend my money?"

00:53:43.150 --> 00:53:51.420
We don't; we have this free tool called a certificate
assistant; it's included with your version of Mac OS X

00:53:51.420 --> 00:53:59.030
which isn't quite free; you can make your own certificates,
your own signing identities and they are just as good

00:53:59.030 --> 00:54:03.650
for the most part as the ones made
by Verisign or Thawte or a long list

00:54:03.650 --> 00:54:06.539
of other companies I've been told not to neglect.

00:54:06.539 --> 00:54:13.409
So the choice is yours; we're not forcing you to spend
any money on these certificates although if you want to,

00:54:13.409 --> 00:54:16.440
if you think it's a good idea go right ahead.

00:54:16.440 --> 00:54:20.750
We're not telling you not to spend
your money on those companies either.

00:54:20.750 --> 00:54:27.429
If you ship codes that suppose to run both
on Tiger and Leopard, that's just fine.

00:54:27.429 --> 00:54:32.440
Tiger has no idea what a code signature is and it
will happily ignore all of this stuff and run it

00:54:32.440 --> 00:54:40.010
like you'd expect it to run it; the only constraint is
that in order to actually sign code the signing step has

00:54:40.010 --> 00:54:44.080
to be done on Leopard because Tiger
doesn't know how to sign code either.

00:54:44.079 --> 00:54:52.029
So, you know, if you want to ship a program that runs on
both systems the easiest way is to build it on Leopard,

00:54:52.030 --> 00:54:56.590
use the Tiger SDK and sign it, works fine.

00:54:58.159 --> 00:55:10.000
Code signing is a really big feature and it's not done
in Leopard but we've concentrated on the infrastructure,

00:55:10.000 --> 00:55:14.699
we've concentrated on getting the big
pieces in but there is a lot of work left

00:55:14.699 --> 00:55:20.079
for the next big cat, whatever we end up calling it.

00:55:20.079 --> 00:55:32.590
We are definitely going to...automatically check more
and more of the pieces of your code like resources,

00:55:32.590 --> 00:55:42.430
like libraries, like plug-ins so in Leopard, as I told you,
libraries aren't automatically checked even if you sign them

00:55:42.429 --> 00:55:49.230
but that will just get added on the way, I can't
tell you when but that will definitely go in.

00:55:49.230 --> 00:55:56.240
We're definitely going to add a lot more code host,
probably a lot of script interpreters, you know,

00:55:56.239 --> 00:56:02.739
little things like the widget runner; widgets
are not supported in Leopard because they're kind

00:56:02.739 --> 00:56:10.949
of complicated little beasties and we're also going
to, well, support more interesting code types;

00:56:10.949 --> 00:56:17.419
kernel extension we actually ended up supporting
in Leopard but there's other pieces of code

00:56:17.420 --> 00:56:23.099
that have their own interesting
features and we are definitely thinking

00:56:23.099 --> 00:56:32.360
about making the various APIs officially, publically
available; if you have a particular preference as to

00:56:32.360 --> 00:56:37.710
which ones you want first let us know, loudly, often.

00:56:38.829 --> 00:56:51.449
There's also some new system features that could really,
God I can't say I use this word, leverage code signing;

00:56:51.449 --> 00:56:55.589
one obvious one that pretty much everybody
comes up with after they hear about this is

00:56:55.590 --> 00:56:59.930
"Does this mean you can just run over the hard drive
and find all the code and see if it's still okay?"

00:56:59.929 --> 00:57:06.739
Yea, that would be a cool facility so
we're definitely thinking about doing that.

00:57:06.739 --> 00:57:14.359
Another obvious application is if your code, if your
application is loading plug-ins wouldn't it be nice

00:57:14.360 --> 00:57:19.160
if the user could say, "These are the kinds
of plug-ins I'm okay with you loading"

00:57:19.159 --> 00:57:25.529
and the code signing requirement machinery
is the perfect tool for expressing that.

00:57:26.639 --> 00:57:33.690
And there's outfits, both parts of Apple and
third parties whose rather lucrative business is

00:57:33.690 --> 00:57:40.539
to ship specialized versions of Mac OS X, you know,
either by adding stuff or by pre-configuring it

00:57:40.539 --> 00:57:46.130
and their customers tend to have a strong
interest in making sure that what they get,

00:57:46.130 --> 00:57:53.390
what they end up with on their hard drive is really
what that pre-configuration service wanted them to have.

00:57:53.389 --> 00:57:58.509
Well code signing can do that; it's
basically born for doing that kind of thing.

00:57:58.510 --> 00:58:02.180
So that's also something that we're
definitely looking into adding.

00:58:02.179 --> 00:58:13.589
Here is the where else to get information; Craig Keithley is
the technology evangelist of security technology evangelist

00:58:13.590 --> 00:58:18.700
so he wants you all to have his e-mail address.

00:58:18.699 --> 00:58:27.259
The man page for code sign is really pretty large and pretty
complete so please do read it even those of you who don't

00:58:27.260 --> 00:58:34.000
like man pages because there is a lot of information in
there that you won't find anywhere else at this point.

00:58:34.000 --> 00:58:43.690
There is a preliminary code signing guide in the reference
library that's on your Beta; that's not on the web site

00:58:43.690 --> 00:58:47.630
yet because, you know, it's not a
released feature but if you use Xcode

00:58:47.630 --> 00:58:54.420
to read the preliminary documentation there
it is, just look for code signing...and

00:58:54.420 --> 00:59:02.519
if you're ever wondering exactly what
the requirements are placed on, you know,

00:59:02.519 --> 00:59:11.699
a code signing identity RFC 2459 describes theY
extended key user extension called code signings and you

00:59:11.699 --> 00:59:15.089
or the geekish friends of yours can figure

00:59:15.090 --> 00:59:19.720
out whether a particular signing identity
will work for code signing or not.

00:59:21.679 --> 00:59:23.719
Summary; they told me to have a summary.

00:59:23.719 --> 00:59:25.539
It's here.

00:59:25.539 --> 00:59:32.529
Really; there's not evading it;
sign your applications, really.

00:59:33.829 --> 00:59:41.799
Your users will be happy particularly if you're using key
chains because a lot of these annoying dialogs used to be,

00:59:41.800 --> 00:59:46.769
"Well the system really doesn't quite know
what's going on so let's ask the user"

00:59:46.769 --> 00:59:51.030
and now the system does know what's going
on and it doesn't have to ask the user.

00:59:51.030 --> 00:59:56.240
I mean it's a win for everybody around, if
you sign your code, which you will, right.
WEBVTT

00:00:16.329 --> 00:00:19.429
>> My name is Derek Clegg.

00:00:19.429 --> 00:00:23.379
I'm an engineer in the graphics
and imaging group and I'm going to talk to you

00:00:23.379 --> 00:00:25.759
about Quartz 2D, how you can use it in your application.

00:00:25.760 --> 00:00:30.670
Give you some introduction to some of
the APIs that are available and then move

00:00:30.670 --> 00:00:35.420
onto some interesting technology directions that you can go.

00:00:35.420 --> 00:00:40.350
So we've going to cover today a little bit about
what Quartz is, sort of the general ideas,

00:00:40.350 --> 00:00:44.070
some of the fundamental concepts in Quartz 2D.

00:00:44.070 --> 00:00:48.829
The basics of what you can use
Quartz 2D to do in your application.

00:00:48.829 --> 00:00:50.429
A lot of you might be familiar with the Cocoa level.

00:00:50.429 --> 00:00:55.090
We're going to drop down into the,
sort of the C APIs underlying.

00:00:55.090 --> 00:00:59.300
Touch on some of the advance capabilities
that are available and then give you some tips

00:00:59.299 --> 00:01:03.209
for getting started and where you can go after this session.

00:01:03.210 --> 00:01:09.390
So Quartz is sort of a big umbrella that a
lot of you may be familiar with from Tiger.

00:01:09.390 --> 00:01:15.040
Includes the windowing system, the basic stuff that manages
your windows for you, all of the 2D drawing of course,

00:01:15.040 --> 00:01:21.610
which I'm going to focus on today, display services,
Image I/O, excuse me, Core Image, Core Video,

00:01:21.609 --> 00:01:23.739
Quartz Composer is part of Quartz and PDF kit.

00:01:23.739 --> 00:01:26.890
So it's a big package of things.

00:01:26.890 --> 00:01:29.030
It's not just simply the Quartz 2D API.

00:01:29.030 --> 00:01:33.670
And in Leopard we've extended it, made
it even better by adding Core Animation

00:01:33.670 --> 00:01:35.820
which is a very cool, very neat frame work.

00:01:35.819 --> 00:01:37.979
There's a talk later today on Core Animation.

00:01:37.980 --> 00:01:39.439
Image Kit also very cool.

00:01:39.439 --> 00:01:42.899
So Quartz is a pretty big package of things.

00:01:42.900 --> 00:01:45.600
But I'm going to focus today specifically on Quartz 2D.

00:01:45.599 --> 00:01:53.109
It's the part of Quartz that is the 2D API
underlying all of the 2D drawing in the system.

00:01:53.109 --> 00:01:59.810
Now some of the features that are key to
Quartz 2D are one: device independence.

00:01:59.810 --> 00:02:05.799
What this means is that when you write your
code using Quartz 2D you don't hav-e to worry

00:02:05.799 --> 00:02:08.810
about what device its going to end up being used on.

00:02:08.810 --> 00:02:13.099
For example, you might be writing code that's
going to end up in a PDF file or draw some stuff

00:02:13.099 --> 00:02:15.750
on the screen of course or to bit map contents.

00:02:15.750 --> 00:02:19.020
All of that is independent of your code.

00:02:19.020 --> 00:02:25.290
We handle that on our side, you write your code once and
because we do the right thing with device independence,

00:02:25.289 --> 00:02:29.319
you don't have think about where
the device, where it's going to end up.

00:02:29.319 --> 00:02:32.810
Another part of, component to that,
because different devices,

00:02:32.810 --> 00:02:37.469
different output media have different
resolutions Quarts 2D is resolution independent.

00:02:37.469 --> 00:02:43.229
So you don't have to worry about whether you're
going to a 92 DPI screen or a 600 DPI printer.

00:02:43.229 --> 00:02:45.479
The resolution is something you don't have to think about.

00:02:45.479 --> 00:02:52.939
You use the same code, ends up in the same
looking good way on each output resolution.

00:02:52.939 --> 00:02:57.479
Of course, high performance, fundamental part of Quartz
2D if we don't have high performance, we don't have much.

00:02:57.479 --> 00:02:59.009
So it's very high performance.

00:02:59.009 --> 00:03:05.169
We spend a lot of effort making sure that it stays
at very, very high performance for your applications.

00:03:05.169 --> 00:03:09.839
An important part of Quartz 2D that you see
all the time and you may not even be aware

00:03:09.840 --> 00:03:12.870
of it consciously, is the anti-aliased graphics and text.

00:03:12.870 --> 00:03:17.890
That anti-aliasing is a technique that keeps the edges
smooth, keeps them from looking blocky, and, and ugly.

00:03:17.889 --> 00:03:21.479
So the smoothing of all the graphics and
text is a fundamental part of Quartz 2D.
-

00:03:21.479 --> 00:03:23.419
You don't need to do anything to get that.

00:03:23.419 --> 00:03:25.709
It's just built in.

00:03:25.710 --> 00:03:30.300
Alpha transparency is also an important part of Quartz 2D.

00:03:30.300 --> 00:03:34.310
Alpha is another word for the opacity,
the transparency of an object,

00:03:34.310 --> 00:03:37.349
how much transparent something is when you draw it.

00:03:37.349 --> 00:03:42.870
So alpha transparency is a fundamental part of Quartz
2D from the beginning which gives us really high quality

00:03:42.870 --> 00:03:46.800
and graphics, very interesting effects,
like the new desktop as you've seen.

00:03:46.800 --> 00:03:51.060
So that's a fundamental part of
Quartz 2D that we have built in.

00:03:51.060 --> 00:03:55.729
And of course we need to be able to draw this
screen, but a lot of people want to print,

00:03:55.729 --> 00:03:59.849
they want to send their PDF files to
their friends and neighbors, presumably.

00:03:59.849 --> 00:04:04.129
So built into Quartz 2D is PDF support for output.

00:04:04.129 --> 00:04:08.530
So again, you don't have to do too much
to get your content written to a PDF file.

00:04:08.530 --> 00:04:10.460
We do all the work for you behind the scenes.

00:04:10.460 --> 00:04:13.770
And that's been part of Quartz 2D from the beg-inning.

00:04:13.770 --> 00:04:15.469
And it's a gateway.

00:04:15.469 --> 00:04:20.170
That once you sort of understand the Quartz 2D
APIs, you can leap from there to other technologies.

00:04:20.170 --> 00:04:26.280
You can use it partly with other things of wholly,
completely write your app on the level of Quartz 2D.

00:04:26.279 --> 00:04:34.419
So it's a nice sort of front door to a lot of
interesting technologies that are part of Mac OS X.

00:04:34.420 --> 00:04:36.390
So where is it in the system?

00:04:36.389 --> 00:04:43.550
For historical reasons, it's also referred to as
core graphics and Image I/O and I may in the course

00:04:43.550 --> 00:04:46.610
of this talk refer to Quartz 2D by either of those names.

00:04:46.610 --> 00:04:48.210
Those are historical.

00:04:48.209 --> 00:04:51.649
It is called Quartz 2D from my point of view.

00:04:51.649 --> 00:04:56.409
So when you want to look for the header files,
you'll want to look in these two frameworks.

00:04:56.410 --> 00:05:01.590
This architectural diagram, this sort of
gives you a flavor of how things fit together.

00:05:01.589 --> 00:05:04.389
All the green parts are part of the
graphics and media technologies.

00:05:04.389 --> 00:05:08.439
So Quartz 2D and core image and core
video are all pretty much peers.

00:05:08.439 --> 00:05:11.339
Build on top of those are core animation, PF kit, Image kit,

00:05:11.339 --> 00:05:14.109
all layered on top of Quarts Open
GL in the graphics hardware.

00:05:14.110 --> 00:05:17.050
Quartz text, I'm not going to talk about
today, but I wanted to mention it.

00:05:17.050 --> 00:05:22.220
It's a very nice framework in Leopard that's integrated
very tightly to Quartz 2D, lets you do- lots of things

00:05:22.220 --> 00:05:26.550
that you wanted to do with text,
but at a Quartz 2D friendly way.

00:05:26.550 --> 00:05:30.379
So it's a really powerful new framework,
and definitely worth checking out.

00:05:31.480 --> 00:05:36.259
So how would you use Quartz 2D in your
world and whatever apps you're writing?

00:05:36.259 --> 00:05:41.930
Of course in Cocoa, a lot of people already
are using the Cocoa drawing classes.

00:05:41.930 --> 00:05:44.250
And so those are perfectly fine for many applications.

00:05:44.250 --> 00:05:48.129
But there are times when you want to drop down
a level, maybe you are worried about performance

00:05:48.129 --> 00:05:52.250
or maybe there's some things in Quartz 2D that
isn't quite expressed in Cocoa the way you want to.

00:05:52.250 --> 00:05:53.639
You just want some finer grain control.

00:05:53.639 --> 00:06:02.459
So it's appropriate in certain circumstances to drop down
into the Quartz 2D C APIs if you, even if you're using Cocoa.

00:06:03.480 --> 00:06:09.040
Of course in Carbon, if you're a Carbon
developer, Quartz 2D is the drawing API you use.

00:06:09.040 --> 00:06:16.230
Because it is a C framework, it's appropriate
for both C and C++ developers.

00:06:16.230 --> 00:06:17.030
Its very light weight.

00:06:17.029 --> 00:06:22.329
So it's definitely something you might want to
use, that you will be using in Carbon development.

00:06:22.329 --> 00:06:26.870
Some people don't realize that Quartz 2D is
not just a window system and its not just sort

00:06:26.870 --> 00:06:28.810
of you know the stuff that appears in the screen.

00:06:28.810 --> 00:06:36.730
You can use Quartz 2D at the tool and script level and sort
of down the command line to build up either complex

00:06:36.730 --> 00:06:41.120
or simplified, simple scripts, maybe dynamic
web page generation, things like that.

00:06:41.120 --> 00:06:43.610
So you don't really need to have
a windows system to use Quartz 2D.

00:06:43.610 --> 00:06:46.800
You can work at the lower level if you want to.

00:06:46.800 --> 00:06:54.069
And in Leopard we have bridge support which lets you do
more scriptable tasks in languages that you may prefer

00:06:54.069 --> 00:06:58.180
to work in but still call the Quartz 2D API.

00:06:58.180 --> 00:07:03.680
So you can use Ruby or Python if you're familiar
with those to do interesting things using Quartz 2D

00:07:03.680 --> 00:07:07.870
without actually having to sort of drop into
writing the C program and all that kind of stuff.

00:07:07.870 --> 00:07:10.639
And there's some samples in this directory that I mentioned,

00:07:10.639 --> 00:07:13.379
are worth check out if that's something
you're interested in.

00:07:14.459 --> 00:07:20.939
So today I'm going to focus on a simple example, sort of give
you a sense of what it would be like to use Quartz 2Ds APIs

00:07:20.939 --> 00:07:24.829
in your app if you were for example
writing something like Pages.

00:07:24.829 --> 00:07:29.359
So Pages, complicated app, does lots of things,
but basically it builds up graphics content.

00:07:29.360 --> 00:07:36.000
I'm going to walk you through some things Pages does
to give, and show you the APIs that correspond to that,

00:07:36.000 --> 00:07:39.899
to give you a flavor of how in your application
you might use some similar type of work.

00:07:39.899 --> 00:07:47.329
And also sort of get you, give you a sense of what
Quartz 2D, what the Quartz 2D API is capabl-e of.

00:07:47.329 --> 00:07:48.969
So we're going to do a really simple thing.

00:07:48.970 --> 00:07:53.130
We're going to try building up a flyer
using just the Quartz 2D APIs alone.

00:07:53.129 --> 00:07:55.209
Of course in Pages this would be really simple

00:07:55.209 --> 00:07:56.949
You just pull those things together.

00:07:56.949 --> 00:08:04.620
We're going to build this up using  Quartz 2D API,
sort of a programmatic flyer generator if you will.

00:08:04.620 --> 00:08:10.160
But first we need to go over some fundamental ideas that
are part of the Quartz 2D model just to get you familiar

00:08:10.160 --> 00:08:16.110
with what's behind the scenes and what you
need to understand to start using Quartz 2D.

00:08:16.110 --> 00:08:22.560
The first important concept is that we build
everything on top of these opaque data types,

00:08:22.560 --> 00:08:27.680
abstract certain ideas in the graphics architectural system.

00:08:27.680 --> 00:08:31.860
And, and a very simple sort of object like style.

00:08:31.860 --> 00:08:37.300
So of course we are C APIs, so we're not, there's not
C++ or Objective-C or anything like that.

00:08:37.299 --> 00:08:42.000
But the model, the concept, the way we
design the architecture is similar in flavor.

00:08:42.000 --> 00:08:49.019
So you will work with the sort of, excuse me, opaque data
types in a similar fashion that you might work with objects

00:08:49.019 --> 00:08:54.699
in Objective-C. And because of that we
have, follow sort of similar models.

00:08:54.700 --> 00:08:57.110
Of course we function based rather than method based.

00:08:57.110 --> 00:08:58.019
But the ideas are the same.

00:08:58.019 --> 00:09:00.629
We have functions which create these objects.

00:09:00.629 --> 00:09:04.669
We have sort of the equivalent of
accessors but you know CG image get width

00:09:04.669 --> 00:09:07.679
for example, get height, for example, things like that.

00:09:07.679 --> 00:09:11.849
Functions which act on objects, CG
contents draw image for example.

00:09:11.850 --> 00:09:12.920
And so on.

00:09:12.919 --> 00:09:19.379
And so we, we try to follow this model of, of sort
of an object like system to give you a flavor of,

00:09:19.379 --> 00:09:23.189
its not really object oriented exactly
but it's the same, same basic model.

00:09:23.190 --> 00:09:26.270
Makes it much simpler to work with.

00:09:26.269 --> 00:09:32.740
And as a consequence, you need to know a little bit
about memory management, so as usual with frameworks

00:09:32.740 --> 00:09:39.009
that follow the core foundation model, which
we do, if you create an object, you own it.

00:09:39.009 --> 00:09:42.289
And once you have created it, when you're
through with it, you must release it,

00:09:42.289 --> 00:09:44.659
because you're the owner, you must release it.

00:09:44.659 --> 00:09:47.469
You can use a standard core foundation function CF release.

00:09:47.470 --> 00:09:51.360
For historical reasons, all of the different
object types have a corresponding release method

00:09:51.360 --> 00:09:53.450
such as CG image release in this case.

00:09:53.450 --> 00:09:56.629
But the key thing is that once you
create something, you have to release it.

00:09:56.629 --> 00:09:58.970
If you don't release it, it'll leak and that's bad.

00:09:58.970 --> 00:10:04.950
On the other hand, if you don't actually own it,
if you didn't create it, you don't release it.

00:10:04.950 --> 00:10:08.320
If you just get it, the model is
sort of you either create or you get.

00:10:08.320 --> 00:10:10.620
If you just get it, you don't release it.

00:10:10.620 --> 00:10:15.870
But sometimes you need to keep things around
even though you didn't create it directly.

00:10:15.870 --> 00:10:19.450
So in that case, again following the
corporate foundation model, you retain it.

00:10:19.450 --> 00:10:21.629
CF retain is the function you use.

00:10:21.629 --> 00:10:25.490
Again for historical reasons there specific
functions for each of the object types.

00:10:25.490 --> 00:10:27.399
So that's sort of the basics of memory management.

00:10:27.399 --> 00:10:32.000
It's exactly like core foundation, those of you who
are familiar with that will be familiar with this.

00:10:32.000 --> 00:10:35.179
It's also very similar to the standard Objective-C model.

00:10:35.179 --> 00:10:37.239
( Period of silence )

00:10:37.240 --> 00:10:44.810
Another concept that's important
to understand at the beginning

00:10:44.809 --> 00:10:47.199
of Quartz 2D is how we work with the coordinates system.

00:10:47.200 --> 00:10:48.980
Of course we're a graphic system.

00:10:48.980 --> 00:10:52.060
So you're going to be drawing things
into some coordinates system.

00:10:52.059 --> 00:10:58.839
And the question is how do you sort of, how do
we model the coordinate system for you to draw.

00:10:58.840 --> 00:11:03.899
The key is that we have a flexible model
where by you change the coordinates system.

00:11:03.899 --> 00:11:05.189
You don't change your objects.

00:11:05.190 --> 00:11:08.280
This is sort of again in keeping with
the idea of object oriented programming.

00:11:08.279 --> 00:11:15.129
The model that we use as our coordinate system changes
in order to change the orientation or scale factor

00:11:15.129 --> 00:11:17.360
in sort of an object, not the object itself.

00:11:17.360 --> 00:11:24.289
And there are functions CG conduct scale, CTM,
rotate, translate, that modify the coordinate system,

00:11:24.289 --> 00:11:27.360
CTM in this case stands for coordinate
transformation matrix.

00:11:27.360 --> 00:11:31.560
And that lets you do really powerful effects
without having to sort of incur the costs

00:11:31.559 --> 00:11:35.339
of creating new objects or doing the work yourself.

00:11:35.340 --> 00:11:41.769
So for example, imagine we have our coordinate system,
the standard one that you get for you when you start

00:11:41.769 --> 00:11:47.949
up using Quartz 2D and here we have an image that's drawn
at certain coordinates and they think, oh but that's nice

00:11:47.950 --> 00:11:49.730
but we really want to scale it down, we want to shrink it.

00:11:49.730 --> 00:11:55.240
Now in some graphic systems, you would have to create a
new image, scale it down yourself and then draw the result.

00:11:55.240 --> 00:12:00.610
Using Quartz 2D, instead the model
is you modify the coordinates system.

00:12:00.610 --> 00:12:03.409
You shrink the coordinates system
and then you draw your same image.

00:12:03.409 --> 00:12:09.199
And on our side, we do the hard work of scaling the
image down, getting to the right location, anti aliasing

00:12:09.200 --> 00:12:15.060
or sampling so that it looks beautiful and you get sort of
the nice result without doing too much work on your part.

00:12:15.059 --> 00:12:23.669
Similarly to rotate, rather than you doing anything directly
to the image, instead you rotate the coordinate system.

00:12:23.669 --> 00:12:28.209
Then you draw your image and we'll
do the work to draw it rotated.

00:12:28.210 --> 00:12:32.030
And there's another little tricky
thing you can do for flipping.

00:12:32.029 --> 00:12:39.049
It turns out that corresponds to a translate
over and then a scale by negative one to flip.

00:12:39.049 --> 00:12:40.969
And you know I'm going through this pretty fast,

00:12:40.970 --> 00:12:44.560
so I don't expect you to necessarily you know
understand all the mathematics behind all this,

00:12:44.559 --> 00:12:48.839
but this is something that as you learn
about Quartz 2D and as you work with it,

00:12:48.840 --> 00:12:52.810
the coordinate system transformations
will become more familiar to you

00:12:52.809 --> 00:12:57.019
and they're also something that's pretty important
to understand how they play into the whole game.

00:12:57.019 --> 00:13:03.360
And the key thing is that you modify the coordinate
system to change your objects, not the objects themselves.

00:13:03.360 --> 00:13:09.139
So as an example of that, a specific one, here we
image let's suppose somebody you know I want you

00:13:09.139 --> 00:13:11.259
to draw two rectangles, a blue one and a green one.

00:13:11.259 --> 00:13:14.470
The blue one is at 0, 0 width and height is 100 and 100.

00:13:14.470 --> 00:13:18.290
And the green one is twice as big at a different location.

00:13:18.289 --> 00:13:24.289
You could, of course, and a lot of systems assume you would,
create two different rectangles and draw them in two points.

00:13:24.289 --> 00:13:30.000
The nice, and you know I realize rectangles are trivial,
but image this is a PDF page or something more complex.

00:13:30.000 --> 00:13:37.210
The nice thing in Quartz 2D is that what you do instead
is you move your coordinate system over to a new location,

00:13:37.210 --> 00:13:39.320
the location you want to draw your rectangle.

00:13:39.320 --> 00:13:42.780
You scale up by a factor of 2 and
then you draw the same rectangle.

00:13:42.779 --> 00:13:47.740
Because our coordinate system is changed, we're now,
we now draw a larger rectangle at a new location.

00:13:47.740 --> 00:13:54.629
So that's a key idea in the Quartz 2D model, that
you work with a coordinate system, not the object.

00:13:54.629 --> 00:13:56.929
( Period of silence )

00:13:56.929 --> 00:14:03.429
So those are sort of some high level abstraction ideas.

00:14:03.429 --> 00:14:08.539
Let's talk about the actual primitives that
you have available to you in Quartz 2D to draw.

00:14:08.539 --> 00:14:11.279
Quartz paths, pretty fundamental, very important.

00:14:11.279 --> 00:14:15.289
We have dotted lines, you have open
curves, you have something complex,

00:14:15.289 --> 00:14:17.959
a complex path like the state of California there.

00:14:17.960 --> 00:14:24.129
The little circular rings are actually two paths,
two circles with the interior fill, filled.

00:14:24.129 --> 00:14:25.879
The two stars show different draw angles.

00:14:25.879 --> 00:14:29.860
A number of ways to work with paths in Quartz 2D.
-

00:14:29.860 --> 00:14:36.060
Images, of course through the Image I/O
framework, we have full support for JPEG, PNG

00:14:36.059 --> 00:14:41.109
to pretty much any image format
that's available in the world almost.

00:14:41.110 --> 00:14:46.700
And as you saw with a little animation we also support
progressive JPEG so you sort of can pull in data

00:14:46.700 --> 00:14:51.710
from some external source and display it incrementally.

00:14:51.710 --> 00:14:56.750
PDF support, been built in from the
beginning, part of Quartz 2D, very fundame-ntal.

00:14:56.750 --> 00:15:00.750
Any PDF file that you have available
we can draw the pages from, display it.

00:15:00.750 --> 00:15:05.710
You can use those in your application as either
like little thumbnails or display as a whole page.

00:15:05.710 --> 00:15:09.820
Could be really useful for built in
artwork that you want to be scalable rather

00:15:09.820 --> 00:15:12.250
than having everything sort of converted to an image.

00:15:12.250 --> 00:15:18.580
You can start out with a PDF and then the things that are
naturally scalable, such as text and line art will remain so

00:15:18.580 --> 00:15:24.060
and things that are you know maybe more device depend,
resolution dependent such as images will scale up nicely.

00:15:24.059 --> 00:15:32.179
But you'll keep the, sort of preserved in the resolution
in an independent way.

00:15:32.179 --> 00:15:35.389
So it's really useful and we starting to use more

00:15:35.389 --> 00:15:40.419
and more PDF throughout the system in
terms of just our artwork and our UI.

00:15:40.419 --> 00:15:42.110
Text is another part of Quartz 2D.
-

00:15:42.110 --> 00:15:46.210
As I mentioned Core Text is the right
way to go about using Quartz 2D in text.

00:15:46.210 --> 00:15:50.190
It's a really powerful framework and you
can do lots of these cool special effects.

00:15:52.509 --> 00:15:54.840
Excuse me.

00:15:54.840 --> 00:15:58.450
So now those are some of the objects
that you have to work with.

00:15:58.450 --> 00:16:07.410
And the part that, that's important about the Quartz 2D
basic drawing model is what's called the painters model,

00:16:07.409 --> 00:16:08.990
or the painters algorithm.

00:16:08.990 --> 00:16:12.090
And this is just the way we express content in Quartz 2D.

00:16:12.090 --> 00:16:12.870
It's very simple.

00:16:12.870 --> 00:16:18.110
The idea is that just like with a painter, as
you put content down, one on top of another,

00:16:18.110 --> 00:16:21.990
only the things that are not obscured
are going to be visible.

00:16:21.990 --> 00:16:26.080
So image we start out with a flight
background and we draw a gradient on top of it.

00:16:26.080 --> 00:16:27.110
Pretty simple.

00:16:27.110 --> 00:16:29.919
Now we draw our image on top of that.

00:16:29.919 --> 00:16:32.000
We draw out little logo on top of that.

00:16:32.000 --> 00:16:33.470
We draw our PDF file on top of that.

00:16:33.470 --> 00:16:35.759
So you see we're sort of building up back to the front.

00:16:35.759 --> 00:16:40.110
And that back to front build of
content is the way Quartz 2D works.

00:16:40.110 --> 00:16:46.840
And we do a lot of tricks and handle things very efficiently
where we can just sort of make that as fast as possible.

00:16:46.840 --> 00:16:50.759
But that's sort of the general idea of you started from
the back and you sort of move up to build your content.

00:16:50.759 --> 00:16:52.769
And those of you who are used to Cocoa programming,

00:16:52.769 --> 00:16:59.539
programming and so on will understand
this exactly the same model.

00:16:59.539 --> 00:17:05.659
Another piece as I mentioned earlier, that's important about
Quartz 2D to understand is alpha transparency,

00:17:05.660 --> 00:17:08.580
the amount of, of transparency an object has.

00:17:08.579 --> 00:17:12.299
This is built into the Quartz model.

00:17:12.299 --> 00:17:16.930
In this case, we have an alpha for every color.

00:17:16.930 --> 00:17:23.670
So a color has not just the red, green, blue components
but also the amount of transparency, how transparent it is.

00:17:23.670 --> 00:17:28.380
So here we have our little cookie and we're
going to draw a blue rectangle with Alpha one.

00:17:28.380 --> 00:17:30.900
That is fully opaque.

00:17:30.900 --> 00:17:35.670
Well, not surprisingly, the cookie is
you know obscured by our blue rectangle.

00:17:35.670 --> 00:17:40.230
Now we take the same cookie, we're going to
turn down the alpha on the blue rectangle

00:17:40.230 --> 00:17:43.460
so the alpha is now point 5, that
is its 50 percent transparent.

00:17:43.460 --> 00:17:47.829
When we draw it of course, the cookie
shows up with the little blue on top of it.

00:17:47.829 --> 00:17:49.139
You can still see through.

00:17:49.140 --> 00:17:57.960
And then alpha zero, that is fully transparent, no opacity
at all, we're going to draw our blue rectangle, oh there it is.

00:17:57.960 --> 00:18:01.029
It turns out you can't really see it
because of course its transparent.

00:18:01.029 --> 00:18:02.319
And that's alpha zero.

00:18:02.319 --> 00:18:09.339
So that, the idea of alpha as part of the
color is a fundamental part of Quartz 2D.

00:18:09.339 --> 00:18:14.369
In addition though, there's also alpha
as part of the objects window drawn.

00:18:14.369 --> 00:18:18.519
So in the same way we can sort of change the coordinates
transformation matrix or change the coordinate system,

00:18:18.519 --> 00:18:21.460
we can also change the alpha when we composite.

00:18:21.460 --> 00:18:27.960
So that things become more or less transparent depending
upon what the global, we call it global alpha is.

00:18:27.960 --> 00:18:33.579
So here we have our white rectangle and we're
going to draw a cookie and the cookie is, has when we,

00:18:33.579 --> 00:18:35.509
when we draw it we set the global alpha to one

00:18:35.509 --> 00:18:40.549
that is everything that's drawn is fully
opaque, relative to the, to the object itself.

00:18:40.549 --> 00:18:42.639
So the cookie shows up fully opaque.

00:18:42.640 --> 00:18:45.100
Now we do the same thing again, but
we're going to turn the global alpha

00:18:45.099 --> 00:18:48.289
down to point 5, that is 50 percent transparent.

00:18:48.289 --> 00:18:50.009
And now the cookie is sort of fading out.

00:18:50.009 --> 00:18:55.500
So we decrease the alpha, we decrease the
transparency and now the cookie is less visible.

00:18:55.500 --> 00:19:01.339
And then again, guess what we're going to do, we're
going to draw the cookie again, global alpha is zero.

00:19:01.339 --> 00:19:06.129
As you see, or rather as you don't see, the cookie
doesn't show up because it's fully transparent.

00:19:06.130 --> 00:19:09.770
So this is in the same way that we,
it sort of follows the same mode.

00:19:09.769 --> 00:19:12.930
We don't change the object to get this effect.

00:19:12.930 --> 00:19:16.830
We don't sort of choose our image and then have
to add an alpha mask and do all sorts of things.

00:19:16.829 --> 00:19:23.480
Instead we just change the global alpha and
that changes the drawing when we draw it.

00:19:23.480 --> 00:19:29.549
Another part that's important to Quartz 2D is our built
in color management that lets us preserve the fidelity

00:19:29.549 --> 00:19:32.980
of colors, depending upon, independent of the output device.

00:19:32.980 --> 00:19:38.250
So our input device, so you might have a high quality
camera that takes pictures and you get it printed

00:19:38.250 --> 00:19:43.579
on some special printer and you want the thing you
saw when you took the picture to look exactly the same

00:19:43.579 --> 00:19:45.809
as the thing that gets printed on the output.

00:19:45.809 --> 00:19:54.129
And the key part is that with built in color management,
that's part of Quartz 2D, we can pres-erve the colors across,

00:19:54.130 --> 00:20:00.310
across input to output device so that we don't have
sort of colors shifting and getting different results.

00:20:00.309 --> 00:20:03.169
As you can see here, we have something
that's not color managed.

00:20:03.170 --> 00:20:04.910
Things are a little, color is a little off.

00:20:04.910 --> 00:20:07.550
When it is color managed, the colors stay true.

00:20:07.549 --> 00:20:12.049
( Period of silence )

00:20:12.049 --> 00:20:19.079
So that's sort of the
concepts behind the various objects.

00:20:19.079 --> 00:20:27.069
A very important object that we have as well is the,
is something that abstracts the drawing destination.

00:20:27.069 --> 00:20:30.429
As I said earlier, we're device independent.

00:20:30.430 --> 00:20:36.380
What that means is that we, when we go to different output
devices such as here is illustrated you know like a window

00:20:36.380 --> 00:20:44.260
or maybe a PDF file, your printer, bit map, we
want to be able to have something that represents

00:20:44.259 --> 00:20:50.670
that drawing destination that's sort of an
abstraction of that idea without necessarily tying this

00:20:50.670 --> 00:20:55.420
to specific behavior of any one of those destinations.

00:20:55.420 --> 00:21:01.660
So the way we express that in the Quartz
2D API is with the CG context ref.

00:21:01.660 --> 00:21:04.590
The core, CG, core graphics context ref.

00:21:04.589 --> 00:21:07.099
It's an abstraction of the destination.

00:21:07.099 --> 00:21:14.199
So when you write your code and use, use a Quartz 2D
APIs, you don't need to think about where you're going,

00:21:14.200 --> 00:21:16.220
where the, where the result is going to end up.

00:21:16.220 --> 00:21:22.440
You just write the same code and then we'll do the work
on the back end on our side to translate what you write

00:21:22.440 --> 00:21:26.789
to either say for example PDF file or maybe
a bit map or maybe something on screen.

00:21:26.789 --> 00:21:30.950
So as, as I mentioned here, there's a
number of different flavors of the context.

00:21:30.950 --> 00:21:33.130
And the great thing is you don't
have to think about it too much.

00:21:33.130 --> 00:21:37.300
You, once it's created for you, or once you're
created it yourself, you just use the same API

00:21:37.299 --> 00:21:42.180
and you get the same results on
all the different destinations.

00:21:42.180 --> 00:21:44.820
So how do you get one of these
things to work with it directly

00:21:44.819 --> 00:21:47.659
if you're wanting to say use Quartz 2D API yourself?

00:21:47.660 --> 00:21:55.440
If you're using Cocoa, there's the standard
model of course is that you have an NS view.

00:21:55.440 --> 00:21:56.940
And you have a draw rect method.

00:21:56.940 --> 00:21:58.740
And in the draw rect method you do your drawing.

00:21:58.740 --> 00:22:02.700
So that's the natural place to get the
core graphics context to work with.

00:22:02.700 --> 00:22:08.259
So in your draw rect you do this little sequence
of operations and you get a contents of, the,

00:22:08.259 --> 00:22:11.089
the names are a little confusing for historical reasons.

00:22:11.089 --> 00:22:19.119
Its, it's a little baroque but basically
you start out by getting a NS graphic context,

00:22:19.119 --> 00:22:22.089
which is not the same thing as a core, a CG context.

00:22:22.089 --> 00:22:27.439
From that NS Graphics context, which is a Cocoa
concept you get the so-called graphics port.

00:22:27.440 --> 00:22:29.450
Now that is your CG context ref.

00:22:29.450 --> 00:22:33.049
And from that point you can tell
do all your Quartz 2D drawing.

00:22:33.049 --> 00:22:36.720
So you sort of follow the same little
sequence and you get your context every time.

00:22:36.720 --> 00:22:43.400
On the other hand, if you're using Carbon, you'll
typically have an event handler on the HI view and your,

00:22:43.400 --> 00:22:48.220
your drawing in the event handler, you
use this nice little piece of code,

00:22:48.220 --> 00:22:51.029
just copy it and it will give you back a context.

00:22:51.029 --> 00:22:56.670
So that's an important way to get the, that's a way
to get both the context in from Carbon and Cocoa.

00:22:57.900 --> 00:23:02.960
So we, the context abstracts the
drawing destination and you can think

00:23:02.960 --> 00:23:06.470
about you know you don't have to
think about where you're ending up.

00:23:06.470 --> 00:23:08.950
PDF or on screen or whatever.

00:23:08.950 --> 00:23:16.559
And inside the context is also a set of state
that is maintained for you when you're drawing.

00:23:16.559 --> 00:23:23.169
So some graphics models require you to set
the state say in the call to draw a line,

00:23:23.170 --> 00:23:25.700
that's when you have to well draw
this line but also make sure it's red

00:23:25.700 --> 00:23:29.059
and make sure it's this thick and
make sure it's dotted and so on.

00:23:29.059 --> 00:23:34.490
So the Quartz model is a little different in that there's
a persistent state that's part of the context that hangs

00:23:34.490 --> 00:23:39.059
around and is maintained for you so
you don't have to always be changing

00:23:39.059 --> 00:23:41.200
or setting the state every time you do a drawing operation.

00:23:41.200 --> 00:23:43.769
You can set it once and then draw a number of things.

00:23:43.769 --> 00:23:50.379
Some of the things that are part of the state, the
stroke color for a line, fill color, the interior fill.

00:23:50.380 --> 00:23:53.660
And of course the coordinates, coordinate
transformation matrix that I mentioned before.

00:23:53.660 --> 00:23:57.170
How the coordinate system looks when you draw to it.

00:23:57.170 --> 00:24:01.800
Things like the line width that's on parameters
that are part of the stroking operation,

00:24:01.799 --> 00:24:06.230
global alpha I mentioned earlier, shadows, blend modes
a whole bunch of things are part of the graphics state.

00:24:06.230 --> 00:24:09.400
So all of those are maintained
for you in the context itself.

00:24:09.400 --> 00:24:15.000
So that's, that's a nice collection
of things for, for you to work with.

00:24:15.000 --> 00:24:21.319
the problem though is that sometimes you want to change
the state and then get back to where it was before

00:24:21.319 --> 00:24:27.210
without necessarily sort of having to save all the, these
parameters yourself and remember what they were and so on.

00:24:27.210 --> 00:24:31.039
And the model that we use in core graphics
is what's known as a graphics stack.

00:24:31.039 --> 00:24:37.119
So we take our graphics state and we have a stack of
states and you can preserve the state and restore the state

00:24:37.119 --> 00:24:44.359
in order to sort of temporarily modify the context
state and then get it back to what it was before.

00:24:44.359 --> 00:24:50.159
So in our case, here we have an example maybe of the simple
state you can imagine, just a stroke color and fill color

00:24:50.160 --> 00:24:52.090
and of course there's a whole bunch
of parameters other than that.

00:24:52.089 --> 00:24:53.740
But let's just look at these two.

00:24:53.740 --> 00:25:00.099
And we imagine that we want to change the fill color, not
really worrying about what it was and then fill something

00:25:00.099 --> 00:25:03.569
and then we're going to return back
to the state we were before.

00:25:03.569 --> 00:25:08.799
So the idea that, the API that you
use is CG context, save G state.

00:25:08.799 --> 00:25:14.769
That's basically is going to save the graphic state
for you and push a copy of it on the graphics stack

00:25:14.769 --> 00:25:19.849
that you can modify freely and then we're
going to restore it back when we are done.

00:25:19.849 --> 00:25:22.730
So we've made a copy of the graphic
state and push it on the stack.

00:25:22.730 --> 00:25:24.420
And now we're going to change the fill color.

00:25:24.420 --> 00:25:25.930
Let's say we just change it to green.

00:25:25.930 --> 00:25:28.250
That's nice, change it to green.

00:25:28.250 --> 00:25:31.730
And notice that we're just changing the current
state, not the stuff that's saved on the stack.

00:25:31.730 --> 00:25:35.140
We do our, you know whatever we want to draw in green color.

00:25:35.140 --> 00:25:39.800
And then we're done and we want to
return back to the state we had before.

00:25:39.799 --> 00:25:46.480
So you kind of restore G state, we'll take the current state
and pop it off and it restores back to the saved state.

00:25:46.480 --> 00:25:48.289
So we go back to the previous state.

00:25:48.289 --> 00:25:54.430
So this is actually a really powerful model in that you can
just change the parameters you care about and return back

00:25:54.430 --> 00:25:58.080
to where you were before without having to
sort of keep track of everything yourself.

00:25:58.079 --> 00:26:02.319
We do a lot of the work on our side
to keep track of things for you.

00:26:02.319 --> 00:26:10.500
This is something that those of you who use Cocoa have had
happen for you implicitly for since the beginning of Cocoa.

00:26:10.500 --> 00:26:14.269
In your draw rect method, right
before the draw rect method is called,

00:26:14.269 --> 00:26:17.950
Cocoa with call this save G state to save the graphic state.

00:26:17.950 --> 00:26:20.900
In your draw rect method, you can
change things all you want as you know.

00:26:20.900 --> 00:26:23.040
And it doesn't affect any other drawing in the system.

00:26:23.039 --> 00:26:24.569
And you may have wondered, well why is that?

00:26:24.569 --> 00:26:27.980
Well because they save the G state right
before they call your draw rect method.

00:26:27.980 --> 00:26:30.690
When you return to your draw rect
method, they restore the G state.

00:26:30.690 --> 00:26:34.700
So any changes you made are basically
isolated only to your draw rect method.

00:26:34.700 --> 00:26:40.370
So that's a really powerful simple model that makes
things a lot simpler for you when you actually do,

00:26:40.369 --> 00:26:42.439
it's rather than having to do state management.

00:26:42.440 --> 00:26:45.539
( Period of silence )

00:26:45.539 --> 00:26:47.960
So this is all fine.

00:26:47.960 --> 00:26:51.789
We've gotten a lot of ideas down,
but we haven't done anything.

00:26:51.789 --> 00:26:54.539
So we need, lets start now just to actually start drawing.

00:26:54.539 --> 00:26:59.980
And we do the simplest thing we can do which
is just filling and stroking a rectangle.

00:26:59.980 --> 00:27:04.289
It's about, you can't do that on a graphic
system, you might as well throw it out.

00:27:04.289 --> 00:27:09.970
So to do this again, we start out, we have this idea of
this abstraction of the drawing destination, the context.

00:27:09.970 --> 00:27:17.089
And we have a little structure called the CG rect that
represents a rectangle, it's just four point values.

00:27:17.089 --> 00:27:22.909
And there are some convenience functions that
let you fill and stroke a rectangle very simply.

00:27:22.910 --> 00:27:25.680
And as a bonus there's also something
that lets you fill and stroke an ellipse.

00:27:25.680 --> 00:27:28.150
That's pretty easy to do either
the erect or the ellipse case.

00:27:28.150 --> 00:27:31.840
We'll just talk about the rectangle for the moment.

00:27:31.839 --> 00:27:39.109
And I'll just walk you through some code that
takes a context and fills a rectangle with a green,

00:27:39.109 --> 00:27:42.069
a blue color and then strokes its
outline with the green color.

00:27:42.069 --> 00:27:48.569
This is a pretty simple function that gives
you a flavor of how Quartz 2D API works.

00:27:48.569 --> 00:27:52.849
So we first create our rectangle, this CG
rect may call to create this structure.

00:27:52.849 --> 00:27:55.189
The first two parameters are the origin, 10, 10.

00:27:55.190 --> 00:27:58.940
The last two parameters are the width and the height.

00:27:58.940 --> 00:28:01.850
And once we've created a rectangle
we're going to fill it with blue.

00:28:01.849 --> 00:28:04.129
And let's imagine, I'll talk about this in a moment

00:28:04.130 --> 00:28:07.420
that there's some magic function called my
get blue color that returns a blue color.

00:28:07.420 --> 00:28:11.300
So we're going to set the fill color and the context to blue.

00:28:11.299 --> 00:28:12.960
And then we're going to fill a rectangle.

00:28:12.960 --> 00:28:14.350
So that's pretty much all there is to it.

00:28:14.349 --> 00:28:19.949
What we have at that point suddenly is a
rectangle appears at the right location

00:28:19.950 --> 00:28:24.029
with the right color and we're very happy.

00:28:24.029 --> 00:28:28.460
Now we're going to stroke the rectangle
with an outline of green.

00:28:28.460 --> 00:28:32.370
So in the same way we imagined
as a function my get green color,

00:28:32.369 --> 00:28:36.500
and that's going to return a green
color that we set as a stroke color.

00:28:36.500 --> 00:28:38.710
And now we're going to stroke the rectangle.

00:28:38.710 --> 00:28:42.569
In this case we're going to stroke it,
but we're also going to pass in the width.

00:28:42.569 --> 00:28:46.450
The, the width of the line that we want to
stroke it with and we call this function,

00:28:46.450 --> 00:28:50.950
we get a rectangle that's stroked
with a green, green outline.

00:28:50.950 --> 00:28:59.049
The part that's important to note about Quartz 2D
model is its- stroking is on both sides of the path.

00:28:59.049 --> 00:29:02.180
So when I say I want to stroke width
to be 10, the total width is 10,

00:29:02.180 --> 00:29:05.049
but I really get five on one side, five on the other side.

00:29:05.049 --> 00:29:10.769
So the model of having the stroke appear on both
sides is pretty fundamental and it's important

00:29:10.769 --> 00:29:14.079
to note that this is the way we do things.

00:29:14.079 --> 00:29:18.480
Now I'm going to do the same thing but I'm just
going to change the order of the operations.

00:29:18.480 --> 00:29:20.339
And this is going to illustrate a couple of ideas.

00:29:20.339 --> 00:29:26.079
One is the idea of saving the graphic state and if
there is a graphic state that keeps state for you,

00:29:26.079 --> 00:29:31.759
there's also the idea of translating or moving the
coordinate system and then sort of showing you also a bit

00:29:31.759 --> 00:29:35.819
of the idea of painters model, how the
order of operations is fundamental.

00:29:35.819 --> 00:29:37.169
So I begin by saving the graphic state.

00:29:37.170 --> 00:29:42.120
That's going to save everything so we don't change,
so we can preserve our, our state and return back.

00:29:42.119 --> 00:29:44.059
Now I'm going to translate the, the CTM.

00:29:44.059 --> 00:29:47.559
That means we're going to translate
the coordinate system over by 200.

00:29:47.559 --> 00:29:51.039
So we've just moved our origin
over by 200 in the X direction.

00:29:51.039 --> 00:29:54.269
And now we're going to do the same
operations the other way around.

00:29:54.269 --> 00:29:57.789
We're first going to stroke the rectangle,
same way, with the green color.

00:29:57.789 --> 00:30:02.099
Now notice that because we have a graphic
state stack, we don't reset the stroke color.

00:30:02.099 --> 00:30:03.649
The stroke color hasn't changed.

00:30:03.650 --> 00:30:04.759
It's still green.

00:30:04.759 --> 00:30:07.180
So we don't set the color to green again.

00:30:07.180 --> 00:30:08.720
We just know its going to be green.

00:30:08.720 --> 00:30:09.839
So now we stroke the rectangle.

00:30:09.839 --> 00:30:12.149
We get a green stroked rectangle.

00:30:12.150 --> 00:30:13.550
And now we're going to fill the rectangle.

00:30:13.549 --> 00:30:15.220
And its color is going to be blue.

00:30:15.220 --> 00:30:21.250
Why? Because the part of the graphics state and we haven't
the fill color so it's the same as what we set it before.

00:30:21.250 --> 00:30:23.180
So it's going to be blue.

00:30:23.180 --> 00:30:26.299
And now you see we draw the blue
rectangle on top of the green stroke.

00:30:26.299 --> 00:30:32.049
And you can see how the stroke is on the inside and
on the outside because the line is a little thinner.

00:30:32.049 --> 00:30:36.269
And also because the painters model, we're
on top of the, the thing we've drawn before.

00:30:36.269 --> 00:30:38.509
So we have a blue rectangle occurring on top.

00:30:38.509 --> 00:30:41.559
So it's visually going to be different.

00:30:41.559 --> 00:30:44.509
And then finally we're going to restore the graphic state.

00:30:44.509 --> 00:30:49.200
And notice that we're not undoing our change
to the coordinate transformation matrix.

00:30:49.200 --> 00:30:52.090
That is going to automatically happen
since its part of the graphics state.

00:30:52.089 --> 00:30:58.199
It's going to automatically undo in the sense because
we're restoring the graphic state to what it was before.

00:30:58.200 --> 00:31:01.130
So we know have the origin moved back.

00:31:01.130 --> 00:31:04.790
And you can go on to draw as many rectangles as you'd like.

00:31:05.910 --> 00:31:06.570
So that's fine.

00:31:06.569 --> 00:31:08.939
That's a, that's a very simple case.

00:31:08.940 --> 00:31:10.549
Just a rectangle.

00:31:10.549 --> 00:31:11.930
( Period of silence )

00:31:11.930 --> 00:31:21.920
It's much more interesting to start drawing an image
and how would go about doing that in Quartz 2D?

00:31:21.920 --> 00:31:29.110
Because we need to get our flyer because our boss is
demanding the flyer soon so we better get it going.

00:31:29.109 --> 00:31:40.009
So there's a number of functions that work with images that
workhorses that are very basic that you'll want to use most

00:31:40.009 --> 00:31:48.150
of the time are 3D functions t=hat let you
create an image from a file and then draw it.

00:31:48.150 --> 00:31:50.340
There's an image source, create with URL.

00:31:50.339 --> 00:31:55.559
An image source is an abstraction of the data on disk.

00:31:55.559 --> 00:31:57.599
It's not actually an abstraction of the idea of an image.

00:31:57.599 --> 00:32:00.730
It's the abstraction of the data on disk.

00:32:00.730 --> 00:32:03.240
Once you have an image source, you can create an image.

00:32:03.240 --> 00:32:07.480
So a CG image is the abstraction of just the
date, of the image itself, the image's data.

00:32:07.480 --> 00:32:12.960
You can create an image from an image
source and then once you have image

00:32:12.960 --> 00:32:17.180
and you have a context, you can
draw the image into the context.

00:32:17.180 --> 00:32:20.769
So here's a bit of code that illustrates those ideas.

00:32:20.769 --> 00:32:26.440
Again, imagine that we have a context that's been
created for us or that we're in a draw rect routine.

00:32:26.440 --> 00:32:32.870
And someone's handed us a URL that probably references an
image file on disk or maybe someplace else in the system.

00:32:32.869 --> 00:32:36.389
And we're going to create an image and draw it from that URL.

00:32:36.390 --> 00:32:40.490
So the first thing we do is create
an image source from the URL.

00:32:40.490 --> 00:32:43.900
And you'll notice I don't do any
error checking or anything like that.

00:32:43.900 --> 00:32:47.620
That's because otherwise you'd be really
bored with all the code on the screen

00:32:47.619 --> 00:32:49.489
You'll normally need to check all that.

00:32:49.490 --> 00:32:52.930
This is very optimistic programming where we
believe that everything succeeds all the time.

00:32:52.930 --> 00:32:56.100
So there is some error checking I've left out.

00:32:56.099 --> 00:32:58.139
In this case, we create an image source.

00:32:58.140 --> 00:33:02.770
And that is going to represent the file on disk.

00:33:02.769 --> 00:33:07.190
Next you create an image from the image source.

00:33:07.190 --> 00:33:11.529
It turns out that although most image
file formats only contain a single image.

00:33:11.529 --> 00:33:15.829
Some can contain multiple images
so that zero after the image source

00:33:15.829 --> 00:33:18.939
in this call is the index of the image in the image source.

00:33:18.940 --> 00:33:21.460
And of course this function is to
get the number of images and so on.

00:33:21.460 --> 00:33:23.160
In this case we're going to get the
first one, the zero item.

00:33:23.160 --> 00:33:29.910
The standard way and once we have the
image, we, we release the image source.

00:33:29.910 --> 00:33:31.650
Because we created it, we must release it.

00:33:31.650 --> 00:33:34.300
So we release the image source.

00:33:34.299 --> 00:33:37.629
And now we want to draw the image into our context.

00:33:37.630 --> 00:33:43.240
So the CG context image draw takes
a rectangle and when you specify

00:33:43.240 --> 00:33:48.240
that rectangle what Quartz will do is
scale your image into that rectangle.

00:33:48.240 --> 00:33:53.740
In our case, we want to draw an image in a certain location,
but we want it to be as big as the image itself is.

00:33:53.740 --> 00:33:55.039
We don't want to sort of shrink down or anything.

00:33:55.039 --> 00:33:57.119
We want to make sure it's the same size as the image.

00:33:57.119 --> 00:33:59.939
So we use a sort of pseudo accessor
functions to access these,

00:33:59.940 --> 00:34:03.799
these functions that return but
within the height of an image.

00:34:03.799 --> 00:34:07.259
So that when we create a rectangle, it'll
be at the origin 200, 100, but its width

00:34:07.259 --> 00:34:09.889
and height will be exactly the,
the rectangles width and height.

00:34:09.889 --> 00:34:12.879
I mean sorry, the widgets width and height.

00:34:12.880 --> 00:34:17.059
Once we've created our rectangle,
we just call CG context draw image.

00:34:17.059 --> 00:34:23.349
And that will show it up at the right location,
the right way and then since we created the image,

00:34:23.349 --> 00:34:29.829
earlier we had the CG source create image and index, we
must release it to make sure that we don't leak memory.

00:34:29.829 --> 00:34:32.759
So those are the steps that, that
you go through to draw an image.

00:34:32.760 --> 00:34:34.120
I mean it's actually pretty simple.

00:34:34.119 --> 00:34:37.159
There's not a lot of work going on.

00:34:37.159 --> 00:34:42.940
And you know error checking and making sure it's in the
right location is sometimes its a little bit more code.

00:34:42.940 --> 00:34:44.579
But the basic idea is exactly this.

00:34:44.579 --> 00:34:47.969
This is how you use Quartz 2D APIs to draw images.

00:34:47.969 --> 00:34:51.750
( Period of silence )

00:34:51.750 --> 00:34:59.989
So now we've drawn a path and we've sort of
implicitly talked about there's these magic functions

00:34:59.989 --> 00:35:05.149
that return colors, green color, blue
color, how do, how do those actually work.

00:35:05.150 --> 00:35:10.369
So to draw with color in Quartz 2D, you first
need to understand what we think a color is.

00:35:10.369 --> 00:35:15.190
So for Quartz, a color is a color space,
which I'll talk about in a second.

00:35:15.190 --> 00:35:21.570
The components themselves that specify the color value, so
for example, if its an RGB color, red, green, blue color,

00:35:21.570 --> 00:35:25.380
the components would specify the amount of
red, the amount of green, the amount of blue.

00:35:25.380 --> 00:35:32.380
And for us also a color always includes the alpha value, the
amount of transparency, whether it's opaque or transparent.

00:35:32.380 --> 00:35:37.240
So the colors are those the components,
the alpha and the color space.

00:35:37.239 --> 00:35:39.129
So what's a color space?

00:35:39.130 --> 00:35:44.750
At the biggest level a color space just
specifies what model you're working in.

00:35:44.750 --> 00:35:49.880
Whether you're using RGB for example
or CMIK or LAB or device N or index.

00:35:49.880 --> 00:35:51.190
There's a whole bunch of different styles.

00:35:51.190 --> 00:35:53.320
A lot of the time you're going to be working with RGB.

00:35:53.320 --> 00:35:54.720
You're going to be drawing stuff on screen.

00:35:54.719 --> 00:35:56.869
You're familiar with an RGB color space.

00:35:56.869 --> 00:36:03.289
So the biggest level, biggest picture it just that
it says how many components are there in this color?

00:36:03.289 --> 00:36:04.659
Three? Four?

00:36:04.659 --> 00:36:13.769
One? But in addition, color spaces can contain information
that lets you have high fidelity color management.

00:36:13.769 --> 00:36:21.630
So as we saw before in the previous slide, you know the
built in color management uses the color space to make sure

00:36:21.630 --> 00:36:27.180
that colors are represented accurately
from device input to device output.

00:36:27.179 --> 00:36:33.719
That said, a lot of the time for most application
developers, there's a, there's a special color space we have

00:36:33.719 --> 00:36:35.980
in Mac OS X, the generic, that's a name.

00:36:35.980 --> 00:36:37.429
It doesn't really mean generic.

00:36:37.429 --> 00:36:39.000
It's the name.

00:36:39.000 --> 00:36:40.599
Which works just fine.

00:36:40.599 --> 00:36:45.849
Its lets you do high fidelity color on
output, on input and it's just sufficient.

00:36:45.849 --> 00:36:50.250
So we're going to focus on just the generic color space today.

00:36:50.250 --> 00:36:55.369
One, in Leopard, its now a lot simpler
to work with colors in that space.

00:36:55.369 --> 00:37:01.779
We have a function that creates a RGB color
and a CMIK color and a gray color and so on.

00:37:01.780 --> 00:37:06.010
In the, in the color space, in the generic
color space directly from color parameters.

00:37:06.010 --> 00:37:11.670
So you pass in the red, green, blue values along with
your alpha of course and you get out a CG color ref.

00:37:11.670 --> 00:37:16.389
The CG color ref is the abstraction of a
color that encapsulates all these pieces.

00:37:16.389 --> 00:37:19.759
In addition, there's a function, a
new function that lets you return,

00:37:19.760 --> 00:37:23.140
that returns a constant, so called constant color.

00:37:23.139 --> 00:37:29.960
You pass in a name, you get a color out that
it's sort of the same across the whole system.

00:37:29.960 --> 00:37:35.260
And those of you who have used Cocoa will be familiar
with this from the NS color function or methods,

00:37:35.260 --> 00:37:39.760
you know there's an NS color, red color,
you know the green color and so on.

00:37:39.760 --> 00:37:41.160
So this is the same basic idea.

00:37:41.159 --> 00:37:43.089
And this is new in Leopard.

00:37:44.099 --> 00:37:50.619
Once you have a color, we've seen this already,
you can change the color in the context

00:37:50.619 --> 00:37:51.980
by calling either of these two functions.

00:37:51.980 --> 00:37:53.789
There's a couple other functions you can work with as well.

00:37:53.789 --> 00:37:59.559
CG context of fill color with color, so
you pass in a CG Color that you've created

00:37:59.559 --> 00:38:02.340
to change the fill color or the stroke color.

00:38:02.340 --> 00:38:06.140
So this is a, this is almost too
simple of a function to illustrate.

00:38:06.139 --> 00:38:10.670
What was that my get blue color that we saw earlier?

00:38:10.670 --> 00:38:15.519
Well the idea behind that function is that it
returns a blue color every time it's called

00:38:15.519 --> 00:38:18.289
and because it's a get function,
we don't have to release it.

00:38:18.289 --> 00:38:19.940
Its just going to return the same one.

00:38:19.940 --> 00:38:26.110
So as usual with that type of model, we're going to have a
static variable that's going to hold on to the color for us

00:38:26.110 --> 00:38:32.030
and after checking to make sure we need to initialize it,
we do a very simple operation, CG Color create generic RGB.

00:38:32.030 --> 00:38:35.630
That creates the CG color that represents blue.

00:38:35.630 --> 00:38:38.680
The components are red, green, blue, alpha.

00:38:38.679 --> 00:38:45.690
And as I said before, the, the amount of each
component is a number between zero and one,

00:38:45.690 --> 00:38:56.240
so in this case we have no zero red, no green, one full 100
percent blue and for the alpha value again, 100 percent.

00:38:56.239 --> 00:38:57.419
That means fully opaque.

00:38:57.420 --> 00:38:59.590
So this is an opaque blue color.

00:38:59.590 --> 00:39:02.280
And then we just return it as, once we've created it.

00:39:02.280 --> 00:39:08.100
So this is a pretty, this, this type of,
of a little piece of code is pretty good

00:39:08.099 --> 00:39:10.569
for colors that you use over and over and over.

00:39:10.570 --> 00:39:14.110
For colors that are one offs, if you're going to
create them and then use them and then get rid

00:39:14.110 --> 00:39:15.680
of them, you might not have something like this.

00:39:15.679 --> 00:39:19.509
But this is really good if you have a
set of colors that you use all the time.

00:39:20.590 --> 00:39:24.150
So once you have a color, you know
you want to actually color things.

00:39:24.150 --> 00:39:24.950
So what can you color?

00:39:24.949 --> 00:39:26.609
Well a path is a standard thing.

00:39:26.610 --> 00:39:29.610
As we saw before, rectangle, we've
both filled and stroked it.

00:39:29.610 --> 00:39:34.519
But paths are much more complex in, in Quartz 2D.
-

00:39:34.519 --> 00:39:40.610
Paths in Quartz 2D consist of pretty simple pieces.

00:39:40.610 --> 00:39:46.190
They're made up of a line segment or, or
sets of line segments, besia (sp?) or cubic,

00:39:46.190 --> 00:39:49.059
sorry besia (sp?), cubic or quadratic curves.

00:39:49.059 --> 00:39:54.000
So a path sort of is built up over these fundamental pieces

00:39:54.000 --> 00:39:59.510
and once you've created a path you
can do a number of things to it.

00:39:59.510 --> 00:40:05.760
So paths are open in the sense that they have
a different start point and an end point.

00:40:05.760 --> 00:40:06.990
That's a possibility.

00:40:06.989 --> 00:40:12.689
They can be closed, which means that they have a
different, sorry, the same start and the same end point.

00:40:12.690 --> 00:40:18.809
And a path can consist of more than just a
single section of you know lines and arches.

00:40:18.809 --> 00:40:22.880
It can actually consist of multiple
sub paths that are disjoint.

00:40:22.880 --> 00:40:30.970
In this case, in the right hand illustration, really
that's actually four sub paths that comprise a single path.

00:40:30.969 --> 00:40:38.209
The two little line segments and the two circles all are
sub paths that are part of the single big path itself.

00:40:38.210 --> 00:40:47.519
So excuse me, so paths in, in Quartz 2D
can be actually very complex and very rich.

00:40:47.519 --> 00:40:49.199
You can do an awful lot of stuff with that.

00:40:49.199 --> 00:40:51.649
And then what's nice too is we
have some convenience functions

00:40:51.650 --> 00:40:54.059
that let you do simple things like just add a rectangle.

00:40:54.059 --> 00:40:58.980
We sort of saw the rectangle functions before,
our ovals, arcs, so you don't have to think

00:40:58.980 --> 00:41:02.889
about how do I get a circle from
a set of besia (sp?) cubic curves.

00:41:02.889 --> 00:41:04.980
We do that for you.

00:41:04.980 --> 00:41:09.599
The way you work with a path is there
are two ways to work with paths.

00:41:09.599 --> 00:41:17.309
The context itself, the, that draw gestation
abstraction contains a path within it implicitly.

00:41:17.309 --> 00:41:21.110
And so you can work directly with
the context to build up a path.

00:41:21.110 --> 00:41:27.519
And once you've built up the path in the context, you can
then stroke is or fill it, do some other operations to it.

00:41:27.519 --> 00:41:29.670
So that's one model for working with paths.

00:41:29.670 --> 00:41:33.619
That's a, that's a simple model where you just
need to sort of you know build up a rectangle

00:41:33.619 --> 00:41:36.469
or a couple circles and just stroke or fill them.

00:41:36.469 --> 00:41:42.279
Sometimes though you actually want to create a path
yourself that you hang onto and then that you use later.

00:41:42.280 --> 00:41:49.800
And we have CG path functions, the CG path object is sort
of the abstraction of all this various pieces of a path.

00:41:49.800 --> 00:41:55.360
And those let you work and build up a path
directly that you can hang onto and reuse.

00:41:55.360 --> 00:41:58.650
Those of you who have used Cocoa know
about the NS besia (sp?) path probably.

00:41:58.650 --> 00:42:02.800
NS besia (sp?) path is essentially
a cover for these functions,

00:42:02.800 --> 00:42:06.690
so you pretty much have the same
functionality of both levels.

00:42:06.690 --> 00:42:12.400
They're not really doing much other than just calling
into the CG functions directly to hang onto a path.

00:42:12.400 --> 00:42:17.880
Once you have a path, you can add it to the
context to, to be drawn or stroked or filled just

00:42:17.880 --> 00:42:20.730
like you would if you use the implicit one.

00:42:22.079 --> 00:42:29.269
So we're going to go through a, a pretty simple
example of returning a path from the rectangle.

00:42:29.269 --> 00:42:30.759
This path is going to represent a rectangle.

00:42:30.760 --> 00:42:34.550
So it's a bit overkill, but it gives you
the flavor of the way Quartz 2D APIs work.

00:42:34.550 --> 00:42:38.720
You begin by creating a mutable path.

00:42:38.719 --> 00:42:42.419
This is the core foundation model
of mutability verses immutability.

00:42:42.420 --> 00:42:45.740
So you create a mutable path that you're going to modify.

00:42:45.739 --> 00:42:49.489
You begin first by moving in the path to a particular point.

00:42:49.489 --> 00:42:51.919
In this case, the origin of the rectangle.

00:42:51.920 --> 00:42:56.750
And then we add a line to the right
hand corner of the rectangle.

00:42:56.750 --> 00:43:01.340
Add the next line to the upper
right hand corner of the rectangle.

00:43:01.340 --> 00:43:07.620
Add the next line to the upper left hand corner of the
rectangle and now rather than adding another line back

00:43:07.619 --> 00:43:14.480
to the origin, which would be okay but it doesn't actually
create a closed path, it just creates an open path

00:43:14.480 --> 00:43:16.590
that happens to start into the same point.

00:43:16.590 --> 00:43:20.650
We're going to go ahead and close the sub path and
implicitly add the last line back to the origin.

00:43:20.650 --> 00:43:21.930
So that's our rectangular point.

00:43:21.929 --> 00:43:23.929
I mean sorry, excuse me our rectangular path.

00:43:23.929 --> 00:43:26.739
So that's, that's a flavor of how you build up paths.

00:43:26.739 --> 00:43:31.769
Of course rectangles are simple and, and most
applications you're going to do something more complex.

00:43:31.769 --> 00:43:33.500
And then we return it.

00:43:33.500 --> 00:43:37.429
So this creates the rectangular path from this path.

00:43:37.429 --> 00:43:41.219
But now we want to actually do something with that rectangle.

00:43:41.219 --> 00:43:47.049
And we're going to talk a little bit about how you might
create this, this fancy little logo for your flyer.

00:43:47.050 --> 00:43:49.330
And if somebody came to you and said,
oh, draw this logo for me please.

00:43:49.329 --> 00:43:52.920
I, this is, the artist said this is
what I want and I'm supposed to do it.

00:43:52.920 --> 00:43:55.420
Might think oh my goodness, this is
a lot of stuff I have to worry about.

00:43:55.420 --> 00:43:59.119
But I'm going to show you how you do
this same little bit of artwork

00:43:59.119 --> 00:44:06.269
with some very simple code just leverage again
the idea of path reuse, alpha transparency values,

00:44:06.269 --> 00:44:13.440
coordinate transformations so that you can end
up with this little logo on the bottom right.

00:44:13.440 --> 00:44:16.309
So we're going to start out first by
imagining we have our context of course.

00:44:16.309 --> 00:44:22.699
And someone is, we specified the rectangle we
want to use, so we're going to begin by creating a path.

00:44:22.699 --> 00:44:25.149
That was as we saw before to represent that rectangle.

00:44:25.150 --> 00:44:27.700
Of course that could be more complex
than just a simple rectangular path.

00:44:27.699 --> 00:44:30.039
It could be any shape.

00:44:30.039 --> 00:44:33.130
And we're going to start out by saying
we're going to set the context color

00:44:33.130 --> 00:44:37.140
to be blue, because we want to draw a blue rectangle.

00:44:37.139 --> 00:44:40.429
And the first thing we're going to do is set the alpha value.

00:44:40.429 --> 00:44:44.929
In this case, as you read the code, we're going to
set it to one, we're going to make it fully opaque.

00:44:44.929 --> 00:44:52.089
So we're going to draw a fully opaque blue rectangle,
color and the context is blue and global alpha is blue.

00:44:52.090 --> 00:44:57.880
And we begin our path and we add
the rectangular path to the context.

00:44:57.880 --> 00:44:59.180
And then we fill it.

00:44:59.179 --> 00:45:01.679
This is not surprising, we get a blue rectangle.

00:45:01.679 --> 00:45:03.949
You could do this more simply of course with other code.

00:45:03.949 --> 00:45:11.799
But this idea is, is you know the path
is could be more complex and, and more,

00:45:11.800 --> 00:45:14.840
more you know not just a simple rectangle.

00:45:14.840 --> 00:45:17.700
And then we rotate our coordinate system.

00:45:17.699 --> 00:45:21.909
So we're going to now draw this same thing
again but within a rotated coordinate system.

00:45:21.909 --> 00:45:24.000
In this case the rectangle is going to be draw rotated.

00:45:24.000 --> 00:45:27.429
Even though the rectangle itself is not
changed, the coordinate system changed.

00:45:27.429 --> 00:45:29.799
So the rectangle now will be rotated.

00:45:29.800 --> 00:45:31.320
So now we go through our loop again.

00:45:31.320 --> 00:45:34.880
We decrease the global alpha value
and set it in the context.

00:45:34.880 --> 00:45:40.280
So now we're going to draw everything
with a slightly more transparent value.

00:45:40.280 --> 00:45:41.950
The same basic operation.

00:45:41.949 --> 00:45:47.750
We begin the path, add the path, the rectangle to the
context and then fill it and now we have the blue rectangle

00:45:47.750 --> 00:45:51.260
but in the rotated coordinate system,
little bit more transparent.

00:45:51.260 --> 00:45:53.990
So now you have the, the second piece of the logo.

00:45:53.989 --> 00:45:55.659
And now we just do the same thing over and over.

00:45:55.659 --> 00:45:58.219
Again we rotate the coordinate system.

00:45:58.219 --> 00:46:02.169
We draw our rectangle with the
global alpha decreased even further.

00:46:02.170 --> 00:46:07.630
Rotate the coordinate system, draw the rectangle,
rotate the coordinate system, draw the rectangle.

00:46:07.630 --> 00:46:08.510
And so on.

00:46:08.510 --> 00:46:13.300
So you can see we get a relatively complex
effect with actually not very much code.

00:46:13.300 --> 00:46:19.240
And, and we're pulling in the whole idea of being
able to change the coordinate transformation matrix

00:46:19.239 --> 00:46:24.739
so that we get this effect of rotating
the system and also reusing the path over

00:46:24.739 --> 00:46:28.459
and over so we're not creating a new object
each time so our memory use is better.

00:46:28.460 --> 00:46:30.650
Excuse me.

00:46:30.650 --> 00:46:34.200
And we just change the global alpha
rather than setting a new color each time.

00:46:34.199 --> 00:46:38.819
We can use the global alpha to decrease the, the opacity.

00:46:38.820 --> 00:46:42.010
And so this gives you a really complex
effect with not very much work.

00:46:42.010 --> 00:46:48.970
And then of course as usual, we have
created the path, so we must release it.

00:46:48.969 --> 00:46:50.819
( Period of silence )

00:46:50.820 --> 00:46:53.410
So now we have a number of pieces of our flyer

00:46:53.409 --> 00:46:59.119
We have image, we have our little funny logo and we
had a gradient in the background that we want to include.

00:46:59.119 --> 00:47:03.159
And this gradient is pretty subtle, so
I'm going to use a, a much of bolder gradient

00:47:03.159 --> 00:47:08.619
to illustrate the way you work
with gradients in Quartz 2D APIs.

00:47:08.619 --> 00:47:15.309
This is new in Leopard and it's based on feedback
from developers who said that the existing method

00:47:15.309 --> 00:47:17.710
of what's called shadings was too complicated.

00:47:17.710 --> 00:47:21.470
So we have a new thing in Leopard, lets
you work directly with gradients, much,

00:47:21.469 --> 00:47:25.230
much simpler, much more developer friendly.

00:47:25.230 --> 00:47:29.699
So the idea behind a gradient is that
it's just an abstraction of an array

00:47:29.699 --> 00:47:34.289
of colors on a line, range from zero to one.

00:47:34.289 --> 00:47:38.630
So here we have an example where
our gradient is three colors.

00:47:38.630 --> 00:47:40.789
The first color starts at zero, the last color ends at one.

00:47:40.789 --> 00:47:43.029
So the first color is red, last color is blue.

00:47:43.030 --> 00:47:44.960
And we have another color in the middle at point 5.

00:47:44.960 --> 00:47:48.329
Of course you can put those colors anywhere you want.

00:47:48.329 --> 00:47:51.929
And as many as you'd like in the gradient.

00:47:51.929 --> 00:47:54.699
So sort of get a, the effects you're looking for.

00:47:54.699 --> 00:48:00.569
And once you set those colors in this line
from zero to one, when you use the gradient,

00:48:00.570 --> 00:48:03.300
you specify a start point and an end point.

00:48:03.300 --> 00:48:06.130
And the current transformation, the
matrix of the coordinates system

00:48:06.130 --> 00:48:12.720
and the clip region determine how the extent of the gradient
is drawn sort of basically the orientation of the gradient.

00:48:12.719 --> 00:48:16.259
So the gradient this follows a lot of our same model.

00:48:16.260 --> 00:48:23.760
You create an object and then you change the system, the
context parameters to change the way the object is drawn.

00:48:23.760 --> 00:48:30.030
So in this case we have an example on the lower left
corner of the gradient with an origin sort of in the middle

00:48:30.030 --> 00:48:33.160
of this rectangle and an end point
at the top of the rectangle

00:48:33.159 --> 00:48:35.019
and then the clip region is probably the whole rectangle.

00:48:35.019 --> 00:48:36.789
So we just see it inside there.

00:48:36.789 --> 00:48:43.880
We might set the same state up in the middle case and maybe
change the start point in there to point to the corners,

00:48:43.880 --> 00:48:50.059
or maybe we rotate our coordinate system 45 degrees
so that we get this other effect for the middle case.

00:48:50.059 --> 00:48:55.809
And then the far right case we've done the same type
of thing, we've changed our start and end point,

00:48:55.809 --> 00:48:57.549
but we've also changed our clip region to be an ellipse.

00:48:57.550 --> 00:49:00.650
So you get this gradient and this ellipse
without actually doing a lot of work.

00:49:00.650 --> 00:49:05.610
And I'm going to walk you through some of
the code necessary to do these effects.

00:49:05.610 --> 00:49:09.920
Another thing that's important about gradients is
there's the linear version which is just showed you

00:49:09.920 --> 00:49:13.940
but we also have radial gradients
that fill a circular region.

00:49:13.940 --> 00:49:17.559
And the area that you clip to can
be any complex shape you want.

00:49:17.559 --> 00:49:24.900
So here we've clipped to this letter B. It could be
more complex than that to get the nice gradient effect.

00:49:24.900 --> 00:49:28.670
The functions you use to work with
gradients, there's one main one.

00:49:28.670 --> 00:49:34.430
The workhorse function, CG gradient create with colors that
lets you specify an array of colors and a set of points.

00:49:34.429 --> 00:49:37.399
So putting those colors along the line.

00:49:37.400 --> 00:49:41.579
There's a, a more primitive function that
could be useful for certain developers

00:49:41.579 --> 00:49:45.619
where you specify the components explicitly
without creating the colors directly.

00:49:47.429 --> 00:49:53.259
And once you've created a gradient, you can
draw it using CG context draw linear gradient

00:49:53.260 --> 00:49:56.260
to draw a linear one or the radial version for a radial one.

00:49:56.260 --> 00:50:00.790
And you specify start end point, some
options and you have your nice gradient.

00:50:00.789 --> 00:50:07.840
So here's an example of drawing gradients
using Quartz 2D APIs for Leopard.

00:50:07.840 --> 00:50:12.110
We begin by imaging that we have a
rectangle that we want to fill with a gradient.

00:50:12.110 --> 00:50:13.960
So we create this rectangle.

00:50:13.960 --> 00:50:15.010
Its origin is zero, zero.

00:50:15.010 --> 00:50:17.770
It's width and height is 100, 100.

00:50:17.769 --> 00:50:21.539
We're going to create a, just a sea array of colors.

00:50:21.539 --> 00:50:24.230
We're going to to start with the color,
the first color is going to be blue.

00:50:24.230 --> 00:50:29.300
It's going to transition to green, then
turn to red just as I showed you before.

00:50:29.300 --> 00:50:35.030
And in order to use the CG gradient API, we need
to create a CF array from the standard colors.

00:50:35.030 --> 00:50:38.840
This is just a core foundation code
that you probably are familiar with.

00:50:38.840 --> 00:50:44.670
You create a CF array passing in the
set of colors and the number of colors.

00:50:44.670 --> 00:50:47.650
And you call CG gradient, create with color.

00:50:47.650 --> 00:50:49.639
So you pass in this array of colors.

00:50:49.639 --> 00:50:57.250
And the, I mentioned before that you should pass in the
locations where the colors go on this line from zero to one.

00:50:57.250 --> 00:51:02.690
As a convenience, if you just pass in null, what we do
is we distribute those points uniformly along the line.

00:51:02.690 --> 00:51:07.679
So in this case, the first color is going to go blue,
the second color green is going to go at point 5.

00:51:07.679 --> 00:51:11.609
Or the first color will be blue at
zero, the second color will be green

00:51:11.610 --> 00:51:13.690
at point 5 and the last color will be red at one.

00:51:13.690 --> 00:51:16.510
So we do that work for you if you
just need to have a uniform gradient.

00:51:16.510 --> 00:51:21.730
This is particularly useful if you're just doing a gradient
with two colors where you know it's going to be zero to one.

00:51:21.730 --> 00:51:26.079
And as usual, we've create this array so we must release it.

00:51:26.079 --> 00:51:29.840
Now I said before, the way gradients work
is they fill the current clip region.

00:51:29.840 --> 00:51:31.440
And I'll talk about clipping in a second.

00:51:31.440 --> 00:51:34.260
The idea is just, this is the area
where, where the drawing is going to go,

00:51:34.260 --> 00:51:39.280
so we're going to clip to the rectangle
that we want the gradient to fill.

00:51:39.280 --> 00:51:40.880
And then we draw our gradient.

00:51:40.880 --> 00:51:42.490
In this case it's linear.

00:51:42.489 --> 00:51:46.839
And we specify the start point where
the zero value of the gradient maps to.

00:51:46.840 --> 00:51:52.559
In this case, the point is 50 0, that is 50
in the X direction, zero in the Y direction.

00:51:52.559 --> 00:51:55.909
So the bottom middle of the, of the rectangle.

00:51:55.909 --> 00:52:00.170
And we specify an end point, CG point
make 50 100 that is 50 in the X direction

00:52:00.170 --> 00:52:02.190
in the middle, 100 at the top of the rectangle.

00:52:02.190 --> 00:52:04.000
So the middle top of the rectangle.

00:52:04.000 --> 00:52:06.739
And we draw it and that's all you
have to do to get the gradient.

00:52:06.739 --> 00:52:09.250
And of course we've created it so we have to release it.

00:52:09.250 --> 00:52:14.349
So this is much simpler than the code you would
have to write in Tiger to do the same effect.

00:52:14.349 --> 00:52:18.779
And we've really taken your feedback
to heart around some of these things.

00:52:18.780 --> 00:52:22.630
There's a class in Cocoa as well and
this gradient that works similarly.

00:52:22.630 --> 00:52:27.030
Again, built right on top of the CG code.

00:52:27.030 --> 00:52:29.170
In case you want to use that.

00:52:31.010 --> 00:52:35.150
so we built up a gradient, we've built
our image, we've got our fancy logo,

00:52:35.150 --> 00:52:45.010
the last piece is to put this little Italian
Velo Tours logo thingy on top of our flyer.

00:52:45.010 --> 00:52:48.210
So that we imagine is going to come in from a PDF file.

00:52:48.210 --> 00:52:49.869
Someone has created that for us.

00:52:49.869 --> 00:52:51.539
And we want to draw it in our context.

00:52:51.539 --> 00:52:54.269
So how do you do that by using Quartz 2D?

00:52:54.269 --> 00:53:01.409
So I mentioned before with images there's an image source
which is the abstraction of the image data on disk.

00:53:01.409 --> 00:53:06.989
Similarly with PDF there's a CG PDF document
which is the abstraction of the PDF file on disk.

00:53:06.989 --> 00:53:13.539
And the document sort of is, is a way you, you talk
about and ask questions about the document data.

00:53:13.539 --> 00:53:20.529
From the document you can get a page in the PDF
file, CG PDF page ref is the abstraction of a page.

00:53:20.530 --> 00:53:23.920
For historical reasons, pages start at one, not at zero.

00:53:23.920 --> 00:53:25.010
Just the way it is.

00:53:25.010 --> 00:53:31.260
So you, you sort of work with doc, PDF
documents in a similar way you work with images.

00:53:31.260 --> 00:53:34.010
Just a slightly different type.

00:53:34.010 --> 00:53:37.530
So as you might image, CG PDF document create with URL,

00:53:37.530 --> 00:53:43.620
is going to create a PDF document CG
PDF document ref from a URL you specify.

00:53:43.619 --> 00:53:46.599
Once you have the document, you can
ask things like the number of pages,

00:53:46.599 --> 00:53:50.079
number of other properties, lots
of properties you can ask about.

00:53:50.079 --> 00:53:58.259
And once you have the page you want, you can
call CG PDF document get page to return a page.

00:53:58.260 --> 00:54:01.950
And then you can draw that page in the context.

00:54:03.280 --> 00:54:05.580
So this is almost too simple of an example.

00:54:05.579 --> 00:54:13.019
But this is walking you through this exact idea of how
would you create a or rather how would you draw a page

00:54:13.019 --> 00:54:17.059
from a PDF file onto your context destination?

00:54:17.059 --> 00:54:22.000
Here we imagine again as with URL probably a
file URL that points to a PDF file in disk,

00:54:22.000 --> 00:54:25.829
we note some page number we want to draw, maybe
it's the first page, probably in this case.

00:54:25.829 --> 00:54:28.069
And we want to just draw another context.

00:54:28.070 --> 00:54:32.320
So we, first we create a PDF document with our URL.

00:54:32.320 --> 00:54:35.010
Again I've left out all the error checking code.

00:54:35.010 --> 00:54:38.490
We get the page that we want to draw from the document.

00:54:38.489 --> 00:54:39.729
And then we draw it.

00:54:39.730 --> 00:54:41.099
That's it.

00:54:41.099 --> 00:54:43.449
Everything else sort of happens behind the scenes in court.

00:54:43.449 --> 00:54:49.779
So the page, the PDF page we've drawn for you at that point
and we created the document so you'll have to release it,

00:54:49.780 --> 00:54:52.010
but notice that we didn't create the page.

00:54:52.010 --> 00:54:53.730
CG PDF document is not going to get page.

00:54:53.730 --> 00:54:57.380
It's the core foundation model again,
the get functions don't need a release.

00:54:57.380 --> 00:55:01.539
You don't release the page once
you get it from the document.

00:55:01.539 --> 00:55:08.670
You just release the document itself.

00:55:08.670 --> 00:55:09.220
( Period of silence )

00:55:09.219 --> 00:55:10.109
So that's great.

00:55:10.110 --> 00:55:12.180
Now we've pretty much built up our little flyer.

00:55:12.179 --> 00:55:16.539
And now let's image you say well, I'd
really like to spice it up a little bit.

00:55:16.539 --> 00:55:18.750
Maybe I want to put that image in an ellipse.

00:55:18.750 --> 00:55:20.840
Boy that's going to be hard.

00:55:20.840 --> 00:55:22.910
Not really.

00:55:22.909 --> 00:55:30.000
Clipping in the Quartz 2D API is the way you
can constrain your drawing to certain regions.

00:55:31.269 --> 00:55:35.900
When you clip to a region, anything that's
outside that region won't be touched.

00:55:35.900 --> 00:55:38.840
And anything inside that region is
only touched when you draw to it.

00:55:38.840 --> 00:55:45.269
So you, you can actually get very sophisticated
and complex effects by using clipping in Quartz 2D.

00:55:45.269 --> 00:55:52.130
The nice thing about using a path such as an ellipse to
clip is that that's implicitly resolution independent.

00:55:52.130 --> 00:55:53.650
The paths are always resolution independent.

00:55:53.650 --> 00:55:58.139
So you can, you get high quality results if
you clip to a path whether you're going to a,

00:55:58.139 --> 00:56:01.250
your screen or to some 1200 specialized DPI printer.

00:56:01.250 --> 00:56:11.489
The other point about clipping that's an important aspect
in Quartz 2D model is that we intersect not replace.

00:56:11.489 --> 00:56:16.979
So when you clip, your new clipping area is the
intersection of the old one and the old you've specified.

00:56:16.980 --> 00:56:23.329
So if they are disjoint and you clip, you will get no,
no drawing because the clipping area is a null set.

00:56:23.329 --> 00:56:26.789
So the intersection, that's different
from some other graphics models.

00:56:26.789 --> 00:56:28.670
The intersection is an important thing.

00:56:28.670 --> 00:56:33.119
You might think oh my goodness, if I keep clipping, I'm
going to shrink down to nothing and then I can never get back.

00:56:33.119 --> 00:56:37.559
The nice thing is the clipping area is part of
the graphic state, so as I talked about before,

00:56:37.559 --> 00:56:42.309
in order to preserve the current clipping area, you would
save the graphic state, do your clipping, do your drawing

00:56:42.309 --> 00:56:44.820
and then restore the graphic state to what it was before.

00:56:44.820 --> 00:56:46.610
So you kind of restore G state.

00:56:46.610 --> 00:56:48.010
So you can get back to where you were.

00:56:48.010 --> 00:56:55.230
So this is a pretty powerful part of Quartz 2D
that lets you do lots of sophisticate effects.

00:56:55.230 --> 00:56:59.900
In order to clip to a path, we
have a simple convenience function.

00:56:59.900 --> 00:57:06.269
CG context is clipped direct, it will clip to a rectangle
or you can create a path in the context as I showed before

00:57:06.269 --> 00:57:12.579
and then CG context clip will clip your
drawing to the path you set in the context.

00:57:12.579 --> 00:57:18.529
So let's go through a simple example
of clipping an image to an ellipse.

00:57:18.530 --> 00:57:20.980
So its, we're going to do the same image drawing we did before,

00:57:20.980 --> 00:57:24.490
but now we're going to draw it so
it only shows up in this ellipse.

00:57:24.489 --> 00:57:27.439
So the first part of the code, same as we saw earlier.

00:57:27.440 --> 00:57:32.200
We image we can create an ellipse some how
and we have a rectangle we want to draw into.

00:57:32.199 --> 00:57:35.119
So how do we actually draw the image in the ellipse.

00:57:35.119 --> 00:57:39.549
We'll first we need to clip, we need to create
a clip region which is the elliptical area.

00:57:39.550 --> 00:57:41.710
So we begin our path in the context.

00:57:41.710 --> 00:57:48.030
We add an ellipse in the right, basically we're going to fill
that rectangle that we specify with, with the ellipse.

00:57:48.030 --> 00:57:53.830
And we call CG Context Clip to set the current
clipping area to the interior of the ellipse.

00:57:53.829 --> 00:57:56.289
Now everything that we draw will
only show up inside the ellipse.

00:57:56.289 --> 00:58:01.250
So we're going to draw our image, only the
part that's inside the ellipse will show up.

00:58:01.250 --> 00:58:06.809
And again we you know passing the image rect using
the width and height zone to get the right model.

00:58:06.809 --> 00:58:11.710
So this is actually, this gives you some really
powerful effects without doing too much coding

00:58:11.710 --> 00:58:16.800
and what's interesting is with all the special effects,
like in Keno and everything, they all sort of basically come

00:58:16.800 --> 00:58:21.570
down to using this type of code, the clipping
area code and so on to get this affect.

00:58:21.570 --> 00:58:26.410
And then as usual we created our
image so we have to release it.

00:58:26.409 --> 00:58:28.239
Don't want any leaks.

00:58:28.239 --> 00:58:32.659
So that's one type of clipping where we clip to the path.

00:58:32.659 --> 00:58:36.769
Another type of clipping in Quartz
2D lets you clip to an image itself.

00:58:36.769 --> 00:58:43.420
You can use an image, any, any gray scale image
as a mask to put, to specify where to put paint.

00:58:43.420 --> 00:58:49.380
And because it's not necessarily one bit image or
you can use an A bit image or any other bit depth.

00:58:49.380 --> 00:58:57.849
You can, the mask effectively acts like a transparency value
that will fade in or out your drawing so that you get more

00:58:57.849 --> 00:59:01.009
or less paint if you will put on the destination.

00:59:01.010 --> 00:59:07.110
And that can also give you a really powerful and really
interesting effects, by using the mask itself directly.

00:59:07.110 --> 00:59:08.660
And it's very simple to use that.

00:59:08.659 --> 00:59:11.359
You don't have to do a lot of work.

00:59:11.360 --> 00:59:14.610
I'll just show you a simple example of clipping to a mask.

00:59:14.610 --> 00:59:18.650
On the left hand side we have this teapot, lets
image that's our mask that someone has given us.

00:59:18.650 --> 00:59:24.639
And we want to put color through it so that we get the
effect on the right hand side with the colored rectangles.

00:59:25.679 --> 00:59:33.629
So what we're going to do is draw a set of colored
rectangles but first we're going to clip the context

00:59:33.630 --> 00:59:39.500
to the masked image so that only paint
will show up where the image is non zero.

00:59:39.500 --> 00:59:41.500
And the amount of paint, the amount of color that shows

00:59:41.500 --> 00:59:46.349
up will be a fraction based on
the intensity of the masked image.

00:59:46.349 --> 00:59:47.849
Excuse me.

00:59:47.849 --> 00:59:51.789
We would use the function CG context
clip to mask to do this where we pass

00:59:51.789 --> 00:59:54.440
in a rectangle just as before when we're drawing an image.

00:59:54.440 --> 00:59:56.220
But also an image that acts as our mask.

00:59:56.219 --> 00:59:57.529
In this case a teapot.

00:59:57.530 --> 01:00:06.130
So now when we, once we set the, the teapot image
as our mask, when we draw each colored rectangle,

01:00:06.130 --> 01:00:11.670
it's only going to show up where the teapot is non zero, where
the image data itself is non zero and the amount of color

01:00:11.670 --> 01:00:17.019
that appears is a function of the,
the color values in the mask itself.

01:00:17.019 --> 01:00:22.139
So you can sort of see this is, this, I mean
this is in some ways a, an artificial example.

01:00:22.139 --> 01:00:27.049
But this gives you some really powerful and sophisticated
effects using just a very little bit of code.

01:00:27.050 --> 01:00:29.070
In this case, CG context clip to mask.

01:00:29.070 --> 01:00:33.200
And so you can do really interesting
things without doing very much work.

01:00:33.199 --> 01:00:38.049
( Period of silence )

01:00:38.050 --> 01:00:42.560
So lets, at this point we've built up
our flyer, we're very happy with it.

01:00:42.559 --> 01:00:44.670
We want to send it to a friend.

01:00:44.670 --> 01:00:49.460
And we don't want to send our program, because we're you
know we're imaging we're writing this whole piece of code

01:00:49.460 --> 01:00:51.599
that the only purpose is to create this flyer.

01:00:51.599 --> 01:00:52.969
So we don't want to send our program.

01:00:52.969 --> 01:00:55.029
Instead we want to send a PDF file.

01:00:55.030 --> 01:01:00.550
How would you get your con, the drawing that
you've been doing on the screen to a PDF file?

01:01:00.550 --> 01:01:05.630
Well we, we want to export it to PDF and there's
a very easy way to do that in Quartz 2D.

01:01:05.630 --> 01:01:11.760
To create the PDF content, we create
a special type of context, it's not,

01:01:11.760 --> 01:01:14.270
it's again, you know the context are all abstract.

01:01:14.269 --> 01:01:20.349
But it is, it is a specific contents that,
that knows how to draw to a PDF file.

01:01:20.349 --> 01:01:25.659
Once you've created the PDF context or it's been
created for you maybe as part of the print system,

01:01:25.659 --> 01:01:31.710
you can then use it to export it to your friend, you
can mail a PDF file off to a friend or something.

01:01:31.710 --> 01:01:35.480
Or you can use it as a very high
resolution clipboard format.

01:01:35.480 --> 01:01:42.369
It's, it's a really useful piece that you could
add to your application to get high quality output.

01:01:42.369 --> 01:01:49.440
So how would you create a PDF context that specifically
is going to write to a PDF file, directly yourself?

01:01:49.440 --> 01:01:54.619
There's a number of functions that
are used to create a PDF context.

01:01:54.619 --> 01:02:00.719
In particular CF PDF context works great with URL, we
imagine as usual we have an output URL we'll write to.

01:02:00.719 --> 01:02:06.069
And we have a default media box,
how big the PDF file will be.

01:02:06.070 --> 01:02:12.870
Because we need to know on the Quartz
2D side, information about the PDF file,

01:02:12.869 --> 01:02:16.389
we do have some functions that
are specific to a PDF context.

01:02:16.389 --> 01:02:20.429
In this case, CG PDF context begin
page, CG PDF context end page.

01:02:20.429 --> 01:02:24.029
Both of those functions let you tell
us when the page begins and ends.

01:02:24.030 --> 01:02:25.769
That is a little different from other context.

01:02:25.769 --> 01:02:27.449
Most other context don't need to know that.

01:02:27.449 --> 01:02:29.769
You know for PDF we do.

01:02:30.920 --> 01:02:34.720
One thing that's new in Leopard that its important to know
about particularly if you're working with garbage collection

01:02:34.719 --> 01:02:39.769
or you implicitly will be because you're
say a plug in or something that gets loaded.

01:02:39.769 --> 01:02:41.909
And it's the PDF context close function.

01:02:41.909 --> 01:02:46.719
So this is sort of like finalize in
standard garbage collection lingo.

01:02:46.719 --> 01:02:53.629
It, it tells us on the Quartz 2D side that you-'re finished
with the context and we can write out all the trailing data

01:02:53.630 --> 01:02:56.150
and stuff like that that's special to PDF files.

01:02:56.150 --> 01:03:00.050
And we'll do it as soon as you call that function.

01:03:00.050 --> 01:03:06.680
In Tiger that was implicit in that when
the context was released, we would do that.

01:03:06.679 --> 01:03:10.259
But the problem with that is if you're in the garbage
collection environment, you may be releasing next year.

01:03:10.260 --> 01:03:11.250
You never know.

01:03:11.250 --> 01:03:17.340
So you, we need to explicitly let you tell us when you're
finished with the PDF file, when you're finished writing

01:03:17.340 --> 01:03:23.360
to the PDF output destination so that we can write
all the necessary meta data at the end of the file.

01:03:23.360 --> 01:03:27.130
And rather than relying on the
sort of fragile release mechanism.

01:03:27.130 --> 01:03:31.710
So here's a simple example of writing PDF content to a file.

01:03:31.710 --> 01:03:39.190
The first that we need to do is create a default
media rect to do a default page size for our PDF file.

01:03:39.190 --> 01:03:44.679
We want it to be, because this is what
works in the US, 8 and a half by 11 inches.

01:03:44.679 --> 01:03:50.500
PDF is interesting in that its default coordinate
set and the coordinate set it works in is points.

01:03:50.500 --> 01:03:52.260
And at 72 points per inch.

01:03:52.260 --> 01:03:55.440
So we need to convert our 8 and
a half by 11 inches to points

01:03:55.440 --> 01:03:59.480
and that's why we do this 8 point 5 times
72, 11 times 72 to convert that to points.

01:03:59.480 --> 01:04:04.059
So to get the points for the, for the default page size.

01:04:04.059 --> 01:04:07.909
And now we create our PDF context
from the URL that's passed in.

01:04:07.909 --> 01:04:09.619
That's going to be our destination.

01:04:09.619 --> 01:04:12.549
And we pass in a media rect that
specifies the default page size.

01:04:12.550 --> 01:04:13.519
So we don't do anything else.

01:04:13.519 --> 01:04:17.159
Everything else, every page will be 8 and a half by 11.

01:04:17.159 --> 01:04:19.199
We need to as I mentioned before begin the page.

01:04:19.199 --> 01:04:21.419
You need to tell Quartz 2D that you're starting your page.

01:04:21.420 --> 01:04:23.269
And then you do your drawing the regular way.

01:04:23.269 --> 01:04:24.690
You don't do anything special about that.

01:04:24.690 --> 01:04:28.500
That's just the same type of content
drawing that I showed you before.

01:04:28.500 --> 01:04:32.260
All of that's, pretty much goes through unchanged.

01:04:32.260 --> 01:04:34.870
So that you get the output into the PDF file.

01:04:34.869 --> 01:04:40.130
And then as usual or rather in this case, you
need to tell us you're done with the content.

01:04:40.130 --> 01:04:43.180
So that the page can be ended, so that we can end the page.

01:04:43.179 --> 01:04:46.399
And maybe you're going to do another page, so
you can do the same thing again and so on.

01:04:46.400 --> 01:04:51.119
So you draw pages one after another,
begin page, draw your content, end page.

01:04:51.119 --> 01:04:57.929
And then as I mentioned in Leopard, make sure you
call CG PDF context close to tell us now I'm done,

01:04:57.929 --> 01:05:04.069
write out everything that you need to write to the file,
flush all the data to the, to the output destination.

01:05:04.070 --> 01:05:08.390
And then because we created the
content, context we have to release it.

01:05:08.389 --> 01:05:17.250
So that's sort of how you might build up a flyer, you
know from start to PDF output just using Quartz 2D APIs.

01:05:17.250 --> 01:05:19.760
Of course I've just barely touched on what's available.

01:05:19.760 --> 01:05:23.900
There's a lot more that you can do in Quartz 2D.

01:05:23.900 --> 01:05:26.269
Let me just give you a flavor of some of that.

01:05:26.269 --> 01:05:31.019
There's what we call a CG pattern
which lets you do replicated drawing.

01:05:31.019 --> 01:05:34.440
Patterns work like colors, so you
can both use, use them both as fill

01:05:34.440 --> 01:05:38.530
and stroke colors as you, if you will to fill regions.

01:05:38.530 --> 01:05:43.840
We can use them like a wallpaper where you
just replicate the pattern over, over an area.

01:05:43.840 --> 01:05:48.200
Shadows, those of you who have used Cocoa
probably know about the NS shadow class

01:05:48.199 --> 01:05:53.230
and of course that's just a straight
cover on top of the CG shadow itself.

01:05:53.230 --> 01:06:00.059
A shadow could be as I show here, it
could be either soft edged, hard edged.

01:06:00.059 --> 01:06:07.000
It can be different orientations, you have different
colored shadows for some reason, you might want that.

01:06:07.000 --> 01:06:10.159
And you, any, anything that you could
can draw in Quartz 2D you can shadow.

01:06:10.159 --> 01:06:12.869
So here I show some more complex
paths that have a nice shadow.

01:06:12.869 --> 01:06:16.849
You can see the shadow is drawn
appropriately in the interior parts and so on.

01:06:16.849 --> 01:06:21.159
So that, that shadows are very powerful
and gives you a lot of cool effects.

01:06:21.159 --> 01:06:24.769
Shadings, I mentioned those earlier in
passing when I talked about gradients.

01:06:24.769 --> 01:06:29.000
It's a more complex but also more
powerful way to do gradients.

01:06:29.000 --> 01:06:32.760
Gives you a little bit more control
over the way the gradient appears.

01:06:32.760 --> 01:06:38.330
So that's worth checking out if you need
more than what the gradient functions offer.

01:06:38.329 --> 01:06:45.889
Transparency layers are a way to draw a group of content
and then have an effect applied to them all as a group.

01:06:45.889 --> 01:06:51.569
Here you can see on the left we have, maybe
this is a logo we want to draw consisting

01:06:51.570 --> 01:06:53.700
of two rectangles with a stroked rectangle.

01:06:53.699 --> 01:06:58.500
And when we draw them with a shadow, if we draw them one
after another we get the shadow sort of falling on top

01:06:58.500 --> 01:07:01.260
of the other objects, which is not what we want.

01:07:01.260 --> 01:07:08.030
On the right, what we've done is used a transparency
layer where we draw the content and its treated all

01:07:08.030 --> 01:07:11.590
as a single set of drawing operations
so that then when the shadow is applied,

01:07:11.590 --> 01:07:14.329
its applied as though that were
all just one block of objects.

01:07:14.329 --> 01:07:18.969
You can see the shadow shows up
correctly on the right hand side.

01:07:18.969 --> 01:07:26.179
There's an idea of CG layer which lets you
do high RSV rendering of drawn content.

01:07:26.179 --> 01:07:30.409
In this case we imagine we have a layer
that we've drawn on little object into.

01:07:30.409 --> 01:07:35.389
And we can reuse that layer to get the,
the same object drawn in multiple times.

01:07:35.389 --> 01:07:41.489
And that's also part of Quartz 2D.
-

01:07:41.489 --> 01:07:45.229
So that's, that's just sort of a flavor of where you can go.

01:07:45.230 --> 01:07:47.309
Of course there's even more beyond this.

01:07:47.309 --> 01:07:50.719
The thing that you might want to
know is like well what do I do now?

01:07:50.719 --> 01:07:51.739
How do I actually get started?

01:07:51.739 --> 01:07:55.319
Because this is, you know this talk is all
good, but really you have to write code.

01:07:55.320 --> 01:07:57.500
How do you do that?

01:07:57.500 --> 01:07:59.420
The thing I would recommend is get this book.

01:07:59.420 --> 01:08:02.090
This is an excellent, fantastic book.

01:08:02.090 --> 01:08:06.350
Talks about everything I've talked about plus a lot more.

01:08:06.349 --> 01:08:10.509
It's really a valuable reference for
anyone who wants to use Quartz 2D.

01:08:10.510 --> 01:08:12.160
And pretty much the reference.

01:08:12.159 --> 01:08:14.259
It was written by two people at Apple.

01:08:14.260 --> 01:08:15.540
They did a fantastic job.

01:08:15.539 --> 01:08:22.640
I absolutely recommend it as a good way to learn more
about what I've been talking about and go even further.

01:08:22.640 --> 01:08:27.970
And of course as a standard Apple developer
resources as you know about, those are also very,

01:08:27.970 --> 01:08:30.909
very good and providing lots and lots of information.

01:08:30.909 --> 01:08:36.689
And of course we have our, we have Allan you can
talk to who, who can get you to the right people

01:08:36.689 --> 01:08:38.719
when you need to have specific questions answered.
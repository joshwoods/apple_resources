WEBVTT

00:00:24.039 --> 00:00:24.779
>> I'm Dave Hall.

00:00:24.780 --> 00:00:33.780
I work on FxPlug in the Pro Aps team at Apple,
and, you know, since we introduced FxPlug at NAB,

00:00:33.780 --> 00:00:40.320
the National Association of Broadcasters conference two
years ago, a lot of people have started writing FxPlugs,

00:00:40.320 --> 00:00:45.310
and I'm really glad to see the -- the number that
have been coming out and the quality of them,

00:00:45.310 --> 00:00:52.109
from camera manufacturers to more
traditional filter and transition developers.

00:00:52.109 --> 00:01:01.170
At this session we're going to talk about, basically,
what the FxPlug SDK is, how you can write an FxPlug

00:01:01.170 --> 00:01:06.349
and some new developments in FxPlug inside Final Cut Pro

00:01:06.349 --> 00:01:13.219
and inside the FxPlug SDK itself and
with the new revision called 1.2.1.

00:01:16.319 --> 00:01:25.099
Now FxPlug is a -- it's a new plug-in architecture that
we created so that we could add new features rather

00:01:25.099 --> 00:01:30.059
than just hosting plug-ins written with other architectures.

00:01:30.060 --> 00:01:36.299
And at first the -- the host application
that supported FxPlug was Motion 2.0.

00:01:36.299 --> 00:01:44.750
Since then last year we introduced FxPlug
support in Final Cut Pro and the FxPlugs

00:01:44.750 --> 00:01:47.609
that you can write can be based on
-- they're based on Objective-C.

00:01:47.609 --> 00:01:51.780
You can use C in your rendering
functions, a lot of people do.

00:01:51.780 --> 00:01:55.890
You can use OpenGL and other Apple frameworks.

00:01:58.430 --> 00:02:04.450
One really attractive thing about writing FxPlugs is
the large user base, there are 800,000 registered users

00:02:04.450 --> 00:02:10.330
of Motion Final Cut, and they all use Fx.

00:02:10.330 --> 00:02:13.200
Another thing is that the effects that you write

00:02:13.199 --> 00:02:21.579
as FxPlugs can have really great performance
and that's due to our use of OpenGL.

00:02:21.580 --> 00:02:30.670
It's due to the universal binaries, and you can also
have custom UI, both in the inspector window in the apps

00:02:30.669 --> 00:02:35.439
where you can make a control that looks
however you want it to, or you can --

00:02:35.439 --> 00:02:40.060
you can do on-screen controls where you
draw controls directly onto the canvas

00:02:40.060 --> 00:02:43.610
and those run in Motion and those are based on OpenGL.

00:02:45.949 --> 00:02:54.159
In the last version last year we introduced RGBA --
or we had RGBA but we introduced YUV plus alpha pixels

00:02:54.159 --> 00:03:03.019
and floating point pixels have been in there from the
start which is a great way to get really good quality and,

00:03:03.020 --> 00:03:08.580
finally, in this -- in this latest release,
Motion 3, we've added 3D to the ap=plication.

00:03:08.580 --> 00:03:17.740
So we've added a little bit of 3D interface to= the FxPlug
SDK so you can access the camera and layer transforms.

00:03:17.740 --> 00:03:27.000
So the first thing I want to talk about is how you
write an FxPlug plug-in and there're five basic steps,

00:03:27.000 --> 00:03:29.789
and I know it's going to sound
ridiculously simple but, of course,

00:03:29.789 --> 00:03:33.129
there's a lot more to these than these three words each.

00:03:33.129 --> 00:03:41.340
You initiate a template in Xcode to make
an FxPlug filter transition or generator.

00:03:41.340 --> 00:03:48.879
You create unique IDs so that we can tell
one plug-in from another and then, of course,

00:03:48.879 --> 00:03:51.689
you customize the source code which is the real work.

00:03:51.689 --> 00:03:56.849
You build an install and you test, and we'll go
through each one of these steps in more depth now.

00:03:57.909 --> 00:04:04.180
So, when you select an Xcode template,
you get the list and the three

00:04:04.180 --> 00:04:07.860
that we've added: FxPlug filter, generator and transition.

00:04:07.860 --> 00:04:11.630
In this example we're selecting the filter.

00:04:11.629 --> 00:04:21.250
You give it a name and what you'll see is a very simple
project that has two source files and some resources.

00:04:21.250 --> 00:04:29.550
It's just a .M and a .H. this is for the filter, for the
generator you'll see a .MMs, we've used Objective-C++

00:04:29.550 --> 00:04:34.689
but it will look very similar to this and the
Info P list in there is -- is interesting, too.

00:04:34.689 --> 00:04:36.839
We'll show you a little bit about that.

00:04:37.959 --> 00:04:48.989
Now just dive into the Info P list and the first thing
you'll want to do is create the unique IDs, and you can --

00:04:48.990 --> 00:04:54.290
you'll find comments in the -- in the Info.P
list but you can also just look for a UUID,

00:04:54.290 --> 00:04:59.140
and you'll find three of them, one of them is the
ID for the group that your plug-in belongs to,

00:04:59.139 --> 00:05:08.310
the category name like blurs or, your company name or
wherever you want it to go, and you'll generate a UUID

00:05:08.310 --> 00:05:15.800
which you can use -- you can use the terminal genUUID or
UUIDgen, but I'll also show you a way to automate that,

00:05:15.800 --> 00:05:19.579
makes it much easier so you can use a keystroke.

00:05:19.579 --> 00:05:23.609
Then that group UUID appears twice, there's
the one where you're defining the group

00:05:23.610 --> 00:05:29.460
and later where you define your plug-in you state which
group it belongs to, so you'll copy that UUID and put it

00:05:29.459 --> 00:05:38.209
in the plug-in descriptor, and then there's a UUID for
the plug-in itself and you give that a separate unique ID.

00:05:38.209 --> 00:05:45.089
So here's how you can create a script that
goes into Xcode so you can have a key stroke.

00:05:45.089 --> 00:05:51.929
In this case you can see it says @dollarU that means
command shift U. So you select one of those UUIDs,

00:05:51.930 --> 00:05:59.209
press this keystroke if you have this
installed, and it will replace your -- the --

00:05:59.209 --> 00:06:07.149
the UUID from the template with yours and don't bother to
write it down, it's all in the SDK, in the documentation.

00:06:09.879 --> 00:06:15.000
So, again, you'll see the comments in there,
just look for those, make the change in the UUID

00:06:15.000 --> 00:06:23.180
and then customizing the source codes two -- two main things
there's a parameter list that the samples will define,

00:06:23.180 --> 00:06:28.310
and you'll change that to be your own parameters, and you'll
change the render method and those are the very basics

00:06:28.310 --> 00:06:33.300
and there's a lot more that you can do in a plug-in
but that's what's going -- going to create your --

00:06:33.300 --> 00:06:37.020
your first effect and the render
methods you can write one or two.

00:06:37.019 --> 00:06:41.250
You can either do CPU rendering or GPU rendering or both.

00:06:43.579 --> 00:06:48.490
Then, when you build your project,
you'll want to install the --

00:06:48.490 --> 00:06:56.120
the product into library plug-ins FxPlug either
from the root domain or your user domain,

00:06:56.120 --> 00:07:01.939
and then you want to be able to debug and -- and so
there're a few different things that we -- we do.

00:07:01.939 --> 00:07:07.540
One of them is to change the build
location to directly write into the --

00:07:07.540 --> 00:07:11.890
into the target folder by making a script command.

00:07:11.889 --> 00:07:18.240
What I usually do is just go into terminal like this
and make a -- a symbolic link to point to the --

00:07:18.240 --> 00:07:25.110
to the build product directory, and
then test in Motion and Final Cut.

00:07:25.110 --> 00:07:37.540
In the case where we built this my filter example it'll
show up in the browsers of either Ap as shown there.

00:07:37.540 --> 00:07:41.930
Now I'd like to have -- I'd like to introduce Vijay
Sundaram to talk a little bit

00:07:41.930 --> 00:07:46.439
about how FxPlugs work in Final Cut
and what's new in that space, Vijay.

00:07:46.439 --> 00:07:47.889
>> Thank you, Dave.

00:07:47.889 --> 00:07:49.259
Hello, everyone --

00:07:49.259 --> 00:07:53.370
( Applause )
Is that for me or for Dave?

00:07:53.370 --> 00:07:58.439
Thank you and welcome to the introduction to FxPlug session.

00:07:58.439 --> 00:08:08.009
We introduced support for FxPlug within Final Cut Pro at
WWDC 2006 and since t hen we have continued to make a lot --

00:08:08.009 --> 00:08:16.990
a number of enhancements to the application as we
continue to support new APIs in the FxPlug API model.

00:08:16.990 --> 00:08:21.360
As Dave mentioned a number of developers
have now started using this.

00:08:21.360 --> 00:08:27.080
So I thought we'll first of all go through some of
the salient features that we've introduced inside

00:08:27.079 --> 00:08:31.569
of Final Cut Pro for the 1.21 version of the API.

00:08:31.569 --> 00:08:35.189
First off is hidden, and disable and
not animatable parameter support.

00:08:35.190 --> 00:08:40.570
This will allow you to be able to create new
and different controls for your plug-ins.

00:08:40.570 --> 00:08:47.760
Support for parameters groups basically allows you to create
your plug-ins with controls that can be grouped together

00:08:47.759 --> 00:08:53.289
in logical units giving a seamless
interface to your customers.

00:08:53.289 --> 00:08:58.959
FX parameter setting API, it allows you
to create presets for your plug-ins.

00:08:58.960 --> 00:09:06.050
So, for example, if your user -- if you have a pop-up menu
for one of your controls and the user makes a selection,

00:09:06.049 --> 00:09:13.089
you can prepopulate some of the other controls and enable
or disable them and provide those default values to them.

00:09:13.090 --> 00:09:19.540
Parameter sampling at arbitrary times allows the plug-in
to get Keyframe parameter values at arbitrary times,

00:09:19.539 --> 00:09:23.689
and you can then support Keyframing inside your plug-in.

00:09:23.690 --> 00:09:25.240
Move to next slide.

00:09:27.090 --> 00:09:34.389
So because Final Cut Studio comes as a box and
Final Cut Pro and Motion are in the same box,

00:09:34.389 --> 00:09:38.779
there is a very high probability that your
plug-in will be used in both applications.

00:09:38.779 --> 00:09:44.129
There's some caveats to remember when you target
your plug-in for each one of these applications,

00:09:44.129 --> 00:09:47.460
and I thought I'll take a little
time and go over some of the things

00:09:47.460 --> 00:09:52.790
to remember especially when you're targeting Final Cut Pro.

00:09:52.789 --> 00:10:00.059
On-screen controls, on-screen controls are
very powerful technology inside of Motion,

00:10:00.059 --> 00:10:02.359
unfortunately not supported in Final Cut Pro.

00:10:02.360 --> 00:10:06.399
So if you were making your plug-ins
with a number of on-screen controls,

00:10:06.399 --> 00:10:11.730
please remember that you provide equivalent controls
and parameters inside of Final Cut Pro so that your user

00:10:11.730 --> 00:10:16.230
when he switches between these two
applications will be able to use your plug-in

00:10:16.230 --> 00:10:21.759
and get a better benefit from your plug-in basically.

00:10:21.759 --> 00:10:27.429
Software rendering is preferred for Final Cut
Pro and there's a couple reasons over here.

00:10:27.429 --> 00:10:32.199
Motion prefers hardware rendering and
Final Cut Pro prefers software rendering.

00:10:32.200 --> 00:10:39.640
The reason in Final Cut Pro is that Final Cut Pro users tend
to go between the tower machines and Mac Pro machines so,

00:10:39.639 --> 00:10:45.189
if you are targeting the GPU and looking for certain
features in the GPU, when they move their projects

00:10:45.190 --> 00:10:51.010
from these high-end machines down to the Mac Pros,
they may not have equivalent functionality in the GPU.

00:10:51.009 --> 00:10:55.769
Also because in Final Cut Pro we'll be
using the resulting images for other effects

00:10:55.769 --> 00:11:02.899
or if an external monitor is connected to it, we will read
the pixels back from the GPU which can effect performance

00:11:02.899 --> 00:11:08.750
and not give the same amount of flow that
the user will be expecting in the plug-ins.

00:11:08.750 --> 00:11:17.879
So, if possible it would be better for you
to create two paths, software and hardware.

00:11:17.879 --> 00:11:23.700
Native YUV support is important inside of Final Cut Pro
because Final Cut Pro is basically a video editing engine.

00:11:23.700 --> 00:11:32.890
R408 which is our 8-bit YUV color space is the native
color space for preview so, when the user hits playback

00:11:32.889 --> 00:11:38.460
and that's the color space that we use
and R4FL is a 30-bit float YU space,

00:11:38.460 --> 00:11:43.500
and it's preferable to support
these two color space parameters

00:11:43.500 --> 00:11:46.100
for two reasons, again, one is for performance reasons.

00:11:46.100 --> 00:11:48.750
You don't want to convert between the different color spaces

00:11:48.750 --> 00:11:52.710
and two to prevent clamping when
you go between these color spaces.

00:11:52.710 --> 00:11:57.990
So keeping fidelity and quality and not
losing your super white and super blacks.

00:11:57.990 --> 00:12:02.289
There are two modes in Final Cut Pro, Safe RT
and Unlimited RT and, when I go to my demo,

00:12:02.289 --> 00:12:05.750
I'll actually show you what this means a little
bit so that you can actually see in action,

00:12:05.750 --> 00:12:13.090
but SafeRT guarantees that we will always playback
without dropping frames, and this is easy for us to do

00:12:13.090 --> 00:12:19.440
for internal plug-ins because we actually profile these
plug-ins and then we can show the user whether it's playable

00:12:19.440 --> 00:12:23.990
in RT or not by giving them either a red
or green bar over the particular segment,

00:12:23.990 --> 00:12:26.490
but this is not possible for third-party effects.

00:12:26.490 --> 00:12:28.930
So how can you take advantage of something similar?

00:12:28.929 --> 00:12:35.439
The user can switch from Safe RT to Unlimited RT.

00:12:35.440 --> 00:12:42.540
When they do this, they get the same functionality as
an internal plug-in except that we do not guarantee

00:12:42.539 --> 00:12:47.870
that there will be no dropped frames but this is a very
useful mode for the user to work with in your plug-in

00:12:47.870 --> 00:12:53.370
so that they can change the parameters and get instant
feedback and even play it back and get preview.

00:12:53.370 --> 00:12:59.169
So to be able to support your playback in
realtime the first two points would be --

00:12:59.169 --> 00:13:03.029
would be something to consider so that you
can give them the same amount of functionality

00:13:03.029 --> 00:13:07.149
when they switch from Safe RT down to Unlimited RT.

00:13:07.149 --> 00:13:12.759
Finally, paying attention to pixel aspect ratio there is
a -- there is a -- there is a bigger thing to remember,

00:13:12.759 --> 00:13:17.620
one of the interesting technology inside
of Final Cut is what we call Dynamic RT.

00:13:17.620 --> 00:13:25.590
The concept of Dynamic RT basically says that we will try
and keep playback constant at the best quality possible.

00:13:25.590 --> 00:13:30.960
Depending on the runtime conditions we
will scale back the quality of the --

00:13:30.960 --> 00:13:36.360
of the image and the way we do this is we basically send a
hint down to the Kodak and ask it to go from high quality

00:13:36.360 --> 00:13:40.389
down to say medium quality, and if there's
resources available, go back up to high quality

00:13:40.389 --> 00:13:47.620
and the implementation detail is left up the Kodak
so the Kodak can give you a scaled image back

00:13:47.620 --> 00:13:56.460
or a single field back, so you should be able to look at the
parameters that get passed down to you in Render Info.scale

00:13:56.460 --> 00:14:04.070
and Image Dimensions to make sure that you are not
expecting always a certain behavior but your --

00:14:04.070 --> 00:14:12.660
that your plug-in adapts to the values that get passed down
to you and puts out the output frame that is full frame.

00:14:12.659 --> 00:14:19.730
Another part about this is that because we can send
you an interlaced field or a single field unlike Motion

00:14:19.730 --> 00:14:23.340
which will actually align double and give you
a full frame, so this is a thing to remember

00:14:23.340 --> 00:14:27.389
when you are targeting these two
applications as to what the behavior is

00:14:27.389 --> 00:14:31.740
and then pixel aspect ratio becomes important
because, if you're passing down a single field,

00:14:31.740 --> 00:14:39.110
you will get a pixel aspect ratio, for example, in the case
of DV of 0.4 where as, if you are passing down a full frame,

00:14:39.110 --> 00:14:41.080
you will get a pixel aspect ratio of 0.8.

00:14:41.080 --> 00:14:48.200
It's something to consider when you are targeting Final
Cut Pro and finally as Dave mentioned, test, test, test.

00:14:48.200 --> 00:14:54.110
Test in both applications to make sure that your
plug-in works correctly in both of these applications

00:14:54.110 --> 00:14:56.820
and that the result in output is correct.

00:14:56.820 --> 00:14:58.830
I'd like to switch over to my demo.

00:14:58.830 --> 00:15:02.350
If I could switch to the demo machine, please.

00:15:08.950 --> 00:15:12.200
Sorry, gets dry out here.

00:15:12.200 --> 00:15:18.460
Couple things I want to show you in the demo is,
first of all the sample plug-in that actually comes

00:15:18.460 --> 00:15:24.310
with the FxPlug SDK, the first
plug-in is what we call SimpleMatte,

00:15:24.309 --> 00:15:29.259
and it allows basically shows you how you can
create custom UI parameters for your controls.

00:15:29.259 --> 00:15:32.909
So, if you follow Dave's steps and do the right thing,

00:15:32.909 --> 00:15:36.169
you will see that your plug-in
will show up under certain groups.

00:15:36.169 --> 00:15:40.959
So there are basically three types of plug-ins that
you can create, filters, transitions and generators

00:15:40.960 --> 00:15:43.629
and all three are supported inside of Final Cut Pro,

00:15:43.629 --> 00:15:49.100
and your company name will probably be
the group, in this case, it's Examples.

00:15:49.100 --> 00:15:55.529
You -- so in this particular case you will
apply the SimpleMatte plug-in to the clip,

00:15:57.700 --> 00:16:03.370
you see there's an NS view that's been created here and the
user can paint around it and create a matte effect for --

00:16:03.370 --> 00:16:07.159
for -- in your plug-in so it's a good example
to be able to understand what's the best way

00:16:07.159 --> 00:16:10.299
to go ahead and create custom UI controls.

00:16:10.299 --> 00:16:15.549
One point I quickly -- before I go to my
next plug-in this is what I was talking

00:16:15.549 --> 00:16:17.389
about with the respect to SafeRT and UnlimitedRT.

00:16:17.389 --> 00:16:25.769
As you can see over here if I switch this from UnlimitedRT
down to SafeRT that particular filter segment went red,

00:16:25.769 --> 00:16:30.289
which means it's in RT because we didn't profile it and
this is what's going to happen to your third-party plug-in.

00:16:30.289 --> 00:16:35.049
So, if you -- if the user switches off from
SafeRT to UnlimitedRT, it will go orange

00:16:35.049 --> 00:16:39.109
and they can actually play it back and get
equivalent performance as though it were

00:16:39.110 --> 00:16:46.050
in SafeRT although we don't guarantee that you won't
drop frames in playback and as you can see below

00:16:46.049 --> 00:16:49.669
that is DynamicRT in the three modes,
so you can force -- for your testing --

00:16:49.669 --> 00:16:53.439
you can actually force the mode to be high,
medium or low and make sure that all three

00:16:53.440 --> 00:16:58.320
of these modes are supported correctly so that
when then the user actually is in dynamic mode

00:16:58.320 --> 00:17:04.059
and it switches during runtime, the right things
will take place with respect to your plug-in.

00:17:04.059 --> 00:17:10.690
Now, since -- since the last time we introduced -- since the
last year when we introduced FxPlug inside of Final Cut Pro,

00:17:10.690 --> 00:17:16.440
we have seen a number of users actually move to the Mac
platform or even people who've written other filters

00:17:16.440 --> 00:17:22.240
who are interested in targeting
Final Cut Pro using the FxPlug API.

00:17:22.240 --> 00:17:26.410
To be able to learn the FxPlug APIs you
can actually take advantage of a lot

00:17:26.410 --> 00:17:29.580
of interesting technologies within
the Mac Operating System itself.

00:17:29.579 --> 00:17:36.509
There's Quartz Composer, Core Image, the Image, Image IO a
number of these very powerful technologies that you can use

00:17:36.509 --> 00:17:41.400
as your image processing engine, so that you
can start playing and learning the FxPlug APIs

00:17:41.400 --> 00:17:46.460
without necessarily having to import any of
your previous plug-ins from another platform.

00:17:46.460 --> 00:17:49.190
The example over here is a simple Core Image filter.

00:17:49.190 --> 00:17:59.700
I will switch this one out and apply this filter.

00:18:01.460 --> 00:18:07.950
It exposes one single parameter which is exposure, CI
actually provides a number of interesting filters for you,

00:18:07.950 --> 00:18:11.960
and all I've done over here is pick one of
the filters which is the exposure CI filter,

00:18:11.960 --> 00:18:16.430
and I'm asking that technology's CI
to actually do the rendering for me.

00:18:16.430 --> 00:18:22.200
I'm exposing the parameter up to Final Cut in this
case through the exposure parameter and as you can see,

00:18:22.200 --> 00:18:26.440
when I scrub her out, CI is actually
doing the image processing for me.

00:18:26.440 --> 00:18:34.420
So you can use technologies inside of the Mac Operating
System to be, one able to learn quickly the FxPlug APIs

00:18:34.420 --> 00:18:42.720
and two probably even use those technologies as part
of your -- of your plug-in and to demonstrate my point,

00:18:42.720 --> 00:18:50.740
we've actually had the good fortune of getting Noise
Industries to provide us with some of their plug-ins,

00:18:50.740 --> 00:18:55.710
and I'd like to be able to demonstrate
the Noise Industry filter.

00:18:55.710 --> 00:19:02.380
So, if you go up to effects and video filters, you can
see that there's a number of filters that they provide

00:19:02.380 --> 00:19:05.280
which can be used inside of Final Cut Pro.

00:19:05.279 --> 00:19:08.649
So let me apply Sobel Edge.

00:19:08.650 --> 00:19:14.850
As you can see it applies the edge
detection filter and it works great.

00:19:14.849 --> 00:19:21.049
So what's interesting about this is, let's say that
your users typically apply the Sobel Edge filter

00:19:21.049 --> 00:19:25.029
and then they want to do a two-tone color effect,
typically they would apply this first filter

00:19:25.029 --> 00:19:27.029
and then they would apply the second filter.

00:19:27.029 --> 00:19:31.460
So how can we change this work, how can you make
it a little bit different and this is the problem

00:19:31.460 --> 00:19:35.779
that Noise Industries has -- has
solved using technologies inside

00:19:35.779 --> 00:19:38.710
of the Mac Operating System and
exposing them through FxPlug.

00:19:38.710 --> 00:19:48.730
So a quick Final Cut Pro here, and bring up the FxFactory
application, so as you can see this FxFactory Pro Pack

00:19:48.730 --> 00:19:56.140
and you can open the Pro Pack and
take a look at all the plug-ins.

00:19:56.140 --> 00:20:00.680
As you can see all the groups are over
here and under stylized you see Sobel Edge

00:20:00.680 --> 00:20:04.210
and you can see all the parameters that
it exposed inside of Final Cut Pro.

00:20:04.210 --> 00:20:08.720
So we were talking about how we can add
two-tone color effect to this without, you know,

00:20:08.720 --> 00:20:18.480
writing another piece of code, so this particular
plug-in actually uses Quartz Compositions and,

00:20:18.480 --> 00:20:21.690
if you hit the edit button, it
actually brings up the Quartz Composer.

00:20:21.690 --> 00:20:27.759
Quartz Composer is a technology inside of the Mac Operating
System, and it's available to every -- every -- it's --

00:20:27.759 --> 00:20:33.079
it's available in every single version of the software --
of the operator system, and you can use Quartz Composer

00:20:33.079 --> 00:20:40.470
to create node-based edits where you basically create
patches and wire them up and create interesting images.

00:20:40.470 --> 00:20:42.650
So in this particular case, if you wanted to take a look

00:20:42.650 --> 00:20:46.610
at what the Sobel Edge filter looks
like, you can see that there's an input.

00:20:46.609 --> 00:20:51.599
This input would typically come
from Final Cut Pro or Motion.

00:20:51.599 --> 00:20:55.119
It goes through a clamp, does the edge
detection, gets cropped and sent --

00:20:55.119 --> 00:21:00.179
and the output is sent out and which comes back to
Final Cut Pro or Motion and it would get rendered up.

00:21:00.180 --> 00:21:04.830
So our initial objective was to be able to add
a two-tone color effect, how do we do this?

00:21:04.829 --> 00:21:06.839
Now the same Core Image that I was talking

00:21:06.839 --> 00:21:13.339
about in the earlier demo actually provides
you with a patch called false color.

00:21:13.339 --> 00:21:19.639
It's very simply put we drag it across and as you
can see it's got two parameters Color 1 and Color 2

00:21:19.640 --> 00:21:23.150
which would effect the colors of -- of the image.

00:21:23.150 --> 00:21:29.860
You can rewire this by breaking the connection over here --
oh, actually not here, but breaking the connection over here

00:21:29.859 --> 00:21:35.789
to the image and then adding this connection back down here

00:21:35.789 --> 00:21:38.430
and as you can see it actually
applied a two-tone color effect.

00:21:38.430 --> 00:21:45.360
Now that's interesting because you've been able to quickly
add a new color but how do you expose the parameters Color 1

00:21:45.359 --> 00:21:49.449
and Color 2 so that inside of Motion and
Final Cut Pro you can do the same thing?

00:21:49.450 --> 00:21:55.400
Quartz Composer actually allows you to publish your inputs
and outputs, so in this particular case I will go ahead

00:21:55.400 --> 00:22:04.860
and publish the input Color 1, call it Color 1 and publish
input Color 2 and call it Color 2 and that's about it.

00:22:04.859 --> 00:22:15.209
Now I go and save this and apply changes over
here and as you can see FxFactory has updated

00:22:15.210 --> 00:22:17.850
and shows you the two parameters Color 1 and Color 2.

00:22:17.849 --> 00:22:43.419
Great. Now we quit this, save the filter, bring up Final
Cut Pro -- takes a minute, and we look for the filter,

00:22:47.230 --> 00:22:54.950
stylize Sobel Edge and there you go, you've
now been able to add two new parameters

00:22:54.950 --> 00:22:59.069
and a filter to your plug-in without any programs.

00:22:59.069 --> 00:23:04.500
So this is a very powerful technology and you
should be able to take advantage of things like this

00:23:04.500 --> 00:23:08.509
when you create your plug-ins and
give your users new and different ways

00:23:08.509 --> 00:23:13.779
of being able to create effects for themselves.

00:23:13.779 --> 00:23:14.849
That concludes my demo.

00:23:14.849 --> 00:23:17.490
I shall return it back to Dave, and
I hope you guys have a great session.

00:23:17.490 --> 00:23:18.779
Thank you.

00:23:18.779 --> 00:23:24.180
( Applause )

00:23:24.180 --> 00:23:25.519
>> Thanks Vijay.

00:23:25.519 --> 00:23:29.970
Now let's actually dive into the FxPlug
SDK a little bit and talk about the APIs.

00:23:29.970 --> 00:23:35.490
An FxPlug is a form of Pro Plug.

00:23:35.490 --> 00:23:42.829
If you went to the aperture export SDK session earlier --
I think it was yesterday, you learned about another form

00:23:42.829 --> 00:23:51.149
of Pro Plug the aperture exporter Pro Plug and Pro Plug in
turn is a flavor of the NS bundle architecture from Apple.

00:23:51.150 --> 00:23:57.460
With the NS bundle is a pretty generic way of wrapping
up a plug-in and Pro Plug is a little bit more specific

00:23:57.460 --> 00:24:05.190
and FxPlug is an instance and the way that
Pro Plug works is that plug-in classes

00:24:05.190 --> 00:24:09.250
that you implement conform to protocols defined by the SDK.

00:24:09.250 --> 00:24:13.839
So, for example, FxFilter is the
protocol that you would conform to.

00:24:13.839 --> 00:24:20.470
You'd implement all the functions -- the methods
in that protocol in order to implement a plug-in

00:24:20.470 --> 00:24:27.769
and the host application, Motion or Final Cut,
provides objects that conform to host API protocols.

00:24:27.769 --> 00:24:33.150
So between the two the -- the two -- the
Ap and the plug-in are able to communicate.

00:24:34.900 --> 00:24:42.120
Now within the plug-in manager framework which is where
Pro Plugs are hosted we use the Objective C protocols

00:24:42.119 --> 00:24:46.449
and most of you who've gone to sessions
here know that some who are new --

00:24:46.450 --> 00:24:52.930
who are plug-in developers but not necessarily Mac
programers from way back would just need to know

00:24:52.930 --> 00:25:01.509
that there's similar to C++, mix-in inheritance or
Java interfaces and one thing a little more arcane

00:25:01.509 --> 00:25:07.099
that we make use of about protocols is that they are
able to inherit from parent protocols so, for example,

00:25:07.099 --> 00:25:13.519
if you have a parent protocol that defines method one
and a child protocol that inherits from the parent

00:25:13.519 --> 00:25:20.400
but defines method two, you end up with the
child protocol implicitly defining both methods.

00:25:20.400 --> 00:25:25.870
So, if you are going to conform to child protocol,
you need to implement both of those two methods.

00:25:27.390 --> 00:25:34.440
Now, when you define your parameters in an FxPlug,
you do that by implementing one method that is --

00:25:34.440 --> 00:25:42.590
as part of the FxBase effect protocol that's the parent
protocol for the filter, generator and transitions.

00:25:42.589 --> 00:25:52.029
So one of the methods in that protocol is the add
parameters and in your add parameters method you define each

00:25:52.029 --> 00:25:56.779
of your parameters one by one which
adds them to the list, top to bottom,

00:25:56.779 --> 00:26:03.389
and you use methods in a host API
called FxParameter Creation API to --

00:26:03.390 --> 00:26:08.930
to tell the application to add
each parameter to your plug-in.

00:26:08.930 --> 00:26:15.870
So in this case we add a float slider and a
point parameter, and we'll talk about now each

00:26:15.869 --> 00:26:23.049
of the different parameter types, there's a floating
point slider and an integer slider which is the same

00:26:23.049 --> 00:26:34.490
but truncated, check box or toggle button an
angle slider which can go beyond 360 degrees

00:26:34.490 --> 00:26:44.359
and goes counterclockwise, this
is an RGB color and an ARGB color.

00:26:44.359 --> 00:26:51.349
I'll just note that the alpha RGB color is not currently
supported in Final Cut but you can -- if you need that --

00:26:51.349 --> 00:26:56.480
if you need the alpha channel in a color control, you
can implement that by adding a slider for the alpha,

00:26:56.480 --> 00:27:01.890
for example, in the -- in your
parameter list when you sense that the --

00:27:01.890 --> 00:27:07.720
the host is Final Cut, and we have an API for telling
you what the host is or you could use a custom control

00:27:07.720 --> 00:27:16.079
if you want and 2D points are -interesting because
they're sort of a composite parameter type.

00:27:16.079 --> 00:27:23.779
They have the X and Y part and there are a couple of
others that are composite including the RGB and RGBA.

00:27:23.779 --> 00:27:33.180
2D point is also interesting because it implicitly defines
an on-screen control which I'll show you in a moment,

00:27:33.180 --> 00:27:43.799
a pop-up menu where you define strings
for each menu item, an image well which --

00:27:43.799 --> 00:27:53.009
into which a user can drag an image or -- or
other piece of medium and a custom control --

00:27:53.009 --> 00:27:59.740
custom controls I'll talk about in more detail but it's
basically any NS view that you assign to a custom control,

00:27:59.740 --> 00:28:08.759
a group parameter which contains
other parameters and a couple

00:28:08.759 --> 00:28:14.769
of more esoteric ones which are the histogram and gradient.

00:28:16.740 --> 00:28:25.559
Now, when you get values from a parameter, you use the
FxParameter Retrieval API, another host API protocol,

00:28:25.559 --> 00:28:31.919
and you can see there are methods with names
like Get Float Value and Get Int Value and so on

00:28:33.759 --> 00:28:39.339
and similarly there's an FxParameter setting
API for setting the values of parameters.

00:28:39.339 --> 00:28:42.069
You'll use this one less often
but you might use it, for example,

00:28:42.069 --> 00:28:46.700
if one parameter state effects
the values of other parameters.

00:28:46.700 --> 00:28:53.890
You might have a check box that once -- if it says
limit values to from zero to hundred in some slider,

00:28:53.890 --> 00:28:58.090
so when that's checked when you're notified
that it's checked through a change parameter --

00:28:58.089 --> 00:29:04.599
a parameter change method you can then
set the values to clamp to those ranges.

00:29:04.599 --> 00:29:10.500
Now, when you make a custom parameter
UI, you define an NS view.

00:29:10.500 --> 00:29:18.650
You can assign this to a custom parameter that has
some type that you define or you can assign it to any

00:29:18.650 --> 00:29:22.710
of the standard parameters so you -- you may
not like our interface for a point parameter

00:29:22.710 --> 00:29:28.069
or want to do something more interesting with
it, you can make it look the way you want.

00:29:28.069 --> 00:29:31.319
The custom view you define will be placed in the inspector,

00:29:31.319 --> 00:29:36.549
and it is resizable so you should
make it respond correctly as resized.

00:29:36.549 --> 00:29:41.129
In theory it's resizable but that doesn't mean the
host applications will actually let you resize them,

00:29:41.130 --> 00:29:49.930
and you can use any subclass of NS view and
you can make that inside Interface Builder

00:29:49.930 --> 00:29:54.470
or you can create it programatically through your code.

00:29:56.920 --> 00:30:04.080
In order to assign an NS view to a parameter,
custom or standard, you use the normal method

00:30:04.079 --> 00:30:14.049
for creating the parameter but then you set one flag called
the KFxParameter Flag Custom UI and, when that flag is set,

00:30:14.049 --> 00:30:22.720
the host application will call a method that you implement
that's part of the FxCustom Parameter View Host Protocol

00:30:22.720 --> 00:30:30.700
that method is a create view for parm and in that
you simply create an NS view, return that NS view,

00:30:30.700 --> 00:30:35.259
you can retrieve it from your NIB or you can
create it right there as you see in the example.

00:30:37.279 --> 00:30:43.279
When you get an event, you get it the same
way that any other NS view would get it.

00:30:43.279 --> 00:30:49.490
You -- you override the methods in NS view
and NS responder and you get mouse button --

00:30:49.490 --> 00:30:56.180
a mouse button events, you get scroll wheel
events and tablet, angles and eraser events

00:30:56.180 --> 00:30:59.269
or whatever it is that you want to handle.

00:30:59.269 --> 00:31:06.210
You can have contextual menus as well so that when
-- when somebody right clicks on part of your view,

00:31:06.210 --> 00:31:18.190
you can bring up a pop-up menu and the controller for
your view can also change parameter values as I mentioned,

00:31:18.190 --> 00:31:24.490
and you can also change the state of other parameters,
so you can hide other parameters, your check box that --

00:31:24.490 --> 00:31:32.480
that effects other parameters might be one that -- that
hides a whole group and so in your method that tells you

00:31:32.480 --> 00:31:41.259
that the parameter value has changed in this case the check
boxes value you can hide or show other parameters and,

00:31:41.259 --> 00:31:50.460
when you change a value or state to access parameters in
general you need to use the FxCustom Parameter Action API.

00:31:51.880 --> 00:31:58.220
The action API gives you two -- two methods that
let you enter and exit the mode you need to be

00:31:58.220 --> 00:32:03.009
in to access parameters, so this is
start action and end action very simple.

00:32:03.009 --> 00:32:07.440
Also because you're not called by one of
our methods here you're called by the OS,

00:32:07.440 --> 00:32:10.830
you need to find out what the current time
is, because, whenever you access parameters,

00:32:10.829 --> 00:32:13.809
you say give me the parameter value at this time.

00:32:13.809 --> 00:32:18.730
So you call an action API method
called current time to get that.

00:32:21.750 --> 00:32:28.589
Now, in addition to custom parameters -- custom
parameter UI there are also custom parameter types,

00:32:28.589 --> 00:32:33.409
and it can be any type that conforms to NS coding.

00:32:33.410 --> 00:32:38.970
I'll talk about that in a moment but, when you
add a custom parameter to your list of parameters,

00:32:38.970 --> 00:32:44.829
use the add custom parameter with name method and
give it a default value which is of the -- it's --

00:32:44.829 --> 00:32:47.799
it's an instance of the class that
you're using for your default values

00:32:47.799 --> 00:32:52.099
but also set the not animatable in the custom UI flag.

00:32:52.099 --> 00:32:57.990
The not animatable flag is needed
because our Aps don't support Keyframing

00:32:57.990 --> 00:33:02.670
or animating the -- the values of custom parameters.

00:33:02.670 --> 00:33:08.050
Some plug-ins have simulated this by making a custom
view with its own timeline, but it's a bit of work.

00:33:08.049 --> 00:33:12.549
In general we don't explicitly
support animatable custom parameters.

00:33:13.930 --> 00:33:19.269
Another thing is that a custom parameter
-- the class that it -- that it -- that --

00:33:19.269 --> 00:33:23.539
that its values belong to like as I
said have to conform to NS coding.

00:33:23.539 --> 00:33:26.889
Now in previous versions of our host applications you've --

00:33:26.890 --> 00:33:32.600
you've had to use keyed coding which was a little
more complex not much but you needed to do that

00:33:32.599 --> 00:33:37.049
or else your custom parameters wouldn't
actually work and that's changed now.

00:33:37.049 --> 00:33:44.809
You can use any class that implements NS coding like an
NS array conforms to NS coding as long as all the members

00:33:44.809 --> 00:33:50.149
of the array conform to NS coding;
NS string conforms as well.

00:33:50.150 --> 00:33:57.120
In -- in the examples plug-in that we have, the two of
them, the SimpleMatte and SimplePaint we've defined a class

00:33:57.119 --> 00:34:02.269
that uses keyed coding and introduces a
whole new class just for an array of points.

00:34:02.269 --> 00:34:08.329
As an exercise to the reader, you could throw away
that whole class and just use NS array, but --

00:34:08.329 --> 00:34:14.329
but you would still need to use this more complicated
method if you wanted to support older host applications.

00:34:17.530 --> 00:34:22.480
Now when you render you render into an Fx image, the --

00:34:22.480 --> 00:34:25.670
the images that you get through a
parameter well are also images --

00:34:25.670 --> 00:34:29.820
Fx images and those that you get as an input to either a --

00:34:29.820 --> 00:34:36.160
an Fx filter or an Fx transition are
Fx images and that's the base class.

00:34:36.159 --> 00:34:41.309
The two child classes we have of
that are FxTexture and FxBit map.

00:34:41.309 --> 00:34:50.909
FxTexture corresponds to an OpenGL P-buffer
and Fx bit map is a RAM based bit map image.

00:34:50.909 --> 00:34:59.009
The pixel formats that we support are alpha
with RGB and there are three forms of that,

00:34:59.010 --> 00:35:08.350
there's the 8-bit integer ARGB, the 16-bit
float ARGB which is only used on the GPU and --

00:35:08.349 --> 00:35:13.509
so, if you're doing a software only render method, you
don't need to worry about that format just support the 8

00:35:13.510 --> 00:35:20.410
and the 32 and you may also do
YUV and the 32-bit float ARGB.

00:35:22.210 --> 00:35:29.760
The byte ordering is defined by a method in the
Fx image class, so you can find out what the --

00:35:29.760 --> 00:35:37.560
the ordering of those components are -- is,
and YUV or YCBCR images are in two formats,

00:35:37.559 --> 00:35:47.289
one of them is the R408 8-bit form which is defined on
our website this link is in the FxPlug documentation,

00:35:47.289 --> 00:35:54.139
but it's one of the old ice -- ice flow letter number 19
defines R408 as well as a bunch of other interesting things

00:35:54.139 --> 00:35:58.690
and the 32-bit float version of that which is the
same thing but instead of 8-bit values it's float

00:35:58.690 --> 00:36:04.700
and the big thing there is that the floating point values
can go out of range so that you don't have clamping.

00:36:04.699 --> 00:36:09.230
So it's optional to support the YUV formats.

00:36:09.230 --> 00:36:13.150
You'll get better performance in Final
Cut in some cases if you do support them.

00:36:13.150 --> 00:36:19.230
They also -- an interesting thing about
them is they do use premultiplied alpha

00:36:19.230 --> 00:36:23.110
in the YUV format as well as in the RGB formats.

00:36:26.550 --> 00:36:34.360
Now, when you're using textures or P-buffers as inputs
and outputs, you just ask for the coordinate system

00:36:34.360 --> 00:36:40.329
from the texture itself and our Fx textures
are a very thin wrapper for OpenGL textures.

00:36:40.329 --> 00:36:42.719
You can do the normal OpenGL operations with them.

00:36:42.719 --> 00:36:54.329
You use binds and enable and you can get their texture ID
and again they're premultipled just as our bitmaps are.

00:36:54.329 --> 00:37:00.929
We also support retiming of parameters
as well as -- as images.

00:37:00.929 --> 00:37:05.769
With parameters it's easy, whenever you get the value of a
parameter or set the value of parameter, you pass a time.

00:37:05.769 --> 00:37:07.400
So it's explicitly supported.

00:37:07.400 --> 00:37:15.070
We added a new proto -- protocol for getting images at
some specified time and that's the Fx temporal image API

00:37:15.070 --> 00:37:18.289
and in the more recent version we've
added Fx temporal transition --

00:37:18.289 --> 00:37:23.869
temporal transition image API which let's
you get transition inputs at some other time.

00:37:25.420 --> 00:37:33.539
We also added in FxPlug 1.2 methods for getting
information about the timing of your effect,

00:37:33.539 --> 00:37:39.789
about the clip that it's applied to, about the
timeline that it's on and that's the Fx timing API.

00:37:39.789 --> 00:37:44.980
We'll talk more about that in the advanced session
this afternoon, but it's a way of finding out the start

00:37:44.980 --> 00:37:49.719
and end -- or start time and duration
of these different entities of the --

00:37:49.719 --> 00:37:54.759
you can find out the frame rate
and so on, in and out points.

00:37:55.980 --> 00:38:03.409
When you use retiming the Fx timing API protocol to get
images at some time, you can get them in four formats:

00:38:03.409 --> 00:38:07.199
They can be filtered or unfiltered,
they can be textured or --

00:38:07.199 --> 00:38:15.799
textures or bitmaps and so we have four very similar methods
for getting images in any one of those types and Fx the --

00:38:15.800 --> 00:38:20.870
the temporal API for getting transition
images is -- is similar.

00:38:23.659 --> 00:38:29.670
Now our on-screen controls are
implemented as another plug-in.

00:38:29.670 --> 00:38:33.400
It's a way of drawing custom controls in the canvas.

00:38:33.400 --> 00:38:39.470
On-screen controls like our custom parameters
aren't Keyframed things, they're not really --

00:38:39.469 --> 00:38:41.709
they don't even have -- they're
not associated with parameters.

00:38:41.710 --> 00:38:48.220
It's just a control from whose methods you
can set parameter values inside your plug-in.

00:38:48.219 --> 00:38:54.469
So, in general, it's a -- it's a way of drawing
custom controls in the canvas and a simple instance

00:38:54.469 --> 00:39:03.069
of an on-screen control is the built-in point parameter
and there are slightly more complex examples you can see

00:39:03.070 --> 00:39:09.670
and one of them is in the kaleidoscope filter
where there's an angle, an arc control.

00:39:09.670 --> 00:39:15.639
On-screen controls are -- are Motion only
and as Vijay pointed out you should --

00:39:15.639 --> 00:39:21.079
you should provide alternate methods for
controlling parameters that are controlled by --

00:39:21.079 --> 00:39:28.579
by the on-screen controls so that when Final Cut hosts
your plug-in, you'll be able to control those parameters.

00:39:29.760 --> 00:39:35.730
You draw your on-screen controls using OpenGL and they're
composited directly over the window in the canvas,

00:39:36.849 --> 00:39:39.900
and you can use different drawing
coordinates depending on what you're drawing,

00:39:39.900 --> 00:39:45.360
one or the others might make more sense, there
is object window and document coordinate systems.

00:39:45.360 --> 00:39:47.660
You should use anti-aliasing.

00:39:52.480 --> 00:39:57.030
You get the usual mouse and keyboard events,
they're not through NS events or NS responders.

00:39:57.030 --> 00:40:00.910
We have our own methods for letting you know
that an event has happened in on-screen controls

00:40:00.909 --> 00:40:09.029
because we're sensing the -- the region that was
clicked on or the part of your control using OpenGL

00:40:09.030 --> 00:40:14.630
and you can set parameter values
based on the events that you see.

00:40:15.829 --> 00:40:19.940
So in order for us to know what parts
of your controls have been clicked on,

00:40:19.940 --> 00:40:24.829
you need to draw your controls a
second time using the GL select mode.

00:40:24.829 --> 00:40:31.009
It -- using that mode you define a number, an
index for the part that you're about to draw.

00:40:31.010 --> 00:40:36.730
You draw that part not using anti-aliasing and not using
any textures but other than that just as you draw it

00:40:36.730 --> 00:40:44.050
when you're drawing your controls, it's probably the
same method and each part you give a different ID and,

00:40:44.050 --> 00:40:48.330
when we see that a click happens, OpenGL
tells us which part was clicked on.

00:40:48.329 --> 00:40:50.319
So this is very fast.

00:40:52.849 --> 00:41:03.029
In FxPlug 1.2.1 we've introduced a lot of new concepts,
and I'm going to group the new additions to 1.2 with 1.2.1

00:41:03.030 --> 00:41:15.760
since they've both been added since the last WWDC, but they
correspond with the Motion 3 and Final Cut 6 applications

00:41:15.760 --> 00:41:22.530
and with a future application so -- a future version, so
some of these things are not yet defined or supported,

00:41:22.530 --> 00:41:24.810
but I'll -- I'll let you know which ones of those they are.

00:41:24.809 --> 00:41:33.730
When the FxPlug 1.2.1 SDK is downloadable
which will be soon, all of this will be clear.

00:41:35.070 --> 00:41:41.430
The Fx versioning API is new this is really useful
for a plug-in that has already released a 1.0 version

00:41:41.429 --> 00:41:46.480
and now they want to release a 2.0 and they,
you know, in some cases these changes are easy.

00:41:46.480 --> 00:41:50.449
If you just add a new parameter, the host
applications will pretty much do the right thing.

00:41:50.449 --> 00:41:53.379
We'll say look there's a new parameter
-- or I'm sorry, if you create --

00:41:53.380 --> 00:42:00.690
if your user creates a project using your 1.0 version,
saves it and then opens it up again in version 2.0,

00:42:00.690 --> 00:42:06.260
we need to know what to do and, if you've just added
a new parameter, the host application will say, well,

00:42:06.260 --> 00:42:12.370
look there's no -- there's no values saved for this
new parameter, so we used the default values defined

00:42:12.369 --> 00:42:20.929
by the plug-in when it created the parameter, and we'll just
add the default value in unanimated for each new parameter

00:42:20.929 --> 00:42:28.539
and deleted or removed parameter similarly it's
pretty easy to handle but what's harder for us to --

00:42:28.539 --> 00:42:31.369
to handle is, if you've just changed
the way you've rendered,

00:42:31.369 --> 00:42:36.650
maybe you've fixed a bug maybe the output
of your render was -- was too bright.

00:42:36.650 --> 00:42:42.660
So in 2.0 you've fixed that and you've darkened it a
bit but what you don't want to have happen is users

00:42:42.659 --> 00:42:50.289
who use the bright version worked around
that bug by applying a darken filter and now,

00:42:50.289 --> 00:42:53.820
when they open up your projects
using your new plug-in version,

00:42:53.820 --> 00:42:59.690
you don't want to have them seeing an extra dark version.

00:42:59.690 --> 00:43:08.750
So we -- we have the Fx versioning API which let's you
find out the version that a project was saved in --

00:43:08.750 --> 00:43:10.969
I'm sorry, that a project was created in.

00:43:10.969 --> 00:43:15.129
As you save subsequently those
and the version will be the same.

00:43:15.130 --> 00:43:16.610
They'll still have the old version.

00:43:16.610 --> 00:43:22.650
We've added a 3D API for getti=ng the camera and
layer transforms and focal lengths in Motion,

00:43:22.650 --> 00:43:33.599
the timing API I mentioned, the Fx Progress API let's
you report progress on a long render periodically

00:43:33.599 --> 00:43:41.940
and let's you sense when the user has canceled a long
render, and we've added more examples to the FxPlug-in SDK

00:43:41.940 --> 00:43:45.970
and also improved the support in the host applications.

00:43:47.659 --> 00:43:55.559
Okay. So the Fx versioning API, you make this work
by defining a new key in your Info.P list file,

00:43:55.559 --> 00:43:58.590
and it's called version, and you
can give it any index you want.

00:43:58.590 --> 00:44:03.800
It might be an index starting with
1, it might be something else.

00:44:03.800 --> 00:44:07.960
And as I said we -- we remember
the version that your plug-in --

00:44:07.960 --> 00:44:14.720
the version of your plug-in that was used when your
project was created, and you can find out the version

00:44:14.719 --> 00:44:21.599
of a project that's been opened by looking at the
version at creation method in the Fx versioning API.

00:44:21.599 --> 00:44:23.819
They will let you handle backward compatibility.

00:44:23.820 --> 00:44:28.340
You might add a control letting the user decide
whether they want to render the old way or new way

00:44:28.340 --> 00:44:32.030
or do some special thing that you
-- that you think is right.

00:44:32.030 --> 00:44:33.680
We don't handle that automatically.

00:44:33.679 --> 00:44:38.319
We leave it up to you because in some cases
it might make sense, in some it might not.

00:44:38.320 --> 00:44:42.539
The 3D API is Motion only and has four methods.

00:44:42.539 --> 00:44:52.230
You can -- you can find out the camera matrix at transform
at time which returns a 4x4 3D camera transform matrix

00:44:52.230 --> 00:44:59.650
and layer matrix at time tells you the transform that's
been applied to the layer to which your plug-in is applied.

00:44:59.650 --> 00:45:06.170
You can also find the camera's focal length and you
can just query to find out whether a layer is 3D.

00:45:09.329 --> 00:45:20.369
The timing API has timing information about a clip including
the image inputs for a filter or transition plug-in

00:45:20.369 --> 00:45:26.179
and for image wells and you can find out the
start time and duration and the field order.

00:45:27.619 --> 00:45:35.409
For effect timing you can get the times in and out points of
-- of a clip to which your -- your plug-in has been applied.

00:45:35.409 --> 00:45:40.159
You can get the start time and duration like
you can through your clip and the frame rate

00:45:42.320 --> 00:45:45.789
and there's also a time conversion
methods for going between one

00:45:45.789 --> 00:45:50.380
of these different times and another
-- one of these time scales.

00:45:53.380 --> 00:45:59.579
The progress API is really only useful for a plug-in
that does a fairly slow render but, if you do,

00:45:59.579 --> 00:46:05.029
it's really essential and the main thing you use is that
the user has cancelled and you just check that periodically

00:46:05.030 --> 00:46:08.500
to find out if the user has tried to cancel your render.

00:46:08.500 --> 00:46:15.949
You don't need to return an error when
you've been canceled, just abort and return.

00:46:17.300 --> 00:46:25.010
There's another matter for updating your progress and in
theory putting an interesting number in the progress bar

00:46:25.010 --> 00:46:29.580
which is not yet supported but it's
good to implement just in case.

00:46:29.579 --> 00:46:34.579
FxPlug 1.2 introduces four new
examples, previously we had the --

00:46:34.579 --> 00:46:41.719
or in 1.2 and earlier we had SimpleMatte and SimplePaint
showing you how to implement a custom control view

00:46:41.719 --> 00:46:50.359
and on-screen control, but it's not enough, so we've added
one showing how to use the progress cancellation method

00:46:50.360 --> 00:46:55.180
in Fx methods in the Fx progress
API that's called slow solid color.

00:46:55.179 --> 00:47:02.819
It's a very simple plug-in that just very slowly
renders, an options dialogue, an example is, again,

00:47:02.820 --> 00:47:08.970
a very simple one that just puts a custom push button
in the parameter list and, when the user clicks on that,

00:47:08.969 --> 00:47:17.980
it brings up a panel with information and there's a
directional blur example which is more complicated

00:47:17.980 --> 00:47:21.300
and shows a lot of different -- different concepts.

00:47:21.300 --> 00:47:26.870
In particular there's P-buffers and how to handle
the capabilities of a machine for different kind

00:47:26.869 --> 00:47:33.170
of OpenGL features and something called effect
helpers which has all sorts of useful goodies.

00:47:33.170 --> 00:47:39.220
We'll talk about the directional blur example at the
advanced session this afternoon, so I encourage you to come

00:47:39.219 --> 00:47:45.589
and hear about that and also there's a scrolling rich
text example which, again, has lots of different concepts

00:47:45.590 --> 00:47:53.240
and there's a great reference when you're writing a -- a
plug-in that uses some concepts that weren't defined before

00:47:53.239 --> 00:47:58.779
but we have now -- shows you how to handle pixel
aspect ratio, gives you a control to turn on

00:47:58.780 --> 00:48:07.269
or off correct handling of pixel aspect and same thing
for -- for field rendering and shows you how to hide

00:48:07.269 --> 00:48:12.119
and show parameters dynamically and other concepts as well.

00:48:13.619 --> 00:48:19.980
For more information about the FxPlug SDK we have a mail
list, and I encourage everybody to sign up for this.

00:48:19.980 --> 00:48:28.460
It's the best way to talk with other plug-in developers as
well as with Apple engineering, and it's called Pro-Aps-Dev

00:48:28.460 --> 00:48:34.429
and the standard Apple mail lists
sign up you'll see that listed.

00:48:34.429 --> 00:48:42.149
We also have an a mail -- a mail group within Apple
but just a few -- a few Apple engineers read and,

00:48:42.150 --> 00:48:46.550
if you've got something confidential that you
want to talk about, you can use that mail address

00:48:46.550 --> 00:48:52.210
but really you get the best results from
Pro-Aps-Dev, the pressure of having everybody else see

00:48:52.210 --> 00:48:58.079
that we've been asked a question is really
is good for getting us to answer quickly.

00:48:58.079 --> 00:49:02.809
The plug-in SDK -- the FxPlug SDK is
available from connect.apple.com, just sign in,

00:49:02.809 --> 00:49:07.230
look in applications and you'll see FxPlug.

00:49:07.230 --> 00:49:13.260
When the new version is -- is up there, you'll
see it in the what's new or new editions section

00:49:13.260 --> 00:49:20.250
and there's also other documentation
including something for porting your plug-ins

00:49:20.250 --> 00:49:25.440
from other plug-in architectures up on the attendee URL.

00:49:27.719 --> 00:49:36.029
We've a lab open today at the Graphics and
Media Lab downstairs from 2:00 to 6:15, however,

00:49:36.030 --> 00:49:40.070
at the beginning of that we also have a
session about advanced FxPlug development.

00:49:40.070 --> 00:49:46.890
So, if you want to talk about FxPlugs, don't go to the
lab looking for us we'll be up here, same room but,

00:49:46.889 --> 00:49:52.819
if you want to talk about the aperture, export
SDK or XML workflows in Final Cut, then --

00:49:52.820 --> 00:49:57.190
then that's the place to be, but we'll
also be down there after this session.

00:49:57.190 --> 00:50:00.780
It's the advanced session is from 2:00 to 3:15 in this room.

00:50:00.780 --> 00:50:11.090
So to summarize, we've added a bunch of new features
in FxPlug 1.2 and 1.21, and they are, again, retiming,

00:50:11.090 --> 00:50:24.280
3D in Motion, progress and cancellation, plug-in versioning,
timing improvements, improved consistency of plug-in hosting

00:50:24.280 --> 00:50:30.180
and bug fixes and enhancements and
the examples that we talked about.

00:50:30.179 --> 00:50:32.279
So, please join the mail list.
WEBVTT

00:00:14.210 --> 00:00:16.910
>> Good morning, everyone.

00:00:16.910 --> 00:00:18.379
My name is Matthew Formica.

00:00:18.379 --> 00:00:25.640
I'm the 64-bit software evangelist in Apple's Developer
Relations Group, and this is Adopting 64-Bit Programmidng.

00:00:27.660 --> 00:00:30.910
We have three things -- three chunks
that I'm going to talk about today.

00:00:30.910 --> 00:00:36.799
First of all we'll talk about what is 64-bit
computing and what does it mean on Mac OS X;

00:00:36.799 --> 00:00:43.169
second we'll talk about porting tips what are some tips
and tricks in Xcode and in your code that you can use

00:00:43.170 --> 00:00:49.380
to help you transition to 64-bit
computing; thirdly we'll finish up talking

00:00:49.380 --> 00:00:54.260
about API changes to Mac OS X for 64-bit programs.

00:00:54.259 --> 00:01:01.289
Let's start with what is 64-bit
computing really all about anyway?

00:01:02.450 --> 00:01:08.600
Well, 64-bit computing at its most fundamental
level means support for a 64-bit address space,

00:01:08.599 --> 00:01:13.829
support for more than four gigabytes
of virtual memory in a given process.

00:01:13.829 --> 00:01:22.009
In order to address more than four gigabytes you need
64-bit pointers, pointers that are twice as large in size.

00:01:22.010 --> 00:01:29.480
Mac OS X follows the industry-standard LP64 model
which means that longs and pointers are 64 bits

00:01:29.480 --> 00:01:34.359
in size, eight bytes in size in a 64-bit process.

00:01:34.359 --> 00:01:40.269
In order to have a complete 64-bit operating system you
also need 64-bit framedworks and libraries to go with it.

00:01:40.269 --> 00:01:44.789
So we've 64-bitized our frameworks in Leopard

00:01:44.790 --> 00:01:50.920
and on Mac OS X a process is either
32-bit or 64-bit, there's dno mixed mode.

00:01:50.920 --> 00:01:57.109
You can't have a 64-bit applicdation
load up a 32-bit library o2r vice versa.

00:01:58.689 --> 00:02:06.530
The basic process of going 64-bit is actually not all
that different then the process you took to go Universal.

00:02:06.530 --> 00:02:09.270
It's actually just additional architectures in the binary.

00:02:09.270 --> 00:02:14.730
If we look at say 32-bit TextEdit and all
the frameworks and libraries it links against,

00:02:14.729 --> 00:02:19.639
going 64-bit would be to simply add
additional architecture to that binary.

00:02:19.639 --> 00:02:29.169
And that architecture would be for either PowerPC 64 or
Intel 64, and you wouldd still have the 32-bit architec2tures

00:02:29.169 --> 00:02:34.949
in there, so you could imagine that you might have a
three- or even four-way Universal binary now in Leopard.

00:02:34.949 --> 00:02:37.500
And, in fact, that's what we've done
with our frameworks and libraries

00:02:37.500 --> 00:02:45.870
and in Leopard Xcode 3.0 is actually four-way
Universal and runs 64-bit on 64-bit capable Macs.

00:02:48.479 --> 00:02:52.590
Now you may be saying I've been hearing
this 64-bit message for a while, what's new

00:02:52.590 --> 00:02:55.879
in Leopard? Didn't we hear about this in Tiger?

00:02:55.879 --> 00:02:57.460
And the answer is yes, you did.

00:02:57.460 --> 00:03:01.070
We took our first steps towards 64-bit computing in Tiger.

00:03:01.069 --> 00:03:07.250
Tiger provides 64-bit versionsd of our tool chain as
well as lib system and the accelerate frameworks,

00:03:07.250 --> 00:03:14.159
so you can basically do C and C++ non-GUI
applications that are 64-bit in Tigedr.

00:03:15.770 --> 00:03:18.930
This is really useful if you're doing command-line tools.

00:03:18.930 --> 00:03:26.460
Oftentimes in the scientific computing realm 64-bit programs
are just command line, but you can't do GUI applications

00:03:26.460 --> 00:03:34.080
in Tiger that are 64-bit. And so what some applications have
actually done in Tiger is split out their user interface

00:03:34.080 --> 00:03:39.020
from the back end of the program that actually needs
64-bit computing and had them talk to each other

00:03:39.020 --> 00:03:46.939
through interprocess communication. That
works for some applications but not all,

00:03:46.939 --> 00:03:49.439
and so in Leopard we're taking the next step.

00:03:49.439 --> 00:03:56.500
We're enabling higher-level graphical
applications to run 64-bit. Cocoa, Java, X11,

00:03:56.500 --> 00:04:04.159
Core Services-based applications can now all be 64-bit in
Leopdard. And we do this while providing full compatibility

00:04:04.159 --> 00:04:10.560
for 32-bit applications on the platform and --
and this is a key point I want to emphasize,

00:04:10.560 --> 00:04:17.379
Leopard is a single install. There's no special 32-bit
version or a special 64-bit version so you're going to find

00:04:17.379 --> 00:04:24.019
that the adoption rate -- the available market
of 64-bit machines on the platform is quite high

00:04:24.019 --> 00:04:28.589
because every 64-bit capable mdachine
that is running Leopard will be enabled

00:04:28.589 --> 00:04:32.629
to run 64-bit programs, your 64-bit programs.

00:04:32.629 --> 00:04:36.639
Your users won't have to choose to go
out and buy a special 64-bit version

00:04:36.639 --> 00:04:40.889
of the operating system like they
do on some other platforms.

00:04:40.889 --> 00:04:44.930
I should also point out that new and
existing drivers continue to be compatible.

00:04:44.930 --> 00:04:54.269
Users don't have to go out and upgrade all of their drivers
when they get a 64-bit version of the operating system.

00:04:54.269 --> 00:04:58.870
This being said, under the covers there
are some architectural differences

00:04:58.870 --> 00:05:02.579
to how we implemented things on
PowerPC and Intel-based Macs.

00:05:02.579 --> 00:05:04.839
I wanted to go through those briefly.

00:05:04.839 --> 00:05:11.139
On PowerPC the transition to 64-bit actually isn't all
that dramatic from the underlying architecture perspective.

00:05:11.139 --> 00:05:16.339
The number of registers stays the same, number of floating
point registers and vector registers also stay the same,

00:05:16.339 --> 00:05:18.149
and the calling convention remains the same.

00:05:18.149 --> 00:05:22.349
The only thing that really changes
is the general purpose register size.

00:05:22.350 --> 00:05:30.110
It needs to be able to hold a pointer so it goes up
from being four bytes in size to eight bytes in size.

00:05:30.110 --> 00:05:36.120
On Intel-based Macs the changes are a little more drastic,
the number of general purpose registers actually doubles

00:05:36.120 --> 00:05:42.639
from eight to sixteen, of course, their size also
doubles and the number of floating point registers,

00:05:42.639 --> 00:05:47.779
which are also used as vector registers, also doubles
which allows us to take a new calling convention.

00:05:47.779 --> 00:05:50.769
Instead of being stack-based where all parameters are passed

00:05:50.769 --> 00:05:57.310
on the stack we now can take a register-based calling
convention, everything gets -- remains in the registers.

00:06:00.610 --> 00:06:03.090
The calling convention we've implemented, thus,

00:06:03.089 --> 00:06:08.299
for Intel-based Macs is actually a pretty
standard UNIX convention for how this is done.

00:06:08.300 --> 00:06:15.379
It's very similar to how LINUX and other UNIX variants do
things. In fact, it's so similar you can get the basics

00:06:15.379 --> 00:06:18.589
of our implementation by looking at X86-64.org.

00:06:18.589 --> 00:06:25.019
You'll find as you delve into this if you
are an assembly-level programmer actually,

00:06:25.019 --> 00:06:34.870
that 64-bit Intel assembly on Mac OS X is actually very
similar to PowerPC probably more similar than 32-bit Intel.

00:06:34.870 --> 00:06:40.430
So you'll feel fairly comfortable with it.

00:06:40.430 --> 00:06:43.660
Now these more significant changes on Intel-based Macs allow

00:06:43.660 --> 00:06:48.380
for some new possibilities in terms
of behavior and performance.

00:06:48.379 --> 00:06:56.730
More registers on 64-bit Intel-based Macs means more
things are possible. The better calling convention means

00:06:56.730 --> 00:07:02.759
that you get faster compute-intensive code because more
information can stay in registers instead of having

00:07:02.759 --> 00:07:05.019
to make that trip back out to main memory.

00:07:05.019 --> 00:07:11.289
For the same reasons you get faster
access to external functions and globals,

00:07:11.290 --> 00:07:16.780
more information stays in the register, less information
needs to make that slow trip back to main memory.

00:07:16.779 --> 00:07:25.619
Now you still get the same potential downside that you
would with any 64-bit program which is that larger longs

00:07:25.620 --> 00:07:30.100
and pointers means that you've got
more bigger data and less of it can fit

00:07:30.100 --> 00:07:33.040
in the cache so you blow out your cache more easily.

00:07:33.040 --> 00:07:41.240
So what all of this means is that, in summary,
many applications will run slightly faster

00:07:41.240 --> 00:07:47.579
on 64-bit Intel-based Macs regardless of whether they
need the larger address space because they'll get

00:07:47.579 --> 00:07:50.689
to take advantage of that better calling convention.

00:07:54.160 --> 00:08:01.430
Now, it's a 64-bit address space theoretically, but
practically speaking certain chunks are carved out.

00:08:01.430 --> 00:08:07.660
The first four gigabytes for Intel-based Macs is actually
reserved for the kernel and the 32-bit address space,

00:08:07.660 --> 00:08:12.840
so your 64-bit application will actually start
at four gigabytes in memory and go up from there

00:08:12.839 --> 00:08:19.589
to about 128 terabytes, at which point there's actually
a hole in the address space due to hardware limitations.

00:08:19.589 --> 00:08:25.899
At the very top of the address space is a chunk reserved for
the kernel, so really you've got about 128 terabytes to work

00:08:25.899 --> 00:08:31.870
with which we think will keep you for a while.

00:08:31.870 --> 00:08:36.399
Now you've got these four new -- these four
architectures in your binary potentially;

00:08:36.399 --> 00:08:39.699
how is Mac OS X going to decide
which architecture to actually run?

00:08:39.700 --> 00:08:47.009
So Mac OS X is going to try and pick the
right architecture from each Universal binary.

00:08:47.009 --> 00:08:54.049
We're actually going to default to the 64-bit architecture
when it's available and when it will run on a given machine.

00:08:54.049 --> 00:08:57.370
We're going to assume that if you took
the trouble to convert your application

00:08:57.370 --> 00:09:01.639
to 64-bit, you probably want us to run it.

00:09:04.549 --> 00:09:11.649
So this leads to a theoretical problem, if you've got
this four-way Universal binary you take it back to Tiger

00:09:11.649 --> 00:09:15.459
on a 64-bit capable Macintosh,
what's actually going to happen?

00:09:15.460 --> 00:09:19.220
One could imagine that the 64-bit side would try to run,

00:09:19.220 --> 00:09:24.480
the 64-bit higher-level frameworks are not
available and you'd simply crash every time.

00:09:24.480 --> 00:09:31.180
But we have a solution for this, if you build the 64-bit
side of your application with a Mac OS X Deployment Target

00:09:31.179 --> 00:09:36.889
of 10.5, Tiger will recognize this
and actually ignore the 64-bit side

00:09:36.889 --> 00:09:45.449
of your binary to -- falling back to the 32-bit side.

00:09:45.450 --> 00:09:53.350
Now, in most cases defaulting to the 64-bit side of the binary
is the right thing to do, but there's the occasional time

00:09:53.350 --> 00:09:56.889
when the 32-bit side is the right side to run.

00:09:56.889 --> 00:10:03.319
This might be the case if your an application with a lot
of third-party 32-bit plug-ins, the user may actually want

00:10:03.320 --> 00:10:06.730
to load up your application 32-bits
so that they can continue

00:10:06.730 --> 00:10:09.980
to use those plug-ins until those plug-ins transition over.

00:10:09.980 --> 00:10:16.899
Similarly if you're running some Java or Perl scripts
for example and you have some 32-bit native libraries

00:10:16.899 --> 00:10:21.009
or scripts you need to interact
with, you may need to launch 32-bit.

00:10:21.009 --> 00:10:25.870
We have a new posix_spawn API in Leopard
to address this which allows you

00:10:25.870 --> 00:10:31.490
to launch a particular architecture from a particular
binary specifying in the system what should be run.

00:10:31.490 --> 00:10:38.889
And there's a few other additional ways to
customize this behavior in your infoPlist file.

00:10:38.889 --> 00:10:41.809
This is the file that sits alongside your --

00:10:41.809 --> 00:10:46.299
inside your application on disk and tells
the Finder actually how to run things.

00:10:46.299 --> 00:10:53.289
We have a new LSArchitecturePriority key where you can
list the different architectures and this is the order

00:10:53.289 --> 00:10:57.209
that launch services will use to
actually launch things from your binary.

00:10:57.210 --> 00:11:05.460
So if I386 is at the top, the 32-bit Intel
sid2e of your binary will get run by default,

00:11:05.460 --> 00:11:14.139
and it will continue to fall back until it finds one
that is compatible with your hardware and software.

00:11:14.139 --> 00:11:19.740
Similarly we have an LSMinimumSystemVersionBy
Architecture launch services key for your infoPlist

00:11:19.740 --> 00:11:26.350
and this allows you to specify a different minimum
system version for each architecture in your binary.

00:11:26.350 --> 00:11:35.440
So, for example, you may decide that the 64-bit Intel
side of your application runs great on stock Leopard 10.5,

00:11:35.440 --> 00:11:42.070
whereas some particular critical bug that you needed
for 64-bit PowerPC wasn't fixed until 10.5.1.

00:11:42.070 --> 00:11:46.010
So you want to set 10.5.1 as the minimum
system version for that architecture.

00:11:46.009 --> 00:11:51.950
And finally the user gets a choice as well.

00:11:51.950 --> 00:12:00.759
We now in the Leopard Finder actually give you an
Open in 32-bit mode check box in the Get Info panel

00:12:00.759 --> 00:12:08.069
for a given application, so the user can decide
they would rather run this application 32-bit.

00:12:08.070 --> 00:12:16.120
So, if that's what 64-bit computing is on
Mac OS X, how do you actually get there?

00:12:16.120 --> 00:12:20.820
Well, actually, the first question
may be, do you need to get there?

00:12:20.820 --> 00:12:26.990
And there's a couple of answers to this. First of all, if
your application today is running into memory pressure,

00:12:26.990 --> 00:12:33.019
if you're running into cases where you need random access to
more than four gigs of memory or you need every last ounce

00:12:33.019 --> 00:12:39.139
of performance out of the system, particularly on
Intel-based Macs, then now is the time to go 64-bit.
d

00:12:39.139 --> 00:12:43.899
You are the perfect sort of application to go 64-bit today.
d

00:12:43.899 --> 00:12:51.000
If you're not in one of those two camps, now is still the
time to start working on your transition strategy to 64-bit.
d

00:12:51.000 --> 00:12:57.100
64-bit computing is here and you don't want to
be the last 32-bit application in a 64-bit world,

00:12:57.100 --> 00:13:03.139
anymore than you'd want to be the last
16-bit application in today's 32-bit world.

00:13:03.139 --> 00:13:07.509
And for Carbon applications you'll want to
start planning your transition because this --

00:13:07.509 --> 00:13:12.939
for graphical applications will involve
transitioning to a Cocoa user interface.

00:13:12.940 --> 00:13:16.650
And we'll talk about that more in a few minutes.

00:13:16.649 --> 00:13:24.860
I've talked about converting to 64-bit and using one
little word may make it sound easy, it's actually --

00:13:24.860 --> 00:13:28.909
takes a certain amount of work and
there are certain levels of 64-bitness.
d

00:13:28.909 --> 00:13:32.949
It's not really a binary, yes, you
did, no, you didn't sort of switch.

00:13:32.950 --> 00:13:43.210
At the first level is the 64-bit wannabe application, that's
an application that can actually build 64-bit. But simply

00:13:43.210 --> 00:13:47.490
because you can compile your application
64-bit doesn't mean that you're ready to ship

00:13:47.490 --> 00:13:50.759
because it won't necessarily run correctly, in fact,

00:13:50.759 --> 00:13:57.830
most applications the first time they're built 64-bit will
simdply crash right out of the gate as they try and run.

00:13:57.830 --> 00:14:03.690
So you reach novice level when your application
actually can run successfully as a 64-bit application

00:14:03.690 --> 00:14:07.160
without crashing but even this is not sufficient.

00:14:07.159 --> 00:14:13.419
You hit 64-bit apprentice level when you can actually
run with addresses above four gigabytes and that's

00:14:13.419 --> 00:14:21.099
because below four gigabytes the top 32-bits of all pointers
will be zero, and so you may be truncating your pointers

00:14:21.100 --> 00:14:26.480
or have other problems in memory and not even
realize it because you're below four gigabytes

00:14:26.480 --> 00:14:30.289
and you would essentially be leaving
those bugs to be discovered in the field

00:14:30.289 --> 00:14:35.039
when your users use your application
long enough for its memory size to grow.

00:14:35.039 --> 00:14:42.279
You're 64-bit master level when your application can
actually handle more than four gigabytes of data. And that's

00:14:42.279 --> 00:14:44.289
because just because you run successfully

00:14:44.289 --> 00:14:51.579
as a 64-bit application doesn't mean your application's data
structures can actually cope with larger amounts of data.

00:14:51.580 --> 00:14:57.300
Oftentimes when you go through your code you'll find cases
where, you know, particular arrays will have a maximum size

00:14:57.299 --> 00:15:02.620
of short, for example, where you're actually artificially
restricting how much information can be stored

00:15:02.620 --> 00:15:04.029
by your application.

00:15:04.029 --> 00:15:10.360
So you'll need to go through and make those changes
as well. And, finally, your application 64-bit is ready

00:15:10.360 --> 00:15:13.340
to ship when you can do all of this efficiently.

00:15:13.340 --> 00:15:19.550
Sometimes the algorithms that worked really well
in 32-bit don't scale well to 64-bit computindg,

00:15:19.549 --> 00:15:23.740
so you'll need to take another
performance pass over your application.

00:15:27.009 --> 00:15:33.809
The first step towards actually converting 64-bit
and following those steps I just talked about is

00:15:33.809 --> 00:15:41.049
to choose the right architecture in Xcode and this is
very similar to how you would get started going Universal.

00:15:41.049 --> 00:15:47.299
You bring up the architecture's panel and you choose 64-bit.

00:15:47.299 --> 00:15:57.189
Now, I should point out that the architecture's panel in
Xcode when it comes to 64-bit computing actually lies.

00:15:57.190 --> 00:16:03.840
It actually -- what it does is for debug builds
its sets the architecture to $(NATIVE_ARCH_ACTUAL)

00:16:03.840 --> 00:16:06.879
which is the actual architecture
of the machine you're building on.

00:16:06.879 --> 00:16:13.309
And we did this because many users accidently got a --
made a mistake and found themselves building debug builds

00:16:13.309 --> 00:16:19.379
with a Universal binary set, so they were building for
all these architectures they didn't actually really need

00:16:19.379 --> 00:16:23.100
when they were just doing their iterative
development cycle on their own machine.

00:16:23.100 --> 00:16:30.490
So we wanted to help you avoid that mistake, help you avoid
wasting a lot of build time and we setup $(NATIVE_ARCH_ACTUAL)

00:16:30.490 --> 00:16:39.750
as the architecture for debug builds. So the way you handle
this is to change your build configuration to release

00:16:39.750 --> 00:16:44.769
when you want to actually build four-way
Universal or go in and edit the actual text field

00:16:44.769 --> 00:16:49.769
for the architectures build setting and
that will override $(NATIVE_ARCH_ACTUAL).

00:16:51.809 --> 00:16:57.359
Now, just like building Universal you don't
actually have to use Xcode to go 64-bit.

00:16:57.360 --> 00:17:02.629
You can do this at the command line with xcodebuild,
passing in the right architectures,

00:17:02.629 --> 00:17:11.690
PowerPC 64 or X86_64, or you could actually use gcc directly.

00:17:13.069 --> 00:17:19.609
So regardless of how you're developing
on Mac OS X you can go 64-bit.
d

00:17:19.609 --> 00:17:24.649
Now going 64-bit will involve changes to your source code.

00:17:24.650 --> 00:17:31.810
64-bit is not necessarily exactly source compatible
with today's 32-bit programs. However, we expect that,

00:17:31.809 --> 00:17:37.549
once you do the transition to 64-bit computingd,
you'll be able to use the same source base to build

00:17:37.549 --> 00:17:42.700
for both the 32-bit version of your app and
the 64-bit versiond of your application.

00:17:42.700 --> 00:17:48.380
And we have a Cocoa conversion script that I'll talk about
in a few minutes that can help you make this transition.

00:17:48.380 --> 00:17:53.790
When you're trying to get your program compiling,

00:17:53.789 --> 00:17:59.279
the compiler actually has some additional warning
flags you may want to turn on to help you out,

00:17:59.279 --> 00:18:04.190
-Wconversion, -Wshorten-64-to-32, and -Wformat2.

00:18:04.190 --> 00:18:10.519
These can sometimes be a bit verbose or aggressive so
you may not want to try and actually correct everything

00:18:10.519 --> 00:18:14.559
that they suggest you correct, but they'll give you some
good ideas for the sorts of changes you'll need to make

00:18:14.559 --> 00:18:20.579
in your program. And the basic process of
getting your program up and running is

00:18:20.579 --> 00:18:25.549
to get it compiling relatively warning free
and then you're just going to be running it.

00:18:25.549 --> 00:18:26.399
It'll crash.

00:18:26.400 --> 00:18:26.980
You'll debug.

00:18:26.980 --> 00:18:30.089
You'll fix that crash, and you'll go onto the next spot.

00:18:30.089 --> 00:18:34.559
It's a very iterative sort of a cycle.

00:18:34.559 --> 00:18:40.460
Now I talked about the first four gigabytes
being set aside on Intel-based architectures.

00:18:40.460 --> 00:18:44.069
It's worth talking about what happens
on PowerPC-based architectures.

00:18:44.069 --> 00:18:51.149
The linker on Mac OS X is going to try to default to a four
gigabyte pagezero size when building for a 10.5 or later,

00:18:51.150 --> 00:18:55.269
and this is so that you get past that
64-bit apprentice level that I talked about

00:18:55.269 --> 00:18:59.180
and actually have everything working
correctly above four gigs

00:18:59.180 --> 00:19:04.519
The problem is there are some things that force
64-bit PowerPC applications to actually load back

00:19:04.519 --> 00:19:12.629
in that first four gigabytes. And the main one is Xcode's
default, the -mdynamic-no-pic flag to the compiler.

00:19:12.630 --> 00:19:18.270
And this is an important flag on PowerPC to have
on for performance, but what it essentially does is

00:19:18.269 --> 00:19:21.529
to pull your application back down into the first four gigs.

00:19:21.529 --> 00:19:24.799
The other way you get your 64-bit PowerPC app

00:19:24.799 --> 00:19:29.619
in the first gigs is sending a Mac OS X
deployment target of 10.4 earlier.

00:19:29.619 --> 00:19:35.829
So 64-Bbit applications on 10.4
load in the first four gigabytes.

00:19:35.829 --> 00:19:39.139
So what you'll probably want to
do in debugging the PowerPC side

00:19:39.140 --> 00:19:45.620
of your 64-bit application is passing the
pagezero size flag to Xcode and passing

00:19:45.619 --> 00:19:47.699
in four gigabytes as your pagezero size.

00:19:47.700 --> 00:19:52.110
This is essentially blocking out the
first four gigs, forcing your application

00:19:52.109 --> 00:19:57.029
to run higher for your debug testing cycle.

00:19:57.029 --> 00:20:02.180
Then, once you got everything working, you can
remove that. -mdynamic-no-pic will pull your app back

00:20:02.180 --> 00:20:04.250
down into the first four gigs, but you will know

00:20:04.250 --> 00:20:07.970
that you have actually eliminated the
bugs that you may have encountered.

00:20:07.970 --> 00:20:14.529
None of this applies for 64-bit Intel-based applications.

00:20:14.529 --> 00:20:16.460
They all live above four gigs.

00:20:16.460 --> 00:20:20.700
There's no performance advantage to
living in the first four gigs on Intel,

00:20:20.700 --> 00:20:24.100
and so you get good 64-bitness and good performance.

00:20:24.099 --> 00:20:30.619
So how do you find out what the 64-bit
dependedncies in your application actually are?

00:20:30.619 --> 00:20:39.149
You'll probably want to go to terminal and use otool dash
capital L to see the direct dependencies of your binary.

00:20:39.150 --> 00:20:44.900
Here's an example of running it against
one third-party application, and you can see

00:20:44.900 --> 00:20:48.800
that it lists all the things that we actually link against.

00:20:48.799 --> 00:20:52.819
The ones that are highlighted are the
ones that are third-party frameworks.

00:20:52.819 --> 00:20:54.769
The ones that are Apple you don't have to worry about.

00:20:54.769 --> 00:21:00.069
We're going to take care of those, but ones that are
third party are ones that you'll probably need to convert

00:21:00.069 --> 00:21:07.289
to 64-bit, and you can use the file command from terminal
to actually see what architectures a given binary has.

00:21:07.289 --> 00:21:12.159
So here we see that Core Foundation
is, in fact, four-way Universal.

00:21:12.160 --> 00:21:18.320
Now, there are some pitfalls that you're going
to run into as you're converting your code.

00:21:18.319 --> 00:21:24.299
I want to go through some of those. Here's the most common
one, almost every program does this at one point or another.

00:21:24.299 --> 00:21:29.460
You probably will end up finding in your code that
you've been assuming that the size of a void*,

00:21:29.460 --> 00:21:35.850
the size of aPointer, is the same as the size of
an integer. That works fine for 32-bit applications

00:21:35.849 --> 00:21:41.459
where an integer was four bytes and a pointer was four
bytes, but in 64-bit computing, pointers are now eight bytes

00:21:41.460 --> 00:21:47.630
in size, so making this assumption and storing
an eight byte value or trying to anyway

00:21:47.630 --> 00:21:51.840
in a four byte data structure means you're
going to chop off the top half of your pointer.

00:21:51.839 --> 00:21:54.959
The next time you try to jump to that address, you'll crash.

00:21:54.960 --> 00:22:02.809
So here's an example where we're actually
making that mistake and the solution is

00:22:02.809 --> 00:22:08.730
to make sure you're always storing pointers in data
structures that can actually hold eight bytes of data.

00:22:08.730 --> 00:22:17.750
The next problem you may run into is using the wrong
formatting characters, and you may run into this

00:22:17.750 --> 00:22:22.579
if you have printfs in your code, but you may also
run into this if you're doing string processing.

00:22:22.579 --> 00:22:27.009
So %d, for example, can only hold four bytes of data.

00:22:27.009 --> 00:22:33.039
So, if you're trying to print a long in 32-bit, that will
work fine, but in 64-bits longs are actually eight bytes

00:22:33.039 --> 00:22:37.319
in size, so you'll only end up printing
the first half of your number.

00:22:37.319 --> 00:22:46.069
So you need to make sure you use the right
formatting characters, %ld in this case.

00:22:46.069 --> 00:22:48.649
The other case where people run into that is

00:22:48.650 --> 00:22:55.210
with pointers %x only handles the first four
bytes, so you'll want to %p instead.

00:22:55.210 --> 00:23:09.390
The next pitfall you'll probably run into somewhere in your
code is failing to use sizeof(), and here's a good example.

00:23:09.390 --> 00:23:16.870
In this memcpy example we're actually trying to
copy the contents of long value into the address of mem,

00:23:16.869 --> 00:23:22.539
and we're making the assumption that long value is only
ever going to be four bytes in size. That works fine

00:23:22.539 --> 00:23:28.210
in a 32-bit application, but in 64-bits
long value is now eight bytes in size,

00:23:28.210 --> 00:23:32.769
so our code would only end up copying
the first half of the number.

00:23:35.750 --> 00:23:43.589
So the solution to this is to use sizeof() instead, so
your code automatically adjusts to be the right size.

00:23:43.589 --> 00:23:50.699
In the bottom case here we're actually copying the full
eight bytes, but there's another issue you may run into;

00:23:50.700 --> 00:23:56.250
you also have to make sure after you make this change
that the data structures you're actually copying things

00:23:56.250 --> 00:24:00.160
into can now hold twice as much information.

00:24:00.160 --> 00:24:04.610
So you'll need to make a pass through
your buffers and your data structures.

00:24:07.509 --> 00:24:09.589
There's some other tricky cases.

00:24:09.589 --> 00:24:16.490
You know the compiler handles wraparounds and going
negative differently in 32-bit then for 64-bit values,

00:24:16.490 --> 00:24:23.069
so you might end up getting a different
result in 64-bit than you would in 32-bit.

00:24:23.069 --> 00:24:28.950
Here we -- the long value would be negative one
in 32-bit or some really large number in 64-bit,

00:24:28.950 --> 00:24:39.090
so just make sure that you correctly -- correctly type
all the values that you are doing arithmetic with.

00:24:39.089 --> 00:24:43.750
Similarly if you are doing bit-shift operations,
you need to make sure that the constants

00:24:43.750 --> 00:24:47.490
that you use are of the appropriate type.

00:24:47.490 --> 00:24:53.809
You might not get the results you expect unless
you specify that the constants are, in fact, longs.

00:24:53.809 --> 00:24:59.349
So simply using 1 would just simply mean it's a 32-bit 1.
2

00:24:59.349 --> 00:25:05.799
If you do 1U, it's an unsigned
32-bit 1, and the correct thing

00:25:05.799 --> 00:25:10.720
to do would be 1UL to specify that it is, in fact, a long.

00:25:17.990 --> 00:25:21.799
Then, finally, I've run into code
with third-party developers like you

00:25:21.799 --> 00:25:24.379
where you're using the wrong preprocesser macro.

00:25:24.380 --> 00:25:30.470
When you did your Intel transition, you made the
assumption that there would only ever be two architectures,

00:25:30.470 --> 00:25:36.180
and so you have a code that looks like this, where
you say, if it's PowerPC do thus and such, otherwise,

00:25:36.180 --> 00:25:43.269
it must be Intel. That breaks down when
you are, for example, on 64-bit PowerPC.

00:25:43.269 --> 00:25:49.059
It's going to fall into the 32-bit Intel code path.

00:25:50.829 --> 00:25:56.409
So instead you want to use the
right macro for the job at hand,

00:25:56.410 --> 00:26:00.360
and we have macros for all the different
architectures that are available.

00:26:00.359 --> 00:26:08.339
We also have BIG_ENDIAN and LP64 which allow ydou to
check for the actual feature that you care about,

00:26:08.339 --> 00:26:10.970
and this is typically what you want to actually be doing.

00:26:10.970 --> 00:26:16.180
It's good to get out of the game of
trying to have per architecture code,

00:26:16.180 --> 00:26:17.750
instead look for the feature you care about.

00:26:17.750 --> 00:26:23.710
If what you care about is the endianness
of the data, check for that.

00:26:23.710 --> 00:26:31.380
If instead what you care about is whether you are 64-bit or
not, check for that and this helps future proof your code.

00:26:36.829 --> 00:26:41.879
So the summary of all these pitfalls is
basically check your assumptions in your code,

00:26:41.880 --> 00:26:46.490
and you'll need to do a careful inspection
of your code to make sure you aren't assuming

00:26:46.490 --> 00:26:49.220
that things are always going to be 32-bit.

00:26:49.220 --> 00:26:54.960
64-bit coding bugs can be subtle, and it'll probably
take you a fair bit of time just trying to weasel

00:26:54.960 --> 00:27:01.500
out what the actual bug is in a particular chunk of
code. But Xcode in gcc can help your transition with some

00:27:01.500 --> 00:27:05.230
of these warnings and error flags that I talked about.

00:27:08.529 --> 00:27:15.720
Let's talk about API changes next, and I'm curious
which APIs those of you in the audience are using today.

00:27:15.720 --> 00:27:24.240
How many of you would say you're primarily Carbon-based?
And how many of you would say you're primarily Cocoa-based?

00:27:24.240 --> 00:27:31.680
And how many of you are largely command
line or UNIX or some other set of APIs?

00:27:31.680 --> 00:27:38.330
Great. I've got chunks of this API section
for each of you that are in the audience.

00:27:38.329 --> 00:27:43.029
Some overall principles that we
applied when making API changes:

00:27:43.029 --> 00:27:46.109
You may be wondering why did we need to change our APIs?

00:27:46.109 --> 00:27:47.779
The first thing was consistency.

00:27:47.779 --> 00:27:53.299
You know, we had to actually fix our APIs the
same way you need to fix your code to be 64-bit.

00:27:53.299 --> 00:27:58.259
There were cases where our data instructions were wrong
or we were making assumptions about the architecture,

00:27:58.259 --> 00:28:04.059
and so we had to make changes to our APIs so they
could actually scale to hold more data. And this led us

00:28:04.059 --> 00:28:09.899
to impedence match problems, where we want to be
able to take the result of one API and easily pass it

00:28:09.900 --> 00:28:15.870
on as the input to another API, and so making
changes in one part would cause these ripple effects

00:28:15.869 --> 00:28:21.799
through the Mac OS X API set so they
would all continue to work well together.

00:28:21.799 --> 00:28:27.059
And going 64-bit was also an opportunity
for Apple to prepare our APIs

00:28:27.059 --> 00:28:29.899
for the future, and let's talk about what that means.

00:28:29.900 --> 00:28:40.400
We'll start with Carbon. So for Carbon, you
know, every architecture diagram is a summary

00:28:40.400 --> 00:28:46.240
to some degree. This may be the architecture diagram
you think about when you think about Mac OS X.

00:28:46.240 --> 00:28:53.720
If we double click on that though you might more actually
more accurately think about it this way: For both Carbon

00:28:53.720 --> 00:29:02.049
and Cocoa they have a user interface side of their
APIs and a lower-level non-graphical side to their APIs.

00:29:02.049 --> 00:29:10.169
And what we've decided to do for 64-bit on Leopard
is actually bring most of these over to 64-bit, except

00:29:10.170 --> 00:29:21.340
for the Carbon UI portion which is basically HI Toolbox.
And as I talk about this I want to make clear

00:29:21.339 --> 00:29:27.569
that this doesn't affect our 32-bit
APIs for Carbon on Leopard.

00:29:27.569 --> 00:29:32.389
So we're strictly talking about 64-bit
here. And this is a change in message

00:29:32.390 --> 00:29:34.230
for Apple, and I want to admit that up front.

00:29:34.230 --> 00:29:40.599
This is not what you have heard me saying
last year here and even up until recently,

00:29:40.599 --> 00:29:47.199
but the reason we've changed is because as we set out
to actually convert our APIs, including our Carbon APIs

00:29:47.200 --> 00:29:52.980
to 64-bit, we actually learned a lot of things. And as
we worked on this, we realized that even if you brought

00:29:52.980 --> 00:30:00.829
over your Carbon application to be fully 64-bit, you still
wouldn't be able to take advantage of the APIs on Mac OS X

00:30:00.829 --> 00:30:07.240
where Apple is innovating, the APIs where Apple is investing
their resources, and it's important that you be investing

00:30:07.240 --> 00:30:10.849
where Apple is investing which is in Cocoa.

00:30:10.849 --> 00:30:16.309
The second thing that happened was I went on the
road over the last year and talked to a lot of --

00:30:16.309 --> 00:30:22.669
a lot of you and a lot of other developers on
our Leopard TechTalk tour about 64-bit computingd.

00:30:22.670 --> 00:30:29.870
And what became clear was that for many Carbon
applications, not all, but many, going --

00:30:29.869 --> 00:30:36.989
converting and modernizing their 64-bit -- their Carbon
Code to be 64-bit was actually not substantially less work

00:30:36.990 --> 00:30:42.180
in many cases then simply rewriting
the user interface in Cocoa.

00:30:42.180 --> 00:30:51.420
So that's our strategy, and you'll find actually in
the build that you have here at WWDC that those header

00:30:51.420 --> 00:30:56.250
and library changes have not been brought into effect
to make this so, but those changes are coming soon.

00:30:56.250 --> 00:31:04.059
These are some of the APIs that will not be
available to Carbon applications in 64-bit:

00:31:04.059 --> 00:31:12.399
Things like QuickDraw will not be available and the
basic HIView Carbon Drawing System, Window Manager,

00:31:12.400 --> 00:31:19.280
and Appearance Manager, the text processing
system, and some of the other APIs that then depend

00:31:19.279 --> 00:31:24.039
on QuickDraw like Font Manager, AGL, and so on.

00:31:27.430 --> 00:31:32.070
On the other hand, the low-level Core
Services level of APIs will be --

00:31:32.069 --> 00:31:38.659
continue to be available for 64-bit. So the things like CF
Strings, CFArray, and CFBundle will be there. Apple Events,

00:31:38.660 --> 00:31:43.660
Launch Services, and other similar
lower-level C APIs will be there.

00:31:43.660 --> 00:31:48.769
So the basic strategy recommendation for you is
to use the highest level Cocoa API that you can,

00:31:48.769 --> 00:31:53.650
and this will give you the best impedance match with
all the new APIs that are coming out for Mac OS X.

00:31:53.650 --> 00:32:00.130
And it will help you be more insulated from API
changes in the future. And making this change

00:32:00.130 --> 00:32:03.410
to Cocoa is probably, actually, easier than you think.

00:32:03.410 --> 00:32:08.560
As I've been talking to you many of
you this week and over the past year,

00:32:08.559 --> 00:32:14.200
I find that there are some myths
about converting over to Cocoa.

00:32:14.200 --> 00:32:20.390
First of all, developers are a little concerned about
what its going to take to actually learn Objective-C,

00:32:20.390 --> 00:32:25.560
which is the main language used for Cocoa development.
And when they actually delve down into it,

00:32:25.559 --> 00:32:31.470
I find that most developers can pick up Objective-C
within a couple of days and be fairly fluent with it.

00:32:31.470 --> 00:32:36.259
It's not that hard to learn, and it
actually mixes well with C++.

00:32:36.259 --> 00:32:43.900
Through our Objective-C ++ compiler technology you
can actually intermix Objective-C native APIs with Mac OS X

00:32:43.900 --> 00:32:52.100
with C++ code in your source files. And Objective-C
continues to be invested in and enhanced by Apple.

00:32:52.099 --> 00:32:56.199
You've heard a lot about Objective-C 2.0
here at conference this week.

00:32:57.390 --> 00:33:05.300
The second myth that some developers have is
that Cocoa is not as cross platform as Carbon is.

00:33:05.299 --> 00:33:10.669
And something worth thinking about is that your
Carbon code was actually platform specific already.

00:33:10.670 --> 00:33:21.190
Your Carbon APIs did not compile on Windows, so it's
really a matter not of picking a platform neutral GUI API,

00:33:21.190 --> 00:33:29.720
but simply abstracting away the GUI-platform native code
from your C C++ backend code that's cross platform.

00:33:29.720 --> 00:33:38.769
And the third myth that I sometimes hear from
Carbon developers is that Cocoa isn't customizable.

00:33:38.769 --> 00:33:40.839
And this, in fact, is not the case.

00:33:40.839 --> 00:33:46.839
The event system, drawing, controls, user experience,
and so on can all be managed and customized by you

00:33:46.839 --> 00:33:50.709
if necessary in Cocoa just as you can in Carbon.

00:33:54.069 --> 00:33:58.769
So there's two ways that you could as a
Carbon application transition to Cocoa.

00:33:58.769 --> 00:34:04.670
One is to rewrite your user interface only, and this is
great if you're a cross-platform application that wants

00:34:04.670 --> 00:34:08.139
to keep the main logic of your application cross platform.

00:34:08.139 --> 00:34:13.889
So you need to abstract away your user interface
and simply write a new user interface for Mac OS X.

00:34:13.889 --> 00:34:19.710
And a lot of applications do this
today already on the platform.

00:34:19.710 --> 00:34:25.079
Taking this strategy actually means you potentially
have less code to touch all in one step, although,

00:34:25.079 --> 00:34:32.019
going 64-bit means you're going to have to basically
make a pass through all of your code in any event.

00:34:33.250 --> 00:34:38.500
The second approach you can take is to simply rewrite
you whole application, and there are advantages

00:34:38.500 --> 00:34:40.659
and disadvantages to this approach as well.

00:34:40.659 --> 00:34:44.190
The advantage is you gain the development
benefits of Cocoa all the way through.

00:34:44.190 --> 00:34:48.480
You get to use technologies like Cocoa
Bindings, Core Data, and so on that are going

00:34:48.480 --> 00:34:51.679
to really accelerate your development. And you'll be able

00:34:51.679 --> 00:34:56.489
to more easily leverage future Apple enhancements
to Cocoa all through your application.

00:34:56.489 --> 00:35:00.989
If you're starting to take this transitional approach,

00:35:00.989 --> 00:35:04.899
it may or may not be actually longer
to rewrite your application this way.

00:35:04.900 --> 00:35:09.340
You'll find you have better impedance match
between the user interface of your application

00:35:09.340 --> 00:35:12.059
and the non-user interface portion of your app.

00:35:12.059 --> 00:35:16.739
The one tricky part about it is that it's more
difficult at times to keep identical functionality.

00:35:16.739 --> 00:35:21.339
You'll need to take a little more work
probably to do customizations in Cocoa

00:35:21.340 --> 00:35:25.230
to get the exact same functionality as you had before.

00:35:25.230 --> 00:35:30.699
And what's important for Apple to hear from
you about in the Q&A time today and emailing me

00:35:30.699 --> 00:35:37.569
in the future is, is there any APIs in Cocoa where
functionality is missing, where you wanted to do something

00:35:37.570 --> 00:35:39.980
in Carbon, and you're not quite sure how to do it in Cocoa?

00:35:39.980 --> 00:35:51.070
Typically you can, but we want to help you make
that transition and find the right APIs in Cocoa.

00:35:51.070 --> 00:35:56.590
Now Carbon has been transitioning actually for
some years, and today there are a lot things

00:35:56.590 --> 00:36:00.130
that are actually pretty similar between Carbon and Cocoa.

00:36:00.130 --> 00:36:05.599
They're both Universal on Mac OS X, they both use
Nibs, although, they use different Nib formats.

00:36:05.599 --> 00:36:11.819
In Carbon you would use Core Foundation, CFString,
and so on; in Cocoa you would use Foundation

00:36:11.820 --> 00:36:16.120
and APIs like NSString or toll free bridged from CFString.

00:36:16.119 --> 00:36:18.960
So, if you're already using APIs like CFString in Carbon,

00:36:18.960 --> 00:36:23.980
it will be very easy to transition
to their equivalents in Cocoa.

00:36:23.980 --> 00:36:31.389
You'll also find that there is a different imaging
models, but Quartz can be used in either a set of APIs.

00:36:31.389 --> 00:36:35.440
They have their own event handling systems, but they have --

00:36:35.440 --> 00:36:40.570
they both have a view hierarchy system,
HIView in Carbon and NSView in Cocoa.

00:36:40.570 --> 00:36:44.309
So there are basic conceptual paradigms that can transition

00:36:44.309 --> 00:36:49.299
over in your application from the
Carbon side to the Cocoa side.

00:36:50.639 --> 00:36:58.500
And once you make this Cocoa transition, you'll be able to
adopt all the newest technologies and APIs in Mac OS X.

00:36:58.500 --> 00:37:04.929
APIs where Apple is innovating that you've heard a lot about
this week like Core Animation, Core Data, and so on.

00:37:07.869 --> 00:37:14.039
So in summary for Carbon, the graphical
Carbon UI Layer is not available in 64-bit

00:37:14.039 --> 00:37:17.050
but the lower-level Core Services APIs are available.

00:37:17.050 --> 00:37:25.090
So to transition your Carbon graphical application over to
64-bit, you'll need to transition to a Cocoa user interface,

00:37:25.090 --> 00:37:33.300
and we want to hear feedback on if there are missing Cocoa
APIs or Cocoa functionality that would help you transition.

00:37:36.610 --> 00:37:40.090
Next, let's talk about Cocoa.

00:37:40.090 --> 00:37:44.340
For 64-bit Cocoa we've actually
rewritten the ObjC runtime,

00:37:44.340 --> 00:37:48.010
and you've heard a lot about Objective-C 2.0 this week.

00:37:48.010 --> 00:37:49.520
It's a lot faster.

00:37:49.519 --> 00:37:54.579
It's got a new implementation. And it's got new
features like Fast Enumeration and Garbage Collection.

00:37:54.579 --> 00:38:00.400
But what you haven't heard as much about is the fact that
we actually have additional features in Objective-C 2.0

00:38:00.400 --> 00:38:07.139
that are specific to 64-bit binaries, and that's
because there's no binary compatibility restrictions.

00:38:07.139 --> 00:38:13.969
We don't have to maintain compatibility with a bunch
of existing Cocoa 64-bit apps, so we can do even more.

00:38:13.969 --> 00:38:19.669
And so we've done things like made instance
variables non-fragile for 64-bit Cocoa apps.

00:38:19.670 --> 00:38:25.450
We made method dispatching faster and unified
the exception handling model with C++

00:38:25.449 --> 00:38:31.039
so that you can write Objective-C++
code more easily in 64-bit

00:38:33.170 --> 00:38:39.780
For Cocoa there's just a couple key changes that have
to be made to the APIs that ripple through everything.

00:38:39.780 --> 00:38:45.450
And here's the big one. We replaced all the
integers with NSInteger and NSUInteger,

00:38:45.449 --> 00:38:47.319
and these are pointer-sized integral types.

00:38:47.320 --> 00:38:57.570
So in 64-bit they are 64-bits in size, and making this
one change basically fixed nearly all of the Cocoa APIs.

00:38:57.570 --> 00:39:02.260
There were some cases where we had to clean
up our enumeration defines and this is

00:39:02.260 --> 00:39:07.880
because with the gcc compiler they're not predictably
unsigned integer. The compiler actually look

00:39:07.880 --> 00:39:13.599
at what you're enumerating and pick a size based on
that, and we wanted them all to be 64-bit capable,

00:39:13.599 --> 00:39:17.199
so we started actually typedefing them with sizes.

00:39:20.289 --> 00:39:23.420
The other change we made that comes from a change

00:39:23.420 --> 00:39:30.670
in the Quartz APIs is all graphics-related floating point
quantities are now actually CGFloat, instead of just float.

00:39:30.670 --> 00:39:39.130
And CGFloat is a double in 64-bit which allows for future
possibilities of better granularity and better accuracy

00:39:39.130 --> 00:39:49.769
for graphics programming in Mac OS X. There was a couple
of Cocoa classes that didn't make the cut to 64-bit

00:39:49.769 --> 00:39:56.460
that are not available. NSMovie and NSMovieView
are not available, instead you want to use QTKit

00:39:56.460 --> 00:40:00.210
which is the Objective-C QuickTime APIs.

00:40:00.210 --> 00:40:08.199
Similarly NSQuickDrawView is not available; you'll want
to use the Cocoa Drawing System or Quartz directly in 64-bit.
d

00:40:10.829 --> 00:40:15.420
NSMovie -- NSMenuView is a class
that probably none of you used.

00:40:15.420 --> 00:40:17.710
It's used for certain rendering in menus.

00:40:17.710 --> 00:40:22.970
It was used basically just to maintain
compatibility with InterfaceBuilder 2.

00:40:22.969 --> 00:40:29.939
So now we have new NSMenuItem custom view support
that allows you to put custom views in menus.

00:40:29.940 --> 00:40:34.970
And we continue to highly discourage
you from using unkeyed Cocoa archiving.

00:40:34.969 --> 00:40:39.419
It is there in 64-bit, but it'ds going
to give you odd behavior in some cases.

00:40:39.420 --> 00:40:46.180
You really want to be using the
keyed archiver for writing out files.

00:40:46.179 --> 00:40:48.269
We've got the script to help you convert.

00:40:48.269 --> 00:40:51.440
It's in /Developer/Extras/64BitConversion.

00:40:51.440 --> 00:40:56.250
It's a top script, which basically means that it'll
chug through your source code looking for patterns

00:40:56.250 --> 00:41:00.769
and replacing those patterns with new chunks of code.

00:41:00.769 --> 00:41:06.130
So you'll run it against you source code and then
pull up FileMerge to actually see what it changed.

00:41:06.130 --> 00:41:07.750
The script is fairly aggressive.

00:41:07.750 --> 00:41:12.840
You probably don't always want to make the changes it
suggests, but it's another good way to find out what sorts

00:41:12.840 --> 00:41:14.970
of changes you'll need to make to your code.

00:41:14.969 --> 00:41:17.579
You can adjust the script to fit your needs if you like.

00:41:17.579 --> 00:41:22.170
It's a good idea, this should get you thinking
about how you can automate certain changes

00:41:22.170 --> 00:41:24.820
to 64-bit if you have a large source base.

00:41:24.820 --> 00:41:33.340
So the summary for Cocoa is, we have a new runtime
that gives you a variety of new features;

00:41:33.340 --> 00:41:41.070
a few key types change in Cocoa; and we've got this Cocoa
script that can help you in your conversion efforts.

00:41:44.409 --> 00:41:47.989
There are a lot of other APIs in
Mac OS X that don't fit into one

00:41:47.989 --> 00:41:53.719
of the nice graphical UI application
categories that are worth talking about as well.

00:41:53.719 --> 00:41:59.509
First of all, we actually have some new CFBundle and
NSBundle APIs for checking the bundle architecture.

00:41:59.510 --> 00:42:03.050
So instead of having to muck around in
the macro header of a binary to figure

00:42:03.050 --> 00:42:10.620
out what architectures are there, you can now just ask for
which architectures are supported in a given executable.

00:42:12.969 --> 00:42:17.909
The message framework was an obscure
framework for sending emails to mail.

00:42:17.909 --> 00:42:22.579
It's not available to 64-bit applications. Instead
you want to send Apple Events to mail directly

00:42:22.579 --> 00:42:28.900
to send email messages or you might actually try
the Scripting Bridge. I would guess that would work

00:42:28.900 --> 00:42:31.289
as well with the AppleScript supporting mail.

00:42:31.289 --> 00:42:39.269
Java is available for 64-bit for
Intel-based Macintoshes only.

00:42:42.619 --> 00:42:47.069
When it comes to networking, Open Transport
never really worked right on Mac OS X anyway,

00:42:47.070 --> 00:42:50.430
so it's not available as 64-bit applications.

00:42:50.429 --> 00:42:54.699
You should be using CFNetwork or BSD
sockets directly for your networking needs.

00:42:54.699 --> 00:43:01.839
And AppleTalk is not available; use a
combination of TCP/IP and Bonjour networking instead.

00:43:05.889 --> 00:43:11.719
Printing--the CFPlugin Carbon-based
PDE, print dialogue extension

00:43:11.719 --> 00:43:16.369
API is now available -- not available
to 64-bit applications.

00:43:16.369 --> 00:43:20.909
Neither are the Carbon QuickDraw-based printing APIs.

00:43:20.909 --> 00:43:27.629
So instead you should use the new Cocoa-based
print dialogue extension APIs that we've introduced.

00:43:27.630 --> 00:43:33.670
And these give you not only equivalent functionality of what
you had before, but the printing architecture's been extended

00:43:33.670 --> 00:43:37.250
in some exciting new ways as well with this new API.

00:43:37.250 --> 00:43:44.019
There's a header for more information, PDEPluginInterface.h,
and you should write that header name down.

00:43:44.019 --> 00:43:52.880
It's a little hard to find on the system,
but that's where you can look at the APIs.

00:43:52.880 --> 00:43:56.900
And if you want to get information
from PPD files in a 64-bit application,

00:43:56.900 --> 00:44:01.240
you'll need to use CUPS instead of PPDLib.

00:44:03.610 --> 00:44:14.240
QuickTime--QuickTime's C APIs are not available to 64-bit
applications, instead you'll want to use the QTKit APIs,

00:44:14.239 --> 00:44:19.409
the Objective-C QTKit APIs for 64-bit QuickTimde programming.

00:44:19.409 --> 00:44:24.049
And QTKit is a rich modern implementation
of the QuickTime APIs.

00:44:24.050 --> 00:44:26.850
It's not simply a set of Objective-C wrappers on the C APIs.

00:44:26.849 --> 00:44:31.569
It's a fresh code base that's very
powerful and really highly performing

00:44:31.570 --> 00:44:39.210
on Mac OS X. It gives you great impedance match
with the rest of the API set on Mac OS X. Well,

00:44:39.210 --> 00:44:44.829
one thing you can't do in 64-bit that you could do
in 32-bit is get the native QuickTime identifiers.

00:44:44.829 --> 00:44:49.269
You can't ask a QTMovie for its quickTimeMovie
like you could in 32-bit

00:44:49.269 --> 00:44:57.110
because the underlying QuickTime
C APIs are not available to 64-bit apps.

00:44:57.110 --> 00:45:03.300
For drivers and IOKit Development, new and existing drivers
are Leopard compatible, but if you want to take advantage

00:45:03.300 --> 00:45:10.330
of more than four gigs of physical memory, you'll need
to use the new IODMACommand APIs, and additionally,

00:45:10.329 --> 00:45:16.630
if you're writing a custom user client, we've got a
new client API in Leopard to support 64-bit client apps

00:45:16.630 --> 00:45:23.150
to enable easy communication between the
application and your kernel extension.

00:45:25.550 --> 00:45:32.620
Some closing thoughts. Going 64-bit I like to
encourage developers to think of it as an opportunity.

00:45:32.619 --> 00:45:36.569
It's an opportunity to remove old
compatibility hacks from your code.

00:45:36.570 --> 00:45:39.800
You know, if you think about it, if
you're a 64-bit application running

00:45:39.800 --> 00:45:45.430
on Leopard, you know the user's got modern hardware and
they're running a modern OS, so all those workarounds

00:45:45.429 --> 00:45:55.059
for 10.2, all those custom code paths for 10.3, and hacks for
10.4 can all be ripped out of your code. And the other thing

00:45:55.059 --> 00:46:01.880
to think about is that this is an opportunity to prepare
your application to easily adopt the other new technologies

00:46:01.880 --> 00:46:07.530
and APIs you've been hearing about all week in Leopard.
Because a lot of the work you need to do to easily plug

00:46:07.530 --> 00:46:11.600
into those other APIs is the same work
you would need to do to go 64-bit.

00:46:11.599 --> 00:46:20.579
So, in summary, Leopard is a fully 64-bit enabled operating
system, and if you need more memory or max. performance,

00:46:20.579 --> 00:46:24.170
now's the time to go 64-bit. And even, if you don't,

00:46:24.170 --> 00:46:30.280
now's the time to start planning your
transition so you can be 64-bit one day.d

00:46:30.280 --> 00:46:37.530
We talked about how to update your code to be 64-bit
clean, andd one big new message is, if you're Carbon,

00:46:37.530 --> 00:46:40.230
you'll need to transition to a Cocoa user interface.

00:46:40.230 --> 00:46:47.090
I'm the 64-bit evangelist, so you can email me
with further comments after this session.

00:46:47.090 --> 00:46:51.900
We have a variety of bits of documentation
that are available particularly

00:46:51.900 --> 00:46:59.019
on the attendee website, not all of this updated
docs are actually on the Leopard Beta that you have,

00:46:59.019 --> 00:47:03.179
and we also have a 64-bit Lab downstairs
right after this session. So,

00:47:03.179 --> 00:47:08.339
if you don't get your questions answered
here, that would be the place to do that.
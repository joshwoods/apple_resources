WEBVTT

00:00:11.039 --> 00:00:16.289
>>We're going to be talking about Advanced Concepts in
Using the Prototype JavaScript frame work by none other

00:00:16.289 --> 00:00:19.129
than the absolute creator himself Sam Stephenson.

00:00:19.129 --> 00:00:24.269
It's a great pleasure having him here and we really
appreciate him coming down from Chicago to be

00:00:24.269 --> 00:00:28.769
with us this evening and at this time I'd like
to welcome up on stage Sam Stephenson developer

00:00:28.769 --> 00:00:31.329
for 37signals and the creator of Prototype.

00:00:31.329 --> 00:00:32.420
Thank you very much.

00:00:32.420 --> 00:00:39.039
( Applause )

00:00:39.039 --> 00:00:46.960
>>Hi I'm Sam and today I'm going to talk about prototype
and prototype is an open source JavaScript frame work

00:00:46.960 --> 00:00:50.240
that was created a little over 2 years ago.

00:00:50.240 --> 00:00:57.000
It's available for free, licensed under the MIT license
so you can do whatever you want with it and it's built

00:00:57.000 --> 00:01:01.820
on code that's extracted from real world
applications that we build at 37 Signals and that team

00:01:01.820 --> 00:01:08.500
of core contributors builds in their own
applications; so this is real code and our goal

00:01:08.500 --> 00:01:12.680
with prototype is provide a nicer
environment for JavaScript development.

00:01:12.680 --> 00:01:20.550
So we want to smooth out cross browser issues and
provide some things we think JavaScript has left out

00:01:20.549 --> 00:01:25.409
and prototype is not a widget tool kit so
by widgets I don't mean Dashboard widgets.

00:01:25.409 --> 00:01:33.979
You can certainly use prototype in your Dashboard widgets
but it doesn't provide new form controls and things

00:01:33.980 --> 00:01:42.329
like that but rather we think that with
judicious use of HTML and CSS that combined

00:01:42.329 --> 00:01:48.900
with prototype you can make these things much simpler
than...you can make them simpler yourself rather

00:01:48.900 --> 00:01:56.780
than configuring someone else's prepacked widget.

00:01:56.780 --> 00:02:05.390
So in this session I'm going to go over a couple of
APIs; I'll talk about how prototype extends JavaScript

00:02:05.390 --> 00:02:13.960
to make it easier to use and likewise how it extends
the DOM so you can call methods on don elements

00:02:13.960 --> 00:02:21.960
to manipulate your pages and finally I'll talk about
how we put all this together and show one technique

00:02:21.960 --> 00:02:28.300
for delivering interface elements incrementally
using AJAX in your web applications.

00:02:28.300 --> 00:02:38.439
So, this is how prototype fits in with the world;
it lives in the JavaScript interpreter obviously;

00:02:38.439 --> 00:02:45.439
it's a single file so you just include with a script tag
in your web pages and there's several third party libraries

00:02:45.439 --> 00:02:51.579
that build on top of prototype; one of those
is Scriptaculous, provides visual effects

00:02:51.580 --> 00:02:57.460
and there's many other libraries provide behavior and
things like that and then you build your application on top

00:02:57.460 --> 00:03:00.250
of all those and the browsers we support

00:03:00.250 --> 00:03:09.550
in prototype officially are internet explorer
6 and above, Firefox, Safari, and Opera.

00:03:09.550 --> 00:03:17.480
So just to get everybody on the same page I'd like to go
over the JavaScript object model and I'm going to assume

00:03:17.479 --> 00:03:21.590
that you already have basic knowledge of Java
script; you know what the different types are;

00:03:21.590 --> 00:03:26.490
you know how to create a 4 loop and things like that
but I want to talk specifically about the object model

00:03:26.490 --> 00:03:31.740
so that you can understand where prototype is coming from.

00:03:31.740 --> 00:03:38.659
So in JavaScript everything is an object; here we
have an object literal and that's just a collection

00:03:38.659 --> 00:03:45.889
of key value pairs; so we name, Sam; age 23;
location, Chicago and we can assign that to a variable

00:03:45.889 --> 00:03:53.639
so here we're calling that variable person...and
JavaScript lets us access properties on an object

00:03:53.639 --> 00:03:59.139
by using the bracket notation;
so here we're getting the name.

00:03:59.139 --> 00:04:05.139
We can also assign the name using equal operator in
conjunction with the bracket and we can get that back

00:04:05.139 --> 00:04:15.339
and you see the value has changed and likewise we can use
the dot operator to access properties and said values;

00:04:15.340 --> 00:04:26.560
so these are 2 ways to do the same thing...and functions
in JavaScript we can make a function called greet here

00:04:26.560 --> 00:04:34.829
that just returns a string, takes a single argument,
a name, and returns a string using that name;

00:04:34.829 --> 00:04:45.029
so if we call that we get our string back that says, "Hello
Sam" using person dot name, but functions are just values

00:04:45.029 --> 00:04:53.349
in JavaScript so instead of saying function greet we can
make an anonymous function and assign that to a variable

00:04:53.350 --> 00:04:59.310
in JavaScript; so this code is exactly the same
as what we saw before; we're just assigning it

00:04:59.310 --> 00:05:07.019
to a variable explicitly instead of using the sugar
that JavaScript provides...and we can make methods

00:05:07.019 --> 00:05:12.139
in JavaScript by assigning functions
to properties of an object;

00:05:12.139 --> 00:05:19.060
so here instead of making a variable called greet
we're assigning this function to the property greet

00:05:19.060 --> 00:05:26.519
of the person object and then when we call that
function on the person object the value this inside

00:05:26.519 --> 00:05:29.939
of the function refers to that person object.

00:05:29.939 --> 00:05:37.399
So here we don't have to pass any arguments to
the function, we're just calling this dot name.

00:05:37.399 --> 00:05:45.250
And JavaScript provides ways to make object constructors
using functions; so here we've created a constructor

00:05:45.250 --> 00:05:51.759
for person objects that takes 3 arguments, we capitalize
the name of this because that's a JavaScript convention

00:05:51.759 --> 00:05:57.719
and what we do in this constructor, what happens is
if you use this in conjunction with the new operator

00:05:57.720 --> 00:06:05.200
as you can see highlighted what happens is that Java
script creates a new object and then invokes this function

00:06:05.199 --> 00:06:12.339
with this value with that new object; so here we're
assigning all of our properties from the constructor

00:06:12.339 --> 00:06:20.219
to the new object and also assigning a function inside
of that constructor and you can see what we can do using

00:06:20.220 --> 00:06:25.600
that constructor...but this kind of sucks because we have

00:06:25.600 --> 00:06:29.920
to create this greet function every
time we instantiate a new person.

00:06:29.920 --> 00:06:37.750
So JavaScript provides a solution for
that which is called the prototype property

00:06:37.750 --> 00:06:41.740
and every function has this prototype
property and it serves as a template

00:06:41.740 --> 00:06:46.790
for instantiating new instances of this object.

00:06:46.790 --> 00:06:53.120
So we can assign the greet function or anything that's
going to be the same in every new instance of the object

00:06:53.120 --> 00:07:00.350
to the prototype object and then we can
instantiate new people from the person constructor

00:07:00.350 --> 00:07:03.520
without creating that function every time.

00:07:03.519 --> 00:07:13.779
So this is really key; this is how prototype builds on
everything that's built into JavaScript and extends it,

00:07:13.779 --> 00:07:18.419
and I'd like to talk about some of the
language extensions now that we provide.

00:07:21.110 --> 00:07:27.420
So we add functions to all strings in
JavaScript; some of those are matching.

00:07:27.420 --> 00:07:36.000
We can check to see if a sub string is included in
the receiving string; similarly we can check to see

00:07:36.000 --> 00:07:41.629
if the string starts or ends with a given
string; these are available to all strings

00:07:41.629 --> 00:07:45.889
if you're including prototype in your web page.

00:07:45.889 --> 00:07:52.889
We can repeat a string any given number of times;
we can chain these things so we can repeat a string

00:07:52.889 --> 00:07:58.500
and then truncate it; so here the string
will be no longer than 15 characters.

00:07:58.500 --> 00:08:03.750
We can strip leading and trailing white space from a string.

00:08:05.750 --> 00:08:14.850
We can convert plain strings into HTML quoted strings and
we can convert HTML quoted strings back into plain strings.

00:08:14.850 --> 00:08:24.610
We can make replacements on strings; so here we're taking a
regular expression as a first argument; this is called G sub

00:08:24.610 --> 00:08:31.389
and a lot of these functions that you see are
inspired by the Ruby programming language.

00:08:31.389 --> 00:08:37.309
We at 37 Signals used Ruby to build all of our
applications and prototype was built to sort of mirror

00:08:37.309 --> 00:08:42.509
that to provide...to lower the
impedance of switching between languages.

00:08:42.509 --> 00:08:50.419
So G sub is a function that Ruby provides; we've copied that
end prototype and you can take a regular expression here;

00:08:50.419 --> 00:08:55.949
we're looking for ING and we're just
going to replace it with an empty string

00:08:55.950 --> 00:09:04.310
or we can get slightly more complicated;
we can capture all vowels followed

00:09:04.309 --> 00:09:09.169
by 2 non vowel characters and we
can swap their order in a string.

00:09:09.169 --> 00:09:15.019
The second argument to this call is prototype
template and we'll talk about that in a little bit

00:09:15.019 --> 00:09:19.079
but here we're just swapping the order of these 2.

00:09:19.080 --> 00:09:27.930
And G sub also takes an anonymous function for generating
replacements; so here we get the match data passed back

00:09:27.929 --> 00:09:34.509
to the anonymous function and we can do stuff like check
to see if the match is and, turn that into an ampersand

00:09:34.509 --> 00:09:39.539
or otherwise we'll just capitalize the word.

00:09:39.539 --> 00:09:40.199
( Pause )

00:09:40.200 --> 00:09:45.590
And prototype provides lots of
functions for working with arrays also.

00:09:45.590 --> 00:09:55.139
Some of those are navigation; I don't know if
you're like me but you can access array indexes

00:09:55.139 --> 00:10:03.649
by using the array bracket operators obviously so you
could write 1, 2, 3 bracket zero to get the first element

00:10:03.649 --> 00:10:11.949
but I don't like these constancy in my code; I like
more expressive code, so prototype provides first

00:10:11.950 --> 00:10:17.040
and last for getting at those very
common elements of an array.

00:10:17.039 --> 00:10:25.329
It also provides index of which is implemented
in JavaScript 1.6 but not by every browser;

00:10:25.330 --> 00:10:28.400
only in Firefox, I think and maybe Web Kit.

00:10:28.399 --> 00:10:34.069
So prototype provides this for all browsers; you
can get the index of any element in an array,

00:10:34.070 --> 00:10:40.530
shocking that that was left out, I know,
but...we can also transform arrays.

00:10:40.529 --> 00:10:47.970
So here we have nested arrays, if we call
flatten; we get a flat array back.

00:10:47.970 --> 00:10:57.139
If we have an array that has nulls or un-defines in it
we can call compact on it and get a copy of the array

00:10:57.139 --> 00:11:08.549
with those removed and there's a without function that will
return a copy of the array without the value passed to it.

00:11:08.549 --> 00:11:14.219
There's a unique function which returns
all the unique values from the array

00:11:15.799 --> 00:11:19.659
and finally prototype provides lots
of shortcuts for working with arrays.

00:11:19.659 --> 00:11:28.980
So here we have this greet function that we looked at
earlier and JavaScript gives you an object called arguments

00:11:28.980 --> 00:11:36.430
and inside of each function and the arguments is
just sort of like an array that gives you access

00:11:36.429 --> 00:11:39.279
to all the arguments you called the function with.

00:11:39.279 --> 00:11:45.549
So we have this code, we want to get the first
argument or we want to call some other method

00:11:45.549 --> 00:11:50.079
that prototype adds to arrays on the arguments array.

00:11:50.080 --> 00:11:58.160
If we try to run this we get a type error because
arguments is not actually an array in JavaScript

00:11:58.159 --> 00:12:01.980
and there's several objects like this; one is node list.

00:12:01.980 --> 00:12:07.420
If you were to get elements by tag name
from the dot you'll get back something

00:12:07.419 --> 00:12:10.839
that acts just like an array except it's not really.

00:12:10.840 --> 00:12:18.259
So all these methods that prototype adds to arrays
aren't available to things like arguments and node list.

00:12:18.259 --> 00:12:25.939
So to deal with that prototype provides dollar
A and you just wrap your array like thing,

00:12:25.940 --> 00:12:32.610
that is anything that has a length property and can
be accessed by index and it returns a copy of it

00:12:32.610 --> 00:12:37.820
as a real array; so here we can call
first on it; it's now a real array.

00:12:39.529 --> 00:12:48.620
There's also dollar W which is inspired by Ruby and Pearls
percent sign W operator; basically just takes a string

00:12:48.620 --> 00:12:55.580
and splits it on white space so it's
an easy way to create an array of words

00:12:55.580 --> 00:13:02.490
and as you can see you can call all the prototype
methods on those arrays that are returned

00:13:02.490 --> 00:13:13.180
because they are real arrays...and prototype provides some
object introspection methods; so a few of those are inspect

00:13:13.179 --> 00:13:20.109
which returns a JavaScript string representation
of an object; keys which returns an array

00:13:20.110 --> 00:13:31.810
of all the property names of an object and values which
returns the corresponding values of those keys as an array.

00:13:31.809 --> 00:13:37.149
There's also some methods for composing objects.

00:13:37.149 --> 00:13:47.899
Object that extend is probably the most used; it's used
heavily in prototype internally and what it does is copy all

00:13:47.899 --> 00:13:52.889
of the keys and values from the
second object into the first object.

00:13:52.889 --> 00:14:00.919
So here we have an object name, Sam; age 22; we have a
second object age 23; so you can see it has 2 properties

00:14:00.919 --> 00:14:09.339
that are identically named and the values of the second
object are copied into the first and overwrite those values.

00:14:09.340 --> 00:14:18.440
And similarly there's blend which works like extend but
it will not overwrite any properties that already exist

00:14:18.440 --> 00:14:27.200
in the original object and an important note is that
these methods return the same object that you pass,

00:14:27.200 --> 00:14:32.440
the first object so it does modify that
object; it doesn't return a copy of it.

00:14:33.519 --> 00:14:40.860
And just as an example of how we use this in prototype
internally we use it to add methods in bulk to things

00:14:40.860 --> 00:14:46.980
like array dot prototype so all those array methods
you saw earlier are added using object dot extend.

00:14:46.980 --> 00:14:53.279
It provides a nice convenient way to do that.

00:14:53.279 --> 00:14:54.799
( Pause )

00:14:54.799 --> 00:15:06.799
So another module that prototype provides is inspired by
Ruby is innumerable and with innumerable you have your class

00:15:06.799 --> 00:15:12.709
or your object constructor; you can
mix an innumerable into the prototype

00:15:12.710 --> 00:15:20.930
and by implementing a single method you
get an entire suite of iteration functions;

00:15:20.929 --> 00:15:26.209
so prototype adds this to a few
classes already; one of those is array.

00:15:26.210 --> 00:15:32.370
So all of these methods are available to arrays and
we'll show you some examples of using these with arrays

00:15:32.370 --> 00:15:36.500
but you can mix them into your own objects.

00:15:36.500 --> 00:15:43.929
And here's the implementation of the single method that you
have to implement in your own classes; it's underscore each

00:15:43.929 --> 00:15:53.009
and what this does is simply wraps a 4 loop; so it
takes an anonymous function, it's called interrater here

00:15:53.009 --> 00:15:58.350
and invokes it for each element of the array.

00:15:58.350 --> 00:16:06.830
So for these examples I'll use this variable called WWDC
which is an array created using this dollar W syntax

00:16:06.830 --> 00:16:11.550
but it's an array of 4 words, Apple
Worldwide Developers Conference.

00:16:11.549 --> 00:16:21.169
The keystone of innumerable is each
and this is how you invoke each.

00:16:21.169 --> 00:16:27.829
You pass it in anonymous function and that function
is invoked for each element of the innumerable;

00:16:27.830 --> 00:16:34.290
so here we would get 4 pop up dialogs
saying each word in the innumerable;

00:16:34.289 --> 00:16:38.019
so we'd see Apple Worldwide Developers and Conference.

00:16:38.019 --> 00:16:49.399
And this anonymous function also has an optional index
parameter so if you want to get the index you can just add

00:16:49.399 --> 00:16:56.929
on a second parameter and then our alerts would
say Apple, Zero, Worldwide One, and so on.

00:16:56.929 --> 00:17:04.230
And it also provides control flow mechanism so
sometimes say we want to break out of a loop

00:17:04.230 --> 00:17:08.210
but we can't use the JavaScript break
command inside of an anonymous function;

00:17:08.210 --> 00:17:14.509
so what we have to do here is throw a
special exception prototype gives you;

00:17:14.509 --> 00:17:18.839
this object called dollar break
and this will let you break out.

00:17:18.839 --> 00:17:28.029
So here we say if index is greater than 2 throw a
break; so here we would only see the first 3 alerts

00:17:28.029 --> 00:17:36.250
and you can do this in any innumerable function not
just each...but where the real power comes in is

00:17:36.250 --> 00:17:41.019
when you can transform arrays or innumerable.

00:17:41.019 --> 00:17:49.660
So one way to do that is with Map and here in
this case the anonymous function is just going

00:17:49.660 --> 00:17:57.340
to return the first character of each element in the
innumerable and then we get back as a return value

00:17:57.339 --> 00:18:05.929
of Map an array of all those returned values; so here we get
the first letter of each element or we can also do something

00:18:05.930 --> 00:18:16.019
like get the length of every word...and it turns out doing
stuff like that, accessing a property for each element

00:18:16.019 --> 00:18:21.579
of an innumerable is pretty common; so prototype
provides a shortcut for doing that, it's called pluck

00:18:21.579 --> 00:18:27.679
and pluck is just Map that accesses each elements property.

00:18:27.680 --> 00:18:32.140
So here we're getting the length of each
element in a more convenient fashion.

00:18:32.140 --> 00:18:34.300
We don't have to create this anonymous function.

00:18:34.299 --> 00:18:38.529
( Pause )

00:18:38.529 --> 00:18:47.259
And we can also call methods on these so here
we're truncating each element to a size of 4

00:18:47.259 --> 00:18:53.029
and again like the pluck this is a pretty
common thing to do on a collection of elements.

00:18:53.029 --> 00:18:59.759
So prototype gives you invoke and invoke takes a
string which is the name of the method you want to call

00:18:59.759 --> 00:19:02.680
on each element and you can optionally
pass any other arguments;

00:19:02.680 --> 00:19:09.390
you would pass to that method and
you'll get the values back.

00:19:09.390 --> 00:19:16.680
Innumerable lets you search through innumerable
objects pretty easily; find will return the first value

00:19:16.680 --> 00:19:25.180
in an innumerable that matches or rather for
which the anonymous function returns true.

00:19:25.180 --> 00:19:32.769
So the first word with length 10 in this
example is developers and we can use find all

00:19:32.769 --> 00:19:36.879
to get all of those matching the given condition.

00:19:36.880 --> 00:19:44.840
So all of the words of lengths 10 returns an array
developers and conference and we can also use grep

00:19:44.839 --> 00:19:52.329
to take an irregular expression and find all
elements that match that regular expression.

00:19:52.329 --> 00:19:59.049
So here anything with an L followed by a
vowel...that would be Apple and Developers.

00:20:00.549 --> 00:20:07.970
Finally there's max and min; so you return some
value, some computed value in your anonymous function

00:20:07.970 --> 00:20:11.829
and prototype gets you the max or the min value.

00:20:11.829 --> 00:20:18.009
( Pause )

00:20:18.009 --> 00:20:26.279
There's some functions for matching elements in
innumerables so if you want to check to see if an array

00:20:26.279 --> 00:20:35.910
or any innumerable includes certain element pass
it to include and you get true or false back.

00:20:35.910 --> 00:20:36.670
( Pause )

00:20:36.670 --> 00:20:40.630
We can also check to see whether all
elements match a certain condition;

00:20:40.630 --> 00:20:47.170
so if we want to see if all elements are longer than
4 characters, that's true but if we check to see

00:20:47.170 --> 00:20:55.570
if all elements are longer than 5 characters, that's
false and similarly there's any which returns true if any

00:20:55.569 --> 00:20:57.929
of the elements match the given condition.

00:20:57.930 --> 00:21:05.210
So here there is an element to match in which the
first character is a W but there's not an element

00:21:05.210 --> 00:21:15.600
in which the first character is an X. There's some sorting
capabilities built into innumerable so you can sort

00:21:15.599 --> 00:21:23.679
by a given anonymous call back here so we're looking
for, in this case, we want to sort by word length;

00:21:23.680 --> 00:21:28.070
turns out the elements are already sorted by
word length here but we can flip that around

00:21:28.069 --> 00:21:31.629
and sort by the inverse word length
and we'll get our elements back

00:21:31.630 --> 00:21:38.980
in reverse order...or we can do something silly
like pass map dot random as the interrater

00:21:38.980 --> 00:21:41.539
and get the elements back in random order.

00:21:41.539 --> 00:21:50.500
You can compose things very easily
using innumerable so the zip method

00:21:50.500 --> 00:21:54.450
in innumerable takes 2 innumerables and combines them.

00:21:54.450 --> 00:22:02.860
So here we're going to pluck the length of each element of
the innumerable; we've got 1 array for that so that's 5, 9,

00:22:02.859 --> 00:22:08.639
10, 10 and then we're going to take that and
zip it back into the original innumerable;

00:22:08.640 --> 00:22:15.370
so now we have a new array returned in which each
element is an array containing the original value

00:22:15.369 --> 00:22:17.059
and the length of that value.

00:22:17.059 --> 00:22:23.450
And there's inject which is sort of like
the Swiss army knife of innumerable.

00:22:23.450 --> 00:22:29.259
It takes an initial value, in this case we're
passing zero and then that value is passed,

00:22:29.259 --> 00:22:37.329
the anonymous function is invoked for each element of
the innumerable and sum here will start out as zero

00:22:37.329 --> 00:22:46.579
and then for each successive invocation of the anonymous
function will be the return value, the previous invocation.

00:22:46.579 --> 00:22:54.669
So here we're accumulating a value; we're summing
up the lengths of all the words and we get 34.

00:22:54.670 --> 00:22:58.170
You can do lots of stuff with inject;
this is just a simple example.

00:22:59.470 --> 00:23:06.360
So you get all this stuff for free if you implement a
single method and we saw arrays implementation was 2 lines

00:23:06.359 --> 00:23:11.179
but you can do this in your own classes and get
all this stuff for free and one such case of doing

00:23:11.180 --> 00:23:15.269
that is prototypes object range internally.

00:23:15.269 --> 00:23:22.589
So object range lets you specify a start and
end value and it'll give you an innumerable

00:23:22.589 --> 00:23:25.019
that lets you access all the values in between.

00:23:25.019 --> 00:23:29.430
So here we're saying new object range from
1 to 10 and then we're going to convert it

00:23:29.430 --> 00:23:33.210
to array and 2 arrays provided by innumerable.

00:23:33.210 --> 00:23:38.660
So we get an array of all the values from
1 to 10...and we can also just call inject

00:23:38.660 --> 00:23:40.779
on that without converting it to an array first.

00:23:40.779 --> 00:23:48.519
So here we're summing up all the values from
1 to 100...we can also use it with strings,

00:23:48.519 --> 00:23:54.579
so here we're getting every letter
from A to Z. You can implement yourself

00:23:54.579 --> 00:24:03.269
in your own types just a single method again that
returns the next value and you can use your own objects

00:24:03.269 --> 00:24:10.230
with object range...and the preferred way to use object
range is with dollar R because it's much shorter.

00:24:10.230 --> 00:24:17.029
So here this is the same thing as saying new
object range but we're just saying dollar R one ten

00:24:17.029 --> 00:24:23.410
and here we're mapping each value in
the range to that number of asterisks.

00:24:24.619 --> 00:24:33.519
And prototype provides a simple way of doing
string interpolation with the template object.

00:24:33.519 --> 00:24:40.420
So here we're creating a new template, we pass it a string
and we've got these funny little hash brace things

00:24:40.420 --> 00:24:49.970
and inside of those we put a name; name, age, and location
in this case and these refer to properties that are going

00:24:49.970 --> 00:24:53.930
to be substituted back into the string when evaluated.

00:24:53.930 --> 00:24:55.700
So we can use it like this.

00:24:55.700 --> 00:25:01.779
We create a template and then we call evaluate on it and
we can pass it any object; we can pass it an object literal

00:25:01.779 --> 00:25:05.940
if we want, such as we're doing in
this case and then we get a string back

00:25:05.940 --> 00:25:15.680
with those values substituted in...and we can call
the same template object on any number of objects.

00:25:15.680 --> 00:25:18.940
So here we're using a different object literal

00:25:18.940 --> 00:25:26.620
and we're getting a different value back...and
finally prototype provides a little wrapper

00:25:26.619 --> 00:25:35.669
around the constructor pattern we saw earlier and
it looks like this; it's called class dot create

00:25:35.670 --> 00:25:42.710
and basically let's you move your constructor
behavior into the constructors prototype.

00:25:42.710 --> 00:25:47.299
So you can move all that behavior
into a function called initialize

00:25:47.299 --> 00:25:55.289
and then what class dot create does is returns a new
function that when instantiated with a new operator calls

00:25:55.289 --> 00:26:03.379
that objects initialized method; so it's just a, again,
just a way to lower impedence when you're switching back

00:26:03.380 --> 00:26:07.160
and forth between languages like
we often do in web programming.

00:26:07.160 --> 00:26:17.779
It's not intended to be a full implementation of class
based programming but it's a very simple way to...not have

00:26:17.779 --> 00:26:19.899
to think about what you're doing to much.

00:26:19.900 --> 00:26:28.490
So now I want to talk about how prototype extends a DOM
We just talked about how it extends JavaScript itself

00:26:28.490 --> 00:26:37.650
and we what we do in JavaScript most of the time is work
with DOMe elements so it's nice to add lots of things

00:26:37.650 --> 00:26:41.550
that we feel that DOM left out
and that's what prototype does.

00:26:42.740 --> 00:26:54.339
So the W3C DOM level 2 HTML specification defines all of
these different objects for referring to the different tags

00:26:54.339 --> 00:27:03.439
in HTML and in a perfect world it would be really,
really nice if we could just take these objects,

00:27:03.440 --> 00:27:10.920
access their prototype property and add methods to
them but unfortunately it's not a perfect world.

00:27:10.920 --> 00:27:14.720
We have to deal with internet explorer.

00:27:14.720 --> 00:27:15.700
( Laughter )

00:27:15.700 --> 00:27:24.610
So as you can see here internet explorer doesn't let us
modify these at all; it doesn't even give us access to them.

00:27:24.609 --> 00:27:30.619
Opera gives us access to HTML element dot
prototype so we can add methods to all elements

00:27:30.619 --> 00:27:33.359
but we can't add methods to individual tags.

00:27:33.359 --> 00:27:39.949
So we can't say like, "I want a
method on a P tag or a form tag."

00:27:39.950 --> 00:27:44.549
Firefox does give us access to everything.

00:27:44.549 --> 00:27:51.190
Safari that ships with Tiger only gives us access
to all elements; so it's better than nothing

00:27:51.190 --> 00:27:55.529
but it could be better; fortunately it's fixed in Leopard.

00:27:55.529 --> 00:28:02.950
Safari 3, Web Kit we have access to
prototypes of all the individual tags.

00:28:02.950 --> 00:28:13.140
So prototypes solution to this problem of not being
able to add methods by default is to introduce the idea

00:28:13.140 --> 00:28:22.090
of the extended element and here's
an example of how we might do that.

00:28:22.089 --> 00:28:28.309
You'd call document dot get element by ID to get some
DOM element and we want to call it prototype method on it

00:28:28.309 --> 00:28:35.429
but if we're using internet explorer we would
get a type error because that method won't exist.

00:28:35.430 --> 00:28:44.620
So we can call element dot extend on that element and
then if we try to call that method we'll get a value back

00:28:44.619 --> 00:28:49.069
and what element dot extend does
is similar to object dot extend.

00:28:49.069 --> 00:28:51.960
It'll copy all of the methods that
prototype catalogs internally

00:28:51.960 --> 00:28:58.240
for these objects and return the element extended.

00:28:59.279 --> 00:29:07.789
Now if you're only developing for Firefox and
Safari 3 you don't have to worry about this stuff.

00:29:07.789 --> 00:29:16.019
All elements are automatically extended for you
but...most of the time you need a cross browser solution;

00:29:16.019 --> 00:29:23.819
so what you do in this case is make sure every DOM element
you use in prototype passes through prototype somehow,

00:29:23.819 --> 00:29:31.509
passes through one of our query functions and you'll
always get an extended element back from prototype.

00:29:31.509 --> 00:29:35.779
So you never need to call element extend yourself basically.

00:29:35.779 --> 00:29:45.079
So, one of the keystones of prototype itself is the
dollar function and this let's us...this is a shortcut

00:29:45.079 --> 00:29:50.139
for get element by ID essentially but again
it always returns an extended element.

00:29:50.140 --> 00:30:01.980
So here we're getting, we can see this DOM tree on the left;
here we're getting the DIV with ID article 4 or the element

00:30:01.980 --> 00:30:10.950
with ID comment 1...but the really nice thing about
dollar is that you can pass it a DOM object as well.

00:30:10.950 --> 00:30:16.710
So if you don't know what, if you want to write functions
that take either a string or a DOM object all you need

00:30:16.710 --> 00:30:23.779
to do is call dollar on that argument and it
doesn't matter whether someone passes a DOM element

00:30:23.779 --> 00:30:28.869
or a string you'll always get an element back.

00:30:28.869 --> 00:30:35.769
We can also query by CSS3 selector
and to do that we use dollar, dollar.

00:30:35.769 --> 00:30:40.670
So dollar is for a single element and
dollar, dollar is for multiple elements.

00:30:40.670 --> 00:30:50.410
So a simple CSS selector would just be a tag name, in this
case dollar, dollar, DIV will give us all the DIV tags

00:30:50.410 --> 00:30:55.740
or DIV dot content will get those with class name content.

00:30:55.740 --> 00:31:03.200
We can also do some advanced queries like
finding all DIVs with class name comment

00:31:03.200 --> 00:31:13.740
who have an immediate child that's an age 3 with
class name author or something like this where we say,

00:31:13.740 --> 00:31:19.460
"All P tags that are the second child
of the parent element," there's only one

00:31:19.460 --> 00:31:24.920
of those here and these work in all browsers.

00:31:24.920 --> 00:31:36.660
So IE barely supports CSS1 but you can use CSS3 selectors
anywhere you can run prototype and in Firefox, Opera,

00:31:36.660 --> 00:31:44.650
and Web Kit these CSS3 selectors are compiled into
X path expressions; so they're really, really fast,

00:31:44.650 --> 00:31:52.070
especially in Web Kit; they're incredibly
fast...but sometimes that's not enough.

00:31:52.069 --> 00:31:59.700
Sometimes we have a reference to an element but we want
to get another element in relation to that element;

00:31:59.700 --> 00:32:06.370
so to do that prototype provides a whole suite
of functions, again; one of those is down.

00:32:06.369 --> 00:32:09.979
If you call down with no arguments you
get the first child of the function

00:32:09.980 --> 00:32:15.920
and if you've ever programmed a DOM before you
know you get these things called text nodes,

00:32:15.920 --> 00:32:21.720
if you use the built in DOM manipulation
functions and they're a pain in the ass.

00:32:21.720 --> 00:32:25.860
You usually never want text nodes,
you just want the DOM elements.

00:32:25.859 --> 00:32:27.579
So prototype only gives you DOM elements.

00:32:27.579 --> 00:32:29.929
You don't have to worry about text nodes.

00:32:29.930 --> 00:32:35.090
So here you won't get a white space text
node; you'll just get the first element,

00:32:35.089 --> 00:32:41.659
that's the child of the DIV with ID article 4.

00:32:41.660 --> 00:32:49.400
Similarly there is up which returns a parent
element and these also take CSS3 selectors;

00:32:49.400 --> 00:32:58.930
so you can say up body dot article to get the body if
it has class name article and these are nice to use

00:32:58.930 --> 00:33:09.230
in conditionals; so if you want to say for instance
"Am I on a page in which the body has class foo"

00:33:09.230 --> 00:33:13.329
and in this case it doesn't so it returns undefined.

00:33:13.329 --> 00:33:18.159
You can use this in a conditional because
undefined works like false and any other value works

00:33:18.160 --> 00:33:21.650
like true or any DOM element works like true.

00:33:21.650 --> 00:33:29.230
So you could say "if comment one up body dot
foo" and then do something based on that.

00:33:30.779 --> 00:33:37.440
And we can combine dollar, dollar with innumerable

00:33:37.440 --> 00:33:40.970
to get some pretty powerful constructs;
so here's one example of that.

00:33:40.970 --> 00:33:47.460
We're getting all DIV elements with class name
content and then we're invoking previous on that

00:33:47.460 --> 00:33:57.819
so we're getting all the previous elements from DIVs
with class name content or we can get all H2 elements

00:33:57.819 --> 00:34:05.279
and get all the next DIVs from those H2s.

00:34:05.279 --> 00:34:12.230
There's functions for manipulating class names in
prototype; so the DOM gives you a single string to work with

00:34:12.230 --> 00:34:16.889
but that really sucks when you have
multiple class names on a single element.

00:34:16.889 --> 00:34:24.069
So prototype gives you functions for working with those
and one of those is has class name which returns true

00:34:24.070 --> 00:34:27.260
or false based on whether or not
an element has a given class name.

00:34:27.260 --> 00:34:33.580
You can add a class name; if that class name
is already there it doesn't get repeated;

00:34:33.579 --> 00:34:36.769
so here we're adding a class name to this element.

00:34:36.769 --> 00:34:42.259
We can toggle class names; so this
element already has a class name content.

00:34:42.260 --> 00:34:48.470
If we call toggle on it with content that
class name goes away; otherwise it's added

00:34:48.469 --> 00:34:52.839
and we can also remove class names explicitly.

00:34:52.840 --> 00:35:02.640
And I found that I don't want to give a number but a good
bit of my DOM manipulation is simply adding and removing

00:35:02.639 --> 00:35:08.839
and checking to see whether or not elements have class
names; so this is very powerful because you can move a lot

00:35:08.840 --> 00:35:15.510
of your logic into CSS just by doing
this; so these are nice tools to have.

00:35:15.510 --> 00:35:22.180
We can check to see whether or not elements are visible;
this is done with the simple convention and that's whether

00:35:22.179 --> 00:35:31.460
or not the element has an inline style property;
the inline display style property specifically.

00:35:31.460 --> 00:35:36.389
So here we have this element and we
want to see whether it's visible or not

00:35:36.389 --> 00:35:40.429
and it is because it doesn't have an inline style property.

00:35:40.429 --> 00:35:44.949
If we call hide on it prototype is
going to set that inline style property

00:35:44.949 --> 00:35:51.730
so this is what the element would look like...and
then if we call visible on that we get false back

00:35:51.730 --> 00:35:56.289
and we can also show it again and
then that style property goes away.

00:35:59.159 --> 00:36:05.710
There's also some functions for working with
element attributes and read attribute is a wrapper

00:36:05.710 --> 00:36:11.000
around the DOMs built in get attribute function
that works around some cross browser issues;

00:36:11.000 --> 00:36:19.230
again in IE which often returns utterly
insane values for certain attributes

00:36:19.230 --> 00:36:23.809
but here we're just showing how you can
read an attribute, get the value back.

00:36:23.809 --> 00:36:32.769
You can also use these because these are real functions
in IE again get attribute is not a real function

00:36:32.769 --> 00:36:39.000
so you can't use it in conjunction with
invoke; it's some sort of native function;

00:36:39.000 --> 00:36:41.699
anyway you can use read attribute with invoke.

00:36:41.699 --> 00:36:46.939
So here we're getting all the A elements
and getting their HREF values.

00:36:46.940 --> 00:36:49.300
( Pause )

00:36:49.300 --> 00:37:03.700
And this also works with XHTML bullion values so
XHTML likes us to say disabled equals disabled.

00:37:03.699 --> 00:37:11.730
So prototype works with that; you can read attribute on
some bullion and you'll get null back if it doesn't exist

00:37:11.730 --> 00:37:15.210
which would be like false in a conditional.

00:37:15.210 --> 00:37:23.780
If you use write attribute the corresponding
function to set a bullion value we can pass true

00:37:23.780 --> 00:37:29.490
and you can see that's automatically
converted into the right value for HTML.

00:37:29.489 --> 00:37:35.000
If we call read attribute on that again we get a
string back and that string will evaluate to true;

00:37:35.000 --> 00:37:41.059
so you can again use these in conditionals
very simply and again we can write values back;

00:37:41.059 --> 00:37:45.130
so if we write false for bullion that value just goes away.

00:37:45.130 --> 00:37:53.309
There's some functions for working with elements
styles and these will actually fall back to CSS.

00:37:53.309 --> 00:37:59.219
They'll read inline styles and styles that you
set with CSS and a style sheet or a style tag;

00:37:59.219 --> 00:38:09.859
so here we've set font size on H2s and if we find an H2
called get style on that we get the right value back.

00:38:09.860 --> 00:38:18.450
Similarly there's set style which takes an object
collection of key value properties so we can set any number

00:38:18.449 --> 00:38:22.819
of styles all at once or we can just set
a single one; here we're setting the width

00:38:22.820 --> 00:38:32.330
to 350 pixels...and finally there's some functions for
working with DOM content and we like to do this with HTML.

00:38:32.329 --> 00:38:40.949
So prototype lets you put HTML anywhere in the DOM,
very easily, especially relative to given elements.

00:38:40.949 --> 00:38:48.169
So here we're going to find this H2 that says
comment title and we're going to call update on it

00:38:48.170 --> 00:38:53.460
and what update does is replaces the elements in your HTML.

00:38:53.460 --> 00:39:03.490
So here we're just replacing that with a string
fragment of HTML that inserts a span tag and you can see

00:39:03.489 --> 00:39:06.579
when this is called this is what happens.

00:39:06.579 --> 00:39:07.269
( Pause )

00:39:07.269 --> 00:39:21.130
You can also insert HTML...HTML fragments so here we have
an A tag followed by a DR in a string and if we call insert

00:39:21.130 --> 00:39:28.230
on this element it's going to go at the bottom
but we can also say that we want it to go

00:39:28.230 --> 00:39:40.440
at the top...or we can put it before or after an element
and this is where before and after go and these all work

00:39:40.440 --> 00:39:43.929
with HTML...and finally we can replace elements outright.

00:39:43.929 --> 00:39:50.989
So instead of just replacing their content, we actually
remove the element from the DOM and insert a new fragment

00:39:50.989 --> 00:39:54.719
of HTML generated from the string in place.

00:39:54.719 --> 00:40:02.739
So that's what that looks like...and we can
also create elements very easily with prototype.

00:40:02.739 --> 00:40:10.279
So we can use a new element constructor; we give it a tag
name and we can optionally give it any attributes we want

00:40:10.280 --> 00:40:18.950
to set on that tag and then we can use real DOM
elements with all of these functions we showed earlier.

00:40:18.949 --> 00:40:26.139
So here's an example of using it with insert instead
of specifying a string we are just using real HTML,

00:40:26.139 --> 00:40:31.089
a real DOM element here...and there's the image.

00:40:32.880 --> 00:40:39.420
Finally you can add your own methods to
elements in prototype and it's very easy to do.

00:40:39.420 --> 00:40:48.619
So here's an example of adding 2 methods to all elements,
dim and brighten, and these will just change the opacity

00:40:48.619 --> 00:40:58.549
and you can see an example of how you might call those in
an element and you can also add methods to individual tags.

00:40:58.550 --> 00:41:05.360
So here's an example of how we might a method called disable
with to all input tags and you might call that something

00:41:05.360 --> 00:41:14.300
like this, get a form, go down and find the first submit
button in that form and disable it with some string.

00:41:15.409 --> 00:41:25.549
So you can do this all yourself, add your own
application specific methods and it's very simple to do.

00:41:25.550 --> 00:41:33.430
So now I'm going to talk about how you can put
all this stuff together and deliver your interface

00:41:33.429 --> 00:41:39.699
in your web application incrementally using AJAX...and
this is just one technique for doing AJAX stuff.

00:41:39.699 --> 00:41:46.939
There's many, many techniques but this is a simple one
that I found works really, really well because in my day

00:41:46.940 --> 00:41:50.150
to day work I really don't like to write JavaScript.

00:41:50.150 --> 00:41:52.849
I prefer to write Ruby.

00:41:52.849 --> 00:42:00.130
So I try to keep JavaScript as dumb as possible and
fortunately our prototype helped me out with that.

00:42:00.130 --> 00:42:08.650
So AJAX, the term stands for a synchronies
JavaScript in XML and the XML presumably comes

00:42:08.650 --> 00:42:16.490
from the XML HTTP request object around which
this is based but it's a pretty poor name

00:42:16.489 --> 00:42:21.589
because we can send any data along; it's
just a wrap around each HTTP request.

00:42:21.590 --> 00:42:30.880
So prototype likes to think of this as a synchronies Java
script end HTML and I'll explain what I mean in a little bit

00:42:30.880 --> 00:42:36.070
but first I'd like to show you how you
can make a simple request in prototype;

00:42:36.070 --> 00:42:48.410
so we instantiate the AJAX dot request constructor, pass it
a URL and you can pass it a set of options; so we can say,

00:42:48.409 --> 00:42:51.769
"I want this to go out as a get request."

00:42:51.769 --> 00:42:57.780
By default it's a post and you can
say "When this request completes,

00:42:57.780 --> 00:43:06.540
say synchronies I want to just show a
pop up dialog with the return value."

00:43:06.539 --> 00:43:07.800
So this is pretty basic stuff.

00:43:07.800 --> 00:43:11.890
I'm not going to go over the whole
AJAX request and update or APIs.

00:43:11.889 --> 00:43:20.839
There's a lot of stuff you can do but I want to
focus specifically on what prototype provides

00:43:20.840 --> 00:43:26.269
which is automatic JavaScript evaluation and
this is all provided if you use default options

00:43:26.269 --> 00:43:32.150
and configure your serve side language to
deliver things in the proper way...and if you do

00:43:32.150 --> 00:43:39.030
that you can just make a simple AJAX request
to a URL, that would look something like this,

00:43:39.030 --> 00:43:47.200
again using all of the default options and if your
response has a content type of text/JavaScript

00:43:47.199 --> 00:43:55.329
and contains JavaScript code when that response comes
back AJAX dot request will automatically evaluate

00:43:55.329 --> 00:44:00.670
that job de-script in that context of the window.

00:44:00.670 --> 00:44:06.539
So this is powerful stuff; this lets us
generate JavaScript programmatically;

00:44:06.539 --> 00:44:12.599
as you can see this stuff would be pretty easy to
generate in any language; it's just...you know,

00:44:12.599 --> 00:44:14.869
you're working with elements and
you're calling methods on them.

00:44:14.869 --> 00:44:25.339
Here we're removing class name; we're replacing an element
in HTML with a string of HTML; we might use Scriptaculous

00:44:25.340 --> 00:44:34.880
to highlight that element and we can do any number of
things...but sometimes you need to pass some data along

00:44:34.880 --> 00:44:43.010
with the request and to do that we need
to serialize a form more often than not.

00:44:43.010 --> 00:44:48.170
So you can do that with prototype
pretty easily, make a new AJAX request

00:44:48.170 --> 00:44:52.740
and use a parameters option and then serialize some forms.

00:44:52.739 --> 00:44:57.739
So here we have a form with ID form and we're
just going to call this serialize method on it

00:44:57.739 --> 00:45:04.759
and here's some sample data you might
get back; it's just your in coded string

00:45:04.760 --> 00:45:12.820
and amazingly JavaScript doesn't provide a way
to get that string from a form but prototype does

00:45:13.900 --> 00:45:19.030
and that's...that's okay but we can make this better.

00:45:19.030 --> 00:45:23.450
We can just fill this information into our form tag itself.

00:45:23.449 --> 00:45:32.239
So if we have our form set up with an action, a method
parameter, and an on submit handler we can just say

00:45:32.239 --> 00:45:39.109
that when this form is submitted we want it to go over AJAX
and we do that by calling the request method on a form;

00:45:39.110 --> 00:45:52.450
this is added to all extended form elements in prototype
and this is the same as the example we saw before...this,

00:45:52.449 --> 00:45:59.739
you can just write it like this, right in your
form tag and this also lets you degrade gracefully;

00:45:59.739 --> 00:46:02.349
so if the user doesn't have Java
script enabled this is just going to go

00:46:02.349 --> 00:46:07.610
out as a regular HTTP request, a page load rather.

00:46:09.300 --> 00:46:18.289
So, in the past...well let me just say that when we're
creating interface elements on the web typically we're going

00:46:18.289 --> 00:46:29.460
to have common operations and that's create, read, update,
and destroy and there's HTTP verb equivalence of all

00:46:29.460 --> 00:46:40.230
of these methods; post, get, put, and delete but in the past
we really haven't had access to those put and delete verbs

00:46:40.230 --> 00:46:49.880
and we've only been able to make post request
by submitting forms but XML HTTP changes that;

00:46:49.880 --> 00:46:56.910
prototype solves some cross browser compatibility issues
with that also but now what it amounts to is we have acces

00:46:56.909 --> 00:47:04.750
to all these verbs and so we can use these
in our application to simplify our code.

00:47:04.750 --> 00:47:14.789
So I'm going to talk about a specific interface element;
this one is from an application we released a few months ago

00:47:14.789 --> 00:47:22.550
at 37 Signals called High Rise which is a shared
contact manager and the element that I'm going to talk

00:47:22.550 --> 00:47:31.460
about is the task widget, so to speak, and this is what
the default view looks like; this is in the side bar

00:47:31.460 --> 00:47:37.500
of every page in High Rise and you can click
this button and get a nice little form here

00:47:37.500 --> 00:47:45.909
for adding task...and one way we could write this
is by writing a whole lot of JavaScript for each

00:47:45.909 --> 00:47:53.349
of the different states of the form building these elements
by creating the DOM elements internally with a bunch

00:47:53.349 --> 00:48:01.619
of JavaScript but really we have to render this stuff
anyway as HTML because they're showing up on page loads.

00:48:01.619 --> 00:48:09.529
So we already have this server side code that generates
the form and we don't really want to duplicate this stuff;

00:48:09.530 --> 00:48:20.350
so prototype is a strong adherent to the dry mantra,
don't repeat yourself, and one of those ways is

00:48:20.349 --> 00:48:30.860
by embracing enter HTML, the update method that you saw
earlier that prototype provides and what we do is we,

00:48:30.860 --> 00:48:38.599
at least in Rales, an easy way to generate all this
stuff on the server side using partials and partials are

00:48:38.599 --> 00:48:45.059
like little pieces of HTML and the entire
application is built around using these partials.

00:48:45.059 --> 00:48:51.079
So we can send these down the wire over
XML HTTP request and in conjunction

00:48:51.079 --> 00:48:57.039
with the 4 ACTP verbs we get a restful
approach to creating interface elements.

00:48:57.039 --> 00:49:03.380
So I'm just going to show you sort
of how we put that together.

00:49:03.380 --> 00:49:12.599
So there's many different states of this
control; one of them is, well you can set a time,

00:49:12.599 --> 00:49:21.719
so when we click this set a time link what happens
internally, this is all very dumb JavaScript;

00:49:21.719 --> 00:49:30.509
we're just setting the value of a hidden field and then
we're making an XML HTTP request and this is going to post

00:49:30.510 --> 00:49:36.710
to task/new and you can think of this as a resource.

00:49:36.710 --> 00:49:44.570
So you might want to think of this a blank sheet of
paper or a form that's printed out on a piece of paper

00:49:44.570 --> 00:49:49.240
and we're going to post some data back to that
and we're going to say, "Let's change your state."

00:49:49.239 --> 00:49:56.289
So what happens is we get some JavaScript back; it's
got the content type of text/JavaScript and it's going

00:49:56.289 --> 00:50:00.519
to re-render the form and that's it; that's
all you have to do in the JavaScript side.

00:50:00.519 --> 00:50:05.480
The JavaScript is just serving as
glue to put all this stuff together.

00:50:05.480 --> 00:50:17.490
So here we've added, we've set this hidden form value and
now the Ruby knows to generate...a little time widget.

00:50:17.489 --> 00:50:27.359
Similarly we can change when this task is due; as
soon as we make a change to this select element,

00:50:27.360 --> 00:50:34.820
we post again to task/new and we get a little
calendar back; so we're changing the states.

00:50:34.820 --> 00:50:41.850
We don't have any JavaScript here that renders a calendar;
this is all done on the server side and it's very,

00:50:41.849 --> 00:50:47.650
very simple to do in Ruby and you're
probably more comfortable with doing this

00:50:47.650 --> 00:50:51.680
on your own server side languages
rather than writing JavaScript.

00:50:51.679 --> 00:50:54.369
So we think this is a good way to do it.

00:50:54.369 --> 00:51:02.289
The HTML coming back down, the form gets re-rendered
and whenever you click on...well when we change months,

00:51:02.289 --> 00:51:09.179
for example, we're just going to make another request;
this is setting a form value, re-serializing the form,

00:51:09.179 --> 00:51:19.309
making that an XML HTTP request and we get the next
month back...and if we click on any of those dates,

00:51:19.309 --> 00:51:25.789
what we're going to do is set it a hidden field and
we'll talk about that in a second but let's go back

00:51:25.789 --> 00:51:31.000
and look at how this looks when we actually add a task.

00:51:31.000 --> 00:51:42.510
So if we type something into this description field here
and we click the add task button we're going to make a post

00:51:42.510 --> 00:51:49.820
to task; now here we're posting to a different
resource because we're not just re-generating the form;

00:51:49.820 --> 00:51:54.160
we're actually submitting this and saying,
"I want you to go in and create a new task."

00:51:54.159 --> 00:51:57.079
So our resource here is a collection of all tasks.

00:51:57.079 --> 00:52:02.840
The verb is post and what we're doing is saying,
"Take this data that we're serializing from this form,

00:52:02.840 --> 00:52:11.750
post it to this resource, and give me a new task back" and
on our server side we take that and we just close the form,

00:52:11.750 --> 00:52:17.670
we send some JavaScript back down the wire
to close the form, essentially hiding it,

00:52:17.670 --> 00:52:27.860
and re-rendering this containing element to show the new
tasks and again we have to do this on every page load

00:52:27.860 --> 00:52:31.269
because these task are shown on each page.

00:52:31.269 --> 00:52:40.259
So we already have Ruby code for generating this list
of tasks in HTML and we don't want to duplicate it;

00:52:40.260 --> 00:52:45.740
so by using enter HTML, by using
prototypes update method and combining

00:52:45.739 --> 00:52:51.589
that with a restful approach we make it really,
really simple to only write your code once.

00:52:51.590 --> 00:53:01.210
If we mouse over this element...we get this little nub end
on the left and this gives us a delete and a change link

00:53:01.210 --> 00:53:06.860
and the way this works is by a little bit of JavaScript
that looks to see what element you're mousing over

00:53:06.860 --> 00:53:15.990
and adds a class name to it and then this nubiness is always
visible in the HTML but we use CSS to hide or show it.

00:53:15.989 --> 00:53:19.979
So there's an example of how you can use the
add, remove class name stuff in prototype

00:53:19.980 --> 00:53:28.570
to really simply modify your page
and separate your behavior into CSS.

00:53:28.570 --> 00:53:37.269
So if we were to click the delete link you would
actually make and XML HTTP request using the delete verb

00:53:37.269 --> 00:53:44.349
to the resource that we just added here and
the URL to that resource would be task/4.

00:53:44.349 --> 00:53:52.259
Four is just some ID but it's a unique URL representing
that single task; I'm not actually going to delete it.

00:53:52.260 --> 00:53:57.880
I'm going to show you what it looks
like when you go to edit a task.

00:53:57.880 --> 00:54:04.960
So if we click on this change link we're going to make
a get request because we're not modifying anything here;

00:54:04.960 --> 00:54:10.610
we just want to get a resource and
that resource is the edit screen.

00:54:10.610 --> 00:54:18.320
You can think of it as a screen or form or piece of paper or
whatever but it's a resource belonging to that single task

00:54:18.320 --> 00:54:28.480
and when we do that we add a class name right after we
make the request to the containing element called busy

00:54:28.480 --> 00:54:34.500
and that shows a little throbber so we get a progress
indicator; we do this on all AJAX request actually

00:54:34.500 --> 00:54:40.309
but I'm just showing you here, showing another example
of how you can use class names to separate out behavior

00:54:40.309 --> 00:54:47.150
like that; so we're showing a throbber and when that
response comes back we get our form rendered again;

00:54:47.150 --> 00:54:54.300
again this is all rendered with Ruby, inserted
right into the DOM using prototypes update method

00:54:54.300 --> 00:55:00.260
and this is our edit resource and it looks
like the form we saw earlier except we're going

00:55:00.260 --> 00:55:03.670
to be changing existing object.

00:55:03.670 --> 00:55:11.130
So we can change the due date again; if we do
that we're making a post to...we're posting back

00:55:11.130 --> 00:55:16.440
to the same edit screen so we're not posting
like we did before to the new tasks resource;

00:55:16.440 --> 00:55:25.909
we're posting to the edit resource...we get a
calendar...and if we click on a specific date,

00:55:25.909 --> 00:55:33.000
this is setting a hidden field in the form and
then if we were to submit that form it's going

00:55:33.000 --> 00:55:41.409
to serialize all the values of the form including that
hidden field and the date changes and then it's reinserted

00:55:41.409 --> 00:55:46.679
into the DOM; this is all re-rendered again using
that code we've already written on the server side.

00:55:46.679 --> 00:55:49.279
So the JavaScript again is very, very dumb.

00:55:49.280 --> 00:55:55.410
All it's doing is gluing this stuff together and it
makes it really, really easy to write this stuff.

00:55:56.429 --> 00:56:00.559
Finally let's look at what happens when you complete a task.

00:56:00.559 --> 00:56:06.579
Well we just have a little form in there and actually we
don't have a form; we're just passing a parameter along;

00:56:06.579 --> 00:56:15.250
so we pass a parameter along with our AJAX request that
tells it the task is completed; we add a class name, busy,

00:56:15.250 --> 00:56:22.739
and again we're re-using that class name that we used to
show the throbber earlier but this time we're just going

00:56:22.739 --> 00:56:30.309
to show it struck out and then the response comes
back and after 5 seconds that element is faded out.

00:56:30.309 --> 00:56:35.539
So that's an example of how you can use all this stuff
in your applications; again there's many ways to do it

00:56:35.539 --> 00:56:42.639
but I find the enter HTML method is a simple way to reuse
code and to not have to think much about JavaScript at all

00:56:42.639 --> 00:56:48.759
and you can find all this stuff and more documented
on the prototype web site at prototypejs.org.
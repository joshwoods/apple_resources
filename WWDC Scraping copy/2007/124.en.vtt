WEBVTT

00:00:19.510 --> 00:00:25.150
>> Peter: Hello, I'm Peter Edburg, and I'm going to give you
just a brief introduction to the presentation before we get

00:00:25.149 --> 00:00:27.750
into the actual meat of the presentation.

00:00:27.750 --> 00:00:32.320
SO what we're talking about here are
the core internationalization services

00:00:32.320 --> 00:00:35.079
that are used by both Cocoa and Carbon.

00:00:35.079 --> 00:00:39.629
And these consist of elements in several different
layers, part of several different frameworks.

00:00:39.630 --> 00:00:42.670
This is designated by the yellow in the slide.

00:00:42.670 --> 00:00:46.539
And they extend all the way from
core foundation up through Carbon.

00:00:46.539 --> 00:00:49.780
Now AppKit is sitting on top of all of this.

00:00:49.780 --> 00:00:53.230
It actually uses some of the internationalization
services from Carbon.

00:00:53.229 --> 00:00:57.239
And so if you're a Cocoa developer and you
want standard internationalization behavior,

00:00:57.240 --> 00:01:00.280
you get that by default from Cocoa applications.

00:01:00.280 --> 00:01:05.260
If you want something that's beyond standard
behavior, or if you're a Carbon developer,

00:01:05.260 --> 00:01:12.020
then you may need to call these services directly
and it's for you that we're directing this session.

00:01:12.019 --> 00:01:18.519
Now we're not talking about all the pieces in all the
frameworks, we're really focusing on a couple of areas.

00:01:18.519 --> 00:01:22.379
One are the internationalization services
at the CF, or core foundation, layer.

00:01:22.379 --> 00:01:24.189
That's the bottom part of the diagram.

00:01:24.189 --> 00:01:30.090
And we're also going to be speaking a little bit
about some of the services in the Carbon layer.

00:01:30.090 --> 00:01:36.070
The services in the core services layer are mostly
deprecated and we'll be talking about that in a minute.

00:01:36.069 --> 00:01:39.359
And the ones in the application services
layer are mostly about text layout

00:01:39.359 --> 00:01:42.819
and those are covered in the core text session later today.

00:01:44.799 --> 00:01:51.859
Okay, so what we're going to be focusing
on are the modern services.

00:01:51.859 --> 00:01:53.150
And what do we mean by modern?

00:01:53.150 --> 00:01:55.210
Well, there are two key aspects of these.

00:01:55.209 --> 00:01:59.869
One is that they use Unicode and another
is that they are available in 64-bit.

00:01:59.870 --> 00:02:05.170
There are some other services and we're going to be
providing some guidelines on how to shift away

00:02:05.170 --> 00:02:09.180
from using the deprecated services
like the script manager and so on.

00:02:09.180 --> 00:02:11.069
Now what are the important reasons for doing this?

00:02:11.069 --> 00:02:15.000
Well, of course, one of the key issues
is that you can use Unicode text.

00:02:15.000 --> 00:02:20.560
And this is not just so that you can display
(inaudible) form or some more obscure scripts in Unicode.

00:02:20.560 --> 00:02:25.090
Unicode text actually provides a lot of
characters for East Asian languages, for example,

00:02:25.090 --> 00:02:28.319
that were not available in the legacy Mac encodings.

00:02:28.319 --> 00:02:32.060
It also means that all characters are always available.

00:02:32.060 --> 00:02:38.189
In the Mac encoding, for example, some characters, and
not necessarily ones associated with specific languages

00:02:38.189 --> 00:02:40.840
or scripts, were only available in certain context.

00:02:40.840 --> 00:02:45.319
For example, the registered sign was in
MacRoman, but it was not in MacJapanese.

00:02:45.319 --> 00:02:49.069
So if you happened to be drawing text
with MacJapanese, you didn't have that.

00:02:49.069 --> 00:02:51.810
The contoured integral is in MacJapanese, not in MacRoman.

00:02:51.810 --> 00:02:54.300
And these are not specifically
things you think of as associated

00:02:54.300 --> 00:02:59.320
with either Japanese or the Western European languages.

00:02:59.319 --> 00:03:03.969
Another big advantage for using the modern services
that we'll be focusing on is it gives you access

00:03:03.969 --> 00:03:10.979
to more languages and localees and it also gives you
a more standard way of designating those languages

00:03:10.979 --> 00:03:15.469
and localees using the language tagging
facilities described by BCP 47.

00:03:15.469 --> 00:03:23.250
Of course another reason for using the modern APIs is
there they ones that we're focusing development on.

00:03:23.250 --> 00:03:30.129
They work better, we're fixing more bugs in them, they also
support the new system initiatives that you've heard about,

00:03:30.129 --> 00:03:33.960
so 64-bit and resolution independence and so on.

00:03:33.960 --> 00:03:39.980
Now there are some cases where we haven't completely filled
in all the functionality that you might need with one

00:03:39.979 --> 00:03:42.399
of our modern APIs that we're focusing on.

00:03:42.400 --> 00:03:45.879
In some cases we have some transitional
APIs that fill these gaps.

00:03:45.879 --> 00:03:50.319
And these transitional APIs typically do
support Unicode, but they may not, for example,

00:03:50.319 --> 00:03:54.169
represent strings using CS strings and so on.

00:03:55.479 --> 00:03:58.759
Okay, now I'm not going to go through
this diagram in great detail.

00:03:58.759 --> 00:04:01.449
You'll get a copy of this later.

00:04:01.449 --> 00:04:05.429
But this is just to give you a sense
of what that things are in which category.

00:04:05.430 --> 00:04:07.939
What's deprecated, transitional and modern?

00:04:07.939 --> 00:04:14.659
And so for example, for the text utilities area,
what's deprecated is certainly the script manager

00:04:14.659 --> 00:04:19.550
and the legacy encodings associated
with it, the old international

00:04:19.550 --> 00:04:24.090
and text utilities, language analysis manager and so on.

00:04:24.089 --> 00:04:27.949
In the modern category we have a lot of
services at the core foundation layer.

00:04:27.949 --> 00:04:33.629
And you'll be hearing about those, CFlocalee,
CFCalendar, CFDateFormatter, and so on.

00:04:33.629 --> 00:04:39.790
Now an example of something that's in the
transitional category would be use of Unicode utilities

00:04:39.790 --> 00:04:42.850
to get a collation key if you wanted to do optimized sorting

00:04:42.850 --> 00:04:46.990
and Deborah will be describing a
little bit more about that later.

00:04:46.990 --> 00:04:52.930
That's something we haven't got
available in the CF Domain at this point.

00:04:52.930 --> 00:04:56.750
Okay. So the topics that we're going to be
covering in this presentation are these.

00:04:56.750 --> 00:05:02.290
The three middle categories on this slide
are things that are all new for Leopard.

00:05:02.290 --> 00:05:09.670
And the first and last topics also are areas in
which we've made some enhancements for Leopard.

00:05:09.670 --> 00:05:14.720
Anyway, now to move into the media presentation, I'd
like to bring up Deborah Goldsmith who's going to talk to you

00:05:14.720 --> 00:05:18.010
about the text utilities, international
formatting and so on.

00:05:18.009 --> 00:05:20.370
Deborah plays many roles at Apple.

00:05:20.370 --> 00:05:29.870
Deborah is the representative to Unicode and is the, I guess
Vice Chair of the CLDR Technical Committee and involved

00:05:29.870 --> 00:05:34.660
with ICU, is also on the ICU board and
sort of the person who knows the most

00:05:34.660 --> 00:05:37.200
about how the internationalization
pieces at Apple fit together.

00:05:37.199 --> 00:05:39.269
So, with that, Deborah.

00:05:39.269 --> 00:05:40.019
Thanks.

00:05:40.019 --> 00:05:45.180
>> Deborah: Thank you Peter.

00:05:45.180 --> 00:05:45.490
( Applause )
>> Deborah: Okay.

00:05:45.490 --> 00:05:52.740
So we're going to talk a little bit about the modern APIs
that you can use to process text in your application.

00:05:52.740 --> 00:05:57.990
Now many of these APIs appeared in
Tiger and some even before that.

00:05:57.990 --> 00:06:00.120
So this is going to go very quickly.

00:06:00.120 --> 00:06:03.480
It's going to be part review and
in a few places introduction

00:06:03.480 --> 00:06:08.170
to some new features that are coming in Leopard.

00:06:08.170 --> 00:06:15.280
So before we start talking about the APIs, we
need to talk about what the APIs deal with.

00:06:15.279 --> 00:06:24.259
On the old world side for the script manager,
we have things like MacRoman and MacJapanese,

00:06:24.259 --> 00:06:26.959
which are the legacy character encodings.

00:06:26.959 --> 00:06:29.669
In the new world, all of the new APIs use Unicode.

00:06:29.670 --> 00:06:36.060
So if you haven't already transitioned your application
to Unicode, that's what you should be focusing on.

00:06:36.060 --> 00:06:43.040
The script manager used ScriptCodes, RegionCodes,
things like that to represent localees or languages.

00:06:43.040 --> 00:06:53.950
In the modern world we have CFLocale, CFStringEncoding
to denote legacy encodings and CFCharacterSet

00:06:53.949 --> 00:06:59.449
to keep track of sets of character or repertoires.

00:06:59.449 --> 00:07:03.810
With the script manager legacy
encodings you use Pascal or C Strings.

00:07:03.810 --> 00:07:10.670
In the modern world we use CFString or
its toll free bridged equivalent NSString.

00:07:10.670 --> 00:07:18.160
And the API sets you used in the Mac OS 9 and Script
Manager world are the Script Manager, Text Utilities,

00:07:18.160 --> 00:07:26.480
Date/Time Measurement Utilities and so on, and those are
replaced by the core foundation API sets that you see here.

00:07:26.480 --> 00:07:31.200
So moving right along, we'll go
through a number of scenarios.

00:07:31.199 --> 00:07:34.099
These don't cover all of the APIs by any means,

00:07:34.100 --> 00:07:39.000
but it's just to give you an idea of
how to move your application forward.

00:07:39.000 --> 00:07:47.240
So if you are interested in getting locale data, things
like the current currency symbol or localized decimal point

00:07:47.240 --> 00:07:51.740
or what have you, you might call GetScriptVariable
or GetScriptManagerVariable.

00:07:51.740 --> 00:07:55.090
Those are now deprecated.

00:07:55.089 --> 00:07:59.199
And there are several API sets that
you can use as the modern equivalent.

00:07:59.199 --> 00:08:04.529
For anything that has to do with locale data,
the place you start is CFLocaleCopyCurrent,

00:08:04.529 --> 00:08:09.159
which gives you a copy of the user's current locale settings.

00:08:09.160 --> 00:08:16.870
In order to disassemble that, or put it back together,
there's CFLocaleCreateComponentsFromLocaleIdentifier,

00:08:16.870 --> 00:08:19.850
which lets you pick out the pieces of the locale ID.

00:08:19.850 --> 00:08:22.620
And there's another API for putting it back together.

00:08:22.620 --> 00:08:28.870
You can use CFLocaleGetValue to get
particular attributes of the locale.

00:08:28.870 --> 00:08:33.919
And you could use CopyDisplayNameForPropertyValue
to get a localized name.

00:08:33.919 --> 00:08:36.459
and we'll give a little example using that.

00:08:36.460 --> 00:08:43.100
So say we want to get the name of the user's primary
language, the user's most preferred language in Polish.

00:08:43.100 --> 00:08:47.940
Well, we can use CFLocaleCopyPreferredLanguages,
which is actually a new API in Leopard.

00:08:47.940 --> 00:08:55.030
It returns an array, which is the list of the user's
language preferences from most preferred to least preferred.

00:08:55.029 --> 00:09:00.370
We then get the first element of that array,
which is the user's most preferred language.

00:09:00.370 --> 00:09:01.750
Then we need a Polish locale.

00:09:01.750 --> 00:09:08.419
Now the user may not have their locale set to
Polish, so since we want Polish in particular,

00:09:08.419 --> 00:09:12.379
we'll create one, instead of using CFLocaleCopyCurrent.

00:09:12.379 --> 00:09:18.730
We create a Polish locale and then we call
CFLocaleCopyDisplayNameForPropertyValue.

00:09:18.730 --> 00:09:19.500
That's a mouthful.

00:09:19.500 --> 00:09:22.080
And we pass our Polish locale.

00:09:22.080 --> 00:09:28.310
And we say we want the localized version of the
locale identifier and then we pass in the language.

00:09:28.309 --> 00:09:32.149
Now why do we say locale identifier
instead of a language identifier?

00:09:32.149 --> 00:09:33.590
Well you can see the reason below.

00:09:33.590 --> 00:09:38.780
Because a language tag doesn't just consist
of a language, it can also have a script code

00:09:38.779 --> 00:09:41.809
and possibly other things associated with it.

00:09:41.809 --> 00:09:45.719
In this case, the users primary
language is Simplified Chinese,

00:09:45.720 --> 00:09:49.470
which is denoted by the language tag and the scripts tag.

00:09:49.470 --> 00:09:52.540
And the result in Polish is shown below.

00:09:52.539 --> 00:09:57.069
And the English equivalent of that
is Chinese in Simplified Han.

00:09:57.070 --> 00:10:02.670
Okay, here's another thing that you
might need to do in your application.

00:10:02.669 --> 00:10:06.699
You might need to get information about characters.

00:10:06.700 --> 00:10:10.800
Now in the script manager world you would
have used CharacterType to do that.

00:10:10.799 --> 00:10:14.799
And there are several replacements in the modern API set.

00:10:14.799 --> 00:10:19.949
First of all, CFCharacterSet, in addition to
letting you create your own sets of characters,

00:10:19.950 --> 00:10:24.640
lets you get predefined sets that represents various
different kinds of characters like uppercase

00:10:24.639 --> 00:10:27.389
or lowercase or digits or what have you.

00:10:27.389 --> 00:10:32.529
In addition there are a few things
you can't do yet with core foundation

00:10:32.529 --> 00:10:36.399
like get nonbinary properties of a character.

00:10:36.399 --> 00:10:41.879
Like, for example, a decimal digit, what is
the value of that digit zero through nine?

00:10:41.879 --> 00:10:46.820
So in this case we're going to test a particular
character to see whether it is a decimal digit.

00:10:46.820 --> 00:10:53.290
We call CFCharacterSetGetPredefined to
get the predefined set of decimal digits

00:10:53.289 --> 00:10:57.329
and then we can use
CFCharacterSetIsLongCharacterMember

00:10:57.330 --> 00:11:01.139
to test a particular character for membership in that set.

00:11:01.139 --> 00:11:07.029
And then you could go on to do other things such as
get the actual value using UCGetCharProperty if,

00:11:07.029 --> 00:11:12.279
for example, you want to scan a number.

00:11:12.279 --> 00:11:18.079
Another scenario is sorting text
strings, or searching through them.

00:11:18.080 --> 00:11:24.090
The script manager had StringOrder and TextOrder for
that, and there's a large set of APIs that replace that,

00:11:24.090 --> 00:11:30.000
which not all of which are listed here, we'll just go
through a few examples to give you some of the flavor

00:11:30.000 --> 00:11:32.370
of how you do things with core foundation.

00:11:32.370 --> 00:11:40.710
You can use CFStringCompare to compare
two strings with various options.

00:11:40.710 --> 00:11:44.360
There's CFStringFind for finding
a string within another string.

00:11:44.360 --> 00:11:48.360
And there's also a find and replace
option that works on mutable strings.

00:11:48.360 --> 00:11:51.100
Sorry, find and replace API.

00:11:51.100 --> 00:11:59.450
And if you're looking for a particular character in a
CFString, like say you want to find the next white space,

00:11:59.450 --> 00:12:05.440
you can use CFStringFindCharacterFromSet, you can
call CFCharacterSet and get the predefined character set

00:12:05.440 --> 00:12:10.620
of all white space and then use that to scan
through a string looking for the next one.

00:12:10.620 --> 00:12:16.190
Now we have one API here that's in the
transitional set and that's UCGetCollationKey.

00:12:16.190 --> 00:12:19.260
And let me explain what you might want to use that for.

00:12:19.259 --> 00:12:26.110
If you're sorting a large set of strings, you're
going to be comparing strings more than once

00:12:26.110 --> 00:12:32.560
because the fastest sorting algorithms
now require N login operations.

00:12:32.559 --> 00:12:37.449
Now if you're doing a localized
comparison, one of the expensive parts

00:12:37.450 --> 00:12:42.900
of that comparison is looking up
the localized ordering information.

00:12:42.899 --> 00:12:47.970
And that's, the technical term for that is
developing a string of collation elements.

00:12:47.970 --> 00:12:55.420
What a collation key lets you do is do that work up front
and get a binary string that's much faster to compare.

00:12:55.419 --> 00:13:00.990
So if you're doing a sort or other large operation
where you're going to comparing strings multiple times,

00:13:00.990 --> 00:13:08.700
this lets you amortize that localized information up
front and that'll speed up your sorting operation.

00:13:08.700 --> 00:13:17.230
Another thing you might need to do is to
convert strings from uppercase or lowercase.

00:13:17.230 --> 00:13:21.700
And CFString has a variety of modern
APIs that you can use to do that.

00:13:21.700 --> 00:13:29.110
You can convert to uppercase or lowercase, as you could
with the script manager, but you can also do capitalization,

00:13:29.110 --> 00:13:33.669
which converts the first character
of each word to uppercase.

00:13:33.669 --> 00:13:36.679
Now you may notice that these APIs all pass the locale

00:13:36.679 --> 00:13:40.229
and you might wonder why you need
that for uppercase and lowercase.

00:13:40.230 --> 00:13:45.300
And the answer is that the rules for
converting between upper and lowercase vary

00:13:45.299 --> 00:13:47.569
from language to language and country to country.

00:13:47.570 --> 00:13:51.530
For example, the rules for Turkish are
not the same as the rules for English.

00:13:51.529 --> 00:13:56.509
So if you're doing this to a string that
is going to be displayed to an end user,

00:13:56.509 --> 00:14:00.750
you're going to want to pass the locale
into make sure that it's done properly.

00:14:00.750 --> 00:14:07.870
Another operation that applies to Unicode that wasn't
necessary in the script manager world is normalization.

00:14:07.870 --> 00:14:14.810
Now as you may be aware, Unicode can have multiple
ways of representing the same character sequence.

00:14:14.809 --> 00:14:21.059
For example, an E with an acute accent can
be represented either as a precomposed form,

00:14:21.059 --> 00:14:27.619
E with an acute accent as one character, or an
E based character with a combining acute accent.

00:14:27.620 --> 00:14:33.419
And what CF normalize string does is let you convert
between those two forms because different systems

00:14:33.419 --> 00:14:36.929
and different applications have a
preference for one form or the other.

00:14:36.929 --> 00:14:42.539
For example on the Internet or on Windows,
you'll typically prefer the precomposed form

00:14:42.539 --> 00:14:45.809
which is a normalization form C, NFC.

00:14:45.809 --> 00:14:50.809
But HFS plus disk volumes prefer file
names in the decomposed form, NFD.

00:14:50.809 --> 00:14:58.309
And there's a few subtleties there,
but I'm not going to go into them now.

00:14:58.309 --> 00:15:02.969
Something else you might need to do in your
application is perform transformations on your text

00:15:02.970 --> 00:15:05.730
and the script manager had a few of those.

00:15:05.730 --> 00:15:12.360
You could strip the diacritics off or you could
transliterate text to Roman from other scripts.

00:15:12.360 --> 00:15:19.830
And CFString has a very powerful API that lets you do
those transformations and more called CFStringTransform.

00:15:19.830 --> 00:15:24.940
It can strip diacritics and this is
actually a new operation in Leopard.

00:15:24.940 --> 00:15:28.600
In Tiger we had an operation for stripping combining marks,

00:15:28.600 --> 00:15:31.690
which is a little bit more enthusiastic
than stripping diacritics.

00:15:31.690 --> 00:15:34.920
So now we have just stripping diacritics.

00:15:34.919 --> 00:15:42.289
It also support transformations to Latin, but actually
you don't want to use that if your application is running

00:15:42.289 --> 00:15:50.199
on Leopard because starting in Leopard we have CFStringTokenizer,
which does a much more detailed analysis of text

00:15:50.200 --> 00:15:55.040
and looks at grammatical information in
dictionaries and so on to convert text to Latin.

00:15:55.039 --> 00:16:01.110
So it does much better job with things like
Japanese or Chinese than CFStringTransform can do.

00:16:01.110 --> 00:16:04.659
So if you're running on Leopard,
use CFStringTokenizer instead

00:16:04.659 --> 00:16:08.539
and Kida-san is going to be talking
about that in a few minutes.

00:16:08.539 --> 00:16:14.579
However, if you need to do other kinds of
transformations, CFStringTransform is your API.

00:16:14.580 --> 00:16:18.830
It also does bidirectional transformations,
which CFStringTokenizer doesn't do.

00:16:18.830 --> 00:16:25.240
So if, for example, you can go back and forth between
Latin script and Hiragana or between Hiragana

00:16:25.240 --> 00:16:32.370
and Katakana, you can do things like convert
non-ASCII characters to numeric escape codes.

00:16:32.370 --> 00:16:37.580
And something that you can do that you could actually
do in Tiger, but we're supporting it formally

00:16:37.580 --> 00:16:44.750
for the first time now, is you can pass any
transformation ID that's supported by the ICU library

00:16:44.750 --> 00:16:51.509
to CFStringTransform and it will do it, in addition
to the predefined ones that we've supplied in the past.

00:16:51.509 --> 00:16:56.100
So in this case, we're using the Half-
width-Fullwidth transform from ICU,

00:16:56.100 --> 00:16:58.730
which converts halfwidth to fullwidth characters.

00:16:58.730 --> 00:17:03.389
But we don't want to do that to the Latin characters in
our string, we just want to do it to the Katakana,

00:17:03.389 --> 00:17:08.319
so we use a transform that has a Katakana
filter and the result is, on the right,

00:17:08.319 --> 00:17:14.490
you can see that the Katakana characters become
fullwidth, but the Latin characters are left alone.

00:17:14.490 --> 00:17:19.279
CFStringTransform can do lots more things
and you can read about it in the documentation.

00:17:19.279 --> 00:17:27.869
Well, in addition to looking at strings and
transforming them, you also need to do basic operations

00:17:27.869 --> 00:17:30.519
like replace parts of them or move bytes around.

00:17:30.519 --> 00:17:37.279
In the past you would have used Munger
or ReplaceText, but in the modern world,

00:17:37.279 --> 00:17:41.139
CFString has a variety of APIs you can call instead.

00:17:41.140 --> 00:17:45.060
You can replace a range of a string with another string.

00:17:45.059 --> 00:17:51.309
You can create a string with a format string, which
is very similar to printf. you can trim a string

00:17:51.309 --> 00:17:54.869
from the beginning and end of another string.

00:17:54.869 --> 00:18:00.509
So for example you can remove comments
or indicators or add comment indicators.

00:18:00.509 --> 00:18:03.170
And there's a more specialized version of that,

00:18:03.170 --> 00:18:06.680
which removes white space characters
from the beginnings or ends of strings.

00:18:06.680 --> 00:18:10.259
And again, there's more APIs than
we have time to go into here.

00:18:10.259 --> 00:18:13.180
You can read the documentation to find out about it.

00:18:13.180 --> 00:18:18.400
If you're just moving bytes around and they're not
Unicode characters, then you can just use memmove

00:18:18.400 --> 00:18:22.810
and similar APIs from the standard C library.

00:18:22.809 --> 00:18:32.440
Okay. Well now we start to get into some
of the more complicated aspects of Unicode.

00:18:32.440 --> 00:18:39.080
You might thing since Unicode is 16-bits wide, that
it's just like a wide version of ASCII, and it isn't.

00:18:39.079 --> 00:18:42.809
it requires a little bit more of
sophistication in handling than that.

00:18:42.809 --> 00:18:50.230
So in the past, you had to user CharacterByteType to make
sure that for a double byte character set like MacJapanese

00:18:50.230 --> 00:18:55.480
or Mac Simplified Chinese, you were not
truncating the character in the middle.

00:18:55.480 --> 00:18:59.289
Well, Unicode is not a multi byte
encoding, but you can still have more

00:18:59.289 --> 00:19:03.119
than one code point used to represent
and end user character.

00:19:03.119 --> 00:19:11.519
For example, the example I gave earlier about an
E character followed by a combining acute accent,

00:19:11.519 --> 00:19:12.940
you don't want a break in the middle of that.

00:19:12.940 --> 00:19:20.580
So suppose you're inserting something like an
ellipses, if you don't pay attention to the boundaries

00:19:20.579 --> 00:19:26.189
of composing character sequence, you could get
something like the first example on the bottom

00:19:26.190 --> 00:19:30.840
where you insert the ellipses in between
the base character and the accent.

00:19:30.839 --> 00:19:33.889
And that's not the result you want.

00:19:33.890 --> 00:19:38.720
Instead you can use
CFStringGetRangeOfComposedCharactersAtIndex,

00:19:38.720 --> 00:19:43.480
and what that will do is it will take the index you
give it and it will give you the range on either side

00:19:43.480 --> 00:19:46.160
of that index, of the composing character sequence.

00:19:46.160 --> 00:19:49.019
And you don't want a break in the middle of that.

00:19:49.019 --> 00:19:53.930
So if you use that, in this example, you'd start
with an arbitrary index and then you say, okay,

00:19:53.930 --> 00:19:56.880
I want to put the break at the end of that range.

00:19:56.880 --> 00:20:01.090
And then you get the second example
we have here where you have the E

00:20:01.089 --> 00:20:05.919
with it's acute accent is okay and
then it's followed by the ellipses.

00:20:09.069 --> 00:20:14.879
Speaking of that particular example of inserting
an ellipsis in order to truncate a string,

00:20:14.880 --> 00:20:17.790
you actually don't have to do that yourself.

00:20:17.789 --> 00:20:22.389
The script manager had APIs for that
and we have modern equivalents also.

00:20:22.390 --> 00:20:30.120
If you're using core text, you don't even have to truncate
the string in memory, you can pass a certain set of tags

00:20:30.119 --> 00:20:36.189
when you're rendering and core text will truncate the string
for you while leaving your string and memory untouched.

00:20:36.190 --> 00:20:42.210
You just tell it how wide you want it to be and it will
do the right thing Unicode wise and put the ellipses

00:20:42.210 --> 00:20:45.450
in the right place when it's actually drawing the string.

00:20:45.450 --> 00:20:49.400
And there's, if you're still using ATSUI,
there's similar tags for (inaudible).

00:20:49.400 --> 00:20:55.460
If you actually do want to truncate the string
in storage, you can call TruncateThemeText,

00:20:55.460 --> 00:20:58.210
which is available as part of the appearance manager.

00:20:58.210 --> 00:21:07.620
Another thing that you need to do in
application, for example, is handle double clicks,

00:21:07.619 --> 00:21:11.129
or do whole word search, or handle word wrapping.

00:21:11.130 --> 00:21:16.530
And it turns out that word boundaries and
line boundaries are not quite the same thing.

00:21:16.529 --> 00:21:19.509
That's why the script manager had two separate APIs.

00:21:19.509 --> 00:21:21.920
It had find word break and style line break.

00:21:21.920 --> 00:21:26.650
And we'll find out a little bit more about
that later in Kida-san's presentation.

00:21:26.650 --> 00:21:33.900
For Unicode text we've had UCFindTextBreak,
but new in Leopard we have CFStringTokenizer,

00:21:33.900 --> 00:21:42.240
and CFStringTokenizer actually is now the preferred
API for looking for word, line or sentence boundaries.

00:21:42.240 --> 00:21:48.980
If you're looking for cluster boundaries for things like
handling arrow keys, again, you can use

00:21:48.980 --> 00:21:53.200
CFStringGetRangeOfComposedCharactersAtIndex,
which we just discussed.

00:21:54.359 --> 00:21:58.109
Okay, moving along to handling locale information.

00:21:58.109 --> 00:22:05.059
One thing you need to do in a localized way for
the end user is format and parse dates and times.

00:22:05.059 --> 00:22:10.480
So the script manager had a long list of
APIs for doing that, too long to list here,

00:22:10.480 --> 00:22:13.410
but those are all replaced by CFDateFormatter.

00:22:13.410 --> 00:22:16.700
The model for CFDateFormatter is very simple.

00:22:16.700 --> 00:22:23.980
You create an object, a CFDateFormatter object
that formats dates or parses dates the way you want

00:22:23.980 --> 00:22:31.950
and then you can use that object to convert a CFAbsoluteTime
to a string or convert a string to a CFAbsoluteTime.

00:22:31.950 --> 00:22:37.920
You can also set properties on the object that lets
you control the way that it does those operations.

00:22:37.920 --> 00:22:40.110
So I have a quick example here.

00:22:40.109 --> 00:22:45.039
We'll create a CFDateFormatter
object, and we use the current locale.

00:22:45.039 --> 00:22:50.829
Now if you've used core foundation before, you'll
notice that I'm leaking the current locale here,

00:22:50.829 --> 00:22:54.119
but that's just for purposes of this example.

00:22:54.119 --> 00:22:58.379
You'd keep track of it and do a CFRelease on it later.

00:22:58.380 --> 00:23:04.050
I'm asking for the LongDateStyle and the
LongTimeStyle and then I set a property

00:23:04.049 --> 00:23:09.019
on the formatter object saying that I want lenient parsing.

00:23:09.019 --> 00:23:17.069
And then I call CFDateFormatterGetAbsoluteTimeFromString
and the string I'm giving is January 1, 2001,

00:23:17.069 --> 00:23:24.750
12 AM, GMT, and it so happens that that's the origin
for CFAbsoluteTime so the answer I get is zero.

00:23:27.549 --> 00:23:32.289
Sometimes you need to do more with
dates than just parse or format them.

00:23:32.289 --> 00:23:39.659
Sometimes you need to do calendar calculations, and since
Tiger we've had CFCalendar, which replaces a long list

00:23:39.660 --> 00:23:45.410
of script manager APIs that are not deprecated, or
actually have been deprecated for some time now.

00:23:45.410 --> 00:23:48.380
And again, we're going through this very quickly.

00:23:48.380 --> 00:23:54.050
CFCalendar lets you go between a list of calendar
components, like the year, month, day, hour, minute,

00:23:54.049 --> 00:23:57.349
second, and compose those into an AbsoluteTime.

00:23:57.349 --> 00:24:02.309
Or go in the other direction, you
can also do arithmetic on dates.

00:24:02.309 --> 00:24:08.980
Say, for example, I want to take CFCalendar that represents
today and I want to say what's the date that corresponds

00:24:08.980 --> 00:24:16.079
to 10 months from now, I can add 10 months to that date
and it will do all the calendrical calculations correctly.

00:24:16.079 --> 00:24:22.869
CFCalendar also supports non-Gregorian calendars, which
is something that we've supported in the OS since Tiger,

00:24:22.869 --> 00:24:30.299
so we would like it if your application
supported non-Gregorian calendars as well.

00:24:30.299 --> 00:24:35.809
Very similar to dates and times, you also need
to format and scan numbers in your application,

00:24:35.809 --> 00:24:39.119
and it's very analogous to the way dates and times work.

00:24:39.119 --> 00:24:41.089
You create a number format or object.

00:24:41.089 --> 00:24:44.849
You can use it to convert to and from a string.

00:24:44.849 --> 00:24:49.219
And you can set properties on that formatter
that control the way it does it's work.

00:24:49.220 --> 00:24:56.160
In this case, you can actually set the format pattern string
if you want to use a particular number format as opposed

00:24:56.160 --> 00:25:00.050
to using the number format that
you get from the user's locale.

00:25:00.049 --> 00:25:05.230
So what we're doing here is we're creating a number
formatter, again with the current locale and again,

00:25:05.230 --> 00:25:09.450
leaking the current locale and we're
asking for the currency style.

00:25:09.450 --> 00:25:11.990
CFNumberFormatter supports a variety of styles.

00:25:11.990 --> 00:25:17.990
It supports currencies, plain numbers,
floating point numbers and percent.

00:25:17.990 --> 00:25:26.670
In this case, we're taking the number
1,992 and we're formatting it as currency.

00:25:26.670 --> 00:25:31.350
And another thing that's different from CFDateFormatter
is you'll notice we have to pass the type

00:25:31.349 --> 00:25:33.929
of the number, and in this case it's a double.

00:25:33.930 --> 00:25:40.220
CFNumberFormatter supports converting to and from
various binary formats, not just doubles and floats,

00:25:40.220 --> 00:25:44.600
but also integers as well and also CFNumbers.

00:25:44.599 --> 00:25:54.039
In this case, we have the Russian locale selected, so we get
an amount formatted in Rubles, which is shown at the bottom.

00:25:54.039 --> 00:25:58.539
Okay. That ends our whirlwind tour of text management APIs,

00:25:58.539 --> 00:26:02.769
and I hope you're not too dizzy from
that because we went very quickly.

00:26:02.769 --> 00:26:10.299
And now I'm going to turn things over to Yasuo Kida,
who's the manager of our Tokyo OS Engineering Group.

00:26:10.299 --> 00:26:10.619
Kida-san.

00:26:10.619 --> 00:26:16.049
>> Thank you, Deborah.

00:26:17.329 --> 00:26:20.809
I'm Yasuo Kida, the manager of OS Engineering in Tokyo.

00:26:20.809 --> 00:26:25.329
I'm actually living here, managing Tokyo engineering team.

00:26:25.329 --> 00:26:28.399
I'll talk about CFStringTokenizer.

00:26:28.400 --> 00:26:32.900
It is a text segmentation API that's new to Leopard.

00:26:32.900 --> 00:26:35.009
Let's see what it is.

00:26:35.009 --> 00:26:43.529
It can tokenize a given string
into a word, sentences or paragraphs.

00:26:43.529 --> 00:26:51.980
Not only can it tokenize languages that has
explicit word boundary marks, like this,

00:26:51.980 --> 00:27:02.519
it also talk nice languages like Japanese
and Chinese into natural word boundaries.

00:27:02.519 --> 00:27:09.980
It can do so by utilizing a technology
called morphological analysis.

00:27:09.980 --> 00:27:18.990
By utilizing the morphological analysis, it can give
Latin transcription for not only for alphabetic language

00:27:18.990 --> 00:27:23.609
like Arabic or Indic, it
can provide Latin transcription

00:27:23.609 --> 00:27:30.569
for ideographic languages like Japanese and Chinese.

00:27:31.980 --> 00:27:35.640
Look at those two kanjis that are highlighted.

00:27:35.640 --> 00:27:41.810
Those are the same kanji, but
have different pronunciation.

00:27:41.809 --> 00:27:54.009
And CFStringTokenizer can provide correct Latin
transcription based on the context of the text.

00:27:54.009 --> 00:28:00.379
Sometimes a word consists of multiple
words, this is called compounds.

00:28:00.380 --> 00:28:09.930
The CFStringTokenizer can break compounds such as
German noun compounds and look at the first compound

00:28:09.930 --> 00:28:14.430
of sub token is different from the original token.

00:28:14.430 --> 00:28:18.660
And it can also break CamelCase
and words with numbers into symbols.

00:28:18.660 --> 00:28:29.710
So previous examples, you are interested in
tokens that are surrounded by boundaries,

00:28:29.710 --> 00:28:34.200
but there are cases you are interested in boundaries itself.

00:28:35.369 --> 00:28:42.259
So one of those cases, line breaking
opportunity, finding line breaking opportunities.

00:28:42.259 --> 00:28:47.660
Other case is finding word break,
which is used for double click range.

00:28:49.269 --> 00:28:55.160
For some languages, word breaking and
line breaking opportunities are similar,

00:28:55.160 --> 00:28:57.660
like shown in the above example.

00:28:57.660 --> 00:29:02.350
Some other languages, those are completely different.

00:29:02.349 --> 00:29:08.539
Lastly, it has an API that does language identification.

00:29:08.539 --> 00:29:14.440
It identifies the language of a given text, like this.

00:29:14.440 --> 00:29:20.340
Here is a relationship with other similar APIs.

00:29:20.339 --> 00:29:28.250
So first of all, do not use language analysis
framework, find word break, style line break,

00:29:28.250 --> 00:29:31.750
focal tokenization, or finding text breaks.

00:29:31.750 --> 00:29:36.839
And do not use TransliterateText for Latin transcription.

00:29:36.839 --> 00:29:42.189
Instead use CFStringTokenizer for
tokenization in Latin transcription.

00:29:42.190 --> 00:29:47.120
Use CFStringTransformation for other
transcriptions like Deborah mentioned.

00:29:47.119 --> 00:29:53.509
So let me show you how it works.

00:29:53.509 --> 00:30:01.480
( Silence. )

00:30:01.480 --> 00:30:02.549
>> Okay.

00:30:02.549 --> 00:30:08.409
( Silence )

00:30:08.410 --> 00:30:12.220
>> So here you have a bunch of text.

00:30:12.220 --> 00:30:16.860
This is the desktop application.

00:30:16.859 --> 00:30:23.299
So let's drag and drop this text into a text field.

00:30:24.779 --> 00:30:28.319
So why do you think this language is?

00:30:28.319 --> 00:30:33.389
Let's click on identify language button.

00:30:33.390 --> 00:30:36.220
And this is Simplified Chinese.

00:30:36.220 --> 00:30:39.519
And let me do the tokenization.

00:30:39.519 --> 00:30:43.420
It can tokenize text into pieces.

00:30:43.420 --> 00:30:45.509
Now let's see.

00:30:45.509 --> 00:30:49.740
And this is Latin transcription.

00:30:49.740 --> 00:30:55.559
Another example is this one.

00:30:55.559 --> 00:30:59.339
I cannot read this language.

00:30:59.339 --> 00:31:03.429
Let's try identifying the language.

00:31:03.430 --> 00:31:04.820
This is German.

00:31:04.819 --> 00:31:12.549
And notice that, not only I identify the language, I set
the spelling Czechker to the language, which is identified.

00:31:12.549 --> 00:31:21.680
And you see the spelling Czechker now works
correctly on this text compared with this state.

00:31:21.680 --> 00:31:29.049
And it can tokenize the German compounds into pieces.

00:31:29.049 --> 00:31:32.009
Look at this word.

00:31:32.009 --> 00:31:38.269
It's a single word in the original text.

00:31:38.269 --> 00:31:40.389
How about this one?

00:31:40.390 --> 00:31:41.240
How about this one?

00:31:41.240 --> 00:31:44.599
What language this is?

00:31:44.599 --> 00:31:45.769
This is French.

00:31:45.769 --> 00:31:47.440
How about this one?

00:31:47.440 --> 00:31:51.509
This is the last one.

00:31:51.509 --> 00:31:56.250
( Silence )

00:31:56.250 --> 00:31:59.400
>> This is Dutch.

00:31:59.400 --> 00:32:02.509
And this is an example I like.

00:32:02.509 --> 00:32:07.210
( Silence )

00:32:07.210 --> 00:32:15.079
>> This is a mixture of some Latin
language and some Kanji.

00:32:15.079 --> 00:32:21.839
This is in German and let's get the Latin transcription.

00:32:21.839 --> 00:32:28.509
You can get the Latin transcription
correctly even for the Japanese part.

00:32:28.509 --> 00:32:33.460
( Silence )

00:32:33.460 --> 00:32:40.259
>> Let's get back to the presentation screen, please.

00:32:40.259 --> 00:32:41.500
Thank you.

00:32:41.500 --> 00:32:45.319
So let's see how you program it.

00:32:45.319 --> 00:32:51.329
So for most of the purposes of language identification,

00:32:51.329 --> 00:32:57.409
you first create the tokenizer by
calling CFStringTokenizerCreate.

00:32:57.410 --> 00:33:05.029
And for this word tokenization case, you
specify KCFStringTokenizerUnitWord to it.

00:33:05.029 --> 00:33:12.750
And then you form iterator by calling
CFStringTokenizerAdvanceToNextToken

00:33:12.750 --> 00:33:17.099
and you iterate while it is returning non zero body.

00:33:17.099 --> 00:33:22.279
And you can access to the range of the current token.

00:33:22.279 --> 00:33:27.829
So CFStringTokenizer API is playing a
lot of attention to memory allocation.

00:33:27.829 --> 00:33:36.179
It is trying to reduce the need for the memory allocation
as much as possible during the iteration process.

00:33:36.180 --> 00:33:43.269
You can add one API to it to do the Latin transcription.

00:33:43.269 --> 00:33:48.700
You call CFStringTokenizerCopyCurrentTokenAttribute.

00:33:48.700 --> 00:33:53.789
With CFStringTokenizerAttributeLatinTranscription,
which is pretty much the only attribute

00:33:53.789 --> 00:34:00.609
that is currently supported to get the
Latin transcription for the current token.

00:34:00.609 --> 00:34:04.059
And here is how you break compounds.

00:34:04.059 --> 00:34:09.500
It's a little bit complicated, but the basic is similar.

00:34:09.500 --> 00:34:10.539
First you create an array.

00:34:10.539 --> 00:34:21.719
Because like I explained and mentioned earlier, there are
some cases that tokens are different from the original text.

00:34:21.719 --> 00:34:26.369
So you need to be getting those into arrays of ranges.

00:34:26.369 --> 00:34:36.980
And if the type says yeah, I have some tokens you
call CFStringTokenizerGetCurrentSubTokens

00:34:36.980 --> 00:34:41.389
and get those sub tokens in the array.

00:34:41.389 --> 00:34:46.150
Here's an example for finding a line breaking opportunities.

00:34:46.150 --> 00:34:53.559
You create a tokenizer by specifying
KCFStringTokenizer, you need line break.

00:34:53.559 --> 00:35:01.549
And instead of forming (inaudible), you
call CFStringTokenizerGoToTokenAtIndex

00:35:01.550 --> 00:35:04.280
by providing a chapter index to it.

00:35:04.280 --> 00:35:08.450
Usually you're not interested in getting
a series of tokens for entire text,

00:35:08.449 --> 00:35:19.169
but you are interested in knowing text boundaries
surrounding your or near a particular chapter index.

00:35:19.170 --> 00:35:23.880
The last thing you do is language identification.

00:35:23.880 --> 00:35:25.500
Simple. One call.

00:35:25.500 --> 00:35:27.400
You gave string and range.

00:35:27.400 --> 00:35:37.440
If you gave a range of zero left of zero it reads
appropriate number of characters to recognize language.

00:35:37.440 --> 00:35:43.130
So that was CFStringTokenizer.

00:35:43.130 --> 00:35:46.450
Next I'll talk about the Dictionary Development Kit.

00:35:46.449 --> 00:35:48.259
What is it?

00:35:48.260 --> 00:35:53.520
In Tiger we released an application called Dictionary App.

00:35:53.519 --> 00:36:01.380
It had US English dictionary and Thesaurus and that was it.

00:36:01.380 --> 00:36:07.750
In Leopard we added the capability
for you to add dictionaries to it.

00:36:07.750 --> 00:36:11.289
So this is what Dictionary Development Kit is for.

00:36:11.289 --> 00:36:15.500
You can draw up dictionaries for Dictionary App.

00:36:15.500 --> 00:36:22.190
Like regular dictionaries and thesaurus or bilingual dictionaries
like Thai and English or specialty dictionaries

00:36:22.190 --> 00:36:30.710
like (inaudible) or technical, some technical area
or medical or you can draw up reference libraries

00:36:30.710 --> 00:36:35.970
or glossaries, glossaries for in house usages.

00:36:35.969 --> 00:36:41.429
It is HTML based, so very simple.

00:36:41.429 --> 00:36:45.639
Each page is an HTML page.

00:36:45.639 --> 00:36:53.129
And you can think of a dictionary as a
set of HTML pages targeted with terms.

00:36:53.130 --> 00:36:57.220
It will use a rich set of terms you already know.

00:36:57.219 --> 00:37:03.539
And it is in UTF-8 throughout, so it is
Unicode and it can support many languages.

00:37:03.539 --> 00:37:07.559
Let's look at the source.

00:37:07.559 --> 00:37:12.179
So Dictionary Development Kit defines
a few XML tags that surround

00:37:12.179 --> 00:37:17.859
and encapsulate the concept of
the dictionary and each entry.

00:37:17.860 --> 00:37:22.460
This is a document entity, dictionary, our root tag.

00:37:22.460 --> 00:37:31.250
Inside the root tag you have entity tags and entry tags.

00:37:31.250 --> 00:37:34.639
You have multiple entry tags in the dictionary.

00:37:34.639 --> 00:37:39.239
And this is an entry tag that's
supposed to an entry called AirPort.

00:37:39.239 --> 00:37:42.619
The ID is a unique identifier for the entry.

00:37:42.619 --> 00:37:47.409
You would be using for linking between entries, for example.

00:37:47.409 --> 00:37:54.429
You can add multiple indexes and here's your content.

00:37:54.429 --> 00:37:58.509
Typically it starts with <h1> tag like this.

00:37:58.510 --> 00:38:05.590
And your content and let me add a link between entries.

00:38:05.590 --> 00:38:09.650
In this cased it links to AirPort Extreme.

00:38:09.650 --> 00:38:18.150
And we define the URI scheme that is
x-dictionary and you can add images.

00:38:18.150 --> 00:38:20.660
It's HTML.

00:38:20.659 --> 00:38:28.519
And you can actually add your own CSS
images etcetera and you provide info.plist,

00:38:28.519 --> 00:38:33.070
you provide dictionary name and bundle identifier, etcetera.

00:38:33.070 --> 00:38:36.450
And compile it into a dictionary.

00:38:36.449 --> 00:38:44.539
You can a Dictionary Development Kit at the following
directory: /Developer/Extras/Dictionary Development Kit/

00:38:44.539 --> 00:38:52.460
We are planning an Xcode version of it, but
that might become available to ADC website.

00:38:53.730 --> 00:38:57.510
And let me compile a dictionary.

00:38:57.510 --> 00:39:21.350
( Silence )

00:39:21.349 --> 00:39:25.509
>> It is taking a long time.

00:39:25.510 --> 00:39:33.800
( Silence )

00:39:33.800 --> 00:39:37.510
>> Let me open it.

00:39:37.510 --> 00:39:44.380
( Silence )

00:39:44.380 --> 00:39:48.670
>> Hello. Oh yeah.

00:39:48.670 --> 00:39:49.510
Phew.

00:39:49.510 --> 00:39:54.040
( Silence )

00:39:54.039 --> 00:40:05.559
>> So this is the source code for
the dictionary we just created.

00:40:05.559 --> 00:40:09.750
It is rather small.

00:40:09.750 --> 00:40:12.940
We need the Xcode.

00:40:12.940 --> 00:40:14.670
( Whispering )
Okay, anyway.

00:40:19.369 --> 00:40:21.819
This dictionary has two entries.

00:40:21.820 --> 00:40:27.670
One is for AirPort the other for AirPort Express.

00:40:27.670 --> 00:40:38.829
And like we created in the presentation, it
has a link to the other entry and an image.

00:40:38.829 --> 00:40:48.849
So CD, and then we compile it to the project
dictionary, project directory and link.

00:40:48.849 --> 00:40:55.469
And it will create a dictionary into the objects directory.

00:40:55.469 --> 00:41:00.809
And let me copy it into the dictionaries folder.

00:41:00.809 --> 00:41:10.029
If your library folder doesn't have
dictionary folder, you can create it.

00:41:10.030 --> 00:41:15.100
And launch dictionary, viola.

00:41:15.099 --> 00:41:16.920
This is your dictionary.

00:41:16.920 --> 00:41:25.639
Let me type AirPort, it finds entry, it should.

00:41:26.739 --> 00:41:28.399
Hello, yep.

00:41:28.400 --> 00:41:34.030
So this is the title as we said and the
content and the link and the picture.

00:41:34.030 --> 00:41:38.670
And you can click on the link then go to the other entry.

00:41:38.670 --> 00:41:41.150
So it's that simple.

00:41:41.150 --> 00:41:42.539
And thank you very much.

00:41:42.539 --> 00:41:47.320
Let me introduce Mr. Michael Grady
to talk about Text Input API.

00:41:47.320 --> 00:41:58.130
>> Mike: Thank you Kito-san for that.

00:41:58.130 --> 00:41:58.670
Hello everybody.

00:41:58.670 --> 00:42:04.900
We'll be discussing the state of
Text Input Sources in Leopard.

00:42:04.900 --> 00:42:10.300
You've heard several times mentioned in this talk that the
script manager's deprecated and some parts of it are really,

00:42:10.300 --> 00:42:13.039
really deprecated like the KeyScript API.

00:42:13.039 --> 00:42:18.279
The reason is not just because those API are based
on the Mac script code, which is a deprecated notion.

00:42:18.280 --> 00:42:26.960
But really they have not as a API been able to keep up with
the variety of text input sources available on Mac OS X.

00:42:26.960 --> 00:42:28.750
What are examples of text input sources?

00:42:28.750 --> 00:42:31.329
You see up here a text input menu.

00:42:31.329 --> 00:42:37.610
It has a number of keyboard layouts, the US keyboard,
Arabic, Czech, and the Unicode text input keyboard layout

00:42:37.610 --> 00:42:40.769
that we'll talk a little bit about later.

00:42:40.769 --> 00:42:42.190
You also see some input methods.

00:42:42.190 --> 00:42:47.800
And here you see some input modes that
belong to the Kotoeri input method.

00:42:47.800 --> 00:42:48.950
( Speaking in foreign language )

00:42:48.949 --> 00:42:53.129
Are three input modes that belong
to the input method and the grayed

00:42:53.130 --> 00:42:55.019
out portion of the menu you see up here, Kotoeri.

00:42:55.019 --> 00:42:58.559
There are additional input sources as well.

00:42:58.559 --> 00:43:03.190
You'll see the character palette available at the
bottom of the menu and keyboard viewer palette.

00:43:03.190 --> 00:43:08.429
These are all examples of text input sources that
the script manager could not really deal with.

00:43:08.429 --> 00:43:14.429
So we're introducing a new API in Leopard to help you,
and modern API to help you control these input sources.

00:43:14.429 --> 00:43:18.119
And we'll tie within nicely afterwards with a demo.

00:43:19.179 --> 00:43:23.349
What are the things that you would expect
the text input source API to provide?

00:43:23.349 --> 00:43:28.279
Well, of course accessing properties of an
input source, icon, localized name, and so forth.

00:43:28.280 --> 00:43:35.080
Discovery on iterated mode to find input sources
that may or may not be enabled already by the user.

00:43:35.079 --> 00:43:41.349
The current "state" of the user's configuration, and something
that simply could not be done with the script manager,

00:43:41.349 --> 00:43:46.750
manipulation of the input sources from the background
and having them take effect in the foreground.

00:43:46.750 --> 00:43:47.699
So let's get into that.

00:43:47.699 --> 00:43:50.109
what is a text input source?

00:43:50.110 --> 00:43:53.240
It's typed as a TISInputSourceRef.

00:43:53.239 --> 00:43:58.000
It is registered with the CF runtime
as an instance of CFType.

00:43:58.000 --> 00:44:02.559
And it's identified uniquely by TISInputSourceGetTypeID.

00:44:02.559 --> 00:44:07.360
And that makes it a candidate to be used with
the normal polymorphic functions you'd expect,

00:44:07.360 --> 00:44:10.769
CFRetain,CFRelease, and CFEqual.

00:44:10.769 --> 00:44:13.500
Once you have a TISInputSourceRef
what can you do with it?

00:44:13.500 --> 00:44:17.309
Well, the workhorse of the API is
accessing properties of an input source.

00:44:17.309 --> 00:44:21.590
TISGetInputSourceProperty is shown
here being passed in input source.

00:44:21.590 --> 00:44:27.320
In this case the current keyboard input source, as
you see at the top and we're querying a property

00:44:27.320 --> 00:44:31.940
in this case its BundleID, very simple API, very powerful.

00:44:31.940 --> 00:44:35.200
What are some of the properties
that you might be interested in?

00:44:35.199 --> 00:44:37.730
we'll go over a set here.

00:44:37.730 --> 00:44:42.659
Identification input sources have a unique InputSourceID.

00:44:42.659 --> 00:44:46.649
For input methods and input modes that's very
straight forward, it's just a BundleID

00:44:46.650 --> 00:44:49.269
and a concatenation with the ModeID.

00:44:49.269 --> 00:44:54.900
For keyboard layouts it's important
that if you develop a keyboard layout

00:44:54.900 --> 00:45:01.320
that you provide your own InputSourceID
keyboard layout should be bundle.key layouts.

00:45:01.320 --> 00:45:08.120
And in the KL info dictionary that they usually contain
that's where you specify your unique InputSourceID.

00:45:08.119 --> 00:45:10.289
Input sources also belong to categories.

00:45:10.289 --> 00:45:15.019
That's a broad distinction between things like
KeyboardInputSources or PaletteInputSources.

00:45:15.019 --> 00:45:19.769
There's a more fine grain distinction
between them by the input source type.

00:45:19.769 --> 00:45:26.159
For example, something, maybe a keyboard layout,
a keyboard input method. In the case of palettes

00:45:26.159 --> 00:45:30.500
that may be a character palette or a keyboard viewer.

00:45:30.500 --> 00:45:34.840
Other static properties of input sources
would be whether it can be enabled.

00:45:34.840 --> 00:45:37.000
Most input sources can be enabled, some cannot.

00:45:37.000 --> 00:45:41.059
For example, an input method may provide a
private keyboard layout in its own bundle.

00:45:41.059 --> 00:45:45.150
That is a text input source not enableable.

00:45:45.150 --> 00:45:48.090
Things that can be enabled are not always selectable.

00:45:48.090 --> 00:45:53.460
For example, we know that input modes of
an enabled input method can be selected

00:45:53.460 --> 00:45:58.599
but the parent input method itself cannot
be selected while it can be enabled.

00:45:58.599 --> 00:46:03.409
Input sources have, are associated with, languages they support.

00:46:03.409 --> 00:46:08.309
For example the US keyboard layout could be used
to type not just English but French and Spanish.

00:46:08.309 --> 00:46:15.309
So an input source will typically be associated with several
languages, the first of which is the intended language.

00:46:15.309 --> 00:46:23.369
The intended language is also another property that you
should be specifying in your keyboard layouts bundle.

00:46:25.679 --> 00:46:31.169
Keyboard layout input sources in particular
have keyboard layout data of the TIS

00:46:31.170 --> 00:46:37.760
or the text input source API only makes available
access to the Unicode keyboard layout data, the uchar,

00:46:37.760 --> 00:46:41.450
the Kkhar format is completely deprecated.

00:46:41.449 --> 00:46:45.009
It's not accessible by either TIS API.

00:46:45.010 --> 00:46:52.720
And this reminder also to, as you do provide your
keyboard layouts to make them bundled.key layouts.

00:46:52.719 --> 00:46:59.869
Some nonstatic state of input sources might be
whether it's currently enabled or currently selected.

00:46:59.869 --> 00:47:06.559
So you seen what we can do with the TISInputSourceRef,
what it is, but how do we get one in the first place?

00:47:06.559 --> 00:47:10.940
Well we have a powerful iterator API
called TISCreateInputSourceList.

00:47:10.940 --> 00:47:12.340
It's a very simple API.

00:47:12.340 --> 00:47:18.530
It takes a filter, really a dictionary of
properties of property keys and values.

00:47:18.530 --> 00:47:22.890
And it returns an array of text input
sources that match your criteria.

00:47:22.889 --> 00:47:27.029
Another API is TISCopyInputSourceForLanguage.

00:47:27.030 --> 00:47:32.840
This takes a language in the BCP 47
format, a language code such as would be returned

00:47:32.840 --> 00:47:38.150
by a CF locale create language identifier from stream.

00:47:38.150 --> 00:47:42.750
And it'll return the most recently used
text input source for that language

00:47:42.750 --> 00:47:45.210
or whose intended language is what you specify.

00:47:45.210 --> 00:47:49.420
And we'll discuss inconvenience functions
that also return TISInputSourceRefs.

00:47:49.420 --> 00:47:53.070
Here's an example of the iterator API in action.

00:47:53.070 --> 00:48:00.070
TISCreateInputSourceList is being passed
to filter, a dictionary of one key value pair.

00:48:00.070 --> 00:48:06.800
In this case we're interested all input
sources whose category is palette input source.

00:48:06.800 --> 00:48:08.250
We're interested in all palettes.

00:48:08.250 --> 00:48:13.159
You'll note the second parameter to
TISInputSourceList is important.

00:48:13.159 --> 00:48:19.859
In this case we're only interested in text input sources
that match the criteria that happen to be enabled currently.

00:48:19.860 --> 00:48:22.890
There are times where you would want to
find input sources that are not yet enabled

00:48:22.889 --> 00:48:25.469
by the user but are installed in the system.

00:48:25.469 --> 00:48:30.219
So you pass through in that case to look through
all the installed input sources but you'll want

00:48:30.219 --> 00:48:32.819
to exercise some care with the filter you pass in.

00:48:32.820 --> 00:48:38.920
If your filter is too loose, not restrictive enough, you
may end up allocating memory for a whole bunch of objects

00:48:38.920 --> 00:48:43.579
in your app's memory that you did not intend to use.

00:48:43.579 --> 00:48:47.529
You see the second API we mentioned
TISCopyInputSourceForLanguage.

00:48:47.530 --> 00:48:51.650
Again it takes a language code in BCP 47 format.

00:48:51.650 --> 00:48:56.450
In this case the Czechk line which it'll
return the last used input source for Czechk.

00:48:56.449 --> 00:49:01.569
I mentioned some convenience APIs as well for the
current state of the user's configuration.

00:49:01.570 --> 00:49:04.440
You may be interested in the current keyboard input source.

00:49:04.440 --> 00:49:06.880
Again this may not necessarily be a keyboard layout.

00:49:06.880 --> 00:49:10.559
It could be an input method or an input mode.

00:49:10.559 --> 00:49:13.099
The current input mode may not be Roman.

00:49:13.099 --> 00:49:14.409
It may not be ASCII capable.

00:49:14.409 --> 00:49:15.980
And that may be something you want.

00:49:15.980 --> 00:49:19.139
What is the last used ASCII capable input source?

00:49:19.139 --> 00:49:24.739
Keyboard input source, so we have
TISCopyCurrentASCIICapableKeyboardInputSource.

00:49:25.800 --> 00:49:29.910
Neither of those need to be keyboard layouts and
you may really want the keyboard layout for yourself

00:49:29.909 --> 00:49:34.909
or perhaps you want to retranslate key
events, changing modifier bits and so forth.

00:49:34.909 --> 00:49:40.719
So you can get that through the
TISCopyCurrentKeyboardLayoutInputSource.

00:49:40.719 --> 00:49:44.239
That input source may not be ASCII capable either.

00:49:44.239 --> 00:49:50.209
So we have another accesser,
TISCopyCurrentASCIICapableKeyboardLayoutInputSource.

00:49:50.210 --> 00:49:59.280
And in the case where an ASCII capable keyboard layout is
not actually enable by the user this will usually return

00:49:59.280 --> 00:50:04.620
to where it was used in Mac buddy in the set
up system at the time you installed the system.

00:50:07.250 --> 00:50:10.710
Here are the things you can do in the manipulation space.

00:50:10.710 --> 00:50:17.289
You can enable input sources, disable them, you can
select usually any input source if it's selectable.

00:50:17.289 --> 00:50:20.099
But you cannot de select a keyboard input source.

00:50:20.099 --> 00:50:24.980
There's only one keyboard input source active
at a time so you can only select another one.

00:50:24.980 --> 00:50:27.650
And the de selection is implicit in that case.

00:50:27.650 --> 00:50:31.900
But you can deselect explicitly palette input sources.

00:50:31.900 --> 00:50:35.180
And again there are things that could
not be done with the script manager.

00:50:35.179 --> 00:50:39.559
That is selection, enabling, disabling
deselection from the background.

00:50:39.559 --> 00:50:42.679
And that automatically takes effect in the foreground.

00:50:42.679 --> 00:50:45.199
And so, we have two notifications that are dispatched

00:50:45.199 --> 00:50:50.139
through the CF distributed notification
center, not the local center.

00:50:50.139 --> 00:50:56.269
Have selected KeyboardInputSourceChanged
or EnableKeyboardInputSourceChanged.

00:50:56.269 --> 00:51:00.880
These would be dispatched for example as a user enables

00:51:00.880 --> 00:51:09.430
or disables input sources in the
internationalization press panel.

00:51:09.429 --> 00:51:14.519
And so to show you how powerful these API are
we'll tie everything together with a nice demo

00:51:14.519 --> 00:51:16.960
that Peter Edburg will be helping use with.

00:51:16.960 --> 00:51:21.820
>> Peter: Hi, what we've got here,
thanks, what I've got here is app,

00:51:21.820 --> 00:51:28.730
it's a bit of a cross between the international
preferences input menu pane and the text input menu.

00:51:28.730 --> 00:51:37.340
And so just to illustrate the discovery or iteration,
basically it requested a list of all of the keyboard input,

00:51:37.340 --> 00:51:44.190
all of the installed keyboard input sources in the system
and that's what the table source is displaying here.

00:51:44.190 --> 00:51:47.440
in terms of properties, some of the properties,

00:51:47.440 --> 00:51:52.389
and I should mention that everything that's being
done here is being done with public TIS API.

00:51:52.389 --> 00:51:56.309
Some of the properties are being
displayed in the table view here.

00:51:56.309 --> 00:52:01.239
for example is it ASCII capable what
the type is and icon and so on.

00:52:01.239 --> 00:52:08.509
And to get additional properties I can select on
a row for example and I get the InputSourceID,

00:52:08.510 --> 00:52:14.510
the BundleID if it's a bundled source, the
InputModeID if it's an input mode and the language codes.

00:52:14.510 --> 00:52:20.620
And the language codes for key layouts we figure out
automatically from the repertoire of the key layout

00:52:20.619 --> 00:52:27.000
and the ICU exemplar or the CLDR exemplar set.

00:52:27.000 --> 00:52:30.949
So, for example for Czech, it's intended for
Czech but it can also be used to input a number

00:52:30.949 --> 00:52:35.230
of other languages including German, English and so on.

00:52:35.230 --> 00:52:36.990
There are notifications going back and forth.

00:52:36.989 --> 00:52:43.899
So, for example if I, right now we haven't gotten
Czech as an enabled key layout but if I enable it here

00:52:43.900 --> 00:52:46.750
for example it the text input menu
will reflect that and so on.

00:52:46.750 --> 00:52:50.900
If I select it here in the text input
menu it shows up as selected here.

00:52:50.900 --> 00:52:58.930
In terms of the current state, the
bottom four fields show the state

00:52:58.929 --> 00:53:02.349
of the various convenience APIs that Mike was mentioning.

00:53:02.349 --> 00:53:09.889
So, for example if I select US then US is our current
key layout, or keyboard input source, it's ASCII capable

00:53:09.889 --> 00:53:12.839
of the Key layout and it's the ASCII capable key layout.

00:53:12.840 --> 00:53:19.710
If I select say Russian, okay well
Russian is not ASCII capable

00:53:19.710 --> 00:53:24.460
but it is the keyboard layout input source
and it's also the current key layout.

00:53:24.460 --> 00:53:29.650
I can select, for example Romaji.

00:53:31.179 --> 00:53:39.730
Romaji is ASCII capable okay so it shows up
as the ASCII capable input source and so on.

00:53:41.170 --> 00:53:49.420
Let's see, and I think the only other thing I wanted to
illustrate is that the APIs that enabled manipulation

00:53:49.420 --> 00:53:51.809
of input sources can operate in the background.

00:53:51.809 --> 00:53:58.029
Let me just get rid of a few of these so it's,
so we don't have to go through many, so many.

00:53:58.030 --> 00:54:06.820
I'm going to turn off some of the input methods here
and then go to this little facility that will cycle

00:54:06.820 --> 00:54:09.600
through the enabled input sources in the background.

00:54:09.599 --> 00:54:15.589
So you can see that the menu up there is changing and I'm
just going to be hitting the same key on the keyboard here.

00:54:15.590 --> 00:54:21.720
So now we've got text edit in foreground,
my little test app here is working

00:54:21.719 --> 00:54:25.259
in the background changing the input sources.

00:54:25.260 --> 00:54:36.740
So there's Arabic, and Czech, and so on, anyway, French, okay.

00:54:36.739 --> 00:54:38.689
And that's about it.

00:54:38.690 --> 00:54:42.510
So that you can do with the TIS API. Thank you.

00:54:42.510 --> 00:54:47.720
( Applause )

00:54:47.719 --> 00:54:49.289
>> Mike: Thank you Peter.

00:54:49.289 --> 00:54:55.690
And the rest of the talk will be considering
briefly the state of the Text Services Manager.

00:54:58.090 --> 00:55:02.910
TSM, for short, is introducing a new
model for restricting input sources.

00:55:02.909 --> 00:55:13.739
This was formerly done by using the super deprecated
KeyScript API restricting input source, the restriction,

00:55:13.739 --> 00:55:19.739
restricting input sources means limiting the
set of text input sources available to the user

00:55:19.739 --> 00:55:22.949
in the context of a particular text field for example.

00:55:22.949 --> 00:55:27.779
So, we'll be considering that, and a brief
mention on some support in TSM Carbon events

00:55:27.780 --> 00:55:33.720
for resolution independence, modern event
primary types, and the state of TSM and 64-bit.

00:55:33.719 --> 00:55:41.299
So input source restriction, the KeyScript API had
a limitation or an inconvenience in that it required,

00:55:41.300 --> 00:55:45.350
first of all it was global in scope,
at least in application scope.

00:55:45.349 --> 00:55:50.690
And whenever you restrict this sort of input sources
for a particular text field you have to carefully undo

00:55:50.690 --> 00:55:56.700
that before switching to another text field
so that the effects would not spill over.

00:55:56.699 --> 00:56:01.199
But really the set of text input sources available
for text field are a property of that text field

00:56:01.199 --> 00:56:05.849
and it should be encapsulated by the input
context, in this case the TSMDocument itself.

00:56:05.849 --> 00:56:13.380
So, TSM is introducing two new TSMDocument properties,
the EnabledInputSourcesPropertyTag and that allows you

00:56:13.380 --> 00:56:20.260
to specify an array of TISInputSourceRefs to which the
user should be restricted in the context of the text field.

00:56:20.260 --> 00:56:24.660
And you can also specify a preferred
input source within that set

00:56:24.659 --> 00:56:28.099
to be switched too the next time
that text field gets focused.

00:56:28.099 --> 00:56:32.699
And again because they are properties of the
input context with the TSMDocument you can set it

00:56:32.699 --> 00:56:36.779
at any time even at the creation of your text field.

00:56:36.780 --> 00:56:46.350
Set it and forget it, let TSM do the gymnastics
of doing and undoing the restriction for you.

00:56:47.909 --> 00:56:55.129
Now as the user's session, the user's
log in session goes on the user may

00:56:55.130 --> 00:56:59.050
at various times enable different
input sources or disable some.

00:56:59.050 --> 00:57:05.390
And you would want the set of enabled input sources to
which you restrict a particular context to reflect that.

00:57:05.389 --> 00:57:11.750
So, you'll from time to time want to look for the
enabled keyboard input sources change notification

00:57:11.750 --> 00:57:17.210
that is dispatched through the CF
distributed notification center.

00:57:17.210 --> 00:57:22.070
Here's some examples of the new document properties in use.

00:57:22.070 --> 00:57:28.050
We have the EnabledInputSourcesPropertyTag being set
for a particular TSMDocument or just passing in an array

00:57:28.050 --> 00:57:30.340
of TISInputSourceRefs in the first example.

00:57:30.340 --> 00:57:35.700
And then at a later time simply removing that
restriction with a TSMRemoveDocumentProperty API.

00:57:35.699 --> 00:57:40.759
If you want to specify preferred input source
within a set of restricted input sources,

00:57:40.760 --> 00:57:45.190
you have an example of the override
property tag being used for that.

00:57:45.190 --> 00:57:48.300
Cocoa also has a similar notion.

00:57:48.300 --> 00:57:54.769
While it doesn't expose the notion of a
TISInputSourceRef, it does allow you to restrict a set

00:57:54.769 --> 00:58:00.860
of input sources available for a text field
using the SetAllowedInputSourceLocalees API.

00:58:00.860 --> 00:58:07.059
And again instead of passing an array of
TISInputSourceRefs, you pass an array of language code

00:58:07.059 --> 00:58:13.460
or language identifiers in BCP 47 format
or loGcale identifiers work as well.

00:58:13.460 --> 00:58:17.990
And if at a later time if you want to
remove the restriction just pass nil.

00:58:17.989 --> 00:58:20.539
By far the most common type of input source restriction

00:58:20.539 --> 00:58:27.750
that you'll see used is the need
for Roman input or ASCII only input.

00:58:27.750 --> 00:58:36.750
There's a convenience API TISCreateASCIICapableInputSourceList
that will return to you the entire set

00:58:36.750 --> 00:58:42.079
of enabled ASCII capable input sources and
you can just pass that indirectly as the value

00:58:42.079 --> 00:58:44.259
of the EnabledInputSourcePropertyTag.

00:58:44.260 --> 00:58:49.880
And Cocoa has a similar notion with a constant
NSAllRomanInputSourcesLocaleIdentifiers

00:58:49.880 --> 00:58:53.800
that you can pass directly to setAllowedInputSourceLocales.

00:58:55.800 --> 00:59:03.010
TSM has modified a number of event parameters in
the current events that defines to the float types

00:59:03.010 --> 00:59:11.670
where in the past there were a mixture of different
numeric types, typedFixed, and the typeSInt16, and so forth.

00:59:11.670 --> 00:59:21.340
You can request any event parameter that's typed
as a float using typeCGFloat if you want.

00:59:21.340 --> 00:59:25.480
And in that case you will get data that's 72 dpi by default.

00:59:25.480 --> 00:59:33.110
But you can also, as shown in the example
below, request that event parameter

00:59:33.110 --> 00:59:38.059
in using a coordinate space variant of the typeFloat.

00:59:38.059 --> 00:59:46.469
So you see here we're asking for the ReplyLineHeight
which is unidimensional value but you may want

00:59:46.469 --> 00:59:48.649
that in screen pixels instead of in 72 dpi.

00:59:48.650 --> 00:59:56.420
And the same thing is done automatically by the Carbon event
manager, it does this coercion automatically independent

00:59:56.420 --> 00:59:59.309
of what is actually in the Carbon unit for you.

00:59:59.309 --> 01:00:04.710
And that applies to typeFloat, it
applies to points, typeHIPoint.

01:00:04.710 --> 01:00:11.059
And so you have screen pixel variance of
typeHIPoint and also for typeHIRect.

01:00:12.539 --> 01:00:17.599
TSM has also introduced our support
for a number of modern data types.

01:00:17.599 --> 01:00:21.980
We, see here typeCTFontRef referring
to the CTFontRef data type,

01:00:21.980 --> 01:00:27.199
CTGlyphInfoRef are also supported
in addition to CFAttributedStrings.

01:00:27.199 --> 01:00:31.409
Now, an application may modernize to
use those types in the events it returns

01:00:31.409 --> 01:00:34.059
but the input methods may not or vice versa.

01:00:34.059 --> 01:00:38.759
So TSM solves this compatibility
problem with a promise mechanism

01:00:38.760 --> 01:00:46.710
where it will promise one modern parameter
from the older parameters and vice versa.

01:00:46.710 --> 01:00:53.240
So it automatically coerced one set of parameters to
or from the other based on how you request the data.

01:00:53.239 --> 01:00:56.229
An example below we have the OffsetToPosevent.

01:00:56.230 --> 01:01:02.670
You may return an ATS font and point
size and the input method may request

01:01:02.670 --> 01:01:08.420
that information using the
kEventParamTextInputReplyCTFontRef.

01:01:08.420 --> 01:01:11.240
And TSM will coerce that from the older data.

01:01:11.239 --> 01:01:17.709
There's another example of coercing an attributed string
from Sintax and GlyphInfo and font array in the event.

01:01:17.710 --> 01:01:20.840
And this works in both directions.

01:01:22.090 --> 01:01:29.350
By now you've all heard that a part of Carbon,
the tool box, the part of the Carbon that deals

01:01:29.349 --> 01:01:35.710
with user interface is not available in 64-bit
and that includes the Text Services Manager.

01:01:35.710 --> 01:01:40.639
This would not normally be an issue for you because
the direction, of course is to go with Cocoa.

01:01:40.639 --> 01:01:45.199
And Cocoa encapsulates all of the interaction
with the Text Services Manager anyway.

01:01:45.199 --> 01:01:51.000
Of course if you're doing some heavy duty
customization of Cocoa, in particular a layout engines,

01:01:51.000 --> 01:01:58.369
perhaps you want to do vertical text layout, you will need
to support interactions with input methods and so forth.

01:01:58.369 --> 01:02:04.009
And that is doable by using the NSInputContext.

01:02:04.010 --> 01:02:08.190
This was made public in Mac OS X 10.4.

01:02:09.900 --> 01:02:14.680
Compliment based input methods are also not
supported in 64-bit so you'll be very interested

01:02:14.679 --> 01:02:19.629
in deploying your input method for
64-bit using the input method kit.

01:02:19.630 --> 01:02:26.869
There's a session a hands on session on the Input Method Kit
Friday morning after the lab that we'll be showing later on.

01:02:26.869 --> 01:02:30.230
I believe that's session 577.

01:02:31.659 --> 01:02:35.969
So in summary for my part of the talk it's a Unicode world.

01:02:35.969 --> 01:02:42.019
Let's get off of the script manager, stop using KeyScripts,
we really need all the keyboard layout developers

01:02:42.019 --> 01:02:47.369
or providers to switch to the uchar
and bundled .keylayouts.

01:02:47.369 --> 01:02:53.309
We talked a little bit about the Cocoa support for
restriction of input sources allowed input source locale API

01:02:53.309 --> 01:02:57.449
and a similar notion in TSM through the document properties.

01:02:57.449 --> 01:03:03.149
Really you'll get the latest goodness by reading our headers
TextInputSources, TextServices, and CarbonEvents.

01:03:03.150 --> 01:03:07.139
And again for input method deployment for
64-bit you'll really be interested

01:03:07.139 --> 01:03:11.309
in the Input Method Kit session on Friday morning.

01:03:11.309 --> 01:03:18.230
And a brief summary of everything we've talked about
this morning, again it's a Unicode world, be Unicode.

01:03:18.230 --> 01:03:23.429
We talked about the CF modern API available
to replace the older deprecated functionality

01:03:23.429 --> 01:03:29.500
in particular CSStringTokenizer
and the TextInputSources API.

01:03:29.500 --> 01:03:33.440
Some contact information for your Evangelist Derek Horn.
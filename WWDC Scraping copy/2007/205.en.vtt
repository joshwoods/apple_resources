WEBVTT

00:00:13.169 --> 00:00:19.189
>> Good morning, thank you all for getting out here at such
a bright and really unnaturally early hour for programmers.

00:00:19.190 --> 00:00:22.140
Welcome to session 205, making your application scriptable.

00:00:22.140 --> 00:00:27.710
I'm Chris Nebel, I'm one of the engineers
in the scripting and automation group.

00:00:29.690 --> 00:00:34.350
So, this morning, the wonders of
scripting and scriptability.

00:00:34.350 --> 00:00:38.320
Scriptability is wonderful for
your users of your application.

00:00:38.320 --> 00:00:40.039
They can solve real problems on their own.

00:00:40.039 --> 00:00:45.109
It's great for you, for a whole host of reasons,
we'll be going through a bunch of those,

00:00:45.109 --> 00:00:47.509
and it's not a whole lot of work actually.

00:00:47.509 --> 00:00:49.649
Possibly far less than you're expecting.

00:00:49.649 --> 00:00:54.320
If you've been following standard design practices,
you've probably written half the code you need already,

00:00:54.320 --> 00:01:01.149
and we'll talk some more about that in a bit more detail.

00:01:01.149 --> 00:01:02.129
Why be scriptable?

00:01:02.130 --> 00:01:04.640
We go through a bunch of the reasons
what you'll get out of it.

00:01:04.640 --> 00:01:07.859
Some interesting new things in Leopard
that you can do with scriptability.

00:01:07.859 --> 00:01:12.489
And then I'll hand over to John Kaminsky
who will talk a bunch about the how.

00:01:12.489 --> 00:01:16.069
Designing a dictionary, writing code, and testing it all.

00:01:16.069 --> 00:01:18.959
So, let's begin.

00:01:18.959 --> 00:01:19.839
Why be scriptable?

00:01:19.840 --> 00:01:22.820
What am I going to get out of this?

00:01:24.359 --> 00:01:25.989
So, first off, some of you are probably new to this.

00:01:25.989 --> 00:01:28.899
I should say, I should clarify what
the heck I mean by scriptability.

00:01:28.900 --> 00:01:35.390
Scriptability is simply the ability of your application
to be controlled by another application, a program,

00:01:35.390 --> 00:01:39.890
instead of somebody sitting there
with a mouse and a keyboard.

00:01:39.890 --> 00:01:44.500
Now, this is just like an API, and you know, you've seen
lots of different APIs, they have lots of different shapes.

00:01:44.500 --> 00:01:49.409
We're not talking about just any sort of scriptability
here, what we're really talking about is OSA compliant.

00:01:49.409 --> 00:01:51.569
OSA is short for Open Scripting Architecture.

00:01:51.569 --> 00:01:55.939
It's kind of this little universe of technologies
that all work together, it's the languages,

00:01:55.939 --> 00:02:00.539
the scriptable applications, and it's the
protocol between them using Apple events.

00:02:00.540 --> 00:02:03.950
All that together makes up the OSA.

00:02:03.950 --> 00:02:10.920
And the system works a lot better if all of the applications
play by similar rules, if they have a similar shape

00:02:10.919 --> 00:02:13.459
and protocol to their scripting interface.

00:02:13.460 --> 00:02:18.120
Means that all the applications work
at least a little bit the same way.

00:02:18.120 --> 00:02:19.300
The Macintosh is kind of like this.

00:02:19.300 --> 00:02:23.100
You go to any application, you know that there's
certain basic commands that work the same way, you know,

00:02:23.099 --> 00:02:26.219
a button always does a button like
thing, a button like thing.

00:02:26.219 --> 00:02:31.080
So, OSA compliant, and these are all written
down, they're all, it's a whole set of guidelines,

00:02:31.080 --> 00:02:37.070
and the scripting interface guidelines which is techno 2106,
but the one particular bit that I want to call out now is

00:02:37.069 --> 00:02:43.139
that we're talking about model scripting, not view
scripting, and this is model and view in the same sense

00:02:43.139 --> 00:02:48.769
as model view controller, which most applications follow,
even if they weren't doing it entirely intentionally.

00:02:48.770 --> 00:02:55.070
So, the model is your, it's what your application
actually does, it's your application's view of reality,

00:02:55.069 --> 00:02:58.689
as it defines it, it's the actual
objects and operations that it defines.

00:02:58.689 --> 00:03:03.590
The view is simply what that looks like on screen,
you know, the windows and menus and what not,

00:03:03.590 --> 00:03:09.650
how you present it to the user, and when some people hear
scriptability, they think, you know, oh, I can, you know,

00:03:09.650 --> 00:03:15.510
there's an accessibility API, right, that I can get
in by system calls and find out where all my menus

00:03:15.509 --> 00:03:21.769
and buttons are, and I can poke those, and you know,
that's, I can write a program to do all that, I'm done.

00:03:21.770 --> 00:03:25.590
Well, except that what you've actually
got there is view scripting,

00:03:25.590 --> 00:03:35.250
and view scripting by its nature is extremely brittle,
it depends on precisely how your interface is laid out.

00:03:35.250 --> 00:03:40.250
So, if you ever change your interface, if
you ever move anything around, scripts break,

00:03:40.250 --> 00:03:42.539
and as we'll discuss more in a bit, that's bad.

00:03:42.539 --> 00:03:47.469
Did you really want to commit to exactly
the interface you have now for all time?

00:03:47.469 --> 00:03:49.580
Probably not.

00:03:50.659 --> 00:03:58.349
Model scripting on the other hand, this talking directly
to what your application does, that's much more durable.

00:03:58.349 --> 00:04:03.319
It's much more comprehensible, it changes, it
changes fairly infrequently, and when it does change,

00:04:03.319 --> 00:04:08.590
it changes in relatively predictable ways, and
it's also easy to put in backwards compatibility

00:04:08.590 --> 00:04:14.300
so the old scripts still keep working even though
you aren't directly revealing that stuff anymore.

00:04:16.069 --> 00:04:22.519
So, you decided, okay, I'll start scripting and
I'll buy this, what are you going to get out of it?

00:04:22.519 --> 00:04:27.469
The first thing you'll get as soon as you implement any
of it, is that you've got an automated testing tool now.

00:04:27.470 --> 00:04:30.560
You've got an automated testing
tool that can test your application,

00:04:30.560 --> 00:04:33.209
and of course you can do this to
view all sorts of useful things.

00:04:33.209 --> 00:04:35.939
You can do regression tests, you
can, you know, make big changes,

00:04:35.939 --> 00:04:38.300
and make sure that you didn't accidentally
change anything you didn't want to.

00:04:38.300 --> 00:04:44.930
You can do stress testing, what happens when you throw
10,000 cards at address book, something like that.

00:04:44.930 --> 00:04:47.370
You can validate releases before you ship
them, make sure that all the features

00:04:47.370 --> 00:04:50.040
that are there are still working
the way they're supposed to.

00:04:50.040 --> 00:04:52.330
So, this is all very useful.

00:04:52.329 --> 00:04:56.649
The next thing, and again, before you even ship
this, is that you start getting to integrate

00:04:56.649 --> 00:05:01.129
with other scriptability, other parts
of the OSA universe in the system,

00:05:01.129 --> 00:05:03.949
so you can start writing Automator actions for instance.

00:05:03.949 --> 00:05:08.029
You can start writing scripts, you can
write entire applications that talk

00:05:08.029 --> 00:05:12.199
to your application using AppleScript Studio.

00:05:12.199 --> 00:05:15.129
And you can even leverage other scriptable applications.

00:05:15.129 --> 00:05:18.269
You can get other applications to do your work for you.

00:05:18.269 --> 00:05:20.789
So, if you need to send a mail
message, you can talk to mail.

00:05:20.790 --> 00:05:24.660
If you need something graphed, you can tell
Microsoft Excel to do it, if you need a diagram drawn,

00:05:24.660 --> 00:05:26.450
you can get OmniGraph to do that for you.

00:05:26.449 --> 00:05:30.779
There are entire applications that
are written doing nothing but this.

00:05:30.779 --> 00:05:36.219
There's a Kinkless GTD, that's a task
management software, that's really just a set

00:05:36.220 --> 00:05:39.110
of scripts that talks to Omni Outliner, right.

00:05:39.110 --> 00:05:45.930
They didn't write any of their own outlining or drawing code
or anything like that, they let Omni Outliner do all of it.

00:05:45.930 --> 00:05:49.060
Okay, so this is pretty cool already.

00:05:49.060 --> 00:05:54.079
Now you actually ship the thing, and now
your users get to start playing with it.

00:05:54.079 --> 00:05:56.109
So, they get about as much of benefits out of this too.

00:05:56.110 --> 00:06:03.020
They get to solve real problems on their own, and invariably
your application doesn't do precisely what they want, right,

00:06:03.019 --> 00:06:04.709
they need to do some sort of customization.

00:06:04.709 --> 00:06:06.680
Scripting gives them the tool to do that.

00:06:06.680 --> 00:06:09.449
And you know, they can do it on their own.

00:06:09.449 --> 00:06:11.589
They don't have to come to you saying oh, I
need this feature, please, please, please.

00:06:11.589 --> 00:06:19.000
No, they just get it done immediately, and if they, if
they talk about it, they will, scripters love to brag,

00:06:19.000 --> 00:06:25.209
you get feedback on what they did, and so the customers
get their work done faster not only because they get

00:06:25.209 --> 00:06:30.209
to write their own features effectively,
but because now it's automated, right.

00:06:30.209 --> 00:06:36.879
Humans are slow and, you know, they get bored,
and they get distracted, ooh, look iPhone.

00:06:37.920 --> 00:06:41.530
Computers don't have that problem, they'll do, you
know, they're about as smart as a box of hammers,

00:06:41.529 --> 00:06:46.719
but they will do the same thing every time
repeatedly, and they don't mind working weekends,

00:06:46.720 --> 00:06:52.990
or if they do, we haven't heard about it.

00:06:52.990 --> 00:06:59.100
So, once your customers start using it, you
know, it starts to flow back to you again.

00:06:59.100 --> 00:07:03.150
When a customer buys your application,
they aren't really buying your application.

00:07:03.149 --> 00:07:11.719
What they're buying is a part of a solution for them,
and once they build your application into your, you know,

00:07:11.720 --> 00:07:13.420
they're building a solution, they're building a workflow.

00:07:13.420 --> 00:07:18.050
Once your application becomes part of that workflow,
that's the product they actually care about,

00:07:18.050 --> 00:07:23.759
that's the product they want to keep, and
they will never get rid of your application,

00:07:23.759 --> 00:07:25.569
as long as you're part of their workflow.

00:07:25.569 --> 00:07:31.560
Never. They will just keep buying your application,
keep buying reps, until you break their workflow.

00:07:31.560 --> 00:07:34.139
This is where that, you know, don't
break scriptability part comes in.

00:07:34.139 --> 00:07:45.750
If you break their scripts, then you've broken their
solution, and yeah, they're going to start looking around.

00:07:45.750 --> 00:07:50.430
So, finally, you get to, you get to spend less, spend
less money, or spend your money more effectively,

00:07:50.430 --> 00:07:53.290
because you're letting your customers
doing the customization.

00:07:53.290 --> 00:07:57.090
You don't have to write every single feature for
them, they can do a lot of it for themselves,

00:07:57.089 --> 00:08:04.299
and you can watch what they customize, you know, by feature
customize is custom, a lot of people will be doing things

00:08:04.300 --> 00:08:07.680
that are interesting only to them,
but you may notice that, oh, hmm,

00:08:07.680 --> 00:08:11.420
there are a bunch of customers doing
this particular task over here,

00:08:11.420 --> 00:08:15.759
maybe that would actually be a good
thing to add as a real feature.

00:08:15.759 --> 00:08:20.349
So, you get out of this is that you get to spend
your time and money more effectively doing the things

00:08:20.350 --> 00:08:23.660
that actually pay off for you and your customers.

00:08:23.660 --> 00:08:31.480
So, that's the virtues, and there's
some new stuff in Leopard.

00:08:31.480 --> 00:08:35.759
Some new, interesting things you
can do playing with scriptability.

00:08:35.759 --> 00:08:38.649
First up is AppleScript.

00:08:40.000 --> 00:08:41.460
There we go.

00:08:41.460 --> 00:08:46.759
AppleScript is the original scripting language on the
Macintosh, it's been around for about 14 years now.

00:08:46.759 --> 00:08:49.340
We expect it to be around for much longer.

00:08:52.240 --> 00:08:57.779
And, you know, it's been working fine for that
time, but we're continuing to make improvements,

00:08:57.779 --> 00:09:00.839
so in Leopard there are, there are
actually lots and lots of little things,

00:09:00.840 --> 00:09:05.850
but two really big ones is one it's all Unicode all the
time now, so you don't have to worry about, you know,

00:09:05.850 --> 00:09:08.590
there used to be two different string
classes in AppleScript that are like,

00:09:08.590 --> 00:09:10.340
as many as five depending on how you counted.

00:09:10.340 --> 00:09:17.930
You don't have to worry about that any of that stuff
anymore, and we improved the application objects.

00:09:17.929 --> 00:09:20.679
Obviously this is kind of the art and soul of AppleScript.

00:09:20.679 --> 00:09:22.579
You tell applications to do stuff for you.

00:09:22.580 --> 00:09:25.440
It's a bit more flexible, and a bit easier now.

00:09:25.440 --> 00:09:30.180
You can tell applications by ID directly, you used
to have to do this four line dance to do that.

00:09:30.179 --> 00:09:35.659
If you need to find out an application's running, there're
a bunch of built in properties now that work just built

00:09:35.659 --> 00:09:38.370
in to AppleScript, so if you need to
find out if an application's running,

00:09:38.370 --> 00:09:42.090
you can ask exactly that now, and it works.

00:09:42.090 --> 00:09:48.550
So, the really, the really interesting
one is something we call scripting bridge.

00:09:48.549 --> 00:09:53.459
So, you know, you want to, you want to control iTunes.

00:09:53.460 --> 00:09:59.180
You have an application, you're doing some sort of little
I thing, iTunes control, or you need to talk to iTunes.

00:09:59.179 --> 00:10:03.519
Now, the traditional way, you know, like I said, Apple
Scripts been around for 14 years, the traditional way to do

00:10:03.519 --> 00:10:08.399
that is you write an AppleScript to do that,
so okay, but you know, say you're going,

00:10:08.399 --> 00:10:14.389
you're writing a real application here, you're
actually working in Objective C, so now what do you do?

00:10:14.389 --> 00:10:22.939
Well, the gut of this communication is a protocol called
Apple Events, you know, inner process communication.

00:10:24.100 --> 00:10:28.490
And there's a perfectly well defined
API for sending Apple events

00:10:28.490 --> 00:10:33.750
from Objective C. It's called NS Apple event
scripter, you know, been around since I think it's been

00:10:33.750 --> 00:10:38.000
around since Mac was ten point oh, and so, you know,
say you want to get the name of the current track

00:10:38.000 --> 00:10:39.840
of iTunes, you know, slap that up on the screen.

00:10:39.840 --> 00:10:45.740
Okay, no problem, all you have to do is write this.

00:10:45.740 --> 00:10:50.320
Naturally, people lack enthusiasm for this.

00:10:50.320 --> 00:10:56.030
So, what most people actually do is they go back to
AppleScript because there's a class to do that to,

00:10:56.029 --> 00:11:00.179
so what you do is you write a little script, that
just, you know, literally a little AppleScript,

00:11:00.179 --> 00:11:04.279
stick that in your application, and when time comes,
you compile and run, and you get your answer back.

00:11:04.279 --> 00:11:10.860
And obviously this is a lot simpler, and
it works, but it doesn't work real well.

00:11:10.860 --> 00:11:17.139
Compared to the NS Apple Event scripter, yes, it's less
effort for you, but it's a lot more effort for the computer.

00:11:17.139 --> 00:11:20.759
You wind up spending somewhere between
ten and a hundred or even a thousand times

00:11:20.759 --> 00:11:22.769
of execution at a time in really bad cases.

00:11:22.769 --> 00:11:27.639
Takes a bunch of additional memory.

00:11:27.639 --> 00:11:33.509
Getting values into the script and back out to objective
C can be kind of a pain, and the larger your script gets,

00:11:33.509 --> 00:11:38.889
the more logic you try to stuff in there, the worse the
three other problems get, so that's problem of scaling.

00:11:38.889 --> 00:11:44.179
So, what we wanted was something that, you know,
is easy to use, but still has the efficiency

00:11:44.179 --> 00:11:48.819
of the direct apple events, and
that's what scripting bridge is.

00:11:48.820 --> 00:11:53.230
So, three steps to use it.

00:11:53.230 --> 00:11:58.610
Step one, generate a header file for the application
you're interested in, iTunes, and add it to your project,

00:11:58.610 --> 00:12:02.539
as the command line tool to do
this, this is what it looks like.

00:12:02.539 --> 00:12:07.129
Step two is you link to scripting
bridge dot framework, new in Leopard.

00:12:07.129 --> 00:12:09.019
Step three, profit.

00:12:09.019 --> 00:12:10.720
This is what the code looks like.

00:12:10.720 --> 00:12:17.470
The first line gets a reference to the iTunes application,
and the second line gets the current tracks name,

00:12:17.470 --> 00:12:24.080
and returns the result as a NS string, there's no
translation to, you know, NS Apple event scripter needed,

00:12:24.080 --> 00:12:28.110
and since this is Leopard, we have Objective
C too, it even works with property syntax.

00:12:28.110 --> 00:12:29.860
Doesn't get much simpler than that.

00:12:29.860 --> 00:12:30.669
( Applause )

00:12:30.669 --> 00:12:34.379
Thank you.

00:12:37.649 --> 00:12:38.669
Talk is cheap.

00:12:38.669 --> 00:12:40.509
Let's see a demo.

00:12:40.509 --> 00:12:44.169
( Silence )

00:12:44.169 --> 00:12:50.299
All right, so, little iTunes demo here.

00:12:50.299 --> 00:13:03.359
So, this was actually inspired by Skype, a voice over
IP application, and Skype has this clever little feature

00:13:03.360 --> 00:13:10.259
that if you're running iTunes, you're playing your music,
and a call comes in, it'll automatically pause iTunes,

00:13:10.259 --> 00:13:17.200
and then when the, when you hang up the call, it'll start
iTunes playing again, and it's actually a little clever

00:13:17.200 --> 00:13:21.509
about it, it fades in, so watch
the volume slider when I do this.

00:13:21.509 --> 00:13:24.139
( Music )

00:13:24.139 --> 00:13:27.549
So, this is written going the kind of traditional way.

00:13:27.549 --> 00:13:31.639
It's using NS AppleScript to compile and execute an
AppleScript on the fly, and for these two buttons,

00:13:31.639 --> 00:13:37.120
it works well enough, because these are only sending a few
events, but if you wind up in a position where you have

00:13:37.120 --> 00:13:41.710
to send a lot of events, like this is
going to crank through, whoops, haha,

00:13:41.710 --> 00:13:46.509
I just stole my own thunder, and ran the wrong version.

00:13:46.509 --> 00:13:51.970
( Silence )

00:13:51.970 --> 00:13:54.509
ITunes demo of NS AppleScript.

00:13:54.509 --> 00:13:59.419
( Silence )

00:13:59.419 --> 00:14:05.360
Okay, if you have to send a few thousand events, be
sure to act really surprised when the next one comes up.

00:14:05.360 --> 00:14:11.930
It's actually drawing on every twentieth one, because
otherwise you might have testing drawing performance,

00:14:11.929 --> 00:14:17.229
but it's cranking all the song titles in my
library, about 13 hundred of them, one at a time.

00:14:17.230 --> 00:14:22.110
So, you know, we could probably do better than this.

00:14:22.110 --> 00:14:37.710
So, if we use the scripting bridge version, then
the, you know, we can still play, and pause,

00:14:37.710 --> 00:14:45.860
and song titles are just a little bit faster.

00:14:45.860 --> 00:14:47.269
( Applause )

00:14:47.269 --> 00:14:48.039
Wasn't that amazing?

00:14:48.039 --> 00:14:49.289
Yeah. And there's one more thing to this too.

00:14:49.289 --> 00:14:51.819
You know, I showed you the slides working,

00:14:51.820 --> 00:15:00.350
and it's all about Objective C. This program is not
actually written in Objective C, it's written in Python.

00:15:00.350 --> 00:15:01.800
( Applause )

00:15:01.799 --> 00:15:06.029
Stop that.

00:15:06.029 --> 00:15:07.740
There we go.

00:15:07.740 --> 00:15:10.519
So, what's happening here is kind of clever.

00:15:10.519 --> 00:15:19.679
The, there is a bridge from Python to Objective C,
it's called PyObC, it's part of the system in Leopard.

00:15:19.679 --> 00:15:23.159
And this lets you get at basically any Objective C class.

00:15:23.159 --> 00:15:26.860
You can just talk directly to the
Objective C runtime from Python.

00:15:26.860 --> 00:15:33.990
So, for the old version, we're just
using NS AppleScript to do this.

00:15:33.990 --> 00:15:41.299
And like I said, this works, but notice that, you know,
an awful lot of my code here is actually these strings

00:15:41.299 --> 00:15:46.899
which are AppleScript, and I have to do this
odd little dance to get a result from them.

00:15:46.899 --> 00:15:49.439
So, this is, you know, this is less than ideal.

00:15:49.440 --> 00:15:53.670
This is what the scripting bridge version looks like.

00:15:53.669 --> 00:15:58.629
And what happens here is actually kind of clever.

00:15:58.629 --> 00:16:03.470
When I get a reference to the application what it actually
does is it goes out and gets the scripting interface

00:16:03.470 --> 00:16:09.259
from iTunes, and uses that to construct Objective C
classes and methods that back everything that iTunes does,

00:16:09.259 --> 00:16:17.279
and once you're there, I can use them just like any other
framework class, in, you know, foundation or AppKit.

00:16:17.279 --> 00:16:20.389
So, here it is getting the name of the current track.

00:16:20.389 --> 00:16:28.620
Here is that fade in loop again, let me get
the side by side with the AppleScript version.

00:16:28.620 --> 00:16:36.740
So, instead of using just kind of the string, I'm
actually using, you know, looks like real Python,

00:16:36.740 --> 00:16:44.269
or real Python luke, and it even works with collections.

00:16:44.269 --> 00:16:51.980
So, you know, get all the tracks for I and P, whereas
with AppleScript, I had to actually, you know,

00:16:51.980 --> 00:16:56.580
go get the count separately and then do
an injure count, and then, yeah, whatever.

00:16:56.580 --> 00:16:57.110
All right.

00:16:57.110 --> 00:16:58.509
Slides, please.

00:16:58.509 --> 00:17:04.049
( silence )

00:17:04.049 --> 00:17:06.889
So, the scripting bridge works very nicely with Python.

00:17:06.890 --> 00:17:14.690
I use the name of the current track bit
again, and this same stunt works equally well

00:17:14.690 --> 00:17:18.910
with any language that has equivalent Objective C bridge.

00:17:18.910 --> 00:17:20.150
For instance Ruby.

00:17:20.150 --> 00:17:23.269
Ruby Cocoa is built into the system in Leopard.

00:17:23.269 --> 00:17:27.170
So, here's what the name of the
current track looks like in Ruby.

00:17:27.170 --> 00:17:30.130
It's really quite straightforward, works very well.

00:17:30.130 --> 00:17:35.850
So, the practical upshot of this,
there, well there are two actually.

00:17:35.849 --> 00:17:40.569
One is that if you're on the scripting side, then
your choice of languages just got a lot bigger.

00:17:40.569 --> 00:17:43.509
You can, you don't have to use
AppleScript if you don't want to.

00:17:43.509 --> 00:17:48.690
If you do want to, great, believe me, we're continuing
to support it, but if you don't, then that's fine too.

00:17:48.690 --> 00:17:56.120
Go use Ruby, go use Python, go use Objective
C, those work fine, and on the flip side,

00:17:56.119 --> 00:18:01.719
if you are an application developer, there are a
lot more possible people using your application,

00:18:01.720 --> 00:18:06.370
and its scriptability, and some of them are
written in objective C, maybe, you know,

00:18:06.369 --> 00:18:09.049
these people are going to be shipping real
applications based on your scripting interface.

00:18:09.049 --> 00:18:11.009
You really don't want to break them.

00:18:11.009 --> 00:18:15.279
Your scripting interface is API now, you
need to take it a bit more seriously.

00:18:15.279 --> 00:18:21.710
But a whole new world of possibilities there for
development and using scriptable applications.

00:18:21.710 --> 00:18:28.509
And with that, I'm going to hand over to
John Kaminsky who will talk about the how.

00:18:28.509 --> 00:18:35.629
( Applause )

00:18:35.630 --> 00:18:36.170
>> Good morning.

00:18:36.170 --> 00:18:41.660
My name's John Kaminsky, and I'm an engineer in the
AppleScript group, and thanks very much for being here.

00:18:44.970 --> 00:18:47.710
So, we're part way through our talk.

00:18:47.710 --> 00:18:50.480
We talked about why be scriptable and what's new in Leopard,

00:18:50.480 --> 00:18:53.690
now we're going to talk about actually
how to construct this.

00:18:53.690 --> 00:18:55.210
First step's designing a dictionary.

00:18:55.210 --> 00:18:55.920
Very important.

00:18:55.920 --> 00:19:00.440
We want you to spend a good chunk of time on that up front.

00:19:00.440 --> 00:19:05.820
Then you've got to write some code to support that,
make it all work, and most importantly we want

00:19:05.819 --> 00:19:11.309
to test it very thoroughly before you send it out.

00:19:11.309 --> 00:19:12.539
Designing a dictionary.

00:19:12.539 --> 00:19:14.519
This is about empowering the end user.

00:19:14.519 --> 00:19:19.539
Chris said that you give the end user the
ability to solve real problems on their own,

00:19:19.539 --> 00:19:23.450
and constructing a good dictionary
is the way that you do that.

00:19:23.450 --> 00:19:28.160
We want you, and we encourage you very
strongly, to deliver an object oriented solution.

00:19:28.160 --> 00:19:31.420
This is the most powerful thing for the scripter.

00:19:31.420 --> 00:19:36.550
If you simply create a bunch of commands
that they can run, then you constantly have

00:19:36.549 --> 00:19:39.240
to anticipate what their needs are going to be.

00:19:39.240 --> 00:19:41.549
You're constantly racing to stay out in front of them.

00:19:41.549 --> 00:19:46.250
If you give them an object oriented solution
instead, you've given them a set of tools

00:19:46.250 --> 00:19:49.349
that they can use to construct their own solutions.

00:19:49.349 --> 00:19:54.079
So, we really want to empower your users
rather than try to anticipate their needs.

00:19:54.079 --> 00:19:57.480
You'll never be able to stay out ahead of them if you do.

00:19:58.490 --> 00:20:00.920
You also achieve interoperability.

00:20:00.920 --> 00:20:07.920
If other applications have followed our recommendations,
and given their users object oriented solutions,

00:20:07.920 --> 00:20:11.980
and you do the same, then your application
will interact better with theirs.

00:20:11.980 --> 00:20:19.269
The scripters will be able to create these solutions more
seamlessly, and will be less apparent that you're using two,

00:20:19.269 --> 00:20:23.730
three, maybe even five different
programs to get the work done.

00:20:23.730 --> 00:20:30.180
The interoperability will flow more smoothly
because similar applications behave similarly.

00:20:30.180 --> 00:20:35.310
I draw your attention again to tech note
2106, the scripting interface guidelines.

00:20:35.309 --> 00:20:37.429
These are a lot like the human interface guidelines.

00:20:37.430 --> 00:20:42.230
The purpose of those was to make
applications look and feel the same.

00:20:42.230 --> 00:20:44.829
We want to achieve the same thing with scriptability,

00:20:44.829 --> 00:20:49.109
that the scriptability of one application
looks and feels the same as another.

00:20:49.109 --> 00:20:56.639
That allows your scripters to construct their solutions
more seamlessly, they flow, the applications work together

00:20:56.640 --> 00:21:03.370
as one, and whoever uses this solution begins
to think of it as just a single application.

00:21:05.279 --> 00:21:12.170
There's a lot of information in the scripting interface
guidelines, and we want you to read it all and take it

00:21:12.170 --> 00:21:16.170
to heart and do things the way that the guidelines say.

00:21:16.170 --> 00:21:20.730
There's a few red flags that'll come up right away
as soon as you start designing your dictionary,

00:21:20.730 --> 00:21:23.039
and I want to point some of them out to you.

00:21:23.039 --> 00:21:25.049
You want to favor objects over commands.

00:21:25.049 --> 00:21:28.529
Like I said, if you've just got a big
list of commands, you're constantly trying

00:21:28.529 --> 00:21:32.149
to anticipate what your scripters are going to want to do.

00:21:32.150 --> 00:21:36.450
If you favor objects over commands, then
they can recombine things in fashions

00:21:36.450 --> 00:21:40.480
that you may not have anticipated that solve their problems.

00:21:40.480 --> 00:21:46.589
One indication that you might be doing this wrong, is
if you've got class names that appear in your commands.

00:21:46.589 --> 00:21:52.659
This first one here, delete front window,
that's supposed to be close front window, sorry.

00:21:52.660 --> 00:21:56.370
That's a perfectly good line of AppleScript, that's
something that people are going to want to do,

00:21:56.369 --> 00:21:59.149
but you don't want that to be a command name.

00:21:59.150 --> 00:22:00.360
Delete is a verb.

00:22:00.359 --> 00:22:01.559
Windows an object.

00:22:01.559 --> 00:22:02.779
Front is an index.

00:22:02.779 --> 00:22:05.089
They should really be three different things.

00:22:05.089 --> 00:22:09.720
So, in your dictionary you're going to want
to define a window object and a delete command

00:22:09.720 --> 00:22:14.410
and allow your users, allow your
scripters to recombine those.

00:22:14.410 --> 00:22:19.710
Likewise, conversely, if you've got
verbs in your class or property names,

00:22:19.710 --> 00:22:24.120
that's an indication that your dictionary might
not be designed according to the guidelines.

00:22:24.119 --> 00:22:30.479
A very common occurrence is for the word is
to appear in the name of a Boolean property.

00:22:30.480 --> 00:22:32.970
This is great inside your code.

00:22:32.970 --> 00:22:38.960
This is very common inside Cocoa applications
to see method names that begin with the word is.

00:22:38.960 --> 00:22:43.809
You want to avoid having that in your scripting
dictionary, AppleScript is an English like language.

00:22:43.809 --> 00:22:46.750
It flows. It's been described as a read only language.

00:22:46.750 --> 00:22:51.549
Easy to read in AppleScript and see what
it does, not necessarily easy to write one.

00:22:51.549 --> 00:22:54.309
If this word is pops up in the middle of property names,

00:22:54.309 --> 00:22:56.869
it's going to make your AppleScript
read in a clunky fashion.

00:22:56.869 --> 00:23:00.279
It's going to make it hard for
people to understand what it's doing.

00:23:00.279 --> 00:23:02.180
So, these are things to avoid.

00:23:02.180 --> 00:23:06.740
Another thing that you want to do in your Apple
Script dictionary is hide some of the grittier details

00:23:06.740 --> 00:23:09.410
of what's going on inside your application.

00:23:09.410 --> 00:23:14.640
You don't necessarily want to turn
every scripter into a Cocoa programmer.

00:23:14.640 --> 00:23:21.900
You want to let them write something that flows naturally,
makes sense, is easy to read, and actually does the job.

00:23:21.900 --> 00:23:26.330
So, when you're hiding these gritty details, one of
the things that's going to happen is you're going

00:23:26.329 --> 00:23:30.339
to avoid intercaps, you don't want
intercaps in your dictionary anywhere,

00:23:30.339 --> 00:23:32.959
and likewise, you don't want any underbars in there.

00:23:32.960 --> 00:23:41.730
If you're doing these things, it's an indication that you're
objective C backed, you're objective C back end is leaking

00:23:41.730 --> 00:23:45.750
into your dictionary, and it's going to make
your dictionary harder for people to use.

00:23:45.750 --> 00:23:49.299
What are you going to design?

00:23:49.299 --> 00:23:50.919
It's hard to get started.

00:23:50.920 --> 00:23:59.100
You don't always know what to do first, and what we suggest
that people do is to design globally and implement locally.

00:23:59.099 --> 00:24:03.099
By that, we mean, think about the
entirety of your application.

00:24:03.099 --> 00:24:04.329
Everything it can do.

00:24:04.329 --> 00:24:06.839
Inventory all the objects that it has.

00:24:06.839 --> 00:24:12.839
Inventory all the various operations it can
perform on those objects, and do that up front.

00:24:12.839 --> 00:24:19.299
The reason being, you're going to want to support all
of this stuff at some point in time in the future,

00:24:19.299 --> 00:24:22.950
and it's better to have names for
everything before you get started.

00:24:22.950 --> 00:24:27.850
It's terrible to get halfway through your implementation
and realize you gave something the wrong name,

00:24:27.849 --> 00:24:34.289
and now it's going to be very difficult for you to add
the next feature, or extend what you've already got.

00:24:34.289 --> 00:24:38.869
Now, after you've done that, after you've created
this massive dictionary that does everything

00:24:38.869 --> 00:24:43.649
that exposes everything that you're application does,
you're going to look at that and you're going to gasp,

00:24:43.650 --> 00:24:48.509
and you're going to say I cannot possibly do
this in one release, what am I going to do?

00:24:48.509 --> 00:24:57.240
We want you to scale that back, and break it into
phases for each release, and the suggestion that I give

00:24:57.240 --> 00:25:03.849
to people is draw a little line around a few objects and
a few commands in your dictionary, and say can I solve one

00:25:03.849 --> 00:25:08.069
or two interesting problems with just these few objects.

00:25:08.069 --> 00:25:13.569
Am I getting feedback from the field that
people need solutions for certain things,

00:25:13.569 --> 00:25:18.899
and if I just give them maybe three objects
and two commands, they'll be able to do that.

00:25:18.900 --> 00:25:20.850
That's doable in a single release.

00:25:20.849 --> 00:25:27.730
Get that done, get that dictionary into the hands
of your users, and they'll, they won't be shy,

00:25:27.730 --> 00:25:33.680
they'll create solutions using that dictionary, and they'll
feed back to you what it is they think they need next.

00:25:33.680 --> 00:25:37.900
And then you'll be able to spend your
time on implementing those things

00:25:37.900 --> 00:25:41.040
that your scripters are going to be using right away.

00:25:41.039 --> 00:25:45.009
We said before, you spend your time
where it does you the most good.

00:25:45.009 --> 00:25:45.940
This is one of the ways.

00:25:45.940 --> 00:25:51.049
You start this two way communication with your scripters,
and then your scripting dictionary grows release

00:25:51.049 --> 00:25:55.960
over release, in the most important
and effective way that it can.

00:25:55.960 --> 00:26:01.960
It's also okay to have features that are in your
GUI that don't appear in your scripting dictionary.

00:26:01.960 --> 00:26:05.840
One example of this is finding things.

00:26:05.839 --> 00:26:10.139
Various applications have very
sophisticated ways of finding things.

00:26:10.140 --> 00:26:15.110
Smart folders, and smart collections
exist in a lot of applications today.

00:26:15.109 --> 00:26:21.689
They're usually defined using a big dialogue that allows
you to construct Boolean algebra to select things based

00:26:21.690 --> 00:26:25.289
on their properties, and create a collection that way.

00:26:25.289 --> 00:26:29.569
It isn't absolutely necessary that
you replicate that in your scripting.

00:26:29.569 --> 00:26:32.439
That's because AppleScript already has whose clauses.

00:26:32.440 --> 00:26:37.150
Who's clauses are a very powerful way of
selecting objects based on their properties.

00:26:37.150 --> 00:26:40.220
It isn't necessary that you reconstruct that.

00:26:40.220 --> 00:26:46.789
So, you're probably not going to even if you have
a very powerful find feature in your application.

00:26:46.789 --> 00:26:50.399
It's highly probable that you don't
have to reconstruct that in scripting,

00:26:50.400 --> 00:26:53.860
because whose clauses actually already do that for you.

00:26:53.859 --> 00:27:00.719
Likewise, it's okay to have scripting
only features in your application.

00:27:00.720 --> 00:27:06.259
One example of that is the address
book has a lot of additional fields

00:27:06.259 --> 00:27:10.819
like nickname, anniversaries, friends, spouses.

00:27:10.819 --> 00:27:16.619
These things all appeared in scripting first, and
didn't show up in the user interface until later.

00:27:16.619 --> 00:27:20.969
Once these properties were named, it was
pretty easy to put them in the dictionary.

00:27:20.970 --> 00:27:27.860
It took a little bit longer to design an effective user
interface, and effective graphical user interface for them.

00:27:27.859 --> 00:27:32.669
So, what the guys that take care of address
book did, they went ahead and put them

00:27:32.670 --> 00:27:38.140
in the scripting interface right away, and it wasn't until
the subsequent release that they showed up in the UI.

00:27:38.140 --> 00:27:39.470
That's okay.

00:27:39.470 --> 00:27:45.690
All you're looking for is down the line, when you
feel you're done, that you have parallel functionality

00:27:45.690 --> 00:27:54.710
between your graphical user interface and your scripting
interface, even if they don't look precisely the same

00:27:54.710 --> 00:27:57.130
Where do I get this design.

00:27:57.130 --> 00:27:59.510
Excuse me.

00:27:59.509 --> 00:28:03.230
( silence )

00:28:03.230 --> 00:28:08.789
The important thing is that you want to, you
want to design to an end user perception.

00:28:08.789 --> 00:28:12.730
It's going to be end users of your
application that write these scripts,

00:28:12.730 --> 00:28:20.230
and to the extent that you can satisfy their expectations,
to the extent that you can use the same terminology

00:28:20.230 --> 00:28:24.490
that they're going to use, they'll find
your scripting dictionary easier to use,

00:28:24.490 --> 00:28:28.299
and to do this I've used a technique
called a blind interview.

00:28:28.299 --> 00:28:30.819
What's that?

00:28:30.819 --> 00:28:33.480
It's not really like this.

00:28:33.480 --> 00:28:35.269
You don't need a blindfold.

00:28:35.269 --> 00:28:40.309
You don't need the bare bulb, but
the fedora, the fedora helps a lot.

00:28:40.309 --> 00:28:47.079
Your scripting dictionary's going to reflect the
internal structure of your program to a certain extent.

00:28:47.079 --> 00:28:51.599
Again, I said you don't want to turn
every scripter into a Cocoa programmer.

00:28:51.599 --> 00:28:58.109
You don't have to show them all the nasty internals of your
application, but if you use Cocoa Scripting and you will,

00:28:58.109 --> 00:29:01.289
because that's the way to go, your internal structure,

00:29:01.289 --> 00:29:05.329
and your scripting dictionary do
have to align to a certain extent.

00:29:05.329 --> 00:29:07.759
So, feel natural doing that.

00:29:07.759 --> 00:29:11.369
If your internal structure and your Apple
Script dictionary parallel each other

00:29:11.369 --> 00:29:13.889
to a certain extent, that's a good thing.

00:29:13.890 --> 00:29:16.009
But stay within reason.

00:29:16.009 --> 00:29:17.849
You're going to want to simplify that for people.

00:29:17.849 --> 00:29:21.829
If you've got little helper objects that the
scripter doesn't really need to know about.

00:29:21.829 --> 00:29:29.029
If you've got collections of things that end up acting
like a single thing, you can hide that from the user,

00:29:29.029 --> 00:29:34.779
and this is just the classic data hiding
capability of object oriented programming.

00:29:34.779 --> 00:29:37.539
An object behaves in a certain way.

00:29:37.539 --> 00:29:44.460
It's not necessary that the scripter know
exactly how all of those internals are done.

00:29:44.460 --> 00:29:52.240
As Chris mentioned, AppleScript is 14 years old
now, and 14 years ago, things were very different.

00:29:52.240 --> 00:29:56.099
Computers were smaller, networks were slower.

00:29:56.099 --> 00:29:58.019
This is a USB thumb drive.

00:29:58.019 --> 00:30:04.619
It's got as much memory on it as everybody had
in this room had on their Macintosh 14 years ago.

00:30:04.619 --> 00:30:08.389
So, 14 years ago, the correct solution was 4 byte codes.

00:30:08.390 --> 00:30:12.259
Every entry in your dictionary has a
human readable term associated with it.

00:30:12.259 --> 00:30:14.960
It's also got a 4 byte code associated with it.

00:30:14.960 --> 00:30:18.549
That's the information that travels
back and forth in the apple events,

00:30:18.549 --> 00:30:24.019
so when you're creating your dictionary you're going to
need to assign 4 byte codes to the human readable terms,

00:30:24.019 --> 00:30:27.609
and one of the biggest stumbling blocks is how do I do this?

00:30:27.609 --> 00:30:29.939
Where do I get this information.

00:30:29.940 --> 00:30:36.519
The important thing, the important message that we want to
get to you is consistency with other existing applications.

00:30:36.519 --> 00:30:41.990
If a human readable term is in use, in other
AppleScript dictionaries, you want to copy that,

00:30:41.990 --> 00:30:45.480
and you want to copy the 4 byte code that goes with it.

00:30:45.480 --> 00:30:49.650
This makes your application interact
better with other applications.

00:30:49.650 --> 00:30:54.460
It makes your application interact better with scripting
additions which behave as though they were part

00:30:54.460 --> 00:30:59.509
of the language, and they make your application
interact better with AppleScript itself

00:30:59.509 --> 00:31:03.180
which has a lot of predefined terminology.

00:31:03.180 --> 00:31:11.009
So, the bottom line is if you use the same human
readable term, use the same 4 byte code and vice versa.

00:31:11.009 --> 00:31:14.160
Where do I find them?

00:31:14.160 --> 00:31:20.040
If you go to the developer site and search for apple
event codes, the first hit you get will be a web page

00:31:20.039 --> 00:31:26.309
that we've constructed that's got 3000 pairs
of human readable terms and 4 byte codes.

00:31:26.309 --> 00:31:31.619
Start there, and if you can find the human
term that you're looking for on that list,

00:31:31.619 --> 00:31:34.419
go ahead and use the 4 byte code that's associated with it.

00:31:34.420 --> 00:31:39.830
If you don't fine your term and you have to
invent something new, then the converse is true.

00:31:39.829 --> 00:31:48.980
Make sure you pair that term up with a 4
byte code that is not in use by anyone else.

00:31:48.980 --> 00:31:53.160
And when you're done, all of this
goes into a scripting definition file.

00:31:53.160 --> 00:31:58.750
The scripting definition file is the newest format.

00:31:58.750 --> 00:32:04.519
We've gong through a series of iterations
on this, back in system 7, 8, and 9,

00:32:04.519 --> 00:32:10.180
we had AETE resources which were
difficult to construct and read.

00:32:10.180 --> 00:32:15.920
When system 10 came along, we had script suite, and
script terminology files, which were a little bit better,

00:32:15.920 --> 00:32:21.769
but sometimes difficult to work with, and
now we've gone to scripting definition files.

00:32:21.769 --> 00:32:23.400
All the old ones still work.

00:32:23.400 --> 00:32:29.210
If you've got an existing scriptable application that uses
an AETE or script suite or script terminology, don't worry,

00:32:29.210 --> 00:32:34.200
it's going to keep working, but the
scripting definition file is more expressive.

00:32:34.200 --> 00:32:39.250
You can include documentation, you can include
examples, you can include links to outside information

00:32:39.250 --> 00:32:43.289
that will help people interpret
your dictionary and use it better,

00:32:43.289 --> 00:32:47.210
and here in orange are the things
that you're going to have to invent.

00:32:47.210 --> 00:32:52.360
There's the term, this is a chunk
from the sketch scripting definition.

00:32:52.359 --> 00:33:01.109
Sketch is the canonical sample code that we
make available to you for Cocoa and AppKit,

00:33:01.109 --> 00:33:08.859
and since Cocoa Scripting is part of AppKit, sketch is
a Cocoa scriptable application, and in its dictionary,

00:33:08.859 --> 00:33:13.469
it defines something called a graphic, and a
graphic is just anything you can draw in sketch.

00:33:13.470 --> 00:33:22.180
A rectangle, a circle, a straight line, a chunk of
text, and it's associated with the 4byte code GRPH,

00:33:22.180 --> 00:33:28.360
and it's implemented by a Cocoa class SKT
graphic, and it's in the scripting definition file

00:33:28.359 --> 00:33:34.679
that you associate these three things together,
so when your scripter types the word graphic,

00:33:34.680 --> 00:33:39.470
when your script editor translates that into
a 4 byte code in order to send an apple event

00:33:39.470 --> 00:33:47.900
and when that apple event arrives in the sketch
application, these three terms are tied together.

00:33:47.900 --> 00:33:54.500
Once you're done designing your dictionary, you're going to
need to write some code to back it up, and as Chris said,

00:33:54.500 --> 00:34:02.230
if you're following existing conventions, a
lot of this code is going to already be there.

00:34:02.230 --> 00:34:04.750
And there's several different things
that you're going to have to create.

00:34:04.750 --> 00:34:10.900
You're going to have to create element accessors that allow
you to get at the objects that your application knows about,

00:34:10.900 --> 00:34:18.690
you're going to have to do some element management so that
you can grow and shrink those collections as appropriate.

00:34:18.690 --> 00:34:22.360
You're going to want to have property accessors
that allow you to get at the information

00:34:22.360 --> 00:34:31.559
that makes one object different form another, and
you're going to have to implement some commands.

00:34:31.559 --> 00:34:37.639
Element accessors come in several different types, but
you're going to have to do at least one of these two.

00:34:37.639 --> 00:34:40.769
The first one here is also from the sketch application.

00:34:40.769 --> 00:34:46.289
It's the accessor that allows you to get at
the graphics that are inside a given document.

00:34:46.289 --> 00:34:50.980
Since the number of graphics inside a given
document is likely to be relatively small,

00:34:50.980 --> 00:34:57.070
and that collection of graphics is going to be
around all the time because it needs to be redrawn,

00:34:57.070 --> 00:35:01.240
it's really going to be pretty easy to
just return an array of graphics objects.

00:35:01.239 --> 00:35:06.179
It already exists inside your application, you
don't have to write any new code to do this.

00:35:06.179 --> 00:35:10.259
So, the first accessor here just
provides the entire collection at once.

00:35:10.260 --> 00:35:13.950
Cocoa Scripting will grab the entire
collection and do whatever is necessary

00:35:13.949 --> 00:35:18.089
to select the object the scripter is looking for.

00:35:18.090 --> 00:35:24.320
If your collections are bigger, or
perhaps don't exist at all times,

00:35:24.320 --> 00:35:27.180
you're going to want to be able to
do this in a more efficient way.

00:35:27.179 --> 00:35:30.399
The example here still uses graphics.

00:35:30.400 --> 00:35:33.320
You notice that we're establishing a naming convention here.

00:35:33.320 --> 00:35:39.880
The term graphics is repeated over and over again in
these accessors and that relates them all together,

00:35:39.880 --> 00:35:44.800
and relates them back to the scripting
definition so that Cocoa Scripting can find them.

00:35:44.800 --> 00:35:51.880
Cocoa Scripting uses your scripting definition file at
runtime to dispatch the events to the proper accessors.

00:35:51.880 --> 00:35:58.400
If you collection is large, or does not always exist, a good
example here would be all of the characters in document.

00:35:58.400 --> 00:36:04.869
You don't necessarily want a Cocoa object representing
every character in a document hanging around all the time.

00:36:04.869 --> 00:36:09.670
That's a lot of overhead for something
that might never get used.

00:36:09.670 --> 00:36:16.760
You can implement access to those characters, or in this
case still graphics, by providing a pair of accessors,

00:36:16.760 --> 00:36:20.700
one which will give the count of
how many of these things there are,

00:36:20.699 --> 00:36:26.269
and one that will give you back exactly one object at a time
based on the index, and again, Cocoa Scripting knows how

00:36:26.269 --> 00:36:32.900
to use this, and will use it to construct an
answer to whatever it is the scripters looking for.

00:36:32.900 --> 00:36:50.240
You can implement one or the other of these or both,
but you're going to have to have one or the other.

00:36:50.239 --> 00:36:50.729
>> ( Pause )
>> Probably.

00:36:50.730 --> 00:36:51.110
>> ( Pause )

00:36:51.110 --> 00:37:01.680
>> Yeah. There's other ways of getting at your elements
as well that if your backend supports an efficient way

00:37:01.679 --> 00:37:06.960
of getting at things by name, perhaps you've got
some hashing algorithm that can take the name,

00:37:06.960 --> 00:37:14.349
munch on it somehow, and then grab the object directly,
you can do that, and Cocoa Scripting will help you.

00:37:14.349 --> 00:37:21.219
You provide another accessor called valuing graphics with
name, and then instead of asking for the entire collection,

00:37:21.219 --> 00:37:26.099
or asking for something by index or going through
the entire collection looking for one that happens

00:37:26.099 --> 00:37:34.509
to match a certain name, Cocoa Scripting will ask for you
to hunt through the collection and get something by name.

00:37:34.510 --> 00:37:38.220
If you believe that you can do a
better job than a simple linear search,

00:37:38.219 --> 00:37:40.539
then you'll want to implement something like this.

00:37:40.539 --> 00:37:44.650
Likewise you can access objects by a unique ID.

00:37:44.650 --> 00:37:50.130
If the back end of your application is a real
live database and it can get at things using a key

00:37:50.130 --> 00:37:57.130
and it can do it really fast, then you're probably going
to want to implement valuing graphics with unique ID

00:37:57.130 --> 00:38:06.420
or valuing object name with unique ID, and that'll
pass back one object that matches that unique ID,

00:38:06.420 --> 00:38:14.710
giving you access to the power of your
backend which happens to be a database.

00:38:14.710 --> 00:38:21.780
Some collections are static, for example the disc drives
on the, oh no, that's not exactly, that's not a good one.

00:38:21.780 --> 00:38:26.010
The monitors, the monitors available
on your machine is relatively static.

00:38:26.010 --> 00:38:29.850
You can't connect a new monitor without
turning your machine off and back on again,

00:38:29.849 --> 00:38:34.539
so what you want to, but not all collections are like that.

00:38:34.539 --> 00:38:39.789
Most collections vary in size over time, and you're
going to want to be able to create new things and get rid

00:38:39.789 --> 00:38:46.480
of old things, and again, Cocoa script is going to
help you do that, and extending this naming pattern,

00:38:46.480 --> 00:38:50.769
you can insert a graphic into the collection of graphics.

00:38:50.769 --> 00:38:53.150
I've got two different accessors here.

00:38:53.150 --> 00:38:55.920
That's because you've got two different
options of how to do this.

00:38:55.920 --> 00:39:01.619
If order is important you might want to be able
to, and your scripter might want to be able

00:39:01.619 --> 00:39:06.029
to insert an object at a particular point in the collection.

00:39:06.030 --> 00:39:12.990
If order isn't important, or order has some kind
of natural definition, then you can insert objects

00:39:12.989 --> 00:39:16.259
into the collection without specifying an index.

00:39:16.260 --> 00:39:18.960
A good example of both, actually, is a window.

00:39:18.960 --> 00:39:23.820
Normally, if you create a new window, you simply want it
to show up in front of all the other the other windows.

00:39:23.820 --> 00:39:26.870
You're creating it because you're going
to do something with it right now.

00:39:26.869 --> 00:39:32.589
And in that case, the first accessor here would be
sufficient, but it's also true if you're doing something

00:39:32.590 --> 00:39:36.519
in an automated fashion, that you might want to
create a window, and you don't want it in front.

00:39:36.519 --> 00:39:41.639
You want it behind all the other windows, so in
that case you'd want to use the second accessor,

00:39:41.639 --> 00:39:44.579
so again you can do one of these or both.

00:39:44.579 --> 00:39:47.949
There's a good chance that you're
going to end up doing both.

00:39:47.949 --> 00:39:50.000
When you're done with a window,
you're going to want to get rid of it.

00:39:50.000 --> 00:39:59.150
You're going to want to remove it from the collection, and
you do that with the remove from collection name and index,

00:39:59.150 --> 00:40:07.059
and this is going to find the object using the index,
and tell the owner of that collection to get rid of it.

00:40:07.059 --> 00:40:15.519
So, you can manage the size and contents of your collections
this way, and the last one here is object specifier.

00:40:15.519 --> 00:40:19.110
Element identification via an object specifier.

00:40:19.110 --> 00:40:24.730
Every good scriptable object is capable of
providing an object specifier for itself,

00:40:24.730 --> 00:40:29.300
and you can think of an object
specifier as like a return address.

00:40:29.300 --> 00:40:33.220
If I wanted to get back to this
object later, how would I do that?

00:40:33.219 --> 00:40:39.379
A command that creates an object should
return as its result an object specifier.

00:40:39.380 --> 00:40:44.000
The scripter can then take that object
specifier, stick it in a variable, hang onto it,

00:40:44.000 --> 00:40:46.960
and get back to that same object later on.

00:40:46.960 --> 00:40:49.210
Some object specifiers are better than others.

00:40:49.210 --> 00:40:53.760
Index object specifiers are somewhat weak.

00:40:53.760 --> 00:41:00.820
If the contents of the collection changes, then the
meaning of an index object specifier may also change.

00:41:00.820 --> 00:41:08.350
Object specifiers by name are better, but because Apple
Script allows non-unique names, they can be ambiguous.

00:41:08.349 --> 00:41:15.319
The most specific and exacting kind of object
specifier is an object specifier by unique ID.

00:41:15.320 --> 00:41:20.320
It's up to you when you write this object
specifier routine what kind you're going to return.

00:41:20.320 --> 00:41:26.880
You're going to want to have your scripter's
end use perception in mind when you do this.

00:41:26.880 --> 00:41:32.320
If people normally call things by name, you're probably
going to want to use by name object specifiers.

00:41:32.320 --> 00:41:37.970
Again if your backend is a database, and your
scriptors know,hey, I'm manipulating a database,

00:41:37.969 --> 00:41:44.809
then unique ID objects specifiers are the right thing, and
if you don't have that kind of information available to you,

00:41:44.809 --> 00:41:49.150
index object specifiers will work, but
like I said, they have their limitations.

00:41:49.150 --> 00:41:57.200
The thing that makes one object different
than another is the value of its properties.

00:41:57.199 --> 00:41:59.869
If you want to do interesting things
with your objects, search through them,

00:41:59.869 --> 00:42:05.909
find objects that have certain properties,
you're going to want to have property accessors.

00:42:05.909 --> 00:42:11.559
You're going to want to be able to
get and set the values of properties,

00:42:11.559 --> 00:42:18.829
and here's a pair of property accessors
for the name of an object.

00:42:18.829 --> 00:42:23.730
These fit a pattern called KVC, Key Value Coding.

00:42:23.730 --> 00:42:30.269
Key Value Coding is a technology
that allows cocoa applications

00:42:30.269 --> 00:42:34.329
to introspect their object and
find out what properties they have.

00:42:34.329 --> 00:42:36.090
It's used in lots of different places.

00:42:36.090 --> 00:42:40.200
It's used in bindings, it's used in
core image, it's used in core data.

00:42:40.199 --> 00:42:45.659
If you're using any of these technologies,
you probably already have a lot

00:42:45.659 --> 00:42:50.730
of Key Value Coding compliant code
in your application already.

00:42:50.730 --> 00:42:51.949
And that's great.

00:42:51.949 --> 00:42:56.239
Because when you go to do scripting, that
means you don't need to write anything new.

00:42:56.239 --> 00:42:59.629
But Key Value Coding is actually more powerful than that.

00:42:59.630 --> 00:43:06.610
It can actually get right at the instance variables of your
objects directly without you creating an accessors at all,

00:43:06.610 --> 00:43:09.500
as long as you stick to this naming convention.

00:43:09.500 --> 00:43:16.659
That instance variable there underscore
name will be treated exactly the same way

00:43:16.659 --> 00:43:21.089
as that pair of accessors get name and set name.

00:43:21.090 --> 00:43:27.150
So, in this instance you don't have to write any kind
of code at all, and if you're objective c two point oh,

00:43:27.150 --> 00:43:33.130
and you use objective c two point oh property
definitions, they're automatically KVC compliant.

00:43:33.130 --> 00:43:38.230
You're going to get that functionality
for free just because you're using the

00:43:38.230 --> 00:43:42.090
at property definition for your instance variables.

00:43:42.090 --> 00:43:48.769
So, like we said, you probably already have a lot of
this code already and don't need to write anything knew.

00:43:48.769 --> 00:43:53.079
The last thing you're going to want to do
is commands, and I do mean the last thing.

00:43:53.079 --> 00:43:56.849
There's 13 built in commands in the AppleScript language.

00:43:56.849 --> 00:44:02.929
We believe that those 13 commands will cover
about 80 percent of what you need to do.

00:44:02.929 --> 00:44:07.389
You don't want to add new commands
if an existing command will do.

00:44:07.389 --> 00:44:09.569
Particularly get and set.

00:44:09.570 --> 00:44:19.019
Getting and setting properties can often do what you
want done rather than creating a complex custom command.

00:44:19.019 --> 00:44:20.969
But it is going to happen.

00:44:20.969 --> 00:44:23.149
Your application does something unique.

00:44:23.150 --> 00:44:28.110
Your application has some value added
functionality that no one else has

00:44:28.110 --> 00:44:31.260
so there is no command to do what your application does.

00:44:31.260 --> 00:44:36.250
In that case, you're going to want
to go ahead and create commands.

00:44:36.250 --> 00:44:44.230
The examples that we gave last year, we used the sketch
sample code again, was to take a couple of features

00:44:44.230 --> 00:44:50.320
that were present in the graphical user interface, but not
in the scriptability, and to go ahead and implement them,

00:44:50.320 --> 00:44:55.480
and we chose two different ones to give an
example of the two different kinds of commands.

00:44:55.480 --> 00:44:59.429
The first kind of command is object first dispatching.

00:44:59.429 --> 00:45:07.460
A lot of objects act independently and can implement
their responses to certain commands independently.

00:45:07.460 --> 00:45:09.300
Good example of this is rotate.

00:45:09.300 --> 00:45:15.430
If you tell something to rotate in sketch, you can tell
one object to rotate, you can tell a collection of objects

00:45:15.429 --> 00:45:19.409
to rotate, but in the end, each
object functions independently.

00:45:19.409 --> 00:45:23.769
It rotates through 90 degrees all by
itself, and it doesn't need to know anything

00:45:23.769 --> 00:45:27.150
about anything that's going on
with any of the other objects.

00:45:27.150 --> 00:45:32.160
In that case, you're going to want to use object
first dispatching, and the way that you do that is

00:45:32.159 --> 00:45:39.509
that you simply add a method to the graphics object itself
called rotate, reference it in your scripting definition,

00:45:39.510 --> 00:45:44.510
and then Cocoa Scripting will route any
rotate commands directly to that object,

00:45:44.510 --> 00:45:49.340
and if the scripter actually tells a collection of
objects to rotate, Cocoa Scripting will call each

00:45:49.340 --> 00:45:52.970
of those objects one at a time, and tell them to rotate.

00:45:52.969 --> 00:45:55.000
There's other kinds of commands that aren't like that.

00:45:55.000 --> 00:45:59.840
There's other kinds of commands that act
in aggregate on an entire collection.

00:45:59.840 --> 00:46:02.590
And example from sketch is align.

00:46:02.590 --> 00:46:05.360
You can't tell one object to align.

00:46:05.360 --> 00:46:08.460
An object has to align to something else.

00:46:08.460 --> 00:46:14.360
Typically what you do is you tell a collection
of objects to align their vertical centers.

00:46:14.360 --> 00:46:19.579
Well, you can't do that by sending a
message to each object individually.

00:46:19.579 --> 00:46:22.730
The objects are going to have to
know about each other somehow,

00:46:22.730 --> 00:46:25.730
so that they can find their vertical centers and align them.

00:46:25.730 --> 00:46:29.250
In that case, you're going to want
to do command first dispatching.

00:46:29.250 --> 00:46:34.920
The way you do that is you create a sub
class of the NS script command class,

00:46:34.920 --> 00:46:39.050
and you implement a perform default implementation method,

00:46:39.050 --> 00:46:43.380
and the perform default implementation
method doesn't have any inputs at all,

00:46:43.380 --> 00:46:46.519
reason being it's a method on the command itself.

00:46:46.519 --> 00:46:52.920
If you need to know anything about the command, whether it's
align to the vertical centers, or the horizontal centers,

00:46:52.920 --> 00:46:56.720
or the left edges, that's present in the command itself,

00:46:56.719 --> 00:47:01.289
and the command can just introspect
itself to find that information.

00:47:01.289 --> 00:47:06.989
And the difference between a command first
dispatched command, and an object first dispatch,

00:47:06.989 --> 00:47:13.269
is that the command first dispatch can act on
the entire collection of objects all at once.

00:47:13.269 --> 00:47:22.420
So, you can see, depending upon the functionality it
will be appropriate to do one of these or the other.

00:47:22.420 --> 00:47:29.250
Cocoa Scripting uses your application as a set of
call backs, and it will call your element accessors,

00:47:29.250 --> 00:47:34.050
and your property accessors in order to answer
the questions that the scripter has asked.

00:47:34.050 --> 00:47:40.420
And it does this in a very predictable and logical fashion,
but when you first get started, there's going to be a lot

00:47:40.420 --> 00:47:45.639
that you don't know, and typically the way
that you figure out how your programs working

00:47:45.639 --> 00:47:48.279
or not working is by setting break points.

00:47:48.280 --> 00:47:54.740
It can be very frustrating setting break points when Cocoa
Scriptings using your application as a set of callbacks.

00:47:54.739 --> 00:47:56.279
You don't know what's going to happen next.

00:47:56.280 --> 00:48:01.610
You can set a break point, and it'll never get hit,
and then you're left wondering what's going on?

00:48:01.610 --> 00:48:04.420
Why am I not coming through this part of my code?

00:48:04.420 --> 00:48:06.170
What did I do wrong in my code?

00:48:06.170 --> 00:48:08.670
What did I do wrong in my dictionary?

00:48:08.670 --> 00:48:14.510
One way to learn how Cocoa Scripting uses
your application, what it calls and when,

00:48:14.510 --> 00:48:18.190
is to put in some kind of logging mechanism,
and when I first started doing this,

00:48:18.190 --> 00:48:23.619
I used a very simple logging mechanism, just a
couple of macros that allowed me to call NS log,

00:48:23.619 --> 00:48:29.839
and allowed me to turn this off
when I built my deployment version.

00:48:29.840 --> 00:48:35.039
And from this I learned a lot about how Cocoa
Scripting worked, what it called me for, when,

00:48:35.039 --> 00:48:37.969
and what it expected back as its answers.

00:48:37.969 --> 00:48:40.009
And I strongly encourage that you do this.

00:48:40.010 --> 00:48:46.310
That you log every accessor call, every event
handler, and any significant processing that you do.

00:48:46.309 --> 00:48:52.539
If you take a branch inside your code that's going
to cause you to do something significantly different,

00:48:52.539 --> 00:48:56.900
log that as well, so that you can follow what's going on.

00:48:56.900 --> 00:49:01.180
After awhile, with the help of Brooke
Callahan, one of the members of our group,

00:49:01.179 --> 00:49:05.639
I made this considerably fancier,
and added a lot of automated stuff.

00:49:05.639 --> 00:49:11.929
I found myself typing over and over again the name of the
method that I was in, the name of the file that I was in.

00:49:11.929 --> 00:49:14.829
I've added this all to my logging macro automatically.

00:49:14.829 --> 00:49:21.840
Now, simply by changing the value on that if
statement, I can turn this logging mechanism on and off,

00:49:21.840 --> 00:49:28.860
and use it to find out what Cocoa Scripting is
doing, and again, I put these things everywhere.

00:49:28.860 --> 00:49:33.930
Every single routine and every single object I've put one
of these logging macros in there, and now since I don't have

00:49:33.929 --> 00:49:39.690
to type in a lot of additional information, it's
really very easy, just a lot of copy and paste.

00:49:39.690 --> 00:49:45.070
So, when you turn this on, well, you can't turn this
on because you don't have the source to system advance,

00:49:45.070 --> 00:49:48.860
but I can turn it on, these are the messages that I get.

00:49:48.860 --> 00:49:55.809
If I tell system events to get script menu enabled, script
menu enabled means that up in the upper right hand corner

00:49:55.809 --> 00:50:03.549
of my menu bar, there's a little script icon that I
can pull down and select scripts that I use commonly

00:50:03.550 --> 00:50:06.940
and frequently to control my scriptable applications.

00:50:06.940 --> 00:50:09.050
Again, this is part of that lock in.

00:50:09.050 --> 00:50:14.210
If you put scripts in this, if you make your application
scriptable, and you put scripts in the script menu,

00:50:14.210 --> 00:50:20.090
people will get used to using them, and they will use
your program over and over again because it's easy.

00:50:20.090 --> 00:50:25.450
When you run this, these are some examples
of the logging that you'll get back.

00:50:25.449 --> 00:50:27.579
First thing in there is my initials.

00:50:27.579 --> 00:50:31.980
I put my initials in there because there maybe
more than one engineer working on this project,

00:50:31.980 --> 00:50:36.440
and I want to be able to tell what
in the console log came from me.

00:50:36.440 --> 00:50:39.400
Mark Pitcherelli will be speaking this afternoon,

00:50:39.400 --> 00:50:42.599
and he'll tell you that when you're
debugging your scriptable application,

00:50:42.599 --> 00:50:48.119
you should leave the console window open all the time
because there's a wealth of information in there.

00:50:48.119 --> 00:50:54.589
To filter out my logging from that wealth of
information, I put my initials in every logging message.

00:50:55.710 --> 00:51:01.470
I also have the name of the file,
and the line number that I'm on.

00:51:01.469 --> 00:51:03.719
This gives me pretty specific information.

00:51:03.719 --> 00:51:11.369
If something goes wrong, if some part of the foundation
throws an exception because I've sent it some bad data,

00:51:11.369 --> 00:51:18.739
right before that, there's a line of code, if I go look
at that line of code, I almost always find my problem.

00:51:18.739 --> 00:51:25.159
Again, I put in the name of the method that I'm
executing at the time, which can be helpful as well,

00:51:25.159 --> 00:51:32.149
and it's also possible for me to put in specific
information about the input to that particular method.

00:51:32.150 --> 00:51:37.150
If I'm in the delicate handles key method,
it's interesting to know what the key is,

00:51:37.150 --> 00:51:39.700
because that will tell me what I expect the answer to be.

00:51:39.699 --> 00:51:41.730
And again, I've put these things everywhere.

00:51:41.730 --> 00:51:48.240
Put them in your application, turn them on, run a couple
of sample scripts, see what Cocoa Scripting is doing.

00:51:48.239 --> 00:51:51.239
That makes it a lot easier for you
to go back later and set break points

00:51:51.239 --> 00:51:54.569
and see what is going right and what's going wrong.

00:51:54.570 --> 00:52:05.269
When you're done, you're going to want to test this all.

00:52:05.269 --> 00:52:11.610
You're going to want to make sure it works right,
and probably the most important reason why you want

00:52:11.610 --> 00:52:20.700
to do this is you've given your end users automated
regression testing tool, it's called scriptability.

00:52:20.699 --> 00:52:25.609
They will run their scripts that they've been
running on previous versions of your application.

00:52:25.610 --> 00:52:27.210
They'll write new scripts.

00:52:27.210 --> 00:52:28.679
They'll find your bugs.

00:52:28.679 --> 00:52:30.279
They'll find your mistakes.

00:52:30.280 --> 00:52:34.980
If you create an embarrassing regression,
and let it slip through, they'll find it.

00:52:34.980 --> 00:52:39.070
So, what you want to do is make sure that you do that first.

00:52:39.070 --> 00:52:44.110
Your testing is going to parallel your code development.

00:52:44.110 --> 00:52:50.090
You're going to test your element accessors, your element
management, your property access, and your commands.

00:52:50.090 --> 00:52:54.700
All that code that you wrote, you're going to want
to have test cases for each and every one of them.

00:52:54.699 --> 00:52:59.460
When you're accessing your elements, there's lots
of different ways you can do that in AppleScript

00:52:59.460 --> 00:53:01.630
and you want to make sure you test them all.

00:53:01.630 --> 00:53:03.019
You can get the entire collection.

00:53:03.019 --> 00:53:08.170
You can get all the graphics that sketch has
in a particular document at a particular time.

00:53:08.170 --> 00:53:12.570
Regardless of how that's implemented, whether
it's done through the entire collection accessor,

00:53:12.570 --> 00:53:17.480
or if it's done through the count and index
accessor, you want to make sure that it works.

00:53:17.480 --> 00:53:21.119
You're also going to want to get things by name and by ID.

00:53:21.119 --> 00:53:25.429
Whether you've implemented those special
accessors or not, somebody has to match that name.

00:53:25.429 --> 00:53:27.409
Somebody has to match that ID.

00:53:27.409 --> 00:53:29.609
It's either your code, or Cocoa Scripting.

00:53:29.610 --> 00:53:36.620
You want to make sure that that works Accessing by index
is relatively simple, but again, you want to test it,

00:53:36.619 --> 00:53:41.159
because if there's anything wrong your
users, your scripters, will catch it.

00:53:42.800 --> 00:53:44.490
There's some other ways to access things.

00:53:44.489 --> 00:53:46.269
There's some indexes that have names.

00:53:46.269 --> 00:53:52.159
You can grab the middle object out of a collection, or you
can grab some randomly chosen object out of a collection.

00:53:52.159 --> 00:53:55.519
You want to test those and make sure that they work.

00:53:55.519 --> 00:54:00.099
AppleScript supports negative indexes, which
count backwards from the end of a collection.

00:54:00.099 --> 00:54:05.119
You're going to want to test that and make sure
that works, and the last and most importantly,

00:54:05.119 --> 00:54:07.210
you're going to want to test whose clauses.

00:54:07.210 --> 00:54:09.860
The power of the AppleScript language
is in the whose clause.

00:54:09.860 --> 00:54:18.740
It allows the scripter to describe what it is he
wants rather than just say this one here, number five.

00:54:18.739 --> 00:54:25.179
If he wants to describe an object that he's seeking or a
collection of objects that he's seeking based on the values

00:54:25.179 --> 00:54:32.879
of their properties, say all of the customers in the local
zip code, he's going to use a whose clause to do that.

00:54:32.880 --> 00:54:37.019
Cocoa Scripting is going to help you out
a lot in implementing these whose clauses.

00:54:37.019 --> 00:54:42.230
You don't have to write much code, if any, to get
these things to work, but you want to test them.

00:54:42.230 --> 00:54:43.789
You want to make sure that they work.

00:54:43.789 --> 00:54:48.659
You want to make sure that your scripters get
sensible answers, and that they get the same answers

00:54:48.659 --> 00:54:50.980
over and over again from release to release.

00:54:50.980 --> 00:54:57.730
So, make sure that you've got some interesting
and powerful whose clauses as part of testing.

00:54:57.730 --> 00:55:01.000
Element management, you're going to
want to create and delete things.

00:55:01.000 --> 00:55:07.639
Again, here's a sketch example of making a
new circle with certain properties, and again,

00:55:07.639 --> 00:55:10.359
you're going to want to delete things from your collection.

00:55:10.360 --> 00:55:16.309
Very often, everything works until you try to delete
the last object, and then something goes horribly wrong.

00:55:16.309 --> 00:55:22.940
You want to make sure that you test that situation
before your code gets out to your scripters.

00:55:22.940 --> 00:55:26.099
You're going to want to get out
all the properties of an object.

00:55:26.099 --> 00:55:32.059
Cocoa Scripting supports for you getting all the properties
at once, but again you want to make sure that it works.

00:55:32.059 --> 00:55:36.170
It uses your application as a set of callbacks.

00:55:36.170 --> 00:55:42.950
When the scripter says get properties of rectangle one,
the first rectangle object is going to be called over

00:55:42.949 --> 00:55:47.359
and over again to query each of its properties,
and Cocoa Scriptings going to do that for you,

00:55:47.360 --> 00:55:50.099
but you want to make sure that that kind of access works.

00:55:50.099 --> 00:55:53.670
And you want to be able to get at
each of the properties by its name,

00:55:53.670 --> 00:55:57.119
so you want to include all of that in your testing as well.

00:55:57.119 --> 00:56:02.710
Some properties are read only,
some properties are read write.

00:56:02.710 --> 00:56:05.650
For the read write properties in your
application, you're going to want to test

00:56:05.650 --> 00:56:09.980
that that works, and we want you to do repeatable tests.

00:56:09.980 --> 00:56:16.139
We want you to put things back they way they were when
you started, so we suggest a get set rest pattern.

00:56:16.139 --> 00:56:23.739
So, get the width of an object of one of the
graphics in sketch, and save a new variable.

00:56:23.739 --> 00:56:30.689
Then change the width of that object, then change it back
to what it was before, and make sure that that all works.

00:56:30.690 --> 00:56:33.019
There are edge cases.

00:56:33.019 --> 00:56:38.389
The width of something probably shouldn't be
any less than 0, but it could conceivably be 0.

00:56:38.389 --> 00:56:40.710
You want to make sure that that works correctly.

00:56:40.710 --> 00:56:42.500
And then there's error cases.

00:56:42.500 --> 00:56:49.239
You want to force your application right up to the limits
of what it can do, and then push it over the edge case

00:56:49.239 --> 00:56:53.949
into the error case, and make sure
that the scripter gets back some kind

00:56:53.949 --> 00:56:57.839
of descriptive error message that
they can use to solve the problem.

00:56:57.840 --> 00:57:04.280
Again Mark Pitcherelli will be talking this afternoon about
the greatly improved error reporting in Cocoa Scripting.

00:57:04.280 --> 00:57:08.580
You want to make sure that you get those errors, and
that your scripters will be able to interpret them

00:57:08.579 --> 00:57:11.849
and fix their scripts, so you want
to make that part of your testing.

00:57:11.849 --> 00:57:18.089
With the commands, if you create any new commands of
your own, you're certainly going to want to make sure

00:57:18.090 --> 00:57:23.019
that they work, and you're also going to want
to test the built in commands that are part

00:57:23.019 --> 00:57:26.780
of the AppleScript language, and you're going
to want to do this in several different ways.

00:57:26.780 --> 00:57:32.300
You're going to want to make sure that if you don't
provide any parameters at all, you just simply tell sketch

00:57:32.300 --> 00:57:37.800
to make a new circle, that it does something
predictable and perhaps even useful.

00:57:37.800 --> 00:57:42.200
If you make a new circle in sketch, it's going to
put it at some default location in the document.

00:57:42.199 --> 00:57:44.480
It's going to give it some default size.

00:57:44.480 --> 00:57:47.619
You want to make sure that's what
the scripters going to expect.

00:57:47.619 --> 00:57:51.409
You also want to make sure that
when you specify all the properties

00:57:51.409 --> 00:57:55.319
of a newly created object, that that works as well.

00:57:55.320 --> 00:58:01.430
And again, you want to take edge cases and
error cases and make sure that they work,

00:58:01.429 --> 00:58:06.239
and give the scripter feedback that's going to be
meaningful to them, so that they aren't surprised

00:58:06.239 --> 00:58:10.509
when they write their script and it doesn't
do exactly what they wanted it to do.

00:58:10.510 --> 00:58:14.510
And here is a good place to mention stress testing.

00:58:14.510 --> 00:58:20.410
Chris said earlier what happens to Address
Book when you throw 10,000 cards at it.

00:58:20.409 --> 00:58:23.319
You're going to want to test your
application that way as well.

00:58:23.320 --> 00:58:27.000
What happens to sketch when you make 10,000 circles.

00:58:27.000 --> 00:58:32.519
It's slow, that's what happens to sketch when you make
10,000 circles, but it's sample code, and it's instructive.

00:58:32.519 --> 00:58:38.730
You want to make sure that your application responds
in a way that's going to make the scripters happy.

00:58:38.730 --> 00:58:43.980
And this is a really important part.

00:58:43.980 --> 00:58:49.039
We told you earlier that scriptability
will build loyalty with your customers.

00:58:49.039 --> 00:58:53.840
Once they've made your application part of an automated
workflow, they're not going to get rid of you.

00:58:53.840 --> 00:58:59.400
They're going to keep you around forever,
but only if you don't break their scripts.

00:58:59.400 --> 00:59:02.930
One of the best ways to make sure that you
don't break their scripts is to get a hold

00:59:02.929 --> 00:59:08.259
of their scripts and make them part of your testing.

00:59:08.260 --> 00:59:09.550
Chris mentioned Kinkless GTD.

00:59:09.550 --> 00:59:18.940
We use that as a test ourselves to make sure that we haven't
done anything that breaks the scripting of Omni Outliner

00:59:18.940 --> 00:59:21.980
to the extent that Kinkless GTD doesn't work anymore.

00:59:21.980 --> 00:59:23.460
If that happened, that would be bad.

00:59:23.460 --> 00:59:25.800
There's lots and lots of people
out there that use Kinkless GTD.

00:59:25.800 --> 00:59:31.620
They have a tendency to be CEOs and CFOs
and we don't want to disappoint them.

00:59:31.619 --> 00:59:35.889
We want to make sure that they keep signing
those checks and keep buying our products.

00:59:35.889 --> 00:59:42.159
So, if you get your real world scripters, real
world scripts, and make them part of your testing,

00:59:42.159 --> 00:59:45.119
then you know that you're not going
to break their automated workflow,

00:59:45.119 --> 00:59:47.449
and you do this by monitoring your feedback sources.

00:59:47.449 --> 00:59:52.929
If you've got a mailing list, if you've got a blog,
if you've got a user community out there that's active

00:59:52.929 --> 00:59:58.079
and interchanges this information, you're going to want to
tap into that, and if you see a really interesting script,

00:59:58.079 --> 01:00:04.130
you're going to want to grab it, and you're going to
add appropriate to your testing methodology to make sure

01:00:04.130 --> 01:00:08.450
that you don't break any of these things, and again,
you're going to want this all to be repeatable.

01:00:08.449 --> 01:00:13.769
You want to retain your prior results, and you want to
do some kind comparison between what's happening now,

01:00:13.769 --> 01:00:18.019
and what was happening in the prior
release, and you want to detect regressions.

01:00:18.019 --> 01:00:20.460
Some of the changes are going to be
there because you want them there.

01:00:20.460 --> 01:00:23.480
Some of the changes are going to
be there because you fixed the bug.

01:00:23.480 --> 01:00:27.079
But there's going to be other changes that
crop up that you don't want to have there.

01:00:27.079 --> 01:00:30.549
You want to catch those at the
earliest possible moment and fix them.

01:00:30.550 --> 01:00:35.450
Like I said, you're giving your scripters
an automated regression testing tool.

01:00:35.449 --> 01:00:40.489
They are going to catch your mistakes
better than you catch them first.

01:00:40.489 --> 01:00:48.639
So, we've dumped a lot on you today, and if you need
more information, here's some people that you contact.

01:00:48.639 --> 01:00:52.460
You may already know Sal Soghoian,
our product marketing manager.

01:00:52.460 --> 01:00:55.190
He can help you in many, many ways.

01:00:55.190 --> 01:01:02.579
He's a very experienced scripter himself, and knows
a lot of the scriptable applications out there.

01:01:02.579 --> 01:01:06.210
If you're looking for solutions, he may have the answer.

01:01:06.210 --> 01:01:09.900
John Montbriand is our contact at
developer technical services.

01:01:09.900 --> 01:01:16.800
If you have questions about coding about developing
dictionaries, go straight to DTS and ask for John.

01:01:16.800 --> 01:01:23.610
And we talked about the Technote 2106, the scripting
interface guidelines, there's the URL for that.

01:01:23.610 --> 01:01:29.030
I talked about the webpage with the 3000
4 byte codes, there's a URL for that,

01:01:29.030 --> 01:01:33.160
and there's going to be a page for this particular session.

01:01:33.159 --> 01:01:42.089
If you go to developer dot apple dot com, wwwdc 2007 and
look  up session 205, you'll find a list of about eight

01:01:42.090 --> 01:01:50.650
or ten documents and links to sample
code, guidelines, and other documentation

01:01:50.650 --> 01:01:55.170
that can help you get started in
making your application scriptable.

01:01:56.219 --> 01:01:58.119
There's also going to be a lab this afternoon.

01:01:58.119 --> 01:02:03.789
I mentioned Mark Piccirelli's session, those of you
that want more, who are maybe a little bit farther along

01:02:03.789 --> 01:02:07.789
in making your application scriptable, or are
just interested in what the newest developments

01:02:07.789 --> 01:02:10.000
in Leopard are, are going to want to go to that.

01:02:10.000 --> 01:02:14.389
Immediately after that, in the labs downstairs in section D,

01:02:14.389 --> 01:02:17.859
we're going to be having our application
scripting laboratory.

01:02:17.860 --> 01:02:22.070
If you're eager to get started, you can start before that.

01:02:22.070 --> 01:02:26.309
After this session's over, I'm going to take a
little break, and then I'll be down in the lab.

01:02:26.309 --> 01:02:32.299
Just come down, tell the concierge there that you're looking
for AppleScript help, somebody will be there to help you.

01:02:32.300 --> 01:02:34.590
You don't have to wait till 3:30 this afternoo0n.

01:02:34.590 --> 01:02:42.670
But don't miss Mark's session, there's
a lot of important stuff there too.

01:02:42.670 --> 01:02:49.240
So, in summary, what this is about is giving
your customers, your scripters the ability

01:02:49.239 --> 01:02:54.319
to solve their real world problems themselves, so
that you don't have to constantly be at their beck

01:02:54.320 --> 01:02:58.880
and call to add tiny little features
that have small audiences.

01:02:58.880 --> 01:03:03.369
The developers, you don't spend as
much time hunting for regressions.

01:03:03.369 --> 01:03:07.789
Your automated scripting, your automated testing
can do that for you, and you spend more time

01:03:07.789 --> 01:03:11.630
on the most beneficial features because
you've gotten feedback from your customers

01:03:11.630 --> 01:03:14.910
as to what those beneficial features ought to look like.

01:03:14.909 --> 01:03:19.690
And your customers are going to spend a lot less time
doing the same thing over and over and over again.

01:03:19.690 --> 01:03:24.230
Their experience with your application is going
to be much more friendly, much more happy,

01:03:24.230 --> 01:03:25.980
because they're going to do something a couple of times,

01:03:25.980 --> 01:03:28.809
they're going to like it, and then
they're going to automate it.

01:03:28.809 --> 01:03:35.179
And in the end, they're going to spend more money on your
software because it's now part of their everyday lives.
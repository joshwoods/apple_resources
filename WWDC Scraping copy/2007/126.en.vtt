WEBVTT

00:00:20.899 --> 00:00:21.859
>> Good afternoon.

00:00:21.859 --> 00:00:26.669
I'm Dominic Giampaolo and this is my imaginary
friend Brent Knight who is actually in San Antonio,

00:00:26.670 --> 00:00:31.090
Texas because his wife is sick and his child.

00:00:31.089 --> 00:00:37.030
We worked on the FSEvents.framework and that's what we're
going to talk to you about today, well, Brent isn't, I will.

00:00:37.030 --> 00:00:38.750
Okay. So what's the agenda?

00:00:38.750 --> 00:00:43.820
We're going to talk about, start with the history and
background, some of this, if you were here last year,

00:00:43.820 --> 00:00:47.000
this will be a little rehash, but
there is quite a bit of new material.

00:00:47.000 --> 00:00:48.899
So don't totally fall asleep.

00:00:48.899 --> 00:00:55.769
After the history and background, we'll go over the
FSEvents framework, the API, kind of the concepts,

00:00:55.770 --> 00:01:02.410
what's involved, and then, of course, since this
is WWDC we'll be dealing some example code,

00:01:02.409 --> 00:01:08.780
sample application that uses the FSEvents framework,
not too complicated, but gives you the basics.

00:01:08.780 --> 00:01:15.739
Then we'll move on to some advance topics, not so much in
the code, but speaking about different parts of the API ,

00:01:15.739 --> 00:01:24.439
this is some of the stuff where a lot has changed since
last year, and then, of course, a review and wrap up.

00:01:24.439 --> 00:01:27.000
So, history and background.

00:01:27.000 --> 00:01:31.060
As I'm fond of saying, any engineering problem
starts with defining what it is you are trying

00:01:31.060 --> 00:01:33.480
to solve before you go and start writing code.

00:01:33.480 --> 00:01:40.950
So in this case for FSEvents framework, the problem that we
were trying to solve is, did anything change in this hierarchy

00:01:40.950 --> 00:01:43.700
or is anything changing in this hierarchy?

00:01:43.700 --> 00:01:49.590
And those are actually pretty hard questions, because
that hierarchy can be big and it's not something

00:01:49.590 --> 00:01:53.040
that is easy to necessarily just watch everything.

00:01:53.040 --> 00:01:55.460
So that's what we were trying to solve.

00:01:55.459 --> 00:01:59.500
We also realized that different applications
may want different types of answers.

00:01:59.500 --> 00:02:04.870
Like as you noticed, did anything change,
sort of has this historical bent to it

00:02:04.870 --> 00:02:09.560
and is anything changing is more of a live kind of question.

00:02:09.560 --> 00:02:14.069
Now, of course, everybody wasn't just sitting around
waiting for us to do this for the last 25 years,

00:02:14.069 --> 00:02:16.620
so there are various techniques that people have used.

00:02:16.620 --> 00:02:19.870
So let's kind of go over those to set
the stage for what's wrong with them

00:02:19.870 --> 00:02:24.050
or what the deficiencies are and
what FSEvents brings to the table.

00:02:24.050 --> 00:02:28.410
The first thing is there is polling
with stat(), you can ask, did this change?

00:02:28.409 --> 00:02:35.000
Did this change, repeatedly, and drain the battery
and spin up the hard disk and so on and so forth?

00:02:35.000 --> 00:02:39.409
A step above that kqueues()  which were
introduced in, I think in,

00:02:39.409 --> 00:02:42.639
definitely in Tiger probably I think it
was Jaguar that they were first introduced.

00:02:42.639 --> 00:02:48.529
And this is certainly a better
mechanism because it is event driven.

00:02:48.530 --> 00:02:52.500
That is, you say I'm interested in this
object, tell me when something happens to it.

00:02:52.500 --> 00:02:57.719
So that's a step above, then there is
the FNSubscribe and FNNotify APIs

00:02:57.719 --> 00:03:01.229
which existed all the way back to Mac OS 9.

00:03:01.229 --> 00:03:08.299
Those are more kind of opt-in APIs
where someone can subscribe to notifications

00:03:08.300 --> 00:03:12.010
and someone else can publish them with FNNotify.

00:03:12.009 --> 00:03:16.060
And then, of course, there is the
kauth subsystem that was introduced in Tiger.

00:03:16.060 --> 00:03:21.340
Now, what are the problems with this? full
rescans are slow, so anything you do with stat(),

00:03:21.340 --> 00:03:24.370
where your application starts up and
goes, hmmm...did anything change?

00:03:24.370 --> 00:03:26.360
Let me just go walk the whole hierarchy.

00:03:26.360 --> 00:03:35.130
That has a lot of performance implications, can potentially
be very slow in addition to using a lot of CPU time,

00:03:35.129 --> 00:03:38.729
burning down the battery, spinning up
the hard disks more than is necessary.

00:03:38.729 --> 00:03:45.519
There is no way to watch an entire hierarchy with kqueues(). So
you can say I want to watch this individual object and that's great

00:03:45.520 --> 00:03:51.200
especially because it's event driven, but if you want, if that object
happens to be the root of a large hierarchy, you won't find

00:03:51.199 --> 00:03:53.759
out if something ten levels down changes.

00:03:53.759 --> 00:03:56.819
You have to open file descriptors for every single thing.

00:03:56.819 --> 00:04:00.739
If there are 100,000 files you can't do that.

00:04:00.740 --> 00:04:06.110
Often APIs like FNSubscribe and FNNotify
are good in that they are event driven,

00:04:06.110 --> 00:04:11.530
but they are opt in so you don't
necessarily find out about all the changes.

00:04:11.530 --> 00:04:18.050
kauth is a kernel level subsystem and that's not really
practical for most applications developing text,

00:04:18.050 --> 00:04:24.189
installing them and so forth is a bit of a
hassle for just wanting to find out what changed.

00:04:24.189 --> 00:04:26.910
And with all these systems there's no history of events.

00:04:26.910 --> 00:04:30.530
So unless your application is running
you won't necessarily know.

00:04:30.529 --> 00:04:34.119
So you would have to do a full rescan.

00:04:34.120 --> 00:04:41.560
So it would be nice to actually have a historical way
to ask for what did change while I wasn't running.

00:04:41.560 --> 00:04:48.129
So, the first step in solving this was /dev/fsevents
events, which got introduced in Tiger for Spotlight

00:04:48.129 --> 00:04:51.560
and some of you discovered and
started writing programs that fiddle

00:04:51.560 --> 00:04:55.709
around with it even though you're
not supposed to, but that's okay.

00:04:55.709 --> 00:04:57.680
And this provides a raw stream of events.

00:04:57.680 --> 00:05:01.620
When I say raw stream of events
it's all LOCALLY generated events.

00:05:01.620 --> 00:05:10.300
So at a fairly fine granularity of this file had stat() changed
that is like the times were updated, this file was modified,

00:05:10.300 --> 00:05:13.730
this file was created, deleted, renamed, so on.

00:05:13.730 --> 00:05:18.580
So even local changes to network
file systems generated events--or generate events.

00:05:18.579 --> 00:05:28.310
These events are very raw and the kernel mechanism by
nature and by design is lossy in that

00:05:28.310 --> 00:05:35.839
if there's no room to put the events in, they will be
dropped, because you can't block generating an event waiting

00:05:35.839 --> 00:05:39.829
for someone to consume it, otherwise
you wind up with these nasty three-way

00:05:39.829 --> 00:05:43.389
or multi-way dead locks that you can't break out of.

00:05:43.389 --> 00:05:45.490
So, it's sensitive to slow clients.

00:05:45.490 --> 00:05:52.090
If someone doesn't read it, read the events out of the
kernel, because it's a shared queue, everybody loses.

00:05:52.089 --> 00:05:56.699
So, that's not the kind of thing we would want
to expose to regular user applications.

00:05:56.699 --> 00:06:02.550
The internal clients that you use /dev/fsevents
like Spotlight taught us quite a bit about it as well

00:06:02.550 --> 00:06:08.430
and then we also got a lot of feedback from WWDC last
year when we first introduced the FSEvents framework.

00:06:08.430 --> 00:06:13.250
And in facts it's pretty remarkable a
lot of the feedback we got from that,

00:06:13.250 --> 00:06:19.610
as well as from internal use, really played
a significant part in some changes that were made.

00:06:19.610 --> 00:06:26.960
So, setting the stage here, the design rationale
that we used, we considered a few types of clients.

00:06:26.959 --> 00:06:33.239
Time Machine and Backup and all sorts of things, did
anything change in this hierarchy so that I can do X,

00:06:33.240 --> 00:06:37.560
Y or Z. File Sync, which is also
a very similar type of application.

00:06:37.560 --> 00:06:41.560
Did anything change that I need to
know, synchronize with another machine?

00:06:41.560 --> 00:06:51.180
Now Finder is asking the, is anything changing type
question and for when you have the folder sizing turned on,

00:06:51.180 --> 00:06:59.370
if you have a folder displayed and something gets dropped
into a folder way down inside that hierarchy the find,

00:06:59.370 --> 00:07:03.870
the folder size for that file,
for that folder should update.

00:07:03.870 --> 00:07:06.220
So the Finder uses it as well.

00:07:06.220 --> 00:07:08.830
We know that this is not going to satisfy virus checkers.

00:07:08.829 --> 00:07:14.189
A lot of people think I'm going to find
out about changes and go check on stuff.

00:07:14.189 --> 00:07:22.759
This is much more informational as opposed to interposing;
something like a virus checker would probably use kauth.

00:07:22.759 --> 00:07:27.539
Limitations and constraints, now we
know that we can't store a complete log,

00:07:27.540 --> 00:07:32.580
a 100% accurate log
of everything that has happened.

00:07:32.579 --> 00:07:39.219
You're computer is intended to be used by you for
various applications, not for storing file system events.

00:07:39.220 --> 00:07:44.270
I think you'd be unhappy if we were eating up
significant fractions of the CPU and disk bandwidth.

00:07:44.269 --> 00:07:48.069
We need to filter the event stream
into something that is manageable,

00:07:48.069 --> 00:07:51.699
something that applications can more easily digest.

00:07:51.699 --> 00:07:56.560
We can't all be all things to all
people, so let's not even try.

00:07:56.560 --> 00:08:01.660
I tend to keep things simple in design, just so that
it is more manageable and I can get my head around it

00:08:01.660 --> 00:08:06.100
and that's kind of the rationale behind it.

00:08:06.100 --> 00:08:13.480
So, some assumptions we had to make. First off, when
you have a client that is watching some hierarchy,

00:08:13.480 --> 00:08:16.710
it has to have a way to generate its initial state.

00:08:16.709 --> 00:08:19.199
So you have to have code that does a full scan.

00:08:19.199 --> 00:08:24.409
Point it at a hierarchy and go,
build up some internal state.

00:08:24.410 --> 00:08:29.860
So if you have that, then it's pretty straight forward
to say, well okay, just go look at this piece here

00:08:29.860 --> 00:08:35.029
and do a partial scan. Don't actually go
cursive and descend into the hierarchy.

00:08:35.029 --> 00:08:44.069
So, given those two pieces, if you have some current
state, some initial state, you can compare that to what is

00:08:44.070 --> 00:08:47.750
out there currently, when something changes.

00:08:47.750 --> 00:08:52.139
And that you can update your state when you get a
notification that something has changed.

00:08:52.139 --> 00:08:59.929
So kind of the mental model is you build an initial state
or whatever, metadata you need

00:08:59.929 --> 00:09:03.500
to extract from a hierarchy and
then when changes happen to it,

00:09:03.500 --> 00:09:07.919
you go update just the specific part
of the hierarchy that has changed.

00:09:07.919 --> 00:09:10.250
We are going to go into this in quite a bit more detail.

00:09:10.250 --> 00:09:18.169
So, the FSEvents framework is a CoreFoundation API that
lets you, gives you the ability to watch a large hierarchy

00:09:18.169 --> 00:09:23.389
for changes, get directory-level notifications of changes.

00:09:23.389 --> 00:09:26.250
All local changes produce events.

00:09:26.250 --> 00:09:32.220
So you can watch a remote file system if you want,
locally generated events will trigger updates.

00:09:32.220 --> 00:09:37.600
Now, if someone changes something on the server
through another client you won't hear about it.

00:09:37.600 --> 00:09:46.529
There's a persistent change history and this is a key
feature, so you can say my Mac last ran at this event ID,

00:09:46.529 --> 00:09:54.000
which I'll explain in a minute, what happened since then and
find out about it, even if that was a week ago or a month ago.

00:09:54.000 --> 00:09:56.899
You have fine control over the frequency of updates.

00:09:56.899 --> 00:10:05.620
So it's kind of a pretty decent package. You don't get
specific changes to event changes for specific files.

00:10:05.620 --> 00:10:08.570
So, if file foo changes, you're
not going to receive an event,

00:10:08.570 --> 00:10:13.710
you are going to receive an event for
the directory that contains it.

00:10:13.710 --> 00:10:16.129
Okay, let's talk a little bit about the architecture.

00:10:16.129 --> 00:10:20.350
Sometimes it's useful to understand
how all the pieces fit together.

00:10:20.350 --> 00:10:25.399
So as I've said, FSEvents is a framework, the core
foundation framework, the API that you guys can call

00:10:25.399 --> 00:10:32.399
and it's backed by a corresponding daemon fseventsd.
fseventsd reads the events out of the kernel

00:10:32.399 --> 00:10:36.419
and kind of multiplexes that stream out to clients.

00:10:36.419 --> 00:10:42.379
It filters it, massages it, and does a bunch of
other work to makes it something that's more manageable.

00:10:42.379 --> 00:10:49.740
Graphically, it looks like what we have here where
the kernel is spewing events up into fseventsd

00:10:49.740 --> 00:10:56.399
who scrolls them away in the event history and then
passes them through to the FSEvents framework

00:10:56.399 --> 00:11:00.340
which eventually makes its way
over to the client application.

00:11:00.340 --> 00:11:03.970
So that's kind of how all the pieces fit together.

00:11:05.220 --> 00:11:12.970
Now, a lot of times, new API, oooh, I got to use it, I got to find
a way to make it, I got a hammer now I got to find a nail.

00:11:12.970 --> 00:11:17.750
FSEvents framework is good, but it's
not always the appropriate thing to use.

00:11:17.750 --> 00:11:24.320
If you have a, let's say a few tens of files at
most, kqueue() you make actually be more appropriate.

00:11:24.320 --> 00:11:28.140
You're going to find out very specifically
this is the file that changed.

00:11:28.139 --> 00:11:33.269
Once you get beyond, if you wanna
say tens, twenty, twenty-five files,

00:11:33.269 --> 00:11:35.210
then it starts to get a little bit more unwieldy.

00:11:35.210 --> 00:11:40.030
If you just need to check a few
files, did my preference file change

00:11:40.029 --> 00:11:46.679
or did some other little file change on
the disk, just use stat() and check it.

00:11:46.679 --> 00:11:52.509
That's actually probably going to be more efficient than
asking to churn through the history of all the changes

00:11:52.509 --> 00:11:55.750
that have happened to look if a particular file changed.

00:11:55.750 --> 00:12:01.320
FSEvents is best when you have basically
a large hierarchy that you'd like to watch.

00:12:01.320 --> 00:12:08.150
You know, i.e., a large repository of media files,
did someone go in there and monkey around with stuff,

00:12:08.149 --> 00:12:15.439
a large package that contains a lot of subfolders, you need
a full history of changes, or you want to watch something

00:12:15.440 --> 00:12:19.500
that may not exist yet and I'll get to that too in a minute.

00:12:19.500 --> 00:12:26.220
All right, so let's go over to the demo machine
real quick and I will show it to you in practice.

00:12:26.220 --> 00:12:29.149
This isn't going to be super exciting.

00:12:29.149 --> 00:12:31.289
Can we switch to the demo machine?

00:12:31.289 --> 00:12:36.079
Okay. There we go.

00:12:36.080 --> 00:12:43.490
All right, so I have two sort of not
very nicely colored windows here.

00:12:43.490 --> 00:12:52.899
We have a little test program that we use
internally, that is called FSEvents creatively enough,

00:12:52.899 --> 00:12:55.240
that let's you play with various API options.

00:12:55.240 --> 00:12:57.620
It's an internal testing tool.

00:12:57.620 --> 00:13:03.379
So I'm going to say, -latency and
I'll go through what all this means.

00:13:03.379 --> 00:13:13.250
1.0, for one second latency and I'm going to watch,
~/dgb, I've made a subdirectory for myself here.

00:13:13.250 --> 00:13:25.059
And so it prints out this new ID for the event
stream for this path and what's a good way to do this?

00:13:25.059 --> 00:13:27.539
Let's make this guy a little bit smaller.

00:13:27.539 --> 00:13:36.949
Now I will mkdir tmp and you'll see an event comes
up that the users apple$ dbg directory was modified

00:13:36.950 --> 00:13:39.520
because I've made this subdirectory called tmp.

00:13:39.519 --> 00:13:46.240
Now cd into there and I have this little alias called
make-files, which will create, I think it's about 5,000 files

00:13:46.240 --> 00:13:53.730
and we got an event that users dbg tmp was
modified and there's 5,000 files in there.

00:13:53.730 --> 00:13:58.639
And it's kind of nice that even though all this
churn happened, this huge burst of activity,

00:13:58.639 --> 00:14:03.919
got one event and I go and I can rescan that
directory if I wanted to, to find out what happened.

00:14:03.919 --> 00:14:11.769
As opposed to getting 5,000 events and you know, competing
with the guy who's trying to do the work to get in there.

00:14:11.769 --> 00:14:18.990
If I remove them all then I actually, in this case, get
a couple of events because of the way things work.

00:14:18.990 --> 00:14:20.220
And that's what I was going to show you next.

00:14:20.220 --> 00:14:29.730
So if I was to change the latency to let's say, some
ridiculously small latency of a hundredth of a second

00:14:29.730 --> 00:14:35.470
and now I go and create all those files
again, I get a whole bunch of events.

00:14:35.470 --> 00:14:40.600
So what this points out is the
fine control over the delivery of events.

00:14:40.600 --> 00:14:49.269
If you have an interactive application, you may want to have
the display update a bit more frequently than once a second.

00:14:49.269 --> 00:14:54.679
So you might ask for half second latency or maybe
even a tenth of a second, certainly not much more,

00:14:54.679 --> 00:14:57.929
not much less than what the display update is.

00:14:57.929 --> 00:15:04.309
There's no point in getting a hundred updates a second
if you can only update the screen 60 times a second.

00:15:04.309 --> 00:15:11.989
So, in this example, a hundredth of a second generated way
to many events for the creation of 5,000 files.

00:15:11.990 --> 00:15:16.830
So you almost never use a latency that small.

00:15:16.830 --> 00:15:24.800
Another thing to notice is that if I watch, didn't have
to stop it, but if I watch this ~/dbg directory

00:15:24.799 --> 00:15:29.409
and I go back to the home directory and
I mkdir foo it will get an event.

00:15:29.409 --> 00:15:30.500
It happens somewhere else.

00:15:30.500 --> 00:15:37.450
It was not in the path or the hierarchy that I was
watching and so it doesn't notify my application.

00:15:37.450 --> 00:15:46.590
Another thing to notice is that if I was watch
/tmp, and I'll harp on this issue a few times,

00:15:46.590 --> 00:15:54.090
touch boo, the path that comes through
was actually /private/tmp.

00:15:54.090 --> 00:15:59.790
You need to be aware of things that are symlinks or
that would cause you to traverse to some other place.

00:15:59.789 --> 00:16:05.219
So this, the path gets resolved and
in this situation, but you maybe surprised

00:16:05.220 --> 00:16:09.110
when you watch /tmp, you actually
get an event for /private/tmp,

00:16:09.110 --> 00:16:12.460
because that is where it really points to.

00:16:12.460 --> 00:16:19.690
So, I think that's reasonable demo
of the FSEvents tool itself.

00:16:19.690 --> 00:16:26.600
So if we switch back to the slides, because we'll
get into a bit more into stuff with the example application.

00:16:26.600 --> 00:16:34.250
So, if we can go back to the slides.

00:16:34.250 --> 00:16:39.960
Okay. So that was, you know, standard
Dominic command-line demo.

00:16:39.960 --> 00:16:42.930
Now, if you were here last year like I said.

00:16:42.929 --> 00:16:44.649
Don't fall asleep; it's time to wake up.

00:16:44.649 --> 00:16:45.899
This is the stuff that is new.

00:16:45.899 --> 00:16:51.500
I was just going to briefly highlight and
it gets covered in line with the rest of it.

00:16:51.500 --> 00:16:54.230
So you have to stay awake the whole time.

00:16:54.230 --> 00:16:58.659
There's a bunch of new device specific, not
bunch, there is a new device-specific APIs,

00:16:58.659 --> 00:17:04.399
there's a per device UUID, that kind
of big ugly string that got printed at the very beginning

00:17:04.400 --> 00:17:13.019
at the FSEvents tool, is a UUID that identifies
a particular event stream for a device.

00:17:13.019 --> 00:17:19.089
There's better handling of historical events, we noticed
that it was kind of difficult to process historical events,

00:17:19.089 --> 00:17:22.750
like when did they stop when am I getting
live events, how will I know when it switched?

00:17:22.750 --> 00:17:24.809
We have a new HistoryDone flag.

00:17:24.809 --> 00:17:27.240
There's more control over event delivery.

00:17:27.240 --> 00:17:32.529
There was this bit of contention over the latency,
the interpretation of the latency parameter,

00:17:32.529 --> 00:17:38.450
there's a NoDefer flag and as
well as these flushing functions.

00:17:38.450 --> 00:17:42.680
There's better handling to changes
of the root of a watched hierarchy.

00:17:42.680 --> 00:17:47.430
And again I'll go into this in more detail later on.

00:17:47.430 --> 00:17:54.190
Better handling of volumes coming and going, because
if you're watching a device-specific volume you,

00:17:54.190 --> 00:17:58.009
with a device-specific API, you need
to know when that volume goes away.

00:17:58.009 --> 00:18:03.819
Security which wasn't implemented at all last
year is, of course, in place and in for a variety

00:18:03.819 --> 00:18:09.899
of reasons it's much more robust and has a lot
fewer dropped events then it did last year.

00:18:09.900 --> 00:18:14.730
So, let's get into the concrete details of the API.

00:18:14.730 --> 00:18:25.860
The data types and the concepts that you have to master,
are basically three things. You have an FSEventStream,

00:18:25.859 --> 00:18:30.979
which is the mechanism that sends you
the notifications about what changed.

00:18:30.980 --> 00:18:32.900
It's a CFRunLoop provider.

00:18:32.900 --> 00:18:39.050
So if you're familiar with CFRunLoops and how that
works and if you program on the Mac, I imagine you are,

00:18:39.049 --> 00:18:46.109
is pretty basic stuff and that's how you get hooked into
the events stream and what happens the notifications call

00:18:46.109 --> 00:18:53.389
a callback and that's your FSEventsCallback. The
second thing that you most "master" to understand the API

00:18:53.390 --> 00:18:57.570
and it's called every time there are
changes. And then the events you get.

00:18:57.569 --> 00:19:03.740
The events have three pieces of information each,
where the change happened, that is the path to it,

00:19:03.740 --> 00:19:09.569
"when" and I put that in quotes and I'll explain
later, when did the event happen, and some information...

00:19:09.569 --> 00:19:13.609
some flags about the event that you need to look at.

00:19:13.609 --> 00:19:16.229
As I said, there are two types of streams.

00:19:16.230 --> 00:19:22.730
There are device relative streams, which is the
preferred type of stream as we learned over the course

00:19:22.730 --> 00:19:27.569
of the last year and you must use them
when your application stores event IDs.

00:19:27.569 --> 00:19:32.189
Paths specified with device relative streams
are relative to the root of the device.

00:19:32.190 --> 00:19:37.480
So if you are watching /Volumes/MyDisk,
the path is /Users/freddy.

00:19:37.480 --> 00:19:42.180
It would be /Volumes/MyDisk/Users/freddy being the full path.

00:19:42.180 --> 00:19:46.970
You don't have any problems with volume renames
also when you have the device relative stream.

00:19:46.970 --> 00:19:53.200
Absolute path streams are useful if you are doing live
monitoring, but we sort of don't really recommend them

00:19:53.200 --> 00:19:58.779
because of the, especially when you have a deep
path, if you're not watching slash it can get tricky

00:19:58.779 --> 00:20:04.569
as to what happens when things change up above it.

00:20:04.569 --> 00:20:12.309
Now, device UUIDs, these uniquely identify
the event stream for a given device.

00:20:12.309 --> 00:20:18.659
So, there's a way to get them, of course,
FSEventsCopyUUIDForDevice() and it's something you would use

00:20:18.660 --> 00:20:22.420
to verify that when you start up a second time

00:20:22.420 --> 00:20:29.440
is the event stream that's out there now the same
one I saw at the last time, because they can change.

00:20:29.440 --> 00:20:34.130
This UUID is not the same as a DiskArb UUID for a disk.

00:20:34.130 --> 00:20:38.950
It's not intended to be a replacement; it's
to uniquely identify the event stream

00:20:38.950 --> 00:20:44.779
and the event ID numbers that are there match what you have.

00:20:44.779 --> 00:20:48.759
The UUID for device can change for several reasons.

00:20:48.759 --> 00:20:56.339
Even though it is a 64-bit value, the event ID
could wrap, although in practice it wouldn't,

00:20:56.339 --> 00:21:01.750
but a nefarious user could create a
situation where they put an event ID

00:21:01.750 --> 00:21:05.519
on the disk that causes it to wrap fairly quickly.

00:21:05.519 --> 00:21:10.200
If someone purges the history on the
disk, and I'll talk about that later,

00:21:10.200 --> 00:21:15.580
that could also cause the event
ID, the UUID to change and therefore

00:21:15.579 --> 00:21:18.809
when a UUID changes it means the event IDs are no longer valid.

00:21:18.809 --> 00:21:26.950
Other catastrophic situations, if the kernel were for
some unforeseen reason to drop events that causes the UUID

00:21:26.950 --> 00:21:31.850
to change or the event IDs, we don't know when
events get dropped, we don't know what happened.

00:21:31.849 --> 00:21:34.599
So we have to say there's been a discontinuity.

00:21:34.599 --> 00:21:43.059
Not so catastrophic situations are things where, for
example, a disk is taken, a removable disk is taken

00:21:43.059 --> 00:21:49.679
from a Leopard system to a Tiger system modified there,
the changes are not updated in the FSEvents history

00:21:49.680 --> 00:21:52.190
and that's brought back to a Leopard system.

00:21:52.190 --> 00:21:56.059
Hopefully this will not be a very common
sort of situation, but it could happen.

00:21:56.059 --> 00:22:02.319
Also, devices such as MS DOS where we don't
know if they've been modified offline,

00:22:02.319 --> 00:22:06.750
They are not able to store a permanent record.

00:22:06.750 --> 00:22:10.549
So, FSEventsStreamCreate(), there's two forms as I said.

00:22:10.549 --> 00:22:15.639
The absolute path version is FSEventsStreamCreate(),
which is what existed last year

00:22:15.640 --> 00:22:20.210
and then we have the new function
FSEventsStreamCreateRelativeToDevice().

00:22:20.210 --> 00:22:23.460
The arguments, pretty straight forward.

00:22:23.460 --> 00:22:26.740
The array of paths you would like to watch.

00:22:26.740 --> 00:22:32.200
Again, if it's relative to device, the paths
should have the volume prefix stripped off.

00:22:32.200 --> 00:22:36.140
So that it's just from the root of the volume down.

00:22:36.140 --> 00:22:39.970
The callback, which is the function
you want to get control.

00:22:39.970 --> 00:22:46.440
sinceWhen is a starting eventID and I'll
get into more detail about that in a minute.

00:22:46.440 --> 00:22:53.680
Latency as you saw was a value, floating point value to
specify the numbers of what the interval of time you would

00:22:53.680 --> 00:22:58.000
like before you get events or how they are batched.

00:22:58.000 --> 00:23:00.339
Flags which control the behavior of the stream.

00:23:00.339 --> 00:23:05.669
There's a lot of bits that you can set to
control different features and for the relative

00:23:05.670 --> 00:23:07.320
to device function you past a dev_t.

00:23:07.319 --> 00:23:12.799
See this is where my UNIX heritage kind of
bubbles up into a core foundation API.

00:23:12.799 --> 00:23:18.039
You get a dev_t, which is the device you want to watch.

00:23:18.039 --> 00:23:23.950
FSEventsStream, as I said, is a CFRunLoop provider,
so it follows a pretty standard life cycle.

00:23:23.950 --> 00:23:28.819
You create it, you schedule it on a
particular run loop, then once your start it,

00:23:28.819 --> 00:23:33.819
your callback will begin being
called when the run loop is run.

00:23:33.819 --> 00:23:39.869
You can stop a stream, which allows you to do an
orderly shut down, so that you don't have to worry

00:23:39.869 --> 00:23:46.169
about race conditions with the callback being called while
you are trying to tear down the stream, so on and so forth.

00:23:46.170 --> 00:23:52.009
So these are clean ways to start and stop a stream.

00:23:52.009 --> 00:23:56.240
Typically after you stop the stream, you just
would call and validate and release it,

00:23:56.240 --> 00:24:00.319
although you can actually restart a stream if you'd like.

00:24:00.319 --> 00:24:09.269
Although there's a, if you're watching historical events
in the WWDC seed you'll get an extra history done event.

00:24:09.269 --> 00:24:11.589
Any way, don't worry about that yet.

00:24:11.589 --> 00:24:13.009
That will be fixed.

00:24:13.009 --> 00:24:18.079
So the paths that you pass in, the
path does not have to exist yet.

00:24:18.079 --> 00:24:20.409
This is kind of a neat feature, because it all sort

00:24:20.410 --> 00:24:24.990
of directory-prefix based matching,
string based matching on the names.

00:24:24.990 --> 00:24:34.710
You could watch users foo documents, does not
exist and when that directory comes into existence

00:24:34.710 --> 00:24:37.860
and something is created inside of
it you'll start receiving events.

00:24:37.859 --> 00:24:41.240
So it's kind of convenient in that way.

00:24:41.240 --> 00:24:46.460
Device relative streams, as I mentioned a few
times now, have to be using relative paths.

00:24:46.460 --> 00:24:50.990
Anything that changes under the path
that you are watching produces an event.

00:24:50.990 --> 00:24:52.620
You can watch any number of paths.

00:24:52.619 --> 00:24:56.739
Typically each stream corresponds
to one path that it is watched.

00:24:56.740 --> 00:25:02.299
But you could watch five, ten, whatever,
fifteen paths in an array and you watch them.

00:25:02.299 --> 00:25:05.720
Non-root FSEvents clients do have permissions checked.

00:25:05.720 --> 00:25:13.500
That is fseventsd will say, okay, you're not root,
you're UUID 501 I'm going to do, I'm going to validate

00:25:13.500 --> 00:25:19.180
that you can actually see the event, the directory
that is being modified so you can't decide

00:25:19.180 --> 00:25:22.950
to watch something that you don't have permission to.

00:25:22.950 --> 00:25:25.880
Again being careful, you have to be
careful of symlinks and hardlinks.

00:25:25.880 --> 00:25:33.300
If there is a hardlink, if there are multiple hardlinks
to a particular piece of data and you're watching it

00:25:33.299 --> 00:25:41.940
in hierarchy A and it gets modified in hierarchy B you don't
get an event because the path in hierarchy A was not modified.

00:25:41.940 --> 00:25:46.450
Again, the paths are matched on strings.

00:25:46.450 --> 00:25:51.660
realpath() is used internally to resolve symlinks
so you may, like I said, if you watch /tmp,

00:25:51.660 --> 00:25:56.040
this was one of the first things that everyone did was,
they watched /tmp and they didn't get any events

00:25:56.039 --> 00:25:59.639
because we were looking for the string /tmp,
but actually it is a private/tmp.

00:25:59.640 --> 00:26:02.250
So we use real path to resolve things.

00:26:02.250 --> 00:26:06.890
Again, modifications to hardlinks or symlinks,
if something traverses through a symlink

00:26:06.890 --> 00:26:11.660
and goes outside of the hierarchy that you're modifying,
or watching and gets modified outside of there,

00:26:11.660 --> 00:26:14.050
you wouldn't get an event.

00:26:14.049 --> 00:26:21.799
The callback gets what you might expect, which is
the number of events that happened, an array of paths,

00:26:21.799 --> 00:26:29.849
an array of eventFlags, each one
across the row correspond to each other,

00:26:29.849 --> 00:26:35.559
and event IDs, one array, one event ID for each event.

00:26:35.559 --> 00:26:40.029
Now a little bit more about the paths
that you'll get in your callback.

00:26:40.029 --> 00:26:44.839
If you watch /Users/foo and you modify
/Documents/MyCoolStuff/newfile,

00:26:44.839 --> 00:26:47.970
you get an event for /Documents/MyCoolStuff.

00:26:47.970 --> 00:26:51.039
If you create /Users/foobar/blah, you don't get an event.

00:26:51.039 --> 00:26:53.799
That's what I showed in the demo as well.

00:26:53.799 --> 00:26:57.359
Normally you don't get events for
changes to the root of the hierarchy.

00:26:57.359 --> 00:27:02.039
If you watch /Users/foo/somedir and you make, you create it.

00:27:02.039 --> 00:27:03.960
Let's say it didn't exist and you create it.

00:27:03.960 --> 00:27:06.610
There's no event for that, normally.

00:27:06.609 --> 00:27:10.069
And then when you create something
inside of it, that will produce an event.

00:27:10.069 --> 00:27:17.769
If you use a kFSEventStreamCreateFlagWatchRoot
when you create the stream then that will produce events

00:27:17.769 --> 00:27:21.190
when the root changes or any of its parents.

00:27:21.190 --> 00:27:25.529
As I keep saying, I'll talk more
about that further on in the talk.

00:27:25.529 --> 00:27:35.210
The flags that you can get for each event,
normally if everything is going straight forwardly.

00:27:35.210 --> 00:27:39.529
You'll get kFSEventStreamFlagNone, which means nothing special.

00:27:39.529 --> 00:27:42.109
There's nothing you need to do or be aware of.

00:27:42.109 --> 00:27:45.949
If for some reason something was dropped along the way.

00:27:45.950 --> 00:27:49.210
The path will say or the flag will say MustScanSubDirs.

00:27:49.210 --> 00:27:53.230
So starting at the path that you received,
go recursive from there down.

00:27:53.230 --> 00:27:56.900
You know, may be a small branch of
the hierarchy, it may be further up.

00:27:56.900 --> 00:27:59.030
Hopefully you'll never see that.

00:27:59.029 --> 00:28:04.099
There's two additional informational
flags that tell you why it happened.

00:28:04.099 --> 00:28:08.019
UserDropped means that your client
was not reading things quickly enough.

00:28:08.019 --> 00:28:13.349
KernelDropped, which I expect that no one will ever
see unless you run these crazy little test programs

00:28:13.349 --> 00:28:14.889
like I do, sometimes.

00:28:14.890 --> 00:28:16.590
Even then it's hard to do.

00:28:16.589 --> 00:28:22.500
Is kernel dropped and that means the kernel simply couldn't
keep up with the volume of changes that were happening

00:28:22.500 --> 00:28:26.460
and it ran out of space to keep track of events.

00:28:26.460 --> 00:28:30.490
Now, the EventIdsWrapped, as I alluded to.

00:28:30.490 --> 00:28:36.319
If you were to just generate events
normally with the 64-bit event ID counter

00:28:36.319 --> 00:28:40.359
it would take you probably anywhere in the
order of 100,000 years to cause them to wrap.

00:28:40.359 --> 00:28:42.179
So that's not likely to be the case.

00:28:42.180 --> 00:28:47.779
However, someone could create a situation where
they, you know have an event ID of all F's

00:28:47.779 --> 00:28:50.059
and the next event will cause it to wrap.

00:28:50.059 --> 00:28:57.259
And so we have to deal with that, because when event IDs
wrap you have no way to know and so we have to reset things.

00:28:57.259 --> 00:29:00.379
When I say you have no way to know what other changes

00:29:00.380 --> 00:29:04.850
your event IDs are longer going to be able
to be compared relative to each other.

00:29:04.849 --> 00:29:09.059
HistoryDone comes through, you'll
get a fake event when you,

00:29:09.059 --> 00:29:13.159
if you've asked for historical
events with the sinceWhen parameter.

00:29:13.160 --> 00:29:18.620
You'll get a HistoryDone flag set, so you'll
know, okay, now I'm getting live events.

00:29:18.619 --> 00:29:25.319
RootChanged is if you asked for the watch root bit
when you created the flag, or created the stream.

00:29:25.319 --> 00:29:32.839
RootChanged means that the root of the hierarchy that
you were watching is no longer there or something

00:29:32.839 --> 00:29:35.730
about it has changed and you need to go reexamine it.

00:29:35.730 --> 00:29:39.569
And mount and unmount mean a device has come and gone.

00:29:39.569 --> 00:29:45.169
And this will--talk about that more later
too; it's not replacement for DiskArb.

00:29:45.170 --> 00:29:48.340
EventIDs, as I said, there are 64-bit numbers.d

00:29:48.339 --> 00:29:53.669
They're monotonically increasing, they are
never recycled for all practical purposes,

00:29:53.670 --> 00:29:57.820
but they have no relation whatsoever
to any kind of wall-clock time.

00:29:57.819 --> 00:30:01.279
They're just a number, that just sequentially increases.

00:30:01.279 --> 00:30:07.950
So for a given event stream you can compare this
one happened before this other one, yes or no.

00:30:07.950 --> 00:30:18.210
You can ask for everything from this last event ID that I
saw, but it doesn't have any relation to wall-clock time.

00:30:18.210 --> 00:30:23.250
Now, the event history, few people maybe
wondering, well what do you really store?

00:30:23.250 --> 00:30:31.890
We really do store all events and for all time unless
something bad happens or we're asked to purged it.

00:30:31.890 --> 00:30:37.920
So the event history is pretty small and it compresses
well, because of the granularity of time and the window

00:30:37.920 --> 00:30:45.170
of time we look at changes and the strings that
tend to be modified tend to compress nicely.

00:30:45.170 --> 00:30:51.490
You can actually just store everything forever without
really significantly eating up a lot disk space.

00:30:51.490 --> 00:30:57.009
When I run tests that go 7 x 24 and really
hammer this system, I generate maybe, I don't know,

00:30:57.009 --> 00:30:59.839
I think it's about three or four megabytes of logs a day.

00:30:59.839 --> 00:31:02.819
So hardly a significant imposition.

00:31:02.819 --> 00:31:08.429
The event history is persistent, so you reboot no problem.

00:31:08.430 --> 00:31:15.700
You'll, as long as Leopard-only systems modify the
disk and given a previous UU... previous eventID

00:31:15.700 --> 00:31:23.269
and device UUID you can check that the event, that
the device UUID matches what's out there currently.

00:31:23.269 --> 00:31:27.700
So the one you stored matches what's out
there and you can ask for all the events

00:31:27.700 --> 00:31:29.850
that happened since that previous eventID.

00:31:29.849 --> 00:31:39.199
And as I said, the last historical event that you'll get
is fake and it's just means that you get HistoryDone bit

00:31:39.200 --> 00:31:44.529
and now you're switched from historical events to live events.

00:31:44.529 --> 00:31:49.789
Now, this is another example of things
that we got feedback from last year.

00:31:49.789 --> 00:31:53.849
You can ask for an approximate event
ID corresponding to a wall-clock time.

00:31:53.849 --> 00:31:59.389
So as I said, even though event IDs themselves
do not correspond to any particular time base,

00:31:59.390 --> 00:32:07.150
there's a way to map approximately so you can
say, what is the closest event ID that you know

00:32:07.150 --> 00:32:10.019
about to this particular time and we look at that.

00:32:10.019 --> 00:32:16.900
And the way we determine that is the time stamps on the log
files and we just sort of find the one that's the closest match for it.

00:32:16.900 --> 00:32:22.630
You can find out of the last event ID for this system, so that
you know what the greatest thing that's come along so far

00:32:22.630 --> 00:32:25.790
and you can purge the history up to a giving event ID.

00:32:25.789 --> 00:32:34.549
This was actually kind of very, I don't know if touching is the right word,
but after the WWDC last year, this Russian fellow comes

00:32:34.549 --> 00:32:39.259
up to me and says, it is very important
that you be able to erase the history,

00:32:39.259 --> 00:32:41.799
because your government may be trying to persecute you.

00:32:41.799 --> 00:32:44.269
I was like, he's not joking.

00:32:44.269 --> 00:32:52.769
I actually took that pretty seriously and made sure that you
have a way to erase the history should you have something

00:32:52.769 --> 00:32:56.200
that you're afraid your government will persecute you for.

00:32:56.200 --> 00:33:07.960
So, switching back over to the sample code and
hopefully nobody here has any of that kind of problems.

00:33:07.960 --> 00:33:10.920
Could we switch to the demo machine?

00:33:13.119 --> 00:33:25.129
Okay. So, stop that, so, I have
this sample program called Watcher.

00:33:25.130 --> 00:33:31.100
I'm just going to set up a little better here.

00:33:36.490 --> 00:33:43.079
Don't think I need that window.

00:33:43.079 --> 00:33:51.089
Okay, what Watcher does is, besides from all the disclaimers,
is, it's a simple example, if using FSEvents framework

00:33:51.089 --> 00:33:58.730
to watch a large, to watch a hierarchy and monitor for
changes to it so that you can update what the total size is.

00:33:58.730 --> 00:34:07.099
So, the first thing it does is, the state that it builds is
what the total size of this directory that you're watching

00:34:07.099 --> 00:34:11.449
and then when changes happen inside
of it, it will update that state.

00:34:11.449 --> 00:34:19.059
So just, show you how it works in practice
if I do watcher large-hierarchy, it will--

00:34:19.059 --> 00:34:27.250
it had the storage size and amazingly enough
there's 850,000 bytes exactly in this hierarchy.

00:34:27.250 --> 00:34:32.340
If something, I did actually need that other window, lovely.

00:34:32.340 --> 00:34:34.829
Well, apologies.

00:34:34.829 --> 00:34:40.610
You won't be able to see what I'm
doing in the window, that's okay.

00:34:40.610 --> 00:34:41.820
Maybe now you can.

00:34:41.820 --> 00:35:00.250
All right, so if I-- dd if= --I'm just going to create a
file this specific size, to-- =10kfile --

00:35:00.250 --> 00:35:10.489
that's actually not 10K. This will create a file
and now you can see the size change to 860,000 bytes

00:35:10.489 --> 00:35:16.369
and if I was to remove the 10kfile, it goes back.

00:35:16.369 --> 00:35:24.579
Now, again the whole point of FSEvents is that if
changes happen while your application isn't running,

00:35:24.579 --> 00:35:32.739
that you will find out about them and it gets,
the stored total size as you can see was 850,000,

00:35:32.739 --> 00:35:37.839
but then there was a change made and so then the
current is done processing the historical events

00:35:37.840 --> 00:35:42.230
that happened while the program wasn't
running and new size is 860,000.

00:35:42.230 --> 00:35:50.289
So this is pretty basic functionality, but
let's go through and see how it actually works.

00:35:50.289 --> 00:35:55.670
Let's jump down to where all good C programs start, name.

00:35:55.670 --> 00:36:00.300
There's a lot of support code that I'm not going
to go into such as interating the hierarchy

00:36:00.300 --> 00:36:03.280
and sating the files and figuring out the size that's in there.

00:36:03.280 --> 00:36:09.690
It's a sample code that you can download and look
at, but we're not going to cover that stuff today.

00:36:09.690 --> 00:36:13.250
There is one thing, hold on a second.

00:36:13.250 --> 00:36:16.690
This is going to drive me nuts.

00:36:16.690 --> 00:36:18.639
Yeah, yeah, yeah, I know.

00:36:18.639 --> 00:36:22.199
I can see everybody groaning.

00:36:22.199 --> 00:36:24.339
Sorry, we have four space versus eight space tabs.

00:36:24.340 --> 00:36:34.170
Anyway, all right, the first thing the program does is some
standard command-line processing of the setting structure

00:36:34.170 --> 00:36:43.220
that keeps track of the state for the application
and then we have a path, and as I said, we call real.

00:36:43.219 --> 00:36:52.419
Why is that, oh, it's not, okay, there we go.

00:36:52.420 --> 00:36:57.809
We call realpath to find out what the actual path
is that we're monitoring and this application cares,

00:36:57.809 --> 00:37:04.269
because if we were watching something that was a symlink,
the events that you get will be for the real, the true path

00:37:04.269 --> 00:37:07.539
and so you wouldn't want to have
differences or discrepancies

00:37:07.539 --> 00:37:12.940
between what you think the paths you should be
getting are and what they really come through as.

00:37:12.940 --> 00:37:15.519
So that's just some initial set up.

00:37:15.519 --> 00:37:22.750
We call this function watch_dir_hierarchy, which
is where most of the work happens, the set-up work.

00:37:22.750 --> 00:37:29.469
So, we call get_dev_info, which is
going to find out what the device is that we're watching.

00:37:29.469 --> 00:37:33.730
That function and I'll just pop to it this way.

00:37:33.730 --> 00:37:39.849
Does a little bit of wonky string
processing to find out what the,

00:37:39.849 --> 00:37:45.380
if the path didn't exist it walks further
back up it to find the piece that does

00:37:45.380 --> 00:37:49.160
and gets the dev_t out of the stat structure.

00:37:49.159 --> 00:37:54.649
Calls lstat and gets the dev, which
we set in our setting structure.

00:37:54.650 --> 00:37:57.970
Then we call FSEventsCopyUUIDForDevice.

00:37:57.969 --> 00:38:01.819
So this is the UUID that that device currently has.

00:38:01.820 --> 00:38:07.170
If we have saved state, we're going to
compare the UUID so we have to do this first.

00:38:07.170 --> 00:38:12.250
If things fail and you know, really
suck we also get the full mouth point.

00:38:12.250 --> 00:38:20.619
So, going back to watch_dir_hierarcy,
we've gotten our dev info and now we're going

00:38:20.619 --> 00:38:25.969
to load the stream information for
this hierarchy that we're watching.

00:38:25.969 --> 00:38:30.559
And again, this is a simple program,
so we load, we save and load state.

00:38:30.559 --> 00:38:33.849
It only knows about watching a single hierarchy.

00:38:33.849 --> 00:38:40.179
So that will get a UUID that was stored
and then we check if they're equal.

00:38:40.179 --> 00:38:50.419
So, if CFEqual(uuid_ref) with what the settings is, the current
UUID and the uuid_ref is the one that we have stored.

00:38:50.420 --> 00:38:54.220
If they match, well, then we can go
and load our previously saved state

00:38:54.219 --> 00:38:58.559
and we have this utility function,
load_dir_items and it loads it up.

00:38:58.559 --> 00:39:04.230
If they mismatch, then we will get rid
of the stored history and do a full rescan.

00:39:04.230 --> 00:39:12.190
For example, one way I can force that, I'll
stop this program and it will save its state

00:39:12.190 --> 00:39:18.309
if I just change this to something that won't match.

00:39:18.309 --> 00:39:22.710
Now when I run the Watcher program
again it is going to complain.

00:39:22.710 --> 00:39:26.210
There's a UUID mismatch, because what
was stored doesn't match what's currently

00:39:26.210 --> 00:39:29.710
out there and so it goes and does a full rescan.

00:39:29.710 --> 00:39:32.730
Just to show you that code really works.

00:39:32.730 --> 00:39:35.039
We go and create a cfarray from the path.

00:39:35.039 --> 00:39:36.909
In this case we are only watching a single path

00:39:36.909 --> 00:39:42.849
so it's pretty straight forward and
now here is the real meat of things.

00:39:42.849 --> 00:39:47.069
Even though I have a dev_t, I was going
to go do a more complicated example,

00:39:47.070 --> 00:39:49.090
but as it is I'm going to run out of time already.

00:39:49.090 --> 00:39:59.500
So, we just call the plain FSEventStreamCreate, we pass
it our callback, the array of paths, since_when parameter,

00:39:59.500 --> 00:40:06.059
which is the last event ID that we stored
or the symbolic constant since now.

00:40:06.059 --> 00:40:09.409
kFSEventStream event ID since now.

00:40:09.409 --> 00:40:11.079
I forget the exact name.

00:40:11.079 --> 00:40:16.730
The latency and we're not going to pass any
particular flags, although we could pass WatchRoot.

00:40:16.730 --> 00:40:21.389
Once that comes back, if we got a stream_ref

00:40:21.389 --> 00:40:26.359
we schedule it on a run loop and then we start it.

00:40:26.360 --> 00:40:30.400
Then if we need an initial scan, we go through and do that.

00:40:30.400 --> 00:40:33.269
Otherwise we just fall into the standard CFRunLoop.

00:40:33.269 --> 00:40:39.920
Now one thing that's important to point out here is
that we start the stream before we do the initial scan

00:40:39.920 --> 00:40:48.000
and the reason that's an important point is that if you were
to go and do your initial scan and then start the stream,

00:40:48.000 --> 00:40:50.599
events could happen in between that you would miss.

00:40:50.599 --> 00:40:55.699
So you always want to be aware of the
ordering of these kinds of operations.

00:40:55.699 --> 00:41:00.339
Don't generate your state before you are going to
be receiving events, because things could change

00:41:00.340 --> 00:41:06.130
and then you do not have any way to know that your
"initial state" is actually already out of date.

00:41:06.130 --> 00:41:14.579
So, once we call CFRunLoopRun(), then all
control really comes through the callback function

00:41:14.579 --> 00:41:21.869
and the callback function right here, as I said, gets these
three arrays, the event paths, the flags, and the eventIDs,

00:41:21.869 --> 00:41:26.759
and as you might expect it just simply loops through them.

00:41:26.760 --> 00:41:33.620
Make a copy of the path so that we can monkey around
with it if we want and then we look at the flags.

00:41:33.619 --> 00:41:42.019
Like I said, it is very important that you do check for
things like dropped events, the MustScanSubDirs flags.

00:41:42.019 --> 00:41:47.230
So the first thing is the HistoryDone event,
which if we get, as I said, that's a fake event,

00:41:47.230 --> 00:41:50.990
we just say we are done processing
historical events continue onward.

00:41:50.989 --> 00:41:56.849
If you were watching the root and the root
changed, then what we do is we say we stat it.

00:41:56.849 --> 00:42:02.059
If it exists, well then we know we're back in
business and we can watch the hierarchy again.

00:42:02.059 --> 00:42:05.739
If the stat fails, then we need to disregard all our state

00:42:05.739 --> 00:42:09.219
because the hierarchy that we were
watching no longer exists.

00:42:09.219 --> 00:42:17.000
Now, in the case that the MustScanSubDirs
flag is set, then we set the recursive variable

00:42:17.000 --> 00:42:25.250
and informationally we print these other things and
if recursive is set then we, for that given path,

00:42:25.250 --> 00:42:26.869
we go ahead and scan it.

00:42:26.869 --> 00:42:32.579
If it's not set, the check_children_of_dir function
will just iterate at that level in the hierarchy.

00:42:32.579 --> 00:42:36.039
It doesn't go down, it doesn't
have to descend into any deeper,

00:42:36.039 --> 00:42:39.230
it just looks at that one level
and finds out what has changed.

00:42:39.230 --> 00:42:41.849
And then, of course, we print out what the total size is.

00:42:41.849 --> 00:42:50.619
Like I said, this is a pretty simple example that
once the callback drive updates and you know,

00:42:50.619 --> 00:42:55.440
these work functions actually do a
fair bit to go and recalculate the size,

00:42:55.440 --> 00:42:59.440
they have to iterate the directory,
but it's not terribly exciting stuff.

00:42:59.440 --> 00:43:01.519
So that's the main way it works.

00:43:01.519 --> 00:43:17.179
Now, if I, again, if something happens in the
hierarchy, let's see, then see the size changes.

00:43:17.179 --> 00:43:22.799
If something happens while we are offline, now
I'll actually go ahead and get rid of a whole bunch

00:43:22.800 --> 00:43:28.560
of stuff here, let's go and erase this whole hierarchy.

00:43:28.559 --> 00:43:35.199
Now as you notice the hierarchy, this program, the Watcher
program is not actually running, but if I rerun it,

00:43:35.199 --> 00:43:38.619
it processes the historical events that happened.

00:43:38.619 --> 00:43:43.710
I had erased that Documents directory
and I had erased a file in there

00:43:43.710 --> 00:43:48.340
and that updates its size as opposed
to having to rescan the entire thing.

00:43:48.340 --> 00:43:51.740
So let's switch back to the slides.

00:43:53.710 --> 00:43:57.500
That was the Watcher sample code.

00:43:57.500 --> 00:44:00.320
Now it's pretty basic FSEventsStream usage.

00:44:00.320 --> 00:44:06.470
You saw how we created an initial state
after we had created and started the stream

00:44:06.469 --> 00:44:14.059
and then it lets the callback just naturally
drive updates to, to the internal state.

00:44:14.059 --> 00:44:19.150
Now a few things you definitely have to,
I don't want to sound like a broken record,

00:44:19.150 --> 00:44:21.389
you have to look at the flags for an event.

00:44:21.389 --> 00:44:25.909
Drop events maybe rare, but they can
happen and when they do happen you need

00:44:25.909 --> 00:44:31.799
to do the rescan from the path that it tells you to.

00:44:31.800 --> 00:44:37.440
Again, it's typical to make this happen in practice, but
make sure the code is there and that you at least test it.

00:44:37.440 --> 00:44:42.329
You start at the specific directory
and scan down from there.

00:44:42.329 --> 00:44:49.170
Normally you just scan that level and you don't descend,
but it MustScanSubDir as a set and you have to go down.

00:44:49.170 --> 00:44:53.720
Token events, this is not something,
with the HistoryDone event,

00:44:53.719 --> 00:44:57.269
it's not as necessary, but token
events can sometimes be handy.

00:44:57.269 --> 00:45:03.389
It's a way or technique where you can sort of
bracket a set of other file system operations.

00:45:03.389 --> 00:45:15.909
So let's say you create a directory called, /tmp/
starting operation and you create a file inside of there.

00:45:15.909 --> 00:45:21.809
Now when you go into a whole bunch of other stuff and then
you go and delete it, you're application will get events

00:45:21.809 --> 00:45:29.679
in /tmp/starting operations directory and when
it sees that that file has been deleted in there,

00:45:29.679 --> 00:45:31.869
it knows the other operations are complete.

00:45:31.869 --> 00:45:39.670
So it's a way to kind of bracket a
more complex set of operations.

00:45:39.670 --> 00:45:45.420
As I said, be careful leaving windows open when you generate
your initial state, you should make sure you're going

00:45:45.420 --> 00:45:50.059
to be beginning the events that correspond
to that so that you're not out of date.

00:45:50.059 --> 00:45:55.179
And, of course, symlinks and hardlinks are an issue as well.

00:45:55.179 --> 00:45:58.029
Now, Advanced FSEvents topics.

00:45:58.030 --> 00:46:04.350
Not that advanced, but it's sort of not the standard
stuff that you have to necessarily worry about.

00:46:04.349 --> 00:46:06.110
We're going to cover a couple things.

00:46:06.110 --> 00:46:10.019
I'm starting to run low on time so maybe rush a little bit.

00:46:10.019 --> 00:46:13.759
Working with the event history a
little bit more, the WatchRoot flag.

00:46:13.760 --> 00:46:18.860
How the different ways that you can
use that, mount and unmount events

00:46:18.860 --> 00:46:26.970
and some additional stream operations
that maybe useful to you

00:46:26.969 --> 00:46:31.159
As I said, there is a way to get the
approximate event ID corresponding

00:46:31.159 --> 00:46:34.000
to a wall-clock time and that one is a mouthful.

00:46:34.000 --> 00:46:37.719
FSEventsGetLastEventIdForDeviceBeforeTime()

00:46:37.719 --> 00:46:40.500
It's like the documentation
is built into the function name.

00:46:40.500 --> 00:46:47.849
It's not exact, but it will give you
an approximate event ID so you can say,

00:46:47.849 --> 00:46:53.440
well, what happened since last Tuesday
and at, let's say at noon.

00:46:53.440 --> 00:46:59.110
You'll get an event ID that will be
approximately at least that time.

00:46:59.110 --> 00:47:03.980
You can purge events with
FSEventsPurgeEventsForDeviceUpToEventId().

00:47:03.980 --> 00:47:08.309
Again this is the way you can clear out the history.

00:47:08.309 --> 00:47:21.279
This is useful perhaps in hand with or corresponding
to the GetEventIdBeforeDeviceTime function.

00:47:21.280 --> 00:47:27.890
You can pass events ID since now and that will
purge everything that basically cleans it out

00:47:27.889 --> 00:47:33.900
and will reset the device UUID or the event stream UUID.

00:47:33.900 --> 00:47:35.740
As with a lot of things that I do with Apple.

00:47:35.739 --> 00:47:37.659
Everybody just wants to disable it.

00:47:37.659 --> 00:47:39.849
I worked on Spotlight too.

00:47:39.849 --> 00:47:45.519
So there is a way to do this, I understand the need for it,

00:47:45.519 --> 00:47:50.400
so you have /Volumes/VOLNAME/.fseventsd, that's where the logs are stored.

00:47:50.400 --> 00:47:57.150
If you put the file no_log then the no_logs will ever
be written to that device and so you don't have to worry

00:47:57.150 --> 00:48:01.170
about stuff persisting when you don't want it to.

00:48:02.409 --> 00:48:04.179
Now the WatchRoot flag.

00:48:04.179 --> 00:48:07.969
This allows you to track changes to
the top level that you're watching.

00:48:07.969 --> 00:48:15.169
An example that came up internally was the
console lap wanted to watch /library logs

00:48:15.170 --> 00:48:21.990
and whenever library logs got erased it wanted to blow away
it's internal state and any internal logs that it may

00:48:21.989 --> 00:48:27.339
of cached in memory and reset that
and so this is a way that it can do that.

00:48:27.340 --> 00:48:31.070
When any component of the path changes you'll get an event.

00:48:31.070 --> 00:48:34.140
So the tracking is path based.

00:48:34.139 --> 00:48:40.650
As I said, we're looking at strings and we're doing
directory prefix matching, so if for example, you wanted

00:48:40.650 --> 00:48:47.000
to watch, lets say /Users foo /MyDocuments/blah

00:48:47.000 --> 00:48:53.929
and then rename my documents just be
documents, you would no longer get events.

00:48:53.929 --> 00:48:57.809
Now if you have the WatchRoot flag
you'll find out, well that path you asked

00:48:57.809 --> 00:49:00.469
to watch it doesn't actually exist any more.

00:49:00.469 --> 00:49:04.909
So this is kind of useful in a number of situations.

00:49:04.909 --> 00:49:07.589
If you want to follow a directory if it moves.

00:49:07.590 --> 00:49:13.680
What you should do is open up the file descriptor,
open a file descriptor on the root of that hierarchy

00:49:13.679 --> 00:49:20.379
and then when you get a root changed event you would
find out where it moved to by calling the F_GETPATH

00:49:20.380 --> 00:49:25.579
on that file descriptor
that you have open and that will sort

00:49:25.579 --> 00:49:28.539
of track it wherever it moves in the hierarchy.

00:49:28.539 --> 00:49:34.610
That's kind of very sticky, that may or may not be,
you have to understand the implications of that kind

00:49:34.610 --> 00:49:38.480
of behavior if that's exactly what the user wants.

00:49:38.480 --> 00:49:45.219
In that case you would create a new stream for the new path
and rescan it, or as I said, in the case of console log,

00:49:45.219 --> 00:49:53.759
you can just reset your internal state when the root
moves and then wait for it to come into existence again.

00:49:53.760 --> 00:50:01.590
As we saw in the Watcher example app, if you discard your
internal state when the directory hierarchy goes away

00:50:01.590 --> 00:50:04.570
and then recreate it when it comes back into existence,

00:50:04.570 --> 00:50:07.670
you're all set.

00:50:07.670 --> 00:50:12.320
Now, you also have to be a little bit careful
when you use it with device-specific streams.

00:50:12.320 --> 00:50:17.039
It's best if your current working directory is
the root of the hierarchy that you are watching.

00:50:17.039 --> 00:50:20.090
The monitoring happens client side.

00:50:20.090 --> 00:50:23.079
This is an important, it's an implementation detail,

00:50:23.079 --> 00:50:28.489
but it's relevant because there are open files
descriptors on that volume in that process.

00:50:28.489 --> 00:50:34.000
So that would mean that if you were watching
something on a removable volume and you're not part

00:50:34.000 --> 00:50:39.170
of the DiskArb framework or you're not participating
with DiskArb that volume will not be able

00:50:39.170 --> 00:50:41.360
to be unmounted while you your application was running.

00:50:41.360 --> 00:50:47.220
So just keep that in mind if you use the WatchRoot flag.

00:50:47.219 --> 00:50:49.619
Now, mount and unmount events.

00:50:49.619 --> 00:50:52.480
It's definitely not a replacement for the DiskArb framework.

00:50:52.480 --> 00:50:57.050
It's more informational if you're
using device relative stream.

00:50:57.050 --> 00:51:02.330
You, it's useful to know, well
that device isn't there anymore.

00:51:02.329 --> 00:51:08.610
And so the unmounted event comes after the volume is
completely gone, where as with DiskArb you have a chance

00:51:08.610 --> 00:51:12.960
to clean up your act and get everything
closed so the volume can be unmounted

00:51:12.960 --> 00:51:19.400
and DiskArb is just a more sophisticated
way to know about volume coming and going.

00:51:19.400 --> 00:51:27.690
But if you are just watching stuff kind of more,
in an observant fashion as opposed to, you know,

00:51:27.690 --> 00:51:35.090
having open files on the volume then use it, seeing that
the unmounted comes through, well there's no point watching

00:51:35.090 --> 00:51:37.610
that stream anymore because it
ain't there so let's get rid of it.

00:51:37.610 --> 00:51:44.140
The unmounted events are important also,
because device IDs can be recycled.

00:51:44.139 --> 00:51:53.469
So if I have external FireWire drive A and it
has let's say device ID 1,000 it gets unplugged

00:51:53.469 --> 00:51:55.509
and unmounted when it comes through.

00:51:55.510 --> 00:52:01.990
Now a new device comes in FireWire drive
B that would get the same device ID.

00:52:01.989 --> 00:52:06.619
So you need to be careful that you
are not burned by recycle device IDs.

00:52:06.619 --> 00:52:12.029
When you get an unmount event close down the stream.

00:52:12.030 --> 00:52:13.800
There's a way to get the latest event ID.

00:52:13.800 --> 00:52:19.240
This is, of course, useful if you want to
just record what's the last event ID in the system.

00:52:19.239 --> 00:52:22.579
FSEventStreamGetLatestEventId()

00:52:22.579 --> 00:52:29.900
That's for a particular stream or FSEventsGetCurrentEventI()
that's the greatest event ID in the entire system.

00:52:29.900 --> 00:52:35.180
So notice the distinction, one is for a particular stream
that's the last event ID that has come through on

00:52:35.179 --> 00:52:39.329
that stream which may not be the
most current event ID in the system

00:52:39.329 --> 00:52:45.090
or GetCurrentEventID is the most
current event that exists in the system.

00:52:45.090 --> 00:52:52.470
There's some flushing functions, which pretty much
you would really only want to use the FlushSync version,

00:52:52.469 --> 00:52:56.969
but this will ask the server to send any pending events.

00:52:56.969 --> 00:53:02.459
So if you were in the process of shutting down, it is
possible that some events were, you know, queued up,

00:53:02.460 --> 00:53:05.610
because you have very long latency
and they haven't been sent yet.

00:53:05.610 --> 00:53:08.289
This will cause them to come through, so that you make sure

00:53:08.289 --> 00:53:12.730
that when your app shuts down
you've seen all the latest stuff.

00:53:12.730 --> 00:53:18.019
Again, generating sentinel events that allows
you to make sure you didn't miss anything.

00:53:18.019 --> 00:53:26.030
So you can sort of have an event stream watching some
hierarchy create something and then look for that coming

00:53:26.030 --> 00:53:31.350
through in the event stream to know that
something is started or that has finished.

00:53:31.349 --> 00:53:37.630
So, well, I actually rushed through it and I'm going
to finish a few minutes early, but wrapping up.

00:53:37.630 --> 00:53:39.559
The FSEvents.framework, what is it?

00:53:39.559 --> 00:53:44.210
It's an event-driven mechanism to find
out about changes to the file system.

00:53:44.210 --> 00:53:46.240
So there's no more polling.

00:53:46.239 --> 00:53:56.079
This is an important thing as we move into new devices where
battery usage and hard drive energy usage is important.

00:53:56.079 --> 00:53:59.670
You don't want to do large rescans if you can avoid it.

00:53:59.670 --> 00:54:03.630
It gives you a full history, so your application
doesn't have to be running all the time.

00:54:03.630 --> 00:54:05.820
You can say what happened since the last time I ran.

00:54:05.820 --> 00:54:11.950
Last time I ran was last Tuesday or more
specifically event ID one billion whatever

00:54:11.949 --> 00:54:17.049
and you'll get everything that has happened since then.

00:54:17.050 --> 00:54:20.780
The FSEvents.framework enables things
like Time Machine and FileSync.

00:54:20.780 --> 00:54:27.870
Again no more full rescans that enables them to operate
very efficiently, internally we've even experimented

00:54:27.869 --> 00:54:32.469
with doing things where you have continuous
backup, which is every couple of minutes,

00:54:32.469 --> 00:54:37.769
because you don't have to do full rescans of
the entire home directory to find what changed.

00:54:37.769 --> 00:54:42.269
Of course, you have the Finder and
its live monitoring and things.

00:54:42.269 --> 00:54:44.440
And then there's the unknown.

00:54:44.440 --> 00:54:45.240
There's you guys.

00:54:45.239 --> 00:54:46.579
How will you use it?

00:54:46.579 --> 00:54:49.000
I actually expect to be surprised.

00:54:49.000 --> 00:54:54.920
A lot of times things, people find creative uses, that's
what we are hoping to see with the FSEvents.framework.
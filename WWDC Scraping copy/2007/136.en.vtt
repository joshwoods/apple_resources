WEBVTT

00:00:20.289 --> 00:00:27.960
>> Hello and welcome to Session 136,
Modernizing Your Text Rendering With Core Text.

00:00:27.960 --> 00:00:30.440
Thanks for coming.

00:00:30.440 --> 00:00:38.480
I'm sure a lot of you are coming from the Quick
Draw and ATSUI stance of dealing with Unicode text

00:00:38.479 --> 00:00:42.479
and non Unicode text, so hopefully
this session will help you

00:00:42.479 --> 00:00:51.390
out in your development moves as we go forward on Leopard.

00:00:51.390 --> 00:01:00.259
The main things we'll be talking about here in this
session is Quick Draw text and ATSUI and how they compare

00:01:00.259 --> 00:01:07.280
to our newest member of the Mac
OS X text handling API, Core Text.

00:01:07.280 --> 00:01:11.920
And I hope by the end of this session
you'll have even more reasons

00:01:11.920 --> 00:01:17.719
of why you'd want to make the switch to using Core Text.

00:01:17.719 --> 00:01:25.429
So what I'll be covering is first a
brief tour of the Leopard text system.

00:01:25.430 --> 00:01:33.570
And some of the major changes within the
system as it pertains to Core Text usage.

00:01:33.569 --> 00:01:40.969
And then throughout the talk I'll be of course
discussing Unicode, because of course Core Text and Cocoa,

00:01:40.969 --> 00:01:44.200
for that matter, is based on Unicode Text.

00:01:44.200 --> 00:01:54.420
And just to drive home the importance of Unicode, it's
throughout the entire text world, including Core Text.

00:01:54.420 --> 00:02:01.579
So with that I'd also be talking about the main
points, which is Quick Draw text and ATSUI.

00:02:01.579 --> 00:02:11.810
In particular, I'm going to touch on some string
input and storage methods and calls you can make

00:02:11.810 --> 00:02:18.659
and string conversions that I'm sure some of you
would need to be making from your older applications

00:02:18.659 --> 00:02:27.759
into our modern string packages, in particular
CF string into CF attributed string packages.

00:02:27.759 --> 00:02:29.959
And then font references.

00:02:29.960 --> 00:02:35.390
A lot of you have expressed confusion
over all of our font references.

00:02:35.389 --> 00:02:44.759
We have a slew of them and Core Text is actually adding
two more, the CT font ref and the CT font descriptor ref.

00:02:44.759 --> 00:02:54.530
but with these references, it actually should clean up
how you look at defining your fonts in your application,

00:02:54.530 --> 00:02:59.120
which I'll touch on to later specifically.

00:02:59.120 --> 00:03:07.450
And then measuring line breaking and rendering will
all be looked at as a unit with examples in Quick Draw,

00:03:07.449 --> 00:03:15.359
ATSUI and comparing to Core Text and give you an idea
of the quickest path to updating your application.

00:03:15.360 --> 00:03:21.720
And lastly, I'll touch on the fonts window,
our fonts panel, as some people refer to it.

00:03:21.719 --> 00:03:27.120
This was also covered in the Core
Text talk earlier this morning.

00:03:27.120 --> 00:03:35.819
There's a great example application that I
really want to advocate you taking a look at.

00:03:35.819 --> 00:03:38.009
Some great stuff in there.

00:03:38.009 --> 00:03:48.429
Something, a particular note in this regard is handling
the fonts window and how easy it is now using Core Text.

00:03:48.430 --> 00:03:50.099
So what's new in text?

00:03:50.099 --> 00:03:54.159
Core Text, but actually Core Text isn't new.

00:03:54.159 --> 00:04:02.289
It's in Tiger, but used under the
covers pretty much all by App Kit.

00:04:02.289 --> 00:04:13.299
It was created specifically for App Kit at that time to
give it an alternative to its core layout needs to ATSUI.

00:04:13.300 --> 00:04:15.530
Now why would you want to move off ATSUI?

00:04:15.530 --> 00:04:17.550
Well, we'll touch on that later.

00:04:17.550 --> 00:04:25.650
One of the main reasons was ATSUI started getting stuck
in the mud in terms of progressing its functionality

00:04:25.649 --> 00:04:34.479
and it's performance was reaching an asymptotic
point at which it could just not get any more fast.

00:04:34.480 --> 00:04:42.450
So it's a proven technology that's Unicode based, of
course, like all of our new APIs for text handling.

00:04:42.449 --> 00:04:46.279
And it's built as a Core Foundation object.

00:04:46.279 --> 00:04:53.829
So you get all the benefits of handling a Core
Foundation object, such as the retain and releases

00:04:53.829 --> 00:04:58.589
and full thread safety that you'd
expect from Core Foundation.

00:04:58.589 --> 00:05:06.689
And it's also built with solid Quartz and Cocoa
integration, unlike Quick Draw and ATSUI for instance,

00:05:06.689 --> 00:05:18.370
Core Text was built after Mac OS X was released, and
so it's main output, of course, is through Quartz.

00:05:18.370 --> 00:05:32.459
And Cocoa, being our main API that we are advocating
usage of, the reason really is better text handling

00:05:32.459 --> 00:05:40.620
and performance, needed to be integrated with Core Text
in such a way to maintain it's optimal performance.

00:05:40.620 --> 00:05:45.959
So you get exceptionally fast text layout by using Core Text

00:05:45.959 --> 00:05:52.989
that you can't obtain using our
other APIs, especially on Carbon.

00:05:52.990 --> 00:06:01.590
It's very easy to optimize, so unlike ATSUI,
for instance, that gets a little mysterious

00:06:01.589 --> 00:06:07.719
on how you should optimize your output, say should
you keep a style object, should you throw it away,

00:06:07.720 --> 00:06:13.510
should you set an attribute, or what order
are you going to be making these API calls?

00:06:13.509 --> 00:06:18.860
Core Text is a lot more straight forward in
understanding how to make it as fast as possible.

00:06:18.860 --> 00:06:28.319
So with that, it's also simple and intuitive to use
and of course it's 64 bit ready in a Cocoa framework.

00:06:28.319 --> 00:06:33.759
So the main changes in text support in
Leopard that I just wanted list here,

00:06:33.759 --> 00:06:37.889
is that App Kit has made the switch
to Core Text exclusively.

00:06:37.889 --> 00:06:42.490
Before, in Tiger was holding off complete usage of Core Text

00:06:42.490 --> 00:06:47.259
for doing certain things like accent
attachments and what not.

00:06:47.259 --> 00:06:50.769
Now it can use Core Text exclusively.

00:06:50.769 --> 00:06:57.949
It's got the performance obtained by
using Core Text and it's all very happy.

00:06:57.949 --> 00:07:08.349
But not to be left out of the game, HI Toolbox also started
using Core Text for it's static text and its font fallbacks.

00:07:08.350 --> 00:07:13.420
Now once HI Toolbox started using the font
fallbacks, this domino effect started occurring.

00:07:13.420 --> 00:07:18.780
Well hey, now ATSUI looks a little bit
different than what HI Toolbox is putting out,

00:07:18.779 --> 00:07:24.609
so we have now ATSUI using Core
Text for it's font fallbacks.

00:07:24.610 --> 00:07:29.050
Now what's so great about these font
fallbacks that we felt a need to switch?

00:07:29.050 --> 00:07:36.629
And the reasons is because now the font fallbacks more
closely match what your original font you assigned

00:07:36.629 --> 00:07:43.839
to your text is, so it matches traits such as serifs
and stuff like that and whether it's bold or not,

00:07:43.839 --> 00:07:48.609
more accurately so you get a more
seamless appearance across your line.

00:07:48.610 --> 00:07:54.870
This is really a great thing and if you've
been frustrated with font fallbacks before,

00:07:54.870 --> 00:08:02.660
trying to adjust them to your own needs, just to get
around this little inconsistency, or big inconsistency,

00:08:02.660 --> 00:08:11.830
depending on where you're coming from, I think you'll really
enjoy the new font fallback scheme introduced by Core Text.

00:08:11.829 --> 00:08:14.709
So this is the Leopard text system in the nut shell.

00:08:14.709 --> 00:08:19.769
Over in the big green box is the Carbon text side of things.

00:08:19.769 --> 00:08:25.529
MLET is still calling into ATSUI for it's text editing.

00:08:25.529 --> 00:08:32.740
And then there's Quick Draw text of course, calling
into ATS to get it's curves and bitmaps and stuff.

00:08:32.740 --> 00:08:38.649
ATSUI now though in Leopard is calling into Core
Text, as I mentioned, for it's font fallbacks.

00:08:38.649 --> 00:08:43.159
There's also a few other things it's
calling into, but more and more it's moving

00:08:43.159 --> 00:08:46.909
over to rely on Core Text for it's basic needs.

00:08:46.909 --> 00:08:51.740
And of course Cocoa, as I mentioned, is now
using Core Text for all it's layout needs.

00:08:51.740 --> 00:08:57.490
But I'm sure doing a lot of other
work besides that for text rendering,

00:08:57.490 --> 00:09:03.360
but for it's main layout engine it's using Core Text.

00:09:03.360 --> 00:09:08.350
And I just wanted to list here our
current font references on Leopard.

00:09:08.350 --> 00:09:14.100
A lot of you are familiar with the classic
references, of course, the ATSUI font, the FM font,

00:09:14.100 --> 00:09:18.550
font family, and ATS font family references.

00:09:18.549 --> 00:09:25.019
These were all great in their day, but as time moved
on we had to keep on adding references in order

00:09:25.019 --> 00:09:31.829
to address the technology shift in fonts
that I'm sure all of you are aware of.

00:09:31.830 --> 00:09:38.129
Fonts are getting increasingly complicated
and sophisticated and I think that's great.

00:09:38.129 --> 00:09:47.679
I mean, text has never had such a boom in usage
these days, so I'm really looking forward to moving

00:09:47.679 --> 00:09:55.729
on to the modern APIs and modern font references that
can be found from the NS font in NS font descriptor.

00:09:55.730 --> 00:10:01.330
The great thing about Core Font descriptors is that
they're toll free bridgeable with the NS equivalent.

00:10:01.330 --> 00:10:06.000
So you can go ahead and interchange
these within the API calls.

00:10:06.000 --> 00:10:15.220
That's really a boom and I think you'll get a
kick out of being able to swap one for the other.

00:10:15.220 --> 00:10:17.320
So let' move on to Quick Draw.

00:10:17.320 --> 00:10:26.480
And for those of you who have never stepped into a Quick
Draw editing session, maybe you can check your emails

00:10:26.480 --> 00:10:34.210
or whatever, but keep an ear open, maybe we can touch
on something that you can look into further later.

00:10:34.210 --> 00:10:37.139
First, I should say, Quick Draw is dead.

00:10:37.139 --> 00:10:38.830
I'll say that right now.

00:10:38.830 --> 00:10:43.730
This is probably the last time you'll
even hear about Quick Draw at a WWDC.

00:10:43.730 --> 00:10:47.810
So in that sense, you're sitting in
on some history right here at WWDC.

00:10:47.809 --> 00:10:53.500
Quick Draw really had an amazing run.

00:10:53.500 --> 00:11:02.919
It served an incredible amount of developers and it
was the only way to draw and render text on the system.

00:11:02.919 --> 00:11:09.979
It's been in use just way longer than we ever though
possible, only because it was worked on so well

00:11:09.980 --> 00:11:14.899
by all our engineers keeping it alive through these years.

00:11:14.899 --> 00:11:25.829
But support is diminishing now and it is deprecated, by
the way, so it's really time to move on to something else.

00:11:25.830 --> 00:11:31.160
And something else, I'm happy to say, is Core Text.

00:11:31.159 --> 00:11:34.919
Because in the older days, really
international text was a hag.

00:11:34.919 --> 00:11:42.360
If you can remember when Quick Draw needed to
now introduce what's called World Script in order

00:11:42.360 --> 00:11:47.300
to do the more complex scripts, we kept
on hacking on to Quick Draw in order

00:11:47.299 --> 00:11:50.969
to make it handle more and more complex situations.

00:11:50.970 --> 00:12:00.090
So now with the introduction of Unicode, as we'll talk
about later, we can get away from all these hacks.

00:12:00.090 --> 00:12:07.389
So let me list some of the reasons why you'd want to change
from Quick Draw, if you aren't convinced at this point.

00:12:07.389 --> 00:12:13.319
First of all, Quick Draw is deprecated and with
any deprecated API there are dangers to using it.

00:12:13.320 --> 00:12:22.710
I'm not saying it's going to be pulled out from under you,
but any further development, don't expect any new APIs

00:12:22.710 --> 00:12:28.650
to come out of Quick Draw and some bugs will
probably remain forever in Quick Draw now.

00:12:28.649 --> 00:12:36.519
Not because we just hate Quick Draw developers, but
because now developers are depending on those bugs.

00:12:36.519 --> 00:12:42.189
They built around them, if you change
them, you've really screwed these people.

00:12:42.190 --> 00:12:46.450
So we're very cognoscente about that.

00:12:46.450 --> 00:12:55.540
So by at least deprecating it it has signaled that it's
days are definitely numbered and you shouldn't use it.

00:12:55.539 --> 00:12:59.370
And the main reason is that it's not Unicode based.

00:12:59.370 --> 00:13:04.289
World Script One, by the way, isn't even
supported in Mac OS X. so don't expect

00:13:04.289 --> 00:13:09.069
to do Arabic rearrangement or anything
like that with Quick Draw.

00:13:09.070 --> 00:13:18.300
It's very much a part of the past and I will emphasize
this over and over again, and add nauseum, I'm sure,

00:13:18.299 --> 00:13:27.059
but I just want to impress upon you that you can't do
these complex scripts anymore using Quick Draw text.

00:13:27.059 --> 00:13:30.469
Now for instance of some of it's incompatibility

00:13:30.470 --> 00:13:35.399
with the current graphics system is
how it does its sub pixel rendering.

00:13:35.399 --> 00:13:42.329
In fact, it doesn't do sub pixel rendering unless you can
use some of the special attributes that were developed

00:13:42.330 --> 00:13:48.160
to kind of shim it into the Quartz environment.

00:13:48.159 --> 00:13:57.679
So on the left here, this is how Quick Draw would
normally render text, meaning all the glyphs are entered

00:13:57.679 --> 00:14:03.799
on an integer origin basis and so you
might end up with kind of awkward spacing.

00:14:03.799 --> 00:14:11.429
I know you've seen the old picket fence example of a slew
of L's and having some of the L's closer or further apart,

00:14:11.429 --> 00:14:18.729
that's due to the fractional rounding involved
in order to make all the glyphs land on integers.

00:14:18.730 --> 00:14:26.450
And the anti-aliasing itself is much deeper and
richer in a full Quartz rendering system using colors,

00:14:26.450 --> 00:14:32.570
for instance to simulate a fractional
bounds in which to lay your glyphs out.

00:14:32.570 --> 00:14:38.840
And believe it or not, using Quick Draw can
actually bog down the overall system performance.

00:14:38.840 --> 00:14:53.370
Every Quick Draw call calls into FM swap font, and FM swap
font could, by nature of calling to ATS for its information,

00:14:53.370 --> 00:15:00.980
could actually generate a width table generation
that would swap it's caches and what not.

00:15:00.980 --> 00:15:07.830
Now this uses up a lot of cycles, of course, in
the ATS server that other processes are using.

00:15:07.830 --> 00:15:14.220
And it will also slow down your own process in the process.

00:15:14.220 --> 00:15:24.360
So I just want to emphasize that it's not efficient
to use quick draw for this one reason right here.

00:15:24.360 --> 00:15:30.060
And of course it doesn't play well with
the other frameworks, in particular Cocoa.

00:15:30.059 --> 00:15:38.429
Don't expect to make a viable Quick
Draw App using Cocoa objects.

00:15:38.429 --> 00:15:47.349
Now this last reason is kind of near to my heart because
I work and concentrate on the typography on a system,

00:15:47.350 --> 00:15:53.029
and Quick Draw can't access all the advanced
typography features that are now available

00:15:53.029 --> 00:15:58.429
in most fonts, such as ligatures, in a simple case.

00:15:58.429 --> 00:16:08.989
Here, on the Zaphino font that comes on the system, you can
create a single ligatured glyph from the character Zaphino.

00:16:08.990 --> 00:16:16.320
And then I also list a (inaudible) example
here of rearrangements and insertions.

00:16:16.320 --> 00:16:18.500
Now why stay with Quick Draw?

00:16:18.500 --> 00:16:24.750
I really search for reasons why
you'd want to stay with Quick Draw.

00:16:24.750 --> 00:16:32.539
I only came up with one, and that was
your app uses bitmap only NFMT fonts

00:16:32.539 --> 00:16:35.819
and you can't switch from using that particular font.

00:16:35.820 --> 00:16:40.420
It's an app specific thing and you just can't move from it.

00:16:40.419 --> 00:16:44.729
Well, we don't advocate using bitmap only NFMT fonts anyway.

00:16:44.730 --> 00:16:47.920
Those in themselves are deprecated.

00:16:47.919 --> 00:16:54.659
So try not to use those fonts, they're
very limited and clunky looking first off.

00:16:54.659 --> 00:16:59.939
But if you are in a situation where you have to use that,

00:16:59.940 --> 00:17:04.370
that would be a viable reason why you'd
want to stick with your current code base.

00:17:04.369 --> 00:17:10.519
The other reason, of course, is that you're out of
business so it doesn't make any sense to upgrade any way.

00:17:10.519 --> 00:17:11.980
So there's choices.

00:17:11.980 --> 00:17:17.610
Not a lot of choices for you, but there are choices.

00:17:17.609 --> 00:17:21.539
They aren't admittedly pretty, because
when you're dealing with Quick Draw,

00:17:21.539 --> 00:17:27.539
you're in a totally different realm
of how to deal with Unicode text.

00:17:27.539 --> 00:17:34.549
You're on a run basis, you need to keep a lot of things
up in the air in order to do correct international text,

00:17:34.549 --> 00:17:38.359
which I'll touch on to later in the presentation.

00:17:38.359 --> 00:17:43.059
So the ultimate would be to rewrite
your application using Cocoa.

00:17:43.059 --> 00:17:44.200
That's the ultimate.

00:17:44.200 --> 00:17:47.340
And I'm not just saying that as a buzz here.

00:17:47.339 --> 00:17:52.759
I really think that you would be
best served by switching to Cocoa.

00:17:52.759 --> 00:17:58.619
Now you can still use Core Text within your Cocoa
app for any fine adjustments such as what was brought

00:17:58.619 --> 00:18:02.009
up in the Cocoa presentation here, vertical text.

00:18:02.009 --> 00:18:08.049
But I highly advocate you start
adopting Cocoa for your text.

00:18:08.049 --> 00:18:12.009
Now you could just stay in Carbon and use Core Text.

00:18:12.009 --> 00:18:13.940
It's incredibly powerful.

00:18:13.940 --> 00:18:25.049
It can basically do everything that ATSUI can render,
at least, and so you might be perfectly happy staying

00:18:25.049 --> 00:18:28.680
within a Carbon framework and using Core Text.

00:18:28.680 --> 00:18:39.000
And then lastly, at least, keep on using Unicode, or
use Unicode text in your application and use ATSUI.

00:18:39.000 --> 00:18:45.640
And I'll give some instances to why you'd want to use
ATSUI over Core Text, but there's not a whole lot,

00:18:45.640 --> 00:18:50.140
but at least you're using Unicode
text when you're using ATSUI.

00:18:50.140 --> 00:18:58.850
So for those of you that know Unicode like the back
of your hand and everything, this may be rehashed,

00:18:58.849 --> 00:19:04.169
but just let me go over some key points
about Unicode that make it so important

00:19:04.170 --> 00:19:08.960
and make it the standard in the world for text.

00:19:08.960 --> 00:19:13.180
Unicode fonts have greater coverage, much greater coverage.

00:19:13.180 --> 00:19:19.650
So your extender Roman, Greek and Cyrillic
are all within our Core Fonts on the system.

00:19:19.650 --> 00:19:28.690
And CGK text just wouldn't be able to be
addressed in the modern world without Unicode text.

00:19:28.690 --> 00:19:32.820
All the new text APIs on the system use Unicode.

00:19:32.819 --> 00:19:41.539
There's just no other reason to go back to
the old script basis of organizing your text.

00:19:41.539 --> 00:19:50.889
Unicode is an established standard that Mac OS X
uses, so all the new APIs are designed around that.

00:19:50.890 --> 00:19:56.250
If you want the latest and the greatest
moving forward, then Unicode's the way to go.

00:19:56.250 --> 00:20:02.410
And there's nearly 100,000 characters
available in Unicode that's being mapped.

00:20:02.410 --> 00:20:08.650
That's Unicode 5.0 now and 5.1 should
tip it right over 100,000 characters,

00:20:08.650 --> 00:20:12.800
now that's more than just mapping characters, of course.

00:20:12.799 --> 00:20:21.019
Unicode sets the layout rules for each language
within this mapping on how to rearrange,

00:20:21.019 --> 00:20:27.529
how to layout the text correctly and all the properties
assigned to every single character are defined.

00:20:27.529 --> 00:20:36.759
If you don't believe me, just pick up yourself a
good Unicode 5.0 book and get a good work out lifting

00:20:36.759 --> 00:20:38.990
that thing, because it's got everything in is.

00:20:38.990 --> 00:20:48.000
It's really fascinating looking through this book
on all that Unicode has brought together for text.

00:20:48.000 --> 00:20:55.980
And I bring up UTF 16 processing because that
is the main atom that Core Text uses internally.

00:20:55.980 --> 00:21:02.319
It's a 2 byte unsigned quantity for
defining the Unicode character code point.

00:21:02.319 --> 00:21:10.569
It's not one to one, like in the Quick Draw days where you'd
expect a single glyph represented from a single character.

00:21:10.569 --> 00:21:15.869
You could end up with many more
characters than you originally put

00:21:15.869 --> 00:21:21.199
on by insertion properties, you'd
actually end up with extra glyphs.

00:21:21.200 --> 00:21:29.170
You could also consolidate your characters into single
glyphs, like I was showing before with the Zaphino example.

00:21:29.170 --> 00:21:36.390
And in this case, I'm combining and E with
an acute accent to an E acute character.

00:21:36.390 --> 00:21:41.530
So don't think one to one anymore in a Quick Draw space.

00:21:41.529 --> 00:21:44.980
I know a lot of you have already
moved off of thinking that way.

00:21:44.980 --> 00:21:51.670
I just want to drill that point through
because it still trips a few people up

00:21:51.670 --> 00:21:55.140
Now text input, you've got choices on that front too.

00:21:55.140 --> 00:22:00.650
And from the Carbon viewpoint you have the
HI text view, the MLTE for text editing.

00:22:00.650 --> 00:22:10.620
And on the Cocoa side you have the NS text view
NS text field for equivalent editing ability.

00:22:10.619 --> 00:22:18.169
And then from the static text frame of usage, you
have the resourced, the nib files for instance,

00:22:18.170 --> 00:22:24.390
for the views and controls, and the strings file.

00:22:24.390 --> 00:22:26.360
Excuse me.

00:22:26.359 --> 00:22:35.509
That is the ultimate way to localize your
application and so all those, of course,

00:22:35.509 --> 00:22:41.480
are available to you for text input to Core Text.

00:22:41.480 --> 00:22:50.099
Now I wanted to list here also how you would
package this text and the sanctioned way to do

00:22:50.099 --> 00:22:57.379
that is using the CF string, but Core
Text eats CF contributed strings.

00:22:57.380 --> 00:23:04.420
If you made it to the morning talk on Core
Text, it showed how to create your frameset

00:23:04.420 --> 00:23:07.620
and all of that using your CF attributed strings.

00:23:07.619 --> 00:23:17.149
But from a Quick Draw standpoint, you've got probably old
strings built with Pasquel and C that you need to convert

00:23:17.150 --> 00:23:22.170
to a CF string and there are APIs
available for you to do that.

00:23:22.170 --> 00:23:31.750
The first one I list here is just taking straight Unicare,
the two byte unsigned quantity for Unicode and pumping it

00:23:31.750 --> 00:23:34.569
through the call CF string create with characters.

00:23:34.569 --> 00:23:40.230
You get your CF string from that, but
now creating a CF dictionary along

00:23:40.230 --> 00:23:48.250
with that CF string you could create a CF attributed
string and this is very powerful and really exciting to use

00:23:48.250 --> 00:23:58.650
because now you've got a complete picture of the text
and how you want it drawn all in one complete CF package.

00:23:58.650 --> 00:24:02.790
And lastly here, I wanted to point out the calls,

00:24:02.789 --> 00:24:07.710
the CF string create with C string
and Pasquel's string and with bytes.

00:24:07.710 --> 00:24:14.049
The with bytes is the most general
translation string call you can call.

00:24:14.049 --> 00:24:24.519
You can define whether you want byte swapping or the byte
order mark looked at, and lots of options to use in that.

00:24:24.519 --> 00:24:31.059
So you're not limited to UTF 16 with that particular call.

00:24:31.059 --> 00:24:38.879
So I wanted to give an example of converting an
old Pasquel string to a CF attributed string.

00:24:38.880 --> 00:24:41.850
It's really not as daunting that you may think.

00:24:41.849 --> 00:24:49.359
You just need to bear in mind that in the
old Pasquel world and in older Mac documents,

00:24:49.359 --> 00:24:56.829
you need to keep track of the encoding, such as Mac
encode, Mac Roman encoding, Mac Japanese, for instance.

00:24:56.829 --> 00:25:04.819
Most of the time you already know what the encoding is and
there's a few APIs out there that would give you hints,

00:25:04.819 --> 00:25:08.250
at least, in the case that you
don't know what the encoding is.

00:25:08.250 --> 00:25:16.430
The CF string get system encoding and get application
text encoding from an application centered point,

00:25:16.430 --> 00:25:23.900
they can give you hints and many times it might be
wrong, but for the most part it would give you hints

00:25:23.900 --> 00:25:28.170
as to what encoding your text is originally in.

00:25:28.170 --> 00:25:36.070
so as an example, let's say you've got a Pasquel string
here, hello world, I put it in the CF string create

00:25:36.069 --> 00:25:43.369
with Pasquel string conversion call, and since I
already know what the encoding is, Mac Roman encoding,

00:25:43.369 --> 00:25:49.179
I put that in the call here and create my CF string.

00:25:49.180 --> 00:25:55.830
Now if I create a dictionary with just one element
in it, the CT font, for instance, with the new key,

00:25:55.829 --> 00:26:02.019
CT font attribute name and combine this dictionary

00:26:02.019 --> 00:26:06.539
with the CF string I just created, I
can create a CF contributed string.

00:26:06.539 --> 00:26:09.779
It's really that simple, just two quantities.

00:26:09.779 --> 00:26:13.700
Bam, you got it.

00:26:13.700 --> 00:26:20.710
Now the other element to Quick Draw that is front
and foremost to a lot of people are graph ports.

00:26:20.710 --> 00:26:23.450
You don't need to use graph ports any more.

00:26:23.450 --> 00:26:28.720
In a sense they're deprecated along with Quick Draw.

00:26:28.720 --> 00:26:36.390
So the ideal way, at least on the Carbon side,
to get your graph port is from an HI View event.

00:26:36.390 --> 00:26:41.259
The K event control event, for instance, would be an event

00:26:41.259 --> 00:26:47.269
that you would call back on in
which to draw items on your frame.

00:26:47.269 --> 00:26:58.710
So in this case the K event for MCD context ref is
gleamed in order to get the CG context from the HI View.

00:26:58.710 --> 00:27:04.370
But as was covered in the earlier
talk on Core Text coordinate flipping,

00:27:04.369 --> 00:27:11.569
the coordinate system from HI Views are going
to be flipped, unless you set them up normal,

00:27:11.569 --> 00:27:16.599
as Quartz likes to term it ahead of time.

00:27:16.599 --> 00:27:26.819
But if it is flipped it's very straightforward to flip it
back and draw your text in a right handed coordinate system.

00:27:26.819 --> 00:27:32.319
Now in this case, if you really wanted to do
the translation correctly, you would flip it

00:27:32.319 --> 00:27:35.720
and then move it down by the size of your box.

00:27:35.720 --> 00:27:41.000
But you get the idea that it's very
easy to translate your CG context.

00:27:41.000 --> 00:27:54.259
I wanted to list also a few calls that may not be
equivalent, but at least can reflect on to what you do

00:27:54.259 --> 00:27:57.490
on the Core Text side of things from Quick Draw.

00:27:57.490 --> 00:28:06.930
The FM swap font get F num, text font, text size,
all those calls are basically setting font attributes

00:28:06.930 --> 00:28:11.460
on your current graph port, or getting the family ID.

00:28:11.460 --> 00:28:18.049
The CT font create with Quick Draw instance,
which we'll go over a little bit later,

00:28:18.049 --> 00:28:24.930
can get you a CT font using a font family ID.

00:28:24.930 --> 00:28:28.490
Now the draw string draw text, you've got three choices,

00:28:28.490 --> 00:28:32.529
really three levels on the Core Text
side of things to draw your text.

00:28:32.529 --> 00:28:42.480
You can do it from a frame, which is used in combination
with a bounding area in which you want your text

00:28:42.480 --> 00:28:47.430
to be constrained, or a single line, or even on a run basis.

00:28:47.430 --> 00:28:57.000
Most people don't need to work on a run basis, but if you're
constrained within your app because Quick Draw also worked

00:28:57.000 --> 00:29:05.880
on a run basis, but not really tied, you may
want to gravitate towards that type of drawing.

00:29:05.880 --> 00:29:14.710
But it really is not necessary and you can draw
entire paragraphs using your CT line draw frame.

00:29:14.710 --> 00:29:20.069
The measure justified, string width,
text width, all those calls can be gotten

00:29:20.069 --> 00:29:24.710
from equivalently in the CT line get typographic bounds.

00:29:24.710 --> 00:29:32.650
And the other measured calls, care to pixel, pixel to
care, there are equivalent calls in CT for these too.

00:29:32.650 --> 00:29:41.880
So you could actually walk your string visually, many
of the same things you would do in your Quick Draw app.

00:29:41.880 --> 00:29:49.790
I wanted to give an example next of the old way
of giving your font reference in Quick Draw.

00:29:49.789 --> 00:29:54.119
You would get a Pasquel string
for instance, say in Helvetica

00:29:54.119 --> 00:29:58.309
and put that in the get F num in order to get the family ID.

00:29:58.309 --> 00:30:06.289
Well this is fraught with some inaccuracies because these
are in the days when fonts were one font for one face

00:30:06.289 --> 00:30:10.029
and it was really straight forward to get this family ID.

00:30:10.029 --> 00:30:18.430
Things started getting complicated when the fonts
became true families, with multiple styles and what not,

00:30:18.430 --> 00:30:25.820
and you weren't really guaranteed what you were
getting and thus we came up with more iteraters

00:30:25.819 --> 00:30:28.519
and what not to go through these font families.

00:30:28.519 --> 00:30:35.779
But this was the basic atom of font
reference within Quick Draw at that time.

00:30:35.779 --> 00:30:45.000
So it's very much preferred to create a font
descriptor ref in a CT font using Core Text.

00:30:45.000 --> 00:30:50.990
And the reason is because it's a
complete package and a complete picture

00:30:50.990 --> 00:30:56.420
into which font face you actually want to use.

00:30:56.420 --> 00:31:01.580
So I wanted to give an instance of using
the CT font create with Quick Draw instance.

00:31:01.579 --> 00:31:07.379
Here I'm using the Pasquel string again,
the Helvetica Pasquel string in this call,

00:31:07.380 --> 00:31:11.730
and notice there's parameters for the style and size.

00:31:11.730 --> 00:31:19.519
I didn't need to put the size defaults to 12 anyway,
but you get the idea that the CT font is now tied

00:31:19.519 --> 00:31:27.460
to a specific instance of your font that you
want to use for your text rendering, the size.

00:31:27.460 --> 00:31:32.009
It gets much better than that,
though, which I'll allude to later.

00:31:32.009 --> 00:31:34.849
Now I want to give an alternative.

00:31:34.849 --> 00:31:41.379
This call can actually take a family ID
instead of name and get the CT font that way.

00:31:41.380 --> 00:31:47.540
And lastly you can create a CT font
descriptor and use that in the CT font create

00:31:47.539 --> 00:31:51.960
with font descriptor to get your CT font ref that way, too.

00:31:51.960 --> 00:32:01.370
So there's a lot of ways to get your CT font in the
Quick Draw world, if you may, but the best way is just

00:32:01.369 --> 00:32:04.909
to create your CT font descriptor,
which we'll go into later,

00:32:04.910 --> 00:32:13.090
on the best way of containing all the attributes
that you want attached to that CT font.

00:32:13.089 --> 00:32:20.289
In this particular slide, I wanted to give
an instance of what you were doing, probably,

00:32:20.289 --> 00:32:27.279
maybe not, for complex text drawing in Quick Draw.

00:32:27.279 --> 00:32:32.349
The main point about drawing in Quick
Draw is that it's a run at a time.

00:32:32.349 --> 00:32:37.379
You can't just define a bunch of runs
and then tell something to just draw it.

00:32:37.380 --> 00:32:42.740
You had to draw a run at a time
because every time before a run you had

00:32:42.740 --> 00:32:45.920
to set the font, the style and size and etcetera.

00:32:45.920 --> 00:32:56.990
So that's an important point that is advocated into
using this CT font descriptor within your lines.

00:32:56.990 --> 00:33:03.370
You also needed to use the Script
Manager to determine the display order.

00:33:03.369 --> 00:33:08.399
This isn't really relevant anymore, but Script
Manager and Quick Draw worked hand in hand in order

00:33:08.400 --> 00:33:12.000
to determine run directions and what not.

00:33:12.000 --> 00:33:19.089
And lastly, you needed to keep track of what's called
slot values and save the screen pixel width in order

00:33:19.089 --> 00:33:27.500
to position these runs correctly, especially
for cases of flush and justified text.

00:33:27.500 --> 00:33:35.579
So here's a little, it's much, much simpler than
what you'd actually have to do in Quick Draw in order

00:33:35.579 --> 00:33:44.659
to render complex text, but you'd first need to break the
line, find a good break point, meaning a space character,

00:33:44.660 --> 00:33:54.340
the style of line break will find this offset using
the starting offset and give you a break code.

00:33:54.339 --> 00:34:01.619
And then using the family ID you could find
the script code and then using the script code,

00:34:01.619 --> 00:34:05.059
find out what direction this text is supposed to be going.

00:34:05.059 --> 00:34:13.829
And now know the text direction you could rearrange all
these runs accordingly to get true bidirectional text.

00:34:13.829 --> 00:34:24.019
Again, I really don't think anybody's doing this anymore
because World Script One isn't even supported on the system

00:34:24.019 --> 00:34:28.769
so you wouldn't be able to get
rearranged Arabic in this case.

00:34:28.769 --> 00:34:36.509
Now before you draw, of course, you've got to set the
family ID, the face, and the size and I don't have it here,

00:34:36.510 --> 00:34:41.220
but you'd also have to set the position,
of course, in your current graph port,

00:34:41.219 --> 00:34:45.959
and then after drawing update your offset and loop.

00:34:47.230 --> 00:34:55.199
Now for drawing using Core Text, you have
multiple levels in which to think about your text,

00:34:55.199 --> 00:34:59.759
from a typesetter, frame setter, line or run.

00:34:59.760 --> 00:35:10.680
Each one of these serves a purpose and you may
find different uses for these within your code,

00:35:10.679 --> 00:35:18.139
but always keep in mind that Core Text works with
floating point, so when in doubt use double precision.

00:35:18.139 --> 00:35:21.609
All the matrix and everything are floating point.

00:35:21.610 --> 00:35:31.030
So don't rely on the CG context show text and show
text at point because that doesn't do Unicode layout.

00:35:31.030 --> 00:35:36.060
A lot of people are under the impression
that this would do advanced layout.

00:35:36.059 --> 00:35:36.880
It doesn't.

00:35:36.880 --> 00:35:42.140
This is very low level drawing call for your text.

00:35:42.139 --> 00:35:47.809
We don't suggest using this at all
for any Unicode text in your system.

00:35:47.809 --> 00:35:54.099
You may find these in such open source code as Web Kit.

00:35:54.099 --> 00:36:00.759
But before they're used, there's a huge amount of analysis
going on if you'd take a look in there and that is

00:36:00.760 --> 00:36:05.570
to determine whether it needs to do complex layout or not.

00:36:05.570 --> 00:36:13.059
I have a feeling that as Core Text becomes more
of a standard, well know to the developers,

00:36:13.059 --> 00:36:17.820
that eventually that will just switch
over to use Core Text directly.

00:36:17.820 --> 00:36:23.760
Because the reason it really had to go
through and use this elaborate scheme was

00:36:23.760 --> 00:36:26.340
to get around performance problems in ATSUI.

00:36:26.340 --> 00:36:31.970
That's no longer an issue when you start using Core Text.

00:36:31.969 --> 00:36:41.179
So a Quick example of how fast it is to
render a line of Unicode text using Core Text.

00:36:41.179 --> 00:36:47.480
You would create your line using your
attributed string that we went over before,

00:36:47.480 --> 00:36:53.590
set your position within your CG context and draw.

00:36:53.590 --> 00:36:55.079
It's really that straightforward.

00:36:55.079 --> 00:36:59.019
There's nothing else you need to do.

00:36:59.019 --> 00:37:04.610
Do a CF release on that CT line of
course, because it's a CF object.

00:37:04.610 --> 00:37:05.930
But this is great.

00:37:05.929 --> 00:37:08.219
It's totally thread safe.

00:37:08.219 --> 00:37:12.399
And you can use this within other threads.

00:37:18.469 --> 00:37:20.230
So Quick Draw.

00:37:20.230 --> 00:37:30.130
It's really been real, it's been fun, but it's a convoluted
process to use for any multilingual and multi-style text.

00:37:30.130 --> 00:37:38.990
I'm sure there is huge infrastructures built around
it now and it's served it's purpose in the past,

00:37:38.989 --> 00:37:48.029
but now those results were probably wrong, because now
you're missing some essential elements to your text

00:37:48.030 --> 00:37:52.950
in today's world because it doesn't use Unicode.

00:37:52.949 --> 00:37:59.719
It can't handle the advanced font technology coming out now
and it doesn't work well with the current graphics system.

00:37:59.719 --> 00:38:03.639
And it's certainly not 64 bit clean.

00:38:03.639 --> 00:38:10.859
So with that, I would like to say goodbye Quick Draw text.

00:38:10.860 --> 00:38:13.780
We should have a little tombstone here for it or something.

00:38:13.780 --> 00:38:22.170
But I think that's enough to say that Quick Draw text is
very deprecated and we would love to help you move off

00:38:22.170 --> 00:38:26.159
of Quick Draw text to our modern text system, Core Text.

00:38:26.159 --> 00:38:29.639
So the next topic here is ATSUI.

00:38:29.639 --> 00:38:36.019
Now I don't say this lightly that
I like Core Text better than ATSUI.

00:38:36.019 --> 00:38:43.909
And that says a lot coming from me, because
I pulled my hair out developing ATSUI.

00:38:43.909 --> 00:38:52.299
I really put my heart and soul into it and I wanted to
make it the best Unicode layout and rendering machine ever.

00:38:52.300 --> 00:38:58.780
And it served it's purpose in the pre
Mac OS X days and is going strong still.

00:38:58.780 --> 00:39:03.250
But there's a better thing out
there now, and that's Core Text.

00:39:03.250 --> 00:39:09.769
And I'm really happy to present the difference now for you.

00:39:09.769 --> 00:39:12.349
So ATSUI. It's showing it's age.

00:39:12.349 --> 00:39:15.219
It was actually developed in the Max OS 8 days.

00:39:15.219 --> 00:39:22.659
It was first presented to outside developers in Mac OS 8.5.

00:39:22.659 --> 00:39:30.449
And with that, when Mac OS X came
around, everything changed.

00:39:30.449 --> 00:39:34.899
We had to shoe horn ATSUI into this modern system,

00:39:34.900 --> 00:39:40.900
which meant getting it to render
into your Core Graphics reference.

00:39:40.900 --> 00:39:45.410
What it was doing before, it was
rendering through Quick Draw, actually.

00:39:45.409 --> 00:39:48.159
That's why it lives in the Quick Draw framework.

00:39:48.159 --> 00:39:51.719
But now it had to render into Core Graphics.

00:39:51.719 --> 00:39:58.459
So we added an attribute, as you probably
know, the CG context ref attribute.

00:39:58.460 --> 00:40:05.190
And you can attach that to your ATSUI text
layout object and everything's great, right?

00:40:05.190 --> 00:40:08.570
Mostly. There's some caveats to that.

00:40:08.570 --> 00:40:15.650
Measurements sometimes are not optimal or
correct, depending on when you've defined

00:40:15.650 --> 00:40:18.769
that attribute and when you've laid out the text.

00:40:18.769 --> 00:40:29.059
So there's slight little tweaks in there that really
bug people to no end and I totally sympathize with them.

00:40:29.059 --> 00:40:35.320
But ATSUI's doing the best it can
with where it was coming from.

00:40:35.320 --> 00:40:41.490
So it's got a lot of baggage to keep everything
up in the air and to be backward compatible

00:40:41.489 --> 00:40:44.719
with all those applications that use ATSUI.

00:40:44.719 --> 00:40:49.209
In fact there's bugs in ATSUI that
can't be changed just like Quick Draw,

00:40:49.210 --> 00:40:54.960
because it would screw the developers
who were already using it.

00:40:54.960 --> 00:41:02.199
For instance I just came across a bug for
getting your glyph curves for vertical text.

00:41:02.199 --> 00:41:03.869
It's not rotated.

00:41:03.869 --> 00:41:08.969
But we can't change it at this point,
because everyone's relying on that fact.

00:41:08.969 --> 00:41:14.669
So it's got a lot of baggage and it
lives in Quick Draw where it began.

00:41:14.670 --> 00:41:16.710
It's time to move off of ATSUI.

00:41:16.710 --> 00:41:18.619
It really is.

00:41:18.619 --> 00:41:23.279
So let me list a few reasons why
you'd want to move off of ATSUI.

00:41:23.280 --> 00:41:31.150
It's not integrated well with other frameworks,
other modern frameworks, at least, such as Cocoa.

00:41:31.150 --> 00:41:39.960
And it's really kind of a hack for our Quartz system.

00:41:39.960 --> 00:41:46.869
Performance is difficult to optimize,
as many of you have probably found out.

00:41:46.869 --> 00:41:53.179
Whether you should hang on to the ATSUI
style or not makes a big difference.

00:41:53.179 --> 00:41:58.819
Whether you set an attribute to one point or another
can actually make a huge different in your performance.

00:41:58.820 --> 00:42:00.000
It's kind of tricky.

00:42:00.000 --> 00:42:06.699
It's still, of course, usable, but it's
mystifying to a lot of people, including myself.

00:42:06.699 --> 00:42:15.989
I'm still discovering things that weren't expected
that happen to be really surprising a lot of people.

00:42:15.989 --> 00:42:22.409
So along with the performance, the internals
are then moving away from its usage.

00:42:22.409 --> 00:42:23.989
It just isn't fast enough.

00:42:23.989 --> 00:42:27.769
As I mentioned, App Kit has moved totally off of ATSUI,

00:42:27.769 --> 00:42:34.539
because it wasn't delivering the excellent
performance that it's users would expect.

00:42:34.539 --> 00:42:38.750
So that's one of the main reasons Core Text was developed,

00:42:38.750 --> 00:42:44.380
to assess that need for the fastest
possible Unicode layout and rendering.

00:42:44.380 --> 00:42:47.800
And it's not available for 64 bit.

00:42:47.800 --> 00:42:55.860
So if you're expecting to write a 64
bit app, dyou can't do it using ATSUI.

00:42:55.860 --> 00:43:03.980
And my last reason, which is the best, is that it's
really straightforward to use Core Text instead of ATSUI.

00:43:03.980 --> 00:43:12.539
Both of them are object based, for instance the
ATSUI style object you can basically say yeah,

00:43:12.539 --> 00:43:14.730
that's a CT font descriptor.

00:43:14.730 --> 00:43:20.039
It contains all these attributes and which
font you want to use and all that stuff.

00:43:20.039 --> 00:43:26.259
The ATSUI text layout object can be though of as a CT frame.

00:43:26.260 --> 00:43:34.010
So it has a lot of similarities that in many
cases you could draw complete parallels over,

00:43:34.010 --> 00:43:41.900
which I'll show in a line break instance
here of how closely resembles ATSUI usage.

00:43:41.900 --> 00:43:44.869
And of course, they both use Unicode for their text,

00:43:44.869 --> 00:43:50.519
so you don't have to change the underlying
layer of your Unicode text input and storage.

00:43:50.519 --> 00:43:54.559
So why would you want to stay with ATSUI?

00:43:54.559 --> 00:43:58.769
There's actually some valid reasons
of why you'd want to stay with ATSUI.

00:43:58.769 --> 00:44:04.670
Core Text doesn't have the text
editing ability that ATSUI does.

00:44:04.670 --> 00:44:10.659
So if you built your edit machinery
around, your text editing machinery

00:44:10.659 --> 00:44:15.500
around ATSUI, it may be best to just stay using ATSUI.

00:44:15.500 --> 00:44:23.570
ATSUI had some great APIs for doing insertion,
deletion and keeping track of all this stuff.

00:44:23.570 --> 00:44:26.840
And Core Text, as of yet, does not have that.

00:44:26.840 --> 00:44:31.380
The other reason would be ATSUI specific attributes.

00:44:31.380 --> 00:44:37.650
There are a few attributes in ATSUI
that aren't accessible from Core Text.

00:44:37.650 --> 00:44:48.430
But I don't think you'd really be missing much because
these attributes are so rarely used we haven't found cases

00:44:48.429 --> 00:44:52.369
where fonts actually used the attributes that were set.

00:44:52.369 --> 00:44:58.400
For instance the just priority overrides.

00:44:58.400 --> 00:45:01.250
I love this one, because no one ever uses it.

00:45:01.250 --> 00:45:06.190
It wasn't carried over to Core Text for
a reason, and that was no one uses it.

00:45:06.190 --> 00:45:15.019
There was another attribute like tracking
that I haven't seen in a font yet.

00:45:15.019 --> 00:45:21.849
So a lot of these attributes were shoved
into ATSUI before we even had working fonts,

00:45:21.849 --> 00:45:26.719
because the idea was that if we
make it, then the fonts will come.

00:45:26.719 --> 00:45:28.949
And that just wasn't the case.

00:45:28.949 --> 00:45:39.349
A lot of these AAT advanced features were born in the
Quick Draw GX days, and we all know how that ended.

00:45:39.349 --> 00:45:49.269
So the other reason you'd want to stay with Quick Draw,
I mean with ATSUI is that your app uses glyph curves.

00:45:49.269 --> 00:45:53.480
ATSUI has a great way of accessing these glyph curves.

00:45:53.480 --> 00:46:01.639
And a lot of applications need these glyph curves in
order to draw them themselves and do some kind of morphing

00:46:01.639 --> 00:46:05.529
to them, you know stretch them,
grow them in the center, whatever.

00:46:05.530 --> 00:46:12.510
One of my first text applications I worked on, Card
Ship Deluxe, I don't know if you remember that,

00:46:12.510 --> 00:46:20.310
but it had this text morphing ability to it where
it had to grab the glyph curves in order to do this.

00:46:20.309 --> 00:46:25.599
Now in many cases, you don't need to
draw your own curves to get that effect.

00:46:25.599 --> 00:46:29.679
You could do your own translations within the CG context.

00:46:29.679 --> 00:46:37.599
So you should reinvestigate whether you really need to be
drawing your curves in order to get these advanced effects.

00:46:37.599 --> 00:46:44.909
The last reason I'm listing here, it's
really kind of scraping the barrel,

00:46:44.909 --> 00:46:51.079
and that is you're ATSUI app needs to mimic Quick Draw.

00:46:51.079 --> 00:47:00.769
This was born out of the need for Quick Draw developers at
the time before Mac OS X, to make the switch to use ATSUI

00:47:00.769 --> 00:47:04.000
so they could render their Unicode
text, but they couldn't afford

00:47:04.000 --> 00:47:08.420
to have their application look
any different than it was before.

00:47:08.420 --> 00:47:16.079
So all the glyph placements, the flow, everything was
as close to the original Quick Draw text rendering

00:47:16.079 --> 00:47:22.230
as could possibly be and ATSUI still has
those special attributes for obtaining that.

00:47:22.230 --> 00:47:30.519
Obviously you wouldn't want to do that from a Core Text
standpoint, so we don't have that ability in Core Text.

00:47:30.519 --> 00:47:36.509
So those are the four main reasons why, I
could think of, of why you'd want to stay

00:47:36.510 --> 00:47:39.360
with ATSUI in your coding and development.

00:47:39.360 --> 00:47:51.130
Now to give you some basis on some of the similarities of
ATSUI and Core Text, it's a lot closer than Quick Draw,

00:47:51.130 --> 00:47:59.599
of course, because ATSUI is at least
Unicode based and it uses objects.

00:47:59.599 --> 00:48:07.739
So the ATSUI draw text, it's main drawing
routine can be gleamed from the Core Text side

00:48:07.739 --> 00:48:16.549
from three different draw calls, the frame, the line
and the run, which I'll touch on to later in this talk.

00:48:16.550 --> 00:48:20.000
Getting font features and variations, no sweat.

00:48:20.000 --> 00:48:22.710
You can do that in Core Text also.

00:48:22.710 --> 00:48:28.769
And bounds for your typographic and
your image bounds can also be gotten

00:48:28.769 --> 00:48:31.889
from Core Text, too, just like you did in ATSUI.

00:48:31.889 --> 00:48:36.329
Now moving to the end of this list
here is the ATSUI break line.

00:48:36.329 --> 00:48:43.630
Very important call that you really need
to call for doing your paragraph breaks.

00:48:43.630 --> 00:48:46.769
There's also a batch break line, too.

00:48:46.769 --> 00:48:53.509
But that was put in by just lots of
pressure to get things speeded up.

00:48:53.510 --> 00:49:02.790
With the CT line suggest line break, it actually comes
out faster in that the call tells you where a good place

00:49:02.789 --> 00:49:07.000
to break is and then you create
the line based on this information.

00:49:07.000 --> 00:49:12.949
In our speed test, sometimes it
comes out twice as fast as ATSUI.

00:49:12.949 --> 00:49:19.069
And I invite you to try your own speed
test, because it's so easy to look at.

00:49:19.070 --> 00:49:25.309
So next I want to talk about those ATSUI
font IDs that everyone's carrying around.

00:49:25.309 --> 00:49:34.429
You can easily convert it to a CT font ref by
using the call CT font create with platform font.

00:49:34.429 --> 00:49:44.230
Here I'm first converting my ATSUI font ID to an ATS
font using the call FM get ATS font ref and font.

00:49:44.230 --> 00:49:53.309
And along with this parameter, I've also got the size,
like in the earlier examples, but I've got a transform

00:49:53.309 --> 00:49:57.199
that I could optionally set, and a font descriptor.

00:49:57.199 --> 00:50:07.919
So I could add this slew of attributes to connect
now to my CT font along with my original font ID.

00:50:09.409 --> 00:50:13.619
Now comes the really fun part.

00:50:13.619 --> 00:50:20.639
When you're breaking lines in a paragraph
of text in ATSUI, you do three basic things.

00:50:20.639 --> 00:50:25.159
You need to find the break point, you
need to measure, and then you draw.

00:50:25.159 --> 00:50:32.279
And then all that other stuff is just keeping track of where
you're going to be drawing and where your break points were.

00:50:32.280 --> 00:50:38.360
A lot of you recognize this stuff,
you've done it a million times, I'm sure.

00:50:38.360 --> 00:50:46.300
Bear in mind also, that all of the quantities coming
out of ATSUI are fixed quantities, not floating point.

00:50:46.300 --> 00:50:48.740
So you need to convert those.

00:50:48.739 --> 00:50:51.619
Also there is coordinate flipping to do.

00:50:51.619 --> 00:50:59.420
ATSUI is a little schizophrenic on it's coordinate frame.

00:50:59.420 --> 00:51:04.030
Any information coming from the fonts is
still in that flipped coordinate system,

00:51:04.030 --> 00:51:10.030
but then when it draws it things
it's in a normal coordinate system.

00:51:10.030 --> 00:51:16.240
So you need to keep track of this stuff pretty
closely when you're drawing using ATSUI.

00:51:16.239 --> 00:51:24.179
Drawing and breaking lines using Core Text, is
very similar, albeit it a little bit simpler.

00:51:24.179 --> 00:51:30.960
Here you can find your line break using
the CT type serve suggest line break

00:51:30.960 --> 00:51:36.039
and then create a line based on that break information.

00:51:36.039 --> 00:51:39.960
Now you would think oh, the lines,
all separate from the paragraph.

00:51:39.960 --> 00:51:41.559
No. It's all connected.

00:51:41.559 --> 00:51:50.480
And you get can your line entity in which now to
operate on and one of the operations, of course,

00:51:50.480 --> 00:51:54.789
is getting the typographic bounds
so you know where to draw this line.

00:51:54.789 --> 00:52:02.960
Notice the difference here that we're setting the drawing
position using the CT context set text position instead

00:52:02.960 --> 00:52:04.929
of right to the calls.

00:52:04.929 --> 00:52:10.129
That's an important distinction between
Core Text and ATSUI that your in control

00:52:10.130 --> 00:52:13.380
of the CG context when you use Core Text.

00:52:13.380 --> 00:52:21.039
With ATSUI it's w little hit or miss with what's
being updated in your Core Text and what's not.

00:52:21.039 --> 00:52:29.529
So it's really an object of a lot of headaches on
trying to figure out what's changed in your Core Text.

00:52:29.530 --> 00:52:34.890
So what many people resort to is
actually saving their CG context ref

00:52:34.889 --> 00:52:37.569
and then restoring it after they've done the draw.

00:52:37.570 --> 00:52:45.000
Of course, doing this takes up valuable cycles
and its not a good thing, in the end, to do.

00:52:45.000 --> 00:52:49.960
But that's what a lot of people had to
resort to to get around that ambiguity

00:52:49.960 --> 00:52:53.550
of what is actually changing in your CG context.

00:52:53.550 --> 00:53:00.650
With Core Text you're in control and it's
very up front of what needs to be done.

00:53:00.650 --> 00:53:06.150
And like in the previous example
here, I'm updating the range location

00:53:06.150 --> 00:53:11.139
and the white position and then I go across with my loops.

00:53:11.139 --> 00:53:16.730
Now this example, you don't even need to do a
break line, because now we've moved up a layer

00:53:16.730 --> 00:53:22.289
in the Core Text by using the CT frame setter.

00:53:22.289 --> 00:53:30.199
If you know the bounds that your paragraph is in,
just use CT frame setter do the drawing for you.

00:53:30.199 --> 00:53:34.329
It's really straightforward and easy to do.

00:53:34.329 --> 00:53:43.179
Why do elaborate break lines when you already
know exactly what the bounds is going to be.

00:53:43.179 --> 00:53:53.559
So with that, I'd like to move on to my last topic,
which is interacting with the user interface,

00:53:53.559 --> 00:54:00.070
in particular the fonts window, or fonts
panel, as a lot of people refer to it.

00:54:00.070 --> 00:54:06.360
And what I have to show in the next few slides
is that it's really a snap using Core Text

00:54:06.360 --> 00:54:13.329
for getting any changes the user might have
set within the typography panel that pops

00:54:13.329 --> 00:54:18.159
up in the fonts panel or the fonts panel itself.

00:54:18.159 --> 00:54:29.799
So in this slide, I'm showing an easy example, really
a small snippet of what you need to do using ATSUI

00:54:29.800 --> 00:54:36.130
to gather the changes made by the user in the font panel.

00:54:36.130 --> 00:54:45.690
Here I'm getting the features, but you would
also need to get DK event param ATSUI font ID

00:54:45.690 --> 00:54:53.269
and the font size and variations and ATSUI attributes.

00:54:53.269 --> 00:54:59.789
And you would need to set all of these individually.

00:54:59.789 --> 00:55:03.360
There's quite a lengthy process to go through.

00:55:03.360 --> 00:55:09.620
And in some cases, you may even miss out
on a few unless you did it exactly right.

00:55:09.619 --> 00:55:16.079
In this example I'm getting the even
parameter K event param dictionary,

00:55:16.079 --> 00:55:21.440
and using that dictionary, I get
the font panel feature types key.

00:55:21.440 --> 00:55:25.059
And with any features types you've got to get the selectors.

00:55:25.059 --> 00:55:30.299
And now with the feature types and selectors
that you've gotten from these dictionaries,

00:55:30.300 --> 00:55:38.130
you've finally set it within your running style
and your app with the ATSUI set font features.

00:55:38.130 --> 00:55:45.890
So that's the features, now you'll need to do that with
the variations and all the attributes and the font ID,

00:55:45.889 --> 00:55:52.940
of course, to make sure that you're up to
date with any user changes in the font panel.

00:55:52.940 --> 00:56:01.010
Now what's great about Core Text is there is a single
event parameter, the K event param CT font descriptor.

00:56:01.010 --> 00:56:02.940
That contains everything.

00:56:02.940 --> 00:56:10.940
And you do a simple merge onto your existing
runtime font descriptor that you're holding

00:56:10.940 --> 00:56:14.639
onto to get up to date with what the user has set.

00:56:14.639 --> 00:56:20.009
This was also touched on in the
hands on session earlier in the day,

00:56:20.010 --> 00:56:25.590
so I highly encourage you to take
a look at that application.

00:56:25.590 --> 00:56:27.550
It's got a lot of aspects to it.

00:56:27.550 --> 00:56:36.610
Even drawing along a curve and rotating a CG context
to do some pretty sophisticated text treatments.

00:56:36.610 --> 00:56:46.130
So using the CT font copy font descriptor, I can
get my current descriptor ref from my CT font,

00:56:46.130 --> 00:56:56.789
which can always be gleamed from that, and using the get
even parameter for the new even param CT font descriptor,

00:56:56.789 --> 00:57:01.590
I can get the changed attributes from the font panel.

00:57:01.590 --> 00:57:12.809
And then the sanctioned way of merging it then
with your existing descriptor is to copy it

00:57:12.809 --> 00:57:19.320
in using the CT font descriptor copy attributes.

00:57:19.320 --> 00:57:26.380
That's how you get the attributes out of the new descriptor.

00:57:26.380 --> 00:57:32.160
And using that, you sue the CT font
descriptor create copy with attributes,

00:57:32.159 --> 00:57:35.989
which actually merges those attributes together.

00:57:35.989 --> 00:57:41.369
And finally you would create your new CT
font descriptor using the CT font create

00:57:41.369 --> 00:57:44.799
with font descriptor and you're done.

00:57:44.800 --> 00:57:52.470
This may look like a lot, but compared to
what was needed for ATSUI, this is nothing.

00:57:52.469 --> 00:57:54.299
This is a blip.

00:57:54.300 --> 00:57:59.340
And you're guaranteed that everything is correct.

00:57:59.340 --> 00:58:03.850
So Core Text, it's really a meaner, leaner text machine.

00:58:03.849 --> 00:58:11.059
And I think you'll whole heartedly agree with me
once you stat digging into it a little bit more.

00:58:11.059 --> 00:58:17.279
I'm really excited about it's entry
into the public domain now.

00:58:17.280 --> 00:58:27.810
We can finally get some real external interactions
now on what would best be the direction of its future.

00:58:27.809 --> 00:58:35.900
And we've already gotten a lot of
feedback from you and we welcome even more.

00:58:35.900 --> 00:58:46.070
It is very similar to ATSUI, you'll find, and in that
way I'll make the transition a lot cleaner and easier.

00:58:46.070 --> 00:58:50.789
Core Text is, by far, faster than ATSUI.

00:58:50.789 --> 00:59:00.039
It is advocated for use within our system to
speed up our overall text layout and rendering.

00:59:00.039 --> 00:59:08.119
So if you want the fastest possible text rendering
and layout, definitely consider Core Text.

00:59:08.119 --> 00:59:12.019
And ATSUI is really an old interface, as I mentioned.

00:59:12.019 --> 00:59:19.559
It was shoe horned into Mac OS X because
really there wasn't anything else out there.

00:59:19.559 --> 00:59:25.289
And when people finally started to getting to know
Cocoa, of course, that was a viable alternative.

00:59:25.289 --> 00:59:35.179
But on the Carbon side, you're kind of left with this
antiquated API set and Core Text is a great alternative

00:59:35.179 --> 00:59:42.279
and progression on the text layout
front for Carbon developers.

00:59:42.280 --> 00:59:48.080
Core Text was defined for Mac OS X,
if I didn't mention that already.

00:59:48.079 --> 00:59:51.909
And it actually used a lot of ATSUI's best parts.

00:59:51.909 --> 00:59:59.719
Some of it's AAT table processing stuff, a lot of
lessons were learned from our development on ATSUI

00:59:59.719 --> 01:00:08.709
to make this the fastest and most stable text rendering
and layout engine out there in the world, I think.

01:00:08.710 --> 01:00:16.220
So I want to summarize this whole talk by saying
Unicode, first and foremost, is the standard for text.

01:00:16.219 --> 01:00:19.219
So really, use it or lose out.

01:00:19.219 --> 01:00:27.379
There's a huge amount of capabilities
available for Unicode text rendering and layout.

01:00:27.380 --> 01:00:41.180
And I think you will greatly appreciate using Unicode as the
main format for using, for storing and editing your text.

01:00:41.179 --> 01:00:43.769
Quick Draw API is dead.

01:00:43.769 --> 01:00:44.909
Rest in peace.

01:00:44.909 --> 01:00:46.210
It is deprecated.

01:00:46.210 --> 01:00:48.889
It's not Unicode based and not suggested.

01:00:48.889 --> 01:00:50.429
So please don't use it.

01:00:50.429 --> 01:00:57.980
It really doesn't do you or your company
any good to continue using Quick Draw.

01:00:57.980 --> 01:01:03.860
ATSUI is still viable in some cases, but
it definitely has performance problems,

01:01:03.860 --> 01:01:09.340
as many of you have knocked down my door pointing out.

01:01:09.340 --> 01:01:18.450
There's not much more we can do about it in that it's stuck
with the current functionality it has and it's reached

01:01:18.449 --> 01:01:22.239
that asymptotic limit of how fast it can actually be.

01:01:22.239 --> 01:01:28.729
There are certain things about it
that are almost impossible to fix.

01:01:28.730 --> 01:01:35.400
It's so rooted in it's old structures that
at some points we just threw up our hands

01:01:35.400 --> 01:01:38.480
and said well, let's put our energy into Core Text.

01:01:38.480 --> 01:01:42.400
So really ATSUI has given all it can.

01:01:42.400 --> 01:01:48.130
And Core Text is really what Apple
is banking on moving forward.

01:01:48.130 --> 01:01:56.039
So all of our future development for
text at this level is build on Core Text.

01:01:56.039 --> 01:02:02.449
ATSUI is not getting any more APIs and
some of its APIs are already deprecated.

01:02:02.449 --> 01:02:09.659
So that's really kind of a show
of the times to come for ATSUI.

01:02:09.659 --> 01:02:12.519
We're not going to ever pull it out from everybody,

01:02:12.519 --> 01:02:20.570
but just be warned that the development
for ATSUI is limited, at this point.

01:02:20.570 --> 01:02:27.820
And we're putting a lot of effort in to making Core
Text our best text rendering layout engine out there.

01:02:27.820 --> 01:02:32.070
And most of all, switching to Core
Text is very straightforward.

01:02:32.070 --> 01:02:39.340
And I think you'll find that it's incredibly
intuitive to use and it's pretty fun.

01:02:39.340 --> 01:02:41.220
So let us help you.

01:02:41.219 --> 01:02:53.359
We are developing this stuff to make your applications
as good as possible and as high performing as possible.

01:02:53.360 --> 01:03:00.680
And we really are trying to keep your best interests
in mind, so we appreciate your feedback, too.

01:03:00.679 --> 01:03:10.369
So I think you'll really be pleasantly
surprised by how insanely great Core Text is.

01:03:10.369 --> 01:03:14.769
So for more information, the usual suspects, Derrick Horn,

01:03:14.769 --> 01:03:20.090
the Application Frameworks Evangelist
and Allan Shaffer for our graphics.

01:03:20.090 --> 01:03:24.590
And documentation, sample code, all
that stuff from the usual place.

01:03:24.590 --> 01:03:33.240
There is also the hands on session that you should really
check out from earlier today in the Core Text talk.

01:03:34.500 --> 01:03:41.780
In the lab, we can work with you, if you have an old,
crusty Quick Draw app, we'll certainly sit down with you

01:03:41.780 --> 01:03:50.500
and see what we can do about making it as painless
as possible of souping it up and using Core Text.
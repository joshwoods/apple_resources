WEBVTT

00:00:13.240 --> 00:00:14.620
>> Kevin: Good afternoon everyone.

00:00:14.619 --> 00:00:16.119
My name's Kevin Van Vechten.

00:00:16.120 --> 00:00:21.210
I'm the BSD Team Manager here at Apple in Core OS.

00:00:21.210 --> 00:00:24.070
And today I'll be talking to you about developing for Unix

00:00:24.070 --> 00:00:30.500
on Mac OS X. Our hope is this session will be a good
introduction to the Mac OS X platform for those of you

00:00:30.500 --> 00:00:36.060
who may not have developed for it before,
particularly those of you who have a Unix background.

00:00:36.060 --> 00:00:41.150
And we'll be going over some of the high level
features of Mac OS X from a programming perspective

00:00:41.149 --> 00:00:47.859
and some of the design decisions that we have and we hope
you'll adopt in your applications to integrate successfully

00:00:47.859 --> 00:00:53.350
with Mac OS X. So what are these concepts of Mac OS X?

00:00:53.350 --> 00:00:57.030
Well, I'm going to give a little bit of
a laundry list and these are the topics

00:00:57.030 --> 00:01:00.509
that we'll cover during the course of the talk.

00:01:00.509 --> 00:01:06.649
First, Mac OS X has a lot of open source
and we really like to adopt open standards

00:01:06.650 --> 00:01:10.700
and we hope you'll interoperate with open standards, too.

00:01:10.700 --> 00:01:14.879
Mac OS X has a very rich structure in
terms of how it's organized on disk

00:01:14.879 --> 00:01:17.469
and how the APIs are layered with each other.

00:01:17.469 --> 00:01:20.560
Mac OS X is very dynamic.

00:01:20.560 --> 00:01:24.799
Most of the computers that it runs
on are portables, the Mac Books.

00:01:24.799 --> 00:01:30.420
They change networks a lot, they have a lot of
different configuration changes all the time,

00:01:30.420 --> 00:01:33.400
so you need to be dynamic in your applications.

00:01:33.400 --> 00:01:39.890
And Mac OS X has a very sophisticated API that we
hope will help you deal with this dynamic environment.

00:01:39.890 --> 00:01:45.930
Internationalization and accessibility
are also important file sets of Mac OS X.

00:01:45.930 --> 00:01:55.010
and Mac OS X has an event driven architecture, which we feel
is very good for the performance of the system for dealing

00:01:55.010 --> 00:02:01.240
with low power situations and just
encourages a good overall design.

00:02:01.239 --> 00:02:07.149
So B, well, virtually all of
Mac OS X's Unix layer is open source.

00:02:07.150 --> 00:02:13.710
So if you're dealing with the command line in libraries
or the kernel, almost everything you need is open source,

00:02:13.710 --> 00:02:18.760
which can be a good place to look at the
code to see how things are really working,

00:02:18.759 --> 00:02:23.449
really dig down with the debugger, see how
well the subsystems are interoperating.

00:02:23.449 --> 00:02:28.929
And it truly is open source under a variety
of open source and free software licenses.

00:02:28.930 --> 00:02:35.270
We have our Apple Public Source License 2.0,
the Apache 2.0 is used for some projects.

00:02:35.270 --> 00:02:40.790
And then of course any projects that we bring in from the
open source community we release under the same license

00:02:40.789 --> 00:02:43.449
that they were originally brought in under.

00:02:44.889 --> 00:02:48.679
There's also literally thousands
of open source projects available

00:02:48.680 --> 00:02:51.659
from the MacPort's and Fink collections of open source.

00:02:51.659 --> 00:02:55.770
And so if there's anything that we haven't already
packaged in Mac OS X, hopefully you'll be able

00:02:55.770 --> 00:03:00.850
to go download it there easily and install it.

00:03:00.849 --> 00:03:07.349
Open Standards are probably even more important than
open source to be interoperable in a larger environment.

00:03:07.349 --> 00:03:12.849
And I'm really pleased to announce that due
to a lot of hard work of people in Core OS,

00:03:12.849 --> 00:03:17.509
we actually are Unix for the Leopard release.

00:03:17.509 --> 00:03:22.959
( Applause )

00:03:22.960 --> 00:03:30.180
>> Kevin: So not only do we adhere to the standards of
Unix, but we are a registered Unix and this is for the CAPI,

00:03:30.180 --> 00:03:33.200
the shell utilities and our threading model.

00:03:33.199 --> 00:03:40.199
The good thing about standards, of course, is there are
so many to choose from and we like to choose them all.

00:03:40.199 --> 00:03:45.000
So here's just a little laundry list of
some of the various standards that we employ

00:03:45.000 --> 00:03:48.620
in our different features of the operating system.

00:03:49.830 --> 00:03:55.030
So you may be wondering what I was talking
about when I said Mac OS X is really dynamic.

00:03:55.030 --> 00:04:02.000
Well, Mac OS X really challenges a lot of the norms
that you might be used to on an historic Unix system,

00:04:02.000 --> 00:04:07.069
the big server setting where everything
pretty much always stays the same.

00:04:07.069 --> 00:04:14.120
Your IP address is probably always the same because
you're serving up web pages and that just is what it is.

00:04:14.120 --> 00:04:16.620
All of your devices are probably always the same.

00:04:16.620 --> 00:04:23.910
You have your ray to ray plugged in, nobody ever unplugs
it, or if they do there's a lot of angry phone calls.

00:04:23.910 --> 00:04:30.800
And you're probably operating 24 hours a day, $7 days
a week, scheduling chron jobs at 2 in the morning

00:04:30.800 --> 00:04:35.079
because that seems like a perfectly good time to run.

00:04:35.079 --> 00:04:40.669
Well, Mac OS X operates in an environment that
really challenges all of these assumptions.

00:04:40.670 --> 00:04:48.790
And they just don't apply for most users in Mac
OS X. In particular, most users are on MacBooks

00:04:48.790 --> 00:04:51.370
and they're roaming from network to network.

00:04:51.370 --> 00:04:56.129
As we are here, attending the conference, and you
walk between buildings or walk down the street,

00:04:56.129 --> 00:05:02.709
you might be leaving the network provided by Apple and
joining the network provided by Starbucks down the street,

00:05:02.709 --> 00:05:09.279
so you need to be able to adapt in your application
to servers coming and going, services being available,

00:05:09.279 --> 00:05:12.629
not being available, not being
available, being available again.

00:05:12.629 --> 00:05:19.159
In addition to that, all of the hardware on our system,
for the most part, is hot pluggable, USB, FireWire, SATA,

00:05:19.160 --> 00:05:24.750
80211 isn't even a plug, but you know, the
network can associate and disassociate.

00:05:24.750 --> 00:05:32.509
And most of our computers in their default
configuration will go to sleep, wake up, hibernate,

00:05:32.509 --> 00:05:36.310
so that assumption that a job will run at
2 in the morning doesn't really hold true

00:05:36.310 --> 00:05:40.449
because very few users have their
desktop machine on at 2 in the morning.

00:05:40.449 --> 00:05:45.550
So you may need to be a little bit more
flexible in how you time some of your events.

00:05:46.790 --> 00:05:50.610
And the way to address all of these
is to subscribe to notifications,

00:05:50.610 --> 00:05:54.129
to be aware of some of the changes
that are happening in the system.

00:05:54.129 --> 00:05:59.370
One of the important things to do is invalidate your
caches when you get notices that hint you should do

00:05:59.370 --> 00:06:05.680
so because perhaps some IP address that
you have cached isn't any longer reachable.

00:06:05.680 --> 00:06:10.269
You might want to go look that up
again and find a different route to it.

00:06:11.399 --> 00:06:14.149
In those terms, you should be willing
to try things again later.

00:06:14.149 --> 00:06:20.349
If a user tries to save a file, you might be able to
save it in a few moments when the networks back up

00:06:20.350 --> 00:06:23.910
and the remote file server's available again.

00:06:23.910 --> 00:06:30.920
So it's a better experience to give the user some sort
of option to retry something later rather than failing

00:06:30.920 --> 00:06:34.660
and quitting and leaving them no recourse.

00:06:34.660 --> 00:06:39.439
And in terms of network connections, be
willing to renegotiate them if necessary.

00:06:39.439 --> 00:06:44.490
Again, if the service isn't there now, it
doesn't mean it's never going to be available.

00:06:46.269 --> 00:06:52.370
So Mac OS X has a very rich structure and I'll
start discussing this at the file system layer,

00:06:52.370 --> 00:06:58.189
since that's one of the first places you'll
encounter when you're using a Unix system.

00:06:58.189 --> 00:07:03.730
We have a very standard file system hierarchy
that's pretty similar to a BSD or Linux system.

00:07:03.730 --> 00:07:09.319
It has all the usual directories, bin, user, var, temp.

00:07:09.319 --> 00:07:13.509
But we also have a bunch of other directories,
which you'll see on the left hand column,

00:07:13.509 --> 00:07:16.899
which aren't very familiar from other Unix systems.

00:07:16.899 --> 00:07:21.529
Well, those are the directories that are
actually visible in the Finder to most users.

00:07:21.529 --> 00:07:26.469
And all of the Unix directories, while
they're available on the terminal or available

00:07:26.470 --> 00:07:33.350
from your programming API aren't shown by default to
the user in the finder and there are no icons for them.

00:07:33.350 --> 00:07:39.379
So you may be wondering what all of these directories
are that Mac OS X has added to the hierarchy.

00:07:39.379 --> 00:07:43.579
Well, they're organized into file system domains.

00:07:43.579 --> 00:07:49.000
And file system domains are essentially a
search path for resources on the system.

00:07:49.000 --> 00:07:55.589
When you want to run an application and it needs to
load a dynamic library, the system will start iterating

00:07:55.589 --> 00:08:00.349
through the file system domains to see
where that library can be loaded from.

00:08:00.350 --> 00:08:05.050
Or if there's a picture resource or a
sound resource or something like that.

00:08:05.050 --> 00:08:09.290
So the first place that's checked in
the search path is the user domain.

00:08:09.290 --> 00:08:17.780
And inside the user's home directory we might have a library
directory and inside there, there might be frameworks

00:08:17.779 --> 00:08:24.329
or preferences or other user specific settings
or user specific installed applications.

00:08:24.329 --> 00:08:28.329
If something's not found there,
it'll proceed to the local domain

00:08:28.329 --> 00:08:34.429
and the local domain is the slash
directory of the root volume.

00:08:34.429 --> 00:08:39.679
And in there there's a library directory where there's
the same structure as you found in the user domain.

00:08:39.679 --> 00:08:46.049
There are frameworks and preferences,
fonts and other types of resources.

00:08:46.049 --> 00:08:52.599
So this is basically everything that should be available
to all users on the local machine should be stored.

00:08:52.600 --> 00:08:56.029
But perhaps you're administering
a site of several different Macs.

00:08:56.029 --> 00:08:59.799
It is possible to provide resources on
the network to all the Macs in your site,

00:08:59.799 --> 00:09:05.000
and that appears in the network
domain with the same structure again.

00:09:05.000 --> 00:09:09.740
Finally, if all those other search
paths fail, there is the system domain.

00:09:09.740 --> 00:09:13.899
And we really prefer that third parties
treat the system domain as immutable.

00:09:13.899 --> 00:09:19.500
By default, everything in there is owned by root
wheel and the permissions are locked down sufficiently

00:09:19.500 --> 00:09:24.250
that no other user should be able to modify
them without escalating privileges first.

00:09:24.250 --> 00:09:31.149
This is the domain that software update will be
modifying when you install future software updates.

00:09:31.149 --> 00:09:37.079
And if you make changes here, there's a
good chance it'll trip up a future update,

00:09:37.080 --> 00:09:41.200
or worse one of our future updates
is going to trip up your application.

00:09:41.200 --> 00:09:47.670
So it's really best to just stay out of the system domain
and just user one of the other domains for your data.

00:09:48.990 --> 00:09:52.019
So inside each of these domains
we have something called bundles.

00:09:52.019 --> 00:09:59.879
And bundles are regular directories and files on the
files system, but presented in a specific structure

00:09:59.879 --> 00:10:04.899
and we recognize them as applications
or frameworks or documents.

00:10:04.899 --> 00:10:07.149
They show up as a single icon in the finder.

00:10:07.149 --> 00:10:10.100
The user can drag them, drop them, move them around.

00:10:10.100 --> 00:10:13.560
And behind the scenes, of course,
it's a bunch of directories and files.

00:10:13.559 --> 00:10:21.329
So application bundles, they should use relative
paths to the resources that they contain.

00:10:21.330 --> 00:10:25.460
So there's a high level directory and then
inside of that is your executable code,

00:10:25.460 --> 00:10:31.030
maybe strings that are your localizations
into other languages, any pictures or sounds

00:10:31.029 --> 00:10:34.199
or QuickTime movies that you use in your application.

00:10:34.200 --> 00:10:41.900
The execution code should be using a relative path to access
these resources so that when the user drags the application

00:10:41.899 --> 00:10:47.490
to a different location, it can still be found.

00:10:47.490 --> 00:10:51.210
And new in Leopard, application
bundles can be signed for integrity.

00:10:51.210 --> 00:10:53.570
This is a pretty neat new feature.

00:10:53.570 --> 00:10:59.310
Something that allows us and you to check
that the application is complete and unaltered

00:10:59.309 --> 00:11:04.619
and really what you have installed initially, so you
can detect corruption or detect when the user is gone

00:11:04.620 --> 00:11:10.340
and move something out of place and hopefully be
able to deal with that situation more gracefully,

00:11:10.340 --> 00:11:12.920
knowing that that's indeed what happened.

00:11:14.240 --> 00:11:19.090
Framework bundles are our organization of dynamic libraries.

00:11:19.090 --> 00:11:23.280
And framework bundles do indeed
contain an ordinary dynamic library.

00:11:23.279 --> 00:11:29.250
But also inside the bundle, we package all of the header
files, so instead of scattering a bunch of header files all

00:11:29.250 --> 00:11:35.289
over user include that belong to all the different
libraries on your system, we package them neatly in bundles

00:11:35.289 --> 00:11:39.980
And when you link against a certain
dylib, you're also going to be linking

00:11:39.980 --> 00:11:43.500
against the correct set of header files for that dylib.

00:11:45.120 --> 00:11:48.470
There's also a convention we have
for storing multiple versions

00:11:48.470 --> 00:11:52.040
of the dylib in the same framework for compatibility.

00:11:52.039 --> 00:11:55.480
So, for example, in Leopard we have the Python framework.

00:11:55.480 --> 00:11:59.110
And on Tiger, we had Python 2.3.

00:11:59.110 --> 00:12:03.899
On Leopard we have Python 2.5, and they
aren't perfectly binary compatible.

00:12:03.899 --> 00:12:11.209
Well, applications that linked against 2.3 can
continue to access it at the historic 2.3 location.

00:12:11.210 --> 00:12:17.100
Applications new in Leopard, when they're compiled,
they'll read the current sim link in the bundle to see

00:12:17.100 --> 00:12:23.389
that they should link against the 2.5 version and
then that's their compatibility version going forward.

00:12:23.389 --> 00:12:28.559
It's also possible for framework bundles to contain
other resources in the same way that applications do,

00:12:28.559 --> 00:12:32.389
but more importantly it's possible for
them to contain command line tools.

00:12:32.389 --> 00:12:36.730
And you'll see with the Python framework,
the Tickle framework, the Ruby framework,

00:12:36.730 --> 00:12:42.850
some of these other frameworks on the system, they
contain command line tools and it's a good way

00:12:42.850 --> 00:12:47.850
to keep things organized neatly instead
of scattered across the user bin.

00:12:49.919 --> 00:12:53.870
Document bundles are where you can
store your application specific data.

00:12:53.870 --> 00:12:57.560
Generally there's a primary document
such as an XML file and then again,

00:12:57.559 --> 00:13:01.219
you can have auxiliary resources
and other files in the bundle.

00:13:02.480 --> 00:13:07.490
So the API for dealing with these
bundles, there's several different ways.

00:13:07.490 --> 00:13:13.720
First we have the NS system directories header file, and
this is what allows you to enumerate the file system domains

00:13:13.720 --> 00:13:17.540
to look for where you should find bundles to begin with.

00:13:17.539 --> 00:13:23.549
Then you can use the POSIX API for unstructured access
to the bundle, that's manipulating the bundle in terms

00:13:23.549 --> 00:13:26.589
of being a directory containing a bunch of files.

00:13:26.590 --> 00:13:31.879
But if you want more structured access that
does some convenience functions for you,

00:13:31.879 --> 00:13:37.529
you should look at the Core Foundations CF header
bundle or foundations NS bundle header to get some

00:13:37.529 --> 00:13:41.289
of these higher level APIs for manipulating bundles.

00:13:42.529 --> 00:13:51.879
So these higher level APIs lead me in to the discussion of
sophisticated API on Mac OS X. The API Mac OS X is organized

00:13:51.879 --> 00:13:58.549
in several layers, all of which are
available for your application to use.

00:13:58.549 --> 00:14:03.750
But at the high layer, we have Carbon, Cocoa, X11, and Java.

00:14:03.750 --> 00:14:12.570
And these are all interfaces that present some UI on
the system and interact with the user in a GUI fashion.

00:14:12.570 --> 00:14:18.190
At the mid layers Core Foundation, and this is
what Carbon and Cocoa are layered on top of,

00:14:18.190 --> 00:14:27.160
the Core Foundation is a nice API to use when you want to
maybe just be a command line utility or a system service,

00:14:27.159 --> 00:14:32.139
but also interact with a lot of the high level features of
Mac OS X. And of course all of this is layered is layered

00:14:32.139 --> 00:14:37.500
on top of the Unix layer, which is the Unix standard.

00:14:38.750 --> 00:14:45.480
So to develop with our APIs you need to use Xcode
tools, which is our name for the compiler,

00:14:45.480 --> 00:14:48.930
the debugger and these other tools on the system.

00:14:48.929 --> 00:14:52.589
Basically the GNU tool chain at the command line lever.

00:14:52.590 --> 00:14:56.509
Its optional install in general, not
everyone has the Xcode tool installed.

00:14:56.509 --> 00:15:00.509
So if you're new to the Mac, you might
be surprised to see that it's a Unix

00:15:00.509 --> 00:15:04.080
that doesn't have a C Compiler installed by default.

00:15:04.080 --> 00:15:09.780
In addition to that, in Leopard, the command line
tools of Xcode aren't even always installed.

00:15:09.779 --> 00:15:14.039
So when you're installing, make sure that
command line tools package is checked, otherwise,

00:15:14.039 --> 00:15:15.779
just installing Xcode to this isn't enough.

00:15:15.779 --> 00:15:20.309
You'll get Xcode, but you won't have a user bin GCC.

00:15:20.309 --> 00:15:26.589
But when you've installed Xcode and its command
line tools, you'll have GCC, GDB, Make, lib tool,

00:15:26.590 --> 00:15:34.490
which for legacy reason, we call G lib tool on our system to
differentiate it from the lib tool that we have internally,

00:15:34.490 --> 00:15:39.629
auto conf, auto make, all the usual
GNU tool chain that you'd expect.

00:15:41.700 --> 00:15:50.330
So frameworks, as I discussed earlier are a Mac OS X
concept of packaging up dynamic libraries into a bundle.

00:15:50.330 --> 00:15:56.300
Well there are GCC extensions that we have
added that deal with frameworks directly.

00:15:56.299 --> 00:16:03.740
So when you include a header file in your sources,
you can actually include with a path that is the name

00:16:03.740 --> 00:16:05.980
of the framework and then the name of the header.

00:16:05.980 --> 00:16:08.800
And this actually gets examined automatically by GCC.

00:16:08.799 --> 00:16:13.269
It looks in whatever your current
framework search path is and then looks

00:16:13.269 --> 00:16:16.600
in the current version of the headers for that framework.

00:16:16.600 --> 00:16:22.290
There are also some GCC flags that you can use to
manipulate the standard search paths for frameworks,

00:16:22.289 --> 00:16:27.610
so if you're linking against a framework that's
not in the standard library frameworks location,

00:16:27.610 --> 00:16:33.620
or system library frameworks location, manipulate the search
paths and find the frameworks where you need to find them.

00:16:33.620 --> 00:16:38.149
And these basically work equivalent to the dash capital L

00:16:38.149 --> 00:16:44.720
or dash lower case L flags that
you're more familiar with in GCC.

00:16:44.720 --> 00:16:49.200
Now we also have a concept on Mac OS X
called software developing kits or SDKs.

00:16:49.200 --> 00:16:54.430
And in a weird way I guess you could think of
them as a bundle of all the bundles on the system.

00:16:54.429 --> 00:16:58.959
So if you took all the frameworks for
a current release and packaged them

00:16:58.960 --> 00:17:05.170
up into an SDK then you have a snapshot
of all the interfaces for that release.

00:17:05.170 --> 00:17:10.660
And what this lets you do is on a 10.5 system
compile in a way that will be compatible

00:17:10.660 --> 00:17:14.730
with 10.4 or 10.3 or some earlier release.

00:17:15.849 --> 00:17:23.199
Now what this does behind the scenes, is GCC has
some extra flags that were added, the dash I sys root

00:17:23.200 --> 00:17:27.600
and the linker argument dash sys lib root.

00:17:27.599 --> 00:17:31.269
And basically these paths just get
prepended to any of the normal search paths.

00:17:31.269 --> 00:17:36.069
So it goes through in the SDK that you specify
and then looks for the system libraries

00:17:36.069 --> 00:17:38.799
and headers when linking your application.

00:17:40.910 --> 00:17:45.269
Deployment targets are a mechanism
that we use within one sys SDK

00:17:45.269 --> 00:17:49.700
or one disk compiling against the
base system without an SDK.

00:17:49.700 --> 00:17:54.890
And this lets you declare your target
environment in terms of which APIs are available.

00:17:54.890 --> 00:17:59.450
So there's the GCC flag, the Mac OS X minimum version flag.

00:17:59.450 --> 00:18:05.000
And when you set this to a version,
let's say 10.4, it'll do two things.

00:18:05.000 --> 00:18:12.160
It'll make all of the functions that were defined later
than 10.4 invisible for the purpose of this compile,

00:18:12.160 --> 00:18:17.070
so you won't accidentally link against any
functions that are too new for that release.

00:18:17.069 --> 00:18:22.069
It'll also warn you about any functions
that were deprecated in 10.4.

00:18:22.069 --> 00:18:26.049
So perhaps there's a better function
available that you should be using.

00:18:26.049 --> 00:18:34.230
The function was valid in 10.3, but in
10.4 discouraged, so you'll get a warning.

00:18:34.230 --> 00:18:37.809
And this is all implemented in the
availability macros header file.

00:18:37.809 --> 00:18:43.929
And in previous releases, you would set the Mac
OS X deployment target environment variable,

00:18:43.930 --> 00:18:52.830
which still works in Leopard but is deprecated; we
recommend setting Mac OS X minimum version tag on GCC.

00:18:52.829 --> 00:19:03.220
So when you compile your binaries, they'll get compiled into
the Mach-O file format, which is our executable file format.

00:19:03.220 --> 00:19:08.490
We don't use ELF on Mac OS X. It
behaves pretty similarly to ELF.

00:19:08.490 --> 00:19:10.920
There are a few small semantic differences.

00:19:10.920 --> 00:19:14.019
Probably the most likely one you'll encounter is

00:19:14.019 --> 00:19:20.109
that in Mach-O there is a difference
in how we treat plug-ins and dylibs.

00:19:20.109 --> 00:19:25.629
plug-ins are what we refer to as bundles, not to be
confused with the bundles I had been talking about earlier.

00:19:25.630 --> 00:19:30.300
And dylibs are pretty much the same as an ELF dylib.

00:19:30.299 --> 00:19:37.119
And the difference here is the bundle actually has some
knowledge about what application is intended to load it.

00:19:37.119 --> 00:19:44.389
We also provide a two level name space in Mach-O. So not
only do we store the symbols that a binary will reference

00:19:44.390 --> 00:19:47.410
from a library, but we also store the name of that library.

00:19:47.410 --> 00:19:55.430
And what this achieves is any library or any plug
in can define the same symbol and it's unambiguous

00:19:55.430 --> 00:19:59.470
which symbol the application is going to get.

00:19:59.470 --> 00:20:05.769
If you run into trouble from the two level name space, it
is possible at compile time to specify a flat name space,

00:20:05.769 --> 00:20:11.410
and this will be have more similarly to other Unix systems.

00:20:11.410 --> 00:20:17.710
One of the big features that Mach
O gives us is a universal binary.

00:20:17.710 --> 00:20:21.200
And this is one file that supports many architectures.

00:20:21.200 --> 00:20:27.140
And currently on Leopard, we're supporting four
architectures in Mac OS X. We have Power PC and Intel,

00:20:27.140 --> 00:20:31.320
but we also have the 64-bit varieties of both of these.

00:20:33.009 --> 00:20:38.569
And one of the points I'd really like to stress about
universal binaries is it's quite literally the same sources

00:20:38.569 --> 00:20:44.210
that get compiled multiple times to produce the
same binary that can run on many architectures.

00:20:44.210 --> 00:20:48.340
And the way you achieve this is through
the GCC flag dash arch and you can specify

00:20:48.339 --> 00:20:51.089
as many or as few architectures as you want.

00:20:51.089 --> 00:20:56.699
We encourage you to specify all the possible
architectures so that your application will run any where.

00:20:56.700 --> 00:21:03.180
Now sometimes it is necessary to know a little
bit about the platform that you are compiling on.

00:21:03.180 --> 00:21:07.480
To that end we have some preprocessor
macros that are available.

00:21:07.480 --> 00:21:12.549
Big -endian, little -endian, LP64 are the
ones we encourage you to use.

00:21:12.549 --> 00:21:20.589
So if you have a data structure that is dependent on the
-endians of the architecture, you can test for these macros.

00:21:20.589 --> 00:21:25.179
Or if you need to make data structures
wider for 64-bit, you can do that.

00:21:25.180 --> 00:21:29.850
In the off chance that you're actually doing some
assembly programming or literally need to know

00:21:29.849 --> 00:21:36.309
which architecture you're on, you can test
for architecture specific macros as well.

00:21:36.309 --> 00:21:43.230
But it's probably a better idea wherever possible to use
the more generic big or little -endian macros or LP64 macro

00:21:43.230 --> 00:21:47.470
so that you're insulated against any future changes.

00:21:49.470 --> 00:21:53.819
We support static and dynamic linking
on Mac OS X. as a general rule,

00:21:53.819 --> 00:21:56.649
all the libraries that Apple provides will be dynamic.

00:21:56.650 --> 00:22:02.640
And we can do this so that we can software update
and provide any bug fixes that we might have.

00:22:02.640 --> 00:22:08.520
If we provided static libraries, those bug fixes
wouldn't really help third party applications.

00:22:09.910 --> 00:22:15.220
When you are linking, we really recommend
that you use the GCC linker driver directly.

00:22:15.220 --> 00:22:17.430
Don't use LD or LD64.

00:22:17.430 --> 00:22:19.019
GCC has some smarts.

00:22:19.019 --> 00:22:20.210
It can do the right thing.

00:22:20.210 --> 00:22:24.140
That might not be immediately obvious
when invoking LD manually.

00:22:24.140 --> 00:22:29.870
And the way to use the GCC linker drivers
is simple as taking all of your object files

00:22:29.869 --> 00:22:34.629
and compiling them into an executable with GCC.

00:22:34.630 --> 00:22:37.760
For dynamic linking we use the DL open interface.

00:22:37.759 --> 00:22:43.049
Compatibility was taken from open
source and introduced in Panther.

00:22:43.049 --> 00:22:46.470
It became native in Tiger.

00:22:46.470 --> 00:22:49.150
And now, actually in Leopard it is the preferred solution.

00:22:49.150 --> 00:22:53.759
If you're going to be dynamically
linking in code, you should use DL open.

00:22:56.019 --> 00:23:02.150
So some of the other Unix API that we have on the system
and some of the changes that we've been making are

00:23:02.150 --> 00:23:06.210
that we now conform fully to the Unix 03 standard.

00:23:06.210 --> 00:23:10.960
So Unix 03 command behavior is the default in Leopard.

00:23:10.960 --> 00:23:16.860
We did keep any non standard behavior wherever we
could that didn't directly conflict with the standard

00:23:16.859 --> 00:23:23.839
and it was something that was being used by scripts or
programs, then we tried to keep it in for compatibility.

00:23:25.430 --> 00:23:29.940
If you run into any cases where there is
an incompatibility with a new behavior,

00:23:29.940 --> 00:23:34.210
it's possible to set an environment
variable known as the command mode.

00:23:34.210 --> 00:23:40.640
By default, if it's empty or it has this validating in
Unix 2003, that's what you're going to get on Leopard.

00:23:40.640 --> 00:23:47.640
If you set it to the string legacy, it'll make command
behave like they used to behave on 10.4 or earlier.

00:23:47.640 --> 00:23:53.680
There are also a few places where we automatically
set this environment variable for compatibility.

00:23:53.680 --> 00:23:58.140
First of these places is in installer
post flight and preflight scripts.

00:23:58.140 --> 00:24:02.700
If you have an installer package that was
created on Tiger or an earlier version,

00:24:02.700 --> 00:24:06.140
then when the installer runs it'll go
ahead and set this environment variable.

00:24:06.140 --> 00:24:10.670
So hopefully you won't have any problems
with any of your existing installer scripts.

00:24:10.670 --> 00:24:14.660
However, if you create a new package
on Leopard, we won't set this.

00:24:14.660 --> 00:24:18.890
We hope you are using the standard behavior of the commands.

00:24:18.890 --> 00:24:23.420
And so we'll assume that.

00:24:23.420 --> 00:24:27.690
We also set this environment variable for
compatibility for any applications that link

00:24:27.690 --> 00:24:31.320
against Core Foundation or a higher level framework.

00:24:31.319 --> 00:24:36.649
And if we can detect that they were linked on 10.4 or
earlier, we'll set the environment variables so that

00:24:36.650 --> 00:24:44.540
if they fork an exec or P open or call system or any of
these other APIs that reach out to the shell, hopefully,

00:24:44.539 --> 00:24:48.089
again, the shell will behave in a manner that they expect.

00:24:48.089 --> 00:24:53.079
But for any applications compile don Leopard,
we hope that you have done testing on Leopard

00:24:53.079 --> 00:24:55.429
and are using the new standard behaviors.

00:24:55.430 --> 00:25:04.779
So to give a little bit of a practical example of how this
might impact you, on Leopard now, with the Unix standard,

00:25:04.779 --> 00:25:10.129
echo dash N, hello world, quite
literally echoes dash N, hello world.

00:25:11.569 --> 00:25:18.490
So if you wanted to revert that temporarily to the legacy
behavior, you could set the command mode equal to legacy,

00:25:18.490 --> 00:25:23.920
run the same command and you would get
hello world without the trailing new line.

00:25:23.920 --> 00:25:27.980
But as I said earlier, wherever things
didn't directly conflict with the standard,

00:25:27.980 --> 00:25:30.009
we tried to preserve them for compatibility.

00:25:30.009 --> 00:25:36.400
If you're not using the POSIX shell, but let's say you're
using Bash, which is outside the scope of the standard,

00:25:36.400 --> 00:25:42.940
then we've preserved the standard Bash behavior, which
is to honor the dash N and not print a trailing new line.

00:25:42.940 --> 00:25:50.340
And of course, what we would hope, is that you do
the POSIX standard way of suppressing the new line

00:25:50.339 --> 00:25:57.449
by including a back slash, back slash C and then
hopefully that'll work in the widest variety of places.

00:26:01.190 --> 00:26:10.259
So not only are there command changes in Leopard,
but we also had some source compatibility changes.

00:26:10.259 --> 00:26:15.849
And you'll probably get some compiler warnings and
compiler errors that you didn't used to get before Leopard.

00:26:15.849 --> 00:26:20.719
Most of them tend to effect system level
services, not so much application level services,

00:26:20.720 --> 00:26:24.120
so hopefully a lot of you won't even notice.

00:26:24.119 --> 00:26:29.239
But if there is a case where you absolutely
cannot live with the new standard behavior,

00:26:29.240 --> 00:26:33.990
it is possible to define the non
standard source preprocessor macro

00:26:33.990 --> 00:26:37.349
and that will opt out of the Unix 03 behavior.

00:26:37.349 --> 00:26:41.339
But I should mention that non standard
source is not available on 64-bit.

00:26:41.339 --> 00:26:46.750
Since 64-bit is a new platform with Leopard
we really wanted to start with a clean slate.

00:26:46.750 --> 00:26:52.279
And 64-bit is completely Unix conforming from the beginning.

00:26:52.279 --> 00:26:59.829
So the difference of setting or not setting this
environment, or this preprocessor macro is that functions

00:26:59.829 --> 00:27:05.859
that had changed behavior are invisibly
suffixed with a dollar sign Unix 2003.

00:27:05.859 --> 00:27:14.990
so non suffixed versions still exist and that's what
applications compile on Tiger or earlier continue to call

00:27:14.990 --> 00:27:20.130
so they continue to behave as they always did, but if
it's compiled on Leopard or later and it's using one

00:27:20.130 --> 00:27:24.770
of these functions that changed due to Unix standards,

00:27:24.769 --> 00:27:30.900
then it'll have an invisible dollar sign Unix
2003 appended to  it and get the new Unix behavior.

00:27:30.900 --> 00:27:34.860
This has a few applications that I'll discuss in a moment.

00:27:34.859 --> 00:27:40.099
The first of these implications is that
you really need to include header files

00:27:40.099 --> 00:27:44.309
and not rely on implicit function definitions.

00:27:44.309 --> 00:27:50.210
Because if you do you're not going to get the
magic that invisibly suffixes dollar Unix 2003.

00:27:50.210 --> 00:27:55.140
in the worst cases, in some places in your
code, you might have the header file link scope,

00:27:55.140 --> 00:28:00.540
you might be getting the new behavior, and in other places
in your sources, you might not have the header and scope

00:28:00.539 --> 00:28:05.490
and you might be getting the legacy behavior
and perhaps mixing and matching legacy behavior

00:28:05.490 --> 00:28:10.539
with the new behavior could lead to
unpredictable or undesired results.

00:28:10.539 --> 00:28:12.740
So you really should warn about missing prototypes.

00:28:12.740 --> 00:28:19.130
If you see missing prototypes for standard functions, go
see what header file needs to be included to make sure

00:28:19.130 --> 00:28:22.530
that you're getting all the right preprocessor magic.

00:28:24.359 --> 00:28:27.629
The other thing this affects is binary compatibility.

00:28:27.630 --> 00:28:32.380
Binaries that were compiled before leopard
still should run on Leopard as mentioned.

00:28:32.380 --> 00:28:38.970
But if you compile a binary on Leopard and don't
use an SDK, it might not run on an earlier version

00:28:38.970 --> 00:28:42.890
of Mac OS X. this was always the case,
but we've just introduced a whole lot

00:28:42.890 --> 00:28:48.840
of additional ways this could fail
with the Unix compatibility.

00:28:48.839 --> 00:28:55.839
And what the symptom would be if you do choose to
build a Leopard binary without an SDK and run it

00:28:55.839 --> 00:29:00.199
on an earlier system is that you will
get undefined symbols at run time

00:29:00.200 --> 00:29:07.210
and most of these undefined symbols will have
the dollar Unix 2003 suffix on t he end of them.

00:29:08.250 --> 00:29:13.390
Now all the Unix API we actually
package into one library, lib system.

00:29:13.390 --> 00:29:19.110
And for compatibility, since this is often in
multiple different libraries on other Unix's,

00:29:19.109 --> 00:29:24.019
we have sim links to lib systems, so hopefully you
won't have to change too many of your make files.

00:29:24.019 --> 00:29:29.940
But for performance reasons, we do have it
all packaged in a single dynamic link library.

00:29:31.299 --> 00:29:36.889
Another difference in the Unix behavior
from other Unix is that our standard calls

00:29:36.890 --> 00:29:40.190
for get adder info, get PW Int, get GR Int.

00:29:40.190 --> 00:29:46.410
I actually talked to our directory service team and
that's part of our open directory infrastructure.

00:29:46.410 --> 00:29:51.680
What this means is that unlike other systems where you
might just be reading the files in slash at C, you know,

00:29:51.680 --> 00:29:59.230
at C password or at C groups, on Mac OS X, you'll also
be consulting the directory service local database,

00:29:59.230 --> 00:30:03.799
you'll be consulting LDAP if you're bound to an
LDAP network, Active Directory if you're bound

00:30:03.799 --> 00:30:11.200
to an Active Directory network, Bonjour for host names
on the local area net, and so basically you get all

00:30:11.200 --> 00:30:17.730
of this additional information free
of charge from the standard Unix APIs.

00:30:19.279 --> 00:30:24.930
Another big change in Leopard, with respect to open
directory, is that Net Info was removed from Leopard

00:30:24.930 --> 00:30:28.140
and everything has been consolidated on open directory.

00:30:28.140 --> 00:30:35.740
So if you have scripts that use NICL or NI
Util to manipulate the Net Info data store,

00:30:35.740 --> 00:30:41.130
you should be changing over to use DSCL,
that's the Directory Service Command Line tool.

00:30:41.130 --> 00:30:45.800
It will let you manage your user and
host records on the local data store.

00:30:45.799 --> 00:30:52.970
It's also been present since Panther, so you should
be able to use it compatibly across several releases.

00:30:52.970 --> 00:30:59.130
There are also alternative GUI methods that
were added in Leopard to do some common tasks.

00:30:59.130 --> 00:31:03.040
One of these is it's now possible to enable
the root user, should you need to do so,

00:31:03.039 --> 00:31:06.519
using directory utility in the utilities folder.

00:31:06.519 --> 00:31:13.139
It's also possible to control click an account in the
accounts pain of systems preferences and that will bring

00:31:13.140 --> 00:31:19.120
up a sheet that lets you edit a lot of the advanced
characteristics of the user account, including the user ID,

00:31:19.119 --> 00:31:23.619
the home directory path, and some of these
other things that aren't normally editable.

00:31:26.180 --> 00:31:31.810
Another interesting note about open directory on our
platform is that open directory is really what handles all

00:31:31.809 --> 00:31:38.109
of our authentication and PAM is
mostly a shim to Open Directory.

00:31:38.109 --> 00:31:43.619
So it takes the standard PAM API and calls out
to Open Directory to perform authentication.

00:31:43.619 --> 00:31:50.119
We do this because there are a lot of standard Unix
utilities, SSH, FTP, Login, that all rely on PAM

00:31:50.119 --> 00:31:53.759
and we can bridge them to Open Directory in a unified way.

00:31:53.759 --> 00:31:58.099
However, login window does not use PAM,
so if you're expecting your PAM modules

00:31:58.099 --> 00:32:01.839
to work with Login, it's just not going to work.

00:32:01.839 --> 00:32:07.609
There are login authentication plug-
ins that are a different architecture.

00:32:07.609 --> 00:32:11.389
So some of the higher level Mac OS
X API that we have layered on top

00:32:11.390 --> 00:32:17.080
of the Unix API has a few concepts
that I'd really like to emphasize.

00:32:17.079 --> 00:32:18.549
And the first of these is Unicode.

00:32:18.549 --> 00:32:26.049
Unicode is a big part of what we do in Mac
OS X. Unicode, as you probably already know,

00:32:26.049 --> 00:32:31.129
is a standard that provides a unique
number for every character.
f

00:32:31.130 --> 00:32:35.510
All the characters for all the different encodings
that are out there were unified into Unicode,

00:32:35.509 --> 00:32:39.940
which hopefully let's you display characters
from any language in the same encoding.

00:32:39.940 --> 00:32:49.880
One of the ways this most directly impacts the Unix layer
of Mac OS X is that HSF plus file names are Unicode.

00:32:49.880 --> 00:32:58.450
They're not a random, or I shouldn't say random, or
arbitrary blob of data like they might be on USF,

00:32:58.450 --> 00:33:02.870
where you can store pretty much anything
you want in there aside from slash, I guess.

00:33:02.869 --> 00:33:05.209
But on HSF, there is an encoding.

00:33:05.210 --> 00:33:12.269
It's Unicode specifically UTF-16.

00:33:12.269 --> 00:33:17.589
and our convention for the POSIX APIs is to use UTF-8.

00:33:17.589 --> 00:33:21.720
and the reason we use UTF-8 is it doesn't
have any embedded null characters,

00:33:21.720 --> 00:33:28.019
which means it works with the standard C
string APIs such as stir L copy or stir L cat.

00:33:28.019 --> 00:33:32.680
And yes, you should be using stir L copy
and stir L cat to avoid any buffer overflows

00:33:32.680 --> 00:33:38.750
that you might get with stir copy and stir cat.

00:33:38.750 --> 00:33:47.730
Another way that Unicode directly impacts your Unix
applications is that terminal defaults to UTF-8.

00:33:47.730 --> 00:33:53.000
o all of the command line input that
you get in your RV array are going

00:33:53.000 --> 00:33:58.339
to be UTF-8 strings by default on almost everybody's Mac.

00:33:58.339 --> 00:34:04.240
Any standard input that's typed into the terminal
and piped to your process is going to be UTF-8.

00:34:04.240 --> 00:34:09.650
and of course you should produce UTF-8 because that's
probably what all of the other tools are going to expect

00:34:09.650 --> 00:34:12.680
and that's what the file names should be opened as.

00:34:12.679 --> 00:34:18.019
So if everybody plays with UTF-8, then for the most
part you'll have maximum compatibility in terms

00:34:18.019 --> 00:34:22.719
of character encodings with all of the
other command line tools on the system.

00:34:22.719 --> 00:34:30.679
I don't know if you're too familiar with UTF-8, but it
breaks some of the common assumptions that have held true

00:34:30.679 --> 00:34:37.579
for a long time in Unix programming in the United
States, which was that one character was one bite.

00:34:37.579 --> 00:34:39.639
No, that's not any longer the case.

00:34:39.639 --> 00:34:42.719
UTF-8 is a multi byte characters.

00:34:42.719 --> 00:34:47.039
So characters can be anywhere from
one byte to 6 bytes or so.

00:34:47.039 --> 00:34:51.670
It's also for a character to take
up multiple columns on the display.

00:34:51.670 --> 00:34:54.289
So what this means is in the world of UTF-8,

00:34:54.289 --> 00:34:59.250
the stir line function is really only
useful to determine the size of a buffer.

00:34:59.250 --> 00:35:01.980
It doesn't tell you much about the string at all.

00:35:01.980 --> 00:35:07.059
It doesn't tell you the number of characters, it doesn't
tell you the number of columns that it'll take to display.

00:35:07.059 --> 00:35:13.610
And you should also be aware when you're manipulating
strings that picking an arbitrary location in the string

00:35:13.610 --> 00:35:19.210
to break it into two pieces might split the middle
of a sequence that represents one character,

00:35:19.210 --> 00:35:24.329
which leaves you with an invalid character on
the end of one string and an invalid character

00:35:24.329 --> 00:35:27.340
on the beginning of the second substring.

00:35:27.340 --> 00:35:29.570
So what can you do to avoid this?

00:35:29.570 --> 00:35:33.900
Well we have the Unix standard wide character strings API.

00:35:33.900 --> 00:35:40.260
And the fundamental unit of the wide
character strings are the wide character type.

00:35:40.260 --> 00:35:44.270
And a wide character type represents
a single Unicode code point.

00:35:44.269 --> 00:35:49.130
And there are APIs available to convert
from Unicode to wide character strings.

00:35:49.130 --> 00:35:53.660
And a bunch of APIs available for manipulating
wide character strings once they're in that format.

00:35:53.659 --> 00:35:58.899
And then you can convert back to UTF-8 and print
them to the display and get the results you wanted.

00:35:58.900 --> 00:36:06.760
So I'm going to give a real world example of
where wide character strings come in handy.

00:36:06.760 --> 00:36:14.560
In Leopard we brought in the Intel application, which
prints this nice little calendar on the terminal.

00:36:14.559 --> 00:36:21.340
And as you can see it's printing the first two
characters of every day of the week in English.

00:36:21.340 --> 00:36:28.660
Well, what happens if you set the
local to a multi byte local.

00:36:28.659 --> 00:36:35.960
The idiom I'm using of Lang sets the environment
variable Lang for the single invocation of cal.

00:36:35.960 --> 00:36:38.730
You can see all the days of the week are question marks.

00:36:38.730 --> 00:36:40.740
Well, why did this happen?

00:36:40.739 --> 00:36:48.259
It turns out that let's say a day of the week character
has a Unicode code point that's also represented

00:36:48.260 --> 00:36:51.580
by a three byte UTF-8 sequence.

00:36:51.579 --> 00:36:57.009
And the end cal program was simply copying two
bytes of the string into the destination buffer

00:36:57.010 --> 00:36:59.310
because it only wanted the first two characters.

00:36:59.309 --> 00:37:05.559
So what you ended up with is question mark, question
mark because you had this illegal UTF-8 sequence.

00:37:05.559 --> 00:37:07.579
It wasn't a complete character.

00:37:07.579 --> 00:37:09.440
The terminal didn't know how to render it.

00:37:09.440 --> 00:37:12.530
It just put a question mark there as a place holder.

00:37:12.530 --> 00:37:14.100
So what can we do to fix that?

00:37:14.099 --> 00:37:20.789
Well it turns out it's possible to use the wide
string API and in the first block of code you see

00:37:20.789 --> 00:37:26.250
up top you can convert from UTF
8 into a wide character string.

00:37:26.250 --> 00:37:32.940
In the middle block we're actually iterating
over the string and using the WCS width function,

00:37:32.940 --> 00:37:35.679
which is determining the display width of the string.

00:37:35.679 --> 00:37:39.559
And what we want to do is keep chopping
off characters off then end of the string

00:37:39.559 --> 00:37:42.480
until we get the display width down to two.

00:37:42.480 --> 00:37:47.059
And then we can concert back to
UTFF 8 and print to the screen.

00:37:47.059 --> 00:37:53.150
And as it turns out, that makes the display much nicer.

00:37:53.150 --> 00:37:55.420
Another interesting thing to note, in this example is each

00:37:55.420 --> 00:37:59.789
of these characters are rendered
by terminal as to columns wide.

00:37:59.789 --> 00:38:05.590
So we were limiting the display width to
two, we ended up with a three byte sequence

00:38:05.590 --> 00:38:09.559
and it's actually only rendering as
a single character on the screen.

00:38:12.780 --> 00:38:16.760
Aside from the Unix standard wide character
string API, there is some higher level API

00:38:16.760 --> 00:38:19.840
on Mac OS X for dealing with Unicode strings.

00:38:19.840 --> 00:38:21.960
These are CF String and NF String.

00:38:21.960 --> 00:38:27.740
And the reason you might want to use these is because
they work very well with all the other CF and NS types.

00:38:27.739 --> 00:38:32.069
So if you're doing a lot of programming at the higher
layer, you probably want to use their string types

00:38:32.070 --> 00:38:35.760
so that you can mix and match with their other objects.

00:38:35.760 --> 00:38:41.180
And CF string is actually an abstract
representation of the UTF-16 string

00:38:41.179 --> 00:38:43.899
and it supports many character encoding versions.

00:38:43.900 --> 00:38:47.690
So where ever your source data is from
you can create a CF string from that

00:38:47.690 --> 00:38:51.250
and you can also convert to any encoding that you need.

00:38:51.250 --> 00:39:01.980
And this is just a simple example of creating
a C string from a UTF-8 encoded arg B vector.

00:39:01.980 --> 00:39:09.219
So whatever argument you are passing to your command
line tool would create a CF string from that,

00:39:09.219 --> 00:39:13.439
then convert the string back to a
C string so we can print it out.

00:39:16.519 --> 00:39:22.030
In addition to Unicode, Mac OS X
has an event driven architecture.

00:39:22.030 --> 00:39:26.950
And the even drive architecture really
focuses around the concept of run loop.

00:39:26.949 --> 00:39:29.779
And the run loop provides much more than select.

00:39:29.780 --> 00:39:34.750
If you're used to the standard command line
programming, then you'll probably have a select loop,

00:39:34.750 --> 00:39:40.150
which tells you when data is ready to be read from
a file descriptor or written to a file descriptor.

00:39:40.150 --> 00:39:47.340
If you're used to using a GUI tool kit like KD or Gnome,
they have more advanced concepts than a select loop.

00:39:47.340 --> 00:39:55.440
And we have run loops on Mac OS X. And run loops accept
a variety of sources, more than just file descriptors,

00:39:55.440 --> 00:39:57.269
but they do accept file descriptors, too.

00:39:57.269 --> 00:40:02.739
And in Leopard we have a new CF File descriptor
type, which should help with compatibility.

00:40:02.739 --> 00:40:10.069
But you can also be waiting for events regarding
network sockets, timers, so you can have a timer fire

00:40:10.070 --> 00:40:16.019
at an arbitrary point of time in the future, mock
IPC messages, and there are many more sources.

00:40:16.019 --> 00:40:17.539
You can even create your own sources.

00:40:17.539 --> 00:40:21.349
So if you do have a select loop that you
absolutely have to have in your application,

00:40:21.349 --> 00:40:23.210
there's really no way to integrate it with a run loop.

00:40:23.210 --> 00:40:25.990
It might be possible to create a custom source.

00:40:25.989 --> 00:40:28.479
Do your select loop on a separate thread.

00:40:28.480 --> 00:40:34.570
Do whatever type of event recognition you
were historically doing on a separate thread

00:40:34.570 --> 00:40:39.019
and then send a message over to the main thread.

00:40:39.019 --> 00:40:44.130
One of the great advantages of run loops is that
it does automatic event dispatch via call backs.

00:40:44.130 --> 00:40:50.530
So when you make a select loop, yeah, it will block until
there is data waiting to be operated on on a socket,

00:40:50.530 --> 00:40:55.620
but then you have to figure out which socket it was
on and then decide what you're going to do with it.

00:40:55.619 --> 00:40:59.449
The way the run loop is modeled is that when
sources are installed into the run loop,

00:40:59.449 --> 00:41:04.489
they each have a call back associated with them and you
just get your callbacks called whenever an event happens.

00:41:04.489 --> 00:41:07.529
There's really no dispatch that
you need to take care of at all.

00:41:07.530 --> 00:41:10.870
It's all taken for you by the framework.

00:41:12.389 --> 00:41:14.759
So, what does that get us?

00:41:14.760 --> 00:41:19.960
Well it gives us seamless interaction
between applications and frameworks.

00:41:19.960 --> 00:41:23.960
One of the advantages of that, applications and
frameworks won't be stealing each others events.

00:41:23.960 --> 00:41:26.940
They can all install sources cooperatively into the run loop

00:41:26.940 --> 00:41:30.070
and they can all handle the events
that they're supposed to handle.

00:41:30.070 --> 00:41:32.440
They're not going to be clobbering each other.

00:41:32.440 --> 00:41:35.190
It also gives frameworks an amount of autonomy.

00:41:35.190 --> 00:41:38.889
It's possible for a framework to
install a source into the run loop

00:41:38.889 --> 00:41:41.299
without any knowledge on the part of the application.

00:41:41.300 --> 00:41:46.690
If you're doing a select loop, the framework's going to have
to give you a file descriptor or some other type of handle

00:41:46.690 --> 00:41:52.980
that you can select on, but with the run loop, they
can just install their sources into the run loop.

00:41:52.980 --> 00:41:54.960
The application doesn't even have to know.

00:41:54.960 --> 00:41:57.740
So the framework can be doing it at initialization time.

00:41:57.739 --> 00:41:59.609
It can get every event that it needs.

00:41:59.610 --> 00:42:04.050
The application can be compatible across
multiple versions of the framework

00:42:04.050 --> 00:42:06.950
as the framework changes behind the
scenes how it deals with events.

00:42:06.949 --> 00:42:12.629
And the way frameworks can do this is they can act
as a run loop which is stored as a per thread global

00:42:12.630 --> 00:42:15.930
and is accessible via the CF run loop get current API.

00:42:15.929 --> 00:42:21.779
That returns a reference to the current run loop and
that's where you can install all of your event sources.

00:42:23.309 --> 00:42:27.019
Another advanced feature of run loops is
that it's possible to run them in a mode.

00:42:27.019 --> 00:42:32.750
And a mode is essentially a subset of all
the installed sources in the run loop.

00:42:32.750 --> 00:42:37.559
So perhaps you want to listen for all events and
then once you received one you only want to listen

00:42:37.559 --> 00:42:40.769
to a subset of events until that operation's done.

00:42:40.769 --> 00:42:43.889
That's what run loop modes can be used for.

00:42:43.889 --> 00:42:46.480
We also have a concept of observers in the run loop.

00:42:46.480 --> 00:42:51.639
And observers are basically callbacks that get called
in each point of the cycle of the run loop regardless

00:42:51.639 --> 00:42:54.889
of whether any events have been delivered or not.

00:42:54.889 --> 00:42:59.429
So what are some of the best practices for using run loops?

00:42:59.429 --> 00:43:02.119
Well, you shouldn't block the main thread.

00:43:02.119 --> 00:43:08.750
If you do, you're going to get that spinning
beach ball cursor that we're all so fond of.

00:43:08.750 --> 00:43:13.159
And to this effect, you should keep
your callbacks relatively fast.

00:43:13.159 --> 00:43:18.339
The more operation you do in your callback, the more likely
you're going to be blocking the main thread for a period

00:43:18.340 --> 00:43:22.220
of time long enough that it's going to cause
the spinney beach ball cursor to appear.

00:43:22.219 --> 00:43:27.939
The window server is what displays that when it
feels that your application's no longer responsive.

00:43:27.940 --> 00:43:35.670
The best way to keep your callbacks fast is to post
notifications or cue work for another thread to do

00:43:35.670 --> 00:43:39.190
so that the main thread is then
free to respond to future events.

00:43:39.190 --> 00:43:51.269
And the new NS operation API in Leopard is a great way
to cue those types of tasks for other threads to handle.

00:43:51.269 --> 00:43:58.690
So here's a real world example of using a
run loop in a command line program for Unix.

00:43:58.690 --> 00:44:07.340
We have the I/O stat tool, which will print statistics from
time to time about disk activity on the current machine.

00:44:07.340 --> 00:44:11.190
And one of the things we notice
is that it only reported activity

00:44:11.190 --> 00:44:16.260
about whatever disks were plugged in
at the time the command was invoked.

00:44:16.260 --> 00:44:21.000
If you added another disk to the machine
it wouldn't print any statistics.

00:44:21.000 --> 00:44:25.750
If you removed a disk from the
machine it would crash I/O stat.

00:44:25.750 --> 00:44:33.949
So what we were able to do is use the I/O Kit
framework and install some notifications.

00:44:33.949 --> 00:44:40.139
So first we established a connection with the IO
Kit framework and then we created what I known

00:44:40.139 --> 00:44:45.049
as a matching dictionary saying that
we wanted to receive notifications

00:44:45.050 --> 00:44:48.630
about all events pertaining to whole media devices.

00:44:48.630 --> 00:44:55.420
So that's an entire physical disk or logical disk,
not one partition on it, but the whole disk itsELF.

00:44:55.420 --> 00:44:58.570
And once we've created this matching
dictionary, which indicates what type

00:44:58.570 --> 00:45:02.910
of events we're interested in, we can add our calls backs.

00:45:02.909 --> 00:45:08.420
And in this example we're adding two call backs,
we're adding a call back called add disc call back

00:45:08.420 --> 00:45:13.119
which gets invoked anytime one of these whole media
devices appears for the first time on the computer.

00:45:13.119 --> 00:45:19.079
And then we also added call back called the remove
disc call back which will get called anytime one

00:45:19.079 --> 00:45:24.569
of these whole disc devices is removed
from the current device tree.

00:45:26.309 --> 00:45:32.369
Now we will get a reference to the current run
loop and add the I/O Kit notifications as a source

00:45:32.369 --> 00:45:35.440
to the current ruin loop in the default mode.

00:45:35.440 --> 00:45:40.090
So once we have all of our call backs set
up we can go ahead and kick off the run loop

00:45:40.090 --> 00:45:47.850
and while the I/O stat tools running, we'll set a time
out of one second by default, actually not by default

00:45:47.849 --> 00:45:55.639
but then one mode of operation will update the display every
second and so instead of just doing a sleep for that second,

00:45:55.639 --> 00:46:01.469
we'll actually run the run loop for that
period of time and if any disc's appear

00:46:01.469 --> 00:46:08.059
or any discs disappear our call backs will get invoked,
we'll update our internal data structures after the period

00:46:08.059 --> 00:46:14.699
of time has elapsed we'll update the display and loop around
and do it again, wait for more disc's to appear or disappear

00:46:14.699 --> 00:46:18.929
and in the meantime keep printing all
the statistics of the current discs.

00:46:18.929 --> 00:46:22.129
I would like to give you a demo of this in action.

00:46:22.130 --> 00:46:25.940
(Pause in speech 0:46:21.8 to 0:46:43.2)

00:46:25.940 --> 00:46:48.750
>> So the dash D argument is going to suppress a little
bit of extra information and then I'll have it repeat

00:46:48.750 --> 00:46:53.150
for really high counts so it probably
won't finish before the demos over.

00:46:53.150 --> 00:47:01.490
So you can see right now it's burning statistics about
two discs and we can take a disc image file here

00:47:01.489 --> 00:47:05.479
and mount the disc image and it shows three discs.

00:47:06.989 --> 00:47:10.709
Well wrong icon.

00:47:10.710 --> 00:47:13.320
Underneath there I have a second disc image.

00:47:13.320 --> 00:47:16.710
You can see that there were four discs mounted.

00:47:16.710 --> 00:47:26.150
We can eject one of these discs it goes back down
to three and eject another, goes back down to two.

00:47:26.150 --> 00:47:31.440
So this is a real world example of a command line
utility that actually can benefit from using a run loop,

00:47:31.440 --> 00:47:35.840
receiving event notifications and
dealing with Mac OS X in a dynamic way

00:47:35.840 --> 00:47:38.300
in opposed to just assuming a static configuration.

00:47:38.300 --> 00:47:39.330
(Pause in speech 0:47:39.0 to 0:47:47.0)

00:47:39.329 --> 00:47:47.569
>> Turn back to the slides.

00:47:47.570 --> 00:47:53.760
(Pause in speech 0:46:47.2 to 0:47:54.0)

00:47:53.760 --> 00:47:59.450
>> So there are a lot of frameworks on Mac OS X that
provided a lot of run lib sources that are events

00:47:59.449 --> 00:48:03.509
that you probably would be interested
in, in your applications.

00:48:03.510 --> 00:48:09.250
I/O Kit is the one that I just demoed and one of the
reasons to use I/O Kit is that it provides everything

00:48:09.250 --> 00:48:15.340
in the device tree not just, not
everything in Mac OS X appears in slash dev.

00:48:15.340 --> 00:48:21.039
Unlike Linux or unlike the SD where pretty much all
devices appear there, I/O Kit has its own device tree

00:48:21.039 --> 00:48:25.059
and only a few things are exported
to slash dev for compatibility.

00:48:25.059 --> 00:48:31.349
An I/O Kit will give you these call backs anytime a device
appears or disappears and while the matching dictionary,

00:48:31.349 --> 00:48:35.739
I showed you was repetitively simple, we
were just matching on any whole device.

00:48:35.739 --> 00:48:42.179
We could really fine tune that search and
say only USB devices, only FireWire devices,

00:48:42.179 --> 00:48:44.699
only FireWire devices with certain vendor ID's.

00:48:44.699 --> 00:48:47.659
There's all sorts of things you can match on.

00:48:48.900 --> 00:48:55.420
Built upon the I/O Kit framework is the disc arbitration
framework which doesn't operate on the devices themselves

00:48:55.420 --> 00:49:01.139
but more of the logical volumes and
the partitions that devices contain.

00:49:01.139 --> 00:49:07.559
Disc arbitration has API for mounting discs and
ejecting discs and more specifically run them call backs

00:49:07.559 --> 00:49:12.920
to let you know anytime a disc has
appeared or a disc has disappeared.

00:49:12.920 --> 00:49:18.550
These also the system configuration framework
in Mac OS X and this deals with all sorts

00:49:18.550 --> 00:49:24.330
of local machine settings, particularly
network related setting.

00:49:24.329 --> 00:49:31.989
Things like the host name the IP address of the current
machine, what your web proxies are on a system wide level

00:49:31.989 --> 00:49:35.500
and you can get run loop call backs for
anytime one of these preferences changes

00:49:35.500 --> 00:49:40.880
so your application can start using a proxy
if one is just been recently been specified.

00:49:40.880 --> 00:49:47.590
Or you might be monitoring the status of network connection,
such as PPP connections or VPN connections to know

00:49:47.590 --> 00:49:52.039
that you should or shouldn't be trying to talk
that server because the connection has gone away.

00:49:52.039 --> 00:49:59.369
And there is also a more generic network reach ability API,
which tells you whether s particular IP address is routable

00:49:59.369 --> 00:50:06.009
or not so you can decide if it s not routable there's
probably no since trying to contact it and more importantly

00:50:06.010 --> 00:50:11.100
if you do have some type UI or you bring some sort
of dialogistic messages you can inform the user

00:50:11.099 --> 00:50:13.440
in a more intelligent manner that the server that they want

00:50:13.440 --> 00:50:16.829
to access isn't reachable with
the current network configuration.

00:50:16.829 --> 00:50:25.549
We have the Notify API in the BSD layer which is
just a simple lightweight notification mechanism.

00:50:25.550 --> 00:50:31.970
Its analagous to Unix signals but we use name
strings which gives you a much wider name space

00:50:31.969 --> 00:50:35.289
for sending notifications to other applications.

00:50:35.289 --> 00:50:41.199
But like signals if multiple notifications
are sent and relatively close to one another,

00:50:41.199 --> 00:50:44.579
they'll all be coalesced into a single notification.

00:50:44.579 --> 00:50:50.250
The Notify API has multiple delivery mechanism,
we tried to make it as easy as possible

00:50:50.250 --> 00:50:56.590
to incorporate these notifications into whatever
architecture your existing application has

00:50:56.590 --> 00:51:02.079
so you can receive notifications via file
descriptor that you can plug into your select loop

00:51:02.079 --> 00:51:07.960
if that's what you are still using you can receive them
over a mach port, you can receive them as Unix signals,

00:51:07.960 --> 00:51:14.579
you can receive them by pulling although we
really do discourage that and for all the details

00:51:14.579 --> 00:51:23.079
about the Notify API, you can view notify.h. Also new in
Leopard we've published some of the notification strings

00:51:23.079 --> 00:51:26.110
that we're using around the system
so you are free to monitor some

00:51:26.110 --> 00:51:29.630
of these notifications in your applications as well.

00:51:29.630 --> 00:51:34.230
These include the directory service cache
and validation to let you know that user

00:51:34.230 --> 00:51:40.960
and group caches have just been purged in the directory or
service daemon, perhaps a move form one ldap domain

00:51:40.960 --> 00:51:47.650
to another or got taken off an ldap domain entirely and
so your application may be running with some credentials

00:51:47.650 --> 00:51:51.559
that are no longer applicable an the
current environment an might want

00:51:51.559 --> 00:51:56.009
to re evaluate all the users and groups that it knows about.

00:51:56.010 --> 00:52:04.800
We also send out notifications whenever a new mount appears
at BFS layer or when there's low disc on the root device

00:52:04.800 --> 00:52:11.519
or other devices and you can receive notifications
about host names changes and time zone changes.

00:52:14.139 --> 00:52:17.259
Bonjour is another source of events for you r run loop.

00:52:17.260 --> 00:52:27.190
Bonjour lets you advertise your services on the local area
network and I thin k on the wide are network now with DNSSD

00:52:27.190 --> 00:52:34.929
and this lets you find other services on the network
without knowing there IP address or port ahead of time.

00:52:34.929 --> 00:52:39.739
Its really kind of an at hawk DNS system
and the way this feeds into your run loop is

00:52:39.739 --> 00:52:49.069
that as new services are published by other machines on
the network and you will get notifications on your run loop

00:52:49.070 --> 00:52:52.690
and present more options to the user about binding

00:52:52.690 --> 00:52:57.139
to these other services it that's
what makes since for your application.

00:52:57.139 --> 00:53:04.009
Another important consideration in terms of being dynamic
with Bonjour is that you should cache the service name,

00:53:04.010 --> 00:53:08.460
not necessarily the IP address or the port, so
remember what services you want it to connect

00:53:08.460 --> 00:53:14.639
to not specifically what the port was at the
time because that might change in the future.

00:53:16.099 --> 00:53:26.679
We also have some new API, the Mac OS X layer and Leopard,
one of these have been around in the Tiger time frame

00:53:26.679 --> 00:53:31.719
but is recently published as public API for
you to use and that is our copy file API.

00:53:31.719 --> 00:53:39.029
And copy file lets you copy files while preserving
there extended attributes, access control list,

00:53:39.030 --> 00:53:45.800
resource for all that other additional
information aside from the data of the file.

00:53:45.800 --> 00:53:52.130
It also offers some compatibility for file systems
which don't support these characteristic's natively.

00:53:52.130 --> 00:53:58.809
It will automatically take a file that contains extended
attributes or somebody's other bits of information

00:53:58.809 --> 00:54:02.779
and create and AppleDouble file which
your probably more familiar with seeing it

00:54:02.780 --> 00:54:07.019
with a dot under bar and your directory listings.

00:54:08.210 --> 00:54:15.929
Then as these are moved around and copied back to the file
system that does natively support these characteristics.

00:54:15.929 --> 00:54:23.940
Those two files will get merged back into a single file
and copy file is the engine is the engine that we are using

00:54:23.940 --> 00:54:29.320
by CP, TAR, GZIP, Rsync all of our standard tools that will
preserve this information and we encourage you to use it

00:54:29.320 --> 00:54:36.300
to so that all applications can copy files around in
a manner that's preserved for any extended attributes.

00:54:36.300 --> 00:54:41.460
Soon as we add new types of information to
the file we can add that support to copy file

00:54:41.460 --> 00:54:46.740
and your applications should be able to get it for free
because the engines taking care of copying all the things

00:54:46.739 --> 00:54:50.529
that you may not have never even heard about
at the time of writing the application.

00:54:50.530 --> 00:55:00.180
Mac OS X also has a security framework and the security
framework is our API for authentication and authorization.

00:55:00.179 --> 00:55:04.649
One of the main parts of the API is the Keychain.

00:55:04.650 --> 00:55:07.599
The Keychain provides secure credential storage.

00:55:07.599 --> 00:55:14.309
It encrypts your web passwords and
other sensitive bits of information.

00:55:14.309 --> 00:55:19.869
There's also an authorization API which is a
rights spaces system, we really would encourage you

00:55:19.869 --> 00:55:27.269
to move away form the old historic Unix assumption that if
the process is running with the same UID as I am running

00:55:27.269 --> 00:55:35.309
as everything's fair game, trying to
introduce finer grain controls into the system.

00:55:35.309 --> 00:55:40.190
One of the authorization API will do is it
will prompt for a password if that's necessary

00:55:40.190 --> 00:55:45.260
but the rights also have al lifetime to them
which is an administratively configurable setting

00:55:45.260 --> 00:55:52.410
so sometimes you can do the same operation several times
since the succession and you won't need to be prompted

00:55:52.409 --> 00:55:56.149
for a password if your configured that way.

00:55:56.150 --> 00:56:02.990
And like I said the administrator does have control
over a lot of the aspects of the authorization API

00:56:02.989 --> 00:56:05.349
so you can grant certain rights to certain users.

00:56:05.349 --> 00:56:09.119
You can deny certain rights to certain
users, you can set timeouts individually.

00:56:09.119 --> 00:56:13.259
You really get a lot of fine grain
control as an administrator.

00:56:13.260 --> 00:56:16.730
So what does this authorization API give us?

00:56:16.730 --> 00:56:23.519
Well one of our long term goals in Mac OS
X is to avoid the use of set UID binaries

00:56:23.519 --> 00:56:29.759
in Unix instead we really abdicate using IPC and LaunchD.

00:56:29.760 --> 00:56:36.670
A set of UID binaries are very difficult thing to secure,
you have to know everything in your execution environment

00:56:36.670 --> 00:56:42.220
and assume that whoever's allowed to execute the
binary, you know isn't going to be able to attack you

00:56:42.219 --> 00:56:46.089
by setting an environment variable
that changes some behavior in library

00:56:46.090 --> 00:56:49.470
or a lot of things that are just really hard to anticipate.

00:56:49.469 --> 00:56:55.399
On the other hand if you use IPC and
LaunchD you can send a message to launch

00:56:55.400 --> 00:57:03.849
on demand helper which will you know perform some action?

00:57:03.849 --> 00:57:09.839
Launch D can start this process privileged, but it
can start it from a clean execution environment.

00:57:09.840 --> 00:57:15.030
And in order to know whether this privilege process
should carry through with the task that's been requested,

00:57:15.030 --> 00:57:18.420
it can use the security frameworks authorization API.

00:57:18.420 --> 00:57:25.300
And the way you can do that is by taking an authorization
token and serializing it, passing it in the message

00:57:25.300 --> 00:57:30.830
to the daemon, the daemon can extract
the serialized authorization right,

00:57:30.829 --> 00:57:33.480
ask the security framework is this valid?

00:57:33.480 --> 00:57:35.940
Is this something I should perform?

00:57:35.940 --> 00:57:40.070
And if it is, I can go ahead and perform the operation.

00:57:40.070 --> 00:57:43.890
And really the root of all of this is that
protocols are something that can be secured easily.

00:57:43.889 --> 00:57:48.940
You can look at your protocol, you can look at what parses
the protocol, you can figure out what it's allowed to do

00:57:48.940 --> 00:57:53.170
and insure that it is only letting
those valid requests through.

00:57:53.170 --> 00:57:57.889
But securing the runtime environment
is really an intractable problem.

00:57:57.889 --> 00:58:04.659
So that's why we'd like to shift away from set UID
binaries to launch on demand privileged helpers.

00:58:05.690 --> 00:58:15.510
And another big change in Mac OS X is that X11
has been updated to X11R7.2 from the X.org tree.

00:58:15.510 --> 00:58:19.140
It's an optional install, but it's on by default in Leopard.

00:58:19.139 --> 00:58:25.109
We've added in launch on demand support from terminal,
so in a way, X11 is a launch on demand helper of any

00:58:25.110 --> 00:58:28.890
of the X11 binaries that you invoke on the command line.

00:58:28.889 --> 00:58:35.029
X11, like all of our other BSD
libraries are available 64-bit.

00:58:35.030 --> 00:58:43.010
We did move the path from user X11R6 to user
X11, so that we won't be dated in future updates.

00:58:43.010 --> 00:58:52.020
And another great news about the X.org changes is that
we've been committing them back to the X.org repository

00:58:52.019 --> 00:58:58.789
so when we ship Leopard we fully anticipate that if you
go to X.org, download the sources from their repository,

00:58:58.789 --> 00:59:05.940
build those sources, you'll get exactly what you would
have gotten if you'd installed it from the Leopard DVD.

00:59:05.940 --> 00:59:09.510
And now I'd like to give you a demo.

00:59:09.510 --> 00:59:18.340
( Applause )

00:59:18.340 --> 00:59:26.380
>> Kevin: So in the spirit of not running things
until they're needed to run to conserve battery power.

00:59:26.380 --> 00:59:29.700
By default the X11 environment is not running.

00:59:29.699 --> 00:59:35.759
However, we do have a display variable set.

00:59:35.760 --> 00:59:44.510
So when we run an X11 application like Xterm, X11 runs.

00:59:44.510 --> 00:59:52.710
( Applause )

00:59:52.710 --> 00:59:56.510
>> Kevin: And it's the X11 that you all know and love.

00:59:56.510 --> 01:00:05.780
( Applause )

01:00:05.780 --> 01:00:06.970
>> Kevin: That's the extent of the demo.

01:00:06.969 --> 01:00:08.589
It's real exciting, I Know.

01:00:08.590 --> 01:00:13.610
But behind the scenes there's a lot of
integration that goes on to make this the case.

01:00:13.610 --> 01:00:17.500
Actually I can give another quick
demo in terms of privilege separation.

01:00:17.500 --> 01:00:23.539
One of the things we wanted to do in leopard is
provide a more secure environment for temp files.

01:00:23.539 --> 01:00:27.480
So you might have always had temp
files go into the slash temp directory.

01:00:27.480 --> 01:00:30.429
Well, that can be erased.

01:00:30.429 --> 01:00:34.329
Other applications, other users can create files before you.

01:00:34.329 --> 01:00:38.119
You have to do some special checks to make
sure that the files don't already exist.

01:00:38.119 --> 01:00:46.219
So we've given every user their own temp directory
on the local volume that is created securely

01:00:46.219 --> 01:00:50.589
so that no other user can interfere with it.

01:00:50.590 --> 01:00:57.300
And when an application wants to access this
directory, it can use the comp store API

01:00:57.300 --> 01:01:01.580
which also is manifested on the command line as get conf.

01:01:03.179 --> 01:01:11.319
so if I ask for the Darwin user temporary
directory, you can see there's a path, Var folders,

01:01:11.320 --> 01:01:17.220
it's based on the UUID of my currently
logged in user, temporary items.

01:01:17.219 --> 01:01:24.839
And if that directory didn't exist ahead of time,
invoking this API to look up the path will actually call

01:01:24.840 --> 01:01:27.829
out to a privilege helper to create it for the first time.

01:01:27.829 --> 01:01:29.630
If it already exists, there's nothing to do.

01:01:29.630 --> 01:01:32.010
It doesn't need to start another process.

01:01:32.010 --> 01:01:40.430
But if we look at the permissions on var folders,
you can see var folders has it's on by root wheel.

01:01:40.429 --> 01:01:45.569
W3e've divided up the name space so we don't
get too many directories in one directory.

01:01:45.570 --> 01:01:51.670
But if we look in there we can see that the
temp directory is in fact owned by the user.

01:01:51.670 --> 01:01:57.570
So we don't have a set UID binary
anywhere, but we can create a directory

01:01:57.570 --> 01:02:09.510
in a secure location via a launch on demand helper.

01:02:09.510 --> 01:02:13.130
( Applause )

01:02:13.130 --> 01:02:15.820
>> Kevin: Going back to the slides.

01:02:19.090 --> 01:02:25.730
So for more information there's a mailing
list on the Apple Mailman List Server.

01:02:25.730 --> 01:02:32.380
Particularly there's the Unix porting list where we'd be
happy to answer a variety of common questions that come

01:02:32.380 --> 01:02:40.730
up when porting Unix applications to Mac OS X. there's
the X11 users mailing list for specific X11 questions.

01:02:40.730 --> 01:02:46.710
And then for any of you who are interested in
manipulating the open source layers of the system itsELF,

01:02:46.710 --> 01:02:52.949
there's the Darwin development mailing list where
we discuss aspects of the Darwin system itsELF.

01:02:54.340 --> 01:03:01.480
And for more information you can contact Ernest Prabhakar),
the Unix and Open Source Marketing Product Manager.

01:03:01.480 --> 01:03:08.179
We have our open source website at
developer.apple.com forward slash opensource

01:03:08.179 --> 01:03:14.269
and we have documentation sample code and other
Unix resources on the developer.apple.com website.
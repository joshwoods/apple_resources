WEBVTT

00:00:14.880 --> 00:00:16.859
>> Okay. Good morning everybody.

00:00:16.859 --> 00:00:18.169
My name is Eric Seymour.

00:00:18.170 --> 00:00:22.630
And today along with my colleague, James
Dempsey, we're going to talk to you

00:00:22.629 --> 00:00:24.739
about adding accessibility to your application.

00:00:24.739 --> 00:00:29.259
And actually, specifically, I'm going to spend a
little bit of time this morning, just a little bit,

00:00:29.260 --> 00:00:32.490
talking about some of the higher
level issues related to accessibility,

00:00:32.490 --> 00:00:36.120
give you a little feature peak into VoiceOver for Leopard.

00:00:36.119 --> 00:00:42.169
And then for those who are new to accessibility
on Macintosh, either from an end-user

00:00:42.170 --> 00:00:47.530
or a programming perspective, just touch on what our
accessibility APIs mean so that when James comes up on stage

00:00:47.530 --> 00:00:54.299
and actually does some real detailed work, everybody is kind
of on the same playing field, understands what's going on.

00:00:54.299 --> 00:00:59.829
So let's get started with the first question that
always happens at the beginning of accessibility talks

00:00:59.829 --> 00:01:02.509
and that's why make your application accessible?

00:01:02.509 --> 00:01:05.920
So there are several really good reasons.

00:01:05.920 --> 00:01:14.420
And one of them starts with your user so a really
good reason to access enable your application is

00:01:14.420 --> 00:01:18.599
because there's this community of users out
there that's getting bigger all the time,

00:01:18.599 --> 00:01:21.709
especially now that VoiceOver has
been shipping for two years.

00:01:21.709 --> 00:01:25.709
And these users don't use a Macintosh in a conventional way.

00:01:25.709 --> 00:01:27.640
These users use assistive technology.

00:01:27.640 --> 00:01:30.540
So they're not using the graphical
interface all the time.

00:01:30.540 --> 00:01:31.590
They're using VoiceOver.

00:01:31.590 --> 00:01:36.230
They're using some other, some other solutions
that I know some folks in the room create.

00:01:36.230 --> 00:01:42.930
And when you access enable your application,
what you're effectively doing is making your app,

00:01:42.930 --> 00:01:48.990
whether it's the most popular in its class or not, you
are making it the best of read application for that user.

00:01:48.989 --> 00:01:55.250
And that becomes a highly leveragable thing when folks
or entities who are purchasing on behalf of that user,

00:01:55.250 --> 00:02:02.000
for example, a school system or the federal government or
a state government or anybody who's contracting on behalf

00:02:02.000 --> 00:02:07.079
of one those entities, when they're looking for a solution
to purchase, your application becomes best of read.

00:02:07.079 --> 00:02:12.359
And it makes it easier for us when we're trying
to do a large volume sell to reference something.

00:02:12.360 --> 00:02:15.500
For example, like your application as a solution.

00:02:15.500 --> 00:02:23.560
But it opens up a big opportunity to not just get one or
two new seats, but to actually get perhaps many, many more.

00:02:23.560 --> 00:02:27.020
So we think there's a lot of value add here.

00:02:27.020 --> 00:02:32.740
And I'm going to mention a statistic in a couple of minutes
about VoiceOver, which has made this even more profound.

00:02:32.740 --> 00:02:38.250
So the second reason really has less to do
with accessibility and it has more to do

00:02:38.250 --> 00:02:41.030
with enabling other technologies on the system.

00:02:41.030 --> 00:02:47.080
So obviously system applications work when you
enable your, when you enable your application.

00:02:47.080 --> 00:02:50.490
But also internal are tools that we ship.

00:02:50.490 --> 00:02:53.969
For example, Automator, a new tool that
we're shipping this year called X-ray.

00:02:53.969 --> 00:02:56.969
Both of those leverage the accessibility APIs.

00:02:56.969 --> 00:02:59.120
You can think of this as user interface automation.

00:02:59.120 --> 00:03:04.250
Internally to Apple, we take advantage of the
accessibility APIs and some internal tools to do testing

00:03:04.250 --> 00:03:06.990
so that we can make our products better and more robust.

00:03:06.990 --> 00:03:14.000
In fact, I know that some of the folks, perhaps even in
this room, some developers use accessibility APIs not

00:03:14.000 --> 00:03:18.689
for assistive devices, but specifically
because it helps them test their application.

00:03:18.689 --> 00:03:22.829
And I know this because I get bugs in our
bug system that have to do with accessibility

00:03:22.830 --> 00:03:24.880
and the driver's not an assistive application.

00:03:24.879 --> 00:03:30.199
The driver is we're trying to automate our testing process
and this particular bug is preventing us from doing this.

00:03:30.199 --> 00:03:31.319
And so we fix it.

00:03:31.319 --> 00:03:32.849
And that's a really good thing, see.

00:03:32.849 --> 00:03:37.569
At the end of the day, accessibility is more
about user, more about user interface automation.

00:03:37.569 --> 00:03:42.000
The fact that it helps a significant group
of users is really, really important.

00:03:42.000 --> 00:03:45.270
So on to VoiceOver.

00:03:45.270 --> 00:03:46.640
So give you a little VoiceOver update.

00:03:46.639 --> 00:03:51.139
So the first thing is VoiceOver for those of you who
haven't used it before or are unfamiliar with it,

00:03:51.139 --> 00:03:54.279
VoiceOver is screen reader technology for Mac OS X.

00:03:54.280 --> 00:04:01.870
So a screen reader is typically software that allows you
to get to every place on the screen, even painted text,

00:04:01.870 --> 00:04:04.420
regions that wouldn't ordinarily
let you get there from a keyboard,

00:04:04.419 --> 00:04:07.750
it lets you have full keyboard access to those locations.

00:04:07.750 --> 00:04:10.379
So sometimes it's called screen access software.

00:04:10.379 --> 00:04:14.879
It speaks everything on the screen so clearly
it text the speech capability in VoiceOver.

00:04:14.879 --> 00:04:19.399
Indeed is very, very strong and it's getting
stronger as I'm going to demo in a couple of minutes.

00:04:19.399 --> 00:04:26.299
So if you have seen VoiceOver or any of our
marketing materials, VoiceOver for Tiger,

00:04:26.300 --> 00:04:28.230
which has been shipping for two years now.

00:04:28.230 --> 00:04:34.140
One of the things that's been really resonating
with our customers is our collaborative experience.

00:04:34.139 --> 00:04:40.019
And that is when you're running VoiceOver as
a user who's visually impaired for example,

00:04:40.019 --> 00:04:42.659
there's some things that happen on the
screen that you might not be able to see.

00:04:42.660 --> 00:04:46.490
Or if you have low vision, there's some
things on the screen which might help you

00:04:46.490 --> 00:04:48.569
because you can make the fonts really big.

00:04:48.569 --> 00:04:52.159
But what's cool about this is if you're a
sighted user and you happen to be working

00:04:52.160 --> 00:04:56.740
with somebody who's visually impaired, you can understand
what they're doing on that computer and they can understand

00:04:56.740 --> 00:04:58.610
and hear what you're doing on your computer.

00:04:58.610 --> 00:05:02.610
And we think, and feedback has
told us this instinct was correct.

00:05:02.610 --> 00:05:06.360
After a couple of years of shipping, we think
that this is resonating with our customers.

00:05:06.360 --> 00:05:12.050
You know, a child in school who happens to be
visually impaired has the right to work side-by-side

00:05:12.050 --> 00:05:15.810
with their sighted peer or their
sighted parent or vice versa.

00:05:15.810 --> 00:05:18.009
So really, really nice message.

00:05:18.009 --> 00:05:20.469
So what's new for VoiceOver and Leopard.

00:05:20.470 --> 00:05:21.760
Well, there's lots of new features.

00:05:21.759 --> 00:05:23.399
We've taken a lot of feedback.

00:05:23.399 --> 00:05:25.799
There's two things I want to focus briefly on today.

00:05:25.800 --> 00:05:31.199
The first, some of you may have heard already
and that's this great new voice named Alex.

00:05:31.199 --> 00:05:33.389
Alex just sounds really, really good.

00:05:33.389 --> 00:05:37.839
I'm going to demo Alex in a couple of minutes.

00:05:37.839 --> 00:05:42.009
It's basically a new approach to concatenative synthesis.

00:05:42.009 --> 00:05:43.829
It's really better just to demo it.

00:05:43.829 --> 00:05:48.250
One of the things that it provides and
it's something that's very important

00:05:48.250 --> 00:05:54.829
to screen reader users is incredibly fast talking while
still sounding good and still being understandable.

00:05:54.829 --> 00:05:56.550
And I'm going to show you that in a second.

00:05:56.550 --> 00:06:00.250
And the other thing is Alex is such
a nice voice, you can actually with,

00:06:00.250 --> 00:06:04.100
with good quality audio, you can actually hear Alex breathe.

00:06:04.100 --> 00:06:06.480
Take breaths before speaking something.

00:06:06.480 --> 00:06:07.870
Then say something.

00:06:07.870 --> 00:06:11.240
And it turns out that that's a very
important que for users who are listening.

00:06:11.240 --> 00:06:15.829
In fact, us, not just users, anybody who's sighted
or non-sighted who's listening to speaking,

00:06:15.829 --> 00:06:20.060
we actually take a lot of ques from things that we
wouldn't think about when we're listening to speaking.

00:06:20.060 --> 00:06:23.680
And so Alex takes advantage of those
and offers some of those things.

00:06:23.680 --> 00:06:27.650
So big feature number two is Braille support.

00:06:27.649 --> 00:06:32.849
So VoiceOver will be adding refreshable
Braille support to Leopard.

00:06:32.850 --> 00:06:37.370
And for those of you who, do you have
a display I can show, I can show?

00:06:37.370 --> 00:06:42.370
For those of you who don't know what Braille is
about, I'm going to give a little Braille primer here.

00:06:42.370 --> 00:06:45.840
But basically, they're these devices.

00:06:45.839 --> 00:06:46.519
This is one.

00:06:46.519 --> 00:06:48.439
There are dozens of them.

00:06:48.439 --> 00:06:50.430
And they have a row of Braille cells.

00:06:50.430 --> 00:06:52.220
I'll talk about Braille in just a second.

00:06:52.220 --> 00:06:55.810
And a user who's visually impaired,
he might have one of these displays,

00:06:55.810 --> 00:07:01.589
might prefer to read in Braille what's happening on their
screen rather than hear it or have a combination of it.

00:07:01.589 --> 00:07:06.939
And so they would take this and they'd take their USB cable
or their or what have you, they plug into their system

00:07:06.939 --> 00:07:11.769
and then you would sit it down in front and they
would be feeling what's going on in their computer.

00:07:11.769 --> 00:07:13.919
And so this is a refreshable Braille display.

00:07:13.920 --> 00:07:18.210
So I'm going to demonstrate this with VoiceOver in a second.

00:07:18.209 --> 00:07:24.560
But before I do that, it's important to have a little
Braille primer so that everybody is on the same page.

00:07:24.560 --> 00:07:28.750
So Braille, if you've ever, if you're
sighted and you're not familiar with Braille,

00:07:28.750 --> 00:07:31.850
you may have noticed some Braille on
elevators and placards and things.

00:07:31.850 --> 00:07:34.140
And you typically see it in six dots.

00:07:34.139 --> 00:07:37.490
And these are, these dots are very
standardized, one through six.

00:07:37.490 --> 00:07:42.189
And in computer Braille, we actually
add two more dots because we can

00:07:42.189 --> 00:07:44.269
and it gives us more options of what to display.

00:07:44.269 --> 00:07:50.039
And basically, these dots when used in
different combinations are symbols for letters

00:07:50.040 --> 00:07:53.030
of the alphabet or numbers or punctuation or whatnot.

00:07:53.029 --> 00:08:00.039
So there's an A. There's a B. There's a C. Sometimes
you can combine multiple cells to mean something

00:08:00.040 --> 00:08:08.150
so for example capitalizing a letter could, with six dot
Braille, could mean add dot six preceding the letter.

00:08:08.149 --> 00:08:13.439
Adding those cells that you could see
there, dots four, five, three, four,

00:08:13.439 --> 00:08:16.860
five and six preceding something
converts a letter to a number.

00:08:16.860 --> 00:08:21.430
In computer Braille you can accomplish the same
thing by using dot seven, instead of the prefix cell.

00:08:21.430 --> 00:08:23.259
So it gives us some more options.

00:08:23.259 --> 00:08:28.870
So anyway, Braille cells are put
together to create Braille words.

00:08:28.870 --> 00:08:32.610
And Braille words are put together
to create Braille phrases.

00:08:32.610 --> 00:08:38.180
Now, you could imagine, one thing about
Braille is, Braille is a standard size.

00:08:38.179 --> 00:08:41.739
Visually, its size is about 18-point font.

00:08:41.740 --> 00:08:43.450
18-point font is pretty big.

00:08:43.450 --> 00:08:45.220
And Braille is also fixed width.

00:08:45.220 --> 00:08:52.029
So you can imagine that if I had a dictionary
or an encyclopedia or a long book, you know,

00:08:52.029 --> 00:08:57.449
big volume of Harry Potter or what have you, it
would take up a very, very large amount of space.

00:08:57.450 --> 00:08:58.940
Sometimes book shelve space.

00:08:58.940 --> 00:09:04.360
So one of the things that's done to counteract
that is the concept of contracted Braille,

00:09:04.360 --> 00:09:12.210
which means sometimes phonetic sounds are of
common word groups are turned into symbols

00:09:12.210 --> 00:09:14.769
so that we can shorten the amount of Braille that's taken.

00:09:14.769 --> 00:09:21.220
And it turns out that Braille readers are
generally really, really fast at reading Braille.

00:09:21.220 --> 00:09:28.379
Shockingly, faster than those of us who
are sighted might, we would be surprised.

00:09:28.379 --> 00:09:32.029
Just as surprised as we are to know
that somebody who's listening to a voice

00:09:32.029 --> 00:09:35.319
at an incredibly fast rate can
actually understand what's going on.

00:09:35.320 --> 00:09:41.530
And it's important when we support Braille for us to
support both contracted and non-contracted and to know

00:09:41.529 --> 00:09:46.539
when to contract and when not to contract because depending
on whether you're editing text or you're reading buttons,

00:09:46.539 --> 00:09:50.019
we have to do the right thing and provide the right options.

00:09:50.019 --> 00:09:51.649
And so that's what I'm going to demonstrate.

00:09:51.649 --> 00:09:54.500
In fact, the best way to that is actually to go to demo.

00:09:54.500 --> 00:09:55.529
So, oh, actually, no.

00:09:55.529 --> 00:09:58.779
Before I go to demo, one more thing.

00:09:58.779 --> 00:10:07.339
So now here's our updated screen shot with voice-over
running a Leopard and, for those of you who are looking

00:10:07.340 --> 00:10:12.980
at the screen, there are a couple of visual aspects to the
screen that are the most common hallmarks of voice-over.

00:10:12.980 --> 00:10:16.710
One of them is a rectangle, a black
rectangle around one of my icons.

00:10:16.710 --> 00:10:22.030
That's the voice-over cursor and that helps somebody whose
sighted see what voice-over is currently focusing on.

00:10:22.029 --> 00:10:28.919
Then there's also this caption panel that you can
turn on and this always prints what's being spoken.

00:10:28.919 --> 00:10:31.519
So, somebody who can't understand the fast speech

00:10:31.519 --> 00:10:37.299
that somebody might be using can just read it
right there and they know exactly what was spoken.

00:10:37.299 --> 00:10:39.949
Well, Braille produces this other challenge.

00:10:39.950 --> 00:10:44.320
Now there's this physical device, somebody's not
even getting output, they're feeling dots on a page.

00:10:44.320 --> 00:10:48.250
Well, not it could be on a page, but in this
case, it's on a refreshable Braille display

00:10:48.250 --> 00:10:50.700
and so how do we add collaboration to that?

00:10:50.700 --> 00:10:53.990
So, we're introducing the concept of a Braille panel

00:10:53.990 --> 00:10:58.430
and the Braille panel will always
display what is on that Braille display.

00:10:58.429 --> 00:11:04.459
It will also translate in real time whether your in grade
one, grade two, that's contracted or non-contracted Braille,

00:11:04.460 --> 00:11:06.050
everything that is going to that Braille display.

00:11:06.049 --> 00:11:11.259
So, a sighted user, a teacher , a parent whose watching
their child learn Braille and use this Braille display

00:11:11.259 --> 00:11:14.019
and knows exactly what they are
reading when they're reading it.

00:11:14.019 --> 00:11:19.439
So, the best way to continue here is to show a demo.

00:11:19.440 --> 00:11:28.070
Ok, so, this demo's not going to be
standard voice-over demo where I chain myself

00:11:28.070 --> 00:11:31.180
to the keyboard and I get rid of the mouse and all that.

00:11:31.179 --> 00:11:34.209
Voice-over is kind of tried and true in that respect.

00:11:34.210 --> 00:11:38.570
This is sighted guy giving demo
of a couple of key technologies.

00:11:38.570 --> 00:11:41.730
I'm going to trade back and forth with
the mouse just to keep things moving.

00:11:41.730 --> 00:11:43.909
First thing I want to do is talk about the voice.

00:11:43.909 --> 00:11:48.659
Here's just a standard text document
and I'm going to turn on voice-over.

00:11:48.659 --> 00:11:49.500
>> Voice-over on.

00:11:49.500 --> 00:11:52.070
Text added Windowdemo.rtf.

00:11:52.070 --> 00:11:55.140
Voice-over is intended to provide
those who are blind, have low vision,

00:11:55.139 --> 00:11:57.659
or learning difficulties the ability to use a Macintosh.

00:11:57.659 --> 00:12:01.929
It's perfect for those who have never used a computer or a
screen-reader before, for those who are new to Macintosh,

00:12:01.929 --> 00:12:06.459
and for those using screen-readers on Mac OS 9 and
wants to take advantage of all Mac OS X has to offer.

00:12:06.460 --> 00:12:09.580
With voice-over, you'll be able to create
and edit word-processing documents,

00:12:09.580 --> 00:12:14.520
send email and browse the world-wide web, even
play chess, edit text, has keyboard focus.

00:12:14.519 --> 00:12:19.470
>> Ok, so, what do people think of the voice?

00:12:19.470 --> 00:12:22.040
Sound pretty good?

00:12:22.039 --> 00:12:28.809
We think it sounds really, really natural, but what's really
important is that there's not a single screen reader user

00:12:28.809 --> 00:12:33.589
on the planet who listens to the voice at that
speed unless this is your very, very first time.

00:12:33.590 --> 00:12:37.990
So what I'm going to do is I'm going to
speed up the voice to an acceptable speed.

00:12:37.990 --> 00:12:40.629
In fact, I'm going to jack it up to 100%.

00:12:40.629 --> 00:12:42.549
I'm just going to go into voice-over utility.

00:12:42.549 --> 00:12:45.490
>> Voice-over utility window, fifty

00:12:45.490 --> 00:12:47.000
>> And, I'm going to 100% speed.

00:12:47.000 --> 00:12:49.769
>> 100. Highlight 100.

00:12:49.769 --> 00:12:50.669
(Inaudible) whose time has come.

00:12:50.669 --> 00:12:52.059
Windowdemo dot rtf.

00:12:52.059 --> 00:12:55.089
Voice-over is intended to provide
those who are blind, have low vision,

00:12:55.090 --> 00:12:58.190
or learning difficulties the ability to use a Macintosh.

00:12:58.190 --> 00:13:05.550
It's perfect for those who have never used a computer or a
screen-reader before, for those who are new to Macintosh,

00:13:05.549 --> 00:13:09.069
and for those using screen-readers on Mac OS 9 and want to ?

00:13:09.070 --> 00:13:16.410
>> Ok, so what's important here is why you might
not just say Here, highlight this entire document

00:13:16.409 --> 00:13:23.269
and start reading it to me at 100% speed.

00:13:23.269 --> 00:13:27.840
What you want is the ability to
navigate exceptionally quickly

00:13:27.840 --> 00:13:33.310
and have your response be really,
really fast and know what's going on.

00:13:33.309 --> 00:13:35.779
So, as I arrow around?

00:13:35.779 --> 00:13:36.539
( Computer speaking )
>> if I go word by word.

00:13:36.539 --> 00:13:37.919
( Computer speaking )
>> In fact if I just lean on the cursor?

00:13:37.919 --> 00:13:41.370
( Computer speaking )
>> I want to be able to move around
and hear things really, really fast.

00:13:41.370 --> 00:13:44.070
So, that's what we think the new voice provides.

00:13:44.070 --> 00:13:48.600
So, the next thing I want to talk about is Braille.

00:13:48.600 --> 00:13:54.310
So, I am now going to enable the Braille caption
panel, so pretend, if you will, that I plug this in,

00:13:54.309 --> 00:14:00.149
but this is kind of a hard thing to demo to a
crowd in the dark who's not right on top of it.

00:14:00.149 --> 00:14:05.279
So, I'm going to turn on the Braille caption panel.

00:14:05.279 --> 00:14:10.319
What would happens here when I plug this in, voice-over
will automatically detect it and it will bring

00:14:10.320 --> 00:14:15.860
up the Braille caption panel by default so that
a sighted user can also see what is going on.

00:14:15.860 --> 00:14:16.980
>> Voice over utility window.

00:14:16.980 --> 00:14:18.139
Table one row selected.

00:14:18.139 --> 00:14:18.870
Row nine (inaudible) panel.

00:14:18.870 --> 00:14:20.549
Text added Windowdemo dot rtf.

00:14:20.549 --> 00:14:24.289
>> All right, here's the caption
panel and let's do another thing here.

00:14:24.289 --> 00:14:24.360
( Computer speaking )

00:14:24.360 --> 00:14:25.930
>> Let's go to speech?

00:14:25.929 --> 00:14:26.129
( Computer speaking )

00:14:26.129 --> 00:14:27.850
>> Let's jack the voice down a little bit.

00:14:27.850 --> 00:14:28.980
( Computer speaking )
>> And now as I move around.

00:14:28.980 --> 00:14:31.920
>> l i n d comma space h a v e

00:14:31.919 --> 00:14:35.279
>> An interesting thing is happening here.

00:14:35.279 --> 00:14:41.709
So you see, I'm one the second line and the second line
starts with the word blind, have low vision and you see

00:14:41.710 --> 00:14:45.560
where the cursor is blinking, notice
there is a cursor blinking

00:14:45.559 --> 00:14:49.250
down in the caption panel right above my finger here.

00:14:49.250 --> 00:14:56.779
What we're doing is straddling dots eight and seven of the
previous and the following cell to mean where the cursor is,

00:14:56.779 --> 00:15:02.879
which maps exactly to the way Mac OS X actually does cursor
positioning with voice-over and you can just move around.

00:15:02.879 --> 00:15:05.610
>> space, l o w, space, v i s i

00:15:05.610 --> 00:15:09.710
>> and, also, notice another nuance
here, when that cursor is on a word,

00:15:09.710 --> 00:15:13.000
that word is non-contracted and
as soon as I walk off a word?

00:15:13.000 --> 00:15:14.710
>> o, n, space

00:15:14.710 --> 00:15:16.280
>> ?it contracts.

00:15:16.279 --> 00:15:21.209
So, that basically means when I'm in text and I'm on
something it selected, you know that when you're feeling

00:15:21.210 --> 00:15:24.970
that thing that's selected, you're getting
letter for letter which is exactly what you want,

00:15:24.970 --> 00:15:29.790
but everything that's surrounding it that the
selection is not touching is contracted and, of course,

00:15:29.789 --> 00:15:33.329
you can turn contractions off, so
if I Shift plus highlight something?

00:15:33.330 --> 00:15:35.610
>> i, i, the, space, w, o, l, space, e

00:15:35.610 --> 00:15:38.480
>> it will contract everything that touches the selection.

00:15:38.480 --> 00:15:39.759
Let's do this?

00:15:39.759 --> 00:15:49.639
>> (inaudible) browse the worldwide web, e, t, a, r, s,
space, t, f, space, o, f , space, a c, i, t, o, f, h.

00:15:49.639 --> 00:15:52.759
>> Ok, so this is the face of Braille on a Macintosh.

00:15:52.759 --> 00:15:53.899
So, there you have it.

00:15:53.899 --> 00:16:06.860
That's Mac OS X with Braille support
and I'm going to go back to slides.

00:16:06.860 --> 00:16:14.230
Ok, so now I want to talk about some accessibility basics
and this is really just the primer before James comes up

00:16:14.230 --> 00:16:16.289
and goes a little deeper about some things.

00:16:16.289 --> 00:16:17.519
Accessibility basics?

00:16:17.519 --> 00:16:21.250
Mac OS X accessibility really comes in three forms.

00:16:21.250 --> 00:16:24.500
The first form is just universal access.

00:16:24.500 --> 00:16:30.350
We've had really good universal access support with all
sorts of features that don't necessarily relate directly

00:16:30.350 --> 00:16:35.740
to screen readers or assistive technology, but
there's zooming, making the screen contrasty,

00:16:35.740 --> 00:16:40.730
and different speaking features and things
like that and most apps just work with them.

00:16:40.730 --> 00:16:49.090
Then there's also the concept of full keyboard navigation,
again all the plumbing is there in Cocoa and in Carbon

00:16:49.090 --> 00:16:55.580
to do keyboard navigation and to support that through
the accessibility hierarchy in all the right places,

00:16:55.580 --> 00:17:00.990
but you still need to do a little bit to ensure
that your application can be driven without a mouse.

00:17:00.990 --> 00:17:03.080
That's something that's really important.

00:17:03.080 --> 00:17:07.950
Part of a QA cycle should be Hmm, let me unplug my
mouse and see if I can actually use this application

00:17:07.950 --> 00:17:11.370
and make good use of it and get to every feature.

00:17:11.369 --> 00:17:15.129
And, then finally, there are assistive
applications like voice-over that want to talk

00:17:15.130 --> 00:17:17.700
to your application and drive it via remote control.

00:17:17.700 --> 00:17:19.880
So, that's what we're talking about today.

00:17:19.880 --> 00:17:25.650
So, accessibility basics, you've got an assistive
application out there or perhaps its Automator,

00:17:25.650 --> 00:17:29.640
perhaps its x-ray, or perhaps it's your testing tool, right.

00:17:29.640 --> 00:17:35.470
But, let's say it's an assistive application and in
voice-overs case it's just this process that's running,

00:17:35.470 --> 00:17:41.059
that's fairly tightly coupled with the rest of the
operating system and it has an assistive user interface.

00:17:41.059 --> 00:17:44.399
It's a different user interface, it's not
one built with Cocoa widgets and buttons.

00:17:44.400 --> 00:17:49.900
It happens to speak and now it happens to Braille
and what it needs to do is it needs to communicate

00:17:49.900 --> 00:17:53.590
with your application and it wants
to do it using this accessibility API

00:17:53.589 --> 00:17:55.869
that we've been shipping for several years.

00:17:55.869 --> 00:18:01.329
The real question comes down to is the application we
want to talk to, your application, is it accessible?

00:18:01.329 --> 00:18:03.409
And, so, what does this mean?

00:18:03.410 --> 00:18:12.130
Perhaps, more explicitly, how is your application coded
and should an assistive application have care about that,

00:18:12.130 --> 00:18:14.100
in fact, we don't want to care about that.

00:18:14.099 --> 00:18:19.629
So, one of the primary things that the accessibility
APIs do, is they abstract the notion of how your coding

00:18:19.630 --> 00:18:23.590
into a common language and that
common language is the UI element.

00:18:23.589 --> 00:18:31.019
It's the unit of access that one uses
when their accessing your application.

00:18:31.019 --> 00:18:37.089
So, everything is a user interface
element to an assistive application.

00:18:37.089 --> 00:18:45.629
There are windows, every window is a user interface
element, every button, text field, even larger canvases

00:18:45.630 --> 00:18:51.160
and things nested with it inside
canvases and elements live in a hierarchy.

00:18:51.160 --> 00:18:58.250
Elements have parents or elements have a parent
chain and elements can zero or more children.

00:19:01.029 --> 00:19:09.160
Your application is also an element, so everything
uses this element as its unit of communication.

00:19:09.160 --> 00:19:12.460
We contact your application element
and we say Give me your window elements

00:19:12.460 --> 00:19:16.860
and then we ask your window element Give me
your widget elements and so on and so forth.

00:19:16.859 --> 00:19:22.799
Then what we do with those elements is we deal
with their attributes, sometimes we ask for them,

00:19:22.799 --> 00:19:25.869
sometimes we set them, sometimes we call actions on them,

00:19:25.869 --> 00:19:30.759
like we say press for a button, and
sometimes we receive notifications.

00:19:30.759 --> 00:19:35.339
For example, if somebody slides a slider, we
need to be able to know when that slider is slid

00:19:35.339 --> 00:19:39.599
so that we can speak something to the user
or Braille its value or what have you.

00:19:39.599 --> 00:19:43.750
So, attributes really describe an element.

00:19:43.750 --> 00:19:49.759
For example, I might have a UI element that's a button in
an application, for example this address button in mail,

00:19:49.759 --> 00:19:52.690
and there are all these attributes that I can ask about.

00:19:52.690 --> 00:19:56.090
Some of these are attributes that you
get for free by implementing Cocoa.

00:19:56.089 --> 00:19:59.849
In fact, most of them you get for free
by implementing Cocoa and even Carbon.

00:19:59.849 --> 00:20:05.750
Some of them you should never change just because the
role and the role description are very standard things

00:20:05.750 --> 00:20:08.430
that voice-over relies upon and
it'll just do the right thing.

00:20:08.430 --> 00:20:12.930
Then, sometimes, there are contextual
attributes that only you can predict.

00:20:12.930 --> 00:20:18.060
Like if you have an image with a picture on it, we
don't know what that is until you add an AX description

00:20:18.059 --> 00:20:26.639
that says This picture means stop and so, then we can
speak Stop when land on that button or whatever it means.

00:20:26.640 --> 00:20:34.480
This picture means delete all files, maybe the user would
want to avoid that, so they should know what that is.

00:20:34.480 --> 00:20:46.789
So, attributes are, at the basic level, presented in
your code by some methods and fairly easy to implement.

00:20:46.789 --> 00:20:53.970
James has several examples, some of which he's
going to reference that we've shown in years past,

00:20:53.970 --> 00:20:56.160
and then he's going to build on a new one today.

00:20:56.160 --> 00:21:03.610
But, basically you add attributes by just implementing
or sub-classing methods in the NS accessibility protocol

00:21:03.609 --> 00:21:09.319
and returning Here's my list of attributes or
I'll take a value for this attribute and set it.

00:21:09.319 --> 00:21:11.450
It's fairly to implement.

00:21:11.450 --> 00:21:19.799
Actions, same thing, there are some
standard defined actions that are very basic.

00:21:19.799 --> 00:21:23.519
Actions aren't actions like print
this panel or save this document

00:21:23.519 --> 00:21:27.109
or something that's more workflow based, they are gestures.

00:21:27.109 --> 00:21:33.559
Press open menu and so you just put actions in all the
right places and it means the user with a special device

00:21:33.559 --> 00:21:36.329
or assisitive application can do those gestures.

00:21:36.329 --> 00:21:44.169
The API for those is very similar, there're methods that
you would override for adding actions and returning them

00:21:44.170 --> 00:21:48.410
and for invoking actions when you're asked to.

00:21:48.410 --> 00:21:50.290
Then there are notifications.

00:21:50.289 --> 00:21:54.700
Notifications, a little more complicated, you
get them for free for the most part with Cocoa,

00:21:54.700 --> 00:21:58.430
but basically if you've got a widget,
for example, that changes the value,

00:21:58.430 --> 00:22:00.960
you would need to post the value change notification.

00:22:00.960 --> 00:22:06.400
Notifications are really important aspect
of assistive applications because we need

00:22:06.400 --> 00:22:15.110
to know what your application is doing so that
we can say it in a timely fashion to the user.

00:22:15.109 --> 00:22:18.289
There's also the notion of hidden elements.

00:22:18.289 --> 00:22:19.909
This is a really important point.

00:22:19.910 --> 00:22:25.180
James, I think, has some really good slides coming up which
talk about this, but when you code your application most

00:22:25.180 --> 00:22:32.019
of the time you're coding, sometimes for
convenience with the kits, lots of grouped views.

00:22:32.019 --> 00:22:35.819
These views, sometimes, aren't apparent to the user.

00:22:35.819 --> 00:22:42.629
What the user might see is two views rather than four or
five and it's important that the accessibility hierarchy

00:22:42.630 --> 00:22:46.030
that you create, that's represented, is what the user sees,

00:22:46.029 --> 00:22:51.029
not what you see in interface builder
or what you see in your view hierarchy.

00:22:51.029 --> 00:22:56.329
So, there's an easy method to implement on your views
where you can say Even though this view's in my hierarchy,

00:22:56.329 --> 00:23:02.279
accessibility shouldn't show it and, in
fact, if you just take advantage of NSview,

00:23:02.279 --> 00:23:08.309
the whole set hidden mechanism hides this
for you and you never need to deal with it.

00:23:08.309 --> 00:23:10.639
Then, a really important aspect is hit testing.

00:23:10.640 --> 00:23:16.220
One of our accessibility tools, Accessibility
Inspector, relies on this and that's, basically,

00:23:16.220 --> 00:23:20.000
when I move my mouse around the screen,
anywhere that mouse is hovering over,

00:23:20.000 --> 00:23:24.240
I should be able to ask your application
What's the UI element under that point?

00:23:24.240 --> 00:23:25.920
It's fairly easy to implement.

00:23:25.920 --> 00:23:30.600
Its usually, again, you get it all for free with Cocoa and
Carbon for the most part, but when you've got a custom view

00:23:30.599 --> 00:23:33.549
with stuff inside it, you need
to make those things available.

00:23:33.549 --> 00:23:42.139
Ok, so, now I going to ask James to
come up and talk to you in more detail.

00:23:45.140 --> 00:23:48.250
>> Thanks, Eric.

00:23:48.250 --> 00:23:49.990
Hi. My name's James Dempsey.

00:23:49.990 --> 00:23:55.529
I'm an engineer on the Cocoa frameworks
team and one of the main things that I do

00:23:55.529 --> 00:24:01.740
on the team is work on the accessibility portions of Cocoa.

00:24:01.740 --> 00:24:11.569
So, first we're going to do a brief Leopard update,
talk about some of the new features and functionality

00:24:11.569 --> 00:24:16.599
that we've added in the frameworks
to accessibility in Leopard.

00:24:16.599 --> 00:24:27.089
Then we're going to talk a little bit about implementing
accessibility in terms of kind of methodology

00:24:27.089 --> 00:24:33.679
that you can use in terms of doing so and
we're going to use, as a specific example,

00:24:33.680 --> 00:24:37.600
a new technology introduced in
Leopard which is CoreAnimation.

00:24:37.599 --> 00:24:46.589
So, Leopard update, we're going
to go through these one by one.

00:24:46.589 --> 00:24:54.829
The first thing we have done in Leopard, Bertrands, I
think, in his state of the union was talking about CoverFlow

00:24:54.829 --> 00:25:03.889
and the Finder in mentioning that we're now able to
put Cocoa views in the midst of Carbon applications.

00:25:03.890 --> 00:25:07.920
In fact, in the Finder, CoverFlow
is a Cocoa view in a Carbon app

00:25:07.920 --> 00:25:14.269
and there's a new HI toolbox, Class HI Cocoa view.

00:25:14.269 --> 00:25:21.839
What we've done is done a good deal of work to do
Carbon and Cocoa integration to make sure that, first,

00:25:21.839 --> 00:25:28.209
Cocoa windows in Carbon applications, all of
their accessibility will come through and, also,

00:25:28.210 --> 00:25:35.279
if you're using HI Cocoa view that as long
as that Cocoa view is accessible that all

00:25:35.279 --> 00:25:43.809
of the accessibility will just work for you no matter
whether you use that in a Carbon app or a Cocoa app.

00:25:43.809 --> 00:25:50.230
So, toolbars, in Tiger and earlier.

00:25:50.230 --> 00:25:56.150
Well, actually, as long we've had toolbars there have
been two ways that you can make a toolbar item in Cocoa.

00:25:56.150 --> 00:25:59.740
You could give us an image or you could give us a view.

00:25:59.740 --> 00:26:04.470
If you gave us an image we would take
that image and the title you gave us

00:26:04.470 --> 00:26:07.710
and make one nice big button out of that image.

00:26:07.710 --> 00:26:15.779
If you gave us a view we would use that view as a group
and then all of the elements in it would be sub-elements,

00:26:15.779 --> 00:26:23.049
which makes for some, in some cases, very complicated
toolbar items, especially if you gave us an NS button.

00:26:23.049 --> 00:26:31.069
We would have a group with a button and a label when
really what you probably wanted was just one big button.

00:26:31.069 --> 00:26:38.490
We, also, in the case of things like mail where people
are using segmented controls and multiple labels,

00:26:38.490 --> 00:26:41.960
we would end up with two sets of information.

00:26:41.960 --> 00:26:50.960
So, in Tiger we've done a lot of work for some NSToolbar
enhancements where, for things like segmented controls

00:26:50.960 --> 00:26:55.210
with multiple labels or NSButtons, we will treat those items

00:26:55.210 --> 00:27:02.059
as one giant button rather than
a complex set of UI elements.

00:27:03.210 --> 00:27:12.180
So, we've also taken a look at things like
QuickTime Player and these ideas of media timelines

00:27:12.180 --> 00:27:19.110
and we've introduced a new sub-role of a slider AX Timeline.

00:27:19.109 --> 00:27:21.500
And, so, if you're building an application

00:27:21.500 --> 00:27:28.059
and you are implementing your own media
slider, this would be the sub-role to use.

00:27:28.059 --> 00:27:34.929
Note that, as opposed to a typical slider which
has one slider value indicator, in QuickTime,

00:27:34.930 --> 00:27:40.549
if you have QuickTime Pro and you're editing
the movie, there are three places you can edit.

00:27:40.549 --> 00:27:45.930
There's the current time, as well as an
end point and an out point for the edit.

00:27:45.930 --> 00:27:51.240
We represent these in an AX timeline
as having value indicator children.

00:27:51.240 --> 00:27:57.809
It's also nice to note that a value indicator
now actually has an AX value in Leopard.

00:27:57.809 --> 00:28:03.990
If there are multiple value indicators, you should
identify them with a separate AX description

00:28:03.990 --> 00:28:07.400
for each so that the user can tell them apart.

00:28:07.400 --> 00:28:14.259
If you're writing an assistive app also be on the lookout
for apps like QuickTime reporting this new sub-role.

00:28:14.259 --> 00:28:25.289
As we were developing Leopard we noticed that, over
time, we were seeing a lot of grids showing up.

00:28:25.289 --> 00:28:31.799
So, this is image kits, its image
browser view is in the form of a grid.

00:28:31.799 --> 00:28:37.289
This is PDF kit has a new thumbnail
view which again, very grid-like,

00:28:37.289 --> 00:28:44.029
and even the DOC with its new stacks has a grid orientation.

00:28:44.029 --> 00:28:51.569
A grid is not quite a table, which might be one way you
might think of accessorizing it and it's not quite a list.

00:28:51.569 --> 00:28:58.210
In fact, it's kind of more like a list because
it's an ordered group of things, however,

00:28:58.210 --> 00:29:00.970
there's no information about tables and rows.

00:29:00.970 --> 00:29:09.120
So, we have added a new role in Leopard,
AXGrid, for these types of interfaces.

00:29:09.119 --> 00:29:16.149
The children of that UI element are ordered, but
we also give you information about how many rows

00:29:16.150 --> 00:29:20.630
and how many columns and whether it's row major or not.

00:29:20.630 --> 00:29:27.160
So, ordered by row is a Boolean.

00:29:27.160 --> 00:29:33.420
We also, as we've been going through in Tiger have
noticed that occasionally you'll have a slider

00:29:33.420 --> 00:29:37.279
where it's providing a very complex value.

00:29:37.279 --> 00:29:44.180
For example, in the energy saver panel, you
can pick one minute, one hour, or never,

00:29:44.180 --> 00:29:49.590
and it's very hard to let a user
know that a hundred means never.

00:29:49.589 --> 00:29:55.319
It's hard to map never to a value
and so we've added a new attribute

00:29:55.319 --> 00:29:59.470
for these sorts of situations, AxValue Description.

00:29:59.470 --> 00:30:03.049
It's an optional attribute and you should use it

00:30:03.049 --> 00:30:10.210
if you're accessorizing whenever AX Value does
not provide enough information for the user.

00:30:10.210 --> 00:30:19.039
It should be very similar to an AX description, a localized
lowercase string and you should dynamically change it

00:30:19.039 --> 00:30:26.009
so that it matches whatever the appropriate
value would be for, in this case, the slider.

00:30:26.009 --> 00:30:31.299
So, for energy saver, it might be anything
like, they tend to concatenate things,

00:30:31.299 --> 00:30:38.149
so somewhere in the middle there you might get an hour and
fifteen minutes, it might be never, it might be a minute.

00:30:38.150 --> 00:30:46.570
AX timelines would also be a good candidate for adding an AX
value description since, again, you are specifically talking

00:30:46.569 --> 00:30:53.240
about a start time and an end time, so often
giving that description in some sort of time code

00:30:53.240 --> 00:30:56.890
of minutes and seconds would be very useful.

00:30:58.930 --> 00:31:04.140
In Tiger, I believe it was Tiger, we
added in the Cocoa text system the ability

00:31:04.140 --> 00:31:07.430
to be able to select multiple pieces of text.

00:31:07.430 --> 00:31:17.029
However, we now have the ability to get
those selected text ranges via accessibility.

00:31:17.029 --> 00:31:24.069
It's an optional attribute, however, all Cocoa text
objects implement it and it returns the full array

00:31:24.069 --> 00:31:31.809
of selected text ranges of the already existing attributes
selected text range will still behave as it did before,

00:31:31.809 --> 00:31:34.980
which is returning that first selected range.

00:31:34.980 --> 00:31:43.079
And then the last thing I'd like to mention in
the Leopard update is Interface Builder 3 point 0.

00:31:43.079 --> 00:31:49.109
Interface Builder has had a very nice makeover.

00:31:49.109 --> 00:31:53.289
I've been playing with it a great deal
over the last few months in Leopard

00:31:53.289 --> 00:31:58.519
and one thing they have done is
they've moved some things around.

00:31:58.519 --> 00:32:02.960
So, I wanted to point out things that you might be
used to in previous versions of Interface Builder,

00:32:02.960 --> 00:32:05.650
where they've moved to in the new version.

00:32:05.650 --> 00:32:13.950
So, for things like adding AX descriptions, which are
incredibly useful for images or buttons with images,

00:32:13.950 --> 00:32:19.019
for instance, or AX help settings and the
Identity Inspector we can put those on.

00:32:19.019 --> 00:32:27.009
And, then if we're connecting to or dragging to
connect different UI elements for a link UI element

00:32:27.009 --> 00:32:33.390
or to say that this particular text field, its
title UI element is this piece of static text.

00:32:33.390 --> 00:32:39.990
We, just like before, can control drag from one element
to another in Interface Builder, but nicely enough,

00:32:39.990 --> 00:32:47.460
all of the accessibility connections show on this pop-up
and it's handled exactly like all other connections.

00:32:47.460 --> 00:32:51.360
We don't have to go to a separate
panel anymore, so that's very nice.

00:32:51.359 --> 00:33:04.259
I haven't done technical training for a while, I always
feel like saying Any questions??, but not this time around.

00:33:04.259 --> 00:33:06.140
We'll have that at the end.

00:33:06.140 --> 00:33:08.080
So, implementing accessibility.

00:33:08.079 --> 00:33:13.119
As I've been working on accessibility,
I've been thinking about it.

00:33:13.119 --> 00:33:23.279
We often think in terms of voice-over and kind of the
result that we get in terms of the speakable text,

00:33:23.279 --> 00:33:29.349
but when we think about it also in terms of
things like Automator's watch me do feature

00:33:29.349 --> 00:33:32.919
or Xray or using it as a testability tool.

00:33:32.920 --> 00:33:39.360
I was kind of thinking about accessibility and
what it really is at the heart of it in terms

00:33:39.359 --> 00:33:49.159
of the implementation and, at least in my mind, it's an
out of process experience for your user interface and,

00:33:49.160 --> 00:33:58.550
if we think about it, it's a little bit like an out of body
experience where kind of all your pixels are left behind,

00:33:58.549 --> 00:34:03.960
you're not really drawing the particular images,
and its only the very core and the very essence

00:34:03.960 --> 00:34:11.659
of your user interface that's kind of over here
in this other process while the apps running.

00:34:11.659 --> 00:34:19.980
And, so, it's a very powerful notion or this wire
frame of your user interface, the very essence of it,

00:34:19.980 --> 00:34:24.340
being able to be projected into
another process and controlled.

00:34:24.340 --> 00:34:28.670
It's actually a very functional out of process experience.

00:34:28.670 --> 00:34:37.180
So, we can find out notifications that things have changed,
so as things update in your application, of course,

00:34:37.179 --> 00:34:41.769
notifications cause us to be able to
get information from that other process.

00:34:41.769 --> 00:34:43.920
We can drive the application from there.

00:34:43.920 --> 00:34:52.599
If we're just pressing a button in one place and it takes
effect on the other, dismiss the sheet and we can get a lot

00:34:52.599 --> 00:34:57.059
of information about each piece of the user interface.

00:34:57.059 --> 00:35:04.340
It's an extraordinarily lightweight representation
of your user interface and, at least for me,

00:35:04.340 --> 00:35:08.820
just from a conceptual point of
view that's a very, very cool thing.

00:35:08.820 --> 00:35:17.130
But, also I think that mental model can help a great
deal as you go about making your application accessible

00:35:17.130 --> 00:35:26.570
because although, yes, the end result is voice-over gets
to use it and interact with it and assistive devices

00:35:26.570 --> 00:35:30.150
and assistive applications and tools also get to do it.

00:35:30.150 --> 00:35:36.230
In a sense, what you are doing when you make your
application accessible is you are giving the best possible,

00:35:36.230 --> 00:35:44.099
or are trying to give the best possible, representation
of your user interface to these other applications

00:35:44.099 --> 00:35:49.610
and mapping what's going on in your app
to what's going on in those applications.

00:35:52.510 --> 00:35:57.390
So, how do we implement accessibility?

00:35:57.389 --> 00:36:03.489
We'll talk through these, a number of these
topics we have definitely covered in the past,

00:36:03.489 --> 00:36:06.199
so there are a few that we will spend a little less time on.

00:36:06.199 --> 00:36:11.000
They're very well documented on our site
as well, but we'll certainly mention them.

00:36:11.000 --> 00:36:14.250
First, test using accessibility clients.

00:36:14.250 --> 00:36:17.539
We have two accessibility specific utilities.

00:36:17.539 --> 00:36:25.630
A verifier, that if you've never really touched
accessibility on your app, you can fire up this verifier,

00:36:25.630 --> 00:36:33.680
set it to your running app and let it loose, kind of
hit test and it will run through and do a verification

00:36:33.679 --> 00:36:36.899
to see kind of what kind of shape your application is in.

00:36:36.900 --> 00:36:43.559
Do you have buttons that have images on them, no
descriptions so nobody can tell what they are?

00:36:43.559 --> 00:36:46.779
Do you have big blank spots in your application?

00:36:46.780 --> 00:36:55.950
The Accessibility Inspector, so you can interactively
look at various pieces of your applications accessibility

00:36:55.949 --> 00:37:00.529
and then voice-over certainly an end-user application,

00:37:00.530 --> 00:37:05.870
but we've found that it's also
incredibly useful to use for testing.

00:37:07.369 --> 00:37:15.679
So, once you do that, probably the first thing
that you'll need to do and certainly the item to do

00:37:15.679 --> 00:37:23.279
that has the most bang for the buck, as they
say, is to add instance-specific information.

00:37:23.280 --> 00:37:29.640
So, in this case, we have two items in our user
interface and then on the left we have kind

00:37:29.639 --> 00:37:32.900
of that wire frame representation in the other process.

00:37:32.900 --> 00:37:35.630
In the first one, add playlist.

00:37:35.630 --> 00:37:41.079
What will come across automatically from
Cocoa, because we have the text already,

00:37:41.079 --> 00:37:43.969
is that it has an AX title of add playlist.

00:37:43.969 --> 00:37:49.809
So, in that other process, it is pretty
obvious what this button is going to do.

00:37:49.809 --> 00:37:57.009
However, at the bottom, we have this button with an image
in it and its title, it doesn't have a string for a title.

00:37:57.010 --> 00:38:02.910
There's nothing being displayed in the user
interface, so it's very difficult to tell

00:38:02.909 --> 00:38:10.299
from that assistive application what the heck is this
button for Is this the Don't press this button button?

00:38:10.300 --> 00:38:13.420
Hopefully not because I'm going to press it.

00:38:13.420 --> 00:38:16.320
So, how do we address that in Interface Builder?

00:38:16.320 --> 00:38:23.320
The easiest way is you select that button
and you add an AX description and, actually,

00:38:23.320 --> 00:38:28.550
I think they fixed my capitalization,
those should be lowercase add playlist.

00:38:28.550 --> 00:38:39.140
But, it should be a localized lowercase string and it
should not include the name of the user interface element.

00:38:39.139 --> 00:38:41.089
So, add playlist.

00:38:41.090 --> 00:38:48.700
The other thing you can do is, especially in
Interface Builder, is relate user interface elements.

00:38:48.699 --> 00:38:57.039
Somebody looking at the top one, a sighted user, it's pretty
obvious that that name label goes with that text field,

00:38:57.039 --> 00:39:06.300
however, it's a little less clear when we bring that over
into an assistive app and, so, we can add an attribute,

00:39:06.300 --> 00:39:14.720
the title UI element attribute, where we connect the
text field and have it refer to its static text label.

00:39:14.719 --> 00:39:18.329
Again, this we can do easily in Interface Builder.

00:39:18.329 --> 00:39:25.849
So, with just those two things, adding
descriptions and connecting relationships

00:39:25.849 --> 00:39:30.799
between the two user interface elements, all
in your NIB file, all in Interface Builder,

00:39:30.800 --> 00:39:39.370
small changes have massive usability results
on the other side for assistive applications.

00:39:39.369 --> 00:39:47.029
Another thing you made need to do are
make some sub-class specific tweaks.

00:39:47.030 --> 00:39:52.070
So, what we can do in Interface Builder,
we can add static pieces of information.

00:39:52.070 --> 00:39:57.320
This is related to that or this is an
add playlist button, but, for example,

00:39:57.320 --> 00:40:05.980
that slider where the value I think your description will
change depending on the value and obviously ahead of time we

00:40:05.980 --> 00:40:10.630
as the framework designers can't know what
value descriptions you're going to need.

00:40:10.630 --> 00:40:12.369
You need to write a bit of code.

00:40:12.369 --> 00:40:20.409
In this case you would subclass the slider and
then you would implement these two methods.

00:40:20.409 --> 00:40:26.859
You'd override accessibility attribute names because
you're going to be returning a new attribute.

00:40:26.860 --> 00:40:38.079
In this case accessibility value description attribute,
and then you would over accessibility attribute value

00:40:38.079 --> 00:40:41.460
and if the string or the attribute being looked for happened

00:40:41.460 --> 00:40:48.559
to be the value description you
would return the appropriate string.

00:40:48.559 --> 00:40:54.029
Now note it's very likely if you're
already, as the energy saver panel is,

00:40:54.030 --> 00:40:59.960
using that string in a particular tool tip it's
possible or probable that you already have a method

00:40:59.960 --> 00:41:03.340
that returns the right string, so you would just call that.

00:41:03.340 --> 00:41:06.440
If not you would obviously write a new method.

00:41:06.440 --> 00:41:16.130
And then if it's not that particular item you
just get the super classes value and off you go.

00:41:16.130 --> 00:41:25.010
So after we get through those items, kind of
tweaking some subclasses, adding descriptions,

00:41:25.010 --> 00:41:33.300
adding connections like title UI elements, we
might end up with seeing some trouble areas

00:41:33.300 --> 00:41:37.960
that get reported, and this is ripped from the headlines.

00:41:37.960 --> 00:41:41.929
This is, I was working with a developer
and we had this problem.

00:41:41.929 --> 00:41:47.019
They had an inspector with a bunch of buttons
across the top, and they'd use that to choose

00:41:47.019 --> 00:41:50.179
that to choose between different inspector paints.

00:41:50.179 --> 00:41:55.679
But then they would look at it in voice
over, or they'd use voice over with it,

00:41:55.679 --> 00:42:02.399
they would look at it in accessibility inspector and
what they'd up seeing there would look more like what's

00:42:02.400 --> 00:42:10.090
on the left, where they'd have these two
ends hanging out and we're looking at that.

00:42:10.090 --> 00:42:18.970
Why was that, well they were misusing a segmented
control, like really misusing a segmented control.

00:42:18.969 --> 00:42:25.730
They didn't like the look of the end caps but they liked
the look of what was in the middle so they made it too big,

00:42:25.730 --> 00:42:29.490
clipped it to the windows so that it looked right.

00:42:29.489 --> 00:42:38.639
They also noticed that as they used full keyboard navigation
that it would hit the first one which was off screen tabbed

00:42:38.639 --> 00:42:40.989
through the middle ones and hit the last one.

00:42:40.989 --> 00:42:44.000
So they turned off full keyboard navigation.

00:42:44.000 --> 00:42:46.269
They went out of their way to turn it off.

00:42:46.269 --> 00:42:50.699
So although it looked right, it wasn't right.

00:42:50.699 --> 00:42:58.899
And I think sometimes when we're developing applications,
the Macintosh, very graphical user interface,

00:42:58.900 --> 00:43:06.369
we often do get into this mindset that
if it looks right that it must be right.

00:43:06.369 --> 00:43:09.259
But obviously that is not the case.

00:43:09.260 --> 00:43:17.880
In this particular case the developer had first gotten
rid of full keyboard navigation on their path here,

00:43:17.880 --> 00:43:24.519
and then we're trying to figure out some way to lie
to accessibility that these two items weren't around.

00:43:24.519 --> 00:43:32.099
Now in this case the solution was fairly simple,
just to make a framework friendly change.

00:43:32.099 --> 00:43:39.250
They changed over to using a matrix
of button cells in radio mode

00:43:39.250 --> 00:43:43.639
and suddenly full keyboard navigation came back for free.

00:43:43.639 --> 00:43:49.210
Suddenly accessibility worked exactly
the way it was supposed to for free.

00:43:49.210 --> 00:43:56.530
So often although what we see on the screen is
on the left, a lot of what accessibility is,

00:43:56.530 --> 00:44:04.060
kind of conceptually is getting that out of
process experience, getting that representation

00:44:04.059 --> 00:44:15.219
of your user interface to be extraordinarily clean,
extraordinarily functional and usually one of the best ways

00:44:15.219 --> 00:44:21.500
to do that is to not fight the framework,
is to make framework friendly changes.

00:44:22.909 --> 00:44:28.989
Some other tips as you're thinking
about making framework friendly changes.

00:44:28.989 --> 00:44:34.169
The first is that sometimes you're possibly not sure

00:44:34.170 --> 00:44:41.099
if your making a custom UI element whether
you should subclass NS View or NS Control,

00:44:41.099 --> 00:44:47.170
and one thing that might help you decide in
terms of just how much accessibility you get

00:44:47.170 --> 00:44:55.610
for free is NS Views are very much about returning
their sub views as children, whereas controls assume

00:44:55.610 --> 00:44:59.070
that by default that a control is going to have a cell.

00:44:59.070 --> 00:45:02.740
So the control's cell is used as its child.

00:45:02.739 --> 00:45:09.909
So if you happen to be doing something with a lot of sub
views it's most likely that NS View is your best bet.

00:45:09.909 --> 00:45:14.899
That way you'll be able to use a lot
more of the accessibility for free.

00:45:14.900 --> 00:45:25.579
Another thing to note is that in coco it's the cells inside
of the control that do the chunk of the accessibility work.

00:45:25.579 --> 00:45:33.639
That allows us to take that cell and use it not only in
say the slider control itself or the text field itself,

00:45:33.639 --> 00:45:40.029
but also put it in matrices or put
it in table views or outline views.

00:45:40.030 --> 00:45:49.600
And so typically NS Controls implement accessibility is
ignored and returned yes, I'm ignored and it's the child,

00:45:49.599 --> 00:45:55.579
the cell of the control that is
really the thing that is communicating

00:45:55.579 --> 00:45:59.710
or talked to to get its accessibility information.

00:45:59.710 --> 00:46:02.280
So sometimes you'll be trying to
do something programmatically

00:46:02.280 --> 00:46:04.430
and you'll say oh, things aren't quite working.

00:46:04.429 --> 00:46:06.129
Why isn't this taking effect?

00:46:06.130 --> 00:46:11.769
And it turns out you've been talking to a control
when you should have been talking to the cell.

00:46:11.769 --> 00:46:17.670
We have some nice convenience methods
for getting to un-ignored descendants

00:46:17.670 --> 00:46:21.789
and children in the NS accessibility dot H header.

00:46:21.789 --> 00:46:23.570
So those are handy to use.

00:46:23.570 --> 00:46:33.170
And finally, I call it being actively lazy,
going out of your way to take advantage as much

00:46:33.170 --> 00:46:36.349
as possible as to what the framework provides.

00:46:36.349 --> 00:46:43.900
Sometimes as we saw with those segmented controls, an
accessibility issue is not really an accessibility issue.

00:46:43.900 --> 00:46:48.400
It's a well we're in a rush, we
did it this way, it looked right

00:46:48.400 --> 00:46:53.030
and we haven't gotten back around
to make it better yet issue.

00:46:53.030 --> 00:46:59.160
And so sometimes when you're dealing with an
accessibility issue the first thing to look at is,

00:46:59.159 --> 00:47:02.710
is this the cleanest way we can do this in coco anyway?

00:47:02.710 --> 00:47:10.110
Because if it's not possibly just moving to that
makes it better in many ways, not just accessibility.

00:47:10.110 --> 00:47:15.289
But also, certainly, we really do appreciate your feedback.

00:47:15.289 --> 00:47:22.750
So if you're working with coco, working with
accessibility, filing issues and enhancement requests either

00:47:22.750 --> 00:47:27.820
to the accessibility dev list or through
bug reporter is definitely greatly appreciated.

00:47:27.820 --> 00:47:35.190
We very much value that feedback, both about accessibility
issues but also about things that you want to do

00:47:35.190 --> 00:47:38.490
in the user interface that possibly we're not providing.

00:47:38.489 --> 00:47:45.639
Because if you have to create it yourself you have to make
it accessible yourself and if it's something that a lot

00:47:45.639 --> 00:47:53.549
of people are doing a lot of we'd like to present that
or provide that for folks for free where possible.

00:47:53.550 --> 00:47:58.470
Okay, and now the biggest piece.

00:47:58.469 --> 00:48:03.279
We have trouble areas, but access enabling unknown areas,

00:48:03.280 --> 00:48:10.250
and this is a screenshot of a basic
CoreAnimation application.

00:48:10.250 --> 00:48:17.110
Its one big view and everything inside
of it are CoreAnimation layers.

00:48:17.110 --> 00:48:19.320
We'll talk about that in a moment.

00:48:19.320 --> 00:48:27.350
And sometimes you'll take a look at your application and
this is what it looks like on the screen but across the wire

00:48:27.349 --> 00:48:31.110
in that other process what they see is something like this.

00:48:31.110 --> 00:48:42.349
Just a big blank area, big empty box called AX
unknown or maybe just a window and nothing in it.

00:48:42.349 --> 00:48:46.009
Well that's not a very rich representation
of your user interface.

00:48:46.010 --> 00:48:51.820
It's a pretty useless representation
of you r user interface.

00:48:51.820 --> 00:48:58.160
This is the case that usually happens
when you're doing the most custom work,

00:48:58.159 --> 00:49:02.119
so we can't just figure out what you're doing for you.

00:49:02.119 --> 00:49:09.089
It's also the one that tends to
take the most amount of time.

00:49:09.090 --> 00:49:13.530
However it doesn't usually end up taking tons of code.

00:49:13.530 --> 00:49:15.950
It's not usually like tens of thousands of lines.

00:49:15.949 --> 00:49:19.250
It's usually a relatively small amount of code.

00:49:19.250 --> 00:49:23.690
It's usually the conceptual what
would be the right thing to do here,

00:49:23.690 --> 00:49:28.079
how should I go about doing this,
that tends to take the time.

00:49:28.079 --> 00:49:35.159
Once that is kind of clear then implementing
is usually the smallest part of it.

00:49:35.159 --> 00:49:38.569
There's not a great deal of code there.

00:49:38.570 --> 00:49:45.700
In fact, there are four scenarios we are going to take
a look at when you hit one of these unknown areas,

00:49:45.699 --> 00:49:50.699
like a custom control, something
like a CoreAnimation animation.

00:49:50.699 --> 00:50:01.129
But really there is one basic methodology that I think
really helps in making something accessible from scratch.

00:50:01.130 --> 00:50:04.260
And the first thing is mapping structures.

00:50:04.260 --> 00:50:10.720
So first deciding what that wire frame should
look like once you are fully accessible,

00:50:10.719 --> 00:50:14.029
what you are exposing on the other side of the,

00:50:14.030 --> 00:50:18.850
kid of the other side of the transom
from your app to that other process.

00:50:18.849 --> 00:50:24.420
And then once you figure out what it should look
like based on just the appearance of your app,

00:50:24.420 --> 00:50:30.170
comparing that to what is the object structure of your app.

00:50:30.170 --> 00:50:31.869
Is it a view hierarchy?

00:50:31.869 --> 00:50:36.380
Well we'll get into a number of cases,
and then using the techniques we are going

00:50:36.380 --> 00:50:40.650
to talk about to map between those two.

00:50:40.650 --> 00:50:47.460
Often that first step, that's the
one that you should tackle first.

00:50:47.460 --> 00:50:54.789
It's also the once that once that is done you're
well, very well on your way to being fully accessible.

00:50:54.789 --> 00:51:00.269
That's the one where you got that done, it's
time to go have a beverage of your choice or two.

00:51:00.269 --> 00:51:05.150
Because that's a very nice feeling,
once you see that structure coming

00:51:05.150 --> 00:51:09.180
across on the other side just as you had expected.

00:51:09.179 --> 00:51:15.359
After you do that then implementing the necessary
attributes, so for a text field oh we need

00:51:15.360 --> 00:51:22.460
to return the value and notify when the value changes
and we're going to see a list in a moment, that menu.

00:51:22.460 --> 00:51:25.409
We need to know what child in that list is selected.

00:51:25.409 --> 00:51:33.449
Those are all things that once you've got that basic
structure usually it's kind of very much downhill from there

00:51:33.449 --> 00:51:36.689
in terms of the amount of effort required.

00:51:36.690 --> 00:51:39.950
Adding actions required for a role
would be the next thing you do.

00:51:39.949 --> 00:51:42.500
Actions are relatively rare though.

00:51:42.500 --> 00:51:50.690
We have the buttons to press but most often in
accessibility we make changes in the application,

00:51:50.690 --> 00:51:57.450
the target application by changing the value
of a property as opposed to sending actions.

00:51:57.449 --> 00:52:06.219
So if we wanted, as we'll see in this list if we want
to change the selected child we set the selected child

00:52:06.219 --> 00:52:08.869
as a new value and that changes the selection.

00:52:08.869 --> 00:52:11.710
We don't press the item for instance.

00:52:11.710 --> 00:52:19.280
And then adding notifications as necessary, and two
of the notifications that are most likely to come

00:52:19.280 --> 00:52:25.060
up are they you've changed the focus
UI element or that a value has changed.

00:52:25.059 --> 00:52:31.049
So let's take a look at these scenarios are about mapping
structures, and first of all look at the default case.

00:52:31.050 --> 00:52:39.230
So here's a window that's very similar to what Eric
showed before in terms of a single button in a window,

00:52:39.230 --> 00:52:47.900
and so we look at that and take a look at what's
going on in our app in terms of the object graph.

00:52:47.900 --> 00:52:52.460
And so it's a window, it has a sub
view, excuse me this is the, yeah,

00:52:52.460 --> 00:52:56.760
the window has a sub view, the
frame view then a content view.

00:52:56.760 --> 00:53:00.870
Within that there's a button and the button has a cell.

00:53:00.869 --> 00:53:07.889
But really what we want to come across to the
user, I highlighted it and then I'll fade it out,

00:53:07.889 --> 00:53:12.279
is just that we want a window with a button in it.

00:53:12.280 --> 00:53:18.320
And so the default accessibility we
would end up with something like this.

00:53:18.320 --> 00:53:23.670
The window ends up reporting itself
and its accessibility information.

00:53:23.670 --> 00:53:28.490
The button cell ends up reporting
its accessibility information.

00:53:28.489 --> 00:53:34.059
Really everything in between is ignored
as far as accessibility is concerned.

00:53:34.059 --> 00:53:43.079
It's important to point out that for everything on that wire
frame diagram, every user interface element that we expose,

00:53:43.079 --> 00:53:50.340
that in your application there is an object
that implements that accessibility protocol

00:53:50.340 --> 00:53:55.210
that is the thing that's answering the
questions being asked from the assistive app.

00:53:55.210 --> 00:54:02.269
And so in this case NS Window and NS Button
Cell both implement that accessibility protocol.

00:54:02.269 --> 00:54:06.610
So when questions come in like what
are your accessibility attributes,

00:54:06.610 --> 00:54:12.760
what's your value for this accessibility
attribute, those can be answered.

00:54:12.760 --> 00:54:17.300
Now default accessibility, this is the ideal case.

00:54:17.300 --> 00:54:23.920
Wherever possible this is the one where how much
work needed to be done here by you the developer?

00:54:23.920 --> 00:54:25.700
None. That's nice.

00:54:25.699 --> 00:54:32.799
If that button happened to have an image in it you'd
have to go into interface builder and add a string.

00:54:32.800 --> 00:54:34.640
That's a good amount of work.

00:54:34.639 --> 00:54:37.940
Now you may have custom elements.

00:54:37.940 --> 00:54:45.329
So in this case, least year we did a little program
called Dicey, which was a little kind of dice game

00:54:45.329 --> 00:54:52.460
where the main view showing the dice
was one view that drew five dice.

00:54:52.460 --> 00:54:56.539
However those dice were not views, they weren't cells.

00:54:56.539 --> 00:54:58.429
They looked something like this.

00:54:58.429 --> 00:55:03.460
So the dice view was in NS View and
then we have these other classes.

00:55:03.460 --> 00:55:11.220
And so if you find yourself in a situation where your
custom view has objects representing sub elements,

00:55:11.219 --> 00:55:19.639
but they don't happen to be cells, they don't haven to be
views, then typically you will use that existing structure

00:55:19.639 --> 00:55:25.779
and implement the accessibility protocol,
those methods that Eric had displayed earlier,

00:55:25.780 --> 00:55:31.850
for that class so that those items can
then answer the appropriate questions.

00:55:31.849 --> 00:55:38.400
And so we want to expose in this case that
outer area as well as those five dice.

00:55:42.710 --> 00:55:53.470
And so for this scenario we did a set of sample code
last year called Dicey, and so if you find yourself

00:55:53.469 --> 00:55:58.739
in that situation when you do that
mapping, that okay I have structure.

00:55:58.739 --> 00:55:59.659
I'm good there.

00:55:59.659 --> 00:56:07.139
It's just those items don't implement the accessibility
protocol, then taking a look at the Dicey example

00:56:07.139 --> 00:56:16.879
as some very nice prototypical sample code of how you would
go about doing this is an extraordinarily valuable resource.

00:56:16.880 --> 00:56:25.599
Now we might also have a situation where in this case
this is an image map where the different parts of this,

00:56:25.599 --> 00:56:29.420
in this case this food pyramid are clickable.

00:56:29.420 --> 00:56:34.030
However, if we look at our object graph there is one view.

00:56:34.030 --> 00:56:35.750
It's doing all the work.

00:56:35.750 --> 00:56:46.110
So there are no sub views, there are no sub element objects
on which we can just hang the accessibility protocol.

00:56:46.110 --> 00:56:53.870
So in a case like this where there's more structure
we want to expose, actually let's expose it.

00:56:53.869 --> 00:57:00.269
We want to go from that image map single
item to all of these sub elements,

00:57:00.269 --> 00:57:03.759
well then we need to do a little bit of work.

00:57:03.760 --> 00:57:10.860
We essentially make up a faux, a fake UI
element and its only job in life really is

00:57:10.860 --> 00:57:18.740
to implement the accessibility protocol and when questions
come in about say the top element in that pyramid,

00:57:18.739 --> 00:57:25.399
it answers the questions correctly about its size
and position and role, responds to actions correctly.

00:57:25.400 --> 00:57:30.570
And usually these faux UI elements are very
tightly integrated with that super view

00:57:30.570 --> 00:57:35.700
because obviously the view knows
where everything draws, etcetera.

00:57:37.250 --> 00:57:46.280
Now when you hit this situation, because it does come up,
a very good thing to do is to hit the image map example.

00:57:46.280 --> 00:57:54.560
This sample code we did a couple of years ago and it
has a reusable faux UI element class that is invaluable.

00:57:54.559 --> 00:58:01.789
Whenever I'm talking with developers and we hit
this situation you can literally pull it right

00:58:01.789 --> 00:58:03.489
out of this sample project.

00:58:03.489 --> 00:58:09.209
You subclass it and it does 80,
80 percent of the work for you.

00:58:09.210 --> 00:58:13.470
So when you hit that, that sample code is very useful.

00:58:15.460 --> 00:58:23.769
Now scenario four is we have this new
framework in Leopard called Core Animation.

00:58:23.769 --> 00:58:33.389
Wonderful framework for doing all sorts of
compositing, rendering, and we see certain pieces

00:58:33.389 --> 00:58:37.980
of user interface being directly in Core Animation.

00:58:37.980 --> 00:58:42.190
A good example would be cover flow in the Finder.

00:58:42.190 --> 00:58:51.550
So I thought we'd talk today about how we go about
doing this and kind of stepping through that process

00:58:51.550 --> 00:58:57.580
with CoreAnimation as an example, and then we will
be showing kind of a before and after at the end,

00:58:57.579 --> 00:59:02.349
and then finally we'll be, is this what I'm looking for?

00:59:02.349 --> 00:59:13.130
Finally we will be releasing sample code that should make it
very easy for you to make Core Animation layers accessible.

00:59:13.130 --> 00:59:19.840
So first let's talk just a bit about what
these things are, Core Animation layers.

00:59:19.840 --> 00:59:21.450
They're very analogous to views.

00:59:21.449 --> 00:59:23.389
They have a rectangular area.

00:59:23.389 --> 00:59:25.500
They, a layer can have sub layers.

00:59:25.500 --> 00:59:27.510
They have a super layer.

00:59:27.510 --> 00:59:36.200
They're very much about drawing performance so Core
Animation is very highly tied into Open GL below

00:59:36.199 --> 00:59:42.849
and it's very optimized to cache drawing and be able
to move it around very quickly on another thread.

00:59:42.849 --> 00:59:49.099
We can do all sorts of visual effects with
it, and we can also do combinations of media

00:59:49.099 --> 00:59:54.219
and drawing typeset really have
never been done before on Mac OS10.

00:59:54.219 --> 01:00:01.829
So certainly I think we're going to see a lot
of people in Leopard using Core Animation.

01:00:01.829 --> 01:00:11.699
In Core Animation, what those animations
are built out of are called layers.

01:00:11.699 --> 01:00:15.169
These are the building blocks.

01:00:15.170 --> 01:00:23.510
A CA layer essentially holds drawing or an image, and then
we have different types of layers that hold different kinds

01:00:23.510 --> 01:00:31.760
of content, a text layer, something for Open GL drawing, a
QuickTime layer for QuickTime movies, Quartz compositions.

01:00:31.760 --> 01:00:38.200
And one thing you'll note is that
this is a graphics framework.

01:00:38.199 --> 01:00:42.919
We don't have CA button and CA slider.

01:00:42.920 --> 01:00:48.200
So a layer could end up being just
about anything in your user interface.

01:00:48.199 --> 01:00:54.939
So Core Animation Layers, question mark.

01:00:54.940 --> 01:01:01.019
It may be if you're building a user
interface using, and you want animation in it,

01:01:01.019 --> 01:01:05.619
that using layer back views may
very well be a much better solution.

01:01:05.619 --> 01:01:11.319
We had talked about this on Tuesday in the
building animated coco user interfaces.

01:01:11.320 --> 01:01:17.580
So as you see Core Animation is a graphics
framework, so it does not have built in accessibility

01:01:17.579 --> 01:01:24.429
and it really is more focused on content
types right, QuickTime, Quartz, text.

01:01:24.429 --> 01:01:31.349
So we couldn't just take a CA layer and say oh that's a
slider because it could be used for just about anything.

01:01:31.349 --> 01:01:39.279
It would be like taking a rectangle and
saying oh that rectangle it's a toolbar.

01:01:39.280 --> 01:01:44.340
AppKit views could very easily use
Core Animation using set once layer,

01:01:44.340 --> 01:01:52.269
which allows you to build user interfaces using AppKit
classes and controls and still access Core Animation

01:01:52.269 --> 01:01:55.750
to get both the animation, the
visual effects and what have you.

01:01:55.750 --> 01:01:59.170
So I believe in most cases for building user interfaces

01:01:59.170 --> 01:02:05.480
that animate using layer backed
views is probably the best choice.

01:02:05.480 --> 01:02:13.889
However, we know that some folks will need to
use layers directly, so let's talk about that.

01:02:13.889 --> 01:02:16.879
In this particular example we have a menu.

01:02:16.880 --> 01:02:20.110
It's sort of like you might see on an Apple TV.

01:02:20.110 --> 01:02:22.960
It's got a Quartz composition in the background.

01:02:22.960 --> 01:02:24.199
It's got five items.

01:02:24.199 --> 01:02:26.009
It has a selections.

01:02:26.010 --> 01:02:29.480
It looks something like this in the object graph.

01:02:29.480 --> 01:02:31.860
We have a host view.

01:02:31.860 --> 01:02:35.630
It's layer is a Quartz composition layer.

01:02:35.630 --> 01:02:38.680
The selection is a CA layer.

01:02:38.679 --> 01:02:43.529
Just drawing an oval, and then
all of the items are text layers.

01:02:43.530 --> 01:02:47.470
And we would want to expose this.

01:02:47.469 --> 01:02:50.239
Currently it's just a big unknown square.

01:02:50.239 --> 01:02:55.159
What we would want to come across to an assistive
application is something that looks something

01:02:55.159 --> 01:03:00.109
like that, the outer list and all of the items.

01:03:00.110 --> 01:03:10.190
Now in this case notice that the selection is something
that is ignored, because really if we have a list the idea

01:03:10.190 --> 01:03:16.450
of selection, whatever the selected child
is, that's an attribute of the list.

01:03:16.449 --> 01:03:23.799
We don't need to have the window treatment of
the visual of selection be a separate UI element,

01:03:23.800 --> 01:03:30.360
and we would want that outer item
to be a list, to be it's role,

01:03:30.360 --> 01:03:36.630
and we would want each inner element to be a static text.

01:03:36.630 --> 01:03:50.470
So some general notes as we go about taking that hierarchy
and turning it into that representation and accessibility.

01:03:52.329 --> 01:03:57.250
Some extraordinarily core attributes
are the hierarchy attributes.

01:03:57.250 --> 01:04:05.269
So AX parent and AX children, those really are
the core of defining the accessibility hierarchy.

01:04:05.269 --> 01:04:12.090
In addition, finding out the window and top level
UI element, which would be the sheet or drawer

01:04:12.090 --> 01:04:16.180
or window that something happens
to be on, are certainly important.

01:04:16.179 --> 01:04:22.359
But usually the initial focus is on hooking
up your parent, hooking up your children

01:04:22.360 --> 01:04:26.000
and making sure that these happen in both directions.

01:04:26.000 --> 01:04:35.500
Occasionally you'll hook something up and forget the
other direction and then you'll find out a little later

01:04:35.500 --> 01:04:42.389
when either voice over won't work because it
tends to come down the hierarchy, or accessibility

01:04:42.389 --> 01:04:45.980
and inspector won't work because
it tends to go up the hierarchy.

01:04:45.980 --> 01:04:53.210
Now for Cote Animation the typical case is
pretty simple because parents and children,

01:04:53.210 --> 01:04:57.970
we have super layers that we can report as
our parent, we have sub layers we can report

01:04:57.969 --> 01:05:01.009
as our children and it's a lot like views.

01:05:01.010 --> 01:05:04.770
The root layer, however, is a specific special case.

01:05:04.769 --> 01:05:15.440
It needs to report it's host view as it's parent, however
layers don't by default have a reference to their view.

01:05:15.440 --> 01:05:22.429
So what we do in the sample code is just a simple
subclass of your root where we add the ability to point

01:05:22.429 --> 01:05:25.769
to the view and return that as the parent.

01:05:25.769 --> 01:05:29.230
The hosting view obviously is also a special case.

01:05:29.230 --> 01:05:38.519
It usually wants to talk all about it's sub views, in
this case it needs to report it's layer as a child.

01:05:38.519 --> 01:05:44.300
Now all of those items in the animation
can get the window and top level UI element

01:05:44.300 --> 01:05:48.870
from the host view because it's already implemented there.

01:05:51.869 --> 01:05:57.839
In addition, we have geometric attributes and hit
testing, so figuring out where each of these are.

01:05:57.840 --> 01:06:03.450
Once we know where we are in the hierarchy, that's
kind of step one of making that wire frame show up.

01:06:03.449 --> 01:06:06.759
Step two is size and position.

01:06:06.760 --> 01:06:10.320
What's nice about layers is its already got them.

01:06:10.320 --> 01:06:11.450
It's a rectangle.

01:06:11.449 --> 01:06:13.659
It reports a size and a position.

01:06:13.659 --> 01:06:21.129
However, when we report it, in accessibility we're
always talking in terms of screen coordinates.

01:06:21.130 --> 01:06:24.630
In fact with the origin in the upper left hand corner.

01:06:24.630 --> 01:06:32.280
So we just need to do that translation and then
we're pretty much fine with layers and it's geometry.

01:06:32.280 --> 01:06:37.700
Actually I think I've just said everything
on this slide one slide too early.

01:06:37.699 --> 01:06:38.919
That's fine.

01:06:38.920 --> 01:06:42.860
Hit testing, there we go.

01:06:42.860 --> 01:06:47.860
C layer has a hit test method that we
could use to find the appropriate point.

01:06:47.860 --> 01:06:52.740
It may be the case though, for example with our selection,

01:06:52.739 --> 01:06:58.209
in Z order it's above all of our
items, however it is ignored.

01:06:58.210 --> 01:07:06.659
So if I try mousing over the selection it's going
to report that ignored item as the hit tested layer.

01:07:06.659 --> 01:07:10.539
So depending on how much of your animation is ignored,

01:07:10.539 --> 01:07:21.590
you may need to implement I'll go back one accessibility
per layer to filter out those ignored elements.

01:07:21.590 --> 01:07:28.890
And then the last thing to talk about in terms of
getting that basic structure going are the roles.

01:07:28.889 --> 01:07:32.059
These are extraordinary important.

01:07:32.059 --> 01:07:41.090
It's how an assistive application knows what kind of thing
it's dealing with, and in fact is a three attribute set.

01:07:41.090 --> 01:07:48.660
There's a role, a modifying sub role and
then a kind of localized description.

01:07:48.659 --> 01:07:56.440
Don't make up your own roles and sub roles because assistive
applications won't know what the heck you're talking about.

01:07:56.440 --> 01:08:03.010
AX My Slider, I don't know what that is,
and it will probably just call you unknown

01:08:03.010 --> 01:08:06.360
or a group or kind of fudged in some way.

01:08:06.360 --> 01:08:09.820
For the role description don't make up your own.

01:08:09.820 --> 01:08:16.350
Use the function and it's accessibility role
description to get a localized string automatically.

01:08:16.350 --> 01:08:30.039
In Core Animation, whereas all the geometry and positioning
is very simple, again a layer could be just about anything.

01:08:30.039 --> 01:08:35.560
We could make a default layer an AX unknown,
sort of like what we do in NS View and in fact

01:08:35.560 --> 01:08:38.590
in our sample code that's what we've done.

01:08:38.590 --> 01:08:47.310
Typically you would subclass to add the role and in fact if
you are building some user interface out of Core Animation,

01:08:47.310 --> 01:08:52.500
most likely you're going to create some
sub class that encapsulates the behavior

01:08:52.500 --> 01:08:55.840
of say a button or a slider or something of that effect.

01:08:55.840 --> 01:08:58.329
That would be the right place to add the role.

01:08:58.329 --> 01:09:09.109
And so once we have those all complete at that
point that major step one that I was talking

01:09:09.109 --> 01:09:15.099
about is done and we end up having those objects map.

01:09:15.100 --> 01:09:19.350
What I'd like to do now is have Eric
come on up and show a little before

01:09:19.350 --> 01:09:27.730
and after of accessibility before we did any work and
then accessibility afterwards for that Core Animation.

01:09:30.340 --> 01:09:32.670
>> Look at that.

01:09:32.670 --> 01:09:35.130
What not to do before demo.

01:09:35.130 --> 01:09:38.109
Okay, so here we are.

01:09:38.109 --> 01:09:43.939
I'm going to go ahead and kill our text
here, and we've got a couple of applications.

01:09:43.939 --> 01:09:46.599
First one is James?

01:09:46.600 --> 01:09:49.240
Handy Application here so ooh, Core Animation.

01:09:49.239 --> 01:09:49.949
Isn't this cool?

01:09:49.949 --> 01:09:51.189
I can go up and down.

01:09:51.189 --> 01:09:55.339
It's nice and animated, really
great experience for cited user.

01:09:55.340 --> 01:10:05.420
So now let's actually run voice
over on this, turn on voice over.

01:10:05.420 --> 01:10:09.510
Okay, and let's complete the experience here.

01:10:09.510 --> 01:10:14.180
Ah this is what most users experience with voice
over, and so let's try to move around this app.

01:10:14.180 --> 01:10:17.170
Oh bummer, what window were we on.

01:10:17.170 --> 01:10:19.010
It's an elevator app.

01:10:19.010 --> 01:10:24.670
I'm on window before.

01:10:24.670 --> 01:10:29.500
Let me try to drill in.

01:10:29.500 --> 01:10:30.060
That's a bummer.

01:10:30.060 --> 01:10:34.360
I don't think I'm going to buy this software.

01:10:34.359 --> 01:10:45.689
So let's be collaborative with our inaccessible app
and let's turn off voice over and let's quit this one,

01:10:45.689 --> 01:10:50.029
and now let's go to our other app accessorized.

01:10:50.029 --> 01:10:52.139
Same app, moves around, looks really nice.

01:10:52.140 --> 01:10:53.180
Now let's turn on voice over.

01:10:53.180 --> 01:10:58.500
Ah that's what I'm talking about.

01:10:58.500 --> 01:11:01.470
Right, now several things are happening here.

01:11:01.470 --> 01:11:05.340
It's reading each item and also
I'm just using the arrow keys.

01:11:05.340 --> 01:11:08.860
I'm not even using the voice over cursor and
we're getting the notifications at the right place

01:11:08.859 --> 01:11:13.369
so that we move the voice over cursor when the
selection changed, really nice and accessible.

01:11:13.369 --> 01:11:15.930
Thank you.

01:11:15.930 --> 01:11:22.960
>> And so we will be making that available.

01:11:22.960 --> 01:11:31.109
What is included in this sample code essentially is we've
added a category to CA layer and also one to CA text layer,

01:11:31.109 --> 01:11:37.849
because although a layer could be anything probably
it's a good guess that a CA text layer is going to come

01:11:37.850 --> 01:11:44.280
across as an AX static text, so we've done that
and also the couple of little places where we need

01:11:44.279 --> 01:11:47.829
to subclass to hook it into the view hierarchy.

01:11:47.829 --> 01:11:50.300
So we will be making that available.

01:11:50.300 --> 01:11:56.380
If it doesn't happen today it should happen very, very
shortly and that would kind of round out this suite

01:11:56.380 --> 01:12:06.250
of sample code for hitting all of the non-default
cases, having your own items, your own structure,

01:12:06.250 --> 01:12:12.569
having CoreAnimation layers as structure or a view
that does all the work itself where you need false items

01:12:12.569 --> 01:12:18.399
or faux UI elements to get across the accessibility.

01:12:18.399 --> 01:12:32.500
So in summary, certainly everything in Mac OS10 more and
more we're seeing things that are relying on accessibility.

01:12:32.500 --> 01:12:34.050
Not just voice over.

01:12:34.050 --> 01:12:43.659
Certainly we're seeing a growing community of users
of voice over on the Macintosh and so accessibility

01:12:43.659 --> 01:12:51.359
over time is becoming more and more important,
and so getting that out of process experience,

01:12:51.359 --> 01:12:57.359
getting that clean representation of your user
interface is becoming more and more important.

01:12:57.359 --> 01:13:04.920
The first thing you could do if you do nothing
else, add descriptions and title UI elements.

01:13:04.920 --> 01:13:10.500
Hook those up, because that makes your
application instantly much more accessible.

01:13:10.500 --> 01:13:21.090
Where possible AppKit views and controls, including
using the animation additions and set once layer in app kit,

01:13:21.090 --> 01:13:24.789
custom views and controls making them accessible.

01:13:24.789 --> 01:13:27.170
Don't forget about the sample code.

01:13:27.170 --> 01:13:34.460
It will save you tons and tons of time because
it is designed to be reused and very helpful.

01:13:34.460 --> 01:13:40.420
And please give feedback and ask questions,
which then leads us more information.

01:13:40.420 --> 01:13:46.550
I highly recommend the accessibility developer's list,
documentation and sample code, Deric's our evangelist,

01:13:46.550 --> 01:13:50.320
and the accessibility lab this afternoon at 2.

01:13:50.319 --> 01:13:52.149
We'd like to see you all there
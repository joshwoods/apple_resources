WEBVTT

00:00:20.050 --> 00:00:21.460
>> Good afternoon everybody.

00:00:21.460 --> 00:00:24.320
I'm Chris Espinosa of the Xcode
team and I want to welcome you

00:00:24.320 --> 00:00:28.160
to Unleashing the Power of the Xcode Build System.

00:00:29.800 --> 00:00:32.090
We have a good session for you this afternoon.

00:00:32.090 --> 00:00:37.270
We're going to take you on a tour of the dark
under belly of the Xcode Build System.

00:00:37.270 --> 00:00:38.900
You'll learn a couple of important things.

00:00:38.899 --> 00:00:44.699
One is the new features in the Xcode 3.0 Build
System that will allow you to build faster

00:00:44.700 --> 00:00:47.950
and add more customization to your projects.

00:00:47.950 --> 00:00:54.109
And two is we're going to show you how to
tune customized projects to build faster.

00:00:54.109 --> 00:00:58.019
I'm going to give you tips on building
for multiple architectures,

00:00:58.020 --> 00:01:02.109
how and when to use the new feature
called Parallel Target Builds.

00:01:02.109 --> 00:01:08.299
How to tune your builds by managing your precompiled
headers so you build fewer and better precompiled headers.

00:01:08.299 --> 00:01:12.609
How to use some of the new build settings in
order to embed frameworks in your applications

00:01:12.609 --> 00:01:16.269
or to use an embedded framework for multiple applications.

00:01:16.269 --> 00:01:20.500
How to create and use your own SDKs
and integrate them with Apple's SDKs

00:01:20.500 --> 00:01:25.599
so you can build against multiple SDKs at the same time.

00:01:25.599 --> 00:01:30.789
How to build the same project in an Xcode 2.5
and 3.0 even on the same machine.

00:01:30.790 --> 00:01:35.730
And also how to use Tiger's gnu tools
when you're running on a Leopard system.

00:01:35.730 --> 00:01:36.790
It's a lot to cover.

00:01:36.790 --> 00:01:38.109
It's going to be very detailed

00:01:38.109 --> 00:01:41.920
And so I hope you take a lot of notes.

00:01:41.920 --> 00:01:48.060
But before I can explain any of that, I have to get on some
common ground with some terminology and give you an overview

00:01:48.060 --> 00:01:52.719
of the main areas of the build system
we're going to be talking about today.

00:01:52.719 --> 00:01:57.400
An Xcode project is a set of targets.

00:01:57.400 --> 00:01:59.990
And a target builds a build product.

00:01:59.989 --> 00:02:07.329
And when I'm talking about the build system, I'm talking
about taking a target and building its, taking a project

00:02:07.329 --> 00:02:12.680
and building its targets in sequence
to create build prod, build products.

00:02:12.680 --> 00:02:15.319
Now each target is a clump.

00:02:15.319 --> 00:02:17.129
And it's a clump of inputs.

00:02:17.129 --> 00:02:22.909
Source files, nib files, build
settings, all sorts of things.

00:02:22.909 --> 00:02:30.270
In order for Xcode to have a methodical way to build a
target into a build product, it has to organize this clump

00:02:30.270 --> 00:02:34.780
of inputs and it organizes them into build phases.

00:02:34.780 --> 00:02:39.909
I'm going to be talking really about only one build phase
today, the most important one which is compile source.

00:02:39.909 --> 00:02:46.479
There are a lot of other build phases that copy your
resources or that run shell scripts or things like that.

00:02:46.479 --> 00:02:54.129
But the main one is compiling and linking the source
files into executables that go into your build product.

00:02:54.129 --> 00:03:01.500
The most important thing about build, build phases is
that they are the things that build settings effect.

00:03:01.500 --> 00:03:07.300
When you change build settings in your project
or your targets, the build phases are the ones

00:03:07.300 --> 00:03:10.990
that take those settings and put them to work.

00:03:12.719 --> 00:03:19.090
The build settings inherit, they
inherit from the project to the target.

00:03:19.090 --> 00:03:25.490
So you can set build settings at your project level
that will affect all of the targets in your project.

00:03:25.490 --> 00:03:30.010
And so those settings that you set at your project
level, you'll really only want to set the ones

00:03:30.009 --> 00:03:37.299
that are generally applicable to everything you're
building such as maybe the major version number or,

00:03:37.300 --> 00:03:40.830
or some setting that you want to
use globally such as optimization.

00:03:40.830 --> 00:03:45.420
What optimization you want to use or
the architectures you want to build for.

00:03:45.419 --> 00:03:51.639
Things that are specific to a target like what kind
of target this is, what's its name, where does it go,

00:03:51.639 --> 00:03:54.219
what specific build flags do I want to build it with.

00:03:54.219 --> 00:03:56.849
You should set those at the target level.

00:03:56.849 --> 00:04:03.549
Build settings then are used by the target
and applied to each build phase to build,

00:04:03.550 --> 00:04:06.540
to produce an output from that build phase.

00:04:06.539 --> 00:04:12.229
Okay? Now the build settings, you'll
see them in the build setting inspector.

00:04:12.229 --> 00:04:15.719
Usually you'll just see a column of names and values.

00:04:15.719 --> 00:04:20.180
If you command click on the build settings
inspector, you'll, you'll be able to control click

00:04:20.180 --> 00:04:22.459
on it, you'll be able to see two other things.

00:04:22.459 --> 00:04:28.459
You'll be able to see the build settings definition
which is the way it comes up with the value.

00:04:28.459 --> 00:04:34.339
And you'll be able to see the build settings identifier
that looks kind of like an environment variable, okay?

00:04:34.339 --> 00:04:37.959
So we have kind of two different
ways of viewing the build setting.

00:04:37.959 --> 00:04:42.419
You can view is as an English name and a string
constant or you could view it as something that looks

00:04:42.420 --> 00:04:48.949
like an environment variable with what looks like a
calculation behind it kind of like an Excel spreadsheet.

00:04:48.949 --> 00:04:52.060
Build settings have definitions that evaluate to values.

00:04:52.060 --> 00:04:56.750
They can be strings, they can be lists of
identifiers, they can be values, they can be Booleans.

00:04:56.750 --> 00:05:01.810
Okay? And there are three basic groups of build settings.

00:05:01.810 --> 00:05:04.259
The first kind are the predefined build settings.

00:05:04.259 --> 00:05:09.829
These are the ones that we define in the Xcode
build setting for you to use generally.

00:05:09.829 --> 00:05:16.399
We take the UNIX shell's environment variables and propagate
them through so you can use them like user and home.

00:05:16.399 --> 00:05:21.609
We take things that the build systems invoked
with like action, just like in a Makefile.

00:05:21.610 --> 00:05:26.389
But we also set constants in the, in the build settings.

00:05:26.389 --> 00:05:33.310
So for example, if you were building the, the
debug configuration, of your product or tar,

00:05:33.310 --> 00:05:40.550
your project or target, the configuration build
setting will be set to the value debug, okay?

00:05:40.550 --> 00:05:44.850
The second kind of build settings
are the definable build settings.

00:05:44.850 --> 00:05:48.530
These are build settings that you can
change in the build settings inspector

00:05:48.529 --> 00:05:52.689
to make your project or target build the way you want it to.

00:05:52.689 --> 00:05:54.910
Sometimes these have default values.

00:05:54.910 --> 00:06:00.820
Sometimes these values are set by the template you created
the project or target from, sometimes they're just blank.

00:06:00.819 --> 00:06:04.300
These are things like the product name,
things like the header search paths.

00:06:04.300 --> 00:06:09.740
Things like the optimization level or things like
the architectures you are choosing to build for.

00:06:09.740 --> 00:06:13.590
This is going to come up most importantly
in a couple of slides.

00:06:13.589 --> 00:06:19.129
And then finally, you can create your own
build settings that look and work exactly

00:06:19.129 --> 00:06:22.909
like Xcode's predefined build
settings or definable build settings.

00:06:22.910 --> 00:06:27.280
And you can use these to pass values to
your compiled code or you can use them

00:06:27.279 --> 00:06:29.949
to change the way other build settings are defined.

00:06:29.949 --> 00:06:34.539
You can define a build setting in
terms of another build setting.

00:06:34.540 --> 00:06:39.990
You can even link build settings
together by saying you know this Boolean,

00:06:39.990 --> 00:06:43.810
the value of this Boolean build setting is equal
to the value of that Boolean build setting.

00:06:43.810 --> 00:06:47.889
So when you set one, the other is automatically changed.

00:06:48.920 --> 00:06:55.189
So when you're building for 64-bit, the build setting
that's most important is the architectures build setting.

00:06:55.189 --> 00:07:02.879
Now you've heard us talk a lot the last couple of days
about building 64-bit code and building 64-bit applicatdions.

00:07:05.600 --> 00:07:10.680
When you build 64-bit, it's thde same process,

00:07:10.680 --> 00:07:15.670
but a different set of steps than building
for a single processor architecture.

00:07:15.670 --> 00:07:20.879
Back in the day when we only had PowerPC,
when you built your Xcode project

00:07:20.879 --> 00:07:25.259
or your project builder project
back then, only one thing happened.

00:07:25.259 --> 00:07:33.339
The, you took your set of source files, you ran them through
the PowerPC compiler, they created a PowerPC binary

00:07:33.339 --> 00:07:36.869
and it was copied into your application
bundle or your executable.

00:07:36.870 --> 00:07:44.220
That's because the value of the architecture's
build settings arch was a single value ppc.

00:07:44.220 --> 00:07:53.870
Well, nowadays, same sources, same kind of project, but
you take the source files and you build them four times.

00:07:53.870 --> 00:07:59.329
Take every source file and you build it for PowerPC,
every source file, build it for Intel, every source file,

00:07:59.329 --> 00:08:05.930
build it for PowerPC 64, every
source file, build it for X86_64.

00:08:05.930 --> 00:08:06.920
Why does it do that?

00:08:06.920 --> 00:08:16.189
Because you've set the value of architecture's
build setting to a list of ppc, ppc64, i386, X86_64,

00:08:16.189 --> 00:08:21.300
and the compile sources build phase simple
iterates over that list, compiles every source file

00:08:21.300 --> 00:08:24.569
for every architecture, links together for each architecture

00:08:24.569 --> 00:08:28.709
and does this thing called lipo,
I didn't come up with the name.

00:08:28.709 --> 00:08:34.029
To put all of the executables together in one binary.

00:08:36.039 --> 00:08:37.480
Now the story is simple.

00:08:37.480 --> 00:08:39.110
How do you build for 64-bit?

00:08:39.110 --> 00:08:44.820
Well, Bertrand Serlet or Steve Jobs will tell
you just check this checkbox that says 64-bit right?

00:08:44.820 --> 00:08:50.420
And then you build and then you get errors and warnings
and you fix those and you repeat until the errors

00:08:50.419 --> 00:08:54.110
and warnings are gone and then you debug it until it works.

00:08:54.110 --> 00:08:56.100
So that's the theory.

00:08:56.100 --> 00:09:03.409
In practice, you want to do something so that building
for 64-bit doesn't have a severe effect on your workflow.

00:09:03.409 --> 00:09:07.679
The severe effect on the workflow is that
if you compile every file four times,

00:09:07.679 --> 00:09:11.259
it's going to take substantially
longer than compiling every file once.

00:09:11.259 --> 00:09:14.679
And three of those compilations are going
to have no relevance to what you're trying

00:09:14.679 --> 00:09:18.379
to do because they won't run on your machine.

00:09:18.379 --> 00:09:26.220
So when you're building for 64-bit, it's important to set
the value for the architecture's build setting differently

00:09:26.220 --> 00:09:34.620
on the desktop when you're debugging than for building
and deploying to people testing or using your product.

00:09:34.620 --> 00:09:41.240
And we built some easy ways to do that and to manage
the side effects of that in to Xcode 3.0.

00:09:41.240 --> 00:09:43.570
Here's what's behind the checkboxes.

00:09:43.570 --> 00:09:53.700
If the value of the architectures build settings starts out
as a list of architecture identifiers, like ppc or x86_64,

00:09:53.700 --> 00:09:57.040
the checkboxes have a certain set of meanings.

00:09:57.039 --> 00:10:01.879
Notice that we don't have individual checkboxes
for individual architectures.

00:10:01.879 --> 00:10:07.070
We are strongly implying, in case you don't get this
message, that you should not build for a single chip set.

00:10:07.070 --> 00:10:12.540
You should build universal, universal 32-bit,
universal 64-bit, universal 4-way,

00:10:12.539 --> 00:10:18.589
but still there are very, very few times when
you should build only Intel or only PowerPC.

00:10:18.590 --> 00:10:24.240
You can of course just manually edit the architecture's
build setting as a text string and do whatever you want,

00:10:24.240 --> 00:10:29.490
but when you're using the checkbox interface,
it really implies, you better be universal.

00:10:29.490 --> 00:10:30.889
One way or the other.

00:10:30.889 --> 00:10:35.669
So the checkbox in 32-bit means ppc i386.

00:10:35.669 --> 00:10:42.639
The checkbox in 64-bit means ppc64 x86_64
and both checkboxes mean all four architectures.

00:10:42.639 --> 00:10:43.730
Very simple.

00:10:43.730 --> 00:10:48.000
Now if you've manually edited the
field and you have a mixed set,

00:10:48.000 --> 00:10:51.409
that is you are building it then, then you'll get a dash.

00:10:51.409 --> 00:10:56.629
So when you see a dash in that architectures
box, it means that you're building thin not fat

00:10:56.629 --> 00:11:01.070
for that bit width, 32-bit, 64-bit.

00:11:01.070 --> 00:11:07.340
So this is really good if you're building the
release configuration or the deployment configuration

00:11:07.340 --> 00:11:09.550
or something that's going to go outside your group.

00:11:09.549 --> 00:11:14.849
Because you want to build as many architectures as possible,
as many architectures as your code is written for,

00:11:14.850 --> 00:11:19.519
to give to other people so your
application can run everywhere.

00:11:19.519 --> 00:11:22.539
But you don't want to do that on your local machine.

00:11:22.539 --> 00:11:28.069
You don't necessarily want to build all four
architectures every time you make a simple bug fix.

00:11:28.070 --> 00:11:31.840
You just want to build for the architecture you're using now.

00:11:31.840 --> 00:11:36.290
We've provided some pre-defined build
settings that will really help you do that.

00:11:36.289 --> 00:11:39.709
Now one that has existed all along is NATIVE_ARCH.

00:11:39.710 --> 00:11:47.150
NATIVE_ARCH is the native chip set of the
machine and typically it's been just ppc or i386.

00:11:47.149 --> 00:11:53.129
Even when we started introducing 64-bit machines,
since we didn't have a full 64-bit model,
d

00:11:53.129 --> 00:11:57.289
it stayed the 32-bit equivalen2t
of that 64-bit model.

00:11:57.289 --> 00:12:00.639
You really shouldn't use NATIVE_ARCH, it could be confusing.

00:12:00.639 --> 00:12:06.220
We've introduced a new pre-defined build setting called
NATIVE_ARCH_32_BIT, which has exactly the same value

00:12:06.220 --> 00:12:09.210
and means exactly the same thing, but is a little clearer.

00:12:09.210 --> 00:12:16.120
NATIVE_ARCH_32_BIT is a pre-defined
build setting that evaluates to ppc on a G3 or G4

00:12:16.120 --> 00:12:20.159
or G5 and i386 on of course a lower core duo.

00:12:20.159 --> 00:12:21.969
Very easy.

00:12:21.970 --> 00:12:26.700
NATIVE_ARCH_64_bit is the
64-bit equivalent of that.

00:12:26.700 --> 00:12:35.610
So regardless of what machine you're on, NATIVE_
ARCH_64_BIT will be ppc64 or x86_64.

00:12:35.610 --> 00:12:38.570
It'll be the 64-bit version of that.

00:12:38.570 --> 00:12:46.050
So if you want to build something that's going to
build fat, but just for the chip set you're on,

00:12:46.049 --> 00:12:52.919
you set your architectures to NATIVE_ARCH_32_BIT,
NATIVE_ARCH_64_BIT and on PodwerPC machine,

00:12:52.919 --> 00:13:05.059
that'll evaluate to ppc i386, ppc ppc64 and
on an Intel machine they'll get i386 x86_64.

00:13:05.059 --> 00:13:09.909
So you'll be able to single processor, multiple-bit widths.

00:13:09.909 --> 00:13:15.339
But if you really want to have a project that's going to
build with the best bit width on the machine I'm running on

00:13:15.340 --> 00:13:21.030
and only build once, the build set
you want is called NATIVE_ARCH_ACTUAL.

00:13:21.029 --> 00:13:25.689
NATIVE_ARCH_ACTUAL evaluates the actual chip
set of the actual machine of the actual process

00:13:25.690 --> 00:13:27.690
of the actual bit width you're running on.

00:13:27.690 --> 00:13:33.200
ppc or 64 or i386 or x86_64.

00:13:33.200 --> 00:13:38.050
Now when you set the architecture's build
setting to one of these pre-defined values

00:13:38.049 --> 00:13:45.579
or a list of these pre-defined values, you still get check
boxes, but the behavior of the checkboxes are different.

00:13:45.580 --> 00:13:50.950
When you check and uncheck the boxes, it will change
them from set of pre-defined values to another set

00:13:50.950 --> 00:13:54.390
of pre-defined values, it won't take
you back to the set of constants.

00:13:54.389 --> 00:13:56.159
And they mean different things.

00:13:56.159 --> 00:14:00.559
And when you have the checkboxes
set with the architecture's values

00:14:00.559 --> 00:14:04.929
with pre-defined values, you will
always build one kind of thin.

00:14:04.929 --> 00:14:06.799
It's really optimized for debugging.

00:14:06.799 --> 00:14:10.919
So you really only want to do this
in your debug configuration.

00:14:10.919 --> 00:14:14.459
32-bit check, when 32-bit is checked,

00:14:14.460 --> 00:14:18.150
that means the value is native
arch or NATIVE_ARCH_32_BIT.

00:14:18.149 --> 00:14:21.959
When 64-bit is checked, it means
that it's NATIVE_ARCH_64_BIT

00:14:21.960 --> 00:14:24.940
and when both are checked, that
means its NATIVE_ARCH_ACTUAL.

00:14:24.940 --> 00:14:30.370
So on your debug configuration you check
both checkboxes and you should build

00:14:30.370 --> 00:14:35.169
for the best architecture thin on
any machine you're building on.

00:14:35.169 --> 00:14:39.319
This is great if you're sharing the project among
multiple people with multiple different machines.

00:14:39.320 --> 00:14:44.090
This way you don't have to go in and change the
architectures every time you open up the project,

00:14:44.090 --> 00:14:52.300
in order to build for you machine, if the guy on the next
desk has a G5 and the woman in the next cubicle is working

00:14:52.299 --> 00:14:57.049
on a core solo, all three of you can open the
same project, you'll build best for your machine,

00:14:57.049 --> 00:15:05.069
no changes to your project file, no contention or
conflict in your SEM system when you check it back in.

00:15:05.070 --> 00:15:11.230
Now when you have these build settings set, we give
you some other aids in the user interface in order

00:15:11.230 --> 00:15:17.190
to use the different architectures that you're building
for if you happen to be building a release configuration.

00:15:17.190 --> 00:15:26.270
Say you want to see both the PowerPC and the Intel assembly
code generated by a certain source file side by side.

00:15:26.269 --> 00:15:33.279
Well you couldn't do that before, but in Xcode 3.0,
we have something on the next slide to do that.

00:15:33.279 --> 00:15:39.049
On this slide, we have pre-architecture build settings.

00:15:39.049 --> 00:15:45.149
When you have a configuration that
has multiple architectures,

00:15:45.149 --> 00:15:52.049
you can also change any compilation related build setting
to be different for each architecture and you do it

00:15:52.049 --> 00:15:59.509
with the little gear menu at the
bottom of the build setting page.

00:15:59.509 --> 00:16:07.480
You select a build setting, you pull down the menu and you
can add a per-architecture setting for any architecture

00:16:07.480 --> 00:16:12.300
to customize any build setting to have
different values for each architecture.

00:16:12.299 --> 00:16:14.919
You can do this for SDKs.

00:16:14.919 --> 00:16:20.459
For example, you may want to use the 10.5
SDK if you're building for a 64-bit,

00:16:20.460 --> 00:16:27.100
but still use the 10.4 SDK if you're building for 32-bit
just because you want to restrict yourselves so those

00:16:27.100 --> 00:16:30.529
to those APIs so you can run back on Tiger.

00:16:30.529 --> 00:16:34.279
You may want to set the deployment target,
you may want to set optimization flags,

00:16:34.279 --> 00:16:42.899
you may want to set anything compilation related you
can customize per-architecture in the user interface.

00:16:42.899 --> 00:16:50.189
And then as I said, if you have a configuration that
has multiple architectures configured and you want

00:16:50.190 --> 00:16:55.070
to see the effects of one of those architectures,
you can use the Set Active Architecture menu item

00:16:55.070 --> 00:17:00.340
in the project menu and there's also an optional
tool bar item that you can just put in your tool bar.

00:17:00.340 --> 00:17:09.009
To pick a single architecture for the operations of compile,
pre-process, show assembly code and fix and continue.

00:17:09.009 --> 00:17:16.960
So if you happen to be, if you happen to have a source file
and you want to see how it looks both in Intel assembly code

00:17:16.960 --> 00:17:22.309
and in PowerPC assembly code, you can Set Active
Architecture and show assembly code and you'll see one

00:17:22.309 --> 00:17:26.720
and then Set Active Architecture to another
architecture, show assembly code again and you can look

00:17:26.720 --> 00:17:34.620
at the assembly codes side by side without having to go and
edit your build settings and that's going to be really handy.

00:17:34.619 --> 00:17:36.519
At the command line, you can do a similar thing.

00:17:36.519 --> 00:17:41.910
If you're building using Xcode build command line
and you want to force a particular architecture,

00:17:41.910 --> 00:17:49.640
you just put ARCHS equals and then the architecture list
after that and build settings set at the command line,

00:17:49.640 --> 00:17:56.790
trump all build settings in the project and the target and
force the Xcode build system to use the value you set there

00:17:56.789 --> 00:18:02.649
so if you just want to build one thin architecture
or if you want to build an alternate architecture

00:18:02.650 --> 00:18:08.070
to what's already configured, you can do that at
command line just by forcing the build setting.

00:18:09.599 --> 00:18:15.129
When you're using per-architecture build settings as
I showed a couple slides ago with the user interface,

00:18:15.130 --> 00:18:23.380
if you happen to be using xcconfig files that allow you
to specify build settings in a text file in your project,

00:18:23.380 --> 00:18:29.150
you can use this special bracket and arch equals notation

00:18:29.150 --> 00:18:33.160
to specify per-architecture build
settings in your xcconfig file.

00:18:33.160 --> 00:18:38.850
So if you're sharing a configuration file among
multiple targets which we highly recommend,

00:18:38.849 --> 00:18:44.449
it's a great way to have to, to be able to make global
changes without having to go through and open a lot

00:18:44.450 --> 00:18:52.200
of inspectors, you can use the bracket
arch equals value close bracket notation

00:18:52.200 --> 00:18:56.750
to set per-architecture build settings
in your xcconfig files.

00:18:56.750 --> 00:19:01.640
And then if you're using custom build settings,
if you have something that's being passed

00:19:01.640 --> 00:19:07.550
through to say a shell script build phase or
you're expanding it into a preprocessor macro,

00:19:07.549 --> 00:19:14.440
you can do that on a per-architecture basis simply
by using the calculated value, which is you know,

00:19:14.440 --> 00:19:17.779
your flag underscore and then CURRENT_ARCH.

00:19:17.779 --> 00:19:22.069
Each time Xcode goes to that compilation group,
it'll set current arch to a different value

00:19:22.069 --> 00:19:29.750
and then it'll evaluate the value of debug ppc, debug
i386, separately and then it'll take that value and pass it

00:19:29.750 --> 00:19:35.390
through to your build, to your shell script
build phase or in your preprocessor macro.

00:19:37.150 --> 00:19:45.080
When you build with multiple architectures, one important
thing will happen, is that your builds will take longer.

00:19:45.079 --> 00:19:49.869
You experienced this going universal, you'll
experience it again going 64-bit.

00:19:49.869 --> 00:19:55.049
It's more and more important to improve
your build speed when you're building

00:19:55.049 --> 00:20:01.109
for full 4-way PowerPC X86
32-bit, 64-bit.

00:20:01.109 --> 00:20:05.689
I'm going to cover four important ways
to improve your build speed here today.

00:20:05.690 --> 00:20:08.130
One is using all available processors.

00:20:08.130 --> 00:20:11.110
This basically comes, well I'm not going to say free.

00:20:11.109 --> 00:20:14.750
This basically comes for the small
cost of buying an 8-way Macintosh.

00:20:14.750 --> 00:20:16.720
( laughter )

00:20:16.720 --> 00:20:19.960
Comes for free in the software.

00:20:19.960 --> 00:20:24.610
The second, which is most important, is to
make the best use of your precompiled headers.

00:20:24.609 --> 00:20:28.799
The more you build the more precompiled
headers you're generating and the faster

00:20:28.799 --> 00:20:33.039
and fewer you generate precompiled
headers, the faster your build will go.

00:20:33.039 --> 00:20:38.269
Third is using the new multiple targets feature, parallel
targets feature in order to build multiple targets

00:20:38.269 --> 00:20:43.009
in parallel and fourth is to use
our distributed build options

00:20:43.009 --> 00:20:45.150
So as I said, building for multiple processors.

00:20:45.150 --> 00:20:50.830
A lot of this was covered in Bertrand
Serlet's State of the Union for Mac OS X.

00:20:50.829 --> 00:20:56.509
In Tiger and Leopard, we try whenever possible
to dispatch jobs to multiple processors

00:20:56.509 --> 00:21:00.940
and in Xcode we do this primarily
with the compile sources build phase

00:21:00.940 --> 00:21:03.710
which is the one where you're doing the most work.

00:21:03.710 --> 00:21:06.289
It's the one where you're doing multiple architectures.

00:21:06.289 --> 00:21:12.950
When you're compiling your sources, we will use all
processors available in order to do the compilation jobs.

00:21:12.950 --> 00:21:18.100
If you are on a four processor or more machine,
we'll reserve one processor to handle the UI tasks

00:21:18.099 --> 00:21:22.409
and everything else going on in your
system, so that Xcode remains responsive.

00:21:22.410 --> 00:21:26.970
You can get your mail, you can do Spotlight
searches, we'll save you one processor for that.

00:21:26.970 --> 00:21:32.490
But if you've got an 8-way machine, seven
GCC jobs are going to be going in parallel

00:21:32.490 --> 00:21:35.170
and that will really help speed up your build.

00:21:35.170 --> 00:21:39.830
Now in the Compile Sources phase is
parallel, but the other steps are choke points.

00:21:39.829 --> 00:21:42.899
All the prerequisites to compilation
are going to be choke points.

00:21:42.900 --> 00:21:48.110
They have to be done serially before
we can fan out and do the compile job

00:21:48.109 --> 00:21:51.849
and one of those choke points is pre-compiling the headers

00:21:51.849 --> 00:21:57.480
because the precompiled header is a
pre-requisite to doing any compilation whatsoever.

00:21:57.480 --> 00:22:02.190
And so it follows that if you have to precompile
a header, you're slowing down the whole machine.

00:22:02.190 --> 00:22:04.480
So try not to.

00:22:04.480 --> 00:22:10.170
Now precompiled headers are interesting because
they are very sensitive to configuration.

00:22:10.170 --> 00:22:16.039
You're going to need a separate precompiled header for
each language dialect that you're using, C, C++,

00:22:16.039 --> 00:22:21.000
Objective-C, because the compiler interprets
the headers differently for each language.

00:22:21.000 --> 00:22:23.869
You're going to need one for each architecture you build.

00:22:23.869 --> 00:22:27.949
If you build four architectures, you're
going to need four precompiled headers.

00:22:27.950 --> 00:22:35.990
You may need one for each target because for each prefix
file by name, we generate a different precompiled header

00:22:35.990 --> 00:22:40.880
and you're going to need one for each variant you use.

00:22:40.880 --> 00:22:48.730
If you do different compile flags that affect the way
that the headers are interpreted and preprocessed,

00:22:48.730 --> 00:22:51.740
they'll generate a separate precompiled
header in those cases.

00:22:51.740 --> 00:22:57.690
It's easy to see how one little target could generate
8, 12, 16, precompiled headers,

00:22:57.690 --> 00:23:01.100
each of which are 32 megabytes in size.

00:23:01.099 --> 00:23:04.609
That's a lot of data moving back and forth.

00:23:04.609 --> 00:23:07.069
That can make your build sub-optimal.

00:23:07.069 --> 00:23:10.710
The most important things you can do are
reduce the number of precompiled headers.

00:23:10.710 --> 00:23:15.759
First use the same prefix file
over and over again if you can.

00:23:15.759 --> 00:23:20.750
Instead of having a different named prefix
file that just pound includes Cocoa, Cocoa.h

00:23:20.750 --> 00:23:24.400
or Carbon, Carbon.h, use the same prefix file.

00:23:24.400 --> 00:23:28.019
If you use the same name, you will
cut the number of precompiled headers

00:23:28.019 --> 00:23:30.650
in half if you follow all the other advice.

00:23:30.650 --> 00:23:37.320
But the second is to reduce the number of different variants
you have to produce because of compiler flags you use

00:23:37.319 --> 00:23:46.589
and it's really hard to tell how to, why you're having on
precompiled header on your system and then you go and build

00:23:46.589 --> 00:23:48.720
and another precompiled header is generated..

00:23:48.720 --> 00:23:49.660
What's that all about?

00:23:49.660 --> 00:23:57.990
Well the secret is in, the secret is in this large string.

00:23:57.990 --> 00:24:05.740
That's a MD5 hash of the settings we used to
generate the precompiled header and so you can see

00:24:05.740 --> 00:24:09.430
that if there's a unique hash,
a unique header was generated.

00:24:09.430 --> 00:24:15.529
Now all the question is, why was it
generated and the why is actually contained

00:24:15.529 --> 00:24:20.649
in this secret filed called pch.gch.hash-criteria.

00:24:20.650 --> 00:24:28.300
By looking inside that file, you'll be able to see what
caused Xcode to generate a different precompiled header

00:24:28.299 --> 00:24:32.759
and to show you some useful techniques in
finding that out and fixing the problems,

00:24:32.759 --> 00:24:36.539
here's Rick Ballard of the Xcode team with the demo.

00:24:36.539 --> 00:24:37.460
>> Thanks Chris.

00:24:37.460 --> 00:24:42.120
( applause )

00:24:42.119 --> 00:24:48.949
So I've got a very simple project here with two targets
and this tool target builds the framework target

00:24:48.950 --> 00:24:54.460
when you build it, they're related and I want to
see what I can do about improving my build time.

00:24:54.460 --> 00:24:56.990
So I'm going to start out and see
what the current situation is.

00:24:56.990 --> 00:25:04.059
Let's open up the build results window and I'm going to make
sure if you're not familiar with the build results window,

00:25:04.059 --> 00:25:09.059
in the lower left or in the middle if you've got an
embedded editor showing there are these little buttons.

00:25:09.059 --> 00:25:11.419
I'm going to make sure that this left most button is on.

00:25:11.420 --> 00:25:16.680
That will show me all the build steps even after they've
occurred and I'm going to make sure that the third

00:25:16.680 --> 00:25:20.220
to left button is on, which shows the build transcript.

00:25:20.220 --> 00:25:24.000
That'll show me the underlying commands that Xcode is using.

00:25:24.000 --> 00:25:32.309
So let's go ahead and build this project and you can see, it
build a precompiled header here from my framework target.

00:25:32.309 --> 00:25:38.359
And then when it went to build the tool target
it built another precompiled header here.

00:25:38.359 --> 00:25:44.529
So we're building that twice and this is a small project
so it built very quickly, but if this was a larger project

00:25:44.529 --> 00:25:50.619
or it had more targets, that precompiled header generation
could be a substantial portion of the time of my build.

00:25:50.619 --> 00:25:54.129
It's definitely a place to get some savings.

00:25:54.130 --> 00:26:02.620
So let's look at how we can make these two targets build and
share one precompiled header instead of building it twice.

00:26:02.619 --> 00:26:04.079
This is a neat little trick.

00:26:04.079 --> 00:26:12.869
I'm going to first start out by selecting the precompiled
header, build step in the build log and since I've turned

00:26:12.869 --> 00:26:18.149
on my complete build transcript, you can see
it's highlighted in the build transcript,

00:26:18.150 --> 00:26:23.560
the actually command Xcode used
to precompile that prefix header.

00:26:23.559 --> 00:26:29.349
The last thing on that line, you don't need to read
it here, but the last thing in the line is going

00:26:29.349 --> 00:26:33.299
to be the actual precompiled header generated.

00:26:33.299 --> 00:26:40.009
What I'm going to do here is I'm going to go launch file merge,
which is an application we ship in the develop folder.

00:26:40.009 --> 00:26:47.230
If you go to developer, applications, utilities, file merge,

00:26:47.230 --> 00:26:50.250
this will help me compare the two
files I want to look at in a nice way.

00:26:50.250 --> 00:26:58.839
I'm going to go ahead go back to my project, select
the precompiled header directory it created.

00:26:58.839 --> 00:27:01.789
Not the actual precompiled header file.

00:27:01.789 --> 00:27:06.599
You can see there I've selected everything
up to the actual precompiled header

00:27:06.599 --> 00:27:18.309
I'm just going to drag that, oops, just going to drag this
line into file merge, you could copy, paste it as well.

00:27:18.309 --> 00:27:22.139
So that tells the file merge that I'm
going to want to compare that directory

00:27:22.140 --> 00:27:26.740
with well let's select the other
precompiled header step and again,

00:27:26.740 --> 00:27:33.470
the last line is the precompiled header it generated, I'm
going to select the directory, drag it right into file merge.

00:27:33.470 --> 00:27:39.450
When I hit compare here, file merge is going to tell me what's
different about these two precompiled header directories.

00:27:39.450 --> 00:27:41.299
Let's go ahead and do that.

00:27:44.730 --> 00:27:46.250
And there are two things that are different here.

00:27:46.250 --> 00:27:52.740
One is the actual precompiled header that's generated, but
the other says hash-criteria file that Chris told you about,

00:27:52.740 --> 00:27:58.730
which tells us what the criteria was that made
Xcode decide it had to compile two of these.

00:27:58.730 --> 00:28:02.089
So if I go ahead and double click
on this hash-criteria file,

00:28:02.089 --> 00:28:07.849
there's one difference and that's this -DHWDEBUG flag.

00:28:07.849 --> 00:28:11.929
Well that's just a preprocessor
define, a C preprocessor define.

00:28:11.930 --> 00:28:17.710
I'm defining the HWDEBUG define and that's
because this project is using that as a debug flag

00:28:17.710 --> 00:28:22.170
to do some extra logging when I'm in my debug configuration.

00:28:22.170 --> 00:28:26.950
Well I'm only defining that for my framework
target, because my tool target either doesn't use

00:28:26.950 --> 00:28:31.080
that same flag or doesn't want debug logging on.

00:28:31.079 --> 00:28:39.139
I could add it to both to make them use the same
criteria or I can go back, I'm going to close file merge.

00:28:39.140 --> 00:28:45.040
Close my build results and I'm going to look
at my build settings and my framework target

00:28:45.039 --> 00:28:47.779
and look for the preprocessor to find I actually set.

00:28:47.779 --> 00:28:54.259
So I could scroll through this list, but instead
I'm going to filter on preprocessor and you can see,

00:28:54.259 --> 00:28:59.859
I'm defining a preprocessor macro
here but we provide a second setting

00:28:59.859 --> 00:29:05.809
which is named preprocessor macros not
defined in the precompiled headers.

00:29:05.809 --> 00:29:11.819
In this case, I don't need my personal debugging macro
defined when I'm pre-compiling the header so I can go ahead

00:29:11.819 --> 00:29:18.119
and delete this preprocessor macro setting and
I can edit the preprocessor macros not used

00:29:18.119 --> 00:29:24.089
in precompiled headers, add it to that setting.

00:29:24.089 --> 00:29:27.480
Now when I build I'll still get
this preprocessor macro defined,

00:29:27.480 --> 00:29:30.569
but it won't effect my precompiled header generation.

00:29:30.569 --> 00:29:31.759
Let's see what effect that has.

00:29:31.759 --> 00:29:38.160
I'm going to go back and clean out my build, build again.

00:29:38.160 --> 00:29:43.100
You can see from my framework, it's building a
precompiled header but when it built the target

00:29:43.099 --> 00:29:46.419
for the tool, it didn't rebuild a precompiled header.

00:29:46.420 --> 00:29:51.150
That tool target is now sharing the same
precompiled header I built for my framework.

00:29:51.150 --> 00:29:55.860
Can't tell on such a fast machine with such a small
project, but I probably just cut my build time in half.

00:29:55.859 --> 00:30:00.979
This is a technique you can use to make
substantial savings in your own build times.

00:30:00.980 --> 00:30:02.059
Back to you Chris.

00:30:02.059 --> 00:30:02.879
>> Thanks Rick.

00:30:02.880 --> 00:30:09.140
( applause )

00:30:09.140 --> 00:30:16.730
So because building a precompiled header is a choke point
in building your target, it's really important to eliminate

00:30:16.730 --> 00:30:23.370
that in order to get as much speed as possible in also in
reusing precompiled headers, shares space on your disk,

00:30:23.369 --> 00:30:25.919
there's less swapping, there's less disk access.

00:30:25.920 --> 00:30:31.110
It's all around better to try to use, share
as many precompiled headers as possible.

00:30:31.109 --> 00:30:36.199
I mean think of a situation where you have
a project that's building 40 targets

00:30:36.200 --> 00:30:39.190
that are all plug-ins and they're all identical.

00:30:39.190 --> 00:30:44.950
If they all have their own prefix file and each
builds a precompiled header, that may be two

00:30:44.950 --> 00:30:48.080
or three seconds per target to
build that precompiled header.

00:30:48.079 --> 00:30:54.240
If you can eliminate that two or three seconds per
target that's several minutes shaved off your build.

00:30:54.240 --> 00:30:58.450
Now even with that, there are other choke points.

00:30:58.450 --> 00:31:06.240
Such as copying resources and linking and things like that
and when you build a project that has an aggregate target,

00:31:06.240 --> 00:31:10.279
that is a target that simply says build this
target and then that target and then that target

00:31:10.279 --> 00:31:14.269
and then that target, Xcode serializes that operation.

00:31:14.269 --> 00:31:19.059
First it looks at the dependencies among
them then builds the prerequisites first

00:31:19.059 --> 00:31:23.799
and then builds everything in order after that, one by one.

00:31:23.799 --> 00:31:29.710
Now this is problematic because
you have, you most of the time,

00:31:29.710 --> 00:31:32.990
you're not using all of the extra
processors in your machine.

00:31:32.990 --> 00:31:39.000
Because they only build phases that can really use
those processors are the Compile Sources build,

00:31:39.000 --> 00:31:41.190
the Compile Sources build phases.

00:31:41.190 --> 00:31:45.130
All the other build phases are just going one by one by one.

00:31:45.130 --> 00:31:49.460
In Xcode 3.0, we allow you
to do something very interesting.

00:31:49.460 --> 00:31:58.100
You can check a checkbox in the project inspector and say,
I want to build my targets in parallel whenever possible.

00:31:58.099 --> 00:32:03.309
And what that means is that after Xcode
determines the dependencies between targets

00:32:03.309 --> 00:32:11.960
and builds the early ones first, it will build all
of the build phases of each target in parallel.

00:32:11.960 --> 00:32:17.170
So that they can overlap and use as much processor
is as available at that time and that means

00:32:17.170 --> 00:32:25.910
if one target is doing a copy files phase which is only
using one processor, because it's primarily disk bound

00:32:25.910 --> 00:32:32.580
and not really processor bound, another target which is
heavily processor bound, building a lot of source code,

00:32:32.579 --> 00:32:37.480
can be using the other six or seven
processors on the machine in order to do that.

00:32:37.480 --> 00:32:43.910
You can see how in that project that built
40 targets for example, 40 plug-ins,

00:32:43.910 --> 00:32:50.570
building those 40 plug-ins ser@ially, where each
one has a single source file, may take a long time.

00:32:50.569 --> 00:32:57.509
But building those targets in groups of eight, when you can
compile all eight source files for eight targets in parallel

00:32:57.509 --> 00:33:01.339
and then go on to the next one, will be much, much faster.

00:33:01.339 --> 00:33:09.139
In order to make this work, you have to ensure
that your intertarget dependencies are rock solid.

00:33:09.140 --> 00:33:14.520
Because this will expose hidden assumptions in your project.

00:33:14.519 --> 00:33:20.529
If you happen to have a linear list of targets that are
always built in this order, when you check that checkbox,

00:33:20.529 --> 00:33:26.759
sometimes this target might be
built first, just because we could.

00:33:26.759 --> 00:33:32.210
If that target happens to depend on something that
needed to built earlier, that build is going to fail

00:33:32.210 --> 00:33:34.960
and what's worse it's going to fail intermittently.

00:33:34.960 --> 00:33:40.460
Because introducing parallelism
introduces non-deterministic behavior.

00:33:40.460 --> 00:33:48.340
So you have to have your intertarget dependencies rock
solid before you turn on parallel targets or you're going

00:33:48.339 --> 00:33:52.339
to get behavior that is non-deterministic
and sometimes erroneous.

00:33:52.339 --> 00:34:00.629
On case we found is when one target used Yak to
build an intermediate C file out of a Yak file

00:34:00.630 --> 00:34:07.980
and that C file was actually compiled by another
target, that didn't have a dependency back on the first

00:34:07.980 --> 00:34:15.110
and so if that target happened to fire first, it looked for
the C file, the other target hadn't even run yet, it failed.

00:34:15.110 --> 00:34:17.780
That's a place where the linear
structure of the project that used

00:34:17.780 --> 00:34:23.400
to impose order didn't work when we went in parallel.

00:34:23.400 --> 00:34:27.539
But once again, I think this is better demoed
than talked about and here's Rick again.

00:34:28.719 --> 00:34:36.219
>> So to show you Parallel Target Builds, I'm going to demo
this with a neat little application called Colloquy,

00:34:36.219 --> 00:34:42.659
it's a free internet chat client that makes their
source available and one of the things about Colloquy is

00:34:42.659 --> 00:34:49.839
that it has a plug-in API with a lot of different plug-ins
and plug-ins, these plug-ins don't have any dependencies

00:34:49.840 --> 00:34:53.079
on each other and they don't compile a whole lot of files.

00:34:53.079 --> 00:34:57.849
They're doing more of the sort of
steps that aren't parallelized already.

00:34:57.849 --> 00:35:01.789
So they're a really great case to take
advantage of Parallel Target Builds.

00:35:01.789 --> 00:35:08.320
So I've got a simple project here which just builds
a few of their plug-ins and I'm going to go ahead

00:35:08.320 --> 00:35:11.200
and open up the build results and
show you how this works right now.

00:35:11.199 --> 00:35:16.159
If I click build, you can see it's building the
first plug-in here which is a support plug-in.

00:35:16.159 --> 00:35:21.629
Now it's building the next and the next, then the
next and when this one's checking it's dependencies,

00:35:21.630 --> 00:35:25.780
the next one hasn't started yet, they're
all building in serial right now.

00:35:26.880 --> 00:35:35.700
What happens if I clean this out, go back and if
I go to my project menu and edit project settings,

00:35:35.699 --> 00:35:42.119
this will open up our project info window, there's
a little checkbox here, shows, let me zoom in on,

00:35:42.119 --> 00:35:45.920
called build independent targets in parallel.

00:35:45.920 --> 00:35:56.530
All I have to do is click this one checkbox, close
the project settings, open my build results back up

00:35:56.530 --> 00:36:00.170
and let's see what happens when I build this again.

00:36:00.170 --> 00:36:02.220
See all that going on in parallel?

00:36:02.219 --> 00:36:05.289
Each target is building while the
other targets are building.

00:36:05.289 --> 00:36:06.739
I'm not waiting for one to finish.

00:36:06.739 --> 00:36:07.879
That went by really quickly.

00:36:07.880 --> 00:36:09.860
Let me show you that again.

00:36:11.599 --> 00:36:16.630
Boom. Five of them at once, six of them
at once, they're all going and we're done.

00:36:16.630 --> 00:36:17.559
Parallel Target Builds.

00:36:17.559 --> 00:36:23.000
If you can straighten out your dependencies or have
targets where you don't have dependencies between them

00:36:23.000 --> 00:36:30.019
that aren't expressed, turn it on and you can
see a big improvement in your build times.

00:36:30.019 --> 00:36:33.619
( applause )

00:36:33.619 --> 00:36:35.849
>> Thanks Rick.

00:36:35.849 --> 00:36:40.219
Have I mentioned that your dependencies have to
be rock solid in order to really use this feature?

00:36:40.219 --> 00:36:47.189
We're expecting a whole lot of support calls on you know, I
turned on parallel targets and my project failed to build.

00:36:47.190 --> 00:36:52.110
You really have to make sure your dependencies are
rock solid before you turn on parallel targets.

00:36:52.110 --> 00:36:56.610
Also, it won't necessarily do much if
you have a typical application project

00:36:56.610 --> 00:36:59.349
that is very heavy on the source code files.

00:36:59.349 --> 00:37:05.369
It's not, it's only going to parallelize
the steps that are currently choke points.

00:37:05.369 --> 00:37:08.750
If you have something that's very
heavy on source code compilation,

00:37:08.750 --> 00:37:11.269
you're probably using all the processor you've got anyway.

00:37:11.269 --> 00:37:13.369
Can I have the slides back please?

00:37:18.619 --> 00:37:23.579
Now parallel targets is going to be used
best with our distributed build features.

00:37:23.579 --> 00:37:30.849
Distributed build features let you go beyond the
four or eight processors that are in one machine

00:37:30.849 --> 00:37:36.369
and use as many processors as you can find in
the local area or on a dedicated build farm.

00:37:36.369 --> 00:37:41.460
It's always a trade off because you have to spend
the time preparing the files and shipping them

00:37:41.460 --> 00:37:48.510
over to the other machines and so on certain kinds of files
you know, short C files, you're not going to gain as much

00:37:48.510 --> 00:37:54.000
by letting another machine do the work for you as you
will in preparing, sending and receiving the results.

00:37:54.000 --> 00:38:00.849
But if you're compiling a lot of C++ files that
are computationally intense, then using other machines

00:38:00.849 --> 00:38:05.699
to do your builds for you, can
really improve your build speeds.

00:38:05.699 --> 00:38:10.269
We have two basic ways to do distributed builds on Xcode.

00:38:10.269 --> 00:38:16.259
One is called shared workgroup builds and it's for casual
ad hawk, just using what other resources are around.

00:38:16.260 --> 00:38:20.950
A couple of machines in your office
or that guy who's gone to lunch.

00:38:20.949 --> 00:38:25.089
Dedicated network builds is more for
setting up a build farm of machines

00:38:25.090 --> 00:38:29.860
that your whole workgroup is going
to use that everybody can share.

00:38:29.860 --> 00:38:38.110
The way shared workgroup builds works is it uses a
common UNIX tool called distcc, to distribute jobs.

00:38:38.110 --> 00:38:45.690
Because distcc works best when you're just sending a single
file at at time, what we do is we take your source code file

00:38:45.690 --> 00:38:50.059
and we pre-process it so we get one .i file.

00:38:50.059 --> 00:38:57.259
We send the one .i file using UNIX pipes
over the network, to the volunteer machine,

00:38:57.260 --> 00:38:59.810
it builds it and then sends back the .o files.

00:38:59.809 --> 00:39:03.230
It's just a one time eyes closed transaction.

00:39:03.230 --> 00:39:04.840
There's no persistent state.

00:39:04.840 --> 00:39:07.660
One file goes across, one file comes back.

00:39:07.659 --> 00:39:12.149
That's why it's really good for casual set up,
just whatever machine happens to be available.

00:39:12.150 --> 00:39:15.970
If machines come and go, we don't
mind, we just pick another machine.

00:39:15.969 --> 00:39:20.129
We actually use Bonjour to browse
local resources to set it up

00:39:20.130 --> 00:39:25.090
At some point though you spend too much time on your
host machine preparing, preprocessing and shipping

00:39:25.090 --> 00:39:31.000
out these files and taking them back, than you actually
get benefit of the other machines compiling them.

00:39:31.000 --> 00:39:36.420
That's why shared workgroup builds is really
good for you know, under five other machines,

00:39:36.420 --> 00:39:41.780
it can speed up certain builds but if you you
know, you try to connect to six or more machines,

00:39:41.780 --> 00:39:44.780
it's just not going to improve your build times that much.

00:39:44.780 --> 00:39:51.580
To do that you need dedicated network builds and
dedicated network builds uses a different architecture.

00:39:51.579 --> 00:39:56.210
First you pre-configure the hosts you're
going to use by host name or IP address

00:39:56.210 --> 00:39:58.360
and really those tend to be dedicated machines.

00:39:58.360 --> 00:40:04.380
They can be Xserves, they can be Mac minis
sitting on a rack in a room and they're configured

00:40:04.380 --> 00:40:08.599
to be optimal compilation systems
and they're not doing anything else.

00:40:08.599 --> 00:40:17.949
Second is we map in a file system, a shared file system
so that the volunteer machines can get at your prefix file

00:40:17.949 --> 00:40:22.989
and your precompiled header file and any other
resources you're using so all we have to ship

00:40:22.989 --> 00:40:31.109
across is the source code file and they can come back to the
shared file system and get any other resources they need.

00:40:31.110 --> 00:40:36.050
If all of the volunteer systems are
going to one shared system to pick up

00:40:36.050 --> 00:40:43.280
or map in the same precompiled header file, then it's a lot
faster than to send the preprocessed files over every time.

00:40:43.280 --> 00:40:48.620
So it scales much, much better and it's much
better if you have a rack and centralized machine.

00:40:48.619 --> 00:40:52.849
Now a caveat right now in both Xcode
2.5 Leopard Developer Preview

00:40:52.849 --> 00:40:56.440
and Xcode 3.0 Leopard Developer Preview,

00:40:56.440 --> 00:41:03.519
neither shared workgroup builds nor
dedicated network builds is actually working.

00:41:03.519 --> 00:41:08.110
It's working in the shipping Xcode 2.4.1
on Tiger and we will have both

00:41:08.110 --> 00:41:09.860
of these shipping and working really well.

00:41:09.860 --> 00:41:14.289
We're working with a couple of our key partners
to make this sing for the Leopard final release.

00:41:14.289 --> 00:41:17.210
But due to a couple of other things,
they're both not working right now.

00:41:17.210 --> 00:41:21.730
You can look at the user interfaces and see
what we're going to ship in the Leopard final,

00:41:21.730 --> 00:41:24.309
but they're not working right, right yet.

00:41:25.659 --> 00:41:31.119
Okay, we've covered a lot of project configuration,
we've covered building for different architectures,

00:41:31.119 --> 00:41:36.750
we've covered optimizing for speed, now
you want to build your project bigger.

00:41:36.750 --> 00:41:42.719
You want to build more complex projects, you want to build
more intricate projects and you need to customize them.

00:41:42.719 --> 00:41:46.629
Customization is the most interesting thing
you can do with the Xcode build system,

00:41:46.630 --> 00:41:50.150
because that's where the power of
all these build settings comes in.

00:41:50.150 --> 00:41:55.240
And I'm not going to go through the hundreds of build
settings we have that allow you to customize your project,

00:41:55.239 --> 00:42:01.789
but I'm going to focus on a couple of the new ones that
make things a lot easier on Xcode 3.0.

00:42:01.789 --> 00:42:06.090
We're going to talk about some new build
settings to build embedded frameworks,

00:42:06.090 --> 00:42:14.079
we're going to talk about the SDK root build setting that
allows you to build against software development kits

00:42:14.079 --> 00:42:19.199
and we're going to talk about building the same
project against multiple versions of Xcode as well

00:42:19.199 --> 00:42:22.609
as building gnu-based projects using the core gnu tools,

00:42:22.610 --> 00:42:27.519
especially now that the developer
tools folder is self contained.

00:42:27.519 --> 00:42:31.199
So let's start with applications with embedded frameworks.

00:42:31.199 --> 00:42:34.460
This is the Mac OS X way of packaging software.

00:42:34.460 --> 00:42:38.130
We talk about this in the very basic introductory materials.

00:42:38.130 --> 00:42:41.809
We talk about it in how you structure an application.

00:42:41.809 --> 00:42:46.980
Don't install shared libraries on the
machine, don't give users a package of stuff.

00:42:46.980 --> 00:42:53.360
Embed your frameworks, embed your subsidiary
code as frameworks inside your application.

00:42:53.360 --> 00:42:57.800
Yet it's surprisingly difficult to set that up in Xcode.

00:42:57.800 --> 00:43:02.700
We were talking to our technical writer about it
when we were explaining this feature and he said,

00:43:02.699 --> 00:43:06.199
you just cut a page and a half out of the manual.

00:43:06.199 --> 00:43:08.699
Because it's a lot of work right now.

00:43:08.699 --> 00:43:14.679
You have to run an auxiliary tool to set up
the installation path of the dynamic library,

00:43:14.679 --> 00:43:18.169
the framework, so that the application can find it.

00:43:18.170 --> 00:43:26.329
Well we've added a new build setting into the Xcode
build settings called Dynamic Library Install Name

00:43:26.329 --> 00:43:32.019
and you set this on any framework that you build,
that's going to be embedded in an application

00:43:32.019 --> 00:43:38.590
and you set it's value to this special path
@executable_path means what was launched,

00:43:38.590 --> 00:43:45.530
.. means go up past the Mac OS folder, frameworks
means oh the frameworks directory of that executable

00:43:45.530 --> 00:43:49.850
and then EXECUTABLE_PATH is how you get to me from there.

00:43:49.849 --> 00:43:55.420
And that means every, when your application links
against your framework and your framework's loaded,

00:43:55.420 --> 00:44:00.340
the framework will know hey, this is my load
location and I can be invoked from the application.

00:44:00.340 --> 00:44:05.590
On the application target, all you have to do is take
the built framework build product from the other target

00:44:05.590 --> 00:44:12.240
or project and copy it into your applications frameworks
directory in the path that's indicated there and that's it.

00:44:12.239 --> 00:44:16.819
You don't have to invoke lib tool, you don't
have to run a separate install name tool,

00:44:16.820 --> 00:44:19.280
it's all set up there in one build setting.

00:44:19.280 --> 00:44:20.980
It's going to be much more convenient.

00:44:20.980 --> 00:44:25.480
( applause )

00:44:25.480 --> 00:44:28.840
Now there are some cases where you
want to build a framework that is used

00:44:28.840 --> 00:44:33.130
by multiple applications or maybe put in multiple locations.

00:44:33.130 --> 00:44:38.490
You don't want to hard coat it to being up
and over from the application executable

00:44:38.489 --> 00:44:40.799
because it may be used in different places.

00:44:40.800 --> 00:44:46.970
Well the Linux community has long had this thing
called rpath and we have it in Mac OS X now in dyld

00:44:46.969 --> 00:44:53.989
and rpath is a Runpath Search Paths
facility that allows a dynamic library to say,

00:44:53.989 --> 00:44:58.259
you can find me relative to any of your known search paths.

00:44:58.260 --> 00:45:02.280
So using Runpath Search Paths when
you build an embedded framework,

00:45:02.280 --> 00:45:08.280
you just say my dynamic library install
name is @rpath/my path.

00:45:08.280 --> 00:45:16.019
So it's whoever's using me, whoever linked to me,
can find me via their rpaths according to my name.

00:45:16.019 --> 00:45:19.800
And then in each client that you
build against that framework,

00:45:19.800 --> 00:45:26.860
you simply say the Run Set Path Search Paths are well here's
my executable and I'm going to put in the frameworks folder

00:45:26.860 --> 00:45:32.860
or if another application wants to put it in
a shared location like we do this with Xcode,

00:45:32.860 --> 00:45:38.720
we put all of our frameworks in a library
folder relative to the Xcode executable.

00:45:38.719 --> 00:45:42.899
And so we find all our frameworks that
way, via that Runpath Search Paths.

00:45:42.900 --> 00:45:50.099
So this is a very powerful facility to ship a
suite of applications or tools that all share a set

00:45:50.099 --> 00:45:54.269
of common libraries and can all find them very easily.

00:45:55.670 --> 00:45:59.240
And to demo that I'm going to turn that over to Rick again.

00:46:01.340 --> 00:46:05.100
>> So I'm going to start out by showing
you what Chris first showed you,

00:46:05.099 --> 00:46:08.719
simple use of the new dynamic library
install name build setting.

00:46:08.719 --> 00:46:14.049
I should mention this is only available
in Xcode 3.0 so you need to wait

00:46:14.050 --> 00:46:18.269
until you can move entirely to
Xcode 3.0 before you can adopt it.

00:46:18.269 --> 00:46:24.570
But here I've got a framework and a self
contained application that wants to link

00:46:24.570 --> 00:46:29.100
against this framework and embed
it in it's application bundle.

00:46:29.099 --> 00:46:32.829
So that it's a completely removable, relocatable application.

00:46:32.829 --> 00:46:38.119
So I've got a cross-project dependency
on my framework project.

00:46:38.119 --> 00:46:42.739
My target for my application depends on my framework target.

00:46:42.739 --> 00:46:48.949
I link against it, it's red because I
haven't built it yet and I actually copy it

00:46:48.949 --> 00:46:54.649
into my applications frameworks
directory using a copy files build phase.

00:46:56.760 --> 00:46:58.790
Well how did I set up this framework target?

00:46:58.789 --> 00:47:03.320
If I go and look at it's build settings, filtered
for the new dynamic library install name,

00:47:03.320 --> 00:47:07.559
you can see here that the dynamic library install name

00:47:07.559 --> 00:47:14.960
for my framework is @executable_path/../
Frameworks/the EXECUTABLE_PATH build setting

00:47:14.960 --> 00:47:20.360
which resolves to the name of frameworks
dyLib binary inside it's wrapper.

00:47:23.000 --> 00:47:32.179
So when I go ahead and build my self contained application
here, it's building right now, if I go and take a look

00:47:32.179 --> 00:47:38.179
at it, here's my built application, I'm going to look at
it in the finder because when you run within Xcode,

00:47:38.179 --> 00:47:43.929
Xcode helps your applications find things in your own
build products directory with a little dyld magic.

00:47:43.929 --> 00:47:48.419
So we're going to run them from the finder so that we can
be absolutely sure that we have our linking set up right

00:47:48.420 --> 00:47:51.809
and that we're not relying on the
crutches that Xcode gives us.

00:47:51.809 --> 00:47:59.239
Here I've got my application I just built, I can take a look
inside with the show package contents contextual menu item

00:47:59.239 --> 00:48:04.439
and you can see that there's a frameworks directory in
this application and it's got my framework embedded in it.

00:48:04.440 --> 00:48:13.289
When I run the application it links or runs
rather and if I drag it somewhere else,

00:48:13.289 --> 00:48:18.639
since it's got the framework it needs
embedded inside it, it still runs.

00:48:18.639 --> 00:48:25.339
The disadvantage of this current approach here is
that if I want to use that framework somewhere else,

00:48:25.340 --> 00:48:32.260
some client which doesn't embed it at the main executable/
../frameworks relative to itself,

00:48:32.260 --> 00:48:38.410
I'd have to add some run script phase,
run some extra tool, do some other magic

00:48:38.409 --> 00:48:40.679
or build a different version of that framework.

00:48:40.679 --> 00:48:43.210
I shouldn't have to build that framework twice.

00:48:43.210 --> 00:48:49.230
See what happens with that fixed framework app, which it
instead of embedding the framework, for whatever purpose,

00:48:49.230 --> 00:48:55.000
wants to put it in a /library in it's
own location and link against it there.

00:48:55.000 --> 00:49:06.389
Well if I build this application and I go take a look at
it in the finder, if I launch it it crashes immediately

00:49:06.389 --> 00:49:10.210
with some obscure dyld error about
not being able to load the framework.

00:49:10.210 --> 00:49:18.309
Well the easiest way to fix this is to adopt Runpath
search paths and I'm going to show you how to do that.

00:49:18.309 --> 00:49:26.809
First I'm going to go to my framework target, inspect it's
build settings and I'm just going to search for Runpath

00:49:26.809 --> 00:49:32.259
and see there's a new Runpath Search Paths build setting
and it can have multiple values, in this case I'm sorry,

00:49:32.260 --> 00:49:37.080
I won't actually set the dynamic
library install name on this target,

00:49:39.309 --> 00:49:44.119
so right now it's set to the
@executable_path based value.

00:49:44.119 --> 00:49:48.339
I'm just going to get rid of all this that tells
whoever links against it where to find it

00:49:48.340 --> 00:49:53.010
and say find me wherever you want
to with your Runpath Search Paths.

00:49:53.010 --> 00:50:00.860
So now the dynamic library install name of my
framework is just @rpath/the rest of my path.

00:50:00.860 --> 00:50:05.820
Go ahead and commit that.

00:50:05.820 --> 00:50:13.789
Now I'm going to go to my application here and this is where in
it's build settings, oops going to double click on the target,

00:50:13.789 --> 00:50:22.029
going to filter on Runpath Search Paths, here I can
give it a value of well in this case I want that rpath

00:50:22.030 --> 00:50:36.960
to be still @executable_path/../Frameworks,
so I can just type that in oops,

00:50:36.960 --> 00:50:56.440
little Xcode 3.0 bug, build my self contained application
and see I can still move it, it still launches just fine,

00:50:56.440 --> 00:51:01.559
even thought it's framework didn't specify
the full dynamic library install name anymore,

00:51:01.559 --> 00:51:07.889
it used the Runpath Search Paths
in the self contained application.

00:51:07.889 --> 00:51:10.460
Let's go over and look at my fixed framework app.

00:51:10.460 --> 00:51:14.740
Well it also need to specify where to find that framework.

00:51:14.739 --> 00:51:17.339
It's going to find it in a different location.

00:51:17.340 --> 00:51:24.870
So I'm just going to go to my copy files phase here,
which is where I specified where to put the framework,

00:51:26.000 --> 00:51:32.940
I'm going to copy that and put that in as a
Runpath Search Path for this application.

00:51:36.480 --> 00:51:43.400
Let's go ahead and build this, take
a look at it here and now it launches

00:51:43.400 --> 00:51:48.660
because it's using it's Runpath Search Paths
to find the framework where it copied it.

00:51:48.659 --> 00:51:52.519
There's a lot more you can do with rpaths,
it's a very powerful and useful tool.

00:51:52.519 --> 00:51:56.889
At the very least it can help you organize
how you link to things even if you don't need

00:51:56.889 --> 00:51:59.989
to use it for it's more complicated affordances.

00:51:59.989 --> 00:52:02.489
I highly encourage you to check it out.

00:52:02.489 --> 00:52:08.189
One thing to keep in mind again, this is a new Leopard
feature, so you need to wait until you can adopt,

00:52:08.190 --> 00:52:11.460
you can use Leopard as your minimum
platform before you can use rpaths.

00:52:11.460 --> 00:52:13.389
Back to you Chris.

00:52:13.389 --> 00:52:14.279
>> Thank you Rick.

00:52:14.280 --> 00:52:20.210
( applause )

00:52:20.210 --> 00:52:26.630
So using embedded frameworks is one of the things that we
exhort you to do which we've made it more difficult to use

00:52:26.630 --> 00:52:30.650
in Xcode than it ought to be and we're
making easier in Xcode 3.0.

00:52:30.650 --> 00:52:32.619
Another one of those is using SDKs.

00:52:32.619 --> 00:52:39.170
We told you from the time of the universal transition
that you should always target SDKs rather than building

00:52:39.170 --> 00:52:41.250
against the content of your native system.

00:52:41.250 --> 00:52:45.619
It's going to make it a lot easier for you
to be portable from one system to another,

00:52:45.619 --> 00:52:48.369
to build from one platform on another platform.

00:52:48.369 --> 00:52:52.679
It's actually a very crucial part of
our strategy of having multiple copies

00:52:52.679 --> 00:52:55.259
of the development environment on one machine.

00:52:55.260 --> 00:52:57.070
But there's a little problem.

00:52:57.070 --> 00:53:04.230
Is that we support only one SDK and a lot of people have
said well that's not SDKs, the whole purpose of SDKs is

00:53:04.230 --> 00:53:12.969
to blend them together and so one of the very common
things that happens is well you have an application,

00:53:12.969 --> 00:53:20.209
you want to build it against the 10.4u SDK because
that's the way to build universal software for Tiger,

00:53:20.210 --> 00:53:24.400
but you want to use the Omni frameworks and
the Omni frameworks come in their own SDK.

00:53:24.400 --> 00:53:29.200
They have their own path from library
frameworks and all their frameworks in them.

00:53:29.199 --> 00:53:31.960
Well with Xcode you have to choose one or another.

00:53:31.960 --> 00:53:38.769
You have to install the Omni frameworks in your system
and then build against the root, the current system

00:53:38.769 --> 00:53:45.280
or you can choose to build against the SDK and lose out on
the Omni frameworks or you can do something really skanky

00:53:45.280 --> 00:53:49.320
like trying to install the Omni
frameworks into your 10.4u SDK

00:53:49.320 --> 00:53:55.450
and create your own custom franken SDK
and people don't do that and I'm glad.

00:53:55.449 --> 00:53:58.989
But in Xcode 3.0, we fixed that.

00:53:58.989 --> 00:54:06.819
The SDK root build setting, the system
SDK build setting, now accepts a list.

00:54:06.820 --> 00:54:12.320
A list of paths and one of those paths can
be the Apple SDK, the system SDK and another

00:54:12.320 --> 00:54:18.860
of those path can be any other SDK that happens to have
libraries, frameworks and headers that you build against

00:54:18.860 --> 00:54:27.030
and then when you go to build, Xcode blends those together
into a composite SDK and compiles and links your application

00:54:27.030 --> 00:54:32.050
against that and it'll do that for every
target that uses that combination of SDKs.

00:54:32.050 --> 00:54:34.100
So it only happens once.

00:54:34.099 --> 00:54:40.420
This makes it very easy for you to use
third party SDKs as well as an Apple SDK

00:54:40.420 --> 00:54:45.409
like the 10.4u universal SDK
or the Leopard 10.5 SDK.

00:54:45.409 --> 00:54:50.769
You can even create your own SDK,
it's very easily to be used this way.

00:54:50.769 --> 00:54:56.420
All you have to do is take your software the builds
into what's called the dest root, the destination root

00:54:56.420 --> 00:55:02.760
and that will look like slash with library or
applications or wherever you want to install your things

00:55:02.760 --> 00:55:06.750
and you call that root you know my.sdk.

00:55:06.750 --> 00:55:14.110
You take the executables in it and you strip them with
strip -c which takes away all of the executable code

00:55:14.110 --> 00:55:16.599
but leaves all the symbols for linking behind

00:55:16.599 --> 00:55:22.159
and then you take away everything else that's
not your header files and the strip executables.

00:55:22.159 --> 00:55:28.639
You put in one file at the top level called SDKSetting.plist
and all it has to have is one key value pair

00:55:28.639 --> 00:55:35.469
of the name of your SDK so that can show in the pop
up list and then any build settings that you choose

00:55:35.469 --> 00:55:38.279
to have in effect when your SDK is in use.

00:55:38.280 --> 00:55:42.430
If you have a build settings dictionary
in your SDKSettings.plist,

00:55:42.429 --> 00:55:45.509
those build settings will be preset automatically

00:55:45.510 --> 00:55:50.800
when somebody choose your SDK even
if it's blended with an Apple SDK.

00:55:50.800 --> 00:55:57.230
So we hope that those of you who vend frameworks for
other developers to use will take advantage of this

00:55:57.230 --> 00:56:03.630
and those of you who want to use those frameworks
can now very easily use third-party SDKs along

00:56:03.630 --> 00:56:07.610
with the Apple SDKs when building your software.

00:56:09.519 --> 00:56:10.440
One last thing.

00:56:10.440 --> 00:56:16.429
We talked this morning and we talked on Monday
about the self contained developer folder.

00:56:16.429 --> 00:56:20.960
The self contained developer folder for Xcode 3.0
and the self contained developer folder

00:56:20.960 --> 00:56:27.530
for Xcode 2.5 and how Xcode uses everything
in that self contained folder to make it portable.

00:56:27.530 --> 00:56:34.670
Well one important thing about that is that includes
all of the standard gnu development tool chain

00:56:34.670 --> 00:56:38.200
that usually is installed in the system root.

00:56:38.199 --> 00:56:39.119
You can see the theme here.

00:56:39.119 --> 00:56:43.619
We're trying to get you independent
from installing things in slash

00:56:43.619 --> 00:56:48.949
so that you can have your whole development
environment in a separate location and be very portable.

00:56:48.949 --> 00:56:56.949
One of the things we do is we take, we put in the
developer folder our own usr directory slash user

00:56:56.949 --> 00:57:03.149
and it has /usr/include and usr/bin and those
have all of the header files and all of the tools

00:57:03.150 --> 00:57:09.269
and all of the link libraries that are normally
only installed by a developer tool installation.

00:57:09.269 --> 00:57:12.440
They're all there in the self contained developer folder.

00:57:12.440 --> 00:57:20.000
The good news is when you launch Xcode, we map everything
so that we use the compiler and the linker and the debugger

00:57:20.000 --> 00:57:24.639
and the standard C library and the link
libraries and the system headers and everything,

00:57:24.639 --> 00:57:33.769
from the developer tools folders copy as slash
user rather than from root and when you're building

00:57:33.769 --> 00:57:38.639
with Xcode 2.5, even on the
Leopard system, we do the same thing.

00:57:38.639 --> 00:57:46.460
So when you launch Xcode 2.5 on a Leopard system,
you're not touching Leopard's slash user directory at all.

00:57:46.460 --> 00:57:52.789
You're using everything from Xcode 2.5's
usr/bin, user included directory.

00:57:52.789 --> 00:57:54.500
That gives you some integrity.

00:57:54.500 --> 00:57:58.699
That keeps you from mixing and
matching Tiger and Leopard components.

00:57:58.699 --> 00:58:03.809
That's really important but, that's
done automatically by Xcode.

00:58:03.809 --> 00:58:08.840
If you go beyond the bounds of that, if you're doing gnu
style development, if you're doing Makefile development,

00:58:08.840 --> 00:58:17.079
if you're invoking things from the command line, if you have
shell scripts that invoke Makefiles and refer to things

00:58:17.079 --> 00:58:22.440
in usr/bin, usr/lib, usr/include
directly, you need to adapt to that.

00:58:22.440 --> 00:58:25.920
Because if somebody picks up and moves your developer folder

00:58:25.920 --> 00:58:31.460
or if somebody doesn't install the tools
in slash, then those are going to fail.

00:58:31.460 --> 00:58:35.630
So you need to know how these are laid out
and what special things to do with them.

00:58:35.630 --> 00:58:37.780
Here are a couple of important pointers.

00:58:37.780 --> 00:58:42.080
The first thing is, how many of you use gcc_select?

00:58:42.079 --> 00:58:43.009
You may stop now.

00:58:43.010 --> 00:58:45.040
( laughter )

00:58:45.039 --> 00:58:46.570
For a couple of reasons.

00:58:46.570 --> 00:58:52.250
One is when you have multiple developer folders and
multiple sets of tools, gcc_select is ambiguous.

00:58:52.250 --> 00:58:59.699
What am I selecting and for whom. The best way we figured
to eliminate that ambiguity was to eliminate gcc_select

00:58:59.699 --> 00:59:05.359
and just say, if you're using Xcode, you
specify the compiler you want to use by default

00:59:05.360 --> 00:59:12.250
in Xcode's compiler rules pane and if you're
using Makefile or gnu development tools,

00:59:12.250 --> 00:59:18.250
you have to specify which compiler you're
using, by compiler name and path rather

00:59:18.250 --> 00:59:23.739
than just having some mystical system setting that sets
up simlinks and assuming you'll get the right answer.

00:59:23.739 --> 00:59:28.469
We don't think it's going to be that much trouble to
migrate to it, especially since the second thing is

00:59:28.469 --> 00:59:34.159
that there's only one compiler to select
among which is GCC 4.0.1.

00:59:34.159 --> 00:59:37.230
There is one compiler installed by Xcode 3.0.

00:59:37.230 --> 00:59:40.300
There is one compiler installed by Xcode 2.5.

00:59:40.300 --> 00:59:43.740
That's GCC 4.0.1.

00:59:43.739 --> 00:59:48.899
If you want to develop for 10.3.9, you
have to install an optional install package

00:59:48.900 --> 00:59:53.950
and that includes the 10.3.9
SDK and the GCC 3.3 compiler.

00:59:53.949 --> 01:00:00.879
So really there's nothing to select among unless
you're specifically doing pre-Tiger development.

01:00:00.880 --> 01:00:08.099
Then you get the 10.3.9 SDK and you get GCC 3.3
and then you have to use GCC 3.3 either

01:00:08.099 --> 01:00:17.829
with the rules pane or by specifying it explicitly in your
Makefile's compilerpath, your CC setting in your Makefile.

01:00:17.829 --> 01:00:19.989
Now there's one special thing.

01:00:19.989 --> 01:00:26.750
We try very hard to keep from mixing Tiger
and Leopard content on a Leopard system.

01:00:26.750 --> 01:00:30.550
Leopard content will never be installed
on a Tiger system, it wouldn't work.

01:00:30.550 --> 01:00:31.900
It would blow up.

01:00:31.900 --> 01:00:36.210
Tiger content is only installed on the
Leopard system in the 2.5 folder

01:00:36.210 --> 01:00:41.240
with one exceptions and that's GCC 3.3.

01:00:41.239 --> 01:00:48.000
There is no Leopard GCC 3.3, there's only a Tiger
GCC 3.3 and so if you install GCC 3.3

01:00:48.000 --> 01:00:51.269
on a Tiger of a Leopard system,
it always goes into /usr/bin.

01:00:51.269 --> 01:00:55.989
It doesn't go into the /usr/bin in the developer folder.

01:00:55.989 --> 01:00:57.529
So that's one thing you don't have to worry about.

01:00:57.530 --> 01:01:04.330
There's only one GCC 3.3 and it's only available
in the 10.3.9 development support package.

01:01:04.329 --> 01:01:11.069
Now I said that there's one GCC 4.0,
GCC 4.0.1, well there's a twist.

01:01:11.070 --> 01:01:13.910
There are different GCC 4.0.1s
for Tiger and Leopard.

01:01:13.909 --> 01:01:20.219
They have different build numbers and different
features, different compatibility, different performance,

01:01:20.219 --> 01:01:22.949
different errors and warnings, different bug fixes.

01:01:22.949 --> 01:01:25.069
They are different compilers.

01:01:25.070 --> 01:01:28.090
But they both report themselves as GCC 4.0.1.

01:01:28.090 --> 01:01:29.610
So just a little warning.

01:01:29.610 --> 01:01:35.910
If you want to report a bug against GCC, please
specify the build number from GCC -v,

01:01:35.909 --> 01:01:39.889
don't just say GCC 4.0.1,
because well we've got a couple of them.

01:01:39.889 --> 01:01:47.569
Okay? If you want to have as I said, you own
make files or your own shell script build phases,

01:01:47.570 --> 01:01:54.450
have access to specific tools even though you
have a portable Xcode DEVELOPER_DIRectory,

01:01:54.449 --> 01:02:04.460
we've provided a few build settings to make
that easy and Rick's going to demo them.

01:02:04.460 --> 01:02:09.710
>> We've got a really simple Makefile base, really,
really simple Makefile-based project here which compiles

01:02:09.710 --> 01:02:16.050
one source file and it uses a C compiler
that it specifies with an absolute path.

01:02:16.050 --> 01:02:23.330
In the past, on OS X, you've been able to assume
that the compiler is at an absolute path in /usr/bin,

01:02:23.329 --> 01:02:28.559
but the linker isn't in absolute path in /usr/bin
and that all the tools are in absolute path.

01:02:28.559 --> 01:02:34.369
Say goodbye to absolute paths if you want
to opt in to using the developer tools

01:02:34.369 --> 01:02:39.089
out of you're currently running
Xcode version's developer folder.

01:02:39.090 --> 01:02:46.570
It's entirely optional, the command line support is on by
default in the installer, so your run script build phases

01:02:46.570 --> 01:02:50.710
and Makefiles can continue to invoke
tools at a /usr/bin if they want.

01:02:50.710 --> 01:02:56.960
But if you want to opt in to using the Xcode 2.5 tools
when your project is built with 2.5, even on Leopard

01:02:56.960 --> 01:03:04.099
or opt into letting people turn off the command line
support package so they have no compiler tools in /usr/bin

01:03:04.099 --> 01:03:09.449
and still be able to build your project, then there
a few simple modifications that you should make

01:03:09.449 --> 01:03:17.309
to your Makefiles, and run script build phases and so
forth, to invoke things out of the developer /user/dir.

01:03:17.309 --> 01:03:20.639
So first of all we're going to get rid of this absolute path.

01:03:20.639 --> 01:03:22.769
What are we going to put in it's place?

01:03:22.769 --> 01:03:30.259
Well when Xcode invokes your Makefiles and run script
phases, it prepends the path environment variable

01:03:30.260 --> 01:03:38.410
with the path to the DEVELOPER_BIN_DIR. So I could do that,
I could specify no path at all, just the name of the tool

01:03:38.409 --> 01:03:45.929
and since I'm being built inside Xcode, it'll find
the version in my developer /usr/bin directory first.

01:03:45.929 --> 01:03:53.599
Or I could use one of the new build settings we provided
which is called DEVELOPER_BIN_DIR. So this is passed

01:03:53.599 --> 01:04:01.610
in the environment and if I make my tool
invocation relative to it, I'll invoke GCC 4.0

01:04:01.610 --> 01:04:07.820
out of my DEVELOPER_BIN_DIR. So let's open up the build
results here and see what happens when I build this.

01:04:10.659 --> 01:04:12.679
Oops, this machine doesn't have zooming on.

01:04:12.679 --> 01:04:17.569
Well you may not be able to read this at
the moment, but it's invoking GCC 4.0

01:04:17.570 --> 01:04:26.470
out of /developer/usr/bin GCC 4.0,
instead of out of /usr/bin GCC 4.0.

01:04:26.469 --> 01:04:33.369
What that means is that if I move this project over to 2.5,
it should invoke 2.5's version of GCC 4.0.

01:04:33.369 --> 01:04:39.750
That's pretty easy to test because I've installed Xcode
2.5 on this machine, it's available as a download

01:04:39.750 --> 01:04:42.519
from the developer.apple.com website.

01:04:42.519 --> 01:04:45.000
It's a pre-release.

01:04:45.000 --> 01:04:52.550
I can just go ahead on Leopard, launch Xcode 2.5,
here it is running side by side with Xcode 3.0

01:04:52.550 --> 01:04:58.160
and I can open my project in Xcode 2.5.

01:04:59.639 --> 01:05:03.219
Now before I build this, there's something I've forgotten

01:05:03.219 --> 01:05:10.549
which is my Makefile is building
against the system headers.

01:05:10.550 --> 01:05:19.780
But as soon as I move over to building with Tiger's tools,
I don't have Tiger system headers on my Leopard system.

01:05:19.780 --> 01:05:26.200
There are all the Tiger developer tools headers
and libraries inside the Xcode 2.5 folder,

01:05:26.199 --> 01:05:32.769
but what I really need to do is build against an SDK to
get the rest of the system headers for my Tiger system.

01:05:32.769 --> 01:05:41.940
So when I go ahead and build this project,
you're going to see oops, should clean first,

01:05:41.940 --> 01:05:46.280
you're going to see that I get an
obscure error from the linker.

01:05:47.599 --> 01:05:55.130
So what I'm going to do is when you're compiling from the
command line with a Makefile, use the -isysroot flag,

01:05:55.130 --> 01:05:59.730
which is documented in the GCC man page
to specify the SDK you want to specify.

01:05:59.730 --> 01:06:12.650
In the past I might have said isysroot /Developer
oops, /Developer/SDKs/MacOSX 10.4u.sdk,

01:06:12.650 --> 01:06:16.450
but that will build against the SDK out of /Developer.

01:06:16.449 --> 01:06:22.169
I might not have an SDK in /Developer, I might
have chosen to install my tools elsewhere and besides,

01:06:22.170 --> 01:06:25.400
/Developer is my 3.0 developer tools folder.

01:06:25.400 --> 01:06:29.519
Instead, I'm going to use another one of the
new environment variables we passed down,

01:06:29.519 --> 01:06:41.219
the DEVELOPER_SDK_DIR. So I'm passing -isysroot
${DEVELOPER_SDK_DIR}/MacOSX10.4u.sdk.

01:06:41.219 --> 01:06:47.980
This is going to make me build against the SDK out
of my Xcode 2.5 folder, wherever that may be.

01:06:47.980 --> 01:06:51.409
On different people's systems if
they install it in different places,

01:06:51.409 --> 01:06:55.139
it'll find GCC and my SDK in the right place.

01:06:55.139 --> 01:07:01.809
Let's go ahead and build and you can see that
my build is succeeded using 2.5 on Leopard.

01:07:01.809 --> 01:07:09.239
So the important things to remember always build against
SDKs, whether you're using a Makefile based project

01:07:09.239 --> 01:07:16.179
or a native project, also requires that you build against an
SDK if you build with 2.5 on Leopard or you choose not

01:07:16.179 --> 01:07:20.639
to install the command line support, in
which case you won't have system headers.

01:07:20.639 --> 01:07:24.549
Build against an SDK and don't use absolute paths.

01:07:24.550 --> 01:07:30.370
Use DEVELOPER_BIN_DIR and there's some others which are in
the documentation like DEVELOPER_DIR and /Developer/usr/dir

01:07:30.369 --> 01:07:33.529
to find the tools that you want to invoke, to invoke them

01:07:33.530 --> 01:07:38.290
out of the self contained developer
directory, wherever that may be.

01:07:38.289 --> 01:07:39.550
Back to you Chris.

01:07:39.550 --> 01:07:39.880
>> Thanks Rick.

01:07:39.880 --> 01:07:52.720
( applause )
Well it's been a longish tour through a lot of intricate
details of the build system, but let's summarize.

01:07:52.719 --> 01:07:57.029
We've got new build system support
for building 64-bit.

01:07:57.030 --> 01:08:02.260
There's a lot of power behind the checkboxes that
just turn on the architecture's build setting.

01:08:02.260 --> 01:08:09.020
We've got new predefined build settings to
help you build fat for your release builds,

01:08:09.019 --> 01:08:12.469
but build as fast as possible thin for your debug builds.

01:08:12.469 --> 01:08:18.859
We've got several useful techniques we've shown you for
managing precompiled headers, for using parallels and write

01:08:18.859 --> 01:08:23.109
and for using distributed builds
in order to speed up your builds.

01:08:23.109 --> 01:08:28.699
We've shown you some useful new build settings for building
embedded framework so that you can actually use Xcode

01:08:28.699 --> 01:08:32.139
to build software the way we tell you to and some techniques

01:08:32.140 --> 01:08:36.360
for building using multiple SDKs
and multiple versions of the tools.

01:08:36.359 --> 01:08:38.759
We really hope that you'll be able to take these,

01:08:38.760 --> 01:08:43.810
apply them using Xcode 3.0
to build better software faster.

01:08:43.810 --> 01:08:48.920
For more information, Matt Formica has been
around all week as your Developer Tools Evangelist,

01:08:48.920 --> 01:08:54.140
there's plenty of documentation in both the Xcode
2.5 and the 3.0 drops.

01:08:54.140 --> 01:08:59.030
I strongly recommend that you open up the new
documentation viewer in Xcode 3.0,

01:08:59.029 --> 01:09:01.889
browse around inside the developer tool documentation.

01:09:01.890 --> 01:09:03.640
There's a gold mine of information there.
WEBVTT

00:00:23.829 --> 00:00:30.820
>> So, my name is Malcolm Crawford, Technical
Writer at, with Rent-a Mob, apparently...

00:00:30.820 --> 00:00:39.829
Technical writer at Apple, welcome then to this afternoons
session, getting started with Cocoa bindings.

00:00:39.829 --> 00:00:44.420
What's the intention for this session?

00:00:44.420 --> 00:00:52.740
First of all, it is very much a getting started session,
so in previous years, we've got into rather more detail

00:00:52.740 --> 00:00:55.520
than we're going to go into in this session.

00:00:55.520 --> 00:01:01.250
The presentation's going to be broken
up broadly into two sections.

00:01:01.250 --> 00:01:07.859
First of all addressing these goals; to answer the
questions, first of all, what is Cocoa Bindings?

00:01:07.859 --> 00:01:09.640
What's the problem that it solves?

00:01:09.640 --> 00:01:12.810
Why would you be interested in using
Cocoa bindings in your application?

00:01:12.810 --> 00:01:15.650
What benefits will you accrue and so on?

00:01:15.650 --> 00:01:20.390
And then the rather trivial question
right to the end, what is a binding?

00:01:20.390 --> 00:01:27.090
And the goal, really, in the first half then, is to provide
you with an understanding of how bindings actually works

00:01:27.090 --> 00:01:29.909
and in particular then, to prove that its not magic.

00:01:29.909 --> 00:01:31.340
There's no magic involved in this.

00:01:31.340 --> 00:01:36.990
You can write the code that's required
yourselves to establish bindings and so on.

00:01:36.989 --> 00:01:39.989
That's part of, part of what we'll see.

00:01:39.989 --> 00:01:49.119
Part of the goal is to then show you the simple rules
and technologies that underlie how bindings work.

00:01:49.120 --> 00:01:54.079
To many people, bindings sometimes appear very
opaque, very complicated, that's typically as a result

00:01:54.079 --> 00:02:01.069
of what you might view as being emergent behavior,
as a result of the combination of very simple rules.

00:02:01.069 --> 00:02:02.979
So, understanding the simple rules and behaviors

00:02:02.980 --> 00:02:07.450
that underlie Cocoa bindings will help you
diagnose any problems that you might have.

00:02:07.450 --> 00:02:10.569
So that's the majority of the presentation.

00:02:10.569 --> 00:02:15.629
During the second half of the presentation, or second
quarter or so of the presentation, we'll look at

00:02:15.629 --> 00:02:19.340
some of the difficulties that people
sometimes encounter and some thoughts

00:02:19.340 --> 00:02:22.780
as to how you might approach learning bindings and so on.

00:02:22.780 --> 00:02:25.490
So learning from those who have gone before you.

00:02:25.490 --> 00:02:26.370
What else will you learn?

00:02:26.370 --> 00:02:31.349
Primarily during the first three quarters or so, first of
all then, what are the technologies that underlie bindings?

00:02:31.349 --> 00:02:36.569
What is it that you have to understand in order
to figure out how bindings works and so on.

00:02:36.569 --> 00:02:41.629
We'll look at, how do you actually establish bindings, both
in an interface builder and very importantly, in codes.

00:02:41.629 --> 00:02:45.629
This goes very much towards the let's
prove that bindings aren't magic.

00:02:45.629 --> 00:02:48.639
You can write the line of code yourself that's required.

00:02:48.639 --> 00:02:52.859
We'll also then look at what's the role of an
NS controller object?

00:02:52.860 --> 00:02:56.730
What are, for those of you who've looked at any of the
bindings related materials in the interface builder,

00:02:56.729 --> 00:03:01.590
what are those green cubes or green spheres
that appear with an interface builder?

00:03:01.590 --> 00:03:09.330
So, let's actually get on, straight away,
with answering the basic questions.

00:03:09.330 --> 00:03:12.600
First of all, while you are here,
what is, what is Cocoa bindings?

00:03:12.599 --> 00:03:15.150
Let's address that straight off.

00:03:15.150 --> 00:03:19.200
It can be addressed in very, with a very simple answer.

00:03:19.199 --> 00:03:23.959
A collection of technologies for
keeping models and views synchronized.

00:03:25.009 --> 00:03:28.099
That encompasses the whole of what bindings are about.

00:03:28.099 --> 00:03:32.909
There's really not very much to it in terms of concept.

00:03:32.909 --> 00:03:35.219
Why might this be of interest to you?

00:03:35.219 --> 00:03:41.259
Well the way that bindings approaches
the problem typically means

00:03:41.259 --> 00:03:48.039
that you write less code yourself, a whole lot of code we'll
see, disappears when you use bindings and typically, also,

00:03:48.039 --> 00:03:52.590
bindings means that you end up with a more polished,
more refined user interface that takes care of some

00:03:52.590 --> 00:03:59.860
of the edge cases that you don't necessarily have time to
deal with, at least in version one of your application.

00:03:59.860 --> 00:04:04.230
So, bindings is a collection of technologies
for keeping models and views synchronized.

00:04:04.229 --> 00:04:06.979
What's a problem they solve?

00:04:06.979 --> 00:04:11.009
Well, from a rather more abstract
perspective, for those of you in particularly

00:04:11.009 --> 00:04:13.009
who managed to do the headstart.

00:04:13.009 --> 00:04:17.110
Can I just see actually, who managed
to go through the headstart sample?

00:04:17.110 --> 00:04:24.730
Anybody? A few, okay, so I'll have to do a quick
recap then of exactly what the headstart sample did.

00:04:24.730 --> 00:04:26.970
So I might go into a little bit more detail.

00:04:26.970 --> 00:04:33.150
Bindings give you an abstraction or refractoring of some
of the typical sorts of problems that you have to solve

00:04:33.149 --> 00:04:37.719
within your own application or just about
every application that you have to write.

00:04:37.720 --> 00:04:42.930
And that was illustrated then in the head
start sample, so actually go through that now.

00:04:42.930 --> 00:04:48.800
The headstart sample basically took a very simple
application, not as simple as the one we're going

00:04:48.800 --> 00:04:54.199
to consider in a moment, but still, fairly simple
application that had a table view that displayed a number

00:04:54.199 --> 00:05:03.829
of URLs, allowed you to add a URL to the table
view, inspect the detail of a particular URL

00:05:03.829 --> 00:05:08.579
so it had the URL, creation date,
and title associated with it.

00:05:08.579 --> 00:05:14.479
That was the user interface. To make sure everything
worked correctly, it was a document based application

00:05:14.480 --> 00:05:17.689
so it was a custom, sub-clause of
NS document, that first of all,

00:05:17.689 --> 00:05:21.439
had a whole lot of outlets pointing
out into the user interface.

00:05:21.439 --> 00:05:24.790
I'm trusting then, that everybody's
aware of what IB outlets are.

00:05:24.790 --> 00:05:27.650
Anybody not know what IB outlets are?

00:05:27.649 --> 00:05:32.579
Okay. So I'm afraid you're going to
get a little bit lost for two of you.

00:05:32.579 --> 00:05:35.919
But, bear with me, hopefully it
will make sense as we go along.

00:05:35.920 --> 00:05:39.819
So this is going to be a very, this is going to be
definitely a crash course to Cocoa for you then.

00:05:39.819 --> 00:05:44.819
So, outlets, as people typically familiar within any Cocoa
application for reaching out into the user interface,

00:05:44.819 --> 00:05:51.319
and it manages then, an array of bookmark objects.

00:05:51.319 --> 00:05:58.639
So in the sample application, well you didn't actually
write loads of code here, I wrote some code and you got

00:05:58.639 --> 00:06:03.829
to see the code at least, for doing fairly menial tasks.

00:06:03.829 --> 00:06:11.479
Moving data from the user interface down into the
bookmark objects, as a user entered data, added bookmarks.

00:06:11.480 --> 00:06:14.310
Managing selection handling, so if
they use a selected a new bookmark,

00:06:14.310 --> 00:06:17.689
make sure that that was displayed
in the underlying detail field.

00:06:17.689 --> 00:06:22.769
And then the application also supported drag and
drop, and it might, if I had actually been bothered,

00:06:22.769 --> 00:06:26.990
have also supported sorting and filtering.

00:06:26.990 --> 00:06:31.579
So, although this revolved around a table view,

00:06:31.579 --> 00:06:37.529
really is a sort of recurring theme throughout
almost any application that you write.

00:06:37.529 --> 00:06:42.819
You have data in your use interface, you have underlying
model objects and you've got a shuffle information

00:06:42.819 --> 00:06:48.240
between the two as a user edit data or maybe
something else, change let's say an AppleScript

00:06:48.240 --> 00:06:49.620
to whatever, changes the data underneath.

00:06:49.620 --> 00:06:52.939
That means to reflect it in your user interface.

00:06:52.939 --> 00:06:56.069
And anybody here actually enjoy writing that code?

00:06:56.069 --> 00:07:02.420
Oh, one, two people, two, two masochists
in the audience, then excellent.

00:07:02.420 --> 00:07:07.699
You can ask them later to do that
for you, for a fee doubtless.

00:07:07.699 --> 00:07:11.329
It's typically some of the most
uninteresting code that you have to write.

00:07:11.329 --> 00:07:13.789
It's fiddly and error-prone.

00:07:13.790 --> 00:07:17.640
How many people have had the situation where
there's that one text field at the edge

00:07:17.639 --> 00:07:20.750
of the window that actually didn't update properly?

00:07:20.750 --> 00:07:23.819
I'm sure, or is it just, okay, it's just me.

00:07:23.819 --> 00:07:26.300
Typically, you have to remember, okay, what
are all the different outlets that I've got,

00:07:26.300 --> 00:07:33.050
make sure everything is updated appropriately and
it's an ideal candidate basically, for abstraction

00:07:33.050 --> 00:07:39.900
and refactoring make somebody else do
all the work for you, ideally, the Cocoa Team.

00:07:39.899 --> 00:07:45.669
So, if we're going to give this task
to somebody else to perform for us,

00:07:45.670 --> 00:07:48.600
what are the things that we got to be able to do?

00:07:48.600 --> 00:07:52.420
We've got to be able to tell whoever's
taking care of all this gnarly mess for us,

00:07:52.420 --> 00:07:55.449
first of all, what should be kept in sync with what.

00:07:55.449 --> 00:08:01.579
We've obviously need a means to specifying that, we've
also got to be able to provide a way of shuffling the data

00:08:01.579 --> 00:08:05.189
around both from the view down to the
model and from the model out to the view.

00:08:05.189 --> 00:08:11.310
And we've got to be able to do things like keep track
of the current selection, so if we're dealing with more

00:08:11.310 --> 00:08:15.850
than one object, if we're dealing with a collection of
objects, whether it's an array, a tree of objects, whatever,

00:08:15.850 --> 00:08:18.810
we want to be able to make sure that
we know what's currently selected

00:08:18.810 --> 00:08:21.910
so it can update any detail views and so on.

00:08:21.910 --> 00:08:28.790
And, we've got to do all of this without
require you to adopt a particular root class.

00:08:28.790 --> 00:08:32.800
We want to make sure that this works
with any class you throw at us.

00:08:32.799 --> 00:08:36.990
So, that's a fairly steep collection of requirements.

00:08:36.990 --> 00:08:38.960
We'll come back to those later.

00:08:38.960 --> 00:08:43.519
For now though, what's the final, what's the
answer to the final question, what is a binding?

00:08:43.519 --> 00:08:49.620
So, if you'll forgive me just reading this one, a binding
is a specification that an attribute of one object is

00:08:49.620 --> 00:08:54.460
to be kept synchronized with a
property of another, with options.

00:08:54.460 --> 00:08:59.269
Hooray, good, right.

00:08:59.269 --> 00:09:03.389
Let's actually try to understand what that really meant,

00:09:03.389 --> 00:09:08.240
with a more simple example then,
than the bookmarks examples.

00:09:08.240 --> 00:09:13.740
So, rather than looking at, its, although the
bookmarks example is not particularly complicated,

00:09:13.740 --> 00:09:18.690
but we can make it simpler still and
still address the fundamental issues,

00:09:18.690 --> 00:09:22.660
the fundamental ideas, that you need to understand bindings.

00:09:22.659 --> 00:09:24.569
So, its actually incredibly difficult to come

00:09:24.570 --> 00:09:28.930
up with a convincing real world scenario
for an example that's this simple.

00:09:28.929 --> 00:09:36.569
But, imagine you're sitting down to write a
write, to write a mixing desk ap, desk application

00:09:36.570 --> 00:09:44.860
and you have track objects that know what
their volume is and the title of the track.

00:09:44.860 --> 00:09:49.629
And you're just setting down to prototype this
so you have your model object and all you have

00:09:49.629 --> 00:09:55.159
on your display is a single window
that has a text field and a slider

00:09:55.159 --> 00:09:59.129
and for the sake of it, we'll have a mute button on it.

00:09:59.129 --> 00:10:02.250
I hope everybody's convinced by this.

00:10:02.250 --> 00:10:07.860
To make it simpler still though,
let's forget about the title,

00:10:07.860 --> 00:10:12.680
so all we're dealing with is a single window
with a button slider and a text field.

00:10:12.679 --> 00:10:20.549
When the user enters a new value into the text field, it
sends the control object, the my document, beg your pardon,

00:10:20.549 --> 00:10:27.370
the document then has outlets reaching out into the user
interface, so its knows about the text field and the slider.

00:10:27.370 --> 00:10:39.730
When those are activated by the user, they send a message
to the controller objects to update the appropriate volume.

00:10:39.730 --> 00:10:46.060
The mute button, then, sets the
volume to zero and the document knows

00:10:46.059 --> 00:10:49.159
about the single track object that its managing.

00:10:49.159 --> 00:10:52.439
So, that's a very simple application that
we're going to consider during the hands

00:10:52.440 --> 00:10:56.010
on session, see how, may that work with bindings.

00:10:56.009 --> 00:11:03.360
Before we go on though, one of the criteria that we had
for a collection of, for our abstraction refactoring,

00:11:03.360 --> 00:11:08.840
was that we're going to require this to work with any class.

00:11:08.840 --> 00:11:13.990
So, let's consider that in the context
of our very simple application.

00:11:13.990 --> 00:11:20.639
Typically, in a custom class, we have custom accessor
methods for the various properties of those classes.

00:11:20.639 --> 00:11:28.740
So the properties, for example, are not going to include
the IB actions so just the actual instance variables

00:11:28.740 --> 00:11:34.180
of the relevant classes, typically don't have accessor
methods for the IB outlets, so you may imagine then,

00:11:34.179 --> 00:11:39.099
that the document class has an accessor method
for track to get and set the track value.

00:11:39.100 --> 00:11:44.050
The track itself then has accessor methods
to get and set its volume and so on.

00:11:44.049 --> 00:11:51.329
But, if we're trying to generate a reusable technology,
then making use of these custom accessor methods is going

00:11:51.330 --> 00:11:56.170
to make the technology not reusable,
we wouldn't be able to reuse any

00:11:56.169 --> 00:12:00.519
of the abstraction if we used custom accessor methods.

00:12:00.519 --> 00:12:06.399
So instead, we're introducing this
idea of keys and key paths.

00:12:06.399 --> 00:12:10.730
Keys are simply strings that specify properties.

00:12:10.730 --> 00:12:14.450
Can I just see, who's come across this,
who has, I should ask the negative.

00:12:14.450 --> 00:12:19.590
Who has not come across the idea of key, of key
value, key value coding, that sort of thing before?

00:12:19.590 --> 00:12:21.920
Who's not come across that?

00:12:21.919 --> 00:12:24.019
Oh, okay, so I can just pretty much skip the rest of this.

00:12:24.019 --> 00:12:30.449
People are aware that volume, as a
string, is a key for the volume attributes

00:12:30.450 --> 00:12:32.530
and then who's come across the idea of key paths?

00:12:32.529 --> 00:12:37.819
So its volume, does track dot volume
means something to everybody?

00:12:37.820 --> 00:12:41.310
Who has not come across that concept before?

00:12:41.309 --> 00:12:45.709
Okay, for those of you who have not come across that
earlier, the idea of a key path is it allows you

00:12:45.710 --> 00:12:50.400
to traverse relationships between objects.

00:12:50.399 --> 00:12:58.399
So a document instance has an instance variable track,
the track itself has an instance variable volume.

00:12:58.399 --> 00:13:07.569
So for a given document, we can access the volume
of its track using the key path track dot volume.

00:13:07.570 --> 00:13:17.870
So a key path is simply a concatenation of
keys where the relationships limited by dots,

00:13:17.870 --> 00:13:22.470
by force dots or periods, depending on your locale.

00:13:22.470 --> 00:13:27.470
Okay, so with that in mind then, what do we
have to do if we want to set up bindings,

00:13:27.470 --> 00:13:30.310
given what our specifications of bindings it was?

00:13:30.309 --> 00:13:32.329
Its actually two parts that I want to go through.

00:13:32.330 --> 00:13:34.379
First of all, how do you set up bindings?

00:13:34.379 --> 00:13:39.210
And then, what are, what are the
technologies that lie behind bindings?

00:13:39.210 --> 00:13:48.850
So, in part, with the set up technologies, first of all,
is key value binding, we'll come back to that in terms

00:13:48.850 --> 00:13:51.990
of the definition of what is a binding in a moment.

00:13:51.990 --> 00:13:58.330
Then as part of the binding process you set
up observation using key value observing.

00:13:58.330 --> 00:14:00.900
And then there are these controller things.

00:14:00.899 --> 00:14:03.919
So let's address the controller things first.

00:14:03.919 --> 00:14:09.399
The controller things are set up to abstract
the function of managing either a single object

00:14:09.399 --> 00:14:12.639
or in many cases, a collection of objects.

00:14:12.639 --> 00:14:14.789
So there's a number of different controller objects.

00:14:14.789 --> 00:14:18.789
First of all one for a single object, NS object controller.

00:14:18.789 --> 00:14:25.909
And then there are a variety of other ones for managing
either a dictionary, new in Leopard, an array or a tree.

00:14:25.909 --> 00:14:31.459
And there's a couple of controller
objects for managing user defaults.

00:14:31.460 --> 00:14:36.970
The main one that we're gonna consider during the hands
on session just is the single NS object controller.

00:14:36.970 --> 00:14:40.149
So we've got this, all these object
controllers and what do they actually do?

00:14:40.149 --> 00:14:44.620
The main thing that they do is manage their content.

00:14:44.620 --> 00:14:51.129
You pass over to them responsibility for managing the object
they have, or objects that they have as their content.

00:14:51.129 --> 00:14:52.570
That may be a little bit subtle.

00:14:52.570 --> 00:14:56.510
That's something else we'll come
back to in a couple of slides' time.

00:14:56.509 --> 00:15:01.939
If you have a collection of objects, if they
manage a collection, one of the great things

00:15:01.940 --> 00:15:07.280
that the object controllers do for
you is manage the current selection.

00:15:07.279 --> 00:15:09.629
That'll be more obvious in the headstart example.

00:15:09.629 --> 00:15:11.429
We're gonna come back to that at the end.

00:15:11.429 --> 00:15:16.149
They also provide a fair amount of other
functionality like supporting filtering and sorting.

00:15:16.149 --> 00:15:23.379
And if you want to allow deferred... partial
editing of values within your user interface,

00:15:23.379 --> 00:15:28.279
they'll allow you to monitor more, more
readily when something is being edited.

00:15:28.279 --> 00:15:34.529
So you can for example make sure that you don't allow a
user to close a window before our change has been committed.

00:15:34.529 --> 00:15:39.110
So those are sort of benefits that a controller gives you.

00:15:39.110 --> 00:15:43.389
Where would a controller fit into a very simple application?

00:15:43.389 --> 00:15:48.870
Well, basically right in the middle
between user interface and the document.

00:15:48.870 --> 00:15:56.019
So again to interpose an instance of NS
object controller to manage the single track.

00:15:56.019 --> 00:15:59.110
Currently the track is managed by the document instance.

00:15:59.110 --> 00:16:06.539
But we can tell the object controller, you
should get your track from the document.

00:16:06.539 --> 00:16:08.339
That's an important thing.

00:16:08.340 --> 00:16:11.160
Again we're going to come back to
that in a couple of slides time.

00:16:11.159 --> 00:16:15.620
So if that's the controller part of the setting up bindings,

00:16:15.620 --> 00:16:20.639
another part of the set up was
the key value binding protocol.

00:16:20.639 --> 00:16:23.309
There are a number of methods in
the key value binding protocol.

00:16:23.309 --> 00:16:26.069
The only one that we're interested in at the moment as part

00:16:26.070 --> 00:16:31.350
of the getting started theme is the method
that's used to actually establish the bindings.

00:16:31.350 --> 00:16:38.740
So the methods that's for that, that's used for
that is bind to object with key path options.

00:16:38.740 --> 00:16:42.460
What does that method do?

00:16:42.460 --> 00:16:47.990
Well, fundamentally you could state that as being
a specification that an attribute of one object is

00:16:47.990 --> 00:16:51.680
to be kept synchronized with the
property of another with options.

00:16:51.679 --> 00:16:55.489
So remember the answer to question three, what is a binding.

00:16:55.490 --> 00:17:00.389
In some respects, that method is a
concrete manifestation of what is a binding.

00:17:00.389 --> 00:17:03.029
It's what you set up using that method.

00:17:03.029 --> 00:17:08.680
One of the things I'd like to sort of,
sort of get you to think of here is

00:17:08.680 --> 00:17:12.080
that a binding is established rather than created.

00:17:12.079 --> 00:17:20.119
If you think about the way that you set up target action in
Interface Builder when you control drag from say a button

00:17:20.119 --> 00:17:25.679
down to an object that influences
an instance, an action method.

00:17:25.680 --> 00:17:30.690
When you make that connection, you're
actually setting two instance variables.

00:17:30.690 --> 00:17:34.110
The target and the action.

00:17:34.109 --> 00:17:40.329
In a similar way, when you start out
binding, you're not actually creating a binding,

00:17:40.329 --> 00:17:45.980
you're filling in information to say what
should be kept synchronized with what.

00:17:45.980 --> 00:17:52.910
So if we set up the bindings for our very simple
application, we know have our object controller

00:17:52.910 --> 00:17:57.490
into between our interface and the underlying document.

00:17:57.490 --> 00:18:08.289
And we want to specify, we want to bind the content
object of the controller with the document track.

00:18:08.289 --> 00:18:15.089
The important thing here and the reason for not
binding directly to the track in the section is

00:18:15.089 --> 00:18:26.119
that if the track changes, then if the user interface
elements are bound to the controller as the intermediary,

00:18:26.119 --> 00:18:35.089
if the track changes, then the user interface elements
start following as it were the new track rather

00:18:35.089 --> 00:18:37.929
than continue to be bound to the old track.

00:18:37.930 --> 00:18:40.779
So this is another reason why we have the
object controller sitting there in the middle.

00:18:40.779 --> 00:18:45.339
If the track changes, we want to keep the user
interface synchronized now with the new track.

00:18:45.339 --> 00:18:50.539
So for both the text field and then the slider,

00:18:50.539 --> 00:18:57.440
we want to make sure that their values are kept
synchronized with the controllers selections value.

00:18:57.440 --> 00:19:03.289
So what is the content object or in the, the case
of an object controller is just a single selection.

00:19:03.289 --> 00:19:07.899
But if you had an array or a tree controller, you may
have multiple objects of which just one is selected.

00:19:07.900 --> 00:19:11.400
So the selection of that object controller.

00:19:11.400 --> 00:19:17.300
So that's setting up bindings.

00:19:17.299 --> 00:19:20.700
But there's another part to setting up bindings.

00:19:20.700 --> 00:19:24.019
This comes of the key value observing heading.

00:19:24.019 --> 00:19:34.400
Key value observing, the set up is the
first step in the notification process.

00:19:34.400 --> 00:19:40.150
Key value observing allows an object to tell other
objects that one of its properties has changed.

00:19:40.150 --> 00:19:42.100
In order for it to tell those other objects,

00:19:42.099 --> 00:19:46.230
those other objects have gotta tell it
that they're interested in that change.

00:19:46.230 --> 00:19:50.870
So registering that interest is
performed in the registration side

00:19:50.869 --> 00:19:57.829
of KVO using the add observer for
key path options context method.

00:19:57.829 --> 00:19:59.419
I'm not gonna say anything more about that now

00:19:59.420 --> 00:20:03.100
It turns out we actually don't need to know
anything more about that at this stage.

00:20:03.099 --> 00:20:07.089
It's just the first step in a change notification mechanism.

00:20:07.089 --> 00:20:12.369
So in the registration side of things, just in the same
that we're setting up bindings, in fact at the same time

00:20:12.369 --> 00:20:19.859
that we're setting up bindings, the object controller
registers as being an observer of the documents track,

00:20:19.859 --> 00:20:29.909
the text field registers an observer of the object
controllers selections volume as does the slider.

00:20:29.910 --> 00:20:36.430
So with that, I'd like to go to the hands on stage.

00:20:36.430 --> 00:20:44.890
So I'm hoping that those who want to follow along
have had an opportunity now to download the example.

00:20:44.890 --> 00:20:52.509
Still getting a 404 error.

00:20:52.509 --> 00:21:09.359
( Inaudible audience comment. )

00:21:09.359 --> 00:21:14.029
Okay for those of you who did not
hear that, apparently if you Google

00:21:14.029 --> 00:21:21.549
for simple bindings adoption, you
will get that as the first result.

00:21:21.549 --> 00:21:23.419
Thank you for the gentlemen in the Google T-shirt.

00:21:23.420 --> 00:21:25.029
( Laughter )

00:21:25.029 --> 00:21:28.099
I'm not joking, he is.

00:21:28.099 --> 00:21:34.509
I hope that at least you'll be able to follow, there
are two parts then to the demo, to the hands on session.

00:21:34.509 --> 00:21:37.900
First of all establishing bindings
programmatically and then in Interface Builder.

00:21:37.900 --> 00:21:42.910
So if you haven't managed to download the application yet,
perhaps you could just wait for the download to happen.

00:21:42.910 --> 00:21:50.920
Follow along with the code section of it, then the
much more exciting is the doing stuff in IB anyway.

00:21:50.920 --> 00:21:53.769
So the application is very simple.

00:21:53.769 --> 00:21:57.029
If I just build and run it straight
off, and then hide, opps.

00:21:57.029 --> 00:22:00.529
Hide Xcode.

00:22:00.529 --> 00:22:05.670
This has got a trivial user interface.

00:22:05.670 --> 00:22:08.539
What I'd just like to draw your
attention to straight off though,

00:22:08.539 --> 00:22:12.349
note that the user interface is as
it were uninitialized at this stage.

00:22:12.349 --> 00:22:15.609
So when the thing launches, we've been a little
bit lazy, well I think a little bit lazy.

00:22:15.609 --> 00:22:20.799
It doesn't show the current volume
and the slide is at its default value.

00:22:20.799 --> 00:22:28.460
However, if I press the mute button, the volume goes
down to zero and I can type in a new value and it goes,

00:22:28.460 --> 00:22:33.269
the user interface is updated appropriately,
the slider of course for volume goes up to 11.

00:22:33.269 --> 00:22:36.819
A good quarter of you got that, excellent.

00:22:36.819 --> 00:22:38.089
( Laughter )

00:22:38.089 --> 00:22:40.359
So very simple application.

00:22:40.359 --> 00:22:44.919
Not an awful lot of code behind it.

00:22:44.920 --> 00:22:49.890
The ironically the track object on model
object is probably the least interesting part

00:22:49.890 --> 00:22:51.530
of this, for this particular demonstration.

00:22:51.529 --> 00:22:55.430
So you got a simple track object that
has, that it has a volume and a type

00:22:55.430 --> 00:22:58.230
as I already described with suitable
access methods implemented.

00:22:58.230 --> 00:23:02.279
That's all I'm going to say about that at this stage though.

00:23:02.279 --> 00:23:06.299
The document class though is a little
bit more interesting in this context.

00:23:06.299 --> 00:23:13.319
It has as I showed in the slides earlier, outlets
to the slider into the text field and one thing

00:23:13.319 --> 00:23:21.960
that wasn't apparent in the original block
diagram was method update user interface.

00:23:21.960 --> 00:23:33.809
That is invoked both by the update volume
from method and by the mute track method.

00:23:33.809 --> 00:23:38.649
So in response to any user interaction that
changes the tracks volume, we must go out

00:23:38.650 --> 00:23:41.390
and update the user interface accordingly.

00:23:41.390 --> 00:23:44.620
Well, that's exactly what we don't want to do.

00:23:44.619 --> 00:23:48.259
We don't want to have to write the code and
maintain the code for doing that ourselves.

00:23:48.259 --> 00:23:53.430
So let's throw caution to the wind and assume that as part

00:23:53.430 --> 00:23:57.769
of our new bindings based implementation
we're not going to need that method.

00:23:57.769 --> 00:23:59.329
So let's delete that.

00:23:59.329 --> 00:24:02.099
That's always a good start of a code demo, delete stuff.

00:24:02.099 --> 00:24:14.629
So given that we're deleting that method, let's delete it
from both the mute track and from the update volume from.

00:24:14.630 --> 00:24:19.990
So hope since I'm deleting stuff here, people
can keep up with that part of it at least.

00:24:19.990 --> 00:24:25.579
Save and let's just delete that
method from the header file as well.

00:24:28.319 --> 00:24:33.329
What I do need to do though, what we need to
do though is make, set up the bindings now.

00:24:33.329 --> 00:24:39.129
And create any of the associated objects
that, that I need to support the bindings.

00:24:39.130 --> 00:24:44.770
So the first thing that we said we wanted
to do was to create a new object controller.

00:24:44.769 --> 00:24:47.849
So we want to do this early on in
the lifetime of the application,

00:24:47.849 --> 00:24:51.189
before the whole lot of user interfaces have been populated.

00:24:51.190 --> 00:24:56.940
So the document architecture gives us a convenient
method for doing this, window controller load nib.

00:24:56.940 --> 00:25:03.650
For those of you who haven't used document
architecture before, this is akin to awake from nib.

00:25:03.650 --> 00:25:08.860
For those of you who haven't heard of awake from
nib before, it does pretty much what it says.

00:25:08.859 --> 00:25:17.359
So within this method, we want to
create a new object controller.

00:25:17.359 --> 00:25:22.669
So this is code that you now have to
type in if you're following along.

00:25:22.670 --> 00:25:25.440
Sorry, there is gonna be some code.

00:25:25.440 --> 00:25:29.840
Remember we're doing this in two stage,
code based and then Interface Builder based.

00:25:29.839 --> 00:25:39.509
Do remember the what is it, control,
control full stop auto complete for Xcode?

00:25:39.509 --> 00:25:44.890
So create a new instance of object controller.

00:25:46.509 --> 00:25:59.609
( Period of silence )

00:25:59.609 --> 00:26:06.899
Then given this new instance of object controller, we
want to tell it where it's going to get its data from.

00:26:06.900 --> 00:26:08.960
What's its content object?

00:26:08.960 --> 00:26:17.850
So we bind its content using the key value
binding, binding establishing method.

00:26:17.849 --> 00:26:25.359
So we tell a controller to bind its content object,
so be careful with the capitalization there.

00:26:25.359 --> 00:26:27.919
The O is capitalized.

00:26:27.920 --> 00:26:30.860
To object self.

00:26:30.859 --> 00:26:36.079
Remember we're editing at the moment
the code for the my document instance.

00:26:36.079 --> 00:26:39.399
This is my document class that has the track object.

00:26:39.400 --> 00:26:44.580
So it's my track object with key path track.

00:26:44.579 --> 00:26:49.789
Put that under a separate line so it, so it's more obvious.

00:26:49.789 --> 00:26:52.700
So the controllers objects contents is gonna be my track

00:26:52.700 --> 00:26:58.299
and to save writing additional lines
of code at this stage, no options.

00:26:58.299 --> 00:27:02.990
So that set up the content for the controller object.

00:27:02.990 --> 00:27:07.420
We now want to make sure that the text field
and the slider are set up appropriately.

00:27:07.420 --> 00:27:21.050
So we pretty much replicate that code for first of all
the text field, except we bind the text fields value,

00:27:21.049 --> 00:27:26.899
so whatever it is that it's displayed
in the text field to the controller

00:27:26.900 --> 00:27:31.730
that we just created with a key path selection dot volume.

00:27:31.730 --> 00:27:34.150
So whatever the current selection in the object controller

00:27:34.150 --> 00:27:38.680
and because the object controller only has a
single object, it's always the single track.

00:27:38.680 --> 00:27:41.320
Whatever its volume is.

00:27:41.319 --> 00:27:49.329
And then the easiest thing to do is actually just copy
and paste but, we also then want to bind the slider.

00:27:49.329 --> 00:28:04.509
So either you can drag it in from your helpful assistant,
or easier for you copy and paste and type in slider.

00:28:04.509 --> 00:28:08.329
( Period of silence )

00:28:08.329 --> 00:28:14.509
So four lines of code basically and there I hope everybody's
kept up with that who wants to keep up with that.

00:28:14.509 --> 00:28:19.230
Not really very much, I hope that's
not very complicated code either.

00:28:19.230 --> 00:28:21.329
If we build this and run.

00:28:25.630 --> 00:28:29.880
Low and behold our user interface is set up appropriately.

00:28:29.880 --> 00:28:36.990
Note that the volume is now set appropriately as well.

00:28:36.990 --> 00:28:40.490
If I change the slider, the volume updates appropriately.

00:28:40.490 --> 00:28:42.930
If I type in a new value, the slider updates.

00:28:42.930 --> 00:28:46.380
If I hit mute, the volume goes down to zero.

00:28:46.380 --> 00:28:52.150
So for those of you who managed to
follow along, congratulations, you,

00:28:52.150 --> 00:28:57.509
for those of you for who this is the first time, you
now have created your first bindings based application.

00:28:57.509 --> 00:28:58.879
And you did it the hard way.

00:28:58.880 --> 00:29:00.790
So congratulations.

00:29:03.880 --> 00:29:06.250
Now let's do it the easy way.

00:29:06.250 --> 00:29:16.619
So I'm hoping then that those of you who had to Google for
the source code have now managed to at least download it

00:29:16.619 --> 00:29:24.139
and we get on to the second part of the example, we can
just do, do exactly the same as this in Interface Builder.

00:29:24.140 --> 00:29:31.600
So the useful part here is that in addition to the
other methods that we just had, that we just deleted,

00:29:31.599 --> 00:29:40.209
we can actually now delete that method that we just wrote.

00:29:40.210 --> 00:29:41.980
So sorry if that appeared like a waste of time,

00:29:41.980 --> 00:29:46.970
but we'll come back to see why that
wasn't a waste of time in a moment.

00:29:46.970 --> 00:29:52.410
So now let's establish those bindings in Interface Builder.

00:29:52.410 --> 00:30:00.830
So open then the my document class, I beg
your pardon, the my document nib file.

00:30:00.829 --> 00:30:08.319
The first thing to do is to add an object controller.

00:30:08.319 --> 00:30:11.569
So who is not running Leopard?

00:30:11.569 --> 00:30:13.189
Anybody not running Leopard?

00:30:13.190 --> 00:30:20.590
So for those of you who are not running Leopard, you
should see in your Interface Builder palette an icon

00:30:21.950 --> 00:30:30.830
that looks pretty much like this
under the controllers button.

00:30:30.829 --> 00:30:36.859
Drag in a new instance of NS object
controller into the nib file.

00:30:36.859 --> 00:30:42.399
So that's the object controller that we created.

00:30:42.400 --> 00:30:48.080
We now want to tell it where it's going to
get its information from, what's its content.

00:30:48.079 --> 00:30:52.259
So the easiest way to do that in
both in Tiger and on Leopard is just

00:30:52.259 --> 00:30:57.680
to press command 4 to bring up the bindings inspector.

00:30:57.680 --> 00:31:05.000
We need to tell it where to get its content object from.

00:31:08.880 --> 00:31:13.910
So its content object is going
to come from the files owners.

00:31:13.910 --> 00:31:16.820
So the instance is my document.

00:31:17.930 --> 00:31:21.039
Click the bind to button.

00:31:21.039 --> 00:31:33.789
And the model key path is going to
be let's say selection dot track.

00:31:35.450 --> 00:31:38.759
Press return.

00:31:38.759 --> 00:31:44.089
For those of you muttering, yes.

00:31:44.089 --> 00:31:56.209
Now we can set up the bindings for
the text field and for the slider.

00:31:56.210 --> 00:31:57.900
So select the text field and slider.

00:31:57.900 --> 00:32:00.700
Select the text field first.

00:32:00.700 --> 00:32:02.690
Look at its value binding.

00:32:02.690 --> 00:32:07.340
We want to bind it to the object controllers selection.

00:32:11.039 --> 00:32:17.180
Volume. Press return.

00:32:17.180 --> 00:32:24.330
And this same for the slider.

00:32:24.329 --> 00:32:36.139
So text field and slider both bound to the
object controllers selection dot volume.

00:32:36.140 --> 00:32:40.180
So if I save the nib file now.

00:32:40.180 --> 00:32:46.460
Go back to Xcode.

00:32:46.460 --> 00:32:49.069
Build and run.

00:32:52.309 --> 00:32:54.419
The window didn't appear.

00:32:54.420 --> 00:32:56.670
Hm. What happened?

00:32:56.670 --> 00:33:08.150
Well, despite the fact that we're using bindings,
let's try looking at the debugger console.

00:33:08.150 --> 00:33:13.810
It seems there's a lot of error messages.

00:33:14.890 --> 00:33:18.390
One of them, well they all basically say the same thing.

00:33:19.740 --> 00:33:26.059
A message was sent to an object that is not
KVC compliant for the selection property.

00:33:26.059 --> 00:33:30.279
And it was sent to an instance of my document.

00:33:30.279 --> 00:33:39.339
So it seems that somewhere along the line we've
tried to access the property selection of an instance

00:33:39.339 --> 00:33:42.980
of document, and documents don't have a selection.

00:33:42.980 --> 00:33:47.799
So a couple of you, it sounded like a couple
you had spotted the deliberate mistake.

00:33:51.069 --> 00:34:02.909
The object controllers key path didn't want to be
selection dot track, it just wanted to be track.

00:34:02.910 --> 00:34:05.640
The my document instance doesn't have an idea of selection.

00:34:05.640 --> 00:34:07.000
It's just managing its own tracks.

00:34:07.000 --> 00:34:10.510
If I change that,

00:34:10.510 --> 00:34:22.550
( Period of silence )

00:34:22.550 --> 00:34:26.680
The application now behaves correctly.

00:34:26.679 --> 00:34:32.069
So for those who managed to follow along in that
section, congratulations, you now also managed to go

00:34:32.070 --> 00:34:36.640
through your first bindings debugging session as well.

00:34:36.639 --> 00:34:43.309
I hope that everybody who wanted to go through that
managed to download the sample then and go through that.

00:34:43.309 --> 00:34:46.799
That's the end of the hands on session,
so or the hands on part of the session,

00:34:46.800 --> 00:34:51.550
so my apologies then to anybody
who is still left behind there

00:34:51.550 --> 00:35:02.240
So if we go back to slides and let's
just recap what we actually did in that.

00:35:02.239 --> 00:35:05.379
First of all, in setting up the bindings programmatically,

00:35:05.380 --> 00:35:10.269
one of the great things we did straight
off was remove a whole lot of code.

00:35:10.269 --> 00:35:13.679
So all of that gnarly code just for
getting stuff from the user interface

00:35:13.679 --> 00:35:16.869
and shuffling it around went away, which is good.

00:35:16.869 --> 00:35:22.559
Because we were establishing the bindings
programmatically first of all, we kept the IB outlets.

00:35:22.559 --> 00:35:24.429
Okay, fair enough.

00:35:24.429 --> 00:35:31.169
And then used the key value binding
method to set up the bindings.

00:35:31.170 --> 00:35:36.230
And as a side effect, remember what I said
about more user interface polish with less code,

00:35:36.230 --> 00:35:42.190
the user interface was properly initialized
when we, when the application was launched.

00:35:42.190 --> 00:35:49.119
Importantly also I mentioned that the model class ironically
in this case was the least interesting part of the example.

00:35:49.119 --> 00:35:50.880
We didn't touch that at all.

00:35:50.880 --> 00:35:55.660
That's something else to come back
to in a couple of slides time.

00:35:55.659 --> 00:36:00.909
For those of you who are concerned about the
object controller, we did alloc init auto release.

00:36:00.909 --> 00:36:07.719
In some respects, by rights it ought have disappeared
at the end of the window controller did load nib method.

00:36:07.719 --> 00:36:16.279
But actually an important thing to bear in mind is that
objects bind, sorry, retain objects to which they're bound.

00:36:16.280 --> 00:36:22.190
so given that we established a binding between
the, sorry between the text field and the slider

00:36:22.190 --> 00:36:27.970
and the object controller, they made sure that the object
controller didn't go away until they were finished with it.

00:36:27.969 --> 00:36:31.379
So there actually wasn't a memory
management issue there at all.

00:36:31.380 --> 00:36:40.320
In the second part of the demo, we removed
all the bindings establishing code, removed,

00:36:40.320 --> 00:36:43.309
well actually I didn't remove the outlets, should have done.

00:36:43.309 --> 00:36:45.880
And we didn't change the mute track method.

00:36:45.880 --> 00:36:48.990
That stayed exactly as it was.

00:36:48.989 --> 00:36:53.269
So basically the second part was just removing
code and setting things up in Interface Builder.

00:36:53.269 --> 00:36:56.670
It's important to bear in mind though, this is,

00:36:56.670 --> 00:37:04.250
this getting to the bindings isn't the magic
thing then, that those two parts were equivalent.

00:37:04.250 --> 00:37:06.769
Think about setting, establishing a binding.

00:37:06.769 --> 00:37:12.690
We had it in a, in one of the cases simply
a text field whose value needed to be bound

00:37:12.690 --> 00:37:17.490
to the selection dot volume of the object controller.

00:37:17.489 --> 00:37:21.409
You did this in two ways.

00:37:21.409 --> 00:37:25.969
In Interface Builder and in code.

00:37:25.969 --> 00:37:32.439
In Interface Builder the inspector looked
pretty much like how it does on the left.

00:37:32.440 --> 00:37:36.150
And code that you wrote was as it is on the right.

00:37:36.150 --> 00:37:42.690
One of the key things that I want you to take away from
this presentation is that these two are equivalent.

00:37:42.690 --> 00:37:45.440
These two are exactly the same thing.

00:37:45.440 --> 00:37:49.260
One is done in Interface Builder, the other is done in code.

00:37:49.260 --> 00:37:56.850
If we work our way down what the parts are of the Interface
Builder inspector, and the arguments are in the bind method,

00:37:56.849 --> 00:37:59.900
you can see exactly where the equivalences are.

00:37:59.900 --> 00:38:05.900
At the top of the bindings inspector for this
particular binding, we have the binding name.

00:38:05.900 --> 00:38:14.210
That's the first argument to the bind method, what
is it, what property is it that you want to bind?

00:38:14.210 --> 00:38:18.579
The second part of it is what's it going to be bound to?

00:38:18.579 --> 00:38:24.500
The object argument to the bind
method, we specify that in the pop up.

00:38:26.489 --> 00:38:32.629
The third part was well what's the key
path to the object to which we're bound?

00:38:33.760 --> 00:38:43.330
That's specified by this combination of controller key
and model key path in the Interface Builder inspector

00:38:43.329 --> 00:38:50.279
and by the single argument, the key
path argument in the bind method.

00:38:50.280 --> 00:38:59.290
And then finally the options simply a dictionary of any
other settings that you want for this particular binding.

00:38:59.289 --> 00:39:08.820
And it just so happens that in this case, nil is the
same as setting those defaults in Interface Builder.

00:39:08.820 --> 00:39:16.740
So key point here, this and this are the same.

00:39:16.739 --> 00:39:22.579
So for those of you who are confused by
this, I hope you're not confused by this.

00:39:22.579 --> 00:39:26.090
Anyone can write a line of code.

00:39:26.090 --> 00:39:29.820
So when you look at that and you're confused,
think well I could have written that.

00:39:29.820 --> 00:39:31.670
So it's easy.

00:39:31.670 --> 00:39:36.930
If you really want to go away and
write all your lines of code, all,

00:39:36.929 --> 00:39:40.759
establish all the bindings programmatically
rather than doing it in Interface Builder,

00:39:40.760 --> 00:39:48.880
remember those two gentlemen earlier who said
that they like doing that, so go and ask them.

00:39:48.880 --> 00:39:53.260
So that's the first half of setting up, of
looking at what bindings are and how they work.

00:39:53.260 --> 00:39:54.510
Actually setting up the bindings.

00:39:54.510 --> 00:39:56.130
Well, what's happening behind the scenes?

00:39:56.130 --> 00:39:58.500
What technologies do we have to understand?

00:39:58.500 --> 00:40:06.510
What technologies does Cocoa bindings
use to do its work for you?

00:40:06.510 --> 00:40:13.270
The first part, we actually got
a clue about in the error message

00:40:13.269 --> 00:40:17.070
that came back when we set up the binding incorrectly.

00:40:17.070 --> 00:40:21.320
Key value coding, actually whose
not, I think I asked before.

00:40:21.320 --> 00:40:23.350
Who's not heard of key value coding?

00:40:23.349 --> 00:40:30.690
Okay, so key value coding everybody familiar with, gives
you a means of managing and accessing an objects properties

00:40:30.690 --> 00:40:38.099
by key, by extension key paths allow you to
transverse relationships between objects.

00:40:38.099 --> 00:40:46.599
An important thing about key value coding as pertains to
Cocoa bindings though is that it's really sort of unicast.

00:40:46.599 --> 00:40:52.730
Key value coding is used to send, to update values

00:40:52.730 --> 00:40:58.519
from a single user interface element
to the property to which it's bound.

00:40:58.519 --> 00:41:02.159
So it's as it were one object at a time.

00:41:02.159 --> 00:41:05.219
Key value coding with paths, everybody, I'm guessing then

00:41:05.219 --> 00:41:07.859
that everybody is familiar with,
so don't need to say anything more.

00:41:07.860 --> 00:41:11.260
Or much more at least.

00:41:11.260 --> 00:41:19.020
Key value something, using key value coding allows
you traverse key paths to both get and set methods.

00:41:19.019 --> 00:41:22.119
So get and set value, get and set values.

00:41:22.119 --> 00:41:29.429
And key value coding continues to use
custom accessing methods if they exist.

00:41:29.429 --> 00:41:36.230
So it gives you a convenient way of
eliminating a fair amount of code.

00:41:36.230 --> 00:41:38.980
To reiterate a point that I made earlier.

00:41:38.980 --> 00:41:47.030
Key value coding then is used to propagate
changes from views to the controller

00:41:47.030 --> 00:41:49.910
or through the controller down to the model.

00:41:49.909 --> 00:42:00.179
So if the user changes a value either in slider or in a text
field, in these particular cases, the selection dot volume

00:42:00.179 --> 00:42:03.750
of the controller is changed using key value coding.

00:42:03.750 --> 00:42:09.949
The other side of this, we come back to key value observing.

00:42:09.949 --> 00:42:12.899
So remember when we were key value observing?

00:42:12.900 --> 00:42:19.019
We looked at the, key value observing
registration part in binding set up,

00:42:19.019 --> 00:42:27.019
the reason for setting up key value observing was so
that if a change was made to the value of a model object,

00:42:27.019 --> 00:42:30.179
that could be broadcast throughout,
through the whole application

00:42:30.179 --> 00:42:34.029
to any object that had registered interest in that.

00:42:34.030 --> 00:42:40.880
So we saw the registration part of it, key value
observing noted, change notification is passed

00:42:40.880 --> 00:42:48.829
out by using the observe value for key
path of object change context method.

00:42:48.829 --> 00:42:52.309
So any objects that are bound need
to implement this similar line

00:42:52.309 --> 00:42:56.210
to receive notification that an objects value has changed.

00:42:56.210 --> 00:42:59.670
This is sort of multicast because
there may be many observers.

00:42:59.670 --> 00:43:05.119
So in the case of our simple application,
we have a change of a value going

00:43:05.119 --> 00:43:07.529
from the model to the controller to the views.

00:43:07.530 --> 00:43:10.380
You have to watch this one carefully.

00:43:10.380 --> 00:43:14.240
So focus first of all on the mute button.

00:43:14.239 --> 00:43:24.719
If the user presses the mute button, the volume
on the of the current track is set to zero.

00:43:24.719 --> 00:43:34.689
That then results in an observe message being sent
to both of the objects that registered an interest

00:43:34.690 --> 00:43:42.200
in that value, namely this text field and the slider.

00:43:42.199 --> 00:43:44.079
How come all of this just worked though?

00:43:44.079 --> 00:43:46.179
Because we didn't actually change the track class.

00:43:46.179 --> 00:43:49.569
We didn't do anything special with the
text field or the slider or anything.

00:43:49.570 --> 00:43:56.760
We just used those in the bindings based
versions of the application without any changes.

00:43:56.760 --> 00:44:06.410
Well, it turns out that using the appropriately named
accessor methods, typically assures both KVC compliance

00:44:06.409 --> 00:44:10.549
as it sounds like most of you are
aware but also KVO compliance.

00:44:10.550 --> 00:44:15.350
So provided you use appropriately named
accessor method in your model classes,

00:44:15.349 --> 00:44:19.110
you will also get KVO compliance,
key value observance compliance.

00:44:19.110 --> 00:44:26.240
Your model objects will automatically send out the
appropriate KVO notifications if values change.

00:44:26.239 --> 00:44:33.659
So the Cocoa team has done some
additional work for you there as well.

00:44:33.659 --> 00:44:39.469
Let's summarize then what we've actually
learned during this first three quarters or so.

00:44:39.469 --> 00:44:48.179
First of all we said that Cocoa bindings
are a way to abstract and refactor some

00:44:48.179 --> 00:44:51.279
of the least interesting parts of your application.

00:44:51.280 --> 00:44:54.140
And we gave this set of requirements.

00:44:54.139 --> 00:44:58.359
We need first of all to specify what
should be kept in sync with what.

00:44:58.360 --> 00:44:59.510
And so on.

00:44:59.510 --> 00:45:05.610
And we also said that it's got to
be able to work with any class.

00:45:05.610 --> 00:45:08.170
Well, we've now gone through and
addressed all of these needs.

00:45:08.170 --> 00:45:13.690
To specify what should be kept in sync
with what, we have key value binding.

00:45:13.690 --> 00:45:19.420
To move data between the view and
the model, we have key value coding.

00:45:19.420 --> 00:45:23.900
To move information the other way,
we have key value observing.

00:45:23.900 --> 00:45:28.900
To keep track of the current selection and so
on, we have NS controller and its subclasses.

00:45:28.900 --> 00:45:34.119
So NS object controller we've looked at and
there are others which I'll turn to in a moment.

00:45:34.119 --> 00:45:39.989
And then in order to be able to work with any of your
existing classes, we have key value technologies.

00:45:39.989 --> 00:45:42.409
So KVC, KVO and KVB.

00:45:42.409 --> 00:45:51.940
I just want to turn this around quickly for a moment to
look at things the other, from a different perspective

00:45:51.940 --> 00:45:58.389
to summarize the actual technologies themselves, key
value bindings, the NS key value binding protocol used

00:45:58.389 --> 00:46:07.079
to establish bindings, but then key value observing used
to actual register the dependency, key value coding is used

00:46:07.079 --> 00:46:13.380
to communicate from view to model, key value observing
used to propagate changes in the other direction

00:46:13.380 --> 00:46:18.579
and then NS controller and subclasses
used to, used to manage model objects.

00:46:19.800 --> 00:46:27.510
So I'm not sure if that seems like an awful lot or not
lot, but basically that's the fundamentals of all you need

00:46:27.510 --> 00:46:31.050
to know in order to figure out how bindings works.

00:46:31.050 --> 00:46:38.950
It's no more complicated in its fundamentals,
in the basic technologies than that.

00:46:38.949 --> 00:46:42.859
Everything else basically is a permutation of those.

00:46:42.860 --> 00:46:46.500
How though does it correspond, how does
it work with the bookmarks example?

00:46:46.500 --> 00:46:54.610
So for those of you who looked at the, the headstart
and for the example that I gave through the beginning,

00:46:54.610 --> 00:47:10.519
if I just go back and do a, do a quick comparison
of two implementations of the bookmarks example.

00:47:10.519 --> 00:47:20.050
For the headstart, this is pretty much the example
that I gave before with a couple little tweaks.

00:47:20.050 --> 00:47:27.680
The data new data source code has been to
away separate, data in a separate file.

00:47:27.679 --> 00:47:33.690
The first action uses standard Cocoa
technologies, the second uses bindings.

00:47:33.690 --> 00:47:40.650
Rather than going through the source code to each of
those, I just want to compare the two implementations.

00:47:42.329 --> 00:47:48.170
So let's compare those in file launch.

00:47:48.170 --> 00:47:52.369
I'm not interested in the two things that are
identical or that are being added or deleted.

00:47:52.369 --> 00:48:01.929
I'm just interested in the things that have changed
and primarily actually the code that's changed.

00:48:01.929 --> 00:48:07.149
So we had a document instance that
was managing the user interface.

00:48:07.150 --> 00:48:15.880
I'm going to, another heads up here, the
source code to this is also available in ADC,

00:48:15.880 --> 00:48:18.880
so you may have seen already the
with and without binding sample code.

00:48:18.880 --> 00:48:21.550
So I'm just gonna go through this very
quickly now so that you can have a look

00:48:21.550 --> 00:48:24.539
at this afterwards yourselves and do a direct comparison.

00:48:24.539 --> 00:48:26.380
But I just want to highlight a few things.

00:48:26.380 --> 00:48:32.650
so in the without bindings example, we had a whole lot
of user interface outlets and a whole lot of methods

00:48:32.650 --> 00:48:38.170
for responding to user interface changes
and propagating back to the user interface.

00:48:38.170 --> 00:48:42.450
From the, just from the header files
it looks like all of those disappeared.

00:48:42.449 --> 00:48:44.089
That's a rather good thing.

00:48:44.090 --> 00:48:58.039
From the implementation, there was only one change it turns
out in the implementation but it was quite a big change.

00:48:58.039 --> 00:48:58.219
( Period of silence )

00:48:58.219 --> 00:49:09.339
So all that code dealing with the table view data source
and propagating changes and so on, that all disappeared.

00:49:09.340 --> 00:49:11.079
So that's good too.

00:49:11.079 --> 00:49:13.989
That's not a particularly profound thing though.

00:49:13.989 --> 00:49:18.679
The table view data source is a thing that I really
want o concentrate on for, for this next section.

00:49:18.679 --> 00:49:26.980
The table view data source as you might
hope for, the for a bindings based example,

00:49:26.980 --> 00:49:31.219
the table view data source method
is pretty much all disappeared,

00:49:31.219 --> 00:49:38.069
but the ones that supported drag and drop didn't.

00:49:38.070 --> 00:49:40.100
Which is sort of a little bit interesting.

00:49:40.099 --> 00:49:45.269
Let's have a look at the implementation.

00:49:45.269 --> 00:49:47.579
Opps. There are six differences.

00:49:47.579 --> 00:49:52.690
First of all the data source method
has disappeared as I just said.

00:49:52.690 --> 00:50:00.630
But there a few other small changes that percolate through.

00:50:00.630 --> 00:50:03.300
Most of the table view drag and
drop methods are the same though.

00:50:03.300 --> 00:50:08.630
There's a few little things that I'm
actually creating new objects and figuring

00:50:08.630 --> 00:50:11.740
out where an object is gonna get inserted and so on.

00:50:11.739 --> 00:50:18.569
But again, most of the stuff is still the same
with the exception of the deleted methods.

00:50:18.570 --> 00:50:22.170
So why is that interesting?

00:50:22.170 --> 00:50:24.329
( Period of silence )

00:50:24.329 --> 00:50:30.529
Well first of all, a whole lot of source code went away.

00:50:30.530 --> 00:50:32.980
That's encouraging.

00:50:32.980 --> 00:50:39.190
But the thing that I didn't show you,
the crucial thing that I didn't show you.

00:50:39.190 --> 00:50:46.050
Whereas in the non bindings version, the
table view data source was implemented

00:50:46.050 --> 00:50:49.880
in the document subclass as a category.

00:50:49.880 --> 00:50:58.030
In the bindings implementation, I had
a subclass of NS array controller.

00:50:58.030 --> 00:51:03.810
So NS, a custom subclass of NS array
controller had taken on the responsibility

00:51:03.809 --> 00:51:08.360
of a managing drag and drop in the table view.

00:51:08.360 --> 00:51:11.720
So as I said this is available as sample code.

00:51:11.719 --> 00:51:21.000
Looking at that pictorially, what actually happened, all
of the code that was written originally to move data around

00:51:21.000 --> 00:51:29.449
and so on disappeared and was replaced
by an instance of NS array controller.

00:51:29.449 --> 00:51:36.119
But specifically a custom subclass thereof
that still had the drag and drop code.

00:51:36.119 --> 00:51:38.469
That you still had to write.

00:51:38.469 --> 00:51:48.969
The point behind this is to get you to think about
the different roles that objects have in bindings.

00:51:48.969 --> 00:51:54.279
The controller, the NS controller
objects are still controller objects,

00:51:54.280 --> 00:51:57.800
but they're still also changeable by subclassing.

00:51:57.800 --> 00:52:03.070
If they don't do exactly what you want,
you now have a different locus of control

00:52:03.070 --> 00:52:07.470
that you can, to which you can give responsibility.

00:52:07.469 --> 00:52:12.480
In a typical application that uses, uses
a table view, your main controller object,

00:52:12.480 --> 00:52:18.840
in this case the document class is responsible for managing
the table view, for managing the selection on so on.

00:52:18.840 --> 00:52:26.190
If that, if that responsibility is pushed out into another
object, that object can also take reasonability for some

00:52:26.190 --> 00:52:32.000
of the other custom behavior such
as managing drag and drop as well.

00:52:32.000 --> 00:52:45.449
So what I'm hoping is that presenting the role of the
controller or the NS controller objects in terms basically

00:52:45.449 --> 00:52:48.689
of refactoring will give you a different handle

00:52:48.690 --> 00:52:52.929
and possibly a more approachable handle
on the way that Cocoa bindings works.

00:52:52.929 --> 00:52:59.259
It's the sort of thing that you might have done
yourself, had you had enough time and inclination.

00:52:59.260 --> 00:53:05.280
So think about the controller objects
just in terms of refactoring behavior.

00:53:05.280 --> 00:53:08.320
But it's still customizable.

00:53:08.320 --> 00:53:15.610
So that then concludes the first of three quarters or
so of the presentation in terms of what are bindings,

00:53:15.610 --> 00:53:20.079
how are they set up, what are the
technologies that lie behind bindings and so on.

00:53:20.079 --> 00:53:23.480
Now I want to go onto the second section, stuff

00:53:23.480 --> 00:53:28.710
that may not make immediate sense now
but I hope will make sense afterwards.

00:53:28.710 --> 00:53:34.369
Particularly as you get to an especially
painful moment in dealing with bindings.

00:53:34.369 --> 00:53:41.039
The first consideration I'd like to make,
make for you is a rather personal one.

00:53:41.039 --> 00:53:46.869
How many people went to the, the getting started
with core data session this morning as well?

00:53:46.869 --> 00:53:54.019
Okay. Please, for those of you who did, for those of you
who are just starting with both core data and bindings,

00:53:54.019 --> 00:54:02.250
both these technologies give you a high
level of abstraction away from your own code.

00:54:02.250 --> 00:54:06.079
They both use the same underlying technologies.

00:54:06.079 --> 00:54:08.860
Key value coding, key value observing.

00:54:11.309 --> 00:54:16.969
If you try to learn the two at the same time
and make a mistake somewhere along the line,

00:54:16.969 --> 00:54:21.169
it can be very difficult to determine
where that mistake was.

00:54:21.170 --> 00:54:25.780
So please, I strongly encourage you choose one.

00:54:25.780 --> 00:54:30.269
I don't care whether its bindings or core data.

00:54:30.269 --> 00:54:35.250
Choose one of those and master that, or if you
don't master it, at least become intimately familiar

00:54:35.250 --> 00:54:39.199
with it first and then go on to the other.

00:54:39.199 --> 00:54:45.989
It'll mean diagnosing problems is a lot easier for you.

00:54:45.989 --> 00:54:49.000
I know it's very tempting to try
to do both at the same time.

00:54:49.000 --> 00:54:52.210
But choose one, master that, then go on to the other.

00:54:52.210 --> 00:54:54.260
It'll make life easier.

00:54:54.260 --> 00:55:00.130
Second thing, the controller layer sometimes
people think oh it's a bit easy isn't it?

00:55:00.130 --> 00:55:02.400
I mean that controller just sits
there managing a single object.

00:55:02.400 --> 00:55:03.389
There's actually a lot to it.

00:55:03.389 --> 00:55:07.429
It manages to make some operations
an awful lot more efficient as well.

00:55:07.429 --> 00:55:11.299
So don't overlook its capabilities.

00:55:11.300 --> 00:55:14.100
The other thing, sometimes people see bindings

00:55:14.099 --> 00:55:18.369
or imagine the bindings is gonna be a
complete panacea or a silver bullet.

00:55:18.369 --> 00:55:24.219
I hope that one of the things that the bookmarks
example showed is that you still have to write code.

00:55:24.219 --> 00:55:28.849
There's gonna be some situations in which
bindings doesn't do everything for you.

00:55:28.849 --> 00:55:32.380
You still have to add your own value to your application.

00:55:32.380 --> 00:55:38.369
Hopefully that you're adding it in a more interesting
place than just in the data marshalling and glue code.

00:55:38.369 --> 00:55:42.940
And as part of that, existing Cocoa
pathways technologies is still valid.

00:55:42.940 --> 00:55:47.730
It's still entirely reasonable
to use the target action pattern

00:55:47.730 --> 00:55:51.909
to connect the mute button up to a mute track method.

00:55:51.909 --> 00:55:53.129
You don't want to use bindings for it.

00:55:53.130 --> 00:55:56.980
It actually makes, if you tried to use bindings
to set up that, that particular button,

00:55:56.980 --> 00:55:59.389
it would end up being a whole lot more complicated.

00:55:59.389 --> 00:56:02.739
So use the appropriate technology and use it wisely.

00:56:02.739 --> 00:56:09.559
Don't think that you can just plaster bindings all over your
application and just you know suddenly have no code at all.

00:56:10.739 --> 00:56:13.289
So some other problems that you might encounter.

00:56:13.289 --> 00:56:16.699
One of the more common ones that we
see is that people say that oh, my,

00:56:16.699 --> 00:56:20.539
my values didn't update somewhere along the line.

00:56:20.539 --> 00:56:22.989
Why might that be?

00:56:22.989 --> 00:56:26.349
Well there are a number of reasons
actually spreading over two slides.

00:56:26.349 --> 00:56:31.400
First of all, bear in mind that
not everything is KVO compliant.

00:56:31.400 --> 00:56:34.840
Indeed actually most things are not.

00:56:34.840 --> 00:56:38.180
When you consider the whole of
foundation and the whole of app kit.

00:56:38.179 --> 00:56:43.149
One of the ones that people come into particularly when
they're writing inspectors, so I'll just say that again.

00:56:43.150 --> 00:56:46.559
For those of you who are going to be
trying to write inspectors at some stage,

00:56:46.559 --> 00:56:54.219
trying to get hold of the document controllers
main document instance, that's not KVO compliant.

00:56:54.219 --> 00:57:00.949
So if you try to make a binding to
that, its not gonna get kept updated.

00:57:02.250 --> 00:57:08.159
If you have a look at the, in Leopard,
sample code of the text edit application,

00:57:08.159 --> 00:57:11.710
you'll see there's actually an example
there of how to make a binding,

00:57:11.710 --> 00:57:17.619
how to make a KVO compliant binding to the main document.

00:57:17.619 --> 00:57:26.239
Another thing that we see people doing fairly commonly
is not changing values in a KVO compliant way.

00:57:26.239 --> 00:57:33.339
We just saw in the trivial example that
simply invoking an appropriate access method

00:57:33.340 --> 00:57:38.390
or using key value coding typically
means that KVO notifications are sent.

00:57:38.389 --> 00:57:42.119
But it's also possible to changes
things in a non KVO compliant way.

00:57:42.119 --> 00:57:44.659
Particularly if you have say collections of objects.

00:57:44.659 --> 00:57:51.559
If you're simply inserting the object directly
into an array, that's not KVO compliant.

00:57:51.559 --> 00:57:59.190
The key value observing programming guide goes through
a number of different ways in which you can make sure

00:57:59.190 --> 00:58:02.820
that you can adhere or make sure you
are key value observing compliant.

00:58:02.820 --> 00:58:04.710
So make sure you read that documentation as well.

00:58:04.710 --> 00:58:12.990
One of the other pleas that we have from the
engineering is and this may not make sense

00:58:12.989 --> 00:58:15.519
until you read the programming guide, but bear it in mind.

00:58:15.519 --> 00:58:21.690
Don't invoke the change notification methods
unless you've actually changed a value.

00:58:21.690 --> 00:58:27.159
Sometimes people see things that aren't updating
appropriately in the user interface and think well maybe

00:58:27.159 --> 00:58:33.099
if I just invoke will change value for key then did
change value for key, that'll send out a notification

00:58:33.099 --> 00:58:35.190
and the value will be updated appropriately.

00:58:35.190 --> 00:58:39.360
Most of the time it is and it works.

00:58:39.360 --> 00:58:46.140
At some stage though it is quite possible that your
application will crash when you try to use that.

00:58:46.139 --> 00:58:50.019
And at some stage in the future it may not work at all.

00:58:50.019 --> 00:58:57.099
So please don't just invoke the KVO change notifications
arbitrarily just to tickle the user interface update.

00:58:58.150 --> 00:59:04.630
Other reasons why user interface might not
update or might not appear to have updated.

00:59:04.630 --> 00:59:07.360
Do bear in mind the granularity of changes.

00:59:07.360 --> 00:59:13.590
Sometimes it may be that something just
hasn't changed yet in, in your application.

00:59:13.590 --> 00:59:17.039
And you need to wait a little while
before that change is propagated through.

00:59:17.039 --> 00:59:22.380
So sometimes if you try to ask a model object for its
new value when you think that something has changed,

00:59:22.380 --> 00:59:26.740
it may not have had an opportunity to change yet.

00:59:26.739 --> 00:59:37.099
Another important, another important consideration is the
asymmetry between the different bindings technologies.

00:59:37.099 --> 00:59:41.539
That is something I sort of, I
try to stress as we went through.

00:59:41.539 --> 00:59:46.269
You bind a view to a model not the other way around.

00:59:46.269 --> 00:59:49.050
With a possible rare exception of web view.

00:59:49.050 --> 00:59:58.310
So changing a view value does not cause that value
to be propagated down to the underlying data objects.

00:59:58.309 --> 01:00:03.210
So occasionally we see people saying
well I sent a set flow value message

01:00:03.210 --> 01:00:07.030
to this text field and the data value didn't update.

01:00:07.030 --> 01:00:10.100
Well that's because that's not how bindings works.

01:00:10.099 --> 01:00:16.279
If you want to, if you want to update the
data value, update the data value directly

01:00:16.280 --> 01:00:20.330
and the view will update correspondingly.

01:00:20.329 --> 01:00:23.460
So make sure you observe the asymmetry there.

01:00:23.460 --> 01:00:27.949
A couple of things that are perhaps less than obvious.

01:00:27.949 --> 01:00:34.129
First of all, a binding name isn't
necessarily the same as a property name.

01:00:34.130 --> 01:00:41.440
So we saw that the text field had a value binding.

01:00:41.440 --> 01:00:47.780
Well NS text field doesn't actually have a value
instance variable or a value accessor method or whatever.

01:00:47.780 --> 01:00:50.769
It does have a value binding though.

01:00:50.769 --> 01:00:56.599
So don't necessarily assume that just because a particular
or a particular class that you're going to interact

01:00:56.599 --> 01:01:03.630
with has a, has a particular accessor method pair or
a particular instance variable that you can bind that.

01:01:03.630 --> 01:01:09.599
Have a look in the bindings reference documentation
to see what bindings are actually available.

01:01:09.599 --> 01:01:14.279
And then you'll also see what the
various options are as well.

01:01:15.949 --> 01:01:18.309
Final on in this section.

01:01:18.309 --> 01:01:24.000
I said there was no magic.

01:01:24.000 --> 01:01:32.690
The one thing that gets close to being magic but its not
really in bindings is that there are a couple of bindings

01:01:32.690 --> 01:01:37.070
that are set up for you automatically in table views.

01:01:37.070 --> 01:01:41.160
And this tends to confuse people
when they're not expecting it.

01:01:41.159 --> 01:01:48.349
If you bind a table columns value, so bind
a value of a table column in a table view,

01:01:48.349 --> 01:01:57.150
that automatically behind the scenes sets up three
additional bindings for you for the table view itself.

01:01:57.150 --> 01:02:04.220
So if you happen to want to programmatically
establish a binding for content, selection indexes,

01:02:04.219 --> 01:02:15.099
or source descriptors, you must actually set
those three up, set up each of those three.

01:02:15.099 --> 01:02:17.309
You can't just programmatically bind one.

01:02:17.309 --> 01:02:21.190
You have to programmatically bind all of them.

01:02:21.190 --> 01:02:26.849
So that catches some people out.

01:02:26.849 --> 01:02:28.980
Finally debugging.

01:02:28.980 --> 01:02:33.659
One of the things that comes up
occasionally in the list is people say,

01:02:33.659 --> 01:02:36.219
well I got this back trace and
I don't know what's gone wrong.

01:02:36.219 --> 01:02:40.629
Well I hope that again from the example that
we went through during the hands on session,

01:02:40.630 --> 01:02:47.070
it'll now be a little bit more obvious that
the debug message means exactly what it says.

01:02:47.070 --> 01:02:48.320
It's usually pretty helpless.

01:02:48.320 --> 01:02:57.269
Well this one particular object that I'm trying to bind
to is not KVC compliant for the key that you gave me.

01:02:57.269 --> 01:03:04.539
So your task then is to find well where did I make
a mistake in trying to set that particular key?

01:03:04.539 --> 01:03:08.690
Things are actually a little bit better
or will be a little bit better in Leopard.

01:03:08.690 --> 01:03:13.440
When you get this error message in Leopard
at some stage in the future, the near future,

01:03:13.440 --> 01:03:19.429
you'll actually get an object ID for the user interface
element that was trying to set up the bindings.

01:03:19.429 --> 01:03:26.000
So you can actually go directly to Interface Builder
to say okay which was the object that I was trying

01:03:26.000 --> 01:03:30.670
to bind that's got the incorrect key path.

01:03:30.670 --> 01:03:37.119
So having gone through then setting up bindings,
the technology behind bindings and learning

01:03:37.119 --> 01:03:39.489
from others, let's get on to the conclusion.

01:03:39.489 --> 01:03:41.339
What have we actually learned from this?

01:03:41.340 --> 01:03:47.160
First of all, what Cocoa bindings are, a
collection of technologies for keeping model

01:03:47.159 --> 01:03:50.359
and view synchronized, the values therein.

01:03:50.360 --> 01:03:53.980
And then there are three technologies
that Cocoa bindings relies on.

01:03:53.980 --> 01:04:00.670
First of all, key value binding itself,
key value observing, and key value coding.

01:04:00.670 --> 01:04:08.380
And then controller objects manage either a
single object or a collection of other objects.

01:04:08.380 --> 01:04:17.760
If you want to know more, Derrick Horn is probably
sitting in a room next door just waiting for your call.

01:04:17.760 --> 01:04:22.450
Feel free to contact Deric if you want to know
more about Cocoa bindings or you have any feedback,

01:04:22.449 --> 01:04:25.730
any specific feedback about the
technology or where you would

01:04:25.730 --> 01:04:28.840
like to see Cocoa bindings going in the future and so on.

01:04:28.840 --> 01:04:32.450
And then there is a fair amount
of documentation on the subject.

01:04:32.449 --> 01:04:39.199
We are hoping that it will be improved in the future.

01:04:39.199 --> 01:04:42.509
We're aware of limitations therein.

01:04:42.510 --> 01:04:47.590
There are though increasing numbers of, increasing
pieces of sample code that are available.

01:04:47.590 --> 01:04:51.260
So a couple that have posted recently
say, one in particular bound button.

01:04:51.260 --> 01:04:56.260
It said that you typically don't want to bind buttons.

01:04:56.260 --> 01:04:58.630
But for the sake of it I though it would be worth posting a,

01:04:58.630 --> 01:05:03.480
posting an example of one case binding a button
does actually make a certain amount of sense.

01:05:03.480 --> 01:05:06.179
So have a, feel free to have a look at that.

01:05:06.179 --> 01:05:14.000
And there's a collection, there's a small framework of new
bindings enabled objects that's I think should be posted now

01:05:14.000 --> 01:05:15.690
or should be posted in the very near future.

01:05:15.690 --> 01:05:16.909
Bindings electric.

01:05:16.909 --> 01:05:18.599
And then there are several of those coming up in the future.
WEBVTT

00:00:11.060 --> 00:00:17.490
>>Good Afternoon everyone; welcome to
session 111 on Managing Schema Versioning

00:00:17.489 --> 00:00:20.469
and Data Migration in your Core Data Application.

00:00:20.469 --> 00:00:25.429
My name is Miguel Sanchez, I'll be doing the first
half of the presentation and then I'll be joined

00:00:25.429 --> 00:00:33.159
by Ron Lue-Sang who...and we're both
engineers in the Core Data team.

00:00:33.159 --> 00:00:37.879
So, seventeen days until the iPhone ships.

00:00:37.880 --> 00:00:41.510
( Laughter )

00:00:41.509 --> 00:00:46.710
That's all I'm going to say about that.

00:00:46.710 --> 00:00:49.109
( Applause )

00:00:49.109 --> 00:00:52.380
This session is actually about
Core Data versioning and migration.

00:00:52.380 --> 00:00:55.850
I hope you guys had a chance to
go to the previous 2 sessions.

00:00:55.850 --> 00:01:00.910
How many of you were in sessions this
morning or have prior Core Data experience?

00:01:00.909 --> 00:01:06.310
Yea, given the limited crowd I'm assuming
you guys are the hard core, Core Data fans.

00:01:06.310 --> 00:01:09.060
So how will this session help you?

00:01:09.060 --> 00:01:13.469
This is the situation you might find yourself in
as you're developing your Core Data applications.

00:01:13.469 --> 00:01:18.560
You'll have a particular version of your
application, it's great but you continue to improve it

00:01:18.560 --> 00:01:24.159
and before you deploy it you have
to face the following issue.

00:01:24.159 --> 00:01:31.030
Your customer data or whoever is using your application
is still bound to the previous version of the application;

00:01:31.030 --> 00:01:36.950
so as you've improved your application you've decided
to improve the schema...you basically decided

00:01:36.950 --> 00:01:43.250
to manage your data in a slightly different way and it's
like a different shape and form, so we have to find a way

00:01:43.250 --> 00:01:48.900
to migrate your data over from your old version of
your application into the new format that you require

00:01:48.900 --> 00:01:53.630
for your new application; so this
is what this session is about.

00:01:53.629 --> 00:02:02.810
We'll be talking about 3 features; the first is a new way
we have in Leopard for tagging your models and your stores

00:02:02.810 --> 00:02:09.250
with a particular version ID; the
second is a new model we're introducing,

00:02:09.250 --> 00:02:14.219
a mapping model that allows you to...this is where you
tell us how you want us to migrate your data from one

00:02:14.219 --> 00:02:18.180
to the other and the third is course new run time classes

00:02:18.180 --> 00:02:22.719
that perform the migration for
you and which you can customize.

00:02:22.719 --> 00:02:28.099
A quick Core Data review for those that are new to
the technology or skipped this morning sessions;

00:02:28.099 --> 00:02:33.319
this is the high level items you need
to know for this particular talk.

00:02:33.319 --> 00:02:41.319
So Core Data manages data for you; to do that we need the
description of the data you want us to manage in a model.

00:02:41.319 --> 00:02:48.189
Once we have that description we maintain a file in your
file system, that's your store, that's where your data lives

00:02:48.189 --> 00:02:55.939
but you'll actually be interacting with your data
as an object graph, as a...in memory object graph

00:02:55.939 --> 00:03:03.000
of Objective-C instances; so this
is what Core Data is about.

00:03:03.000 --> 00:03:08.919
Now of course a Core Data application has
more; it's got UI, it's got your custom logic,

00:03:08.919 --> 00:03:17.189
for purposes of this presentation we really won't be
talking about migration issues relating to moving to new UI

00:03:17.189 --> 00:03:23.759
or even API for example; let me make clear that this
has nothing to do with new Core Data APIs that you have

00:03:23.759 --> 00:03:31.969
to migrate to; this is about you guys, right; so
like my wife says, "Honey, it's not me, it's you."

00:03:31.969 --> 00:03:39.650
So I think what she means by that is that I
have chosen to move, to evolve my model over

00:03:39.650 --> 00:03:43.120
and I need to take care of moving the data over.

00:03:44.439 --> 00:03:46.449
So why do we need migration?

00:03:46.449 --> 00:03:53.639
As long as we have a model description we're able to create
the persistent store file in which we're going to use...in

00:03:53.639 --> 00:04:02.299
which we're going to store your data; so that works fine;
we're able to persist the data that you asked us to do.

00:04:02.300 --> 00:04:08.590
Now, the moment you decide that your customers are
really asking for you to give them an application

00:04:08.590 --> 00:04:14.270
that manages stars and hexagons then you're
breaking the schema with your store, right?

00:04:14.270 --> 00:04:19.629
I just want...you're giving us a model, you're
pointing us to a store that is not described

00:04:19.629 --> 00:04:26.670
by the model you're giving us so we have to do something
about that; this is where migration becomes an issue.

00:04:26.670 --> 00:04:33.240
So this can happen for 2 reasons; either you're
deploying a whole new version of your application,

00:04:33.240 --> 00:04:38.290
a major version change but realize
this also happens internally

00:04:38.290 --> 00:04:43.500
as you're developing your own Core Data applications; you're
modifying your schema; you're experimenting with things

00:04:43.500 --> 00:04:51.269
so the migration issue is still the same; this is not just
a deployment time kind of thing; you'll also have to deal

00:04:51.269 --> 00:04:56.469
with it within your own many versions
that you have in your deployment cycle.

00:04:56.470 --> 00:05:00.740
So once you realize that you have to
migrate your data you need 3 things.

00:05:00.740 --> 00:05:07.550
You need to give us...we don't do magic, we still need the
model, the Core Data model descriptions to both versions

00:05:07.550 --> 00:05:10.030
of your data; so you need to give us that.

00:05:10.029 --> 00:05:15.379
You also need to give us a mapping model that tells us
how to get from one to the other and of course you need

00:05:15.379 --> 00:05:18.879
to point us to the stores that you want us to migrate.

00:05:18.879 --> 00:05:26.860
Most of the time you will be doing this within Xcode; we
now have a new Core Data model which is a version model;

00:05:26.860 --> 00:05:33.090
it's now a group and a directory in the file system
and inside that you can put in the multiple versions,

00:05:33.089 --> 00:05:39.310
your multiple generations for each particular model
that you're working with and we now have a new file type

00:05:39.310 --> 00:05:42.639
which is the XE mapping model and you
can see the editor there under write

00:05:42.639 --> 00:05:45.810
and I'll be showing these shortly in a demo.

00:05:47.449 --> 00:05:55.129
So this is what you need to begin the migration; what
happens behind the scenes to actually perform the migration.

00:05:55.129 --> 00:05:59.329
So we're now starting to talk in
terms of sources and destinations,

00:05:59.329 --> 00:06:02.899
this is the terminology I'll be using throughout the talk.

00:06:04.120 --> 00:06:10.389
So we get to migration by you giving us a model
which is incompatible with your source store;

00:06:10.389 --> 00:06:16.800
so the first thing we have to do is find the source model
that we need to open the source store and the mapping model

00:06:16.800 --> 00:06:20.100
that tells us how to migrate your data over;

00:06:20.100 --> 00:06:25.360
this is all given to the migration
manager class, one of our new classes.

00:06:25.360 --> 00:06:33.600
The migration manager's responsibility is to create
a new Core Data stack with the proper data format.

00:06:33.600 --> 00:06:37.290
So to do that it instantiates a
whole source Core Data stack;

00:06:37.290 --> 00:06:40.560
it knows how to do that because
you given it the source model.

00:06:40.560 --> 00:06:47.509
We instantiate a source stack, we fetch the instances
and one by one we migrate them over to the destination.

00:06:47.509 --> 00:06:50.110
Why should we do this in multiple stages?

00:06:50.110 --> 00:06:55.860
During the first stage we only create instances,
during the second stage we recreate the relationships

00:06:55.860 --> 00:07:01.520
and during the third stage we make sure that the
migration was correct and we do the validation.

00:07:01.519 --> 00:07:10.680
So at the end of this process you have a new Core Data,
a persistent store with the data that is compatible

00:07:10.680 --> 00:07:13.670
with the new version of the model that you gave us.

00:07:13.670 --> 00:07:20.170
So let me show you how this all fits together
so that you know what I'm talking about.

00:07:20.170 --> 00:07:27.480
So here we have 2 simple versions of the same
application; on the left is my source application,

00:07:27.480 --> 00:07:33.060
on the right is my new application; so you can see on
the left we have a very, very simple Core Data model;

00:07:33.060 --> 00:07:37.220
it's on a person with age, name,
state, and street address fields

00:07:37.220 --> 00:07:44.150
and the new improved application not only has a slightly
different UI but I've also decided to improve my schema

00:07:44.149 --> 00:07:48.149
by introducing a new relationship and a new entity.

00:07:48.149 --> 00:07:52.459
So let's begin here by inputting some
data in my original application.

00:07:52.459 --> 00:07:54.919
( Pause )

00:07:54.920 --> 00:08:07.009
I'm so glad I'll be able to drink at the beer
bash this year. And my son...let's add 3 records;

00:08:07.009 --> 00:08:13.019
he turned 2 last week; he still
lives with me, and then Ron...

00:08:13.019 --> 00:08:13.969
( Pause )

00:08:13.970 --> 00:08:23.480
hides his age pretty well.

00:08:23.480 --> 00:08:28.759
Okay, so we have just random data; we'll call this demo.

00:08:28.759 --> 00:08:36.539
So that's your version 1 of your application; now you
deploy your new application and we don't have it set

00:08:36.539 --> 00:08:40.129
up to do versioning yet but I just want
to show you what happens if you try

00:08:40.129 --> 00:08:44.809
to open the store we just created with a new application.

00:08:44.809 --> 00:08:52.500
So, we have the demo store and we get an error panel where
Core Data detects that there's a version incompatibility,

00:08:52.500 --> 00:08:57.159
so we need to do something about
that to move your data over.

00:08:57.159 --> 00:09:02.519
So fortunately we've already have all of the
elements that we require in this project;

00:09:02.519 --> 00:09:05.850
I have just not enabled versioning to happen automatically.

00:09:05.850 --> 00:09:14.029
So we have, like I said, a version Core Data model
with both the old version, here's the person entity

00:09:14.029 --> 00:09:23.809
and the new version and we also have a mapping model which
I'll go into a lot more detail in the second demo as to how

00:09:23.809 --> 00:09:30.209
to create one of these but right now we have
one where we have the mapping definitions

00:09:30.210 --> 00:09:37.820
that tells us...that tell us how to go from person to
person and from person to address and the last thing I need

00:09:37.820 --> 00:09:45.390
to do it by default we bring up that error panel;
unless you tell us to try to do automatic migration.

00:09:45.389 --> 00:09:52.230
So this is a default code that you get from
the document class and one of the methods is

00:09:52.230 --> 00:09:59.009
where you're configuring the persistent store
coordinator and all I'm doing is, we have a new option

00:09:59.009 --> 00:10:01.710
and NS migrate persistent store automatic option,

00:10:01.710 --> 00:10:06.990
which I'm setting to yes...that's the
only reason I'm overriding this method

00:10:06.990 --> 00:10:13.120
and we just called the supra implementation so all
I'm saying with that option is "If I see this option,

00:10:13.120 --> 00:10:18.899
go out into your project, look for the corresponding
models that we need and try to perform the migration."

00:10:18.899 --> 00:10:21.509
So let me launch the application again.

00:10:23.169 --> 00:10:35.469
Here's the old data...we open it...here...and
boom; we have new data.

00:10:35.470 --> 00:10:40.820
( Applause )

00:10:40.820 --> 00:10:43.180
So we can go back to slides please.

00:10:43.179 --> 00:10:47.709
So that's just a quick overview so you know
really how you'll be interacting with these tools;

00:10:47.710 --> 00:10:54.180
now we're ready to go into a lot more detail and
you won't be so lost as to what I'm talking about.

00:10:54.179 --> 00:11:00.009
Model versioning and mapping...let's step back a little bit.

00:11:00.009 --> 00:11:02.639
Let me introduce a few patterns that you might come

00:11:02.639 --> 00:11:06.509
across as you're evolving your
schema of your Core Data application.

00:11:06.509 --> 00:11:11.840
Now these could be very simple things, you're
simply adding or removing attributes or entities.

00:11:11.840 --> 00:11:17.149
You can have fairly intermediate kind of changes where
you're actually transforming the data that you have

00:11:17.149 --> 00:11:25.110
in your store, up to nontrivial transformations; you
have to deal with incomplete data, duplicate detection;

00:11:25.110 --> 00:11:32.419
I'd like to point out at this moment that even though
Core Data helps you a lot with the problem of migration

00:11:32.419 --> 00:11:36.689
from a data base technology point of view
migration is a very sophisticated issue.

00:11:36.690 --> 00:11:43.030
You could really get into trouble if you're trying to
deal with your data in a manner that you didn't intend

00:11:43.029 --> 00:11:48.039
to so you have incomplete data, the transformation
ends up being a fairly sophisticated thing;

00:11:48.039 --> 00:11:52.379
so that's independent of what Core Data does for you.

00:11:52.379 --> 00:11:59.490
So here's the first pattern; we have a very simple entity
that has an age and a name and you might want to extend

00:11:59.490 --> 00:12:03.139
in version 2 of your application you
now what to keep address information

00:12:03.139 --> 00:12:06.759
in your entities and now you have a state and a street.

00:12:07.840 --> 00:12:15.110
You continue the evolutions from version 2 to version 3
and you decide to pay attention to what Melissa told you

00:12:15.110 --> 00:12:20.519
in the first talk and extract address fields
into a separate, a whole separate entity;

00:12:20.519 --> 00:12:24.949
this also gives you the opportunity
of having multiple address per person;

00:12:24.950 --> 00:12:28.050
you can also do this without migration solution.

00:12:29.129 --> 00:12:35.990
Going from version 3 to version 4 you decide that you
now want to introduce inheritance into your model;

00:12:35.990 --> 00:12:42.450
you're interested in seeing person instances not only
as generic persons but either as adult or children based

00:12:42.450 --> 00:12:49.220
on their age and you decide to also introduce additional
information per subclass, per sub entity, I'm sorry;

00:12:49.220 --> 00:12:56.899
company names for adults and school names for
children and the last change you might want

00:12:56.899 --> 00:13:00.579
to do is this is where you start cleaning up your data.

00:13:00.580 --> 00:13:08.090
You notice that adults and children have company names and
school names but of course multiple adults will be working

00:13:08.090 --> 00:13:14.870
at the same company and multiple children will be going
to the same school so you want to do a unique pass

00:13:14.870 --> 00:13:19.149
and extract all the common values
for company name and school name

00:13:19.149 --> 00:13:23.269
and have their own separate entities
for them and create relationships.

00:13:23.269 --> 00:13:29.279
Okay, so this is just an example of how you can be
evolving your model from version 1 all the way to version 5

00:13:29.279 --> 00:13:35.069
and all of these things you can do
with our versioning mapping solutions.

00:13:35.070 --> 00:13:43.610
So, how does Core Data know that you have made a change
in your model that breaks our ability to read your data?

00:13:43.610 --> 00:13:49.419
If you change any of the following things that
are up on the screen this breaks our ability

00:13:49.419 --> 00:13:53.039
to break, to read your data from your store.

00:13:53.039 --> 00:13:56.919
You're changing your entity name, you're
saying anything having to do with inheritance,

00:13:56.919 --> 00:14:05.459
the properties you're actually writing out or you want us to
write out to disk, at the property level names, optionality,

00:14:05.460 --> 00:14:11.040
attribute types, obviously the definition of the
relationship; we've already prebuilt the store for you

00:14:11.039 --> 00:14:14.490
and now you come by and change the
structure of what you want to manage

00:14:14.490 --> 00:14:17.779
so that will break our ability to read you data.

00:14:17.779 --> 00:14:23.350
There are certain things that don't break our
ability to read your data such as the class name

00:14:23.350 --> 00:14:26.570
that you're using a runtime to instantiate your instances,

00:14:26.570 --> 00:14:32.170
transient properties because those are not actually
persisted; user info validation, predicates,

00:14:32.169 --> 00:14:38.039
which really don't come into play until we save
your data out and the same thing for properties.

00:14:38.039 --> 00:14:40.789
So what do we do with these changes?

00:14:40.789 --> 00:14:46.219
We simply calculate a hash digest for each one
of the entities that participates in your model;

00:14:46.220 --> 00:14:51.629
so you give us your model, we do through a hashing
algorithm, we come up with a number, that's the version ID,

00:14:51.629 --> 00:14:55.000
you give us a different version of the model,

00:14:55.000 --> 00:14:59.029
we pass it through a hashing algorithm,
we come up with another version.

00:14:59.029 --> 00:15:04.339
So, I'm going to be using shapes from now on
just so that it's easy for you guys to detect

00:15:04.340 --> 00:15:10.320
when there's a difference rather than
trying to part long strings of hex numbers.

00:15:10.320 --> 00:15:17.280
So here's what I was talking about that certain
changes do affect the version hash and others don't.

00:15:17.279 --> 00:15:25.470
You have version 1-0 of your entity, we calculate
its version hash we come up with a particular value,

00:15:25.470 --> 00:15:30.529
you continue evolving you application; you might even
change the name of your model but you only happen

00:15:30.529 --> 00:15:35.689
to touch validation rules, user info or the
custom class that you are using so even though

00:15:35.690 --> 00:15:40.450
for your purposes this might be a different
version we're still compatible with your stores;

00:15:40.450 --> 00:15:45.070
so our hashing algorithm will detect that you
haven't changed anything of significance to us

00:15:45.070 --> 00:15:48.680
so we have the same number coming out the other side.

00:15:48.679 --> 00:15:52.120
Of course the moment you start
adding properties to you entities

00:15:52.120 --> 00:15:58.340
or for example an address relationship then
we will detect that something is different.

00:15:58.340 --> 00:16:00.710
I'd also like to point out that we don't have the concept

00:16:00.710 --> 00:16:04.879
of versioning even though I keep
saying versioning for your models.

00:16:04.879 --> 00:16:11.429
We don't really manage the concept of versioning at the
model level; a model is really just a collection of entities

00:16:11.429 --> 00:16:15.699
so when we talk about versioning at least from core
data's point of view we're talking about the versions

00:16:15.700 --> 00:16:22.509
of the entities inside your model; we don't really
tag your model with a particular version identifier.

00:16:22.509 --> 00:16:24.669
So what do we do?

00:16:24.669 --> 00:16:30.370
You give us a model, you point us to a store and we create
a Core Data stack for you; we calculate the version hashes

00:16:30.370 --> 00:16:37.850
for the model and when you ask us to save we save
that versioning information as metadata in the store;

00:16:37.850 --> 00:16:44.759
so you simply, we have a new key, you know, metadata
in a store, model version hash key; you can look it

00:16:44.759 --> 00:16:51.519
and all you see will be a dictionary with the entity
names and the hash digest for each of the entities.

00:16:52.950 --> 00:16:59.850
Once we have this information now we can really determine
that there's a version compatibility or incompatibility.

00:16:59.850 --> 00:17:05.779
We can't fully trust you guys to tell us
when something broke because your idea

00:17:05.779 --> 00:17:08.599
of what a version is, is different from what our idea is.

00:17:08.599 --> 00:17:14.480
So, if you give us proper versions of the model
in the store, how do we know they're correct?

00:17:14.480 --> 00:17:21.039
Because we have that information; we go to the store first,
get its metadata, check against what we have from the model;

00:17:21.039 --> 00:17:25.579
this is fine; we build up the stack for you.

00:17:25.579 --> 00:17:32.889
Version incompatibility we now have different numbers at
the model at the store and this is how that panel came up;

00:17:32.890 --> 00:17:37.200
this is how we were able to know that
you were giving us a wrong model.

00:17:38.460 --> 00:17:41.860
Now of course you don't want to deploy
error panels in your applications.

00:17:41.859 --> 00:17:45.559
You want to have function applications
that open your preexisting data;

00:17:45.559 --> 00:17:50.000
so this is where mapping models come into play.

00:17:50.000 --> 00:17:54.759
So here we have version 4 and version 5 and
we're going to need to create a mapping model

00:17:54.759 --> 00:17:57.650
that tells us how to go from one to the other.

00:17:57.650 --> 00:18:03.130
I'm going to flatten out the models here a little
bit; so I'm going to get rid of the inheritance lines

00:18:03.130 --> 00:18:10.840
in the relationships...so you can see on the
left the entities that participate in the source

00:18:10.839 --> 00:18:14.470
on the right the entities that
participate on the destination.

00:18:14.470 --> 00:18:21.160
At a very high level what a mapping model has to
tell us is the following, "You know what Core Data,

00:18:21.160 --> 00:18:28.019
create adult instances from my person, create
other children instances from person to

00:18:28.019 --> 00:18:33.379
and just migrate my address instances as they are
because I didn't really change any of this version;

00:18:33.380 --> 00:18:37.560
so this is what you're telling us,
how to get from one to the other.

00:18:37.559 --> 00:18:41.460
Likewise at the attribute level you're
telling us how to populate each thing

00:18:41.460 --> 00:18:45.400
in your instances as we're moving the data over.

00:18:46.599 --> 00:18:53.629
So we have equivalent classes; you should know that
we have...modeling classes in the current version

00:18:53.630 --> 00:19:00.160
of Core Data to...represent a Core Data managed
object model; so we now have 3 new classes

00:19:00.160 --> 00:19:06.080
to represent a Core Data mapping model; mapping
model entity mapping and property mapping.

00:19:06.079 --> 00:19:14.710
At runtime these are used by a new class which
is the true workhorse of the migration logic

00:19:14.710 --> 00:19:19.930
and its entity migration policy; so the migration
policy has all the default implementation for how

00:19:19.930 --> 00:19:25.400
to migrate your instances over and we use the
definitions that you give us in your entity mappings

00:19:25.400 --> 00:19:28.870
and the whole process in coordinated by a migration manager;

00:19:28.869 --> 00:19:33.500
these are the 5 new classes that
we're introducing for migration.

00:19:33.500 --> 00:19:41.180
A quick refresher of the migration process, remember that
we build up 2 Core Data stacks and we stage multiple stacks,

00:19:41.180 --> 00:19:44.890
instance, creation, relationship creation,
and validation.

00:19:44.890 --> 00:19:52.700
So entity mappings, the 2 main things we want to know
about an entity mapping are what the source entity is

00:19:52.700 --> 00:19:59.960
and what the destination entity is and you can also give it
a mapping name; as your mapping models grow it's important

00:19:59.960 --> 00:20:03.210
that you have names on them so you can differentiate them.

00:20:03.210 --> 00:20:10.740
A mapping order, it might be important for you to migrate
certain instances before others and of course you can plug

00:20:10.740 --> 00:20:17.480
in your own custom policy class names so that if you don't
like the default implementation this is where you tell us,

00:20:17.480 --> 00:20:21.029
"You know what, use this class which is
a subclass of your default implementation

00:20:21.029 --> 00:20:24.490
and that's where I'll do my customize migration."

00:20:24.490 --> 00:20:33.710
At the property mapping level we have the name of the
destination property and a value expression definition.

00:20:33.710 --> 00:20:39.900
So you have a...a value expression which we
evaluate and whatever comes out of that is the value

00:20:39.900 --> 00:20:44.830
that we're going to stick in your destinations property.

00:20:44.829 --> 00:20:53.220
As we're evaluating the value expression and as you're giving
it to us you have access to a handful of special keys

00:20:53.220 --> 00:20:59.960
which are dollar sign something; so you can access the
source instance, the destination instance, the manager,

00:20:59.960 --> 00:21:06.329
even the entity mapping if you happen to need
that during the evaluation of the expression.

00:21:06.329 --> 00:21:13.089
Here's a very, very simple expression; you'll see a
more sophisticated one later on, 2 or 3 slides down.

00:21:13.089 --> 00:21:20.439
Let's say that you want us to fill in your name property by
doing a simple copy of the name property from the source;

00:21:20.440 --> 00:21:24.710
so you would just do dollar sign source
dot name; we evaluate that, we get its name

00:21:24.710 --> 00:21:29.210
and that's what goes into the name in your new entity.

00:21:29.210 --> 00:21:37.160
Now let's go back to the pattern that I introduced
in the earlier session; actually it was this session.

00:21:37.160 --> 00:21:41.850
So we have person to person, you would have an
entity mapping that we can name whatever we want,

00:21:41.849 --> 00:21:49.089
I'm going to call it person to person, the source is person,
the destination is person, that's what you want us to create

00:21:49.089 --> 00:21:51.019
and the property mappings are the following.

00:21:51.019 --> 00:21:58.940
So you want us to get the age and the name from the
sources age and name; pretty straight forward, first step.

00:21:58.940 --> 00:22:06.049
Second panel, we still need the mapping we just talked
about because you still want us to create persons

00:22:06.049 --> 00:22:13.430
from your persons so you still have that mapping but in this
case you need an additional mapping to create addresses.

00:22:13.430 --> 00:22:20.019
So we have a new mapping, persons who
address; the source is person, that's obvious.

00:22:20.019 --> 00:22:23.619
The destination is now address and here are the mappings.

00:22:23.619 --> 00:22:31.829
You want us to create an instance of address for each person
and you just want us to copy over the state and the street

00:22:31.829 --> 00:22:38.949
as we were basically getting the information from the person
instance and sticking it into the new address instances.

00:22:38.950 --> 00:22:44.779
Now we get into the inheritance example; you want
us to create adults and children, 2 mappings;

00:22:44.779 --> 00:22:52.690
the first one is person to adult, person to adult, the
source is a person but you can attach a filter predicate

00:22:52.690 --> 00:23:00.840
to the mapping; so you only want us to fetch persons
who's age is over 18, the destination is adult

00:23:00.839 --> 00:23:12.599
and the property mappings you've seen before; likewise for
the child, we have another mapping...that the only thing

00:23:12.599 --> 00:23:15.339
that changes here is that the filter is now under 18.

00:23:15.339 --> 00:23:17.849
I don't know what happens with the animations there.

00:23:17.849 --> 00:23:21.799
The filter is now under 18 and the destination is child.

00:23:21.799 --> 00:23:26.980
You'll notice that I have glossed over; I
haven't even mentioned relationship mappings.

00:23:26.980 --> 00:23:33.789
Those take a little bit; those take one additional
step that is unlike the property mappings.

00:23:33.789 --> 00:23:42.680
You might think...so what we want to do here is hook
up Ron to his corresponding migrated address instance;

00:23:42.680 --> 00:23:46.990
now you would think you would want to do something
like, "You know, just populate his address

00:23:46.990 --> 00:23:50.230
with whatever the address was on the source."

00:23:50.230 --> 00:23:52.849
Why won't this work?

00:23:52.849 --> 00:23:59.889
As we evaluate dollar sign source we have an instance of
source in the source context; we traverse the key path;

00:23:59.890 --> 00:24:04.890
we have an instance of address in the...source context

00:24:04.890 --> 00:24:09.250
but this is not the one we want;
we want to find this one, right.

00:24:09.250 --> 00:24:12.660
We can't just take an instance from a source
content and put it into the destination;

00:24:12.660 --> 00:24:19.870
these are completely different objects; they have different
object IDs; they could be even different address definitions

00:24:19.869 --> 00:24:25.189
for the entity; so what we really want to
know is "what was the corresponding address

00:24:25.190 --> 00:24:29.450
that was created in the destination for this source?"

00:24:29.450 --> 00:24:36.110
Once we have that we're able to
hook up Ron to his migrated address;

00:24:36.109 --> 00:24:41.639
so fortunately the migration manager keeps
track of this as we're doing the migration.

00:24:41.640 --> 00:24:49.910
So as it's moving each instance it's keeping lookup
tables so that you can ask these kinds of questions.

00:24:49.910 --> 00:24:55.940
So what you have to do in your mapping model is, you
can't just do the simple expression I had before;

00:24:55.940 --> 00:25:03.080
you still have those elements; you still have, "I want to
walk, dollar sign source dot address" but you also need

00:25:03.079 --> 00:25:09.169
to tell us which entity mapping was used to create
the instances that you're interested in getting here

00:25:09.170 --> 00:25:17.029
on the destination; so here we want to get the addresses
that were created with the address to address entity mapping

00:25:17.029 --> 00:25:22.799
and all the other stuff, don't be overwhelmed; that's just
because we have a value expression this is how you have

00:25:22.799 --> 00:25:30.159
to do it in a valued expression to execute a
method called on the manager and we also have UI

00:25:30.160 --> 00:25:35.480
that makes this...defining this a lot easier;
you don't have to type in this whole thing.

00:25:35.480 --> 00:25:42.849
You'll also remember that in one of my patterns we didn't
really have a whole separate address instance on the source

00:25:42.849 --> 00:25:50.469
but the mechanism that we follow is the same; so we
evaluate the source; we don't have source dot address

00:25:50.470 --> 00:25:55.410
because we remember the address information was
embedded in the source model but we still want

00:25:55.410 --> 00:25:58.480
to answer the same question; we still want to answer,

00:25:58.480 --> 00:26:02.950
"What was the address instance that
was created for Ron in the source?"

00:26:02.950 --> 00:26:11.059
So the question is the same; the only thing that changes is
that we don't use the full key pad in the value expression;

00:26:11.059 --> 00:26:19.669
we only say, "Go to the source, get Ron, now look at
another table, look at the person to address mapping;

00:26:19.670 --> 00:26:24.200
so now that you have Ron tell me which address
was created for this person and whatever

00:26:24.200 --> 00:26:28.470
that is that's what I want to bind
to my address relationship."

00:26:28.470 --> 00:26:35.230
So this is why you need an extra step
when you're hooking up addresses.

00:26:35.230 --> 00:26:38.279
So let's show you this in a demo.

00:26:38.279 --> 00:26:46.690
This demo will show you how to create
version models and...mapping models.

00:26:46.690 --> 00:26:58.380
So I have to bring up...I have to bring
up this guy...so this is where we ended

00:26:58.380 --> 00:27:03.300
in the previous demo; now we want to get to this model.

00:27:03.299 --> 00:27:08.700
So in the previous demo we did not have inheritance;
now we're going to introduce inheritance;

00:27:08.700 --> 00:27:14.009
so here's a new version of my application; I'm going
to launch it; I'm going to...you see we have a new UI

00:27:14.009 --> 00:27:22.279
where we separated between adults and children; we're
going to try to open the old version of the data.

00:27:22.279 --> 00:27:25.180
Here we have demo and there's our error.

00:27:25.180 --> 00:27:31.860
Our error panel, you have to do something about
this so let me...now I'm not going to cheat;

00:27:31.859 --> 00:27:34.799
I'm going to show you how to create things by hand here.

00:27:34.799 --> 00:27:40.720
Before I forget let me built in Queen
because I always forget to do this.

00:27:40.720 --> 00:27:44.769
So here we have...the new version of you model, right.

00:27:44.769 --> 00:27:46.470
It's got inheritance.

00:27:46.470 --> 00:27:49.069
How do we create a version model inside of Xcode?

00:27:49.069 --> 00:27:55.329
We select the model; we go to the design menu, data
model and now we have a new menu item here that says,

00:27:55.329 --> 00:28:02.720
"Data model version," so this becomes a group; it
just made a copy of the model you had selected.

00:28:02.720 --> 00:28:09.789
So here's the old version, the new version; I want to
rename them just so that they're easier to identify.

00:28:09.789 --> 00:28:22.809
So this is the new...this is the old...but the old
didn't really have inheritance so I'm going to modify it

00:28:22.809 --> 00:28:27.710
to actually be the old; so get rid of that,
get rid that; I also added an attribute

00:28:27.710 --> 00:28:31.640
in the new model for city; I'm going to get rid of that.

00:28:31.640 --> 00:28:33.770
Okay, so now you have a version model.

00:28:33.769 --> 00:28:36.859
You have your old version and your new.

00:28:36.859 --> 00:28:41.439
We also want to make the new one the current version
so that when the application launches it uses this one.

00:28:41.440 --> 00:28:46.330
So you'll see this little green icon here; that
indicates what the current model version is.

00:28:46.329 --> 00:28:51.259
So I want to make new the current model version so
you just go to the design menu, set current version

00:28:51.259 --> 00:28:54.019
and you see that the little icon changed.

00:28:54.019 --> 00:28:57.650
Okay, so that's it; we have version
models, now let's create the mapping model.

00:28:57.650 --> 00:29:08.980
Go to file menu, new file, the design category,
mapping model...let's call this from old to new;

00:29:08.980 --> 00:29:20.099
it asks me for a source and destination models; that's my
source; that's my destination; here we have a mapping model.

00:29:20.099 --> 00:29:24.399
The wizard tried to be smart and...part your model

00:29:24.400 --> 00:29:28.360
and tried to create a partial mapping
model for you to continue editing.

00:29:28.359 --> 00:29:36.089
So it recognized, by the way the editor has the entity
mappings area, the property mappings area, the detail area,

00:29:36.089 --> 00:29:44.480
even a short dipping view so you can see the differences
between your source entities and your destination entities.

00:29:45.829 --> 00:29:51.369
So it created a mapping for us to migrate persons
to persons but we don't need that in this case

00:29:51.369 --> 00:29:56.099
because person is an abstract entity in our new model.

00:29:56.099 --> 00:30:02.139
It created a mapping to migrate addresses to
addresses with the property level mapping, that's fine.

00:30:02.140 --> 00:30:07.790
We don't really have city or residence in our
new destination so we can just leave those out;

00:30:07.789 --> 00:30:12.559
actually we do have residence but I'm going to
deal with that in the inverse relationships side.

00:30:12.559 --> 00:30:16.669
So if I leave a mapping out we just use the
default value that's defining your model.

00:30:16.670 --> 00:30:18.789
So here's the interesting ones.

00:30:18.789 --> 00:30:21.059
How do we create adults?

00:30:21.059 --> 00:30:22.980
We fetch them from person.

00:30:22.980 --> 00:30:25.740
How do we filter them?

00:30:25.740 --> 00:30:34.039
We only fetch the ones whose age is greater than or equal
to 18, right, and that's our mapping for creating adults

00:30:34.039 --> 00:30:37.990
and we're going to get rid of company name
because we really don't have company names yet.

00:30:37.990 --> 00:30:49.480
The same for child, the source entity for a child mapping is
person and the filter is age is less than 18 and we get rid

00:30:49.480 --> 00:30:55.059
of the school name mapping which the wizard
tried to be smart about; so here we are.

00:30:55.059 --> 00:31:04.299
We have 3 mappings migrating addresses, creating children,
creating adults; you'll note that we have the mapping

00:31:04.299 --> 00:31:14.269
for the relationship; here's that scary function which you
can type if you're a masochist or use our fancy UI here

00:31:14.269 --> 00:31:18.920
where you give us a key path that you want to navigate
and the name of the mapping that you want us to use

00:31:18.920 --> 00:31:21.740
to do the translation over to the destination.

00:31:21.740 --> 00:31:27.730
So we've got everything we want now; we have a mapping
model, version models, we launched the application.

00:31:27.730 --> 00:31:44.380
We launched the application side...so here's our
old data...we open our store...and we have adults

00:31:44.380 --> 00:31:47.930
and children and that's migration.

00:31:47.930 --> 00:31:54.570
( Applause )

00:31:54.569 --> 00:31:56.470
So back to slides please.

00:31:56.470 --> 00:32:00.690
I'd like to bring Ron up to finish up the talk.

00:32:00.690 --> 00:32:03.970
( Pause )

00:32:03.970 --> 00:32:06.190
>>Thanks Miguel.

00:32:06.190 --> 00:32:12.680
My name is Ron LuSang and I'm an engineer on the core
data team and I'll be your host for the rest of the hour.

00:32:12.680 --> 00:32:20.820
So let's see...so migration is a big topic and
instead of going over every piece of API that we have

00:32:20.819 --> 00:32:27.559
for the migration process I'm just going to
go over some the big concepts to make sure

00:32:27.559 --> 00:32:34.190
that you guys feel comfortable working with the classes
later on and navigating the documentation, asking questions.

00:32:34.190 --> 00:32:43.059
Let's start off with versioning; so we assume that you
figured out versioning; you've mastered creating versions

00:32:43.059 --> 00:32:49.409
of your managed object model and you have a store that you
want to migrate forward and you've also figured out how

00:32:49.410 --> 00:32:54.070
to do mapping between the different
stores; the different models.

00:32:54.069 --> 00:33:00.980
So I'll focus mostly on how the migration model drives
everything that happens in the migration classes

00:33:00.980 --> 00:33:06.730
and I'll focus on 2 classes in
particular; first the migration manager.

00:33:06.730 --> 00:33:11.569
So the NS migration manager is really the heart
of the migration process and we saw earlier

00:33:11.569 --> 00:33:14.779
that we have all these other things
around the migration manager.

00:33:14.779 --> 00:33:22.799
It manages the source and destination stacks and all of
the entity mapping in your mapping model and we touch on it

00:33:22.799 --> 00:33:30.990
as well that it keeps track of these per-entity mapping
association tables that let you go from the source

00:33:30.990 --> 00:33:37.000
and destination objects, figure out given some
destination object what source object was it created from.

00:33:37.000 --> 00:33:42.740
Okay, so there's a lot of stuff that goes on
around the migration manager and it's the heart

00:33:42.740 --> 00:33:45.839
of the migration process for that reason.

00:33:45.839 --> 00:33:49.759
So the other class that I want to talk about
is if the migration manger is the heart

00:33:49.759 --> 00:33:55.799
of migration then NS entity migration
policy is kind of the limbs of migration

00:33:55.799 --> 00:33:59.869
that actually does the hard work in each of the 3 stages.

00:33:59.869 --> 00:34:08.849
The entity mappings in you mapping model each have
a migration policy object attached to it and in each

00:34:08.849 --> 00:34:16.619
of the 3 stages, instance creation, relationship
creation, and validation, it's the policy objects on each

00:34:16.619 --> 00:34:19.139
of those mappings that does the real work.

00:34:20.179 --> 00:34:25.839
I'm going to talk about each of these stages but first I
want to make sure that you realize where migrating your data

00:34:25.840 --> 00:34:32.980
in all of these stages; it's not necessarily the
behavior in you custom managed object subclasses;

00:34:32.980 --> 00:34:40.530
so in the runtime we only use manage objects to
hold all the data during the migration process.

00:34:40.530 --> 00:34:45.720
This greatly simplifies everything since we don't have
to keep multiple different versions of the same classes

00:34:45.719 --> 00:34:54.149
and the runtime it wants but we do have a validation step
so the custom logic that you would normally have called

00:34:54.150 --> 00:34:59.050
in your custom managed object subclasses
does have a place to live.

00:34:59.050 --> 00:35:05.720
You can move that into a different area and
we'll talk about that when I say, "Limbago."

00:35:05.719 --> 00:35:08.009
We'll see that in stage 3.

00:35:09.179 --> 00:35:16.389
So, first we'll look at how the migration
policy works in stage one, instance creation.

00:35:16.389 --> 00:35:22.809
So as you saw stage one is really about copying over
the objects wholesale from the source of the destination

00:35:22.809 --> 00:35:30.509
and the basic implementation of the migration policy is
to just expect one source instance to be handed to it

00:35:30.510 --> 00:35:38.610
and then it'll create a blank managed object in the
destination context, will copy over all the attribute values

00:35:38.610 --> 00:35:45.490
and then the important bit is associating that
destination object with the source object we were handed.

00:35:45.489 --> 00:35:50.689
So one to one mapping from source to destination;
that's great for a lot of common cases

00:35:50.690 --> 00:35:56.329
but you can imagine many other cases where you might want
maybe more destination objects than you started out with

00:35:56.329 --> 00:36:04.710
for source objects; so imagine having one large record
that had person information as well as multiple copies

00:36:04.710 --> 00:36:09.980
of different phone number records or something
like that and you want to migrate it to a new model

00:36:09.980 --> 00:36:17.340
where you have different instances for each
record that you might have had for a phone number.

00:36:17.340 --> 00:36:23.960
So that's creating multiple destination instances for
source instance; you might want to do the opposite

00:36:23.960 --> 00:36:27.250
which we also talked about for normalizing your data.

00:36:27.250 --> 00:36:32.860
Now imagine as we saw earlier you have child
and adult and each one has an attribute

00:36:32.860 --> 00:36:36.750
for respectively school name and company name.

00:36:36.750 --> 00:36:43.869
Now if you had 100 child objects you'd have school
name replicated a hundred times; big waste of space;

00:36:43.869 --> 00:36:51.130
so we move towards using a relationship
between school and child and company and adult.

00:36:51.130 --> 00:36:57.019
During migration we want to make sure
that we migrate over all of the 100 kids

00:36:57.019 --> 00:37:02.900
but we don't create 100 pretty much
identical school objects for the migration.

00:37:02.900 --> 00:37:12.730
So to put in logic like this we implement
this method in our custom migration policy.

00:37:12.730 --> 00:37:17.960
Create destination instances for source instance
entity mapping manager error, which is a long method

00:37:17.960 --> 00:37:23.610
but the important pieces that there are 3
arguments that you have to pay attention to.

00:37:23.610 --> 00:37:29.800
The source instance entity, mapping, and the migration
manager are there so that you can do your work

00:37:29.800 --> 00:37:38.570
in this method for you policy and that work is simply
to create as many destination instances as is necessary,

00:37:38.570 --> 00:37:46.400
populate the attributes of that new instance
and then important, go to the migration manager

00:37:46.400 --> 00:37:57.700
and associate the destination instances you've
created with the source instance you were handed.

00:37:57.699 --> 00:37:58.210
( Pause )

00:37:58.210 --> 00:38:05.490
So now we've gone through and we've created all of the
objects in our destination, the migration manager has gone

00:38:05.489 --> 00:38:08.559
through every entity mapping in our mapping model,

00:38:08.559 --> 00:38:14.779
given each of the entity mappings policy objects
a chance to create these destination instances.

00:38:14.780 --> 00:38:21.769
We have a big soup of objects with no
relationships so now we start stage 2.

00:38:21.769 --> 00:38:30.199
We saw by default what the migration policy tries to do; it
goes through these association tables that the manager keeps

00:38:30.199 --> 00:38:34.739
for us and this is where I say
limbago; this is the important piece;

00:38:34.739 --> 00:38:42.809
this is why during the instance creation phase it's
important to associate our destination and source instances;

00:38:42.809 --> 00:38:49.230
otherwise we can't...we might have a
hard time actually, not that we can't.

00:38:49.230 --> 00:38:55.110
This is the easiest way to figure out which
destination object should be related together.

00:38:55.110 --> 00:38:59.260
So you can do something other than
going through the association tables;

00:38:59.260 --> 00:39:04.270
you could imagine having some custom logic that
figures, "Well there's an adult and there's a child

00:39:04.269 --> 00:39:08.030
and they show the same address, they
might even show the same last name,

00:39:08.030 --> 00:39:14.670
let's assume that they're related,
like Miguel is Ovie's papa, of course.

00:39:14.670 --> 00:39:19.920
That's not something you could get directly from the
association tables but you could put custom logic

00:39:19.920 --> 00:39:23.869
in your migration policy subclass in this method,

00:39:23.869 --> 00:39:29.500
create relationships for destination
instances and see mapping manager error.

00:39:29.500 --> 00:39:33.639
Yet another long method that gives you 3 arguments.

00:39:33.639 --> 00:39:39.029
The important thing is the destination instance
for which you're suppose to create relationships

00:39:39.030 --> 00:39:44.080
and then you can leverage the entity mapping
and the migration manager to figure out,

00:39:44.079 --> 00:39:51.860
"Well which instances were created from the
source instances related to the source object

00:39:51.860 --> 00:39:54.900
that we got from this destination instance."

00:39:54.900 --> 00:40:03.550
So, again you'll end up using the migration managers
association methods a lot here...and once you figured

00:40:03.550 --> 00:40:11.080
out which objects need to be related in the destination
context you relate them just using regular key value coding

00:40:11.079 --> 00:40:19.039
or setting the relationships for
regular managed objects, right.

00:40:19.039 --> 00:40:26.659
Okay, so now we've gone through all of our entity mappings
twice giving each entity mappings policy objects a chance

00:40:26.659 --> 00:40:33.129
to create instances and now relate
objects and we save again.

00:40:33.130 --> 00:40:39.900
So now in our destination store we have all of our
objects copied over; they're all related together;

00:40:39.900 --> 00:40:44.440
now we should run validation on it
to make sure all the data is correct.

00:40:46.329 --> 00:40:51.719
The base implementation for the migration
policy does something very simple.

00:40:51.719 --> 00:41:02.779
It looks at the destination model and re-enables all of the
validation rules that were set on all of your properties;

00:41:02.780 --> 00:41:09.440
so here you can see for person the name attribute its
non-optional, it has a minimum and a maximum length;

00:41:09.440 --> 00:41:15.809
so we would use this to validate all of the person
objects that were created in our destination context.

00:41:15.809 --> 00:41:24.440
You can do something special and augment this behavior
by implementing in you custom policy the method,

00:41:24.440 --> 00:41:27.869
"Perform custom validation for
entity mapping manager error."

00:41:27.869 --> 00:41:34.690
Here you'll notice you're only handed 2 pieces of
information, the entity mapping and the manager itself;

00:41:34.690 --> 00:41:43.010
it's up to you to fetch or find any objects in the
destination context that you feel you need to validate;

00:41:43.010 --> 00:41:52.430
so this gets called only once for this stage on your
custom policy...and in this case you're probably going

00:41:52.429 --> 00:42:01.029
to call super so that you can get any custom
rules from your object model validated

00:42:01.030 --> 00:42:04.130
to be used to validate your destination objects.

00:42:04.130 --> 00:42:11.150
And at this point we save, we have all of our
objects copied over to the destination context,

00:42:11.150 --> 00:42:18.210
all of the relationships are set up, we've validated them
and we have a new context, a new store that we can load

00:42:18.210 --> 00:42:23.619
and using the destination model we're ready to go.

00:42:23.619 --> 00:42:26.319
So let's recap.

00:42:26.320 --> 00:42:31.660
Again the heart of the migration process is the
migration manager and it's the one that drives everything

00:42:31.659 --> 00:42:41.210
into 3 stages during migration using the mapping models,
the entity mapping to configure each of the policies

00:42:41.210 --> 00:42:47.949
and the policy objects are the ones that do the work
and if you want to customize anything that's the place

00:42:47.949 --> 00:42:54.179
where you're probably going to want to
start, is by sub-classing the policy.

00:42:54.179 --> 00:42:59.779
But before you can actually perform the
migration you have to configure the migration;

00:42:59.780 --> 00:43:03.769
really configuring the migration manager.

00:43:03.769 --> 00:43:09.320
Now as we saw there's a lot of stuff that needs
to go into the migration, the manager keeps track

00:43:09.320 --> 00:43:17.769
of all these different things; they come from somewhere
and that's what configuration of the manager requires.

00:43:17.769 --> 00:43:24.070
There are 2 ways to configure the migration manager; you
can either let Core Data handle everything starting off

00:43:24.070 --> 00:43:29.950
and just letting Core Data figure it out or you as the
developer can look through your application bundle,

00:43:29.949 --> 00:43:33.869
you can figure out whatever you need
to, to configure the migration manager.

00:43:33.869 --> 00:43:38.940
The important point here is that in both cases
whether you do it or you let Core Data figure things

00:43:38.940 --> 00:43:42.260
out the migration that happens will be the same, right.

00:43:42.260 --> 00:43:47.960
The process that we just talked about, the 3 stages,
everything about the policy, the migration manager,

00:43:47.960 --> 00:43:53.970
all of that is the same it's just a matter
of who sets up the migration manager.

00:43:53.969 --> 00:43:59.579
So first let's take a look at what happens
when we let Core Data figure things out.

00:44:01.550 --> 00:44:08.130
If we let Core Data configure the manager this is what
we call automatic migration or automatic boot strapping

00:44:08.130 --> 00:44:15.400
and this happens when you load a store in your persistent
store coordinator and it happens because you asked for it

00:44:15.400 --> 00:44:22.000
and we saw this earlier where you add a persistent
store with type and you add this option to say, "Yes,

00:44:22.000 --> 00:44:26.190
if there's any version skewed, please try
and migrate everything automatically."

00:44:26.190 --> 00:44:36.519
In this case you've handed the persistent store coordinator,
you've handed Core Data a managed object model and a store

00:44:36.519 --> 00:44:44.110
to try to load; those end up being the destination
model we'll use when we create our migration manager

00:44:44.110 --> 00:44:48.519
and the source store that we're going to migrate from.

00:44:48.519 --> 00:44:54.690
So that's 2 pieces of the picture that we've already figured
out for when we're configuring the migration manager.

00:44:54.690 --> 00:45:01.789
From there Core Data can figure out, "Well we'll look
in the applications resources, try and find a model,

00:45:01.789 --> 00:45:09.219
an object model, whose version information matches
the version information for our source store."

00:45:09.219 --> 00:45:19.429
Once we find one of those we can start looking for a mapping
model in you applications resources that defines a migration

00:45:19.429 --> 00:45:24.099
between the source and the destination
models that we've already found.

00:45:24.099 --> 00:45:29.049
Once we've found that we figured out just about
everything we need in order to start the migration;

00:45:29.050 --> 00:45:36.310
the last piece is where should we migrate the data to...and
that's simply a matter of appending something to the URL

00:45:36.309 --> 00:45:39.099
for the source store that you've already given us.

00:45:39.099 --> 00:45:45.309
So there you can see that there's not a whole lot of magic
here; it's just doing what would probably be done by all

00:45:45.309 --> 00:45:53.320
of you automatically but if you want to do things
yourself, if you want to do something differently,

00:45:53.320 --> 00:45:57.610
you can use the same API that we're
using to do the automatic migration.

00:45:57.610 --> 00:46:06.099
You could read the models off of disk; you could read them
off the internet; you could create the models at runtime,

00:46:06.099 --> 00:46:12.130
make them up, not read them from disk at all and
the only thing you have to do is manage the manager,

00:46:12.130 --> 00:46:19.809
like you alloc in at the manager, set the
source and destination models and push the button

00:46:19.809 --> 00:46:24.449
that says migrate using this mapping
model from this URL to this URL.

00:46:24.449 --> 00:46:30.879
It's not anything special that goes
on there; it's all public API...and

00:46:32.690 --> 00:46:39.510
so from there let me show you a demo of
what you can do with a custom policy.

00:46:39.510 --> 00:46:41.310
( Pause )

00:46:41.309 --> 00:46:50.269
We'll bring up version 5 of our application
starting first with version 4 of our model.

00:46:50.269 --> 00:46:57.360
You can see we already have a version model here...where we
started off with the inheritance based version of our model,

00:46:57.360 --> 00:47:04.190
right; adult and child, school name as an
attribute, company name as an attribute.

00:47:04.190 --> 00:47:13.950
Version 5 of our model...we end up breaking out the
company and the school into separate entities, fine.

00:47:15.190 --> 00:47:26.769
Here we have our mapping model; so we're just moving over
addresses wholesale; we're not doing anything special there.

00:47:26.769 --> 00:47:35.300
So state becomes state, source, street becomes the
destination street and for companies though we're going

00:47:35.300 --> 00:47:40.080
to break out the company name into a separate entity
so we need to read that information from somewhere.

00:47:40.079 --> 00:47:53.539
We get that from the adult that we're migrating
over...but here you'll see...we've set a custom policy,

00:47:53.539 --> 00:48:05.119
we named it my migration policy and yea, we'll see how that
works in a second and finally when we migrate the adults

00:48:05.119 --> 00:48:14.819
over to the destination stack...we've set up relationship
mappings here so we just copy the address over wholesale

00:48:14.820 --> 00:48:19.800
from the adult in the source; the age
is the same thing, copy over the age

00:48:19.800 --> 00:48:26.870
and the name...and then here the company
we look at the adult to company mapping;

00:48:26.869 --> 00:48:34.710
so we're expecting that companies will be created in
this mapping which is where we set our custom policy

00:48:34.710 --> 00:48:40.690
and if we look at our document real quick you'll see we've
already done the work to trigger the automatic migration;

00:48:40.690 --> 00:48:47.710
I've decided not to do any of the work myself and
here we've defined our custom migration policy;

00:48:47.710 --> 00:48:55.389
here see it's just a subclass of entity
migration policy...and we've overridden 2 methods;

00:48:55.389 --> 00:49:02.049
for stage one of the migration, instance creation,
we've overridden the create destination instances method

00:49:02.050 --> 00:49:06.980
and we're handed enough information that we can figure
out, "Well here's the destination context from the manager;

00:49:06.980 --> 00:49:12.530
We know which entity we're going to create;
we get that from the mapping that we're handed;

00:49:12.530 --> 00:49:19.310
we can read the company name out of the instance that
we're handed; the adult object that we're handed here

00:49:19.309 --> 00:49:25.170
and we go off to the migration manager
which has a user info dictionary.

00:49:25.170 --> 00:49:31.750
We'll lazily create this user info dictionary because
we're going to stick our own mapping of which,

00:49:31.750 --> 00:49:39.920
it's kind of a cash of which companies we've already
created by name, so we go...once we find that user info,

00:49:39.920 --> 00:49:48.200
if it already exists, then we can look at the dictionary, at
another dictionary and see, did we already create a company

00:49:48.199 --> 00:49:52.609
with this name; so that's what we do here.

00:49:52.610 --> 00:49:58.150
If we haven't created a company with this
name or at least we didn't catch one, right,

00:49:58.150 --> 00:50:06.139
we go in and we create a new managed object, blank, generic
NS managed object, we set the company name setting all

00:50:06.139 --> 00:50:09.309
of the attributes that we care about for the migration.

00:50:09.309 --> 00:50:12.179
We can do something special here; we see,

00:50:12.179 --> 00:50:17.859
well if the company name is Apple then we know
what their business is; I might have missed that.

00:50:17.860 --> 00:50:26.800
In version 5 of our model companies have a business as a
string and their default value, all businesses make stuff

00:50:26.800 --> 00:50:33.660
but we know in the case of Apple we make phones,
right and feel free to log anything you like.

00:50:33.659 --> 00:50:45.799
We auto release the instance because we're about
to set it in our...yes in our association table 2

00:50:45.800 --> 00:50:54.400
but in our unique look up map, right, that we keep on the
user info on the manager...and then here's that last step

00:50:54.400 --> 00:51:01.950
for the creation...creating instances, we associate the
source and destination instances using this mapping.

00:51:01.949 --> 00:51:07.449
So you'll notice that we do this even if
we already had a company with this name.

00:51:07.449 --> 00:51:12.399
We didn't create any new companies but we're still
interested in making sure that we can get back

00:51:12.400 --> 00:51:20.889
from whatever company we've created to any source object
that would make sense for that company that matches;

00:51:20.889 --> 00:51:25.949
so this is what we'll use for creating
relationships later in this method.

00:51:25.949 --> 00:51:32.139
Well actually this method doesn't do anything
because...we've already set up a relationship mapping

00:51:32.139 --> 00:51:37.129
in our entity mapping; so this is
something you can take advantage of.

00:51:37.130 --> 00:51:47.920
Remember that we have inverse relationships
modeled in our model between company and adult

00:51:47.920 --> 00:51:56.860
and we've set a relationship mapping so that every company
knows its adults, which adults, all of its employees rather;

00:51:56.860 --> 00:52:00.780
so you don't have to do both sides
of handling the relationship mapping;

00:52:00.780 --> 00:52:06.030
we've already dealt with this in
our generic entity mapping here.

00:52:06.030 --> 00:52:17.680
We can sort of skip this part...Okay,
so I'm going to run this

00:52:17.679 --> 00:52:21.089
( Pause )

00:52:21.090 --> 00:52:30.160
here's our UI for Peoplizer 5;
well open up documents...let's choose

00:52:31.469 --> 00:52:34.169
that one...good; so here we've created companies.

00:52:34.170 --> 00:52:37.789
You can see this is our list of companies;
these are all the companies we have.

00:52:37.789 --> 00:52:38.800
The Banana Inc.

00:52:38.800 --> 00:52:46.240
makes stuff; Apple makes phones; Ron's employed
at Apple; Miguel is a Banana...no he works

00:52:46.239 --> 00:52:50.519
at Apple too; so the whole thing just works.

00:52:50.519 --> 00:52:52.159
One thing that I didn't show you;

00:52:52.159 --> 00:52:55.609
( Pause )

00:52:55.610 --> 00:53:02.700
if you take a look at arguments that we've passed
to executable you can actually log some information

00:53:02.699 --> 00:53:05.480
about what happens during the migration process.

00:53:05.480 --> 00:53:08.630
We take a look at that...cool, okay.

00:53:08.630 --> 00:53:15.320
So we saw, we were looking for a mapping model with this
hash information, these version hashes; okay we found one;

00:53:15.320 --> 00:53:24.830
this is the one we're going to use and here are the
source hashes...cool...and...and here' s our log

00:53:24.829 --> 00:53:27.210
of what we were doing in our custom policy.

00:53:27.210 --> 00:53:31.090
So it's a good way to keep track of what's
going on during the migration process.

00:53:31.090 --> 00:53:32.010
We'll go back to slides now.

00:53:32.010 --> 00:53:33.180
( Pause )

00:53:33.179 --> 00:53:43.519
Actually I think that's it; we have only one more slide.

00:53:43.519 --> 00:53:49.469
Tips and tricks; so we touched on a bunch
of these; one thing we didn't mention is

00:53:49.469 --> 00:53:56.629
that when you're doing the migration remember that if
there's already a file there, the migration process appends

00:53:56.630 --> 00:54:06.500
to that file; so we don't just want to delete files out from
under you; I hope that's okay; we just append to it...and

00:54:06.500 --> 00:54:12.630
as I mentioned try and take advantage of the fact
that you've modeled your relationships with inverses.

00:54:12.630 --> 00:54:16.230
I mean, you did model all of your
relationships with inverse, right;

00:54:16.230 --> 00:54:22.590
we keep telling you that...and this is good
reason to try that because this way you don't have

00:54:22.590 --> 00:54:30.490
to setup relationship mappings from both sides; you can let
Core Data do the inverse relationship management for you

00:54:30.489 --> 00:54:35.059
and just choose whichever relationship
mapping is easier to define.

00:54:35.059 --> 00:54:35.619
( Pause )

00:54:35.619 --> 00:54:46.449
And it says it here, for large object graphs
try doing the migration in multiple passes;

00:54:46.449 --> 00:54:54.369
what I mean by that is imagine you have a bazillion, just
to choose a number, person objects that you need to migrate;

00:54:54.369 --> 00:55:02.769
you could fetch all the people whose names start
with A first, perform a migration, nuke the contexts

00:55:02.769 --> 00:55:12.019
and then progress to B, C, D; this way you're using,
you're chewing up a lot less memory during the migration;

00:55:12.019 --> 00:55:17.139
it's much nicer to your user that way and you can
even put up a progress bar or something like that.

00:55:17.139 --> 00:55:26.549
The migration manager gives you API for figuring out
what stage of the migration you're in and the last tip,

00:55:26.550 --> 00:55:33.110
remember if you already have an application that's shipping
on Tiger some of your users coming to version 2 or version 3

00:55:33.110 --> 00:55:39.610
of your application will have store files that
don't have any version information in them.

00:55:39.610 --> 00:55:43.890
It's up to you at that point to look at
the store file, check out the metadata,

00:55:43.889 --> 00:55:54.429
maybe map it to a specific file number and
then...and then perform migration yourself there.

00:55:54.429 --> 00:55:55.739
Okay, that's all I have.

00:55:55.739 --> 00:56:00.339
For more information you can check with
Deric; there's lots of sample code;

00:56:00.340 --> 00:56:03.840
you can come by and ask questions in the Core Data lab.
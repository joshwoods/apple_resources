WEBVTT

00:00:13.179 --> 00:00:15.689
>> So, hello everybody.

00:00:15.689 --> 00:00:20.269
I am really happy to see so many
people showed up on Friday at 5 p.m.

00:00:20.269 --> 00:00:24.230
for Improving User Experience With
Effective Power Management.

00:00:24.230 --> 00:00:28.010
My name is Ethan Bold,
and I come from the Core OS team.

00:00:28.010 --> 00:00:30.750
I work on the I/O Kit Driver framework.

00:00:30.750 --> 00:00:37.170
And I am going to be speaking with
Dave Ferguson from the USB team.

00:00:37.170 --> 00:00:44.590
He's going to come on stage after me in a little bit
to talk about how the USB team has implemented a lot

00:00:44.590 --> 00:00:48.000
of power management technology in Leopard.

00:00:48.000 --> 00:00:54.230
So today I want to talk to you about first
off a couple of new things in Leopard.

00:00:54.229 --> 00:01:04.289
We have a new chapter on managing power and the I/O Kit
Fundamentals book, which is available as a PDF today.

00:01:04.290 --> 00:01:12.640
We've got a new power management implementation in the
kernel, and then we're going to discuss for a few slides how

00:01:12.640 --> 00:01:17.219
to implement a power managed device driver in the kernel.

00:01:17.219 --> 00:01:25.150
And then we'll finish up with a little
bit of user space API for interacting

00:01:25.150 --> 00:01:29.310
with power management in your user space application.

00:01:30.439 --> 00:01:38.950
So why should you as a device driver developer
worry about managing power in your device?

00:01:38.950 --> 00:01:43.049
One thing -- one reason is battery life.

00:01:43.049 --> 00:01:50.189
When you save a milliwatt or a watt of
power in your device you're saving minutes

00:01:50.189 --> 00:01:53.109
or dozens of minutes of battery life for your developers.

00:01:53.109 --> 00:02:00.650
These numbers up on screen are approximate, they're really
just estimates, and obviously these numbers would vary

00:02:00.650 --> 00:02:05.920
by system and by your usage environment.

00:02:05.920 --> 00:02:13.939
But for example, we do save 15 to 20 minutes of battery life
just by turning off the audio hardware when your MacBook

00:02:13.939 --> 00:02:16.599
or PowerBook isn't actively playing any audio.

00:02:16.599 --> 00:02:19.379
The same goes for the battery.

00:02:19.379 --> 00:02:25.530
I am sure everyone who's used a MacBook
or a PowerBook has seen the display dim

00:02:25.530 --> 00:02:29.509
after a few minutes of not using the keyboard or mouse.

00:02:30.729 --> 00:02:39.419
And finally we save tons of battery life by
powering down the CPU when it's not in use.

00:02:39.419 --> 00:02:46.519
That happens totally automatically
on all of your computers out there.

00:02:46.520 --> 00:02:54.500
And we save, I mean, at least 30 or 40 minutes0, sometimes
up into an hour or an hour-and-a-half of battery life

00:02:54.500 --> 00:03:01.319
by automatically consuming -- I'm sorry
-- automatically preserving CPU power.

00:03:01.319 --> 00:03:06.989
Another thing to note is that when you save power
for your users, you are not only saving battery life,

00:03:06.990 --> 00:03:11.480
you're generating less heat that
means a cooler MacBook on their lap,

00:03:11.479 --> 00:03:15.939
and it means that the fans are
going to stay quiet a lot longer.

00:03:17.729 --> 00:03:26.769
Now I want to point out that this is the -- the interface
that most of your users have with power management.

00:03:26.770 --> 00:03:33.090
You'll notice that I talked about the audio
driver and the CPU driver on the previous slide.

00:03:33.090 --> 00:03:36.599
And neither of those drivers is here.

00:03:36.599 --> 00:03:38.560
There aren't user settings for that.

00:03:38.560 --> 00:03:47.270
It is that they're drivers and their software is smart
enough to realize when their hardware isn't actively in use.

00:03:47.270 --> 00:03:54.890
And that's what -- what all of your device
drivers and all of your software can do as well.

00:03:56.909 --> 00:04:03.180
So the first thing I want to point
out is we have a brand new rewrite

00:04:03.180 --> 00:04:07.719
of the Managing Power chapter in I/O Kit Fundamentals.

00:04:07.719 --> 00:04:11.460
I/O Kit Fundamentals is our I/O kit book.

00:04:11.460 --> 00:04:13.420
It's available as a PDF.

00:04:13.419 --> 00:04:21.579
And this new chapter we have is -- is very
informative - it's got some great documentation

00:04:21.579 --> 00:04:29.339
about using power management APIs
in the kernel and in device drivers.

00:04:29.339 --> 00:04:36.099
So it's available at the WWDC page for this session.

00:04:36.100 --> 00:04:38.460
And it's available today.

00:04:40.220 --> 00:04:49.770
So we have made some pretty significant changes to
power management in the OS X kernel, in Leopard.

00:04:49.769 --> 00:04:58.879
Some of the things that drove those changes leading up
to Leopard were that it hasn't been a very convenient

00:04:58.879 --> 00:05:05.149
or easy environment for developers to write drivers to.

00:05:05.149 --> 00:05:14.870
There were a lot of issues with OS X's threading model
and locking model that were difficult to interact with.

00:05:14.870 --> 00:05:17.340
And the APIs were vague.

00:05:17.339 --> 00:05:21.269
Sometimes a call was synchronous,
sometimes a call was asynchronous,

00:05:21.269 --> 00:05:29.099
and it was very hard to -- to really
account for all of that.

00:05:29.100 --> 00:05:34.110
So in Leopard we fixed a lot of those things.

00:05:34.110 --> 00:05:40.840
First off, we eliminated the issue of the
ambiguous behavior by defining and documenting all

00:05:40.839 --> 00:05:44.079
of those in-kernel power management calls.

00:05:44.079 --> 00:05:49.430
And we introduced a new chapter --
that new chapter I just talked about,

00:05:49.430 --> 00:05:53.519
the Managing Power chapter in I/O Kit Fundamentals.

00:05:53.519 --> 00:06:01.599
But we also improved our locking and threading model,
and we made all calls into power management asynchronous,

00:06:01.600 --> 00:06:09.970
which provides a much more -- a much more consistent
interface for anyone writing a driver with power management.

00:06:11.790 --> 00:06:19.800
So -- so if you are beginning to implement power
management in your own driver, the first thing you need

00:06:19.800 --> 00:06:27.990
to do is consider what level of support your
I/O kit family provides for you automatically.

00:06:27.990 --> 00:06:37.269
For certain families like USB and networking and FireWire,
and mass storage, those families provide quite a bit

00:06:37.269 --> 00:06:40.419
of built-in support for power management.

00:06:40.420 --> 00:06:50.280
And your driver as a sub class of those needs to know how
to interact with the support built into the super class.

00:06:50.279 --> 00:06:58.869
Other drivers don't provide as much or
any built-in power management support.

00:06:58.870 --> 00:07:03.590
Those are drivers like PCI or audio.

00:07:03.589 --> 00:07:15.849
And when I say, does your family provide built-in
power management support -- I mean that --

00:07:15.850 --> 00:07:22.180
I/O service provides a base level of APIs that we're
about to discuss and go through on the next few slides.

00:07:22.180 --> 00:07:31.519
But some of these other families provide other APIs that
you would use instead of or in addition to those basic APIs.

00:07:33.000 --> 00:07:37.259
So I want to go over the I/O power plan.

00:07:37.259 --> 00:07:49.349
This is the basic data structure that OS X uses to
track the power dependencies of devices in the system.

00:07:49.350 --> 00:07:57.120
And it's this data structure that OS X uses to determine
what order to put all of the hardware in your system

00:07:57.120 --> 00:08:04.610
to sleep when you close your laptop and put your
machine to sleep, and what order to power those devices

00:08:04.610 --> 00:08:08.250
on in order to wake the machine from sleep.

00:08:08.250 --> 00:08:14.790
So the I/O power plan is a tree-like structure.

00:08:14.790 --> 00:08:19.490
At the root we have the -- a note
called IOP and root domain.

00:08:19.490 --> 00:08:23.420
And that's the parent of all the devices in the system.

00:08:23.420 --> 00:08:35.889
And throughout the rest of the tree we have
-- so elsewhere in the tree a -- any node --

00:08:37.549 --> 00:08:42.269
has its power dependencies as its parent.

00:08:42.269 --> 00:08:48.470
So if you were writing a driver for a USB
audio device, you would declare an audio --

00:08:48.470 --> 00:08:54.080
a power dependency on the USB bus above you.

00:08:54.080 --> 00:09:01.420
So your USB audio devices -- devices,
node's parent would be USB power.

00:09:01.419 --> 00:09:08.620
And this would let OS X know that when we're powering
the machine off for sleep, we should always power off

00:09:08.620 --> 00:09:17.909
that USB audio node first before we power off its
parent, because the USB audio device will probably need

00:09:17.909 --> 00:09:22.639
to communicate across that parent node's USB bus.

00:09:22.639 --> 00:09:27.769
And this -- this diagram shows
a sleep transition in progress.

00:09:27.769 --> 00:09:32.649
You can see some of the leaf nodes
are highlighted because we always --

00:09:32.649 --> 00:09:38.120
when we're putting a machine to sleep
we always turn off the leaf nodes first.

00:09:39.610 --> 00:09:50.120
So what I want to talk about now is the API calls
that your driver would use to interact with --

00:09:50.120 --> 00:09:56.909
with kernel power management, and how your driver
would insert itself into the I/O power plan here

00:09:56.909 --> 00:10:01.379
to be involved in system power management.

00:10:02.389 --> 00:10:08.860
So there are -- there are three calls that your driver
would need to make in its I/O service start routine

00:10:08.860 --> 00:10:11.639
to be involved in system power management.

00:10:11.639 --> 00:10:14.240
The first one is PM init.

00:10:14.240 --> 00:10:18.690
That initializes some basic power
management data structures.

00:10:18.690 --> 00:10:22.340
The second is join PM tree.

00:10:22.340 --> 00:10:28.879
And depending on the arguments that you pass and how
you call join PM tree, that is the call that's going

00:10:28.879 --> 00:10:33.570
to insert your driver into the I/O power plan.

00:10:33.570 --> 00:10:37.140
And the third call is register power driver.

00:10:37.139 --> 00:10:41.319
Register power driver is the call that you make

00:10:41.320 --> 00:10:48.060
to let the kernel power management know
what kind of power states you have.

00:10:48.059 --> 00:10:54.039
You can offer -- usually just an on state
or an off state for a very simple driver.

00:10:54.039 --> 00:10:58.659
And your device would be in the on state
when the system was awake and fully on.

00:10:58.659 --> 00:11:04.120
And then put your device in its off
state when we put the machine to sleep.

00:11:06.179 --> 00:11:13.359
So after you make those three set up calls, those PM
init, join PM tree, and register power driver,

00:11:13.360 --> 00:11:18.600
there is a couple of other calls you need to implement to --

00:11:18.600 --> 00:11:23.360
to be a part of power management
in a very passive, simple way.

00:11:23.360 --> 00:11:31.200
Now when I say passive, I mean if you were a
passively power managed driver then you are involved

00:11:31.200 --> 00:11:34.440
in system sleep and system wake.

00:11:34.440 --> 00:11:42.360
But you're not necessarily going out of your way
to actively power-manage your device, like the --

00:11:42.360 --> 00:11:46.500
the audio chip I talked about before, or the CPU.

00:11:46.500 --> 00:11:51.240
You're just simply involved in system sleep and system wake.

00:11:51.240 --> 00:11:57.240
And able to power down your hardware
and restore it safely away from sleep.

00:11:57.240 --> 00:12:07.539
So the next things your driver would have to do would be to
implement the I/O service virtual method, Set Power State.

00:12:07.539 --> 00:12:14.529
Set Power State is the -- it's the hook
that OS X uses to communicate into a driver

00:12:14.529 --> 00:12:18.370
to say, all right, it's your turn to turn off.

00:12:18.370 --> 00:12:20.950
To let the system go to sleep.

00:12:20.950 --> 00:12:26.000
Or it's your turn to power back
on when you're waking from sleep.

00:12:26.000 --> 00:12:34.240
And finally, you need to make one clean up
call, PM stop, in your driver stop routine.

00:12:34.240 --> 00:12:43.269
So just to -- to obtain a bare minimum of
interaction with system power management,

00:12:43.269 --> 00:12:53.779
you need to make those three initialization calls I just
discussed, and implement that one virtual I/O service method.

00:12:53.779 --> 00:12:56.389
And call PM stop.

00:12:56.389 --> 00:13:01.370
And again, if you'll remember that slide -- I showed it

00:13:01.370 --> 00:13:08.440
a couple of minutes ago -- about how certain families
already implement some forms of power management for you,

00:13:08.440 --> 00:13:13.900
this is a perfect example of you might not
need to make all these calls if you're, say,

00:13:13.899 --> 00:13:24.139
a USB driver or a FireWire driver, because your family
may already make some of these calls on your behalf.

00:13:24.139 --> 00:13:33.149
So next up I want to talk about how you can be more involved
in managing your own power and how you can contribute

00:13:33.149 --> 00:13:38.309
to power savings over the course of a running system.

00:13:38.309 --> 00:13:47.019
So -- so if your driver is actively involved
in power management it can turn off the --

00:13:47.019 --> 00:13:53.090
its hardware where the machine is going to sleep, and it
can turn that hardware back on when the system's waking up.

00:13:53.090 --> 00:14:00.730
But it may also have a more -- a more
sophisticated way to manage its power

00:14:00.730 --> 00:14:05.340
when the system is running, and the hardware isn't in use.

00:14:05.340 --> 00:14:15.480
So -- so I am going to go through some existing API that you
can use to add this kind of support to device drivers today

00:14:15.480 --> 00:14:27.100
and let OS X automatically notice when your hardware isn't
in use, and idle your devices into a lower power state.

00:14:27.100 --> 00:14:35.330
So the first thing we need to talk about is
-- is what power states your device offers.

00:14:35.330 --> 00:14:43.860
If you were writing a passive device driver
that was only involved in system sleep wake

00:14:43.860 --> 00:14:49.000
and didn't have any more advanced power states,
you might justify these two power states.

00:14:49.000 --> 00:14:50.509
On, and off.

00:14:50.509 --> 00:14:54.569
And when the machine was awake and
useable, your device would be on.

00:14:54.570 --> 00:14:59.660
And when the machine was off and
asleep, your device would be off.

00:15:01.549 --> 00:15:06.049
Now you're -- now maybe your device is more sophisticated.

00:15:06.049 --> 00:15:16.019
Maybe you have a -- a state that's a lot, maybe,
faster to transition into, and to transition out of

00:15:16.019 --> 00:15:21.840
than a full off state, and maybe you can transition
into this state while the system is running,

00:15:21.840 --> 00:15:25.870
but while your device isn't actively in use.

00:15:25.870 --> 00:15:33.529
This -- this power state array here
pretty accurately mirrors what the --

00:15:33.529 --> 00:15:38.990
the audio device's power state might
look like in any of your MacBook pros.

00:15:38.990 --> 00:15:44.279
Because when you're playing music or you're
playing sound, the device is fully on.

00:15:44.279 --> 00:15:52.610
But 20, 30 seconds later, when there's -- there's no sound
being played, the device can automatically transition itself

00:15:52.610 --> 00:15:57.600
into its low power state and can remain there until --

00:15:57.600 --> 00:16:04.090
until you play sound again, and then jump right back
up to it's on state to service that sound request.

00:16:04.090 --> 00:16:05.970
And you don't have to stop there.

00:16:05.970 --> 00:16:13.450
If you have a sophisticated device with several degrees
of power savings, you can always take advantage of as many

00:16:13.450 --> 00:16:17.220
of those as you want using this mechanism.

00:16:17.220 --> 00:16:20.850
This framework of power management.

00:16:22.570 --> 00:16:31.900
So -- so earlier I talked about five API calls you
would make to be involved in passive power management

00:16:31.899 --> 00:16:36.209
for your device, and there's really
just two more that you would --

00:16:36.210 --> 00:16:44.519
that you would need to use to be able to automatically
power your device down into a lower power state

00:16:44.519 --> 00:16:49.559
and then automatically back up when
your device needed to be used again.

00:16:49.559 --> 00:16:55.889
So with the call set idle timer period
and activity tickle, you can do just that.

00:16:55.889 --> 00:17:04.279
So by calling set idle timer period you
can let power management know how --

00:17:04.279 --> 00:17:09.859
how long you want your device to be idle
before being put into a reduced power state,

00:17:09.859 --> 00:17:14.639
so you could pass in 15 seconds,
or 30 seconds, or 2 minutes.

00:17:14.640 --> 00:17:25.970
And -- and then after 30 seconds of no
device activity, OS X would -- would --

00:17:25.970 --> 00:17:35.319
would call into your driver on that set power state routine
we talked about before, and would power your device down.

00:17:35.319 --> 00:17:43.299
So if your device had an on state, a low state and an
off state, after 30 seconds of not having any activity

00:17:43.299 --> 00:17:51.649
on your device, OS X would put you into your low state.

00:17:51.650 --> 00:17:59.250
So like I just said, the idle timer once
its elapsed will power your device down.

00:17:59.250 --> 00:18:07.589
Now, now of course OS X needs to somehow
know when your device isn't active.

00:18:07.589 --> 00:18:10.809
And that's what that activity tickle call was all about.

00:18:10.809 --> 00:18:17.799
The activity tickle call, you would
have to call that somewhere on a data

00:18:17.799 --> 00:18:22.129
or on a hardware access path in your device driver.

00:18:22.130 --> 00:18:25.630
So any time your driver accessed its own hardware,

00:18:25.630 --> 00:18:33.970
or any time a user space application triggered a
hardware request you'd want to call activity tickle.

00:18:36.750 --> 00:18:40.170
And one thing I haven't mentioned
is that you can use the call

00:18:40.170 --> 00:18:45.210
Change Power State to, to set
a minimum of idle power state.

00:18:45.210 --> 00:18:55.049
So if you had those on low and off states and you
wanted your device to idle down from on to low,

00:18:55.049 --> 00:19:02.549
but never to go lower than that, then you could use
Change Power State to, to set a floor at that low state.

00:19:02.549 --> 00:19:10.329
And again, that is documented, and you can read all about
it in the Managing Power chapter in I/O Kit fundamentals.

00:19:10.329 --> 00:19:11.659
Very proud of that chapter.

00:19:11.660 --> 00:19:13.390
You guys should really take a look.

00:19:13.390 --> 00:19:15.560
Very excited.

00:19:15.559 --> 00:19:20.639
So I also wanted to talk about kind
of switching gears a little bit.

00:19:20.640 --> 00:19:32.310
This is a new driver space API in Leopard
for -- for I/O Kit, or I/O service sub classes.

00:19:32.309 --> 00:19:40.639
This is a -- a shut down notification
that your driver can register for simply

00:19:40.640 --> 00:19:47.150
by implementing the I/O service
method, System Will Shut Down.

00:19:47.150 --> 00:19:56.120
And on system shut down or restart, at the very latest
stages of shut down and restart, OS X, the kernel,

00:19:56.119 --> 00:20:02.639
will call into your device with --
via that System Will Shut Down method

00:20:02.640 --> 00:20:09.410
with either the System Will Shut
Down, or System Will Restart argument.

00:20:09.410 --> 00:20:18.519
Now, we are implementing this in the same order
that we put -- that we put devices to sleep.

00:20:18.519 --> 00:20:31.529
So if you think back to that I/O power plan that I discussed
earlier, a USB device would be the first one to get this --

00:20:31.529 --> 00:20:37.170
this shut down notification even
earlier than its USB parent.

00:20:37.170 --> 00:20:44.450
And of course, I should mention that USB
has its own implementation of shut down

00:20:44.450 --> 00:20:49.240
and restart notifications that -- that layer on top of this.

00:20:49.240 --> 00:20:58.190
So this is a perfect example of -- of a -- an I/O
Kit family providing a different level of support

00:20:58.190 --> 00:21:01.600
for power management than the basic level.

00:21:01.599 --> 00:21:11.730
So if you were writing a USB driver, you can still get
this shutdown message, just through a different format.

00:21:11.730 --> 00:21:19.150
And I also want to mention that of the interesting
thing about running code at shutdown time,

00:21:19.150 --> 00:21:24.880
and this shutdown time is it's after
applications have all been killed,

00:21:24.880 --> 00:21:27.910
it's after all the file systems have been torn down.

00:21:27.910 --> 00:21:37.880
It's that any code you run here only -- only link
-- only makes your user shutdown take longer.

00:21:37.880 --> 00:21:48.730
So you can -- unfortunately it's pretty easy to add to a
bad user experience by running too much code at this time.

00:21:48.730 --> 00:21:54.690
And this replaces an older call, called
register priority sleep wake interest

00:21:54.690 --> 00:21:58.680
that had a few problems that made us replace it.

00:21:58.680 --> 00:22:09.490
The notifications were not ordered, so -- so for
instance, if you were a FireWire disk that needed to --

00:22:09.490 --> 00:22:21.579
to flush any unsafe buffers to a hard disk, then it's very
possible that the FireWire bus that your device is loaded

00:22:21.579 --> 00:22:27.919
on was already turned off, or had already received
it's shutdown notification and turned off.

00:22:27.920 --> 00:22:31.050
Thus making your disc completely inaccessible.

00:22:31.049 --> 00:22:33.909
So that's fixed by the new notification.

00:22:36.089 --> 00:22:42.449
And the old notifications were also single-threaded.

00:22:42.450 --> 00:22:48.170
So in Leopard we were able to run all
those shutdown notifications in parallel

00:22:48.170 --> 00:22:53.769
and make that important shutdown process even faster.

00:22:54.970 --> 00:22:57.970
So I want to switch gears.

00:22:57.970 --> 00:23:05.680
We've been talking about in kernel
device driver API for I/O Kit devices.

00:23:05.680 --> 00:23:13.350
And I want to jump up to user space and run through
a few really interesting user space power manager

00:23:13.349 --> 00:23:22.439
and APIs that can help your app more --
better interact with power management.

00:23:22.440 --> 00:23:31.180
And we're going to talk about how to schedule a
timed sleep wake shutdown power on or restart.

00:23:31.180 --> 00:23:37.400
How to listen for sleep wake notifications,
and how to prevent idle sleep

00:23:37.400 --> 00:23:43.990
or prevent displaced sleep very
easily with one line of code.

00:23:43.990 --> 00:23:47.529
Because before that's been a little complicated to do.

00:23:47.529 --> 00:23:49.960
So that's a fun new API.

00:23:51.009 --> 00:23:55.480
So first, I want to talk about I/O PM schedule power event.

00:23:55.480 --> 00:24:05.960
This is a queued interface that let's you
request a system wake up or sleep or shutdown.

00:24:05.960 --> 00:24:15.569
Say you could request a shutdown
on Friday night at 8 p.m. and --

00:24:15.569 --> 00:24:20.799
and then when that time came around
the system would -- would shutdown.

00:24:20.799 --> 00:24:25.029
You could also request a wake up Monday morning at 7 a.m..

00:24:25.029 --> 00:24:33.059
And the wake up Wednesday morning at
9 a.m. so it's a fairly simple API.

00:24:33.059 --> 00:24:38.099
But it's been available since 10.4 and it's pretty useful.

00:24:38.099 --> 00:24:46.409
Next, I -- I want to talk about the I/O
register for system power notification.

00:24:46.410 --> 00:24:52.050
This is the notification that you can use to --

00:24:52.049 --> 00:24:58.649
to simply get a notification when the system
goes to sleep, or when the system wakes up.

00:24:58.650 --> 00:25:05.160
I should point out that you do not get a
system shutdown notification through this API.

00:25:05.160 --> 00:25:09.500
That's kind of outside of the scope of this API.

00:25:09.500 --> 00:25:18.609
And yeah, so this API is only for getting
notified on system sleep, and on system wake.

00:25:18.609 --> 00:25:28.819
So there are a couple of arguments to this -- to
this function that you might be interested in

00:25:28.819 --> 00:25:32.829
Like KIO Message, Can System Sleep.

00:25:32.829 --> 00:25:39.529
KIO System Will Sleep, and KIO
Message, System Has Powered on.

00:25:39.529 --> 00:25:45.549
Your application would get a System
Will Sleep message before any

00:25:45.549 --> 00:25:49.480
of the hardware devices on the system have powered off.

00:25:49.480 --> 00:25:59.069
So your app would get this message and it would handle it,
and only when it was done, say, saving unsaved documents

00:25:59.069 --> 00:26:04.740
or saving drafts, if you're writing in a Text
Editor, or closing out openly network connections.

00:26:04.740 --> 00:26:07.779
Only after you're done doing that does OS X tear

00:26:07.779 --> 00:26:14.009
down the driver stack below it and
eventually put the machine to sleep.

00:26:14.009 --> 00:26:24.509
And then again, on Wake From Sleep after that, OS X builds
up the entire power stack by powering all your devices on.

00:26:24.509 --> 00:26:31.490
And once all of the devices are on, it will
send out the KIO message, system has powered on.

00:26:31.490 --> 00:26:40.900
So if you are using these, this API with these
notifications you might notice three to five seconds

00:26:40.900 --> 00:26:49.680
between the time the system appears to wake up and the time
your application actually gets the wake up notification.

00:26:49.680 --> 00:26:57.440
And that's because that delay is
powering on every device in the system.

00:26:58.549 --> 00:27:06.319
So the big caveat about these APIs is
that they're easy to misuse or to miss --

00:27:06.319 --> 00:27:13.869
pretty important call to acknowledge
the notification with the kernel.

00:27:13.869 --> 00:27:20.079
So when you receive one of these Can System
Sleep or System Will Sleep notifications,

00:27:20.079 --> 00:27:23.669
it's imperative that you reply immediately --

00:27:23.670 --> 00:27:31.630
or as soon as you're done with your sleep
processing, with an IO Allow Power Change message.

00:27:31.630 --> 00:27:40.620
IO Allow Power Change, it let's the kernel know that
you're done doing whatever you were going to do.

00:27:42.500 --> 00:27:50.819
And finally, I want to talk about a really cool
new API in Leopard called IO PM Insertion Create.

00:27:50.819 --> 00:27:53.919
There are two arguments that you can pass to it today.

00:27:53.920 --> 00:28:05.140
They are KIO PM Assertion Type No Displaced Sleep and
assertion type No Idle Sleep so if you were writing a, say,

00:28:05.140 --> 00:28:14.060
an FCP client and you wanted to make sure that no matter
what the Mac that you were downloading or up loading a file

00:28:14.059 --> 00:28:22.329
on stayed awake, then you could call IO PM
Assertion Create, assertion type No Idle Sleep.

00:28:22.329 --> 00:28:33.029
And that would completely disable idle sleep until you later
called IO PM Assertion Release to release that assertion.

00:28:33.029 --> 00:28:35.829
And the same goes for No Displaced Sleep.

00:28:35.829 --> 00:28:44.710
If you were displaying a movie or a
presentation like in key note, you would --

00:28:44.710 --> 00:28:54.329
you would want to use this call to completely disable
Displace Sleep and keep it as Play Awake the entire time.

00:28:54.329 --> 00:28:59.179
So these calls are new in Leopard.

00:28:59.180 --> 00:29:04.450
One thing worth noting is that they
only allow you to prevent idle sleep.

00:29:04.450 --> 00:29:18.420
They don't let you prevent sleep if the user selects sleep
from the Apple menu, or chooses sleep or if there's software

00:29:18.420 --> 00:29:23.570
on the computer that it causes sleep programatically.

00:29:23.569 --> 00:29:29.019
And of course there's a lot of things
you can't prevent, like forces of nature.

00:29:29.019 --> 00:29:36.349
Like thermal emergencies, or batteries running
out of juice, that's just -- how it goes.

00:29:36.349 --> 00:29:38.869
So that's it for me.

00:29:38.869 --> 00:29:46.500
And up next is Dave Ferguson who's going to talk
to you about USB and how they've implemented some

00:29:46.500 --> 00:29:49.259
of these power management APIs in Leopard.

00:29:49.259 --> 00:29:50.519
Thank you.

00:29:50.519 --> 00:29:54.059
( Applause )

00:29:54.059 --> 00:29:54.720
>> Thanks, Ethan.

00:29:54.720 --> 00:30:00.970
To talk about USB power management
we first start with the USB spec.

00:30:00.970 --> 00:30:11.130
Because the spec defines how USB devices specify their
power, when USB devices can draw power from the USB bus

00:30:11.130 --> 00:30:18.920
at what levels and what times, USB devices have to draw
a very small amount of power until they're configured.

00:30:18.920 --> 00:30:22.980
Once they're configured the host operating system can detect

00:30:22.980 --> 00:30:27.390
that that device declares it needs
more power, if there is more power.

00:30:27.390 --> 00:30:33.740
For instance, you're plugged into the root hub on
the back of the machine or into a self-powered hub.

00:30:33.740 --> 00:30:36.970
If there's enough power then we can
configure that device for high power.

00:30:36.970 --> 00:30:43.009
If the device doesn't need much power and it can work, say,
in a keyboard hub, then we can configure it right away.

00:30:43.009 --> 00:30:46.009
USB devices have to support suspend mode.

00:30:46.009 --> 00:30:53.779
This means that when the USB bus becomes inactive, they have
to go into a very low power mode where they draw milliamps,

00:30:53.779 --> 00:30:58.289
like 2.5 milliamps for a high power device.

00:30:58.289 --> 00:31:02.759
Now the USB devices can wake up a sleeping computer.

00:31:02.759 --> 00:31:08.730
So once the USB bus is suspended, it's possible
for a device to generate a Resume signal

00:31:08.730 --> 00:31:11.450
which says, wake up the port that I'm on.

00:31:11.450 --> 00:31:14.680
And if it's a running machine, it
just wakes up to do communication.

00:31:14.680 --> 00:31:17.029
If it's a sleeping machine, it
would wake the whole machine up.

00:31:17.029 --> 00:31:20.710
So you experience this every day when you
put a machine to sleep and you wake it

00:31:20.710 --> 00:31:24.500
up with a keyboard press or clicking the mouse button.

00:31:24.500 --> 00:31:32.000
So if a USB device defines itself as having remote
wake up capability, then we automatically enable that.

00:31:32.000 --> 00:31:36.910
So that means that modems that have the ability
to wake on ring automatically get that behavior.

00:31:36.910 --> 00:31:40.560
Any other USB device can easily with
a device that wakes up the system.

00:31:40.559 --> 00:31:44.179
It just has to have its describers correctly configured.

00:31:44.180 --> 00:31:50.320
And all of that is specified in the USB
spec. This suspending that I was talking

00:31:50.319 --> 00:31:53.629
about does come in a flavor known as Selective Suspend.

00:31:53.630 --> 00:31:58.410
And that's where we suspend just a single port on a USB hub.

00:31:58.410 --> 00:32:01.670
And that suspends that device and all down stream devices.

00:32:01.670 --> 00:32:07.190
So a portion of the tree can easily be trimmed
out, causing it to go into the lowest power states.

00:32:07.190 --> 00:32:11.150
So you can see that USB devices can control their power

00:32:11.150 --> 00:32:18.750
by having their port suspended whenever they're not
actively transferring data or need to be polled for data.

00:32:18.750 --> 00:32:23.630
I'm going use this picture today
and so you're going to see it a lot.

00:32:23.630 --> 00:32:25.150
And I thought I would describe it here.

00:32:25.150 --> 00:32:27.820
This is the USB topology.

00:32:27.819 --> 00:32:30.429
So at the top I've got a USB controller.

00:32:30.430 --> 00:32:36.130
I've chosen to use rectangular boxes because
these actually represent real hardware.

00:32:36.130 --> 00:32:41.800
So the USB controller in this case might have
a Bluetooth connected over there on the left.

00:32:41.799 --> 00:32:45.629
It has a keyboard and a mouse, you
know, connected there in the center.

00:32:45.630 --> 00:32:48.290
And on the right-hand side you see a USB hub.

00:32:48.289 --> 00:32:55.509
And down stream of that hub is an audio device,
both input and out put, and a USB mass storage.

00:32:55.509 --> 00:33:00.559
The green around that represents that
these devices are turned on right here.

00:33:00.559 --> 00:33:03.339
The green represents the on state.

00:33:03.339 --> 00:33:06.099
Now we also have the I/O power tree.

00:33:06.099 --> 00:33:11.049
And in Tiger and up until Leopard,
the I/O power tree was very flat.

00:33:11.049 --> 00:33:18.669
The USB controller was a power parent, and all USB
devices were power children of that power parent.

00:33:18.670 --> 00:33:20.250
So they were all singly connected.

00:33:20.250 --> 00:33:24.970
We'll talk a little bit about what's
happening in Leopard and how that's new,

00:33:24.970 --> 00:33:27.789
but I wanted to introduce you to that in just a little bit.

00:33:27.789 --> 00:33:36.440
Now, in our old model, Power Management Tiger and
before, we had no defined ordering among USB devices.

00:33:36.440 --> 00:33:38.920
All of those power children were there.

00:33:38.920 --> 00:33:46.880
When notifications went out, the notifications went in
whatever random order they happened to get distributed in.

00:33:46.880 --> 00:33:49.760
We know that hubs are actually
involved in the power management.

00:33:49.759 --> 00:33:52.299
Because a hub is the thing that suspends the port.

00:33:52.299 --> 00:33:56.349
So it knows whether an individual
device is in a low power state or not.

00:33:56.349 --> 00:33:58.789
But it wasn't involved in the power management.

00:33:58.789 --> 00:34:00.289
Not specifically.

00:34:00.289 --> 00:34:04.430
So the USB controller basically operated on two states.

00:34:04.430 --> 00:34:09.789
It had an off state, or zero, and a 1
state when the controller was running.

00:34:09.789 --> 00:34:14.119
So really, all of USB was off or all of USB was on.

00:34:14.119 --> 00:34:19.769
It was possible for an individual device to
turn its power off by suspending its port.

00:34:19.769 --> 00:34:23.320
But that really didn't involve
any of the other power management.

00:34:23.320 --> 00:34:28.090
We didn't know that there was a device with a suspended
port, other than we did the work to suspend did port.

00:34:28.090 --> 00:34:33.990
So the last thing that was a little different with the --
that you need to be aware of with USB power management,

00:34:33.989 --> 00:34:41.859
PCI cards, because the PCI bus is generally powered
off across sleep, the USB devices couldn't remain on.

00:34:41.860 --> 00:34:48.500
So if a USB device is plugged into a PCI card
you're not going to see the bus get suspended.

00:34:48.500 --> 00:34:51.000
You're not going to be able to wake up a sleeping machine.

00:34:51.000 --> 00:34:55.449
Some PCI cards actually use auxiliary
power and are capable of doing that.

00:34:55.449 --> 00:34:57.769
And if a card is capable, we enable it.

00:34:57.769 --> 00:35:00.820
But the bulk of them, we can't tell from the card design.

00:35:00.820 --> 00:35:03.420
There's nothing that declares whether it has that or not.

00:35:03.420 --> 00:35:08.740
And so if it doesn't look like it, then at
sleep time we unload all of the drivers.

00:35:08.739 --> 00:35:13.359
And at wake up time we completely reenumerate
and rediscover all of the devices in the bus.

00:35:13.360 --> 00:35:19.550
So that's why plugging in a mass storage device into a
PCI card, you sleep a machine and you get that dialogue

00:35:19.550 --> 00:35:22.430
that says you removed this device unexpectedly.

00:35:22.429 --> 00:35:28.169
Well, because we powered it off
and unloaded the driver for it.

00:35:28.170 --> 00:35:33.030
So under the old model of when the system
was powered on, here's all the hardware.

00:35:33.030 --> 00:35:34.860
Everything was just turned on.

00:35:34.860 --> 00:35:38.480
And when the system went to sleep,
the sleep request came in.

00:35:38.480 --> 00:35:40.619
This was the same power management call.

00:35:40.619 --> 00:35:44.219
Set Power State came into the USB controller.

00:35:44.219 --> 00:35:46.419
And you would just issue a global suspend.

00:35:46.420 --> 00:35:49.610
Which suspends all the down stream ports at the same time,

00:35:49.610 --> 00:35:55.809
and causes all of the down stream hardware
to suspend at exactly the same time.

00:35:55.809 --> 00:36:02.730
From the I/O power tree what this looked like is we sent all
of our children the message that said we're going to sleep.

00:36:02.730 --> 00:36:04.760
All at once, unordered.

00:36:04.760 --> 00:36:07.080
Just hoped it all worked out.

00:36:07.079 --> 00:36:10.710
Now hardware wake up worked like this.

00:36:10.710 --> 00:36:14.960
When the user presses a key, you see that
we've got the bus all in the suspended state.

00:36:14.960 --> 00:36:19.539
When the user presses a key on the mouse
that actually causes a resume signal

00:36:19.539 --> 00:36:22.199
to go up stream to the hub and the keyboard.

00:36:22.199 --> 00:36:26.529
The hub comes alive and sends a
resume signal up stream to the host.

00:36:26.530 --> 00:36:31.660
The host controller, when it gets the resume
signal, actually, it's still in a suspended state.

00:36:31.659 --> 00:36:37.239
But it has the capability of generating
a PCI power management event, or PME.

00:36:37.239 --> 00:36:42.309
So it generates this PME event,
which goes over to the power manager.

00:36:42.309 --> 00:36:47.480
The power manager actually says, oh, we've got
something that wants to wake up the system.

00:36:47.480 --> 00:36:52.210
Let's go ahead and turn the clocks
on, get memory going, wake the CPU up.

00:36:52.210 --> 00:36:53.730
All of those things start to happen.

00:36:53.730 --> 00:36:59.829
The power management code runs again, and now it sends
the System Wake Up message to the USB controller.

00:36:59.829 --> 00:37:04.369
So you see two of our devices are already powered
on, but now the system wake up message comes on

00:37:04.369 --> 00:37:09.589
and we did a global resume and all
the rest of the devices came on.

00:37:09.590 --> 00:37:16.950
Since -- since from a software driver model,
the I/O power tree, you don't have a notion,

00:37:16.949 --> 00:37:19.589
you don't see the event that caused the wake up.

00:37:19.590 --> 00:37:21.820
All the devices are still in the suspended state.

00:37:21.820 --> 00:37:25.550
And when the message comes in to do
System Wake Up, we do a global resume.

00:37:25.550 --> 00:37:33.390
We essentially send the message to all of the children
to set their power state to running, and there they are.

00:37:33.389 --> 00:37:39.069
Now with Leopard, we knew that
we needed a hub-centric model.

00:37:39.070 --> 00:37:44.309
One reason for this is that sleep wake on USB actually
according to an errata that came

00:37:44.309 --> 00:37:51.969
with the USB spec says for high speed hubs we need to
actually sleep the ports before we sleep the parents.

00:37:51.969 --> 00:37:56.489
The result of not doing this is
that there's a race condition

00:37:56.489 --> 00:38:00.819
where the device down stream transitions to full speed.

00:38:00.820 --> 00:38:05.070
Which is what you do when you are
suspending before the hub transitions.

00:38:05.070 --> 00:38:07.960
And it's possible for the hub to think a device disconnects.

00:38:07.960 --> 00:38:14.730
So you may have seen this message when you plug in some mass
storage devices into a high speed hub and you go to sleep,

00:38:14.730 --> 00:38:18.119
and you occasionally get the system
wakes back up right away.

00:38:18.119 --> 00:38:23.480
The reason it wakes back up right away is
that the hub thinks the device disconnected.

00:38:23.480 --> 00:38:24.670
And it starts to report that.

00:38:24.670 --> 00:38:26.820
But then it says, oh, the device is still here

00:38:26.820 --> 00:38:30.470
So sometimes you get a device was disconnected unexpectedly,

00:38:30.469 --> 00:38:33.419
and sometimes the system just wakes
itself back up right away.

00:38:33.420 --> 00:38:36.889
And we notice the device fast enough
to not notice that it disconnected.

00:38:36.889 --> 00:38:41.230
So this is going to solve that problem.

00:38:41.230 --> 00:38:45.480
So now we're going to make hubs be
the parent in the I/O parent tree.

00:38:45.480 --> 00:38:51.559
And we've defined our hubs, and we encourage
other USB devices to use five power states

00:38:51.559 --> 00:38:55.279
when their USB device is participating in power management.

00:38:55.280 --> 00:38:59.530
The top one there is IO U S -- IO PM power on.

00:38:59.530 --> 00:39:01.480
That's the on and running state.

00:39:01.480 --> 00:39:06.159
The next two states both represent
when the USB bus is suspended.

00:39:06.159 --> 00:39:13.309
The IO PM low power state, that's when the bus
is suspended just for an individual device.

00:39:13.309 --> 00:39:16.860
IO PM sleep is when the whole system is asleep.

00:39:16.860 --> 00:39:22.780
The reason we distinguish between that is that
a device might go into the I'm not active,

00:39:22.780 --> 00:39:26.990
and I want to go into the low power
state while the system operating.

00:39:26.989 --> 00:39:30.329
And we can still have the overall system go into sleep.

00:39:30.329 --> 00:39:35.599
And when we restore from sleep into running, we know not to
mess with the devices that were already in low power state.

00:39:35.599 --> 00:39:38.179
I am going to show how that operates in a minute.

00:39:38.179 --> 00:39:42.559
Finally, we created two different
states for the off condition.

00:39:42.559 --> 00:39:48.159
Because the controller is receiving the messages
that the system is shutting down or restarting.

00:39:48.159 --> 00:39:52.079
And we participated in using the
new APIs that Ethan talked about.

00:39:52.079 --> 00:39:58.259
We, then, turn around and tell our children that
we are putting them in one of two off states.

00:39:58.260 --> 00:40:02.310
Either the IO PM restart state, or the off state.

00:40:02.309 --> 00:40:03.889
Which actually doesn't have a symbol.

00:40:03.889 --> 00:40:05.250
We just send a zero.

00:40:05.250 --> 00:40:13.739
So this is what we mean when we say that USB
drivers don't need to participate in the new API.

00:40:13.739 --> 00:40:21.029
They're going to get through the Set Power State all
the information that we're shutting down or restarting.

00:40:22.239 --> 00:40:26.429
So low power state devices can use the idle timer.

00:40:26.429 --> 00:40:28.059
You know, the activity tickle.

00:40:28.059 --> 00:40:31.840
Or some other mechanism to determine when they
might be able to drop into the low power state.

00:40:31.840 --> 00:40:38.420
For instance, a printer driver might say if I
don't have a client currently attached to me

00:40:38.420 --> 00:40:42.450
and I'm not currently streaming data to that,
I know that I can be in my low power state.

00:40:42.449 --> 00:40:44.109
I don't need to use the activity.

00:40:44.110 --> 00:40:50.840
I know that the open and closed call are sufficient for
me to know that now I can enter the low power state.

00:40:50.840 --> 00:40:55.789
So whenever it's in the low power state, the
power driver for that device should suspend it.

00:40:55.789 --> 00:40:59.900
And we've always had the call suspend
device, and that effectively tells the hub

00:40:59.900 --> 00:41:04.269
that that port is connected to into the suspend state.

00:41:04.269 --> 00:41:09.429
But now because the hub is participating in
power management, it knows what that means.

00:41:09.429 --> 00:41:17.089
Because you've suspended a port, the hubs can say, oh, when
all of my children are suspended I can go and put myself

00:41:17.090 --> 00:41:22.030
in a low power state and the hub driver
itself can suspend its parent support.

00:41:22.030 --> 00:41:24.900
So it just works its way right up the tree.

00:41:24.900 --> 00:41:31.119
And in fact when the entire USB controller finds that
all of its devices, all of its ports are suspended,

00:41:31.119 --> 00:41:34.150
we can actually suspend the whole
controller, and stop the controller

00:41:34.150 --> 00:41:37.920
from accessing memory, resulting in further power savings.

00:41:37.920 --> 00:41:42.550
So let's take a look how this works within the new system.

00:41:42.550 --> 00:41:44.390
So here's a running system.

00:41:44.389 --> 00:41:49.279
And you'll notice that Bluetooth, because it didn't
have any devices currently pairs has already suspended

00:41:49.280 --> 00:41:51.760
its controller.

00:41:51.760 --> 00:41:56.510
So the audio device determines that its not
doing anything with its audio head set right now.

00:41:56.510 --> 00:41:59.290
So it goes ahead and suspends its device.

00:41:59.289 --> 00:42:02.730
And the hub says I don't have any
children attached right now.

00:42:02.730 --> 00:42:03.480
They're all suspended.

00:42:03.480 --> 00:42:06.099
So I will go ahead and suspend myself.

00:42:06.099 --> 00:42:09.809
So at this point we have three of
our USB devices that are drawing,

00:42:09.809 --> 00:42:14.559
that are in the lowest power state
possible while the system's on.

00:42:14.559 --> 00:42:17.219
Now at this point, what if you plug in a device?

00:42:17.219 --> 00:42:21.500
Well, the hub when you plug in a device
like that supplies power to the device.

00:42:21.500 --> 00:42:24.030
The low amount of configuration power.

00:42:24.030 --> 00:42:28.080
But, it then generates a resume signal
and says I need to wake myself --

00:42:28.079 --> 00:42:31.639
I need to wake my parent up so
that I can communicate with it.

00:42:31.639 --> 00:42:35.779
Now that that port resumed, the hub
driver will notice that device is attached

00:42:35.780 --> 00:42:39.550
and the distal mount on the desktop and all that stuff.

00:42:39.550 --> 00:42:44.269
So what happens when it comes time
to transition the system to sleep?

00:42:44.269 --> 00:42:50.840
The sleep command Set Power State
call into our USB controller comes in.

00:42:50.840 --> 00:42:57.519
And we start -- well, what actually happens is the power
manager goes to all the children in the IO power tree

00:42:57.519 --> 00:43:01.079
and starts to suspend those by doing their Set Power State.

00:43:01.079 --> 00:43:05.819
In response to a Set Power State, a driver
called suspend device -- here you go.

00:43:05.820 --> 00:43:07.670
It suspends the device.

00:43:07.670 --> 00:43:10.550
Then we go to the next parents and we suspend those.

00:43:10.550 --> 00:43:14.030
And finally, the controller gets its suspend.

00:43:14.030 --> 00:43:17.840
Now at wake up time, the hardware wake up is the same.

00:43:17.840 --> 00:43:22.950
User presses a key, it generates the resumes
up stream, the power management then happens

00:43:22.949 --> 00:43:30.349
over to the power manager chip, wakes up the CPU, the CPU
power management software runs and System Wake Up is called.

00:43:30.349 --> 00:43:33.980
Now that System Wake Up is called,
we wake up the controller first,

00:43:33.980 --> 00:43:36.840
the controller then goes down and wakes up just the hub.

00:43:36.840 --> 00:43:42.010
But you notice we didn't wake up the Bluetooth
device, because we knew that it was in a power state

00:43:42.010 --> 00:43:47.400
that wasn't system sleeping, we can avoid waking
him up, doing any other communication there.

00:43:47.400 --> 00:43:50.809
And we would resume the other device that
was down stream there, the mass storage.

00:43:50.809 --> 00:43:57.039
So the audio device and the Bluetooth
still remain in the low powered state.

00:43:58.070 --> 00:44:02.160
Now the IO power tree -- so now I've got
my circles representing drivers here.

00:44:02.159 --> 00:44:08.079
The IO power tree shows that a couple of those drivers are
in the low power state already when the system's running.

00:44:08.079 --> 00:44:09.860
And a system sleep comes in.

00:44:09.860 --> 00:44:11.570
And we follow exactly the same model.

00:44:11.570 --> 00:44:14.760
We start with turning off the leaf nodes, the children.

00:44:14.760 --> 00:44:17.720
By the way, you'll notice that in
this model, I didn't mention it before

00:44:17.719 --> 00:44:20.559
but the keyboard, I split it off into two devices.

00:44:20.559 --> 00:44:24.340
Because the keyboard actually is a
keyboard device and a hub device.

00:44:24.340 --> 00:44:26.730
There's two USB devices inside of there.

00:44:26.730 --> 00:44:29.849
So it gets two circles in the driver.

00:44:29.849 --> 00:44:32.250
One circle in the physical hardware.

00:44:32.250 --> 00:44:37.289
So once we've done the leaf nodes, then
the parents of those get suspended.

00:44:37.289 --> 00:44:38.940
And finally the controller.

00:44:38.940 --> 00:44:41.920
And that's what puts the whole system to sleep.

00:44:41.920 --> 00:44:48.800
At system wake up time, at System Wake Up
time we start by waking up the controller.

00:44:48.800 --> 00:44:53.000
After the controller, the next thing
down is the children of the controller.

00:44:53.000 --> 00:45:00.559
And then finally, those -- the
children of the hubs get woken up.

00:45:00.559 --> 00:45:04.380
And so the running system is back
again with two of our devices still

00:45:04.380 --> 00:45:07.490
in the low power state and the rest of the devices on.

00:45:08.539 --> 00:45:14.509
Now shutdown and restart, because we're turning
the whole USB tree off for shutdown and restart,

00:45:14.510 --> 00:45:18.430
it means that we're going to do the
Change Power State -- pardon me --

00:45:18.429 --> 00:45:21.219
the Set Power State function, we're going to be calling you

00:45:21.219 --> 00:45:26.750
with either setting your state
to zero or to the KIO PM restart.

00:45:26.750 --> 00:45:30.880
So you can use that instead of the
new I/O Kit API for USB drivers.

00:45:30.880 --> 00:45:35.440
Now what do we need you to do?

00:45:35.440 --> 00:45:38.159
We need you to do your part to save power.

00:45:38.159 --> 00:45:43.069
Start by changing your drivers
to use the new USB power states.

00:45:43.070 --> 00:45:51.340
When transitioning your driver to -- when transitioning
your driver to the low power state you need

00:45:51.340 --> 00:45:53.050
to make sure that you call suspend device.

00:45:53.050 --> 00:45:57.830
Because that's what actually notifies the hubs that
something is actually happening to the children.

00:45:57.829 --> 00:46:01.590
And finally, you need to transition to the low
power state whenever the device is inactive.

00:46:01.590 --> 00:46:09.309
You can use open close calls from a user client, if you
can do it when you don't have activity going to the device,

00:46:09.309 --> 00:46:12.159
every bit that you can suspend the device saves power.

00:46:12.159 --> 00:46:19.359
And it all adds minutes of time
to a PowerBook, or MacBook Pro.

00:46:19.360 --> 00:46:20.900
Tools for debugging.

00:46:20.900 --> 00:46:23.639
This is actually something kind of new.

00:46:23.639 --> 00:46:29.170
New with Leopard is FireWire K Print F
built into the kernel.

00:46:29.170 --> 00:46:34.030
If you ever used FireWire K Print F it was
distributed previously as part of the FireWire SDK,

00:46:34.030 --> 00:46:43.830
and it was a special version of FireWire that
gave kernel Print F from drivers and read them

00:46:43.829 --> 00:46:46.809
from another machine connected via FireWire.

00:46:46.809 --> 00:46:49.480
You had a special version of FireWire,
when you ran that special version

00:46:49.480 --> 00:46:52.900
of FireWire unfortunately all you
could do was K Print F Logging.

00:46:52.900 --> 00:46:55.740
You couldn't connect your FireWire devices and use that.

00:46:55.739 --> 00:46:57.359
So it was kind of an either or.

00:46:57.360 --> 00:47:00.510
Are you going to do debugging with
FireWire or are you going to use FireWire.

00:47:00.510 --> 00:47:05.080
Now they've built it so that FireWire
is active all the time.

00:47:05.079 --> 00:47:09.759
And until the -- until either debug flags are enabled,

00:47:09.760 --> 00:47:14.950
enabling K Print F in the first
place, and a user client connects.

00:47:14.949 --> 00:47:17.669
Until those thing happens FireWire works normally.

00:47:17.670 --> 00:47:19.700
You can use devices and all of that.

00:47:19.699 --> 00:47:24.859
But when you suddenly need to debug something,
connect up with FireWire K Print F Viewer,

00:47:24.860 --> 00:47:27.860
and all of a sudden your FireWire
devices are going to disconnect.

00:47:27.860 --> 00:47:31.840
But FireWire K Print F starts working
exactly at that moment.

00:47:31.840 --> 00:47:39.700
You can then put a machine to sleep if you're turned on
flags enabling power management logs you can look at those.

00:47:39.699 --> 00:47:45.839
FireWire K Print F has turned out to be extremely useful for
debugging power management because FireWire remains active

00:47:45.840 --> 00:47:49.030
up until the very last moment that the machine goes off.

00:47:49.030 --> 00:47:54.019
So even though the other things may be
turned off, the display may be off, you know,

00:47:54.019 --> 00:47:56.409
it just may not be possible to do other communications.

00:47:56.409 --> 00:48:00.170
FireWire with its direct memory
access keeps going all the time.

00:48:00.170 --> 00:48:04.280
So to use this, you have to turn on the kernel K Print Fs.

00:48:04.280 --> 00:48:09.890
And right here I have an example of the command
line you would do, where you do a pseudo N V ram,

00:48:09.889 --> 00:48:11.639
and you set the boot-args.

00:48:11.639 --> 00:48:14.359
The key is that that debug equals 8.

00:48:14.360 --> 00:48:18.849
It's that bit right there that
says turn on kernel K Print F.

00:48:18.849 --> 00:48:23.449
And then there's argument there that says IO equals 80 Hex.

00:48:23.449 --> 00:48:28.519
And the 80 Hex is the bit that
turns on power management messages.

00:48:28.519 --> 00:48:32.429
I'm going to show a little example of decoding
a couple of those power management messages.

00:48:32.429 --> 00:48:36.609
If you're starting to do your driver that
participates in this power management,

00:48:36.610 --> 00:48:41.079
you want to know when your Set Power State is being
called, you want to know what it's being changed to,

00:48:41.079 --> 00:48:51.549
you want to know what your parent is -- these
are the logs that help you figure that stuff out.

00:48:51.550 --> 00:48:58.470
Oh, the last thing is the FireWire K print Fs viewer
which is the necessary piece for this is available

00:48:58.469 --> 00:49:03.839
in the FireWire SDK 24, which just
became available, like, yesterday.

00:49:03.840 --> 00:49:05.920
So it's available for you now.

00:49:05.920 --> 00:49:11.490
You can download that thing and have its command
line tool that you run in a Terminal window.

00:49:11.489 --> 00:49:17.179
And finds the machines connected via FireWire
and starts getting their log messages right away.

00:49:17.179 --> 00:49:21.549
So take it for a spin on your Leopard machines.

00:49:21.550 --> 00:49:29.740
Now the messages that you get out when you have the
power management locking enabled, with the I/O equals 80,

00:49:29.739 --> 00:49:33.649
they're these cryptic things which look
like this top line up here, which --

00:49:33.650 --> 00:49:37.960
it's got a time stamp on it, it's got a few other fields.

00:49:37.960 --> 00:49:40.960
Finally, over there, you see Apple USB EHCI.

00:49:40.960 --> 00:49:46.570
Well, that happens to be one of the
-- that happens to be a power driver.

00:49:46.570 --> 00:49:50.019
And that's the EHCI's power driver.

00:49:50.019 --> 00:49:54.159
And the first thing you do is you
look for your class name right there.

00:49:54.159 --> 00:49:57.349
The second thing is you look for the
number just to the right of that.

00:49:57.349 --> 00:50:02.409
And we know that number 38 is the settle power state call.

00:50:02.409 --> 00:50:06.899
And the next number is the instance of Apple USB EHCI.

00:50:06.900 --> 00:50:12.119
And the number 2 is the actual state change.

00:50:12.119 --> 00:50:16.920
And that is the index into the
table of power states that you have.

00:50:16.920 --> 00:50:21.260
So this is a case where EHCI is
being asked to change the state to.

00:50:21.260 --> 00:50:26.030
And then on the second line you see us
decoding one where it says minus 38.

00:50:26.030 --> 00:50:30.750
Minus 38 indicates that the Set
Power State call has returned.

00:50:30.750 --> 00:50:31.840
There's our incidence again.

00:50:31.840 --> 00:50:34.460
So it's the same EHCI driver.

00:50:34.460 --> 00:50:36.389
And the zero is the return value.

00:50:36.389 --> 00:50:41.759
So because it returns a zero, that says
that the Set Power State was completed.

00:50:41.760 --> 00:50:46.480
If you return a non zero value, that
says that this is an asynchronous call.

00:50:46.480 --> 00:50:50.349
And at that point you have to look for the completion call.

00:50:50.349 --> 00:50:53.819
And I'm going to show you what that message is right here.

00:50:53.820 --> 00:50:59.070
So the -- where will you find a
list of what those numbers mean?

00:50:59.070 --> 00:51:02.500
I went to actually answer that question so
that I could hopefully just point to you

00:51:02.500 --> 00:51:05.610
and say here's the definition out of the header file.

00:51:05.610 --> 00:51:09.400
And what I found is we have a header
file that defines these messages.

00:51:09.400 --> 00:51:13.059
It's available in the Darwin open source.

00:51:13.059 --> 00:51:16.980
But the defines don't necessarily give
you much of a clue as to what they are.

00:51:16.980 --> 00:51:22.760
So I went back to our engineers who sit down and do this
stuff day in and day out and said, which ones do you use.

00:51:22.760 --> 00:51:24.410
And they said here are the magic numbers.

00:51:24.409 --> 00:51:28.509
This is what's written on their little
notes next to the computer monitor.

00:51:28.510 --> 00:51:33.330
38 and minus 38 are the Set Power State as I just covered.

00:51:33.329 --> 00:51:37.360
39 is the power state will change to call.

00:51:37.360 --> 00:51:40.160
40 is the power state did change call.

00:51:40.159 --> 00:51:45.089
So one is before it happens, an
the other is after it has happened.

00:51:45.090 --> 00:51:50.059
And then finally, 16 is that asynchronous
Set Power State completion.

00:51:50.059 --> 00:51:56.099
So in the previous example when you saw the minus
38, if that had returned a non zero number there

00:51:56.099 --> 00:52:03.339
on the right-hand side, then you would then
see a call later with the EHCI driver and a 16,

00:52:03.340 --> 00:52:08.750
and you would see what the return value was at that time.

00:52:08.750 --> 00:52:14.559
Okay. So for more information Craig Keithley
is our I/O Technology Evangelist.

00:52:14.559 --> 00:52:17.449
There's his e-mail address.

00:52:17.449 --> 00:52:23.619
And we've got things that are up on the
attendee Web site so you can go there

00:52:23.619 --> 00:52:26.239
and download the latest power management chapter.

00:52:26.239 --> 00:52:26.969
Take a look.
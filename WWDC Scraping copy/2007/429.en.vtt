WEBVTT

00:00:09.990 --> 00:00:14.190
>> Welcome to the Tune Your 2D Graphics session.

00:00:14.189 --> 00:00:20.480
Apparently it turns out this is the haven for people who
weren't allured by the Core Image and the Core Animation.

00:00:20.480 --> 00:00:23.160
So you all are here, thanks very much.

00:00:23.160 --> 00:00:28.379
Hi, my name is Andrew Barnes, and yes I'm
the pixel guy, the guy who makes pixels.

00:00:28.379 --> 00:00:38.969
So this session, the things that you learn is how to make
more efficient use of the Mac OS X's graphics pipeline,

00:00:38.969 --> 00:00:44.140
and what we're going to go through is sort of divided into
sections, one section has to do with drawing optimizations,

00:00:44.140 --> 00:00:49.250
what you can do to draw faster, and the other one is
what you can do to get your stuff to the screen faster.

00:00:49.250 --> 00:00:53.579
So let's take a look at the graphics architecture slide.

00:00:53.579 --> 00:00:56.659
We've all seen this before, for
those of you who are returning.

00:00:56.659 --> 00:00:59.849
Basically what happens is that when
you draw with Quartz, you draw,

00:00:59.850 --> 00:01:04.060
your application draws into the window backing store,
and if you draw with video, you draw into surfaces,

00:01:04.060 --> 00:01:12.969
and you draw into 3D. Those guys both are surfaces that
reside in VRAM, and once all the, you flushed your content

00:01:12.969 --> 00:01:17.060
and you want to say great, I want to present it to the
screen, the Quartz Compositor takes it all together,

00:01:17.060 --> 00:01:21.840
builds it up, and puts it onto the framebuffer,
and that's the thing that you see on screen.

00:01:21.840 --> 00:01:27.960
So, what we won't be talking about obviously
is 3D and video, what we will be talking

00:01:27.959 --> 00:01:30.619
about is you know, Quartz, the uses of Quartz.

00:01:30.620 --> 00:01:31.750
So let's jump right in.

00:01:31.750 --> 00:01:39.840
First we want to start off with some
basic optimization fundamentals, right.

00:01:39.840 --> 00:01:44.520
The first one, it doesn't matter what graphics
system you're on, changes in state are expensive.

00:01:44.519 --> 00:01:48.810
So the first thing you want to try and do
is try and minimize your state changes.

00:01:48.810 --> 00:01:55.230
Second thing you want to do is obviously don't draw that
can't be seen, or what won't be seen, or what's secluded.

00:01:55.230 --> 00:01:56.439
Don't overdraw your stuff.

00:01:56.439 --> 00:02:00.120
An example in 3D is like tryin=g
to test like the far side of the moon.

00:02:00.120 --> 00:02:04.109
It's like nobody's going to see it, so why bother testing it?

00:02:04.109 --> 00:02:08.069
Another important point is about memory consumption.

00:02:08.069 --> 00:02:13.389
People like to create caches, they like to allocate memory,
you know, hopefully garbage collection might want to get rid

00:02:13.389 --> 00:02:18.000
of your memory for you, but basically
what happens when you create a page,

00:02:18.000 --> 00:02:21.250
it potentially becomes a page that
needs to be paged out the disk.

00:02:21.250 --> 00:02:26.250
So if you can control how much memory you
consume, it's always wise to try and do so.

00:02:27.599 --> 00:02:31.750
Another point is sort of trying to understand
what kind of data you're dealing with.

00:02:31.750 --> 00:02:34.509
Right, are you an application that draws images?

00:02:34.509 --> 00:02:36.099
Are you an application that draws line art?

00:02:36.099 --> 00:02:42.009
What sort of size of data that you're dealing
in, what amount of data that you're dealing with,

00:02:42.009 --> 00:02:46.939
all these things are very important in trying to
come up with the solution to your particular problem.

00:02:46.939 --> 00:02:51.879
And the last point, obviously, is sort of
never be afraid to sort of reexamine any kind

00:02:51.879 --> 00:02:54.539
of the architectural decisions you
may have made in the past, right.

00:02:54.539 --> 00:02:58.400
What's true today, it may not be true tomorrow, right.

00:02:58.400 --> 00:03:02.750
So let's jump a little bit further in.

00:03:02.750 --> 00:03:07.349
Objects. We have a whole plethora
of objects for you to use, right.

00:03:07.349 --> 00:03:12.299
And reusing those objects are critical to best performance.

00:03:12.300 --> 00:03:15.600
You don't really have to do very much, you just have
to, once you use your objects, you hold onto it.

00:03:15.599 --> 00:03:17.639
If you don't need the object, well yes you can release it.

00:03:17.639 --> 00:03:22.109
But if you do need your object and you're going to
reuse it again, hold onto it, reuse it and reuse it.

00:03:22.110 --> 00:03:25.890
Basically improves the performance of your
application without you doing very much, right.

00:03:25.889 --> 00:03:29.849
It avoids a whole bunch of costly sort of
complications, whether or not it's a path,

00:03:29.849 --> 00:03:33.019
whether or not it's color matching, whether
it's image interpolation or color matching.

00:03:33.020 --> 00:03:35.820
It you know, just reusing that image ref is very important.

00:03:35.819 --> 00:03:40.189
Another important point about it is for PDF
and PostScript representations, right.

00:03:40.189 --> 00:03:44.400
Some people are, there's been a
bug that I've seen people have

00:03:44.400 --> 00:03:50.080
where they would actually draw this image repeatedly inside
this PDF document, and they constantly created new images.

00:03:50.080 --> 00:03:54.240
And what actually ended up happening was that we
created several copies of the image inside the PDF file.

00:03:54.240 --> 00:03:57.040
If they only used the same image ref all
the time, what would have happened is

00:03:57.039 --> 00:04:00.889
that they only have one representation
of that image in the file.

00:04:00.889 --> 00:04:08.129
And of course for transportation to the GPU, which
is sometimes costly, if you reuse these objects,

00:04:08.129 --> 00:04:10.340
we know we don't need to re-upload this stuff.

00:04:10.340 --> 00:04:15.930
So definitely if you have objects, you
want to hold onto them, by all means do so.

00:04:15.930 --> 00:04:19.310
Finally, of course you know, the previous
slide told you about memory consumption.

00:04:19.310 --> 00:04:24.280
If you don't need the object, definitely throw it away.

00:04:24.279 --> 00:04:28.609
So Quartz objects are sort of separated
so that they live in two worlds.

00:04:28.610 --> 00:04:30.220
Well not live in, there are two worlds.

00:04:30.220 --> 00:04:32.960
One world is about coverage, it's like
the stencil sheet

00:04:32.959 --> 00:04:36.430
in which you, the mesh or the cookie cutter, right.

00:04:36.430 --> 00:04:38.250
And the other one is the actual paint.

00:04:38.250 --> 00:04:42.730
The colorized objects are basically paint that you
pour through the stencil in order affect your destination.

00:04:42.730 --> 00:04:47.790
So what we're going to talk about
right now is coverage objects.

00:04:47.790 --> 00:04:53.160
So the first guy on the list is paths.

00:04:53.160 --> 00:04:56.560
Hopefully you're digging the fruit theme today.

00:04:56.560 --> 00:05:06.439
Paths are basically general containers for any kind of
geometric data, curves, lines, rectangles, and so on.

00:05:06.439 --> 00:05:13.250
And the important point about paths is that yes they're
really complicated, yes they're really easy to use,

00:05:13.250 --> 00:05:15.910
as well as you can capture lots of complicated stuff.

00:05:15.910 --> 00:05:18.880
You can have a path that has multiple sub-paths, right.

00:05:18.879 --> 00:05:24.519
And what happens is that at the time you actually draw
your path, or your paths, your array of sub-paths,

00:05:24.519 --> 00:05:27.569
we go in and compute exact geometric coverage.

00:05:27.569 --> 00:05:31.550
So basically what happens is that we never
overdraw, even though you have multiple objects.

00:05:31.550 --> 00:05:36.310
We basically compute the geometric coverage for exactly each
pixel, so that when we pour the paint through the pixel,

00:05:36.310 --> 00:05:42.709
it's only going to touch the pixel once, so that's important.

00:05:42.709 --> 00:05:43.109
PathRefs.

00:05:43.110 --> 00:05:46.960
Whenever you have objects that you're reusing over and
over again, like I'd say you want to have a little circle

00:05:46.959 --> 00:05:50.409
or a little kind of something that
you want to reuse over and over again,

00:05:50.410 --> 00:05:55.380
it's much better to just construct a PathRef and
then reuse that object instead, instead of re-explore,

00:05:55.379 --> 00:05:58.750
or re-explaining the whole arc
in the line and the curve, right.

00:05:58.750 --> 00:06:05.189
So if you are reusing paths over and over again, regardless
of whether you're scaling them or not, or transforming them,

00:06:05.189 --> 00:06:08.310
you should just make a path object
and reuse the path object.

00:06:08.310 --> 00:06:14.709
So yes, do that, and it's always better than
explaining or doing path reconstruction all the time.

00:06:14.709 --> 00:06:17.239
Last point really is connected to the first point.

00:06:17.240 --> 00:06:21.680
I told you that you can create a path that can
be arbitrarily complex in multiple path segments,

00:06:21.680 --> 00:06:27.689
but computing the actual geometric coverage for
each of those pixels that comprise the path,

00:06:27.689 --> 00:06:30.670
or the area that the path is going to
touch does take a lot of time.

00:06:30.670 --> 00:06:34.780
So, especially when they're self intersecting.

00:06:34.779 --> 00:06:40.639
So it's important, or it helps if you were
to somehow subdivide your paths, right.

00:06:40.639 --> 00:06:43.490
So if you have a big street map you could say
okay, well let's draw all the thin streets,

00:06:43.490 --> 00:06:46.240
and then I'll draw all the fat streets,
and then draw all the different, you know.

00:06:46.240 --> 00:06:51.120
So you can break your stuff up to decrease the
actual computation cost of actually constructing

00:06:51.120 --> 00:06:54.209
and creating the physical mask for the path.

00:06:54.209 --> 00:06:57.120
So definitely you can try and subdivide things.

00:06:57.120 --> 00:07:00.949
And of course it's also important to try and
know what kind of data and where the data is,

00:07:00.949 --> 00:07:05.930
so that when you start cutting these paths
up, you can sort of discard whole chunks.

00:07:05.930 --> 00:07:08.780
Which kind of leads me into something else.

00:07:08.779 --> 00:07:12.329
We've talked about CAD and different things.

00:07:12.329 --> 00:07:18.109
We have new APIs that were sort of available in Tiger,
and they're stroke line segments and draw up rectangles.

00:07:18.110 --> 00:07:21.569
These are the fastest ways to draw rectangles on lines.

00:07:21.569 --> 00:07:23.790
So even though paths are great in general,

00:07:23.790 --> 00:07:27.040
lines and rectangles are really common,
and people use them all the time.

00:07:27.040 --> 00:07:29.939
And these APIs are the fastest way to do things.

00:07:29.939 --> 00:07:38.009
But be aware that the actual exact pixel
coverage is not completely guaranteed.

00:07:38.009 --> 00:07:43.310
Gives you a good estimate, but
it's not as accurate as the path.

00:07:43.310 --> 00:07:47.970
The coverage values and errors are probably you
know, one and two pixels, something like that.

00:07:47.970 --> 00:07:53.290
But it definitely saves us from having to do a lot of costly
computations with respect to the self intersecting lines

00:07:53.290 --> 00:07:58.400
and stuff like that, which you get a lot of when you have
line segments and you know, rectangles and stuff like that.

00:07:58.399 --> 00:08:03.250
So if you just like a simple CAD application, or you want to
just draw a whole bunch of rectangles, definitely use that,

00:08:03.250 --> 00:08:06.060
those, these APIs and you go a lot faster.

00:08:06.060 --> 00:08:14.170
For more complicated situations, you know, which is more
or less the CAD situation, or a GIS system, you sort of,

00:08:14.170 --> 00:08:20.830
if you haven't already done this before, you might want to
take a look at what kind of data you're dealing with, right.

00:08:20.829 --> 00:08:25.069
Especially for instance GIS systems or CAD
systems, you really want to try and say well geez,

00:08:25.069 --> 00:08:30.339
how can I organize my data structures in such a way that
I can get efficient rendering of what I need to draw,

00:08:30.339 --> 00:08:35.459
and not basically shove you know, five million lines at
us and say draw it please, only if it's a postage stamp.

00:08:35.460 --> 00:08:41.860
So you could definitely do a whole bunch of reorganizing how
you actually store your data so that you can get fast access

00:08:41.860 --> 00:08:46.230
or random access as people are panning and zooming around.

00:08:46.230 --> 00:08:49.460
The other thing too is about what you're actually seeing.

00:08:49.460 --> 00:08:51.940
You know, I made a comment about
testing the far side of the moon,

00:08:51.940 --> 00:08:54.160
similarly with for instance the
waveform diagram that you see.

00:08:54.159 --> 00:08:58.360
There's a lot of segments in that waveform diagram,
and not all of them need to be drawn, right.

00:08:58.360 --> 00:09:01.149
If the line width is one, you can
certainly prune a whole bunch

00:09:01.149 --> 00:09:04.029
of data instead of shoving all 10,000 lines at us.

00:09:04.029 --> 00:09:06.199
You can cut it down to a hundred and it'll be just as good.

00:09:06.200 --> 00:09:11.000
So definitely knowing what kind of data
you're dealing with is very important.

00:09:11.000 --> 00:09:15.049
So next thing is, told you how to draw
paths, different types of coverage.

00:09:15.049 --> 00:09:17.809
The other type of coverage is clipping.

00:09:17.809 --> 00:09:29.179
So told you how to sort of draw less, now
we're telling you how to draw even less, right.

00:09:29.179 --> 00:09:33.039
The first part of this sort of
problem is to do with calling, right.

00:09:33.039 --> 00:09:36.620
The, for instance, the highlighted
area is just a bunch of text blocks,

00:09:36.620 --> 00:09:39.330
and you really don't need to draw the entire page, right.

00:09:39.330 --> 00:09:41.590
There's a whole bunch of text, a
whole bunch of lines (inaudible).

00:09:41.590 --> 00:09:44.670
If you know that they are outside of
what the area that you want to draw,

00:09:44.669 --> 00:09:46.629
definitely cull those objects and
don't send them to (inaudible).

00:09:46.629 --> 00:09:50.750
You could send them to (inaudible), but we'll just simply
go in and do a whole bunch of work to diskard the objects.

00:09:50.750 --> 00:09:55.009
So definitely if you know ahead of time, you can
actually just sort of call out entire blocks of stuff,

00:09:55.009 --> 00:09:57.439
it's like this is not visible, just get rid of it.

00:09:57.440 --> 00:10:03.110
And similarly for trying to sort of look at things that are
actually smaller, to do sort of trivial clipping yourself.

00:10:03.110 --> 00:10:07.840
Even though you might have a sub region, and you have a
huge text run, which is like 500 glyphs, right,

00:10:07.840 --> 00:10:12.370
and you know all 500 glyphs are not going to you
know, hit the area that you're going to touch,

00:10:12.370 --> 00:10:17.379
you can sort of do trivial clipping and just clip out all
of those glyphs and not give us that large run, right.

00:10:17.379 --> 00:10:20.759
Because we're just going to turn around and start
processing the data and throwing away those runs anyway.

00:10:20.759 --> 00:10:25.409
So if you are able to you know, efficiently
ascertain whether or not you need to run to the run,

00:10:25.409 --> 00:10:27.659
then yes, you can start chopping your runs up.

00:10:27.659 --> 00:10:30.120
And of course minimizing what you clip, right.

00:10:30.120 --> 00:10:35.710
Typically sometimes people do something kind of
silly, like set the clip path around the image.

00:10:35.710 --> 00:10:39.550
The image already intrinsically has a clip,
it's whatever's outside of the image bounds.

00:10:39.549 --> 00:10:43.109
So don't just set up a clip and then draw
the image, that's just a waste of a clip.

00:10:43.110 --> 00:10:44.610
So just draw the image.

00:10:44.610 --> 00:10:48.560
So if objects intrinsically have clips,
don't try and re-explain what that clip is

00:10:48.559 --> 00:10:50.989
if the object already is going to tell you what the clip is.

00:10:50.990 --> 00:10:52.490
So definitely do that.

00:10:52.490 --> 00:10:58.799
And along the state changes line, you might want
to sort of think about amortizing your clip.

00:10:58.799 --> 00:11:02.959
We spoke about how expensive it is to do
state changes, and yes clips are cached

00:11:02.960 --> 00:11:05.580
on the card, which is slightly unlike paths.

00:11:05.580 --> 00:11:10.920
But at the same time, reusing those
clips will definitely help you.

00:11:10.919 --> 00:11:16.339
So if you have stuff that is going to share a particular
clip, it's much better to say I'm going to use clip A,

00:11:16.340 --> 00:11:21.220
draw a whole bunch of objects, and then move onto
clip B, as opposed to saying I'm going to draw clip A,

00:11:21.220 --> 00:11:25.629
and then I'm going to draw clip B, then you move back to A, and
then you go to B, and you know, that's just going to cause us

00:11:25.629 --> 00:11:29.730
to do a whole bunch of stuff to do things.

00:11:29.730 --> 00:11:35.610
So definitely you want to amortize your clip
over you know, if your content allows, of course.

00:11:35.610 --> 00:11:37.100
So great, that's clipping.

00:11:37.100 --> 00:11:43.300
So that's all nice and great, but what if I definitely
have a clipping issue in terms of my performance,

00:11:43.299 --> 00:11:49.719
and I want to sort of pre-build this clip at a particular
resolution, such that I don't have to go in and tell you

00:11:49.720 --> 00:11:52.200
about this clip, and we have to go
and construct the clip every time.

00:11:52.200 --> 00:11:55.460
So you might want to just create the
clip off screen, and then draw it.

00:11:55.460 --> 00:11:56.920
So how do we do that?

00:11:56.919 --> 00:12:01.969
Basically create an alpha-only bitmap context, that
context is basically I'm going to call our coverage.

00:12:01.970 --> 00:12:04.750
You can draw any kind of object in
there and then record the coverage.

00:12:04.750 --> 00:12:07.710
Even the alpha from your images, or shadings, or whatever.

00:12:07.710 --> 00:12:13.290
So an example, the little thing on the bottom,
and basically use a shading with a circular clip.

00:12:13.289 --> 00:12:16.009
Second thing you want to do, after you've
constructed your clip, you have a choice.

00:12:16.009 --> 00:12:20.340
You can either set it to be the current clip
in your context, or if you're drawing an image,

00:12:20.340 --> 00:12:25.040
you can just simply create a masked image from the
clip, or you could just draw the clip yourself.

00:12:25.039 --> 00:12:30.709
So in this particular example I just you know,
created the clip with a shading, with a circular clip,

00:12:30.710 --> 00:12:34.889
added the texture on top of it, and then threw a
little highlight, and you can get something like that.

00:12:34.889 --> 00:12:35.889
So that's an example.

00:12:35.889 --> 00:12:39.350
And you can sort of reuse that
clip object every single time.

00:12:39.350 --> 00:12:42.600
Just say ClipToMask, and away you go.

00:12:42.600 --> 00:12:48.050
Okay. So now let's talk about, we know how
to create the thing, the stencil that we want

00:12:48.049 --> 00:12:50.299
to pour our paint to, pour our paint into.

00:12:50.299 --> 00:12:57.629
Now we want to talk a little bit about how to
create the paint that you want to pour into there.

00:12:57.629 --> 00:12:59.759
So we're going to talk a little bit about colorized objects.

00:12:59.759 --> 00:13:03.659
First up a thing that you guys use all the time, ColorRefs.

00:13:03.659 --> 00:13:13.360
ColorRefs are definitely much faster than sort
of saying set RGB color, or set CMYK color.

00:13:13.360 --> 00:13:18.320
If you have a color, you can just create
the color object and reset the object.

00:13:18.320 --> 00:13:26.070
Colors represent either single colors, like a color like a
spot color like red, green, or blue, as well as patterns.

00:13:26.070 --> 00:13:32.100
They're the thing that is sort of an infinite sheet of just
color, and that infinite sheet can be a constant color,

00:13:32.100 --> 00:13:34.980
or the infinite sheet could be a replicated pattern.

00:13:34.980 --> 00:13:42.139
So we have some, for spot color examples, we have
new API for Leopard, where it allows you to sort

00:13:42.139 --> 00:13:45.699
of create a generic RGB color, or
gray color, or something like that.

00:13:45.700 --> 00:13:50.100
So you can definitely start using those APIs, instead
of having to go in and find the colored space,

00:13:50.100 --> 00:13:52.550
then go and create the object and never use it.

00:13:52.549 --> 00:13:53.949
It can be in APIs.

00:13:53.950 --> 00:13:58.620
Patterns as I said before, patterns are
sort of wrap, interior components of colors.

00:13:58.620 --> 00:14:01.330
You create your pattern, which
represents your arbitrary drawing.

00:14:01.330 --> 00:14:03.850
It could be an image, it could be a
PDF document, it could be anything.

00:14:03.850 --> 00:14:06.399
And then you stick it inside the
color and say this is the thing I want

00:14:06.399 --> 00:14:09.889
to do my infinite sheet of fill with, all right.

00:14:09.889 --> 00:14:14.179
It's obviously much faster than just going through and
setting up the clip, and drawing, drawing, drawing,

00:14:14.179 --> 00:14:15.599
drawing, drawing, drawing, drawing, right.

00:14:15.600 --> 00:14:18.899
So you basically set this pattern up,
give us a representation of the pattern,

00:14:18.899 --> 00:14:22.480
and you just set that to be your current
color, and you fill your current color.

00:14:22.480 --> 00:14:26.029
One thing about patterns that you need to be
cautious about is about how it replicates.

00:14:26.029 --> 00:14:30.839
If you want sort of consistent spacing, or sort of pixel
aligned spacing, either you try and do it yourself,

00:14:30.840 --> 00:14:37.600
which is not always possible, or you try and use that
constant, which is a PatternTilingConstantSpacing.

00:14:37.600 --> 00:14:39.750
So great, we spoke about patterns and colors.

00:14:39.750 --> 00:14:45.100
So yes, they're one of the objects that you can hold
onto, and if you hold onto it will do nicer things.

00:14:45.100 --> 00:14:49.940
In the case of colors, color matching sometimes
can be expensive, so if you reuse your ColorRef

00:14:49.940 --> 00:14:54.920
and we see the ColorRef again, we would say
hey, I can look it up in my cache, bam, got it.

00:14:54.919 --> 00:14:55.759
Similarly with patterns.

00:14:55.759 --> 00:14:59.720
Patterns are a little bit more complicated in the
sense that just because you've described a pattern,

00:14:59.720 --> 00:15:04.290
which was that shade that you see, it is really
sort of, there's a lot of work that has to go on,

00:15:04.289 --> 00:15:07.240
especially if the actual pattern contained a PDF document.

00:15:07.240 --> 00:15:12.610
We have to go in and rescan, convert, and we have to recolor
match, you know, to calculate everything that we need

00:15:12.610 --> 00:15:15.870
to in order to get this key cell,
which then gets replicated.

00:15:15.870 --> 00:15:20.789
So holding on to the PatternRef and reusing that PatternRef
in the form of a color is definitely going to say,

00:15:20.789 --> 00:15:24.919
going to give us the ability to go and
fetch that representation in the cache,

00:15:24.919 --> 00:15:27.399
and then reuse that to go and do replication.

00:15:27.399 --> 00:15:31.629
And always, about the state changes, we sort of minimize.

00:15:31.629 --> 00:15:36.419
There are lots of cases when you want to sort of
say great, I'm going to be drawing my black text,

00:15:36.419 --> 00:15:41.919
you draw your black text, then you draw your red highlights,
you know, so that you can reorganize your data around trying

00:15:41.919 --> 00:15:45.750
to minimize your state changes,
that would also be beneficial.

00:15:45.750 --> 00:15:49.149
Okay, so shadings.

00:15:49.149 --> 00:15:54.029
Shadings and gradients are obviously
transitions between two colors, or smooth colors.

00:15:54.029 --> 00:15:58.879
I shouldn't say two colors, they're
arbitrary transitions between colors.

00:15:58.879 --> 00:16:04.289
They're definitely much better than
trying to create the shading yourself.

00:16:04.289 --> 00:16:10.759
A lot of documents that were sort of PostScript generated
back to PDF have this kind of misbehavior where they,

00:16:10.759 --> 00:16:15.250
because there was no shading in PostScript
prior, they would basically go in and draw,

00:16:15.250 --> 00:16:17.620
start to draw a whole bunch of
lines in order to make the gradient.

00:16:17.620 --> 00:16:19.429
That's super painful, right.

00:16:19.429 --> 00:16:24.379
And PDF does support shadings, we support
shadings, and shadings are sort of you know,

00:16:24.379 --> 00:16:27.409
a common thing of how to do transitions between colors.

00:16:27.409 --> 00:16:31.289
So definitely it's much faster, you should always use them.

00:16:31.289 --> 00:16:36.309
And your performance would be increased.

00:16:36.309 --> 00:16:40.929
Shadings and gradients are also objects that we cache.

00:16:40.929 --> 00:16:47.429
So if you had a shading that you were using, and you wanted
to reuse that, that would be a much more beneficial thing,

00:16:47.429 --> 00:16:52.429
because we would, if we constructed something at a
particular resolution, did sampling on our function,

00:16:52.429 --> 00:16:55.739
when you reuse that object and you give
it to us again, we'll say hey great,

00:16:55.740 --> 00:16:57.480
we have this in the cache, we can reuse it.

00:16:57.480 --> 00:17:00.310
But more specifically to do with shadings.

00:17:00.309 --> 00:17:04.240
Shadings, gradients are just basically
transition between two colors, right.

00:17:04.240 --> 00:17:06.180
It's a linear transition.

00:17:06.180 --> 00:17:12.049
Functions are a little bit more general, or
shadings have the ability to specify shapes.

00:17:12.049 --> 00:17:16.629
Shadings have the ability to specify
things more general than just a gradient.

00:17:16.630 --> 00:17:22.790
So if you create a function, which
basically represents your sampling point,

00:17:22.789 --> 00:17:24.460
it could be non-linear, it doesn't really matter.

00:17:24.460 --> 00:17:29.160
It's a, the shadings are evaluated by callback, and
you can do whatever you want inside that callback.

00:17:29.160 --> 00:17:31.940
So it's important to try and sort
of minimize what you do, you know,

00:17:31.940 --> 00:17:35.640
don't go off and touch the disk you
know, to go and do a sample point.

00:17:35.640 --> 00:17:41.590
You know, just sort of try and make it as optimal as
possible, because at any point in time the shading is sort

00:17:41.589 --> 00:17:46.089
of re-evaluated as you draw different,
sorry, the function is re-evaluated

00:17:46.089 --> 00:17:48.039
as you draw different shadings that use that.

00:17:48.039 --> 00:17:52.490
So in that particular example I had one
shading, and I basically, sorry, one function,

00:17:52.490 --> 00:17:55.240
and I basically reused it across a bunch of shadings.

00:17:55.240 --> 00:18:00.309
So definitely you want to reuse your functions,
and you want to implement them efficiently.

00:18:01.380 --> 00:18:05.570
So we spoke about colors and coverage.

00:18:05.569 --> 00:18:11.200
You know, we really sort of didn't actually talk
about colorspaces, like what, what is my color?

00:18:11.200 --> 00:18:12.170
What space is my color?

00:18:12.170 --> 00:18:12.610
Is it red?

00:18:12.609 --> 00:18:13.119
Is it green?

00:18:13.119 --> 00:18:13.799
What is it?

00:18:13.799 --> 00:18:20.269
You should try and be very cautious
about colorspaces that you use, right.

00:18:20.269 --> 00:18:24.480
If you have gray or black, you should
typically just say gray or black.

00:18:24.480 --> 00:18:29.610
Don't try and say okay great, I'm going to set my
RGB components to my, to all the same color,

00:18:29.609 --> 00:18:33.019
cause they actually aren't you know, the exact same color.

00:18:33.019 --> 00:18:36.079
And this is also very true for gradients, right.

00:18:36.079 --> 00:18:41.509
An RGB gradient is a very, very different thing than just
a simple gray gradient, if all the RGB values are equal.

00:18:41.509 --> 00:18:44.920
So you want to use the appropriate colorspace.

00:18:44.920 --> 00:18:47.700
Second point is you always want
to use calibrated colorspaces.

00:18:47.700 --> 00:18:54.120
People sometimes you know, from way back when got accustomed
to using device RGB, that's not always a very good thing.

00:18:54.119 --> 00:18:58.699
In fact it's a very bad thing, because you actually
don't know what the output representations going to be.

00:18:58.700 --> 00:19:04.740
You could be like a Mac Mini plugged into TV, you could have
gotten one of those brand new Sony TVs with a huge Y gamma.

00:19:04.740 --> 00:19:10.359
And if you don't actually say what you know, the
color is really with respect to one colorspace,

00:19:10.359 --> 00:19:15.990
we don't really know exactly what to do, and we
produce you know, cyan, electric cyan on displays

00:19:15.990 --> 00:19:21.609
that really that's not the color what you wanted,
you wanted a red that was a red in this colorspace.

00:19:21.609 --> 00:19:25.699
So you should choose the appropriate
colorspace that looks good for you,

00:19:25.700 --> 00:19:28.370
and you say this is what I want to present to my users.

00:19:28.369 --> 00:19:32.069
So definitely you want to always
use calibrated colorspaces.

00:19:32.069 --> 00:19:36.230
Quartz Debug has a new feature that
will allow you to sort of you know,

00:19:36.230 --> 00:19:40.690
colorize your usage of uncalibrated colorspaces.

00:19:40.690 --> 00:19:44.890
So if you have line art or images, it'll just sort
of produce a different color, and you say hey yeah,

00:19:44.890 --> 00:19:47.950
I used, I filled this line with a device RGB.

00:19:47.950 --> 00:19:50.970
So that is definitely available.

00:19:50.970 --> 00:19:56.440
And we've also added new APIs for Leopard, which allow
you to say, instead of trying to find out some colorspace

00:19:56.440 --> 00:19:59.490
and go and get some profile from the
disk, you just basically, they're by name,

00:19:59.490 --> 00:20:06.680
you can say give me a generic RGB, or give
me a linear SRGB, you know, as constants.

00:20:06.680 --> 00:20:13.480
So you can get colorspaces that way, and then construct
your colors or your shadings, or your images, or whatever.

00:20:13.480 --> 00:20:17.460
Second point about colors and trying to fill area.

00:20:17.460 --> 00:20:19.759
Transparency.

00:20:19.759 --> 00:20:22.369
Transparency's really cool, it has great effects.

00:20:22.369 --> 00:20:25.769
But it's expensive, it basically
cuts your fill rate in half.

00:20:25.769 --> 00:20:30.180
Cause every time we need to draw something that
is partially transparent, it requires us to go in

00:20:30.180 --> 00:20:34.880
and blend with the destination and the source
in order to choose the final pixel.

00:20:34.880 --> 00:20:39.810
On your right here's an example of the San Francisco Bridge.

00:20:39.809 --> 00:20:44.519
And a transparent image is put on top of it.

00:20:44.519 --> 00:20:50.900
We don't actually know, because you basically said there's
transparency in for instance, an image or something.

00:20:50.900 --> 00:20:55.060
We don't know exactly which pixels are opaque and
which are not, so we basically have to run through

00:20:55.059 --> 00:20:59.460
and do a per pixel operation, which
requires us to fetch a destination.

00:20:59.460 --> 00:21:04.789
In a case of the other case where it's actually
just you know, opaque, and you set it to be opaque,

00:21:04.789 --> 00:21:09.769
we just never ever contact the destination, we just
simply slam the data down onto the destination.

00:21:09.769 --> 00:21:15.799
Now, if that image actually contained alpha
in it where all the alpha was FFF, similarly,

00:21:15.799 --> 00:21:19.139
you would be in a bad situation too, because
we'd still be doing per pixel operations

00:21:19.140 --> 00:21:21.670
in order to find out what has to happen.

00:21:21.670 --> 00:21:27.120
So definitely stay away from, if you can
I should say, even though alpha's sexy,

00:21:27.119 --> 00:21:33.099
you should stay away from needlessly putting alpha into
your objects when they don't necessarily need to be there.

00:21:33.099 --> 00:21:37.379
Another thing that people sometimes
do is sort of fade objects.

00:21:37.380 --> 00:21:41.950
We have a constant that's been, sorry, a function
that's been available on a context (inaudible)

00:21:41.950 --> 00:21:45.200
which basically allows you to set a global alpha, right.

00:21:45.200 --> 00:21:49.940
So if you want your entire PDF document faded out by
50%, or an image faded out by 50%,

00:21:49.940 --> 00:21:56.789
or whatever, you could just basically set that
constant, say okay draw my image, instead of you know,

00:21:56.789 --> 00:21:59.769
trying to create an image that
has alpha in it at 50%,

00:21:59.769 --> 00:22:06.230
or trying to draw the image that's your PDF document
off screen at 50%, or you know, anything else.

00:22:06.230 --> 00:22:11.839
Just very simple call, just make that
call and draw it, and then you'd be fine.

00:22:11.839 --> 00:22:18.449
We've also added new blend modes, the Porter-Duff
blend modes to the CG context.

00:22:18.450 --> 00:22:23.769
Now you have to be cautious about using these blend modes,
because they're not easily representable on print material.

00:22:23.769 --> 00:22:28.329
So what ends up happening is that you end up conceptually
going on the transparency printing path, which is not,

00:22:28.329 --> 00:22:31.149
may not have been what, exactly what you wanted to do.

00:22:31.150 --> 00:22:36.870
So you have to use them cautiously, which,
so the Porter-Duff compositing modes are new.

00:22:36.869 --> 00:22:41.729
But previously we had PDF blend modes,
those can be represented and printed.

00:22:41.730 --> 00:22:46.190
So if you try and switch over because Porter-Duff
is a lot nicer, and there's lots of new features,

00:22:46.190 --> 00:22:49.190
there's lots of features that Porter-
Duff supports that aren't

00:22:49.190 --> 00:22:52.890
in the usual PDF set, you can use
the Porter-Duff modes fine.

00:22:52.890 --> 00:22:57.680
But just be cautious about what happens
when you're actually going to the printer.

00:22:57.680 --> 00:23:02.390
Okay, so let's talk about the workhorse images.

00:23:02.390 --> 00:23:05.430
Images are images, they're all over the place.

00:23:05.430 --> 00:23:10.680
And they are basically containers full of color and alpha.

00:23:10.680 --> 00:23:16.600
Arbitrary colorspace, arbitrary number of
components, arbitrary depth, optional decode,

00:23:16.599 --> 00:23:20.449
there's a whole bunch of parameters
that you can pass in image creation.

00:23:20.450 --> 00:23:26.269
Images are probably the biggest thing we cache, because
sometimes they're expensive, and sometimes the operations

00:23:26.269 --> 00:23:28.730
that you try to do with them are also very expensive.

00:23:28.730 --> 00:23:32.500
So most of the stuff that sits in
our cache is basically about images.

00:23:32.500 --> 00:23:40.480
One sort of general note about images is that you can
actually control the interpolation quality when you come to,

00:23:40.480 --> 00:23:43.579
when you actually start to scale your images.

00:23:43.579 --> 00:23:50.179
New for Leopard is the low interpolation quality mode
actually now does something a little bit more enhanced.

00:23:50.180 --> 00:23:51.509
It does an area sample.

00:23:51.509 --> 00:23:57.450
High does lancose which is a two lobe thing,
or three lobe thing,

00:23:57.450 --> 00:24:02.110
and gives you much better quality, and low slightly less.

00:24:02.109 --> 00:24:07.389
None is obviously just point sampling, and
default is whatever the context chooses to,

00:24:07.390 --> 00:24:12.810
which is going to be not none, but
something, but not necessarily low either.

00:24:12.809 --> 00:24:15.740
So definitely you want to use them to your advantages,

00:24:15.740 --> 00:24:22.069
and we'll talk about that coming
up on next, on subsequent slides.

00:24:22.069 --> 00:24:26.309
Okay. So let's talk a little bit about
things that you should know about images.

00:24:26.309 --> 00:24:29.179
This is when you're actually constructing
images yourself, right.

00:24:29.180 --> 00:24:32.019
So people sort of okay, we construct an image

00:24:32.019 --> 00:24:34.889
and it has a parameter called bytes-per-row,
what is that?

00:24:34.890 --> 00:24:37.340
Well it's the actual skip to the next gamma line.

00:24:37.339 --> 00:24:38.339
What should that number be?

00:24:38.339 --> 00:24:45.220
Well the number should at least be the number, at
least be congruent to the size of your pixel, right.

00:24:45.220 --> 00:24:49.279
You have24-bit pixel, you
probably want to choose a multiple of that.

00:24:49.279 --> 00:24:55.470
Next up from that, cache line or vector alignment,
those are all good, those make us go faster.

00:24:55.470 --> 00:25:02.480
So patting them out, yes they increase the size of your
image, but for large images it may not be that much

00:25:02.480 --> 00:25:07.410
of a factor, but it definitely improves the image
handling and the image pipeline when you do that.

00:25:07.410 --> 00:25:09.740
Component sizes.

00:25:09.740 --> 00:25:13.250
Bytes, shorts, and ints, and floats, they're all good.

00:25:13.250 --> 00:25:19.380
For Leopard we've actually widened the
pipeline, and basically allowed the image

00:25:19.380 --> 00:25:21.620
to dictate how deep the pipeline should be.

00:25:21.619 --> 00:25:25.409
A lot of people got surprised in Leopard when
they would actually create floating point images,

00:25:25.410 --> 00:25:31.160
and have them unfortunately bottleneck through you
know, 8-bit image, eight bit per component.

00:25:31.160 --> 00:25:34.170
So now for Leopard, the pipelines are
completely deep, you draw a floating point image,

00:25:34.170 --> 00:25:35.539
you're going to get floating point on the other side.

00:25:35.539 --> 00:25:39.680
And that's especially useful and nice when you
actually have a floating point destination,

00:25:39.680 --> 00:25:43.930
which is not actually new for Leopard, we had that before.

00:25:43.930 --> 00:25:49.370
We've also deepened the actual destinations, in the sense
that now you can actually have short bitmap context.

00:25:49.369 --> 00:25:55.339
So you can actually draw yourself through your, the image
pipeline, it'll actually, if you have a short destination,

00:25:55.339 --> 00:25:58.779
short component size destination,
it'll actually record your short data.

00:25:58.779 --> 00:26:00.170
So definitely those are all good.

00:26:00.170 --> 00:26:06.350
If you have, formats that are like 11-bit,
you know, 17-bit, those kind of numbers,

00:26:06.349 --> 00:26:08.649
you may not be going down the fastest path possible.

00:26:08.650 --> 00:26:15.380
So if you can, sort of align things
up to some reasonable size.

00:26:15.380 --> 00:26:17.540
Transparency.

00:26:17.539 --> 00:26:21.490
Can you tell that's my favorite topic?

00:26:21.490 --> 00:26:27.430
Transparencies, transparency is
great, but more specifically to do

00:26:27.430 --> 00:26:31.110
with pre-multiplication when it comes to specifying images.

00:26:31.109 --> 00:26:33.229
Pre-multiplication allows us to avoid a whole bunch

00:26:33.230 --> 00:26:37.620
of expensive calculations, when
actually blending to destination.

00:26:37.619 --> 00:26:39.729
But sometimes they get in the way.

00:26:39.730 --> 00:26:44.490
When we actually have to color match data, we actually have
to unpre-multiply the data in order to do color matching.

00:26:44.490 --> 00:26:49.180
When we have to do interpolation, well we actually
have to have it pre-multiplied in order to do it.

00:26:49.180 --> 00:26:53.740
So the basic point of this slide is that if
you need to manipulate the pixels themselves,

00:26:53.740 --> 00:26:56.759
or you're generating the pixels themselves,
and it's more efficient for you to work

00:26:56.759 --> 00:26:59.549
with pre-multiplied data, then by all means do so.

00:26:59.549 --> 00:27:03.349
If the data came to you unpre-multiplied,
don't try and pre-multiply for us.

00:27:03.349 --> 00:27:07.719
We know, we have fast vectorizer teams that'll
do that, and we know under what situations we can

00:27:07.720 --> 00:27:09.890
or should or shouldn't do pre-multiplication.

00:27:09.890 --> 00:27:11.800
So if you have unpre-multiplied data,

00:27:11.799 --> 00:27:15.720
whatever the pre-multiplied state is
of your input data, just give it to us.

00:27:15.720 --> 00:27:22.210
Don't try and do anything, unless
you need to modify them yourself.

00:27:22.210 --> 00:27:23.110
Endianess.

00:27:23.109 --> 00:27:27.089
This showed up for late ended Tiger, which
is basically because we started to switch

00:27:27.089 --> 00:27:31.529
over to non big endian machines, and consequently endian.

00:27:31.529 --> 00:27:38.149
So this constant, or these constants in this API
showed up for exactly this purpose, how to handle this.

00:27:38.150 --> 00:27:42.140
So typically, if you're actually generating
an image, you might want to manipulate pixels.

00:27:42.140 --> 00:27:45.830
So if you have an RGB 32-bit
pixel, you might want to say okay,

00:27:45.829 --> 00:27:50.119
take red and shift it up by 24
bits, take green, and you manipulate that.

00:27:50.119 --> 00:27:57.439
If you write that into a stream, what actually ends
up is in memory, the data is actually flipped around.

00:27:57.440 --> 00:28:01.880
So lots of people do this, and we have to provide
some particular facility for you to say look,

00:28:01.880 --> 00:28:06.450
I'm going to lay down a bunch of shorts, and they're
going to be shorts because I dealt with the data,

00:28:06.450 --> 00:28:09.690
and it's on a linear machine I want to lay down shorts.

00:28:09.690 --> 00:28:15.430
Because effectively image data inside of the images
that are provided by the data providers are more

00:28:15.430 --> 00:28:19.470
or less big endian streams, most significant
byte followed by least significant byte.

00:28:19.470 --> 00:28:21.480
And (inaudible) on your Intel machine
and you try and do that,

00:28:21.480 --> 00:28:25.140
and you write that out by just writing
out the ints, it's actually swapped.

00:28:25.140 --> 00:28:28.610
So definitely you should do those.

00:28:28.609 --> 00:28:33.229
So you can set up the byte order
constants to specify whether

00:28:33.230 --> 00:28:36.950
or not you're 16-bit or 32-bit
swapped, basically.

00:28:36.950 --> 00:28:46.750
And you can set that on your image info when you create it,
and you can pass your data unmodified directly to image.

00:28:46.750 --> 00:28:50.930
That being said, if you're actually looking at image
data, you're on the receiving end of the image,

00:28:50.930 --> 00:28:54.049
you actually have to be prepared
to handle these cases, right.

00:28:54.049 --> 00:28:56.839
So basically you want to do whatever you have to do.

00:28:56.839 --> 00:29:00.839
You read the constant, figure it
out, it's like it's swapping data.

00:29:00.839 --> 00:29:05.289
And of course you need to use sort of
the endianess that, when it makes sense.

00:29:05.289 --> 00:29:10.569
You get, you can get situations like this where somebody
has an RGB image, it's obviously 24-bit,

00:29:10.569 --> 00:29:16.179
but they specified a 32-bit endian
swap thingie, that's just kind of dumb.

00:29:16.180 --> 00:29:26.549
So definitely don't do that, be nice and play fair, and be,
make other people further down the chain from you happier.

00:29:26.549 --> 00:29:31.539
Okay. So that's enough about sort
of creating your own image.

00:29:31.539 --> 00:29:33.920
So what happens if you actually
want to get an image from someplace?

00:29:33.920 --> 00:29:36.710
It's on disk, you need to, or you need to write it
out to disk.

00:29:36.710 --> 00:29:43.309
ImageIO was created for Tiger, and it's a very great,
good, and we've collected basically all the JPEG libraries,

00:29:43.309 --> 00:29:48.049
and all the TIFF libraries, and all the p and g libraries
from all over the place, and compressed it into one.

00:29:48.049 --> 00:29:53.180
So now we have just basically one source, a bunch
of very talented guys that go and work on stuff,

00:29:53.180 --> 00:30:00.390
and they basically Altivec it, SSE it you know, so
it's, don't sort of drag your own image decompression

00:30:00.390 --> 00:30:02.230
or compression libraries with you, because we have them.

00:30:02.230 --> 00:30:06.240
They're on the platform, they're the fastest
that we, you know, they can be on a platform,

00:30:06.240 --> 00:30:09.230
so definitely you should just basically use ImageIO.

00:30:09.230 --> 00:30:13.910
So in addition to that, there's lots of
nice little bells and whistles on ImageIO.

00:30:13.910 --> 00:30:20.690
You can you know, supports a rich set of
formats, RAW, OpenEXR, all the web standards.

00:30:20.690 --> 00:30:23.200
You know, so any kind of image that
you can see, you probably just give it

00:30:23.200 --> 00:30:25.360
to ImageIO, suck it up, and say here's your image.

00:30:25.359 --> 00:30:27.399
So definitely you want to take a look at that.

00:30:27.400 --> 00:30:29.019
Also has features for incremental loading.

00:30:29.019 --> 00:30:33.180
For instance if your Safari uses it as it's
actually getting the stream data from the websites

00:30:33.180 --> 00:30:35.480
that are actually incrementally
loading it into the image source,

00:30:35.480 --> 00:30:39.180
and then the final thing is they get the
image and they draw the image to the screen.

00:30:39.180 --> 00:30:45.769
It also provides image manipulation, like rotation,
shares, stuff like that, it does fairly primitive stuff.

00:30:45.769 --> 00:30:53.379
There are also some additional features on image, in
image sources where you can ask for thumbnails, right.

00:30:53.380 --> 00:30:59.360
You want to have a reduced size, as well as you know,
because you might be drawing an image over and over again

00:30:59.359 --> 00:31:02.189
and it's always going to be decompressing,
you might want to say actually no,

00:31:02.190 --> 00:31:05.480
I want you to just decompress it
once, and put it, cache it in memory.

00:31:05.480 --> 00:31:08.710
So there's these options when you
ask for images, you can set these up.

00:31:08.710 --> 00:31:14.910
There's one interesting thing that I actually bumped into
just you know, a few weeks ago where I had a RAW image,

00:31:14.910 --> 00:31:19.670
and if I asked for a thumbnail at a reduced size, it
actually went down a much faster code path in order

00:31:19.670 --> 00:31:25.140
to construct the data, because the actual processing
was a lot, the processing required was a lot less.

00:31:25.140 --> 00:31:28.590
You didn't have to go through the full
debayering process to construct your image.

00:31:28.589 --> 00:31:34.829
So if you asked for thumbnails, it reduced like little
tiny, you know, you want to do a quick shot of the image.

00:31:34.829 --> 00:31:39.319
Like you have RAW image and you want to display something
really quickly, while you go run off and do the real work,

00:31:39.319 --> 00:31:43.960
you can ask for this thumbnail at reduced size, and
then show that as a poster, posted frame let's say,

00:31:43.960 --> 00:31:47.230
while you're actually processing
and fetching the real image.

00:31:47.230 --> 00:31:53.309
So definitely you might want to use that.

00:31:53.309 --> 00:31:56.339
So one additional point is about caching.

00:31:56.339 --> 00:32:00.750
People say hey, you know, I'd like to
cache because I think I have a problem.

00:32:00.750 --> 00:32:07.099
So this sometimes is a little bit problematic, in the sense
that you'd like to cache, and somebody else is caching,

00:32:07.099 --> 00:32:09.480
so then we have two caches that don't know about each other.

00:32:09.480 --> 00:32:14.660
So what you really should do is try and sort of make sure
that there is a performance benefit for caching, right.

00:32:14.660 --> 00:32:19.720
This is definitely a case of pre-optimization
that you kind of want to avoid.

00:32:19.720 --> 00:32:27.480
So you need to make sure that there's a benefit, one, and
you need to be aware of the cost of doing your own caching.

00:32:27.480 --> 00:32:32.420
And you also need to be committed
to managing the cache effectively.

00:32:32.420 --> 00:32:34.490
The cache and the stash are two different things, you know.

00:32:34.490 --> 00:32:40.039
A stash is basically oh I saw it, let's just put
it memory, versus something that actually ages.

00:32:40.039 --> 00:32:44.950
And always remember back to the original slide,
first slide, be cognizant of memory consumption.

00:32:44.950 --> 00:32:49.400
When you start creating these caches, you're just
basically making pages for the VM system to page up.

00:32:49.400 --> 00:32:53.970
So definitely, you have to be committed
to managing it correctly.

00:32:55.410 --> 00:32:58.509
Images are supplied by data providers.

00:32:58.509 --> 00:33:05.059
Data providers basically are the means by which
the data gets to the image and gets represented.

00:33:05.059 --> 00:33:07.839
These objects can be used to your advantage, right.

00:33:07.839 --> 00:33:14.470
You can simply say, on my first fetch of
my data, that's when I do my decompress.

00:33:14.470 --> 00:33:20.400
And then you supply the image to the data, sorry, the
data to the image, and then some time later you might want

00:33:20.400 --> 00:33:25.060
to just discard the memory, cause
it's been sitting there for you know,

00:33:25.059 --> 00:33:27.809
six hours or something, so you might want to discard it.

00:33:27.809 --> 00:33:32.619
So you can sort of decouple the image usage from
the actual decompression, and sort of do you know,

00:33:32.619 --> 00:33:37.209
fancy stuff to discard memory on you
know, when it's no longer needed.

00:33:37.210 --> 00:33:43.559
So definitely data providers, you
might want to look into that.

00:33:43.559 --> 00:33:48.879
Another way of caching is to actually just
say well, even inside of a data provider,

00:33:48.880 --> 00:33:52.630
the data provider says get me the byte point, or
you say okay great, I need to provide the data.

00:33:52.630 --> 00:33:56.080
I've got my image, let's go in
and construct the data right now.

00:33:56.079 --> 00:34:00.250
So what you would normally do is just basically
create a bitmap context of the appropriate size

00:34:00.250 --> 00:34:07.140
and colorspace, and a format, and then you
simply draw the original image into the bitmap context.

00:34:07.140 --> 00:34:12.000
And then you ask the bitmap context to give
you back the image, or you can actually,

00:34:12.000 --> 00:34:14.789
because you've created the bitmap
context, you can supply the data point

00:34:14.789 --> 00:34:17.920
as you can create the image yourself,
and the data provider yourself.

00:34:17.920 --> 00:34:23.170
And then you draw the resultant image, or in
this particular, in the example that I gave you,

00:34:23.170 --> 00:34:25.880
you actually just populated the
memory for the data provider.

00:34:25.880 --> 00:34:28.390
And then you just draw that instead of the original image.

00:34:28.389 --> 00:34:30.879
And therefore bing, bang, boom, you get caching.

00:34:30.880 --> 00:34:36.420
So let's look at the creation part a little bit more.

00:34:36.420 --> 00:34:39.710
Obviously you're going to be using BitmapContextCreate.

00:34:39.710 --> 00:34:43.280
Now if you actually don't need to manipulate
the pixels, it's much faster for you

00:34:43.280 --> 00:34:46.970
to just tell us you don't care about the memory, right.

00:34:46.969 --> 00:34:52.029
We go in, we create a chunk of memory that's
applicable to whatever system you're on,

00:34:52.030 --> 00:34:55.240
and with the right alignment you know, for speed.

00:34:55.239 --> 00:34:57.949
And when you draw, it draws into that memory.

00:34:57.949 --> 00:35:05.539
A second point is about creating
the correct format and colorspace.

00:35:05.539 --> 00:35:10.730
Easy example of that is the image source
was for instance, a grayscale image,

00:35:10.730 --> 00:35:15.670
and you created a bitmap context
that was RGB, and you added alpha.

00:35:15.670 --> 00:35:20.019
When you drew that opaque grayscale
image into that bitmap context,

00:35:20.019 --> 00:35:23.780
what will actually end up happening now is
that you'll get an RGB image with alpha.

00:35:23.780 --> 00:35:27.540
So now you've basically replicated the
data by three, and you've added alpha,

00:35:27.539 --> 00:35:32.420
which of course in the previous slides
we spoke about reducing your fill rate

00:35:32.420 --> 00:35:34.760
by actually introducing alpha when you didn't need to.

00:35:34.760 --> 00:35:39.500
So that's an example of trying to choose you know,
the appropriate number of components and colorspace

00:35:39.500 --> 00:35:42.449
for the source that you're trying to create.

00:35:42.449 --> 00:35:46.809
And of course, you know, use transparency effectively.

00:35:46.809 --> 00:35:53.920
Layers. Layers are basically general containers.

00:35:53.920 --> 00:35:56.510
They're device-dependent representations.

00:35:56.510 --> 00:36:01.210
You can simply create a layer from a
bitmap context, and you can draw, sorry,

00:36:01.210 --> 00:36:03.990
a context, and you can draw all of your content.

00:36:03.989 --> 00:36:08.079
Layers are primarily used to capture multiobjects,
like if you had a PDF document

00:36:08.079 --> 00:36:09.769
or you're drawing a whole bunch of stuff.

00:36:09.769 --> 00:36:13.539
Sometimes it's not advantageous, most times it's
not advantageous to actually just create a layer,

00:36:13.539 --> 00:36:16.179
to draw an image into it and then draw the layer instead.

00:36:16.179 --> 00:36:20.569
So definitely you want to sort of be
conservative about when you use these layers.

00:36:20.570 --> 00:36:26.050
So whenever possible you should try to
use layers instead of bitmap context,

00:36:26.050 --> 00:36:29.880
because they sort of simplify a lot of the details, right.

00:36:29.880 --> 00:36:33.829
We told about, we spoke about you know, creating
the right colorspace, the right bits per component,

00:36:33.829 --> 00:36:36.549
you know, all of these little nasty things.

00:36:36.550 --> 00:36:40.400
And what layers allow you to do is basically say
okay, given a context, I don't know what it is,

00:36:40.400 --> 00:36:45.250
it could be a PostScript context, it could be a PDF context,
it could be a bitmap context that's actually floating point,

00:36:45.250 --> 00:36:47.139
and the floating point bits are swapped, right.

00:36:47.139 --> 00:36:51.699
Asking that context for a layer gives you the best
representation, so that what you draw in it is more

00:36:51.699 --> 00:36:54.179
or less compatible with a destination, right.

00:36:54.179 --> 00:36:57.669
Whereas if you were to choose a bitmap context
approach, you'll have to figure out all these details,

00:36:57.670 --> 00:37:03.059
which is not all readily available to you, as opposed, you
know, in the case of for instance swap flow components.

00:37:03.059 --> 00:37:09.809
You might just say create flow little endian, and what
actually happens is that little endian float layer

00:37:09.809 --> 00:37:12.949
that you just, bitmap context that you
just created is drawn into the context,

00:37:12.949 --> 00:37:17.379
but the actual context is actually expecting big endian
float, so we have to do a whole bunch of conversions.

00:37:17.380 --> 00:37:21.269
So definitely if you want to basically get
something that's compatible with destination,

00:37:21.269 --> 00:37:24.300
create a LayerRef drawing to it, and then you, away you go.

00:37:24.300 --> 00:37:32.630
For transient type stuff, meaning that you just want
to draw a bunch of objects and have them all faded

00:37:32.630 --> 00:37:37.950
out by 50% for example, what you would normally
do, instead of creating a layer from a whole cloth,

00:37:37.949 --> 00:37:42.689
which is basically a separate independent object, you
can simply just, simply create a transparency layer,

00:37:42.690 --> 00:37:45.119
which is basically a sheet of acetate that you can draw on.

00:37:45.119 --> 00:37:49.679
You draw onto it, and then you say EndTransparencyLayer,
whatever you drew gets composited into destination based

00:37:49.679 --> 00:37:52.819
on the mode that was set, or the
clipping that was set, or the alpha,

00:37:52.820 --> 00:37:57.940
or the style that was set before you
actually began the transparency layer.

00:37:57.940 --> 00:38:02.740
One important point about that is when you say begin
transparency layer and it's completely unbounded,

00:38:02.739 --> 00:38:06.049
we have to more or less create a
transparency layer the size of the destination.

00:38:06.050 --> 00:38:08.180
So if you know that you want to draw on a particular area,

00:38:08.179 --> 00:38:11.569
it's advisable to set the clip before
you create the transparency layer,

00:38:11.570 --> 00:38:17.789
and that way we basically create transparency layer
that would capture everything that would be drawn.

00:38:17.789 --> 00:38:23.239
New APIs for Leopard would be CreateTransparencyLayer in
rectangle, where you say hey, I'm going to promise to draw

00:38:23.239 --> 00:38:27.419
in this area, and that area is a
rectangle specified in user space.

00:38:27.420 --> 00:38:32.349
And what we'd end up doing is we'd actually project
that user space rectangle to the destination,

00:38:32.349 --> 00:38:37.380
create a destination of that size at the right position,
where I'd format, etcetera, etcetera, and we'll draw,

00:38:37.380 --> 00:38:39.450
when you draw, it'll be captured correctly.

00:38:39.449 --> 00:38:43.109
This is explicitly useful when dealing with styles.

00:38:43.110 --> 00:38:47.360
Because a lot of the times you have styles, like
for instance shadow style or focus ring style.

00:38:47.360 --> 00:38:53.370
Those styles are very, it's not easily determined
exactly how much area you actually should draw.

00:38:53.369 --> 00:38:56.279
So you can use this new API, it's much more convenient.

00:38:56.280 --> 00:39:00.410
You just say here's a rectangle, make me, I'm going to
draw in this area, make me a transparency group,

00:39:00.409 --> 00:39:04.509
a transparency layer for it, draw
into it, and then you're done.

00:39:04.510 --> 00:39:09.000
Okay. So last little point about basically finding pixels.

00:39:09.000 --> 00:39:14.679
It's wise to hit pixel cracks.

00:39:14.679 --> 00:39:17.849
If you don't hit pixel cracks,
we do a little bit of extra work.

00:39:17.849 --> 00:39:23.279
So you might want to align your pixel crack,
align your drawing to pixel cracks, like images,

00:39:23.280 --> 00:39:28.010
you want to snap them out so you don't get
edges or blurring inside of your image.

00:39:28.010 --> 00:39:32.320
You can sort of adjust your pixel coordinates to
match exactly where you think you want to go in order

00:39:32.320 --> 00:39:36.690
to hit pixels, so we get you know, one to one mappings.

00:39:36.690 --> 00:39:41.179
HiDPI tends to add a little bit of complexity,
because you know, if it's completely scalable

00:39:41.179 --> 00:39:44.169
and you're not only locked in at 1X
2X, you end up having things

00:39:44.170 --> 00:39:47.250
that might basically be always straddling pixel boundaries.

00:39:47.250 --> 00:39:52.000
So it adds a little bit of additional complexity to trying
to figure out if you wanted to lay out UI and draw a bunch

00:39:52.000 --> 00:39:54.969
of controls, what do you have to do in order to make sure

00:39:54.969 --> 00:39:59.179
that you get a good representation
for the DPI that was specified.

00:39:59.179 --> 00:40:03.099
Way how to do that, ask the context for
the user space, the device space transform.

00:40:03.099 --> 00:40:09.130
You take your user space point, you transform it to your
device space point, and then you round in device space,

00:40:09.130 --> 00:40:15.260
and then you transform the point back to user space,
such that if you were to draw that user space,

00:40:15.260 --> 00:40:18.820
that new user space point, that
point will hit a device pixel.

00:40:18.820 --> 00:40:21.390
So that's kind of how you do that.

00:40:21.389 --> 00:40:27.589
Okay. So let's, we finished all the
optimizations, let's say more or less.

00:40:27.590 --> 00:40:35.329
And what we're going to do is talk a little bit about
even more optimizations, more specifically Quartz GL.

00:40:35.329 --> 00:40:37.449
So for those of you who don't know what Quartz GL,

00:40:37.449 --> 00:40:43.000
basically Quartz GL is a Quartz 2D
implementation on top of Open GL.

00:40:43.000 --> 00:40:51.800
Basically it allows us to offload the burden of
rendering, inputing, and blending onto the GPU.

00:40:51.800 --> 00:40:57.670
Using Quartz GL minimizes DMA transfers
that'll happen to and from the video card,

00:40:57.670 --> 00:41:04.650
and it has a much more efficient integration
model when dealing with other GPU-based subsystems.

00:41:04.650 --> 00:41:10.730
An example of that is obviously things like
Quartz Composer, Quartz GL, sorry, Open GL,

00:41:10.730 --> 00:41:14.409
Core Image is another one, and Core Animation.

00:41:14.409 --> 00:41:20.670
So while we ran off and did all this really
cool stuff, it's been in the works for a while,

00:41:20.670 --> 00:41:24.769
we discovered a really large set of lessons.

00:41:24.769 --> 00:41:30.690
One major lesson is that for a lot of applications,
rendering may not be the bottleneck, all right.

00:41:30.690 --> 00:41:36.690
You guys are running off fetching a disk or copying files,
or looking at the network or something, and you know,

00:41:36.690 --> 00:41:39.789
your actual application isn't really rendering bound.

00:41:39.789 --> 00:41:41.800
So that's one point.

00:41:41.800 --> 00:41:50.030
The second point, which is kind of not so surprising, but
it was kind of obvious, it was more that if you sort of try

00:41:50.030 --> 00:41:54.760
and use Quartz 2D in the ineff-icient model,
like you don't reuse your ImageRefs or colors,

00:41:54.760 --> 00:42:00.720
or anything like that, basically can be extremely
costly, especially in the GPU scenario, right.

00:42:00.719 --> 00:42:04.549
You don't tell us this is an image that
you're reusing again, we have no choice

00:42:04.550 --> 00:42:08.080
but to re-upload it to the card, and that's not fast, right.

00:42:08.079 --> 00:42:13.590
So definitely try to make sure that you
use the APIs in an efficient fashion,

00:42:13.590 --> 00:42:16.970
and you can get much better performance,
especially in the GPU scenario.

00:42:16.969 --> 00:42:21.730
Of course the good news is that if
you kind of us it, it'll go fast.

00:42:21.730 --> 00:42:27.559
Okay. So let's look at some stuff in more details.

00:42:27.559 --> 00:42:31.570
So why is the expense what it is?

00:42:31.570 --> 00:42:37.039
When I spoke about you know, the GPU scenario being
slightly more expensive than the CPU scenario, here's why.

00:42:37.039 --> 00:42:42.889
With Quartz 2D what normally happens is that you can
draw into backing storage, which reside in system memory

00:42:42.889 --> 00:42:49.299
at five gigabytes a second, six gigabytes a
second depending on what machine you're on.

00:42:49.300 --> 00:42:56.269
That stuff, once the data is actually in the backing
store, then gets sent to the Quartz Compositor,

00:42:56.269 --> 00:43:00.849
which actually basically DMAs it up from
the system memory into the video card.

00:43:00.849 --> 00:43:02.949
That happens at two gigabytes a second.

00:43:02.949 --> 00:43:05.109
Notice the number, two not five, two.

00:43:05.110 --> 00:43:10.269
The the Quartz Compositor blends it all
together and presents it to the screen.

00:43:10.269 --> 00:43:17.259
In the Quartz GL path what's actually happening is
that you're now putting data into the backing store

00:43:17.260 --> 00:43:19.600
at two gigabytes a second, remember that number two.

00:43:19.599 --> 00:43:24.360
But it's significantly less data, it has
nothing to do with the actual geometry.

00:43:24.360 --> 00:43:28.170
In terms of the area that's covered,
it merely has to do with what it is.

00:43:28.170 --> 00:43:32.610
It's a quad, it requires four vertices,
that's the data that you're actually sending.

00:43:32.610 --> 00:43:36.250
You're putting that stuff into a command
buffer, and that command buffer is going

00:43:36.250 --> 00:43:39.090
up at two gigabytes a second, up to the video card.

00:43:39.090 --> 00:43:43.740
And the actual filling, the actual area, the uploading
is actually done at thirty gigabytes a second.

00:43:43.739 --> 00:43:46.729
So you can see where those numbers sort of lopside.

00:43:46.730 --> 00:43:52.320
So let's take a look at a simple benchmark.

00:43:52.320 --> 00:43:56.870
Here I think we're trying to, we
might be trying to fill a rectangle.

00:43:56.869 --> 00:43:58.739
And we're filling a rectangle and flushing it.

00:43:58.739 --> 00:44:02.769
So you can see those numbers, this is
done in Mac Pro, you can see the numbers

00:44:02.769 --> 00:44:08.110
for Quartz 2D. Basically it's the draw
into my backing store, flush my backing store,

00:44:08.110 --> 00:44:12.940
that's 500 megabytes a second just
constantly pumping up to the video card.

00:44:12.940 --> 00:44:20.889
Quartz GL, well there's no backing store DMA going
on, it's zero, there's nothing to do right, it's gone.

00:44:20.889 --> 00:44:25.859
Command buffer traffic, you, Quartz 2D,
you draw into your backing store,

00:44:25.860 --> 00:44:29.920
and then when you tell the Quartz Compositor
to draw, it goes and lays a little command

00:44:29.920 --> 00:44:32.920
that says okay great, upload this data and draw this data.

00:44:32.920 --> 00:44:37.159
The Quartz GL case, well that's not the only traffic.

00:44:37.159 --> 00:44:41.609
The Quartz Compositor's putting its own traffic
going up to GPU, but you've also put the quads

00:44:41.610 --> 00:44:44.800
that you're actually drawing on the
command traffic that's going to the GPU.

00:44:44.800 --> 00:44:50.250
So that's 40, so it's you know,
four times, more or less, bigger.

00:44:50.250 --> 00:44:54.239
CPU utilization, well it's more or less the same.

00:44:54.239 --> 00:45:00.039
But the bottom line is basically that we get
four times the amount of updates per second.

00:45:00.039 --> 00:45:03.800
Of course we've thrown the Quartz Compositor
into a mode that you guys can't do,

00:45:03.800 --> 00:45:05.850
but it's just basically trying to measure traffic.

00:45:05.849 --> 00:45:10.460
And so yeah, you can get 8,000 frames per second.

00:45:10.460 --> 00:45:13.980
Don't try this at home.

00:45:13.980 --> 00:45:14.550
( laughter )

00:45:14.550 --> 00:45:19.110
Okay, so that's kind of cool, so
let's look at some more numbers.

00:45:19.110 --> 00:45:24.590
Here's a situation of trying to find out if I were given
100% of the CPU, what can I do with it?

00:45:24.590 --> 00:45:30.800
So for Quartz 2D obviously as -you draw more and more
pixels, we're actually trying to do an image operation,

00:45:30.800 --> 00:45:38.240
so we have to fetch an image and then write destination,
you can see that you're just basically dropping, right.

00:45:38.239 --> 00:45:41.969
I mean it's just going to go that way, because
you're just consuming more and more.

00:45:41.969 --> 00:45:46.599
You're maxing out your G, your CPU usage,
but you're doing less operations per second,

00:45:46.599 --> 00:45:50.769
because each operation for the image size is
getting larger and larger, so that's true.

00:45:50.769 --> 00:45:53.989
The Quartz GL case, it's slightly different.

00:45:53.989 --> 00:45:57.489
Yes it's no surprise, it does take
constant time to pack one quad.

00:45:57.489 --> 00:46:01.639
Doesn't matter how big the quad is,
it's just going to take constant time.

00:46:01.639 --> 00:46:07.829
So some of you might actually get it, and you're
thinking but that doesn't seem quite right.

00:46:07.829 --> 00:46:09.400
I mean you got to block some time, right?

00:46:09.400 --> 00:46:12.280
The GPU doesn't have infinite bandwidth.

00:46:12.280 --> 00:46:13.430
You're right.

00:46:13.429 --> 00:46:18.250
So let's actually look at what actually happens
if you were to say, measure in real time, right.

00:46:18.250 --> 00:46:22.989
You're not measuring if you max out the CPU, you
want to find out exactly how much can get done.

00:46:22.989 --> 00:46:27.899
Well this graph is not so great.

00:46:27.900 --> 00:46:37.369
For the Quartz GL case, you can see at the
small sizes we're actually not as fast as a CPU.

00:46:37.369 --> 00:46:39.599
The reason for that is that the actual data that goes

00:46:39.599 --> 00:46:43.559
into the command buffer is actually
larger than the area that you're filling.

00:46:43.559 --> 00:46:48.279
But at some point in time, actually it's kind of a sweet
spot, because you don't normally necessarily draw one

00:46:48.280 --> 00:46:53.590
by one things or two by two things, lots of images are
you know, 32 or 48 x 48.

00:46:53.590 --> 00:47:02.930
GLs start to take over, in that the CPU trying to draw
that area is actually taking more time than the GPU.

00:47:02.929 --> 00:47:07.389
And then the GPU starts to take off, and says
hey yeah, I'm winning, I'm much better than you.

00:47:07.389 --> 00:47:12.879
And then as the image sizes get to fly down
towards the end, they more or less sort of come off

00:47:12.880 --> 00:47:15.490
and say well, we're more or less the same.

00:47:15.489 --> 00:47:18.789
So that's not very encouraging results.

00:47:18.789 --> 00:47:24.809
But you really have to look at it a different way,
keep on switching the axis of the presentation.

00:47:24.809 --> 00:47:31.679
But anyway, if you look at it a different
way, and it's basically how much resources,

00:47:31.679 --> 00:47:35.409
how many resources are you consuming to do your work?

00:47:35.409 --> 00:47:39.159
We spoke about the G, the CPU scenario where
you're actually consuming all of your CPU

00:47:39.159 --> 00:47:41.750
to do the work, and that's the straight line at the top.

00:47:41.750 --> 00:47:45.570
The GPU scenario, well you're actually
using less and less of the GPU,

00:47:45.570 --> 00:47:48.200
but you're basically doing more or less the same area.

00:47:48.199 --> 00:47:51.699
Remember the previous graph, toward
the end it was more or less equivalent.

00:47:51.699 --> 00:47:57.589
So the GPU less, uses way less CPU in
order to do the same amount of work.

00:47:57.590 --> 00:47:58.150
Okay, great.

00:47:58.150 --> 00:48:00.559
That's fine for one particular application.

00:48:00.559 --> 00:48:05.480
But let's actually take a look at some of
the results that we see with Quartz GL turned

00:48:05.480 --> 00:48:08.329
on for a bunch of different applications.

00:48:08.329 --> 00:48:09.489
Text edit.

00:48:09.489 --> 00:48:15.349
Simple Text edit resize, simple flow document, it's
not rich text, plain text, 3X performance.

00:48:15.349 --> 00:48:21.089
The rich text format, there's a lot of kerning that goes
on, a lot of different types of fonts and stuff like that,

00:48:21.090 --> 00:48:24.350
that's not so, but it's still 70% improvement,p

00:48:24.349 --> 00:48:28.400
which is not bad for absolutely doing
nothing other than turning on a switch.

00:48:28.400 --> 00:48:35.079
Similarly, Safari scrolling, empty page,
terminal resize, that's a nice number,

00:48:35.079 --> 00:48:38.029
it's 2.3X. Mail resize, 170.

00:48:38.030 --> 00:48:40.730
So all you have to do is just turn
on the switch and do nothing,

00:48:40.730 --> 00:48:47.480
make sure you optimize your codes using it the right
way, and boom, you get you know, 40 to 3X,

00:48:47.480 --> 00:48:54.940
or 0.4X to 3 or 4, maybe even 5X
sometimes, depending on what hardware you're on.

00:48:54.940 --> 00:48:56.860
So that's nice for simple applications.

00:48:56.860 --> 00:49:00.930
So let's take a look at something more complicated.

00:49:00.929 --> 00:49:07.929
Here I have a situation where I have basically
four P of documents running away in the background,

00:49:07.929 --> 00:49:14.279
a 3D app running, clock running, frame meter running, a
whole bunch of stuff running, the entire desktop is all done

00:49:14.280 --> 00:49:18.390
with Quartz GL, just flip the switch on
everything and boom, it's all running.

00:49:18.389 --> 00:49:19.579
Let's see what that does.

00:49:19.579 --> 00:49:29.500
Well, as in the previous slide, Quartz 2D, if they
were drawn, if that exact demo was done with Quartz 2D,

00:49:29.500 --> 00:49:34.000
basically there's a whole bunch of DMA
traffic, 500 giga, megabytes a second.

00:49:34.000 --> 00:49:37.239
Quartz GL, nothing, there's no backing store to upload.

00:49:37.239 --> 00:49:43.779
Command DMA 30 megabytes a second, that's
just basically the Quartz Compositor using Open GL

00:49:43.780 --> 00:49:46.230
to get all those windows on screen, right.

00:49:46.230 --> 00:49:50.500
In the Quartz GL case, it's actually
the window server, or sorry,

00:49:50.500 --> 00:49:54.900
Quartz Compositor's code that's actually sending
the command data, plus the Quartz GL code

00:49:54.900 --> 00:49:57.430
to all of those PDF documents, all going away.

00:49:57.429 --> 00:50:00.489
And we're not even, it isn't double,
it's not even double, right.

00:50:00.489 --> 00:50:01.969
It's 47 versus 30.
0

00:50:01.969 --> 00:50:09.109
So we are consuming much less bandwidth, and more
or less doing the same amount of work, if not more.

00:50:09.110 --> 00:50:11.960
CPU utilization, well basically it's the same, right.

00:50:11.960 --> 00:50:16.900
They're, it's a quad, there are four documents
being passed, all done on separate threads,

00:50:16.900 --> 00:50:19.190
or basically maxing out the CPU more or less.

00:50:19.190 --> 00:50:26.090
But the bottom line is basically we get a little bit more
than 50% improvementP, just by flipping a switch.

00:50:26.090 --> 00:50:31.510
Okay. So how do you turn it on?

00:50:31.510 --> 00:50:37.590
All you developers, I can see you like sitting in your
seats all, I want to turn it on, I want to turn it on.

00:50:37.590 --> 00:50:38.410
It's really simple.

00:50:38.409 --> 00:50:43.069
You basically go into your, in Xcode, or you can
manually do it, info.plist, just turn that on,

00:50:43.070 --> 00:50:47.120
Quartz GL enabled set to true, boom,
your entire application's Quartz GL.

00:50:47.119 --> 00:50:50.269
Or you can be a little bit more cautious, and
since I don't want to turn it on for everything,

00:50:50.269 --> 00:50:54.579
I just want to turn it on a per window basis, because my
other windows, they don't really need hardware acceleration.

00:50:54.579 --> 00:51:01.130
You can turn it on by either asking the window to set its
preferred backing store if you're using NS, the Cocoa APIs,

00:51:01.130 --> 00:51:04.039
and for the carbon APIs it's same similar thing,

00:51:04.039 --> 00:51:07.809
you just set your preferred backing
store location to be video memory.

00:51:07.809 --> 00:51:11.179
Things you should know.

00:51:11.179 --> 00:51:17.289
It's important for you to try and figure
out exactly what camp you're in, right.

00:51:17.289 --> 00:51:23.789
There's one camp where you're basically trying to upload
a whole bunch of data, brand new images every single time,

00:51:23.789 --> 00:51:25.480
brand new line art, brand new everything.

00:51:25.480 --> 00:51:31.940
Basically all of those basically happen at the two
gigabytes a second transfer, versus the other count,

00:51:31.940 --> 00:51:37.380
which is typically user applications where
your objects are already on the card, right.

00:51:37.380 --> 00:51:41.420
You have all your textures and whatever, your fonts
and your glyphs, and you're just basically redrawing.

00:51:41.420 --> 00:51:46.710
So that's why for instance things like application
resize would, you would see performance benefit,

00:51:46.710 --> 00:51:48.769
because all this stuff is more or less cached.

00:51:48.769 --> 00:51:55.280
In the cases of for instance, like let's say your
web browser that's trying to get pages from the web,

00:51:55.280 --> 00:52:00.130
that particular scenario is basically this
brand new data every single frame, right.

00:52:00.130 --> 00:52:02.950
So the data's coming in off the network,
and you have to upload that data.

00:52:02.949 --> 00:52:04.679
So it depends on what kind of number you're dealing with.

00:52:04.679 --> 00:52:10.149
I don't necessarily think that people are going to
be able to click a new page at 60 hertz.

00:52:10.150 --> 00:52:14.059
What would be more interesting to them
is being able to resize at 60 hertz.

00:52:14.059 --> 00:52:20.769
So you have to figure out what the tradeoff
is for you, and where you're going to sit.

00:52:20.769 --> 00:52:23.190
Second point is about Core Image integration.

00:52:23.190 --> 00:52:31.139
A lot of work went into this, and a lot of people
sometimes create, the normal usage for Core Image is

00:52:31.139 --> 00:52:35.500
to basically have an image, and then you create
your Open GL, you create your CIOpenGL view,

00:52:35.500 --> 00:52:37.110
and you draw your Core Image stuff into there.

00:52:37.110 --> 00:52:45.710
What happens under the covers is that the Open GL surface
is more or less a sheet that sits on top of your window.

00:52:45.710 --> 00:52:51.530
So when you create those Open GL contexts, you end up
effectively burning that size memory into video memory.

00:52:51.530 --> 00:52:55.750
For a GL application that's great, it runs really fast.

00:52:55.750 --> 00:52:59.050
But for CI, depending on what you're
actually doing, you may not necessarily need

00:52:59.050 --> 00:53:00.900
to do that, so you can make that tradeoff.

00:53:00.900 --> 00:53:07.130
It's like do I need to create an OpenGLContext,
or do I just create a normal CICGContext.

00:53:07.130 --> 00:53:10.840
If you create a CICGContext, you
can draw your CI stuff into there,

00:53:10.840 --> 00:53:13.789
as well as you can put text highlights
and all sorts of nice things on it.

00:53:13.789 --> 00:53:16.969
So you don't have to write any Open GL code,
you don't have to sort of change things.

00:53:16.969 --> 00:53:22.509
You just say okay, I've got my CI, you use CI the way
it was, it's intended to just do image processing.

00:53:22.510 --> 00:53:25.490
And then you just draw it with your normal CICGContext.

00:53:25.489 --> 00:53:29.369
And you turn on Quartz GL, and it runs faster.

00:53:29.369 --> 00:53:32.569
Okay, other things.

00:53:32.570 --> 00:53:39.760
What you should do obviously is talk about the,
implement the optimizations, right, use Shark,

00:53:39.760 --> 00:53:45.130
use your different tools, figure out where you are, find
out what it's category, whether you're into new resource

00:53:45.130 --> 00:53:50.119
versus resource reuse case, and definitely do those things.

00:53:50.119 --> 00:53:54.679
So you basically turn it on, use Quartz
Debug to turn it on, test your applications.

00:53:54.679 --> 00:53:57.669
If you see an advantage and you want to opt in, opt in.

00:53:57.670 --> 00:54:01.409
If you see a disadvantage, and you
don't have time to optimize your code,

00:54:01.409 --> 00:54:04.089
just turn it off and start working on your code later.

00:54:04.090 --> 00:54:06.010
If you see neither, don't do anything.

00:54:06.010 --> 00:54:09.280
Don't explicitly enable it or disable
it, just leave it the way how it is.

00:54:09.280 --> 00:54:15.310
And of course don't forget to test
on different kinds of hardware.

00:54:15.309 --> 00:54:18.090
It's not like your stuff will break.

00:54:18.090 --> 00:54:22.510
If you happen to turn it on and you're running
on a G4 with a Rage 128,

00:54:22.510 --> 00:54:24.990
what actually happens is that that just gets disabled.

00:54:24.989 --> 00:54:30.929
So you don't really have to do any hardware-
specific changes to handle different hardware,

00:54:30.929 --> 00:54:34.509
it just automatically falls off, and
you get exactly what you get now.

00:54:34.510 --> 00:54:40.240
The thing about this feature is that it is not something
that is new, and therefore you can expect bugs.

00:54:40.239 --> 00:54:42.309
It's like you can't expect any bugs, right.

00:54:42.309 --> 00:54:47.940
It's a replacement, it's a way of drawing
what you used to draw before faster.

00:54:47.940 --> 00:54:52.110
So we tried to make sure that there are
absolutely no bugs, no visual anomalies.

00:54:52.110 --> 00:54:55.750
So you don't have to actually do anything different.

00:54:55.750 --> 00:55:00.170
Okay. So, we spoke about optimizations,
we spoke about different types

00:55:00.170 --> 00:55:02.200
of coverage objects, and types of ways to draw things.

00:55:02.199 --> 00:55:05.119
Now we're going to talk about how
to get stuff to the screen fast.

00:55:05.119 --> 00:55:06.779
So, optimized screened updates.

00:55:06.780 --> 00:55:09.230
Let's go back to the architecture diagram.

00:55:09.230 --> 00:55:13.380
You've seen it before, and what we're going to
concentrate on is that part of the process.

00:55:13.380 --> 00:55:17.470
After you've drawn your data, now
you want to get it to the screen.

00:55:17.469 --> 00:55:22.459
Flushing. Once you finished drawing what you
have to draw, you have to present it to the user.

00:55:22.460 --> 00:55:25.329
So you basically do a CG context flush, right.

00:55:25.329 --> 00:55:32.449
You definitely don't want to flush things
that the user, that you didn't draw in.

00:55:32.449 --> 00:55:35.509
Try not to draw a flush area that you didn't draw in.

00:55:35.510 --> 00:55:37.690
That's obvious, if you didn't draw there, why flush it?

00:55:37.690 --> 00:55:46.659
The other thing too is that sometimes people try to
flush way more than they should, and that's you know,

00:55:46.659 --> 00:55:51.089
it's pretty obvious because it's 60 hertz for
the refresh of display, if you try to flush faster

00:55:51.090 --> 00:55:54.309
than 60 hertz, nothing really is going to happen.

00:55:54.309 --> 00:55:58.269
If you do that, also you basically end
up consuming valuable GPU and resources,

00:55:58.269 --> 00:56:02.079
GPU and CPU resources if you just try
to flush this willy nilly all the time.

00:56:02.079 --> 00:56:04.420
So let's take a look at what actually happens.

00:56:04.420 --> 00:56:11.519
So great, I got my application, and I, basically I have
a VBL timeline, so the application hasn't drawn anything.

00:56:11.519 --> 00:56:16.559
VBL is clear screen, application draws
something, consumes some GPU and CPU resources.

00:56:16.559 --> 00:56:20.949
Again, he does the next thing, the
VBL goes out, bim, you get beat.

00:56:20.949 --> 00:56:26.250
Again, next VBL, C does a whole bunch of stuff,
consumes a whole bunch of GPU and CPU resources.

00:56:26.250 --> 00:56:28.639
Very valuable, you could have given it to somebody else.

00:56:28.639 --> 00:56:34.429
But basically what happens is boom, you see Z.
So all of that work you did was for nothing.

00:56:34.429 --> 00:56:40.099
So what you should have done was really try and
synchronize your flushes more or less to the VBL,

00:56:40.099 --> 00:56:46.079
and that way you do less work, and
the user sees what they're going to see.

00:56:46.079 --> 00:56:51.000
Okay. So talking about optimal flushing.

00:56:51.000 --> 00:56:53.750
One important case is about animations.

00:56:53.750 --> 00:56:58.530
If you're not using Core Animation, which actually
does the right thing, they actually sync off of VBLs,

00:56:58.530 --> 00:57:02.750
if you're actually doing your own animations,
you have like little, an animating GIF let's say,

00:57:02.750 --> 00:57:07.539
like 500 of them on one window, and you
actually do the flushes off of different timers,

00:57:07.539 --> 00:57:09.630
you're going to get five independent flushes.

00:57:09.630 --> 00:57:15.890
What's much better is for you to actually animate off of
one clock so that you update all 500 of them once.

00:57:15.889 --> 00:57:21.929
So definitely you want to choose something that is, have
a single clock, and you want to choose a refresh rate

00:57:21.929 --> 00:57:26.679
of I don't know, half the display refresh rate,
60 hertz, maybe 30 hertz, pref0erably 30.

00:57:26.679 --> 00:57:29.529
Movies are okay with 24, so why not 30.

00:57:29.530 --> 00:57:33.140
And of course you're drawing time mustbe less that your
timer interval obviously, or else you'd just be backing

00:57:33.139 --> 00:57:39.139
into yourself. Second point right here is kind of crucial.

00:57:39.139 --> 00:57:43.179
You need to sort of separate your data
manipulation engine from your visual engine.

00:57:43.179 --> 00:57:47.559
It's always good, doesn't block your
UI, you get much more responsiveness.

00:57:47.559 --> 00:57:53.940
So let's say you were somebody's
favorite file copying utility let's say.

00:57:53.940 --> 00:58:00.679
And you were, you made the unfortunate
decision to use your file copying thread,

00:58:00.679 --> 00:58:05.119
and your visual thread, and have that be the same thread.

00:58:05.119 --> 00:58:10.589
There would be no surprise if you realized
that you could only copy files at 60 hertz,

00:58:10.590 --> 00:58:14.340
because what actually would happen is that your file
copying will copy, and then it'll go and try and do a flush,

00:58:14.340 --> 00:58:18.309
your flush may or may not rock, but it's
definitely going to happen at 60 hertz.

00:58:18.309 --> 00:58:24.039
So if you have situations like that, it might be wise
to sort of separate your visual and your data engine,

00:58:24.039 --> 00:58:27.590
have your file copying routine
copy at file copy speeds, right.

00:58:27.590 --> 00:58:32.329
Or your file copy thread running at file copy speeds,
and then have your visual engine happen at 60 hertz.

00:58:32.329 --> 00:58:33.639
That's definitely a thing.

00:58:33.639 --> 00:58:42.699
Definitely also in those particular cases you might want to
use separate threads obviously, it's much better to do that.

00:58:42.699 --> 00:58:46.259
Another approach would be timer based also.

00:58:46.260 --> 00:58:50.070
Last point about flushing or trying
to do it optimally is more or less try

00:58:50.070 --> 00:58:54.769
and flush using a validation model
rather than explicit flushing, right.

00:58:54.769 --> 00:58:58.920
The event loophole, the frameworks all do their own
nice thing to try to give you the best representation,

00:58:58.920 --> 00:59:04.750
so you just simply say I've drawn this and validated back
through the event that will get flushed, and away you go,

00:59:04.750 --> 00:59:07.289
instead of actually calling explicitly flush, right.

00:59:07.289 --> 00:59:11.349
There's actually some cases where you actually want to
explicitly flush in order to present something to the user,

00:59:11.349 --> 00:59:17.670
but if you don't need that kind of urgency, just let,
just use the normal framework and validation model.

00:59:17.670 --> 00:59:20.710
Okay. So optimal flushing again.

00:59:20.710 --> 00:59:23.699
So how to detect these type of problems,
what tools do we have available.

00:59:23.699 --> 00:59:27.019
Quartz Debug, if you guys aren't accustomed
to using it, or never seen it before,

00:59:27.019 --> 00:59:31.780
it's basically a nice little handy tool that we have
hanging around that does a bunch of nice cool things.

00:59:31.780 --> 00:59:33.460
One of them is autoflush.

00:59:33.460 --> 00:59:38.849
autoflush sort of basically as you draw, every
single primitive that you draw, we basically go in

00:59:38.849 --> 00:59:41.969
and we flush it out to the screen,
so the user sees it right away.

00:59:41.969 --> 00:59:47.849
You can use that to detect whether or not you've redrawn
stuff over and over again all the time for no reason,

00:59:47.849 --> 00:59:52.079
and you can turn on the color flush updates, which means
that once the flush happens, we actually flash yellow

00:59:52.079 --> 00:59:56.059
in front of you, and say hey this is
going to be flushed, and then you see it.

00:59:56.059 --> 01:00:02.659
And the other one is identical updates, where we actually
do some processing in the background as the flush happens

01:00:02.659 --> 01:00:05.690
to say look, and we highlight these
pixels and say look, this is the same.

01:00:05.690 --> 01:00:08.889
You've painted a white rectangle
500 times, it's still white.

01:00:08.889 --> 01:00:13.980
So definitely you can turn on those different
things to try and debug what's actually happening.

01:00:13.980 --> 01:00:15.590
It also captures things like overdraw.

01:00:15.590 --> 01:00:19.480
You know, you might resize a window, and you see
a view being reflashed like 500 times,

01:00:19.480 --> 01:00:22.039
it's where the actual resize is actually done.

01:00:22.039 --> 01:00:27.269
That may mean that you might have some invalidation
problem, where you've invalidated the view too many times.

01:00:27.269 --> 01:00:31.340
So definitely we can, you can use those
tools to take a look at what you're doing,

01:00:31.340 --> 01:00:34.970
what you're drawing, and how often you're flushing.

01:00:34.969 --> 01:00:39.439
Shark. Shark is another useful
tool, it's a great tool I find.

01:00:39.440 --> 01:00:42.670
In Shark, because flushing is really
more or less asynchronous,

01:00:42.670 --> 01:00:45.599
when you actually do a flush you
don't actually get taxed right away.

01:00:45.599 --> 01:00:49.819
The flush goes into a queue, and some other work
some time later, the Quartz Compositor picks it up.

01:00:49.820 --> 01:00:55.570
So you may not see the time there, but what you will
see is a time when you try to draw again, right.

01:00:55.570 --> 01:00:59.480
So definitely you want to look
for the times at those points.

01:00:59.480 --> 01:01:05.449
Also too, when you're talking about dealing with Sharking
your application to find out where you're blocking,

01:01:05.449 --> 01:01:08.779
you want to throw it in the all threads
states mode, not just the time profile.

01:01:08.780 --> 01:01:13.850
Time profile measures exactly time spent in your process,
not necessarily time you're spent waiting on other people.

01:01:13.849 --> 01:01:19.019
So if you turn on all thread states, it shows you exactly
what's happening in your process, where you're blocking.

01:01:19.019 --> 01:01:23.769
And of course if you try to use it too often, even
though I said it was all queued up and asynchronous,

01:01:23.769 --> 01:01:26.670
if you overuse it, it'll obviously
start showing up in profiles.

01:01:26.670 --> 01:01:32.970
Last point is basically that you know, we
put nice names inside of our functions.

01:01:32.969 --> 01:01:38.109
So if you see those kind of functions, it
basically means you have some sort of a contention.

01:01:38.110 --> 01:01:44.579
Okay. So we spoke a little bit about optimizations,
then we spoke about how to flush your stuff optimally.

01:01:44.579 --> 01:01:47.869
Now we're going to say okay, this is the final
stage, this is the stage where stuff is getting

01:01:47.869 --> 01:01:51.400
from your backing stores onto the screen, right.

01:01:51.400 --> 01:01:55.000
The Quartz Compositor, you sort of have to
look at it as basically being the guardian.

01:01:55.000 --> 01:01:59.289
It's like nothing gets to the screen except going
through the Quartz Compositor, absolutely nothing.

01:01:59.289 --> 01:02:04.730
So what we do is we manage all these flushes from all
these different applications, right, and they come in,

01:02:04.730 --> 01:02:08.090
and then we say at VBL time we go
in and take it out, composite it,

01:02:08.090 --> 01:02:11.840
throw it on the screen, and that's what the user sees.

01:02:11.840 --> 01:02:15.059
Coalescing these updates together
from multiple applications allows us to much,

01:02:15.059 --> 01:02:21.099
make much better use of the CPU and the GPU, right, because
there's absolutely no sense in trying to draw faster

01:02:21.099 --> 01:02:26.170
than the user can see, you know, trying to get
800, or 8,000 updates per second,

01:02:26.170 --> 01:02:28.260
when the user does not going to see any of it.

01:02:28.260 --> 01:02:33.030
So we basically try and police the whole scenario,
and say you know, hold off, you're over flushing,

01:02:33.030 --> 01:02:37.790
let's wait for some other people to happen, flushes,
and then they all get presented out on the screen.

01:02:37.789 --> 01:02:41.050
So let's look how that sort of affects you.

01:02:41.050 --> 01:02:44.110
Here we have an application that's actually a drawing.

01:02:44.110 --> 01:02:48.640
And because of coalesced updates, instead
of doing that, what ends up happening is

01:02:48.639 --> 01:02:51.949
that it updates and gets scheduled for the next VBL.

01:02:51.949 --> 01:02:57.529
Another application comes in, similarly he tries
to flush, he gets scheduled for the next VBL.

01:02:57.530 --> 01:03:01.269
Lots more CPU, lots more applications,
they all get scheduled for the next VBL.

01:03:01.269 --> 01:03:05.369
And then when the VBL goes out, all the presentation
happens all at once, you get nice, smooth,

01:03:05.369 --> 01:03:08.619
flicker free drawing, or flicker free updates.

01:03:10.119 --> 01:03:12.609
So coalesced updates.

01:03:12.610 --> 01:03:17.079
What happens when you actually become
part of this whole flushing scenario.

01:03:17.079 --> 01:03:23.079
Your updates are guaranteed to go out to the next
display, we're not going to sort of miss an extra VBL,

01:03:23.079 --> 01:03:25.029
or you know, you get a flush and it didn't happen.

01:03:25.030 --> 01:03:27.260
It's going to go off with the next VBL.

01:03:27.260 --> 01:03:32.920
But more importantly, in order for us to satisfy that
constraint, we have to prevent you from trying to overdraw

01:03:32.920 --> 01:03:36.240
on top of the backing store that
we have yet to flush to the screen.

01:03:36.239 --> 01:03:37.579
So we hold you off.

01:03:37.579 --> 01:03:47.480
So your next drawing operation after you did a flush may be
held off for a little while until the actual VBL goes out.

01:03:47.480 --> 01:03:53.780
So this is kind of important, and go back
to the file copying example that I gave you.

01:03:53.780 --> 01:03:58.130
This is exactly what slows things
down for people who try to overflush.

01:03:58.130 --> 01:04:00.660
So let's take a look at actually what happens.

01:04:00.659 --> 01:04:04.119
Application comes in, before VBL 1 he starts to draw.

01:04:04.119 --> 01:04:08.079
And then somewhere between VBL 1
and VBL two he actually does a flush.

01:04:08.079 --> 01:04:11.699
He gets scheduled for that flush.

01:04:11.699 --> 01:04:15.279
All of that time he was blocked.

01:04:15.280 --> 01:04:17.320
Similarly, another application does the same thing,

01:04:17.320 --> 01:04:20.670
they're always going to schedule them,
they're all going to go out at VBL 2.

01:04:20.670 --> 01:04:24.210
But during that time they get held off in a certain way.

01:04:24.210 --> 01:04:31.369
So, how do you avoid this?

01:04:31.369 --> 01:04:38.889
Also be aware that for Quartz GL, if you use
Quartz GL the time delay is actually a lot less,

01:04:38.889 --> 01:04:41.440
so that's another benefit.

01:04:41.440 --> 01:04:43.800
So how do you avoid things like this?

01:04:43.800 --> 01:04:46.019
Minimize, obviously you want to minimize what you flush.

01:04:46.019 --> 01:04:48.139
If you try to flush it more than
60 hertz, then you're going to bump,

01:04:48.139 --> 01:04:51.079
if you even flush at 60 hertz you
might bump into it every so often.

01:04:51.079 --> 01:04:55.889
So definitely flushing more, less, less than
the refresh rate of the monitor is a good thing.

01:04:55.889 --> 01:04:58.869
Try and do useful work.

01:04:58.869 --> 01:05:02.130
If you're not flushing you could be doing
something else, if you have something else to do.

01:05:02.130 --> 01:05:06.110
Definitely, that's another way
of trying to avoid the situation.

01:05:06.110 --> 01:05:08.050
So how do you detect the problem?

01:05:08.050 --> 01:05:12.230
If you were to try and say I think I'm bumping into
a situation, how do I turn, how do I detect it?

01:05:12.230 --> 01:05:18.500
In Quartz Debug will, what we have is the ability
for us to turn on, or force beam synchronization.

01:05:18.500 --> 01:05:23.710
And when you turn on the flash screen updates and the
force beam synchronization, we throw it into this mode

01:05:23.710 --> 01:05:28.710
where what happens is that if you try to draw on
the backing store before we actually took it out

01:05:28.710 --> 01:05:33.019
and sent it up to the display, we'll flash it cyan.

01:05:33.019 --> 01:05:38.440
That way you can get an indication that what's
actually happening is you're trying to draw,

01:05:38.440 --> 01:05:41.340
or flush faster than the refresh rate in the monitor.

01:05:41.340 --> 01:05:43.840
So that's also a kind of neat tool.

01:05:43.840 --> 01:05:49.190
Also too, Shark again, that will tell you,
you'd see the lock or synchronization in there.

01:05:49.190 --> 01:05:56.710
There's also a tech note that was published two years ago
I guess exactly on this topic, and how it affects you.

01:05:56.710 --> 01:05:59.139
A lot of people don't necessarily have
to worry about it, cause they don't try

01:05:59.139 --> 01:06:00.929
and update faster than 60 hertz per second.

01:06:00.929 --> 01:06:05.359
So definitely you can take a look
at that tech note for more details.

01:06:05.360 --> 01:06:11.700
Okay. So this is sort of coming up to the tail end of
the presentation, and live resize.

01:06:11.699 --> 01:06:16.909
Sounds something, sounds like something very
simple, but it is really, really very complicated.

01:06:16.909 --> 01:06:21.099
It is the most graphics intensive part
of your application, when the user wants

01:06:21.099 --> 01:06:26.509
and doesn't want live resize the last thing you want to
do is block your resize, and the first thing you want

01:06:26.510 --> 01:06:29.950
to do is make sure he sees what he
asked to see really, really quickly.

01:06:29.949 --> 01:06:33.230
So how do all of that?

01:06:33.230 --> 01:06:39.349
You don't necessarily need to update everything all the
time, every time, with as much precision as you want.

01:06:39.349 --> 01:06:43.049
You can use periodic updates while
the live resize is actually happening.

01:06:43.050 --> 01:06:48.440
You don't need to re-layout, you can
refresh at particular, refresh periodically.

01:06:48.440 --> 01:06:51.579
(inaudible) is an example of this, when you
actually live resize, there's a little table view

01:06:51.579 --> 01:06:54.079
that actually updates every now and again, not all the time.

01:06:54.079 --> 01:06:57.900
It doesn't do the re-layout for
the rows, for the table view.

01:06:57.900 --> 01:07:01.230
You also can consider drawing lower quality results.

01:07:01.230 --> 01:07:02.730
Preview is an example of this.

01:07:02.730 --> 01:07:08.280
When you live, when you try to do live resize, we actually
put up a lower quality representation of the image while

01:07:08.280 --> 01:07:12.510
that resize is happening, and only when you drop
the mouse does it actually go in and say great,

01:07:12.510 --> 01:07:16.260
give me the full quality image representation at that scale.

01:07:16.260 --> 01:07:17.280
Text layout.

01:07:17.280 --> 01:07:19.330
Text layout is very consuming also.

01:07:19.329 --> 01:07:23.579
You want to try and avoid re-laying out the data.

01:07:23.579 --> 01:07:28.019
Text edit is an example of this where
when you actually resize Text edit,

01:07:28.019 --> 01:07:33.150
the layout that exists before the resize happens
actually is kept until you actually drop the mouse.

01:07:33.150 --> 01:07:35.380
Once you drop the mouse, then it
goes and it does all the re-layout.

01:07:35.380 --> 01:07:39.130
You wouldn't necessarily see this in normal text,
but you'd see it in, definitely in rich text,

01:07:39.130 --> 01:07:41.720
cause rich text is a lot more difficult to lay out.

01:07:41.719 --> 01:07:45.599
And of course avoid disk and network
access during live resize.

01:07:45.599 --> 01:07:48.019
It's not all the time, you know.

01:07:48.019 --> 01:07:56.519
If you were to say let's say somebody's favorite
address lookup utility, and you were to actually go in

01:07:56.519 --> 01:08:01.690
and fetch data from some database while the resize
is happening, this would not be a good place.

01:08:01.690 --> 01:08:06.460
I mean it's not as if the representation on screen
the user's seeing is what we'd actually change, right.

01:08:06.460 --> 01:08:10.559
It's only when the user releases the
mouse you can sort of run off and go

01:08:10.559 --> 01:08:12.949
and start doing some expensive work during that time.

01:08:12.949 --> 01:08:21.539
So you should try not to block your user interface
during live resize, try not to do expensive things,

01:08:21.539 --> 01:08:24.239
right, touching the disk, anything like that.

01:08:24.239 --> 01:08:28.219
You can do it once it's done, and
at all costs you should try not to,

01:08:28.220 --> 01:08:33.600
definitely try not to block any kind
of user interface manipulation at all.

01:08:33.600 --> 01:08:36.230
Cause it just annoys users.

01:08:36.229 --> 01:08:39.049
So how do you do that in Cocoa?

01:08:39.050 --> 01:08:40.510
Well there's lots of different features.

01:08:40.510 --> 01:08:47.539
Well first feature is for instance, you might see in Text
edit, Text edit actually uses this pretty extesively.

01:08:47.539 --> 01:08:51.949
It basically says for the update what I want
to do is I want to get the exposed area.

01:08:51.949 --> 01:08:56.550
So if you have a window that's been resized,
there's a little L that needs to be repainted,

01:08:56.550 --> 01:09:01.190
you just simply update the stuff that overlaps the
L, you don't need to draw all the interior content.

01:09:01.189 --> 01:09:08.489
So you can get the exposed rectangles inside
of live resize, and just only repaint those.

01:09:08.489 --> 01:09:13.380
There's also a switch so that you
can know when you're in live resize.

01:09:13.380 --> 01:09:17.319
And we spoke about image interpolation quality, excuse me.

01:09:17.319 --> 01:09:22.659
You can find out whether you're in interpolation, sorry,
in the live resize, and choose a different representation.

01:09:22.659 --> 01:09:29.309
So a lower quality representation, you know, in order to
get much better response, and then when the mouse drops,

01:09:29.310 --> 01:09:31.740
then you actually do the better representation.

01:09:31.739 --> 01:09:35.760
There's also an option in Cocoa that
allows you to preserve the contents,

01:09:35.760 --> 01:09:40.699
where you actually basically say during my
live resize, I want you to preserve my content.

01:09:40.699 --> 01:09:42.909
And what happens there is that
they take a snapshot of the window,

01:09:42.909 --> 01:09:46.720
and just leave all of the outside area unpainted, basically.

01:09:46.720 --> 01:09:49.060
Or you just paint the outside area.

01:09:49.060 --> 01:09:51.460
That's another cool feature for some type of things,

01:09:51.460 --> 01:09:54.810
especially some of the representations
are really, really complex.

01:09:54.810 --> 01:09:58.250
Like if you had a CAD, and you know you
have no choice but to draw everything,

01:09:58.250 --> 01:10:00.640
you could just say preserve what I have now,

01:10:00.640 --> 01:10:04.650
and then repaint these other pieces later,
and then once it's done you're fine.

01:10:04.649 --> 01:10:11.579
Notifications are also available, tells you when
the resize has started and when it's stopped.

01:10:11.579 --> 01:10:17.819
In Cocoa, sorry, in Carbon, similar types of
behavior in terms of finding out what happens

01:10:17.819 --> 01:10:20.109
to the exposed area, how to get newly exposed area.

01:10:20.109 --> 01:10:23.539
You just basically sort of diff the difference
between the current and the previous balance,

01:10:23.539 --> 01:10:27.279
and that'll tell you what new area's being exposed.

01:10:27.279 --> 01:10:32.909
And you can handle the appropriate
events to do more optimal invalidation.

01:10:32.909 --> 01:10:35.989
And of course in that framework there's
also notifications that are available

01:10:35.989 --> 01:10:39.139
to tell you when resize has started and stopped.

01:10:39.140 --> 01:10:45.240
Okay. So I want to leave you with this quote that I
found two years ago, and I thought it was pretty cool.

01:10:45.239 --> 01:10:52.099
I don't know if it's completely true that it's
a root of all evil, but it's fairly close.

01:10:52.100 --> 01:10:58.750
But basically the whole point is to use your tools, right.

01:10:58.750 --> 01:11:03.329
Go and find out what your problems are
first, don't run into lots of situations

01:11:03.329 --> 01:11:08.689
that you have no clue about, like our favorite president.

01:11:08.689 --> 01:11:10.859
( laughter )

01:11:10.859 --> 01:11:13.039
( applause )

01:11:13.039 --> 01:11:18.500
And whatever tools, we provide lots of cool
tools, you know, Quartz Debug, Shark, Xray.

01:11:18.500 --> 01:11:21.310
And whatever other tools, gdb
is you know, the best tool.

01:11:21.310 --> 01:11:26.830
Well not for performance reasons, but
definitely printf is a good tool.

01:11:26.829 --> 01:11:31.869
And of course the last tool of course is
you know, the ultimate computer, the brain.

01:11:31.869 --> 01:11:36.500
So definitely take your tools together, and make a decision
about what you want to do, go in, refine your work,

01:11:36.500 --> 01:11:39.770
and do your stuff the way, how it should be done.

01:11:39.770 --> 01:11:44.690
Want to leave you also with this last slide.

01:11:44.689 --> 01:11:50.129
And it basically is about a book that was written
by Bunny Laden and David Gelphman.

01:11:50.130 --> 01:11:54.659
David is on the team, and he basically
knows a lot about Quartz.

01:11:54.659 --> 01:12:00.849
And this book is a very good book, it talks about
all the details of what you might want to know.

01:12:00.850 --> 01:12:04.030
It's a good reference book to have if you
wanted to do something in a particular way.

01:12:04.029 --> 01:12:08.639
It doesn't necessarily talk a whole bunch about performance,
but it definitely talks about all the aspects of Quartz,

01:12:08.640 --> 01:12:11.940
goes through every single thing that you
can possibly do it, when you want to do it,

01:12:11.939 --> 01:12:14.849
when you don't want to do it, pitfalls to fall into.

01:12:14.850 --> 01:12:19.210
It's a very, very good book, it should
probably be on everybody's shelf.

01:12:19.210 --> 01:12:26.390
So with that, that definitely want to say that we have
labs, but it's Thursday but we don't really have labs,

01:12:26.390 --> 01:12:28.390
so we have open hours so you can come by and visit.

01:12:28.390 --> 01:12:30.310
I'll be there, some other people will be there.

01:12:30.310 --> 01:12:34.720
And that would be more or less it.

01:12:34.720 --> 01:12:39.090
So now I'm going to invite Allan, is Allan here?

01:12:39.090 --> 01:12:49.239
For Q and A. So our Evangelist, he will, you
can contact him for any questions that you have,

01:12:49.239 --> 01:12:54.359
and sample code is also available at the
website, previous years and this year.

01:12:54.359 --> 01:12:56.529
And definitely, I'll invite Haroon.

01:12:56.529 --> 01:13:00.069
There you go.

01:13:00.069 --> 01:13:00.920
Two minutes, yes.

01:13:00.920 --> 01:13:07.880
So we can talk about, you know, come to me or at the
lab, and we can talk about any details anybody has.
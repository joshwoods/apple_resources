WEBVTT

00:00:14.880 --> 00:00:19.269
>> So welcome to session 103 getting started with Core Data.

00:00:19.269 --> 00:00:23.369
I am Melissa Turner I am one of the engineers who
work on Core Data and they drafted me to come up here

00:00:23.370 --> 00:00:26.510
and tell you all about all the wonderful stuff I do.

00:00:26.510 --> 00:00:30.870
Now if I had to make a guess, I'd guess
that a lot of you have something in common.

00:00:30.870 --> 00:00:35.730
A lot of you are probably programmers or the
unfortunate few that have to manage programmers

00:00:35.729 --> 00:00:38.699
and get us all going in the same direction.

00:00:38.700 --> 00:00:43.680
So I'm going to show you some applications and then
we're going to talk about what they have in common.

00:00:43.679 --> 00:00:49.310
Some of you are pretty familiar or might be familiar with
this application, its Yojimbo by Bare Bones software.

00:00:49.310 --> 00:00:52.700
It's a personal organizer application.

00:00:52.700 --> 00:00:58.950
Let's use track and store notes, archives
of web pages, few other interesting things.

00:00:58.950 --> 00:01:05.870
This is iCal, many of you are probably
familiar with it, we shipped it on Tiger.

00:01:05.870 --> 00:01:12.540
Some partially rewritten for Leopard, it does some new and
interesting things and we'll get into those later as well.

00:01:12.540 --> 00:01:18.000
Most of you probably haven't seen this, this is
Terrain editor, it's an application developed by one

00:01:18.000 --> 00:01:25.420
of our customers, it's an OpenGL application that lets
you navigate and sort of fly through rendered landscape.

00:01:26.870 --> 00:01:31.000
And this is Aperture, Apple's latest
edition to our stable of Pro applications.

00:01:31.000 --> 00:01:35.569
What do all these applications have in common?

00:01:35.569 --> 00:01:39.669
Well starting with the obvious,
they are all Cocoa applications.

00:01:39.670 --> 00:01:44.189
All of them deal with data, they create
it, they store it, they retrieve it

00:01:44.189 --> 00:01:46.409
and while that data is live, they manage it.

00:01:46.409 --> 00:01:50.799
They track undo, redo, that kind of thing.

00:01:50.799 --> 00:01:52.840
And all of them use Core Data.

00:01:54.840 --> 00:02:00.260
Hwy do they use Core Data and this is sort of the
part you are really here for the why's, the how's.

00:02:00.260 --> 00:02:04.280
You want to know how we can make your life
better and what motivated our customers,

00:02:04.280 --> 00:02:06.120
the ones we've got started using Core Data.

00:02:06.120 --> 00:02:08.590
Well they wanted to spend time working on their features,

00:02:08.590 --> 00:02:13.379
when it comes right down to it they
didn't want to reinvent wheels.

00:02:13.379 --> 00:02:18.469
Persistence is really critically important but not
what anyone buys an application for, they don't go

00:02:18.469 --> 00:02:22.740
and say oh wow you store your data
as, at least more people don't.

00:02:22.740 --> 00:02:26.390
Most people say this is a really
cool accounting application.

00:02:26.389 --> 00:02:28.889
This is a really cool game.

00:02:28.889 --> 00:02:31.739
They're interested in the features
that they can see and manipulate.

00:02:31.740 --> 00:02:35.820
Persistence isn't really on their radar.

00:02:35.819 --> 00:02:40.819
So something that is very easy for programmers to
hand off to a framework and let somebody else do it.

00:02:40.819 --> 00:02:44.969
Object lifecycle management is
the same kind of thing, undo redo.

00:02:44.969 --> 00:02:49.099
People notice when it's there but they don't particularly
care how it got there or how it's implemented.

00:02:49.099 --> 00:02:53.609
So these are things that are really ideal to hand
off to somebody else who is willing to write them

00:02:53.610 --> 00:02:58.060
so you can concentrate on building the
really interesting user interactions

00:02:58.060 --> 00:03:02.740
that make your application something your customers
are really going to want to go out and buy.

00:03:02.740 --> 00:03:07.950
And the additional benefit of using somebody else's
framework is that well you get automatic access

00:03:07.949 --> 00:03:10.560
to everything they do and if your using an Apple framework

00:03:10.560 --> 00:03:13.960
that means you get automatic access
to all the platform initiatives.

00:03:13.960 --> 00:03:19.599
If for example Apple goes off and I know they'd never
do this but if they decided to switch chip architectures

00:03:19.599 --> 00:03:25.280
and say go from something that was big endian to
little endian, you wouldn't have to do anything

00:03:25.280 --> 00:03:29.080
because the underlying technology
takes care of that for you.

00:03:29.080 --> 00:03:33.650
So it's less work you have to do on stuff that
is not terribly interesting to your customers.

00:03:33.650 --> 00:03:39.490
It gives you more time to spend doing
whatever it is that you do best.

00:03:39.490 --> 00:03:44.610
So today we are going through some of the basics
supported, what the pieces are, how they fit together.

00:03:44.610 --> 00:03:50.720
We're going to talk about building models cause models
are essentially the scaffolding around which all

00:03:50.719 --> 00:03:56.039
of Core Data sort of operates or
within all which Core Date operates.

00:03:56.039 --> 00:04:02.299
We're going to visit some applications and stuff and we
are going to visit some applications that use Core Data

00:04:02.300 --> 00:04:06.080
and sort of talk about how they are using it,
why they are using it, what they got out of it

00:04:06.080 --> 00:04:08.969
and it might give you some ideas
for things you hadn't thought about.

00:04:08.969 --> 00:04:13.609
Either application you hadn't thought about building in
Core Data or things that you hadn't thought about putting

00:04:13.610 --> 00:04:17.790
in your application that are kind of neat and nifty.

00:04:17.790 --> 00:04:21.390
We'll talk about Core Data features and a little
bit more depth, some of the things you can do sort

00:04:21.389 --> 00:04:26.789
of what the features you can expect is and we'll go through
some of the common questions that people come up with

00:04:26.790 --> 00:04:31.970
when there first starting to look at using Core Data.

00:04:31.970 --> 00:04:33.420
So the pieces, what are they?

00:04:33.420 --> 00:04:35.670
How do they fit together?

00:04:35.670 --> 00:04:42.069
Well most people start looking at Core Data because
they want a persistence layer and well it's got data

00:04:42.069 --> 00:04:45.219
in the name so maybe that's what it does.

00:04:45.220 --> 00:04:51.430
So the foundation, the lowest level of Core Data is the
persistence stores, these are the pieces of technology

00:04:51.430 --> 00:05:01.240
that take care of putting bits on a disc and pulling bits
off a disc and putting them into some clarinet form for you.

00:05:01.240 --> 00:05:07.430
We provide four stores under the box and SQLite
and XML and in memory and the binary store.

00:05:07.430 --> 00:05:11.730
These all have different characteristics, it's up to you
to pick the one that works best for your application.

00:05:11.730 --> 00:05:15.280
We've tried to give you good enough selection
that there's something out there for everyone.

00:05:15.279 --> 00:05:21.619
But incase whatever we, the stores we have aren't quite
what you need, you maybe need to support a legacy format.

00:05:21.620 --> 00:05:26.990
We also pride in Leopard and API that allow
you to build a custom Core Data Store,

00:05:26.990 --> 00:05:35.509
first class store just like all the others only
its your data format doing what you need it to do.

00:05:35.509 --> 00:05:39.579
But as I said we're pushing bits in and out of a file.

00:05:39.579 --> 00:05:44.560
Something needs to define a structure for those
bits to say you know this piece of it is a date.

00:05:44.560 --> 00:05:46.089
This piece of it is the strength.

00:05:46.089 --> 00:05:50.519
That's done by the managed object model, the
models sort of defines the structure of your date.

00:05:50.519 --> 00:05:54.639
It says these are the pieces and this
is how they interact with each other.

00:05:54.639 --> 00:06:00.469
The main components in managed object models are entities.

00:06:00.470 --> 00:06:06.120
Entities have attributes, strings, dates, numbers and
they have relationships which are as you might guess,

00:06:06.120 --> 00:06:09.819
relationships that describe interactions between entities.

00:06:11.939 --> 00:06:18.000
The objects that are created from the design that
is the managed object model called managed objects.

00:06:18.000 --> 00:06:21.449
These are instances of the entities and
these are the sort of real work horses,

00:06:21.449 --> 00:06:23.569
these are the things that hold your data.

00:06:23.569 --> 00:06:31.610
In a sense they are the nouns of Core Data,
the songs, the people, the presentations,

00:06:31.610 --> 00:06:35.730
these are the things you operate on, you
work with, this is the important stuff.

00:06:37.990 --> 00:06:42.569
But a model and a managed object really isn't sufficient,
you need some kind of connection between the two of them

00:06:42.569 --> 00:06:46.860
so that your application can make use
of the information that's in the model.

00:06:46.860 --> 00:06:50.650
In Core Data this position is filled
by the managed object context.

00:06:50.649 --> 00:06:52.699
It's sort of the central scrutinizer of Core Data.

00:06:52.699 --> 00:06:59.610
It watch's all of the managed objects that are
registered with it, takes notes whenever a change is made

00:06:59.610 --> 00:07:04.240
and records information so that undo and redo just work.

00:07:04.240 --> 00:07:07.530
It also takes care of maintaining
relationships, if something changes on one end

00:07:07.529 --> 00:07:12.729
of a relationship it will go off and do
whatever's necessary to update the other end of it.

00:07:12.730 --> 00:07:16.050
All of this for free, you don't have to worry about it.

00:07:17.720 --> 00:07:22.370
And in between the stores and the managed object
context because those are the top and bottom levels

00:07:22.370 --> 00:07:26.040
of the Core Data stack lives a
persistence store coordinator.

00:07:26.040 --> 00:07:31.110
This is sort of the center of the Core Data world,
the fulcrum point around which every thing else spins.

00:07:31.110 --> 00:07:34.580
This is where we register the managed
object models, so if you ever need to get

00:07:34.579 --> 00:07:37.399
to your model you go to persistence store coordinator.

00:07:37.399 --> 00:07:42.269
It mediates between the context and the stores so that
the stores don't need to know whose using their data,

00:07:42.269 --> 00:07:44.979
all they know is that the coordinator
has asked them for some.

00:07:44.980 --> 00:07:47.530
In context don't need to know where data is coming from.

00:07:47.529 --> 00:07:51.739
All they need to know if they can ask the
coordinator and they will take care of it for them.

00:07:53.069 --> 00:07:58.750
This is a very important piece of the stack,
you probably not have to interact with it much,

00:07:58.750 --> 00:08:02.360
you need to register the model and this
is where you add and remove stores.

00:08:02.360 --> 00:08:04.900
But most of the rest of your interactions
are probably going to be

00:08:04.899 --> 00:08:08.229
with the managed objects and the managed object context.

00:08:08.230 --> 00:08:10.319
So how does it all fit together?

00:08:10.319 --> 00:08:15.490
Well sort of like this, on the one
end you have the persistence stores.

00:08:15.490 --> 00:08:18.300
On the other end you have the managed object context.

00:08:18.300 --> 00:08:27.240
Your user comes in at the managed context level and
says I want to look at all songs in my song library,

00:08:27.240 --> 00:08:32.919
the context say okay we can do that and it passes
the request down to the persistence store coordinator

00:08:32.919 --> 00:08:36.799
which goes off and hands it to
a store and says get me songs.

00:08:36.799 --> 00:08:42.659
The store goes off and retrieves everything that
matches the description songs and passes it all up back

00:08:42.659 --> 00:08:45.750
to context which returns those to the user.

00:08:45.750 --> 00:08:51.559
So that's where all the components are
attached to each other, that's how they fit

00:08:51.559 --> 00:08:58.129
and that whole fetch concept is encapsulated
in another object called the fetch request.

00:08:58.129 --> 00:09:03.580
A fetch request describes the data you are interested in
retrieving from the store, specifies what entity you want

00:09:03.580 --> 00:09:08.960
and it can specify filtering and sorting
rules as well so you can say not,

00:09:08.960 --> 00:09:12.889
I don't just want songs, I want all Pink Floyd songs.

00:09:12.889 --> 00:09:15.769
And that's done with a fetch request.

00:09:15.769 --> 00:09:20.490
And we have some features on fetch request that will
allow you to find tune how you get your data back.

00:09:20.490 --> 00:09:26.730
We have a head start example that you can have a look at,
see some of the parameters that are tweaked and Adam Smith

00:09:26.730 --> 00:09:30.500
and the session immediately after this one
in this room will be talking more in depth

00:09:30.500 --> 00:09:33.730
about fetch request and how to tune them.

00:09:33.730 --> 00:09:38.100
So at this point I am going to bring Ben up for a demo and
he is going to show you, now that I showed you the picture

00:09:38.100 --> 00:09:41.800
of how Core Data fits together, he's going
to show you what it look like in code.

00:09:44.350 --> 00:09:45.720
>> Ben: Good Morning I'm Ben Trumbull.

00:09:45.720 --> 00:09:51.649
I am the manager of the Core Data team and I'm
going to show you a fairly simple foundation tool.

00:09:51.649 --> 00:09:57.879
So one of the questions we have is a lot of our demo's
and work, work with Cocoa bindings and Interface Builder,

00:09:57.879 --> 00:10:03.439
you see a lot of examples with sort of dynamic
UI and stuff like that and I just wanted

00:10:03.440 --> 00:10:08.220
to show you something that's fairly
straight forward, a little app.

00:10:08.220 --> 00:10:16.700
So it's just a page of code and you
can see some warnings there, my code.

00:10:16.700 --> 00:10:23.120
And we have a fairly simple model for this app here
which basically goes off and every time you run it,

00:10:23.120 --> 00:10:29.899
it records the process ID and the time stamp in
a launch entity.

00:10:29.899 --> 00:10:37.769
So here I just imported Core Data
header and we set up a Core Data stack

00:10:37.769 --> 00:10:41.110
and the basic stack is set up with just these two methods.

00:10:41.110 --> 00:10:47.370
We create model, in this case we initialize it with
a contents of the URL for the model we created in the tool

00:10:47.370 --> 00:10:55.720
and we create a coordinator and we register the model
with it and then we add a store and I've just got a URL

00:10:55.720 --> 00:11:04.009
to a little XML file that's in the current working
directory and we clear the context which is alloc inited.

00:11:04.009 --> 00:11:10.669
We set the coordinator, now the store
is empty when we first run this app.

00:11:10.669 --> 00:11:15.479
So we want to create a new instance of
our launch entity here, which we do.

00:11:15.480 --> 00:11:20.110
Asking entity description to create a
new one and then we ask NS process info

00:11:20.110 --> 00:11:23.710
which is a foundation to get the current process identifier.

00:11:23.710 --> 00:11:32.370
We wrap it in a number object and then here we
tell the record we created to set this attribute.

00:11:32.370 --> 00:11:38.269
Now I am getting a warning because
actually didn't declare any new classes.

00:11:38.269 --> 00:11:42.079
As you can see the total work here is
I'm linked against two frameworks.

00:11:42.080 --> 00:11:49.800
Xcode decided to give me like a man page and
some other things that I am not sure I really needed.

00:11:49.799 --> 00:11:57.399
I have the model and I have my dot M. so what's going
on here is in Leopard, Core Data is automatically going

00:11:57.399 --> 00:12:02.519
to generate accessor methods for anything you
need for the entity that you are working with.

00:12:02.519 --> 00:12:07.840
So the launch entity has a PID attribute and
the launch entity also has a time attribute.

00:12:07.840 --> 00:12:11.660
So we can set and get these properties even
though we actually haven't made a class for them

00:12:11.659 --> 00:12:17.789
because at run time Core Data will specialize the class of
the object that we are working with to match the entity.

00:12:17.789 --> 00:12:25.689
So I do the same thing here, I ask NS date to
give me a date, then tell managed object context,

00:12:25.690 --> 00:12:31.550
I'd like to save the changes I've made with this newly
inserted record and then the app basically goes off

00:12:31.549 --> 00:12:34.559
and creates this fetch request
that Melissa was telling you about.

00:12:34.559 --> 00:12:38.829
I tell it that I am going to fetch launch entities and
then I don't send anything else because I am just going

00:12:38.830 --> 00:12:41.600
to grab all of them, all the ones that have been saved.

00:12:41.600 --> 00:12:51.629
I ask the context to execute the fetch and then I just log
and I call value for key on the array to get all the PIDs.

00:12:55.830 --> 00:12:59.190
So basically I have a model and I have
the compiled program here.

00:12:59.190 --> 00:13:11.110
And if I run the tool it just logs the PID and we
can see that we created and XML file here as the type

00:13:11.110 --> 00:13:15.769
of store we created and we got a little XML
file, there's some metadata at the beginning.

00:13:15.769 --> 00:13:21.840
The Core Data is using to track information, you know
what version of the launch entity I was working with

00:13:21.840 --> 00:13:27.840
and then here we can see the object,
the PID and the time stamp.

00:13:27.840 --> 00:13:34.980
And then if I run it a few times
you can see they just accumulate.

00:13:34.980 --> 00:13:39.230
So this is basically, this is probably the
simplest Core Data app you are going to write.

00:13:39.230 --> 00:13:44.990
And it's broken up into just a few pieces where you
set up the stack, you add a store, you create a context

00:13:44.990 --> 00:13:47.269
and then you start working with your managed objects.

00:13:47.269 --> 00:13:48.509
I do most.

00:13:48.509 --> 00:14:05.049
( Pause in speaking. )

00:14:05.049 --> 00:14:09.889
>> Melissa: So Ben talked, I talked to you
earlier about models and Ben talked about models.

00:14:09.889 --> 00:14:13.850
It's really hard to over estimate how
important these are to your application.

00:14:13.850 --> 00:14:17.600
The first is sort of high level view, what is a model?

00:14:17.600 --> 00:14:22.149
Models a blueprint of your data,
it describes what it looks like.

00:14:23.940 --> 00:14:26.480
In a more traditional world you
might think of it as a schema

00:14:26.480 --> 00:14:29.580
but that really applies to the external representation.

00:14:29.580 --> 00:14:34.009
Models sort of the description of the Y
versions of your objects and how they interact.

00:14:34.009 --> 00:14:44.269
A good way to think of it is in the context of Objective-C.
a class is to an object as an entity is to a managed object

00:14:44.269 --> 00:14:48.480
and a model encapsulates a whole bunch of
entities and describes how they interact.

00:14:48.480 --> 00:14:57.090
So the second most important part of your application,
most important part of course being the idea, the spark,

00:14:57.090 --> 00:14:59.889
the thing that is your trying to communicate.

00:14:59.889 --> 00:15:04.370
It's influenced by and will influence your
interface as you start thinking about modeling

00:15:04.370 --> 00:15:08.330
and as you start learning it, you
sort of start seeing how it might.

00:15:08.330 --> 00:15:15.740
How your application might be faster or more elegant if you
built it this way but the model will also designed by sort

00:15:15.740 --> 00:15:19.210
of how you want to present, be influenced by
how you want opt present you data to the user.

00:15:19.210 --> 00:15:25.990
There's a few simple principles to follow when you're
building a model and we're going to go watch for an example

00:15:25.990 --> 00:15:33.100
that will sort of help you see how it
works and see those principles at play.

00:15:33.100 --> 00:15:38.620
We're going to go with the songs example because well
it's interesting and that's what I have slides for.

00:15:38.620 --> 00:15:45.860
But when you're talking about building an application, a
song library type of applications maybe call it my tunes,

00:15:45.860 --> 00:15:49.330
you get a bunch of pieces of data you need to organize.

00:15:49.330 --> 00:15:53.570
Here's some of them, just a few random
ones that are the most obvious things

00:15:53.570 --> 00:15:57.210
that you might think of when you're talking about songs.

00:15:57.210 --> 00:16:01.490
So you've got these things, you
need to play with them somehow.

00:16:01.490 --> 00:16:06.100
You need to conglomerate them together so
you can operate on and manipulate with them.

00:16:06.100 --> 00:16:07.580
So how do you do that?

00:16:07.580 --> 00:16:08.820
Where do you start?

00:16:08.820 --> 00:16:12.300
Well at first pass might be something that looks like this.

00:16:12.299 --> 00:16:14.669
You just stick everything into one big table.

00:16:14.669 --> 00:16:20.209
Each song has all of the information
associated with the song in a single row.

00:16:20.210 --> 00:16:26.220
Well it's not bad for first pass but it's not
the most efficient thing we can do either.

00:16:26.220 --> 00:16:30.060
If you look at it you'll notice
that there's duplicated data.

00:16:30.059 --> 00:16:33.389
This is always I mean it increases
the size of your application.

00:16:33.389 --> 00:16:37.169
You got extra strings all over the
place, you got extra copies of data

00:16:37.169 --> 00:16:40.199
and it makes it a little bit more difficult to maintain.

00:16:40.200 --> 00:16:45.360
Its not as visible in this song type application
but if you envision a contact dictionary,

00:16:45.360 --> 00:16:52.970
if you change a name in one place you often want those
changes propagated else where and if you put the information

00:16:52.970 --> 00:16:57.259
in just one place you'll only have to edit it in
one place and everything else relates off to it.

00:16:57.259 --> 00:17:03.289
So we've got album information and if I edit it in one
row I'll probably going to want it edited everywhere.

00:17:03.289 --> 00:17:05.779
So whey don't we split that off into a separate table.

00:17:05.779 --> 00:17:12.690
Take all of this row and move it
somewhere else, often to its album table.

00:17:12.690 --> 00:17:17.920
Well for those of you that are familiar with
normalization and doing relational modeling

00:17:17.920 --> 00:17:22.600
in databases your probably saying oh yeah now she's
going to tell me I have to add a row ID column

00:17:22.599 --> 00:17:27.129
and add foreign keys back to the other
table, no you don't need to do any of that.

00:17:27.130 --> 00:17:34.320
Core Data takes care of all this for you, all of the key
management taken, you can just concentrate on your data.

00:17:34.319 --> 00:17:38.119
The Row ID just goes away, so there's your album table.

00:17:39.180 --> 00:17:43.259
So we had that row and we made it gone.

00:17:43.259 --> 00:17:47.480
Following the principle of eliminating
redundant data we see that well we've got

00:17:47.480 --> 00:17:51.370
yet more information sitting there duplicated.

00:17:51.369 --> 00:17:57.389
Things that really are the same piece of information
just in multiple places, so we'll take that row away too,

00:17:57.390 --> 00:18:04.860
but wait a second do I want to just make that a single to
one relationship cause you know the way this is recorded,

00:18:04.859 --> 00:18:10.740
in some places I might have multiple artist for the
same song and that make searching kind of a painful.

00:18:10.740 --> 00:18:17.839
One or the other artist is likely to get lost in the library
and last we give each of those artist there own entry

00:18:17.839 --> 00:18:20.549
and link both of those back to the original table.

00:18:20.549 --> 00:18:22.740
This is what's called a (inaudible) relationship.

00:18:22.740 --> 00:18:30.240
So there goes that row, what else can we do?

00:18:30.240 --> 00:18:31.930
How can we make this smaller?

00:18:31.930 --> 00:18:36.380
Well here's some more duplicated data,
that's what we are working with isn't it?

00:18:36.380 --> 00:18:45.840
But when you really think about it our song title, wish
you were here, is that the same thing in both cases.

00:18:45.839 --> 00:18:52.209
I mean if I am talking about an album Delicate
Sound of Thunder by a group Pink Floyd,

00:18:52.210 --> 00:18:56.100
those are really unique identifying
pieces of information for those objects.

00:18:56.099 --> 00:19:00.389
Song titles really aren't unique in the same way.

00:19:00.390 --> 00:19:04.200
There basically key information about the song itself

00:19:04.200 --> 00:19:07.529
but the same key information can
be shared across multiple songs.

00:19:07.529 --> 00:19:11.710
If I edit one, I only want to edit that one not all of them.

00:19:11.710 --> 00:19:14.620
So think we can leave those in place.

00:19:14.619 --> 00:19:16.879
So what else have we got done?

00:19:16.880 --> 00:19:22.750
We've got this column sitting over here song data, now this
is an interesting case and this is where we start getting

00:19:22.750 --> 00:19:26.299
into the art and science of model design.

00:19:27.500 --> 00:19:32.710
If you think about your application my tunes, how
are you going to present information to the user?

00:19:32.710 --> 00:19:37.789
You probably are going to have some kind of
a table view listing you know song titles,

00:19:37.789 --> 00:19:39.700
lengths, ratings, that kind of stuff.

00:19:39.700 --> 00:19:46.920
And that's what the user sees so really that's all the data
we really need to load in order to show them the interface.

00:19:46.920 --> 00:19:50.890
We don't actually need to load the song
data because well it's big and it takes time

00:19:50.890 --> 00:19:53.940
to pull stuff off disc and they are not going to use it.

00:19:53.940 --> 00:19:58.340
So we don't really need that song data sitting right
there in to that row, we can just move that off

00:19:58.339 --> 00:20:04.559
into a song table file and leave the sings table to
show only the information that's going to be right there

00:20:04.559 --> 00:20:09.009
in the interface when your user goes looking for it.

00:20:09.009 --> 00:20:13.400
Systems and basic split out of the model sort
of conceptually how it works and what it does,

00:20:13.400 --> 00:20:18.290
so now I am going to go through and show you
how to do this in the Xcode modeling tool.

00:20:18.289 --> 00:20:19.509
Whoops.

00:20:19.509 --> 00:20:36.039
( Pause in speaking. )

00:20:36.039 --> 00:20:38.799
>> Melissa: Where is my project, where is my project?

00:20:38.799 --> 00:20:40.200
There we go.

00:20:43.130 --> 00:20:53.200
So here we have a sort of vestigial model, shows all the
table that I broke out as we walked thought that example.

00:20:53.200 --> 00:21:00.860
We got song data, bytes, we got artist
with group or with name and whether a group

00:21:00.859 --> 00:21:04.509
or not, we got albums with labels and names.

00:21:04.509 --> 00:21:09.910
And how did they get the model it was actually
pretty simple, you just go up to Xcode, new file,

00:21:09.910 --> 00:21:15.540
scroll down and we have under the
design category data models.

00:21:15.539 --> 00:21:20.470
But I've already created this one and cause its
boring for you guys to watch models on stage.

00:21:20.470 --> 00:21:25.620
So just going to add a songs entity since
that is truly the center of the world.

00:21:25.619 --> 00:21:28.859
And I am going to add some attributes.

00:21:28.859 --> 00:21:37.509
Its going to be done either using the contacts menu
or by coming up here, clicking on this little arrow

00:21:37.509 --> 00:21:46.259
( Pause in speaking. )

00:21:46.259 --> 00:21:49.509
>> Melissa: Give it a title, give it a rating.

00:21:49.509 --> 00:21:57.900
( Pause in speaking. )

00:21:57.900 --> 00:22:07.060
>> Melissa: Okay so its morning and that
means that I am not allowed to type.

00:22:07.059 --> 00:22:13.950
You can come up here to the inspector view and give all
of these types, last plate is going to be a date, blank,

00:22:13.950 --> 00:22:20.910
well let's make that a decimal,
rating is going to be an integer.

00:22:20.910 --> 00:22:25.019
Untitled is going to se a string.

00:22:25.019 --> 00:22:32.069
So there we have our basic song information but no
connections to anything else that is actually related.

00:22:32.069 --> 00:22:34.509
So add some relationships while we're at it.

00:22:34.509 --> 00:22:48.299
( Pause in speaking. )

00:22:48.299 --> 00:22:55.539
>> Melissa: And again we can come up to this corner
of the model editor and set up a relationships,

00:22:55.539 --> 00:23:02.039
we can edit the friends names here and we set the
destinations of the relationship, in this case is album

00:23:02.039 --> 00:23:09.740
and immediately below that we have a pop up list
for inverses and this is actually kind of important

00:23:11.799 --> 00:23:19.369
because it allows Core Data to figure out what
the other half of any other given relationship is.

00:23:19.369 --> 00:23:24.829
Because when you think about it when you got a
relationship it's really bi directional, songs have albums

00:23:24.829 --> 00:23:31.039
and albums have songs, if I change something about one,
if I added a new song to an album I also want the son

00:23:31.039 --> 00:23:33.159
to know that it now belongs to that album.

00:23:33.160 --> 00:23:36.120
So by setting up two relationships is inverses,

00:23:36.119 --> 00:23:41.169
your really saying this is really the same
relationship seen from two differing directions.

00:23:41.170 --> 00:23:44.470
And that lets Core Data do all the
relationship maintenance for you.

00:23:44.470 --> 00:23:47.630
So we're going to go through and songs belong to albums,

00:23:47.630 --> 00:23:51.660
but album can have multiple songs
so we will mark that as a it's many.

00:23:53.289 --> 00:23:56.509
Set up the artist relationship.

00:23:56.509 --> 00:24:00.279
( Pause in speaking. )

00:24:00.279 --> 00:24:03.369
>> Songs can have multiple artists.

00:24:03.369 --> 00:24:07.069
Artists definitely have multiple songs most of the times.

00:24:07.069 --> 00:24:14.259
And we'll also set up the song have been to everything.

00:24:15.980 --> 00:24:25.700
And we'll also set up the song, data relationship.

00:24:25.700 --> 00:24:36.990
But that's one long because any song really
only has only one pierce of information.

00:24:39.009 --> 00:24:41.079
That's our model, pretty simple.

00:24:41.079 --> 00:24:49.569
But wait there's more once I've got
the model I can just go into build,

00:24:49.569 --> 00:24:52.970
interface builder and build a little interface for it.

00:24:52.970 --> 00:24:53.829
Where's my window?

00:24:53.829 --> 00:24:58.470
I scroll through my library of interesting
stuff and I grab the Core Data entity element.

00:24:58.470 --> 00:25:07.170
And I am just going to drag that out and interface
builder is going to notice that I am trying to set

00:25:07.170 --> 00:25:10.779
up an application, an interface for Core Data entity.

00:25:10.779 --> 00:25:12.990
What does it know about Core Data entities?

00:25:12.990 --> 00:25:18.769
Well it knows it's got a model, it's got a
project open, project has a model so maybe I want

00:25:18.769 --> 00:25:22.039
to use one of those and indeed its correct, I do.

00:25:22.039 --> 00:25:27.159
I am going to set this up so I can display multiple
instance of my song, add some separate widgets

00:25:27.160 --> 00:25:28.750
so you can see the changes I am
making in this view over here.

00:25:28.750 --> 00:25:29.920
This is what is going to end up looking like.

00:25:29.920 --> 00:25:31.630
And I am going to select the elements
that I want to display.

00:25:31.630 --> 00:25:34.210
This is going to be an inspector window so I don't
need any of the stuff that's in a relationship.

00:25:34.210 --> 00:25:35.019
There we go, I have an interface.

00:25:35.019 --> 00:25:37.509
I am going to arrange it for a second
because I like having titles up top.

00:25:37.509 --> 00:25:59.849
( Pause in speaking. )

00:25:59.849 --> 00:26:03.889
>> Melissa: And let's go and edit the table
a little bit and move the title over here.

00:26:03.890 --> 00:26:11.250
But there, that looks like it's not a bad
first pass at building a little song inspector.

00:26:13.079 --> 00:26:21.949
So what next, well to files those,
oops I missed something in my model.

00:26:21.950 --> 00:26:28.910
If I go through and look at all of these, it's important
to Core Data that I specify types for all of my data

00:26:28.910 --> 00:26:34.259
because this allows it to say when you pull these
bytes off discs turn it into an object of this type.

00:26:34.259 --> 00:26:39.140
Well we notice over in this column here
that some of my things are undefined.

00:26:39.140 --> 00:26:46.450
Well I should probably go through and give those
a definition so I can collect multiple ones.

00:26:48.000 --> 00:26:51.990
We do multi select so it's easier to edit
multiple attributes at the same time.

00:26:51.990 --> 00:26:53.880
What else did I miss?

00:26:53.880 --> 00:27:05.090
Missed the artist songs relationship,
I did not give it indeed correct.

00:27:05.089 --> 00:27:09.069
Somehow I deleted that relationship
so there we should be all done.

00:27:09.069 --> 00:27:17.589
We should just be able to build it and at this point
I got my fingers crossed cause I haven't run it

00:27:17.589 --> 00:27:20.509
on this system before so we'll see if it works.

00:27:20.509 --> 00:27:28.039
( Pause in speaking. )

00:27:28.039 --> 00:27:29.509
>> Melissa: There we go.

00:27:29.509 --> 00:27:53.849
( Pause in speaking. )

00:27:53.849 --> 00:27:56.509
>> Melissa: Just add a couple of songs here.

00:27:56.509 --> 00:28:03.039
( Pause in speaking. )

00:28:03.039 --> 00:28:08.049
>> Melissa: We can just, oh I forgot
to set up a save method.

00:28:08.049 --> 00:28:12.579
Oh well. Its morning, I'm slow.

00:28:12.579 --> 00:28:17.029
I could come in here and tell it, actually that's
not correct, it automatically set it up for me,

00:28:17.029 --> 00:28:25.599
so if I quit the application and
rerun it, there we got our data.

00:28:25.599 --> 00:28:30.909
It's the same thing I entered before, not a line
of code required, well that you wrote anyway.

00:28:30.910 --> 00:28:37.500
This is just one of the standard template applications,
if you want to see how a basic Core Data application,

00:28:37.500 --> 00:28:42.609
a little bit more complicated then the one Ben
setup, one that has a user interface looks.

00:28:42.609 --> 00:28:48.629
You just go into Xcode and create
a new project Core Data application.

00:28:48.630 --> 00:28:49.980
We got a few types.

00:28:49.980 --> 00:28:53.620
Document based and document based
for the Spotlight importer.

00:28:53.619 --> 00:28:54.529
It's a way to get you started.

00:28:54.529 --> 00:28:57.509
I have a drink somewhere.

00:28:57.509 --> 00:29:06.049
( Pause in speaking. )

00:29:06.049 --> 00:29:08.460
>> Melissa: So can we go back to the sides please?

00:29:11.099 --> 00:29:18.159
So that's sort of the how to get started on modeling,
its very easy, we provide integration from between Xcode

00:29:18.160 --> 00:29:23.029
and interface builder and Core Data so that 9its really
to bring up a simple application, get things started

00:29:23.029 --> 00:29:27.259
and start playing with your data and
figuring out what you want it to look like?

00:29:27.259 --> 00:29:31.690
That was a basic model, we also support version
models, which is a way of telling Core Data

00:29:31.690 --> 00:29:37.529
and that different models are really
different generations of the same thing.

00:29:37.529 --> 00:29:43.369
Miguel will be talking more about that in his session
at I believe 2 o'clock today, also in this room

00:29:43.369 --> 00:29:50.689
and he'll also be discussing schema migration, which is how
to translate data that was written to disc in one format,

00:29:50.690 --> 00:29:54.880
into a different format, so later
version of your application can read it.

00:29:56.690 --> 00:29:59.789
So that's according to basics, modeling basics.

00:29:59.789 --> 00:30:04.319
Now we are going to look at some of the applications that
are using Core Data and sort of see what they are doing

00:30:04.319 --> 00:30:11.909
with it and what they are to give you a since how
broad the scope of what Core Data can help you with is,

00:30:11.910 --> 00:30:18.360
first off is your system events, well system events, well
technically its Cocoa application but really what it is,

00:30:18.359 --> 00:30:25.579
is a demon that runs on your system so sure it lives in
the background and waits for people to send Apple events

00:30:25.579 --> 00:30:29.789
to it, it's AppleScript integrated. That's the API.

00:30:29.789 --> 00:30:35.440
Background process just sits there and waits
for people to send a request, send, create data,

00:30:35.440 --> 00:30:38.160
pull data out from the system of events server database.

00:30:38.160 --> 00:30:43.300
It's very generic, they create models on the fly,
they pull data out and return it as generic objects,

00:30:43.299 --> 00:30:47.109
through the magic of key value
coding it all again just works.

00:30:47.109 --> 00:30:53.219
It's very flexible and very powerful, it doesn't have
a defined schema, but it allows people to do useful

00:30:53.220 --> 00:30:57.059
and interesting things, without a lot of work.

00:30:57.059 --> 00:31:03.929
Yojimbo, you saw this earlier, it's a personal organizer
written by the folks over at Bare Bones and it's a bunch

00:31:03.930 --> 00:31:08.710
of types of data and the important
thing with Yojimbo is it has to scale.

00:31:08.710 --> 00:31:14.130
It has the potential to have Gigabytes
and gigabytes of data in your data store.

00:31:14.130 --> 00:31:19.930
They need a technology that was capable of doing
that and Core Data is, they use or SQLite store,

00:31:19.930 --> 00:31:25.820
everything is goes out into the same file, gets
brought in, very fast, for a snappy application.

00:31:27.529 --> 00:31:33.889
iCal as I mentioned was rewritten for Leopard, they wanted
to take advances of Core Data because they were starting

00:31:33.890 --> 00:31:39.390
to want increased skill ability and they wanted
to be able to store more of that, more people,

00:31:39.390 --> 00:31:41.250
more interesting things hanging off of that.

00:31:41.250 --> 00:31:49.829
It's also a framework in Leopard it's the iCal framework
so that other applications are integrated in integration

00:31:49.829 --> 00:31:55.449
with the information in iCal have an API that they can
use to call into it and retrieve information about events.

00:31:55.450 --> 00:32:00.440
You see this in Mail where the to
do's are shared between iCal and Mail.

00:32:00.440 --> 00:32:06.850
So they needed multi process access, which Core Data could
give them, and they desperately wanted change tracking

00:32:06.849 --> 00:32:11.849
so that if you undid, or if you made a bunch of
changes to an event and the suddenly realized oops,

00:32:11.849 --> 00:32:15.559
I'm editing the wrong event, not that
I personally would ever have done that,

00:32:15.559 --> 00:32:19.539
you can just undo back across all of those changes.

00:32:19.539 --> 00:32:22.769
And even if there's been a save
because iCal saves automatically

00:32:22.769 --> 00:32:26.309
for you quite frequently, you can undo back across saves.

00:32:26.309 --> 00:32:29.230
Core Data does all of that.

00:32:29.230 --> 00:32:30.250
Address book.

00:32:30.250 --> 00:32:33.920
Again address book has been rewritten
in Leopard to use Core Data.

00:32:33.920 --> 00:32:38.610
Again, they are after increased capability, scalability.

00:32:38.609 --> 00:32:40.299
They had a slightly different set of requirements,

00:32:40.299 --> 00:32:46.549
because where iCal was for the first time publishing
their framework APIs, Address Book already had a set

00:32:46.549 --> 00:32:48.799
of framework APIs that they needed to remain binary
compatible with.

00:32:48.799 --> 00:32:52.539
And they've successfully done that using Core Data.

00:32:52.539 --> 00:32:58.750
And one of the other requirements is that
legacy API that they needed to support needed

00:32:58.750 --> 00:33:03.740
to support multi threaded access, needed to be able to
pass address book objects to people, contacts, groups,

00:33:03.740 --> 00:33:06.829
they needed to be able to pass that around between threads.

00:33:06.829 --> 00:33:11.879
And they're successfully doing
that using Core Data in Leopard

00:33:13.799 --> 00:33:19.149
Xcode, in the spirit of eating your own dog food,
also uses Core Data, in a couple of places, actually.

00:33:19.150 --> 00:33:23.370
We use it in the modeling editor
that you saw earlier and we use it

00:33:23.369 --> 00:33:27.250
in the documentation viewer, which
you might not have expected.

00:33:27.250 --> 00:33:31.170
Documentation viewer has multiple data
sources, they have multiple persistent stores.

00:33:31.170 --> 00:33:37.950
Each section of documentation, the Carbon stuff,
the Java stuff, the Cocoa stuff, is its own file.

00:33:37.950 --> 00:33:43.490
And they present a unified interface on top of that so it
looks like all of the data is coming from a single place.

00:33:43.490 --> 00:33:47.160
They get hundreds of thousands of symbols that they
need to be able to manage and they need to be able

00:33:47.160 --> 00:33:50.610
to complex text queries on a return
results very, very quickly.

00:33:50.609 --> 00:33:53.359
They actually have a hybrid storage model.

00:33:53.359 --> 00:33:58.419
Well all of the meta information, all of the symbol
information is actually st0ored in Core Data.

00:33:58.420 --> 00:34:03.800
The bulky files, they actually store outside on the
file system because file systems are really great

00:34:03.799 --> 00:34:09.659
at storing large elements of infrequently
accessed data that you don't need to search on.

00:34:09.659 --> 00:34:16.379
And as with the rest of Xcode is 64-bit garbage collected.

00:34:19.289 --> 00:34:21.050
Terrain Editor, we showed you that one earlier.

00:34:21.050 --> 00:34:26.260
It's actually an OpenGL application
that does real time rendering

00:34:26.260 --> 00:34:29.990
and allows you to navigate through a virtual landscape.

00:34:29.989 --> 00:34:33.969
In this case we have a picture of Britain
that was downloaded from some information

00:34:33.969 --> 00:34:38.179
that was retrieved from the British government, I believe.

00:34:38.179 --> 00:34:44.589
All of the data, all of the vertices that are used
to construct these scenes are stored in Core Data.

00:34:44.590 --> 00:34:52.480
The author just stores them as data attributes and passes
those data blobs directly into the OpenGL rendering engine.

00:34:52.480 --> 00:34:55.579
His requirement was really it had to be low latency.

00:34:55.579 --> 00:34:59.549
Rendering engines and the people
who use them are very, very fussy.

00:34:59.550 --> 00:35:03.370
They don't want to have to sit around
and wait and have one scene per second

00:35:03.369 --> 00:35:06.549
as your application slowly pulls data out of a database.

00:35:06.550 --> 00:35:13.410
They need it to be very, very fast, they need it to be very,
very seamless and Core Data is capable of giving him that.

00:35:13.409 --> 00:35:18.440
And also it gave him undo, redo, binding support, a bunch
of stuff that he didn't want to have to write himself.

00:35:19.719 --> 00:35:22.079
And there's other apps on the system
that use Core Data as well

00:35:22.079 --> 00:35:24.900
and other applications out in the world that use Core Data.

00:35:24.900 --> 00:35:30.400
Some of the other benefits, some of the other
reasons people like it, it enables rapid development.

00:35:30.400 --> 00:35:36.110
You say how quickly I brought up a simple
little inspector type application in Core Data.

00:35:36.110 --> 00:35:38.849
Very, very fast and flexible.

00:35:38.849 --> 00:35:42.349
It allows you to get it started with minimal code and time.

00:35:42.349 --> 00:35:45.349
It lets you concentrate on your features.

00:35:45.349 --> 00:35:54.420
And at least one of the applications we have out there, Icon
Composer, has a custom Core Data store that they're using

00:35:54.420 --> 00:35:58.019
that actually writes the traditional .ICNS files.

00:35:58.019 --> 00:36:01.130
So just because you're not using what you think

00:36:01.130 --> 00:36:09.380
of as a standard database type application doesn't mean
there's not a way that Core Data might be able to help you.

00:36:09.380 --> 00:36:14.900
And I'm going to haul Ben back on stage and he's
going to go into some detail on Core Data features.

00:36:17.989 --> 00:36:18.500
>> Thank you, Melissa.

00:36:18.500 --> 00:36:22.820
So I'm going to give you an overview of some
of the features that Core Data is providing.

00:36:22.820 --> 00:36:26.590
We're not going to go into too deep a detail, but
just kind of raise your awareness of things about some

00:36:26.590 --> 00:36:29.500
of the things you can expect from Core Data.

00:36:29.500 --> 00:36:34.980
So in particular, one of the higher level
parts of Core Data, there are two main pieces,

00:36:34.980 --> 00:36:38.920
there's the persistence mechanism, which is fairly
self explanatory and then the data management,

00:36:38.920 --> 00:36:42.800
and this is broken up into change
tracking, relationship management and undo.

00:36:42.800 --> 00:36:51.500
So for the change tracking, the manage object context
is tracking all the insertions, updates, deletes,

00:36:51.500 --> 00:36:56.659
whenever you changing your managed objects, it's
recording that and keeping track of what's changed.

00:36:56.659 --> 00:37:02.259
It's posting notifications for you, so the managed
objects themselves are all key value observing compliant

00:37:02.260 --> 00:37:05.430
and the managed object context at
the end of every event will batch up

00:37:05.429 --> 00:37:09.589
and send a meta notification of what changed recently.

00:37:09.590 --> 00:37:15.780
And with the SQL store, it's providing incremental saves,
so it'll only save the objects that have actually changed.

00:37:15.780 --> 00:37:21.900
For the relationship maintenance, there are a number
of pieces, and the first is unique references.

00:37:21.900 --> 00:37:27.599
So in the songs, for example, that Melissa showed
you, if you fetch multiple songs and they're all

00:37:27.599 --> 00:37:31.569
from the same artist, when you
traverse the relationship there,

00:37:31.570 --> 00:37:34.360
you're going to get back the same
artist object for each of those songs.

00:37:34.360 --> 00:37:43.180
So Core Data is going to make sure that you have a single
unique object for all the artists working with those songs.

00:37:43.179 --> 00:37:47.929
And as Melissa mentioned, Core Data is maintaining
the inverses, so if you decide that you made a mistake

00:37:47.929 --> 00:37:53.719
in your editing, and a song has a different artist,
it'll fix up the other end of the relationship for you.

00:37:53.719 --> 00:37:58.909
And if you start deleting artists, it'll follow the
relationships and it'll clear things out for you.

00:37:58.909 --> 00:38:03.929
Or in your model, you can specify that you
want it to cascade and remove a whole chain

00:38:03.929 --> 00:38:09.349
of objects and then finally the undo support.

00:38:09.349 --> 00:38:14.349
This is something that really helps a lot of
developers out because it's very easy to do.

00:38:14.349 --> 00:38:15.869
You wire it up and your done.

00:38:15.869 --> 00:38:18.449
And bindings, in the App delegate.

00:38:18.449 --> 00:38:20.849
So there's no real configuration on your part.

00:38:20.849 --> 00:38:22.269
It's all based on the model.

00:38:22.269 --> 00:38:28.940
The manage object context is just rolling back changes
to the state of affairs that existed the previous event.

00:38:28.940 --> 00:38:30.230
And it works across saves.

00:38:30.230 --> 00:38:32.969
This is something a lot of developers really like.

00:38:32.969 --> 00:38:35.629
But there's not much really to say about it.

00:38:35.630 --> 00:38:39.280
There's not much that you need to do about it.

00:38:39.280 --> 00:38:44.300
And as I mentioned there's the persistence mechanism,
which for the most part is pretty self explanatory.

00:38:44.300 --> 00:38:51.260
We've got four main stores, the XML Store, which is
using NS XML from foundation, the binary store,

00:38:51.260 --> 00:38:57.000
which is using a keyed archive reference foundation,
the SQLite store, which is using SQLite library,

00:38:57.000 --> 00:39:01.480
and then a custom store, an atomic store,
this is the store that you might write.

00:39:01.480 --> 00:39:04.780
And then the persistent store coordinator
is working with aggregation.

00:39:04.780 --> 00:39:09.410
So if you do a fetch, we'll find out which stores
actually have those objects and give them back to you.

00:39:09.409 --> 00:39:16.399
And if you do save, will remember where those objects
came from and save updates back to the originating store.

00:39:16.400 --> 00:39:22.210
And then in Leopard, we support versioning, so we keep track
of which entities were used to create the store and whether

00:39:22.210 --> 00:39:27.119
or not you load a store later, perhaps after
one of your customers has done an upgrade,

00:39:27.119 --> 00:39:30.359
if that store's still compatible with your current version.

00:39:30.360 --> 00:39:35.920
And we have some tools to do schema
changes to migrate to your next version.

00:39:35.920 --> 00:39:44.340
And as Melissa mentioned iCal, Address Book and some
of our other clients are using multiprocessing.

00:39:44.340 --> 00:39:51.539
So the SQLite store offers incremental changes and it
does file system locking and it supports multiple readers

00:39:51.539 --> 00:39:55.000
and authors and the conflicts are handled by the context.

00:39:55.000 --> 00:40:01.019
So we'll talk about that right now.

00:40:01.019 --> 00:40:08.000
So we'll detect changes made to the same objects in the data
file, whether by multiple threads or by multiple processes.

00:40:08.000 --> 00:40:11.559
And we have automated recovery options for you.

00:40:11.559 --> 00:40:13.529
And these are called the merge policies.

00:40:13.530 --> 00:40:20.370
And if you decide you want to learn more about what exactly
is going on, Wikipedia has Optimistic Concurrency Control.

00:40:20.369 --> 00:40:23.000
But for the most part, on the context you just set what kind

00:40:23.000 --> 00:40:28.289
of recovery option you want and
Core Data will handle if for you.

00:40:28.289 --> 00:40:35.449
And as mentioned, we provide a lot
of the platform initiatives here.

00:40:35.449 --> 00:40:40.759
So we're integrated into Cocoa and we support
key value coding on all the managed objects.

00:40:40.760 --> 00:40:43.760
As I demonstrated earlier, we'll
even generate the methods for you

00:40:43.760 --> 00:40:48.480
to match all the accessors that
your entities might want to define.

00:40:48.480 --> 00:40:53.789
And everything's key value observing compliant, so
you can get notifications whenever a property changes.

00:40:53.789 --> 00:40:56.699
We have the undo feature.

00:40:56.699 --> 00:41:00.669
And Core Data is built on top of
the NS undo manager from foundation.

00:41:00.670 --> 00:41:05.240
So if you want to customize our undo behavior,
you have all the foundation API to do that.

00:41:05.239 --> 00:41:07.099
And the same is true with the notifications.

00:41:07.099 --> 00:41:08.909
We're just working with the NS notification center

00:41:08.909 --> 00:41:12.710
and you have all the foundation API
there to customize that behavior.

00:41:12.710 --> 00:41:17.679
And we're integrated on the other side, sort
of the at Kit Cocoa side, with Cocoa bindings.

00:41:17.679 --> 00:41:23.199
And in the tools integration side, we
have all these modeling tools for you.

00:41:23.199 --> 00:41:27.429
We have the templates that both Melissa's
app and my app were based off of.

00:41:27.429 --> 00:41:32.609
So there are a number of other templates for
you to explore to get you started faster.

00:41:32.610 --> 00:41:36.070
We're integrated with Cocoa bindings, an interface builder.

00:41:36.070 --> 00:41:37.690
And we have wizards.

00:41:37.690 --> 00:41:41.230
So in addition to the wizard showed you,
there's a wizard for the collection view,

00:41:41.230 --> 00:41:44.179
to do a grid layout, and a bunch of other things.

00:41:44.179 --> 00:41:48.429
And finally in Leopard we have some
integration with Xray and we have built

00:41:48.429 --> 00:41:51.769
in probes to track performance issues for you.

00:41:51.769 --> 00:41:57.000
And high level Mac OS X initiatives.

00:41:57.000 --> 00:41:59.719
We're fully 32-bit and 64-bit compliant.

00:41:59.719 --> 00:42:03.209
So you can just get started with your 64-bit efforts.

00:42:03.210 --> 00:42:07.110
If you have the, obviously universal binaries.

00:42:07.110 --> 00:42:09.099
We're supporting the new Objective-C properties,

00:42:09.099 --> 00:42:15.259
so in Objective-C 2 with both dynamic
properties and garbage collection.

00:42:15.260 --> 00:42:18.500
And we also spend some effort on multi core utilization.

00:42:18.500 --> 00:42:25.250
So a lot of people's machines, most of the shipping
systems here are dual or quad core or even 8 core

00:42:25.250 --> 00:42:30.630
and Core Data is finding some ways to use those up for you.

00:42:30.630 --> 00:42:36.170
And something important to keep in mind
here, we get a lot of questions about this,

00:42:36.170 --> 00:42:39.099
Core Data is not an ideal solution
if you can't link against foundation.

00:42:39.099 --> 00:42:43.929
We're integrated into all the Cocoa
technologies and if you can't use foundation

00:42:43.929 --> 00:42:48.149
for some reason then Core Data
isn't a great solution for you.

00:42:48.150 --> 00:42:50.980
We also have, we want that model information.

00:42:50.980 --> 00:42:55.360
All of these automatic behaviors
are derived from your schema.

00:42:55.360 --> 00:43:01.890
So if you have an application in which the user
can change any aspect of the schema all the time,

00:43:01.889 --> 00:43:04.980
then Core Data isn't really a great
solution because there's some overhead

00:43:04.980 --> 00:43:08.900
and we want to compile the model
and have it relatively static.

00:43:08.900 --> 00:43:11.579
So you can make changes to the
model, but we're going to want you

00:43:11.579 --> 00:43:14.400
to reload the data after you do that and stuff like that.

00:43:14.400 --> 00:43:18.849
So if you need to make changes all the time,
Core Data's not a perfect solution for you.

00:43:18.849 --> 00:43:26.799
And then finally, if it's not a client server database,
all of the persistence technologies are backed by files

00:43:26.800 --> 00:43:34.330
and we currently don't have any plans
for client server support at this time.

00:43:34.329 --> 00:43:42.940
So some other common questions that are coming up
have to do with performance, so here's a little sample

00:43:42.940 --> 00:43:51.190
that I wrote several different versions of this
project and it fetches 500,000 rows in SQLite store.

00:43:51.190 --> 00:43:53.000
They're all using the same store.

00:43:53.000 --> 00:43:57.329
And the purple column, the SQLite store,
is pretty typical of the kind of code

00:43:57.329 --> 00:44:00.130
when I see people using SQLite directly themselves.

00:44:00.130 --> 00:44:07.269
The model objects here are NS dictionaries, so they
have NS dictionaries in a table view, for instance,

00:44:07.269 --> 00:44:13.619
and they're working with SQLite to pull back the rows
and they set all of the columns as keys in the dictionary

00:44:13.619 --> 00:44:17.119
and the column values as those values in the dictionary.

00:44:17.119 --> 00:44:22.609
Now if you refine that and you
have a custom object and you run it

00:44:22.610 --> 00:44:26.510
through Shark a lot, you can get
it to be quite a bit faster.

00:44:26.510 --> 00:44:30.860
So that's what the optimize SQLite column there is in blue.

00:44:30.860 --> 00:44:33.079
And both of these are raw C tools.

00:44:33.079 --> 00:44:34.960
There's actually very little.

00:44:34.960 --> 00:44:37.880
So the dictionaries here are CF dictionaries.

00:44:37.880 --> 00:44:43.990
So there isn't any overhead here in terms of
language initiatives or anything like that.

00:44:43.989 --> 00:44:45.750
These are C programs.

00:44:45.750 --> 00:44:52.070
The optimize SQLite does a lot of work to, for
instance, optimize retain counting and a bunch

00:44:52.070 --> 00:44:55.039
of other issues if you're working with core foundation.

00:44:55.039 --> 00:45:04.179
And then finally we get to Core Data, which is again about
twice as fast as the previous optimizing as SQLite yourself.

00:45:04.179 --> 00:45:08.219
And the reason for that comes up with the
multi core utilization that we're doing.

00:45:08.219 --> 00:45:12.419
So this fetches large enough that we
realize hey, we've got some extra cores

00:45:12.420 --> 00:45:15.300
in the machine, we can do something useful with them.

00:45:15.300 --> 00:45:20.810
And as a point of reference, I wrote a tool that
malloc'd the same amount of memory and then freed it.

00:45:20.809 --> 00:45:29.299
So we're about twice the speed of just mallocing that
memory and then releasing it as a bench point here.

00:45:29.300 --> 00:45:35.400
And we're going to get into this example a little bit
more in the next session talking about optimization.

00:45:35.400 --> 00:45:39.860
So the basic speed is pretty fast.

00:45:39.860 --> 00:45:41.780
We're smaller and faster than dictionaries.

00:45:41.780 --> 00:45:43.320
Dictionaries are very flexible.

00:45:43.320 --> 00:45:45.309
There are arbitrary hash tables there.

00:45:45.309 --> 00:45:49.480
And the Core Data is making use of that schema information

00:45:49.480 --> 00:45:52.860
and providing a much more optimized
layout and much faster look ups.

00:45:52.860 --> 00:46:00.140
The dynamic methods we generate are direct
dispatches, so it's very synonymous to ivar access.

00:46:00.139 --> 00:46:06.579
And we're providing configurable options on the
fetch request for your applications specific needs.

00:46:06.579 --> 00:46:11.340
And there's an entire example devoted to
exploring this attached to the next session,

00:46:11.340 --> 00:46:15.130
session 105, Optimizing Your Core Data Application.

00:46:15.130 --> 00:46:16.170
So you can take a look at that.

00:46:16.170 --> 00:46:21.639
And even if you're new to Cocoa, you can run the
app and get an idea of what the little options are

00:46:21.639 --> 00:46:26.389
and how they change the behavior of the application.

00:46:26.389 --> 00:46:32.369
So some common questions we have in terms
of customers improving their performance,

00:46:32.369 --> 00:46:37.839
something that often goes overlooked is fetching
performs IO, so if you're working with the SQLite store

00:46:37.840 --> 00:46:41.430
in particular, we're going to be
loading that data as you ask for it.

00:46:41.429 --> 00:46:47.509
So every time you ask for new data, we
have to go to disk and that's kind of slow.

00:46:47.510 --> 00:46:52.190
So you don't want to have to do that for every single object.

00:46:52.190 --> 00:46:54.590
What you're rather do is have one fetch that says hey,

00:46:54.590 --> 00:46:58.760
I'm going to need all these objects really
soon now, can you go off and get them for me?

00:46:58.760 --> 00:47:04.850
So it's much, much faster to issue a fetch
that's for an entire batch of objects.

00:47:04.849 --> 00:47:09.339
And if your batch is large enough, then
we might decide that we can actually spool

00:47:09.340 --> 00:47:13.900
up some background threads to help
you get that done even faster.

00:47:13.900 --> 00:47:17.849
Since this is IO, you really want to be reading from
the database the same way you would from a file.

00:47:17.849 --> 00:47:22.230
You're not going to be reading a single character
out of unbuffered file one character at a time.

00:47:22.230 --> 00:47:24.909
You're going to read a bunch in the buffer
and then you're going to work with them

00:47:24.909 --> 00:47:26.250
and then you're going to read the next batch.

00:47:26.250 --> 00:47:33.880
And that's really the best way to work with
Core Data an any of the options we provide.

00:47:33.880 --> 00:47:38.190
There are also a bunch of performance
tools here that tend to go overlooked.

00:47:38.190 --> 00:47:47.869
So new on Leopard, we have Xray and DTrace, but I want to
bring your attention to Shark, which can be loved more.

00:47:47.869 --> 00:47:53.400
So there's an all thread state option in the time sampling
with Shark that'll track how long it took to get data

00:47:53.400 --> 00:47:59.059
from disk, which is obviously a big
issue for working with a lot of data.

00:47:59.059 --> 00:48:01.889
And then finally Core Data itself offers some SQL logging.

00:48:01.889 --> 00:48:05.909
There's a user default and we'll just log what
we're sending to the database and give you an idea

00:48:05.909 --> 00:48:07.659
of how often we're going to the database.

00:48:07.659 --> 00:48:15.099
It includes timing information,
annotations and stuff like that.

00:48:15.099 --> 00:48:18.639
Another common question that comes
up is how to create unique values.

00:48:18.639 --> 00:48:24.349
So how to assure that there's only one
artist of a given name in the database.

00:48:24.349 --> 00:48:32.130
And it turns out that this kind of behavior is a little
bit intentioned with Core Data providing unique references.

00:48:32.130 --> 00:48:36.079
Because if you make a mistake, and you said
no, these two things were the same at run time

00:48:36.079 --> 00:48:42.039
and we've already created two unique
references, resolving that is somewhat difficult.

00:48:42.039 --> 00:48:47.269
So one of the key things to remember is to avoid
fetching each of these objects one at a time.

00:48:47.269 --> 00:48:52.840
So if you're creating a unique artist, you don't
want to every time the user enters a new artist,

00:48:52.840 --> 00:48:57.490
you kind of want to avoid fetching is this
artist unique, is this artist unique,

00:48:57.489 --> 00:48:59.899
is this artist unique, is this artist unique.

00:48:59.900 --> 00:49:01.880
If you can, you want to batch them up.

00:49:01.880 --> 00:49:07.230
But if you can't, you want to leverage some
application specific usage pattern there to try

00:49:07.230 --> 00:49:09.269
and cut back on the amount of fetching you're doing.

00:49:09.269 --> 00:49:13.800
So one thing you can do is you can cache the
keys that you already know to be unique in memory

00:49:13.800 --> 00:49:18.920
in the NS dictionary and check there first.

00:49:18.920 --> 00:49:22.690
On the list we see a fair number of
questions about memory management.

00:49:22.690 --> 00:49:28.210
So Core Data does the Cocoa technology and all
the standard Cocoa memory management rules apply.

00:49:28.210 --> 00:49:32.869
And something to keep particularly in mind is that all of
the objects you fetch from Core Data are all auto released.

00:49:32.869 --> 00:49:40.949
So if you don't know what that means, that's a
basic Cocoa term and you'll need to work with that

00:49:40.949 --> 00:49:45.710
to create auto release spools to manage the
scope of how long those objects survive.

00:49:45.710 --> 00:49:50.740
So if you're doing a lot of fetching in a loop, you might
want to create an auto release spool to go inside that loop

00:49:50.739 --> 00:49:53.829
so at the end of every loop iteration you pop the spool

00:49:53.829 --> 00:49:58.199
and all the objects you fetched during
that iteration of the loop go away.

00:49:58.199 --> 00:50:02.609
Or, on Leopard you can use garbage
collection and not worry about this.

00:50:03.809 --> 00:50:06.529
We also have some good questions about the notifications.

00:50:06.530 --> 00:50:10.150
As I mentioned we provide a lot of notifications,
both key value observing notifications

00:50:10.150 --> 00:50:12.450
and NS notification center notifications.

00:50:12.449 --> 00:50:15.519
They are provided at the end of every event.

00:50:15.519 --> 00:50:18.269
They're also provided whenever you save a context.

00:50:18.269 --> 00:50:22.420
We don't, however, provide any
process notifications for you.

00:50:22.420 --> 00:50:27.840
There are a lot of technologies on Mac OS X that already
do this, and you can leverage any of those technologies.

00:50:27.840 --> 00:50:33.450
For instance, you can take the notifications we send and
repost them with the NS distributed notification center.

00:50:33.449 --> 00:50:39.329
And there are kit keys where you can use to observe
the file descriptor of the database you're working with

00:50:39.329 --> 00:50:42.719
and how the other processes notice
whenever that changes on disk.

00:50:42.719 --> 00:50:43.500
Stuff like that.

00:50:43.500 --> 00:50:47.760
So there are a lot of Mac OS X technologies
to handle cross process notifications.

00:50:47.760 --> 00:50:51.640
And we also get a lot of questions about multithreading.

00:50:51.639 --> 00:50:56.809
So one of the things is Core Data wants to
use these patterns called thread confinement.

00:50:56.809 --> 00:51:00.210
And basically, we want you to keep
your managed objects on one thread.

00:51:00.210 --> 00:51:05.340
And if you want to work with them on another thread, we
want you to bring over clones into that other thread

00:51:05.340 --> 00:51:09.910
as a separate scratch pad, a separate
working space confined to each thread.

00:51:09.909 --> 00:51:14.989
The raw data that we use, that you fetch
from disks is actually going to be shared

00:51:14.989 --> 00:51:18.569
between the managed object context by the
coordinator and that shared copy and write.

00:51:18.570 --> 00:51:23.840
So pulling these managed objects into separate
threads isn't as expensive as you might fear.

00:51:23.840 --> 00:51:27.789
And as I mentioned a couple of times, on
Leopard, we're going to try to find ways

00:51:27.789 --> 00:51:31.840
to utilize all those extra cores on your machine on demand.

00:51:31.840 --> 00:51:38.130
And then just a quick note, schema version migration,

00:51:38.130 --> 00:51:42.980
there's a session at 2 p.m. entirely
devoted to this and to the tools.

00:51:42.980 --> 00:51:47.329
Custom atomic stores we're going to talk about
a little bit in the next session after this.

00:51:47.329 --> 00:51:51.309
And then dynamic properties and
our integration with Objective-C 2.

00:51:51.309 --> 00:51:55.549
and then there's also transformable attributes, so if
any of you have actually played around with Core Data,

00:51:55.550 --> 00:52:01.080
there's an attribute type which basically allows
you to attach an NS value transformer to it

00:52:01.079 --> 00:52:08.029
and then we just serialize out in NS data, so you can put
in any kind of object you want on the object graph side

00:52:08.030 --> 00:52:11.380
and then Core Data will serialize it into a blob for you.

00:52:11.380 --> 00:52:15.119
So that way you can set up more custom
classes for your attribute types.

00:52:15.119 --> 00:52:18.989
So a summary of some of the things we discussed today.

00:52:18.989 --> 00:52:20.659
We went over some of the basics.

00:52:20.659 --> 00:52:25.210
Melissa showed you an example of building
a model and normalizing song data.

00:52:25.210 --> 00:52:30.030
We showed you some of the examples of
applications on the system that are using Core Data

00:52:30.030 --> 00:52:34.300
and some of the things you're using Core Data for,
and an overview of some of the things you can expect

00:52:34.300 --> 00:52:36.720
from Core Data and some of the common questions.

00:52:36.719 --> 00:52:43.349
So we're going to start Q and A in just
a bit, but some partnering requests

00:52:43.349 --> 00:52:48.759
for you is the documentation's
fabulous and there's a lot of it now.

00:52:48.760 --> 00:52:54.480
So a few years into Core Data here we have accumulated
a lot of documentation on different features

00:52:54.480 --> 00:52:57.070
and performance and a bunch of things like that.

00:52:57.070 --> 00:52:59.340
It really helps us out when you file bug reports.

00:52:59.340 --> 00:53:05.230
So not just, you're welcome to use the mailing list, but
if you come across a problem or even a performance issue,

00:53:05.230 --> 00:53:09.190
if you can go to bugreport.apple.com and let us know.

00:53:09.190 --> 00:53:14.880
And we also love stack traces and Shark samples, so if
you have something that you think is a performance issue

00:53:14.880 --> 00:53:18.700
and you attach a little Shark sample,
that's really going to help us out.

00:53:18.699 --> 00:53:24.000
And a sample application is one of the best
ways to communicate your problem to us.

00:53:24.000 --> 00:53:30.860
We click run, we have it in the debugger with
the Core Data source, and we see your problem.

00:53:30.860 --> 00:53:36.740
So if you have basically a way to isolate the
bug into a simple app, that would be great.

00:53:36.739 --> 00:53:41.319
And we get to those bugs first.

00:53:42.809 --> 00:53:45.500
It's true.

00:53:45.500 --> 00:53:48.019
So some overview.

00:53:48.019 --> 00:53:49.730
There's a Core Data programming guide.

00:53:49.730 --> 00:53:52.599
There's a persistent document tutorial.

00:53:52.599 --> 00:53:57.039
We haven't gone too much into detail about
some of the integration in the app kit side.

00:53:57.039 --> 00:54:00.179
There's a subclass of NS document that
integrates your Core Data for you.

00:54:00.179 --> 00:54:06.399
There's a low level Core Data tutorial and
then there's all the reference documentation.

00:54:06.400 --> 00:54:10.700
There are a whole bunch of examples on your
system in slash developer slash examples.

00:54:10.699 --> 00:54:15.289
And there's some related sessions all here today.

00:54:15.289 --> 00:54:19.829
So next up will be optimizing your Core Data application.

00:54:19.829 --> 00:54:25.489
Then there's going to be managing your schema
versioning and data migration this afternoon.

00:54:25.489 --> 00:54:32.829
Somewhat related, Tuesday, is getting started with
Cocoa bindings that Malcolm's going to be doing.

00:54:32.829 --> 00:54:37.880
And our lab, if you want to come in and show us
your application or just ask more questions,

00:54:37.880 --> 00:54:43.960
will be tomorrow at 3:30 in the Mac OS X Lab.

00:54:43.960 --> 00:54:48.579
Standard who to contact, Matt Formica is the
Track Manager here and the Cocoa Evangelist.
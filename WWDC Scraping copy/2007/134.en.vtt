WEBVTT

00:00:18.989 --> 00:00:20.719
>> So good afternoon everyone.

00:00:20.719 --> 00:00:24.570
I'm Doug Davidson and I'm here to talk
to you about the Cocoa text system.

00:00:24.570 --> 00:00:29.899
Now anyone who has ever worked with Cocoa has seen the
text system in action because it's responsible for most

00:00:29.899 --> 00:00:33.369
of the text you see displayed in
the typical Cocoa application.

00:00:33.369 --> 00:00:37.769
But what may not be quite so obvious is
that there's an enormous depth to it.

00:00:37.770 --> 00:00:40.920
Many different levels at which
you can deal with the text system

00:00:40.920 --> 00:00:43.260
and particularly which you could customize its behavior.

00:00:43.259 --> 00:00:46.449
And that's the main thing that I
want to talk to you about today.

00:00:46.450 --> 00:00:53.650
For those of you who are new to Cocoa text, along the way
I will also be discussing quite a bit about how it works.

00:00:53.649 --> 00:01:01.009
And of course, we have a great many things that are
new in Leopard I will be discussing from time to time.

00:01:01.009 --> 00:01:03.890
So what is it the Cocoa text system does?

00:01:03.890 --> 00:01:12.140
The main job of the text system is to take a text document, that
is characters plus their attributes like color and font

00:01:12.140 --> 00:01:20.239
and so forth and to convert them into glyphs which are the
individual displayable elements to the font and positions

00:01:20.239 --> 00:01:22.469
so that they can be displayed on the screen.

00:01:22.469 --> 00:01:23.849
So here's my standard example.

00:01:23.849 --> 00:01:33.589
We have a character set, a with an acute accent and
attributes blue color, Helvetica 64 font, and centered.

00:01:33.590 --> 00:01:39.829
And what the text system does is take the character and
attributes and convert it into the appropriate glyph

00:01:39.829 --> 00:01:44.109
or glyphs in the font needed to
display this and the position centered,

00:01:44.109 --> 00:01:52.689
so that we get a nice blue accented a. The text system
also deals with all the ways we have of getting text

00:01:52.689 --> 00:01:57.670
into the system and modifying it, particularly
with all the interactions that the user may do

00:01:57.670 --> 00:02:00.900
with keyboard and mouse and so forth to edit the text.

00:02:00.900 --> 00:02:08.300
And furthermore, it handles import from and
export to a wide variety of text document formats.

00:02:08.300 --> 00:02:12.650
So just to orient you, let me point out
where we are in the layering of the system.

00:02:12.650 --> 00:02:20.310
Most of the Cocoa text system of course is in AppKit,
many of the fundamental classes are defined in foundation,

00:02:20.310 --> 00:02:26.270
and those were the toll free bridge that their
counterparts at the core foundation level.

00:02:26.270 --> 00:02:32.490
In addition there's another a framework that's well not new
for Leopard, but newly public for Leopard call Core Text

00:02:32.490 --> 00:02:36.969
which is what the Cocoa text system
uses for its low level line layout.

00:02:38.349 --> 00:02:44.789
Like many pieces of Cocoa, the text system uses model
view controller structure and I'm also going to use

00:02:44.789 --> 00:02:46.859
that to structure some of the pieces of my talk.

00:02:46.860 --> 00:02:55.280
At the top of the view level we have classes like NSTextView,
the bottom model layer, classes like NSTextStorage,

00:02:55.280 --> 00:03:01.890
and in the middle are the control objects that mediate
between the two like NSLayoutManager and so on.

00:03:01.889 --> 00:03:08.389
Now there are a lot of APIs here, it's natural to ask
when you're starting where do you want to go first?

00:03:08.389 --> 00:03:10.519
So here's a brief guide.

00:03:10.520 --> 00:03:16.030
If you're trying to draw some little piece of text
in your view, the natural first place to look is

00:03:16.030 --> 00:03:17.750
at the API we call a string drawing APIs.

00:03:17.750 --> 00:03:19.539
I'm going to discuss in a minute.

00:03:19.539 --> 00:03:25.719
Or you can use NSCell which in turn uses the string
drawing APIs to draw when it needs to draw text.

00:03:25.719 --> 00:03:28.349
If you want a small bit of editable
text, the natural thing to look

00:03:28.349 --> 00:03:32.489
at would be NSTextField or any of the other controls.

00:03:32.490 --> 00:03:38.969
If you have large pieces of text, these are editable
or not, the natural class to look at is NSTextView.

00:03:38.969 --> 00:03:44.889
If you have needs for detailed measurement or
specialized drawing of text that beyond what you can get

00:03:44.889 --> 00:03:49.559
from the string drawing APIs, the place to look
is NSLayoutManager at the controller level.

00:03:49.560 --> 00:03:53.150
I'm going to be talking quite a bit about that later on.

00:03:53.150 --> 00:03:54.740
Finally there is also Core Text.

00:03:54.740 --> 00:03:59.350
Now if you're working in Cocoa, you probably
are not going to need to use Core Text directly.

00:03:59.349 --> 00:04:06.319
It's primarily intended for Carbon developers as a modern
replacement for things like QuickDraw and ATSUI so forth.

00:04:06.319 --> 00:04:10.199
As I said Cocoa, the Cocoa text system does use Core Text.

00:04:10.199 --> 00:04:16.930
And essentially all the features of Core Text are available
for you plus a lot more through the Cocoa text system.

00:04:16.930 --> 00:04:20.579
But it is there if you want to use it directly.

00:04:20.579 --> 00:04:22.899
So let's start at the view level.

00:04:22.899 --> 00:04:26.870
The view level, the main class in
the Cocoa text system is NSTextView.

00:04:26.870 --> 00:04:31.620
That handles all of the display
and editing of all sorts of text.

00:04:31.620 --> 00:04:36.290
In fact, even a control like NSTextField,
if it wants to edit text,

00:04:36.290 --> 00:04:39.550
it uses NSTextField to do it called a field editor.

00:04:39.550 --> 00:04:45.319
And NSTextView is very, very customizable,
even if your never subclass at all.

00:04:45.319 --> 00:04:50.490
It has a large number of options,
it has many, many delegate methods

00:04:50.490 --> 00:04:53.900
and it can be hooked up in a wide variety of configurations.

00:04:53.899 --> 00:04:56.870
But rather than tell you about it,
let me just show you some of that.

00:04:56.870 --> 00:04:58.360
Let's go over to demo one.

00:04:58.360 --> 00:05:00.680
( Period of silence )

00:05:00.680 --> 00:05:05.470
Take a look at this.

00:05:05.470 --> 00:05:13.880
So if I just drag an NSTextView into my nib
and Interface Builder with zero lines of code,

00:05:13.879 --> 00:05:21.509
immediately I get all, we want this machine?

00:05:21.509 --> 00:05:33.939
( Period of silence )

00:05:33.939 --> 00:05:35.230
There we go.

00:05:37.310 --> 00:05:43.860
So, if I just drag a text view into my nib in Interface
Builder, immediately, with zero lines of code,

00:05:43.860 --> 00:05:48.889
I have all the features of text edit
right at my fingertips in my application.

00:05:48.889 --> 00:05:56.819
That's rich text, graphics, undo, spell checking,
any or all of these that I want for free.

00:05:56.819 --> 00:05:59.209
And a few more for Leopard.

00:05:59.209 --> 00:06:12.500
So for example, automatic detection of
URLs, that will be zero lines of code.

00:06:12.500 --> 00:06:17.819
Tool tips for the URLs, for the links, zero lines of code.

00:06:17.819 --> 00:06:20.709
How about smart quotes?

00:06:20.709 --> 00:06:22.889
( Period of silence )

00:06:22.889 --> 00:06:28.789
In Leopard, zero lines of code.

00:06:28.790 --> 00:06:36.360
Say what about grammar checking?

00:06:36.360 --> 00:06:38.410
( Period of silence )

00:06:38.410 --> 00:06:42.460
In Leopard, zero lines of code.

00:06:44.800 --> 00:06:49.590
But supposing for a minute that you
were actually going to write some code.

00:06:49.589 --> 00:06:53.359
So if you're willing to write, oh say a dozen lines of code,

00:06:53.360 --> 00:06:58.220
you can start working with multiple instances
of NSTextView and NSTextContainer.

00:06:58.220 --> 00:07:00.400
And you can hook them up in a wide variety of ways.

00:07:00.399 --> 00:07:09.560
So for example, if you got multiple pages
or what I have here is multiple columns.

00:07:09.560 --> 00:07:10.660
Going a little further.

00:07:10.660 --> 00:07:17.300
If you were actually willing to subclass NSTextContainer
override two method, maybe another dozen lines of code,

00:07:17.300 --> 00:07:23.650
you can get all sorts of fancy shapes, arrangements of text.

00:07:23.649 --> 00:07:29.549
And if you were actually willing to write a
custom NS view subclass, maybe 20 lines of code,

00:07:29.550 --> 00:07:36.319
you can actually put text just about anywhere you want.

00:07:36.319 --> 00:07:43.279
Oh and one thing I should mention is that the way I've
hooked these up, these are not many separate text documents.

00:07:43.279 --> 00:07:46.759
These are many different views of the same text document.

00:07:46.759 --> 00:07:54.920
So if I make changes in one, they'll be
automatically reflected instantly in all of them.

00:07:56.139 --> 00:08:00.310
But really, this is the easy stuff.

00:08:00.310 --> 00:08:05.089
We've talked about this sort of thing
many times at past WWDC sessions.

00:08:05.089 --> 00:08:07.179
There's copious documentation on it.

00:08:07.180 --> 00:08:10.980
And there are many examples, many code
examples available, including this one.

00:08:10.980 --> 00:08:14.470
This should be available for download now.

00:08:14.470 --> 00:08:20.830
The main thing I want to do in this session is to
go a little deeper and to explore some more subtle

00:08:20.829 --> 00:08:25.219
and more thorough going modifications to the text system.

00:08:25.220 --> 00:08:29.510
So let's go back to the slides.

00:08:29.509 --> 00:08:37.830
( Period of silence )

00:08:37.830 --> 00:08:42.570
Just for the record, here is a list
of some of the principle new feature

00:08:42.570 --> 00:08:45.940
that we have available through NSTextView in Leopard.

00:08:45.940 --> 00:08:48.330
But I want to strongly encourage you to take a look

00:08:48.330 --> 00:08:52.940
at the AppKit release notes you
received, and take a look at the headers.

00:08:52.940 --> 00:08:58.230
There are many, many new methods that we've
added, far more than I could list here right now.

00:08:58.230 --> 00:09:02.139
All sorts of new individual methods, new
options, new delegate methods and so forth.

00:09:02.139 --> 00:09:05.769
Many of them specific responses, specific requests from you.

00:09:05.769 --> 00:09:08.500
So go take a look at the headers,
go take a look at the release notes.

00:09:08.500 --> 00:09:11.190
You'll find a lot of nice surprises.

00:09:11.190 --> 00:09:14.220
Alright, so now let's start going down a little deeper.

00:09:14.220 --> 00:09:17.190
Let's go down to the model level.

00:09:17.190 --> 00:09:22.770
At the model level, the main class of NSText
Core Text system is NSTextStorage.

00:09:22.769 --> 00:09:28.009
That models text document as first
of all a string that is an NSString,

00:09:28.009 --> 00:09:32.200
conceptually of UTF-16 characters plus attributes.

00:09:32.200 --> 00:09:36.050
So conceptually to each character is
associated a dictionary of attributes.

00:09:36.049 --> 00:09:43.209
And these attributes cover fonts, colors,
topography, paragraphs, anything and everything

00:09:43.210 --> 00:09:48.550
that might affect the way the text is
supposed to be laid out and displayed.

00:09:48.549 --> 00:09:52.399
Let me back up for a minute and talk a
bit about the inheritance hierarchy here.

00:09:52.399 --> 00:10:01.199
So the basic class is NSAttributedString that is defined
in foundation, toll free bridged with CFAttributedString

00:10:01.200 --> 00:10:08.770
in core foundation and I should mention that CFAttributedString
is the principle model class used by Core Text.

00:10:08.769 --> 00:10:14.759
So now for the first time we have a unified
rich text model across both Carbon and Cocoa.

00:10:14.759 --> 00:10:20.340
Then the immediate subclass of NSAttributedString is
NSMutableAttributedString, which adds mutability,

00:10:20.340 --> 00:10:24.110
toll free bridged again with CFMutableAttributedString.

00:10:24.110 --> 00:10:29.300
And then AppKit has a special subclass of
NSMutableAttributableString called NSTextStorage.

00:10:29.299 --> 00:10:33.189
And I'll be getting into its features later.

00:10:33.190 --> 00:10:36.630
So how is it you work with NSAttributedString?

00:10:36.629 --> 00:10:43.559
If you want to get at the characters, then there's a string
method that gives you an efficient proxy, an NSString.

00:10:43.559 --> 00:10:49.929
And you can use all the NSString methods on to get access
to the characters of the string, of the AttributedString.

00:10:49.929 --> 00:10:57.029
If you want to look at the attributes, well typically it's
rare for an attribute to apply to just a single character.

00:10:57.029 --> 00:11:01.850
Usually they're going to apply to some
range, short or long, of characters.

00:11:01.850 --> 00:11:06.740
So when you ask for the attribute dictionary at a
particular index, we return you to that dictionary,

00:11:06.740 --> 00:11:11.110
but we also return by reference a
range, we call the effective range.

00:11:11.110 --> 00:11:15.080
That is some range over which those,
that set of attributes holds.

00:11:15.080 --> 00:11:20.360
And we don't guarantee it's the longest range,
but it's some range over which they are effective.

00:11:20.360 --> 00:11:24.570
If you just want a single attribute, again you can just
ask for the attribute at a given index, we return it,

00:11:24.570 --> 00:11:30.270
we also return by reference, again effective range,
there's some range for which that attribute holds.

00:11:30.269 --> 00:11:37.110
If you do want the longest range over which an attribute
or set of attributes is valid, then you can ask for it

00:11:37.110 --> 00:11:39.590
with these longestEffectiveRange methods.

00:11:39.590 --> 00:11:43.570
It can be a little expensive to compute
it especially if the range is very long.

00:11:43.570 --> 00:11:47.590
So you shouldn't ask for it unless you actually
plan to be dealing with that whole range.

00:11:47.590 --> 00:11:50.519
But it is there if you want it.

00:11:50.519 --> 00:11:52.250
Now what are these attributes?

00:11:52.250 --> 00:11:55.389
As I said, NSAttributedString is defined in foundation.

00:11:55.389 --> 00:11:58.299
But AppKit adds a great deal to it.

00:11:58.299 --> 00:12:01.589
And there is an AppKit/NSAttributedString.h header,

00:12:01.590 --> 00:12:05.120
which is different from the foundation
NSAttributedString.h header.

00:12:05.120 --> 00:12:12.379
And in the AppKit/NSAttributedString header are defined
the interesting attributes that the text system understands.

00:12:12.379 --> 00:12:17.669
For each attribute, there is a string constant, that
is the name, the value, the key for that attribute,

00:12:17.669 --> 00:12:21.839
like NSFontAttributeName, NSForegroundColorAttributeName,
NSParagraphStyleAttributeName.

00:12:21.840 --> 00:12:28.920
And also is specified what the class is for that,
is intended for the values of that attribute.

00:12:28.919 --> 00:12:33.129
And in addition there's also specified
a default value that is going to be used

00:12:33.129 --> 00:12:34.850
if that attribute doesn't happen to be present.

00:12:34.850 --> 00:12:39.430
So the default color is black, the default
font is Helvetica 12 and so on, so forth.

00:12:40.860 --> 00:12:48.230
So one very common programming practice is when you're
working with an attributed string, you want to go over it

00:12:48.230 --> 00:12:53.680
and deal with the different attributes in it
and you want to work by ranges of attribute.

00:12:53.679 --> 00:12:55.849
So this is a common code pattern.

00:12:55.850 --> 00:13:00.389
Here we start off with a range, range which
is the overall range we want to deal with.

00:13:00.389 --> 00:13:04.179
And we're going to iterate through it by
effective ranges for a particular attribute.

00:13:04.179 --> 00:13:08.549
In this case, I've chosen to use the
ParagraphStyleAttribute which is the one

00:13:08.549 --> 00:13:11.159
that describes all paragraph level formatting.

00:13:11.159 --> 00:13:16.110
Line spacing, indents, margins and so forth.

00:13:16.110 --> 00:13:22.600
So we are going to ask for the
ParagraphStyleAttribute at a given index,

00:13:22.600 --> 00:13:27.279
and here we're getting the longest effective range
because we do want to deal with the whole thing.

00:13:27.279 --> 00:13:29.399
And that will be our effective range.

00:13:29.399 --> 00:13:35.740
Now as a default value, NSParagraphStyle DefaultParagraphStyle
used if the attribute isn't present.

00:13:35.740 --> 00:13:37.639
Here I'm not actually doing anything much with it.

00:13:37.639 --> 00:13:38.750
I'm just logging the value.

00:13:38.750 --> 00:13:43.509
And then after we've dealt with that effective
range, then we go and start over again

00:13:43.509 --> 00:13:46.860
at the NSMaxRange of the effective range.

00:13:46.860 --> 00:13:49.259
That is just beyond its end.

00:13:49.259 --> 00:13:54.720
And get the next value of the attribute and so on by ranges.

00:13:54.720 --> 00:13:59.580
So NSMutableAttributedString adds mutability.

00:13:59.580 --> 00:14:01.129
How can we deal with that?

00:14:01.129 --> 00:14:08.309
First of all there is a mutableString method that gives an
efficient proxy as an NSMutableString that you can use.

00:14:08.309 --> 00:14:12.409
You can use all of the NSMutableString
methods to change the characters.

00:14:12.409 --> 00:14:17.179
You can also change the characters directly acting
on the mutable attributable string with methods

00:14:17.179 --> 00:14:20.669
like replaceCharactersInRange:withString
or withAttributedString.

00:14:20.669 --> 00:14:27.919
And then there are some convenience methods that do
specifically insertion, append and delete and so forth.

00:14:27.919 --> 00:14:33.079
If you just want to change attributes,
then you can call setAttribute,

00:14:33.080 --> 00:14:39.259
Attributes:range that will just remove any attributes that
are a set these, this set of attributes for that range.

00:14:39.259 --> 00:14:45.259
Or add attributes to add some dictionary of
attributes to the attributes that are already there.

00:14:45.259 --> 00:14:48.120
Override any that might conflict.

00:14:48.120 --> 00:14:50.279
Or you can just set a single attribute.

00:14:50.279 --> 00:14:54.179
Add it or remove it.

00:14:54.179 --> 00:15:01.439
So let's go back to our code example.

00:15:01.440 --> 00:15:06.120
( Period of silence )
Can we have the slides?

00:15:06.120 --> 00:15:11.649
Sorry. In this case, we're going to
take that same set of code and instead

00:15:11.649 --> 00:15:14.120
of just logging the value we're going to actually modify it.

00:15:14.120 --> 00:15:18.509
In this case I've chosen to take that paragraph
style and modify it by changing its alignment

00:15:18.509 --> 00:15:21.509
to center it so to make all the text centered.

00:15:21.509 --> 00:15:26.950
So we take the same code as before
plus we take that paragraph style

00:15:26.950 --> 00:15:29.830
for that effective range and we make a mutable copy.

00:15:29.830 --> 00:15:30.700
And we change it.

00:15:30.700 --> 00:15:33.610
We call setAlignment, CenterAlignment.

00:15:33.610 --> 00:15:40.899
And then we take that modified, the copy, and set
it back the attribute on the same effective range

00:15:40.899 --> 00:15:42.909
that the original paragraph style applied to.

00:15:42.909 --> 00:15:44.730
And then we release it.

00:15:44.730 --> 00:15:50.460
Very common code pattern when dealing
with mutable attributed strings.

00:15:50.460 --> 00:15:56.660
So as I said, attributed strings are defined in
foundation but a great is added to them in AppKit.

00:15:56.659 --> 00:16:01.360
And one of the things that is added is in
the AppKit/NSStringDrawing.h header.

00:16:01.360 --> 00:16:04.950
A set of methods that we call the
StringDrawing methods, generally.

00:16:04.950 --> 00:16:10.460
And these include both drawing,
simple drawing and measuring of text.

00:16:10.460 --> 00:16:15.920
So the basic methods, you just draw an
attributed string in a Rect with various options

00:16:15.919 --> 00:16:18.799
or get it sized again with various options.

00:16:18.799 --> 00:16:22.379
And again there are a number of convenience
methods that take fewer arguments.

00:16:22.379 --> 00:16:27.909
Some that take just a string and an attribute
dictionary instead of an attributed string.

00:16:27.909 --> 00:16:31.519
These are the first place you should look if
you're just trying to draw a piece of text

00:16:31.519 --> 00:16:36.189
in your view or image or other graphics context.

00:16:36.190 --> 00:16:44.700
One thing that I should note when you're using these is
that the Cocoa text system uses the attributes defined

00:16:44.700 --> 00:16:50.860
on attributed strings and not in
general where they, where they overlap,

00:16:50.860 --> 00:16:54.820
not the same things that might be
defined on the graphics context.

00:16:54.820 --> 00:16:57.170
So even if the attributes are not present.

00:16:57.169 --> 00:16:59.469
So you, for drawing text with the text system,

00:16:59.470 --> 00:17:02.690
you're never going to be setting the fonts
or colors on the graphics context.

00:17:02.690 --> 00:17:08.720
Instead you'll be setting them as
attributes on your attributed strings.

00:17:08.720 --> 00:17:15.019
Another thing that the AppKit adds to
attributed strings is import from and export

00:17:15.019 --> 00:17:18.730
to a lot of different text document formats.

00:17:18.730 --> 00:17:22.750
This includes plain text, RTF, RTFD,
HTML, word documents and so on.

00:17:22.750 --> 00:17:28.369
For Leopard we've added the Open
Document format used by Open Office.

00:17:28.369 --> 00:17:34.979
And the Office Open XML text document
format used by Word 2007.

00:17:34.980 --> 00:17:42.750
The basic methods for import take either a file URL
or an NSData, that would be the contents of the file.

00:17:42.750 --> 00:17:51.220
And they take a number of options and documentwide
attributes and they may return an error.

00:17:51.220 --> 00:17:58.660
The basic export methods will give you either the data
of the document or a file wrapper that you can then write

00:17:58.660 --> 00:18:01.200
out to disk or do whatever you like with.

00:18:01.200 --> 00:18:05.240
Now there are many, many options.

00:18:05.240 --> 00:18:10.690
There are lots of global documentwide
attributes like metadata.

00:18:10.690 --> 00:18:15.789
And these things are all defined again in the
AppKit/AssistDistributedString.h header.

00:18:15.789 --> 00:18:17.879
I urge you to take a look at it.

00:18:17.880 --> 00:18:22.930
They are all specified in enormous detail there.

00:18:22.930 --> 00:18:28.360
Now when you go to import from a rich
text document, usually it is not necessary

00:18:28.359 --> 00:18:30.839
to specify the format that you want to read.

00:18:30.839 --> 00:18:34.309
The text system can automatically
detect all these different formats.

00:18:34.309 --> 00:18:35.980
You can specify if you want.

00:18:35.980 --> 00:18:37.769
That's usually just for special cases.

00:18:37.769 --> 00:18:46.009
For example, if you wanted to read HTML in as source, as
plain text, source rather than as the attributed result.

00:18:46.009 --> 00:18:54.509
It's a bit different when it comes
to encodings for plain text.

00:18:54.509 --> 00:18:57.230
Fortunately in Leopard we have a new feature.

00:18:57.230 --> 00:19:02.240
And that is that we have a way of
tagging plain text documents according

00:19:02.240 --> 00:19:05.210
to their encoding using extended attributes.

00:19:05.210 --> 00:19:11.410
And when NSString writes out a string with an
encoding, it will automatically apply this tagging.

00:19:11.410 --> 00:19:16.310
And NSString and NSAttributedString
will use this if it is there when they read

00:19:16.309 --> 00:19:21.730
in that plain text document much better
than having to guess the encoding.

00:19:21.730 --> 00:19:28.839
If its not there, of course then you may be forced to
specify or if you don't specify we'll try to guess,

00:19:28.839 --> 00:19:32.689
but it really helps if you can
know the encoding of document's in.

00:19:32.690 --> 00:19:35.130
And just let me put in a plug.

00:19:35.130 --> 00:19:39.790
If you are planning to use plain text
documents, please try wherever possible

00:19:39.789 --> 00:19:45.099
to use a Unicode encoding like UTF-8, UTF-16.

00:19:45.099 --> 00:19:50.429
We also have a command line tool called a textutil
that provides access to these import

00:19:50.430 --> 00:19:53.170
and export features of the Cocoa text system.

00:19:53.170 --> 00:19:55.570
And it has a man page, you can read it.

00:19:55.569 --> 00:20:03.189
This is something you can use if you want to use
these features from a shell or from a script.

00:20:03.190 --> 00:20:08.090
Now in principle, it's possible to have any
combination of characters and attributes.

00:20:08.089 --> 00:20:12.699
But not all combinations of characters
and attributes make sense.

00:20:12.700 --> 00:20:18.309
For example, if you have a surrogate pair, it doesn't
really make sense to have different attributes

00:20:18.309 --> 00:20:20.789
on the low end or the high part of the surrogate pair.

00:20:20.789 --> 00:20:25.659
In general, if you have a character cluster like
an a with an accent, it doesn't really make sense

00:20:25.660 --> 00:20:27.690
to have different attributes on the a and the accent.

00:20:27.690 --> 00:20:32.519
This is not something that the Cocoa text system
tries to enforce, but we reserve the right to look

00:20:32.519 --> 00:20:36.289
at just the attributes on the first
character of the cluster.

00:20:36.289 --> 00:20:40.409
There are some other constraints
that can sometimes be enforced.

00:20:40.410 --> 00:20:45.630
So the paragraph style attribute that I mentioned
describes paragraph level formatting for the text

00:20:45.630 --> 00:20:49.660
and it really only makes sense if it is
actually constant over the whole paragraph.

00:20:49.660 --> 00:20:53.060
That is from one paragraph break to the next.

00:20:53.059 --> 00:21:00.099
And so there is a process, we call paragraph style fixing and
a method, fix paragraph style attribute and so forth

00:21:00.099 --> 00:21:08.359
that causes this to be enforced
by a setting, the paragraph style.

00:21:08.359 --> 00:21:15.759
Again the font that, attribute on a
certain characters should be a font

00:21:15.759 --> 00:21:18.170
that can actually represent those characters.

00:21:18.170 --> 00:21:26.250
And we have a process again called font fixing and a method
that will cause the fonts to be substituted as necessary

00:21:26.250 --> 00:21:29.220
if they cannot represent the characters
to which they are applied.

00:21:29.220 --> 00:21:34.799
And the text system will substitute a
font that can represent those characters.

00:21:34.799 --> 00:21:41.500
Also attachments are represented by characters that are
supposed to apply to Unicode replacement character FFFC

00:21:41.500 --> 00:21:47.000
and there's attachment fixing which removed the
attachment attributes from any other character.

00:21:47.000 --> 00:21:52.970
So for all of these, there is a single
method, fix attributes in range.

00:21:52.970 --> 00:21:58.600
And one thing to note about it is that it
fixes attributes only by changing attributes.

00:21:58.599 --> 00:22:02.490
It never changes the underlying characters.

00:22:02.490 --> 00:22:08.460
Now I mentioned NSTextStorage as a sub
class of NSMutableAttributedString.

00:22:08.460 --> 00:22:13.230
And it adds two things primarily
to NSMutableAttributedString.

00:22:13.230 --> 00:22:16.480
The first thing is that in an ordinary
MutableAttributedString,

00:22:16.480 --> 00:22:22.549
font attribute fixing happens only
when you explicitly ask for it.

00:22:22.549 --> 00:22:26.259
With NSTextStorage, attribute
fixing happens automatically.

00:22:26.259 --> 00:22:29.879
So whenever you look at the attributes,
you can be sure they've been fixed.

00:22:29.880 --> 00:22:36.670
The second thing that it adds is that
whenever an NSTextStorage is changed,

00:22:36.670 --> 00:22:42.370
it notifies classes in the controller level.

00:22:42.369 --> 00:22:45.309
It has, maintains a list of NSLayoutManagers.

00:22:45.309 --> 00:22:51.899
And tells them about its change so that they can keep
current any information they may have about the text.

00:22:51.900 --> 00:22:58.380
Now it's common that when you're making changes to
the text, you may be making many changes at once.

00:22:58.380 --> 00:23:03.610
And it would be inefficient to notify the layout
manager and have it do work for every little change.

00:23:03.609 --> 00:23:07.539
So what we have is a way for you to
batch up all those changes at once

00:23:07.539 --> 00:23:10.170
and just notify the layout managers at the end.

00:23:10.170 --> 00:23:16.410
And the way you do that is to called beginEditing before you
sequence of changes and then endEditing when you're done.

00:23:16.410 --> 00:23:19.080
So here's an example, the same code again.

00:23:19.079 --> 00:23:23.599
If you're modifying a text storage instead
of an arbitrary MutableAttributedString,

00:23:23.599 --> 00:23:26.159
you start of by calling beginEditing.

00:23:26.160 --> 00:23:31.090
Then you make all the changes just as before
and when you're done you call endEditing.

00:23:31.089 --> 00:23:39.559
Now if this text storage happens to be hooked up
to an NSTextView, NSTextView adds something.

00:23:39.559 --> 00:23:41.589
It adds undo.

00:23:41.589 --> 00:23:49.779
And if you want your change to be undoable, then you
also have to notify the text view of what you are doing.

00:23:49.779 --> 00:23:54.119
And the way you do that is adding a few more lines of code.

00:23:54.119 --> 00:23:59.699
First of all, before you want to make your changes, you call
out the text view and ask it should change text in range,

00:23:59.700 --> 00:24:04.769
replacement string or range is replacement
strings, you should listen to the answer too.

00:24:04.769 --> 00:24:06.569
Then you do your changes.

00:24:06.569 --> 00:24:08.399
One other little thing.

00:24:08.400 --> 00:24:14.060
The text view adds has, or possibly has its own notion
of a default paragraph style that it wants to be used

00:24:14.059 --> 00:24:17.359
in preference to the system wide default paragraph style.

00:24:17.359 --> 00:24:20.769
And then when you're done making your
changes, after you've called endEditing,

00:24:20.769 --> 00:24:24.369
then you call the text view and tell it didChangeText.

00:24:24.369 --> 00:24:28.009
And that's all you need to do to make it ready for undo.

00:24:28.009 --> 00:24:32.980
Oh, one other little thing I did here was
to set an action name that can be used

00:24:32.980 --> 00:24:36.250
on the undoManager for the title of the undo menu.

00:24:36.250 --> 00:24:42.500
Of course, in production code, you would make
sure this string was a localized string, right?

00:24:42.500 --> 00:24:47.000
Now this is starting to look like a lot of code.

00:24:47.000 --> 00:24:47.799
This is Cocoa.

00:24:47.799 --> 00:24:49.509
We don't like a lot of code.

00:24:49.509 --> 00:24:52.670
So we have an easier alternative.

00:24:52.670 --> 00:24:57.340
NSTextView implements a method changeAttributes.

00:24:57.339 --> 00:25:00.549
And you can call this and you,
it has one argument, the sender.

00:25:00.549 --> 00:25:08.129
Is some class that you define, and all the sender has
to do is implement a method called convertAttributes.

00:25:08.130 --> 00:25:10.260
Takes a dictionary, returns a dictionary.

00:25:10.259 --> 00:25:17.730
And what NSTextView will do is go through and for
each set of attributes that needs to be modified,

00:25:17.730 --> 00:25:20.170
it'll pass in those attributes as a dictionary.

00:25:20.170 --> 00:25:23.640
All you do is make your change to
those attributes and return it.

00:25:23.640 --> 00:25:29.570
So for this particular change, centering, all
we would have to do is have a center object

00:25:29.569 --> 00:25:37.559
which would implement convertAttributes to just make
this change, center the text for the paragraph style.

00:25:37.559 --> 00:25:39.879
We wouldn't need to do all of that other stuff.

00:25:39.880 --> 00:25:41.870
It would be done for us.

00:25:43.019 --> 00:25:45.529
So let's talk about customization.

00:25:45.529 --> 00:25:54.700
Why might I want to customize the text system at the model
level with a custom subclass in NSTextStorage?

00:25:54.700 --> 00:25:56.710
Well, there are several possible reason.

00:25:56.710 --> 00:26:02.150
One for example, I might want to
customize the attribute fixing process.

00:26:02.150 --> 00:26:04.940
I could have a custom subclass of NSTextStorage

00:26:04.940 --> 00:26:08.720
and override the attribute fixing
and have complete control over it.

00:26:08.720 --> 00:26:15.240
Another possibility is that I might have a different
way of storing text other than as characters

00:26:15.240 --> 00:26:21.049
and attribute dictionaries, but I still want to present
it to the Cocoa Text system with that sort of interface.

00:26:21.049 --> 00:26:27.440
In that case I could use a custom text storage that
could provide the text system with what it needs.

00:26:27.440 --> 00:26:32.720
But store it under an underlying in any form that I want.

00:26:32.720 --> 00:26:39.309
One sub possibility of this is for example the one
that is used by Xcode for its code folding feature.

00:26:39.309 --> 00:26:45.799
It has an underlying attributed string
that represents the entire unfolded text.

00:26:45.799 --> 00:26:53.990
But then it has a custom subclass of NSTextStorage
that presents the folded text derived from that

00:26:53.990 --> 00:26:58.809
to the text system for display and editing.

00:26:58.809 --> 00:27:00.759
So now let's go over to the demo machine.

00:27:00.759 --> 00:27:02.769
( Period of silence )

00:27:02.769 --> 00:27:07.470
And let me show an example of this.

00:27:07.470 --> 00:27:08.890
( Period of silence )

00:27:08.890 --> 00:27:16.350
So the, the system of characters and attributes
that we have is fine for a lot of purposes.

00:27:16.349 --> 00:27:18.519
But what if it doesn't meet your particular needs?

00:27:18.519 --> 00:27:20.440
Well, you could just change it.

00:27:20.440 --> 00:27:24.850
What I've got here is a custom NSTextStorage subclass.

00:27:24.849 --> 00:27:26.589
It works just like an ordinary text storage.

00:27:26.589 --> 00:27:29.419
For everything in it except for the text color.

00:27:29.420 --> 00:27:35.640
And I've specified certain parts of this text
as headings and certain parts as sub headings

00:27:35.640 --> 00:27:39.400
and certain parts as, the rest of it is body text.

00:27:39.400 --> 00:27:45.070
And so I have this sort of rudimentary style
system here, just to show you you can do it.

00:27:45.069 --> 00:27:51.769
And what this does is for all the heading text, it
doesn't apply any color that might be on the text.

00:27:51.769 --> 00:27:55.089
It applies the heading color.

00:27:55.089 --> 00:28:03.569
And for any text that's specified as sub heading, it
uses the color that's specified as a sub heading color.

00:28:03.569 --> 00:28:08.750
And for all the remaining text, uses a
color that's specified as a body color.

00:28:08.750 --> 00:28:11.400
Some nice bright colors.

00:28:11.400 --> 00:28:14.750
Let's see what this looks like in code.

00:28:14.750 --> 00:28:18.250
So I have a custom subclass of NSTextStorage.

00:28:18.250 --> 00:28:23.839
And really there are three methods
here that I really need to override.

00:28:23.839 --> 00:28:30.980
I use a mutable attributable string I call
contents to actually store the underlying text.

00:28:30.980 --> 00:28:36.029
And then I've replaced characters in range with string.

00:28:36.029 --> 00:28:37.940
These are the primitives.

00:28:37.940 --> 00:28:42.720
And that just replaces the characters in
the underlying mutable attributed string.

00:28:42.720 --> 00:28:50.140
And then it calls this method on NSTextStorage,
edited range, change in length and that is the method

00:28:50.140 --> 00:28:53.790
that causes the layout measures
to be notified of the change.

00:28:53.789 --> 00:28:56.940
Very simple, as is anything you do in any subclass.

00:28:56.940 --> 00:29:01.090
And likewise with setAttributes, we set
the attributes on the underlying contents

00:29:01.089 --> 00:29:05.059
and then we cause the layout managers to be notified.

00:29:05.059 --> 00:29:11.730
The real meat of this is in our override of attributes
that index effective range that returns the attributes.

00:29:11.730 --> 00:29:15.289
For every attribute except for the foreground color,

00:29:15.289 --> 00:29:21.460
we are just going to return the
underlying attributes on our contents.

00:29:21.460 --> 00:29:27.579
But I have defined a custom attribute
that I call headingType.

00:29:27.579 --> 00:29:32.069
And that specifies whether the text
is heading or subheading or body.

00:29:32.069 --> 00:29:37.909
And whenever I encounter that, then I
just synthesize a color based on that

00:29:37.910 --> 00:29:43.090
as specified elsewhere and I use that as a foreground color.

00:29:43.089 --> 00:29:45.309
And those are the attributes that are returned.

00:29:45.309 --> 00:29:48.279
These synthesized set of attributes,
I return those to the text system.

00:29:48.279 --> 00:29:53.889
And those are the attributes that get used.

00:29:53.890 --> 00:29:55.690
So let's go back to the slides.

00:29:55.690 --> 00:29:58.039
( Period of silence )

00:29:58.039 --> 00:30:07.159
And now let's go to the controller level
and the main class in the Cocoa text system

00:30:07.160 --> 00:30:09.690
at the controller level is NSLayoutManager.

00:30:09.690 --> 00:30:13.320
And NSLayoutManager is the boss of the text system.

00:30:13.319 --> 00:30:17.009
It manages all the processes that go on.

00:30:17.009 --> 00:30:22.009
You remember that I said that the main job
of the text system was to convert characters

00:30:22.009 --> 00:30:24.220
and attributes into glyphs and their positions.

00:30:24.220 --> 00:30:27.470
So there are two main processes that are involved here.

00:30:27.470 --> 00:30:30.230
One we call glyph generation where we get the glyphs.

00:30:30.230 --> 00:30:35.220
And the second is layout where we position them into lines.

00:30:35.220 --> 00:30:40.630
And NSLayoutManager calls on two
subsidiary classes. First, NSGlyphGenerator

00:30:40.630 --> 00:30:43.900
to do the glyph generation and
NSTypeSetter to do the layout.

00:30:43.900 --> 00:30:46.290
And then NSLayoutManager stores all the results.

00:30:46.289 --> 00:30:50.059
And its NSLayoutManager that
actually does the drawing for the view.

00:30:50.059 --> 00:30:54.049
So first glyph generation.

00:30:54.049 --> 00:30:59.450
Now one thing to remember about NSLayoutManager
is that it's extremely lazy, just like you and me.

00:30:59.450 --> 00:31:03.360
It does not calculate a result until it actually needs it.

00:31:03.359 --> 00:31:08.149
So its not going to do glyph generation until
for example some client asks it a question

00:31:08.150 --> 00:31:10.910
for which it needs to have the glyphs to answer it.

00:31:10.910 --> 00:31:14.580
Also for Leopard we've added some
explicit methods that you can call

00:31:14.579 --> 00:31:19.460
to explicitly request glyph generation for a specific range.

00:31:19.460 --> 00:31:23.529
And when that happens, the layout
manager will call on the glyph generator,

00:31:23.529 --> 00:31:27.399
saying give me the glyphs for this range of characters.

00:31:27.400 --> 00:31:32.470
And then the glyph generator calls back
to the layout manage with the glyphs

00:31:32.470 --> 00:31:37.789
that it has generated plus some attributes for them.

00:31:37.789 --> 00:31:40.109
And a layout manager stores them.

00:31:40.109 --> 00:31:43.469
Now if you want to use glyph generator
without layout manager, you could do it.

00:31:43.470 --> 00:31:47.559
All you have to do is implement these
same methods that layout manager does

00:31:47.559 --> 00:31:49.559
to receive the results from the glyph generator.

00:31:49.559 --> 00:31:53.450
And there's a protocol for that, glyph storage protocol.

00:31:53.450 --> 00:31:55.420
Layout, similarly.

00:31:55.420 --> 00:31:57.220
Layout is done very lazily.

00:31:57.220 --> 00:32:01.220
Layout manager is not going to do layout
until it actually needs the result.

00:32:01.220 --> 00:32:05.230
Perhaps some client has asked a question for
which it needs layout to give the answer.

00:32:05.230 --> 00:32:10.769
Or again we have some new explicit calls that you
can use to force layout for a particular range

00:32:10.769 --> 00:32:16.329
of characters or range in the text, the screen.

00:32:16.329 --> 00:32:19.250
And when it needs to do layout, the
layout manager calls on the typesetter.

00:32:19.250 --> 00:32:23.480
Typesetter, get me some layout for this range.

00:32:23.480 --> 00:32:28.250
And then the typesetter calls back to the
layout manager, as I'm going to discuss.

00:32:28.250 --> 00:32:30.099
And the layout manager stores the results.

00:32:30.099 --> 00:32:32.879
Now there's one very important that is new in Leopard.

00:32:32.880 --> 00:32:35.560
And that's what we call non-contiguous layout.

00:32:35.559 --> 00:32:38.419
In Tiger, layout was always contiguous.

00:32:38.420 --> 00:32:43.300
That is we would never do a layout for one piece
of text without having layout for all the text

00:32:43.299 --> 00:32:46.220
from the beginning of the document to that point.

00:32:47.420 --> 00:32:49.420
In Leopard we've added a switch you can turn on.

00:32:49.420 --> 00:32:55.269
And when the switch is turned on then the layout
manager will, is allowed to, doesn't have to

00:32:55.269 --> 00:33:01.779
but will if it thinks it can do layout for one piece
of text without having, necessarily having layout

00:33:01.779 --> 00:33:04.710
for any other piece of text before or after.

00:33:04.710 --> 00:33:08.750
And the reason we implemented this is because it's
an enormous performance win for large documents.

00:33:08.750 --> 00:33:15.789
With this change, with this turned on, text data can
easily open and deal with a million line text document.

00:33:15.789 --> 00:33:21.899
And the reason its not on default is for capability reasons,
because it makes significant changes to the behavior

00:33:21.900 --> 00:33:24.060
of many of the methods in NSLayoutManager.

00:33:24.059 --> 00:33:29.279
Now if you are using NSLayoutManager
only indirectly, say through NSTextView,

00:33:29.279 --> 00:33:32.220
then you could probably turn this
on without worrying much about it.

00:33:32.220 --> 00:33:39.079
But if you are actually calling NSLayoutManager's
directly, then you will need before try turning this on,

00:33:39.079 --> 00:33:45.679
you would need to review all your usage of layout manager
methods to make sure that, to see whether you need

00:33:45.680 --> 00:33:51.000
to make any change to respond to this and if
you look at the layout manager header, there,

00:33:51.000 --> 00:33:54.650
it's a bunch of descriptions there of
how non-contiguous layout changes behavior

00:33:54.650 --> 00:33:58.470
of each different method on NSLayoutManager.

00:33:58.470 --> 00:34:05.420
So during the layout process, one thing I
need to, should mention is that the glyphs

00:34:05.420 --> 00:34:11.490
that the glyph generator produces aren't necessarily
only preliminary, not necessarily final.

00:34:11.489 --> 00:34:18.019
And the reason is that in many fonts, many writing
systems, the actual glyphs that it used depend on context.

00:34:18.019 --> 00:34:21.940
That is on the other glyphs to the
right and left of it in the line.

00:34:21.940 --> 00:34:25.470
And the glyph generator doesn't
know what glyphs are in a line.

00:34:25.469 --> 00:34:28.309
It's only the layout manager that puts glyphs in the line.

00:34:28.309 --> 00:34:33.549
So its, the layout manager has to have, it's only
the typesetter that puts the glyphs in the lines.

00:34:33.550 --> 00:34:39.920
So the typesetter has to have the ability to make
contextual changes to the glyphs during the layout process.

00:34:39.920 --> 00:34:47.840
And it does so by calling again on the layout manager,
telling it to insert or remove or rearrange glyphs.

00:34:47.840 --> 00:34:55.010
Now in general, it's important to remember the mapping
between characters and glyphs is not one to one.

00:34:55.010 --> 00:34:56.720
It's potentially many to many.

00:34:56.719 --> 00:35:03.109
A single character can be represented by many glyphs,
multiple characters can be represented by one glyph.

00:35:03.110 --> 00:35:08.809
But we do make the restriction in the layout
manager that this mapping is always in order.

00:35:08.809 --> 00:35:12.269
That is the glyphs are always stored in logical order,

00:35:12.269 --> 00:35:15.480
in the same order as the characters
from which they are generated.

00:35:15.480 --> 00:35:20.159
If they need to be reordered say
for example for bidirectional text,

00:35:20.159 --> 00:35:26.319
then we do that by changing their locations and positions in
the line, not by changing their indexes in the glyph stream.

00:35:26.320 --> 00:35:29.120
( Period of silence )

00:35:29.119 --> 00:35:32.789
So after it may have made modification to
the glyphs, the typesetter positions them

00:35:32.789 --> 00:35:35.009
by calling three methods in a particular order.

00:35:35.010 --> 00:35:42.540
First it tells the layout manager which page, which
text container the glyphs have been placed in.

00:35:42.539 --> 00:35:50.550
Then it tells them what line a particular set of glyphs has
been placed in and where that line is and what its size is.

00:35:50.550 --> 00:35:55.840
And then for each glyph or each run of glyphs in that line,
it tells the layout manager where those glyphs are located.

00:35:55.840 --> 00:35:57.840
And the layout manager stores all this information.

00:35:57.840 --> 00:36:04.700
There are a few other things for special circumstances, some
glyphs are not shown, some may draw outside of their lines,

00:36:04.699 --> 00:36:10.250
some may be attachments and the layout
manager is told of all these things as well.

00:36:10.250 --> 00:36:12.179
So here's a brief example.

00:36:12.179 --> 00:36:15.989
We have some English language text and some Arabic text.

00:36:15.989 --> 00:36:18.739
At the top, the underlying characters are the bottom glyphs.

00:36:18.739 --> 00:36:20.549
There are two things I want to point out.

00:36:20.550 --> 00:36:26.780
First of all, even in ordinary ASCII English language
text, here we have a case where two characters, F and I,

00:36:26.780 --> 00:36:31.660
are represented by a single glyph, and FI ligature glyph.

00:36:31.659 --> 00:36:37.039
Now when we go over to our Arabic text, Arabic
is first of all it's written from right to left.

00:36:37.039 --> 00:36:42.989
Second it's typically a cursive style,
handwriting style, writing system.

00:36:42.989 --> 00:36:48.469
So most glyphs are going to be modified contextually
based on the other glyphs to the right and left of them.

00:36:48.469 --> 00:36:49.529
And you can see that here.

00:36:49.530 --> 00:36:57.040
First of all, the glyphs remain in order in logical order
in the glyph storage, but their positions are reversed,

00:36:57.039 --> 00:37:05.210
go from right to left plus most of them have a different
form in, in context than they would in isolation.

00:37:05.210 --> 00:37:11.610
Okay, there's another set of processes that are in
some sense the inverse of what we've just discussed.

00:37:11.610 --> 00:37:12.950
And that's invalidation.

00:37:12.949 --> 00:37:17.489
The layout manager stores lots of information so it
has to know when that information is no longer valid

00:37:17.489 --> 00:37:21.679
so it can discard it and eventually
later recalculate it if necessary.

00:37:21.679 --> 00:37:26.359
We have three kinds, display invalidation
will tell the view if there's a view

00:37:26.360 --> 00:37:30.160
to that a certain region needs to be redisplayed.

00:37:30.159 --> 00:37:38.250
Layout invalidation tells the layout manager that a
certain portion of layout isn't valid and can be discarded

00:37:38.250 --> 00:37:41.780
Glyph invalidation says that the glyphs are no longer valid.

00:37:41.780 --> 00:37:46.330
And should be discarded plus the layout
because that depends on the glyphs.

00:37:46.329 --> 00:37:54.980
And if this information needs to be recalculated
later, again it'll be done so lazily only as needed.

00:37:54.980 --> 00:37:56.780
So let me go through an example.

00:37:56.780 --> 00:38:01.090
The user types a character in some
existing text in text view.

00:38:01.090 --> 00:38:10.240
So the text view gets key down events and eventually
ends up inserting that character into the text storage.

00:38:10.239 --> 00:38:12.699
Makes a change directly in the text storage.

00:38:12.699 --> 00:38:17.089
Text storage as I said notifies the
layout manager whenever it's changed.

00:38:17.090 --> 00:38:18.829
That's its job.

00:38:18.829 --> 00:38:22.659
And then the layout manager discards any
information that it had about the layout

00:38:22.659 --> 00:38:26.230
of the characters around that one that was just typed.

00:38:26.230 --> 00:38:30.809
So eventually now that text view is
going to be, end up being redisplayed.

00:38:30.809 --> 00:38:36.929
And when that happens, text view is going to say,
hey layout manager, what do I need to display?

00:38:36.929 --> 00:38:39.730
And the layout manager will say, well I don't know that.

00:38:39.730 --> 00:38:40.980
Ask the glyph generator.

00:38:40.980 --> 00:38:42.400
Give me some glyphs.

00:38:42.400 --> 00:38:45.269
And it will ask the typesetter, give me some layout.

00:38:45.269 --> 00:38:50.840
And then it will go back to the text view and say, what
needs to be displayed, which glyphs need to be displayed?

00:38:50.840 --> 00:38:56.650
And then finally the text view is going to call on
the layout manager to actually display those glyphs.

00:38:56.650 --> 00:39:02.240
So the layout manager stores all sorts
of information about the layout of text.

00:39:02.239 --> 00:39:06.169
Anything you might want to know, the
layout manager knows all if you ask it.

00:39:06.170 --> 00:39:14.930
Any of the correspondences between characters and glyphs
and positions of glyphs and lines, back and forth.

00:39:14.929 --> 00:39:18.509
The layout manager has methods to do all these things.

00:39:18.510 --> 00:39:24.870
In fact anything that you need to do with
measurement of text or also with drawing of text,

00:39:24.869 --> 00:39:30.819
it goes beyond what the simple string drawing methods can
give you, you probably want to go to NSLayoutManager

00:39:30.820 --> 00:39:37.280
for that, because as I said the layout manager is
also what does the display of glyphs for the view.

00:39:37.280 --> 00:39:38.490
It does it over in this text view.

00:39:38.489 --> 00:39:40.519
It could do it for your view if you like.

00:39:40.519 --> 00:39:42.829
There are two main entry points for this.

00:39:42.829 --> 00:39:49.279
First of all, one for drawBackgroundForFlyphRange:atPoint
that does background colors.

00:39:49.280 --> 00:39:52.930
It does table borders and backgrounds and so forth.

00:39:52.929 --> 00:40:00.379
And then there's a second method, drawGlyphsForGlyphRange
that does the glyphs and any decorations

00:40:00.380 --> 00:40:05.660
like underlines and strike throughs
that might go over the glyphs.

00:40:05.659 --> 00:40:11.359
These methods assume that focus is locked on a
flipped view or image or other graphics context.

00:40:11.360 --> 00:40:15.059
And these are two possible points for overriding.

00:40:15.059 --> 00:40:17.150
There are some other more specific points.

00:40:17.150 --> 00:40:21.710
The method showPackedGlyphs:length
is specifically for glyph drawing.

00:40:21.710 --> 00:40:26.199
There are specific methods that you could override for
drawing underlines, drawing strike throughs and so forth.

00:40:26.199 --> 00:40:30.369
There are some other classes that can be
overridden for specific kinds of drawing.

00:40:30.369 --> 00:40:36.839
NSTextAttachmentCell for attachment drawing,
NSTextBlock for table cells.

00:40:36.840 --> 00:40:42.650
So how can we customize the text
system at the controller level?

00:40:42.650 --> 00:40:46.260
Any of these three classes can be
overridden with a custom subclass.

00:40:46.260 --> 00:40:48.790
You could have a custom glyph generator for example.

00:40:48.789 --> 00:40:54.769
If you wanted to have full control over the
initial mapping between characters and glyphs.

00:40:54.769 --> 00:41:01.630
You could have a custom typesetter
subclass if you want to modify the layout

00:41:01.630 --> 00:41:04.809
of the lines and the layout of glyphs in lines.

00:41:04.809 --> 00:41:11.119
You could have a custom layout manager subclass
if you want to make some modifications to any

00:41:11.119 --> 00:41:17.650
of the drawing that's being done in the text at the
level of individual glyphs and individual lines of text.

00:41:17.650 --> 00:41:19.090
So let's have an example of that.

00:41:19.090 --> 00:41:20.840
We can go back to the demo machine.

00:41:20.840 --> 00:41:23.190
( Period of silence )

00:41:23.190 --> 00:41:29.000
So the text system has a lot of different attributes,
but what if it doesn't have the one that I want?

00:41:29.000 --> 00:41:32.179
In this case I've decided that bright
colors aren't really enough here.

00:41:32.179 --> 00:41:36.149
They don't make my headings and subheadings
stand out the way I want them to.

00:41:36.150 --> 00:41:39.440
So I want to do some extra special
fancy drawing behind these headings

00:41:39.440 --> 00:41:43.880
and subheadings so it really stand out, whoa, like that.

00:41:43.880 --> 00:41:51.460
So now I've done this with a fancy Bezier paths
and gradients to show off some Leopard features.

00:41:51.460 --> 00:41:57.869
But also to show that you know you could do any kind
of crazy drawing that you want right there in the text.

00:41:57.869 --> 00:42:07.099
And the way I've done this is that I have a custom layout
manager subclass that does my extra special fancy drawing

00:42:07.099 --> 00:42:13.500
and I have custom typesetter subclass that
expands the layout around these lines to make room

00:42:13.500 --> 00:42:16.079
for my extra special fancy drawing around them.

00:42:16.079 --> 00:42:20.340
So let's take a look at that in the code.

00:42:20.340 --> 00:42:20.559
( Period of silence )

00:42:20.559 --> 00:42:23.320
First of all, my custom typesetter subclass.

00:42:23.320 --> 00:42:27.710
Now NSTypesetter has many different override
points so I've chosen one of them here.

00:42:27.710 --> 00:42:29.619
I've just overridden one method.

00:42:29.619 --> 00:42:37.069
And all I do is if it's enabled, if it's turned on,
then I go back to the text storage and look to see

00:42:37.070 --> 00:42:41.490
if the line is a special heading or subheading.

00:42:41.489 --> 00:42:48.169
And if it is, then I just increase the space
available by some amount that I know is suitable

00:42:48.170 --> 00:42:51.349
to make space for my extra special fancy drawing.

00:42:51.349 --> 00:42:53.289
Very simple.

00:42:53.289 --> 00:42:59.519
And then my custom layout manager here the method
I've chosen to override is the one I mentioned before

00:42:59.519 --> 00:43:06.250
for drawing backgrounds because these, this extra
special fancy drawing is background behind the text.

00:43:06.250 --> 00:43:08.519
And again, it's pretty simple.

00:43:08.519 --> 00:43:12.739
If it's turned on then we're going to
go through the text that we're drawing.

00:43:12.739 --> 00:43:18.789
We're going to go through it line by line.

00:43:18.789 --> 00:43:26.579
And see if that is one of our special headings
or subheadings and if it is then we're going

00:43:26.579 --> 00:43:35.869
to take the position and size that line and from
it construct a Bezier path and draw that path

00:43:35.869 --> 00:43:39.880
and a gradient within it to do
our extra special fancy drawing.

00:43:39.880 --> 00:43:43.809
And then of course we call super to do
the normal behavior for everything else.

00:43:43.809 --> 00:43:49.250
So this is how if the text system doesn't
support the kind of drawing that you want it to,

00:43:49.250 --> 00:43:54.260
you can add just about anything to it that you want.

00:43:54.260 --> 00:43:54.460
( Period of silence )

00:43:54.460 --> 00:44:00.500
Let's go back to the slides.

00:44:00.500 --> 00:44:05.789
( Period of silence )
So for the rest of the talk, I want to turn the stage
over to my colleague Aki Inoue whose going to talk

00:44:05.789 --> 00:44:10.820
about some of the very interesting things
you can do with fonts in Cocoa text system.

00:44:11.940 --> 00:44:13.099
>> Thanks Doug.

00:44:13.099 --> 00:44:15.690
( Applause )

00:44:15.690 --> 00:44:19.389
Hi I'm Aki Inoue from Cocoa group.

00:44:19.389 --> 00:44:27.670
Today I'd like to discuss font handling in
Cocoa especially focusing on customization.

00:44:27.670 --> 00:44:29.430
Let's get started.

00:44:31.190 --> 00:44:35.599
There are four principle font handling
classes in Cocoa, NSFont,

00:44:35.599 --> 00:44:40.710
NSFontDescriptor, NSFontManager, and NSFontPanel.

00:44:40.710 --> 00:44:46.409
I'm going to be discussing each of these later in detail.

00:44:46.409 --> 00:44:52.629
From the beginning, the font architecture was
designed with the Unicode standard in mind.

00:44:52.630 --> 00:44:56.890
It works with the character exclusively.

00:44:56.889 --> 00:45:02.969
Since we don't have any legacy font
encoding heritage in this environment,

00:45:02.969 --> 00:45:09.039
we can offer very clean and consistent font API.

00:45:09.039 --> 00:45:19.699
And as with other products of Cocoa framework, FontDescriptor,
FontManager and FontPanel follows

00:45:19.699 --> 00:45:27.210
that model view controller design pattern
and it gives us straightforward customizability

00:45:27.210 --> 00:45:32.119
and extensibility for the subsystem.

00:45:32.119 --> 00:45:35.779
Let's look at, let's talk about NSFont.

00:45:35.780 --> 00:45:39.870
NSFont is that graphics primitive in Cocoa.

00:45:39.869 --> 00:45:48.519
This is the object you most likely dealing
with when you are handling your style of text.

00:45:48.519 --> 00:45:59.460
It is roughly equivalent Java AWT font in Java
environment or the font handlers in Windows GDI.

00:45:59.460 --> 00:46:03.579
This is the value for NSFontAttribute name.

00:46:03.579 --> 00:46:07.449
This is for the font information in your attributed strings.

00:46:07.449 --> 00:46:17.149
NSFont encapsulates multiple font
information into a single, convenient package.

00:46:17.150 --> 00:46:23.369
It includes typeface information, size and rendering mode.

00:46:24.659 --> 00:46:32.469
The size can be specified with a point size
and/or transformation, transformation metrics.

00:46:32.469 --> 00:46:37.829
The font rendering mode consists of
graphics rendering appearance settings

00:46:37.829 --> 00:46:43.719
such as anti aliasing or ideal advancement settings.

00:46:45.289 --> 00:46:52.849
You can ask NSFont detailed typeface
information for rendering or layout.

00:46:52.849 --> 00:46:59.710
Those include names, postscript
names, following name, you name it.

00:46:59.710 --> 00:47:07.110
Or you can ask font wide matrix such
as ascender, descender, leading.

00:47:07.110 --> 00:47:12.760
Or you can ask information about
each of the glyphs in your font.

00:47:12.760 --> 00:47:15.490
Such as bounding in box over (unclear) glyph.

00:47:15.489 --> 00:47:21.159
You can directly access NSFont for those information.

00:47:21.159 --> 00:47:28.899
However, we are recommending you use the approaches
Doug mentioned earlier in this presentation.

00:47:28.900 --> 00:47:38.139
They are NSDrawing, NSStringDrawing API or NSLayoutManager
if you are rendering or measuring text.

00:47:38.139 --> 00:47:49.509
Since those possibilities provide higher level abstraction,
you don't have to deal with going detail of Unicode there.

00:47:49.510 --> 00:47:55.000
In Leopard we added some enhancements to NSFont.

00:47:55.000 --> 00:48:01.329
Prior to Leopard, majority of NSFont
instances were cached by the system

00:48:01.329 --> 00:48:06.610
and never delegated during the lifetime of application.

00:48:06.610 --> 00:48:14.210
In Leopard, all the font instance follow
the Cocoa memory management combination.

00:48:14.210 --> 00:48:21.400
Subject to the allocation of final revision, depending
on your application's memory management conservation.

00:48:21.400 --> 00:48:27.900
It gives draw screen more efficient
system font users especially

00:48:27.900 --> 00:48:33.970
if your application needs a large number
of typeset usage in your application.

00:48:33.969 --> 00:48:35.549
But be careful.

00:48:35.550 --> 00:48:42.289
Since now NSFont objects can be deallocated,
it might reveal issues in the application.

00:48:42.289 --> 00:48:48.829
For example, if you overrelease font
instances or productive retain in your variable.

00:48:48.829 --> 00:48:51.849
It might be deallocated underneath you.

00:48:51.849 --> 00:49:01.610
NSFont instances are now toll-free bridged
FUI which CTFont from Core Text framework.

00:49:01.610 --> 00:49:07.539
So that we can now have unified NSFont, unified
font representation throughout the system.

00:49:07.539 --> 00:49:16.150
With NSFontFeatureSettingsAttribute,
you can have programming,

00:49:16.150 --> 00:49:19.990
programmatic access to the advance type review features.

00:49:19.989 --> 00:49:26.299
Previously only accessible from the
typography panel user interface.

00:49:26.300 --> 00:49:39.110
And we enhanced the system so your applications can now
use other multiple master font or true type variation font.

00:49:39.110 --> 00:49:46.530
Finally, we completed the API usage
clean up process, started in Tiger.

00:49:46.530 --> 00:49:49.820
NSFont is now fully subclassable.

00:49:49.820 --> 00:49:55.490
You don't override any of the public API in NSFont object.

00:49:55.489 --> 00:49:58.629
And customize the behavior in the text system.

00:49:58.630 --> 00:50:04.769
Now let's talk about other part of Cocoa.

00:50:04.769 --> 00:50:11.759
Behind the NSFontPanel view, there
is model view controller relationship.

00:50:11.760 --> 00:50:16.570
NSFontDescriptor is the data model object.

00:50:16.570 --> 00:50:20.980
And represent each type faces available
to your applications.

00:50:20.980 --> 00:50:28.510
And NSFontManager manages those data
object and coordinates with the view objects

00:50:28.510 --> 00:50:32.270
such as NSFontPanel or NSFont menus.

00:50:32.269 --> 00:50:36.190
And there's no NSFont menus, just font menu.

00:50:36.190 --> 00:50:45.079
NSFontManager, it manage all other
font descriptors in your application.

00:50:45.079 --> 00:50:51.219
When you want to know all the font names
available to your applications, ask font manager.

00:50:51.219 --> 00:50:57.629
When you want to know all the file names that are
available to your application, ask the font manager.

00:50:57.630 --> 00:51:02.140
NSFontManager also manages font collections.

00:51:02.139 --> 00:51:08.549
You can add, delete, modify font collection.

00:51:08.550 --> 00:51:13.440
By the way, a font collection is a back of font descriptors.

00:51:13.440 --> 00:51:19.099
And suppose convenient font manager
in facility to your end users.

00:51:19.099 --> 00:51:26.539
And NSFontManager can map between type faces.

00:51:26.539 --> 00:51:32.789
For example, you can map, you can
query for mod version of a font.

00:51:32.789 --> 00:51:38.230
Or you can ask for a different
typeface in a different family.

00:51:38.230 --> 00:51:48.960
And NSFontManager can manage a notion
of font select in your application.

00:51:48.960 --> 00:51:58.369
By managing the current font selection abstractly, it
can act as a middle man between the your document object

00:51:58.369 --> 00:52:07.230
and standard font using interface
in Cocoa framework such as NSPanel.

00:52:07.230 --> 00:52:10.820
Now let's look at an NSFontPanel.

00:52:10.820 --> 00:52:18.630
NSFontPanel provides the standard font selection
using interface for both Cocoa and Carbon applications.

00:52:18.630 --> 00:52:23.360
And it has bit point font collection management facility.

00:52:23.360 --> 00:52:28.490
So end user can manage the font
selection right in the panel without going

00:52:28.489 --> 00:52:33.469
to any special font management
application such as Font Book.

00:52:33.469 --> 00:52:40.309
It is highly customizable for both
end users and programmers.

00:52:40.309 --> 00:52:48.179
And it gives you access to a variety
of features such as typography panel,

00:52:48.179 --> 00:52:54.139
or text effects such as underline or shadows.

00:52:54.139 --> 00:52:58.929
Let's talk about customizing NSFontPanel.

00:52:58.929 --> 00:53:02.569
You can customize font panel in two ways.

00:53:02.570 --> 00:53:12.620
You can add your own controls to NSFontPanel
via calling setAccessoryView.

00:53:12.619 --> 00:53:20.250
Or you can customize or limit the control available
inside of panel depending on your document object using

00:53:20.250 --> 00:53:24.199
the validateModesForFontPanel method.

00:53:24.199 --> 00:53:33.569
Let's talk about, let's take a look at how
to add accessory view to your font panel.

00:53:33.570 --> 00:53:40.390
You can create any view with controls of your
choice in Interface Builder and add that view

00:53:40.389 --> 00:53:43.869
to the font panel using setAccessoryView like this.

00:53:43.869 --> 00:53:46.400
It's pretty simple.

00:53:46.400 --> 00:53:54.349
And NSFontPanel just accommodates
its frame based on your views frame.

00:53:54.349 --> 00:53:58.900
This is a normal font panel.

00:53:58.900 --> 00:54:02.269
And with accessory view.

00:54:02.269 --> 00:54:11.610
When you want to apply your change in accessory view,
just as Doug mentioned in this earlier presentation,

00:54:11.610 --> 00:54:16.769
you can send change attributes
message to your first responder.

00:54:16.769 --> 00:54:26.309
The document object reply with
convertAttributes multiple time

00:54:26.309 --> 00:54:30.039
for each of the runs in the document selection.

00:54:30.039 --> 00:54:30.599
( Period of silence )

00:54:30.599 --> 00:54:34.059
This is how you do it.

00:54:34.059 --> 00:54:45.389
As with normal action of messages, you can send
changeAttributes message to the new target

00:54:45.389 --> 00:54:52.469
and NSApplication objects write the message
appropriate for, appropriate in the creation.

00:54:52.469 --> 00:54:56.099
It's typical you document object.

00:54:56.099 --> 00:55:03.549
In the convert attributes, you can return the
modified version of the paths (unclear) attributes.

00:55:03.550 --> 00:55:08.769
Just focusing to the attributes you are interested in.

00:55:08.769 --> 00:55:16.090
When you update, you are using interface
according to the user selection.

00:55:16.090 --> 00:55:24.930
You can subclass NSFontManager and implement
setSelectedAttributes as multiple message method.

00:55:24.929 --> 00:55:35.719
On the document object participating in Cocoa text
system sends that message to the shared font manager.

00:55:35.719 --> 00:55:45.539
Inside your algorithm method, you can route
the message to your own font accessory view.

00:55:45.539 --> 00:55:47.139
That's pretty simple.

00:55:47.139 --> 00:55:57.029
So inside your subclass NSFontManager, you can
implement selected attributes is multiple method.

00:55:57.030 --> 00:56:05.410
Don't forget send message to super so that all the
other font are using interface can update its state

00:56:05.409 --> 00:56:10.639
and you can reroute the message
to your own FontAccessoryView.

00:56:10.639 --> 00:56:20.900
With your setSelect, setSelectedAttributes with
access method with accessory view, it's pretty simple.

00:56:20.900 --> 00:56:28.550
You can update your user interface depending on
your, depending on attributes in you are passing.

00:56:28.550 --> 00:56:36.360
Of course you can use the Cocoa binding here to
further automate that user interface update.

00:56:36.360 --> 00:56:42.740
Finally by implementing validModesForFontPanel
in your document object,

00:56:42.739 --> 00:56:47.769
you can limit the control available
for your, for your document.

00:56:47.769 --> 00:56:53.960
In this case, I'm already doing
NSFontPanel, FaceModeMask,

00:56:53.960 --> 00:57:01.309
and it's going to be NSFontPanel is going to
be displaying just a type face column

00:57:01.309 --> 00:57:08.029
in addition to the font family column here.

00:57:09.300 --> 00:57:16.620
Let's talk a look in a demo.

00:57:16.619 --> 00:57:18.639
( Period of silence )
Demo two please.

00:57:18.639 --> 00:57:20.089
>> (Unclear)

00:57:20.090 --> 00:57:20.120
>> Oh.

00:57:20.119 --> 00:57:20.279
( Period of silence )

00:57:20.280 --> 00:57:21.740
Thank you.

00:57:24.260 --> 00:57:31.280
This is a slightly modified version of text
edit application you are all familiar with.

00:57:31.280 --> 00:57:33.870
And opening a font panel.

00:57:33.869 --> 00:57:36.019
As you can see font panel.

00:57:36.019 --> 00:57:38.869
( Period of silence )

00:57:38.869 --> 00:57:49.469
Can configure itself depending on the user
selected layout and let me add accessory view.

00:57:49.469 --> 00:57:53.399
It's pretty simple.

00:57:53.400 --> 00:58:01.420
With this accessory view, I can open
a drawer with the document object.

00:58:01.420 --> 00:58:09.789
In this drawer there are a couple of switches
you can enable part of the font panels controls.

00:58:09.789 --> 00:58:16.199
I can disable size and effects.

00:58:16.199 --> 00:58:24.549
Note that each document implements validate
most for font panel and return its own setting.

00:58:24.550 --> 00:58:32.539
The font panel updates its user interface
according to the current document selected.

00:58:32.539 --> 00:58:39.019
Let's go back to the presentation please.

00:58:39.019 --> 00:58:39.969
( Period of silence )

00:58:39.969 --> 00:58:47.159
Now finally let me talk about the model object
in the font subsystem, NSFontDescriptor.

00:58:47.159 --> 00:58:55.029
NSFontDescriptor can be considered
part of the identity of NSFont instance.

00:58:55.030 --> 00:59:02.710
With NSFontDescriptor, you can
describe what the NSFont is.

00:59:02.710 --> 00:59:12.170
So by archiving NSFontDescriptor,
you can revive what the NSFont was.

00:59:12.170 --> 00:59:20.170
NSFontDescriptor is a very rich font query mechanism.

00:59:20.170 --> 00:59:30.980
Based on the accessory key where you pair pattern,
you can query font object inside the application.

00:59:30.980 --> 00:59:37.179
For example, in this example, I'm
specifying LucidaGrande as a family name.

00:59:37.179 --> 00:59:42.469
And bold as the typeface on the type
the font descriptor on the left.

00:59:42.469 --> 00:59:52.059
And the system returns correctly LucidaGrande
Bold typeface with next example,

00:59:52.059 --> 00:59:56.019
I'm specifying HelveticaNeue as a family name.

00:59:56.019 --> 01:00:01.610
And it returns all the typefaces
belonging to the font family.

01:00:01.610 --> 01:00:12.039
Finally, NSFontDescriptor can provide certain aspect
of information that doesn't require the graphic system.

01:00:12.039 --> 01:00:20.590
For example, it can return item defined names such as
Postscript names, family names or style characteristics

01:00:20.590 --> 01:00:27.240
of the typeface such as font traits or weights.

01:00:27.239 --> 01:00:33.750
Also NSFontDescriptor has certain
customizable advanced attributes.

01:00:33.750 --> 01:00:40.139
With these attributes, the NSFont can change the behavior.

01:00:40.139 --> 01:00:40.699
( Period of silence )

01:00:40.699 --> 01:00:48.909
Let's take a look one of the attributes
here, NSFontFixedAdvanceAttribute.

01:00:48.909 --> 01:00:55.619
It can specify the advancement used by
all the glyphs in a font instantiated

01:00:55.619 --> 01:00:59.279
from NSFontDescriptor that contains this attribute.

01:00:59.280 --> 01:01:07.170
This is how you create NSFont instances
that contains advanced attributes.

01:01:07.170 --> 01:01:13.250
Let's assume this font variable
contains a valid font reference.

01:01:13.250 --> 01:01:22.179
By sending font descriptor, you get back NSFontDescriptor
object that describes this NSFont.

01:01:22.179 --> 01:01:29.190
And I'm getting the advancement
for the widest glyph in the font.

01:01:29.190 --> 01:01:31.619
Box it into NSNumber.

01:01:31.619 --> 01:01:38.619
Now create a new dictionary using this body.

01:01:38.619 --> 01:01:45.799
Here I'm creating copy of the original font
descriptor by adding the new advanced attributes.

01:01:45.800 --> 01:01:52.280
Envelope, I have NSFont instances
that's through the fixed-pitch.

01:01:52.280 --> 01:01:54.170
Let's take a look in a demo.

01:01:54.170 --> 01:02:02.110
Okay, I have a document that says
this is a fixed-pitch font,

01:02:02.110 --> 01:02:11.400
but obviously this is Times Roman, it's not a fixed-pitch.

01:02:11.400 --> 01:02:23.780
By specifying this accessory view switch I'm switching, I'm
adding the NSFontFixedAdvancedAttribute to the font.

01:02:23.780 --> 01:02:31.800
And by adjusting the advancement
you have a fixed-pitch Times Roman.

01:02:31.800 --> 01:02:36.720
And you can specify for example for Futura or Arial.

01:02:36.719 --> 01:02:41.029
And this is the alive.

01:02:41.030 --> 01:02:46.490
Let's get back to the presentation please.

01:02:46.489 --> 01:02:48.649
( Period of silence )

01:02:48.650 --> 01:02:56.820
As you've seen, NSFonts of Cocoa font
subsystem provides enough customizability

01:02:56.820 --> 01:03:00.559
and extensibility for most of your application needs.

01:03:00.559 --> 01:03:07.150
So please stick to the standard Cocoa
user interface and use NSFont system.

01:03:07.150 --> 01:03:14.190
That way you can take advantage of all
enhancement we're going to do in the future.

01:03:14.190 --> 01:03:18.920
Let's get back and bring out Doug to wrap this presentation.

01:03:18.920 --> 01:03:25.329
( Applause )

01:03:25.329 --> 01:03:27.349
>> Let me just summarize.

01:03:28.469 --> 01:03:35.069
So the Cocoa text system has a lot of power, a lot of
depth and many different ways that you can customize it

01:03:35.070 --> 01:03:37.900
at many different levels for different uses.

01:03:37.900 --> 01:03:41.190
In particular, it uses the model
view controller organization

01:03:41.190 --> 01:03:44.679
to provide access point at both, at all of these levels.

01:03:44.679 --> 01:03:49.549
The model level, the control level and the view level.

01:03:49.550 --> 01:03:53.920
For more information, you can look
sample code up on the website.

01:03:53.920 --> 01:03:57.349
Our evangelist isn't here right now I don't believe.

01:03:57.349 --> 01:04:00.699
But you can contact him at this address.

01:04:00.699 --> 01:04:02.159
There are some labs coming up.

01:04:02.159 --> 01:04:07.149
There was a Cocoa lab today, but there's going to be
another one tomorrow and we're all going to be there.

01:04:07.150 --> 01:04:12.820
And for input methods, there is a lab on Friday
morning and if you're interested in Core Text,

01:04:12.820 --> 01:04:15.050
there's another session following this one actually.

01:04:15.050 --> 01:04:17.670
There's also a lab Friday afternoon.
WEBVTT

00:00:12.449 --> 00:00:16.000
>> I'm going to talk to you about Objective-C 2.0.

00:00:16.000 --> 00:00:23.660
Objective-C 2.0 is very heavy on programmer productivity.

00:00:23.660 --> 00:00:31.609
We have a new feature called Fast Enumeration, which
gives you much more efficient, better access to --

00:00:31.609 --> 00:00:38.439
to the elements of your collections with properties,
which give you a convenient way to declare,

00:00:38.439 --> 00:00:41.469
to access, use accessor methods and implement them.

00:00:41.469 --> 00:00:43.600
Saves you a lot of time.

00:00:43.600 --> 00:00:52.200
And garbage collection -- we have garbage
collection, which makes it a lot easier

00:00:52.200 --> 00:00:54.340
to manage the life times of your objects.

00:00:54.340 --> 00:00:59.960
So the first part of this talk I am going to be
talking about Objective-C 2.0 language sfeatures,

00:00:59.960 --> 00:01:04.090
the second half of the talk about be about a new runtime.

00:01:04.090 --> 00:01:08.260
And then go to Session 165 where Blaine
Garst is going

00:01:08.260 --> 00:01:11.219
to be talking about garbage collection in detail.

00:01:13.019 --> 00:01:16.280
So let's dive right into Fast Enumeration.

00:01:22.549 --> 00:01:31.679
Fast Enumeration gives you a much cleaner, faster, easier to
understand way to access the elements of your collections.

00:01:31.680 --> 00:01:40.370
In the past you would use an NS enumerator, and if you
use this new loop that we call informally the for...in loop.

00:01:40.370 --> 00:01:44.050
There are two forms of this loop.

00:01:44.049 --> 00:01:50.590
One allows you to introduce a variable
that's bound to the scope of the loop.

00:01:50.590 --> 00:01:56.450
The other let's you use a predeclared variable which
is great for searching the contents of a collection,

00:01:56.450 --> 00:01:59.980
and you can break out of the loop
when you find what you're looking for.

00:01:59.980 --> 00:02:04.630
And if you fall through and don't find
what you want, that variable will be nil.

00:02:04.629 --> 00:02:09.900
So you can tell, foundation collections
will never have nil in them.

00:02:09.900 --> 00:02:19.819
So why would you switch to this kind of a loop when NS
enumerator's been around a long time; it's served us well.

00:02:19.819 --> 00:02:22.989
One of the reason is it's wicked fast.

00:02:22.990 --> 00:02:33.750
It's so much faster to use with arrays because in essence
you're able to bypass encapsulation in a very safe way,

00:02:33.750 --> 00:02:39.229
and get direct access to the pointers
where the array elements are stored.

00:02:40.289 --> 00:02:47.780
This -- this graph here shows that for arrays,
Fast Enumeration is the fastest way to go.

00:02:47.780 --> 00:02:52.500
The blue line is your typical for...loop
with object at index.

00:02:52.500 --> 00:02:59.020
The green line is the NS enumerator, and the
vertical axis is basically average time per iteration

00:02:59.020 --> 00:03:00.860
of a very simple loop.

00:03:00.860 --> 00:03:02.560
So it comes in the fastest.

00:03:02.560 --> 00:03:07.270
So why wouldn't you use it.

00:03:07.270 --> 00:03:08.409
It's also safer.

00:03:08.409 --> 00:03:15.150
Fast Enumeration will detect if you happen to have some code
that's side effects the contents of a mutable collection.

00:03:15.150 --> 00:03:21.180
Part of the Fast Enumeration protocol
is code -- is part of the loop.

00:03:21.180 --> 00:03:24.870
Is code that's compiled in that checks every
time we've done an iteration of the loop.

00:03:24.870 --> 00:03:26.530
Has the collection changed.

00:03:26.530 --> 00:03:32.610
So that turns mysterious crashes into
exceptions that you can catch and identify.

00:03:32.610 --> 00:03:35.290
It's also very flexible.

00:03:35.289 --> 00:03:37.939
You can teach your own classes how to do Fast Enumeration.

00:03:37.939 --> 00:03:41.740
And I'm going to show you later an example of doing that.

00:03:43.250 --> 00:03:45.680
So how does it work.

00:03:45.680 --> 00:03:47.310
Here's a basic loop.

00:03:47.310 --> 00:03:49.870
Summing an NS array of numbers.

00:03:49.870 --> 00:03:55.189
It's just a function that returns such
an array and sums all the NS numbers up.

00:03:55.189 --> 00:03:56.829
So what does the compiler do for you.

00:03:56.830 --> 00:03:59.790
It looks pretty simple.

00:03:59.789 --> 00:04:04.030
Well, thank God you don't have to write this code.

00:04:04.030 --> 00:04:10.449
All the orange is inserted by the compiler, and
you can see the original code mixed in with it.

00:04:10.449 --> 00:04:14.109
So what the compiler does it creates a special
instruction on the stack that has the --

00:04:14.110 --> 00:04:17.090
keeps track of the enumeration state of the loop.

00:04:17.089 --> 00:04:22.250
It compiles in, checks to make sure the
object that you're trying to enumerate

00:04:22.250 --> 00:04:25.689
over implements the Fast Enumeration protocol.

00:04:25.689 --> 00:04:31.509
And I didn't show it, but it also has code for
each iteration of the loop to check the mutation.

00:04:31.509 --> 00:04:36.039
It's basically a counter or a word in memory that's cached.

00:04:36.040 --> 00:04:41.640
So what it does is it calls this
method count by enumerating state.

00:04:41.639 --> 00:04:45.979
And it gets the elements out of the
array in as few chunks as possible.

00:04:45.980 --> 00:04:49.650
Sometimes just one call to access all the elements.

00:04:49.649 --> 00:04:53.699
Then it fore-loops over those, and
accesses them directly by pointer.

00:04:53.699 --> 00:04:58.409
So it's really fast; it's great stuff.

00:04:58.410 --> 00:05:03.560
So here's an example of a class that you
might write that implements Fast Enumeration.

00:05:03.560 --> 00:05:07.280
This is a file reader hypothetical class.

00:05:07.279 --> 00:05:11.089
I've written code, tested that this works.

00:05:11.089 --> 00:05:16.549
You allocate one, you read a text file, and then
you treat it as if we have a collection of strings.

00:05:16.550 --> 00:05:18.500
And you could just use for...in on it.

00:05:18.500 --> 00:05:21.089
So what's makes it work?

00:05:21.089 --> 00:05:23.529
This single method.

00:05:23.529 --> 00:05:24.329
This is enough.

00:05:24.329 --> 00:05:27.579
All you need to make the for...in loop work.

00:05:27.579 --> 00:05:34.199
So when the loop is first called we detect first
call by checking the state, field of the structure.

00:05:34.199 --> 00:05:37.469
Do some required initialization.

00:05:37.470 --> 00:05:44.550
Then we actually read the next line out of the
file and if we get nil back we know we're done.

00:05:44.550 --> 00:05:51.370
So the return value of this method is the number
of elements available on the current iteration.

00:05:51.370 --> 00:05:52.470
So this is real simple.

00:05:52.470 --> 00:05:58.730
You could actually enhance this a little bit by having
it read ahead a few lines and return a check of it.

00:05:58.730 --> 00:06:02.250
But probably wouldn't matter in this particular case.

00:06:02.250 --> 00:06:03.670
So that's it.

00:06:03.670 --> 00:06:05.819
The Fast Enumeration protocol is really simple.

00:06:05.819 --> 00:06:12.879
It's fully documented in the Objective-C 2.0 programming
language document that you'll find in your documentation.

00:06:12.879 --> 00:06:16.850
And it's a lot of the repeats of
the word document right there.

00:06:16.850 --> 00:06:20.170
We go onto the next topic, which is protocols.

00:06:21.709 --> 00:06:31.500
So protocols are mostly used today in Cocoa to
model very simple, usually a couple methods --

00:06:31.500 --> 00:06:36.459
simple contracts between one part -- one class and another.

00:06:36.459 --> 00:06:41.639
But there are many cases in Cocoa where we need
to be able to say yes, we need a set of methods,

00:06:41.639 --> 00:06:44.319
but we only want a few of them to be required.

00:06:44.319 --> 00:06:49.050
So we've added that feature to
protocols from Objective-C 2.0.

00:06:49.050 --> 00:06:50.360
Call them optional methods.

00:06:50.360 --> 00:06:58.400
So a great example of this is if you're writing an NS table,
UI, you need to implement an NS table data source, which is,

00:06:58.399 --> 00:07:01.669
today, what we call an informal category.

00:07:01.670 --> 00:07:04.550
And we use informal category --
I'm sorry, informal protocols.

00:07:04.550 --> 00:07:10.400
And we use those, because those allow you
to specify a bag of methods and say, well,

00:07:10.399 --> 00:07:12.149
these are required and these are optional.

00:07:12.149 --> 00:07:15.479
But there's no compiler enforcement of that.

00:07:15.480 --> 00:07:17.960
We just see comments or documentation.

00:07:17.959 --> 00:07:27.250
So now we can recast the same thing as a protocol, and we
introduce two new keywords: At Required and At Optional.

00:07:27.250 --> 00:07:31.449
At Optional implemented; no problem.

00:07:31.449 --> 00:07:37.939
So these new key words, At Required is default.

00:07:37.939 --> 00:07:42.459
So if you haven't specified it, you
have a backward compatible protocol.

00:07:42.459 --> 00:07:45.620
All the methods in that protocol are required.

00:07:45.620 --> 00:07:49.889
And again, if we start using these
more for delegate type things,

00:07:49.889 --> 00:07:54.729
then the compiler can tell us if we
actually implemented it correctly.

00:07:54.730 --> 00:07:58.860
So protocols, you will probably start to
see more and more protocols with optional --

00:07:58.860 --> 00:08:02.420
I know there are at least two or
three classes in the AppKit today

00:08:02.420 --> 00:08:08.870
that are brand new delegate types
things that are using them.

00:08:08.870 --> 00:08:14.209
One other thing to say about -- and
here's the syntax, just for completeness.

00:08:15.370 --> 00:08:20.850
One other thing to say about protocols is
they are now completely opaque to the runtime.

00:08:20.850 --> 00:08:24.939
The fact that they were objects in
the past -- well, just forget that.

00:08:24.939 --> 00:08:28.680
We provide a set of cover APIs.

00:08:28.680 --> 00:08:36.259
32-bit mode, you can still call the methods on the
protocol method, and 64-bit you must use Protocol Get Name,

00:08:36.259 --> 00:08:38.899
for example, to get the name out of a protocol object.

00:08:38.899 --> 00:08:42.169
So it's just becoming -- it's a
general trend in our 64-bit runtime.

00:08:42.169 --> 00:08:44.649
Anything we can hide, we'll hide.

00:08:44.649 --> 00:08:46.850
More details on that later.

00:08:48.129 --> 00:08:51.120
Class extensions are a new feature.

00:08:51.120 --> 00:08:59.419
They are, again, to substitute in for what
categories have been used for what historically.

00:08:59.419 --> 00:09:05.639
One of the important uses of categories
is to create a private API to a class.

00:09:05.639 --> 00:09:12.279
Here's an example of a class that has a public
getter, but only -- but a private setter.

00:09:12.279 --> 00:09:14.639
And it's expressed as a category.

00:09:14.639 --> 00:09:18.159
But again, the compiler enforces this.

00:09:18.159 --> 00:09:23.169
If you've declared it, but you forget to
implement it, the compiler won't complain.

00:09:23.169 --> 00:09:26.990
You'll find out at runtime that the
thing you're trying to use is not there.

00:09:26.990 --> 00:09:29.960
So it's simple syntactic transformation.

00:09:29.960 --> 00:09:33.720
There it goes.

00:09:33.720 --> 00:09:35.210
Relieve the name.

00:09:35.210 --> 00:09:38.110
And now you have what we call a class extension.

00:09:38.110 --> 00:09:44.259
This changes the behavior of the compiler
so that this piece of interface is required

00:09:44.259 --> 00:09:46.210
to be implemented in the add implementation.

00:09:46.210 --> 00:09:48.210
So you can have as many of these as you like.

00:09:48.210 --> 00:09:51.120
So you can divide up your class into multiple pieces.

00:09:51.120 --> 00:09:56.310
So if you forget to implement the
set name method in this example,

00:09:56.309 --> 00:09:58.759
the compiler will warn and say, hey, what are you doing?

00:09:58.759 --> 00:10:05.580
So it treats that declaration as if we
were lexically part of the original class.

00:10:07.230 --> 00:10:08.769
So there's the syntax.

00:10:08.769 --> 00:10:12.980
You can put in methods or property declarations.

00:10:18.110 --> 00:10:20.240
Which leads me to properties.

00:10:20.240 --> 00:10:27.419
So properties I think are our biggest future in
the direction of improved programmer productivity.

00:10:27.419 --> 00:10:36.049
They provide a way for you to declare, to
use, and to implement accessor methods.

00:10:36.049 --> 00:10:36.719
That's what they are.

00:10:36.720 --> 00:10:40.570
They're basically all about accessor methods.

00:10:40.570 --> 00:10:44.440
And one of the greatest innovations of
properties, we discussed this last year,

00:10:44.440 --> 00:10:47.020
automatically generated accessor methods.

00:10:47.019 --> 00:10:56.389
But everything I told you last year; forget it.

00:10:56.389 --> 00:10:58.960
We changed nearly everything about Properties.

00:10:58.960 --> 00:11:02.600
The only thing that's the same
is, well, yeah, you can dot them.

00:11:02.600 --> 00:11:10.779
One of the perhaps most interesting changes
we've made is that anything that looks

00:11:10.779 --> 00:11:14.629
like an accessor method you can use the dot operator on.

00:11:14.629 --> 00:11:18.320
So even if we haven't gotten around
to creating property declarations

00:11:18.320 --> 00:11:22.870
for common accessor methods, you can use them as if we did.

00:11:22.870 --> 00:11:24.560
So more details on that later.

00:11:24.559 --> 00:11:30.339
We have some new keywords for synthesizing accessor methods.

00:11:30.340 --> 00:11:35.050
We've redesigned attributes, we've made
them more regular; easier to understand.

00:11:35.049 --> 00:11:37.000
You'll tell me, of course, if that's true.

00:11:37.000 --> 00:11:42.740
And synthesized instance variables now
are only part of the 64-bit runtime.

00:11:43.750 --> 00:11:47.539
So how do you use a property?

00:11:47.539 --> 00:11:53.849
Well, you can walk up to an object and if it has an
accessor method you can use the dot operator to access it.

00:11:53.850 --> 00:11:56.470
So, okay, it's one character fewer to type.

00:11:56.470 --> 00:11:59.490
Well, those characters add up if
you have deeply nested expressions.

00:11:59.490 --> 00:12:02.570
So that's pretty nice.

00:12:02.570 --> 00:12:06.690
This feature is as I said independent
of the rest of the talk.

00:12:06.690 --> 00:12:12.590
So if you only learn this, you can start using the
dot operator to start accessing your properties.

00:12:12.590 --> 00:12:16.160
It works with any name, set name pattern by default.

00:12:16.159 --> 00:12:17.379
That's the stock behavior.

00:12:17.379 --> 00:12:19.279
But you can customize that.

00:12:19.279 --> 00:12:22.269
The only constraint is that X has to be a known type.

00:12:22.269 --> 00:12:23.679
It can't be an I.D..

00:12:23.679 --> 00:12:30.859
And if it is a class type, it can't
just be forward declared.

00:12:30.860 --> 00:12:34.019
So we declare properties with a simple syntax.

00:12:34.019 --> 00:12:37.889
We use the At Property keyword,
an optional list of attributes.

00:12:37.889 --> 00:12:42.409
If there are no attributes specified you can
actually declare them without any attributes.

00:12:42.409 --> 00:12:43.789
You don't need the parenthesis.

00:12:43.789 --> 00:12:46.099
Type and a list of names.

00:12:46.100 --> 00:12:53.070
And that's equivalent to declaring by
default, the pair, the name and set name pair.

00:12:53.070 --> 00:12:55.900
You can use them anywhere you would use methods today.

00:12:55.899 --> 00:12:59.899
Classes protocols, categories and class extensions.

00:12:59.899 --> 00:13:02.539
And I'm going talk to you more about these attributes.

00:13:02.539 --> 00:13:06.899
Because they've provide sort of this enhanced capability.

00:13:06.899 --> 00:13:15.279
The ability to have your properties described to both
your clients and to the compiler how they should work.

00:13:15.279 --> 00:13:16.399
How they should implement.

00:13:16.399 --> 00:13:23.120
They go a long way toward supporting
existing practice in Cocoa.

00:13:23.120 --> 00:13:31.090
So there are four broad categories of attributes.

00:13:31.090 --> 00:13:33.290
One is for controlling mutability.

00:13:33.289 --> 00:13:37.149
You can say, yeah, this property
is read write, or read only.

00:13:37.149 --> 00:13:42.079
There is ownership to talk about, when
object values are stored in properties.

00:13:42.080 --> 00:13:44.280
How they are managed.

00:13:44.279 --> 00:13:49.230
And there's amnesty, which has to do be
correctness under multithreaded programming.

00:13:49.230 --> 00:13:56.570
Finally, there's a way to teach the compiler the naming
convention you want to use for your accessor methods.

00:13:58.710 --> 00:14:02.519
So mutability is all about read only or read write.

00:14:02.519 --> 00:14:06.439
We don't have read -- write only.

00:14:06.440 --> 00:14:09.080
Somebody asked about that the other day.

00:14:10.450 --> 00:14:15.550
Classes -- sub classes -- base classes are
allowed to say this is property is read only.

00:14:15.549 --> 00:14:19.479
But a sub class can come along and change that.

00:14:19.480 --> 00:14:28.090
And this models the typical immutable base class,
immutable sub class that you find all over foundation.

00:14:28.090 --> 00:14:33.850
So here's an example, the old way, the
current way NS data says, yeah, I'm immutable.

00:14:33.850 --> 00:14:36.029
There is nothing you can do to touch me.

00:14:36.029 --> 00:14:39.459
You can't touch the length of my data.

00:14:39.460 --> 00:14:43.000
But mutable data comes along and says, sure you can.

00:14:43.000 --> 00:14:46.289
You can change the length.

00:14:46.289 --> 00:14:55.240
With properties, we would change it to this; which to my
mind is a little clearer, because you're saying, yeah,

00:14:55.240 --> 00:15:01.960
the base class can only read --
the sub class can read and write.

00:15:01.960 --> 00:15:05.850
Another thing you can do with this though
doesn't require inheritance at all.

00:15:05.850 --> 00:15:07.830
You can use it in a class extension.

00:15:07.830 --> 00:15:13.800
So if you would like to have a class which is publicly read
only, as a publicly read only property, you can turn around

00:15:13.799 --> 00:15:18.019
and make it read write in a class extension.

00:15:18.019 --> 00:15:22.929
Which then allows you change it
internally, or some other class you trust.

00:15:22.929 --> 00:15:28.909
The next set of attributes have to do with ownership.

00:15:28.909 --> 00:15:30.089
The object ownership.

00:15:30.090 --> 00:15:33.590
The very first one, assign, is the default.

00:15:33.590 --> 00:15:36.750
And it models two things.

00:15:36.750 --> 00:15:45.210
This is where we first want to talk about garbage
collection versus retained code, or retained counted code.

00:15:45.210 --> 00:15:48.180
When you use the Assign Property
attribute -- property attribute --

00:15:48.179 --> 00:15:53.059
by default that means you simply get an
assignment in reference counting code.

00:15:53.059 --> 00:15:54.459
It's an unretained pointer.

00:15:54.460 --> 00:15:58.900
Which means it could be a dangling
pointer under reference counting code.

00:15:58.899 --> 00:16:02.990
Under gc, though, a simple assignment is
sufficient to create an owning reference.

00:16:02.990 --> 00:16:06.480
So that there is a difference in the semantics.

00:16:06.480 --> 00:16:12.779
If you're going to write gc-only code, this would
probably be what you want to use most of the time.

00:16:12.779 --> 00:16:17.669
The next attribute is what you want to
use if you need code that is compatible

00:16:17.669 --> 00:16:20.669
across garbage-collected or retained counted code.

00:16:20.669 --> 00:16:24.019
If you're going to create a framework
that needs to run in both.

00:16:24.019 --> 00:16:31.639
Retain means use retain to manage the lifetime as a side
effect of assignment, retain the object, release the old.

00:16:31.639 --> 00:16:41.269
And your getters will call retain auto release to give you
a little bit more safety with respect to auto release pools.

00:16:41.269 --> 00:16:47.620
Retain also, though, has the same meaning as Assign
under garbage collection code -- collected code.

00:16:47.620 --> 00:16:54.840
Copy is just the same as retain, but it says as a side
effect also use the NS copying protocol, copy the object.

00:16:54.840 --> 00:16:58.310
Now these are contracts; these are specifications.

00:16:58.309 --> 00:17:01.729
If someone reads your property declarations
they'll know that's what you're doing.

00:17:01.730 --> 00:17:03.769
It's a standard behavior.

00:17:03.769 --> 00:17:10.599
But if you write the accessor methods it's
your job to adhere to these contracts.

00:17:10.599 --> 00:17:18.309
Which brings up the whole rationale for
wanting to use synthesized accessors,

00:17:18.309 --> 00:17:23.379
because you don't have to do the work then.

00:17:24.890 --> 00:17:33.340
Now for multithreaded programming, we may decide to
make it a possibly that all accessors should be atomic.

00:17:33.339 --> 00:17:37.470
So if you use any of our built in accessor methods with any

00:17:37.470 --> 00:17:44.630
of these previously mentioned attributes
you're guaranteed to get atomic updates.

00:17:44.630 --> 00:17:49.520
For the simple scaler values, you know,
the compiler machine arranges that for you.

00:17:49.519 --> 00:17:58.490
But for retain and copy and structure that's you might
have written into yours, you have to take pains to do that.

00:17:58.490 --> 00:18:04.740
The whole cycle of retaining and releases
the old and retain auto releasing means

00:18:04.740 --> 00:18:07.309
that the code has to run in a critical section.

00:18:07.309 --> 00:18:12.789
So if you use our -- as I said, if you use our
synthesized accessors, you get that for free.

00:18:12.789 --> 00:18:16.659
But there are going to be some times
when you need to escape from that.

00:18:16.660 --> 00:18:21.070
Because you're paying that cost
every time you access a property.

00:18:21.069 --> 00:18:26.549
And if you're going have something that requires sort of
a complicit locking anyway, because you're, let's say,

00:18:26.549 --> 00:18:31.109
in the update to property values, and
then that has to happen automatically.

00:18:31.109 --> 00:18:38.329
Then you can actually optimize your accessors and
advertise that you do so to a potential client.

00:18:38.329 --> 00:18:40.500
Hey, you need to lock me before you use this property.

00:18:40.500 --> 00:18:44.369
You can do that with a nonatomic attribute.

00:18:44.369 --> 00:18:51.699
We don't have an atomic attribute that's implicit.

00:18:51.700 --> 00:18:56.809
Finally, the final set of attributes are
called the accessor naming attributes.

00:18:56.809 --> 00:19:01.309
And they are used to be able to cause
your properties to be able to adhere

00:19:01.309 --> 00:19:04.909
to a pre-existing naming convention that you might have.

00:19:04.910 --> 00:19:10.759
I show here one where you might have a class
that has an invisible -- visibility control.

00:19:10.759 --> 00:19:16.670
And it has its accessor, a typical boolean
accessor using the prefix is -- so is visible.

00:19:16.670 --> 00:19:18.110
So I just made one up here.

00:19:18.109 --> 00:19:20.359
Imagine you have a setter called make visible.

00:19:20.359 --> 00:19:21.619
Well, you can -- you can model that.

00:19:21.619 --> 00:19:26.029
You can do that with properties so that
if you simply say object dot visible,

00:19:26.029 --> 00:19:30.329
you're either reading or writing calling these accessors.

00:19:30.329 --> 00:19:36.359
This is different, again, from what we presented last
year, which this was really an aliasing mechanism.

00:19:36.359 --> 00:19:38.759
Now it is a straight directive to the compiler.

00:19:38.759 --> 00:19:45.329
Use these selectors when you use your properties.

00:19:45.329 --> 00:19:48.539
The main constraint is that these
methods have to obey the correct types.

00:19:48.539 --> 00:19:53.129
The correct return type, the correct argument type.

00:19:53.130 --> 00:19:58.100
So here's the summary of tables
showing them in the grouping.

00:19:58.099 --> 00:20:08.369
And this leads me to the next part of the talk where
I want to now tell you about implementing properties.

00:20:09.569 --> 00:20:14.309
So as I have implied up to now you
can write your accessors by hand.

00:20:14.309 --> 00:20:16.599
If you have a whole bunch of code
that you have already written,

00:20:16.599 --> 00:20:19.740
you can actually use convert to Objective-C 2.0 in Xcode.

00:20:19.740 --> 00:20:24.829
There's a refactoring tool that will take all of
your existing property accessor getter setter pairs

00:20:24.829 --> 00:20:28.089
and rewrite them as properties, if you like.

00:20:28.089 --> 00:20:35.179
But if you're going to write new stuff,
might give the compiler a shot at it.

00:20:35.180 --> 00:20:41.990
And then there's some extra runtime magic that
I want to tell you about that might get you --

00:20:41.990 --> 00:20:46.779
help you get yourself out of a
corner you painted yourself into.

00:20:46.779 --> 00:20:54.289
So to synthesize an accessor we have
provided the At Synthesize keyword.

00:20:54.289 --> 00:21:02.460
And this is included in the implementation
section of your class.

00:21:02.460 --> 00:21:06.920
Rather than specifying something in
the interface, which we did last year,

00:21:06.920 --> 00:21:14.220
we decided this is information that's not terrible
interesting to the clients of your -- of your classes.

00:21:14.220 --> 00:21:16.779
It's sort of an implementation detail.

00:21:16.779 --> 00:21:20.599
So this appears in inside the add implementation block.

00:21:20.599 --> 00:21:25.740
And the -- as I mentioned earlier,
all the other attributes are used

00:21:25.740 --> 00:21:28.640
to guide the compiler when it implements these things.

00:21:28.640 --> 00:21:32.320
So if you specify copy, it's going
to call copy on the value.

00:21:32.319 --> 00:21:35.169
If you specify retain, it's going to call retain.

00:21:35.170 --> 00:21:42.640
So here's an example of using Add Synthesize with a car
object, two instance variables, position and velocity.

00:21:42.640 --> 00:21:44.420
And we want to have two properties.

00:21:44.420 --> 00:21:46.950
One named position and one named speed.

00:21:46.950 --> 00:21:49.110
So this shows off what you can do.

00:21:49.109 --> 00:21:52.599
Just like getter equals and setter
equals, you can change the accessor.

00:21:52.599 --> 00:21:59.109
Here you can change the ivar (assumed
spelling) that the synthesize accessor uses.

00:21:59.109 --> 00:22:07.639
So here's a complete example for 32-bit code.

00:22:07.640 --> 00:22:17.680
This creates a fully functioning class that
will respond to these messages, and you're done.

00:22:17.680 --> 00:22:22.080
Well, there's things to think about like memory
management and inits and deallocs (Phonetic).

00:22:22.079 --> 00:22:29.259
But -- the 64-bit, though, you're even -- done earlier.

00:22:29.259 --> 00:22:32.140
Because you can remove those two instance variables.

00:22:32.140 --> 00:22:39.500
So it's -- an added convenience that in 64-bit code
the compiler will actually add the instance variables

00:22:39.500 --> 00:22:42.150
to your class for you.

00:22:42.150 --> 00:22:46.700
The thing I didn't mention is when
At Synthesize sees a name,

00:22:46.700 --> 00:22:50.220
it assumes there's an instance
variable that matches that name.

00:22:50.220 --> 00:22:56.170
That's why we have this -- this extra syntax,
to be able to remap the instance variable.

00:22:56.170 --> 00:22:58.029
But it's implicit in 64-bit mode.

00:22:58.029 --> 00:23:02.299
If the ivar isn't there, it will add it.

00:23:02.299 --> 00:23:06.990
That works because in 64-bit mode we
have non fragile instance variables.

00:23:06.990 --> 00:23:17.099
The next thing that we can do -- this is what I
alluded to earlier -- is a little bit of runtime magic.

00:23:17.099 --> 00:23:22.429
We have this other keyword that says, you
know that property that I just declared.

00:23:22.430 --> 00:23:25.240
Well, forget that declared it.

00:23:25.240 --> 00:23:26.259
I am not going to implement it.

00:23:26.259 --> 00:23:27.490
And don't bother me about it.

00:23:27.490 --> 00:23:29.319
I know what I'm doing.

00:23:29.319 --> 00:23:33.099
So this class shows a property -- a boolean property --

00:23:33.099 --> 00:23:42.459
and it tells the compiler, this probably will
just come, be implemented, as if by magic.

00:23:42.460 --> 00:23:45.819
So an example of using this is Core Data.

00:23:45.819 --> 00:23:54.529
Core Data today in the seed you have allows you
to declare sub classes of NS Managed Object,

00:23:54.529 --> 00:23:59.599
and today or in the past you would
declare old school accessor methods.

00:23:59.599 --> 00:24:04.289
And you would write boiler plate code
which basically goes three methods

00:24:04.289 --> 00:24:06.909
and the only thing you ever change is the name of the key.

00:24:06.910 --> 00:24:09.009
So it's not doing very much for you.

00:24:09.009 --> 00:24:12.440
Wouldn't it be nice if you don't have to write that code.

00:24:12.440 --> 00:24:18.090
The next way, the better way would be to use
a property and to say, hey, it's dynamic.

00:24:18.089 --> 00:24:20.649
Don't bother me.

00:24:20.650 --> 00:24:27.460
Core Data already knows how to turn properties
that are specified just by name into accessors

00:24:27.460 --> 00:24:32.100
into the NS Managed Objects object store.

00:24:32.099 --> 00:24:35.299
So wouldn't it be a great idea if it could do that.

00:24:35.299 --> 00:24:38.049
If it could provide the accessor methods for you.

00:24:38.049 --> 00:24:39.539
Well, it does.

00:24:39.539 --> 00:24:44.759
It does that through a mechanism that
we call dynamic method resolution.

00:24:44.759 --> 00:24:49.339
And this is a new runtime feature
that is invoked very early on.

00:24:49.339 --> 00:24:52.609
If the runtime discovers that you're
trying to call a method that isn't defined

00:24:52.609 --> 00:24:59.750
in your class it will consult your classes plus method,
resolve instance method, or resolve class method,

00:24:59.750 --> 00:25:02.980
and ask it, hey, do you got anything for me?

00:25:02.980 --> 00:25:06.579
If it does, if you do, you add it to the class.

00:25:06.579 --> 00:25:09.649
You can do lazy binding this way.

00:25:09.650 --> 00:25:11.100
And return yes.

00:25:11.099 --> 00:25:17.139
If you don't, you defer to your superclass
and hopefully it knows something you don't.

00:25:18.690 --> 00:25:25.470
So this will happen as I said on the first call, where
a method hasn't been -- is discovered not to be defined.

00:25:25.470 --> 00:25:30.039
If you don't provide something then
the old way of handling it with occur.

00:25:30.039 --> 00:25:33.589
Either you'll get an exception raise
because the method doesn't exist,

00:25:33.589 --> 00:25:40.009
or programs you will have a forwarding call
go -- happen -- that does something else.

00:25:40.009 --> 00:25:42.319
Like a proxy.

00:25:42.319 --> 00:25:44.889
This can be leverage for lots of interesting things.

00:25:44.890 --> 00:25:48.310
Bridging to other programming languages.

00:25:48.309 --> 00:25:52.069
Perhaps some lazy initialization of your class.

00:25:52.069 --> 00:25:58.279
And it's fully documented, again, in
the Objective-C 2.0 programming guide.

00:25:59.400 --> 00:26:01.250
And that's it.

00:26:01.250 --> 00:26:05.420
Greg Parker's going to take over now, and thanks a lot.

00:26:07.509 --> 00:26:11.150
( Applause )

00:26:11.150 --> 00:26:11.990
>> Thank you, Patrick.

00:26:11.990 --> 00:26:13.640
I am Greg Parker.

00:26:13.640 --> 00:26:19.340
I am the runtime wrangler, which means I write
code in the low-level Objective-C 2.0 runtime,

00:26:19.339 --> 00:26:24.470
which is the underpinnings for the entire
Objective-C 2.0 and Cocoa language system.

00:26:24.470 --> 00:26:27.400
I could talk about some new features we have in the runtime.

00:26:27.400 --> 00:26:30.170
These are all new in Leopard.

00:26:30.170 --> 00:26:35.080
Some of the features we've added are
some syntax for method class attributes.

00:26:35.079 --> 00:26:36.730
I'll show you some examples.

00:26:36.730 --> 00:26:42.610
We have an enhanced low-level C API, for those
of you doing low-level runtime manipulations.

00:26:42.609 --> 00:26:47.169
We have several new Objective-C features in 64-bit only.

00:26:47.170 --> 00:26:54.500
I'm going talk about the 64-bit API, which is
the representation of your program's meta data.

00:26:54.500 --> 00:26:56.259
And then three new features.

00:26:56.259 --> 00:27:02.579
Instance variable and class access role
for those of you writing frameworks.

00:27:02.579 --> 00:27:09.240
Non fragile instance variables, which are also
interesting for those of you writing frameworks and others.

00:27:09.240 --> 00:27:13.569
And finally, 64-bit zero cost C++
compatible exceptions.

00:27:13.569 --> 00:27:16.439
For those of you who know what
that means, you'll really like it.

00:27:16.440 --> 00:27:20.230
This is multi for C++ developers.

00:27:20.230 --> 00:27:24.710
So let's jump into the method in
class attributes to start with.

00:27:24.710 --> 00:27:32.309
So attributes are a GCC syntax for specifying
additional things about a method, about a function.

00:27:32.309 --> 00:27:39.470
We've added the ability to add them to Objective-C 2.0
construct, including classes, methods, and properties.

00:27:39.470 --> 00:27:45.509
So some examples of what they've useful for, you
can add an attribute for deprecating a method,

00:27:45.509 --> 00:27:49.240
or specifying which OS versions a method works in.

00:27:49.240 --> 00:27:53.870
You'll see this all over the foundation and AppKit.

00:27:53.869 --> 00:28:00.459
You can add a -- an attribute that specifies whether
the parameter list method must have a nil terminator.

00:28:00.460 --> 00:28:06.670
So the big example of this is the array with objects
method, where you specify a list of objects and then a nil.

00:28:06.670 --> 00:28:08.779
If you leave out the nil the computer crashes.

00:28:08.779 --> 00:28:12.200
If you add the attribute the compiler will warn you first.

00:28:12.200 --> 00:28:17.450
Finally, we have a parameter -- an attribute
which is actually not quite implemented yet.

00:28:17.450 --> 00:28:20.600
For specified parameters in a method that are unused.

00:28:20.599 --> 00:28:24.149
So let me show you the examples of these.

00:28:24.150 --> 00:28:28.660
The first one we have are availability
and deprecation attributes.

00:28:28.660 --> 00:28:35.740
The first one here is a class that
is deprecated in Mac OS X, 10.5.

00:28:35.740 --> 00:28:41.049
So if you try to use this class the compiler will
warn you that you're using a deprecated class.

00:28:41.049 --> 00:28:45.069
We have the same deprecation warning
for the deprecated method,

00:28:45.069 --> 00:28:51.059
and a similar macro for a property
which has been introduced in 10.5.

00:28:51.059 --> 00:28:54.730
If you set your deployment target
to 10.4, you get a compiler warning.

00:28:54.730 --> 00:29:00.880
Next example is the nil termination attribute.

00:29:00.880 --> 00:29:05.060
There are other attributes that you can use for
different sorts of termination and method lists.

00:29:05.059 --> 00:29:07.950
But this is the one you will actually see most often.

00:29:07.950 --> 00:29:10.140
So this is a foundation macro.

00:29:10.140 --> 00:29:17.130
The array with objects method takes a variable number
of arguments, and the last one has to be a nil.

00:29:17.130 --> 00:29:25.610
And that's what the -- requires nil termination -- macro
tells the compiler to warn you if you left off the nil.

00:29:25.609 --> 00:29:29.589
Finally, the unused parameter attribute.

00:29:29.589 --> 00:29:34.649
This one only works in GCC 4.2, which
is, you know, not quite out yet.

00:29:34.650 --> 00:29:36.170
But you will see this in the future.

00:29:36.170 --> 00:29:38.880
It will be available to you.

00:29:38.880 --> 00:29:47.720
The example here is an IB action, which very commonly
the sender parameter you see isn't actually used anywhere

00:29:47.720 --> 00:29:48.839
in the method.

00:29:48.839 --> 00:29:54.149
If you turn on GCC warnings it will warn you,
you have this parameter; you didn't use it.

00:29:54.150 --> 00:29:59.180
The unused attribute tells the compiler
I have this parameter, it's unused,

00:29:59.180 --> 00:30:06.269
and I know it's unused, so you don't have to warn about it.

00:30:06.269 --> 00:30:10.369
Next feature I am going to talk
about is the low-level API changes.

00:30:10.369 --> 00:30:15.609
Probably, only 10 percent of your or fewer care about this.

00:30:15.609 --> 00:30:19.899
But those of you who do, it will
be pretty important in Leopard.

00:30:19.900 --> 00:30:21.019
API additions.

00:30:21.019 --> 00:30:26.460
We've added new features to the C level API, to the runtime.

00:30:26.460 --> 00:30:31.650
The primary edition is function-based
replacements for all the meta data structures.

00:30:31.650 --> 00:30:36.390
This includes the struct OBJC class,
struct OBJC method, et cetera.

00:30:36.390 --> 00:30:39.920
If you wanted to read those structures
we have functions to access it.

00:30:39.920 --> 00:30:44.110
If you want to modify those structures
we have functions to manipulate them.

00:30:44.109 --> 00:30:50.519
As Patrick mentions, protocols
are not really objects any more.

00:30:50.519 --> 00:30:55.369
And particularly in the 64-bit runtime
they do not respond to any messages.

00:30:55.369 --> 00:31:01.839
So to replace the name method, description for
instance method, we've added some C level API

00:31:01.839 --> 00:31:05.849
to manipulate protocols due to access protocols.

00:31:05.849 --> 00:31:11.069
One additional advantage of the C level API is
it provides features that we didn't have before.

00:31:11.069 --> 00:31:15.299
The ability is to look up a protocol by name.

00:31:15.299 --> 00:31:19.559
You can say give me a protocol for
the NS copying protocol at runtime,

00:31:19.559 --> 00:31:25.859
instead of using the app protocol syntax,
which is appropriate for some code.

00:31:25.859 --> 00:31:30.689
Another addition we have for those of you
who are constructing classes at runtime,

00:31:30.690 --> 00:31:34.440
we have a new set of functions to
make that much easier; much simpler.

00:31:34.440 --> 00:31:38.309
And much less likely to crash if
you get something slightly wrong.

00:31:38.309 --> 00:31:46.389
For creating classes, adding methods to those classes,
adding instance variables to those classes at runtime.

00:31:46.390 --> 00:31:49.460
Finally, for those of you who actually
look at all this stuff,

00:31:49.460 --> 00:31:54.120
all the header files have been rearranged in user include.

00:31:54.119 --> 00:31:56.349
So be aware of that.

00:31:56.349 --> 00:31:57.119
It's pretty simple.

00:31:57.119 --> 00:32:00.099
Pretty straight forward.

00:32:00.099 --> 00:32:01.730
API subtractions.

00:32:01.730 --> 00:32:02.779
Not everything is free.

00:32:02.779 --> 00:32:04.349
There are some costs.

00:32:04.349 --> 00:32:09.269
We have removed some things or deprecated
some things that the runtime API.

00:32:09.269 --> 00:32:18.160
The first thing I mentioned about these changes are they're
deprecated in 32-bit and they're simply gone in 64-bit.

00:32:18.160 --> 00:32:21.060
If they aren't gone in your seed
they will be gone in October.

00:32:21.059 --> 00:32:26.019
So be sure to fix those deprecation warnings in 64-bit mode.

00:32:26.019 --> 00:32:27.920
So what are the subtractions.

00:32:27.920 --> 00:32:33.650
The primary one going back to the first slide,
all the meta data structures are deprecated.

00:32:33.650 --> 00:32:35.269
OBJC Class; gone.

00:32:35.269 --> 00:32:36.230
OBJC Method.

00:32:36.230 --> 00:32:38.640
Gone. Well, gone in 64-bit.

00:32:38.640 --> 00:32:41.920
They're still there in 32-bit if you want to use them.

00:32:41.920 --> 00:32:46.550
Use the function-based replacements to manipulate
the things you would have manipulated anyway.

00:32:46.549 --> 00:32:52.399
In general, there are things -- there are functions to
manipulate anything that you would have changed previously.

00:32:52.400 --> 00:32:56.690
If there's not a function to change it, it probably
means that you can't change it in the new runtime anyway.

00:32:56.690 --> 00:32:59.779
We don't want you to do that.

00:32:59.779 --> 00:33:07.769
One particular note about these changes, if you
have any variables of type structure, object class.

00:33:07.769 --> 00:33:13.450
That type is deprecated, you should use the
class type instead, which is not deprecated.

00:33:13.450 --> 00:33:16.600
Doesn't have any variables in it, but that's okay.

00:33:16.599 --> 00:33:20.689
For non deprecated use the class type is what you want.

00:33:20.690 --> 00:33:26.259
As Patrick mentioned all the methods
on class protocol are deprecated.

00:33:26.259 --> 00:33:31.440
Use the function-based replacements for them
if you are manipulating protocols that way.

00:33:31.440 --> 00:33:34.789
For most of you the only thing
you're doing is a line like this.

00:33:34.789 --> 00:33:38.680
Class conforms to protocol at protocol.

00:33:38.680 --> 00:33:40.810
This still works, nothing deprecated.

00:33:40.809 --> 00:33:42.339
Nothing evil about this.

00:33:42.339 --> 00:33:43.609
It will all work fine.

00:33:43.609 --> 00:33:49.039
If you're doing something for sophisticated with
protocols you will probably need to change your code.

00:33:50.589 --> 00:33:56.480
Finally, there are some other random functions in the old
API that have been deprecated or removed in the new one.

00:33:56.480 --> 00:34:00.500
A couple of examples here for manipulating method lists.

00:34:00.500 --> 00:34:03.920
The big example for a lot of you is class posing.

00:34:03.920 --> 00:34:08.610
Class posing is now completely absent in the 64-bit runtime.

00:34:08.610 --> 00:34:12.140
You cannot pose as another class.

00:34:12.139 --> 00:34:17.079
For most things you want to do with class posing,
you can use method list manipulations to do it.

00:34:17.079 --> 00:34:23.319
You can add a method to a class, you could change
the method implementation of a class's method.

00:34:23.320 --> 00:34:25.070
The code might be a little bit uglier.

00:34:25.070 --> 00:34:29.260
But face it, you're pretty much going
behind the scenes hacking anyway.

00:34:29.260 --> 00:34:34.940
So we consider it acceptable that you have
to do a bit more work to do your hacking.

00:34:34.940 --> 00:34:42.200
Next feature I'm going to talk
about is a 64-bit runtime ABI.

00:34:42.199 --> 00:34:46.769
The ABI is the Application Binary Interface.

00:34:46.769 --> 00:34:49.300
Which is how the meta data is structured.

00:34:49.300 --> 00:34:50.890
What does a class structure look like.

00:34:50.889 --> 00:34:54.969
What does a message sent look like
when the compiler writes it.

00:34:54.969 --> 00:35:02.129
64-bit, we have a brand new ABI taking advantage
of the fact that we're breaking capability anyway,

00:35:02.130 --> 00:35:05.920
because there isn't any 64-bit code to be compatible with.

00:35:05.920 --> 00:35:08.490
A new meta data format on disc.

00:35:08.489 --> 00:35:13.179
The big design feature here is
some performance enhancements.

00:35:13.179 --> 00:35:15.529
But also much better future expandability.

00:35:15.530 --> 00:35:21.780
When we want to change the ABI, we will have the flexibility
to do that without breaking any existing programs.

00:35:21.780 --> 00:35:26.340
For those of you looking very carefully
at the ABI data you'll notice first

00:35:26.340 --> 00:35:29.730
of all that there is no OBJC segment any more.

00:35:29.730 --> 00:35:32.000
All the meta data is in a new format.

00:35:32.000 --> 00:35:35.239
It's in different places now.

00:35:35.239 --> 00:35:37.699
Results and new meta data format in memory.

00:35:37.699 --> 00:35:39.909
In particular, the class structure is different.

00:35:39.909 --> 00:35:41.690
The method structure is different.

00:35:41.690 --> 00:35:45.639
Which is pretty much why we've
deprecated all those structures for you.

00:35:49.469 --> 00:35:54.359
And that's actually all I'm going say about the 64-bit ABI.
d

00:35:54.360 --> 00:35:56.559
All the rest of the details are private.

00:35:56.559 --> 00:35:57.869
They are subject to change.

00:35:57.869 --> 00:35:59.679
They will change in the future.

00:35:59.679 --> 00:36:03.219
Thus, the future expandability part I noted about.

00:36:03.219 --> 00:36:09.639
For those of you who are writing any sort of tools,
introspection tools, compiler tools, that sort of thing,

00:36:09.639 --> 00:36:12.960
we will be providing documentation about the API.

00:36:12.960 --> 00:36:17.949
But it's only going to be valid for Leopard, perhaps.

00:36:17.949 --> 00:36:23.909
We may have changed it by the time we get
around to whatever the next major OS is.

00:36:23.909 --> 00:36:29.009
One note about -- final not about it is
the Objective-C runtime is open source.

00:36:29.010 --> 00:36:31.630
But open source does not mean documented.

00:36:31.630 --> 00:36:34.420
Open source does not mean forward compatible.

00:36:34.420 --> 00:36:38.519
Feel free to learn whatever you like by reading the source,

00:36:38.519 --> 00:36:43.420
by looking at the data structures the open
source compiler and open source runtime use.

00:36:43.420 --> 00:36:47.769
But don't write code that depends on it if you
want that code to run in future OS versions.

00:36:47.769 --> 00:36:57.139
Finally, I am going to talk about three 64-bit only
features that we've added to the runtime of the compiler.

00:36:57.139 --> 00:36:59.379
These features are all taking advantage of the fact

00:36:59.380 --> 00:37:04.550
that we can change the binary compatibility
layout, we can add new features to the language.

00:37:04.550 --> 00:37:10.110
At this point in 64-bit where we
couldn't add them in 32-bit.

00:37:10.110 --> 00:37:14.860
First of all, I am going to talk about
instance variable and class action control.

00:37:14.860 --> 00:37:20.019
This is going be primarily interesting for those of
you writing frameworks that are providing classes

00:37:20.019 --> 00:37:24.269
or providing instance variables to clients.

00:37:24.269 --> 00:37:30.960
So one feature of the 64-bit runtime is
private instance variables, the hidden classes.

00:37:30.960 --> 00:37:32.179
First of all hidden classes are new.

00:37:32.179 --> 00:37:33.500
I'll tell you about them in a minute.

00:37:33.500 --> 00:37:40.900
But private instance variables and hidden classes are more
strongly enforced if you're trying to access them outside

00:37:40.900 --> 00:37:44.450
from the ordinary protection domain
where they're allowed to the accessed in.

00:37:44.449 --> 00:37:47.539
What does strongly enforced mean?

00:37:47.539 --> 00:37:53.409
Strongly enforced means if you're using somebody
else's private ivar your program may fail to link.

00:37:53.409 --> 00:37:55.399
Because you're using that private ivar.

00:37:55.400 --> 00:38:01.450
For those of you writing applications,
don't access private ivars.

00:38:01.449 --> 00:38:07.409
For those of you writing frameworks, you can add
private ivars to your classes, mark them private,

00:38:07.409 --> 00:38:13.099
and be more assured that your clients
won't be accessing them behind your back

00:38:13.099 --> 00:38:16.789
Let's talk about instance variable visibility.

00:38:16.789 --> 00:38:21.469
Again, for those of you writing
frameworks with instance variables in them.

00:38:21.469 --> 00:38:27.089
At public and at protected instance
variables behave the same as they always did.

00:38:27.090 --> 00:38:28.829
You may use them anywhere.

00:38:28.829 --> 00:38:33.259
The compiler will warn you if you're using
at private outside of a sub -- sorry --

00:38:33.260 --> 00:38:38.220
Compiler will warn you if you're using at
protected ivars outside of a sub class.

00:38:38.219 --> 00:38:39.629
But there's no other enforcement.

00:38:39.630 --> 00:38:42.630
There won't be a link area or anything like that.

00:38:42.630 --> 00:38:46.720
At private ivars are where the enforcement comes in.

00:38:46.719 --> 00:38:49.069
And may only be used in the defining class.

00:38:49.070 --> 00:38:50.370
That's the definition of private.

00:38:50.369 --> 00:38:54.219
The compiler warns you if you're using it outside.

00:38:54.219 --> 00:38:56.019
The new feature is this.

00:38:56.019 --> 00:39:01.579
If you use the ivar outside the image
defined in the class you get a link error.

00:39:01.579 --> 00:39:04.559
So by image, I mean the framework that implements the class.

00:39:04.559 --> 00:39:08.019
Or the bundle that implements the class, or the application.

00:39:10.929 --> 00:39:14.789
For those of you who have -- who need for flexibility

00:39:14.789 --> 00:39:19.829
for your instance variables we've added
a new ivar class called At Package.

00:39:19.829 --> 00:39:26.019
The way to think of that package is internal
to your framework or your application.

00:39:26.019 --> 00:39:28.190
It's a public instance variable.

00:39:28.190 --> 00:39:31.130
But if anybody tries to use it
outside of your framework, say,

00:39:31.130 --> 00:39:34.250
your clients try and access it, it looks private to them.

00:39:34.250 --> 00:39:39.719
So this works, for instance, for instance variables
you want to access freely inside your implementation

00:39:39.719 --> 00:39:44.209
for speed reasons, but you don't
want your clients to access it.

00:39:44.210 --> 00:39:48.780
So just like private ivars, if
you use it outside the framework

00:39:48.780 --> 00:39:52.390
or the library defined in the class you get a link error.

00:39:55.030 --> 00:39:57.710
At Package works in 32-bit.

00:39:57.710 --> 00:40:02.909
It behaves the same At Public, because we don't
have any stronger enforcement app framework

00:40:02.909 --> 00:40:06.690
at the framework boundary level.

00:40:06.690 --> 00:40:08.019
Class visibility.

00:40:08.019 --> 00:40:12.489
I mentioned hidden classes a minute ago.

00:40:12.489 --> 00:40:15.299
All classes in Objective-C are public by default.

00:40:15.300 --> 00:40:17.750
This is the same as it is in 32-bit.

00:40:17.750 --> 00:40:25.400
In 6-bit we have a new feature where you
can mark a class hidden if it is a class

00:40:25.400 --> 00:40:28.599
that you're only going to be using inside of your framework.

00:40:28.599 --> 00:40:35.199
So this is a class that is an implementation class
or a private sub class, or something like that.

00:40:35.199 --> 00:40:42.379
This is the syntax for marking such a class, it uses
one of the GCC attributes that I mentioned earlier.

00:40:42.380 --> 00:40:45.880
Oops. Sorry about that.

00:40:45.880 --> 00:40:50.559
One problem with this feature is we
don't have any clean syntax for it yet.

00:40:50.559 --> 00:40:51.920
Sorry about that.

00:40:51.920 --> 00:40:55.079
You have to use the raw GCC attribute syntax.

00:40:55.079 --> 00:41:00.619
One note about that; first of all the attribute
needs to go before your At Interface declaration.

00:41:00.619 --> 00:41:05.309
Second of all, you must have as precisely as many
parentheses and double quotes as you see here.

00:41:05.309 --> 00:41:10.750
If you have any different number the compiler
will complain because it won't recognize it.

00:41:10.750 --> 00:41:13.050
So what does a hidden class do?

00:41:13.050 --> 00:41:17.830
First of all, hidden class gives you
a link error if somebody else tries

00:41:17.829 --> 00:41:20.319
to use the class outside of the framework.

00:41:20.320 --> 00:41:26.350
You try and access it directly, if they try
and sub class it, they get a link error.

00:41:26.349 --> 00:41:35.589
Additionally, all the ivars will similarly get a linker
if anybody tries to access them out of your implementation.

00:41:35.590 --> 00:41:44.269
One down side of this is the hidden class is
still in the global Objective-C class name space.

00:41:44.269 --> 00:41:46.940
Which means the class name still needs to be unique.

00:41:46.940 --> 00:41:51.400
So you still need the class name
prefix at the start of the class.

00:41:51.400 --> 00:41:54.099
The hidden class do not provide that.

00:41:54.099 --> 00:41:59.349
We're looking at ways to provide a better way
to do non unique class names in the future.

00:41:59.349 --> 00:42:02.589
But for now this is what we have.

00:42:02.590 --> 00:42:07.829
So one point about hidden classes and private ivars.

00:42:07.829 --> 00:42:12.869
For those of you who really, really,
really want to access them still.

00:42:12.869 --> 00:42:15.109
You can actually get to them at runtime.

00:42:15.110 --> 00:42:20.829
If you call OBJC get class with the name
of a hidden class you'll get the class.

00:42:20.829 --> 00:42:26.610
If you call the instance variable look up
foundation for a private I bar, you'll get the ivar.

00:42:26.610 --> 00:42:29.000
So you can still use them.

00:42:29.000 --> 00:42:29.650
But don't.

00:42:29.650 --> 00:42:30.750
You really shouldn't be doing that.

00:42:30.750 --> 00:42:35.630
There's usually reasons why they're
marked private in the first place.

00:42:35.630 --> 00:42:38.640
So manipulating class and ivar visibility.

00:42:38.639 --> 00:42:44.079
The best way to change visibility of an instance
variable or a class is to use the language constructs.

00:42:44.079 --> 00:42:51.259
If you have ivars and they're internal to your code
mark them private; mark them packaged as appropriate.

00:42:51.260 --> 00:42:57.380
If you have classes which are internal to your
implementation mark them hidden so that anybody who tries

00:42:57.380 --> 00:43:00.660
to use them will get a link error if they try.

00:43:00.659 --> 00:43:04.170
There are other ways to restrict the visibility as well.

00:43:04.170 --> 00:43:06.260
Using the linker.

00:43:06.260 --> 00:43:08.110
So I won't talk about these too much.

00:43:08.110 --> 00:43:11.630
But if you use an exported symbol list.

00:43:11.630 --> 00:43:14.769
Classes in 64-bit have a symbol attached to them.

00:43:14.769 --> 00:43:18.070
Instance variables in 64-bit have a symbol attached to them.

00:43:18.070 --> 00:43:24.940
That's why you get the link error if you're trying to use
the wrong one, because those symbols are not exported.

00:43:24.940 --> 00:43:31.550
So you can manipulate your instance variable and
class visibility using an exported symbol list

00:43:31.550 --> 00:43:39.800
or using the GCC option or Xcode
option for hiding symbols by default.

00:43:39.800 --> 00:43:43.590
One point to note, you may already
be hiding your symbols by default.

00:43:43.590 --> 00:43:49.269
But in 32-bit that doesn't hide your
Objective-C classes or your instance variables.

00:43:49.269 --> 00:43:53.650
So if you are using symbols hidden
by default for F visibility hidden

00:43:53.650 --> 00:44:00.670
and you're writing a framework you may need to add this
attribute to your classes which says visibility default.

00:44:00.670 --> 00:44:04.820
Which makes them public again, if you
have classes that you did want to export,

00:44:04.820 --> 00:44:07.570
even though you said symbols hidden by default.

00:44:07.570 --> 00:44:15.850
So for more information on these details, on these options
see the Xcode documentation, see the GCC documentation.

00:44:15.849 --> 00:44:25.309
If you do try to access a class or an instance variable that
you're not allowed to access you'll get one of these errors.

00:44:25.309 --> 00:44:28.949
Undefined symbol error from the linker.

00:44:28.949 --> 00:44:33.000
The first one is you tried to access
a class; called some class.

00:44:33.000 --> 00:44:42.239
The OBJC Class, dull, or some class is the symbol name
generated behind the scenes in 64-bit for that class.

00:44:42.239 --> 00:44:47.549
Similarly, if you tried to access an ivar from
that class and it was a private ivar you would get

00:44:47.550 --> 00:44:52.380
that linker message for the illegal access to the ivar.

00:44:52.380 --> 00:44:55.940
It's also possible that the instance variable is public.

00:44:55.940 --> 00:44:58.119
That the class is a public class.

00:44:58.119 --> 00:45:01.269
But you simply forget to link to the proper framework.

00:45:01.269 --> 00:45:13.409
So be aware of that when you see this sort of warning,
this sort of error when you're building your code.

00:45:13.409 --> 00:45:18.269
Next 64-bit feature I'll talk about
is non fragile instance variables.

00:45:18.269 --> 00:45:25.610
Non fragile instance variables basically make things
work in the way that they didn't work in 32-bit.
2

00:45:25.610 --> 00:45:28.579
So for most of you, you won't actually care
that this is happening behind your back.

00:45:28.579 --> 00:45:31.049
Because like I said, it just works.

00:45:31.050 --> 00:45:33.740
Let me talk about fragile instance variables.

00:45:33.739 --> 00:45:38.189
Which is what we have in 32-bit, what we fixed in 64-bit.

00:45:38.190 --> 00:45:40.610
This is what a fragile instance variable is.

00:45:40.610 --> 00:45:47.230
Classes in a framework cannot change instance
variables without breaking sub classes in applications.

00:45:47.230 --> 00:45:54.449
What this means is NS View in 32-bit cannot ad2d
any additional instance variables because all

00:45:54.449 --> 00:45:57.759
of your sub classes of NS View would stop working.

00:45:59.090 --> 00:46:02.920
Fragile base class problem, for those of
you who have studied language-based theory.

00:46:02.920 --> 00:46:05.170
This is what it is.

00:46:05.170 --> 00:46:12.789
Because we can't change NS View or any other Cocoa
framework, it makes it harder to improve the framework.

00:46:12.789 --> 00:46:20.900
We can't add ivars when we want to once the class is
released, once you guys have sub classed the class.

00:46:20.900 --> 00:46:24.780
In Objective-C we don't have this
problem with methods, basically.

00:46:24.780 --> 00:46:29.960
You can add a methods to a base class and the sub
classes still work because method look up is so dynamic.

00:46:29.960 --> 00:46:36.250
There are still problems with if you've got method of the
same name, if you took away a method someone was calling.

00:46:36.250 --> 00:46:37.400
That's a problem.

00:46:37.400 --> 00:46:38.700
But you guys can deal with that.

00:46:38.699 --> 00:46:40.699
You guys are smart.

00:46:40.699 --> 00:46:44.349
But in 32-bit Objective-C instance
variables are decidedly not safe.

00:46:44.349 --> 00:46:50.829
You just can't add an instance variable to a
class if anybody else has a sub class of it.

00:46:50.829 --> 00:46:54.840
Let me show you an illustration of
what actually happens if you try

00:46:54.840 --> 00:46:58.680
and add an instance variable and
your instance variables are fragile.

00:46:58.679 --> 00:47:01.259
On the left we have NS window.

00:47:01.260 --> 00:47:05.930
Or a very tiny version of NS window with
only a couple of instance variables in it.

00:47:05.929 --> 00:47:12.549
And on the right we have the pet store window, which is my
neat pet store application which is sub classing NS window.

00:47:12.550 --> 00:47:17.120
And I've added two instance variables for the list of
kittens and the list of puppies that are available.

00:47:17.119 --> 00:47:19.329
So this is all well and good.

00:47:19.329 --> 00:47:22.690
The problem is when Leopard comes out.

00:47:22.690 --> 00:47:27.070
And NS window added a tool bar instance variable.

00:47:27.070 --> 00:47:31.030
The problem is the tool bar instance variable is at offset 24.

00:47:31.030 --> 00:47:34.720
And unfortunately that just killed your kittens.

00:47:34.719 --> 00:47:39.899
Because all your compiled code expects
that instance variable to be at offset 24.
$

00:47:39.900 --> 00:47:41.030
And it's not there any more.

00:47:41.030 --> 00:47:43.070
That's where the tool bar is.

00:47:43.070 --> 00:47:44.950
So this is a fragile instance variable.

00:47:44.949 --> 00:47:45.869
This is what happens.

00:47:45.869 --> 00:47:50.849
This why NS Window and NS View cannot
add instance variables any more.

00:47:50.849 --> 00:47:55.349
What you really want to have happen, though, is this.

00:47:55.349 --> 00:47:58.190
This is what happens in 64-bit mode.

00:47:58.190 --> 00:48:07.559
The 64-bit runtime and compiler, and the compiled code are
smart enough to be able to move ivars around at run time.

00:48:07.559 --> 00:48:14.599
When the runtime loads the pet store window class
and it sees that the NS window class is bigger

00:48:14.599 --> 00:48:17.039
than it was when the pet store window was compiled.

00:48:17.039 --> 00:48:18.599
It can move the instance variables.

00:48:18.599 --> 00:48:23.759
It can slide the kitten and the puppies out of the
way of the marauding tool bar and keep them safe.

00:48:23.760 --> 00:48:30.380
And the generated code does not need to be recompiled
to adapt to the New Instance variable layout.

00:48:30.380 --> 00:48:33.559
This is what we've added in 64-bit.

00:48:33.559 --> 00:48:36.949
All instance variables in 64-bit are non fragile.

00:48:36.949 --> 00:48:38.159
Which is good.

00:48:38.159 --> 00:48:43.359
The compiled code uses the symbol I showed
you earlier during the access control.

00:48:43.360 --> 00:48:46.220
That symbol points to the offset of that instance variable.

00:48:46.219 --> 00:48:51.549
When you access the instance variable
it load the offset from that location.

00:48:51.550 --> 00:48:55.660
The runtime can then change that
offset when it loads the class.

00:48:55.659 --> 00:49:00.559
What does this mean for framework authors?

00:49:00.559 --> 00:49:04.389
It means framework can change their ivars
without breaking their clients.

00:49:04.389 --> 00:49:06.319
The specific changes you can make.

00:49:06.320 --> 00:49:10.100
You can add ivars to a class and no sub classes will care.

00:49:10.099 --> 00:49:14.880
You can move ivars within a class,
and the sub classes won't care.

00:49:14.880 --> 00:49:21.720
You can also delete and rename instance variables that you
already have and sub classes won't care unless, of course,

00:49:21.719 --> 00:49:24.669
the sub classes are actually using that ivar.

00:49:24.670 --> 00:49:27.380
In which case they will get a link
error when they try and run.

00:49:27.380 --> 00:49:36.760
A couple of things in your code that you should
not do to ivars because they are non fragile.

00:49:36.760 --> 00:49:40.650
Because the non fragileness sort of
breaks these -- this sort of code.

00:49:40.650 --> 00:49:42.160
Particular things you shouldn't do.

00:49:42.159 --> 00:49:44.039
Don't use at depths.

00:49:44.039 --> 00:49:49.119
The at depths construct gives you a structure
representation of your instance variables.

00:49:49.119 --> 00:49:52.339
And of course if the instance variables
move at runtime that structure is wrong.

00:49:52.340 --> 00:49:54.120
So don't do it.

00:49:54.119 --> 00:49:56.730
Don't use size of a class.

00:49:56.730 --> 00:49:59.900
It's possible that the sub class
added instance -- or a superclass --

00:49:59.900 --> 00:50:03.860
added instance variables which
changes the size of the class itself.

00:50:03.860 --> 00:50:07.059
We have a runtime function you could use to get the size.

00:50:07.059 --> 00:50:10.690
For the same reason, don't use offset of and ivar.

00:50:10.690 --> 00:50:16.090
Instead, use the C functions to look up
the I bar, look up the size at runtime.

00:50:16.090 --> 00:50:25.600
Finally, non fragile ivars only applies to structure and
bit fields as the entire structure, or the entire bit field.

00:50:25.599 --> 00:50:30.759
The individual fields inside structure or
bits inside your bit fields are still fragile

00:50:30.760 --> 00:50:34.150
if you array arrange them inside
the structure in the bit field.

00:50:34.150 --> 00:50:39.320
So if you have an instance variable which you expect
other people to use and its the structure type,

00:50:39.320 --> 00:50:44.470
don't rearrange the contents of the
structure in your framework or in your class.

00:50:44.469 --> 00:50:52.539
Last feature I'm going to talk about, for those of
you writing C++ or Objective-C++ Code,

00:50:52.539 --> 00:50:55.469
zero-cost C++ compatible exceptions.

00:50:55.469 --> 00:50:58.079
Now I heard earlier some of you
guys thought you would like this.

00:50:58.079 --> 00:51:00.489
Let me show you why.

00:51:00.489 --> 00:51:04.799
This is a performance graph, showing
you what zero cost means.

00:51:04.800 --> 00:51:09.480
I put it in scare quotes there, because
it is not really zero cost everything.

00:51:09.480 --> 00:51:12.000
It's zero cost some things.

00:51:12.000 --> 00:51:17.280
So this is showing performance of executing empty blocks,

00:51:17.280 --> 00:51:23.290
executing try finally blocks, and
executing exception throwing

00:51:23.289 --> 00:51:26.469
The blue columns are 32-bit runtime.

00:51:26.469 --> 00:51:33.049
And the green columns are the 64-bit runtime
wdith quote, unquote, "zero cost" exceptions.

00:51:33.050 --> 00:51:35.539
So the column on the left is just the baseline.

00:51:35.539 --> 00:51:38.519
Speed for executing lots of empty blocks.

00:51:38.519 --> 00:51:42.900
And we see actually Intel 64 is a
little bit faster than Intel 32-bit.
2

00:51:42.900 --> 00:51:47.410
Yay for the new instruction set!

00:51:47.409 --> 00:51:50.829
So the middle column shows you try finally blocks.

00:51:50.829 --> 00:51:54.190
And this is the part where zero cost exceptions are faster.

00:51:54.190 --> 00:52:02.039
That big blue bar means that 32-bit exceptions
simply using an at try block is slow.

00:52:02.039 --> 00:52:09.110
Because an at try block means execute a lot of code in order
to prepare for an exception if it actually were thrown.

00:52:09.110 --> 00:52:13.320
64-bit you'll see that it is within one millisecond.

00:52:13.320 --> 00:52:18.269
It's actually within the timing error
of my test, of executing empty blocks

00:52:18.269 --> 00:52:22.349
to get to use the same number of try blocks.

00:52:22.349 --> 00:52:26.480
Try blocks are no more expensive than an ordinary block.

00:52:26.480 --> 00:52:28.440
But there is a cost.

00:52:28.440 --> 00:52:30.380
So you don't get that cost for free.

00:52:30.380 --> 00:52:34.599
The problem is when you actually throw
in an exception the speed is reversed.

00:52:34.599 --> 00:52:39.009
We see that the 32-bit is very2,
very fast at throwing exceptions.

00:52:39.010 --> 00:52:43.050
But 64-bit is much slower at throwing exceptions.

00:52:43.050 --> 00:52:49.070
So the change is 32-bit does all the
exception overhead at the try block.

00:52:49.070 --> 00:52:55.460
64-bit does the same exception overhead when
you actually try and throw in exception.

00:52:55.460 --> 00:53:01.650
So the assumption is you do a lot more
try blocks, you don't do very many throws.

00:53:01.650 --> 00:53:04.280
So 64-bit.

00:53:04.280 --> 00:53:06.130
Entering a try block is fast.

00:53:06.130 --> 00:53:11.809
Feel free to sprinkle try blocks throughout your
code to help make your code more exception safe.

00:53:11.809 --> 00:53:15.309
On the down side, throwing an exception is slow.

00:53:15.309 --> 00:53:21.779
And one thing I didn't show in that graph, there's
also a big memory overhead with an exception is thrown

00:53:21.780 --> 00:53:25.260
to pull in the exception unwinding information.

00:53:25.260 --> 00:53:28.980
What does this mean?

00:53:28.980 --> 00:53:32.610
Throw exceptions in exceptional circumstances only.

00:53:32.610 --> 00:53:37.320
For the Cocoa frameworks themselves, they're
-- the model is already fulfilled that way.

00:53:37.320 --> 00:53:45.269
We don't have a file not found exception,
or you hit the end of your array exception.

00:53:45.269 --> 00:53:49.500
Instead we have things like invalid
parameter for your programmer error.

00:53:49.500 --> 00:53:51.219
Or out of bounds exceptions.

00:53:51.219 --> 00:53:54.649
Again, a programmer error.

00:53:54.650 --> 00:53:59.230
One note here that some of you might not be aware
of if you are using exception handling code.

00:53:59.230 --> 00:54:03.429
AppKit assumes that exceptions being
thrown are NS exception objects.

00:54:03.429 --> 00:54:06.489
So don't throw string objects, don't throw other objects.

00:54:06.489 --> 00:54:09.049
AppKit will get confused.

00:54:09.050 --> 00:54:13.030
So use that NS exceptions; use sub classes of it.

00:54:13.030 --> 00:54:18.120
I mentioned one other thing earlier, which
is C++ compatible exceptions.

00:54:18.119 --> 00:54:19.880
What does that mean?

00:54:19.880 --> 00:54:24.550
You guys are going to like this, for those of you who do --

00:54:24.550 --> 00:54:30.490
64-bit exceptions in Objective-C share
the C++ exception machinery.

00:54:30.489 --> 00:54:33.519
Which means C++ exceptions, Objective-C code,

00:54:33.519 --> 00:54:40.519
and Objective-C++ code all work
together, the exception models are the same.

00:54:40.519 --> 00:54:44.690
( Applause )

00:54:44.690 --> 00:54:46.760
>> Your source code doesn't have to change.

00:54:46.760 --> 00:54:52.080
The throw expression, the try expressions,
the syntax is all the same.

00:54:52.079 --> 00:54:57.150
The only thing that's not source compatible is those
of you who were jumping through big hoops to try

00:54:57.150 --> 00:55:01.400
to catch your Objective-C and rethrow C++.

00:55:01.400 --> 00:55:02.590
You might want to change that code.

00:55:02.590 --> 00:55:06.350
But otherwise, source compatible with 32-bit.

00:55:06.349 --> 00:55:13.389
We've added one additional source construct to
32-bit and 64-bit, which is a default catch,

00:55:13.389 --> 00:55:17.769
like C++ catch dot, dot, dot expression.

00:55:17.769 --> 00:55:19.509
Which catches any exception.

00:55:19.510 --> 00:55:21.940
I'll talk about that in just a second.

00:55:21.940 --> 00:55:24.829
So what do I mean by work together?

00:55:24.829 --> 00:55:26.699
I mean all of this.

00:55:26.699 --> 00:55:30.859
C++ destructors are called when
unwinding an Objective-C exception.

00:55:30.860 --> 00:55:32.050
( Applause )

00:55:32.050 --> 00:55:34.039
>> This didn't happen in 32-bit.

00:55:34.039 --> 00:55:38.900
In 32-bit your C++ destructors are
ignored when unwinding an object to C exception.

00:55:38.900 --> 00:55:39.860
Which is bad.

00:55:39.860 --> 00:55:42.340
We fixed it in 64-bit.
d

00:55:42.340 --> 00:55:48.620
Conversely, at finally blocks are executed
when unwinding a C++ exception.

00:55:48.619 --> 00:55:50.769
Again, the exception models are the same.

00:55:50.769 --> 00:55:52.610
The unwind mechanism is the same.

00:55:52.610 --> 00:55:57.289
The runtime is -- has no trouble
recognizing finally blocks and destructors.

00:55:57.289 --> 00:56:06.059
In terms of catch blocks, C++ catch blocks will not
catch Objective-C exceptions except for the default catch.

00:56:06.059 --> 00:56:14.469
So a catch dot dot dot will catch a detected C exception
and you can rethrow it using a throw expression.

00:56:14.469 --> 00:56:20.599
For Objective-C we've added the new
default catch, mirror A C++.

00:56:20.599 --> 00:56:26.989
At Catch catches any Objective-C exception,
and any C++ exception that's going by.

00:56:26.989 --> 00:56:31.489
You can use at Throw to rethrow them
just as you would use a C++ throw

00:56:31.489 --> 00:56:34.909
to rethrow whatever you caught in a default catch.

00:56:34.909 --> 00:56:37.690
Two notes on Objective-C catch.

00:56:37.690 --> 00:56:40.320
The first one is the NS Handler Macro.

00:56:40.320 --> 00:56:45.640
If any of you are still using it, you probably
don't want to use it in 64-bit any more.

00:56:45.639 --> 00:56:49.989
Because NS handler is defined as catch I.D.

00:56:49.989 --> 00:56:53.549
Which means that it doesn't catch
any C++ exceptions.

00:56:53.550 --> 00:56:57.850
So if you're excepting your NS handler
to catch everything that goes by,

00:56:57.849 --> 00:57:01.769
it's actually going to miss any C++ exceptions.

00:57:01.769 --> 00:57:09.739
The other note is that the catch dot dot dot or the at catch
dot dot dot, the Objective-C one, is available in 32-bit.
2

00:57:09.739 --> 00:57:13.609
It does exactly the same thing as catch IDE would.

00:57:13.610 --> 00:57:15.690
So it doesn't add anything to 32-bit.
2

00:57:15.690 --> 00:57:18.690
It's just provided for source compatibility.

00:57:22.449 --> 00:57:28.359
And that's all I have for the new 64-bit
runtime, new Objective-C features.

00:57:28.360 --> 00:57:30.809
We hope you like Objective-C 2.

00:57:30.809 --> 00:57:35.309
We've added some pretty nifty stuff in Objective-C,
and some pretty nifty stuff to the runtime.

00:57:35.309 --> 00:57:42.710
For more information Deric Horn
is the Apple Developer Connection guy to talk to.

00:57:42.710 --> 00:57:44.409
The framework evangelist.

00:57:44.409 --> 00:57:50.179
And we have sample code documentation and more
documentation forthcoming in a couple cases

00:57:50.179 --> 00:57:54.739
for the new features available at the WWDC Web site.
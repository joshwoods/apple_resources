WEBVTT

00:00:17.410 --> 00:00:20.320
Hi everybody,
I'm Dave Zarzycki and I'm going to be

00:00:20.320 --> 00:00:23.200
talking to you about launchd today.

00:00:23.200 --> 00:00:26.690
And although the title may say
managing processes with launchd,

00:00:26.690 --> 00:00:29.460
it's really about helping you
get your processes run when you

00:00:29.460 --> 00:00:30.960
need them and when you want them.

00:00:30.960 --> 00:00:34.440
But first,
and for the first third of this talk,

00:00:34.440 --> 00:00:35.950
I want to talk big.

00:00:35.960 --> 00:00:39.070
I want to talk about Apple and
I want to talk about the goals we

00:00:39.180 --> 00:00:43.280
have for ourselves and how they
permeate the system and go all the

00:00:43.280 --> 00:00:47.140
way down to a low level technology
like launchd and how they permeate

00:00:47.140 --> 00:00:51.480
back to everyone else at the company
and or third parties to make really

00:00:51.480 --> 00:00:53.070
great products for all our customers.

00:00:53.080 --> 00:00:58.690
So these are three fundamentally
different products,

00:00:58.690 --> 00:01:02.680
but they're all derived from the
same core Unix operating system.

00:01:02.680 --> 00:01:07.280
But only one of them, the laptop,
has a terminal.

00:01:07.280 --> 00:01:09.600
The other two, no terminal.

00:01:09.640 --> 00:01:13.070
In fact,
one of these doesn't even have a shell,

00:01:13.080 --> 00:01:13.750
the interpreter.

00:01:13.760 --> 00:01:15.880
What does this mean?

00:01:15.880 --> 00:01:18.910
Well,
when something goes wrong on your laptop,

00:01:18.910 --> 00:01:22.180
you can get a smart friend,
maybe a system administrator,

00:01:22.240 --> 00:01:24.440
they can come poke around, maybe fix it.

00:01:24.440 --> 00:01:27.160
The other two, they're on their own.

00:01:27.160 --> 00:01:31.260
So we need a system that's reliable,
can respond to events when especially

00:01:31.260 --> 00:01:34.830
when things don't go right,
or when unanticipated events happen

00:01:34.830 --> 00:01:36.760
and when expected events happen.

00:01:36.760 --> 00:01:39.550
So let's talk about these
goals more in depth.

00:01:39.550 --> 00:01:41.280
What are our goals?

00:01:41.280 --> 00:01:42.360
What are our goals at Apple?

00:01:42.360 --> 00:01:44.950
And what are our goals that we hope
that maybe you guys can adopt too?

00:01:44.960 --> 00:01:49.090
Well, unlike mainframes and
computers of bygone eras,

00:01:49.100 --> 00:01:53.250
we don't want to restart
applications or computers after

00:01:53.250 --> 00:01:56.160
you change a configuration detail.

00:01:56.160 --> 00:01:58.000
Use...

00:02:00.380 --> 00:02:02.050
Users expect us these days.

00:02:02.060 --> 00:02:06.310
They expect things to just work,
and can you blame them?

00:02:07.190 --> 00:02:09.560
We also want the system
to be more dynamic.

00:02:09.630 --> 00:02:13.910
We have hot-- I like the
airport express this way.

00:02:13.980 --> 00:02:17.740
It's a hot plug hardware,
and it's a wireless device.

00:02:17.740 --> 00:02:22.330
These are low level technology,
like a device as far

00:02:22.360 --> 00:02:25.800
as iTunes is concerned,
and it's wireless networking,

00:02:25.840 --> 00:02:28.860
which we're all very
familiar with these days.

00:02:28.960 --> 00:02:31.840
Finally, it's user friendly.

00:02:31.850 --> 00:02:34.740
This is really what we're
trying to go for in a nutshell.

00:02:35.610 --> 00:02:38.920
This is a slide that I'd
really like to drive home to.

00:02:38.940 --> 00:02:42.260
Today's multi-core CPUs that
Intel and other vendors are

00:02:42.260 --> 00:02:44.580
providing are pretty amazing.

00:02:44.580 --> 00:02:47.980
We've got quad core, eight core.

00:02:47.980 --> 00:02:50.620
Just a couple of years ago,
we were single core.

00:02:50.640 --> 00:02:54.910
We need to figure out ways, collectively,
how to extract the power that this modern

00:02:54.910 --> 00:03:01.960
hardware provides and take advantage
of it across all layers of the system.

00:03:03.210 --> 00:03:08.460
Now, this is one of the web pages on
store.apple.com for one of our machines.

00:03:08.460 --> 00:03:11.070
The details aren't important,
except for one little part.

00:03:11.100 --> 00:03:16.030
That memory, 512 megabytes,
might seem like a lot, but, you know,

00:03:16.030 --> 00:03:19.490
when you have a couple thousand
developers at Apple and tens of

00:03:19.490 --> 00:03:24.230
thousands of third-party developers
all trying to share that memory,

00:03:24.230 --> 00:03:26.100
we all get a small piece of the pie.

00:03:26.100 --> 00:03:29.300
And what we do at Apple,
and we hope you can try to

00:03:29.300 --> 00:03:33.270
do too to help everyone out,
is use as little as possible,

00:03:33.280 --> 00:03:37.100
and if you do consume a lot
to try and solve a problem,

00:03:37.100 --> 00:03:40.320
let it go as quickly as possible,
so that way you can let some

00:03:40.400 --> 00:03:43.100
other part of the system or
some other application use it.

00:03:43.100 --> 00:03:47.010
So, what we've done with
launchd helps us even more,

00:03:47.010 --> 00:03:49.490
and we'll get into that later.

00:03:49.680 --> 00:03:52.650
Now, given these goals, of course,
there's going to be obstacles.

00:03:52.660 --> 00:03:54.500
What are these obstacles?

00:03:54.510 --> 00:03:57.460
Well, straight back to where we started,
life is dynamic.

00:03:57.460 --> 00:03:58.860
That is an obstacle.

00:03:58.900 --> 00:04:02.480
Back in those past,
when we have those mainframes, well,

00:04:02.510 --> 00:04:03.690
we could make assumptions.

00:04:03.720 --> 00:04:06.150
We could assume that the
power wasn't going to go out,

00:04:06.170 --> 00:04:09.100
that the machine wasn't
going to go to sleep,

00:04:09.100 --> 00:04:10.550
network wasn't going to change.

00:04:10.560 --> 00:04:13.230
That really made life easy
for us programmers because

00:04:13.230 --> 00:04:14.740
we could get away with a lot.

00:04:14.770 --> 00:04:16.960
Can't do that as much these days.

00:04:16.960 --> 00:04:20.120
And what we do inside of Apple,
and we hope to help work

00:04:20.120 --> 00:04:24.460
with you to do the same,
is to push everybody to be more dynamic.

00:04:24.460 --> 00:04:27.410
You know, things will change on you,
and you should expect it.

00:04:27.440 --> 00:04:32.090
When you do expect things to go
wrong or things to go different,

00:04:32.120 --> 00:04:35.870
your software tends to behave better
and your customers are happier.

00:04:37.460 --> 00:04:41.850
But some more on the
way of design obstacles.

00:04:41.880 --> 00:04:44.660
Back in the old day, again,
kind of making the assumptions, you know,

00:04:44.660 --> 00:04:46.020
things happen very linearly.

00:04:46.020 --> 00:04:49.080
I was going to do A,
then I was going to do B, and then C.

00:04:49.080 --> 00:04:52.200
And that limited concurrency,
because you had to

00:04:52.230 --> 00:04:54.280
accomplish things linearly.

00:04:54.280 --> 00:04:55.840
And that was unfortunate.

00:04:55.840 --> 00:04:57.630
But it was easier to program that way.

00:04:57.630 --> 00:04:59.160
So no one's going to blame you.

00:04:59.160 --> 00:05:02.200
But these days,
we have a lot of event-driven APIs.

00:05:02.200 --> 00:05:05.680
And what we do is we encourage, again,
Apple people and outside of

00:05:05.680 --> 00:05:07.280
Apple to adopt these APIs.

00:05:07.300 --> 00:05:09.240
And respond to events as they happen.

00:05:09.240 --> 00:05:12.280
And now we can do things out of order,
and possibly even in parallel.

00:05:14.210 --> 00:05:17.280
But more to the point,
when you adopt these event-driven APIs,

00:05:17.280 --> 00:05:19.800
you increase the flexibility
of your software.

00:05:19.800 --> 00:05:24.500
And the more flexibility you have,
the more resilient you are to

00:05:24.510 --> 00:05:29.030
unanticipated events happening
and not having your software

00:05:29.030 --> 00:05:34.100
crumble under the bizarreness of
the system or the environment.

00:05:34.400 --> 00:05:39.550
When things go wrong on other systems,
and sometimes our system,

00:05:39.560 --> 00:05:40.800
something like this happens.

00:05:40.800 --> 00:05:45.090
You get a blue screen of death,
and that's because things fell apart so

00:05:45.090 --> 00:05:47.790
bad we had to grind to a halt and reboot.

00:05:47.890 --> 00:05:50.680
And what we'd like to do,
and what we encourage, again,

00:05:50.680 --> 00:05:53.600
everybody to do,
is adopt ways to avoid this problem.

00:05:53.600 --> 00:05:56.220
And most of it's through error recovery.

00:05:56.750 --> 00:05:59.250
Now, how did Apple accomplish
our design goals?

00:05:59.280 --> 00:06:02.270
Well, launchd is one part of it,
but it's a big part.

00:06:02.290 --> 00:06:05.390
Launchd manages processes,
and when processes,

00:06:05.400 --> 00:06:06.700
they occasionally fail.

00:06:06.770 --> 00:06:09.700
And when they fail,
what launchd does is it restarts them.

00:06:09.700 --> 00:06:12.690
In that sense, launchd is a lifeguard.

00:06:12.690 --> 00:06:17.630
Watches out, something goes wrong,
it'll save you, get you restarted again.

00:06:18.710 --> 00:06:21.240
But also,
given that there's a bunch of processes,

00:06:21.240 --> 00:06:24.000
launchd is also a telephone operator,
and it helps these

00:06:24.140 --> 00:06:25.700
processes find each other.

00:06:25.700 --> 00:06:29.130
This is really all launchd does,
and we'll go into this

00:06:29.130 --> 00:06:30.900
in detail quite quickly.

00:06:33.500 --> 00:06:36.640
First, let me say that launchd
is very popular at Apple.

00:06:36.640 --> 00:06:42.680
There are 164 launchd jobs in
Mac OS X just provided by Apple.

00:06:42.680 --> 00:06:44.420
And this is just Mac OS X client.

00:06:44.420 --> 00:06:48.320
There are even more on Mac OS X server,
and there are unnamed ones on some

00:06:48.320 --> 00:06:51.900
of the other embedded devices.

00:06:51.900 --> 00:06:54.800
In fact,
we don't even have startup items anymore.

00:06:54.800 --> 00:06:58.070
The fact that launchd
has been so successful.

00:06:58.400 --> 00:07:04.080
From airport to x-ray,
many diverse and different technologies

00:07:04.080 --> 00:07:08.510
that are from low-level airport to
high-level x-ray with developers,

00:07:08.540 --> 00:07:11.440
they're using launchd to
accomplish their design goals.

00:07:11.440 --> 00:07:13.620
So I'm glad that for those
of you that are here,

00:07:13.620 --> 00:07:15.860
you're going to find out why.

00:07:16.310 --> 00:07:20.240
Well, first of all,
fault isolation and recovery.

00:07:20.260 --> 00:07:25.240
launchd, at a very simple level,
launches a process, keeps it running.

00:07:25.240 --> 00:07:27.690
If it crashes or if
it exits mysteriously,

00:07:27.780 --> 00:07:29.190
launchd will restart it.

00:07:29.240 --> 00:07:32.500
That's the simplest usage model,
but that's powerful.

00:07:32.500 --> 00:07:34.850
In the previous system,
we'd just launch a process

00:07:34.860 --> 00:07:38.640
and forget about it and hope
that things went all right.

00:07:38.710 --> 00:07:41.990
It's a simple change,
but it makes a world of difference.

00:07:42.820 --> 00:07:47.100
Launchd, going with the telephone
operator analogy,

00:07:47.100 --> 00:07:49.100
allows for fully asynchronous bootstrap.

00:07:49.100 --> 00:07:52.510
We can really help
processes find each other,

00:07:52.530 --> 00:07:55.890
even though,
and coordinate things in a much

00:07:55.900 --> 00:08:00.140
more parallel way that feeds back
into helping us solve the multi-core

00:08:00.140 --> 00:08:02.760
problem which we talked about earlier.

00:08:03.600 --> 00:08:07.100
It also provides pay-as-you-go computing.

00:08:07.100 --> 00:08:09.920
We try, again,
in the low memory scenarios

00:08:09.920 --> 00:08:13.140
and performance goals
that our customers love,

00:08:13.260 --> 00:08:16.850
try and help our developers inside
and outside the company only

00:08:16.950 --> 00:08:18.880
run software when they need it.

00:08:18.880 --> 00:08:21.800
And being event driven helps that too.

00:08:22.560 --> 00:08:24.500
And finally, security.

00:08:24.560 --> 00:08:27.780
Launchd provides,
and I know this may sound crazy,

00:08:27.780 --> 00:08:31.500
just a clean environment for
your process when it starts.

00:08:31.500 --> 00:08:35.280
You don't have to worry about pollution
by maybe the user set up some strange

00:08:35.280 --> 00:08:39.580
environment variable that may change
the behavior of a library you're using,

00:08:39.630 --> 00:08:42.490
or all of a sudden a user may
launch a program in a working

00:08:42.570 --> 00:08:44.570
directory that you didn't expect.

00:08:44.610 --> 00:08:48.260
Nope, same environment from the
first time to the last time.

00:08:48.260 --> 00:08:49.480
It's always clean.

00:08:50.520 --> 00:08:53.100
Also,
in a mechanism that Apple primarily uses,

00:08:53.100 --> 00:08:56.500
but you can use too,
launchd provides privilege separation,

00:08:56.500 --> 00:09:01.740
which going combined with a clean
environment can allow you to accomplish

00:09:01.740 --> 00:09:04.990
privilege operations in a secure manner.

00:09:05.370 --> 00:09:06.500
So let's go into depth.

00:09:06.500 --> 00:09:09.260
Let's go into those
bullets that you all love.

00:09:09.280 --> 00:09:11.920
Launchd, first of all, is open source.

00:09:11.920 --> 00:09:15.260
We at Apple think this is so important
that we've open sourced this with a

00:09:15.260 --> 00:09:19.460
license that is the Apache license.

00:09:19.470 --> 00:09:23.120
So that organizations,
such as the BSD projects,

00:09:23.120 --> 00:09:29.080
are more likely to include and
find all around more palatable.

00:09:29.120 --> 00:09:33.080
We'd like to work with other OS vendors,
such as the BSDs and the Lennoxes,

00:09:33.080 --> 00:09:36.840
or anybody else, for that matter,
who wants to adopt it.

00:09:36.840 --> 00:09:41.100
We have a URL and a blog and a
mailing list and actually all that

00:09:41.220 --> 00:09:45.140
good stuff on launchd.macosforge.org.

00:09:45.140 --> 00:09:49.580
In fact, you can see the source live
as we update it here at Apple.

00:09:50.300 --> 00:09:53.590
Now, what are we going to cover
today as far as the details?

00:09:53.610 --> 00:09:58.430
Well, for you developers in the audience,
we'll cover where your code fits in.

00:09:58.460 --> 00:09:59.650
There's a big system.

00:09:59.690 --> 00:10:02.260
There's lots of different
places it can go.

00:10:02.930 --> 00:10:03.890
How does it get involved?

00:10:03.910 --> 00:10:06.330
When is it going to be run?

00:10:06.340 --> 00:10:08.140
How do we resolve dependencies?

00:10:08.140 --> 00:10:10.230
You know,
we still need to rely on things.

00:10:10.260 --> 00:10:13.860
We may be making less assumptions,
but we still need things.

00:10:13.860 --> 00:10:17.200
And if we're the backend of something,
how do we check in?

00:10:17.210 --> 00:10:19.000
How do we get things going?

00:10:19.000 --> 00:10:21.790
If you're a system administrator,
we'll show you some of the

00:10:21.790 --> 00:10:25.230
things that you can do,
and we'll give a demo later showing

00:10:25.230 --> 00:10:27.880
some of the commands you can do
to interact with the system and

00:10:27.880 --> 00:10:29.770
find out how things are working.

00:10:30.110 --> 00:10:33.840
And we'll talk about why
launchd is good for you.

00:10:33.840 --> 00:10:36.240
So fitting into Mac OS X.

00:10:36.240 --> 00:10:38.530
We have some three basic
layers now in Leopard.

00:10:38.540 --> 00:10:41.040
This is different than Tiger.

00:10:41.040 --> 00:10:43.680
In Tiger,
we just had the per machine layer,

00:10:43.680 --> 00:10:47.060
and the per session layer was, well,
less defined.

00:10:47.150 --> 00:10:49.260
Now it's much more concrete.

00:10:49.280 --> 00:10:51.940
You're going to find
programs like Safari,

00:10:51.940 --> 00:10:55.560
iTunes, System UI Server,
running in this collective layer.

00:10:55.590 --> 00:11:00.480
And to be completely forthwith,
I may use different words

00:11:00.480 --> 00:11:02.800
to describe this layer.

00:11:02.800 --> 00:11:03.900
I might say bucket.

00:11:03.900 --> 00:11:05.200
I may say session.

00:11:05.200 --> 00:11:06.800
I may say context.

00:11:06.800 --> 00:11:08.460
I mean all the same thing.

00:11:08.510 --> 00:11:13.000
We're still struggling with terminology
for describing these containers.

00:11:13.860 --> 00:11:18.350
We also have a per machine layer,
and this layer contains

00:11:18.430 --> 00:11:21.080
things like disk arbitrationd,
or kextd, or configd,

00:11:21.080 --> 00:11:23.390
if you've ever done a PS.

00:11:23.820 --> 00:11:28.080
But what we've added that is truly
new in Leopard is a per user layer.

00:11:28.110 --> 00:11:32.040
The per user layer is meant for
programs like these outlined here,

00:11:32.060 --> 00:11:35.190
like the GSSD or the C cache agent.

00:11:35.230 --> 00:11:37.980
You're not necessarily,
I'm not going to go into

00:11:37.980 --> 00:11:41.260
what these exactly do,
but it's a new layer for your

00:11:41.260 --> 00:11:45.200
software can run and provide
services on behalf of the user.

00:11:45.810 --> 00:11:48.960
So what's the relationship
between these layers?

00:11:48.960 --> 00:11:51.520
Well, what we'd like to encourage,
given these programs need

00:11:51.520 --> 00:11:53.790
to talk to each other,
they don't exist in a vacuum,

00:11:53.790 --> 00:11:56.800
is peer-to-peer or downward
interprocess communication.

00:11:56.800 --> 00:12:00.210
We have these three buckets,
as we outlined before,

00:12:00.210 --> 00:12:01.770
and we have programs.

00:12:01.840 --> 00:12:03.800
Here's some nicknames we give for them.

00:12:03.800 --> 00:12:07.780
We have applications, we have agents,
we have daemons.

00:12:07.800 --> 00:12:09.760
These are the nicknames
we try and stick to,

00:12:09.800 --> 00:12:11.800
but we're not always consistent about.

00:12:11.800 --> 00:12:15.740
And what we'd like to encourage is that,
well, talk to the friends

00:12:15.800 --> 00:12:16.800
and their direct peers.

00:12:16.800 --> 00:12:18.260
And it can go either way.

00:12:18.260 --> 00:12:20.780
One app can talk to the other,
or vice versa,

00:12:20.780 --> 00:12:23.800
or one agent can talk to the other,
or vice versa.

00:12:23.800 --> 00:12:25.800
It's all cool.

00:12:25.800 --> 00:12:29.800
But what we'd also like to
encourage is downward communication.

00:12:29.800 --> 00:12:34.120
Applications can talk to helper
agents or helper daemons,

00:12:34.120 --> 00:12:37.060
or agents can talk to helper daemons.

00:12:37.640 --> 00:12:41.180
On the flip side,
why only die with Nord IPC?

00:12:41.180 --> 00:12:42.780
What's the problem?

00:12:42.820 --> 00:12:46.180
Well, we have this machine-wide layer.

00:12:46.210 --> 00:12:50.100
This is where our programs
live that help the machine out.

00:12:50.290 --> 00:12:52.950
And oh wait, we can have more than
one user on the system,

00:12:53.020 --> 00:12:54.750
and they both could be
running the same program.

00:12:54.750 --> 00:12:58.620
In fact, there's a whole bunch
of layers on the system.

00:12:58.710 --> 00:13:03.210
A user can have a GUI session,
they can have command line sessions,

00:13:03.210 --> 00:13:04.650
or yet future sessions.

00:13:04.650 --> 00:13:09.850
When we encourage downward only IPC,
we encourage well-layered designs.

00:13:09.850 --> 00:13:13.800
It's unambiguous what the
helper process is at that point.

00:13:13.800 --> 00:13:17.930
A GUI session only has a user session,
and it only has one machine

00:13:17.930 --> 00:13:19.620
that it's running on.

00:13:20.210 --> 00:13:22.850
On the flip side,
the machine has multiple users,

00:13:22.850 --> 00:13:26.600
multiple sessions, and at that point,
you'd have to have some policy,

00:13:26.640 --> 00:13:29.840
and policy is the right word,
for which user you talk to.

00:13:29.840 --> 00:13:33.270
And that gets really messy,
and it's something the computer

00:13:33.270 --> 00:13:36.910
shouldn't be trying to do,
you know, at that low of a level.

00:13:38.300 --> 00:13:40.060
So what is the purpose
of these containers?

00:13:40.060 --> 00:13:42.000
We've been kind of alluding to them.

00:13:42.000 --> 00:13:43.860
Let's go in depth.

00:13:43.930 --> 00:13:47.800
The per session layer is for programs
that need to interact with the user.

00:13:47.820 --> 00:13:51.420
That's the closest we can
come to a session definition.

00:13:51.420 --> 00:13:52.380
They come and go with the session.

00:13:52.380 --> 00:13:56.340
You want that finder to
exit when you log out.

00:13:57.140 --> 00:14:03.150
The per user bucket, or session,
or context, is for programs that don't

00:14:03.230 --> 00:14:06.800
need to interact with the user,
but still want to run

00:14:06.800 --> 00:14:08.860
on the user's behalf.

00:14:08.870 --> 00:14:12.990
They are allowed to
transcend login and logout,

00:14:13.000 --> 00:14:15.820
and they're pretty much the lifetime
of the system once they get launched.

00:14:16.820 --> 00:14:19.440
And finally,
we have the per machine layer.

00:14:19.440 --> 00:14:23.030
We'd really like to encourage the
minimal amount of code that is

00:14:23.030 --> 00:14:26.920
required to arbitrate or share
hardware to live at this level.

00:14:26.930 --> 00:14:31.140
And we do this because
of the security risks.

00:14:31.140 --> 00:14:33.340
Obviously,
it's working on behalf of the machine,

00:14:33.340 --> 00:14:37.610
but what it also is doing is
operating on behalf of all the users.

00:14:37.820 --> 00:14:41.110
And if you get a security bug,
maybe a buffer overflow,

00:14:41.110 --> 00:14:44.850
or some kind of other exploit,
you put all the users at risk.

00:14:45.220 --> 00:14:45.220
Whereas if the per user
bucket is a security bug,

00:14:45.220 --> 00:14:45.300
then you're operating on
behalf of all the users.

00:14:45.780 --> 00:14:50.570
And if the per user program were just
up one more layer at the per user layer,

00:14:50.570 --> 00:14:53.460
the damage would be limited to that user.

00:14:53.460 --> 00:14:58.220
So if you're not arbitrating the hardware
or helping share it between users,

00:14:58.220 --> 00:15:02.830
hopefully you can consider
moving up a layer.

00:15:03.360 --> 00:15:06.080
Well, getting started,
let's go down into the meat

00:15:06.080 --> 00:15:07.690
more of this presentation.

00:15:08.550 --> 00:15:11.290
Let's install a property list,
Apple's favorite data

00:15:11.290 --> 00:15:13.940
description language,
in the right location.

00:15:14.010 --> 00:15:16.730
There's a whole bunch of standard
locations on Mac OS X where you

00:15:16.730 --> 00:15:18.780
can install a property list.

00:15:18.780 --> 00:15:21.400
First and foremost,
that probably most of you that may

00:15:21.400 --> 00:15:25.910
be shipping software to a customer,
is library launchdamons.

00:15:25.980 --> 00:15:29.640
Library launchdamons are
per-machine jobs that are installed

00:15:29.640 --> 00:15:33.860
by the system administrator,
and they are loaded up for

00:15:33.860 --> 00:15:36.970
the machine for that system.

00:15:37.430 --> 00:15:41.630
Now, Apple provides some, obviously,
but we have a directory of our own,

00:15:41.680 --> 00:15:44.090
and that's /system/library/launchd.

00:15:44.090 --> 00:15:47.700
That's per machine
jobs provided by Apple.

00:15:48.450 --> 00:15:49.630
Now let's do four more.

00:15:49.680 --> 00:15:50.510
They're called agents.

00:15:50.570 --> 00:15:53.820
These can either be the per
user or per session jobs.

00:15:53.860 --> 00:15:55.400
We have a separate directory for those.

00:15:55.400 --> 00:15:59.400
Firstly, we go look in the home
directory for the user.

00:15:59.400 --> 00:16:02.920
Maybe they want a program
only run for them when they're

00:16:02.920 --> 00:16:04.390
logged into a machine somewhere.

00:16:04.400 --> 00:16:08.490
Well, they can do that by putting a
property list in their home directory

00:16:08.490 --> 00:16:10.400
in library and launch agents.

00:16:10.400 --> 00:16:14.390
These are loaded in any of
their sessions when they log in,

00:16:14.480 --> 00:16:19.630
and the user can limit that
through a key we'll describe later.

00:16:20.040 --> 00:16:23.630
Now, the system administrator can
also load jobs into all the

00:16:23.630 --> 00:16:25.890
user sessions and on a network.

00:16:25.940 --> 00:16:30.590
They can do that through
/network/library/launchagents.

00:16:30.590 --> 00:16:34.400
And any machine that mounts that,
launchd will find that and it will

00:16:34.400 --> 00:16:38.520
get some jobs loaded up for every
user on every machine on the network.

00:16:39.160 --> 00:16:41.840
Sometimes you don't want such a wide net.

00:16:41.860 --> 00:16:46.350
You can use /librarylaunchagents to
get processes loaded for each user on

00:16:46.350 --> 00:16:49.000
the system as a system administrator.

00:16:49.000 --> 00:16:55.060
And finally, the one Apple provides,
/systemlibrarylaunchagents.

00:16:56.010 --> 00:16:58.340
Well,
what if you actually wanted to create

00:16:58.340 --> 00:17:00.460
one that worked on Tiger and later?

00:17:00.460 --> 00:17:04.470
Let's go back to that simple case
where launchd starts a process and

00:17:04.470 --> 00:17:06.900
restarts if it crashes or exits.

00:17:07.040 --> 00:17:08.170
Well, you're going to need a label.

00:17:08.170 --> 00:17:09.800
This label is really critical.

00:17:09.800 --> 00:17:11.800
It's a unique identifier for the job.

00:17:11.800 --> 00:17:13.150
It's typically a string.

00:17:13.150 --> 00:17:16.360
It's reverse DNS because
that's pretty hot these days.

00:17:16.360 --> 00:17:20.170
And what it allows us to do,
which is really different

00:17:20.170 --> 00:17:24.140
compared to Unix of old,
is we have a name for a process,

00:17:24.140 --> 00:17:25.880
regardless of when it starts.

00:17:25.900 --> 00:17:26.900
So we have a label.

00:17:26.900 --> 00:17:29.410
We have a label that says, "I'm sorry,
this is a new PID.

00:17:29.410 --> 00:17:31.940
It's going to be a little bit
more complicated if it crashes

00:17:31.940 --> 00:17:33.130
and restarts." The kernel,
on the other hand, has a PID,

00:17:33.130 --> 00:17:33.260
which is ephemeral.

00:17:33.260 --> 00:17:33.900
Every time it crashes and restarts,
it gets a new PID.

00:17:33.900 --> 00:17:36.180
And if you tried to keep chasing it,
you're going to go crazy.

00:17:36.190 --> 00:17:49.230
So we have a label, and we can use that,
and we do use that to

00:17:49.240 --> 00:17:54.710
keep ourselves sane.

00:17:54.800 --> 00:17:56.920
I'm going to read this bullet because
that's the best way to say it.

00:17:56.920 --> 00:17:59.230
It's a pre-tokenized array of
strings that corresponds to

00:17:59.230 --> 00:18:02.650
the second argument of main,
including argv0,

00:18:02.650 --> 00:18:06.770
or the second argument of execv,
and the first argument will

00:18:06.770 --> 00:18:09.790
be inferred if not supplied to
launchd via the program key.

00:18:26.280 --> 00:18:26.280
I can just say, see the man pages.

00:18:26.280 --> 00:18:26.280
It's a little bit more
complicated than it should be,

00:18:26.280 --> 00:18:26.280
but what it amounts to is the name of
your program is actually an argument,

00:18:26.280 --> 00:18:26.280
and you need to supply that,
and we'll use that name to

00:18:26.280 --> 00:18:26.280
figure out what to launch if you
don't tell us what to launch.

00:18:26.510 --> 00:18:27.780
And finally, the last key.

00:18:27.800 --> 00:18:28.860
It's just three keys.

00:18:28.860 --> 00:18:31.690
What to run, a name,
and the on-demand key.

00:18:31.750 --> 00:18:35.620
And when you say on-demand false,
we'll keep that program alive,

00:18:35.620 --> 00:18:38.590
and we'll keep it alive
for the life of the system.

00:18:40.620 --> 00:18:42.760
This is what it looks like in a plist.

00:18:42.760 --> 00:18:45.720
It's surrounded by, obviously,
your header for a property

00:18:45.720 --> 00:18:48.120
list with the XML tags.

00:18:48.120 --> 00:18:51.720
You've got the key labels,
and its value is a string.

00:18:51.750 --> 00:18:57.570
In this case, we have com.example.helloD.

00:18:57.600 --> 00:18:59.080
And we have the program arguments.

00:18:59.080 --> 00:19:01.320
In this case,
the name is a very explicit path

00:19:01.410 --> 00:19:03.010
to where it is on the system.

00:19:03.060 --> 00:19:06.450
We could have just put helloD,
and launchd would have

00:19:06.450 --> 00:19:07.850
found it in user sbin.

00:19:07.910 --> 00:19:12.600
But this is more explicit
and a little more cautious.

00:19:12.600 --> 00:19:14.480
And finally, onDemandFalse.

00:19:14.480 --> 00:19:19.190
OnDemandFalse tells launchd, start it,
keep it alive forever.

00:19:19.770 --> 00:19:20.700
All right.

00:19:20.720 --> 00:19:23.440
So this schema,
I've mentioned three keys.

00:19:23.480 --> 00:19:26.010
There's actually a lot, lot more.

00:19:26.050 --> 00:19:30.860
And the man page is the best place
to go if you want to see them.

00:19:30.940 --> 00:19:34.930
But to give some brief examples,
the working directory.

00:19:34.940 --> 00:19:36.610
You're probably used
to that in your shell.

00:19:36.620 --> 00:19:39.060
You can say CD here, CD there.

00:19:39.180 --> 00:19:42.640
Launchd lets you set
that in a property list.

00:19:42.640 --> 00:19:45.810
Now every time launchd starts that job,
it'll be started with

00:19:45.810 --> 00:19:45.810
that working directory.

00:19:46.500 --> 00:19:48.160
Environment variables.

00:19:48.190 --> 00:19:52.890
If you are at all familiar with some of
our malloc debugging library facilities,

00:19:52.920 --> 00:19:56.460
you will know that the malloc
behavior can be changed via

00:19:56.460 --> 00:19:58.500
malloc environment variables.

00:19:58.580 --> 00:19:59.720
Maybe you want to do that for your job.

00:19:59.720 --> 00:20:01.110
Maybe you're having difficulty with it.

00:20:01.160 --> 00:20:03.130
Well,
you can add it to the property list,

00:20:03.130 --> 00:20:05.990
and now you know every time
that program is started,

00:20:06.080 --> 00:20:08.860
be it the first boot or
some crash and restart,

00:20:08.880 --> 00:20:11.650
the environment variables
will be the same.

00:20:12.400 --> 00:20:13.600
You can set the program.

00:20:13.670 --> 00:20:17.340
This goes back to that program
arguments key and its relationship.

00:20:17.410 --> 00:20:21.930
This allows you to skip the path walk
of maybe bin or user S bin or whatever

00:20:22.070 --> 00:20:24.770
and directly execute a program.

00:20:24.920 --> 00:20:29.900
Username, this only applies to daemons
since they run as root by default.

00:20:29.900 --> 00:20:33.430
Maybe you don't want a particular
program that's a daemon to run as root.

00:20:33.450 --> 00:20:36.160
You can pick a user to run it as.

00:20:36.710 --> 00:20:40.870
A really basic example is the start
interval and start calendar interval.

00:20:40.930 --> 00:20:43.100
Start interval, it's pure.

00:20:43.120 --> 00:20:47.700
If you say 137, we're going to start that
program every 137 seconds.

00:20:47.710 --> 00:20:49.580
It's a little bit different
than cron that way,

00:20:49.590 --> 00:20:51.360
because cron, well,
doesn't let you do that

00:20:51.360 --> 00:20:52.560
level of granularity.

00:20:52.560 --> 00:20:56.470
The best you could hope for is
once a minute on the minute.

00:20:56.920 --> 00:20:59.680
But should you prefer
a calendar interval,

00:20:59.680 --> 00:21:04.520
maybe every Thursday at 3:00 PM,
you can use start calendar interval.

00:21:04.520 --> 00:21:09.070
And to talk about some improvements of
start calendar interval for Leopard,

00:21:09.070 --> 00:21:10.820
we now support more of them.

00:21:10.850 --> 00:21:13.830
So if you wanted to support
multiple calendar intervals,

00:21:13.830 --> 00:21:14.800
you can do that.

00:21:16.800 --> 00:21:19.950
And secondarily,
we fixed a popular bug to report

00:21:19.950 --> 00:21:24.170
that if a calendar interval is
missed while the machine is asleep,

00:21:24.170 --> 00:21:27.800
we will now quickly notice that,
or hopefully quickly notice that

00:21:27.800 --> 00:21:30.620
when the machine wakes up and
run jobs that should have been

00:21:30.620 --> 00:21:33.020
run while the machine was asleep.

00:21:34.080 --> 00:21:38.920
Finally, an example-- yeah.

00:21:38.920 --> 00:21:39.750
Sorry about that.

00:21:39.770 --> 00:21:44.990
Finally, an example,
now that we have the whole concept

00:21:45.000 --> 00:21:49.960
of per user and per session for
context or sessions or buckets,

00:21:49.960 --> 00:21:52.370
we have limit load to session type.

00:21:52.410 --> 00:21:57.300
Popular examples are background, Aqua,
login window.

00:21:57.300 --> 00:21:59.630
We have a couple more,
but these are the ones

00:21:59.630 --> 00:22:01.000
to mention up front.

00:22:01.000 --> 00:22:08.320
Background is the per user context,
and Aqua is the graphical login context.

00:22:08.320 --> 00:22:11.960
And login window is what you see
when you boot up to a login prompt.

00:22:11.960 --> 00:22:16.670
And the reason for this is sometimes
not every program you want run in,

00:22:16.670 --> 00:22:20.500
let's say, the Finder while you're
logged into the GUI.

00:22:20.500 --> 00:22:23.320
You want run while you're
at the login window.

00:22:23.320 --> 00:22:26.320
But some you do want run in both,
like the bezel UI.

00:22:26.320 --> 00:22:28.480
Whenever you adjust the
volume or the brightness,

00:22:28.480 --> 00:22:30.860
that happens to launch a program
on demand in the background.

00:22:30.860 --> 00:22:36.010
And we want that program loaded into
both the Aqua and login window context.

00:22:37.030 --> 00:22:39.730
Now dependencies,
a favorite topic for people,

00:22:39.750 --> 00:22:41.720
and I can't blame them,
because we all have needs

00:22:41.720 --> 00:22:43.590
that we need to sort out.

00:22:43.900 --> 00:22:46.000
We looked at things a little
bit differently in Apple.

00:22:46.010 --> 00:22:49.240
We decided that programs,
programmers work with contracts.

00:22:49.240 --> 00:22:52.530
We need to ask what those pro, uh,
contracts were.

00:22:52.550 --> 00:22:57.020
Well, they define expectations
and promises on both sides.

00:22:57.020 --> 00:22:59.510
In fact, there are two kinds.

00:22:59.660 --> 00:23:02.770
We have programmatic,
which is every API you've ever used,

00:23:02.770 --> 00:23:05.260
and you kind of not,
you don't think about it.

00:23:05.260 --> 00:23:07.900
But one that we sometimes
forget is data driven.

00:23:07.900 --> 00:23:11.780
And what we've talked about thus far
with all the property lists is the fact

00:23:11.780 --> 00:23:13.720
that we're using a data driven API.

00:23:13.720 --> 00:23:16.580
And it's a very nice API,
and it's an API that hopefully

00:23:16.580 --> 00:23:17.950
you all can appreciate.

00:23:17.960 --> 00:23:20.910
But I do know the system
administrators appreciate it,

00:23:20.910 --> 00:23:24.480
because now they can write tools
to introspect all the programs that

00:23:24.480 --> 00:23:27.410
run and ask questions about them,
or maybe change their

00:23:27.420 --> 00:23:29.580
behavior in a consistent way.

00:23:29.600 --> 00:23:33.060
And it makes it just much easier to
interrogate and change the system.

00:23:33.070 --> 00:23:36.530
And it provides for consistent behavior.

00:23:36.530 --> 00:23:41.190
I can't say any programmer who would
rather see the same recipe of code

00:23:41.200 --> 00:23:46.450
copied and pasted between applications,
when they could defer to some other

00:23:46.450 --> 00:23:49.070
program to implement it for them.

00:23:49.770 --> 00:23:52.150
Well, let's say you're writing a program.

00:23:52.220 --> 00:23:54.880
How are you going to
solve your dependencies?

00:23:55.390 --> 00:23:57.460
Well, we're going to start a trend here.

00:23:57.530 --> 00:24:00.980
For network changes, we, Apple,
recommend internally and both

00:24:00.980 --> 00:24:04.800
externally that programmers use
the system configuration framework

00:24:04.820 --> 00:24:06.200
to monitor for network events.

00:24:06.200 --> 00:24:07.940
Remember those laptops.

00:24:07.940 --> 00:24:09.510
They're coming and going from networks.

00:24:09.530 --> 00:24:13.570
If you want to write an application
that your customers will appreciate,

00:24:13.570 --> 00:24:14.880
that's the way to go.

00:24:16.330 --> 00:24:19.610
Now, you might say, "Hey,
I'm writing a server product.

00:24:19.620 --> 00:24:23.200
That server's not moving,
and its network's not changing."

00:24:23.210 --> 00:24:26.900
And what we would like to suggest is,
"Well, okay, fine.

00:24:26.900 --> 00:24:30.720
It may not move,
but if you're not responding

00:24:30.720 --> 00:24:32.700
to network events,
it makes it very difficult for

00:24:32.700 --> 00:24:35.610
system administrators to reconfigure
their network in a way that's

00:24:35.610 --> 00:24:39.750
transparent to their users." And as
we watch more and more server

00:24:39.750 --> 00:24:43.610
administrators maintain lots of servers,
they want to be able to

00:24:43.610 --> 00:24:45.550
centrally administer them.

00:24:45.560 --> 00:24:45.560
Well, we're going to start a trend here.

00:24:45.560 --> 00:24:45.570
For network changes, we, Apple,
recommend internally and both

00:24:45.570 --> 00:24:45.600
externally that programmers use
the system configuration framework

00:24:45.600 --> 00:24:45.600
to monitor for network events.

00:24:45.600 --> 00:24:45.600
Remember those laptops.

00:24:45.600 --> 00:24:45.600
They're coming and going from networks.

00:24:45.600 --> 00:24:45.610
If you're not responding
to network events,

00:24:45.610 --> 00:24:45.920
they might not be able to
centrally administer them.

00:24:46.520 --> 00:24:49.850
And as we watch more and more server
administrators maintain lots of servers,

00:24:49.870 --> 00:24:52.570
they're using things like DHCP to
assign IP addresses to them.

00:24:52.570 --> 00:24:55.300
And it's not surprising these
days to see system administrators

00:24:55.300 --> 00:24:58.420
reconfigure the network and like to
see those updates happen on the fly.

00:24:58.420 --> 00:25:01.340
If you're writing a server,
we'd really appreciate it if you, too,

00:25:01.340 --> 00:25:04.330
would consider using the
system configuration framework.

00:25:04.910 --> 00:25:06.380
Let's say you've got disk changes.

00:25:06.380 --> 00:25:10.380
Well, the disk arbitration
framework is the way to go.

00:25:10.380 --> 00:25:14.970
And this, again, both client and server,
this permeates everything.

00:25:14.980 --> 00:25:17.380
We have FireWire and USB.

00:25:17.380 --> 00:25:19.850
We have Fiber Channel.

00:25:19.850 --> 00:25:21.860
It allows for hot plug devices.

00:25:22.510 --> 00:25:24.530
If you happen to be in
the previous session,

00:25:24.530 --> 00:25:26.760
we demonstrated basic
Unix tools like I/O stab,

00:25:26.760 --> 00:25:28.650
discovering when devices come and go.

00:25:29.640 --> 00:25:32.110
It's very important that everyone
pay attention when disks come and

00:25:32.150 --> 00:25:33.380
go to provide a user experience.

00:25:34.380 --> 00:25:34.380
And a server administrator can do that.

00:25:34.380 --> 00:25:34.440
And a server administrator can do that.

00:25:34.650 --> 00:25:35.380
And a server administrator can do that.

00:25:35.380 --> 00:25:37.610
It's a server administrator
experience that makes everyone happy.

00:25:38.390 --> 00:25:42.210
Finally, for device discovery,
we recommend the I/O Kit framework.

00:25:42.630 --> 00:25:46.370
We're really dynamic these days
between USB and FireWire and

00:25:46.420 --> 00:25:47.720
CardBus was the old technology.

00:25:48.410 --> 00:25:51.590
And I believe ExpressCard is the
new plug-in slot for laptops.

00:25:52.160 --> 00:25:53.840
Their devices come in going like crazy.

00:25:54.210 --> 00:25:57.410
And if you use the I/O Kit framework,
you can find out about that.

00:25:58.200 --> 00:26:01.190
Other changes are going to
require other frameworks.

00:26:01.850 --> 00:26:04.380
Well, why are we driving home
the framework message?

00:26:04.980 --> 00:26:09.540
In the old days, with System Starter and
other similar mechanisms,

00:26:09.640 --> 00:26:13.370
programmers, and this is just the way we
all collectively did things,

00:26:13.460 --> 00:26:15.450
declared which processes they needed.

00:26:16.140 --> 00:26:18.940
But what we noticed in Mac OS X is
the processes were actually an

00:26:18.940 --> 00:26:20.800
implementation detail of a framework.

00:26:21.230 --> 00:26:22.960
And they were already linking
against the framework,

00:26:23.000 --> 00:26:24.990
so that was the dependency declaration.

00:26:25.480 --> 00:26:26.200
It was automatic.

00:26:26.820 --> 00:26:29.480
And what we did is we provided
a mechanism for the frameworks

00:26:29.480 --> 00:26:31.000
to find the processes they need.

00:26:31.550 --> 00:26:34.380
And should that process go away in
the future or a new one comes along,

00:26:34.380 --> 00:26:36.240
Dave Zarzycki and that new
one be added to a framework

00:26:36.240 --> 00:26:39.110
that didn't have one before,
it won't affect the application

00:26:39.110 --> 00:26:41.720
writers because they're already
declaring their dependencies by

00:26:41.720 --> 00:26:43.670
what frameworks they link against.

00:26:44.050 --> 00:26:47.820
So this is a list of
some common examples.

00:26:47.840 --> 00:26:49.410
Some of you may have seen them.

00:26:49.440 --> 00:26:50.540
Just link against the frameworks.

00:26:50.540 --> 00:26:52.510
You'll be a lot happier.

00:26:52.720 --> 00:26:54.600
Well,
let's say you're writing a framework.

00:26:54.600 --> 00:26:56.100
What do you got to do?

00:26:56.100 --> 00:26:58.100
Well, I'm going to pick a case example.

00:26:58.100 --> 00:27:00.270
It goes all the way back to the '70s.

00:27:00.280 --> 00:27:06.100
Simple input, simple output,
takes a login, returns a structure.

00:27:06.110 --> 00:27:07.560
This is getpwnam.

00:27:07.560 --> 00:27:09.300
It looks up an account.

00:27:11.360 --> 00:27:14.620
It previously read a file directly,
because that was just the

00:27:14.620 --> 00:27:16.540
way we did things back then.

00:27:16.580 --> 00:27:20.790
But later in the Mac OS X evolution,
we changed it to talk to a

00:27:20.790 --> 00:27:23.650
program called Directory Services.

00:27:24.170 --> 00:27:26.220
But how did we avoid a race condition?

00:27:26.240 --> 00:27:30.150
Because once that API is called,
we need that process to be running,

00:27:30.150 --> 00:27:30.980
don't we?

00:27:30.980 --> 00:27:32.480
Well, maybe not.

00:27:32.480 --> 00:27:36.680
And the way we did that is by
telling LaunchD about directory

00:27:36.680 --> 00:27:40.680
services and the fact that it
vends inter-process communication.

00:27:40.680 --> 00:27:43.120
This is the change we
made to the property list.

00:27:43.120 --> 00:27:47.140
And this goes all the way back
to what I said LaunchD does.

00:27:47.140 --> 00:27:49.850
It watches out for
processes and restarts them,

00:27:49.900 --> 00:27:52.080
but it's also a telephone operator.

00:27:52.080 --> 00:27:56.890
And what this allows us to do-- and if
I may stretch the telephone operator

00:27:56.890 --> 00:28:00.540
analogy-- this is like getting an
entry in a phone book that you can

00:28:00.540 --> 00:28:02.260
then look up and start dialing.

00:28:02.260 --> 00:28:06.170
But the person doesn't-- or the
process-- doesn't need to be

00:28:06.170 --> 00:28:07.740
home yet and ready to answer.

00:28:07.740 --> 00:28:10.420
But you're not going to get
a no such number problem

00:28:10.420 --> 00:28:12.200
when you make the phone call.

00:28:12.200 --> 00:28:15.860
And what this allows us to do is actually
launch directory services on demand,

00:28:15.880 --> 00:28:19.500
because we know that a process
is trying to talk to it.

00:28:19.500 --> 00:28:24.760
And we can keep that process-- again,
stretching the analogy-- ringing

00:28:24.760 --> 00:28:28.920
until directory services,
the process,

00:28:28.920 --> 00:28:33.160
comes online and picks up the
phone and starts answering.

00:28:33.160 --> 00:28:34.460
This is very powerful.

00:28:34.460 --> 00:28:37.760
This is exactly what allows
us to have a very asynchronous

00:28:37.760 --> 00:28:42.690
boot up and to be able to launch
things in a pay-as-you-go manner.

00:28:44.760 --> 00:28:46.200
So the property list.

00:28:46.200 --> 00:28:47.980
What are we promising you guys?

00:28:47.980 --> 00:28:49.690
Again, API contracts.

00:28:49.710 --> 00:28:51.880
We need to make promises to you.

00:28:51.880 --> 00:28:54.680
Well, if you use IPC,
you're writing a framework,

00:28:54.680 --> 00:28:56.380
you're writing the
backend to a framework,

00:28:56.380 --> 00:29:00.370
we're going to have
race-free IPC handle setup.

00:29:00.730 --> 00:29:02.150
And how do we do that?

00:29:02.160 --> 00:29:07.700
Well, we read all of the property
lists before we run any program.

00:29:07.700 --> 00:29:12.400
We're populating that directory
of possible IPC channels.

00:29:12.400 --> 00:29:15.160
This is true for per session.

00:29:15.300 --> 00:29:42.300
( Transcript missing )

00:29:43.730 --> 00:29:44.440
Wait a sec.

00:29:44.440 --> 00:29:45.950
What are we not promising you?

00:29:45.990 --> 00:29:48.030
What's the other end of the equation?

00:29:48.050 --> 00:29:51.480
Well, no network interfaces have
been found or configured.

00:29:51.520 --> 00:29:54.990
No auxiliary file systems
have been mounted.

00:29:55.860 --> 00:29:59.000
Not all hardware has been discovered yet.

00:29:59.000 --> 00:30:03.460
In fact, we're basically promising
that any detail about the

00:30:03.510 --> 00:30:06.260
configuration beyond IPC is done.

00:30:06.260 --> 00:30:09.750
But if you're using the
frameworks as an application,

00:30:09.760 --> 00:30:10.750
you'll be OK.

00:30:10.750 --> 00:30:12.880
And this applies to everyone.

00:30:14.100 --> 00:30:16.480
We would really appreciate it,
both inside of Apple and

00:30:16.520 --> 00:30:18.990
outside of Apple,
if you just collectively,

00:30:18.990 --> 00:30:22.550
if we could all make fewer assumptions
about the state of the system and

00:30:22.550 --> 00:30:24.670
use the callbacks from the framework.

00:30:25.350 --> 00:30:26.450
All right.

00:30:26.470 --> 00:30:29.430
Let's say you're writing
a backend to a framework.

00:30:29.480 --> 00:30:31.950
What do you got to do?

00:30:31.950 --> 00:30:31.950
You're going to

00:30:32.470 --> 00:30:35.560
We have some simple APIs.

00:30:35.560 --> 00:30:39.180
They're boxed objects in an
object-oriented terminology.

00:30:39.180 --> 00:30:40.720
But they're really, really simple.

00:30:40.720 --> 00:30:43.840
And their whole purpose is inter-process
communication with launchd.

00:30:43.890 --> 00:30:45.640
Here's a simple example.

00:30:45.640 --> 00:30:49.010
We have a boxing of a string,
in this case, hello world.

00:30:49.020 --> 00:30:50.640
It returns temp.

00:30:50.640 --> 00:30:54.470
And we can unbox it
with the basic getter.

00:30:55.260 --> 00:30:59.000
Well,
we've been talking about IPC for a while.

00:30:59.020 --> 00:31:01.030
How does that all work?

00:31:01.060 --> 00:31:04.810
Well, you've got to get the IPC handles
from launchd before you can

00:31:04.810 --> 00:31:07.120
start talking to your customers.

00:31:07.190 --> 00:31:08.540
How do we do that?

00:31:08.580 --> 00:31:12.540
Well, today,
you create a new string with a

00:31:12.570 --> 00:31:17.040
known constant called checkin,
and you send that via one API.

00:31:17.040 --> 00:31:22.270
It allows you to send an object graph
to launchd and get an object graph back.

00:31:22.970 --> 00:31:26.750
If it returns null,
there was some kind of problem

00:31:26.770 --> 00:31:30.950
in the IPC at a very low level,
it's an error.

00:31:31.210 --> 00:31:34.200
There is also secondary failures
that need to be checked.

00:31:34.200 --> 00:31:37.600
You might be able to talk to launchd,
but the request that was made

00:31:37.600 --> 00:31:41.200
was somehow interpreted and
possibly rejected by launchd.

00:31:41.200 --> 00:31:44.160
And the way we do this is
by checking the type of the

00:31:44.330 --> 00:31:46.190
response via the get type API.

00:31:46.220 --> 00:31:49.000
If it's error no,
we can extract the error

00:31:49.000 --> 00:31:53.340
no and then print out why
launchd rejected the request.

00:31:53.480 --> 00:31:56.400
Otherwise,
things are probably moving along.

00:31:56.400 --> 00:31:59.960
What do we need to do next
if we're writing a backend?

00:32:00.020 --> 00:32:02.610
Well, we need to iterate the results.

00:32:02.720 --> 00:32:24.260
: This is an advisory idle timeout
to help consume less resources.

00:32:24.260 --> 00:32:24.260
You obviously don't have
to pay attention to it.

00:32:24.260 --> 00:32:24.260
And if you're writing
a program that's busy,

00:32:24.260 --> 00:32:24.260
you don't obviously have to exit.

00:32:24.260 --> 00:32:24.260
You're busy.

00:32:24.260 --> 00:32:24.260
But we'd like to see everybody
inside and outside idle exit.

00:32:24.260 --> 00:32:24.260
And this is a hint about when to do it.

00:32:24.480 --> 00:32:27.250
You can also iterate the Mach services
that were provided to your job

00:32:27.250 --> 00:32:29.200
and define in the property list.

00:32:29.200 --> 00:32:31.630
You can iterate the sockets.

00:32:31.630 --> 00:32:35.200
And you can do this by first
extracting the well-known keys

00:32:35.200 --> 00:32:36.620
using a dictionary lookup.

00:32:36.690 --> 00:32:40.830
And then you can iterate the
results of that dictionary

00:32:40.870 --> 00:32:43.460
fetch via the dict iterate call.

00:32:43.460 --> 00:32:47.160
And the next slide will demonstrate
what that callback looks like.

00:32:47.160 --> 00:32:48.700
It's real simple.

00:32:48.700 --> 00:32:51.960
Key, value, a cookie,
or a reference constant,

00:32:51.960 --> 00:32:54.380
whatever you would like to call it.

00:32:54.400 --> 00:32:58.380
that'll help you iterate the results.

00:32:59.550 --> 00:33:01.790
Now if you're a system administrator
or just a programmer trying

00:33:01.790 --> 00:33:07.270
to figure out what's going on,
you can use the launchd tl command

00:33:07.280 --> 00:33:09.730
to talk to launchd from the shell.

00:33:12.250 --> 00:33:14.060
It has many available subcommands.

00:33:14.060 --> 00:33:15.950
There are a few listed here.

00:33:15.970 --> 00:33:16.960
We have list.

00:33:16.980 --> 00:33:19.790
It'll list all the programs
loaded into launchd.

00:33:19.820 --> 00:33:23.690
And in fact, it can pass the label,
again, the unique identifier,

00:33:23.690 --> 00:33:27.110
as an argument to list,
and that'll tell you more information

00:33:27.110 --> 00:33:29.280
about the job loaded into launchd.

00:33:29.480 --> 00:33:32.760
You can also load and
unload a property list.

00:33:32.760 --> 00:33:36.320
And those commands also allow
you to tweak whether or not it's

00:33:36.320 --> 00:33:38.290
disabled on a permanent basis.

00:33:40.130 --> 00:33:42.200
And should you need to debug
what's going on in the system,

00:33:42.200 --> 00:33:45.220
you can say log space level space debug.

00:33:45.220 --> 00:33:48.410
And that'll crank up
the output of launchd.

00:33:48.430 --> 00:33:52.140
You will need to, of course,
adjust your syslog configuration

00:33:52.140 --> 00:33:54.160
to actually have those
messages go somewhere,

00:33:54.160 --> 00:33:56.230
but that's covered in another talk.

00:33:57.760 --> 00:33:59.250
You can also manually kickstart a job.

00:33:59.250 --> 00:34:01.700
You can stop a job.

00:34:01.840 --> 00:34:03.240
And all that does is send a SIGTERM.

00:34:03.240 --> 00:34:06.060
But again,
going back to the label analogy,

00:34:06.100 --> 00:34:08.980
launchd keeps track of the current PID,
and it will send it to

00:34:08.980 --> 00:34:10.240
the correct process.

00:34:10.240 --> 00:34:15.040
So you don't need to worry about
any race between your typing of PS,

00:34:15.040 --> 00:34:18.240
and if it dies and restarts
and gets a new PID.

00:34:18.670 --> 00:34:20.920
Finally, we have export and help.

00:34:20.940 --> 00:34:25.270
Export extracts all the environment
variables out of launchd that

00:34:25.270 --> 00:34:27.190
can be useful for debugging.

00:34:27.230 --> 00:34:30.630
And help will list more
subcommands and how to use them.

00:34:31.880 --> 00:34:34.000
So what's new in Leopard?

00:34:34.010 --> 00:34:35.830
Well, we've added Mach IPC support.

00:34:35.880 --> 00:34:38.840
This may not affect most of you,
but it affects a lot of

00:34:38.840 --> 00:34:40.580
what Apple's implemented.

00:34:40.580 --> 00:34:42.810
If should you choose to use it,
it's real simple.

00:34:42.840 --> 00:34:46.320
You can add the dictionary
as we iterated before.

00:34:46.740 --> 00:34:47.940
We've also added agents.

00:34:47.960 --> 00:34:50.400
That's both the per user and per session.

00:34:50.410 --> 00:34:53.700
If you look on Leopard right now,
just in the system library launch agents,

00:34:53.700 --> 00:34:58.880
you'll see several dozen adoptions
of that technology to provide

00:34:58.880 --> 00:35:01.640
many services on Mac OS X.

00:35:01.660 --> 00:35:05.190
We've also-- and this is, I think,
kind of fun--

00:35:06.620 --> 00:35:10.590
At a conditional keepalive support,
and this is logically ORed.

00:35:10.620 --> 00:35:13.600
So what does that mean?

00:35:13.600 --> 00:35:16.590
Instead of saying keepalive true,
like keep this program

00:35:16.590 --> 00:35:18.640
running all the time,
you can make it conditional.

00:35:18.640 --> 00:35:21.960
The first example, successful exit.

00:35:21.960 --> 00:35:25.460
Let's say you want to run a program,
and as long as it fails,

00:35:25.460 --> 00:35:27.430
you want launchd to restart it.

00:35:27.430 --> 00:35:30.150
But the minute,
or the first time it actually succeeds,

00:35:30.160 --> 00:35:32.530
you want launchd to give
up and just walk away.

00:35:32.530 --> 00:35:34.060
Well, you can do that now.

00:35:34.060 --> 00:35:36.240
You can say successful exit, false.

00:35:36.600 --> 00:35:38.840
That's what launchd does.

00:35:38.850 --> 00:35:40.590
You could actually do the inverse, too.

00:35:40.600 --> 00:35:43.600
Maybe you want the program
running as long as it exits zero,

00:35:43.600 --> 00:35:46.080
which is traditionally
considered success.

00:35:46.080 --> 00:35:48.710
Well, just set it to true.

00:35:49.150 --> 00:35:52.450
Now, doing the logical OR,
the network state can

00:35:52.510 --> 00:35:54.140
be paid attention to.

00:35:54.150 --> 00:35:55.600
Network state's ambiguous.

00:35:55.610 --> 00:35:59.440
It just means that we plausibly might
be able to talk to another machine.

00:35:59.470 --> 00:36:00.650
No guarantees.

00:36:00.660 --> 00:36:07.630
But if you feel that your software is
not very useful unless that is true,

00:36:07.630 --> 00:36:12.200
you can express that now
in your property list.

00:36:12.200 --> 00:36:12.200
And then when the machine boots up, or

00:36:12.410 --> 00:36:16.740
Whatever the case may be,
launchd won't start the process

00:36:16.770 --> 00:36:18.840
until we sniff out a network.

00:36:18.870 --> 00:36:22.230
Again, oring in the next possible state,
we have pass state.

00:36:22.240 --> 00:36:25.260
There's already several projects at
Apple that have adopted this to only

00:36:25.260 --> 00:36:26.900
run their programs when they're needed.

00:36:26.900 --> 00:36:29.630
And a popular example
is a configuration file.

00:36:29.630 --> 00:36:33.100
So what we can do is say, well,
this program isn't needed unless

00:36:33.100 --> 00:36:35.240
the user's actually configured it.

00:36:35.240 --> 00:36:39.910
Well, a great way to express that is say,
keep this program alive as long

00:36:39.910 --> 00:36:42.360
as the configuration file exists.

00:36:42.400 --> 00:36:43.870
And this is how we express it.

00:36:43.870 --> 00:36:47.100
You say pass state, it's a dictionary,
and then you can have as many

00:36:47.100 --> 00:36:48.580
paths as you want to monitor.

00:36:48.580 --> 00:36:50.450
Again, they're all logically ORed.

00:36:50.460 --> 00:36:53.950
You can do the existence of a path,
you can do the non-existence of a path,

00:36:53.950 --> 00:36:56.740
whatever makes more sense
for your application.

00:36:58.790 --> 00:37:04.740
Once again, all these top level keys,
successful exit, network state,

00:37:04.740 --> 00:37:06.700
and pass state are logically ORed.

00:37:06.700 --> 00:37:08.680
So keep that in mind.

00:37:09.940 --> 00:37:15.540
So just to rehash our goals,
we would like to see everybody

00:37:15.540 --> 00:37:20.260
recover for more hours and
monitor for more events and

00:37:20.470 --> 00:37:21.980
Pay attention to when
things happen around you,

00:37:21.980 --> 00:37:26.640
be it the devices you need,
or the networks you need, or disks.

00:37:26.680 --> 00:37:27.580
We have the mechanisms.

00:37:27.580 --> 00:37:29.290
You should use it.

00:37:29.320 --> 00:37:30.340
We have our frameworks.

00:37:30.340 --> 00:37:32.300
We can write our own.

00:37:32.890 --> 00:37:36.390
You can use launchd to launch on demand,
help save resources

00:37:36.390 --> 00:37:38.230
for everybody involved.

00:37:38.530 --> 00:37:43.380
And should you be writing a framework,
please use launchd to help your backend

00:37:43.380 --> 00:37:46.990
and your framework coordinate and
find each other in a race-free way.

00:37:47.000 --> 00:37:51.290
And again,
to buy off on the pay-as-you-go model.

00:37:52.040 --> 00:37:54.230
So I want to give some demonstrations.

00:37:54.240 --> 00:37:56.900
If we could switch to
the demo machine one,

00:37:56.910 --> 00:38:01.770
I'd like to show two changes
to basic Unix technologies that

00:38:01.770 --> 00:38:03.570
we've made launch on demand.

00:38:03.580 --> 00:38:10.920
So SSH has its own public/private key
cryptography to simplify authentication.

00:38:10.920 --> 00:38:15.030
And I'm going to create a key right now.

00:38:17.160 --> 00:38:18.520
So we have a key.

00:38:18.550 --> 00:38:21.300
And it has a program to help
cache that key so we don't

00:38:21.310 --> 00:38:23.100
constantly have to re-authenticate.

00:38:23.130 --> 00:38:25.480
That's the SSH agent.

00:38:26.100 --> 00:38:32.580
And normally what a user would have to
do is say something like eval ssh agent,

00:38:32.580 --> 00:38:35.620
and it would say this,
and this is how you would start it.

00:38:35.620 --> 00:38:36.420
Well, that's annoying.

00:38:36.420 --> 00:38:37.630
Why should I always have to start it?

00:38:37.640 --> 00:38:40.140
Why can't the computer do this for me?

00:38:40.140 --> 00:38:45.770
And well, we can do that.

00:38:46.720 --> 00:38:52.040
What we did in Mac OS X is we
made SSH agent launch on demand.

00:38:52.040 --> 00:38:55.040
So if we actually look,
the agent isn't running.

00:38:55.040 --> 00:39:00.980
But if we look in launchd with list,
and I'm going to grep

00:39:00.980 --> 00:39:02.630
here to sort it out.

00:39:02.790 --> 00:39:05.500
We have the SSH launching on demand.

00:39:05.520 --> 00:39:07.700
And this first column is the PID,
and it's not running.

00:39:07.700 --> 00:39:15.650
But just by-- if we say echo ssh ossock,
we see that it's actually

00:39:15.700 --> 00:39:17.700
ready to be talked to.

00:39:17.700 --> 00:39:21.690
So we can type ssh add to
add that key we just created.

00:39:22.220 --> 00:39:28.690
And now, when we do launchctl list,
we see that it's PID 160,

00:39:28.690 --> 00:39:31.610
which if we had looked
at the PID of SSHAd,

00:39:31.660 --> 00:39:34.100
that was probably 159.

00:39:35.150 --> 00:39:40.280
And now we can kill 160 and say, oops,
it died.

00:39:40.280 --> 00:39:42.140
Launchd has noticed.

00:39:42.140 --> 00:39:45.440
This was actually the signal,
the exit code.

00:39:45.440 --> 00:39:47.500
So it exited with two.

00:39:47.500 --> 00:39:50.840
But we can add it again.

00:39:51.600 --> 00:39:53.140
There it goes.

00:39:53.140 --> 00:39:57.760
But one other thing to say
about this is this SSH agent,

00:39:57.760 --> 00:40:01.100
the way it's configured,
can be accessed by all GUI apps.

00:40:01.100 --> 00:40:05.850
So what that means is things like Xcode,
when it runs SVN and SVN tries to

00:40:05.850 --> 00:40:11.160
use SSH to talk to your server,
that SSH can talk to your agent.

00:40:11.160 --> 00:40:15.680
Because the SSH agent was configured
with all the other launchd jobs,

00:40:15.680 --> 00:40:19.500
and that means that every launchd
job can find that SSH agent,

00:40:19.500 --> 00:40:22.970
which was really complicated and
really hard to set up right in previous

00:40:22.970 --> 00:40:25.320
versions of the operating system.

00:40:26.110 --> 00:40:29.890
So another example of launch on
demand that we've done in Leopard

00:40:29.920 --> 00:40:32.280
is we've made X11 launch on demand.

00:40:32.310 --> 00:40:35.150
What that means is you don't need to,
as the user,

00:40:35.160 --> 00:40:40.070
either double click X11.app or
somehow ensure that it's running.

00:40:40.080 --> 00:40:42.580
You can just say, Xterm.

00:40:42.630 --> 00:40:45.040
And if you watch the doc,

00:40:45.240 --> 00:40:46.160
There it goes.

00:40:46.160 --> 00:40:47.520
It's launched.

00:40:47.530 --> 00:40:49.560
And again, it's done via the same way.

00:40:49.560 --> 00:40:53.000
We've modified it just a
little bit and told launchd

00:40:53.000 --> 00:40:54.520
about it with a property list.

00:40:54.530 --> 00:41:00.500
And now any program that uses the X11
library or framework will automatically

00:41:00.500 --> 00:41:02.600
get the server run if they need it.

00:41:04.960 --> 00:41:10.580
To give more examples of
what can be done-- well,

00:41:10.620 --> 00:41:13.790
now we killed the server
and Xterm got cranky.

00:41:14.010 --> 00:41:17.300
To give more examples of launchd
and what can be done either as a

00:41:17.310 --> 00:41:21.320
system administrator or a developer,
let's say list.

00:41:21.320 --> 00:41:26.150
This is listing all the
agents on the system.

00:41:26.350 --> 00:41:31.260
Any,
so a lot of examples are all right here.

00:41:31.290 --> 00:41:34.140
We have things like Spotlight.

00:41:34.140 --> 00:41:37.800
That's this menu right here.

00:41:37.810 --> 00:41:37.810
Or,

00:41:38.000 --> 00:41:39.340
What's another good example?

00:41:39.340 --> 00:41:41.840
The pasteboard for when
you do copy and paste.

00:41:41.860 --> 00:41:43.800
But notice how many
programs aren't running.

00:41:43.860 --> 00:41:48.000
This is what Apple is using to help
save resources for all your users.

00:41:48.060 --> 00:41:51.000
This is that quick look process
that you saw demoed in the keynote.

00:41:51.000 --> 00:41:57.620
If I were to start browsing via the
finder and go to quick look mode,

00:41:57.620 --> 00:42:02.190
it's do launchd to list again.

00:42:03.760 --> 00:42:05.760
Well,
I need to get it to render something.

00:42:05.760 --> 00:42:10.800
That was probably a generic icon.

00:42:10.800 --> 00:42:10.800
But this quick look--

00:42:11.510 --> 00:42:13.540
Oh, space.

00:42:13.540 --> 00:42:14.180
Oh, it's an alias.

00:42:14.180 --> 00:42:19.080
It's on-- it should have--
had I found a document,

00:42:19.080 --> 00:42:20.330
actually--

00:42:22.300 --> 00:42:24.000
Oh, well.

00:42:24.000 --> 00:42:25.760
You would have seen Quick Look running.

00:42:25.760 --> 00:42:31.350
And to give you a better example
of how this can be used to debug,

00:42:31.650 --> 00:42:37.900
Let's see what com.apple.quicklook
is configured to run as.

00:42:37.920 --> 00:42:41.920
Well,
we can see their program is right here.

00:42:41.920 --> 00:42:43.880
We can see that they've
been this Mach service,

00:42:43.880 --> 00:42:45.840
and that's what would have
launched it on demand,

00:42:45.840 --> 00:42:47.840
had I found a document to render.

00:42:47.840 --> 00:42:53.840
And it has some advisory
exit time out of zero.

00:42:53.850 --> 00:42:56.060
It's on demand is true,
and it only wants to

00:42:56.060 --> 00:42:59.690
load in GUI sessions,
because that's only where it makes sense.

00:43:00.280 --> 00:43:03.940
Well, you can use other examples too,
like, well, what are all the environment

00:43:03.940 --> 00:43:05.080
variables in launchd?

00:43:05.080 --> 00:43:06.040
Here they are.

00:43:06.110 --> 00:43:09.730
Here's that SSH OSOC that
makes that possible.

00:43:10.030 --> 00:43:13.860
This is what makes the launch
and demand X11 possible.

00:43:13.860 --> 00:43:18.190
And here's some other basic environment
variables that users expect.

00:43:19.680 --> 00:43:25.340
You can also-- let's give an
example of unloading something.

00:43:25.340 --> 00:43:33.730
So you can say, unload system library
launchagents com.apple.spotlight.

00:43:33.740 --> 00:43:37.030
So what this is going to
do is unload spotlight from

00:43:37.040 --> 00:43:38.720
the current running session.

00:43:38.720 --> 00:43:41.200
And what you're going to notice
right up here in the menu

00:43:41.200 --> 00:43:44.860
is this is going to go away,
because that's what's drawing that.

00:43:44.900 --> 00:43:46.790
But we can load it back.

00:43:48.640 --> 00:43:51.940
And I'm going to do something
here to make sure it works right.

00:43:51.940 --> 00:43:54.400
So we're only interested in Aqua jobs.

00:43:54.400 --> 00:43:56.200
And this is the job we're trying to load.

00:43:56.200 --> 00:43:57.750
Now it's back.

00:43:58.100 --> 00:44:00.980
So let's say if you're
developing that program,

00:44:00.980 --> 00:44:04.080
you could then maybe unload it,
modify the plist,

00:44:04.130 --> 00:44:07.860
add an environment variable,
and then load it back to get maybe malloc

00:44:07.860 --> 00:44:12.280
debugging or some other feature enabled.

00:44:12.280 --> 00:44:13.200
Now what else can we do?

00:44:13.200 --> 00:44:15.500
Let's see.

00:44:17.300 --> 00:44:21.780
We can start a job.

00:44:21.780 --> 00:44:22.660
That's real simple.

00:44:22.660 --> 00:44:25.750
That just kicks it off.

00:44:25.760 --> 00:44:27.300
I showed export.

00:44:27.300 --> 00:44:28.980
Oh, debugging.

00:44:28.980 --> 00:44:32.520
So let's say you need to debug launchd.

00:44:32.520 --> 00:44:38.090
What you can do, I'm going to demonstrate
syslog a little bit here.

00:44:43.810 --> 00:44:45.360
I forgot that we can't do that part.

00:44:45.360 --> 00:44:57.440
Well, what you would do is you can
say launchctl log level debug,

00:44:57.440 --> 00:44:58.860
and that engages it.

00:44:58.860 --> 00:45:02.880
You can verify by typing log,
and that shows you what's being logged.

00:45:02.880 --> 00:45:06.050
You can obviously go
back to log level notice,

00:45:06.060 --> 00:45:08.110
which is the default.

00:45:10.700 --> 00:45:15.810
But what you can do is crank it up to
debug and then tail the system log.

00:45:42.710 --> 00:45:42.710
And that's pretty verbose when enabled.

00:45:42.710 --> 00:45:42.710
You'll need to adjust your syslog.conf,
but it'll tell you everything you need.

00:45:42.710 --> 00:45:42.710
If you want a more granular level,
you can add debug true in your property

00:45:42.710 --> 00:45:42.710
list and just get debug output from
launchd when your launchd is working

00:45:42.710 --> 00:45:42.710
on behalf of your particular job.

00:45:42.710 --> 00:45:42.710
I think that's it for
what I want to demo.

00:45:42.710 --> 00:45:42.710
So if we go back to the slides, we can

00:45:44.400 --> 00:45:46.400
Go into more information.

00:45:46.400 --> 00:45:48.630
We have documentation and sample code.

00:45:48.640 --> 00:45:51.670
You can also go to the open
source website and get involved

00:45:51.680 --> 00:45:53.400
and ask questions there.
WEBVTT

00:00:13.099 --> 00:00:19.469
>> Hello, and welcome to Integrating iCal
Events and Tasks into Your Applications.

00:00:19.469 --> 00:00:20.199
I'm Scott Adler.

00:00:20.199 --> 00:00:25.039
I'm from the iCal engineering team, and today we're going
to show you all the ways that you can take advantage

00:00:25.039 --> 00:00:30.160
of the Calendar Store framework to
integrate events and tasks into your apps.

00:00:30.160 --> 00:00:33.700
So first we want you to say hello to iCal in Leopard.

00:00:33.700 --> 00:00:40.580
We are the iCal team, and we've made a lot of improvements
to iCal, just the screen itself is a little different,

00:00:40.579 --> 00:00:44.159
but we've added a lot of new features. One of the big things

00:00:44.159 --> 00:00:53.869
that you might have seen already is we have a new Inline
Inspector so your data is right there with your events.

00:00:53.869 --> 00:01:00.269
It comes up in different modes depending on whether
you're editing or not, and we also have new ability

00:01:00.270 --> 00:01:07.210
to contact servers so we have the iCal server built into
the Mac OS X server and you can get things like availability

00:01:07.209 --> 00:01:12.739
of other attendees to your meetings and scheduling
support. And there are many other new features in iCal

00:01:12.739 --> 00:01:18.789
but those are just a couple of them. But what we're
here to talk about today is what's behind iCal

00:01:18.790 --> 00:01:22.380
and that is the Calendar Store framework.

00:01:22.379 --> 00:01:30.109
So iCal is actually built on top of what comprises the
Calendar Store framework. But what we'd like to really talk

00:01:30.109 --> 00:01:35.370
about now is -- one second and my
slide will change, there we go --

00:01:35.370 --> 00:01:43.450
is other applications on the system that also use the
Calendar Store framework. So mail, you may have seen demos

00:01:43.450 --> 00:01:49.680
of mail doing things like notes and in your notes you
can create to-dos, and there's actually an Inspector

00:01:49.680 --> 00:01:56.320
for those to-dos. And that all is built
using the Calendar Store framework.

00:01:56.319 --> 00:01:59.149
Now there's some other things in
mail you might not have seen yet.

00:01:59.150 --> 00:02:05.980
You can actually find dates and times of events and things
in your mail messages and automatically create things

00:02:05.980 --> 00:02:09.080
that go right into iCal that's also
using the Calendar Store framework.

00:02:09.080 --> 00:02:12.040
You may have seen the iCal widget.

00:02:12.039 --> 00:02:17.889
It's one of the default widgets that comes up on your
screen when you bring up Dashboard and, if you click on it,

00:02:17.889 --> 00:02:24.979
you get your agenda for today and that is
all done using the Calendar Store framework.

00:02:24.979 --> 00:02:29.849
So the real question is why should you use Calendar Store?

00:02:29.849 --> 00:02:34.979
Well, we have a couple different answers for you.
And the first one is probably the most important

00:02:34.979 --> 00:02:39.000
and that's we want to do all the heavy lifting for you.

00:02:39.000 --> 00:02:43.759
You don't really want to have to deal with
things like complex recurrence patterns.

00:02:43.759 --> 00:02:48.389
If you're getting today's agenda, you don't want to
have to go through and figure out is today election day,

00:02:48.389 --> 00:02:52.919
is it the second day in November
or, you know, is this the day --

00:02:52.919 --> 00:02:55.399
or when is Thanksgiving and all those kinds of things.

00:02:55.400 --> 00:03:00.300
You don't want to have to do all those complex
recurrence expansions that can be very complicated logic.

00:03:00.300 --> 00:03:05.590
You'll see more about recurrences later in the talk,
but if all you care about is one range of time,

00:03:05.590 --> 00:03:12.219
we'll figure out what the occurrences for those events
are on that day or on that range of days and you don't have

00:03:12.219 --> 00:03:15.699
to worry about what's going on behind the scenes.

00:03:15.699 --> 00:03:20.199
We also take care of all the persistence and
all the fast queries that you want to do.

00:03:20.199 --> 00:03:24.979
So we do this by using Core Data behind
the scenes and you just create predicates

00:03:24.979 --> 00:03:28.359
and queries and we take care of it all for you.

00:03:28.360 --> 00:03:33.580
You get all your results back fast, and also we take care
of all the persistence of laying everything down on disk

00:03:33.580 --> 00:03:39.969
for you, you don't have to worry about any of that. And also
in getting that you automatically get Spotlight indexing.

00:03:39.969 --> 00:03:44.080
So, if your events go into the Calendar Store,
it'll automatically be indexed by Spotlight,

00:03:44.080 --> 00:03:48.440
you'll be able to get all those great
features that Spotlight gives you.

00:03:48.439 --> 00:03:53.939
So another reason to use Calendar Store is
you want to help your users get organized.

00:03:53.939 --> 00:04:00.469
Organized users are -- are much more productive and they
want to be organized and you want to help them do that.

00:04:00.469 --> 00:04:05.349
So how can you do that, one is use system-wide alarms.

00:04:05.349 --> 00:04:10.930
You put alarms into your events, into your tasks,
and they'll come up in the system-wide alarm service,

00:04:10.930 --> 00:04:13.400
so your app doesn't even have to be running.

00:04:13.400 --> 00:04:18.889
Let's say you have a list of tasks, they have due dates,
you throw alarms in there, they close your application.

00:04:18.889 --> 00:04:22.430
Two days later when their task is --
has the alarm that comes up that has

00:04:22.430 --> 00:04:24.720
to remind them, it will automatically happen.

00:04:24.720 --> 00:04:29.100
You don't have to worry that they
haven't run your app in a couple of days.

00:04:29.100 --> 00:04:33.470
So integrating your application into
their lives, what we mean here is a lot

00:04:33.470 --> 00:04:38.080
of organized users will have what they need
to do that day, what events are coming up.

00:04:38.079 --> 00:04:39.120
They might be using iCal.

00:04:39.120 --> 00:04:44.300
They might be using some other utility that another
developer here in the audience has written to look

00:04:44.300 --> 00:04:49.310
at what they're doing that day or that week, and
you want your application to be right there up there

00:04:49.310 --> 00:04:53.970
with everyone else saying here's what you need to do
today, here are events you did, if they need to look back

00:04:53.970 --> 00:04:58.830
at what they did last week. Say you're a billing
application and you want to see when you billed people

00:04:58.829 --> 00:05:04.469
for hours you were working, your data will be
right there along with everyone else's data.

00:05:04.470 --> 00:05:11.840
And also Calendar data is everywhere, so you might not
realize that your application has calendar-specific data,

00:05:11.839 --> 00:05:14.529
but just the fact that they're using your application

00:05:14.529 --> 00:05:18.219
at a certain time might be something
that you want to keep track of.

00:05:18.220 --> 00:05:23.290
Just the fact that someone in a chat message
said, "I want to go to a baseball game on Friday,"

00:05:23.290 --> 00:05:24.710
maybe there's something you can keep track of.

00:05:24.709 --> 00:05:31.180
Even in this chat message up here you can -- you can
see that it has a time that I chatted with that person

00:05:31.180 --> 00:05:36.209
and I might want to keep track of I had
an event of chatting with that person,

00:05:36.209 --> 00:05:39.839
so I could create Event Data that
might be important to that user.

00:05:41.129 --> 00:05:48.790
So the final reason, of the ones I'm covering today, is
getting your data everywhere and there's a bunch of places

00:05:48.790 --> 00:05:55.090
that users like to see their calendar data and,
if you use your application and build it on top

00:05:55.089 --> 00:05:57.829
of Calendar Store, you'll already get into these places

00:05:57.829 --> 00:06:06.669
we talked about -- inside of iCal, inside of the widget, inside
of mail, you know, the tasks will end up inside of mail

00:06:06.670 --> 00:06:10.230
but there are other places that use
Calendar Store and use the calendar data

00:06:10.230 --> 00:06:12.980
on the system that you may not have even realized.

00:06:12.980 --> 00:06:17.870
iPhoto creates calendars and you can get
calendars ordered and shipped to you,

00:06:17.870 --> 00:06:21.949
and you can put events on those calendars
and, if your data is in Calendar Store,

00:06:21.949 --> 00:06:27.810
the user and iPhoto can decide, okay, am I
going to put that data onto my calendar?

00:06:27.810 --> 00:06:30.000
And then there's going to be many other applications.

00:06:30.000 --> 00:06:34.560
We have lots of developers here, hopefully, you're
going to be using Calendar Store and your data will end

00:06:34.560 --> 00:06:37.790
up in those applications too if it's applicable.

00:06:38.939 --> 00:06:45.319
So the other thing -- one of the other ways you
get your data in other places is using Sync.

00:06:45.319 --> 00:06:51.139
And so your local data on your machine, your data that's not
on a CalDAV server or not on the iMap server will be synched

00:06:51.139 --> 00:06:57.550
so that your data goes into Calendar Store, gets into
the Sync database, and then ends up on all the devices,

00:06:57.550 --> 00:07:02.199
and on .Mac, anything that can support calendaring
information. So your data without you having

00:07:02.199 --> 00:07:09.240
to do anything it goes right into sync and it will
end up on these devices so long as it's local data.

00:07:09.240 --> 00:07:11.810
So I also talked about CalDAV a couple times.

00:07:11.810 --> 00:07:16.769
So CalDAV is an open standard; it's
supported by lots of different organizations.

00:07:16.769 --> 00:07:24.779
We have a CalDAV client and a CalDAV server. The iCal
server is built on top of CalDAV and this is built

00:07:24.779 --> 00:07:30.379
for small business and enterprise scheduling
and group calendaring, and iCal now supports it.

00:07:30.379 --> 00:07:38.560
Well, your data, if you put it onto a CalDAV calendar, what
happens is your data goes from the Calendar Store into iCal,

00:07:38.560 --> 00:07:45.490
and then iCal communicates to the iCal
server and this arrow is a little misleading.

00:07:45.490 --> 00:07:49.569
You can see the arrow goes this way, well, the important
thing is that the arrow goes the other way too.

00:07:49.569 --> 00:07:55.939
So any new updates whether it's from a handheld
device talking through another CalDAV client getting

00:07:55.939 --> 00:08:02.360
onto the server will end up back into iCal and then your
application will get notified that data has changed.

00:08:02.360 --> 00:08:08.449
So you get to use CalDAV right our of the box. If you're
talking to a CalDAV calendar and putting your events

00:08:08.449 --> 00:08:12.990
on that calendar then all your data will
end up on the CalDAV server for free.

00:08:12.990 --> 00:08:18.379
There's nothing you have to do other
than just use the Calendar Store APIs.

00:08:18.379 --> 00:08:22.850
So I've talked about a lot of different
reasons to use the Calendar Store framework.

00:08:22.850 --> 00:08:25.100
There's lots of applications that support it.

00:08:25.100 --> 00:08:31.750
It's an easy way for you to get calendaring
data and through a very simple Objective-C API.

00:08:31.750 --> 00:08:37.559
And now to discuss the inner details of that
whole API, I'd like to bring up Matt DiMaggio.

00:08:37.559 --> 00:08:44.309
( Applause )

00:08:44.309 --> 00:08:45.779
>> Thank you, Scott.

00:08:47.590 --> 00:08:51.509
So just to give you guys an idea of what I'm
going to be talking about today here's a roadmap.

00:08:51.509 --> 00:08:54.460
I'm going to start by going over how to read calendar data.

00:08:54.460 --> 00:08:58.850
Then we'll look at the notification model,
and we'll move on to writing calendar data,

00:08:58.850 --> 00:09:02.310
and we'll finish with some common questions.

00:09:02.309 --> 00:09:06.299
And the way that I'm going to be discussing
reading calendar data is by exploring all

00:09:06.299 --> 00:09:09.469
of the various classes in the Calendar Store framework.

00:09:09.470 --> 00:09:15.960
I think a very easy way to understand these classes is
by start by looking at iCal, so this is Leopard iCal.

00:09:15.960 --> 00:09:21.310
And moving left to right you'll be able to see that a
lot of the things in UI correspond directly to things

00:09:21.309 --> 00:09:29.759
in the framework, so the list of calendars is going to
be represented as CalCalendars, events are CalEvents,

00:09:29.759 --> 00:09:36.759
tasks are cal -- I'm sorry, to-dos are CalTasks,
and just a small note on that wording there.

00:09:36.759 --> 00:09:40.370
What appears as a to-do in the UI is just a task in the API.

00:09:40.370 --> 00:09:47.220
It's the same object, we decided to use task just to actually
make the capitalization and the spacing a little easier

00:09:47.220 --> 00:09:51.660
but it's the same thing. And in addition to
those classes there are a few more classes

00:09:51.659 --> 00:09:54.600
that you can correlate the things inside the Inspector.

00:09:54.600 --> 00:10:00.820
You can see this is a reoccurring event, the recurrence
data will be encapsulated as a CalRecurrence rule,

00:10:00.820 --> 00:10:05.340
attendees are CalAttendees, and alarms are CalAlarms.

00:10:05.340 --> 00:10:12.090
So that's what the data looks like in iCal, and kind of
through the first part of this presentation we're going

00:10:12.090 --> 00:10:20.070
to show you how to go from here, where it is in iCal, to
here, where you can show the data in your application.

00:10:20.070 --> 00:10:23.680
And I'm going to start by discussing
actually the one class that wasn't

00:10:23.679 --> 00:10:27.919
in that screenshot of iCal, and that's CalCalendarStore.

00:10:27.919 --> 00:10:35.199
Now CalCalendarStore is really the superclass or
not superclass, but the main class of the framework.

00:10:35.200 --> 00:10:38.520
This is where it all starts, and this
is the class that you're going to use

00:10:38.519 --> 00:10:41.639
in order to get calendars, events, and tasks.

00:10:41.639 --> 00:10:46.220
It's very similar to the ABAddressBook class,
if you've used the AddressBook framework.

00:10:47.720 --> 00:10:50.720
And here's some methods on CalCalendarStore.

00:10:50.720 --> 00:10:52.700
As I mentioned it's similar to ABAddressBook.

00:10:52.700 --> 00:10:56.300
There's one kind of default or shared instance.

00:10:56.299 --> 00:11:00.809
In addition to that you can get an
array of all the users' calendars.

00:11:00.809 --> 00:11:05.309
You can get an array of selected events, and
you'll notice that that method takes a parameter.

00:11:05.309 --> 00:11:13.369
Now I'll go much further into detail about that, but for now
I'll just tell you that -- that parameter is a predicate,

00:11:13.370 --> 00:11:18.230
AddressBook framework uses AB search elements we
decide to use NSPredicate but it's the same idea.

00:11:18.230 --> 00:11:22.700
It'll tell us exactly which events you want, and
we'll pass you back an array with those events.

00:11:24.019 --> 00:11:28.139
And finally, a method to get tasks,
again, using NSPredicate.

00:11:30.700 --> 00:11:34.009
So as I discuss these classes I want
to show you kind of a data model

00:11:34.009 --> 00:11:38.350
of how these things fit together.
That's the CalCalendarStore class.

00:11:38.350 --> 00:11:40.430
The next class that I'll talk about is CalCalendar.

00:11:40.429 --> 00:11:47.229
As I said before that's one of the classes that you'll be
able to access directly through the CalCalendarStore class.

00:11:47.230 --> 00:11:54.659
Now CalCalendar has six properties. Just as I
kind of correlated things in the UI to classes

00:11:54.659 --> 00:11:59.079
in the framework, I'll correlate a lot of the
things in the UI to properties of CalCalendar.

00:11:59.080 --> 00:12:04.420
So what you see at the bottom there is a screenshot of
what comes up when you try to edit a CalCalendar in Leopard.

00:12:04.419 --> 00:12:09.819
There's a sheet, that sheet allows you
to change the title of the calendar.

00:12:09.820 --> 00:12:11.620
It's name.

00:12:11.620 --> 00:12:18.039
There's a color property, and there's
another string for the notes on a calendar.

00:12:19.159 --> 00:12:23.909
Now in addition to those properties, there are a few
more that don't correlate directly to things in the UI.

00:12:23.909 --> 00:12:29.219
We've got a type string that will be one of a
few statically declared types that we specify.

00:12:29.220 --> 00:12:35.700
You can see those in the documentation. That will be
things like a CalDAV calendar or a subscription calendar

00:12:35.700 --> 00:12:41.080
or just a plain old local calendar that's
what the user starts with by default.

00:12:41.080 --> 00:12:46.180
There's a bBoolean for whether or not the
calendar is editable and this refers not only

00:12:46.179 --> 00:12:49.009
to whether you can make changes
to the calendar through the API,

00:12:49.009 --> 00:12:53.730
but whether or not you can make changes
to the events or tasks on the calendar.

00:12:53.730 --> 00:12:59.379
On a subscription calendar, for instance, one that's
all the U.S. holidays, in iCal's UI you're not able

00:12:59.379 --> 00:13:01.830
to add or remove things from that calendar.

00:13:01.830 --> 00:13:10.240
The same thing is true in the API. And, finally, there's
a UID. This is just in case you need to store a reference

00:13:10.240 --> 00:13:14.950
to that CalCalendar later on, make
sure you have the right calendar.

00:13:17.899 --> 00:13:24.059
Looking back at the diagram we talked about CalCalendar;
next class I'm going to look at is CalEvents.

00:13:25.830 --> 00:13:30.790
A CalEvent is actually one of two
subclasses of CalCalendarItem.

00:13:30.789 --> 00:13:36.259
CalCalendarItem encapsulates all the things
that a CalEvent and a CalTask both have,

00:13:36.259 --> 00:13:45.899
all those properties. That includes things like the title,
the calendar that will be a CalCalendar, of course.

00:13:45.899 --> 00:13:53.579
CalCalendar items can have one or more alarms.
There will be an array of CalAlarms, URL,

00:13:53.580 --> 00:14:04.009
notes, and a date stamp for the last time that event or
task changed, and finally, a UID just like in CalCalendar.

00:14:06.320 --> 00:14:13.660
Now, in addition to those, CalEvent has properties of its
own. Events can have locations, a Boolean for whether

00:14:13.659 --> 00:14:19.329
or not it's an all-day event, start date, and end date, and,

00:14:19.330 --> 00:14:22.900
if it's a repeating event, it'll
also have a CalRecurrenceRule.

00:14:22.899 --> 00:14:31.919
If this is a one-time standalone event, then that field
will be nil. And finally, an array of CalAttendees.

00:14:34.750 --> 00:14:39.610
So I told you what CalEvents look like, but
I haven't told you how to get CalEvents yet.

00:14:39.610 --> 00:14:43.419
Well, I think it's a pretty simple
process. There's a few steps.

00:14:43.419 --> 00:14:45.969
What you're going to do is start by
getting the default Calendar Store.

00:14:45.970 --> 00:14:50.960
You're going to use that Calendar Store to create a
predicate and then you'll pass that predicate back

00:14:50.960 --> 00:14:54.230
to the Calendar Store where you'll get an array of events.

00:14:55.360 --> 00:15:00.230
So here's a call to get the default
Calendar Store. And this is a method

00:15:00.230 --> 00:15:07.340
that we haven't seen. What we have here is a class method on
CalCalendarStore that's going to return an NSPredicate.

00:15:07.340 --> 00:15:12.330
Here it's eventPredicateWithStartDate, endDate,
and calendars.

00:15:12.330 --> 00:15:17.580
What you'll do for this particular predicate generation
method is pass in the start date that the date range

00:15:17.580 --> 00:15:25.000
of events you want and the end date, and then the
list of calendars that you want to query events from.

00:15:25.000 --> 00:15:29.870
And in this example we're just passing the array of
calendars directly back so that will include events on any

00:15:29.870 --> 00:15:37.100
of the users' calendars. And finally, we call eventsWithPredicate
passing the predicate we just generated.

00:15:37.100 --> 00:15:42.389
And that will give you all the CalEvents that you requested.

00:15:42.389 --> 00:15:49.470
The last class that you access directly
from the CalCalendarStore class is CalTask.

00:15:51.529 --> 00:15:56.549
Now CalTask is the other subclass of CalCalendar item so
it's going to have all the same fields that CalEvent had,

00:15:56.549 --> 00:15:59.939
things like a name, notes, the CalCalendar and a UID.

00:15:59.940 --> 00:16:04.520
In addition to that it has some properties of its own.

00:16:04.519 --> 00:16:07.230
There's a Boolean for whether or
not the task has been completed.

00:16:07.230 --> 00:16:11.690
If it is completed, there will be a completion date.

00:16:11.690 --> 00:16:15.350
There will be a priority and that's just in your
enumerator type that's going to be something from zero

00:16:15.350 --> 00:16:20.560
to nine that's all CalPriority is. And finally,

00:16:20.559 --> 00:16:25.599
if the to-do or task has a due date
specified, there will be a dueDate property.

00:16:27.379 --> 00:16:32.360
So for events I showed you an example where we passed in
a start date and end date in a list of calendars in order

00:16:32.360 --> 00:16:34.789
to get the array of events that you wanted.

00:16:34.789 --> 00:16:36.289
For tasks it's a little bit different.

00:16:36.289 --> 00:16:40.279
We don't have a strict start date or end date per se.

00:16:40.279 --> 00:16:45.029
You're still going to use an array of calendars instead of
a start and end date you'll be able to key off of things

00:16:45.029 --> 00:16:49.149
like whether you want completed tasks, whether
you want tasks due before a certain day.

00:16:49.149 --> 00:16:54.860
And just to briefly show you the
predicates that you can use to generate --

00:16:54.860 --> 00:17:00.960
I'm sorry, the methods you can use to generate a
predicate to give you a list of tasks. But even better

00:17:00.960 --> 00:17:06.529
than showing you this code up on the stage or showing
you snippets is seeing a demo of how it all works.

00:17:06.529 --> 00:17:07.829
Matt Shepherd is going to give you a demo.

00:17:07.829 --> 00:17:09.980
( Applause )

00:17:09.980 --> 00:17:11.130
>> Thanks.

00:17:14.549 --> 00:17:25.579
Okay. So what we have here is -- what
we have here is the Checklist sample app,

00:17:25.579 --> 00:17:28.569
so I'll just give you a quick look at what this is.

00:17:28.569 --> 00:17:36.399
So it's just a list of tasks. These are
the same tasks that you would see in iCal.

00:17:36.400 --> 00:17:45.590
So, now all that's really in here is a single
controller -- start with the interface --

00:17:45.589 --> 00:17:53.609
now what's in this class is basically a reference
to a tableView and a cached array of tasks.

00:17:53.609 --> 00:17:59.189
And this Controller will also implement
the DataSource for this table.

00:17:59.190 --> 00:18:08.039
So take a look at the implementation on awakeFromNib
what we do is we go ahead and grab an instance

00:18:08.039 --> 00:18:17.970
of the CalCalendarStore, from that CalCalendarStore we
get an array of calendars, and then we ask for a predicate

00:18:17.970 --> 00:18:20.680
for all the tasks in that array of calendars.

00:18:20.680 --> 00:18:31.340
So we're going to load everything, every task in iCal,
by calling tasks with predicates. And the important thing

00:18:31.339 --> 00:18:39.759
that we're going to do in this implementation is we're
going to retain the array of tasks, and we're going to cache

00:18:39.759 --> 00:18:45.589
that in the Controller, and then, once we have that
array, we're going to tell the table to reload.

00:18:46.930 --> 00:18:55.779
Now this is a just a simple DataSource implementation so
from that cached array we know how many tasks there are,

00:18:55.779 --> 00:19:01.569
and then I've cheated a little bit
and I've named the table columns --

00:19:01.569 --> 00:19:08.139
the identifier of those is the same as the properties
on the tasks -- so in this case completed and title.

00:19:08.140 --> 00:19:17.990
So by doing that I can grab the value and then I
can sort based on the -- the various column names.

00:19:17.990 --> 00:19:25.150
So just by doing that I'm able to, you know,
populate the table and show you the same data

00:19:25.150 --> 00:19:28.509
that iCal sees. That's all there is to it.

00:19:28.509 --> 00:19:42.039
( Applause )

00:19:42.039 --> 00:19:46.509
>> So we've looked at three kind of primary
classes in the CalCalendarStore framework.

00:19:46.509 --> 00:19:54.259
The next class I'll review is CalAlarm, and this
is something that events or tasks could have.

00:19:54.259 --> 00:20:02.609
So CalAlarm has a few properties. The first property
is probably the most interesting. That's the action

00:20:02.609 --> 00:20:09.139
and that could be any sort of the -- any of a few
values depending on what the user selected in iCal.

00:20:09.140 --> 00:20:11.759
You can see there in the pop-up
that's what it looks like in iCal,

00:20:11.759 --> 00:20:15.609
and there's a statically declared string for each of those.

00:20:15.609 --> 00:20:18.819
After you've specified that the
alarm is a message with sound,

00:20:18.819 --> 00:20:22.250
there would also be a string for the name of the sound.

00:20:22.250 --> 00:20:28.190
If it's an email alarm, there will be a string
for the emailAddress, and, if it's an open file

00:20:28.190 --> 00:20:35.630
or a run script alarm, then you will be able to access
the file URL of the file that's being opened or run.

00:20:37.799 --> 00:20:42.430
In addition to those, all CalAlarms
will have one of two types of triggers.

00:20:42.430 --> 00:20:48.000
Now in this example the event is -- the alarm is
specified to fire five minutes before the event starts.

00:20:48.000 --> 00:20:53.490
We call that a relativeTrigger. The trigger
time of the alarm is specified in relation

00:20:53.490 --> 00:20:57.329
to the start time of the event or the due date of a to-do.

00:20:58.740 --> 00:21:03.079
The other possibility is that the trigger
is specified with an absolute date.

00:21:03.079 --> 00:21:07.099
User said they want the alarm to fire
exactly at a specific date and time,

00:21:07.099 --> 00:21:11.059
and in that case there would be an
absolute trigger which is an NSDate.

00:21:14.829 --> 00:21:17.309
The next class is CalAttendee.

00:21:19.109 --> 00:21:26.929
CalAttendee just has a few properties. There's a commonName
that will be the name of the attendee that shows up in iCal.

00:21:26.930 --> 00:21:33.910
There's an NSString for one of a few -- a few possibly -- a
few possible statuses for the attendee depending on whether

00:21:33.910 --> 00:21:39.000
or not they've responded to the
invitation and accepted or declined it.

00:21:39.000 --> 00:21:43.220
And there's an NSURL for the address of the attendee.

00:21:43.220 --> 00:21:50.460
Now in Tiger it was possible to invite attendees to an
event and the way that happened usually was you'd click send

00:21:50.460 --> 00:21:54.700
and it would send an email to them, but
it always required an email address.

00:21:54.700 --> 00:21:58.620
So in that type of event it's still
possible in Leopard, if you have an attendee

00:21:58.619 --> 00:22:02.739
like that, the address will be a mailto.

00:22:02.740 --> 00:22:07.079
In Leopard it's also possible to have
a meeting on a CalDAV server, and

00:22:07.079 --> 00:22:10.889
if the meeting is on a CalDAV server,
the server admin, or I guess,

00:22:10.890 --> 00:22:16.880
the server software could specify any
sort of URL as the address of an attendee.

00:22:16.880 --> 00:22:21.290
Now, if you actually go and try this on a few
servers you'll find that many times the address

00:22:21.289 --> 00:22:27.299
on a CalDAV server is also a mailto address, and I
believe that's what we do for Mac OS X server as well.

00:22:29.109 --> 00:22:34.339
And the final class in this data
model is CalRecurrenceRule.

00:22:34.339 --> 00:22:39.279
So this one is a little trickier.

00:22:39.279 --> 00:22:43.099
We think that CalRecurrenceRule will be most
useful to you as developers when you want

00:22:43.099 --> 00:22:47.199
to create an event that has a recurrence pattern.

00:22:47.200 --> 00:22:50.850
Say you want to create an event that happens every
two weeks or happens every Monday through Friday.

00:22:50.849 --> 00:22:54.589
In that case you'll create a CalRecurrenceRule
and you'll attach it

00:22:54.589 --> 00:22:58.429
to the event, and that's how you create
a repeating event.

00:22:58.430 --> 00:23:02.740
Now, if you're really only concerned about
showing repeating events in your UI --

00:23:02.740 --> 00:23:06.620
say you want to show the events for a week and you
want to make sure you that you show each instance

00:23:06.619 --> 00:23:10.669
of a repeating lunch meetin -- that's kind of what that
screen shot at the bottom is trying to capture --

00:23:10.670 --> 00:23:15.750
if that's all you want to do, you don't
need to be aware of CalRecurrenceRule.

00:23:15.750 --> 00:23:20.079
What'll happen is you'll request all the events
in a week, you'll get a start date and an end date,

00:23:20.079 --> 00:23:23.909
and then we'll create a CalEvent
for each one of those meetings.

00:23:23.910 --> 00:23:26.740
You don't need to be aware that the
CalRecurrenceRule is Monday through Friday.

00:23:26.740 --> 00:23:29.299
We do all that behind the scenes for you.

00:23:31.890 --> 00:23:38.150
Now, if you've played with iCal, you might be aware that
iCal let's you specify a kind of rich set of definitions

00:23:38.150 --> 00:23:42.680
of different recurrence patterns. Everything
from the simple like every day or every week

00:23:42.680 --> 00:23:49.690
to increasingly more complicated things, the first of every
month, the fourth Thursday of every November. And in order

00:23:49.690 --> 00:23:56.750
to give you the freedom to create all those
recurrence patterns, iCal uses a lot of different UI.

00:23:56.750 --> 00:24:01.319
It's either things for yearly recurrence
patterns, monthly recurrence patterns.

00:24:01.319 --> 00:24:10.470
It can get a little sticky so just as that's true
about the UI, we've created a lot of API to provide you

00:24:10.470 --> 00:24:13.700
with the same level of functionality in the framework.

00:24:13.700 --> 00:24:18.759
Now I could spend the next 20 or 30 minutes talking
about all these different types of constructors

00:24:18.759 --> 00:24:23.599
and how you specify a CalRecurrenceRule that
is the last Friday of every financial quarter,

00:24:23.599 --> 00:24:25.799
but instead I'll just refer you to the docs.

00:24:25.799 --> 00:24:26.889
It's very well commented.

00:24:26.890 --> 00:24:30.210
I think it's very -- it's pretty well
thought out and easy to understand.

00:24:30.210 --> 00:24:34.140
We really wanted to give you guys the same
function that's available in iCal, just turns

00:24:34.140 --> 00:24:37.870
out that it requires a lot of code
in order to get that done.

00:24:39.009 --> 00:24:43.650
So those are the classes in the framework.

00:24:43.650 --> 00:24:45.060
Now, let's look at the notification model.

00:24:45.059 --> 00:24:53.919
So at a very high level, the way this works is that the
user will make a change in iCal or another application.

00:24:53.920 --> 00:24:58.259
That change would be made through the Calendar Store
framework, and then your instance

00:24:58.259 --> 00:25:03.200
of the Calendar Store framework will send out a
notification if you signed up for notifications.

00:25:04.769 --> 00:25:08.000
Again, this is very similar to
the way AddressBook does things.

00:25:08.000 --> 00:25:13.569
One difference is that there are separate
notifications for calendars, events, and tasks.

00:25:13.569 --> 00:25:18.460
This is nice if you're only concerned about one of
those data types because if a user checks off a to-do

00:25:18.460 --> 00:25:24.240
and you're only showing event data, then
you won't get an unnecessary notification.

00:25:24.240 --> 00:25:29.410
The API also allows you to specify that you want to
listen for local notifications that would be changes made

00:25:29.410 --> 00:25:33.420
by your application or for changes made by any application.

00:25:35.460 --> 00:25:40.130
Once you get that notification, you have
a couple options on how to update your UI.

00:25:40.130 --> 00:25:47.220
You can either refresh the list of events or tasks you
got, either by creating the same predicate you had before

00:25:47.220 --> 00:25:53.680
or passing that predicate to the Calendar Store and getting
the updated list of events or tasks. And the other option is

00:25:53.680 --> 00:25:58.039
to dig into the userInfo dictionary
that's included in the notification

00:25:58.039 --> 00:26:04.119
and specifically update the one event
or task that changed based on its UID.

00:26:04.119 --> 00:26:10.219
So if you choose to do it this route, you're going
to want to be able to request a specific task

00:26:10.220 --> 00:26:13.730
from the CalCalendarStore, that's
what this method looks like.

00:26:13.730 --> 00:26:17.370
They say taskWithUID and you pass in the UID of the task.

00:26:17.369 --> 00:26:19.639
You'll get back the updated task.

00:26:21.589 --> 00:26:23.289
For events it's a little bit trickIer.

00:26:23.289 --> 00:26:29.639
You can see that the call we use includes not just
the UID but this other thing called occurrence.

00:26:29.640 --> 00:26:36.390
Now the story on that is that non-repeating events,
that's one-time events that are just scheduled once

00:26:36.390 --> 00:26:41.480
and don't repeat at all, they all
have their own truly unique UID.

00:26:41.480 --> 00:26:44.559
There's nothing else in the Calendar
Store framework that would provide you

00:26:44.559 --> 00:26:49.019
with that UID other than some very small random chance.

00:26:49.019 --> 00:26:59.059
Now repeating instances of a single event also have the
same UID and that's just the way the iCalendar spec was created.

00:26:59.059 --> 00:27:04.470
The way we differentiate between those instances
of the same event, the same repeating event,

00:27:04.470 --> 00:27:10.120
is to give them this thing called an occurrence value, and
so here, this lunch -- this repeating lunch event --

00:27:10.119 --> 00:27:17.529
all those have the same UID, they all have different
recurrence values. An occurrence is one more property

00:27:17.529 --> 00:27:19.210
on CalEvent.

00:27:19.210 --> 00:27:24.220
You'll note that it's an NSDate. That's just
because that's what the spec says it should be,

00:27:24.220 --> 00:27:30.309
the iCalendar spec. We really advise you guys to just treat that
as another part of the UID and really kind of keep the UID

00:27:30.309 --> 00:27:35.319
and the occurrence and use them both to get a
specific event from the Calendar Store framework.

00:27:36.609 --> 00:27:43.769
I'll move onto writing Calendar Data. And the set
of steps that you're going to use in order

00:27:43.769 --> 00:27:50.279
to make changes to user's calendar data or to add
an event or task of your own aren't all that different

00:27:50.279 --> 00:27:55.000
from when you were reading calendar data.
But instead of showing you sample code

00:27:55.000 --> 00:28:01.049
or showing you some method prototypes, Matt Shepherd is
going to come back up and give you guys a demo of how

00:28:01.049 --> 00:28:08.250
to use the writing API, as well as show you how you
can use event notification stuff to update your data.

00:28:14.309 --> 00:28:18.309
>> Okay. We're going to take that last
sample. I've added a couple of things

00:28:18.309 --> 00:28:22.940
to handle the notifications as well as writing.

00:28:22.940 --> 00:28:24.940
So we're still loading the same data.

00:28:24.940 --> 00:28:29.820
We're still using the same predicate, the one change at
the beginning here is that we're going to register it

00:28:29.819 --> 00:28:34.980
for the CalChange -- CalTasksChangedExternally
notification.

00:28:34.980 --> 00:28:42.000
The externally part means that you're not going
to receive your notifications from your own app.

00:28:42.000 --> 00:28:42.970
It's a different notification.

00:28:42.970 --> 00:28:52.220
You can get that if you want, but in this case not so much.
And in the dealloc we will remove ourselves as an observer.

00:28:52.220 --> 00:28:57.769
So how do we handle that? So as Matt said
you can handle this in two different ways.

00:28:57.769 --> 00:29:03.710
With this task changed method I can either
just reload all my data or I can sift

00:29:03.710 --> 00:29:07.950
through the userInfo and I can update my cache.

00:29:07.950 --> 00:29:16.049
So in this case we're going to sift through the userInfo,
so we're going to loop through all the deleted tasks

00:29:16.049 --> 00:29:20.250
which you can get by using this -- this constant.

00:29:20.250 --> 00:29:26.019
You can loop through and you can remove those
from your cache as we do here based on the UID.

00:29:26.019 --> 00:29:32.720
So you can do that, and then, when you go
through the updated tasks here, you can then --

00:29:32.720 --> 00:29:41.930
you can then replace the tasks that -- that have updated.
And you do that by checking the UID from the userInfo

00:29:41.930 --> 00:29:47.470
and then reloading that task using the taskWithUID
method and then going through and replacing that as well.

00:29:47.470 --> 00:29:54.529
And then in the last case that we deal with is a new
task which is signified by this inserted constant,

00:29:54.529 --> 00:30:00.839
and you can iterate through those and then you can also
load those using the taskWithUID and then you can add those

00:30:00.839 --> 00:30:07.809
to your tasks array. And then -- and then
you can reload the data in the table.

00:30:07.809 --> 00:30:17.220
So that's -- that's for notifications, but for -- for
writing we only have to add really one method down here

00:30:17.220 --> 00:30:23.160
which is the data source method for setting
a value based on an update to the table.

00:30:23.160 --> 00:30:30.060
So in this case, the only change we're going to make in our
app here is we're going to allow the user to set completed.

00:30:30.059 --> 00:30:34.759
So the TableColumn is identified as completed,
and so that when that changes, all we have

00:30:34.759 --> 00:30:39.390
to do is set the completedDate on
the task and then grab an instance

00:30:39.390 --> 00:30:44.920
of the Calendar Store, call saveTask, and handle an error.

00:30:44.920 --> 00:30:58.039
So, if we do that -- and I'll load this one up. So if I check
this off here, you see that it shows up in iCal, and as far

00:30:58.039 --> 00:31:07.099
as our notifications go, if I go and I create a new to-do
in iCal and save it -- it shows up in the Checklist.

00:31:07.099 --> 00:31:11.799
So there's not a lot of code here and yet we've
gotten all access to all the data in iCal,

00:31:11.799 --> 00:31:23.720
and we're able to make changes and the
notifications are handled in iCal for us, so --

00:31:23.720 --> 00:31:29.390
( Applause )

00:31:29.390 --> 00:31:35.470
>> So one final note on saving changes to events or on
saving changes is that for events it is slightly different

00:31:35.470 --> 00:31:42.250
than tasks, and for the same reason as before
because of these repeating tasks -- recurring tasks.

00:31:42.250 --> 00:31:47.720
You can see that the saveEvent method has
an additional parameter and that's the span --

00:31:47.720 --> 00:31:53.470
that will be a type CalSpan. This is
only meaningful for repeating events.

00:31:53.470 --> 00:31:58.500
If you're saving a change to a non-repeating event, then
it doesn't matter what value you pass in for the span.

00:31:58.500 --> 00:32:04.200
For a repeating event you'll want to
pass in one of these three values.

00:32:04.200 --> 00:32:09.250
The names kind of give away what they do. CalSpanThisEvent
means that the change you're saving should only apply

00:32:09.250 --> 00:32:16.150
to this event; CalSpanFutureEvents means it should
apply to future events; and CalSpanAllEvents means apply

00:32:16.150 --> 00:32:19.680
that change to all the events in the repeating pattern.

00:32:19.680 --> 00:32:23.910
If you've used iCal and had reoccurring events before,
this is very similar to the panel that comes up

00:32:23.910 --> 00:32:30.269
and asks you, do you want these changes to apply only
to this event or to all events or future events?

00:32:33.700 --> 00:32:38.950
So I'm going to end by going over some common
questions that people have about the Calendar Store API,

00:32:38.950 --> 00:32:44.360
and this probably isn't the first question you thought
to ask, but if you're going to be writing any data

00:32:44.359 --> 00:32:49.329
to the user's calendar it is a question that you'll
need to ask yourself and you'll need to answer.

00:32:49.329 --> 00:32:52.470
Should I create a Calendar for my app?

00:32:52.470 --> 00:32:58.269
Well, we believe that users already have their
calendar data organized how they want it organized.

00:32:58.269 --> 00:33:02.869
They've already picked out the colors and the
names of the calendars that they want to use,

00:33:02.869 --> 00:33:07.019
and so what we're telling you guys is that
you should ask the user what they want to do.

00:33:07.019 --> 00:33:12.129
You can see in the example there there's
an option to add it to a specific calendar.

00:33:12.130 --> 00:33:17.910
There's also an option to create the calendar specific
to your application if that's what they want to do.

00:33:20.539 --> 00:33:26.180
One other note about adding calendars to the
framework is that, if you're adding calendars,

00:33:26.180 --> 00:33:30.890
you can only add local calendars
to the user's Calendar Store.

00:33:30.890 --> 00:33:38.000
If you choose to save an event to a specific calendar,
the API does allow you to save events to CalDAV calendars.

00:33:39.859 --> 00:33:45.859
The next question, this is probably a little more
common is, how do I add my own custom data to iCal?

00:33:45.859 --> 00:33:48.039
Well, there are a few options.

00:33:48.039 --> 00:33:52.659
If you have some very basic data, it might be
appropriate to put that data in the URL field

00:33:52.660 --> 00:33:54.710
or the notes field of your event or task.

00:33:54.710 --> 00:33:59.180
Now there's a big caveat that goes along
with that, that if you put data there,

00:33:59.180 --> 00:34:04.299
then when the user launches iCal they'll see the data
that you've put in the URL field or in the notes field,

00:34:04.299 --> 00:34:10.029
and they'll be able to modify it and so you
can't count on that data always being the same.

00:34:10.030 --> 00:34:18.860
Another option is to store it yourself and then sync that
data up with the tasks or events in the API using UID

00:34:18.860 --> 00:34:22.250
or finally you can use the Sync Services API.

00:34:22.250 --> 00:34:25.539
Sync Services API has an iCal schema
which you can extend and add fields to.

00:34:25.539 --> 00:34:29.900
There are caveats that go along with that as well.

00:34:29.900 --> 00:34:35.760
If you choose to extend the iCal schema and put your
own data into these records using the Sync Services API,

00:34:35.760 --> 00:34:41.440
you will not be able to access that data from the
Calendar Store framework; those are new fields

00:34:41.440 --> 00:34:46.170
and the Calendar Store framework just doesn't
know anything about them. And really we advocate

00:34:46.170 --> 00:34:51.000
that people use either Calendar Store or
Sync Services, but not both.

00:34:51.000 --> 00:34:56.769
The reason is that it's very easy for your data
to get -- for lack of a better word, out of sync.

00:34:56.769 --> 00:35:05.269
And that dovetails very nicely into the next
question: Should I use Calendar Store or Sync Services?

00:35:05.269 --> 00:35:07.960
Well, we're really excited about
the Calendar Store framework.

00:35:07.960 --> 00:35:12.639
It's an easy Cocoa way to access your events and tasks, and
so, if you have already written the rest of your application

00:35:12.639 --> 00:35:15.989
in Cocoa, this should match really well with it.

00:35:15.989 --> 00:35:19.919
In addition to that, you will be able to access all
of iCal's data using the Calendar Store framework

00:35:19.920 --> 00:35:23.559
that includes mail, to-dos, CalDAV events.

00:35:23.559 --> 00:35:29.389
Those are records that don't get pushed down into
sync. And the Calendar Store framework also allows you

00:35:29.389 --> 00:35:35.019
to receive real-time notifications as
changes are made in iCal or another app.

00:35:35.019 --> 00:35:40.239
One really big win to using Sync Services is that
it does allow you specify arbitrary custom data

00:35:40.239 --> 00:35:44.979
and allows you to attach that data to events and tasks.

00:35:44.980 --> 00:35:49.010
Another advantage is that Sync Services
lets you determine what data has changed

00:35:49.010 --> 00:35:51.410
since the last time your app is launched.

00:35:52.659 --> 00:35:57.629
So in closing we're really excited about this framework.

00:35:57.630 --> 00:36:00.579
We think this is a new technology that's
been missing from Mac OS X for a while.

00:36:00.579 --> 00:36:05.969
We think it's going to allow you guys to do a lot of
exciting things, integrate with your user's iCal data,

00:36:05.969 --> 00:36:10.469
make your apps more useful to your users,
and help your users get organized.

00:36:10.469 --> 00:36:13.739
We're really excited about what you
guys are going to be able to do with it.

00:36:13.739 --> 00:36:20.599
There is an iCal and Calendar Store Lab tomorrow,
that's 2:00PM tomorrow in Mac OS X Lab C.
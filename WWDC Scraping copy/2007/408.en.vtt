WEBVTT

00:00:19.230 --> 00:00:24.199
>> My name is Allan Schaffer, and I'm Apple's
graphics evangelist, and this session is all

00:00:24.199 --> 00:00:32.140
about taking an OpenGL application that you've written or
that you have in progress and modernizing it for the things

00:00:32.140 --> 00:00:36.240
that we've done with our implementation
of OpenGL and Mac OS X Leopard.

00:00:36.240 --> 00:00:43.350
And as I was saying in an earlier session, there's really,
there's sort of three categories that modernizations fit

00:00:43.350 --> 00:00:46.990
into when we're thinking of them in presenting to you.

00:00:46.990 --> 00:00:52.820
The first category is that we've really added a lot of new
features to our implementation of OpenGL for Leopard.

00:00:52.820 --> 00:00:55.719
Things like the multithreaded engine, 64-bit support.

00:00:55.719 --> 00:00:59.030
Other things I'm going to get into
later in the, in the presentation.

00:00:59.030 --> 00:01:00.329
So that's kind of the first category.

00:01:00.329 --> 00:01:06.599
We want you to adopt those features really to
keep up with what's going on on the platform.

00:01:06.599 --> 00:01:12.559
The second category is that with OpenGL,
we're tracking an external specification.

00:01:12.560 --> 00:01:18.519
You know the OpenGL is defined by the OpenGL ARB
working group, now part of Kronos.

00:01:18.519 --> 00:01:23.869
And so as they do their work and you know
refine the specification and add extensions

00:01:23.870 --> 00:01:26.840
and so on, we bring those into our implementation.

00:01:26.840 --> 00:01:32.740
And so some of this presentation is about that, it's about
things that the ARB is working on that we want you

00:01:32.739 --> 00:01:37.419
to adopt to bring your application
to, into the modern times.

00:01:37.420 --> 00:01:42.240
The third category is that there's
really a number of best practices.

00:01:42.239 --> 00:01:48.549
Either that are specific to the Mac OS X platform
or
things that are just in general now with GPUs,

00:01:48.549 --> 00:01:53.329
the best practices that you should be using
for when you're developing using OpenGL.

00:01:53.329 --> 00:01:55.870
A lot of this centers around the different buffer objects.

00:01:55.870 --> 00:01:58.719
And so we'll be talking about that quite a bit.

00:01:58.719 --> 00:02:07.569
So this presentation is actually the first of four
OpenGL talks that we're giving here at WWDC this year.

00:02:07.569 --> 00:02:09.419
Along with an OpenGL lab.

00:02:09.419 --> 00:02:14.859
So the session later this after, Switching to Mac OS X
OpenGL is intended for those of you who are coming

00:02:14.860 --> 00:02:18.150
to Mac OS X and OpenGL from another platform.

00:02:18.150 --> 00:02:23.960
Either from Direct 3D to OpenGL or maybe
you're using OpenGL on another operating system

00:02:23.960 --> 00:02:27.200
and just want to know how to get started with it on Mac OS X.

00:02:27.199 --> 00:02:34.319
Then tomorrow morning we have the GLSL and Tuning session
so that's really for, especially for people who are deeper

00:02:34.319 --> 00:02:40.039
into OpenGL already and you have working applications,
you want to know how to kind of take them to the next level.

00:02:40.039 --> 00:02:43.919
And then we'll all be in the lab
all afternoon Tuesday until closing.

00:02:43.919 --> 00:02:50.079
So for this session what we've got, how I've got this
set up is that I'm going to spend a few minutes just talking

00:02:50.080 --> 00:02:52.980
about what is OpenGL and its role in Mac OS X.

00:02:52.979 --> 00:02:55.169
This is just some introductory material.

00:02:55.169 --> 00:03:03.399
And then after that we're going to talk about 10 ways
that you can modernize your OpenGL-based application.

00:03:03.400 --> 00:03:12.719
So let me just kind of go back into the past, you know when,
when OpenGL was first ratified, 1992 with OpenGL 1.0.

00:03:12.719 --> 00:03:17.530
You know if you think back to the
applications of the time, you know they were,

00:03:17.530 --> 00:03:20.710
they were really defined by the graphics cards of that era.

00:03:20.710 --> 00:03:26.830
You know, it was very expensive workstation
class and higher-end graphics pipelines.

00:03:26.830 --> 00:03:33.130
And so those were primarily being used by people
doing high-performance scientific visualization,

00:03:33.129 --> 00:03:37.359
or also on the other side being used by
people in the entertainment industry.

00:03:37.360 --> 00:03:41.090
Now this is a picture on the left
here of a modern application actually.

00:03:41.090 --> 00:03:47.319
I just mean it to, to sort of illustrate the market
that was enabled by OpenGL back at that time.

00:03:47.319 --> 00:03:52.599
But if you look at these models here, their
sort of, they have a certain look, right?

00:03:52.599 --> 00:03:57.069
They are garrow shaded, they
have one point light source.

00:03:57.069 --> 00:04:00.479
In this particular case, there's no textures being applied.

00:04:00.479 --> 00:04:04.269
Pretty simple models, probably just triangle strips.

00:04:04.270 --> 00:04:08.939
And you know not using any, any
real further uses of OpenGL.

00:04:08.939 --> 00:04:16.129
But really that's because that's what was the,
you, know the main, the mainline use of OpenGL

00:04:16.129 --> 00:04:19.420
on those graphics cards back when it first started.

00:04:19.420 --> 00:04:28.000
And then if you jump forward a few years, and think
of the progression of graphics technology and hardware,

00:04:28.000 --> 00:04:31.660
what happened is it started to move
down market into the consumer space.

00:04:31.660 --> 00:04:36.300
And what the consumers were doing, you know one
thing they really liked doing is to play games.

00:04:36.300 --> 00:04:42.889
And so once again, a modern image from a modern app but just
to illustrate, you know games kind of started to come online

00:04:42.889 --> 00:04:45.750
and it was being driven by changes in the hardware.

00:04:45.750 --> 00:04:52.769
So once the hardware started to support things like
multitexture and you know more complex blending operations

00:04:52.769 --> 00:04:58.719
and other things like that, you started to see these
kinds of games, you know, come into the marketplace.

00:04:58.720 --> 00:05:02.280
Of course, this is a shot from Doom 3
which is much more recent.

00:05:02.279 --> 00:05:05.209
But, just you know, games started to happen.

00:05:05.209 --> 00:05:13.680
Then likewise in the, in sort of the higher-end space,
you started to see a move from geotypical terrain

00:05:13.680 --> 00:05:22.319
and outdoor scenes to geospecific data, meaning real-world
terrain, real-world textures, being paged off the disk

00:05:22.319 --> 00:05:25.269
and moved into the, into the graphics hardware.

00:05:25.269 --> 00:05:31.469
And once again this was driven by hardware changes, what
was going on was that the interconnect between the host

00:05:31.470 --> 00:05:34.250
and the graphics hardware was getting faster.

00:05:34.250 --> 00:05:39.889
And so, it was becoming practical now to
stream textures down to the graphics cards.

00:05:39.889 --> 00:05:41.789
And so you were able to do applications like this.

00:05:41.790 --> 00:05:47.370
Of course, this is a shot out of Google Earth, a modern
application that, that's the Apple campus right there.

00:05:47.370 --> 00:05:56.259
And so, but you know, just to show you as the graphics
hardware advanced, these new markets started to come online.

00:05:56.259 --> 00:06:01.310
And likewise, the last example,
texture memory kept increasing.

00:06:01.310 --> 00:06:04.620
You know sort of over the years
as texture memory has increased,

00:06:04.620 --> 00:06:08.910
volume visualization has become more
and more practicable using OpenGL.

00:06:08.910 --> 00:06:16.280
Once again we have a case here, this is the OsiriX
app and you know even with a chat window in the front.

00:06:16.279 --> 00:06:20.389
But behind the chat you know you can
see a heart, you can see the skeleton

00:06:20.389 --> 00:06:22.889
and veins and things like that and nerve endings.

00:06:22.889 --> 00:06:31.469
So you know this sort of volume metric dataset started
to become more applicable for OpenGL applications to go

00:06:31.470 --> 00:06:35.400
and implement as the graphics hardware advanced.

00:06:35.399 --> 00:06:41.500
So that's sort of like the past in you know
going through three-dimensional graphics.

00:06:41.500 --> 00:06:46.870
But so if you think about now, OpenGL in the
present, I actually want to start somewhere else.

00:06:46.870 --> 00:06:55.629
OpenGL has become pervasive now beyond 3D graphics and
we're using it in Mac OS X in a lot of places for 2D.

00:06:55.629 --> 00:06:57.230
And so you see some examples here.

00:06:57.230 --> 00:07:02.700
The Window effects like the genie effect is
the, as you, you know, minimize the window.

00:07:02.699 --> 00:07:08.569
Video effects coming in through Core Image, excuse
me, through Core Video and fed into Core Image.

00:07:08.569 --> 00:07:10.250
Image effects as well.

00:07:10.250 --> 00:07:14.879
So these are things that are now
being driven once again by hardware.

00:07:14.879 --> 00:07:22.240
And so like for the image effects, just as an example,
Core Image is implementing those using fragment programs.

00:07:22.240 --> 00:07:27.280
And so that's programming the GPU to
do a complex image processing operation

00:07:27.279 --> 00:07:32.029
and move that work essentially off the
CPU, move it onto the graphics hardware,

00:07:32.029 --> 00:07:35.139
which is a process that's really
geared toward that kind of work.

00:07:35.139 --> 00:07:41.519
And we're able to really do some things
you know outside of just this, the,

00:07:41.519 --> 00:07:46.329
the sort of expected 3D graphics and image processing space.

00:07:46.329 --> 00:07:51.729
Then likewise in Mac OS X, there's a lot of our
frameworks that are using OpenGL under the hood.

00:07:51.730 --> 00:07:57.250
And so I mentioned Core Image, so that's how
they're doing their image processing effect.

00:07:57.250 --> 00:07:58.709
Core Animation, same story.

00:07:58.709 --> 00:08:04.060
So when, when a layer is being animated in Core
Animation, that is actually, you could think of that

00:08:04.060 --> 00:08:09.319
like a texture being drawn on a quad in OpenGL.

00:08:09.319 --> 00:08:14.659
Core Video, another case where you have, you
know, Core Video is used to sort of tear frames

00:08:14.660 --> 00:08:17.860
out of a QuickTime movie and feed it through a pipeline.

00:08:17.860 --> 00:08:21.220
Well, the end of that pipeline can be resulting in a,

00:08:21.220 --> 00:08:26.700
you know, a Core Video pixel buffer
which is stored down on the GPU.

00:08:26.699 --> 00:08:31.459
Core, Quartz Composer likewise is
really an OpenGL-based application.

00:08:31.459 --> 00:08:35.379
All of Quartz Composer's rendering
is just doing, using OpenGL.

00:08:35.379 --> 00:08:36.570
And I'm going to show you that in a little bit.

00:08:36.570 --> 00:08:39.260
And then maybe the last one is kind of interesting now.

00:08:39.259 --> 00:08:46.939
Added in Leopard is that Quartz itself
can be accelerated through OpenGL.

00:08:46.940 --> 00:08:52.330
This is an opt-in thing that your application can
do but you see some good speed improvements

00:08:52.330 --> 00:08:59.320
because you're moving essentially 2D graphics work
onto the GPU, and just you know besides moving it,

00:08:59.320 --> 00:09:06.120
you're offloading that work from the CPU, and so the CPU
doesn't have to go and try and fill every pixel anymore.

00:09:06.120 --> 00:09:09.399
That's the kind of work that the GPU is really tuned for.

00:09:09.399 --> 00:09:11.639
So that's in the 2D space.

00:09:11.639 --> 00:09:13.980
Now let's think about the 3D space.

00:09:13.980 --> 00:09:18.320
The big change that has happened
here is programmable shading.

00:09:18.320 --> 00:09:25.540
And you, I think many of you saw this, this
example during Steve's keynote on Monday.

00:09:25.539 --> 00:09:29.909
This is a shot out of id's Tech 5 demo.

00:09:29.909 --> 00:09:31.149
Excuse me.

00:09:31.149 --> 00:09:37.370
And I guess what this really represents
is sort of that, that extreme leading edge

00:09:37.370 --> 00:09:42.039
of where 3D graphics is and where it can be right now.

00:09:42.039 --> 00:09:48.149
Using things like programmable shading, using
really all of the power of the graphics card,

00:09:48.149 --> 00:09:52.179
you know for as much as the 3D pipeline can do for you.

00:09:52.179 --> 00:09:58.069
And so I sort of present this as a,
as a question for, for all of you.

00:09:58.070 --> 00:10:01.950
I mean it, I mean it very gently.

00:10:01.950 --> 00:10:10.390
But I want to ask, so does your OpenGL
application, well, does it look more like this?

00:10:10.389 --> 00:10:15.019
Or more like the dinosaur from before?

00:10:15.019 --> 00:10:22.649
So, because if it, if it looks like where
on that spectrum are you, you know?

00:10:22.649 --> 00:10:30.189
Dinosaur over here, John Carmack over here, you know
somewhere in between is where most everybody else is.

00:10:30.190 --> 00:10:34.650
And if your application is really
way more on the dinosaur side, then,

00:10:34.649 --> 00:10:38.970
then you're the motivating purpose for this session.

00:10:38.970 --> 00:10:44.710
And that's why we've put together a list of ten
ways for you now to modernize your application

00:10:44.710 --> 00:10:51.370
so that you can make it, you know, really make
use of what's modern in graphic hardware.

00:10:51.370 --> 00:10:52.779
So okay, off we go.

00:10:52.779 --> 00:10:54.339
Number one.

00:10:54.340 --> 00:10:58.019
This is really the most fundamental of all of the top ten.

00:10:58.019 --> 00:11:00.250
You've heard us say this before.

00:11:00.250 --> 00:11:05.460
If you've been to WWDC in the past, and so I
apologize for one especially repetitive item.

00:11:05.460 --> 00:11:08.310
But it's so important that we have
to just keep emphasizing it.

00:11:08.309 --> 00:11:11.039
And its vertex buffer projects.

00:11:11.039 --> 00:11:15.049
And what this is is that we need for
people, well, actually I'll say it this way.

00:11:15.049 --> 00:11:18.370
Let's look at the cause of the problem.

00:11:18.370 --> 00:11:26.370
So one of my colleagues has a copy of the
Red Book, first edition, first printing.

00:11:26.370 --> 00:11:28.590
I think it might be signed by Curt Ackley.

00:11:28.590 --> 00:11:34.710
And so I looked in it and on page
six, the very first example is this.

00:11:34.710 --> 00:11:40.639
And if you look at this example, well, this is
the, kind of the cause of our problem now a days.

00:11:40.639 --> 00:11:47.009
It's teaching people that, you know, the easy, easy way
to get just something up and running in OpenGL is

00:11:47.009 --> 00:11:55.220
to use immediate mode, using calls like glBegin, sending a
few vertices, glEnd, you know sending a, a color and so on.

00:11:55.220 --> 00:12:02.110
And you know this was true back in the days when
kind of the graphics hardware was pretty power,

00:12:02.110 --> 00:12:05.610
you know was kind of the, the most
expensive part of your machine.

00:12:05.610 --> 00:12:08.529
The CPUs were pretty powerful and
you had a good interconnect.

00:12:08.529 --> 00:12:13.819
But now a days, the overhead of doing
calls like this is just so inefficient.

00:12:13.820 --> 00:12:15.950
There's much, much more modern ways.

00:12:15.950 --> 00:12:21.980
And like if you've been following OpenGL over the years,
you know that now a days, there's four different ways

00:12:21.980 --> 00:12:25.509
of sending vertices down to the graphics hardware.

00:12:25.509 --> 00:12:26.529
Why are there four?

00:12:26.529 --> 00:12:32.019
Well, because over the years there's been,
you know, this was what was fastest in 1992,

00:12:32.019 --> 00:12:38.000
and then there was something faster in 96 and
something faster in 2000 and something faster now.

00:12:38.000 --> 00:12:41.860
And so you know you've got to use these more modern methods.

00:12:41.860 --> 00:12:47.100
If you're code looks like this, then you're
here, you know, you need to modernize.

00:12:47.100 --> 00:12:51.649
And so the reason why this is such an issue is
it really has to do with the transfer bandwidth

00:12:51.649 --> 00:12:53.549
between the host and the graphics hardware.

00:12:53.549 --> 00:12:59.169
And if we kind of open up these diagrams, so you know
sort of stylized here on the left is the host

00:12:59.169 --> 00:13:03.019
with your application talking to OpenGL
and the main memory is there.

00:13:03.019 --> 00:13:09.879
You have all of your triangle data and so on sitting in
memory in immediate mode using or you know you're planning

00:13:09.879 --> 00:13:13.149
to use immediate mode or display
list to send it to the hardware.

00:13:13.149 --> 00:13:19.649
And then just graphically speaking on the GPU side, you have
a vertex unit, fragment unit, and you've got video memory

00:13:19.649 --> 00:13:21.669
with you know your textures and frame buffers.

00:13:21.669 --> 00:13:23.029
Just conceptually there.

00:13:23.029 --> 00:13:26.389
So the problem with immediate mode is very obvious.

00:13:26.389 --> 00:13:31.649
It's that you begin sending very, very small
chunks of data down to the graphics pipe,

00:13:31.649 --> 00:13:37.789
they get bottlenecked in the transfer, and then meanwhile
also the vertex unit is just sitting there starving

00:13:37.789 --> 00:13:39.349
for work to do.

00:13:39.350 --> 00:13:47.389
Right? It's just, you know, it's such little bits of data coming
across the pipe, its able to process vertices much faster

00:13:47.389 --> 00:13:50.340
than you know you'd be sending them one at a time.

00:13:50.340 --> 00:13:51.340
And so that's bad.

00:13:51.340 --> 00:13:53.009
Don't do that.

00:13:53.009 --> 00:13:58.360
What we want you to do instead is to
set up your data into a buffer object.

00:13:58.360 --> 00:14:01.639
That's the new box that's appeared under VRAM there.

00:14:01.639 --> 00:14:05.120
And what you're doing is your caching your data on the GPU.

00:14:05.120 --> 00:14:10.129
And so since its cached there, the
internal bandwidths of the GPU are immense.

00:14:10.129 --> 00:14:12.759
And so when you go to draw this, it's a very fat pipe.

00:14:12.759 --> 00:14:17.840
It just goes flows into the vertex processing unit
and then can go through the rest of the system.

00:14:17.840 --> 00:14:20.700
And it's just much, much faster, much more efficient.

00:14:20.700 --> 00:14:26.960
And then likewise just think, you know, realize that
over on the host side, basically no work is happening.

00:14:26.960 --> 00:14:34.900
So your CPU is, is free to go do other things rather
than your CPU being busy bundling up vertices,

00:14:34.899 --> 00:14:41.250
trying to you know bundle them up more
optimally and send them down to the GPU.

00:14:41.250 --> 00:14:45.220
So this is kind of the basic of VBOs, vertex buffer objects.

00:14:45.220 --> 00:14:52.040
But usual, the usual criticism that we receive at
this point is, well, Alan, my, my data is dynamic

00:14:52.039 --> 00:14:54.639
or it's too big to fit in VRAM, what do I do?

00:14:54.639 --> 00:14:58.169
You know I can't just push it all down
there on paging data, just whatever.

00:14:58.169 --> 00:15:00.559
I've got some special case.

00:15:00.559 --> 00:15:09.529
The, the answer for that is that actually you can set up
dynamic buffer objects over on the CPU side in regular RAM.

00:15:09.529 --> 00:15:16.299
And so these are still considered, you know,
treated like vertex buffer objects in terms

00:15:16.299 --> 00:15:20.179
of being packed together optimally and
sent down to the graphics hardware.

00:15:20.179 --> 00:15:25.620
And actually what's nice is that it uses a DMA
transfer to kind of more optimally send them down.

00:15:25.620 --> 00:15:30.360
So the thing to know about this is
that the worst case scenario with,

00:15:30.360 --> 00:15:36.509
with dynamic buffer objects meaning you're changing like
every texture, or sorry, you're changing every color,

00:15:36.509 --> 00:15:39.769
every, you know, normal, you know, every vertex, every frame.

00:15:39.769 --> 00:15:46.299
Generally speaking, that ends up performing faster
than the equivalent in immediate mode for big datasets.

00:15:46.299 --> 00:15:51.159
Just because the transfer is more efficient.

00:15:51.159 --> 00:15:54.449
But okay, so now let's look at a little bit of code.

00:15:54.450 --> 00:15:58.490
So the steps for using a vertex buffer object are here.

00:15:58.490 --> 00:16:01.190
First, you're just defining a buffer and then creating it.

00:16:01.190 --> 00:16:06.350
So in this case we create it with,
we're passing NULL for the data.

00:16:06.350 --> 00:16:13.600
And this tells OpenGL that we're going to give it the data a
little bit later, that's what's going to happen in step three.

00:16:13.600 --> 00:16:17.950
So now essentially that step two is like a big malloc.

00:16:17.950 --> 00:16:22.009
And now we're asking for the result of the malloc back.

00:16:22.009 --> 00:16:26.809
The MapBuffer maps the data back into our
address space and then we can insert code

00:16:26.809 --> 00:16:29.369
to go and modify VBO data however we like.

00:16:29.370 --> 00:16:35.980
And then when we unmap that sort of sends
it back into the storage in OpenGL.

00:16:35.980 --> 00:16:38.490
So that's all, step one through three is the set up

00:16:38.490 --> 00:16:42.789
and then step four here is what you
do during draw time in your draw loop.

00:16:42.789 --> 00:16:44.409
You're just binding the buffer, or

00:16:44.409 --> 00:16:48.990
you're setting an offset to tell OpenGL kind
of where in that buffer you want to start drawing.

00:16:48.990 --> 00:16:53.370
Telling it what's in there and then,
boom, you go and draw those arrays.

00:16:53.370 --> 00:16:57.529
Okay? I want to mention a brief aside.

00:16:57.529 --> 00:17:00.689
So about this code in these slides.

00:17:00.690 --> 00:17:08.850
So the, we're not ready to hand out slides or anything, but
if you, if we're going to go too fast for you to write it down,

00:17:08.849 --> 00:17:11.139
my email address will be at the end of the present.

00:17:11.140 --> 00:17:17.480
You can email me and I will reply back with
the text of the code in the slides, okay?

00:17:17.480 --> 00:17:18.059
( Period of silence )

00:17:18.059 --> 00:17:20.769
So that was number one.

00:17:20.769 --> 00:17:23.559
Replace immediate mode with vertex buffer objects.

00:17:23.559 --> 00:17:24.519
Number two.

00:17:24.519 --> 00:17:29.930
This is a feature that we added first in,
I believe, 10.4.8.

00:17:29.930 --> 00:17:36.490
On Intel and now in Leopard it's going to be
across all the platforms that Leopard supports.

00:17:36.490 --> 00:17:42.190
So the idea of multithreaded engine is that,
you know, usually your application is just sort

00:17:42.190 --> 00:17:45.390
o,f you know, your application is
running, it's talking to OpenGL.

00:17:45.390 --> 00:17:49.370
OpenGL is taking some amount of your CPU time also.

00:17:49.369 --> 00:17:52.409
And then OpenGL is talking to the graphics hardware.

00:17:52.410 --> 00:17:58.720
Now the systems that we're shipping now,
you know today, are multicourse machines.

00:17:58.720 --> 00:18:04.289
And so, in many cases, there's extra CPU
horsepower that you can offload some work to.

00:18:04.289 --> 00:18:07.460
And so that's what the multithreaded engine is all about,

00:18:07.460 --> 00:18:13.569
is just giving your application more time
on, you know, sort of in the main thread.

00:18:13.569 --> 00:18:19.700
And then spawning off another thread that's going to be the
one that's doing the work to bundle up OpenGL commands

00:18:19.700 --> 00:18:21.819
and send them down to the graphics hardware.

00:18:21.819 --> 00:18:25.629
Now you notice there's still a
little bit of blue on CP1 there.

00:18:25.630 --> 00:18:31.050
That's because your application is still communicating
with OpenGL and there's a little bit of overhead.

00:18:31.049 --> 00:18:34.680
OpenGL has to take your calls and send
them over to the other thread and so on.

00:18:34.680 --> 00:18:35.860
So that's happening.

00:18:35.859 --> 00:18:41.879
But then CPU2 or CPU core 2 is the one
that's going to communicate with the graphics hardware.

00:18:41.880 --> 00:18:48.170
Now the main benefit of this is that when you
issue a OpenGL call once this is turned on,

00:18:48.170 --> 00:18:51.269
all that happens is that call gets
queued up by the other thread.

00:18:51.269 --> 00:18:56.809
And your application thread returns
immediately and can go on to do more stuff.

00:18:56.809 --> 00:18:59.940
And so you get a performance boost because of that.

00:18:59.940 --> 00:19:02.470
So to turn this one, it's really just one line of code.

00:19:02.470 --> 00:19:05.509
You have a pointer, or you have a handle to your context.

00:19:05.509 --> 00:19:09.269
And you just call this CGLEnable to enable this.

00:19:09.269 --> 00:19:14.269
You can also enable it from within the
OpenGL Profiler just using a checkbox.

00:19:14.269 --> 00:19:15.470
You can force on or off.

00:19:15.470 --> 00:19:17.309
So that's a good way to test.

00:19:17.309 --> 00:19:20.940
But so there's a little bit of fine print here.

00:19:20.940 --> 00:19:27.070
So with the multithreaded engine, first of all,
you know, there's a certain profile of applications

00:19:27.069 --> 00:19:30.319
that really are going to benefit from using this.

00:19:30.319 --> 00:19:35.720
If you are CPU bounded in your
application, then that's great.

00:19:35.720 --> 00:19:42.150
You are farming the work that OpenGL is doing off
into another thread and that gives you more CPU time.

00:19:42.150 --> 00:19:43.450
So that's great.

00:19:43.450 --> 00:19:50.460
If you, but you know, cases where it
won't help you is if you have a lot

00:19:50.460 --> 00:19:54.250
of what we call client/server sync points in OpenGL.

00:19:54.250 --> 00:19:56.769
The number three on my list is all about that.

00:19:56.769 --> 00:19:58.900
So we'll come back to it.

00:19:58.900 --> 00:20:02.430
Obviously it only helps you if you have multiple CPU cores.

00:20:02.430 --> 00:20:09.539
If you enable this on a machine with just one CPU,
and you know, and one core it just has no effect.

00:20:09.539 --> 00:20:15.409
Also this is called the multithreaded engine,
but it doesn't change the threading behavior

00:20:15.410 --> 00:20:19.779
in relation to OpenGL and contexts itself.

00:20:19.779 --> 00:20:25.879
So you still, just as before, you still want
to have one rendering thread per context.

00:20:25.880 --> 00:20:27.620
And that's basically no change.

00:20:27.619 --> 00:20:29.859
This doesn't add anything to that.

00:20:29.859 --> 00:20:32.059
And then I mentioned there's some tradeoffs here.

00:20:32.059 --> 00:20:35.779
So there's you know there's additional
buffering, there's queuing that's going on.

00:20:35.779 --> 00:20:41.019
And we have to copy the data over to the other
thread, and so there's an overhead associated there.

00:20:41.019 --> 00:20:46.740
But the main thing with the multithreaded engine
is that you have to get rid of the sync points.

00:20:46.740 --> 00:20:50.569
And it's just not going to do you any
good if you're using immediate mode.

00:20:50.569 --> 00:20:56.079
So you have to move over to at least to use VBOs.

00:20:56.079 --> 00:21:00.039
So that's number two, use the multithreaded engine.

00:21:00.039 --> 00:21:03.409
Number three, okay, these sync
points that I'm talking about.

00:21:03.410 --> 00:21:09.160
So the basic idea here is that you want
what the CPU is doing and what OpenGL

00:21:09.160 --> 00:21:13.330
and the GPU are doing to be as decoupled as you possibly can.

00:21:13.329 --> 00:21:19.049
And so you know OpenGL works in a client and server model
and there's some calls that when you make them in your app,

00:21:19.049 --> 00:21:23.450
you know like glGett or glGetError,
and so on, well, your app,

00:21:23.450 --> 00:21:27.970
you know, your app waits for the
OpenGL framework to reply back.

00:21:27.970 --> 00:21:32.250
And there might be things that the OpenGL
framework has queued up that would have

00:21:32.250 --> 00:21:36.019
to complete before it can give you that answer.

00:21:36.019 --> 00:21:40.639
So you, in many cases, you're waiting for
the pipe to drain on the software stack.

00:21:40.640 --> 00:21:44.920
And just blocked there waiting for an answer back.

00:21:44.920 --> 00:21:47.000
And then that's sort of case number one.

00:21:47.000 --> 00:21:52.559
Case number two, even worse, is that there's some calls
that have to wait for an answer back from the GPU.

00:21:52.559 --> 00:21:57.849
Which means that you have to wait for the whole graphics
pipeline to drain before you can get your result back.

00:21:57.849 --> 00:22:04.490
So like glReadPixels, for example, if you just call
that, that's going to, your process is going to block

00:22:04.490 --> 00:22:07.809
until the result of the glReadPixels comes back to you.

00:22:07.809 --> 00:22:14.929
And then it's even worse because it's blocked
and, and you know, once you start up again,

00:22:14.930 --> 00:22:18.519
now your pipeline is dry and you
have to start filling the pipe.

00:22:18.519 --> 00:22:24.069
You know, and the pipe is going to be frontloaded at
first, it'll take a while for things to get down.

00:22:24.069 --> 00:22:27.970
Now getting this perfect is kind of a tough balancing act.

00:22:27.970 --> 00:22:32.279
But there's a few steps that you can take
to really just make this better in your app.

00:22:32.279 --> 00:22:37.569
And number one is to just methodically go through
and look for places where you call glGet.

00:22:37.569 --> 00:22:40.159
And those other synchronizing calls.

00:22:40.160 --> 00:22:44.860
You know, you can set break points in OpenGL Profiler,
you can use grep, whatever is your favorite method.

00:22:44.859 --> 00:22:48.809
Just go through and every time you
find one think, do I really need this?

00:22:48.809 --> 00:22:53.039
Like, do I really need to ask GL is lighting enabled?

00:22:53.039 --> 00:22:55.700
And aren't I the only one who set it?

00:22:55.700 --> 00:22:59.539
Like I could just have a Boolean that keeps track of that.

00:22:59.539 --> 00:23:01.379
And by doing that, that's removal.

00:23:01.380 --> 00:23:02.590
Bing, one sync point.

00:23:02.589 --> 00:23:06.549
And so you know once you finally make
your way down to zero, you're golden.

00:23:06.549 --> 00:23:12.029
The, another one that's really important
and especially because it's seen

00:23:12.029 --> 00:23:15.099
in a lot of documentation, is glGetError.

00:23:15.099 --> 00:23:17.049
So you know glGetError is great.

00:23:17.049 --> 00:23:22.960
You can use it in your code, you know sprinkle around, do
whatever, you know, all the things that I've seen people do,

00:23:22.960 --> 00:23:26.519
but when it comes time for production use
of your code, you need to get rid of those.

00:23:26.519 --> 00:23:29.950
Because every one of those glGetErrors is a sync point.

00:23:29.950 --> 00:23:35.029
And what I see a lot is people trying to debug
something will just start inserting glGetError kind

00:23:35.029 --> 00:23:38.970
of like a print F. You know like
where is this problem coming from?

00:23:38.970 --> 00:23:42.589
And then they leave it and you
know their performance suffers.

00:23:42.589 --> 00:23:47.369
Number two, if you have intentional
sync points, that's bad obviously.

00:23:47.369 --> 00:23:51.929
glFinish, you know, in the Mac OS X
is usually not a necessary call,

00:23:51.930 --> 00:23:55.940
as compared to like on Linux or other platforms in the past,

00:23:55.940 --> 00:24:00.240
where it's just been sort of a
standard synchronizing operation.

00:24:00.240 --> 00:24:04.220
Instead it's best to just letCGLFlushDrawable
do a glFlush.

00:24:04.220 --> 00:24:05.789
Now there are special cases.

00:24:05.789 --> 00:24:14.230
So sort of if you fall into maybe the, your way more
on the, you know, the shader end of that spectrum

00:24:14.230 --> 00:24:16.009
from the dinosaur that I was talking about.

00:24:16.009 --> 00:24:20.390
Okay, you probably know of some cases then
where you still need to call glFlush.

00:24:20.390 --> 00:24:27.150
But if you're a developer who's just adding a glFlush
because you think, oh, am I supposed to do this here?

00:24:27.150 --> 00:24:32.030
No. Just you know in most cases, you
can go and take that out of your code.

00:24:32.029 --> 00:24:33.809
A few other things just to grab bag.

00:24:33.809 --> 00:24:36.599
You know you can avoid a lot of state setting.

00:24:36.599 --> 00:24:38.559
And that can help you avoid sync points.

00:24:38.559 --> 00:24:42.559
You know OpenGL is just a big state machine where
you're kind of tweaking all these knobs everywhere

00:24:42.559 --> 00:24:45.779
and then saying, okay, you know fire me another frame.

00:24:45.779 --> 00:24:50.799
And so the more that you can, as much as
you can minimize that, that's positive here.

00:24:50.799 --> 00:24:53.299
And usually you do that by sorting by state.

00:24:53.299 --> 00:24:54.759
And then something more advanced.

00:24:54.759 --> 00:25:01.000
If you are using fences, just make sure that, that
you, you know you set the fence early and you go off

00:25:01.000 --> 00:25:07.109
and do enough work so that the fence will have
completed or whatever you're fencing will have completed

00:25:07.109 --> 00:25:10.829
by the time you go back and test the fence.

00:25:10.829 --> 00:25:13.839
But okay, so that was remove client/server sync points.

00:25:13.839 --> 00:25:17.699
The take away there, go through and get rid of glGets.

00:25:17.700 --> 00:25:20.049
Number four, this is how you can do that.

00:25:20.049 --> 00:25:21.849
Master the developer tools.

00:25:21.849 --> 00:25:27.639
So in Mac OS X Leopard there's a number of developer
tools that just are the standard ones that we use

00:25:27.640 --> 00:25:32.530
when we're trying to do performance
profiling on an OpenGL application.

00:25:32.529 --> 00:25:35.470
You know, we usually actually start with Shark and then go

00:25:35.470 --> 00:25:39.350
into the OpenGL Profiler and run
Driver Monitor in addition.

00:25:39.349 --> 00:25:42.399
Also there's a tool that's coming called the Shader Builder.

00:25:42.400 --> 00:25:46.460
And I think there's sessions here
at the show about Xray as well.

00:25:46.460 --> 00:25:49.860
So since we start with Shark, I just
want to make a quick mention there,

00:25:49.859 --> 00:25:52.149
I'm not going to go into Shark in too much detail.

00:25:52.150 --> 00:25:55.090
So you know the things that you need to look

00:25:55.089 --> 00:26:01.789
for in Shark are actually, you know, am I
spending a lot of time, you know, in disk access.

00:26:01.789 --> 00:26:06.430
Am I spending a lot of time calling
some, you know, JPEG load library?

00:26:06.430 --> 00:26:09.140
You know like where am I spending the time in my app?

00:26:09.140 --> 00:26:12.600
But, if it is in OpenGL, if that's what's showing up,

00:26:12.599 --> 00:26:17.109
then there's a few tell-tale symbols
that you need to look out for.

00:26:17.109 --> 00:26:18.779
So glgProcessPixels.

00:26:18.779 --> 00:26:21.849
If you're spending a lot of time in it, usually means

00:26:21.849 --> 00:26:27.839
that you're spending, you know, you're doing texture
format conversions or image format conversions.

00:26:27.839 --> 00:26:32.899
If you see a GLRendererFloat, it means you did
something to fall off the hardware path and now you're

00:26:32.900 --> 00:26:38.580
in the software renderer and that's almost,
you know, if it's unintended then it's bad.

00:26:38.579 --> 00:26:42.559
And then finally, if you see gleFinishCommandBuffer,
it means you fell into one

00:26:42.559 --> 00:26:46.250
of these client/server sync points,
you're spending too much time there.

00:26:46.250 --> 00:26:52.569
But okay, so for the next, I'd like to show a
quick demo of the OpenGL Profiler in Leopard.

00:26:52.569 --> 00:26:57.519
So I've got it just running here already.

00:26:57.519 --> 00:27:00.389
With a Quartz Composer composition.

00:27:00.390 --> 00:27:02.910
As I mentioned, Quartz Composer
is rendering through Open L.

00:27:02.910 --> 00:27:06.740
So it just, it makes a very convenient
test case for the Profiler.

00:27:06.740 --> 00:27:08.980
This is the Profiler main window, up here.

00:27:08.980 --> 00:27:14.789
I'm using, oops, let me zoom in so you can see that up here.

00:27:14.789 --> 00:27:18.170
The place where most people start in the Profiler is,

00:27:18.170 --> 00:27:22.880
is here to either launch an application
or to attach to a running application.

00:27:22.880 --> 00:27:25.730
In this case, I just launched it
right before we started here.

00:27:25.730 --> 00:27:28.099
And now there's a number of different views that you can go.

00:27:28.099 --> 00:27:30.429
A trace, to statistics and so on.

00:27:30.430 --> 00:27:32.700
I'm going to start with the statistics.

00:27:32.700 --> 00:27:39.450
So this is just showing statistics of what we're
calling, they're just totaling up every frame.

00:27:39.450 --> 00:27:44.640
And it's always interesting to kind of look at
this to see where the GL time is being spent.

00:27:44.640 --> 00:27:49.310
But, you know, it's, there's really some
more specific things that you can do.

00:27:49.309 --> 00:27:52.529
Now the reason why I want to show you this
is if you're developing with OpenGL

00:27:52.529 --> 00:27:55.319
on Mac OS X, I expect you to run the Profiler.

00:27:55.319 --> 00:27:59.210
I mean, I expect the Profiler to be
in your Dock, to tell you the truth.

00:27:59.210 --> 00:28:03.200
And so you know, it's something that's
just very, very useful to have.

00:28:03.200 --> 00:28:07.590
And I want to show you just a usual pattern of using it here.

00:28:07.589 --> 00:28:10.539
So I have this statistics window up.

00:28:10.539 --> 00:28:12.750
What I want to do actually is slow things down.

00:28:12.750 --> 00:28:15.980
I'm going to set a break point over here.

00:28:15.980 --> 00:28:19.410
This is the break points windows, and it's
just showing different to OpenGL calls.

00:28:19.410 --> 00:28:23.430
And I can set a break point here
at CGLFLushDrawable, there.

00:28:23.430 --> 00:28:25.110
And my rendering start stopped.

00:28:25.109 --> 00:28:27.859
It shows me the stack trace here if I want to see that.

00:28:27.859 --> 00:28:31.259
But more importantly, the statistics window stopped going.

00:28:31.259 --> 00:28:40.759
I can clear that and now advance a frame, and
now I can see what OpenGL calls are being made

00:28:40.759 --> 00:28:44.099
in one frame in this application.

00:28:44.099 --> 00:28:47.599
And you know, there's some really interesting stuff in here.

00:28:47.599 --> 00:28:54.019
In one frame, we're calling glGetError 121 times.

00:28:54.019 --> 00:28:56.740
Okay? So that's a problem.

00:28:56.740 --> 00:29:00.599
We're calling glGetIntegerv 544 times.

00:29:00.599 --> 00:29:03.839
glIsEnabled, 359 times.
Y

00:29:03.839 --> 00:29:05.309
You know in one frame.

00:29:05.309 --> 00:29:10.119
So that's, you know that is what close
to 1000 sync points, right there.

00:29:10.119 --> 00:29:14.189
That would be good to go and at
least justify for why they're there.

00:29:14.190 --> 00:29:20.299
Now I happen to know, you know, since Quartz
Composer now is extensible, there are certain cases

00:29:20.299 --> 00:29:25.470
where you know an extension could be changing
the GL state and so Quartz Composer has to go

00:29:25.470 --> 00:29:27.829
and double check it and maybe restore it.

00:29:27.829 --> 00:29:29.569
But that's why there's some of these.

00:29:29.569 --> 00:29:32.929
But there's others that are maybe a little more interesting.

00:29:32.930 --> 00:29:37.420
And so I'll show you, you know, another
thing that you can take a look at.

00:29:37.420 --> 00:29:39.380
That's the trace window.

00:29:39.380 --> 00:29:42.010
So clean up a little bit.

00:29:42.009 --> 00:29:43.039
So here's the trace.

00:29:43.039 --> 00:29:51.839
And once again, if I advance a frame, this shows me all
of the OpenGL calls that I just made in that one frame.

00:29:51.839 --> 00:29:53.589
Right, and I can scroll through the list.

00:29:53.589 --> 00:29:58.179
I can look at see if I, there's a button I
can check so that if I click one of these,

00:29:58.180 --> 00:30:01.200
it'll show me the stack trace at that particular moment.

00:30:01.200 --> 00:30:05.090
But you know, let's, I saw something
right down at the bottom here.

00:30:05.089 --> 00:30:05.990
Now let me see, where is that?

00:30:05.990 --> 00:30:07.900
Here's a call to glGetError.

00:30:07.900 --> 00:30:10.780
And check it out, there's another call to glGetError.

00:30:10.779 --> 00:30:12.769
And there's another call to glGetError.

00:30:12.769 --> 00:30:13.700
And there's another one.

00:30:13.700 --> 00:30:19.269
You know, like there's some things where if you go
and actually look at the trace of OpenGL calls

00:30:19.269 --> 00:30:23.079
that you're application makes, you
might end up embarrassed, right?

00:30:23.079 --> 00:30:29.529
Because there's things in here like, okay, you didn't realize
that your clean up function, you know, your destructor

00:30:29.529 --> 00:30:33.470
for every class in your scene graph
hierarchy is calling glGetter.

00:30:33.470 --> 00:30:36.289
You know, these kinds of things are
what you should be looking for.

00:30:36.289 --> 00:30:38.889
And you know, this is the truth.

00:30:38.890 --> 00:30:40.940
Right? And so it'll show you.

00:30:40.940 --> 00:30:44.279
Do it in, you know, look at it in private, but...

00:30:44.279 --> 00:30:46.440
( Laughter )

00:30:46.440 --> 00:30:47.630
Go fix that stuff.

00:30:47.630 --> 00:30:48.370
All right.

00:30:48.369 --> 00:30:50.219
So thank you, we'll go back to slides.

00:30:50.220 --> 00:30:54.460
( Period of silence )

00:30:54.460 --> 00:30:58.779
So number four, master the developer
tools, takes us into number five.

00:30:58.779 --> 00:31:00.460
Okay, 64-bit.

00:31:00.460 --> 00:31:06.279
So the idea for 64-bit in OpenGL and
primarily in scientific graphics or especially

00:31:06.279 --> 00:31:09.269
in scientific graphics is to get big address space.

00:31:09.269 --> 00:31:11.059
You can load big datasets.

00:31:11.059 --> 00:31:18.179
You can move the processing away from disk IO and some
of the other bottlenecks that are frequently found there

00:31:18.180 --> 00:31:22.970
and move, you know, essentially change the
balance point again by moving to 64 bit.

00:31:22.970 --> 00:31:26.960
So you know essentially you have the
ability to have a bigger dataset.

00:31:26.960 --> 00:31:30.740
There's also sort of a hidden benefit and it's on Intel.

00:31:30.740 --> 00:31:34.549
You actually have twice as many
registers as the 32-bit process.

00:31:34.549 --> 00:31:38.889
And so that means twice as many things end
up in registers instead of on the heap.

00:31:38.890 --> 00:31:42.880
And it's just a nice benefit you
see some performance gains there.

00:31:42.880 --> 00:31:48.090
Now you know 64-bit just, you know, the 30-second overview.

00:31:48.089 --> 00:31:51.549
We use the LP64 model.

00:31:51.549 --> 00:31:53.960
That means that longs in pointers are 64-bit.

00:31:53.960 --> 00:31:58.059
And of course, you have this huge,
you know, theoretical address space,

00:31:58.059 --> 00:32:01.240
more than physical RAM you can put in the machine certainly.

00:32:01.240 --> 00:32:07.529
Now between that last slide and this
one is where you ported your app.

00:32:07.529 --> 00:32:09.299
I'm not covering that topic.

00:32:09.299 --> 00:32:15.309
So you know, a lot of, there is some porting work
that has to happen to move your app to 64-bit.

00:32:15.309 --> 00:32:19.839
And so this is like once you're
done, how you can make a binary.

00:32:19.839 --> 00:32:22.849
We have a number of sessions here
at, you know, at the conference

00:32:22.849 --> 00:32:25.399
for how to, you know, for issues in moving to 64-bit.
d

00:32:25.400 --> 00:32:29.210
You know, my best advice to you is look at compiler warnings,

00:32:29.210 --> 00:32:33.039
and you know, that'll tell you a
lot of what you're going to find.

00:32:33.039 --> 00:32:36.019
But it's just a checkbox here once it's ported over.

00:32:36.019 --> 00:32:43.200
Or if you're a command-line guy like me, then
you can use these command-line arguments here,

00:32:43.200 --> 00:32:48.850
-arch for PowerPC 64 and for Intel 64.

00:32:48.849 --> 00:32:54.480
Or for Xcode ability, you just add a few more
variables, or a few more items into that variable.

00:32:54.480 --> 00:33:03.470
Okay? Something to remember as far as 64-bit goes is what's
actually been deprecated and what's not available in 64-bit.

00:33:03.470 --> 00:33:06.600
So there's no 64-bit support fdor QuickDraw.

00:33:06.599 --> 00:33:11.649
And so that means that some of the routines
in our AGL implementation, excuse me,

00:33:11.650 --> 00:33:16.240
are no longer available or have replacements now.

00:33:16.240 --> 00:33:18.099
And so you need to go and check that out.

00:33:18.099 --> 00:33:22.689
The thing to know is that, okay, so
this is talking about 64-bit in Leopard,

00:33:22.690 --> 00:33:29.080
and so if you have a 32-bit QuickDraw-based
application, and incidentally, that's redundant.

00:33:29.079 --> 00:33:32.059
All of QuickDraw-based applications are 32-bit.

00:33:32.059 --> 00:33:35.990
They will continue to work in Leopard.

00:33:35.990 --> 00:33:39.220
Or you know, they won't break because
of this change, I should say.

00:33:39.220 --> 00:33:43.200
All right, so that was number five, build for 64-bit.
d

00:33:43.200 --> 00:33:48.730
For number six, I'd like to invite Geoff Stahl,
the engineering manager for the 3D graphics te=am

00:33:48.730 --> 00:33:52.420
up to the stage and he's going to talk about adopting GLSL.

00:33:52.420 --> 00:33:53.029
>> Thanks, Allan.

00:33:53.029 --> 00:33:53.149
( Applause )

00:33:53.150 --> 00:34:03.830
So I'm going to talk about adopting GLSL
and go through a little bit today.

00:34:03.829 --> 00:34:08.509
And then tomorrow in the morning we're going to
talk more in depth about GLSL in general.

00:34:08.510 --> 00:34:11.750
So first thing I want to talk about is what is GLSL?

00:34:11.750 --> 00:34:15.780
If you haven't used it before, it's a high-
level C-like language which really kind

00:34:15.780 --> 00:34:18.210
of simplifies the programming of OpenGL.

00:34:18.210 --> 00:34:25.789
It allows you to directly program what you want to program
rather than setting maybe your color mask or your colors

00:34:25.789 --> 00:34:28.779
and try and draw it all with vertices and fragments.

00:34:28.780 --> 00:34:32.800
It really allows you to actually define
a program that defines your vertices,

00:34:32.800 --> 00:34:35.140
define a program that defines your fragments.

00:34:35.139 --> 00:34:39.230
And now it will allow you to define
a program that defines geometry also.

00:34:39.230 --> 00:34:41.750
So it's a rendering in the OpenGL API.

00:34:41.750 --> 00:34:47.590
One of the keys here is that it allows
future access to the power of the GPU.

00:34:47.590 --> 00:34:50.350
Right now if you take Ope GL 1112 even through 15,

00:34:50.349 --> 00:34:55.059
there are features that are being built
into GPUs you just can't get access to.

00:34:55.059 --> 00:34:59.079
Geometry shader, brand new, fourth
generation shading extensions.

00:34:59.079 --> 00:35:01.980
Not available through any non -programmable API.

00:35:01.980 --> 00:35:05.889
So if you're not on a programmable API,
you can't get access to those features.

00:35:05.889 --> 00:35:08.739
An example at the bottom of the
slide is what it kind of looks like.

00:35:08.739 --> 00:35:14.369
You got some vertex attributes coming in,
uniforms are like constants to your program.

00:35:14.369 --> 00:35:19.579
And the variance in this case a vertex shader is something
you're outputting to the fragment into the pipeline.

00:35:19.579 --> 00:35:26.340
It's a main like you would expect in C, and basically,
in this case we're going to do some work with the vertices,

00:35:26.340 --> 00:35:33.829
set a texture coordinate, and output your GL position and
then will go to be interpolated for your fragment programs.

00:35:33.829 --> 00:35:37.299
So why do you want to adopt GLSL?

00:35:37.300 --> 00:35:42.340
A lot of folks that Allan may have talked to in the
beginning of the session have like the dinosaur kind of app.

00:35:42.340 --> 00:35:46.740
What benefit is GLSL in your dinosaur?

00:35:46.739 --> 00:35:51.989
The thing here is I think it opens up a really
large set of new types of apps and new types

00:35:51.989 --> 00:35:56.789
of kind of programming designs for OpenGL.

00:35:56.789 --> 00:35:58.349
Because this really is approachable.

00:35:58.349 --> 00:35:59.329
It's C-like language.

00:35:59.329 --> 00:36:02.360
You can just kind of type what you
want like I showed in the example.

00:36:02.360 --> 00:36:07.210
And you don't really have to think of how can
take a, you know, use a texture combine stages

00:36:07.210 --> 00:36:11.369
and combine different texture, you know,
different texturing to get the effect that I want?

00:36:11.369 --> 00:36:15.920
You actually can just blend them
in a small program that you write.

00:36:15.920 --> 00:36:17.720
It's also easy to experiment with.

00:36:17.719 --> 00:36:21.689
We give you some tools, we give you Shader
Builder which we're rewriting for Leopard.

00:36:21.690 --> 00:36:26.190
We also have the Profiler works that's hooked in, and
we have an Editor sample out there which you can use,

00:36:26.190 --> 00:36:30.860
and it allows you to very easily just on the fly
write shaders, experiment with how they fit together,

00:36:30.860 --> 00:36:37.059
and look at the output in a quick-turn kind of
iterative development environment which may not be

00:36:37.059 --> 00:36:40.789
if you're setting a lot of state and trying
to figure out kind of where you went awry,

00:36:40.789 --> 00:36:42.949
it may not be as easy to do.

00:36:42.949 --> 00:36:46.289
It's also, as I said before, you get
direct access to the graphics hardware.

00:36:46.289 --> 00:36:52.130
Vertex shaders, fragment shaders, geometry shaders,
those all allow you direct access to the newest features

00:36:52.130 --> 00:36:56.680
of graphics hardware, and we'll continue
to really focus our effort there.

00:36:56.679 --> 00:36:58.019
And it's fast.

00:36:58.019 --> 00:37:00.759
You can directly access the power of the GPU.

00:37:00.760 --> 00:37:06.180
I'm going to show a few demos, and one of the keys
to programming modern GPUs is understanding kind

00:37:06.179 --> 00:37:09.480
of what Allan was talking about with where your dataflow is.

00:37:09.480 --> 00:37:12.900
Are you taking vertices from the CPU
moving them across a very small bus one

00:37:12.900 --> 00:37:15.760
at a time to the GPU and starving it for data?

00:37:15.760 --> 00:37:21.740
Or are you statically putting your vertices and
your geometry on the GPU and allowing the GPU

00:37:21.739 --> 00:37:24.599
to run full open and run all those effects?

00:37:24.599 --> 00:37:27.429
You want to really minimize those synchronization points.

00:37:27.429 --> 00:37:33.299
You want to maximize the amount of things a GPU can do
on its own without having to come back to your program,

00:37:33.300 --> 00:37:37.370
and a lot of the topics we're talking
about today really are down that road.

00:37:37.369 --> 00:37:44.429
And the GLSL allows you to put programs on the GPU
that run natively on the GPU and stay there, and that's

00:37:44.429 --> 00:37:47.169
where it gets data from and executes data.

00:37:47.170 --> 00:37:52.389
And also really from an industry standpoint with the
ARB and from the Apple, that's our focus moving forward.

00:37:52.389 --> 00:38:01.409
Our focus is going to be GLSL modernized in the
OpenGL API for using programmable hardware.

00:38:01.409 --> 00:38:07.089
So one thing I want to show here is talk
about the fourth generation shader support.

00:38:07.090 --> 00:38:13.370
So there's been some questions. We just brought out
a new laptop with the Invidia 8600 MGT, part energy force,

00:38:13.369 --> 00:38:19.339
G Force 8600 part, and it is a fourth
generation capable shader for Leopard.

00:38:19.340 --> 00:38:23.809
We're going to have geometry shaders,
GPU shader for transformed feedback

00:38:23.809 --> 00:38:28.559
and bindable uniform extensions, all part of the
new modern fourth generation shading extension.

00:38:28.559 --> 00:38:35.639
And what those things are, geometry shaders allow you to
manipulate geometry downstream of the vertex process.

00:38:35.639 --> 00:38:38.219
And so you have a set a vertices maybe that form a triangle.

00:38:38.219 --> 00:38:41.399
Well, that triangle goes into a geometry
shader and you can do things with it.

00:38:41.400 --> 00:38:45.800
GPU shader allows you to use large
texture arrays, integer texture arrays.

00:38:45.800 --> 00:38:52.430
Transform feedback allows that bottom feedback loop that you
may see which allows you to go out from a geometry shader

00:38:52.429 --> 00:38:55.500
back into your inputs and do an iterative on the GPU.

00:38:55.500 --> 00:38:59.260
Again, you're not synchronizing across the
bus, you're not reading it back to the CPU,

00:38:59.260 --> 00:39:04.190
iterative work on the GPU with
using the full power of the GPU.

00:39:04.190 --> 00:39:09.820
And finally bindable uniforms allow you to take these large
constant set, bundle them up in packages and submit them

00:39:09.820 --> 00:39:12.120
to a large number of shaders at one time.

00:39:12.119 --> 00:39:20.509
So for GLSL we're going to talk more in depth tomorrow morning,
but right now I'm just going to go over, do a little demo.

00:39:20.510 --> 00:39:25.510
Show you some of the things we can do with
these new fourth generation shading extensions.

00:39:25.510 --> 00:39:33.760
( Period of silence )

00:39:33.760 --> 00:39:38.630
Okay, this is very much like dinosaurs.

00:39:38.630 --> 00:39:43.269
This is, the only thing interesting here is
that this is running through a geometry shader.

00:39:43.269 --> 00:39:49.909
And when we move to the next version you'll see
that what we have here is exactly what you saw

00:39:49.909 --> 00:39:52.980
on the last one, but all this is occurring on the GPU.

00:39:52.980 --> 00:39:57.920
It's not very interesting in a small shader like
this, but all we sent was the original geometry down,

00:39:57.920 --> 00:40:04.460
all the original vertices, and we then sent a single uniform
at that point to manipulate over time where the inset

00:40:04.460 --> 00:40:08.250
and outset of the new geometry we're
actually coming out of the geometry shader.

00:40:08.250 --> 00:40:11.829
Again, not, not too bad, but we can do better.

00:40:11.829 --> 00:40:15.449
Let's see, let's move up a little bit in the idea here.

00:40:15.449 --> 00:40:17.250
Red dots, ten control points.

00:40:17.250 --> 00:40:18.980
These lines are all draw with 10 control points.

00:40:18.980 --> 00:40:23.990
I didn't send down line segments, I didn't
send down any kind of additional pieces.

00:40:23.989 --> 00:40:26.309
I sent down 10 points to the GPU.

00:40:26.309 --> 00:40:31.389
What we can do is we can-- you'll see that's
really the geometry that you would get

00:40:31.389 --> 00:40:33.639
if you wanted to draw just a line between them.

00:40:33.639 --> 00:40:35.719
Geometry shaders allow you to get line adjacency.

00:40:35.719 --> 00:40:39.169
They allow you to figure out and kind
of trace along your path so to speak.

00:40:39.170 --> 00:40:42.519
So you can add in iterations and you can add in smoothing.

00:40:42.519 --> 00:40:51.190
So you have a-- you can add in a very smooth curve,
and you can, of course, manipulate it in real time,

00:40:51.190 --> 00:40:54.900
again all the program here is doing
is sending down 10 control points.

00:40:54.900 --> 00:40:59.030
Control points are bouncing off the edges and the
rest of the geometry is rendered all in the GPU.

00:40:59.030 --> 00:41:02.300
This is simple for a demo, but obviously
you can expand that and you can see

00:41:02.300 --> 00:41:04.680
if you have very powerful GPUs
you can leave the geometry there.

00:41:04.679 --> 00:41:05.519
( Period of silence )

00:41:05.519 --> 00:41:16.559
This is a fairly simple demo as far as-- this
may be what you, what you'd like to have to see

00:41:16.559 --> 00:41:20.199
if you're having a standard teapot
drawing in your apps that need teapots.

00:41:20.199 --> 00:41:24.589
But really here, we have a fairly high
tessellation and it looks pretty good.

00:41:24.590 --> 00:41:32.340
Both of them, both versions on the left without a geometry
shader and on the right using quadratic normal interpolation

00:41:32.340 --> 00:41:39.490
with the geometry shader where it takes all of the, all
of the information in from each quad, they're equivalent.

00:41:39.489 --> 00:41:46.250
But if I lower my tessellation on this and
you can see it's not very many polygons now.

00:41:46.250 --> 00:41:51.750
That you can see, the highlight stays as a nice
highlight, and so you can get better highlights,

00:41:51.750 --> 00:41:55.630
better geometry information using that geometry
shader because it can look at adjacent points

00:41:55.630 --> 00:42:00.059
and pull out that geometry information, allow you
to do things you couldn't do with high tessellation.

00:42:00.059 --> 00:42:02.239
So instead you would have to send a lot of data down.

00:42:02.239 --> 00:42:06.869
And you can see from the wire frame,
I don't have wire frame for that one.

00:42:06.869 --> 00:42:13.539
So moving up again, this is kind of a standard bump map
demo, and like okay, why are we showing bump map demos?

00:42:13.539 --> 00:42:14.440
That's not very interesting.

00:42:14.440 --> 00:42:18.869
That's like so 1982 or 1992 or 2002.

00:42:18.869 --> 00:42:23.509
What's interesting on this is that the geometry is static.

00:42:23.510 --> 00:42:28.130
It's all sent down and the vertex program
interpolates with the time value, so one uniform.

00:42:28.130 --> 00:42:30.610
Keyframes between them, so it interpolates between them.

00:42:30.610 --> 00:42:32.930
The light vector is sent when the light vector changes.

00:42:32.929 --> 00:42:35.559
The rest is done on the GPU.

00:42:35.559 --> 00:42:39.599
So the GPU takes the light vector in and does
all of the bump mapping actually on the hardware.

00:42:39.599 --> 00:42:41.099
There's no additional light vectors down.

00:42:41.099 --> 00:42:45.159
You don't have to go per poly, per polygon or
per vertex and send additional information.

00:42:45.159 --> 00:42:49.079
So all of the bump mapping is down completely
on the GPU and the CPU is completely idle other

00:42:49.079 --> 00:42:52.210
than sending one time value and one light vector.

00:42:52.210 --> 00:42:53.769
( Period of silence )

00:42:53.769 --> 00:43:00.579
And of course, you'd always want to
add shadows to it, so in this case,

00:43:00.579 --> 00:43:04.539
this is using a geometry shader to generate lines.

00:43:04.539 --> 00:43:06.610
We don't draw any of the original data.

00:43:06.610 --> 00:43:09.000
All we're going to do is look at silhouette edges.

00:43:09.000 --> 00:43:13.579
We're going to use GPU shader, calculate the silhouette
edges and draw lines instead of the original data.

00:43:13.579 --> 00:43:19.710
So GPU shader processing geometry information on the GPU.

00:43:19.710 --> 00:43:20.949
( Period of silence )

00:43:20.949 --> 00:43:27.199
Taking that to another step, in this case,
we have-- we're going to draw shadow volumes.

00:43:27.199 --> 00:43:32.309
This is kind of a visualization of actually what
you would see if you extended shadow volumes.

00:43:32.309 --> 00:43:36.380
In this case, I will show the wire frame, the wire frame you
can see the lines that were generating by the GPU shader.

00:43:36.380 --> 00:43:38.150
Again, additional lines generated.

00:43:38.150 --> 00:43:44.680
And if we fill them in and draw them as filled surfaces,
you can see the shadow volumes from the light source.

00:43:44.679 --> 00:43:58.699
Finally let's put this together and get
a, are lit, bump mapped Quake 2 model,

00:43:58.699 --> 00:44:03.439
but the key here is, again, one light source, one time value.

00:44:03.440 --> 00:44:05.250
The rest of it's all in GPU.

00:44:05.250 --> 00:44:07.030
So this is what geometry shader adds.

00:44:07.030 --> 00:44:12.180
It adds you to do the ability of actually understanding
the geometry sent down, generating geometry

00:44:12.179 --> 00:44:14.409
and allowing you to do these things on the GPU.

00:44:14.409 --> 00:44:17.539
Alleviating the CPU of that, alleviating
the busses of bottleneck,

00:44:17.539 --> 00:44:20.679
allows you to do some great things
using this new technology.

00:44:20.679 --> 00:44:23.440
And this is going to be available in Leopard.

00:44:23.440 --> 00:44:24.210
( Period of silence )

00:44:24.210 --> 00:44:27.380
I'll hand it back over to Allan.

00:44:27.380 --> 00:44:28.849
( Period of silence )

00:44:28.849 --> 00:44:29.259
Thank you.

00:44:29.260 --> 00:44:29.380
( Applause )

00:44:29.380 --> 00:44:30.530
Thanks.

00:44:33.420 --> 00:44:33.950
>> Thanks, sir.

00:44:33.949 --> 00:44:35.509
>> Matching shirts.

00:44:35.510 --> 00:44:37.720
Thank you, Geoff.

00:44:37.719 --> 00:44:41.299
So we'll continue on with our top ten list.

00:44:41.300 --> 00:44:46.750
That was adopting GLSL, certainly something
that we want you all to look into some more.

00:44:46.750 --> 00:44:47.679
And just a reminder.

00:44:47.679 --> 00:44:50.559
So Geoff's session on GLSL is 9:00am tomorrow.

00:44:50.559 --> 00:44:55.049
Come early, get up early, have that morning coffee.

00:44:55.050 --> 00:44:59.039
Number seven, use APPLE_flush_buffer_range.

00:44:59.039 --> 00:45:00.820
It's an extension that we've added.

00:45:00.820 --> 00:45:05.380
And this has to do with vertex buffer
objects and how to make updates to them.

00:45:05.380 --> 00:45:09.190
So going back to our chart, our diagram again.

00:45:09.190 --> 00:45:15.420
So the issue with vertex buffer objects is that when
you do what I said before and you just call map,

00:45:15.420 --> 00:45:21.500
what that does is to just calls, sorry, it
copies the data of those objects into your--

00:45:21.500 --> 00:45:24.610
or it maps it into your local address space.

00:45:24.610 --> 00:45:31.590
And then if you go and make some modification to one of
those objects, when you call unmap what's going to happen is

00:45:31.590 --> 00:45:35.650
that the entire object is going to get copied back to the GPU.

00:45:35.650 --> 00:45:36.710
And that's inefficient.

00:45:36.710 --> 00:45:41.619
If you have some really big object, you're just
changing one byte, it's going to copy the whole thing back.

00:45:41.619 --> 00:45:48.750
So instead what flush_buffer_range lets you
do is to just, come on baby, there we go.

00:45:48.750 --> 00:45:49.500
All right.

00:45:49.500 --> 00:45:52.210
Well, it didn't quite show it.

00:45:52.210 --> 00:45:57.130
What flush_buffer_range lets you do
is if you make a change to an object,

00:45:57.130 --> 00:46:01.470
you can say, okay, just copy back the part that I changed.

00:46:01.469 --> 00:46:04.279
And so that way you're being much more efficient.

00:46:04.280 --> 00:46:09.340
If you make multiple changes, you're able
to, you know, say exactly where they are

00:46:09.340 --> 00:46:11.490
and only those parts gets, get copied back.

00:46:11.489 --> 00:46:16.089
And so you end with a much more efficient
transfer here for when you're modifying the data.

00:46:16.090 --> 00:46:18.130
So the steps here are really pretty easy.

00:46:18.130 --> 00:46:25.280
The first is just you essentially start by turning off the
default behavior which is to flush the whole thing back.

00:46:25.280 --> 00:46:27.250
And then proceed normally.

00:46:27.250 --> 00:46:32.590
You map the buffer, that copies the buffer into
your, the buffer into your local address space.

00:46:32.590 --> 00:46:39.630
You make some changes to modify it and now you can
go and say explicitly exactly what parts you changed.

00:46:39.630 --> 00:46:41.890
You tell us the offset and the number of bytes.

00:46:41.889 --> 00:46:45.920
And if you make multiple changes in different
locations, you just call this with different offsets

00:46:45.920 --> 00:46:48.829
and bytes, you know call it multiple times.

00:46:48.829 --> 00:46:55.610
And so now when you call unmap buffer, that's you know only
that part is going to get mapped back into the original VBO.

00:46:55.610 --> 00:47:00.510
So that's number seven, use Apple_flush_buffer_range
to modify your VBOs.

00:47:00.510 --> 00:47:03.590
So if you're modifying VBOs, this is critical.

00:47:03.590 --> 00:47:08.260
This is one of those modernization steps that
is going to give you a good performance boost.

00:47:08.260 --> 00:47:09.480
Okay, number eight.

00:47:09.480 --> 00:47:10.139
Going onwards.

00:47:10.139 --> 00:47:12.339
Another buffer object type.

00:47:12.340 --> 00:47:14.210
So frame buffer objects.

00:47:14.210 --> 00:47:18.889
These basically replace code that
used to be dealing with PBuffers.

00:47:18.889 --> 00:47:22.210
And a lot of this is, a lot of
the purpose of using PBuffers

00:47:22.210 --> 00:47:26.340
in the past has been for doing multiple, multipass effects.

00:47:26.340 --> 00:47:32.760
Essentially like our render to texture and then
using the texture in a, in another part of the frame.

00:47:32.760 --> 00:47:36.740
The benefit of frame buffer objects
though is that they don't have to be,

00:47:36.739 --> 00:47:40.899
well, you don't have to switch context
like you do with a PBuffer.

00:47:40.900 --> 00:47:46.980
And so, you know, that ends up giving you a nice performance
boost there and avoiding a sync point in many cases.

00:47:46.980 --> 00:47:52.329
So then there's a more advanced use, that
combinations of frame buffer objects along

00:47:52.329 --> 00:47:56.929
with the other buffer objects can be
used to do a render to vertex array.

00:47:56.929 --> 00:47:58.389
We're not going to show that this year.

00:47:58.389 --> 00:48:02.750
Go look at last year's video if
you want to see an example of that.

00:48:02.750 --> 00:48:04.619
But so just talking about render to texture.

00:48:04.619 --> 00:48:07.900
You know, the basic steps here are, there's two steps.

00:48:07.900 --> 00:48:14.369
You know, in the first step we're going to take our normal
geometry, we're going to render it normally using OpenGL.

00:48:14.369 --> 00:48:18.239
But instead of rendering into the frame buffer
we're going to render into a frame buffer object.

00:48:18.239 --> 00:48:23.019
And you get that result sitting there,
and it's basically now just a texture.

00:48:23.019 --> 00:48:30.000
And you can use that texture in the second pass and
put it on some arbitrary geometry, of course, a teapot.

00:48:30.000 --> 00:48:35.469
And render that normally into the normal frame
buffer and you end up, you know, with that result.

00:48:35.469 --> 00:48:39.439
So that's just, that's the basic
concept of a render to texture.

00:48:39.440 --> 00:48:42.900
So to use frame buffer objects here, here are the steps.

00:48:42.900 --> 00:48:47.220
The first is to bind the frame
buffer and then attach a texture ID

00:48:47.219 --> 00:48:50.849
that is going to be the destination
or, you know, the output of that.

00:48:50.849 --> 00:48:53.069
You check to make sure that everything is complete.

00:48:53.070 --> 00:48:58.250
And then you can do whatever normal
OpenGL operations you want.

00:48:58.250 --> 00:49:04.590
And those are going to end up instead of in the regular
frame buffer, they're going to end up in that texture.

00:49:04.590 --> 00:49:09.710
Now you're done, and so you bind, you put everything
back to normal, bind to the default frame buffer.

00:49:09.710 --> 00:49:14.400
And now you can go and do a second pass
using that texture ID that you generated,

00:49:14.400 --> 00:49:17.670
or the texture that you generated the first time around.

00:49:17.670 --> 00:49:20.450
So that is number eight.

00:49:20.449 --> 00:49:28.579
Replace. Replace uses of PBuffers or render to
texture with frame buffer objects instead.

00:49:28.579 --> 00:49:32.289
Number nine, pixel buffer objects.

00:49:32.289 --> 00:49:33.449
Seems like it's the same thing.

00:49:33.449 --> 00:49:35.529
Wasn't I just talking about PBuffers, pixels?

00:49:35.530 --> 00:49:37.950
No, this is a different feature.

00:49:37.949 --> 00:49:43.259
It's a part of the OpenGL 2.1 specification
now which we're supporting in Mac OS X Leopard.

00:49:43.260 --> 00:49:50.450
The main value here is to, for really fast copies of pixel
data between the different buffer objects without having

00:49:50.449 --> 00:49:55.299
to come back to the GPU to do like a read
back and then send it back down again.

00:49:55.300 --> 00:49:59.970
The main purpose that we see a
lot of-- or we expect you to use this

00:49:59.969 --> 00:50:04.989
for is this actually could be a faster
way for you guys to do glReadPixels.

00:50:04.989 --> 00:50:10.989
There's also a number of different things that are more
advanced, render-to-vertex arrays, streaming, and so on.

00:50:10.989 --> 00:50:16.009
But asynchronous glReadPixels is something that could
give you a big benefit, because as I mentioned before,

00:50:16.010 --> 00:50:20.760
ReadPixels is one of those really,
really heavy-weight sync points.

00:50:20.760 --> 00:50:25.000
And so, you know, usually you might have
code that looks kind of like this, right?

00:50:25.000 --> 00:50:32.679
You have glReadPixels, you're passing in a particular
format and you're getting back some result, right?

00:50:32.679 --> 00:50:38.039
So the idea here, you probably have something like this
in your code, just you know with other stuff around it.

00:50:38.039 --> 00:50:42.099
Well, here's what I want you to surround this call with.

00:50:42.099 --> 00:50:46.369
You want to augment it now with a call to, or with PBOs.

00:50:46.369 --> 00:50:55.009
So the first is to just bind the PBO as the new destination
for where you're glReadPixels is going to end up.

00:50:55.010 --> 00:50:58.880
So you notice instead of result
now on number two we have offset.

00:50:58.880 --> 00:51:02.750
So that's just you know an offset into the PBO.

00:51:02.750 --> 00:51:07.190
We make the glReadPixels call as
before, but now you're asynchronous.

00:51:07.190 --> 00:51:08.570
It's decoupled.

00:51:08.570 --> 00:51:11.410
And so you don't want for it to complete.

00:51:11.409 --> 00:51:13.679
You go off and you do other work.

00:51:13.679 --> 00:51:18.069
Go do something, have you know a cup of
coffee when you're out of that teapot.

00:51:18.070 --> 00:51:21.750
And so, just kidding, but you know go do some other work.

00:51:21.750 --> 00:51:27.579
And then insert enough time essentially so that
when you come back and you call map buffer,

00:51:27.579 --> 00:51:31.719
the glReadPixels will have completed in that time.

00:51:31.719 --> 00:51:33.139
And it's, it's asynchronous.

00:51:33.139 --> 00:51:36.739
So if it's completed, you'll get
the pointer back immediately.

00:51:36.739 --> 00:51:40.389
If it hasn't completed yet, this
will block until it's complete.

00:51:40.389 --> 00:51:43.279
Okay? And then when you call unmap buffer...

00:51:43.280 --> 00:51:48.180
Oh, and then unmap the buffer to, to clean up.

00:51:48.179 --> 00:51:50.269
Okay, so actually I want to bring Geoff back up.

00:51:50.269 --> 00:51:55.280
We have a really interesting demo that's using
these techniques for read back and so on.

00:51:55.280 --> 00:51:55.910
So Geoff.

00:51:55.909 --> 00:51:56.679
>> Thanks.

00:51:56.679 --> 00:51:57.299
So thanks, Allan.

00:51:57.300 --> 00:51:57.840
( Applause )

00:51:57.840 --> 00:52:06.530
So we're going to show, we're going to talk to the same,
basically the same demo we did on Monday afternoon

00:52:06.530 --> 00:52:08.360
but we're going to talk about the techniques behind it.

00:52:08.360 --> 00:52:13.090
Blizzard has done a great job of using PBO
and using some techniques here to get a,

00:52:13.090 --> 00:52:15.700
really an interesting user enhancement in World of Warcraft.

00:52:15.699 --> 00:52:18.980
So let me jump right into the demo, and
we'll talk through what they're doing.

00:52:18.980 --> 00:52:24.250
They've allowed us to kind of glimpse into their app a bit.

00:52:24.250 --> 00:52:28.269
So as far as you know kind of how this works.

00:52:28.269 --> 00:52:35.340
So we talked about before is that in the next
major release of World of Warcraft for Mac OS X,

00:52:35.340 --> 00:52:43.030
you'll be able to capture movies in real time and compress
them on the fly for documenting your greatest heroics.

00:52:43.030 --> 00:52:45.970
And so what we're going to do is we're
going to do that and then talk

00:52:45.969 --> 00:52:49.699
about exactly how Blizzard kind of
implemented this behind the scenes.

00:52:49.699 --> 00:52:52.469
And so you can do something in your app the same way.

00:52:52.469 --> 00:52:58.719
I think there's a big community now of, of capturing you
know either, whether it's a scientific visualization app,

00:52:58.719 --> 00:53:01.189
whether it's a game, whether it's movie playback, it,

00:53:01.190 --> 00:53:04.690
you'll want to get this data back off the
GPU and this is a great way to do it

00:53:04.690 --> 00:53:08.349
So we're here, I'm running again on my laptop.

00:53:08.349 --> 00:53:10.909
It doesn't require the highest end hardware.

00:53:10.909 --> 00:53:13.379
It is, you know, depending on the amount of
hard drive space you have and the amount

00:53:13.380 --> 00:53:16.809
of how fast your hard drive does
depend on how fast you can stream.

00:53:16.809 --> 00:53:24.389
But this is a, this is a current laptop and we have
all of the visual options turned on to maximum.

00:53:24.389 --> 00:53:26.639
So everything is turned up there.

00:53:26.639 --> 00:53:28.859
And let's look again at the Mac options.

00:53:28.860 --> 00:53:33.170
In this case, I'm going to capture 800 by 600, a
little bit smaller than I did on the Mac Pro,

00:53:33.170 --> 00:53:38.539
but it's 20 frames per second, and then I'm going to
use H264 so we can use it, iPods, Apple TVs,

00:53:38.539 --> 00:53:40.429
iPhones, websites, whatever you want to do here.

00:53:40.429 --> 00:53:46.559
And we just jump right in and talk about the,
actually I'm going to show the demo of the video capture.

00:53:46.559 --> 00:53:52.969
And again, the big thing is here that I can
start the capture and we have an icon that came

00:53:52.969 --> 00:53:55.969
up in the upper corner here that
shows it, the movie capture is going.

00:53:55.969 --> 00:53:59.129
But you know, it's, you know, you have
a good play-- everything looks nice.

00:53:59.130 --> 00:54:05.890
It plays well and there's no problems with, with
playing the game while you're doing video capture.

00:54:05.889 --> 00:54:11.949
And one thing, I'll jump in on, I'm probably going to get
this wrong, but Rob can correct me later if I'm, if I do.

00:54:11.949 --> 00:54:17.189
I'm going to do the capture, I'm going to start
compression now because this is a little demo.

00:54:17.190 --> 00:54:21.179
Your, if you go into the movie control
panel it's also just limited by hard drive space.

00:54:21.179 --> 00:54:22.989
Because basically, from a technique standpoint,

00:54:22.989 --> 00:54:24.329
what have they done so far?

00:54:24.329 --> 00:54:30.090
So they took the frame, and they've rendered it
into basically a texture, rendered it onto the GPU.

00:54:30.090 --> 00:54:32.610
So we kept, we did that work on the GPU.

00:54:32.610 --> 00:54:39.579
Also they rerendered to a 12-bit YUV buffer on
the GPU to get the data as small as possible.

00:54:39.579 --> 00:54:41.049
So we're dealing with the smallest piece of data.

00:54:41.050 --> 00:54:47.310
They then use the technique that Allan described to map
this as a PBO and use glReadPixels to pull it back.

00:54:47.309 --> 00:54:53.750
And when they pulled it back, they try and they do that
on, they do that and it gets back into the system memory.

00:54:53.750 --> 00:54:56.480
One thing is here is there's a synchronization on this.

00:54:56.480 --> 00:55:00.760
So if you only have one buffer and you're trying
to read that back for the next frame needs a buffer

00:55:00.760 --> 00:55:02.490
and you're kind of, so they set up a round robin.

00:55:02.489 --> 00:55:04.089
So they have three buffers in flight.

00:55:04.090 --> 00:55:09.160
And they always try and keep you know the, they try and as
Rob describes when he's talking about it, is it's a juggler.

00:55:09.159 --> 00:55:10.480
You always try and keep some things in flight.

00:55:10.480 --> 00:55:14.610
You're only working to draw one
and receive one at the same time.

00:55:14.610 --> 00:55:19.180
And you have to experiment in your app depending on how big
your frames are, how much bandwidth you're using that kind

00:55:19.179 --> 00:55:21.879
of thing to determine what the
right asynchronicity is there.

00:55:21.880 --> 00:55:24.490
But again, the theme of the talk is about asynchronicity.

00:55:24.489 --> 00:55:29.689
So we have this asynchronous mapping of,
or asynchronous use of these buffers.

00:55:29.690 --> 00:55:35.480
And it allows the game to continue playing while you're
doing the capture and not really affect the game play.

00:55:35.480 --> 00:55:38.320
Because it keeps it on the GPU.

00:55:38.320 --> 00:55:44.400
Finally the compressing sequence uses QuickTime,
spawns a thread, asynchronous again,

00:55:44.400 --> 00:55:49.050
reads the frames in 12-bit YUV off disk, because
it's a custom fragment program to write that.

00:55:49.050 --> 00:55:51.660
So we compress small, small amounts of data.

00:55:51.659 --> 00:55:54.519
It then does the compression on the fly with QuickTime.

00:55:54.519 --> 00:55:58.119
They've talked about trying to do the compression
in real time because you can imagine if you could do

00:55:58.119 --> 00:56:02.199
that basically you're limited by compressed
space rather than uncompressed frames.

00:56:02.199 --> 00:56:04.149
And that just depends on synchronization.

00:56:04.150 --> 00:56:07.329
If you had an eight core machine or a four core
machine, you probably could get away with it.

00:56:07.329 --> 00:56:12.400
But for the majority of the users of World of Warcraft
and your laptop, you know, you only have a couple cores.

00:56:12.400 --> 00:56:15.059
Maybe a couple years from now.

00:56:15.059 --> 00:56:19.590
But so, you're back at the, back at the
old ranch and you want to show your movies.

00:56:19.590 --> 00:56:23.850
And so we'll go back to here and show the movie.

00:56:23.849 --> 00:56:28.699
And again it's, it was 800 by 600 of it.

00:56:31.360 --> 00:56:31.470
Oops.

00:56:31.469 --> 00:56:31.699
( Period of silence )

00:56:31.699 --> 00:56:35.629
And we should have the standard,
you know, standard movie scrub.

00:56:35.630 --> 00:56:39.190
And it just plays like you would expect.

00:56:39.190 --> 00:56:40.510
( Period of silence )

00:56:40.510 --> 00:56:44.850
So you get, you know, a movie of your
travels, captures your stuff, and you can post it

00:56:44.849 --> 00:56:46.210
to the web, do whatever you'd like with it.

00:56:46.210 --> 00:56:50.730
Again, again as I mentioned before,
Monday, it's a great synergy of technologies,

00:56:50.730 --> 00:56:52.360
has a lot of things that can tie together.

00:56:52.360 --> 00:56:55.800
But the key here is some components from Allan's talk.

00:56:55.800 --> 00:57:01.519
Remove sync points, use asynchronous
PBO API, use multicore.

00:57:01.519 --> 00:57:04.329
Another point is a big point is the multithreaded engine.

00:57:04.329 --> 00:57:10.409
Multithreaded engine really makes this work a lot better
because really you have these sets of the ReadPixels

00:57:10.409 --> 00:57:12.420
in the command queue for the multithreaded engine.

00:57:12.420 --> 00:57:14.000
They're not necessarily being executed by the engine.

00:57:14.000 --> 00:57:15.340
So they can be queued up also.

00:57:15.340 --> 00:57:16.950
So you can get that additional asynchronicity.

00:57:16.949 --> 00:57:19.109
Multithreaded engine, key component here.

00:57:19.110 --> 00:57:24.750
So now we've hit, you know, maybe four or five of your,
of your top ten in implementing a feature like this.

00:57:24.750 --> 00:57:28.900
So I think everyone can go find a place in
their app they can use some of these techniques.

00:57:28.900 --> 00:57:31.340
And I'll hand it back over to Allan.

00:57:31.340 --> 00:57:33.350
>> Great, thanks, Geoff.

00:57:33.349 --> 00:57:36.819
( Applause )

00:57:36.820 --> 00:57:38.250
So thank you, Geoff.

00:57:38.250 --> 00:57:40.510
So that was the end of number nine.

00:57:40.510 --> 00:57:45.300
Move pixels with PBOs to make them asynchronous.

00:57:45.300 --> 00:57:47.700
That takes us to our last one, number ten.

00:57:47.699 --> 00:57:49.549
It's embrace the platform.

00:57:49.550 --> 00:57:56.240
So you know a lot of the OpenGL applications I look
at are trying to do cross-platform stuff and that means

00:57:56.239 --> 00:58:02.939
that when they run on Mac OS X they
look not like a Mac OS X application.

00:58:02.940 --> 00:58:08.510
And so, you know, there's some things that I want to
really, you know, my title is evangelist, so here we go.

00:58:08.510 --> 00:58:16.420
I would really like to, to encourage you guys to think of
places in your application especially if it's cross platform

00:58:16.420 --> 00:58:23.750
or you're bringing it to Mac OS X, where you would use some
of the frameworks that we provide for you rather than kind

00:58:23.750 --> 00:58:30.760
of rolling your own or doing, you know, one of
these cross-platform GUI tool kits and so on.

00:58:30.760 --> 00:58:34.370
So you know, first of all, we want
to encourage you to use Cocoa.

00:58:34.369 --> 00:58:39.409
So use and NSOpenGLView to render your OpenGL.

00:58:39.409 --> 00:58:45.639
And there's a very cool thing that's
now a tie in, related to Core Animation.

00:58:45.639 --> 00:58:51.219
You know a lot of apps that I've looked at over the years
that are trying to like put text or a HUD or something

00:58:51.219 --> 00:58:58.209
up on the screen and they're doing it by rendering, you
know, the letters themselves in like Battle Zone Letter Art.

00:58:58.210 --> 00:59:00.570
You know it doesn't look right.

00:59:00.570 --> 00:59:09.580
And now, you know, with Core Animation, you can render
OpenGL into an OpenGL layer and you can have Cocoa controls

00:59:09.579 --> 00:59:12.460
in another layer right on top it, composited.

00:59:12.460 --> 00:59:13.590
Don't have to do anything.

00:59:13.590 --> 00:59:16.700
You can write those Cocoa controls in Interface Builder.

00:59:16.699 --> 00:59:21.089
You know, it's just-- it's a very seamless
experience for you to go and use.

00:59:21.090 --> 00:59:25.920
So the other thing is, you know, in my job
I see a lot of different applications

00:59:25.920 --> 00:59:27.369
as people are bringing them to the platform.

00:59:27.369 --> 00:59:31.109
And I, I mean we love to get, or you
know, to see applications coming.

00:59:31.110 --> 00:59:34.289
But once, once you've reached
the platform to really modernize,

00:59:34.289 --> 00:59:38.869
you should and give your application
a Mac OS X user experience.

00:59:38.869 --> 00:59:45.299
And what this really means it that if you're using
X11 of GLX or GLUT, or you know, one of these sort

00:59:45.300 --> 00:59:52.330
of, you know, dinosaur windowing models, you
could move to what is native on Mac OS X

00:59:52.329 --> 00:59:59.049
and give your application a much more, a much
better user experience and more of a Mac OS X look.

00:59:59.050 --> 01:00:01.820
And then also other things.

01:00:01.820 --> 01:00:06.320
If your application goes beyond 3D,
think abou=t some of the things

01:00:06.320 --> 01:00:08.990
that you could do with some of our other Cocoa-based UIs.

01:00:08.989 --> 01:00:10.799
So I mentioned Core Animation.

01:00:10.800 --> 01:00:15.480
So you know, Core Animation isn't just about
having, you know, kind of an interesting demo.

01:00:15.480 --> 01:00:19.880
It can really be something that does
something new in your user interface.

01:00:19.880 --> 01:00:24.769
And particularly I want you to look at it
as a way to layer controls into OpenGL.

01:00:24.769 --> 01:00:28.929
And we're kind of jettisoning some of that
old code for doing really weird text

01:00:28.929 --> 01:00:31.829
and stuff on top of the OpenGL rendering.

01:00:31.829 --> 01:00:38.219
If you're doing image processing in your app,
then you probably already know about Core Image,

01:00:38.219 --> 01:00:40.309
because that would be kind of your bread and butter.

01:00:40.309 --> 01:00:46.219
But maybe you're, you just want to do something
like add a, add a transition or add a bloom effect

01:00:46.219 --> 01:00:50.480
or add some other kind of imaging
effect into your application.

01:00:50.480 --> 01:00:56.900
That's something that you could think about implementing
through Core Image in the Mac OS X version of your app.

01:00:56.900 --> 01:01:01.329
If you're bringing video into your app,
maybe you're playing video on a texture.

01:01:01.329 --> 01:01:04.949
The way to do that the right way
on Mac OS X is through Core Video.

01:01:04.949 --> 01:01:10.889
And you can, if you're bringing it in, you can
then pipe that through Core Image on its way

01:01:10.889 --> 01:01:15.599
to apply image processing effects to every frame in
the video and then it ends up in the texture and OpenGL

01:01:15.599 --> 01:01:18.190
and you can use it in all the normal ways.

01:01:18.190 --> 01:01:24.460
And if you're using, if you need to do movie playback
and capture, I want to encourage you to look at QTKit.

01:01:24.460 --> 01:01:30.210
Now there's a QTKit session, Core Image session,
Core Animation sessions here at the show.

01:01:30.210 --> 01:01:33.409
So for more information on those, go to those sessions.

01:01:33.409 --> 01:01:35.469
But really embrace the platform.

01:01:35.469 --> 01:01:41.129
You know I would love to see more like
hardcore OpenGL applications going

01:01:41.130 --> 01:01:46.570
into the best Mac OS X user experience category
at the ADA.

01:01:46.570 --> 01:01:49.000
That's what I want to challenge you with.

01:01:49.000 --> 01:01:54.070
So that was number ten, embrace the
platform, which concludes our top ten list.

01:01:54.070 --> 01:01:59.440
For more information, something I want to
point out for those here is that we're going

01:01:59.440 --> 01:02:06.070
to be issuing an OpenGL seed before Leopard ships.

01:02:06.070 --> 01:02:12.180
And so if you're interesting in getting into the
OpenGL seeding program, send email to that address.

01:02:12.179 --> 01:02:16.259
Secondly, we have a public mailing
list for discussions of OpenGL.

01:02:16.260 --> 01:02:20.660
I want to remind you that what we discuss
here at the conference is confidential.

01:02:20.659 --> 01:02:24.909
But for, you know, you want to get on that list
just to kind of find out what's going on.

01:02:24.909 --> 01:02:29.109
And then you can find documentation
and that's my email address there.

01:02:29.110 --> 01:02:31.269
A few other things just before we wrap up.

01:02:31.269 --> 01:02:34.670
So these are the other OpenGL
sessions that are going to be happening.

01:02:34.670 --> 01:02:41.980
And so sort of depending on where you fit in, if you're
more advanced, you want to go to the GLSL and Tuning.

01:02:41.980 --> 01:02:44.990
If you're coming from another platform,
you probably want to go to switching.

01:02:44.989 --> 01:02:46.589
Everybody should come to the lab.
WEBVTT

00:00:15.369 --> 00:00:16.699
>> Good afternoon.

00:00:16.699 --> 00:00:18.489
Welcome to Cocoa Today.

00:00:18.489 --> 00:00:24.599
( Applause )

00:00:24.600 --> 00:00:29.100
>> My name is Ali Ozer, I'm the manager of the
Cocoa Frameworks Team at Apple.

00:00:29.100 --> 00:00:30.870
So today we have a pretty packed agenda.

00:00:30.870 --> 00:00:36.039
The bulk of the talk is about what's new in Leopard,
and the highlights of what we've added to Leopard.

00:00:36.039 --> 00:00:39.799
Before but that I am just going spend a
few minutes talking about what Cocoa is.

00:00:39.799 --> 00:00:42.939
Especially for those of you who are
new to the platform or new to Cocoa.

00:00:42.939 --> 00:00:44.960
And then at the end we're going
to spend a few minutes talking

00:00:44.960 --> 00:00:48.910
about best practices in creating your Leopard application.

00:00:48.909 --> 00:00:50.779
So what is Cocoa?

00:00:50.780 --> 00:00:56.929
Cocoa is the term we use for the object-oriented frameworks
for developing fuel featured applications on Mac OS X.

00:00:56.929 --> 00:01:01.570
And when we say Cocoa, we often refer
to the three-core Cocoa frameworks,

00:01:01.570 --> 00:01:05.069
Foundation Kit, which is the non UI layer of Cocoa.

00:01:05.069 --> 00:01:11.069
Core Data, which is the data model and persistency
layer, and AppKit, which is the UI layer of Cocoa.

00:01:11.069 --> 00:01:17.309
Now Cocoa sits in the system next to Carbon
and Java, which are the application frameworks.

00:01:17.310 --> 00:01:22.390
Above this, of course, are applications, and below this
layer are Darwin, and of course the graphics layer.

00:01:22.390 --> 00:01:28.689
Quartz, OpenGL, Core Animation, and QuickTime, and so on.

00:01:28.689 --> 00:01:33.280
Now this is -- if there is one thing that
embodies a philosophy of Cocoa, it is this;

00:01:33.280 --> 00:01:36.159
imple things simple, complex things possible.

00:01:36.159 --> 00:01:38.420
If you've been to WWDC before you've probably heard this.

00:01:38.420 --> 00:01:39.820
You might have read it places.

00:01:39.819 --> 00:01:42.339
But this is basically how we design Cocoa.

00:01:42.340 --> 00:01:49.109
Try to make simple, obvious things that all
applications have to do simple, but also enable things,

00:01:49.109 --> 00:01:51.719
complex things that you want to do in your applications.

00:01:51.719 --> 00:01:56.409
And we're going to go and give examples
of this throughout the talk today.

00:01:56.409 --> 00:02:01.739
Now one thing this doesn't mean is that Cocoa is simple.

00:02:01.739 --> 00:02:03.390
What do I mean by that?

00:02:03.390 --> 00:02:06.329
Cocoa is not something you're going
to learn from a quick reference card.

00:02:06.329 --> 00:02:08.150
You know, sometimes people think oh, I'll go to WWDC

00:02:08.150 --> 00:02:11.909
and afterwards I'll write applications
that evening or something.

00:02:11.909 --> 00:02:14.090
And that's definitely not the case.

00:02:14.090 --> 00:02:15.840
With Cocoa, there are a number of things to learn.

00:02:15.840 --> 00:02:21.659
You're going to learn the APIs, the program interfaces,
the conventions, the best practices, and Objective-C.

00:02:21.659 --> 00:02:27.229
And I am actually going to talk about these
at various points during the talk today.

00:02:27.229 --> 00:02:34.469
But once you learn Cocoa, once you've, you know, learned
all these things I showed you, you're actually enabled

00:02:34.469 --> 00:02:39.719
to do much more, be much more productive
with much less code and effort.

00:02:39.719 --> 00:02:45.319
With Cocoa, the philosophy is we write the common
code, you write the things that distinguish your app.

00:02:45.319 --> 00:02:49.000
And of course the less code you write, the less code
you have to debug, the less code you have to maintain,

00:02:49.000 --> 00:02:52.580
and more of your functionality your leveraging.

00:02:52.580 --> 00:02:57.480
Now, sometimes people see demos of Cocoa, you know,
somebody gets on stage, puts together a calculator app

00:02:57.479 --> 00:03:02.840
or a temperature converter app, or a recipe app -- and
you know, the app is nice and simple, and looks great.

00:03:02.840 --> 00:03:04.300
And doesn't require any code.

00:03:04.300 --> 00:03:06.900
And you know, folks get the impression Cocoa is great.

00:03:06.900 --> 00:03:09.219
But it's for simple applications.

00:03:09.219 --> 00:03:10.909
And that's not quite true.

00:03:10.909 --> 00:03:15.740
There are many, many applications out there,
many powerful and sophisticated applications.

00:03:15.740 --> 00:03:17.310
Some of these are from Apple.

00:03:17.310 --> 00:03:20.289
And many of those are from third parties like yourselves.

00:03:20.289 --> 00:03:22.979
And there are literally hundreds of applications out there.

00:03:22.979 --> 00:03:26.250
And the good news about these apps,
you know, many of these apps,

00:03:26.250 --> 00:03:30.080
is that they are not only powerful and
sophisticated, they're a joy to use.

00:03:30.080 --> 00:03:31.390
Many of these are applications,

00:03:31.389 --> 00:03:33.819
you just want to, you know, bring up and do things in.

00:03:33.819 --> 00:03:36.180
And you want to get your friends and family to use them.

00:03:36.180 --> 00:03:42.349
And there's, you know , they're not only consistent,
UI powerful, and also a lot of attention to detail.

00:03:42.349 --> 00:03:46.659
In fact, let me -- let me show an example of that.

00:03:46.659 --> 00:03:49.659
Here's the icon for Coda, from Panic.

00:03:49.659 --> 00:03:51.310
An application that was released two months ago.

00:03:51.310 --> 00:03:53.390
And I was looking at this icon -- yeah.

00:03:53.389 --> 00:03:54.329
It's a great app.

00:03:54.330 --> 00:03:55.719
It's a bug development app.

00:03:55.719 --> 00:04:01.219
I was looking at this and I noticed that they
actually have a 5, 12 by 5 icon in their app wrapper.

00:04:01.219 --> 00:04:06.419
And this is what we've been telling people to do as
a forward-looking move for resolution independence.

00:04:06.419 --> 00:04:09.449
And I was looking at this, I was
looking at it a little bit more,

00:04:09.449 --> 00:04:12.419
and I noticed in the stem -- I
don't know if you can see that.

00:04:12.419 --> 00:04:14.259
Let me zoom just a little more.

00:04:14.259 --> 00:04:16.319
There are those little hairs on the stem.

00:04:16.319 --> 00:04:18.279
And those are called try cones, I think.

00:04:18.279 --> 00:04:19.329
If I'm pronouncing it correctly.

00:04:19.329 --> 00:04:21.639
But there's so much detail in here.

00:04:21.639 --> 00:04:24.099
And this is just so today, on the screen.

00:04:24.100 --> 00:04:25.200
You know, you can see that.

00:04:25.199 --> 00:04:29.269
But some day in your super-high resolution display
you'll be able to count the hairs on that leaf.

00:04:29.269 --> 00:04:33.500
So that's great attention to detail there.

00:04:33.500 --> 00:04:38.149
Okay. So let me spend a few minutes
talking about what makes Cocoa powerful.

00:04:38.149 --> 00:04:40.399
Well, as I mentioned, it's object-oriented classes.

00:04:40.399 --> 00:04:46.189
And it's just -- not just any object-oriented
classes, but well-designed object-oriented classes.

00:04:46.189 --> 00:04:50.540
And there's a growing set of powerful libraries.

00:04:50.540 --> 00:04:54.500
I already mentioned AppKit, Core Data,
and Foundation as the core of Cocoa.

00:04:54.500 --> 00:05:00.220
But there's a number of other frameworks that are
on the system and that let you access the back-ends

00:05:00.220 --> 00:05:04.170
of the applications we ship, such as
Address Book, iChat, Calendar Store,

00:05:04.170 --> 00:05:09.460
and of course this graphics capabilities, the input methods
Disc Recording and so on.

00:05:09.459 --> 00:05:13.779
There's a lot of frameworks on the system that are --

00:05:13.779 --> 00:05:16.939
plugged into Cocoa well, and that
you can use in your applications.

00:05:16.939 --> 00:05:20.219
And these use Cocoa conventions,
which are all very consistent.

00:05:20.220 --> 00:05:23.000
I am going to talk about this right now.

00:05:24.550 --> 00:05:31.270
When I say consistent conventions, I mean that all these
APIs that are Cocoa compatible use the same nuts and bolts.

00:05:31.269 --> 00:05:34.769
The common currency of Cocoa applications is NS strings.

00:05:34.769 --> 00:05:37.409
For instance, if you have character
strings you're communicating

00:05:37.410 --> 00:05:39.890
between layers, it's almost always an NS string.

00:05:39.889 --> 00:05:41.680
It's not a (Inaudible) or anything else.

00:05:41.680 --> 00:05:42.750
It's an NS string.

00:05:42.750 --> 00:05:45.730
Similarly, NS arrays, NS datas, NS URL, NS View.

00:05:45.730 --> 00:05:46.990
These are the common currencies.

00:05:46.990 --> 00:05:51.860
So we can take these APIs and plug
them into each other very easily.

00:05:51.860 --> 00:05:56.080
And there's a small number of mechanisms and conventions.

00:05:56.079 --> 00:05:58.639
Here I've listed, you know, five
bullet points worth of them.

00:05:58.639 --> 00:06:04.539
And once you learn these you pretty much become familiar
with 90-95 percent of the paradigms used in Cocoa APIs.

00:06:04.540 --> 00:06:07.790
You know, when you approach a new Cocoa
API you will see, oh, this uses delegation.

00:06:07.790 --> 00:06:08.520
That's great.

00:06:08.519 --> 00:06:09.959
Oh, and this is KVO compliant.

00:06:09.959 --> 00:06:10.789
That's great.

00:06:10.790 --> 00:06:14.890
And object ownership memory management rules,
the last one on that list, as an example.

00:06:14.889 --> 00:06:17.979
We've had these rules for ever since Cocoa's been around.

00:06:17.980 --> 00:06:20.009
And as we move into the world of Garbage Collection,

00:06:20.009 --> 00:06:23.219
it turns out the rules are totally
consistent with garbage collection.

00:06:23.220 --> 00:06:24.240
So there's no change there.

00:06:24.240 --> 00:06:27.379
And if anything, of course, memory
management rules get simpler.

00:06:27.379 --> 00:06:34.699
So again, you learn this small number of mechanisms,
conventions, and you are familiar with a lot of Cocoa APIs.

00:06:34.699 --> 00:06:41.620
Objective-C is a super-set of C. It's
native, and C compatible calling conventions.

00:06:41.620 --> 00:06:45.160
What this means is the way arguments are placed
on the stack under different architectures

00:06:45.160 --> 00:06:48.980
and et cetera, is the same for C and Objective-C.

00:06:48.980 --> 00:06:52.910
And this, of course, means you can
cross-call into C back and forth no problems.

00:06:52.910 --> 00:06:56.370
There's great C++ integration,
even better in Leopard.

00:06:56.370 --> 00:06:58.750
And Objective-C is also very dynamic.

00:06:58.750 --> 00:07:01.829
It's got this great runtime system which can introspect.

00:07:01.829 --> 00:07:07.879
You can ask questions about methods, classes,
et cetera, and using that dynamic functionality,

00:07:07.879 --> 00:07:12.370
it's a bridge to other languages like Ruby and Python.

00:07:12.370 --> 00:07:14.050
Cocoa is not an isolated box.

00:07:14.050 --> 00:07:17.889
It's not -- all this power doesn't come
at the price of having an environment

00:07:17.889 --> 00:07:21.339
which is self-contained and can't
interact with other pieces.

00:07:21.339 --> 00:07:26.169
Since it uses C calling conventions, it can easily
call into APIs such as POSIX.

00:07:26.170 --> 00:07:31.100
You can download pretty much any open source
package from any open source UNIX package

00:07:31.100 --> 00:07:33.860
and integrate it into your Cocoa application no problem.

00:07:33.860 --> 00:07:36.980
And it also interacts with Carbon.

00:07:36.980 --> 00:07:41.620
Before Leopard, the interaction was at the
lower levels, and also at the window layer.

00:07:41.620 --> 00:07:46.480
And in Leopard we now have an HI
Cocoa view type, in HI Toolbox,

00:07:46.480 --> 00:07:50.490
which let's you incorporate Cocoa
views into Carbon applications.

00:07:50.490 --> 00:07:55.220
I am not going to talk much more about this,
but there is a session Thursday afternoon,

00:07:55.220 --> 00:08:02.270
Session 145 where you can hear the HI Toolbox
team talk about this new technology.

00:08:02.269 --> 00:08:09.060
Cocoa is native Mac OS X. Cocoa is not a cross-platform
environment that's been ported to Mac OS X,

00:08:09.060 --> 00:08:12.699
and that repeatedly has to be ported
over and over to keep pace

00:08:12.699 --> 00:08:16.319
with Mac OS X. Cocoa and Mac OS X are very well integrated.

00:08:16.319 --> 00:08:24.670
And as a result Cocoa provides native -- you know,
absolute, great support for Mac OS X features, such as Aqua,

00:08:24.670 --> 00:08:29.150
accessibility, printing, all these features are
defined by Cocoa for the environment, basically.

00:08:29.149 --> 00:08:34.840
And finally, what makes Cocoa powerful are the tools.

00:08:34.840 --> 00:08:38.970
As you heard yesterday, there's a new
version of Interface Builder, IB 3.

00:08:38.970 --> 00:08:44.740
Now interface builder is the user interface design tool,
but it's much more than just a user interface design tool.

00:08:44.740 --> 00:08:50.470
It not only let's you lay out windows views
controls, it also let's you create the relationships

00:08:50.470 --> 00:08:52.990
between these -- object relationships between them.

00:08:52.990 --> 00:08:58.690
It lets you save these out, archive these out,
to files which are read back at the runtime.

00:08:58.690 --> 00:09:00.760
So those objects are brought back to life.

00:09:00.759 --> 00:09:01.879
And this is very powerful.

00:09:01.879 --> 00:09:05.439
You can create a lot of your -- the logic --

00:09:05.440 --> 00:09:11.750
that would normally have required glue code in
IB visually by connecting these objects together.

00:09:11.750 --> 00:09:17.350
It's a very integral part of Cocoa application development.

00:09:17.350 --> 00:09:21.570
Sometimes people ask how can I
create my UI without using IB.

00:09:21.570 --> 00:09:24.190
And you know, that's possible.

00:09:24.190 --> 00:09:28.840
It's totally possible to write dozens or hundreds
of lines of code to sort of establish all that.

00:09:28.840 --> 00:09:30.440
But you know, you really wouldn't want to.

00:09:30.440 --> 00:09:35.480
It's just -- IB is a great time-safer, and it's
an integral part of the development environment.

00:09:35.480 --> 00:09:36.840
Xcode is, of course, the IDE.

00:09:36.840 --> 00:09:38.259
The development environment.

00:09:38.259 --> 00:09:41.610
It not only does project management, it
has features such as syntax coloring,

00:09:41.610 --> 00:09:44.800
code folding, refactoring, data modelling and so on.

00:09:44.799 --> 00:09:47.759
And also the Compiler and the debug tools.

00:09:47.759 --> 00:09:52.439
An important point here is that all of
these features are Objective-C enabled.

00:09:52.440 --> 00:09:54.010
So when you're looking at your Cocoa program,

00:09:54.009 --> 00:09:58.819
when you're looking for your Objective-C program you're
actually doing this in terms much Objective-C methods,

00:09:58.820 --> 00:10:02.390
Objective-C back traces, Objective-C objects.

00:10:02.389 --> 00:10:05.750
And in the tools area we have extra -- Xray now.

00:10:05.750 --> 00:10:08.980
Which is sort of the new uber-tool
for all our new performance tools.

00:10:08.980 --> 00:10:12.789
Xray allows you to look at a bunch of performance --

00:10:12.789 --> 00:10:17.230
let's you do performance measurements
simultaneously on your application.

00:10:17.230 --> 00:10:21.920
Again, all of these measurements it does, it
does it in a way which is Objective-C compatible.

00:10:21.919 --> 00:10:23.189
It knows about Objective-C.

00:10:23.190 --> 00:10:27.870
So again, when you see reports about what's
going on, what objects are being allocated,

00:10:27.870 --> 00:10:34.909
it's all in terms of Objective-C objects and back
traces, and methods it applies to your program.

00:10:34.909 --> 00:10:40.899
Okay. So with that little background to Cocoa, I
am now going to talk about what's new in Leopard.

00:10:40.899 --> 00:10:45.769
Now if you were here last year, you already
heard a lot of stuff we covered at

00:10:45.769 --> 00:10:49.069
a lot of stuff that we added to Leopard already.

00:10:49.070 --> 00:10:52.210
But since then we've added a lot of new stuff.

00:10:52.210 --> 00:10:54.360
Now a lot of this stuff is in the Release Notes.

00:10:54.360 --> 00:10:56.669
And a bunch of it's also been documented.

00:10:56.669 --> 00:10:58.169
Today we're sort of going to be unfair.

00:10:58.169 --> 00:11:01.549
We're only going could cover some of the highlights
and some of the exemplary items, you know.

00:11:01.549 --> 00:11:05.379
We're not going to go into detail about everything we've
added into Leopard because there is just way too much.

00:11:05.379 --> 00:11:07.399
But we will cover the highlights.

00:11:07.399 --> 00:11:10.549
So we're going to do it in five areas.

00:11:10.549 --> 00:11:12.309
The first one is definitely where the bulk is.

00:11:12.309 --> 00:11:16.699
We're going to talk about UI followed
by the other areas of Cocoa.

00:11:16.700 --> 00:11:20.009
So yesterday you heard about this from both Steve's talk

00:11:20.009 --> 00:11:23.149
and also Scott Forstall's talk in State of the Union.

00:11:23.149 --> 00:11:24.189
We have a new window up here.

00:11:24.190 --> 00:11:28.730
And so basically there's one look
and feel for title and tool bars.

00:11:28.730 --> 00:11:30.460
And there's no more metal.

00:11:30.460 --> 00:11:34.430
Now we used to have this textured background style.

00:11:34.429 --> 00:11:37.199
Which indicated that a window should be metal.

00:11:37.200 --> 00:11:41.950
It now simply indicates whether the title
tool bar gradient continues down the window.

00:11:41.950 --> 00:11:47.420
So the way the gradient continues is there is a
light to -- sort of a darker gradient at the top.

00:11:47.419 --> 00:11:49.829
Then there is a solid body, which will grow.

00:11:49.830 --> 00:11:55.520
And then in addition there is another gradient from
that solid color to a darker color at the bottom.

00:11:55.519 --> 00:11:58.240
So this is what you get if you use textured windows.

00:11:58.240 --> 00:12:01.180
There's content in that window,
those gradients will be adjusted.

00:12:01.179 --> 00:12:02.199
And there are ways to tweak that.

00:12:02.200 --> 00:12:07.030
I am not going to talk more about textures windows,
because in general we want you to use non-textured windows.

00:12:07.029 --> 00:12:11.250
But this is just to show you how a textured window behaves.

00:12:11.250 --> 00:12:13.450
Now examples of non textured windows, for instance,

00:12:13.450 --> 00:12:18.150
your common text document window is
an example of a non textured window.

00:12:18.149 --> 00:12:21.269
Another example is preferences and preview.

00:12:21.269 --> 00:12:27.449
There's a solid color in the background of non
textured windows that you can place Aqua controls on.

00:12:27.450 --> 00:12:30.370
And here's another example of a non textured window.

00:12:30.370 --> 00:12:32.060
The Font Book application.

00:12:32.059 --> 00:12:37.250
Now at this point, though, you might be saying,
hey, there's a gradient border at the bottom.

00:12:37.250 --> 00:12:39.299
Doesn't this make this is a textured window?

00:12:39.299 --> 00:12:42.219
And the answer is no.

00:12:42.220 --> 00:12:47.950
This is a lighter gradient -- in fact this gradient
is sort of similar to the gradient at the top.

00:12:47.950 --> 00:12:53.930
We put a lighter grade in at the bottom as a way to
enable black text to be easily visible on that area.

00:12:53.929 --> 00:12:59.849
So you would use this gradient if you want to put
controls or text as a -- sort of an alternate bottom bar.

00:12:59.850 --> 00:13:02.820
Analogous to the tool bar on your window.

00:13:02.820 --> 00:13:05.110
So how do you enable this?

00:13:05.110 --> 00:13:09.600
There's an API which let's you set the
content border thickness for an edge.

00:13:09.600 --> 00:13:13.600
For non textured windows, the only edge
that is valid for today is the bottom edge.

00:13:13.600 --> 00:13:15.580
So we would go ahead and specify this.

00:13:15.580 --> 00:13:21.940
And when you do that, that's where you, you know, this
is the bottom content border you would be specifying.

00:13:21.940 --> 00:13:25.500
And then you would go in and put
your custom controls in there.

00:13:25.500 --> 00:13:29.720
Now the other kind of window style is
this HUD, that's Heads Up Display windows.

00:13:29.720 --> 00:13:31.899
Scott also went into this yesterday.

00:13:31.899 --> 00:13:33.730
They can be borderless.

00:13:33.730 --> 00:13:35.519
Or they can be titled.

00:13:35.519 --> 00:13:38.889
And they are, of course, partially transparent.

00:13:38.889 --> 00:13:42.159
Now heads up display windows are not
the general replacement for panels.

00:13:42.159 --> 00:13:45.879
You shouldn't be replacing every panel in
your application with a Heads Up Display.

00:13:45.879 --> 00:13:48.320
You would use them where the transparency is useful.

00:13:48.320 --> 00:13:51.300
For instance, full screen applications.

00:13:51.299 --> 00:13:54.879
And they are mostly for transient usages.

00:13:54.879 --> 00:13:59.370
Like non modal panel, non -- such
as the font panel, color panel,

00:13:59.370 --> 00:14:01.560
the user might bring up and leave it up there for a while.

00:14:01.559 --> 00:14:06.859
But if they just want to bring up something, tweak
it, and dismiss it, maybe a HUD window is appropriate.

00:14:06.860 --> 00:14:10.680
And it's also a convenient alternate
access to existing functionality.

00:14:10.679 --> 00:14:13.000
An example here is Xray.

00:14:13.000 --> 00:14:15.610
Yeah, Xray has a big window where
you have all your controls.

00:14:15.610 --> 00:14:19.529
But if you minimize your Xray window,
it turns into a HUD window that's on top

00:14:19.529 --> 00:14:24.740
of whatever you're trying to --
whatever you're trying to measure.

00:14:24.740 --> 00:14:27.700
So here's what a HUD window looks
like in preview screen mode.

00:14:27.700 --> 00:14:29.920
It's giving you slideshow capabilities.

00:14:29.919 --> 00:14:32.659
And here's another example.

00:14:32.659 --> 00:14:34.629
The HUD windows in iPhoto.

00:14:34.629 --> 00:14:36.610
Now you will see three HUD windows at the top.

00:14:36.610 --> 00:14:38.490
And then there's one more HUD window at the bottom.

00:14:38.490 --> 00:14:40.659
I hope you can see this all the way at the bottom.

00:14:40.659 --> 00:14:47.750
But one thing to note about this HUD window is that
there is a pop up and a slider in this HUD window.

00:14:47.750 --> 00:14:51.580
Now, these are HUD -- what we call HUD style controls.

00:14:51.580 --> 00:14:55.280
And we don't yet have support for
this in the AppKit in Leopard.

00:14:55.279 --> 00:14:58.439
As you will notice, the other HUD
windows in here don't use controls,

00:14:58.440 --> 00:15:01.220
they basically just use text items or images, whatever.

00:15:01.220 --> 00:15:03.230
These are all things that can be easily done.

00:15:03.230 --> 00:15:06.570
But if you wish to put controls like this in
your HUD windows, you're sort of on your own.

00:15:06.570 --> 00:15:12.129
And either you can put Aqua controls or maybe
avoid those controls in HUD windows all together.

00:15:13.250 --> 00:15:14.970
So resolution dependence.

00:15:14.970 --> 00:15:19.460
If I were to put up one picture to define
resolution dependence, it would be this.

00:15:19.460 --> 00:15:25.810
Basically goes to show ability to draw standard controls
and other drawing at -- in the resolution-dependent matter.

00:15:25.809 --> 00:15:31.889
In this case they're being drawn at 8x. And we
have now enabled this resolution-dependent drawing

00:15:31.889 --> 00:15:39.210
so that the same resolution drawing code path
is used for 1x, 2x, whatever you've chosen.

00:15:39.210 --> 00:15:44.450
So this is the way things would look like before
in 8x, and this is the way they look after.

00:15:44.450 --> 00:15:46.170
So before; after.

00:15:46.169 --> 00:15:49.289
So there is -- there is a difference there.

00:15:49.289 --> 00:15:51.419
Now here's a little fun fact for you.

00:15:51.419 --> 00:15:52.179
Don't tell anyone.

00:15:52.179 --> 00:15:54.909
But I am just going -- just between us.

00:15:54.909 --> 00:16:02.269
If you hold down Command Control Option
3, your front-most app will switch back

00:16:02.269 --> 00:16:06.629
and forth to using resolution dependence
drawing and non resolution dependence drawing.

00:16:06.629 --> 00:16:08.919
This little debugging aid we added in there.

00:16:08.919 --> 00:16:13.240
And you can actually see some sort of a difference
even at 1x, between the resolution dependent

00:16:13.240 --> 00:16:15.430
and the non resolution dependent drawing.

00:16:15.429 --> 00:16:16.959
So you can play with this right now.

00:16:16.960 --> 00:16:21.340
Show you the debugging aid to see how it might
be effecting your applications, if at all.

00:16:21.340 --> 00:16:24.250
It's something we intend to remove for the final release.

00:16:24.250 --> 00:16:25.779
Assuming we don't forget.

00:16:25.779 --> 00:16:28.789
( Laughter )

00:16:28.789 --> 00:16:34.959
>> Now, along with resolution dependence we've also
added support for resolution independent NS Images.

00:16:34.960 --> 00:16:37.540
That's are a number of standard images.

00:16:37.539 --> 00:16:38.870
Here are a few examples.

00:16:38.870 --> 00:16:42.019
And this is just the small -- a
small set that I am showing you.

00:16:42.019 --> 00:16:44.000
Info, color panel, network, et cetera.

00:16:44.000 --> 00:16:45.960
And let me just expand one of them.

00:16:45.960 --> 00:16:48.360
Here's, for instance, the image that corresponds to network.

00:16:48.360 --> 00:16:50.899
Now these are resolution independent.

00:16:50.899 --> 00:16:54.519
They have a size, a conical size they have, that they use.

00:16:54.519 --> 00:16:59.939
But if you wish to draw them at any other size, they
will accommodate you and look pretty, like this.

00:16:59.940 --> 00:17:03.340
Now the way you access these images
is with the API we had for years.

00:17:03.340 --> 00:17:04.870
NS Image image named.

00:17:04.869 --> 00:17:07.739
You would say NS Image image named.

00:17:07.740 --> 00:17:11.000
Network. Now, a word of warning here.

00:17:11.000 --> 00:17:13.400
You look at this beautiful network
image and you might be tempted.

00:17:13.400 --> 00:17:18.650
For instance, you might say I'm writing a fantasy
game and I really need a gray, magical orb.

00:17:18.650 --> 00:17:20.880
The network image looks great.

00:17:20.880 --> 00:17:24.520
So you would say, my gray magic
orb is now the network image.

00:17:24.519 --> 00:17:25.579
The word of warning is this.

00:17:25.579 --> 00:17:30.829
In the next release we might decide to represent network,
we're going to start using, say, a coaxial cable.

00:17:30.829 --> 00:17:33.879
So suddenly your wizards in the fancy
game are walking around with a bag

00:17:33.880 --> 00:17:36.930
of coaxial cables, which is not quite what you wanted.

00:17:36.930 --> 00:17:38.320
So this is a no-no.

00:17:38.319 --> 00:17:44.849
Typically when you're using these images, please use them,
you know, just look at the name, see what the name defines,

00:17:44.849 --> 00:17:47.480
look at the documentation and use
them just for that purpose.

00:17:47.480 --> 00:17:50.769
Don't misuse them, otherwise you might
be surprised in the next release.

00:17:50.769 --> 00:17:56.319
The intent here is these images are there to give
you a common look and feel across all applications.

00:17:56.319 --> 00:18:04.369
Now another set of resolution and NS Images are
these template images, and you can recognize these

00:18:04.369 --> 00:18:06.819
because they have the word template at the end of the name.

00:18:06.819 --> 00:18:09.659
Now these are monochromatic by default.

00:18:09.660 --> 00:18:12.860
I believe they are gray if you try to draw them as is.

00:18:12.859 --> 00:18:18.579
However, the intent here is that you would put them -- these
in NS cells, and then you would set the background style,

00:18:18.579 --> 00:18:22.399
or you would put them in standard cells like
button cells, and the right thing would happen.

00:18:22.400 --> 00:18:22.800
For instance.

00:18:22.799 --> 00:18:27.109
If you add template image into a
gradient button, this is the way it looks.

00:18:27.109 --> 00:18:29.729
It actually has a little bit of embossing in there.

00:18:29.730 --> 00:18:30.960
I don't know if you can see it.

00:18:30.960 --> 00:18:36.579
So depending on the context, these images about be
processed by NS Cell, and appear in an appropriate map.

00:18:36.579 --> 00:18:42.759
And you can go ahead and use a cell, a pretty vanilla
cell, to draw these in your own contexts if you wish.

00:18:42.759 --> 00:18:45.470
Now here's one more thing to notice.

00:18:45.470 --> 00:18:50.640
The last two images to go right and
right-facing triangle are the same.

00:18:50.640 --> 00:18:53.650
Here we wanted -- you know, the
temptation here might be too great.

00:18:53.650 --> 00:18:55.630
Because let's say you need a right-facing triangle.

00:18:55.630 --> 00:18:59.350
If we don't provide that, you might
have used the go right image to do that.

00:18:59.349 --> 00:19:04.250
Again, to remove the temptation of using the go right
image in place of triangle, we're providing both.

00:19:04.250 --> 00:19:06.059
Currently, they have to be the same image.

00:19:06.059 --> 00:19:08.690
But in the next release, if the go right image changes to --

00:19:08.690 --> 00:19:12.769
for instance a sign post or a finger
pointing right, the triangle will not change.

00:19:12.769 --> 00:19:15.700
So use the appropriate one.

00:19:15.700 --> 00:19:18.980
There are two talks which will go into more --

00:19:18.980 --> 00:19:22.650
which will give you a lot of information
on drawing and images and cells.

00:19:22.650 --> 00:19:26.509
And those are tomorrow morning at 9,
the customs controls for Cocoa talk.

00:19:26.509 --> 00:19:31.089
And then at 10:30, the Cocoa drawing techniques talk.

00:19:31.089 --> 00:19:32.389
Accessory views and alerts.

00:19:32.390 --> 00:19:34.280
This is something that you've asked for a lot.

00:19:34.279 --> 00:19:36.410
And we finally have it in Leopard.

00:19:36.410 --> 00:19:38.269
Basically, alerts are simple to use.

00:19:38.269 --> 00:19:42.490
You just -- one line and then you can put
up an alert panel, with, you know, cancel,

00:19:42.490 --> 00:19:44.450
install, okay, whatever your buttons are.

00:19:44.450 --> 00:19:47.640
But if you want to customize it, it
was fairly difficult to do before.

00:19:47.640 --> 00:19:53.780
Now we have a way to do that and as you might except,
the API parallels the other API in panels to do this.

00:19:53.779 --> 00:19:55.319
Set accessory view accessory.

00:19:55.319 --> 00:19:56.029
That's it.

00:19:56.029 --> 00:20:00.690
You create your own custom view in IB,
you know, IB is the usual way to do it.

00:20:00.690 --> 00:20:04.710
And then you would give it to the alert panel
and bingo, you get your accessory panel.

00:20:04.710 --> 00:20:07.759
Now, one common usage of this is the check box.

00:20:07.759 --> 00:20:09.289
So refreshen check box.

00:20:09.289 --> 00:20:11.159
Do not show me this again.

00:20:11.160 --> 00:20:16.840
And we make this even simpler by providing
this API, set show expression button.

00:20:16.839 --> 00:20:21.250
If you say yes to this, you automatically get
a check box with that default text on there.

00:20:21.250 --> 00:20:27.730
And if you wish, you can ask for the suppression button,
which is the check box, and changes title or initial state.

00:20:27.730 --> 00:20:31.220
And of course when the panel is
dismissed, ask for the current state.

00:20:31.220 --> 00:20:33.740
Now again, a word of warning from before.

00:20:33.740 --> 00:20:35.779
This is meant for a suppression check box.

00:20:35.779 --> 00:20:38.730
And in the future we might change
the way it looks, the way it behaves.

00:20:38.730 --> 00:20:40.789
Maybe it's not even going to be a check box any more.

00:20:40.789 --> 00:20:43.220
Do not use this for any purposes other than a check box.

00:20:43.220 --> 00:20:49.069
If you use a check box which is not a suppression check
box, just go ahead and add your own accessory view.

00:20:49.069 --> 00:20:55.730
dock tile. In Leopard we now have this new class
that enables the customized drawing into the dockk.

00:20:55.730 --> 00:20:57.390
So let me bring up a dock.

00:20:57.390 --> 00:20:59.090
Oh, wait, first of all.

00:20:59.089 --> 00:21:01.500
This is how you get an instance of dock tile.

00:21:01.500 --> 00:21:05.019
You could -- you would ask the
application object for its dock tile object.

00:21:05.019 --> 00:21:06.779
Similarly, you can do the same thing for a window.

00:21:06.779 --> 00:21:09.430
So let me bring up a dock now.

00:21:09.430 --> 00:21:10.830
So here's your dock.

00:21:10.829 --> 00:21:12.349
An example of this is here.

00:21:12.349 --> 00:21:18.039
The -- the little badge on the Mail icon
indicating that you have seven unread messages.

00:21:19.529 --> 00:21:21.609
The API said badge label.

00:21:21.609 --> 00:21:22.990
You just pass this string.

00:21:22.990 --> 00:21:24.420
Preferably a small string.

00:21:24.420 --> 00:21:27.650
Enables you to put that string right
into that little red star there.

00:21:27.650 --> 00:21:31.030
And this is something Mail uses, iChat uses,
and something your application can use as well

00:21:31.029 --> 00:21:34.379
to indicate there's some pending
activity that you need to look at.

00:21:34.380 --> 00:21:39.860
Another kind of customization is this icon here.

00:21:39.859 --> 00:21:42.329
Now these are mini windows, minimized windows.

00:21:42.329 --> 00:21:45.559
And they're typically badged with the
application icon that they belong to.

00:21:45.559 --> 00:21:50.629
But if for some reason you do not want that application icon
on there because you're doing some other custom drawing,

00:21:50.630 --> 00:21:53.960
you can disable that by calling set show application badge.

00:21:53.960 --> 00:21:55.069
Default is yes.

00:21:55.069 --> 00:21:56.859
So you would say no.

00:21:56.859 --> 00:22:00.500
And the final customization is perhaps the most interesting.

00:22:00.500 --> 00:22:02.789
For instance, iCal is showing the current date.

00:22:02.789 --> 00:22:06.769
Xcode is showing progress of the build.

00:22:06.769 --> 00:22:10.349
Activity viewers is showing the CPU usage.

00:22:10.349 --> 00:22:16.259
And finally on your GPS-enabled Powerbook or
MacBook Pro, Safari's showing where north is.

00:22:16.259 --> 00:22:18.720
Actually that -- yes, we didn't release that yet.

00:22:18.720 --> 00:22:19.140
But anyway --

00:22:19.140 --> 00:22:19.460
( Laughter )

00:22:19.460 --> 00:22:22.620
>> Could happen.

00:22:22.619 --> 00:22:24.369
anyway, that API is very simple.

00:22:24.369 --> 00:22:25.599
Set content view.

00:22:25.599 --> 00:22:27.899
You just tell a dock tile set content view.

00:22:27.900 --> 00:22:30.610
And now you control the drawing of that view.

00:22:30.609 --> 00:22:32.869
And you know, what -- draw whatever you want.

00:22:32.869 --> 00:22:37.979
So it's a way to totally customize drawing in that dock tile.

00:22:37.980 --> 00:22:39.829
Split view customizations.

00:22:39.829 --> 00:22:42.009
You know, split view is a class
that doesn't get much respect.

00:22:42.009 --> 00:22:44.190
But if you look in your apps they're everywhere.

00:22:44.190 --> 00:22:45.640
They are a lot of split views.

00:22:45.640 --> 00:22:49.170
And then in recent releases, you know,
in Leopard, there are actually many,

00:22:49.170 --> 00:22:51.410
many kinds of split views appearing in applications.

00:22:51.410 --> 00:22:54.420
Not just the standard bar with a dimple in it.

00:22:54.420 --> 00:22:59.410
For instance, in Mail this area
here is a 1-pixel wide split view.

00:22:59.410 --> 00:23:05.320
However, since the user cannot click on a 1-pixel wide
area, the cursor changes as the user gets near it.

00:23:05.319 --> 00:23:07.450
So this is an example of a new kind of split bar.

00:23:07.450 --> 00:23:10.809
And now we're enabling this with the set divider style API.

00:23:10.809 --> 00:23:14.779
You can specify thin as a way to get this new thinner look.

00:23:14.779 --> 00:23:17.099
And the default is thick.

00:23:17.099 --> 00:23:19.459
You can also get the color of this divider.

00:23:19.460 --> 00:23:22.789
The color depends on what kind of divider bar you've set.

00:23:22.789 --> 00:23:25.970
Or you can override this to change the color if you wish.

00:23:25.970 --> 00:23:30.210
And one other way to customize things
is to change the effective area.

00:23:30.210 --> 00:23:36.170
For instance, if you decide you want your cursor to
change, to split to be effective, some pixels on this side

00:23:36.170 --> 00:23:39.570
but not on this side you can change
direct where it's effected.

00:23:39.569 --> 00:23:43.329
Now one other customization that
you can see here is the ability

00:23:43.329 --> 00:23:46.619
to put little dragging areas in
addition to the splitter bar.

00:23:46.619 --> 00:23:48.079
I don't know if you can see it at the bottom there.

00:23:48.079 --> 00:23:49.049
The Mail window.

00:23:49.049 --> 00:23:54.440
And this is done by another delegate method, which let's
you specify the additional effect of dragging area.

00:23:54.440 --> 00:23:57.430
And you just, you know, return a rectangle here.

00:23:57.430 --> 00:24:03.460
And then you go ahead and put your custom control or
your standard button in there to do that, the dragging.

00:24:03.460 --> 00:24:05.759
One other split view feature is auto saving.

00:24:05.759 --> 00:24:11.220
If you're familiar with auto saving feature in NS
window, it saves the -- well, one person likes it.

00:24:11.220 --> 00:24:12.690
Thank you.

00:24:12.690 --> 00:24:17.690
So it lets you save the window's
position automatically to user defaults.

00:24:17.690 --> 00:24:19.840
Then you can now do this with the exact same API.

00:24:19.839 --> 00:24:21.379
Set, auto, save name.

00:24:21.380 --> 00:24:25.810
And split -- the split view will save the positions of bars

00:24:25.809 --> 00:24:29.019
and also whether they are collapsed
or not out in the defaults.

00:24:29.019 --> 00:24:33.609
And this is also not only accessible through
the simple API, but in Interface Builder

00:24:33.609 --> 00:24:37.829
in the split view inspector you can go
ahead and just type in the name you wish.

00:24:37.829 --> 00:24:41.179
Very, very simple to use.

00:24:41.180 --> 00:24:41.779
Menu item.

00:24:41.779 --> 00:24:43.670
Now this is something we talked about last time.

00:24:43.670 --> 00:24:47.990
But it's such a great little feature, I
definitely wanted to talk about it now as well.

00:24:47.990 --> 00:24:50.240
It let's you customize menu item drawing.

00:24:50.240 --> 00:24:51.839
And not let's you customize it.

00:24:51.839 --> 00:24:54.609
It let's you handle events.

00:24:54.609 --> 00:24:56.329
This includes mouse and keyboard events.

00:24:56.329 --> 00:24:57.480
And can also animate.

00:24:57.480 --> 00:25:00.380
So here's an example where we put sliders into a menu.

00:25:00.380 --> 00:25:04.600
You know, not that this is a great UI
here, but this is something you can do.

00:25:04.599 --> 00:25:07.379
The API is again extremely simple.

00:25:07.380 --> 00:25:09.340
You just add a view.

00:25:09.339 --> 00:25:13.629
You set the view that corresponds to the mean
you item and Cocoa does the rest for you.

00:25:13.630 --> 00:25:17.770
And of course those views could have controls,
target action, bindings, whatever you want.

00:25:17.769 --> 00:25:22.480
All the power of Cocoa is available to you in that view.

00:25:22.480 --> 00:25:23.740
Collection view.

00:25:23.740 --> 00:25:24.829
This is a new class.

00:25:24.829 --> 00:25:27.839
It had made an appearance at the last WWDC.

00:25:27.839 --> 00:25:31.679
It was known then as Grid View, but
it went -- underwent a name change.

00:25:31.680 --> 00:25:35.390
Collection View is simply described as NS matrix per views.

00:25:35.390 --> 00:25:37.090
For those of you who are familiar with NS Matrix,

00:25:37.089 --> 00:25:42.490
it's basically our collection, our
UI class that shows grid of cells.

00:25:42.490 --> 00:25:43.910
But now we can do this for views.

00:25:43.910 --> 00:25:45.680
And Collection View is actually a lot more powerful.

00:25:45.680 --> 00:25:48.250
I'm going -- I'll explain that now.

00:25:48.250 --> 00:25:52.160
An example of Collection View is in Interface Builder.

00:25:52.160 --> 00:25:56.170
The library in interface builder
is actually the collection view.

00:25:56.170 --> 00:26:02.340
So as objects are deleted, removed, sorted, et
cetera, these things animate and that's some

00:26:02.339 --> 00:26:04.439
of the features that Collection View provides.

00:26:04.440 --> 00:26:08.380
Another great feature of Collection View
is that it's fully driven via bindings.

00:26:08.380 --> 00:26:12.190
It can be fully competent Interface
Builder with zero lines of code.

00:26:12.190 --> 00:26:14.690
Now let me explain the architecture
of collection view a bit.

00:26:14.690 --> 00:26:18.880
Just to short of make this a little bit more concrete.

00:26:18.880 --> 00:26:20.350
Here we have a collection view.

00:26:20.349 --> 00:26:28.619
Typically, the contents for a collection view comes from
-- comes by binding the content to an array controller.

00:26:28.619 --> 00:26:31.199
Or you can actually assign an array to this content.

00:26:31.200 --> 00:26:33.000
So anyway, you bind it to an array controller.

00:26:33.000 --> 00:26:34.740
The content comes from there.

00:26:34.740 --> 00:26:37.509
Then there is a prototype.

00:26:37.509 --> 00:26:43.019
A collection view item class -- that's your item
prototype -- and that in turn points to a view.

00:26:43.019 --> 00:26:45.359
You design the view in Interface Builder.

00:26:45.359 --> 00:26:50.309
This is the view that's going to
appear in the collection view.

00:26:50.309 --> 00:26:56.029
Now when that view object is added, the item
and the view are automatically replicated.

00:26:56.029 --> 00:26:57.509
So let me show you that.

00:26:57.509 --> 00:27:01.670
We're going to add a new object
array to the array controller.

00:27:01.670 --> 00:27:05.100
This causes a new collection item to be created.

00:27:05.099 --> 00:27:08.500
It's represented object points to the newly added object.

00:27:08.500 --> 00:27:11.509
And the view is replicated and added to the collection view.

00:27:11.509 --> 00:27:14.160
Now let's add in that second object,
and the same thing happens.

00:27:14.160 --> 00:27:15.790
A second view appears.

00:27:15.789 --> 00:27:20.049
And the third one will do the same thing.

00:27:20.049 --> 00:27:27.740
Now one final piece of this puzzle is that the values in
the UI elements in the view -- so these guys up here --

00:27:27.740 --> 00:27:30.130
the values in here -- shows there
can be arbitrary views in here.

00:27:30.130 --> 00:27:32.530
Text fields, sliders, whatever.

00:27:32.529 --> 00:27:37.190
These are bound to the corresponding
items represented object.

00:27:37.190 --> 00:27:39.360
Now of course represented objects are here.

00:27:39.359 --> 00:27:40.699
So this is all automatic.

00:27:40.700 --> 00:27:45.830
Just by specifying these connections in interface
builder this collection view will respond

00:27:45.829 --> 00:27:47.559
to addition, removal of objects.

00:27:47.559 --> 00:27:53.419
And if you change the sorting in the array
controller the collection view will respond and so on.

00:27:53.420 --> 00:27:58.519
Now -- talking about animation, let's talk
about animation support we've added to Cocoa.

00:27:58.519 --> 00:27:59.569
You've seen this yesterday.

00:27:59.569 --> 00:28:02.519
There's great animation capabilities in Leopard.

00:28:02.519 --> 00:28:10.440
And we bring this to NS Views and NS Windows, and in
fact any Cocoa object in general if you wish to add it.

00:28:10.440 --> 00:28:14.920
The way this works is that to animate a
property, let's take a view as an example --

00:28:14.920 --> 00:28:21.610
to animate a property in NS View instead of just
setting the value of that property in the view,

00:28:21.609 --> 00:28:24.709
you talk to the view's animator to set the same property.

00:28:24.710 --> 00:28:27.309
Now the view's animator is a proxy.

00:28:27.309 --> 00:28:31.059
It acts like the view for most purposes,
but if you tell it to set the value

00:28:31.059 --> 00:28:33.740
of an animatable property, it will animate that property.

00:28:33.740 --> 00:28:39.460
So if you set the frame in the Animator, the view will
actually animate from its old location to the new location.

00:28:39.460 --> 00:28:44.170
And size. Now there's a reasonable set of default settings.

00:28:44.170 --> 00:28:47.470
Most of the time you don't even have
to change these default settings.

00:28:47.470 --> 00:28:51.000
You can just go ahead with this and, you
know, reasonable animations will occur.

00:28:51.000 --> 00:28:54.279
So that's -- that's simple as it can get.

00:28:54.279 --> 00:28:57.879
Now so far one thing I haven't
talked about is Core Animation.

00:28:57.880 --> 00:29:02.140
Because it turns out that this feature
in view can work without Core Animation.

00:29:02.140 --> 00:29:08.500
However, for sophisticated animations, highly performing
animations, you will probably want to enable Core Animation.

00:29:08.500 --> 00:29:12.269
And you do that by turning on layer backing for views.

00:29:12.269 --> 00:29:14.829
In the API for that is settle once layer.

00:29:14.829 --> 00:29:16.879
So you tell a view set wants layer yes.

00:29:16.880 --> 00:29:20.430
This enables layer backing for
that view and all its sub views.

00:29:20.430 --> 00:29:23.990
This is also possible to do in Interface Builder.

00:29:23.990 --> 00:29:29.210
We are checking this wants layer box in the Inspector.

00:29:29.210 --> 00:29:31.799
Now what this does, it turns on
layer backing as I mentioned.

00:29:31.799 --> 00:29:36.230
It enables per view alpha, shadow, and also filters.

00:29:36.230 --> 00:29:39.910
What this means is you get fancy visual
effects and high performance animation.

00:29:39.910 --> 00:29:44.860
So if you have large areas animating, many objects
animating, and the standard animation view doesn't do it

00:29:44.859 --> 00:29:48.819
for you, definitely enable Core Animation-based animations.

00:29:48.819 --> 00:29:54.429
And this also enables additional features such as
hosting of Cocoa controls and NS OpenGL views.

00:29:54.430 --> 00:29:57.970
Before, if you wanted to put a button
on top of an OpenGL view you would have

00:29:57.970 --> 00:30:00.890
to create a child window and so on and manage that.

00:30:00.890 --> 00:30:03.930
And that was definitely in the realm of complex is possible.

00:30:03.930 --> 00:30:05.960
Well now it's simple things simple.

00:30:05.960 --> 00:30:08.809
You just put those things on top of OpenGL view.

00:30:08.809 --> 00:30:16.690
Now the session in this room after me is Cocoa Animation.

00:30:16.690 --> 00:30:18.850
Building Animated Cocoa User Interfaces.

00:30:18.849 --> 00:30:22.379
And James Dempsey will be talking to
you about -- more about these features.

00:30:22.380 --> 00:30:27.320
And just one more thing, again, between all
of us here, I think I saw a guitar back stage.

00:30:27.319 --> 00:30:29.500
So for those of you who know James --

00:30:29.500 --> 00:30:32.230
( Applause )

00:30:32.230 --> 00:30:33.809
View Controller is a new class.

00:30:33.809 --> 00:30:36.460
It's basically NS Window Controller for views.

00:30:36.460 --> 00:30:39.269
Now it turns out nobody really asked for this class.

00:30:39.269 --> 00:30:44.629
However, whenever we look at your sample code or
we looked at various code people have been writing,

00:30:44.630 --> 00:30:46.780
it was clear that people needed this class.

00:30:46.779 --> 00:30:49.500
Because people would use a windows
controller to control views.

00:30:49.500 --> 00:30:52.759
And that's sort of an abuse of NS Window Controller.

00:30:52.759 --> 00:30:59.220
It's useful for plug-in architectures where dynamic sets of
views are, you know, are being swapped in and out and so on.

00:30:59.220 --> 00:31:04.170
It's also useful it turns out for
incorporating Cocoa views into Carbon windows.

00:31:04.170 --> 00:31:06.670
In conjunction with that HI Cocoa as I mentioned.

00:31:06.670 --> 00:31:12.340
You basically create your view hierarchy, have it controlled
by NS View Controller, and put that into your HI Cocoa view.

00:31:12.339 --> 00:31:17.139
And there is a sample for this that you
can download from your attendee site.

00:31:17.140 --> 00:31:21.860
Now, just like an NS Window Controller, a
View Controller manages top level objects.

00:31:21.859 --> 00:31:25.799
And it also confronts the NS Cell through informal protocol.

00:31:25.799 --> 00:31:32.169
Which means if a user types in the text field and
closes the window without hitting tab or return,

00:31:32.170 --> 00:31:37.140
it will manage the discarding or
committing of that value, for instance.

00:31:37.140 --> 00:31:39.640
And these are the highlights of
the methods in View Controller.

00:31:39.640 --> 00:31:42.640
There's a represented object, you can set and get that.

00:31:42.640 --> 00:31:43.390
There's a title.

00:31:43.390 --> 00:31:46.509
It turns out many of the context
for View Controllers are used.

00:31:46.509 --> 00:31:47.740
The title is useful.

00:31:47.740 --> 00:31:51.430
And then there's finally the view that's being controlled.

00:31:51.430 --> 00:31:55.710
The -- you can either -- this normally comes from IB.

00:31:55.710 --> 00:32:00.269
But you can also override this to change
the view that is being controlled.

00:32:00.269 --> 00:32:04.930
Now this view control discussion might be a
little abstract for some of you, you know,

00:32:04.930 --> 00:32:06.850
maybe hard to visualize what this is useful for.

00:32:06.849 --> 00:32:08.849
So let me give a concrete example.

00:32:08.849 --> 00:32:15.579
The Print Panel, the Print Dialogue, it used to have --

00:32:15.579 --> 00:32:19.339
it has a set accessory view where you can customize
the behavior of adding your accessory view.

00:32:19.339 --> 00:32:25.359
In Leopard we've now enabled customizing it further
by adding this method, Add Accessory Controller.

00:32:25.359 --> 00:32:28.769
And this can be called multiple times
to add multiple accessory views.

00:32:28.769 --> 00:32:31.670
And the argument here is a View Controller.

00:32:31.670 --> 00:32:34.470
You sub class View Controller and you supply it here.

00:32:34.470 --> 00:32:38.549
We've also provided this protocol, Print Panel
Accessorizing to tell you what methods you need

00:32:38.549 --> 00:32:41.109
to implement on top of anything else you might need.

00:32:41.109 --> 00:32:43.019
Here's what that protocol looks like.

00:32:43.019 --> 00:32:44.500
It's got two methods.

00:32:44.500 --> 00:32:46.450
One of them is required and one of them is optional.

00:32:46.450 --> 00:32:49.590
I'll talk about optional methods shortly.

00:32:49.589 --> 00:32:55.679
But basically you implement a sub class of View Controller
and implement the required method, and optionally,

00:32:55.680 --> 00:32:58.080
the other method and then you're good to go.

00:32:58.079 --> 00:33:04.639
And then the thing here is that the represented object
of each controller is settle to the NS Print info object.

00:33:04.640 --> 00:33:10.130
Print info object is the object that maintains the
print settings so it's a reasonable represented object

00:33:10.130 --> 00:33:13.900
and it lets your accessory views
basically change the settings in there.

00:33:13.900 --> 00:33:18.220
Now let me give an example of this
to make it even more concrete.

00:33:18.220 --> 00:33:19.539
Now you might know of TextEdit.

00:33:19.539 --> 00:33:24.269
TextEdit is the word processor, the simple
word processor that was shipped with Mac OS X.

00:33:24.269 --> 00:33:29.000
And the sources are available, by the way, on
your systems if you want to look at this later.

00:33:29.000 --> 00:33:31.339
Here's what the Print Panel for TextEdit looks like.

00:33:31.339 --> 00:33:36.079
Now one major feature here is the inclusion of
the print preview, which is pretty much automatic

00:33:36.079 --> 00:33:39.559
for Cocoa applications under --
under some sort of consensus.

00:33:39.559 --> 00:33:41.019
But there you go.

00:33:41.019 --> 00:33:44.879
It's the print -- it's a live preview
of the document that's being printed.

00:33:44.880 --> 00:33:48.050
Now, let's put that aside.

00:33:48.049 --> 00:33:49.839
Because I want to talk about the accessory view.

00:33:49.839 --> 00:33:53.949
TextEdit adds this one sample accessory
view that just has this one check box.

00:33:53.950 --> 00:33:55.920
Print header and footer.

00:33:55.920 --> 00:34:02.840
And when the user checks that check box what happens is
the headers and footers appear in the corners of the page.

00:34:02.839 --> 00:34:04.419
And this happens live.

00:34:04.420 --> 00:34:10.460
And that's what that API I just showed you -- the
Print Panel accessory thing -- tries to enable.

00:34:13.730 --> 00:34:17.170
So here is what the sub class of
View Controller would look like.

00:34:17.170 --> 00:34:18.110
There are two methods.

00:34:18.110 --> 00:34:20.170
Set page numbering, and page numbering.

00:34:20.170 --> 00:34:21.650
No need to look at the code here.

00:34:21.650 --> 00:34:24.019
The point is that these are KVC compliant.

00:34:24.019 --> 00:34:29.070
In addition, we implement that method in
protocol key paths for values effecting preview.

00:34:29.070 --> 00:34:31.500
And return to key page numbers.

00:34:31.500 --> 00:34:34.289
So what this means is that when the page numbering --

00:34:34.289 --> 00:34:38.679
the value for page numbering, the
preview is automatically displayed.

00:34:38.679 --> 00:34:40.469
So that's what this enables.

00:34:40.469 --> 00:34:48.699
Okay. Speaking of TextEdit, now we
should talk about text system features.

00:34:48.699 --> 00:34:52.299
And there are a number of great
features in the text system in Leopard.

00:34:52.300 --> 00:34:53.840
Non contiguous layout.

00:34:53.840 --> 00:35:00.990
This enables multimegabyte documents to be opened by the
Cocoa text system much faster and much more efficiently.

00:35:00.989 --> 00:35:03.809
It's doing a much better job now with huge documents.

00:35:03.809 --> 00:35:05.559
We now support new document formats.

00:35:05.559 --> 00:35:09.799
The Open document format, and the
Microsoft Office Open XML Format.

00:35:09.800 --> 00:35:12.730
And these can be both read and written.

00:35:12.730 --> 00:35:17.530
In addition, there's grammar checking, smart quotes,
link detection, and a number of other features.

00:35:17.530 --> 00:35:20.230
Now some of these features are
reflected in Interface Builder Inspector.

00:35:20.230 --> 00:35:26.050
You can actually enable, for instance,
automatic quote substitution where, you know,

00:35:26.050 --> 00:35:28.490
non-fancy quotes convert to fancy quotes.

00:35:28.489 --> 00:35:32.759
But if you're in the context of Xcode, for
instance, that's something you might want to disable.

00:35:32.760 --> 00:35:34.660
Otherwise the compiler wouldn't be happy with you.

00:35:34.659 --> 00:35:40.759
I am not going to talk more about the text system features,
but there is a talk, Customizing the Cocoa Text System,

00:35:40.760 --> 00:35:45.310
tomorrow afternoon where Doug Davidson and Aki Inoue
will talk about these features,

00:35:45.309 --> 00:35:49.679
and also in general how to customize the text system.

00:35:49.679 --> 00:35:52.529
Okay. Now that was the big UI part of our talk.

00:35:52.530 --> 00:35:54.340
Now let's get to Core Data.

00:35:54.340 --> 00:35:56.880
What new in Core Data.

00:35:56.880 --> 00:35:59.099
So persistent store API.

00:35:59.099 --> 00:36:05.539
This enables your -- you to have -- you
to use custom stores in your applications.

00:36:05.539 --> 00:36:08.309
There's an abstract base class, NS persistent store,

00:36:08.309 --> 00:36:14.210
but typically you would sub class its
somewhat abstract class, NS atomic store.

00:36:14.210 --> 00:36:17.539
And there are five methods you need
to override, and here they are.

00:36:17.539 --> 00:36:20.949
So by doing this you can have your own file formats.

00:36:20.949 --> 00:36:22.549
And there is an example you can download.

00:36:22.550 --> 00:36:24.680
I believe it's called HTML store.

00:36:24.679 --> 00:36:28.190
Which let's you -- which shows you
how to use an HTML file as a store

00:36:28.190 --> 00:36:32.650
for your Core Data -- for your Core data managed data.

00:36:32.650 --> 00:36:35.930
We have other changes in NS Fetch Request.

00:36:35.929 --> 00:36:39.589
Now Fetch Request allows much finer
grain than performance tested fetches.

00:36:39.590 --> 00:36:44.670
And there are these methods that let you control
exactly how objects are loaded or not loaded.

00:36:44.670 --> 00:36:48.079
Include sub entities, include property
values, only return objects that are false.

00:36:48.079 --> 00:36:54.389
These are all yes by default, but you can tweak the
behavior depending on how much stuff you want to load in.

00:36:54.389 --> 00:36:58.150
There's an example called Go Fetch
which shows these in action as well.

00:36:58.150 --> 00:37:02.950
I mention these examples because if you're interested more
in the Core Data sessions -- well, you missed them all.

00:37:02.949 --> 00:37:05.409
Because they were this morning and one's going on right now.

00:37:05.409 --> 00:37:09.440
So the examples are -- examples
are the only thing you can look at.

00:37:09.440 --> 00:37:15.780
One other performance aid here is Manage Object
context, which has this new method this let's you --

00:37:15.780 --> 00:37:20.780
returns the number of objects that would be fetched
for a Fetch Request without actually returning them.

00:37:20.780 --> 00:37:26.350
And if all you need is a number of objects and not the
objects themselves, this is a huge performance win.

00:37:26.349 --> 00:37:30.920
Finally the big -- other big Core Data
feature is the version of migration API.

00:37:30.920 --> 00:37:34.980
Typically -- you know, as you know,
the Core Data stores are very much --

00:37:34.980 --> 00:37:38.650
are very tied to the model that's defined for them.

00:37:38.650 --> 00:37:42.150
So whenever you change your model,
of course the store no longer works.

00:37:42.150 --> 00:37:47.450
This new API, there's a mapping model class
which let's you define how a mapping --

00:37:47.449 --> 00:37:50.230
how a model maps from one version to the other.

00:37:50.230 --> 00:37:55.710
And of course this let's you control, you know,
when writing the stores for those different models.

00:37:55.710 --> 00:37:59.130
Using the NS migration manager
class you can actually get a --

00:37:59.130 --> 00:38:02.590
you can actually migrate a model up, or even in fact down.

00:38:02.590 --> 00:38:04.510
You down grade to a previous version.

00:38:04.510 --> 00:38:06.540
And you control the set runtime.

00:38:06.539 --> 00:38:11.849
And Xcode also has tools to let
you define these mapping models.

00:38:11.849 --> 00:38:13.529
So you're actually doing it in Xcode.

00:38:13.530 --> 00:38:16.070
You don't have to do it in code.

00:38:16.070 --> 00:38:19.039
Okay. So with that, let's move on to non UI.

00:38:19.039 --> 00:38:24.340
Which, of course, means mostly
foundation stuff at this point.

00:38:24.340 --> 00:38:25.590
You heard about this yesterday.

00:38:25.590 --> 00:38:27.780
The new NS Operation class.

00:38:27.780 --> 00:38:30.850
This class represents an encapsulated task.

00:38:30.849 --> 00:38:33.730
And when I say task, I don't mean NS task.

00:38:33.730 --> 00:38:34.750
You know, the kernel task.

00:38:34.750 --> 00:38:41.159
It's more than an operation, some --
some encapsulated piece of thing to do.

00:38:41.159 --> 00:38:46.049
This enables specifying dependencies in
terms of other operations, priorities,

00:38:46.050 --> 00:38:48.310
and whether these things can execute concurrently.

00:38:48.309 --> 00:38:53.389
Meaning they can be run on separate
threads against each other.

00:38:53.389 --> 00:38:55.489
Now NS Operation's partly abstract.

00:38:55.489 --> 00:39:01.079
You would typically sub class NS Operation
and specify what operation needs to be done.

00:39:01.079 --> 00:39:07.269
However, we do supply a concrete sub class NS Invocation
operation, where it can supply a target and selector,

00:39:07.269 --> 00:39:10.929
or NS indication, as though we define a concrete operation.

00:39:10.929 --> 00:39:17.239
Now, one other helper classes here, the Operation Queue, and
Operation Queue performs NS Operations in the background.

00:39:17.239 --> 00:39:23.269
You create your operations, you put them in the queue, and
they will be executed automatically in the background.

00:39:23.269 --> 00:39:26.980
Now my default Operation Queue does the right thing.

00:39:26.980 --> 00:39:30.460
And Simon Patience talked about this a bit yesterday.

00:39:30.460 --> 00:39:36.679
But you know, NS Operation might start executing operations
concurrently based on how many CPUs are in your machine.

00:39:36.679 --> 00:39:39.949
But if some of those operations got blocked due to IO,

00:39:39.949 --> 00:39:43.879
then NS Operation Queue might choose
to start with more operations.

00:39:43.880 --> 00:39:46.890
You know, this is the kind of smarts that
would be very hard for you to control.

00:39:46.889 --> 00:39:50.329
Because this really involves knowledge of the kernel inside.

00:39:50.329 --> 00:39:53.599
So it's fairly powerful stuff.

00:39:53.599 --> 00:39:56.519
We've also done some threading improvements,
which are worth mentioning right now

00:39:56.519 --> 00:39:59.469
of the we have less and faster locking throughout.

00:39:59.469 --> 00:40:01.980
For instance, at synchronize is now much faster.

00:40:01.980 --> 00:40:05.480
And retain and release are also much
faster in the face of contention.

00:40:05.480 --> 00:40:09.900
You know, when there are multiple threads trying
to do things, these things could slow down a bit.

00:40:09.900 --> 00:40:12.110
But now they are much faster.

00:40:12.110 --> 00:40:15.579
Similarly, Objective-C 2.0 properties -- not similar,

00:40:15.579 --> 00:40:20.690
but along the lines of threading improvements
-- properties are atomic by default.

00:40:20.690 --> 00:40:25.559
What this means is if one thread is setting
a property and another thread is getting

00:40:25.559 --> 00:40:28.509
that property, you will never get a corrupt value back.

00:40:28.510 --> 00:40:30.710
It does the orderly thing in the right context.

00:40:30.710 --> 00:40:35.139
And if it's returning multiword values like
NS ref, you will never get half a ref back.

00:40:35.139 --> 00:40:36.679
That's what atomic means.

00:40:36.679 --> 00:40:38.009
Now, one important thing.

00:40:38.010 --> 00:40:40.330
This doesn't imply high level synchronization.

00:40:40.329 --> 00:40:45.000
If you need high level synchronization of your object
you still have to lock your objects at a higher level.

00:40:45.000 --> 00:40:49.619
For instance, if you ask an array for the number
of items and you start enumerating those items,

00:40:49.619 --> 00:40:51.809
the array might change between those calls.

00:40:51.809 --> 00:40:56.170
So in those cases you need to have your
own -- own synchronization around --

00:40:56.170 --> 00:40:58.019
around your beta structures, or around your code.

00:40:58.019 --> 00:41:02.539
Now there are also new NS object
methods to improve threading.

00:41:02.539 --> 00:41:04.960
And I will just show you one could whet your appetite.

00:41:04.960 --> 00:41:07.599
This is basically the lazy man's method.

00:41:07.599 --> 00:41:09.190
Perform selector in background.

00:41:09.190 --> 00:41:11.130
So this creates a thread and executes it.

00:41:11.130 --> 00:41:13.630
So it's a way for your thread to
just execute this elsewhere,

00:41:13.630 --> 00:41:15.539
and I don't want to be blocked,
I don't want to hear about it.

00:41:15.539 --> 00:41:16.619
Just execute it.

00:41:16.619 --> 00:41:17.829
It's fairly straight forward.

00:41:17.829 --> 00:41:23.690
There are a few other methods like this, and
you can go to these two talks Thursday morning,

00:41:23.690 --> 00:41:29.690
Partitioning Your Cocoa Application, or the
Performance and Boosting Response and Performance.

00:41:29.690 --> 00:41:30.670
A glorious title.

00:41:30.670 --> 00:41:38.010
You can go to these two talks and hear more about
NS Operations threading improvements and much more.

00:41:38.010 --> 00:41:39.050
Three new classes.

00:41:39.050 --> 00:41:41.200
NS hash table map, table pointer array.

00:41:41.199 --> 00:41:46.289
These correspond to or they're analogous
to NS Set, NS Dictionary, and NS Array.

00:41:46.289 --> 00:41:48.920
What these classes do is they're customizable.

00:41:48.920 --> 00:41:52.380
You can put objects or non objects in these classes.

00:41:52.380 --> 00:41:54.849
They can have different copy retain behaviors,

00:41:54.849 --> 00:42:00.099
and one interesting behavior they have is
the ability to do zeroing weak references.

00:42:00.099 --> 00:42:05.019
This is very interesting for Garbage Collection, because
when an object gets garbage collected, any references,

00:42:05.019 --> 00:42:09.199
any weak references to those objects in these
collections are automatically cleared out,

00:42:09.199 --> 00:42:11.059
which is very good for Garbage Collection purposes.

00:42:11.059 --> 00:42:13.699
And something that will be very
hard for you to do correctly.

00:42:13.699 --> 00:42:18.219
Because there are a lot of raised
conditions involved in that.

00:42:18.219 --> 00:42:21.569
Now, again, this is a case for simple usage is simple.

00:42:21.570 --> 00:42:26.030
You create a hash table by, for instance , you
can create it by hash table with weak objects.

00:42:26.030 --> 00:42:30.100
This means create me a hash table
where objects are not retained.

00:42:30.099 --> 00:42:34.449
And the garbage collected in mind, which
means the objects, you know, this reference,

00:42:34.449 --> 00:42:37.549
does not cause object to not be garbage collected.

00:42:37.550 --> 00:42:44.030
Or if you want a more sophisticated set up, you go
ahead and create an instance of pointer functions.

00:42:44.030 --> 00:42:45.190
You create pointer functions.

00:42:45.190 --> 00:42:48.329
You can then set -- oops, sorry.

00:42:48.329 --> 00:42:49.949
Twitchy finger there.

00:42:49.949 --> 00:42:50.639
Let's go for it.

00:42:50.639 --> 00:42:53.839
Okay. You can set the echo function
and the hash function, for instance.

00:42:53.840 --> 00:42:58.329
Or there's a number of other functions you can set and
create your hash table from these pointer functions.

00:42:58.329 --> 00:43:02.989
And this says to customize these
collections any which way you want.

00:43:02.989 --> 00:43:08.169
Okay. Scripting.

00:43:08.170 --> 00:43:15.230
I am not going to say much about scripting
except we have a bunch of new features.

00:43:15.230 --> 00:43:22.760
Some new features to enable scripting to -- the scripting
abilities of your application to grow with plug-ins.

00:43:22.760 --> 00:43:28.900
There's support for these hidden attributes an sib
elements, which let's you support all their deprecated APIs

00:43:28.900 --> 00:43:34.150
So basically enable you to have old scripts
continuing running while you present the new API

00:43:34.150 --> 00:43:35.840
to new script developers.

00:43:35.840 --> 00:43:38.960
And finally, much better error sensing and reporting.

00:43:38.960 --> 00:43:43.559
There is a talk for Cocoa scripting
that's tomorrow afternoon at this time.

00:43:43.559 --> 00:43:44.969
Not this room, but this time.

00:43:44.969 --> 00:43:48.019
Where you can hear Mark Piccirelli
talk about these improvements.

00:43:48.019 --> 00:43:50.900
So 64-bit.

00:43:50.900 --> 00:43:52.380
You heard about this yesterday.

00:43:52.380 --> 00:43:55.460
Leopard enables Cocoa applications
that are 64-bit throughout.

00:43:55.460 --> 00:44:01.340
And by this I don't mean -- I just -- I don't
mean just -- you can compile your app at 64-bit.

00:44:01.340 --> 00:44:04.610
But they can actually manage 64-bits worth of data.

00:44:04.610 --> 00:44:09.849
Because some of the classes like -- or most of
the classes like string, array, the text system,

00:44:09.849 --> 00:44:14.900
are actually also capable of dealing
more than 32 bits worth o2f data.

00:44:14.900 --> 00:44:20.740
Now to enable this, we've added three new
types, NS Integer, NS UInteger.

00:44:20.739 --> 00:44:23.979
These replace Int and unsigned int, respectively.

00:44:23.980 --> 00:44:30.329
And CG float, which replaces graphical
and related float quantities in the APIs.

00:44:30.329 --> 00:44:32.029
Now really, there's only three new types.

00:44:32.030 --> 00:44:34.530
But you know, it's really a huge API change.

00:44:34.530 --> 00:44:37.390
Because hundreds of methods in the API have been effected.

00:44:37.389 --> 00:44:42.250
Where Int now becomes NS integer, unsigned int becomes
NSU Integer and so on.

00:44:42.250 --> 00:44:47.190
But you know, when you look at the definition, you
see that for 64-bit, these are defined as longs,

00:44:47.190 --> 00:44:49.409
or doubles, which means they're 64-bit quantitdies.

00:44:49.409 --> 00:44:52.369
But for 32-bit they're defined as their previous definition.

00:44:52.369 --> 00:44:56.400
So really, although the declarations
themselves have changed, API is not changing.

00:44:56.400 --> 00:44:59.019
32-bit applications totally binary incompatible.

00:44:59.019 --> 00:45:01.320
Exactly the same as before.

00:45:01.320 --> 00:45:05.440
Now let me show you what the API
looks like with these changes.

00:45:05.440 --> 00:45:08.670
For instance, NS Array used to have an
account method that returns unsigned Int.

00:45:08.670 --> 00:45:10.340
Now returns NS U integer.

00:45:10.340 --> 00:45:12.940
Object Index now takes NS View integer.

00:45:12.940 --> 00:45:15.900
The line spacing and paragraph style used to be a float.

00:45:15.900 --> 00:45:16.970
Now it's a CG float.

00:45:16.969 --> 00:45:20.639
And of course, in 64-bit this is a double.

00:45:20.639 --> 00:45:23.389
Which means you get much better precision.

00:45:23.389 --> 00:45:27.920
And the basic types, like NS point, NS
size, are now in terms of CG floats.

00:45:27.920 --> 00:45:32.079
This means that direct basic type
are also in terms of CG floats.

00:45:32.079 --> 00:45:34.739
It's in terms of points and sizes.

00:45:37.769 --> 00:45:44.030
Now you know, if you take your Cocoa application and
you compile for 64-bit, you might get a few warnings,

00:45:44.030 --> 00:45:47.460
you might not get anything, no
warnings, and might seem to run.

00:45:47.460 --> 00:45:52.610
However, if you're still content to use Ints
and unsigned Ints and floats in your program,

00:45:52.610 --> 00:45:55.550
there might be a lot of hidden bugs in there.

00:45:55.550 --> 00:45:57.539
Things will crash, maybe mysteriously later.

00:45:57.539 --> 00:46:04.809
In addition, of course, your program might not be able to
process 64-bit quantities as effectively as you might want.

00:46:04.809 --> 00:46:10.239
So we have this conversion script that will convert your
Objective-C source code to use these new source types.

00:46:10.239 --> 00:46:13.059
Typically, you would run this conversion
script and then depending on the size

00:46:13.059 --> 00:46:20.380
of your app you might spend a few quality minutes or
hours or maybe days in file merge, looking at the discs,

00:46:20.380 --> 00:46:24.900
or maybe using Xcode's new Snapshot feature,
looking at the discs and fixing them up one by one.

00:46:24.900 --> 00:46:27.639
And most of the time, most of the changes will be, you know,

00:46:27.639 --> 00:46:31.170
along the same lines so it should
be pretty quick to get through.

00:46:31.170 --> 00:46:34.340
This script -- running this script
is -- and its effects are described

00:46:34.340 --> 00:46:36.750
in the 64-bit transition guide, which is available.

00:46:36.750 --> 00:46:39.860
You can get to it from your Xcode documentation.

00:46:41.610 --> 00:46:51.570
Oh, and worth mentioning, Friday morning at 9
a.m. we have an Adopting 64-bit Programming Talk,

00:46:51.570 --> 00:46:54.340
where Matthew Formica will talk about just --

00:46:54.340 --> 00:46:59.350
just give you an overview of 64-bit and talk
about the various API changes and so on.

00:46:59.349 --> 00:47:00.889
And that's Friday morning.

00:47:00.889 --> 00:47:05.920
Okay. So now let's talk about Objective-C.

00:47:08.690 --> 00:47:10.820
So Garbage Collection is a big new feature.

00:47:10.820 --> 00:47:13.450
Now the biggest -- the most important thing
about Garbage Collection, you've probably --

00:47:13.449 --> 00:47:16.589
if you've come to WWDC the last few years
you're heard about Garbage Collection.

00:47:16.590 --> 00:47:18.519
There was talk of Garbage Collection in the air.

00:47:18.519 --> 00:47:20.030
And now it's real.

00:47:20.030 --> 00:47:21.010
And that's the important thing.

00:47:21.010 --> 00:47:24.200
It's real enough tomorrow Xcode to use Garbage Collection.

00:47:24.199 --> 00:47:29.989
So you probably heard this yesterday,
but Xcode is a garbage collected app.

00:47:29.989 --> 00:47:32.669
Now Garbage Collection is easy to get started with.

00:47:32.670 --> 00:47:34.490
You just enable it within Xcode.

00:47:34.489 --> 00:47:38.619
So if you bring up the build inspector,
you can go ahead and check that check box

00:47:38.619 --> 00:47:42.339
to enable Garbage Collection for your application.

00:47:42.340 --> 00:47:48.300
Now, one thing about Garbage Collection
is that it's best for new applications.

00:47:48.300 --> 00:47:53.860
It's not the kind of thing that you should go take
your big application, you know, that's already running,

00:47:53.860 --> 00:47:56.099
already debugged, and change it to use Garbage Collection.

00:47:56.099 --> 00:47:57.909
We do not recommend that.

00:47:57.909 --> 00:48:01.069
Instead, you know, if you're selling a
new project it's a good thing to consider.

00:48:01.070 --> 00:48:05.490
Now of course, if you're a big existing application that
had a lot of memory problems and crashed every few minutes

00:48:05.489 --> 00:48:08.409
and leaked all over the place, maybe it is a good idea.

00:48:08.409 --> 00:48:14.949
But anyway -- now one more app that Garbage
Collection turns out to be good for is BlastApp.

00:48:14.949 --> 00:48:17.329
Now, I don't know how many of you know about BlastApp.

00:48:17.329 --> 00:48:18.920
Oh, there's one person.

00:48:18.920 --> 00:48:21.630
BlastApp is this retro looking helicopter game.

00:48:21.630 --> 00:48:22.599
I mean, it's really retro.

00:48:22.599 --> 00:48:24.869
It was retro the day it was written, like, 20 years ago.

00:48:24.869 --> 00:48:26.109
And still is retro.

00:48:26.110 --> 00:48:29.789
But it was written as an Objective-C
app for back in the day.

00:48:29.789 --> 00:48:31.409
And it was converted to Cocoa Java.

00:48:31.409 --> 00:48:34.230
And recently it was converted back to Objective-C.

00:48:34.230 --> 00:48:38.420
Now one thing that happened when it got converted
to Java is all the retains and releases got dropped.

00:48:38.420 --> 00:48:41.900
Of course had it got converted back to
Objective-C, the last thing, you know,

00:48:41.900 --> 00:48:44.990
somebody wants to do is put all
the retains and releases back in.

00:48:44.989 --> 00:48:49.149
So instead we just checked some check box
and some Garbage Collection works great.

00:48:49.150 --> 00:48:56.300
So there's another example of something that works --
I mean, that's what Garbage Collection's very good for.

00:48:56.300 --> 00:49:00.840
There is a GC -- in depth GC talk Friday afternoon at 3:30.

00:49:00.840 --> 00:49:04.780
You can hear more about that.

00:49:04.780 --> 00:49:07.230
Okay. Exceptions.

00:49:07.230 --> 00:49:12.530
We now have a unified exception model that
unifies the exception models of C++

00:49:12.530 --> 00:49:17.010
and Objective-C now one thing to note
here is that this is 64-bit only.

00:49:17.010 --> 00:49:21.680
However, it is source compatible with 32.

00:49:21.679 --> 00:49:23.589
Now in general, and I didn't mention this earlier.

00:49:23.590 --> 00:49:27.440
But in general, we want you to have
one source base for 32 and 64-bit.
d

00:49:27.440 --> 00:49:30.929
We don't want you to have to maintain
two different source bases for those two.

00:49:30.929 --> 00:49:34.719
Now in this case, the exception code you
write for 32-bit will be source compatible

00:49:34.719 --> 00:49:38.539
with 64-bit except it will have
different behaviors in some cases.

00:49:38.539 --> 00:49:42.289
Probably the biggest difference in
behavior is the fact that under 64-bit

00:49:42.289 --> 00:49:49.420
with this new unified exception model it's much
cheaper to enter NS during or at try block.

00:49:49.420 --> 00:49:54.180
However, it's more expensive to
raise or to throw an exception.

00:49:54.179 --> 00:49:57.690
Now this of course is in sync with
Cocoa's exception handling guidelines.

00:49:57.690 --> 00:50:03.220
Cocoa's exception handling guidelines state that, you
know, we don't use exceptions for normal program flow.

00:50:03.219 --> 00:50:06.199
We don't use exceptions for regularly expected errors.

00:50:06.199 --> 00:50:14.849
But they are used for unexpected
errors or programming errors and such.

00:50:14.849 --> 00:50:17.029
Now also let me talk a bit about properties.

00:50:17.030 --> 00:50:21.280
I am not going to go into too much detail in
properties, but properties provide new syntax

00:50:21.280 --> 00:50:24.540
for declaring properties, and synthesizing accessors.

00:50:24.539 --> 00:50:29.230
Now properties are really great at eliminating tons of code.

00:50:29.230 --> 00:50:34.300
For instance, here we have three property
declarations, and they have their time and At Interface.

00:50:34.300 --> 00:50:38.490
And at the bottom is the implementation
file, where just putting one At Synthesize,

00:50:38.489 --> 00:50:42.339
we're able to synthesize the getters
and setters for those properties.

00:50:42.340 --> 00:50:48.550
And not only are these -- getters and setters do what
you might expect, as I mentioned earlier, they are atomic

00:50:48.550 --> 00:50:50.340
and they do the right thing for different types.

00:50:50.340 --> 00:50:54.710
They handle the memory management rules and
they're okay, they work for Garbage Collection

00:50:54.710 --> 00:50:56.539
or not, depending on how your app is built.

00:50:56.539 --> 00:50:58.719
So it's very powerful stuff.

00:50:59.769 --> 00:51:05.039
So one question at this point is that, you know,
let's say that you open up NS View dot H. And you saw

00:51:05.039 --> 00:51:07.400
that there was absolutely zero use of At Properties.

00:51:07.400 --> 00:51:13.530
So the question you might have is why doesn't Apple
use the At Properties syntax if this stuff is so great?

00:51:13.530 --> 00:51:15.120
Well, it turns out we do use it.

00:51:15.119 --> 00:51:17.929
There are some of our APIs, especially
in the newer frameworks

00:51:17.929 --> 00:51:21.239
and the newer classes that do use the properties syntax.

00:51:21.239 --> 00:51:25.189
For instance, Image Kit uses property,
and most of it is APIs.

00:51:25.190 --> 00:51:28.269
And really, the bottom line is all
of our APIs should be using this.

00:51:28.269 --> 00:51:30.759
And you know, it just hasn't happened yet.

00:51:30.760 --> 00:51:31.800
That's just where we are.

00:51:31.800 --> 00:51:37.400
Now of course the good news is that property
syntax isn't all that magically different.

00:51:37.400 --> 00:51:41.220
It does let you get meta data about
those properties, but other than that,

00:51:41.219 --> 00:51:45.109
the property and non property declarations are equivalent.

00:51:45.110 --> 00:51:49.910
For instance, just because NS View did not use a property,

00:51:49.909 --> 00:51:53.099
doesn't mean in your sub class of
NS View you can't use At Property.

00:51:53.099 --> 00:51:55.099
You can go ahead and do that.

00:51:55.099 --> 00:52:00.529
In fact, there is a new dot syntax, and you know,
we don't talk too much about that yesterday,

00:52:00.530 --> 00:52:01.950
I am not going talk too much about it now.

00:52:01.949 --> 00:52:06.059
But the new dot syntax allows you to
get properties by using dot syntax.

00:52:06.059 --> 00:52:10.710
That turns out to be orthogonal
properties, where you can use the dot syntax

00:52:10.710 --> 00:52:14.510
to get properties that are not declared using At Property.

00:52:14.510 --> 00:52:16.100
You know, you can say my view dot bounds.

00:52:16.099 --> 00:52:17.920
Although bounds is not declared using At Property.

00:52:17.920 --> 00:52:21.329
Or my view dot window dot title, or
my view dot once there equals yes.

00:52:21.329 --> 00:52:22.319
So these will work.

00:52:22.320 --> 00:52:23.920
So there are the two features that are orthogonal.

00:52:23.920 --> 00:52:26.159
So turns out this is not a big issue right now.

00:52:26.159 --> 00:52:33.099
And over time we should just switch that properties in our
header files of course, and I encourage you to do the same.

00:52:33.099 --> 00:52:34.049
Fast animation.

00:52:34.050 --> 00:52:36.019
You heard about this yesterday the syntax is great.

00:52:36.019 --> 00:52:40.530
You know, this reads much better than
any of the previous alternatives we had.

00:52:40.530 --> 00:52:44.519
This not only turns out to look better,
it's also much faster than reading one

00:52:44.519 --> 00:52:46.989
by one because it does its work in batches.

00:52:46.989 --> 00:52:49.539
So it's really a win, win situation here.

00:52:49.539 --> 00:52:54.909
Now you can tell which classes
implement fast animation by looking

00:52:54.909 --> 00:52:57.879
at which ones implement this fast animation protocol.

00:52:57.880 --> 00:53:03.720
For instance, NS Array, implements NS Fast Enumeration.

00:53:03.719 --> 00:53:10.679
And since there's a protocol for this stuff you can
actually implement fast animation in your own classes

00:53:10.679 --> 00:53:12.649
by implementing the fast animation protocol.

00:53:12.650 --> 00:53:16.880
There is just one method you have to implement.

00:53:16.880 --> 00:53:18.289
Optional methods and protocols.

00:53:18.289 --> 00:53:23.440
I showed you an example of this earlier where
we had the Print Panel accessorizing protocol.

00:53:23.440 --> 00:53:27.210
So what this means is that for an object to be conforming

00:53:27.210 --> 00:53:31.289
to a protocol is just needs to
implement the methods that are valid.

00:53:31.289 --> 00:53:34.159
It can optionally implement the optional methods.

00:53:34.159 --> 00:53:39.559
This puts a little bit of a burden on the caller,
or the caller has to be response to selector to see

00:53:39.559 --> 00:53:42.920
if the object responds to those optional methods.

00:53:42.920 --> 00:53:44.470
Now, what are the benefits of this?

00:53:44.469 --> 00:53:50.049
Well, one benefit is now you can add
methods to a protocol in a later release.

00:53:50.050 --> 00:53:55.830
Without this feature, if we publish the protocol
and your objects implemented this protocol,

00:53:55.829 --> 00:54:00.989
and if we added two new methods to that protocol
later, your object would suddenly be non conforming.

00:54:00.989 --> 00:54:02.119
You know, it would be in this situation where, hey --
so we would have to

00:54:02.119 --> 00:54:08.559
maybe invent a new protocol or
create additional protocol and so on.

00:54:08.559 --> 00:54:12.250
So this enables us to get around it
by added those methods as optional.

00:54:12.250 --> 00:54:16.239
Another benefit is that this enables using
protocol for declaring delegate methods.

00:54:16.239 --> 00:54:21.599
Now if you're familiar with delegate methods in Cocoa,
they're often declared as informal protocols NS objects.

00:54:21.599 --> 00:54:28.110
But with these optional methods and protocols,
we intend to convert all our delegate methods

00:54:28.110 --> 00:54:30.690
to actually be protocols with optional methods.

00:54:30.690 --> 00:54:37.599
Here's an example that actually has been added in Leopard
for the new path control in the path cell classes.

00:54:37.599 --> 00:54:42.739
These -- this is a -- here's a delegate --
here's a protocol defining a delegate method.

00:54:42.739 --> 00:54:45.209
And the two methods in there are optional.

00:54:45.210 --> 00:54:47.300
Since typically delegate methods are optional.

00:54:47.300 --> 00:54:52.680
And so all the methods in this protocol are optional.

00:54:52.679 --> 00:54:55.739
And again, you know, you might be
asking why isn't this done everywhere.

00:54:55.739 --> 00:54:59.179
Well, it just hasn't happened yet.

00:54:59.179 --> 00:55:02.349
Okay. Now Objective-C has support for GC attributes.

00:55:02.349 --> 00:55:05.420
This is not something -- I don't
think they talked about any yesterday.

00:55:05.420 --> 00:55:07.800
But it's actually a pretty powerful new feature.

00:55:07.800 --> 00:55:12.420
These GCC attributes enable decorating
declarations with meta data.

00:55:12.420 --> 00:55:14.530
And they actually look God awful.

00:55:14.530 --> 00:55:15.680
There's an example.

00:55:15.679 --> 00:55:22.599
What this -- what this horrendous yellow
thing says is that the first argument

00:55:22.599 --> 00:55:26.000
of this function is a print out-like argument.

00:55:26.000 --> 00:55:31.440
So that any percent Ds, percent Ss,
whatever in there, should be paired with,

00:55:31.440 --> 00:55:34.070
you know, arguments in the rest of the functional.

00:55:34.070 --> 00:55:35.240
So it's fairly powerful.

00:55:35.239 --> 00:55:37.909
However, this attribute syntax is gnarly.

00:55:37.909 --> 00:55:42.210
We go ahead and create macros to cover
this up a bit in many of the cases.

00:55:42.210 --> 00:55:44.720
And let me show you some of the other usage scenarios.

00:55:44.719 --> 00:55:46.679
For instance, availability and deprecations.

00:55:46.679 --> 00:55:52.730
As lenient as a new method we've added, and it's
got this declaration available in 10.5 and later.

00:55:52.730 --> 00:55:55.010
This is -- also the Compiler will pay attention to this.

00:55:55.010 --> 00:55:58.590
If you are compiling against 10.4 it will warn you.

00:55:58.590 --> 00:55:59.970
The C string method.

00:55:59.969 --> 00:56:04.339
Famously deprecated a long time
ago, it now has a declaration on it.

00:56:04.340 --> 00:56:06.769
If you try to use it, we'll give you a warning.

00:56:06.769 --> 00:56:09.969
Another usage case here is putting sample requirements.

00:56:09.969 --> 00:56:14.659
A common pitfall in Cocoa applications
is, like, saying NS Array with objects,

00:56:14.659 --> 00:56:17.849
which takes a list of objects and
you forget to put the nil is in.

00:56:17.849 --> 00:56:23.529
We now have this declaration at the end which causes
the Compiler to warn you if you forget to put the nil.

00:56:23.530 --> 00:56:25.050
And again -- yes, it is a nice thing.

00:56:25.050 --> 00:56:31.010
( Applause )
>> And again, if you look at this declaration you
will see it in terms of these attribute things.

00:56:31.010 --> 00:56:34.610
But we try to hide a mess.

00:56:34.610 --> 00:56:36.710
Using advantaged OBGCO features.

00:56:36.710 --> 00:56:38.300
That's Thursday afternoon.

00:56:38.300 --> 00:56:40.870
Right before we all go get drunk.

00:56:40.869 --> 00:56:43.349
But anyway -- Thursday afternoon.

00:56:43.349 --> 00:56:45.789
And at least it's now in this area.

00:56:45.789 --> 00:56:47.329
We don't go all the way to Apple any more for this.

00:56:47.329 --> 00:56:53.340
But anyway -- this talk will go not only into
this feature, but also go exceptions, protocols,

00:56:53.340 --> 00:56:57.250
and a bunch of other things I just talked about.

00:56:57.250 --> 00:57:01.139
Okay, and here's my absolute favorite feature in Leopard.

00:57:01.139 --> 00:57:03.389
Non ASCII and constant NS traits.

00:57:03.389 --> 00:57:07.210
( Applause )

00:57:07.210 --> 00:57:09.829
>> Okay, well, actually it's not in the seed yet.

00:57:09.829 --> 00:57:10.170
But --

00:57:10.170 --> 00:57:13.690
( Laughter )
>> I am just telling you -- again, it's between us.

00:57:13.690 --> 00:57:14.789
Don't tell it to anybody else.

00:57:14.789 --> 00:57:17.170
You know, it's -- we normally don't
talk about things that are not there.

00:57:17.170 --> 00:57:19.230
But this is so exciting I just had to tell you.

00:57:19.230 --> 00:57:22.590
So now you can go ahead and do things like this.

00:57:22.590 --> 00:57:25.030
You can use the first form, which is very safe.

00:57:25.030 --> 00:57:30.870
You are just using uni code, U NS 16 code points
to put non ASCII characters in your string.

00:57:30.869 --> 00:57:32.199
This will work everywhere.

00:57:32.199 --> 00:57:33.179
It's great.

00:57:33.179 --> 00:57:39.039
And by the way, programs using this will work all the way
back to -- theoretically, they will work back to 10.2,

00:57:39.039 --> 00:57:43.909
but there are many other reasons applications won't work
back to 10.2, so anyway, the runtime knows about this.

00:57:43.909 --> 00:57:48.089
Another way to represent this is with example
-- for example, is with UTF8 strings.

00:57:48.090 --> 00:57:50.710
This is even less readable than the other format.

00:57:50.710 --> 00:57:53.269
But of course the most desirable way to represent this is

00:57:53.269 --> 00:57:56.579
by actually typing those characters
as you see in the third example.

00:57:56.579 --> 00:57:59.440
With that, you know, funny little infamous snow man there.

00:57:59.440 --> 00:58:06.030
Now to do the third form you really, really must trust
your editor not to lose the encoding of your file.

00:58:06.030 --> 00:58:07.850
And Xcode does a great job of this.

00:58:07.849 --> 00:58:09.500
It knows the end coding of your file.

00:58:09.500 --> 00:58:15.210
But for instance if you ever open that file in some other
lesser editor and save it, it might ruin your files.

00:58:15.210 --> 00:58:20.389
So this is something that, you know, to do
this you must be brave and trust your tools.

00:58:20.389 --> 00:58:22.339
But if you can do it, it's of course great.

00:58:22.340 --> 00:58:24.340
Now one thing here though.

00:58:24.340 --> 00:58:29.230
This feature doesn't mean you can now take all the
localized string calls in your application and dump them.

00:58:29.230 --> 00:58:32.969
You still need to localize all the strings
which are shown to the user, of course,

00:58:32.969 --> 00:58:36.829
by using macros like NS Localized String and so on.

00:58:36.829 --> 00:58:43.739
But now you can actually use real double quotes, fancy
quotes, long dashes, in the strings you're localizing.

00:58:43.739 --> 00:58:46.769
So that's the feature you're getting here.

00:58:46.769 --> 00:58:47.969
Thank you.

00:58:47.969 --> 00:58:51.969
( Applause )

00:58:51.969 --> 00:58:56.339
>> Okay. Now just very quickly, we're just
going to put up slides of other changes.

00:58:56.340 --> 00:58:57.850
Not even talk about them.

00:58:57.849 --> 00:59:00.779
We have several new controls.

00:59:00.780 --> 00:59:02.850
Rule Editor and Predicate Editor are great.

00:59:02.849 --> 00:59:08.789
They give you the same kind of UI that you see
in Mail and Finder for creating search rules.

00:59:08.789 --> 00:59:09.920
Path Control.

00:59:09.920 --> 00:59:13.559
Again. If you're showing paths in your
applications, if you're getting paths from the users,

00:59:13.559 --> 00:59:15.380
path control is an object you should look at.

00:59:15.380 --> 00:59:17.230
We have a bunch of other new classes.

00:59:17.230 --> 00:59:21.510
Dictionary controller for bindings, we
have a great new tracking area class

00:59:21.510 --> 00:59:24.940
which gives much finer control over tracking areas.

00:59:25.980 --> 00:59:27.960
And other significant changes.

00:59:27.960 --> 00:59:29.210
There's tons more.

00:59:29.210 --> 00:59:32.340
You should really look through the
release notes to see what these are.

00:59:32.340 --> 00:59:33.500
Table out line view.

00:59:33.500 --> 00:59:35.539
Much better keyboard handling, for instance.

00:59:35.539 --> 00:59:36.579
Open panel, save panel.

00:59:36.579 --> 00:59:41.360
If you've seen it, it's got the Finder
like side bar, it supports icons and so on.

00:59:41.360 --> 00:59:42.360
A lot of changes.

00:59:42.360 --> 00:59:46.190
Many other changes throughout the --
throughout Foundation, Core Data and AppKit.

00:59:46.190 --> 00:59:49.639
And of course all the other frameworks as well.

00:59:49.639 --> 00:59:54.389
Okay. So, with that, let's talk a bit about best practices.

00:59:54.389 --> 01:00:00.039
And this is -- these are mostly best practices
as you write your application for Leopard.

01:00:00.039 --> 01:00:06.489
So one best practice is use properties.

01:00:06.489 --> 01:00:14.769
Just single handedly, properties feature will help
eliminate dozens, hundreds of lines of source code.

01:00:14.769 --> 01:00:18.039
And this is typically the kind of source
code that suffers from copy-paste errors.

01:00:18.039 --> 01:00:22.289
Because you write your set-get methods, and then you
copy, paste them and you forget to change one thing.

01:00:22.289 --> 01:00:26.079
And there are tools out there -- I mean there are
tools out there that help you write your accessors

01:00:26.079 --> 01:00:28.670
and properties will eliminate all that work.

01:00:28.670 --> 01:00:32.380
For a new application, consider Garbage Collection.

01:00:32.380 --> 01:00:35.980
Now I talked earlier about why you would
consider this for a new application.

01:00:35.980 --> 01:00:40.289
But there's one reason why Garbage
Collection might not be appropriate yet.

01:00:40.289 --> 01:00:43.920
For an app to run garbage collected,
all the frameworks it depends on,

01:00:43.920 --> 01:00:46.619
all the libraries it depends on must be garbage collected.

01:00:46.619 --> 01:00:49.719
That includes all the plug-ins that might load.

01:00:49.719 --> 01:00:52.119
That's not a problem for Apple frameworks.

01:00:52.119 --> 01:00:57.339
But if you're using some third party frameworks which
are not yet garbage collected you might want to --

01:00:57.340 --> 01:01:02.510
you might want to consider that maybe evangelize to get
those frameworks also to convert to Garbage Collection.

01:01:02.510 --> 01:01:08.950
But anyway, that's something -- you know, make sure all
your dependencies are available in a garbage-collected form.

01:01:08.949 --> 01:01:12.639
Be 64-bit ready.

01:01:14.280 --> 01:01:17.900
Now you might not think you want to ship
a 64-bit app yet, and you don't need to.

01:01:17.900 --> 01:01:24.079
You know, there are some reasons to shipped 64-bit apps,
but many applications don't yet -- aren't yet there.

01:01:24.079 --> 01:01:25.869
But it's important to be 64-bit ready.

01:01:25.869 --> 01:01:29.529
Instead of using Ints and unsigned Ints, use NS integers.

01:01:29.530 --> 01:01:30.350
CG floats.

01:01:30.349 --> 01:01:33.839
Once in a while compile your app for
64-bit and see what warnings there are.

01:01:33.840 --> 01:01:38.960
And you know, if you do those things your app will
probably be 64-bit ready thde day you want to ship it.

01:01:38.960 --> 01:01:44.289
And you can even -- if you're shipping your application
for Tiger you can make it 64-bit ready even there.

01:01:44.289 --> 01:01:48.289
All you have to do is define -- when
I say it's going to be 64-bit ready,

01:01:48.289 --> 01:01:52.590
I'm saying your app which is 64-bit
for Leopard will still run on Tiger.

01:01:52.590 --> 01:01:55.079
All you have to do is define NS
integer, U integer, and CG float

01:01:55.079 --> 01:01:58.099
using those simple definitions I showed earlier.

01:01:58.099 --> 01:02:04.739
That way your app can still compile on Tiger,
and on Leopard it can compile as 64-bit.
d

01:02:04.739 --> 01:02:06.819
Use multiple processors effectively.

01:02:06.820 --> 01:02:09.880
Clearly, as you heard yesterday, that is the direction.

01:02:09.880 --> 01:02:15.400
You know, instead of adding more
CPU cycles we're adding cores.

01:02:15.400 --> 01:02:17.769
And having an application that can take advantage of mean,

01:02:17.769 --> 01:02:22.210
that means your application will benefit
from increasing the number of cores.

01:02:22.210 --> 01:02:23.470
Use NS Operations.

01:02:23.469 --> 01:02:28.699
Think about how your applications can
be made more thread safe and so on.

01:02:28.699 --> 01:02:30.799
Take advantage of new features.

01:02:30.800 --> 01:02:37.400
Now, some of the features I've shown you require one
line, some require zero lines, some require two lines.

01:02:37.400 --> 01:02:39.220
There's one that requires half a line.

01:02:39.219 --> 01:02:42.500
So you know, sometimes enabling
new features is very little work.

01:02:42.500 --> 01:02:45.650
You can go in and enable non contiguous
layouts in the text system.

01:02:45.650 --> 01:02:50.820
And unless you're doing something very sophisticated, it
will probably require no more changes to your application.

01:02:50.820 --> 01:02:53.530
You can, for instance, enable auto saving in this document.

01:02:53.530 --> 01:02:58.290
That literally requires only one or two lines, and
suddenly there's a brand new feature in your application.

01:02:58.289 --> 01:03:01.719
An ability to save your documents automatically.

01:03:01.719 --> 01:03:04.919
So if your app or the system crashes,
you know, they're there.

01:03:04.920 --> 01:03:08.119
And you know, you can do these even if
your app still needs to run on Tiger.

01:03:08.119 --> 01:03:15.299
You can do something like response a selector, continue set
-- contiguous set, contiguous set needs continuous layout.

01:03:15.300 --> 01:03:17.769
And if it's not there you know you're
on Tiger and you just don't call it.

01:03:17.769 --> 01:03:21.849
So it's possible to use these dynamic determinations.

01:03:21.849 --> 01:03:23.369
Avoid deprecated APIs.

01:03:23.369 --> 01:03:27.139
Now that we've started deprecating
them it's easier for you to find them.

01:03:27.139 --> 01:03:29.089
Not all of them have been deprecated yet.

01:03:29.090 --> 01:03:33.140
But anyway, you know, just if you
see deprecated APIs, don't use them.

01:03:33.139 --> 01:03:35.960
Use the suggested replacements instead.

01:03:35.960 --> 01:03:39.530
And please don't use private or undeclared APIs.

01:03:39.530 --> 01:03:41.670
This always ends in tears.

01:03:41.670 --> 01:03:45.010
Either for you, or for us, or for the user.

01:03:45.010 --> 01:03:48.980
You know, as we work hard to try to wrap Leopard up.

01:03:48.980 --> 01:03:54.900
The biggest problems we run into are applications
which have used private, undeclared functionality.

01:03:54.900 --> 01:03:59.000
Therefore they are breaking our assumptions
on how our objects are being used.

01:03:59.000 --> 01:04:00.219
It's -- it's really a big problem.

01:04:00.219 --> 01:04:04.509
And gets bigger, of course, as
there's more APIs to choose from.

01:04:04.510 --> 01:04:09.220
And finally, start with the highest level of abstraction.

01:04:09.219 --> 01:04:14.250
And this is an important enough point that I'm
just going to talk a little bit more about it.

01:04:14.250 --> 01:04:16.159
Just give examples first.

01:04:16.159 --> 01:04:19.889
An example is use NS View instead of Core Animation.

01:04:19.889 --> 01:04:25.289
If you want to animate things in your Cocoa
application to view later, start by using NS View.

01:04:25.289 --> 01:04:27.360
Turn on layer backing.

01:04:27.360 --> 01:04:29.440
See how well that suits your needs.

01:04:29.440 --> 01:04:35.210
If you find that doesn't suit your needs, you need much
more control, that's the time to go to Core Animation and,

01:04:35.210 --> 01:04:37.440
you know, start doing more advanced things.

01:04:37.440 --> 01:04:46.099
Now of course the reason for this is, in NS View you get
all sorts of features like event handling, tool tips,

01:04:46.099 --> 01:04:50.889
tracking areas, training, accessibility --
the moment you drop down to Core Animation

01:04:50.889 --> 01:04:55.279
and start doing your own drawing, you know,
you have to consider these other features.

01:04:55.280 --> 01:04:57.820
Do you have to enable them, and
if so how are you going to do it.

01:04:57.820 --> 01:05:01.250
So there's a lot of stuff NS View does for you.

01:05:01.250 --> 01:05:08.980
Another example here is use NS types instead of CG types,
or CF types or other lower level types whenever you can.

01:05:08.980 --> 01:05:11.300
For instance, NS font is FCG font.

01:05:11.300 --> 01:05:13.700
S C array instead of CF array and so on.

01:05:13.699 --> 01:05:15.319
And what are the reasons for these?

01:05:15.320 --> 01:05:18.030
Well, one thing is this thing we call impedence matching.

01:05:18.030 --> 01:05:21.420
If you have an NS font it will
work with Cocoa APIs much better.

01:05:21.420 --> 01:05:24.559
If you have a CG font you will have to
convert it to an NS font at some point.

01:05:24.559 --> 01:05:25.739
So you are paying that cost.

01:05:25.739 --> 01:05:28.649
You are constantly going through this conversion process.

01:05:28.650 --> 01:05:34.450
In addition, using NS types -- NS types
are a lot more Garbage Collection friendly.

01:05:34.449 --> 01:05:39.889
The moment you start using CF types, some of
the retain release behaviors are different

01:05:39.889 --> 01:05:41.900
in the garbage collected world for CF types.

01:05:41.900 --> 01:05:46.110
And you've got to worry about the
bridging between those objects.

01:05:46.110 --> 01:05:51.050
Another example here -- another thing I
mean, is use higher level functionality.

01:05:51.050 --> 01:05:57.039
If you have some algorithm, you know, for dealing with
C strings, like Cons Care Star (Phonetic), or Point,

01:05:57.039 --> 01:06:01.449
or Plus Plus, the first inclination
might be to convert the character index.

01:06:01.449 --> 01:06:03.039
NS string character index.

01:06:03.039 --> 01:06:09.320
That's often the wrong approach because it exposes you to
the -- some of the dirty, undersides of Unicode where --

01:06:09.320 --> 01:06:12.410
you know, Unicode's very complicated because in the end.

01:06:12.409 --> 01:06:16.029
It supports a lot of things, but there
are sometimes multiple characters need

01:06:16.030 --> 01:06:18.360
to come together to represent one character.

01:06:18.360 --> 01:06:20.309
You know, what the user might think of as a character.

01:06:20.309 --> 01:06:20.900
And so on.

01:06:20.900 --> 01:06:23.660
There are surrogate pairs and all this stuff.

01:06:23.659 --> 01:06:28.569
So instead of using character with index and deal with
these issues yourself, use higher level functionality

01:06:28.570 --> 01:06:31.590
like has prefix, arrange in string, and so on.

01:06:31.590 --> 01:06:34.710
NS string has a whole set of rich
functionality that can help you here.

01:06:34.710 --> 01:06:38.970
Similarly, instead of using objects that index
and NS Array, used enumeration facilities,

01:06:38.969 --> 01:06:41.939
like make objects perform selector, or the four in.

01:06:41.940 --> 01:06:45.200
This -- if you use those array
nodes you're trying to enumerate

01:06:45.199 --> 01:06:50.509
and can optimize the access patterns while you're
using object at index, the array doesn't notice.

01:06:50.510 --> 01:06:53.710
One final example here is NS document.

01:06:53.710 --> 01:07:00.679
You know, NS document does a great job of saving files
on different file systems, handling the meta data,

01:07:00.679 --> 01:07:05.639
handling it with all the quirks, doing appropriate
back up copies, auto saving and the whole --

01:07:05.639 --> 01:07:10.359
and I don't envy them on the work NS document has to do,
it's just a lot of work.

01:07:10.360 --> 01:07:14.309
And if you have to replicate them in your own
applications, you know, you could be a lot more productive

01:07:14.309 --> 01:07:21.610
by letting NS document handle that, and you concentrate on
the things, of course, that differentiate your application.

01:07:21.610 --> 01:07:25.059
By the way, on NS document one
thing to mention is TextEdit.

01:07:25.059 --> 01:07:30.759
The word processor now using NS document in Leopard
so it could be a good showcase for what it is.

01:07:30.760 --> 01:07:32.970
Okay, so why do you want to do all this?

01:07:32.969 --> 01:07:38.369
Well, this way you know, we can change implementation
on their issue, we can improve it, we speed it up,

01:07:38.369 --> 01:07:41.819
we add more features, and now this document
can do more things for you , for instance.

01:07:41.820 --> 01:07:42.970
And so on.

01:07:42.969 --> 01:07:44.869
And therefore you will be leveraging us.

01:07:44.869 --> 01:07:48.289
So, you know, so we're providing the
foundation for you to build upon.

01:07:48.289 --> 01:07:50.809
And you know, we enable you to ship innovative applications.

01:07:50.809 --> 01:07:53.730
Concentrate on the things that you want to ship.

01:07:53.730 --> 01:07:59.719
That's why you should always start with
the highest level abstraction that you can.

01:07:59.719 --> 01:08:02.439
So that's that.

01:08:02.440 --> 01:08:04.720
Please, for more information you can contact Deric Horn.

01:08:04.719 --> 01:08:06.489
The application's Framework Evangelist.

01:08:06.489 --> 01:08:11.379
He's down here in the front row right now of the we have
the usually attendee site with a lot of documentation

01:08:11.380 --> 01:08:16.329
and sample programs, and the reminder that we have
source codes to applications like TextEdit and Sketch

01:08:16.329 --> 01:08:19.750
and many more available on your
machine and developer examples folder.
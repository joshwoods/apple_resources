WEBVTT

00:00:20.010 --> 00:00:21.780
>> My name is Steve Peters.

00:00:21.780 --> 00:00:24.550
I work in the Mac OS X Performance Group.

00:00:24.550 --> 00:00:29.339
My colleague James McIlree is in front and
he'll join me later to answer questions.

00:00:29.339 --> 00:00:31.800
We'd like to tell you a bit about DTrace today.

00:00:31.800 --> 00:00:35.230
And this will be a very practical hands on presentation.

00:00:35.229 --> 00:00:39.669
Are they any DTrace users in the audience today?

00:00:39.670 --> 00:00:40.789
Okay, there's a smattering.

00:00:40.789 --> 00:00:42.359
Yeah. Right?

00:00:42.359 --> 00:00:46.079
I think you'll find a lot that's very,
very familiar, identical in fact.

00:00:46.079 --> 00:00:52.429
And for the rest of you, we hope you'll
be DTrace users by the end of this hour.

00:00:52.429 --> 00:01:00.390
So, DTrace is a system observability
facility that's new to Mac OS X in Leopard.

00:01:00.390 --> 00:01:05.269
It joins the rich collection of Mac OS X
development tools already present in Leopard,

00:01:05.269 --> 00:01:07.310
in some cases extending the reach of what you can do.

00:01:07.310 --> 00:01:13.700
And in some case consolidating which
helped us in our work on Leopard.

00:01:13.700 --> 00:01:20.049
But more important, you can use DTrace to gain
insight into the behavior of your applications.

00:01:21.459 --> 00:01:27.069
And we're very pleased to acknowledge right up front
that DTrace was developed at Sun Microsystems.

00:01:27.069 --> 00:01:31.109
It's open soft, open source software.

00:01:31.109 --> 00:01:38.890
Appears in Open Solaris and we did the port
to Mac OS X over the last 18 months or so.

00:01:38.890 --> 00:01:41.140
So what do I think you're going to learn today?

00:01:41.140 --> 00:01:45.079
First, what DTrace is and a little bit about what it's not.

00:01:45.079 --> 00:01:46.170
How to use DTrace.

00:01:46.170 --> 00:01:52.180
You should come away and you may even want to try doing
this as you sit here today, typing small DTrace scripts

00:01:52.180 --> 00:01:56.630
and gaining some interesting insights
into the system you're working on.

00:01:56.629 --> 00:02:00.609
We'll talk in some detail about the D language, including,

00:02:00.609 --> 00:02:03.769
you'll see some patterns and maybe
some pitfalls along the way.

00:02:03.769 --> 00:02:07.079
We'll talk about the DTrace ToolKit.

00:02:07.079 --> 00:02:10.939
And you don't want to leave home without
that if you're a sys admin or a,

00:02:10.939 --> 00:02:14.780
a developer whose out in the field correcting problems.

00:02:14.780 --> 00:02:20.629
And we'll talk a bit about the roster of DTrace
providers that we're going to ship with Leopard.

00:02:22.509 --> 00:02:28.129
So if anybody has to write a trip report and report
on what this session is about, here's your slide.

00:02:28.129 --> 00:02:33.900
DTrace is a comprehensive, dynamic
tracing framework for Mac OS X.

00:02:33.900 --> 00:02:39.849
DTrace provides a powerfool infrastructure to
administrators, developers and service personnel

00:02:39.849 --> 00:02:45.489
to concisely answer arbitrary questions about the
behavior of the operating system and user programs.

00:02:45.490 --> 00:02:51.330
It's written by Sun, probably by marketing folks
and it's a nice, high level pitch about DTrace.

00:02:51.330 --> 00:02:55.600
I think the important piece here is
arbitrary questions and you'll see how

00:02:55.599 --> 00:02:59.439
that emerges as a theme throughout the talk today.

00:02:59.439 --> 00:03:02.829
So what are the advantages of DTrace?

00:03:02.830 --> 00:03:04.530
Why did we take this on?

00:03:04.530 --> 00:03:09.090
As we said it's new and unique tracing
technology in Leopard, what's unique about it?

00:03:09.090 --> 00:03:11.450
First of all zero disabled cost.

00:03:11.449 --> 00:03:13.849
We think this is an important feature.

00:03:15.120 --> 00:03:22.500
There, you'll see thousands and thousands of probe
points, points where you could collect data in Leopard,

00:03:22.500 --> 00:03:27.580
yet they cost you nothing if you
don't use them or very nearly nothing.

00:03:28.719 --> 00:03:31.330
DTrace is dynamic.

00:03:31.330 --> 00:03:38.219
You don't need to start an application, stop it,
decompile it, set flags, reboot, you just use DTrace,

00:03:38.219 --> 00:03:43.710
point it at the facility you want to
investigate and let it go.

00:03:45.080 --> 00:03:46.820
It's system-wide.

00:03:46.819 --> 00:03:53.289
You can see the tiniest bit down in the guts of the
kernel all the way up through Cocoa Applications

00:03:53.289 --> 00:03:57.299
and messages being passed among objects there.

00:03:57.300 --> 00:03:59.060
DTrace is always available.

00:03:59.060 --> 00:04:01.069
We're going to ship it as part of the user install.

00:04:01.069 --> 00:04:05.250
You can use it diagnose problems in the field.

00:04:05.250 --> 00:04:08.360
Yea. And it's comprehensive.

00:04:08.360 --> 00:04:15.910
Essentially any place a threat of execution
can land, DTrace can shed some light.

00:04:15.909 --> 00:04:23.339
And the piece that's most important to me or most impressed
me, is it's programmable, programmable, programmable.

00:04:23.339 --> 00:04:24.589
All right?

00:04:24.589 --> 00:04:28.819
There's a language, an interpreter,
a model of execution and the freedom

00:04:28.819 --> 00:04:34.879
to turn the ship any way you want
that's unlike most of the tracing tools

00:04:34.879 --> 00:04:39.079
that you perhaps have encountered along your careers.

00:04:40.269 --> 00:04:46.870
And the, the exhortation here is pose and
answer arbitrary questions, follow your nose.

00:04:46.870 --> 00:04:51.250
Do an experiment, look at the DTrace output, scratch head,

00:04:51.250 --> 00:04:55.980
think about what might be the next interesting
question to ask, immediately code that and go.

00:04:55.980 --> 00:04:58.550
It has that style of interaction.

00:05:00.100 --> 00:05:04.680
And it turns out DTrace is an important
enabling technology for the Xray tool

00:05:04.680 --> 00:05:09.639
and you learned about that yesterday in session 309.

00:05:09.639 --> 00:05:16.319
There's a DTrace instrument template where you can do
some of the same kind of improvisational programming

00:05:16.319 --> 00:05:19.699
to build new instruments in Xray with DTrace.

00:05:20.970 --> 00:05:25.850
So just as important as what DTrace
is, is what DTrace isn't.

00:05:25.850 --> 00:05:29.470
It doesn't replace all your tried and true tools.

00:05:29.470 --> 00:05:32.330
You're still going to be using the
right tool for the job at hand.

00:05:32.329 --> 00:05:37.639
So for example, if you need instruction level
timings and you're tightest loops, look to Shark.

00:05:37.639 --> 00:05:42.839
I mean that's been really worked out very carefoolly
and beautifoolly over the last couple of years.

00:05:42.839 --> 00:05:49.810
For memory leaks, go straight to Xray's ObjectAlloc
template or the Guard Malloc libraries.

00:05:49.810 --> 00:05:56.910
For figuring out where something might be hung up or
spinning under the spad, go to the sampler instrument.

00:05:56.910 --> 00:05:59.470
And there's no magic here with DTrace.

00:05:59.470 --> 00:06:00.880
You still have to understand the problem.

00:06:00.879 --> 00:06:08.209
It's not a one push button solution to, to all
performance problems or bug investigations.

00:06:08.209 --> 00:06:16.079
You need to be able to generate hypothesis, write a
little script, interpret the results, and iterate.

00:06:16.079 --> 00:06:20.469
All right, so for the visual learners
like myself, here's a picture.

00:06:20.470 --> 00:06:28.170
There, there's quite a lot of software in the DTrace stack,
but it sort of naturally bisects into what sits in user land

00:06:28.170 --> 00:06:32.259
above the dash line and what sits inside the kernel.

00:06:32.259 --> 00:06:41.110
So in user land, sort of starting from the top, you're going to
express your analysis and investigation steps in scripts.

00:06:41.110 --> 00:06:44.750
Often you'll write these at the command line, sometimes
they'll be large enough that you'll want to put them

00:06:44.750 --> 00:06:48.300
in a text file, edit them and send them through.

00:06:48.300 --> 00:06:55.780
And what you send them through is a command line interpreter
called /usr/sbin/dtrace, DTrace at the command line.

00:06:55.779 --> 00:07:01.319
It talks to a, it's a sort of a thin
veneer on lib.dtrace.dylib,

00:07:01.319 --> 00:07:05.759
dtrace.dylib is a compiler for the D Language.

00:07:05.759 --> 00:07:12.449
It all, it knows how to communicate with the
kernel layer in an organized and safe fashion.

00:07:12.449 --> 00:07:16.120
And it turns out that that's the place
that Xray hooks into too, is libdtrace.

00:07:16.120 --> 00:07:19.259
So it's got a couple of clients.

00:07:19.259 --> 00:07:24.550
Below the line in the kernel sort of the big
piece of DTrace, the DTrace virtual machine.

00:07:24.550 --> 00:07:28.819
Interprets the byte codes, sets up
the trace points, collects the data,

00:07:28.819 --> 00:07:34.159
sends it back up into user land for you to look at it.

00:07:34.160 --> 00:07:43.250
The virtual machine in turn relies on a set of semantically
knowledgeable modules that are called providers.

00:07:43.250 --> 00:07:50.279
So if you're interesting for example in important events
in the life of a process, you'll turn to the proc provider

00:07:50.279 --> 00:07:57.089
and see things like exec starts, exits,
forks, lightweight thread starts and so forth.

00:07:57.089 --> 00:08:03.079
If you're interested in when io gets started and
finishes up, you'll appeal to the io provider.

00:08:03.079 --> 00:08:09.620
Similarly if you want to run profiling experience,
experiments, catch events on millisecond boundaries

00:08:09.620 --> 00:08:12.530
for example, you'll turn to the profile provider.

00:08:12.529 --> 00:08:16.549
We'll be spending a lot of time
with the system call provider.

00:08:16.550 --> 00:08:22.970
Remember system calls are the programming interfaces
that sort of span the user land to kernel boundary.

00:08:22.970 --> 00:08:30.920
Things like read, write, select, get me some memory, exit.

00:08:32.690 --> 00:08:38.500
And really interesting provider here that James
has done a lot of work on is a fasttrap provider.

00:08:38.500 --> 00:08:44.450
It knows how to reach from the kernel,
back into user land, place instrumentation,

00:08:44.450 --> 00:08:48.500
and collect data from the instruments
it places back in user land.

00:08:48.500 --> 00:08:53.899
So we can go right into say malloc in libSystem
and notice when malloc is called,

00:08:53.899 --> 00:08:57.509
notice what the arguments to malloc are and so forth.

00:08:58.870 --> 00:09:03.429
Similarly fasttrap can instrument your application.

00:09:03.429 --> 00:09:06.779
Any function entry point, any return
and any instruction in between.

00:09:06.779 --> 00:09:17.809
In fact, fasttrap is capable of implementing just about
any instruction in the entire memory image of Mac OS X.

00:09:17.809 --> 00:09:22.159
So enough talking, let's take a quick, quick demo.

00:09:22.159 --> 00:09:28.919
So great. So say DTrace here,
I've got the right machine, good.

00:09:28.919 --> 00:09:33.819
And DTrace announces what its arguments
are, what it's command line flags are.

00:09:33.820 --> 00:09:42.330
There are a ton of them, but we'll get away in
most practice using just about five as you'll see.

00:09:42.330 --> 00:09:49.139
And probably the first and most interesting one is to ask
DTrace what are the probe points that you know about?

00:09:49.139 --> 00:09:51.899
Where can I collect data in my system right now?

00:09:51.899 --> 00:09:54.429
So let's clear that out.

00:09:54.429 --> 00:09:56.500
Grab this guy.

00:09:56.500 --> 00:10:01.200
And here I've said DTrace -l
and pushed it through more.

00:10:01.200 --> 00:10:07.640
And we begin to see the sort of
long list of DTrace probe points.

00:10:07.639 --> 00:10:15.860
The left most column, increasing series of small integers
are numeric ID, then we have the name of the provider,

00:10:15.860 --> 00:10:23.039
a module, which helps us disambiguate names, a function
name and a particular point within that function

00:10:23.039 --> 00:10:27.639
where we're going to collect data, where the,
the probe could be attached so to speak.

00:10:27.639 --> 00:10:35.649
So let's see, let's go down and here's, so 19,000
probes later, we hit vminfo, which is going to,

00:10:35.649 --> 00:10:41.959
if we were interested in when paging happens or page
faults occur, we'd take a look at what vminfo can provide.

00:10:41.960 --> 00:10:49.370
There's the proc providers we talked about before,
forks, exits, io provider, when we start and stop io.

00:10:49.370 --> 00:10:59.600
And I think we're pretty close to the end here, so on
this system 19,448 probes in place right now for DTrace.

00:10:59.600 --> 00:11:06.629
And we haven't mentioned the probes that you could provide,
put into any running application, Mail, Safari, your app.

00:11:06.629 --> 00:11:12.230
Which can make this one of probes grow very, very fast.

00:11:12.230 --> 00:11:18.560
It's not unusual to, to see 100,000 probes appear
when you instrument a big Cocoa application.

00:11:19.610 --> 00:11:24.950
So let's, let's latch onto one of these
probes and see what's going on on this system.

00:11:24.950 --> 00:11:30.259
( Period of silence )

00:11:30.259 --> 00:11:33.870
So here's the sort of canonical little DTrace command.

00:11:33.870 --> 00:11:38.389
DTrace -n says I'm going to give
the D Language program right here

00:11:38.389 --> 00:11:42.159
on the command line immediately following and here it is.

00:11:42.159 --> 00:11:49.559
It says, let's look at what the sys call
provider can tell us about everything it knows.

00:11:49.559 --> 00:11:56.149
We say no more, DTrace fills in and says, well we'll
tell you any time a system call is made on this system.

00:11:56.149 --> 00:12:01.340
And we'll pipe that through more because as
you'll see these things go on for quite a while.

00:12:01.340 --> 00:12:08.430
So I don't know if you notice, there are 854 sys call
probes matched and now we begin to see the entry and return

00:12:08.429 --> 00:12:14.000
from a whole, whole long list of these things.

00:12:14.000 --> 00:12:18.600
All right, so absent any specific
direction, DTrace does the natural thing.

00:12:18.600 --> 00:12:20.759
It says, I hit this probe, I'm going to tell you about it.

00:12:20.759 --> 00:12:24.019
Puts it in a buffer and we eventually see it in more.

00:12:26.120 --> 00:12:32.590
But this is sort of an overload of data, there's
an overwhelming amount of stuff to look at.

00:12:32.590 --> 00:12:34.600
Is there some way we can organize this?

00:12:34.600 --> 00:12:40.540
And DTrace has very power, powerfool
facilities for digging into the data,

00:12:40.539 --> 00:12:45.259
massaging it in ways that help
us understand sort of immediately

00:12:45.259 --> 00:12:47.480
with immediate impact what's going on on the system.

00:12:47.480 --> 00:12:49.639
Let's look at one way to do that.

00:12:50.799 --> 00:12:57.699
So again, we're thinking about system calls that are going
on on this you know what other, otherwise is an idle system.

00:12:59.110 --> 00:13:05.399
And again here's that command line, DTrace -n,
I'm going to give you an immediate script here.

00:13:05.399 --> 00:13:09.699
You're again asking the sys call
provider to offer up its probes.

00:13:09.700 --> 00:13:11.940
We'll take all the entry probes.

00:13:11.940 --> 00:13:16.360
And now here in the brackets, we have a
little bit of computation we'd like to do.

00:13:16.360 --> 00:13:25.430
We're going to fill in a table called ag and the rows of the
table will be keyed by the name of the probe, read, write,

00:13:25.429 --> 00:13:30.000
select, ioctal, the particular system call that we dove into.

00:13:30.000 --> 00:13:32.679
And we'll just increment a count for that guy.

00:13:32.679 --> 00:13:37.209
We'll talk a little bit more about what this at
sign syntax means and why we're using the function

00:13:37.210 --> 00:13:39.170
on the right hand side in a couple of minutes.

00:13:39.169 --> 00:13:45.509
But let's just see what happened while I was talking
over that, that data collection was occurring.

00:13:45.509 --> 00:13:51.689
We'll stop the data collection and observe
that a little table was printed out.

00:13:51.690 --> 00:13:57.910
Keyed on the left, my left, by the name
of the system call that we dove into.

00:13:57.909 --> 00:14:01.309
And the value on the right is the number
of times we encountered it, all right

00:14:01.309 --> 00:14:03.759
So sort of simple counting exercise.

00:14:03.759 --> 00:14:08.439
Interesting that these two guys at the top sig
all stack and the sig proc mass, remember those.

00:14:08.440 --> 00:14:17.460
Those are you know, I probably talked for 15 seconds or net
1300 of those, that's a fair amount of system call activity.

00:14:17.460 --> 00:14:22.629
Well, you know sort of the next question following our
nose is well which process is making these system calls?

00:14:22.629 --> 00:14:25.200
You know otherwise, this was an otherwise idle system.

00:14:25.200 --> 00:14:26.740
Can we look into that?

00:14:26.740 --> 00:14:28.190
Well, sure.

00:14:28.190 --> 00:14:29.900
So let's clear this.

00:14:29.899 --> 00:14:33.730
( Period of silence )

00:14:33.730 --> 00:14:35.710
Okay, so same idea.

00:14:35.710 --> 00:14:38.490
going to look at entry probes from sys call.

00:14:38.490 --> 00:14:46.139
We're going to collect them in a table, but now
the index to the table is the process name.

00:14:46.139 --> 00:14:51.789
So as a thread comes through and hits a
system call, say makes a read system call,

00:14:51.789 --> 00:14:54.009
that traps into the DTrace virtual machine

00:14:54.009 --> 00:14:57.389
and the first thing the DTrace virtual
machine says, hm, whose the process?

00:14:57.389 --> 00:15:00.189
What's the name of that process
associated with the thread that did this?

00:15:00.190 --> 00:15:02.950
I'll need to remember that because
someone may make a table like this.

00:15:02.950 --> 00:15:07.250
Well, it doesn't quite work that
way, but it maintains a collection

00:15:07.250 --> 00:15:12.409
of special named variables that
you can use for purposes like this.

00:15:12.409 --> 00:15:18.120
All right, so again after talking for 15 seconds or so, hmm.

00:15:18.120 --> 00:15:22.899
Here's the list of processes now that made system calls.

00:15:22.899 --> 00:15:29.459
And woo, window server at the top with
674 system calls made in that interval.

00:15:29.460 --> 00:15:31.129
I don't know, was I shaking the mouse?

00:15:31.129 --> 00:15:33.330
I'm not so sure.

00:15:34.600 --> 00:15:39.560
So now maybe we can dive in foorther and
ask well, window server, what, what,

00:15:39.559 --> 00:15:42.989
what system calls was window server making?

00:15:42.990 --> 00:15:47.039
And here's a script that'll do just that.

00:15:47.039 --> 00:15:48.589
( Period of silence )

00:15:48.590 --> 00:15:57.440
So now we introduce another element of the
D scripting language, a predicate or filter.

00:15:57.440 --> 00:16:04.710
Enclosed by slashes and it says, whenever
we dive into one of these probe points,

00:16:04.710 --> 00:16:07.870
detect if the name of the process is Windows server.

00:16:07.870 --> 00:16:10.929
If so, go on and do this action, otherwise, you're done.

00:16:10.929 --> 00:16:13.819
Nothing interesting here.

00:16:13.820 --> 00:16:22.390
So when we do see a system call made by Windows server, we're
going to collect it in the style of the original table example,

00:16:22.389 --> 00:16:27.360
namely we'll index by the name of
the system call and count those up.

00:16:27.360 --> 00:16:30.149
So what did we get?

00:16:30.149 --> 00:16:37.250
Oh my goodness, it's the Windows server who's making that
sort of high level of sig alt stack and sig part mass calls.

00:16:37.250 --> 00:16:40.139
So that's sort of there's the paradigm right?

00:16:40.139 --> 00:16:44.090
A series of questions, a series of
scripts and maybe some insight at the end.

00:16:44.090 --> 00:16:50.210
That's our next stop for me is the Windows
server folks and asking what's going on here?

00:16:50.210 --> 00:16:52.820
All right, so back to the slides.

00:16:52.820 --> 00:16:54.550
( Period of silence )

00:16:54.549 --> 00:16:59.709
So what have we been doing?

00:16:59.710 --> 00:17:03.190
We've been writing little DTrace
programs at the command line.

00:17:03.190 --> 00:17:05.220
Here's a summary of what they were.

00:17:05.220 --> 00:17:10.900
Sort of a little growing pattern that we've been using.

00:17:10.900 --> 00:17:14.400
And at the heart of all this was this D Language.

00:17:14.400 --> 00:17:17.310
This is the DTrace D Language not the Mars D Language.

00:17:17.309 --> 00:17:21.909
It's very much like C, you should be, if you know
a little bit of C, or you know a little Perl,

00:17:21.910 --> 00:17:23.540
you should very much at home with the D Language.

00:17:23.539 --> 00:17:29.809
So I mentioned before, it's compiled to bytecodes and
those are passed down into the DTrace virtual machine

00:17:29.809 --> 00:17:35.759
and the kernel, where they're interpreted, sort of held
onto until some probe fires and then off we go and figure

00:17:35.759 --> 00:17:41.660
out if we're going to do some table counting and just
where we're going to put the entries in the table.

00:17:41.660 --> 00:17:48.080
libdtrace.dylib shipping on every user system for
Leopard does most of the heavy work, heavy lifting here.

00:17:48.079 --> 00:17:49.629
The language though is lightweight.

00:17:49.630 --> 00:17:50.950
It's really small.

00:17:50.950 --> 00:17:52.620
It's quite simple.

00:17:52.619 --> 00:17:54.539
There's no explicit control flow.

00:17:54.539 --> 00:17:57.129
There's a sort of technical safety reason for that.

00:17:57.130 --> 00:18:00.130
You don't want to get stuck in a loop by mistake.

00:18:00.130 --> 00:18:05.920
Say if you're tracing I/O interrupts, that
would not be good for the life of your system.

00:18:05.920 --> 00:18:08.490
There are no user defined functions.

00:18:08.490 --> 00:18:10.130
Variable declarations are optional.

00:18:10.130 --> 00:18:15.760
You know you just say what you mean and
variables spring to life, very Perl like.

00:18:15.759 --> 00:18:21.779
The D Language is built of common elements.

00:18:21.779 --> 00:18:27.089
The first are these, the probe clause,
the foondamental element of D program.

00:18:27.089 --> 00:18:29.609
We sort of stretch these out onto one line.

00:18:29.609 --> 00:18:37.199
You can of course, text file, make it
look even more C-like or Perl-like.

00:18:37.200 --> 00:18:40.180
The probe calls, it's lazy.

00:18:40.180 --> 00:18:42.620
You know if you're missing some element for example

00:18:42.619 --> 00:18:46.029
in our first script we omitted the
predicate and the action statements entirely.

00:18:46.029 --> 00:18:48.609
The interpreter fills in something sensible to do.

00:18:48.609 --> 00:18:50.750
Namely announce that you visited this probe.

00:18:50.750 --> 00:18:51.960
All right?

00:18:53.670 --> 00:18:59.720
The first piece in the probe clause is the probe descriptor.

00:18:59.720 --> 00:19:08.089
That's that tupole of four components that uniquely
identify a point in the system where we're collecting data.

00:19:08.089 --> 00:19:09.379
First component is the provider.

00:19:09.380 --> 00:19:10.300
We've talked about that.

00:19:10.299 --> 00:19:12.839
You're familiar with several providers now.

00:19:12.839 --> 00:19:16.250
Second is the module and you'll be
more familiar with that as we go along

00:19:16.250 --> 00:19:21.109
but it's basically a way to set separate name spaces up.

00:19:21.109 --> 00:19:25.809
Then a function, read, write, select, malloc,

00:19:25.809 --> 00:19:28.539
and a particular point within that
function that we might want to probe.

00:19:28.539 --> 00:19:33.119
The entry, the return, some hex offset within some function.

00:19:33.119 --> 00:19:36.959
( Period of silence )

00:19:36.960 --> 00:19:39.650
Supports wild cards, you saw that in our very first example.

00:19:39.650 --> 00:19:42.640
We provided none of module function or name.

00:19:42.640 --> 00:19:43.750
The interpreter did the right thing.

00:19:43.750 --> 00:19:47.880
It said, oh he wants to look at
all 854 of the sys call probes.

00:19:49.809 --> 00:19:55.309
The probe descriptor naturally is really
the only required part of a probe clause.

00:19:55.309 --> 00:19:59.609
You got to say what you want to hook the sys call to.

00:19:59.609 --> 00:20:03.159
Can list probes via DTrace -l,
we've done that already.

00:20:03.160 --> 00:20:10.130
If you want to sharpen that, mine down into what
particular provider might be able to offer,

00:20:10.130 --> 00:20:18.750
you can essentially just set up a probe descriptor when
prefixed with this -l flag, nothing gets enabled,

00:20:18.750 --> 00:20:26.720
no probes fire, but it will list all the
probe matching sys call provider name,

00:20:26.720 --> 00:20:29.690
sorry function being one of the
write system calls on the system.

00:20:29.690 --> 00:20:34.690
There's write, p write, write no
cancel, so forth on Mac OS X.

00:20:37.309 --> 00:20:42.299
Some examples, our very first one, sys
call all the arguments wildcarded.

00:20:43.470 --> 00:20:47.690
Here's a provider that I've referred to
but we haven't seen explicitly before.

00:20:47.690 --> 00:20:54.890
Suppose we want it to look at our process number
1017 and we may have gleaned that from one

00:20:54.890 --> 00:20:58.190
of the other tools on Mac OS X PS or top.

00:20:58.190 --> 00:21:08.830
So we say pid provider, process number 1017, in the module
libSystem, I want to look every place printf returns.

00:21:11.349 --> 00:21:17.369
And finally because Objective-C
plays such a large role on Mac OS X,

00:21:17.369 --> 00:21:22.159
James went ahead an implemented Objective-C
provider that derives from the pid provider.

00:21:22.160 --> 00:21:26.340
So imagine that process 1017 was a Cocoa app.

00:21:26.339 --> 00:21:30.119
We could look into its Objective-C name space.

00:21:30.119 --> 00:21:36.609
Any class or category, we've omitted
the sort of second module piece.

00:21:36.609 --> 00:21:42.759
Any instance method that begins with the
letters draw, wildcard the rest at the entry.

00:21:42.759 --> 00:21:50.799
We'd like to probe those points and fire through
to the rest of the stuff when that's hit.

00:21:50.799 --> 00:21:54.619
Next piece in the probe clause is the predicate.

00:21:54.619 --> 00:21:59.279
That's a condition, a Boolean, a filter.

00:21:59.279 --> 00:22:02.230
We evaluate it every time the probe fires.

00:22:02.230 --> 00:22:06.170
We use it to focus in on just the
pieces of data of interest.

00:22:06.170 --> 00:22:10.509
We may be waiting for an obscure
condition that triggers a bug.

00:22:10.509 --> 00:22:16.140
This is a way to sort of keep our probes
out of the way until that event happens.

00:22:16.140 --> 00:22:22.050
And then start collecting lots and lots of interesting
data to help us diagnose a particular situation.

00:22:23.910 --> 00:22:29.060
Some quick examples we've already seen, the
comparison of the special variable exec name

00:22:29.059 --> 00:22:31.859
that the interpreter maintains with a fixed string.

00:22:31.859 --> 00:22:37.319
We might be interested in when Perl for
example makes and open sys call, right?

00:22:37.319 --> 00:22:44.409
So combining the probe descriptor that tells us what
we're looking at, the filter to say when we want to see it.

00:22:44.410 --> 00:22:48.590
We might go on to do some interesting data logging activity.

00:22:50.190 --> 00:22:53.990
So here we refer to sort of an arithmetic Boolean.

00:22:53.990 --> 00:23:01.539
If my call count exceeds five, then we're going to
trap into the action statements for this probe,

00:23:01.539 --> 00:23:04.049
post incrementing the my count call along the way.

00:23:04.049 --> 00:23:07.619
If my call count is less than five, we don't bother.

00:23:07.619 --> 00:23:16.519
Perhaps the first five opens are uninteresting to us, but on
the sixth one our app falls apart and we'd like to know why.

00:23:18.740 --> 00:23:26.029
And finally we can actually dig in to the state
of the probe that fired itself a little bit.

00:23:26.029 --> 00:23:36.269
Here, if we ask for the tripping on entry point to
open sys call, we can look at its arguments list.

00:23:36.269 --> 00:23:41.750
Right? Argument zero to the open system call happens
to be the string name of the file we're about to open.

00:23:41.750 --> 00:23:46.579
We can get a hold of that through copyinstr, talk
about that in a moment, and compare it to a fixed string.

00:23:46.579 --> 00:23:55.000
So we might be interested in looking for all the times in
the life of the system when terminal opens its plist file.

00:23:57.319 --> 00:24:03.470
Action statements, this is the computation,
this is sort of the heart of the DTrace probe.

00:24:03.470 --> 00:24:06.539
These are expressions in the D Language.

00:24:06.539 --> 00:24:10.420
Arithmetic, relational, logical,
bit operation, semantics just like C,

00:24:10.420 --> 00:24:13.840
syntax just like C, it's going to be very familiar.

00:24:13.839 --> 00:24:19.449
Other action statements assigned to program variables, you
can remember some state, you can remember that state either

00:24:19.450 --> 00:24:24.870
for the life of the, the duration
of the firing of the probe.

00:24:24.869 --> 00:24:29.399
You can remember it globally for the
duration of the experiment you're running.

00:24:29.400 --> 00:24:34.259
And you can segregate that data perhaps
by the thread on which an event occurs.

00:24:34.259 --> 00:24:37.750
We'll say more about that in a little bit too.

00:24:37.750 --> 00:24:39.880
There are built in functions.

00:24:39.880 --> 00:24:43.090
printf does an actual thing.

00:24:43.089 --> 00:24:48.579
Same syntax as C. Stack, we can ask for
a stack back trace when a probe fires.

00:24:48.579 --> 00:24:51.980
If you're familiar with that from debuggers.

00:24:51.980 --> 00:24:56.420
There are string manipulation functions,
strlen, strtoke, substr.

00:24:56.420 --> 00:25:03.430
And an interesting class of functions that I've
already referred to, copyin, copyinster, copyout.

00:25:05.529 --> 00:25:08.720
We've already mentioned special
variables whose value is maintained

00:25:08.720 --> 00:25:11.549
by the interpreter, execname being the first one.

00:25:11.549 --> 00:25:16.279
probefoonc, the name of the function that was triggered.

00:25:17.759 --> 00:25:19.519
The interpreter also maintains a timestamp.

00:25:19.519 --> 00:25:23.139
It has actually three notions of, of time progressing.

00:25:23.140 --> 00:25:27.080
Wall time, virtual time for the
process and one other version.

00:25:27.079 --> 00:25:32.669
It maintains the, a notion of what process
ID was associated with the thread that ran

00:25:32.670 --> 00:25:34.960
into the probe, the thread ID and so forth.

00:25:34.960 --> 00:25:36.529
There's several more.

00:25:36.529 --> 00:25:37.730
You'll find them in the documentation.

00:25:37.730 --> 00:25:48.650
And in action statements assignments as we mentioned
can just create variables out of thin air so to speak.

00:25:48.650 --> 00:25:54.769
So some simple examples call to printf, where the argument,

00:25:54.769 --> 00:26:00.319
the string argument is actually extracted
from the system call that was made.

00:26:01.890 --> 00:26:07.290
Here we assign that string perhaps we
want to hang on to it to see when it closes,

00:26:07.289 --> 00:26:11.289
there's something interesting about
when that, that file closes.

00:26:11.289 --> 00:26:12.250
Who knows?

00:26:12.250 --> 00:26:20.039
At this point we're interested in when Perl
does an open, where we in the Perl executable?

00:26:20.039 --> 00:26:25.109
So we'll ask for the user stack
trace, stack trace back in user land.

00:26:25.109 --> 00:26:28.149
So let's look at a few more demonstrations.

00:26:30.509 --> 00:26:37.569
( Period of silence )

00:26:37.569 --> 00:26:43.359
So here's that use of printf. The
special built in variable execname.

00:26:43.359 --> 00:26:51.709
That copyin function that's going to pull the first
argument to an open call out of the probe firing.

00:26:51.710 --> 00:26:57.120
And we're going to tag a, put a little extra argument
on the end of the DTrace command that says be quiet,

00:26:57.119 --> 00:27:00.439
print none of the identifying information about the probe.

00:27:00.440 --> 00:27:06.820
We've handled it in our printf. So let's
see what happens when this guy runs.

00:27:06.819 --> 00:27:08.279
So he's off to the races.

00:27:08.279 --> 00:27:10.099
( Period of silence )

00:27:10.099 --> 00:27:17.849
And what happens if we have a look at the about box.

00:27:17.849 --> 00:27:19.569
Right, great.

00:27:19.569 --> 00:27:22.389
All sorts of open calls.

00:27:22.390 --> 00:27:28.390
Most of them made by log in window, who's
managing the, that dialog box as you might expect.

00:27:28.390 --> 00:27:36.330
A bunch of calls to open made by ATSServer, which is,
manages the fonts, the collection of fonts on the system.

00:27:36.329 --> 00:27:44.490
( Period of silence )

00:27:44.490 --> 00:27:49.880
So I think I'd like to sort of broaden our horizons now
away from the, the sort of narrow system call interface

00:27:49.880 --> 00:27:55.750
and look a bit more about how DTrace can
tell us things about processes we construct.

00:27:55.750 --> 00:28:01.460
So here's a, oh hang on, let me clear the screen.

00:28:01.460 --> 00:28:03.289
Here's Hello World.

00:28:04.519 --> 00:28:10.970
Maybe a little more complicated that versions
that are in K and R. So let's run this guy.

00:28:10.970 --> 00:28:12.279
It does the natural thing.

00:28:12.279 --> 00:28:14.000
Right? Hello WWDC.

00:28:14.000 --> 00:28:19.660
And now let's, let's take a look into the execution

00:28:19.660 --> 00:28:25.009
of this very simple user binary and
ask does this thing ever call malloc?

00:28:25.009 --> 00:28:29.430
You know it might be an interesting thing to answer,
certainly in a much larger program you'd like to know that.

00:28:29.430 --> 00:28:33.810
So here's DTrace -n and the new construct here.

00:28:33.809 --> 00:28:39.849
pid provider, kind of a macro argument
and we'll get to that in a second.

00:28:39.849 --> 00:28:43.049
So pid provider is going to instrument a process in user land.

00:28:43.049 --> 00:28:46.819
We'd like to give it the process number,
but we don't quite know that yet.

00:28:46.819 --> 00:28:49.389
And we'll look for entries into malloc.

00:28:49.390 --> 00:28:55.250
And when we see one, we'd like to see the
stack, stack back trace up in user land.

00:28:55.250 --> 00:28:56.900
Well, how do we fill in the process number?

00:28:56.900 --> 00:29:02.720
Well, we ask DTrace to start the program itself,
keep track of the pid that gets started and feed it

00:29:02.720 --> 00:29:06.500
into that script so it knows just who to instrument.

00:29:06.500 --> 00:29:08.609
And away this guy goes.

00:29:08.609 --> 00:29:13.309
And sure enough, here's the execution.

00:29:13.309 --> 00:29:19.419
And when that thing finished up, DTrace collected
its buffers and said, yep, sure enough, you hit malloc.

00:29:19.420 --> 00:29:23.320
And it was under main, under printf,
under the implementation

00:29:23.319 --> 00:29:27.200
of printf and right down somewhere in make buff.

00:29:27.200 --> 00:29:34.700
So interesting, might be useful for example as the
next thing to know how big was the malloc buffer.

00:29:34.700 --> 00:29:37.380
We leave that as an exercise for the reader.

00:29:37.380 --> 00:29:42.650
And now we can go back to the slides.

00:29:42.650 --> 00:29:46.240
( Period of silence )

00:29:46.240 --> 00:29:51.930
Okay. So a little bit more about action statements.

00:29:51.930 --> 00:29:57.539
It's really quite a rich computational environment.

00:29:57.539 --> 00:30:01.190
It allows complete structure and array access.

00:30:01.190 --> 00:30:06.890
If you have a variable that you know in your
process, in the kernel, that's a structure,

00:30:06.890 --> 00:30:11.830
you can dig into it by a construct like that.

00:30:11.829 --> 00:30:17.619
If you hold a pointer, if you can get your hands
on a pointer in a D Language script like p,

00:30:17.619 --> 00:30:24.159
which we know is a struct proc pointer, we can
dereference it and look at pieces of the struct.

00:30:27.200 --> 00:30:30.269
We can index into arrays, all right?

00:30:30.269 --> 00:30:33.779
So curproc is a special variable
maintained by the interpreter.

00:30:33.779 --> 00:30:35.730
We can dereference it.

00:30:35.730 --> 00:30:42.180
It, we know it's a structs, struct proc star,
into the p_ucred structure and then foorther

00:30:42.180 --> 00:30:44.360
down into the cr_groups array under there.

00:30:44.359 --> 00:30:49.109
And that turns out to be the affective
group ID for the current process.

00:30:49.109 --> 00:30:54.109
( Period of silence )

00:30:54.109 --> 00:31:00.969
Sort of as a side note, it's interesting to know that
there are, there's some opportunity to make decisions

00:31:00.970 --> 00:31:05.460
in a D Language script with a conditional
expression of the familiar C sort.

00:31:05.460 --> 00:31:07.610
We have a lot, essentially a selection.

00:31:07.609 --> 00:31:13.539
( Period of silence )

00:31:13.539 --> 00:31:19.960
Well there's something special going on when we can chase
through named pointers and named objects in a sort of C

00:31:19.960 --> 00:31:24.289
like fashion on a, a big object like the kernel.

00:31:24.289 --> 00:31:28.200
Hmm, we're not recompiling the kernel
with D, but we're able to peer into it.

00:31:28.200 --> 00:31:32.259
And that's because DTrace is symbol savvy and type aware.

00:31:32.259 --> 00:31:36.150
Has deep knowledge of the UNIX kernel, mock kernel.

00:31:36.150 --> 00:31:42.780
It knows every type definition, every struct in union and
every global variable and external symbol in the kernel.

00:31:44.640 --> 00:31:52.320
Similarly the, the pid provider can deal with unstripped
binaries, any symbol that you can see with nm -g

00:31:52.319 --> 00:31:56.369
on your binary, the pid provider
will be able to offer up to you

00:31:56.369 --> 00:32:02.829
and DTrace can again chase pointers,
examine structures and unions.

00:32:02.829 --> 00:32:08.279
And the way you get it, get to that functionality
is to use the minus upper case C argument

00:32:08.279 --> 00:32:12.750
to DTrace to pull in your own type definitions.

00:32:12.750 --> 00:32:19.720
Alright so it, it has a clear understanding of what
C structures look like and can press on that way.

00:32:19.720 --> 00:32:24.630
( Period of silence )

00:32:24.630 --> 00:32:29.270
So let's take a carefool look at that.

00:32:29.269 --> 00:32:36.069
Our previous Hello World example was
built on the printf stdio functions.

00:32:36.069 --> 00:32:39.269
These are the file versions of those.

00:32:39.269 --> 00:32:44.700
So we include stdio.h, and in there
there's a declaration for stderr

00:32:44.700 --> 00:32:47.509
that says it's a pointer to a file structure.

00:32:47.509 --> 00:32:53.960
If you've got your machines now, you can look at
stdio.h and see what a upper, FILE upper case is.

00:32:53.960 --> 00:33:02.259
It's a structure that contains buffers, lengths and one
interesting field which is the small integer file descriptor

00:33:02.259 --> 00:33:05.609
that UNIX uses to communicate the identities of files, okay?

00:33:05.609 --> 00:33:13.569
So we'd like to kind of hunt, hunt through the file
pointer to see that number, you know what is that number?

00:33:13.569 --> 00:33:22.259
That small integer number that we communicate to UNIX when
we do an fprintf to standard error of the Hello WWDC string.

00:33:22.259 --> 00:33:25.920
Well, here's a script that lets us get after that.

00:33:25.920 --> 00:33:32.289
It too wants to include stdio since
it wants to manipulate this structure.

00:33:32.289 --> 00:33:43.349
We use the pid provider to place a trap, a break point, a
probe point at fprintf, the user of the stderr symbol.

00:33:43.349 --> 00:33:54.619
And when that probe fires, we grab the first argument
to fprintf, zero base, so we call it arg0.

00:33:54.619 --> 00:34:01.959
Pull in the structure that it points to,
that turns out to be 88 bytes worth of stuff.

00:34:01.960 --> 00:34:05.029
Bring it into the DTrace virtual
machine and then manipulate it,

00:34:05.029 --> 00:34:09.860
namely print out it's under bar file component.

00:34:11.960 --> 00:34:12.990
So let's see how that works.

00:34:12.989 --> 00:34:13.599
( Period of silence )

00:34:13.599 --> 00:34:18.279
And we'll go to the demo machine.

00:34:18.280 --> 00:34:23.380
( Period of silence )

00:34:23.380 --> 00:34:31.420
So here's that program, uses fprintf,
passes this file pointer around.

00:34:31.420 --> 00:34:35.309
Here's that D script.

00:34:35.309 --> 00:34:41.059
Catches fprintf, grabs that file pointer, hauls it in,

00:34:41.059 --> 00:34:47.239
puts it into the DTrace virtual
machine and then digs into it.

00:34:48.420 --> 00:34:53.210
All right, so let's run that guy.

00:34:53.210 --> 00:35:00.789
Ah cool! So there's the execution, and here's DTrace
telling us, yeah, I caught a call to fprintf.

00:35:00.789 --> 00:35:04.409
And the thing you asked me to trace was the small integer 2.

00:35:04.409 --> 00:35:12.039
And if you remember your UNIX 101 stdin,
stdout, stderr is zero, one and two.

00:35:12.039 --> 00:35:14.929
So makes sense.

00:35:14.929 --> 00:35:16.029
Thank goodness.

00:35:16.030 --> 00:35:19.710
( Background noises )

00:35:19.710 --> 00:35:24.010
So let's go back to the slides once more.

00:35:24.010 --> 00:35:31.050
And here's what we just saw.

00:35:31.050 --> 00:35:38.420
Sort of glossed over this business of copyin and its
actually a good point now to dig in a little bit deeper here

00:35:38.420 --> 00:35:43.260
and expose the sort of foondamental
execution model of DTrace.

00:35:43.260 --> 00:35:49.370
It's I think important to have in mind.

00:35:49.369 --> 00:35:56.289
DTrace makes very clear distinctions between what
goes on in user land and what goes on in its kernel,

00:35:56.289 --> 00:36:00.210
virtual machine, data store let's call it.

00:36:00.210 --> 00:36:04.320
And keeping those things straight in your mind
will make it really, really straight forward

00:36:04.320 --> 00:36:07.140
to get scripts running right the first time.

00:36:07.139 --> 00:36:10.579
So here's the big picture.

00:36:10.579 --> 00:36:14.590
We had a script, that's up on the
white, big white box there.

00:36:15.989 --> 00:36:20.419
Sent it into the DTrace command,
that got compiled into byte codes.

00:36:20.420 --> 00:36:26.349
The byte codes got pushed down into the
DTrace virtual machine, its interpreter.

00:36:29.619 --> 00:36:38.469
DTrace actually started the, the -c option,
our little hello_fp program.

00:36:38.469 --> 00:36:42.449
At that point, libSystem was instrumented.

00:36:42.449 --> 00:36:52.509
A trap was placed on the entry to
fprintf. hello_fp began executing.

00:36:52.510 --> 00:37:01.330
It called into fprintf. Passing
that pointer to this file structure.

00:37:03.400 --> 00:37:05.599
The trap hits.

00:37:05.599 --> 00:37:09.750
The interpreter, the interpreter in the kernel gets invoked.

00:37:11.519 --> 00:37:13.079
We begin to execute this code.

00:37:13.079 --> 00:37:15.460
In particular we execute a copyin function.

00:37:15.460 --> 00:37:21.449
That's a special function that knows how to reach into
the virtual address space of the user land process,

00:37:21.449 --> 00:37:30.480
pulls 88 bytes located at arg0,
the pointer stderr back up there.

00:37:30.480 --> 00:37:37.269
Drops that into the DTrace virtual machine
data store where we can now manipulate it.

00:37:39.639 --> 00:37:46.969
By referencing through the pfile variable,
pushing the result back up for our viewing pleasure

00:37:46.969 --> 00:37:49.569
at the end of the execution of this script.

00:37:49.570 --> 00:37:51.680
All right.

00:37:51.679 --> 00:37:54.509
So if there's copyin, well there must be copyout.

00:37:54.510 --> 00:38:02.130
You can copyout something from the DTrace
virtual machine's data store into user land.

00:38:02.130 --> 00:38:10.700
But I've been advised here by my session director to stand
very still and soberly announce don't do this at home kids.

00:38:10.699 --> 00:38:18.059
You can mess up the stack, data and
all sorts of things in your world.

00:38:18.059 --> 00:38:24.230
Can you consider yourself forewarned
and forearmed let's just say that.

00:38:24.230 --> 00:38:25.429
All right.

00:38:28.059 --> 00:38:29.650
So the copyout action.

00:38:29.650 --> 00:38:31.430
Here's that program again.

00:38:31.429 --> 00:38:37.159
I'm going to allocate a string this
time to hold the Hello WWDC message.

00:38:37.159 --> 00:38:41.210
I don't want to mess with the protected data pages.

00:38:41.210 --> 00:38:46.500
I just want a raw memory that I can fooss with here.

00:38:46.500 --> 00:38:55.789
So we malloc some space, copy the constant string
hello wwdc, and then we're going to print it right?

00:38:58.039 --> 00:39:07.789
Except we're going to interpose a little DTrace
action that will when fprintf is entered,

00:39:07.789 --> 00:39:11.400
it's going to copyout its own constant string.

00:39:11.400 --> 00:39:17.760
It's going to copy that from DTrace kernel
virtual data store up into user land

00:39:17.760 --> 00:39:22.030
and then let things go and let's see what happens.

00:39:24.739 --> 00:39:27.849
Notice I've done some carefool counting of
the number of characters in the string.

00:39:27.849 --> 00:39:28.619
( Laughter )

00:39:28.619 --> 00:39:30.509
Okay, forewarned.

00:39:32.039 --> 00:39:33.550
So back to the demo machine.

00:39:33.550 --> 00:39:37.930
( Laughter )

00:39:37.929 --> 00:39:39.779
Let's see.

00:39:41.880 --> 00:39:45.420
Here's that program, I can cat it what the heck.

00:39:47.440 --> 00:39:52.619
Right, oh, whoa you don't want to cat
the, let's, let's cat the C code, right?

00:39:52.619 --> 00:39:55.380
Good. Yeah.

00:39:55.380 --> 00:39:57.880
All right, and then you run it.

00:40:01.360 --> 00:40:03.470
Does the right thing, all right.

00:40:04.670 --> 00:40:10.670
Here we'll apply that little piece of business.

00:40:13.039 --> 00:40:16.940
There's that D script that did the copyout.

00:40:16.940 --> 00:40:22.340
I've got to stand up straight again and say, in order
to do this thing, this is called a destructive action

00:40:22.340 --> 00:40:27.130
in the DTrace world, you've got to add a
special argument to the DTrace line, right?

00:40:27.130 --> 00:40:30.510
You're going to write into some place
where you really shouldn't be.

00:40:30.510 --> 00:40:31.260
Take my word.

00:40:31.260 --> 00:40:35.040
And away we go, what the heck.

00:40:35.039 --> 00:40:39.509
Ah! So there we executed.

00:40:39.510 --> 00:40:41.810
Different message this time.

00:40:41.809 --> 00:40:47.769
We've done a destructive action and poked
into the address space of this process.

00:40:47.769 --> 00:40:54.130
The point of this is if you can understand this interaction
you've, then you've got a clear model of the execution model

00:40:54.130 --> 00:40:57.960
for DTrace in your head and you're home free.

00:40:57.960 --> 00:40:59.490
All right?

00:40:59.489 --> 00:41:00.079
You're good to go.

00:41:00.079 --> 00:41:02.509
Let's go back to the slides.

00:41:02.510 --> 00:41:12.770
( Period of silence )

00:41:12.769 --> 00:41:16.570
So let's talk, I'm going to give you a quick
survey of the D Languages variables.

00:41:16.570 --> 00:41:17.990
I promised this at the outset.

00:41:17.989 --> 00:41:19.379
They're global variables.

00:41:19.380 --> 00:41:23.110
They're just simply utter their names, foo and bar.

00:41:23.110 --> 00:41:31.370
You can declare them if you want, initialize them
and use them any place you care to in a D script.

00:41:31.369 --> 00:41:36.839
Here we might want to record the very
first time we see Perl do an open.

00:41:36.840 --> 00:41:43.220
( Period of silence )

00:41:43.219 --> 00:41:48.039
I said before that it's possible to
collect information segregated by threads.

00:41:48.039 --> 00:41:53.349
That you know threads come flying through system
calls and all sorts of other probe points.

00:41:53.349 --> 00:41:57.659
You may want to collect you know particular
counts based on which thread is coming through.

00:41:57.659 --> 00:41:59.809
There's a syntax for that.

00:41:59.809 --> 00:42:07.059
Arbitrary, just simply prefix the name of the
variable with self pointer, foo self pointer bar,

00:42:07.059 --> 00:42:13.599
this segregates the variable, attaches it to the
particular thread that's flying through this probe point.

00:42:13.599 --> 00:42:20.329
All right so we can count the number of thread opens
for this particular invocation of Perl on a thread.

00:42:20.329 --> 00:42:25.049
Perhaps we've got you know multiple versions of
these things running in some sort of web server.

00:42:26.969 --> 00:42:32.259
And then we have essentially what amount to
equivalents of stack variables in the C language.

00:42:32.260 --> 00:42:39.270
Probe quo as locals, they appear and live for the life
of the execution between the braces and then disappear.

00:42:39.269 --> 00:42:42.219
Usually used for you know temporary variables.

00:42:42.219 --> 00:42:45.049
Right? We want to compute a difference,
we may use that several times.

00:42:45.050 --> 00:42:52.539
For efficiency we capture it once and then
let the interpreter use that later on.

00:42:53.710 --> 00:43:01.240
Okay, so orthogonal to the sort of scope
issues are kind of dimensionality issues.

00:43:01.239 --> 00:43:04.069
So variables can be scalers.

00:43:04.070 --> 00:43:07.059
foo, self bar, this baz.

00:43:07.059 --> 00:43:11.820
They can appear in arrays and DTrace
arrays are associative arrays.

00:43:11.820 --> 00:43:18.390
You can have arbitrary keys and
actually tupoles of keys appearing

00:43:18.389 --> 00:43:21.699
between the square braces that index the associative array.

00:43:21.699 --> 00:43:26.039
And you can assign arbitrary values on the right hand side.

00:43:26.039 --> 00:43:33.800
It's very handy again for sort of teasing out data
based on like for example a particular file descriptor,

00:43:33.800 --> 00:43:37.730
a particular socket number, a particular range of addresses.

00:43:39.590 --> 00:43:43.980
And then there's this really powerful
notion of aggregations.

00:43:43.980 --> 00:43:48.619
We actually started off in our second
example just making use of an aggregation.

00:43:48.619 --> 00:43:51.690
That's a, a table, a place where we can count up stuff.

00:43:51.690 --> 00:43:54.130
But has a very special property.

00:43:54.130 --> 00:43:57.490
It works really well on multi processor systems, all right.

00:43:57.489 --> 00:44:08.509
As we scale up to more and more processors, if you
think about assigning into an array, like @trapsTaken,

00:44:08.510 --> 00:44:12.730
you don't want to have to take a
global lock to get an atomic update.

00:44:12.730 --> 00:44:15.650
So what DTrace has introduced
is this notion of an aggregation.

00:44:15.650 --> 00:44:23.740
It's quite a bit like a reduction operator if
you've taken I don't know CS203 or something.

00:44:23.739 --> 00:44:36.209
Across a multi processor machine, we maintain these results
in individual copies of the aggregation called @trapsTaken.

00:44:36.210 --> 00:44:41.929
And later when we want to the net effect of the
aggregation, we combine them all together at once.

00:44:41.929 --> 00:44:47.609
That allows us to proceed synchronization
free on all the processors.

00:44:47.610 --> 00:44:49.050
Here's another example.

00:44:49.050 --> 00:44:53.140
We can use a tupole to index into this aggregation.

00:44:53.139 --> 00:44:57.889
Aggregations are introduced by the
@ sign that's part of the syntax.

00:44:57.889 --> 00:45:00.690
But notice there's something special on the right hand side.

00:45:00.690 --> 00:45:04.720
I've not done, you know ++ or + another variable.

00:45:04.719 --> 00:45:07.059
I've called another function and that's very special.

00:45:07.059 --> 00:45:13.539
Because there are just these seven, eight
aggregating functions that DTrace allows.

00:45:13.539 --> 00:45:23.719
These functions have all the property that if you
perform them on each of the multi processors,

00:45:23.719 --> 00:45:29.559
you can in the end reconstruct the total by just
bringing the, the numbers together and reapplying,

00:45:29.559 --> 00:45:31.730
essentially reapplying some versions of function.

00:45:31.730 --> 00:45:35.159
So if we count, we just maintain
counts on all these machines.

00:45:35.159 --> 00:45:39.250
Time comes to collect the data, pull them all together,
well just add them and we've got the net count.

00:45:39.250 --> 00:45:45.340
You need to sum, say byte counts, how many bytes are
being allocated by malloc on this process or by malloc

00:45:45.340 --> 00:45:48.780
on that processor, maintain them independently.

00:45:48.780 --> 00:45:52.080
When time comes to print the data,
bring them together, just sum them up.

00:45:52.079 --> 00:45:56.739
Similarly for maximum, minimum and then
these very interesting quantize functions

00:45:56.739 --> 00:46:00.000
that are essentially capturing distributions of values.

00:46:00.000 --> 00:46:04.099
You can do the same thing, histograms, and
then combine them at the end into one sort

00:46:04.099 --> 00:46:08.849
of grand histogram, one global distribution.

00:46:10.389 --> 00:46:13.000
Okay, so quick demonstration of aggregations.

00:46:13.000 --> 00:46:14.659
We've seen some of these before.

00:46:14.659 --> 00:46:18.769
Here's a, another piece on this.

00:46:21.130 --> 00:46:25.960
Good. So we're going to call, we're
going to look at system calls again.

00:46:25.960 --> 00:46:29.940
This time the memory map system call.

00:46:29.940 --> 00:46:39.139
And it turns out that the second argument to memory
map is the number of bytes you'd like mapped.

00:46:39.139 --> 00:46:41.429
Number of bytes you'd like to attain
for their chunk of memory.

00:46:41.429 --> 00:46:46.469
Of course since that's zero based, we call that arg1.

00:46:46.469 --> 00:46:51.809
We form an aggregation introduced
by the @ sign, call it mmaptotal.

00:46:51.809 --> 00:46:59.429
We're going to tease these out by the name
of the process that's doing the mmap.

00:46:59.429 --> 00:47:07.480
And just a keep a you know a sort of running total
of all the mmap activity across the system that way.

00:47:07.480 --> 00:47:09.289
So off we go.

00:47:10.539 --> 00:47:18.630
And what the heck, let's launch Safari and see
what happens during that little piece of work.

00:47:18.630 --> 00:47:23.630
And we'll quit.

00:47:23.630 --> 00:47:26.760
And absent to anything else, when the script ends

00:47:26.760 --> 00:47:30.100
and there's been an aggregation
accumulating, DTrace does the sensible thing.

00:47:30.099 --> 00:47:32.400
It says you've been collecting this table of numbers.

00:47:32.400 --> 00:47:36.869
I'm going to pull it all together for you
and display it smallest to largest.

00:47:36.869 --> 00:47:42.789
And sure enough, we launch Safari here and
it mmapped what 78 megabytes of stuff,

00:47:42.789 --> 00:47:47.500
probably it's code segments or the leading piece there.

00:47:47.500 --> 00:47:49.059
PubSubAgent, that's interesting.

00:47:49.059 --> 00:47:50.320
I hadn't seen that before.

00:47:50.320 --> 00:47:53.130
And that would bear some looking into.

00:47:53.130 --> 00:47:54.890
Maybe that's a recent feature.

00:47:54.889 --> 00:47:55.079
( Laughter )
Okay.

00:47:55.079 --> 00:47:55.309
( Period of silence )

00:47:55.309 --> 00:48:11.440
So but maybe we're running a little bit more,
we've got this sort of overall global sum.

00:48:11.440 --> 00:48:14.450
You know how were these mmaps taken?

00:48:14.449 --> 00:48:17.869
Were they for a large chunks of memory, small
chunks of memory, what's the distribution?

00:48:17.869 --> 00:48:22.659
So here's where these quantize aggregations come into play.

00:48:22.659 --> 00:48:27.859
( Period of silence )

00:48:27.860 --> 00:48:31.670
So this time rather than sum the
sizes, we're going to quantize these.

00:48:31.670 --> 00:48:34.570
Essentially collect a histogram.

00:48:34.570 --> 00:48:41.710
Let's send that off to run and we'll warm launch
Safari this time, it may turn up different.

00:48:41.710 --> 00:48:45.960
But it's, it's sort of the same idea.

00:48:45.960 --> 00:48:48.110
Quit from here.

00:48:48.110 --> 00:48:49.030
Stop the script.

00:48:49.030 --> 00:49:01.300
And what we see are the distributions of mmap
sizes organized in a sit on your side histogram.

00:49:01.300 --> 00:49:05.180
And split out by executable.

00:49:05.179 --> 00:49:09.629
So we see Safari a whole bunch of 16K segments.

00:49:09.630 --> 00:49:11.730
Hmm, I'm not so sure they're code segments anymore.

00:49:11.730 --> 00:49:13.679
I don't know.

00:49:13.679 --> 00:49:20.069
And DTrace itself allocated two very big mmapped buffers.

00:49:20.070 --> 00:49:22.300
I know that from how DTrace works.

00:49:22.300 --> 00:49:25.330
Gee the dock got interest, did
some interesting stuff in there.

00:49:25.329 --> 00:49:27.489
And what was launch D up to?

00:49:27.489 --> 00:49:27.779
So.

00:49:27.780 --> 00:49:29.269
( Laughter )

00:49:29.269 --> 00:49:31.739
Yeah, right.

00:49:31.739 --> 00:49:35.049
There's a talk about that, or there
was a talk about that, a great talk.

00:49:37.530 --> 00:49:44.080
So often it's the, sort of immediately gestalt impression
of a histogram that leads you to the next question.

00:49:44.079 --> 00:49:48.969
You know why was there this one really big thing,
chunked way out there and then you can filter on that.

00:49:48.969 --> 00:49:52.699
So again the paradigm of follow
your nose through these things.

00:49:54.000 --> 00:50:00.719
And finally suppose we wanted to know the site.

00:50:00.719 --> 00:50:06.889
You know where was it that Safari was mmapping, mmapping.

00:50:06.889 --> 00:50:07.869
Where was Safari mmapping?

00:50:07.869 --> 00:50:10.199
That's an interesting question.

00:50:10.199 --> 00:50:17.149
Perhaps to isolate down to a particular framework
where big chunks of resources were being consumed.

00:50:17.150 --> 00:50:22.329
So, here's sort of this interesting idea.

00:50:22.329 --> 00:50:29.989
We'll look for mmap entries, filter it down to
Safari, the exec name Safari, collect an aggregation,

00:50:29.989 --> 00:50:38.919
but now for the key to the table we're
constructing, we'll collect a user stack.

00:50:38.920 --> 00:50:40.210
All right?

00:50:40.210 --> 00:50:48.179
And the value stored there will be sort of
the net amount of mmapping done at that site.

00:50:48.179 --> 00:50:50.519
So let's how that works.

00:50:50.519 --> 00:50:52.289
Off we go.

00:50:53.500 --> 00:50:57.929
Safari up and away, faster and
faster each time, that's good.

00:50:57.929 --> 00:51:00.429
Let's pull down a menu for the heck of it.

00:51:00.429 --> 00:51:03.949
Quit, stop here, ah interesting.

00:51:03.949 --> 00:51:06.399
Oh, I should have left it running.

00:51:06.400 --> 00:51:07.780
One more time.

00:51:09.739 --> 00:51:12.250
Run it again.

00:51:12.250 --> 00:51:12.849
Safari.

00:51:12.849 --> 00:51:14.460
>> Ran the wrong one.

00:51:14.460 --> 00:51:15.880
>> I ran the wrong one.

00:51:15.880 --> 00:51:18.710
Did I? Yeah I did.

00:51:18.710 --> 00:51:20.900
Okay, nice and easy.

00:51:23.610 --> 00:51:25.789
That's the one I wanted.

00:51:27.880 --> 00:51:30.769
Safari, let's do something, go visit somewhere else.

00:51:30.769 --> 00:51:33.250
All right.

00:51:33.250 --> 00:51:39.510
All right, now great.

00:51:39.510 --> 00:51:41.140
Ah, much better.

00:51:41.139 --> 00:51:44.699
We see the wonderful work that
James has done with sybolication.

00:51:44.699 --> 00:51:53.859
So, so you know here's a, here's a big collection of
mmaps, mmap calls, netting out to a total of what,

00:51:53.860 --> 00:51:58.640
3.3 megabytes made from this stack location.

00:51:58.639 --> 00:51:59.809
In libGIF.

00:51:59.809 --> 00:52:01.559
That's interesting.

00:52:01.559 --> 00:52:06.699
In ImageIO, another 3 megabytes of mMap stuff.

00:52:06.699 --> 00:52:08.149
Core foundation similarly.

00:52:08.150 --> 00:52:11.660
So it's you know yet another slice and dice, right?

00:52:11.659 --> 00:52:18.539
And just by sort of almost elementary
recombination of the elements we've talked about,

00:52:18.539 --> 00:52:22.679
lead you to you know sort of very
interesting displays of data.

00:52:22.679 --> 00:52:29.230
And seeing them smallest to largest is often very
quickly focuses you on you know where the action is.

00:52:30.750 --> 00:52:34.199
Okay, back to the slides.

00:52:34.199 --> 00:52:38.379
Good. Good, good, good.

00:52:38.380 --> 00:52:44.579
So you're now all DTrace experts, ready
to go out and right tons of scripts.

00:52:44.579 --> 00:52:50.730
Well, maybe not, you know you may have a restricted
set of problems you always like to look at.

00:52:50.730 --> 00:52:56.389
You maybe want to have some handy
tools you know sort of prestructed.

00:52:56.389 --> 00:53:00.900
And that's what the DTrace ToolKit is about.

00:53:00.900 --> 00:53:07.650
Freeware again done, first at Sun
Microsystems for Open Solaris.

00:53:07.650 --> 00:53:12.289
And imported almost trivially to
our implementation of DTrace.

00:53:12.289 --> 00:53:15.699
There's very few changes once you
get the basic DTrace stuff.

00:53:15.699 --> 00:53:19.009
The scripts just seem to come right across.

00:53:19.010 --> 00:53:28.430
They're a set a handy analysis tools for common
investigations done by a very talented Sun field engineer.

00:53:28.429 --> 00:53:33.489
They're, and all DTrace scripts
or D Language programs wrapped

00:53:33.489 --> 00:53:37.649
in a little bit of shell wrapper to do argument parsing.

00:53:37.650 --> 00:53:44.130
They're readily customized if you have a, you know a sort
of a different need, different take on what you want to see,

00:53:44.130 --> 00:53:47.430
you know hit it with your favorite editor.

00:53:47.429 --> 00:53:56.529
Browse them, learn about the D Language, some of the
more esoteric patterns appear in some of these scripts.

00:53:56.530 --> 00:54:01.430
Sort of useful for a second course in DTrace.

00:54:01.429 --> 00:54:05.609
We've got a little more than 40
of 104 scripts ported to Leopard.

00:54:05.610 --> 00:54:14.010
The ones that are missing largely rely on
specific, you know Solaris implementation details.

00:54:14.010 --> 00:54:18.450
We'll be moving those over in, or many of
them over in the next, in the coming weeks.

00:54:18.449 --> 00:54:23.069
But today on your Leopard CD you'll see
around 40 scripts read@y to rock and roll.

00:54:23.070 --> 00:54:24.630
They're all on usr/bin.

00:54:24.630 --> 00:54:29.480
man pages in a place where just saying
man's such and such will get them.

00:54:29.480 --> 00:54:36.900
And there are some interesting annotated examples of how
these things can be used in user share examples, DTTk.

00:54:36.900 --> 00:54:47.139
So we spent a lot of time this afternoon
looking at sys calls and how to dive

00:54:47.139 --> 00:54:49.109
into them and collect various information.

00:54:49.110 --> 00:54:52.030
Well that's all been sort of pulled
together in a tool called dtruss.

00:54:52.030 --> 00:54:54.150
It's very popular in the Solaris world.

00:54:54.150 --> 00:54:56.840
I find it very useful now on Mac OS X.

00:54:56.840 --> 00:54:58.850
Here's its help message.

00:54:58.849 --> 00:55:02.259
Gives the list of arguments, the
things that it knows how to do.

00:55:02.260 --> 00:55:09.120
The argument sort of partition into what
thing do we, do you want me to look at.

00:55:09.119 --> 00:55:11.900
Is it already running?

00:55:11.900 --> 00:55:19.180
Or do I want to start it up by using the last option command,
just utter the name of the thing on the command line.

00:55:20.619 --> 00:55:25.920
Do we want to filter down to just a particular
set of system calls or see everything in sight?

00:55:25.920 --> 00:55:29.130
Should we print summary counts?

00:55:29.130 --> 00:55:31.750
Do we want to look at times?

00:55:31.750 --> 00:55:33.960
Back traces and a demo.

00:55:33.960 --> 00:55:34.619
Wow.

00:55:34.619 --> 00:55:38.369
( Laughter )

00:55:38.369 --> 00:55:42.109
( Period of silence )

00:55:42.110 --> 00:55:44.960
Click to type.

00:55:47.219 --> 00:55:53.039
So let's run dtruss now.

00:55:53.039 --> 00:55:59.779
We're going to collect counts and the thing we want to
look at is the dock which is already running.

00:55:59.780 --> 00:56:05.920
So it's, oh, we go right over the dock and
it begins to react to our mouse motions.

00:56:05.920 --> 00:56:07.720
Interesting.

00:56:07.719 --> 00:56:09.609
Pop up a menu.

00:56:11.110 --> 00:56:13.720
Cause something to show.

00:56:15.250 --> 00:56:21.170
And at the end I just stopped it, we see a
summary of all the system calls it passed by.

00:56:21.170 --> 00:56:30.440
And just to look up a little bit in the scroll, process
number 96 an isolary process number for the dock,

00:56:30.440 --> 00:56:37.860
a thread identifier, the kernel thread that sits behind
the particular thread that dove into the system call.

00:56:37.860 --> 00:56:39.579
The name of the system call.

00:56:39.579 --> 00:56:42.119
Some of its arguments.

00:56:44.900 --> 00:56:49.510
The immediate return value of the system
call and any error node that was set.

00:56:49.510 --> 00:56:55.020
And so here we see for some reason we
weren't allowed to make dir probably

00:56:55.019 --> 00:56:58.070
because it already exists on user Apple library preferences.

00:56:58.070 --> 00:57:02.160
Return minus 1, that's error node
17 and you can look that up

00:57:02.159 --> 00:57:09.349
in syserrnode.h. All right,
back to the slides one more time.

00:57:09.349 --> 00:57:12.659
( Period of silence )

00:57:12.659 --> 00:57:15.670
So does that look green?

00:57:15.670 --> 00:57:17.340
It should.

00:57:17.340 --> 00:57:28.630
The notion is here's our roster
of providers in Mac OS X at WWDC.

00:57:28.630 --> 00:57:31.539
fbt function boundary tracing we
didn't talk much about that.

00:57:31.539 --> 00:57:35.529
But it's in that initial list of 20,000 probe points.

00:57:35.530 --> 00:57:40.640
You can see the entry and return
from any function in the UNIX kernel.

00:57:40.639 --> 00:57:46.170
lockstat, particular semantic
knowledge about kernel locking.

00:57:46.170 --> 00:57:50.440
vminfo, we took a quick look at,
see where page faults occur.

00:57:50.440 --> 00:57:53.309
proc, life of processes in the system.

00:57:53.309 --> 00:57:54.820
io, where I/O occurs.

00:57:54.820 --> 00:57:59.920
Profile, timed events, system calls
we done, did a ton with, mach traps.

00:57:59.920 --> 00:58:03.789
Sort of the mach world compliment to a system call.

00:58:03.789 --> 00:58:07.570
plockstats, those are locks up in user land.

00:58:07.570 --> 00:58:09.350
p thread locking.

00:58:09.349 --> 00:58:13.610
And you can investigate the behavior of
those things using the plockstat provider.

00:58:13.610 --> 00:58:17.860
pid and Objective-C we talked quite a bit about.

00:58:17.860 --> 00:58:21.900
usdt, which are static probes up in user land.

00:58:21.900 --> 00:58:27.289
An advanced DTrace topic and we
believe Dave will be talking about those

00:58:27.289 --> 00:58:32.219
in the advanced DTrace and Xray session tomorrow.

00:58:32.219 --> 00:58:41.919
And finally sort of like a gift, when you've got
DTrace and user, user land probes working right,

00:58:41.920 --> 00:58:46.960
you begin to pick up what's going on in the
other communities around Perl, Python, Ruby,

00:58:46.960 --> 00:58:51.949
and now the Java 6.0 preview have, all
have DTrace instrumentation points

00:58:51.949 --> 00:58:55.500
that are ready to rock and roll on Mac OS X.

00:58:55.500 --> 00:58:59.019
( Period of silence )

00:58:59.019 --> 00:59:02.670
So the summary, the take home message.

00:59:02.670 --> 00:59:11.559
The DTrace approach unlike the monolithic
tools we've previously had, ktrace, trace,

00:59:11.559 --> 00:59:15.029
is incremental, exploratory and improvisional.

00:59:15.030 --> 00:59:17.440
So follow your nose.

00:59:17.440 --> 00:59:21.579
Aggregation turns out to be the really
powerful, powerful piece of work.

00:59:21.579 --> 00:59:30.730
And finally you're going to find all these facilities in
the Seed as it was delivered to you earlier this week.

00:59:30.730 --> 00:59:41.360
More information there is manual pages, the examples
for the DTrace ToolKit scripts that I mentioned.

00:59:41.360 --> 00:59:47.550
A vital and vibrant community of
DTrace users at opensolaris.org.

00:59:47.550 --> 00:59:55.990
And a discussion mailing list that's
again lively and fun to keep an eye on.
WEBVTT

00:00:12.689 --> 00:00:13.809
>> Hi there.

00:00:13.810 --> 00:00:15.470
I'm Deric Horn.

00:00:15.470 --> 00:00:17.300
I'm the Application Technologies Evangelist.

00:00:17.300 --> 00:00:20.199
Hopefully you'll see my name at the end of
this session so you can always send me email.

00:00:20.199 --> 00:00:24.259
This is the second part to our two
part series on coming to the Mac.

00:00:24.260 --> 00:00:28.440
And it's actually going to be broken up into two parts.

00:00:28.440 --> 00:00:35.560
The Mac is an awesome environment for graphics,
multimedia, content, podcasts and so forth.

00:00:35.560 --> 00:00:40.070
So for the first part will have Babak Mahbod
talking about our graphics frameworks.

00:00:40.070 --> 00:00:44.929
And then on the second part of this session
we'll have Matt Henderson go down deeper

00:00:44.929 --> 00:00:50.039
and talk about our different development tools, performance
tools, changes we've made in Leopard to our tools,

00:00:50.039 --> 00:00:52.979
debugging, everything that you're going to need to know.

00:00:52.979 --> 00:00:56.779
Being developers, that's one thing that we
all have in common is our development tools

00:00:56.780 --> 00:00:58.670
and our love hate relationship with them.

00:00:58.670 --> 00:01:01.030
So at this point, I'd like to welcome
Babak Mahbod.

00:01:01.030 --> 00:01:01.460
Thank you.

00:01:01.460 --> 00:01:03.509
>> Thank you Deric for that introduction.

00:01:03.509 --> 00:01:09.000
So my name is Babak Mahbod and I'm
a Senior Software Engineer at Apple Computer.

00:01:09.000 --> 00:01:15.980
And today I'm here to talk to you a little bit about
our graphics, our multimedia frameworks on Mac OS X.

00:01:15.980 --> 00:01:20.600
So what are we going to talk about and
why talk about graphics and multimedia?

00:01:20.599 --> 00:01:25.899
If you attended the previous session Larry Cooper
talked about basically what frameworks are.

00:01:25.900 --> 00:01:31.170
And he probably told you that frameworks
are basically a folder that inside

00:01:31.170 --> 00:01:33.829
that folder you have your library and headers.

00:01:33.829 --> 00:01:39.849
And all of our graphics and multimedia is
delivered to you in a form of a frameworks.

00:01:39.849 --> 00:01:43.789
And in fact, on our platform we
take a layered approach to design.

00:01:43.790 --> 00:01:46.560
And one layer builds on top of another layer.

00:01:46.560 --> 00:01:55.920
So why talk about graphics and multimedia specifically when
there are so many other you know frameworks to talk about?

00:01:55.920 --> 00:01:59.350
Well, you know lets look at the spreadsheet application.

00:01:59.349 --> 00:02:04.509
It's really not really interesting by just
looking at numbers in a spreadsheet application.

00:02:04.510 --> 00:02:08.700
Typically when you deliver content, with
with spreadsheet application,

00:02:08.699 --> 00:02:11.169
you want to at least have some visual feedback.

00:02:11.169 --> 00:02:13.509
Right? So what do you deliver with?

00:02:13.509 --> 00:02:15.579
You deliver your spreadsheet with some graphs.

00:02:15.580 --> 00:02:19.120
And even it would be interesting that, to the people

00:02:19.120 --> 00:02:24.170
that you deliver your presentation
to if those graphs evolve over time.

00:02:24.169 --> 00:02:29.219
When you send an email, you can you know
most of you send audio clips with your email.

00:02:29.219 --> 00:02:32.000
Some of you send your clips of your home movies.

00:02:32.000 --> 00:02:35.060
So there's a digital, digital content contained therein.

00:02:35.060 --> 00:02:43.280
And so I'm going to spend a little bit of time today to talk
about graphics and multimedia framework to our platform.

00:02:43.280 --> 00:02:48.330
We're going to talk about a little bit about Mac
OS X system architecture and we're going to talk

00:02:48.330 --> 00:02:55.200
about multimedia image handling and
2D and 3D graphics layers on our OS.

00:02:55.199 --> 00:02:59.959
So in our OS we take as I said a layered approach to design.

00:02:59.960 --> 00:03:03.090
You probably have seen this before in Larry's presentation.

00:03:03.090 --> 00:03:11.199
But at the core of our OS is a Darwin kernel
and that's based on free BSD and Mach microkernel.

00:03:11.199 --> 00:03:15.919
And then we have our graphics and media
layer, which are our Core Services.

00:03:15.919 --> 00:03:20.469
In this case we're talking about Core Audio,
Core Image, Core Video and OpenGL.

00:03:20.469 --> 00:03:24.939
And on top of that are Carbon and Cocoa frameworks.

00:03:24.939 --> 00:03:30.650
So if your procedural programmer, you do C, C++
programming, you probably be using Carbon,

00:03:30.650 --> 00:03:35.930
but we of course recommend using
Objective-C and our Cocoa frameworks.

00:03:35.930 --> 00:03:42.409
And the top most layers of course are user experience
layer and if you've seen our windows aqua look and feel,

00:03:42.409 --> 00:03:49.180
Dashboard and widgets, Spotlight search engine
and accessibility family of APIs and tools.

00:03:49.180 --> 00:03:54.550
So for me to talk about graphics and multimedia,
I'm going to kinda take a top down approach.

00:03:54.550 --> 00:04:01.370
So I'm going to start speaking with you about
high level APIs, basically our Cocoa frameworks

00:04:01.370 --> 00:04:05.830
and work our, work my way down to the core services.

00:04:05.830 --> 00:04:09.550
So let's talk a little bit about QTKit.

00:04:09.550 --> 00:04:14.730
QTKit is an Objective-C Cocoa framework.

00:04:14.729 --> 00:04:16.589
It's a very high level framework.

00:04:16.589 --> 00:04:19.839
It's designed specifically for developers.

00:04:19.839 --> 00:04:27.069
So if you want to deliver a multimedia application to our
platform, you can deliver it in rather short amount of time.

00:04:27.069 --> 00:04:33.750
It allows you to work with the QuickTime content, but even
goes beyond QuickTime content and what it can deliver.

00:04:33.750 --> 00:04:40.689
If you for example want to do simple, if your application
you want to do simple to rather complex editing,

00:04:40.689 --> 00:04:47.980
cut copy and waste kind of workflows, if you want to
splice movies, if you want to combine and transcode movies,

00:04:47.980 --> 00:04:50.660
this QTKit high level APIs will allow you to do that.

00:04:50.660 --> 00:04:54.900
And of course in Leopard, it's been highly optimized.

00:04:56.769 --> 00:05:05.180
There has additional benefits such as if you wanted to do 64
bit development, this is a framework that you wish to use.

00:05:05.180 --> 00:05:12.650
And of course it really builds as I said on top of
our core services, namely Core Image, Core Audio,

00:05:12.649 --> 00:05:19.049
Core Video and OpenGL, which I'll
briefly touch upon later in the presentation.

00:05:19.050 --> 00:05:25.230
But also bundled with QTKit framework
and its family of APIs is QT Capture.

00:05:25.230 --> 00:05:29.750
So let's say you want to capture media in real time.

00:05:29.750 --> 00:05:33.300
QT capture gives you the APIs necessary for you to do that.

00:05:33.300 --> 00:05:39.230
In fact, many of our own computers
are delivered with an iSight camera.

00:05:39.230 --> 00:05:44.800
It's you know if you want to leverage off of
using iSight camera to capture or camcorders

00:05:44.800 --> 00:05:51.090
or your you know regular microphones, if you
want to capture true QuickTime movie, you want to,

00:05:51.089 --> 00:05:57.729
if you want to just have it video preview or audio preview
or if you want to just capture video that you want to process

00:05:57.730 --> 00:06:03.810
at a later date, running it for example through our
OpenGL engine or if you want to, for example, run it

00:06:03.810 --> 00:06:07.530
through a filter, you know for post processing.

00:06:07.529 --> 00:06:19.089
But its lot more than that because this high level APIs
will allow you to also take advantage of your HD devices.

00:06:19.089 --> 00:06:26.919
And it, it does frame accurate capture,
with time codes and per sample meta data.

00:06:26.920 --> 00:06:33.569
So let me show you how just briefly how easy it is actually
to use these high level APIs to actually capture a movie.

00:06:33.569 --> 00:06:38.149
So the first thing is you substantiate of course a QT movie.

00:06:38.149 --> 00:06:41.979
The next step is of course you want to
set some properties for this movie.

00:06:41.980 --> 00:06:45.210
In this case I'm just saying that
I want this movie to be editable.

00:06:45.209 --> 00:06:51.839
And last but not least you will tell your view
this is an editable movie so play it in my view.

00:06:51.839 --> 00:06:58.149
And it's just equally easy to save movies, you
captured it, you edited it, what you want to do?

00:06:58.149 --> 00:06:59.009
You just want to save it.

00:06:59.009 --> 00:07:01.629
It's really, I mean, two steps.

00:07:03.379 --> 00:07:08.790
So we have a QTKit session and lab coming up for you.

00:07:08.790 --> 00:07:16.470
If you're interested in this technology, I highly recommend
that you should attend these, this session and lab.

00:07:16.470 --> 00:07:20.240
So but not everybody is interested
in you know writing a multimedia app.

00:07:20.240 --> 00:07:23.540
Some of you want to just do image processing.

00:07:23.540 --> 00:07:27.300
So for that we have a framework called ImageKit.

00:07:27.300 --> 00:07:30.870
So what are some of these basic applications have in common?

00:07:30.870 --> 00:07:38.800
Here I have iPhoto that many of you have seen for just
doing basic editing, and you know managing your photo album

00:07:38.800 --> 00:07:47.560
and I always have here Aperture which
is for film proc, raw image processing.

00:07:47.560 --> 00:07:49.060
So these two apps, what do we have?

00:07:49.060 --> 00:07:55.509
Some of the basic workflow as if you want to find and browse
images both iPhoto and Aperture will allow you to do that.

00:07:55.509 --> 00:08:02.750
Well the same two application, iPhoto and Aperture
will also allow you to display and edit images.

00:08:02.750 --> 00:08:06.470
So in general, if you think about
it, most of the applications,

00:08:06.470 --> 00:08:12.090
image processing applications have
some very simple and common things.

00:08:12.089 --> 00:08:16.519
So they allow you to find and
browse images and display and edit images.

00:08:16.519 --> 00:08:22.099
So why go through the trouble of having to write your
own architecture, implement your own architecture

00:08:22.100 --> 00:08:26.990
when we deliver such a great framework
called ImageKit for you to leverage off of?

00:08:26.990 --> 00:08:31.370
So what are some of the basic components of ImageKit?

00:08:31.370 --> 00:08:35.370
The first thing is the Image Viewer
which gives you basically high level APIs

00:08:35.370 --> 00:08:38.649
that will allow you to actually view your images.

00:08:38.649 --> 00:08:46.909
You just basically give a file name and Image Viewer,
once you substantiate the object it gives you this

00:08:46.909 --> 00:08:51.350
simple user interface to allow
you to step through your images.

00:08:51.350 --> 00:08:58.220
And of course there's ImageEdit panel again simple
object, substantiated, it comes with this heads up display

00:08:58.220 --> 00:09:02.759
that will allow you to, has three
tabs, adjust, effects and details tabs.

00:09:02.759 --> 00:09:08.069
And of course with adjust it allows
you to do some basic picture properties

00:09:08.070 --> 00:09:12.470
like brightness, saturation, and gamma control.

00:09:12.470 --> 00:09:18.200
Your image edit tab, effects tab will
allow you to actually utilize some

00:09:18.200 --> 00:09:21.980
of the filters that you have all over your system.

00:09:21.980 --> 00:09:26.639
And of course the meta data view or
the details view allow you to look

00:09:26.639 --> 00:09:30.610
at some information associated with each of your images.

00:09:30.610 --> 00:09:34.129
Then it also has an API called Image Browser.

00:09:34.129 --> 00:09:39.799
So if you want to have, you know if you have a
folder full of images and you want one API,

00:09:39.799 --> 00:09:44.359
want to point that to that folder,
and get this simple user interface

00:09:44.360 --> 00:09:51.230
so that you know your clients are going to be using
your application can simply just view pictures

00:09:51.230 --> 00:09:52.300
that are in a folder.

00:09:52.299 --> 00:09:56.959
This portion of ImageKit will allow you to do that.

00:09:58.909 --> 00:10:01.019
Then there's Picture Taker.

00:10:01.019 --> 00:10:08.740
It gives you a simple, again, user interface component and
a API that brings up this interface and will allow you

00:10:08.740 --> 00:10:13.320
to actually work for example with
devices like your iSight camera.

00:10:13.320 --> 00:10:18.590
And the Slideshow, same thing, I mean.

00:10:18.590 --> 00:10:24.860
So here we have, we have a simple folder that
have full of pictures and you want to, this API.

00:10:24.860 --> 00:10:31.090
You point that to that folder and it will bring up
again this user interface that will you to just go

00:10:31.090 --> 00:10:36.820
through all your images in that folder
and give your clients a slide show.

00:10:36.820 --> 00:10:37.940
There is a save panel.

00:10:37.940 --> 00:10:44.070
Let's say that you have finally edited and you know
add some of the effects to your images as you browse

00:10:44.070 --> 00:10:45.960
and viewed them, but you want to save them.

00:10:45.960 --> 00:10:50.320
It gives you a simple user interface
again for you to save your images.

00:10:50.320 --> 00:10:58.560
And last, part of the ImageKit is the ImageKit's filter
browser, again allowing you to actually see all the filters

00:10:58.559 --> 00:11:06.579
in your system and actually see, set some
attributes on them and use them as you wish.

00:11:06.580 --> 00:11:14.230
So basically ImageKit gives you a complete
workflow if you're processing images.

00:11:14.230 --> 00:11:22.310
So here I'm going to show you a simple three steps that
you know you can use a Picture Taker family of APIs

00:11:22.309 --> 00:11:25.699
to actually take some picture from your iSight camera.

00:11:25.700 --> 00:11:28.770
So first thing is you get a shared instance.

00:11:28.769 --> 00:11:39.100
You launch Picture Taker and here as soon as you
send the message, begin Image Picker with delegate,

00:11:39.100 --> 00:11:45.879
along with the selector and a context to this object
that you substantiated, you get that user interface

00:11:45.879 --> 00:11:48.120
and it'll allow you to actually
work with your iSight camera.

00:11:48.120 --> 00:11:56.549
And last part, once you get the result, you just can save
the image or pass it to a filter for further processing.

00:11:56.549 --> 00:12:05.139
So you have one session and one lab for you to
actually, if you're interested in ImageKit,

00:12:05.139 --> 00:12:08.949
these are places we would like you to go.

00:12:08.950 --> 00:12:17.180
So next thing I want to talk about is - you have images,
you have edited images but how do you read images?

00:12:17.179 --> 00:12:21.259
So we have this high level framework called Image I/O.

00:12:21.259 --> 00:12:27.950
Again it allows you to read and write a plethora of
file formats, write them, work with their meta data,

00:12:27.950 --> 00:12:33.090
do color management and process, if
you have a raw camera for instance,

00:12:33.090 --> 00:12:35.290
framework will allow you to actually work with those.

00:12:35.289 --> 00:12:40.339
And in fact it does incremental loading
of course for those large sized images.

00:12:40.340 --> 00:12:42.750
So where does it lie in our OS?

00:12:42.750 --> 00:12:47.779
Well, again Image I/O, I mean many of you that
come from UNIX or other platforms, you're,

00:12:47.779 --> 00:12:52.470
you know well familiar with libTiff, libJpeg and LibPng.

00:12:52.470 --> 00:12:57.310
So here we have taken the trouble to actually taking
those libraries and optimize it and deliver it

00:12:57.309 --> 00:13:00.459
on our platform for you in a form of Image I/O.

00:13:00.460 --> 00:13:09.340
And as you can see, higher level APIs like Quartz
ImageKit and Core Image all leverage off of Image I/O.

00:13:09.340 --> 00:13:17.149
So you can see that Image I/O supports a web standards,
all the, or many of the floating point HDR formats,

00:13:17.149 --> 00:13:23.269
camera raw formats, meta data formats and as more
and more file formats are becoming available,

00:13:23.269 --> 00:13:30.879
Image I/O team will be hard at work and bringing
those to you in a form of Image I/O family of APIs.

00:13:30.879 --> 00:13:35.360
So I'm going to go through very, very
quickly - go through a bit of sample code

00:13:35.360 --> 00:13:38.100
to show you how simple it really is to use Image I/O.

00:13:38.100 --> 00:13:42.200
So here all I'm doing is writing a JPEG image.

00:13:42.200 --> 00:13:45.740
So the first thing that I want to do
actually I want to write it to a location.

00:13:45.740 --> 00:13:51.590
So what I do is I substantiate an
opaque reference, my destination.

00:13:51.590 --> 00:13:54.240
The next thing that I want to do is just set some properties.

00:13:54.240 --> 00:13:58.590
Here I want to set a JPEG, I want to set, set a dots per inch.

00:13:58.590 --> 00:14:00.340
And compression quality of course.

00:14:00.340 --> 00:14:04.129
And then I add the image to my destination.

00:14:04.129 --> 00:14:10.730
And of course I want to close the file or finalize it.

00:14:10.730 --> 00:14:16.649
So the next thing I want to talk about that I've
talked about just how you read and write images,

00:14:16.649 --> 00:14:25.000
I talked briefly when I talked about ImageKit
about the if at stack, and I talked about filters.

00:14:25.000 --> 00:14:26.909
So what does Core Image do?

00:14:26.909 --> 00:14:33.129
Well, Core Image is really a framework
of per pixel operations.

00:14:33.129 --> 00:14:39.799
That means it's basically really a higher level
API that wraps a lot of the OpenGL framework

00:14:39.799 --> 00:14:44.349
and it harnesses the power of the
GPU and graphics card on your machine.

00:14:44.350 --> 00:14:51.899
It, it is for you to add just basically beautiful
effects like transition effects or anything

00:14:51.899 --> 00:14:54.250
that you can think, think of to your images.

00:14:54.250 --> 00:15:01.009
It comes with about 100 plus filters.

00:15:01.009 --> 00:15:06.330
But let's talk little bit about
the filters and how they work.

00:15:06.330 --> 00:15:12.490
So basically at the heart of core
image is this concept of filters.

00:15:12.490 --> 00:15:19.509
And let's say that you have an original image and you
want to apply certain number of filters to get a final image.

00:15:19.509 --> 00:15:25.069
Normally you know what you would do, you would take one
image, you apply a filter, you save the intermediate step,

00:15:25.070 --> 00:15:31.700
you apply the image, and you apply
another filter to get the final image.

00:15:31.700 --> 00:15:34.020
Core Image is really smart about this process.

00:15:34.019 --> 00:15:39.340
In fact, instead of storing those
intermediate images, it changes those filters

00:15:39.340 --> 00:15:43.759
for you together and optimizes the pipeline.

00:15:45.039 --> 00:15:48.409
Core Image as I say comes with 100 plus filters.

00:15:48.409 --> 00:15:51.189
So there, there's a good chance that
most of the filters that you need

00:15:51.190 --> 00:15:57.570
for your image processing apps
comes already with Core Image.

00:15:57.570 --> 00:16:04.340
But if just in case that there are some filters
that you feel that are not bundled with Core Image,

00:16:04.340 --> 00:16:08.460
you have these flexibility of writing
what's called image units.

00:16:08.460 --> 00:16:13.330
And once you write image units, you can,
they are just your filters and just available

00:16:13.330 --> 00:16:16.460
to all the applications throughout the system.

00:16:18.019 --> 00:16:25.069
So before going any further, I just want to impress upon
you the fact that this family of APIs and frameworks

00:16:25.070 --> 00:16:31.500
that I talked about probably take into
account a bulk of your algorithmic workflow.

00:16:31.500 --> 00:16:35.929
And they were designed to reduce the
amount of work that you need to do

00:16:35.929 --> 00:16:39.779
to deliver the application in a short amount of time.

00:16:39.779 --> 00:16:47.269
But there are those occasions that once you go through
these high level APIs and you exhaust all possibilities,

00:16:47.269 --> 00:16:52.309
you feel that these high level APIs
and frameworks, you need to do more.

00:16:52.309 --> 00:16:59.859
And in order to do that, at this stage, as I said,
its probably 80 percent, 75 to 80 percent of the time,

00:16:59.860 --> 00:17:03.350
these frameworks take into account many of the workflows.

00:17:03.350 --> 00:17:06.360
But that remaining percentage what do you do?

00:17:06.359 --> 00:17:12.059
At this stage you, then you want to go delve a little
bit deeper and then go into the Core Services.

00:17:12.059 --> 00:17:17.990
So the first thing I want to talk about is the Core Video.

00:17:17.990 --> 00:17:20.690
Now so what is Core Video?

00:17:20.690 --> 00:17:26.420
Core Video is basically let's say that
you want to capture individual frame.

00:17:26.420 --> 00:17:32.480
You work with QTKit and then you come to a point and
say, well okay look I want to capture individual frames

00:17:32.480 --> 00:17:36.809
and in real time I want to apply some sort of effects to them.

00:17:36.809 --> 00:17:41.200
So this is a technology in this case
that you may want to use called Core Video.

00:17:41.200 --> 00:17:48.759
And in fact Core Video, the pipeline was designed
to break that entire work into discrete steps.

00:17:49.809 --> 00:17:53.730
One of the advantages of course Core Video
once you go to this level is the fact

00:17:53.730 --> 00:17:58.599
that you don't have you know typically if you
work with individual frames you have to work,

00:17:58.599 --> 00:18:02.819
worry about the synchronization issues,
especially with your audio track.

00:18:02.819 --> 00:18:09.339
Core Video really takes care of it and it allows
you to actually work on more creative aspects.

00:18:09.339 --> 00:18:15.279
If you want to apply individ - if you want to apply
filters to your individual frames in real time.

00:18:15.279 --> 00:18:18.149
Such as Core Image filters or your own image units.

00:18:18.150 --> 00:18:19.880
You can, you can use Core Video.

00:18:19.880 --> 00:18:24.750
If you want to transform images dynamically,
you can use Core Video.

00:18:24.750 --> 00:18:30.200
If you want to add for example any games,
some video, you can use Core Video.

00:18:30.200 --> 00:18:37.440
And of course it's really a good
technology for compositing multiple streams.

00:18:37.440 --> 00:18:44.890
So it allows you to actually accomplish this
through a simple mechanism called the Display Link.

00:18:44.890 --> 00:18:50.250
Here I've shown you one workflow, but
through the combination use of QTKit

00:18:50.250 --> 00:18:56.509
and Core Video you can accomplish amazing things.

00:18:56.509 --> 00:19:04.779
So we have three sessions and three labs
for you if you're interested Core Video.

00:19:04.779 --> 00:19:13.629
Now of course at the heart of every good multimedia
experience is a good audio engine and we have Core Audio.

00:19:13.630 --> 00:19:18.750
So many of you are probably familiar with the
hardware recording studio and the hardware

00:19:18.750 --> 00:19:22.339
of every hardware recording studio is your mixing deck.

00:19:23.599 --> 00:19:29.829
Well Core Audio has brought that hardware
recording studio experience into software.

00:19:29.829 --> 00:19:37.839
And again the heart of Core Audio is a mixer unit
that allows you to actually have an exact same experience

00:19:37.839 --> 00:19:44.569
through the tie - coupling of this so called
hardware application layer and audio units.

00:19:45.769 --> 00:19:47.970
But it does again much more than that.

00:19:47.970 --> 00:19:53.529
If you're interested in the signal processing, if you
are interested in surround sound and if you want to put

00:19:53.529 --> 00:19:58.039
that in your games using OpenAL, we deliver
a native implementation of OpenAL for you.

00:19:58.039 --> 00:20:02.970
If you want to do hardware or software midi
processing, then Core Audio may be thing for you.

00:20:02.970 --> 00:20:13.920
If you want to work with read and write compress
audio files, in real time, Core Audio is for you.

00:20:13.920 --> 00:20:23.220
QTKit again provides you the high level services, but
this is there to actually enhance the API workflows for you.

00:20:24.970 --> 00:20:30.180
And of course we have three sessions and three labs

00:20:30.180 --> 00:20:35.860
and we have a brown bag lunch for,
if you're interested in Core Audio.

00:20:35.859 --> 00:20:44.969
Well the heart of every good graphics
system has to be a great 2D and 3D graph-ics API.

00:20:44.970 --> 00:20:48.019
And here we have OpenGL.

00:20:49.109 --> 00:20:55.179
Again with OpenGL, we've taken layered
approach to a, to its implementation.

00:20:55.180 --> 00:20:58.150
We have the driver layer.

00:20:58.150 --> 00:21:04.960
We have the OpenGL engine that comes in two varieties
the multithreaded variety and non multithreaded.

00:21:04.960 --> 00:21:11.819
And of course the frameworks we have, these are the
utility frameworks called AGL, NS OpenGL, and CGL.

00:21:11.819 --> 00:21:19.809
But if you want to do OpenGL programming, again you need
to do, to utilize OpenGL APIs and those frameworks,

00:21:19.809 --> 00:21:23.950
high level frameworks are just utility frameworks.

00:21:23.950 --> 00:21:31.490
So OpenGL is used at every level throughout our
OS from basically our genie effect that you see

00:21:31.490 --> 00:21:38.700
when you actually collapse a window to compositing
to all the Core Image filters, all the video effects,

00:21:38.700 --> 00:21:43.490
to all the iChat effects are all done in OpenGL.

00:21:43.490 --> 00:21:51.849
And again, our own iApps, like iLife, iWork, and our
Pro apps such as Final Cut Pro Shape and Logical Pro,

00:21:51.849 --> 00:21:54.689
they all leverage off of power of OpenGL.

00:21:54.690 --> 00:22:02.309
And Core Image, Core Video, core animation
and core composer all leverage off of OpenGL.

00:22:02.309 --> 00:22:10.789
And we have four sessions and a lab for you,
for those of you who are interested in OpenGL.

00:22:10.789 --> 00:22:19.509
So at this stage I want to hand off to my, to Matt
Henderson, and he's going to take you through the tools.

00:22:19.509 --> 00:22:23.140
( Period of silence )

00:22:23.140 --> 00:22:26.759
( Applause )

00:22:26.759 --> 00:22:28.150
>> Hi. My name is Matt Henderson.

00:22:28.150 --> 00:22:33.850
I am a coworker of Babak, Senior Software
Engineer in Worldwide Developer Relations.

00:22:33.849 --> 00:22:35.199
My background is in tools.

00:22:35.200 --> 00:22:40.500
I worked for many years on CodeWarrior for Mac
OS and Mac OS X before I worked for Apple.

00:22:40.500 --> 00:22:45.519
And so that's what I'm going to talk to you about,
our most basic and fundamental tools aspects.

00:22:45.519 --> 00:22:49.339
I think Deric asked you how many
were new to Mac OS X as developers?

00:22:49.339 --> 00:22:52.230
Can I get that show of hands again?

00:22:52.230 --> 00:22:53.690
So this is stuff you need to know.

00:22:53.690 --> 00:22:59.500
This is, you know, is getting started right with the
developer tools and, and learning you know how to get,

00:22:59.500 --> 00:23:04.240
how to get involved in Mac OS X programming
with the tools is a great for you to learn.

00:23:04.240 --> 00:23:06.400
And so let's talk about that.

00:23:06.400 --> 00:23:08.470
And we have an entire tool chain.

00:23:08.470 --> 00:23:13.730
Covers every aspect of software development on Mac
OS X and it starts with Xcode, which is our IDE.

00:23:13.730 --> 00:23:18.730
And we have Interface Builder, our
UI design and implementation tool.

00:23:18.730 --> 00:23:21.960
Both these great tools take advantage
of Objective-C which is the,

00:23:21.960 --> 00:23:27.579
as you've gathered through these sessions
is the language of choice on Mac OS X.

00:23:27.579 --> 00:23:32.279
Objective-C is built with you know good old UNIX GCC and LD,

00:23:32.279 --> 00:23:36.410
the compiler link combination that's
been around for decades and decades.

00:23:36.410 --> 00:23:44.110
We debug it with GDB, the open source standard for, for
debugging that's also, comes for the UNIX background.

00:23:44.109 --> 00:23:47.649
And we also have our own great suite
of performance analysis tools.

00:23:47.650 --> 00:23:50.740
So starting with Xcode.

00:23:50.740 --> 00:23:56.490
Lots and lots of great features and it's a
very powerful, very robust industrial strength tool.

00:23:56.490 --> 00:24:00.359
It's used inside of Apple to build
both, practically the whole OS.

00:24:00.359 --> 00:24:06.319
It's used outside of Apple by virtually every major
third party who develops software on Mac OS X.

00:24:06.319 --> 00:24:15.179
Adobe, Microsoft, anyone who's shipped a universal
binary on Mac OS X has probably built it with Xcode.

00:24:15.180 --> 00:24:22.490
And Xcode is great if you're from a UNIX background because
it wraps all the great open source tools I just mentioned,

00:24:22.490 --> 00:24:30.450
GCC, LD, GDB, those are all the foundations for Xcode
when you get to your building and debugging parts.

00:24:30.450 --> 00:24:38.610
And it's just a great, powerful, easy to use front end for
those sorts of low level, low level open source tools.

00:24:38.609 --> 00:24:41.069
Core features, every IDE does three things.

00:24:41.069 --> 00:24:43.809
It edits, it builds, it debugs.

00:24:43.809 --> 00:24:46.789
And Xcode is no different in these respects.

00:24:46.789 --> 00:24:53.019
The great editor, it's a language sensitive, context
sensitive, you get nice coloring indentation,

00:24:53.019 --> 00:24:59.980
a huge number of navigation features for both discovering
newer code and navigating two different symbols very easily.

00:24:59.980 --> 00:25:06.220
And cool features called code sense for figuring out
the system APIs and getting those in your code easily

00:25:06.220 --> 00:25:10.120
without worrying about the parameters so much.

00:25:10.119 --> 00:25:15.939
Building, it also does everything you
accept, automatic dependency tracking,

00:25:15.940 --> 00:25:19.640
you do not have to manage the relationship
between your source and your header files.

00:25:19.640 --> 00:25:22.310
I know that for some of you coming
from a Make File background

00:25:22.309 --> 00:25:26.029
that might, that might be luxurious, but it's there.

00:25:26.029 --> 00:25:33.109
It works. And beyond the simple source and header file
dependencies, you can set up your own multi target,

00:25:33.109 --> 00:25:38.369
multi binary dependencies, you know to
make sure that your shared libraries build

00:25:38.369 --> 00:25:41.229
in the right version before your application builds.

00:25:41.230 --> 00:25:46.519
And everything is linked properly and everything exists
and your build, you know the entire hierarchical

00:25:46.519 --> 00:25:49.789
build of your application fires correctly.

00:25:49.789 --> 00:25:56.420
And one of the best features, especially if you're a
fairly large, deploy these fairly large scale applications,

00:25:56.420 --> 00:25:59.240
is Xcode's hierarchal cross project settings.

00:25:59.240 --> 00:26:06.660
So you can make a simple few configuration files that
contain all of your build settings and deploy them so they,

00:26:06.660 --> 00:26:12.810
they configure multiple projects across, and
multiple targets and it provides complete uniformity

00:26:12.809 --> 00:26:18.389
of build settings and you can easily, easily
make large scale changes by just you know a few,

00:26:18.390 --> 00:26:24.060
editing a few text files such that you don't end up
iterating through all of your projects and targets

00:26:24.059 --> 00:26:27.190
and manually tweaking build settings
when you need to make a change.

00:26:27.190 --> 00:26:31.460
And lastly, I don't know, as I said I worked
on you know CodeWarrior from MetroWorks

00:26:31.460 --> 00:26:34.230
and a lot of you all probably haven't heard of that.

00:26:34.230 --> 00:26:38.819
But code warrior was a really fast
IDE and I like really fast builds.

00:26:38.819 --> 00:26:39.980
And Xcode provides that.

00:26:39.980 --> 00:26:43.470
It's a multiprocessor and a distributed builds.

00:26:43.470 --> 00:26:47.269
If you're a small, five man software
shop and you've got five engineers

00:26:47.269 --> 00:26:50.079
on five MacPros, that's not really all you have.

00:26:50.079 --> 00:26:53.009
You really have a 20 core buil d farm.

00:26:53.009 --> 00:26:58.250
Xcode automatically discovers other running X
Codes for you and will distribute builds for that.

00:26:58.250 --> 00:27:04.009
And you can really, really reduce the amount of time
you spend waiting on builds when you use Xcode.

00:27:04.009 --> 00:27:06.230
Debugging as I mentioned is based on GDB.

00:27:06.230 --> 00:27:13.120
Provides everything you expected in a debugger, process
flow control, variable display, break points, watch points.

00:27:13.119 --> 00:27:17.709
It also fully debugs, shared code and plug ins.

00:27:17.710 --> 00:27:24.160
So there's no worry about that if you have a modular
applications or are working on a plug in for another app.

00:27:24.160 --> 00:27:27.050
Xcode will handle all that for you.

00:27:27.049 --> 00:27:33.329
And there's a million other features in Xcode,
but I'm going to cover a couple that I think that you

00:27:33.329 --> 00:27:35.480
as an audience are going to be particularly interested in.

00:27:35.480 --> 00:27:37.420
And the first is the research assistant.

00:27:37.420 --> 00:27:45.029
It's basically a context sensitive documentation viewer
that will show you API references and tools references

00:27:45.029 --> 00:27:49.019
from whatever you're working on at
that moment without losing focus.

00:27:49.019 --> 00:27:54.660
And it's just such a great way to discover
the, the APIs on Mac OS X whatever they are.

00:27:54.660 --> 00:28:00.890
And to have great fun and an easy to
use front end for our documentation.

00:28:00.890 --> 00:28:03.700
And also build phases and build rules.

00:28:03.700 --> 00:28:11.470
These allow you to produce, implement, make file-
like features into the Xcode build process

00:28:11.470 --> 00:28:15.759
such that you can perform common batch
operations, integrate your own custom tools.

00:28:15.759 --> 00:28:20.930
If you have your own compilers or even something
standard from the UNIX world like a Lexor Yak Compiler.

00:28:20.930 --> 00:28:24.519
Very easy to plug it into the Xcode build process.

00:28:24.519 --> 00:28:29.410
And Xcode will even track dependencies for
those sorts of tools the same way it does

00:28:29.410 --> 00:28:33.690
for your basic C and C++ sources and headers.

00:28:33.690 --> 00:28:38.960
And you can also integrate practically any shell
script you want into the Xcode build process.

00:28:38.960 --> 00:28:46.799
And that shell script will have full access to all of
the environment variables for the build environment.

00:28:46.799 --> 00:28:53.940
So, and after Xcode, which covers you know the, the
basics of building or editing, building and debugging,

00:28:53.940 --> 00:28:59.299
we have Interface Builder which is the user
interface design and implementation tool.

00:28:59.299 --> 00:29:06.299
And if you've heard Larry's presentation in
the session before, you'll know that you're,

00:29:06.299 --> 00:29:13.169
he talked a lot about the view model controller paradigm
for implementing applications with user interface.

00:29:13.170 --> 00:29:15.279
Interface Builder makes that easy.

00:29:15.279 --> 00:29:22.129
It's a completely visual editor
for the view and control of thing and it,

00:29:22.130 --> 00:29:27.140
it also has a lot of great features for using Mac OS X

00:29:27.140 --> 00:29:31.350
and the Mac OS X user interface
conditions properly in your application.

00:29:31.349 --> 00:29:37.219
It knows all about widget metrics and is a great
system of guides for snapping things into place exactly

00:29:37.220 --> 00:29:41.839
where they need to go as you lay out your user interface.

00:29:41.839 --> 00:29:48.619
So even cooler than that, Interface Builder can
actually learn about your classes that you write

00:29:48.619 --> 00:29:56.219
in Objective-C. Once you've written one of your
controller classes to hook your UI up to your engine code,

00:29:56.220 --> 00:30:02.259
Interface Builder will import it and parse it and
provide all its functionality accessible through its,

00:30:02.259 --> 00:30:11.140
its design and layout layer when you're visually editing
your, your applications interface in Interface Builder.

00:30:11.140 --> 00:30:16.430
With that I'm going to switch to the demo station and
show you a couple of quick demos of these features.

00:30:16.430 --> 00:30:20.690
So its, seems to be in screen saver mode right now.

00:30:20.690 --> 00:30:26.130
But oh. That's our, our boss asking what's going on.

00:30:26.130 --> 00:30:28.910
So, we'll get rid of that.

00:30:28.910 --> 00:30:35.610
First thing I'm going to do is a really trivial
but interesting demo of Interface Builder.

00:30:36.670 --> 00:30:40.340
And I'm going to essentially build a web browser.

00:30:40.339 --> 00:30:42.349
So we start with an empty window.

00:30:42.349 --> 00:30:48.139
And every good web browser has a text field.

00:30:49.160 --> 00:30:50.680
So we'll lay that out there.

00:30:50.680 --> 00:30:56.090
And as you watch the little guide snap it into
place, in the proper place and we'll size it.

00:30:56.089 --> 00:31:04.509
And we'll bring up the inspector so I can make sure.

00:31:04.509 --> 00:31:09.329
( Period of silence )

00:31:09.329 --> 00:31:12.889
Find the right palette here.

00:31:12.890 --> 00:31:15.509
This is a beta OS and uh

00:31:15.509 --> 00:31:21.680
( Period of silence )

00:31:21.680 --> 00:31:26.900
It occasionally misbehaves
and this is what I'm looking for.

00:31:26.900 --> 00:31:33.360
So we'll snap that into place and make
sure it behaves when the window resizes.

00:31:33.359 --> 00:31:44.119
Then we need our forward and our back
button, so we'll place a back button.

00:31:45.599 --> 00:31:49.750
And we'll place a forward button.

00:31:53.509 --> 00:32:00.299
( Period of silence )

00:32:00.299 --> 00:32:06.669
And finally we'll scroll down and
we'll place the Web Kit web view.

00:32:08.130 --> 00:32:13.290
So you see a few little drawing glitches, but we're
allowed a few glitches because it's a beta OS.

00:32:13.289 --> 00:32:16.809
So we have all those things and we've build a,

00:32:16.809 --> 00:32:23.889
a view resources that's some binary data that's
going to be used in your, in your application.

00:32:23.890 --> 00:32:28.830
But we can go beyond that in Interface Builder and we
can sort of wire up the behaviors and the functionality.

00:32:28.829 --> 00:32:36.899
So we take the URL field and connect it
to the web view and tell the web view

00:32:36.900 --> 00:32:40.910
that it should get the URL string from that URL field.

00:32:40.910 --> 00:32:44.160
We'll take the back button, wire it to the web view.

00:32:44.160 --> 00:32:47.220
Tell it it should make the web view go back.

00:32:47.220 --> 00:32:50.569
Take the forward button, same thing but go forward.

00:32:50.569 --> 00:32:53.889
And we've got a very simple web, web browser.

00:32:53.890 --> 00:33:01.300
So I can, we'll save the whole thing off.

00:33:03.490 --> 00:33:06.509
Take it, simulate an interface.

00:33:06.509 --> 00:33:13.710
( Background noise )

00:33:13.710 --> 00:33:18.390
And we've got basic web browser.

00:33:18.390 --> 00:33:23.320
And I know you all want an iPhone,
so we'll click on the iPhone link.

00:33:23.319 --> 00:33:27.879
Wait on it a bit, we see the iPhone,
back button works, forward button works.

00:33:27.880 --> 00:33:29.620
And I haven't written a line of code.

00:33:29.619 --> 00:33:33.299
And Interface Builder hasn't generated a line of code.

00:33:33.299 --> 00:33:36.829
In fact, it's not even actually running your application.

00:33:36.829 --> 00:33:43.720
This is just taking the simple layout and relationships
between the widgets that I've defined and it is using

00:33:43.720 --> 00:33:47.370
that data driven description to simulate your interface.

00:33:47.369 --> 00:33:50.519
So we can quit the Cocoa simulator now.

00:33:50.519 --> 00:33:58.000
Go back to Interface Builder, and
tell it to build and go in Xcode.

00:33:59.009 --> 00:34:07.549
It will compile it, link it, build succeeds
and now it's actually launched my no code demo.

00:34:07.549 --> 00:34:08.630
And same thing.

00:34:08.630 --> 00:34:14.710
It works. And no code at all.

00:34:14.710 --> 00:34:22.880
And no generated code, no build dependencies, so it's,
it's really great for way to cleanly implement URI.

00:34:22.880 --> 00:34:29.010
So we'll quit out of Interface Builder and
I'm going to show you a completely unrelated

00:34:29.010 --> 00:34:34.020
but I think equally interesting demo for you as an audience.

00:34:36.780 --> 00:34:43.200
We'll open up one of these standard Apple
example projects for your app kit in Cocoa.

00:34:43.199 --> 00:34:50.919
And this is of course Xcode the IDE and here
you can see I'm looking at the sources in here.

00:34:50.920 --> 00:34:55.079
So I'll open this one big Objective-C file.

00:34:55.079 --> 00:35:01.230
And here's Xcode's editor, but I'm not so much
interested in showing off the editor as the documentation.

00:35:01.230 --> 00:35:08.409
Since you are all mostly new to the platform, you're
going to have a, a really big initial learning curve,

00:35:08.409 --> 00:35:16.000
getting used to the APIs and I want you
to see how easy that can be with Xcode.

00:35:16.000 --> 00:35:25.570
So I'm going to use this to quickly jump to a function and
you know pretty common Objective-C, Objective-C method.

00:35:25.570 --> 00:35:28.440
We see something here on NS Array.

00:35:28.440 --> 00:35:32.740
And NS Array of course is one of the
core collection classes of Cocoa.

00:35:32.739 --> 00:35:36.539
And so its, its probably interesting
to you as a new developer.

00:35:36.539 --> 00:35:44.250
So if you're a new developer and you want to learn
about NS Array, you might jump to our documentation.

00:35:47.659 --> 00:35:53.589
Do an API search in our core reference library for NS Array.

00:35:53.590 --> 00:35:55.730
And we find some hits.

00:35:55.730 --> 00:36:00.119
We find a lot of good stuff about it.

00:36:00.119 --> 00:36:10.339
A basic overview of the class that explains it and a
method by method description of all the instances vari,

00:36:10.340 --> 00:36:13.420
instances variables and methods in the class.

00:36:13.420 --> 00:36:14.050
And so that's great.

00:36:14.050 --> 00:36:15.870
That's exactly what you were looking for as a new developer.

00:36:15.869 --> 00:36:20.299
You've, can peruse this documentation,
learn a lot about NS Array.

00:36:20.300 --> 00:36:25.220
But I was a little tedious, so
can we do it any faster in Xcode?

00:36:25.219 --> 00:36:26.199
And we can.

00:36:26.199 --> 00:36:28.019
We have the Research Assistant.

00:36:28.019 --> 00:36:32.809
So just the Research Assistant
takes the selection and tells you

00:36:32.809 --> 00:36:35.230
about it immediately if there's something to say about it.

00:36:35.230 --> 00:36:41.380
So I've highlight NS Array, you see the exact
sample NS Array class reference I just looked up,

00:36:41.380 --> 00:36:42.910
manually in the doc viewer.

00:36:42.909 --> 00:36:48.549
And we never had to click off anything or
unselect or to the menus or anything else.

00:36:48.550 --> 00:36:52.300
In fact, I can even jump to the header
file from the Research Assistant.

00:36:52.300 --> 00:36:54.630
And it works for stuff other than classes.

00:36:54.630 --> 00:36:57.360
We can look up the array with objects method here.

00:36:57.360 --> 00:37:01.099
And it provides you know the full
description of that as well.

00:37:01.099 --> 00:37:02.389
So that's my demo.

00:37:02.389 --> 00:37:04.650
I'm ready to go back to the slides now.

00:37:08.130 --> 00:37:14.840
And that's Xcode Interface Builder and that was not a,
not a huge and involved demo, but that gives you some

00:37:14.840 --> 00:37:21.720
of the sort of the idea of how developing on Mac OS X
is going to be quicker than it is on other platforms.

00:37:21.719 --> 00:37:26.730
So we have a lot of content about Xcode
and Interface Builder at this show.

00:37:26.730 --> 00:37:31.840
I hope you'll go to as much of it as you can,
especially the first two sessions on this list,

00:37:31.840 --> 00:37:35.829
getting started with the development
tools and getting started with Xcode.

00:37:35.829 --> 00:37:43.849
They're great and from those two we have four more
sessions that build on that to more advanced expertise

00:37:43.849 --> 00:37:50.089
and Xcode Interface Builder and you know I
think by the time you've seen the first two,

00:37:50.090 --> 00:37:52.180
the next four will make a lot of sense to you.

00:37:52.179 --> 00:37:57.949
So please, I encourage you to go see,
go see all these as the week progresses.

00:37:57.949 --> 00:38:02.649
And the most fundamental aspect,
now that we've covered sort of the,

00:38:02.650 --> 00:38:06.910
the high level pretty parts of the
Apple tool chain is the language.

00:38:06.909 --> 00:38:12.759
And its Objective-C is the language for
high level development on Mac OS X.

00:38:12.760 --> 00:38:18.610
It is a C based language, just like Java
is C, or C and C++.

00:38:18.610 --> 00:38:28.160
In fact it's just a very simple extension to basic
C that takes some of the small talk heritage,

00:38:28.159 --> 00:38:32.299
object oriented features and graphs
them onto the plain C language.

00:38:32.300 --> 00:38:35.560
So it's not very complicated.

00:38:35.559 --> 00:38:42.090
Back in the day when it was originally invented, it was
a very simple pre processor that took an Objective-C code

00:38:42.090 --> 00:38:48.380
and spit out simple plain C code
and its, so its quite light weight.

00:38:48.380 --> 00:38:52.910
Like all object oriented languages, it
supports all of the stuff you learned in CS101.

00:38:52.909 --> 00:39:01.029
Encapsulation, inheritance, polymorphism, unlike Java and C
Plus Plus, polymorphic methods in Objective-C are dispatched

00:39:01.030 --> 00:39:04.060
at run time and are not bound at compile time.

00:39:04.059 --> 00:39:09.380
And this is a great and powerful feature
and is one of the enabling technologies

00:39:09.380 --> 00:39:13.000
that allows Interface Builder to
do all the cool stuff it does.

00:39:13.000 --> 00:39:18.719
So, and Objective-C has even more cool dynamic
language features, introspection of course,

00:39:18.719 --> 00:39:22.939
you can query at run time all about
methods and instance variables.

00:39:22.940 --> 00:39:29.429
Object properties gets rid of a lot of the basic
tedium of writing getters and setters for your classes.

00:39:29.429 --> 00:39:32.719
That's a new feature for Objective-C 2.0 in Leopard.

00:39:32.719 --> 00:39:39.789
Garbage collection supercedes the old reference
counting method that of memory management

00:39:39.789 --> 00:39:46.389
that Cocoa has traditionally used, but is an opt in scheme
as Larry mentioned in the last setting, last session.

00:39:46.389 --> 00:39:48.129
You don't have to use it if you don't want to.

00:39:48.130 --> 00:39:53.490
Or if you want very explicit control over your memory
management, you can choose to not use garbage collection

00:39:53.489 --> 00:39:56.909
and continue with a reference counted memory model.

00:39:56.909 --> 00:40:01.289
And all these things add up to make
Objective-C a truly dynamic language.

00:40:01.289 --> 00:40:04.949
It has a lot of advantages over other C derived languages.

00:40:04.949 --> 00:40:12.439
It doesn't suffer from the, you know perplexity of
fragile base class problems that C++ does.

00:40:12.440 --> 00:40:17.230
You can have fragile base classes in Objective
C, but it's a lot harder and a lot easier for you

00:40:17.230 --> 00:40:22.019
to purposely avoid it rather than
have it practically always happen.

00:40:22.019 --> 00:40:28.199
Because of the dynamic dispatch at run time, it makes
writing plug ins and shared code very, very easy.

00:40:28.199 --> 00:40:34.139
So you can just load them and dispatch by
symbols and not have as hard a linking phase

00:40:34.139 --> 00:40:38.829
as you would with a C++ base DOL or plug in.

00:40:38.829 --> 00:40:44.929
And of course it enables the very powerful
development tools like Interface Builder that lets you,

00:40:44.929 --> 00:40:48.759
saves you from having to write a lot of code.

00:40:50.000 --> 00:40:55.519
And there's a lot of sessions to learn more of
Objective-C. Getting starting with Cocoa bindings,

00:40:55.519 --> 00:40:58.840
we'll talk about some of the ways
that Cocoa, Interface Builder

00:40:58.840 --> 00:41:02.880
and Objective-C work together to save you from writing code.

00:41:02.880 --> 00:41:09.320
And there's a further session coverage of the new
garbage collection feature in Objective-C 2 point 0

00:41:09.320 --> 00:41:13.910
and some general coding tips for
writing better code in Objective-C

00:41:13.909 --> 00:41:19.500
and at last an advanced session on
the Objective-C language as well.

00:41:19.500 --> 00:41:23.989
So Objective-C though is not the
only way to code on Mac OS X.

00:41:23.989 --> 00:41:27.909
We do of course fully support NCC and C++.

00:41:27.909 --> 00:41:33.779
And the great story about this is we not only support
them, they are fully integratable with Objective-C.

00:41:33.780 --> 00:41:40.340
So if you have a legacy code base coming from Windows
or UNIX then you, and you factored it like Larry talked

00:41:40.340 --> 00:41:45.360
about in the last session such that your
UI code is separated from your engine code,

00:41:45.360 --> 00:41:48.050
then there's a good chance you'll
probably be able to use a lot

00:41:48.050 --> 00:41:51.680
of your intellectual property as
is when coming to Mac OS X.

00:41:51.679 --> 00:41:52.639
That's what we want to do.

00:41:52.639 --> 00:41:57.920
We don't want you to have to reinvent your
own wheel just to exist on our platform.

00:41:57.920 --> 00:42:04.200
So we're hoping that all of you as developers
from other platforms will come in and build,

00:42:04.199 --> 00:42:10.210
build a really Mac OS X user interface using Cocoa
and then keep using your same CDC++ based code

00:42:10.210 --> 00:42:14.960
that you've already invested heavily in on
other platforms and build them together.

00:42:14.960 --> 00:42:17.639
And produce a great Mac OS X application.

00:42:17.639 --> 00:42:19.230
Java exists.

00:42:19.230 --> 00:42:27.130
Virtually every UNIX scripting and development language that
you've ever heard of exists in and is installed by default.

00:42:27.130 --> 00:42:34.380
And there's also, if you're coming from Fortran
background, G Fortran and Fortran compilers

00:42:34.380 --> 00:42:38.400
from both Intel and IBM are available for use.

00:42:38.400 --> 00:42:45.019
And there's two sessions related to this,
discovering Java on Leopard and Fortran Development.

00:42:45.019 --> 00:42:49.800
If those are applicable to you, then
by all means, please go see them.

00:42:49.800 --> 00:42:56.720
And as I mentioned before, the compiler linker in
Mac OS X is GCC and LD and they're actually the same

00:42:56.719 --> 00:42:59.449
as they are on every other UNIX in the world.

00:42:59.449 --> 00:43:07.659
We track the current state of the art in the open
source community for these two tools very closely.

00:43:07.659 --> 00:43:10.769
We not only track and we contribute heavily back to them.

00:43:10.769 --> 00:43:17.920
So a lot of the, the more current GCCs have
Apple contributed changes and features in them.

00:43:17.920 --> 00:43:23.570
You've seen, you've seen me talk or heard
me talk about using GCC and LD from Xcode.

00:43:23.570 --> 00:43:26.550
Well, they're also fully accessible by the command line.

00:43:26.550 --> 00:43:31.740
We of course supply straight up UNIX Make, so
if you're coming from a Make File background,

00:43:31.739 --> 00:43:35.869
you can use that on Mac OS X without
worrying about your Make Files

00:43:35.869 --> 00:43:39.869
and with the same GCC compiler
you've been used to forever and ever.

00:43:39.869 --> 00:43:47.549
And our compiler, linker and debugger use the
emerging dwarf standard for debugger symbolics.

00:43:47.550 --> 00:43:52.450
And that's, that's a much faster
and more optimal and smaller format

00:43:52.449 --> 00:43:56.929
for storing debugging information than
the old traditional UNIX stabs is.

00:43:56.929 --> 00:44:02.489
It goes without saying our compiler, linker
target all, all current Mac OS hardware platforms

00:44:02.489 --> 00:44:06.349
and it supports you know the obvious
Mac OS X technologies as well.

00:44:06.349 --> 00:44:07.940
Debugger is the same story.

00:44:07.940 --> 00:44:11.429
The GDB, we started with GDB from the open source world.

00:44:11.429 --> 00:44:18.909
We've pushed back a lot of our changes to make debugging
better on Mac OS X and presumably other UNIX as well.

00:44:18.909 --> 00:44:23.949
Like our command line, like compiler and linker
it's fully accessible via the command line

00:44:23.949 --> 00:44:25.819
if you choose to use it that way.

00:44:25.820 --> 00:44:27.360
And it also uses dwarf.

00:44:27.360 --> 00:44:31.490
And of course it supports all our hardware.

00:44:31.489 --> 00:44:37.109
So those are the core tools and after you've built, built,

00:44:37.110 --> 00:44:41.380
debugged and mostly have your application
done, its time to look at your performance.

00:44:41.380 --> 00:44:45.180
And figure out what things are slow
or what things are going wrong.

00:44:45.179 --> 00:44:52.960
And we have a great set of tools for doing run time analysis
of your application and virtually any of its aspects.

00:44:52.960 --> 00:44:55.210
And the first one of those is Xray.

00:44:55.210 --> 00:45:01.970
And it's a debugging and analysis tool based on Detrace,
which is an open source tracing and analysis tool.

00:45:01.969 --> 00:45:08.980
And it can analyze all sorts of things about
your application from memory usage to file usage

00:45:08.980 --> 00:45:12.809
to execution speed to virtual memory usage.

00:45:12.809 --> 00:45:14.119
It's all very configurable.

00:45:14.119 --> 00:45:24.909
It all has a great UI based on our iApps UI
that shows a, you know sort of a timelines.

00:45:24.909 --> 00:45:30.199
And so if you, when you get to the part
where you're a bit beyond debugging and are looking

00:45:30.199 --> 00:45:34.599
to optimize the performance of your
application or figure out some problem,

00:45:34.599 --> 00:45:38.519
problematic statistics about it, then Xray is where you go.

00:45:38.519 --> 00:45:45.590
We also have Shark which is a lower level,
you know specialized profiler that basis,

00:45:45.590 --> 00:45:50.769
samples at kernel time to tell exactly
what you're application is doing.

00:45:50.769 --> 00:45:54.199
The most common use of Shark is to measure time spent.

00:45:54.199 --> 00:45:59.730
And it will measure execution time down
to the instruction in your application.

00:45:59.730 --> 00:46:06.110
But it also tracks all sorts of other low level system
events like CPU cache misses, virtual memory usage,

00:46:06.110 --> 00:46:12.380
page outs, page ins, anything that could slow your
application down, Shark will detect it and show it to you

00:46:12.380 --> 00:46:18.789
and match it to an exact line of code in your
application so you can hunt that down and fix it.

00:46:18.789 --> 00:46:22.509
And we have a lot more performance, a lot more
performance tools as well, beyond those two.

00:46:22.510 --> 00:46:28.200
Those are the, the big ones and, and
who, that cover the most territory.

00:46:28.199 --> 00:46:33.049
But we have Big Top which is nice UI around the classic mix.

00:46:33.050 --> 00:46:38.170
Top Tool, stuff for debugging Quartz drawing.

00:46:38.170 --> 00:46:45.119
Thread specific debugging tools, even a tool
to tell you why you're spinning too much,

00:46:45.119 --> 00:46:50.219
or tell you why your application is spinning
the rainbow cursor of idleness too much.

00:46:50.219 --> 00:46:54.839
So we have all these great tools for
analyzing performances of your application,

00:46:54.840 --> 00:46:58.950
and they're included by default
with the developer tools installer.

00:46:58.949 --> 00:47:02.129
So we do of course have sessions about these.

00:47:02.130 --> 00:47:09.730
And if you're at all interested in measuring your
application's performance, I would encourage you strongly

00:47:09.730 --> 00:47:15.039
to go to getting started with Xray and getting
started with performance tending with Shark.

00:47:15.039 --> 00:47:21.769
And we also have a great session on tuning your OpenGL
application, which we use a variety of tools to tell you how

00:47:21.769 --> 00:47:27.980
to make your OpenGL performance really scream on
Mac OS X and because OpenGL is cross platform,

00:47:27.980 --> 00:47:31.539
on any other platforms you might support as well.

00:47:31.539 --> 00:47:34.279
So that covers the basics of our tools chain.

00:47:34.280 --> 00:47:41.470
So now I'm going to just mention some things that are
interesting to you if you're coming to Mac OS X from UNIX.

00:47:41.469 --> 00:47:45.769
And the great news is if you're a UNIX
developer is that Mac OS X is UNIX.

00:47:45.769 --> 00:47:52.269
Every API, every tool that you've probably ever
used on UNIX all, already exists on Mac OS X.

00:47:52.269 --> 00:47:56.639
Its free BSD at the lowest level as
you saw on some of the box slides.

00:47:56.639 --> 00:47:58.869
All that good stuff.

00:47:58.869 --> 00:48:03.630
If you know god help you, you edit
your source in VI or Emax, then,

00:48:03.630 --> 00:48:07.000
then that's there for you to use and, and it's not my fault.

00:48:07.000 --> 00:48:08.949
( Laughter )

00:48:08.949 --> 00:48:11.500
If you use MEG files, that's there.

00:48:11.500 --> 00:48:18.050
Pearl, Python, Ruby all of the you know great
UNIX scripting languages, there by default.

00:48:18.050 --> 00:48:22.960
All that good stuff, it's available
and the wider open source community

00:48:22.960 --> 00:48:28.400
and set of tools is also available via
Darwin ports and FINK, two really powerful

00:48:28.400 --> 00:48:34.440
and comprehensive package management tools for Mac OS X.

00:48:34.440 --> 00:48:40.300
If you are an X11 developer on UNIX, X11 is available.

00:48:40.300 --> 00:48:48.990
We would prefer that you develop a nice UI for your Mac OS
X application in Cocoa, but if you must, you can use X11

00:48:48.989 --> 00:48:53.539
and it will come across generally
speaking very cleanly to Mac OS X.

00:48:53.539 --> 00:48:58.320
GTK plus, KD based software, it's pretty
much just a recompile on Mac OS X.

00:48:58.320 --> 00:49:00.500
And that will save you a lot of
work if you are trying to get

00:49:00.500 --> 00:49:04.780
over to Mac OS X really quick from an X based environment.

00:49:05.860 --> 00:49:10.680
If you're coming to Mac OS X from Windows,
well the story is not quite as good.

00:49:10.679 --> 00:49:13.289
Mac OS X is definitely not Windows.

00:49:13.289 --> 00:49:23.139
I've gone over the whole tool chain. Xcode is, I think,
the moral equivalent of DevStudio, but a lot better.

00:49:23.139 --> 00:49:30.879
We do a lot of cool things they don't and Interface
Builder has a tool that lets you avoid coding in ways

00:49:30.880 --> 00:49:33.030
that you can't when you're working on Windows.

00:49:33.030 --> 00:49:39.500
There's not any APIs in common
between Mac OS X and Windows.

00:49:39.500 --> 00:49:45.429
But we have equivalent APIs to all of the functionality
that you would expect to be able to use you know

00:49:45.429 --> 00:49:47.539
if you're coming from a Windows background.

00:49:47.539 --> 00:49:53.659
And of course you know Larry in the last session harped on
it again and again, you know if you've done the right thing

00:49:53.659 --> 00:50:00.799
and at least factored UI from your engine code, if
not gone the whole full view model controller app,

00:50:00.800 --> 00:50:04.120
then rebuilding your Windows application should be easy.

00:50:04.119 --> 00:50:11.139
And finally its even though we don't have equivalent APIs
for, we do have equivalent APIs for everything on windows,

00:50:11.139 --> 00:50:16.960
but we also have a lot of great APIs like core
animation and some of the stuff that Deric showed off,

00:50:16.960 --> 00:50:23.449
that just don't exist on Windows that will let you put new
features in your application that your customers will love

00:50:23.449 --> 00:50:25.929
and that won't exist on any other platform.

00:50:25.929 --> 00:50:31.739
So I think we have a great story if you're a Windows
developer coming to Mac OS X for the first time.

00:50:31.739 --> 00:50:34.169
You have the chance to really add some cool stuff

00:50:34.170 --> 00:50:38.619
and make the Mac OS X you know the
design center for your application.
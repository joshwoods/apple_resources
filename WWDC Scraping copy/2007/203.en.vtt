WEBVTT

00:00:12.980 --> 00:00:18.839
>> I'm Bill Bumgarner. I'm the engineering
manager of the runtime team or the wizards

00:00:18.839 --> 00:00:22.289
that make the runtime, so I'm the wizard wrangler.

00:00:22.289 --> 00:00:25.769
This is Coding Smarter with Objective-C 2.0.

00:00:25.769 --> 00:00:30.719
I hope you all have your laptops booted
in Leopard, full batteries, ready to go.

00:00:30.719 --> 00:00:36.500
I want to see a show of hands, how many people
here have done a bunch of Objective-C programming?

00:00:36.500 --> 00:00:39.579
Cool. How many of you are pretty new to it?

00:00:39.579 --> 00:00:41.539
Alright, and while we're raising hands, Michael?

00:00:41.539 --> 00:00:41.729
>> Yes?

00:00:41.729 --> 00:00:42.959
Can you lead a wave?

00:00:42.960 --> 00:00:44.410
>> Wave?

00:00:44.409 --> 00:00:47.069
>> Wave from over there to over here, come on.

00:00:47.070 --> 00:00:49.480
All right. Good.

00:00:49.479 --> 00:00:55.409
Now that everyone's awake. So here's
an overview of the session.

00:00:55.409 --> 00:00:57.649
We're here to do a little survey of Objective-C 1.0,

00:00:57.649 --> 00:01:01.100
kind of frame where we're coming from
and some history of this platform.

00:01:01.100 --> 00:01:05.489
And then we're going to look specifically to
Objective-C 2.0, dive right into this code.

00:01:05.489 --> 00:01:11.329
I think the teams pulled together some very cool stuff
that's going to make you much more efficient programmers.

00:01:11.329 --> 00:01:16.329
We want to get your hands in it and give you a feel for it.

00:01:16.329 --> 00:01:24.959
So Objective-C. Well, it's a simple set of syntactic
extensions to C. And it's truly a set of extensions.

00:01:24.959 --> 00:01:33.099
It doesn't try to overload or override existing behaviors
in C. It is a dynamic object-oriented programming language.

00:01:33.099 --> 00:01:38.699
And by dynamic, I mean that you have a lot of control of
the behavior at runtime and there's a lot of behaviors

00:01:38.700 --> 00:01:45.159
that happen at runtime as your applications are
running, as opposed to all compiled time or all static.

00:01:45.159 --> 00:01:49.289
It was actually invented about the same time as C++.

00:01:49.290 --> 00:01:52.470
So this is a very mature language.

00:01:52.469 --> 00:01:58.819
There's a small and powerful runtime that's
actively available at the core of your applications,

00:01:58.819 --> 00:02:04.129
its there for you to use to leverage,
to build your applications.

00:02:05.260 --> 00:02:11.789
It uses single inheritance, so there's no
multiple inheritance for the implementation side.

00:02:11.789 --> 00:02:17.179
The inheritance model supports inheritance of
class methods too. So you can create a class,

00:02:17.180 --> 00:02:21.390
have a class method, subclasses, override that class method.

00:02:21.389 --> 00:02:26.209
However, specifications can be multiply inherited.

00:02:27.629 --> 00:02:32.680
And you can extend existing classes with categories.

00:02:32.680 --> 00:02:39.830
And this is an implementation inherited by subclasses.
So you can extend the base class in this object

00:02:39.830 --> 00:02:44.260
and that implementation will be available everywhere.

00:02:44.259 --> 00:02:51.780
So when we talk about languages, though, really you never
talk about a language without talking about the APIs

00:02:51.780 --> 00:02:55.780
that are available with the language,
the libraries available with it.

00:02:55.780 --> 00:02:59.340
And this is very true of Objective-C
on the Mac OS X platform.

00:02:59.340 --> 00:03:07.509
There are other base classes available in
Objective-C; they're out there, you can go find them

00:03:07.509 --> 00:03:13.189
But on the Mac OS X platform everything kind of
roots from NSObject as a part of the foundation kit

00:03:13.189 --> 00:03:17.579
and a lot of what we're going to be talking
about today is actually behaviors provided

00:03:17.580 --> 00:03:20.460
by the foundation, not a part of the language.

00:03:20.460 --> 00:03:25.540
But the two can't be separated so that's why it's
important to talk about them at the same time.

00:03:25.539 --> 00:03:32.879
Lots of powerful objects in the foundation kit for you
to use so you won't have to reinvent common wheels.

00:03:34.139 --> 00:03:38.859
Now when we're talking about an object-
oriented language, of course, it's all

00:03:38.860 --> 00:03:43.430
about subclassing, amongst other things.
This is a typical class declaration.

00:03:43.430 --> 00:03:48.730
You see there's instance variables for storage,
there's methods, the method with a + in front of it,

00:03:48.729 --> 00:03:53.239
class method, instance methods, etc.

00:03:53.240 --> 00:04:03.520
So we talked about multiple inheritance of specification
and in Objective-C that's called a protocol.

00:04:03.520 --> 00:04:07.670
And you'll see that we've now declared
that our Car object which is a subclass

00:04:07.669 --> 00:04:11.409
of NSObject implements the NSCopying protocol.

00:04:11.409 --> 00:04:19.699
And the NSCopying protocol is just a way to say my
class is going to implement the copyWithZone method.

00:04:19.699 --> 00:04:25.969
And as well, give the foundation and the other tools and the
environment including the compiler the ability to validate

00:04:25.970 --> 00:04:28.300
that your class implements that contract.

00:04:28.300 --> 00:04:35.590
Your class is compatible with the copying
contract and instances can be copied.

00:04:35.589 --> 00:04:42.979
Now categories on the other hand, they're sort of
an informal protocol that can fulfill three roles.

00:04:42.980 --> 00:04:45.860
We can use them as an organizational tool.

00:04:45.860 --> 00:04:51.230
I think you may have seen in some languages
where there's not organizational tools like this.

00:04:51.230 --> 00:04:54.530
The interface for class can get really huge.

00:04:54.529 --> 00:04:57.899
Well, we can use a category to break up the interface.

00:04:57.899 --> 00:05:00.810
For example this is the NSArray's interface.

00:05:00.810 --> 00:05:03.649
And you'll see here come the formal protocols again.

00:05:03.649 --> 00:05:11.469
NSArrays can copy, they can mutably copy, they can
be encoded and it's got this base API of count

00:05:11.470 --> 00:05:15.420
and objectAtInderx which is sort of the
fundamental behavior of an NSArray.

00:05:15.420 --> 00:05:21.509
And then it's got extended behaviors for
your convenience. It's got creation behaviors

00:05:21.509 --> 00:05:24.060
that you can use to create new arrays, things like that.

00:05:24.060 --> 00:05:27.470
So you can use categories to organize your code.

00:05:28.920 --> 00:05:32.780
Or you can use categories to provide
extensible implementations.

00:05:32.779 --> 00:05:38.929
Now this gets back to we can't talk about a language
without also talking about the kit of objects.

00:05:38.930 --> 00:05:45.720
And this is behavior provided by the
foundation on NSObjects, KeyValueCoding

00:05:45.720 --> 00:05:48.060
and KeyValue|Coding extensions on NSArray.

00:05:48.060 --> 00:05:56.250
But one example of many of these kinds of things and what
this is saying is that we've got these additional methods

00:05:56.250 --> 00:06:00.769
on NSObject provided by some other provider
somewhere else, not a part of the language,

00:06:00.769 --> 00:06:05.339
not a part of NSObject itself, that
you can use throughout your code.

00:06:05.339 --> 00:06:08.179
And you're free to add your own.

00:06:08.180 --> 00:06:14.730
As well, we can use categories to
define optional or informal behaviors.

00:06:14.730 --> 00:06:19.009
One of the models you'll see throughout Objective-C,
throughout the foundation of the AppKit, Core Data,

00:06:19.009 --> 00:06:26.019
and the other kits on the operating system,
is this notion of delegates or notifications.

00:06:26.019 --> 00:06:31.689
Well, with a delegate it's kind of like, hey, that
object over there, if it implements this method,

00:06:31.689 --> 00:06:37.790
I'm going to let it know that something's happened,
say before and after like in our Car model,

00:06:37.790 --> 00:06:42.500
maybe the Car will say, oh, I've got a delegate,
I'm going to go and call the willOpenDoor

00:06:42.500 --> 00:06:47.269
and didOpenDoor methods before and after aDoor opens.

00:06:47.269 --> 00:06:52.449
This is very easy implementation for you to put
into your code, very easy behavior to implement.

00:06:52.449 --> 00:06:54.709
And it can be very powerful.

00:06:54.709 --> 00:06:58.029
It means that you can avoid subclassing in a lot of cases.

00:06:59.240 --> 00:07:03.819
So the other part of object-oriented
programming, of course, is, well, you declare a bunch

00:07:03.819 --> 00:07:07.009
of classes then you've got to talk to them.

00:07:07.009 --> 00:07:12.399
And that's dispatch, method dispatch, or
runtime dispatch of method invocations.

00:07:12.399 --> 00:07:16.849
In Objective-C, methods break down
to basically standard C functions.

00:07:16.850 --> 00:07:23.800
As a matter of fact, the original Objective-C
compiler wasn't a compiler, it was a pre-compiler.

00:07:23.800 --> 00:07:29.910
It took the Objective-C syntax and spewed C code
that was then compiled by the standard compiler.

00:07:29.910 --> 00:07:37.470
In particular, when you have a declaration
like this, replaceWheel withWheel,

00:07:37.470 --> 00:07:44.210
the method is called this, replaceWheel:withWheel:.

00:07:44.209 --> 00:07:50.250
There's no named arguments, there's no keyword
arguments, there's no type-based dispatch.

00:07:50.250 --> 00:07:56.250
Objective-C uses a very simple,
and I believe, very elegant model.

00:07:56.250 --> 00:07:59.629
And this results in a much simpler runtime.

00:07:59.629 --> 00:08:04.990
It also means your code's a lot easier to debug because you
don't have to sit there and go, okay, I've got a wheel instead

00:08:04.990 --> 00:08:09.360
of a round wheel, okay, that means
that method instead of this one.

00:08:09.360 --> 00:08:11.259
Very straightforward.

00:08:11.259 --> 00:08:18.670
So when you call the method using syntax like
this, Objective-C uses the arguments interleaved

00:08:18.670 --> 00:08:27.939
with the method name, again not keywords. This, the compiler
will turn this into a call to the objc_msgSend function

00:08:27.939 --> 00:08:36.659
or one of the other variance, and the objc_msgSend function
will look at the target, aCar,

00:08:36.659 --> 00:08:45.519
for this the C function then implements the selector,
replaceWheel:withWheel passing the arguments

00:08:45.519 --> 00:08:48.829
and when it finds that implementation, it will call it.

00:08:48.830 --> 00:08:51.680
Now this is where the dynamic runtime kicks in.

00:08:51.679 --> 00:08:54.019
Because this is what happens on every method invocation.

00:08:54.019 --> 00:08:56.889
So if you extend this class later and add a method,

00:08:56.889 --> 00:09:00.889
somewhere in the class hierarchy,
the runtime will figure it out.

00:09:00.889 --> 00:09:07.449
If you call a method that doesn't exist, you have
hooks to catch that and do what you need to do.

00:09:07.450 --> 00:09:10.570
And in Objective-C 2.0, as we'll see in a little bit,

00:09:10.570 --> 00:09:16.520
you can actually dynamically add
method implementations at runtime.

00:09:16.519 --> 00:09:22.889
So moving into Objective-C 2.0.

00:09:22.889 --> 00:09:33.399
We had some goals with Objective-C 2.0, and they were
actually focused on refinement and productivity,

00:09:33.399 --> 00:09:37.559
not focused on revolutionary changes
to your development world

00:09:37.559 --> 00:09:41.049
to achieve the next generation development environment.

00:09:41.049 --> 00:09:48.389
In particularly, we looked at the past 20 years of
Objective-C and all the patterns that people have used

00:09:48.389 --> 00:09:51.019
and the patterns that have been standardized upon.

00:09:51.019 --> 00:10:00.519
And we wanted to syntactically encapsulate those patterns
to give you the ability to write software using less code

00:10:00.519 --> 00:10:05.840
that would result in code that executes
faster and code that was more reliable.

00:10:05.840 --> 00:10:12.980
And by that I mean code that the compiler has more hints
to do the validation to give you warnings and errors

00:10:12.980 --> 00:10:18.350
that lead you to finding bugs in
your code before it's ever executed.

00:10:18.350 --> 00:10:23.360
We're going to highlight a few of the features in
Objective-C 2.0, some changes we've made to categories

00:10:23.360 --> 00:10:31.269
and protocols, fast enumeration,
garbage collection, and properties.

00:10:31.269 --> 00:10:37.509
And really in a lot of ways this is kind of in the
reverse order of the magnitude of change to the language.

00:10:40.289 --> 00:10:41.969
So categories and protocols.

00:10:41.970 --> 00:10:46.720
Well, we've seen categories and protocols
are a means of organizing your code,

00:10:46.720 --> 00:10:55.210
a means of providing informal specification,
inheriting specification, providing formal contracts.

00:10:55.210 --> 00:11:04.030
With categories, a common pattern was that you would declare
a set of API for public use throughout your application

00:11:04.029 --> 00:11:07.730
or somewhere else and then internally to
the class you'd have some private stuff

00:11:07.730 --> 00:11:11.570
that the class used that should never be used outside.

00:11:11.570 --> 00:11:17.850
And it wasn't really possible for
the compiler to validate this fully.

00:11:17.850 --> 00:11:26.840
So we changed it so that you can now have a class
extension which is just like a regular category declaration

00:11:26.840 --> 00:11:32.090
but there's no name in the parenthesis and this just
says to the compiler, hey, whatever's declared in here,

00:11:32.090 --> 00:11:36.580
treat it exactly as if it was declared
in the main @interface for the class.

00:11:36.580 --> 00:11:42.730
And thus the compiler will treat the methods
and later you'll see the properties in there

00:11:42.730 --> 00:11:46.050
as if they have to be implemented to that specification.

00:11:46.049 --> 00:11:49.019
It's not just an informal advisement.

00:11:50.309 --> 00:11:55.839
And then with protocols we've added the
ability to declare methods as being optional.

00:11:55.840 --> 00:12:04.670
Formerly protocols,every method declared in the protocol,
had to be implemented in your class to achieve conformance.

00:12:04.669 --> 00:12:07.059
This is no longer the case.

00:12:07.059 --> 00:12:13.179
So this is a protocol in the AppKit, NSPrintPanelAccessorizing
for you know accessorizing your print panels,

00:12:13.179 --> 00:12:16.909
you can put rings and earrings and beads on it.

00:12:16.909 --> 00:12:24.039
And you have an optional method here, so to conform
to this protocol you implement the first method,

00:12:24.039 --> 00:12:30.519
you can optionally provide the second method
and the compiler can validate everything.

00:12:30.519 --> 00:12:32.659
Moving on, fast enumeration.

00:12:32.659 --> 00:12:41.219
So one of the most common constructs you find
in code outside of the setters and getters

00:12:41.220 --> 00:12:43.910
and accessors which we'll get to in a moment.

00:12:43.909 --> 00:12:46.169
You've got to enumerate stuff.

00:12:46.169 --> 00:12:54.929
And the traditional enumeration pattern was using
objectEnumerator, then using nextObject and looping through.

00:12:54.929 --> 00:12:58.659
It was memory intensive because that
invocation of objectEnumerator ended

00:12:58.659 --> 00:13:04.699
up duplicating the collection being
enumerated most of the time.

00:13:04.700 --> 00:13:08.350
It was verbose, I mean there's just a lot
of lines of code here, very repetitive

00:13:08.350 --> 00:13:14.460
and, of course, anything that's repetitive--
error prone. And it was imprecise.

00:13:14.460 --> 00:13:19.269
Because you weren't really enumerating
the collection that you started with.

00:13:19.269 --> 00:13:25.039
So there could be mismatch, there
could be other bad things happen.

00:13:25.039 --> 00:13:26.329
So fast enumeration.

00:13:26.330 --> 00:13:28.170
There's not a lot to say here.

00:13:28.169 --> 00:13:44.759
It's simply a syntax for an object in a collection
that's fast, concise, efficient, and very easy to use.

00:13:44.759 --> 00:13:50.379
You can also very easily adopt fast
enumeration for your own collection classes.

00:13:50.379 --> 00:13:58.809
You simply implement this formal protocol NSFastEnumeration
which declares a single method

00:13:58.809 --> 00:14:06.309
countByEnumeratingWithState; objects; count,
whose implementation is well documented

00:14:06.309 --> 00:14:10.569
and will be covered in detail in a session later this week.

00:14:10.570 --> 00:14:16.920
So with that I would like to bring up Michael Jurewitz
to show you some hands-on with fast enumeration.

00:14:16.919 --> 00:14:18.839
>> Thanks, Bill.

00:14:18.840 --> 00:14:23.399
My name is Michael Jurewitz. I work in Developer Technical
Support, so my main job is actually to interface

00:14:23.399 --> 00:14:27.230
with developers like yourselves and help
to answer your questions on the frameworks.

00:14:27.230 --> 00:14:32.129
For today we presented some pretty neat but simple
projects to take you through Objective-C 2.0.

00:14:32.129 --> 00:14:38.220
So Bill's intro slides said you want to make sure that you
have the IntroObjC2 project downloaded from the website.

00:14:38.220 --> 00:14:41.519
So we're going to go ahead and go to that right now.

00:14:41.519 --> 00:14:44.579
So if you open that up, you'll notice
we have three projects here for you.

00:14:44.580 --> 00:14:47.620
We'll be getting to two of them later.

00:14:47.620 --> 00:14:51.200
We're going to take a look at the
fast enumeration project first.

00:14:51.200 --> 00:14:55.890
You'll also notice that we have a beginning and an end so
at any point during these changes, you lose where I'm at,

00:14:55.889 --> 00:14:59.090
know that you've got an end point
and a reference to go back to.

00:14:59.090 --> 00:15:03.009
So let's go ahead and open up the beginning project.

00:15:04.559 --> 00:15:09.989
So this is a simple application, simple
foundation tool that we call PeopleMinder.

00:15:09.990 --> 00:15:16.509
And what's happening here is we're simply taking a sample
plist that's got a bunch of information on people,

00:15:16.509 --> 00:15:20.569
their first name, their last name, and their
favorite color, and we're just going to enumerate

00:15:20.570 --> 00:15:25.070
through it, first using NSEnumerator
and then using fast enumeration.

00:15:25.070 --> 00:15:29.580
So you'll notice that our person
class is actually pretty simple.

00:15:29.580 --> 00:15:35.610
We just have strings to the first name, the last name, and
the color and we've got some pretty basic accessors too.

00:15:35.610 --> 00:15:41.129
So let's go back to PeopleMinder.m and
take a look at what's actually going on.

00:15:41.129 --> 00:15:44.490
So the first part here we're just loading
up the data, what we're really concerned

00:15:44.490 --> 00:15:48.220
about is happening in this section right here.

00:15:48.220 --> 00:15:54.580
We're going to go ahead and make ourselves an array for
people to add and we're going to take some snapshots

00:15:54.580 --> 00:15:59.500
of our start and stop time to figure out
how fast we can actually get through this.

00:15:59.500 --> 00:16:04.320
So you'll notice we're using the usual NSEnumerator
construct using the objectEnumerator

00:16:04.320 --> 00:16:07.720
and a simple while loop for getting our next object.

00:16:07.720 --> 00:16:13.779
So obviously changing the syntax isn't that difficult so Xcodes
actually built in some code refractoring just for us.

00:16:13.779 --> 00:16:18.149
So we're going to go ahead and do a
Convert to Objective-C 2.0.

00:16:18.149 --> 00:16:22.569
Make this big, we'll make sure we have the
Modernized Loops checked, and let's go ahead

00:16:22.570 --> 00:16:26.210
and take a preview and see what Xcode finds for us.

00:16:26.210 --> 00:16:29.150
So you'll notice that it found two
changes that it would like to make.

00:16:29.149 --> 00:16:32.659
And it gives us a nice div of this too.

00:16:32.659 --> 00:16:35.309
Scroll down here.

00:16:35.309 --> 00:16:39.739
So you'll see that Xcode wants to
get rid of the objectEnumerator line

00:16:39.740 --> 00:16:43.360
and change our while to for in, it really is that simple.

00:16:43.360 --> 00:16:49.000
So let's go ahead and have that done.

00:16:49.000 --> 00:16:57.110
So I'll make that change, and you'll notice
we've gone ahead and made the change here.

00:16:57.110 --> 00:17:05.819
So now, let me go ahead and quickly actually undo that just
to show you what the timing looks like using NSEnumerators.

00:17:05.819 --> 00:17:14.700
Let's go ahead and do a quick build and go and we're
going to go ahead and take a look at our console.

00:17:14.700 --> 00:17:19.009
Let me go ahead and build and go one more time.

00:17:19.009 --> 00:17:21.690
>> You've got to resize the window.

00:17:21.690 --> 00:17:23.259
Oh, sorry.

00:17:23.259 --> 00:17:24.910
>> Just resize it.

00:17:24.910 --> 00:17:26.850
There we are.

00:17:26.849 --> 00:17:27.859
There you go.

00:17:27.859 --> 00:17:28.659
>> Thank you.

00:17:28.660 --> 00:17:32.200
So you'll see we took that long to get to the loop.

00:17:32.200 --> 00:17:33.039
All right, great.

00:17:33.039 --> 00:17:36.519
So now let's go back here, we'll go ahead and do the,

00:17:36.519 --> 00:17:39.680
why don't you do this by hand this time--
this is a really easy change.

00:17:39.680 --> 00:17:51.200
Take out this line, make this for( theObject in dateArray,
save that off,

00:17:51.200 --> 00:17:55.950
let's go ahead, let's build and go again.

00:17:55.950 --> 00:18:01.269
You'll notice we have dramatically increased the
speed with which we've actually gone through this loop.

00:18:01.269 --> 00:18:05.879
Fast enumeration really is fast and
the real win is avoiding the copying.

00:18:05.880 --> 00:18:11.170
It's a really easy construct to use, it's as simple as
that, it's going to make your code a lot faster too.

00:18:11.170 --> 00:18:12.600
Bill back to you.

00:18:12.599 --> 00:18:14.129
>> Thanks, Michael.

00:18:15.799 --> 00:18:26.369
Sure. So moving on, that was fast enumeration.

00:18:26.369 --> 00:18:27.849
It's fast and it enumerates.

00:18:27.849 --> 00:18:31.899
>> You need to go back to the demo machine.

00:18:31.900 --> 00:18:34.850
>> Oh, I'm sorry, can we go back to the
demo machine for just a moment please?

00:18:34.849 --> 00:18:36.259
>> Sure.

00:18:36.259 --> 00:18:37.089
>> Thank you.

00:18:37.089 --> 00:18:39.169
>> Yeah, no problem here.

00:18:39.170 --> 00:18:44.090
Go ahead and I'll build and go here again
for you and try to get that text bigger.

00:18:48.710 --> 00:18:50.799
Let's see here.

00:18:50.799 --> 00:18:53.259
>> Command T.

00:18:53.259 --> 00:18:54.170
>> Command T.

00:18:54.170 --> 00:18:54.930
>> (inaudible)

00:18:54.930 --> 00:19:01.150
>> Yeah, he's going to make the font bigger.

00:19:03.480 --> 00:19:07.529
>> Yeah, right.

00:19:07.529 --> 00:19:09.339
>> Or maybe not.

00:19:09.339 --> 00:19:10.500
Shift command +?

00:19:10.500 --> 00:19:11.539
>> That's okay.

00:19:11.539 --> 00:19:20.889
>> So the results, zero point zero,
zero, zero, zero seven three.

00:19:20.890 --> 00:19:22.310
There we go.

00:19:23.640 --> 00:19:28.210
>> So in this case, you see this is actually
fast enumeration that took this time.

00:19:28.210 --> 00:19:33.910
But in this case we actually were roughly
thirty times faster than regular enumeration.

00:19:33.910 --> 00:19:37.140
All right.

00:19:37.140 --> 00:19:38.720
Back to you, Bill.

00:19:38.720 --> 00:19:40.039
>> Thank you.

00:19:42.910 --> 00:19:46.920
So a lot of that speed was actually the copy.

00:19:46.920 --> 00:19:53.090
So not only was there a speed boost there,
there was also a memory footprint reduction.

00:19:53.089 --> 00:19:58.099
And you could especially see that if you were,
say, enumerating a set of fairly complex stuff

00:19:58.099 --> 00:20:01.629
or enumerating a collection that has a very inefficient copy

00:20:01.630 --> 00:20:06.930
or enumerating an infinite collection
making a copy of it would be bad.

00:20:08.279 --> 00:20:10.710
So garbage collection.

00:20:12.130 --> 00:20:18.370
In Objective-C 1.0, memory management which
has been the paradigm from memory management

00:20:18.369 --> 00:20:24.500
in Objective-C since 1993, was reference counting.

00:20:24.500 --> 00:20:28.940
Retain, release, autorelease, and the "pool".

00:20:30.789 --> 00:20:32.990
These were methods on NSObject.

00:20:32.990 --> 00:20:39.410
They were not language behaviors, they were
runtime behaviors, they were object behaviors.

00:20:39.410 --> 00:20:43.440
And they were supported by the NSAutoreleasePool class.

00:20:43.440 --> 00:20:47.789
It's actually a pretty simple concept,
its just reference counting.

00:20:47.789 --> 00:20:52.980
With this added little thing that you can
delay the decrement of a reference count,

00:20:52.980 --> 00:20:55.860
until sometime later via the autorelease pool.

00:20:55.859 --> 00:21:01.449
Throw it in the pool, if something else pulls it
out, hey, it will stay alive, if not it goes away.

00:21:01.450 --> 00:21:05.900
Except for autorelease pools were per-thread
which as we've moved into this modern day

00:21:05.900 --> 00:21:12.210
and age of pretty much every Macintosh shipping
with multiple cores, threading becomes a big issue.

00:21:12.210 --> 00:21:18.250
And that perthread notion of autorelease pools,
yeah, ouch.

00:21:18.250 --> 00:21:24.890
And garbage collection, what we've done in Objective-C 2.0,

00:21:24.890 --> 00:21:31.140
is add a collector that's conservative,
so it never moves stuff around on you.

00:21:31.140 --> 00:21:34.520
Your pointers will always stay the same.

00:21:34.519 --> 00:21:42.059
It's generational which is an optimization
from the eighties, I believe, yes, the eighties.

00:21:42.059 --> 00:21:49.379
That basically means that it scans a limited sumset of the
objects based on how long the objects have been in existence

00:21:49.380 --> 00:21:56.520
because in general short-lived objects are common, longer-
lived objects tend to stay around for quite a long time.

00:21:56.519 --> 00:21:59.930
And it's concurrent, which means
it's running on its own thread,

00:21:59.930 --> 00:22:06.799
it doesn't block the other threads,
and it's a very efficient collector.

00:22:08.670 --> 00:22:16.130
It's also an opt-in contract which means you
can choose whether or not you want to use GC.

00:22:16.130 --> 00:22:20.510
It's all or none, though, meaning that if
you choose to use GC in an application,

00:22:20.509 --> 00:22:25.000
everything in that app needs to be GC or not.

00:22:25.000 --> 00:22:28.579
However, you can write dual mode
code which means you can continue

00:22:28.579 --> 00:22:32.889
to write the retain/release/autorelease
code and still use it under GC.

00:22:32.890 --> 00:22:39.430
This is exactly what we've done for all of
Mac OS X, so you don't have separate copies

00:22:39.430 --> 00:22:43.880
of the framework binaries for GC versus non-GC.

00:22:43.880 --> 00:22:52.170
Not necessarily the path we're recommending.
Veing able to choose GC only is very liberating,

00:22:53.839 --> 00:23:00.119
and one of the added benefits of garbage collection
is that it simplifies threaded programming

00:23:00.119 --> 00:23:08.089
The reason why is because now object life span
is below the behavior of the objects themselves.

00:23:08.089 --> 00:23:11.970
Object life span is largely governed by assignments.

00:23:11.970 --> 00:23:19.490
Assignments are atomic so when you say my
stack ivar equals some random object,

00:23:19.490 --> 00:23:22.900
that's a reference, it's going to keep that object alive.

00:23:22.900 --> 00:23:27.970
You don't have the race conditions associated with
multiple method calls to try to put things in a pool,

00:23:27.970 --> 00:23:30.150
pull them out, retain, release, all that.

00:23:30.150 --> 00:23:34.340
Or the exception handling that's required therein.

00:23:34.339 --> 00:23:41.019
So when you're writing the dual mode code
what basically happens is the retain,

00:23:41.019 --> 00:23:44.220
release, and auto release are ignored.

00:23:44.220 --> 00:23:49.019
Literally they are rewritten to become effectively no ops.

00:23:49.019 --> 00:23:53.309
The one exceptions is the -drain
method on NSAutoreleasePool.

00:23:53.309 --> 00:23:55.669
It's kind of a hint to the collector.

00:23:55.670 --> 00:24:01.700
It says, hey, you're back in the non-GC world, developer
thought right about now is a good time to get rid of a bunch

00:24:01.700 --> 00:24:06.950
of temporary objects so the collector uses that as a hint.

00:24:06.950 --> 00:24:13.559
There's also what are called zeroing weak references, which
means that you can have a strong reference to an object,

00:24:13.559 --> 00:24:18.519
which is ownership, it will keep that object
alive, the collector won't collect as long

00:24:18.519 --> 00:24:25.930
as the strong reference exists, or he can say, this
reference is weak but unlike in the non-GC case

00:24:25.930 --> 00:24:31.390
where when you release an object for the last time,
all references to it become dangling pointers,

00:24:31.390 --> 00:24:39.740
the collector will actually sweep back through and
zero out any of the weak references to that object.

00:24:39.740 --> 00:24:41.430
( Applause )

00:24:41.430 --> 00:24:43.700
>> Yeah. It's really cool.

00:24:44.950 --> 00:24:48.130
In particular, it means that you don't
have to worry about removing observers

00:24:48.130 --> 00:24:50.430
from NotificationCenters on object death.

00:24:50.430 --> 00:24:54.400
( Applause )

00:24:54.400 --> 00:24:58.030
>> There are new collection classes provided
in the foundation that have been optimized

00:24:58.029 --> 00:25:04.899
for garbage collection, so mapping and hashing collections.

00:25:05.940 --> 00:25:17.509
They work in non-GC as well, and like I said, no need to
unregister these observers, I can't tell you the number

00:25:17.509 --> 00:25:21.980
of times I've seen things crash in NSNotificationCenter
post notification.

00:25:21.980 --> 00:25:24.799
It goes away now.

00:25:26.299 --> 00:25:31.119
You do have to optimize for a little bit
different model of memory management.

00:25:31.119 --> 00:25:36.589
Whereas before you had the retain, release, auto release
and you had really tight control over object life spans

00:25:36.589 --> 00:25:42.720
and memory bloat could often be fixed by adding
an autorelease pool in a loop somewhere.

00:25:42.720 --> 00:25:46.269
With the collector it's a little different.

00:25:46.269 --> 00:25:48.019
You're caches will behave a little bit differently.

00:25:48.019 --> 00:25:53.139
You can take advantage of those weak
references to make caches self cleaning.

00:25:53.140 --> 00:25:58.310
You can, you want to sometimes
avoid lots and lots of allocations

00:25:58.309 --> 00:26:01.149
of small objects reuse in some cases, things like that.

00:26:01.150 --> 00:26:04.420
But it's all just an optimization exercise.

00:26:04.420 --> 00:26:07.029
One of the nice things about GC is
that when you're working with GC

00:26:07.029 --> 00:26:14.079
and debugging GC you don't generally have dangling
pointers to dead objects so when you're inspecting things

00:26:14.079 --> 00:26:18.460
in GDB you're actually talking to a viable
object and generally trying to figure

00:26:18.460 --> 00:26:22.279
out why the heck it's sticking
around when it shouldn't be anymore.

00:26:22.279 --> 00:26:26.450
And there will be lots and lots
of information on the collector.

00:26:26.450 --> 00:26:32.590
It's an amazing piece of technology and I encourage
you to go to the session later on in the week.

00:26:32.589 --> 00:26:38.069
So with that, Michael, would you
like to show some hands-on with GC?

00:26:38.069 --> 00:26:38.899
>> All right.

00:26:38.900 --> 00:26:40.250
Thanks, Bill.

00:26:40.250 --> 00:26:43.779
Okay, we'll be turning to the Garbage Collection project now.

00:26:43.779 --> 00:26:49.089
So go ahead and go to our Beginning
project and open that up.

00:26:49.089 --> 00:26:53.059
You'll notice that this has changed a little
bit, we've actually got a full-fledged

00:26:53.059 --> 00:26:55.389
GUI application we're using at this point.

00:26:55.390 --> 00:26:57.259
So I'm just going to build and run.

00:26:57.259 --> 00:27:01.099
And you can take a look at it.

00:27:01.099 --> 00:27:06.439
So a really simple user interface for application, we've got
a list of people, we've got their colors, we can go ahead

00:27:06.440 --> 00:27:13.110
and go through these. We can use the Inspector
here to change the color that we have listed.

00:27:13.109 --> 00:27:15.869
Really simple application.

00:27:15.869 --> 00:27:19.429
So now let's go ahead and let's introduce
garbage collection this application.

00:27:19.430 --> 00:27:21.920
So what do you have to do in your project to do that?

00:27:21.920 --> 00:27:28.610
Well, you simply need to go to Edit Project Settings
under the Project menu, go to the Build tab,

00:27:28.609 --> 00:27:35.929
and then we want to make sure that we click
on Enable Objective-C Garbage Collection.

00:27:35.930 --> 00:27:36.420
And there you go.

00:27:36.420 --> 00:27:41.550
When you compile the collector at
runtime is going to be working for you.

00:27:41.549 --> 00:27:52.529
Now as Bill mentioned, retain, release, and autorelease
all are basically no ops under garbage collection.

00:27:52.529 --> 00:27:58.160
So you'll see at several points here we've got releases,
we're doing memory management, we can actually go ahead

00:27:58.160 --> 00:28:04.900
and still build and run this application and the
application is still going to behave just as it did before.

00:28:04.900 --> 00:28:08.300
So again, just like you saw.

00:28:08.299 --> 00:28:13.089
But one of the great wins about garbage collection
is the amount of code that you can actually tear out

00:28:13.089 --> 00:28:16.899
and that you don't need anymore since
you're not dealing with reference counting.

00:28:16.900 --> 00:28:23.269
So let's go ahead and we'll start in the AppController
here and take a look at what we can tear out.

00:28:23.269 --> 00:28:27.509
So you'll notice first of all, we
make a newPeople array for iterating

00:28:27.509 --> 00:28:30.160
through our collection and storing people into it.

00:28:30.160 --> 00:28:34.910
And then this, we're actually allocating
newPeople objects and adding them to that array.

00:28:34.910 --> 00:28:39.130
So one of the first things that we have to make sure we
do since we alloc and inited this person is

00:28:39.130 --> 00:28:41.700
to release it after we add it to the collection.

00:28:41.700 --> 00:28:45.380
It's a pretty common error to add something
to collection and forget to release it.

00:28:45.380 --> 00:28:47.750
I know that I've done that before,
I'm sure all of you have too.

00:28:47.750 --> 00:28:50.599
But that line can simply go away.

00:28:50.599 --> 00:28:52.799
So go ahead and take that out.

00:28:52.799 --> 00:28:58.539
And now also with our newPeople array after we go ahead
and set that as the array of people we want to use we had

00:28:58.539 --> 00:29:02.779
to remember, oh, that's right, we're retaining that
as the app controller so we need to release it

00:29:02.779 --> 00:29:07.250
since we alloc and inited it above here.

00:29:07.250 --> 00:29:10.819
We can go ahead and take out this line as well.

00:29:11.859 --> 00:29:13.279
Pretty nice.

00:29:13.279 --> 00:29:18.329
Now with the accessors here, I'm sure all of you have
been making sure to use the retain autorelease pattern

00:29:18.329 --> 00:29:22.789
in your code, of course, so one of the
nice things about garbage collection is

00:29:22.789 --> 00:29:27.159
that since we can guarantee atomicity we don't need
to jump through these hoops with our accessors.

00:29:27.160 --> 00:29:30.860
We can go ahead and just return
the instance very well directly.

00:29:30.859 --> 00:29:35.490
So we can get rid of this and just return people instead.

00:29:35.490 --> 00:29:43.460
Similarly we'll go ahead and tear out this code here where
we were releasing our old person, assigning a new value

00:29:43.460 --> 00:29:50.470
and we'll go ahead and have this be people
is equal to a copy of the newPeople.

00:29:50.470 --> 00:29:55.970
In this case we're preserving our copy
just to maintain object encapsulation.

00:29:55.970 --> 00:29:57.660
So we can go ahead and save that.

00:29:57.660 --> 00:30:01.120
Now you notice we've actually made
a small error in this project.

00:30:01.119 --> 00:30:04.609
I've been coding in with garbage
collection now for months and months,

00:30:04.609 --> 00:30:07.579
you'll notice we don't have a dealloc
method on our app controller.

00:30:07.579 --> 00:30:09.869
Purely a mistake but again it's one of those things

00:30:09.869 --> 00:30:13.949
that once you adopt garbage collection
you don't need to have in your code.

00:30:13.950 --> 00:30:15.430
We'll see that in the person class.

00:30:15.430 --> 00:30:17.350
Let's go ahead and go there.

00:30:19.099 --> 00:30:26.449
You'll see pretty simple what's going on here as
far as dealing with a few string instance variables

00:30:26.450 --> 00:30:31.940
and in this case we're actually using an
NS Color for our favorite color this time.

00:30:31.940 --> 00:30:38.580
So as we saw before in the app controller, let's go
ahead and take a lot of this stuff and we can go ahead

00:30:38.579 --> 00:30:43.629
and just tear it out, and replace it
with some much more readable code.

00:30:43.630 --> 00:30:49.970
So we're going to go ahead and replace our firstName
accessors with much more simple variant.

00:30:49.970 --> 00:31:00.069
Same thing with our lastName accessors,
again deleting the extra code here.

00:31:00.069 --> 00:31:07.649
And for our favoriteColor we can do the exact same thing.

00:31:07.650 --> 00:31:12.290
Our instance variable here is named color of
course so that's why we've got the name difference.

00:31:12.289 --> 00:31:16.839
Now it's interesting to note that NS Color is immutable
so that's actually why we're not making a copy of it,

00:31:16.839 --> 00:31:20.149
we can just go ahead and do direct assignment.

00:31:20.150 --> 00:31:22.670
But again down here in dealloc
we're doing all this memory management

00:31:22.670 --> 00:31:26.970
where when we no longer need the objects we're having
to clean up everything that we've had a reference to.

00:31:26.970 --> 00:31:32.670
Well, under garbage collection we can just get rid of that.

00:31:32.670 --> 00:31:40.440
So now you notice we've got a much, much
more simple person file to deal with.

00:31:40.440 --> 00:31:43.480
So let's go ahead and save this.

00:31:43.480 --> 00:31:45.480
We'll build and run.

00:31:45.480 --> 00:31:54.599
You'll see the application works just as before, no
problems, no memory management that we have to do manually.

00:31:54.599 --> 00:31:58.359
Bill, back to you.

00:32:00.380 --> 00:32:02.300
>> Thanks, Michael.

00:32:02.299 --> 00:32:03.819
( Applause )

00:32:03.819 --> 00:32:04.720
>> Moving on.

00:32:04.720 --> 00:32:07.150
Properties.

00:32:07.150 --> 00:32:10.890
Properties were kind of quite a bit of discussion.

00:32:10.890 --> 00:32:14.560
We changed properties on you since last WWDC by the way.

00:32:14.559 --> 00:32:19.329
Sorry about the change but I think you'll like it better.

00:32:19.329 --> 00:32:26.099
So in Objective-C, as you saw with the code Michael
was working with there, setters, getters everywhere.

00:32:26.099 --> 00:32:31.819
I mean in Objective-C you have this standard
pattern of setters and getters that are used

00:32:31.819 --> 00:32:33.839
to set the state and get the state from objects.

00:32:33.839 --> 00:32:37.579
And when you see it throughout model ops, you
see it throughout the view classes for setting

00:32:37.579 --> 00:32:40.129
up different parameters for visualization.

00:32:40.130 --> 00:32:45.980
Core Animation is pretty much all setters and
getters for setting up the animation parameters.

00:32:45.980 --> 00:32:48.160
Very common pattern.

00:32:48.160 --> 00:32:53.190
And again you'll also see it that a lot of
times you'll have a read-only parameter.

00:32:53.190 --> 00:32:57.710
See publicly it can only be read like the speed method here

00:32:57.710 --> 00:33:06.150
but privately there's probably a setSpeed method
declared in one of those categories again there.

00:33:06.150 --> 00:33:11.490
Informal category that the compiler
can't validate so we'll fix that too.

00:33:11.490 --> 00:33:19.789
So when you start getting into more complex classes, this
is not intended to be readable, this is just the reality

00:33:19.789 --> 00:33:26.589
of the situation you end up with large class files
with lots of stuff in them that's kind of noisy.

00:33:26.589 --> 00:33:29.849
And this is a common pattern.

00:33:29.849 --> 00:33:33.639
Pretty much every class has some amount of these.

00:33:33.640 --> 00:33:39.900
So really properties are all about encapsulating
this stuff, properties are about simplifying it.

00:33:39.900 --> 00:33:45.240
We look at the setters and getters, they're everywhere,
they are a foundation of the classes you design.

00:33:45.240 --> 00:33:51.349
They do already work, you know they're used
everywhere for data storage, configuration, data flow,

00:33:51.349 --> 00:33:57.659
and by data flow I mean not just setting and getting
stuff but you see key value coding and key value observing

00:33:57.660 --> 00:34:03.220
and Cocoa bindings, all are built on
top of the setter getter foundation.

00:34:04.289 --> 00:34:06.190
Why are we fixing them?

00:34:06.190 --> 00:34:12.690
Well, they're also one of the largest points
of frustration, largest points of failure,

00:34:12.690 --> 00:34:15.099
because they're so tedious, they're very repetitive.

00:34:15.099 --> 00:34:18.549
Change one and you've got to change
the method in a couple places.

00:34:18.550 --> 00:34:22.269
You know, you change the contract
for storage, you've got to change it

00:34:22.269 --> 00:34:27.289
in several places, it's just, it's easy to get wrong.

00:34:27.289 --> 00:34:33.659
And concurrency, threading, greatly
complicates the implementation.

00:34:33.659 --> 00:34:39.869
Earlier when Michael showed the code that was
doing a retain autorelease to return an object,

00:34:39.869 --> 00:34:45.049
some are under the mistaken impression
that that is thread safety, that's not.

00:34:45.050 --> 00:34:46.330
That's an object level behavior.

00:34:46.329 --> 00:34:52.309
If to make that setter get her pair thread safe, you
need to make it really ugly, you need to add locking,

00:34:52.309 --> 00:34:57.949
you need to add exception handling, you need to have
an external mechanism for initializing the locks.

00:34:57.949 --> 00:35:04.989
It can get very complex very quickly, all
adding to the error-prone nature of it.

00:35:04.989 --> 00:35:12.379
So if we had these setters getters everywhere,
and we want to fix them, how about this instead?

00:35:12.380 --> 00:35:20.940
We've added in properties, this @property
notation, so this and this are equivalent.

00:35:20.940 --> 00:35:28.389
But this is a lot more, I would say,
evocative, precise in terms of the contract,

00:35:28.389 --> 00:35:34.960
It's the syntax that declares not only the
presence of this data accessor's pair,

00:35:34.960 --> 00:35:38.000
but the semantics of how the data is managed.

00:35:38.000 --> 00:35:44.590
And you can see we also converted the private interface
to no longer be a named category but actually one

00:35:44.590 --> 00:35:48.780
of the extensions to the class so the
compiler can validate it properly.

00:35:48.780 --> 00:35:55.010
And you actually see here we're also adding readwrite
to the property so we're actually extending the behavior

00:35:55.010 --> 00:35:59.240
of the property internally, we'll get to that in a second.

00:35:59.239 --> 00:36:05.779
So what this means is that when you have a more complex
class like this we can reduce this code down to this,

00:36:05.780 --> 00:36:12.240
which is great for Keynote because now you can read it.

00:36:12.239 --> 00:36:19.709
So properties, they are a simple syntax
that has very powerful consequences.

00:36:19.710 --> 00:36:24.380
They are highly configurable, they just
work out of the box but you have a lot

00:36:24.380 --> 00:36:27.260
of control over the configuration of them.

00:36:27.260 --> 00:36:33.700
They can be automatic for convenience, which we'll
show in a second, however, you can manually implement

00:36:33.699 --> 00:36:37.399
for very tight control in the cases where you need it.

00:36:37.400 --> 00:36:39.820
Or they can be fully dynamic.

00:36:41.079 --> 00:36:47.650
And by using properties you are
automatically achieving compliance

00:36:47.650 --> 00:36:52.130
with what is necessary to fit into that Cocoa foundation.

00:36:52.130 --> 00:36:58.180
To provide a foundation on top of which very rich
Cocoa application can be naturally developed.

00:36:58.179 --> 00:37:01.299
In particular they are compliant with key value coding.

00:37:01.300 --> 00:37:06.269
Compliant with key value observation.
Core Data uses properties extensively

00:37:06.269 --> 00:37:10.409
in Core Data 2.0 with the NSManagedObject.

00:37:10.409 --> 00:37:17.250
Bindings which is implemented on
top of KVC and KVO uses properties.

00:37:18.800 --> 00:37:24.910
When we look at the properties implementation or
the properties feature itself, there's two pieces,

00:37:24.909 --> 00:37:30.690
there's the interface, the declaration piece,
and there's the implementation piece.

00:37:30.690 --> 00:37:36.970
So looking at the interface of the declaration
first, the syntax is simply @property, some list

00:37:36.969 --> 00:37:42.750
of attributes, a type, and the variable name.

00:37:42.750 --> 00:37:51.809
The attributes control the storage semantics, in particular,
the attribute readonly/readwrite. You can use one

00:37:51.809 --> 00:37:58.529
or the other, controls whether or not that
property will be readonly or readwrite.

00:37:58.530 --> 00:38:04.700
Whether or not the property implies,
in this case, that both speed

00:38:04.699 --> 00:38:10.469
and setSpeed, the methods, will be available
or if just speed will be available.

00:38:10.469 --> 00:38:18.049
Readwrite is one of the few attributes that you
can override in subclasses or in class extensions.

00:38:18.050 --> 00:38:22.590
So you can publicly declare that a property is readonly

00:38:22.590 --> 00:38:29.130
and then without writing any code you can redeclare
it internally to your class to be readwrite.

00:38:29.130 --> 00:38:35.329
Assign, retain, copy, these are the
memory management behavior controls

00:38:35.329 --> 00:38:39.630
so in this case, we have a passenger's property.

00:38:39.630 --> 00:38:45.460
It's of type NSArray by providing the copy attribute.

00:38:45.460 --> 00:38:49.889
That will be copied when it is assigned.

00:38:49.889 --> 00:38:56.460
Now the difference between assigned and
retained is a GC versus non-GC issue.

00:38:56.460 --> 00:39:03.380
Retain is a strong reference in non-GC, it's a
retained reference, and a strong reference in GC.

00:39:03.380 --> 00:39:08.250
Assign is a weak reference in non-
GC, meaning it's just an assignment.

00:39:08.250 --> 00:39:14.380
But a strong reference in GC and that kind of gets back to
the delegate pattern in the AppKit, and I'm not going to go

00:39:14.380 --> 00:39:24.289
into detail on it, this is something you can find out a
lot more information in the Advanced Objective-C session.

00:39:24.289 --> 00:39:32.349
So there is a non-atomic attribute and what that means
is that when we automatically create implementations

00:39:32.349 --> 00:39:37.719
of the methods for you, which you'll see in
a second, the implementation will not try

00:39:37.719 --> 00:39:41.279
to be safe under concurrent environments.

00:39:41.280 --> 00:39:46.130
Now safe under concurrency means not necessarily
thread safety, it means that when you call it

00:39:46.130 --> 00:39:51.090
from a multithreaded environment, being atomic
means that you'll always get a value back

00:39:51.090 --> 00:39:54.579
that at least doesn't cause your program
to crash, you're not going to get

00:39:54.579 --> 00:39:58.279
like a released object or something like that.

00:39:58.280 --> 00:40:02.030
You can't do thread safety at this level of an API.

00:40:02.030 --> 00:40:03.370
You just can't.

00:40:03.369 --> 00:40:07.529
So this is about consistency of values returned.

00:40:07.530 --> 00:40:11.480
Nonatomic is much more efficient under non-GC.

00:40:11.480 --> 00:40:16.840
Under GC, everything's atomic for
free except for structures.

00:40:16.840 --> 00:40:21.340
This gets back to GC adds a lot of
efficiency to your applications.

00:40:21.340 --> 00:40:31.630
So moving on, setter equals, getter equals,
sometimes if you have a property name, say, goingFast,

00:40:31.630 --> 00:40:36.099
you don't want to have a couple methods
named goingFast and setgoingFast.

00:40:36.099 --> 00:40:43.579
You may want the query method, the getter, to be
isGoingFast, and setter equals and getter equals allows

00:40:43.579 --> 00:40:49.389
you to supply the method name or the selector that should
be generated or used by the property subsystem.

00:40:49.389 --> 00:40:55.969
So as you can see, that gives you a lot
of control over how property is declared.

00:40:55.969 --> 00:41:03.859
Now on the implementation side,
there's a new keyword @synthesize.

00:41:03.860 --> 00:41:08.420
Say @synthesize property name
in your @implementation block.

00:41:08.420 --> 00:41:16.960
And it will synthesize the methods necessary to fulfill the
contract that was declared with the @property declaration.

00:41:16.960 --> 00:41:24.070
So if you just say @synthesize goingFast,
and it was a straight property declaration,

00:41:24.070 --> 00:41:29.870
you're going to get goingFast and setgoingFast
as two method implementations that will work just

00:41:29.869 --> 00:41:34.059
like they were declared and implemented by you.

00:41:34.059 --> 00:41:38.489
You can also, say, that the method
implementation should be synthesized

00:41:38.489 --> 00:41:43.539
to use an instance variable other
than the same name as the property.

00:41:43.539 --> 00:41:53.690
Because of the way the 32-bit runtime works, or what
we call the, I guess, antique Objective-C runtime works,

00:41:53.690 --> 00:42:01.440
you have to actually declare an instance variable
as storage for a property when using @synthesize.

00:42:01.440 --> 00:42:09.150
In the 64-bit runtime or the new runtime, the 2.0 runtime,
that's not the case and again you can see more details

00:42:09.150 --> 00:42:12.740
on that in the Advanced Objective-C session.

00:42:12.739 --> 00:42:17.629
So anyway getting back to this, you can synthesize
a property that uses a preexisting instance variable

00:42:17.630 --> 00:42:26.490
of a different name or you can say @dynamic property,
and what that tells the compiler is to not complain

00:42:26.489 --> 00:42:32.189
when it doesn't find the implementations of the
methods that the property declaration implies.

00:42:32.190 --> 00:42:36.240
Because you're going to take care
of bringing those into being later.

00:42:36.239 --> 00:42:42.069
Maybe you'll dynamically provide them at runtime,
maybe you'll load a bundle that has them, I don't know.

00:42:42.070 --> 00:42:44.550
And then finally you can just implement
the methods yourself.

00:42:44.550 --> 00:42:49.810
You can implement set speed and, you know, speed directly.

00:42:49.809 --> 00:42:57.380
We've also added one additional bit of syntax
for making property use much more convenient.

00:42:57.380 --> 00:43:01.280
So say we had @property speed.

00:43:01.280 --> 00:43:07.620
You could call aCar speed using the normal
Objective-C method syntax and it would work just fine.

00:43:07.619 --> 00:43:13.650
However, we have overloaded for the
first time one piece of C syntax,

00:43:13.650 --> 00:43:22.300
the . to allow property access and
actually any method that fits the pattern.

00:43:22.300 --> 00:43:26.830
So that you can say aCar.speed.

00:43:26.829 --> 00:43:30.759
And that is effectively equivalent
to calling the speed method.

00:43:30.760 --> 00:43:34.930
There's some little more subtlety there,
again, the Advanced session covers that.

00:43:34.929 --> 00:43:40.109
Or you can use this for assignment,
aCar.speed = 87 which is more

00:43:40.110 --> 00:43:46.390
or less equivalent to aCar setSpeed:87.

00:43:46.389 --> 00:43:51.049
So, Michael, hands-on properties.

00:43:51.050 --> 00:43:56.390
This is one of the more exciting additions
simply because of the reduction in code.

00:43:56.389 --> 00:43:58.039
>> That's right, you stole my line.

00:43:58.039 --> 00:44:02.420
But, yes, no, properties are, properties really are excellent
for how they're going to change your development.

00:44:02.420 --> 00:44:05.010
So let's go ahead and dive right in and have a look at that.

00:44:05.010 --> 00:44:12.180
So open up our properties project, go to
our Beginning project, and take a peek.

00:44:12.179 --> 00:44:17.750
This is, actually, the exact same application we
had at the end of the garbage collection section.

00:44:17.750 --> 00:44:19.539
We just copied it pretty much right over.

00:44:19.539 --> 00:44:22.210
If you go ahead and look we've made a few little changes

00:44:22.210 --> 00:44:28.429
to how we've actually done a few
things just for readability's sake.

00:44:28.429 --> 00:44:31.049
One of the nice things about garbage
collection is that in something

00:44:31.050 --> 00:44:35.019
like your init method you
could just say NSArray array,

00:44:35.019 --> 00:44:37.219
keeps you from having to say alloc init,
a little more readable.

00:44:37.219 --> 00:44:39.169
I like that style a lot better.

00:44:39.170 --> 00:44:41.769
We're here to focus on properties right now.

00:44:41.769 --> 00:44:47.960
So let's take a look at AppController.h. And notice
we've got our people that we've been holding on to, as well

00:44:47.960 --> 00:44:50.519
as a couple accessors for dealing with them.

00:44:50.519 --> 00:44:55.059
So let's go ahead, and first things first, get rid of those.

00:44:55.059 --> 00:45:02.519
And let's add a property declaration for the people array,
so we'll say @ property, we want this to be readwrite.

00:45:02.519 --> 00:45:08.409
You want to make sure that we're making a copy
of it when we go ahead and get a new value.

00:45:08.409 --> 00:45:12.519
It's an NSArray, and we're calling it "people;.

00:45:12.519 --> 00:45:14.139
Simple as that.

00:45:14.139 --> 00:45:19.379
So now let's go to the App Controller,
let's go down to our accessors here,

00:45:19.380 --> 00:45:22.750
and you can see we're just doing some pretty
vanilla stuff here, we're returning a value,

00:45:22.750 --> 00:45:27.639
we're making a copy when we get it, so properties
are going to go ahead and provide this for us.

00:45:27.639 --> 00:45:33.319
So let's go ahead and get rid of this repetitive
code and take it out of our implementation.

00:45:33.320 --> 00:45:38.269
And we need to make sure that we actually
synthesize values for these properties

00:45:38.269 --> 00:45:42.509
so we're going to say, @synthesize people.

00:45:42.510 --> 00:45:52.570
That's all we had to do to tell the compiler
that we want it to generate these methods for us,

00:45:52.570 --> 00:45:56.210
have the runtime generate these methods for us at runtime.

00:45:56.210 --> 00:45:59.710
So now some nice little syntactic changes we can make here.

00:45:59.710 --> 00:46:02.280
Down here we say self setPeople:newPeople.

00:46:02.280 --> 00:46:06.440
As Bill discussed that's still going to work
for us, we can leave that code exactly as it is,

00:46:06.440 --> 00:46:15.849
but one of the nice changes you can make is we can take this
line and we can make this self.people = newPeople;.

00:46:15.849 --> 00:46:23.440
Now one of the important things to note about
using this syntax, it's tempting to think of this

00:46:23.440 --> 00:46:28.490
as direct ivar access, this is actually just
a synonym for going through a message sent,

00:46:28.489 --> 00:46:31.419
this is actually a message that's being sent at this point.

00:46:31.420 --> 00:46:35.820
So we're actually going through the
setPeople method in order to use this.

00:46:35.820 --> 00:46:39.650
But again one of the nice changes we
can make as a result of properties.

00:46:39.650 --> 00:46:45.070
The real win though happens, and I think you'll
see this more often than not, in your model classes.

00:46:45.070 --> 00:46:48.920
So in this case, again, we had our person, we
had a first name, a last name, and a color.

00:46:48.920 --> 00:46:52.889
Remember this is a pretty basic class
as far as things go, so really not

00:46:52.889 --> 00:46:55.449
that many accessors or instance variables happening here.

00:46:55.449 --> 00:47:02.829
So let's go ahead and rip out these accessors because
we're not going to need to write these manually anymore.

00:47:02.829 --> 00:47:10.150
So we're going to say @property
readwrite, copy) for NSStrings.

00:47:10.150 --> 00:47:12.410
We want to make sure we're making a
copy of the string that gets passed in.

00:47:12.409 --> 00:47:18.569
In this case, we want firstName and we want lastName.

00:47:18.570 --> 00:47:25.710
Now we also want to make sure we have a property for our
color so we're going to make sure that this is readwrite,

00:47:25.710 --> 00:47:33.829
we're going to make this assign, remember again, we're
operating under garbage collection as is NSColor.

00:47:33.829 --> 00:47:42.049
In this case remember our API will refer to this as
favoriteColor so that's what we're going to put here.

00:47:42.050 --> 00:47:48.720
So we'll go ahead and save that
and go to our Person.m file.

00:47:48.719 --> 00:47:54.649
Now first things first, let's go ahead and
synthesize these things right up front.

00:47:54.650 --> 00:48:04.090
So we'll synthesize, in this case we add firstName
and lastName and we also had our favoriteColor

00:48:04.090 --> 00:48:06.789
but remember our instance variable is named color.

00:48:06.789 --> 00:48:11.829
So we want to make sure we tell the compiler about that.

00:48:12.909 --> 00:48:21.759
So now down below we've got all these accessors that
again are just doing the basic set of tasks for us.

00:48:21.760 --> 00:48:26.400
So we can take all this code and just rip that right out.

00:48:26.400 --> 00:48:32.820
You see we've already dramatically simplified your
implementation, made things a lot easier to follow,

00:48:32.820 --> 00:48:35.960
and again, here we can actually
make some changes if you wanted to,

00:48:35.960 --> 00:48:43.539
to the init method where you could actually say
self dot, self.firstName = first,

00:48:43.539 --> 00:48:49.059
we don't need to do the copy here because we
know that the property is doing a copy for us.

00:48:49.059 --> 00:48:54.029
And the same thing with lastName.

00:48:54.030 --> 00:49:01.690
Now here we can do the same thing for color and we have
to make sure we remember that we called it favoriteColor.

00:49:01.690 --> 00:49:12.010
So let's go ahead and build and run, and you'll see
the application still works exactly as it did before.

00:49:12.010 --> 00:49:17.500
In this case we've been able to tear out
a ton of code. But let's think about this.

00:49:17.500 --> 00:49:21.500
This isn't necessarily realistic, there's great reasons
to have accessors a lot of the time. You actually need

00:49:21.500 --> 00:49:26.940
to do some complicated things and your
accessors set off other behavior, etc.

00:49:26.940 --> 00:49:33.159
So let's go ahead and let's put one of these accessors back
in, so let's go ahead and let's do the setFavoriteColor.

00:49:34.349 --> 00:49:44.000
So we'll say setFavoriteColor, and we're going to be
taking in an NSColor, and just as before we're going

00:49:44.000 --> 00:49:52.000
to do a simple check to make sure that we've actually got
a new value, at least as far as pointers are concerned.

00:49:52.000 --> 00:50:01.369
And here we're just going to say color =
newColor, and then we'll just do a simple NSLog

00:50:01.369 --> 00:50:07.289
to see that we've actually got a new value.

00:50:07.289 --> 00:50:14.849
So we'll say the color has changed, and we'll
make sure that we log out the newColor.

00:50:14.849 --> 00:50:19.659
All right, so let's save that, we'll build and go,

00:50:19.659 --> 00:50:23.000
if I bring up the console here I
promise I won't make you try to read it.

00:50:23.000 --> 00:50:25.480
You can just see that there's text.

00:50:25.480 --> 00:50:31.650
And we see if we go ahead and try to change this value
that we're going through our setter automatically.

00:50:31.650 --> 00:50:36.920
Meanwhile, we've dramatically reduced the amount of
code we had to write, made our project much easier

00:50:36.920 --> 00:50:39.659
to navigate in the future, and more maintainable.

00:50:39.659 --> 00:50:41.369
All right, Bill, back to you.

00:50:41.369 --> 00:50:46.449
>> Could you leave the code up for just a second, please?

00:50:46.449 --> 00:50:48.609
Heather, go back to the code, please?

00:50:48.610 --> 00:50:49.510
Thank you.

00:50:49.510 --> 00:50:55.030
So not only do you see a reduction of code,
there's one other thing I want to point here,.

00:50:55.030 --> 00:50:59.019
We reduced repetition, we reduced fragility.

00:50:59.019 --> 00:51:05.179
If you noticed before when there was the setter of the
firstName and the lastName directly to the instance variable,

00:51:05.179 --> 00:51:11.210
in the init method on here, it
was calling firstName copy there,

00:51:11.210 --> 00:51:14.699
as well as then having to reimplement
it in the accessor method.

00:51:14.699 --> 00:51:19.589
But now with this code we've actually reduced one of the
calls to copy so if you wanted to change the semantics

00:51:19.590 --> 00:51:24.970
of how the firstName and lastName are managed so
that they're no longer copy, there's exactly one place

00:51:24.969 --> 00:51:28.679
to change it now and no places to forget to change it.

00:51:28.679 --> 00:51:30.769
And that's about reliability.

00:51:30.769 --> 00:51:36.170
Another aspect of this is that we're never boxing stuff.

00:51:36.170 --> 00:51:41.250
With key value coding, key value coding is
intended to be a bit of a higher level thing.

00:51:41.250 --> 00:51:46.719
And it does boxing which means that when you're passing
numbers through it, it's sticking them in NSValues.

00:51:46.719 --> 00:51:50.469
And that's very appropriate and the
correct behavior for that level.

00:51:50.469 --> 00:51:56.119
When you called key value coding directly, which was a
convenient thing to do when looping through, say, a set

00:51:56.119 --> 00:52:01.739
of keys or something like that, setting up values, and
you said, you know, take value for key you commonly had

00:52:01.739 --> 00:52:05.319
to put an integer or Boolean into an NSNumber.

00:52:05.320 --> 00:52:07.330
With properties you don't have to do that.

00:52:07.329 --> 00:52:11.960
It can handle the scalar C types and structures just fine.

00:52:11.960 --> 00:52:16.500
That has two advantages beyond the efficiency,
well, one advantage beyond the efficiency.

00:52:16.500 --> 00:52:22.250
It means the compiler has the type information such that
if you do a type mismatch or you do a type quer--

00:52:22.250 --> 00:52:27.170
or conversion that's lossy,
the compiler can tell you about it.

00:52:27.170 --> 00:52:30.019
And that gets back to doing more reliable code.

00:52:30.019 --> 00:52:36.400
So not only have we seen a vast reduction in code, the
compiler can now tell you a lot more about the quality

00:52:36.400 --> 00:52:40.690
of the code and help you to achieve
bullet-proof, bug-free programs.

00:52:40.690 --> 00:52:42.000
That's pretty cool.

00:52:42.000 --> 00:52:43.489
Slides, please.

00:52:47.289 --> 00:52:57.590
So later on today there is an Objective-C 2.0 Lab
and then we're going to redo another Lab tomorrow.

00:52:57.590 --> 00:53:01.630
So we'll be there, please come by, say hello.

00:53:01.630 --> 00:53:08.869
There's two more sessions focused on Objective-C. There's
an Advanced Objective-C 2.0 session which is going

00:53:08.869 --> 00:53:15.960
to cover an area which I only glossed over, which is the
64-bit runtime or the new runtime and some of the features

00:53:15.960 --> 00:53:21.429
that are available there where we can add these
features without worrying about binary compatibility.

00:53:21.429 --> 00:53:23.179
It's pretty amazing.

00:53:23.179 --> 00:53:26.730
It's definitely a look to the future of Objective-C.

00:53:26.730 --> 00:53:33.519
And the Garbage Collection session at the end of the
week which will go into the garbage collector in depth,

00:53:33.519 --> 00:53:38.750
talk about debugging, analysis, and fine grain
control, as well as having to look at some

00:53:38.750 --> 00:53:41.320
of the architectures you can use specific to the collector.
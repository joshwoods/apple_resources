WEBVTT

00:00:11.779 --> 00:00:17.750
>> Good afternoon and welcome to session three
seventeen, Taking Advantage of Compiler Advances.

00:00:17.750 --> 00:00:21.399
This is the compiler talk this year.

00:00:21.399 --> 00:00:22.989
My name is Geoffrey Keating.

00:00:22.989 --> 00:00:29.159
I am the GCC team lead and I'll be
doing the first part of this talk.

00:00:29.160 --> 00:00:33.560
So in this talk there are three things
that we'll be telling you about.

00:00:33.560 --> 00:00:40.100
The GCC 4.2 in your Leopard seen today,
has some new features over the GCC 4.2

00:00:40.100 --> 00:00:44.289
and 4.0 in Tiger and we'll be telling you about those.

00:00:44.289 --> 00:00:49.679
Then we'll be telling you about a new compiler technology
that we're developing which has a new version number,

00:00:49.679 --> 00:00:56.549
GCC 4.2 and finally, we'll be telling you about
an even newer compiler technology called LLVM.

00:00:56.549 --> 00:01:00.750
We'll be telling you what it is and what you can do with it.

00:01:00.750 --> 00:01:02.420
( applause )

00:01:02.420 --> 00:01:06.250
We have a fan, excellent.

00:01:06.250 --> 00:01:11.129
So first of all, for those who are
relatively new to the developing on the Mac,

00:01:11.129 --> 00:01:15.379
we thought we'd just introduce how
the developer tools are structured.

00:01:15.379 --> 00:01:18.299
I talked earlier about three different things, GCC 4.0,

00:01:18.299 --> 00:01:23.250
4.2 and LLVM and I thought I'd tell you
about how they all integrate into Xcode.

00:01:23.250 --> 00:01:29.739
So the place to start for development
on the Mac platform is Xcode.

00:01:29.739 --> 00:01:36.449
You'll find it in the developer folder
on your developer seed with this icon.

00:01:36.450 --> 00:01:42.870
Internally, Xcode uses a number of different possible
compilers to take the source code that you enter

00:01:42.870 --> 00:01:45.820
and convert it into a working application.

00:01:45.819 --> 00:01:52.339
For C and C++ and Objective-C and Objective-C
applications, the default compiler that's used in Leopard

00:01:52.340 --> 00:01:59.140
and that was also used in Tiger, is named GCC 4.0.

00:01:59.140 --> 00:02:02.659
But Xcode is not tied to a single compiler.

00:02:02.659 --> 00:02:11.120
For example, in Leopard, you can also use
GCC 3.3, an older version of the compiler.

00:02:11.120 --> 00:02:17.099
Xcode also in Leopard, also permits you to add
third party compilers like the Intel compilers.

00:02:17.099 --> 00:02:22.280
In this talk we'll be introducing two
new possibilities that aren't available

00:02:22.280 --> 00:02:25.759
yet on your Leopard seed, but that we're developing.

00:02:25.759 --> 00:02:32.649
In the future we may produce GCC 4.2
which will be a new version.

00:02:32.650 --> 00:02:38.610
It will be a separate compiler that will also be, that
will be able to be used in parallel with GCC4 dot 0.

00:02:38.610 --> 00:02:43.870
You can actually set up Xcode to compile one
file with 4.0 and then the next file with 4.2.

00:02:43.870 --> 00:02:52.960
We'll also be talking about LLVM which is
like 4.2 an additional compiler on the system.

00:02:52.960 --> 00:02:57.320
You can also use all of these compilers
with other build systems.

00:02:57.319 --> 00:03:05.449
For example, if you have a process that uses, the
build process that uses Mac and possibly Emac's or VI,

00:03:05.449 --> 00:03:10.729
you can still use all of the compilers
from the command line.

00:03:10.729 --> 00:03:16.019
So first of all I'll talk about the
improvements we've made to GCC 4.0.

00:03:16.020 --> 00:03:23.219
GCC 4.0 was as I said, the default compiler even in
Tiger, but the GCC 4.0 in Leopard and in Xcode 3.0,

00:03:23.219 --> 00:03:27.909
has some significant improvements made to it.

00:03:27.909 --> 00:03:35.879
So one change that we made is that we've
default debugging format in Xcode 3.0.

00:03:35.879 --> 00:03:41.150
We've had a new debugging format called
DWARF available since Xcode 2.2.3,

00:03:41.150 --> 00:03:44.400
but in Xcode 3.0 we're switching it on by default.

00:03:44.400 --> 00:03:54.159
So we're kind of hoping most of you won't notice, but
there are some significant improvements that this brings.

00:03:54.159 --> 00:03:58.229
One thing that it improves is the size of final executables.

00:03:58.229 --> 00:04:05.469
The previous debugging format called STABS had
used to include all the debugging information

00:04:05.469 --> 00:04:08.109
through the link process, in the final executable.

00:04:08.110 --> 00:04:11.950
So the debugging information would be
generated by the compiler in the object files,

00:04:11.949 --> 00:04:17.219
would be copied through the link phasing in the final
executable and then the debugger would read it from there.

00:04:17.220 --> 00:04:22.960
The problem with this is that it really made the
executables much larger than they needed to be.

00:04:22.959 --> 00:04:27.149
STABS was typically larger than the
executable code itself, so they would,

00:04:27.149 --> 00:04:30.219
the executables would become truly huge in some cases.

00:04:30.220 --> 00:04:35.410
We had a number of technologies designed to avoid
this but DWARF makes the whole process redundant.

00:04:35.410 --> 00:04:41.290
Because, with DWARF, the debugging information,
although it's still placed in the object files,

00:04:41.290 --> 00:04:43.860
is no longer copied to the final executable.

00:04:43.860 --> 00:04:48.030
Instead, just a small amount of indexing
information is placed in the final executable

00:04:48.029 --> 00:04:54.709
and the debugging information is read from the
.o files when you debug your executable.

00:04:54.709 --> 00:04:56.089
The benefit of this?

00:04:56.089 --> 00:05:01.339
Well the executables become smaller when the
compilers debug information, but more importantly,

00:05:01.339 --> 00:05:06.789
link time is dramatically reduced because this
extra information doesn't need to be copied around.

00:05:06.790 --> 00:05:09.760
So you should notice significantly faster turnaround times.

00:05:09.759 --> 00:05:15.219
If you don't wanna keep the object files
around, we have a tool called DCM Util

00:05:15.220 --> 00:05:18.920
that let's you take the DWARF information
from all of the object files

00:05:18.920 --> 00:05:23.870
and creates a separately file called a
DCM file which you can then use even

00:05:23.870 --> 00:05:28.230
with a strict executable for debugging purposes.

00:05:28.230 --> 00:05:30.970
DWARF also has a number of other benefits.

00:05:30.970 --> 00:05:34.700
For example, you get better C++ debugging,

00:05:34.699 --> 00:05:39.479
especially DWARF can properly represent
name spaces which STABS couldn't.

00:05:39.480 --> 00:05:42.980
You'll find the .o files themselves are also smaller.

00:05:42.980 --> 00:05:48.540
You'll find that in line subroutines are
have almost transparent debugging now.

00:05:48.540 --> 00:05:56.629
You can actually debug any line subroutine as if it wasn't
and that feature, that last one is new with Xcode 3.0

00:05:56.629 --> 00:06:01.790
and again, DWARF was always available since
Xcode 2.3 but now we've made it the default.

00:06:01.790 --> 00:06:06.710
STABS is still available as an option for the moment.

00:06:06.709 --> 00:06:10.250
Another collection of features that
we've added relate to security.

00:06:10.250 --> 00:06:14.480
So there's a continuing emphasis on security in Leopard.

00:06:14.480 --> 00:06:17.840
Where Tiger was pretty secure,
Leopard will be even more secure.

00:06:17.839 --> 00:06:27.299
Plan for this to continue happening until we either reach
a perfectly secure operating system or we run out of time.

00:06:27.300 --> 00:06:27.829
( laughter )

00:06:27.829 --> 00:06:33.250
So there are some things that the compiler
will now do to help you write more secure code.

00:06:33.250 --> 00:06:35.610
To basically catch security problems.

00:06:35.610 --> 00:06:38.819
But where should you put them,
where should you turn them on.

00:06:38.819 --> 00:06:45.439
Well the places where you need security are
where you application listens to the network,

00:06:45.439 --> 00:06:49.610
reads files that might be sent through
email or through a web browser.

00:06:49.610 --> 00:06:55.139
We know we tell people that you know, you really shouldn't
just click on a file that someone's just sent you in email

00:06:55.139 --> 00:06:59.199
and most of the time that works and
sometimes they click on it anyway.

00:06:59.199 --> 00:07:03.599
You also need to take extra care to be secure
where application crosses privilege boundaries.

00:07:03.600 --> 00:07:11.200
So an example of that is any place where your
application runs as root where it installs software.

00:07:11.199 --> 00:07:19.000
So as I said, GCC 4.0 and Leopard provides
new ways to avoid some common security bugs

00:07:19.000 --> 00:07:22.240
that you might have accidentally placed in your application.

00:07:22.240 --> 00:07:27.860
You should make sure to switch these on in places where you
wanna take extra care to be secure and possibly switch them

00:07:27.860 --> 00:07:32.910
on all the time just in case because
you never know when you might need it.

00:07:32.910 --> 00:07:36.400
So here's an example of a security bug.

00:07:36.399 --> 00:07:41.569
Possibly the smallest program that can
have a really serious security bug.

00:07:41.569 --> 00:07:47.899
We have a simple main program that takes some input from
the user through it's arguments and attempts to copy

00:07:47.899 --> 00:07:55.639
that information into a fixed size buffer and the problem
is that if the information from the user is too large well,

00:07:55.639 --> 00:07:59.300
the buffer isn't that large so it won't fit.

00:07:59.300 --> 00:08:02.340
So how does this become a security problem?

00:08:02.339 --> 00:08:05.250
Well let's see what happens when we trigger the bug.

00:08:05.250 --> 00:08:12.750
When this is compiled and run, it sets up a frame
on the stack that contains a number of things.

00:08:12.750 --> 00:08:20.769
It contains local variables including the buffer, the fixed
sized buffer and there's other information on the stack

00:08:20.769 --> 00:08:24.139
like save registers and importantly the return address.

00:08:24.139 --> 00:08:29.759
Since this is the main program, the return address will
normally call the exit routine to finish the application.

00:08:30.790 --> 00:08:38.039
So when this program is run normally, it'll
copy some information into the buffer.

00:08:38.039 --> 00:08:42.409
If that information doesn't fit, it'll overflow.

00:08:42.409 --> 00:08:48.549
It'll continue copying up the stack, overwriting
other local variables, the saved registers,

00:08:48.549 --> 00:08:51.519
the return address and the function arguments.

00:08:51.519 --> 00:08:58.500
Someone malicious could arrange that the information
copied into the buffer changes the return address to point

00:08:58.500 --> 00:09:05.220
to a location where code that they want to execute
is available and that code could do something

00:09:05.220 --> 00:09:08.769
that you weren't expecting as the author of this program.

00:09:08.769 --> 00:09:17.370
So GCC 4.0 in Leopard, now has a technology which
can at least prevent this particular case.

00:09:17.370 --> 00:09:24.620
What we do is we insert a canary between
the local variables and the save registers.

00:09:25.889 --> 00:09:29.840
In defense of our art department, I
should point out that I drew this canary.

00:09:29.840 --> 00:09:34.420
( laughter )

00:09:34.419 --> 00:09:38.039
So the way this works is this.

00:09:38.039 --> 00:09:41.709
Under normal use there's nothing changes.

00:09:41.710 --> 00:09:44.430
You write into the buffer and everything fits.

00:09:44.429 --> 00:09:49.479
If the buffer overflows, it will write
up past the canary, the saved registers

00:09:49.480 --> 00:09:53.210
and onto whatever the attacker was hoping for.

00:09:53.210 --> 00:10:04.190
The compiler generates code as the function returns,
to notice whether the canary is still in tact

00:10:04.190 --> 00:10:07.260
or whether he's suffered this horrible fate.

00:10:07.259 --> 00:10:12.909
If the canary has been overwritten,
the code at the end of the program,

00:10:12.909 --> 00:10:16.839
the code at the end of the function
will then terminate execution.

00:10:16.840 --> 00:10:22.730
It'll make sure that the saved registers or the return
address which might have been compromised, are not used

00:10:25.649 --> 00:10:30.929
You can switch this functionality on
with the -fstack-protector flag.

00:10:30.929 --> 00:10:40.769
At the moment we don't have any UI for it so you have
to add it into the other C flag setting in Xcode.

00:10:40.769 --> 00:10:43.579
However, this catches that particular case.

00:10:43.580 --> 00:10:45.940
There are cases that this won't catch.

00:10:45.940 --> 00:10:50.540
For example, it relies on the buffer being a local variable.

00:10:50.539 --> 00:10:56.990
If the buffer is in the fixed data section instead,
so if it's static like in this example here.

00:10:56.990 --> 00:11:00.250
The stack canary won't be overwritten.

00:11:00.250 --> 00:11:07.580
So the stack canaries won't catch this particular problem.

00:11:07.580 --> 00:11:10.530
However we have another technology
that we've added in Leopard,

00:11:10.529 --> 00:11:15.549
another security technology that
will catch this particular case.

00:11:15.549 --> 00:11:24.529
The problem here is that when we call the operating system
string copy routine, there's no way for the operating system

00:11:24.529 --> 00:11:32.539
to know where the buffer ends and where other information
like the remainder of the stack frame or the canary begins.

00:11:32.539 --> 00:11:43.139
So in GCC 4.0, we've added a flag that
lets the compiler change string copy

00:11:43.139 --> 00:11:47.750
into a new function called string copy
check and that lets the compiler pass

00:11:47.750 --> 00:11:51.259
on information about what the return size should be.

00:11:51.259 --> 00:11:57.610
So here for example, will pass on the size of
the buffer so will tell the string copy check

00:11:57.610 --> 00:12:00.370
that it should not copy more than 32 bytes.

00:12:00.370 --> 00:12:06.450
If it does appear to be copying more than 32
bytes, it'll stop and again, it'll terminate your program.

00:12:06.450 --> 00:12:13.170
So you'll notice a trend with these, none of
them really hide the bug and the usual response

00:12:13.169 --> 00:12:17.229
to a detected security problem is
that the application gets terminated.

00:12:17.230 --> 00:12:23.629
So you should only really use them where terminating the
application is better than what might otherwise happen.

00:12:23.629 --> 00:12:27.309
But again, this has it's limitations.

00:12:27.309 --> 00:12:33.419
Object size checking is limited to checking only
system calls or calls into the system libraries.

00:12:33.419 --> 00:12:38.919
So if you write the string copy yourself,
object size checking can't catch that.

00:12:38.919 --> 00:12:43.299
Of course one thing that would have helped
with this is that don't write it yourself.

00:12:43.299 --> 00:12:48.959
The system string copy routine is likely to be
much faster than this code that I've written here.

00:12:50.059 --> 00:12:55.409
So to switch on object size checking,
you define a preprocessor macro.

00:12:55.409 --> 00:12:59.000
In this case here, fortify source with and underscore.

00:12:59.000 --> 00:13:07.019
There's two levels, one and two, just use two.

00:13:07.019 --> 00:13:11.439
Another security feature that we've added in
Leopard is address space layout randomization.

00:13:11.440 --> 00:13:17.440
So you'll remember the earlier example that I
showed you relied on overwriting the return address.

00:13:17.440 --> 00:13:24.120
The return, to point it at code that
would do whatever the attacker wanted.

00:13:24.120 --> 00:13:30.039
To make this harder, we've now randomized the addresses
of code so that the attacker can't so easily guess

00:13:30.039 --> 00:13:33.329
where the code they wanted to run might be.

00:13:33.330 --> 00:13:38.770
So it works by loading executables in
libraries at random locations in memory.

00:13:38.769 --> 00:13:43.500
The randomization for system libraries
only varies between machines,

00:13:43.500 --> 00:13:49.389
so for a given machine the system
libraries will always be in the same place

00:13:49.389 --> 00:13:53.049
until I guess you reinstall and
a few other things like that.

00:13:53.049 --> 00:13:58.479
But for applications in user libraries,
they differ every time you run the program.

00:13:58.480 --> 00:14:04.269
So one detail about this is that
debugging will all still work.

00:14:04.269 --> 00:14:07.199
All your variables will be found by name, etcetera.

00:14:07.200 --> 00:14:12.940
But if you're in the habit of for example, writing
down the address from the screen on a Post-it note,

00:14:12.940 --> 00:14:17.330
well the computer can't update your Post-it note
if you put your application in and restart it,

00:14:17.330 --> 00:14:20.460
so you might find it desirable to
switch this off during debugging.

00:14:20.460 --> 00:14:23.500
But leave it on in your released application.

00:14:27.250 --> 00:14:36.240
Oh and I guess I should say, you switch it on by doing
all of these things, you have to add the dash F pie

00:14:36.240 --> 00:14:41.000
for position independent executable flag
and also pass that flag to the linker.

00:14:41.000 --> 00:14:44.370
You also need to make sure that you are
not generating position dependent code.

00:14:44.370 --> 00:14:53.320
The default is not to do that, but it might be
switched on depending on what template you used.

00:14:53.320 --> 00:14:56.129
Another feature, another security
feature that we've added in Leopard,

00:14:56.129 --> 00:15:01.769
so this is 4.0 now, is code and data separation.

00:15:01.769 --> 00:15:06.659
It's no longer the case that you
can just copy code into memory

00:15:06.659 --> 00:15:10.120
that you've allocated with malloc and then run it.

00:15:10.120 --> 00:15:12.549
You'll get a protection fault if you do that.

00:15:12.549 --> 00:15:17.959
This is to prevent a situation where the
attacker provides his own code in memory

00:15:17.960 --> 00:15:21.440
in your application and then tries to return to that.

00:15:21.440 --> 00:15:27.670
If your application does in fact generate code at run time,
you should use the end protect system call to make just

00:15:27.669 --> 00:15:33.479
that place, just the part of memory
where you generated code executable.

00:15:33.480 --> 00:15:40.180
This doesn't need to be switched on, it applies
to all 64-bit programs in Leopard.

00:15:41.350 --> 00:15:44.629
So in summary, four new security features.

00:15:44.629 --> 00:15:50.679
Stack canaries, object size checking, address
space randomization and code and data separation

00:15:50.679 --> 00:15:57.689
They work together to make it harder or in
some cases impossible to exploit security bugs.

00:15:57.690 --> 00:16:00.680
But, none of them are a perfect solution.

00:16:00.679 --> 00:16:05.429
There are certainly security bugs that
you can have that nothing here will catch,

00:16:05.429 --> 00:16:08.549
even the compiler can't catch in principle.

00:16:08.549 --> 00:16:12.779
But they will help you to catch
many of the more common ones.

00:16:12.779 --> 00:16:15.620
Unfortunately they're also all not the default.

00:16:15.620 --> 00:16:24.000
You do need to switch them on at the moment and they have to
be switched on individually except for code data separation.

00:16:24.000 --> 00:16:29.559
Okay so that was security.

00:16:29.559 --> 00:16:35.429
So another change that we made in Leopard has
to do with the way deployment targets works.

00:16:35.429 --> 00:16:44.839
So the idea here is that you're on the left, you're
writing your wonderful application with Xcode,

00:16:44.840 --> 00:16:48.259
you have some users running various
versions of the operating system

00:16:48.259 --> 00:16:51.679
that you wanna be able to give your application to.

00:16:51.679 --> 00:17:03.509
So in Leopard, the default is that if you write an
application in Leopard, by default it runs only on Leopard.

00:17:03.509 --> 00:17:08.049
So okay, well as a commissioned developer
you might not be terribly happy about this

00:17:08.049 --> 00:17:10.299
because at the moment there are zero people running Leopard.

00:17:10.299 --> 00:17:15.099
Well not counting the people in this building.

00:17:15.099 --> 00:17:19.859
And you might feel that even when Leopard does
get released and nearly everybody moves to it,

00:17:19.859 --> 00:17:24.000
that the remaining people are still people you
would like to be able to sell your application to.

00:17:25.470 --> 00:17:29.720
On the other hand, you might feel that the
new features in Leopard like core animation,

00:17:29.720 --> 00:17:34.370
like the security features I just talked about, are
sufficiently interesting that this is what you want.

00:17:34.369 --> 00:17:38.659
That you don't need to be, that you can
allow, you can ask you customers to upgrade

00:17:38.660 --> 00:17:42.430
to Leopard to get all of these new cool features.

00:17:42.430 --> 00:17:48.240
However, should you decide that you would really like the
people running on Tiger to be able to run your application,

00:17:48.240 --> 00:17:51.690
what you need to do now is change a setting in Xcode.

00:17:51.690 --> 00:17:59.670
If you set the Mac OS X deployment setting to be 10.4,
then this will mean that people running 10.4

00:17:59.670 --> 00:18:02.970
and higher should be able to run your application.

00:18:02.970 --> 00:18:08.240
Obviously you can't use any 10.5 features in
your application when you're running on 10.4,

00:18:08.240 --> 00:18:17.039
although you can use weak symbols to use new functionality
by detecting that you're running on a 10.5 system.

00:18:17.039 --> 00:18:24.589
If you wanna go all the way back to 10.3.9,
GCC 4.0 on Leopard, continues to support that.

00:18:24.589 --> 00:18:28.349
You simply need to set you deployment
target to be 10.3.

00:18:28.349 --> 00:18:36.529
For so this catches the vast majority of all the
people, of all the installed based of Mac OS X.

00:18:36.529 --> 00:18:40.589
For still earlier versions, then
life becomes much more complicated

00:18:40.589 --> 00:18:45.119
than a simple setting and we can talk about that afterwards.

00:18:45.119 --> 00:18:48.239
There's not quite time in this
talk to discuss the permentations.

00:18:48.240 --> 00:18:59.279
However, these three, 10.3.9, 10.4
and 10.5, are the vast majority of users.

00:18:59.279 --> 00:19:06.539
Okay and one more thing, we don't have time in this talk
to explain all the wonderful Objective-C 2.0 features

00:19:06.539 --> 00:19:08.730
that we've added in the Leopard compiler.

00:19:08.730 --> 00:19:14.759
For those you would need it to go to the Objective-C
2.0 talks that were earlier in the week.

00:19:14.759 --> 00:19:18.269
But hopefully they will become available later on.

00:19:18.269 --> 00:19:21.759
Or hopefully you already went.

00:19:21.759 --> 00:19:25.319
So in summary, the GCC 4.0 changes for Leopard.

00:19:25.319 --> 00:19:30.429
We added a collection of new security features,
some of which you should probably switch on.

00:19:30.430 --> 00:19:34.259
We've changed the default setting for deployment targets.

00:19:34.259 --> 00:19:38.660
We've changed the default for DWARF
and we added Objective-C 2.0

00:19:38.660 --> 00:19:48.110
and 64-bit Objective-C.
So those were the GCC 4.0 changes.

00:19:48.109 --> 00:19:55.339
We're also working on a new technology, GCC 4.2,
that's not yet available in your Leopard seed.

00:19:55.339 --> 00:20:02.289
It will be a new major version of the
compiler so it will install parallel to GCC 4.0.

00:20:02.289 --> 00:20:08.450
So people who are using GCC 4.0 now will be able to
continue to use it for some time in the future.

00:20:08.450 --> 00:20:12.809
In GCC 4.2, we're adding a bunch of new features.

00:20:12.809 --> 00:20:18.079
In particular, we're adding a new version
of the standard C++ library.

00:20:18.079 --> 00:20:26.139
We're also planning to make, we're also making a number of
bug fixes, including some that might break the existing code

00:20:26.140 --> 00:20:36.160
and so and in combination with that, we're going to
attempt to avoid adding such new features to GCC 4.0.

00:20:36.160 --> 00:20:42.290
So the plan which is not final yet, is
that GCC 4.0 will become the stable compiler

00:20:42.289 --> 00:20:46.190
and GCC 4.2 will be where the new development happens.

00:20:46.190 --> 00:20:47.660
All this of course is subject to change.

00:20:47.660 --> 00:20:53.350
We haven't shipped a 4.2 yet and there's still time.

00:20:53.349 --> 00:20:59.209
One of the significant new features that we're adding
in GCC 4.2 has to do with multiprocessing support.

00:20:59.210 --> 00:21:04.289
For those of you who are in the Intel
compiler talk, you already know about OpenMP

00:21:04.289 --> 00:21:07.430
but there's still new information in this part of the talk.

00:21:07.430 --> 00:21:13.019
So for those who weren't there, I should
briefly introduce what OpenMP is.

00:21:13.019 --> 00:21:18.789
Mac OS X has a large number of
libraries supporting multiprocessing.

00:21:18.789 --> 00:21:26.680
At the very basic level you have the Mach kernel
which supports Mac tasks and ports and such.

00:21:26.680 --> 00:21:32.920
Layered above that we have as one possibility, the
UNIX end of process communication infrastructure.

00:21:32.920 --> 00:21:36.470
For example fork, UNIX pipes.

00:21:36.470 --> 00:21:44.559
And on top of that what you might find are more friendly and
more structured approaches to multiprocess communication.

00:21:44.559 --> 00:21:49.149
We have the Cocoa inter application
communications layer and we have Apple events.

00:21:49.150 --> 00:21:56.009
If you want to do threads so multiple threads
of application within the same process,

00:21:56.009 --> 00:22:02.700
we provide the POSIX thread layer and we provide
Carbon threads for people who are still using Carbon

00:22:02.700 --> 00:22:08.420
but what we recommend is Cocoa threads, a nice
user-friendly way to set up multiple threads of execution

00:22:08.420 --> 00:22:14.550
in a single process, pass messages
between them, set up locks and the like.

00:22:14.549 --> 00:22:19.419
All of these thought are fundamentally
based on message passing.

00:22:19.420 --> 00:22:25.910
You set up a thread, the thread you
know, passes a message to another thread,

00:22:25.910 --> 00:22:28.980
acquires a lock from another thread and so on.

00:22:28.980 --> 00:22:36.150
If your code is already basically procedural and
you want to add multiprocessing support to it,

00:22:36.150 --> 00:22:43.160
these are somewhat more complicated than the new
alternative that we're proposing, suggesting, OpenMP.

00:22:43.160 --> 00:22:47.710
So let me talk about OpenMP, who might
want to use it and what it's useful for.

00:22:50.910 --> 00:22:54.740
Here is a simple example of some procedural code.

00:22:54.740 --> 00:22:59.970
It's a simple loop that adds two arrays together.

00:22:59.970 --> 00:23:07.769
You could paralyze this with POSIX's threads
or the like, but it would be complicated.

00:23:07.769 --> 00:23:11.910
You would have to start off a bunch
of threads, you'd have to set up locks

00:23:11.910 --> 00:23:14.310
to make sure the threads don't over write each other.

00:23:14.309 --> 00:23:20.589
With OpenMP, you can add parallelism
to this simple loop like this.

00:23:20.589 --> 00:23:31.599
Here we've added two single lines of code.

00:23:31.599 --> 00:23:39.609
One of them is the OMP4 pragma, this basically
says, please take this full loop and paralyze it.

00:23:39.609 --> 00:23:42.549
The other one is infrastructure.

00:23:42.549 --> 00:23:47.419
It informs the compiler about what things are
really parallel in this loop and what aren't.

00:23:47.420 --> 00:23:52.470
For example, here we've said that the arrays A,
B and C are shared between all of the threads,

00:23:52.470 --> 00:23:55.190
but that the loop counter eye is to be private.

00:23:55.190 --> 00:23:59.539
We've also passed information about how many threads to use.

00:23:59.539 --> 00:24:02.700
We've basically said we don't care
and how to organize the data.

00:24:02.700 --> 00:24:05.470
We've said to divide it up into chunks.

00:24:06.920 --> 00:24:14.830
So what this does is it will cause the compiler to
automatically generate code which creates a bunch

00:24:14.829 --> 00:24:19.279
of threads, runs this computation in parallel
and then waits for them all to finish.

00:24:19.279 --> 00:24:26.259
To do this with POSIX threads would
require significantly more code.

00:24:26.259 --> 00:24:30.809
So the basic model of OpenMP is
that it's a fork joined model.

00:24:30.809 --> 00:24:38.220
You start off with sequential code, the code splits
off into a bunch of threads, runs some computation

00:24:38.220 --> 00:24:43.720
and then when the computation is done, all the
threads join together and then sequential code resumes

00:24:43.720 --> 00:24:47.720
and then maybe later on you do
the same thing all over again.

00:24:47.720 --> 00:24:51.809
OpenMP also supports more complicated forms of parallelism,

00:24:51.809 --> 00:24:55.240
all the threads don't necessarily have
to be running in the same computation.

00:24:55.240 --> 00:25:01.420
You can set up barriers and locks to synchronize so
that at some point in the middle of the parallelism,

00:25:01.420 --> 00:25:04.560
all your threads have single point where they're executing.

00:25:04.559 --> 00:25:12.710
And I don't plan to go into the details of OpenMP here.

00:25:12.710 --> 00:25:20.170
So but what you do need to know is what compiler
is supported and on what system it works.

00:25:20.170 --> 00:25:25.190
So open mp will be supported in GCC 4.2.

00:25:25.190 --> 00:25:33.480
However the version that's supported there is not compatible
with the version that the Intel compilers support.

00:25:33.480 --> 00:25:42.779
So you should really use for your multi threaded
code, a single compiler to per shared library.

00:25:42.779 --> 00:25:46.670
You should probably avoid exporting
OpenMP controlled variables

00:25:46.670 --> 00:25:50.940
from shared libraries because the ABI's aren't consistent.

00:25:50.940 --> 00:25:58.289
You can use OpenMP only if you're using the Leopard SDK
but you can still use it to target 10.3.9 and higher

00:25:58.289 --> 00:26:01.649
through the deployment target mechanism
I referred to earlier.

00:26:01.650 --> 00:26:09.030
And there is one feature of the Open, that's commonly
supported in OpenMP, the GCC 4.2. does not have yet.

00:26:09.029 --> 00:26:15.099
You remember earlier that I said that the
variable I was to be distributed per thread,

00:26:15.099 --> 00:26:17.209
that worked because I was a local variable.

00:26:17.210 --> 00:26:23.110
At the moment GCC 4.2 doesn't do
that for file scope variables.

00:26:24.829 --> 00:26:33.399
So for more information, if you wanna know how to program
an OpenMP for example, go to www.openmp.org

00:26:33.400 --> 00:26:36.620
where there's a full description of all that OpenMP can do.

00:26:36.619 --> 00:26:45.799
There's also numerous tutorials on the web, just type
OpenMP tutorial into Google and you'll get five.

00:26:45.799 --> 00:26:48.299
Okay so that was OpenMP.

00:26:48.299 --> 00:26:53.799
Now let's talk the improvements that GCC 4.2
is going to make to visibility support.

00:26:55.029 --> 00:26:59.670
So for those who are new to the platform or
haven't had to deal with shared libraries a lot,

00:26:59.670 --> 00:27:05.900
by default the C++ program behaves the same
way whether it's a single monolithic application

00:27:05.900 --> 00:27:08.420
or if you split it into multiple shared libraries.

00:27:08.420 --> 00:27:12.690
This is different on Mac OS compared to say Windows.

00:27:14.809 --> 00:27:21.809
So to avoid collisions between multiple shared libraries
that might happen to use the same name for things,

00:27:21.809 --> 00:27:24.599
you should use the C++ name space feature.

00:27:24.599 --> 00:27:28.969
This is a good idea even if you're not
using shared libraries at all of course.

00:27:28.970 --> 00:27:33.130
However, there is another alternative.

00:27:33.130 --> 00:27:42.260
GCC 4.0 and improved in GCC 4.2, supports an
attribute, the hidden visibility attribute.

00:27:42.259 --> 00:27:45.980
This set ups a new layer of what we call linkage.

00:27:45.980 --> 00:27:52.860
So just as you can use the keyword static to say
that a variable is restricted to a single .o file

00:27:52.859 --> 00:27:58.369
or exstone keyword to say that this variable should
be visible throughout the entire application.

00:27:58.369 --> 00:28:02.189
There's an intermediate layers where
you can say this is to be hidden,

00:28:02.190 --> 00:28:05.470
which means that the variable is
visible only inside the shared library

00:28:05.470 --> 00:28:08.269
or application where the variable was defined.

00:28:08.269 --> 00:28:12.950
And in C++ the hidden attribute
also works for types.

00:28:12.950 --> 00:28:18.289
So if a type is supposed to be visible throughout
the entire application, don't say it's hidden.

00:28:18.289 --> 00:28:24.529
But if you do want it to me limited to just a
single dialog, then you use an attribute on that.

00:28:24.529 --> 00:28:31.490
The benefits of doing this, aside from the normal code
friendliness, is that it improves performance just

00:28:31.490 --> 00:28:38.140
as static does, is because the loader in
macros doesn't need to start to deal with all

00:28:38.140 --> 00:28:41.310
of these symbols when you application starts up.

00:28:41.309 --> 00:28:46.529
It also prevents accidental use of internal symbols.

00:28:46.529 --> 00:28:52.990
So we're making improvements to the
visibility support in GCC 4.2.

00:28:52.990 --> 00:28:59.079
The basic concept is if you can't use a symbol, that
is the symbol relies on something that isn't visible

00:28:59.079 --> 00:29:05.199
on the outside this translation unit, then the compiler
will hide it so that you get the performance benefits

00:29:05.200 --> 00:29:09.519
without having to worry about putting
explicit attributes on anything.

00:29:09.519 --> 00:29:15.730
So for example here, we have a
structure that's marked as hidden.

00:29:15.730 --> 00:29:19.519
We have a function that takes that structure as a parameter.

00:29:19.519 --> 00:29:24.170
Since the structure is restricted
to just this shared library,

00:29:24.170 --> 00:29:31.940
then the function can also be automatically restricted
because nothing from outside should be able to use it.

00:29:33.490 --> 00:29:40.319
This is particularly useful in combination with
templates and the standard C++ library.

00:29:41.990 --> 00:29:51.019
So for example, if you create a standard vector with
a structure that is only used in your shared library,

00:29:51.019 --> 00:29:57.279
the compiler will now, the 4.2 compiler will automatically
make sure that all of the components of that structure,

00:29:57.279 --> 00:30:03.450
the instantiated functions and variables
are also themselves automatically hidden

00:30:03.450 --> 00:30:07.809
because since the structure isn't
visible outside your shared library,

00:30:07.809 --> 00:30:12.409
neither the instantiation does not need to be either.

00:30:12.410 --> 00:30:20.180
But if you instantiate a template on some type that
is not hidden, some type that is visible everywhere,

00:30:20.180 --> 00:30:28.450
then the compiler will ensure that is in fact continues
to be visible everywhere unless you tell it otherwise.

00:30:28.450 --> 00:30:34.430
Another improvement that we're making in GCC 4.2 is that
the hidden attribute can now be applied to namespaces

00:30:34.430 --> 00:30:40.039
and when you do that the obvious thing happens,
everything inside the namespace is hidden.

00:30:40.039 --> 00:30:45.740
This is particularly beneficial if you have a namespace
containing the internal implementation details

00:30:45.740 --> 00:30:47.160
of your shared library.

00:30:47.160 --> 00:30:50.009
You can just mark that name space
as hidden and then everything

00:30:50.009 --> 00:30:54.519
that relates to it will also automatically hidden.

00:30:55.859 --> 00:31:02.889
Another collection of improvements that we're
making don't involve the hidden key word at all.

00:31:02.890 --> 00:31:09.240
Anonymous namespaces don't have a name, that's why
they're anonymous and therefore you can't use them

00:31:09.240 --> 00:31:12.500
from outside the translation unit where they're defined.

00:31:13.539 --> 00:31:22.359
What GCC 4.2 will do is notice that types, variables,
functions and the like declared in an anonymous namespace,

00:31:22.359 --> 00:31:29.250
first of all all of those will be made static, but also
anything that relies on them will also be made static.

00:31:29.250 --> 00:31:34.720
So if for example, if you declare a structure in
an anonymous namespace and then you instantiate

00:31:34.720 --> 00:31:41.200
for example a standard vector, of those
structures, nothing on that vector needs

00:31:41.200 --> 00:31:43.910
to escape the object file that data compiled into.

00:31:43.910 --> 00:31:46.480
So all of that will be automatically made static.

00:31:46.480 --> 00:31:51.880
So that will become a significant
performance improvement both in terms of load,

00:31:51.880 --> 00:31:58.980
application load time and the speed of linking become.

00:31:58.980 --> 00:32:04.240
Another new feature we're adding in GCC 4.2
is the ability to turn warnings into errors.

00:32:04.240 --> 00:32:11.339
Now you could always turn all of your warnings into
errors by using the -W error command line flag,

00:32:11.339 --> 00:32:14.990
in GCC 4.2 we let you turn specific warnings into errors.

00:32:14.990 --> 00:32:20.980
So for example, if you decided that the format
security option is a very important option for you

00:32:20.980 --> 00:32:26.460
and you absolutely don't wanna build anything that produces
those warnings, but you have other warnings that you're not

00:32:26.460 --> 00:32:31.980
so curious about and but that you
still don't wanna suppress,

00:32:31.980 --> 00:32:37.680
GCC 4.2 lets you say -Werror=format-security.

00:32:37.680 --> 00:32:44.690
This will then ensure that all those associated warnings
are hard errors so that you, if they're using your build,

00:32:44.690 --> 00:32:52.960
your build will fail and you'll be sure that
none of those ever slip into a shipping product.

00:32:52.960 --> 00:32:55.470
We've also added to a collection of optimizations.

00:32:55.470 --> 00:33:04.500
Some of the more significant ones is the dead code in
elimination will now remove static variables that are used

00:33:04.500 --> 00:33:08.210
in your code, but were only used
in code that turned out to be dead.

00:33:08.210 --> 00:33:13.340
We've made improvements to profile guided in
lining and improvements to profiling itself.

00:33:14.950 --> 00:33:20.630
We've also added an option called inter procedural
constant propagation that works like this.

00:33:20.630 --> 00:33:26.200
Suppose you have a function and it takes a
parameter and your code has been well structured

00:33:26.200 --> 00:33:29.400
so that many things are parameters or functions.

00:33:29.400 --> 00:33:33.330
It just so happens that this particular
parameter is always the same.

00:33:33.329 --> 00:33:40.909
This is fairly easy to do if you've got say a control
structure that is passed to most of your functions,

00:33:40.910 --> 00:33:43.690
but that you only ever actually instantiate one of.

00:33:43.690 --> 00:33:46.779
If this gets in lined of course, this will go away.

00:33:46.779 --> 00:33:51.950
If it turns out that the function is not in
lined, the compiler will still notice that only,

00:33:51.950 --> 00:33:56.559
that this function was only ever called
with this single value of the variable

00:33:56.559 --> 00:33:59.589
and so the compiler will simply eliminate it.

00:33:59.589 --> 00:34:06.179
It will remove the function parameter and will
replace the parameter in the actually function

00:34:06.180 --> 00:34:08.820
with the constant value that it always has.

00:34:08.820 --> 00:34:16.289
So you can use this kind of code without worrying
about any penalty for passing extra parameters around.

00:34:16.289 --> 00:34:27.029
So in summary, we're working on a new technology,
GCC 4.2, it's not available yet but it will be we hope.

00:34:27.030 --> 00:34:33.750
Among some of the significant new features are OpenMP,
symbol visibility improvements, some new optimizations

00:34:33.750 --> 00:34:37.510
and of course the ability to upgrade
individual warnings to errors.

00:34:37.510 --> 00:34:43.700
So now to talk about an even newer compiler
technology will be my good friend, Chris Lattner.

00:34:43.699 --> 00:34:43.739
( applause )

00:34:43.739 --> 00:34:45.279
>> Thank you.

00:34:45.280 --> 00:34:52.360
Hello everyone.

00:34:52.360 --> 00:34:54.070
My name is Chris Lattner.

00:34:54.070 --> 00:34:57.160
I am the manager of the LLVM group at Apple.

00:34:57.159 --> 00:35:01.789
I'm also the founder and architect
of the LLVM open source project.

00:35:01.789 --> 00:35:08.119
So, okay so, LLVM is a little bit
different than GCC in a lot of ways.

00:35:08.119 --> 00:35:11.009
The biggest of which is that it's not a compiler.

00:35:11.010 --> 00:35:12.760
Well what does that mean?

00:35:12.760 --> 00:35:18.360
It's actually a collection of technologies that you
can use to build things like compilers and other tools.

00:35:18.360 --> 00:35:25.240
LLVM specifically consists of many libraries and so
if you're familiar with framework based development,

00:35:25.239 --> 00:35:30.979
it's exactly what you're familiar with,
we just have lots of different components

00:35:30.980 --> 00:35:34.579
and tools can choose the components
that they're interested in and use them.

00:35:34.579 --> 00:35:36.319
Today I'll talk about three components.

00:35:36.320 --> 00:35:41.950
The JIT, the GCC integration layer and
the link time optimization components.

00:35:41.949 --> 00:35:46.849
As I mentioned before, LLVM is an open
sourced project and so you can go

00:35:46.849 --> 00:35:50.769
to the llvm.org website and you can read all about it.

00:35:50.769 --> 00:35:55.739
I'll talk about a couple of applications
we're using LLVM for today.

00:35:55.739 --> 00:35:58.979
So today specifically I'll be talking about two things.

00:35:58.980 --> 00:36:05.619
The first is Leopard and the second is future plug ins
with GCC 4.2 that we're planning on building.

00:36:05.619 --> 00:36:13.009
And so I'll start out by talking about LLVM and
Leopard and to do that I wanna talk about OpenGL.

00:36:13.010 --> 00:36:19.180
The funny thing about OpenGL is that your into
compiler talk right, you're not into graphics talk.

00:36:19.179 --> 00:36:21.980
So what do compilers and graphics
have to do with each other right.

00:36:21.980 --> 00:36:25.519
I mean if you wanted to talk graphic,
you'd go somewhere else.

00:36:25.519 --> 00:36:30.780
Well as graphics have been developing and
as graphics technology has been improving,

00:36:30.780 --> 00:36:36.940
the GPU's have been getting more and more general and
the things that the OpenGL stack has been expected

00:36:36.940 --> 00:36:40.400
to do has been getting more and more
advanced and much more aggressive.

00:36:40.400 --> 00:36:47.000
So what we've been finding is that graphics, compilers
and other technologies are starting to converge

00:36:47.000 --> 00:36:50.360
and there are a lot of things that OpenGL
has to do that starts to look and smell

00:36:50.360 --> 00:36:53.250
and feel a little bit like a compiler problem.

00:36:53.250 --> 00:36:57.760
So for example, OpenGL has this
concept of a vertex program.

00:36:57.760 --> 00:37:05.970
A vertex program is a small program that an application
ships with that at run time, it is uploaded onto the GPU

00:37:05.969 --> 00:37:11.329
and every vertex that's sent down the pipeline for
example if you're drawing triangles or polygons whatever,

00:37:11.329 --> 00:37:15.239
each vertex has to be transformed by this program.

00:37:15.239 --> 00:37:24.119
And so in OpenGL, if you have vertex programs the typical
way this works is the application developer writes a GLSL

00:37:24.119 --> 00:37:26.099
for example, a vertex program.

00:37:26.099 --> 00:37:27.299
These are text files.

00:37:27.300 --> 00:37:28.910
These ship with the application.

00:37:28.909 --> 00:37:32.420
These are included in their application bundle or whatever.

00:37:32.420 --> 00:37:37.019
At run time, the application says okay,
I'm gonna upload these programs to the GPU.

00:37:37.019 --> 00:37:43.030
Well what that means is that when your levels load in
or when Keynote's building its transitions or whatever,

00:37:43.030 --> 00:37:48.900
whenever's a convenient time, it sends this to the driver
and it says okay driver, I'm going to have to send lots

00:37:48.900 --> 00:37:53.369
of polygons through you with this
program, think about it for a while.

00:37:53.369 --> 00:37:56.150
Well there's a couple of different
ways that OpenGL can do this right?

00:37:56.150 --> 00:38:04.910
I mean, ideally you want the graphics card to support your
program and so the driver gets this thing, it processes it,

00:38:04.909 --> 00:38:08.730
figures out how to configure the GP to support
it and then when you send all the polygons

00:38:08.730 --> 00:38:13.429
down the pipe, it transforms them and draws them.

00:38:13.429 --> 00:38:16.190
Unfortunately life's not always that simple though.

00:38:16.190 --> 00:38:21.789
Specifically if your graphics card isn't as capable as
you'd hoped, for example you might have embedded graphics,

00:38:21.789 --> 00:38:26.289
you might have one of the early Mac minis,
it might not be able to support the program.

00:38:26.289 --> 00:38:31.329
GLSL is actually a very interesting language
in that it's very generic and very high level

00:38:31.329 --> 00:38:36.590
and a lot of the capabilities of GLSL supports,
actually aren't supported by any graphics cards

00:38:36.590 --> 00:38:40.309
that you can buy today or probably in the near future.

00:38:40.309 --> 00:38:42.579
It supports many, many things.

00:38:42.579 --> 00:38:47.429
For example, very large programs,
branching, looping, memory accesses.

00:38:47.429 --> 00:38:50.190
A lot of different things that a lot of GPs can't support.

00:38:50.190 --> 00:38:58.829
So because OpenGL has to support the full subset or
the full spectrum of GLSL applications or programs,

00:38:58.829 --> 00:39:05.440
if the graphics card can't support it, it has to fall
back and one option is to fall back to an interpreter.

00:39:05.440 --> 00:39:10.920
The problem with falling back to an interpreter for this is
that interpreters as you might expect, are very slow right

00:39:10.920 --> 00:39:12.750
and falling back to an interpreter when you're

00:39:12.750 --> 00:39:19.789
about to send a few billion vertices
down the graphics pipeline is very bad.

00:39:19.789 --> 00:39:25.409
So the solution then is to say well we compiler
people know something about JIT compilers right.

00:39:25.409 --> 00:39:31.529
JIT compilers are a great way to implement
a language, in this case a graphics language

00:39:31.530 --> 00:39:34.400
and you know, spend a little bit of time up front.

00:39:34.400 --> 00:39:39.730
So that you spends some time making code that's
better so that when you send lots of vertices

00:39:39.730 --> 00:39:43.710
down the pipeline it will be executed more quickly.

00:39:43.710 --> 00:39:51.710
So specifically, the way the LLVM gets involved with this,
is that you have this several stages of this pipeline

00:39:51.710 --> 00:39:57.780
and in Leopard for example, your application
starts up, it uploads it's program OpenGL gets it.

00:39:57.780 --> 00:40:02.490
If it decides it can't hit the hardware, the hardware
doesn't support it for one reason or another,

00:40:02.489 --> 00:40:07.869
then it actually has a translator where it
takes the GLSL and converts it into LLVM code

00:40:07.869 --> 00:40:14.079
and LLVM has this internal code representation which
the optimizers use and the code generators understand

00:40:14.079 --> 00:40:21.340
and so it's this mid level representation that the set
of frameworks we have understands and can chew on them.

00:40:21.340 --> 00:40:27.380
Once it's in that form, LLVM among other things, has an
optimizer, has a full suite of scaler optimizations,

00:40:27.380 --> 00:40:31.650
loop transformations and standard kinds of
authorizations you'd expect to be in a compiler.

00:40:31.650 --> 00:40:37.490
Well it has these available in a library
and so because these are easy to reuse,

00:40:37.489 --> 00:40:42.250
the OpenGL code that's been transformed to LLVM,
can now make use of the same authorizations.

00:40:42.250 --> 00:40:48.719
Once the code has been optimized, we send it through
the standard LLVM code generator and the LLVM JIT

00:40:48.719 --> 00:40:54.759
and this allows you to get out at the end,
sequences of highly optimized SSE or Altivec code

00:40:54.760 --> 00:40:59.250
that can process your vertex, your
vertices or your pixels very,

00:40:59.250 --> 00:41:03.230
very quickly and it's much better
than interpreting obviously.

00:41:03.230 --> 00:41:07.250
So once you have that code of course,
OpenGL then runs it on the all the pixels

00:41:07.250 --> 00:41:10.260
and all the vertices coming down the pipe.

00:41:10.260 --> 00:41:17.460
So that's kind of a high level example of how
in Leopard right now, OpenGL is using LLVM.

00:41:17.460 --> 00:41:24.429
So the problem with that example is that it's a high
impact example that a lot of people don't understand,

00:41:24.429 --> 00:41:28.889
so I'll give you a much more concrete,
easier to understand example here.

00:41:28.889 --> 00:41:31.839
So imagine you are a graphics card.

00:41:31.840 --> 00:41:33.730
If you're a graphics card, you have a very simple mind.

00:41:33.730 --> 00:41:38.170
You understand very small sets of for example color formats.

00:41:38.170 --> 00:41:45.440
So you might understand eight bit per pixel images
and you might want RGBA, a very standard format.

00:41:45.440 --> 00:41:51.460
The problem is that OpenGL supports a gigantic
amount of color form, that actually supports hundreds

00:41:51.460 --> 00:41:55.309
and so these things might you know, be
packed so you have five bits per pixel

00:41:55.309 --> 00:41:59.259
or they might have two bits of alpha
and four bits of this you know.

00:41:59.260 --> 00:42:03.740
There's all these different ways of encoding colors
and images and when you say upload this texture

00:42:03.739 --> 00:42:09.669
to the graphics card, there's this transition that has
to happen that maps from what the application knows

00:42:09.670 --> 00:42:14.099
and what the image format is, into
what the graphics card understands.

00:42:14.099 --> 00:42:20.960
And this has to happen before the image actually even
gets to the GPU, so this always has to happen on the CPU.

00:42:20.960 --> 00:42:26.230
So the way this works is that you have code in the OpenGL
stack that looks like this and basically it says

00:42:26.230 --> 00:42:32.400
that if I have an image, I'm going to loop over
all the pixels in the image and for every pixel,

00:42:32.400 --> 00:42:36.680
I'm going to map it out of the encoding format,
so I have this gigantic switch statement

00:42:36.679 --> 00:42:41.989
and the switch statement has hundreds of cases in it and
I will decode all of the different fields of the pixel,

00:42:41.989 --> 00:42:47.179
you know pull out the red, the green, the alpha,
the blue and decode them into the common format.

00:42:47.179 --> 00:42:51.539
Then I'll do another switch statement
which again has the same hundreds of cases

00:42:51.539 --> 00:42:54.789
and it will recompress these back
into the destination format.

00:42:54.789 --> 00:42:56.570
All right.

00:42:56.570 --> 00:43:01.440
So the reason that the code has to be written this
way is that you have hundreds of formats to deal with

00:43:01.440 --> 00:43:06.210
and if you were to make a specialized version of
this function, it would have to be specialized

00:43:06.210 --> 00:43:10.559
for n squared combinations which are thousands
and thousands of different combinations right.

00:43:10.559 --> 00:43:16.369
There's no way that we can ship OpenGL which has to
be statically compiled, with thousands and thousands

00:43:16.369 --> 00:43:20.029
of different permientations of
this, it just wouldn't scale right.

00:43:20.030 --> 00:43:22.620
So fortunately at run time, we actually do know

00:43:22.619 --> 00:43:26.639
which formats the application's using
and so we can do better than that.

00:43:26.639 --> 00:43:32.989
And so specifically if we see your application's
uploading a lot of you know, five bit per pixel images,

00:43:32.989 --> 00:43:38.589
well we can actually realize that we should
make a specialize version of this code.

00:43:38.590 --> 00:43:44.410
So we can actually take the four loop, we can
take the code just for the case that you care

00:43:44.409 --> 00:43:51.289
about that decodes the pixels and then add the code that
recompresses the pixels and you get a nice simple four loop,

00:43:51.289 --> 00:43:54.250
which just has you know, say a dozen operations.

00:43:54.250 --> 00:43:59.659
These operations have no switching, it has no indirect
branching, it's all very simple bit manipulation code.

00:43:59.659 --> 00:44:06.119
Well, furthermore again, we have the LLVM optimizer around
and so the optimizer's very good at stamping out you know,

00:44:06.119 --> 00:44:09.569
extra bit shifting and masking and things like that.

00:44:09.570 --> 00:44:15.840
The end result of this is that when you JIT
compile this, suddenly you have a very small loop.

00:44:15.840 --> 00:44:21.890
It can be unrolled and optimized and suddenly instead of
spending all your time doing indirect jumps and switches

00:44:21.889 --> 00:44:26.859
and things like that, you're spending all the time
streaming through memory and doing actual useful work.

00:44:26.860 --> 00:44:34.740
All right and so this is a fundamentally run time you
know, dynamic kind of application where you can't do this

00:44:34.739 --> 00:44:40.659
without a runtime version of a compiler, it's
just you don't have enough information you know,

00:44:40.659 --> 00:44:42.829
in the factory before you ship.

00:44:43.969 --> 00:44:49.309
So to give you an example of the impact of this,
I just ran some benchmarks where I timed you know,

00:44:49.309 --> 00:44:53.829
how fast it is to convert images from one
format to another on Tiger and on Leopard.

00:44:53.829 --> 00:44:58.069
Again, the problem with this is that you know,
there's hundreds of different foundations

00:44:58.070 --> 00:45:05.000
and you get all these different numbers and it's
not, I'm not gonna walk through all of this right.

00:45:05.000 --> 00:45:11.869
So what I ended up doing is I ended up doing a summary
and the impact of just the color format conversion,

00:45:11.869 --> 00:45:18.259
if you look at the average across all the different formats,
shows a 5.4x speed up going from Tiger

00:45:18.260 --> 00:45:22.250
to Leopard and this is just by using the dynamic
techniques and being able to actually optimize

00:45:22.250 --> 00:45:25.460
and produce specialized code that
eliminates all the branching over it.

00:45:25.460 --> 00:45:30.010
All right, well if that's the average
speed up, one of the interesting things is

00:45:30.010 --> 00:45:34.540
that you get much higher peak speed
ups in certain cases and so you know,

00:45:34.539 --> 00:45:39.119
one case we got a 19.3x
speed up which is pretty ridiculous.

00:45:39.119 --> 00:45:45.079
That goes from 13 megabytes per second that you
can translate to 257 megabytes.

00:45:45.079 --> 00:45:50.039
Well the reason for this is that you know,
in this particular color conversion case,

00:45:50.039 --> 00:45:55.230
where you're converting you know, RGB
4_4_4_4 to the same thing but byte reverse.

00:45:55.230 --> 00:45:59.240
Well the optimizer's able to see that you know,
you have this very simple transformation happening

00:45:59.239 --> 00:46:02.609
and it was actually able to simplify
the code a lot all right.

00:46:02.610 --> 00:46:09.769
But the what this means is certain cases which
should be very simple and very cheap to do, now are.

00:46:10.780 --> 00:46:15.960
So that's an example of how we're using LLVM in Leopard.

00:46:15.960 --> 00:46:21.019
We're also planning on doing many other things with
it and one of the things I wanna talk about is GCC 4.2.

00:46:21.019 --> 00:46:26.610
So Jeff talked about GCC 4.2 earlier in the talk.

00:46:26.610 --> 00:46:30.680
So integrating LLVM with GCC, what does that really mean?

00:46:30.679 --> 00:46:33.710
Basically the idea is we all know and love GCC right?

00:46:33.710 --> 00:46:41.320
We use the driver and we use command line either
directly with our make files or indirectly through Xcode

00:46:41.320 --> 00:46:47.870
and when we get errors and warnings and messages, we
get it from the GCC front end and so staying compatible

00:46:47.869 --> 00:46:53.969
with all your code out there is really important to us
and so we decided well, we should marry the GCC front end

00:46:53.969 --> 00:46:57.609
with some new technology for the optimizer in the back end.

00:46:57.610 --> 00:47:02.670
And so the idea here is that we'll take the GCC front
end which is just the stock 4.2 front end.

00:47:02.670 --> 00:47:07.360
This preserves compatibility with all the command
line options, all the warnings, all you know,

00:47:07.360 --> 00:47:11.789
it sets the language that you know, the
pickiness of the language that it accepts.

00:47:11.789 --> 00:47:13.070
It's all the same as GCC 4.2.

00:47:13.070 --> 00:47:18.140
The difference though is that we're taking
the LLVM optimizer and the LLVM code generator,

00:47:18.139 --> 00:47:24.159
again these are the exact same libraries used by
OpenGL or available on the open source website

00:47:24.159 --> 00:47:30.139
and we're replacing the GCC optimizer and
the GCC code generator with LLVM versions.

00:47:30.139 --> 00:47:32.179
Well, what does this do?

00:47:32.179 --> 00:47:33.940
Well there's a couple things this does.

00:47:33.940 --> 00:47:40.200
One is you get significantly better code
in some cases, as usual not always right.

00:47:40.199 --> 00:47:42.250
We, compilers can only do so much.

00:47:42.250 --> 00:47:46.769
It can't eliminate the n squared
algorithms from your code for you.

00:47:46.769 --> 00:47:50.259
But, it also gives you new capabilities
and one of the things

00:47:50.260 --> 00:47:54.970
that it lets you do is it lets you do
optimization across files in your application.

00:47:54.969 --> 00:47:58.689
So specifically right now today,
if you pick your application,

00:47:58.690 --> 00:48:02.789
it might contain a few hundred source files right.

00:48:02.789 --> 00:48:09.489
Today, GCC will only optimize within each file, which means
that if you have trivial, little, small programs, trivial,

00:48:09.489 --> 00:48:15.669
little, small functions in one file, you can't in line
those into other files, you can't propagate constants

00:48:15.670 --> 00:48:23.200
across files, you can't delete dead code that's
you know, only visible once you link the image.

00:48:23.199 --> 00:48:26.919
The linker has the ability to do this,
but the linker only see the machine code.

00:48:26.920 --> 00:48:29.240
So it can't do high level transformations.

00:48:29.239 --> 00:48:35.849
To be clearer, the linker can do dead code elimination,
but the linker can't do high level optimizations.

00:48:35.849 --> 00:48:41.789
Well so the idea with LLVM GCC is that suddenly you can say
okay, I'm going to use the exact same command line options,

00:48:41.789 --> 00:48:48.070
I'm gonna use exactly everything that I normally do
with GCC, but I'm just going to specify 04 all right.

00:48:48.070 --> 00:48:54.720
This is our very simple, simplified user interface
that even compiler people like me can understand.

00:48:54.719 --> 00:48:58.429
And from there it's very simple.

00:48:58.429 --> 00:49:02.789
You compile your application, at compile
time you're building .o files,

00:49:02.789 --> 00:49:04.980
at link time we're invoking the linker.

00:49:04.980 --> 00:49:09.110
Now these .o files are a little bit
different than standard macho .o files.

00:49:09.110 --> 00:49:13.740
They contain extra information and so
right now, we haven't enhanced nm or otool,

00:49:13.739 --> 00:49:16.239
for example, because they don't understand them.

00:49:16.239 --> 00:49:22.939
But the important thing is that when you invoke the linker,
the Leopard linker then starts reading these .o files,

00:49:22.940 --> 00:49:27.860
it starts reading the native o files and it
sees ah ha, these are LLVM enhanced .o files

00:49:27.860 --> 00:49:31.610
and it can actually invoke the LLVM optimizer at link time.

00:49:31.610 --> 00:49:35.960
Well at link time, you application has a
lot more context, a lot more information.

00:49:35.960 --> 00:49:43.460
It can see for example if you're using anonymous namespaces
or visibility hidden, it knows which symbols can be imported

00:49:43.460 --> 00:49:49.000
and exported out of you know, the different libraries and
dilibs you're linking, it can see your application,

00:49:49.000 --> 00:49:52.659
you know if you're linking your whole application
together at once, it has a lot of information.

00:49:52.659 --> 00:49:59.899
A lot of things only become visible at the linker and
based on that information, the export lists and you know,

00:49:59.900 --> 00:50:04.220
whether you're compiling things for the whole program,
things like that, the optimizer has a lot more freedom

00:50:04.219 --> 00:50:09.189
and LLVM in general will do cross,
cross function optimizations

00:50:09.190 --> 00:50:13.039
at compile time, but that's only within a single file.

00:50:13.039 --> 00:50:16.789
By doing it in the linker, that means you can
optimize across files and that includes things

00:50:16.789 --> 00:50:21.269
like dead code elimination and procedural
constant propagation, in lining,

00:50:21.269 --> 00:50:29.130
a whole host of other interesting inter procedural
authorizations which I won't get into right now.

00:50:29.130 --> 00:50:35.000
So another interesting aspect of this is that this is all
completely language independent and so not only does it work

00:50:35.000 --> 00:50:41.739
with Objective-C++ or Objective-C, it also works
with C++ and C and so anything that you can send

00:50:41.739 --> 00:50:50.519
through LLVM GCC, we support the same languages that
GCC does, can all be compiled as usual, just with 04,

00:50:50.519 --> 00:50:55.929
linked together and optimized across the language
boundaries, meaning you can in line a C++ method

00:50:55.929 --> 00:51:02.119
into an Objective-C message or you know,
across these different language boundaries.

00:51:02.119 --> 00:51:05.750
Which is actually surprisingly powerful
and important in some cases because,

00:51:05.750 --> 00:51:12.559
due to wanting to build modular libraries and
building our applications with abstractions,

00:51:12.559 --> 00:51:17.250
we wanna preserve the abstractions for the programmer,
but we want the optimizer to eliminate them where it can.

00:51:17.250 --> 00:51:22.090
So another interesting thing about this is this actually
works really well with native .o files as well.

00:51:22.090 --> 00:51:26.390
You don't have to rebuild your entire
application with LLVM to get this.

00:51:26.389 --> 00:51:32.960
This means that if you have old archives that have crusty
.o files built ages ago, you can still use those.

00:51:32.960 --> 00:51:37.050
If you wanna use ICC or GCC for certain pieces
of your application, that's totally fine.

00:51:37.050 --> 00:51:43.130
The only disadvantage of this is the LLVM will
see relatively less of your application or dilib,

00:51:43.130 --> 00:51:47.039
so it won't be able to know the full effects of
that code and so we'll have to be more conservative.

00:51:47.039 --> 00:51:52.449
But it will work correctly just fine, it
just reduces the scope of optimization.

00:51:52.449 --> 00:51:58.299
Okay, so this was a whirlwind summary of
some of the things we're doing with LLVM.

00:51:58.300 --> 00:52:04.710
The big pic, take away picture of this is the
LLVM is a framework for building compilers.

00:52:04.710 --> 00:52:09.070
We're not planning on exposing
that framework to end developers.

00:52:09.070 --> 00:52:12.420
If you're interested you can get it off
the web page, it's an open source project

00:52:12.420 --> 00:52:15.740
and we're contributing a lot of code to it.

00:52:15.739 --> 00:52:20.839
We're working very closely with the community
so that we're working with generally main line.

00:52:20.840 --> 00:52:27.870
The two things that we're doing in the short term is
that we are actively using OpenGL or actively using LLVM

00:52:27.869 --> 00:52:35.269
in the OpenGL stack and Leopard today and
last WWDC for that matter uses LLM internally.

00:52:35.269 --> 00:52:41.980
In the future we plan on or we hope to
have a LLVM GCC that we ship to customers,

00:52:41.980 --> 00:52:49.269
this LLVM GCC is aimed at supporting the GCC 4.2
front end and when and if we actually ship this,

00:52:49.269 --> 00:52:51.340
we it will be a drop in replacement for GCC.

00:52:51.340 --> 00:52:55.250
It'll work in, work, feel and smell just like GCC.

00:52:55.250 --> 00:53:02.460
So the it's as easy as selecting a new
compiler in the Xcode compiler list.

00:53:02.460 --> 00:53:06.320
So that is the end of the talk.

00:53:06.320 --> 00:53:13.760
In summary today, Geoff described some of the new
features that Leopard brings to GCC 4.2,

00:53:13.760 --> 00:53:18.430
GCC 4.2 has a number of new things, in
particular the security features are really cool

00:53:18.429 --> 00:53:21.139
and you should try them out.

00:53:21.139 --> 00:53:26.639
Going forward, GCC 4.0 will become
the stable critical bug fix only compiler

00:53:26.639 --> 00:53:30.579
and so the 4.0 in Leopard will be basically frozen.

00:53:30.579 --> 00:53:33.539
Going forward, 4.2 is the new development vehicles.

00:53:33.539 --> 00:53:37.489
This will bring most of the new
improvements and new enhancements in GCC.

00:53:37.489 --> 00:53:42.449
Immediately the first obvious things are things
like OpenMP, there's new optimization improvements,

00:53:42.449 --> 00:53:46.489
the visibility improvements, there's
a lot of things coming there.

00:53:46.489 --> 00:53:49.359
LLVM is a new technology that we're developing.

00:53:49.360 --> 00:53:51.870
It's very technology oriented.

00:53:51.869 --> 00:53:54.960
We're trying to use it for a number of different things.

00:53:54.960 --> 00:53:56.539
Today it's an OpenGL.

00:53:56.539 --> 00:54:01.659
In the future hopefully it will be a stand
alone compiler that you can use on the system.

00:54:01.659 --> 00:54:05.679
If you wanna try it out right now, you
can download LLVM GCC off the website.

00:54:05.679 --> 00:54:08.460
There is a 2.0 release a
couple weeks ago, that's really cool.

00:54:08.460 --> 00:54:09.960
You should try it out.
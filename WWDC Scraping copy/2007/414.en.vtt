WEBVTT

00:00:20.019 --> 00:00:21.660
>> Good afternoon.

00:00:21.660 --> 00:00:29.219
Welcome to our session:  Creating High
Quality Content With QuickTime APIs.

00:00:29.219 --> 00:00:31.539
My name is Kaz Ohta.

00:00:31.539 --> 00:00:36.280
There will be Sayli Benadikar and
Brian Pietsch joining me later

00:00:36.280 --> 00:00:41.760
in this session to cover some of the topics.

00:00:44.549 --> 00:00:49.909
So what we're going to talk about
at this session is the kinds

00:00:49.909 --> 00:00:57.750
of things you can do using QuickTime to help create content.

00:00:57.750 --> 00:01:03.579
Basically, when you create content it
usually involves some sort of work flow.

00:01:03.579 --> 00:01:06.780
As much as shown in this diagram.

00:01:06.780 --> 00:01:13.849
You might have seen a nicer version of a
similar diagram in the previous session.

00:01:13.849 --> 00:01:23.389
Basically you can start capturing material video
content and process it, or possibly edit it.

00:01:23.390 --> 00:01:36.450
And then encode the content for delivering to your
final destination, including things like iPod or Apple TV.

00:01:37.590 --> 00:01:43.770
QuickTime can be a help in each of those stages.

00:01:43.769 --> 00:01:48.759
Today I would like to focus on a few areas.

00:01:48.760 --> 00:01:51.200
One is about audio processing.

00:01:51.200 --> 00:01:55.270
We covered pretty much the video
stuff in the previous session.

00:01:55.269 --> 00:02:02.549
I would like to spend some time in the session
talking about the audio aspect of QuickTime.

00:02:02.549 --> 00:02:11.139
What you can do with the QuickTime API, like
extracting uncompressed audio or playing audio effects.

00:02:11.139 --> 00:02:21.239
Then we're going to talk about closed caption, which is
a new feature of QuickTime we added in QuickTime 7.1.6.

00:02:21.240 --> 00:02:27.270
We're going to talk about how you add
closed captioning to QuickTime Movies

00:02:27.270 --> 00:02:33.890
and how you can play closed captions
along with QuickTime Movie.

00:02:33.889 --> 00:02:39.379
Then finally, we're going to talk
about exporting QuickTime Movie.

00:02:39.379 --> 00:02:49.759
We're going cover some basic way of exporting QuickTime
Movie into various file format, and we also cover a way

00:02:49.759 --> 00:02:56.989
to export to specific format,
including device formats.

00:02:56.990 --> 00:03:00.480
One of the device formats like iPod and Apple TV.

00:03:01.599 --> 00:03:05.769
Now I would like to bring up Sally Benatika.

00:03:05.770 --> 00:03:09.170
She is going to cover the audio aspect of the session.

00:03:09.169 --> 00:03:10.789
Sally?

00:03:10.789 --> 00:03:13.389
>> Thanks, Kaz.

00:03:16.460 --> 00:03:17.010
Hi everyone.

00:03:17.009 --> 00:03:18.289
I am Sally.

00:03:18.289 --> 00:03:23.599
And in this first session we're going talk
about some of the QuickTime audio APIs

00:03:23.599 --> 00:03:30.030
that you can use during the processing
step of your content creation work flow

00:03:31.819 --> 00:03:42.099
So when we think about dealing with audio in QuickTime land,
here are some of the APIs that you might think of using.

00:03:42.099 --> 00:03:47.579
On the left-hand section you have more of
the presentation or the playback set of APIs.

00:03:47.580 --> 00:03:53.190
Things that you can use the control the rate,
pitch, volume, et cetera during playback.

00:03:53.189 --> 00:04:01.009
Or metering APIs to get at the characteristics
such as volume or frequent levels.

00:04:01.009 --> 00:04:06.840
The data that is modified by these APIs isn't persistent.

00:04:06.840 --> 00:04:10.219
It doesn't save across exports

00:04:10.219 --> 00:04:17.689
On the other side you have more of the authoring APIs
like the SC audio compression API set which you can use

00:04:17.689 --> 00:04:22.819
to configure your export settings,
export compression settings.

00:04:22.819 --> 00:04:30.269
And then there's movie audio extraction, which is
your way of getting at uncompressed movie audio data.

00:04:30.269 --> 00:04:37.349
And sitting in the middle you have the audio context
APIs useful for both presentation as well as authoring.

00:04:37.350 --> 00:04:45.990
The audio contexts, this abstract notion of
an audio rendering of an audio environment.

00:04:45.990 --> 00:04:53.750
And every movie has its own audio context, and there's
this concept of playing to a destination context.

00:04:53.750 --> 00:04:59.459
So if you're doing regular playback your
destination is an audio device context.

00:04:59.459 --> 00:05:03.469
If you're extracting, your destination
is an extraction context.

00:05:03.470 --> 00:05:10.760
So today we are going to focus mainly on these
two API sets, the movie audio extraction set.

00:05:10.759 --> 00:05:17.670
And in addition to the audio context
APIs dealing with inserts.

00:05:17.670 --> 00:05:22.060
So let's dive right into movie audio extraction.

00:05:22.060 --> 00:05:24.490
What exactly is this?

00:05:24.490 --> 00:05:32.040
This is your way of accessing uncompressed
audio data of the movie.

00:05:32.040 --> 00:05:37.280
And you can choose to have this data such that all
the data from all the tracks is mixed together.

00:05:37.279 --> 00:05:39.019
Or you can choose not to have it.

00:05:39.019 --> 00:05:44.029
So I like to make a distinction
here between extraction and export.

00:05:44.029 --> 00:05:50.299
Export is when you're converting usually from
one kind of compressioned format to another.

00:05:50.300 --> 00:05:56.490
Extraction is when you're converting a
compressed format to uncompressed PCM audio data.

00:05:57.990 --> 00:06:00.230
This is our recommended API.

00:06:00.230 --> 00:06:04.210
It was introduced in QuickTime 7,

00:06:04.209 --> 00:06:08.579
prior to which developers had to
resort to all sorts of trickery

00:06:08.579 --> 00:06:14.189
and tedious combinations of things to get this end result.

00:06:14.189 --> 00:06:19.079
But since its introduction we'd like you to use
this instead of any of the other alternatives.

00:06:19.079 --> 00:06:26.899
And I will show you in the next slide how easy it
is to work with the movie audio extraction APIs.

00:06:26.899 --> 00:06:31.329
Another cool thing about this, is that it's thread safe.

00:06:31.329 --> 00:06:36.539
So you can have little Elf worker threads in
the background doing your extraction for you.

00:06:36.540 --> 00:06:45.080
There's a caveat here, of course, that the decoder that
you're using for the extraction needs to be thread safe.

00:06:45.079 --> 00:06:51.949
And finally, if you are extracting using these
APIs, the extraction is highly configureable.

00:06:51.949 --> 00:06:58.949
By this I mean that you can specify what the output
data is going to look like at the end of the extraction.

00:06:58.949 --> 00:07:02.899
You can specify the target format.

00:07:02.899 --> 00:07:10.679
By this I mean sample rate, as well as what specific kind
of uncompressed data you want, which is either floater in 16

00:07:10.680 --> 00:07:13.910
or 32-bit big endian, little endian, et cetera.

00:07:13.910 --> 00:07:17.210
And also the channel layout.

00:07:17.209 --> 00:07:22.939
You can use the start time property
to specify a particular end point

00:07:22.939 --> 00:07:26.889
if you don't want to start the extraction at sample zero.

00:07:26.889 --> 00:07:33.120
And the All Channels Discrete property
allows you to completely disable mixing.

00:07:33.120 --> 00:07:38.379
So by default what happens is like
channeled from the different tracks together.

00:07:38.379 --> 00:07:44.310
But if you set this property then you
get all the channels separated in order.

00:07:44.310 --> 00:07:47.209
So that can be a useful thing.

00:07:47.209 --> 00:07:51.409
Let's look at some code at a pseudo code level.

00:07:51.410 --> 00:07:54.040
Just to show you how easy it is to use these APIs.

00:07:54.040 --> 00:07:57.220
You can think of this as a four-step process.

00:07:57.220 --> 00:08:00.970
Step number one is begin extraction.

00:08:00.970 --> 00:08:06.740
Step number two is where you can configure
your particular extraction instance.

00:08:06.740 --> 00:08:11.259
And the way you can figure this is by Set Property Calls.

00:08:11.259 --> 00:08:15.509
We have various properties for the various
things I mentioned in the previous slide.

00:08:15.509 --> 00:08:20.569
So say you want to set a particular target format.

00:08:20.569 --> 00:08:24.610
You would use the Audio Stream Basic Description property.

00:08:24.610 --> 00:08:26.960
You accept that property.

00:08:26.959 --> 00:08:32.710
The way you do this it usually you get a property, you
modify the fields you want to change and set it back.

00:08:32.710 --> 00:08:35.970
So that's how you change the audio
stream based on description.

00:08:35.970 --> 00:08:39.740
If you want to specify a particular
layout that's the property you would use.

00:08:39.740 --> 00:08:48.840
You can use the current time property to settle
a specific end time that's not time zero.

00:08:48.840 --> 00:08:52.100
And the All Channels Discreet property to disable mixing.

00:08:52.100 --> 00:08:53.560
So that's step number two.

00:08:53.559 --> 00:08:59.379
So at the end of this you have a configured
extraction section that you're ready to use.

00:08:59.379 --> 00:09:00.399
So what do you do?

00:09:00.399 --> 00:09:06.669
You pull from the data by calls to
movie audio extraction fill buffer.

00:09:06.669 --> 00:09:08.870
Once you have the -- this happens in a loop.

00:09:08.870 --> 00:09:13.779
So every time you get a buffer of data you are
write it to fileor whatever you want to do it with.

00:09:13.779 --> 00:09:21.169
And you can go on until there's no more data to extract,
or say you want to extract just a specific duration,

00:09:21.169 --> 00:09:27.299
then you keep track of how many samples you have
extracted and get out of the loop once you're done.

00:09:27.299 --> 00:09:30.559
And step number four, you just send the extraction.

00:09:30.559 --> 00:09:37.819
So you can see that QuickTime here has handled
a lot of the intricacies related to setting

00:09:37.820 --> 00:09:41.450
up of the audio converter, setting up of mixers, et cetera.

00:09:41.450 --> 00:09:47.360
All that is abstracted away from you and you just get
this really clean high level, convenient API to use.

00:09:47.360 --> 00:09:56.409
So we strongly encourage that you use it if your
goal is to get the decoded audio movie data.

00:09:56.409 --> 00:10:03.809
The second API said that we saw in the
figure is the audio context inserts.

00:10:03.809 --> 00:10:09.179
And we've added a new -- this inside API is new in Leopard.

00:10:09.179 --> 00:10:11.739
And what exactly is it?

00:10:11.740 --> 00:10:17.299
It's a way to tap into the QuickTime audio rendering chain.

00:10:17.299 --> 00:10:23.579
And those tap points can be made during
playback, as well as movie audio extraction.

00:10:23.580 --> 00:10:29.440
Once -- once you have access to QuickTime's
data along this chain you can do all sorts

00:10:29.440 --> 00:10:31.780
of interesting things with it in your app.

00:10:31.779 --> 00:10:37.769
If this is during playback you could just watch the
samples go by and do things like data visualization, or --

00:10:37.769 --> 00:10:44.829
if it's play -- either during playback or extraction
you can get the data, add cool effects to it,

00:10:44.830 --> 00:10:48.160
and hand it back to QuickTime for the rendering.

00:10:48.159 --> 00:10:55.009
So what's cool about this is that until now
QuickTime's audio chain has been sort of a black box.

00:10:55.009 --> 00:10:57.319
You haven't been able to get into it.

00:10:57.320 --> 00:11:00.230
And this gives you points that you can actually tap into.

00:11:00.230 --> 00:11:06.200
And you can have -- you can attach inserts both
at the movie level as well as the track level.

00:11:06.200 --> 00:11:11.670
The movie level works on all the audio
data of the movie that's mixed together.

00:11:11.669 --> 00:11:18.689
Track level as the name suggests operates
on just the data of a particular track.

00:11:18.690 --> 00:11:21.440
So I thought a diagram would help here.

00:11:21.440 --> 00:11:24.910
So this is a general audio flow diagram.

00:11:24.909 --> 00:11:33.539
We have a movie with two tracks and they mix together and
that data is then further sent to an extraction context,

00:11:33.539 --> 00:11:36.019
because this example deals with extraction.

00:11:36.019 --> 00:11:42.509
If we were playing back instead then that
mixed data would be sent out to device.

00:11:42.509 --> 00:11:45.120
So a little more detail in that same diagram.

00:11:45.120 --> 00:11:47.500
Let's say you have two kinds of tracks.

00:11:47.500 --> 00:11:49.950
One's stereo, the other has three channels.

00:11:49.950 --> 00:11:55.600
The data, the light channels mixed together to
create what is called the movie summary mix.

00:11:55.600 --> 00:11:59.529
And that's the data that then gets sent on ward.

00:11:59.529 --> 00:12:05.529
The movie level insert fits right about there.

00:12:05.529 --> 00:12:13.480
So what it gets as its input is the movie summary
mix and the client does its own processing

00:12:13.480 --> 00:12:17.100
or effect-adding, and hands it back to QuickTime.

00:12:17.100 --> 00:12:21.810
That data then makes it on wards to the extraction context.

00:12:21.809 --> 00:12:28.099
It -- it's good to note here that your
particular insert might have constraints

00:12:28.100 --> 00:12:31.019
like it can only do stereo to stereo effects.

00:12:31.019 --> 00:12:32.210
And that's perfectly fine.

00:12:32.210 --> 00:12:38.110
So during the set up of the insert you communicate
to QuickTime that your insert expects stereo data.

00:12:38.110 --> 00:12:41.930
And so this is, that movie summary mix of left, right,

00:12:41.929 --> 00:12:45.919
center will be mixed down to a stereo
before it's handed to your insert.

00:12:45.919 --> 00:12:52.559
A track level insert fits further up stream.

00:12:52.559 --> 00:12:54.909
It only operates on the data for the particular track.

00:12:54.909 --> 00:13:03.539
And here, too, a sub mix can be performed by
QuickTime if your insert has certain constraints.

00:13:03.539 --> 00:13:08.909
You can have only one insert at each of the top points.

00:13:08.909 --> 00:13:15.610
So a movie can have one movie level insert and as
many track level inserts as the number of tracks.

00:13:15.610 --> 00:13:21.490
But this shouldn't really constrain you in any way because
you can do as much processing as you want on your end.

00:13:21.490 --> 00:13:25.659
You just display it as a single insert interface.

00:13:25.659 --> 00:13:31.259
And another caveat I'd like to mention here is
that inserts do not work on predicted content.

00:13:31.259 --> 00:13:41.899
I'd like to now do a quick demo of -- where we deal
with inserts during playback as well as extraction.

00:13:41.899 --> 00:13:48.840
Just to show you the kinds of things that you can do.

00:13:48.840 --> 00:13:53.480
So just a quick -- I'd like to let you
know what I am going to do in this demo.

00:13:53.480 --> 00:13:57.889
There's three things I'd like to show you
of the movie level inserts during playback,

00:13:57.889 --> 00:14:03.199
track level inserts during playback, and
track level inserts during extraction.

00:14:03.200 --> 00:14:04.950
And looks like our machine's up.

00:14:04.950 --> 00:14:09.740
And you might not see me behind this, but I am here.

00:14:12.500 --> 00:14:18.440
So this is an app that we've written and
it should be available to you as sample code as part

00:14:18.440 --> 00:14:21.120
of the stuff that's related to the session.

00:14:21.120 --> 00:14:23.299
So you can go take a look at it.

00:14:23.299 --> 00:14:26.569
I am just going to open a movie first.

00:14:26.570 --> 00:14:30.230
And actually just play a quick segment for you.

00:14:30.230 --> 00:14:31.550
>> This is Brad Ford.

00:14:31.549 --> 00:14:35.759
I did this recording two years ago at WWDC.

00:14:35.759 --> 00:14:40.179
This piece by Andrew York called Bantu --

00:14:40.179 --> 00:14:46.769
>> Brad's an engineer on our QuickTime team and he
moonlights as a stupid movie star and a classical guitarist.

00:14:46.769 --> 00:14:55.569
So a couple years ago he did this stupid movie and we asked
him this year to do kind of a voiceover, over the original,

00:14:55.570 --> 00:14:58.770
talking about what he's playing
and his experiences doing it.

00:14:58.769 --> 00:15:02.559
Kind of like a director's cut version of that movie.

00:15:02.559 --> 00:15:09.099
So if we look at the properties for this, this is
just a regular old movie with five sound tracks.

00:15:09.100 --> 00:15:15.360
I am now going to open the audio context insert panel.

00:15:19.190 --> 00:15:28.720
And try some effects -- so the first thing
I am going do is apply an effect to a movie.

00:15:28.720 --> 00:15:33.639
A movie level insert, basically,
instead of a track level insert.

00:15:33.639 --> 00:15:39.279
And let's try a -- this section here
is the insert configuration area.

00:15:39.279 --> 00:15:44.559
So I want to use an aband class filter as the processor for this insert.

00:15:44.559 --> 00:15:51.299
And I am going to specify that this insert expects a
stereo layout and that it's going to produce stereo.

00:15:51.299 --> 00:15:59.069
Notice how the four tracks of the movie are
creating a summary mix that's quad

00:15:59.070 --> 00:16:04.550
but since this insert expects stereo data, QuickTime will
be mixing it down to stereo before handing it to the insert.

00:16:04.549 --> 00:16:10.099
And I am going to start off bypass -- just so
you know how it feels like without the insert.

00:16:10.100 --> 00:16:13.889
And then I'll bring it in.

00:16:13.889 --> 00:16:22.129
>> -- four guitars was originally recorded by the Los
Angeles Guitar Quartet on their Labyrinth CD in 1998.

00:16:22.129 --> 00:16:25.610
And it was written by --

00:16:25.610 --> 00:16:30.460
>> So this effect is being applied to all
the data of all the tracks mixed together.

00:16:30.460 --> 00:16:31.440
( Music )

00:16:31.440 --> 00:16:41.900
>> Next I'd like to apply a track level insert

00:16:41.899 --> 00:16:47.230
I know for a fact that track number
five contains Brad's dialogue track.

00:16:47.230 --> 00:16:50.940
So I am going to select that.

00:16:50.940 --> 00:16:54.830
And apply -- let's see -- a delay effect.

00:16:55.850 --> 00:16:59.000
And see what that looks like.

00:16:59.000 --> 00:17:05.140
So in this case we're only effecting
the data going out of that track.

00:17:05.140 --> 00:17:15.970
So you should see that the rest of the audio is unaffected.

00:17:15.970 --> 00:17:16.140
( Multiple voices speaking )

00:17:16.140 --> 00:17:23.500
>> So the effect on his dialogue.

00:17:23.500 --> 00:17:23.869
( Multiple voices speaking )

00:17:23.869 --> 00:17:27.859
>> Let's try a slightly funny effect.

00:17:27.859 --> 00:17:31.859
>> Of the four -- common language -- my kids to do it.

00:17:31.859 --> 00:17:32.750
My three kids --

00:17:32.750 --> 00:17:33.690
>> Those are his kids.

00:17:33.690 --> 00:17:39.960
>> I've got Milo there, who's now 6, Eliza who's
4 -- that little baby Clara there is now 3 years old.

00:17:39.960 --> 00:17:45.980
So the hardest part of doing this was keeping
straight which shirts I had to wear in which chairs.

00:17:45.980 --> 00:17:50.650
And finally, all the shots of the band so that I remember --

00:17:50.650 --> 00:17:53.720
>> Okay. So Brad with a slight chipmunk voice.

00:17:53.720 --> 00:17:56.490
I would like to now extract.

00:17:56.490 --> 00:17:59.480
So we just saw track level inserts during playback.

00:17:59.480 --> 00:18:03.769
So what happens if we extract with this effective play.

00:18:03.769 --> 00:18:06.099
So I will bring up the extraction panel here.

00:18:06.099 --> 00:18:12.659
And I don't want to extraction the entire movie.

00:18:12.660 --> 00:18:14.950
I just want a little segment at the end.

00:18:14.950 --> 00:18:24.279
So I am going to set this to like -- and I can
preview what I am about to extract just to make sure.

00:18:24.279 --> 00:18:32.129
>> Base guitar in the rhythm one, and
it's a lot of fun to put together.

00:18:32.130 --> 00:18:34.850
Four shirts on a hot day.

00:18:34.849 --> 00:18:36.909
I hope you liked it.

00:18:36.910 --> 00:18:38.990
>> And so we can now export this.

00:18:38.990 --> 00:18:44.930
So what's going to happen is during extraction we're
applying this insert effect to that specific track.

00:18:44.930 --> 00:18:49.920
So I'm going to hit export, and
let's just call this Extracted.

00:18:49.920 --> 00:18:56.150
And save it to the desktop.

00:18:56.150 --> 00:18:58.750
And we should see it somewhere here.

00:18:58.750 --> 00:19:10.490
>> -- the bass guitar and the rhythm one,
and it's a lot of fun on to put together.

00:19:10.490 --> 00:19:13.789
Four shirts on a hot day.

00:19:13.789 --> 00:19:15.430
I hope you liked it.

00:19:15.430 --> 00:19:20.009
>> So that's some of the things you can do
with inserts during extraction and playback.

00:19:20.009 --> 00:19:23.799
I'd like to now switch back to slides please.

00:19:27.569 --> 00:19:30.179
So how exactly did we do this?

00:19:30.180 --> 00:19:34.299
You want to apply Chipmunk effects to your own tracks.

00:19:34.299 --> 00:19:37.430
So how do you go about doing it?

00:19:37.430 --> 00:19:40.630
The general theory of operation is pretty simple.

00:19:40.630 --> 00:19:48.760
What you do is on your client app site you do the signal
processing logic needed for your particular effect.

00:19:48.759 --> 00:19:52.309
You then implement three call backs
that I will get into more detail in.

00:19:52.309 --> 00:19:58.710
That these call backs are going to be called by quick type.

00:19:58.710 --> 00:20:03.440
And then during set up stage you
register your insert with QuickTime.

00:20:03.440 --> 00:20:09.990
That's your time to communicate things like what you
expect the in and out channel layouts to be for your insert

00:20:09.990 --> 00:20:14.240
and addresses of your call backs, et cetera.

00:20:14.240 --> 00:20:20.829
So for a movie level insert, this is what
the registry structure will look like.

00:20:20.829 --> 00:20:26.159
The first field is just a pointer to --
a pointer that QuickTime will send back

00:20:26.160 --> 00:20:29.040
with all your call backs just so you can I.D. your instance.

00:20:29.039 --> 00:20:35.549
The next four fields refer to what
the insert expects on its input side.

00:20:35.549 --> 00:20:40.539
The channel layout expects -- and what
it's going to produce on its output side.

00:20:40.539 --> 00:20:46.700
And the last three are just addresses to the
three call backs that you will be implementing.

00:20:46.700 --> 00:20:51.910
If it's a track level insert you provide all the
information that you do for the movie level insert.

00:20:51.910 --> 00:20:54.830
So the first field is just this script above.

00:20:54.829 --> 00:21:02.240
And the additional thing that you need to communicate
is what track you want to attach the insert to.

00:21:02.240 --> 00:21:04.620
So what are these call backs that we're talking about?

00:21:04.619 --> 00:21:07.429
There's three call backs that you need to implement.

00:21:07.430 --> 00:21:09.500
The first is reset.

00:21:09.500 --> 00:21:14.740
The reset call back gets called
right at the start of processing,

00:21:14.740 --> 00:21:18.430
and also every time there's an
interruption in the processing chain.

00:21:18.430 --> 00:21:26.019
So this is the point where QuickTime communicates to your
app the sample rate of the data it's going to hand to it,

00:21:26.019 --> 00:21:30.720
and also the maximum number of frames
that will be pulled per render cycle.

00:21:30.720 --> 00:21:37.480
And your clients should be -- the client app should be
able to deal with any kind of sample rate that its given.

00:21:37.480 --> 00:21:45.900
The signal processing that you might be doing might be
working with windows or samples, so it could be the case

00:21:45.900 --> 00:21:51.300
that you need a particular number of input
samples before you can create meaningful data.

00:21:51.299 --> 00:21:59.649
So if you have that kind of latency, then the app
communicates that to QuickTime as the latency figure.

00:21:59.650 --> 00:22:04.220
And also things like reverbs might be
creating samples beyond the end time of the

00:22:04.220 --> 00:22:07.809
so if you have a tail time, you can communicate that.

00:22:07.809 --> 00:22:16.789
And like I said, the reset gets called pretty much any time
there's an interruption in chains, in the rendering changes.

00:22:16.789 --> 00:22:24.230
So you need to reset your buffers and it could be
that time has moved and we are now playing backwards

00:22:24.230 --> 00:22:26.130
in the case of instances during playback.

00:22:26.130 --> 00:22:31.810
So you shouldn't depend on any
state that you had previous to that.

00:22:31.809 --> 00:22:36.039
The process data call backs is where
the crux of the processing happens.

00:22:36.039 --> 00:22:42.500
It gets called for every buffer of audio
rendered, and QuickTime hands the client data.

00:22:42.500 --> 00:22:46.569
You process it, add your effect,
and hand it back to QuickTime

00:22:46.569 --> 00:22:52.379
And the first processed data after a
reset is when the latency gets pulled.

00:22:52.380 --> 00:22:56.440
So if in the reset call back you specified
a latency, then QuickTime will pull

00:22:56.440 --> 00:22:59.900
that many samples to clear out the latency.

00:22:59.900 --> 00:23:06.620
And if this is an insert during playback then it
will be called on the high priority isle thread.

00:23:06.619 --> 00:23:14.949
So make sure you don't do any expensive operations
like memory allocation, taking locks, et cetera.

00:23:14.950 --> 00:23:18.360
Here's just a general prototype
for this process data call back.

00:23:18.359 --> 00:23:22.309
And as you can see, audio buffer list, audio time stamp,

00:23:22.309 --> 00:23:26.269
these data structures are the same
as those used in Core Audio

00:23:26.269 --> 00:23:33.680
So the calling conventions for the inserts
is very similar to audio unit conventions.

00:23:33.680 --> 00:23:40.799
So if you were to write your effects using audio
units that would work beautifully with the insert API.

00:23:40.799 --> 00:23:42.629
But that is not a requirement.

00:23:42.630 --> 00:23:46.940
You can roll your own processing
logic and it should still work great.

00:23:46.940 --> 00:23:56.450
And the finalized call back is just a way for QuickTime to
let the insert know that it's never going to call it again.

00:23:56.450 --> 00:24:01.170
And any resources that the insert might
be holding on to, it can let go of now.

00:24:01.170 --> 00:24:09.410
It's optional, because depending on what your
application -- how it -- the logic of your application is,

00:24:09.410 --> 00:24:14.250
you might have complete control over the
state of effects that caused an audio context

00:24:14.250 --> 00:24:16.549
to go away or an extraction session to end.

00:24:16.549 --> 00:24:18.809
In which case you don't really need to be told that.

00:24:18.809 --> 00:24:21.339
You know that it's okay to leave your resources.

00:24:21.339 --> 00:24:25.659
But in a more complicated scenario
this could be a useful call back.

00:24:25.660 --> 00:24:33.680
So right in the beginning of the session we talked
about extraction, then we talked about inserts.

00:24:33.680 --> 00:24:36.330
So how do we put the two together.

00:24:36.329 --> 00:24:42.480
It's really -- extraction with inserts is just like
regular vanilla extraction, but just a slight change.

00:24:42.480 --> 00:24:47.880
So in step one you still begin your extraction session.

00:24:47.880 --> 00:24:52.790
Step three looks just the same, where you're
calling fill buffer until you're done.

00:24:52.789 --> 00:24:55.700
Step four is when you end the session,
that's exactly the same.

00:24:55.700 --> 00:24:58.670
So what's really changed is the configuration

00:24:58.670 --> 00:25:03.880
and what you do is you configure your session exactly
how you want it to, but then you do some extra work.

00:25:03.880 --> 00:25:07.050
You set properties to register your insert.

00:25:07.049 --> 00:25:09.240
So if it's a movie level insert that you want

00:25:09.240 --> 00:25:13.549
to attach during extraction then you would
set a property called register movie insert.

00:25:13.549 --> 00:25:18.139
And you hand in that registry structure
that he went over earlier.

00:25:18.140 --> 00:25:20.920
If it's a track level insert, you do the same.

00:25:20.920 --> 00:25:26.050
Except you set a different property and you
pass in the track level registry structure.

00:25:26.049 --> 00:25:28.019
And that's pretty much it.

00:25:28.019 --> 00:25:34.900
So with this and just a combination of the two
you can do quite a few interesting things with it.

00:25:34.900 --> 00:25:39.790
So this is like the end of the QuickTime
part of this talk -- so just a quick summary.

00:25:39.789 --> 00:25:41.809
We went over two APIs.

00:25:41.809 --> 00:25:47.619
The movie audio extraction APIs, which helps
you get at uncompressed audio movie data.

00:25:47.619 --> 00:25:51.879
Inserts, with the help of which you can
add effects during playback and extraction.

00:25:51.880 --> 00:25:54.110
And cool ways of putting the two together.

00:25:54.109 --> 00:26:01.649
And this might be useful to you during the stage when
you're manipulating your data, processing it, et cetera.

00:26:01.650 --> 00:26:05.490
Before you do your actually export to creative content.

00:26:05.490 --> 00:26:13.240
I would like to now invite Brian
up to talk about closed captioning.

00:26:13.240 --> 00:26:14.200
( Applause )

00:26:14.200 --> 00:26:18.799
>> Thank you, Sally.

00:26:19.950 --> 00:26:21.029
My name is Brian Pietsch.

00:26:21.029 --> 00:26:23.399
I am an engineer on the QuickTime team.

00:26:23.400 --> 00:26:28.660
And I'd like to talk to you this afternoon about closed
captions in QuickTime and how you can take advantage of that

00:26:28.660 --> 00:26:35.150
in your applications for both creating the content,
as well as playing it back in your applications.

00:26:35.150 --> 00:26:41.680
So the closed captions with QuickTime in sticking with
our theme that you may have heard in some of the sessions

00:26:41.680 --> 00:26:48.870
at the beginning of the week is that we're
really taking advantage of open standards.

00:26:48.869 --> 00:26:51.379
We didn't want to reinvent the wheel with closed captions.

00:26:51.380 --> 00:26:53.600
Closed captions have been around for a long time.

00:26:53.599 --> 00:26:57.029
And there are several standards out
there that cover them quite well.

00:26:57.029 --> 00:26:59.529
And we thought we would take advantage of those.

00:26:59.529 --> 00:27:08.250
So initially, for this first support that we've added
in the just recently released 7.16 we've added support

00:27:08.250 --> 00:27:14.339
for what is known as the CEA-608
standard, which is essentially the standard

00:27:14.339 --> 00:27:16.980
on which the FCC based their regulations.

00:27:16.980 --> 00:27:21.880
So it's what you would see coming across
a television set in North America.

00:27:21.880 --> 00:27:26.870
Commonly known as analog line 21 captions.
!

00:27:26.869 --> 00:27:31.219
You've probably heard them referred
to as several different ways.

00:27:31.220 --> 00:27:38.750
But essentially, what that is, is you know, when you turn
on a television set and there's captioning available,

00:27:38.750 --> 00:27:42.559
you see the standard black bars with the white text.

00:27:42.559 --> 00:27:49.639
So we really wanted to start with that in QuickTime,
as that's the most common format used today.

00:27:49.640 --> 00:27:56.140
The support in QuickTime for that is limited
to a single field and a single channel.

00:27:56.140 --> 00:28:02.540
If you're familiar with closed caption technology you
know that captions are available in up to four channels

00:28:02.539 --> 00:28:08.279
of information and you have options on
your TV set to choose which one you want.

00:28:08.279 --> 00:28:14.379
The first one which is the most common one is
typically the direct captioning of what you've got.

00:28:14.380 --> 00:28:21.130
And then often times there's a second one which might be a
foreign language translation, or a simplified translation

00:28:21.130 --> 00:28:23.700
for maybe a younger audience or something of that nature.

00:28:23.700 --> 00:28:25.779
Channels three and four are extremely rarely used.

00:28:25.779 --> 00:28:29.789
So I wouldn't even go into them.

00:28:29.789 --> 00:28:34.250
So the support in QuickTime is done via
a new Midi handler and a new track type.

00:28:34.250 --> 00:28:38.849
We could have gone and used the
existing text track in QuickTime.

00:28:38.849 --> 00:28:42.899
But that would have meant, you know,
going with a non standard type thing.

00:28:42.900 --> 00:28:47.310
And we really wanted to take advantage
of the standard, as I mentioned before.

00:28:47.309 --> 00:28:52.190
The nice thing too about this is that with a new
track type and Midi handler, we can make captions,

00:28:52.190 --> 00:28:55.120
visual content, capable which text tracks are not.

00:28:55.119 --> 00:28:57.179
As many of you are probably well aware.

00:28:57.180 --> 00:29:01.580
That means that you can display captions in
a visual context, enable the application,

00:29:01.579 --> 00:29:06.439
and get all the performance that
comes along with doing that.

00:29:06.440 --> 00:29:09.529
Current, captions are not searchable.

00:29:09.529 --> 00:29:14.379
If you're used to text, you might know that text
is searchable in QuickTime, captions are not.

00:29:14.380 --> 00:29:16.440
And really, this is a first pass support for us.

00:29:16.440 --> 00:29:20.900
So of the main focus here is playback,
and also the ability to create the movie.

00:29:20.900 --> 00:29:23.330
So we don't yet have a capture solution.

00:29:23.329 --> 00:29:27.259
I just wanted to point that out.

00:29:27.259 --> 00:29:31.369
So I just want to show you something here that kind
of illustrates the format of the data before we get

00:29:31.369 --> 00:29:34.219
into actually how to get this into
a movie in your own application.

00:29:34.220 --> 00:29:38.930
One of the most common file formats
that you might see this represented in,

00:29:38.930 --> 00:29:44.480
in a digital world once you've brought it off the Line
21 analog signal is something called a Scenarist

00:29:44.480 --> 00:29:45.789
closed caption.

00:29:45.789 --> 00:29:48.279
And basically what that is, is a text based file.

00:29:48.279 --> 00:29:54.829
And you'll see by looking at it that you have a
time code followed by a series of hexadecimal bytes.

00:29:54.829 --> 00:29:59.849
And you'll see a 2-byte pair followed
by another 2-byte pair, et cetera.

00:29:59.849 --> 00:30:06.000
Line 21 signal carries 2 bytes
per field in the NTSC signal.

00:30:06.000 --> 00:30:10.450
So each one of those pairs of bytes represents one field.

00:30:10.450 --> 00:30:16.779
And then the time code is the time at which
that particular row of data starts displaying.

00:30:16.779 --> 00:30:23.420
And that will be useful when we look at
how we create the content in a moment.

00:30:23.420 --> 00:30:25.789
So I wanted to show you some pseudo code here, basically,

00:30:25.789 --> 00:30:29.170
that will show you how you can add
the content to your own movies.

00:30:29.170 --> 00:30:32.820
And the great thing to note here is
that there's actually no new APIs.

00:30:32.819 --> 00:30:34.079
No new data structures.

00:30:34.079 --> 00:30:36.710
You can do all of this with existing APIs.

00:30:36.710 --> 00:30:41.279
There are some new constants which
we don't yet have published constants

00:30:41.279 --> 00:30:43.359
in the APIs set for, but those will come soon.

00:30:43.359 --> 00:30:44.609
And you can note the four CCs here.

00:30:44.609 --> 00:30:49.099
So the first thing you're going
to do is create a track media,

00:30:49.099 --> 00:30:52.559
which you would do in the normal content creation process.

00:30:52.559 --> 00:30:57.279
And the four CC for that media
time is C L C P for closed caption.

00:30:57.279 --> 00:30:59.879
And you'll notice that I am using a Time Scale of 30,000.

00:30:59.880 --> 00:31:03.980
30,000 is a good NTSC based Time Scale.

00:31:03.980 --> 00:31:12.200
You can represent one frame in an NTSC
world as 1,001 units in a 30,000 Time S0cale.

00:31:12.200 --> 00:31:16.509
Not required, but we do highly
recommend that you stick with that.

00:31:16.509 --> 00:31:19.680
Setting up the sample description is extremely easy.

00:31:19.680 --> 00:31:21.170
Like I said, there's no new data structures.

00:31:21.170 --> 00:31:24.150
You can just use a standard vanilla sample description.

00:31:24.150 --> 00:31:28.920
And the only field of note there is the
data format, in which case this is c608,

00:31:28.920 --> 00:31:33.120
which is a representation of the CEA-608 standard.

00:31:35.170 --> 00:31:41.110
Then the only thing left, really, is what is the
format of the actual media sample in the track.

00:31:41.109 --> 00:31:46.479
And if you look here I've defined a structure --
I've defined this just for illustration purposes.

00:31:46.480 --> 00:31:49.910
There's no actual data structure in
the headers that you need to follow.

00:31:49.910 --> 00:31:52.529
But this will just help to illustrate
the layout of the data.

00:31:52.529 --> 00:31:54.950
And what it is basically is just an atom.

00:31:54.950 --> 00:31:59.529
If you're familiar with an atom, it's
a size field followed by a time field

00:31:59.529 --> 00:32:02.819
and they be an amount of data following that.

00:32:02.819 --> 00:32:10.399
So you'll see here as we've set it up that we're allocating
a buffer that is big enough to hold those two header fields,

00:32:10.400 --> 00:32:13.830
the size and the type, as well as the
amount of data that you're putting in there.

00:32:13.829 --> 00:32:17.109
You're setting the size to be the size of the buffer.

00:32:17.109 --> 00:32:21.519
Because it's important to note that the
size actually includes the header itself.

00:32:21.519 --> 00:32:26.740
And you're setting the type for that
particular atom to see that, which is caption data.

00:32:26.740 --> 00:32:30.620
And one thing I would like to point
out here too is just that --

00:32:30.619 --> 00:32:33.039
to note that the endianess is important.

00:32:33.039 --> 00:32:36.740
QuickTime file format lives in a big-endian world.

00:32:36.740 --> 00:32:39.720
So you'll always want to make sure
that even if you're on an Intel machine

00:32:39.720 --> 00:32:43.630
that you're writing out your data in big-endian format.

00:32:43.630 --> 00:32:46.980
And then finally you're just going
to add those bytes like you saw

00:32:46.980 --> 00:32:51.950
in the Scenarist closed caption file
illustration earlier, to that buffer.

00:32:51.950 --> 00:32:57.390
And finally, you're going to call an Add
Media Sample too, and the one important thing

00:32:57.390 --> 00:33:01.120
to note there is the duration that
you're adding for that sample.

00:33:01.119 --> 00:33:04.029
And I've calculated here it's the data size
divided by 2.

00:33:04.029 --> 00:33:06.970
Since there's 2 bytes per NTSC field.

00:33:06.970 --> 00:33:08.059
Times 1,001.

00:33:08.059 --> 00:33:15.869
1,001 being the duration of an NTSC
frame in a 30,000 Time Sca0le base.

00:33:15.869 --> 00:33:18.359
Some tips and tricks.

00:33:18.359 --> 00:33:22.889
I probably mentioned a few of these as I was
going, but they're worth mentioning again.

00:33:22.890 --> 00:33:25.790
The first one is to use that NTSC Time Scale.

00:33:25.789 --> 00:33:31.519
It gives you the most accuracy when
you're stepping through the samples.

00:33:31.519 --> 00:33:38.369
The sample data must be in multiples of 2 bytes, since
we're following the standard of NTSC and line 21 analog.

00:33:38.369 --> 00:33:40.429
You're going to have 2 bytes per field.

00:33:40.430 --> 00:33:45.810
So you want to make sure you keep that consistency.

00:33:45.809 --> 00:33:53.069
As far as selecting the size of your QuickTime sample,
your media sample, there's no specific limitation,

00:33:53.069 --> 00:34:00.710
but what we're recommending is that you do one caption, so
for example, one sentence or one speaker's line per sample.

00:34:00.710 --> 00:34:04.079
That's a nice trade off between
having a large number of samples.

00:34:04.079 --> 00:34:09.059
For example, if we were to do each 2
byte field as an individual sample,

00:34:09.059 --> 00:34:10.779
you're going end up with a lot of samples.

00:34:10.780 --> 00:34:15.690
Versus doing everything in one giant sample
where you will have a very small number

00:34:15.690 --> 00:34:19.590
of the media samples, but you've got a lot of data in it.

00:34:19.590 --> 00:34:20.390
So it's a nice trade off.

00:34:20.389 --> 00:34:24.989
It gives you a little bit more flexibility
in terms of scrubbing through the media.

00:34:24.989 --> 00:34:28.439
QuickTime is a little bit able to
handle that a little bit better.

00:34:28.440 --> 00:34:34.320
And you're able to seek around
and pick up where you left off.

00:34:34.320 --> 00:34:40.840
And to know it on playback as well that the Midi handler
will actually interpret the samples as its playing through.

00:34:40.840 --> 00:34:48.130
So if you have a media sample that has, say, 2 seconds worth
of data, as QuickTime is playing it through, it will --

00:34:48.130 --> 00:34:52.750
if it's the type of caption that's,
say, paints on as you're watching it,

00:34:52.750 --> 00:34:55.449
QuickTime will interpret those frames automatically for you.

00:34:55.449 --> 00:35:01.539
So it would look exactly as you
expect it to look on a television set.

00:35:01.539 --> 00:35:10.119
And then you can avoid edits when you're adding your media
samples by simply extending the duration of the sample.

00:35:10.119 --> 00:35:14.230
So you notice in my previous slide that when I
calculated the duration of the sample I calculated

00:35:14.230 --> 00:35:19.990
by taking the data sides and dividing by 2
and multiplying by the duration of the frame.

00:35:19.989 --> 00:35:22.769
Well, that was just, you know, that's
the minimum size of that sample.

00:35:22.769 --> 00:35:26.110
But you can certainly make the duration
longer and QuickTime will automatically ignore

00:35:26.110 --> 00:35:29.849
that extra duration by padding in null data.

00:35:31.139 --> 00:35:33.940
That was how to create the content.

00:35:33.940 --> 00:35:35.500
As you see it was very simple.

00:35:35.500 --> 00:35:39.519
How, then, would you display it
back in your own application.

00:35:39.519 --> 00:35:43.460
If you were presented with a movie
that had this information?

00:35:43.460 --> 00:35:47.740
Basically what you're going to do is you're going
to walk the tracks in the movie looking for tracks

00:35:47.739 --> 00:35:51.389
of type CLCP. That's that same content
we saw before when we were creating it.

00:35:51.389 --> 00:35:55.500
And when you do find one of those tracks
if you want to show the closed captioning

00:35:55.500 --> 00:35:58.489
on it what you're going to do is set a track property.

00:35:58.489 --> 00:36:02.219
Put QT set track property API has
been around a little while now.

00:36:02.219 --> 00:36:08.559
All you're going to do is set the closed
caption property type and the display property,

00:36:08.559 --> 00:36:14.659
which is represented by DISP as a simple
boolean value that turns it on and off.

00:36:14.659 --> 00:36:21.839
It's worth pointing out that that's not quite the same as
enabling and disabling the track as you may be used to.

00:36:21.840 --> 00:36:26.640
That mechanism is more of an authoring type mechanism,

00:36:26.639 --> 00:36:30.789
whereas this is more of a user
preference to turn on or off at runtime.

00:36:30.789 --> 00:36:37.480
And not everybody, for example, has access to QuickTime Pro
with functionality to be able to turn the track on and off.

00:36:37.480 --> 00:36:45.610
So I want to give you a quick demo that shows
the process of bringing in the content from --

00:36:45.610 --> 00:36:48.690
since the Scenarist closed caption
format that I showed you earlier.

00:36:48.690 --> 00:36:51.820
And then playing it back in QuickTime Player.

00:36:51.820 --> 00:36:56.230
Should be on this machine right here.

00:36:56.230 --> 00:37:05.599
So included with the content of this session is
sample code for a closed caption import component.

00:37:05.599 --> 00:37:07.089
And I'm not going to go into that code.

00:37:07.090 --> 00:37:12.620
But basically it shows all the things
that I demonstrated for you earlier today.

00:37:14.340 --> 00:37:19.640
Oops. Pardon me while I fumble around a little bit here.

00:37:19.639 --> 00:37:29.190
So as you know, QuickTime import components
can be added to your library folder.

00:37:29.190 --> 00:37:32.679
So I've already done that ahead of
time just to show you that it is there.

00:37:32.679 --> 00:37:39.649
And basically what that movie import component is going to
do is allow me to bring in a Scenarist closed caption file.

00:37:39.650 --> 00:37:49.599
So if I just open this real quick
to show you what's in it -- maybe.

00:37:49.599 --> 00:37:51.159
Maybe not.

00:37:51.159 --> 00:37:52.179
Okay, well.

00:37:52.179 --> 00:37:56.579
Basically it's a text file that looks
exactly what I showed you earlier.

00:37:56.579 --> 00:38:02.759
And what I can do then is drag this down into QuickTime and
what it will do is open up using that movie import component

00:38:02.760 --> 00:38:08.560
And you will see a couple seconds into it we've got caption
data exactly like you would see on a television set.

00:38:08.559 --> 00:38:13.070
So what I can do here is take this
-- I have selected all it.

00:38:13.070 --> 00:38:14.490
I am going copy it.

00:38:14.489 --> 00:38:23.649
And what I am going to do is open up a movie -- I've
created these captions to go along with this movie.

00:38:23.650 --> 00:38:27.880
So what I will do then is I will add them to the movie.

00:38:27.880 --> 00:38:29.980
I'm going to save it.

00:38:29.980 --> 00:38:34.590
And because of the little thing with glare
I have to save it and then reopen it.

00:38:34.590 --> 00:38:36.430
But what I'll do now is play this back for you.

00:38:36.429 --> 00:38:39.159
And for your enjoyment.

00:38:39.159 --> 00:38:51.779
( Music )

00:38:51.780 --> 00:38:55.850
>> All too often Lazy Larries try to
speed through the development process

00:38:55.849 --> 00:39:12.539
with a disturbing disregard for careful planning.

00:39:12.539 --> 00:39:23.779
But this industrious engineer has
discovered the fun and gratifying results

00:39:23.780 --> 00:39:28.090
that come with strict adherence to standards.

00:39:28.090 --> 00:39:30.400
>> What's a standard?

00:39:30.400 --> 00:39:37.960
>> Travel to exotic locations.

00:39:37.960 --> 00:39:47.289
Engage in civil discourse.

00:39:47.289 --> 00:39:49.539
Enjoy enriching presentations guaranteed
to thrill, excite, and inspire.

00:39:49.539 --> 00:39:50.800
Regular delivery of exciting reading material.

00:39:50.800 --> 00:39:51.880
With easy to remember standards names too.

00:39:51.880 --> 00:39:52.690
Learn about the standard process.

00:39:52.690 --> 00:39:54.039
So never underestimate the importance of standards.

00:39:54.039 --> 00:39:55.869
After all, it was standards that
brought us cheap, reliable electricity.

00:39:55.869 --> 00:39:56.710
Oh crap. I wasn't work like this.

00:39:56.710 --> 00:39:57.519
Somebody call the -- bleep -- governor.

00:39:57.519 --> 00:39:58.509
Get out of my way.

00:39:58.510 --> 00:40:04.010
( Music )

00:40:04.010 --> 00:40:11.010
( Applause )

00:40:11.010 --> 00:40:15.060
>> So I thought that one would be
appropriate given it's adherence to standards.

00:40:15.059 --> 00:40:17.259
Came from a few years back.

00:40:17.260 --> 00:40:20.650
So that's pretty much it for my portion of the talk.

00:40:20.650 --> 00:40:25.200
I will be in the lab down stairs after this
session if you have any specific questions.

00:40:25.199 --> 00:40:27.189
I know I kind of went through this pretty quickly.

00:40:27.190 --> 00:40:30.820
But definitely take a look at the sample code
if that's something you're interested in.

00:40:30.820 --> 00:40:35.660
And I hope that you'll all be captioning
your own movies pretty soon.

00:40:35.659 --> 00:40:42.859
I am going hand it back to Kaz now so he can
go over some export information with you.

00:40:42.860 --> 00:40:43.630
( Applause )

00:40:43.630 --> 00:40:45.599
>> Thanks Brian.

00:40:46.900 --> 00:40:54.880
It's actually good to have this kind of movie as one of
our assets so we can use that as a part of demonstration

00:40:54.880 --> 00:40:57.890
without worrying about rights and all that stuff.

00:40:57.889 --> 00:41:00.049
Anyway, export.

00:41:00.050 --> 00:41:09.250
So what I am going to talk about -- excuse
me -- is basically overview of export.

00:41:09.250 --> 00:41:19.809
And how you can run export in an
application in terms of a very simple code.

00:41:19.809 --> 00:41:27.340
And QuickTime export functionality can
go into different kinds of file format.

00:41:27.340 --> 00:41:37.320
I am going give you an overview of what kind of file format
you can export into, and when you might want to use one.

00:41:37.320 --> 00:41:45.250
And how you can specifically use
exporter to go to one of the formats.

00:41:45.250 --> 00:41:52.309
And that would include one of the device formats like
iPod or Apple TV or even iPhone.

00:41:52.309 --> 00:42:02.759
And the last one I would like to briefly touch on the --
the stuff we've been doing in terms of export performance.

00:42:02.760 --> 00:42:04.370
So what does export do?

00:42:04.369 --> 00:42:07.889
That's a very simple question.

00:42:07.889 --> 00:42:15.869
I mean, simply put, it's essentially convert
-- converting one form of content to another.

00:42:15.869 --> 00:42:24.869
And that actually involves both the file format level
conversion as well as the media format level conversion.

00:42:24.869 --> 00:42:32.969
As you already know very well, a content
can contain both audio and video.

00:42:32.969 --> 00:42:35.829
And they can be in different formats.

00:42:35.829 --> 00:42:39.699
And then depending on the file format you're going to,

00:42:39.699 --> 00:42:45.939
the file format itself may dictate a
particular video format or audio format.

00:42:45.940 --> 00:42:58.940
So this export functionality basically handles a
conversion of the both media format and the file format.

00:42:58.940 --> 00:43:05.280
Here's a simple diagram that out
lines what's in the export system.

00:43:06.900 --> 00:43:10.200
Clearly, you need video compressor, audio codec --

00:43:10.199 --> 00:43:15.629
video codecs, audio codecs handles the
compression and decompression of the media data.

00:43:15.630 --> 00:43:21.170
And we have associated piece of code that manages the codecs.

00:43:21.170 --> 00:43:30.320
And we also have facility to manage
the file format like writing sample

00:43:30.320 --> 00:43:34.500
down into the file container, reading them back.

00:43:34.500 --> 00:43:36.079
Those kind of stuff.

00:43:36.079 --> 00:43:41.289
And then on top of that, we have
something called export component

00:43:41.289 --> 00:43:44.519
that basically bundles those functionality together

00:43:44.519 --> 00:43:53.059
and then provide you an easy way to
have access to that functionality.

00:43:53.059 --> 00:43:58.829
And we also have something we call high level
API, which is very simple, easy to use API.

00:43:58.829 --> 00:44:06.819
So then you can run export with very few amount of code.

00:44:06.820 --> 00:44:10.660
Something I would like to point
out about this architecture is

00:44:10.659 --> 00:44:16.730
that this is designed to be a plug-in
component architecture.

00:44:16.730 --> 00:44:21.320
Many of the pieces are implemented
as component manage component.

00:44:21.320 --> 00:44:26.269
For example, exporters, they are implemented as components.

00:44:27.630 --> 00:44:32.900
For each supported file format
there's an exporter component.

00:44:32.900 --> 00:44:39.320
So, for example, we have an epic
4 file format exporter component.

00:44:39.320 --> 00:44:42.269
That is implemented as a component.

00:44:42.269 --> 00:44:47.679
Similarly, video codec, audio codec
are implemented as a component.

00:44:47.679 --> 00:44:55.609
So for each supported video and audio format,
video or audio format, there is a codec component.

00:44:55.610 --> 00:45:05.170
This way you can do a mix and match of export component
as well as the video and audio codec components.

00:45:05.170 --> 00:45:15.860
And that basically lent our support with a variety
of file format, and then the video and audio formats.

00:45:15.860 --> 00:45:20.910
So let's look at quickly what's
happening in the export process.

00:45:20.909 --> 00:45:29.759
This is also a simple diagram that shows the
-- basically the flow of data during export.

00:45:29.760 --> 00:45:39.760
Of course there are both audio and video
data can be in the source media -- material.

00:45:39.760 --> 00:45:42.700
We have to handle both audio and video compression.

00:45:42.699 --> 00:45:45.799
Let's focus on the audio side first.

00:45:45.800 --> 00:45:54.150
The source data in the source movie
is -- needs to be decompressed.

00:45:54.150 --> 00:46:00.680
And that is actually done through
the mechanism Sally was explaining.

00:46:00.679 --> 00:46:04.159
That was the audio -- I'm sorry -- movie extraction.

00:46:04.159 --> 00:46:08.940
And if there are multiple tracks
-- with multiple audio tracks

00:46:08.940 --> 00:46:13.240
in the source movie theory decompressed and mixed down.

00:46:13.239 --> 00:46:20.219
And that will result in a single
track of uncompressed audio data.

00:46:20.219 --> 00:46:26.959
And this uncompressed audio data is then
fed into the audio compression machinery

00:46:26.960 --> 00:46:32.990
that uses the audio codec of the type you want to use.

00:46:32.989 --> 00:46:39.500
And finally, the compressed audio
data comes out of the codec.

00:46:39.500 --> 00:46:42.469
Is laid down to the final container.

00:46:42.469 --> 00:46:44.629
That is often times a file.

00:46:44.630 --> 00:46:49.690
And that is done by the movie tool box.

00:46:49.690 --> 00:46:56.519
A similar process is happening in the video side as well.

00:46:56.519 --> 00:47:01.719
A video data in the source movie needs to be decompressed.

00:47:01.719 --> 00:47:08.269
And then if there are multiple video tracks they
need to be composed to create a single picture.

00:47:08.269 --> 00:47:13.009
Or more accurately, a single stream of pictures.

00:47:13.010 --> 00:47:20.460
And then this is done by video decompressor and the
appropriate composing machinery we have in QuickTime.

00:47:20.460 --> 00:47:29.010
And then that will produce a stream of pixels,
or essentially pixel images, or pictures.

00:47:29.010 --> 00:47:33.100
The series is now fed into the video compression machinery.

00:47:33.099 --> 00:47:37.759
And once again there's some mechanism
to draw the video codec.

00:47:37.760 --> 00:47:43.950
And video codec will produce a
series of compressed video data.

00:47:43.949 --> 00:47:50.899
And then this compressed data is laid down into
the final container with the movie tool box.

00:47:50.900 --> 00:47:57.070
And in movie tool box, or -- depending on the file
format, appropriate file format handlers associated

00:47:57.070 --> 00:48:06.890
with the exporter component -- that is responsible to manage
interleaving of that video data, audio data, appropriately.

00:48:06.889 --> 00:48:16.039
Once again, this is something dependent on the file format.

00:48:16.039 --> 00:48:20.079
So how do you run this export processing in the application?

00:48:20.079 --> 00:48:22.389
That's very simple.

00:48:23.460 --> 00:48:30.240
What you need to start with is
a source movie, source content.

00:48:30.239 --> 00:48:32.619
Prepared as a QuickTime Movie.

00:48:32.619 --> 00:48:42.759
In order to have this you can either run the
capture or you can read existing QuickTime file.

00:48:42.760 --> 00:48:46.080
Or you can import some of that format or materials.

00:48:46.079 --> 00:48:53.259
QuickTime has a series of -- a number
of importers you can use to bring

00:48:53.260 --> 00:48:56.830
in media content in formats other than QuickTime Movie.

00:48:56.829 --> 00:48:57.809
You can use that.

00:48:57.809 --> 00:49:05.349
You can use one of those to ingest
your source material into QuickTime.

00:49:05.349 --> 00:49:12.489
Once you have sourced QuickTime Movie, then all
you need to do is to call this high level API

00:49:12.489 --> 00:49:14.509
called ConvertMovietoDataRef.

00:49:14.510 --> 00:49:16.220
This is not a new thing.

00:49:16.219 --> 00:49:18.419
It's been around for quite some time.

00:49:18.420 --> 00:49:27.079
And then if you have used QuickTime, many of you
have already seen this API, or used this API.

00:49:27.079 --> 00:49:31.369
But I would like to just, you know,
do a recap of how simple it is.

00:49:31.369 --> 00:49:36.239
This is the code you would have to use.

00:49:36.239 --> 00:49:38.849
Basically, this is a simple function code.

00:49:38.849 --> 00:49:47.929
Anyone -- you are passing it in as a source movie,
which is either imported, or read into memory.

00:49:47.929 --> 00:49:57.879
And the -- the last line shows the
flag parameter you can pass in.

00:49:57.880 --> 00:50:02.769
Now basically tells this API to bring up the piece of UI.

00:50:02.769 --> 00:50:11.739
That is something you see in the QuickTime
Player when you do export in QuickTime player.

00:50:11.739 --> 00:50:17.309
So basically you can provide a very similar
user experience in your application.

00:50:18.320 --> 00:50:24.800
So what this hollow way API does is the following.

00:50:24.800 --> 00:50:28.900
It basically presents the configuration UI as I said.

00:50:28.900 --> 00:50:31.130
The dialogue looks like this.

00:50:31.130 --> 00:50:34.550
It's a navigation sort of dialogue.

00:50:34.550 --> 00:50:38.039
And it has some customs controls on it.

00:50:38.039 --> 00:50:46.699
And basically you let the user of your application to
choose the type of export or the target file format.

00:50:46.699 --> 00:50:50.109
And as I said there's one exporter
component for each file format.

00:50:50.110 --> 00:50:56.760
So you can basically set up the export
type by choosing the target file format.

00:50:56.760 --> 00:51:04.720
And this also let's the user specify
the location of the out put.

00:51:04.719 --> 00:51:09.779
Exporter component usually creates a file
as a result of export.

00:51:09.780 --> 00:51:12.140
You can specify the location.

00:51:12.139 --> 00:51:16.949
Where you want the export component to put the final output.

00:51:16.949 --> 00:51:21.909
And then also there's a piece about -- and to bring

00:51:21.909 --> 00:51:28.559
up the exporter special dialogue, to
manage compression-specific options.

00:51:29.900 --> 00:51:36.230
And then one nice thing about this
hollow API is it remembers what the user

00:51:36.230 --> 00:51:40.039
of your application chose though this dialogue.

00:51:40.039 --> 00:51:45.960
So when you invoke this function the next time around,

00:51:45.960 --> 00:51:52.000
it remembers what your user chose
in the last call of this function.

00:51:52.000 --> 00:51:57.119
This information is saved in the
QuickTime preference -- preferences.

00:51:57.119 --> 00:51:59.380
And of course, it runs the expert.

00:51:59.380 --> 00:52:00.849
That's the most important part.

00:52:00.849 --> 00:52:10.309
If the user pushes the same button it runs the export parts.

00:52:10.309 --> 00:52:18.539
So as you can see, with the use of
this hollow API, it brings up the UI.

00:52:18.539 --> 00:52:22.429
It let's the user of the application choose the export type.

00:52:22.429 --> 00:52:26.019
You may not need this much flexibility.

00:52:26.019 --> 00:52:32.630
For example, your application might
have a particular destination format.

00:52:32.630 --> 00:52:37.980
Or your application might have some
specific convention about managing files,

00:52:37.980 --> 00:52:43.449
like project folder or something along those lines.

00:52:43.449 --> 00:52:49.309
In those cases, you want to specify
those information through the API rather

00:52:49.309 --> 00:52:54.090
than let, you know, your user to pick up one time.

00:52:54.090 --> 00:52:56.539
Of course you can do it.

00:52:56.539 --> 00:53:02.849
Before going into that detail, I would
like to briefly touch on the choice

00:53:02.849 --> 00:53:07.250
of file format you can make for the application.

00:53:07.250 --> 00:53:15.780
These are the typical formats for -- as I said most
important formats we support in QuickTime currently --

00:53:15.780 --> 00:53:22.269
that includes QuickTime Movie, MPEG-4
file format, 3GPP, and in the Apple devices,

00:53:22.269 --> 00:53:26.539
that's the format that can go into, like, iPod, iPhone, Apple TV.

00:53:26.539 --> 00:53:35.389
And of course we can export to DV,
which is the standard of DV file.

00:53:35.389 --> 00:53:42.069
Many of these files look similar,
for example, MPEG-4 and 3GPP,

00:53:42.070 --> 00:53:47.130
they are both based on the ISO
media file format standard.

00:53:47.130 --> 00:53:49.990
And some of you might think that they're interchangeable.

00:53:49.989 --> 00:53:52.019
They are really not.

00:53:52.019 --> 00:54:02.739
So what I would like to say is that what you make a choice
about the file format, do what your application exports to.

00:54:02.739 --> 00:54:11.269
You have to consider carefully, and you really
have to know what your final destination is.

00:54:11.269 --> 00:54:16.250
Okay. So then here's how you want to
export without bringing up the dialogue.

00:54:16.250 --> 00:54:19.130
It's essentially similar.

00:54:19.130 --> 00:54:21.410
You see the function code here.

00:54:21.409 --> 00:54:33.019
What you have to do before calling this convertible into
dataref file APIs is to find the exporter component itself.

00:54:33.019 --> 00:54:38.869
This is done through the standard component
manager function, open default component.

00:54:38.869 --> 00:54:43.489
What you have to specify is the
type of export, which is an OS type.

00:54:43.489 --> 00:54:48.699
And then once you have that component open, you
can pass that to the convert movie to data ref.

00:54:48.699 --> 00:54:51.779
And it's going to use this component to run the export.

00:54:51.780 --> 00:54:56.630
And then when you're done, you just
close the component, as always.

00:54:57.929 --> 00:55:03.059
Okay. And then there are a few more
things I would like to touch on.

00:55:03.059 --> 00:55:06.980
These are what we call helping features.

00:55:06.980 --> 00:55:14.670
As I indicated earlier, this export functionality has been
around for -- I would say a long time -- with QuickTime.

00:55:14.670 --> 00:55:19.980
And there are some features of
QuickTime that are added recently.

00:55:19.980 --> 00:55:27.599
And in order to take advantage of those
features you have to indicate your intention.

00:55:29.269 --> 00:55:31.130
Two examples I have here.

00:55:31.130 --> 00:55:33.260
One is the high bred solution of the export.

00:55:33.260 --> 00:55:38.570
You have the capability of handling every
solution you are given in QuickTime 7.

00:55:38.570 --> 00:55:45.410
And that include multichannel review,
sample wave greater than 64 kilohertz.
d

00:55:45.409 --> 00:55:53.799
And you can now use those materials as a source
of export, or you can export into those formats

00:55:53.800 --> 00:55:57.220
that involve multichannels or a sample rate.

00:55:57.219 --> 00:56:02.709
And it also brings you some level of thread safety.

00:56:02.710 --> 00:56:07.099
This is not a complete thread safety unfortunately.

00:56:07.099 --> 00:56:13.039
As Sally indicated, the codec involving the
process have to be thread safe in order to be --

00:56:13.039 --> 00:56:17.239
in order to have the whole export process be thread safe.

00:56:17.239 --> 00:56:20.309
So this is sort of conditional thread safety.

00:56:20.309 --> 00:56:27.710
But basically had what I -- I'm trying to say here
is that with this solution Opt-in,

00:56:27.710 --> 00:56:34.500
you can potentially make your export process thread-safe.

00:56:34.500 --> 00:56:37.690
The other thing is the aperture mode.

00:56:37.690 --> 00:56:43.970
Those of you who were in the previous
session now know what aperture mode means.

00:56:43.969 --> 00:56:56.359
That basically control how your content would look in
the -- when you open this content in QuickTime Player

00:56:56.360 --> 00:57:01.940
or some of the applications that basically
plays the content through QuickTime.

00:57:01.940 --> 00:57:10.800
And then not as critical when your source has clean aperture

00:57:10.800 --> 00:57:16.640
or your source is encoded in a
format that uses no script results.

00:57:16.639 --> 00:57:22.449
What it does is to get the same effect as you --

00:57:22.449 --> 00:57:27.379
as you would with setting the aperture
mode in your playback application.

00:57:27.380 --> 00:57:34.860
This is to make sure you get the same result as
you see during playback as a result of export.

00:57:36.460 --> 00:57:37.690
So here's what you do.

00:57:37.690 --> 00:57:41.990
So I'm going to talk about the high
resolution of your Opt-in first.

00:57:41.989 --> 00:57:46.099
So this uses QT set component property.

00:57:46.099 --> 00:57:51.039
This is a function that has been around for some time.

00:57:51.039 --> 00:57:56.900
This basically let's you set a
particular prompt of a component.

00:57:56.900 --> 00:57:59.360
So in this case you are talking to the export component.

00:57:59.360 --> 00:58:04.340
You discovered that's actually the code
I showed in the previous code slide.

00:58:04.340 --> 00:58:11.120
And you can set this -- I can't even pronounce this name.

00:58:11.119 --> 00:58:16.529
It's K QT with the exporter property I D M as
core enable high resolution and audio feature.

00:58:16.530 --> 00:58:17.670
This actually is a single word.

00:58:17.670 --> 00:58:21.269
I couldn't fit this into a single
line, so I broke this into two lines.

00:58:21.269 --> 00:58:23.710
But essentially, it's a single property name.

00:58:23.710 --> 00:58:25.550
And then the data type is boolean.

00:58:25.550 --> 00:58:29.630
So you indicate this is boolean.

00:58:29.630 --> 00:58:33.430
You do this before running export.

00:58:33.429 --> 00:58:41.369
So units are discoded in the middle
of the code example I showed earlier.

00:58:41.369 --> 00:58:46.089
Okay. And then here's how you manipulate the aperture mode.

00:58:46.090 --> 00:58:49.670
It's a little more complicated, but the idea is similar.

00:58:49.670 --> 00:58:55.740
This time, instead of movie -- I'm sorry,
instead of exporter component you want

00:58:55.739 --> 00:59:00.579
to manipulate an attribute of the source movie.

00:59:00.579 --> 00:59:07.090
So now you use QT Kit movie property,
or QT Kit set movie property.

00:59:07.090 --> 00:59:12.420
What it is trying to do here is to save the current aperture

00:59:12.420 --> 00:59:16.920
of the source movie, and then set
the aperture mode you want.

00:59:16.920 --> 00:59:19.119
Okay, another -- I have a nice highlight.

00:59:19.119 --> 00:59:22.289
So that's the aperture mode you were using.

00:59:22.289 --> 00:59:24.630
In this example I said create an aperture.

00:59:24.630 --> 00:59:27.360
So let's say you want to create
an aperture of the source movie.

00:59:27.360 --> 00:59:34.260
What you do is to save the current aperture mode of the
source movie, and then set the clean aperture source movie.

00:59:34.260 --> 00:59:35.530
And then run the export.

00:59:35.530 --> 00:59:47.890
And then of course you want to reset the aperture mode of
this movie back to the way it is before this code runs.

00:59:47.889 --> 00:59:51.099
Okay. Export to iPhone, iPhone FTV.

00:59:51.099 --> 01:00:00.069
Okay, so many of you are interested
in, I am sure, trying to export into --

01:00:00.070 --> 01:00:06.769
you're exporting the content your application
handles into one of those formats.

01:00:06.769 --> 01:00:08.869
This is actually very simple.

01:00:08.869 --> 01:00:14.609
But there are a few things I would like --
I would like you to know about this export.

01:00:14.610 --> 01:00:17.660
This is a new breed of exporters.

01:00:17.659 --> 01:00:24.819
And this behaves -- behaves slightly
differently than the traditional exporters.

01:00:24.820 --> 01:00:27.280
They are basically not configureable.

01:00:27.280 --> 01:00:30.840
They don't have any settings UI.

01:00:30.840 --> 01:00:38.150
They are supposed to do the right thing based on the
source movie, and based on the destination device.

01:00:38.150 --> 01:00:40.930
And that actually overlaps to what I say.

01:00:40.929 --> 01:00:46.739
But they are optimized for the device's capability.

01:00:46.739 --> 01:00:49.539
Those devices run H.264 video.

01:00:49.539 --> 01:00:54.349
And then they use appropriate profile
-- profile depending on the device.

01:00:54.349 --> 01:00:57.299
Unfortunately, they are somewhat different.

01:00:57.300 --> 01:01:00.100
And those devices use ACOD.

01:01:00.099 --> 01:01:02.909
They can playback ACOD.

01:01:02.909 --> 01:01:08.440
So these exporters compress audio into NFC audio.

01:01:09.489 --> 01:01:17.699
And the other nice thing about this approach is
that as the capabilities of the device evolve,

01:01:17.699 --> 01:01:26.079
we can update exporter to take it -- advantage of
the evolving -- the new capabilities of the device.

01:01:26.079 --> 01:01:31.380
So you don't have to worry about adjusting your
settings, saving the application, so on and so forth.

01:01:32.889 --> 01:01:44.589
And one example of knowing the source movie
and adjust the settings appropriately is

01:01:44.590 --> 01:01:47.970
to preserve the aspect ratio of the source.

01:01:47.969 --> 01:01:52.199
This has never been done in other exporters before.

01:01:52.199 --> 01:01:59.689
Those exporters look at the destination of
the source movie and then try to fit the image

01:01:59.690 --> 01:02:06.230
into the maximum dimensions the
device is capable of dealing with.

01:02:06.230 --> 01:02:12.990
That way you can get the maximum size without,
like, squishing or distorting the content.

01:02:15.059 --> 01:02:25.460
And it adjust the -- the exporter adjusts the data rate
depending on the dimension of the picture and determines.

01:02:25.460 --> 01:02:30.710
So you don't have to worry about tweaking
the data away, or tweaking the size,

01:02:30.710 --> 01:02:37.289
trying to preference the aspect ratio and all that stuff.

01:02:37.289 --> 01:02:47.449
And it also -- the exporter's also
maintain better data supported by iTunes.

01:02:47.449 --> 01:02:57.409
You might have already seen some of the meta data you can
see in iTunes that come against the file iTunes plays.

01:02:57.409 --> 01:03:04.420
And if -- if your content has those meta data
in your source, those exporters will preserve --

01:03:04.420 --> 01:03:10.269
preserve and transfer over to the NS
destination with appropriate trance coding.

01:03:11.440 --> 01:03:12.710
Okay. So here's the code.

01:03:12.710 --> 01:03:14.320
It's once again very simple.

01:03:14.320 --> 01:03:19.930
And it's essentially the same that one
of the example that I showed before.

01:03:19.929 --> 01:03:25.159
This slide incorporates some of the points I made
earlier about this app and these app features,

01:03:25.159 --> 01:03:28.809
like high res audio and the clean aperture.

01:03:28.809 --> 01:03:36.789
Difference is that you just have to find
the right component for your device.

01:03:36.789 --> 01:03:39.730
In this example, this is for Apple TV.

01:03:39.730 --> 01:03:44.019
And in the end the type of the components happen to be MPBH.

01:03:44.019 --> 01:03:49.219
Currently, those component types are
not defined in your public datas.

01:03:49.219 --> 01:03:53.069
We will make sure that these will
be defined in the future datas.

01:03:53.070 --> 01:04:04.080
In the meantime I would tech node or developer
sample code -- those kind of information --

01:04:04.079 --> 01:04:15.400
will contain the list of component times that you
need to use depending on the type of export --

01:04:15.400 --> 01:04:20.059
I'm sorry -- device -- you want to export to.

01:04:20.059 --> 01:04:24.699
But essentially, this is just a
matter of finding the right protocol.

01:04:24.699 --> 01:04:33.989
And this is the high res property and
this is the source movie's aperture mode.

01:04:33.989 --> 01:04:38.399
And you're just passing the source movie
into the component view configured.

01:04:38.400 --> 01:04:39.970
And the export.

01:04:39.969 --> 01:04:45.179
So it's that simple.

01:04:45.179 --> 01:04:49.079
Okay. So I would like to brief
touch on the export performance.

01:04:49.079 --> 01:04:53.699
There's some kinds of stuff we've
been doing about export performance.

01:04:53.699 --> 01:05:00.159
We've been hearing a lot of feed back
about H 264 compression in particular.

01:05:00.159 --> 01:05:02.389
You can get a high quality result.

01:05:02.389 --> 01:05:05.210
But often times it takes a long time.

01:05:05.210 --> 01:05:10.269
We're taking steps to address the situation.

01:05:10.269 --> 01:05:22.440
Like trying to optimize the CPU usage, using asynchronous
I/O, we're trying to take advantage of the multicore systems.

01:05:22.440 --> 01:05:30.659
So then you can have a scaleable performance
depending on the configuration you have.

01:05:30.659 --> 01:05:39.389
These are current only limited to
iPod, Apple TV, and iPhone export.

01:05:39.389 --> 01:05:44.909
In particular, compression including
in it, with H.264, and AAC audio.

01:05:46.500 --> 01:05:51.679
And this is actually available
with the Leopard seed of QuickTime.

01:05:51.679 --> 01:05:55.279
Currently, it's only accessible in QuickTime Player.

01:05:55.280 --> 01:06:03.260
We're working to make sure that that will be
accessible to the rest of the applications.

01:06:03.260 --> 01:06:11.580
Here's an example of kind of performance
improvement you can get through this approach.

01:06:11.579 --> 01:06:19.779
The blue bars result from QuickTime 7.1.6,
and then the orange, yellowish bars --

01:06:19.780 --> 01:06:24.019
looks like orange -- they are from QuickTime 7.2.

01:06:24.019 --> 01:06:27.829
This is a few builds before the Leopard seed.

01:06:27.829 --> 01:06:32.139
So the data may not exactly match with the
Leopard seed, or by of the time we ship Leopard.

01:06:32.139 --> 01:06:39.239
But this is just sort of to give you an idea
about what kind of improvement we are looking at.

01:06:39.239 --> 01:06:46.500
And this is using a RGB source going to Apple )
export and there are three data points: single core,

01:06:46.500 --> 01:06:51.360
two core, and then four core system.

01:06:51.360 --> 01:06:58.110
And this is the same export from
2UVY. It's that similar trend.

01:07:01.329 --> 01:07:08.409
Okay. So quick summary.

01:07:08.409 --> 01:07:20.969
Basically what we covered was some of the things you can
use QuickTime to help your content creation work flow

01:07:20.969 --> 01:07:32.809
And that includes audio processing that let's you extract
uncompressed audio source and then apply audio tracks.

01:07:32.809 --> 01:07:34.869
And then we covered closed caption.

01:07:34.869 --> 01:07:37.369
Both creation and then playback.

01:07:37.369 --> 01:07:43.980
And finally I basically explained
some basic concepts of export,

01:07:43.980 --> 01:07:47.909
(Inaudible) and some particular about going to
device export.

01:07:49.610 --> 01:07:53.230
More information, there's some documentation, code examples,

01:07:53.230 --> 01:07:58.679
these are available through the
web site, your attendee web site.

01:07:58.679 --> 01:08:00.839
And there are a few labs.

01:08:00.840 --> 01:08:06.390
In particular, there's a QuickTime audio lab running
in parallel to this session -- ( pause ) --

01:08:06.389 --> 01:08:10.159
speakers including myself will be in the lab.

01:08:10.159 --> 01:08:13.769
So if you have more questions you can come and talk to us.

01:08:13.769 --> 01:08:17.710
And then there are QuickTime video lab tomorrow.

01:08:17.710 --> 01:08:19.899
Probably some of us will be there.

01:08:19.899 --> 01:08:27.819
And there are people from video group will be there so
you can ask questions about video compressions and such.
WEBVTT

00:00:18.609 --> 00:00:23.179
>> My name is Brendan Langoulant, and
I am an engineering manager for Address Book and Mail.

00:00:23.179 --> 00:00:30.469
Today we are here to help you ensure that your
customers' important contact information isn't isolated

00:00:30.469 --> 00:00:32.850
from the Apple ecosystem.

00:00:32.850 --> 00:00:36.380
And we're going to take you through three major sections.

00:00:36.380 --> 00:00:43.500
The first section is really going be about how to -- giving
you an understanding of the layers involved and building

00:00:43.500 --> 00:00:46.789
up from some of the basics of how to use the API.

00:00:46.789 --> 00:00:50.039
Going through some of the data types in the
core functions that you need to know in order

00:00:50.039 --> 00:00:53.659
to development an application using Address Book.

00:00:53.659 --> 00:01:00.429
Then we're going to move on to giving
you some examples of how to use some

00:01:00.429 --> 00:01:02.850
of these interface elements that we provide you.

00:01:02.850 --> 00:01:08.680
And actually add a hook into the Address Book
application that you might be able to find ways to --

00:01:08.680 --> 00:01:12.710
find new ways to integrate your application
with the Address Book application.

00:01:12.709 --> 00:01:20.479
And then finally, we're going to move on to how
to make sure that you're using the best practices.

00:01:20.480 --> 00:01:22.280
We've made some changes under the
hood with your Address Book.

00:01:22.280 --> 00:01:27.570
And we want to make sure that you're really
not wasting time taking the wrong approach,

00:01:27.569 --> 00:01:30.789
that you're actually using the
best practices that we suggest.

00:01:30.790 --> 00:01:33.680
And making sure that you get the best performance.

00:01:34.989 --> 00:01:42.219
So in the dark days of Macintosh we had many,
many different contact management databases.

00:01:42.219 --> 00:01:46.750
That meant that each developer had to
implement their own contact database.

00:01:46.750 --> 00:01:51.219
It meant that customers, worse
had to actually go and implement

00:01:51.219 --> 00:01:54.469
or type in the same contact details over and over again.

00:01:54.469 --> 00:01:55.609
And that was not very good.

00:01:55.609 --> 00:02:00.450
So we really didn't -- we thought maybe
there's a better way of doing this.

00:02:00.450 --> 00:02:03.359
Hint; born, the Address Book framework.

00:02:03.359 --> 00:02:09.500
So as you can see up here, the Address Book
framework is used by a lot of applications.

00:02:09.500 --> 00:02:11.389
Here are some of the applications.

00:02:11.389 --> 00:02:16.699
Going through applications like mail,
which uses it for e-mail addresses.

00:02:16.699 --> 00:02:22.099
Applications, iChat for doing IM handles.

00:02:22.099 --> 00:02:23.859
Interesting one.

00:02:23.860 --> 00:02:31.210
ICal, using it for birthdays and for attendees, when
you're actually inviting people to your meetings.

00:02:31.210 --> 00:02:33.280
And there's a lot of other applications.

00:02:33.280 --> 00:02:37.289
In fact when we're going through of the
process of making Address Book 64-bit,

00:02:37.289 --> 00:02:41.539
we really understood how many applications
inside Apple used the Address Book framework.

00:02:41.539 --> 00:02:47.739
There's a large hierarchy of applications which
are all based on having an Address Book somewhere.

00:02:50.240 --> 00:02:53.930
Here's some applications that are
already using the Address Book framework.

00:02:53.930 --> 00:03:03.020
And they're already getting the benefits of using
a centralized database for managing their contacts.

00:03:06.039 --> 00:03:14.969
So some of the benefits that you get by using this
database -- as we add more devices to the Apple ecosystem,

00:03:14.969 --> 00:03:18.680
your contact information will automatically
migrate into those devices.

00:03:18.680 --> 00:03:23.430
So when we first developed Address
Book, things like Sync didn't exist.

00:03:23.430 --> 00:03:32.740
So when we added sync, that meant that automatically your
contact information went to places like dot Mac, to iPod,

00:03:32.740 --> 00:03:35.879
and other devices that you might think of.

00:03:38.240 --> 00:03:42.180
One of the new things that we've done in
Address Book is add Time Machine support.

00:03:42.180 --> 00:03:50.099
So what this enables your customers to do is if they realize
that they've either changed a piece of data on a customer,

00:03:50.099 --> 00:03:58.549
or one of their contacts, I should say, and they no longer
can find that information, you can launch into Time Machine,

00:03:58.550 --> 00:04:06.090
type in the name of that person, and then fly back through
time to find that person and retrieve those contact details.

00:04:06.090 --> 00:04:12.210
Worse, if you happened to have deleted the person, then
you can also go back and retrieve it in the same way.

00:04:12.210 --> 00:04:18.500
So in effect, your customers automatically gain this
benefit by using -- your customers will gain this benefit.

00:04:18.500 --> 00:04:22.800
One of the things that we've done under the hood

00:04:22.800 --> 00:04:29.990
for Address Book is we've replaced our
own database with the CoreData database.

00:04:29.990 --> 00:04:32.040
And we've done this for a couple of reasons.

00:04:32.040 --> 00:04:33.230
More of which we'll get to later.

00:04:33.230 --> 00:04:38.620
But some of the reasons in fact were to
help us support some of the Time Machine.

00:04:38.620 --> 00:04:44.540
Also to make sure that we don't use too
much memory when managing the contacts.

00:04:44.540 --> 00:04:49.160
And really to make sure that the on disc
representation of those contacts remains coherent.

00:04:49.160 --> 00:04:53.210
So really, no matter what happens,
you know, ecstatic shot, cosmic rays,

00:04:53.209 --> 00:04:57.479
that your data is really safe from any problems.

00:04:57.480 --> 00:05:00.970
Or unexpected problems, even worse.

00:05:00.970 --> 00:05:04.520
So with that, I will hand over to Joe who
will take you through some of the overview

00:05:04.519 --> 00:05:11.250
and give you an understanding of the API.

00:05:11.250 --> 00:05:13.300
( Applause )

00:05:13.300 --> 00:05:17.490
>> Thanks Brendan.

00:05:19.639 --> 00:05:20.939
My name's Joe Engel.

00:05:20.939 --> 00:05:25.290
I am a software engineer in Apple's
internet technologies group on Address Book.

00:05:25.290 --> 00:05:26.640
And this is my slide.

00:05:26.639 --> 00:05:34.509
Today, I'd like to help you learn how you can integrate
your applications with Apple's standard system repository

00:05:34.509 --> 00:05:39.980
for contact information by going over an overview
of our most commonly used APIs and tasks,

00:05:39.980 --> 00:05:44.580
as well as some of the architecture involved.

00:05:44.579 --> 00:05:46.419
So onto the architecture.

00:05:46.420 --> 00:05:54.890
This is by now a possibly familiar looking
stack diagram of the Mac OS X operating system.

00:05:54.889 --> 00:05:58.339
And at its core is the Darwin foundation layer.

00:05:58.339 --> 00:06:04.409
Which is where the kernel and V F S and
concrete file system implementations reside.

00:06:04.410 --> 00:06:09.780
And as Brendan mentioned, now that we're using
CoreData this offers a robust backing store,

00:06:09.779 --> 00:06:15.559
which offers type integration with each of these file
system implementations to provide for file amnesty,

00:06:15.560 --> 00:06:23.519
and coherency for all of your database
transactions such that even in the event

00:06:23.519 --> 00:06:29.099
of a power failure the database
integrity should be maintained.

00:06:30.139 --> 00:06:34.839
Additionally, this is where the I O sub
systems and networking stack reside.

00:06:34.839 --> 00:06:39.919
And these are leveraged by the sync
services layer in system services.

00:06:39.920 --> 00:06:48.930
To allow all of the information your applications enter
into the Address Book a conduit to devices like iPod, PDAs,

00:06:48.930 --> 00:06:54.160
cell phones, as well as network services like dot
Mac, so your data can be universally available.

00:06:54.160 --> 00:06:59.980
Also at this layer is the notification server.

00:06:59.980 --> 00:07:05.900
And Address Book makes use of notifications to
notify your application when another application

00:07:05.899 --> 00:07:09.549
on the system has made a change
to the underlying data store.

00:07:09.550 --> 00:07:15.720
And this allows every application to maintain
a synchronis view of all of the information.

00:07:15.720 --> 00:07:20.050
So when I user adds a contact or removes a
contact from the Address Book application

00:07:20.050 --> 00:07:23.540
or when your application updates a record or adds a contact.

00:07:23.540 --> 00:07:24.950
Every other app can see it as well.

00:07:24.949 --> 00:07:32.430
On top of this is the frameworks layer,
where Address Book itself resides,

00:07:32.430 --> 00:07:36.540
as a peer to framework such as Carbon and Cocoa.

00:07:36.540 --> 00:07:43.520
Here we provide Objective-C interfaces for foundation
and Cocoa applications as well as C interfaces.

00:07:43.519 --> 00:07:51.639
Which can be used by Core foundation applications
and B S C applications, as well as Carbon apps.

00:07:51.639 --> 00:07:57.189
We won't be discussing the C interfaces very
much today, although the Objective-C interfaces

00:07:57.189 --> 00:08:01.050
and the C interfaces have future parity, and
I think you will find them to be very similar.

00:08:01.050 --> 00:08:04.050
So a transition between the two should be fairly natural.

00:08:04.050 --> 00:08:09.780
On top of the frameworks we have search.

00:08:09.779 --> 00:08:18.269
Now search has been an increasingly important
technology in Mac OS X. In 10.4 Tiger, we did Spotlight,

00:08:18.269 --> 00:08:24.609
which began to offer users content indexing of all
the meta data stored in the Address Book records.

00:08:24.610 --> 00:08:31.170
So Spotlight defines property types for
each of the pieces of data in a record

00:08:31.170 --> 00:08:34.529
Such as the e-mail addresses and phone numbers.

00:08:34.529 --> 00:08:38.759
And using the Spotlight APIs, or the
Spotlight feature for the interface,

00:08:38.759 --> 00:08:44.950
your users can quickly search this information
and your applications can retrieve it.

00:08:44.950 --> 00:08:48.710
Inside of the framework we also have
a class called A B search element.

00:08:48.710 --> 00:08:52.759
And you can use this to formulate
expressive queries about those data

00:08:52.759 --> 00:08:55.389
that you wish to retrieve from the persistent store.

00:08:55.389 --> 00:08:59.779
And this is increasingly important
in Leopard for performance reasons,

00:08:59.779 --> 00:09:01.289
which Colter will be getting into later.

00:09:01.289 --> 00:09:06.779
But this is also a handy way to retrieve
just those contacts that you wish.

00:09:06.779 --> 00:09:12.829
And on top of all this, we have the user interface layer.

00:09:12.830 --> 00:09:17.139
And this kind of falls into two categories for Address Book.

00:09:17.139 --> 00:09:21.350
The one most people are familiar with as
users is the Address Book application.

00:09:21.350 --> 00:09:29.659
But as developers we provide a hook for you to provide
an action associated with any bit of information

00:09:29.659 --> 00:09:33.990
so that you can link the Address
Book application into your app.

00:09:33.990 --> 00:09:39.610
So when you roll over one of the properties, a
plug-in that you write can invoke your application

00:09:39.610 --> 00:09:42.350
to perform whatever application may be appropriate.

00:09:43.440 --> 00:09:51.750
Additionally, we provide a user interface module which
reassembles the UI inside of the Address Book application.

00:09:51.750 --> 00:09:54.840
And there is a pallet available in interface builder.

00:09:54.840 --> 00:09:57.740
So you can just drag this out into
your application and use it.

00:09:57.740 --> 00:10:02.490
And it's customizable, so that it can show only
that data which you're interested in for your app.

00:10:02.490 --> 00:10:05.750
Of the pallets available in Tiger.

00:10:05.750 --> 00:10:11.399
And unfortunately it didn't quite make it
into the Leopard DVD that you have this week.

00:10:11.399 --> 00:10:13.840
But I think we will be addressing that shortly.

00:10:13.840 --> 00:10:25.200
So when you actually want to go and use the Address
Book, the first class that you're probably going to need

00:10:25.200 --> 00:10:32.610
to interface with is AB Address Book provides
a work space into the world of Address Book.

00:10:32.610 --> 00:10:36.730
It internally manages interactions with the
Address Book persistent data store as well

00:10:36.730 --> 00:10:41.560
as providing a conduit for search
and localization internally.

00:10:41.559 --> 00:10:52.849
So in order to get an Address Book object, you can
use the shared Address Book method on AB Address Book.

00:10:52.850 --> 00:10:56.279
Every invocation in your application
will return the same object.

00:10:56.279 --> 00:10:59.259
It's a single ten or shared object.

00:10:59.259 --> 00:11:06.269
There's also a new method called Address Book, which will
turn a unique object, which Colter will be discussing.

00:11:08.179 --> 00:11:15.109
Once you have this object you can query the set of
all people in the database using the people method,

00:11:15.110 --> 00:11:19.180
which will return array of people, or groups,
which will return an array of those groups

00:11:19.179 --> 00:11:26.799
that have been defined either by your application
or by the users using the Address Book app.

00:11:26.799 --> 00:11:33.179
You can also manipulate the records with AB Address Book
through of the simple methods, add record, remove record,

00:11:33.179 --> 00:11:39.029
and when you're done making these changes
you can commit them to disc by calling save.

00:11:39.029 --> 00:11:42.350
So what are you getting back when you call people in groups.

00:11:42.350 --> 00:11:44.490
And what are these AB records?

00:11:44.490 --> 00:11:47.909
Well, you're getting back an array
of AB records for people in groups.

00:11:47.909 --> 00:11:55.449
And the AB records themselves are an abstract
superclass for all data types with an Address Book.

00:11:55.450 --> 00:12:01.460
And presently this includes people,
which are also companies, and groups,

00:12:01.460 --> 00:12:05.050
which are containers for other AB records.

00:12:09.970 --> 00:12:13.980
There are a number of methods that
are available on all AB groups.

00:12:13.980 --> 00:12:19.670
And you may notice that this reassembles a
map or a dictionary in that we have a number

00:12:19.669 --> 00:12:23.029
of predefined property constants for all Address Book types.

00:12:23.029 --> 00:12:26.069
So at the AB record level, there are some defined.

00:12:26.070 --> 00:12:32.030
As well as some that are only valid for
the scope of AB person and AB group.

00:12:32.029 --> 00:12:35.419
Using value for property, if you pass
in the associated prompt con constant

00:12:35.419 --> 00:12:38.000
for a type, for example, it would be first name.

00:12:38.000 --> 00:12:44.169
You will be returned an NF string
for a first name for AB person.

00:12:44.169 --> 00:12:46.990
You can manipulate the record using set value for property.

00:12:46.990 --> 00:12:51.129
And when you wish to remove it
using remove value properties.

00:12:51.129 --> 00:12:53.700
Fairly straight forward.

00:12:53.700 --> 00:12:59.530
One important bit about AB record is that
when you're integrating your application

00:12:59.529 --> 00:13:05.069
with Address Book you'll probably want to maintain
some sort of correlation between your data types

00:13:05.070 --> 00:13:08.080
or your records and Address Book records.

00:13:08.080 --> 00:13:12.190
And the appropriate way to do this
is using the unique I.D. method.

00:13:12.190 --> 00:13:16.000
This is available on all AB records,
and it will return an N F string

00:13:16.000 --> 00:13:20.519
which uniquely identifies this record in the database.

00:13:20.519 --> 00:13:24.549
All other pieces of data in the record are mutable.

00:13:24.549 --> 00:13:29.269
Such as the name may change, or
any other piece of information.

00:13:29.269 --> 00:13:32.819
So if you want to keep a consistent reference

00:13:32.820 --> 00:13:40.770
to this you should use the unique I.D.
method and store that in your application.

00:13:42.600 --> 00:13:49.470
Here's some examples of some of the properties available
on AB record for different types of record types.

00:13:49.470 --> 00:13:56.879
So on the top we see that we have the KAB
last name property -- and this returns --

00:13:56.879 --> 00:14:02.399
not surprisingly, the last name or surname of
the individual represented by the AB record.

00:14:02.399 --> 00:14:08.850
The KAB birthday property, however, will return an NS date.

00:14:08.850 --> 00:14:15.370
There's some properties which are only valid for groups.

00:14:15.370 --> 00:14:19.019
Such as the group name property, which
returns the string of the group name.

00:14:19.019 --> 00:14:22.120
And then there are a few that are available on all records.

00:14:22.120 --> 00:14:25.190
And these include the creation date property.

00:14:25.190 --> 00:14:27.970
Which is a date as well as modification date property.

00:14:27.970 --> 00:14:30.480
And NS date as well.

00:14:30.480 --> 00:14:37.769
Now there's one item on here as a data type that you may
not have seen before which is the AB multivalue class.

00:14:39.059 --> 00:14:41.459
So what does this do?

00:14:41.460 --> 00:14:49.160
AB multivalue is used for those situations
where you may have data that has multiple roles.

00:14:49.159 --> 00:14:51.169
For example, telephone numbers.

00:14:51.169 --> 00:14:57.169
You have a home number, a work number,
and also possibly a mobile number.

00:14:57.169 --> 00:15:01.849
And rather than having a single attribute
for this, AB multivalue allows you

00:15:01.850 --> 00:15:06.570
to keep track of these on a pro role basis.

00:15:07.940 --> 00:15:14.970
The multivalue has sub elements, and to find the
number of elements in it, you can use the count method.

00:15:14.970 --> 00:15:20.610
Up until Leopard you had to access these by index.

00:15:20.610 --> 00:15:26.789
And the traditional ways of doing this are
evaluated index, label index, and identifier index.

00:15:26.789 --> 00:15:30.699
Up to the count.

00:15:30.700 --> 00:15:38.030
So there are three properties associated
with each element in an AB multivalue.

00:15:38.029 --> 00:15:39.250
So there's the value itself.

00:15:39.250 --> 00:15:41.950
And there's the label.

00:15:41.950 --> 00:15:44.530
Which is an identifier for the role.

00:15:44.529 --> 00:15:47.089
But the third one is the identifier itself.

00:15:47.090 --> 00:15:53.830
Which is a string similar to the unique I.D., which
uniquely identifies an element inside of the AB multivalue.

00:15:53.830 --> 00:15:58.870
So again, if you want to maintain a
reference to a particular data inside

00:15:58.870 --> 00:16:04.399
of AB multivalue you should do so using the identifier.

00:16:04.399 --> 00:16:06.189
Because the label may change as well.

00:16:06.190 --> 00:16:09.810
Perhaps the land line's been converted to
a mobile number, or the number's changed.

00:16:09.809 --> 00:16:14.799
But if you want to keep a reference to
just that element, use the identifier.

00:16:14.799 --> 00:16:17.309
Excuse me.

00:16:17.309 --> 00:16:21.000
And new in Leopard we have two
new method which are convenient

00:16:21.000 --> 00:16:25.100
with Objective-C 2.0's class denumeration feature.

00:16:25.100 --> 00:16:28.850
And these are value for identifier and label for identifier.

00:16:28.850 --> 00:16:32.040
Which allow you to bypass the indices entirely.

00:16:32.039 --> 00:16:43.299
So you can enumerate over the identifiers in a
four-loop and access just the values and labels.

00:16:43.299 --> 00:16:46.839
There's another variant of AB multivalue.

00:16:46.840 --> 00:16:49.910
AB multivalue itself is immutable.

00:16:49.909 --> 00:16:54.829
However, there's also a mutable
variant for mutable multivalues

00:16:54.830 --> 00:16:58.030
that you can change and then store back into the database.

00:16:59.759 --> 00:17:05.210
The second type of record that I mentioned is AB group.

00:17:05.210 --> 00:17:09.720
And AB group serves as a container
for other AB record types.

00:17:09.720 --> 00:17:16.289
Now being an AB record type itself, this means
that AB group it contain other AB groups.

00:17:16.289 --> 00:17:20.769
And you can do this on the Address Book application
very easily by dragging AB group into another.

00:17:20.769 --> 00:17:27.700
And this is handy for, like, scenarios like Brendan,
who manages as he said both mail and Address Book.

00:17:27.700 --> 00:17:32.650
He might have one group for all the Address Book
engineers, one group for all the mail engineers.

00:17:32.650 --> 00:17:38.240
But when he wants to send mail to his entire organization,
he could have a group that contains both of those groups.

00:17:38.240 --> 00:17:41.900
And here's where hierarchy becomes
very useful for your users.

00:17:43.109 --> 00:17:46.939
You can query the membership of a group by calling members,

00:17:46.940 --> 00:17:50.559
which will return an array of AB
people, or AB person objects.

00:17:50.559 --> 00:17:58.730
And add member and remove member
may be used to manipulated the list.

00:17:58.730 --> 00:18:02.380
For examining the hierarchy, you can use parent groups.

00:18:02.380 --> 00:18:10.610
To find those groups that are contained by this group and
other groups to find those groups that this group contains.

00:18:10.609 --> 00:18:19.149
There's one additional feature in AB
group which is a kind of hidden feature.

00:18:19.150 --> 00:18:20.730
But it's been around.

00:18:20.730 --> 00:18:23.339
And that is distribution lists.

00:18:24.789 --> 00:18:28.170
So for multivalues you may have several e-mail addresses.

00:18:28.170 --> 00:18:32.620
You might have a work e-mail address, a
home e-mail address for the e-mail property.

00:18:32.619 --> 00:18:37.329
But when you send e-mail to a group, how do you
know which e-mail address it's going to pick.

00:18:37.329 --> 00:18:41.569
Or more importantly, how do you specify which one?

00:18:41.569 --> 00:18:46.319
If you're sending a work-related e-mail you probably
want it to go to their e-mail address at work.

00:18:46.319 --> 00:18:55.299
And you can use a primary identifier on the group
using set distribution identifier for property person.

00:18:55.299 --> 00:19:00.450
You just pass the identifier for the
element in the AB multivalue that you want

00:19:00.450 --> 00:19:05.710
to associate as the primary one for this group.

00:19:05.710 --> 00:19:13.870
Pass in the property string for the time, and
then the person that you want it to be applied to.

00:19:13.869 --> 00:19:15.419
And one final bit.

00:19:15.420 --> 00:19:21.920
Into the bit passed into the API level, but still
quite important is that of the notifications.

00:19:21.920 --> 00:19:29.920
Address Book using notifications to alert
your application about database state changes.

00:19:29.920 --> 00:19:36.630
So if you're running, and another application is
running, which is almost guaranteed to be the case,

00:19:38.500 --> 00:19:41.450
many of these apps may be making
changes underneath of your app.

00:19:41.450 --> 00:19:46.460
So if they're running your application and
they're also running the Address Book application,

00:19:46.460 --> 00:19:52.240
they could be making changes to contacts, or
possibly even deleting the one you're working with.

00:19:52.240 --> 00:19:56.779
These notifications allow you to
respond appropriately to these actions.

00:19:56.779 --> 00:20:04.069
And it's especially important that you
not continue to reference deleted records.

00:20:04.069 --> 00:20:05.909
If you have any sort of interactive use of the API.

00:20:05.910 --> 00:20:10.610
It's not quite as bad as, say,
referencing deal indicated memory.

00:20:10.609 --> 00:20:15.000
It won't cause a crash in your application, but
it will raise an exception because underneath

00:20:15.000 --> 00:20:21.410
of the framework it causes a fault that CoreData
could not fulfill because the record has been deleted.

00:20:21.410 --> 00:20:26.440
So if you just listen to these
notifications you will be fine.

00:20:26.440 --> 00:20:32.340
But how do you know that a record's been deleted?

00:20:32.339 --> 00:20:36.269
Well, there are two kinds of notifications.

00:20:36.269 --> 00:20:43.690
And the most important one is the K A B
database changed externally notification.

00:20:43.690 --> 00:20:49.720
And this informs you of changes made
by other applications to the database.

00:20:51.410 --> 00:20:55.950
We also have a K B database change notification.

00:20:55.950 --> 00:21:03.200
And the distinction between the externally changed
notification and the change notification is

00:21:03.200 --> 00:21:09.789
that the AB database change notification is only
sent to you if you register for it in response

00:21:09.789 --> 00:21:12.849
to changes that you make to the database.

00:21:12.849 --> 00:21:15.269
This is mostly a convenience.

00:21:15.269 --> 00:21:18.990
So that if you have multiple windows or multiple views,

00:21:18.990 --> 00:21:22.880
your view controller are register
for interest in this notification.

00:21:22.880 --> 00:21:33.460
And when one of your windows makes a change to
your model then all of your views can be updated.

00:21:35.869 --> 00:21:43.119
If you called the user info method on the
notification objects sent to your notification handler.

00:21:43.119 --> 00:21:49.789
You will be sent or you will be returned
a dictionary object with three keys.

00:21:49.789 --> 00:21:54.029
And these allow you to know precisely
what happened under the hood.

00:21:54.029 --> 00:21:58.980
Why some other application or your own, to the database.

00:21:58.980 --> 00:22:07.390
So if you want to find out which records have been deleted,
you can use the deleted records key on that dictionary

00:22:07.390 --> 00:22:14.480
to retrieve that list as well as a list
for inserted records or updated records.

00:22:14.480 --> 00:22:22.670
All of these notifications are sent
by the default notification center,

00:22:22.670 --> 00:22:24.980
and not the distribution notification center.

00:22:24.980 --> 00:22:32.009
It might seem natural that because the external change
notifications are coming from other applications

00:22:32.009 --> 00:22:34.420
that they would be sent on the
distributed notification center.

00:22:34.420 --> 00:22:37.220
But they are all sent by the default notification center.

00:22:37.220 --> 00:22:42.390
So use the NS notification center and not
the distributive notification center this is.

00:22:42.390 --> 00:22:46.180
There may be some distributive
notifications underneath the hood.

00:22:46.180 --> 00:22:53.230
But the framework will interpret those and rebroadcast
them to you as local notifications as appropriate.

00:22:53.230 --> 00:22:58.339
And that about covers the API overview.

00:22:58.339 --> 00:23:01.789
So I would like to turn this over to Bret
who's going to be going over action plug-ins

00:23:01.789 --> 00:23:06.990
for the Address Book application, as
well as how to use the people picker.

00:23:06.990 --> 00:23:07.640
Bret?

00:23:07.640 --> 00:23:12.560
( Applause )

00:23:12.559 --> 00:23:14.819
>> Thanks Joe.

00:23:16.140 --> 00:23:17.800
Good morning.

00:23:17.799 --> 00:23:20.529
Let me get some water first.

00:23:24.539 --> 00:23:27.220
I'm sorry.

00:23:27.220 --> 00:23:28.319
Good morning.

00:23:28.319 --> 00:23:36.980
I am Brett Neeley and I work on
Address Book as the quality assurance and build engineer.

00:23:36.980 --> 00:23:38.529
Let's get started to these two topics.

00:23:38.529 --> 00:23:43.670
First I will be talking about the people picker,
which is a user interface we provide in your framework

00:23:43.670 --> 00:23:48.310
to let users take advantage of contact
information they already have in their databases.

00:23:48.309 --> 00:23:54.809
Secondly, I'll talk about the action plug-in API that we
provide allowing you to add features to the application

00:23:54.809 --> 00:23:58.529
and hook into services or applications that you provide.

00:23:58.529 --> 00:24:04.230
So why would you want to use something
like of the People Picker in your software?

00:24:04.230 --> 00:24:07.559
Well, let's take a look back at the
early days of commerce on the Web.

00:24:07.559 --> 00:24:10.339
Have you seen something like this before?

00:24:10.339 --> 00:24:14.509
This is a site where maybe you're making a
purchase here, and the site is asking you

00:24:14.509 --> 00:24:17.329
to enter your billing and shipping address.

00:24:17.329 --> 00:24:22.619
Well, because of the way this form is constructed
you have to enter that information twice.

00:24:22.619 --> 00:24:25.079
Isn't that a hassle?

00:24:25.079 --> 00:24:29.839
So move beyond this interface, and to
improve it is to add a check box here

00:24:29.839 --> 00:24:33.459
that says use the same address for billing and shipping.

00:24:33.460 --> 00:24:35.170
So now you can only enter the address once.

00:24:35.170 --> 00:24:37.140
And that's nice.

00:24:37.140 --> 00:24:45.300
But if the address is already on your system, why not just
take advantage of that data and not retype anything at all.

00:24:45.299 --> 00:24:49.359
And if that's what you want to do
then you should use is People Picker.

00:24:49.359 --> 00:24:51.069
What does the People Picker look like?

00:24:51.069 --> 00:24:54.509
Well, let's start by taking a look
at the Address Book application.

00:24:55.640 --> 00:24:58.040
This layout has three columns in it.

00:24:58.039 --> 00:24:59.859
Groups are on the left.

00:24:59.859 --> 00:25:00.669
Names in the middle.

00:25:00.670 --> 00:25:03.480
And then values on the right.

00:25:03.480 --> 00:25:07.660
And at the top right of this window
you'll see our search field.

00:25:07.660 --> 00:25:08.950
So now I'll show you the People Picker.

00:25:08.950 --> 00:25:15.090
And this layout pretty much matches
the Address Book application.

00:25:15.089 --> 00:25:16.549
Groups on the left.

00:25:16.549 --> 00:25:17.649
Names in the middle.

00:25:17.650 --> 00:25:19.320
Values on the right.

00:25:19.319 --> 00:25:23.200
And the top right of this window also has a search field.

00:25:24.660 --> 00:25:31.430
Let's take a closer look now at how the
mail application uses the People Picker.

00:25:33.799 --> 00:25:36.930
This is mail's People Picker, and
I'll point out two things here.

00:25:36.930 --> 00:25:44.210
First, on the right-most column the mail application
configures the People Picker to display e-mail addresses.

00:25:44.210 --> 00:25:50.630
For e-mail application, the e-mail property in AB
person is the most important type of value to display.

00:25:50.630 --> 00:25:56.920
Now second, on the top left of this
window we see these three buttons.

00:25:56.920 --> 00:26:00.170
Well, how did mail put these buttons
into our user interface?

00:26:00.170 --> 00:26:02.850
Well, this is actually public API.

00:26:02.849 --> 00:26:09.480
This is called the accessory view inside of the AB People
Picker view that we provide for Objective-C developers.

00:26:10.640 --> 00:26:16.580
So using these three buttons, mail is able to provide
a complete work flow for composing a new mail message

00:26:16.579 --> 00:26:19.990
to an existing e-mail address into
the Address Book database.

00:26:19.990 --> 00:26:27.150
So when the user selects an e-mail address,
presses either 2 C C, or C C B here,

00:26:27.150 --> 00:26:30.700
then that e-mail address is added to a mail compose window.

00:26:31.950 --> 00:26:33.420
Now let's look at iChat's People Picker.

00:26:33.420 --> 00:26:35.140
This is a little bit different.

00:26:35.140 --> 00:26:38.259
And I'll point out a couple things here as well.

00:26:38.259 --> 00:26:45.950
First you'll notice that the right-most column is
displaying the Aim property from the AB person class.

00:26:47.849 --> 00:26:54.609
This gives the user the opportunity to add buddies to their
Aim buddy list by using a value from their Address Book.

00:26:54.609 --> 00:26:56.449
If it exists there already.

00:26:56.450 --> 00:27:02.630
But you also notice that next to the Aim column
in the column header is the up down arrows.

00:27:02.630 --> 00:27:08.680
And this indicates that the People Picker
is providing you with a pop up menu.

00:27:08.680 --> 00:27:13.150
So the People Picker can provide more than
one prompt, but not more than one at a time.

00:27:13.150 --> 00:27:19.300
So the iChat People Picker shows both
the Aim and the e-mail properties.

00:27:19.299 --> 00:27:24.430
Now why does iChat need to use the
e-mail property in addition to Aim?

00:27:24.430 --> 00:27:29.890
Well, this is because dot Mac e-mail accounts
can also be used as Aim buddy handles.

00:27:29.890 --> 00:27:38.150
So if you have an Aim account, or a Mac dot com
e-mail address in one of your existing contacts,

00:27:38.150 --> 00:27:44.560
you can select it from this UI
and add it to your Aim buddy list.

00:27:44.559 --> 00:27:48.929
Now iChat also puts these three
text fields above the People Picker.

00:27:48.930 --> 00:27:50.380
And what do these do?

00:27:50.380 --> 00:27:54.330
Well, it seems to be just showing
the same information that's displayed

00:27:54.329 --> 00:27:56.720
with the current selection in the People Picker.

00:27:56.720 --> 00:27:59.650
But these are also editable text fields.

00:27:59.650 --> 00:28:06.180
So say that you select a contact in Address Book that
does not vet have an Aim account associated with it.

00:28:06.180 --> 00:28:12.930
You can select that contact, go to the account name text
field above the window, above the People Picker view,

00:28:12.930 --> 00:28:16.500
and then type in the account name and press the add button.

00:28:16.500 --> 00:28:18.289
And that will do two things.

00:28:18.289 --> 00:28:23.119
That will save the Aim account to the Address
Book card and the Address Book application

00:28:23.119 --> 00:28:26.109
and then add the Aim account to your buddy list as well.

00:28:26.109 --> 00:28:33.969
So iChat is providing a complete work flow within
this window to add existing or new Aim accounts

00:28:33.970 --> 00:28:38.870
to your buddy list and up date your
Address Book application if necessary.

00:28:38.869 --> 00:28:43.629
And you don't have to jump back and forth between
Address Book and iChat to accomplish this.

00:28:46.779 --> 00:28:52.609
Now how is iChat keeping these text fields in
sync with the selections inside the People Picker.

00:28:52.609 --> 00:28:55.659
Well, this is done with the selection
change notifications that we provide

00:28:55.660 --> 00:28:59.330
in the People Picker which I will talk about shortly.

00:28:59.329 --> 00:29:06.929
In order to retrieve values from the People Picker,

00:29:06.930 --> 00:29:11.080
you can add buttons to accessory view
as I pointed out with the mail example.

00:29:11.079 --> 00:29:17.419
Or you might decide to configure double actions
to associate with name or group selections.

00:29:17.420 --> 00:29:20.970
So a double action is a double-click on the user interface.

00:29:20.970 --> 00:29:26.400
So if a group or a name is double-clicked then
the method that you provide will be invoked.

00:29:27.569 --> 00:29:33.200
And it's this easy using one of these two
methods to retrieve the selected values

00:29:33.200 --> 00:29:35.819
or the selected records from the People Picker.

00:29:37.920 --> 00:29:48.870
The notifications I mentioned during the iChat demo,
the screen shots, the notifications are shown here.

00:29:48.869 --> 00:29:53.509
AB People Picker group did -- group
selection did change notification,

00:29:53.509 --> 00:29:57.269
or name selection did change, or value selection did change.

00:29:57.269 --> 00:30:03.940
You can register for any or all of these notifications
to update your user interface or take some action.

00:30:03.940 --> 00:30:07.009
And this code example at the bottom
will show you how to do that.

00:30:07.009 --> 00:30:14.160
In this example we register tomorrow the AB People
Picker value selection did change notification.

00:30:14.160 --> 00:30:20.540
And when that notification is received, then the picker
up dated method that's highlighted here will be invoked.

00:30:24.029 --> 00:30:28.259
Let's summarize what we've just been
discussing about the People Picker.

00:30:28.259 --> 00:30:33.430
This is a familiar user interface that's based directly
on the user interface of the Address Book application.

00:30:33.430 --> 00:30:40.470
It's a great way to provide an interface to your users
to use information already entered in their Address Book.

00:30:40.470 --> 00:30:43.380
And to avoid the hassles of retyping
something that they know they just typed

00:30:43.380 --> 00:30:47.150
in a few minutes ago, or some time in the past.

00:30:47.150 --> 00:30:50.400
Search is provided for free in this user interface.

00:30:50.400 --> 00:30:54.090
All of the People Pickers have
the search field at the top right

00:30:54.089 --> 00:31:00.259
so users can quickly filter the name
list by typing in a search term there.

00:31:00.259 --> 00:31:03.700
The picker is provided for both
C and Objective-C developers,

00:31:03.700 --> 00:31:09.000
and the difference between these two People
Pickers is that the C People Picker is a window,

00:31:09.000 --> 00:31:11.349
whereas the Objective-C People Picker is a view.

00:31:11.349 --> 00:31:15.819
And the Objective-C People Picker
also provides the accessory view,

00:31:15.819 --> 00:31:18.950
allowing you to add some user interface elements.

00:31:18.950 --> 00:31:21.779
All right.

00:31:21.779 --> 00:31:29.990
Let's move on, and now we'll talk about the Address
Book plug-in APIs that we provide in the application.

00:31:31.319 --> 00:31:38.009
So the action plug-in API allows you to add features to
Address Book that hook into your application or service.

00:31:38.009 --> 00:31:41.049
How does this look in the application?

00:31:41.049 --> 00:31:43.609
Let's take a look at this Apple card here.

00:31:43.609 --> 00:31:48.250
So we see a phone under, an URL, and a street address.

00:31:48.250 --> 00:31:52.240
And on the left of these values
we see what's called the label

00:31:52.240 --> 00:31:55.500
Now clicking on the label will bring up a menu of options.

00:31:55.500 --> 00:32:01.460
And let's click on the menu to the left of the street
address, for example, and we'll see this pop up menu.

00:32:01.460 --> 00:32:04.860
This is what we call the option menu.

00:32:04.859 --> 00:32:08.719
These options here are actions that
can be performed on the selected value.

00:32:08.720 --> 00:32:11.009
So the first option here is Map Of.

00:32:11.009 --> 00:32:15.150
And this will map the street address in your Web browser.

00:32:15.150 --> 00:32:19.730
And new for Leopard we are mapping
these street addresses with Google Maps.

00:32:19.730 --> 00:32:22.890
So what's it like to create one of these plug-ins?

00:32:22.890 --> 00:32:24.000
Well, it's not too hard at all.

00:32:24.000 --> 00:32:25.690
Let's take a look at X code.

00:32:25.690 --> 00:32:29.289
And I will be switching to the demo machine please.

00:32:32.579 --> 00:32:37.579
Okay. So I launched X code.

00:32:37.579 --> 00:32:41.779
And I'll go to the file menu to
open a new project assistant.

00:32:44.400 --> 00:32:48.940
So scrolling down to the bottom we find
this group called standard Apple plug-ins.

00:32:50.119 --> 00:32:55.089
Here we provided plug-in templates
for C and Objective-C developers.

00:32:55.089 --> 00:32:58.289
And I'll do my demo in Objective-C.

00:32:58.289 --> 00:33:07.809
And we'll give this -- we'll give the project a name.

00:33:07.809 --> 00:33:10.599
And then hit finish.

00:33:10.599 --> 00:33:13.459
Here's your plug-ins project.

00:33:13.460 --> 00:33:15.049
And at this point we'll just go ahead and build it.

00:33:15.049 --> 00:33:18.470
Because this is already a fully working plug-in.

00:33:18.470 --> 00:33:22.339
Now plug-ins can be installed into
one of two locations on the system.

00:33:22.339 --> 00:33:28.389
They are be installed to the top level library directory,
which means that the plug-in is visible to all users.

00:33:28.390 --> 00:33:33.340
Or the plug-in can be installed into the user's
directory, so it's only visible to that user.

00:33:34.400 --> 00:33:40.350
For this example I am going to install
the plug-ins for only this logged in user.

00:33:40.349 --> 00:33:43.230
So it's going to be library directory.

00:33:43.230 --> 00:33:48.180
And here's the Address Book plug-ins
directory that we provide.

00:33:48.180 --> 00:33:50.120
And so this is empty right now.

00:33:50.119 --> 00:33:57.809
There is no custom plug-ins installed -- let's go find the
build directory for the plug-in project that I just created.

00:33:57.809 --> 00:34:01.089
Okay. Here's session 209 plug-in.

00:34:01.089 --> 00:34:03.490
Build. Release.

00:34:03.490 --> 00:34:05.990
And here is the bundle that we just built.

00:34:05.990 --> 00:34:09.420
So now I'll just drag this into
the Address Book plug-in directory.

00:34:09.420 --> 00:34:11.200
Sorry. That was so loud.

00:34:12.820 --> 00:34:14.670
And now I launch Address Book.

00:34:14.670 --> 00:34:19.019
So this plug-in by default works
with the K A B property on AB person.

00:34:19.019 --> 00:34:24.050
So that means when we bring up the phone
action mean you we will see a new menu item,

00:34:24.050 --> 00:34:26.380
and it's called Speak 1-800 My Apple.

00:34:26.380 --> 00:34:32.700
And what we've done here is we've taken -- we've retrieved
the value of the phone number that the user selected

00:34:32.699 --> 00:34:37.889
from the card and we used that to fill in the menu title,
and I'll show you how that's done in just a moment.

00:34:37.889 --> 00:34:39.129
So let's go ahead run the plug-in now.

00:34:39.130 --> 00:34:46.400
( Applause )
>> 1 -800 My Apple.

00:34:47.650 --> 00:34:48.349
>> Goodness, that's loud.

00:34:48.349 --> 00:34:53.239
I will do that one more time, a little bit quieter.

00:34:53.239 --> 00:34:55.250
>> 1-800 My Apple.

00:34:55.250 --> 00:34:58.269
>> Okay. That was kind of a phone number.

00:34:58.269 --> 00:35:04.179
Okay. So now we've seen how the plug-in can be
installed, built, and then shown up in Address Book.

00:35:04.179 --> 00:35:08.329
Now let's take a look at the code behind the plug-in.

00:35:08.329 --> 00:35:12.049
Our plug-in API is based around four tasks.

00:35:12.050 --> 00:35:20.750
So whether we're doing C, Objective-C, or Apple Script,
you'll have to implement four methods, functions,

00:35:20.750 --> 00:35:23.059
or handlers to perform the plug-in actions.

00:35:23.059 --> 00:35:28.019
First we have this action property method.

00:35:28.019 --> 00:35:33.389
This method tells Address Book which property
on AB person the plug-in will operate upon.

00:35:33.389 --> 00:35:38.239
So this is returning KAB phone property, which is one
of the can constants that we provide in the framework.

00:35:40.840 --> 00:35:43.260
Title for person identifier.

00:35:43.260 --> 00:35:49.230
Now this method retrieves -- receives two parameters
from the Address Book application informing

00:35:49.230 --> 00:35:55.110
which AB person is current displayed in the
application, and which unique identifies the value

00:35:55.110 --> 00:35:58.130
in the multivalue that the user has selected.

00:35:58.130 --> 00:36:04.450
And this method is responsible for setting the
menu title, which is done here on the last line.

00:36:04.449 --> 00:36:09.699
So see here that the code is based around
retrieving the value from the contact

00:36:09.699 --> 00:36:14.009
and then setting the menu title with Speak Value.

00:36:17.460 --> 00:36:22.230
Perform action for person identifier receives
those same parameters I just mentioned

00:36:22.230 --> 00:36:24.329
from the Address Book application.

00:36:24.329 --> 00:36:28.789
And this is responsible for actually
doing the work of the plug-in.

00:36:28.789 --> 00:36:33.860
And in this case, the example that we provide
is we create an NS speech synthesizer object,

00:36:33.860 --> 00:36:40.980
receive the value from the record, and then
have the speech synthesizer speak the value.

00:36:43.920 --> 00:36:52.180
And finally, should enable action for person identifier
again receive those same parameters, and give you the chance

00:36:52.179 --> 00:36:55.599
to initially enable or disable your plug-in.

00:36:55.599 --> 00:36:59.210
Based on whether or not the value meets the criteria.

00:37:01.750 --> 00:37:06.010
One example of how you might use this is if you're
writing a plug-in that works on the phone property

00:37:06.010 --> 00:37:10.860
and you can only operate on 1-800
numbers, or if you're operating on the KAB

00:37:10.860 --> 00:37:13.890
or URL's property, and you can only work on HTTPS URLs.

00:37:13.889 --> 00:37:20.210
If you wanted to disable your plug-in, you would
return no unconditionally in this method here.

00:37:20.210 --> 00:37:24.170
And then your menu item would still appear in
the user interface, but it would be disabled.

00:37:27.269 --> 00:37:30.690
So that's all the code that's behind
this plug-in that I have shown to you.

00:37:30.690 --> 00:37:33.869
I now have another example to show.

00:37:33.869 --> 00:37:38.599
To give you an idea of how else this API can be used.

00:37:38.599 --> 00:37:43.170
Let's go back to the Address Book
plug-in's directory for this user.

00:37:43.170 --> 00:37:47.250
And I have a street bundle that we've created.

00:37:47.250 --> 00:37:49.820
This is from Joe.

00:37:49.820 --> 00:37:53.000
Then I'll launch Address Book again.

00:37:53.000 --> 00:37:55.219
And okay, here's the card.

00:37:55.219 --> 00:37:59.879
So I heard there's a cool store somewhere
near 1 Stocking Street here in the city.

00:37:59.880 --> 00:38:05.890
Now I have any new plug-in title here
called take a look around 1 Stocking Street.

00:38:05.889 --> 00:38:08.409
Let's run that and see what it does.

00:38:11.840 --> 00:38:13.390
Okay. This will bring up Google maps.

00:38:13.389 --> 00:38:16.889
And now we're using the street view from Google maps.

00:38:16.889 --> 00:38:21.900
So let's rotate here and see what's around here.

00:38:21.900 --> 00:38:24.309
I think I see something that I like.

00:38:27.309 --> 00:38:28.199
That looks like an Apple store.

00:38:28.199 --> 00:38:31.179
Okay. That's cool.

00:38:31.179 --> 00:38:34.329
Let's see what's down here.

00:38:34.329 --> 00:38:36.199
Just zoom in.

00:38:36.199 --> 00:38:37.369
Ah, I see some shuffles there.

00:38:37.369 --> 00:38:40.309
Look at all those pretty colors.

00:38:40.309 --> 00:38:45.539
And note that if you're going to park here just pay
that meter, because those tickets are expensive.

00:38:45.539 --> 00:38:50.730
So that's another example of what you can
do with the information that you can receive

00:38:50.730 --> 00:38:54.860
from Address Book through the action plug-in API.

00:38:54.860 --> 00:39:03.809
Okay. Now switch back to the slides please.

00:39:03.809 --> 00:39:07.610
Seed developers can use this call back
based API which structured very similarly

00:39:07.610 --> 00:39:11.710
to our Objective-C API for the action plug-in interface.

00:39:11.710 --> 00:39:17.699
And you'll notice the same values, the same value parameters
are passed in to you from the Address Book application.

00:39:17.699 --> 00:39:23.529
Person identifier, except these are
AB person refs in C F string refs.

00:39:23.530 --> 00:39:30.360
This is also a fully working template installed for you
in X code when you use the standard Apple plug-ins group.

00:39:32.489 --> 00:39:35.000
We allow you to write plug-ins using Apple Script.

00:39:35.000 --> 00:39:38.440
Here are the four handlers that
you would implement to do that.

00:39:38.440 --> 00:39:43.590
And whether you're writing a plug-in using Objective-C,
C, or Apple Script all the plug-ins are installed

00:39:43.590 --> 00:39:46.360
to the same locations that I mentioned earlier.

00:39:50.530 --> 00:39:54.090
Now I'd like to talk about some
best practices for using this API.

00:39:55.789 --> 00:39:58.489
It's important that your plug-in is able to load quickly,

00:39:58.489 --> 00:40:02.169
and quickly tell Address Book what the
menu title should be for the plug-in.

00:40:02.170 --> 00:40:07.829
Plug-ins are only loaded at the time the user first
brings up one of the action menus in the user interface.

00:40:10.159 --> 00:40:13.250
Also keep in mind that if you're
developing and shipping a plug-in,

00:40:13.250 --> 00:40:16.969
your plug-in might be only one of
several that the user has installed.

00:40:19.570 --> 00:40:24.490
Appropriate actions that you can perform with
this plug-in interface is you can openly an URL

00:40:24.489 --> 00:40:27.759
to direct the user to an on line service of some form.

00:40:27.760 --> 00:40:30.290
Or you could pass the value to your own application.

00:40:30.289 --> 00:40:36.739
Either through a local URL or if the app is already
running, you could post notification so send the value.

00:40:41.260 --> 00:40:44.310
Now summarize the action plug-in APIs for you.

00:40:44.309 --> 00:40:49.699
This is a simple but powerful API that we provide
to you to let you hook your features or services

00:40:49.699 --> 00:40:51.929
into the Address Book user interface directly.

00:40:51.929 --> 00:40:56.609
You would use Objective-C, C, or Apple Script to do this.

00:40:56.610 --> 00:41:03.320
And developers of C and Objective-C can use the templates
that we provide in X code to get started very quickly.

00:41:03.320 --> 00:41:06.880
Once you make the template project I did of X
code, you already have a fully working plug-in.

00:41:06.880 --> 00:41:11.820
So you can build it, run it, and
then modify it to your needs.

00:41:11.820 --> 00:41:20.110
And you can use this API to pass values to your application
or service directory from the Address Book user interface.

00:41:22.559 --> 00:41:24.739
Not that you know all this I hope that you go forth

00:41:24.739 --> 00:41:28.059
and write some great new plug-ins
for our Address Book application.

00:41:31.340 --> 00:41:33.750
Now I'll introduce Colter Reed, who will come to talk to you

00:41:33.750 --> 00:41:37.300
about the best practices with the Address Book API.

00:41:37.300 --> 00:41:38.050
Thank you.

00:41:38.050 --> 00:41:43.330
( Applause )

00:41:43.329 --> 00:41:44.769
>> Thanks, Bret.

00:41:44.769 --> 00:41:46.070
Good morning.

00:41:46.070 --> 00:41:46.559
I'm Colter.

00:41:46.559 --> 00:41:48.299
One of the Address Book engineers.

00:41:48.300 --> 00:41:52.110
And the next 15, 20 minutes I'm going to
cover some best practices to keep in mind

00:41:52.110 --> 00:41:54.380
when you're developing for the Address Book framework.

00:41:54.380 --> 00:41:59.230
We made some changes behind the scenes for
Leopard and we want to make sure that you're aware

00:41:59.230 --> 00:42:02.880
of a couple potential hot spots,
to keep an eye out in your code.

00:42:02.880 --> 00:42:07.250
Or if you're just developing your application,
hopefully we'll get you started on the right foot.

00:42:07.250 --> 00:42:11.159
We want to make sure that the changes that we've
made to Leopard will work to your advantage.

00:42:11.159 --> 00:42:12.929
We'll be covering three things.

00:42:12.929 --> 00:42:14.659
All of them have to do with performance.

00:42:14.659 --> 00:42:23.399
The first two are going to be ways that your application
can use less memory and get things done faster.

00:42:23.400 --> 00:42:28.960
And the third one is going to be going
into how you might be doing as little work

00:42:28.960 --> 00:42:33.329
as possible to get the results that you want.

00:42:33.329 --> 00:42:36.009
Let's go back to Tiger for a second.

00:42:36.010 --> 00:42:43.320
In Tiger, we made some assumptions about how the clients
were using our framework, or going to be using them.

00:42:43.320 --> 00:42:49.680
And one of the assumptions that we made was that if you were
interested in any of the data that was in the Address Book,

00:42:49.679 --> 00:42:52.889
you were going to be interested in all
the data that was in the Address Book.

00:42:52.889 --> 00:42:59.429
And so as soon as your application watched, we made sure
that all of the information that the Address Book was loaded

00:42:59.429 --> 00:43:01.929
into memory, it was ready, it was waiting.

00:43:01.929 --> 00:43:04.279
As soon as you wanted it, it was there.

00:43:04.280 --> 00:43:13.240
But no. There are a lot of really great applications
out there for OS X. They're all using Address Book

00:43:13.239 --> 00:43:18.799
to store the contact information centrally and get
these great benefits that Brendan talked about.

00:43:18.800 --> 00:43:24.560
And each one of these applications is
interested in a different type of information.

00:43:24.559 --> 00:43:30.529
If you're writing an e-mail client, you're going to be
interested in the e-mail addresses that a person has.

00:43:30.530 --> 00:43:35.000
If you're writing a Web browser, you're going
to be interested in the URLs that they have.

00:43:35.000 --> 00:43:38.960
Maybe one or two addresses to help
them fill out forms quickly.

00:43:38.960 --> 00:43:44.340
But the rest of the information, your
application probably isn't concerned with.

00:43:44.340 --> 00:43:50.430
So in Leopard we're going to wait to
load information until you ask for it.

00:43:50.429 --> 00:43:55.099
And there is one thing that is going to be critical
to making this work to everyone's advantage.

00:43:55.099 --> 00:43:56.159
And that's searching.

00:43:56.159 --> 00:43:59.629
Let me show you how.

00:44:01.590 --> 00:44:03.990
Say you're writing an app -- say
you're writing an e-mail application.

00:44:03.989 --> 00:44:08.939
And you want to build a quiet list out of all the e-mail
addresses that a person has in their Address Book.

00:44:08.940 --> 00:44:11.099
You might have a loop something like this.

00:44:11.099 --> 00:44:18.730
We're going to use the new four in syntax as part of
Objective-C 2.0, and we're going to ask the Address Book

00:44:18.730 --> 00:44:21.059
for a list of all the people that it has.

00:44:21.059 --> 00:44:23.719
We're going to iterate over the array that comes back.

00:44:23.719 --> 00:44:28.939
And we're going to ask each person
for the e-mails that they have.

00:44:28.940 --> 00:44:32.639
And we're going to add those e-mails to our writing list.

00:44:32.639 --> 00:44:38.500
Now let's look at this from a memory access
standpoint and see what's going on behind the scenes.

00:44:39.519 --> 00:44:44.190
At the beginning of the loop you asked the Address
Book framework for a list of all the people.

00:44:44.190 --> 00:44:48.550
So we'll go to the disc, we'll get you a
list of all the people in the Address Book.

00:44:48.550 --> 00:44:50.170
You go into the loop.

00:44:50.170 --> 00:44:53.940
You get to the first person, you ask us
for the e-mail address for person one.

00:44:53.940 --> 00:44:54.809
We'll go to the disc.

00:44:54.809 --> 00:44:57.820
We'll get you the e-mail address for person one.

00:44:57.820 --> 00:44:59.230
You get to person two.

00:44:59.230 --> 00:45:01.980
You ask us for the e-mail address for person two.

00:45:01.980 --> 00:45:04.860
We'll go back to the disc, we'll get
you the e-mail address for person two.

00:45:04.860 --> 00:45:11.930
We'll go back to the disc and we'll get
you the e-mail addresses for person three.

00:45:11.929 --> 00:45:17.989
We're not going to second-guess your application and try
to predict what kind of information you're interested in.

00:45:17.989 --> 00:45:24.439
We're going to wait until you ask for information
before we go to the disc and get it for you.

00:45:24.440 --> 00:45:30.829
And as a result this loop is going to end up spending a lot
of time waiting on disc access; waiting for us to come back.

00:45:30.829 --> 00:45:32.019
How does search make this better?

00:45:32.019 --> 00:45:34.369
Let's go back to the beginning of the loop.

00:45:34.369 --> 00:45:40.190
If you just ask us for a list of all the people
we don't know what you're interested in next.

00:45:40.190 --> 00:45:44.920
But if you ask us for the people who have
an e-mail address, that gives us a clue.

00:45:44.920 --> 00:45:48.460
I mean, wow, you're probably interested in the e-mail data.

00:45:48.460 --> 00:45:53.230
So the same trip that we go to the disc and we get
you the list of people who have e-mail addresses,

00:45:53.230 --> 00:45:58.380
and just people who have e-mail addresses, we
can also get that e-mail data at the same time.

00:45:58.380 --> 00:46:01.730
And then the loop can go through and
it doesn't have to touch the disc again

00:46:01.730 --> 00:46:04.050
because all that data is already in memory.

00:46:04.050 --> 00:46:09.210
And only the data is -- that you're
interested in, that e-mail information.

00:46:09.210 --> 00:46:10.490
Only that is in memory.

00:46:10.489 --> 00:46:13.869
You don't have to worry about the rest of it.

00:46:13.869 --> 00:46:16.190
How much faster is this?

00:46:16.190 --> 00:46:19.679
I mean, you might be thinking, okay,
there's a little bit of overhead involved

00:46:19.679 --> 00:46:23.879
in creating the search and executing the search.

00:46:23.880 --> 00:46:31.240
Certainly, for small data sets it's faster to just grab
the list of everybody and just blindly walk through it.

00:46:31.239 --> 00:46:32.709
And you're right.

00:46:32.710 --> 00:46:36.139
A little proof of concept app, just to
play around, take some measurements.

00:46:36.139 --> 00:46:41.089
And how many of you have at least
10 people in your Address Book?

00:46:41.090 --> 00:46:46.990
Yeah. That's how slow it is to go back to the
disc all the time on every pass through the loop.

00:46:46.989 --> 00:46:52.089
If you have just ten people in your
Address Book, it's faster to search.

00:46:52.090 --> 00:46:54.130
Now what if you have more than 10 people.

00:46:54.130 --> 00:46:55.780
What if you have hundreds of contacts?

00:46:55.780 --> 00:46:58.310
What if you have thousands of contacts?

00:46:58.309 --> 00:47:04.210
Well, turns out that, yeah, searching is definitely faster.

00:47:04.210 --> 00:47:06.720
It's a lot faster.

00:47:06.719 --> 00:47:10.189
Now how much additional code do you have
to write in order to get this performance?

00:47:10.190 --> 00:47:12.139
Well, not much.

00:47:12.139 --> 00:47:13.609
Just two lines.

00:47:13.610 --> 00:47:15.370
Let take a look at them.

00:47:16.699 --> 00:47:20.799
The search element is a description
of what we're interested in.

00:47:20.800 --> 00:47:24.560
Here we're interested in all the
people who have an e-mail address.

00:47:24.559 --> 00:47:25.889
We're not worried about the label.

00:47:25.889 --> 00:47:28.239
We don't care if it's a home address
or if it's a work address.

00:47:28.239 --> 00:47:29.250
We're not worried about that.

00:47:29.250 --> 00:47:30.619
We want them all.

00:47:30.619 --> 00:47:32.279
We don't need to use the key.

00:47:32.280 --> 00:47:34.530
The key is used if you're searching street addresses.

00:47:34.530 --> 00:47:39.440
Let's us know if you're searching the
street value or the city, or the zip.

00:47:39.440 --> 00:47:40.480
Don't need to use that here.

00:47:40.480 --> 00:47:44.619
Just want all the people who have an e-mail address.

00:47:44.619 --> 00:47:48.769
And then instead of asking the Address Book,
you know, for everybody, we ask the Address Book

00:47:48.769 --> 00:47:51.920
for the people who have an e-mail address.

00:47:51.920 --> 00:47:53.460
Again, we get back an array.

00:47:53.460 --> 00:47:58.220
And so our original loop doesn't have to change at all.

00:47:58.219 --> 00:48:03.819
But because you searched, the Address Book framework
has been able to preload the data that you're interested

00:48:03.820 --> 00:48:09.110
in into memory and so you get faster
performance using less memory.

00:48:09.110 --> 00:48:12.950
Searching is something that works
in Leopard, also works in Tiger.

00:48:12.949 --> 00:48:19.519
So if your application targets both versions of
OS, don't worry about special-casing anything.

00:48:19.519 --> 00:48:22.349
You can -- the same code will run on both.

00:48:22.349 --> 00:48:30.589
Let's talk about something that is new in Leopard.

00:48:30.590 --> 00:48:35.890
Brendan mentioned that new in Leopard
we're now using CoreData on the back end.

00:48:38.010 --> 00:48:40.240
Simple database engine.

00:48:40.239 --> 00:48:46.079
One of the fun things about sequel database engines
is we've made these little sand boxes to play in.

00:48:46.079 --> 00:48:51.069
And you can get the data, and you can play around
with it and make all the changes that you want to it.

00:48:51.070 --> 00:48:56.120
And when you're ready, you have control over
when that information is saved and made available

00:48:56.119 --> 00:48:58.529
to anybody else that's using the databases.

00:48:58.530 --> 00:49:02.230
So new in Leopard, and in addition
to the shared Address Book object,

00:49:02.230 --> 00:49:05.889
we're also introducing local Address Book objects.

00:49:05.889 --> 00:49:09.230
They have the same data available to them.

00:49:09.230 --> 00:49:15.050
But whereas the shared Address Book is available to the
entire operating system, any application that's running,

00:49:15.050 --> 00:49:23.240
a local Address Book object is only available to your
process within whatever method you're using it in.

00:49:23.239 --> 00:49:26.599
When you make changes to a record
that's in the shared Address Book,

00:49:26.599 --> 00:49:30.960
those changes are immediately visible
and available to other applications.

00:49:30.960 --> 00:49:38.070
With a local Address Book object, you have control
over when those changes are made available.

00:49:38.070 --> 00:49:43.440
This additional control does come
at a little bit of a price.

00:49:43.440 --> 00:49:48.170
Because there is just one shared Address Book
object, once it's initialized, it's initialized.

00:49:48.170 --> 00:49:50.610
Anybody can get it, anybody can get it for free.

00:49:50.610 --> 00:49:54.390
Any time you want to create a local Address
Book object, it does take a little bit --

00:49:54.389 --> 00:49:58.069
it does take a little bit of time for
us to set it up; get ready for you.

00:49:58.070 --> 00:50:00.240
Not much, but it can ad up.

00:50:00.239 --> 00:50:03.449
So there's one place that I want you to be
aware that we're doing this behind the scenes.

00:50:03.449 --> 00:50:06.009
And that's when you create a record.

00:50:06.010 --> 00:50:11.670
In order to get future pairing between
Leopard and Tiger when you create an --

00:50:11.670 --> 00:50:17.480
when you create a record using the emit method
we will create a local Address Book object

00:50:17.480 --> 00:50:19.639
to create the record in; set it up.

00:50:19.639 --> 00:50:24.629
So new in Leopard we're also going to
introduce an emit with Address Book method.

00:50:24.630 --> 00:50:29.250
And this will let you specify which
Address Book object you want us to use.

00:50:29.250 --> 00:50:35.050
Let me show you how this can work -- how this can help
you fine tune the performance of your application.

00:50:35.050 --> 00:50:37.440
Let's say you want to write an H card parser.

00:50:38.510 --> 00:50:43.020
You've got code that loads the X M data
into memory and parses it on to some sort

00:50:43.019 --> 00:50:47.050
of a temporary data structure,
maybe an array of dictionaries.

00:50:47.050 --> 00:50:52.190
If you do the Cocoa development, a dictionary is
just a hash table, a map associated with an array.

00:50:52.190 --> 00:50:55.139
And once you're satisfied that you
got good information out of it,

00:50:55.139 --> 00:50:59.579
you want to take any temporary data
structure and store it into the Address Book.

00:50:59.579 --> 00:51:04.860
Let's start with a loop something like this.

00:51:04.860 --> 00:51:05.750
Nothing fancy.

00:51:05.750 --> 00:51:08.860
We're just going to go through our temporary data structure.

00:51:08.860 --> 00:51:13.030
We're going to create a local person
-- we're going to create a person.

00:51:13.030 --> 00:51:16.580
We're going to go through and we're
going to populate the person with values

00:51:16.579 --> 00:51:18.489
that we've got on temporary data structure.

00:51:18.489 --> 00:51:21.859
And we're going to add that person to our Address Book.

00:51:21.860 --> 00:51:24.740
Now let's go back to the emit method where you created this.

00:51:24.739 --> 00:51:28.629
Like I said behind the scenes, we're going to do this.

00:51:28.630 --> 00:51:29.630
This is the equivalent code.

00:51:29.630 --> 00:51:31.559
Does the same thing.

00:51:31.559 --> 00:51:37.849
Create a local Address Book object and we use that local
Address Book object while you're initializing the record.

00:51:37.849 --> 00:51:40.079
This let's you make all the changes that you want.

00:51:40.079 --> 00:51:47.119
And then you control when the Address Book -- when
the record is added to the shared Address Book.

00:51:47.119 --> 00:51:51.630
Now each time through of the loop here we're going to set
up and create a local Address Book object for you just

00:51:51.630 --> 00:51:55.740
to throw it away and create a new one
at the beginning of the next loop.

00:51:55.739 --> 00:51:59.289
Well, one optimization you can make to this loop is

00:51:59.289 --> 00:52:04.050
to just manually create a local Address
Book object before you go into the loop.

00:52:04.050 --> 00:52:10.140
And then we can reuse that same local
Address Book each time we go through the loop

00:52:10.139 --> 00:52:13.409
to set the records up and initialize them.

00:52:13.409 --> 00:52:17.519
There's another optimization you can make in this.

00:52:17.519 --> 00:52:25.039
When you add a person to the Address Book, there's
an implicit save that goes on behind the scenes.

00:52:25.039 --> 00:52:28.739
Well, because we have a local Address Book
that we're working with, let's just --

00:52:28.739 --> 00:52:34.009
instead of saving, saving a change to the shared
object every time we go through this loop,

00:52:34.010 --> 00:52:38.340
let's just save that local Address Book,
once we're done going through the loop.

00:52:38.340 --> 00:52:41.940
When you save, the changes that you've
made are going to be made available

00:52:41.940 --> 00:52:44.409
to other applications of that shared Address Book.

00:52:44.409 --> 00:52:48.359
When you save changes there are notifications
that are posted to other applications

00:52:48.360 --> 00:52:50.870
to let them know that there are changes available.

00:52:50.869 --> 00:52:56.069
By just saving it once at the end you save your application
work, you save other applications on the system work.

00:52:56.070 --> 00:52:57.340
Everybody wins.

00:52:57.340 --> 00:53:01.500
Everybody's code runs faster, your code uses less memory.

00:53:05.260 --> 00:53:07.480
Let's go beyond the framework for a second.

00:53:08.570 --> 00:53:12.840
When we created the Address Book
framework we didn't think of everything.

00:53:12.840 --> 00:53:15.150
We didn't try to think of everything.

00:53:15.150 --> 00:53:21.200
What we provided is a quick and easy way to
store and access the types of information that --

00:53:21.199 --> 00:53:26.799
that applications are most interested
in when they're dealing with people.

00:53:26.800 --> 00:53:30.320
But -- let's say your application
needs to start with more information.

00:53:30.320 --> 00:53:33.850
You want to do something that sets
your app apart from the competition.

00:53:33.849 --> 00:53:36.880
Well, how do you store more information?

00:53:36.880 --> 00:53:40.190
There are a couple different options available to
you, and which option you use is going to be depend

00:53:40.190 --> 00:53:43.179
on the specify needs of your application.

00:53:43.179 --> 00:53:49.079
One thing that you can do -- let's say you want to store
information about a person's favorite food or what kind

00:53:49.079 --> 00:53:52.340
of music they like; what their favorite color is.

00:53:53.920 --> 00:53:56.659
The quickest thing to do is use custom properties.

00:53:56.659 --> 00:54:02.670
You can create a custom description of what type of --
a new type of information that's going to be associated

00:54:02.670 --> 00:54:06.900
with -- with a person in the Address Book.

00:54:06.900 --> 00:54:08.660
It works for groups as well.

00:54:08.659 --> 00:54:11.159
This does have its limitations.

00:54:11.159 --> 00:54:16.429
For example, because the sync schema doesn't
know about these custom properties, you know,

00:54:16.429 --> 00:54:19.539
custom properties wouldn't be able to sync around.

00:54:19.539 --> 00:54:28.230
But for just, you know, access on the one computer,
this is going to be fastest and easiest way to do it.

00:54:28.230 --> 00:54:32.780
But let's say that you do want to have data
propagate around, you do want to get it in sync.

00:54:32.780 --> 00:54:36.260
You do want to get it out on other computers; other devices.

00:54:36.260 --> 00:54:38.810
Or let's say you want to store more complex information.

00:54:38.809 --> 00:54:40.969
You want to store more than just information about a person.

00:54:40.969 --> 00:54:46.439
You want to store, you know, an order
history with a complete call log

00:54:46.440 --> 00:54:49.200
of interactions you have had with customers.

00:54:49.199 --> 00:54:53.569
Well, your application may need
to use a generic staple database.

00:54:53.570 --> 00:54:55.830
CoreData is a great framework to use.

00:54:55.829 --> 00:54:59.269
It's pretty easy to get up and running with it.

00:54:59.269 --> 00:55:06.530
And a custom database solution can coexist side by
side with the Address Book framework just wonderfully.

00:55:06.530 --> 00:55:10.390
Every person and every value, like Joe
mentioned, had a unique I.D. on it.

00:55:10.389 --> 00:55:17.420
And so as your database needs to store references
back to particular people and items of data

00:55:17.420 --> 00:55:20.849
in the Address Book database, you
can use those as a reference.

00:55:20.849 --> 00:55:21.420
They persist.

00:55:21.420 --> 00:55:22.019
They stay around.

00:55:22.019 --> 00:55:28.190
Or you want to go really complex.

00:55:28.190 --> 00:55:32.460
Or maybe you've already got an existing database
solution that you use with your application.

00:55:32.460 --> 00:55:35.420
You've had it for years, you've
invested a lot of engineering time

00:55:35.420 --> 00:55:37.710
to fine tuning, you've got the performance you want.

00:55:37.710 --> 00:55:38.900
It's tried, it's trusted.

00:55:38.900 --> 00:55:42.300
You're a little bit hesitant about, you
know, getting in and tearing things apart.

00:55:42.300 --> 00:55:46.490
Well, going in with sync services is another option.

00:55:46.489 --> 00:55:52.119
There's a public sync schema for contacts that
will let you get the information from your database

00:55:52.119 --> 00:55:58.159
into the Apple Address Book ecosystem so
that users can pick up on these events,

00:55:58.159 --> 00:56:01.019
OS X technologies that Brendan was talking about.

00:56:01.019 --> 00:56:06.780
Also let's your application pick up information that
users have already entered in another application.

00:56:07.849 --> 00:56:10.449
That's another option that's available to you.

00:56:10.449 --> 00:56:18.119
But for most of you, the fastest, easiest way to get your
application up and running is sharing address information

00:56:18.119 --> 00:56:23.389
with other applications on the system is going
to be through using the Address Book framework.

00:56:25.059 --> 00:56:29.799
You get advantage to these new OS X
technologies as they become variable.

00:56:29.800 --> 00:56:37.810
When Tiger came along, anybody who was already using
the Address Book framework they got Spotlight for free.

00:56:37.809 --> 00:56:42.110
Anybody who is using the Address Book framework
now is going to get Time Machine for free.

00:56:42.110 --> 00:56:43.650
Syncing to other devices.

00:56:43.650 --> 00:56:47.670
As other devices come along, syncing dot Mac services.

00:56:47.670 --> 00:56:49.650
Syncing to dot Mac.

00:56:49.650 --> 00:56:53.530
All for free.

00:56:53.530 --> 00:56:58.740
People Picker -- gives you familiar user
interface so that your customers can get

00:56:58.739 --> 00:57:00.609
up to speed faster with your application.

00:57:00.610 --> 00:57:01.490
They already know it.

00:57:01.489 --> 00:57:03.369
They can get going with it.

00:57:03.369 --> 00:57:04.940
And searching.

00:57:05.949 --> 00:57:12.699
Searching the Address Book whenever possible gives us
clues to the kinds of data that you're interested in,

00:57:12.699 --> 00:57:18.179
so that we can have the data ready for you when you
need it, still using as little memory as possible.

00:57:18.179 --> 00:57:22.119
So where do we go from here?

00:57:23.409 --> 00:57:29.429
Well, 5 o'clock any afternoon we're going to be down
in Mac OS X Lab A. And we would love for you to come

00:57:29.429 --> 00:57:31.559
by and spend some one on one time with us.

00:57:31.559 --> 00:57:36.119
You know, talk with us, any questions,
concerns that you have, stop on by.

00:57:36.119 --> 00:57:38.109
There's also our developer Web site.

00:57:38.110 --> 00:57:39.640
Developer dot Apple dot com.

00:57:39.639 --> 00:57:45.210
It's got some great code examples and mailing list
archives for people who have already gone through

00:57:45.210 --> 00:57:49.470
and solved maybe the same problems that you're facing now.

00:57:49.469 --> 00:57:51.949
It's always available, 24-7.

00:57:51.949 --> 00:57:55.969
There's also Matt Drance, our
sharing technologies evangelist here at Apple.

00:57:55.969 --> 00:57:59.869
He doesn't keep quite the same hours that
the Web site does, but he is available now.
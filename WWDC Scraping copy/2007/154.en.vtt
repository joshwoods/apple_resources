WEBVTT

00:00:15.109 --> 00:00:16.030
>> Hi, I'm Todd.

00:00:16.030 --> 00:00:21.510
Welcome to Leveraging Soap Technologies on OS X.

00:00:21.510 --> 00:00:27.590
( Period of silence )

00:00:27.589 --> 00:00:33.640
Over the past couple of years, we've seen a growing
collection of popular web applications providing you,

00:00:33.640 --> 00:00:38.829
the application developer, a lot of their
functionality through what is called web services.

00:00:38.829 --> 00:00:45.420
Very popular web applications such as Google Maps,
YouTube, Amazon web services, Face Book etcetera.

00:00:45.420 --> 00:00:53.560
And these web services are very often provided
through web service architectural styles two

00:00:53.560 --> 00:00:56.370
that are particularly popular, Soap and Rest.

00:00:56.369 --> 00:01:03.169
So today we're going to talk about the tools available to you
on OS X to access remote Rest and Soap based web services.

00:01:03.170 --> 00:01:11.379
So looking at the agenda, first we're going to focus
on Soap and the tools available to you for Soap.

00:01:11.379 --> 00:01:15.109
So first we're going to survey the tools
available for Soap programming on OS X.

00:01:15.109 --> 00:01:21.579
And then we'll go in depth with Apple's native
web services tool kit, web services core.

00:01:21.579 --> 00:01:26.959
When we look at web services core, first we'll focus
on code generation from WSDL files and the features

00:01:26.959 --> 00:01:28.939
and functionalities web services core offers there.

00:01:28.939 --> 00:01:33.730
And then we'll look at using the web services
core API directly in your client application.

00:01:33.730 --> 00:01:40.210
Second style of web services we'll look at accessing
from your applications are Rest phone web services

00:01:40.209 --> 00:01:47.559
and we'll take a close look at using NSXML, Apple's native
XML programming tool kit for accessing Rest services.

00:01:47.560 --> 00:01:56.980
So just briefly, let's catch up and make sure we know
what we're talking about when we say what is Soap.

00:01:56.980 --> 00:02:04.540
Soap is a W3C specification and I found this definition of
Soap on the W3C website in the Soap 1 point 2 specification

00:02:04.540 --> 00:02:06.780
and I find it kind of long and
involved and not very helpful.

00:02:06.780 --> 00:02:11.419
So actually I kinda prefer the
definition I found on Wikipedia for Soap.

00:02:11.419 --> 00:02:17.819
And Wikipedia says Soap is a protocol for exchanging XML
based messages over computer networks normally using HTTP.

00:02:17.819 --> 00:02:20.459
I think that's a pretty good definition.

00:02:20.460 --> 00:02:26.629
Soap originally invented by Microsoft and others as the
successor to earlier RPC technologies like XML Air PC.

00:02:26.629 --> 00:02:32.139
It's another approach to the age old
problem of inter process communication,

00:02:32.139 --> 00:02:36.159
the idea being that if one program written in one
programming language and another program written

00:02:36.159 --> 00:02:38.359
in another programming language need to communicate.

00:02:38.360 --> 00:02:41.950
One possible way to do this is to
pass XML messages back and forth.

00:02:41.949 --> 00:02:45.409
The idea being that most programming
environments have solid XML tools,

00:02:45.409 --> 00:02:48.569
so that's one way to communicate between the two programs.

00:02:48.569 --> 00:02:52.120
This probably sounds a lot like XML RPC and it is.

00:02:52.120 --> 00:02:58.069
Soap is very similar to XML RPC but the innovation of Soap
is meant to add is object orientation where the primaries

00:02:58.069 --> 00:03:02.739
that you pass and return from the remote
service could be native object types rather

00:03:02.740 --> 00:03:09.500
than just scaler values which we usually use in XML RPC.

00:03:09.500 --> 00:03:15.900
Another technology that's often associated with Soap
based web services is a technology called WSDL, W S D L,

00:03:15.900 --> 00:03:20.039
stands for web services description language.

00:03:20.039 --> 00:03:26.729
This is an XML vocabulary used to describe
the interface and features of web services.

00:03:26.729 --> 00:03:30.609
And in practice it's almost always used
to describe soap based web services.

00:03:30.610 --> 00:03:35.710
So this kind of a XML format that's meant to be
machine readable so that automated processes can come

00:03:35.710 --> 00:03:39.129
and discover features of your Soap based web service.

00:03:39.129 --> 00:03:41.269
So again, it's a service interface description language.

00:03:41.270 --> 00:03:49.360
So Soap is kind of the centerpiece of a large and
ever growing collection of web service specifications

00:03:49.360 --> 00:03:54.530
from the W3C and these all kind of start
with the abbreviation WS for web services.

00:03:54.530 --> 00:03:57.520
Kind of collectively referred to as WS star.

00:03:57.520 --> 00:04:04.439
There's been some negative press recently from some
developer camps targeted towards the WS star specifications,

00:04:04.439 --> 00:04:07.400
leading them to maybe even refer to it as WS death star.

00:04:07.400 --> 00:04:13.300
The implication being that these specifications
might be a little bit overly complex or convoluted.

00:04:13.300 --> 00:04:18.780
But the point remains that certain
Soap services do exist out there

00:04:18.779 --> 00:04:20.509
and there are times when you need to interact with them.

00:04:20.509 --> 00:04:24.039
So the good news is that on OS X there
are tools available for you to do that.

00:04:24.040 --> 00:04:28.360
So today we're going to look at those tools.

00:04:28.360 --> 00:04:32.430
I think it bears mentioning, Soap was kind
of originally invented as an RPC mechanism.

00:04:32.430 --> 00:04:38.900
More recently there's been kind of an attempt to generalize
Soap to a more general XML message passing system.

00:04:38.899 --> 00:04:43.569
But I think you'll find in practice, Soap is
probably most often used as an RPC mechanism.

00:04:43.569 --> 00:04:47.159
And the tools we'll look at today
generally model it as an RPC mechanism.

00:04:47.160 --> 00:04:50.310
So I'm going to just kinda refer to Soap
as an RPC messaging mechanism today.

00:04:50.310 --> 00:04:56.670
So let's look at a little diagram of kind of a
common Soap interaction just to get us up to speed.

00:04:56.670 --> 00:04:59.259
We've got a client application and a server application.

00:04:59.259 --> 00:05:03.399
And the client's going to send what is
logically a method call to the server.

00:05:03.399 --> 00:05:09.469
And this is represented by an HTTP post request
that contains and XML document as its body.

00:05:09.470 --> 00:05:12.770
This XML document is specifically a Soap XML envelop.

00:05:12.769 --> 00:05:20.089
And the return value from the server to the client in HTTP
response again containing an XML document as its body.

00:05:20.089 --> 00:05:24.289
Just a quick look at a standard XML
or a standard Soap HTTP request.

00:05:24.290 --> 00:05:28.150
You've got all the normal aspect of
an HTTP request that you'd expect.

00:05:28.149 --> 00:05:32.739
Headers up top and then in the body
again, a Soap envelopee XML document,

00:05:32.740 --> 00:05:38.910
outer most element being the envelop element containing
the normal name space declarations you'd expect.

00:05:38.910 --> 00:05:44.000
Also an optional header, header element which can
contain XML content for the server to use at it chooses

00:05:44.000 --> 00:05:48.250
and then the required body element which
contains the actual method call we're calling,

00:05:48.250 --> 00:05:50.680
in this case a method called do spelling suggestion.

00:05:50.680 --> 00:05:55.650
And any parameters or arguments we're sending to
the server, in this case a single strand value.

00:05:55.649 --> 00:05:59.639
Keep in mind that conceptually what we're talking
about is something similar to this pseudo code here.

00:05:59.639 --> 00:06:04.449
You've got a service, you're calling a
method and passing a single named parameter.

00:06:04.449 --> 00:06:15.329
And so, conceptually one of the kind of rubs on Soap has
been in the past that this is the same representation

00:06:15.329 --> 00:06:20.300
of what we just looked at, the pseudo code and it's
kind of robust and its kind of a large XML document

00:06:20.300 --> 00:06:23.590
that tends to be a little bit, well robust.

00:06:23.589 --> 00:06:27.060
So that's one of the kind of the rubs on Soap.

00:06:27.060 --> 00:06:30.360
And if you look at, just a quick
look at the Soap HTTP response,

00:06:30.360 --> 00:06:33.819
again the normal aspects of an HTTP response you'd expect.

00:06:33.819 --> 00:06:40.180
The HTTP prolong and the body is an XML document
with the outer most element is an envelope element.

00:06:40.180 --> 00:06:44.030
And there's a required body element
that, that contains the return value.

00:06:44.029 --> 00:06:45.979
In this case a strain that's correctly spelled.

00:06:45.980 --> 00:06:52.970
So that was just a quick overview of
Soap to make sure we're all up to speed.

00:06:53.990 --> 00:06:58.030
Let's go ahead and take a look at
the tools available on Mac OS X

00:06:58.029 --> 00:07:00.859
for doing Soap programming from your client applications.

00:07:00.860 --> 00:07:09.720
So we're going to take a look at two broad
types of tools available on OS X.

00:07:09.720 --> 00:07:13.500
Third party tools and the built
in tools available from Apple.

00:07:15.060 --> 00:07:19.689
So obviously Java is a cross platform
environment that runs extremely well on OS X.

00:07:19.689 --> 00:07:26.740
Java has a large collection of very mature tools for web
services programming and Soap programming in particular.

00:07:26.740 --> 00:07:32.790
So the story here is that you have a lot of options
in the Java world for web services programming tools.

00:07:32.790 --> 00:07:38.500
As far as integrating these tools into your Cocoa or Carbon
client application, you may actually run into some problems

00:07:38.500 --> 00:07:44.199
because Java is in the Java programming language, your
Cocoa application is probably written in Objective-C,

00:07:44.199 --> 00:07:45.990
crossing this language bridge could be difficult.

00:07:45.990 --> 00:07:49.610
So even though the tools in Java are very
mature, you may have a hard time integrating this

00:07:49.610 --> 00:07:52.879
into your Cocoa, Cocoa or Carbon client application.

00:07:52.879 --> 00:08:02.079
Mono is another tool set that contains a lot of
Soap services or web service programming tools.

00:08:02.079 --> 00:08:07.959
Mono, you may be familiar, is an open source
implementation of Microsoft dot net platform.

00:08:07.959 --> 00:08:12.370
Being an implementation of the dot net platform,
it does contain a lot of web services tools,

00:08:12.370 --> 00:08:18.670
but it kinda runs into the same problem from our
context of OS X programming that we saw with Java.

00:08:18.670 --> 00:08:23.280
It's going to be difficult to integrate with your Cocoa
application, the native language of Mono being C Sharp,

00:08:23.279 --> 00:08:25.609
bridging from C Sharp to Objective-C can be difficult.

00:08:25.610 --> 00:08:30.129
There actually is an open source tool available that
looks really promising called Dumb Barton Bridge,

00:08:30.129 --> 00:08:36.570
which allows you to bridge Mono and C Sharp to Cocoa
and Objective-C. I recommend you take a look at that.

00:08:36.570 --> 00:08:39.240
But again, it's probably not going to
be the easiest choice for you

00:08:39.240 --> 00:08:43.159
if you want to access remote services
from your client application.

00:08:43.159 --> 00:08:51.679
Soap client is a third party free developer tool that we're
going to take a look at in a minute, during one of the demos.

00:08:51.679 --> 00:08:56.129
This is a pretty helpful tool for
debugging and testing your Soap services.

00:08:56.129 --> 00:09:01.509
It kind of creates basically a dynamic
user interface for remote Soap services.

00:09:01.509 --> 00:09:04.169
Given a WSDL file.

00:09:04.169 --> 00:09:07.860
And it can be really helpful for testing
and debugging, but that's about it.

00:09:07.860 --> 00:09:11.240
It's not something that, that you're going to
be able to ship in the shipping application.

00:09:11.240 --> 00:09:16.529
Its not going to help you in your production code.

00:09:16.529 --> 00:09:21.860
So as far as built in tools from Apple
for Soap or web services programming,

00:09:21.860 --> 00:09:27.000
Apple script actually has very high level language
integration for Soap and XML RPC programming.

00:09:27.000 --> 00:09:34.309
This can be an extremely easy and quick way to do fast and
easy scripting of remote Soap services or XML RPC services.

00:09:34.309 --> 00:09:36.489
It's great for testing and debugging.

00:09:36.490 --> 00:09:39.570
But again, it's a little short on features
if you need to get under the covers of your,

00:09:39.570 --> 00:09:41.940
something a little bit unusual with the remote service.

00:09:41.940 --> 00:09:45.000
It may not have all the features that you need.

00:09:45.000 --> 00:09:53.220
Automator is a, another tool on the
platform that has some Soap service

00:09:53.220 --> 00:09:57.009
or Soap programming tools that you might take a look at.

00:09:57.009 --> 00:10:02.669
Automator is a really great application they released in OS
X Tiger, that's kind of a graphical programming environment

00:10:02.669 --> 00:10:07.449
where you can drag discrete actions into a
scripting workflow and then execute the workflow.

00:10:07.450 --> 00:10:12.490
And automater actually includes an
action for accessing remote Soap service.

00:10:12.490 --> 00:10:16.230
It's kind of similar to the user
interface with saw with Soap client.

00:10:16.230 --> 00:10:23.639
And it can be again a really great way to test or debug
your remote Soap service or accessing a remote service.

00:10:23.639 --> 00:10:25.759
So it's great for fast and easy scripting.

00:10:25.759 --> 00:10:30.220
But it's kinda very similar to Apple script in that it's a
little short on features if you need to do something unusual

00:10:30.220 --> 00:10:35.720
or you're having problems with the remote service, you
may not be able to get the job done with just this tool.

00:10:35.720 --> 00:10:38.740
And then finally we've got web services core.

00:10:42.250 --> 00:10:43.450
So what is web services core?

00:10:43.450 --> 00:10:49.050
WebServices Core is Apple's native
XML RPC and Soap tool kit.

00:10:49.049 --> 00:10:51.269
It's a C based tool kit.

00:10:51.269 --> 00:10:55.079
And it's based on a couple of other
tool kits available on the platform.

00:10:55.080 --> 00:11:02.970
So at the lowest level we've got core foundation, which is
Apple's general purpose programming environment based in C.

00:11:02.970 --> 00:11:08.050
And so its got all the basic data types that you expect from
a modern programming environment like strings and arrays

00:11:08.049 --> 00:11:13.729
and dictionaries and also some higher level
objects and classes like dates or URLs.

00:11:13.730 --> 00:11:19.389
And on top of core foundation is another
C based framework called CF Network.

00:11:19.389 --> 00:11:22.039
And the CF here stands for core foundation of course.

00:11:22.039 --> 00:11:28.139
And CF Network adds and HTTP 1 point 1
implementation on top of core foundation.

00:11:28.139 --> 00:11:30.449
On top of CF Network is web services core.

00:11:30.450 --> 00:11:35.470
And again, this is Apple's native C based tool
kit for XML RPC and Soap programming and it adds

00:11:35.470 --> 00:11:37.550
to those high level features on top of CF Network.

00:11:37.549 --> 00:11:44.829
So what can web services core do?

00:11:44.830 --> 00:11:51.350
WebServices Core is actually a great option for
you to access remote XML RPC or Soap services

00:11:51.350 --> 00:11:54.009
from your Carbon or Cocoa client application for OS X.

00:11:54.009 --> 00:12:01.210
A couple of features that we'll look at today, you can
do code generation from WSDL files for remote services.

00:12:01.210 --> 00:12:04.139
And also of course it has a lower
level API that you can use directly

00:12:04.139 --> 00:12:07.449
in your client application to access the remote services.

00:12:07.450 --> 00:12:12.620
So first let's take a look at code
generation using web services core.

00:12:12.620 --> 00:12:16.980
WebServices Core includes a tool called WS Make Stubs.

00:12:16.980 --> 00:12:19.509
WS Make Stubs is the easiest way for you to interact

00:12:19.509 --> 00:12:23.759
with a remote known Soap based web
services that's describe by a WSDL file.

00:12:23.759 --> 00:12:30.080
So if you have a remote Soap service and it has a WSDL file
description, WS Make Stubs can help you auto generate code.

00:12:30.080 --> 00:12:32.740
So again, it's the easiest way
to interact with these services

00:12:32.740 --> 00:12:34.919
when you know they have WSDL and you know what they are.

00:12:34.919 --> 00:12:36.129
It's a command line interface.

00:12:36.129 --> 00:12:40.169
It's an executable, you access from the command line.

00:12:40.169 --> 00:12:45.479
And using WS Make Stubs actually produces
stub interface code from the WSDL.

00:12:45.480 --> 00:12:51.590
WS Make Stubs can generate code in one of three
languages, C++, Objective-C or Apple script.

00:12:51.590 --> 00:12:54.800
And the code generated by web services
core, actually, I'm sorry.

00:12:54.799 --> 00:13:02.009
By WS Make Stubs actually uses the W,
web services core API under the hood.

00:13:02.009 --> 00:13:09.509
So WS Make Stubs again, a command line executable that
located at slash developer slash tools slash WS Make Stubs.

00:13:09.509 --> 00:13:16.419
So we're going to do a quick demo of using WS
Make Stubs to interact with the remote service.

00:13:16.419 --> 00:13:22.639
I just went online and looked for a free, simple Soap
based service that was also described by a WSDL file

00:13:22.639 --> 00:13:24.740
and I found something called Random Quote.

00:13:24.740 --> 00:13:29.320
So again this is a real live Soap
service that's available online.

00:13:29.320 --> 00:13:33.320
And it actually returns, oops.

00:13:33.320 --> 00:13:36.270
Not just yet, thanks.

00:13:36.269 --> 00:13:41.250
So the service is called Random Quote and it's got a couple
of methods and we're going to call one of these methods.

00:13:41.250 --> 00:13:46.009
One method is called get quote and it accepts a
single parameter, Boolean parameter called inHTML.

00:13:46.009 --> 00:13:46.970
We're going to call that method.

00:13:46.970 --> 00:13:52.060
And this returns actually a quotation, not a
stock quote, but a quotation from an individual.

00:13:52.059 --> 00:13:55.649
And it returns a dictionary with
a couple of keys and values,

00:13:55.649 --> 00:13:59.529
author and the author name quote and the actual quote value.

00:13:59.529 --> 00:14:03.509
So demo slides please, or demo machine please.

00:14:03.509 --> 00:14:08.179
( Period of silence )

00:14:08.179 --> 00:14:13.569
So before we actually call the random quote
web service, I mentioned Soap client dot app,

00:14:13.570 --> 00:14:16.379
which is a desktop debugging tool on OS X.

00:14:16.379 --> 00:14:21.049
Let's just go ahead and use that tool, just to kind of
interact with the service before we actually call it.

00:14:21.049 --> 00:14:24.519
So here I'm launching Soap client dot app.

00:14:24.519 --> 00:14:32.889
And again, this is just a free
debugging tool available on the platform.

00:14:32.889 --> 00:14:36.799
And with the remote quote service, I
said it was described by a WSDL file.

00:14:36.799 --> 00:14:48.049
Well I went ahead and found the WSDL file out
on the web and downloaded it to my desktop here.

00:14:48.049 --> 00:14:52.339
I could just as easily point this to the actual WSDL
file online, but I went ahead and downloaded it.

00:14:52.340 --> 00:14:57.509
So I'm going to click the browse button and
I'm going to open the WSDL file in Soap client.

00:14:57.509 --> 00:15:13.529
( Period of silence )

00:15:13.529 --> 00:15:16.509
Try that again.

00:15:16.509 --> 00:15:28.659
( Period of silence )

00:15:28.659 --> 00:15:31.639
Okay I'm going to drag the WSDL file direct to the Soap client.

00:15:33.820 --> 00:15:36.850
So once we've got the WSDL file loaded into
Soap client, I can click the parse button

00:15:36.850 --> 00:15:42.529
and it's going to dynamically create a user interface
for the web service described by the WSDL file.

00:15:42.529 --> 00:15:49.009
So as you can see here, I've got a user interface
created dynamically for the web service and I choose one

00:15:49.009 --> 00:15:52.659
of the two methods, again there's methods
and we're going to choose the get quote method.

00:15:52.659 --> 00:15:55.860
And notice that it conveniently
filled out some of the values for us.

00:15:55.860 --> 00:16:00.550
This way we don't have to fill out all the details of
the Soap request, which is kind of a handy feature.

00:16:00.549 --> 00:16:04.929
And again there was a single parameter to that method
and it's a user interface for entering the value there.

00:16:04.929 --> 00:16:08.129
And you get a little type hint here
that it's actually a Boolean parameter.

00:16:08.129 --> 00:16:12.330
So I'm going to go ahead and say false, we
don't want the return value in HTML format.

00:16:12.330 --> 00:16:13.960
We just want a dictionary.

00:16:13.960 --> 00:16:18.000
So when I click the execute button, down
on the button half of the user interface,

00:16:18.000 --> 00:16:22.950
you can actually see the raw XML messages sent to the
server and actually back from the server to the client.

00:16:22.950 --> 00:16:24.780
So here we've got the raw XML that we sent.

00:16:24.779 --> 00:16:27.419
And this is again the Soap envelopeee.

00:16:27.419 --> 00:16:29.409
We can see it as a pretty style.

00:16:29.409 --> 00:16:33.049
We can see the raw response as text,
and we can see the pretty response.

00:16:33.049 --> 00:16:35.889
So let's just take a quick look at the pretty response.

00:16:35.889 --> 00:16:37.730
I mentioned that the response is a dictionary.

00:16:37.730 --> 00:16:42.950
And here's the raw XML representation of that
dictionary with the key of author, with Will Rogers

00:16:42.950 --> 00:16:46.170
and the quote is the best doctor
in the world is the veterinarian.

00:16:46.169 --> 00:16:49.919
He can't ask his patients what's
the matter, he's just got to know.

00:16:49.919 --> 00:16:51.839
So there you have it.

00:16:51.840 --> 00:16:56.910
Anyway that's how you can use Soap client
to kind of debug your remote Soap service.

00:16:58.080 --> 00:17:04.079
So I do want to talk about using WS Make Stubs now to actually
auto generate code for this random quote web service.

00:17:04.079 --> 00:17:09.629
So what I'm going to do is first take a look
at the help information for WS Make Stubs.

00:17:09.630 --> 00:17:11.580
And I've got a little text clipping here.

00:17:11.579 --> 00:17:16.529
So again, WS Make Stubs is located at slash
developer slash tools slash WS Make Stubs.

00:17:16.529 --> 00:17:18.019
I'm going to pass the help argument.

00:17:18.019 --> 00:17:20.799
And that's how you can get the
documentation for WS Make Stubs.

00:17:20.799 --> 00:17:25.529
And there's a few arguments, probably the
most interesting is the Dash X argument.

00:17:25.529 --> 00:17:28.940
And that's how you can specify which of the
languages you're going to generate code in.

00:17:28.940 --> 00:17:31.950
C++, Objective-C or Apple Script.

00:17:31.950 --> 00:17:36.420
And there's a couple other arguments for specifying where
you want the output to go or where you want the WSDL

00:17:36.420 --> 00:17:39.529
to be fetched from, either a local file or remote URL.

00:17:39.529 --> 00:17:43.029
I'm just going to use a local file
because I've got it here on my desktop.

00:17:44.970 --> 00:17:48.559
So I've got another text clipping here
for the actual command WS Make Stubs,

00:17:48.559 --> 00:17:54.379
I'm going to produce Objective-C Stub files
for the WSDL file for my remote service.

00:17:54.380 --> 00:18:04.510
So I executed WS Make Stubs and it actually produced a
pair of header and implementation files here on my desktop.

00:18:04.509 --> 00:18:09.160
So these are files that you can actually link into
an Xcode project to interact with a remote service.

00:18:09.160 --> 00:18:11.210
So I'm actually on Tiger here not on Leopard.

00:18:11.210 --> 00:18:15.059
All of the tools that I'm talking about today
are available on Tiger and available to you now.

00:18:15.059 --> 00:18:16.919
So just approve that I'm going to do this on Tiger.

00:18:16.920 --> 00:18:23.390
I'm going to go to Xcode and incorporate this
into, incorporate this into an Xcode project.

00:18:23.390 --> 00:18:26.840
So I'm going to do file new.

00:18:26.839 --> 00:18:29.829
And choose Cocoa application.

00:18:29.829 --> 00:18:34.549
Call this random quote app.

00:18:34.549 --> 00:18:42.799
I'm going to drag the four files that were
generated by WS Make Stubs into my project.

00:18:42.799 --> 00:18:46.669
Its going to ask me to confirm that I want to
add them to the project and I'll do that.

00:18:48.039 --> 00:18:51.430
Just to show you how easy it is to use
the code generated by WS Make Stubs,

00:18:51.430 --> 00:18:53.820
I'm going to actually go ahead and build this application.

00:18:53.819 --> 00:18:57.950
So I'm going to go to Interface Builder,
very quickly drag out a text find

00:18:57.950 --> 00:19:02.500
which will display the result of calling the web service.

00:19:02.500 --> 00:19:05.190
And a button to execute the web service.

00:19:05.190 --> 00:19:08.880
I hope you'll do something a little
more inventive than what I'm doing here.

00:19:08.880 --> 00:19:13.970
But this will get the job done.

00:19:13.970 --> 00:19:18.480
Now I'm going to create a controller
class for my application.

00:19:18.480 --> 00:19:23.700
So I'm going to choose the base class for my
controller class which is going to be NS Object.

00:19:23.700 --> 00:19:26.890
I'm going to go up to classes and subclass NS Object.

00:19:26.890 --> 00:19:29.150
Create a class called my controller.

00:19:32.039 --> 00:19:36.829
In my controller class, I'm going to
add outlet to my controller.

00:19:36.829 --> 00:19:37.779
Call it text view.

00:19:37.779 --> 00:19:43.119
And this'll be a pointer to the NS Text view
that I just dragged into the user interface.

00:19:43.119 --> 00:19:45.829
And I'm going to add a single action.

00:19:45.829 --> 00:19:49.059
I'm going to call the fetch quote.

00:19:49.059 --> 00:19:51.500
And this will interact with the web service.

00:19:51.500 --> 00:19:53.000
So now I'm going to link.

00:19:53.000 --> 00:20:03.769
Oops. So I've got this new class, my controller,
where I've added an outlet and I've added an action.

00:20:03.769 --> 00:20:07.529
I'm going to go ahead and instantiate
my controller into the nib file.

00:20:08.930 --> 00:20:17.220
And now I'm going to link the outlet
text field and I'm going to link the button

00:20:17.220 --> 00:20:23.630
to the action of my controller fetch quote.

00:20:23.630 --> 00:20:29.540
And finally I'm going to select the my controller class.

00:20:29.539 --> 00:20:37.619
And we're going to create the files for my controller
and send them over to the Xcode project.

00:20:37.619 --> 00:20:43.199
Its going to make me confirm that I want to actually send these
files to this specific Xcode project, I'm going to confirm.

00:20:45.059 --> 00:20:51.329
So when I come back to my Xcode project, I see the
code for the class I just created, my controller.

00:20:51.329 --> 00:20:55.339
And I'm going to go to the implementation
file for the controller class.

00:20:55.339 --> 00:20:59.909
I'm going to go ahead and import one of the
headers the WS Make Stubs generated for me.

00:20:59.910 --> 00:21:10.110
And that file is called WS Stub dot H. If I go ahead
and look in that header file, and again this is the file

00:21:10.109 --> 00:21:15.509
that was generated for me by WS Make Stubs, it creates
a few ways that I can interact with this web service.

00:21:15.509 --> 00:21:17.420
A few of them synchronous, a few of them asynchronous.

00:21:17.420 --> 00:21:21.279
I'm going to choose the simplest which is just a
synchronous way to interact with the web service.

00:21:21.279 --> 00:21:24.710
And you can see it created a class for me
called random quote service and it has a couple

00:21:24.710 --> 00:21:26.970
of methods corresponding to the
methods available by the service.

00:21:26.970 --> 00:21:32.339
So I'm going to go ahead and use that in my action method.

00:21:32.339 --> 00:21:35.750
And if you're familiar with the other programming
environments, this is kind of like an event handler

00:21:35.750 --> 00:21:38.660
for when someone clicks on the button in the user interface.

00:21:38.660 --> 00:21:50.610
So I'm going to say ID result equals
random quote service, oops, get quote.

00:21:50.609 --> 00:21:56.409
Wanna pass a single argument of no because I don't want
an HTML response, I just want the dictionary response.

00:21:56.410 --> 00:22:09.850
And then I'm going to set my text view, the
string of my text view, to a string description

00:22:09.849 --> 00:22:13.579
of the result of calling the remote web service.

00:22:13.579 --> 00:22:16.299
So now I'm going to build my.

00:22:16.299 --> 00:22:23.379
And again what I'm actually doing
here is probably not a best practice.

00:22:23.380 --> 00:22:26.970
I'm actually calling a synchronous remote
web service and the main GUI thread.

00:22:26.970 --> 00:22:30.110
So I wouldn't recommend doing this
in your actual application.

00:22:30.109 --> 00:22:35.149
but just to kind of demonstrate how easy it is to interact
with the code that's generated by web serve, WS Make Stubs,

00:22:35.150 --> 00:22:37.240
I'm going to show how quick and easy it can be

00:22:37.240 --> 00:22:39.880
So hopefully you'll do something more
interesting with the user interface

00:22:39.880 --> 00:22:42.800
and not be calling methods synchronously
on the main GUI thread.

00:22:42.799 --> 00:22:48.159
But again, now I've clicked the button and
here's the response from the web service.

00:22:48.160 --> 00:22:50.620
And I've got my quotation.

00:22:50.619 --> 00:22:53.979
This one is from Rudyard Kipling?

00:22:53.980 --> 00:22:57.140
A woman's guess is much more accurate
than a man's certainty.

00:22:57.140 --> 00:23:03.259
Anyway, that's, that's how you can auto generate
code and use WS Make Stubs to save you a lot of time

00:23:03.259 --> 00:23:08.309
in accessing remote Soap based
services from your client application.

00:23:08.309 --> 00:23:10.129
Back to slides please.

00:23:11.509 --> 00:23:19.269
( Period of silence )

00:23:19.269 --> 00:23:22.359
So we looked at auto generating of code using WS Make Stubs.

00:23:22.359 --> 00:23:25.979
Now let's just take a quick look at the
web services core API in case you needed

00:23:25.980 --> 00:23:30.759
to do something a little more specific or a
little more dynamic from your client application.

00:23:30.759 --> 00:23:35.480
Remember that conceptually what we're going to be talking
about here is basically calling method of a remote service.

00:23:35.480 --> 00:23:40.220
In this case we're going to call a method call do spelling
suggestion, passing a single parameter with a key,

00:23:40.220 --> 00:23:43.309
a phrase and a value of the string that's misspelled.

00:23:44.440 --> 00:23:53.580
Let's go ahead and just look at a diagram here of what the
interaction is going to be like with the web services core.

00:23:53.579 --> 00:23:56.309
We're going to first create an object
that represents our Soap request.

00:23:56.309 --> 00:24:01.169
And this is actually a very central data type to
web services core called WS Method Invocation Ref.

00:24:01.170 --> 00:24:04.340
And this will represent either a Soap or an XML RPC request.

00:24:04.339 --> 00:24:06.299
In this case, a Soap request.

00:24:06.299 --> 00:24:10.480
We're going to set the parameters of the request
and set a few extra properties on the request.

00:24:10.480 --> 00:24:12.819
Then we're going to send the Soap request to the remote server.

00:24:12.819 --> 00:24:16.589
The server is going to return a Soap response.

00:24:16.589 --> 00:24:23.899
We'll check for HTTP authorization challenges and if we
have any of those we'll add credentials and rise and repeat.

00:24:23.900 --> 00:24:25.710
Finally we want to check for a Soap fault.

00:24:25.710 --> 00:24:31.039
And then we can use the, the information in our
client application that the Soap service returned.

00:24:31.039 --> 00:24:33.779
So let's just walk through that quickly.

00:24:33.779 --> 00:24:37.240
Again, the first step is to create the object
that's going to represent your Soap request,

00:24:37.240 --> 00:24:40.900
WS method invocation ref is the name of that data type.

00:24:40.900 --> 00:24:45.580
And you can create one of those items using
the function WS Method invocation create.

00:24:45.579 --> 00:24:52.189
This function takes three argument,
the end point URI of the service, oops.

00:24:52.190 --> 00:24:55.259
The actual string method name of the method you are calling.

00:24:55.259 --> 00:24:56.660
And the third parameter is the protocol.

00:24:56.660 --> 00:24:58.779
This is where you specify or XML RPC.

00:24:58.779 --> 00:25:02.369
In our case we'd be specifying Soap.

00:25:02.369 --> 00:25:05.549
Then you want to actually set the
parameters on the Soap request

00:25:05.549 --> 00:25:08.720
and these are the arguments to the method you're calling.

00:25:08.720 --> 00:25:15.579
The parameters are represented by a dictionary because in
Soap we have a name value pair representation of arguments.

00:25:15.579 --> 00:25:20.679
So we might set these with something like
the code below where we have a, a key,

00:25:20.680 --> 00:25:23.230
a phrase and value of a string that's misspelled.

00:25:23.230 --> 00:25:24.410
And again that's a dictionary.

00:25:24.410 --> 00:25:30.290
And then you set these parameters on the request
using WS method invocation set parameters.

00:25:30.289 --> 00:25:33.309
So the first argument is the Soap request.

00:25:33.309 --> 00:25:35.599
And then the dictionary of parameters.

00:25:35.599 --> 00:25:40.359
And then finally you can specify the
order of the parameters because some Soap

00:25:40.359 --> 00:25:43.740
and XML RPC services require parameters
to be in a specific order.

00:25:43.740 --> 00:25:51.109
You can use this stirred array argument to specify
the names in the order that you want to send them.

00:25:51.109 --> 00:25:53.719
Next its time to set extra properties on the request.

00:25:53.720 --> 00:26:01.730
WebServices Core represents some aspects of Soap and
XML RPC requests as these, this concept of extra properties.

00:26:01.730 --> 00:26:07.339
And the properties come in basically four
categories, Soap, HTTP, debugging properties

00:26:07.339 --> 00:26:09.599
and then there's a few miscellaneous properties.

00:26:09.599 --> 00:26:14.409
But you set these with the WS method
invocation set property function.

00:26:14.410 --> 00:26:20.220
This takes three arguments, the request itself, a key and
there's several constants to defining web services core

00:26:20.220 --> 00:26:22.210
for all of the properties that you might want to set.

00:26:22.210 --> 00:26:23.390
And a value.

00:26:23.390 --> 00:26:29.580
Just to look very briefly at some of the properties
that are available, in the Soap category they follow

00:26:29.579 --> 00:26:34.259
of naming convention of K WS, WS for web services, Soap.

00:26:34.259 --> 00:26:37.000
And then the actual property that you're setting.

00:26:37.000 --> 00:26:40.700
Method names base URI is one you
will often have to use for Soap.

00:26:40.700 --> 00:26:43.720
And there others including encoding
styles and other features of Soap

00:26:43.720 --> 00:26:46.620
that you often deal with when dealing with Soap services.

00:26:46.619 --> 00:26:48.889
There's HTTP properties.

00:26:48.890 --> 00:26:53.250
Again, following the convention of K WS HTTP extra headers,

00:26:53.250 --> 00:26:56.980
this is how you can actually add a
Soap action header to your request.

00:26:56.980 --> 00:27:02.490
It's often necessary and also some other
HTTP information like proxy information.

00:27:04.059 --> 00:27:06.609
There's actually four keys for
debugging that can be extremely useful.

00:27:06.609 --> 00:27:09.769
These follow the same convention, KWS debug.

00:27:09.769 --> 00:27:13.639
Then you have outgoing body, outgoing
headers, incoming body and incoming headers.

00:27:13.640 --> 00:27:19.070
If you set any, all of these properties to true, you'll
actually see the raw XML messages being sent back

00:27:19.069 --> 00:27:22.099
and forth in the result dictionary,
this return from the server.

00:27:22.099 --> 00:27:24.649
So this can actually be extremely helpful for debugging.

00:27:24.650 --> 00:27:26.800
I recommend always setting these
to true when you're first starting

00:27:26.799 --> 00:27:29.099
out using web services core to access a new service.

00:27:29.099 --> 00:27:33.169
So you can see the raw XML messages being sent and debug.

00:27:33.170 --> 00:27:35.560
And there's some other miscellaneous
properties we won't go into.

00:27:35.559 --> 00:27:37.279
You can check those out in the API.

00:27:37.279 --> 00:27:40.839
So now its time to send the Soap message.

00:27:40.839 --> 00:27:45.859
WebServices Core supports both
synchronous and asynchronous messaging.

00:27:45.859 --> 00:27:50.139
For synchronous messaging, there's
WS method invocation invoke function

00:27:50.140 --> 00:27:53.800
and this actually returns the result
dictionary directly synchronously.

00:27:53.799 --> 00:27:59.220
Or if you want to send an asynchronous message, you can
set a call back with a function of a defined signature

00:27:59.220 --> 00:28:02.579
And then schedule the execution in the next run loop.

00:28:03.799 --> 00:28:07.819
So we've sent the Soap request to the Soap
server and the server should return a result.

00:28:07.819 --> 00:28:10.259
And the result is going to be modeled as a dictionary.

00:28:10.259 --> 00:28:14.390
And the dictionary will contain all of the
information including the result value as well

00:28:14.390 --> 00:28:17.840
as debugging information if you
ask for debugging information.

00:28:17.839 --> 00:28:20.139
First thing you should do is check for a Soap fault.

00:28:20.140 --> 00:28:24.710
Soap faults are something defined by the Soap
specification that's an application level fault

00:28:24.710 --> 00:28:27.250
that the server may send back to you.

00:28:27.250 --> 00:28:29.630
So you want to check for that as soon as you get the result.

00:28:29.630 --> 00:28:31.850
If you did get a Soap fault, there's a couple of keys

00:28:31.849 --> 00:28:37.079
that you could access inside the result
dictionary to get Soap fault information.

00:28:37.079 --> 00:28:39.339
So assuming that you've gotten passed the fault stage,

00:28:39.339 --> 00:28:44.529
you can now retrieve the result object
from the response from the server.

00:28:44.529 --> 00:28:48.039
So to get those result object out
of the response dictionary,

00:28:48.039 --> 00:28:51.099
there's a specific key, WS method invocation result.

00:28:51.099 --> 00:28:54.959
And you can fetch the result out
of the dictionary using that key.

00:28:54.960 --> 00:28:58.740
So now at this point we've done the entire
interaction of the Soap request and response.

00:28:58.740 --> 00:29:03.589
And you can use the response data in
your application however you choose.

00:29:03.589 --> 00:29:07.509
So that was web services core.

00:29:07.509 --> 00:29:17.920
( Period of silence )

00:29:17.920 --> 00:29:26.660
Increasingly, we're seeing adoption of a new style or
a new architecture for web services rather than Soap

00:29:26.660 --> 00:29:30.009
or XML RPC that kinda follow an RPC mechanism.

00:29:30.009 --> 00:29:35.970
There is a growing collection of web services
that are using something called Rest.

00:29:35.970 --> 00:29:36.829
So what is Rest?

00:29:36.829 --> 00:29:43.220
Just to describe briefly what we're going to talk about today
when we mean, when we say Rest, there was an individual,

00:29:43.220 --> 00:29:48.279
a very smart guy named Roy Fielding who is one
of the cofounders of the Apache Foundation.

00:29:48.279 --> 00:29:52.970
And also involved in the IHEF working groups
for several very important specifications

00:29:52.970 --> 00:29:57.089
for web technologies such as URI, HTTP, and HTML.

00:29:57.089 --> 00:30:01.859
So obviously, Roy Fielding, very smart guy,
involved in a lot of important projects.

00:30:01.859 --> 00:30:05.719
In the year 2000 he wrote a PhD
dissertation where he coined the term Rest.

00:30:05.720 --> 00:30:11.930
I think it's probably fair to say that about the
time around 2000, Soap and XML RPC were beginning

00:30:11.930 --> 00:30:15.440
to gain popularity as ways to develop web services.

00:30:15.440 --> 00:30:20.299
It's probably fair to say that Roy Fielding was not a
huge fan of this architectural style for web services.

00:30:20.299 --> 00:30:24.629
And he was kind of looking at these design
ideas coming from Soap and XML RPC and saying,

00:30:24.630 --> 00:30:28.600
actually I think maybe there's
simpler way to design web services

00:30:28.599 --> 00:30:31.909
that also is working today in scales extremely well.

00:30:31.910 --> 00:30:35.600
And I see these services all around
me and it's called the World Wide Web.

00:30:35.599 --> 00:30:43.579
So he coined the term Rest as kind of a means of codifying
the characteristics of the web which made the web useful.

00:30:43.579 --> 00:30:48.980
So again, in this 2000 PhD dissertation, he kind
of went on to say, what makes the web work so well?

00:30:48.980 --> 00:30:56.140
What about the architecture of the web is so great that
makes it do all these things that we enjoy every day?

00:30:56.140 --> 00:30:59.720
And so he did coin this term called Rest.

00:30:59.720 --> 00:31:03.170
And Rest stands for representational state transfer.

00:31:03.170 --> 00:31:04.810
Rest is not a standard.

00:31:04.809 --> 00:31:08.339
It's actually an architectural style of network systems.

00:31:08.339 --> 00:31:17.189
But it is however built on top of several other
standards such as URL, HTTP, XML, HTML, PING and others.

00:31:17.190 --> 00:31:22.580
And an important point is the World Wide
Web itself is a massive restful system.

00:31:22.579 --> 00:31:28.609
So what is a restful web service?

00:31:28.609 --> 00:31:33.219
Just the, the actual basics of what a restful
web services is actually quite simple.

00:31:33.220 --> 00:31:37.390
And probably sound very familiar to you if
you're used to the web, which of course you are.

00:31:37.390 --> 00:31:43.490
So a restful web service is just a collection of
resources and all these resources are addressable by URL.

00:31:43.490 --> 00:31:44.660
This is important for book marking.

00:31:44.660 --> 00:31:48.450
You can always book mark a resource
just by book marking its URL.

00:31:48.450 --> 00:31:55.750
And these resources are accessible by a small set
of HTTP verbs such at get, put, post and delete.

00:31:55.750 --> 00:32:00.099
Using a HTTP verb like get just accesses a resource.

00:32:00.099 --> 00:32:08.259
Using a HTTP verb such as post will create a resource,
delete deletes a resource, put updates etcetera.

00:32:08.259 --> 00:32:14.329
So the resources returned by a restful, restful
web service could be anything but, but in practice

00:32:14.329 --> 00:32:19.710
and in the web services we're going to talk about today, you'll
often find that either HTML or XML mark up is returned

00:32:19.710 --> 00:32:21.440
as a resource from a restful web service.

00:32:21.440 --> 00:32:28.289
So as kind of an example of the popular restful web
service that's available today that you can use,

00:32:28.289 --> 00:32:34.339
Amazon has several services for which it
has a rest based, rest style interface.

00:32:34.339 --> 00:32:41.829
And here we have a URL to specific resource
available by the Amazon web service.

00:32:41.829 --> 00:32:47.009
And this URL is actually asking for
books, items from the category books

00:32:47.009 --> 00:32:50.289
who might be associated with the title Harry Potter.

00:32:50.289 --> 00:32:55.829
So if we were to use this resource or if we to
use this URL to access resources from Amazon,

00:32:55.829 --> 00:32:59.689
we might receive this XML resource that
includes a list of books available for sale

00:32:59.690 --> 00:33:03.880
on Amazon associated with the title Harry Potter.

00:33:03.880 --> 00:33:06.740
So again, just a quick diagram of the
interaction we're talking about here.

00:33:06.740 --> 00:33:08.289
We have a client, we have a server.

00:33:08.289 --> 00:33:13.000
The client is going to send an HTTP get
request with the specific URL to the server.

00:33:13.000 --> 00:33:19.210
And the server's going to return an XML
representation of the resource that was requested.

00:33:20.470 --> 00:33:24.380
So accessing a rest service from a Cocoa app.

00:33:24.380 --> 00:33:26.480
There's actually a few different ways you could do this.

00:33:26.480 --> 00:33:30.120
But one really simple way you could do
it we'll talk about here in this diagram.

00:33:30.119 --> 00:33:34.149
First obviously you want to build the URL
for the resource that you want to access.

00:33:34.150 --> 00:33:39.420
So in Cocoa URLs are represented by a class
called NS URL, so you can build this URL first.

00:33:39.420 --> 00:33:44.390
Then in a minute we're going to talk
about a tool kit called NSXML.

00:33:44.390 --> 00:33:45.720
So we'll go into the details in a minute.

00:33:45.720 --> 00:33:51.019
But there's actually a class called NSXML
document, which has a method called contents of URL.

00:33:51.019 --> 00:33:57.299
Which is a really easy way to grab an object
representation of a remote XML resource, given a URL.

00:33:57.299 --> 00:34:01.619
So a very high level, convenient
way to access this remote resource.

00:34:01.619 --> 00:34:05.159
At that point, you've got your object
representation of the remote XML resource.

00:34:05.160 --> 00:34:08.849
And you can use any kind of XML programming
tools that you've got at your disposal

00:34:08.849 --> 00:34:11.480
to interact with this data return from the server.

00:34:11.480 --> 00:34:16.039
Tools such as Xray, XSLT, DOM or others.

00:34:18.909 --> 00:34:23.649
So we've been talking a lot about XML especially
in connection with Rest based web services.

00:34:23.650 --> 00:34:29.160
So you're going to need an XML programming tool
in your Cocoa application to interact with this

00:34:29.159 --> 00:34:32.129
and program these XML responses returned from the server.

00:34:32.130 --> 00:34:37.970
We actually have a fantastic tool kit
available to you in Cocoa called NSXML.

00:34:37.969 --> 00:34:45.509
So NSXML is our native Cocoa API
for XML programming on OS X.

00:34:45.510 --> 00:34:50.870
NSXML is a tree API for XML programming, very
similar to what you might be familiar with,

00:34:50.869 --> 00:34:53.989
with DOM if you're familiar with
Java Script or Java programming.

00:34:53.989 --> 00:35:00.139
So it's a tree API that represents an XML document
as a hierarchy of nodes, very similar to DOM.

00:35:00.139 --> 00:35:02.859
However it's based roughly on the X Query data model.

00:35:02.860 --> 00:35:05.440
X Query data model is very similar to DOM except

00:35:05.440 --> 00:35:08.690
that it adds a few extra items to
its model that DOM doesn't include.

00:35:08.690 --> 00:35:12.480
So whereas DOM represents an XML
document as a collection of nodes,

00:35:12.480 --> 00:35:16.250
X Query data model also represents
XML document as a collection of nodes.

00:35:16.250 --> 00:35:22.250
But X Query data model includes a couple of other items
such as atomic values in its data model and also sequences.

00:35:22.250 --> 00:35:26.099
So atomic values could be anything
like strings or numbers or dates.

00:35:26.099 --> 00:35:30.349
And sequences are ordered items,
sorry, ordered collections of items.

00:35:30.349 --> 00:35:33.650
So again the X Query data model not
only models XML documents as nodes

00:35:33.650 --> 00:35:37.300
but also includes atomic values and sequences.

00:35:37.300 --> 00:35:42.769
NSXML is based roughly on this model.

00:35:42.769 --> 00:35:46.250
NSXML also includes an implementation
of X Path 2 point 0 and X Query.

00:35:46.250 --> 00:35:50.000
If you're not familiar with these, these
are really fantastic tools to have available

00:35:50.000 --> 00:35:52.300
on your platform for doing XML programming.

00:35:52.300 --> 00:35:58.030
X Path could be thought of maybe as a, kind of
a regular expression syntax specific to XML.

00:35:58.030 --> 00:36:05.030
It's a non XML syntax that allows you to address
and extract very specific parts of an XML document

00:36:05.030 --> 00:36:07.050
at a very high level and very conveniently.

00:36:07.050 --> 00:36:09.480
And X Query is kind of like Sequel for XML.

00:36:09.480 --> 00:36:12.760
Obviously it's a query language specifically built for XML.

00:36:12.760 --> 00:36:18.130
And it's a super set of X Path 2 point 0.

00:36:18.130 --> 00:36:21.309
NSXML also supports XSLT transformations.

00:36:21.309 --> 00:36:25.989
And NSXML also supports validation against a DTD.

00:36:25.989 --> 00:36:32.239
A couple other features like X include
for including a remote XML fragments

00:36:32.239 --> 00:36:34.829
into a main XML document as you parse it.

00:36:34.829 --> 00:36:40.719
And also tidying for fixing up well form NS errors
in an XML document as you parse it initially.

00:36:40.719 --> 00:36:47.750
You can use NSXML to create an object representation
of an XML file on disk, either locally or remotely.

00:36:47.750 --> 00:36:53.760
You can also use NSXML to programmatically
create an XML document.

00:36:53.760 --> 00:36:58.450
It's layered on a couple of open source
technologies that are available on OS X platform,

00:36:58.449 --> 00:37:02.500
specifically lib XML 2 which provides the parsing abilities.

00:37:02.500 --> 00:37:06.070
Lib XSLT which provides the XSLT capabilities.

00:37:06.070 --> 00:37:12.070
And tidy which of course provides the tidying
abilities for fixing well form NS errors.

00:37:12.070 --> 00:37:18.910
Another interesting feature of NSXML that maybe a lot of
people don't know about is it does all the methods in NSXML

00:37:18.909 --> 00:37:24.219
or excuse me, all of the attributes of the
NSXML objects support key value observing

00:37:24.219 --> 00:37:27.409
and key value coding, so it also supports Cocoa bindings.

00:37:27.409 --> 00:37:32.019
This is a way to very easily bind the elements
and attributes of an XML document directly

00:37:32.019 --> 00:37:36.250
to a Cocoa user interface without a lot of
controller code, shuttling data back and forth.

00:37:36.250 --> 00:37:44.230
So just a quick look at a couple of the
important classes from the NSXML API.

00:37:44.230 --> 00:37:52.929
Very much like DOM, NSXML has a base node class that is
the base class from which other types of nodes descend.

00:37:52.929 --> 00:37:55.129
And in DOM you have the base node class.

00:37:55.130 --> 00:37:58.630
In NSXML you have base NSXML node class.

00:37:58.630 --> 00:38:02.230
And then there's a couple of specific
important classes that descend from that.

00:38:02.230 --> 00:38:06.159
Specifically NSXML document represent
the document as a whole.

00:38:06.159 --> 00:38:09.369
And NSXML element which represents XML element nodes.

00:38:09.369 --> 00:38:16.230
Just to go over a couple of the interesting
features of NSXML features that I mentioned before,

00:38:16.230 --> 00:38:24.070
it does include a really great high level
way for accessing remote XML documents.

00:38:24.070 --> 00:38:30.230
So there's an instance method of the NSXML document
class that's called Init with Contents of URL.

00:38:30.230 --> 00:38:35.780
If you're not familiar with Cocoa, Init methods are kind of
very similar to constructor methods in some other languages.

00:38:35.780 --> 00:38:37.870
So this actually is kind of like constructor method

00:38:37.869 --> 00:38:43.109
that will return an NSXML document
representation of a remote XML resource.

00:38:43.110 --> 00:38:49.000
So it's a really great, convenient high level way to
get an object representation of a remote XML document.

00:38:49.000 --> 00:38:56.059
So with the Init of content, Init with
contents of URL method of NSXML document,

00:38:56.059 --> 00:39:02.460
you retrieve an NSXML document representation
of a remote resource given the URL.

00:39:02.460 --> 00:39:07.559
And I mentioned there were a couple of other
features of NSXML such as tidying and validation.

00:39:07.559 --> 00:39:10.460
And this is actually the gateway to
some of those features right here.

00:39:10.460 --> 00:39:15.159
There's a second argument to this method called options
where you can order together a few options that allow you

00:39:15.159 --> 00:39:21.250
to validate or X Include or tidy your
document as its parsed initially.

00:39:22.469 --> 00:39:24.929
( Period of silence )

00:39:24.929 --> 00:39:28.929
So I mentioned the NSXML supports X Query.

00:39:28.929 --> 00:39:32.980
There's a couple of methods that support this functionality.

00:39:32.980 --> 00:39:39.579
But one important one is this, the instance method
on NSXML node called objects by applying X Query.

00:39:39.579 --> 00:39:43.909
With this method you can retrieve a sequence of items.

00:39:43.909 --> 00:39:49.049
And the context of your X Query will be the
actual node that you call this method on.

00:39:49.050 --> 00:39:51.360
And you can pass a string that contains an X Query

00:39:51.360 --> 00:39:58.460
and that of course will return the
sequence of items that match the X Query.

00:39:58.460 --> 00:40:02.110
I also mentioned that XSLT is supported by NSXML.

00:40:02.110 --> 00:40:09.610
There's an instance method of the NSXML
document class called object by applying XSLT.

00:40:09.610 --> 00:40:14.720
So again, you can pass an XSLT string
or an XSLT data object to this method.

00:40:14.719 --> 00:40:19.129
And what will be returned is the
result of the XSLT transformation.

00:40:19.130 --> 00:40:25.320
XSLT itself can return a new XML
document or even strings or other objects.

00:40:25.320 --> 00:40:29.559
So this is kind of generically
typed as ID rather than a document.

00:40:29.559 --> 00:40:36.949
And I just want to do a quick demo of a Cocoa
app that I threw together that uses NSXML

00:40:36.949 --> 00:40:40.839
to access a remote rest style web service.

00:40:42.510 --> 00:40:50.230
( Period of silence )

00:40:50.230 --> 00:40:51.130
Gonna quit Xcode.

00:40:51.130 --> 00:41:00.360
So I created this little application called YouTube Pal.

00:41:00.360 --> 00:41:07.590
And as I mentioned before YouTube has a rest interface for its
web services that allow you to search its videos by tags.

00:41:07.590 --> 00:41:11.940
So as users upload videos to YouTube,
they tag them with different items,

00:41:11.940 --> 00:41:15.710
with different strings to represent what they're about.

00:41:15.710 --> 00:41:19.929
So this is just a very simple Cocoa app
that using NSXML and also uses web kit.

00:41:19.929 --> 00:41:24.779
If you're not familiar with web kit, web kit
is our web rendering engine on the platform.

00:41:24.780 --> 00:41:26.560
You've probably heard a ton about it this week.

00:41:26.559 --> 00:41:30.110
Obviously its, it powers to Safari web browser

00:41:30.110 --> 00:41:32.309
So I've embedded web kit in this application.

00:41:32.309 --> 00:41:40.190
And I'm going to use NSXML to make a request to the
rest interface of YouTube and then I'm going to use NSXML

00:41:40.190 --> 00:41:44.579
to apply an XSLT transformation on the
XML response that I get from YouTube.

00:41:44.579 --> 00:41:49.279
So I'm going to go directly from XML response
from the web service to HTML interface.

00:41:49.280 --> 00:41:50.700
So there's no objects in between.

00:41:50.699 --> 00:41:56.649
This is kind of a really convenient way to access, to
access remote web services and, and interact with them.

00:41:56.650 --> 00:41:59.420
Because there's no converting to
objects and then back to mark.

00:41:59.420 --> 00:42:01.400
There's just no mark up objects, mark up.

00:42:01.400 --> 00:42:05.869
I just go straight from XML mark up
directly to HTML user interface using XSLT.

00:42:05.869 --> 00:42:11.190
So the way this application will work is, I
can type in a tag that I want to search for.

00:42:11.190 --> 00:42:16.929
So if I want to search for say iPhone videos on YouTube,
when I click enter, it's going to send the request

00:42:16.929 --> 00:42:23.119
to the YouTube rest interface, transform the result
into an HTML user interface and display it on the UI.

00:42:23.119 --> 00:42:23.839
And so here it is.

00:42:23.840 --> 00:42:28.590
I've got a list of just a few, I'm limiting
the results to like 20 or 22 or so mething.

00:42:28.590 --> 00:42:30.570
Of course there's a lot more videos on YouTube than this.

00:42:30.570 --> 00:42:34.710
And then when I click an item, its
actually using an HTML embed tag over here

00:42:34.710 --> 00:42:37.420
on the left and I can watch videos about the iPhone.

00:42:37.420 --> 00:42:40.110
I don't think I have audio hooked up, but that's okay.

00:42:40.110 --> 00:42:47.269
Might remember this video was the Conan O'Brien play
on the iPhone functionality which was pretty funny.

00:42:47.269 --> 00:42:49.159
But anyway, this application.

00:42:49.159 --> 00:42:54.929
( Laughter )
Side burns.

00:42:54.929 --> 00:43:03.659
Just a really simple example of how you can use NSXML
to interact with the remote rest style web service.

00:43:03.659 --> 00:43:05.839
It's a cheese grater.

00:43:05.840 --> 00:43:07.400
( Laughter )

00:43:07.400 --> 00:43:12.510
Anyway. Back to slides please.

00:43:12.510 --> 00:43:18.960
( Period of silence )

00:43:18.960 --> 00:43:25.480
so that was NSXML and it's a really fantastic
tool for accessing remote rest style web services

00:43:25.480 --> 00:43:29.050
or just doing general XML programming on OS X.

00:43:29.050 --> 00:43:32.720
Very helpful tool, a lot of great
features, X Query, X Path 2 point 0.

00:43:32.719 --> 00:43:38.519
So I just kinda want to summarize the
things we talked about here today.

00:43:38.519 --> 00:43:44.000
WebServices Core is our native C based tool
kit for doing XML RPC and Soap based programming

00:43:44.000 --> 00:43:46.539
from your Cocoa or Carbon client application.

00:43:46.539 --> 00:43:51.699
If you need to interact with an XML RPC service,
I highly recommend trying web services core.

00:43:51.699 --> 00:43:53.219
It's very solid for that.

00:43:53.219 --> 00:43:56.599
As far as Soap programming, Soap is kind of
notorious for in or out problems where a lot

00:43:56.599 --> 00:44:00.380
of times Java tools won't interact
well with dot not tools and etcetera.

00:44:00.380 --> 00:44:02.590
And so you're probably going to
run into some in or out problems.

00:44:02.590 --> 00:44:06.920
But I would recommend trying web services
core for Soap programming as well.

00:44:06.920 --> 00:44:10.250
And then for accessing remote rest style web services,

00:44:10.250 --> 00:44:15.239
NSXML is a fantastic tool available
on our platform for doing that.

00:44:15.239 --> 00:44:22.439
For more information we have an NSXML programming guide
and also a programming guide for web services core online.

00:44:22.440 --> 00:44:24.590
And we have a new article that we just did a,

00:44:24.590 --> 00:44:29.690
a short while again about adding HTTP
authentication to your use of web services core.

00:44:29.690 --> 00:44:36.269
So if you need to access a remote based web, a remote web
service that's behind HTTP basic or digest authentication.

00:44:36.269 --> 00:44:38.119
And we've got an article up on that.
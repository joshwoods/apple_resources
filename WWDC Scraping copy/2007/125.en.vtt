WEBVTT

00:00:10.849 --> 00:00:12.439
>> My name is Peter Ammon.

00:00:12.439 --> 00:00:15.059
I'm an engineer on the Cocoa Frameworks team.

00:00:15.060 --> 00:00:21.480
This is Building a Custom Control for your Cocoa
Application and that's exactly what we're going to do.

00:00:21.480 --> 00:00:23.379
All right.

00:00:24.690 --> 00:00:28.950
So this isn't something you have to do often right?

00:00:28.949 --> 00:00:33.409
Because Cocoa gives you a lot of flexibility
in terms of modifying existing controls.

00:00:33.409 --> 00:00:41.359
You can take any NS button and you can override draw rec in
a sub class and you can draw whatever crazy thing you want.

00:00:41.359 --> 00:00:43.479
But we're not going to talk about that.

00:00:43.479 --> 00:00:46.909
What we're going to talk about the whole enchilada.

00:00:46.909 --> 00:00:49.299
We're going to make a track ball type control.

00:00:49.299 --> 00:01:00.899
It will be used for rotating objects in like a 3D context
and =in our sample code, which is attached to the session,

00:01:00.899 --> 00:01:09.569
we have a panorama viewer and the track ball that is
moved through the panoramic view in a very nice way.

00:01:09.569 --> 00:01:13.609
So I'm going to give you a demo of that now if I can.

00:01:17.769 --> 00:01:26.530
So this here is the track ball viewer and much of what you
see is drawn with quartz composer, not Cocoa and we'll talk

00:01:26.530 --> 00:01:32.450
about why that is and you can see, you can move
through it nicely with the mouse, rotating up and down,

00:01:32.450 --> 00:01:36.859
left and right, can do a barrel roll by going around.

00:01:36.859 --> 00:01:45.280
Of course it responds with the scroll ball, you can use the
mighty mouse, that works well because it's got 360 degrees.

00:01:45.280 --> 00:01:52.670
We have arrow keys, so by pressing the up and down
arrow keys, left and right you can rotate around

00:01:52.670 --> 00:01:56.299
and by holding down option, we can rotate in a circle.

00:01:59.390 --> 00:02:04.030
And there's three text fields at
the bottom and we can tab to those,

00:02:04.030 --> 00:02:08.349
we can click on one and it'll animate to the new position.

00:02:12.169 --> 00:02:18.859
Of course, it does not accept invalid input, so I
type in pizza, it's not going to let me enter that.

00:02:18.860 --> 00:02:21.570
And there's more to this that isn't immediately obvious.

00:02:21.569 --> 00:02:28.049
For example, this control is fully
accessible, it's exposed to accessibility.

00:02:28.050 --> 00:02:34.900
So let's talk about some of the decisions we
made in designing this control and how we did it.

00:02:34.900 --> 00:02:36.819
Let's go back to the slides.

00:02:42.810 --> 00:02:46.180
So we chose to sub class NS control.

00:02:46.180 --> 00:02:47.110
Why NS control?

00:02:47.110 --> 00:02:52.750
Well we could have sub classed NS view but,
NS control gives us a lot more for free.

00:02:52.750 --> 00:02:57.979
For example, it gives us mouse tracking and it gives
us more event handling, it gives us target action.

00:03:01.289 --> 00:03:03.280
So here are the topics we're going to cover.

00:03:03.280 --> 00:03:07.699
We'll talk about making a custom cell because, you
can have a custom control without a custom cell.

00:03:07.699 --> 00:03:12.780
We'll go through different appearances you have for your
control, different states, different ways it needs to draw,

00:03:12.780 --> 00:03:15.110
choices you have for behavior of your control,

00:03:15.110 --> 00:03:19.820
should it send a continuous action,
how we did the text editing component.

00:03:19.819 --> 00:03:21.439
We'll talk about making it accessible.

00:03:21.439 --> 00:03:25.469
We'll touch on bindings and we'll finish
up with some common pitfalls you might run

00:03:25.469 --> 00:03:29.240
into when designing your own control and we'll wrap up.

00:03:29.240 --> 00:03:32.550
So a custom cell.

00:03:32.550 --> 00:03:36.719
All right, seems like every control has a custom cell.

00:03:36.719 --> 00:03:40.789
There's NS date picker, there's NS date picker cell,
there's button and then there's NS button cell,

00:03:40.789 --> 00:03:46.239
there's pop up button and pop up button cell, there's text
field and text field cell, there's slider, slider cell.

00:03:46.240 --> 00:03:50.659
So are we going to need to make a
track ball and a track ball cell?

00:03:50.659 --> 00:03:56.349
Well you think so, but really no, you do not have to.

00:03:56.349 --> 00:03:59.469
You do not make a custom cell.

00:03:59.469 --> 00:04:05.050
In the Cocoa frameworks, we have to make cells for every
control so that the control can be used in a table view.

00:04:05.050 --> 00:04:09.570
But if you're not planning to put track ball
in a table view and we certainly aren't,

00:04:09.569 --> 00:04:11.289
then there's no reason to make a custom cell.

00:04:11.289 --> 00:04:14.759
We can do everything we need in
the context of just the control.

00:04:14.759 --> 00:04:16.810
And this gives us some advantages.

00:04:16.810 --> 00:04:21.069
It means we can add sub views to our
control to help us draw for example.

00:04:21.069 --> 00:04:29.990
But that's not to say we're not going to use cells, in fact,
we're going to use cells quite a lot and you want the control

00:04:29.990 --> 00:04:37.650
to have a cell and by have a cell, I mean the cell method
should return something meaningful for your control.

00:04:37.649 --> 00:04:44.579
The reason for that is that many NS control
methods just pass on the parameter to NS cell.

00:04:44.579 --> 00:04:49.509
For example, set target and set action, these don't
do anything unless you have an NS cell attached

00:04:49.509 --> 00:04:51.569
to your control.

00:04:51.569 --> 00:04:53.990
But it can be a plain vanilla NS action cell.

00:04:53.990 --> 00:05:00.319
This turns out to be the most base cell which implements
what we need and this is the cell for our track ball.

00:05:01.459 --> 00:05:08.049
So do make sure your control has a cell in your
control class, you'll override the class method,

00:05:08.050 --> 00:05:12.009
cell class and return whatever class of the cell you want.

00:05:12.009 --> 00:05:15.399
Another way to do this is to call
set cell class on the control.

00:05:15.399 --> 00:05:18.019
It's really up to you, there's
not a whole lot of difference.

00:05:18.019 --> 00:05:21.129
All right, so custom cell, that's gone.

00:05:21.129 --> 00:05:23.879
We're not going to do that.

00:05:23.879 --> 00:05:27.879
Let's talk about the different ways your control can draw.

00:05:30.389 --> 00:05:35.509
So there's a lot of different techniques for drawing in Cocoa
and we've seen, I'm sure you're familiar with a lot of them.

00:05:35.509 --> 00:05:38.560
We can use a sub view of your control
to draw and this is one

00:05:38.560 --> 00:05:42.519
of the things we can do because
we're not making a custom cell.

00:05:42.519 --> 00:05:47.229
You can also draw directly with
cells, called draw with frame.

00:05:47.230 --> 00:05:52.740
You can draw with NS images, you can use Cocoa drawing
primitives, bezier path and fillrect.

00:05:52.740 --> 00:05:58.420
Of course there's OpenGL and if you're interested in
this, we're not going to talk a whole lot more about it,

00:05:58.420 --> 00:06:03.080
but I encourage you to attend the Cocoa drawing
techniques session, which is just after this session

00:06:03.079 --> 00:06:06.209
and of course, come see us in the Cocoa labs.

00:06:07.730 --> 00:06:08.879
How are we drawing track ball?

00:06:08.879 --> 00:06:16.159
Well, as I said, we're using quartz composer to
draw the actual ball and all we do is make a sphere

00:06:16.160 --> 00:06:23.200
and we slap a texture on it and we put it inside a lighting
environment and then we get a QC view and we add the QC view

00:06:23.199 --> 00:06:26.509
as a sub view of our control and we're done.

00:06:26.509 --> 00:06:30.069
That's how we can draw the entire
ball with in one line of code.

00:06:30.069 --> 00:06:31.730
Which is very nice.

00:06:31.730 --> 00:06:34.790
The labels are going to be draw with NS cell.

00:06:34.790 --> 00:06:41.540
This is not a text field cell, it's just plain NS cell
and each angle as a number, is drawn with one cell

00:06:41.540 --> 00:06:44.080
and each label is drawn with a different cell.

00:06:44.079 --> 00:06:47.750
And while there's three text fields down
there, apparently we're only using one cell

00:06:47.750 --> 00:06:51.019
and we're using it to draw three different places.

00:06:53.959 --> 00:06:57.969
Now, because we're adding the QC
view as a sub view of our control,

00:06:57.970 --> 00:07:01.260
we have this concern about the QC view intercepting events.

00:07:01.259 --> 00:07:07.199
So if you click on our control, but you actually
click on the track ball QC view, you have a problem.

00:07:07.199 --> 00:07:09.750
Because the QC view will handle the event.

00:07:09.750 --> 00:07:11.430
So how are we going to fix this?

00:07:11.430 --> 00:07:13.579
Well I'm sure you know how.

00:07:13.579 --> 00:07:16.919
You override the hit test method, that's what we'll do.

00:07:16.920 --> 00:07:23.780
So in hit test is called in our control, we'll call
through to super and if the result is our QC view,

00:07:23.779 --> 00:07:26.139
then we'll return self instead of the QC view.

00:07:26.139 --> 00:07:30.490
And in this way, we will block the
QC view from intercepting events.

00:07:32.600 --> 00:07:40.379
Let's see we've got.

00:07:40.379 --> 00:07:46.360
Ah, so this is a cell and it's happy,
because cells are, they're friendly.

00:07:46.360 --> 00:07:53.410
I think a lot of people have a certain fear of cells for
various reasons and if there's one thing I could impart

00:07:53.410 --> 00:07:59.030
to you from this session, it would be that
cells are not hard to use and do a lot for you.

00:07:59.029 --> 00:08:05.259
Even plain NS cell by itself, not even a sub
class, can do quite a bit and we'll use it.

00:08:05.259 --> 00:08:11.879
For example, NS cell can draw text and images and
with Leopard, we have a lot of effects available

00:08:11.879 --> 00:08:17.269
for drawing those texts and images and some of
those effects are visible in the track ball.

00:08:19.430 --> 00:08:21.759
Cells are also used for text editing.

00:08:21.759 --> 00:08:29.480
Right, we clicked on the text field and we began
editing in an NS text view and cell facilitated that.

00:08:29.480 --> 00:08:35.980
We saw how we blocked invalid input, we can do that
with the formatter of the cell and also localization.

00:08:35.980 --> 00:08:42.370
So we saw that the angle had a period because that's
the decimal separator used in our current localization,

00:08:42.370 --> 00:08:45.700
but in a different localization, you might use a comma.

00:08:45.700 --> 00:08:48.930
The cell will handle that for us with the help of formatter.

00:08:48.929 --> 00:08:51.049
And cells are used for a lot of behavior.

00:08:51.049 --> 00:08:55.519
For example, target action, mouse tracking and some others.

00:08:55.519 --> 00:09:05.000
So when we draw the cells at the bottom in our
track ball, as I said they're ordinary NS cells

00:09:05.000 --> 00:09:07.149
and we're giving them a number formatter.

00:09:07.149 --> 00:09:11.669
We're also giving them a background style.

00:09:11.669 --> 00:09:13.429
Now what is a background style?

00:09:13.429 --> 00:09:17.629
This is something new in Leopard
and all it is is just an enum.

00:09:17.629 --> 00:09:24.789
It's just an integer in C and the background styles
visually describes the surface onto which you're drawing.

00:09:24.789 --> 00:09:28.129
What do I mean be visually describes?

00:09:28.129 --> 00:09:32.639
Well you'll never see a window background
style or a menu background style,

00:09:32.639 --> 00:09:35.449
because those don't give you information
about what it looks like.

00:09:35.450 --> 00:09:41.540
But you might see a raised metal background style or
plastic or glossy or something which gives you an indication

00:09:41.539 --> 00:09:46.449
of how the content you draw on top
of the background style should look.

00:09:47.480 --> 00:09:50.629
And NS cell uses background styles to determine the text

00:09:50.629 --> 00:09:54.610
and image effects it applies when
drawing on a different background.

00:09:55.850 --> 00:09:59.730
And this isn't magic right, it
can't look at the actual background.

00:09:59.730 --> 00:10:05.580
It's up to you as a client programmer, to
tell the control what it's background is.

00:10:05.580 --> 00:10:14.920
So some cells, for example ordinary NS button cell, that
draws a standard aqua frame, they have their own style.

00:10:14.919 --> 00:10:16.919
They draw their own background.

00:10:16.919 --> 00:10:22.439
So for example, this is an aqua button and any kind
of background you put it on, it's going to be legible,

00:10:22.440 --> 00:10:27.960
it's going to look okay and the content, the text
in the center, does not change it's appearance,

00:10:27.960 --> 00:10:30.450
even though the background of the cell might change.

00:10:30.450 --> 00:10:33.740
So the cell itself has a background style inside it.

00:10:33.740 --> 00:10:39.500
We call it the interior background style and we can call the
interior background style to get this and you can use this

00:10:39.500 --> 00:10:46.559
to determine how to draw when you're, if you were to
draw on top of the cell, which we're not going to do.

00:10:48.220 --> 00:10:53.610
Now for unbeveled cells, cells that just draw
the text or images without any sort of border,

00:10:53.610 --> 00:10:55.889
they have to be told their background style.

00:10:55.889 --> 00:10:59.960
So for example, we're drawing one button
on top of four different backgrounds,

00:10:59.960 --> 00:11:04.310
well the text becomes progressively less
legible or it just kind of looks flat

00:11:04.309 --> 00:11:06.099
or plain, looks like it's missing something.

00:11:06.100 --> 00:11:12.029
In this case, the background styles
correspond to light rays, lowered and dark.

00:11:12.029 --> 00:11:16.019
So that's NS raised background style,
NS dark background style.

00:11:16.019 --> 00:11:25.179
And by calling set background style on the cell, the
text will apply effect so that it becomes legible.

00:11:25.179 --> 00:11:28.969
In the case of the ray's background
style, it'll have an engraved effect.

00:11:28.970 --> 00:11:32.200
In the case of dark, it'll just invert it so it's white.

00:11:32.200 --> 00:11:36.379
And traditionally, you might have done this
by using, giving it an attributed string,

00:11:36.379 --> 00:11:40.689
so you might have a foreground color in
the attributed string to make it white.

00:11:40.690 --> 00:11:42.840
Background styles are a better way to do this

00:11:42.840 --> 00:11:47.399
because they will apply the right effects,
even though we might change the effects.

00:11:47.399 --> 00:11:51.419
It'll make your application consistent
with any changes we make in the future.

00:11:53.179 --> 00:11:55.000
So how does track ball use background styles?

00:11:55.000 --> 00:12:01.620
Well as you saw, it draws these cells that don't really have
a bevel, they had a slight bevel, but not really enough.

00:12:01.620 --> 00:12:09.080
So our track ball needs to be told the background style
it's drawing on and to do that, we're just going to define.

00:12:09.080 --> 00:12:12.240
You can see this in the sample
code as set background style method

00:12:12.240 --> 00:12:15.810
and all that does is turn around and call it on the cell.

00:12:15.809 --> 00:12:21.879
So now for each of our images, I just sort of
looked at the image and said, this image looks dark,

00:12:21.879 --> 00:12:24.370
this image looks light and I set
the background style accordingly.

00:12:24.370 --> 00:12:31.269
As you can see in these screen shots here, the text fields
draw differently depending on whether the image is dark

00:12:31.269 --> 00:12:34.990
or light and it makes, it makes it
look nice or it makes it more legible.

00:12:34.990 --> 00:12:40.220
All right, that's all I'm going to say about background styles

00:12:40.220 --> 00:12:43.139
Let's talk about the different
appearances your control will have.

00:12:43.139 --> 00:12:46.939
The different states it can be in.

00:12:46.940 --> 00:12:52.230
And controls of course, draw these different states
depending on the context and the point is to convey

00:12:52.230 --> 00:12:59.620
to the user what will happen if the user releases the
mouse button or types a character or clicks on it.

00:12:59.620 --> 00:13:02.350
And there's a lot of different appearances.

00:13:02.350 --> 00:13:06.350
Maybe more than you realize that are built
into the standard control, so here they are.

00:13:06.350 --> 00:13:07.610
Here's some of them.

00:13:07.610 --> 00:13:12.750
I've divided them into positive appearances which
convey something active, it conveys something ready

00:13:12.750 --> 00:13:15.590
about the control, it's going to respond.

00:13:15.590 --> 00:13:19.440
And negative appearances which convey
something, the control's inactive,

00:13:19.440 --> 00:13:24.930
the control's disabled, it's not ready to be used right now.

00:13:24.929 --> 00:13:30.009
So how do you draw these different appearances
and when do you know which appearance to use?

00:13:30.009 --> 00:13:32.629
Well let's go through them.

00:13:32.629 --> 00:13:37.470
First appearance is active and active is
what we call sort of the default look.

00:13:37.470 --> 00:13:42.460
In user controls and in front window, you
can interact with it, it's not disabled.

00:13:44.179 --> 00:13:49.209
This is the look you use when no other look applies.

00:13:51.960 --> 00:13:54.560
And the next state is pressed.

00:13:54.559 --> 00:14:02.639
And pressed means that it typically darkens the cell or
the control and it means that it is tracking the mass.

00:14:02.639 --> 00:14:08.370
So for example, like I mentioned, all
controls track until you let go of the mouse

00:14:08.370 --> 00:14:14.299
and this may not be immediately obvious so if you click on
a button, hold the mouse down and move the cursor outside

00:14:14.299 --> 00:14:19.769
of the button, the button stops it from drawing press, but
it's still tracking the mouse and the way you know that is

00:14:19.769 --> 00:14:23.360
because you can't interact with
any other control in the window.

00:14:23.360 --> 00:14:30.360
So tracking is modal in that sense and all
controls track until you let go of the mouse.

00:14:30.360 --> 00:14:35.389
Some controls, when they're tracking the mouse, only
draw press when the mouse is inside, like the button

00:14:35.389 --> 00:14:39.319
and some draw press even though the
mouse leaves the bounds of the control.

00:14:39.320 --> 00:14:42.080
For example a slider.

00:14:42.080 --> 00:14:43.810
What does this mean?

00:14:43.809 --> 00:14:49.049
Well this is really answering the question, can
the action be triggered from outside the control.

00:14:49.049 --> 00:14:55.459
So with a slider, if you click and press on the slider,
move the mouse outside, you can still manipulate the slider,

00:14:55.460 --> 00:14:59.560
but with the button, you click and hold
on the button, you move the mouse outside,

00:14:59.559 --> 00:15:03.019
you let go of the button, it is not going to activate.

00:15:03.019 --> 00:15:05.269
All right.

00:15:06.549 --> 00:15:10.519
So buttons, the answer is no the action
cannot be triggered from outside.

00:15:10.519 --> 00:15:12.990
Sliders, the answer is yes.

00:15:12.990 --> 00:15:14.529
So you should ask yourself this question.

00:15:14.529 --> 00:15:18.240
Can the action be triggered outside
the control for your control?

00:15:18.240 --> 00:15:19.690
And for track ball we're going to say yes.

00:15:19.690 --> 00:15:24.280
The reason for that is because it feels more natural
to be able to move the mouse outside and then rotate it

00:15:24.279 --> 00:15:28.049
around to do a barrel roll or other types of maneuvers.

00:15:29.659 --> 00:15:33.100
So how do we get this behavior?

00:15:33.100 --> 00:15:38.629
How do we indicate to the control, whether we want
it to continue tracking or to continue drawing press?

00:15:38.629 --> 00:15:40.559
Well NS control will track the mouse for you.

00:15:40.559 --> 00:15:42.319
How does it track the mouse?

00:15:42.320 --> 00:15:49.260
Well inside NS control's mouse down event, it's going to
ask the class of it's cell, another reason why we have

00:15:49.259 --> 00:15:54.549
to have a cell, we want to have a cell, whether
it prefers tracking until mouse up and this is,

00:15:54.549 --> 00:15:57.309
this method really means do you
want to continue drawing press,

00:15:57.309 --> 00:15:59.459
even though the mouse has left the bounds of your control.

00:15:59.460 --> 00:16:07.930
It will pass it's value to the
track mouse method of the cell.

00:16:07.929 --> 00:16:14.469
The cell, when it receives it, so in order
to get this behavior, to continue tracking,

00:16:14.470 --> 00:16:19.440
you have to return yes from prefers tracking
until mouse up and you act like NS slider.

00:16:19.440 --> 00:16:26.790
But the default is no in NS control, yet most of
our controls actually override it to return yes.

00:16:26.789 --> 00:16:29.559
No that's not right, it's something else.

00:16:30.940 --> 00:16:36.270
So this is the only case where we have to
actually sub class NS cell to get this behavior.

00:16:36.269 --> 00:16:37.329
We don't do this in track ball.

00:16:37.330 --> 00:16:43.290
We use a different mechanism, but this is how you would
do it if you were to use a cell for most of your behavior.

00:16:43.289 --> 00:16:48.069
You would override, prefers tracking
until mouse up in a sub class of NS cell

00:16:48.070 --> 00:16:54.250
and then you would make that class the cell of your control.

00:16:54.250 --> 00:16:58.440
So you made this decision, how do you know
whether you should actually draw press,

00:16:58.440 --> 00:16:59.580
whether you're tracking the mouse?

00:16:59.580 --> 00:17:00.910
That's easy.

00:17:00.909 --> 00:17:06.839
You ask the cell if it's highlighted and if
it is highlighted, you know to draw pressed.

00:17:06.839 --> 00:17:13.839
Highlighted is a term which means
pressed in the context of NS cell.

00:17:13.839 --> 00:17:18.399
Another mechanism to do this is to just
sort of do it yourself inside mouse drag.

00:17:18.400 --> 00:17:23.940
So track ball doesn't have a separate pressed appearance,
but it can track the mouse inside mouse dragged,

00:17:23.940 --> 00:17:33.789
which is of course, an event handler on NS control and the
way you would accomplish this is you would get the location

00:17:33.789 --> 00:17:38.659
of the event in window coordinates, convert it to
local coordinates, convert it to local coordinates,

00:17:38.660 --> 00:17:41.140
the coordinates base of your control and determine

00:17:41.140 --> 00:17:45.170
if the mouse is inside the region you're
tracking by calling NS point in recs.

00:17:45.170 --> 00:17:50.140
So this is another mechanism to do mouse
tracking and it's the one the track ball uses.

00:17:52.730 --> 00:17:59.390
All right, another state that you might have is
on or on in pressed for example, a check box.

00:17:59.390 --> 00:18:03.500
When you click the check box, it draws
a check mark and that's it's on state.

00:18:03.500 --> 00:18:10.150
If you click the mouse while it's checked, it will draw
everything darker and that's the on and pressed state.

00:18:10.150 --> 00:18:16.390
Not all controls have this of course, most for
example, known as button typically doesn't.

00:18:16.390 --> 00:18:22.420
Cell has some support for state but, frankly
I think it's just as easy to do it yourself.

00:18:22.420 --> 00:18:27.800
So store the state in an instance variable and when you
get a mouse down method, you can intrement the state

00:18:27.799 --> 00:18:34.369
and tell yourself to redraw and I don't think
that's any more difficult than using NS cell.

00:18:36.410 --> 00:18:43.440
So the inactive state is for when a control is in
a background window and not all controls have this.

00:18:43.440 --> 00:18:50.070
If they do, it's usually subtle for an aqua control like
this pop up button, it will lose the aqua appearance.

00:18:50.069 --> 00:18:51.529
It will just draw gray.

00:18:51.529 --> 00:18:57.170
The sort of metal button here will draw
slightly less texture, there we go.

00:18:58.700 --> 00:19:04.850
You can determine if you're in an inactive window
by asking if your window is the key window.

00:19:04.849 --> 00:19:11.929
You could also ask if your window is, if your
window equals the key window of the application.

00:19:11.930 --> 00:19:15.240
So you could call is key window or
compare it to the applications key window.

00:19:15.240 --> 00:19:19.259
You'd think these might be the same, but they're often not.

00:19:19.259 --> 00:19:22.470
An example when they're not is in a drawer of a window.

00:19:22.470 --> 00:19:28.259
In that case, the application has a key window
which is the main, the window containing the drawer,

00:19:28.259 --> 00:19:31.359
but there may be multiple windows
that respond yes from is key window.

00:19:31.359 --> 00:19:35.509
So this is the right way to do it.

00:19:35.509 --> 00:19:41.950
And then there's the disabled state which is when
you draw faded and you don't respond to events.

00:19:41.950 --> 00:19:45.130
NS controls has this is enabled method.

00:19:45.130 --> 00:19:48.850
This is not something you need to use a cell for of course.

00:19:48.849 --> 00:19:54.599
You do not even need to have give the
control a cell to use the enabled state.

00:19:54.599 --> 00:19:57.719
But NS cell can help you draw things in a disable manner.

00:19:57.720 --> 00:20:06.870
So if you have say a string, cowabunga, it draws like
this, you'd tell the cell hey I want you to be disabled,

00:20:06.869 --> 00:20:11.989
so disabled yes, it will draw it with a gray look
instead of black and this works for images too.

00:20:11.990 --> 00:20:18.769
So here we have a picture of the American flag and we
call set disabled yes and it will draw it with less color.

00:20:18.769 --> 00:20:24.529
So this is an easy way to get a disabled state and this
is another reason why NS cell is a good choice to use

00:20:24.529 --> 00:20:31.259
for drawing text and images inside your control as
compared to string drawing primitives or NS image.

00:20:32.700 --> 00:20:36.670
There's two more appearances I want to talk
about that don't really fit in anywhere.

00:20:36.670 --> 00:20:44.940
There's this notion of roll over and this isn't something
we encourage right, if every control had a roll over,

00:20:44.940 --> 00:20:50.240
it would be very distracting to be moving the mouse
around the screen for every control to be you know,

00:20:50.240 --> 00:20:53.359
doing something every time you enter or leave it's rect.

00:20:53.359 --> 00:20:55.349
So if you do use this, use it sparingly.

00:20:55.349 --> 00:21:01.169
An easy way to get a roll over effect is the
set shows border only when mouse inside method.

00:21:01.170 --> 00:21:03.880
This is how for example, safari's bookmarks bar does it.

00:21:03.880 --> 00:21:09.190
You move over a bookmark in the bookmarks bar
and it will invert the text and draw a bevel

00:21:09.190 --> 00:21:15.759
and it does this very easily with one line of code
with the set shows border only while mouse inside.

00:21:15.759 --> 00:21:21.650
But if you wanted to do a different roll over effect,
this hasn't been something that's been easy in the past,

00:21:21.650 --> 00:21:25.700
good news is it's much easier in Leopard
with the new tracking area class.

00:21:25.700 --> 00:21:27.769
So how would you do that?

00:21:29.690 --> 00:21:32.670
Well a tracking area is a replacement for tracking recs

00:21:32.670 --> 00:21:38.019
and the way you create one is you
initialize it and you pass it some options.

00:21:38.019 --> 00:21:43.299
In this case, we're passing it the mouse entered and
exited option, which indicates that we want to get notified

00:21:43.299 --> 00:21:46.589
when the mouse leaves and enters our
bounds, as opposed to for example,

00:21:46.589 --> 00:21:50.009
getting notified every time the mouse moves within our recs.

00:21:50.009 --> 00:21:54.869
And we're passing of the NS tracking invisible
rect and that is within the visible region,

00:21:54.869 --> 00:21:58.029
not as in it is invisible and you can't see it.

00:21:58.029 --> 00:22:04.289
Because we're passing the invisible, the within visible
rect flag, we can pass zero rect as the rectangle

00:22:04.289 --> 00:22:07.200
for the tracking area that will be ignored.

00:22:07.200 --> 00:22:12.299
It will always use the visible rect of your control,
no matter how your control changes it's frame.

00:22:12.299 --> 00:22:14.009
So this is very convenient.

00:22:14.009 --> 00:22:17.740
Then you add it as a tracking area of your view.

00:22:17.740 --> 00:22:24.509
When you get a mouse entered event, if a tracking
area of the event is the tracking area you added,

00:22:24.509 --> 00:22:29.190
which you stored in an instance variable, then
you indicate, you set the shows roll over flag yes

00:22:29.190 --> 00:22:32.950
and you tell yourself to read display
and similarly for mouse exited,

00:22:32.950 --> 00:22:37.580
if the tracking area is the tracking area
you added, you say I'm not showing roll

00:22:37.579 --> 00:22:40.559
over anymore and you tell yourself to read display.

00:22:40.559 --> 00:22:45.450
So this is a state you want to track manually.

00:22:45.450 --> 00:22:53.120
And lastly, there is focus rings and of course, the focus
ring is the familiar blue highlight around a control

00:22:53.119 --> 00:22:56.679
and it's very easy to determine
if your control has the focus.

00:22:56.680 --> 00:23:03.240
You ask the key window of NS application, you get
it's first responder and if that is your control,

00:23:03.240 --> 00:23:06.220
then you know you have the keyboard
focus and you should indicate

00:23:06.220 --> 00:23:10.470
that in some way, particularly with the blue highlight.

00:23:10.470 --> 00:23:18.940
So the way you draw the blue highlight is by saving the
graphic state and calling the NS set focus ring style method

00:23:18.940 --> 00:23:24.539
and this means that all subsequent drawing
will have the draw the focus ring around it.

00:23:24.539 --> 00:23:27.500
Now the slides are a little misleading here.

00:23:27.500 --> 00:23:31.069
Focus ring only indicates that all other drawing is blocked.

00:23:31.069 --> 00:23:32.599
So it only draws the focus ring.

00:23:32.599 --> 00:23:38.299
It does not draw other content that you tell
it to draw while has this focus ring style.

00:23:38.299 --> 00:23:40.859
If you pass the focus ring above, then it will draw both.

00:23:40.859 --> 00:23:45.729
And this is true, even if what you drew is not visible.

00:23:45.730 --> 00:23:51.019
So the way we can get a focus ring in track ball of
course, QC view doesn't have any way of doing this easily

00:23:51.019 --> 00:23:56.730
and our track ball is not a rectangle, it is a sphere.

00:23:56.730 --> 00:24:01.860
So we're just going to take the track ball,
we'll just draw a clear circle around it,

00:24:01.859 --> 00:24:04.919
with the focus ring style it will
draw the blue focus ring for us.

00:24:04.920 --> 00:24:13.600
Of course, this clear sphere does not show up and
we're left with the focus ring around the track ball.

00:24:13.599 --> 00:24:16.539
Now I think there's some confusion
about the way focus rings work.

00:24:16.539 --> 00:24:22.539
I think people have this notion sometimes that it's
floating over the window in a separate layer, but it's not.

00:24:22.539 --> 00:24:28.599
It is ordinary pixels in the same backing
store as every other view draws into.

00:24:28.599 --> 00:24:30.889
The only difference is it's not clicked.

00:24:30.890 --> 00:24:33.940
This means that it can draw outside
the bounds of your control.

00:24:33.940 --> 00:24:39.100
Perhaps you've seen a case where one of your controls, you
tap outside of it, there is a bit of focus ring left over,

00:24:39.099 --> 00:24:42.779
that because only the bounds of your control were redrawn.

00:24:42.779 --> 00:24:48.129
This means you have to take care to invalidate the proper
region of the window, every time you gain or lose focus,

00:24:48.130 --> 00:24:52.130
which corresponds to become a resigned
first responder methods.

00:24:52.130 --> 00:24:59.960
So for example, in become first responder, if you can
become first responder, you call through to super,

00:24:59.960 --> 00:25:05.860
then you indicate that the focus ring region should be
redrawn with set keyboard focus ring needs display in rect

00:25:05.859 --> 00:25:09.769
and this will invalidate a bit more of
the window than your control takes up.

00:25:09.769 --> 00:25:18.259
Invalidates just enough so that any focus ring you draw
will be repainted and this is not something you have to do

00:25:18.259 --> 00:25:21.420
with every control, this is only for
controls that do something custom

00:25:21.420 --> 00:25:25.980
with the focus ring like we saw with track ball.

00:25:25.980 --> 00:25:32.170
So here's sort of a summary of the float control you
might use for drawing, deciding which appearance to use.

00:25:32.170 --> 00:25:38.250
If your control is a first responder,
then you will need to draw the focus ring.

00:25:38.250 --> 00:25:42.309
So you save the graphic state and
call this set focus ring style.

00:25:42.309 --> 00:25:44.929
If your control is not enabled, you'll draw disabled.

00:25:44.930 --> 00:25:48.880
Otherwise if it's highlighted, you draw pressed.

00:25:48.880 --> 00:25:52.660
Otherwise if it's in a background
window, you draw inactive and by default.

00:25:52.660 --> 00:25:56.490
If no other state applies, you can draw active

00:25:56.490 --> 00:26:00.730
And remember to restore the graphic
state if you set the focus ring style.

00:26:02.640 --> 00:26:06.310
Okay, that summarizes the different
appearances you might have for your control.

00:26:06.309 --> 00:26:09.649
Let's talk about different behaviors
you have as options for your control.

00:26:09.650 --> 00:26:12.660
Different choices you have to make
about how your control behaves.

00:26:12.660 --> 00:26:14.759
And there's four that we're going to talk about.

00:26:14.759 --> 00:26:22.349
There's click through behavior, this notion of
continuous controls, keyboard navigation and validation.

00:26:22.349 --> 00:26:27.399
So click through of course, is whether a mouse click
in an inactive window should not only bring the window

00:26:27.400 --> 00:26:30.480
to the front, but also cause the
control to fire into action.

00:26:30.480 --> 00:26:36.309
And this is unusual because it depends not just on
the type of control, but on what the control does.

00:26:36.309 --> 00:26:40.980
So for example in Mail, we have two
buttons, a new message and the to do button

00:26:40.980 --> 00:26:46.950
and the to button does not have click
through and the new message does.

00:26:46.950 --> 00:26:49.309
Now why do we make this, how do you make this choice?

00:26:49.309 --> 00:26:55.619
Well it was talked about in the human interface guidelines,
but to summarize, click through should be off for actions

00:26:55.619 --> 00:27:00.149
that are destructive like erasing a file
or actions that can't be easily undone

00:27:00.150 --> 00:27:04.350
like sending an email or actions that destroys your context.

00:27:04.349 --> 00:27:10.129
In the case of Mail, clicking the to do button does not send
an email, but it does take you to a different part of Mail,

00:27:10.130 --> 00:27:13.020
where it lets you do edit this new to do.

00:27:13.019 --> 00:27:16.809
So in that sense, it destroys your context
and that's why click through is off.

00:27:16.809 --> 00:27:21.329
The new message brings up a new window, but
it doesn't do anything to the old window.

00:27:21.329 --> 00:27:23.129
It doesn't take you out of your context.

00:27:23.130 --> 00:27:27.000
That's okay to have click through.

00:27:27.000 --> 00:27:33.339
Now click through is off by default and that is
controlled but it is on in most NS control sub classes.

00:27:34.480 --> 00:27:39.519
So if you want click through to be on and your sub
classing NS control, you do have to make ensure it's on,

00:27:39.519 --> 00:27:43.809
you have to do some work and track ball,
it's harmless to click on the track ball

00:27:43.809 --> 00:27:47.379
and maybe move it a few pixels, so we're going to turn it on.

00:27:47.380 --> 00:27:51.260
The way you do this is in your control
method to override accepts first mouse,

00:27:51.259 --> 00:27:54.500
your pass key event so you can
make a decision based on the event.

00:27:54.500 --> 00:27:56.539
We don't care about the event, you normally don't.

00:27:56.539 --> 00:27:58.450
We'll just return yes.

00:28:05.349 --> 00:28:10.639
So controls have this notion of a continuous action,
which of course indicates that the control should continue

00:28:10.640 --> 00:28:15.660
to fire the action while the user is using the
control instead of just firing it at the end

00:28:15.660 --> 00:28:21.029
and you make a control continuous by
calling the set continuous on it of course.

00:28:22.700 --> 00:28:27.840
And examples of continuous controls are a
slider or a search field or a track ball,

00:28:27.839 --> 00:28:31.740
right a search field as you type
it will filter as you, as you go.

00:28:31.740 --> 00:28:35.359
You don't have to wait, you know hit
return at the end to make it filter.

00:28:35.359 --> 00:28:38.939
But this also might depend on the action of the control.

00:28:38.940 --> 00:28:39.640
Like click through.

00:28:39.640 --> 00:28:45.180
For example, a volume slider can be easily continuous
so you can hear the change in volume as you drag it.

00:28:45.180 --> 00:28:48.900
But a screen resolution slider, well it's very
expensive to change the screen resolution.

00:28:48.900 --> 00:28:49.920
It's distracting.

00:28:49.920 --> 00:28:52.710
You only want to do that at the end when the user lets go.

00:28:52.710 --> 00:28:58.069
So a screen resolution slider would not be continuous.

00:28:59.140 --> 00:29:02.440
Now continuous is free with NS cell's track mouse.

00:29:02.440 --> 00:29:08.210
So you call set continuous yes and
your control will do the right thing.

00:29:08.210 --> 00:29:13.620
But I really meant action cell because, only
action cell has target and action of course.

00:29:13.619 --> 00:29:16.039
How does NS control use this flag?

00:29:16.039 --> 00:29:22.059
Well we'll call up the first track until
mouse up, we'll pass that to the cell.

00:29:22.059 --> 00:29:27.529
The cell within it's track mouse method,

00:29:27.529 --> 00:29:33.119
will send the action repeatedly during
mouse tracking and again at the end.

00:29:33.119 --> 00:29:39.289
If it's not continuous, it'll only send it at the end.

00:29:39.289 --> 00:29:43.879
Now if you use mouse dragged like our
track ball does, it's much easier.

00:29:43.880 --> 00:29:50.890
You can just send the action yourself within the mouse drag
method and that's another way to accomplish the same thing.

00:29:50.890 --> 00:29:56.670
I just wanted to give you an understanding of the way NS
control and NS cell interact for making continuous actions.

00:29:58.279 --> 00:29:59.559
All right.

00:29:59.559 --> 00:30:00.679
Keyboard navigation.

00:30:00.680 --> 00:30:06.720
So ideally if you're a control, the keyboard should
be all that's necessary to get anything done.

00:30:06.720 --> 00:30:08.500
And the reason for that is accessibility.

00:30:08.500 --> 00:30:12.730
Users with motor skills disabilities, may have
trouble using the mouse or a pointing device,

00:30:12.730 --> 00:30:20.660
but if they can use the keyboard and your control supports
the keyboard entirely, then they can use your control fully.

00:30:23.039 --> 00:30:28.329
Now of course, Cocoa does the key view loop for you so
you can tab between controls, but it might have a case

00:30:28.329 --> 00:30:32.990
of one control that has sort of
sub components that can gain focus.

00:30:32.990 --> 00:30:36.220
For example a tool bar, a tool
bar can do that or an NS tab view.

00:30:36.220 --> 00:30:39.670
You can focus on each of the tabs even
though they're part of the same control.

00:30:39.670 --> 00:30:40.660
We saw that with track ball.

00:30:40.660 --> 00:30:42.450
You can tab to the various fields at the bottom.

00:30:42.450 --> 00:30:49.039
Now the human interface guidelines say
that navigation occurs between controls

00:30:49.039 --> 00:30:51.849
with the tab, but within controls with the arrow keys.

00:30:51.849 --> 00:30:54.879
But of course, control here is as the users see it.

00:30:54.880 --> 00:31:01.280
So track ball, the user sees multiple controls,
there's really one so we will use the tab,

00:31:01.279 --> 00:31:03.960
because it appears to be multiple controls.

00:31:06.319 --> 00:31:12.710
So tab view and segmented control are example of
where you use arrow keys to navigate within it

00:31:12.710 --> 00:31:19.710
and to accomplish this you can override move right and
move left and these are methods that are called on you

00:31:19.710 --> 00:31:27.210
from NS window, when NS window receives key down event
and as window performs it's mapping of keys to selectors

00:31:27.210 --> 00:31:33.079
and this is the Cocoa key binding's architecture, so
you can, the user can configure different arrow keys

00:31:33.079 --> 00:31:36.419
or different keys entirely to correspond
to move right or move left.

00:31:36.420 --> 00:31:39.310
Which is very convenient.

00:31:39.309 --> 00:31:45.919
Between controls, date picker is an example of one
control which has multiple apparent controls right.

00:31:45.920 --> 00:31:53.730
You can tab to the date picker and also to
the up and down arrows on the right of side

00:31:53.730 --> 00:31:55.930
of it which controls in committing the date.

00:31:55.930 --> 00:32:01.690
And table view is another example
of control that lets you navigate

00:32:01.690 --> 00:32:04.930
within the control view of the
tab key and track ball as well.

00:32:04.930 --> 00:32:09.799
And of course, with track ball, we already use the
arrow keys for manipulating the rotation so it's very,

00:32:09.799 --> 00:32:16.250
it makes sense to use the arrow key, the tab
key for moving the focus within the control.

00:32:18.220 --> 00:32:24.390
So the easiest way to get this sort of tracking
or excuse me, keyboard focus within the control,

00:32:24.390 --> 00:32:30.420
is to just have an instance variable which tracks
which part of the control has the keyboard focus.

00:32:32.029 --> 00:32:33.960
We just use an enum in track ball.

00:32:33.960 --> 00:32:38.380
We have the focus can be on the track ball
itself or on any of the three fields and we store

00:32:38.380 --> 00:32:41.880
that as an instance variable within the track ball.

00:32:41.880 --> 00:32:45.820
We also define some convenient, you know, we're on the
last part, where on the first part which will tell us

00:32:45.819 --> 00:32:50.519
when to you know, call through to
super when we get the key down event.

00:32:50.519 --> 00:32:57.559
So then in key down, we'll check the character we were
passed and if it's the tab character and we're not already

00:32:57.559 --> 00:33:03.919
at the end, we're not focused on the last part, then we
will just increment our focus portion which is the enum

00:33:03.920 --> 00:33:09.440
and tell us to redisplay and then when we draw
again, we will draw the focus around the right part

00:33:09.440 --> 00:33:15.580
and if we get the back tab character which corresponds with
shift tab and we're not at the beginning of the focuses part

00:33:15.579 --> 00:33:21.579
of our control, we will decrement the focus part and then
tell us to redisplay and if we are at the beginning or end

00:33:21.579 --> 00:33:29.829
or if it's a different key, we will call through to super.

00:33:29.829 --> 00:33:36.679
Now the only reason we overrode key down, this is the
tabbing, you do not have to override key down just

00:33:36.680 --> 00:33:40.740
to participate in the key view
loop that Cocoa gives you for free.

00:33:45.190 --> 00:33:46.580
All right, validation.

00:33:46.579 --> 00:33:51.879
So the user enters pizza like I entered in
a text field, which is just for numbers,

00:33:51.880 --> 00:33:55.480
how do we prevent the user from committing this data?

00:33:55.480 --> 00:34:03.160
Well we do that by overriding text should end editing and
in this case, we will call through to is entry acceptable

00:34:03.160 --> 00:34:10.760
which is the formatter of our cell, to
determine if the user string matches the format.

00:34:10.760 --> 00:34:16.590
And if it does not, it returns no and we are
not allowed to end editing the text field.

00:34:16.590 --> 00:34:24.300
So this brings us to right, you can also do other
custom work of course and this text should end editing.

00:34:25.510 --> 00:34:31.390
And this brings us to text editing and
text editing is sort of an in depth topic.

00:34:31.389 --> 00:34:35.909
There's a lot of messages that are
flying back and forth but NS cell again,

00:34:35.909 --> 00:34:39.989
makes it pretty easy to edit text fields and we'll see how.

00:34:39.989 --> 00:34:41.879
So how does text editing work?

00:34:41.880 --> 00:34:46.860
Well you'll have your control and your control has a
cell that you can use for editing and this does not have

00:34:46.860 --> 00:34:50.750
to be the cell of your control, it could be an
arbitrary cell and in the case of track ball,

00:34:50.750 --> 00:34:54.980
we have a cell we allocate just for
the purpose of editing text fields.

00:34:54.980 --> 00:34:56.360
So this is arbitrary NS cell.

00:34:56.360 --> 00:35:02.980
And the control will call edit with
frame or select with frame on the cell.

00:35:02.980 --> 00:35:03.929
Okay, what happens next?

00:35:03.929 --> 00:35:05.750
This is how you begin editing.

00:35:05.750 --> 00:35:11.900
Well the cell is going to call out to
the window of the control and say hey,

00:35:11.900 --> 00:35:15.150
I need the field editor and will pass yes for create.

00:35:15.150 --> 00:35:17.840
So the field editor will be created if it doesn't exist.

00:35:17.840 --> 00:35:23.480
Well the window then is going to allocate the field
editor and the field editor is just an NS text view.

00:35:23.480 --> 00:35:26.969
It's not a special class, sub class of NS text view,

00:35:26.969 --> 00:35:32.709
but it is configured with set field editor
yes, which changes some of it's behavior.

00:35:32.710 --> 00:35:37.610
The text view will set your control
as the delegate of the text view

00:35:37.610 --> 00:35:41.769
and it will add itself as a sub view of your control.

00:35:43.190 --> 00:35:50.309
So now the text view is a sub view of your control
and it's editing you and editing will continue

00:35:50.309 --> 00:35:55.239
until the field editor is done and the field editor
will be done maybe if the user tabs out of the control

00:35:55.239 --> 00:36:00.099
or the user hits return or loses
first responder in some other way.

00:36:00.099 --> 00:36:01.219
For example, you close the window.

00:36:01.219 --> 00:36:09.449
And if text should end editing returns yes, which is the
method we overrode, then it calls this on your control

00:36:09.449 --> 00:36:15.750
or on the delegate whatever you passed, then it
will call text did end editing and this is your cue

00:36:15.750 --> 00:36:22.230
to fire your target in action and to call end
editing on the cell you began editing with.

00:36:22.230 --> 00:36:30.449
So your text at end editing is called on the control
by the field editor and we call end editing on the cell

00:36:30.449 --> 00:36:37.089
and this tells the cell to remove the field editor as a
sub view of your control and the editing session is done.

00:36:37.090 --> 00:36:41.410
So you set the target action, you've updated
your object value and we're done editing.

00:36:42.869 --> 00:36:47.449
So let's look at how track ball uses
text editing for the mouse down event.

00:36:47.449 --> 00:36:54.099
If the mouse down is within the label region, the bottom
portion of our control, then we want to begin editing.

00:36:54.099 --> 00:37:01.630
We will get the field editor, we will set our
editing cell to have the value representative

00:37:01.630 --> 00:37:04.450
of whatever text field the user clicked on.

00:37:04.449 --> 00:37:09.599
So if the user clicked on the Y portion, that
is the Y angle, we will set the editing cell

00:37:09.599 --> 00:37:12.599
to have whatever value the Y rotation is.

00:37:12.599 --> 00:37:16.449
And then we'll call the select with frame method.

00:37:16.449 --> 00:37:20.909
We'll pass in view cell, so editing is
happening within our control and we'll pass self

00:37:20.909 --> 00:37:25.219
as a delegate so that we get these call backs.

00:37:25.219 --> 00:37:29.000
And the difference between select with frame
and edit with frame of course is that edit

00:37:29.000 --> 00:37:34.440
with frame will just begin editing I think with
cursor appear to the end, but with select with frame,

00:37:34.440 --> 00:37:40.769
you have control over what portion is initially selected
and we want to have the entire text initially selected

00:37:40.769 --> 00:37:46.210
so we pass the start of zero to indicate the beginning
and the length of whatever the string value's length is.

00:37:46.210 --> 00:37:48.340
So we select the entire region.

00:37:48.340 --> 00:37:56.460
Now in our text should end editing method as discussed
earlier, we call through to the is entry acceptable method

00:37:56.460 --> 00:38:01.720
which uses the formatter and if
the text did end editing method,

00:38:01.719 --> 00:38:05.719
this is when we need to update our object
value and fire our target in action.

00:38:05.719 --> 00:38:12.069
And also to call end editing on the
cell that we began editing with.

00:38:14.920 --> 00:38:17.309
So that's the summary of text editing.

00:38:17.309 --> 00:38:20.650
Let's move on to accessibility.

00:38:20.650 --> 00:38:24.690
And accessibility of course is another topic
where you can have multiple sessions on it,

00:38:24.690 --> 00:38:30.679
so I'll try to give you three rules to remember and the
first rule is that accessibility is not, it's not frosting.

00:38:30.679 --> 00:38:35.599
It's not just bonus for your control, it's rather
fundamental to your control and you should not treat it

00:38:35.599 --> 00:38:40.389
as something to add on sort of at the end.

00:38:40.389 --> 00:38:40.900
Why is that?

00:38:40.900 --> 00:38:47.710
Well of course it's very important to make the control
accessible to user with both visual disabilities

00:38:47.710 --> 00:38:52.829
or motor disabilities, but it's also for tool support.

00:38:52.829 --> 00:38:58.440
An example of a tool, this is new in Leopard which
depends on accessibility, is watch me do an automator.

00:38:58.440 --> 00:39:07.059
So if your control is accessible, it makes it more useful
not only to disabled users, but users without disabilities.

00:39:07.059 --> 00:39:11.340
So that's why accessibility is important.

00:39:11.340 --> 00:39:15.860
The second rule is to think carefully
about the role of your control.

00:39:15.860 --> 00:39:21.660
The role is the face of your control to users who are
depending on accessibility and I think there's a tension

00:39:21.659 --> 00:39:25.519
when deciding on a role, oh you have to
stick to the framework supplied in constant.

00:39:25.519 --> 00:39:33.099
You can return your own arbitrary role
because tools won't know what to do with it.

00:39:33.099 --> 00:39:39.210
And I think there's a tension between making your
role descriptive and making you role accurate.

00:39:39.210 --> 00:39:40.800
What do I mean?

00:39:40.800 --> 00:39:45.820
Well for example, let's say you had a light switch control
and you said hey, this light switch has got an on stage,

00:39:45.820 --> 00:39:48.620
it's got an off stage, this is kinda like the check box.

00:39:48.619 --> 00:39:53.359
So for my role I'm going to return
NS accessibility check box role.

00:39:53.360 --> 00:39:59.329
This may sound good at first, but imagine you had
two users using the computer and communicating

00:39:59.329 --> 00:40:04.250
and one of them is depending on accessibility,
one of them is sighted and looking at the screen.

00:40:04.250 --> 00:40:09.480
The first user might say hey, look at the check box, he
thinks it's a check box because of the check box role,

00:40:09.480 --> 00:40:15.599
the sighted user's not going to see the check box,
all the sighted user sees is the light switch.

00:40:15.599 --> 00:40:21.190
So a better choice for the role for the
light switch is the value indicator role.

00:40:21.190 --> 00:40:28.389
It's not quite as descriptive, but it is more accurate
and I think that is a better fit on the spectrum there.

00:40:31.099 --> 00:40:33.179
So what role do we choose for our track ball?

00:40:33.179 --> 00:40:36.000
And this is, this is rather challenging, believe me.

00:40:36.000 --> 00:40:41.880
Our track ball is, oh it's the rules so think carefully
about your controls rule, make sure it's descriptive

00:40:41.880 --> 00:40:50.809
and accurate and for the track ball, it's like a slider
but, most sliders have an orientation of either horizontal

00:40:50.809 --> 00:40:56.840
or vertical and one way we can indicate that this isn't
an ordinary slider is by returning an unknown orientation

00:40:56.840 --> 00:40:59.620
which is another constant you can return.

00:41:01.130 --> 00:41:08.550
Now how do we represent the axis of
rotation that the track ball shows.

00:41:08.550 --> 00:41:12.900
Well we're going to give it three children, so
in the accessibility inspector for example,

00:41:12.900 --> 00:41:18.559
the track ball will have three children who's
descriptions are the X rotation, Y rotation and Z rotation

00:41:18.559 --> 00:41:24.029
and these are value indicators indicating
the rotation around these different axis.

00:41:25.530 --> 00:41:31.600
And the third rule for accessibility is ideally,
everything your control can do needs to be exposed

00:41:31.599 --> 00:41:37.599
through accessibility and this includes information about
the control state and any properties that are settable

00:41:37.599 --> 00:41:44.920
and of course, any actions and your control also needs
to send out notifications when the value changes.

00:41:46.659 --> 00:41:50.809
So in track ball, we have the accessibility hierarchy.

00:41:50.809 --> 00:41:55.159
We actually have nine children of the track ball.

00:41:56.360 --> 00:42:00.690
Right, so it's the slider, it's got the unknown
orientation, it's got the three ordinary children,

00:42:00.690 --> 00:42:07.750
but we also want to expose the text
fields as children as well.

00:42:07.750 --> 00:42:14.539
So the X or the Y or the Z, the sort of static text
labels to be exposed as static text role objects

00:42:14.539 --> 00:42:21.429
and the angles themselves will be text field role
and these will be writable so that the accessibility,

00:42:21.429 --> 00:42:25.369
someone can modify their value, just
the way we like when we typed in a value

00:42:25.369 --> 00:42:28.369
and we saw the control rotate to the final value.

00:42:29.980 --> 00:42:38.570
And to set up the relationships properly, we will set the
static text as the title UI element of the angle itself.

00:42:38.570 --> 00:42:42.559
Because it represents the label for that angle.

00:42:42.559 --> 00:42:44.519
So we have nine children as I mentioned.

00:42:44.519 --> 00:42:48.900
We have one child for each axis,
one child for each label text field,

00:42:48.900 --> 00:42:52.250
each static text field and one child for each angle.

00:42:54.309 --> 00:42:59.559
We accomplish this sort of, these fake children,
these children are not part of the NSU hierarchy,

00:42:59.559 --> 00:43:08.549
but they are part, they are part of the accessibility
hierarchy and we return what's called a faux UI element.

00:43:08.550 --> 00:43:14.269
This is not a class in the Cocoa frameworks, but it is a
class in the sample code, in the track ball sample code

00:43:14.269 --> 00:43:17.480
and another sample code that is very useful for setting

00:43:17.480 --> 00:43:21.990
up accessibility hierarchy's that
do not reflect the view hierarchy.

00:43:21.989 --> 00:43:25.589
All right, so the sample code.

00:43:27.090 --> 00:43:33.930
We also must ensure that we send out notifications
every time the object value changes or anything not just

00:43:33.929 --> 00:43:38.230
in set object value, but anytime
we change it in any other method.

00:43:38.230 --> 00:43:43.550
So we send out an accessibility
notification, not just for the angle,

00:43:43.550 --> 00:43:48.019
the axis element of the track ball,
but also for the text field.

00:43:48.019 --> 00:43:53.210
This way is someone is preserving the text field or the
angle, they'll get the right accessibility notifications.

00:43:56.960 --> 00:44:01.309
Right, to sum up our track ball's accessibility,
it does not match the view hierarchy

00:44:01.309 --> 00:44:06.000
and this is the more complex your control
is, the less likely your view hierarchy

00:44:06.000 --> 00:44:08.349
and accessibility hierarchy are going to match.

00:44:08.349 --> 00:44:12.789
So that's okay, this doesn't indicate
some sort of flaw in your design.

00:44:12.789 --> 00:44:18.139
You can get these phantom accessibility elements with the
faux UI elements class, which I encourage you to incorporate

00:44:18.139 --> 00:44:25.029
because there are some complications in terms
of is equal and hash, for faux UI elements.

00:44:25.030 --> 00:44:28.940
We have one per axis, one per text field and one per label.

00:44:28.940 --> 00:44:31.960
So there's a total of nine.

00:44:31.960 --> 00:44:37.050
And we have to ensure we send out the notifications
every time the track ball's object value changes.

00:44:37.050 --> 00:44:41.630
We have one for the text field and
one for each axis that changes.

00:44:41.630 --> 00:44:46.090
And with this accessibility design, I think we've reached
the goal of everything that the track ball can do.

00:44:46.090 --> 00:44:47.789
It can also be done with accessibility.

00:44:47.789 --> 00:44:54.329
The user can modify the view rotations via the text
fields or via the axis within the track ball itself.

00:44:54.329 --> 00:45:00.400
All right, so the three rules are all
right, accessibility is important.

00:45:00.400 --> 00:45:04.220
It's not gravy, this is something
which is fundamental to your control

00:45:04.219 --> 00:45:07.599
and fundamental to being a good citizen on Mac OS X.

00:45:07.599 --> 00:45:13.809
Think carefully about the controls accessibility
role attribute right, there's a tension between roles

00:45:13.809 --> 00:45:17.110
that are accurate and roles that are descriptive
and you want to strike the right balance

00:45:17.110 --> 00:45:20.710
so you're not misleading, but you give enough information.

00:45:20.710 --> 00:45:26.780
And ideally, everything a user can do with a mouse
or keyboard, should also be doable via accessibility.

00:45:26.780 --> 00:45:31.870
Either by the accessibility actions
or by writable properties.

00:45:33.980 --> 00:45:35.349
All right.

00:45:35.349 --> 00:45:37.130
Let's talk about bindings.

00:45:37.130 --> 00:45:39.500
Bindings is also an in depth subject.

00:45:39.500 --> 00:45:45.440
I'm just going to try to give you the enough
information to set up basic bindings on your control.

00:45:45.440 --> 00:45:47.070
News you can use.

00:45:47.070 --> 00:45:51.600
But for more, you can of course attend
a bindings session or the bindings lab

00:45:51.599 --> 00:45:57.569
and there is new bindings sample
code which I'll also get to.

00:45:57.570 --> 00:45:59.860
So how do Cocoa bindings work?

00:45:59.860 --> 00:46:05.380
Well you have your model object and you
have your control and you say bind right.

00:46:05.380 --> 00:46:09.420
So I'm going to bind my control to my model and what happens?

00:46:09.420 --> 00:46:18.050
Well the control is going to observe the model of the key
value observing and the model's going to observe the control.

00:46:18.050 --> 00:46:23.940
You might think that would make sense,
but that's not actually how it works.

00:46:23.940 --> 00:46:33.780
The control, the changes to the control are not pushed
to the model automatically and they're not pushed by KVO.

00:46:33.780 --> 00:46:40.840
Instead the control has to explicitly
set values on the model when it changes.

00:46:40.840 --> 00:46:48.420
Bindings are not symmetric, they are
asymmetric and setting these values

00:46:48.420 --> 00:46:52.780
from the control back to the model, is custom per class.

00:46:52.780 --> 00:46:56.810
Because the object value can change at any
time and it can be also fairly tricky to code.

00:46:56.809 --> 00:47:01.619
It can be tricky to get this right and we don't
have a great story about a way to do this right now.

00:47:01.619 --> 00:47:10.230
But the good news is, if your model is KVO and KVC
compliant, then the other direction comes for free,

00:47:10.230 --> 00:47:13.070
thanks to NS object's implementation of the blind method.

00:47:13.070 --> 00:47:21.950
So any change to your model will be pushed to your
control by the NS object's implementation of bind.

00:47:21.949 --> 00:47:28.539
So the upshot of this is if your control is only used
for displaying a value, it does not allow the user

00:47:28.539 --> 00:47:31.659
to modify the value, well then you're essentially done.

00:47:31.659 --> 00:47:36.319
All you have to do is ensure that
your model is KVC and KVO compliant

00:47:36.320 --> 00:47:41.390
and you will properly reflect changes
to the model into your view.

00:47:41.389 --> 00:47:46.069
Now you have to be prepared for the set
method of your control to be called.

00:47:46.070 --> 00:47:51.450
So if you bind the object value, then set object value
will be called on your control and you have to remember

00:47:51.449 --> 00:47:54.500
to mark the control as needing display when this happens.

00:47:54.500 --> 00:47:59.059
Otherwise changes will not cause your control to redisplay.

00:47:59.059 --> 00:48:09.619
Now if your view does change values, I recommend attending
the bindings lab or seeing the bindings electric sample code

00:48:09.619 --> 00:48:15.500
which is new and this bindings electric sample code
shows you how to push values from the view back

00:48:15.500 --> 00:48:18.539
to the model while taking into
account the different bindings option

00:48:18.539 --> 00:48:21.559
that we have and that's a good place to look.

00:48:21.559 --> 00:48:26.920
The topic is too in depth for this session.

00:48:26.920 --> 00:48:29.940
So that sums up bindings.

00:48:29.940 --> 00:48:32.260
Let's talk about some common pitfalls you might run into.

00:48:32.260 --> 00:48:35.620
What are some problems you might have
when you are designing your control.

00:48:35.619 --> 00:48:40.750
So let's say you make your control and you find out
that basic control methods don't seem to do anything.

00:48:40.750 --> 00:48:44.369
You call set font in your control
and then you ask for the font back

00:48:44.369 --> 00:48:48.089
but you're getting a nil font, you're
not getting the font you expect.

00:48:48.090 --> 00:48:50.000
Why is that?

00:48:50.000 --> 00:48:54.989
Well as we discussed earlier, many of these NS
control methods are just wrappers around NS cell.

00:48:54.989 --> 00:48:58.209
So if your control has a cell, these methods will work.

00:48:58.210 --> 00:49:01.949
If it does not have a cell, the methods will fail.

00:49:01.949 --> 00:49:09.359
So the solution is to call set cell class or override cell
class so that NS control will instantiate and instance

00:49:09.360 --> 00:49:13.349
of the cell and set it on your control
when the control itself is instantiated

00:49:13.349 --> 00:49:16.860
and then these methods will do what you expect.

00:49:16.860 --> 00:49:19.260
And it can be a vanilla NS cell.

00:49:19.260 --> 00:49:23.660
It doesn't have to be a fancy NS button
cell or text field cell or a custom cell.

00:49:23.659 --> 00:49:27.259
Even the basic NS cell has support
for most of these methods.

00:49:27.260 --> 00:49:30.080
Use NS action cell for set target and set action.

00:49:30.079 --> 00:49:33.519
That's probably as deep into the
hierarchy as you need to go.

00:49:35.429 --> 00:49:40.859
All right, let's say you make your control and you
find that it doesn't seem to work with first responder.

00:49:40.860 --> 00:49:47.870
So in IB, you set your controls target to first
responder, but it doesn't seem to be working.

00:49:47.869 --> 00:49:50.299
Well a nil target indicates first responder.

00:49:50.300 --> 00:49:54.050
So when you set your target at first
responder, that really means nil and of course,

00:49:54.050 --> 00:49:57.450
sending a message to nil doesn't do anything.

00:49:57.449 --> 00:50:04.829
So instead of messaging your target directly, the
right thing to do is to call through to NS app and pass

00:50:04.829 --> 00:50:11.039
and pass NSApp send action, pass your actions
to pass your target from pass your control.

00:50:11.039 --> 00:50:16.570
And NS app will take care of not only sending the
target or sending the action to the first responder

00:50:16.570 --> 00:50:22.460
if the target is nil, but it will also do the right thing
for model panels, for many target actions should be blocks.

00:50:22.460 --> 00:50:29.369
So definitely use send action to from, instead of
messaging your target directly and track ball does this.

00:50:29.369 --> 00:50:31.650
The last pitfall.

00:50:31.650 --> 00:50:37.250
Say you pressed the arrow keys, you pressed the right
arrow key and you expect move right to be called.

00:50:37.250 --> 00:50:39.139
Move right does not seem to be called on your control.

00:50:39.139 --> 00:50:40.920
What's going wrong?

00:50:40.920 --> 00:50:49.099
Well, these methods are called by NS Window on your
control via the Cocoa key bindings architecture.

00:50:49.099 --> 00:50:52.079
They are not called directly.

00:50:52.079 --> 00:50:57.739
So if you override key down and you do not call through
to super, then NS window will not receive the event

00:50:57.739 --> 00:51:00.559
and know to call move right on your control.

00:51:00.559 --> 00:51:06.429
So of course, for actions, key presses that you
do not handle, make sure you call through to super

00:51:06.429 --> 00:51:10.349
and then you will have these move
right methods called on your control.

00:51:13.250 --> 00:51:17.920
All right, let's wrap up everything
we've discussed and we'll take questions.

00:51:17.920 --> 00:51:22.820
So custom controls are not really difficult.

00:51:22.820 --> 00:51:24.720
They are straightforward.

00:51:24.719 --> 00:51:25.509
They make sense.

00:51:25.510 --> 00:51:26.000
They really do.

00:51:26.000 --> 00:51:30.500
So don't worry too much about creating
one, it's not that hard.

00:51:30.500 --> 00:51:32.010
You can use sub views to help you draw.

00:51:32.010 --> 00:51:33.120
We saw that with track ball.

00:51:33.119 --> 00:51:35.960
It used the QC view to draw the track ball itself.

00:51:35.960 --> 00:51:42.240
You can also use cells to draw, but you
don't have to sub class NS cell typically.

00:51:42.239 --> 00:51:48.250
The one case where we saw you did have to sub class
NS cell was for prefers tracking until mouse up.

00:51:48.250 --> 00:51:54.119
You could use cells for drawing, for
mouse tracking, for text editing.

00:51:54.119 --> 00:51:55.349
Don't be afraid of NS cell.

00:51:55.349 --> 00:52:00.369
It can seem like an intimidating class and maybe one
that's not easy to understand, but it's not that bad.

00:52:00.369 --> 00:52:02.609
It's not hard to use and it's very useful.

00:52:02.610 --> 00:52:06.280
Even plain vanilla NS cell is very useful.

00:52:06.280 --> 00:52:08.300
We saw all the different appearances.

00:52:08.300 --> 00:52:14.070
There's the press appearance, there's the on state disabled
and think carefully about which ones apply to your control,

00:52:14.070 --> 00:52:17.980
so I want to have a roll over, how do I draw my focus rings.

00:52:17.980 --> 00:52:22.329
And we saw how to determine which
appearance applies at any given moment.

00:52:23.550 --> 00:52:25.870
And think carefully about the different behaviors.

00:52:25.869 --> 00:52:28.389
Should my control be continuous,
should it support click through,

00:52:28.389 --> 00:52:32.819
what is the that should be configurable
if the action is also configurable.

00:52:32.820 --> 00:52:39.080
Because click through is something which depends not
only on the class control, but also on the action.

00:52:39.079 --> 00:52:41.170
And don't forget accessibility right.

00:52:41.170 --> 00:52:43.280
Accessibility is not an add on at the end.

00:52:43.280 --> 00:52:47.170
Accessibility is fundamental to
being a good control on Mac OS X.

00:52:47.170 --> 00:52:52.349
Not only for users depending on it, but for tools support.

00:52:52.349 --> 00:52:56.469
And I'm sure most of you have, but if you haven't,
please read the human interface guidelines.

00:52:56.469 --> 00:53:01.679
It will make your control a better citizen on Mac OS X
and it will give you better understanding of the way,

00:53:01.679 --> 00:53:05.649
the reason existing controls work the way they do.
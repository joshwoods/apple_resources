WEBVTT

00:00:20.089 --> 00:00:25.929
>> Hi. Hey I'm actually surprised there's this
many of you here cause it's Friday and it's late.

00:00:25.929 --> 00:00:27.629
But welcome.

00:00:27.629 --> 00:00:30.129
I think it's been a great developer conference this year.

00:00:30.129 --> 00:00:34.859
I want to talk to you today about
what we're doing with device drivers

00:00:34.859 --> 00:00:40.899
for class compliant devices on the Mac OS platform.

00:00:40.899 --> 00:00:48.259
So the built in drivers for Macs are actually pretty
good, but they're pretty good in a limited way.

00:00:48.259 --> 00:00:51.509
There's stereo, you can do stereo input and output.

00:00:51.509 --> 00:00:53.049
The performance of them is really good.

00:00:53.049 --> 00:01:00.019
But we found, and we know from talking to people
who are doing pro audio that they want to be able

00:01:00.020 --> 00:01:03.480
to expand the built in capabilities of the platform.

00:01:03.479 --> 00:01:09.159
And there's a list of things here that we know
that you care about if you're gonna do a device.

00:01:09.159 --> 00:01:15.549
So how can you actually extend the
built in capabilities of a Mac?

00:01:15.549 --> 00:01:21.950
Well, you've really got three ways,
you can use USB, Firewire,

00:01:21.950 --> 00:01:26.079
or PCI express or Express card, or a variance thereof.

00:01:26.079 --> 00:01:34.539
What I want to do is talk about standards
space devices, so devices that are based

00:01:34.540 --> 00:01:41.010
on industry standards published
by recognized industry bodies.

00:01:41.010 --> 00:01:46.370
And there's a number of advantages for
developing your devices in these ways.

00:01:46.370 --> 00:01:53.090
But we do recognize that there are good and valid reasons
why you may want to (inaudible) your own protocols.

00:01:54.430 --> 00:01:59.560
The main advantages generally translate
into time to market things.

00:01:59.560 --> 00:02:06.500
So if you're going to buy standards based silicon
rather than doing an FPGA, you don't have to do all

00:02:06.500 --> 00:02:12.379
of the design language stuff that you're gonna
have to do to (inaudible) your own solution.

00:02:12.379 --> 00:02:16.210
If you're buying a standards based solution, you're
not gonna have to write firmware for that device.

00:02:16.210 --> 00:02:21.719
You may have to customize the firmware, but you're not gonna
have to write the firmware from scratch for the device,

00:02:21.719 --> 00:02:27.580
and that's actually you know, a six
months to a year thing on most devices.

00:02:27.580 --> 00:02:36.260
The other thing is if you're using the driver in the
operating system, you're kind of insulated from changes,

00:02:36.259 --> 00:02:41.969
and the types of changes I mean are things
like the Power PC to Intel transition,

00:02:41.969 --> 00:02:44.719
the thirty two bit to sixty four bit transition.

00:02:44.719 --> 00:02:51.310
We've seen developers take upwards to six months to really
(inaudible) when we go through a major architecture change.

00:02:51.310 --> 00:02:55.729
If you're using the built in drivers,
you're gonna work from day one.

00:02:55.729 --> 00:03:02.139
So as an example, AVC fireware devices that we're
shipping on Mac OS, when we went to Intel they worked

00:03:02.139 --> 00:03:04.469
on the first Intel machines that we shipped.

00:03:04.469 --> 00:03:09.280
So there's a number of really good reasons why you
want to go for standards based devices, but as I say,

00:03:09.280 --> 00:03:15.129
I understand why you may not want to go to it.

00:03:15.129 --> 00:03:19.289
So these really translate to a
time to market and a cost issue.

00:03:19.289 --> 00:03:23.519
And ultimately if you're not having to
do all this engineering work, you know,

00:03:23.520 --> 00:03:30.770
just to get your transport working, you can spend
more time on the product differentiation features

00:03:30.770 --> 00:03:34.490
for your device, and that's really important.

00:03:34.490 --> 00:03:38.270
So the two things that I'm gonna talk about today,

00:03:38.270 --> 00:03:43.719
or that actually the team are gonna
talk about today, are USB and firewire.

00:03:43.719 --> 00:03:50.750
We're not gonna talk about PCI or Express card,
primarily because there really are no standards

00:03:50.750 --> 00:03:56.159
in those spaces to develop devices under.

00:03:56.159 --> 00:04:03.280
So for USB it kind of splits between
USB audio class device one point oh

00:04:03.280 --> 00:04:07.219
and USB audio class two point oh spec compliant devices.

00:04:07.219 --> 00:04:12.469
And for firewire we're primarily talking
about music subunit and audio subunit.

00:04:14.409 --> 00:04:20.490
So what I want to do is kind of run through
the features that we've put into Leopard,

00:04:20.490 --> 00:04:25.720
to sort of answer a question that
some of you may be answering.

00:04:25.720 --> 00:04:32.180
We will actually ship the same drivers under Tiger.

00:04:32.180 --> 00:04:36.970
So you know, what we're talking about
today will be on both Tiger and Leopard,

00:04:36.970 --> 00:04:40.370
although these features have been
primarily developed for Leopard.

00:04:40.370 --> 00:04:45.170
And we're gonna you know, talk about
USB, and we're gonna talk about firewire.

00:04:47.189 --> 00:04:53.469
The goal is that you'll be aware of the new features
that are available in the driver set on Leopard,

00:04:53.470 --> 00:04:59.170
and we want to provide you with a set of tips and techniques
for ensuring your device works well on the platform,

00:04:59.170 --> 00:05:01.080
and getting the most out of the class drivers.

00:05:01.079 --> 00:05:09.639
So you know, we want to point you at
tools that we have for making sure your,

00:05:09.639 --> 00:05:17.129
making sure that your device descriptors are correct, and
we want to you know, point you at resources that you can use

00:05:17.129 --> 00:05:23.329
in order to work more closely with
Apple on your standards based device.

00:05:23.329 --> 00:05:31.579
Also want to talk about specifically to firewire how you
can customize the behavior of an ABC music subunit device.

00:05:31.579 --> 00:05:37.199
We've got a couple of things that enable
your device to work well with our driver,

00:05:37.199 --> 00:05:40.639
and enable you to tune the performance
of your device with the driver.

00:05:40.639 --> 00:05:45.779
And the last thing I want to cover
is some work that we've been doing

00:05:45.779 --> 00:05:48.339
with the firewire team for networking ABC devices together.

00:05:48.339 --> 00:05:50.810
And I'm really excited about that.

00:05:50.810 --> 00:05:52.949
So I want to bring up Tori (assumed spelling) Walker.

00:05:52.949 --> 00:05:57.009
Tori is the device driver engineer who's
responsible for the Apple USB audio driver.

00:05:57.009 --> 00:05:57.039
( applause )

00:05:57.040 --> 00:05:57.840
>> Thanks Nick.

00:05:57.839 --> 00:06:00.810
>> Thanks Tori.

00:06:04.389 --> 00:06:08.279
>> Good afternoon everyone out there in the audience,
and those listening in from the overflow room.

00:06:08.279 --> 00:06:10.129
My name is Tori Walker.

00:06:10.129 --> 00:06:14.500
I'm going to be talking to you today about
primarily USB two point oh audio devices.

00:06:14.500 --> 00:06:18.129
But before we get there, let's talk a
little bit about what we already had.

00:06:18.129 --> 00:06:22.069
So USB audio class one point oh, what does it buy you?

00:06:22.069 --> 00:06:27.230
Apple USB audio is the name of the driver, it's
a kernel extension, and it supports full speed,

00:06:27.230 --> 00:06:34.930
meaning USB one point oh, one point one devices
using USB audio class one point oh descriptors.

00:06:34.930 --> 00:06:40.840
One point one is to transport, one point oh is to
spec. The round trip latency is under ten milliseconds,

00:06:40.839 --> 00:06:45.549
for most devices we've measured it's
generally about nine point five milliseconds.

00:06:45.550 --> 00:06:50.939
Kind of depends on the hardware there, but
that latency is measured from analog to analog.

00:06:50.939 --> 00:06:53.620
That goes up through core audio and back down.

00:06:53.620 --> 00:06:56.530
And that's a pretty good latency I think.

00:06:56.529 --> 00:06:59.529
There are also a few newly resolved
issues I wanted to touch on.

00:06:59.529 --> 00:07:05.429
For one, we now properly handle short refresh
intervals for feedback and synch endpoints.

00:07:05.430 --> 00:07:13.180
What we had before is if you were using a feedback endpoint
to report your sample rate, if the polling rate was so,

00:07:13.180 --> 00:07:15.639
was too low, then we had some trouble with queuing.

00:07:15.639 --> 00:07:19.729
That's been fixed, so you can go down
now basically as low as you want.

00:07:19.730 --> 00:07:23.680
Also we now properly handle high refresh intervals.

00:07:23.680 --> 00:07:27.829
And when I say greater than a hundred twenty eight
milliseconds, since they have to be a power of two,

00:07:27.829 --> 00:07:35.159
and the maximum is two fifty six, what I'm really saying
is now two fifty six millisecond polling intervals work.

00:07:35.160 --> 00:07:38.680
Also we now actually respect the lock delay value.

00:07:38.680 --> 00:07:43.110
Now as far as I know, most devices I've
seen do not record a lock delay value.

00:07:43.110 --> 00:07:46.770
So it didn't really make that much of a difference before.

00:07:46.769 --> 00:07:52.680
But we have seen devices where we try to start streaming
to the device and it's not ready, and we get choppy audio

00:07:52.680 --> 00:07:55.400
for the first very, very short period of time.

00:07:55.399 --> 00:08:01.979
Well now if you specified lock delay properly, we will obey
it, and we won't start streaming until your device is ready.

00:08:01.980 --> 00:08:06.430
Finally, we handle the volume controls
with large ranges properly.

00:08:06.430 --> 00:08:12.370
Previously if you had a volume control range, it started
at low, the low of negative one twenty eight DB up to

00:08:12.370 --> 00:08:18.970
about one twenty eight DB, with the resolution of about
one DB, you might see some funkiness being reported

00:08:18.970 --> 00:08:24.160
with the DB value that's reported, and
audio MIDI setup, or any audio application

00:08:24.160 --> 00:08:26.800
where it shows a control value versus a DB value.

00:08:26.800 --> 00:08:28.900
That also has been fixed.

00:08:28.899 --> 00:08:31.500
So, with that being said, let's move on to two.

00:08:31.500 --> 00:08:35.809
It's bigger, it's better, why would
you want to use USB two point oh audio?

00:08:35.809 --> 00:08:40.729
Well, the main reason is you've
got a fatter pipe to deal with.

00:08:40.730 --> 00:08:48.850
That means more channels, higher sample rates, run
faster, jump higher, be the envy of all of your friends.

00:08:48.850 --> 00:08:51.519
Plus any system that you deal with these days,

00:08:51.519 --> 00:08:56.059
regardless of what platforms you're
developing for, generally have a USB port.

00:08:56.059 --> 00:08:58.729
So it's a good bet to go ahead and get into that.

00:08:58.730 --> 00:09:00.970
So, what driver is it?

00:09:00.970 --> 00:09:02.110
It's the same driver.

00:09:02.110 --> 00:09:07.230
Apple USB audio is gonna support USB
audio class one point oh and two point oh.

00:09:07.230 --> 00:09:14.039
The round trip latency is still under ten milliseconds,
and now we have support for high speed endpoint polling.

00:09:14.039 --> 00:09:18.009
Now in the USB one point oh audio
specification, what you basically had to deal

00:09:18.009 --> 00:09:23.419
with was every millisecond you're
expected to send or receive some data.

00:09:23.419 --> 00:09:29.399
With the USB two point audio spec you can have data
transactions as many as eight times per millisecond,

00:09:29.399 --> 00:09:32.399
or once every one hundred twenty five microseconds.

00:09:32.399 --> 00:09:38.709
Now for those of you who are really on top of it, you think
well if I can poll that often, is there some potential

00:09:38.710 --> 00:09:43.800
for me to perhaps have a lower latency
than USB one point oh audio devices?

00:09:43.799 --> 00:09:47.539
And what I want to say is a very firm maybe.

00:09:47.539 --> 00:09:54.250
And the reason I say that is because before the queuing was
within one millisecond, so we had one millisecond of jitter

00:09:54.250 --> 00:09:57.059
for input, and one millisecond of jitter for output.

00:09:57.059 --> 00:10:02.419
But now if we move that down to one hundred twenty
five microseconds of jitter for input and output,

00:10:02.419 --> 00:10:08.699
I could potentially shave as much as one point
seventy five milliseconds of round trip latency off

00:10:08.700 --> 00:10:13.770
that for class compliant devices, from analog
to analog, up through core audio, and back down.

00:10:13.769 --> 00:10:15.579
And that's a pretty savings.

00:10:15.580 --> 00:10:20.330
However, in order to develop a device that
will provide that for you, I need you, sorry,

00:10:20.330 --> 00:10:26.470
a driver to provide that for you, I need you to
develop a device that actually polls that often.

00:10:26.470 --> 00:10:32.820
So if you're interested in developing an ultra low latency
solution high speed audio device, let us know, get it to us,

00:10:32.820 --> 00:10:37.050
and we'll see what we can do to drag
that latency down even farther for you.

00:10:37.049 --> 00:10:41.829
So what are the big changes in USB audio two point oh?

00:10:41.830 --> 00:10:44.810
The biggest thing is probably the clock model.

00:10:44.809 --> 00:10:48.799
There's a new clock model and latency at
the feature unit level that have been added

00:10:48.799 --> 00:10:52.949
so that the timing relationships
and synchronicity are detailed.

00:10:52.950 --> 00:10:59.220
We can actually go in and if you have a latency control,
poll every latency control in the audio path and figure

00:10:59.220 --> 00:11:03.620
out what the latency is from terminal to terminal.

00:11:03.620 --> 00:11:08.480
Also sample rates are no longer listed
explicitly in the format descriptors.

00:11:08.480 --> 00:11:15.379
They are discovered by querying the clock entities
that are published in the USB two point oh audio.

00:11:15.379 --> 00:11:22.029
This is a big change, because if you want to have
any sample rates that are available for the user,

00:11:22.029 --> 00:11:26.350
we have to be able to go to your clock
source, look at your sample frequency control,

00:11:26.350 --> 00:11:29.050
and read all of the different sample
ranges that you support.

00:11:29.049 --> 00:11:36.229
If you do not do this, then your device may show
up in system profiler, or something like that,

00:11:36.230 --> 00:11:41.600
but it won't show up in the sound
preference pane or to any audio applications,

00:11:41.600 --> 00:11:44.350
because you never told us what sample rates you run at.

00:11:44.350 --> 00:11:47.769
So this is a big, it's a big change,
and it's a good area for you to study

00:11:47.769 --> 00:11:51.009
if you're going to develop these types of devices.

00:11:51.009 --> 00:11:53.779
Also, the notion of feedback endpoints has been changed.

00:11:53.779 --> 00:12:02.159
The feedback is formatted differently, and also the
feedback is per transaction, as opposed to per millisecond.

00:12:02.159 --> 00:12:10.889
So for example, if you were running at one hundred ninety
two kilohertz, and you wanted to report that is your nominal

00:12:10.889 --> 00:12:17.379
and actual sample rate, then if you're polling twice
per millisecond, you actually report ninety six twice,

00:12:17.379 --> 00:12:21.860
instead of reporting one ninety two twice.

00:12:21.860 --> 00:12:24.310
Also some descriptors have been streamlined.

00:12:24.309 --> 00:12:27.589
They've changed, make sure that you
take a look at the one point oh version

00:12:27.590 --> 00:12:31.490
versus the two point oh version,
and don't mix those descriptors.

00:12:31.490 --> 00:12:35.419
And also, and this is a big point, high speed devices

00:12:35.419 --> 00:12:42.129
with USB one point oh audio class descriptors
are explicitly disallowed, explicitly disallowed.

00:12:42.129 --> 00:12:50.129
I've seen devices, mostly, I think mostly cameras, high
speed cameras that will have an audio interface on them,

00:12:50.129 --> 00:12:54.769
and they have USB one point oh
audio class compliant descriptors.

00:12:54.769 --> 00:13:01.649
This, and they say that it works on Mac OS ten, I want
to say that this is not by design, this is by luck.

00:13:03.049 --> 00:13:06.039
The reality of the situation is is if we ever have a problem

00:13:06.039 --> 00:13:10.589
with a high speed device using a USB
one point oh audio class descriptor,

00:13:10.590 --> 00:13:13.440
we may have to just explicitly disable that support.

00:13:13.440 --> 00:13:18.660
And if you want your device to work properly on Mac
OS ten, you need to use the correct audio class.

00:13:18.659 --> 00:13:25.500
A USB two point oh audio class is not only good for high
speed devices, but it's also good for full speed devices.

00:13:25.500 --> 00:13:31.649
So you don't necessarily have to have some new
fancy audio chip out there to develop these.

00:13:31.649 --> 00:13:36.529
All you have to do is use the proper
spec and we'll respect it.

00:13:36.529 --> 00:13:38.309
Okay. Let's talk about the clock model.

00:13:38.309 --> 00:13:43.769
This is one of the biggest changes to the USB two point
oh audio spec. Here's a big pretty graph on the screen,

00:13:43.769 --> 00:13:45.649
I want you to take a moment to admire it.

00:13:45.649 --> 00:13:45.840
( laughter )

00:13:45.840 --> 00:13:51.500
On the left side, well, stage left.

00:13:51.500 --> 00:13:55.889
All right, there's an input terminal on one side,
and there's an output terminal on the other.

00:13:55.889 --> 00:14:00.059
Ignore the fact that the input terminal
is also labeled OT, that's a mistake.

00:14:00.059 --> 00:14:04.509
What I want you to see is that there is for, there's
an audio path, and then there's a clock path,

00:14:04.509 --> 00:14:08.789
and the clock path is joined to a few of
the new USB two point oh audio entities.

00:14:08.789 --> 00:14:12.159
You've got the clock selector and
you've got some clock sources.

00:14:12.159 --> 00:14:15.740
Now this is a very, very simple clock model.

00:14:15.740 --> 00:14:21.210
What you know here is that this single audio path is
going to have the same clock source, either the top one

00:14:21.210 --> 00:14:24.310
or the bottom one, depending on
how the selector is configured.

00:14:24.309 --> 00:14:28.409
Now if you want to take this and kind of
just imagine, just use your imagination.

00:14:28.409 --> 00:14:31.789
Make another one of these and connect
it to the same clock path,

00:14:31.789 --> 00:14:37.709
then now you know that perhaps you've got two
audio signal paths, and they're both synchronized.

00:14:37.710 --> 00:14:43.550
This is something that you could not do in the USB one
point oh audio spec. If for example you always have

00:14:43.549 --> 00:14:49.679
to run your sample rates off the same crystal, and your
output sample rate changes, your input needs to change

00:14:49.679 --> 00:14:52.729
as well, but there was no way to say that explicitly.

00:14:52.730 --> 00:14:56.259
Well now, in USB two point oh audio, you can do it.

00:14:58.179 --> 00:15:03.899
Now the big control that you're going
to want to make sure that you implement

00:15:03.899 --> 00:15:06.399
for your clock entitles is the sample rate control.

00:15:06.399 --> 00:15:11.209
As I said earlier, you're not going
to be able to publish any sample rates

00:15:11.210 --> 00:15:14.889
for the user to use unless you implement this.

00:15:14.889 --> 00:15:19.199
You cannot specify your sample rates
inside the format descriptors any more.

00:15:19.200 --> 00:15:23.160
So take a look at this clock source
here, it has a sample rate control.

00:15:23.159 --> 00:15:28.730
The current value which we've just supplied
here is gonna be one ninety two kilohertz,

00:15:28.730 --> 00:15:31.389
and then you'll see three range entities.

00:15:31.389 --> 00:15:36.029
Now the range subzero entity is just the
number of ranges that are actually reported

00:15:36.029 --> 00:15:39.230
by the control, so in this case it's two.

00:15:39.230 --> 00:15:43.279
Range one you'll see is ninety
six K for the minimum attribute,

00:15:43.279 --> 00:15:47.899
ninety six K for the maximum attribute,
and a resolution of zero.

00:15:47.899 --> 00:15:52.529
What this essentially means is it's a discrete sample rate.

00:15:52.529 --> 00:15:57.309
The other range is the same, it's one ninety
two K, and it's also a discrete sample rate.

00:15:57.309 --> 00:16:04.609
So when the driver looks into this clock source, it sees
this sample rate control, and then what it says is okay,

00:16:04.610 --> 00:16:09.870
anything that's plugged into this clock source
is gonna have two sample rates that support it.

00:16:09.870 --> 00:16:12.980
It has ninety six K and one ninety two K, and that's it.

00:16:12.980 --> 00:16:14.230
So this is what you need to support.

00:16:14.230 --> 00:16:19.980
There are also other controls of interest that you may
want to implement, such as the clock validity control.

00:16:19.980 --> 00:16:25.379
We don't want to try to choose a clock source
for you that does not have a valid clock running.

00:16:25.379 --> 00:16:32.759
And there are other controls of interest as well that you
can read about in the USB two point oh audio specification.

00:16:32.759 --> 00:16:33.720
All right.

00:16:33.720 --> 00:16:38.860
So I want to make my USB two point
oh audio device, how do I do it?

00:16:38.860 --> 00:16:40.419
There are three big ways you can do it.

00:16:40.419 --> 00:16:45.019
There are ready to roll implementations that are
already under development by several companies.

00:16:45.019 --> 00:16:51.840
What you're gonna do in this situation is make sure
that you change the vendor ID and the product ID

00:16:51.840 --> 00:16:55.019
to be unique for your company and your device.

00:16:55.019 --> 00:17:01.870
Because in some cases we may need to distinguish your
device from other devices, and if you don't change this,

00:17:01.870 --> 00:17:06.180
then your device may look like any other
number of devices that are on the market.

00:17:06.180 --> 00:17:10.519
And if there's a problem that is specific to your device,

00:17:10.519 --> 00:17:15.980
we can't address that without affecting
a wide, a variety of devices.

00:17:15.980 --> 00:17:18.279
Also you've got programmable audio chips.

00:17:18.279 --> 00:17:23.230
You're gonna supply your own descriptor, and then
you're gonna manage your own audio centric resources.

00:17:23.230 --> 00:17:26.870
If you want help building a descriptor, we are here for you.

00:17:26.869 --> 00:17:29.349
We would like for your device to be class compliant,

00:17:29.349 --> 00:17:33.719
and we would like for your descriptor
to work well with Apple USB audio.

00:17:33.720 --> 00:17:39.089
If there's, for some reason it doesn't work the way you
expect, it could be because the descriptor is wrong,

00:17:39.089 --> 00:17:41.119
it could be because there's a bug in the driver.

00:17:41.119 --> 00:17:44.799
So contact us early and often,
send us a version of your device,

00:17:44.799 --> 00:17:49.940
and we'll do our best to get it working
on Mac OS ten at no extra cost to you.

00:17:49.940 --> 00:17:50.820
And finally, FPGA.

00:17:50.819 --> 00:17:59.480
This is gonna be the most intense involved and difficult
way to design your own USB two point oh audio device.

00:17:59.480 --> 00:18:05.099
Not only are you going to supply your own device descriptor,
but you're gonna do your own device debugging as well.

00:18:05.099 --> 00:18:10.429
If you're going to take, undertake this
massive project, please let us know early.

00:18:10.430 --> 00:18:14.279
Get us early versions of your hardware so we
can help you out with it along the process,

00:18:14.279 --> 00:18:17.619
and make sure that it works well on Mac OS ten.

00:18:17.619 --> 00:18:23.169
Okay. Now on to James Brown's favorite portion, the gotchas.

00:18:23.170 --> 00:18:24.660
The volume range is invalid.

00:18:24.660 --> 00:18:28.220
Sometimes I see this on, and the
first few are descriptor problems.

00:18:28.220 --> 00:18:31.180
But sometimes I see the volume range is invalid.

00:18:31.180 --> 00:18:34.960
The valued hexadecimal value eight zero zero zero,

00:18:34.960 --> 00:18:40.350
which is meant to connote negative infinity,
is only valid as a current attribute.

00:18:40.349 --> 00:18:43.049
You cannot use it as your minimum control value.

00:18:43.049 --> 00:18:47.329
Now if you use this, we won't choke, we won't fall over.

00:18:47.329 --> 00:18:50.329
We're just gonna bump it up to eight zero zero one.

00:18:50.329 --> 00:18:57.379
However, if you're doing specific math with your
resolution and you expect the step size to be X,

00:18:57.380 --> 00:19:02.510
it'll be off a little bit because I've had to change
the step size, and your math doesn't work out any more.

00:19:02.509 --> 00:19:08.420
So be careful about this, and there's an extra paragraph in
the USB two point oh audio spec that says this is only valid

00:19:08.420 --> 00:19:11.870
as the current attribute, so don't use it as your minimum.

00:19:11.869 --> 00:19:15.159
All right, maximum packet size is incorrect.

00:19:15.160 --> 00:19:20.140
Let's say that you're streaming two
channels, sixteen bit at forty four one.

00:19:20.140 --> 00:19:23.660
That means your average packet is
gonna be, you've got the two channels,

00:19:23.660 --> 00:19:27.190
and sixteen over eight is two, and
then forty four average samples.

00:19:27.190 --> 00:19:32.830
So four times forty four is a hundred seventy six.

00:19:32.829 --> 00:19:34.329
Damn, you guys are good.

00:19:34.329 --> 00:19:35.279
All right.

00:19:35.279 --> 00:19:41.000
So you're moving between one seventy six nine times,
and then the tenth time you'll have one eighty,

00:19:41.000 --> 00:19:43.140
because you've got that one extra sample.

00:19:43.140 --> 00:19:47.410
So what if your maximum packet size is one seventy six?

00:19:47.410 --> 00:19:51.120
Then when you try to send that one eighty
for input, or I try to send that one eighty

00:19:51.119 --> 00:19:53.789
for output, we're gonna generate an overrun.

00:19:53.789 --> 00:20:02.759
Now an overrun was more or less benign on Power PC
systems, but on Intel systems it's bad, very, very bad.

00:20:02.759 --> 00:20:05.809
And you don't want to have bad behavior by your device.

00:20:05.809 --> 00:20:10.519
You don't want to have audio artifacts, you
don't want to have all the traffic that's plugged

00:20:10.519 --> 00:20:15.450
into that particular USB port slowing
down or choking because of these overruns.

00:20:15.450 --> 00:20:20.110
And also you don't want to report a maximum
package size of zero, because honestly, why bother?

00:20:20.109 --> 00:20:26.219
That's like a no fat decaf sugar free you know, mocha.

00:20:26.220 --> 00:20:26.920
All right.

00:20:26.920 --> 00:20:30.850
So another thing I'm gonna point out here is
I'm gonna say the lock delay is not specified.

00:20:30.849 --> 00:20:35.219
Now that's gonna sound funny to you because
earlier I said now we respect lock delay.

00:20:35.220 --> 00:20:39.130
Well hey, now that we respect it, we
want you to publish it, all right?

00:20:39.130 --> 00:20:46.630
If your device takes a while to get its sample clock cooking
before it's ready to stream audio, let us know about that

00:20:46.630 --> 00:20:52.370
and we will hold off asking for, or sending
data to your device until you're ready.

00:20:52.369 --> 00:20:55.609
Next, audio class descriptor versions are mixed.

00:20:55.609 --> 00:21:01.909
So some people wanted to jump the gun a little
bit and have some USB two point audio support,

00:21:01.910 --> 00:21:04.990
but mostly use USB one point oh audio descriptors.

00:21:04.990 --> 00:21:07.279
This also can lead to unexpected behavior.

00:21:07.279 --> 00:21:11.210
Remember, if you're using a full speed
device, you can use two point oh audio spec,

00:21:11.210 --> 00:21:16.009
or the one point oh audio spec. Either is
fine, but just you know, keep them separate.

00:21:16.009 --> 00:21:19.970
If you're using a high speed device,
you must use two point oh.

00:21:19.970 --> 00:21:23.210
Finally, and this is not a descriptor
problem, this is actually just kind

00:21:23.210 --> 00:21:25.890
of a device problem, especially for input.

00:21:25.890 --> 00:21:29.870
Your packet to packet variance exceeds one sample frame.

00:21:29.869 --> 00:21:35.319
The USB audio one point oh spec said that you could
go up one sample or down one sample for your average.

00:21:35.319 --> 00:21:40.269
So say you were doing, streaming in forty
four one, then you could go forty four

00:21:40.269 --> 00:21:42.759
or you could go forty five, or you could go forty three.

00:21:42.759 --> 00:21:46.509
Well for the USB two point oh spec you can go up one.

00:21:46.509 --> 00:21:49.650
So you can go forty four, you can do forty five only.

00:21:49.650 --> 00:21:56.509
Now I'm not gonna check that, but it is important for
you not to dip down to forty, and then try to compensate

00:21:56.509 --> 00:22:03.250
for it later by jumping up to forty eight, because we
have a very, very sensitive, time sensitive measurement

00:22:03.250 --> 00:22:06.710
that we're doing here to provide low
latency, and if the data's not there

00:22:06.710 --> 00:22:10.380
when we expect it, you could get artifacts or worse.

00:22:10.380 --> 00:22:11.870
All right.

00:22:11.869 --> 00:22:13.929
Few final thoughts before I get off the stage.

00:22:13.930 --> 00:22:20.240
In Leopard the same driver supports USB audio
one point oh and USB audio two point oh classes.

00:22:20.240 --> 00:22:24.710
And not only that, it's on that Leopard
beta disk that you guys got already.

00:22:24.710 --> 00:22:28.000
So you could start developing your
devices against this right now.

00:22:28.000 --> 00:22:32.279
As Nick said earlier, we're gonna try to
get the same support into a software update

00:22:32.279 --> 00:22:36.170
for Tiger before we wave goodbye to it, but you can go ahead

00:22:36.170 --> 00:22:40.460
and start developing now using the
developer DVD that you've received.

00:22:40.460 --> 00:22:45.259
Class compliance does not compromise your
features, and it does not cost your resources.

00:22:45.259 --> 00:22:50.109
Remember, if you develop a class compliant
audio device, you have relative immunity

00:22:50.109 --> 00:22:52.299
to platform changes and software updates.

00:22:52.299 --> 00:22:56.490
And you can still write your own driver,
just provide a higher match score

00:22:56.490 --> 00:23:00.730
and we will gracefully back away
and let you handle your own device.

00:23:00.730 --> 00:23:05.480
But if something happens where your driver breaks,
hopefully your driver can just be disabled,

00:23:05.480 --> 00:23:12.019
and then your customers can still have access to the
basic, and maybe even advanced features of your device.

00:23:12.019 --> 00:23:15.660
Also, we can help support you for your product.

00:23:15.660 --> 00:23:21.509
If you send us your descriptor, we'll be happy to hand
parse it and let you know whether or not it's good to go.

00:23:21.509 --> 00:23:26.660
Send us your device, we'll do device testing, as
well as sleep, wake, and hot plugs to make sure

00:23:26.660 --> 00:23:29.509
that it behaves the way we expect it to behave

00:23:29.509 --> 00:23:34.210
And finally, if you read the audio spec, and not
just the audio spec, but the USB spec as well,

00:23:34.210 --> 00:23:36.170
so I wanted to point out a couple of sections.

00:23:36.170 --> 00:23:43.110
USB two point oh, this is not the audio spec, but
actually USB two point oh spec. Section five two oh four

00:23:43.109 --> 00:23:50.769
on isochronous devices, this is a very good read, also
section nine six six on endpoints is a very good read.

00:23:50.769 --> 00:24:00.069
And finally I'll call out the USB audio class, section four
seven two, the class specific audio control descriptor.

00:24:00.069 --> 00:24:03.419
This is basically where all the
new clock entities are located

00:24:03.420 --> 00:24:06.050
that you're going to need to implement for your device.

00:24:06.049 --> 00:24:08.509
Thank you for your time, and I'll turn it back over to Nick.

00:24:08.509 --> 00:24:13.039
( applause )

00:24:13.039 --> 00:24:14.409
>> Good job Tori.

00:24:14.410 --> 00:24:15.170
Thank you.

00:24:15.170 --> 00:24:17.210
Hey thanks Tori.

00:24:17.210 --> 00:24:20.569
Okay, so I want to talk a little
bit about (inaudible) devices,

00:24:20.569 --> 00:24:27.369
and specifically about AVC, music
and audio subunit place devices.

00:24:27.369 --> 00:24:29.359
Why do you use file after audio?

00:24:29.359 --> 00:24:34.729
Well, it's a big pipe, so you get a lot of bandwidth,
so you can get a lot of channels down there.

00:24:34.730 --> 00:24:44.079
We've actually found that we can get lower latency with
firewire than we can with USB, and we have a contest now

00:24:44.079 --> 00:24:47.759
that we've actually got the latency
down to something reasonable.

00:24:47.759 --> 00:24:50.839
They're both under ten milliseconds.

00:24:50.839 --> 00:24:56.519
Firewire is just edging ahead of USB, and Tori's
always coming up with schemes to make USB lower.

00:24:56.519 --> 00:25:00.569
But we understand, and we've heard you, you know.

00:25:00.569 --> 00:25:06.019
You've come to us and said class drivers, how
am I gonna develop a standards based device?

00:25:06.019 --> 00:25:09.750
Your driver's too high lane, see I can do my own.

00:25:09.750 --> 00:25:16.369
What's really interesting though is that sometimes we
measure your drivers, and sometimes chip companies will come

00:25:16.369 --> 00:25:19.909
to us and tell us they've got a very
low latency driver for their hardware.

00:25:19.910 --> 00:25:21.430
We measure those against ours.

00:25:21.430 --> 00:25:27.060
We know that on Mac OS, with the exception of
(inaudible), we have the lowest latency driver now.

00:25:27.059 --> 00:25:35.809
We're within about one and a half milliseconds round
trip (inaudible), and we're gonna try and get closer.

00:25:35.809 --> 00:25:38.099
(inaudible) pretty cost effective to implement.

00:25:38.099 --> 00:25:42.079
That may seem odd, cause you can get a
USB one point oh chip for about a buck,

00:25:42.079 --> 00:25:45.089
but you can't get a USB two chip for a buck.

00:25:45.089 --> 00:25:49.629
The firewire silicon that we're seeing
for audio is very cost competitive

00:25:49.630 --> 00:25:53.220
with firewire silicon that we're
seeing for USB two point oh.

00:25:53.220 --> 00:26:00.370
That may change if volumes go up on the USB two point
oh side, but you know, that's the truth of it today.

00:26:00.369 --> 00:26:07.029
And the thing that I find really compelling about
firewire as a solution is peer to peer networking.

00:26:07.029 --> 00:26:12.680
And we've spent a long while trying to get the firewire
driver where we want it in terms of performance,

00:26:12.680 --> 00:26:16.450
and we know the way we want it is the way you want it.

00:26:16.450 --> 00:26:23.850
And Matt and Neil (inaudible) and the rest of the team
have been working really, really hard over the last year

00:26:23.849 --> 00:26:28.459
and a half to get the latency to
something that we consider to be good.

00:26:28.460 --> 00:26:31.319
And we think we're there, we'd like to hear from you.

00:26:31.319 --> 00:26:36.039
This gives us a chance now to look at the thing
that has always been interesting about firewire,

00:26:36.039 --> 00:26:42.730
and actually is gonna come up and talk a
little bit about networking and some code

00:26:42.730 --> 00:26:48.789
that we're gonna release (inaudible) SDK so
that you can start to experiment with this.

00:26:48.789 --> 00:26:51.960
So I want to talk about the new features in Leopard.

00:26:51.960 --> 00:26:57.850
And I've listed the things that
I think are the most compelling.

00:26:57.849 --> 00:27:02.230
What the (inaudible) driver team have
been working on probably for the last year

00:27:02.230 --> 00:27:05.400
and a half is rewriting the streaming engine.

00:27:05.400 --> 00:27:12.600
In the past we took an interrupt to
do our work about every millisecond.

00:27:14.069 --> 00:27:16.490
Interrupts in Mac OS ten not good.

00:27:16.490 --> 00:27:23.789
We've rerun everything on new DCLs to be timer based,
and that's enabled us to do a whole bunch of stuff

00:27:23.789 --> 00:27:30.009
that improves performance, reduces CPU overhead,
improves the latency, so I want to talk about that stuff.

00:27:30.009 --> 00:27:35.589
We've also put extended stream format
support in, and I want to talk about that.

00:27:35.589 --> 00:27:41.839
We've improved MIDI, we recognized that it was kind of
weird, you know, cause we had low latency on firewire

00:27:41.839 --> 00:27:44.959
for streaming audio (inaudible) speed driver.

00:27:44.960 --> 00:27:49.200
But the MIDI latency was double, why was that?

00:27:49.200 --> 00:27:54.490
So we fixed that, and we've actually got
really good latency now with MIDI data.

00:27:54.490 --> 00:28:00.630
And then there's been some changes in the user
client which are of great interest if you want

00:28:00.630 --> 00:28:05.380
to customize the behavior of your firewire device.

00:28:05.380 --> 00:28:12.040
The new straining engines, it's been a long
and hard (inaudible) but we really (inaudible).

00:28:12.039 --> 00:28:15.720
It's been rewritten, we removed the timer.

00:28:15.720 --> 00:28:20.319
So those of you who know about this and care
will realize that that CPU spiking's gone.

00:28:20.319 --> 00:28:27.559
CPU spiking was never really a problem,
other than we think the CPU sampling

00:28:27.559 --> 00:28:30.440
in the performance tools was beating against our interrupt.

00:28:30.440 --> 00:28:32.990
So they sample about every ten milliseconds.

00:28:32.990 --> 00:28:37.890
We had an interrupt firing every
millisecond, every so often they coincided.

00:28:37.890 --> 00:28:42.380
If we were in an interrupt handler and you were trying
to sample the CPU, it looked like the CPU was pinned.

00:28:42.380 --> 00:28:45.470
So if you looked at performance
monitor, there'd be big spikes

00:28:45.470 --> 00:28:48.279
where the CPU appeared to be spiked at a hundred percent.

00:28:48.279 --> 00:28:54.539
We don't think that was ever actually a problem, because
users weren't using data, so your audio wasn't glitching.

00:28:54.539 --> 00:29:00.649
But what we do recognize is that the CPU overhead previously
on firewire was way higher than we'd like it to be.

00:29:00.650 --> 00:29:05.360
And we're measuring it now at about a third of
what it used to be, so this is really great,

00:29:05.359 --> 00:29:08.719
particularly if you want to start using multiple devices.

00:29:08.720 --> 00:29:12.230
The other thing we've done is we now
support blocking mode transmission.

00:29:12.230 --> 00:29:14.849
And this is important for certain firewire chips.

00:29:14.849 --> 00:29:20.879
We now have great compatibility with all of
the vendors of firewire silicon out of there.

00:29:20.880 --> 00:29:24.680
We've been working with them all, they're all great guys.

00:29:24.680 --> 00:29:33.130
Doesn't matter which you choose, all of the silicon vendors
out there have good solutions, and they work really hard

00:29:33.130 --> 00:29:37.950
to make this a good business for you guys.

00:29:39.279 --> 00:29:41.960
The big thing is latency improvements.

00:29:41.960 --> 00:29:47.500
The sub nine milliseconds is on bridge co, we've seen
silicon from other vendors where the latency's a lot lower

00:29:47.500 --> 00:29:51.319
than that because the chip housed audio more efficiently.

00:29:51.319 --> 00:29:56.359
You should go review who you're working with,
and see who has the right solution for you.

00:29:56.359 --> 00:30:01.639
The thing about rewriting the streaming
engine is we got better timing,

00:30:01.640 --> 00:30:05.670
and with better timing we could
start to have smaller safety offsets.

00:30:05.670 --> 00:30:16.740
And this also allows us to put data in exactly the right
place, which helps us both in terms of startup latency,

00:30:16.740 --> 00:30:20.789
and also in terms of making sure
that devices are sample locked.

00:30:20.789 --> 00:30:25.230
And this is very important again,
if you want to do multiple devices.

00:30:27.359 --> 00:30:31.899
Obviously the rewrite as I've said, gave us
a whole bunch of performance improvements.

00:30:31.900 --> 00:30:37.470
And the big thing here is if you profile
it, you can see that less CPU is being used.

00:30:37.470 --> 00:30:42.980
And you know, we heard you when you came to this
you know, those, I see some of you have there,

00:30:42.980 --> 00:30:46.049
the people out there who are working on firewire devices.

00:30:46.049 --> 00:30:53.210
We do listen to you, and we've been working
really hard to make sure that we fix this.

00:30:53.210 --> 00:30:57.329
The extended stream format support's
actually very, very useful.

00:30:57.329 --> 00:31:06.210
It allows devices to basically tell the driver
accurately what their IO and streaming capabilities are.

00:31:06.210 --> 00:31:14.420
And the big thing about this is previously if you
wanted to stream (inaudible) data and MBLA data,

00:31:14.420 --> 00:31:19.900
MBLA is firewire speak for linear PCM data, you
had to burn an iso (inaudible) stream for each,

00:31:19.900 --> 00:31:23.769
and we're limited in terms of the number of
iso (inaudible) streams that we have available.

00:31:23.769 --> 00:31:28.450
So obviously, you know, having to blow two is not desirable.

00:31:28.450 --> 00:31:35.880
So this is big news if you want to
mix this bit of data with PCM data.

00:31:37.380 --> 00:31:46.280
The MIDI support, again, this was an area that
both developers and customers talked to us about.

00:31:46.279 --> 00:31:53.129
So we've definitely improved the latency and the jitter, and
we've been using tools that the (inaudible) team provided us

00:31:53.130 --> 00:31:56.740
with to make sure that we've got the best possible latency

00:31:56.740 --> 00:32:00.230
and the lowest possible jitter
with MIDI on firewire devices.

00:32:00.230 --> 00:32:06.019
And we're actually pretty pleased with this, and we think
you will be too when you start playing with this card.

00:32:07.779 --> 00:32:14.819
The big thing, I think, are the changes in the user client.

00:32:14.819 --> 00:32:18.789
We did a lot of work in the user client for various reasons.

00:32:18.789 --> 00:32:28.259
But there's two APIs that are of particular
interest, FWA set plug in path, and FWA open service.

00:32:28.259 --> 00:32:31.769
If you don't know about the user
client, it's basically a back door

00:32:31.769 --> 00:32:35.180
into the firewire driver, and why would this be interesting?

00:32:35.180 --> 00:32:42.310
Well you may want to produce a device that uses Apple's
driver for streaming data to and from your device.

00:32:42.309 --> 00:32:49.599
But you want to actually control the behavior of that device
outside of what's specified in music and audio subunit.

00:32:49.599 --> 00:32:57.779
So for example, you may have a signal processing device
that you know, allows, affects processing on audio streams.

00:32:57.779 --> 00:33:04.139
You would be able to send the parameters for your
DSP routines down as AVC down to specific commands,

00:33:04.140 --> 00:33:10.970
and in order to do that you would need
to open a connection to the user client.

00:33:12.539 --> 00:33:16.450
So set plug in path is the first thing I want to talk about.

00:33:16.450 --> 00:33:19.890
Basically this allows you to load a help plug in.

00:33:19.890 --> 00:33:29.430
And reasons that you might want to load a help plug in
are that you're using somebody's silicon in the firmware,

00:33:29.430 --> 00:33:34.310
and they come up with a bunch of (inaudible) sources
that are more or less meaningless to your user,

00:33:34.309 --> 00:33:36.529
the computer generated (inaudible) sources.

00:33:36.529 --> 00:33:42.549
You may want to give them human readable clock source
names, so you can basically in your help plug in interface,

00:33:42.549 --> 00:33:48.470
intercept messages and massage them to
provide a good user interface to (inaudible).

00:33:48.470 --> 00:33:52.360
So you can correctly name your clock sources.

00:33:52.359 --> 00:33:59.169
Another thing you might want to do is intercept volume and
mute commands, so that if you have a custom control panel,

00:33:59.170 --> 00:34:05.950
you can update volume sliders and mute controls in your
control panel to reflect the actual settings on the device.

00:34:05.950 --> 00:34:15.490
So this is a really useful user client API if
you're developing any kind of control panel

00:34:15.489 --> 00:34:18.969
for your application, sorry for your hardware.

00:34:18.969 --> 00:34:27.779
Open with service, is a new API that allows you to
open a connection to the driver the correct way.

00:34:27.780 --> 00:34:31.080
Previous ways that you may have been doing
it probably won't work in the future,

00:34:31.079 --> 00:34:36.509
so we recommend that if you are opening a
connection to the driver, you do it this way.

00:34:36.510 --> 00:34:41.250
Once you've built your connection as I
said, you can send the specific ABC commands

00:34:41.250 --> 00:34:44.929
to your device, and change parameters on the device.

00:34:44.929 --> 00:34:48.079
And when you're using open with
service, there is a bit of a gotcha.

00:34:48.079 --> 00:34:54.440
You need to make sure that the service T that you pass
in is the Apple remote audio device from the registry.

00:34:54.440 --> 00:35:02.450
You can traverse the registry in the
way described here to get at this.

00:35:02.449 --> 00:35:08.019
Okay, so that's about new features in Leopard.

00:35:08.019 --> 00:35:14.400
For those of you who are developing ABC firewire
devices, if you only take one thing away from this talk,

00:35:14.400 --> 00:35:18.050
I want you to listen to the next part, okay?

00:35:18.050 --> 00:35:21.590
We've provided a facility for a
vendor specific override kext.

00:35:21.590 --> 00:35:25.920
And what this does is it provide
information to the driver that allows you

00:35:25.920 --> 00:35:32.400
to tune the driver's behavior to
the performance of your device.

00:35:32.400 --> 00:35:41.230
We strongly recommend that if you're shipping ABC firewire
devices today, sorry ABC firewire audio devices today,

00:35:41.230 --> 00:35:44.050
you look at implementing an override kext.

00:35:44.050 --> 00:35:48.100
We're undecided as to whether we want to
bundle all of these up and ship them in the OS.

00:35:48.099 --> 00:35:53.429
It seems like it's a good idea, but we don't want to be in
the position where we're writing these for your devices.

00:35:53.429 --> 00:36:02.190
You guys understand how your devices work, so you know, it
would be good for you to consider implementing one of these.

00:36:02.190 --> 00:36:09.340
The types of things that you can provide, kind
of latency in terms of safety offsets for input

00:36:09.340 --> 00:36:12.470
and output for each sample rate on your device.

00:36:12.469 --> 00:36:21.969
You can also do some performance tuning for G fours, because
we understand that on less capable processor you may need

00:36:21.969 --> 00:36:27.569
to fuss with your safety offsets in
order to make your device work well.

00:36:28.739 --> 00:36:33.169
So what I want to talk through very briefly
is how do you implement one of these.

00:36:33.170 --> 00:36:34.880
And it's pretty straight forward.

00:36:34.880 --> 00:36:43.510
We've provided some sample code, the hot code on the
sample codes where there's a URL to get it right here.

00:36:43.510 --> 00:36:47.470
I encourage you to take a look at this and try building one.

00:36:47.469 --> 00:36:53.209
So we're gonna make one for you know, we're gonna
assume that your company name is My Great Company,

00:36:53.210 --> 00:36:59.289
and the vendor ID is given there, and you have a firewire
device which we've called My Great Firewire device.

00:36:59.289 --> 00:37:04.250
We had other names in here, but
we didn't want people to sue us.

00:37:04.250 --> 00:37:07.489
So first step is take a look at the header file.

00:37:07.489 --> 00:37:13.649
And you're gonna want to make sure
that you update this for your company.

00:37:13.650 --> 00:37:22.269
A note is that this definition is also used in the P
list file, so you're gonna need to update to there.

00:37:22.269 --> 00:37:28.630
Second step in the source code you're
gonna want to change the class definition.

00:37:29.840 --> 00:37:34.460
You also want to publish the devices that
are actually supported by this override kext.

00:37:36.139 --> 00:37:41.219
In the P list file you're gonna
want to update the bundle executable

00:37:41.219 --> 00:37:44.579
and bundle identifier to your vendor specific names.

00:37:46.039 --> 00:37:49.449
And for each supported device you
want to add device matching

00:37:49.449 --> 00:37:54.199
and latency information in the IO kit personality section.

00:37:59.289 --> 00:38:07.259
Also you're gonna want to specify your input and
output latencies and samples for your device.

00:38:10.739 --> 00:38:14.959
You can also add G four specific settings,
and you may want to do this, you know,

00:38:14.960 --> 00:38:18.340
you'll probably want to test on a variety of computers.

00:38:18.340 --> 00:38:22.610
And I, in thinking about this, and
this didn't really occur to me,

00:38:22.610 --> 00:38:27.140
but we probably want to explicitly
say what the quote default things are,

00:38:27.139 --> 00:38:32.420
because obviously things are gonna get faster in
the future, and there may actually be a time where,

00:38:32.420 --> 00:38:36.730
when we want to determine whether we'll be
running on a G five or an Intel core duo,

00:38:36.730 --> 00:38:39.780
or whatever things are coming in the future.

00:38:39.780 --> 00:38:44.780
Now you know, the important thing is
you know, we recognize that you know,

00:38:44.780 --> 00:38:48.750
some of our developers are shipping
multiple different firewire devices.

00:38:48.750 --> 00:38:56.380
You can do a single kext, you can call out your
product specifically in the IO kit personality section

00:38:56.380 --> 00:39:00.550
so that you know, per company you
only need one of these override kext,

00:39:00.550 --> 00:39:04.950
and it can be updated on your website
as you ship new devices.

00:39:06.530 --> 00:39:13.880
You also obviously need to set up your
bundle name in the P list strings file.

00:39:13.880 --> 00:39:22.309
Make sure you mess with your target settings in your
project, and then just clean old build and it'll just work.

00:39:22.309 --> 00:39:29.759
If you have any issues with this, or you have questions
or comments, and we're very interested in comments,

00:39:29.760 --> 00:39:35.890
the people who are responsible for writing this are
Hawk and Matt, come up and talk to us at the end.

00:39:35.889 --> 00:39:39.589
Or you can reach us via email, and we've
got some contacts at the end of the session.

00:39:39.590 --> 00:39:42.870
But like I say, if this is the only
thing you take away from this session,

00:39:42.869 --> 00:39:46.799
and you're a firewire audio developer,
I'll be a happy bunny.

00:39:47.840 --> 00:39:54.620
Last thing I want to talk about is
networking ABC audio devices together.

00:39:54.619 --> 00:40:02.339
So we recognize that the audio interface
market is kind of a weird and wacky place.

00:40:02.340 --> 00:40:06.350
And really there's a ton of boxes on a rope
(inaudible) expression on both USB and firewire.

00:40:06.349 --> 00:40:07.299
And this works well.

00:40:07.300 --> 00:40:14.960
I mean you know, the vast majority of people
just want to get audio into their computer,

00:40:14.960 --> 00:40:20.250
and get audio out of their computer once they've done
something with it, and listen to it on monitor speakers.

00:40:20.250 --> 00:40:25.460
But we know that in a studio setting
this isn't an ideal situation.

00:40:25.460 --> 00:40:31.820
And particularly having the computer as the center
of a star hub for audio devices is undesirable,

00:40:31.820 --> 00:40:38.840
because we know that you know, if you're coming in fire
high speed serial port, and you've got to do a kernel

00:40:38.840 --> 00:40:43.039
to use a space transition, do some processing and
use a space, and go back down through the kernel

00:40:43.039 --> 00:40:45.909
to your device, you're gonna have latency.

00:40:45.909 --> 00:40:47.219
It's just the way it is.

00:40:47.219 --> 00:40:52.619
We know the you know, devices when they're
talking to each other have much lower latency.

00:40:52.619 --> 00:40:57.889
So what we want to do is figure
out well how can we do a studio?

00:40:57.889 --> 00:41:04.809
And what we want to talk about is a scenario for
example where you may have a source of audio,

00:41:04.809 --> 00:41:12.710
you come into a A two D converter, that converts to digital,
sticks it on the firewire bus, sends it to another device

00:41:12.710 --> 00:41:16.440
for processing, and then sends the
processed audio to the computer.

00:41:16.440 --> 00:41:21.440
So we have a real peer to peer network, and the
network could be a lot more complex than this,

00:41:21.440 --> 00:41:24.309
and all devices could talk to other devices.

00:41:24.309 --> 00:41:28.869
And we want to talk about how we can get there.

00:41:28.869 --> 00:41:32.259
So I want to bring up Ashley, who's been doing some work

00:41:32.260 --> 00:41:38.530
with the ABC video services library
the firewire team have produced.

00:41:38.530 --> 00:41:42.620
And he's gonna talk about some sample code that
we want to release through the firewire SDK

00:41:42.619 --> 00:41:46.489
so that you guys can play with
this and give us your comments.

00:41:46.489 --> 00:41:48.509
So welcome Ashley.

00:41:48.510 --> 00:41:53.210
( applause )

00:41:53.210 --> 00:41:54.079
>> Thanks Nick.

00:41:54.079 --> 00:42:01.230
As those of you who are familiar with the ABC specifications
are aware, ABC is built around a peer to peer network.

00:42:01.230 --> 00:42:06.449
The way the current firewire driver is implemented,
it wants to be the center of the universe.

00:42:06.449 --> 00:42:12.239
So when a device is discovered, it detects
it, captures it, starts talking to it,

00:42:12.239 --> 00:42:15.839
and basically means nobody else can use it.

00:42:15.840 --> 00:42:23.559
So if we stop the driver from doing its matching,
we can let other apps in to talk to the devices.

00:42:23.559 --> 00:42:25.440
And one of these is networking.

00:42:25.440 --> 00:42:27.659
Why are we doing this in firewire?

00:42:27.659 --> 00:42:31.179
Well we're doing this on firewire
because USB is host dependent.

00:42:31.179 --> 00:42:33.769
Everything has to go through the host processor.

00:42:33.769 --> 00:42:37.590
So everything's there, it's nowhere to go peer to peer.

00:42:37.590 --> 00:42:42.039
Firewire however, is host diagnostic, so we
can have all the multiple devices on the bus,

00:42:42.039 --> 00:42:47.179
and let them be networked together, and the audio
does not have to go through the Mac on each hop.

00:42:47.179 --> 00:42:56.169
So what I'll like to show you now is a technology
demo of the work we've been doing on the networking.

00:42:56.170 --> 00:43:00.090
So the software we've written is in two parts.

00:43:00.090 --> 00:43:07.860
There's a, let me just maximize this, daemon, which does
all the device matching, handles all the communications

00:43:07.860 --> 00:43:12.190
with the devices, and is the central thing of the app.

00:43:12.190 --> 00:43:18.590
So we have three Apple (inaudible) sitting here,
and the daemon has gone out, looked up a registry,

00:43:18.590 --> 00:43:26.190
found all the devices, and created a
connection, grabbed the device descriptors,

00:43:26.190 --> 00:43:31.340
and worked out what plug formats are
supported, how many streams, how many,

00:43:31.340 --> 00:43:34.840
what are all the sample rates,
and all the details of the device.

00:43:34.840 --> 00:43:39.840
So we can now, through the power of
Leopard, switch over to our GUI app.

00:43:39.840 --> 00:43:43.910
So what we have here is some graphical
representations of each device.

00:43:43.909 --> 00:43:48.039
So we have three ensembles here
which are Fred, Barney, and Wilma.

00:43:48.039 --> 00:43:59.880
So through our inspector you can see here that you can give
your device a new nickname, you can allow the device to come

00:43:59.880 --> 00:44:02.519
up in (inaudible) as though we
hadn't stopped the device matching

00:44:02.519 --> 00:44:07.250
in the current driver, and you can get the GUIds up.

00:44:07.250 --> 00:44:12.429
If the vendor has written a plug in for the
device that we support, a plug in architecture,

00:44:12.429 --> 00:44:20.369
you can have your own user interface in here, and allow
you to do your vendor specific user interface and commands.

00:44:20.369 --> 00:44:22.619
So that's great.

00:44:22.619 --> 00:44:24.359
Now we need to get some audio.

00:44:24.360 --> 00:44:34.200
So what we can do is drag out an audio
stream, might help if I start the audio.

00:44:34.199 --> 00:44:37.049
( background music )
And now we've connected the audio stripe from Fred to Wilma,

00:44:37.050 --> 00:44:40.810
doesn't go anywhere near the Mac,
it's straight on the bus only.

00:44:40.809 --> 00:44:46.130
What we can also do is stream to multiple devices.

00:44:46.130 --> 00:44:51.140
So we've just overlayed a second
connection onto this existing stream,

00:44:51.139 --> 00:44:55.339
and allowed the second device access to the stream.

00:44:55.340 --> 00:45:01.410
Now if one of these devices was a DSP box, so
in this example we'll use Barney as a DSP box,

00:45:01.409 --> 00:45:11.730
we can actually stream that audio through the DSP box,
and it, we now have a low latency pipeline, DSP pipeline.

00:45:11.730 --> 00:45:15.519
We don't have any latency at each hop through the Mac.

00:45:15.519 --> 00:45:18.150
Now there are some limitations to this.

00:45:18.150 --> 00:45:24.590
Current devices only support talking
in their current native stream format.

00:45:24.590 --> 00:45:28.430
So if you have devices which do
not support this stream format,

00:45:28.429 --> 00:45:31.940
of the same stream format, they won't talk to each other.

00:45:31.940 --> 00:45:41.440
So we have come around, up with a little user
space solution where we can create from Fred

00:45:41.440 --> 00:45:49.860
to Wilma a little streaming connection
which comes up back into the Mac,

00:45:49.860 --> 00:45:56.760
and goes through, and produces a plug format change.

00:45:56.760 --> 00:46:01.110
We can also use it to change the stream mapping.

00:46:01.110 --> 00:46:12.660
So let me just, so we have audio going into
these devices on channels four and five.

00:46:12.659 --> 00:46:19.019
We can drop that off and the audio's gone away,
because we're no longer mapping those channels.

00:46:19.019 --> 00:46:22.679
And if we had audio we could map
them around to other channels.

00:46:22.679 --> 00:46:32.409
So for those of you that can see the meters on the front,
you'll notice that it's now going into channels one

00:46:32.409 --> 00:46:36.389
and two rather than, or zero one rather than four and five.

00:46:36.389 --> 00:46:42.719
So this is a little demo of a small set
of the features that we currently support.

00:46:43.750 --> 00:46:52.869
And I just need to, get out of there.

00:46:52.869 --> 00:46:55.389
Okay, can I have the slides back please?

00:46:59.480 --> 00:47:00.519
So what did we just see?

00:47:00.519 --> 00:47:04.519
Well we just saw a streaming of
audio directly between the devices,

00:47:04.519 --> 00:47:08.690
without it going anywhere near the
Mac, except in the remapper case.

00:47:08.690 --> 00:47:12.470
So we can create a low latency DSP pipeline with this.

00:47:12.469 --> 00:47:18.949
There is no latency introduced at each hop by the
audio coming into and going back out of the Mac.

00:47:18.949 --> 00:47:25.439
And we can flexibly route audio, so you can go from one
device to multiple devices, one device to one device.

00:47:25.440 --> 00:47:31.470
And you can have any number of
streams established on the bus.

00:47:31.469 --> 00:47:42.759
So in the DSP pipeline case what we saw was audio going into
the input device, onto the bus, into the DSP processing box,

00:47:42.760 --> 00:47:50.580
being processed, and being put back out onto the bus,
and then out the output device, and into the speakers.

00:47:50.579 --> 00:47:56.590
So I showed you two of the parts of this,
there is a command line client as well.

00:47:56.590 --> 00:48:01.309
So the daemon sits on top of IO kit
of course, to do device matching,

00:48:01.309 --> 00:48:08.079
the ABC video services which provides all the ABC device
descriptor parsing, all the communications with the device,

00:48:08.079 --> 00:48:13.489
and the Apple firewire audio driver which
provides the core audio integration.

00:48:13.489 --> 00:48:18.449
And of course (inaudible) so that we can
get lovely Cocoa distributed objects.

00:48:18.449 --> 00:48:28.309
The GUI client sits on top of Cocoa so we can get
the distributed objects, and the Cocoa code base,

00:48:28.309 --> 00:48:31.710
and all the graphics in that demo
are done with core animation.

00:48:31.710 --> 00:48:33.929
So all the fancy animations come for free.

00:48:33.929 --> 00:48:38.859
And the command line client of
course sits on top of the foundation.

00:48:38.860 --> 00:48:41.550
So how did it work for the device discovery?

00:48:41.550 --> 00:48:50.130
Well IO kit uses space matching, looks for ABC unit,
subunits, and once we find one, we get a notification,

00:48:50.130 --> 00:48:54.470
and the code base reads the device descriptors.

00:48:54.469 --> 00:48:57.909
Once it's read the device descriptors,
worked out what the device supports

00:48:57.909 --> 00:49:03.460
and created its little internal representation,
it notifies any attached clients and daemons

00:49:03.460 --> 00:49:09.230
that there's this new device available,
and it pops up the nice pretty picture.

00:49:09.230 --> 00:49:18.159
When a device is removed, the, also receives a message
from IO kit, and the device, the daemon automatically tears

00:49:18.159 --> 00:49:24.929
down all the connections established for that device, so you
don't get any screeching or other missing audio features.

00:49:24.929 --> 00:49:29.579
And once it's done that, it notifies
the clients and daemons that it's gone.

00:49:29.579 --> 00:49:35.920
So the (inaudible) streams that are used for
carrying the audio over the bus have to be allocated,

00:49:35.920 --> 00:49:38.030
there's only a certain amount of bandwidth.

00:49:38.030 --> 00:49:43.840
We're using only new Leopard isochronous
resource manager API to do that allocation,

00:49:43.840 --> 00:49:50.820
and it's the daemon that is responsible for allocating
and assigning all those streams to the devices.

00:49:52.500 --> 00:49:53.639
So what does it work with?

00:49:53.639 --> 00:49:56.609
Well it only works with ABC standards compliant devices.

00:49:56.610 --> 00:50:00.930
If it's not a standards compliant device,
we can't discover it and talk to it.

00:50:00.929 --> 00:50:06.089
And at this stage it requires that the input
and output plugs have the same stream format.

00:50:06.090 --> 00:50:08.809
If it's different we can't talk to it.

00:50:08.809 --> 00:50:14.519
While the spec actually supports the
devices listening in on certain channels,

00:50:14.519 --> 00:50:20.059
no device manufacturer has currently actually
implemented that part of the spec. A future version

00:50:20.059 --> 00:50:25.529
of the ABC specification that we're currently
working on clarifies this point more,

00:50:25.530 --> 00:50:29.170
and will hopefully allow us to do this in the future.

00:50:29.170 --> 00:50:37.710
In the meantime we have the interim solution of the user
space remapper, which we'll be releasing the code to.

00:50:37.710 --> 00:50:41.300
So we'd like to get some of this
stuff in an upcoming firewire SDK,

00:50:41.300 --> 00:50:47.200
so the source code for the demo app will
be included so you can play with it.

00:50:47.199 --> 00:50:55.789
A new little tool, a format switcher which allows us
to automatically stop and start the device matching

00:50:55.789 --> 00:51:02.199
in the driver, and allows us to
run other user space applications.

00:51:02.199 --> 00:51:08.079
After running this tool you must restart the
computer so that IO kit updates its kext cache.

00:51:09.139 --> 00:51:13.079
In ABC video services we're planning
to get a couple of additions.

00:51:13.079 --> 00:51:18.279
So ABC info is a new command line
tool that reads device descriptors.

00:51:18.280 --> 00:51:20.850
This is the same code used in the demo.

00:51:20.849 --> 00:51:29.269
It creates a P list representation of all the data its
read, and it allows you to verify your device descriptors.

00:51:29.269 --> 00:51:35.670
So if it crashes or produces an empty dictionary,
it's encountered an error in the descriptor,

00:51:35.670 --> 00:51:37.780
and obviously you've got something to fix.

00:51:37.780 --> 00:51:42.350
There's a new universal transmitter,
which is used by the (inaudible) mapper.

00:51:42.349 --> 00:51:46.809
It allows you to transmit any data on an isochronous stream.

00:51:46.809 --> 00:51:50.759
It uses callbacks to populate its outgoing packets.

00:51:50.760 --> 00:51:52.690
So anybody can really use it.

00:51:52.690 --> 00:51:58.130
And we include the sourcecode for the IRE mapper
which uses the existing universal receiver,

00:51:58.130 --> 00:52:03.680
and the universal transmitter to
do user space audio streaming.

00:52:03.679 --> 00:52:06.429
So what we would like from you after all this.

00:52:06.429 --> 00:52:08.399
Well we'd like you to use standards compliant firmware.

00:52:08.400 --> 00:52:11.740
If it's standards compliant, we can talk to it

00:52:11.739 --> 00:52:14.759
Implement the ABC music plugs in the specification.

00:52:14.760 --> 00:52:22.840
That will allow us to stream different stream formats from
any device to your device, and specify which channels we'd

00:52:22.840 --> 00:52:29.050
like you to use on what plugs and external outputs.

00:52:29.050 --> 00:52:32.460
And experiment with this demo code when it comes out.

00:52:32.460 --> 00:52:39.880
Use it to network your devices, tell us about our
bugs, play with it, expand it, tell us what you want.

00:52:39.880 --> 00:52:46.539
Write plug ins for your devices so that we can get you
know, more support for your vendor specific commands.

00:52:46.539 --> 00:52:52.440
It also functions as a great test point while
you're building your vendor specific commands,

00:52:52.440 --> 00:52:59.610
because it will not kernel panic your system when
something goes wrong, it will just crash the user space.

00:52:59.610 --> 00:53:05.570
So I'd like to hand it back to Nick now for a summary.

00:53:05.570 --> 00:53:05.820
>> Cool.

00:53:05.820 --> 00:53:06.460
( applause )

00:53:06.460 --> 00:53:07.659
>> Thanks (inaudible).

00:53:09.539 --> 00:53:15.150
So I'd really like to recognize the work of the firewire
team, and particularly Andy Annowitz (assumed spelling)

00:53:15.150 --> 00:53:19.650
for the ABC video services library, and
also the work that Ashley's been doing

00:53:19.650 --> 00:53:22.440
over the last five or six months on this app.

00:53:22.440 --> 00:53:29.280
Because we think this is a really interesting direction,
and we hope if you're doing firewire devices you will too.

00:53:29.280 --> 00:53:33.360
Okay, so let's cover what we've covered.

00:53:33.360 --> 00:53:37.420
Okay, so we ran through USB audio class two point oh topics.

00:53:37.420 --> 00:53:42.340
And if you're developing a USB two point oh
audio device, please stay for the Q and A,

00:53:42.340 --> 00:53:44.670
or come up at the end and introduce yourself.

00:53:44.670 --> 00:53:50.340
We want to meet you, we want to help you
in terms of getting your script to write,

00:53:50.340 --> 00:53:53.430
and making sure that our driver works well with your device.

00:53:53.429 --> 00:53:58.319
We talked about (inaudible) features,
new features in Leopard.

00:53:58.320 --> 00:54:01.880
Rewritten streaming engines are big news.

00:54:01.880 --> 00:54:08.829
The override kext for tuning the parameters of
your devices and networking devices together,

00:54:08.829 --> 00:54:12.460
which we see as an important technology demo.

00:54:13.829 --> 00:54:15.730
What should you do?

00:54:15.730 --> 00:54:22.760
Well, the biggest thing is work with Apple to make
sure that you have correct device descriptors.

00:54:22.760 --> 00:54:31.230
We've worked with almost every developer of standards
based devices before they ship their device to ensure

00:54:31.230 --> 00:54:36.650
that we can accurately parse their device
descriptors, both on USB and firewire.

00:54:36.650 --> 00:54:41.599
We want to continue doing that, we're not looking out
for free hardware, we're happy to buy hardware from you.

00:54:41.599 --> 00:54:46.380
But what we do want to make sure is that your
device is well supported on our platform.

00:54:46.380 --> 00:54:53.920
For firewire devices, please if you take one
thing, write an override kext, very important.

00:54:53.920 --> 00:55:00.230
That allows us to get the best possible
performance through core audio to your device.

00:55:00.230 --> 00:55:01.940
Take a look at the networking thing.

00:55:01.940 --> 00:55:04.139
We're really interested in comments from developers.

00:55:04.139 --> 00:55:11.049
We know that some of the IO box developers are really
interested in developing firewire signal processing products

00:55:11.050 --> 00:55:14.400
that complement their IO products really well.

00:55:14.400 --> 00:55:16.539
You know, we'd be happy to help you do that.

00:55:16.539 --> 00:55:24.250
What I'd love to see is a whole ecosystem of
interconnectable firewire devices from multiple vendors.

00:55:24.250 --> 00:55:28.559
There's been attempts at networking, both on
firewire and on other transports in the past.

00:55:28.559 --> 00:55:33.340
They've always degenerated because one company wants
to control it, and they want to control information,

00:55:33.340 --> 00:55:36.780
or they want to license it, or
they want to get a revenue from it.

00:55:36.780 --> 00:55:39.190
We don't care, we'll give you the code.

00:55:39.190 --> 00:55:42.510
It's free, go implement it.

00:55:43.519 --> 00:55:47.130
The other thing is if you have a user client,
look at the (inaudible) as a client routine.

00:55:47.130 --> 00:55:50.750
Make sure that you're setting up connections
properly, and make sure if appropriate,

00:55:50.750 --> 00:55:58.989
if you have UI apps that you provide a help log
in to give the best possible UI to your users.

00:55:58.989 --> 00:56:02.549
And then you know, again, if you're
working on a device, let us know.

00:56:02.550 --> 00:56:06.550
Like I say, you know, our team's happy to buy
hardware from you, we're not looking for freebies,

00:56:06.550 --> 00:56:10.870
we just want to get the best possible
experience for your users.

00:56:10.869 --> 00:56:13.750
Where should you go for more information?

00:56:13.750 --> 00:56:19.170
Well there's two points of contact that are huge, and I
strongly encourage you if you're not already doing this,

00:56:19.170 --> 00:56:21.960
to build a relationship with the two people on this slide.

00:56:21.960 --> 00:56:23.579
Craig Keathley's a great guy.

00:56:23.579 --> 00:56:27.119
I don't know if he's here, but
I know he's at the conference.

00:56:27.119 --> 00:56:33.000
Craig is the IO technologies evangelist,
he looks after USB and firewire devices.

00:56:33.000 --> 00:56:36.400
Definitely make sure Craig is aware of your plans.

00:56:36.400 --> 00:56:40.130
He can hook you up with the right people at
Apple, because the right people's not always us.

00:56:40.130 --> 00:56:45.700
You might not be doing a class compliant device, but
you should be talking to the USB and the firewire team.

00:56:45.699 --> 00:56:48.049
The other person you should be talking to, particularly

00:56:48.050 --> 00:56:52.090
if you have application software
running on Mac OS ten is Craig Linson.

00:56:52.090 --> 00:56:55.030
Craig is, two Craigs.

00:56:55.030 --> 00:56:57.130
So Keathley and Linson.

00:56:57.130 --> 00:57:02.690
Craig is the music and audio technology evangelist, I
strongly encourage you to build a relationship with Craig.

00:57:02.690 --> 00:57:06.250
And you know, if you're working on software
products, give him copies of the products.

00:57:06.250 --> 00:57:11.659
If you're a hardware developer let Craig know about
your product range, send him URLs to your website,

00:57:11.659 --> 00:57:13.949
just keep Craig aware of your product releases.

00:57:13.949 --> 00:57:18.429
If you keep these two guys up to date, they can
help connect you with other people in Apple.

00:57:18.429 --> 00:57:24.239
And then again, you know, the (inaudible)
for the override kext is

00:57:24.239 --> 00:57:29.229
in the attendee part of the WWDC portion of Apple's website.
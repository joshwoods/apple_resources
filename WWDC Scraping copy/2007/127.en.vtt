WEBVTT

00:00:18.280 --> 00:00:27.120
>> My name is Ned Holbrook and I'm a software engineer
working on text layout at Apple, so let's get started.

00:00:27.120 --> 00:00:34.950
So this morning we are talking about several things.

00:00:34.950 --> 00:00:40.800
We decided to plan this session with
sort of a variety of the groups in mind.

00:00:40.799 --> 00:00:49.769
So, if you're coming to the Mac OS X platform from say
Windows, then you'll see that we've interspersed some sort

00:00:49.770 --> 00:00:54.020
of signposts throughout so you can kind of
get your bearings with Core Text relative

00:00:54.020 --> 00:00:56.370
to what you've been working with on Windows.

00:00:56.369 --> 00:01:04.549
Also, if you have come to our Core
Text session last year, then you'll --

00:01:04.549 --> 00:01:10.920
we've tried to beef things up a bit by showing
you a bit more about how Core Text interacts

00:01:10.920 --> 00:01:18.769
in a real world application with other frameworks and so
that's kind of what we're going to be doing this morning.

00:01:18.769 --> 00:01:22.829
I would start off by saying that,
if you haven't done so already,

00:01:22.829 --> 00:01:27.799
I highly recommend taking a look at
our Core Text session from last year.

00:01:27.799 --> 00:01:33.979
We're going to start off with an overview of Core Text but
it's nowhere near as detailed as the presentation we gave

00:01:33.980 --> 00:01:41.400
at WWDC06 but those slides and that talk are available
online so, if you haven't done so, go ahead and look that up

00:01:41.400 --> 00:01:47.650
at some point and you'll see a very
detailed overview of Core Text in Leopard.

00:01:47.650 --> 00:01:51.390
But we're going to start off by giving you a
quick overview so we can remind ourselves of some

00:01:51.390 --> 00:01:53.000
of the terms that we're going to be using.

00:01:53.000 --> 00:02:01.710
Then we're going to talk more generally about text and
fonts on Mac OS X and best practices for dealing with those.

00:02:01.709 --> 00:02:11.019
We're going to spend particular attention with
drawing, inputting and some minutia about saving text

00:02:11.020 --> 00:02:19.540
and font information in documents and, of course, this
is a hands on session so, if you haven't done so already,

00:02:19.539 --> 00:02:29.180
please go ahead and access the session website for Session
127 and there's a download called Core Text Arc Hands On

00:02:29.180 --> 00:02:36.270
and we are actually going to be walking
through that sample application as we go.

00:02:36.270 --> 00:02:46.900
So -- so if -- if you are looking for something else, I'll
point out that this afternoon there's a Cocoa text session

00:02:46.900 --> 00:02:54.219
that goes into some amount of detail in
extending the Cocoa text system and in particular

00:02:54.219 --> 00:03:01.189
if you're Mac OS X application programmer who's
dealt with QuickDraw or ATSUI and are interested

00:03:01.189 --> 00:03:03.949
in how you might convert Core Text in your application,

00:03:03.949 --> 00:03:10.079
then there's also a session this afternoon
following the Cocoa session about making the switch,

00:03:10.080 --> 00:03:17.680
but I'll assume that we have all of our hands on projects
ready and let's go ahead and get started by taking a look

00:03:17.680 --> 00:03:21.099
at the application that we're going
to be working with and so to do so I'd

00:03:21.099 --> 00:03:23.469
like to bring Nathan Taylor on stage, Nathan.

00:03:23.469 --> 00:03:28.509
>> Thanks, Ned, can we switch to demo one, please.

00:03:29.639 --> 00:03:31.189
All right.

00:03:31.189 --> 00:03:35.829
So this is where we're going to start. I'm going
to show you a quick look at this application

00:03:35.830 --> 00:03:37.560
that we've put together for the hands on.

00:03:37.560 --> 00:03:41.670
If you've downloaded the hands on material you'll
see that I have it broken down into six steps,

00:03:41.669 --> 00:03:45.679
and I'm just going to give you a start by letting
you see what the finished product looks like here.

00:03:45.680 --> 00:03:52.240
So let's run this guy and as you can see we
have an application and we're using Core Text

00:03:52.240 --> 00:03:58.030
to draw text along an arc in the application, you know,
the drawing and the rotations are all graphical operations

00:03:58.030 --> 00:03:59.939
and you'll see that when you look at the code.

00:03:59.939 --> 00:04:04.169
This is also a live application
with all the niceties you'd expect

00:04:04.169 --> 00:04:08.119
for the user interaction, so we
have live update of the text.

00:04:08.120 --> 00:04:11.090
If I type here, we update live.

00:04:11.090 --> 00:04:17.030
I have interactions with font control, so I have these bold
and italic check boxes and you notice we update them based

00:04:17.029 --> 00:04:24.639
on the status of the font, and I also have integration
with the font panel so the user can change the font

00:04:24.639 --> 00:04:30.339
and even support multiple Windows with live updates of
fonts and, if we have time, I'll show you these options

00:04:30.339 --> 00:04:36.139
that I have hooked up here at the end that use
some of the Core Text details to, you know,

00:04:36.139 --> 00:04:43.039
detect when we substitute fonts, you know,
draw glyph metrics and draw line metrics.

00:04:43.040 --> 00:04:47.740
With that I hope you've downloaded the
demonstration and I'll hand the session back

00:04:47.740 --> 00:04:51.360
over to Ned to give you the Core Text overview.

00:04:52.569 --> 00:04:55.189
>> Thanks, Nathan, could we switch back to slides.

00:04:59.750 --> 00:05:03.040
Great. So like I mentioned, we're going
to start off by giving a quick rundown

00:05:03.040 --> 00:05:06.430
of the talk we gave at our session last year.

00:05:06.430 --> 00:05:11.579
So this is one of the slides that I pulled up, this
is kind of the tech marketing speak about Core Text

00:05:11.579 --> 00:05:16.709
but what I wanted to do instead of going through these
points again because you have access to those slides,

00:05:16.709 --> 00:05:21.089
is to go ahead and just -- just refresh
your mind as to what Core Text actually is.

00:05:21.089 --> 00:05:27.560
For Windows programers in the audience you can
think of Core Text as being similar to Uniscribe

00:05:27.560 --> 00:05:37.180
and that is what it does is Unicode Text Layout and some
font management. So Unicode Text Layout essentially means

00:05:37.180 --> 00:05:49.310
that in Unicode rather than having a one-to-one mapping from
characters to glyphs, we have a many-to-many relationship

00:05:49.310 --> 00:05:55.300
and so the process of Unicode Text Layout then
is the process of converting from characters,

00:05:55.300 --> 00:05:59.660
the numeric representation of text, into positioned glyphs.

00:05:59.660 --> 00:06:07.330
Glyphs, of course, being the graphical atoms in a
font that are used to render text and so when we talk

00:06:07.329 --> 00:06:13.319
about text layout it's that process of conversion
from text and some style information to glyphs

00:06:13.319 --> 00:06:15.719
and their positions relative to one another.

00:06:15.720 --> 00:06:21.760
And Core Text also includes a great set
of utilities for working with fonts.

00:06:21.759 --> 00:06:29.689
So let's go ahead and talk about very briefly the major
classes that you're going to deal with in Core Text.

00:06:29.689 --> 00:06:35.649
The highest level one and the one that for
many tasks is sufficient is the Framesetter

00:06:35.649 --> 00:06:38.359
and the Framesetter is responsible
for filling frames with text.

00:06:38.360 --> 00:06:42.139
So essentially you have a box and
you want to put some text in it.

00:06:42.139 --> 00:06:44.990
Usually this could be multiple paragraphs of text.

00:06:44.990 --> 00:06:48.019
You could have multiple styles, anything you want.

00:06:48.019 --> 00:06:56.680
You can even flow text from one frame to the next, the frame
being the object that is created to hold these text boxes

00:06:56.680 --> 00:07:03.290
and so in order to do so the Framesetter
makes use of a class called the Typesetter.

00:07:03.290 --> 00:07:07.939
Now primarily the Typesetter is responsible
for the actual text layout process,

00:07:07.939 --> 00:07:14.579
that conversion to glyphs I was talking about, but another
crucial feature that it offers and one that's essential

00:07:14.579 --> 00:07:21.139
for something like the Framesetter or yourself
is determining where line breaks are in text.

00:07:21.139 --> 00:07:25.750
So you can think of text as having been laid out into a
giant line of text and for each line that you're going

00:07:25.750 --> 00:07:32.069
to draw you're going to see how much text is going to fit in
a certain width and you're going to then use the Typesetter

00:07:32.069 --> 00:07:36.800
after it's suggested a line break to you to create a line,

00:07:36.800 --> 00:07:40.920
and a line is pretty much self-explanatory
it's a line of text.

00:07:40.920 --> 00:07:51.780
It can be of multiple styles and directions of text and the
line is comprised of a series of glyph runs and each one

00:07:51.779 --> 00:07:58.019
of these glyph runs contains those
positioned glyphs grouped by style.

00:07:58.019 --> 00:08:06.979
So when a run is drawn either by yourself or by Core Text,
you can be assured that the graphic style that you're going

00:08:06.980 --> 00:08:13.370
to use in order to render those glyphs is
the same for every glyph in a particular run.

00:08:13.370 --> 00:08:20.340
So now that we have our overview of Core Text in hand, a
good refresh from last year, let's jump straight to drawing.

00:08:20.339 --> 00:08:26.989
Now the reason I want to do this is because Core
Text, of course, is tied intimately to Quartz

00:08:26.990 --> 00:08:35.080
which is the graphics rendering mechanism for Mac OS X.
It's used pervasively and so I thought especially for people

00:08:35.080 --> 00:08:41.410
who were coming from a Window perspective we
might as well just give a quick overview of how

00:08:41.409 --> 00:08:45.529
to think about text with regards to Quartz.

00:08:45.529 --> 00:08:52.649
So the major differences from other graphic systems
are, of course, primarily coordinate spaces.

00:08:52.649 --> 00:08:58.720
Quartz offers freely transformable coordinate
spaces which is a great convenience to have

00:08:58.720 --> 00:09:06.160
since it's a resolution independent graphics mechanism
and so you can think of those as being GDI mapping modes

00:09:06.159 --> 00:09:14.819
in that you have your pick of, you know, the mapping
from your coordinate system to the actual display.

00:09:14.820 --> 00:09:21.170
Now there's two common orientations that we use
on Mac OS X, we call them normal and flipped.

00:09:21.169 --> 00:09:28.439
Normal, of course, is positive "y" going
up and flipped is positive "y" going down.

00:09:28.440 --> 00:09:33.010
So, if you've dealt with other raster
graphic packages such as GDI on Windows or QuickDraw

00:09:33.009 --> 00:09:39.580
on the Mac you may think that the flipped
coordinate system is the most natural but in Quartz we tend

00:09:39.580 --> 00:09:45.550
to use the normal coordinate system which is
the default coordinate system unlike the flipped

00:09:45.549 --> 00:09:50.109
which corresponds roughly to MM
text used by GDI but keep in mind

00:09:50.110 --> 00:09:53.480
that the coordinate spaces are
remappable; you have your choice.

00:09:53.480 --> 00:09:58.490
So we tend to think of things in normal but you
can do whatever you want but just keep this in mind

00:09:58.490 --> 00:10:03.710
because you may run into situations where
things go the other way and, of course,

00:10:03.710 --> 00:10:10.700
within that same frame of measurement all of your
measurements are floating point all the time.

00:10:10.700 --> 00:10:16.680
This corresponds quite closely to GDI+
on Windows which also uses real coordinates

00:10:16.679 --> 00:10:23.599
for measurement. This is incredibly handy when you're
dealing with resolution independence you can, of course,

00:10:23.600 --> 00:10:29.370
go straight to PDF or print or whatever and you have
the same coordinate system that you are dealing with,

00:10:29.370 --> 00:10:34.259
but I will just point out that being floating
point there are some bugaboos that may apply

00:10:34.259 --> 00:10:41.580
that don't necessarily apply when dealing with
integer map on a computer so keep that in mind.

00:10:41.580 --> 00:10:47.310
And then I also wanted to give a quick overview of the
line and glyph metrics that we tend to use in Core Text

00:10:47.309 --> 00:10:52.019
and Quartz and also the Cocoa text
system and other parts of the system.

00:10:52.019 --> 00:10:57.879
You'll see in this diagram that we have on
the slide here there are two different types

00:10:57.879 --> 00:11:01.029
of metrics; we have line metrics and glyph metrics.

00:11:01.029 --> 00:11:08.500
The line metrics are indicated in that orangish yellow
color and the glyph metrics are in the white color.

00:11:08.500 --> 00:11:18.440
And the -- the -- along the left side of the diagram
here these are the primary line measurements that we talk

00:11:18.440 --> 00:11:23.750
about when dealing with individual lines of
text, the ascent, the descent and the baseline.

00:11:23.750 --> 00:11:30.220
The baseline typically doesn't get a measurement of its own
but the relationship between the baseline and the ascent,

00:11:30.220 --> 00:11:36.430
of course, is the ascent measurement and then the difference
between the baseline and the descent is the descent value.

00:11:36.429 --> 00:11:40.929
When you're dealing with multiple lines of text and
trying to figure out how they are placed relative

00:11:40.929 --> 00:11:45.519
to one another other, you quite frequently encounter
the leading as well that is in the lower right

00:11:45.519 --> 00:11:50.419
and that's an additional amount of space
that's added typically between lines.

00:11:50.419 --> 00:11:58.899
Then common glyph metrics we refer to the advance width --
I say the advance width although sometimes we do shorten it

00:11:58.899 --> 00:12:06.470
to advance, but I say advance width here because
technically advance is a two dimensional measurement

00:12:06.470 --> 00:12:10.480
in that you could have a shift
vertically between adjacent glyphs

00:12:10.480 --> 00:12:16.019
but this advance width is the distance
you would conceptually move to get

00:12:16.019 --> 00:12:18.779
from one glyph to the next in a sequence.

00:12:18.779 --> 00:12:25.100
And then along the right we have a couple other
information data points, cap height and x height,

00:12:25.100 --> 00:12:29.800
these are less frequently used but especially in a graphics
context when you might be looking at doing some sort

00:12:29.799 --> 00:12:33.389
of vertical positioning of text these can come in handy.

00:12:33.389 --> 00:12:43.169
The reason I've separated them into line and glyph metrics
all of the line metrics correspond to individual fonts

00:12:43.169 --> 00:12:50.229
but in Core Text we group those so that, when
you request those measurements from a line,

00:12:50.230 --> 00:12:58.100
we give you an aggregate value so it's appropriate for
all of the different fonts in the line and all of the rest

00:12:58.100 --> 00:13:04.480
of the information, of course, can be gotten from fonts
directly and typically don't correspond to a line as a whole.

00:13:04.480 --> 00:13:10.759
And so with that admittedly brief overview, let's go
ahead and actually start drawing some text so, Nathan.

00:13:10.759 --> 00:13:11.759
>> All right.

00:13:11.759 --> 00:13:13.580
Please switch to demo one.

00:13:14.899 --> 00:13:15.919
Thanks, Ned.

00:13:15.919 --> 00:13:22.179
So what we have here is the start of the
Core Text Arc application and I'm starting

00:13:22.179 --> 00:13:28.609
with a Carbon application template from
Xcode and we're going to add things to it.

00:13:28.610 --> 00:13:32.690
As you see I already have some stubs for
some implementation files and headers

00:13:32.690 --> 00:13:36.740
and I also have a nib laid out at the beginning of step one.

00:13:36.740 --> 00:13:40.879
So let's take a look at this nib,
it defines our user interface

00:13:40.879 --> 00:13:45.409
and as you can see this is the basic layout of the window.

00:13:45.409 --> 00:13:50.769
We've got the HIView subclass that's
going to do our ArcView drawing

00:13:50.769 --> 00:13:54.730
and we have the check boxes and
text field for user controls.

00:13:54.730 --> 00:14:04.990
So to implement this we need to implement the ArcView
subclasses and HIView subclass and so I'm going to open

00:14:04.990 --> 00:14:09.720
up ArcView.h here and declare some things.

00:14:09.720 --> 00:14:12.950
So let me drop in the declarations we need.

00:14:12.950 --> 00:14:16.290
Now this is the basic HIView subclassing stuff.

00:14:16.289 --> 00:14:19.679
We have our class registration and everything else.

00:14:19.679 --> 00:14:25.509
What we're going to want to pay key attention to,
when I implement it, is the ArcViewDraw method here.

00:14:25.509 --> 00:14:29.460
This is what's going to do the drawing and this
is where we're going to use Core Text heavily.

00:14:29.460 --> 00:14:30.129
So we save that.

00:14:30.129 --> 00:14:32.559
I'm going to switch to the implementation file

00:14:32.559 --> 00:14:38.679
with the counterpart button here and
drop in our initial implementation.

00:14:41.230 --> 00:14:43.659
All right.

00:14:43.659 --> 00:14:48.459
Now look at the implementation and let's take
a look at some of the functions we have here.

00:14:48.460 --> 00:14:56.129
Basically, we have ArcViewCreate which is the
constructor for our HIView subclass and this is just setting

00:14:56.129 --> 00:15:02.360
up a structure that we have defined and of key interest
is, you know, we need a default font to get started

00:15:02.360 --> 00:15:07.269
so ArcViewCreateDefaultFont is our
first call we make to Core Text in here.

00:15:07.269 --> 00:15:13.470
We use CTFont, create with name give him the
default name and size and this will create a font

00:15:13.470 --> 00:15:17.160
that we'll use for our initial rendering.

00:15:17.159 --> 00:15:23.600
Below that we see ArcViewCreateWithString or
CreateAttributedString, sorry let me jump to that here

00:15:25.120 --> 00:15:32.000
and this is what's setting up the string that we're going
to draw and what we're doing is we're going to build

00:15:32.000 --> 00:15:35.840
up an AttributedString from a default
string and we're going to add our font to it.

00:15:35.840 --> 00:15:40.480
Those of you that are a student and are looking at the
code notice we have two attributes that we're using here.

00:15:40.480 --> 00:15:44.860
We also have the ligature attribute and we're going
to intentionally going to specify that to be zero

00:15:44.860 --> 00:15:51.110
to disable all ligature processing because drawing text
on an arc with ligatures isn't going to flow very well,

00:15:51.110 --> 00:15:53.909
so this is one of the tricks you
might want to take out from this talk.

00:15:53.909 --> 00:16:00.459
So we're going to create a dictionary with
our attributes and then given our string,

00:16:00.460 --> 00:16:06.120
we'll use CFAttributedStringCreate with our
string from the ArcView and these attributes

00:16:06.120 --> 00:16:09.139
and now that we have our AttributedString
let's go to where we do our drawing.

00:16:09.139 --> 00:16:13.490
I'll scroll this up a little bit so you can see.

00:16:13.490 --> 00:16:18.549
So now we'll putting this drawing
together like you would in any application.

00:16:18.549 --> 00:16:21.639
We're going to get someone to draw first and
then we'll worry about making into an arc.

00:16:21.639 --> 00:16:25.419
So the first thing we need to do is
we're going to set-up our context

00:16:25.419 --> 00:16:30.389
and as Ned mentioned we have flipped
and normal transforms on our context.

00:16:30.389 --> 00:16:37.330
HIView deals in the flipped context and for our purposes
here we want a normal context, so I'm going to translate

00:16:37.330 --> 00:16:46.700
and scale the CTM appropriately so we can draw and then
I'm going to use our method to create our AttributedString

00:16:46.700 --> 00:16:51.100
and then the next we'll use
CTLineCreateWithAttributedString

00:16:51.100 --> 00:16:53.930
with our AttributedString to create a line object.

00:16:53.929 --> 00:16:57.969
Now for this first step that's all we're
going to need to draw is our CTLine,

00:16:57.970 --> 00:17:02.870
as you'll see we'll call CTLineDraw
after setting the text position.

00:17:02.870 --> 00:17:09.019
It's important to note that Core Text will always draw the
line at the text position and as Ned may have mentioned

00:17:09.019 --> 00:17:14.680
that corresponds to the baseline
of the font metrics line metrics.

00:17:14.680 --> 00:17:23.840
So before we can actually get this to run, we need to do
one more thing and that's to actually register the class,

00:17:23.839 --> 00:17:30.279
so let's drop in this one line to register our subclass
here before we do anything else very imperative

00:17:30.279 --> 00:17:36.690
and we will build this and go and there
we go we're drawing our default text

00:17:36.690 --> 00:17:41.269
with the default font Dito
we specified and it doesn't do much else yet.

00:17:41.269 --> 00:17:48.639
So let's now take the next step, step two if you're
following along and get this thing drawing along the arc

00:17:48.640 --> 00:17:54.250
and all we're really going to do for this one is open up
ArcView.c and we're going to replace the implementation

00:17:54.250 --> 00:18:04.849
for ArcViewDDraw with an updated one
-- and I love how this jumps around --

00:18:04.849 --> 00:18:09.980
and there we go we'll save that off and I'll take
a quick look at it and walk you through again.

00:18:09.980 --> 00:18:14.470
So pretty much what we're doing here is the same.

00:18:14.470 --> 00:18:18.870
We still create the line the way we did, but now
we have two nested four loops if you'll notice.

00:18:18.869 --> 00:18:26.619
The first one is going to walk the runs in the line so that
there is CT run so, if there are multiple runs as you saw

00:18:26.619 --> 00:18:34.359
in the fully featured app we had two different fonts
split up into three runs, so this will iterate the runs

00:18:34.359 --> 00:18:40.269
and then as we go through the runs we're going
to iterate the glyphs and create a glyph range.

00:18:40.269 --> 00:18:47.230
We're going to draw glyphs one glyph at a time applying
a graphical transform to do the rotation of the glyphs,

00:18:47.230 --> 00:18:52.390
get it to draw on our arc and then
we'll just call CTRunDraw

00:18:52.390 --> 00:18:57.150
with the single glyph, glyph range
to draw in our context here.

00:18:57.150 --> 00:19:05.019
So, if we build and run this now, we should draw on our
arc and so for now the app is drawing how we want it to do

00:19:05.019 --> 00:19:11.359
but now we need to get feedback from the user and with
that I'm going to let Ned tell you how to do text input.

00:19:11.359 --> 00:19:13.269
Switch to slides, please.

00:19:15.130 --> 00:19:16.170
>> Thanks, Nathan.

00:19:16.170 --> 00:19:18.640
Things are really starting to perk up here.

00:19:18.640 --> 00:19:24.340
So, Nathan brought up a good point and I just want
to touch on that before I move on to my next slide.

00:19:24.339 --> 00:19:32.659
He mentioned that the origin of text is on the baseline and
that's a very good point and one that I forgot to mention

00:19:32.660 --> 00:19:38.830
in my previous slide about metrics. That's a
common convention using the baseline as the origin

00:19:38.829 --> 00:19:48.960
for both Core Text and Quartz, of course, Cocoa which uses
-- makes use of both technologies internally often refers

00:19:48.960 --> 00:19:56.029
to the rectangle of a line of text or fragment of text
and so in that case they would actually place the origin

00:19:56.029 --> 00:20:02.389
at the ascent of the line of text but otherwise
metrics should be consistent throughout the system.

00:20:02.390 --> 00:20:04.530
So that was just the one point I wanted to make.

00:20:04.529 --> 00:20:11.829
So -- so you've got something drawing now, but
you probably noticed it was pretty obvious --

00:20:11.829 --> 00:20:17.220
he spelled default text out there on the screen that
we don't really have it hooked up to anything yet.

00:20:17.220 --> 00:20:23.049
We're going to need to get some text in and so
there's two types of text we don't want to deal with,

00:20:23.049 --> 00:20:27.430
first of all we're going to want to replace that default
string with something that's a bit more localizable

00:20:27.430 --> 00:20:33.799
that is we're probably going to want to import this
fantastic application to other markets throughout the world

00:20:33.799 --> 00:20:40.669
or whatever and so we might want to be able to
specify something for our different markets something

00:20:40.670 --> 00:20:46.740
in Japanese, something in German whatever, and we're
also going to want to eventually take a user input and,

00:20:46.740 --> 00:20:55.559
of course, for both these tasks we're going to need a
quick overview of strings and so it goes without saying,

00:20:55.559 --> 00:20:59.169
but I'll say it anyway Mac OS X uses Unicode.

00:20:59.170 --> 00:21:05.600
This is a far cry from having to worry about the
A and W variance of Windows where you're dealing

00:21:05.599 --> 00:21:09.480
with code pages in the A and Unicode in the W versions.

00:21:09.480 --> 00:21:15.890
There used to be a long, long time ago pre Mac
OS X the requirement of using the Script Manager

00:21:15.890 --> 00:21:20.360
which is kind of a code page system of its own.

00:21:20.359 --> 00:21:25.629
Code pages are incredibly unwieldy, they're
completely impractical for dealing with real text,

00:21:25.630 --> 00:21:35.040
Japanese for instance couldn't really make use of a script
for modern Japanese and so the Script Manager is fairly,

00:21:35.039 --> 00:21:43.440
pretty, completely deprecated and so which is great
because we have Unicode to solve all of our needs for us.

00:21:43.440 --> 00:21:48.680
So it does make things a lot simpler especially
when you keep in mind that we have a handful

00:21:48.680 --> 00:21:52.460
of system wide classes available to
you for dealing with Unicode strings.

00:21:52.460 --> 00:21:55.579
There is, of course, CFString and NSString.

00:21:55.579 --> 00:22:00.699
You'll note on the slide I have that double headed
arrow there between the two that's my way of indicating

00:22:00.700 --> 00:22:06.809
that these classes are toll-free bridged so CFString,
of course, lives in Core Foundation which is a

00:22:06.809 --> 00:22:12.950
"C" procedural API for this functionality but
there's also the NSString class in Foundation

00:22:12.950 --> 00:22:21.360
which is a different syntax for using strings but both of
these classes can be used interchangeably with the methods

00:22:21.359 --> 00:22:28.139
or functions on the other, so it's largely a syntactic
difference but all of this functionality is available

00:22:28.140 --> 00:22:33.360
to you both at a very low level and at a
more convenient level and then built on top

00:22:33.359 --> 00:22:42.259
of those string classes are the AttributedStrings and so
Nathan already made use of one of these in our sample code

00:22:42.259 --> 00:22:48.299
and you can think of an AttributedString as being the
array of characters in your string and then parallel

00:22:48.299 --> 00:22:55.129
to that we have an array of attributes that specifies
the style corresponding to a particular characters

00:22:55.130 --> 00:23:02.830
in that string and so in Nathan's example he set a
font and another attribute for disabling ligatures

00:23:02.829 --> 00:23:10.899
but there are other attributes available to you both through
Core Text and a wide variety available to you through Cocoa.

00:23:10.900 --> 00:23:20.759
So these strings -- these AttributedStrings are the
primary input to Core Text as they carry both the text

00:23:20.759 --> 00:23:24.529
and the style that we're required to render it.

00:23:24.529 --> 00:23:30.670
The CF and NSString classes also offer a wide
variety of utilities including converting to

00:23:30.670 --> 00:23:39.529
and from other well known encodings, so I encourage
you to make use of these extensively as does Mac OS X.

00:23:39.529 --> 00:23:49.269
So the first type of string I mentioned is that
localizable text and so there's two different primary types

00:23:49.269 --> 00:23:53.240
of localizable text, the first most
common one that you would think about

00:23:53.240 --> 00:24:02.049
and one that we have been using throughout already is in
resources either attached to view or control of some sort

00:24:02.049 --> 00:24:08.980
and so, when Nathan had check boxes and everything, that
text was actually stored in a nib file which, of course,

00:24:08.980 --> 00:24:15.900
makes is easy to localize so for text that is
localizable text that is attached to a view

00:24:15.900 --> 00:24:22.019
in your user interface definition then a nib file
is a preferred mechanism for keeping track of that.

00:24:22.019 --> 00:24:30.230
Also we have strings resource files this is
appropriate when you're dealing with text-only resources

00:24:30.230 --> 00:24:35.230
that is not necessarily attached to a
particular view but this is something

00:24:35.230 --> 00:24:38.390
that we're going to make use of in the very next demo.

00:24:38.390 --> 00:24:45.470
In order to show you how we can use some text that
we haven't created in Interface Builder itself

00:24:45.470 --> 00:24:50.980
in a nib we're going to want to be able to use in
our application and localize at some future point.

00:24:50.980 --> 00:24:58.789
So but the most exciting type of text input, of course,
is going to be the text that you get from the user

00:24:58.789 --> 00:25:05.470
and so there's a wide variety of functionality
that's offered by system-defined control

00:25:05.470 --> 00:25:08.529
and view classes the primary one being, of course, Unicode.

00:25:08.529 --> 00:25:14.759
You don't have to worry about, you know, what language or
whatever your user is interacting with in order to get text

00:25:14.759 --> 00:25:18.839
in through one of these controls
or views into your application.

00:25:18.839 --> 00:25:25.679
In particular the system defined classes
and views offer support for input methods.

00:25:25.680 --> 00:25:32.279
This is incredibly useful as there
are many languages used on Mac OS X

00:25:32.279 --> 00:25:35.039
that the keyboard isn't really appropriate by itself.

00:25:35.039 --> 00:25:40.950
You might want to have some graphical or typing base
mechanism for constructing the text that you're going

00:25:40.950 --> 00:25:48.140
to input in a view and the system defined classes take care
of the input method integration for you which is great.

00:25:48.140 --> 00:25:53.910
And finally the system defined classes
also offer user interface consistency.

00:25:53.910 --> 00:25:58.860
We're very concerned about consistency of
usability throughout the system and so by using one

00:25:58.859 --> 00:26:05.759
of these system classes, of course, you're guaranteed that
the most appropriate mechanisms are used for interacting

00:26:05.759 --> 00:26:10.990
with text the most appropriate display and paradigms.

00:26:10.990 --> 00:26:14.900
So you should definitely make one of
these classes wherever possible not just

00:26:14.900 --> 00:26:19.269
because it makes your life a whole lot easier
but also because it's what your users expect.

00:26:19.269 --> 00:26:23.710
So there's a variety of classes and views that
are available, the most common ones I've indicated

00:26:23.710 --> 00:26:30.190
on the slide are in Carbon, HITextView and MLTE, the
later being appropriate for large amounts of text such as

00:26:30.190 --> 00:26:39.009
in a Text Editor of some sort and HITextView offering
either static or that's a static text or text controls

00:26:39.009 --> 00:26:47.640
and then there's also Cocoa which offers its own set
of views, the most commonly used are NSTextField

00:26:47.640 --> 00:26:55.820
for user interface interaction at the control level and
NSTextView which is appropriate for large amounts of text.

00:26:55.819 --> 00:27:02.159
So we encourage you to make use of these, of course,
we're going to not be able to use one of these

00:27:02.160 --> 00:27:07.970
for drawing our text, but we're certainly going to make
use of one of these for getting the text from the user

00:27:07.970 --> 00:27:12.420
and that's exactly what Nathan is going
to do over on the demo machine right now.

00:27:12.420 --> 00:27:13.660
>> Thank you.

00:27:16.380 --> 00:27:16.640
All right.

00:27:16.640 --> 00:27:21.980
So this is where we left off, we are basically
drawing static text on an arc and that's great

00:27:21.980 --> 00:27:27.299
but this is an application that the user is going
to run so I'm going to show you in this next step --

00:27:27.299 --> 00:27:35.819
step three if you're following along how we're going to get
default text in and then live text input and for the sake

00:27:35.819 --> 00:27:40.079
of having some code to demonstrate I'm going
on get the default text from the strings file.

00:27:40.079 --> 00:27:44.179
It's still just a little bit of code rather
than from a nib file because that's no code.

00:27:44.180 --> 00:27:51.390
But, so let's take a look at this, and I'll get started
here so I'm going to open up control.h here and I am going

00:27:51.390 --> 00:27:59.860
to drop in some of the text field utilities, the
declarations for these guys, so as you can see I put

00:27:59.859 --> 00:28:06.129
in two functions here that I'm going to define,
InitializeTextField, this is going to be called when we open

00:28:06.130 --> 00:28:11.400
up a window and it's going to grab the string from
the strings file and send it to our text field

00:28:11.400 --> 00:28:17.150
and then Update Text which is going to
be responsible for extracting the string

00:28:17.150 --> 00:28:21.450
from the text field and applying it to our ArcView.

00:28:21.450 --> 00:28:29.940
Now jump to the implementation file of this and
let's drop in the implementations of these guys,

00:28:29.940 --> 00:28:39.210
and we'll take a look at what we got. So initializeTextField
here is really quite simple. All we're going

00:28:39.210 --> 00:28:43.120
to do is call the CFCopyLocalizeString
macro and having this

00:28:43.119 --> 00:28:46.509
in there handles all the interactions
with the appropriate strings files.

00:28:46.509 --> 00:28:52.319
There's several of these macros that allow you a little
bit more control over how your strings are organized and,

00:28:52.319 --> 00:28:58.480
if you're writing a Cocoa application, there
are equivalent NS localize string macros.

00:28:58.480 --> 00:29:03.769
Now just using this is not enough to
get the strings file in your code.

00:29:03.769 --> 00:29:07.859
You need to use one of developer tools
called genstrings let me jump to the project

00:29:07.859 --> 00:29:17.549
and I'll show you what the string looks like. genstrings
will when you pass your source files will parse those

00:29:17.549 --> 00:29:23.730
and create appropriate strings files and then, once you have
the strings files, you can as necessary, edit the strings

00:29:23.730 --> 00:29:28.420
and your localizers can create copies
of these for other localizations.

00:29:28.420 --> 00:29:33.970
As you see our now default string will have some
Unicode text with some Japanese text interspersed

00:29:33.970 --> 00:29:39.230
with the English text as you saw
in the original application.

00:29:39.230 --> 00:29:43.900
So that's the strings file and that's how we're
going to get the strings file out and all we're going

00:29:43.900 --> 00:29:48.370
to simply do is set it to our text field.

00:29:48.369 --> 00:29:55.239
Now update text is the one responsible
for grabbing the text from control

00:29:55.240 --> 00:29:58.170
and there really isn't any Core Text specific --

00:29:58.170 --> 00:30:01.570
anything really specific here this is
standard HIView stuff we're just going

00:30:01.569 --> 00:30:05.089
to grab the text and assign it to our ArcView.

00:30:05.089 --> 00:30:09.049
So with that in mind let's hook up
the application event handlers --

00:30:09.049 --> 00:30:12.980
or the Window Event Handler in this case for these guys.

00:30:12.980 --> 00:30:19.809
First thing I'm going to do is drop in a new
implementation of HandleNew which is the event handler

00:30:19.809 --> 00:30:26.250
for creating a new window and just quickly walk you
through this -- see if we can jump to the top here.

00:30:26.250 --> 00:30:32.660
What I've added are the control events that
we're interested in handling and then I am going

00:30:32.660 --> 00:30:40.019
to set-up a ControlEventHandler for those events and
I'm going on use my Window Event Handler for convenience

00:30:40.019 --> 00:30:46.000
and before we show the window I'll
initialize the text field and update the text.

00:30:48.140 --> 00:30:49.740
That should be there.

00:30:55.799 --> 00:31:00.029
You know what let me do that again
because I dragged the wrong one in.

00:31:00.029 --> 00:31:08.960
I want this to compile for you guys, so now we'll go to the
Window Event Handler and put in the new Window Event Handler

00:31:08.960 --> 00:31:14.610
and then we'll take a quick look at what
we're doing for the TextField Event Case.

00:31:14.609 --> 00:31:21.529
So this is where we're handling the events from our text
field control and, you know, we're going to respond to two

00:31:21.529 --> 00:31:25.759
of them, the TextAccepted and the TextDidChange event.

00:31:25.759 --> 00:31:30.599
The TextEventAccepted is going to be good for getting the
input at the end when the user hits the carriage return,

00:31:30.599 --> 00:31:37.459
but we want live input and live feedback here, so
we're going to listen for the text to change event also

00:31:37.460 --> 00:31:42.319
and to handle this properly -- and
it's actually fairly well documented,

00:31:42.319 --> 00:31:46.240
we want to look for the unconfirmed range parameter.

00:31:46.240 --> 00:31:52.299
If that parameter is present, that means there's an
unconfirmed range of text usually from an input method

00:31:52.299 --> 00:31:57.750
and in that case we're going to bypass update
the text and wait for that to be confirmed.

00:31:57.750 --> 00:32:03.759
So let's take a look and see what this does, I'll build it.

00:32:03.759 --> 00:32:09.500
Now you can see we have our default text pulled in
from the strings file assigned to our text input field

00:32:09.500 --> 00:32:17.829
and the ArcView and live update I
was telling you about is now working

00:32:17.829 --> 00:32:22.179
and so let's show you what would happen
-- what happens with the input method.

00:32:22.180 --> 00:32:24.779
So I'll switch to the Hirigana input method --

00:32:24.779 --> 00:32:28.700
and I apologize if there are Japanese
speakers here, if I mess anything up, I'm not.

00:32:28.700 --> 00:32:35.299
So I'm going to try and type something
and notice I'm not updating

00:32:35.299 --> 00:32:40.579
yet because technically there's still an unconfirmed range
and once I confirm that, we'll update the view of the text.

00:32:40.579 --> 00:32:45.869
And this is what we sort of desire for live update behavior.

00:32:45.869 --> 00:32:53.229
So now that we're getting text into the application
both from a strings file and from user input,

00:32:53.230 --> 00:32:58.799
the next thing we're going to want to do is move on
to step four and, you know, hook up the fonts window,

00:32:58.799 --> 00:33:02.869
but before I do that let Ned tell you about fonts.

00:33:04.160 --> 00:33:05.320
Slides.

00:33:05.319 --> 00:33:09.759
>> Thank you very much.

00:33:12.299 --> 00:33:16.759
So we're going to need to talk about fonts.

00:33:16.759 --> 00:33:25.049
As Nathan said we've already been making use of our
default font, but now it's time to actually get real

00:33:25.049 --> 00:33:30.750
and let our user select some fonts for
using -- for use in their document.

00:33:30.750 --> 00:33:38.799
So first let's get an overview of fonts on Mac OS X, so
there's two primary classes that you're going to want

00:33:38.799 --> 00:33:45.599
to make use of when dealing with fonts, there's the font
which is a specific graphic instance that's used to render

00:33:45.599 --> 00:33:51.949
in a particular case and then there's a descriptor and
a descriptor you can think of as being a loose match

00:33:51.950 --> 00:33:54.559
to a font or kind of like a search query.

00:33:54.559 --> 00:34:01.269
So this is something that can be used to either
uniquely identify a particular font by its attributes

00:34:01.269 --> 00:34:11.210
or it can be something that you can use to basically
find the most appropriate font on a particular system.

00:34:11.210 --> 00:34:13.900
Now Windows programers have already made this distinction --

00:34:13.900 --> 00:34:20.710
are used to making this distinction by both having a font
instance in the form of an HFONT and a font descriptor

00:34:20.710 --> 00:34:25.309
of sorts being a LOGFONT structure and so it's --

00:34:25.309 --> 00:34:30.460
it's a very common distinction to be made
so a descriptor allows you to say something

00:34:30.460 --> 00:34:36.559
like I want a serif font instead of saying well I want
this particular serif font, you can say well I want a font

00:34:36.559 --> 00:34:40.799
that has these particular attributes
and handles that mapping for you.

00:34:40.800 --> 00:34:51.610
So, of course, as with strings we also have toll-free
bridged classes for dealing with these classes as well.

00:34:51.610 --> 00:34:59.980
What you see on the slide is a rough overview of both CTFont
and CTFontDescriptor being in Core Text and available

00:34:59.980 --> 00:35:06.219
at a very low level to you and NSFont and NSFontDescriptor
their bridged counterparts which are available

00:35:06.219 --> 00:35:15.269
through the applicant framework and so is
available with a different syntax but, of course,

00:35:15.269 --> 00:35:21.550
those classes are toll-free bridged so you can
use the two interchangeably and then at the --

00:35:21.550 --> 00:35:33.620
at the very bottom of this diagram you can also see
the implementation of these classes which, of course,

00:35:33.619 --> 00:35:41.699
are based on CGFont which is the Quartz font instance
and under the hood ATSFont which roughly corresponds

00:35:41.699 --> 00:35:45.949
to a particular font file or font container on disk.

00:35:45.949 --> 00:35:51.250
These are, of course, the implementation you
typically don't want to use one of these classes.

00:35:51.250 --> 00:35:56.619
It's much easier to make use of the higher level
classes but if for some reason you do need to access one

00:35:56.619 --> 00:36:01.920
of those lower level classes Core Text
allows you access to both of those.

00:36:01.920 --> 00:36:04.150
So that's how fonts work.

00:36:04.150 --> 00:36:10.690
Now we're going to need to figure out in some cases
what font in particular we're going to be dealing

00:36:10.690 --> 00:36:15.880
with from a user perspective, of course,
as an application you should prefer

00:36:15.880 --> 00:36:22.820
to use the font panel sometimes called the fonts window in
user interface parlance for letting a user select fonts.

00:36:22.820 --> 00:36:28.780
It used to be the -- the normal mode to have a big
menu with all of your fonts and everything well,

00:36:28.780 --> 00:36:34.670
it's not really what users expect these days on OS X.
The font panel offers a lot more flexibility when dealing

00:36:34.670 --> 00:36:42.530
with fonts other than just that single long listing and
lets you access many of the attributes in a particular font

00:36:42.530 --> 00:36:50.300
and so, in particular, in Leopard we've enhanced the
capabilities of the font panel interface for Carbon

00:36:50.300 --> 00:36:59.610
to allow you to access a font descriptor for the user font
selections, this is a great boon for anyone who has had

00:36:59.610 --> 00:37:03.240
to deal with integrating font panel
into a Carbon application

00:37:03.239 --> 00:37:11.049
because the font descriptor makes it virtually painless to
apply the newly updated attributes from the user selection

00:37:11.050 --> 00:37:14.070
to the font panel to the particular
font that you're using in a document.

00:37:14.070 --> 00:37:20.070
So that's a great new addition in Leopard and
one that Nathan is going to make use of and then,

00:37:20.070 --> 00:37:26.769
if you do need to enumerate all of the fonts on a particular
system, of course, there is also a CTFontCollection class,

00:37:26.769 --> 00:37:33.210
and we gave an example of using that in our slides
last year and so that is also available to you.

00:37:33.210 --> 00:37:37.500
So with that in mind, let's go ahead
and actually hook up to the font panel

00:37:37.500 --> 00:37:39.699
as Nathan is going to show you on the demo machine.

00:37:39.699 --> 00:37:41.019
Thanks.

00:37:42.159 --> 00:37:43.359
>> Thanks, Ned.

00:37:43.360 --> 00:37:47.360
So, hooking up to the font panel
is really fairly simple, you know,

00:37:47.360 --> 00:37:51.329
it could be you can think it's fairly
complex especially if you've tried to do it

00:37:51.329 --> 00:37:55.529
in other Carbon applications using ATSUI or even QuickDraw.

00:37:55.530 --> 00:38:01.500
We've added some functionality to the font panel to support
Core Text font descriptors and you'll find that using those

00:38:01.500 --> 00:38:04.840
with the font panel a lot easier, and I'm
going to show you that in a few minutes.

00:38:04.840 --> 00:38:11.150
First thing is I want to show you how to display a font
panel for your application and our preferred way is for you

00:38:11.150 --> 00:38:17.970
to add a format menu for your application where you'll
format fonts and format text in your application.

00:38:17.969 --> 00:38:20.480
In this case all we really care about are fonts.

00:38:20.480 --> 00:38:26.460
As you can see in the nib I have a format menu
defined and I have a show fonts menu item.

00:38:26.460 --> 00:38:31.990
What I've done to the menu item is the menu
item has the command SHFP and that corresponds

00:38:31.989 --> 00:38:39.199
to the standard constant KHI show/hide fonts panel and,
if you define this with a menu item or a control to send

00:38:39.199 --> 00:38:44.439
that command and let that command filter through your
application, the standard event handler will show

00:38:44.440 --> 00:38:47.480
or hide the fonts panel depending on the current state.

00:38:47.480 --> 00:38:56.099
You may want to make note of that event when it is issued so
that you can do certain things such as update the font panel

00:38:56.099 --> 00:39:00.409
which we do in this application or
update your menu which we also do,

00:39:00.409 --> 00:39:03.980
and I'll show you in one of the later -- in the next step.

00:39:03.980 --> 00:39:07.170
So that's a look at the code.

00:39:07.170 --> 00:39:10.909
We'll get out of Interface Builder
here and go back to Xcode.

00:39:10.909 --> 00:39:16.529
So to hook up to the fonts panel I'm mostly going to
be interacting with the fonts.h and .c files here,

00:39:16.530 --> 00:39:27.680
so we'll open fonts.h and as we've been doing I'm going
to drop in some declarations for the font panel support

00:39:27.679 --> 00:39:32.730
and all we really have right here
is the ChangedFont function.

00:39:32.730 --> 00:39:36.389
This function is going to be where we're
going to handle events from the font panel,

00:39:36.389 --> 00:39:41.199
so we're going to take an event as input and the WindowRef.

00:39:41.199 --> 00:39:45.519
We'll respond to this event by setting the font from
the font panel to the ArcView, so let's go ahead

00:39:45.519 --> 00:39:54.039
and implement that, jump to the implementation
file and drop in the implementation here.

00:39:55.190 --> 00:40:01.769
Now, if those of you familiar with Cocoa you will note
that you use a method very similar to this when responding

00:40:01.769 --> 00:40:04.730
to the font panel you'll get a new font
from the font panel and you'll be asked

00:40:04.730 --> 00:40:08.010
to convert your current font to that font.

00:40:08.010 --> 00:40:11.840
What we're doing here for Core Text in
ChangeFont is, first thing we're going

00:40:11.840 --> 00:40:15.460
to do is get the current font out of the ArcView.

00:40:15.460 --> 00:40:22.150
Once we have that we will copy the font descriptor
with CTFontCopyFontDescriptor from the current font

00:40:22.150 --> 00:40:27.720
and also extract the point size so we can use it
when recreating the font if that hasn't changed.

00:40:27.719 --> 00:40:33.949
The next we're going to do is extract the
descriptor, the CT font descriptor from the event --

00:40:33.949 --> 00:40:40.179
from the font panel so we'll get event parameter and
the parameter kEventParamCTFontDescriptor,

00:40:40.179 --> 00:40:43.649
we will get the font description from the font panel.

00:40:43.650 --> 00:40:47.680
Now it's important to note that the font panel
has a lot of different modes and it's possible

00:40:47.679 --> 00:40:53.049
that the user only interacted with one of these modes
and possibly only changed one aspect of the font.

00:40:53.050 --> 00:40:56.789
So this font descriptor you get from the
font panel could be partially complete

00:40:56.789 --> 00:41:02.849
that is the user manipulated the size slider you may only
have a point size in the font descriptor from the font panel

00:41:02.849 --> 00:41:07.099
so what you need to do is merge this -- these
new attributes from this new font descriptor

00:41:07.099 --> 00:41:11.159
with your current font that's why we
got the current font to begin with.

00:41:11.159 --> 00:41:16.839
So the first thing we're going to do is call
CTFontDescriptorCopyAttributes with this new descriptor

00:41:16.840 --> 00:41:22.970
from the font panel, that will give us the dictionary of
attributes and Core Text has a very convenient method,

00:41:22.969 --> 00:41:27.480
CTFontDescriptorCreateCopyWithAttributes
that takes a basic --

00:41:27.480 --> 00:41:33.280
base descriptor, the original descriptor and a set
of a new attributes and will do the proper merge

00:41:33.280 --> 00:41:35.340
of those attributes with the existing descriptor.

00:41:35.340 --> 00:41:39.990
It will handle the tough work of merging the
more complex attributes like variation settings

00:41:39.989 --> 00:41:44.099
and feature settings from the typography panel.

00:41:44.099 --> 00:41:47.460
Once we have this new font descriptor
we're pretty much home free.

00:41:47.460 --> 00:41:54.360
We will create a new font, CTFontCreateWithFontDescriptor
with this new one and then we will --

00:41:54.360 --> 00:42:02.420
we'll specify zero point size and null for the matrix
parameter, basically so that we will preserve the values

00:42:02.420 --> 00:42:07.039
that are in the descriptor and so the descriptor came from
a font originally that was merged with the font panel,

00:42:07.039 --> 00:42:13.199
so it has everything we need inside of it at this point
we don't want to override any of those because we want

00:42:13.199 --> 00:42:20.369
to respect the user selection in the font panel and last we
will set the font to our ArcView and release everything.

00:42:21.389 --> 00:42:26.379
The next part of interacting with the font panel is you
need to tell the font panel what the current font is

00:42:26.380 --> 00:42:29.500
and it's important to do this so that
the font panel when it's displayed

00:42:29.500 --> 00:42:33.980
or when the user switches windows is always
displaying, you know, the correct font.

00:42:33.980 --> 00:42:43.099
So I'm going to go to controls.h again and here we're
going to go to the font panel utilities and I'm going

00:42:43.099 --> 00:42:50.219
to declare a utility function here,
UpdateFontPanel, this is what we'll call

00:42:50.219 --> 00:42:53.269
to update the font panel with the
font for the current ArcView.

00:42:53.269 --> 00:43:02.239
Now, if we go to the implementation file and
drop in the implementation, we can see --

00:43:02.239 --> 00:43:05.319
take a look through this and see
what UpdateFontPanel actually does.

00:43:05.320 --> 00:43:11.390
It's really quite simple, like change font we're
going to get the current font and then the descriptor

00:43:11.389 --> 00:43:17.440
from the current font CTFontCopyFontDescriptor again
and then we're going to call SetFontInfoForSelection.

00:43:17.440 --> 00:43:22.610
This is the primary mechanism for accessing
the font panel from the Carbon interface.

00:43:22.610 --> 00:43:28.349
We'll specify that our selection is a
Core Text type and pass in our descriptor.

00:43:28.349 --> 00:43:33.969
Those of you that may have tried this before with the ATSUI
styles and having to build up these fairly large structures

00:43:33.969 --> 00:43:39.339
for all the information might be relieved moving to Core
text that it's as easy as passing a descriptor around.

00:43:39.340 --> 00:43:44.300
Now the last piece of information that I want you
to note is that the last parameter to SetFontInfoForSelection

00:43:44.300 --> 00:43:47.250
is the window event target
of our current window.

00:43:47.250 --> 00:43:52.159
This could be the window or could be a control since we're
sort of Windows-based here I'm going to use the window.

00:43:52.159 --> 00:43:57.629
It's important to specify this because that tells the
font panel where to send its next selection event to.

00:43:57.630 --> 00:44:03.230
If you don't do that, you may not get the selection event
that you need when the user interacts with the font panel.

00:44:03.230 --> 00:44:10.139
Last things we're going to hook the events up in our
event handlers, so first I'll drop a new implementation

00:44:10.139 --> 00:44:21.639
of HandleNew, all this new implementation really does
and we'll take a quick look is add another two events

00:44:21.639 --> 00:44:31.309
that we want to handle here, the WindowActivated and the
FontSelection event and then also we'll update the status

00:44:31.309 --> 00:44:36.630
of the font panel so that when we have a new
window it gets -- the font panel gets updated.

00:44:36.630 --> 00:44:47.220
So we go to the Window Event Handler and we'll drop in a new
implementation here with the code to handle these events,

00:44:47.219 --> 00:44:51.829
save our file and let's take a quick look
at what we're doing with the font events.

00:44:51.829 --> 00:44:57.949
So when we get the show/hide font panel event,
all I'm going to do is call update the font panel

00:44:57.949 --> 00:45:03.210
so that it knows what Windows sent the event to and what the
current font is, and I'm not going to set the status code

00:45:03.210 --> 00:45:05.470
or anything because I don't actually handle the event.

00:45:05.469 --> 00:45:11.559
I want the standard event handler to do
that, and we get the selection event,

00:45:11.559 --> 00:45:15.920
all I'm going to do is call my change font routine
and that's going to apply the current font.

00:45:15.920 --> 00:45:25.559
So if we build and run this now our application is
up and I can bring up the font panel -- excellent.

00:45:25.559 --> 00:45:31.360
And I should be able to change the font here, so let's pick
a different font let's try Cochin you see

00:45:31.360 --> 00:45:34.769
that the font change is not very clear,
maybe Copperplate, yeah, there we go.

00:45:34.769 --> 00:45:39.059
It's always, you know, I can change
the styles and the sizes.

00:45:39.059 --> 00:45:47.960
It all updates live, responds to the font events and, if
I open up a new window, you know, it sets the current font

00:45:47.960 --> 00:45:51.150
in the new window, switch back, we're good to go.

00:45:51.150 --> 00:45:55.530
So before we're done with fonts Ned has a little bit
more to tell you about determining font capabilities

00:45:55.530 --> 00:45:58.880
and this is what we're going to
use for hooking up these bold

00:45:58.880 --> 00:46:04.740
and italic check boxes you've been
looking at for the past few demos, Ned.

00:46:04.739 --> 00:46:06.509
>> Nathan, that was riveting.

00:46:06.510 --> 00:46:07.350
>> Slides, please.

00:46:07.349 --> 00:46:08.559
Thank you.

00:46:10.099 --> 00:46:11.440
>> All right.

00:46:11.440 --> 00:46:17.369
So what we've done so far, of course, we've gotten
some drawing in, we've gotten some strings in,

00:46:17.369 --> 00:46:21.299
we've gotten some font panel action
in, this has been fantastic.

00:46:21.300 --> 00:46:29.140
So I want to go back to rendering
for just a couple of slides here.

00:46:29.139 --> 00:46:36.750
So, of course, as I mentioned before
Mac OS X uses Quartz or Core Graphics

00:46:36.750 --> 00:46:43.409
as its fundamental graphics mechanism
and Quartz brings a lot to the table.

00:46:43.409 --> 00:46:45.379
It's really a great mechanism to work for.

00:46:45.380 --> 00:46:51.930
It's resolution independent, it has great PDF, all sorts of
cool shadings and all sorts of stuff I couldn't even begin

00:46:51.929 --> 00:46:59.849
to tell you about but there's, and of course, CGFont
is the drawing primitive for dealing with text

00:46:59.849 --> 00:47:09.659
and fonts within a Quartz context and -- but there's
a catch. The catch is that if you've been dealing

00:47:09.659 --> 00:47:19.739
with raster graphics package or bitmap graphics
package for most of your life as most of us have,

00:47:19.739 --> 00:47:27.159
there's a bit of a sea change that you're going to have
to make when you think about fonts in your application.

00:47:27.159 --> 00:47:33.879
And that is the notion that not all styles
apply in any particular instance for a font.

00:47:33.880 --> 00:47:40.750
So what I mean by this is that when you're dealing
with a raster graphics package like QuickDraw or GDI,

00:47:40.750 --> 00:47:45.960
it's really easy to take any font that a user has on
their system and say, oh hey, I want an italic version

00:47:45.960 --> 00:47:53.590
of that font and there it goes or hey, I want a
bold version and get this chunky double struck bold,

00:47:53.590 --> 00:48:03.090
but Quartz is really founded in the sensibility of PDF
which holds text in very high regard and so we tend

00:48:03.090 --> 00:48:07.710
to take the font designer into
account when dealing with fonts.

00:48:07.710 --> 00:48:15.769
In particular not all font designers have designed
a particular family with bold and italic instance,

00:48:15.769 --> 00:48:21.590
sometimes they might be, you know, in a completely
different font family or maybe there just isn't one,

00:48:21.590 --> 00:48:25.650
maybe the design isn't suitable for either of those styles.

00:48:25.650 --> 00:48:32.990
So it's important to note both for yourself and
to your users that they can't just arbitrarily go

00:48:32.989 --> 00:48:37.399
and apply these styles to just any
font they have on their system.

00:48:37.400 --> 00:48:43.940
So as we saw in the last example the font panel makes
this really easy because it lists all of the styles

00:48:43.940 --> 00:48:53.220
that are available for a particular font even beyond
simple bold and italic if the font happens to have one,

00:48:53.219 --> 00:49:01.149
but you may find there's an instance where you have kind
of this sort of old notion of dealing with the font,

00:49:01.150 --> 00:49:09.280
and so you'll find out that you can almost synthesize
an italic for any particular face and you can do

00:49:09.280 --> 00:49:15.250
that graphically by applying a shear transform which
is where you turn the rectangle into a parallelogram

00:49:15.250 --> 00:49:23.500
and so it doesn't really give you real italic, you know, it
won't give you any sort of change to the design of the font

00:49:23.500 --> 00:49:30.570
but it will give you an obliqued graphics
effect for that particular font instance

00:49:30.570 --> 00:49:35.480
but bold on the other hand is a different story.

00:49:35.480 --> 00:49:42.510
It -- there's no real way to synthesize a bold for a
font that didn't have one in a way that's going to work

00:49:42.510 --> 00:49:48.070
in every context that that particular
font instance is going to be used.

00:49:48.070 --> 00:49:54.830
That old notion of doing the literal double strike in order
to get the bolder text isn't going to work and so in order

00:49:54.829 --> 00:50:00.049
to handle this -- this new world where fonts look
great because they were designed that way rather

00:50:00.050 --> 00:50:02.670
than just being kind of mangled by your graphics,

00:50:02.670 --> 00:50:12.820
we're going to need to determine what particular fonts have
particular styles or perhaps other traits in some cases

00:50:12.820 --> 00:50:16.170
and in this case I'm going to turn it
over to Nathan to show you how to do so.

00:50:16.170 --> 00:50:19.099
>> All right.

00:50:20.380 --> 00:50:23.619
So back to the demo we're moving on to step five.

00:50:23.619 --> 00:50:29.309
We're going to hook up those check boxes and menu items
to make text switch the font to bold and italic faces.

00:50:29.309 --> 00:50:34.949
What's important to note is we're going to be analyzing
the capabilities of the font using Core Text to figure

00:50:34.949 --> 00:50:38.939
out if these check boxes even apply
for the font we've selected.

00:50:38.940 --> 00:50:42.260
So if a font doesn't have an italic face, you know,

00:50:42.260 --> 00:50:45.770
moving from the current face, we're
going to disable that check box.

00:50:45.769 --> 00:50:53.250
So let's get started here and we're going to be working
in the fonts.h and c and controls.h and c files.

00:50:53.250 --> 00:51:02.590
So in fonts.h I want to drop in a couple more utilities
for probing font traits and setting font traits.

00:51:02.590 --> 00:51:07.079
So we'll drop those in, two simple functions
here that we're going to be implementing,

00:51:07.079 --> 00:51:10.569
ToggleFontTrait and CanToggleFontTrait.

00:51:10.570 --> 00:51:15.780
Essentially ToggleFontTrait is just going to
be take the current font and take the font --

00:51:15.780 --> 00:51:20.430
the trait that is specified and switch
the meaning of it from the current font.

00:51:20.429 --> 00:51:25.669
So, if the font is bold and we want to toggle
bold trait, we're going to make it nonbold

00:51:25.670 --> 00:51:32.710
and CanToggleFontTrait is very similar but all it's going
to do is determine whether the font can actually do that.

00:51:35.139 --> 00:51:38.079
So let's drop in the implementation for these.

00:51:41.570 --> 00:51:43.360
All right.

00:51:43.360 --> 00:51:47.700
And we'll take a look at what ToggleFontTrait does
here or right there, first thing we're going to do

00:51:47.699 --> 00:51:53.669
as we've done before is get the current font and then
we are going to call CTFont and get symbolic traits.

00:51:53.670 --> 00:52:00.010
That will give us the traits that we determine
for the font as a short-bit field, you know,

00:52:00.010 --> 00:52:07.720
using bitmask for each trait and this represents things
like bold, italic, monospace and various other things

00:52:07.719 --> 00:52:14.089
and then we're going to do a quick set of
code here and we had it broken down into if-else

00:52:14.090 --> 00:52:20.130
for readability there are other ways we can do this but
we're going to call CTFontCreateWithSymbolicTraits,

00:52:20.130 --> 00:52:25.180
give it our original font and default
values of zero and null for size and matrix.

00:52:25.179 --> 00:52:30.779
We don't want to change those and then we're going
to pass in the trait value as the fourth parameter

00:52:30.780 --> 00:52:36.180
and the trait mask as the fifth parameter
and, again, like I said these are bitmasks

00:52:36.179 --> 00:52:43.169
and so the fifth parameter is important that actually tells
Core Text which trait you desire to modify and it's possible

00:52:43.170 --> 00:52:47.250
to modify multiple traits at a time and
the value for those traits will be set

00:52:47.250 --> 00:52:50.800
by the values you pass in for the fourth parameter.

00:52:50.800 --> 00:52:56.960
So, you know, the first line here that I've highlighted
we're going to be trying to turn on a given trait

00:52:56.960 --> 00:53:02.530
and the other call we're trying to
turn off that given trait and so,

00:53:02.530 --> 00:53:06.110
once we've done that we will set the font to our ArcView.

00:53:06.110 --> 00:53:10.530
If you take a look at CanToggleFontTrait,
the code is pretty much identical.

00:53:10.530 --> 00:53:15.310
All it does is take a font as input instead of getting
it from our current ArcView and then it checks to see

00:53:15.309 --> 00:53:18.480
if we can actually make a converted
font, and it will toss out the result

00:53:18.480 --> 00:53:22.550
but it tells us whether the font can do this or not.

00:53:22.550 --> 00:53:30.080
So we move on to controls let's quickly
drop in the controls stuff here,

00:53:30.079 --> 00:53:34.710
the control utilities let's put in the declaration.

00:53:34.710 --> 00:53:40.710
I just have two utilities here to update the font controls
those are the check boxes and update the format menu

00:53:40.710 --> 00:53:47.630
which is the update the menu items, and I'm
going to jump to our implementation file

00:53:47.630 --> 00:53:51.300
and put the implementations in the right place.

00:53:51.300 --> 00:53:58.300
I'm not really going to walk you through these because
this is standard control functions calls for HIToolbox

00:53:58.300 --> 00:54:03.680
but suffice it to say these are calling those two
functions that I provided the ToggleFontTraits

00:54:03.679 --> 00:54:11.009
and the CanToggleFontTraits in response to
being called and then update the menu items

00:54:11.010 --> 00:54:14.660
and essentially we're just changing
a few attributes on those controls.

00:54:14.659 --> 00:54:15.539
All right.

00:54:15.539 --> 00:54:26.980
So before this will run we need to, again, update
our event handler, so let's replace update new

00:54:28.000 --> 00:54:35.300
and all we're really doing here is making sure we
update the font controls as well as the font panel,

00:54:35.300 --> 00:54:47.050
and we drop in our new Window Event Handler, and now I will
show you what we're doing in the Window Event Handler is

00:54:47.050 --> 00:54:53.080
when we get the font control commands which we have
defined in the controls.h file for bold and italic,

00:54:53.079 --> 00:54:57.840
we're going to toggle the font trait and then
reupdate the controls with the current font

00:54:57.840 --> 00:55:03.289
because we've changed the font and
that's all we really need to do.

00:55:03.289 --> 00:55:08.829
If we build and run this, you can see
the effect right away -- hide Xcode.

00:55:08.829 --> 00:55:12.480
We're starting to look like that app I first showed you.

00:55:12.480 --> 00:55:16.280
We got our text drawn in Arc, we got the font
panel integration and if I change the font --

00:55:16.280 --> 00:55:22.010
let me bring up the font panel so you can actually
see how things are going here, if I change it to bold,

00:55:22.010 --> 00:55:28.030
you can see that since dedo our current
font does not have a bold italic typeface,

00:55:28.030 --> 00:55:34.230
we disabled the italic check box
as well as the italic menu item.

00:55:34.230 --> 00:55:39.750
Now if I disable bold and switch to italic,
you can see that the reverse happens,

00:55:39.750 --> 00:55:48.460
switch to a more complete face say Cochin and now I actually
have access to a bold italic face and once you've got that

00:55:48.460 --> 00:55:52.150
and you're giving the proper feedback to
the users for the capabilities of the font.

00:55:52.150 --> 00:55:56.780
We're not giving them misconceptions of what fonts
can, you know, that they can do things with fonts

00:55:56.780 --> 00:56:02.240
that the fonts actually don't support
and so before I wrap up and show you some

00:56:02.239 --> 00:56:08.769
of the option hookup let's have Ned talk
about saving your text into your document.

00:56:08.769 --> 00:56:09.119
Slides, please.

00:56:09.119 --> 00:56:09.339
>> Thanks.

00:56:09.340 --> 00:56:13.620
Nathan. Truly that's better than Cats.

00:56:13.619 --> 00:56:22.230
So this is just kind of a quick run down on
saving because by and large we hope that you

00:56:22.230 --> 00:56:31.199
as you're designing your document format will consider some
of the existing mechanisms for dealing with saving text but,

00:56:31.199 --> 00:56:38.829
if you're implementing a file format of your own, we
certainly strongly recommend that you make use of Unicode.

00:56:38.829 --> 00:56:46.900
CF has some conveniences for dealing -- for converting
your text to a version that's appropriate for being saved

00:56:46.900 --> 00:56:55.059
in a document, the external representation, of course,
is UTF-16 with a byte order marker that means that,

00:56:55.059 --> 00:57:02.079
if you save your document on an Intel machine and open
on a PowerPC that byte order marker will, of course,

00:57:02.079 --> 00:57:10.110
be a signal to CFString as to what byte
ordering to use when reading that text back in.

00:57:10.110 --> 00:57:16.019
So we do recommend that, if you have the choice, you
make use of this convenience although you may find

00:57:16.019 --> 00:57:19.829
that if you're dealing with, you know, documents from
the internet or some other protocol you might need

00:57:19.829 --> 00:57:26.029
to also use something like UTF-8 which is
also available to you but do keep that in mind

00:57:26.030 --> 00:57:29.470
as a consideration when you're designing document format.

00:57:29.469 --> 00:57:38.099
Also and sometimes you may need to use this not just
for documents but perhaps for other purposes as well,

00:57:38.099 --> 00:57:48.679
when you are dealing with the style for a particular run of
text, you should make note that we strongly encourage you

00:57:48.679 --> 00:57:52.419
to serialize the font descriptor and not the font.

00:57:52.420 --> 00:57:59.130
Remember as I said the font descriptor contains the
attributes that describe a font rather than information

00:57:59.130 --> 00:58:05.869
about a particular instance of a font and so by serializing
the font descriptor, there's some amount of flexibility

00:58:05.869 --> 00:58:13.099
that you have when you're reading that document back in
-- in hopes of providing some sort of reasonable behavior

00:58:13.099 --> 00:58:19.289
when a user opens document on a machine that doesn't have
a font that the document was created with for instance

00:58:19.289 --> 00:58:25.039
and also it's a lot easier to identify the
information you're going to need to represent a font

00:58:25.039 --> 00:58:28.769
because it's all just in the font
descriptor attributes so that's fantastic.

00:58:28.769 --> 00:58:35.320
And then as I mentioned at the beginning of this slide
we really do have a ton of functionality available to you

00:58:35.320 --> 00:58:42.980
in Mac OS X, in particular available through
Cocoa which allows you to save your text documents

00:58:42.980 --> 00:58:54.050
as not only simple formats like RTF but even formats
such as the Open Office format and Office XML and others.

00:58:54.050 --> 00:59:00.890
So it's really fabulous technology for dealing with a single
line of code, to save a single line of code, to restore,

00:59:00.889 --> 00:59:07.289
it's really great stuff and we encourage you
to make use of that if that fits your needs.

00:59:07.289 --> 00:59:14.469
So that's just a quick rundown, there's a lot more
to go into detail here, but we just want to touch

00:59:14.469 --> 00:59:20.779
on it being good citizens in Mac OS X.
So now we come to the bonus material.

00:59:20.780 --> 00:59:27.690
We thought about director's commentary but we realized there
probably wouldn't be as much there as we might have liked,

00:59:27.690 --> 00:59:31.630
so instead we're going to show you how
to hookup those option check boxes.

00:59:31.630 --> 00:59:35.650
So no Quentin Tarantino but Nathan will do.

00:59:35.650 --> 00:59:37.250
>> Demo one, please.

00:59:38.750 --> 00:59:39.119
All right.

00:59:39.119 --> 00:59:41.909
So you've been looking at these
option check boxes for a while.

00:59:41.909 --> 00:59:44.219
They do some interesting things with
Core Text and since we're a little short

00:59:44.219 --> 00:59:46.519
on time I'm going to run through this very quickly.

00:59:46.519 --> 00:59:48.730
If you're following along it's step six.

00:59:48.730 --> 00:59:55.980
So the first thing I'm going to do declare some options
and some accessors, and I will define them as well

00:59:55.980 --> 01:00:02.210
with the option accessors, and then let's,
actually, get to the nuts and bolts.

01:00:02.210 --> 01:00:07.519
We're going to look at the drawing here, so
let's first look at what we need to do to get

01:00:07.519 --> 01:00:11.110
and draw glyph bounds, so I'll drop in the code for this.

01:00:11.110 --> 01:00:16.599
If the option is set, we'll get the image
bounds from the run for the current glyph range,

01:00:16.599 --> 01:00:20.079
and we'll simply stroke a rect and
that's pretty straightforward.

01:00:20.079 --> 01:00:23.549
All of our graphic operations apply.

01:00:23.550 --> 01:00:27.430
Line metrics are almost as easy to do with our run.

01:00:27.429 --> 01:00:32.500
We'll call CTRunGetTypographicBounds, and we're going
to get the ascent and descent to use to construct the height

01:00:32.500 --> 01:00:36.929
of the box and then again all we have to do
is stroke the rect.

01:00:36.929 --> 01:00:43.379
Determining when we have substituted fonts
is a little tricker but not that bad.

01:00:43.380 --> 01:00:50.610
If we drop in some code to determine when the substitution
occurs, we will set-up a Boolean we'll use for drawn

01:00:50.610 --> 01:00:56.820
and all we're really doing here is extracting
attributes from the run and we want the font attribute

01:00:56.820 --> 01:01:05.030
and then we're going to compare with CFEqual our
current ArcView font to this font from the run.

01:01:05.030 --> 01:01:11.390
If they're not, well we know we need to draw --
do some special drawing to implement this option.

01:01:11.389 --> 01:01:20.469
So to do that I'm going to get rid of the simple run
drawn and implement or substitute glyph drawing and so,

01:01:20.469 --> 01:01:26.049
if we're not, we're going to do a simple run drawing
and, if we are, we have to draw manually and we're going

01:01:26.050 --> 01:01:32.850
to get the graphics font, the CGFontRef, from -- from
our current font and then simply going to get the glyphs

01:01:32.849 --> 01:01:40.179
and the glyph positions from the run and pass those
on to CG to show our glyphs at these positions.

01:01:40.179 --> 01:01:44.319
So now the last bit is to hook up the Event Handler,

01:01:44.320 --> 01:01:51.590
so I'm going to do that real quick and
drop in the new implementation here.

01:01:53.039 --> 01:02:02.420
All this is doing is putting a handler for the commands
from our check boxes and then setting the correct options

01:02:02.420 --> 01:02:07.240
to the ArcView and, if I build
and run let's hide Xcode real quick

01:02:07.239 --> 01:02:15.189
and you can see now we can dim the substituted glyphs as
I showed before draw glyph bounds and draw line metrics.

01:02:15.190 --> 01:02:15.429
All right.

01:02:15.429 --> 01:02:18.519
Ned, time to wrap up.

01:02:18.519 --> 01:02:20.440
>> All right.

01:02:20.440 --> 01:02:27.250
That was great, so, of course, for more information you can
contact Deric Horn the Application Frameworks Evangelist

01:02:27.250 --> 01:02:30.489
who can put you in touch with the
right people to resolve your issues.

01:02:30.489 --> 01:02:37.529
Under documentation, sample code, and other resources I do
point out the second URL there is the address of the webpage

01:02:37.530 --> 01:02:42.260
where you can subscribe to the coretext-dev
public mailing list so if you want to hang

01:02:42.260 --> 01:02:48.350
out with other Core Text aficionados that
is the proper venue to do so and, of course,

01:02:48.349 --> 01:02:56.420
on the session page for this particular session
there is doc links to the documentation for Core Text

01:02:56.420 --> 01:02:59.070
and this sample code and some other stuff.

01:02:59.070 --> 01:03:06.350
So that's great, if you want even more in
depth hands on discussions with Nathan,

01:03:06.349 --> 01:03:11.759
myself or other Core Text engineers, you
can come to Lab C on Friday afternoon.

01:03:11.760 --> 01:03:14.620
There's going to be a lab on Core Text.

01:03:14.619 --> 01:03:18.299
I will also point out as I did at the
beginning of this talk there's a talk

01:03:18.300 --> 01:03:24.810
on Extending the Cocoa Text System this afternoon,
followed by another Core Text talk geared towards people

01:03:24.809 --> 01:03:30.849
who are converting from existing
Mac QuickDraw and ATSUI situations.

01:03:30.849 --> 01:03:36.710
So that is fantastic, in summary Unicode is awesome.

01:03:36.710 --> 01:03:39.480
We use it throughout the system, you should definitely too.

01:03:39.480 --> 01:03:45.780
The way to do so is, of course, to make use of
it and Core Text allows you to make use of that

01:03:45.780 --> 01:03:53.880
in a very low level context and, of course, built on
top of this mechanism you have the full flexibility

01:03:53.880 --> 01:03:58.220
of the Cocoa text system, so we really
are trying to get you to use Unicode

01:03:58.219 --> 01:04:00.539
by making it easy to do so in your application.
WEBVTT

00:00:12.356 --> 00:00:13.336
>> Good morning!

00:00:13.616 --> 00:00:13.796
Welcome!

00:00:14.516 --> 00:00:17.136
[ Applause ]

00:00:17.636 --> 00:00:20.886
Glad to see a number of folks
out now, bright and early,

00:00:20.886 --> 00:00:23.906
to talk about all the
heart-pounding excitement

00:00:23.906 --> 00:00:25.276
in the world of compilers.

00:00:26.026 --> 00:00:31.396
And I'm Jim Grosbach, and I'm
really happy to be here today

00:00:31.396 --> 00:00:35.746
to share with you all of the
new things that we have in LLVM.

00:00:37.106 --> 00:00:42.226
When we normally talk about LLVM
and what first comes to mind

00:00:42.226 --> 00:00:46.296
when we think about it is the
Apple LLVM Compiler itself.

00:00:46.646 --> 00:00:51.146
This is what we all use to
build our apps and that's

00:00:51.146 --> 00:00:53.276
where we really first
encounter LLVM,

00:00:53.966 --> 00:00:57.136
but it's much more than that.

00:00:57.886 --> 00:01:03.266
LLVM is used in a wide
variety of products and tools

00:01:03.766 --> 00:01:09.436
that we all use every day, both
as developers and as end users.

00:01:10.866 --> 00:01:16.326
Over the years LLVM has grown to
be a really key technology here

00:01:16.326 --> 00:01:19.566
at Apple for building
tools, for performance,

00:01:20.146 --> 00:01:25.996
and for modernization, and that
has been no exception this year

00:01:26.496 --> 00:01:28.276
as we have moved swiftly along

00:01:29.226 --> 00:01:32.106
with a wide variety
of new improvements.

00:01:33.666 --> 00:01:38.806
To start with, back in September
we introduced the Apple A7

00:01:38.806 --> 00:01:43.086
processor which has been
just absolutely magnificent

00:01:43.206 --> 00:01:44.516
in what it's allowed us to do,

00:01:44.826 --> 00:01:47.366
bringing truly desktop-class
performance

00:01:48.076 --> 00:01:53.166
to your mobile devices and
LLVM plays a key role in this.

00:01:54.226 --> 00:01:59.546
And now we're encouraging more
of you to use this technology

00:01:59.546 --> 00:02:03.396
in your apps, so
building for 64-bit

00:02:03.676 --> 00:02:05.546
in iOS is now the default.

00:02:05.626 --> 00:02:09.515
As of Xcode 5.1 carrying
on into Xcode 6,

00:02:10.235 --> 00:02:11.546
when you rebuild your app,

00:02:12.486 --> 00:02:14.146
if you're using standard
architectures,

00:02:14.616 --> 00:02:16.676
ARM64 will be included.

00:02:17.406 --> 00:02:19.926
This does not impact
your deployment story.

00:02:19.926 --> 00:02:23.466
You can continue to
deploy back to iOS 4.3.

00:02:23.466 --> 00:02:26.786
We still build for
arm V7 for 32 bit.

00:02:27.626 --> 00:02:30.546
All of the development work
flows that you're familiar

00:02:30.546 --> 00:02:34.346
with for the simulator,
the debugger, profiling,

00:02:34.916 --> 00:02:38.066
all of these things continue
to work transparently,

00:02:38.526 --> 00:02:41.636
just as you're familiar with
in a 64-bit environment.

00:02:42.506 --> 00:02:44.926
Now, one thing to be aware of is

00:02:44.926 --> 00:02:49.166
that because ARM64 is an
entirely new architecture,

00:02:49.856 --> 00:02:52.786
your entire application
must be built 64 bit,

00:02:53.256 --> 00:02:54.826
not just a few libraries here,

00:02:54.826 --> 00:02:57.526
or a few files there,
but the whole app.

00:02:57.746 --> 00:03:00.586
So, if you're relying on
third-party libraries,

00:03:01.286 --> 00:03:05.416
and those libraries have
not yet adopted 64 bit,

00:03:06.036 --> 00:03:10.506
please work with your vendors
and encourage them to update

00:03:10.746 --> 00:03:12.796
and support 64 bit development

00:03:13.146 --> 00:03:16.276
so that your app
can then migrate

00:03:16.276 --> 00:03:18.116
as well and get the benefits.

00:03:18.666 --> 00:03:22.526
Now, during migration there
are a few things that we'd

00:03:22.526 --> 00:03:26.426
like to bring to your
attention that might come up,

00:03:26.426 --> 00:03:29.586
a few advancements we've
made, and a few things

00:03:29.586 --> 00:03:31.676
that we've tightened
up in the specification

00:03:31.806 --> 00:03:35.406
and what the possible impact
of that to your app is.

00:03:35.956 --> 00:03:42.556
To start with, in 64-bit iOS all
functions must have a prototype.

00:03:43.096 --> 00:03:47.116
This has been good style
since time immemorial

00:03:47.596 --> 00:03:51.496
and it's been required
for C++ since the start.

00:03:51.886 --> 00:03:55.156
It's been highly suggested in C,

00:03:55.276 --> 00:03:58.636
for any modern version not
using a prototype is deprecated

00:03:59.306 --> 00:04:01.976
and has been for a
very long time now.

00:04:03.206 --> 00:04:06.546
So, we've taken advantage
of this in ARM64

00:04:06.986 --> 00:04:10.156
to generate more efficient
calling convention code,

00:04:10.396 --> 00:04:12.866
in particular for variatic
functions like printf,

00:04:12.866 --> 00:04:14.866
that the number of arguments

00:04:15.166 --> 00:04:17.476
to the function varies
by call site.

00:04:18.995 --> 00:04:21.805
So, when you have older
code that you're using

00:04:21.805 --> 00:04:23.356
that may not use prototypes,

00:04:24.176 --> 00:04:27.496
what is normally a warning has
now been promoted to an error,

00:04:27.496 --> 00:04:31.646
so the compiler will highlight
to you in your code exactly

00:04:31.736 --> 00:04:35.766
where this is happening so
that you know which prototypes

00:04:35.766 --> 00:04:38.156
to go add to your
header files to move on.

00:04:39.796 --> 00:04:42.786
One place that this
does sometimes come

00:04:42.786 --> 00:04:46.556
up in a little bit more
of a subtle way is when C

00:04:46.556 --> 00:04:50.116
and Objective-C interworking
code with direct indications

00:04:50.116 --> 00:04:51.816
of Objective-C message send.

00:04:52.466 --> 00:04:54.946
To help find this, we
have a new Xcode setting

00:04:55.536 --> 00:04:58.896
to enable strict
checking of objc-msgSend.

00:05:00.366 --> 00:05:01.706
This is a recommended setting

00:05:02.796 --> 00:05:05.236
and when you first
upgrade your project

00:05:05.236 --> 00:05:07.396
to [inaudible] code
6 we'll encourage you

00:05:07.506 --> 00:05:08.546
to adopt this setting.

00:05:08.546 --> 00:05:12.926
And what's tricky is
that every indication

00:05:12.926 --> 00:05:16.636
of objc-msgSend effectively
has a different type.

00:05:17.466 --> 00:05:22.196
It has the type of what the
final receiving method is going

00:05:22.196 --> 00:05:22.646
to be.

00:05:23.696 --> 00:05:26.566
For example here,
a trivial piece

00:05:26.566 --> 00:05:29.906
of code that's invoking
method foo,

00:05:31.046 --> 00:05:36.446
with strict checking enabled,
the compiler will now tell us

00:05:36.576 --> 00:05:40.236
that we need to tell it
what the final type is.

00:05:41.136 --> 00:05:42.466
This is straightforward to do.

00:05:42.466 --> 00:05:44.956
It's a little bit verbose,
but very straightforward.

00:05:44.956 --> 00:05:47.736
We simply add the type of
the final receiving method.

00:05:48.146 --> 00:05:49.406
Done it here with a typedef.

00:05:49.446 --> 00:05:52.856
This could be done with a direct
type test on all on one line,

00:05:52.856 --> 00:05:54.866
if you prefer, just to make sure

00:05:54.866 --> 00:05:57.646
that the compiler knows what
the final receiving type

00:05:57.646 --> 00:06:01.046
of the method is so that it
can generate the right code

00:06:01.296 --> 00:06:02.926
to get the final result correct.

00:06:05.016 --> 00:06:08.296
Another place that we've
tightened things up

00:06:08.296 --> 00:06:09.916
and taken advantage
of our new ABI

00:06:09.916 --> 00:06:13.856
and ARM64 is the
Objective-C Boolean type.

00:06:14.276 --> 00:06:17.776
If any of you were at Stump
the Experts last night,

00:06:17.776 --> 00:06:19.916
this topic actually
came up as a question.

00:06:20.396 --> 00:06:23.306
It was rather amusing like,
"I have a slide on that!

00:06:23.456 --> 00:06:25.116
That'll be great!"

00:06:25.116 --> 00:06:27.596
So, BOOL is basically
now a BOOL type.

00:06:28.716 --> 00:06:31.666
Previously, it's been
a signed character.

00:06:32.156 --> 00:06:36.726
And, sometimes our code -- our
code as well, not just in yours,

00:06:37.326 --> 00:06:39.756
would put values
into the Boolean type

00:06:39.786 --> 00:06:41.876
that weren't strictly Boolean.

00:06:42.946 --> 00:06:46.606
Now, the compiler is going to
be taking advantage of this type

00:06:46.606 --> 00:06:48.796
or definition, so
what can happen is

00:06:48.796 --> 00:06:52.346
that if your code does that,
the results between 32-bit iOS

00:06:52.696 --> 00:06:55.106
and 64-bit iOS may differ.

00:06:56.046 --> 00:06:59.066
So, if you start seeing some
odd behaviors with Booleans,

00:06:59.366 --> 00:07:03.326
this is something
to look out for.

00:07:04.946 --> 00:07:06.296
We also have pointers.

00:07:07.516 --> 00:07:10.196
As we're now 64-bit
architecture, this is kind

00:07:10.196 --> 00:07:12.666
of the core of what this
is all about, that pointers

00:07:12.666 --> 00:07:14.266
and longs are now 64 bits.

00:07:15.226 --> 00:07:19.146
So, old code would
often do horrible things

00:07:19.146 --> 00:07:21.916
like casting integers to
pointers, and back-and-forth.

00:07:22.866 --> 00:07:25.286
And hopefully, we don't write
code that does that anymore,

00:07:25.286 --> 00:07:28.026
but we all have this legacy
code that we have to live with,

00:07:29.076 --> 00:07:32.176
and now this can bite
us if we're not careful.

00:07:32.486 --> 00:07:34.736
This is very similar
to what we've all dealt

00:07:34.736 --> 00:07:38.876
with on the 32-bit to
64-bit Intel transition,

00:07:38.876 --> 00:07:39.816
if we went through that.

00:07:40.616 --> 00:07:41.496
That's still a problem;

00:07:41.496 --> 00:07:43.826
we haven't magically just
solved that in the compiler.

00:07:44.886 --> 00:07:48.946
So for example here, we're
casting an integer which came

00:07:48.946 --> 00:07:50.106
from a pointer somewhere else.

00:07:50.106 --> 00:07:52.156
We're casting that
to a void (star).

00:07:52.156 --> 00:07:55.186
But now the compiler
can help a little bit.

00:07:55.186 --> 00:08:00.196
It can at least inform us
that the problem is coming up

00:08:00.196 --> 00:08:03.636
and tell us that, "Oh, we have a
problem here that we need to go

00:08:03.636 --> 00:08:04.606
and look at and make sure

00:08:04.606 --> 00:08:06.796
that this is really
what's happening."

00:08:07.596 --> 00:08:09.176
Now, if we ignore this warning,

00:08:09.796 --> 00:08:12.656
the runtime in the
kernel is going

00:08:12.656 --> 00:08:15.036
to be a little bit more
forceful about this.

00:08:15.606 --> 00:08:19.116
If we dereference that pointer,
we're going to get a hard fault

00:08:19.916 --> 00:08:22.936
because the page zero is
mapped to always give a fault,

00:08:22.936 --> 00:08:26.236
so if we miss any of these
through other warnings,

00:08:26.806 --> 00:08:27.916
we'll still get an error.

00:08:28.406 --> 00:08:29.696
Paying attention
to the compiler,

00:08:29.696 --> 00:08:32.106
it's going to be a lot
friendlier because it'll be nice

00:08:32.106 --> 00:08:34.515
and friendly and tell you the
line number and the source file

00:08:34.576 --> 00:08:35.496
for where the problem is.

00:08:35.716 --> 00:08:37.756
The kernel's just going to
tell you you did something bad.

00:08:39.246 --> 00:08:43.666
To address this, we use
the C language typedefs

00:08:44.456 --> 00:08:46.776
that are 64 and 32-bit cleaned.

00:08:46.776 --> 00:08:49.596
We say we want a signed
integer, an unsigned integer,

00:08:49.816 --> 00:08:53.086
that is an appropriate type
for saving a pointer value

00:08:53.386 --> 00:08:55.306
or for indexing into an array

00:08:55.746 --> 00:08:58.466
for comparing the differences
between two pointers.

00:08:59.446 --> 00:09:02.026
For example, if we would
modify our previous code

00:09:02.026 --> 00:09:05.566
to simply use the intptr type,
which when we're compiling

00:09:05.566 --> 00:09:08.726
for 32-bit iOS, will we
get 32-bit signed integer,

00:09:09.126 --> 00:09:13.726
and for 64-bit iOS will be
a 64-bit signed integer.

00:09:14.456 --> 00:09:18.686
Slightly more subtly, this can
come up in structure layouts.

00:09:19.496 --> 00:09:23.266
When we use a long or pointer
these now grow, which change

00:09:23.636 --> 00:09:26.236
but the size and
sometimes the alignment,

00:09:26.236 --> 00:09:28.836
the offsets of other
fields in our structures.

00:09:29.486 --> 00:09:30.576
And, we have to be careful

00:09:30.576 --> 00:09:32.646
that this is done in
a way that's safe.

00:09:33.876 --> 00:09:36.586
Now, most of time this is
going to work transparently,

00:09:36.586 --> 00:09:38.856
because these structures
are used entirely

00:09:38.856 --> 00:09:40.236
within our application

00:09:40.236 --> 00:09:42.926
and everything gets the new
definition and works fine.

00:09:44.146 --> 00:09:46.806
But, if we're doing something
like a representation

00:09:46.806 --> 00:09:50.556
of an on-disk file format
communicating across a network

00:09:50.556 --> 00:09:54.436
to another process that is going
to rely on the exact layout

00:09:54.436 --> 00:09:58.056
of a structure, that
can go badly.

00:09:58.056 --> 00:10:01.086
So again, on any of those
data structures we want

00:10:01.086 --> 00:10:07.496
to use the C fixed type,
fixed size types to make sure

00:10:07.496 --> 00:10:09.316
that we get what we want,
whether we're building

00:10:09.316 --> 00:10:12.876
for 64-bit iOS or
for 32-bit iOS.

00:10:14.756 --> 00:10:18.166
So in summary, building
for 64-bit iOS is easy,

00:10:18.636 --> 00:10:23.596
it's a default, and the
compiler will help find

00:10:23.596 --> 00:10:25.136
and resolve any issues.

00:10:26.116 --> 00:10:29.736
But, this isn't the only
thing that we've been up to.

00:10:29.816 --> 00:10:33.056
We've also been making
advances in Objective-C

00:10:34.086 --> 00:10:36.596
and the compiler
can help here, too.

00:10:37.996 --> 00:10:39.906
The language has
continued to move forward.

00:10:40.386 --> 00:10:43.166
Some of this really helps with
the interoperability with SWF

00:10:43.286 --> 00:10:46.006
as well, as you may be
seeing in that talk.

00:10:46.006 --> 00:10:47.656
I highly encourage
you to check it out.

00:10:47.656 --> 00:10:50.116
It's happening at the same time
as this one, so go and look

00:10:50.116 --> 00:10:53.516
on the video when that
comes on the WWDC app.

00:10:53.566 --> 00:10:59.776
And, whenever we write new
code, we've been using all

00:10:59.776 --> 00:11:02.046
of these advancements
in the language

00:11:02.626 --> 00:11:05.436
to get the modern best
practices, more expressive code,

00:11:05.436 --> 00:11:10.386
but then we have all of this
older legacy code that we'd

00:11:10.386 --> 00:11:12.776
like to adopt all of these
features in, as well.

00:11:13.026 --> 00:11:15.436
But, that's a lot of
code to go read through

00:11:15.436 --> 00:11:19.216
and manually find all of these
things, so we have a tool

00:11:19.216 --> 00:11:22.196
that will help us
identify the opportunities

00:11:22.746 --> 00:11:24.686
where we can use
these new features.

00:11:24.926 --> 00:11:28.496
And, I think the best
way to talk about that is

00:11:28.496 --> 00:11:32.066
to show you with the demo.

00:11:32.686 --> 00:11:37.576
Now, rather than use some
contrived example code here,

00:11:37.576 --> 00:11:39.376
I thought we'd maybe
look at something

00:11:39.376 --> 00:11:40.966
that we all are familiar with,

00:11:40.966 --> 00:11:44.326
at least as users,
and our WWDC app.

00:11:45.236 --> 00:11:47.246
That code has been
with us for a while.

00:11:47.246 --> 00:11:48.696
We update it every year.

00:11:49.126 --> 00:11:53.326
And, with the modernizer we
wanted to use that to look at it

00:11:53.326 --> 00:11:55.986
and find out if there
are perhaps some places

00:11:55.986 --> 00:11:58.486
in the codebase that we
missed for opportunities

00:11:59.496 --> 00:12:01.516
to use new Objective-C features.

00:12:02.396 --> 00:12:04.786
So, let's look and
see what a few

00:12:04.786 --> 00:12:06.396
of those things that
we found are.

00:12:06.876 --> 00:12:11.246
If we go under Edit to refactor,
we can convert our project

00:12:11.356 --> 00:12:13.246
to modern Objective-C syntax.

00:12:14.136 --> 00:12:16.796
We get a dialog box telling
us what we've just selected,

00:12:16.896 --> 00:12:18.676
so make sure that we've
got the right thing.

00:12:20.476 --> 00:12:21.486
We can select whether --

00:12:21.566 --> 00:12:23.886
which targets in our
project to modernize.

00:12:23.886 --> 00:12:26.876
In this case, we're looking
at the WWDC app, itself.

00:12:27.476 --> 00:12:32.406
In the previous versions of
Xcode, the modernizer would go

00:12:32.466 --> 00:12:33.716
through and just look

00:12:33.806 --> 00:12:36.246
for Objective-C literals
and subscripting.

00:12:36.246 --> 00:12:38.596
But now, we have more options.

00:12:39.606 --> 00:12:42.476
Now personally, I prefer not
to do all of these at once.

00:12:42.476 --> 00:12:45.566
That tends to be a little too
much to swap back-and-forth,

00:12:45.596 --> 00:12:48.156
so I tend to want to
select a few things.

00:12:48.446 --> 00:12:51.616
I'm going to look for
instance type here

00:12:51.616 --> 00:12:53.866
that we can get our
initialization methods more

00:12:53.866 --> 00:12:54.616
strongly typed.

00:12:54.616 --> 00:12:58.596
I'm going to try and find if we
missed any read/write properties

00:12:58.596 --> 00:13:01.726
where we convert explicit
getter/setter methods.

00:13:02.316 --> 00:13:05.116
And, we're going to
look to use NS ENUM

00:13:05.496 --> 00:13:08.766
for our enumeration values
so the compiler can cooperate

00:13:08.766 --> 00:13:11.156
with the runtime to
give better results.

00:13:12.246 --> 00:13:16.736
Click Next, and the compiler
will run over our code

00:13:16.986 --> 00:13:20.216
and it turns out we do, indeed,
have a few more suggestions

00:13:20.216 --> 00:13:21.506
for what we can look at.

00:13:22.176 --> 00:13:25.016
Now, do keep in mind that
these are just suggestions,

00:13:25.866 --> 00:13:27.406
that we need to go
through and look

00:13:27.406 --> 00:13:30.656
at the side-by-side diff here,
where we have the new code

00:13:30.656 --> 00:13:35.026
on the left, the old code on the
right, and we look through here.

00:13:35.026 --> 00:13:36.226
This looks fine.

00:13:36.926 --> 00:13:38.196
Everything looks good here.

00:13:38.196 --> 00:13:39.556
We're converting to ENUMS.

00:13:40.066 --> 00:13:42.096
Let's look at our next one.

00:13:42.936 --> 00:13:46.036
This looks a little
bit different,

00:13:46.036 --> 00:13:50.686
because we still have this NS
integer over here that looks

00:13:50.686 --> 00:13:52.196
like it'd be straightforward
to clean up,

00:13:52.196 --> 00:13:54.116
but I'd rather come
back to this later.

00:13:54.116 --> 00:13:55.076
I just want to deal
with the things

00:13:55.076 --> 00:13:56.756
that we can do automatically
right now.

00:13:57.416 --> 00:14:00.546
So, I tell the modernizer
to discard that change.

00:14:00.996 --> 00:14:03.396
It wants to make sure
that I'm doing that.

00:14:03.396 --> 00:14:04.966
Yes, I am absolutely sure.

00:14:04.966 --> 00:14:07.396
I can do the same here.

00:14:08.876 --> 00:14:11.646
We could also tell it to ignore
all of the changes in this file

00:14:11.646 --> 00:14:12.846
with this Check button here.

00:14:13.406 --> 00:14:16.366
And now, it's also found a place

00:14:17.026 --> 00:14:18.396
where we can use
an instance type.

00:14:18.696 --> 00:14:23.296
And, that all looks good
so we tell it to save.

00:14:24.236 --> 00:14:26.086
And, Xcode will now
tell us that, "Oh!

00:14:26.086 --> 00:14:29.926
We can update our project as
well, and take snapshots."

00:14:30.376 --> 00:14:31.416
That sounds great.

00:14:31.416 --> 00:14:33.216
Let's let it do that
because backups are good.

00:14:33.216 --> 00:14:36.476
And now, our project is
saved, it's been rebuilt,

00:14:37.286 --> 00:14:42.416
and the Objective-C modernizer
works to update our code

00:14:42.416 --> 00:14:45.026
and help us find places
where we can take advantage

00:14:45.326 --> 00:14:46.216
of new features.

00:14:46.846 --> 00:14:51.046
But, this isn't the only
place that we've made advances

00:14:51.616 --> 00:14:55.086
for Objective-C and
for interoperability.

00:14:55.136 --> 00:14:58.886
And, to tell you more about that
I'd like to invite my friend

00:14:58.886 --> 00:15:00.036
and coworker, Bob Wilson.

00:15:00.246 --> 00:15:01.066
Thank you, Bob.

00:15:02.516 --> 00:15:07.576
[ Applause ]

00:15:08.076 --> 00:15:08.516
>> Thank you, Jim.

00:15:10.186 --> 00:15:12.006
So, modules are another way

00:15:12.096 --> 00:15:14.476
that LLVM can help
modernize your code.

00:15:14.726 --> 00:15:18.066
We introduced modules just last
year, but in cases you missed

00:15:18.066 --> 00:15:19.786
that let's start
with some background.

00:15:22.056 --> 00:15:24.896
So, before modules we
had precompiled headers,

00:15:25.136 --> 00:15:28.556
which are often an effective
way to speed up the compilation

00:15:28.556 --> 00:15:31.286
of your code, but they
do have some limitations.

00:15:32.196 --> 00:15:35.606
You can only have one
precompiled header at a time,

00:15:36.516 --> 00:15:39.536
and more importantly,
the whole approach

00:15:39.536 --> 00:15:43.156
of using a textual inclusion
of a header file as a way

00:15:43.156 --> 00:15:45.846
of importing a framework
is just fragile.

00:15:46.916 --> 00:15:48.396
We have a deal with the issue

00:15:48.396 --> 00:15:51.266
where a header file gets
included more than once

00:15:51.266 --> 00:15:52.406
in a single compilation.

00:15:53.606 --> 00:15:55.986
We have also a problem
of headers being fragile.

00:15:56.526 --> 00:15:59.346
And, what I mean by
that is that the meaning

00:15:59.346 --> 00:16:01.956
of the header can change
depending on the environment

00:16:02.236 --> 00:16:05.246
where it's imported, and let me
show you that with an example.

00:16:06.706 --> 00:16:09.936
So here, I've defined a macro
count to the value of 100,

00:16:10.266 --> 00:16:12.266
and then I import the
foundation framework.

00:16:13.256 --> 00:16:17.056
Now, inside the foundation
header there's an include

00:16:17.096 --> 00:16:18.586
for the NSArray definition.

00:16:19.346 --> 00:16:21.786
An NSArray has an
ivar, the count.

00:16:22.726 --> 00:16:26.896
So, the macro of count gets
substituted as literal text

00:16:27.356 --> 00:16:30.296
in that place and we end up
with completely broken code

00:16:30.296 --> 00:16:32.936
where instead of the ivar
name, we have a value of 100.

00:16:33.856 --> 00:16:35.876
This is what I mean by
headers being fragile.

00:16:37.296 --> 00:16:40.696
Modules solve this problem
by replacing the model

00:16:40.696 --> 00:16:43.996
of textual inclusion
with a semantic import.

00:16:44.326 --> 00:16:48.426
And, there's a lot more detail
about modules in the Advances

00:16:48.426 --> 00:16:50.956
in Objective-C presentation
from last year's WWDC

00:16:50.956 --> 00:16:52.556
and I encourage you to watch

00:16:52.556 --> 00:16:54.146
that if you're not
familiar with modules.

00:16:55.816 --> 00:16:58.466
Until now, modules have
only been available

00:16:58.516 --> 00:16:59.776
for the system frameworks.

00:17:01.106 --> 00:17:04.286
New in Xcode 6, you
can now define modules

00:17:04.476 --> 00:17:07.906
for your own frameworks as
well for C and Objective-C.

00:17:09.156 --> 00:17:11.866
Besides fixing the
problems we just looked at,

00:17:11.986 --> 00:17:13.356
this also gives you a way

00:17:13.356 --> 00:17:16.886
of importing your own
framework into your SWF code.

00:17:17.586 --> 00:17:19.286
And as Jim mentioned,
there's another session

00:17:19.286 --> 00:17:22.336
on integrating SWF with
Objective-C that I encourage you

00:17:22.336 --> 00:17:24.425
to watch the video to
learn more about that.

00:17:25.675 --> 00:17:27.556
So if you want to do this, how?

00:17:28.806 --> 00:17:29.986
It's really very easy.

00:17:30.946 --> 00:17:32.926
For most frameworks
it's possible

00:17:32.926 --> 00:17:35.656
to define a single
umbrella header

00:17:35.916 --> 00:17:38.126
that imports all of
the framework API.

00:17:38.606 --> 00:17:40.866
And, this is what we
recommend that you do

00:17:41.276 --> 00:17:43.976
as it is the easiest
way to adopt a module.

00:17:45.046 --> 00:17:48.046
Once you've done that, simply
go to the Xcode BUILD settings

00:17:48.256 --> 00:17:52.756
for your framework and in the
packaging section set Defines

00:17:52.756 --> 00:17:55.616
Module to Yes, and that's it.

00:17:55.616 --> 00:17:57.176
It really is very easy.

00:17:57.796 --> 00:17:59.896
Now, if you have a more
complicated framework

00:18:00.116 --> 00:18:03.516
where that single umbrella
header is not sufficient,

00:18:03.516 --> 00:18:05.146
you can use a custom module map.

00:18:05.946 --> 00:18:08.236
And, there's more
information to describe how

00:18:08.236 --> 00:18:09.846
that works on the LLVM website.

00:18:12.036 --> 00:18:14.506
After you've created a
module you'll want to use it.

00:18:15.396 --> 00:18:16.036
How do you do that?

00:18:17.226 --> 00:18:21.516
There's an @import keyword
followed by the module name

00:18:21.856 --> 00:18:24.076
that tells the compiler, "I
want to import this module."

00:18:24.726 --> 00:18:27.636
If you haven't had a
chance to update your code

00:18:27.636 --> 00:18:28.716
and you're still --

00:18:28.716 --> 00:18:31.726
have a #import to include
the umbrella header,

00:18:31.726 --> 00:18:33.986
the compiler's smart
enough to know

00:18:34.206 --> 00:18:37.416
that this is now a modular
framework and it will go ahead

00:18:37.416 --> 00:18:40.426
and treat that as an implicit
modular import anyway.

00:18:41.966 --> 00:18:45.516
So just as a guideline though,
we do recommend you use @import

00:18:46.396 --> 00:18:49.536
when you're importing your
framework into a separate target

00:18:49.536 --> 00:18:53.036
within your project just because
it makes it clear in the source

00:18:53.116 --> 00:18:56.326
that you really intend for
this to be a modular import.

00:18:57.646 --> 00:19:00.466
One exception to that is
within the implementation

00:19:00.466 --> 00:19:01.776
of your framework, itself.

00:19:02.476 --> 00:19:05.746
It doesn't make any sense to
import a framework into itself

00:19:05.746 --> 00:19:09.006
and so, in that case, you
really need to use #import

00:19:09.006 --> 00:19:11.096
to textually include
the framework headers,

00:19:11.276 --> 00:19:13.286
just within the implementation
of the framework.

00:19:14.846 --> 00:19:17.616
And, besides those guidelines,
we have a few other rules

00:19:17.616 --> 00:19:19.876
about modules that you
should be aware of.

00:19:20.286 --> 00:19:23.916
First, don't expose
any non-modular headers

00:19:23.916 --> 00:19:24.966
in your framework API.

00:19:26.186 --> 00:19:28.786
It's fine to import
another module, like Cocoa,

00:19:29.296 --> 00:19:32.266
but if I have an import of
something like Postgres.h,

00:19:32.266 --> 00:19:34.226
which presumably
is not a module,

00:19:34.986 --> 00:19:37.156
you can put that down
inside the implementation

00:19:37.156 --> 00:19:40.366
of your framework, but
don't expose it in the API.

00:19:42.596 --> 00:19:46.436
One other issue is that
modules can change the semantics

00:19:46.526 --> 00:19:47.146
of your code.

00:19:47.636 --> 00:19:50.386
We saw earlier the
problem of a fragile header

00:19:50.496 --> 00:19:53.676
where a macro definition
inadvertently broke the code.

00:19:54.206 --> 00:19:56.256
Sometimes you might want
to do this on purpose,

00:19:56.286 --> 00:19:59.236
and I'm showing here an example
where I've defined a macro,

00:19:59.336 --> 00:20:03.226
DEBUG, as a flag to enable
additional debugging APIs

00:20:03.896 --> 00:20:04.726
in my framework.

00:20:06.386 --> 00:20:08.806
By switching that
framework to be a module,

00:20:08.806 --> 00:20:10.846
the DEBUG macro defined

00:20:10.846 --> 00:20:13.066
in my source code no
longer has any effect,

00:20:13.196 --> 00:20:14.426
which is not what I wanted.

00:20:15.296 --> 00:20:17.726
Now, that limitation
only applies to macros

00:20:17.726 --> 00:20:19.716
that are defined
in the source code.

00:20:19.966 --> 00:20:22.066
So, if you really want to
do something like this,

00:20:22.546 --> 00:20:26.146
one alternative is to define
the macro on the command line

00:20:26.276 --> 00:20:27.726
or in the Xcode build settings.

00:20:30.086 --> 00:20:31.716
So, that is user-defined
modules.

00:20:31.906 --> 00:20:33.466
It's really pretty
straightforward

00:20:33.466 --> 00:20:36.096
in the common case, and it
gives you fast compilation,

00:20:36.436 --> 00:20:40.076
clear semantics, and a way of
interoperating with SWF code.

00:20:42.396 --> 00:20:44.826
So far, we've been
talking a lot about ways

00:20:44.826 --> 00:20:47.016
that LLVM helps you
modernize your code

00:20:47.016 --> 00:20:52.106
and adopt modern Objective-C
modules, but let's turn now

00:20:52.106 --> 00:20:53.346
and look at performance,

00:20:53.446 --> 00:20:55.566
which is the other theme
of this presentation.

00:20:56.846 --> 00:21:02.766
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6

00:21:03.316 --> 00:21:04.606
and it gives you a way

00:21:04.606 --> 00:21:07.206
of getting even more
performance out of your code.

00:21:08.436 --> 00:21:11.836
Let me give you an overall
high-level understanding

00:21:11.836 --> 00:21:13.396
of what this is about.

00:21:14.506 --> 00:21:17.426
One of the inherent
challenges for the compiler is

00:21:17.426 --> 00:21:19.656
that it has no way of
knowing what the input

00:21:19.656 --> 00:21:20.946
to your program is going to be.

00:21:21.356 --> 00:21:24.006
The only input to the
compiler is your source code.

00:21:25.176 --> 00:21:27.106
So, the compiler has to assume

00:21:27.366 --> 00:21:29.346
that all inputs are
equally likely.

00:21:30.506 --> 00:21:32.096
There are some cases
where it can guess

00:21:32.536 --> 00:21:35.116
that certain code paths will
be more common than others.

00:21:35.856 --> 00:21:39.346
For example, it can assume that
going through a loop is going

00:21:39.346 --> 00:21:41.516
to happen more often than
code outside of that loop.

00:21:42.246 --> 00:21:44.246
But, those are just guesses
and there are a lot of things

00:21:44.246 --> 00:21:45.496
that it simply can't know.

00:21:47.286 --> 00:21:50.616
If we provide a profile
as an additional input

00:21:50.616 --> 00:21:55.486
to the compiler it can now try
to optimize for the common case

00:21:55.816 --> 00:21:58.736
and do a better job
of optimization.

00:21:59.216 --> 00:22:01.036
And, what I mean
by a profile, here,

00:22:01.226 --> 00:22:03.876
is simply a count how
many times each statement

00:22:03.876 --> 00:22:08.366
in your app executes in a
typical run of your app.

00:22:09.086 --> 00:22:12.086
You may be wondering, "How do
I get a profile like that?"

00:22:12.466 --> 00:22:14.166
Again, we could use
the compiler here

00:22:14.826 --> 00:22:17.616
to generate a special
instrumented app

00:22:17.676 --> 00:22:19.316
that as it runs is going

00:22:19.316 --> 00:22:22.276
to count how many times
each statement executes.

00:22:22.606 --> 00:22:24.146
And then, when your app finishes

00:22:24.146 --> 00:22:26.676
with this special instrumented
version, it will write

00:22:26.676 --> 00:22:29.706
out that profile which
we can then use for PGO.

00:22:31.896 --> 00:22:34.936
So, how does the compiler
use that profile information?

00:22:35.736 --> 00:22:37.106
There are an awful lot of ways.

00:22:37.236 --> 00:22:39.636
So many optimizations
can benefit from this,

00:22:40.326 --> 00:22:41.916
but I'm highlighting
just three here

00:22:41.916 --> 00:22:43.316
that are particularly valuable.

00:22:43.946 --> 00:22:45.046
One is to the inliner.

00:22:46.066 --> 00:22:48.166
If we know that a
function is really hot,

00:22:48.166 --> 00:22:50.706
and by that I mean it's
run a lot, over and over.

00:22:51.256 --> 00:22:54.936
The inliner can be much more
aggressive about inlining that.

00:22:55.226 --> 00:22:57.016
When we're generating
the code we can try

00:22:57.016 --> 00:22:59.696
to layout the common
paths through your code

00:23:00.126 --> 00:23:02.246
so that they're contiguous,
which makes it easy

00:23:02.246 --> 00:23:04.156
for the processor
to run them fast.

00:23:04.986 --> 00:23:08.006
And the register allocator
can also try to keep values

00:23:08.066 --> 00:23:12.466
in registers throughout
those most common paths.

00:23:12.766 --> 00:23:14.006
Let's look at an example just

00:23:14.006 --> 00:23:16.306
to give you a better
understanding of this.

00:23:16.836 --> 00:23:20.286
This is some C++ code that's
going to iterate over a set

00:23:20.286 --> 00:23:22.306
of colored objects and
for each one it's going

00:23:22.306 --> 00:23:24.146
to update the position
of the object.

00:23:24.596 --> 00:23:27.646
So, at the top I've got
a loop over the objects,

00:23:28.206 --> 00:23:29.016
and for each one I'm going

00:23:29.016 --> 00:23:30.956
to call my Update
Position function.

00:23:32.066 --> 00:23:33.906
And, Update Position is
going to look and see

00:23:34.166 --> 00:23:38.206
if the object is red it moves in
a very simple horizontal line,

00:23:38.206 --> 00:23:39.456
so the code is really simple.

00:23:40.146 --> 00:23:42.266
But, if the object
is blue, let's assume

00:23:42.516 --> 00:23:44.696
that the movement is
much more complicated,

00:23:44.696 --> 00:23:46.796
I've got a very large
block of code here.

00:23:48.126 --> 00:23:51.416
Now, the compiler has no way
of knowing whether red objects

00:23:51.416 --> 00:23:53.216
or blue objects are more likely,

00:23:53.256 --> 00:23:56.196
so it just assumes they're
both equally likely.

00:23:56.196 --> 00:23:59.856
But, with PGO I might
be able to know

00:23:59.856 --> 00:24:02.796
that red objects
are far more common.

00:24:03.326 --> 00:24:05.906
And so, I'm highlighting
in red here the hot code,

00:24:06.346 --> 00:24:09.116
which is the code to iterate
over the set of objects and then

00:24:09.116 --> 00:24:10.546
to handle the red objects.

00:24:11.536 --> 00:24:14.986
I'm going to color-code
the cold code in blue,

00:24:15.016 --> 00:24:16.736
which is blue objects
which are rare

00:24:16.736 --> 00:24:18.346
for some reason in
this application.

00:24:19.216 --> 00:24:22.056
And then, let's look at how the
compiler would handle this code.

00:24:24.016 --> 00:24:27.786
Here's kind of the default code
layout that matches, roughly,

00:24:27.786 --> 00:24:29.286
the original source order.

00:24:29.606 --> 00:24:31.416
We've got the hot loop outside,

00:24:31.416 --> 00:24:34.346
and then the Update
Position function down below,

00:24:34.556 --> 00:24:37.536
with a little bit
of hot code in it.

00:24:38.486 --> 00:24:41.606
Inlining is one of the most
important optimizations

00:24:42.346 --> 00:24:45.826
and we'd really like to inline
that Update Position function.

00:24:46.226 --> 00:24:48.686
But, the compiler
can't inline everything

00:24:49.266 --> 00:24:52.586
or the code would bloat beyond a
point where it would be useful.

00:24:53.796 --> 00:24:57.006
But in this case, the Update
Position function is big

00:24:57.046 --> 00:24:59.916
because of all that cold code
for handling the blue objects

00:25:00.876 --> 00:25:02.646
and so it wouldn't
normally be inlined.

00:25:02.956 --> 00:25:05.866
But, because PGO tells us
there's some really hot code

00:25:05.866 --> 00:25:09.896
here, the inliner can be much
more aggressive about that

00:25:09.896 --> 00:25:11.216
in this particular case.

00:25:11.936 --> 00:25:16.046
So, we take the loop iterating
over the objects and split

00:25:16.046 --> 00:25:20.546
that in half and move the Update
Position code right inline.

00:25:21.416 --> 00:25:22.706
So, this is much better now.

00:25:22.706 --> 00:25:25.406
We've got a lot of the
hot code right together,

00:25:25.406 --> 00:25:29.966
but we've still got a big chunk
of this code for blue objects,

00:25:29.966 --> 00:25:31.816
the cold code, right in
the middle of our loop.

00:25:32.696 --> 00:25:36.596
And, PGO can help this, as well,
by changing the code layout.

00:25:36.926 --> 00:25:40.456
It knows that that code is cold
and can move it down below,

00:25:40.456 --> 00:25:43.436
out of the way, and we end
up with a nice tight loop

00:25:43.746 --> 00:25:45.016
that can run really fast.

00:25:45.536 --> 00:25:48.906
And, it also typically
enables other optimizations

00:25:48.906 --> 00:25:49.906
on that hot code.

00:25:51.146 --> 00:25:53.416
So obviously, this is
a simplified example,

00:25:53.416 --> 00:25:56.216
but hopefully gives you a
feel of the power of PGO

00:25:56.216 --> 00:25:58.486
and just how much it
can help the optimizer.

00:26:00.056 --> 00:26:01.606
So, you may want to use it.

00:26:02.406 --> 00:26:03.496
When does it make sense?

00:26:04.406 --> 00:26:07.746
The compiler does a really
good job optimizing by default.

00:26:08.916 --> 00:26:11.636
With PGO, if you do just
a little bit of extra work

00:26:11.856 --> 00:26:15.146
to gather the profile,
you can do even better.

00:26:15.826 --> 00:26:17.666
So obviously, if you're happy

00:26:17.666 --> 00:26:19.616
with the performance
you're already getting,

00:26:20.126 --> 00:26:21.806
you're probably not
motivated to do that --

00:26:22.036 --> 00:26:23.506
even that little
bit of extra work.

00:26:23.936 --> 00:26:25.966
But, if you need
more performance,

00:26:26.486 --> 00:26:28.486
by all means, give it a try.

00:26:29.136 --> 00:26:31.066
And, let me show
you some examples

00:26:31.066 --> 00:26:32.436
of just how much it can help.

00:26:33.676 --> 00:26:36.886
This is a graph showing
the speedup.

00:26:36.886 --> 00:26:38.876
Compare it with PGO
compared to a case

00:26:38.876 --> 00:26:40.636
of just a normal optimize build.

00:26:41.446 --> 00:26:44.206
And, I'm looking at four
different applications here;

00:26:44.206 --> 00:26:47.516
the Apple LLVM compiler
itself, applying PGO

00:26:47.606 --> 00:26:50.766
to the compiler itself,
the SQLite database,

00:26:51.246 --> 00:26:53.596
the PERL interpreter, and
gzip file compression.

00:26:54.676 --> 00:26:56.736
And, PGO gives us
speedups ranging

00:26:56.736 --> 00:26:59.456
from about 4% all
the way up to 18%.

00:27:00.786 --> 00:27:02.806
So, not all apps will
benefit this much.

00:27:03.026 --> 00:27:04.646
It really varies,
depending on the app,

00:27:05.116 --> 00:27:07.426
but clearly there's a
lot of potential here.

00:27:09.676 --> 00:27:12.606
So, if you want to try it,
how do you go about that?

00:27:13.166 --> 00:27:15.016
PGO is really easy to use.

00:27:15.616 --> 00:27:17.476
The first step is to
collect a profile.

00:27:17.476 --> 00:27:20.186
I'm going to come back and talk
about that in just a minute.

00:27:21.286 --> 00:27:24.146
Once you've done that, simply
go in the Xcode Build settings

00:27:24.146 --> 00:27:27.676
for your project and find
the Use Optimization Profile

00:27:27.676 --> 00:27:30.096
setting, and set it
to Yes, typically just

00:27:30.096 --> 00:27:31.446
for the release configuration.

00:27:32.216 --> 00:27:32.886
And that's it!

00:27:32.886 --> 00:27:34.576
You've enabled PGO.

00:27:35.696 --> 00:27:36.576
Once you've done that,

00:27:36.576 --> 00:27:39.326
as you continue developing
your app you may change it

00:27:39.326 --> 00:27:41.176
as you fix bugs, you
add new features,

00:27:41.876 --> 00:27:44.336
the code becomes
gradually out of sync

00:27:44.336 --> 00:27:46.136
with the profile you've
collected earlier.

00:27:47.096 --> 00:27:50.996
And, when that happens, the
compiler will simply fail to use

00:27:50.996 --> 00:27:52.486
that profile information.

00:27:52.486 --> 00:27:53.636
It won't break anything,

00:27:53.636 --> 00:27:56.666
you just gradually lose
the optimization benefit.

00:27:56.666 --> 00:27:58.986
And when that happens, it
will give you a warning.

00:27:59.966 --> 00:28:01.636
So, if you see warnings
like this,

00:28:01.636 --> 00:28:04.866
saying that your profile may
be out of date, as you see more

00:28:04.866 --> 00:28:06.866
and more of them, it's a good
indication to you that's time

00:28:06.866 --> 00:28:09.376
to go back and update
your profile.

00:28:10.726 --> 00:28:13.876
So, let's turn now and look at,
how do you generate the profile?

00:28:15.166 --> 00:28:19.406
Xcode 6 has a new command,
Generate Optimization Profile.

00:28:20.096 --> 00:28:21.176
When you run this command,

00:28:21.376 --> 00:28:24.316
Xcode will build the special
instrumented version of your app

00:28:24.316 --> 00:28:27.096
and then run it, and
you can then interact

00:28:27.096 --> 00:28:29.506
with the running app to
generate the profile.

00:28:29.506 --> 00:28:31.616
When it finishes running, it
will write out the profile

00:28:31.616 --> 00:28:32.956
and add it to your project.

00:28:34.316 --> 00:28:37.156
As you're running your app,
keep in mind it's important

00:28:37.156 --> 00:28:40.056
to exercise all of the
code that's important

00:28:40.056 --> 00:28:41.076
for your performance.

00:28:41.626 --> 00:28:43.906
If I have a game with
three different levels

00:28:44.416 --> 00:28:47.966
and I only play the first level
of my game, the compiler's going

00:28:47.966 --> 00:28:49.856
to assume that that's the
only thing that really matters

00:28:49.856 --> 00:28:52.096
and not work as hard
on the other levels.

00:28:54.356 --> 00:28:57.166
Now, you may be wondering, "If
I've written a really hard game,

00:28:57.936 --> 00:29:00.746
it may take a while to play
the whole thing to completion."

00:29:01.396 --> 00:29:03.476
That could be a problem, right?

00:29:03.546 --> 00:29:05.966
So, Xcode has another option,

00:29:07.116 --> 00:29:10.076
which is to use your
performance tests as inputs

00:29:10.076 --> 00:29:11.286
to drive the profiling.

00:29:12.496 --> 00:29:15.296
Performance tests are a
new feature in Xcode 6.

00:29:15.796 --> 00:29:17.246
If you'd like to
learn more about them,

00:29:17.376 --> 00:29:19.096
there's a session right
here tomorrow morning

00:29:19.096 --> 00:29:20.756
on testing in Xcode 6.

00:29:21.586 --> 00:29:25.436
And, if you care about
performance you want to set

00:29:25.436 --> 00:29:28.406
up these performance tests
anyway, to catch regressions

00:29:28.406 --> 00:29:30.406
in your code, just to keep
track of how you're doing.

00:29:31.296 --> 00:29:34.276
And once you've gone to
that trouble to set them up,

00:29:34.776 --> 00:29:36.906
in most cases they're
pretty good inputs

00:29:36.906 --> 00:29:38.176
for driving this profile.

00:29:40.106 --> 00:29:42.396
Again though, keep in
mind it's important

00:29:42.596 --> 00:29:45.116
that your tests cover
the code in a way

00:29:45.116 --> 00:29:47.566
that reflects the
typical usage of your app.

00:29:47.946 --> 00:29:51.066
Going back to my three-level
game, if I write lots of tests

00:29:51.066 --> 00:29:53.356
for the first level and
only a few for the second

00:29:53.356 --> 00:29:56.006
and third level, again,
the compiler's going to end

00:29:56.006 --> 00:29:59.216
up optimizing more heavily
for that first level.

00:30:00.656 --> 00:30:03.416
Another benefit of using tests
is it gives you a great way

00:30:03.746 --> 00:30:06.306
of evaluating, how
much does PGO help me?

00:30:06.306 --> 00:30:07.726
You can just run your tests.

00:30:08.086 --> 00:30:10.286
Now, let me show you
that with a demo now.

00:30:12.376 --> 00:30:14.556
So, with the release
of the SWF language,

00:30:15.286 --> 00:30:18.026
we thought it would be
fun to make a demo app

00:30:18.026 --> 00:30:19.016
that would celebrate that.

00:30:19.986 --> 00:30:21.566
And so, rather than
the SWF language,

00:30:21.566 --> 00:30:25.056
we thought of the SWF birds
and we made an application

00:30:25.196 --> 00:30:28.326
that uses the Boids
Artificial Life Simulation

00:30:29.326 --> 00:30:30.816
to simulate a flock of SWFs.

00:30:33.146 --> 00:30:35.206
And, I can create a
whole bunch of them here

00:30:35.206 --> 00:30:36.436
and let them fly around.

00:30:36.516 --> 00:30:40.686
And, the way this Boids
application works is

00:30:40.686 --> 00:30:44.986
that each bird, or Boid,
compares its position to all

00:30:44.986 --> 00:30:48.346
of the other ones on the screen
and it calculates the distance

00:30:48.346 --> 00:30:52.066
between them to find the flock
of the birds nearest to it.

00:30:53.016 --> 00:30:57.136
And then, each Boid
has competing urges.

00:30:57.136 --> 00:30:59.446
On the one hand, it
wants to move closer

00:30:59.446 --> 00:31:00.696
to the center of the flock.

00:31:00.696 --> 00:31:03.886
At the same time, it doesn't
want to get too close.

00:31:04.676 --> 00:31:08.986
And so, if it gets too close to
another one it will move apart.

00:31:10.066 --> 00:31:12.946
And the performance of that,
as we add more and more

00:31:12.946 --> 00:31:15.666
of these Boids, could
become a problem.

00:31:16.466 --> 00:31:20.086
So, we set up a performance
test to track that,

00:31:20.936 --> 00:31:24.216
and this is a really
simple performance test.

00:31:25.576 --> 00:31:29.296
We set up a scene with 200 Boids
and measured the time it takes

00:31:29.296 --> 00:31:31.686
to update their positions
100 times,

00:31:31.686 --> 00:31:32.816
and that's our performance test.

00:31:32.816 --> 00:31:33.716
So, let's run that.

00:31:34.476 --> 00:31:36.376
Because I care about
performance,

00:31:36.816 --> 00:31:39.806
I'm going to edit my
current scheme to make sure

00:31:39.806 --> 00:31:41.656
that my test step is going

00:31:41.656 --> 00:31:44.186
to use the release-built
configuration

00:31:44.586 --> 00:31:46.436
so that we get optimized
results.

00:31:47.616 --> 00:31:49.726
And, I'll go to the
Product Test menu

00:31:51.376 --> 00:31:53.096
and run my performance
test here.

00:31:57.526 --> 00:31:57.936
All right.

00:31:58.086 --> 00:32:00.486
And now, because I haven't run
the test before I don't have a

00:32:00.536 --> 00:32:02.086
baseline, so let's go ahead

00:32:02.086 --> 00:32:06.536
and set the baseline
based on that first run.

00:32:07.666 --> 00:32:10.366
And now, let's try adding PGO.

00:32:11.256 --> 00:32:13.636
Under the Product
menu, Perform Action,

00:32:14.246 --> 00:32:16.636
down at the bottom here is this
new command I told you about,

00:32:16.636 --> 00:32:18.496
Generate Optimization Profile.

00:32:19.136 --> 00:32:22.516
I get two choices; I can
either run the application

00:32:23.616 --> 00:32:25.446
or I can use my performance
test.

00:32:25.446 --> 00:32:28.016
And, I'd like to show you how it
works with the performance test.

00:32:29.026 --> 00:32:33.256
I just click Build and Run,
and Xcode, very helpfully,

00:32:33.396 --> 00:32:35.906
warns me that I haven't
yet enabled PGO

00:32:35.906 --> 00:32:38.616
in the Build settings
and it offers to do that.

00:32:38.616 --> 00:32:41.196
So, let's go ahead and
let it enable that.

00:32:41.486 --> 00:32:44.236
It's now building a special
instrumented version of our app

00:32:44.236 --> 00:32:48.736
and running it using
the performance test.

00:32:49.136 --> 00:32:50.406
And when those tests finish --

00:32:52.516 --> 00:32:55.436
ah, I got a warning
here, an error.

00:32:55.436 --> 00:32:57.586
Let me just explain
what's happened here is

00:32:57.616 --> 00:33:00.016
that because we've
run the app with a lot

00:33:00.016 --> 00:33:02.966
of the instrumentation
code, it runs more slowly.

00:33:03.246 --> 00:33:05.616
But, this is just being
used to generate the profile

00:33:05.616 --> 00:33:06.656
so that's not a problem.

00:33:07.026 --> 00:33:10.016
I'm going to go back to the
Project Navigator a minute

00:33:10.616 --> 00:33:13.666
and show you that Xcode has
added this new Optimization

00:33:13.666 --> 00:33:14.836
Profiles folder.

00:33:15.446 --> 00:33:18.806
And inside of that, if you can
see it, there's my profile data.

00:33:20.066 --> 00:33:20.826
So, that's great!

00:33:21.416 --> 00:33:23.776
PGO is enabled, we
have a profile.

00:33:23.776 --> 00:33:25.676
Let's rerun those
performance tests.

00:33:26.276 --> 00:33:27.786
We'll go back to
run Product Test,

00:33:28.946 --> 00:33:30.156
and see how much does it help?

00:33:30.156 --> 00:33:34.956
And the tests are running now.

00:33:36.376 --> 00:33:39.036
And, wow, we got a 21%
improvement just like that.

00:33:39.386 --> 00:33:41.696
We didn't have to change the
code or do anything else.

00:33:42.516 --> 00:33:49.286
[ Applause ]

00:33:49.786 --> 00:33:51.276
So, that is PGO.

00:33:51.626 --> 00:33:54.836
It's a great new feature to help
you get even more performance,

00:33:54.946 --> 00:33:57.346
when you care about
getting every last drop

00:33:57.346 --> 00:33:58.006
out of your code.

00:33:59.136 --> 00:34:01.186
Continuing on this
theme of performance,

00:34:01.266 --> 00:34:04.736
I'd like to turn the stage over
to Nadav Rotem, my colleague,

00:34:04.736 --> 00:34:08.936
to talk about advances
in vectorization.

00:34:09.536 --> 00:34:09.966
>> Thank you, Bob.

00:34:10.565 --> 00:34:10.735
Hi.

00:34:11.516 --> 00:34:16.476
[ Applause ]

00:34:16.976 --> 00:34:21.896
So, Last year with Xcode 5 we've
introduced a new optimization

00:34:22.186 --> 00:34:23.856
called loop vectorization.

00:34:24.156 --> 00:34:28.485
And, I would like to remind
you what loop vectorization is.

00:34:29.085 --> 00:34:33.186
So, modern processors
have vector instructions.

00:34:33.616 --> 00:34:37.025
These instructions can process
multiple scalars at once.

00:34:37.505 --> 00:34:40.406
And loop vectorization is
the compiler optimization

00:34:40.766 --> 00:34:43.866
that accelerates loops using
these vector instructions.

00:34:44.866 --> 00:34:45.735
And let's see how it's done.

00:34:46.295 --> 00:34:48.266
If you can see the code
on the screen here,

00:34:48.266 --> 00:34:49.656
you'll see that it's
a simple program

00:34:50.266 --> 00:34:52.716
that accumulates all
the numbers in the array

00:34:53.025 --> 00:34:54.436
into one variable, into sum.

00:34:54.496 --> 00:34:59.016
And, the natural way of
executing this code is

00:34:59.016 --> 00:35:02.366
to load one number at a time and
save it into the variable sum.

00:35:02.426 --> 00:35:04.586
And then, load another
number and save it into sum.

00:35:05.236 --> 00:35:07.736
But, there's the better
way of executing this code.

00:35:09.076 --> 00:35:11.856
What the loop vector does
for you automatically,

00:35:12.186 --> 00:35:15.596
is that it introduces a new
temporary variable, temp4.

00:35:15.596 --> 00:35:19.436
Now, this is a vector register,
a vector temporary variable.

00:35:20.576 --> 00:35:23.586
And, this allows us to
load four numbers at a time

00:35:23.856 --> 00:35:25.246
and add four numbers at a time,

00:35:25.556 --> 00:35:26.766
and we do it for
the entire array.

00:35:27.206 --> 00:35:29.136
So, this is obviously
much faster

00:35:29.136 --> 00:35:32.236
because we're processing
four numbers at once instead

00:35:32.236 --> 00:35:34.896
of processing one
number at a time.

00:35:35.036 --> 00:35:37.416
And, when you finish
scanning the array we need

00:35:37.416 --> 00:35:40.186
to take the four numbers
from that temporary register

00:35:40.186 --> 00:35:42.076
and add them together,
but it doesn't matter

00:35:42.076 --> 00:35:43.826
because usually an
array is pretty big.

00:35:44.836 --> 00:35:48.716
So, this is how loop
vectorization accelerates loops

00:35:48.716 --> 00:35:49.846
and makes your code run faster

00:35:49.956 --> 00:35:51.466
so that you don't have
to change your code.

00:35:52.696 --> 00:35:56.956
So, in Xcode 6 we've improved
loop vectorization in a number

00:35:56.956 --> 00:35:58.726
of ways, where first of all,

00:35:59.006 --> 00:36:01.126
we've improved the analysis
of complicated loops.

00:36:01.716 --> 00:36:03.976
This means that the
LLVM will be able

00:36:03.976 --> 00:36:07.906
to analyze more complicated
loops and vectorize more loops

00:36:07.906 --> 00:36:09.326
in your code, which is great.

00:36:09.696 --> 00:36:12.696
We've also integrated the
Loop Vectorizer with PGO,

00:36:12.696 --> 00:36:14.146
that Bob just mentioned.

00:36:14.596 --> 00:36:18.166
So, this means that when PGO is
available the Loop Vectorizer

00:36:18.236 --> 00:36:19.896
will be able to make
better decisions

00:36:20.406 --> 00:36:21.436
when vectorizing your code.

00:36:22.436 --> 00:36:27.016
We've also improved the X86
and ARM64 in coding support.

00:36:27.096 --> 00:36:28.066
Now this means two things.

00:36:28.766 --> 00:36:31.616
First of all, the Loop
Vectorizer has a better

00:36:31.616 --> 00:36:35.096
understanding of the processor
so it can predict better

00:36:35.376 --> 00:36:37.806
when it is profitable
to vectorize your codes.

00:36:38.226 --> 00:36:40.266
And the second thing
that it means is

00:36:40.266 --> 00:36:44.096
that when it vectorize your
code it'll generate better,

00:36:44.096 --> 00:36:46.216
more optimized code sequences,

00:36:46.286 --> 00:36:47.756
so that your code
would run faster.

00:36:49.926 --> 00:36:51.576
And, the last feature
that I want to talk to you

00:36:51.576 --> 00:36:54.156
about is specialization
of loop variables.

00:36:56.896 --> 00:37:02.946
So, most variables in your
code are only known at runtime.

00:37:03.796 --> 00:37:09.396
These variables can be arguments
or computed expressions,

00:37:09.396 --> 00:37:12.356
and compiler doesn't know
the values of these variables

00:37:12.656 --> 00:37:15.076
at compile time,
only at runtime.

00:37:16.186 --> 00:37:17.776
And in many times,

00:37:18.176 --> 00:37:21.556
the Vectorizer cannot vectorize
your code unless the value

00:37:21.556 --> 00:37:23.536
of these variables is
known to be constant.

00:37:24.146 --> 00:37:25.416
So, let's take a
look at the example

00:37:25.416 --> 00:37:26.266
that I showed you earlier.

00:37:26.496 --> 00:37:30.026
So, this is a simple loop and
I modified it a little bit

00:37:30.026 --> 00:37:32.066
and I introduced
the Step variable.

00:37:32.356 --> 00:37:36.196
So now, instead of consecutively
scanning all of the elements

00:37:36.196 --> 00:37:38.796
in the array, we jump
and skip some elements,

00:37:38.796 --> 00:37:41.216
and we go in step
of variable Step.

00:37:42.826 --> 00:37:44.366
Now, we can't vectorize
this code

00:37:44.366 --> 00:37:48.056
because these elements are
not consecutive in memory.

00:37:48.056 --> 00:37:51.466
We can't use these vector
registers to load a few elements

00:37:51.466 --> 00:37:52.766
and then add them together.

00:37:52.766 --> 00:37:56.266
It's won't work unless
Step is equal to one.

00:37:56.586 --> 00:37:59.236
Well, in many cases
Step is equal to one.

00:38:00.236 --> 00:38:01.046
So, what do we do?

00:38:01.726 --> 00:38:04.776
Well, we've introduced a
new optimization that's

00:38:04.776 --> 00:38:05.976
called Specialization.

00:38:06.706 --> 00:38:09.546
What we do is we create
multiple versions of the loop.

00:38:10.206 --> 00:38:13.036
In one version of the loop
we assume that step is equal

00:38:13.036 --> 00:38:15.176
to one, and then we
vectorize the code

00:38:15.896 --> 00:38:17.046
and make the code run faster.

00:38:17.946 --> 00:38:20.706
But, in another version of the
loop we don't assume anything

00:38:20.756 --> 00:38:24.316
and the code runs
as-is -- scalar.

00:38:25.396 --> 00:38:29.106
And then, we add code
for selecting at runtime

00:38:29.636 --> 00:38:31.586
which version of
the loop to run.

00:38:31.926 --> 00:38:35.056
If Step happened to
be one, then we go

00:38:35.056 --> 00:38:36.956
and execute the vectorized
version.

00:38:37.136 --> 00:38:38.286
But, if Step is not equal

00:38:38.286 --> 00:38:40.956
to one then we execute
the regular version.

00:38:41.236 --> 00:38:43.206
And this compiler,
this new feature,

00:38:43.206 --> 00:38:45.666
allows the Loop Vectorizer

00:38:45.736 --> 00:38:50.146
to vectorize a lot more
loops, and it's great.

00:38:50.146 --> 00:38:52.106
Okay. So, this was
loop vectorization.

00:38:52.626 --> 00:38:56.606
But, in Xcode 6 we've also added
a new kind of vectorization.

00:38:56.816 --> 00:38:59.916
This is -- this new vectorizer
is not a loop vectorizer.

00:39:00.206 --> 00:39:03.156
It's called SLP Vectorizer,
which stands

00:39:03.156 --> 00:39:05.386
for Superword Level Parallelism,

00:39:05.686 --> 00:39:08.646
and it extracts parallelism
beyond loops.

00:39:09.116 --> 00:39:11.726
What this SLP Vectorizer
does is that it looks

00:39:11.726 --> 00:39:15.426
for multiple scalars in your
code and it glues them together

00:39:15.426 --> 00:39:16.686
into vector instructions.

00:39:18.136 --> 00:39:20.496
Let's see how it's done.

00:39:21.696 --> 00:39:23.596
So, on the screen you
see a very simple struct.

00:39:24.476 --> 00:39:26.936
This struct has two
members, x and y.

00:39:27.596 --> 00:39:28.816
They're consecutive in memory.

00:39:29.766 --> 00:39:32.246
And, we have a simple
function that converts units

00:39:32.946 --> 00:39:34.326
from feet to centimeters.

00:39:34.496 --> 00:39:36.086
Now, this is a very
simple conversion.

00:39:36.136 --> 00:39:39.486
All we have to do is
load the x member,

00:39:39.486 --> 00:39:41.206
multiply it by a
constant, and do it again.

00:39:41.206 --> 00:39:42.246
And, we do the same thing for y.

00:39:42.576 --> 00:39:46.606
And of course, the natural
way of executing this code is

00:39:46.636 --> 00:39:49.746
to do it consecutively;
load variable x,

00:39:49.836 --> 00:39:51.646
multiply it, save it back.

00:39:52.736 --> 00:39:56.396
Load variable y, multiply
it, and save it back.

00:39:57.076 --> 00:39:59.556
But again, there's a
better way of doing it,

00:39:59.866 --> 00:40:01.956
and this is what the
SLP Vectorizer does.

00:40:02.486 --> 00:40:05.316
We can load x and y together
because they're consecutive

00:40:05.316 --> 00:40:09.026
in memory, multiply
them together again,

00:40:09.026 --> 00:40:10.316
and save them back to memory.

00:40:10.316 --> 00:40:13.366
And, this is SLP vectorization.

00:40:15.996 --> 00:40:20.766
SLP vectorization is very
beneficial for some kinds

00:40:20.766 --> 00:40:23.296
of applications, mainly
numeric applications,

00:40:23.296 --> 00:40:24.906
and we see great speedups.

00:40:25.186 --> 00:40:27.386
It may not speed
up all programs,

00:40:27.996 --> 00:40:30.096
but it definitely
speeds up a lot

00:40:30.166 --> 00:40:32.546
of numerically complex
applications.

00:40:33.816 --> 00:40:40.236
So to summarize, we've improved
loop vectorization in Xcode 6

00:40:40.526 --> 00:40:42.056
and we've introduced a new kind

00:40:42.056 --> 00:40:44.896
of vectorization called
SLP vectorization.

00:40:46.866 --> 00:40:49.676
Now in Xcode 5, when we
introduced the Loop Vectorizer,

00:40:49.916 --> 00:40:52.646
we did not enable it by default
and you had to go into one

00:40:52.646 --> 00:40:54.816
of the settings and
select Loop Vectorization

00:40:54.816 --> 00:40:56.186
and then Loop Vectorization
worked.

00:40:56.596 --> 00:40:59.426
Well, in Xcode 6 you
don't have to do anything

00:40:59.426 --> 00:41:02.136
because both the
new SLP Vectorizer

00:41:02.536 --> 00:41:05.776
and the improved Loop Vectorizer
are enabled by default

00:41:05.916 --> 00:41:08.036
when you build your
application in a release mode.

00:41:08.306 --> 00:41:09.746
This means that you don't
need to do anything.

00:41:09.746 --> 00:41:11.846
Just compile your
application in release mode

00:41:12.346 --> 00:41:15.016
and the improved LLVM will
make your code run faster.

00:41:18.916 --> 00:41:20.856
Okay. So, we talked
about a number

00:41:20.856 --> 00:41:23.036
of performance features in LLVM.

00:41:23.276 --> 00:41:25.486
We talked about PGO, we
talked about vectorization,

00:41:26.656 --> 00:41:29.696
but both of these
features are features

00:41:29.696 --> 00:41:32.806
of a static C and C++ compiler.

00:41:33.316 --> 00:41:36.346
But, LLVM is essential
technology here at Apple,

00:41:36.346 --> 00:41:38.156
that's used by many projects.

00:41:38.506 --> 00:41:40.126
And, one of the projects
that I want to talk to you

00:41:40.126 --> 00:41:43.266
about today is accelerating
JavaScript code.

00:41:47.356 --> 00:41:52.126
Well, WebKit is another
important technology.

00:41:52.126 --> 00:41:54.406
It's the heart of the
Safari Web Browser.

00:41:55.166 --> 00:41:57.646
And, WebKit needs to
execute JavaScript code

00:41:58.046 --> 00:42:00.326
because JavaScript is
everywhere in every web page.

00:42:01.806 --> 00:42:03.236
And, WebKit has an interpreter,

00:42:03.536 --> 00:42:05.826
so when you load your Facebook
page, or any other page,

00:42:06.156 --> 00:42:09.966
WebKit starts executing your
code with the interpreter.

00:42:11.356 --> 00:42:13.906
But, WebKit also has
two JIT compilers

00:42:14.276 --> 00:42:15.926
to accelerate your code.

00:42:17.156 --> 00:42:19.466
When WebKit sees that you
execute the same function,

00:42:19.466 --> 00:42:21.816
the same JavaScript
functions over

00:42:21.816 --> 00:42:23.396
and over again, it says, "Huh.

00:42:23.716 --> 00:42:27.106
Let's take a little bit of time
to compile it really quickly

00:42:27.106 --> 00:42:29.396
so that it will run a little bit
faster than the interpreter."

00:42:29.876 --> 00:42:30.956
So, this is the fast JIT.

00:42:32.366 --> 00:42:36.236
And, when WebKit sees that you
execute a function many times,

00:42:36.806 --> 00:42:39.726
then it says, "All right,
let's also take the time

00:42:39.936 --> 00:42:41.596
and optimize this
function real quick,

00:42:41.836 --> 00:42:44.256
so that it will run a
little bit more faster,

00:42:44.256 --> 00:42:45.286
a little bit faster."

00:42:45.676 --> 00:42:49.736
So, we have the interpreter,
we have the fast JIT,

00:42:50.126 --> 00:42:54.176
and we have the optimizing
JIT, and there are tradeoffs

00:42:54.176 --> 00:42:56.836
between compile time and
the quality of the code.

00:42:57.186 --> 00:43:00.256
And this works really great,

00:43:01.136 --> 00:43:03.096
except that JavaScript
is evolving.

00:43:04.146 --> 00:43:05.986
People start writing large,

00:43:06.106 --> 00:43:08.696
compute intensive
applications in JavaScript.

00:43:09.346 --> 00:43:13.356
People then compile C++
programs into JavaScript

00:43:13.776 --> 00:43:15.326
and run them in the browser.

00:43:15.586 --> 00:43:18.256
You can even compile
a Quake3 and run it

00:43:18.256 --> 00:43:20.446
in your browser today,
which is --

00:43:20.486 --> 00:43:22.266
some people like it [laughter].

00:43:23.586 --> 00:43:25.716
Yeah, it's great.

00:43:26.436 --> 00:43:30.956
But, it's a new-use case
and we need a new compiler

00:43:31.306 --> 00:43:32.356
to support this use-case,

00:43:32.926 --> 00:43:35.476
and this is where LLVM
comes into the picture.

00:43:36.986 --> 00:43:41.446
So, we're adding LLVM as a
fourth tier compiler to WebKit.

00:43:43.896 --> 00:43:45.796
Functions that run many, many,

00:43:45.796 --> 00:43:48.906
many times are now
compiled with LLVM.

00:43:49.096 --> 00:43:52.716
And, LLVM is tuned for making
the most out of your code,

00:43:52.716 --> 00:43:55.736
for really trying hard
to optimize your code

00:43:55.966 --> 00:43:59.366
and to generate excellent
code quality.

00:43:59.746 --> 00:44:03.106
And again, there's a
tradeoff between compiled time

00:44:03.386 --> 00:44:06.286
and the quality of the code,
so WebKit really waits for you

00:44:06.286 --> 00:44:09.426
to execute that function
many, many times as you do

00:44:09.426 --> 00:44:10.976
in computing intensive
applications

00:44:11.016 --> 00:44:11.856
that you run in the browser.

00:44:11.856 --> 00:44:17.746
But, compiling JavaScript
with LLVM is very different

00:44:17.746 --> 00:44:21.126
from compiling C or Objective-C
because JavaScript --

00:44:21.786 --> 00:44:24.446
it's a great language,
it's a dynamic language,

00:44:24.446 --> 00:44:26.226
and if you look at the code
on the screen you'll see

00:44:26.226 --> 00:44:27.726
that there are no types.

00:44:28.356 --> 00:44:33.086
There's this n argument
here, but what is n?

00:44:33.086 --> 00:44:34.246
Is it an integer?

00:44:34.326 --> 00:44:35.346
Is it double?

00:44:35.626 --> 00:44:36.436
Is it a class?

00:44:37.306 --> 00:44:38.506
It can be a lot of
different things.

00:44:39.706 --> 00:44:41.316
So, how do we compile it?

00:44:41.906 --> 00:44:48.616
Well luckily, WebKit executed
this function many, many, many,

00:44:48.616 --> 00:44:50.376
many times before
with the interpreter,

00:44:50.526 --> 00:44:56.636
so it knows that in the last
1000 times n was an integer.

00:44:57.006 --> 00:45:00.016
So now, we can compile this code
assuming that n is an integer,

00:45:00.996 --> 00:45:03.406
except that someone made decide

00:45:03.406 --> 00:45:06.466
to pass an n that's
not an integer.

00:45:06.466 --> 00:45:09.206
Someone may decide to
pass a double or a class

00:45:09.736 --> 00:45:12.266
and then everything will
break and we can't allow that.

00:45:12.786 --> 00:45:13.866
So, what do we do?

00:45:14.216 --> 00:45:15.606
We use a technique
that's very similar

00:45:15.606 --> 00:45:16.936
to what we did with
the vectorizer.

00:45:17.596 --> 00:45:18.336
We add checks.

00:45:18.336 --> 00:45:19.896
We make assumptions
and we add checks.

00:45:20.306 --> 00:45:21.946
We assume that n is an integer.

00:45:22.806 --> 00:45:24.976
We assume that n
does not overflow.

00:45:24.976 --> 00:45:28.476
And then, we verify our
assumptions at runtime.

00:45:29.526 --> 00:45:30.486
Okay, that's great.

00:45:30.966 --> 00:45:32.016
But, what is the fallback?

00:45:32.016 --> 00:45:32.506
What do we do?

00:45:33.276 --> 00:45:35.656
When our assumptions
fail we have to go back

00:45:35.656 --> 00:45:38.676
to the interpreter because only
the interpreter can handle all

00:45:38.676 --> 00:45:40.736
these cases, all
these extreme cases.

00:45:42.426 --> 00:45:45.616
But, moving back to the
interpreter is not simple

00:45:46.106 --> 00:45:47.826
because we started
executing it in a code

00:45:47.826 --> 00:45:48.976
and the function made changes.

00:45:48.976 --> 00:45:50.976
We can't just start executing
it from the beginning.

00:45:51.736 --> 00:45:54.536
So, we developed a technology
that's called On-Stack

00:45:54.536 --> 00:45:57.406
Replacement, which is
techniques that is used

00:45:57.856 --> 00:46:01.856
to migrate the state of the
program from the JITed code

00:46:01.856 --> 00:46:03.886
in LLVM back to WebKit.

00:46:04.156 --> 00:46:07.486
And, LLVM needs to track all of
the variables in your program

00:46:07.486 --> 00:46:09.966
and some of them may be in the
register, some of them may be

00:46:09.966 --> 00:46:13.406
in the stack, and now we're
able to migrate them from LLVM

00:46:13.406 --> 00:46:17.666
to WebKit and continue
the execution in WebKit.

00:46:17.906 --> 00:46:22.726
Now, this doesn't happen all the
time, it's a very extreme case.

00:46:22.726 --> 00:46:24.806
But when it happens, we
have to handle these cases.

00:46:26.996 --> 00:46:32.086
Okay, now compiling code
with LLVM is very beneficial,

00:46:32.086 --> 00:46:35.956
especially for compute intensive
applications and especially

00:46:36.226 --> 00:46:39.106
for these C++ applications
compiled

00:46:39.106 --> 00:46:40.976
into JavaScript,
run in the browser.

00:46:43.986 --> 00:46:45.596
And, we're really excited
about this technology.

00:46:45.886 --> 00:46:46.216
It's great.

00:46:47.176 --> 00:46:49.966
So now, we use LLVM.

00:46:50.386 --> 00:46:53.566
So to summarize, we use LLVM
as a fourth tier compiler

00:46:53.966 --> 00:47:00.006
in Safari, both for X86
and ARM64 on iOS and OS X,

00:47:00.006 --> 00:47:02.306
and we get excellent
performance speedups.

00:47:03.336 --> 00:47:05.276
To summarize this
talk, today we talked

00:47:05.276 --> 00:47:08.286
about modernizing Objective-C
code and we also talked

00:47:08.286 --> 00:47:09.946
about a number of
performance features.

00:47:10.716 --> 00:47:12.326
If you have any more questions,

00:47:12.326 --> 00:47:15.966
you can contact our Developer
Tools Evangelist, Dave DeLong,

00:47:16.156 --> 00:47:19.276
or you can go to the Apple
website or to the LLVM website.

00:47:19.476 --> 00:47:24.046
There are a few related
sessions, and I encourage you

00:47:24.046 --> 00:47:26.496
to attend these sessions
or to watch them online.

00:47:28.506 --> 00:47:31.756
Thank you, very much,
and have a good week.

00:47:32.436 --> 00:47:32.896
Bye-bye.

00:47:33.016 --> 00:47:35.000
[ Applause ]
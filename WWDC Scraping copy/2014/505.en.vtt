WEBVTT

00:00:00.506 --> 00:00:11.626
[ Silence ]

00:00:12.126 --> 00:00:16.686
>> Hello, good afternoon,
welcome to session 505,

00:00:16.756 --> 00:00:19.426
"Harnessing Metadata
in Audiovisual Media".

00:00:20.026 --> 00:00:22.846
I've heard we are competing
with the "Intro to Swift" talk

00:00:22.846 --> 00:00:24.956
so get intimate with
your neighbors here.

00:00:25.626 --> 00:00:28.476
My name is Adam Sonnanstine.

00:00:28.476 --> 00:00:30.916
I'm an engineer on
the AVFoundation team

00:00:30.916 --> 00:00:33.586
and today we are going to talk
about, of course, metadata.

00:00:34.296 --> 00:00:35.646
So what do I mean by metadata?

00:00:35.996 --> 00:00:38.416
Well, for the purposes
of this talk we're going

00:00:38.416 --> 00:00:40.896
to define metadata to mean
any data that is stored

00:00:40.896 --> 00:00:44.296
in movie files, streaming
presentations, any other sort

00:00:44.296 --> 00:00:49.636
of audiovisual presentation
that describes the primary data,

00:00:49.636 --> 00:00:51.876
like the audio and video that
we think about when we think

00:00:51.876 --> 00:00:53.146
of those sorts of presentations.

00:00:53.856 --> 00:00:55.556
Some examples are
always helpful.

00:00:56.336 --> 00:00:58.946
One you should be familiar
is iTunes metadata,

00:00:59.376 --> 00:01:02.606
when you have this sort of
the song names and the artists

00:01:02.606 --> 00:01:05.756
and the album artwork
in your iTunes library.

00:01:05.986 --> 00:01:08.376
All these things are stored
as the sort of metadata

00:01:08.376 --> 00:01:10.436
that I'm talking about
today in the files

00:01:10.436 --> 00:01:11.506
in your iTunes library.

00:01:12.756 --> 00:01:15.426
Besides iTunes metadata,
we also have things

00:01:15.426 --> 00:01:16.836
like location information.

00:01:17.166 --> 00:01:20.006
If you have a movie that
you took with your iPhone

00:01:20.006 --> 00:01:23.226
or some other location-enabled
device and you played it

00:01:23.226 --> 00:01:26.146
in QuickTime player, that will
show up in the info window

00:01:26.216 --> 00:01:28.956
to tell you where you were
when you took that movie.

00:01:29.356 --> 00:01:31.206
That's also stored as
the kind of metadata

00:01:31.206 --> 00:01:33.816
that we are talking about today.

00:01:33.816 --> 00:01:36.966
Some new features, we know that
you're not always standing still

00:01:36.966 --> 00:01:38.006
when you are taking your videos.

00:01:38.086 --> 00:01:43.006
So new in iOS 8 and OS X
Yosemite, we have features

00:01:43.106 --> 00:01:46.456
that support things like dynamic
location, that's a location

00:01:46.456 --> 00:01:47.666
that changes over time.

00:01:47.666 --> 00:01:49.456
So these are some new features
that we are going to be talking

00:01:49.456 --> 00:01:52.996
about later on that we are
pretty excited about and,

00:01:53.406 --> 00:01:57.436
in addition to location, this
really applies to any sort

00:01:57.436 --> 00:02:00.176
of metadata that you might
want to add that changes

00:02:00.176 --> 00:02:01.636
over time in your movie.

00:02:02.066 --> 00:02:04.536
This is a screen shot of a
demo app we'll show you later

00:02:04.856 --> 00:02:07.786
but the circle and the
annotation text that's all

00:02:07.786 --> 00:02:12.456
stored as the same sort of timed
metadata as a timed location.

00:02:13.136 --> 00:02:14.846
So hopefully that whets
your appetite a little bit.

00:02:15.206 --> 00:02:17.526
We'll talk about what
we're going to cover today,

00:02:17.526 --> 00:02:19.716
we're going to start, I'm going
to give you an intro to metadata

00:02:19.716 --> 00:02:21.986
and AVFoundation, some of
the classes that have been

00:02:21.986 --> 00:02:25.006
around for a while for
describing all sorts

00:02:25.006 --> 00:02:27.776
of metadata, how to inspect
that and how to author it.

00:02:27.776 --> 00:02:29.126
We're going to talk more

00:02:29.126 --> 00:02:30.966
about those new timed
metadata features

00:02:31.046 --> 00:02:35.256
and then I'll give you some best
practices including some privacy

00:02:35.256 --> 00:02:37.856
things to keep in mind and
some other best practices.

00:02:38.856 --> 00:02:42.006
So our first topic: metadata
in AVFoundation..What kind

00:02:42.006 --> 00:02:44.906
of classes are we going to be
using to describe our metadata?

00:02:45.346 --> 00:02:48.316
Well our primary model
objects that we use

00:02:48.376 --> 00:02:54.536
to describe both movie files
or HLS streams is AVAsset.

00:02:54.986 --> 00:03:00.036
AVAsset can contain any
number of AV metadata objects

00:03:00.376 --> 00:03:05.646
and each AVMetadataItem instance
represents a single piece

00:03:05.646 --> 00:03:08.686
of metadata, either your
track name or your album mark,

00:03:08.976 --> 00:03:13.316
even your location stuff that's
going to be separate pieces

00:03:13.316 --> 00:03:15.836
of metadata in our
runtime environment.

00:03:16.196 --> 00:03:19.946
So a closer look at
AVMetadataItem: at its core,

00:03:20.196 --> 00:03:21.436
it has two properties.

00:03:22.076 --> 00:03:24.536
The first is identifier, which
is actually a new property

00:03:24.906 --> 00:03:26.636
and that is going
to describe the kind

00:03:26.636 --> 00:03:27.676
of metadata that you have.

00:03:27.866 --> 00:03:31.626
In this example we have the
song name and it's represented

00:03:31.626 --> 00:03:33.036
by this long symbol name,

00:03:33.036 --> 00:03:36.396
AVMetadataIdentifieriTunes
MetadataSongName,

00:03:37.026 --> 00:03:38.276
and then you have the value

00:03:38.276 --> 00:03:40.436
which is the actual payload
of the metadata item.

00:03:40.436 --> 00:03:43.136
So for song name, it's the
name of the song as a string.

00:03:44.896 --> 00:03:47.446
As an example for cover art,

00:03:47.446 --> 00:03:49.706
you can see that the
value doesn't have

00:03:49.706 --> 00:03:53.256
to be a string it can be an
image or any other object

00:03:53.506 --> 00:03:57.576
that supports both the NSObject
and NSCopying protocols.

00:03:58.456 --> 00:04:00.696
Now if you've used
AVMetadataItem

00:04:00.696 --> 00:04:03.356
in the past you might
be familiar with the key

00:04:03.356 --> 00:04:04.646
and key space properties.

00:04:05.196 --> 00:04:07.266
Well the identifier I
mentioned that was new,

00:04:07.616 --> 00:04:09.306
it's new because
it is a combination

00:04:09.306 --> 00:04:11.626
of the old properties,
key and key space.

00:04:11.626 --> 00:04:14.216
So I'm not going to talking much
about key and key space today

00:04:14.216 --> 00:04:17.065
but mostly going to be talking
about identifier going forward

00:04:17.065 --> 00:04:19.375
as the way to describe
your metadata.

00:04:20.446 --> 00:04:22.846
Take a look at some of the
built-in identifiers we have;

00:04:23.346 --> 00:04:24.736
this is just a tiny sampling.

00:04:24.736 --> 00:04:25.626
There's a lot of them.

00:04:25.626 --> 00:04:26.376
You can find them

00:04:26.376 --> 00:04:29.856
in AVMetadataIdentifiers.h. I've
arranged them here according

00:04:29.856 --> 00:04:34.476
roughly to the old notion of
key space so that's just sort

00:04:34.476 --> 00:04:37.526
of a sampling of the kind of
metadata that we already know

00:04:37.526 --> 00:04:38.866
that you might want
to represent.

00:04:40.196 --> 00:04:42.846
Going back to the
metadata item itself,

00:04:43.926 --> 00:04:47.826
we have a property that's
also new called dataType,

00:04:47.826 --> 00:04:49.686
which describes the
native data type

00:04:50.026 --> 00:04:51.886
that your metadata
is representing.

00:04:52.236 --> 00:04:54.956
So for the case of our song
name it's stored as a string

00:04:54.956 --> 00:04:57.486
so we see that the data
type is a UTF8 string;

00:04:57.926 --> 00:04:59.526
and these string constants

00:04:59.526 --> 00:05:02.336
that represent the different
data types are all defined

00:05:02.336 --> 00:05:07.956
in CMMetadata.h. And besides
the data type property,

00:05:07.956 --> 00:05:11.356
we also have several
type coercion properties

00:05:11.356 --> 00:05:14.106
that you can use if you know
you want to get your payload

00:05:14.346 --> 00:05:17.536
in the form of a certain
type of Objective C object.

00:05:17.536 --> 00:05:21.286
So you have string value, number
value, date value and data value

00:05:21.566 --> 00:05:24.656
and those are going to give
you exactly what you'd expect.

00:05:24.976 --> 00:05:28.726
For the case of where our
native payload is a string,

00:05:28.946 --> 00:05:31.526
only string value is going to
give you an interesting answer.

00:05:31.526 --> 00:05:32.596
The rest will give you NULL.

00:05:33.226 --> 00:05:36.476
For our artwork example where
the payload is a JPEG image,

00:05:36.976 --> 00:05:39.236
the top three are
going to give you NULL

00:05:39.496 --> 00:05:42.286
and the data value is going
to give you the NSData

00:05:42.286 --> 00:05:45.646
that you're looking for to grab
the bytes of the JPEG image.

00:05:46.506 --> 00:05:48.796
There are examples
where you can have more

00:05:48.796 --> 00:05:52.466
than one non-nil
tech coercion method.

00:05:52.756 --> 00:05:56.986
And one is creation date if
you have the date represented

00:05:56.986 --> 00:05:59.236
as a standard string
format for dates.

00:05:59.666 --> 00:06:05.126
You can either get the actual
string that was stored that way

00:06:05.376 --> 00:06:08.286
or you can ask the metadata
item to give you an instance

00:06:08.286 --> 00:06:10.266
of NSDate that describes
the same thing

00:06:10.266 --> 00:06:12.326
in a more convenient
representation.

00:06:12.636 --> 00:06:15.536
So that's your brief
intro to AVMetadataItem,

00:06:15.536 --> 00:06:17.636
we're going to be talking a lot
about it throughout the talk.

00:06:17.906 --> 00:06:19.356
Let's go back to AVAsset

00:06:19.356 --> 00:06:21.866
so we can see how we actually
get these metadata items.

00:06:21.866 --> 00:06:25.606
So the easiest way is just to
ask for all of the metadata

00:06:25.606 --> 00:06:27.286
that applies to the
entire asset.

00:06:27.626 --> 00:06:30.456
There are types of metadata that
apply to just parts of the asset

00:06:30.706 --> 00:06:33.686
but this is how you get the
metadata to, like, the location

00:06:33.686 --> 00:06:35.796
and the song title that
applies to the entire asset.

00:06:36.686 --> 00:06:40.036
There's also a way to get
just a subset of the metadata.

00:06:40.586 --> 00:06:42.926
We have this notion of metadata
format but I'm not going

00:06:42.926 --> 00:06:45.496
to be talking about too much
today but you can use it

00:06:45.496 --> 00:06:47.656
to get just that
subset of the metadata.

00:06:48.046 --> 00:06:50.656
So for our example, when we
are getting iTunes metadata,

00:06:50.946 --> 00:06:54.426
we're going to use that
AVMetadataFormatiTunesMetadata

00:06:54.426 --> 00:06:58.526
and grab all of that using
the metadataForFormat method.

00:06:58.976 --> 00:07:02.146
And then from there we can
use this filtering method,

00:07:02.146 --> 00:07:04.646
metadataItemsFromArray,
filtered by an identifier

00:07:04.646 --> 00:07:07.346
to get just the items
that correspond

00:07:07.346 --> 00:07:08.716
to the song name identifier.

00:07:09.166 --> 00:07:11.026
You might be wondering
why you can have more

00:07:11.026 --> 00:07:13.106
than one song name
in a single asset?

00:07:13.336 --> 00:07:15.876
We'll get back to that in just
a little bit but first I want

00:07:15.876 --> 00:07:19.986
to talk about how you load the
payload of your metadata items.

00:07:20.336 --> 00:07:23.196
AVMetadataItem conforms

00:07:23.196 --> 00:07:25.216
to the
AVAsynchronousKeyValueLoading.h

00:07:25.216 --> 00:07:25.726
protocol.

00:07:25.726 --> 00:07:28.706
This is a protocol we define
ourselves in AVFoundation

00:07:28.776 --> 00:07:32.076
and a lot of our core
model objects conform to it

00:07:32.546 --> 00:07:35.686
because a lot of times
when you get an AVAsset

00:07:35.686 --> 00:07:38.686
or an AVMetadataItem we haven't
actually loaded the data behind

00:07:38.686 --> 00:07:39.006
it yet.

00:07:39.006 --> 00:07:43.326
So you can use this method, load
values asynchronously for keys

00:07:43.826 --> 00:07:46.326
to load the specific values
you want and they'll do

00:07:46.326 --> 00:07:48.926
that asynchronously so you're
not blocking your main thread

00:07:49.206 --> 00:07:51.876
with some sort of synchronous
I/O or something like that.

00:07:52.426 --> 00:07:54.436
So for this case we
have our metadata item.

00:07:54.796 --> 00:07:58.216
We're looking for the value so
we just load the key value and,

00:07:58.216 --> 00:07:59.516
when we get our completion
handler,

00:07:59.856 --> 00:08:01.556
we're going to check
the status to make sure

00:08:01.556 --> 00:08:04.256
that that loading succeeded
and, assuming that we did,

00:08:04.386 --> 00:08:06.386
we can then just go
ahead and grab the value

00:08:06.386 --> 00:08:07.856
and use it however we see fit.

00:08:08.556 --> 00:08:12.836
So back to that whole multiple
titles in one asset string.

00:08:12.836 --> 00:08:16.396
Well, one reason we
might have that is

00:08:16.446 --> 00:08:20.016
if we have the asset localized
in multiple languages.

00:08:20.016 --> 00:08:22.836
So an asset can have
the same metadata items

00:08:22.836 --> 00:08:23.976
in multiple languages.

00:08:24.426 --> 00:08:25.836
The example that
we're going to talk

00:08:25.836 --> 00:08:28.466
about is
QuickTimeUserDataFullName

00:08:28.776 --> 00:08:29.696
dat identifier.

00:08:29.936 --> 00:08:32.135
If you use this identifier
in your files,

00:08:32.416 --> 00:08:35.395
then QuickTime Player, for
example, can pick up the title

00:08:35.566 --> 00:08:36.885
and display it in the title bar.

00:08:36.885 --> 00:08:39.206
So this is just yet
another example

00:08:39.206 --> 00:08:41.996
of how metadata is used
in our applications.

00:08:42.525 --> 00:08:44.576
This particular example

00:08:44.576 --> 00:08:49.176
of the movie actually has the
title available in both English

00:08:49.176 --> 00:08:53.456
and Spanish so here we have the
English as the system language

00:08:53.456 --> 00:08:56.486
so QuickTime Player picks that
up, picks up the English title

00:08:56.486 --> 00:08:59.816
but if we set our system
language to Spanish it will pick

00:08:59.816 --> 00:09:02.286
up the Spanish localization
of that title instead.

00:09:02.746 --> 00:09:06.986
These are represented as two
distinct pieces of metadata

00:09:06.986 --> 00:09:10.456
within the file and the way that
you distinguish between them is

00:09:10.456 --> 00:09:11.696
that they'll have
different values

00:09:11.696 --> 00:09:15.056
for these final two properties
of AVMetadataItem locale

00:09:15.116 --> 00:09:16.406
and extendedLanguageTag.

00:09:17.106 --> 00:09:19.586
ExtendedLanguageTag is
new in this release.

00:09:19.716 --> 00:09:23.166
It's a BCP 47 language tag
and it's particularly useful

00:09:23.166 --> 00:09:24.856
when you want to
distinguish written languages.

00:09:25.616 --> 00:09:29.596
So that's one reason
why you might have more

00:09:29.596 --> 00:09:32.326
than one metadata item
with the same identifier.

00:09:32.326 --> 00:09:36.916
So I mentioned before that
not all metadata applies

00:09:37.036 --> 00:09:40.726
to the entire asset, well one
example of that is metadata

00:09:40.726 --> 00:09:42.566
that only applies to
a particular track,

00:09:42.636 --> 00:09:45.976
so for this example we have
a special label attached

00:09:45.976 --> 00:09:49.506
to our subtitle track called
SDH, that stands for Subtitles

00:09:49.506 --> 00:09:51.336
for the Deaf or Hard of Hearing

00:09:51.866 --> 00:09:56.616
and that's basically just a
more rich form of subtitles

00:09:57.196 --> 00:09:59.956
that includes things like
labeling who's talking

00:10:00.176 --> 00:10:01.956
and mentioning sound effects

00:10:01.956 --> 00:10:04.056
that are vital to
the understanding.

00:10:04.056 --> 00:10:09.416
We talked a little bit more
about SDH and accessibility

00:10:09.416 --> 00:10:11.956
in general last year in our
"Preparing and Presenting Media

00:10:11.956 --> 00:10:14.766
for Accessibility" talk so check
that one out for more details.

00:10:14.766 --> 00:10:16.076
For the purposes of this talk,

00:10:16.416 --> 00:10:18.886
just know that to get
this SDH label here,

00:10:19.106 --> 00:10:21.446
it involves setting
track-specific metadata.

00:10:21.936 --> 00:10:23.816
So let's talk about
how you actually find

00:10:23.816 --> 00:10:25.806
out if your track has
this metadata in it,

00:10:26.356 --> 00:10:29.166
well you're going
to use AVAsset track

00:10:29.466 --> 00:10:31.586
and it has pretty much
the exact same API

00:10:31.586 --> 00:10:32.976
as AVAsset for reading metadata.

00:10:33.196 --> 00:10:35.486
You have your metadata property;

00:10:35.896 --> 00:10:39.736
you have your metadataForFormat
method and so if we want

00:10:39.736 --> 00:10:42.676
to find all the tagged
characteristics that are

00:10:42.676 --> 00:10:46.526
in an asset track, we're
going to ask the track

00:10:46.526 --> 00:10:49.186
for its metadata for the
FormatQuickTimeUserData.

00:10:49.866 --> 00:10:50.996
Once we have that we use

00:10:51.036 --> 00:10:54.556
that same filtering method we
saw before in order to get all

00:10:54.556 --> 00:10:58.506
of the items that
have the identifier,

00:10:58.506 --> 00:11:00.806
QuickTimeUserDataTagged
Characteristic.

00:11:00.916 --> 00:11:05.136
So this is one example of tagged
characteristics is the SDH

00:11:05.256 --> 00:11:07.726
that I just talked about
and it's the payload

00:11:07.726 --> 00:11:09.986
of the metadata items
that tells you what kind

00:11:09.986 --> 00:11:12.316
of tagged characteristic
you're dealing with.

00:11:12.716 --> 00:11:14.726
We'll talk a little bit
more detail about SDH

00:11:14.726 --> 00:11:18.156
and how you author it
in just a little bit.

00:11:18.586 --> 00:11:20.326
So going back to our list

00:11:20.326 --> 00:11:23.506
of identifiers you might
have noticed some patterns

00:11:23.506 --> 00:11:24.636
if you were looking closely.

00:11:25.856 --> 00:11:29.796
Each of these groups has
their own version of a title

00:11:29.796 --> 00:11:31.496
or a song name or
something like that.

00:11:32.116 --> 00:11:36.036
We noticed that and come up
with our own special kind

00:11:36.036 --> 00:11:38.226
of identifier called
a CommonIdentifier

00:11:38.776 --> 00:11:41.296
which can be used when
you want to look up, say,

00:11:41.296 --> 00:11:45.236
for this example a title without
caring exactly how it's stored

00:11:45.236 --> 00:11:45.966
in your file.

00:11:46.616 --> 00:11:49.946
Same for copyright here; we
also have a common identifier

00:11:49.946 --> 00:11:51.116
that represents copyright.

00:11:51.756 --> 00:11:53.566
These are not the only
common identifiers;

00:11:53.646 --> 00:11:56.766
there's a whole list of them
but these are just two examples.

00:11:57.256 --> 00:11:59.366
So if we go back to our
example where we're looking

00:11:59.366 --> 00:12:02.526
for our iTunes song name,
if we don't actually care

00:12:02.526 --> 00:12:06.496
that the title of our asset
is stored as iTunes metadata

00:12:06.496 --> 00:12:09.356
and we just want a title so
we can display it somewhere,

00:12:09.646 --> 00:12:12.606
you can ask the asset for
its array of commonMetadata

00:12:12.606 --> 00:12:14.216
and this is all the
metadata items

00:12:14.536 --> 00:12:18.816
that can be represented
using a common identifier.

00:12:19.296 --> 00:12:22.176
Then you use that same filtering
method we've been using

00:12:22.176 --> 00:12:23.956
to filter down to just the ones

00:12:23.956 --> 00:12:25.696
that have the
CommonIdentifierTitle

00:12:26.076 --> 00:12:28.996
and you can go from
there with your title.

00:12:28.996 --> 00:12:30.216
Also worth noting is

00:12:30.276 --> 00:12:34.976
that AVAssetTrack has the
same property, commonMetadata,

00:12:34.976 --> 00:12:36.886
so you can do the same
thing over there as well.

00:12:37.426 --> 00:12:40.856
So that is your brief
introduction

00:12:40.856 --> 00:12:43.076
to inspecting metadata
with AVFoundation.

00:12:43.316 --> 00:12:45.186
Let's talk a little
bit about authoring.

00:12:45.186 --> 00:12:48.096
If you want to make your own
files that have say location

00:12:48.096 --> 00:12:52.156
or iTunes metadata in them, we
have several different classes

00:12:52.156 --> 00:12:55.766
that can write movie
files, AVAssetExportSession,

00:12:55.766 --> 00:12:59.396
AVAssetWriter and the capture
movie and audio files outputs

00:12:59.446 --> 00:13:02.576
and these all have the exact
same redirect property called

00:13:02.576 --> 00:13:03.426
simply, metadata.

00:13:03.426 --> 00:13:06.126
So you give an array of
metadata items and then

00:13:06.126 --> 00:13:07.706
that will be written
out to the file.

00:13:08.476 --> 00:13:11.246
Similarly for track-specific
metadata

00:13:11.246 --> 00:13:12.806
like those tagged
characteristics,

00:13:13.186 --> 00:13:15.426
you can use an AVAssetWriter
input

00:13:15.656 --> 00:13:18.176
which also has the
exact same property.

00:13:19.166 --> 00:13:23.696
Now you are not limited to
just writing out metadata

00:13:23.696 --> 00:13:25.636
that you got from somewhere
else, like another file

00:13:25.636 --> 00:13:27.146
through the APIs
we've been looking at.

00:13:27.386 --> 00:13:29.336
You can also create
your own metadata items

00:13:29.336 --> 00:13:32.006
with a mutable subclass
of metadataItem.

00:13:32.356 --> 00:13:34.996
And as you might expect, this
just has read/write properties

00:13:34.996 --> 00:13:38.536
for all of the properties
in AVMetadataItem.

00:13:39.056 --> 00:13:42.546
So if we use an example of
writing a subtitle track

00:13:42.546 --> 00:13:46.666
that is marked as SDH, well
it's actually two different tag

00:13:46.666 --> 00:13:48.266
characteristics that
you have to use

00:13:48.376 --> 00:13:50.566
and so we'll create two
different metadata items,

00:13:50.936 --> 00:13:55.556
set both of their identifiers
to the identifier we just saw,

00:13:55.776 --> 00:13:58.106
the QuickTimeUserData
tag characteristic,

00:13:58.616 --> 00:14:00.206
but one of them will
set the value

00:14:00.206 --> 00:14:02.816
to TranscribesSpokenDialogue
ForAccessibility

00:14:02.816 --> 00:14:05.116
and the other will be
DescribesMusicAndSound

00:14:05.116 --> 00:14:06.066
ForAccessibility.

00:14:06.476 --> 00:14:09.556
Then we get the subtitle
AssetWriterInputthat's going

00:14:09.556 --> 00:14:13.486
to write our subtitle track and
set that array of the two items

00:14:13.486 --> 00:14:15.126
on our asset writer input.

00:14:15.336 --> 00:14:18.486
So that's how you would
author a subtitle track

00:14:18.596 --> 00:14:20.516
that is marked as SDH.

00:14:20.516 --> 00:14:23.506
Just one example of
using tag characteristics

00:14:23.776 --> 00:14:25.316
in AVMutableMetadataItem.

00:14:26.116 --> 00:14:29.646
Special note about
AVAssetExportSession:

00:14:30.776 --> 00:14:33.896
by default the ExportSession
is actually going to take any

00:14:33.896 --> 00:14:37.006
of the metadata that's
in the source asset

00:14:37.006 --> 00:14:37.976
that you're exporting.

00:14:38.236 --> 00:14:40.696
It's going to copy that
over to the output file.

00:14:41.326 --> 00:14:43.656
Now that's not the case
if you set metadata

00:14:43.656 --> 00:14:44.906
on its metadata property.

00:14:45.396 --> 00:14:47.386
That will be the signal
to tell the ExportSession

00:14:47.386 --> 00:14:49.516
to ignore the metadata
in the source file

00:14:49.726 --> 00:14:52.506
and instead write just what
you put on the property.

00:14:52.956 --> 00:14:55.836
So if you want to do
augmentation of the metadata

00:14:55.836 --> 00:14:59.146
or some other sort of
modification you'll want to grab

00:14:59.146 --> 00:15:01.926
that array of metadata,
make a mutable copy

00:15:01.926 --> 00:15:04.216
and do any adjustments
that you want and then set

00:15:04.216 --> 00:15:05.956
that on the metadata property.

00:15:06.046 --> 00:15:08.316
So that's just a quick
note about ExportSession.

00:15:08.676 --> 00:15:12.536
The last note about authoring
metadata is HTTP Live Streaming,

00:15:12.536 --> 00:15:16.006
this is actually a new
feature in iOS 8, OS X Yosemite

00:15:16.086 --> 00:15:20.496
and you can use a new tag
called session-data tag

00:15:20.496 --> 00:15:23.396
in your playlist, which
has two required fields:

00:15:23.426 --> 00:15:26.226
the data ID which is a
lot like our identifiers

00:15:26.226 --> 00:15:29.926
that we're talking about, a URI
which can point to the payload

00:15:29.926 --> 00:15:33.376
or a value which directly
specifies the payload and,

00:15:33.536 --> 00:15:35.276
optionally, some
language information.

00:15:35.276 --> 00:15:37.316
So here's an example
that shows very similar

00:15:37.316 --> 00:15:38.986
to what we saw before
with the titles

00:15:38.986 --> 00:15:42.316
in two different languages but
this is the markup you'd use

00:15:42.316 --> 00:15:44.356
for HTTP Live Streaming.

00:15:44.896 --> 00:15:47.586
So for more information
on reading

00:15:47.586 --> 00:15:49.896
and writing metadata we
do have some sample code,

00:15:50.106 --> 00:15:53.806
it's called AVmetadataeditor
and for more information

00:15:53.806 --> 00:15:58.416
about the details of writing
HTTP Live Streaming metadata see

00:15:58.416 --> 00:16:00.326
the documents at this URL.

00:16:00.436 --> 00:16:03.466
All right so that is your
crash course in metadata

00:16:03.466 --> 00:16:07.206
in AVFoundation, our next
topic is timed metadata.

00:16:08.046 --> 00:16:10.716
So timed metadata, although I
mentioned we have new features,

00:16:10.716 --> 00:16:11.946
it is not a new concept.

00:16:12.806 --> 00:16:15.426
We supported the notion of
chapters for quite some time

00:16:15.716 --> 00:16:18.166
and conceptually chapters
are just an example

00:16:18.166 --> 00:16:19.096
of times metadata.

00:16:19.436 --> 00:16:22.616
Each of these chapter markers
is just a piece of metadata

00:16:22.896 --> 00:16:26.446
that is describing
a particular range

00:16:26.446 --> 00:16:27.836
of the timeline of the movie.

00:16:28.496 --> 00:16:31.096
That's all that timed
metadata is,

00:16:31.146 --> 00:16:34.336
it's just metadata associated
with a range of time.

00:16:34.886 --> 00:16:40.076
So similarly, with our
dynamic location example,

00:16:40.586 --> 00:16:43.336
we have the path that's drawn
here that's really just composed

00:16:43.336 --> 00:16:45.216
of a number of pieces

00:16:45.216 --> 00:16:48.106
of metadata indicating
the current location,

00:16:48.306 --> 00:16:50.766
each one of them associated
with a particular time

00:16:50.956 --> 00:16:52.036
in the movie's timeline.

00:16:52.036 --> 00:16:55.496
So to demonstrate
QuickTime Player's features

00:16:55.496 --> 00:16:57.896
with dynamic location
in Yosemite,

00:16:57.896 --> 00:16:59.456
I want to bring my
colleague, Shalini,

00:16:59.456 --> 00:17:00.606
up to the stage for a demo.

00:17:01.566 --> 00:17:04.226
>> Hi, I'm here to
demonstrate how to read

00:17:04.266 --> 00:17:06.726
and play back metadata
using QuickTime Player.

00:17:07.876 --> 00:17:11.406
Here I have a movie file
which has both audio and video

00:17:11.665 --> 00:17:14.906
and timed locations data
stored in a different track.

00:17:15.685 --> 00:17:17.996
So now if I bring this
up in QuickTime Player,

00:17:19.146 --> 00:17:21.455
this is the usual UI
for audio and video.

00:17:22.205 --> 00:17:23.896
New in OS X Yosemite:

00:17:24.286 --> 00:17:28.165
in the Movie Inspector
you can see a map view

00:17:28.906 --> 00:17:30.746
if your movie file
has location data.

00:17:31.226 --> 00:17:33.966
Your map view is presented
along with the route

00:17:34.566 --> 00:17:35.996
where you have recorded
this video.

00:17:37.186 --> 00:17:39.716
So here the blue line
indicates the path

00:17:39.716 --> 00:17:43.496
where we recorded the video and
the red pin is an indication

00:17:43.556 --> 00:17:45.736
of the current location
or the location

00:17:46.166 --> 00:17:50.076
on the timeline of the movie.

00:17:50.076 --> 00:17:52.556
So if I zoom in a little
bit and start play,

00:17:52.906 --> 00:17:57.996
you can see as the movie
progresses the pin's location is

00:17:57.996 --> 00:18:00.976
being updated to be in
sync with the video.

00:18:01.576 --> 00:18:05.456
I can drag the scrubber around

00:18:06.076 --> 00:18:08.116
and you can see the pin
moving back and forth.

00:18:09.466 --> 00:18:15.296
I can also go and click
at any point in the map

00:18:15.296 --> 00:18:18.376
and you see the video seek
to that location to present

00:18:18.436 --> 00:18:21.576
where your video was when
you were at that location.

00:18:22.876 --> 00:18:26.966
This is map view in QuickTime
Player on OS X Yosemite.

00:18:27.866 --> 00:18:28.516
>> Thank you, Shalini.

00:18:29.266 --> 00:18:31.386
So let's talk about
what we just saw there.

00:18:32.256 --> 00:18:35.676
So that location information
was stored as timed metadata

00:18:35.676 --> 00:18:38.866
in the file and in order to
have QuickTime Player draw

00:18:38.866 --> 00:18:43.436
that information on the map, we
use AVAssetReader to read all

00:18:43.436 --> 00:18:46.906
of the location information
from that asset.

00:18:46.906 --> 00:18:50.436
And because timed metadata
is stored in its own track,

00:18:50.746 --> 00:18:53.436
we use an
AVAssetReaderTrackOutput to read

00:18:53.436 --> 00:18:56.836
that data and we use a new
class called AVAssetReaderOutput

00:18:56.836 --> 00:19:00.066
MetadataAdaptor that knows how
to give us that data in the

00:19:00.066 --> 00:19:02.946
from of a class called
AVTimedMetadataGroup.

00:19:03.356 --> 00:19:05.636
Then from there we
can grab each location

00:19:05.636 --> 00:19:07.066
and draw that path on the map.

00:19:08.116 --> 00:19:11.376
So AVTimedMetadataGroup
is a very simple class.

00:19:11.746 --> 00:19:13.476
It's really just
these two properties:

00:19:13.476 --> 00:19:16.806
an array of metadata items
combined with a time range

00:19:16.806 --> 00:19:20.106
that describes where in the
movie that data applies.

00:19:20.646 --> 00:19:25.006
So to see a little bit of
code for using AssetReader

00:19:25.006 --> 00:19:27.016
for this purpose, the
first thing you want

00:19:27.016 --> 00:19:28.186
to do is find the track

00:19:28.386 --> 00:19:31.616
that contains your location
information and we'll talk more

00:19:31.616 --> 00:19:33.286
about how to do that
in just a second.

00:19:33.676 --> 00:19:37.586
Then you use that track to
create an AssetReaderTrackOutput

00:19:38.156 --> 00:19:39.736
and you use nil output settings

00:19:40.276 --> 00:19:42.796
and then you'll create
your metadataAdaptor

00:19:42.796 --> 00:19:43.916
with that trackOutput.

00:19:44.626 --> 00:19:47.756
And then, in a loop we just
take your metadataAdaptor

00:19:47.756 --> 00:19:50.866
and call the
nextTimedMetadataGroup method

00:19:51.156 --> 00:19:53.606
over and over again, doing
something with each piece

00:19:53.606 --> 00:19:55.496
of data, like drawing
it on the map

00:19:55.666 --> 00:19:57.446
until that method returns nil.

00:19:57.446 --> 00:19:58.946
Then you know there's
no more data to draw.

00:19:58.946 --> 00:20:02.656
So in terms of finding
the right track to read,

00:20:03.096 --> 00:20:05.616
the way you're going to do
that is by examining the tracks

00:20:05.616 --> 00:20:08.276
in your asset and looking
through the format description

00:20:08.276 --> 00:20:10.796
of each track to find the
identifiers you're looking for.

00:20:10.876 --> 00:20:13.626
So you first start
by getting the tracks

00:20:13.626 --> 00:20:15.826
with the MediaTypeMetadata
and then for each

00:20:15.826 --> 00:20:17.806
of those tracks you're
going to loop through all

00:20:17.806 --> 00:20:20.986
of its format descriptions,
usually there's only one

00:20:21.316 --> 00:20:24.016
and for each format description
you're going to grab its list

00:20:24.016 --> 00:20:26.916
of identifiers using this
function and check whether

00:20:26.916 --> 00:20:28.596
that identifier array
contains the identifier you're

00:20:28.596 --> 00:20:28.976
looking for.

00:20:29.176 --> 00:20:30.226
In this case we're looking

00:20:30.226 --> 00:20:34.966
for the location
ISO 6709 identifier.

00:20:34.966 --> 00:20:37.516
So once we've found it we're
good to go and we can resume

00:20:37.516 --> 00:20:39.016
with the code on
the previous slide.

00:20:39.566 --> 00:20:42.296
So that's how QuickTime
Player is drawing the map

00:20:42.296 --> 00:20:45.046
or drawing the path on the
map before you start playback.

00:20:45.676 --> 00:20:48.256
The other thing that QuickTime
Player does, as you saw,

00:20:48.256 --> 00:20:50.886
is it can update the current
location while you're doing

00:20:50.886 --> 00:20:53.456
playback or even scrubbing
around and the way it does

00:20:53.526 --> 00:20:57.246
that while it's already playing
the asset using an AVPlayerItem

00:20:57.556 --> 00:20:59.556
and we're going to
use a new class called

00:20:59.556 --> 00:21:03.456
AVPlayerItemMetadataOutput that
you attach to your PlayerItem,

00:21:03.766 --> 00:21:06.196
which also notes how to
vend this data in the form

00:21:06.196 --> 00:21:07.406
of TimedMetadataGroups.

00:21:07.706 --> 00:21:10.456
But unlike the asset reader,
instead of getting all the data

00:21:10.456 --> 00:21:12.196
up front you're going
to be getting it piece

00:21:12.196 --> 00:21:13.936
by piece as the movie plays.

00:21:14.436 --> 00:21:16.526
So a little bit of code,

00:21:16.826 --> 00:21:18.856
you first create your
metadata output using the

00:21:18.856 --> 00:21:20.356
initWithIdentifiers method

00:21:20.586 --> 00:21:23.956
and in this case we're only
interested in metadata that has

00:21:23.956 --> 00:21:27.096
that location identifier so
that's all we're going to get

00:21:27.096 --> 00:21:28.436
by opting into this way.

00:21:29.086 --> 00:21:31.646
Then you create a
delegate that you define

00:21:31.916 --> 00:21:32.816
and that's what's going

00:21:32.816 --> 00:21:35.416
to receive the metadata
during playback and you set

00:21:35.416 --> 00:21:36.516
that delegate on your output

00:21:36.516 --> 00:21:40.256
and tell us what cue you
want us to send the data on.

00:21:41.476 --> 00:21:45.376
Then you create or grab your
AVPlayerItem and call addOutput

00:21:45.376 --> 00:21:48.296
to attach your output, to attach
your output to the playerItem

00:21:48.456 --> 00:21:52.676
and finally make your player
and associate your item

00:21:52.676 --> 00:21:55.106
with the player as the current
item and start playback.

00:21:55.596 --> 00:21:58.106
It's important to get the
smoothest playback experience

00:21:58.106 --> 00:22:01.116
possible, we highly recommend
that you do all of this sort

00:22:01.116 --> 00:22:03.466
of setup work before
you start playback

00:22:03.466 --> 00:22:05.636
or even attach the
item to the player.

00:22:06.186 --> 00:22:12.266
So a little bit of look at
what your delegate method might

00:22:12.266 --> 00:22:12.796
look like.

00:22:13.316 --> 00:22:15.966
There's only one delegate
method; it's the metadataOutput,

00:22:15.966 --> 00:22:19.146
didOutputTimedMetadataGroups,
fromPlayerItemTrack method.

00:22:19.196 --> 00:22:21.536
And the first thing you
want to do is grab an item

00:22:21.536 --> 00:22:23.336
that you can get your
payload data from.

00:22:23.666 --> 00:22:25.046
In this case, to
keep things simple,

00:22:25.046 --> 00:22:27.956
I'm just grabbing the first item
from the first group but keep

00:22:27.956 --> 00:22:29.636
in mind there could
be multiple items,

00:22:29.636 --> 00:22:31.066
there could even
be multiple groups.

00:22:31.426 --> 00:22:33.446
One reason there could
be multiple groups given

00:22:33.446 --> 00:22:38.456
to this method is that the
metadata output will keep track

00:22:38.456 --> 00:22:41.216
of whether the metadata
is coming faster

00:22:41.216 --> 00:22:43.736
than you're processing it and,
if it is, it will start to batch

00:22:43.736 --> 00:22:46.706
that up and give you
the metadata in batches

00:22:46.706 --> 00:22:48.696
when you're done with the
previous batch of metadata.

00:22:49.306 --> 00:22:51.916
So moving on with your
item; you're going

00:22:51.916 --> 00:22:55.076
to do this
LoadValueAsynchronouslyForKeys

00:22:55.116 --> 00:22:56.556
dance that we talked
about before.

00:22:56.786 --> 00:22:59.576
In this case, we're
interested in the value

00:22:59.826 --> 00:23:01.386
and data type properties
so we're going

00:23:01.386 --> 00:23:02.196
to load both of those.

00:23:02.716 --> 00:23:05.336
I've admitted the error
checking for brevity here

00:23:05.336 --> 00:23:07.326
which you'll probably want
to do that error checking

00:23:07.326 --> 00:23:08.496
like we had in the other slide.

00:23:09.126 --> 00:23:12.966
And once we have the completion
handler we can ask the item

00:23:12.966 --> 00:23:16.276
for its data type and make
sure that's the data type we're

00:23:16.276 --> 00:23:18.816
prepared to handle, in this
case my code only knows how

00:23:18.816 --> 00:23:23.096
to handle location information
in ISO 6709 format so we got

00:23:23.096 --> 00:23:26.416
to make sure that's the right
data type and from there we go

00:23:26.416 --> 00:23:28.146
and dispatch our code
to the main thread

00:23:28.146 --> 00:23:29.566
that will update our UI.

00:23:29.856 --> 00:23:34.966
So that's how QuickTime Player
is updating the location

00:23:35.396 --> 00:23:36.726
metadata during playback.

00:23:37.366 --> 00:23:40.506
Of course this is not the
first API that we have offered

00:23:40.506 --> 00:23:42.466
for reading timed
metadata during playback.

00:23:43.196 --> 00:23:46.096
There is an existing
property called timedMetadata

00:23:46.096 --> 00:23:48.516
on AVPlayerItem but
I'm here to say

00:23:48.516 --> 00:23:50.276
that the
AVPlayerItemMetadataOutput

00:23:50.276 --> 00:23:54.196
replaces that property for
all of these use cases.

00:23:55.386 --> 00:23:57.686
Now we're not deprecating
the property yet

00:23:57.966 --> 00:24:01.066
but we do recommend, if
you're new to timed metadata,

00:24:01.066 --> 00:24:03.356
just adopt the metadataOutput

00:24:03.356 --> 00:24:04.626
and not worry about
the property.

00:24:05.126 --> 00:24:09.066
If you're already using the
property version we do recommend

00:24:09.066 --> 00:24:12.726
that you move over but just you
know that you should make sure

00:24:12.726 --> 00:24:16.206
that your code is working
properly after that transition,

00:24:16.446 --> 00:24:17.506
in particular I'll point

00:24:17.506 --> 00:24:21.596
out that the metadataOutput
will give you, for certain kinds

00:24:21.596 --> 00:24:26.026
of HLS content, will give
more specific identifiers

00:24:26.366 --> 00:24:27.926
than the old property did.

00:24:27.926 --> 00:24:30.556
So just make sure your code
is prepared to handle that.

00:24:31.386 --> 00:24:35.536
The last topic on reading
timed metadata is Chapters.

00:24:36.066 --> 00:24:38.386
Chapters, like I said, have
been supported for some time;

00:24:38.386 --> 00:24:39.816
they even have their own API:

00:24:40.336 --> 00:24:43.076
chapterMetadataGroupsBest
MatchingPreferredLanguages.

00:24:43.146 --> 00:24:44.766
This is on AVAsset.

00:24:45.636 --> 00:24:48.926
This will give you an array
of timed metadata groups

00:24:49.296 --> 00:24:52.286
that contain items
with the identifier,

00:24:52.286 --> 00:24:55.766
QuickTimeUserDataChapter,
and we've supported this

00:24:55.766 --> 00:24:59.686
for some time for QuickTime
movie files and M4Vs and,

00:24:59.686 --> 00:25:05.776
new in iOS 8 is the-and OS X
Yosemite-is support for chapters

00:25:05.776 --> 00:25:08.936
in HTTP Live Streams
as well as MP3 files.

00:25:09.176 --> 00:25:10.356
And I'll tell you more about how

00:25:10.356 --> 00:25:13.766
to author those HLS chapters
in just a little bit.

00:25:14.566 --> 00:25:17.516
So for more information,
we have some sample code

00:25:17.516 --> 00:25:20.916
that does approximately what
QuickTime Player is doing,

00:25:21.416 --> 00:25:24.326
where it can show your
location during play back.

00:25:24.756 --> 00:25:28.716
We also have a previous session
about AssetReader that goes

00:25:28.716 --> 00:25:31.736
into much more detail than I did
here, called "Working with Media

00:25:31.736 --> 00:25:34.476
in AVFoundation" from 2011.

00:25:34.506 --> 00:25:36.836
So that's how you read and
play back timed metadata.

00:25:37.636 --> 00:25:40.776
Our next timed metadata topic
is how you can create your own

00:25:40.776 --> 00:25:42.536
movies that contain
timed metadata.

00:25:43.116 --> 00:25:45.056
We saw the screenshot
before and I mentioned

00:25:45.106 --> 00:25:48.796
that these annotations are
stored as timed metadata and,

00:25:48.876 --> 00:25:51.696
to show you this demo app, I'd
like to invite Shalini back

00:25:51.696 --> 00:25:53.396
up on stage to demo it.

00:25:54.216 --> 00:25:56.396
>> This time let's
look at an app on how

00:25:56.396 --> 00:25:59.816
to author your own custom
metadata movie files.

00:26:00.356 --> 00:26:04.266
Here I have a video and if I
would like to share some notes

00:26:04.476 --> 00:26:07.706
with my friend, who is good
at fixing colors in a movie,

00:26:07.936 --> 00:26:11.246
I can now do that
within the app.

00:26:11.516 --> 00:26:15.066
To add annotations, I
use a two-finger gesture,

00:26:15.306 --> 00:26:22.096
I can use a pinch gesture to
resize and then add a comment

00:26:24.156 --> 00:26:28.266
which is enough for my whoever
looks at the video later

00:26:28.396 --> 00:26:31.786
to fix the colors there
and then I begin playback.

00:26:33.296 --> 00:26:36.366
And as playback progresses,
I track the circle

00:26:37.116 --> 00:26:39.246
to where I want this
to be fixed.

00:26:39.926 --> 00:26:43.206
And now that I have this
annotation and I can write it

00:26:43.206 --> 00:26:46.626
out along with the audio and
video to do that, I hit "export"

00:26:47.996 --> 00:26:51.076
and now we see an AV
player view controller

00:26:51.076 --> 00:26:54.256
which shows the exported
movie along with the metadata

00:26:54.256 --> 00:26:55.216
which was written to it.

00:26:55.586 --> 00:27:00.556
So if I start playback you see
the annotation is moving along

00:27:00.556 --> 00:27:04.476
the timeline in the
part in which I traced.

00:27:04.906 --> 00:27:09.996
So if I scrub back in time you
can see the annotation moving.

00:27:10.336 --> 00:27:12.646
You might wonder that
the annotation is baked

00:27:12.646 --> 00:27:14.126
into the video frame; it is not.

00:27:15.346 --> 00:27:19.286
It is being rendered real-time
using AVPlayerItemMetadataOutput

00:27:19.886 --> 00:27:23.586
and you can change the color
or the font of the annotation.

00:27:24.016 --> 00:27:27.356
So if I begin playback, you
see the rendering is happening

00:27:27.356 --> 00:27:31.266
in real time.

00:27:31.266 --> 00:27:34.656
That's AVTimedAnnotationWriter,
we have this available

00:27:34.656 --> 00:27:36.846
as a sample code
as well, thank you.

00:27:36.846 --> 00:27:38.946
>> So that was a
great demonstration

00:27:38.946 --> 00:27:42.836
of not only the playback part
of it but also how to write

00:27:42.836 --> 00:27:45.206
that data into the file,
so let's take a look at how

00:27:45.206 --> 00:27:46.056
that was accomplished.

00:27:46.056 --> 00:27:50.296
So we're going to use an
AVAssetWriter to write the file

00:27:50.626 --> 00:27:53.596
and we're going to use an
AVAssetWriterInput in order

00:27:53.596 --> 00:27:55.816
to write that metadata
track to the file.

00:27:55.816 --> 00:27:58.056
Just like the reader side,

00:27:58.336 --> 00:28:01.736
the writer has a new class
that's a metadataAdaptor

00:28:02.266 --> 00:28:04.976
and that class knows how
to interpret instances

00:28:04.976 --> 00:28:08.286
of AVTimedMetadataGroup and
write that into the file.

00:28:08.286 --> 00:28:12.866
See a little bit of code;
first thing we're going

00:28:12.866 --> 00:28:15.666
to do is create our
AssetWriter Input.

00:28:15.666 --> 00:28:20.046
We're going to use the media
type AVMediaTypeMetadata,

00:28:20.286 --> 00:28:23.026
once again nil outputSettings
and we're going to have

00:28:23.026 --> 00:28:26.396
to provide a clue to
the source format, well,

00:28:26.396 --> 00:28:28.496
the format of the data that
we're going to be appending.

00:28:28.496 --> 00:28:30.086
We'll talk more about this

00:28:30.176 --> 00:28:32.126
and why it's required
on the next slide.

00:28:32.736 --> 00:28:34.676
Then you simply create
your metadataAdaptor

00:28:34.676 --> 00:28:38.526
with the reference to that
input and, as you generate

00:28:38.526 --> 00:28:40.506
or receive your timed
metadata groups,

00:28:40.906 --> 00:28:43.666
you simply use the
appendTimedMetadataGroup method

00:28:43.926 --> 00:28:47.416
to continue to append those
and write them to the file.

00:28:47.646 --> 00:28:50.306
So what's the deal with
that source format thing.

00:28:50.856 --> 00:28:55.476
Well, it turns out in order
for AVAssetWriter to be able

00:28:55.476 --> 00:28:59.036
to write your metadata in the
most efficient way possible,

00:28:59.196 --> 00:29:01.566
it needs to know up
front exactly what kind

00:29:01.566 --> 00:29:02.936
of metadata it is
going to be writing.

00:29:03.756 --> 00:29:08.556
This will result in the most
lowest storage overhead in terms

00:29:08.556 --> 00:29:10.176
of the number of bytes
your file takes up

00:29:10.176 --> 00:29:13.376
and it also has a effect
on how efficient it is

00:29:13.376 --> 00:29:15.546
to play back this
kind of contents.

00:29:15.546 --> 00:29:17.116
You don't want to be
using too much power

00:29:17.426 --> 00:29:19.436
when you're playing this
kind of content back.

00:29:19.606 --> 00:29:21.486
So you do have some
options in terms

00:29:21.486 --> 00:29:24.046
of how you actually construct
one of these format hits.

00:29:24.796 --> 00:29:25.586
If you're reading

00:29:25.586 --> 00:29:28.566
from AVAssetReader you
can actually ask the track

00:29:28.566 --> 00:29:30.306
that you are reading
from to give you its list

00:29:30.306 --> 00:29:33.136
of format descriptions
and use one of those.

00:29:33.936 --> 00:29:36.806
If you're creating the metadata
group yourself or getting it

00:29:36.806 --> 00:29:40.386
from some other source then
you can use a new method called

00:29:40.386 --> 00:29:43.446
copyFormatDescription that
will give you back an instance

00:29:43.446 --> 00:29:46.166
of CM format description that
will do this job for you.

00:29:46.776 --> 00:29:49.086
It's important to note that
if you go this route you need

00:29:49.086 --> 00:29:50.376
to make sure that the contents

00:29:50.376 --> 00:29:53.276
of your metadata group
are comprehensive in terms

00:29:53.276 --> 00:29:55.766
of it containing
every combination

00:29:55.766 --> 00:29:58.926
of identifier data
type and language tag

00:29:58.926 --> 00:30:00.496
that you are going
to be appending.

00:30:00.746 --> 00:30:03.946
That is. it contains an item
with each of those combinations.

00:30:04.626 --> 00:30:07.976
Of course, since the CM format
description is a CF type,

00:30:08.266 --> 00:30:10.006
you'll need a CFRelease
app when you're done.

00:30:10.746 --> 00:30:12.846
Of course, there's one
more way you can do this:

00:30:12.846 --> 00:30:15.166
you can create the format
description directly using

00:30:15.166 --> 00:30:16.336
CoreMedia APIs.

00:30:16.666 --> 00:30:21.016
And here you use this long name
CMMetadataFormatDescription

00:30:21.016 --> 00:30:23.496
CreateWith
MetadataSpecifications function.

00:30:23.536 --> 00:30:26.386
You're going to pass in
the metadataType box.

00:30:26.386 --> 00:30:28.096
That's the sort of
metadata we've been talking

00:30:28.096 --> 00:30:29.976
about this whole time
with timed metadata.

00:30:31.056 --> 00:30:34.006
And these metadata
specifications it's just an

00:30:34.006 --> 00:30:35.086
array of dictionaries.

00:30:35.576 --> 00:30:38.626
Each dictionary contains those
combinations I was talking

00:30:38.626 --> 00:30:39.306
about before.

00:30:39.306 --> 00:30:43.226
The identifier dataType and
optionally extended language tag

00:30:43.526 --> 00:30:46.736
so you want to make one of
these metadata specifications

00:30:46.736 --> 00:30:49.386
dictionaries for each
combination you plan to append.

00:30:50.556 --> 00:30:54.106
So the one thing that was not
obvious about that demo is

00:30:54.236 --> 00:30:58.016
that we're actually writing
metadata timed metadata

00:30:58.016 --> 00:31:00.656
that describes one
particular other track.

00:31:01.106 --> 00:31:03.116
So for the example
of these annotations,

00:31:03.116 --> 00:31:06.076
we're really just talking about
the video track of the movie

00:31:06.076 --> 00:31:08.656
and not the sound or
anything else like that.

00:31:08.716 --> 00:31:13.766
So just like we had a way of
making track-specific metadata

00:31:13.766 --> 00:31:15.256
that applied to the
entire track,

00:31:15.256 --> 00:31:16.526
with those tagged
characteristics

00:31:16.526 --> 00:31:18.806
that we saw before, you
also have the ability

00:31:18.806 --> 00:31:21.466
to formerly mark
your metadata track

00:31:21.676 --> 00:31:24.066
as describing one
particular other track.

00:31:24.686 --> 00:31:27.246
You do that with the
addTrackAssociationWith

00:31:27.246 --> 00:31:31.326
TrackOfInput method using as the
parameter the AssetWriterInput

00:31:31.326 --> 00:31:33.016
that you are using to
write your video track.

00:31:33.226 --> 00:31:35.406
And your receiver is the
input that you are using

00:31:35.406 --> 00:31:36.546
to write your metadata track.

00:31:36.936 --> 00:31:39.126
You use the
AssociationTypeMetadataReferent.

00:31:39.916 --> 00:31:43.186
So that's how your create
metadata that's timed

00:31:43.186 --> 00:31:45.326
but also specific to
a particular track.

00:31:46.096 --> 00:31:49.326
The next thing we did that was
interesting in that demo is

00:31:49.326 --> 00:31:51.706
that we actually used our
own custom identifiers.

00:31:51.706 --> 00:31:53.986
So we had that big list
of built in identifiers.

00:31:54.246 --> 00:31:55.406
Well, you don't have
to use those;

00:31:55.406 --> 00:31:56.636
you can actually build your own

00:31:57.036 --> 00:31:59.836
and as I mentioned before an
identifier is just a combination

00:31:59.836 --> 00:32:02.866
of key space and key and
it has a particular format:

00:32:02.866 --> 00:32:04.936
it's just a string but it
is in a particular format

00:32:05.246 --> 00:32:07.336
so to help you make your
own custom identifiers,

00:32:07.336 --> 00:32:10.256
we have this method,
identifierFor Key, and keySpace,

00:32:10.326 --> 00:32:14.086
it's a class method
on AVMetadataItem.

00:32:14.086 --> 00:32:17.476
There are some rules to
follow: your key space needs

00:32:17.476 --> 00:32:19.326
to be four characters
long if you want to use it

00:32:19.326 --> 00:32:20.376
for timed metadata

00:32:20.696 --> 00:32:22.996
so we actually recommend you
use our built-in key space,

00:32:23.106 --> 00:32:24.836
the QuickTimeMetadata keySpace.

00:32:25.376 --> 00:32:28.816
We also highly recommend
you use reverse DNS notation

00:32:28.816 --> 00:32:30.776
for your custom keys
to avoid collisions

00:32:31.026 --> 00:32:32.636
with other kinds of metadata.

00:32:32.806 --> 00:32:36.256
So a brief code snippet you
can see you can simply use this

00:32:36.256 --> 00:32:39.666
method to make your custom
identifier and then set

00:32:39.666 --> 00:32:42.536
that on the identifier property
of your mutableMetadataItem.

00:32:42.936 --> 00:32:46.936
So in addition to custom
identifiers you can also create

00:32:46.936 --> 00:32:48.346
your own custom data types.

00:32:49.966 --> 00:32:52.746
So we're all familiar by now,
through this presentation,

00:32:52.746 --> 00:32:55.026
with some of the built-in
data types that we defined;

00:32:55.256 --> 00:32:56.306
there's a lot more than these

00:32:56.306 --> 00:32:58.266
but we've been using these
quite heavily already.

00:32:58.266 --> 00:33:00.256
These are really useful

00:33:00.256 --> 00:33:02.656
but sometimes you want
your data type information

00:33:02.656 --> 00:33:05.896
to express more, maybe about
the domain you're working in,

00:33:06.616 --> 00:33:08.956
so if you are doing a serial
number or a bar code kind

00:33:08.956 --> 00:33:10.156
of thing you might want

00:33:10.156 --> 00:33:13.236
to define a data type that's
this sort of serial number

00:33:13.236 --> 00:33:17.196
as string data type or
barcode image as JPEG data type

00:33:17.326 --> 00:33:19.066
so you have more
specific information

00:33:19.066 --> 00:33:20.966
about what your metadata
actually contains.

00:33:21.576 --> 00:33:26.136
The way that this works is,
you have to tell us exactly how

00:33:26.136 --> 00:33:30.596
to serialize that custom
data type and the way you do

00:33:30.596 --> 00:33:33.516
that is you tell us that your
custom data type conforms to one

00:33:33.516 --> 00:33:34.836
of our built-in data types.

00:33:35.346 --> 00:33:37.796
So in this case the
serial number conforms

00:33:37.846 --> 00:33:41.736
to the UTF8 data type so under
the hood it's UTF8 string,

00:33:41.736 --> 00:33:44.986
but we know that it really
represents a serial number

00:33:45.276 --> 00:33:46.716
and the same with
the barcode image.

00:33:47.126 --> 00:33:49.926
The way that you do this is you
register your data type using

00:33:49.926 --> 00:33:54.266
the CMMetadataDataTypeRegistry
RegisterDataType function that's

00:33:54.266 --> 00:33:55.256
defined in Core Media.

00:33:55.776 --> 00:33:58.716
You can't create your
own custom base types

00:33:59.206 --> 00:34:03.816
but you can create your own
custom type that conforms

00:34:03.816 --> 00:34:06.556
to our raw data built-in type

00:34:06.556 --> 00:34:10.146
if your data type really is
just a custom sequence of bytes.

00:34:11.396 --> 00:34:14.235
So there are some rules
to using AVAssetWriter

00:34:14.386 --> 00:34:17.056
for writing timed metadata.

00:34:17.056 --> 00:34:20.755
Most importantly, every metadata
item that you append has

00:34:20.755 --> 00:34:24.226
to have non-nil values for
identifier, data type and value.

00:34:24.226 --> 00:34:28.835
Your identifier has to conform
to the format that we specify,

00:34:28.835 --> 00:34:31.076
so we highly recommend
using that utility method

00:34:31.076 --> 00:34:31.856
that we just talked about.

00:34:32.666 --> 00:34:34.985
The value has to be
compatible with the data type

00:34:35.045 --> 00:34:39.106
so you can tell us that your
NSString value is an UTF8 string

00:34:39.396 --> 00:34:40.335
but don't try telling us

00:34:40.386 --> 00:34:43.806
that your custom class is a UTF8
string because we won't know how

00:34:43.806 --> 00:34:47.056
to serialize that properly
and the AssetWriter will fail.

00:34:47.516 --> 00:34:50.755
As I mentioned before, you have
to create your AssetWriterInput

00:34:50.755 --> 00:34:53.056
with a format hint and
that must be comprehensive

00:34:53.416 --> 00:34:54.666
and we described that before.

00:34:54.766 --> 00:34:57.646
So the last topic
about AssetWriter

00:34:57.646 --> 00:35:01.886
and timed metadata is a recipe
for creating your own movies

00:35:02.156 --> 00:35:04.206
that have the same sort
of dynamic location

00:35:04.206 --> 00:35:05.676
that we've seen a
couple of times already.

00:35:06.706 --> 00:35:09.706
To do this, you can
use AVCapture audio

00:35:09.706 --> 00:35:12.456
and video data outputs
and target that data

00:35:12.456 --> 00:35:15.436
at twin instances of
AssetWriterInput and,

00:35:15.506 --> 00:35:19.736
at the same time, grab
information from Core Location

00:35:19.736 --> 00:35:22.266
that represents the location
information and write

00:35:22.266 --> 00:35:23.906
that to its own
AssetWriterInput.

00:35:24.766 --> 00:35:28.676
For more detail about how to do
that we've actually implemented

00:35:28.676 --> 00:35:30.546
that and made it
available as sample code,

00:35:30.846 --> 00:35:34.436
so see AVCaptureLocation if you
want to make your own movies

00:35:34.436 --> 00:35:35.986
that contain dynamic location.

00:35:36.626 --> 00:35:39.116
We also have sample code
as Shalini mentioned

00:35:39.116 --> 00:35:40.416
for the demo we just showed you,

00:35:40.686 --> 00:35:42.776
that's called
AVTimedAnnotationWriter.

00:35:43.106 --> 00:35:45.376
And, of course, for more
information about AssetWriter

00:35:45.376 --> 00:35:48.146
in general, see that same
talk I referenced earlier:

00:35:48.146 --> 00:35:50.326
"Working with Media
in AVFoundation".

00:35:51.096 --> 00:35:54.726
Last two quick topics about
timed metadata: ExportSession.

00:35:55.366 --> 00:35:57.966
Just like we've said the
asset ExportSession will

00:35:57.966 --> 00:36:01.456
by default pass through any
of your metadata that applies

00:36:01.456 --> 00:36:04.436
to the entire asset or
entire track, it will pass

00:36:04.496 --> 00:36:06.356
that through, copy it
to the output file.

00:36:06.626 --> 00:36:09.376
It will do the same thing with
timed metadata that exists

00:36:09.376 --> 00:36:11.126
in the source file provided

00:36:11.126 --> 00:36:13.786
that your destination file
type is QuickTime Movie.

00:36:14.046 --> 00:36:16.916
We'll talk more about file
types in just a little bit

00:36:17.316 --> 00:36:20.596
but basically ExportSession
behaves exactly

00:36:20.596 --> 00:36:21.466
as you would expect.

00:36:22.526 --> 00:36:27.396
In our last timed metadata
authoring topic is HTTP Live

00:36:27.396 --> 00:36:30.536
Streaming chapters so if
you want to author chapters

00:36:30.536 --> 00:36:34.556
in your HLS stream, you can use
the session-data tag we talked

00:36:34.556 --> 00:36:40.386
about earlier and the special
data ID, com.apple.hls.chapters.

00:36:40.826 --> 00:36:43.296
Your URL should point
to a JSON file

00:36:43.476 --> 00:36:47.346
that describes the chapter
information for that stream and,

00:36:47.346 --> 00:36:50.066
of course for more detail
on this, see that same link

00:36:50.066 --> 00:36:53.166
that I referenced earlier
for HTTP Live Streaming.

00:36:53.446 --> 00:36:55.716
All right, so that
is timed metadata,

00:36:55.716 --> 00:36:57.326
our next topic is privacy.

00:36:58.066 --> 00:37:00.546
Why is privacy important
in this context?

00:37:00.546 --> 00:37:04.446
Well, any time that you
are writing your users data

00:37:04.446 --> 00:37:07.856
to a file you need to
be at least considerate

00:37:07.856 --> 00:37:12.546
about their privacy and be aware
that the metadata that you write

00:37:12.546 --> 00:37:15.926
out to these movie files can
contain user identifiable

00:37:15.926 --> 00:37:19.176
information, the most obvious
example of that is location.

00:37:19.836 --> 00:37:23.696
And so because movie files
can be distributed and we want

00:37:23.696 --> 00:37:25.446
to protect the privacy
of our users,

00:37:26.136 --> 00:37:29.776
for our built-in sharing
services, we do our best

00:37:29.776 --> 00:37:33.276
to strip out any potentially
user identifiable information,

00:37:33.336 --> 00:37:36.356
such as this location and we
recommend that you do the same.

00:37:36.686 --> 00:37:38.046
So we've given you a utility

00:37:38.046 --> 00:37:41.736
for that called
AVMetadataItemFilter.

00:37:42.276 --> 00:37:44.716
Right now there is only one
filter that we make available

00:37:44.716 --> 00:37:46.316
but it is geared
towards privacy,

00:37:46.316 --> 00:37:49.686
it is the metadata item filter
for sharing and that will strip

00:37:49.686 --> 00:37:52.716
out any of this sort of
user identifying information

00:37:52.716 --> 00:37:55.086
that we're talking about;
location is only one example.

00:37:55.086 --> 00:37:57.986
But it will also strip out
anything it doesn't recognize,

00:37:58.016 --> 00:37:59.186
because it doesn't know whether

00:37:59.186 --> 00:38:02.126
that might contain user
identifiable information.

00:38:02.126 --> 00:38:05.356
So that includes any
metadata that uses identifiers

00:38:05.356 --> 00:38:06.536
that you define yourself.

00:38:07.306 --> 00:38:11.476
It will leave in some things
like metadata that's important

00:38:11.476 --> 00:38:12.656
to the structure of the movie

00:38:12.656 --> 00:38:14.746
and chapters are the
best example of that,

00:38:15.166 --> 00:38:18.166
and also any commercial
related data like your Apple ID.

00:38:19.406 --> 00:38:23.776
So to use the MetadataItemFilter
you're going to first

00:38:23.776 --> 00:38:27.986
of all create your filter and
feed it your original array

00:38:27.986 --> 00:38:31.296
of metadata items using
this metadataItemsFromArray

00:38:31.296 --> 00:38:33.656
filteredByMetadataItemFilter
method.

00:38:33.966 --> 00:38:36.696
This is a companion to that
other filtering method based

00:38:36.696 --> 00:38:38.406
on identifiers we've
been using all day

00:38:39.276 --> 00:38:41.666
and then once you have
your filtered array

00:38:41.746 --> 00:38:45.686
of metadata items just set
that on your AssetWriter

00:38:45.686 --> 00:38:47.566
or ExportSession as
you normally would.

00:38:47.916 --> 00:38:49.976
Well actually I mentioned
ExportSession

00:38:49.976 --> 00:38:53.006
but things can be simple if
you're using the ExportSession

00:38:53.006 --> 00:38:56.646
and only want to
copy the metadata

00:38:56.766 --> 00:38:59.046
from the source asset
and not add your own.

00:38:59.356 --> 00:39:01.606
You just set the filter
on the ExportSession

00:39:01.606 --> 00:39:03.326
and it will actually do
the filtering for you,

00:39:03.976 --> 00:39:07.186
this will filter both
static and timed metadata

00:39:07.186 --> 00:39:10.726
but it will only filter the
metadata from the source asset.

00:39:10.726 --> 00:39:13.236
If you set your own metadata
on the metadata property,

00:39:13.596 --> 00:39:16.146
it won't filter that for you;
you'll need to do the process

00:39:16.146 --> 00:39:19.246
that I just described of
doing the filtering yourself.

00:39:19.246 --> 00:39:20.726
The only other thing
to keep in mind is

00:39:20.726 --> 00:39:22.456
that the export may
take more time

00:39:22.696 --> 00:39:25.496
when the filter is being used
because it has to go through

00:39:25.496 --> 00:39:27.356
and examine all of
the metadata items.

00:39:27.876 --> 00:39:29.396
So that's privacy.

00:39:30.196 --> 00:39:34.016
Our last section of the talk
today is some assorted best

00:39:34.016 --> 00:39:36.366
practices when you are
writing your own files

00:39:36.416 --> 00:39:37.636
that contain metadata.

00:39:39.536 --> 00:39:42.436
First up, what if you're
writing timed metadata

00:39:42.676 --> 00:39:45.986
and you have multiple
streams of metadata

00:39:46.136 --> 00:39:47.686
that use different identifiers.

00:39:48.256 --> 00:39:50.146
How do you get those
into the same file?

00:39:50.146 --> 00:39:52.986
Well, we actually have the
situation in the demo app,

00:39:53.206 --> 00:39:56.266
we have that circle is comprised
of two different pieces

00:39:56.266 --> 00:39:59.096
of information, the
position and the radius.

00:39:59.676 --> 00:40:02.406
So we're representing these

00:40:02.406 --> 00:40:04.826
and the demo app is two
distinct streams of metadata.

00:40:05.366 --> 00:40:07.666
And so the most obvious way
I can think of to get this

00:40:07.666 --> 00:40:12.816
into a file is to use two
different AVAssetWriterInputs,

00:40:13.186 --> 00:40:15.386
which result in having
two metadata tracks

00:40:15.386 --> 00:40:17.046
in the output file,
pretty simple.

00:40:17.466 --> 00:40:20.336
But there is another
way you can do it,

00:40:20.336 --> 00:40:23.966
you could instead combine those
two different types of metadata

00:40:23.966 --> 00:40:26.816
into one timed metadata
group and write

00:40:26.816 --> 00:40:28.806
that to a single
AssetWriterInput

00:40:28.806 --> 00:40:31.766
and that will result in
only one metadata track

00:40:31.766 --> 00:40:34.576
in the output file that contains
multiple different kinds

00:40:34.576 --> 00:40:35.366
of identifiers.

00:40:35.876 --> 00:40:38.426
There are some advantages to
this approach, not the least

00:40:38.426 --> 00:40:41.316
of which is it can result
in lower storage overhead

00:40:41.626 --> 00:40:44.036
and therefore as we always
see more efficient playback.

00:40:45.136 --> 00:40:48.246
But there are of course
pros and cons to everything.

00:40:48.696 --> 00:40:50.976
So you'll definitely want
to consider combining

00:40:51.216 --> 00:40:53.436
into one track your
different metadata

00:40:53.616 --> 00:40:55.716
if they are used
together during playback

00:40:56.316 --> 00:40:58.296
and they have identical timing.

00:40:58.296 --> 00:41:00.616
This is definitely the case
with the example we just saw

00:41:00.616 --> 00:41:03.046
with the circle center
and the circle radius.

00:41:03.866 --> 00:41:07.096
If these are not true then
you might not want to combine.

00:41:07.096 --> 00:41:09.346
And in fact one instance where
you definitely do not want

00:41:09.346 --> 00:41:12.596
to combine, is if
you have one type

00:41:12.596 --> 00:41:15.856
of metadata that's associated
with another track in the file,

00:41:15.856 --> 00:41:18.346
so that's like our
annotations are associated

00:41:18.416 --> 00:41:20.736
with the video track, but
then you have another type

00:41:20.736 --> 00:41:23.466
of metadata like location
that is associated

00:41:23.466 --> 00:41:24.756
with the entire asset.

00:41:24.756 --> 00:41:27.316
You don't want to combine
those into one track,

00:41:27.316 --> 00:41:31.836
otherwise your location in that
example will become mistakenly

00:41:31.836 --> 00:41:33.406
associated with just
the video track,

00:41:33.406 --> 00:41:34.746
and that's not what you want.

00:41:35.006 --> 00:41:36.076
So that's how to deal

00:41:36.076 --> 00:41:38.156
with multiple streams
of timed metadata.

00:41:38.956 --> 00:41:43.466
Next topic is duration of
your timed metadata groups,

00:41:44.216 --> 00:41:45.766
when you get a timed
metadata group

00:41:45.766 --> 00:41:47.526
from AVFoundation
it's always going

00:41:47.526 --> 00:41:51.466
to have a fully formed
time range.

00:41:51.756 --> 00:41:54.456
So that means it will have
a start time and a duration.

00:41:54.846 --> 00:41:57.426
We actually recommend when you
make your own timed metadata

00:41:57.426 --> 00:41:59.906
groups for a pending
with the AVAssetWriter

00:42:00.196 --> 00:42:02.236
that you don't bother
giving us a duration.

00:42:02.636 --> 00:42:05.466
And to see how that works,
here's an example of a group

00:42:05.466 --> 00:42:08.266
that starts at time 0 but
it doesn't have a duration

00:42:08.266 --> 00:42:10.326
so how do we know when it ends?

00:42:10.326 --> 00:42:12.536
Well, of course we'll wait
until you append the next one

00:42:12.536 --> 00:42:15.596
and then we'll say that,
"Okay, the end time

00:42:15.596 --> 00:42:17.696
of the first group is the same

00:42:17.696 --> 00:42:19.386
as the start time
of the next one."

00:42:19.906 --> 00:42:22.206
So this ensures that your
metadata track is going

00:42:22.206 --> 00:42:27.636
to have a continuous stream of
contiguous metadata and we think

00:42:27.636 --> 00:42:30.266
that for most cases this is the
best way to store your metadata.

00:42:31.036 --> 00:42:32.916
The way you accomplish this is,

00:42:32.916 --> 00:42:34.356
when you're making
your time range,

00:42:34.576 --> 00:42:38.356
you just use KCMTimeInvalid
for your duration

00:42:38.656 --> 00:42:39.956
and we'll take care of the rest.

00:42:40.576 --> 00:42:43.846
We do recognize that there are
cases where you might not want

00:42:43.846 --> 00:42:46.536
to have contiguous
metadata, you might want

00:42:46.536 --> 00:42:50.246
to author an explicit gap into
your metadata stream and so,

00:42:50.246 --> 00:42:52.246
for that, our recommendation
is that you give us

00:42:52.656 --> 00:42:55.596
in the middle there a group
that contains zero items.

00:42:55.746 --> 00:42:58.526
This is the best way to
author a gap in the metadata.

00:42:58.526 --> 00:43:03.086
And you can see we just do that
by presenting an empty array

00:43:03.166 --> 00:43:05.076
when we're creating our
timed metadata group.

00:43:05.506 --> 00:43:08.636
Notice that we're still
using KCMTimeInvalid

00:43:08.636 --> 00:43:09.876
for our duration here.

00:43:10.326 --> 00:43:13.406
Just tell us when the beginning
of the metadata silence,

00:43:13.406 --> 00:43:16.976
so to speak, is and we'll figure
out how long it lasts based

00:43:16.976 --> 00:43:19.966
on when you append your
next non-empty group.

00:43:20.566 --> 00:43:22.756
So that's how you write
gaps in your metadata.

00:43:23.446 --> 00:43:24.946
Our last best practice,

00:43:25.516 --> 00:43:27.346
I mentioned output
file type before

00:43:27.636 --> 00:43:29.876
and here's the longer
explanation.

00:43:30.916 --> 00:43:32.366
Well, AssetWriter

00:43:32.366 --> 00:43:35.166
and AssetExportSessions
support writing

00:43:35.166 --> 00:43:37.566
to a wide variety of file types.

00:43:39.626 --> 00:43:42.376
You've got QuickTime
movie, MPEG4, and all sorts

00:43:42.376 --> 00:43:44.916
of other kind of file types

00:43:45.406 --> 00:43:49.426
and those file types can carry
different kinds of metadata;

00:43:49.496 --> 00:43:51.746
some have more restrictions
than others about what kind

00:43:51.746 --> 00:43:53.526
of metadata can go
into that file type.

00:43:53.526 --> 00:43:57.246
So the easiest situation, say
if you have an ExportSession

00:43:57.486 --> 00:44:01.546
and you're going from one,
from the same file type

00:44:01.546 --> 00:44:02.946
as your source to the output,

00:44:02.946 --> 00:44:05.436
so for this example they're
both QuickTime movie files.

00:44:06.186 --> 00:44:08.426
This is the easiest
way to ensure that all

00:44:08.426 --> 00:44:11.206
of that data is actually going
to make it into the output file.

00:44:11.706 --> 00:44:14.476
If instead you're using a
different output file type,

00:44:14.726 --> 00:44:16.536
like MPEG4 in this example,

00:44:16.836 --> 00:44:19.626
then some different things
are going to have to happen.

00:44:19.966 --> 00:44:22.306
You notice those last few
items didn't quite make it

00:44:22.306 --> 00:44:23.276
into the output file;

00:44:23.386 --> 00:44:25.626
it's because they have no
equivalent representation

00:44:25.806 --> 00:44:27.716
that works with an MPEG4 file.

00:44:28.576 --> 00:44:30.126
If you're looking
closely you'll also notice

00:44:30.126 --> 00:44:32.356
that those top two
items have changed,

00:44:32.886 --> 00:44:36.136
although they sound very similar
they are slightly different

00:44:36.136 --> 00:44:38.406
identifiers because that's
the kind of identifier

00:44:38.406 --> 00:44:39.396
that works with MPEG4.

00:44:39.396 --> 00:44:43.836
So both AssetExportSession and
AssetWriter will do the sort

00:44:43.836 --> 00:44:44.906
of three step process.

00:44:45.346 --> 00:44:48.876
First, they'll try to pass
that data through directly

00:44:49.196 --> 00:44:52.986
if possible and, if not, they'll
try to convert the identifier

00:44:52.986 --> 00:44:54.706
into an equivalent
representation

00:44:54.866 --> 00:44:56.006
in the output file type.

00:44:56.626 --> 00:44:59.816
If neither of those work, we
have no choice but to just drop

00:44:59.816 --> 00:45:01.636
that piece of metadata
on the floor.

00:45:01.636 --> 00:45:05.766
So in terms of guidance on how
to choose an output file type,

00:45:06.126 --> 00:45:07.776
well, my two recommendations
are,

00:45:08.266 --> 00:45:12.876
if you are using say an
ExportSession to copy all

00:45:12.966 --> 00:45:17.426
of the metadata, timed or
otherwise, from the source asset

00:45:17.426 --> 00:45:20.336
to your destination file,
the best way is to try

00:45:20.336 --> 00:45:22.766
and use the same file type
that you started with,

00:45:22.876 --> 00:45:25.716
and if you don't know what the
file type is you can use the

00:45:25.716 --> 00:45:27.776
NSURLTypeIdentifierKey
to find out.

00:45:28.276 --> 00:45:32.746
You can also always use
the QuickTime Movie file

00:45:32.746 --> 00:45:37.216
because that is going to
have the greatest chance

00:45:37.216 --> 00:45:39.726
of supporting your metadata
no matter where it came from.

00:45:39.966 --> 00:45:42.416
If AVFoundation supports
it, there's a good chance

00:45:42.416 --> 00:45:44.496
that it will be supported
by the QuickTime movie file.

00:45:44.826 --> 00:45:46.936
Of course, this is the only way

00:45:46.936 --> 00:45:48.446
if you're writing
timed metadata,

00:45:48.716 --> 00:45:51.326
to get your timed
metadata into a file is

00:45:51.366 --> 00:45:53.816
to use QuickTime Movie file;
it's the only file form

00:45:53.816 --> 00:45:55.216
that supports it right now.

00:45:55.856 --> 00:45:58.596
Of course good advice is always

00:45:58.596 --> 00:46:00.186
to check the results,
no matter what.

00:46:00.886 --> 00:46:04.246
Check that your output files
contain the kind of metadata

00:46:04.246 --> 00:46:06.436
that you expect, all the
metadata that you expect

00:46:07.046 --> 00:46:09.036
and you can choose to
use some of the APIs

00:46:09.146 --> 00:46:10.656
that we've already
talked about if you want

00:46:10.656 --> 00:46:11.546
to do that at runtime.

00:46:12.926 --> 00:46:16.106
Some guidance if that
doesn't end up being the case:

00:46:16.196 --> 00:46:18.486
if you don't get all the
metadata that you expect, well,

00:46:18.486 --> 00:46:20.106
you can try to do the
conversion yourself.

00:46:20.536 --> 00:46:23.316
Especially if you have a
custom identifier and are going

00:46:23.316 --> 00:46:25.936
to a file type that doesn't
support your custom identifier,

00:46:26.456 --> 00:46:29.386
take a look at that long list
of built-in identifiers we have

00:46:29.616 --> 00:46:31.746
and see if there is something
that's roughly equivalent

00:46:31.746 --> 00:46:33.546
to what you're trying
to store and you can do

00:46:33.546 --> 00:46:34.536
that conversion yourself.

00:46:35.226 --> 00:46:36.966
One particular example
I want to call

00:46:36.966 --> 00:46:39.886
out that involves only
built-in identifiers is

00:46:39.886 --> 00:46:42.936
when you're trying to
go from ID3 to iTunes,

00:46:43.246 --> 00:46:45.496
well AVFoundation
currently isn't going to do

00:46:45.496 --> 00:46:46.966
that conversion for you.

00:46:47.436 --> 00:46:49.366
But there's no reason you
couldn't do that yourself,

00:46:49.636 --> 00:46:52.386
so once again just take a look
at our long list of identifiers

00:46:52.626 --> 00:46:55.596
and match them up and do the
conversion in your own code.

00:46:56.956 --> 00:46:59.146
So that is the end of the talk.

00:46:59.496 --> 00:47:02.926
See what we covered: we talked
obviously a lot about metadata

00:47:02.926 --> 00:47:04.986
in AVFoundation,
we talked about all

00:47:04.986 --> 00:47:07.576
of the different classes
you can use for inspection,

00:47:07.816 --> 00:47:10.286
we talked about AVAsset
and AVMetadataItem

00:47:10.286 --> 00:47:12.806
and how those work
together and also authoring,

00:47:12.806 --> 00:47:15.266
we talked about the AssetWriter,

00:47:15.266 --> 00:47:18.376
the AssetExportSession even
briefly on the capture audio

00:47:18.376 --> 00:47:19.556
and movie file outputs.

00:47:20.406 --> 00:47:23.316
We dove into timed metadata,
including all the new features

00:47:23.316 --> 00:47:26.096
that enable things like
the dynamic location

00:47:26.316 --> 00:47:29.436
and your own timed metadata
like the annotation demo.

00:47:30.416 --> 00:47:33.016
We also talked about
privacy considerations

00:47:33.266 --> 00:47:36.136
and some best practices like how
to choose the right file type.

00:47:36.546 --> 00:47:40.146
So for more information, you
can contact our evangelism team

00:47:40.456 --> 00:47:41.826
or see our programing guide,

00:47:42.266 --> 00:47:44.586
there are some other
related sessions you might be

00:47:44.586 --> 00:47:45.186
interested in.

00:47:45.486 --> 00:47:47.226
If you missed this
morning's presentation

00:47:47.226 --> 00:47:48.926
on "Modern Media
Playback", you can catch

00:47:48.976 --> 00:47:50.566
that on the video recording.

00:47:51.016 --> 00:47:55.626
Tomorrow there is also a
camera capture talk focusing

00:47:55.626 --> 00:47:56.746
on manual controls.

00:47:57.266 --> 00:48:00.776
And on Thursday we'll have
a talk about direct access

00:48:00.896 --> 00:48:03.546
to video encoding and
decoding, which I'm sure a lot

00:48:03.546 --> 00:48:04.786
of you will be interested in.

00:48:06.516 --> 00:48:13.440
[ Silence ]
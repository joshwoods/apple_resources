WEBVTT

00:00:14.616 --> 00:00:16.976
>> Hi. Welcome to the
Advanced CloudKit session.

00:00:17.516 --> 00:00:20.546
[ Cheering & Applause ]

00:00:21.046 --> 00:00:21.416
Thank you.

00:00:21.546 --> 00:00:23.526
My name is Jacob Farkas.

00:00:23.526 --> 00:00:25.496
I'm a Software Engineer
at Apple and one

00:00:25.496 --> 00:00:26.896
of the designers of
the CloudKit API.

00:00:27.656 --> 00:00:29.766
And my colleagues and I
have put a lot of hard work

00:00:29.766 --> 00:00:30.706
into the CloudKit API.

00:00:30.706 --> 00:00:33.356
I'm really excited to talk
to you guys about it today.

00:00:33.356 --> 00:00:35.306
So, let's jump right into it.

00:00:36.276 --> 00:00:40.616
So, CloudKit is this thing
that we've built on top

00:00:40.616 --> 00:00:41.886
of our iCloud servers.

00:00:41.886 --> 00:00:45.286
We've built a lot of iCloud
services, and what we're doing

00:00:45.286 --> 00:00:48.626
with CloudKit is exposing those
database servers that we use

00:00:48.626 --> 00:00:51.246
at Apple to all of
you developers.

00:00:52.186 --> 00:00:54.026
So, we're actually using this.

00:00:54.026 --> 00:00:56.796
This is something that we
use in the new iCloud Photos

00:00:56.796 --> 00:00:58.956
and iCloud Drive feature
that we're introducing,

00:00:59.516 --> 00:01:02.366
and we're building all of
that on top of CloudKit.

00:01:03.366 --> 00:01:06.056
If all of this is unfamiliar to
you, you might want to go back

00:01:06.056 --> 00:01:08.206
and check out the
Introducing CloudKit session.

00:01:08.206 --> 00:01:11.506
It was given on Tuesday and
there should be videos online.

00:01:12.876 --> 00:01:14.306
So, we're going to
jump right into this.

00:01:14.456 --> 00:01:15.886
What we're going to learn today,

00:01:15.886 --> 00:01:18.736
we're going to over the CloudKit
private database, which is a way

00:01:18.736 --> 00:01:21.236
for you store private user
information in iCloud.

00:01:22.266 --> 00:01:24.386
We're going to talk about
modeling your data in CloudKit.

00:01:25.516 --> 00:01:27.956
We're going to talk about
advanced record manipulation

00:01:27.956 --> 00:01:30.066
and different ways of saving
records to the server.

00:01:31.466 --> 00:01:34.276
We're going to go over how to
handle notifications reliably,

00:01:34.526 --> 00:01:36.156
if you miss a push, what to do.

00:01:37.666 --> 00:01:39.866
And finally, we're going to
go over the iCloud Dashboard

00:01:39.866 --> 00:01:41.456
which is a web-based interface

00:01:41.456 --> 00:01:43.126
for managing your
CloudKit application.

00:01:45.496 --> 00:01:47.246
So, let's start off by looking

00:01:47.246 --> 00:01:48.916
at the CloudKit API
really quick.

00:01:50.346 --> 00:01:53.606
We designed the CloudKit API
to be highly asynchronous.

00:01:53.606 --> 00:01:57.416
Everything has a callback,
nothing is synchronous.

00:01:57.486 --> 00:01:59.056
And we did this because all

00:01:59.056 --> 00:02:00.836
of these requests are
going out over the network.

00:02:01.316 --> 00:02:03.686
When you get the network
involved, anything can happen,

00:02:03.686 --> 00:02:06.446
you know, the server might
not be responding quickly,

00:02:06.446 --> 00:02:08.036
there might be a bad
network connection.

00:02:08.395 --> 00:02:11.736
We don't want to block the UI
and cause a bad user experience.

00:02:12.816 --> 00:02:16.036
And to help do this, we've used
NSOperation almost everywhere

00:02:16.036 --> 00:02:16.516
in our API.

00:02:17.576 --> 00:02:20.636
I say almost everywhere
because if you went

00:02:20.636 --> 00:02:21.986
to the introductory session,

00:02:21.986 --> 00:02:24.406
you remember seeing what we
called the Convenience API.

00:02:25.276 --> 00:02:29.086
And the Convenience API is our
way of helping you get started

00:02:29.086 --> 00:02:30.916
with CloudKit really
quickly and simply.

00:02:31.406 --> 00:02:35.046
All of these APIs are, you
know, single calls that work

00:02:35.046 --> 00:02:36.986
on one record at a time.

00:02:36.986 --> 00:02:39.116
So, in this case, we're
fetching one record

00:02:39.606 --> 00:02:41.076
and it's asynchronous.

00:02:41.076 --> 00:02:43.286
We get that one record back
in our completionHandler.

00:02:44.156 --> 00:02:46.496
But, as you use CloudKit
more, you might find

00:02:46.496 --> 00:02:48.026
that you need some
additional functionality.

00:02:48.676 --> 00:02:51.376
And that's where the
NSOperation-based API comes in.

00:02:52.066 --> 00:02:55.506
So, what we've got here is
the CKFetchRecordsOperation.

00:02:55.556 --> 00:02:58.696
And this is an NSOperation
that does the equivalent

00:02:58.696 --> 00:03:00.436
of that convenience
API we just saw.

00:03:01.136 --> 00:03:02.656
We give you a lot
more functionality

00:03:02.656 --> 00:03:04.996
when you use the
NSOperation-based API.

00:03:05.596 --> 00:03:09.316
So, you can see here that our
initializer takes an array

00:03:09.316 --> 00:03:09.876
of record IDs.

00:03:09.876 --> 00:03:13.046
You can fetch a whole batch
of records all at once.

00:03:14.286 --> 00:03:16.296
We also give you more
feedback on what's happening.

00:03:16.296 --> 00:03:18.886
We've got a completion
block for each record,

00:03:18.886 --> 00:03:20.326
and we also give you progress

00:03:20.326 --> 00:03:22.056
as we download those
records from the server.

00:03:22.646 --> 00:03:28.306
And finally, these operations
give you more knobs and levers

00:03:28.306 --> 00:03:32.196
to tweak what is returned
and what the operation does.

00:03:32.196 --> 00:03:34.816
In this case, we've got
a desiredKeys property

00:03:34.816 --> 00:03:36.916
that lets you specify
what key should come back

00:03:36.916 --> 00:03:40.436
on the records that you fetch.

00:03:40.656 --> 00:03:43.086
So, since all of this
is built on NSOperation,

00:03:43.086 --> 00:03:44.176
let's do a quick overview

00:03:44.176 --> 00:03:46.366
of what the NSOperation
class looks like.

00:03:47.466 --> 00:03:50.446
What we've got in NSOperation
is a completionBlock

00:03:50.446 --> 00:03:53.176
and a cancel call so that
you can manage the life cycle

00:03:53.176 --> 00:03:53.946
of your operation.

00:03:55.406 --> 00:03:56.586
We've got a couple of variables

00:03:56.586 --> 00:03:58.606
that tell you some state
about the operation.

00:03:59.756 --> 00:04:01.916
And NSOperations
have dependencies,

00:04:01.916 --> 00:04:04.376
so you can link two
NSOperations together.

00:04:06.956 --> 00:04:09.336
Once you have an NSOperation,
you're going to want to start

00:04:09.336 --> 00:04:11.566
that operation, and you
do that by adding it

00:04:11.566 --> 00:04:13.266
to an NSOperationQueue.

00:04:13.806 --> 00:04:16.276
When you have an
NSOperationQueue,

00:04:16.276 --> 00:04:19.276
you can also manage the life
cycle of that operation queue.

00:04:19.276 --> 00:04:21.156
You can suspend it
and resume it,

00:04:21.456 --> 00:04:23.826
and you can cancel
the operations in it.

00:04:26.156 --> 00:04:28.836
So, if you go to look at
our NSOperation-based API,

00:04:28.836 --> 00:04:30.906
you might just see this
big list of a bunch

00:04:30.906 --> 00:04:32.026
of different operations.

00:04:32.026 --> 00:04:33.896
It's kind of overwhelming
and confusing.

00:04:34.396 --> 00:04:36.796
The best way to think
about this API is to think

00:04:36.796 --> 00:04:38.736
about the objects that
you want to deal with.

00:04:39.236 --> 00:04:41.076
If you remember from
the introductory talk,

00:04:41.756 --> 00:04:44.936
CloudKits-based objects
are records and zones

00:04:44.936 --> 00:04:48.546
and subscriptions, and you'll
see that up here we have a fetch

00:04:48.546 --> 00:04:50.926
and a modify operation
for all of those items.

00:04:50.926 --> 00:04:57.476
One of the really cool
things about NSOperation is

00:04:57.476 --> 00:04:58.616
that is has dependencies.

00:04:58.616 --> 00:05:01.656
So, you can set a dependency
between two operations

00:05:02.226 --> 00:05:04.506
and the second operation
won't fire

00:05:04.506 --> 00:05:06.226
until the first operation
is completed.

00:05:06.786 --> 00:05:09.796
This is really handy
with CloudKit if you want

00:05:09.796 --> 00:05:13.146
to do something like fetch a
record, add a property to it,

00:05:13.146 --> 00:05:14.936
and save that record
back to the server.

00:05:15.576 --> 00:05:17.696
You can make the
FetchRecordsOperation,

00:05:17.856 --> 00:05:21.646
make the modify operation at the
same time, set up a dependency,

00:05:22.046 --> 00:05:24.046
and when the fetch completes,
you can put that data

00:05:24.046 --> 00:05:26.286
in the modify operation, and
it'll start automatically.

00:05:26.836 --> 00:05:30.786
These dependencies also
work between queues.

00:05:30.786 --> 00:05:34.566
So, even though CloudKit has
its own internal operation queue

00:05:34.566 --> 00:05:37.006
that you can use to run
operations, you're welcome

00:05:37.326 --> 00:05:39.486
to create your own
NSOperation queue,

00:05:39.856 --> 00:05:41.436
and you can then
manage its life cycle.

00:05:41.436 --> 00:05:47.716
You can stop operations or
suspend them or cancel them.

00:05:47.926 --> 00:05:51.326
One tip with using
NSOperation though is

00:05:51.326 --> 00:05:55.146
that the NSOperation-based class
has a completionBlock on it.

00:05:55.766 --> 00:05:56.926
This completionBlock ends

00:05:56.926 --> 00:05:59.496
up firing asynchronously
with dependencies.

00:05:59.496 --> 00:06:01.056
So, if you've set
up dependencies

00:06:01.096 --> 00:06:03.466
and you're using the
NSOperation's completion block,

00:06:03.916 --> 00:06:05.586
they might happen
at the same time,

00:06:05.996 --> 00:06:07.586
and that data you
were trying to funnel

00:06:07.586 --> 00:06:10.596
into the next operation won't
get there in time, you know,

00:06:10.596 --> 00:06:11.876
that operation has
already started.

00:06:12.576 --> 00:06:15.056
So, what we've done with
the CloudKit API is we have

00:06:15.106 --> 00:06:16.996
CloudKit-specific
completion blocks.

00:06:17.416 --> 00:06:21.316
And if we look at what we had
for that fetchRecords operation,

00:06:21.806 --> 00:06:23.766
we have a
fetchRecordsCompletionBlock.

00:06:24.456 --> 00:06:26.946
You'll see this pattern on
all of our NSOperations.

00:06:26.946 --> 00:06:29.366
And these completion
blocks hand back all

00:06:29.366 --> 00:06:30.906
of the information
you needed to know

00:06:30.906 --> 00:06:32.286
about the operation
that just ran.

00:06:32.806 --> 00:06:35.756
In this case, we've got the
errors for that operation,

00:06:35.756 --> 00:06:38.396
and we've also got the
records that were fetched.

00:06:40.466 --> 00:06:43.146
And finally, NSOperations can
have their own priorities.

00:06:43.146 --> 00:06:45.856
So, you can set background
operations and have them run

00:06:45.856 --> 00:06:48.656
at a really low priority
and keep your UI responsive.

00:06:49.066 --> 00:06:52.226
So, when we were
designing CloudKit,

00:06:52.306 --> 00:06:53.406
one of the things we noticed is

00:06:53.406 --> 00:06:55.546
that there's two general
classes of applications.

00:06:56.366 --> 00:06:59.816
There's one class of application
that stores a whole bunch

00:06:59.816 --> 00:07:02.836
of data up on the server, and
when you use the application,

00:07:02.836 --> 00:07:04.476
it's just presenting
the view of that data.

00:07:04.476 --> 00:07:07.556
It downloads it on demand,
displays it to the user,

00:07:07.556 --> 00:07:10.096
and then, you know,
tosses it out because it's,

00:07:10.096 --> 00:07:11.446
the real copy's on the server.

00:07:12.266 --> 00:07:13.866
But there's another
class of application

00:07:13.866 --> 00:07:16.346
that has just a little
bit of data, but you want

00:07:16.346 --> 00:07:18.376
that same data on
all of your clients.

00:07:19.706 --> 00:07:21.536
So, if you remember from
the introductory talk,

00:07:21.536 --> 00:07:24.446
we talked about what we
called Big Data, Little Phone.

00:07:24.446 --> 00:07:26.826
That's that case where we have
a lot of data on the server.

00:07:27.306 --> 00:07:30.156
It's not all going to fit on
one phone, and you download it

00:07:30.156 --> 00:07:31.196
and view it on demand.

00:07:31.456 --> 00:07:33.886
So, you can see these clients
are downloading records,

00:07:33.916 --> 00:07:37.156
viewing them, and the truth
lives up on the server.

00:07:38.716 --> 00:07:40.966
However, there's another
class of application,

00:07:41.626 --> 00:07:43.686
where it's a small
amount of data.

00:07:43.686 --> 00:07:46.816
It lives on one client, but you
want it on all your clients.

00:07:47.086 --> 00:07:48.986
An example of this
is an application

00:07:48.986 --> 00:07:50.076
that manages your receipts.

00:07:50.146 --> 00:07:53.836
So, every time you buy
something, you take a picture

00:07:53.836 --> 00:07:57.846
of the receipt, and you want
that information on your phone,

00:07:57.846 --> 00:08:00.746
in your iPad, in your Mac,
and you want them all to be

00:08:00.746 --> 00:08:02.306
up to date with the
same receipts.

00:08:05.716 --> 00:08:07.556
So, what we've done
to help you solve

00:08:07.556 --> 00:08:11.146
that is we've got something
in CloudKit that does that.

00:08:11.146 --> 00:08:13.946
If you remember, we have, every
application gets a container.

00:08:14.756 --> 00:08:17.146
In every container is a
public and private database.

00:08:18.016 --> 00:08:20.296
And just as a refresher,

00:08:20.296 --> 00:08:22.676
that private database is
actually one private database

00:08:22.676 --> 00:08:23.476
for every user.

00:08:26.156 --> 00:08:27.516
Inside of those databases,

00:08:27.516 --> 00:08:29.196
we then subdivide
them down into zones.

00:08:29.316 --> 00:08:32.706
So, both the public and the
private database have a default

00:08:32.736 --> 00:08:33.265
zone in them.

00:08:34.426 --> 00:08:37.275
But we've also given you
what we call custom zones,

00:08:37.275 --> 00:08:40.486
and these custom zones allow us
to give you some extra features

00:08:40.486 --> 00:08:42.816
that we can't provide
in the default zones.

00:08:44.536 --> 00:08:47.786
You can create these custom
zones and use the new features.

00:08:47.846 --> 00:08:50.556
Let's go over a couple of them.

00:08:50.756 --> 00:08:53.246
The first feature
is atomic commits.

00:08:54.516 --> 00:08:57.286
So, CloudKit has
relationships between records.

00:08:57.286 --> 00:09:00.596
And if you start using CloudKit
and using these relationships,

00:09:00.596 --> 00:09:03.476
you're going to build up an
object graph, and you're going

00:09:03.476 --> 00:09:06.966
to realize you want
consistency in your data.

00:09:06.966 --> 00:09:09.466
If, you know, you might have
an object graph that you want

00:09:09.466 --> 00:09:10.556
to commit all at once.

00:09:10.586 --> 00:09:13.186
And if some of those
things don't get committed,

00:09:13.186 --> 00:09:15.996
the data on the server
doesn't make sense.

00:09:16.296 --> 00:09:18.296
On the public database,
we can't guarantee

00:09:18.296 --> 00:09:20.616
that because there might
be thousands or millions

00:09:20.616 --> 00:09:22.246
of users hitting
the same database.

00:09:22.246 --> 00:09:25.496
So, there's no way to lock the
database while we, you know,

00:09:25.496 --> 00:09:27.106
commit your very
special records.

00:09:27.916 --> 00:09:31.416
But in the private database,
you only have one user.

00:09:31.416 --> 00:09:33.156
It's the current user's account.

00:09:33.196 --> 00:09:40.506
And in that case, we can provide
you things like atomic commits.

00:09:40.586 --> 00:09:43.176
So, with atomic commits,
these batch operations

00:09:43.206 --> 00:09:46.726
in the NSOperation API will
succeed or fail as a whole.

00:09:47.106 --> 00:09:49.216
So, if any record had a problem,

00:09:49.926 --> 00:09:52.886
you will get back a
CKErrorPartialFailure.

00:09:54.546 --> 00:09:56.846
Inside of that partial
failure error, you're going

00:09:56.846 --> 00:09:59.526
to see a user, the
userInfo dictionary is going

00:09:59.576 --> 00:10:02.246
to have this
CKPartialErrorsByItemID key.

00:10:03.386 --> 00:10:05.796
And that's going to be a
dictionary of record IDs

00:10:06.306 --> 00:10:08.336
to errors for each
of those records.

00:10:09.116 --> 00:10:10.556
And some of those
errors are going

00:10:10.556 --> 00:10:12.416
to be the real failures
that you care about.

00:10:12.476 --> 00:10:14.636
These are the reasons that
the atomic commit failed.

00:10:15.376 --> 00:10:17.486
But, you know, the rest
of the records failed

00:10:17.486 --> 00:10:19.726
because it was atomic commit,
and we need to let you know

00:10:19.726 --> 00:10:21.476
that they failed,
so you're also going

00:10:21.556 --> 00:10:23.576
to see
CKErrorBatchRequestFailed.

00:10:24.306 --> 00:10:26.006
That's just a way of
saying that something else

00:10:26.006 --> 00:10:27.816
in this batch failed,
and, you know,

00:10:27.816 --> 00:10:32.726
this wasn't the real problem, it
was that other record in here.

00:10:32.946 --> 00:10:34.466
Another great feature
that we give you

00:10:34.466 --> 00:10:36.566
with custom zones
are delta downloads.

00:10:37.946 --> 00:10:40.656
So, delta downloads are a
way for that second class

00:10:40.656 --> 00:10:43.586
of application to be
possible in CloudKit.

00:10:43.966 --> 00:10:46.456
You can download only the
changes that were made

00:10:46.456 --> 00:10:48.996
in that zone, and you can
cache them all locally.

00:10:48.996 --> 00:10:51.926
So, what does that look like?

00:10:52.236 --> 00:10:55.306
Well, we've got our Mac here,
and we've got our iPhone,

00:10:55.736 --> 00:10:57.126
and we've got a custom zone.

00:10:57.936 --> 00:11:00.096
So, let's step through a
delta download really quick.

00:11:00.896 --> 00:11:02.966
We've got an orange
record and a green record

00:11:02.966 --> 00:11:05.496
over on the Mac here, and we
want them on the phone as well.

00:11:05.856 --> 00:11:08.346
So, we're going to first
upload those both into CloudKit

00:11:08.346 --> 00:11:12.346
in our custom zone, and
then our iPhone is going

00:11:12.346 --> 00:11:15.946
to perform a delta
download to get up to date.

00:11:17.456 --> 00:11:19.396
So, these delta downloads
are based

00:11:19.396 --> 00:11:20.836
on what we call change tokens.

00:11:20.836 --> 00:11:23.406
And a change token is a
way of tracking the state

00:11:23.406 --> 00:11:25.226
of the server the last
time you talked to it.

00:11:26.176 --> 00:11:28.256
So, this phone has never
talked to the server,

00:11:28.726 --> 00:11:31.536
and what it's going to do is
send up a nil change token.

00:11:31.536 --> 00:11:33.466
And that's a way of saying,
"I've never talked to you,

00:11:33.466 --> 00:11:35.216
just send me all the
records in the zone."

00:11:36.106 --> 00:11:38.176
So, the server is the going
to take that nil change token,

00:11:38.936 --> 00:11:41.376
send down an, the orange
record and green record.

00:11:41.876 --> 00:11:44.056
The phone is going to save
them into its local database.

00:11:44.646 --> 00:11:47.106
And then the server is going to
send down a new change token.

00:11:47.556 --> 00:11:50.466
In this case, it's change
token A, and that means that,

00:11:50.466 --> 00:11:53.566
you know, the records you
have are all from state A.

00:11:53.566 --> 00:11:56.766
If the phone came back
again with change tag A,

00:11:56.766 --> 00:11:58.296
the server will go, "Well,
I don't have anything

00:11:58.296 --> 00:11:59.856
for you, A is good enough.

00:11:59.986 --> 00:12:00.916
There's nothing to download."

00:12:01.446 --> 00:12:05.796
But let's say the Mac
comes along and it creates

00:12:05.796 --> 00:12:08.386
that purple record, and it
deletes the green record.

00:12:08.626 --> 00:12:10.736
And it uploads those
changes to the server.

00:12:11.716 --> 00:12:14.076
The server is going to track
the changes, so it'll note

00:12:14.076 --> 00:12:15.476
that that green record
was deleted.

00:12:15.556 --> 00:12:17.346
It'll note that there's
a new purple record.

00:12:18.106 --> 00:12:20.566
And now, when the iPhone
comes back with change tag A,

00:12:21.106 --> 00:12:23.786
the server goes, "All right,
well, we're are at B now.

00:12:24.186 --> 00:12:25.086
That's farther than A.

00:12:25.916 --> 00:12:27.336
Here's a delete of
the green record

00:12:27.336 --> 00:12:30.136
and here's a new purple record
that happened while, you know,

00:12:30.136 --> 00:12:31.286
since the last time we talked."

00:12:32.686 --> 00:12:34.696
Then it sends back
that new change token

00:12:34.986 --> 00:12:37.026
and everyone is up to date.

00:12:38.356 --> 00:12:40.526
So, you can use this
delta download

00:12:40.526 --> 00:12:43.016
to implement an offline
cache in your application.

00:12:43.736 --> 00:12:46.146
If you want to do
that, there's a couple

00:12:46.146 --> 00:12:47.156
of steps your app
should to take.

00:12:47.156 --> 00:12:49.936
This is kind of an outline
of a basic state machine

00:12:49.936 --> 00:12:52.196
for every time you talk
to the server and you want

00:12:52.196 --> 00:12:53.146
to do a delta download.

00:12:54.556 --> 00:12:56.776
The first thing you're going
to want to do in your app is

00:12:56.846 --> 00:12:58.456
to track the local changes.

00:12:58.916 --> 00:13:00.716
You're going to want
to make a change table,

00:13:01.286 --> 00:13:03.966
and every time the user makes
an edit in your application,

00:13:03.966 --> 00:13:04.916
you want to write that down.

00:13:04.916 --> 00:13:07.766
You're going to want to do this
because you might be offline

00:13:07.766 --> 00:13:10.266
when the user makes the changes,
and you're going to need

00:13:10.266 --> 00:13:12.496
to replay all those
changes back to the server

00:13:12.496 --> 00:13:14.106
when you can talk to it.

00:13:16.116 --> 00:13:17.166
Then, you're going to need

00:13:17.166 --> 00:13:19.046
to send all those
changes up to the server.

00:13:19.046 --> 00:13:21.006
You want to do that before
you fetch the changes

00:13:21.056 --> 00:13:23.666
because someone else might
have changed the record

00:13:23.666 --> 00:13:26.356
in the meantime, and you need
to resolve these conflicts.

00:13:27.606 --> 00:13:29.776
So, we'll go over conflict
handling in just a little bit,

00:13:29.866 --> 00:13:31.196
but just keep in mind

00:13:31.196 --> 00:13:33.186
that that's an important
step in this process here.

00:13:34.666 --> 00:13:37.086
Finally, you're ready to
do the delta download.

00:13:37.086 --> 00:13:38.146
This is the point
where you're going

00:13:38.146 --> 00:13:40.526
to call
CKFetchRecordChangesOperation.

00:13:41.666 --> 00:13:45.576
The server is going to send
you back updates and deletes

00:13:45.576 --> 00:13:48.766
and modifies and adds of
records, and you're going

00:13:48.766 --> 00:13:50.496
to save those into
your local database.

00:13:51.696 --> 00:13:53.016
Finally, the server is going

00:13:53.016 --> 00:13:54.646
to send you back a
new change token.

00:13:54.716 --> 00:13:56.396
And that's the change
token you want to save

00:13:56.396 --> 00:13:58.296
so that the next time
you talk to the server,

00:13:58.746 --> 00:13:59.916
you can get only the records

00:13:59.916 --> 00:14:01.646
that have changed
and not everything.

00:14:04.476 --> 00:14:07.296
So, one of the other features
we give you with custom zones

00:14:07.296 --> 00:14:09.346
and delta downloads
are zone subscriptions.

00:14:09.346 --> 00:14:12.956
In the case of that state
machine I just talked about,

00:14:13.276 --> 00:14:16.376
you could pull every, you
know, 10 minutes or 5 minutes

00:14:16.376 --> 00:14:18.466
or whatever and hope that
there are changes up there.

00:14:19.136 --> 00:14:21.256
But wouldn't it be great if
the server just told you,

00:14:21.256 --> 00:14:22.226
"Hey, I've got changes.

00:14:22.226 --> 00:14:23.356
It's time for delta download."

00:14:23.946 --> 00:14:24.816
Well, we give you that.

00:14:24.886 --> 00:14:27.296
We give you what we
call zone subscriptions.

00:14:27.766 --> 00:14:29.646
These look like query
subscriptions,

00:14:29.706 --> 00:14:30.826
but they're a little
bit different.

00:14:31.586 --> 00:14:34.746
What they do is every
time something changes

00:14:34.746 --> 00:14:37.336
in a custom zone, you'll
get a push notification.

00:14:38.076 --> 00:14:39.556
When you see that
push notification,

00:14:39.556 --> 00:14:42.056
you know you should go do a
delta download with the server,

00:14:42.366 --> 00:14:43.456
and you'll get new records.

00:14:43.536 --> 00:14:50.696
So, a couple of notes on
designing custom zones

00:14:50.696 --> 00:14:51.716
and when you should use them.

00:14:52.956 --> 00:14:56.206
These custom zones are meant
to compartmentalize your data.

00:14:56.656 --> 00:14:59.696
Because of that, there's a
couple of restrictions on them.

00:14:59.696 --> 00:15:02.416
The first is that you can't
move records between zones.

00:15:03.226 --> 00:15:05.096
You can pick these
records up and copy them

00:15:05.096 --> 00:15:09.806
and make a new copy in the new
zone, but you can't move them.

00:15:09.806 --> 00:15:12.676
You also can't make
any cross-zone delete

00:15:12.676 --> 00:15:13.916
self relationships.

00:15:14.006 --> 00:15:17.656
So, you have to think of
these zones as self-contained.

00:15:17.656 --> 00:15:20.096
If you have records that need to
go across zones, you might want

00:15:20.096 --> 00:15:21.086
to rethink your model.

00:15:23.696 --> 00:15:26.306
And finally, these zones
determine the level of updates.

00:15:26.306 --> 00:15:28.476
If you're using a zone
subscription, you're going

00:15:28.476 --> 00:15:30.976
to get a push every single
time something has changed

00:15:30.976 --> 00:15:31.526
in that zone.

00:15:31.526 --> 00:15:36.006
If you have a lot of data on
the server and you only care

00:15:36.006 --> 00:15:38.196
about getting updates for
one part of that data,

00:15:38.196 --> 00:15:41.486
you might want to make that a
zone so that you can ignore the,

00:15:41.486 --> 00:15:43.956
you know, really busy
stuff going on over here

00:15:43.956 --> 00:15:51.236
and just download the
things you care about.

00:15:52.276 --> 00:15:54.776
So, let's talk about some
advanced record operations.

00:15:55.826 --> 00:15:59.266
When you're using CKRecord,
any changes you make

00:15:59.266 --> 00:16:03.676
to a CKRecord object locally get
tracked, and then when we talk

00:16:03.676 --> 00:16:06.076
to the server, we're only
going to send the changes

00:16:06.076 --> 00:16:07.466
that you made to that CKRecord.

00:16:08.636 --> 00:16:10.926
This is the default behavior,
and it works great most

00:16:10.926 --> 00:16:14.286
of the time, but you might
want some additional control

00:16:14.286 --> 00:16:15.906
over what we're sending
to the server.

00:16:16.666 --> 00:16:18.606
And we give you that
with save policies.

00:16:19.846 --> 00:16:23.156
So, these save policies,
we have three of them.

00:16:23.276 --> 00:16:25.226
They're
CKRecordSaveIfServerUnchanged.

00:16:26.266 --> 00:16:32.046
We have CKRecordSaveChangedKeys,
and we have CKRecordSaveAllKeys.

00:16:34.236 --> 00:16:37.186
So, let's look at the
differences between those.

00:16:38.236 --> 00:16:42.336
The biggest difference is
what they determine for a,

00:16:42.376 --> 00:16:43.866
what I'm going to
call a locked save.

00:16:44.636 --> 00:16:46.856
And a locked save is
a way of making sure

00:16:46.856 --> 00:16:48.646
that you don't overwrite
data on the server

00:16:48.646 --> 00:16:50.716
that someone else
has already written.

00:16:50.716 --> 00:16:52.156
When you perform a locked save,

00:16:52.156 --> 00:16:56.576
it says that if the record has
changed since-on the server

00:16:56.576 --> 00:16:57.736
since the time you fetched it,

00:16:58.206 --> 00:17:00.336
the server will give you an
error saying your record is

00:17:00.336 --> 00:17:03.466
out of date, you need to resolve
this conflict and try again.

00:17:04.596 --> 00:17:09.816
So, the only thing that performs
a locked save here is CKRecord

00:17:09.816 --> 00:17:12.086
save policy
SaveIfServerUnchanged.

00:17:12.786 --> 00:17:16.076
The other two actually force
these changes to the server.

00:17:16.076 --> 00:17:17.336
So, SaveChangedKeys

00:17:17.336 --> 00:17:20.386
and SaveAllKeys always overwrite
the values on the server.

00:17:22.435 --> 00:17:25.626
These policies also determine
how much data we're sending

00:17:25.626 --> 00:17:26.106
to the server.

00:17:27.546 --> 00:17:29.756
In the case of
SaveIfServerUnchanged

00:17:29.816 --> 00:17:34.286
and SaveChangedKeys, we're only
going to send up the, sorry,

00:17:34.286 --> 00:17:35.626
we're only going to
send up the values

00:17:35.626 --> 00:17:37.466
on the record that have changed.

00:17:38.036 --> 00:17:39.386
In the case of SaveAllKeys,

00:17:39.386 --> 00:17:41.686
we're going to send the
entire record, all the values,

00:17:41.746 --> 00:17:43.726
whether you've changed
them or not.

00:17:45.216 --> 00:17:48.486
So, back to locked updates.

00:17:48.486 --> 00:17:50.676
We've got this thing
called locking,

00:17:50.676 --> 00:17:53.526
and if you don't use it,
here's what could go wrong

00:17:53.526 --> 00:17:54.526
with an unlocked update.

00:17:54.676 --> 00:17:57.026
Right now, we've got
this contact card.

00:17:57.076 --> 00:17:59.456
We've got the same name,
first name, last name,

00:17:59.456 --> 00:18:02.496
picture on two clients,
and in iCloud.

00:18:02.496 --> 00:18:03.626
Everything is good right now.

00:18:04.526 --> 00:18:07.466
But let's say the iPhone
changes that contact completely.

00:18:07.466 --> 00:18:10.136
So it modifies the picture,
it modifies the first name,

00:18:10.136 --> 00:18:11.476
and it modifies the last name.

00:18:12.436 --> 00:18:15.296
Well, it's going to perform a
SaveChangedKeys to the server,

00:18:15.616 --> 00:18:17.806
which is going to send up
the things that have changed,

00:18:18.156 --> 00:18:20.286
and that's going to overwrite
whatever is on the server.

00:18:20.286 --> 00:18:25.536
Next, before the Mac gets a
chance to download that record,

00:18:25.536 --> 00:18:26.896
the user edited the first name

00:18:26.896 --> 00:18:28.466
of that record and
just changed it.

00:18:29.496 --> 00:18:33.456
And that Mac then sends- does a
SaveChangedKeys with the server,

00:18:34.156 --> 00:18:36.496
and it sent up just the
property that was modified.

00:18:37.176 --> 00:18:40.556
And now, we've got a problem
here, oops, we've got a problem.

00:18:40.556 --> 00:18:44.206
This contact record isn't
what either the clients meant

00:18:44.206 --> 00:18:45.036
to have.

00:18:45.866 --> 00:18:49.096
So, to work around this,
we have locked updates.

00:18:49.736 --> 00:18:52.346
And locked updates are
a way of making sure

00:18:52.346 --> 00:18:55.376
that the server knows that
you're updating the same values

00:18:55.446 --> 00:18:56.536
that are already on the server.

00:18:57.376 --> 00:18:58.836
And we do this with
a change tag.

00:18:59.266 --> 00:19:01.606
So, the change tag is a
property on the record

00:19:02.286 --> 00:19:05.976
that necessarily changes anytime
a value in the record changes.

00:19:06.626 --> 00:19:09.416
In this case, we've got change
tag A both on the server

00:19:09.416 --> 00:19:12.926
and locally, and so we know that
they both have the same values.

00:19:13.796 --> 00:19:17.396
If we go and we add a new
property on the local record,

00:19:18.296 --> 00:19:21.256
when we save that to the server
using the default save policy,

00:19:21.366 --> 00:19:23.356
it's going to send up
both the change tag

00:19:23.946 --> 00:19:25.476
and the property that changed.

00:19:26.866 --> 00:19:29.096
The servers then,
before it does anything,

00:19:29.096 --> 00:19:30.756
it's going to check
the two change tags,

00:19:31.216 --> 00:19:34.296
and if they're equal, it'll
apply the change that you made.

00:19:34.996 --> 00:19:40.096
If on the other hand we have
another client that, oh, sorry,

00:19:40.096 --> 00:19:43.056
and then the server is going
to send back a new change tag

00:19:43.086 --> 00:19:44.586
because we did change
a property.

00:19:45.586 --> 00:19:49.386
We return this new record to
you with the updated change tag

00:19:49.386 --> 00:19:50.576
in the completion block.

00:19:50.576 --> 00:19:53.716
So, if you take the record that
we gave you at the end of a save

00:19:54.286 --> 00:19:56.836
and you do all your subsequent
modifications on that,

00:19:57.316 --> 00:19:59.136
you'll be using the
updated change token,

00:19:59.166 --> 00:20:01.586
and you shouldn't have any
conflicts with the server.

00:20:03.716 --> 00:20:05.656
Now, let's say we had
another client that, you know,

00:20:05.656 --> 00:20:07.896
hadn't seen that change and
he was still at version A.

00:20:08.556 --> 00:20:10.506
And he decides to add
a different property

00:20:10.506 --> 00:20:11.036
on the record.

00:20:11.766 --> 00:20:13.996
Well, he's going to save it to
the server, he's going to send

00:20:13.996 --> 00:20:16.716
up the change tag and
the modified property,

00:20:17.416 --> 00:20:19.476
and the server is going
to realize that, hey,

00:20:19.476 --> 00:20:20.836
those two values
aren't the same.

00:20:21.626 --> 00:20:24.266
And the client is going to
get back an error saying,

00:20:24.266 --> 00:20:25.286
you know, you have a conflict.

00:20:26.496 --> 00:20:28.146
So, how do we handle
these conflicts?

00:20:29.876 --> 00:20:32.976
Well, if you run into this
case of a locked save failing,

00:20:33.456 --> 00:20:36.616
you're going to get an error
that CKErrorServerRecordChanged.

00:20:37.236 --> 00:20:39.726
And because you guys all
went to the introductory talk

00:20:39.726 --> 00:20:42.206
and you learned about how
great error handling is

00:20:42.206 --> 00:20:43.076
and how important it is,

00:20:43.076 --> 00:20:46.226
you've got some fantastic error
handling here, and it's going

00:20:46.226 --> 00:20:48.676
to check for
CKErrorServerRecordChanged.

00:20:49.946 --> 00:20:52.656
When you see that, you know that
you're out of date, you're going

00:20:52.656 --> 00:20:54.236
to need to get the new
record from the server.

00:20:54.506 --> 00:20:56.296
You're going to need to
take your local changes,

00:20:56.296 --> 00:20:58.506
apply them to that record
and try to save again.

00:20:59.566 --> 00:21:01.066
And we've already
anticipated that.

00:21:01.156 --> 00:21:03.596
So, what we're going to do
is help you out a little bit,

00:21:03.596 --> 00:21:06.366
and we're going to return
those records to you already

00:21:06.416 --> 00:21:09.386
because we know that's the
next logical thing to do.

00:21:10.096 --> 00:21:12.686
So, inside of the userInfo
dictionary of this error,

00:21:12.806 --> 00:21:14.526
you're going to find three
copies of the record.

00:21:15.826 --> 00:21:18.176
You're going to find the record
that you attempted to save

00:21:18.176 --> 00:21:20.866
to the server, the one
that encountered the error.

00:21:22.116 --> 00:21:23.536
You're going to find
the original copy

00:21:23.536 --> 00:21:26.736
of the local record, which
is the copy we downloaded

00:21:26.736 --> 00:21:28.696
from the server before
you made any changes.

00:21:29.816 --> 00:21:32.126
And finally, we're going to
give you the server record back.

00:21:32.276 --> 00:21:34.006
This is the copy of the
record with the most

00:21:34.006 --> 00:21:36.906
up to date change tag.

00:21:37.086 --> 00:21:40.216
You're going to want to figure
out what makes sense out of all

00:21:40.216 --> 00:21:42.196
of those copies of
values and keys.

00:21:42.766 --> 00:21:44.746
You're going to apply them
all to the server version

00:21:44.746 --> 00:21:50.326
of the record, and then you're
going to retry that save.

00:21:50.526 --> 00:21:52.186
So, you might be wondering
at this point, you know,

00:21:52.186 --> 00:21:55.006
what type of save
policy should you use?

00:21:55.476 --> 00:21:57.286
And the simple answer to that is

00:21:57.286 --> 00:22:00.846
that you should just always
use CKRecordSaveIfUnchanged,

00:22:01.436 --> 00:22:02.686
and it's the default.

00:22:02.686 --> 00:22:03.936
It's the default for a reason,

00:22:04.006 --> 00:22:05.896
and that's because
it's the safest.

00:22:06.086 --> 00:22:08.816
If you remember that example
of an unlocked update gone bad,

00:22:09.486 --> 00:22:11.676
you could end up with really
mixed-up, corrupt data

00:22:11.676 --> 00:22:13.626
on the server if you're
not using locking.

00:22:15.196 --> 00:22:17.446
However, there is
always a time and place

00:22:17.446 --> 00:22:19.226
for using unlocked updates.

00:22:19.816 --> 00:22:23.226
And the biggest case for these
are highly contentious updates.

00:22:23.746 --> 00:22:25.676
If you're doing anything
in the public database,

00:22:25.676 --> 00:22:27.886
you might have hundreds
or thousands or millions

00:22:27.886 --> 00:22:29.866
of clients accessing
it at the same time.

00:22:30.766 --> 00:22:33.706
And if every one of those
clients is trying to save if,

00:22:34.226 --> 00:22:36.706
save the same record and
you're locking on that,

00:22:37.616 --> 00:22:39.696
most of those clients are going
to be hitting locking errors,

00:22:39.736 --> 00:22:41.676
they're going to hit
conflicts, and they're going

00:22:41.676 --> 00:22:43.116
to be retrying really
frequently.

00:22:43.976 --> 00:22:46.456
So, if you know this is going to
be a really contentious update,

00:22:46.996 --> 00:22:50.096
you can structure your client
to do unlocked updates as long

00:22:50.096 --> 00:22:52.496
as you know you're always
writing consistent properties.

00:22:53.286 --> 00:22:55.636
On the case of that unlocked
update that failed, you know,

00:22:55.636 --> 00:22:57.786
you could make sure you
always write both the first

00:22:57.786 --> 00:23:00.196
and last name, and you
know it'll be consistent.

00:23:02.176 --> 00:23:05.956
The other reason to use an
unlocked update in the case

00:23:06.056 --> 00:23:07.666
of SaveAllKeys would
be if you want

00:23:07.696 --> 00:23:08.976
to force something
to the server.

00:23:09.086 --> 00:23:11.816
The client might say, you know,
the copy on the server is bad,

00:23:11.816 --> 00:23:13.716
but I know I have a good
copy of the record here.

00:23:14.296 --> 00:23:18.376
I want to just force that all
on top of the server's copy.

00:23:19.836 --> 00:23:23.566
There are some catches
to using SaveAllKeys,

00:23:23.606 --> 00:23:27.846
and one of the problems is
that any property on the server

00:23:28.406 --> 00:23:30.846
that doesn't exist in the
local record that you're trying

00:23:30.846 --> 00:23:32.276
to save isn't going

00:23:32.276 --> 00:23:36.116
to get removed unless
you explicitly remove

00:23:36.116 --> 00:23:37.676
that property on the record.

00:23:38.496 --> 00:23:41.536
All those words are
really confusing,

00:23:41.616 --> 00:23:43.006
and it's really hard to explain.

00:23:43.006 --> 00:23:44.346
So instead, I'm going
to try and explain

00:23:44.346 --> 00:23:45.266
that with the picture here.

00:23:46.376 --> 00:23:48.346
So, we've got our
contact record again.

00:23:48.436 --> 00:23:51.086
What we're going to do is
add a couple of properties.

00:23:51.086 --> 00:23:52.386
We're going to change
the first name,

00:23:52.386 --> 00:23:53.556
we're going to add
a new property,

00:23:54.006 --> 00:23:55.346
and we're going to
delete the hobby.

00:23:56.786 --> 00:23:59.756
We're now going to do a
SaveAllKeys to the server.

00:24:01.306 --> 00:24:04.316
What that's going to do is send
up all of these properties,

00:24:04.846 --> 00:24:07.986
even the ones we didn't change
locally, and they're going

00:24:07.986 --> 00:24:09.516
to update the values
on the server.

00:24:10.216 --> 00:24:12.026
But what you'll notice here is

00:24:12.026 --> 00:24:14.016
that the server had
an additional property

00:24:14.016 --> 00:24:17.446
that we didn't have in our
original copy of the record.

00:24:17.446 --> 00:24:19.406
This hometown property
wasn't removed.

00:24:20.736 --> 00:24:23.756
We do this to help you with
versioning of your app.

00:24:24.046 --> 00:24:28.156
You might release a version 2
of your app that adds hometowns

00:24:28.216 --> 00:24:30.386
but version 1 didn't ever
know about the hometown.

00:24:30.926 --> 00:24:33.506
And if version 1 was
using SaveAllKeys,

00:24:33.926 --> 00:24:35.966
it's going to overwrite these
properties on the server

00:24:35.966 --> 00:24:38.766
that it never knew about, and
that's kind of a bad thing.

00:24:38.766 --> 00:24:42.086
You can't have backwards
compatible code easily that way.

00:24:43.386 --> 00:24:46.406
So, what we do instead is we
still allow you to remove that,

00:24:46.496 --> 00:24:48.936
but you need to explicitly
tell us that you want

00:24:48.936 --> 00:24:50.416
that property deleted
on the server.

00:24:51.216 --> 00:24:53.376
So, even though there's
no hometown property

00:24:53.376 --> 00:24:57.696
on this record, we can still
call CKRecordSetValueForKey nil

00:24:58.066 --> 00:25:00.246
or we can call
removeObjectForKey.

00:25:01.246 --> 00:25:02.466
We're going to remove
the hometown,

00:25:02.466 --> 00:25:04.246
and now when we save
it up to the server,

00:25:04.526 --> 00:25:08.996
that delete will also
go up with the save.

00:25:09.146 --> 00:25:12.646
Finally, one of the really
neat things about CKRecord is

00:25:12.646 --> 00:25:14.346
that we allow you to
have partial records.

00:25:15.126 --> 00:25:17.736
So, you might have a really
big record on the server,

00:25:17.736 --> 00:25:20.056
and you only care about one
or two properties of that.

00:25:20.736 --> 00:25:23.346
Well, with the desiredKeys
property, we allow you

00:25:23.346 --> 00:25:26.306
to fetch just a certain
subset of the properties

00:25:26.306 --> 00:25:27.216
that are on the server.

00:25:28.546 --> 00:25:32.406
And we expose this desiredKeys
property on any operation

00:25:32.406 --> 00:25:34.116
that fetches a record,
so you're going to see it

00:25:34.116 --> 00:25:37.956
on CKFetchRecordsOperation,
CKQueryOperation,

00:25:37.956 --> 00:25:40.476
and
CKFetchRecordChangesOperation.

00:25:42.146 --> 00:25:43.346
And the really neat thing

00:25:43.346 --> 00:25:46.006
about this is you can then
take these partial records

00:25:46.006 --> 00:25:47.636
and save them back
up to the server.

00:25:47.716 --> 00:25:50.316
You don't need to work
with entirely full records.

00:25:50.856 --> 00:25:53.096
You can, you know, if you
want to update just one value

00:25:53.096 --> 00:25:55.676
on a record, fetch that
one value from the record,

00:25:55.796 --> 00:25:58.206
update it, and do a
save of just that record

00:25:58.206 --> 00:25:59.186
that has that one value.

00:25:59.836 --> 00:26:01.956
If you're doing this
with locking enabled,

00:26:02.306 --> 00:26:05.266
you know it's safe because
if the record is changed

00:26:05.266 --> 00:26:13.216
on the server since then,
you're going to get a conflict.

00:26:13.436 --> 00:26:14.736
So now, let's talk a little bit

00:26:14.736 --> 00:26:16.626
about modeling your
data for CloudKit.

00:26:17.976 --> 00:26:20.446
If we go back to that
example of a Receipts app,

00:26:20.796 --> 00:26:23.926
let's say we have a shoebox
that holds all our receipts

00:26:24.456 --> 00:26:27.126
and that's going to be
one object in the cloud,

00:26:27.596 --> 00:26:28.766
and we're going to
have an object

00:26:28.766 --> 00:26:29.946
for each one of our receipts.

00:26:31.036 --> 00:26:34.586
And the initial way you might
design this is you create a

00:26:34.586 --> 00:26:36.456
receipts array inside
of your shoebox,

00:26:37.156 --> 00:26:39.596
and every time you add a
new receipt, you're going

00:26:39.596 --> 00:26:42.576
to add new entry to that
array and that entry is going

00:26:42.576 --> 00:26:44.626
to be a reference to the
record you just created.

00:26:45.376 --> 00:26:47.136
We call these forward
references.

00:26:47.136 --> 00:26:49.636
These are references from
a parent to its child.

00:26:50.666 --> 00:26:52.086
And the problem with
these is that you end

00:26:52.086 --> 00:26:54.046
up getting bottlenecked
on that receipts array.

00:26:54.046 --> 00:26:57.746
If this was a public database,
you might have hundreds

00:26:57.746 --> 00:26:59.606
of clients trying to
save this record at once.

00:27:00.386 --> 00:27:03.166
And every time a client
tries to add a new record,

00:27:03.866 --> 00:27:06.616
they need to update that
array on the shoebox,

00:27:06.816 --> 00:27:08.976
and even though the clients
might be adding different

00:27:08.976 --> 00:27:13.216
records, different receipts,
they're all going to run

00:27:13.266 --> 00:27:16.376
into conflicts on the shoebox
app, or on the shoebox record.

00:27:17.146 --> 00:27:20.106
So, we recommend that you try
and avoid forward references

00:27:20.106 --> 00:27:24.496
in your design, and instead, use
what we call back references.

00:27:25.056 --> 00:27:26.886
So, instead of having
the shoebox point

00:27:26.886 --> 00:27:29.736
at the receipt that's in
it, have the receipt point

00:27:29.736 --> 00:27:30.906
at the shoebox that it's in.

00:27:32.506 --> 00:27:35.566
The great thing about this
is it's very scalable.

00:27:35.566 --> 00:27:39.376
You can have millions of clients
adding receipts all at once,

00:27:39.476 --> 00:27:40.586
and there's no bottleneck.

00:27:40.586 --> 00:27:42.956
They can create their receipt,
point at who owns them,

00:27:43.596 --> 00:27:47.296
and none of them are going
to run into conflicts.

00:27:47.296 --> 00:27:49.476
When you need to go get
everything that's in a shoebox,

00:27:49.476 --> 00:27:51.706
rather than fetching that
shoebox, getting the array

00:27:51.706 --> 00:27:54.186
of records in it, and
fetching all those records,

00:27:54.646 --> 00:27:56.186
you can instead just
use a query.

00:27:56.976 --> 00:27:59.636
That query is going to select
all of the records that have

00:27:59.636 --> 00:28:04.446
that shoebox as an owner.

00:28:04.446 --> 00:28:05.696
One other neat feature
we give you

00:28:05.696 --> 00:28:08.416
with the relationships
are cascading deletes.

00:28:09.116 --> 00:28:10.866
So, cascading deletes
are a way for you

00:28:10.866 --> 00:28:14.656
to make your object graph
get cleaned up automatically,

00:28:15.356 --> 00:28:17.556
and you do this by
marking your references

00:28:17.596 --> 00:28:20.356
with a
CKReferenceActionDeleteSelf,

00:28:21.036 --> 00:28:23.636
and that means that
when the record

00:28:23.636 --> 00:28:26.586
that you referenced is deleted,
you will also be deleted.

00:28:26.826 --> 00:28:28.616
In this case, the
green record has

00:28:28.676 --> 00:28:30.946
that reference action
pointed in the orange record.

00:28:31.646 --> 00:28:32.976
When the orange record
gets deleted,

00:28:33.476 --> 00:28:34.356
the green record is going

00:28:34.356 --> 00:28:36.266
to get automatically
deleted by the server.

00:28:38.016 --> 00:28:39.836
These deletes also cascade.

00:28:39.976 --> 00:28:42.556
So, if we had a whole
tree of objects hang off

00:28:42.556 --> 00:28:45.236
of that one orange record,
those deletes are going

00:28:45.236 --> 00:28:49.806
to cascade all the way down
and clean up our graph for us.

00:28:54.496 --> 00:28:56.076
But one thing to keep in mind

00:28:56.076 --> 00:28:57.986
with these delete
self references is

00:28:57.986 --> 00:29:00.216
that they're not
reference counted.

00:29:00.216 --> 00:29:03.606
That means that if you have
multiple references coming

00:29:03.606 --> 00:29:05.666
out of one record, the first one

00:29:05.666 --> 00:29:12.076
of those records that's deleted
will cause you to get deleted.

00:29:12.166 --> 00:29:16.436
And finally, these delete
self references give you one

00:29:16.436 --> 00:29:17.256
additional feature.

00:29:17.526 --> 00:29:20.866
If you're doing a batch save and
you've got a jumble of records

00:29:20.866 --> 00:29:23.666
in this graph, and they
have delete self references

00:29:23.666 --> 00:29:25.316
between them, CloudKit is going

00:29:25.316 --> 00:29:27.906
to do an automatic
topological sort for you.

00:29:27.906 --> 00:29:30.586
We're going to upload
the records in order

00:29:30.586 --> 00:29:33.146
so that all the records that
are referenced will be up there

00:29:33.146 --> 00:29:35.586
by the time the record
reference in them is uploaded.

00:29:36.076 --> 00:29:38.196
This is really great
in the public database

00:29:38.196 --> 00:29:41.606
where you don't have atomic
commits but you still want

00:29:41.606 --> 00:29:44.636
to be able to upload data that
looks consistent at any point

00:29:44.636 --> 00:29:46.326
when a client downloads it.

00:29:48.846 --> 00:29:51.956
So, while developing CloudKit
internally, we've had a couple

00:29:51.956 --> 00:29:54.016
of our clients ask us,
you know, why do I need

00:29:54.016 --> 00:29:55.346
to use these reference objects?

00:29:55.346 --> 00:29:58.306
I have to, you know, alloc and
omit and it's so much work.

00:29:58.306 --> 00:30:01.646
You know, I've got a record
ID, why can't I just put it

00:30:01.646 --> 00:30:02.976
in the string and put
that in my record?

00:30:03.696 --> 00:30:04.896
You can, so, you know, you come

00:30:04.896 --> 00:30:06.806
up with this clever
little RecordIDToString,

00:30:07.366 --> 00:30:09.196
but then you look at
the recordID class

00:30:09.196 --> 00:30:11.696
and you realize it's
actually two properties,

00:30:11.696 --> 00:30:14.426
and you can't just store the
description of the record

00:30:14.426 --> 00:30:16.966
on the server so you
get a little smarter

00:30:16.966 --> 00:30:21.346
and you store the recordID
and the name and the zoneID.

00:30:21.986 --> 00:30:25.686
But then, you look at zoneID
and that's also composite.

00:30:26.426 --> 00:30:30.676
We need to know what, where
zone is and whose account it is.

00:30:31.256 --> 00:30:32.986
So, you get a little more clever

00:30:32.986 --> 00:30:34.976
and you make this
RecordIDToString

00:30:34.976 --> 00:30:39.066
and ZoneIDToString, and now
you call that everywhere.

00:30:39.226 --> 00:30:41.936
The problem is now you're
not forwards compatible.

00:30:42.006 --> 00:30:45.346
If anything ever gets added to
references, all of your records

00:30:45.346 --> 00:30:47.856
on the server are already going
to have this hard coded format,

00:30:48.256 --> 00:30:49.996
and you're going to have
to go through a lot of work

00:30:49.996 --> 00:30:51.156
when you query records.

00:30:52.316 --> 00:30:54.726
Instead, just use references.

00:30:54.726 --> 00:30:56.166
It's going to make
your code really clean.

00:30:56.166 --> 00:30:58.356
I mean that shoebox
could be a recordID,

00:30:58.356 --> 00:31:01.106
that shoebox could be a record
itself, it could be a reference.

00:31:01.566 --> 00:31:04.046
All of those will just work as
long as you use the CKReference.

00:31:04.946 --> 00:31:10.556
A couple last notes on
modeling your data in CloudKit.

00:31:11.896 --> 00:31:14.866
One of them is that CloudKit
is a transport mechanism.

00:31:14.986 --> 00:31:17.776
What we've tried to do here
is give you an easy way

00:31:17.776 --> 00:31:21.446
to access the CloudKit
servers, but we're not meant

00:31:21.446 --> 00:31:23.296
to be a local persistence layer.

00:31:23.296 --> 00:31:26.516
We want that to be up to
you, and you need to figure

00:31:26.516 --> 00:31:28.096
out the best way to
store your objects.

00:31:28.746 --> 00:31:33.336
And to that extent, we recommend
that you don't subclass CKItems.

00:31:33.526 --> 00:31:36.516
You should take those items when
you receive them from the server

00:31:37.216 --> 00:31:40.896
and translate them into your own
model objects, and you can do

00:31:40.896 --> 00:31:42.046
that on the way out as well.

00:31:42.046 --> 00:31:44.606
When you need to save one of
your model objects, translate it

00:31:44.606 --> 00:31:55.036
into a CKRecord and upload
all of that to the server.

00:31:55.216 --> 00:31:57.136
So, if you remember from
the introductory talk,

00:31:57.136 --> 00:31:59.466
we have these things that
we call subscriptions.

00:31:59.596 --> 00:32:01.686
They're persistent queries
that run on the server,

00:32:02.536 --> 00:32:05.396
and every time something
changes that matches that query,

00:32:06.186 --> 00:32:07.616
you're going to get
a push notification.

00:32:08.546 --> 00:32:11.206
And these push notifications
are sent via the Apple Push

00:32:11.206 --> 00:32:14.026
Notification Service, just the
same way that it would work

00:32:14.026 --> 00:32:15.106
if you built your own server.

00:32:16.766 --> 00:32:18.356
But there are some drawbacks

00:32:18.356 --> 00:32:20.336
with Apple Push Notification
Service.

00:32:20.336 --> 00:32:22.966
One of them is that they
can't make any guarantees

00:32:22.966 --> 00:32:24.366
on delivery of these pushes.

00:32:24.446 --> 00:32:26.536
They're kind of meant to
be these ephemeral, little,

00:32:26.536 --> 00:32:28.086
you know, here's a
push, here's a push.

00:32:28.586 --> 00:32:31.096
If one of them gets dropped
because of a bad network

00:32:31.096 --> 00:32:35.306
or anything else going
on, there's no guarantee.

00:32:35.636 --> 00:32:37.316
So, in practice,
they're really good

00:32:37.316 --> 00:32:38.536
about delivering these pushes.

00:32:39.006 --> 00:32:40.606
And one of the reasons is

00:32:40.656 --> 00:32:42.346
because the server
will store pushes

00:32:42.346 --> 00:32:43.596
for you if you're offline.

00:32:44.246 --> 00:32:45.936
So, if you put your
phone in Airplane Mode

00:32:45.936 --> 00:32:48.216
and you get a push, as
soon as you come back

00:32:48.216 --> 00:32:50.366
out of Airplane Mode, the
server will have that saved

00:32:50.366 --> 00:32:51.806
and still deliver
the push on to you.

00:32:52.976 --> 00:32:56.226
But the problem with this is
the server only stores one push

00:32:56.296 --> 00:32:56.796
per client.

00:32:57.776 --> 00:33:00.376
So, if you received a bunch of
pushes while you're offline,

00:33:00.376 --> 00:33:02.086
you're only going to
get the most recent one.

00:33:03.676 --> 00:33:04.416
What does that look like?

00:33:04.456 --> 00:33:07.026
Well, we've got our
CloudKit server,

00:33:07.026 --> 00:33:09.866
we've got the APS server, and
we've got the iPhone up here.

00:33:10.366 --> 00:33:13.486
And we send a push, and we're
online, everything goes through,

00:33:13.486 --> 00:33:15.036
we get our badge,
everyone's happy.

00:33:16.536 --> 00:33:18.196
But then, we get on an airplane.

00:33:18.196 --> 00:33:21.126
Our phone is in Airplane Mode;
we have no network connection.

00:33:22.136 --> 00:33:24.176
And when that push gets sent,

00:33:24.176 --> 00:33:26.176
the APS server helpfully
stores it for us.

00:33:26.306 --> 00:33:28.126
If we were going to come
back online right now,

00:33:28.126 --> 00:33:30.636
we would get our subscription
push and we'd be happy.

00:33:31.626 --> 00:33:34.596
But this is a long plane flight
and while we're on the plane,

00:33:34.716 --> 00:33:37.696
we got a zone update push,
that new zone subscription

00:33:37.696 --> 00:33:38.546
that I was talking about.

00:33:39.556 --> 00:33:42.916
When that gets to the APS
server, it's going to drop

00:33:42.916 --> 00:33:44.416
that previous subscription push,

00:33:44.916 --> 00:33:48.296
and now when your phone comes
back online, all you're going

00:33:48.296 --> 00:33:49.566
to receive is the zone update.

00:33:51.096 --> 00:33:52.736
The problem with this
is that you never heard

00:33:52.736 --> 00:33:54.096
about that subscription
that fired.

00:33:54.806 --> 00:33:56.016
So, how do we solve this?

00:33:56.016 --> 00:33:59.356
Well, we've created a
notification collection

00:33:59.356 --> 00:34:00.006
in CloudKit.

00:34:01.406 --> 00:34:04.376
Every time the server sends
a push to the APS server,

00:34:04.836 --> 00:34:06.616
it also makes a copy
of that push

00:34:06.616 --> 00:34:07.936
in the notification collection.

00:34:08.896 --> 00:34:11.356
So, you can see we have that
same problem where we're

00:34:11.356 --> 00:34:13.686
in Airplane Mode, we dropped
our subscription push,

00:34:14.446 --> 00:34:16.346
our phone comes online,
and it gets the push,

00:34:17.416 --> 00:34:19.406
and because this is a
well-behaved client,

00:34:19.406 --> 00:34:21.485
it knows every time
it receives a push,

00:34:21.545 --> 00:34:23.726
it should go check the
notification collection to find

00:34:23.726 --> 00:34:25.846
out about anything
it might have missed.

00:34:26.896 --> 00:34:28.116
So, how does that work?

00:34:28.116 --> 00:34:30.786
Well, this notification
collection is a lot

00:34:30.786 --> 00:34:32.686
like the delta downloads
I talked about earlier.

00:34:33.275 --> 00:34:34.676
It's all change token-based.

00:34:35.126 --> 00:34:36.656
You hand a change
token to the server,

00:34:37.005 --> 00:34:39.116
and the server hands back
all the notifications

00:34:39.116 --> 00:34:41.016
that have changed
since then along

00:34:41.016 --> 00:34:42.255
with an updated change token.

00:34:42.826 --> 00:34:45.716
So, since this is our
first time talking

00:34:45.716 --> 00:34:47.366
to the notification
collection, we're going to send

00:34:47.366 --> 00:34:48.456
up a nil change token.

00:34:49.576 --> 00:34:51.676
We're going to get back
both of those pushes,

00:34:51.676 --> 00:34:53.045
one of them which we missed.

00:34:53.525 --> 00:34:57.005
And then we're also going to
get an updated change token

00:34:57.005 --> 00:34:59.566
for the current state.

00:35:00.376 --> 00:35:04.396
One thing with subscriptions is
that you might want to use those

00:35:04.396 --> 00:35:06.516
to change some UI
in your application.

00:35:07.056 --> 00:35:10.946
For example in our Receipts app,
we might want a subscription

00:35:11.006 --> 00:35:14.176
for any receipt that
was over 100 dollars.

00:35:14.176 --> 00:35:16.986
If that happens, we want to mark

00:35:17.626 --> 00:35:19.256
that receipt in a
different color.

00:35:19.446 --> 00:35:21.736
So we're going to get this
push for a subscription,

00:35:22.656 --> 00:35:24.226
and now that receipt is blue

00:35:24.226 --> 00:35:26.036
because it was a big
expensive receipt.

00:35:27.396 --> 00:35:30.046
But, you know, this is going
to happen on all your clients,

00:35:30.046 --> 00:35:32.336
so you're going to have you iPad
showing that receipt in blue,

00:35:32.336 --> 00:35:34.536
you're going to have your Mac
showing that receipt in blue,

00:35:35.016 --> 00:35:38.356
and once this acknowledges
it, you want that UI state

00:35:38.396 --> 00:35:40.776
to go away on all your clients.

00:35:41.666 --> 00:35:44.476
Well, the way we do that is we
let you mark a subscription,

00:35:44.646 --> 00:35:46.806
sorry, we let you mark
a notification as red.

00:35:46.856 --> 00:35:49.366
And when you do that,
you're going to get a push

00:35:49.366 --> 00:35:51.576
for the updated subscription,

00:35:51.856 --> 00:35:53.816
updated notification
on every client.

00:35:54.486 --> 00:35:56.136
So, in this case,
we mark our receipt.

00:35:56.136 --> 00:35:58.826
We're going to go mark
that subscription as red

00:35:58.826 --> 00:36:00.846
on the server, and now
there's a new entry.

00:36:02.406 --> 00:36:04.786
And if we switch over to our
Mac which is still showing it

00:36:04.786 --> 00:36:06.286
in blue, it's going
to get a push,

00:36:06.516 --> 00:36:08.356
it's going to check the
notification collection,

00:36:09.126 --> 00:36:11.856
it's going to get that
subscription notification,

00:36:12.006 --> 00:36:14.466
and it can tear down
its UI and now all

00:36:14.466 --> 00:36:16.926
of your clients are
in the same state.

00:36:19.426 --> 00:36:20.966
So, with the notification
collection,

00:36:20.966 --> 00:36:22.976
keep in mind every
time you get a push,

00:36:22.976 --> 00:36:24.826
you should check the
notification collection.

00:36:25.086 --> 00:36:27.306
You never know what
you might have missed.

00:36:28.236 --> 00:36:31.366
And this isn't just for
Airplane Mode or bad networks.

00:36:31.526 --> 00:36:34.946
This can happen if you get
multiple pushes in a row.

00:36:34.946 --> 00:36:36.836
If there's a lot of changes
that happen all at once,

00:36:37.376 --> 00:36:39.256
the CloudKit server
might coalesce them,

00:36:39.256 --> 00:36:43.646
or the push server might
coalesce those pushes.

00:36:43.646 --> 00:36:46.836
And of course, because a lot
of these are mobile devices,

00:36:46.836 --> 00:36:48.966
they're iPhones, they're
going to be moving in

00:36:48.966 --> 00:36:50.056
and out of network states.

00:36:50.096 --> 00:36:53.786
They might be on Wi-Fi, or they
might be on a bad cell network.

00:36:53.786 --> 00:36:55.516
You never know what
your network is like.

00:36:56.356 --> 00:36:58.686
Just assume that there
might have been more pushes

00:36:58.726 --> 00:37:00.206
that you didn't hear about.

00:37:04.176 --> 00:37:06.696
So, now we're going to go
over the iCloud Dashboard.

00:37:07.036 --> 00:37:09.996
And the iCloud Dashboard
is our web-based interface

00:37:10.076 --> 00:37:13.166
for managing your
application in CloudKit.

00:37:14.536 --> 00:37:17.346
The iCloud Dashboard
lets you view your data.

00:37:18.076 --> 00:37:20.636
It lets you manage the schema
that we're creating for you.

00:37:21.666 --> 00:37:25.926
It lets you control what's
indexed, and it helps you moving

00:37:25.926 --> 00:37:27.136
from development to production.

00:37:27.136 --> 00:37:29.486
I'm going to explain all of
those in detail in a bit.

00:37:29.756 --> 00:37:31.526
Let's start with viewing data.

00:37:33.596 --> 00:37:38.166
So, if you remember the view
of our containers up here,

00:37:38.166 --> 00:37:40.466
we've got a public database
and a private database.

00:37:41.556 --> 00:37:44.706
And when you're viewing your
data in the iCloud Dashboard,

00:37:45.426 --> 00:37:48.506
all of that data in the public
database is of course public.

00:37:48.936 --> 00:37:52.356
So, in the dashboard, you'll
be able to see every record

00:37:52.356 --> 00:37:53.536
in your public database.

00:37:54.996 --> 00:37:58.266
But if you remember, the private
database is again one database

00:37:58.336 --> 00:37:59.706
for each individual user.

00:38:00.646 --> 00:38:03.266
And in this case, we're
only logged in as one user.

00:38:03.266 --> 00:38:04.976
We're logged in as
our developer account.

00:38:05.826 --> 00:38:09.126
So, all we're going to see in
the iCloud Dashboard is the data

00:38:09.426 --> 00:38:13.036
in the private database
for our developer account.

00:38:13.036 --> 00:38:13.966
This is really important.

00:38:13.966 --> 00:38:16.006
You know, you might use a
different account for testing

00:38:16.006 --> 00:38:17.586
and a different account
for viewing data

00:38:17.586 --> 00:38:18.696
in the iCloud Dashboard.

00:38:19.196 --> 00:38:20.476
If you do that, you
won't be able

00:38:20.476 --> 00:38:22.696
to view your private
data in the dashboard.

00:38:22.696 --> 00:38:26.226
So, what does the
dashboard look like?

00:38:26.266 --> 00:38:29.736
Well, we log in, and the
first thing we're going

00:38:29.736 --> 00:38:31.856
to see here are our
different record types.

00:38:32.376 --> 00:38:34.856
So, you can see we're
using the Party app.

00:38:34.856 --> 00:38:37.226
We've got parties,
and over here,

00:38:37.226 --> 00:38:39.476
we see the different schema

00:38:39.576 --> 00:38:41.676
for those values
that's been created.

00:38:43.426 --> 00:38:45.556
When you're developing
a CloudKit application,

00:38:45.996 --> 00:38:47.736
you're talking at the
development environment,

00:38:48.386 --> 00:38:49.286
and the server

00:38:49.286 --> 00:38:52.166
in the development environment
creates a just-in-time schema

00:38:52.246 --> 00:38:52.566
for you.

00:38:53.256 --> 00:38:55.946
So, we did this because we
wanted you to be able to develop

00:38:55.946 --> 00:38:57.256
as rapidly as possible.

00:38:57.256 --> 00:39:01.706
We didn't want you have to go
to a, this dashboard and plan

00:39:01.706 --> 00:39:03.576
out what you were going
to do in your application

00:39:03.576 --> 00:39:05.066
and choose all the data types.

00:39:05.066 --> 00:39:07.746
That's not as much fun as
just writing some code.

00:39:08.016 --> 00:39:10.856
So, we let you dive right
in, you write some code,

00:39:11.436 --> 00:39:14.726
and the things that you upload
to CloudKit as you upload them,

00:39:15.146 --> 00:39:17.376
those values get
locked in into a schema.

00:39:18.526 --> 00:39:20.496
So, you can see here
that we've got a couple

00:39:20.496 --> 00:39:23.426
of different values, and we've
got their, couple different keys

00:39:23.426 --> 00:39:26.146
and their values but we
notice that we made a mistake

00:39:26.146 --> 00:39:27.476
when we're developing this app.

00:39:27.666 --> 00:39:30.666
We uploaded a date
value or a date key,

00:39:31.106 --> 00:39:32.276
but we use a string value.

00:39:32.276 --> 00:39:34.136
And what we really want
there is a date value.

00:39:34.886 --> 00:39:37.306
The iCloud Dashboard is
going to let us fix that up.

00:39:37.826 --> 00:39:40.026
So we can go to this
and we can delete it.

00:39:41.016 --> 00:39:42.386
We can remove it
from our schema,

00:39:43.336 --> 00:39:46.296
and now we can recompile
our app, use a date value,

00:39:46.756 --> 00:39:49.696
upload that record again,
and when the server sees

00:39:49.696 --> 00:39:52.446
that record, it will
create a new schema entry

00:39:52.556 --> 00:39:59.866
for the date value using an
actual date instead of a string.

00:40:00.066 --> 00:40:02.306
So next up, you can
view all the records

00:40:02.306 --> 00:40:05.376
in your public database
using the iCloud Dashboard.

00:40:05.696 --> 00:40:07.486
So, you can see here,
we already have a couple

00:40:07.486 --> 00:40:09.496
of different parties
in the public database.

00:40:10.736 --> 00:40:14.306
What you can also do is create
records in the public database.

00:40:14.396 --> 00:40:18.356
So, you can tap on this Plus
button and fill out a new entry.

00:40:19.026 --> 00:40:22.226
We're going to make a new
party for coffee on Friday,

00:40:23.276 --> 00:40:26.966
and we can save that and you'll
see that that actually got saved

00:40:27.036 --> 00:40:28.276
into the public database.

00:40:28.316 --> 00:40:31.256
Any clients that are fetching
records are going to see

00:40:31.256 --> 00:40:33.316
that change in the
public database.

00:40:33.876 --> 00:40:37.796
We can also search for records.

00:40:37.796 --> 00:40:39.136
This is just like CKQuery.

00:40:39.136 --> 00:40:41.866
So we can click on
that magnifying glass,

00:40:42.816 --> 00:40:46.326
and we can type any
string, and we can filter

00:40:46.326 --> 00:40:49.316
down to any party
that mentions WWDC.

00:40:50.566 --> 00:40:52.856
Additionally, this gives
us all the functionality

00:40:52.856 --> 00:40:54.246
that we have in CKQuery.

00:40:54.246 --> 00:40:56.836
We can build compound queries
right in the dashboard.

00:40:57.326 --> 00:41:01.516
So, if you click on the Plus
button, let's choose location,

00:41:01.516 --> 00:41:03.716
and let's filter down
to everything that's

00:41:03.716 --> 00:41:06.246
within 5 kilometers
of Moscone Center.

00:41:06.366 --> 00:41:08.016
I happen to have
those memorized.

00:41:08.636 --> 00:41:12.826
So, that filtered everything
down just to the two parties

00:41:12.826 --> 00:41:13.726
that are in this area.

00:41:16.556 --> 00:41:18.766
Finally, in the public database,

00:41:19.076 --> 00:41:22.336
by default every record
can be read by every user,

00:41:23.346 --> 00:41:25.426
and it can be created
by any user.

00:41:25.726 --> 00:41:29.016
Once you create a record, that
record can only be updated

00:41:29.016 --> 00:41:31.096
or deleted by the
user that created it.

00:41:32.106 --> 00:41:34.296
But we understand that that
doesn't provide all the

00:41:34.296 --> 00:41:36.746
functionality that you might
need to make an application

00:41:36.746 --> 00:41:37.766
in the public database.

00:41:38.356 --> 00:41:41.186
So, what we've given you
are what we call roles.

00:41:41.186 --> 00:41:44.106
These roles let you
choose sets of users

00:41:44.106 --> 00:41:46.606
that have different
permissions for record types

00:41:46.606 --> 00:41:47.696
in the public database.

00:41:48.566 --> 00:41:52.156
So, one example of that might
be that I want to restrict it

00:41:52.156 --> 00:41:55.056
so that only I can create
parties in the public database.

00:41:55.716 --> 00:41:57.106
So, what I'm going
to do in order to do

00:41:57.106 --> 00:41:58.556
that is create a new role.

00:41:58.556 --> 00:42:04.336
I'm going to call this, you
know, PartyAdmin, and in that,

00:42:04.336 --> 00:42:07.206
I need to choose a record type
and give it special permissions.

00:42:07.286 --> 00:42:11.676
So I'm going to choose parties,
and I'm going to give it Create,

00:42:11.676 --> 00:42:13.586
Read, and Write permissions
for those parties.

00:42:16.466 --> 00:42:19.596
Now, what I need to do is go to
the record type and restrict it

00:42:19.596 --> 00:42:21.366
so that no one else
can create a party.

00:42:21.756 --> 00:42:25.586
So, I'm going to find my
party, my party record type,

00:42:26.106 --> 00:42:29.376
and you can see up there
that parties can be created

00:42:29.376 --> 00:42:30.666
by anyone who's authenticated.

00:42:31.226 --> 00:42:33.496
We don't want that, we
want only party admins

00:42:33.536 --> 00:42:34.416
to create this record.

00:42:34.506 --> 00:42:38.296
So, we're going to
uncheck that value.

00:42:38.386 --> 00:42:40.626
Now, we need to assign
people to that role

00:42:40.696 --> 00:42:42.976
so that there's actually users
out there that can do this.

00:42:43.796 --> 00:42:45.246
If we go to the user records,

00:42:45.246 --> 00:42:47.776
we can see everyone who's
used this app so far.

00:42:48.626 --> 00:42:51.636
If they have marked themselves
as discoverable, you're going

00:42:51.636 --> 00:42:53.306
to be able to see their
first and last name.

00:42:53.756 --> 00:42:55.296
If they haven't,
you're just going to see

00:42:55.296 --> 00:42:57.826
that recordID up there.

00:42:58.036 --> 00:43:01.396
So, I'm going to click on
my user, and then I'm going

00:43:01.396 --> 00:43:05.976
to add myself as a party admin.

00:43:05.976 --> 00:43:08.326
And now, I'm the only user
in the public database

00:43:08.396 --> 00:43:11.676
that can create a party.

00:43:13.516 --> 00:43:18.486
[ Applause ]

00:43:18.986 --> 00:43:22.626
So, one of the last things the
iCloud Dashboard helps you do is

00:43:22.626 --> 00:43:25.066
move from development
into production.

00:43:25.376 --> 00:43:27.186
So, as I talked about earlier,

00:43:27.286 --> 00:43:29.986
we wanted the development
environment to be as quick

00:43:29.986 --> 00:43:31.556
and easy to use as possible.

00:43:32.056 --> 00:43:34.076
We wanted you to hit the
ground running, we wanted you

00:43:34.076 --> 00:43:37.046
to just open up Xcode,
start typing some code,

00:43:37.046 --> 00:43:39.806
save your record to the server,
and see immediate results.

00:43:40.496 --> 00:43:43.786
And that all works great because
the server does just-in-time

00:43:43.786 --> 00:43:47.256
schemas, but that's not very
efficient if we're working

00:43:47.256 --> 00:43:49.986
in a public database that
might have millions of users.

00:43:50.066 --> 00:43:52.916
We need to prepare some
things before we go

00:43:52.916 --> 00:43:55.946
into the environment that all of
our customers are going to hit.

00:43:56.656 --> 00:43:59.216
So, the way this works
is we've got our records,

00:43:59.326 --> 00:44:00.696
we're developing
our app right now,

00:44:01.586 --> 00:44:03.916
and we just created a record
for the very first time,

00:44:03.916 --> 00:44:05.896
and we uploaded it in the
development environment.

00:44:07.076 --> 00:44:08.206
The server is going to see that

00:44:08.256 --> 00:44:10.656
and since this is the first
time it's seen a party,

00:44:10.656 --> 00:44:13.316
it's going to automatically
create a new party record type.

00:44:13.316 --> 00:44:16.556
And then for each of
these keys and values,

00:44:17.056 --> 00:44:19.986
it's going to create an entry
in a schema, and it's going

00:44:19.986 --> 00:44:22.206
to create an index on
every one of those values.

00:44:23.316 --> 00:44:26.606
This index is what lets you
query for any value in a record.

00:44:27.096 --> 00:44:29.656
So, while you're in development,
you can just run a query

00:44:29.656 --> 00:44:32.506
and search on any value
for any key in a record.

00:44:33.966 --> 00:44:36.196
And let's say we're going ahead
and we're developing this app

00:44:36.196 --> 00:44:38.686
and we decide we want to
add an additional property,

00:44:38.686 --> 00:44:42.116
so we decide we want to
have a background property

00:44:42.116 --> 00:44:43.356
for the color of the party.

00:44:43.916 --> 00:44:45.556
So, this party's
background is blue.

00:44:46.046 --> 00:44:47.556
All we have to do is
upload that record.

00:44:48.116 --> 00:44:50.566
It's going to send all those
other properties to the index,

00:44:51.156 --> 00:44:52.936
and the server is
going to notice, "Oh,

00:44:52.936 --> 00:44:54.056
there's a new property in here."

00:44:54.546 --> 00:44:57.146
It's going to create a new
schema entry, build a new index,

00:44:57.536 --> 00:44:58.606
and index that property.

00:45:00.536 --> 00:45:03.006
When you're ready to release
your app, you're going to want

00:45:03.006 --> 00:45:05.406
to make sure you've run
everything in development first

00:45:05.506 --> 00:45:07.466
so that you've built up
this just-in-time schema.

00:45:08.726 --> 00:45:11.476
You're then going to use
the iCloud Dashboard to move

00:45:11.476 --> 00:45:13.896
that schema from
development into production,

00:45:13.896 --> 00:45:15.826
and you're going to want to
check all of these fields

00:45:15.826 --> 00:45:17.316
to make sure that
they're the right values,

00:45:17.836 --> 00:45:19.066
make sure that every key

00:45:19.066 --> 00:45:21.706
that your app will ever
use exists in the schema.

00:45:22.646 --> 00:45:25.146
And when you do that, you're
going to move it into production

00:45:25.146 --> 00:45:26.476
and lock that schema in.

00:45:28.066 --> 00:45:31.406
Additionally, all of these
indexes take up a decent amount

00:45:31.406 --> 00:45:33.306
of space because
it has to make it

00:45:33.306 --> 00:45:35.926
so that you can query
those records.

00:45:35.926 --> 00:45:38.216
If you know you're never
going to query a value

00:45:38.216 --> 00:45:40.266
like we know we're never
going to query for records

00:45:40.266 --> 00:45:43.636
with just a blue background,
you can drop that index,

00:45:43.686 --> 00:45:47.036
and this will help free up some
space in your app's database

00:45:47.036 --> 00:45:48.746
or in your user's database.

00:45:51.716 --> 00:45:54.886
So, finally, a couple
CloudKit tips and tricks.

00:45:56.286 --> 00:45:57.866
So, we already went over this

00:45:57.866 --> 00:46:00.286
in the intro talk
about error handling.

00:46:00.716 --> 00:46:02.346
Please handle your
errors in CloudKit.

00:46:02.416 --> 00:46:03.486
This is really important.

00:46:03.536 --> 00:46:07.496
I know error handling is
hard and it's not fun to do,

00:46:07.946 --> 00:46:11.886
but CloudKit is all based
on network communication.

00:46:12.526 --> 00:46:15.716
And when you're talking over the
network, anything can go wrong.

00:46:16.526 --> 00:46:18.256
You know, the network
can get dropped.

00:46:18.256 --> 00:46:20.096
Because we have other
people talking

00:46:20.096 --> 00:46:21.706
to the server, we
can get conflicts.

00:46:21.706 --> 00:46:22.526
We can get errors.

00:46:23.146 --> 00:46:26.646
All kinds of things can
happen, and as Paul said

00:46:26.646 --> 00:46:29.876
in the first talk, this is the
difference between a working app

00:46:29.876 --> 00:46:30.976
and a not working app.

00:46:30.976 --> 00:46:34.606
It's not the difference between
a good app and a great app.

00:46:34.606 --> 00:46:36.096
If you don't handle errors,

00:46:36.176 --> 00:46:39.446
your app just isn't
going to work right.

00:46:39.646 --> 00:46:42.786
In CloudKit also, we've tried
to avoid any sort of magic.

00:46:42.906 --> 00:46:46.376
We don't want to try and handle
these errors for you and figure

00:46:46.376 --> 00:46:47.406
out what might be best.

00:46:47.896 --> 00:46:50.556
We want to just tell
you what happened.

00:46:50.556 --> 00:46:53.306
We want you to be able to figure
out what you need to do next,

00:46:53.306 --> 00:46:56.896
and we want to give you all
the information to do that.

00:46:57.136 --> 00:46:59.236
So, keep in mind when you're
handling your errors here

00:46:59.236 --> 00:47:01.566
that your operations
can have partial errors.

00:47:02.036 --> 00:47:05.316
These partial errors when you're
using the NSOperation API,

00:47:05.316 --> 00:47:07.746
you might be sending
up a batch of records.

00:47:08.406 --> 00:47:10.636
And if you're saving them
to the public database,

00:47:10.736 --> 00:47:12.806
it could be the case
that just one

00:47:12.806 --> 00:47:15.746
of those records had a conflict
but the rest saved just fine.

00:47:16.526 --> 00:47:18.626
If that happens, you're
going to get a partial error,

00:47:18.746 --> 00:47:20.876
and inside of that, you're
going to find one error

00:47:20.876 --> 00:47:21.966
for the record that failed.

00:47:22.816 --> 00:47:25.386
If this was in a custom
zone, you might see

00:47:25.386 --> 00:47:27.276
that as an atomic update error.

00:47:27.276 --> 00:47:30.006
So, you might see that one
of those records failed,

00:47:30.006 --> 00:47:33.366
and the rest got the
batch error in there.

00:47:34.356 --> 00:47:37.096
And finally, we want
you to make sure

00:47:37.096 --> 00:47:39.436
that you retry any
server busy errors.

00:47:40.176 --> 00:47:42.476
It could be the case
that the, you know,

00:47:42.546 --> 00:47:45.046
a bunch of people are going at
the servers at the same time

00:47:45.046 --> 00:47:46.236
and the servers can't handle it

00:47:46.236 --> 00:47:47.906
and they need clients
to back off.

00:47:48.096 --> 00:47:50.686
It could also be that
your client is misbehaving

00:47:50.686 --> 00:47:52.286
and hitting the server
too frequently,

00:47:52.286 --> 00:47:55.686
and the server is saying,
"Slow down, buddy."

00:47:55.686 --> 00:47:57.556
This is our way of
saying, "You know,

00:47:57.556 --> 00:47:58.656
we need a little more time.

00:47:58.656 --> 00:48:00.796
This request was OK, but
please try it again".

00:48:01.426 --> 00:48:03.556
And anytime we give you
a server busy error,

00:48:03.556 --> 00:48:06.496
we're going to hand back
a CKErrorRetryAfterKey.

00:48:07.026 --> 00:48:09.456
This is a number of seconds
that we'd like you to wait

00:48:09.456 --> 00:48:11.426
and retry your request.

00:48:14.116 --> 00:48:17.046
So, limits, in the
keynote, it was mentioned

00:48:17.046 --> 00:48:18.936
that CloudKit is
free with limits.

00:48:19.556 --> 00:48:21.326
How do those limits work?

00:48:21.326 --> 00:48:25.116
Well, anything stored in the
public database is counted

00:48:25.116 --> 00:48:26.336
against your app's quota.

00:48:26.386 --> 00:48:29.766
We give every app a
quota, and that's just

00:48:29.766 --> 00:48:30.626
for the public database.

00:48:31.726 --> 00:48:34.086
Anything you put in the
private database is counted

00:48:34.086 --> 00:48:35.516
against the user's account.

00:48:35.706 --> 00:48:39.656
So, every iCloud account gets
5 gigabytes of free storage,

00:48:40.146 --> 00:48:43.446
but users might have bought
more, or they might have filled

00:48:43.446 --> 00:48:46.356
up all that space with
emails or backups or photos.

00:48:46.866 --> 00:48:48.796
So, every user is going
to have a different amount

00:48:48.796 --> 00:48:49.516
of storage in there.

00:48:50.126 --> 00:48:52.216
And because this is
kind of the user space

00:48:52.216 --> 00:48:54.116
and it's shared space,
we want you to, you know,

00:48:54.346 --> 00:48:55.916
remember to be nice
to your users.

00:48:55.916 --> 00:49:01.086
It's technically free space for
you because it's theirs but,

00:49:01.086 --> 00:49:03.326
you know, don't fill it
up with unnecessary stuff.

00:49:03.906 --> 00:49:08.226
So again, with the
limits, how much do you get

00:49:08.226 --> 00:49:09.096
for your app container?

00:49:09.096 --> 00:49:10.766
Well, what we're concerned

00:49:10.766 --> 00:49:13.666
with here is customers
having a great experience,

00:49:14.166 --> 00:49:17.536
and these limits that we've
specified here are really

00:49:17.576 --> 00:49:19.056
to try and prevent abuse.

00:49:19.056 --> 00:49:20.936
We don't want to
prevent legitimate use.

00:49:20.936 --> 00:49:23.446
We just don't want
anyone abusing CloudKit.

00:49:24.496 --> 00:49:26.736
And the numbers that we
give you here also scale

00:49:26.736 --> 00:49:28.356
with the number of
users you have.

00:49:28.356 --> 00:49:29.946
If you go on
developer.apple.com,

00:49:29.946 --> 00:49:32.666
you can get the full breakdown
of the different values,

00:49:32.666 --> 00:49:36.916
but as an example, if you had
10 million users of your app,

00:49:36.916 --> 00:49:39.486
we're going to give you a
petabyte of asset storage,

00:49:39.486 --> 00:49:41.186
10 terabytes of database
storage,

00:49:41.186 --> 00:49:44.676
some pretty high transfer
limits, and this is all

00:49:44.766 --> 00:49:46.986
for your public database
in your application.

00:49:49.556 --> 00:49:51.666
So, finally, a note
on efficiency.

00:49:52.336 --> 00:49:54.916
One thing about CloudKit
is, again,

00:49:54.916 --> 00:49:56.876
it's a transport mechanism.

00:49:56.876 --> 00:49:59.976
We are only there to talk to
the iCloud servers for you.

00:50:00.676 --> 00:50:02.636
We're not storing any records.

00:50:02.636 --> 00:50:03.796
We're not caching records.

00:50:04.316 --> 00:50:06.456
Anytime we give you back
a record, it's something

00:50:06.456 --> 00:50:07.536
that we got from the server.

00:50:08.156 --> 00:50:10.206
We're trying to be as
transparent about that

00:50:10.206 --> 00:50:13.876
as possible and not do any
caching shenanigans here.

00:50:13.876 --> 00:50:16.326
We're always just giving
you what the server gave us.

00:50:17.666 --> 00:50:21.116
In terms of efficiency
though, you might remember

00:50:21.166 --> 00:50:23.226
from the save policies
that we're only going

00:50:23.226 --> 00:50:25.366
to save the values that
have changed on the records.

00:50:25.366 --> 00:50:27.856
So, we try and be smart about
what we send over the wire.

00:50:29.106 --> 00:50:30.846
When we're sending up assets,

00:50:30.956 --> 00:50:33.586
those can be potentially
really big blobs of data,

00:50:34.246 --> 00:50:36.496
and that data is
transferred efficiently.

00:50:36.496 --> 00:50:38.896
So, if the server already
has a copy of a file,

00:50:39.306 --> 00:50:40.306
we won't re-upload it.

00:50:40.486 --> 00:50:42.236
If we already have
that file locally,

00:50:42.236 --> 00:50:46.506
we don't need to re-download it.

00:50:46.696 --> 00:50:50.076
So, in summary, we're really
excited about CloudKit here.

00:50:50.076 --> 00:50:52.446
We've built a lot of
really great features

00:50:52.926 --> 00:50:55.306
and it's something that
we actually use at Apple.

00:50:55.306 --> 00:50:58.466
We've built iCloud Drive, we've
built iCloud Photos on top

00:50:58.466 --> 00:51:02.326
of this, and we want you guys to
start using the same technology

00:51:02.326 --> 00:51:03.646
that we're using at Apple.

00:51:04.536 --> 00:51:06.906
I'm really excited to see
what's going to happen.

00:51:06.906 --> 00:51:09.036
I can't wait to see some
apps that use CloudKit,

00:51:09.566 --> 00:51:12.376
and good luck with
using CloudKit.

00:51:14.516 --> 00:51:21.176
[ Applause ]

00:51:21.676 --> 00:51:24.816
So, if you need any, if
you need to contact anyone,

00:51:24.816 --> 00:51:26.316
Dave DeLong is our Evangelist.

00:51:26.316 --> 00:51:28.376
He's the guy with the bowtie.

00:51:28.426 --> 00:51:31.976
If you need documentation,
it's on developer.apple.com.

00:51:31.976 --> 00:51:35.086
We had a Introducing CloudKit
session earlier in the week.

00:51:35.246 --> 00:51:37.836
There's a couple more
related sessions.

00:51:38.876 --> 00:51:39.216
Thank you.

00:51:40.016 --> 00:51:41.000
[ Applause ]
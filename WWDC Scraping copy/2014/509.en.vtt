WEBVTT

00:00:11.396 --> 00:00:12.286
>> Hi, everyone.

00:00:12.546 --> 00:00:14.496
I'm Dean. In a few minutes,

00:00:14.496 --> 00:00:16.155
my colleague Brady will
go come up on stage.

00:00:16.556 --> 00:00:19.036
We're both engineers
on Apple's WebKit team.

00:00:19.666 --> 00:00:22.796
How often have you heard a
presentation start with "Today,

00:00:22.796 --> 00:00:25.386
I'm really excited to talk to
you about blah, blah, blah?"

00:00:25.596 --> 00:00:27.386
And I told myself I
didn't really want

00:00:27.876 --> 00:00:29.206
to introduce this
session that way

00:00:29.206 --> 00:00:31.226
and then I realized I
actually am really passionate

00:00:31.226 --> 00:00:33.786
about this topic because
over the past few years,

00:00:33.786 --> 00:00:36.526
I've worked on a lot of graphics
technologies on the web like SVG

00:00:37.006 --> 00:00:41.216
and Canvas, CSS transforms,
animations, filters.

00:00:41.426 --> 00:00:44.196
And I really think like WebGL
is the next significant leap

00:00:44.196 --> 00:00:46.336
in the type of graphics you
can do in a web browser.

00:00:47.686 --> 00:00:52.866
WebGL takes the power of
the OpenGL ES standard,

00:00:53.426 --> 00:00:57.516
which is popular on mobile chips
and combines it with the speed

00:00:57.516 --> 00:01:00.666
and convenience of JavaScript,
the web's programming language.

00:01:01.626 --> 00:01:03.976
This means-Well, because
you got this proliferation

00:01:03.976 --> 00:01:08.406
of really powerful
GPU hardware combined

00:01:08.406 --> 00:01:11.676
with this incredible performance
improvement in JavaScript,

00:01:11.676 --> 00:01:12.896
we've hit this sort
of sweet spot

00:01:12.896 --> 00:01:14.596
where you can do these
amazing graphics.

00:01:15.106 --> 00:01:18.866
This is going to give you the
full power of a configurable

00:01:18.866 --> 00:01:22.406
and programmable pipeline,
as well as performance,

00:01:23.116 --> 00:01:25.466
both because you're
talking directly to the GPU

00:01:26.856 --> 00:01:30.626
and because JavaScript
is super-fast nowadays.

00:01:30.626 --> 00:01:33.116
This is going to allow
you to write web content

00:01:33.796 --> 00:01:37.546
such as showing an interactive
3D model while still maintaining

00:01:37.546 --> 00:01:40.396
the flexibility and ease
of use of having your text

00:01:40.396 --> 00:01:42.256
and interactive controls
in HTML.

00:01:42.336 --> 00:01:45.536
Or maybe you want to take that
3D model a little bit further

00:01:45.536 --> 00:01:48.896
and do something like an
architectural walk-through flow

00:01:48.896 --> 00:01:50.506
through a building site.

00:01:50.616 --> 00:01:54.706
You can see here we've got more
advanced lighting, shadows.

00:01:59.056 --> 00:02:02.776
There's also data
visualization and mapping.

00:02:02.776 --> 00:02:05.006
We all know 3D mapping
is becoming more popular.

00:02:05.006 --> 00:02:06.406
But it's not just 3D.

00:02:06.886 --> 00:02:10.666
Let's say you want to do a
2D-You want to provide something

00:02:10.666 --> 00:02:13.266
like an image editor
that's doing 2D operations

00:02:13.266 --> 00:02:14.506
on your content.

00:02:14.506 --> 00:02:15.826
And here, you get
to do something

00:02:15.826 --> 00:02:18.416
that previously wasn't
available or was difficult to do

00:02:18.576 --> 00:02:19.776
in regular JavaScript.

00:02:20.166 --> 00:02:24.426
Well, something that's
very popular

00:02:24.426 --> 00:02:27.206
on the web is just
doing image transitions.

00:02:27.486 --> 00:02:29.386
So here, we've got
something a bit more exciting

00:02:29.456 --> 00:02:32.976
than a normal image slide where
we can do a 3D ripple effect.

00:02:34.076 --> 00:02:36.186
And of course, there's games.

00:02:36.186 --> 00:02:37.706
This is a demo, AngryBots,

00:02:37.776 --> 00:02:41.136
by Unity where you've got
this console level game engine

00:02:41.356 --> 00:02:46.176
which has things like realistic
lighting, particles and shadows

00:02:46.176 --> 00:02:48.846
and also the ability
to destroy evil robots.

00:02:49.886 --> 00:02:54.536
Or maybe you want to do
something like casual gaming

00:02:54.836 --> 00:02:56.716
and this is Swooop
by PlayCanvas.

00:02:56.716 --> 00:02:58.726
And it's a really
great innovative take

00:02:58.726 --> 00:03:02.056
on the infinite 2D runner where
instead of like sliding along

00:03:02.056 --> 00:03:06.566
in 2D, you're actually flying
this sort of nice stylized plane

00:03:06.566 --> 00:03:08.646
around this 3D island;
it's quite fun.

00:03:08.646 --> 00:03:13.546
So, what are you
going to learn today?

00:03:14.336 --> 00:03:18.746
We'd start by how to set
up-how to get access to WebGL

00:03:18.746 --> 00:03:20.076
and set it up in your web page.

00:03:20.126 --> 00:03:22.296
And then, we're going
to show how

00:03:22.296 --> 00:03:23.786
to do basic drawing with WebGL.

00:03:23.786 --> 00:03:25.806
And this is going to be sort
of like crash course into how

00:03:25.806 --> 00:03:28.766
to draw something with
WebGL and you get an idea

00:03:28.766 --> 00:03:31.016
of how powerful the
rendering system is.

00:03:31.556 --> 00:03:32.906
Once we get that, we're
actually going to move

00:03:32.906 --> 00:03:35.876
on to advanced drawing and
how to do simple animation.

00:03:35.966 --> 00:03:37.896
And lastly, because
it's a web technology,

00:03:38.086 --> 00:03:39.736
we want to tell you
how WebGL fits

00:03:39.736 --> 00:03:41.356
into other parts of
the web platform.

00:03:41.866 --> 00:03:45.706
But the important topic is
where is WebGL available?

00:03:45.706 --> 00:03:48.886
And we're happy to say that
WebGL is available in Safari,

00:03:48.886 --> 00:03:51.596
on OS X Yosemite, and that
was announced on Monday.

00:03:52.516 --> 00:03:54.546
[ Applause ]

00:03:55.046 --> 00:03:56.966
And what wasn't announced,
but I'm happy to say,

00:03:56.966 --> 00:03:59.836
is it's also available
in Safari on iOS.

00:04:00.516 --> 00:04:05.556
[ Applause ]

00:04:06.056 --> 00:04:09.036
The even better news is
this-WebGL is available

00:04:09.036 --> 00:04:13.006
on every device that can
install these operating systems.

00:04:13.816 --> 00:04:15.936
If you're a programmer and
you want to use WebGL content

00:04:15.936 --> 00:04:17.666
in your app, you're
going to want to know

00:04:17.666 --> 00:04:21.565
about the modern WebKit API
and its WKWebView class.

00:04:22.096 --> 00:04:25.326
Now, one of the many benefits
of using this new modern API is

00:04:25.326 --> 00:04:30.066
that you get full benefit of
the JavaScript Nitro engine,

00:04:30.066 --> 00:04:32.636
which means your content has
got to be running super-fast

00:04:32.886 --> 00:04:35.576
which we all know is Craig's
mom's favorite feature

00:04:35.576 --> 00:04:38.236
and she's updated all her
apps to use the modern API.

00:04:38.236 --> 00:04:45.896
Something else is that the
API surface area between iOS

00:04:45.896 --> 00:04:47.916
and OS X is identical
and this means

00:04:47.916 --> 00:04:51.556
that your content should run
the same on both devices with,

00:04:51.556 --> 00:04:54.096
of course, the understanding
that some devices don't run

00:04:54.396 --> 00:04:57.736
or don't have as powerful GPUs,
but otherwise, it's identical.

00:04:58.016 --> 00:04:59.596
And similarly, because
it's a web standard,

00:04:59.596 --> 00:05:00.846
that same content should run

00:05:00.846 --> 00:05:02.546
on other browsers
that support WebGL.

00:05:04.376 --> 00:05:09.206
Now, creating great 3D
content is made a lot easier

00:05:09.206 --> 00:05:10.476
if you have a good tool system.

00:05:10.806 --> 00:05:13.516
And even though WebGL is a
relatively young technology,

00:05:13.676 --> 00:05:15.876
it does have a sort of
thriving ecosystem of tools.

00:05:16.126 --> 00:05:17.956
And there's a couple I want
to call out in particular

00:05:17.956 --> 00:05:20.106
and these are big
vendors, Epic Games,

00:05:20.106 --> 00:05:22.916
the makers of Unreal Engine,
and Unity Technologies,

00:05:22.916 --> 00:05:26.506
the makers of Unity, both
have announced WebGL export

00:05:26.506 --> 00:05:27.446
from their systems.

00:05:27.496 --> 00:05:31.986
This means not only do you get
the state-of-the-art 3D engines

00:05:31.986 --> 00:05:33.836
and editing environments,
you also get access

00:05:33.836 --> 00:05:36.446
to their marketplace where
you can purchase 3D models

00:05:36.596 --> 00:05:39.796
or materials or other assets
to help you make your content.

00:05:41.356 --> 00:05:44.026
Another example is the
company called PlayCanvas,

00:05:44.216 --> 00:05:47.006
who also have a 3D engine and
editing tool, but they do it all

00:05:47.006 --> 00:05:48.846
within the web browser,
and this means

00:05:48.846 --> 00:05:51.496
that you can have distributed
teams working inside

00:05:51.496 --> 00:05:54.076
of a browser editing the same
content; it's really cool.

00:05:54.406 --> 00:05:57.266
If you're a developer, there's
a bunch of open source libraries

00:05:57.266 --> 00:05:58.646
and I've just listed a few here.

00:05:59.096 --> 00:06:02.156
Most of these do wrap
the low-level WebGL API

00:06:02.156 --> 00:06:05.716
and something higher which
allows you to program in terms

00:06:05.716 --> 00:06:08.226
of spheres and cubes
and materials rather

00:06:08.346 --> 00:06:09.926
than buffers and triangles.

00:06:10.666 --> 00:06:13.246
But today, we are going to talk
about buffers and triangles

00:06:13.246 --> 00:06:16.196
because we think it's important
that you understand that level

00:06:16.396 --> 00:06:18.636
of programming especially
if you are using some

00:06:18.636 --> 00:06:19.836
of these high-level tools.

00:06:20.076 --> 00:06:22.436
You have some hints as to
what might be going wrong

00:06:22.436 --> 00:06:24.986
and what you can do to
improve your content.

00:06:25.326 --> 00:06:27.416
Before I get into that, I just
want to talk about one thing

00:06:27.736 --> 00:06:30.026
which is motivation,
why we're doing this.

00:06:30.026 --> 00:06:33.956
So, Apple has always considered
rich, powerful graphics

00:06:33.956 --> 00:06:36.426
to be super important
to web developers

00:06:36.426 --> 00:06:37.656
and to the Safari engine.

00:06:37.656 --> 00:06:39.926
And in fact, this is
why about a decade ago,

00:06:39.926 --> 00:06:41.346
we invented the <canvas> element

00:06:41.556 --> 00:06:43.706
which is what the
basis of WebGL is.

00:06:45.146 --> 00:06:48.576
As soon as WebGL was announced,
we joined the working group

00:06:48.946 --> 00:06:50.806
and to this day, we
volunteer ourselves

00:06:50.806 --> 00:06:52.366
as the editor of
the specification.

00:06:52.916 --> 00:06:55.216
So, next question is
why do we choose OpenGL?

00:06:55.316 --> 00:06:58.736
OpenGL is the most important
standard graphics API

00:06:58.736 --> 00:07:00.506
that's around.

00:07:00.506 --> 00:07:02.326
It's already been demonstrated.

00:07:02.326 --> 00:07:04.476
It can run on a billion
mobile devices.

00:07:04.476 --> 00:07:07.416
And the content you can create
there is still just amazing

00:07:07.416 --> 00:07:09.676
on other devices or more
powerful devices as well.

00:07:10.456 --> 00:07:12.846
So, again, it sort
of made a no-brainer

00:07:12.846 --> 00:07:14.666
that we choose the best
standard and that way,

00:07:14.666 --> 00:07:16.926
all browsers can implement
it and we end up with WebGL.

00:07:17.516 --> 00:07:21.306
OK. So, let's get coding.

00:07:21.716 --> 00:07:25.346
Like all programming examples,
we want to start with "Hello,

00:07:25.346 --> 00:07:29.416
world" and we got to the
"Hello, world" of WebGL.

00:07:29.786 --> 00:07:31.946
So, imagine you're
opening your text editor

00:07:32.276 --> 00:07:33.966
and we're starting
with a blank slate.

00:07:33.966 --> 00:07:35.566
We're just going to
type a few commands

00:07:35.566 --> 00:07:39.846
and create something that's
this 3D interactive environment.

00:07:39.846 --> 00:07:43.456
We're actually going to start
with something very simple

00:07:43.456 --> 00:07:44.456
which is just a triangle.

00:07:44.776 --> 00:07:47.936
But while that might sound
disappointing, if we go back

00:07:47.936 --> 00:07:49.816
to the 3D environment,
we look at it

00:07:49.816 --> 00:07:52.936
and think actually-let's take
a look-it's actually made

00:07:52.936 --> 00:07:55.016
up of millions of
little triangles and each

00:07:55.016 --> 00:07:56.476
of those triangles have color

00:07:56.596 --> 00:07:58.956
or texture applied
or some lighting.

00:07:59.466 --> 00:08:01.566
And then we're rendering
it again with another pass

00:08:01.566 --> 00:08:05.256
where we might be doing blurs
or glows or shadows or whatever.

00:08:05.416 --> 00:08:07.186
And when you combine
them all together,

00:08:07.186 --> 00:08:09.576
you actually do get
the advanced rendering.

00:08:09.916 --> 00:08:13.986
So, you learn a lot of detail
from how to draw one triangle

00:08:14.156 --> 00:08:16.816
and the power that you learn
goes on to create better things.

00:08:18.226 --> 00:08:20.436
So, let's start creating,
configuring and drawing.

00:08:20.436 --> 00:08:22.146
And for that, we need 4 things.

00:08:22.696 --> 00:08:26.376
First, we're going to
need somewhere to draw to,

00:08:26.376 --> 00:08:27.486
something to draw on to.

00:08:28.226 --> 00:08:29.716
Then, we're going to need
something to draw with.

00:08:29.936 --> 00:08:32.296
Then, we're going to
configure that thing,

00:08:32.456 --> 00:08:33.785
choose what paint we
want to paint with.

00:08:33.785 --> 00:08:36.176
And lastly, we got
to do the drawing.

00:08:36.176 --> 00:08:38.135
We'll go through each of
these steps one by one.

00:08:38.885 --> 00:08:41.596
So, let's start with
something to draw onto.

00:08:41.726 --> 00:08:44.786
And artists like myself
call this a canvas

00:08:45.146 --> 00:08:46.806
which is super convenient

00:08:46.806 --> 00:08:49.176
because HTML already has
an element called <canvas>.

00:08:49.686 --> 00:08:50.456
So, we'll use that.

00:08:50.456 --> 00:08:54.336
And this is like a regular
image element except instead

00:08:54.336 --> 00:08:58.256
of getting the graphics to draw
from say, a file on the web,

00:08:58.546 --> 00:09:01.776
you provide the commands
in JavaScript that draw

00:09:01.776 --> 00:09:03.676
into the image and then
the browser renders that.

00:09:04.136 --> 00:09:06.376
You might already have one in
your page as a <canvas> element

00:09:06.506 --> 00:09:09.266
or you can create one through
JavaScript via createElement.

00:09:09.916 --> 00:09:11.086
In my example, I'm
going to pretend

00:09:11.086 --> 00:09:12.976
that I've already got one
in the page and I'm going

00:09:12.976 --> 00:09:16.036
to select it using the DOM
API and I'm going to store

00:09:16.036 --> 00:09:17.686
in the local variable
"canvas" 'cause I want

00:09:17.686 --> 00:09:18.786
to reference to it later.

00:09:19.616 --> 00:09:20.886
Now, before I can draw into it,

00:09:21.196 --> 00:09:23.956
I need to tell the system
how big an image it is

00:09:23.956 --> 00:09:26.216
or how many pixels it
needs to allocate so that

00:09:26.216 --> 00:09:28.986
when I draw the rendering
happens into that image.

00:09:28.986 --> 00:09:31.506
And I do that by
setting the width

00:09:31.506 --> 00:09:33.506
and height variables
on the canvas.

00:09:33.806 --> 00:09:37.526
Here, I want to set it to 600
by 400 but also I want to take

00:09:37.526 --> 00:09:39.606
into account if I'm
on a Retina display,

00:09:39.606 --> 00:09:41.016
I want a higher resolution
image,

00:09:41.016 --> 00:09:43.086
so I'm querying
window.devicePixelRatio.

00:09:44.796 --> 00:09:46.476
That's all I need for
something to draw.

00:09:46.476 --> 00:09:48.316
The next thing is I need
something to draw with.

00:09:48.526 --> 00:09:51.476
And in WebGL, that is the
WebGLRenderingContext.

00:09:51.476 --> 00:09:54.116
This is the object that
exposes the entire WebGL API.

00:09:54.116 --> 00:09:58.346
In code form, you do
that-you get one quite easily.

00:09:58.346 --> 00:10:01.616
You just call getContext passing
the string parameter WebGL.

00:10:02.756 --> 00:10:04.596
If you're familiar with
2D Canvas rendering,

00:10:04.596 --> 00:10:08.026
you would have seen someone
call this with a 2D string

00:10:08.026 --> 00:10:08.966
and you get the 2D API.

00:10:08.966 --> 00:10:11.526
So here, we've-we'd
code it with WebGL

00:10:11.526 --> 00:10:13.536
and we have a variable
called GL,

00:10:13.536 --> 00:10:15.086
which is the thing
we got to draw with.

00:10:15.986 --> 00:10:19.016
If you're familiar with
Native OpenGL programming,

00:10:19.246 --> 00:10:22.086
you might be wondering where
did I set my pixel format

00:10:22.086 --> 00:10:24.516
and create my render buffers
and frame buffers, et cetera,

00:10:24.846 --> 00:10:26.206
you don't have to
do that in WebGL.

00:10:27.216 --> 00:10:29.736
The previous step allocated the
image that you got to draw into

00:10:29.736 --> 00:10:31.876
and this step is giving you
the context that you got

00:10:31.876 --> 00:10:35.166
to draw with, that's
all you have to do.

00:10:35.396 --> 00:10:37.876
Next, we're going to
need something to-We need

00:10:37.876 --> 00:10:39.336
to configure the
system and this is

00:10:39.336 --> 00:10:40.536
where it gets a little
bit tricky

00:10:40.536 --> 00:10:42.616
so if-with only a few
lines, we've got something

00:10:42.616 --> 00:10:45.046
to draw with, now we're
getting into the native system.

00:10:45.226 --> 00:10:48.406
We got to give-This
is where we're got

00:10:48.406 --> 00:10:50.666
to start the crash
course in WebGL rendering.

00:10:51.556 --> 00:10:52.966
Before we are able
to render something,

00:10:52.966 --> 00:10:54.206
we need to do a few things.

00:10:54.206 --> 00:10:56.206
We need to create buffers.

00:10:56.206 --> 00:10:57.566
And buffers are just
a set of data

00:10:57.566 --> 00:10:59.206
that we got to upload
to the GPU.

00:10:59.646 --> 00:11:01.206
And that data can be
any types of things

00:11:01.206 --> 00:11:03.326
but they're almost certainly
got to contain the geometry

00:11:03.326 --> 00:11:04.226
that we want to render.

00:11:05.076 --> 00:11:07.946
Next thing we need is a
program which is going

00:11:07.946 --> 00:11:09.936
to be the actual way
that WebGL renders it.

00:11:10.356 --> 00:11:12.416
Now, you're going to
be a bit confused here

00:11:12.416 --> 00:11:14.906
because we're already making a
program what's-is this another

00:11:14.906 --> 00:11:17.316
program and the answer
is it is, we got to get

00:11:17.316 --> 00:11:18.746
into the details of
what it is later.

00:11:18.746 --> 00:11:21.756
But just imagine that you got to
be writing some specialized code

00:11:21.756 --> 00:11:24.386
that gets uploaded also to
the GPU and executed there.

00:11:24.706 --> 00:11:25.996
Let's start with the buffers.

00:11:26.156 --> 00:11:28.726
I want to draw this triangle,

00:11:28.726 --> 00:11:31.136
and the triangle is just
made up of 3 points.

00:11:32.056 --> 00:11:34.486
In WebGL, the coordinate
system goes from minus 1,

00:11:34.486 --> 00:11:38.616
minus 1 on the bottom left to 1,
1, on the top right and I want

00:11:38.616 --> 00:11:40.356
to create a buffer
out of these 3 points.

00:11:40.436 --> 00:11:43.636
So, what I'm going to
do is allocate 6 values,

00:11:43.636 --> 00:11:45.506
an array of 6 values
and I'm going

00:11:45.506 --> 00:11:49.086
to map those points
to those 6 values.

00:11:49.086 --> 00:11:53.306
So here, I've got (X1,
Y1), (X2, Y2), (X3, Y3).

00:11:53.306 --> 00:11:56.536
This is all I need
to upload to the GPU.

00:11:56.536 --> 00:11:59.446
So, I'm going to show you how to
do that in WebGL.In JavaScript,

00:11:59.756 --> 00:12:01.926
we just start with
the array of 6 values.

00:12:01.926 --> 00:12:03.706
This is a JavaScript array.

00:12:03.706 --> 00:12:07.236
And I'm going to assign
it into a Float32Array.

00:12:07.236 --> 00:12:09.346
And this is a special
type array in JavaScript

00:12:09.346 --> 00:12:12.576
and that's telling the system
that I want it to imagine

00:12:12.576 --> 00:12:15.746
or allocate this data
as a fixed-length array

00:12:16.046 --> 00:12:19.246
where each value is a full
byte floating point number.

00:12:19.936 --> 00:12:22.456
This comes in handy because
when we upload it to the GPU,

00:12:22.636 --> 00:12:25.606
we've already told the system
what the type of data is

00:12:25.606 --> 00:12:27.036
and that way, it-so
it doesn't have

00:12:27.036 --> 00:12:28.886
to do another conversion
from JavaScript.

00:12:29.496 --> 00:12:31.326
So, they actually
create the buffer.

00:12:31.326 --> 00:12:34.856
I'm going to call it
createBuffer command.

00:12:35.136 --> 00:12:37.496
And now I'm going to provide
the data that is going

00:12:37.496 --> 00:12:38.696
to be uploaded through the GPU.

00:12:38.696 --> 00:12:40.786
So, I just tell it, "That
buffer you just created?

00:12:41.026 --> 00:12:43.946
Send that vertex-vertices
variable up there."

00:12:43.946 --> 00:12:45.646
And that's all we have
to do to create a buffer.

00:12:45.646 --> 00:12:49.316
Now, we're going to
talk about the program.

00:12:49.836 --> 00:12:52.936
Now, conceptually, what
we're doing is we've got some

00:12:52.936 --> 00:12:55.706
JavaScript commands we're
executing and then we're going

00:12:55.706 --> 00:12:57.256
to end up with pixels
on the screen.

00:12:57.256 --> 00:13:01.556
But what really happens is that
we process some JavaScript,

00:13:01.726 --> 00:13:04.016
it gets sent to the
WebGL rendering pipeline

00:13:04.016 --> 00:13:05.316
and it's the thing that draws.

00:13:05.316 --> 00:13:06.846
So, we've really got to
understand what's happening

00:13:06.846 --> 00:13:08.396
in the WebGL rendering pipeline.

00:13:08.676 --> 00:13:10.346
Now, you can look
up OpenGL textbooks

00:13:10.346 --> 00:13:12.846
and they all explain the
same thing, but it's made

00:13:12.846 --> 00:13:14.426
up of basically 8 steps,

00:13:14.426 --> 00:13:16.936
and each of these 8 steps you
have different configuration

00:13:16.936 --> 00:13:18.136
options you can pass to them.

00:13:18.976 --> 00:13:21.516
But these 2 that you have
almost complete control of over

00:13:21.516 --> 00:13:23.206
and they're the 2
most important ones

00:13:23.206 --> 00:13:24.796
and the ones we're going
to talk about today.

00:13:24.796 --> 00:13:26.356
And that's the Vertex
Shader step

00:13:26.356 --> 00:13:27.686
and the Fragment Shader step.

00:13:28.486 --> 00:13:31.236
If we take them in isolation,
we can really consider

00:13:31.236 --> 00:13:33.076
that for the sake of
this presentation,

00:13:33.236 --> 00:13:34.596
I'm executing JavaScript.

00:13:34.596 --> 00:13:36.806
I'm going to send the commands
into the Vertex Shader.

00:13:37.036 --> 00:13:38.646
The Vertex Shader is going
to do something with it,

00:13:38.646 --> 00:13:41.126
send the command-send the
output onto the Fragment Shader

00:13:41.126 --> 00:13:43.026
which is going to do
something to it and eventually,

00:13:43.026 --> 00:13:44.356
we get the pixels on the screen.

00:13:45.006 --> 00:13:46.786
And this combination
of the Vertex Shader

00:13:46.786 --> 00:13:48.596
and the Fragment Shader
is what we were referring

00:13:48.596 --> 00:13:49.886
to as the program before.

00:13:50.416 --> 00:13:53.966
Now, Shaders are these little
programs that you got to write

00:13:53.966 --> 00:13:55.706
in another language
which we'll get to later

00:13:55.706 --> 00:13:57.756
and they're the things
that execute on the GPU.

00:13:57.756 --> 00:13:58.796
And the reason there's two

00:13:58.796 --> 00:14:00.466
of them is they have two
different operations.

00:14:00.786 --> 00:14:02.726
The Vertex Shader is
mostly about geometry.

00:14:02.726 --> 00:14:05.626
So, you're passing in
points to it and it's got

00:14:05.626 --> 00:14:07.396
to output converted points.

00:14:07.996 --> 00:14:10.206
The Fragment Shader is
really about what color

00:14:10.206 --> 00:14:12.976
of pixels you're going to do
based on the input of points.

00:14:13.616 --> 00:14:17.596
If we rotate this diagram
clockwise 90 degrees,

00:14:18.086 --> 00:14:18.996
we'll look at it another way.

00:14:18.996 --> 00:14:21.576
Here, I've got the buffer
that I've allocated before

00:14:21.576 --> 00:14:22.846
and I've uploaded to the GPU.

00:14:22.846 --> 00:14:24.526
I'm going to send it
into the Vertex Shader.,

00:14:24.526 --> 00:14:26.516
except it doesn't
quite work this way.

00:14:26.516 --> 00:14:28.926
And this is where the power
of GPUs comes in to play.

00:14:28.926 --> 00:14:32.946
I'm actually going to separate
each of those by buffering

00:14:32.946 --> 00:14:35.336
to a set of three
vertices and it gets sent

00:14:35.336 --> 00:14:37.496
to a different instance
of the Vertex Shader.

00:14:37.496 --> 00:14:40.606
And these were all executed
in parallel on the GPU.

00:14:40.606 --> 00:14:42.126
And this is where you get
this great performance.

00:14:42.656 --> 00:14:45.786
So, given a Vertex,
which is just the (x,

00:14:45.786 --> 00:14:47.866
y) point in this case,
the Vertex Shader is going

00:14:47.866 --> 00:14:49.926
to do something and
create another point

00:14:50.116 --> 00:14:51.476
and send it back to the system.

00:14:51.716 --> 00:14:54.286
And when the system has
collected all the points,

00:14:54.286 --> 00:14:56.116
it's going to do what's
called rasterization.

00:14:56.396 --> 00:14:59.016
So, it now knows where the
geometry on the screen is going

00:14:59.016 --> 00:15:01.356
to be displayed and which
pixels are going to be touched.

00:15:01.356 --> 00:15:04.656
But it still doesn't know
what color to draw the pixels

00:15:05.026 --> 00:15:07.256
and it's-this is the next
step where it's very similar

00:15:07.256 --> 00:15:08.306
to the Vertex Shader steps.

00:15:08.306 --> 00:15:10.516
It's going to take all those
pixels and then send them

00:15:10.516 --> 00:15:12.456
out to a bunch of
parallel instances

00:15:12.456 --> 00:15:13.406
of the Fragment Shaders.

00:15:13.406 --> 00:15:15.206
And the Fragment Shaders
just have the one task:

00:15:15.496 --> 00:15:17.396
given a pixel, what
color should it be?

00:15:18.176 --> 00:15:19.776
Let's look at the code for this.

00:15:19.966 --> 00:15:24.526
I'm going to start by creating
a vertexShader object which I do

00:15:24.526 --> 00:15:26.716
by createShader,
passing in the parameter,

00:15:26.716 --> 00:15:28.936
telling it that it's going
to be of type, vertex shader.

00:15:29.356 --> 00:15:30.406
And next, I'm going to tell it

00:15:30.406 --> 00:15:32.256
to provide some source
code for the shader.

00:15:32.256 --> 00:15:33.966
I'm not showing you the
source code at the moment

00:15:34.146 --> 00:15:36.116
but you can just imagine I'm
getting it from somewhere.

00:15:36.116 --> 00:15:37.946
It might be I create
it by JavaScript

00:15:38.196 --> 00:15:40.426
or I might have preloaded it
or got it from the internet

00:15:40.616 --> 00:15:41.516
and we'll get to that later.

00:15:41.516 --> 00:15:44.246
I'm going to compile it, which
is turning it into commands

00:15:44.246 --> 00:15:46.116
that we can use later
on the GPU.

00:15:46.506 --> 00:15:48.376
I do the same thing with
the Fragment Shader.

00:15:48.736 --> 00:15:50.096
It's pretty much identical.

00:15:50.096 --> 00:15:50.606
Of course, I'm going

00:15:50.606 --> 00:15:52.316
to use different source
code, which we'll see.

00:15:53.116 --> 00:15:55.686
Once we have those two
objects, the vertexShader

00:15:55.686 --> 00:15:58.576
and the fragmentShader, I
want to create a program

00:15:58.886 --> 00:16:01.426
and we tell the program that
it's two objects that it needs

00:16:01.426 --> 00:16:03.306
to talk to, or the two
shaders we created.

00:16:03.306 --> 00:16:06.696
I'm going to link it and then
lastly, I'm going to tell WebGL

00:16:06.696 --> 00:16:08.526
that this is the
program I want you to use

00:16:08.526 --> 00:16:09.616
when you do your drawing.

00:16:10.216 --> 00:16:12.626
So, that's all we have
to do for configuration.

00:16:12.626 --> 00:16:15.976
So, we now have a setup where
we have something to draw,

00:16:16.086 --> 00:16:18.696
we have something to draw with
and we've configured it to draw

00:16:18.696 --> 00:16:21.146
and the last thing we need to
do is render our masterpiece.

00:16:23.966 --> 00:16:26.226
Now, the next tricky step.

00:16:26.746 --> 00:16:28.436
I haven't shown you
any source code

00:16:28.966 --> 00:16:31.726
but what we-what the general
idea is here, we have a bunch

00:16:31.726 --> 00:16:34.016
of WebGL-we have a
bunch of JavaScript

00:16:34.066 --> 00:16:36.376
and we have some buffers on
the GPU that are what I want

00:16:36.376 --> 00:16:39.036
to render and I've got these
programs that I got to render it

00:16:39.076 --> 00:16:41.906
and I need to, through
JavaScript,

00:16:42.186 --> 00:16:45.716
tell the system how I'm binding
the data in those buffers

00:16:45.996 --> 00:16:47.466
to variables in my program.

00:16:47.466 --> 00:16:49.096
And you'll see the variables
in the program later.

00:16:49.096 --> 00:16:52.096
But the first thing I'm going
to do here is say, when you come

00:16:52.096 --> 00:16:54.246
to execute the program, there's
going to be a variable called

00:16:54.246 --> 00:16:57.656
"aPosition" and I want you
to associate every vertex

00:16:57.756 --> 00:17:00.886
in the-that you've uploaded
as a buffer to that variable.

00:17:01.226 --> 00:17:05.486
Next, when you actually
go to use the buffer,

00:17:05.486 --> 00:17:09.506
I have to tell the system that,
well, I've uploaded X, Y, X, Y,

00:17:09.506 --> 00:17:11.396
X, Y so I want you to assume

00:17:11.396 --> 00:17:15.236
that when you're processing this
buffer, take it two at a time

00:17:15.236 --> 00:17:16.806
and that they're
floating point values.

00:17:18.896 --> 00:17:20.296
Then, I just have to draw.

00:17:20.476 --> 00:17:21.146
I've sent a buffer.

00:17:21.146 --> 00:17:23.016
I'm going to draw the vertices

00:17:23.016 --> 00:17:25.656
in the buffer starting position
zero and I've got three of them

00:17:25.656 --> 00:17:28.506
which makes the three points
in the triangle and eventually,

00:17:28.806 --> 00:17:31.096
we end up with a
triangle on the screen.

00:17:31.286 --> 00:17:35.446
Now that-if we have to look at
the source code all at once,

00:17:35.446 --> 00:17:36.696
you might be a little
bit worried

00:17:36.696 --> 00:17:38.246
that it was actually a
fair bit of source code.

00:17:38.246 --> 00:17:40.096
I've skipped some in the
slides because I wanted

00:17:40.096 --> 00:17:41.276
to add some error
checking or whatever.

00:17:41.276 --> 00:17:43.826
But the important thing is
actually while you only drew a

00:17:43.826 --> 00:17:45.796
red triangle, there's
an insane amount

00:17:45.796 --> 00:17:47.796
of power behind that
red triangle.

00:17:48.006 --> 00:17:49.396
That power comes
from the shaders

00:17:49.396 --> 00:17:52.696
and that's what we're
going to look at next.

00:17:52.696 --> 00:17:54.576
So, I didn't show the
source code to the shaders,

00:17:54.576 --> 00:17:56.306
but we'll get into that.

00:17:56.306 --> 00:17:56.946
Shaders are written

00:17:56.946 --> 00:17:59.446
in a language called GL
Shading Language or GLSL.

00:18:00.526 --> 00:18:03.406
It's a C-like language
designed for parallel graphics.

00:18:04.706 --> 00:18:07.056
What this means is that
it's got-it looks like C

00:18:07.056 --> 00:18:10.306
but it's got some extra
primitives for vectors

00:18:10.306 --> 00:18:14.386
and matrices and also some
operations on those primitives

00:18:14.386 --> 00:18:16.046
so that you can multiply
matrices and whatever.

00:18:16.046 --> 00:18:17.526
You don't have to do
the math yourself.

00:18:17.646 --> 00:18:19.946
It also has a bunch
of built-in functions,

00:18:20.246 --> 00:18:23.806
such as trigonometry
functions or other operations

00:18:23.806 --> 00:18:25.806
on the matrices, like
dot products and normals

00:18:26.286 --> 00:18:29.476
and some other sort of helper
functions to make the -

00:18:29.476 --> 00:18:32.146
that are common in
graphics operations.

00:18:32.736 --> 00:18:36.266
Let's go back to the view
of the rendering pipe.

00:18:36.596 --> 00:18:38.076
So, I have the buffer
that I was sending off

00:18:38.106 --> 00:18:40.346
to multiple Vertex
Shaders that we're sending

00:18:40.346 --> 00:18:41.436
on to Fragment Shaders.

00:18:41.436 --> 00:18:43.176
But we'll simplify it
again and come back.

00:18:43.556 --> 00:18:46.056
Now, the data I was sending
in, the buffer at the top

00:18:46.056 --> 00:18:48.786
that you're familiar with,
I-at the moment, I only have X,

00:18:48.786 --> 00:18:52.176
Y positions but really you
can send any data into it.

00:18:52.316 --> 00:18:54.566
So here, I've just
added some other data.

00:18:54.566 --> 00:18:57.856
And again, this is the-these are
your input to the Vertex Shader.

00:18:57.856 --> 00:19:01.096
Each part, chunk of the buffer
is going to be associated

00:19:01.096 --> 00:19:04.666
with the vertex and sent in
to a Vertex Shader instance.

00:19:05.316 --> 00:19:07.686
But you might want to send data

00:19:07.686 --> 00:19:10.316
into the Vertex Shader that's
shared across all the instances

00:19:10.316 --> 00:19:12.816
that are running and you
do that by using uniforms.

00:19:13.446 --> 00:19:15.236
And these are global constants.

00:19:15.236 --> 00:19:17.626
So, good examples of this
might be the current frame

00:19:17.626 --> 00:19:20.336
of the animation that you want
to run or the mask position

00:19:20.336 --> 00:19:25.206
or the time-the rendering time
or maybe the camera position

00:19:25.256 --> 00:19:27.786
on matrix that you want to
do as a viewing position.

00:19:28.546 --> 00:19:31.706
So, the Vertex Shader is going
to operate on those two sets

00:19:31.706 --> 00:19:33.676
of inputs, one's
coming per vertex

00:19:33.676 --> 00:19:35.836
and the other one that's
coming as global variables

00:19:35.996 --> 00:19:38.246
and that only has one task
and that's to produce a point.

00:19:38.246 --> 00:19:40.026
And it produces that
point by writing

00:19:40.026 --> 00:19:42.356
to the global variable
called glPosition.

00:19:43.136 --> 00:19:45.146
The Fragment Shader
is quite similar.

00:19:45.146 --> 00:19:47.176
It's got to use the
position that was passed

00:19:47.176 --> 00:19:49.146
by the Vertex Shader
and any other data

00:19:49.146 --> 00:19:52.306
and the global constants and
it's going to write to one thing

00:19:52.306 --> 00:19:54.756
which is the color of the
pixel which it does by writing

00:19:54.756 --> 00:19:56.916
to the global variable,
GL fragment position.

00:19:57.426 --> 00:20:00.956
Let's look at the-finally,
look at the source code.

00:20:01.046 --> 00:20:02.606
So, my Vertex Shader,

00:20:02.606 --> 00:20:06.686
I've picked basically the most
simple Vertex Shader I can do.

00:20:07.316 --> 00:20:09.596
Now remember, we saw
that we were binding

00:20:09.756 --> 00:20:12.906
in JavaScript the
value aPosition-sorry,

00:20:12.906 --> 00:20:15.536
the variable aPosition to the
buffers that we passed in.

00:20:15.716 --> 00:20:16.986
Here's where I actually
get to do it.

00:20:17.216 --> 00:20:20.306
So here I am in the Vertex
Shader saying the data

00:20:20.306 --> 00:20:23.866
that comes in from the vertex,
I want you to associate it

00:20:23.866 --> 00:20:27.416
with the variable aPosition and
I'm doing the one thing I have

00:20:27.416 --> 00:20:29.016
to do which is writing
to gl-Position

00:20:29.016 --> 00:20:31.086
and I'm just writing the
same value that I got in.

00:20:31.086 --> 00:20:32.876
It's just sending the
inputs straight through.

00:20:33.396 --> 00:20:36.386
At this step, normally, you
would do something like map

00:20:36.386 --> 00:20:38.546
from your world coordinate
system

00:20:38.546 --> 00:20:40.726
into the camera coordinate
system,

00:20:40.726 --> 00:20:41.866
which then the camera maps it

00:20:41.866 --> 00:20:43.226
into the screen coordinate
system.

00:20:43.776 --> 00:20:47.036
But because I-the data I send
is actually really and already

00:20:47.036 --> 00:20:48.756
in the screen coordinate
system, I can just pass it

00:20:48.756 --> 00:20:49.746
through for convenience.

00:20:50.346 --> 00:20:53.946
The Fragment Shader is equally
simple-the Fragment Shader

00:20:53.946 --> 00:20:54.956
example is equally simple.

00:20:54.956 --> 00:20:56.286
I'll start with some
boilerplate.

00:20:56.286 --> 00:20:58.916
And the boilerplate is
telling the system what level

00:20:58.916 --> 00:21:01.906
of precision I want it to use
for floating point operations.

00:21:02.526 --> 00:21:05.586
And then I'm going to write
the color of the pixel and,

00:21:05.586 --> 00:21:08.426
in this case, I'm
writing to gl-FragColor.

00:21:08.426 --> 00:21:09.986
I'm going to write
every instance

00:21:09.986 --> 00:21:12.536
that the Fragment Shader is
writing the same value which,

00:21:12.536 --> 00:21:17.486
in this case is four-a vector
of four values which is the red,

00:21:17.486 --> 00:21:19.026
green, blue and alpha values.

00:21:19.336 --> 00:21:22.636
So here, I am writing
100 percent red, 0 green,

00:21:22.636 --> 00:21:24.336
0 blue and 100 percent alpha

00:21:24.336 --> 00:21:26.756
and this is why every
pixel came out as red.

00:21:26.756 --> 00:21:30.206
Now that was pretty simple.

00:21:30.206 --> 00:21:32.576
And to take it and show
you a little bit more power

00:21:32.576 --> 00:21:34.766
of the shaders, I'm going
to show a live demo.

00:21:35.896 --> 00:21:37.096
OK. So, here's our triangle.

00:21:37.646 --> 00:21:39.816
Now, this is running in
Safari and it's a web page

00:21:39.956 --> 00:21:41.946
and what you've got
is a-the top half

00:21:41.946 --> 00:21:44.566
of the screen is a WebGL canvas
that's drawing the triangle we

00:21:44.566 --> 00:21:45.206
did before.

00:21:45.596 --> 00:21:46.336
And the bottom half

00:21:46.336 --> 00:21:49.296
of the screen is showing the
source code to the shaders.

00:21:49.616 --> 00:21:52.456
So, in this case, it's
showing the Vertex Shader,

00:21:52.456 --> 00:21:56.156
and here's the Fragment Shader.

00:21:56.606 --> 00:21:58.586
And this whole environment
is live.

00:21:58.586 --> 00:22:00.616
So, if I make an edit
in the page here,

00:22:00.766 --> 00:22:03.176
it's going to grab the
source code out of the page,

00:22:03.286 --> 00:22:06.486
recompile the program, upload
it to the GPU and render again.

00:22:06.666 --> 00:22:08.236
It's actually rendering
constantly here.

00:22:08.236 --> 00:22:10.766
You just don't see it
because nothing's changing.

00:22:11.156 --> 00:22:12.106
So here's an example.

00:22:12.106 --> 00:22:17.256
Let's say here's the-me
writing the color of the pixel

00:22:17.256 --> 00:22:19.086
and I've set it to 1, 0, 0, 1.

00:22:19.086 --> 00:22:23.016
If I change this to just
1, I get full red, green,

00:22:23.016 --> 00:22:24.196
zero blue and I get yellow.

00:22:24.916 --> 00:22:27.486
Let's reset that and go
back to the Vertex Shader.

00:22:28.666 --> 00:22:33.036
So, you can see here is the
attribute that I'm passing in

00:22:33.036 --> 00:22:35.236
and I'm also passing
in some uniform values

00:22:35.236 --> 00:22:37.316
which is the time, as
in, every time I render,

00:22:37.316 --> 00:22:40.126
I update that value so that
I can read it in the shader.

00:22:40.196 --> 00:22:43.376
So, I could do something tricky
here like, well, maybe I want

00:22:43.376 --> 00:22:44.876
to do some kind of
coordinate transform.

00:22:44.876 --> 00:22:50.086
I want to make the
triangle twice as high

00:22:50.086 --> 00:22:52.616
so I just multiplied the Y
position or I can do something

00:22:52.616 --> 00:22:57.326
like if I take the attribute
in and I say I want the X value

00:22:57.326 --> 00:22:59.266
to be the Y value and the
Y value to be the X value,

00:22:59.266 --> 00:23:01.116
we've got this flipped triangle.

00:23:01.466 --> 00:23:04.166
I've got a preloaded one
which is doing it here.

00:23:04.976 --> 00:23:09.896
So, in this case, what I'm doing
is, I've got the input variable

00:23:09.896 --> 00:23:11.696
that I've post in called
time and I'm just mapping

00:23:11.696 --> 00:23:14.486
that between 0 and 1 and
calling it-assigning it

00:23:14.486 --> 00:23:15.796
to the variable called progress.

00:23:15.796 --> 00:23:17.966
And then when I come
to write the position,

00:23:18.226 --> 00:23:21.466
I'm just telling the position
that I want to interpolate

00:23:21.666 --> 00:23:24.056
between the X and
the Y positions using

00:23:24.056 --> 00:23:26.706
that progress value and that's
why you get this nice reflection

00:23:26.706 --> 00:23:28.016
across the diagonal axis.

00:23:28.926 --> 00:23:31.926
Let's reset again and go
back to the Fragment Shader.

00:23:32.906 --> 00:23:37.266
Now, we can do some cool
things in the Fragment Shader.

00:23:37.266 --> 00:23:40.606
For example, I've got
this communication

00:23:40.606 --> 00:23:42.956
between the Vertex Shader
and the Fragment Shader

00:23:42.956 --> 00:23:46.096
where I've alloc-of telling it,
the shader, where the position

00:23:46.096 --> 00:23:48.286
in X and Y is of the fragment.

00:23:48.476 --> 00:23:51.366
So, if I say instead of the
green value, I set it to be,

00:23:51.366 --> 00:23:55.716
say, fragPosition.x,
then we get a gradient

00:23:55.716 --> 00:23:59.306
because the value moves from
0 to 1 across the triangle.

00:24:00.256 --> 00:24:03.546
Again, I've got a preset one
so I don't have to type it out,

00:24:03.706 --> 00:24:04.986
but I'm doing something
similar here

00:24:04.986 --> 00:24:07.416
where the red value
is the X position,

00:24:07.596 --> 00:24:09.286
the green value is
the Y position

00:24:09.496 --> 00:24:11.816
and then the blue value
is oscillating over time

00:24:11.816 --> 00:24:13.916
so you get this nice
triangle that's moving.

00:24:14.066 --> 00:24:18.166
I'm kind of getting sick of the
triangle so let's have a look

00:24:18.166 --> 00:24:19.246
at it in wireframe mode.

00:24:19.536 --> 00:24:23.016
Now, we said that really GL is
about drawing lots of triangles.

00:24:23.016 --> 00:24:25.426
I want to draw a rectangle,

00:24:25.506 --> 00:24:27.696
which is really just two
triangles joined together.

00:24:27.696 --> 00:24:29.296
And if we go back
to the solid mode,

00:24:29.296 --> 00:24:31.246
you see that the same
animation is still running.

00:24:31.796 --> 00:24:35.646
Now, what's really impressive
is this program is running

00:24:35.646 --> 00:24:39.086
and calculating the value of
every pixel every time we draw.

00:24:39.086 --> 00:24:41.656
And this really blew my
mind when I first saw it

00:24:41.806 --> 00:24:43.596
but even this is a
pretty simple example

00:24:43.596 --> 00:24:45.516
and we can do way
more cool things.

00:24:45.516 --> 00:24:47.346
So, here's a little
bit more code.

00:24:49.256 --> 00:24:52.476
But what it's really doing is
just taking some sine waves

00:24:52.536 --> 00:24:56.016
and with slightly different
offsets and adding them

00:24:56.136 --> 00:24:58.086
up to get this interactive
thing.

00:24:58.086 --> 00:25:00.476
So, there's no images here,
it's all being calculated live.

00:25:00.616 --> 00:25:02.846
And the cool thing is you
can play around with stuff.

00:25:02.846 --> 00:25:05.806
So, here is where I
basically choose the frequency

00:25:05.806 --> 00:25:10.386
of the plasma so I can make it
a little bit higher by dividing

00:25:10.386 --> 00:25:14.996
by less and, let's say I
don't really like the colors,

00:25:14.996 --> 00:25:16.416
this is the-here's the point

00:25:16.416 --> 00:25:18.256
where I'm assigning
the color value.

00:25:18.256 --> 00:25:21.556
Let's say, instead of
minus 4, let's do plus 4,

00:25:21.556 --> 00:25:23.676
I like those colors
a little bit better.

00:25:23.826 --> 00:25:26.186
And I can go up here and
say, "Well, here's the number

00:25:26.186 --> 00:25:27.436
of iterations that
I'm adding up.

00:25:27.436 --> 00:25:30.186
So let's say, go down to 7.

00:25:31.006 --> 00:25:33.126
Let's do something like
3, kind of like that."

00:25:33.126 --> 00:25:36.706
This looks pretty cool.

00:25:36.916 --> 00:25:38.706
Now, as programmers you'll know

00:25:38.706 --> 00:25:40.646
that you can do cool
things like here.

00:25:40.646 --> 00:25:42.706
Let's say I want to
change the value of Pi,

00:25:42.706 --> 00:25:44.776
something that's quite hard
to do in the real world

00:25:44.776 --> 00:25:45.856
as far as I'm concerned.

00:25:46.046 --> 00:25:47.926
We will say something like 5, 6,

00:25:48.186 --> 00:25:50.626
or we can go-that's
kind of a nice effect.

00:25:51.226 --> 00:25:53.056
You can even do something
like crazy-what happens

00:25:53.706 --> 00:25:54.786
if I, hold on a second.

00:25:54.786 --> 00:25:57.106
Now, I came across
something earlier in the week

00:25:57.106 --> 00:26:00.076
which I really liked,
which was-I saw on the web

00:26:00.076 --> 00:26:01.816
and it was a guy and
his name is Israel

00:26:01.816 --> 00:26:04.496
and he saw the WWDC
branding and said, "Hey,

00:26:04.496 --> 00:26:07.056
I could write a Shader that
does this," and I asked him

00:26:07.056 --> 00:26:08.516
if I could use it
and here's the code.

00:26:08.836 --> 00:26:11.686
This is really cool, so this is
again a program that's running

00:26:11.686 --> 00:26:14.146
for every pixel every
time we draw and it's sort

00:26:14.146 --> 00:26:16.146
of this interactive WWDC logo.

00:26:16.146 --> 00:26:19.596
And you see, scroll down,
there's a fair bit of code.

00:26:19.686 --> 00:26:21.266
Amazing that it's all
running every step.

00:26:21.826 --> 00:26:24.286
Let's say I want to comment out
the final one and get black.

00:26:24.696 --> 00:26:26.366
You could sort of see what
he was doing in each step,

00:26:26.366 --> 00:26:27.286
so there's the gradient.

00:26:29.036 --> 00:26:31.536
There's the balls
that he was animating.

00:26:31.536 --> 00:26:34.026
And he sort of masked
them out to that

00:26:34.026 --> 00:26:36.126
and then eventually it
gets the square grid.

00:26:36.606 --> 00:26:39.276
I think this is really cool.

00:26:39.516 --> 00:26:43.486
So, I wrote this whole
system in a couple of hours,

00:26:43.836 --> 00:26:46.026
what's important to you is
that there's actually a couple

00:26:46.026 --> 00:26:47.946
of communities out there that
have something very similar,

00:26:47.946 --> 00:26:49.756
shadertoy.com and
the GLSL workspace,

00:26:49.756 --> 00:26:53.736
or becoming what is
called a playground, maybe.

00:26:54.016 --> 00:26:56.046
And if you look this up,
you'll see whole examples

00:26:56.046 --> 00:26:58.826
of amazing shaders that
will really blow your mind.

00:26:59.156 --> 00:27:04.296
So, in wrap up, shaders are
C-like programs that you write

00:27:04.856 --> 00:27:06.736
in GLSL and upload to the GPU.

00:27:07.016 --> 00:27:09.486
You get complete control
over the vertex positions

00:27:09.486 --> 00:27:13.296
that you pass in and the
color of the pixels you render

00:27:13.296 --> 00:27:15.296
to the screen and they're
extremely powerful.

00:27:16.616 --> 00:27:19.326
So with that, I'm going to pass
it on to my colleague Brady.

00:27:19.596 --> 00:27:23.226
Who's going to talk to you about
how to do advanced rendering.

00:27:23.276 --> 00:27:26.276
>> Thank you, Dean.

00:27:27.856 --> 00:27:30.386
So, so far, we've seen
the Hello World program

00:27:30.386 --> 00:27:32.716
of WebGL, the basic triangle.

00:27:33.016 --> 00:27:35.526
And yeah, there was a
little bit of effort to get

00:27:35.526 --> 00:27:37.026
that basic triangle
on the screen.

00:27:37.026 --> 00:27:41.016
But once we'd gone through that
effort, with just a few lines

00:27:41.016 --> 00:27:42.306
of shader code, we start

00:27:42.306 --> 00:27:45.216
to achieve some pretty
fancy things pretty quickly.

00:27:46.616 --> 00:27:49.026
And there's a lot more to be
said about shaders and we'll get

00:27:49.026 --> 00:27:51.266
into that more very soon.

00:27:51.696 --> 00:27:53.996
But I want to start out focusing
back on that red triangle.

00:27:55.416 --> 00:27:56.756
So, what is that triangle?

00:27:57.066 --> 00:27:58.916
The triangle is three
points in space.

00:27:59.606 --> 00:28:03.666
I can rearrange those three
points and move this triangle

00:28:03.666 --> 00:28:05.356
and reshape it however
I'd like to.

00:28:05.866 --> 00:28:08.356
Make it really skinny and tall.

00:28:09.136 --> 00:28:12.126
Now, I have two triangles,
two slightly different colors.

00:28:12.506 --> 00:28:14.636
This is starting to look very
familiar to me for some reason.

00:28:15.686 --> 00:28:16.556
Oh, that's why.

00:28:16.906 --> 00:28:19.026
OK. So, that's part
of the needle

00:28:19.026 --> 00:28:20.676
of the compass in
the Safari logo.

00:28:22.256 --> 00:28:24.316
So, let's build up
on this a little bit.

00:28:25.066 --> 00:28:29.656
We're going to take the Safari
logo and we're going to bring it

00:28:29.656 --> 00:28:32.206
into the third dimension
using WebGL.

00:28:33.076 --> 00:28:35.016
So, this is the most
basic example

00:28:35.016 --> 00:28:37.456
of a 3D compass you could say.

00:28:38.906 --> 00:28:40.446
But except for that
picture on top,

00:28:40.706 --> 00:28:42.656
it's basically just a gray disc.

00:28:43.096 --> 00:28:48.136
So, this gray disc is
actually very similar

00:28:48.406 --> 00:28:50.216
to that red triangle
that we started out with.

00:28:50.776 --> 00:28:52.766
And by that I mean, it's nothing

00:28:52.766 --> 00:28:54.626
but a whole bunch
of triangles itself.

00:28:54.826 --> 00:28:58.416
As Dean has already mentioned,
even the most complex scenes

00:28:58.416 --> 00:29:01.946
in WebGL are just
hundreds, thousands,

00:29:01.946 --> 00:29:03.276
maybe even millions
of triangles.

00:29:03.276 --> 00:29:08.916
So, for each of those triangles,
we have three points of course.

00:29:09.966 --> 00:29:12.086
Let's go back to the code that
Dean has already showed us

00:29:12.496 --> 00:29:16.536
where we take three points
to make a basic flat triangle

00:29:16.536 --> 00:29:19.136
and upload it to the GPU.

00:29:19.336 --> 00:29:22.696
And for our disc, our
basic little gray disc,

00:29:22.976 --> 00:29:24.286
we're just going to
do more of the same,

00:29:26.016 --> 00:29:27.796
a lot more of the same.

00:29:28.926 --> 00:29:31.956
So, how did I get all
these coordinates here?

00:29:32.426 --> 00:29:33.536
I'll tell you what I didn't do.

00:29:33.646 --> 00:29:35.286
I didn't calculate them by hand.

00:29:35.286 --> 00:29:37.206
I didn't type them out by hand.

00:29:37.956 --> 00:29:39.116
I used a tool.

00:29:39.526 --> 00:29:44.076
As Dean has already touched on,
your toolbox is very important

00:29:44.076 --> 00:29:45.386
when programming with WebGL.

00:29:46.076 --> 00:29:48.276
Unless you're doing the
most basic of examples,

00:29:48.276 --> 00:29:51.666
a handful of triangles, you're
probably going to want to rely

00:29:52.046 --> 00:29:56.136
on 3D modeling tools,
preexisting 3D models

00:29:56.456 --> 00:30:00.926
to shape your geometry and
the appearance and get them

00:30:00.926 --> 00:30:02.076
into your WebGL program.

00:30:03.076 --> 00:30:04.086
There's great native tools.

00:30:04.086 --> 00:30:05.266
There's great web
tools out there.

00:30:05.266 --> 00:30:06.396
Dean touched on a few.

00:30:06.796 --> 00:30:08.166
But what they all
have in common is

00:30:08.166 --> 00:30:10.356
that they'll export vertex data.

00:30:11.586 --> 00:30:13.516
And that is any data you want.

00:30:13.776 --> 00:30:14.856
That's what a vertex is.

00:30:15.466 --> 00:30:20.336
It's any data you want
for any point you want.

00:30:20.516 --> 00:30:22.746
We've already touched on the
most obvious bit of this data,

00:30:22.746 --> 00:30:25.636
which is the coordinate:
the X, Y and Z coordinate

00:30:25.636 --> 00:30:26.806
of that point in space.

00:30:28.136 --> 00:30:31.206
We can also directly include
the color of the point.

00:30:31.866 --> 00:30:35.196
But then as we get into more
advanced graphics programming,

00:30:35.406 --> 00:30:37.496
we'll want to include the
normal vectors of the point.

00:30:37.996 --> 00:30:41.266
This tells WebGL which
direction the point is facing,

00:30:41.506 --> 00:30:43.916
which is important for things
such as lighting later on.

00:30:44.426 --> 00:30:49.786
And then we can also
include texture coordinates.

00:30:50.536 --> 00:30:52.036
So, what are textures?

00:30:52.586 --> 00:30:57.496
Textures are just flat bitmap
images, an array of pixels

00:30:57.796 --> 00:30:59.526
and each pixel has
a color to it.

00:30:59.766 --> 00:31:01.526
You know this as
an image, right?

00:31:01.526 --> 00:31:04.516
So, here's the Safari
icon; it's just an image.

00:31:05.046 --> 00:31:08.976
But what texture coordinates
do is they map those pixels

00:31:08.976 --> 00:31:11.626
from the image onto our
three-dimensional shape.

00:31:12.376 --> 00:31:15.036
So, we can have the
basic, uncolored 3D shape

00:31:15.366 --> 00:31:18.786
and use a flat image to define
what colors it will show.

00:31:19.296 --> 00:31:21.936
So, how does this look in code?

00:31:23.146 --> 00:31:25.696
Back to our example of uploading
the geometry of our shape

00:31:25.766 --> 00:31:27.506
onto the GPU for use

00:31:27.506 --> 00:31:29.906
in our shaders program-our
Shader programs,

00:31:30.516 --> 00:31:32.946
here's the first 10
pixels from the disc.

00:31:33.686 --> 00:31:36.986
So, for each of these
10 vertices,

00:31:37.336 --> 00:31:38.866
we have an X, Y and
a Z coordinate.

00:31:39.956 --> 00:31:43.446
And then our tool can also
output the texture coordinates.

00:31:44.116 --> 00:31:48.396
These are just X and Y
coordinates into a texture image

00:31:48.596 --> 00:31:50.306
to map the pixels
onto our geometry.

00:31:51.106 --> 00:31:54.566
Instead of working from
the native pixel count

00:31:54.566 --> 00:31:57.146
of the image, it
works from 0 to 1.

00:32:00.856 --> 00:32:03.516
So, once we have that
data from our tool,

00:32:03.516 --> 00:32:05.636
we need to get it onto the GPU.

00:32:06.216 --> 00:32:08.796
So, you've already seen the code
that Dean showed us about how

00:32:08.796 --> 00:32:11.966
to get the position
vertices up onto the GPU.

00:32:12.046 --> 00:32:14.346
We're going to do a
little bit more of the same

00:32:14.346 --> 00:32:16.506
to get the texture
coordinates to the GPU.

00:32:17.176 --> 00:32:19.436
We're going to specify
a new attribute.

00:32:19.436 --> 00:32:24.246
Remember, an attribute is a way
to specify to the GPU the inputs

00:32:24.246 --> 00:32:25.506
into the shader programs.

00:32:26.136 --> 00:32:27.856
And we're going to
say that the input

00:32:27.856 --> 00:32:30.826
to the texture coordinate
attribute is our texture

00:32:30.826 --> 00:32:31.936
coordinate buffer.

00:32:32.436 --> 00:32:35.976
And then, we'll go ahead
and upload the data

00:32:35.976 --> 00:32:41.166
from that JavaScript
array onto the GPU.

00:32:41.656 --> 00:32:43.656
Now, back to our Vertex
Shader source code.

00:32:44.296 --> 00:32:46.746
This is the most basic
Vertex Shader example

00:32:46.746 --> 00:32:48.086
that Dean had showed
us, where we have

00:32:48.356 --> 00:32:50.026
that position attribute
as an input.

00:32:50.026 --> 00:32:53.506
We'll just go ahead and add the
texture coordinate attribute

00:32:53.786 --> 00:32:54.836
as an input as well.

00:32:54.836 --> 00:32:56.666
And now, it's available
to the Vertex Shader.

00:32:56.666 --> 00:33:01.776
One of the examples Dean showed

00:33:01.776 --> 00:33:05.206
in the demo had what's
called a varying variable

00:33:05.206 --> 00:33:06.036
in the shader program.

00:33:06.166 --> 00:33:08.456
He didn't touch on what that
is, so I'll tell you now.

00:33:08.926 --> 00:33:11.596
A varying variable is
a quick and easy way

00:33:11.596 --> 00:33:13.816
for the two shader
programs to share data.

00:33:14.316 --> 00:33:16.976
So, by declaring the
vTextureCoord variable,

00:33:17.656 --> 00:33:20.626
we can pass data from the Vertex
Shader to the Fragment Shader.

00:33:21.136 --> 00:33:24.936
And then, since we've already
pre-calculated what the texture

00:33:24.936 --> 00:33:27.746
coordinates are, we don't need
to transform them in any way.

00:33:28.156 --> 00:33:30.766
We're just going to pass them on
directly to our Fragment Shader.

00:33:32.436 --> 00:33:34.976
So, over in the Fragment
Shader source code,

00:33:35.826 --> 00:33:37.756
you'll make a similar change.

00:33:38.036 --> 00:33:40.296
We'll declare that texture
coordinate attribute

00:33:40.856 --> 00:33:42.916
and now it's available
in the Fragment Shader.

00:33:44.156 --> 00:33:45.636
So, this is the texture
coordinates.

00:33:45.816 --> 00:33:47.026
We've gotten them from our tool.

00:33:47.236 --> 00:33:48.906
We've gotten the
JavaScript array for them.

00:33:49.146 --> 00:33:50.716
We've uploaded them to the GPU.

00:33:50.836 --> 00:33:52.126
Now, the coordinates
are available

00:33:52.126 --> 00:33:53.316
in that Fragment Shader program.

00:33:54.436 --> 00:33:56.156
Now, we need to worry
about the texture itself.

00:33:56.606 --> 00:34:03.086
So, the way WebGL gets the
pixel data from an image

00:34:03.146 --> 00:34:05.036
that is your texture and uses it

00:34:05.036 --> 00:34:08.716
in the shader programs
is by using a sampler.

00:34:10.005 --> 00:34:12.485
So, back on our JavaScript where
we're configuring our shaders,

00:34:12.886 --> 00:34:14.556
we'll just declare
a sampler variable.

00:34:14.985 --> 00:34:17.306
This is uniform variable
as Dean already mentioned,

00:34:17.306 --> 00:34:19.826
it's a global variable that
JavaScript can assign to,

00:34:20.156 --> 00:34:22.176
to pass some data into
the shader programs.

00:34:23.735 --> 00:34:27.775
So, once it's been declared
in JavaScript, we can go back

00:34:27.775 --> 00:34:30.596
to our Fragment Shader and
declare it there in GLSL.

00:34:31.856 --> 00:34:34.956
The type here is sampler2D,
that's one of the few types

00:34:35.536 --> 00:34:40.706
in the GL language that
operate on textures.

00:34:41.856 --> 00:34:44.356
And once we have that
sampler, we'll change

00:34:44.356 --> 00:34:47.226
that straight red color where
we're saying every pixel is red.

00:34:48.045 --> 00:34:51.056
And now, we'll use the sampler
with this quick function call.

00:34:51.056 --> 00:34:53.396
What this function
call does is it says,

00:34:53.866 --> 00:34:57.796
for the texture source
represented in the sampler,

00:34:58.346 --> 00:35:01.496
I want the color of the pixel
at this texture coordinate.

00:35:02.146 --> 00:35:04.156
And then we assign
it to gl-FragColor

00:35:04.156 --> 00:35:08.016
and that's what's going
to show up in the scene.

00:35:08.106 --> 00:35:09.106
So, Texture Source.

00:35:09.376 --> 00:35:10.936
What is a texture source?

00:35:12.036 --> 00:35:13.596
In OpenGL, it means one thing.

00:35:13.596 --> 00:35:16.276
Here in WebGL, we're working
with web technologies.

00:35:16.746 --> 00:35:18.936
There's a few different
options for your texture source.

00:35:19.646 --> 00:35:21.846
The most obvious is
the <img> element.

00:35:22.316 --> 00:35:26.206
If you have an image in your
HTML page, in the markup,

00:35:26.476 --> 00:35:27.776
and your page is
finished loading,

00:35:28.176 --> 00:35:30.686
you can use that image
element as a texture source.

00:35:31.286 --> 00:35:33.346
You can also create an
image element dynamically.

00:35:33.386 --> 00:35:35.056
And as long as you've
waited for it to load,

00:35:35.406 --> 00:35:40.416
those pixels are ready to
be uploaded to the GPU.

00:35:40.536 --> 00:35:41.866
You can also grab data

00:35:41.866 --> 00:35:44.826
from a server directly
using XMLHttpRequest.

00:35:45.556 --> 00:35:50.136
You can-XMLHttpRequest has the
ability to grab the raw bytes

00:35:50.136 --> 00:35:52.586
of the response and
that is used in WebGL

00:35:52.586 --> 00:35:57.196
to get those vertex
points into the shader.

00:35:57.706 --> 00:36:01.096
Then there's a <video> element.

00:36:01.456 --> 00:36:05.496
The video element is a great way
to display video in your webpage

00:36:05.886 --> 00:36:09.346
without using any plug-ins in
a native web technology manner

00:36:09.346 --> 00:36:11.636
that interacts with all the
other web technologies created.

00:36:12.036 --> 00:36:15.336
But what a video really is,
is just a sequence of images.

00:36:15.866 --> 00:36:18.496
So, if you use a video
element as your texture source

00:36:18.686 --> 00:36:20.686
when you're drawing a
frame of your scene,

00:36:21.106 --> 00:36:23.346
it'll grab the freeze frame
of whatever is being shown

00:36:23.346 --> 00:36:25.046
in the video element
at that point in time

00:36:25.536 --> 00:36:27.056
and that freeze frame
will be used

00:36:27.056 --> 00:36:28.326
as the image for the texture.

00:36:28.806 --> 00:36:35.626
Last but definitely not least,
some pretty cool possibilities

00:36:35.806 --> 00:36:38.516
with the <canvas> element
being used as a texture source.

00:36:39.156 --> 00:36:40.046
You can draw whatever you

00:36:40.046 --> 00:36:43.256
like into a canvas
element: an image, text.

00:36:43.866 --> 00:36:47.256
You can use the canvas 2D
drawing APIs to draw a 2D scene.

00:36:47.866 --> 00:36:50.286
You can also use the WebGL API

00:36:50.286 --> 00:36:52.996
to draw a three-dimensional
scene into a canvas,

00:36:52.996 --> 00:36:56.026
and then use that canvas
as a texture source

00:36:56.176 --> 00:36:57.586
for a different WebGL scene.

00:36:57.926 --> 00:37:01.506
This way you can render
one 3D scene to be used

00:37:01.506 --> 00:37:05.236
in another 3D scene for a
movie screen or a billboard

00:37:05.236 --> 00:37:07.796
or television or much
more creative ideas.

00:37:08.316 --> 00:37:12.556
But how this looks in code,
we're just going to stick

00:37:12.556 --> 00:37:13.826
to the basic image element.

00:37:14.306 --> 00:37:16.836
Here's an image element
I have in my HTML markup

00:37:17.286 --> 00:37:20.476
and it's pointing to an image
that represents the Safari logo.

00:37:20.566 --> 00:37:26.966
Now, in JavaScript, first,
we ask the GL context

00:37:27.136 --> 00:37:29.336
to create a texture and then,

00:37:29.796 --> 00:37:32.006
similar to what we've
done a few times,

00:37:32.346 --> 00:37:38.216
we bind-do some binding
voodoo to specify

00:37:38.216 --> 00:37:39.606
which texture we're working on.

00:37:40.236 --> 00:37:43.016
TEXTURE0: this constant
might seem a little weird.

00:37:43.616 --> 00:37:46.606
The story behind TEXTURE0
is that each program,

00:37:46.606 --> 00:37:50.266
each set of shader programs
can access up to 32 textures

00:37:50.266 --> 00:37:52.536
and there's a constant
for texture 0, 1,

00:37:52.536 --> 00:37:53.876
2, all the way up to 31.

00:37:54.326 --> 00:37:55.786
We're just using
1 in this example,

00:37:55.786 --> 00:37:57.076
so we'll stick with the first.

00:37:57.506 --> 00:38:00.176
Then we get our texture source.

00:38:00.606 --> 00:38:01.886
Using this basic DOM API,

00:38:02.006 --> 00:38:03.836
we grabbed a reference
to the image element.

00:38:04.386 --> 00:38:08.586
Now, this line of code is
where the magic happens.

00:38:09.126 --> 00:38:12.146
In this line of code, we're
updating the raw pixel data,

00:38:12.146 --> 00:38:15.606
the RGBA bytes, 8
bytes per component,

00:38:16.206 --> 00:38:18.956
and we're uploading it
to the GPU to be used

00:38:18.956 --> 00:38:19.946
in our shader programs.

00:38:20.476 --> 00:38:23.836
And the key in this line
is the texture source,

00:38:23.946 --> 00:38:25.756
and that's the image
element you've grabbed,

00:38:25.966 --> 00:38:29.176
and this is where you might put
the XMLHttpRequest, the <video>

00:38:29.176 --> 00:38:30.976
or the <canvas> element
as a texture source,

00:38:30.976 --> 00:38:31.866
if that's what you're doing.

00:38:32.336 --> 00:38:37.176
And then, we're going
to go ahead and interact

00:38:37.176 --> 00:38:40.036
with that uniform variable that
we created earlier, the sampler,

00:38:40.556 --> 00:38:42.166
and now we actually
need to set its value.

00:38:42.526 --> 00:38:44.636
And the value we're
setting here is zero

00:38:44.926 --> 00:38:46.576
because we're working
on TEXTURE0.

00:38:47.056 --> 00:38:49.646
Behind the scenes, WebGL
translates that into an object

00:38:49.646 --> 00:38:53.146
that says, "I'm going to
be sampling pixel data

00:38:53.546 --> 00:38:55.086
from texture image zero."

00:38:57.496 --> 00:39:02.546
Now, we're ready to go and that
Vertex Shader can put those

00:39:02.546 --> 00:39:04.476
pixels onto the screen
from our texture.

00:39:05.456 --> 00:39:09.886
So, using textures, we
can map a flat 2D image

00:39:10.166 --> 00:39:11.706
onto our 3D geometry.

00:39:12.216 --> 00:39:15.426
In this example I've been
talking about so far,

00:39:15.426 --> 00:39:16.666
it's a very basic disc

00:39:17.126 --> 00:39:20.136
and a very flat image that's
just mapping one to one.

00:39:21.256 --> 00:39:25.166
But using our tools, we can have
a much more complicated texture

00:39:25.366 --> 00:39:26.446
where different regions

00:39:26.446 --> 00:39:29.606
of the texture represent
different parts of the geometry

00:39:29.656 --> 00:39:31.676
and then we can have much
more geometry as well.

00:39:32.826 --> 00:39:34.506
So, I'd like to show
you a live demo

00:39:35.166 --> 00:39:36.876
of what we've talked
about so far.

00:39:37.226 --> 00:39:39.286
So, I'm not going to show
you any code in this demo.

00:39:39.386 --> 00:39:42.936
I just think it helps to
visualize what I've been talking

00:39:42.936 --> 00:39:44.636
about with these
texture coordinates

00:39:44.826 --> 00:39:46.036
by building up an example.

00:39:46.936 --> 00:39:49.896
So, here's our very basic
three-dimensional disc.

00:39:50.416 --> 00:39:55.266
You can see it's got a
wireframe which is nothing

00:39:55.266 --> 00:39:57.686
but a whole bunch of triangles
that build up this round shape.

00:39:58.106 --> 00:40:03.136
But as I alluded to in the slide
right before I started the demo,

00:40:03.136 --> 00:40:04.976
we can have a much more
complex version of this.

00:40:05.626 --> 00:40:09.186
We can build up the geometry
to represent the features

00:40:09.186 --> 00:40:11.096
of the compass in
three dimensions.

00:40:11.616 --> 00:40:17.516
And then, we can go ahead and
apply that complicated texture

00:40:17.516 --> 00:40:19.336
onto that geometry, and now,

00:40:19.336 --> 00:40:24.356
we have a live 3D
representation of a compass.

00:40:24.476 --> 00:40:28.136
Now, to really convince you it's
live, let's start animating.

00:40:29.506 --> 00:40:31.956
So, this is a really quick
little routine that's just

00:40:31.956 --> 00:40:34.016
animating a camera
around the compass,

00:40:34.356 --> 00:40:39.446
following some sign waves
and the time, just to kind

00:40:39.446 --> 00:40:41.356
of give an ooh, aah, view of it.

00:40:42.636 --> 00:40:45.006
To further convince you that
this is a live 3D model,

00:40:45.316 --> 00:40:47.356
I can show you that parts of it
are independent from another.

00:40:47.476 --> 00:40:49.356
So, let's go ahead and
start that needle spinning.

00:40:51.516 --> 00:40:55.406
So, all that data generated
using a tool, its output,

00:40:55.716 --> 00:40:58.246
the coordinate information,

00:40:58.446 --> 00:41:01.036
the texture-the position
coordinate information,

00:41:01.036 --> 00:41:02.456
the texture coordinate
information,

00:41:02.806 --> 00:41:04.886
it's also outputted
a whole bunch

00:41:04.886 --> 00:41:06.986
of other vertex information
that we've uploaded

00:41:06.986 --> 00:41:11.536
to our shader programs and can
be using to show this compass.

00:41:12.086 --> 00:41:16.046
Now, the same code was being
executed both in JavaScript

00:41:16.046 --> 00:41:19.686
and on the shaders no
matter which geometry

00:41:19.686 --> 00:41:22.946
and vertices I'm
passing into it.

00:41:23.036 --> 00:41:25.716
But vertex information does
not need to come from a tool.

00:41:26.356 --> 00:41:29.616
We can also procedurally
generate vertex information.

00:41:30.716 --> 00:41:33.246
So here, we have a terrain
underneath the compass

00:41:33.576 --> 00:41:35.356
that we're generating
in JavaScript.

00:41:35.546 --> 00:41:39.146
It's just a few dozen lines
of code to generate this strip

00:41:39.146 --> 00:41:40.106
of terrain underneath.

00:41:40.636 --> 00:41:43.046
So, we can move the
compass over to terrain,

00:41:43.646 --> 00:41:44.836
the needle is still spinning,

00:41:45.506 --> 00:41:47.366
and some more advanced
things we can do, too,

00:41:47.366 --> 00:41:50.426
right now I haven't talked
about yet but we'll get

00:41:50.426 --> 00:41:52.306
into in a little bit
more detail later.

00:41:52.306 --> 00:41:53.856
So, we can add some lighting.

00:41:54.116 --> 00:41:56.536
So now, we have some lights
animating over the terrain.

00:41:57.236 --> 00:41:59.766
You can see how they
affect the entire scene

00:41:59.766 --> 00:42:00.766
and the compass itself.

00:42:00.766 --> 00:42:07.336
So, in that demo, we showed a
live representation of a few

00:42:07.336 --> 00:42:08.956
of the concepts we've
been talking about so far:

00:42:09.116 --> 00:42:11.226
outputting complex
geometry from a tool,

00:42:11.226 --> 00:42:13.056
outputting texture
information from a tool.

00:42:13.576 --> 00:42:16.086
But the code that are

00:42:16.086 --> 00:42:20.166
in the demo really was only a
few dozen lines of JavaScript

00:42:20.166 --> 00:42:23.286
and Vertex Shader programming
that we've already gone over.

00:42:23.406 --> 00:42:25.566
There's some additional
JavaScript to animate things.

00:42:26.066 --> 00:42:31.716
But it barely scraped the
surface of what WebGL can do.

00:42:32.386 --> 00:42:34.976
Even with that procedural
terrain generation

00:42:35.276 --> 00:42:38.816
and the lighting effects which
I haven't told you any details

00:42:38.816 --> 00:42:41.266
about, that's still
barely scraped the surface

00:42:41.266 --> 00:42:42.476
of what WebGL can do.

00:42:42.476 --> 00:42:43.896
It is immensely powerful.

00:42:43.896 --> 00:42:47.186
It is a toolbox unto
itself and trying

00:42:47.186 --> 00:42:49.186
to describe everything
would take a lot more

00:42:49.186 --> 00:42:50.036
of these sessions.

00:42:50.556 --> 00:42:54.166
So, I'm not going to go into
much more detail on any of that,

00:42:54.676 --> 00:42:56.846
but I am going to talk about
a different toolbox now,

00:42:57.186 --> 00:42:59.176
like to shift gears and touch

00:42:59.176 --> 00:43:01.436
up on the web platform
a little bit.

00:43:02.016 --> 00:43:05.296
The web platform is pretty
mature at this point,

00:43:05.296 --> 00:43:10.896
it's been around for dozens
of years and WebGL is just one

00:43:10.896 --> 00:43:14.356
of the newest star children
tools in the web platform.

00:43:15.136 --> 00:43:18.536
But there's also some very basic
tools that are still there.

00:43:18.906 --> 00:43:20.456
HTML is what started it all.

00:43:20.456 --> 00:43:22.836
HTML specifies the
content and structure

00:43:23.156 --> 00:43:24.566
of the document in your webpage.

00:43:25.086 --> 00:43:28.926
And then a little bit
later, we introduced CSS,

00:43:29.276 --> 00:43:31.646
which specifies how that
content is presented.

00:43:32.056 --> 00:43:35.836
CSS can do simple things like
change the font of some text,

00:43:36.176 --> 00:43:39.736
but it can also animate
the transitions of an image

00:43:39.736 --> 00:43:42.436
or any element from
different points on the page,

00:43:42.586 --> 00:43:44.126
including 3D transforms.

00:43:44.316 --> 00:43:49.066
That's already been available
in CSS, a native web technology

00:43:49.066 --> 00:43:50.366
that preexisted WebGL.

00:43:50.886 --> 00:43:53.976
And then of course,
there is JavaScript.

00:43:54.306 --> 00:43:56.216
We've talked a lot
about JavaScript today

00:43:56.216 --> 00:43:58.866
because you use JavaScript
to drive WebGL

00:43:59.246 --> 00:44:02.906
but JavaScript also has native
DOM bindings to the HTML content

00:44:03.296 --> 00:44:05.866
and can transition
styles on the page.

00:44:07.076 --> 00:44:10.956
So, using just this bottom
tier of technologies, the HTML,

00:44:11.036 --> 00:44:13.306
the CSS, and JavaScript,
we've already been able

00:44:13.306 --> 00:44:14.666
to do some pretty cool things.

00:44:15.576 --> 00:44:17.266
For example, if I
wanted to go into

00:44:17.706 --> 00:44:20.576
and create a 3D image gallery,
I wouldn't need to jump

00:44:20.576 --> 00:44:22.146
into WebGL just to do that.

00:44:22.556 --> 00:44:26.926
The HTML can specify a series
of images and their relation

00:44:26.926 --> 00:44:28.646
to each other, the order
in which they appear.

00:44:29.156 --> 00:44:34.966
The CSS can define a 3D
presentation of those images

00:44:35.176 --> 00:44:41.226
and JavaScript can drive some
CSS animations between them.

00:44:41.426 --> 00:44:44.976
Something else that's already
been possible is really advanced

00:44:45.116 --> 00:44:46.426
text operations.

00:44:46.806 --> 00:44:50.336
Using HTML and CSS and things
like the font-face rules,

00:44:50.626 --> 00:44:52.576
you can add your own
fonts to content,

00:44:52.846 --> 00:44:56.856
you can really finally tweak
how the font is rendered

00:44:57.556 --> 00:45:00.906
and it's pretty simple
to do versus,

00:45:00.906 --> 00:45:02.876
if you try to do font
rendering in WebGL,

00:45:02.876 --> 00:45:04.816
you might find it
much more difficult.

00:45:05.796 --> 00:45:07.676
Also, in this little
video I just showed,

00:45:07.906 --> 00:45:09.926
you can see that HTML

00:45:09.926 --> 00:45:12.016
and JavaScript have
built-in event handling

00:45:12.016 --> 00:45:15.806
for the mouse pointer and a
whole bunch of built-in controls

00:45:15.926 --> 00:45:18.746
and built-in hit testing for
different elements on the page.

00:45:19.076 --> 00:45:21.286
These are all built in
and easy to use already.

00:45:21.756 --> 00:45:25.806
And then at an even
more basic level,

00:45:26.116 --> 00:45:28.786
what HTML does is
lay out content.

00:45:29.036 --> 00:45:31.576
It lays out texts and
other elements on a page.

00:45:31.946 --> 00:45:33.836
You can see in this
iBook example,

00:45:34.146 --> 00:45:37.336
the text flows beautifully
around elements on the page

00:45:37.676 --> 00:45:41.176
and that was basically all free
for whoever wrote that content

00:45:41.346 --> 00:45:43.176
and put that image
into that document.

00:45:43.666 --> 00:45:47.446
And then very importantly,

00:45:47.646 --> 00:45:50.346
sticking with the native web
technologies whenever you can

00:45:50.716 --> 00:45:52.166
gets you accessibility for free.

00:45:52.746 --> 00:45:57.796
So today, we're talking
a lot about tools,

00:45:58.486 --> 00:46:02.486
and the point I'd just
like to drive home here is

00:46:02.806 --> 00:46:05.856
to use the appropriate
tool whenever you can,

00:46:05.926 --> 00:46:09.066
it's an old programming
adage and it's really true

00:46:09.306 --> 00:46:11.756
when we take a platform as
mature as the web platform

00:46:11.936 --> 00:46:14.606
and introduce as something
as powerful as WebGL.

00:46:15.096 --> 00:46:20.366
And finally, I have one more
thing we need to talk about

00:46:20.976 --> 00:46:22.036
and that's when to draw.

00:46:23.166 --> 00:46:25.376
So far, Dean and I
have described a lot

00:46:25.376 --> 00:46:29.056
about how you render an
individual frame in your scene,

00:46:29.356 --> 00:46:32.706
you set up the geometry
of objects and the colors

00:46:32.706 --> 00:46:35.386
and you set up your shaders
and then you make a call

00:46:35.386 --> 00:46:39.016
to draw triangles and, boom,
you've rendered a still frame.

00:46:39.856 --> 00:46:43.046
Now, each of the demos we showed
you had animation involved.

00:46:43.516 --> 00:46:44.806
How did that animation happen?

00:46:45.696 --> 00:46:49.446
Well, as you know by now,
JavaScript drives drawing

00:46:49.446 --> 00:46:53.216
in WebGL, but JavaScript
is not always running.

00:46:54.506 --> 00:46:58.886
Take this beautiful web page
here, it's clean and looks nice,

00:46:59.156 --> 00:47:02.756
but it's also very static
and as long as I'm the user

00:47:02.756 --> 00:47:04.436
and I'm not touching
the mouse or keyboard

00:47:04.606 --> 00:47:06.256
and I'm not interacting
with the page at all

00:47:06.576 --> 00:47:08.726
and the page is very static,
it doesn't have timers

00:47:08.726 --> 00:47:11.856
or any other things going on,
no JavaScript is executing.

00:47:12.616 --> 00:47:15.366
So, how can we render WebGL
if no JavaScript is executing?

00:47:16.526 --> 00:47:20.126
Well, but then if I start
moving the mouse over the page,

00:47:20.656 --> 00:47:24.306
and selecting things and
dragging and bringing up menus,

00:47:24.766 --> 00:47:28.136
now, JavaScript is executing
a whole bunch, except,

00:47:28.356 --> 00:47:30.506
it's responding to all these
events that are happening.

00:47:30.506 --> 00:47:35.126
It's executing asynchronously
hundreds of times a second.

00:47:35.256 --> 00:47:37.736
So, in one of those little
JavaScript executions,

00:47:37.766 --> 00:47:41.226
you could do some drawing, but
you probably shouldn't draw

00:47:41.806 --> 00:47:44.556
in every single EventHandler
that's called

00:47:44.806 --> 00:47:46.306
because that'd just be crazy.

00:47:46.306 --> 00:47:49.816
You'd be drawing-trying to draw
hundreds of times a second.

00:47:50.306 --> 00:47:53.246
That can't possibly work because
drawing takes a long time

00:47:53.246 --> 00:47:55.126
compared to how quickly
these events would normally

00:47:55.126 --> 00:47:55.706
be handled.

00:47:56.116 --> 00:47:59.706
You can only get bits to the
screen 60 times a second.

00:48:00.146 --> 00:48:02.236
So basically, you just
slow down responsiveness.

00:48:02.236 --> 00:48:04.186
You'd start chewing
through CPU and battery life

00:48:04.186 --> 00:48:06.886
and you wouldn't even
gain anything out of it.

00:48:07.756 --> 00:48:10.056
But there are times when
you might want to draw

00:48:10.056 --> 00:48:12.376
in direct response to
one of these events.

00:48:12.376 --> 00:48:15.586
Imagine if you're rendering
a 3D button using WebGL

00:48:15.586 --> 00:48:16.676
and the user clicks on it.

00:48:17.426 --> 00:48:20.126
You might immediately
want to redraw your scene

00:48:20.166 --> 00:48:21.216
to update the state there.

00:48:21.786 --> 00:48:23.626
That's great; that makes sense.

00:48:24.106 --> 00:48:26.796
If you have a complex scene
that is animating a lot

00:48:26.796 --> 00:48:30.216
of geometry though, you probably
want a smooth animation.

00:48:30.396 --> 00:48:33.866
You probably are going for that
60 frames per second animation.

00:48:34.496 --> 00:48:37.726
Now to get that, I can tell
you one steadfast rule:

00:48:39.056 --> 00:48:40.656
please don't use timers!

00:48:41.526 --> 00:48:44.936
JavaScript timers are a way
to execute a chunk of code

00:48:44.936 --> 00:48:47.946
at some point in the future
that's based on a time delay.

00:48:49.236 --> 00:48:51.416
This, it turns out,
is not appropriate

00:48:51.416 --> 00:48:53.186
for rendering animations.

00:48:54.166 --> 00:48:56.876
One example where
it's inappropriate is

00:48:56.876 --> 00:48:59.626
that the system might be under
load and you might not be able

00:48:59.626 --> 00:49:01.386
to keep up with 60
frames per second.

00:49:01.636 --> 00:49:04.386
So, if you set a timer to
run 60 frames per second,

00:49:04.646 --> 00:49:07.516
not knowing the system is under
load, you're going to be trying

00:49:07.516 --> 00:49:11.146
to draw more often than your
drawing can be presented

00:49:11.146 --> 00:49:11.846
onto the screen.

00:49:12.706 --> 00:49:14.466
This is just wasteful.

00:49:14.606 --> 00:49:18.106
It's going to waste CPU, heat
up the user's mobile device,

00:49:18.106 --> 00:49:21.946
burn through the battery.

00:49:22.076 --> 00:49:23.276
So, what can we use instead?

00:49:24.756 --> 00:49:27.426
There's an API specifically
for drawing

00:49:28.466 --> 00:49:30.266
that you should use
instead of timers

00:49:30.336 --> 00:49:32.136
and it's called
requestAnimationFrame().

00:49:33.686 --> 00:49:35.476
Much like a timer,
you pass a callback

00:49:35.476 --> 00:49:36.716
to request animation frame.

00:49:38.216 --> 00:49:40.196
So that's the first
thing you do to use it.

00:49:40.746 --> 00:49:42.146
Now, when is your
callback called?

00:49:42.916 --> 00:49:48.286
Your callback is invoked when
WebKit Safari or the application

00:49:48.286 --> 00:49:51.456
that runs WebKit, knows
that it's time to draw.

00:49:51.876 --> 00:49:54.816
So, if the system load is light

00:49:55.236 --> 00:49:57.646
and your drawing is
simple enough, you can keep

00:49:57.646 --> 00:49:59.066
up that 60 frames a second,

00:49:59.346 --> 00:50:02.966
so requestAnimationFrame() will
be called 60 times a second.

00:50:03.046 --> 00:50:05.156
If the system is under a
little bit of a heavier load

00:50:05.306 --> 00:50:06.616
and you can't keep up with that,

00:50:06.806 --> 00:50:09.796
it'll call request-it'll call
your callback less often.

00:50:10.916 --> 00:50:13.726
If your web content is in
a background tab in Safari,

00:50:13.806 --> 00:50:17.376
for example, or the canvas
your WebGL is painting

00:50:17.376 --> 00:50:21.386
into is offscreen, request
animation frame might be called

00:50:21.576 --> 00:50:24.736
much less often or not at
all because WebKit knows

00:50:24.986 --> 00:50:28.666
that drawing a scene that
can't be seen is not important.

00:50:29.156 --> 00:50:34.206
So, here, we have a
drawingCallback function

00:50:35.446 --> 00:50:38.476
and we set it up to be called
by calling requestAnimationFrame

00:50:38.786 --> 00:50:39.606
with the drawingCallback.

00:50:41.896 --> 00:50:44.146
Inside our callback,
we do some drawing.

00:50:45.376 --> 00:50:47.306
This can be updating
physics based on the amount

00:50:47.306 --> 00:50:49.736
of time that's passed,
responding to queued

00:50:49.736 --> 00:50:52.786
up user events that we've logged
as the user was moving the mouse

00:50:52.786 --> 00:50:55.126
around and pressing
keys and such,

00:50:55.316 --> 00:50:58.006
and then we can draw
the individual elements

00:50:58.006 --> 00:51:00.356
for our scene: the
compass, other entities,

00:51:00.416 --> 00:51:01.506
the terrain in the background.

00:51:02.206 --> 00:51:04.346
And then when we're
done drawing,

00:51:04.886 --> 00:51:06.236
we request the next callback.

00:51:07.536 --> 00:51:10.586
We're telling WebKit, "Hey,
we finished drawing one frame.

00:51:11.066 --> 00:51:14.286
Now it's time for me to be told
when to draw the next frame."

00:51:14.806 --> 00:51:18.126
And that's it.

00:51:23.676 --> 00:51:25.326
So, that's all we
have to talk about,

00:51:25.326 --> 00:51:28.506
about these nitty-gritty
topics, the code

00:51:28.866 --> 00:51:31.116
and how things fit together
with the web platform,

00:51:31.386 --> 00:51:32.976
but I want to show
you one final demo.

00:51:33.716 --> 00:51:35.846
I'll call it the
requestAnimationFrame() demo

00:51:35.846 --> 00:51:39.666
because this demo certainly does
use requestAnimationFrame().

00:51:40.296 --> 00:51:42.506
But it also uses
a whole lot more.

00:51:43.246 --> 00:51:46.186
So, our friends at
Epic Games were happy

00:51:46.186 --> 00:51:49.196
to let us use this demo
from the Unreal Engine,

00:51:49.716 --> 00:51:53.326
and this is just a really cool
little temple thing we have.

00:51:53.366 --> 00:51:54.926
Let me go ahead and
take it full screen.

00:51:55.506 --> 00:51:57.716
So, this is rendering in Safari.

00:51:57.716 --> 00:51:59.556
This is executing JavaScript.

00:52:00.106 --> 00:52:04.546
This is executing Fragment
Shaders and Vertex Shaders,

00:52:05.066 --> 00:52:10.066
and what we're seeing
is just amazing.

00:52:11.216 --> 00:52:13.096
So, there's a lot going on here.

00:52:13.096 --> 00:52:15.596
We have light, reflection.

00:52:15.686 --> 00:52:18.066
A lot of these surfaces
are really interesting:

00:52:18.066 --> 00:52:19.126
marble and glass.

00:52:19.126 --> 00:52:22.396
We have fire casting
reflections and light.

00:52:23.296 --> 00:52:26.226
As we move around, you can
see the background scene being

00:52:26.226 --> 00:52:28.206
reflected off the shiny walls.

00:52:28.706 --> 00:52:31.896
Let's climb these
stairs over here.

00:52:31.896 --> 00:52:37.226
So, as I enter this
hallway-let me go back

00:52:37.226 --> 00:52:38.596
and forth just a few times,

00:52:38.596 --> 00:52:41.836
I love this-you can see this
orange reflection on the wall.

00:52:42.326 --> 00:52:44.236
So, I'm wondering where
that orange is coming from.

00:52:44.626 --> 00:52:46.336
Something also interesting
is you see this room

00:52:46.336 --> 00:52:49.626
over here is a lot brighter,
the engine is doing HDR

00:52:49.626 --> 00:52:52.426
for dynamic lighting
effects to great effect.

00:52:53.066 --> 00:52:58.936
So, we can see that these
fires on these podiums here,

00:52:58.936 --> 00:53:01.026
they are casting
shadows into the hallway.

00:53:01.026 --> 00:53:03.306
Here's more examples
of the HDR contrast.

00:53:03.616 --> 00:53:04.776
I mean, there's a bright room,

00:53:04.776 --> 00:53:06.416
so it's dark off
in the distance.

00:53:08.976 --> 00:53:12.306
This is millions of
triangles, millions of vertices.

00:53:12.716 --> 00:53:15.266
It was generated with some
pretty advanced tools,

00:53:16.456 --> 00:53:19.626
but then the actual code
that drives it isn't nearly

00:53:19.626 --> 00:53:21.596
as advanced as the
data that's coming in.

00:53:21.946 --> 00:53:24.196
It's just relying on the
power of GL and the power

00:53:24.196 --> 00:53:28.236
of the web platform to do
previously impossible things,

00:53:28.876 --> 00:53:32.796
using the tools of
the web platform.

00:53:32.796 --> 00:53:36.196
And to wrap us up, I'd like to
invite my colleague Dean back

00:53:36.196 --> 00:53:36.626
on stage.

00:53:37.516 --> 00:53:43.706
[ Applause ]

00:53:44.206 --> 00:53:44.716
>> Thanks, Brady.

00:53:44.836 --> 00:53:46.686
That's pretty awesome and,
like I said at the start,

00:53:46.686 --> 00:53:49.416
WebGL is insanely fun
technology to play with.

00:53:49.766 --> 00:53:51.386
So, while you might
not get quite

00:53:51.386 --> 00:53:53.766
to the Unreal Engine straight
away, you can certainly play

00:53:53.766 --> 00:53:57.036
with stuff right away and
get some amazing input.

00:53:57.726 --> 00:53:58.666
Let's wrap up.

00:53:58.666 --> 00:54:00.586
So, WebGL provides rich, fast,

00:54:00.586 --> 00:54:02.586
powerful graphics
inside the web browser.

00:54:03.326 --> 00:54:08.876
It's available in Safari, on
both OS X Yosemite and iOS 8.

00:54:10.226 --> 00:54:13.766
And it's also available in the
modern WebKit API, WKWebView,

00:54:13.766 --> 00:54:14.656
if you're a developer.

00:54:15.546 --> 00:54:18.126
With that, I want to
tell you-direct you

00:54:18.126 --> 00:54:18.976
to more information.

00:54:18.976 --> 00:54:21.696
There's an email address you
can get for contact with Apple.

00:54:21.696 --> 00:54:23.616
There's a few websites
and, of course,

00:54:23.616 --> 00:54:26.016
WebKit is an open source
project so you can follow along

00:54:26.016 --> 00:54:27.826
with that development
on webkit.org.

00:54:28.726 --> 00:54:31.106
There's some related
sessions: the one yesterday

00:54:31.106 --> 00:54:32.156
on the modern WebKit API,

00:54:32.156 --> 00:54:34.396
which is definitely
worth checking out,

00:54:34.746 --> 00:54:37.806
and we've got one tomorrow
on the Web Inspector

00:54:37.806 --> 00:54:40.406
and Modern JavaScript which, of
course, is important to WebGL.

00:54:40.606 --> 00:54:42.506
And we're looking forward
to seeing whatever you do.

00:54:42.506 --> 00:54:43.846
Have a great rest
of the conference.

00:54:44.516 --> 00:54:49.640
[ Applause ]
WEBVTT

00:00:21.806 --> 00:00:24.206
>> Good morning-ish.

00:00:25.026 --> 00:00:28.846
My name is Andy, and I'm here
to talk about Motion Processing.

00:00:29.216 --> 00:00:29.786
So welcome.

00:00:29.786 --> 00:00:32.806
We're going to start
with some definitions.

00:00:33.196 --> 00:00:36.436
We'll flesh out that
term "motion processing"

00:00:36.896 --> 00:00:39.756
by giving you a description of
the features that comprise it.

00:00:40.606 --> 00:00:43.866
We'll talk about how they work,
as well as how well they work.

00:00:45.526 --> 00:00:49.106
We'll give you some ideas on how
to use it in your application.

00:00:49.186 --> 00:00:54.486
We'll help answer some questions
about when should I use one

00:00:54.646 --> 00:00:56.776
or the other, what
interface should I use,

00:00:57.176 --> 00:01:01.146
and how can I use it with
other services from the OS?

00:01:01.596 --> 00:01:04.525
From this very high level then
we'll dive into the details

00:01:04.525 --> 00:01:07.386
of the interface,
we'll talk about usage,

00:01:07.386 --> 00:01:11.826
we'll deconstruct
the data objects

00:01:11.826 --> 00:01:13.366
so that you can know
better what to expect,

00:01:13.426 --> 00:01:15.716
and finally we'll
reiterate the main points

00:01:16.066 --> 00:01:17.226
with a coding exercise.

00:01:17.816 --> 00:01:21.216
Now before I go any further,
I do want to apologize

00:01:21.276 --> 00:01:22.706
because I've been standing

00:01:22.706 --> 00:01:25.586
up here saying motion
processing, motion processing.

00:01:26.136 --> 00:01:26.736
It's vague.

00:01:27.566 --> 00:01:30.336
The title of this track
is "Motion Tracking",

00:01:31.376 --> 00:01:33.786
and this session is not Gaming,

00:01:34.556 --> 00:01:37.696
so there's probably a
huge number of you who are

00:01:37.696 --> 00:01:40.206
in here thinking that you're
going to learn all about how

00:01:40.206 --> 00:01:42.926
to track a person's
motion in a gaming context.

00:01:44.076 --> 00:01:50.926
This is not that talk, so
nevertheless I hope you'll stick

00:01:50.926 --> 00:01:53.086
around because there's a
lot of really neat things

00:01:53.086 --> 00:01:55.996
that we're going to
reveal and hopefully even

00:01:55.996 --> 00:01:58.956
if you weren't planning
to use this,

00:01:58.956 --> 00:02:00.306
at least it'll spark some ideas

00:02:00.306 --> 00:02:03.336
on how you can perhaps develop
the next great app with this.

00:02:03.496 --> 00:02:05.726
So, with that, let's go on.

00:02:06.166 --> 00:02:09.205
The biggest thing that happened
since the last time we talked,

00:02:09.846 --> 00:02:14.056
Core Motion, has been the advent
of the M7 Motion Coprocessor.

00:02:14.986 --> 00:02:19.206
This is an ultra-efficient
microcontroller that we use

00:02:19.266 --> 00:02:22.576
to essentially manage all
of our sensory interaction.

00:02:23.046 --> 00:02:26.066
It's really cool, but for
the purposes of this talk,

00:02:26.066 --> 00:02:30.306
I'm really just going to focus
about how we combine the M7

00:02:30.306 --> 00:02:33.016
with an electron
sipping accelerometer

00:02:33.446 --> 00:02:37.926
to give you motion awareness,
constant motion awareness,

00:02:38.256 --> 00:02:40.746
with no noticeable
impact on battery life.

00:02:41.846 --> 00:02:44.596
How efficient is our
motion processing system?

00:02:45.356 --> 00:02:50.436
You get 24 hours of
motion activity pedometer

00:02:51.006 --> 00:02:56.366
for about three minutes
of a FaceTime call.

00:02:57.186 --> 00:02:58.636
So what can you do
with motion activity?

00:02:58.636 --> 00:03:02.746
I think that when you're talking
about a mobile application,

00:03:03.366 --> 00:03:05.796
where you have limited
real estate,

00:03:06.606 --> 00:03:11.006
you have limited bandwidth, and
the user is always in a hurry,

00:03:11.826 --> 00:03:15.116
context is key, right?

00:03:16.026 --> 00:03:19.796
It's the filter that
allows you to filter

00:03:19.796 --> 00:03:21.446
out the nonessential information

00:03:21.446 --> 00:03:24.066
so that the really important
stuff just comes to the top

00:03:24.776 --> 00:03:27.146
and it allows the user
to connect the dots

00:03:27.816 --> 00:03:29.976
so that they can bridge
missing information.

00:03:30.766 --> 00:03:32.826
It allows you to
relate information

00:03:32.886 --> 00:03:35.896
from disparate sources so that
you can recognize patterns,

00:03:35.896 --> 00:03:36.096
right?

00:03:36.746 --> 00:03:41.016
Now I don't have to convince
you of how important location is

00:03:41.346 --> 00:03:44.466
as a context, it's intuitive and
you're all aware of that, right?

00:03:44.776 --> 00:03:47.646
I do a search for
cafes in London,

00:03:48.146 --> 00:03:51.246
I would expect different results
if I had initiated that search

00:03:51.426 --> 00:03:54.876
in Ohio versus England, right?

00:03:56.096 --> 00:03:59.446
Time is a context.

00:03:59.446 --> 00:04:05.086
Activity is similarly very, very
powerful as a context, right?

00:04:05.366 --> 00:04:07.816
And that's what we're
here to give you,

00:04:08.246 --> 00:04:13.176
the ability to know the
user's motion at any time

00:04:13.606 --> 00:04:17.726
so that you can frame
the context.

00:04:17.726 --> 00:04:21.755
So not all activities are going
to be detected in the same way,

00:04:22.055 --> 00:04:23.916
there are going to be
differences, and I want you

00:04:23.916 --> 00:04:25.236
to be aware of that
because that's going

00:04:25.236 --> 00:04:26.876
to drive different use cases.

00:04:27.146 --> 00:04:29.726
Different activities are
going to be better suited

00:04:29.966 --> 00:04:33.826
for different ways or
different applications.

00:04:33.876 --> 00:04:34.956
So please be aware.

00:04:34.956 --> 00:04:37.076
And then when we talk about
performance we're really going

00:04:37.076 --> 00:04:38.526
to evaluate on three things.

00:04:38.886 --> 00:04:42.746
We're going to look at detection
accuracy, we're going to talk

00:04:42.746 --> 00:04:45.906
about the latency of
detection and then, finally,

00:04:45.906 --> 00:04:49.436
we're going to talk about the
robustness, how sensitive are we

00:04:49.956 --> 00:04:53.236
to differences in, say,
the device location

00:04:53.466 --> 00:04:54.976
or situational differences.

00:04:54.976 --> 00:04:56.456
So, again, please
bear this in mind.

00:04:56.786 --> 00:05:00.126
And when I start talking about
the performance in a little bit,

00:05:00.126 --> 00:05:01.666
I'm going to stay
very qualitative.

00:05:02.076 --> 00:05:04.576
I will give you some
numbers, but the intent is not

00:05:04.576 --> 00:05:06.766
to give you precise
numbers and not

00:05:06.766 --> 00:05:10.056
to compare the performance
to our competitors.

00:05:10.056 --> 00:05:14.386
We are very proud that we have
industry leading performance,

00:05:14.386 --> 00:05:17.456
but we do encourage you, I
encourage you to please go out

00:05:17.456 --> 00:05:19.526
and test for yourself
and quantify

00:05:19.526 --> 00:05:22.766
for yourself how well
this will work for you

00:05:23.686 --> 00:05:25.306
when you get the final seed.

00:05:25.406 --> 00:05:27.036
So, with that, let's go
ahead and get started.

00:05:27.706 --> 00:05:29.476
The first activity
I'm going to talk

00:05:29.476 --> 00:05:30.866
about is the walking activity.

00:05:31.306 --> 00:05:34.686
This is something that
most people do every day,

00:05:34.686 --> 00:05:37.296
it occurs quite often, so
you're going to see this a lot.

00:05:37.296 --> 00:05:39.376
When we talk about
the performance

00:05:39.756 --> 00:05:42.426
and how the performance
changes across location,

00:05:42.796 --> 00:05:44.466
it's very, very robust.

00:05:44.466 --> 00:05:46.246
When you're walking,
we're going to detect it,

00:05:46.246 --> 00:05:48.816
and it doesn't really matter
if the device is in the pocket,

00:05:48.856 --> 00:05:52.466
on the waist, on the
arm, or even in hand.

00:05:52.586 --> 00:05:56.786
Now I do want to caution,
though, that when a person -

00:05:56.786 --> 00:06:00.046
it is possible that a
person could hold a device

00:06:00.226 --> 00:06:03.066
so steady while they're walking,
such as when they're trying

00:06:03.066 --> 00:06:06.456
to read a text or so on, so that
you can fall out of walking,

00:06:06.776 --> 00:06:08.276
but again they're
not going to do

00:06:08.276 --> 00:06:10.276
that over the entire
walk so that's okay.

00:06:11.116 --> 00:06:15.896
In terms of latency, it's
fairly low, 5 to 10 seconds.

00:06:16.386 --> 00:06:17.546
If it's in my pocket
and I get up

00:06:17.546 --> 00:06:19.106
and I start walking
it's going to detect

00:06:19.176 --> 00:06:20.986
that in about 3 to 5 seconds.

00:06:21.216 --> 00:06:24.416
It's going to take longer, as
I said, if it's in the hand

00:06:24.416 --> 00:06:25.836
or the user is fiddling
with that.

00:06:25.836 --> 00:06:28.106
So that should be
your expectation.

00:06:28.106 --> 00:06:31.796
In terms of accuracy
it's very accurate.

00:06:32.116 --> 00:06:33.346
You walk, we're going
to detect it.

00:06:33.346 --> 00:06:35.636
And I'm going to say
it's accurate on average

00:06:35.686 --> 00:06:37.786
because you can expect
that you're going

00:06:37.786 --> 00:06:41.096
to intermittently fall into
and out of the walking state,

00:06:41.376 --> 00:06:43.286
but again that's okay, right,

00:06:43.286 --> 00:06:46.236
because that's actually
the situation

00:06:46.576 --> 00:06:48.286
that the user finds himself in.

00:06:48.646 --> 00:06:51.636
Let me explain what
I mean by that.

00:06:51.926 --> 00:06:54.606
When you get up and
you walk a lot

00:06:54.606 --> 00:06:57.606
of times you may get
distracted or you may stop, say,

00:06:57.606 --> 00:06:59.886
to open a door, or
somebody stops you to chat.

00:07:00.306 --> 00:07:03.836
And so as you stop and as you
start you're going to fall into

00:07:03.836 --> 00:07:06.666
and out of the walking state,
and so the application,

00:07:06.956 --> 00:07:09.846
going back later in time
to look at say the query,

00:07:09.846 --> 00:07:13.256
the history of transitions
between the start of the walk

00:07:13.256 --> 00:07:15.716
and the end of the walk you'll
see that it's mostly walk

00:07:15.926 --> 00:07:19.566
and sometimes you'll be in a
non-walking state, but again,

00:07:19.566 --> 00:07:22.826
that's okay and as long as
you expect that and deal

00:07:22.826 --> 00:07:24.446
with that appropriately
it should be okay.

00:07:25.286 --> 00:07:27.986
But what does that mean for
how you can use walking?

00:07:29.896 --> 00:07:32.466
You should use walking,
if you're thinking

00:07:32.466 --> 00:07:36.286
about using walking as a
context in the here and now,

00:07:37.316 --> 00:07:38.626
you'll want to be
careful about that

00:07:38.716 --> 00:07:41.986
because walking is not
a context here and now,

00:07:42.536 --> 00:07:46.786
walking is a context over the
past say 30 seconds, right?

00:07:47.046 --> 00:07:50.326
If I've been walking for the
past 30 seconds I'm walking,

00:07:50.986 --> 00:07:52.966
but I could be instantaneously
stopped.

00:07:52.966 --> 00:07:59.076
I think walking might be better
suited to use as a transition,

00:07:59.076 --> 00:08:01.876
and I'll talk a little bit
later in the presentation,

00:08:01.876 --> 00:08:03.946
it'll be more apparent
what I mean by transition,

00:08:04.286 --> 00:08:07.556
but walking is how we
go from A to B, right?

00:08:07.746 --> 00:08:10.256
And so if you keep that
in mind it'll be a very,

00:08:10.256 --> 00:08:11.566
very powerful tool for you

00:08:11.566 --> 00:08:15.766
to help infer what the
situational context was.

00:08:16.186 --> 00:08:17.296
All right, next is running.

00:08:17.606 --> 00:08:18.486
Running is really great.

00:08:19.286 --> 00:08:21.796
Again, in terms of robustness,

00:08:21.796 --> 00:08:24.466
it doesn't matter
where you hold it.

00:08:24.596 --> 00:08:26.746
We're going to detect
running, and it's going

00:08:26.746 --> 00:08:28.456
to be pretty uniform
in the performance.

00:08:28.686 --> 00:08:30.056
What's great about running is

00:08:30.096 --> 00:08:34.275
that not only is the
signal very, very vivid,

00:08:34.756 --> 00:08:37.346
in other words, it allows
us to quickly detect

00:08:37.346 --> 00:08:39.186
that a person is running.

00:08:39.186 --> 00:08:42.236
You take a handful of
steps, a handful of steps,

00:08:42.236 --> 00:08:43.405
and we're going to
detect running.

00:08:44.166 --> 00:08:46.226
So not only is it
very, very vivid,

00:08:46.736 --> 00:08:49.516
but there is no situational
ambiguity.

00:08:49.886 --> 00:08:53.906
If a person runs they
really mean it, right?

00:08:54.276 --> 00:08:56.216
They're not going to
multitask while they run,

00:08:56.216 --> 00:08:58.206
as like they do while
they're walking, right?

00:08:58.206 --> 00:09:01.216
When they're running they're
not going to log into Facebook

00:09:01.216 --> 00:09:02.976
and change their
relationship status,

00:09:03.256 --> 00:09:05.236
they're just going to run.

00:09:05.296 --> 00:09:08.796
And when they stop it's not
because they saw something shiny

00:09:08.796 --> 00:09:10.636
on the side of the road
and just got distracted.

00:09:10.636 --> 00:09:12.336
No, they stop because
they meant to stop.

00:09:13.166 --> 00:09:18.426
So as a context in the here

00:09:19.346 --> 00:09:22.566
and now running is
very, very great, right?

00:09:22.986 --> 00:09:26.546
Short in terms of latency;
very, very short in terms

00:09:26.546 --> 00:09:29.476
of detection; very, very
accurate; and in terms

00:09:29.476 --> 00:09:32.806
of robustness completely
robust, so think about that,

00:09:32.886 --> 00:09:34.216
just think about how
you'd want to use that.

00:09:34.966 --> 00:09:37.226
We've already talked
about the accuracy.

00:09:37.226 --> 00:09:42.986
So let's go on to driving,
driving is different

00:09:42.986 --> 00:09:46.316
from running and walking because
the motion signature is more

00:09:46.316 --> 00:09:48.386
subtle, and because
it's more subtle.

00:09:48.786 --> 00:09:53.306
The more coupled the device
is to the vehicle dynamics,

00:09:53.686 --> 00:09:56.076
the more likely it
is that we'll be able

00:09:56.156 --> 00:09:58.796
to detect the driving
state much more quickly.

00:09:58.796 --> 00:10:02.176
So if the user were to, say, get
in the car and put the device

00:10:02.636 --> 00:10:05.836
on the dash, in the cup holder,
perhaps mounted, that's fine.

00:10:06.026 --> 00:10:07.386
As soon as they drive
off we're going

00:10:07.386 --> 00:10:08.476
to be able to detect driving.

00:10:09.256 --> 00:10:13.176
Conversely, if the user
were to, say, have the phone

00:10:13.176 --> 00:10:16.116
in their back pocket, and
it would take a lot longer

00:10:16.556 --> 00:10:21.776
to detect driving,
but again that's fine

00:10:22.046 --> 00:10:24.216
because eventually
we'll detect driving,

00:10:24.466 --> 00:10:29.176
and if you use driving as,
again, defining a transition

00:10:29.236 --> 00:10:31.336
or if we were going to
use that with walking,

00:10:31.336 --> 00:10:34.916
I'll show you again later in
the presentation how you want

00:10:34.916 --> 00:10:38.206
to do that, you can make up
for some of these challenges

00:10:38.716 --> 00:10:40.906
from observing things
strictly through motion.

00:10:41.196 --> 00:10:48.576
Now the latency, again, is
variable, as I just described.

00:10:49.096 --> 00:10:52.776
Now what's really cool is that
we're going to use information

00:10:52.776 --> 00:10:55.896
from other sources as
it becomes available.

00:10:56.016 --> 00:10:58.166
Without really going into
details what it really means is

00:10:58.166 --> 00:11:03.376
that if you get in your
car, you plug your device in

00:11:03.746 --> 00:11:06.476
or you have Bluetooth
or so on and so forth,

00:11:06.476 --> 00:11:10.116
it's going to be able to detect
your driving state pretty

00:11:10.116 --> 00:11:12.616
quickly, so that's really cool.

00:11:12.696 --> 00:11:15.626
Cycling is new, something
we introduced in iOS 8.

00:11:16.246 --> 00:11:22.726
Cycling is very challenging,
and again you need the dynamics

00:11:22.726 --> 00:11:25.106
and so it's going to be
very sensitive to location.

00:11:25.106 --> 00:11:28.656
If it was mounted on the
upper arm the latency is going

00:11:28.656 --> 00:11:30.396
to be fairly reasonable.

00:11:30.546 --> 00:11:33.446
And if it's anywhere else, it's
going to take a lot longer.

00:11:33.446 --> 00:11:37.906
So definitely I would not
suggest using cycling activity

00:11:37.906 --> 00:11:41.716
classification as a hint for
the context here and now.

00:11:41.976 --> 00:11:44.306
It's really something
that you'll want to use

00:11:44.346 --> 00:11:47.946
in a retrospective manner for
a journaling app, for example.

00:11:48.136 --> 00:11:51.016
This would be a perfect
use case for that, right?

00:11:51.276 --> 00:11:53.356
So that's motion activity.

00:11:53.526 --> 00:11:56.846
Now I want to talk a little
bit about the pedometer.

00:11:57.696 --> 00:12:02.116
For the pedometer you have two
things, you have step counts

00:12:02.796 --> 00:12:06.256
and you have the stride
estimate, how long is your step.

00:12:07.026 --> 00:12:12.546
With step counting there is
a surprising amount of value

00:12:12.626 --> 00:12:15.266
in just the user knowing
their step count, right?

00:12:15.486 --> 00:12:18.616
There's a lot of research
already out there that suggests

00:12:18.656 --> 00:12:21.476
that at least for sedentary,

00:12:21.536 --> 00:12:23.396
for people with a very
sedentary lifestyle,

00:12:23.396 --> 00:12:26.616
the best thing they can do for
themselves is to just to get up

00:12:26.616 --> 00:12:29.646
and walk, just take steps.

00:12:29.646 --> 00:12:35.036
And we know that, say, the
average American only takes

00:12:35.036 --> 00:12:39.096
around 5,100 steps a day.

00:12:39.326 --> 00:12:43.256
If you are from Switzerland,
Western Australia,

00:12:43.256 --> 00:12:46.326
interestingly, you'll
take about 9,500 steps.

00:12:47.096 --> 00:12:50.506
And so what you see here
is a great opportunity,

00:12:50.896 --> 00:12:53.576
it's a great opportunity
to provide something

00:12:53.826 --> 00:12:57.436
that will really help users
improve their quality of life,

00:12:57.436 --> 00:13:01.456
just knowing that I want to
target 7,500 to 9,000 steps or,

00:13:01.456 --> 00:13:04.016
if I want to be more active,
try to get over 10,000,

00:13:04.246 --> 00:13:05.666
and giving me constant feedback

00:13:05.806 --> 00:13:08.786
about how I'm doing,
that would be great.

00:13:09.656 --> 00:13:13.526
I think that would just
really make a whole world

00:13:13.526 --> 00:13:13.986
of difference.

00:13:14.606 --> 00:13:19.936
But if you wanted more than just
step counts and just wanted more

00:13:19.936 --> 00:13:23.156
than knowing how active you are,

00:13:23.226 --> 00:13:26.386
then stride estimation gives
you more quantitative results,

00:13:26.386 --> 00:13:26.616
right?

00:13:26.926 --> 00:13:32.956
With stride estimation we can
tell how far your walk was,

00:13:32.956 --> 00:13:35.826
and so if you were to like,
say, initiate an activity,

00:13:36.076 --> 00:13:39.106
go out and hike, go out and
run, we would be able to say

00:13:39.276 --> 00:13:41.436
at the end of it that
you ran four miles

00:13:41.506 --> 00:13:43.416
or that you hiked
three-and-a-half miles.

00:13:43.906 --> 00:13:49.106
And then, also, if you were to
look at how we do, the user ran

00:13:49.386 --> 00:13:53.126
or hiked in short bursts then
you can see the intensity

00:13:53.126 --> 00:13:54.646
of the workout, and
again that is something

00:13:54.646 --> 00:13:57.056
that is very interesting
and very powerful

00:13:57.206 --> 00:13:59.296
to present to the user, right?

00:13:59.296 --> 00:14:02.236
Now you can argue that you
could do this with GPS,

00:14:03.606 --> 00:14:07.006
and while that's true,
the attendant power cost

00:14:07.006 --> 00:14:11.826
in GPS is literally 100
times greater than the power

00:14:11.826 --> 00:14:14.466
of the speedometer, the energy
cost of the speedometer.

00:14:14.466 --> 00:14:18.186
So you can give, what if you
can give the same performance

00:14:18.326 --> 00:14:21.776
in terms of the distance
without that power,

00:14:22.066 --> 00:14:24.586
and what if you can give
the same performance

00:14:24.976 --> 00:14:29.926
in that distance no matter,
say, the GPS conditions,

00:14:29.926 --> 00:14:32.526
whether it's urban,
canyons, trail hiking,

00:14:33.176 --> 00:14:36.846
or suburban streets, you
get the same performance,

00:14:37.246 --> 00:14:37.896
wouldn't that be cool?

00:14:39.106 --> 00:14:41.966
So talk a little bit then

00:14:41.966 --> 00:14:46.456
about the performance
of our pedometer.

00:14:46.856 --> 00:14:48.316
Similar to the activity
classification,

00:14:48.776 --> 00:14:52.036
the step counting is very
consistent across body location,

00:14:52.366 --> 00:14:54.946
and that's something that
we're very, very proud of.

00:14:54.946 --> 00:14:56.786
Again, it doesn't matter
whether a device is,

00:14:57.036 --> 00:14:58.406
here let's say, FitBit.

00:14:58.836 --> 00:15:04.116
The device is here, it provides
very, very good clean signature

00:15:04.286 --> 00:15:07.646
of your motion, and so
they're able to get a very,

00:15:07.646 --> 00:15:10.746
very accurate count
to your step.

00:15:11.186 --> 00:15:14.676
We're able to provide
similar levels of accuracy,

00:15:14.916 --> 00:15:17.536
but not only just, not
only here, but in the hand

00:15:17.536 --> 00:15:19.676
and everywhere else,
so that's really cool.

00:15:20.056 --> 00:15:23.216
Just talked about accuracy.

00:15:23.796 --> 00:15:27.436
Another thing that we
really focus on is we try

00:15:27.436 --> 00:15:29.446
to be robust to extraneous
inputs.

00:15:29.776 --> 00:15:33.416
It is accelerometer-based,
and so you'll see things,

00:15:33.416 --> 00:15:38.936
such as periodic inputs into the
device that will generate steps.

00:15:39.236 --> 00:15:42.676
We try very hard to
eliminate most of that,

00:15:42.676 --> 00:15:44.436
and we actually do
very, very well.

00:15:44.676 --> 00:15:47.246
Compared to our competitors,

00:15:47.306 --> 00:15:48.606
we're actually much,
much better.

00:15:48.606 --> 00:15:53.416
So try this for yourself,
get a Fitbit, hop on a bus,

00:15:53.786 --> 00:15:55.466
sit in the back of
the bus, more towards

00:15:55.466 --> 00:15:56.356
over the wheel well, right?

00:15:56.356 --> 00:15:59.506
Take it up and down the 280,
you'll see that you'll walk

00:15:59.506 --> 00:16:01.586
out of there and will have
counted, say, 1,000 steps,

00:16:02.526 --> 00:16:06.296
but again that's a
challenge of a pedometer

00:16:06.296 --> 00:16:07.776
or an accelerometer solution.

00:16:08.206 --> 00:16:15.446
So stride estimation, this is
again just like the step count,

00:16:15.756 --> 00:16:17.666
we're very insensitive
to the body location,

00:16:18.246 --> 00:16:20.306
but and this is the
really important thing,

00:16:21.096 --> 00:16:25.036
we're also insensitive
across pace.

00:16:25.776 --> 00:16:29.996
It doesn't matter if
you're running or jogging

00:16:30.446 --> 00:16:33.876
or hiking you're going
to get the same accuracy,

00:16:34.236 --> 00:16:36.376
and that same accuracy,
like I said,

00:16:36.656 --> 00:16:39.366
is pretty good, very, very good.

00:16:39.786 --> 00:16:41.416
And the other great thing
is that it's going to adapt

00:16:41.606 --> 00:16:43.516
to the user across over time.

00:16:43.766 --> 00:16:46.926
So the more they use it, the
more accurate it's going to get.

00:16:48.706 --> 00:16:52.476
So, again, I encourage you when
the final release comes out,

00:16:52.476 --> 00:16:56.766
do go try it out for yourself,
take the device, strap it on,

00:16:57.166 --> 00:16:58.536
walk around the block,

00:16:58.696 --> 00:17:00.266
maybe walk around
the block a few times

00:17:00.676 --> 00:17:01.966
and see how well we do.

00:17:03.016 --> 00:17:07.506
Okay, so how can we
use motion activity?

00:17:07.856 --> 00:17:11.526
I want to start by talking
about the different data models

00:17:11.526 --> 00:17:13.096
that we use or the
different ways

00:17:13.096 --> 00:17:14.195
that we can get the data to you.

00:17:14.556 --> 00:17:19.046
There's a notion of
push versus pull.

00:17:19.705 --> 00:17:24.116
In the push interface, we give
you events as they happen.

00:17:24.226 --> 00:17:27.356
This is our lowest latency
path, so if latency is important

00:17:27.356 --> 00:17:29.446
to you, you'll want
to use this interface.

00:17:29.446 --> 00:17:32.716
What that means is that when
motion state transitions happen,

00:17:32.716 --> 00:17:34.756
we'll let you know right away.

00:17:34.756 --> 00:17:37.696
Every two-and-a-half seconds,

00:17:38.446 --> 00:17:40.696
we'll give you the
new step count,

00:17:41.256 --> 00:17:42.376
that's the lowest latency.

00:17:42.376 --> 00:17:45.956
You can also use
the query interface,

00:17:46.156 --> 00:17:49.896
and in the query interface you
will provide a range of times,

00:17:49.986 --> 00:17:51.516
a start time and an end time.

00:17:52.016 --> 00:17:53.506
And for motion activities,

00:17:53.506 --> 00:17:56.746
we will give you basically every
transition that has happened

00:17:57.026 --> 00:17:58.636
between the start and end time.

00:17:59.186 --> 00:18:02.456
For the pedometer we'll just
give you the cumulative steps,

00:18:03.516 --> 00:18:04.746
so you'll get a single record

00:18:04.746 --> 00:18:07.296
that provides a cumulative
pedometer activity

00:18:07.336 --> 00:18:08.786
between the start and end time.

00:18:09.266 --> 00:18:13.136
So you understand latency,
but then what is the value

00:18:13.136 --> 00:18:14.056
of the query interface?

00:18:14.956 --> 00:18:17.546
For that let me talk a little
bit about the architecture,

00:18:17.636 --> 00:18:19.376
so we'll start with
the accelerometer.

00:18:19.376 --> 00:18:24.286
And as you can probably surmise
we then operate in the data

00:18:24.286 --> 00:18:25.446
at a periodic interval.

00:18:25.896 --> 00:18:27.896
I mentioned two-and-a-half
seconds earlier

00:18:27.896 --> 00:18:28.576
for the step count.

00:18:28.806 --> 00:18:31.746
It's actually what cadences
that run everything.

00:18:31.996 --> 00:18:35.976
Now I'm telling you this not so
that you set your watches by it

00:18:36.316 --> 00:18:39.696
or that you design around this,
I'm really telling you this,

00:18:39.696 --> 00:18:42.426
two-and-a-half seconds, so
that you can get an expectation

00:18:42.426 --> 00:18:44.236
for the latencies, right?

00:18:44.546 --> 00:18:48.096
And so when I say running, we
can detect that you're running

00:18:48.096 --> 00:18:50.416
in three to five
seconds, that's really,

00:18:50.416 --> 00:18:52.346
that three to five
seconds that's because of

00:18:52.346 --> 00:18:56.056
that two-and-a-half second
batch processing that we do.

00:18:56.326 --> 00:19:00.566
And really as soon as we just
look at data over that interval

00:19:00.566 --> 00:19:01.396
and you're running, we're going

00:19:01.396 --> 00:19:04.256
to know you're running
right away, right?

00:19:04.506 --> 00:19:06.546
And so this information
as it happens gets pushed

00:19:06.546 --> 00:19:08.096
to the client, and so
that's the push interface.

00:19:08.946 --> 00:19:12.926
Now what's interesting is that
we also filter the information,

00:19:12.926 --> 00:19:16.576
so we'll take all of these state
transitions in, and we'll try

00:19:16.576 --> 00:19:18.926
to fuse them with data
from other sources,

00:19:18.926 --> 00:19:20.026
and then we'll persist that.

00:19:20.316 --> 00:19:23.456
And so if an application were to
come back later in time and ask

00:19:23.456 --> 00:19:27.846
for the data, the information
is going to be more accurate

00:19:29.156 --> 00:19:32.266
and it's going to be
less intermittent.

00:19:32.266 --> 00:19:35.346
We talked about walk and how
you can start and stop, and stop

00:19:35.346 --> 00:19:36.806
and start, and start and stop.

00:19:36.936 --> 00:19:38.426
With the query interface,

00:19:38.426 --> 00:19:41.666
many of those transitions
will be smoothed out for you.

00:19:43.806 --> 00:19:49.766
So I think it might be
more tangible if I were

00:19:49.886 --> 00:19:54.036
to motivate how we use
this in an application.

00:19:54.846 --> 00:19:58.506
So let's say running, let's come
up with a running application.

00:19:58.506 --> 00:20:00.986
I mentioned running as one
of those great activities

00:20:01.396 --> 00:20:03.096
that gives you the
context here and now.

00:20:03.096 --> 00:20:04.476
I'm going to see
how we can use that.

00:20:04.966 --> 00:20:09.056
So in a running application,
I'm going to be running,

00:20:09.106 --> 00:20:11.816
so the last thing I
want to do is to mess

00:20:11.816 --> 00:20:14.156
around with the interface or
do anything with it, right?

00:20:14.346 --> 00:20:16.056
I just want to launch
it, and I just want it

00:20:16.056 --> 00:20:18.006
to understand what I'm
doing and try to react

00:20:18.266 --> 00:20:20.766
to me rather than
what I do to it.

00:20:20.766 --> 00:20:24.836
And so I wanted to automatically
change this experience,

00:20:25.776 --> 00:20:27.966
my experience as I go
through my exercise.

00:20:29.346 --> 00:20:33.496
While I'm exercising I want it
to give me constant feedback

00:20:33.906 --> 00:20:34.946
on how well I'm doing.

00:20:35.826 --> 00:20:38.646
And then it'd be nice that
once I stopped it could

00:20:38.646 --> 00:20:40.786
automatically, say,
summarize my results

00:20:40.816 --> 00:20:44.336
and present that to me, right?

00:20:44.336 --> 00:20:45.936
So, let's think about
how that could happen.

00:20:45.936 --> 00:20:47.926
So let's say I've
got this running app,

00:20:47.926 --> 00:20:50.986
I'm going to launch it,
I'm going to strap it on,

00:20:50.986 --> 00:20:52.896
and then I'm just going to
go through my stretches.

00:20:53.306 --> 00:20:56.916
Now music is a really
important part of my experience

00:20:57.286 --> 00:20:59.696
when I exercise, and so
let's say that it's going

00:20:59.696 --> 00:21:03.116
to start just playing some
kind of preprogrammed,

00:21:03.836 --> 00:21:05.886
easy listening kind of playlist.

00:21:05.886 --> 00:21:11.676
Now my stretch and my warm-up
routine, it's not constant,

00:21:11.676 --> 00:21:13.386
so some days it might
be two minutes,

00:21:13.516 --> 00:21:15.056
some days it might
be 10 minutes.

00:21:15.056 --> 00:21:18.526
And so I don't want
to design a playlist

00:21:18.526 --> 00:21:21.446
around my stretch workout,

00:21:21.446 --> 00:21:22.796
I just want to put
something in there.

00:21:23.246 --> 00:21:26.166
And then when I start
running it'd be nice

00:21:26.236 --> 00:21:29.596
if the OS detected that,
and then the app were then

00:21:29.596 --> 00:21:32.886
to quickly or just automatically
change out my playlist,

00:21:32.886 --> 00:21:34.696
so to something that's
more uptempo, right?

00:21:34.696 --> 00:21:37.766
Don't even have to think
about it, I just start running

00:21:37.766 --> 00:21:39.316
and then, boom, the
music changes.

00:21:40.046 --> 00:21:45.346
So I'm running, and now you can
imagine the Siri voice coming

00:21:45.346 --> 00:21:51.796
out over my earphone, giving me
just this great feedback, "Andy,

00:21:52.106 --> 00:21:54.726
you're doing a great
job, you're on pace

00:21:54.726 --> 00:21:57.146
for your 15-minute mile."

00:21:57.546 --> 00:22:00.496
So just stuff that gets
me really pumped up.

00:22:00.826 --> 00:22:03.836
And you can imagine I hit my
first mile and it tells me,

00:22:03.896 --> 00:22:05.416
you know, what my
split time is, right?

00:22:05.636 --> 00:22:06.736
So it's really real cool.

00:22:06.876 --> 00:22:09.636
I'm getting this constant
feedback, and then I get

00:22:09.636 --> 00:22:11.586
to the end of my
run and I slow down,

00:22:11.946 --> 00:22:13.426
and that music is
really bothering me,

00:22:13.646 --> 00:22:17.076
so it switches automatically
to a cooldown playlist,

00:22:17.416 --> 00:22:21.326
something more suited
to my walking pace now.

00:22:22.166 --> 00:22:24.056
And I don't even have to
think about it, right?

00:22:24.056 --> 00:22:25.646
It just happens, right?

00:22:25.886 --> 00:22:28.966
And then, let's say, I'm done
walking, I'm done with cooldown,

00:22:29.196 --> 00:22:33.176
and automatically just, say,
maybe it uses a query interface

00:22:33.266 --> 00:22:37.186
to loop back over how I've been
doing the past several days

00:22:37.536 --> 00:22:40.756
and compares my performance
historically,

00:22:41.036 --> 00:22:45.436
or it might summarize my
run in that particular day.

00:22:45.436 --> 00:22:51.976
So all of that basically you
can get for very little cost

00:22:51.976 --> 00:22:55.846
with the services that we're
providing you in Core Motion,

00:22:55.906 --> 00:22:56.886
so that's pretty cool.

00:22:57.656 --> 00:23:01.136
So that's an example of
a running application

00:23:01.136 --> 00:23:03.556
where you rely primarily
on the push interface,

00:23:03.556 --> 00:23:06.586
you're using context in the
here and now, but let's talk

00:23:06.586 --> 00:23:07.506
about a journaling app,

00:23:07.846 --> 00:23:09.706
where the requirements
might be different.

00:23:10.446 --> 00:23:13.326
And so what would it - why
would I want a journaling app?

00:23:13.466 --> 00:23:17.496
I think in a journaling app what
really matters to me is context

00:23:17.496 --> 00:23:18.566
and correlation, right?

00:23:18.756 --> 00:23:22.926
But I want the app
to do that for me.

00:23:23.786 --> 00:23:28.746
I want it to be able to figure
out what I was doing and where,

00:23:28.876 --> 00:23:32.706
so I'd want it to correlate
multiple sources of information.

00:23:33.116 --> 00:23:36.346
And then ideally I
would like for it

00:23:36.346 --> 00:23:38.106
to profile my physical activity,

00:23:38.106 --> 00:23:41.386
let me know how active I've
been through the past day.

00:23:42.256 --> 00:23:45.886
So, this is what my
typical day looks like,

00:23:45.886 --> 00:23:50.366
and so let's say this
journaling app would start

00:23:50.756 --> 00:23:55.066
by querying the visit monitoring
service, which is a service

00:23:55.066 --> 00:23:59.926
from the location, Core
Location, and it gives me a list

00:23:59.926 --> 00:24:01.756
of places that I've
visited throughout the day.

00:24:02.476 --> 00:24:05.846
Typically I go from home,
sometimes I go to the gym,

00:24:06.386 --> 00:24:10.126
and then of course I go to work,
and so it detects all that,

00:24:10.126 --> 00:24:12.486
and so that provides essentially
the location context.

00:24:13.496 --> 00:24:19.906
Now suppose the journaling
app also then queries

00:24:19.966 --> 00:24:22.486
for the transport context
between these points?

00:24:22.766 --> 00:24:25.866
And so looking at motion
activity it knows that, oh,

00:24:25.866 --> 00:24:29.806
I drove from home to the
gym instead of cycling

00:24:30.006 --> 00:24:34.086
and doing a solid for the
environment, just really lazy.

00:24:34.666 --> 00:24:37.196
Got to the gym, and then from
the gym I walked to work.

00:24:37.606 --> 00:24:41.136
And what if the app then
queried the pedometer,

00:24:41.626 --> 00:24:47.326
and then I could look and
see, say, how far was the walk

00:24:47.326 --> 00:24:51.566
between work and the gym and how
many steps that I took in each

00:24:51.566 --> 00:24:52.476
of those different places.

00:24:52.476 --> 00:24:56.486
And you can see here that this
presentation of these results is

00:24:56.486 --> 00:24:58.536
so much more powerful
than to, say,

00:24:58.536 --> 00:25:00.946
that I walked 5,000
steps, right?

00:25:01.206 --> 00:25:04.626
To say that I walked 5,000
steps, if I were to look back

00:25:05.206 --> 00:25:08.266
at that data, five
days or 10 days

00:25:08.266 --> 00:25:09.966
from now it would mean
very, very little to me.

00:25:10.286 --> 00:25:12.986
But if I looked at that data
and it was presented something

00:25:12.986 --> 00:25:14.326
like this I would know that, oh,

00:25:14.326 --> 00:25:19.506
on that day I lost my
keys in the morning.

00:25:20.916 --> 00:25:23.146
That's when I walked
around, all over the house.

00:25:23.276 --> 00:25:28.866
All right, so that's
some examples of how

00:25:29.046 --> 00:25:32.636
to use the services,
how to combine it

00:25:32.876 --> 00:25:35.906
with other OS services,
and the difference

00:25:35.906 --> 00:25:37.256
between a push and
a pull interface.

00:25:37.946 --> 00:25:44.256
So now let's go a little
into the, basically the API.

00:25:44.256 --> 00:25:46.986
Before I do that, I want
to talk about privacy.

00:25:46.986 --> 00:25:48.596
It's very important
to us, privacy,

00:25:48.596 --> 00:25:50.446
we treat it very,
very seriously.

00:25:51.266 --> 00:25:53.336
And so, for motion,
just like location,

00:25:53.666 --> 00:25:55.116
the user is going
to need to opt in.

00:25:55.726 --> 00:26:00.096
Now the very first time you
launch your app we're going

00:26:00.096 --> 00:26:04.476
to request access on
your behalf, and a popup,

00:26:04.476 --> 00:26:06.736
a dialogue will pop up that
looks something like this.

00:26:07.406 --> 00:26:10.986
Your app name there, and then
the user would then choose

00:26:10.986 --> 00:26:13.196
to opt in, and as
soon as the user opts

00:26:13.196 --> 00:26:19.926
in then essentially you get data
up to seven days in the past,

00:26:20.266 --> 00:26:22.366
no more than seven days,
just seven days in the past.

00:26:22.756 --> 00:26:23.826
Now it's important to note

00:26:23.826 --> 00:26:29.276
that at any time the user can
opt out, so when the user opts

00:26:29.276 --> 00:26:34.526
out then you will no longer be
authorized to receive the data,

00:26:35.046 --> 00:26:35.776
and then you'll have

00:26:35.816 --> 00:26:37.736
to basically be able
to handle that case.

00:26:38.126 --> 00:26:39.586
Sunny is going to
show you in a bit

00:26:39.586 --> 00:26:43.226
with a coding example how
you can detect that condition

00:26:43.576 --> 00:26:46.696
and how you can essentially
request for reauthorization.

00:26:47.096 --> 00:26:48.836
And so that's a bit
about privacy.

00:26:49.116 --> 00:26:50.666
Now let's go on into
actually the API.

00:26:51.006 --> 00:26:53.716
So the very first thing that
we want to talk about is the -

00:26:53.926 --> 00:26:56.496
for the activity classification
you'll want to deal

00:26:56.496 --> 00:27:00.576
with the activity manager,
so you'll get a reference

00:27:00.776 --> 00:27:03.106
to the CM activity
manager object.

00:27:03.766 --> 00:27:05.486
And the first thing
you want to do is

00:27:05.486 --> 00:27:07.976
to check whether activity
classification is available.

00:27:08.006 --> 00:27:10.036
It's pretty standard
stuff, there's not a lot

00:27:10.226 --> 00:27:12.726
of mystery there, but I'm
just pointing that out

00:27:13.026 --> 00:27:17.616
because it's just
good general hygiene.

00:27:18.256 --> 00:27:20.236
Now two ways I mentioned
to get data,

00:27:20.486 --> 00:27:21.676
there's the push and the pull.

00:27:21.676 --> 00:27:25.646
For this one, this push
interface, what you want

00:27:25.646 --> 00:27:29.246
to do is basically provide
a handler and a queue,

00:27:29.546 --> 00:27:31.876
and then we'll call you
back on that handler

00:27:32.246 --> 00:27:35.336
and we'll basically
call you back.

00:27:35.336 --> 00:27:39.026
As soon as you call that start
method we'll call you back right

00:27:39.026 --> 00:27:43.096
away, and what we're going to
give you then is the activity

00:27:43.096 --> 00:27:46.226
that the user or the device
is in at that time, okay?

00:27:46.306 --> 00:27:49.196
And then any subsequent changes

00:27:49.196 --> 00:27:53.286
after that we will then
trigger an update, right?

00:27:54.076 --> 00:27:57.226
For the push, for the
pull interface, again,

00:27:57.386 --> 00:28:00.466
you provide a start time and
an end time in the query.

00:28:00.796 --> 00:28:03.766
Now the reason why you want
to provide a queue is because,

00:28:03.766 --> 00:28:06.826
like I said before, we're going
to call you back not just once,

00:28:06.826 --> 00:28:09.526
but we're going to call you back
for every activity transition

00:28:09.856 --> 00:28:11.666
that has happened between
the start and the stop,

00:28:11.786 --> 00:28:16.746
so you'll basically get a flood
or a storm of records, okay?

00:28:17.076 --> 00:28:19.306
And it's also important to
note that the first record

00:28:19.306 --> 00:28:22.356
that you get, you'll
actually get a time

00:28:22.626 --> 00:28:25.066
that is before your requested
time, and that's okay

00:28:25.446 --> 00:28:27.126
because it's that
current activity,

00:28:27.766 --> 00:28:30.526
that's the very first activity

00:28:30.526 --> 00:28:32.396
and its start time
might be before

00:28:32.676 --> 00:28:36.476
when you asked for
it, all right?

00:28:36.476 --> 00:28:38.786
Okay, so that's pretty
straightforward.

00:28:39.486 --> 00:28:41.826
The start time and the activity,

00:28:41.826 --> 00:28:43.306
and so the
CMMotionActivityManager,

00:28:43.306 --> 00:28:46.716
you'll get a CMActivity object.

00:28:46.716 --> 00:28:50.156
Again, the start date,
not that interesting.

00:28:50.666 --> 00:28:53.906
This is what is very
interesting,

00:28:54.216 --> 00:28:55.676
in addition to the start date

00:28:55.676 --> 00:28:57.976
of the activity we'll
give you a confidence.

00:28:58.486 --> 00:29:04.646
The confidence is what you can
use to trade off the difference

00:29:04.646 --> 00:29:07.556
between accuracy - or trade
off accuracy with latency.

00:29:08.366 --> 00:29:12.676
When you start walking, you'll
get walking, low confidence,

00:29:14.056 --> 00:29:16.956
potentially medium confidence,
and then high confidence.

00:29:17.206 --> 00:29:18.246
Sometimes when we're really,

00:29:18.246 --> 00:29:20.816
really sure that you're
high confidence walking,

00:29:20.816 --> 00:29:22.596
we might skip the
ones in between,

00:29:22.596 --> 00:29:24.716
but typically the
transition is going to go

00:29:24.716 --> 00:29:26.326
from low, medium, to high.

00:29:26.616 --> 00:29:28.336
And so if you're
really, really interested

00:29:28.336 --> 00:29:30.616
in latency you may
want to react as soon

00:29:30.616 --> 00:29:33.606
as you get a low confidence
transition, but if you want

00:29:33.606 --> 00:29:36.566
to be sure that you only react

00:29:36.566 --> 00:29:37.646
to very high confidence
stuff then you want

00:29:37.646 --> 00:29:37.976
to wait, all right?

00:29:38.046 --> 00:29:44.416
Now I want to get to the actual
classifications, themselves.

00:29:44.416 --> 00:29:48.056
The classifications are
presented as a bunch of BOOLs

00:29:48.056 --> 00:29:49.746
that you're going to have
to query one at a time.

00:29:50.026 --> 00:29:52.436
So, the very first one is
this notion of stationary.

00:29:52.736 --> 00:29:57.026
Now stationary here is in the
context of motion stationary

00:29:57.406 --> 00:29:59.386
and not location
stationary, right?

00:29:59.696 --> 00:30:02.626
Here I'm on the stage, I
am location stationary,

00:30:02.966 --> 00:30:06.326
but I am not motion stationary,
so this thing is only going

00:30:06.326 --> 00:30:09.526
to be true when the
device is say on the table.

00:30:10.186 --> 00:30:13.276
These are the actual
classifications that we're going

00:30:13.276 --> 00:30:16.006
to try to make a call on -
walking, running, automotive,

00:30:16.006 --> 00:30:17.066
cycling, you already know that.

00:30:17.386 --> 00:30:19.286
Unknown, that's an
interesting one.

00:30:19.286 --> 00:30:21.616
What that represents is
essentially the state

00:30:21.616 --> 00:30:25.446
in which we don't have enough
data in order to make a call.

00:30:26.706 --> 00:30:29.566
When all of those BOOLs
are false it means

00:30:29.566 --> 00:30:30.936
that we have plenty of data,

00:30:31.636 --> 00:30:32.896
we're just not going
to make the call.

00:30:33.376 --> 00:30:40.776
Unknown is, the unknown state
there is the unknown unknown,

00:30:41.886 --> 00:30:45.706
and when they're all false
it is the known unknown.

00:30:47.796 --> 00:30:52.366
Now I know you can't appreciate
this, but I've always wanted

00:30:52.366 --> 00:30:59.086
to stand on stage and say that,
and so, check, bucket list.

00:30:59.606 --> 00:31:02.726
All right, again, so to make
these points really salient,

00:31:02.726 --> 00:31:05.386
let's go through some
example scenarios.

00:31:05.846 --> 00:31:08.556
So here we have the scenario
that the device is going to be

00:31:08.556 --> 00:31:11.566
in and then all the BOOLs and
what they're going to represent.

00:31:11.566 --> 00:31:15.056
So when the device is on
the table, like we said,

00:31:15.106 --> 00:31:17.926
it's going to be stationary and,
obviously, it's not going to be

00:31:17.926 --> 00:31:20.496
in any of those other states,
so a trivial example, right?

00:31:21.266 --> 00:31:24.286
What happens when the device
is on the runner's upper arm?

00:31:24.286 --> 00:31:28.186
In that case, running
is going to be true

00:31:28.186 --> 00:31:29.936
and everything else is
going to be false, so,

00:31:30.116 --> 00:31:31.506
again, not that interesting.

00:31:32.296 --> 00:31:35.626
This is interesting, what if
it was in the dash of a vehicle

00:31:35.626 --> 00:31:36.986
and it's idling at a stoplight?

00:31:37.866 --> 00:31:41.216
In this case the
stationary flag is true,

00:31:41.656 --> 00:31:44.946
as well as automotive
flag is true.

00:31:45.296 --> 00:31:50.576
So stationary can be -
coexist alongside the other

00:31:50.576 --> 00:31:52.976
classification states,
that's an important point.

00:31:52.976 --> 00:31:55.766
And if it was in the
in-dash of a moving vehicle,

00:31:56.006 --> 00:31:57.716
then stationary toggles
back to false,

00:31:58.096 --> 00:31:59.506
automotive still stays true.

00:32:00.626 --> 00:32:04.096
Immediately after the
reboot, this is the case

00:32:04.096 --> 00:32:06.856
where we don't have enough data
yet to make a determination,

00:32:06.856 --> 00:32:09.326
so we actually don't
know what the state is,

00:32:09.326 --> 00:32:15.966
and so that's the only time
when - oh, I jumped ahead - oh,

00:32:15.966 --> 00:32:18.156
so for this one,
this is interesting,

00:32:19.136 --> 00:32:21.626
this is when the
passenger's checking e-mail.

00:32:21.626 --> 00:32:27.436
This is because there's motion
here and it's not something

00:32:27.436 --> 00:32:30.266
that we want to classify, the
passenger or the vehicle is

00:32:30.266 --> 00:32:32.546
in the car, but the
motion suggests

00:32:32.546 --> 00:32:34.506
that we actually don't know
whether it's in the vehicle

00:32:34.506 --> 00:32:37.066
or not, so all of
this is a false.

00:32:37.066 --> 00:32:38.526
We know that you, as a driver,

00:32:38.936 --> 00:32:40.176
wouldn't be checking
your e-mail,

00:32:40.546 --> 00:32:44.616
so that's why we
have that example.

00:32:44.936 --> 00:32:46.296
Finally, the immediately

00:32:46.296 --> 00:32:48.476
after the reboot was what I
was talking about earlier.

00:32:48.786 --> 00:32:52.116
This is the only time when
the unknown flag will be true.

00:32:53.056 --> 00:32:57.786
So similar to checking the
e-mail, what if there is motion

00:32:57.786 --> 00:33:03.226
with a very strong
pattern, but like say Zumba?

00:33:03.946 --> 00:33:08.246
That one is tough
because it's periodic,

00:33:08.386 --> 00:33:11.546
so in some ways it can look a
lot like walking and running,

00:33:11.936 --> 00:33:16.476
but if it's on somebody that
is not well practiced in Zumba

00:33:16.476 --> 00:33:17.596
or whose hips don't work

00:33:17.596 --> 00:33:19.796
that way it could
look really awkward,

00:33:20.116 --> 00:33:22.896
and so from a motion signature
standpoint it's something

00:33:22.896 --> 00:33:25.556
that it's just going to stay
unknown for us for a while,

00:33:25.956 --> 00:33:27.946
but that doesn't preclude us

00:33:27.946 --> 00:33:30.366
from extending our
classifications in the future

00:33:30.656 --> 00:33:34.316
to add activities that are
interesting, all right?

00:33:34.806 --> 00:33:38.076
So, I talked earlier about
how we can use walking

00:33:38.416 --> 00:33:43.076
as essentially a transition
and how that can help us,

00:33:43.076 --> 00:33:45.206
so let me drive that point home.

00:33:45.556 --> 00:33:50.406
Let's take this example, let's
say I'm walking to my car,

00:33:50.456 --> 00:33:53.396
and so in that particular state,
walking is going to be true.

00:33:53.546 --> 00:33:57.796
I get into my car
and now I sat down,

00:33:57.796 --> 00:34:00.356
and so now walking is
no longer true and all

00:34:00.356 --> 00:34:01.136
of my flags are false.

00:34:01.136 --> 00:34:03.816
I'm essentially in
the unknown state.

00:34:03.816 --> 00:34:09.996
I start the engine and I start
driving, and I put it down

00:34:09.996 --> 00:34:12.366
and start driving, put it
down, start the engine,

00:34:12.366 --> 00:34:14.966
so it's completely stationary
now, so now stationary is true.

00:34:14.966 --> 00:34:18.646
And now I start driving,
and so automotive is true

00:34:18.866 --> 00:34:20.565
and stationary is false, right?

00:34:20.876 --> 00:34:21.706
I stop at a light.

00:34:22.646 --> 00:34:26.525
I'm still in automotive,
stationary is true.

00:34:26.926 --> 00:34:30.085
Now you can imagine that you're
going to cycle back and forth

00:34:30.085 --> 00:34:33.266
on this thing until you
actually pick the device up

00:34:33.266 --> 00:34:37.085
and now it doesn't look like
we're in automotive anymore,

00:34:37.085 --> 00:34:38.636
and then you'll go
into that empty set.

00:34:39.156 --> 00:34:44.656
What's interesting is that
in the driving context you'll

00:34:44.656 --> 00:34:48.426
basically limit cycle
among these four states

00:34:49.906 --> 00:34:52.696
without actually being
automotive equals true.

00:34:53.146 --> 00:34:57.416
You can think automotive equals
true as a hard classification,

00:34:58.646 --> 00:35:02.196
and you can think of those other
two states essentially being an

00:35:02.196 --> 00:35:05.206
inference that you're still
driving, and that you're going

00:35:05.256 --> 00:35:09.386
to stay driving until
you walk away, right?

00:35:09.386 --> 00:35:13.896
And in this case, walking
serves as a boundary condition

00:35:14.556 --> 00:35:18.796
that defines driving
in a larger context.

00:35:19.086 --> 00:35:21.526
Does that make sense?

00:35:21.526 --> 00:35:21.696
All right.

00:35:22.446 --> 00:35:25.026
That's pretty cool.

00:35:25.026 --> 00:35:27.296
All right, so now let's talk
about the pedometer API.

00:35:27.996 --> 00:35:31.856
So, again, you'll want to
check whether it's available.

00:35:31.856 --> 00:35:35.296
It's not going to be
available on all devices.

00:35:35.296 --> 00:35:37.896
We're going to, and when
I say it's not available

00:35:37.896 --> 00:35:39.486
on all devices, it's not
going to be available

00:35:39.486 --> 00:35:42.986
on all M7 devices, we're only
going to support a subset

00:35:42.986 --> 00:35:46.316
of them, so you'll want to check
which ones that are supported.

00:35:47.236 --> 00:35:51.746
All right, so similar to the
activity, the push interface,

00:35:51.746 --> 00:35:54.926
you provide a start call,

00:35:54.926 --> 00:35:56.836
and then we'll start
giving you updates.

00:35:57.176 --> 00:36:00.206
Now the one thing that I
didn't mention earlier is

00:36:00.206 --> 00:36:02.816
that we don't always
provide an update.

00:36:03.196 --> 00:36:04.186
I said earlier we were going

00:36:04.186 --> 00:36:05.666
to give you an update every
two-and-a-half seconds.

00:36:05.666 --> 00:36:06.666
Well, that's not strictly true.

00:36:07.486 --> 00:36:10.216
We'll give you an update every
two-and-a-half seconds as long

00:36:10.216 --> 00:36:11.146
as you're taking steps.

00:36:11.896 --> 00:36:13.636
As soon as you stop
taking steps,

00:36:13.696 --> 00:36:15.606
we won't give you an update,
but again that makes sense.

00:36:15.826 --> 00:36:17.496
So we'll give you an update

00:36:17.496 --> 00:36:18.886
when something interesting
is happening.

00:36:19.676 --> 00:36:22.776
What's interesting is that the
only time we violate that is

00:36:22.776 --> 00:36:25.516
when your app gets backgrounded
and it gets resumed.

00:36:25.876 --> 00:36:27.556
In that case, as soon
as you get resumed,

00:36:27.556 --> 00:36:29.926
regardless of whether
you've taken any steps

00:36:29.926 --> 00:36:31.836
or the user has taken
any steps you're going

00:36:31.836 --> 00:36:35.196
to get an immediate
update, all right?

00:36:35.196 --> 00:36:38.246
As far as the pull interface,
again, you're just going

00:36:38.246 --> 00:36:40.546
to give us start and
end, and we're just going

00:36:40.636 --> 00:36:42.296
to give you everything
that happened in between.

00:36:42.296 --> 00:36:46.266
So there's really not a
lot to say about that.

00:36:46.266 --> 00:36:50.676
Start and stop time, again,
that's going to mark the -

00:36:50.676 --> 00:36:54.706
what's interesting here is that
for the pedometer, every record

00:36:54.706 --> 00:36:58.756
that you get you'll have
the same start time,

00:36:59.396 --> 00:37:02.266
and that start time is the time

00:37:02.266 --> 00:37:05.896
when you call the
start update method.

00:37:06.846 --> 00:37:10.276
That's really, really
important, so every record

00:37:10.276 --> 00:37:12.566
that you get will have
the same start time,

00:37:12.896 --> 00:37:14.856
you'll just have a
different end time, okay?

00:37:15.406 --> 00:37:20.266
And that end time represents
basically the cumulative number

00:37:20.396 --> 00:37:24.026
of steps taken between the
start time and the end time,

00:37:24.026 --> 00:37:27.686
so you can think of every record
essentially just providing a

00:37:27.736 --> 00:37:30.636
cumulative value that
is delta increment

00:37:30.666 --> 00:37:33.436
over the previous value.

00:37:34.596 --> 00:37:37.136
The number of steps is going
to be an integer number,

00:37:37.546 --> 00:37:41.776
and one of the things
that we always get asked

00:37:41.776 --> 00:37:44.806
about is what happens if
you provide several queries,

00:37:45.256 --> 00:37:52.896
one query over say 24 hours, and
then 24 queries over an hour,

00:37:53.426 --> 00:37:55.656
should you expect to get
the same number of steps?

00:37:56.116 --> 00:37:59.436
And the answer is yes, there
might be slight differences due

00:37:59.436 --> 00:38:02.786
to rounding issues or
interpolation issues,

00:38:03.486 --> 00:38:06.096
but by and large the number
of steps should be the same.

00:38:06.946 --> 00:38:09.636
And the reason why you'd
want a large query,

00:38:10.636 --> 00:38:12.306
in addition to smaller
queries, again,

00:38:12.306 --> 00:38:13.456
it depends on your use case.

00:38:13.456 --> 00:38:14.996
If, say, for example, you know

00:38:14.996 --> 00:38:17.176
that a person left the
particular location

00:38:17.176 --> 00:38:21.016
at a certain time and ended
in a location then you want

00:38:21.016 --> 00:38:23.426
to just provide a query over
that time interval, right?

00:38:24.396 --> 00:38:27.836
All right, total distance,
again, similar to the number

00:38:27.916 --> 00:38:31.156
of steps, except distance is
going to be a fractional number

00:38:31.156 --> 00:38:32.666
and that's going to be
represented in meters.

00:38:32.946 --> 00:38:35.306
Again, that is the total
distance that you travel,

00:38:35.856 --> 00:38:38.266
it could be from start to stop,

00:38:38.266 --> 00:38:40.706
so it's not the actual
stride themselves.

00:38:41.876 --> 00:38:50.576
All right, so that is pretty
briefly the Motion Processing

00:38:50.576 --> 00:38:52.106
services that we provide.

00:38:52.436 --> 00:38:56.146
The APIs are pretty
straightforward, pretty simple,

00:38:56.446 --> 00:38:58.636
but you'll find that the
things that you can do

00:38:58.636 --> 00:39:01.946
with them can potentially
be very, very powerful.

00:39:02.706 --> 00:39:10.426
The stride estimate, I think can
basically facilitate a whole new

00:39:10.426 --> 00:39:13.406
set of applications
around health and fitness.

00:39:13.736 --> 00:39:16.966
And you can imagine now
using health or the things

00:39:16.966 --> 00:39:19.956
that you achieve in fitness
as an additional currency.

00:39:19.956 --> 00:39:25.196
If you've not seen the HealthKit
session, I encourage you

00:39:25.196 --> 00:39:28.536
to watch that on video because
that perhaps will give you some

00:39:28.536 --> 00:39:31.276
ideas on how you can use this

00:39:31.436 --> 00:39:33.256
in a social media
context, all right?

00:39:33.786 --> 00:39:36.516
So that's it, all that I have.

00:39:36.516 --> 00:39:38.876
I'm going to invite
Sunny up to actually go

00:39:38.876 --> 00:39:39.976
over the demo exercise.

00:39:40.516 --> 00:39:45.236
[ Applause ]

00:39:45.736 --> 00:39:46.236
>> Thank you, Andy.

00:39:48.786 --> 00:39:49.996
Hello, everyone.

00:39:49.996 --> 00:39:50.826
My name is Sunny.

00:39:51.046 --> 00:39:56.466
I'm a Developer on
the Core Motion Team.

00:39:57.476 --> 00:40:02.536
So the topics I want to be
covering today are mainly

00:40:02.536 --> 00:40:04.066
about CMMotionActivityManager,

00:40:04.096 --> 00:40:06.116
CMPedometer, as Andy
just covered.

00:40:06.116 --> 00:40:07.776
We'll be taking a
deeper look at both

00:40:07.776 --> 00:40:09.646
of these classes during
the coding exercise.

00:40:10.336 --> 00:40:14.376
Now as we're going
through coding exercise,

00:40:14.506 --> 00:40:15.976
at times there might be a lot

00:40:15.976 --> 00:40:17.376
of code that's displayed
all at once.

00:40:17.376 --> 00:40:18.336
Don't worry too much

00:40:18.336 --> 00:40:19.886
about following every
last detail, though.

00:40:20.436 --> 00:40:23.066
This coding exercise has already
been made publicly available.

00:40:24.266 --> 00:40:27.556
The important parts, though,
I will be sure to highlight,

00:40:27.556 --> 00:40:28.456
and I think as long

00:40:28.456 --> 00:40:31.166
as you follow those parts
it'll make your experience

00:40:31.166 --> 00:40:33.556
with the Motion Activity
APIs that much smoother.

00:40:34.556 --> 00:40:36.286
So let's go ahead and start
with the coding exercise.

00:40:36.946 --> 00:40:39.596
Here you go.

00:40:39.856 --> 00:40:42.796
So just some context - so this
coding exercise eventually

00:40:42.796 --> 00:40:46.946
compiles into a UI application,
and the code that we're

00:40:46.946 --> 00:40:50.196
about to implement right
now makes up the data model

00:40:50.726 --> 00:40:52.426
that the UI application
will use.

00:40:52.996 --> 00:40:55.166
The very first thing
that we want to do

00:40:55.166 --> 00:40:58.416
with this data model is, as
Andy mentioned, we want to do -

00:40:58.696 --> 00:41:01.176
we want to check for
proper availability

00:41:01.176 --> 00:41:04.816
of these APIs before
we start using any

00:41:04.816 --> 00:41:06.306
of the queries or
the live updates.

00:41:06.546 --> 00:41:08.846
So let's go ahead and
go implement that.

00:41:10.316 --> 00:41:14.266
Get rid of that typo
there, and the check

00:41:15.226 --> 00:41:18.416
for availability looks
something like this.

00:41:19.626 --> 00:41:21.646
And you look at the
parts I have highlighted.

00:41:21.646 --> 00:41:26.086
Here it's as simple as checking
for activity that's available

00:41:26.216 --> 00:41:28.756
for CMMotionActivityManager

00:41:28.756 --> 00:41:32.836
and isStepCountingAvailable
for CMPedometer?

00:41:33.606 --> 00:41:36.376
It's important to check for
both because, as Andy mentioned,

00:41:36.376 --> 00:41:37.876
not all platforms support both.

00:41:37.876 --> 00:41:45.356
Now that we've done our due
diligence it's time for us

00:41:45.476 --> 00:41:46.946
to create our instances

00:41:47.006 --> 00:41:50.076
of CMMotionActivityManager
and CMPedometer.

00:41:51.016 --> 00:41:56.296
Something to keep in mind with
these classes is that a lot

00:41:56.296 --> 00:41:58.926
of our APIs are largely
callback-based,

00:41:59.206 --> 00:42:00.776
so you want to keep in mind

00:42:00.776 --> 00:42:06.926
about the lifetime
of these objects.

00:42:08.016 --> 00:42:10.036
For my class, because
I'm expecting

00:42:10.036 --> 00:42:11.436
or will be expecting
live updates

00:42:11.436 --> 00:42:14.356
at any point during my
program, I've decided

00:42:14.446 --> 00:42:16.926
to tie really the
lifetime of these objects

00:42:16.926 --> 00:42:20.026
with my data model, in
essence tie the lifetime

00:42:20.026 --> 00:42:22.156
of my data model
with my application.

00:42:22.416 --> 00:42:25.956
A pattern I've seen commonly
with code that has come

00:42:25.956 --> 00:42:30.936
across my table is people will
very commonly create an instance

00:42:31.976 --> 00:42:35.126
and assign it to an object
that only lives on the stack,

00:42:35.496 --> 00:42:38.296
and so what happens
when that object perhaps

00:42:38.296 --> 00:42:40.406
in a stack frame
goes out of scope?

00:42:40.406 --> 00:42:41.806
Well, that object is released,

00:42:41.806 --> 00:42:43.676
and no more callbacks
are called.

00:42:43.786 --> 00:42:45.726
So it's important
that you keep in mind

00:42:45.946 --> 00:42:47.566
about lifetimes of
these objects.

00:42:47.566 --> 00:42:48.286
You just want to make sure

00:42:48.286 --> 00:42:51.136
that these objects are still
available when callbacks,

00:42:51.916 --> 00:42:54.066
when you want callbacks
to be involved.

00:42:54.066 --> 00:42:58.226
The next thing we want to do
is check for authorization.

00:42:58.226 --> 00:43:01.326
This is - we handle
most of the details

00:43:01.376 --> 00:43:02.916
of authorization for you, right?

00:43:03.216 --> 00:43:07.936
Every time you make a call
that accesses motion activity,

00:43:07.936 --> 00:43:10.356
we'll do the proper popups.

00:43:10.436 --> 00:43:12.956
The only time you'll want to
do something more than that is

00:43:13.006 --> 00:43:17.236
to check to make sure that your
app does have authorization

00:43:17.236 --> 00:43:19.376
to access activity
because when you don't,

00:43:19.376 --> 00:43:23.346
you want to show a dialogue
box saying, informing the user

00:43:23.346 --> 00:43:26.906
of his mistake and
allowing your app a chance

00:43:26.906 --> 00:43:29.236
to correct that behavior.

00:43:34.076 --> 00:43:35.706
So the query looks like this.

00:43:35.706 --> 00:43:39.136
As Andy mentioned,
there's - well,

00:43:39.136 --> 00:43:43.066
the authorization really
is just a simple query.

00:43:43.326 --> 00:43:45.226
We don't really care about
the results that come

00:43:45.226 --> 00:43:47.946
from this query, we
just care about sort

00:43:47.946 --> 00:43:49.976
of whether it returns
an error or not.

00:43:49.976 --> 00:43:51.686
This is why the "from" dates

00:43:51.686 --> 00:43:53.546
and "to" dates are
both equal to now.

00:43:54.956 --> 00:43:58.396
Now on the callback we
just want to make sure

00:43:58.396 --> 00:44:00.476
that there's no errors, and
if there is an error code

00:44:00.476 --> 00:44:03.286
that it's not equal to this
particular error message.

00:44:03.466 --> 00:44:05.456
And if you've done that
then you've made sure

00:44:05.456 --> 00:44:08.126
that your app is, indeed,
ready to start querying

00:44:08.126 --> 00:44:09.126
for motion activity data.

00:44:10.086 --> 00:44:11.716
There's one more
thing to notice here,

00:44:11.716 --> 00:44:16.706
I've chosen to use CMPedometer
to check for this authorization,

00:44:17.056 --> 00:44:18.806
and because my
authorizationCheck

00:44:18.806 --> 00:44:22.586
CompletionHandler may possibly
invoke some UI dialogue

00:44:22.586 --> 00:44:25.836
informing the user that
motion activity was denied,

00:44:27.056 --> 00:44:29.396
you will want to make sure
that you dispatch that block

00:44:29.396 --> 00:44:34.836
onto the main queue because
blocks that are passed

00:44:34.836 --> 00:44:38.356
to CMPedometer will be
invoked on an arbitrary queue

00:44:38.356 --> 00:44:40.366
that might not necessarily
be your main queue.

00:44:40.996 --> 00:44:46.556
Okay, so now that we've done
our check for authorization,

00:44:46.736 --> 00:44:49.316
now it's time for us to start
querying data, and this is kind

00:44:49.316 --> 00:44:52.806
of the magical part of our
API because it allows your app

00:44:52.806 --> 00:44:57.116
to give the illusion that you've
been collecting data all along.

00:44:57.456 --> 00:44:59.416
So the queries, for
this data model,

00:45:00.026 --> 00:45:02.866
this data model is
responsible for collecting data

00:45:02.866 --> 00:45:07.706
from start date to end date
for both motion activity data

00:45:07.706 --> 00:45:09.796
and step counting
data, and when all

00:45:09.796 --> 00:45:12.786
of that data has been
collected then it's time

00:45:12.836 --> 00:45:13.656
to invoke some sort

00:45:13.656 --> 00:45:17.786
of completion handler
allowing the UI to be updated

00:45:17.786 --> 00:45:18.736
with all of that data.

00:45:23.056 --> 00:45:24.986
So the motion query looks
something like this.

00:45:25.556 --> 00:45:29.596
There's a start date, there's an
end date, there's a main queue,

00:45:30.226 --> 00:45:31.426
and there's a completion
handler.

00:45:32.266 --> 00:45:33.706
Be sure to check for errors

00:45:34.336 --> 00:45:37.856
because at any point during your
program's operation the user can

00:45:37.936 --> 00:45:41.286
still go ahead to the security
screen or the privacy pane

00:45:41.286 --> 00:45:43.566
and disable authorization
on your app.

00:45:44.276 --> 00:45:48.976
After that, you can
start playing

00:45:48.976 --> 00:45:51.916
around with the activities
that are passed back

00:45:52.346 --> 00:45:53.656
when this call back is invoked.

00:45:54.936 --> 00:45:58.456
Now a word about the
types of data segments

00:45:58.456 --> 00:46:00.856
that are passed back
after this query,

00:46:01.076 --> 00:46:02.916
very often you might
not be interested

00:46:02.916 --> 00:46:04.666
in all the data segments
that are passed back.

00:46:05.696 --> 00:46:09.686
For example, you might not be
interested in all the periods

00:46:09.686 --> 00:46:13.346
of time for which your
device stays static or that,

00:46:13.346 --> 00:46:16.706
if you're a fitness app you
might want to consider a trip,

00:46:16.856 --> 00:46:18.226
a jog through a shopping mall

00:46:18.226 --> 00:46:22.246
as one bit contiguous walking
segment as opposed to a walking,

00:46:22.246 --> 00:46:24.156
stopping, walking,
stopping segment.

00:46:25.146 --> 00:46:28.086
And so you'll want to do some
sort of app-specific filtering

00:46:28.086 --> 00:46:32.236
on this activity data to kind of
clean up and make it appropriate

00:46:32.236 --> 00:46:34.686
and more sort of easier to
understand for the user.

00:46:34.686 --> 00:46:36.186
And this is what,

00:46:36.566 --> 00:46:38.466
this additional processing
method is doing,

00:46:38.466 --> 00:46:41.106
it's doing some filtering that's
specific for the demo app.

00:46:41.246 --> 00:46:45.286
In the demo app, we'll do some
filtering based on confidence,

00:46:45.286 --> 00:46:49.696
we'll do some filtering based
on getting rid of data seconds

00:46:49.766 --> 00:46:52.046
that are short enough
and have no sort

00:46:52.046 --> 00:46:54.376
of classification behind them.

00:46:54.936 --> 00:46:58.866
But I'll leave the sort of
implementation details up to you

00:46:59.136 --> 00:47:00.876
as an exercise for you
to check out later.

00:47:02.036 --> 00:47:04.756
Now that we've done that,
we have activities ready,

00:47:04.756 --> 00:47:08.066
they're filtered, they're almost
- we're almost ready to push up

00:47:08.066 --> 00:47:10.246
and let the UI know that
all of our data is ready,

00:47:10.246 --> 00:47:12.776
but as I mentioned we're also
interested in step count data.

00:47:14.006 --> 00:47:16.176
The question that
comes up now is, well,

00:47:16.176 --> 00:47:19.266
how do I synchronize my
motion activity results

00:47:19.266 --> 00:47:23.856
with my step counting results,
and what I like to do is

00:47:24.196 --> 00:47:26.456
to solve that problem
and nest the query

00:47:26.456 --> 00:47:30.336
so that one successful query
results in another query,

00:47:30.336 --> 00:47:32.566
and at the end of all
the successful queries is

00:47:32.566 --> 00:47:35.976
when you tell the UI is
ready to display the data.

00:47:36.496 --> 00:47:41.746
The step count query
looks like this.

00:47:44.796 --> 00:47:46.926
There's a start date,
there's an end date.

00:47:47.296 --> 00:47:50.176
Note again the absence of an
operation queue parameter,

00:47:50.626 --> 00:47:51.596
this means that if you were

00:47:51.596 --> 00:47:55.766
to invoke any UI modification
behavior inside your completion

00:47:55.766 --> 00:47:58.766
block, that it's wise to
dispatch your first domain.

00:47:58.766 --> 00:48:03.316
And let's go ahead and
invoke the completion block

00:48:03.316 --> 00:48:05.416
that ultimately invokes the UI.

00:48:06.026 --> 00:48:11.336
And that's it, at this point
my app has all the data

00:48:11.696 --> 00:48:14.136
that was accumulated on behalf

00:48:14.136 --> 00:48:16.286
of my app while my app
was in the background.

00:48:17.336 --> 00:48:20.516
So in order to further
the user experience

00:48:20.516 --> 00:48:26.416
so that you can see live updates
as the user is using the device,

00:48:26.416 --> 00:48:30.286
let's go ahead and start
using the live updates parts

00:48:30.286 --> 00:48:32.356
of our API.

00:48:34.056 --> 00:48:37.766
So we'll start with step
updates, it's as simple

00:48:37.816 --> 00:48:40.086
as calling starts, and
for people who are used

00:48:40.086 --> 00:48:41.956
to seeing step counter
you might have noticed

00:48:41.956 --> 00:48:44.276
that we have a new
parameter here and a state,

00:48:44.406 --> 00:48:48.096
this is a convenience for
you so that in case you want

00:48:48.096 --> 00:48:51.436
to start step counting, but you
want some offset applied to it,

00:48:51.846 --> 00:48:54.966
say you're a daily journaling
app, you want step counts

00:48:54.966 --> 00:48:58.486
to be counted from the beginning
of today, not from right now.

00:48:59.126 --> 00:49:00.736
You can now specify that date,

00:49:01.046 --> 00:49:03.206
that saves you an
additional query and having

00:49:03.206 --> 00:49:04.566
to combine information together.

00:49:05.976 --> 00:49:09.166
Again, we did not specify
an NS operation queue

00:49:09.866 --> 00:49:12.466
because this makes the API
simpler, but if you want

00:49:12.466 --> 00:49:14.956
to do any UI modification
behaviors,

00:49:14.956 --> 00:49:16.706
be sure to dispatch this back

00:49:16.776 --> 00:49:19.356
to the main queue before you
run your completion handler.

00:49:19.616 --> 00:49:23.086
I know I'm sounding like a -
I'm repeating myself a couple

00:49:23.086 --> 00:49:25.106
of times, but this is something
that I've found something

00:49:25.156 --> 00:49:27.626
to be problematic in
my own app development.

00:49:29.656 --> 00:49:33.156
Stopping step updates is
simple, you just call stop.

00:49:39.876 --> 00:49:42.076
Let's go ahead and start
motion updates, as well.

00:49:42.076 --> 00:49:48.626
Starting motion updates is
very simple, specify queue,

00:49:48.786 --> 00:49:52.066
specify a completion block, and
they'll all be kind of handled

00:49:52.066 --> 00:49:55.596
for you, and you'll have
indications every time you get a

00:49:55.596 --> 00:49:57.376
new motion activity.

00:49:58.306 --> 00:50:01.796
And stopping motion updates is
also as simple as calling stop.

00:50:02.436 --> 00:50:05.706
And there you go.

00:50:05.706 --> 00:50:08.626
At this point you have a
fully functional data model

00:50:08.626 --> 00:50:12.276
that you can use in your UI
app to get motion activity data

00:50:12.656 --> 00:50:14.656
for when your app is in
the background and for

00:50:14.656 --> 00:50:16.116
when your app is
in the foreground.

00:50:16.666 --> 00:50:17.956
So let's go ahead
and take a look

00:50:17.956 --> 00:50:19.926
at what this eventually
compiles into.

00:50:26.036 --> 00:50:29.546
So here we have the
motion activity demo app,

00:50:30.496 --> 00:50:32.426
and in the very first
view you can see a listing

00:50:32.426 --> 00:50:35.366
of the past seven days, for
which we've collected data,

00:50:35.366 --> 00:50:38.926
and if you click on any of
these days you'll see sort

00:50:38.926 --> 00:50:42.556
of some transformations
that we've done on the set

00:50:42.556 --> 00:50:43.786
of activity data segments.

00:50:44.156 --> 00:50:45.936
You'll see the total
durations for walking,

00:50:45.936 --> 00:50:47.836
running, driving, and moving.

00:50:48.376 --> 00:50:49.276
And because I've clicked

00:50:49.276 --> 00:50:53.226
on the Today view you can
also see my current activity,

00:50:53.356 --> 00:50:55.906
and because this device is in
my hand it says it's moving.

00:50:56.306 --> 00:50:59.796
If I set this device on
the floor or on the table,

00:51:00.016 --> 00:51:02.726
I'm sorry, it will now
say it's not moving.

00:51:03.376 --> 00:51:06.576
It will also show you a
set of live step counts.

00:51:07.026 --> 00:51:08.846
What's more interesting
or what's really cool

00:51:08.846 --> 00:51:12.456
about this is once you do the
application-specific filtering,

00:51:12.456 --> 00:51:15.356
you can get a lot of very useful
contextual information, as well.

00:51:16.406 --> 00:51:20.296
And this is sort of the filtered
history of my day so far.

00:51:20.296 --> 00:51:22.716
You can see when I walked
to my car in the morning,

00:51:22.716 --> 00:51:27.506
from 8:15 to 8:20, and you
can see my commute from home

00:51:27.506 --> 00:51:29.146
to work, from 8:20 to 8:36.

00:51:29.146 --> 00:51:31.156
Now I actually have
a real time span

00:51:31.156 --> 00:51:32.856
for how long it took
me to get to work.

00:51:33.396 --> 00:51:37.666
You can see me walk from my
car to the crosswalk in front

00:51:37.666 --> 00:51:41.006
of aisle two, and I took 50
steps, and there's a little bit

00:51:41.006 --> 00:51:42.676
of a running segment
here because I was trying

00:51:42.676 --> 00:51:45.796
to beat the Ferrari that was
stopped and I didn't want

00:51:45.796 --> 00:51:47.526
to hold up the exec
in that Ferrari.

00:51:48.096 --> 00:51:54.266
After that, I walked to get
some breakfast, and you can kind

00:51:54.266 --> 00:51:56.326
of unfurl all of that, and
you can see when I make

00:51:56.326 --> 00:52:00.356
that big long drive from
aisle two to Moscone Center.

00:52:01.756 --> 00:52:06.226
So, cool, so that's the demo
app, and I've talked a lot

00:52:06.226 --> 00:52:08.366
about sort of the steps
that are necessary

00:52:08.446 --> 00:52:10.226
for accessing motion
activity data.

00:52:10.226 --> 00:52:12.896
I've talked about
checking for availability.

00:52:12.896 --> 00:52:14.876
I've talked about
initialization.

00:52:14.876 --> 00:52:16.516
I've talked about authorization.

00:52:16.516 --> 00:52:18.386
And I've talked about
historical queries.

00:52:18.386 --> 00:52:19.746
I've talked about live updates.

00:52:21.166 --> 00:52:23.306
However, nothing beats
hands-on experience,

00:52:23.306 --> 00:52:25.206
so I highly encourage
all of you to go ahead

00:52:25.276 --> 00:52:27.496
and download this coding
exercise and compile it,

00:52:27.906 --> 00:52:29.756
deploy it in your phones,
and take a look at the data

00:52:29.756 --> 00:52:31.026
that has already been
collected for you,

00:52:31.356 --> 00:52:36.486
I think you'll be
pleasantly surprised.

00:52:36.866 --> 00:52:39.026
So for any questions
that you might have

00:52:39.026 --> 00:52:42.156
or for more information about
our Motion Activity Frameworks,

00:52:42.246 --> 00:52:47.086
feel free to contact Allan or
after WWDC feel free to interact

00:52:47.086 --> 00:52:48.086
on the Developer Forums.

00:52:48.736 --> 00:52:52.096
As Andy mentioned,

00:52:52.356 --> 00:52:54.286
motion activity is just
one context, right?

00:52:54.956 --> 00:52:56.406
However, when you
start combining this

00:52:56.406 --> 00:52:58.286
with other contextual
queues from HealthKit,

00:52:58.346 --> 00:53:00.686
from Core Location, it can
help you build a very powerful

00:53:00.766 --> 00:53:02.576
picture of what the
user has been doing

00:53:03.096 --> 00:53:04.866
and what the user is now doing.

00:53:05.636 --> 00:53:08.266
So we highly encourage you to
check out the sessions related

00:53:08.266 --> 00:53:10.186
to HealthKit and Core
Location, as well.

00:53:10.986 --> 00:53:13.656
So I thank you all for
attending this session.

00:53:13.836 --> 00:53:15.566
We really appreciate
you taking the time

00:53:15.706 --> 00:53:18.196
to understand the Motion
Activity APIs a little bit more.

00:53:18.876 --> 00:53:21.636
We hope to see some of you
at the session, and for those

00:53:21.636 --> 00:53:24.676
of you who we don't, we hope to
see some of your work on that,

00:53:24.676 --> 00:53:26.906
and we can't wait to see
what you will do with these -

00:53:27.576 --> 00:53:28.476
what you'll come up
next with these APIs.

00:53:28.476 --> 00:53:28.976
Thank you so much.

00:53:29.516 --> 00:53:32.310
[ Applause ]
WEBVTT

00:00:13.336 --> 00:00:14.186
>> So welcome.

00:00:14.186 --> 00:00:14.253
So-

00:00:14.253 --> 00:00:14.926
[ Applause ]

00:00:14.926 --> 00:00:15.736
-oh, thank you.

00:00:21.836 --> 00:00:24.046
So, my name's Richard
Schreyer, and I've been working

00:00:24.046 --> 00:00:26.146
on the design of Metal
for quite a while now.

00:00:26.146 --> 00:00:28.446
And so it's really exciting
to finally be able to talk

00:00:28.446 --> 00:00:29.206
to all of you about it.

00:00:29.536 --> 00:00:31.826
So this is the Metal
fundamentals session.

00:00:32.016 --> 00:00:35.396
It's the second in our trio of
sessions, following concepts

00:00:35.466 --> 00:00:37.816
and to be followed by
Metal advanced usage.

00:00:38.036 --> 00:00:42.276
So this session is going to
be split into two major parts.

00:00:43.036 --> 00:00:45.306
The first half, which I'm going
to present, is going to be how

00:00:45.306 --> 00:00:47.126
to build a basic
Metal application.

00:00:48.056 --> 00:00:49.686
I want to take all
of the concepts

00:00:49.686 --> 00:00:50.736
that Jeremy just described,

00:00:50.876 --> 00:00:52.946
a bunch of block
diagrams and arrows.

00:00:53.376 --> 00:00:54.956
And turn those into actual code.

00:00:55.646 --> 00:00:57.986
So, we'll try to make
everything more concrete.

00:00:59.636 --> 00:01:01.126
During the second
half of the session,

00:01:01.126 --> 00:01:03.176
I'm going to turn the stage over
to my colleague Aafi [phonetic],

00:01:03.176 --> 00:01:05.196
who will take you
into a deep dive

00:01:05.266 --> 00:01:06.496
into the Metal shading language.

00:01:07.076 --> 00:01:10.366
Talk about, you know, the
various syntax and data types.

00:01:10.366 --> 00:01:12.736
How to express vertex,
pixel and compute shaders.

00:01:12.996 --> 00:01:15.246
And then a bunch of grab bag
of other interesting topics.

00:01:16.236 --> 00:01:19.176
So, getting right into
building a Metal application.

00:01:19.176 --> 00:01:22.786
So as I said, this is
going to be a fairly --

00:01:22.986 --> 00:01:26.376
a set of slides that are
fairly heavy on code.

00:01:26.496 --> 00:01:29.036
That's really what I want to
try to get across is, you know,

00:01:29.146 --> 00:01:31.906
what you're going to actually
want to put down in Xcode.

00:01:32.106 --> 00:01:33.986
So I'm going to try and
keep this application

00:01:33.986 --> 00:01:34.896
as simple as possible.

00:01:34.896 --> 00:01:36.946
So it's going to be a very
"hello world" kind of thing.

00:01:37.416 --> 00:01:40.576
So in the interest of, is it
always that way in graphics?

00:01:40.576 --> 00:01:41.836
So the application I'm going

00:01:41.836 --> 00:01:43.616
to build is basically
just a triangle.

00:01:43.616 --> 00:01:45.456
We're going to go
through all the steps

00:01:45.456 --> 00:01:47.896
to go put a single shaded
triangle on the screen.

00:01:47.896 --> 00:01:48.086
[ Applause ]

00:01:48.086 --> 00:01:49.896
I know, really exciting stuff.

00:01:51.476 --> 00:01:54.016
But it's actually pretty cool
because, and we're going to go

00:01:54.016 --> 00:01:56.136
through some boiler
plate and some setup.

00:01:56.136 --> 00:01:57.306
But once you get through that,

00:01:57.306 --> 00:01:58.936
that's really the same
foundation you need

00:01:58.936 --> 00:01:59.996
to start building, immediately,

00:01:59.996 --> 00:02:01.886
much more complex
content on top of that.

00:02:02.536 --> 00:02:05.016
So we're not going out of our
way to draw just a triangle.

00:02:07.226 --> 00:02:08.985
So the first set of
things I'm going to go

00:02:08.985 --> 00:02:10.616
through are just
the initialization.

00:02:10.616 --> 00:02:12.556
I mean what's the
one-shot setup you'll do

00:02:12.646 --> 00:02:14.646
when your application launches
or you start using Metal?

00:02:15.646 --> 00:02:17.686
Then I'll get into the
contents of what, you know,

00:02:17.686 --> 00:02:18.996
the actual drawing
will look like.

00:02:19.736 --> 00:02:22.356
And then we'll get on to
extending the application

00:02:22.356 --> 00:02:23.806
to do a little bit more stuff.

00:02:23.906 --> 00:02:26.256
So these are the
steps that I'll walk

00:02:26.256 --> 00:02:27.346
through in the code, in order.

00:02:28.546 --> 00:02:30.506
So right at the top
is getting the device.

00:02:31.106 --> 00:02:32.436
So what is the device API?

00:02:32.436 --> 00:02:37.586
So in Metal, a device is sort of
the root object of a whole API.

00:02:37.586 --> 00:02:40.656
It's your direct connection

00:02:40.656 --> 00:02:42.916
to the GPU driver
and the GPU hardware.

00:02:43.616 --> 00:02:46.226
Now as far as the actual API
that the device sends out,

00:02:46.886 --> 00:02:50.226
what it really does directly,
it's the source that you go

00:02:50.226 --> 00:02:52.556
to to create all of the other
objects in the Metal API.

00:02:53.786 --> 00:02:56.856
So if you want to go create
a new texture or a new buffer

00:02:56.856 --> 00:02:59.146
or a new RenderPipeline,
the device is

00:02:59.146 --> 00:02:59.876
where you'll find that.

00:03:01.006 --> 00:03:02.826
So, we want to go
create some stuff,

00:03:02.826 --> 00:03:04.616
and so we need a device
to create them on.

00:03:05.236 --> 00:03:05.966
So that's really easy.

00:03:06.026 --> 00:03:09.016
So our first initialization
step is to just say, "hey,

00:03:09.096 --> 00:03:12.396
I want the default device."

00:03:13.196 --> 00:03:17.046
Our second initialization step
is we need a command queue.

00:03:18.126 --> 00:03:20.996
The CommandQueue is our channel
to submit work to the GPU.

00:03:21.726 --> 00:03:24.036
Now we're not actually going
to do any of that until we get

00:03:24.036 --> 00:03:26.156
to drawing, so I'm going to
create a CommandQueue now

00:03:26.446 --> 00:03:28.566
from the device and
save it aside.

00:03:29.166 --> 00:03:35.086
The third initialization step is
to go create all of my buffers

00:03:35.086 --> 00:03:37.536
and textures and
other resources.

00:03:38.316 --> 00:03:40.576
My application is simple enough
that I have exactly one of them.

00:03:40.576 --> 00:03:41.416
I need a vertexArray.

00:03:41.416 --> 00:03:44.166
And so I'm going to
go back to the device

00:03:44.366 --> 00:03:45.866
yet again and say newBuffer.

00:03:46.646 --> 00:03:48.886
This particular variance
will go allocate a new block

00:03:48.886 --> 00:03:52.256
of CPU/GPU shared memory, copy
the provided pointer into it,

00:03:52.256 --> 00:03:53.916
and give me back a
handle to that buffer.

00:03:55.376 --> 00:03:57.136
So right off the bat
we've gotten through three

00:03:57.136 --> 00:03:58.696
of our five initialization
steps.

00:03:58.696 --> 00:03:59.706
We're making pretty good time.

00:04:00.586 --> 00:04:02.706
The fourth one is going to
be quite a bit more involved.

00:04:02.706 --> 00:04:04.266
We're going to spend
some time on that one.

00:04:04.816 --> 00:04:06.806
And that is creating
the RenderPipeline.

00:04:07.416 --> 00:04:11.396
So this is all -- so as we
saw in the concepts session,

00:04:12.336 --> 00:04:14.366
the RenderPipeline
is a collection

00:04:14.366 --> 00:04:15.706
of quite a bit of stuff.

00:04:15.976 --> 00:04:19.096
Most importantly, the vertex
and the fragment shaders,

00:04:19.896 --> 00:04:22.396
but it also incorporates
every other piece of state

00:04:22.396 --> 00:04:24.006
that the shader compiler needs

00:04:24.006 --> 00:04:27.346
to generate the final
machine code for the A7.

00:04:27.896 --> 00:04:29.926
That includes some
information on vertex layout,

00:04:30.236 --> 00:04:33.146
some rasterizer configuration,
all of the framebuffer,

00:04:33.146 --> 00:04:35.226
blend modes, and
some information

00:04:35.226 --> 00:04:36.846
about the framebuffer
configuration

00:04:36.966 --> 00:04:37.966
that this pipeline will draw to.

00:04:38.086 --> 00:04:41.486
That's actually quite
a bit of stuff.

00:04:41.986 --> 00:04:43.756
And so we've split
the RenderPipeline

00:04:43.756 --> 00:04:45.216
into two separate objects.

00:04:45.636 --> 00:04:48.596
The RenderPipelineDescriptor,
which is your object

00:04:48.666 --> 00:04:50.506
that provides all the
configuration API,

00:04:50.506 --> 00:04:56.616
and the RenderPipelineState,
which is the sort of baked,

00:04:56.616 --> 00:04:57.776
finalized form of that.

00:04:58.166 --> 00:04:59.786
It's just small, it's compact,

00:05:00.146 --> 00:05:02.526
and they're really
cheap to switch between.

00:05:03.916 --> 00:05:05.706
So let's go look at
the code to build --

00:05:05.706 --> 00:05:07.226
I'm going to build
one RenderPipeline

00:05:07.226 --> 00:05:12.536
in this application, so
let's go look at the code.

00:05:12.646 --> 00:05:15.186
So first, I'm going to
conjure up a new descriptor.

00:05:16.286 --> 00:05:18.686
And the very first things I'm
going to set on it are my vertex

00:05:18.686 --> 00:05:19.916
and my fragment shaders.

00:05:21.736 --> 00:05:23.946
And you'll notice that I'm not
providing any source code here.

00:05:24.476 --> 00:05:26.516
So this is what the
runtime API looks

00:05:26.516 --> 00:05:29.246
like when Xcode builds your
shaders offline for you.

00:05:29.546 --> 00:05:32.596
Xcode's going to package up all
of the offline-built shaders

00:05:33.046 --> 00:05:35.056
into a device independent
bytecode file...

00:05:35.866 --> 00:05:37.726
and ship that in your
application bundle.

00:05:37.776 --> 00:05:40.256
And at runtime I can
go ask the device

00:05:40.256 --> 00:05:41.716
to load that default library.

00:05:43.266 --> 00:05:45.556
Once I have that, I can
go start picking functions

00:05:45.556 --> 00:05:46.496
out of that by name.

00:05:49.256 --> 00:05:51.216
The second piece of
configuration I need

00:05:51.216 --> 00:05:53.726
on the RenderPipeline is
the framebuffer format.

00:05:54.256 --> 00:05:58.256
So, I'm only going to have one
color attachment I'm rendering

00:05:58.256 --> 00:06:00.436
to, and so I'm going to
say, "hey, this is going

00:06:00.436 --> 00:06:01.946
to be a BGRA render target."

00:06:03.086 --> 00:06:06.816
A RenderPipeline has a whole
bunch of other stuff I can set

00:06:06.816 --> 00:06:08.906
on it, but for my simple
little application,

00:06:09.356 --> 00:06:10.536
that's really all I need.

00:06:10.946 --> 00:06:13.336
The default values of all
the other properties are

00:06:13.336 --> 00:06:14.276
already appropriate.

00:06:14.676 --> 00:06:19.096
So I'm going to go ahead and
compile and ask the device

00:06:19.096 --> 00:06:20.656
to compile a RenderPipeline
state.

00:06:20.896 --> 00:06:21.946
I'll just go to the device

00:06:21.946 --> 00:06:25.426
and call newRenderPipelineState
WithDescriptor.

00:06:26.706 --> 00:06:28.386
So this is actually
the expensive API.

00:06:29.166 --> 00:06:31.646
This is the API that is
going to, if necessary,

00:06:31.976 --> 00:06:33.466
go call over to the
shader compiler

00:06:33.676 --> 00:06:37.416
and finish the code generation,
taking into account all

00:06:37.416 --> 00:06:40.506
of the other information
that you have provided.

00:06:40.576 --> 00:06:42.976
Once we have this
RenderPipeline, now you,

00:06:43.076 --> 00:06:44.586
you know -- it's all baked.

00:06:44.586 --> 00:06:46.466
It's all finalized, and
we can toggle between them

00:06:46.466 --> 00:06:48.476
at draw time very, very cheaply.

00:06:48.956 --> 00:06:51.846
So that's our fourth
initialization step,

00:06:52.416 --> 00:06:53.496
building the RenderPipeline.

00:06:53.916 --> 00:06:57.436
But before I move on from that,
you know, since we're pointing

00:06:57.436 --> 00:06:58.946
at our vertex and
fragment shader here,

00:06:59.426 --> 00:07:01.336
I do want to take a
really quick little detour

00:07:01.336 --> 00:07:04.066
and show you the vertex and
fragment shader code itself.

00:07:04.836 --> 00:07:08.296
So I'm not going to explain to
you every part of the syntax,

00:07:08.326 --> 00:07:11.086
because Aafi is going to
tell you all about that

00:07:11.086 --> 00:07:12.126
in just a few minutes.

00:07:12.876 --> 00:07:15.486
But I'm going to show you
just, I'm going to focus

00:07:15.486 --> 00:07:18.696
on just the dataflow from the
vertexArray through the vertex

00:07:18.696 --> 00:07:20.896
and fragment shader and
into the frame buffer.

00:07:21.616 --> 00:07:24.826
So, I've split this
up into two slides.

00:07:24.826 --> 00:07:26.686
My first slide are
a couple structures

00:07:26.976 --> 00:07:29.276
that describe the input and
output of the vertex shader.

00:07:30.156 --> 00:07:34.066
The vertex structure defines
how my vertexArray is laid

00:07:34.066 --> 00:07:34.586
out in memory.

00:07:34.956 --> 00:07:39.186
Position followed by a color.

00:07:39.376 --> 00:07:40.366
My vertex shader is going

00:07:40.366 --> 00:07:42.086
to be a really simple
pass-through shader.

00:07:42.086 --> 00:07:44.666
I'm going to read my position
color from the vertexArray

00:07:44.666 --> 00:07:47.226
and pass them right out
down the pipeline unchanged.

00:07:47.556 --> 00:07:51.656
So, unsurprisingly, my
VertexOut struct looks,

00:07:51.886 --> 00:07:52.826
well, just like it.

00:07:53.376 --> 00:07:56.766
The only difference is that
the rasterizer needs to know

00:07:56.766 --> 00:07:58.266
which of the outputs
is the position,

00:07:58.266 --> 00:07:59.966
so we have to use an attribute

00:08:00.096 --> 00:08:03.126
to identify that
to the compiler.

00:08:03.206 --> 00:08:05.556
All of the other outputs
will get interpolated

00:08:05.556 --> 00:08:06.766
across the triangle as usual.

00:08:06.766 --> 00:08:12.996
So on to the body of
the vertex shader.

00:08:13.226 --> 00:08:15.866
So here's my simple
pass-through VertexShader.

00:08:16.766 --> 00:08:21.226
So we have a normal
C-style declaration

00:08:21.256 --> 00:08:22.606
with some extra key
words and attributes.

00:08:22.606 --> 00:08:23.906
We'll go into more
detail on them later.

00:08:24.806 --> 00:08:27.316
But I'm getting a
pointer to my vertexArray

00:08:28.076 --> 00:08:31.036
into my VertexShader, along
with a vertex ID that tells me

00:08:31.296 --> 00:08:32.246
which of the three vertexes

00:08:32.246 --> 00:08:33.686
that this thread is
going to be processing.

00:08:36.416 --> 00:08:38.645
From those I'm going to
read from the vertexArray,

00:08:39.035 --> 00:08:44.456
copy to the output struct, and
I'm going to return an instance

00:08:44.456 --> 00:08:45.636
of the VertexOut struct.

00:08:45.636 --> 00:08:50.406
So this is sort of in comparison
to GLSL where all of the inputs

00:08:50.406 --> 00:08:52.016
and outputs are specified
as global scope.

00:08:52.076 --> 00:08:55.036
In the Metal shading language,
all of your inputs come

00:08:55.036 --> 00:08:56.146
in via function arguments.

00:08:56.296 --> 00:08:59.206
All of your outputs are
returned via the C return pipe.

00:08:59.206 --> 00:08:59.856
[ Applause ]

00:08:59.856 --> 00:09:02.496
Okay, this guy likes that!

00:09:04.326 --> 00:09:07.236
So now the FragmentShader
is of course even easier.

00:09:07.956 --> 00:09:12.246
The input to my FragmentShader
is again, a single argument.

00:09:12.666 --> 00:09:14.686
In this case the same
VertexOut structs

00:09:14.686 --> 00:09:16.066
that the VertexShader
just returned.

00:09:16.976 --> 00:09:19.226
Except now it contains
an interpolated position

00:09:19.776 --> 00:09:21.016
and an interpolated color.

00:09:21.016 --> 00:09:23.136
So I'm going to go
read my color.

00:09:23.136 --> 00:09:25.486
And I'm going to
return a float4,

00:09:25.486 --> 00:09:26.646
which will write
into the framebuffer.

00:09:27.426 --> 00:09:29.326
And because we told them --

00:09:29.326 --> 00:09:31.446
put in the pipeline state what
the framebuffer for it is,

00:09:31.826 --> 00:09:33.706
the compiler knows how it
needs to pack this down

00:09:33.706 --> 00:09:35.956
and compress it to the actual,
final framebuffer format.

00:09:36.516 --> 00:09:38.776
So that's the vertex

00:09:38.776 --> 00:09:41.346
and frag-pass-through
vertex and FragmentShaders.

00:09:41.816 --> 00:09:44.646
And that's really the end of
how to build a RenderPipeline.

00:09:45.026 --> 00:09:47.766
The one last bit are just the
function names themselves,

00:09:47.826 --> 00:09:49.976
which are the strings that I
use to pull up these functions

00:09:49.976 --> 00:09:51.336
up when building
another pipeline.

00:09:51.916 --> 00:09:59.946
So our fifth and final step to
initialize is creating the view.

00:10:00.346 --> 00:10:03.136
So if you've been working
on iOS for a while,

00:10:03.136 --> 00:10:05.576
you're probably aware that
if you want to get anything

00:10:05.726 --> 00:10:08.316
on the screen, it
basically needs to be part

00:10:08.316 --> 00:10:09.646
of a core animation layer tree.

00:10:10.546 --> 00:10:13.566
So, iOS 8 provides
a new subclass

00:10:13.566 --> 00:10:15.606
of CA layer called CAMetalLayer.

00:10:16.796 --> 00:10:18.436
And that class is
really interesting

00:10:18.476 --> 00:10:20.746
because it can vend
out textures.

00:10:20.746 --> 00:10:23.266
It will manage a swap chain
of typically three textures,

00:10:23.266 --> 00:10:24.756
and you can ask for the
next one in the chain.

00:10:25.276 --> 00:10:27.576
And I can say, "Give me a
texture," render into it,

00:10:27.576 --> 00:10:29.626
and when I'm done
I can push it back

00:10:29.626 --> 00:10:30.816
to be swapped on to the display.

00:10:32.116 --> 00:10:34.046
To create a layer,

00:10:34.126 --> 00:10:36.676
that's typically owned
by a UIView subclass.

00:10:37.306 --> 00:10:38.806
I'm going to show you a very,

00:10:38.886 --> 00:10:41.826
very bare bones UIView
subclass on the next slide.

00:10:42.216 --> 00:10:44.156
And you can find a much more
complete implementation,

00:10:44.156 --> 00:10:46.146
with a bunch of functionality,
in our sample code.

00:10:46.816 --> 00:10:50.066
And then because this is
iOS, and this is you know,

00:10:50.206 --> 00:10:52.676
entirely typical, your view
is then typically owned

00:10:52.676 --> 00:10:54.946
by a ViewController, which is
usually typically completely

00:10:54.946 --> 00:10:56.066
custom to your application.

00:10:56.526 --> 00:10:59.726
So let's go look at our
really bare bones view.

00:11:01.406 --> 00:11:03.696
So really this is all
you really need to do.

00:11:03.826 --> 00:11:05.226
I need to subclass UIView,

00:11:05.596 --> 00:11:07.786
and I need to override the
layerClass method and say,

00:11:08.436 --> 00:11:11.046
"I want this view to own
a Metal layer as opposed

00:11:11.046 --> 00:11:12.906
to any other kind of layer."

00:11:13.636 --> 00:11:16.356
There is some other
configuration we could do

00:11:16.456 --> 00:11:18.716
on this view in this
layer (primarily

00:11:18.716 --> 00:11:22.486
for efficient compositing) but
this is really the bare minimum

00:11:22.486 --> 00:11:23.866
that you need to get
something on to the screen.

00:11:24.416 --> 00:11:27.976
So with that, we've been
through all five our

00:11:27.976 --> 00:11:28.996
initialization steps.

00:11:29.636 --> 00:11:34.556
We breezed through getting the
device, getting a CommandQueue,

00:11:34.816 --> 00:11:36.546
and creating a resource.

00:11:37.056 --> 00:11:40.256
Spent a little bit of time on
the RenderPipelineDescriptor

00:11:40.556 --> 00:11:41.636
and RenderPipelineState.

00:11:42.636 --> 00:11:43.856
Also looked at the shaders.

00:11:43.856 --> 00:11:46.166
And then we created a view.

00:11:46.246 --> 00:11:50.216
So with that we can actually
get to drawing something.

00:11:50.356 --> 00:11:52.786
And so that has a
few more steps.

00:11:52.786 --> 00:11:58.856
So, we need to get a command
buffer, since all of our work

00:11:58.856 --> 00:12:02.056
that goes to the GPU will be
enqueued into a command buffer.

00:12:02.796 --> 00:12:04.826
We're going to encode
a renderToTexture pass

00:12:05.096 --> 00:12:06.046
into that command buffer.

00:12:06.046 --> 00:12:08.216
We're going to put some stuff
in that render texture pass.

00:12:08.926 --> 00:12:10.596
And then finally we're going
to send that CommandBuffer

00:12:10.746 --> 00:12:12.306
to the GPU hardware
to be executed.

00:12:13.516 --> 00:12:15.266
So, step 1, getting
the CommandBuffer.

00:12:16.176 --> 00:12:17.116
That's another one-liner.

00:12:18.166 --> 00:12:20.256
You can simply go to the
command queue and say,

00:12:20.726 --> 00:12:22.246
"give me the next
available CommandBuffer."

00:12:22.896 --> 00:12:28.736
The second step is setting
up my renderToTexture pass.

00:12:29.726 --> 00:12:33.056
One thing that sets Metal apart
from other graphic APIs is

00:12:33.056 --> 00:12:35.806
that we have a, sort of,
very rigorous definition

00:12:35.806 --> 00:12:38.846
of when a rendered texture
pass begins and when it ends.

00:12:39.436 --> 00:12:41.336
And when you start a
renderToTexture pass,

00:12:41.906 --> 00:12:43.586
we require that you tell us all

00:12:43.586 --> 00:12:46.386
of the framebuffer configuration
right up front so we know how

00:12:46.386 --> 00:12:47.206
to configure the hardware.

00:12:48.506 --> 00:12:52.696
And most of what goes into
that configuration looks a lot

00:12:52.696 --> 00:12:54.506
like a framebuffer
object in open GL.

00:12:55.226 --> 00:12:58.066
There's, you know, what color
textures am I rendering too?

00:12:58.266 --> 00:12:59.056
Up to four of those.

00:12:59.056 --> 00:12:59.846
What depth texture?

00:12:59.846 --> 00:13:00.786
What stencil texture?

00:13:00.786 --> 00:13:04.466
Which bitmap levels that, the
load actions and store actions

00:13:04.466 --> 00:13:05.806
that you saw in Jeremy's
presentation.

00:13:06.426 --> 00:13:10.396
So given that there's so much
configuration that happens here,

00:13:11.406 --> 00:13:14.416
we've again taken that
and packaged it all

00:13:14.416 --> 00:13:17.246
up into a descriptor to do
convenient configuration on.

00:13:18.056 --> 00:13:20.136
And then once you have
the descriptor configured,

00:13:20.416 --> 00:13:23.766
you can then create the
renderToTexture pass.

00:13:23.966 --> 00:13:25.216
So, putting that into code.

00:13:25.706 --> 00:13:28.726
Right off the top, we need

00:13:28.726 --> 00:13:30.666
to know what texture we're
going to render into.

00:13:30.786 --> 00:13:33.286
So we're actually going to
go back to our CA ,metalLayer

00:13:33.286 --> 00:13:35.736
and say, "give me the
next available drawable."

00:13:35.736 --> 00:13:39.176
And a drawable is pretty
much just a wraparound

00:13:39.176 --> 00:13:41.346
to texture plus a little
bit of extra bookkeeping.

00:13:42.876 --> 00:13:45.956
This is one of the very
few API calls in Metal

00:13:45.956 --> 00:13:47.486
that will actually
block your application

00:13:47.806 --> 00:13:49.396
if there's no more
available textures

00:13:49.396 --> 00:13:51.256
in the swap chain,
if they're all busy.

00:13:51.976 --> 00:13:53.466
So this could block
and wait awhile,

00:13:53.466 --> 00:13:54.646
especially if you're GPU bound.

00:13:55.006 --> 00:14:00.256
Next, I want to set up
my RenderPassDescriptor.

00:14:01.206 --> 00:14:04.276
I'm going to .colorAttachment
zero at my drawables texture.

00:14:04.436 --> 00:14:06.516
I'm going to configure
the RenderPass

00:14:06.856 --> 00:14:09.246
such that it will clear
that texture at the start

00:14:09.246 --> 00:14:12.076
of the pass, preventing
the existing contents

00:14:12.076 --> 00:14:13.096
of that texture from
being loaded

00:14:13.226 --> 00:14:14.496
into the GPU's tile cache.

00:14:14.796 --> 00:14:16.616
And then I'm going to
then actually, you know,

00:14:16.616 --> 00:14:20.216
I'm going to choose some really
boring array to clear it to.

00:14:20.886 --> 00:14:23.546
So again, if I had a
more complex framebuffer

00:14:23.546 --> 00:14:25.826
configuration, there would be a
bunch more similar stuff here.

00:14:25.896 --> 00:14:27.856
But again, that's all
I really need for my

00:14:28.336 --> 00:14:29.386
"hello world" application.

00:14:29.806 --> 00:14:32.656
So now I can go to the
CommandBuffer, and I can say,

00:14:32.876 --> 00:14:34.926
"the next thing on
this CommandBuffer is

00:14:34.986 --> 00:14:35.846
a renderCommand.

00:14:36.686 --> 00:14:37.536
Here's the descriptor.

00:14:37.886 --> 00:14:40.056
Give me back the interface
I can use to encode."

00:14:40.906 --> 00:14:43.996
And this renderCommand encoder
you're getting back is the

00:14:43.996 --> 00:14:45.046
object that has most

00:14:45.046 --> 00:14:47.976
of the traditional 3D graphics
API you're expecting to find.

00:14:48.346 --> 00:14:50.016
Things like setting
the depth stencil state

00:14:50.226 --> 00:14:53.176
and binding textures and
colNodes and all that stuff.

00:14:54.346 --> 00:14:58.716
So let's go actually
draw our triangle init.

00:14:58.856 --> 00:15:01.946
So previously I created
my RenderPipeline,

00:15:01.946 --> 00:15:03.316
and I created my vertexArray.

00:15:03.516 --> 00:15:04.596
So I want to set them both here:

00:15:04.996 --> 00:15:06.276
which RenderPipeline
we're going to use?

00:15:06.506 --> 00:15:07.526
And I'm going to say, I'm going

00:15:07.526 --> 00:15:08.796
to point right at
the vertexArray.

00:15:09.056 --> 00:15:10.706
And I can finally
encode the command

00:15:10.806 --> 00:15:12.106
to draw my single triangle.

00:15:13.556 --> 00:15:16.446
So now we've gotten
through our third step

00:15:16.446 --> 00:15:17.356
of drawing the triangle.

00:15:17.456 --> 00:15:19.056
And now we get to the final one,

00:15:19.306 --> 00:15:20.786
committing the CommandBuffer
to the GPU.

00:15:21.436 --> 00:15:26.066
At this point we have basically
a fully-formed CommandBuffer

00:15:26.066 --> 00:15:27.426
just sitting in memory, idle.

00:15:27.426 --> 00:15:30.766
It's not going -- GPU
will not start executing

00:15:30.806 --> 00:15:31.566
until you've committed.

00:15:32.566 --> 00:15:35.346
So before we do that
though, we actually want

00:15:35.346 --> 00:15:38.336
to do one more thing
and tell CoreAnimation

00:15:38.696 --> 00:15:40.376
when you actually want
to present this texture.

00:15:40.866 --> 00:15:43.586
Because we got a texture from
CoreAnimation, and now we need

00:15:43.586 --> 00:15:46.716
to tell CA when we can
display that texture safely.

00:15:47.646 --> 00:15:48.936
Because we haven't
rendered anything yet,

00:15:49.116 --> 00:15:49.926
now's not the time.

00:15:50.866 --> 00:15:54.836
So we want to be able to -- and
so this API addPresent will set

00:15:54.836 --> 00:15:58.086
up an automatic notification
from Metal to CoreAnimation

00:15:58.536 --> 00:16:02.206
that when this rendering is
complete, it will cross-call

00:16:02.206 --> 00:16:03.596
into CoreAnimation and say,

00:16:03.996 --> 00:16:05.386
"it's time to put this
on the display now."

00:16:06.046 --> 00:16:09.476
And then finally we
have the big red button.

00:16:10.216 --> 00:16:13.096
You call commit, and this
CommandBuffer gets encoded --

00:16:13.096 --> 00:16:15.026
gets enqueued into the
end of the command queue,

00:16:15.386 --> 00:16:17.266
and it will execute
on the GPU hardware.

00:16:17.896 --> 00:16:23.836
So that is all of the steps to
go and draw my single triangle.

00:16:24.676 --> 00:16:28.676
We needed to get a command
buffer, configure a render pass

00:16:28.676 --> 00:16:30.936
with one target texture that
we got from CoreAnimation,

00:16:32.256 --> 00:16:34.286
draw my triangle
with the vertexArray

00:16:34.286 --> 00:16:35.116
and a pipeline state.

00:16:35.396 --> 00:16:38.706
And commit the command encoder.

00:16:40.636 --> 00:16:42.326
So that's my triangle.

00:16:42.546 --> 00:16:43.906
That's pretty much all
the codes you need.

00:16:44.406 --> 00:16:45.016
Go -- do it, yeah.

00:16:45.016 --> 00:16:45.226
[ Applause ]

00:16:45.226 --> 00:16:51.466
So it's kind of a
boring application.

00:16:51.706 --> 00:16:54.446
So let's add at least
one little thing more

00:16:54.476 --> 00:16:56.646
that every single
application is going to need

00:16:56.946 --> 00:16:59.026
because I imagine
you're all not going

00:16:59.026 --> 00:17:02.966
to be happy drawing exactly the
same thing over and over again.

00:17:02.996 --> 00:17:06.616
We need to load some shader
uniforms because, you know,

00:17:06.846 --> 00:17:09.816
we actually want to make things
move over time or what have you.

00:17:10.156 --> 00:17:12.445
So, this is going to
take the form of --

00:17:12.445 --> 00:17:15.826
so I want to use this
opportunity to show you how

00:17:15.826 --> 00:17:19.076
to load shader uniforms,
also known as constants.

00:17:21.205 --> 00:17:24.536
So, in Metal, shader constants
come in through buffers.

00:17:24.616 --> 00:17:26.455
Just like vertexArrays
or anything else.

00:17:27.616 --> 00:17:30.536
So back to my vertex
shader code.

00:17:31.336 --> 00:17:34.506
I have declared a new
struct, which describes

00:17:34.506 --> 00:17:37.416
to the compiler how my
uniforms are laid out in memory.

00:17:37.976 --> 00:17:40.306
In this case it's just
a single 4x4 matrix.

00:17:43.106 --> 00:17:45.626
And I've added a second
argument to my function.

00:17:45.626 --> 00:17:47.026
I'm going to read from
a different buffer.

00:17:47.026 --> 00:17:48.716
Now I'm going to read
from buffer location 1,

00:17:49.396 --> 00:17:52.146
and that's where the compiler is
going to expect to find a buffer

00:17:52.146 --> 00:17:55.246
that it's going to actually
load that struct from.

00:17:55.246 --> 00:17:58.816
So that's the extent
of the shader changes.

00:17:59.376 --> 00:18:05.266
On the API side, I've
allocated a second buffer

00:18:05.376 --> 00:18:06.556
to -- hold my uniforms.

00:18:06.556 --> 00:18:08.446
And I'm going to call
the contents property,

00:18:08.446 --> 00:18:10.496
and that's just going to
return to me a void star.

00:18:10.956 --> 00:18:14.636
And, err, these are CPU/GPU
shared CommandBuffers,

00:18:14.636 --> 00:18:15.606
or shared -- not
Command Buffers.

00:18:15.606 --> 00:18:16.956
These are CPU/GPU shared memory.

00:18:17.446 --> 00:18:19.226
The GPU is reading from
exactly the same memory

00:18:19.226 --> 00:18:19.996
that GPU's writing.

00:18:20.316 --> 00:18:22.386
There's no lock or
unlock API calls

00:18:22.386 --> 00:18:23.446
or flushing or any of that.

00:18:24.006 --> 00:18:26.116
You can get a pointer,
[inaudible] it to a type

00:18:26.116 --> 00:18:27.426
of your choosing
and start writing.

00:18:28.206 --> 00:18:33.096
And then finally, I'm going to
set a second buffer argument

00:18:33.186 --> 00:18:36.626
to the vertex stage to point
the hardware at uniformBuffer.

00:18:37.556 --> 00:18:40.346
This is almost okay
but not quite.

00:18:40.346 --> 00:18:43.266
Because we actually have
a race condition here.

00:18:45.176 --> 00:18:49.456
So your application encodes
a frame and also writes

00:18:49.456 --> 00:18:50.856
to a uniform buffer
at the same time.

00:18:50.896 --> 00:18:53.656
And then we ship that off
to the GPU to be executed.

00:18:55.436 --> 00:18:57.976
The execution is going to take
some amount of time depending

00:18:57.976 --> 00:19:01.636
on the complexity of your scene.

00:19:02.486 --> 00:19:04.556
So if you have like a
conventional game loop,

00:19:04.556 --> 00:19:06.936
you're probably going to turn
around and immediately jump back

00:19:06.936 --> 00:19:07.786
up to the top of your loop

00:19:08.126 --> 00:19:09.966
and start encoding the
next frame right away.

00:19:10.606 --> 00:19:13.556
Of course the GPU, being
an asynchronous device,

00:19:13.626 --> 00:19:15.906
is still executing the
previous commandbuffer.

00:19:16.886 --> 00:19:19.786
So if I have go right to that
unit, I have a new frame.

00:19:20.066 --> 00:19:20.886
It's a new time stamp.

00:19:21.096 --> 00:19:22.316
It's a new model view matrix.

00:19:22.726 --> 00:19:24.516
But if I write that into
my buffer right now,

00:19:24.516 --> 00:19:28.216
I'm writing into the same memory
that the GPU is reading from.

00:19:28.356 --> 00:19:29.636
And I've created
a race condition.

00:19:30.246 --> 00:19:32.926
At that point what the GPU
reads is completely undefined.

00:19:34.766 --> 00:19:37.726
So, the easy thing to do is
write to a different buffer.

00:19:38.646 --> 00:19:39.746
So there's no conflict here.

00:19:40.256 --> 00:19:44.576
Then I come down into my
third frame and so forth.

00:19:44.576 --> 00:19:46.926
But there comes a point where
you just, where you, you know,

00:19:47.096 --> 00:19:48.666
you can't allocate
new buffers forever.

00:19:48.746 --> 00:19:50.226
There comes a point where
you're going to want

00:19:50.226 --> 00:19:52.446
to recycle an existing
buffer again.

00:19:53.216 --> 00:19:57.536
And the problem here is that,
a CPU can get, sometimes,

00:19:57.536 --> 00:19:59.306
depending on how you
structure your application,

00:19:59.606 --> 00:20:01.266
several frames ahead of the GPU.

00:20:01.776 --> 00:20:04.346
And the GPU might still
be working on that frame

00:20:04.556 --> 00:20:05.866
that you submitted
two frames ago.

00:20:06.396 --> 00:20:08.526
And we still have
a race condition.

00:20:10.216 --> 00:20:13.636
So the final step to resolving
this is that we need to wait.

00:20:13.806 --> 00:20:16.486
That your application needs
to not write to that buffer

00:20:16.746 --> 00:20:18.686
until you know that your code

00:20:18.686 --> 00:20:21.606
on the GPU is no
longer reading from it.

00:20:21.846 --> 00:20:23.406
Fortunately, that's pretty easy.

00:20:23.546 --> 00:20:24.866
It takes about four
lines of code.

00:20:24.866 --> 00:20:28.266
So I'm going to show
you that now.

00:20:29.146 --> 00:20:33.096
So I'm going to do this with
dispatch semaphores, which are,

00:20:33.096 --> 00:20:36.696
you know, a common low-level
synchronization primitive

00:20:36.696 --> 00:20:37.266
on iOS.

00:20:38.176 --> 00:20:39.606
So for this example,
I'm going to have a pool

00:20:39.606 --> 00:20:41.346
of three uniform
buffers I've created.

00:20:41.346 --> 00:20:43.456
So I'm going to create
a dispatch semaphore

00:20:43.456 --> 00:20:44.316
with a count of 3.

00:20:45.316 --> 00:20:48.146
I'm going to add my
common CommandBuffer loop.

00:20:48.146 --> 00:20:49.356
I'm going to build
a Command Buffer.

00:20:49.356 --> 00:20:50.476
And I'm going to
send it to the GPU.

00:20:51.556 --> 00:20:54.856
But right at the top, before
I write to any shared memory

00:20:54.856 --> 00:20:57.386
that I'm recycling, that the
GPU is potentially still reading

00:20:57.386 --> 00:20:58.696
from, I'm going to wait.

00:20:58.696 --> 00:20:59.726
And I'm going to make sure

00:21:00.056 --> 00:21:03.436
that the GPU has actually
finished executing

00:21:03.436 --> 00:21:05.986
that previous CommandBuffer
before I reuse the memory.

00:21:06.296 --> 00:21:10.476
So this is the second place,
apart from next drawable,

00:21:10.806 --> 00:21:13.286
where you probably see
an application block

00:21:13.386 --> 00:21:14.056
when using Metal.

00:21:14.546 --> 00:21:19.076
Now the other side of this is
we need to signal the semaphore

00:21:19.076 --> 00:21:21.016
when it is safe for the
application to proceed.

00:21:22.016 --> 00:21:24.966
So, in Metal, you can
add a completion handler

00:21:25.086 --> 00:21:25.906
to a CommandBuffer.

00:21:26.576 --> 00:21:29.156
When the GPU finishes
executing this CommandBuffer,

00:21:30.446 --> 00:21:33.066
the OS will invoke the
block that you provide,

00:21:33.126 --> 00:21:34.646
and you can do whatever
you want in there.

00:21:35.306 --> 00:21:37.906
In this case, I'm going to
signal the semaphore and say,

00:21:38.556 --> 00:21:39.866
"Hey a CommandBuffer finished.

00:21:40.216 --> 00:21:41.536
There's a uniform
buffer available.

00:21:42.266 --> 00:21:43.036
Start writing to it.

00:21:43.036 --> 00:21:43.586
Have a blast."

00:21:43.786 --> 00:21:46.246
And that's really it.

00:21:46.976 --> 00:21:51.456
So that's really the basic
walk-through through a simple

00:21:51.456 --> 00:21:53.356
"hello world" application
with some animation.

00:21:53.356 --> 00:21:54.466
It does shader constants.

00:21:54.726 --> 00:21:58.516
Does vertexArrays, and we
still have this setup 3D state.

00:22:00.096 --> 00:22:02.336
Went through some of the
basic initialization process.

00:22:03.036 --> 00:22:06.146
We showed how to set up
basic CommandBuffer draw.

00:22:06.146 --> 00:22:09.266
And we said hey, the moment
you produce any CPU dynamically

00:22:09.266 --> 00:22:12.106
produced data, we saw how you
have to synchronize access

00:22:12.106 --> 00:22:14.456
to that because we're just
giving you the raw memory

00:22:14.456 --> 00:22:16.476
pointers now.

00:22:18.356 --> 00:22:22.766
So, that thing -- these design
patterns actually go really far.

00:22:22.766 --> 00:22:26.186
For example, that same pattern
of synchronizing with semaphores

00:22:26.186 --> 00:22:28.906
or any other permit of your
choice, and the callbacks,

00:22:29.416 --> 00:22:31.996
for example, are just as
useful for dynamic vertex data,

00:22:32.436 --> 00:22:34.626
for streaming image
up-, texture updates,

00:22:34.626 --> 00:22:36.746
if you have a large open
world kind of scene.

00:22:37.456 --> 00:22:39.056
Or even if you're going
the other direction

00:22:39.096 --> 00:22:40.456
and having the GPU produce data,

00:22:41.256 --> 00:22:43.386
you know that the CPU
can read it as soon

00:22:43.386 --> 00:22:44.716
as that callback fires.

00:22:46.076 --> 00:22:49.686
So that's really your
introduction to a really simple

00:22:49.686 --> 00:22:50.686
"hello world" application.

00:22:50.836 --> 00:22:51.966
We made a spinning triangle.

00:22:52.146 --> 00:22:56.376
Hooray. So, with that,
that wraps up this.

00:22:56.376 --> 00:22:58.356
And so I'm going to turn the
stage over to my colleague Aafi,

00:22:58.686 --> 00:23:01.436
to talk to you in detail about
the Metal shading language.

00:23:01.786 --> 00:23:02.216
So thank you.

00:23:02.216 --> 00:23:03.766
[ Applause ]

00:23:03.766 --> 00:23:06.996
>> All right.

00:23:07.426 --> 00:23:08.066
Thanks Richard.

00:23:08.766 --> 00:23:13.416
All right, so we're going to
talk about the shading language.

00:23:13.626 --> 00:23:16.456
And so Jeremy mentioned
in the first presentation

00:23:16.456 --> 00:23:20.986
that this language is based
on C++, so a lot of you --

00:23:21.156 --> 00:23:23.656
most of you -- are all
familiar with writing C++ code.

00:23:23.656 --> 00:23:26.336
What we're going to talk
about is how we extended this

00:23:26.686 --> 00:23:29.406
to be able to write
shaders in Metal.

00:23:30.626 --> 00:23:33.936
So the things, the things
we're going to cover

00:23:33.936 --> 00:23:36.946
in this session is
how to write shaders.

00:23:36.946 --> 00:23:39.326
We're going to take a simple
vertex in the fragment shader

00:23:39.326 --> 00:23:41.916
and see how we can take
C++ code and make it

00:23:41.916 --> 00:23:43.166
into a vertex fragment shader.

00:23:43.586 --> 00:23:46.466
We will talk about data
types that Metal supports.

00:23:46.466 --> 00:23:50.896
We will talk about, you know,
well, shaders need inputs

00:23:50.896 --> 00:23:53.746
and outputs, so how do
you specify that in Metal.

00:23:54.226 --> 00:23:55.936
And, you know, if I'm
going to use them,

00:23:55.936 --> 00:23:58.216
because in the RenderPipeline,
I need a vertex shader

00:23:58.216 --> 00:24:01.126
and a fragment shader, well
how do I make sure I pair these

00:24:01.166 --> 00:24:01.856
things together?

00:24:02.416 --> 00:24:04.896
And then we'll talk
about math, okay?

00:24:05.436 --> 00:24:09.236
All right, so how to
write shaders in Metal.

00:24:09.236 --> 00:24:13.126
So let's take this in
a pseudo C code here.

00:24:13.596 --> 00:24:17.526
So what you see here in
this function is it takes

00:24:17.596 --> 00:24:18.416
three arguments.

00:24:18.416 --> 00:24:21.526
The first two are some
pointers to some structures

00:24:21.956 --> 00:24:24.676
and the return's this
vertex output struct which,

00:24:24.846 --> 00:24:25.806
you declared it.

00:24:26.276 --> 00:24:28.696
And what I want to
happen here is --

00:24:28.756 --> 00:24:32.986
remember, the vertex shader
is executing for each vertex,

00:24:32.986 --> 00:24:35.706
so if I have N vertices
in my primitive I want,

00:24:36.026 --> 00:24:38.256
there may be multiple threads
executing these vertices

00:24:38.256 --> 00:24:39.616
in parallel.

00:24:39.876 --> 00:24:43.616
So what I want to be
able to do is read

00:24:43.616 --> 00:24:45.426
in that thread that's
executing this vertex shader,

00:24:45.426 --> 00:24:49.096
which vertex am I actually
accessing so I can go

00:24:49.096 --> 00:24:50.716
and get the right index --

00:24:50.786 --> 00:24:53.746
use that index to access
the right vertex data.

00:24:54.156 --> 00:24:56.536
So, just you know,
imagine, just imagine

00:24:56.536 --> 00:24:59.056
that this is that ID, okay.

00:24:59.146 --> 00:25:01.716
So in this code, what we see
is we're going to use this ID

00:25:02.046 --> 00:25:04.936
and reference into
the input arguments.

00:25:04.936 --> 00:25:07.106
This is the vertex
data and UV data.

00:25:07.106 --> 00:25:08.866
Arguments have passed
to this function.

00:25:09.106 --> 00:25:11.316
And you will typically
probably do some computations.

00:25:11.316 --> 00:25:12.616
In this case I'm not doing much.

00:25:12.616 --> 00:25:14.406
I'm just going to copy
them and return them back.

00:25:15.016 --> 00:25:17.986
Well okay, how do I make this
into a Metal vertex shader?

00:25:18.146 --> 00:25:22.716
Well the first thing, note that
we don't -- and Metal doesn't --

00:25:22.716 --> 00:25:24.916
support the C++ standard
library.

00:25:24.916 --> 00:25:27.116
Instead Metal has its
own standard library

00:25:27.506 --> 00:25:30.156
that has been optimized
for the GPU.

00:25:30.156 --> 00:25:31.366
For the graphics and compute.

00:25:32.066 --> 00:25:33.846
In addition to that, so
I want to include that.

00:25:33.936 --> 00:25:37.016
In addition to that, you know,
types and functions defined

00:25:37.016 --> 00:25:39.276
by Metal actually are in
the Metal's namespace.

00:25:39.356 --> 00:25:40.886
So I'm just being lazy.

00:25:40.886 --> 00:25:43.426
Instead of explicitly calling
them, I'm just saying I'm going

00:25:43.426 --> 00:25:45.336
to use the Metal
namespace in my shader here.

00:25:45.676 --> 00:25:47.776
The next thing I'm
going to do is I'm going

00:25:47.776 --> 00:25:48.876
to tell the compiler, "hey,"

00:25:48.876 --> 00:25:50.436
that "this function
is a vertex function."

00:25:50.666 --> 00:25:53.316
Okay, so that's what
I'm going to do.

00:25:53.316 --> 00:25:57.966
And then Jeremy showed you
that any resource that's passed

00:25:57.966 --> 00:25:59.466
as arguments to your functions,

00:25:59.826 --> 00:26:01.786
you need to have the
argument indices.

00:26:01.786 --> 00:26:03.206
So in this case, you know,

00:26:03.206 --> 00:26:05.086
anything that's a pointer
is actually a buffer.

00:26:05.086 --> 00:26:07.366
So I'm going to assign
buffer indices.

00:26:07.666 --> 00:26:10.306
And there's this global
thing that I have added here.

00:26:10.306 --> 00:26:12.066
So just ignore that for now.

00:26:12.066 --> 00:26:13.926
I'll talk about what
that is in a few slides.

00:26:14.196 --> 00:26:16.496
So almost there.

00:26:16.946 --> 00:26:18.576
And I need to tell the compiler

00:26:18.576 --> 00:26:21.126
that that ID is actually
the vertex ID

00:26:21.126 --> 00:26:22.936
so it can generate
the right code for me.

00:26:23.196 --> 00:26:23.696
And that's it.

00:26:23.866 --> 00:26:26.476
That's a Metal vertex
shader, okay?

00:26:27.296 --> 00:26:33.666
What, nobody's going to clap?

00:26:33.666 --> 00:26:33.733
[ Applause ]

00:26:33.733 --> 00:26:33.800
[Laughs ]

00:26:33.800 --> 00:26:34.136
All right.

00:26:34.846 --> 00:26:37.866
And you know a fragment shader
is just very similar, OK?

00:26:38.026 --> 00:26:41.526
So I need to tell the compiler
it's a fragment function,

00:26:41.526 --> 00:26:43.436
so I use the fragment qualifier.

00:26:43.856 --> 00:26:47.986
Now note, remember the fragment
shader typically takes inputs

00:26:48.036 --> 00:26:51.146
that are generated
by the vertex shader.

00:26:51.146 --> 00:26:53.386
The output of the vertex
shader goes to the rasterizer

00:26:53.386 --> 00:26:55.806
and becomes inputs to
the fragment shader.

00:26:56.216 --> 00:26:59.236
So in this case, the vertex
shader returns VertexOutput

00:26:59.236 --> 00:27:00.936
and I want to use
that as an input.

00:27:01.116 --> 00:27:05.776
Now, this is some struct
that you have declared.

00:27:05.816 --> 00:27:07.536
So the compiler needs to know

00:27:07.806 --> 00:27:09.956
that this is a per
instance input.

00:27:10.006 --> 00:27:14.636
So anything that's user defined
and input to a vertex shader

00:27:14.636 --> 00:27:17.476
or fragment shader that needs
to be generated uniquely

00:27:17.476 --> 00:27:20.016
for instance, also
has to be qualified.

00:27:20.066 --> 00:27:22.376
And so in Metal you do
that by declaring that with

00:27:22.376 --> 00:27:24.176
that stage and attribute, okay?

00:27:24.876 --> 00:27:27.596
So what I'm doing is in this
shader I'm going to look

00:27:27.596 --> 00:27:30.966
at the texture coordinate per
fragment and use that to sample

00:27:31.366 --> 00:27:33.096
into a texture that'll
return the color value.

00:27:33.096 --> 00:27:34.226
So pretty straight forward.

00:27:34.226 --> 00:27:34.776
So that's it.

00:27:34.906 --> 00:27:37.196
It's really, you're going
to find that writing shaders

00:27:37.196 --> 00:27:38.896
in Metal is really, really easy.

00:27:39.086 --> 00:27:42.516
All right so let's
talk about data types.

00:27:42.816 --> 00:27:46.666
So, I've broken data
types into two categories.

00:27:47.166 --> 00:27:48.506
One I call the basic types.

00:27:48.766 --> 00:27:50.646
And then we have
resources and state objects.

00:27:51.046 --> 00:27:55.466
Note that one thing you
see is that all the inputs

00:27:55.466 --> 00:27:57.296
to a shader are passed
as arguments.

00:27:57.336 --> 00:27:58.196
There are no globals.

00:27:58.196 --> 00:28:00.226
So you declare everything
as arguments,

00:28:00.576 --> 00:28:03.096
and then if these are
resources or state objects,

00:28:03.576 --> 00:28:06.966
then you specify the indices
that the runtime will use

00:28:06.966 --> 00:28:08.416
to set the right resources to.

00:28:08.726 --> 00:28:10.136
Okay, so let's talk
about the base types.

00:28:10.136 --> 00:28:10.856
What are these?

00:28:10.856 --> 00:28:13.766
These are scalars, vectors,
matrices and atomics.

00:28:13.766 --> 00:28:16.866
So... the scalar is
pretty straightforward.

00:28:16.936 --> 00:28:18.656
I mean it doesn't
usually tell much.

00:28:18.826 --> 00:28:21.466
We support the C++11
scalar types.

00:28:22.376 --> 00:28:25.926
In addition to that,
we have the half type.

00:28:26.366 --> 00:28:26.636
Okay.

00:28:26.636 --> 00:28:26.866
[ Applause ]

00:28:26.866 --> 00:28:27.096
[ Laughs ]

00:28:27.096 --> 00:28:27.616
All right.

00:28:27.996 --> 00:28:31.486
So the half type.

00:28:31.486 --> 00:28:36.026
So this is the IEEE 754
16-bit floating point type.

00:28:36.026 --> 00:28:38.766
And so any operation
you could do with Float,

00:28:38.766 --> 00:28:40.216
is half of a first
class citizen.

00:28:40.216 --> 00:28:42.226
So anything you can do with
Float, you can do with Half.

00:28:42.456 --> 00:28:44.556
In fact, we really
want you to use half

00:28:44.556 --> 00:28:46.236
because they are
both performance

00:28:46.236 --> 00:28:50.076
and power optimizations that you
surely can take advantage of.

00:28:50.586 --> 00:28:52.386
Vectors: very similar.

00:28:52.626 --> 00:28:55.976
So you have you know, two, three
and four component vector types.

00:28:56.046 --> 00:29:00.266
So for example, a half2
is a two-component 16-bit

00:29:00.376 --> 00:29:01.286
floating-plan vector.

00:29:01.786 --> 00:29:06.186
Matrices: we have floating point
matrices, and they're stored

00:29:06.186 --> 00:29:09.056
in column major order,
just like they are in GL.

00:29:09.426 --> 00:29:12.726
The constructors and
operators: the things you can do

00:29:12.726 --> 00:29:14.716
on them are very similar
to what you would find

00:29:14.716 --> 00:29:15.786
in other shading languages,

00:29:15.976 --> 00:29:19.376
so I'm not really
going to cover that.

00:29:19.586 --> 00:29:21.016
But here's the thing
I want to talk about.

00:29:21.136 --> 00:29:22.856
So, remember your path.

00:29:22.856 --> 00:29:23.996
You're declaring a struct.

00:29:23.996 --> 00:29:25.696
You're passing a
pointer to that struct

00:29:26.066 --> 00:29:27.716
as argument to your shader.

00:29:27.716 --> 00:29:31.096
So what you want to be able
to do is declare these --

00:29:31.306 --> 00:29:32.356
let's say in a header file --

00:29:32.746 --> 00:29:35.336
and then use them both on the
host code because you're going

00:29:35.336 --> 00:29:36.886
to build this data
structure on the host.

00:29:37.366 --> 00:29:40.276
And then use this header
file also in your shader.

00:29:41.056 --> 00:29:43.456
Well you can do that
because these types --

00:29:44.206 --> 00:29:48.426
So, in iOS 8 we have
the SIMD math library,

00:29:48.426 --> 00:29:51.296
and so these define the
vector and matrices types.

00:29:51.296 --> 00:29:53.716
And Metal uses the
exact same types.

00:29:53.716 --> 00:29:56.936
So, what that means is: if
you include the SIMD header

00:29:57.036 --> 00:29:59.926
in your host code and you
can build the structures,

00:30:00.046 --> 00:30:00.916
you can share them.

00:30:01.356 --> 00:30:02.726
You don't have to
do anything special.

00:30:02.726 --> 00:30:04.176
It just works, okay?

00:30:04.176 --> 00:30:05.566
[ Laughs ]

00:30:05.566 --> 00:30:09.976
Not every slide, no
clapping every slide.

00:30:10.496 --> 00:30:13.716
Again, just like I said
previously, use the half vector

00:30:13.716 --> 00:30:16.376
and matrix types
whenever you can, okay?

00:30:16.906 --> 00:30:20.896
All right, so the last -- Oh, so
one more point on vector types.

00:30:21.186 --> 00:30:23.276
So they are aligned
at vector length.

00:30:23.476 --> 00:30:24.226
So what does that mean?

00:30:24.226 --> 00:30:28.216
So if I look at the struct,
what that means is: a float2,

00:30:28.386 --> 00:30:30.896
which is what b is, is going
to be aligned on 8 bytes.

00:30:31.156 --> 00:30:34.096
And similarly c is going to
be aligned with 16 bytes.

00:30:34.406 --> 00:30:37.666
But if you notice, b is
actually at an offset of 4.

00:30:38.626 --> 00:30:39.746
So that's a problem.

00:30:39.856 --> 00:30:41.286
So what the compiler will do is,

00:30:41.286 --> 00:30:43.976
it's going to generate
a padding variable.

00:30:44.196 --> 00:30:45.626
Okay, so when you
do sizeof(Foo),

00:30:45.626 --> 00:30:47.046
you're only going
to get 32 bytes.

00:30:47.046 --> 00:30:51.256
So depending on how big your
data structure is and what kind

00:30:51.256 --> 00:30:52.746
of scalars and vectors you use,

00:30:53.086 --> 00:30:54.516
the compiler may
potentially have

00:30:54.516 --> 00:30:55.636
to generate lots of padding.

00:30:55.636 --> 00:30:58.816
And if you're going to declare
an array of these structs, then,

00:30:58.816 --> 00:31:00.866
you know, it has
potential implications

00:31:00.866 --> 00:31:04.406
to your allocation size
and even memory bandwidth

00:31:04.406 --> 00:31:06.926
when you access these data
structures in a shader code.

00:31:07.326 --> 00:31:11.156
So, well, you may want to
be smart and say, "well,

00:31:11.156 --> 00:31:14.126
let me declare them in
order of decreasing size;

00:31:14.156 --> 00:31:15.906
put all of my biggest
data types first,

00:31:16.326 --> 00:31:17.836
and then the smaller types."

00:31:18.586 --> 00:31:20.826
Well if you try to do
a sizeof(Foo) on that,

00:31:21.136 --> 00:31:22.496
you're still going
to get 32 bytes.

00:31:22.786 --> 00:31:24.376
And you're like, "why is that?"

00:31:24.926 --> 00:31:28.356
The reason for that is the
compiler still has to guarantee

00:31:28.766 --> 00:31:31.626
that each struct is
aligned to the site

00:31:31.626 --> 00:31:33.836
of the largest data
type in that struct.

00:31:34.446 --> 00:31:37.136
Because if you were to
use an array of these,

00:31:37.136 --> 00:31:40.126
if you type index C at index 1,

00:31:40.506 --> 00:31:42.386
you have to make sure
it's aligned on 16 bytes.

00:31:42.676 --> 00:31:43.456
So that doesn't work.

00:31:44.026 --> 00:31:47.626
So what if I wanted to tightly
pack all my data structures?

00:31:48.126 --> 00:31:48.966
Yes, you can do that.

00:31:48.966 --> 00:31:51.056
And we have packed
vector types for that.

00:31:51.796 --> 00:31:54.046
So they are just like
the aligned vector types.

00:31:54.096 --> 00:31:56.796
They're declared with this
"packed underscore" prefix.

00:31:57.746 --> 00:32:01.896
You can do all of the operations
on these types as you can

00:32:01.966 --> 00:32:03.246
on the aligned vector types.

00:32:04.076 --> 00:32:07.436
The only benefit is that a
line is scalar type length.

00:32:07.606 --> 00:32:11.756
So if I declare the same struct
now, but use the packed types,

00:32:12.376 --> 00:32:14.066
then these are aligned
correctly.

00:32:14.066 --> 00:32:16.466
And so the sizeof(Foo)
is going to be 28 bytes.

00:32:16.786 --> 00:32:19.976
So then you are ask, "well why
shouldn't I always use these

00:32:19.976 --> 00:32:20.586
packed types?"

00:32:21.486 --> 00:32:23.406
And the reason, the
answer to that depends

00:32:23.406 --> 00:32:26.186
on how you are going to
use these on the host.

00:32:26.186 --> 00:32:31.426
Because the CPU, these types
are not a good fit for the CPU.

00:32:31.426 --> 00:32:33.786
But the CPU likes vector
types to be aligned.

00:32:33.786 --> 00:32:35.766
So if you're just
building a data structure,

00:32:36.106 --> 00:32:38.696
and just filling it
out and going to pass

00:32:38.696 --> 00:32:41.776
that to the shader (and
most of your computations

00:32:41.776 --> 00:32:43.186
on these data types
are going to happen

00:32:43.186 --> 00:32:45.186
in the shader) then you
can use the packed types.

00:32:45.626 --> 00:32:48.436
But if you're going to perform
computations with these types

00:32:49.336 --> 00:32:51.916
in host code, then you should
use the aligned vector types.

00:32:52.256 --> 00:32:55.816
So use that to determine like
which types you need to use.

00:32:56.116 --> 00:32:58.796
All right, so the last
of the basic types,

00:32:58.796 --> 00:32:59.986
and these are the atomic types.

00:33:00.476 --> 00:33:04.346
And so we support a subset
of the C++11 atomic types.

00:33:04.936 --> 00:33:07.686
And the question is, "why
should I use atomic types?"

00:33:07.796 --> 00:33:11.416
Well, the operations on
these types are race-free.

00:33:11.516 --> 00:33:12.886
So, let's take an example.

00:33:12.886 --> 00:33:15.206
Let's say I'm generating
a histogram for an image.

00:33:15.616 --> 00:33:17.016
And so I have 8 bits
per channel.

00:33:17.016 --> 00:33:20.026
So I have 256 bins for
each color channel.

00:33:20.526 --> 00:33:22.196
So I want to update a bin.

00:33:22.456 --> 00:33:23.666
So I'm going to read
the current value.

00:33:23.726 --> 00:33:25.826
I'm going to increment
it, and then write it out.

00:33:25.826 --> 00:33:28.936
So what I want to make sure
is that after I've read

00:33:29.076 --> 00:33:31.826
but before I've written, nobody
else comes and changes it.

00:33:31.976 --> 00:33:34.706
And that's what these
atomic operations guarantee.

00:33:35.226 --> 00:33:38.326
Okay? All right, so that
covers the basic types.

00:33:38.896 --> 00:33:42.136
So let's talk about resource and
state objects that you can pass

00:33:42.606 --> 00:33:43.796
as data types to your shader.

00:33:45.826 --> 00:33:49.156
All right, so we support the
traditional texture types

00:33:49.156 --> 00:33:51.806
like 1d, 1dArray, 2d, 2dArray,

00:33:52.096 --> 00:33:54.006
but how do you declare
these in Metal?

00:33:54.096 --> 00:33:58.556
So these are declared
as a template.

00:33:58.556 --> 00:33:58.926
[ Laughs ]

00:33:58.926 --> 00:34:00.256
He likes it, all right.

00:34:00.376 --> 00:34:03.416
So the template takes
two parameters.

00:34:03.416 --> 00:34:04.616
One is the color type.

00:34:04.616 --> 00:34:07.656
And this indicates if
you're going to sample

00:34:07.656 --> 00:34:10.356
from a texture the vector
type you're going to return,

00:34:10.856 --> 00:34:13.676
or as a color value, or
if you're going to write

00:34:13.916 --> 00:34:15.346
to the texture, what
is the vector type

00:34:15.696 --> 00:34:17.206
that would represent
the color value?

00:34:17.416 --> 00:34:18.335
And the access mode.

00:34:18.565 --> 00:34:21.275
And this tells the compiler
whether you're going

00:34:21.275 --> 00:34:24.886
to be sampling from a
texture or reading or writing.

00:34:25.005 --> 00:34:27.216
Reading is just saying, "hey,

00:34:27.216 --> 00:34:31.496
go read this specific
location pixel in my texture"

00:34:31.545 --> 00:34:33.866
or "write this color value

00:34:33.866 --> 00:34:35.636
to this specific
location in the texture."

00:34:36.255 --> 00:34:38.356
You can sample and
read or write.

00:34:38.505 --> 00:34:41.936
You cannot do both to the
same texture within a shader.

00:34:43.436 --> 00:34:44.896
And that texture is
of a different type

00:34:44.896 --> 00:34:47.656
because the GPU actually
optimizes them differently.

00:34:47.656 --> 00:34:48.565
And so we need to know

00:34:48.565 --> 00:34:50.815
that you're actually
working with a depth texture.

00:34:51.656 --> 00:34:53.446
So let's look at some examples.

00:34:54.246 --> 00:34:56.726
So in this first one
we have a 2d texture,

00:34:56.946 --> 00:34:58.416
and its color type is float.

00:34:58.416 --> 00:34:59.796
So if you sample from
this, you're going

00:34:59.796 --> 00:35:00.816
to return the float forward.

00:35:01.176 --> 00:35:02.806
Notice I didn't specify
the access mode

00:35:02.806 --> 00:35:05.526
because it has a
default, which is sample.

00:35:05.946 --> 00:35:11.326
So the next one is a 2d texture
again which uses the half type

00:35:11.326 --> 00:35:13.196
and its access mode is write.

00:35:13.196 --> 00:35:16.286
So if I try to read from
this texture in my shader,

00:35:16.286 --> 00:35:17.576
the compiler will
throw an error.

00:35:17.616 --> 00:35:20.606
And then finally we
have a depth texture.

00:35:20.856 --> 00:35:24.546
Okay? Samplers are
separate from textures.

00:35:24.836 --> 00:35:26.656
So, what does that mean?

00:35:26.656 --> 00:35:29.966
That means I can use the same
sampler with multiple textures.

00:35:29.966 --> 00:35:31.946
Or I can use multiple samplers

00:35:31.946 --> 00:35:33.346
of the same thing
with one texture.

00:35:33.926 --> 00:35:34.706
You have the freedom.

00:35:35.206 --> 00:35:36.206
How do I pass these?

00:35:36.426 --> 00:35:39.326
Well, like I said, everything
is passed as an argument,

00:35:39.326 --> 00:35:41.636
so you can pass them as an
argument to your shader.

00:35:41.636 --> 00:35:44.646
In addition though, you
can actually declare them

00:35:44.646 --> 00:35:45.356
in your source.

00:35:45.876 --> 00:35:47.856
So it depends.

00:35:47.856 --> 00:35:50.846
So like in a lot of cases,
especially if you're doing, ah,

00:35:50.846 --> 00:35:53.396
image processing filters -- you
know, you just need a handful

00:35:53.396 --> 00:35:55.606
of samplers that
you're going to use.

00:35:56.106 --> 00:35:57.916
And data declared is
a variadic template.

00:35:57.916 --> 00:36:00.296
And the reason for that
is samples have a number

00:36:00.296 --> 00:36:02.926
of properties like the filter
mode, the addressing mode,

00:36:03.416 --> 00:36:05.706
whether the coordinates I'm
going to use are normalized

00:36:05.706 --> 00:36:07.626
or pixel, and a bunch
of other things.

00:36:07.716 --> 00:36:11.496
I don't want to have to set
them explicitly every time.

00:36:11.716 --> 00:36:13.106
All of these have defaults.

00:36:13.396 --> 00:36:15.186
So you only change
the one you want to,

00:36:15.186 --> 00:36:16.656
you are changing
from the defaults.

00:36:16.656 --> 00:36:19.666
So in this example, I'm changing
the address more from clamp

00:36:19.666 --> 00:36:23.716
to clamp to zero, and the other
properties take the default.

00:36:24.276 --> 00:36:26.796
So you can choose to
pass them as an argument,

00:36:26.796 --> 00:36:28.746
or you can choose them to
declare them in your source,

00:36:28.746 --> 00:36:29.656
depending on your needs.

00:36:30.966 --> 00:36:32.296
All right, so last of the types.

00:36:32.566 --> 00:36:36.986
All right, so buffers is just
(as Jeremy mentioned) a bag

00:36:36.986 --> 00:36:37.356
of bytes.

00:36:37.486 --> 00:36:40.856
And so you just pass a pointer
or a reference to this type.

00:36:41.086 --> 00:36:43.616
And notice in the first slide
I have this global qualifier.

00:36:43.616 --> 00:36:45.226
Well let's talk about that now.

00:36:45.526 --> 00:36:48.366
See, anything that's passed
as a pointer, or a reference

00:36:48.366 --> 00:36:49.796
to some memory, you need to say

00:36:49.796 --> 00:36:51.356
which memory region
it comes from.

00:36:51.866 --> 00:36:54.476
And that's because GPUs actually
implement the member hierarchy.

00:36:55.126 --> 00:36:57.206
With compute, you got an
additional memory region.

00:36:57.206 --> 00:36:58.876
But if you're just writing
vertex and fragment shaders,

00:36:58.916 --> 00:37:02.436
the two memory regions (we
call them address spaces),

00:37:02.436 --> 00:37:04.756
you need to worry about
our global and constant.

00:37:04.866 --> 00:37:07.096
So the question is, "well
when should I use which?"

00:37:07.976 --> 00:37:11.246
All right, so if you are
writing a vertex shader,

00:37:11.676 --> 00:37:14.666
you pass pointers to some
buffers, you're going

00:37:14.666 --> 00:37:16.796
to use your vertex
ID to index into it.

00:37:16.986 --> 00:37:20.926
That means for each, if the
vertex shader is being executed

00:37:20.926 --> 00:37:24.596
over N vertices, all
of these instances

00:37:24.596 --> 00:37:26.136
that are executing the
vertex shader are going

00:37:26.136 --> 00:37:27.566
to be unique locations.

00:37:27.746 --> 00:37:30.916
So when you see that data
pattern, you want to use global.

00:37:32.196 --> 00:37:33.576
Okay, and the same
thing for compute.

00:37:33.626 --> 00:37:35.496
You will find that
out when we talk

00:37:35.496 --> 00:37:36.636
about computing in
the next session.

00:37:37.486 --> 00:37:41.906
However, you will also find
in your shader that you may,

00:37:42.136 --> 00:37:45.066
you are actually accessing
some data structures where all

00:37:45.066 --> 00:37:48.656
of these instances actually
access the same location.

00:37:48.856 --> 00:37:51.986
For example, if you
have a light descriptor.

00:37:52.296 --> 00:37:53.416
Or if you're doing skinning.

00:37:53.416 --> 00:37:54.406
Or if you're doing filtering.

00:37:55.046 --> 00:37:56.356
So in this case you will find

00:37:56.356 --> 00:38:00.876
that all these instances
executing your vertex shader go

00:38:00.876 --> 00:38:02.536
refer to the same
light descriptor.

00:38:02.756 --> 00:38:04.416
Or the same skinning matrix.

00:38:04.736 --> 00:38:05.826
So let's look at an example.

00:38:06.336 --> 00:38:08.746
One more thing here is
that when you use constant,

00:38:08.986 --> 00:38:10.566
we really want you
to pass by reference.

00:38:11.006 --> 00:38:12.826
Because that tells
us what the size is

00:38:12.826 --> 00:38:15.186
and we can actually optimize
by prefetching the data.

00:38:15.246 --> 00:38:18.606
And that can have a significant
impact to improvement

00:38:18.606 --> 00:38:19.596
of performance of your shader.

00:38:19.706 --> 00:38:23.146
So definitely take
advantage of that.

00:38:23.146 --> 00:38:24.346
Okay, so let's take an example.

00:38:24.846 --> 00:38:27.926
Here I have four arguments
passing three buffers

00:38:28.396 --> 00:38:29.386
and my vertex ID.

00:38:29.386 --> 00:38:30.976
So let's look at the
first data pattern.

00:38:31.516 --> 00:38:33.136
Look at normal data
and position data.

00:38:33.136 --> 00:38:35.876
I'm actually accessing
using my vertex ID,

00:38:35.876 --> 00:38:38.886
so which address space
should these belong in?

00:38:40.176 --> 00:38:42.376
Global. But if you look

00:38:42.376 --> 00:38:46.786
at the other three data
pattern accesses and matrices,

00:38:46.786 --> 00:38:48.576
you notice that if,

00:38:48.796 --> 00:38:51.056
in a multiple vertices
root exiting this function

00:38:51.056 --> 00:38:53.246
across multiple vertices,
they're going to refer

00:38:53.246 --> 00:38:56.536
to the same normal matrix,
the same projection matrix.

00:38:57.026 --> 00:38:59.696
So, therefore, I
should declare these

00:38:59.696 --> 00:39:00.826
in a constant address space.

00:39:00.826 --> 00:39:02.886
So hopefully this gives
you an idea of how

00:39:02.886 --> 00:39:05.326
to declare your buffers
in which address space.

00:39:05.446 --> 00:39:06.786
You don't have to do
that for textures.

00:39:07.206 --> 00:39:11.056
All right, so let's talk
about inputs and outputs.

00:39:11.056 --> 00:39:14.526
So that was a very high-level
overview of the data types.

00:39:14.526 --> 00:39:17.736
So, how do you pass input
through your vertex shader?

00:39:17.886 --> 00:39:18.886
Well there are two ways.

00:39:19.346 --> 00:39:21.026
The first one we've
actually shown you, right?

00:39:21.026 --> 00:39:24.186
In all of the examples I have
shown you, you pass the input

00:39:24.296 --> 00:39:27.266
by passing a pointer to a
struct, so you've declared,

00:39:27.266 --> 00:39:29.276
and then you use your
vertex ID to index into it.

00:39:29.626 --> 00:39:32.486
So that means is you
actually know the data layout

00:39:33.146 --> 00:39:34.726
of your vertex inputting
in a shader.

00:39:34.796 --> 00:39:38.056
So if you do, this is
the way to do it, okay?

00:39:38.056 --> 00:39:40.506
So in addition to your vertex
ID you can also use your

00:39:40.506 --> 00:39:41.206
instance ID.

00:39:42.246 --> 00:39:45.076
Like in this example, I
have two inputs I'm passing

00:39:45.076 --> 00:39:49.736
in as buffers, and I'm using
the vertex ID and instance ID.

00:39:50.046 --> 00:39:52.946
But there is also the
traditional approach.

00:39:53.486 --> 00:39:57.216
So in this approach, you
don't know the data layout

00:39:57.456 --> 00:39:58.076
in your shader.

00:39:58.546 --> 00:40:01.656
And so if you want it all,
you may want to decouple.

00:40:01.886 --> 00:40:05.276
You may want to declare in your
vertex shader the data types you

00:40:05.276 --> 00:40:07.056
want to use for your
vertex inputs

00:40:07.056 --> 00:40:09.106
because of the computations
you're doing in your shader,

00:40:09.606 --> 00:40:13.056
and have the flexibility to be
able to declare the actual input

00:40:13.296 --> 00:40:15.146
at runtime in the
buffers are showing,

00:40:15.146 --> 00:40:15.976
and they may be different.

00:40:16.486 --> 00:40:20.376
So, this is more like the
OpenGL's Vertex Array API.

00:40:20.376 --> 00:40:25.006
And so this, this approach in
Metal is actually a good match.

00:40:25.096 --> 00:40:26.936
And let me talk about
how it works.

00:40:27.346 --> 00:40:28.176
So the thing you'll do

00:40:28.176 --> 00:40:30.586
in the runtime is you will
create a vertex descriptor.

00:40:30.656 --> 00:40:32.906
So in this descriptor for
each input, you're going

00:40:32.906 --> 00:40:36.546
to specify the buffer it comes
from, where inside the buffer,

00:40:37.566 --> 00:40:39.936
what is the format,
things like that.

00:40:40.376 --> 00:40:43.106
And you may have one or more
buffers for your inputs.

00:40:43.346 --> 00:40:46.826
In the shader, everything
that is an input, you're going

00:40:46.826 --> 00:40:47.916
to declare them in a struct.

00:40:47.916 --> 00:40:51.456
And remember I said, anything
that's user-defined information

00:40:51.456 --> 00:40:53.186
that you want to
generate per instance,

00:40:53.936 --> 00:40:54.846
you have to use stage-in.

00:40:54.846 --> 00:40:55.936
So that's how you declare it.

00:40:56.616 --> 00:40:58.506
So let's look at a code example.

00:40:59.986 --> 00:41:00.816
Ah, before that.

00:41:01.276 --> 00:41:02.986
So I declared my
struct and my shader,

00:41:03.196 --> 00:41:05.216
and I declared my
vertex descriptor.

00:41:05.556 --> 00:41:07.776
All my inputs and my vertex
descriptor, I need to be able

00:41:07.776 --> 00:41:08.926
to say, "hey, this will work --

00:41:08.926 --> 00:41:11.246
I need to be able to
map one to the other."

00:41:11.346 --> 00:41:12.876
And the way I do that is

00:41:12.876 --> 00:41:15.376
by specifying an
attribute index, okay?

00:41:15.466 --> 00:41:16.396
So let's look at an example.

00:41:16.396 --> 00:41:19.236
Let's say I want to
pass four inputs.

00:41:19.406 --> 00:41:21.906
The first one is going to be
positioned, and it's going

00:41:21.906 --> 00:41:25.306
to be an index 0,
and 12 bytes in size.

00:41:25.376 --> 00:41:26.706
The next one is normal.

00:41:27.186 --> 00:41:29.656
It's also at offset 12
and 12 bytes in size.

00:41:29.656 --> 00:41:31.356
In fact, all four
inputs are going

00:41:31.356 --> 00:41:32.426
to come from the same buffer.

00:41:32.816 --> 00:41:36.486
And so the next one is color
at index 2, 4 bytes in size.

00:41:36.486 --> 00:41:39.606
And then third is texture
coordinate at index 3,

00:41:39.606 --> 00:41:40.926
4 bytes in size, okay.

00:41:41.366 --> 00:41:43.026
All right, so how do I
declare this in the shader?

00:41:43.516 --> 00:41:44.526
So I have a struct.

00:41:44.526 --> 00:41:47.716
I have defined the data
types I want to use,

00:41:48.146 --> 00:41:50.326
and the attribute indices
they're going to use.

00:41:50.326 --> 00:41:53.226
And notice that I've declared
them with the stage-in qualifier

00:41:53.226 --> 00:41:54.966
because this is going
to be per instance.

00:41:55.436 --> 00:41:57.376
For every instance it
executes as a vertex shader.

00:41:57.476 --> 00:41:59.276
Okay, so let's look at the API.

00:41:59.776 --> 00:42:00.696
So the first thing I'm going

00:42:00.696 --> 00:42:02.776
to do is create the
vertex descriptor.

00:42:03.536 --> 00:42:06.496
So the first imput
was my position.

00:42:06.576 --> 00:42:08.886
So I'm going to say
float3 is 12 bytes.

00:42:08.966 --> 00:42:11.296
So it's going to
start us off at 0.

00:42:11.926 --> 00:42:15.996
And notice I had a single
buffer for all of the input.

00:42:15.996 --> 00:42:18.406
So my buffer index for all
of these is going to be 0.

00:42:19.226 --> 00:42:20.446
The attribute index is 0.

00:42:21.186 --> 00:42:24.696
So next I set the
normal, so at index1.

00:42:24.696 --> 00:42:28.286
The next I set color, at index2.

00:42:28.676 --> 00:42:29.346
Texture coordinate.

00:42:30.156 --> 00:42:32.466
And for each buffer
that I'm using

00:42:32.746 --> 00:42:35.286
to declare my vertex
inputs in my descriptor,

00:42:35.656 --> 00:42:37.786
I have to say the
stride, what is the stride

00:42:37.786 --> 00:42:39.376
so I can fetch the
right vertex data.

00:42:40.066 --> 00:42:41.476
So in this case it's 32 bytes.

00:42:41.626 --> 00:42:42.366
So I did that.

00:42:43.276 --> 00:42:44.826
Then I put this vertex
descriptor

00:42:45.376 --> 00:42:47.076
to in my pipeline descriptor.

00:42:47.226 --> 00:42:49.536
And then I create
my pipeline object,

00:42:49.606 --> 00:42:50.736
my RenderPipeline object.

00:42:51.026 --> 00:42:55.206
And at that point in time,
Metal will go figure out how

00:42:55.206 --> 00:42:57.016
to generate the code
to go fetch your input.

00:42:57.226 --> 00:42:58.576
So, you have both
options available.

00:42:58.576 --> 00:43:02.216
Use which works best
for your problem.

00:43:02.606 --> 00:43:06.606
All right, outputs: well, there
are two ways of writing inputs,

00:43:06.606 --> 00:43:08.516
so we wanted to make
sure you get two ways

00:43:08.516 --> 00:43:09.506
of writing outputs too.

00:43:10.466 --> 00:43:13.576
So, typically what you
would do is the output

00:43:13.576 --> 00:43:15.906
of your vertex shader will go
the rasterizer, because you want

00:43:15.906 --> 00:43:17.446
to show something on the screen,

00:43:17.446 --> 00:43:18.796
so you want to rasterize
triangles.

00:43:19.276 --> 00:43:22.856
So anything that you
return from the return type

00:43:22.856 --> 00:43:25.306
of your vertex shader is what's
going to go to the rasterizer.

00:43:25.566 --> 00:43:26.416
So what can I return?

00:43:26.626 --> 00:43:27.786
I can return a float4.

00:43:27.996 --> 00:43:30.996
At a minimum I must return a
float4, and I'll tell you why.

00:43:31.416 --> 00:43:33.106
Or you can have a
user-defined struct.

00:43:33.606 --> 00:43:35.106
What can be in this struct?

00:43:35.316 --> 00:43:38.736
So there can be a scalar,
a vector or a matrix.

00:43:38.736 --> 00:43:39.966
You can even have
arrays of these.

00:43:40.776 --> 00:43:42.476
There's some special
variables we need to know

00:43:42.476 --> 00:43:44.876
about like position, point size

00:43:44.876 --> 00:43:47.096
if you're rendering a point
sprite or clip distance.

00:43:47.586 --> 00:43:49.946
You must return a float4
because position must always

00:43:49.946 --> 00:43:50.376
be returned.

00:43:50.376 --> 00:43:51.616
It's kind of hard
for the rasterizer

00:43:51.616 --> 00:43:54.306
to generate rasterized triangles
without knowing position.

00:43:54.816 --> 00:43:55.376
So that's why.

00:43:57.336 --> 00:43:58.946
All right, so here's an example.

00:43:59.926 --> 00:44:01.076
I'm returning four things.

00:44:01.686 --> 00:44:05.706
And I use the built-in variables
attributes to identify things

00:44:05.706 --> 00:44:07.146
such as position and point size.

00:44:07.226 --> 00:44:08.806
This is really pretty
straight forward.

00:44:08.806 --> 00:44:11.596
Declare your struct, declare
some attributes and you're done.

00:44:12.606 --> 00:44:14.146
Okay. So it's great.

00:44:14.936 --> 00:44:17.826
I can generate output,
pass it to the rasterizer.

00:44:17.986 --> 00:44:18.976
But I want to do more.

00:44:20.256 --> 00:44:22.966
I want to be able to
write some buffer,

00:44:23.066 --> 00:44:24.336
maybe more than one buffer.

00:44:24.336 --> 00:44:26.416
I don't want to send
anything to the rasterizer.

00:44:26.616 --> 00:44:27.776
Or maybe I want to do both.

00:44:28.236 --> 00:44:28.826
Can I do that?

00:44:29.116 --> 00:44:34.216
The answer is, "we
are here to please."

00:44:34.216 --> 00:44:35.306
[ Laughs ]

00:44:35.306 --> 00:44:36.396
[ Applause ]

00:44:36.396 --> 00:44:39.386
So remember the vertex ID
you can use that to input.

00:44:39.386 --> 00:44:40.496
Well guess what?

00:44:40.496 --> 00:44:42.726
You can use that to output too.

00:44:42.856 --> 00:44:45.226
So here is the structure
I want to write out.

00:44:45.256 --> 00:44:51.666
I want to pass that as --
declare that as a struct,

00:44:51.666 --> 00:44:52.356
ah, create a buffer...

00:44:52.356 --> 00:44:54.206
Pass that as an argument
to my shader,

00:44:55.036 --> 00:44:57.716
and output to it
using the vertex ID.

00:44:58.236 --> 00:45:05.636
In fact, I can pass up to 31
buffers if one is not enough.

00:45:05.636 --> 00:45:05.703
[ Applause ]

00:45:05.703 --> 00:45:08.056
You notice I'm not
returning anything here

00:45:08.056 --> 00:45:11.296
because of the return type.

00:45:11.456 --> 00:45:13.226
But I could have returned
the same struct here,

00:45:13.396 --> 00:45:15.366
or I could return something
completely different.

00:45:15.656 --> 00:45:18.336
So you have a lot
of flexibility here.

00:45:18.666 --> 00:45:19.006
All right.

00:45:19.846 --> 00:45:21.706
So that's per-vertex
inputs/outputs.

00:45:21.926 --> 00:45:23.566
Per-fragments are a lot simpler.

00:45:23.696 --> 00:45:25.146
There's only one way
of doing things here.

00:45:25.696 --> 00:45:31.786
So, the inputs to a fragment
shader are typically the outputs

00:45:31.786 --> 00:45:33.906
of the vertex shader because
they go to the rasterizer

00:45:34.016 --> 00:45:36.526
and they generate fragments
and that's the inputs.

00:45:36.996 --> 00:45:38.776
So what can I --
must be declared

00:45:38.776 --> 00:45:39.926
in with this stage-in qualifier.

00:45:41.776 --> 00:45:44.666
Sometimes the raster also
generates information

00:45:44.666 --> 00:45:46.546
that you may actually
want to know about, like,

00:45:46.546 --> 00:45:48.066
"is my triangle front-facing?"

00:45:48.616 --> 00:45:50.176
Or if I'm doing multi-sampling.

00:45:51.226 --> 00:45:53.186
So things like that,
you can use attributes

00:45:53.726 --> 00:45:55.646
to identify these inputs.

00:45:55.736 --> 00:45:57.896
And if you wanted to
program a blending,

00:45:58.216 --> 00:45:59.996
you want to read the
frame buffer color value.

00:46:00.276 --> 00:46:01.076
So, you can.

00:46:01.666 --> 00:46:02.926
So let's talk about
how I do that.

00:46:03.136 --> 00:46:04.276
So here's an example.

00:46:05.136 --> 00:46:08.716
In this case, my fragment
input was the output

00:46:08.716 --> 00:46:09.636
of the vertex shader.

00:46:09.926 --> 00:46:12.136
So I used the staging
qualifier to say

00:46:12.136 --> 00:46:13.676
that this is a per-fragment
input.

00:46:14.686 --> 00:46:18.106
I want to read whether the
triangle is front-facing or not.

00:46:18.106 --> 00:46:20.696
So I use this attribute
to identify

00:46:20.696 --> 00:46:22.986
that this front face is
a front-facing variable.

00:46:23.056 --> 00:46:25.386
And I also want to do
blending in my shader.

00:46:25.646 --> 00:46:28.066
So I'm going to read
front color attachment 0.

00:46:29.856 --> 00:46:31.936
Though I passed as a
separate arguments here,

00:46:31.936 --> 00:46:32.866
they don't have to be.

00:46:32.866 --> 00:46:37.406
I could have declared them
in the struct itself, okay?

00:46:38.126 --> 00:46:40.166
Outputs from a fragment
shader work just

00:46:40.166 --> 00:46:41.906
like outputs from
a vertex shader.

00:46:42.226 --> 00:46:43.256
You can't write to
memory though.

00:46:43.356 --> 00:46:44.176
Only the first one.

00:46:44.176 --> 00:46:45.106
So you only return type.

00:46:45.106 --> 00:46:49.016
And you can return a scalar,
vector or user-defined struct.

00:46:49.016 --> 00:46:50.146
A lot of flexibility here.

00:46:50.476 --> 00:46:51.756
But the only thing
you can return

00:46:51.756 --> 00:46:55.536
in a fragment shader is a
color, a depth or a sample mask.

00:46:55.796 --> 00:46:57.676
And we need to know so you have

00:46:57.676 --> 00:46:59.546
to four color attachments,
one depth.

00:46:59.966 --> 00:47:00.866
And sample mask.

00:47:00.866 --> 00:47:02.126
We need to know what
you're writing to.

00:47:02.186 --> 00:47:05.156
And so you identify them
with attributes, okay?

00:47:06.036 --> 00:47:10.696
So in this example, I'm
just returning a single

00:47:10.696 --> 00:47:11.836
and a color value back.

00:47:11.836 --> 00:47:13.826
This is going to be returned
to color attachment zero.

00:47:14.676 --> 00:47:17.646
Here's another example where I'm
returning more than one color.

00:47:17.946 --> 00:47:20.726
And notice here that the color
attachments don't have to be

00:47:20.726 --> 00:47:22.356
in the right order, okay?

00:47:22.426 --> 00:47:23.396
They can be sparse.

00:47:24.836 --> 00:47:27.166
All right, you guys ready
for some matchmaking?

00:47:28.436 --> 00:47:33.176
All right, so I've written,
you've written a vertex shader

00:47:33.176 --> 00:47:34.086
and a fragment shader.

00:47:34.516 --> 00:47:36.986
I want to pair them because
I can't do the RenderPipeline

00:47:36.986 --> 00:47:37.496
without it.

00:47:37.496 --> 00:47:38.496
So how do I pair?

00:47:38.786 --> 00:47:39.516
What are the rules?

00:47:39.976 --> 00:47:41.916
The simplest rule
is that types match.

00:47:42.776 --> 00:47:46.536
That means the return type of
the vertex shader is the input

00:47:46.756 --> 00:47:47.556
to the fragment sharer.

00:47:47.626 --> 00:47:49.406
In this example,
that's what it is.

00:47:50.356 --> 00:47:52.576
And this will always pair, okay?

00:47:53.386 --> 00:47:54.586
But that's boring.

00:47:54.736 --> 00:47:59.856
I want to just, I want
to declare my own struct

00:47:59.946 --> 00:48:01.626
as my input to my
fragment shader,

00:48:01.626 --> 00:48:03.976
and that can be a subset.

00:48:03.976 --> 00:48:05.606
In fact, that's typically
very common

00:48:05.636 --> 00:48:08.696
if I use one vertex shader with
many, many fragment shaders.

00:48:08.696 --> 00:48:09.936
So where's the rule here then?

00:48:09.936 --> 00:48:10.566
How do I pair?

00:48:10.566 --> 00:48:11.906
The rule is really simple.

00:48:12.036 --> 00:48:14.556
For anything that's an
input to the fragment,

00:48:15.696 --> 00:48:20.726
it's attribute name and type
must exist in the vertex output.

00:48:20.916 --> 00:48:23.856
So in this example,
you know, I have:

00:48:24.746 --> 00:48:27.196
position is a float4
in my fragment input.

00:48:27.646 --> 00:48:29.066
It exists, and it's the same!

00:48:29.766 --> 00:48:32.386
Same thing for this
attribute, user(T).

00:48:32.386 --> 00:48:35.406
So anything that's not a
built-in variable, you can come

00:48:35.616 --> 00:48:36.766
up with your own name.

00:48:37.006 --> 00:48:39.726
It just needs to use
the user-parentheses,

00:48:39.726 --> 00:48:40.526
braces, and tags.

00:48:41.096 --> 00:48:42.546
So that's the same thing here.

00:48:43.806 --> 00:48:46.726
And so if I create a vertex
shader and a fragment shader

00:48:46.896 --> 00:48:48.876
that uses these types,
they will pair.

00:48:49.516 --> 00:48:50.956
Note that there is
no requirement

00:48:50.956 --> 00:48:52.666
that all the elements
that I have

00:48:52.666 --> 00:48:55.266
in my fragment input must
occur in the same order.

00:48:55.446 --> 00:48:57.976
They can occur in any order,
they just need to occur.

00:48:58.276 --> 00:48:58.586
That's it.

00:48:58.626 --> 00:49:00.926
All right so that's
matchmaking for you guys.

00:49:01.806 --> 00:49:04.026
Okay? All right, my
favorite topic: math.

00:49:04.836 --> 00:49:08.776
Is anyone interested in math?

00:49:08.776 --> 00:49:08.866
[ Applause ]

00:49:08.866 --> 00:49:13.876
But why? Well because the two
common operations you guys are

00:49:13.876 --> 00:49:15.816
going to do are loads
and stores.

00:49:16.136 --> 00:49:18.026
And the rest is math.

00:49:19.346 --> 00:49:21.776
By default, all operation
math operations

00:49:21.776 --> 00:49:23.876
in Metal are in fast math mode.

00:49:23.876 --> 00:49:27.016
So want to make sure you get
the absolute fastest experience

00:49:27.016 --> 00:49:28.366
of your shaders running
on the GPU.

00:49:28.746 --> 00:49:31.656
Did anyone say, "well, if you
want to give me fast mode,

00:49:31.656 --> 00:49:33.656
why do I care about
precise mode?"

00:49:34.316 --> 00:49:36.286
Well because, you
know, fast mode comes

00:49:36.286 --> 00:49:38.206
with some caveats, it's fast.

00:49:39.116 --> 00:49:42.746
So sometimes, like in fast
mode, we tell you behavior

00:49:42.746 --> 00:49:44.666
of NaNs is not defined.

00:49:44.666 --> 00:49:45.756
So NaN is not a number.

00:49:46.486 --> 00:49:47.556
Well then what do
I care about that?

00:49:47.556 --> 00:49:48.146
It's not a number.

00:49:48.146 --> 00:49:50.456
"I'm not going to do math on
a not-a-number," you're like.

00:49:50.456 --> 00:49:51.806
Well, sometimes you do.

00:49:52.346 --> 00:49:55.626
So for example, if I'm clamping
an input with some minimum

00:49:55.626 --> 00:49:59.996
and a maximum, if I pass
an input that's NaN,

00:49:59.996 --> 00:50:02.646
in fast mode we're
going to say "ah,

00:50:02.646 --> 00:50:03.976
we don't know what the
answer is going to be."

00:50:04.446 --> 00:50:06.736
But if you actually follow
iTripoli's [inaudible] rules,

00:50:06.736 --> 00:50:08.246
there's guaranteed
defined behavior.

00:50:08.246 --> 00:50:09.656
And you may actually
care about that.

00:50:10.426 --> 00:50:12.716
Or, let's say you're using
trigonometric functions

00:50:12.716 --> 00:50:13.336
in your shader.

00:50:13.806 --> 00:50:16.936
In fast mode, they work
great over a small range.

00:50:17.556 --> 00:50:20.006
If your inputs go above
and beyond that range,

00:50:20.326 --> 00:50:21.446
behavior is undefined.

00:50:22.046 --> 00:50:25.126
So, let's say you want
correct behavior for those.

00:50:26.216 --> 00:50:28.516
Then you want to
use precise mode.

00:50:29.036 --> 00:50:32.576
So one option is you're going
to say, "I want my entire shader

00:50:32.576 --> 00:50:33.616
to run in precise mode."

00:50:33.816 --> 00:50:34.666
You can do that.

00:50:34.666 --> 00:50:36.016
You can set the compiler option.

00:50:36.196 --> 00:50:38.706
But that may actually...

00:50:38.706 --> 00:50:40.776
So, you need to really know
what you're doing before you set

00:50:40.776 --> 00:50:41.436
that option.

00:50:41.556 --> 00:50:43.306
So. But that option does exist.

00:50:43.646 --> 00:50:47.296
OK? All right, I think the more
common scenario is, you know,

00:50:47.296 --> 00:50:49.936
you're going to do most of
your stuff in fast mode.

00:50:50.416 --> 00:50:55.156
There may be some functions you
want to run in precise mode.

00:50:55.296 --> 00:50:56.776
So, you can do that in Metal.

00:50:57.586 --> 00:50:59.896
Because guess what, these
functions actually occur

00:50:59.896 --> 00:51:00.916
in nested name spaces.

00:51:00.916 --> 00:51:02.256
[ Applause ]

00:51:02.256 --> 00:51:09.266
So by default, you get
the fast name space.

00:51:09.566 --> 00:51:12.976
But you can call the precise
math function explicitly.

00:51:13.286 --> 00:51:15.616
Okay? So that's it.

00:51:17.026 --> 00:51:18.536
Ah! Metal standard library.

00:51:18.646 --> 00:51:20.346
So we don't do the
C++ standard library.

00:51:20.676 --> 00:51:21.446
We do our own.

00:51:21.776 --> 00:51:23.976
And it is really
optimized for the GPU.

00:51:23.976 --> 00:51:25.776
And I think you guys
are going to love it.

00:51:25.776 --> 00:51:27.326
I think it has a nice
list of functions.

00:51:28.036 --> 00:51:30.066
It's all described
in the documentation.

00:51:30.486 --> 00:51:33.366
I'm not going to cover
details of these functions,

00:51:33.366 --> 00:51:34.976
but please refer to
the specs, but...

00:51:34.976 --> 00:51:36.016
these are some of the functions.

00:51:36.016 --> 00:51:36.556
[ Laughter ]

00:51:36.556 --> 00:51:38.486
There's quite a few, okay.

00:51:39.186 --> 00:51:42.276
All right, so what did we do?

00:51:43.226 --> 00:51:45.016
We covered, Richard talked

00:51:45.016 --> 00:51:46.936
about how you build
a Metal application.

00:51:47.156 --> 00:51:49.306
And he showed you how to
draw a simple triangle.

00:51:49.306 --> 00:51:51.626
But then he took
it even further.

00:51:51.866 --> 00:51:56.656
He showed you how to do
stream uniforms, okay,

00:51:57.056 --> 00:51:59.616
with multiple buffers and how
to synchronize them efficiently.

00:52:00.186 --> 00:52:02.096
Then I talked to you guys
about the shading language.

00:52:02.096 --> 00:52:02.896
We went on a tour.

00:52:03.256 --> 00:52:06.496
We didn't go much deeper,
but a very high-level tour.

00:52:06.806 --> 00:52:09.626
We talked about how to write
shaders, given that it's based

00:52:09.626 --> 00:52:12.496
on C++, it's actually going to
be really, really easy for you

00:52:12.496 --> 00:52:13.726
to write these shaders.

00:52:14.246 --> 00:52:16.046
We talked about the data
types Metal supports.

00:52:16.526 --> 00:52:18.806
We talked about inputs
and outputs to shaders.

00:52:18.996 --> 00:52:20.566
We talked about how
to match them.

00:52:21.016 --> 00:52:22.146
We talked about math.

00:52:23.986 --> 00:52:25.636
So really, now it's your turn.

00:52:26.326 --> 00:52:27.836
I'm excited about how,

00:52:27.836 --> 00:52:29.636
the amazing ways you guys
are going to use Metal.

00:52:30.316 --> 00:52:32.096
And we want to hear from you.

00:52:32.236 --> 00:52:34.106
We want to know how we can
improve this even better.

00:52:34.106 --> 00:52:37.156
So, please come talk to us.

00:52:38.166 --> 00:52:40.096
So, for more information,
please --

00:52:41.216 --> 00:52:43.556
Filip Iliescu and Allan
Schaffer are our evangelists.

00:52:43.636 --> 00:52:45.086
Their email addresses are here,

00:52:45.286 --> 00:52:47.826
so bug them as much
as you can, okay?

00:52:48.666 --> 00:52:50.266
And Jeremy talked
about documentation.

00:52:50.266 --> 00:52:52.456
All documentation
for both the API

00:52:52.456 --> 00:52:54.876
and the language
are on our website.

00:52:55.376 --> 00:52:58.456
Please, you can use the
forums to ask questions.

00:52:58.966 --> 00:53:01.946
But actually, there's
one more session.

00:53:02.266 --> 00:53:06.426
The next session covers -- goes
into a deeper dive in Metal,

00:53:06.426 --> 00:53:07.046
and we're going to talk

00:53:07.046 --> 00:53:09.576
about data power
computing and tools as well.

00:53:10.236 --> 00:53:11.416
The one session I
actually wanted

00:53:11.466 --> 00:53:13.966
to highlight was what's new
in the Accelerate Framework.

00:53:13.966 --> 00:53:16.396
And it actually happened
yesterday, okay.

00:53:16.726 --> 00:53:18.856
But I think this is really
important because we talked

00:53:18.856 --> 00:53:21.546
about sharing data structures
between the CPU and the GPU.

00:53:21.866 --> 00:53:24.466
So this, actually, session
talks about the same library.

00:53:24.566 --> 00:53:26.356
So I definitely recommend
you go listen to it.

00:53:26.806 --> 00:53:28.276
And that's it.

00:53:28.666 --> 00:53:29.346
Thank you for coming.
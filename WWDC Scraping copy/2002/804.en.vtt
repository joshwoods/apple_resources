WEBVTT

00:00:03.410 --> 00:00:04.400
Steve, good morning.

00:00:04.400 --> 00:00:07.160
I want to make sure I understand
how this thing works.

00:00:07.160 --> 00:00:09.560
This is me, Steve Zelers,
and I'm an engineer working on web

00:00:09.660 --> 00:00:11.210
services frameworks for Mac OS X.

00:00:11.220 --> 00:00:16.650
So, before we begin,
let's talk about what a web service is,

00:00:16.720 --> 00:00:19.960
what it means to us and to developers.

00:00:19.960 --> 00:00:24.810
A web service is basically an endpoint,
or a method, that you can access over the

00:00:24.900 --> 00:00:29.340
internet using standard protocols,
including XML and HTTP,

00:00:30.480 --> 00:00:33.720
to either get a result or
perform some action on,

00:00:33.720 --> 00:00:35.480
well, we call it an endpoint.

00:00:35.480 --> 00:00:38.260
This is usually an HTTP server.

00:00:38.260 --> 00:00:39.470
It's heterogeneous.

00:00:39.470 --> 00:00:42.370
That means that the clients
and the servers can be running

00:00:42.380 --> 00:00:44.920
on different architectures,
and they're all just going to

00:00:44.990 --> 00:00:46.760
speak a lingua franca called XML.

00:00:46.760 --> 00:00:51.200
There are commercial web services,
which are things that you might pay for.

00:00:51.200 --> 00:00:55.240
If you had a business that
needed some piece of information,

00:00:55.240 --> 00:00:58.620
someone else could put up a web
service that provided that information,

00:00:58.620 --> 00:01:00.360
and you would access it.

00:01:00.480 --> 00:01:02.450
You would access it through
a web services toolkit,

00:01:02.450 --> 00:01:04.460
and you would be billed for it.

00:01:04.820 --> 00:01:09.010
And then there are private or
not commercial web services

00:01:09.160 --> 00:01:11.580
that you could also access.

00:01:11.580 --> 00:01:14.320
So,
some examples that you'll see on the net.

00:01:14.340 --> 00:01:17.510
Barnes & Noble has a web service
that you give it an ISBN number,

00:01:17.640 --> 00:01:19.350
it gives you the price of the book.

00:01:19.420 --> 00:01:24.020
There's also a web service that tells you
the current temperature in a zip code.

00:01:24.020 --> 00:01:25.720
So, Cupertino is 95014.

00:01:25.820 --> 00:01:27.720
You would send it 95014.

00:01:27.720 --> 00:01:30.400
It would tell you that it's a balmy 68.

00:01:30.490 --> 00:01:32.990
degrees or some such.

00:01:33.160 --> 00:01:39.920
The standards in web services
are all built on acronyms.

00:01:39.920 --> 00:01:43.220
There are dozens and dozens of acronyms,
and I'm only going to talk about a

00:01:43.220 --> 00:01:45.580
few of these during this presentation.

00:01:45.650 --> 00:01:51.980
XMLRPC and SOAP are both formats
of web service invocations.

00:01:51.980 --> 00:01:57.490
That is, these are mutually exclusive,
different ways of packaging up the data

00:01:57.490 --> 00:02:00.000
that you're sending to the web service.

00:02:00.000 --> 00:02:04.820
These are both built on top of XML,
which is a standard for presenting

00:02:04.820 --> 00:02:08.110
information in a way that is reliable.

00:02:08.130 --> 00:02:13.760
The other side is guaranteed to
either understand the message or not.

00:02:13.770 --> 00:02:17.230
It's also very easy for humans to read,
so that we get an understanding of

00:02:17.230 --> 00:02:19.820
what the data is that's being sent.

00:02:19.820 --> 00:02:22.580
These are both, in our case,
sent on top of HTTP,

00:02:22.580 --> 00:02:26.630
which we all know is used
to access web pages on the

00:02:26.940 --> 00:02:31.970
Internet and also to do HTTP posts,
which web services typically

00:02:31.990 --> 00:02:33.860
are done via HTTP post.

00:02:33.860 --> 00:02:36.460
There's another acronym called WSDL,
W-S-D-L, which stands for

00:02:36.550 --> 00:02:38.610
Web Service Description Language.

00:02:38.610 --> 00:02:42.130
This is an XML document that
describes what services are

00:02:42.130 --> 00:02:43.820
available at an endpoint.

00:02:44.030 --> 00:02:45.880
I'll talk about that a little more later.

00:02:45.880 --> 00:02:50.840
Here's an architectural diagram
of what XMLRPC and SOAP look

00:02:50.920 --> 00:02:52.550
like sitting on top of XML.

00:02:52.550 --> 00:02:55.540
In addition,
SOAP sits on top of XML schemas,

00:02:55.540 --> 00:02:58.380
which give you a very rich type system.

00:02:58.380 --> 00:02:58.380
This is a very interesting example
of what XMLRPC and SOAP look

00:02:58.380 --> 00:02:59.380
like sitting on top of XML.

00:02:59.380 --> 00:03:02.560
There are actually two ways
of encoding SOAP documents.

00:03:02.560 --> 00:03:07.840
The phrase you're going to hear a little
later is called Section 5 encoding.

00:03:07.840 --> 00:03:10.900
In this,
the XML that you're sending is typed.

00:03:11.020 --> 00:03:14.350
It's strongly typed with a
tag on the XML that says,

00:03:14.410 --> 00:03:18.990
"This element is an integer," or "This
element is a string." XML schemas

00:03:18.990 --> 00:03:21.070
let you build up complex types.

00:03:21.160 --> 00:03:25.090
Again,
I'll talk about those a little later on.

00:03:25.090 --> 00:03:28.540
As you can see,
XML writing on top of HTTP is typically

00:03:28.540 --> 00:03:30.980
what we think of as a web service.

00:03:31.600 --> 00:03:35.180
So, here's the state of
XML web services today.

00:03:35.240 --> 00:03:39.910
XMLRPC is a spec that was developed
by a company called Userland

00:03:39.910 --> 00:03:43.260
with some independent developers,
with help from Microsoft and

00:03:43.260 --> 00:03:44.290
some other folks.

00:03:44.400 --> 00:03:47.870
And basically,
it was published by this company and

00:03:48.220 --> 00:03:52.990
is used by them and by other vendors
to implement a simple RPC mechanism

00:03:52.990 --> 00:03:55.670
on top of XML and on top of HTTP post.

00:03:56.570 --> 00:03:57.280
It is done.

00:03:57.280 --> 00:04:00.250
The guy who owns the
spec isn't moving on it.

00:04:00.290 --> 00:04:02.400
And that means you can
implement the spec today,

00:04:02.400 --> 00:04:04.020
and it's pretty much
guaranteed to work tomorrow.

00:04:04.020 --> 00:04:05.560
It's not a moving target.

00:04:05.560 --> 00:04:07.720
SOAP is an evolving standard, however.

00:04:07.720 --> 00:04:11.690
SOAP 1.0 was developed by Userland
and Microsoft and some other folks.

00:04:11.690 --> 00:04:15.640
And it's a little different from XMLRPC.

00:04:15.770 --> 00:04:18.140
The syntax is a little different,
but fundamentally,

00:04:18.140 --> 00:04:19.700
it's trying to do the same thing.

00:04:19.700 --> 00:04:22.050
And as SOAP evolves,
more and more extensions

00:04:22.230 --> 00:04:23.620
have been added onto it.

00:04:23.680 --> 00:04:28.900
So, as of today, SOAP 1.1 is... SOAP 1.2
is a W3C recommendation,

00:04:28.900 --> 00:04:31.280
the World Wide Web Consortium
recommendation,

00:04:31.280 --> 00:04:33.210
which means it's basically done.

00:04:33.210 --> 00:04:34.520
It's no longer a moving target.

00:04:34.520 --> 00:04:38.620
SOAP 1.2 is a W3C note,
which means it's still a moving target.

00:04:38.780 --> 00:04:40.460
It's still being debated.

00:04:40.460 --> 00:04:43.750
The extensions to the
specification aren't final yet.

00:04:43.760 --> 00:04:47.360
In addition,
SOAP includes something called a header,

00:04:47.360 --> 00:04:51.640
which can contain additional
information for SOAP extensions.

00:04:51.640 --> 00:04:55.580
And SOAP extensions can be anything that
a platform vendor might want to add.

00:04:55.580 --> 00:05:00.330
So... SOAP is more of a moving target,
but it's still being pushed

00:05:00.330 --> 00:05:02.100
very heavily by Microsoft.

00:05:03.800 --> 00:05:06.530
So the difference between
these two specifications.

00:05:06.650 --> 00:05:09.150
XMLRPC is very simple.

00:05:09.620 --> 00:05:11.820
I'm going to show you an
example of what the message

00:05:11.980 --> 00:05:14.140
actually looks like in a minute.

00:05:14.140 --> 00:05:18.270
SOAP 1.1 could be as simple as SOAP,
but it could also be written

00:05:18.270 --> 00:05:19.730
in a more complex way.

00:05:19.840 --> 00:05:20.790
It's kind of like Perl.

00:05:20.790 --> 00:05:22.600
You can write your Perl
code any way you want,

00:05:22.690 --> 00:05:26.060
and it may look like line
noise or it may look like Java,

00:05:26.060 --> 00:05:29.160
and it's up to you to
make that distinction.

00:05:29.160 --> 00:05:32.910
Both of them have basic
type support for scalars,

00:05:32.910 --> 00:05:40.440
integer, string, double, and date,
and binary data passed as base64.

00:05:40.440 --> 00:05:45.680
And it has support for custom types,
arrays, and records.

00:05:45.830 --> 00:05:49.030
Soap enhances this by adding
multi-ref support so you could have

00:05:49.190 --> 00:05:53.090
a single element in an XML document
that is referenced multiple times,

00:05:53.200 --> 00:05:57.760
and it also has user types
in the form of XML schemas.

00:05:57.980 --> 00:06:02.220
In XMLRPC, there is a major flaw,
or what most of us think of as a flaw,

00:06:02.220 --> 00:06:06.750
in that the string parameters
must be passed as US ASCII text.

00:06:06.750 --> 00:06:09.440
If you have international
text that you want to pass,

00:06:09.440 --> 00:06:12.080
you have to encode it as base64 binary.

00:06:12.080 --> 00:06:15.240
This has been a bone of
contention for a lot of people,

00:06:15.240 --> 00:06:18.400
and it's just something you
have to deal with in the API.

00:06:18.400 --> 00:06:22.990
XMLRPC passes parameters by position.

00:06:23.000 --> 00:06:28.390
If you have, say,
a routine that adds two numbers, A and B,

00:06:28.390 --> 00:06:31.400
or, say, divides two numbers where
the position is important,

00:06:31.400 --> 00:06:35.910
the XMLRPC routine has to take
those parameters in order A,

00:06:35.980 --> 00:06:36.220
B.

00:06:36.400 --> 00:06:40.540
The SOAP method takes
them as named parameters.

00:06:40.540 --> 00:06:44.710
You can say element A or
parameter A has a value 4,

00:06:44.860 --> 00:06:47.290
parameter B has a value 2.

00:06:47.400 --> 00:06:50.860
XMLRPC can only be transported

00:06:52.300 --> 00:07:20.900
[Transcript missing]

00:07:22.200 --> 00:07:23.610
So how do you access web services?

00:07:23.710 --> 00:07:29.360
Well, there are dozens and dozens of
toolkits for both XMLRPC and SOAP.

00:07:29.500 --> 00:07:36.330
And the thing to remember about these
toolkits is that they bind a framework

00:07:36.480 --> 00:07:39.030
to the runtime model of your application.

00:07:39.030 --> 00:07:41.600
So if you have an
application written in Java,

00:07:41.600 --> 00:07:45.330
it's probably a good bet to go
with one of the established Java,

00:07:45.330 --> 00:07:50.200
SOAP, or XMLRPC implementations because
they will match your object model.

00:07:50.200 --> 00:07:54.190
But it's an investment to bring one of
these toolkits into your application.

00:07:54.190 --> 00:07:56.130
If you go out on the
net and grab a toolkit,

00:07:56.190 --> 00:07:58.590
then start shipping it
with your application,

00:07:58.590 --> 00:08:02.090
you're going to be forced to maintain
that toolkit and your customers

00:08:02.100 --> 00:08:03.280
are going to have to hear about it.

00:08:03.300 --> 00:08:06.730
Or you'll hear about it when
your customers are dissatisfied

00:08:06.730 --> 00:08:08.720
with some bug or something else.

00:08:08.790 --> 00:08:13.420
So you want to choose the toolkit that
best matches your runtime environment

00:08:13.420 --> 00:08:15.730
and your application frameworks.

00:08:16.650 --> 00:08:19.000
So what did we do in Mac OS 10.1?

00:08:19.000 --> 00:08:22.810
Well, last year at the conference,
we were really pushing Mac OS X and

00:08:22.810 --> 00:08:24.490
what was available then.

00:08:24.490 --> 00:08:27.260
And coming out a few months
later was Mac OS 10.1,

00:08:27.260 --> 00:08:31.280
and we couldn't tell you about one of
the exciting features in Mac OS 10.1,

00:08:31.280 --> 00:08:36.260
which is XMLRPC and SOAP 1.1 support
baked into the Apple Event Manager.

00:08:37.360 --> 00:08:39.610
Because it was baked into
the Apple Event Manager,

00:08:39.610 --> 00:08:41.530
AppleScript got support
for this for free.

00:08:41.630 --> 00:08:44.120
In a few minutes,
we'll have a demo of that.

00:08:44.120 --> 00:08:48.020
This proved to be a very popular
way for people on our platform

00:08:48.020 --> 00:08:49.270
to access these web services.

00:08:49.360 --> 00:08:51.780
They didn't have to go out on the
net and download a toolkit and

00:08:51.780 --> 00:08:52.910
make sure their customers had it.

00:08:52.970 --> 00:08:55.970
They just had to make sure
their customers had 10.1,

00:08:55.970 --> 00:08:58.550
which most everybody did,
and they were able to write

00:08:58.550 --> 00:09:02.410
applications that took advantage of
the support built into the system.

00:09:02.420 --> 00:09:06.690
It works by hijacking an
addressing mode for an Apple event.

00:09:07.360 --> 00:09:11.200
An Apple event, for those of you who
are new to our platform,

00:09:11.260 --> 00:09:13.780
is an interprocess
communication mechanism.

00:09:13.920 --> 00:09:17.070
And in 10.1,
we reintroduced remote Apple events,

00:09:17.190 --> 00:09:21.710
the ability to send a binary message to
another application on another computer,

00:09:21.830 --> 00:09:23.440
another Mac OS X computer.

00:09:23.660 --> 00:09:30.220
And for addressing modes that were HTTP,
we treated them as a web service.

00:09:30.390 --> 00:09:33.850
We were able to do this without any
API changes to the Apple Event Manager,

00:09:33.860 --> 00:09:37.580
and just by enabling some additional
data types that hinted to the

00:09:37.620 --> 00:09:45.400
Apple Event Manager that the method that
needed to be called was to be called

00:09:45.400 --> 00:09:45.400
using the XMLRPC or SOAP framework.

00:09:46.110 --> 00:09:48.760
So I'm going to give the
canonical XML RPC example,

00:09:48.760 --> 00:09:53.180
which is to call the method
examples.getStateName on the server

00:09:53.550 --> 00:09:58.840
http://betty.userland.com/port80/rpc2.

00:09:58.960 --> 00:10:01.220
When I go to send this message,
I'm going to open up an

00:10:01.310 --> 00:10:09.300
HTTP connection and do an HTTP post
to that site with an XML document.

00:10:09.420 --> 00:10:12.210
And the XML document takes a
single integer as a parameter

00:10:12.210 --> 00:10:13.500
and returns a string.

00:10:13.620 --> 00:10:17.070
This is what that message
is going to look like.

00:10:17.360 --> 00:10:18.450
It's XML.

00:10:18.610 --> 00:10:22.710
It has a structure to it that includes
the method name and a parameter list.

00:10:22.840 --> 00:10:25.450
In this case, there's a single parameter.

00:10:25.560 --> 00:10:31.460
You can see the parameter is number 41
encased in an element tag that says i4.

00:10:31.460 --> 00:10:37.400
That's XML RPC's indicator that the
element is typed as a long integer.

00:10:37.510 --> 00:10:41.110
And in response,
the server comes back by saying, "Okay,

00:10:41.110 --> 00:10:45.520
the return value from that method
is the string South Dakota." Now,

00:10:45.520 --> 00:10:50.300
the server is returning, I think,
basically it's got an array of 50 states,

00:10:50.300 --> 00:10:53.500
and it returns element 41 in the
array in no particular order.

00:10:53.500 --> 00:10:57.150
So it's not a very interesting example,
but it shows the message

00:10:57.150 --> 00:10:59.470
in response pretty well.

00:11:00.300 --> 00:12:11.000
[Transcript missing]

00:12:11.470 --> 00:12:15.330
So the next thing we do is create
the event that we're going to send.

00:12:15.490 --> 00:12:19.880
And just like in the
normal Apple Event Manager,

00:12:19.880 --> 00:12:22.260
you create the target address.

00:12:22.310 --> 00:12:24.170
In our case, it's an application URL.

00:12:24.740 --> 00:12:26.980
Type char should be on that slide.

00:12:26.980 --> 00:12:31.420
And then you give it the location that
you're going to post the event to.

00:12:31.420 --> 00:12:37.390
Then you create the event with
the special event class and ID of

00:12:37.390 --> 00:12:41.270
KAERPC class and the event ID of KAERPC.

00:12:58.900 --> 00:13:00.140
So this is what we've created.

00:13:00.150 --> 00:13:03.180
We've created an Apple event on
the left-hand side of the screen,

00:13:03.220 --> 00:13:06.030
and the callouts show you
basically what the contents

00:13:06.030 --> 00:13:07.790
of the Apple event look like.

00:13:07.840 --> 00:13:10.460
You've got the class, the scheme,
the target address,

00:13:10.570 --> 00:13:14.600
and the direct object is broken
out into a record with two fields.

00:13:15.080 --> 00:13:18.130
The examples that get state
name is the method name.

00:13:18.130 --> 00:13:21.390
The parameters is actually a
list containing the number 41.

00:13:21.680 --> 00:13:24.420
Okay, so then you send the event
and you deal with the reply.

00:13:24.420 --> 00:13:28.020
Apple events can be sent
synchronously or asynchronously,

00:13:28.020 --> 00:13:31.580
which means that if it's
an asynchronous call,

00:13:31.580 --> 00:13:35.410
you're going to receive the
reply as an Apple event,

00:13:35.450 --> 00:13:38.360
as a class AEVT, ANSR.

00:13:38.360 --> 00:13:41.830
But in this case,
we're just going to say, send the event,

00:13:41.830 --> 00:13:43.010
wait for the reply.

00:13:43.020 --> 00:13:47.000
This opens up the connection to the
remote site and sends the event,

00:13:47.000 --> 00:13:50.620
gets the reply, turns it back into an
Apple event descriptor,

00:13:50.740 --> 00:13:54.430
and then you can pull out,
out of the reply, the direct object,

00:13:54.430 --> 00:13:57.460
which in our case is a string,
and then you can call printf

00:13:57.620 --> 00:14:00.740
because your Unix programmer is now,
and you can call printf with impunity.

00:14:02.750 --> 00:14:04.740
You can have more complex
types in an Apple event.

00:14:04.760 --> 00:14:09.100
You can have an AE list gets
turned into an array in the XML,

00:14:09.100 --> 00:14:11.740
and an AE record gets
turned into a structure,

00:14:11.740 --> 00:14:13.620
which is a key-value pair.

00:14:13.620 --> 00:14:16.910
The problem with Apple event records,
though,

00:14:16.910 --> 00:14:22.050
is that they have a limitation that the
key for a record is a 4-byte string,

00:14:22.050 --> 00:14:24.060
or an OS type, actually.

00:14:24.060 --> 00:14:25.620
It's a 32-bit integer.

00:14:25.860 --> 00:14:31.160
We borrow something
innovated by AppleScript,

00:14:31.270 --> 00:14:36.870
which is to say you can have a
list of items in a record under

00:14:36.870 --> 00:14:41.100
the key KeyASUserRecordFields,
and this will be the string,

00:14:41.100 --> 00:14:44.280
and then a descriptor, and then a string,
and then a descriptor.

00:14:44.280 --> 00:14:48.000
This is how you would build up a
complex record in AppleScript or

00:14:48.110 --> 00:14:49.980
in the Apple Event Manager.

00:14:49.980 --> 00:14:53.190
When the Apple Event Manager sees
one of these special keys,

00:14:53.210 --> 00:14:55.680
it knows that it wants
to build a structure.

00:14:55.860 --> 00:14:58.850
It knows that it wants to build
a structure with a complex name,

00:14:58.850 --> 00:15:01.020
a long string name, and then some value.

00:15:01.020 --> 00:15:04.800
The value is going to be either
a scalar type or a compound type.

00:15:04.840 --> 00:15:07.090
This is how you would do that.

00:15:07.160 --> 00:15:09.860
You create the list that this...

00:15:12.610 --> 00:15:22.900
The application is a simple document.

00:15:22.900 --> 00:15:29.920
You can write a code to it.

00:15:29.920 --> 00:15:39.120
There's an alternative,
which is that AppleScript basically got

00:15:39.120 --> 00:15:44.210
support for all of this for free by the
addition of a simple dictionary that adds

00:15:44.210 --> 00:15:47.300
the call soap and call XML RPC methods.

00:15:47.300 --> 00:15:50.170
This is a great way to prototype
and debug web services,

00:15:50.380 --> 00:15:53.620
because the Apple Event Manager sits
below AppleScript,

00:15:53.630 --> 00:15:58.870
and AppleScript just builds complex
Apple events like a duck in water.

00:15:58.910 --> 00:16:03.220
It's really easy to use AppleScript to
both prototype and to embed web

00:16:03.260 --> 00:16:06.220
services inside your application.

00:16:06.270 --> 00:16:09.880
There's a tech note that I'll mention
at the end that can show you how to add

00:16:09.880 --> 00:16:12.680
AppleScript to your application as well.

00:16:12.680 --> 00:16:15.420
At this time,
I'm going to ask Tim Bumgarner to

00:16:15.480 --> 00:16:21.640
come up and demo AppleScript Studio,
which uses Apple Events to

00:16:21.640 --> 00:16:24.110
access web services.

00:16:33.870 --> 00:16:34.170
Sound?

00:16:34.320 --> 00:16:34.790
Sound?

00:16:34.830 --> 00:16:35.420
There we go.

00:16:35.570 --> 00:16:36.450
Okay, great.

00:16:36.450 --> 00:16:36.890
Okay.

00:16:36.950 --> 00:16:40.090
First thing we need to do in our
demo is actually discover what

00:16:40.090 --> 00:16:41.720
type of service we want to use.

00:16:41.800 --> 00:16:45.390
And I've got an application here
called X Methods Service Finder.

00:16:45.390 --> 00:16:48.660
And this employs the services from
the X Methods website to actually

00:16:49.090 --> 00:16:52.240
display all the different publishers,
the service names,

00:16:52.240 --> 00:16:56.260
and a short description of all
the services that are available.

00:16:56.260 --> 00:16:59.060
And I've got a nice little
search area up here.

00:16:59.210 --> 00:17:03.780
I can actually find maybe all the
publishers that begins with X Methods.

00:17:03.800 --> 00:17:07.800
I'll type this and it quickly just
lists the ones that are from X Methods.

00:17:07.800 --> 00:17:10.190
Let's do something a
little more interesting.

00:17:10.280 --> 00:17:14.830
Let's see if we can find anything
that has to do with stock.

00:17:14.940 --> 00:17:17.910
So if I, maybe I wanted a web
service that would be,

00:17:17.930 --> 00:17:21.290
pull out the current value of a stock,
I could use that.

00:17:21.450 --> 00:17:24.090
For our demo actually,
let's see if we can find

00:17:24.090 --> 00:17:25.760
anything about Dilbert.

00:17:25.760 --> 00:17:28.920
And actually there is one, Daily Dilbert.

00:17:28.920 --> 00:17:33.780
And it looks like it says it returns a
binary stream of today's Dilbert comics.

00:17:33.800 --> 00:17:37.130
And actually what it returns
is a URL to an image.

00:17:37.270 --> 00:17:43.240
So let's go ahead and build a web
service built on this particular service.

00:17:43.240 --> 00:17:46.240
So I'm going to go into Project Builder.

00:17:46.380 --> 00:17:47.900
And we're going to start
right at the beginning.

00:17:47.900 --> 00:17:49.420
We're going to do this
right from scratch.

00:17:49.580 --> 00:17:51.870
So I'm going to choose New Project.

00:17:51.870 --> 00:17:56.210
And in this case, I'm going to choose the
AppleScript application template.

00:17:56.390 --> 00:17:59.740
And we're going to go ahead
and call this Daily Dilbert.

00:17:59.760 --> 00:18:02.050
All right, click Finish.

00:18:04.750 --> 00:18:06.920
Now I've got my project open here.

00:18:06.940 --> 00:18:11.090
And it's already given me basically a
blank script to start with and pretty

00:18:11.200 --> 00:18:14.580
much just a start on our resources.

00:18:14.590 --> 00:18:16.680
If it will open-- there we go.

00:18:16.700 --> 00:18:17.300
Double-click that.

00:18:17.430 --> 00:18:18.660
We're going to go into Interface Builder.

00:18:18.700 --> 00:18:21.200
First thing we're going to do is go
ahead and put together our interface.

00:18:21.200 --> 00:18:23.140
And in this case,
it's going to be a fairly

00:18:23.320 --> 00:18:24.500
trivial application.

00:18:24.500 --> 00:18:26.110
We'll just make this a little smaller.

00:18:26.220 --> 00:18:27.500
I'm going to bring up the attributes.

00:18:27.580 --> 00:18:30.220
First thing I want to do is
go ahead and change the title

00:18:30.390 --> 00:18:33.230
to Daily Dilbert of my window.

00:18:33.370 --> 00:18:36.110
Since what we're going to be doing
is getting an image and putting

00:18:36.110 --> 00:18:38.160
it and loading it in this view,
we'll need an image view.

00:18:38.160 --> 00:18:39.460
There's one right here.

00:18:39.490 --> 00:18:41.140
Drag it over.

00:18:41.140 --> 00:18:43.120
And we'll change some of
the attributes of that.

00:18:43.120 --> 00:18:45.040
We'll make it so there's no border.

00:18:45.040 --> 00:18:47.110
I can use the Aqua guidelines
to make sure I get it

00:18:47.190 --> 00:18:49.560
snapped right up to the edge.

00:18:50.450 --> 00:18:53.650
A couple other things is that we're
going to automatically resize the image,

00:18:53.660 --> 00:18:57.280
this window, based on what the image that
we get from the service.

00:18:57.280 --> 00:19:00.960
And so I want to just make sure
that this particular view stretches.

00:19:00.980 --> 00:19:03.940
So for the most part, the UI is done.

00:19:03.940 --> 00:19:04.640
It's very simple.

00:19:04.640 --> 00:19:07.320
Now I actually want to add
some AppleScript functionality.

00:19:07.320 --> 00:19:11.170
And one of the things we have to
do is to name our objects so that

00:19:11.220 --> 00:19:14.630
we can refer to them by name in
our scripts instead of by index.

00:19:14.700 --> 00:19:17.120
So I'm going to go to
my AppleScript panel.

00:19:17.920 --> 00:19:21.280
Anytime I want to do anything with
AppleScript in Interface Builder,

00:19:21.280 --> 00:19:22.400
I go to this panel.

00:19:22.400 --> 00:19:23.960
And I'm going to name my window.

00:19:23.960 --> 00:19:26.140
Go ahead and we'll call it Dilbert.

00:19:26.140 --> 00:19:29.200
And then I also want
to name my image view.

00:19:29.200 --> 00:19:32.020
And I know that I've got the image
view because when I click on it,

00:19:32.220 --> 00:19:33.830
there's an NSImageView title here.

00:19:33.840 --> 00:19:35.760
And I'm going to also
call this one Dilbert.

00:19:35.760 --> 00:19:40.140
Now what I want to do is I want to
actually execute some AppleScript.

00:19:40.140 --> 00:19:43.510
So when this window gets loaded,
or in particular this view

00:19:43.510 --> 00:19:46.780
gets loaded from the nib,
I want to trigger an AppleScript.

00:19:47.380 --> 00:19:49.040
And so there is a nib class here.

00:19:49.040 --> 00:19:50.790
And for those of you that
are Cocoa programmers,

00:19:50.790 --> 00:19:52.640
this will look very familiar,
awake from nib.

00:19:52.640 --> 00:19:55.840
So you can attach to any object
and find out when it's been loaded.

00:19:55.840 --> 00:19:57.920
And we're going to assign it to this.

00:19:58.020 --> 00:20:02.990
One other thing is that I don't want
the window to be initially visible.

00:20:03.000 --> 00:20:05.520
So let's turn off its visibility.

00:20:05.520 --> 00:20:08.570
And then the other thing we need
to do is we want to know when the

00:20:08.580 --> 00:20:12.020
app is finished launching so that
we can then present the window.

00:20:12.020 --> 00:20:14.120
So again, I go back to my AppleScript.

00:20:14.120 --> 00:20:16.670
And in this case, there is a launched.

00:20:17.080 --> 00:20:18.280
Event.

00:20:18.280 --> 00:20:21.020
And let's go ahead and then
click on the edit script.

00:20:21.080 --> 00:20:24.320
Now what this does is it goes
back into Project Builder,

00:20:24.740 --> 00:20:27.050
loads my script,
and it determines that there weren't

00:20:27.050 --> 00:20:28.400
any handlers with those names.

00:20:28.400 --> 00:20:31.070
And so it automatically goes
and adds those handlers for me.

00:20:31.080 --> 00:20:32.770
So let's go ahead,
and I've got a little bit

00:20:32.770 --> 00:20:34.020
of a demo assistant here.

00:20:34.020 --> 00:20:35.810
If it's working correctly,
it's going to enter the

00:20:35.830 --> 00:20:38.020
script so you don't have to
watch me painfully type this.

00:20:38.020 --> 00:20:43.960
Basically, what we do is the parameter
to this web service is a date.

00:20:44.080 --> 00:20:46.080
And it has to be in the format month.

00:20:46.780 --> 00:20:50.040
So it's going to use as digits/day/year.

00:20:50.390 --> 00:20:52.840
And ironically enough,
I found it was actually easier to

00:20:52.840 --> 00:20:56.480
use the shell to call date to get
it in that particular format because

00:20:56.480 --> 00:20:59.280
AppleScript doesn't make it easy
to get it in this specific format.

00:20:59.280 --> 00:21:03.280
You can get it -- the month comes back as
the actual string of January or February.

00:21:03.280 --> 00:21:05.280
In this case, that wouldn't work.

00:21:05.280 --> 00:21:07.710
So I just found that we actually
have this functionality built into

00:21:07.720 --> 00:21:09.270
AppleScript called do shell script.

00:21:09.410 --> 00:21:13.250
And I just jump out and call the shell
command date passing it the parameter,

00:21:13.280 --> 00:21:15.280
and voila, it works.

00:21:15.280 --> 00:21:16.480
So let's go ahead and continue on.

00:21:16.480 --> 00:21:19.560
Then the next thing I do is
I want to get the image as this

00:21:19.680 --> 00:21:21.480
image view is being loaded.

00:21:21.480 --> 00:21:24.350
And so there's a handler here,
get Dilbert image for date.

00:21:24.480 --> 00:21:26.480
And we're going to add
that in just a bit.

00:21:26.480 --> 00:21:28.190
Now continue on.

00:21:28.580 --> 00:21:30.460
And then what I do is once
I've loaded the image,

00:21:30.510 --> 00:21:32.470
I go ahead and set the
image of that image view.

00:21:32.480 --> 00:21:36.480
And the thing that's being awoken
in essence is the image view.

00:21:36.480 --> 00:21:39.870
The object will contain that image view.

00:21:42.780 --> 00:21:46.380
All right, so let's go down and add the
rest of our handlers here.

00:21:46.400 --> 00:21:48.710
Oh, we've got one more thing here.

00:21:50.560 --> 00:21:52.620
Next thing I also want to
do is once I load the image,

00:21:52.660 --> 00:21:56.680
I want to adjust the size of the window
based on the size of the image itself.

00:21:56.680 --> 00:21:58.970
So I simply call size of the window.

00:21:59.070 --> 00:21:59.760
I set its size.

00:21:59.760 --> 00:22:02.240
This is actually doing
another interesting thing.

00:22:02.240 --> 00:22:05.240
It happens that at this
point in version Studio 1.1,

00:22:05.270 --> 00:22:08.610
the size of an image can't be
determined directly from AppleScript.

00:22:08.610 --> 00:22:09.400
This will be fixed.

00:22:09.400 --> 00:22:11.870
But I can actually call Objective-C.

00:22:11.950 --> 00:22:15.410
And this is another Studio enhancement
such that call method is

00:22:15.430 --> 00:22:18.850
calling the Objective-C method
called size on the object,

00:22:18.850 --> 00:22:19.540
the image.

00:22:19.620 --> 00:22:22.990
Without any code, I can just jump off and
call into Objective-C.

00:22:22.990 --> 00:22:25.280
So if Studio hasn't provided
some functionality for you,

00:22:25.350 --> 00:22:28.620
we've sort of put a backdoor
in with the call method.

00:22:28.650 --> 00:22:31.360
So let's go on down here and we'll
see if we can put in the rest of it.

00:22:31.360 --> 00:22:32.380
Nope, and I forgot to show it.

00:22:32.520 --> 00:22:36.640
And then at the very end,
we want to show that window.

00:22:41.340 --> 00:22:43.820
And then I'm going to go through this,
the getDilbertImage.

00:22:43.890 --> 00:22:47.010
So it's setting it to some
known value to begin with.

00:22:47.020 --> 00:22:50.700
And then we're going to call another
handler called loadImageAtUrl.

00:22:50.710 --> 00:22:54.740
And this is going to call yet another
handler calling the actual web service

00:22:54.840 --> 00:22:58.080
getDailyDilbert for image at the path.

00:22:58.080 --> 00:22:59.100
And we'll finish this.

00:22:59.310 --> 00:23:01.220
And then here's the loadImage.

00:23:01.220 --> 00:23:03.400
And I'll walk through
this one here in a second.

00:23:03.400 --> 00:23:07.280
Basically, it does another call method.

00:23:07.280 --> 00:23:08.840
I cheated here again.

00:23:08.840 --> 00:23:11.960
Given the URL, there's actually a Cocoa--
I'm a Cocoa engineer.

00:23:11.990 --> 00:23:17.100
There is a-- and a string class,
and there actually has one--

00:23:17.430 --> 00:23:20.110
A category point on it,
so I can actually get the last path

00:23:20.110 --> 00:23:21.780
component of that URL very simply.

00:23:21.920 --> 00:23:24.650
So I jump out, and with call method,
I pass this particular

00:23:24.690 --> 00:23:27.460
method name on the URL,
and it gives me the last part of it,

00:23:27.460 --> 00:23:30.340
because that's what I'm going
to use as the part of the name.

00:23:30.340 --> 00:23:32.590
And basically,
we're going to stick this image

00:23:32.590 --> 00:23:35.190
that we load in slash temp,
so the next time we reboot,

00:23:35.190 --> 00:23:37.440
we don't have to worry
about getting rid of it.

00:23:37.440 --> 00:23:40.080
And then again,
we're going to employ do shell script,

00:23:40.080 --> 00:23:42.520
because we can use the curl
tool to pass it that URL,

00:23:42.520 --> 00:23:45.140
and it's going to return it to
and save it for me on my disk.

00:23:45.300 --> 00:23:49.440
And then when I'm done,
I will use the load image command

00:23:49.440 --> 00:23:52.600
that's in studio to load that
image and set it into that,

00:23:52.740 --> 00:23:54.360
or to pass it back in our array.

00:23:56.050 --> 00:23:56.690
All right.

00:23:56.750 --> 00:23:59.300
Then the next thing we need to read
is the most interesting one as far

00:23:59.300 --> 00:24:00.840
as the web services is concerned.

00:24:00.840 --> 00:24:04.790
And this is called
Daily Dilbert Image Path.

00:24:05.730 --> 00:24:10.420
And what it does is it simply uses
that URL that Steve talked about.

00:24:10.520 --> 00:24:11.740
This is the endpoint.

00:24:11.740 --> 00:24:13.700
And just like we talked
to a local application,

00:24:13.820 --> 00:24:16.790
by tell application finder,
we can simply talk to the web services

00:24:16.900 --> 00:24:19.560
tell application this particular URL.

00:24:19.560 --> 00:24:21.360
And then we give it the method name.

00:24:21.360 --> 00:24:23.580
And it needs also a
SOAP action in this case,

00:24:23.580 --> 00:24:25.080
and the namespace for that.

00:24:25.150 --> 00:24:29.360
And the parameters we're actually passing
in right here in the end parameters,

00:24:29.360 --> 00:24:30.780
and they get sort of put together.

00:24:30.780 --> 00:24:33.310
And then we ultimately call SOAP.

00:24:33.490 --> 00:24:36.500
And this is going to do
what Steve talked about.

00:24:36.500 --> 00:24:38.400
It's going to take all
this data that we pass,

00:24:38.400 --> 00:24:40.180
which is really just
an AppleScript record.

00:24:40.180 --> 00:24:41.540
You'll see this is an AppleScript record.

00:24:41.540 --> 00:24:45.630
Takes that, pulls it into,
or takes it and converts it into XML,

00:24:45.710 --> 00:24:48.910
sends it over the wire,
waits for the response.

00:24:49.000 --> 00:24:52.140
It comes back as an XML data,
and then he parses it and

00:24:52.140 --> 00:24:54.760
then gives it back to us in
AppleScript so that we can use it.

00:24:54.910 --> 00:24:56.210
And that will be our image.

00:24:56.220 --> 00:25:00.420
And let's see, I think we've got
everything that we need.

00:25:00.420 --> 00:25:02.620
and let's go ahead and save and run this.

00:25:02.620 --> 00:25:03.560
See how it works.

00:25:07.620 --> 00:25:08.560
builds, compiles.

00:25:08.560 --> 00:25:12.590
There you go.

00:25:13.040 --> 00:25:15.840
So it's went off, loaded that data,
loaded our image,

00:25:15.840 --> 00:25:18.400
and it looks like that's
our today's daily image.

00:25:18.400 --> 00:25:19.550
And Steve, pick it back up.

00:25:21.560 --> 00:25:24.790
Oh, by the way, I forgot to tell you.

00:25:24.890 --> 00:25:29.050
It just happens to be that
this application itself

00:25:29.050 --> 00:25:30.630
is a studio application.

00:25:30.640 --> 00:25:35.390
The app that I use to find the
services is a studio application.

00:25:35.540 --> 00:25:37.620
And here's the code for it,
if I can open it up.

00:25:37.620 --> 00:25:40.790
It's actually going to talk to mail.

00:25:44.300 --> 00:25:46.000
And close all the windows.

00:25:46.000 --> 00:25:47.970
And here is the service detail.

00:25:47.980 --> 00:25:50.630
So here, I put this together last night.

00:25:51.040 --> 00:25:52.230
And here's the script for that.

00:25:52.320 --> 00:25:53.600
So just a little bit of script here.

00:25:53.600 --> 00:25:56.860
That whole application was written in a
couple hours to actually do the services.

00:25:56.920 --> 00:25:59.970
Again, employing web services to get
all the data that we needed.

00:26:00.050 --> 00:26:00.630
All right, thanks, Steve.

00:26:00.950 --> 00:26:02.580
Thank you, Tim.

00:26:06.300 --> 00:26:11.040
So I guess the point to get out of that
is that AppleScript and Apple Events,

00:26:11.170 --> 00:26:13.440
empowered with web services,
really give you a way of getting

00:26:13.570 --> 00:26:16.130
to web services very quickly,
and at least, if nothing else,

00:26:16.130 --> 00:26:16.780
playing with them.

00:26:16.800 --> 00:26:19.560
Okay,
so what do we have for you in Jaguar?

00:26:19.560 --> 00:26:24.030
We've decided to ship something
called Web Services Core.

00:26:24.040 --> 00:26:27.050
Now, what was wrong with the
Apple Event Manager way of doing things?

00:26:27.170 --> 00:26:27.370
Nothing.

00:26:27.380 --> 00:26:29.720
The Apple Event Manager way
of doing things is fine,

00:26:29.720 --> 00:26:33.480
but it's at a little too high
a level in the protocol stack,

00:26:33.480 --> 00:26:37.980
in the library chain of our system.

00:26:37.980 --> 00:26:40.650
So in this slide,
we see that App Services has

00:26:40.800 --> 00:26:44.200
the Apple Event Manager sitting
as a little bubble in it.

00:26:44.260 --> 00:26:49.420
And then what we've done is implemented
WS Core inside of Core Services.

00:26:49.420 --> 00:26:51.080
Now, this is a lower-level framework.

00:26:51.080 --> 00:26:55.600
It sits alongside of CF Network,
Core Foundation, and Carbon Core.

00:26:55.600 --> 00:27:00.600
And it gives you access to the...
basic runtime model for our system.

00:27:00.620 --> 00:27:05.060
It's available to all applications,
plugins, daemons, tools.

00:27:05.090 --> 00:27:09.690
It doesn't have any dependency on
the Windows Server or login window.

00:27:09.850 --> 00:27:11.160
You don't have to be a logged-in user.

00:27:11.160 --> 00:27:14.990
You could use it from a CGI application.

00:27:15.800 --> 00:27:18.690
It's integrated with the system.

00:27:18.700 --> 00:27:24.880
It sits inside of core services and it
leverages CFXML parser and CF network.

00:27:24.980 --> 00:27:27.200
It's thread safe, run loop safe,
and friendly.

00:27:27.200 --> 00:27:36.660
It encourages you to asynchronously
issue invocation requests on the run loop

00:27:36.730 --> 00:27:38.210
and receive a reply on your run loop.

00:27:38.560 --> 00:27:43.300
It's CF type based,
so you have to create CF type objects for

00:27:43.300 --> 00:27:48.440
your strings and integers and records,
dictionaries, and CFArrays.

00:27:48.560 --> 00:27:52.400
But if you're an Objective-C programmer,
you get toll-free bridging

00:27:52.400 --> 00:27:53.740
with the Objective-C types.

00:27:53.740 --> 00:27:58.410
It's also a simple procedural API,
so there's no need to have a lot

00:27:58.410 --> 00:28:00.960
of objects involved for this API.

00:28:00.960 --> 00:28:06.810
There's actually probably six calls in
the API and a single object or type ref.

00:28:08.600 --> 00:30:20.600
[Transcript missing]

00:30:21.180 --> 00:30:23.420
So, like I said,
you create one of these things using

00:30:23.420 --> 00:30:26.420
the method WS_MethodInvocationCreate.

00:30:26.600 --> 00:30:29.320
It's a CFURL or an NSURL.

00:30:29.480 --> 00:30:33.200
A method name is a CFString,
and the protocol is one of

00:30:33.200 --> 00:30:35.740
these CFString constants
that are in the header.

00:30:35.820 --> 00:30:42.600
The header, by the way,
on the Jaguar CD is

00:30:42.600 --> 00:30:42.600
WS_MethodInvocation.h.

00:30:43.600 --> 00:32:07.100
[Transcript missing]

00:32:08.200 --> 00:32:11.870
So this is how you would build the
dictionary and parameter order array.

00:32:11.990 --> 00:32:15.660
You call CFDictionary add value on a
mutable dictionary that you've created.

00:32:15.740 --> 00:32:16.900
You've got two parameters.

00:32:16.980 --> 00:32:20.000
Param one is Steve, param two is John.

00:32:20.110 --> 00:32:23.540
You add the parameter names
to the parameter name array,

00:32:23.540 --> 00:32:27.170
and then you just set the
parameters onto the ref.

00:32:28.970 --> 00:32:29.810
So, then you invoke it.

00:32:29.970 --> 00:32:34.560
And you do that with a single call,
WS_MethodInvocationInvoke.

00:32:34.640 --> 00:32:36.800
The result of this
call is a CFDictionary.

00:32:36.800 --> 00:32:40.260
Now, that's not the actual method result.

00:32:40.330 --> 00:32:43.090
That's a dictionary containing
the actual method result,

00:32:43.160 --> 00:32:45.400
as well as optional
debugging information,

00:32:45.400 --> 00:32:49.900
including the outgoing XML and
the returned XML and the

00:32:49.900 --> 00:32:54.790
HTTP headers or HTTP errors,
and fault information so that if there

00:32:54.790 --> 00:32:58.140
was a networking transport error,
that information is going to

00:32:58.140 --> 00:33:02.430
be in there and available as
keys in that dictionary as well.

00:33:02.780 --> 00:33:05.040
So, basically,
you make this invocation call,

00:33:05.040 --> 00:33:08.700
and then if you can call this
method WS_MethodResultIsFault,

00:33:08.750 --> 00:33:12.430
passing up that result dictionary,
then you can pull out the fault string

00:33:12.840 --> 00:33:17.310
out of the dictionary and display it
to the user or do some other work,

00:33:17.490 --> 00:33:18.910
whatever you want to do.

00:33:19.010 --> 00:33:21.720
Otherwise, if it's not a fault,
you look up the

00:33:21.720 --> 00:33:24.090
KWS_MethodInvocationResult.

00:33:24.300 --> 00:33:26.910
The result of this is a CF type ref,
and depending on the

00:33:26.960 --> 00:33:32.140
service you're calling,
it's going to be some sort of value

00:33:32.140 --> 00:33:35.440
that's expressed in CF type lingo.

00:33:35.510 --> 00:33:38.060
So,
in the example we saw earlier of XMLRPC,

00:33:38.090 --> 00:33:40.960
the result of this would be a CFString.

00:33:41.150 --> 00:33:47.600
A more complex type like the
XMethods inspector that Tim showed,

00:33:47.770 --> 00:33:51.020
the result is a dictionary
containing arrays of dictionaries

00:33:51.020 --> 00:33:52.930
containing arrays of dictionaries.

00:33:52.930 --> 00:33:55.580
And so you have to know
upfront what the type is.

00:33:55.670 --> 00:33:57.760
Of course,
you can't do a full transaction

00:33:57.760 --> 00:34:01.570
to decide what the type ID is
and do something based on that.

00:34:02.390 --> 00:34:04.360
You can also execute
these asynchronously.

00:34:04.490 --> 00:34:07.900
You set on the invocation
a client context.

00:34:07.900 --> 00:34:10.920
This is similar to how CF Stream works.

00:34:10.920 --> 00:34:12.840
In the old world, we used to set refcons.

00:34:12.920 --> 00:34:15.110
Nowadays, we set client context.

00:34:15.170 --> 00:34:20.200
This includes the info pointer that
you want to pass to your callback,

00:34:20.200 --> 00:34:24.260
as well as some callbacks
for the info pointer to allow

00:34:24.350 --> 00:34:26.740
it to be reference counted.

00:34:26.740 --> 00:34:31.680
If you're familiar with the CF API,
you can see how this works.

00:34:31.680 --> 00:34:34.540
Once you set the callback,
you can schedule this invocation

00:34:34.540 --> 00:34:38.120
on one or more run loops,
and as those run loops execute,

00:34:38.120 --> 00:34:41.620
the invocation will pass
through its state machine,

00:34:41.790 --> 00:34:45.640
ultimately resulting in getting
the data or getting a fault.

00:34:45.640 --> 00:34:49.440
Then it will call your callback
during that run loop invocation,

00:34:49.440 --> 00:34:53.140
and you can process the result.

00:34:53.140 --> 00:34:54.200
We're going to do a demo now.

00:34:54.280 --> 00:34:56.440
If I could go to demo four.

00:34:59.340 --> 00:35:00.000
We're on demo four.

00:35:00.000 --> 00:35:01.070
All right.

00:35:01.070 --> 00:35:02.130
Here we go.

00:35:02.130 --> 00:35:04.250
Google API in shiny metal.

00:35:04.510 --> 00:35:08.510
I did the demo last night,
so I had the opportunity to check that

00:35:08.620 --> 00:35:12.040
checkbox and make this thing demo,
make it metal.

00:35:12.040 --> 00:35:14.420
So,
I'm gonna show you first what it does.

00:35:14.420 --> 00:35:18.780
If you haven't heard, Google released an
API for their web service,

00:35:18.780 --> 00:35:20.800
for their search engine.

00:35:21.020 --> 00:35:25.530
And this is relevant because
if they don't change the API,

00:35:25.530 --> 00:35:29.480
which they shouldn't because
APIs are supposed to be immutable,

00:35:29.650 --> 00:35:31.720
20 years from now,
I won't have to try and figure

00:35:31.740 --> 00:35:34.440
out how to scrape their web page
to get their search results.

00:35:34.440 --> 00:35:37.160
I can just call this API and
get the same information back.

00:35:37.160 --> 00:35:43.520
So we search for Google API, hit return,
and it goes out, contacts Google through

00:35:43.520 --> 00:35:48.540
WS Core and fetches the results.

00:35:48.990 --> 00:35:53.000
Anyway,
so the result from the Google API is

00:35:53.000 --> 00:35:55.500
that the search engine is now working.

00:35:55.500 --> 00:35:57.300
So, I'm gonna show you what it does.

00:35:57.550 --> 00:36:01.500
So, I'm gonna show you what it does.

00:36:01.500 --> 00:36:04.190
So, I'm gonna show you what it does.

00:36:04.220 --> 00:36:06.900
So, I'm gonna show you what it does.

00:36:06.900 --> 00:36:09.000
So, I'm gonna show you what it does.

00:36:09.000 --> 00:36:13.990
So, I'm gonna show you what it does.

00:36:13.990 --> 00:36:17.000
So, I'm gonna show you what it does.

00:36:17.000 --> 00:36:20.990
So, I'm gonna show you what it does.

00:36:21.000 --> 00:36:21.000
So, I'm gonna show you what it does.

00:36:21.000 --> 00:36:21.970
So, I'm gonna show you what it does.

00:36:22.020 --> 00:36:24.000
So, I'm gonna show you what it does.

00:36:24.000 --> 00:36:24.000
So, I'm gonna show you

00:36:24.860 --> 00:36:28.430
First thing we do is we
create an invocation.

00:36:28.790 --> 00:36:31.580
Well, actually the first thing I guess
we did was we created a URL that

00:36:31.740 --> 00:36:35.140
specified the endpoint that we
wanted to send our request to,

00:36:35.140 --> 00:36:40.140
in this case,
http://google.com/search/beta2.

00:36:40.270 --> 00:36:42.580
When you go to Google and
you look at their API,

00:36:42.580 --> 00:36:45.910
they give you a developer kit,
and it's got all the information

00:36:45.910 --> 00:36:49.070
about what the methods are
available and what the APIs are,

00:36:49.070 --> 00:36:52.280
what the endpoints are,
and sort of all the meta information

00:36:52.280 --> 00:36:54.650
you need in order to send the request.

00:36:55.780 --> 00:36:59.400
So we create the URL,
we create the invocation with the URL,

00:36:59.400 --> 00:37:02.160
the name of the method, and the protocol.

00:37:02.160 --> 00:37:04.290
We're specifying as SOAP 1999.

00:37:04.320 --> 00:37:08.190
It's probably not the best name,
but that specifies SOAP 1.1.

00:37:08.190 --> 00:37:10.620
Then we're going to set the parameters.

00:37:10.620 --> 00:37:14.400
The Google search takes 10 parameters.

00:37:14.400 --> 00:37:18.560
They're all required in their API or
in their implementation of the API,

00:37:18.560 --> 00:37:24.160
but that is something that,
it's really up to them to own that.

00:37:24.160 --> 00:37:27.800
Probably the least relevant
thing that's required is the key.

00:37:27.800 --> 00:37:29.240
When you sign up for
their developer program,

00:37:29.240 --> 00:37:30.340
they give you a key.

00:37:30.400 --> 00:37:34.200
The key is like a 40-digit long number,
alphanumeric string.

00:37:34.200 --> 00:37:37.880
I keep it in a dot file in
my home directory so that

00:37:37.880 --> 00:37:40.080
all my tools can use it.

00:37:40.110 --> 00:37:41.220
We're going to do two things.

00:37:41.220 --> 00:37:44.680
We're going to build up an array
of strings and an array of values.

00:37:44.680 --> 00:37:49.820
There's a one-to-one correspondence
between the key in the string table

00:37:49.820 --> 00:37:53.060
and the value in the value table.

00:37:53.060 --> 00:37:55.400
In this case, we've got the keys,
get my secret key,

00:37:55.400 --> 00:37:58.260
and the key key from my dot file.

00:37:58.490 --> 00:38:00.980
Q is the query, the F query string.

00:38:00.980 --> 00:38:03.830
This was set when you
hit the search button.

00:38:03.840 --> 00:38:06.880
Magic Cocoa things happened.

00:38:06.930 --> 00:38:11.780
I have to create an NSNumber instead of
just passing the number 0 or 10 in here.

00:38:11.790 --> 00:38:15.680
There's no automatic Cocoa or
Objective-C coercion from

00:38:15.680 --> 00:38:17.700
a scalar to an NSNumber.

00:38:17.700 --> 00:38:21.360
I create the number with
the integers 0 and 10.

00:38:21.360 --> 00:38:22.520
There are additional parameters,
which are booleans and strings

00:38:22.520 --> 00:38:23.210
that tell us what the number is.

00:38:23.300 --> 00:38:24.120
I'm going to use the integer 0 and 10.

00:38:24.120 --> 00:38:24.280
I'm going to use the integer 0 and 10.

00:38:24.280 --> 00:38:25.080
I'm going to use the integer 0 and 10.

00:38:25.080 --> 00:38:25.280
I'm going to use the integer 0 and 10.

00:38:25.280 --> 00:38:27.910
I'm going to use the tell Google what
kind of search I want to do,

00:38:27.910 --> 00:38:32.420
or whether to restrict the
Google search to a particular language.

00:38:32.420 --> 00:38:36.490
I create an array,
which is the parameter order from

00:38:36.490 --> 00:38:42.570
the array that I tonsed up up front,
and then a parameter values.

00:38:42.570 --> 00:38:42.570
And I have a parameter, which is a

00:38:43.300 --> 00:39:26.100
[Transcript missing]

00:39:26.640 --> 00:39:28.210
with, again,
the string that was given to us

00:39:28.370 --> 00:39:30.680
by the Google API documentation.

00:39:30.710 --> 00:39:32.870
And then you invoke it.

00:39:33.900 --> 00:39:35.960
So the result of the invocation
is a result dictionary.

00:39:35.960 --> 00:39:39.380
So we block at this point,
send the message, get the result,

00:39:39.440 --> 00:39:42.590
and then we process it in here.

00:39:42.770 --> 00:39:45.490
If the reply is a fault,
then we're just going to go

00:39:45.490 --> 00:39:47.530
ahead and say an error occurred.

00:39:47.690 --> 00:39:51.200
Otherwise, we delve into the dictionary.

00:39:52.940 --> 00:39:58.620
and we look up the magic key
KWS method invocation result.

00:39:58.690 --> 00:40:02.600
This contains the actual
result of the SOAP invocation,

00:40:02.600 --> 00:40:04.420
not the meta information.

00:40:04.420 --> 00:40:09.840
Google, of course, well, not of course,
but Google decided to add an extra

00:40:09.840 --> 00:40:11.500
level of an indirection to that.

00:40:11.760 --> 00:40:15.580
So we then, we know the result of that
invocation was a dictionary,

00:40:15.580 --> 00:40:19.060
and then we have to
look up the key return,

00:40:19.120 --> 00:40:22.750
which gives us another dictionary,
and then the key result elements.

00:40:23.180 --> 00:40:27.770
which is an array that lives
inside that dictionary.

00:40:28.380 --> 00:40:31.510
From there,
we just go off into the rest of our

00:40:31.510 --> 00:40:33.750
Cocoa class and process the results.

00:40:33.880 --> 00:40:36.680
Now, one interesting thing is

00:40:37.300 --> 00:40:43.180
So when we ran this API, AppleScript,

00:40:43.470 --> 00:40:50.750
When we ran this demo,
my little progress bar didn't spin.

00:40:50.750 --> 00:40:50.750
Why didn't it?

00:40:50.750 --> 00:40:50.750
I don't believe that.

00:40:52.840 --> 00:40:56.310
A little progress where I didn't
spin because this application

00:40:56.950 --> 00:40:58.710
blocked in order to get the results.

00:40:58.860 --> 00:41:02.200
So I want to go ahead
and modify it real quick.

00:41:02.980 --> 00:41:09.420
and David Levy are also
represented in this session.

00:41:10.190 --> 00:41:17.290
I'm going to copy the code that sets
the context to my Cocoa object and

00:41:17.290 --> 00:41:23.520
sets the callback to be a little stub
that calls a method on my Cocoa object.

00:41:23.520 --> 00:41:26.350
Then WS method invocation
schedule with run loop,

00:41:26.520 --> 00:41:27.970
giving it the current run loop.

00:41:28.040 --> 00:41:30.100
And then I'm going to
return from my function.

00:41:30.700 --> 00:41:34.800
So this is the function that
gets hit when you call doSearch.

00:41:35.100 --> 00:41:41.600
[Transcript missing]

00:41:42.130 --> 00:41:46.310
Close our function,
and then we need another function which

00:41:46.460 --> 00:41:51.590
gets called when the callback completes.

00:41:52.300 --> 00:42:20.200
[Transcript missing]

00:42:23.010 --> 00:42:26.900
There are a couple of customizations
you can add to an invocation.

00:42:26.940 --> 00:42:29.770
You can override how
it serializes CF types,

00:42:29.770 --> 00:42:32.200
and you do this based on the CF type IDs.

00:42:32.200 --> 00:42:37.460
So if a CFDictionary comes along that you
need special control over serializing,

00:42:37.460 --> 00:42:42.060
you can say, I want to customize
CFDictionary serialization,

00:42:42.060 --> 00:42:45.500
and insert your own code at that point,
which will get called

00:42:45.500 --> 00:42:46.900
to write out the XML.

00:42:46.900 --> 00:42:49.520
And of course, if you return null,
then the default

00:42:49.690 --> 00:42:51.360
serializer will take over.

00:42:52.900 --> 00:42:57.140
If there's a part of an XML tree
that isn't being parsed properly

00:42:57.160 --> 00:43:02.170
or to your satisfaction,
you can get control of the parser at that

00:43:02.170 --> 00:43:08.660
point and replace your own CF type with
what you think should be represented.

00:43:08.660 --> 00:43:13.830
And you can access the SOAP headers
and put your own SOAP extensions in,

00:43:13.870 --> 00:43:17.800
or if there is a SOAP extension that you
need support for that we don't support,

00:43:17.800 --> 00:43:21.980
because we don't support any in 1.0,
you can add your own SOAP headers,

00:43:21.980 --> 00:43:22.760
which are XML.

00:43:23.020 --> 00:43:27.600
basically into the into the
soap header that gets sent.

00:43:28.200 --> 00:44:56.500
[Transcript missing]

00:44:57.340 --> 00:45:00.230
So, one more demo.

00:45:00.300 --> 00:45:02.340
Back to the demo machine.

00:45:02.510 --> 00:45:06.920
And if this works, whoa.

00:45:07.660 --> 00:45:08.600
Let's get rid of all these.

00:45:08.600 --> 00:45:09.780
So I've got a new project.

00:45:09.870 --> 00:45:10.940
I'm not going to copy and paste.

00:45:11.040 --> 00:45:13.410
I'm just going to hope it works.

00:45:13.450 --> 00:45:15.160
I probably should have run it beforehand.

00:45:15.230 --> 00:45:21.160
But I'm going to show you I have,
in a PB project, a new project.

00:45:22.760 --> 00:45:25.420
An invocation of the WS Make Stubs tool.

00:45:25.530 --> 00:45:28.720
It's probably too small to read,
but it takes -x,

00:45:28.720 --> 00:45:32.530
Objective-C is the language
that I want emitted,

00:45:32.710 --> 00:45:36.460
and then some parameters that
specify the output directory,

00:45:36.460 --> 00:45:38.570
the name of the file
that I want to create,

00:45:38.680 --> 00:45:44.200
and in this case,
the URL that Google supplies

00:45:44.200 --> 00:45:44.200
with their WSDL information.

00:45:44.420 --> 00:45:48.280
And I'm going to go ahead and
run it or compile it while I'm

00:45:48.330 --> 00:45:51.780
actually looking at the source.

00:45:53.100 --> 00:46:04.700
[Transcript missing]

00:46:07.000 --> 00:46:08.680
like this.

00:46:08.680 --> 00:46:11.870
For each different method or
endpoint that's available,

00:46:11.940 --> 00:46:15.710
it creates an Objective-C class
which inherits from a master

00:46:15.710 --> 00:46:21.120
class that implements some of
the underlying WS core behavior.

00:46:21.120 --> 00:46:24.550
DoSpellingSuggestion is
one of the Google API's.

00:46:24.550 --> 00:46:28.830
Just like the other ones,
it's got the key parameter and then

00:46:28.830 --> 00:46:32.130
the phrase that we want to spell check.

00:46:32.130 --> 00:46:34.780
And then the one that
we were calling before,

00:46:34.780 --> 00:46:35.780
doGoogleSearch.

00:46:35.980 --> 00:46:41.600
So in order to call this API,
I changed my implementation.

00:46:43.300 --> 00:46:58.800
[Transcript missing]

00:47:01.200 --> 00:47:03.800
and then call the set
parameters method on it,

00:47:03.800 --> 00:47:06.840
giving it all the same values,
but this time it's statically bound,

00:47:06.920 --> 00:47:08.150
statically typed to the
Objective-C runtime.

00:47:08.240 --> 00:47:14.580
I set the callback based on the

00:47:16.160 --> 00:47:18.860
The API of the generated stubs
gives you a set callback method

00:47:18.860 --> 00:47:20.390
and a schedule on run loop method.

00:47:20.640 --> 00:47:23.290
It looks exactly the
same as the other code,

00:47:23.290 --> 00:47:26.580
it's just I didn't have to do
all the method namespace URI,

00:47:26.580 --> 00:47:28.960
SOAP action, and naming of parameters.

00:47:28.960 --> 00:47:33.440
That was all done by the generated stubs.

00:47:33.440 --> 00:47:33.440
Then when we ran it,

00:47:33.970 --> 00:47:34.900
It was running.

00:47:34.900 --> 00:47:36.340
It is running.

00:47:36.440 --> 00:47:44.200
So it's exactly the same thing,
but the complexity of calling the API is

00:47:44.200 --> 00:47:44.200
abstracted by the generated stubs.

00:47:45.530 --> 00:47:52.400
The source to that will
be available for demo.

00:47:52.510 --> 00:48:02.600
Where are we going in
the future with this API?

00:48:02.600 --> 00:48:05.170
We're going to have some
SOAP extensions coming in the future.

00:48:05.170 --> 00:48:07.750
As these become formalized
by the industry at large,

00:48:07.750 --> 00:48:13.400
we're going to adopt them and produce
APIs to allow them to bind into WS Core.

00:48:13.400 --> 00:48:14.520
This is the core stuff.

00:48:14.520 --> 00:48:19.340
This is the stuff that we're going to
build our web services architectures on.

00:48:19.340 --> 00:48:23.760
We will have a WSDL API in the future,
and better WSDL integration

00:48:23.850 --> 00:48:26.300
with CF types and CF schemas.

00:48:26.300 --> 00:48:28.690
People have ideas on how they
would like to see that implemented.

00:48:28.690 --> 00:48:33.040
By all means, get in contact with us and
let's work together on that.

00:48:33.040 --> 00:48:35.890
There's been some call for a UDDI API.

00:48:35.890 --> 00:48:40.940
UDDI is an acronym that I'm not
even going to try and remember.

00:48:40.940 --> 00:48:43.640
But it's for locating
services on the network.

00:48:43.700 --> 00:48:46.590
It's for saying,
"I'm interested in services that give

00:48:46.590 --> 00:48:51.010
me cartoons," and coming back with
a list of WSDL files that specify

00:48:51.010 --> 00:48:54.280
different cartoons that you can get.

00:48:54.290 --> 00:48:58.720
It's a programmatic interface
for discovery of services.

00:48:58.720 --> 00:49:03.220
A server-side API may be part of WS Core,
but today,

00:49:03.390 --> 00:49:09.730
WebObjects provides a server-side web
services API that's very well integrated

00:49:09.730 --> 00:49:12.740
with the WebObjects environment.

00:49:12.800 --> 00:49:14.100
Thank you.

00:49:14.730 --> 00:49:17.130
you want to talk about the
RoadMap or other sessions.

00:49:17.330 --> 00:49:18.700
Or I'll talk about them.

00:49:18.880 --> 00:49:19.420
Okay.

00:49:19.420 --> 00:49:21.750
So some other sessions that
you might want to go to.

00:49:21.750 --> 00:49:26.600
CfNetwork that WS Core is built on is
a very exciting framework that we're

00:49:26.600 --> 00:49:32.810
putting a lot of investment in and all
the other sort of IAP and web projects

00:49:32.810 --> 00:49:38.110
that you see us doing at Apple are
going to be built on CfNetwork.

00:49:38.430 --> 00:49:43.770
XML and WebObjects is going to talk
about accessing web services from

00:49:43.770 --> 00:49:50.040
WebObjects and how to integrate
XML into WebObjects applications.

00:49:50.040 --> 00:49:52.260
Same with Java Web Services.

00:49:52.260 --> 00:49:56.010
Managing I/O, CFRunLoop and CfStream,
if you're a low level person and you

00:49:56.010 --> 00:50:00.630
want to understand how CfNetwork works,
how Web Services Core works,

00:50:00.630 --> 00:50:03.770
that's a good session to talk,
to go to as well.

00:50:06.500 --> 00:50:07.720
More Web Objects and Web Services.

00:50:07.800 --> 00:50:09.370
And then the AppleScript Studio intro.

00:50:09.840 --> 00:50:12.600
There will be a lot of good
information there about how to use

00:50:12.770 --> 00:50:15.730
AppleScript to access web services.

00:50:16.900 --> 00:50:29.800
[Transcript missing]

00:50:37.700 --> 00:50:42.500
On the Jaguar CD,
in Developer Examples Web Services,

00:50:42.500 --> 00:50:48.050
there's an XMethods Inspector app
built using WSMakeStubs.

00:50:48.160 --> 00:50:51.490
It's not as nicely polished
as the one Tim showed,

00:50:51.490 --> 00:50:55.060
but at least the source is there
and it's easy to understand.

00:50:55.060 --> 00:50:59.360
You can find out about XMLRPC at
the website of the developer,

00:50:59.360 --> 00:51:00.700
xmlrpc.com.

00:51:00.700 --> 00:51:11.480
He's got links to implementations as
well as services that are available.

00:51:11.490 --> 00:51:11.490
SOAP is a W3C thing,
so that's a URL that you

00:51:11.490 --> 00:51:11.490
use to access the software.

00:51:11.640 --> 00:51:13.610
the SOAP specification.

00:51:13.610 --> 00:51:15.600
Same with WSDL and UDDI.

00:51:15.600 --> 00:51:19.500
And there's a QA, Tech Note 1111,
which is how to add OSA or

00:51:19.500 --> 00:51:21.330
AppleScript to your application.

00:51:21.460 --> 00:51:24.490
So if you want to take
advantage of AppleScript today,

00:51:24.500 --> 00:51:27.620
and web services in a
shipping application,

00:51:27.700 --> 00:51:30.260
that would be a good place to start.

00:51:30.260 --> 00:51:35.730
There are also tech notes available on
the developer public site on accessing

00:51:36.320 --> 00:51:39.400
web services through SOAP and XMLRPC.

00:51:39.480 --> 00:51:42.080
Some really good documentation
is already available.
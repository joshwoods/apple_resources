WEBVTT

00:00:02.460 --> 00:00:09.500
Ladies and gentlemen, please welcome
Senior Software Engineer John Randolph.

00:00:14.410 --> 00:00:15.960
Good morning.

00:00:16.000 --> 00:00:17.960
Thanks everyone.

00:00:17.960 --> 00:00:20.610
As the announcer mentioned,
I'm a senior software engineer at Apple,

00:00:20.610 --> 00:00:23.800
which means that I'm getting close to 40.

00:00:24.130 --> 00:00:29.490
I've been using this product, Cocoa,
for quite a long time.

00:00:29.500 --> 00:00:33.540
In fact, I've been using it since it was
going by a number of other names.

00:00:33.710 --> 00:00:36.540
What I'm going to talk to you about today

00:00:37.580 --> 00:00:43.100
is that portion of Cocoa that's involved
with actually getting onto the screen.

00:00:43.200 --> 00:00:46.290
So we're going to talk about the
classes in the Cocoa framework

00:00:46.290 --> 00:00:48.060
that are involved in drawing.

00:00:48.180 --> 00:00:50.810
We're gonna talk about how
the quartz drawing model,

00:00:50.830 --> 00:00:53.930
the 2D rendering model,
all those wonderful things that

00:00:53.930 --> 00:00:56.960
you saw in the core graphics
sessions that were not OpenGL is

00:00:56.960 --> 00:00:59.540
reflected in the Cocoa framework.

00:00:59.610 --> 00:01:02.470
We're going to talk about how to
change a coordinate space around

00:01:02.470 --> 00:01:05.910
to make it more convenient for you,
and we're going to talk about images,

00:01:06.000 --> 00:01:07.630
we're going to talk about paths,
we're going to talk a

00:01:07.630 --> 00:01:09.620
little bit about text.

00:01:11.310 --> 00:01:13.800
So the Quartz 2D imaging model.

00:01:13.800 --> 00:01:14.640
You've all seen it before.

00:01:14.640 --> 00:01:15.680
You saw it in PostScript.

00:01:15.750 --> 00:01:19.200
If you're a web developer,
you're starting to see it again in SVG.

00:01:19.200 --> 00:01:24.200
And the idea in the Quartz 2D
imaging model is that you describe

00:01:24.200 --> 00:01:29.260
how you want to move a pen in
a virtual two-dimensional space.

00:01:29.990 --> 00:01:32.690
These moves consist of
things like go here,

00:01:32.800 --> 00:01:35.960
draw a line to there,
draw a curve over here,

00:01:35.970 --> 00:01:40.580
and then once you describe this path,
you can take that path and fill

00:01:40.690 --> 00:01:44.780
it or you can stroke it and you
can stroke it with a dashed line

00:01:44.790 --> 00:01:47.050
style and that sort of thing.

00:01:50.310 --> 00:01:53.480
receivers all the way over there, okay.

00:01:53.480 --> 00:01:57.970
The quartz 2D imaging model also gives
us alpha channel support or transparency.

00:01:57.970 --> 00:02:01.830
We can use pre-multiplied images
or not pre-multiplied images,

00:02:01.910 --> 00:02:05.990
depending on what you want to do
for your performance considerations.

00:02:05.990 --> 00:02:09.700
And we give you a lot of
different compositing modes.

00:02:09.830 --> 00:02:11.540
We've got 14 of them.

00:02:11.540 --> 00:02:15.730
The original Porter-Duff
paper on compositing had 12.

00:02:15.850 --> 00:02:17.460
We invented two more.

00:02:17.460 --> 00:02:20.880
We care about both the source
and the destination alpha,

00:02:20.880 --> 00:02:24.100
and I'll show you the benefit
of that in the demo coming up.

00:02:24.140 --> 00:02:29.470
And there's a program in your
developer applications examples app

00:02:29.470 --> 00:02:34.030
kit folder called Composite Lab that
you can use to try out all of these

00:02:34.030 --> 00:02:37.970
different compositing modes and
see which one does what you need.

00:02:41.330 --> 00:02:42.820
Isn't that amazing?

00:02:42.880 --> 00:02:44.430
OK.

00:02:44.510 --> 00:02:47.830
So I'd like to give you some advice
about writing code with Cocoa.

00:02:47.930 --> 00:02:52.020
The idea in Cocoa is that all
of the parts of an application

00:02:52.020 --> 00:02:56.490
that are common to a spreadsheet
and to a 3D rendering app

00:02:57.780 --> 00:03:01.140
Those parts,
those common parts belong in the kit.

00:03:01.140 --> 00:03:01.930
We should do those.

00:03:01.940 --> 00:03:04.500
You shouldn't really be redoing them.

00:03:04.620 --> 00:03:07.290
So don't reinvent the wheel.

00:03:07.630 --> 00:03:09.890
Secondly,
we give you a lot of ways to change

00:03:09.890 --> 00:03:12.100
the environment you're working in.

00:03:12.170 --> 00:03:15.970
We give you delegate methods,
we give you notifications,

00:03:15.970 --> 00:03:20.490
we give you a lot of ways to check
what's happening and say thumbs up

00:03:20.490 --> 00:03:22.800
or thumbs down or do it different.

00:03:24.570 --> 00:03:27.300
And as a good friend of mine
has said on many occasions,

00:03:27.360 --> 00:03:31.980
this is the best advice I can possibly
give you for working with Cocoa.

00:03:37.960 --> 00:03:42.140
First, see if there's an easy way
to do what you want to do.

00:03:42.180 --> 00:03:47.280
A lot of common drawing tasks
are taken care of by high level

00:03:47.950 --> 00:03:49.890
classes in the application kit.

00:03:49.890 --> 00:03:53.860
We've got paths, we've got colors,
we've got text handling,

00:03:54.010 --> 00:03:59.910
we've got coordinate transformations,
and these all have associated classes

00:03:59.910 --> 00:03:59.910
to make them easier to get at.

00:04:01.720 --> 00:04:04.500
So if you're going to draw,
the first question is what

00:04:04.500 --> 00:04:05.260
am I going to draw on?

00:04:05.330 --> 00:04:07.260
Well, actually your first question
is what are you going to draw,

00:04:07.260 --> 00:04:08.060
but that's your problem.

00:04:08.060 --> 00:04:09.840
Where you draw, that's for us.

00:04:12.330 --> 00:04:19.490
A drawing destination in the
application kit is an object that's

00:04:19.490 --> 00:04:21.220
able to get the drawing focus.

00:04:21.240 --> 00:04:23.800
In other words,
it's an object that can get the

00:04:23.800 --> 00:04:26.700
current core graphics state.

00:04:26.700 --> 00:04:30.220
In the kit,
these are objects that implement

00:04:30.220 --> 00:04:32.130
lock focus and unlock focus methods.

00:04:32.750 --> 00:04:36.100
Normally,

00:04:36.780 --> 00:04:40.110
in NSView, "You don't have to deal
with locking focus.

00:04:40.310 --> 00:04:45.270
When it's time for you to draw,
that will have already

00:04:45.270 --> 00:04:45.270
been done for you."

00:04:45.630 --> 00:04:50.830
The NSView class has been described a
little bit in the Cocoa sessions already,

00:04:50.830 --> 00:04:54.460
and I like to describe it as
a rectangle of responsibility.

00:04:54.460 --> 00:04:59.540
It's the area in a window that's going
to get the events that happen in that

00:04:59.540 --> 00:05:02.710
part of the window that it covers.

00:05:02.710 --> 00:05:07.340
So it's going to get keystrokes if
it has the first responder status.

00:05:07.340 --> 00:05:10.370
It's going to get mouse events
if it implements methods to

00:05:10.450 --> 00:05:12.080
react to the mouse events.

00:05:25.480 --> 00:05:25.490
But we're here to talk about the drawing,
so I'm going to describe how

00:05:25.490 --> 00:05:25.490
NSView knows when to draw,
where to draw, and how you can just say,

00:05:25.490 --> 00:05:25.490
"Here's what to draw."

00:05:29.700 --> 00:05:32.590
We also have a class in
the kit called NSImage.

00:05:32.700 --> 00:05:35.780
And NSImage is also a place to draw.

00:05:35.780 --> 00:05:39.600
It's a little unusual in the kit
in that it's also a thing to draw.

00:05:39.600 --> 00:05:43.600
And I'll get into that in
some more detail later on.

00:05:44.460 --> 00:05:51.020
So NSView is the class that draws,
it prints, and it takes events.

00:05:51.020 --> 00:05:53.400
Every view has its own coordinate space.

00:05:53.670 --> 00:05:55.900
Views live in a hierarchy in a window.

00:05:55.900 --> 00:05:59.280
Every view has a super
view or a sub view,

00:05:59.280 --> 00:06:01.830
except for the one at the very top,
which is part of the kit and

00:06:01.830 --> 00:06:03.270
you don't have to deal with it.

00:06:06.060 --> 00:06:07.910
Back here.

00:06:07.910 --> 00:06:13.000
And NSImage is a container
for NSImageRep instances.

00:06:13.000 --> 00:06:17.840
As I said before,
it's a thing to draw and a place to draw.

00:06:18.090 --> 00:06:24.110
You can think of NSImage as a resolution
independent representation of an image.

00:06:24.630 --> 00:06:26.810
And if you're coming from
the quick draw world,

00:06:26.810 --> 00:06:29.960
you used to set up your own G worlds,
and in other environments you might set

00:06:29.960 --> 00:06:31.500
up a memory buffer and draw into that.

00:06:31.500 --> 00:06:36.060
In the app kit,
when you want to do off-screen drawing,

00:06:36.100 --> 00:06:40.040
when you want to assemble
something in multiple steps

00:06:40.040 --> 00:06:44.760
before showing it to your users,
you should create an NSImage,

00:06:44.760 --> 00:06:48.050
draw into that,
and then use the image's drawing

00:06:48.330 --> 00:06:50.920
methods to get it onto the display.

00:06:51.070 --> 00:06:52.590
So now I'm going to
give you my first demo.

00:06:53.480 --> 00:06:55.400
Can we go to the demo machine please?

00:06:55.760 --> 00:06:58.700
Okay.

00:06:58.700 --> 00:07:02.800
And I could go to my demo code folder
or I could just go to the doc here.

00:07:03.960 --> 00:07:05.900
So this is a fairly simple application.

00:07:05.900 --> 00:07:08.140
It's got a pair of NSImage views in it.

00:07:08.140 --> 00:07:13.300
It's got a color well,
which will invoke the color panel.

00:07:14.220 --> 00:07:18.450
And it's got a pop-up menu that
selects one of the 14 compositing

00:07:18.450 --> 00:07:20.940
operators that I just mentioned before.

00:07:21.070 --> 00:07:23.690
Let me go to my Handy Icons folder.

00:07:23.810 --> 00:07:29.330
And let's say, for example,
I've got this eject symbol.

00:07:30.570 --> 00:07:42.460
and I may want it in a different color.

00:07:42.460 --> 00:07:42.460
So what I'm going to do
is take a color that has a

00:07:42.460 --> 00:07:42.460
transparency value and apply it

00:07:43.680 --> 00:07:45.780
Oops.

00:07:45.880 --> 00:07:47.960
Okay, now the color well is active.

00:07:47.990 --> 00:07:51.570
Take a color that has a transparency
value and apply it to an existing image.

00:07:51.570 --> 00:07:55.690
Make that a little bigger.

00:07:58.700 --> 00:08:01.770
And I don't know if you can
quite see the shadow under here,

00:08:01.820 --> 00:08:05.940
but notice as I go to a completely solid
color that I'm compositing over here,

00:08:06.000 --> 00:08:07.920
I still have a shadow.

00:08:07.980 --> 00:08:12.560
That's because we care about both
the source and the destination alpha.

00:08:12.560 --> 00:08:19.000
Now we've got a number of different
compositing operators here,

00:08:19.000 --> 00:08:23.080
and one of these is probably
the one we want for whatever

00:08:23.080 --> 00:08:23.080
drawing task we have at hand.

00:08:23.550 --> 00:08:26.540
And like I said,
the composited lab example can

00:08:26.540 --> 00:08:32.480
be used to test all these out and
see which one you actually need

00:08:32.480 --> 00:08:35.940
for your particular situation.

00:08:36.030 --> 00:08:38.500
So, lots of them to check.

00:08:38.500 --> 00:08:40.900
So let me show you the code for this.

00:08:46.010 --> 00:08:52.440
One thing I wanted to mention to you here
is that when you're writing Cocoa code,

00:08:52.440 --> 00:08:56.900
you should think about
where code actually belongs.

00:08:56.900 --> 00:09:05.410
I could have made a subclass of
NSImageView that draws tinted images,

00:09:05.520 --> 00:09:07.270
that has an image and has
a color and overrides the

00:09:07.270 --> 00:09:07.270
drawing methods of NSImageView.

00:09:07.910 --> 00:09:11.950
I thought that it might be convenient
if every image was able to give

00:09:11.950 --> 00:09:14.080
me a tinted version of itself.

00:09:14.080 --> 00:09:21.340
So what I did in this code is
I made a category of NSImage and

00:09:21.340 --> 00:09:24.560
I have two methods in the category.

00:09:25.440 --> 00:09:28.660
This is the method that
does the heavy lifting.

00:09:28.660 --> 00:09:31.510
What I'm going to do in this
method is create a new image that

00:09:31.570 --> 00:09:35.300
is a tinted version of the image
that's received this message.

00:09:35.300 --> 00:09:38.830
To do that,
I make a rectangle for the image bounds,

00:09:38.830 --> 00:09:43.340
make a new image with the size
that I've constructed up here.

00:09:44.000 --> 00:09:45.240
Lock focus on the image.

00:09:45.270 --> 00:09:49.600
That means tell Core Graphics
this is where we're drawing.

00:09:49.640 --> 00:09:51.770
Fill it with the clear color.

00:09:52.440 --> 00:09:57.890
and the image that got this message
is going to composite its contents

00:09:58.420 --> 00:10:03.050
into the current drawing focus,
the new image we've created.

00:10:03.050 --> 00:10:06.870
I'm going to set the color that
I got from that color well,

00:10:06.920 --> 00:10:10.150
or excuse me, in this case,
the color that was

00:10:10.300 --> 00:10:12.360
passed into this method.

00:10:14.510 --> 00:10:22.140
fill using the compositing operation,
which was also passed into this

00:10:22.140 --> 00:10:22.140
method and in this application.

00:10:22.140 --> 00:10:22.140
It came from that pop-up list.

00:10:22.330 --> 00:10:25.040
Unlock Focus on the image
and return the image.

00:10:25.040 --> 00:10:28.530
Return it auto-released because
this is not an init method,

00:10:28.530 --> 00:10:29.950
it is not a copy method.

00:10:29.950 --> 00:10:32.080
It is not an alloc method.

00:10:32.080 --> 00:10:36.100
So anything that needs a tinted
version of the image can say

00:10:36.100 --> 00:10:40.140
to some particular image,
I need a tinted version of you with this

00:10:40.210 --> 00:10:42.660
compositing operator and this color.

00:10:42.670 --> 00:10:45.470
Get back to me when
you've figured that out.

00:10:45.540 --> 00:10:50.100
So that is the code for the tinted image.

00:10:52.200 --> 00:10:54.510
Back to slides, please.

00:10:59.900 --> 00:11:02.360
I really shouldn't do this from
all the way over on this side.

00:11:02.360 --> 00:11:05.140
So I'm going to tell you what
I did wrong in that demo.

00:11:05.210 --> 00:11:07.660
First thing is I was not
very memory efficient.

00:11:07.690 --> 00:11:11.270
Every time I changed the color I was
actually creating a new image and

00:11:11.270 --> 00:11:13.290
throwing away the one I had before.

00:11:13.340 --> 00:11:17.180
If I was doing this in a real
live graphics application and

00:11:17.180 --> 00:11:21.420
I cared about memory footprint
and cared about performance,

00:11:21.420 --> 00:11:25.270
I would actually have an image
that I reused while I was moving

00:11:25.640 --> 00:11:29.400
controls around and then save
that when I was happy with it.

00:11:31.500 --> 00:11:35.980
This would also be a good time to
start talking about the NSColor class.

00:11:35.980 --> 00:11:39.570
The NSColor is sort of like
NSImage in that it's an

00:11:39.570 --> 00:11:45.560
abstract definition of colors,
meaning anything you can use to

00:11:46.060 --> 00:11:49.020
paint an area or paint a line.

00:11:49.270 --> 00:11:52.740
It's not necessarily an RGB value.

00:11:52.740 --> 00:11:55.460
We've got a lot of different
color spaces you can use.

00:11:55.460 --> 00:12:00.280
We also have pattern colors,
which you would have seen in

00:12:00.280 --> 00:12:03.660
the core graphics 2D demos.

00:12:03.660 --> 00:12:05.690
To paint with a color,
to make it the current color,

00:12:05.690 --> 00:12:07.820
you send it a set message.

00:12:07.880 --> 00:12:11.560
And to create a color,
there's lots of ways to get them.

00:12:11.560 --> 00:12:13.530
You can get them from a
color well as I just did,

00:12:13.530 --> 00:12:17.410
or programmatically you can set an
image as a color so that when you paint,

00:12:17.610 --> 00:12:20.000
that image shows through in
the areas you're painting.

00:12:20.050 --> 00:12:21.860
There are a lot of named
colors that are defined in the

00:12:21.860 --> 00:12:25.100
headers such as white color,
red color, blue color, and so on.

00:12:25.150 --> 00:12:28.670
And color with calibrated red, green,
blue, and alpha.

00:12:28.670 --> 00:12:30.900
Let me just mention the word calibrated.

00:12:30.900 --> 00:12:33.860
Colibrated means it
goes through color sync.

00:12:33.860 --> 00:12:38.740
So you can define your colors in some
abstract ideal color space and you

00:12:38.850 --> 00:12:44.440
can be confident that you're going to
get the same results on any machine

00:12:44.440 --> 00:12:48.540
that's got color sync installed.

00:12:48.540 --> 00:12:52.750
And then again, we have methods like
control highlight color,

00:12:52.950 --> 00:12:56.760
which will tell you a value that's
actually been determined at run time.

00:12:56.870 --> 00:12:59.410
So you could, for example,
ask for the user's

00:12:59.430 --> 00:13:00.600
preferred control color.

00:13:00.600 --> 00:13:01.990
color.

00:13:04.440 --> 00:13:07.000
Now, I'll mention a couple
of things about NSImage.

00:13:07.000 --> 00:13:09.180
Check the size.

00:13:10.920 --> 00:13:15.590
The dimensions of the image in pixels is
not the same thing as the image's size.

00:13:15.760 --> 00:13:19.000
You may have scanned that image on a
very high resolution scanner that's

00:13:19.070 --> 00:13:21.440
giving you 10,000 lines per inch.

00:13:21.460 --> 00:13:27.750
If you try to draw that
at the pixel dimensions,

00:13:27.750 --> 00:13:27.750
you're going to get a very small
amount of it on the screen.

00:13:28.100 --> 00:13:32.090
You can change the size of a given image
without changing its pixel dimensions

00:13:32.110 --> 00:13:33.800
by sending it a set size message.

00:13:34.060 --> 00:13:38.000
You can find out what size it is by
querying it with the size method.

00:13:38.000 --> 00:13:44.990
I will mention that a lot of drawing
apps out there and a lot of images

00:13:45.050 --> 00:13:51.740
that you're going to get from the
net are going to have size values

00:13:51.740 --> 00:13:51.740
in their headers that are wrong.

00:13:52.360 --> 00:13:55.060
I just wanted to caution
you to watch out for that,

00:13:55.230 --> 00:13:59.530
be alert, do a little bit of sanity
checking before you show an image.

00:13:59.790 --> 00:14:03.780
And I'm going to mention when
you draw an image with a scale,

00:14:03.790 --> 00:14:06.820
there are methods that start
with composite and dissolve,

00:14:07.000 --> 00:14:11.700
and these behave differently than the
methods that start with DrawInRect.

00:14:11.700 --> 00:14:17.200
So what you saw me using before
to draw that image in the tinted

00:14:17.200 --> 00:14:20.700
image demo was composite to point.

00:14:20.700 --> 00:14:24.670
A thing to remember about the composite
methods is that they don't respect

00:14:24.750 --> 00:14:26.700
a change in the coordinate space.

00:14:26.700 --> 00:14:29.040
The draw-in-rect methods do.

00:14:32.650 --> 00:14:35.890
mentioned some things that are
coming up in NSImage for Jaguar.

00:14:35.890 --> 00:14:38.090
First thing,
something a lot of people have been

00:14:38.090 --> 00:14:41.900
asking us for for quite some time is the
ability to draw images progressively.

00:14:41.900 --> 00:14:44.690
So when you're loading a
large image over the net,

00:14:44.890 --> 00:14:48.940
You can make an NSImage object
that will tell its delegate,

00:14:48.980 --> 00:14:51.240
"I got enough of it to know
how big it's going to be.

00:14:51.270 --> 00:14:55.560
I got enough to draw a band of
pixels." And repeat that message until,

00:14:55.640 --> 00:14:57.720
"I've got the whole image."

00:14:57.830 --> 00:15:01.040
We're also adding support for
multi-frame images such as

00:15:01.040 --> 00:15:02.840
animated GIFs and the like.

00:15:02.840 --> 00:15:06.150
The way that this works is
we load up all the frames,

00:15:06.150 --> 00:15:09.440
put them in one long bitmap,
and when you want to

00:15:09.440 --> 00:15:12.940
draw them in sequence,
you'll change the frame and

00:15:12.940 --> 00:15:17.760
draw the portion that you want
to for that point in time.

00:15:19.580 --> 00:15:23.000
And now I'm going to tell you
about the coordinate system.

00:15:23.040 --> 00:15:27.420
In QuickDraw,
the coordinates started at the upper left

00:15:27.420 --> 00:15:33.490
corner and x values increased this way,
y values increased this way.

00:15:33.650 --> 00:15:36.970
This is handy because, well,
that's the way we scanned out

00:15:37.020 --> 00:15:38.920
the memory to go to the screen.

00:15:40.620 --> 00:15:43.940
This is not the way the
world of mathematics,

00:15:43.940 --> 00:15:46.560
the world of geometry does this.

00:15:46.690 --> 00:15:51.520
We are using the original coordinate
system that Rene Descartes came up with.

00:15:51.570 --> 00:15:53.620
The origin is in the lower left corner.

00:15:53.830 --> 00:15:55.550
Coordinates are floating point values.

00:15:55.680 --> 00:15:57.300
Well,
he didn't know what floating point meant,

00:15:57.300 --> 00:15:58.620
but that's neither here nor there.

00:15:58.620 --> 00:16:04.450
Whole number coordinates land exactly
between the screen pixels initially.

00:16:04.450 --> 00:16:10.570
So that's how the coordinate
system is when we hand it to you.

00:16:11.380 --> 00:16:14.370
If you don't like it, you can change it.

00:16:14.610 --> 00:16:17.140
There are lots of ways to
change the coordinate system.

00:16:17.180 --> 00:16:20.360
A very easy way to change the
coordinate system for size is to use

00:16:20.360 --> 00:16:22.220
the scale unit square to size method.

00:16:22.260 --> 00:16:24.750
If you want to turn
the coordinate system,

00:16:24.810 --> 00:16:26.200
rotate by angle.

00:16:26.240 --> 00:16:33.120
If you say, okay, I want zero,
zero in this coordinate system to be

00:16:33.120 --> 00:16:33.120
right smack in the middle of my view,
well...

00:16:33.530 --> 00:16:35.910
Figure out where that point is,
say translate origin to point,

00:16:36.040 --> 00:16:39.030
and now that's your zero zero point.

00:16:39.710 --> 00:16:45.380
We have a class in the kit called the
NSAffineTransform class which will

00:16:45.380 --> 00:16:54.120
describe any sequence of scaling,
translating,

00:16:54.120 --> 00:16:54.380
or rotating a coordinate space,
that is any linear transformation.

00:16:57.040 --> 00:17:01.210
Now, an NSView has two rectangles
that you care about,

00:17:01.340 --> 00:17:03.760
the frame rect and the bounds rect.

00:17:03.800 --> 00:17:09.980
The frame rect tells you where you are
as far as your super view is concerned.

00:17:10.320 --> 00:17:13.040
You can change it by,
you can get it with the frame method,

00:17:13.040 --> 00:17:16.000
you can change it with
setFrame or setFrameRotation.

00:17:16.060 --> 00:17:19.870
There are a couple of other methods
for manipulating your frame rectangle.

00:17:20.120 --> 00:17:23.950
And when you change that,
you're changing what portion

00:17:23.950 --> 00:17:26.320
of your super view you cover.

00:17:27.500 --> 00:17:30.520
The one you're going to deal with
more often is the bounds rectangle.

00:17:30.530 --> 00:17:34.400
And that's how your coordinate space
looks from your own point of view.

00:17:34.400 --> 00:17:39.300
You use the bounds rectangle to determine
where the origin of your view is.

00:17:39.450 --> 00:17:42.580
You use the bounds rectangle
to determine the size of the

00:17:42.580 --> 00:17:43.400
coordinate space you're drawing in.

00:17:43.400 --> 00:17:48.510
Because when you draw, well,

00:17:49.260 --> 00:17:51.500
You're drawing in an
abstract coordinate space.

00:17:51.530 --> 00:17:54.960
Like if you have a CAD program and
you say that this particular object is

00:17:54.960 --> 00:17:59.180
10 units long and it's 5 units high,
well, what does that mean?

00:18:00.190 --> 00:18:04.810
What it means depends on what the
current transform it says and how that

00:18:04.810 --> 00:18:09.120
maps to the screen or how it maps to
whatever device you're rendering on.

00:18:12.600 --> 00:18:14.640
We'll talk about the
NS Affine Transform class.

00:18:14.640 --> 00:18:19.660
This is an object that may look familiar
to you if you were used to QuickDraw

00:18:19.660 --> 00:18:21.180
using the transformation matrix.

00:18:21.180 --> 00:18:24.540
In PostScript, you could also get at the
transformation matrix.

00:18:24.540 --> 00:18:28.910
It's a little easier to get at
in the AppKit because you don't

00:18:28.910 --> 00:18:30.270
really have to do any matrix math.

00:18:30.380 --> 00:18:33.540
You don't have to know exactly what
values to put where in the matrix

00:18:33.540 --> 00:18:34.980
to make a particular thing happen.

00:18:34.980 --> 00:18:39.230
We've got methods that are very much like
manipulating a view's coordinate space,

00:18:39.240 --> 00:18:41.860
but they can apply to
an Affine Transform.

00:18:42.440 --> 00:18:45.000
You tell it rotate by degrees,
rotate by radians,

00:18:45.000 --> 00:18:47.920
translate X by and Y by or scale by.

00:18:47.920 --> 00:18:53.680
Transform operations can be combined
using append and prepend transform.

00:18:53.680 --> 00:18:58.480
And it matters what order you
do certain transformations in,

00:18:58.480 --> 00:19:01.310
so it's something else you
want to experiment with.

00:19:04.270 --> 00:19:07.800
So if I have an affine transform,
how do I use it?

00:19:07.870 --> 00:19:10.690
Well, there's a couple of things you can
do with an affine transform that

00:19:10.700 --> 00:19:12.260
I'll show you shortly in the demo.

00:19:12.290 --> 00:19:14.650
You can take a point,
run it through a transform,

00:19:14.650 --> 00:19:17.800
and find out what the point is
in the new coordinate space.

00:19:17.800 --> 00:19:20.860
You can take a BezierPath and say,
"Here's a transform.

00:19:20.910 --> 00:19:24.340
Make all your points go through
this and get back to me when those

00:19:24.340 --> 00:19:29.190
are all done." And we can make
it the current transform for the

00:19:29.190 --> 00:19:32.480
drawing context using set or concat.

00:19:34.840 --> 00:19:43.560
And now I'm going to show you
the effects of a transformation.

00:19:43.560 --> 00:19:43.560
I didn't even have to
call for the demo machine.

00:19:43.560 --> 00:19:43.560
That's nice.

00:19:47.400 --> 00:19:51.080
Okay.

00:19:51.080 --> 00:19:54.310
So what I'm doing in this demo is
I'm making a path with a rectangle,

00:19:54.350 --> 00:19:59.070
putting a character glyph in it,
then I'm running it through a

00:19:59.070 --> 00:20:01.780
transformation and drawing it again.

00:20:01.850 --> 00:20:05.550
So the black path is the original,
the red path is the path in

00:20:05.550 --> 00:20:08.260
the transform coordinate space.

00:20:08.300 --> 00:20:12.880
And these sliders are setting the,
in this case,

00:20:12.880 --> 00:20:18.210
the x scale of the transform,
the y scale of the transform,

00:20:18.210 --> 00:20:21.380
the translation of the transform,
and the transformation of

00:20:22.350 --> 00:20:27.160
And this will rotate the
coordinate space around the origin.

00:20:27.170 --> 00:20:29.200
Oh look, forgot to hook those up.

00:20:29.200 --> 00:20:29.200
Whoops.

00:20:29.200 --> 00:20:35.310
And let me show you the
code that implements this.

00:20:41.400 --> 00:20:55.740
So first to construct the path,
I go get a new path from the class,

00:20:55.850 --> 00:21:03.090
tell the path move to zero zero,
append a rectangle,

00:21:03.090 --> 00:21:03.090
rectangle I've just defined up here,

00:21:04.400 --> 00:21:05.300
Append a glyph.

00:21:05.300 --> 00:21:07.730
I just happen to know
that glyph number 59,

00:21:07.730 --> 00:21:10.180
since I looked it up
in the Unicode table,

00:21:10.200 --> 00:21:16.870
gives me a nice big Mac OS X X that
I can use from the Helvetica font.

00:21:17.450 --> 00:21:21.000
Once created this path,
in my drawRect method, well,

00:21:21.000 --> 00:21:25.170
I check whether I've already got
the path in my instance variable,

00:21:25.460 --> 00:21:27.360
go and get it if I don't.

00:21:27.420 --> 00:21:33.400
If I don't have the transformed path,
I go and get the transformed path from,

00:21:33.990 --> 00:21:37.300
oh goodness, where did I put that?

00:21:37.300 --> 00:21:37.300
Oh, here we are.

00:21:40.120 --> 00:21:42.120
from ConstructTransformPath.

00:21:42.120 --> 00:21:45.980
What I'm doing in this method is
I make a new AffineTransform using

00:21:45.980 --> 00:21:48.500
the convenience method from the class.

00:21:48.530 --> 00:21:52.690
I tell it I'm going to rotate by this
value that I got from the user interface.

00:21:52.700 --> 00:21:58.960
I'm going to scale by this
value that I also got from the

00:21:58.960 --> 00:22:03.070
user interface from the slider.

00:22:03.070 --> 00:22:03.070
I'm going to translate and then

00:22:05.480 --> 00:22:09.980
Okay, well this will create
the path and return it.

00:22:10.070 --> 00:22:18.900
Every time I come through the UI saying
that I need to change the path,

00:22:18.900 --> 00:22:18.900
I have logic here to check for,

00:22:19.860 --> 00:22:23.620
Whether the path is in existence,
I'm being a little economical

00:22:23.620 --> 00:22:29.100
here by reusing the transform path
every time I want to change it.

00:22:31.400 --> 00:22:40.520
And in the DrawRect method,
I set the white color, fill up my bounds,

00:22:40.520 --> 00:22:45.680
set the black color,
set the untransformed path,

00:22:45.780 --> 00:22:52.190
set the red color,
and stroke the transformed path.

00:22:56.380 --> 00:22:58.860
What I did wrong in that demo?

00:22:58.910 --> 00:23:00.760
Well, I was drawing too much.

00:23:00.810 --> 00:23:03.620
To draw the white background,
I was actually filling my entire bounds.

00:23:03.830 --> 00:23:07.660
I should have just been drawing what
was handed to me in the drawRect method,

00:23:07.660 --> 00:23:10.200
the one parameter saying,
"I've got this rect.

00:23:10.200 --> 00:23:11.590
I need you to refill."

00:23:11.750 --> 00:23:31.620
I could also only have drawn
the parts that changed.

00:23:31.620 --> 00:23:31.620
I can find out what the bounds are
of those paths that I'm drawing.

00:23:31.620 --> 00:23:31.620
I can tell the app kit that I'm only
going to need to change this rectangle

00:23:31.620 --> 00:23:31.620
that the transformed path lies inside of.

00:23:34.800 --> 00:23:39.900
also made lame excuses because it's
just a demo and I don't have to be

00:23:40.060 --> 00:23:43.370
the best coding expert in the demo.

00:23:44.770 --> 00:23:52.630
I'm going to go to the next demo here
and show you that I can transform images.

00:23:56.010 --> 00:24:04.530
Just as readily as I can transform paths.

00:24:04.530 --> 00:24:04.530
Let me get some of this
stuff out of my way.

00:24:06.920 --> 00:24:11.920
So let's say I take an image here.

00:24:11.920 --> 00:24:13.800
And how many of you ever
wrote a raster rotation?

00:24:13.800 --> 00:24:17.240
Lot of work, wasn't it?

00:24:17.260 --> 00:24:20.550
Well, it's not a lot of work anymore.

00:24:22.090 --> 00:24:24.700
All I'm doing here is I'm telling
this image to composite itself

00:24:24.790 --> 00:24:29.100
in a rect and that rect is in
a rotated coordinate space.

00:24:30.060 --> 00:24:33.880
Now one thing that we can do in NSImage,
I mean people will tell

00:24:33.880 --> 00:24:35.610
me from time to time,
"My God, John,

00:24:35.710 --> 00:24:37.460
you know this is way too easy.

00:24:37.460 --> 00:24:43.090
You know, I'm a hardcore pointer chasing,
bit flipping, image processing guy."

00:24:44.000 --> 00:24:47.360
How can I get at all the
pixels in that image?

00:24:47.360 --> 00:24:50.240
Well, how do I compute the values
for every point in the bitmap?

00:24:50.240 --> 00:24:52.760
Well, we can do things like that.

00:24:52.760 --> 00:24:54.680
Here's one that I did.

00:24:57.320 --> 00:25:00.010
But I didn't want to do all
the work to rotate that raster,

00:25:00.020 --> 00:25:04.300
so I just did the work that generates
the gradient in a given 256 by 256 image.

00:25:04.300 --> 00:25:07.860
Let me show you the code that
you can use if you really want

00:25:07.860 --> 00:25:11.290
to be a hardcore pointer chasing,
bit flipping image processing expert.

00:25:12.330 --> 00:25:15.850
Here we are in transformed image.

00:25:20.110 --> 00:25:22.850
I wanted the ability for
NSImage to give me a gradient,

00:25:22.850 --> 00:25:27.030
so I wrote this method called
Pretty Gradient for the WWDC demo.

00:25:28.750 --> 00:25:30.110
Pretty much like I did
in the tinted image,

00:25:30.160 --> 00:25:31.200
I'm creating a new one.

00:25:31.200 --> 00:25:34.910
I'm giving it the size
that I've defined up here,

00:25:35.020 --> 00:25:35.680
256 by 256.

00:25:35.730 --> 00:25:38.560
Creating a bitmap image rep.

00:25:38.810 --> 00:25:43.410
As I mentioned, an NSImage object is a
container for image reps.

00:25:43.890 --> 00:25:46.870
Creating one by telling
bitmap image rep Alec,

00:25:46.870 --> 00:25:50.340
"In it with data planes,
I'm passing it no pointer here,"

00:25:50.340 --> 00:25:54.000
meaning you make the memory,
you give it back to me.

00:25:54.080 --> 00:26:00.000
Telling its size, I want 8-bit samples,
I want 4 samples per pixel.

00:26:00.040 --> 00:26:03.110
I'm going to create it in the
calibrated RGB color space,

00:26:03.110 --> 00:26:06.190
so I'm going to be able
to take advantage of color

00:26:08.800 --> 00:26:10.130
Bytes per row, you figure it out.

00:26:10.260 --> 00:26:14.010
Bits per pixel, 32,
I figured that out for you.

00:26:14.930 --> 00:26:15.700
Check this out.

00:26:15.740 --> 00:26:20.010
I've got a pointer to the raw bits.

00:26:20.230 --> 00:26:22.130
Again, I'm not dropping down
to core graphics here.

00:26:22.130 --> 00:26:29.580
This is plain old C bit twiddling,
pointer chasing, and then I'm going to

00:26:30.420 --> 00:26:33.640
Yes, you can directly get
at the pixels this way.

00:26:33.640 --> 00:26:36.280
And since I put this in an image
rep and put that in an NSImage,

00:26:36.330 --> 00:26:37.470
I get the rotation for free.

00:26:37.760 --> 00:26:41.170
I don't have to calculate
the image rotation.

00:26:41.600 --> 00:26:46.810
And again, returning it as an
auto-released instance because

00:26:47.520 --> 00:26:48.800
This is a convenience constructor.

00:26:48.800 --> 00:26:51.290
It's not an alloc method.

00:26:51.300 --> 00:26:52.160
It's not a copy method.

00:26:52.160 --> 00:26:57.930
It's not a retain.

00:27:03.880 --> 00:27:08.200
Okay, this is probably not the first
lie I've ever told any of you,

00:27:08.200 --> 00:27:12.820
but I'm just going to gloss over what
I may have done wrong in that demo.

00:27:14.510 --> 00:27:20.770
So now I'm going to talk a bit about
BezierPath and go get some of that water.

00:27:22.630 --> 00:27:26.760
So in the core graphic sessions they
would have told you about the CGPath

00:27:27.060 --> 00:27:30.500
and if you were a PostScript programmer
you would have constructed paths,

00:27:30.500 --> 00:27:34.200
you would have written yourself
little routines to draw arrow heads

00:27:34.200 --> 00:27:39.590
and character strings and so on,
all those good things.

00:27:39.630 --> 00:27:45.600
What we've given you in the app kit
is a path that encapsulates that.

00:27:45.690 --> 00:27:52.930
The BezierPath represents the
PostScript scalable vector graphics,

00:27:52.930 --> 00:27:57.600
core graphics, path, stroke,
fill drawing model.

00:27:57.620 --> 00:27:59.700
We have path construction
methods such as move to,

00:27:59.800 --> 00:28:02.670
line to, curve to,
things you'd be familiar with if

00:28:02.680 --> 00:28:05.470
you read the Adobe Redbook or the
Adobe Greenbook back in the day.

00:28:05.600 --> 00:28:09.600
We can also combine BezierPaths.

00:28:09.720 --> 00:28:12.600
This was something that wasn't actually
all that convenient to do in PostScript.

00:28:12.720 --> 00:28:15.600
So if you've got a path that describes
a character outline and an image,

00:28:15.600 --> 00:28:15.600
you can do that.

00:28:15.600 --> 00:28:18.590
Another path that describes
some other figure you've got.

00:28:18.900 --> 00:28:22.600
Well, with BezierPath you can
combine them and get one path.

00:28:23.670 --> 00:28:25.140
We have path attributes, of course.

00:28:25.160 --> 00:28:27.980
We've got line join, line width,
miter limit, flatness,

00:28:27.980 --> 00:28:30.820
which you'll all be familiar with
if you've written page layout

00:28:30.820 --> 00:28:32.510
programs and had to deal with them.

00:28:32.540 --> 00:28:34.600
And paths, of course, can be drawn.

00:28:34.600 --> 00:28:38.490
They can be filled with the current
color of the drawing context.

00:28:38.750 --> 00:28:43.630
They can be stroked with the
current color of the drawing

00:28:43.630 --> 00:28:43.630
context and the current line style.

00:28:44.700 --> 00:28:46.560
We give you convenience methods.

00:28:46.610 --> 00:28:49.280
These are class methods.

00:28:49.280 --> 00:28:52.100
So the idea in BezierPath I think
was basically that this is where

00:28:52.150 --> 00:28:53.680
you look for vector drawing.

00:28:53.680 --> 00:28:55.370
So maybe you're going
to construct a path,

00:28:55.530 --> 00:28:56.690
maybe you just need to draw a line.

00:28:56.850 --> 00:28:59.860
If you just need to draw a line,
you use the class method that says stroke

00:28:59.940 --> 00:29:01.460
line from a point to another point.

00:29:03.230 --> 00:29:08.060
Now, I like to add methods to
existing AppKit classes.

00:29:08.060 --> 00:29:10.130
I find it convenient.

00:29:10.130 --> 00:29:10.130
I like to

00:29:11.230 --> 00:29:15.520
To my mind,
it makes my code a little more reusable.

00:29:15.520 --> 00:29:20.030
In the kit, we've given you methods like
BezierPathWithOvalInRect,

00:29:20.260 --> 00:29:25.740
BezierPathWithRect, BezierPathWithGlyph,
and things like this.

00:29:25.800 --> 00:29:28.200
But I want something a little
more artistic than that.

00:29:28.200 --> 00:29:36.100
I'm going to add a method to
BezierPath to draw something that

00:29:36.140 --> 00:29:38.780
we often see in graphics textbooks.

00:29:45.460 --> 00:29:47.100
Isn't that pretty?

00:29:47.100 --> 00:29:48.830
Okay.

00:29:48.910 --> 00:29:50.830
It is, but I'm done with it.

00:29:53.570 --> 00:29:55.380
Now isn't that beautiful?

00:29:55.550 --> 00:29:57.960
I've got a polygon that I'm drawing
right in the middle of the view.

00:29:57.960 --> 00:30:00.940
I've transformed the coordinate space
to put it in the middle of the view.

00:30:01.000 --> 00:30:07.000
I can control the number of sides of
the polygon as you can clearly see.

00:30:07.850 --> 00:30:10.630
I control the rotation of the
polygon again as you can clearly

00:30:10.720 --> 00:30:13.040
see I can change its color.

00:30:16.140 --> 00:30:20.220
There, now that polygon is
showing in glorious red.

00:30:20.250 --> 00:30:22.110
Oh, I'm sorry,
I can also change the coordinate

00:30:22.110 --> 00:30:25.370
space so you can actually see
the polygon that I'm drawing.

00:30:27.650 --> 00:30:34.760
You can make it more sides and it
approaches a circle and less sides

00:30:34.760 --> 00:30:34.760
and it's not very round anymore.

00:30:34.860 --> 00:30:36.270
I can change its line width.

00:30:36.520 --> 00:30:40.160
This is just one of the drawing
attributes of the current,

00:30:40.340 --> 00:30:45.800
actually the line width is an
attribute of the path when you draw it.

00:30:46.220 --> 00:30:48.810
And we can get artistic.

00:30:51.700 --> 00:30:57.390
Now here's something
I want to warn you about.

00:31:02.340 --> 00:31:06.240
The cost of stroking a path
depends mostly on how many

00:31:06.240 --> 00:31:09.200
times the path crosses itself.

00:31:09.200 --> 00:31:14.730
To do the right thing for rendering this
path so that all of these points don't

00:31:14.730 --> 00:31:18.360
end up darker than they should be because
we're drawing over the same area twice,

00:31:18.460 --> 00:31:22.720
we've got to figure out each
of these intersections before

00:31:22.720 --> 00:31:25.400
we send it to the rasterizer.

00:31:25.480 --> 00:31:26.640
And as I go up,

00:31:27.100 --> 00:31:30.340
You are going to see this
getting noticeably slower.

00:31:30.480 --> 00:31:34.000
It's not going to break,
but it is going to slow down.

00:31:34.000 --> 00:31:38.140
This would go a lot faster if
I was drawing individual vectors.

00:31:38.140 --> 00:31:40.840
And they'll be telling you about
that in the graphics and imaging

00:31:40.900 --> 00:31:43.000
performance talk a little later on.

00:31:43.200 --> 00:31:49.430
You might actually see this
image on one of their slides.

00:31:49.470 --> 00:31:50.610
Let me point something else out here.

00:31:50.610 --> 00:31:50.610
As I move the size slider,

00:31:51.380 --> 00:31:55.560
The reason that that string art view
isn't just going outside the window and

00:31:55.560 --> 00:32:01.260
clobbering everything else is because
of the clip path that was set up for me

00:32:01.320 --> 00:32:04.060
when lock focus was called on this view.

00:32:04.110 --> 00:32:09.430
I can add to the clip path if I wanted to
draw this say behind a big blue X because

00:32:09.430 --> 00:32:12.300
I like string art and I like Mac OS X.

00:32:12.350 --> 00:32:17.670
I can add to the clip path by defining
a path and telling that path add

00:32:17.750 --> 00:32:19.260
yourself to the current clipping path.

00:32:19.960 --> 00:32:22.700
I'll point out another thing here.

00:32:22.740 --> 00:32:27.560
Notice that as I increase the line width,
I've got nice line joints.

00:32:27.630 --> 00:32:31.730
When I go to the meshed mode,
see these gaps?

00:32:31.940 --> 00:32:37.460
That's a consequence of the sequence
that I was adding these line segments.

00:32:37.530 --> 00:32:42.800
Where I'm creating the polygon when
I'm just drawing the perimeter,

00:32:42.800 --> 00:32:45.300
I'm actually going about it
slightly differently than when

00:32:45.300 --> 00:32:46.790
I'm drawing the meshed polygon.

00:32:46.810 --> 00:32:49.330
And let me show you the
code for that right now.

00:32:54.760 --> 00:32:58.220
Again, I like adding categories
to existing AppKit classes.

00:32:58.270 --> 00:33:01.250
I want BesierPath to be
able to do polygons for me.

00:33:01.390 --> 00:33:06.160
So I defined a category on
BesierPath called polygons.

00:33:06.210 --> 00:33:09.930
I tell it, give me a polygon with sides.

00:33:11.160 --> 00:33:14.960
I will draw this polygon in the unit
circle because it's so convenient for

00:33:14.960 --> 00:33:19.090
me to just change my coordinate space
to draw it at whatever size I need.

00:33:20.110 --> 00:33:23.160
And the math is pretty
straightforward here.

00:33:23.180 --> 00:33:25.110
Make a circle.

00:33:25.860 --> 00:33:30.250
has a loop that will take
a step out of the circle,

00:33:30.250 --> 00:33:34.160
go to the cosine and sine
of the current angle.

00:33:34.200 --> 00:33:40.580
I call line to point, line to point,
line to point, line to point until

00:33:40.580 --> 00:33:41.790
I'm done with the loop,
tell the path to close the path.

00:33:41.900 --> 00:33:46.020
The fact that all of these line 2s
happen in sequence means that the

00:33:46.020 --> 00:33:50.880
BezierPath knows that it should
apply its current line joint.

00:33:51.230 --> 00:33:53.610
Where I do the meshed polygon,
I'm going about it in a

00:33:53.610 --> 00:33:55.070
slightly different way.

00:33:55.130 --> 00:33:56.650
And you can see that the
sequence is move two,

00:33:56.650 --> 00:33:59.090
line two, move two, line two.

00:33:59.240 --> 00:34:03.380
Now the fact that I've moved and then
drawn the line means that it can't simply

00:34:03.380 --> 00:34:05.580
outguess me as far as line joins go.

00:34:06.930 --> 00:34:13.800
So that's why you saw those little
gaps when I'm in the mesh mode.

00:34:13.800 --> 00:34:17.580
And of course this is a
Cocoa app and it's so easy to

00:34:17.690 --> 00:34:19.790
do things like this that I do.

00:34:22.630 --> 00:34:35.780
Yell when you think you like the colors.

00:34:35.780 --> 00:34:35.780
Why don't we put red on blue?

00:34:35.780 --> 00:34:35.780
That'll make all of
our eyes really bleed,

00:34:35.780 --> 00:34:35.780
won't it?

00:34:35.780 --> 00:34:35.780
I haven't played with
this projector in my--ooh,

00:34:35.780 --> 00:34:35.780
ooh, that's harsh.

00:34:35.780 --> 00:34:35.780
Okay.

00:34:38.740 --> 00:34:44.770
didn't mean to build that.

00:34:44.770 --> 00:34:44.770
All right,
and let's go back to the slides, please.

00:34:49.690 --> 00:34:50.900
What I was drawing wrong this time.

00:34:50.920 --> 00:34:52.470
Again, I was drawing inefficiently.

00:34:52.510 --> 00:34:54.950
They'll tell you more about
this in the graphics and imaging

00:34:54.950 --> 00:34:56.600
performance talk after lunch.

00:34:56.600 --> 00:35:00.020
I was clearing and
redrawing the entire bounds.

00:35:00.120 --> 00:35:04.100
I should have just cleared the rectangle
that was handed to me in DrawRect.

00:35:04.150 --> 00:35:05.880
I did not reuse the BezierPath.

00:35:05.950 --> 00:35:08.800
I was getting a new one every time.

00:35:08.840 --> 00:35:12.760
I should point out it's not actually
necessary to throw BezierPaths away.

00:35:12.760 --> 00:35:13.670
They are mutable.

00:35:13.670 --> 00:35:15.040
You can change them.

00:35:15.040 --> 00:35:17.720
If you have a sequence of
points that you want to draw,

00:35:17.720 --> 00:35:22.270
you can always send a remove all points
message to a BezierPath and you won't be

00:35:22.270 --> 00:35:26.500
doing a round trip to the memory pool.

00:35:26.500 --> 00:35:30.110
As before, I made lame excuses
because it's just a demo.

00:35:31.840 --> 00:35:34.290
Thanks for remembering when
you're using the BezierPath,

00:35:34.310 --> 00:35:37.300
the rasterizer charges
by the intersection.

00:35:37.780 --> 00:35:40.880
I will also mention many
people have asked about the,

00:35:40.880 --> 00:35:46.980
you know, if you draw a line,
a vertical line from 0, 0 to 0, 10,

00:35:46.980 --> 00:35:50.620
you end up with a fuzzy gray line.

00:35:50.620 --> 00:35:50.620
Well, I'm not sure

00:35:51.670 --> 00:35:57.070
The fact is our coordinate system,
the integer values of the

00:35:57.120 --> 00:36:01.460
coordinate system land exactly
between the screen pixels when we

00:36:01.460 --> 00:36:06.210
first hand you a transformation,
the current device transformation.

00:36:06.310 --> 00:36:10.540
You can change this to make sure
that you get a solid black line.

00:36:10.820 --> 00:36:16.200
You can bump the coordinate
system just a bit,

00:36:16.200 --> 00:36:16.230
but I want to caution
you about that because

00:36:17.000 --> 00:36:22.490
We really want to head for a time where
we're completely resolution independent.

00:36:22.500 --> 00:36:26.080
I mean when we first brought
out the Macintosh we had 72 DPI,

00:36:26.080 --> 00:36:28.710
all displays were 72 DPI.

00:36:29.270 --> 00:36:33.140
The new titanium powerbook,
I think we just shipped, it's 104 dpi.

00:36:33.140 --> 00:36:38.790
And higher resolution displays
clearly are on the way.

00:36:38.820 --> 00:36:43.850
I'm not sure when we're all going
to have displays that have the same

00:36:43.850 --> 00:36:45.560
resolution as the original laser writer.

00:36:45.560 --> 00:36:49.200
But all of these little tweaks
that you might be doing to deal

00:36:49.360 --> 00:36:52.970
with today's device resolution,
check and make sure you

00:36:53.280 --> 00:36:54.830
really need to do them.

00:36:54.860 --> 00:36:56.810
In particular, right now,
check whether you're drawing for

00:36:56.810 --> 00:36:57.920
the screen or for the printer.

00:36:58.280 --> 00:37:01.040
You can ask the graphics context
whether you're drawing to the screen.

00:37:01.040 --> 00:37:03.920
And if you're not,
turn off your little tweaks.

00:37:07.610 --> 00:37:09.490
which brings me to the graphic state.

00:37:09.570 --> 00:37:13.110
So if you're an old PostScript hacker,
if you're looking for gSave and gRestore,

00:37:13.110 --> 00:37:14.620
this is where they are.

00:37:14.620 --> 00:37:17.800
They're in save graphic state
and restore graphic state.

00:37:17.800 --> 00:37:20.350
We can turn off the anti-aliasing
if you don't need it for your

00:37:20.440 --> 00:37:22.120
particular rendering situation.

00:37:22.120 --> 00:37:25.600
And you can test for whether you're
drawing to the screen and so on.

00:37:25.670 --> 00:37:29.250
I urge you to read the documentation
on the graphic state class.

00:37:29.320 --> 00:37:30.980
It can be convenient for you.

00:37:31.150 --> 00:37:34.180
You can make a lot of
changes to a graphic state.

00:37:34.350 --> 00:37:39.170
You can call save graphic state,
make a lot of other changes and pop

00:37:39.320 --> 00:37:44.600
back to your original conditions,
your previous coordinate system,

00:37:44.670 --> 00:37:46.760
your previous clipping path.

00:37:46.910 --> 00:37:49.810
Let's see,
what else is in the graphic state?

00:37:49.810 --> 00:37:53.660
There's coordinates, clipping path,
your current color and so on.

00:37:53.660 --> 00:37:58.520
And you can basically keep all
of these elements on a stack very

00:37:58.520 --> 00:38:01.100
conveniently with the graphic state

00:38:02.270 --> 00:38:06.410
We'll also point out that there are
a lot of functions in the AppKit.

00:38:06.570 --> 00:38:11.440
Not all Cocoa API is Objective-C API.

00:38:11.440 --> 00:38:15.750
And these C functions that we give you,
such as rectfill, rectfill list,

00:38:15.820 --> 00:38:18.480
and so on, the rest of the ones
I have on the slide there,

00:38:18.480 --> 00:38:22.350
these are probably the
fastest way you have to draw

00:38:22.960 --> 00:38:25.010
vertical or horizontal lines.

00:38:25.030 --> 00:38:27.560
They're very highly optimized
because we're using them in a lot

00:38:27.560 --> 00:38:29.020
of places in the kit ourselves.

00:38:29.880 --> 00:38:32.710
We also have geometry
convenience methods.

00:38:32.710 --> 00:38:35.980
DivideRect will take a
rectangle and give you back two.

00:38:35.980 --> 00:38:40.330
We can test for whether one
rectangle intersects another,

00:38:40.330 --> 00:38:45.000
whether a point is in a rectangle,
testing for equivalence.

00:38:45.150 --> 00:38:50.120
There's a lot of things there to
get you elements of rectangles.

00:38:50.120 --> 00:38:53.410
And I'd just like to say if
you think it ought to be there,

00:38:53.410 --> 00:38:56.720
if you think it's something
a lot of people have probably

00:38:56.720 --> 00:38:59.230
needed to this point,
look for it.

00:38:59.880 --> 00:39:01.040
It's probably there.

00:39:01.040 --> 00:39:05.160
I see a lot of places where people have,
you know, are referring to elements of a

00:39:05.180 --> 00:39:07.950
rectangle like myrect.size.width.

00:39:07.950 --> 00:39:10.780
They could have just
used nswidth to get it.

00:39:15.980 --> 00:39:19.170
We'll mention also the app kit
adds some methods to NSString.

00:39:19.180 --> 00:39:21.200
There's draw at point.

00:39:21.260 --> 00:39:26.880
It's really quite simple to just
put a label somewhere in your view.

00:39:26.880 --> 00:39:30.940
If I wanted to draw a little
coordinate pair and show you where

00:39:30.990 --> 00:39:33.720
the origin was in my string art view,
probably another two

00:39:33.740 --> 00:39:34.980
or three lines of code.

00:39:34.980 --> 00:39:38.890
I'm not going to go much into
text here because there's a

00:39:38.930 --> 00:39:40.360
whole session on that left to go.

00:39:40.360 --> 00:39:42.980
I certainly recommend that
you go to that session.

00:39:42.980 --> 00:39:44.880
The Cocoa text system is very powerful.

00:39:45.140 --> 00:39:50.340
It does a lot of really cool things
that are beyond the scope of this talk.

00:39:53.350 --> 00:40:00.470
I'll mention another class here,
the NSCell class.

00:40:00.520 --> 00:40:05.400
If you went to the controls talk,
they would have shown you

00:40:05.420 --> 00:40:06.610
how to do the clock cell.

00:40:06.890 --> 00:40:12.070
Most of the controls in the app
kit are just containers for a cell.

00:40:12.160 --> 00:40:15.820
This is why it's so easy for us to like
turn a slider into a matrix of sliders.

00:40:16.050 --> 00:40:20.270
We just change from a slider,
an NSSlider, which is a view,

00:40:20.400 --> 00:40:22.400
to an NSMatrix,
which is another view that's

00:40:22.400 --> 00:40:23.700
got a number of cells in it.

00:40:23.720 --> 00:40:28.800
A cell is something that draws in a view.

00:40:28.800 --> 00:40:32.910
A cell is also typically a responder.

00:40:33.050 --> 00:40:37.570
And you'll use a cell where you
don't want the overhead of an NSView.

00:40:37.660 --> 00:40:40.000
A cell doesn't need its
own coordinate space.

00:40:40.000 --> 00:40:45.330
We've got cell classes already
for drawing text and for drawing

00:40:45.330 --> 00:40:48.200
images and if you have a view
where you're going to need to let

00:40:48.200 --> 00:40:53.000
someone edit a little bit of text,
cell is a very convenient way to do that.

00:40:53.000 --> 00:40:55.510
If you just want to draw an image,
you don't want to bother

00:40:55.510 --> 00:41:00.000
with compositing an NSImage,
you can get a cell object, tell it,

00:41:00.000 --> 00:41:03.410
get this image, give it an image by name,
and give it a path that

00:41:03.410 --> 00:41:06.000
you got from an open panel.

00:41:06.000 --> 00:41:10.000
Cells can save you a lot of work.

00:41:10.000 --> 00:41:14.730
And I would like to urge you to check
out the documentation on NSCell.

00:41:15.530 --> 00:41:19.390
Use them where you can.

00:41:21.390 --> 00:41:25.530
So you can use a cell for drawing lines,
for editing text.

00:41:25.590 --> 00:41:26.420
You can reuse cells.

00:41:26.620 --> 00:41:30.910
In fact, you can use a cell multiple
times in the same draw method.

00:41:31.130 --> 00:41:33.580
In fact, in our table view,

00:41:33.970 --> 00:41:38.160
When you've got 10,000 things to draw,
well, it would really be expensive

00:41:38.160 --> 00:41:40.060
to have 10,000 subviews.

00:41:40.110 --> 00:41:44.540
So what we do in the table view is we
use the same cell for every column.

00:41:44.790 --> 00:41:47.100
We just change the text that
it's going to draw and say,

00:41:47.100 --> 00:41:48.070
"Draw yourself here.

00:41:48.190 --> 00:41:49.880
Change your text, draw yourself here.

00:41:49.880 --> 00:41:53.030
Change your text,
draw yourself here." It's a very

00:41:53.090 --> 00:42:00.330
powerful design approach and would
certainly be worth your while

00:42:00.330 --> 00:42:02.370
to check out how to use those.

00:42:04.280 --> 00:42:09.240
A cell is often a good starting
point for your own custom drawing.

00:42:09.240 --> 00:42:12.930
And in a cell class,
it's very handy sometimes to hijack

00:42:13.070 --> 00:42:15.200
the inherited drawing behavior.

00:42:15.660 --> 00:42:21.330
And I'm going to go back to a demo
you just saw before and show you

00:42:21.340 --> 00:42:23.710
something about the code in there.

00:42:28.300 --> 00:42:35.300
Okay, let's go back to my
transformed image code.

00:42:35.300 --> 00:42:41.290
Close this project.

00:42:41.300 --> 00:42:48.820
Wrong project, that's a tinted image.

00:42:48.820 --> 00:42:50.890
Transformed image, here we are.

00:43:06.060 --> 00:43:08.970
Now first I'll show you my transformed
image view that was drawing the

00:43:09.010 --> 00:43:11.180
rotated image is an NSImage view.

00:43:11.180 --> 00:43:13.150
That means I didn't have to
write the code that accepts

00:43:13.330 --> 00:43:14.900
dragged images from the finder.

00:43:14.900 --> 00:43:19.560
It means I didn't have to write the code
that drew the bezel around the image.

00:43:20.800 --> 00:43:22.860
All I did with the transformed
image view is I've added a

00:43:22.860 --> 00:43:27.900
couple of instance variables,
the rotation and the scale.

00:43:29.500 --> 00:43:33.500
I added a method to show the
gradient for the splash factor.

00:43:33.500 --> 00:43:39.490
And let's see,
going back to the implementation

00:43:39.490 --> 00:43:41.200
of transformed image view.

00:43:44.440 --> 00:43:47.980
Here's a place where I'm
lying to an object in the kit.

00:43:48.070 --> 00:43:52.830
I am telling the cell that it had,
"You don't have an image.

00:43:52.980 --> 00:43:57.260
Draw yourself." That gets me the bezel.

00:43:57.650 --> 00:44:04.230
It doesn't leave the image un-rotated
for me to have to deal with.

00:44:06.190 --> 00:44:08.820
Changing my coordinates base.

00:44:10.300 --> 00:44:12.740
Let's see.

00:44:12.740 --> 00:44:14.940
Building the destination rect
of where to draw the image.

00:44:14.940 --> 00:44:16.300
So I lie to the cell.

00:44:16.300 --> 00:44:17.840
I say you don't have an image.

00:44:17.880 --> 00:44:19.300
I make it draw itself.

00:44:19.350 --> 00:44:21.640
I figure out where
I want to draw the image.

00:44:21.700 --> 00:44:27.190
I draw the image there,
set the bounds rotation back,

00:44:27.310 --> 00:44:29.520
Tell the cell, oh, by the way,
you do have an image after all,

00:44:29.520 --> 00:44:31.680
but this won't make it get drawn again.

00:44:31.680 --> 00:44:36.030
So the upshot is by just using
the existing machinery of

00:44:36.100 --> 00:44:40.770
the cell in the NSImageView,
I've saved myself the work of having

00:44:40.770 --> 00:44:44.200
to deal with storing an image,
having to deal with

00:44:44.420 --> 00:44:47.260
accepting image drags,
or having to deal with

00:44:47.260 --> 00:44:48.820
drawing that bezel.

00:44:48.860 --> 00:44:52.220
If there's some class in the kit that's
already drawing some of what you need,

00:44:52.280 --> 00:44:56.300
use that existing drawing
behavior and then modify it.

00:44:56.300 --> 00:45:01.210
So, let's, back to the slides please.

00:45:05.140 --> 00:45:09.330
Now I've left us a pretty long time for
the Q&A because somehow I managed to

00:45:09.440 --> 00:45:12.090
rope most of the AppKit team in here.

00:45:12.090 --> 00:45:15.080
And let me just sum up here and say,

00:45:15.340 --> 00:45:18.700
We saw how to draw using the
classes in the Cocoa Framework,

00:45:18.800 --> 00:45:22.400
how to get some fairly sophisticated
effects with not a whole lot of code,

00:45:22.400 --> 00:45:25.650
and the whole idea of Cocoa coding,
use the least amount of

00:45:25.690 --> 00:45:27.170
code you possibly can.

00:45:30.670 --> 00:45:32.530
So there's the point of the talk.

00:45:32.630 --> 00:45:36.460
Do the simple things the simple way,
and if you want to do the hard things,

00:45:36.560 --> 00:45:36.930
you can.

00:45:42.290 --> 00:45:46.920
There were many complaints about
the Cocoa documentation over the

00:45:46.920 --> 00:45:51.890
last year and they were fair,
but I'm happy to say that most of

00:45:51.890 --> 00:45:54.200
this is pretty much dealt with now.

00:45:54.200 --> 00:45:57.200
We've got a lot of new
documentation that's topic oriented.

00:45:57.200 --> 00:46:01.200
I urge you to go have a
look at that documentation.

00:46:01.200 --> 00:46:06.070
There's an excellent section
on the view hierarchy and on

00:46:06.070 --> 00:46:08.700
drawing in Cocoa in general.

00:46:08.700 --> 00:46:11.120
It should be on all your Jaguar disks.

00:46:13.700 --> 00:46:32.640
For more reading, Learning Cocoa,
I was one of the technical reviewers

00:46:32.640 --> 00:46:32.640
on Building Cocoa Applications.

00:46:32.640 --> 00:46:32.640
This was a wonderful book.

00:46:32.640 --> 00:46:32.640
It's got a lot more detail on all of the
things that I just talked about today.

00:46:32.640 --> 00:46:32.640
You all got a free copy of it, I presume?

00:46:32.970 --> 00:46:38.010
and besides the Garfinkel-Mahoney book,
the developer documentation available

00:46:38.010 --> 00:46:39.900
on the web and available in the help
folders on the systems you have.

00:46:39.900 --> 00:46:46.090
And if you want to go
to a class about this,

00:46:46.150 --> 00:46:50.140
you can contact us at train.apple.com.

00:46:50.140 --> 00:46:54.590
So here's the road map which we've
been through nearly all of it.

00:46:56.390 --> 00:46:56.730
Two left.

00:46:56.890 --> 00:46:58.340
We've got the Cocoa Text session.

00:46:58.340 --> 00:47:03.700
There is a lot in Cocoa Text.

00:47:07.090 --> 00:47:10.480
I don't know how I can
say it more than that.

00:47:10.630 --> 00:47:14.000
Japanese text input, you get it for free.

00:47:14.000 --> 00:47:17.810
A tremendous amount of sophisticated
typography functionality,

00:47:17.810 --> 00:47:19.020
you get it for free.

00:47:19.120 --> 00:47:23.120
It's all described in section 306.

00:47:23.120 --> 00:47:27.860
And we have the feedback forum
for Cocoa coming up today at 5:00.

00:47:28.340 --> 00:47:30.640
So I hope you'll catch
those sessions as well.

00:47:30.640 --> 00:47:32.820
We're interested in what you
have to say about these kits.

00:47:34.870 --> 00:47:35.590
Who to contact?

00:47:35.690 --> 00:47:41.610
The Cocoa Evangelist is my colleague
Heather Hickman sitting right over there.

00:47:41.910 --> 00:47:48.060
Cocoa Feedback, we do read this mail at
cocoafeedback@group.apple.com,

00:47:48.060 --> 00:47:51.070
and there are a number of
excellent mailing lists

00:47:51.070 --> 00:47:52.840
available at mail.apple.com.

00:47:52.840 --> 00:47:57.760
The one most pertinent to
this talk is the CocoDev list.

00:47:57.800 --> 00:48:03.420
We've got quite a lot of people on there,
people who are just beginners,

00:48:03.420 --> 00:48:06.660
people who have been doing
this for ten years as I have,

00:48:06.660 --> 00:48:10.220
and I will also mention that a
lot of the people who work on the

00:48:10.220 --> 00:48:12.710
kit read that list frequently.
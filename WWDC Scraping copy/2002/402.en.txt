---
Title:  J2SE Mac OS X Platform Overview
Year:   2002
Web:    https://nonstrict.eu/wwdcindex/wwdc2002/402/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Ladies and gentlemen, please welcome Java platform engineer Scott Adler. Good afternoon. So, I'm Scott Adler. I'm from the Java Platform Classes team. And today we're going to talk about the Java Platform and just a general overview of what's in it. So what we're going to actually talk about today.

First is an overview of the Java 2 platform. I'm not sure how many of you are actually familiar with it, but we're going to talk a little bit about what's in the Java 2 platform itself. Then some of the Mac OS X integration issues, things that you can do to actually make your integration with Mac OS X when you're doing a Java 2 application, make that experience better.

We're also going to talk a little bit about where you can find all the documentation for this stuff. And then finally we're going to talk about the Java 2 Standard edition version 1.4 and the features that are in that and the things that you'll be able to take advantage of when we get to 1.4.

So you see this slide a lot. This is the slide that is the Apple frameworks, and... Java is one of the frameworks that we have. Now, there's a little bit of confusion when people talk about Java. And this has been from the very beginning of Java that the word Java means probably 600 different things. It means coffee. It means a language. It means a framework. It means the beginning of this weird language called JavaScript that has nothing to do with Java.

There's like all these things that are the meaning of the word Java. And what we're talking about when we say frameworks is we're talking about the Java 2 platform as a framework for you to use to develop applications. Java can also be used to develop applications that are run using the Cocoa framework. But that's the Java language. That's not the Java platform. So you can use the Java language to get access to Cocoa. But what we're going to talk about is the Java platform itself.

So here's the overview of what the standard edition is. So a little before we get into specifically the standard edition, we have a bunch of cross-platform editions. This is actually the foundation for all the editions. We've got the Java language that is on top of the Hotspot virtual machine, and then there's the KVM, which is the tiny little VM that's used, and there's also a card VM. So starting on your right, There's the Java Card Edition, which is this tiny little VM that runs on top of smart cards.

Then next we have the Micro Edition, which is a VM that runs inside of lots of household appliances, your cell phones. If you're in Japan, you have a G3 phone. It's usually running something on the Micro Edition. Even I've heard of cases of washers and dryers that have VMs built into them.

Then we have the Standard edition, and this is where we fit in. We're actually providing a Standard edition implementation. We have been since 10.1. Actually, since 10.0 we've been providing it. And we've also been providing a Java-- not Java 2, but a Java Standard edition on earlier Macs, too. And this is so you can deliver your applications, and they can be cross-platform applications. They just--their applications just run.

And finally there's the J2 Enterprise edition, which there's a lot of confusion on what's actually involved in here. We actually have an enterprise product called WebObjects that you've probably heard a lot about and there are a lot of good sessions on it. And that enterprise product does a lot of the same things that J2EE does.

It actually has many of the same features and some of them are directly out of the J2EE spec. There also are third parties that have brought their J2EE platforms, their certified platforms, to our platform. So things like Lutris and Primati have already brought certified J2EE platforms. And I think Ted Goldstein mentioned a couple others that are pure Java implementations, things like Orion and I can't remember all the names right off the top of my head. But there are a bunch of J2EE certified platforms. So they all run on top of our Standard edition. So you can use those J2EE platforms to deliver your enterprise platform. edition things on top of our standard edition.

So what exactly is the Standard Edition? So if we look at the very bottom here, we're going to start talking about all the different OS platforms. And this is just all the OS platforms that we run on, that Java runs on. Mac OS X is right there. Linux, Windows, Solaris, and there's other ports that have happened.

So on top of that, you have the Java Virtual Machine. And this is the stuff that runs Java bytecodes. So you've got the Hotspot compiler, you've got the Hotspot Virtual Machine. They're basically one big thing that compiles your stuff as needed, and Hotspot has all these really cool features built into it to determine when it's supposed to compile things and keeps track of how often your routines are run so that it doesn't waste time compiling something that's only run like ten times.

On top of that are the core Java APIs. And these usually correspond to things like Java.util, Java.security. And there's so many APIs in here. This has been developing for years. There are utility classes to let you do things with all your typical string manipulations, string tokenizers that are built in. There's a whole collections framework, so you don't actually have to rewrite your B-tree sorting or your red-black trees or whatever. You just use the collections framework.

There are tested sorting algorithms in there. There's iterators that work on top of the collections framework. There's locale support so that you can actually have resource bundles for different locales. There's a whole Java beans framework that lets you build bean application components and use them inside of other applications and use things like reflection to figure out what's going on inside of those beans. There's built-in networking support, so you can just open up connections, use print writers.

There's a whole suite of things you can do just in the core API. And this is common across all of the Java platforms. Then there's a set of integration APIs. And these are things like RMI, remote method invocation, JDBC, which lets you get to database connectivity, the Java naming and directory interface, and then Corba. So all these are things that you integrate with your existing enterprise systems. And things like RMI you can use to actually write distributed applications with just using remote procedure calls. You don't have to do any funky transport. That's taken care of for you underneath.

And one of the more important things for desktop applications is actually having a UI toolkit. And if you look at the top of our UI toolkit, we have Swing and AWT as the very top level of the UI toolkit. Now, AWT, if you don't know about it, AWT is the Abstract Windowing Toolkit.

And this is a--it's a platform-independent definition of all the GUI objects that you could have on different platforms. And then what each platform vendor does is they develop interface elements that match those specifications. So it'll be things like a button and a window and very typical things, but sort of least common denominator.

And we've implemented those things. And then Swing is actually what is called a lightweight framework. And that is--in Java, everything is rendered, and it's more complex controls because you don't have to worry about the differences between the platforms. You can do things like different-looking buttons than what might be on Mac OS X or might be on some other platforms.

And it's all done inside of Java, so it's okay. You can--you know, we can handle the rendering. And all this lives on top of Java 2D. And if you went to the graphics session this morning, Java 2D is this really robust graphics engine. It lets you do things like translucencies, general paths, strokes on paths, gradients. There are just so many things you can do in Java 2D.

And Swing actually uses Java 2D to do a lot of their graphics manipulations and things. And then we also have things like sound input methods for internationalized text, so you can actually get--you know, get things out of the OS so that people can enter more complex characters. And then accessibility, which is involved with focus management and all the things you need to do to use a computer if you're not physically able to use a mouse or hit the keys.

And you saw some of that in the keynote, and Java has a lot of that built in and has a lot--has had that built in for a long time. And then at the very top are Java-specific deployment options. We'll talk about this a lot in this whole conference. Java Web Start and the Java Plugin are two ways that actually are unique to Java in the way you can deliver Java applications and applets.

So that's basically an overview of the entire Java 2 Standard edition, the way we ship it now, and we're going to talk a little bit about Mac OS X integration. And the most important thing about our Mac OS X integration is, simply put in this slide, is Aqua. So what we've done is we've spent a lot of time to get Aqua to look good in Java, because we want your Java applications to look just like every other application on the Mac.

So we have the Mac OS X look for Java. Of course, all of our AWT peers, all of our AWT widgets, and they're called peers, are already in Aqua, because a lot of times we're just using the native windows. Sometimes we use some of our own custom things, but usually we're using the native windows. So you get native windows, you get native menus, you get native dialogues and things like that. Swing itself, we implemented the... Aqua look and feel.

So Swing has a pluggable look and feel that you can implement your own. There's already one that's a Java look and feel, which James Galsing was talking about was designed by bankers, so we don't like it so much. And there's a... On other platforms, you can actually have specific look and feels, like on Windows, there's a Windows look and feel, which looks just like that. So if you're on Windows, you can run that.

And there's a motif look and feel, so if you want to feel like you're back in college running on your X Windows thing, you can... You can use that. But we have the Aqua look and feel. It's on by default. You can... It just works. You get it with your applications. It has things like the default button is throbbing, and so when you hit return, it'll go there, and all the translucencies just happen for you automatically.

And then we're using Quartz 2D for the graphics. So you actually get all of our anti-aliasing that's built into Quartz. You get our font support. There was some talk about how we actually support things like TrueType hinting because that's built into the Quartz font mechanism. And that's something that's a new feature for 1.4 that we already have in our 1.3 implementation.

So when we talk about actually more detailed integration, we've got a couple different categories. One of them is application-specific. And application-specific integration is actually a big topic, and it's so big that we have a whole session on that. And that's going to be this afternoon. It'll show in the roadmap.

But there's an entire session that talks about things like all of the Mac OS X-isms that people don't want to see that this was a cross-platform thing that you brought to the Mac or that you used Java. So they want the menu bar to be in the right place. They want you to use the About and the Quit of the File menu instead of having a File Exit menu because that's foreign to most Mac users.

So there are a lot of little things you can do. Now, you don't have to do them, but we really encourage you to do these because Mac users are very discriminating. And if they see the option between something that looks like a Mac application and something that looks like they just downloaded it off of freeshareware.com or something, they're going to choose the one that looks like a real Mac application. But we want to let you be able to do that. So we have a lot of ways that you can customize your Mac application, your Java application, to look just like other Mac OS X applications.

And then there's browser-based integration, which means you're developing an applet, and you want to ship it to people through the web. And what are all the issues when it comes to Mac OS X browsers and applets and applet support? There's a lot of information on this, and we're having a Java in the browser session right after this one. And there's a lot of information about, well, we're using Aqua widgets, so those look different in the browser.

Or we're not sure what VM exists, because on other platforms there could be 30 different VMs installed, or there could be two VMs in the browser, one shipped by the OS vendor and one shipped by someone else. And so we've eliminated a lot of that complexity. But there's still a question of, well, I've written my HTML for one site. How do I deal with it on the Mac? And so this session will actually clear up a lot of those issues.

There's also packaging and deployment issues. You don't want to just ship an application as a JAR file to end users. You could. And JAR files, if you don't know what they are, they're actually the container for Java applications. And we have some stuff in Mac OS X so that you can actually just load a JAR file off the web and double-click it and it'll launch. And it'll just work. It'll show up in the dock as an application and things like that. But it's not the ideal experience. So there are things you can do to package and deploy your application, and we'll talk about that a little more.

There's also JDIRECT and JNI, and we'll get into that more again in the application-specific, the tailoring application session. But JDIRECT and JNI allow you access to native libraries. And JNI is the one that is Java across all Java implementations. JDIRECT is some things we've implemented to make life easier for you if you want to do native implementations, but you don't have to use it if you don't want to. And then we also have the Mac OS X Java Toolkit, which is called the MRJ Toolkit. And this has a lot of things for dealing with files and dealing with other OS-specific things. It's Java classes that they get to Mac-specific features.

So when we talk about deployment, I've mentioned some of these things, but there are three ways you can deploy. You can deploy as an application, which means you bundle all of your Java-specific things inside of an application bundle. And so that is recognized by the system as an application. You have an icon.

You can do things like register for file types and all the typical things you'd want to do as an application. There are also some really good tools from Install Anywhere, Zero-G. They make Install Anywhere and Power Update, which are tools that let you create these applications and install them.

But they also are themselves applications that run on our platform. So you can see things like JBuilder, and there are a whole bunch of applications of ThinkFree. They bundle their applications as a normal application, and the only way to tell that it's Java is to maybe look at top or something like that or try to get a stack trace out of it or something.

Then there's Java Web Start. And what Java Web Start is, is it's a technology to deploy your applications over the web. And this is full-fledged applications that you're going to put on a website somewhere. And you just click on a link and it downloads information about that application. Then it'll go download all the jars and everything.

And then you'll have a full-fledged application sitting on your system. And it's a really good deployment mechanism. It has a lot of advantages for things like, if you're going to update your application, you just update your jars on your website. And when people run their local application, it goes and pings your website and sees, has this jar changed? If it has, it'll download the new jar. And this is available on Windows, too. So it's sort of a just universal way to deploy applications over the web.

And then finally, there's applets and plugins, which applets, not surprisingly, are the most common way people see Java on Mac OS X, and probably in the world. You run your web browser, you go to a website, and some little thing pops up that animates around, and a lot of times that's in Java. And also people have a lot of games.

If you go to Yahoo and Yahoo Games, there's hundreds of thousands of people playing Yahoo Games every day online with each other. And it's just amazing. Those are all Java applets that are running. So there's just so many Java applets that are delivered that way, and they're easy ways to deliver small programs, especially because it's just in the browser. And on Mac OS X, we have 1.3.1 right built in, so you can do some cool things in applets.

So now to show a little bit about what you can do with our existing Java on Mac OS X, I'd like to bring up Tyler Stone from our Worldwide Developer Relations Group to show us a demo of a product called eBeam. Tyler? Hey, Scott. How you doing? Thanks. I haven't actually done anything yet, but thanks. How's it going? Not bad. Not bad. So what are you going to show us here? I wanted to talk to you a little bit about eBeam. eBeam is a very fascinating product by the folks from Electronics for Imaging, EFI. Screwed up their company name.

They're known for the Fiery print process, so a lot of you have heard of EFI for that. But eBeam is a new product they've come out with. It's a whiteboard capture hardware and software application. So you take this little receiver, you attach it to any standard whiteboard. It attaches via USB to your Macintosh. You take any standard whiteboard pen. If I take the clip off, you'll see that. And you take these whiteboard pens and you put them inside a transmitter. Then, any time you write on your whiteboard, it'll actually transmit through to your Macintosh, like so.

So that's really cool, but why are you showing this at the Java overview session? Oh, this isn't cool USB products overview session? No, no. No, I'm showing it in this particular session because the application that you see running up here is indeed a Java application. We see a lot of applets, but I'm kind of an old-fashioned tofu and potatoes kind of guy.

I like shrink-wrapped applications. And that's what the folks at eBeam and EFI have done using Java. They've created this application. It has all the Aqua look and feel in it. It has standard menu bars. It has a lot of complex functionality, and it's done almost completely in Java. And this is running on our existing Mac OS X?

It's available today. You can purchase it from the folks at eBeam. It runs under Mac OS X, right, X1 right now. So what else can we do with this? Well, of course, you've seen us write something on here. Of course, a whiteboard product wouldn't be a whole lot if it didn't have an erase function as well. So you can go ahead and erase as well.

In fact, why don't we play a little game? Do we have time to play a little game? Yeah, but here's the problem. So you work in worldwide developer relations. I'm actually a developer. So we're in different buildings. Yeah, we are. There's like an entire gap of a couple hundred feet between us, I believe. So if we wanted to actually play this game at the office, not here up on stage, how would we do that?

Well, you know what? One of the neat things about the eBeam product is that it has meeting functionality built into it so that you can connect to the eBeam application directly. So you can connect to a meeting that I broadcast from my whiteboard over the Internet. Okay. Let's go ahead and take a look at that. I should stay on demo machine one.

Thanks. So what I do from any standard whiteboard session, so I've been writing up on the whiteboard, I decide I need to bring you in via a conference call, for instance, is I come up here and I say share meeting. Click on share meeting. EFI hosts some servers that I automatically can connect to. I go ahead and name my meeting. I have to stop you for a second.

I just have to say, I know this isn't in our script, but this is really cool. He's going on script. Because the cool thing about this is this is all a swing window. This is all native stuff going on here. And this looks great to me. I mean, I see all these little touches they did, but you wouldn't know that this is swing running here. So I just think that's really great. And I wanted to comment about that.

Oh, no problem at all. So I'm going to go ahead and share this meeting. I've called it the 402 session demo. It's a pretty original name. It goes out to the internet and actually starts broadcasting everything I write on the whiteboard. So if we switch over to demo machine 2 now. Okay, so... and Scott Adler: So click on Join Meeting. It goes out to the same server and you should be able to join 402 Session Demo. Okay, so this is actually live, right?

[Scott Adler]
This is live. So if you guys have eBeam on your machines, you can join our session, too, if you want. If you go to www.e-beam.com and download the software real quick, you can join in.

[Transcript missing]

You get the pulsating default button.

I believe those are called throbbing, actually. Throbbing, pulsating, whatever. You get the nice pinstripe background automatically. You notice the menu bar is in the right location. All of our drawing is anti-alias by default. All the text is anti-alias by default. And so none of this-- we didn't have to do any extra work to get these features.

Then we did do a little bit of tweaking for OS X. So in the Applications menu, we do have our preference item that actually appears and works like it's supposed to. And then finally, we were able to leverage QuickTime for Java so that this meeting that you and Tyler have been working on so that you can prove that you beat Tyler, you can actually export this as a QuickTime or digital video file format and save that as an iMovie to share with all your friends at Apple. Cool. That's great. Well, thanks a lot. Thanks.

So if we can go back to slides. So the next thing I want to talk about is a big question that a lot of developers get. That is, they don't really know that much about Mac OS X specifics, and they're big Java developers from whatever other platforms might be coming from. Or the other way around.

They're Mac OS X developers, and they don't know what's going on in Java. And this is the question I get, is what do you actually need to develop Mac OS X? Develop applications using Mac OS X and Java. And the simplest answer I can give them is documentation. And so to talk about that, I'd like to bring up Bodhi Gerfen from the technical publications group.

Well, good afternoon. I'm Bodhi. And as the screen says, I work in technical publications. I wanted to give you guys a little bit of insight today in what we've been doing in tech pubs, what we plan on doing in the future, and also for those of you that don't know or may be new to the platform, where you find the technical documentation. So to prove that, I put it on the slide. So where are we today? What have we done with documentation up to this point? Well, we saw in the Hangman demo that MRJ is not there anymore.

MRJ was around a long time. We saw the other day in Steve's demo. Mac OS 9 is dead. Well, we've been working hard to update our documentation to Mac OS X. Mac OS X has been out a little over a year now. And we've been, first of all, working on updating our website to bring it up to date with what's out there today.

You'll see things on the website today that explain some of these little nuances that Scott's mentioned about J2SE on Mac OS X. We have revised the release notes format. When Java first shipped on Mac OS X, the release notes, since it was so different than Mac OS 9, had all the information in it.

Since then, we've listened to you and we've tried to pull things out of there. Now the release notes are release notes. And more than that, we address some of your issues. We've broken the release notes out into individual issues that you've had to kind of give you, to show you what we're doing inside Apple to make Java the best on Mac OS X. We've updated, we have a document on our website that's Java development on Mac OS X.

We've updated that for Mac OS X 10.1, Mac OS X version 10.1, so that the examples in there, the little tutorials, they apply to the current version of Java. And we've added some more Java-specific information to the project builder help. So if you are using project builders, your IDE, we have some details in there now on how to do those little things that might not be obvious at first glance.

So that's what we've done this past year. Where do we want to go from here? Well, we want to make sure that you always have the current version of Java doc on the system, so that if you are developing on your laptop, walking around, it's all right there. We want to work harder to integrate the documentation with the developer tools.

Things like the class browser, things like project builder. If you're a Cocoa developer, you're familiar with the fact that you can go in and select a class, and you can open up the documentation right in project builder. We're looking at things like that. We want to see if we can incorporate that also for you. We're working on some more topic-based tutorials to give you an idea of how do I put the name of my application up in the menu bar, or how do I implement a quit handler, an about handler. Simple things for you if you're not used to them.

We're working also on some tutorials for beginning and more advanced developers to walk you through some of the things that might be a little different on Mac OS X. And of course, this is Apple. There's other things we have in mind that we're scheming about that we're working on. So, we've seen where we are, where we're going, and where do you find this stuff?

Well, the best place to find it is online at developer.apple.com/techpubs, and there is a Java section in there. Of course, we also give it to you with the developer tools. We install it when you install the developer tools in developer documentation Java. So you'll find a snapshot of what's on the web page there. Also, the Java documentation is available in developer help center. If you're using project builder, under the help menu, there's an item for developer help center.

So if you look in there, you'll see the Java section. And if you want to see what's new, of course, check developer.apple.com/dev notes, and that'll tell you what we've got out there new. So we've got some new things coming in light of the upcoming Jaguar release, and of course, the 1.4 release will be real exciting too. So thanks very much. Scott?

Thanks. So the rest of the time here we're going to talk about the Java 2 Standard edition version 1.4. And we're working on 1.4. We want to have 1.4 available for you. So we'll talk a little bit about what things are in 1.4 and what things you can take advantage of today and what things will be coming in the future.

So in order to talk about 1.4, we sort of have to talk about 1.3 and compare it to 1.4. So this is 1.3, very similar to what I showed before. And if you look, you know, there's a lot to it. But when we talk about 1.4, we can add the brand new packages here. So these five packages are brand new. They haven't existed before. They've bundled in things like XML, new IO, logging, a lot of very new functionality in actual whole new packages.

All of these packages have actually changed significantly and have had user level or developer level APIs added to them. So they've actually had large changes inside of these packages. And even more is that all of these packages, which is the entire Java platform, has actually been changed with bug fixes and updates.

There's actually, I think someone looked at the code and they said there's over 40% more code in Java 1.4 than there was in 1.3. So that's actually a big increase because Java code is pretty big, the amount of stuff we get from Sun. that has new functionality and new features.

So we'll talk a little bit about what are the additions to the Java 2 Standard edition. And we grouped them into three areas. There's the UI frameworks, there's the enterprise frameworks, and then there's the core frameworks. So we're kind of going in the reverse order. We're going from the top down.

So if we start with the UI frameworks, there's AWT, there's Swing, there's Java 2D, and there's printing. We've talked about those before. We'll go into some specifics on each of those. So in AWT, some of the major changes that have happened in there is there's headless support, which is if you're going to run on a server or somewhere where you don't actually want to draw to the screen, if you have like a daemon mode or something like that, you can actually still do AWT commands and generate images or whatever you might need to do in AWT without actually having a screen.

Or a screen process running. There's full screen exclusive mode API, and this is an interesting thing. This is mostly designed for game developers, but it could be done for kiosks and other things like that where you actually take over the entire screen. Now, it's interesting because we actually have this functionality today. If you use QuickTime for Java, you can actually take over the entire screen. And if you saw the demo in our keynote where we had that getAMP thing, that was, I think, using QuickTime for Java to take over the screen. Okay.

And this is going to be built into 1.4, so there are going to be a lot of people writing games and other things that just take over the whole user interface of the computer. And it's really fun for games and for kiosks, specifically. There's also enhanced frame support. You have things like being able to remove decorations from frames. Frames in Java lingo are Windows and things like that.

There's a lot of things you can do for dynamic layout of frames. There's support for a mouse wheel. So on a Mac, if you have a mouse with a mouse wheel that you've bought, you can do that. You can then use that and it'll actually be supported in your applications. And then there's also a new focus architecture.

And this is actually a big change from 1.3. And 1.3 had some problems in focus in that there was a different focus architecture between AWT and Swing, and there's also a different focus architecture between what the platforms have available and the different OSes. So it got really confusing.

Like, what did activation mean? What did moving around between your components -- how did you manage that? There's actually a brand new focus architecture, and we'll show a little bit about that. And of course, there's a lot more. We're not going to get into every detail of this. There's an entire conference that Sun puts on that's all about these kinds of things, and we're just trying to give you an overview of what things have changed.

So now I want to give you a demo of what we were talking about with the focus policy. One thing I have to say with this demo is that this is running on a development system. It's actually running off of my PowerBook's hard drive. So it's a development system that we're working on that we're not releasing, but it has some of the 1.4 features in it. And we're going to show a little bit about the focus policy. And yeah, this is my computer. Nobody's computer.

And so what we're looking at here is a little demo I made to show off how to focus it. And I sort of stripped it down just to show you how it's built up. And this is just a big swing container with a bunch of J buttons. You kind of tell that's where all the buttons are located. And if I... and David Hau.

Thank you. So, I'm going to go ahead and show you a little bit of the demo. Now, that's all well and good. You can do this on our Java stuff today, and I actually did this first on our 1.3.1. But now when we went to 1.4, we wanted to look at what does the new focus architecture do for you.

So, what I wanted to do is I wanted to say, okay, I want to be able to just, not using the mouse, be able to tab through the components in this view. Now, if I were to use the focus architecture that's built into 1.3, and I'll actually switch to that right now, and if you see on the very top here it says it's using the 1.3 layout for the focus architecture, and I'm going to go ahead and do that. And I'm going to go ahead and do that. And I'm going to go ahead and do that. And I'm going out focus policy.

So this is the default focus policy. And I start tabbing around by pressing the tab button now. It's just jumping around randomly to whatever you, however you added your components to this thing. Now, that's okay if you want to just, you know, try to hunt and peck, but if I switch to the focus policy in 1.4, I've actually implemented a focus policy that follows all the components through the tour itinerary.

So if I tab through You can do this, you can see it follows through the whole itinerary of the tour. And we actually have some things just for fun here. You can see the itinerary and see the tour. Now, you're probably saying, well, we can do this in 1.3. Yeah, you can do this really easily in 1.3 if you have one itinerary.

But if you have multiple itineraries here, so if I switch to another itinerary, now we've just changed the focus policy to the new itinerary's focus policy. So without actually changing anything except telling our focus policy object we've got a new object in there that is our itinerary, we now can follow this. this itinerary through.

and David We can also, you know, we can have a whole bunch of other tours and jump through those. So this is, again, this is not a groundbreaking feature in terms of you could somehow spoof this same feature by building a whole bunch of code and do this. And, you know, but this, in this code we actually just implement a focus policy, apply it to that object and it just follows all the focus.

And for accessibility this is really important because if you want to let people actually use this stuff in a meaningful way, they have to be able to tab to the different items and then press the space bar and use the item and interact with these components without actually using the mouse. And if there's some defined way that you're supposed to navigate through things and if that actually dynamically changes, this kind of focus policy will help out a lot.

So if we can go back to the slides. So the next thing we're gonna talk about is Swing. And Swing has had some, some additions to it. The most notable are the indeterminate progress bars. The JSpinner, which lets you do things like make date changers really easily, just a little up and down arrow. Scrollable JTab panes. So if you--right now if you have JTab panes and you add lots of elements to them, they just start stacking up, and it's not very good looking. It actually doesn't follow the Aqua HI guidelines.

So the new scrollable JTab panes are useful if you have to have lots of tabs. And for some reason, a lot of people like tabs and like tons of tabs. So this helps out with that. I recommend you don't use tons of tabs, but if you do, you can use the scrollable JTab pane. There's also a JFormatted text field, which lets you handle things like formatting dates and other-- just any object you can build formatters for and put right into this text field. There's also a new drag-and-drop architecture, which we'll talk about more in the tailoring the application session.

So in Java 2D, if you went to the graphics session, you heard a lot about this. In Java 2D, there's actually an entirely new pipeline architecture. There's a really cool thing that's been added called hardware acceleration. It's called volatile images and it lets you hardware accelerate your off-screen images.

So if you're trying to pull images off-screen and then just splitting them up to the screen, you can actually use the graphics card and hardware accelerate this stuff. There's a whole new image I/O framework which is for pluggable images so you can build your own image encoders and decoders and they just plug right into the system. So if you decide to come out with brand new image format X, you can just add yours into the image I/O format.

And there's support for bidirectional text. So if you're using things like Arabic or Hebrew that have to go right to left and then sometimes you throw in an English thing that has to go left to right, it's really confusing if you have to write that support yourself and this is taken care of for you. And there's a whole lot more inside of Java 2D.

Printing has had some major changes. There's some new things for printer device discovery. It lets you find printers and find information about them. There's actually an extensible printing API, so you can add custom things to the print service. And then if you actually are a service provider of printing services, you can actually add new functionality using just this plug-in API that's built in there.

So now we're getting towards the web and enterprise frameworks. There's actually a whole bunch of things that are going on in here. And this is--there's a session on this, which is our web services session that's going to talk about some of these things. XML processing is actually a useful feature that they've bundled in of extensions of XML processing. It's some basic XML features.

It handles your XSL, your different kinds of DTDs and things like that, all the stuff that goes into XML. It's got some basic functionality. And you can actually see on SunSite all the specs for what their XML processing involves. The really good thing about this is that you know you have at least some base functionality built into the 1.4 JDK.

So you don't have to count on bundling another XML parser or whatever you might be using XML for. You at least know there's a known quantity. And if you have something that you need to do specific, you can always bundle your own. But this is just a known quantity that they're bundling inside.

There's JDBC 3.0, and I actually have some notes on this. I actually have some notes on some of these things, because I can't remember everything. But there's things in JDBC 3.0 like save points, keeping your result sets open, better access to your metadata, getting automatically generated keys. Inside of the JNDI, there's access to your domain name servers.

There's LDAP access, support for Corba object services. And then RMI has a bunch of enhancements. RMI, you can get server-side stack traces. So if you've ever tried to do RMI applications, one of the hardest things to do is to get your information of what's going on on the server onto your client side so that you can actually dump those to a console or something equivalent so you can see what's going on on the server without having to find that server or remotely log into that server, find the console dump of that server, so you can actually get those stack traces back. RMI over IIOP lets you use Corba servers instead of RMI APIs. So you can use RMI APIs to get to IIOP. And then let's go on to the next section.

which is the core VM features. Now, the core VM features are really interesting. There's gonna be an entire session about this, which is 406, the Java VM internals, where we're gonna talk about all the 1.4 features that are inside of the core VM. But some of these that are highlights for you to see are improved debugging, which the biggest thing here is the full-speed debugging that we mentioned later, and Blaine will talk a lot about what's actually improved in here. Assertions are something that developers have been asking for for a long time, and they'll be available in 1.4.

Chained exceptions. If you've been doing any coding where you actually have some sort of factored-out framework below you, and it throws exceptions, you catch those things, and you want to re-throw them as your own exception, you can bundle those exceptions inside of it. And it's things you sort of could do in 1.3 before, but this has a structured way for doing it so that you can actually get your chained description of exceptions.

And I like to refer back to what James Gosling was saying. It's one of those great things about Java is that when things fail, they usually fail gracefully, and they usually tell you why they failed. And this is getting you more information about why this has failed. You want to see, you know, not only did you get some array out-of-bounds thing, it was caused because you had some network error below it that was thrown, and you caught it somewhere, or something like that. And then there's things like hot-swap code substitution, which Blaine will tell you all about. I really don't know even what that is, but it's some cool stuff.

So also inside of the core frameworks, there's new I/O APIs, which that has to do with actually getting access to the data buffer of the images. There's a whole bunch of things going on in these I/O APIs, so you can actually get access to almost anything that you need I/O.

It has faster access, has direct native access, and as was explained in this morning's graphics talk, is getting really close to C speed on a lot of these I/O things. There's a whole preferences API that lets you take care of multiple users in terms of preferences. So you can--it's really good for Mac OS X. I mean, you have multiple users on Mac OS X out of the box, and this preferences API lets you take care of that.

There's a logging API that is useful. If you start using some of the things in the Internet plugin that we'll talk in in the browser section, there's whole ways to view this logging information. You can also log it to special areas and things like that. And then there's IPv6 support, which is going to be a little bit more advanced, but it's going to be really important because we're running out of IP addresses, and everyone's dealing with that. So IPv6 and those things are going to be big things that your applications are going to want to take advantage of so that when everything starts changing, it just all works.

So with that, I'd like to bring up Victor Hernandez, who's our Java Runtime Engineering lead, and he has been working on some of the new I/O stuff and is going to give us a little demo of what that can do. There we go. Hello. I'm here to show you the benefits of using one of the most exciting features that's available in JDK 1.4.

That feature is new I/O. So what exactly is new I/O? New I/O is the ability to allocate and directly reference memory that's allocated in the native heap from Java. Previously, you couldn't do this directly from Java, and coming in 1.4, you will have the ability to do so.

This will incredibly improve the performance of any operation that requires access to native memory, such as file access, sockets. And I'm going to show you a quick demo of how it'll improve the-- you can even improve the performance of the Java 1.4. So let's get started. So let's get started. of your graphics. So what I have here is a flight simulator written by Ken Russell, who is a hotspot VM engineer over at Sun. And it's a real-time rendering engine.

So what we have right here is just a huge set of data points. And right now, I'm basically going to try to go up and get it to come back down and show you the graphics performance. So if I go up, there we go. I'm not very good at flying airplanes.

All right, so as you see right now, this is rendering under JDK 1.3. You see the choppiness in general. And if we go over to 1.4... It's smooth. Pretty straightforward. Basically, what we're moving over here is a lot of overhead of copies of the native memory buffers back and forth between the heap and the native heap. So where can you go to find out more about this? Come on Friday morning to the Java Performance Session, and you'll find out how to make your app look like that instead. Great. Thanks. Thanks a lot.

So actually they showed me that demo last week when they got it working, and it was actually running a lot faster on our machines back at the office, but it was going between, like, 30 frames a second and, like, 160 or something crazy like that. And you couldn't see a difference.

So I actually told them to slow it down for this session, put a lot more data in there. So it's kind of cool. That's one of the reasons why when it comes up, it looks really choppy, 'cause there's actually a lot of information in that data that they're showing there. It's real terrain information from the Grand Canyon. So there's a lot going on there. And it's kind of cool to see the difference in speed between actually using the native buffers and uploading all that information.

So security has had a lot of changes, and it's really important to us to make sure that we keep up with all these security changes because security is huge. So some of the things we have here are the Java Secure Sockets extension. Now, that's bundled into 1.4. It was an extension in 1.3, and we shipped it in 1.3. So you get this right now.

And that's all of your HTTPS kind of connections that are automatically authenticated, and it just happens. There's the Java Cryptography extension that uses the message authentication code. It lets you take care of things like if you're talking over an insecure connection, you can have some authentication key that is used to make sure that you're actually sending secure packets.

There's the authentication and authorization services, the GSS API, which is for Kerberos support, so you don't send your passwords over the network, and you have just a single sign-up. You can sign on for each domain. Then there's the Java Certification Path API that lets you build up certificate chains and things. So there's a lot of information about all this on Sun's website, so you can check out more details about this there, too.

So that's sort of a high-level overview of what are things that are new in 1.4. Now going With 1.4 development, we're actually adding things in for 1.4 that will allow you to have multiple JDK support. Now, I'm very specific here by saying JDK support, and that is because we're setting this up for you as developers to have multiple JDKs on your machine and be able to switch back and forth. Because you as developers, you know what's best for you and you know how to switch things around.

We're trying to figure out exactly what we should do for end users and to make sure that we give them the best experience because we don't want their applications to break as soon as we give them a 1.4 system. So we really need your feedback on this and what would make sense. For details, Blaine has a lot more information on the details of how this is going to happen and how we might do things in the future. So definitely go to the 4.06 session.

and as Ted announced yesterday, we have the Java 1.4 Developer Preview. It's available right now. You can go get it. You can try it out. We encourage you to do it. Remember, it's a developer preview. It only runs on Jaguar. and the question we keep getting and we have to remind everybody what's in it, it's got the Hotspot Client VM, it's got the 131 GUI frameworks, but everything else inside of it is 1.4. So if you think about it, it's what I just showed, there's the first section I talked about, Swing and AWT, most of that is 1.3.1 still.

So we don't have those features yet, but everything else, all the chained exceptions, the assertions and all those things are 1.4. The new IO, which is running there, that was running with GL for Java. So a lot of functionality is there and you can do things like all of your web services, you can definitely do on this developer preview. So hopefully you'll check that out and you'll get your feedback to us on what things we're doing well.

and definitely go to session 406 for more details. So in summary, what we've gone through today We know that the Java 2 platform is included in Mac OS X. It's in every box. Java 1.3.1 is what's on there now. You can develop real applications we saw with eBeam. They have a real application that ships with a $600 piece of hardware and that's their free application that runs with it. It's all written in Java and users don't know that. It just works. 1.4 is coming. You got the developer preview. We've talked about that.

and then the roadmap. I've talked about this a lot, but just so you know where the sessions are. 403, Java in the Browser, is immediately after this in Room C, right over here. We'll talk about applets, we'll talk about Web Start, we'll show you some things about different browsers and what you have to worry about as an applet developer. Then 404 is tailoring Java applications for Mac OS X.

This is key for anyone who's delivering applications on Mac OS X. You want to make sure that everything looks good, everything feels like a regular application. And we're going to have all of our DTS engineers there. I'm going to show a couple little things there, so it'll be fun. Java Web Services is tomorrow. And this is an overview, again, of all the things you can do as web services in Java using XML. So we saw a lot of web services things being demoed in Sherlock and other places in the keynote, the opening keynote.

And most of these web services, or a lot of these web services, are being run on Java servers, things that are running just regularly, their J2EE or SE servers, running servlets, providing ways to get to your web services through Java. There's just a huge family of the Java family that is supporting these kinds of things. And then there's the 406, which we've talked about a lot, is the Java Virtual Machine Internals. You can see a little bit under the hood there.

And then 407, which is Victor's session, is Java Performance, talking about making your applications faster and taking advantage of our new 1.4 features. And then, of course, the QuickTime for Java. We don't talk about that a lot because it really just works. You want QuickTime stuff inside of your Java. You just start using QuickTime for Java, just like Matt talked about with the E-Beam things.

They found out about QuickTime for Java. They saw that they could export DV, they could export QuickTime movies, and so they just turned these sessions that have all this vector-based drawing into little QuickTime movies. And you can see exactly the way people draw. And then, of course, there's the QuickTime for Java. And then, of course, there's the QuickTime for Java.

You can see exactly the way people drew it on screen and things. So it's a really good technology. It's available for Mac and for Windows. So for most of the cross-platform needs, you can use it to do lots of things that just are not built into the Java platform itself.

And then, of course, WebObjects. WebObjects uses Java for almost everything. So check them out. They have great server solutions. They have this client-side Java that all uses swing applications on the client. So it's--and they are in room A1. They own that room. And they're in room A1. And they're in room A1. So if you want to go see them, go to room A1. And it's all week over there. We also have the Java compatibility lab, which is down in room L.

So that's down the stairs back to the front of the session--front of the hall. And if you go down there, we actually have at least one or two Java engineers from our team who can help you with any of your issues with your applications. If you have any questions on things or want to just see how an application that you have written runs on Java, go down there and see what we have. Go down there, talk to them. They'll answer any of your questions. And that's all week in room L.

And, of course, our links and resources. We've got all the documentation we talked about. Java dev mailing list hasn't been talked about that much, but it's a really good resource for anyone who's developing Java on the Macintosh. We watch that mailing list ourselves. Our DTS engineers watch that mailing list. We answer questions as much as we can.

Other developers answer questions, oftentimes better than we do. So it's a really good resource. You can just--you can just go down there and talk to them. And just send your questions there. There's anything ranging from simple newbie questions to how do I do an about handler to--or how do I do basic Java stuff to I'm trying to do this stuff with JNI, how exactly do I do it, and someone will pipe up and say I tried this, I tried this. So it's a really good developer forum.

And then, of course, when you have real questions that have to be answered by Apple employees, contact DTS. Both Matt--Matt Drance and Ted Jusvick are DTS engineers, and they're absolutely excellent. They--so call them--I mean, send them email, and they'll fix your problems, hopefully. and the final thing is who to contact about everything else and who we're going to bring up now is Alan Samuel. He's our evangelist for Java. He is otherwise known as "The Man." and he is the one to contact. Do you have any issues with Java? Anything outside the realm of technically how do we do this? Talk to Alan.

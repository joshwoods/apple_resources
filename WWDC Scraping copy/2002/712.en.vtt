WEBVTT

00:00:02.210 --> 00:00:04.990
So I wanted to welcome you all
to our last session of the day,

00:00:04.990 --> 00:00:09.100
which is Advanced Enterprise Objects
Frameworks.

00:00:09.140 --> 00:00:11.470
And we have Steve Minehr
here to present for you.

00:00:11.510 --> 00:00:12.100
Steve?

00:00:12.250 --> 00:00:19.000
Thank you, Toni.

00:00:28.270 --> 00:00:30.940
So today's session is Advanced EOF.

00:00:30.940 --> 00:00:31.740
My name is Steve Minehr.

00:00:31.740 --> 00:00:33.660
I'm a Web Objects Engineer.

00:00:33.660 --> 00:00:35.940
Helping with the demos
later will be Ben Trumbull,

00:00:35.940 --> 00:00:37.180
another Web Objects Engineer.

00:00:37.370 --> 00:00:38.520
So we'll bring him up a little bit later.

00:00:40.840 --> 00:00:43.290
First, before we get started,
I'd like to know how many people attended

00:00:43.290 --> 00:00:46.080
the Intro to EOF session on Tuesday?

00:00:46.140 --> 00:00:47.480
I saw James Dempsey.

00:00:47.520 --> 00:00:48.700
So he put on a great show.

00:00:48.760 --> 00:00:51.180
I'm sorry I don't have
any musical ability.

00:00:51.190 --> 00:00:52.960
No singing or dancing for you today.

00:00:52.970 --> 00:00:54.560
But if you do come to
the beer bash tonight,

00:00:54.560 --> 00:00:55.520
there'll be a band there.

00:00:55.580 --> 00:00:58.070
So I hope that takes care
of the entertainment.

00:00:59.090 --> 00:01:01.660
Can I also ask,
I wonder how many people here are

00:01:01.660 --> 00:01:04.430
new to EF or new to WebObjects?

00:01:04.600 --> 00:01:05.590
Okay, so there's a few.

00:01:05.600 --> 00:01:08.040
How many people feel like
they're advanced users?

00:01:08.080 --> 00:01:12.550
You prefer to edit your models
in Emacs because it's faster?

00:01:12.620 --> 00:01:14.020
All right, good, good.

00:01:14.080 --> 00:01:15.030
We got a couple.

00:01:15.230 --> 00:01:16.760
All right,
so I'll try to give you something new.

00:01:16.760 --> 00:01:20.560
A lot of this is going to be review of
things you picked up in other sessions.

00:01:20.630 --> 00:01:22.750
But we'll try to leave time for
questions at the end because I have

00:01:22.750 --> 00:01:25.560
a feeling most people come to these
sessions just to ask questions.

00:01:25.560 --> 00:01:27.500
They don't really want the content.

00:01:27.770 --> 00:01:30.040
Okay, so introduction,
we're going to talk about a

00:01:30.050 --> 00:01:34.540
number of different topics in EOF.

00:01:34.540 --> 00:01:36.940
We've already reviewed models
in this previous session.

00:01:36.940 --> 00:01:40.780
I'm going to give you my spin
on a couple of little things.

00:01:40.780 --> 00:01:43.350
We'll talk about designing EOs,
and I'll give you some

00:01:43.350 --> 00:01:44.600
recommendations there.

00:01:44.600 --> 00:01:47.990
I'm going to strongly recommend
you use single-table inheritance

00:01:48.100 --> 00:01:49.590
when you're using inheritance.

00:01:49.670 --> 00:01:50.780
We'll get to that.

00:01:51.000 --> 00:01:54.680
Most of that was already
explained in the last session.

00:01:54.680 --> 00:01:57.030
We'll do a quick bit on
shared editing contexts,

00:01:57.030 --> 00:01:59.450
and we might get some
questions on that later.

00:01:59.510 --> 00:02:03.060
I'm going to go over delegate methods,
but I don't have enough time,

00:02:03.060 --> 00:02:06.220
and to tell you the truth,
I can't get into every single delegate,

00:02:06.220 --> 00:02:10.740
so I'm going to give you my general spiel
on delegate methods and what to look for.

00:02:10.920 --> 00:02:13.550
Then we'll get to data
synchronization and have a demo there.

00:02:13.580 --> 00:02:17.240
That's an issue that affects some
large installations when you have

00:02:17.250 --> 00:02:20.780
multiple WebObjects instances
or you have multiple writers,

00:02:20.780 --> 00:02:23.630
and there's some
interesting issues there.

00:02:23.880 --> 00:02:23.880
Finally, I'm going to talk about
the use of the EOF.

00:02:23.880 --> 00:02:23.880
I'm going to talk about
the use of the EOF.

00:02:23.880 --> 00:02:23.880
I'm going to talk about
the use of the EOF.

00:02:23.880 --> 00:02:23.880
I'm going to talk about
the use of the EOF.

00:02:23.910 --> 00:02:27.400
Finally, if we have time,
we'll talk about raw rows

00:02:27.400 --> 00:02:29.270
and using SQL within EOF.

00:02:33.000 --> 00:02:36.080
Okay, before I get started into my talk,
I want to review last year's talk.

00:02:36.200 --> 00:02:38.020
Eric Noyo gave a really good talk.

00:02:38.020 --> 00:02:40.120
It had the same title, Advanced EOF.

00:02:40.190 --> 00:02:42.440
I'm stealing only a couple of his slides.

00:02:42.530 --> 00:02:46.160
You should go back and look at last
year's talk if you want to review.

00:02:46.420 --> 00:02:48.890
Eric told us about his
bug tracker example.

00:02:49.120 --> 00:02:52.420
And one of the big points he made
was the separation of the user

00:02:52.420 --> 00:02:54.510
interface from the controller logic.

00:02:54.620 --> 00:02:58.080
And he had a nice framework for
doing his controller and showing

00:02:58.080 --> 00:03:03.100
you how you can change that to put
different UIs on the same application.

00:03:03.140 --> 00:03:07.290
Eric also made a point of doing built-in
testing while you're developing.

00:03:07.300 --> 00:03:10.010
This is one of the ideas
from extreme programming.

00:03:10.010 --> 00:03:13.540
You might not be so extreme,
but it is a good idea to build some

00:03:13.600 --> 00:03:18.630
tests into your components and into your
application as you're developing it.

00:03:18.680 --> 00:03:22.600
Then you could feel adventurous,
make big changes, run your test,

00:03:22.620 --> 00:03:25.600
make sure you didn't break anything else.

00:03:25.750 --> 00:03:28.560
and Eric's example is
still available on the web,

00:03:28.560 --> 00:03:31.450
so you can download
that and play with that.

00:03:32.960 --> 00:03:36.350
Okay, the technology frameworks
that we deal with in EOF,

00:03:36.380 --> 00:03:37.680
of course we start with Java Foundation.

00:03:37.680 --> 00:03:42.560
That's all your base classes
and a lot of utility classes.

00:03:42.710 --> 00:03:45.060
We build on that with Java EO Control.

00:03:45.230 --> 00:03:48.380
That's where EO Editing Context
lives and Fetch Specifications.

00:03:48.540 --> 00:03:50.830
That's where you're going to
do most of your programming

00:03:50.830 --> 00:03:52.310
when you're dealing with EOF.

00:03:52.470 --> 00:03:56.780
Java EO Access is our
database access layer.

00:03:56.780 --> 00:03:59.850
For the most part, you don't need to know
how EO Access works,

00:03:59.850 --> 00:04:04.400
but since you came to an advanced talk,
I'm going to talk about it.

00:04:04.510 --> 00:04:09.850
And similarly, with our JDBC adapter,
at the API level, you shouldn't have the

00:04:09.940 --> 00:04:11.400
program to the JDBC adapter.

00:04:11.400 --> 00:04:15.800
We mention it just because that's the
main framework you want to include when

00:04:15.800 --> 00:04:21.400
you're talking to relational databases,
and we add that automatically for you.

00:04:21.400 --> 00:04:24.460
in Project Builder.

00:04:24.830 --> 00:04:26.310
All right,
I stole this slide from another

00:04:26.400 --> 00:04:28.840
talk because I thought it was a
pretty slide and I didn't have

00:04:28.840 --> 00:04:30.360
any great graphics in mind.

00:04:30.360 --> 00:04:34.040
EOF is that little part over the right.

00:04:34.160 --> 00:04:37.600
Okay, most of this is other
stuff in WebObjects,

00:04:37.710 --> 00:04:44.730
but the part on the right is the database
talking to your web application machines.

00:04:44.910 --> 00:04:47.780
So here's another slide I just
stole from the previous talk.

00:04:47.780 --> 00:04:49.490
But I'll take credit for this last year.

00:04:49.490 --> 00:04:52.670
I designed this slide,
so I gave it to them.

00:04:52.830 --> 00:04:54.560
The idea here is editing
context at the top.

00:04:54.790 --> 00:04:56.520
That's where you're doing
most of your programming.

00:04:56.620 --> 00:05:00.840
If you're new to EOF,
spend time looking at EO editing context.

00:05:00.840 --> 00:05:01.740
Look at the API.

00:05:01.740 --> 00:05:05.730
Make sure you understand how to add
objects to both sides of relationships.

00:05:05.880 --> 00:05:08.240
There's plenty of API there.

00:05:08.240 --> 00:05:09.310
It's not too complicated.

00:05:09.550 --> 00:05:12.390
But that's where you want to
concentrate your time and effort.

00:05:12.660 --> 00:05:12.660
All right?

00:05:12.690 --> 00:05:13.940
I'm going to talk about
some other things.

00:05:14.050 --> 00:05:17.560
I don't want to confuse new people,
but advanced people sometimes run

00:05:17.560 --> 00:05:22.110
into issues where they have to dig
a little deeper into the EOF stack.

00:05:22.290 --> 00:05:27.280
The object store coordinator is
a simple object that coordinates

00:05:27.280 --> 00:05:28.680
multiple object stores.

00:05:28.780 --> 00:05:32.890
And an object store is kind of an
abstract representation of some data

00:05:32.900 --> 00:05:34.920
source out there in the real world.

00:05:35.430 --> 00:05:39.430
Normally, your object store is going
to be an EO database context.

00:05:39.630 --> 00:05:43.290
That's our object that knows
how to manage dealing with

00:05:43.290 --> 00:05:45.360
any particular database.

00:05:46.050 --> 00:05:49.240
and EODatabaseContext is a complicated
class with lots of delegates.

00:05:49.320 --> 00:05:53.020
There's plenty of opportunities for
you to take control of EOF there.

00:05:53.380 --> 00:05:55.940
Normally you don't have to,
but it's there if you need it.

00:05:56.220 --> 00:06:00.160
EODatabase uses, I'm sorry,
EODatabaseContext uses an

00:06:00.160 --> 00:06:02.400
EODatabase to store snapshots.

00:06:02.680 --> 00:06:09.010
So that maintains the EOF's idea of
what data exists in the database.

00:06:09.250 --> 00:06:11.760
We use those,
those are row level snapshots.

00:06:11.890 --> 00:06:16.110
We use that for checking objects when
we're going in and out of the database.

00:06:16.220 --> 00:06:19.060
When we're instantiating objects,
we're sharing that memory

00:06:19.060 --> 00:06:21.920
that's stored in the snapshots.

00:06:21.980 --> 00:06:24.540
The, at the intro course,
James mentioned that I talked

00:06:24.540 --> 00:06:27.090
more about snapshots,
so I'll talk about it now because

00:06:27.090 --> 00:06:28.710
I didn't have a slide for this.

00:06:28.840 --> 00:06:31.530
But EOeditingContext
also keeps snapshots.

00:06:31.720 --> 00:06:33.920
It keeps object level snapshots.

00:06:34.040 --> 00:06:38.920
So you can imagine any EO can more or
less be translated in terms of storage.

00:06:39.160 --> 00:06:41.430
It keeps the storage at
state into a dictionary.

00:06:41.430 --> 00:06:42.800
So that's what a snapshot is.

00:06:42.900 --> 00:06:45.690
It's just a dictionary
representation of the state of an EO.

00:06:45.690 --> 00:06:48.940
And EOeditingContext will keep track
of that as you're changing EOs.

00:06:48.940 --> 00:06:50.680
There's a last committed snapshot.

00:06:50.680 --> 00:06:53.890
You can always take a current snapshot
of any EO and store that away.

00:06:54.320 --> 00:06:56.660
The EODatabase keeps row level snapshots.

00:06:56.660 --> 00:07:01.090
So again, it's a dictionary idea,
but their values in the

00:07:01.090 --> 00:07:05.150
EODatabase correspond to the
columns in your database.

00:07:05.150 --> 00:07:06.160
So it's a little bit different.

00:07:06.160 --> 00:07:08.120
It's not necessarily your full EO.

00:07:08.160 --> 00:07:10.160
And you might have
more information there.

00:07:10.160 --> 00:07:13.660
The EODatabase snapshots, for example,
have primary key information,

00:07:13.670 --> 00:07:16.960
whereas your EOs typically won't
have primary key information in your

00:07:16.960 --> 00:07:19.160
snapshots at the editing context level.

00:07:19.160 --> 00:07:26.160
The database channel controls the
interaction with the database,

00:07:26.500 --> 00:07:28.050
issuing queries to the database.

00:07:28.440 --> 00:07:34.180
And each of these database sorts
of objects has an adapter object

00:07:34.180 --> 00:07:40.160
corresponding to it that it uses
to deal with a particular database.

00:07:40.160 --> 00:07:44.980
In our case, we have a JDBC adapter,
so there's a JDBC adapter context

00:07:44.980 --> 00:07:46.930
and there's a JDBC channel.

00:07:47.160 --> 00:07:47.750
Those particular data sources
are the ones that are used

00:07:47.750 --> 00:07:48.160
to deal with the EODatabase.

00:07:48.160 --> 00:07:53.970
Those particular adapter level
classes know how to deal with

00:07:53.970 --> 00:07:56.080
a particular data source.

00:07:56.170 --> 00:08:00.150
So we're specialized for
JDBC with our JDBC channel.

00:08:00.190 --> 00:08:04.500
The database channel object is
more abstract and it just uses the

00:08:04.500 --> 00:08:07.080
adapter channel to get the job done.

00:08:07.160 --> 00:08:10.160
And then below, of course,
there's a relational database.

00:08:12.830 --> 00:08:15.850
All right, for model recommendations,
Justin talked about quite

00:08:15.850 --> 00:08:17.540
a bit of this before,
so I'll go quickly.

00:08:17.540 --> 00:08:19.460
In the primary key, it's simpler.

00:08:19.460 --> 00:08:21.480
If you use a simple energy
as your primary key,

00:08:21.480 --> 00:08:23.500
there was a question last
time about compound keys.

00:08:23.500 --> 00:08:26.000
That's no problem,
but you have to do a little bit more

00:08:26.000 --> 00:08:28.980
work if you have compound primary keys.

00:08:28.980 --> 00:08:31.380
All your relationships are a
little bit more complicated.

00:08:31.380 --> 00:08:33.140
That's fine.

00:08:33.140 --> 00:08:37.110
Many DBAs will set up the
database for you that way.

00:08:37.120 --> 00:08:41.500
Complicated models are natural.

00:08:41.770 --> 00:08:44.380
If you have a big enterprise application.

00:08:44.380 --> 00:08:48.400
But if you're in control and you're
designing the database from scratch

00:08:48.460 --> 00:08:51.620
just for your WebObjects application,
I recommend that you keep it simple.

00:08:51.620 --> 00:08:53.550
Use an integer as your primary key.

00:08:53.560 --> 00:08:57.340
And usually,
you don't want to use that primary key

00:08:57.340 --> 00:08:59.860
as a foreign key into another table.

00:08:59.880 --> 00:09:03.120
If you're doing inheritance,
that's natural.

00:09:03.120 --> 00:09:04.600
You have multiple tables.

00:09:04.600 --> 00:09:05.920
They share the primary key.

00:09:05.920 --> 00:09:10.030
You can take the primary key from
one table to get into the other.

00:09:10.780 --> 00:09:13.780
But in the general case,
you'll want to have a separate attribute,

00:09:13.780 --> 00:09:16.160
which is your foreign key,
into the other table.

00:09:16.160 --> 00:09:20.660
That's going to make it more flexible
for you and will allow you to have

00:09:20.660 --> 00:09:25.390
optional relationships where that
foreign key value might be null.

00:09:25.400 --> 00:09:28.130
Whereas some people get into
trouble where they want to

00:09:28.130 --> 00:09:30.220
make an optional relationship,
but they're joining

00:09:30.220 --> 00:09:33.440
using the primary key,
which is identically the same as

00:09:33.510 --> 00:09:35.200
the primary key in the other table.

00:09:35.200 --> 00:09:38.700
And EOF will be confused by
that because any time you have

00:09:38.760 --> 00:09:41.390
a value for a foreign key,
it expects to see another

00:09:41.470 --> 00:09:42.900
row in the other table.

00:09:42.900 --> 00:09:45.060
And if you don't actually
have that other row there,

00:09:45.060 --> 00:09:45.940
you're going to get an error.

00:09:47.860 --> 00:09:49.560
We were talking about class properties.

00:09:49.560 --> 00:09:52.230
Justin mentioned to be
careful with large to many's.

00:09:52.350 --> 00:09:56.130
You don't always have to model your
relationships as class properties.

00:09:56.230 --> 00:10:00.410
You might have them in your model so
that you can form queries over them,

00:10:00.410 --> 00:10:04.860
but you might not need those values
every time you instantiate Neo.

00:10:04.860 --> 00:10:09.320
So the idea here is just a question
of performance and being pragmatic.

00:10:09.460 --> 00:10:13.930
There may be cases where you don't need
that to many to be updated every time

00:10:13.930 --> 00:10:16.380
you update the inverse relationship.

00:10:16.380 --> 00:10:19.500
So leave it off,
don't turn it on as a class property.

00:10:19.610 --> 00:10:22.180
When you need those values,
you can use a fetch spec.

00:10:22.340 --> 00:10:27.360
You can fetch all those objects
across that relationship on demand.

00:10:27.360 --> 00:10:31.500
This is a question of
how large the to many is.

00:10:31.830 --> 00:10:36.240
Similarly, for, well, for another reason,
primary keys usually are not

00:10:36.240 --> 00:10:37.990
marked as class properties.

00:10:38.000 --> 00:10:40.280
You usually don't need to
manipulate the primary key.

00:10:40.280 --> 00:10:41.670
But if you have some complicated
situation where your primary key

00:10:41.670 --> 00:10:42.340
is not marked as class property,
you usually don't need to

00:10:42.340 --> 00:10:42.650
manipulate the primary key.

00:10:42.650 --> 00:10:43.690
But if you have some complicated
situation where your primary

00:10:43.690 --> 00:10:46.090
key isn't a simple integer,
then you might want to

00:10:46.090 --> 00:10:47.270
populate that yourself.

00:10:47.600 --> 00:10:49.340
But of course,
once you have Neo constructed

00:10:49.460 --> 00:10:53.200
with a primary key value,
you're not allowed to change that.

00:10:53.780 --> 00:10:56.140
When you're modeling blobs,
the recommendation is to put

00:10:56.140 --> 00:10:57.540
the blobs in a separate table.

00:10:57.540 --> 00:11:00.990
And this, again,
was a question in the last session.

00:11:01.450 --> 00:11:02.570
EOF is creating faults.

00:11:02.640 --> 00:11:05.330
I'll talk about faults a little
bit more for you in a minute.

00:11:05.330 --> 00:11:08.000
But a fault is basically an
empty shell of an object.

00:11:08.090 --> 00:11:09.760
We'll fill that up later.

00:11:09.930 --> 00:11:15.080
If your blobs are in your main
table and their class properties,

00:11:15.230 --> 00:11:19.160
whenever EOF fetches that object,
it has to instantiate the blob in memory.

00:11:20.160 --> 00:11:24.580
If it's in a separate table and
you use a relationship to the

00:11:24.580 --> 00:11:28.780
other EO containing just the blob,
then that allows us to make that a fault.

00:11:28.790 --> 00:11:32.620
And that can give you better performance
in the situation where you're not

00:11:32.620 --> 00:11:34.600
necessarily touching all those blobs.

00:11:34.600 --> 00:11:40.160
And as Justin mentioned,
you probably don't want to lock on blobs.

00:11:40.540 --> 00:11:43.800
There's no SQL command for us to
do a comparison against the blob,

00:11:43.800 --> 00:11:45.530
so we have to pull the
whole thing into memory,

00:11:45.920 --> 00:11:49.970
compare it in memory,
and that's usually a performance killer.

00:11:52.850 --> 00:11:54.950
When we're talking about
generating primary keys,

00:11:54.950 --> 00:11:58.180
the adapter will automatically
generate primary keys for you

00:11:58.470 --> 00:12:00.330
if they're simple integers.

00:12:00.430 --> 00:12:04.100
If there's any other kind of primary key,
then you need to fill that in yourself.

00:12:04.210 --> 00:12:06.860
And one way you can do that
is with the delegate method,

00:12:06.940 --> 00:12:09.860
database context, new primary key.

00:12:10.110 --> 00:12:16.890
You can implement that whenever EOF is
inserting an object in the database,

00:12:16.900 --> 00:12:21.520
it will ask your delegate to give it,
fill out a value for the

00:12:21.520 --> 00:12:24.890
primary key dictionary and
then use those values into the,

00:12:25.080 --> 00:12:27.560
put those values into
the database for you.

00:12:27.660 --> 00:12:32.420
Or if you mark your primary
key as a class property,

00:12:32.420 --> 00:12:35.060
you can implement wake
from insertion on your EO,

00:12:35.180 --> 00:12:38.440
fill in that value
whenever you insert an EO,

00:12:38.550 --> 00:12:42.550
you'll be responsible for
giving it a unique primary key.

00:12:42.660 --> 00:12:44.960
There's also one other way that
we can do it automatically,

00:12:44.960 --> 00:12:47.920
it's not on the slide,
but if your primary key is an

00:12:47.920 --> 00:12:53.420
NSData of exactly 24 bytes,
EOF has a magic way of coming up with a

00:12:53.520 --> 00:12:57.220
globally unique value for those 25 bytes.

00:12:57.340 --> 00:13:03.720
That's a little complicated,
but if you want to use it, go ahead.

00:13:05.620 --> 00:13:07.900
All right, when you're designing EOs,
the first thing, of course,

00:13:07.900 --> 00:13:12.280
you have to take a look at the
EO Enterprise Object Interface.

00:13:12.450 --> 00:13:16.270
But for most people,
you don't want to just implement

00:13:16.370 --> 00:13:17.780
that interface yourself.

00:13:17.850 --> 00:13:20.620
You want to use one of our base classes.

00:13:20.740 --> 00:13:24.340
First base class is EO Custom Object.

00:13:24.400 --> 00:13:25.640
That's your basic EO.

00:13:25.690 --> 00:13:28.160
It knows how to do
everything with faults.

00:13:28.250 --> 00:13:32.550
And again,
let me review faults while we're here.

00:13:33.190 --> 00:13:35.850
A fault is an empty shell of an EO.

00:13:35.860 --> 00:13:39.240
The reason we create faults is when
we're fetching the first EO and

00:13:39.420 --> 00:13:42.400
it has relationships to other EOs,
you can imagine a long

00:13:42.400 --> 00:13:44.100
chain of relationships.

00:13:44.100 --> 00:13:45.840
We're pulling in one EO.

00:13:45.840 --> 00:13:48.080
We don't want to pull in the
whole database or follow that

00:13:48.080 --> 00:13:49.710
long chain on the first fetch.

00:13:49.720 --> 00:13:54.680
So EOF creates an empty shell,
a placeholder, for that object.

00:13:54.740 --> 00:13:58.600
And when your code is
going to touch that object,

00:13:58.680 --> 00:14:00.210
EOF will populate it.

00:14:00.300 --> 00:14:04.350
Now, the situation can be more
complicated with batch faulting.

00:14:04.360 --> 00:14:08.370
We can actually populate multiple objects
at the same time when you fire one fault.

00:14:08.400 --> 00:14:11.820
We'll fill a few more of them,
so that can help you with performance and

00:14:11.940 --> 00:14:14.260
improve the locality of reference there.

00:14:14.260 --> 00:14:19.030
But the key thing on faults is
that in your getter methods,

00:14:19.060 --> 00:14:21.130
you need to call will read.

00:14:21.180 --> 00:14:27.040
If you're implementing EO custom object,
it's a very easy requirement,

00:14:27.040 --> 00:14:27.920
but just remember this.

00:14:28.000 --> 00:14:30.220
In all your getter methods,
call will read first.

00:14:30.240 --> 00:14:33.510
That gives the framework a
chance to populate the fault,

00:14:33.860 --> 00:14:37.290
create a real EO, so that everything
else will work for you.

00:14:38.580 --> 00:14:41.640
Another requirement is
in your setting methods,

00:14:41.640 --> 00:14:44.220
your setters have to call will change.

00:14:44.320 --> 00:14:46.350
Will change will call will read,
so that takes care of

00:14:46.440 --> 00:14:47.620
the faulting part of it.

00:14:47.730 --> 00:14:50.450
And then will change also
allows the framework to keep

00:14:50.610 --> 00:14:52.390
track of EOs that have changed.

00:14:52.390 --> 00:14:55.260
And then as we mentioned
in all the other sessions,

00:14:55.280 --> 00:14:57.980
EOF is keeping track of
all those changed objects,

00:14:58.260 --> 00:15:02.170
and later when you save changes,
we know which ones to send

00:15:02.170 --> 00:15:04.410
back to the database for you.

00:15:04.660 --> 00:15:08.480
Now if you don't want to write any code,
you can use EOGenericRecord.

00:15:08.580 --> 00:15:13.040
And so you can think of this as
your EO with values and keys in it.

00:15:13.150 --> 00:15:16.520
So it's your, it's the simplest way
to do your programs.

00:15:16.560 --> 00:15:24.760
It's a great way to get started and
EOModeler will use EOGenericRecord

00:15:24.760 --> 00:15:27.310
if it can't find your class or you
don't specify a class in your EOModel.

00:15:27.620 --> 00:15:29.440
There's no code required.

00:15:29.440 --> 00:15:30.550
We do automatic storage.

00:15:30.600 --> 00:15:35.220
It's actually a tiny bit faster in
that we're controlling all the storage.

00:15:35.300 --> 00:15:37.440
The key value coding
runs a little faster.

00:15:37.440 --> 00:15:40.930
Another nice feature
is EOGENERIC_RECORD can

00:15:41.010 --> 00:15:42.780
do deferred faulting.

00:15:42.880 --> 00:15:46.360
So I just talked about normal faulting
where we create a shell of an object,

00:15:46.430 --> 00:15:47.630
we'll fill it in later.

00:15:47.640 --> 00:15:51.110
Deferred faulting doesn't even
allocate the memory for the object yet.

00:15:51.130 --> 00:15:53.350
It's deferring even creating the fault.

00:15:53.430 --> 00:15:56.240
We have a special unique
placeholder object.

00:15:56.250 --> 00:15:59.390
And because this is all
happening within our framework,

00:15:59.570 --> 00:16:02.470
we can take care of creating
the fault and creating the real

00:16:02.470 --> 00:16:04.750
object when it's actually needed.

00:16:04.780 --> 00:16:07.280
So you can save a little bit of
memory with deferred faulting.

00:16:07.380 --> 00:16:09.030
If you want,
your EOCustom objects can also

00:16:09.270 --> 00:16:10.680
implement deferred faulting.

00:16:10.680 --> 00:16:12.610
That's another interface.

00:16:12.820 --> 00:16:18.340
You'll need to call one extra method
in your accessor methods to make sure

00:16:18.340 --> 00:16:21.320
that deferred faulting is working.

00:16:21.510 --> 00:16:24.930
So it's really simpler probably
to use EOGENERIC_RECORD.

00:16:25.110 --> 00:16:30.020
You can subclass EOGENERIC_RECORD and
when EOModeler creates a Java class

00:16:30.020 --> 00:16:33.070
for you by our templates,
we're creating a subclass

00:16:33.160 --> 00:16:34.170
of EOGENERIC_RECORD.

00:16:34.360 --> 00:16:36.460
You can add IVARs there
and do whatever you want.

00:16:36.570 --> 00:16:40.470
And you'll see how the
EOGENERIC_RECORD accesses

00:16:40.570 --> 00:16:45.700
values using the stored value
accessors a little bit later.

00:16:49.100 --> 00:16:52.130
All right,
last part of designing your EOs.

00:16:52.130 --> 00:16:54.610
You want to keep your EO code clean.

00:16:54.610 --> 00:16:58.270
This is really just a basic
object-oriented programming

00:16:58.710 --> 00:17:00.670
principle of encapsulation.

00:17:00.690 --> 00:17:04.570
Don't put more code in your
EOs than they need to know about.

00:17:04.750 --> 00:17:08.000
Make sure you just use
Java Foundation and EO control

00:17:08.470 --> 00:17:09.690
concepts in your EOs.

00:17:09.970 --> 00:17:12.290
You shouldn't be using EO access.

00:17:12.350 --> 00:17:15.230
Maybe you might want to use EO utilities.

00:17:15.230 --> 00:17:18.710
That's kind of a special
area of EO access.

00:17:19.000 --> 00:17:23.810
It's, um, some convenience, uh,
functionality there for, um...

00:17:23.800 --> 00:18:08.400
[Transcript missing]

00:18:10.230 --> 00:18:11.280
All right, key value coding.

00:18:11.310 --> 00:18:14.300
Probably you've dealt with key
value coding if you've done any

00:18:14.300 --> 00:18:18.860
work in WebObjects Builder or
any EOF applications before.

00:18:18.860 --> 00:18:22.740
The interfaces for key value coding
are spread across four different

00:18:23.140 --> 00:18:25.400
interfaces there that I've listed.

00:18:25.400 --> 00:18:28.160
The basics are pretty simple.

00:18:28.160 --> 00:18:30.270
If you want to, you can override it.

00:18:30.390 --> 00:18:32.340
We don't recommend you do,
but it's all there if you

00:18:32.480 --> 00:18:34.100
want to take control yourself.

00:18:35.040 --> 00:18:39.040
I would suggest take a look at the inner
classes of each of those interfaces.

00:18:39.130 --> 00:18:41.620
It has an inner class called
utility and default implementation.

00:18:41.620 --> 00:18:44.980
The utility has static methods
that if you're taking control,

00:18:44.980 --> 00:18:47.880
you can invoke these static
methods on any object.

00:18:47.880 --> 00:18:51.020
We'll check to make sure
we do the right thing.

00:18:51.020 --> 00:18:55.950
And the default implementation has
our performance optimizations in it.

00:18:56.100 --> 00:18:58.750
So even if you're doing something fancy,
try to call back into our

00:18:58.750 --> 00:18:59.990
default implementation.

00:19:00.000 --> 00:19:02.760
But for most users, you don't need to
change key value coding.

00:19:02.760 --> 00:19:04.280
You're just going to be using it.

00:19:06.570 --> 00:19:10.330
So the basics,
access to your object by key

00:19:10.670 --> 00:19:12.290
is to call value for key.

00:19:12.290 --> 00:19:14.960
So on any EO, if you know your
different attribute names,

00:19:14.960 --> 00:19:16.820
you can get the value by
calling value for key.

00:19:16.820 --> 00:19:19.420
Take value for key is
for setting a value.

00:19:19.420 --> 00:19:22.750
And we'll explain exactly how
those methods work in a minute.

00:19:22.760 --> 00:19:27.490
Value for key paths and take value
for key paths is just an extension.

00:19:27.500 --> 00:19:31.300
Instead of having a simple key,
you can have a key path,

00:19:31.440 --> 00:19:33.260
which is a chain of keys.

00:19:33.260 --> 00:19:39.290
So you can be following a relationship,
and that's the notation for that is just

00:19:39.290 --> 00:19:41.320
a string with a key separated by dots.

00:19:43.270 --> 00:19:48.340
One interesting item is that
NSDictionary implements key value coding.

00:19:48.340 --> 00:19:51.060
So you can see the
correspondence between snapshots,

00:19:51.100 --> 00:19:55.990
which are NSDictionary's,
and EOs allow you to kind of mix and

00:19:55.990 --> 00:20:00.790
match values out of EOs and dictionaries.

00:20:00.820 --> 00:20:05.840
NSArray is special and to many
relationships are implemented

00:20:06.410 --> 00:20:08.760
with NSMutable arrays.

00:20:10.040 --> 00:20:13.450
They have special keys that they
understand these at sign operators.

00:20:13.460 --> 00:20:15.500
At sign count gives you
the count of the array.

00:20:15.500 --> 00:20:19.500
The other operators, min, max, sum,
and average,

00:20:19.500 --> 00:20:22.160
all take another key after them.

00:20:22.160 --> 00:20:24.060
So you're using a key
path and you might say,

00:20:24.060 --> 00:20:30.800
give me the average of a particular key
in all these EOs that were in an array.

00:20:30.820 --> 00:20:35.100
and we'll return that single value.

00:20:39.680 --> 00:20:43.450
The stored value accessors,
these are the more primitive

00:20:43.590 --> 00:20:45.400
way of getting access to EOs.

00:20:45.610 --> 00:20:50.870
And these methods are mainly used
by our framework in order to,

00:20:50.960 --> 00:20:53.300
say, populate EOs,
take stored value for key.

00:20:53.300 --> 00:20:55.880
When we're fetching the raw
data out of the database,

00:20:55.880 --> 00:20:59.830
the framework is going to
invoke take stored value for

00:20:59.830 --> 00:21:02.380
key to populate your EO object.

00:21:02.490 --> 00:21:05.530
So we're trying to do it in the
most primitive way possible.

00:21:05.530 --> 00:21:10.460
We'll talk about the difference
between the stored value and the take,

00:21:10.460 --> 00:21:14.220
and the regular value
for key in a minute.

00:21:14.220 --> 00:21:19.590
Values for keys and take values from
dictionary are methods that let you slice

00:21:19.590 --> 00:21:22.210
and dice between dictionaries and EOs.

00:21:22.320 --> 00:21:25.150
So you can update your EOs from
a dictionary or you can

00:21:25.150 --> 00:21:29.180
pull out just pieces of your
dictionary by using values,

00:21:29.340 --> 00:21:32.380
pieces of your EO by
using values for keys.

00:21:32.380 --> 00:21:35.750
And then these last two static
methods you can implement on your

00:21:35.750 --> 00:21:41.290
EO class and it controls how this,
how we do our key value coding.

00:21:41.460 --> 00:21:43.120
First of all,
whether or not we can access

00:21:43.410 --> 00:21:47.930
your member fields directly,
usually that's true and we'll

00:21:47.930 --> 00:21:52.060
use your IVARs directly,
but you can set that to false if you

00:21:52.060 --> 00:21:56.800
don't want key value coding to look
into your EOs and hit the IVARs.

00:21:56.800 --> 00:22:00.250
And the other option is
should use stored accessors,

00:22:00.250 --> 00:22:01.800
and that controls whether or not
we're going to do anything special

00:22:01.840 --> 00:22:02.150
on the stored value accessor methods.

00:22:02.180 --> 00:22:02.460
We'll talk about that in a minute.

00:22:02.510 --> 00:22:03.480
So we're going to do a little bit
of a quick review of the EO class.

00:22:03.480 --> 00:22:04.040
We're going to talk about the EO class,
and then we're going to

00:22:04.040 --> 00:22:04.470
talk about the EO class.

00:22:04.480 --> 00:22:05.480
And then we're going to
talk about the EO class.

00:22:05.480 --> 00:22:05.480
And then we're going to
talk about the EO class.

00:22:05.480 --> 00:22:08.230
And then we're We'll talk
about that in a second.

00:22:09.290 --> 00:22:13.550
So quickly, value for key,
that's the main way that you're going

00:22:13.550 --> 00:22:15.000
to access values out of your EOs.

00:22:15.000 --> 00:22:18.200
We have to look up a method,
figure out how to get

00:22:18.290 --> 00:22:19.720
that value out of your EO.

00:22:19.720 --> 00:22:22.740
And the way we do that is looking
for the public method first.

00:22:22.800 --> 00:22:25.730
If we can't find a public method,
then we're going to look

00:22:25.730 --> 00:22:26.960
for an underbar method.

00:22:26.980 --> 00:22:30.480
And the convention is the underbar
method is maybe a little bit

00:22:30.480 --> 00:22:32.290
more private or more direct.

00:22:32.360 --> 00:22:36.260
And finally, if there's no method
matching that key name,

00:22:36.260 --> 00:22:38.050
we'll look for a field
matching the key name.

00:22:38.430 --> 00:22:40.400
And so you can see the whole list
of things we'll look at there.

00:22:43.430 --> 00:22:46.700
Stored Value for Key just changes
the order that we're going to

00:22:46.700 --> 00:22:49.060
look for a way to access your EO.

00:22:49.110 --> 00:22:52.890
And as we said before, the stored

00:22:53.060 --> 00:22:58.170
The stored value methods are trying
to get to the more primitive values,

00:22:58.250 --> 00:23:00.500
bypassing some of your code maybe.

00:23:00.500 --> 00:23:03.550
You might have your public
method implement something a

00:23:03.550 --> 00:23:06.840
little more complicated than
your underbar primitive method.

00:23:06.940 --> 00:23:09.140
So you can take advantage
of this when you're coding.

00:23:09.210 --> 00:23:13.460
If you have to do something complicated,
put your public API that you

00:23:13.460 --> 00:23:18.600
want other users to invoke
in your regular get method,

00:23:18.680 --> 00:23:21.820
and then maybe have an underbar
get name that does something a

00:23:21.820 --> 00:23:23.930
little more direct to your EO.

00:23:24.290 --> 00:23:26.740
And of course, we'll hit the fields,
and finally,

00:23:26.740 --> 00:23:31.590
if there's no underbar or field,
we'll call your public method.

00:23:32.870 --> 00:23:34.090
Take value for key.

00:23:34.090 --> 00:23:37.000
This is how we're setting things,
so we're looking for the set methods.

00:23:37.060 --> 00:23:40.730
If we don't find a method,
we'll look for the underbar,

00:23:40.730 --> 00:23:42.120
and finally we'll hit the field directly.

00:23:42.120 --> 00:23:45.460
And when we're doing
the take stored value,

00:23:45.460 --> 00:23:46.880
we just change that order.

00:23:46.880 --> 00:23:49.430
We're hitting the primitive
underbar method first,

00:23:49.430 --> 00:23:51.830
otherwise the field,
and then the public method.

00:23:51.840 --> 00:23:56.810
So you don't have to do anything fancy,
but if you do have a complicated EO and

00:23:56.810 --> 00:24:00.870
there's some subtlety to how you want
that EO populated versus how you want

00:24:00.870 --> 00:24:03.480
the rest of the world to access the EO,
you can take advantage of

00:24:03.480 --> 00:24:04.650
following this convention.

00:24:07.070 --> 00:24:14.560
and its validation is our interface
declaring how we validate EOs.

00:24:14.600 --> 00:24:18.390
We don't want you to put the
validation code in the setter methods.

00:24:18.390 --> 00:24:21.500
We want you to write a separate
method on a particular key.

00:24:21.600 --> 00:24:25.360
You can call our method
validate value for key.

00:24:25.420 --> 00:24:28.060
We'll call your custom validate key.

00:24:28.100 --> 00:24:32.200
So we'll show you in a second
an implementation of that.

00:24:32.280 --> 00:24:36.160
Again, you can override and do something
different in validation.

00:24:36.230 --> 00:24:40.920
Take a look at the interclass utility
so you can invoke this on any object.

00:24:40.980 --> 00:24:43.900
And also take a look at
our default implementation.

00:24:43.900 --> 00:24:48.080
Normally you don't want to override this,
but it's there if you want to.

00:24:48.700 --> 00:24:50.090
Here's a validation example.

00:24:50.100 --> 00:24:54.360
If you have a key name,
then you might write a method.

00:24:54.360 --> 00:24:57.960
In this case, we're taking a string
and returning a string.

00:24:58.040 --> 00:25:00.540
If something goes wrong,
then we want to throw an exception.

00:25:00.770 --> 00:25:03.060
And our framework is
looking for that exception.

00:25:03.130 --> 00:25:06.490
It's an NSValidation
validation exception.

00:25:06.560 --> 00:25:07.490
In this case, it's very simple.

00:25:07.530 --> 00:25:12.260
We're just saying we want the length
of the name to be greater than four.

00:25:12.310 --> 00:25:14.280
We'll throw if it's not.

00:25:14.540 --> 00:25:15.990
Otherwise, we'll just return the name.

00:25:16.120 --> 00:25:19.570
But you might do something
more sophisticated.

00:25:20.390 --> 00:25:22.350
All right, you can also do EO validation.

00:25:22.500 --> 00:25:25.630
These validation methods
are sent to your EO,

00:25:25.690 --> 00:25:29.800
and you can validate the entire EO,
not just an individual key

00:25:29.800 --> 00:25:32.400
or attribute on that EO.

00:25:32.510 --> 00:25:35.990
So,
the names are kind of self-explanatory.

00:25:36.240 --> 00:25:39.560
When your EO is first being
inserted in an editing context,

00:25:39.650 --> 00:25:41.400
we'll call validate for insert.

00:25:41.500 --> 00:25:44.410
When you're updating that EO,
we can call validate for update.

00:25:44.590 --> 00:25:47.400
When we're saving changes,
we'll call validate for save.

00:25:47.480 --> 00:25:50.400
And finally, if you delete the EO,
we'll call validate for delete.

00:25:50.400 --> 00:25:54.400
So, you can put extra business
logic in any of these methods.

00:25:56.740 --> 00:25:59.110
A few other methods that you
might consider implementing on

00:25:59.110 --> 00:26:02.200
your EO to handle unknown keys.

00:26:02.200 --> 00:26:04.700
These are really error handling.

00:26:04.700 --> 00:26:06.700
There's an interface
called error handling.

00:26:06.700 --> 00:26:09.680
Handle query with unbound key.

00:26:09.740 --> 00:26:11.950
So if you send your EO some
key it doesn't know about,

00:26:11.960 --> 00:26:16.960
if you implement this method,
we'll call this method and give

00:26:16.960 --> 00:26:19.690
you a chance to recover from
that or do something special.

00:26:19.840 --> 00:26:22.700
And similarly for handle
take value for unbound key.

00:26:22.700 --> 00:26:24.700
Unable to set null for key.

00:26:24.700 --> 00:26:27.610
Some attributes don't allow null.

00:26:27.810 --> 00:26:31.700
You want to maybe substitute a
zero or some other special value.

00:26:31.700 --> 00:26:33.700
You can do that using this method.

00:26:33.700 --> 00:26:35.180
Awake from insertion.

00:26:35.180 --> 00:26:39.750
Whenever you're inserted into the EO,
I'm sorry, whenever you're inserted

00:26:39.860 --> 00:26:44.940
into the EO editing context,
your EO will get called with this method,

00:26:45.020 --> 00:26:46.700
awake from insertion.

00:26:46.720 --> 00:26:48.480
If you're populating
your own primary keys,

00:26:48.480 --> 00:26:49.690
that's a good place to do it.

00:26:49.700 --> 00:26:52.560
When the EO is fetched
out of the database,

00:26:52.560 --> 00:26:55.660
it will be sent the
message awake from fetch.

00:26:55.760 --> 00:26:58.700
So you can do some special
processing there to fix up your EO.

00:27:00.960 --> 00:27:03.510
Okay, the following methods are things
that you want to invoke but

00:27:03.510 --> 00:27:04.740
you don't want to override.

00:27:04.800 --> 00:27:08.960
These are all things used by the
framework and we give you a good

00:27:08.960 --> 00:27:12.640
implementation and I don't think
anything good can happen if you

00:27:12.640 --> 00:27:13.800
override any of these methods.

00:27:13.800 --> 00:27:16.490
So,
will change notifies the editing context

00:27:16.630 --> 00:27:18.800
that you're changing this object.

00:27:18.800 --> 00:27:20.800
Do that in your setter methods.

00:27:20.800 --> 00:27:23.790
Will read in your getter methods.

00:27:23.790 --> 00:27:26.730
Will read relationship if you're
implementing deferred faulting,

00:27:26.770 --> 00:27:27.700
you'll need to invoke this.

00:27:27.820 --> 00:27:30.800
Again,
if you're doing an eogeneric record,

00:27:30.800 --> 00:27:33.490
you don't even have to worry about
invoking any of these methods

00:27:33.490 --> 00:27:34.800
because we'll invoke those for you.

00:27:34.800 --> 00:27:38.460
Then the stored value access,
stored value for key and take

00:27:38.460 --> 00:27:42.800
stored value for key are kind of
private to our implementation.

00:27:42.800 --> 00:27:44.800
We'll invoke those at the right time.

00:27:44.800 --> 00:27:47.870
You can invoke those if you're
subclassing eogeneric record,

00:27:47.980 --> 00:27:51.550
but I don't think you
should ever override those.

00:27:54.750 --> 00:27:57.940
Okay, we'll switch gears a little
bit and talk about inheritance.

00:27:58.010 --> 00:28:00.700
This was covered in the last session,
so this is a bit of review.

00:28:01.010 --> 00:28:03.340
But vertical inheritance is
nice because it's natural for

00:28:03.440 --> 00:28:04.940
object-oriented programming.

00:28:05.040 --> 00:28:05.920
It's simple maintenance.

00:28:06.050 --> 00:28:10.010
You can add an attribute at any
parent entity and all the other

00:28:10.010 --> 00:28:12.850
entities will inherit that attribute.

00:28:12.930 --> 00:28:18.970
You don't have to do much maintenance
on your database table because

00:28:18.970 --> 00:28:19.080
there's only one table where
you have to add another column.

00:28:19.240 --> 00:28:29.780
But the fetches are expensive because
we have to do joins and we have

00:28:29.780 --> 00:28:29.780
to do multiple fetches to do deep
inheritance fetching because we have

00:28:29.780 --> 00:28:29.780
to fetch once for every sub-entity.

00:28:30.000 --> 00:28:34.040
Horizontal inheritance,
where you duplicate the column

00:28:34.040 --> 00:28:38.430
names in different tables,
is a bit more efficient in that

00:28:38.430 --> 00:28:43.040
we don't have to join when we're
doing fetches for the simple case.

00:28:43.150 --> 00:28:45.040
But there's still more
maintenance overhead.

00:28:45.140 --> 00:28:49.480
If you want to update your
database or your object model

00:28:49.930 --> 00:28:52.340
and add another attribute,
you have to remember to go put that

00:28:52.340 --> 00:28:57.800
attribute in all the subentities
that inherit from the same parent.

00:28:58.690 --> 00:29:02.340
So the recommendation is to
use single table inheritance.

00:29:02.380 --> 00:29:05.920
In single table inheritance,
your columns are the union of all the

00:29:05.920 --> 00:29:09.200
columns needed by all your subentities.

00:29:09.260 --> 00:29:12.800
Each subentity might map a
different set of those columns.

00:29:13.300 --> 00:29:17.440
The downside is you have to
allow null in anything that's not

00:29:17.440 --> 00:29:19.760
common to all the subentities.

00:29:19.870 --> 00:29:23.130
We'll have to insert a null in
those columns that aren't used

00:29:23.140 --> 00:29:25.700
by a particular subentity row.

00:29:25.800 --> 00:29:29.760
The big advantage is we can do a
single fetch for deep inheritance.

00:29:29.870 --> 00:29:35.160
So we only have to issue one select,
get all the values out of the table,

00:29:35.250 --> 00:29:40.710
and then we can assemble those into
the correct kind of subentity class.

00:29:41.240 --> 00:29:45.090
And this also avoids a
limitation on sorting.

00:29:45.100 --> 00:29:49.470
When you're doing horizontal
inheritance and you're trying to sort,

00:29:49.470 --> 00:29:53.300
we're actually issuing multiple
select statements to the database.

00:29:53.550 --> 00:29:55.890
Each of those is sorted,
but you don't have an

00:29:55.890 --> 00:29:57.360
overall sorted result.

00:29:57.540 --> 00:30:02.350
So that's a little bit of a
problem in horizontal inheritance.

00:30:02.660 --> 00:30:06.360
Single table inheritance, of course,
since we're doing one select,

00:30:06.490 --> 00:30:08.680
you'll get the natural result back.

00:30:10.100 --> 00:30:12.930
Then you remember this
from the previous slides.

00:30:12.930 --> 00:30:16.910
The idea here is that
everybody's sitting in one table.

00:30:17.670 --> 00:30:20.750
I'm sorry,
that was from the previous session.

00:30:20.750 --> 00:30:26.170
Now, we say we can do single table
inheritance fetching in one select,

00:30:26.230 --> 00:30:32.000
but that's only if you meet a few
restrictions on how you set up

00:30:32.070 --> 00:30:34.280
your single table inheritance.

00:30:34.500 --> 00:30:38.820
First requirement is that you
have some attribute that's

00:30:38.960 --> 00:30:43.640
distinguished to determine what
sub-edit this particular row is.

00:30:43.750 --> 00:30:49.650
And the simplest way to do that
is to just have a subtype column,

00:30:49.650 --> 00:30:53.240
maybe have different constants
assigned for each sub-edity.

00:30:53.240 --> 00:30:56.400
Sub-edity one has a one in that column,
two, and so on.

00:30:56.520 --> 00:31:00.380
And you write a restricting qualifier,
which is of the form attribute

00:31:00.450 --> 00:31:02.580
equals some constant value.

00:31:02.670 --> 00:31:06.270
Okay, this, if you follow these two
simple requirements,

00:31:06.390 --> 00:31:10.200
then EOF can do a single fetch and

00:31:10.500 --> 00:31:29.300
[Transcript missing]

00:31:29.810 --> 00:31:31.650
All right,
so if you're trying to-- if you're

00:31:31.650 --> 00:31:35.740
implementing single table inheritance,
typically you'll have to

00:31:35.820 --> 00:31:38.390
implement a wake from insertion.

00:31:38.530 --> 00:31:41.220
Whenever you create a
new instance of your EO,

00:31:41.500 --> 00:31:42.850
you'll want to set this column.

00:31:43.030 --> 00:31:47.130
So if the attribute was called sub,
you have a method called setSub,

00:31:47.260 --> 00:31:51.510
and then each unique sub entity--
each sub entity has a unique

00:31:51.510 --> 00:31:55.490
implementation of mySub that
just returns that constant value.

00:31:55.640 --> 00:32:00.660
and once you've set the value for
the determinant of the subentity,

00:32:00.660 --> 00:32:01.390
you shouldn't change it.

00:32:01.500 --> 00:32:03.890
That's almost like a primary key.

00:32:03.910 --> 00:32:07.180
It's write once.

00:32:10.590 --> 00:32:13.800
All right, new topic,
shared editing context.

00:32:13.840 --> 00:32:16.160
I don't have a lot to say
about shared editing context.

00:32:16.310 --> 00:32:18.330
It was touched on in
the previous session.

00:32:18.340 --> 00:32:24.270
In your EO model, you can designate fetch
specifications that will fetch

00:32:24.400 --> 00:32:27.620
objects whenever we load this model
into the shared editing context.

00:32:27.660 --> 00:32:31.310
So the shared editing context
is some common space that your

00:32:31.310 --> 00:32:35.030
other editing contexts kind of
get to hold onto by default.

00:32:35.090 --> 00:32:38.050
And the idea here is you might
fetch these things once it's

00:32:38.050 --> 00:32:39.940
started up of your application.

00:32:39.940 --> 00:32:43.940
You never have to fetch them again.

00:32:43.940 --> 00:32:45.360
Everybody can see those EOs.

00:32:45.360 --> 00:32:50.330
Maybe you have a catalog application,
some other kind of mostly

00:32:50.900 --> 00:32:52.660
read-only permanent data.

00:32:52.660 --> 00:32:54.620
Put it in your shared editing context.

00:32:54.640 --> 00:32:59.280
But there's a requirement that other
editing contexts can have relationships

00:32:59.360 --> 00:33:03.920
that point into your shared set of EOs,
but none of the shared EOs can point

00:33:04.000 --> 00:33:06.110
out to the other editing contexts.

00:33:08.050 --> 00:33:11.050
While we're here,
I should also point out that we are

00:33:11.050 --> 00:33:15.250
aware of a bug that is causing some
kind of deadlocking issue when people

00:33:15.340 --> 00:33:17.160
are using shared editing contexts.

00:33:17.240 --> 00:33:18.160
So we're working on that.

00:33:18.160 --> 00:33:19.640
We have our top people on that.

00:33:19.690 --> 00:33:22.110
And I don't know exactly
when it will be fixed,

00:33:22.220 --> 00:33:25.980
but just to be aware of that,
we'll get on it.

00:33:29.700 --> 00:33:31.410
Delegate Methods.

00:33:31.410 --> 00:33:33.750
So, EOF is very customizable.

00:33:33.910 --> 00:33:38.110
There are lots of places
you can implement delegates,

00:33:38.110 --> 00:33:38.110
but

00:33:38.420 --> 00:33:41.480
New users probably don't want
to look at delegates first.

00:33:41.600 --> 00:33:44.450
This is what you look at
when you can't figure out why

00:33:44.450 --> 00:33:46.330
isn't EOF doing what I want.

00:33:46.460 --> 00:33:47.510
There must be a better way.

00:33:47.800 --> 00:33:51.140
There probably is if you go
take control and use a delegate.

00:33:51.290 --> 00:33:54.990
But when you implement a delegate,
remember you're kind of doing

00:33:54.990 --> 00:33:59.180
brain surgery on the EOF stack,
so you have a lot of responsibility to do

00:33:59.190 --> 00:34:01.710
the right thing in your delegate method.

00:34:01.710 --> 00:34:05.700
And your delegate methods then
get invoked possibly fairly often,

00:34:05.700 --> 00:34:06.330
so you want to make sure it's efficient.

00:34:06.650 --> 00:34:09.070
In the EO Control Layer,
take a look at EO Editing Context.

00:34:09.150 --> 00:34:13.700
There's a few delegates there
controlling how updates are merged.

00:34:13.710 --> 00:34:19.260
And each of these classes on the list
here has an inner class called Delegate.

00:34:19.260 --> 00:34:24.530
So you can explore that in our API,
our Java documentation,

00:34:24.790 --> 00:34:27.760
and see what other
delegates are available.

00:34:27.800 --> 00:34:30.300
EO Database Context has
quite a few delegates.

00:34:30.400 --> 00:34:34.420
You can control a lot of what EO Database
Context is doing in terms of fetching

00:34:34.490 --> 00:34:37.540
and dealing with the database there.

00:34:37.540 --> 00:34:41.020
EO Adapter Context also
has some delegates that

00:34:41.020 --> 00:34:43.270
you might be interested in.

00:34:43.590 --> 00:34:49.690
All these classes in the EO Access layer,
though, are a little difficult for your

00:34:49.690 --> 00:34:51.120
application to get a hold of.

00:34:51.300 --> 00:34:55.180
They're created on demand when you
first start doing something that

00:34:55.180 --> 00:34:56.530
requires you to go to the database.

00:34:56.540 --> 00:34:59.160
You usually have easy access
to your editing context.

00:34:59.240 --> 00:35:01.090
Your session has a
default editing context,

00:35:01.240 --> 00:35:03.060
or you've created it yourself.

00:35:03.180 --> 00:35:06.690
But you don't really have direct
access to your database context,

00:35:06.690 --> 00:35:09.640
your EO database context,
or these other things that

00:35:09.640 --> 00:35:11.000
we're creating on demand.

00:35:11.120 --> 00:35:15.060
So there's a static method in each of
these classes called setDefaultDelegate.

00:35:15.170 --> 00:35:18.240
This lets you start your application
early on in your application.

00:35:18.320 --> 00:35:21.500
You can call setDefaultDelegate.

00:35:21.630 --> 00:35:24.060
Whenever EO database context
or any of these other things

00:35:24.060 --> 00:35:27.770
are created after that point,
it will automatically be

00:35:27.770 --> 00:35:29.500
assigned the delegate you wanted.

00:35:29.650 --> 00:35:34.290
So this gives you a way to
kind of preload your delegates.

00:35:34.380 --> 00:35:36.530
It makes it much easier than
trying to reach into the

00:35:36.530 --> 00:35:38.980
stack and setting a delegate.

00:35:44.450 --> 00:35:46.360
Data synchronization.

00:35:46.500 --> 00:35:51.400
So this is an issue that comes up
especially in large deployments.

00:35:51.520 --> 00:35:55.110
First thing to remember
is EOF is a big cache.

00:35:55.470 --> 00:35:58.870
So we fetched values out of the database.

00:35:58.870 --> 00:36:03.980
We checked when we're writing
back that values haven't changed.

00:36:04.290 --> 00:36:09.260
But sometimes if you have multiple
WebObjects application instances,

00:36:09.260 --> 00:36:12.490
you might have multiple writers or
you might even have external writers,

00:36:12.490 --> 00:36:15.460
some other application that
has access to your database.

00:36:15.550 --> 00:36:19.590
And the values have changed
out from underneath your EO.

00:36:19.780 --> 00:36:22.910
Then when we try to do an update
and write to the database,

00:36:22.920 --> 00:36:25.660
we're comparing against the old values.

00:36:25.750 --> 00:36:28.490
EOF will notice that
something has changed,

00:36:28.540 --> 00:36:32.440
which means you have stale data,
and will throw an exception,

00:36:32.440 --> 00:36:35.810
and you'll get an optimistic
locking exception.

00:36:36.800 --> 00:36:42.970
So, that's an issue that
requires some coding.

00:36:43.310 --> 00:36:45.780
Let's talk about what's happening at UF.

00:36:45.900 --> 00:36:49.050
This graphic again shows
you on the right hand side,

00:36:49.060 --> 00:36:52.980
you can see you have multiple web optics,
application instances.

00:36:53.110 --> 00:36:54.640
They may be talking
to multiple databases,

00:36:54.640 --> 00:36:58.510
but the important thing is each
WOAP might have a slightly different

00:36:58.510 --> 00:37:02.710
view of the data because of updates
and the time that things were fetched.

00:37:03.090 --> 00:37:05.600
And if we have an
optimistic locking failure,

00:37:05.660 --> 00:37:07.900
we'll have to do something about it.

00:37:08.000 --> 00:37:11.000
So, what are the approaches to handling
optimistic locking failure?

00:37:11.120 --> 00:37:13.490
Well, the first thing, of course,
do nothing.

00:37:13.680 --> 00:37:17.240
We've conveniently implemented
that for you in the framework.

00:37:18.840 --> 00:37:19.230
Okay.

00:37:19.590 --> 00:37:20.100
We do nothing.

00:37:20.100 --> 00:37:21.240
It's a little bit complicated.

00:37:21.240 --> 00:37:23.850
It is application-specific
about how to handle that.

00:37:23.890 --> 00:37:28.390
But for a lot of applications,
you're mostly read-only,

00:37:28.390 --> 00:37:29.750
so this issue doesn't come up.

00:37:29.750 --> 00:37:32.830
In many other applications,
even though you're writing

00:37:32.830 --> 00:37:35.480
data to the database,
it's partitioned data.

00:37:35.480 --> 00:37:38.930
Another user doesn't necessarily have
to see the data that's being written.

00:37:38.930 --> 00:37:43.330
So again, in those kind of situations,
you don't have to worry about this.

00:37:43.330 --> 00:37:45.600
But if you're in a real
concurrent situation,

00:37:45.690 --> 00:37:48.680
you have multiple writers,
then you have to do something.

00:37:48.700 --> 00:37:50.680
So there's two ideas.

00:37:51.030 --> 00:37:54.370
One is try to avoid the
optimistic locking failure.

00:37:54.600 --> 00:37:56.520
And the other thing to
do is to recover from it.

00:37:56.520 --> 00:38:00.420
And if you want a robust application,
maybe you want

00:38:00.930 --> 00:38:03.270
Let's talk about avoidance.

00:38:03.270 --> 00:38:05.860
So the issue here is just,
sometimes it's just a matter

00:38:06.020 --> 00:38:07.500
of freshness of your data.

00:38:07.660 --> 00:38:12.820
EOF is trying to cache data,
so maybe you fetched something a long

00:38:12.820 --> 00:38:18.460
time ago and you wanted to update it and
get the latest data from the database.

00:38:18.550 --> 00:38:21.040
One way to do that is to refault objects.

00:38:21.120 --> 00:38:25.110
So you can tell your editing
context to refault objects for you.

00:38:25.350 --> 00:38:28.700
The editing context also has
a notion of a fetch timestamp.

00:38:28.770 --> 00:38:34.000
Fetch timestamp is the editing context
request for freshness of the data.

00:38:34.130 --> 00:38:36.530
So when any context is
first built by default,

00:38:36.690 --> 00:38:39.610
it will accept data from this
object store that I think

00:38:39.610 --> 00:38:41.680
the default is one hour old.

00:38:41.790 --> 00:38:43.380
And that's reasonable for
a lot of applications.

00:38:43.380 --> 00:38:47.710
You might want to change that to you
only want data that's one minute old.

00:38:47.870 --> 00:38:49.680
That's acceptable, or even less.

00:38:49.800 --> 00:38:53.180
But the tighter you set
the fetch timestamp,

00:38:53.180 --> 00:38:54.730
the more fetching you'll have to do.

00:38:54.860 --> 00:38:57.370
So you have to think about that a bit.

00:38:58.060 --> 00:39:01.830
When you're fetching objects
on your fetch specifications,

00:39:01.970 --> 00:39:12.650
as was shown in the last session,
you can set refreshes, refetched objects,

00:39:12.650 --> 00:39:12.650
which usually I can't say in one go.

00:39:12.650 --> 00:39:12.650
You can set that so that...

00:39:12.900 --> 00:41:26.900
[Transcript missing]

00:41:27.080 --> 00:41:30.210
But it is useful if you know there
are triggers out in the database or

00:41:30.210 --> 00:41:32.700
something else strange has happened.

00:41:32.820 --> 00:41:36.700
So that's your best efforts if
you're trying to avoid changes.

00:41:36.810 --> 00:41:42.100
You can also use Dave Newman's
Change Notification Framework.

00:41:42.220 --> 00:41:45.500
So this is not something
we ship with WebObjects,

00:41:45.580 --> 00:41:51.470
but Dave Newman from Apple has made
this available to a number of people.

00:41:51.690 --> 00:41:56.570
Wirehose recently shipped,
and they have an improved version of

00:41:56.570 --> 00:41:58.260
it that is available for download.

00:41:58.540 --> 00:42:04.130
The idea here is that you want
to notify your other WO apps that

00:42:04.130 --> 00:42:06.370
you've made changes in one WO app.

00:42:06.470 --> 00:42:11.140
You send those changes to the other
WO apps so that they try to keep in sync.

00:42:11.280 --> 00:42:16.380
So this has been used in
several customer applications,

00:42:16.380 --> 00:42:17.680
and people are pretty happy with it.

00:42:17.680 --> 00:42:18.980
So you can check that out.

00:42:19.130 --> 00:42:22.100
Download it from wirehose.com.

00:42:24.480 --> 00:42:27.740
Okay, finally,
you may have tried to avoid

00:42:27.740 --> 00:42:30.720
optimistic locking failure,
but somebody else got in there,

00:42:30.720 --> 00:42:31.460
changed the data.

00:42:31.460 --> 00:42:33.190
Now you want to recover from it.

00:42:34.520 --> 00:42:39.540
All right, so you need to catch this
EO General Adapter exception.

00:42:39.620 --> 00:42:43.040
Then you're going to have to drill down
a bit and investigate what happened.

00:42:43.160 --> 00:42:44.920
Take a look at the user info.

00:42:45.040 --> 00:42:49.370
There are a number of constants
defined in EO Adapter Channel.

00:42:50.270 --> 00:42:52.620
First,
there's the look at adapter failure key.

00:42:52.620 --> 00:42:56.400
Check that it's equal to the
adapter optimistic locking failure.

00:42:56.400 --> 00:43:00.200
Then you'll have another key,
failed adapter operator key.

00:43:00.200 --> 00:43:02.060
Take a look at that in
the user dictionary,

00:43:02.060 --> 00:43:04.430
and there'll be all kinds of
information about what went wrong,

00:43:04.440 --> 00:43:06.890
what your snapshots were,
what EO you were dealing with,

00:43:06.960 --> 00:43:08.660
and you'll have a chance to recover.

00:43:10.640 --> 00:43:14.600
Now, that doesn't help you so much,
but we have a demo coming up.

00:43:14.600 --> 00:43:17.860
I'd like to invite
Ben Trumbull to come up.

00:43:17.870 --> 00:43:22.400
So Ben has implemented this,
and he'll show you how to recover.

00:43:48.330 --> 00:43:51.800
So basically what happened is
I'm sort of simulating another

00:43:51.800 --> 00:43:56.260
user or database administrator
just whacking on your table.

00:43:56.400 --> 00:43:59.050
So there's a background
process that's going,

00:43:59.050 --> 00:44:03.290
and it's just picking random rows out
of a table and just changing them.

00:44:03.430 --> 00:44:08.420
So that's going to cause some problems,
as you might imagine.

00:44:08.920 --> 00:44:14.110
The big thing that you need to do is...

00:44:16.400 --> 00:44:19.220
As we come in here,
Steve was talking about this general

00:44:19.260 --> 00:44:22.600
adapter exception that you need to catch.

00:44:22.600 --> 00:44:27.230
And you need to take a look at
this key and check to see if it's

00:44:27.300 --> 00:44:29.010
an optimistic locking failure.

00:44:29.050 --> 00:44:33.360
And then I just sort of isolated
the exact code down in here.

00:44:33.420 --> 00:44:37.860
It's a little bit more than you
might need so I can show you exactly

00:44:37.890 --> 00:44:44.230
what happened so I can make you
believe that I actually did something.

00:44:44.390 --> 00:44:48.200
Otherwise, the save just goes through.

00:44:48.200 --> 00:44:48.200
So, let's see

00:44:49.480 --> 00:44:51.780
We get the operation type,
which is going to be an

00:44:51.780 --> 00:44:54.060
integer and their constants,
and we're going to do a

00:44:54.070 --> 00:44:55.380
switch down here on which one.

00:44:55.400 --> 00:44:59.120
And we get the adapter operation
and the database operation.

00:44:59.200 --> 00:45:02.680
And then from the database operation,
we find out what EO failed.

00:45:02.730 --> 00:45:05.640
And from the adapter operation,
we find out what changes we were

00:45:05.640 --> 00:45:08.220
trying to make when we saved.

00:45:08.320 --> 00:45:12.670
And we also get a hold of the
database snapshot and stuff so we

00:45:12.690 --> 00:45:16.020
can show that in our success page.

00:45:16.370 --> 00:45:17.540
Then we switch on this.

00:45:17.540 --> 00:45:20.800
This app's pretty simple,
and all it does is doing updates.

00:45:21.040 --> 00:45:26.340
So we ignore deletes,
and we don't do any explicit locking.

00:45:26.860 --> 00:45:29.260
So we kind of gloss over that.

00:45:29.260 --> 00:45:31.780
As Steve mentioned,
this is application-specific.

00:45:31.940 --> 00:45:33.800
There isn't any right answer.

00:45:33.800 --> 00:45:37.980
So what I've done here is implemented
a last right wins behavior.

00:45:38.170 --> 00:45:40.850
And that may or may not be what you want.

00:45:40.860 --> 00:45:45.230
In fact, as I'll show you in the demo,
it produces some behavior you

00:45:45.230 --> 00:45:48.690
might consider odd depending
on who you want to be right,

00:45:48.800 --> 00:45:53.420
whether or not you want the first guy
to be right or the last guy to be right.

00:45:53.500 --> 00:45:59.530
And basically we refault the object,
and then we reapply the

00:45:59.550 --> 00:46:02.290
changes dictionary we got
out of the adapter operation,

00:46:02.410 --> 00:46:04.700
and then we try to save again.

00:46:05.190 --> 00:46:07.880
Unfortunately,
you're only going to get one exception.

00:46:08.080 --> 00:46:11.320
So if you do a save and you save,
you know, 20 EOs,

00:46:11.320 --> 00:46:15.950
or actually in this example we
saved about 14 rows all at once.

00:46:16.670 --> 00:46:19.260
and three or four of
them have been changed.

00:46:19.400 --> 00:46:23.640
You're going to get an
exception one at a time.

00:46:23.730 --> 00:46:27.740
That's just the way the EO database
context goes through and performs

00:46:27.820 --> 00:46:30.080
each adapter for each global ID.

00:46:30.110 --> 00:46:33.920
So you could expect to possibly
have to catch a number of these,

00:46:33.920 --> 00:46:37.610
which is why we've put
this in a while loop.

00:46:37.940 --> 00:46:41.750
And we keep saving until we either
get an adapter exception that's

00:46:41.820 --> 00:46:43.940
not an optimist clocking failure,
in which case we don't really

00:46:44.010 --> 00:46:46.640
know what to do with it,
or we get something else,

00:46:46.640 --> 00:46:49.220
which is probably a more
catastrophic failure.

00:46:49.220 --> 00:46:50.470
Maybe you ran out of memory.

00:46:50.470 --> 00:46:57.010
There's a no pointer exception somewhere
there shouldn't be that point for.

00:46:59.740 --> 00:47:00.930
So we'll launch this up.

00:47:01.190 --> 00:47:02.050
There's a quick little page.

00:47:02.060 --> 00:47:03.660
It's using the real estate framework.

00:47:03.900 --> 00:47:06.380
It's been demoed a few
times over the conference.

00:47:06.420 --> 00:47:12.460
And basically there is an agent who's
looking through a number of listings,

00:47:12.460 --> 00:47:15.130
and he's only showing the
things he really cares about,

00:47:15.140 --> 00:47:17.440
which is the listing name,
what the asking price is,

00:47:17.480 --> 00:47:20.800
and how much commission he
can expect to get out of that.

00:47:20.800 --> 00:47:23.820
And if the housing market has gone up,
it's

00:47:24.190 --> 00:47:32.290
In the last few months,
you probably want to change

00:47:32.290 --> 00:47:32.290
all of these all at once,
unless something specific.

00:47:32.290 --> 00:47:32.290
So...

00:47:37.110 --> 00:47:42.150
We'll take a little look at what
this background process is doing.

00:47:42.150 --> 00:47:42.150
It's made some changes.

00:48:00.800 --> 00:48:10.700
[Transcript missing]

00:48:11.380 --> 00:48:13.930
From our code,
we got the adapter operation,

00:48:13.990 --> 00:48:17.890
we got what was in the database,
we got the

00:48:18.250 --> 00:48:20.850
What's currently in the database
now-- and this is our cached

00:48:21.030 --> 00:48:25.300
value here-- and then here is the
change that we wanted to make.

00:48:25.640 --> 00:48:30.870
and we had two separate conflicts,
so they got involved in the loop.

00:48:31.220 --> 00:48:32.520
come back.

00:48:32.590 --> 00:48:36.860
And then, so this is the last write wins
behavior that I was talking about that

00:48:36.860 --> 00:48:40.960
could be considered a little weird,
is that basically

00:48:41.020 --> 00:48:43.700
everything's been written out,
sorry,

00:48:43.920 --> 00:48:45.960
Everything's been written out
according to what this particular

00:48:45.960 --> 00:48:48.200
editing context viewed the world as.

00:48:48.310 --> 00:48:53.200
And despite the fact that a number of
other rows have been changed to 1,000,

00:48:53.320 --> 00:48:56.790
and that we were setting inflation
in this particular example to 3%,

00:48:56.890 --> 00:49:01.300
it took the previous value and
incremented it 3%, as opposed to

00:49:01.390 --> 00:49:05.040
taking what was in the database,
you know, somebody else changed the

00:49:05.040 --> 00:49:07.650
value for that listing,
and then applying a 3% to that,

00:49:07.650 --> 00:49:08.800
incrementing that.

00:49:09.000 --> 00:49:11.590
So, you know,
it's pretty application-specific

00:49:11.730 --> 00:49:14.120
how you want to do that.

00:49:14.130 --> 00:49:16.110
And, uh...

00:49:18.150 --> 00:49:20.700
That's pretty much it.

00:49:20.790 --> 00:49:24.750
I'm just using generic records here,
so I haven't done anything useful.

00:49:24.930 --> 00:49:28.760
I put my UI code here in
these component classes,

00:49:29.000 --> 00:49:30.960
and that's all there is.

00:49:31.040 --> 00:49:31.930
Okay.

00:49:32.000 --> 00:49:33.420
Thank you.

00:49:38.200 --> 00:49:39.700
Okay, can we switch back to slides?

00:49:39.750 --> 00:49:39.850
Thanks.

00:49:39.960 --> 00:49:43.150
So, Ben made that look pretty simple.

00:49:43.150 --> 00:49:45.400
And once you have it working,
I guess it is pretty simple.

00:49:45.620 --> 00:49:50.120
But for a lot of EOF users
and Web Objects users,

00:49:50.120 --> 00:49:54.790
this kind of problem has
troubled them for a long time.

00:49:54.950 --> 00:49:58.620
So we're going to make that code
available in some generic way that would

00:49:58.620 --> 00:50:00.960
make everything from WWDC available.

00:50:00.960 --> 00:50:06.480
So you can download that
and take a look later.

00:50:06.480 --> 00:50:06.480
Thanks, Ben.

00:50:07.910 --> 00:50:08.960
All right.

00:50:09.000 --> 00:50:10.940
We just have a few more slides left.

00:50:10.940 --> 00:50:12.910
I want to talk about raw rows,
and this was touched

00:50:13.000 --> 00:50:14.900
on in the last session.

00:50:15.240 --> 00:50:18.750
You can certainly fetch raw rows,
which are just dictionaries

00:50:18.750 --> 00:50:22.900
of keys and values,
in any of your fetch specifications.

00:50:23.300 --> 00:50:28.370
The reason for doing that might be
because you don't need a full EO or maybe

00:50:28.590 --> 00:50:34.580
you have a very large data set and you
just want some of that information back.

00:50:34.680 --> 00:50:41.460
As long as you fetch primary key as part
of that raw row or somehow manipulate a

00:50:41.460 --> 00:50:46.150
dictionary to add a primary key to it,
then we can always turn that into a

00:50:46.150 --> 00:50:48.800
fault or a fault is a shell of an EO.

00:50:48.800 --> 00:50:52.790
We can turn it back into an EO because
you can invoke a fault for a raw row.

00:50:54.180 --> 00:50:55.900
And then one trick,
you might want to look at our

00:50:56.010 --> 00:51:00.740
Think Movies example where we have
a component that declares a local

00:51:00.740 --> 00:51:03.860
variable as NSKeyValueCoding.

00:51:03.960 --> 00:51:05.990
So if you remember,
anything that implements key

00:51:05.990 --> 00:51:10.540
value coding knows how to
take values and return values.

00:51:10.630 --> 00:51:14.930
And typically all your WebObjects
components are just using

00:51:15.010 --> 00:51:17.320
key paths to access values.

00:51:17.470 --> 00:51:21.430
So dictionaries will work for that
just as well as full-fledged EOs.

00:51:21.540 --> 00:51:25.160
You just have to make sure that your
dictionaries support all the keys

00:51:25.260 --> 00:51:27.000
that are required in that component.

00:51:27.180 --> 00:51:32.280
So by using a local variable
of NSKeyValueCoding,

00:51:32.280 --> 00:51:39.140
you can use that component to
display both EOs and raw rows.

00:51:43.030 --> 00:51:47.100
So when we're talking about EOF,
we always say the great feature

00:51:47.100 --> 00:51:48.640
is you don't have to know SQL.

00:51:48.640 --> 00:51:49.900
You don't have to write any SQL.

00:51:49.900 --> 00:51:51.270
EOF will do it all for you.

00:51:51.340 --> 00:51:54.320
And that's true,
and that is a big benefit.

00:51:54.320 --> 00:51:57.780
It simplifies your
interaction with the database.

00:51:57.780 --> 00:52:01.630
You spend most of your time modeling,
and then you can work on your custom

00:52:01.630 --> 00:52:05.430
web applications without worrying too
much about how to talk to the database.

00:52:05.440 --> 00:52:10.640
But there are times when you know
something about SQL or you want to take

00:52:10.640 --> 00:52:13.790
advantage of some special feature in SQL,
special things that

00:52:13.790 --> 00:52:15.240
aren't so object-oriented.

00:52:15.240 --> 00:52:17.960
You might have a
complicated SQL expression,

00:52:17.960 --> 00:52:22.850
or you might have a faster
SQL expression than we generate for

00:52:22.850 --> 00:52:24.580
one of our fetch specifications.

00:52:24.580 --> 00:52:27.620
In any fetch spec,
you can add a hint where you

00:52:27.620 --> 00:52:29.280
can put your own custom SQL.

00:52:30.610 --> 00:52:32.980
All right,
so you can find out what SQL we

00:52:32.980 --> 00:52:38.240
generate and look in your modeler
and then decide to change the SQL,

00:52:38.240 --> 00:52:39.760
do your own thing.

00:52:39.820 --> 00:52:40.700
So you just have to be careful.

00:52:40.700 --> 00:52:44.140
Make sure you return the values in
the same order that the original fetch

00:52:44.140 --> 00:52:47.810
specification was going to return values.

00:52:48.230 --> 00:52:53.730
You can also use custom SQL expressions
in any attribute definition.

00:52:53.830 --> 00:52:57.300
So if you need access, say,
to some SQL function,

00:52:57.300 --> 00:53:00.360
you don't want to compute it in memory,
but you just want to fetch the right

00:53:00.360 --> 00:53:04.160
value when you're populating your EO,
as we mentioned in the previous session,

00:53:04.270 --> 00:53:07.840
you can set a definition
on your attribute.

00:53:08.680 --> 00:53:12.390
Then for any EO entity,
you can specify an external query.

00:53:12.400 --> 00:53:15.140
Again,
you can use your own custom SQL there.

00:53:15.220 --> 00:53:18.300
EO Utilities has several utility methods.

00:53:18.300 --> 00:53:22.060
One is called Raw Rows for SQL,
and there's also a way to turn

00:53:22.060 --> 00:53:25.750
those raw rows back into EOs.

00:53:26.780 --> 00:53:30.130
EOadapter channel has
evaluate expression.

00:53:30.280 --> 00:53:34.940
So every EOadapter is going to implement
some way to evaluate expressions,

00:53:35.020 --> 00:53:38.490
and you can make direct use
of this if you want to send

00:53:38.490 --> 00:53:40.660
your own SQL to a database.

00:53:40.750 --> 00:53:43.750
And we'll show you that in
just a second in the next demo.

00:53:43.930 --> 00:53:46.640
And if you want to write
your own custom EOQualifier,

00:53:46.710 --> 00:53:49.100
EOQualifiers live in EO control.

00:53:49.230 --> 00:53:53.010
So you can define in EO control
how-- some new qualifier you want

00:53:53.010 --> 00:53:54.840
to use in your fetch specifications.

00:53:54.940 --> 00:53:57.280
You define how it works in memory.

00:53:57.420 --> 00:54:01.940
Then you implement another
interface that lives in EO access,

00:54:01.940 --> 00:54:07.290
the EO SQL generation interface
for that particular qualifier.

00:54:07.440 --> 00:54:11.250
You generate the SQL,
and we'll use that whenever we're

00:54:11.250 --> 00:54:15.470
evaluating that query or using that
qualifier in a fetch specification.

00:54:15.630 --> 00:54:18.730
So you can go ahead and
augment what we're doing.

00:54:20.710 --> 00:54:21.700
All right.

00:54:21.700 --> 00:54:22.130
We'll do another demo.

00:54:22.180 --> 00:54:23.670
This time it's going to be for me.

00:54:23.740 --> 00:54:27.410
Can we switch back to demo one?

00:54:27.410 --> 00:54:27.410
Thanks.

00:54:30.540 --> 00:54:33.460
All right,
we just have a couple of minutes.

00:54:33.460 --> 00:54:37.920
This demo is not nearly as exciting.

00:54:41.230 --> 00:54:45.200
So we have a project here that
is just a command line tool

00:54:45.200 --> 00:54:47.730
for doing a SQL command line.

00:54:47.730 --> 00:54:51.570
And this is more of something that's
kind of cool that you can do it,

00:54:51.590 --> 00:54:53.780
not that it's something you want to do.

00:54:53.780 --> 00:54:56.720
You don't, you don't, by any means,
you don't need to send your

00:54:56.720 --> 00:55:01.440
own SQL in your applications,
but just to show you that it's all there.

00:55:01.440 --> 00:55:06.500
So I wanted to show you how we fetch.

00:55:11.020 --> 00:55:14.900
Okay, so the code is pretty
simple here to fetch.

00:55:14.970 --> 00:55:17.390
I'll show you an operation in a second.

00:55:17.520 --> 00:55:22.090
But the basic idea is that
once you find an entity,

00:55:22.230 --> 00:55:27.110
you can ask that entity for
fetch specification by the name

00:55:27.110 --> 00:55:30.140
that was given in this example.

00:55:30.140 --> 00:55:33.990
Then we can do a fetch specification
with qualifier bindings,

00:55:33.990 --> 00:55:38.120
all right, and I'm holding the bindings
in another dictionary.

00:55:38.250 --> 00:55:41.220
So that gives me a fetch
spec that's ready to execute.

00:55:41.340 --> 00:55:42.700
Come down here.

00:55:42.780 --> 00:55:45.580
We're making a new editing context.

00:55:46.050 --> 00:55:48.540
We're sending that editing
context and message objects with

00:55:48.540 --> 00:55:51.850
fetch specification and the fetch
spec that we just built above.

00:55:51.870 --> 00:55:54.160
And we pulled that fetch
spec out of the model.

00:55:54.370 --> 00:55:57.070
Right,
we asked the entity for the fetch spec.

00:55:57.800 --> 00:56:13.200
[Transcript missing]

00:56:20.600 --> 00:56:25.960
Okay, so the most important part is down
here when we're dealing with models.

00:56:25.960 --> 00:56:27.680
We want to add the model
to our model group.

00:56:27.860 --> 00:56:31.130
We create a new adapter
with adapter with model,

00:56:31.340 --> 00:56:32.500
alright?

00:56:32.620 --> 00:56:35.220
And from that adapter we can
create an adapter context.

00:56:35.350 --> 00:56:39.120
The adapter context manages the
connection and we can create an adapter

00:56:39.120 --> 00:56:41.490
channel which allows us to send queries.

00:56:41.500 --> 00:56:55.050
Steve Mineur, Ben Trumbull Okay.

00:56:55.050 --> 00:56:55.050
What's the wrong one?

00:56:55.050 --> 00:56:55.050
You know, I'm trying to find my...

00:57:04.650 --> 00:57:07.030
So this is the SQL tool running.

00:57:07.040 --> 00:57:11.570
Make that bigger and I have a
couple of queries to show you.

00:57:16.060 --> 00:57:20.940
So the typical query we've seen in
some other sessions here is finding a

00:57:20.940 --> 00:57:26.900
listing in the real estate database with,
say, at least four bedrooms.

00:57:26.910 --> 00:57:27.900
Okay.

00:57:27.900 --> 00:57:29.950
And since I wrote this tool myself,
I'm getting back raw rows,

00:57:29.950 --> 00:57:32.900
and I'm showing you kind of a dictionary
representation of the results.

00:57:32.910 --> 00:57:35.900
With a little more effort,
we could show that in a table instead.

00:57:35.900 --> 00:57:37.900
But this is just to show
you I can execute SQL.

00:57:37.900 --> 00:57:42.740
My SQL tool just read this string,
sent it to the adapter channel,

00:57:42.820 --> 00:57:44.950
and got back some results.

00:57:50.070 --> 00:57:53.750
This tool here also has
a concept of logging.

00:57:53.960 --> 00:57:59.060
There's a helpful setting called
EOAdapterDebugEnabled that

00:57:59.060 --> 00:58:02.800
you can turn on to see your
application generating SQL.

00:58:02.800 --> 00:58:06.500
It does more logging of all the SQL calls
and the interactions with the database.

00:58:06.640 --> 00:58:09.700
So I just asked for that to be turned on.

00:58:09.840 --> 00:58:13.610
And now I have a command line.

00:58:27.500 --> 00:58:33.890
Thank you for joining us.

00:58:33.890 --> 00:58:33.890
I'm going to start with the
first part of the session,

00:58:33.890 --> 00:58:33.890
which is to talk about the model.

00:58:42.340 --> 00:58:47.000
I think I spelled something wrong.

00:58:47.110 --> 00:58:48.800
All right,
I think I'm gonna run out of time here,

00:58:48.800 --> 00:58:50.260
so I better take the questions then.

00:58:50.340 --> 00:58:51.560
I'm sorry, I got the wrong model.

00:58:51.790 --> 00:58:58.000
But I'll put this code out on the web,
too, or wherever we put the WWDC code.

00:58:58.070 --> 00:59:00.350
And you can take a look at it,
but this is just to show

00:59:00.350 --> 00:59:02.680
you that you can fetch SQL,
and you can use the adapter

00:59:02.680 --> 00:59:06.220
debug enabled and logging to
see what SQL we're generating.

00:59:06.490 --> 00:59:08.930
And sometimes it helps even
debug your own code in that

00:59:08.930 --> 00:59:11.840
you may have a typo somewhere,
like this time.

00:59:11.970 --> 00:59:15.200
You may have an incorrectly
defined attribute,

00:59:15.200 --> 00:59:17.180
and that causes your SQL to look strange.

00:59:17.200 --> 00:59:19.200
So, all right, thank you very much.

00:59:19.200 --> 00:59:22.740
I think we'll go back to the slides,
please.

00:59:28.030 --> 00:59:31.010
So in summary,
well I think you've heard everything.

00:59:31.010 --> 00:59:33.910
We're running low on time so
I'm going to skip the summary

00:59:33.930 --> 00:59:36.000
and go through the final slides.

00:59:36.050 --> 00:59:39.000
The beta, the lab, open tomorrow.

00:59:39.000 --> 00:59:41.180
There's nowhere else to go except
for the feedback session so you

00:59:41.180 --> 00:59:43.000
can bring more questions there.

00:59:43.000 --> 00:59:45.000
Contact those people, more information.

00:59:45.000 --> 00:59:48.000
All our documentation,
I think you've seen this before.
WEBVTT

00:00:07.570 --> 00:00:09.500
Hello, good afternoon.

00:00:09.500 --> 00:00:13.800
Welcome to session 513,
OpenGL Advanced 3D.

00:00:13.860 --> 00:00:18.500
This session is a real treat
for all of us 3D enthusiasts.

00:00:18.580 --> 00:00:24.260
We're going to show the process and
the very latest techniques for high-end

00:00:24.260 --> 00:00:27.500
CGI generation using vertex programs.

00:00:27.500 --> 00:00:29.930
Well,
the treat is not only on the content,

00:00:29.930 --> 00:00:31.500
but also on the delivery.

00:00:31.500 --> 00:00:34.500
We have a very special
celebrity guest today.

00:00:34.500 --> 00:00:40.260
NVIDIA demo engineer Simon Green is
here to deconstruct the Wolfman

00:00:40.260 --> 00:00:45.770
demo and share with us his expertise
and knowledge about the subject.

00:00:50.200 --> 00:00:54.660
So to deliver the first
part of session 503,

00:00:54.720 --> 00:00:57.940
OpenGL Advanced 3D,
I would like to introduce to the stage

00:00:57.940 --> 00:01:00.910
Apple OpenGL engineer Geoff Stahl.

00:01:12.100 --> 00:01:17.260
The first thing I'm going to do is
talk specifically about what advances

00:01:17.380 --> 00:01:20.260
we've made in OpenGL for Jaguar.

00:01:20.260 --> 00:01:23.010
Then we're going to hand it over
to Simon to talk specifically

00:01:23.040 --> 00:01:24.130
about the Wolfman demo.

00:01:25.470 --> 00:01:28.800
So that's me, Geoff Stahl,
and Simon will be handling

00:01:28.800 --> 00:01:30.840
the second half from NVIDIA.

00:01:30.840 --> 00:01:32.880
Again, I'm going to talk about
what's new with Jaguar.

00:01:32.890 --> 00:01:35.110
We're going to walk through the
Wolfman and then take your questions

00:01:35.290 --> 00:01:40.690
and answers both on Jaguar and how the
Wolfman was made after the session.

00:01:41.100 --> 00:01:43.660
So what optimizations
do we have in Jaguar?

00:01:43.930 --> 00:01:47.130
First thing we did was we realized
that while read pixels and draw

00:01:47.220 --> 00:01:50.410
pixels are not the optimum path,
or draw pixels are not the optimum

00:01:50.500 --> 00:01:53.470
path to get things to a card,
we still realize there are legacy

00:01:53.550 --> 00:01:56.630
applications that need to use these or
there are valid reasons to use these.

00:01:56.720 --> 00:01:58.300
So we optimized those.

00:01:58.370 --> 00:02:00.620
Read pixels and draw pixels
now are supported on most

00:02:00.620 --> 00:02:04.200
cards through DMA engines,
so relieving the CPU of

00:02:04.200 --> 00:02:07.100
having to move all that data.

00:02:07.350 --> 00:02:09.110
You'll see definitely in
your apps that use these,

00:02:09.110 --> 00:02:10.240
you'll see improvements.

00:02:10.280 --> 00:02:12.820
We still recommend using a
texturing path for when you

00:02:12.820 --> 00:02:16.000
would normally use draw pixels,
but if you need to use it,

00:02:16.020 --> 00:02:19.800
note that we have done some
implementation optimizations for that.

00:02:19.860 --> 00:02:21.740
Also, copy text sub-image.

00:02:21.790 --> 00:02:25.440
This now does not do a round trip
across the bus and will stay on the GPU,

00:02:25.540 --> 00:02:29.630
so you may get rates up to 9,
10 gigabytes per second,

00:02:29.740 --> 00:02:33.180
which is native on the card,
for your copy text sub-image.

00:02:33.310 --> 00:02:36.500
So if you need to do this,
you should be seeing tremendous

00:02:37.120 --> 00:02:38.350
increases in throughput.

00:02:38.470 --> 00:02:39.480
Display list.

00:02:39.480 --> 00:02:41.800
Display lists are now
optimized in your seed,

00:02:41.800 --> 00:02:43.890
and we're going to continue
to further optimize them as we

00:02:43.940 --> 00:02:45.440
move down and lock down Jaguar.

00:02:45.440 --> 00:02:47.830
What we're looking to do is
move display lists through

00:02:47.830 --> 00:02:49.300
a vertex array range scheme.

00:02:49.300 --> 00:02:51.880
So what happens is when you
have primitives that you

00:02:51.880 --> 00:02:54.800
run through a display list,
we'll take those primitives,

00:02:55.130 --> 00:02:57.590
optimize them,
put them into a vertex array range,

00:02:57.630 --> 00:03:03.360
and allow the card directly to map
those from AGP memory into the GPU.

00:03:03.360 --> 00:03:06.710
We've seen tremendous
increases in using this.

00:03:06.770 --> 00:03:09.260
And John Stauffer will talk
about it in the optimization.

00:03:09.480 --> 00:03:12.660
He'll talk about specifically
about and show you what kind of

00:03:12.660 --> 00:03:14.300
display list increases we've made.

00:03:14.300 --> 00:03:18.040
So especially for like an architectural
application that is set up to use

00:03:18.120 --> 00:03:21.500
display list and draw a thousand
spheres through display list,

00:03:21.610 --> 00:03:24.290
those kind of applications will
definitely see some speed ups.

00:03:24.480 --> 00:03:27.520
For general purpose applications
that you have a large array of data,

00:03:27.700 --> 00:03:30.430
as they do with the Wolfman,
vertex array range is your friend,

00:03:30.700 --> 00:03:32.490
and you want to move through that path.

00:03:33.780 --> 00:03:34.870
Image Processing.

00:03:34.870 --> 00:03:38.170
We've added the image processing
extension for all machines.

00:03:38.240 --> 00:03:41.700
That includes all machines that
even support a software renderer.

00:03:41.700 --> 00:03:44.760
So you'll be able to get the image
processing extensions and we'll go

00:03:44.760 --> 00:03:48.700
through some of those in a minute,
what the optimizations there are.

00:03:48.700 --> 00:03:50.700
Again, I mentioned vertex arrays.

00:03:50.700 --> 00:03:54.960
Last year we came to this session,
or we came to talking about how to

00:03:55.230 --> 00:03:57.490
get data through the system quickly.

00:03:57.840 --> 00:04:00.700
And we said compile vertex
array is the best way to do it.

00:04:00.700 --> 00:04:02.700
So you take a vertex array, compile it,
and that's the best way.

00:04:02.700 --> 00:04:04.700
Well, we're moving past that now.

00:04:04.740 --> 00:04:08.590
We're actually looking at vertex array
range where you can set a section

00:04:08.860 --> 00:04:12.460
of memory up and map that into,
we will dynamically map that into

00:04:12.460 --> 00:04:17.110
AGP and the GPU will DMA from that
memory with the vertices without having

00:04:17.160 --> 00:04:18.690
to involve the CPU in the process.

00:04:18.870 --> 00:04:21.700
That is going to be the fastest
path in Jaguar for you to use.

00:04:21.700 --> 00:04:23.620
So look at vertex array range.

00:04:23.830 --> 00:04:27.100
It's only a couple of additional
calls if you're already on vertex

00:04:27.520 --> 00:04:31.700
arrays and it'll really give some
great speed ups for your applications.

00:04:31.700 --> 00:04:34.520
for as far as things we've
added that aren't extensions,

00:04:34.520 --> 00:04:35.740
surface texture.

00:04:35.740 --> 00:04:40.160
Surface texture is supported
both in Cocoa and Carbon.

00:04:40.160 --> 00:04:42.540
Carbon is AGL surface texture.

00:04:42.540 --> 00:04:43.780
Cocoa is create texture.

00:04:43.930 --> 00:04:46.000
I talked about this earlier
in one of my sessions.

00:04:46.000 --> 00:04:49.940
And specifically,
this allows you to render to a surface,

00:04:49.940 --> 00:04:51.800
which can be a window
that you just don't show,

00:04:51.800 --> 00:04:55.380
or it can just be a window,
and use the content of that as a texture.

00:04:55.380 --> 00:04:58.640
The requirements are very simply
whatever requirements were there

00:04:58.640 --> 00:05:01.610
originally for the GPU for textures.

00:05:01.700 --> 00:05:04.580
So if your GPU supports
rectangular textures,

00:05:04.580 --> 00:05:07.290
then you can do a surface
texture of any arbitrary size.

00:05:07.390 --> 00:05:09.180
If it doesn't support
rectangular textures,

00:05:09.180 --> 00:05:11.860
you're going to still need a power
of two surface to be supported,

00:05:11.860 --> 00:05:14.160
and you'll just pass that
in as you would normally.

00:05:14.160 --> 00:05:18.340
Last, and probably the best news,
is extension support.

00:05:19.810 --> 00:05:24.540
One of the things we concentrated on for
the 10.1 release was getting a very good,

00:05:24.540 --> 00:05:27.210
stable OpenGL release that
you all could work on,

00:05:27.360 --> 00:05:30.680
could build your applications,
and really didn't have any

00:05:30.680 --> 00:05:32.500
downsides or any flaws in it.

00:05:32.750 --> 00:05:35.520
We think we've really
achieved that with 10.1.

00:05:35.830 --> 00:05:38.260
10.2, we said we really need to add
the features you're asking for.

00:05:38.260 --> 00:05:42.360
So we had 34 extensions
coming into today,

00:05:42.470 --> 00:05:46.640
and Jaguar has an additional,
at this point, planned 30 extensions.

00:05:46.640 --> 00:05:48.390
So we're bringing up
the 64 new extensions,

00:05:48.390 --> 00:05:49.570
and I'll go over what they are.

00:05:49.640 --> 00:05:53.530
And there may be some more in the
works as we move toward the final.

00:05:55.160 --> 00:06:02.100
So one of the main areas of the past year
that's really increased in visibility in

00:06:02.100 --> 00:06:04.390
the commercial market is programmability.

00:06:04.720 --> 00:06:09.920
Programmability is both on the
pixel side and on the vertex side.

00:06:10.190 --> 00:06:14.020
We've supported through a set
of about seven extensions.

00:06:14.090 --> 00:06:16.820
We have one unified extension,
our vertex program,

00:06:16.870 --> 00:06:18.760
which we talked about a few days ago.

00:06:18.890 --> 00:06:21.210
And that will take care of the
vertex programming along with

00:06:21.300 --> 00:06:24.300
providing you a great tool,
the OpenGL shader builder,

00:06:24.420 --> 00:06:28.190
which will allow you to work
on vertex programs today on

00:06:28.190 --> 00:06:30.300
the Jaguar C that you have.

00:06:30.400 --> 00:06:32.630
This gives us the vertex
programming functionality.

00:06:32.950 --> 00:06:36.540
It's available for the ATI Radeon 8500.

00:06:36.620 --> 00:06:41.520
NVIDIA GeForce 3 and 4 all support
vertex programming in hardware.

00:06:41.760 --> 00:06:46.160
All other machines that support
OpenGL have a software implementation

00:06:46.160 --> 00:06:48.420
that's optimized for the CPU.

00:06:48.530 --> 00:06:51.540
What this means is your PowerBooks,
whatever generation they

00:06:51.540 --> 00:06:53.730
are that you have out there,
if they support OpenGL,

00:06:53.750 --> 00:06:57.470
you can use that OpenGL shader builder
and build shaders and have that

00:06:57.470 --> 00:06:59.600
optimized software implementation.

00:06:59.700 --> 00:07:02.600
From the pixel program
and fragment program side,

00:07:02.770 --> 00:07:05.690
from the NVIDIA we have all
five of their programmability

00:07:05.690 --> 00:07:07.580
on that pixel side extensions.

00:07:07.670 --> 00:07:11.600
Registered Combiner 1 and 2,
Texture Shader 2 and 3,

00:07:11.730 --> 00:07:15.600
which will support the full
pixel programmable path.

00:07:15.600 --> 00:07:19.430
On the ATI side,
we're targeting ATI Fragment Shader as a

00:07:19.540 --> 00:07:22.550
support there with the unified extension.

00:07:23.670 --> 00:07:24.550
So vertex array range.

00:07:24.610 --> 00:07:26.860
I think we talked about this already,
but to reiterate,

00:07:26.880 --> 00:07:31.600
it allows the GPU to DMA the vertex
arrays directly from client memory.

00:07:31.600 --> 00:07:33.040
You don't have to involve the CPU.

00:07:33.040 --> 00:07:35.600
So this allows you to alleviate
the CPU of that burden,

00:07:35.710 --> 00:07:40.290
use the CPU for other things,
and utilize the GPU to its fullest.

00:07:40.430 --> 00:07:44.500
It supports both Radeon
cards and all NVIDIA cards,

00:07:44.500 --> 00:07:46.950
but does require hardware TCL.

00:07:47.690 --> 00:07:51.920
Apple vertex array object is a very
simple extension that extends this,

00:07:51.980 --> 00:07:56.300
which allows you to add on the
idea of multiple vertex arrays

00:07:56.300 --> 00:07:57.240
like you would have textures.

00:07:57.240 --> 00:07:59.700
If you have texture objects,
you may want to have

00:07:59.710 --> 00:08:00.760
vertex array objects.

00:08:00.870 --> 00:08:04.140
So you would have for different
objects in your scene,

00:08:04.140 --> 00:08:06.540
you could have a vertex array
for each one of them instead

00:08:06.540 --> 00:08:09.780
of having to manipulate a huge,
large vertex array and have

00:08:09.970 --> 00:08:11.170
sub ranges inside of that.

00:08:11.490 --> 00:08:16.910
So that operates very similar to
texture objects with generate and bind.

00:08:18.710 --> 00:08:22.500
Apple texture range is similar to
vertex array range but allows clients

00:08:22.670 --> 00:08:27.080
to specify memory that they map texture
space and allow you a very fast texture

00:08:27.220 --> 00:08:31.600
upload and utilizing this for the
maximum texture throughput performance.

00:08:31.620 --> 00:08:35.660
John Stauffer will also talk about
this in the session following this

00:08:35.660 --> 00:08:37.600
as far as performance of this.

00:08:37.600 --> 00:08:40.300
Apple fence is a basically will
insert a token into the command

00:08:40.300 --> 00:08:43.560
stream so it allows you to do more
synchronization if you have audio/video

00:08:43.660 --> 00:08:44.600
synchronization you want to do.

00:08:44.600 --> 00:08:48.430
Or OpenGL and some other process you can
do that with an Apple Fence extension

00:08:48.710 --> 00:08:52.600
both synchronously and asynchronously
as far as the handling of the fence.

00:08:53.860 --> 00:08:55.720
So some additional extensions.

00:08:55.750 --> 00:08:58.000
For texturing,
we have texture mirror repeat,

00:08:58.000 --> 00:09:00.800
which is going to basically
double the size of your texture

00:09:00.800 --> 00:09:04.080
with a mirrored section of it.

00:09:04.190 --> 00:09:06.370
Texture EMV crossbar,
which allows you to more

00:09:06.510 --> 00:09:10.110
arbitrarily reference texture
units when you're doing combining.

00:09:10.290 --> 00:09:12.280
Texture mirror once,
very similar to mirror repeat,

00:09:12.380 --> 00:09:15.750
but the fact is that you have a single
mirror without the repeating edges.

00:09:15.850 --> 00:09:19.120
SGI depth texture and SGI X shadow,
which is something that

00:09:19.120 --> 00:09:21.000
Simon will talk about later,
where it was critical for the

00:09:21.000 --> 00:09:22.300
Wolfman to get the self-shadowing.

00:09:22.560 --> 00:09:26.050
This allows you to do
shadow mapping techniques.

00:09:26.120 --> 00:09:28.500
These two extensions
are critical for that.

00:09:29.500 --> 00:09:30.600
So rendering extension.

00:09:30.700 --> 00:09:33.310
Something that's been there before
but I think we should really

00:09:33.310 --> 00:09:34.900
mention is our multi-sample.

00:09:34.900 --> 00:09:37.020
Multi-sample's been in through 10.1.

00:09:37.020 --> 00:09:40.030
It's fully supported through
both Cocoa and Carbon and allows

00:09:40.090 --> 00:09:42.860
you to do anti-aliasing both
in windowed and for full screen.

00:09:42.950 --> 00:09:44.890
So you can have full screen
anti-aliasing support over all

00:09:44.890 --> 00:09:46.400
cards that support the multi-sample.

00:09:46.400 --> 00:09:49.700
Secondary color is an extension
that's been around for a while.

00:09:49.780 --> 00:09:53.170
People are asking for it to support
secondary colors both in vertex

00:09:53.170 --> 00:09:55.280
programs and through our normal path.

00:09:55.400 --> 00:09:59.400
Fog coordinates allow you to
pass explicit fog coordinates.

00:09:59.460 --> 00:10:00.400
Draw range elements.

00:10:00.400 --> 00:10:02.400
It seems to you,
those folks who know OpenGL,

00:10:02.400 --> 00:10:04.400
well that's an old extension.

00:10:04.400 --> 00:10:05.400
Why is that new for Jaguar?

00:10:05.400 --> 00:10:08.550
We wanted to make sure that was
in there so if you're checking for

00:10:08.840 --> 00:10:12.450
that on machines that don't report
OpenGL 1.2 and only report 1.1,

00:10:12.460 --> 00:10:15.440
you can specifically check for that
which allows you to draw a range of

00:10:15.450 --> 00:10:16.400
elements instead of the entire array.

00:10:16.400 --> 00:10:19.340
Stencil wrap for stencil shadows.

00:10:19.340 --> 00:10:24.390
This is a key thing to wrapping
your stencil buffers around.

00:10:24.410 --> 00:10:28.930
Fog distance allows you to specify
an eye radial fog distance instead

00:10:29.060 --> 00:10:31.530
of just a planar from the eye point.

00:10:31.530 --> 00:10:34.520
So it allows you to have more correct
looking fog which I know Austin will

00:10:34.530 --> 00:10:36.400
be very happy with that we have that.

00:10:36.560 --> 00:10:40.320
Multi-sample filter hint allows you,
as you may have read, there's a,

00:10:40.320 --> 00:10:43.400
NVIDIA has a multi-sample
technique called Quinconcs.

00:10:43.400 --> 00:10:47.270
And to do this you would specify
the four tap multi-sample and then

00:10:47.370 --> 00:10:50.930
you would say nicest as far as
the filter hint and it would pick

00:10:51.030 --> 00:10:53.380
the five tap Quinconcs algorithm.

00:10:53.440 --> 00:10:56.500
What that does is allows you
to pick nicest or fastest in

00:10:56.500 --> 00:10:58.400
your multi-sample algorithms.

00:10:58.420 --> 00:11:01.070
And depth clamp, again,
in some of the shadowing algorithms

00:11:01.070 --> 00:11:03.720
covering shadow volumes you
want depth clamping rather than

00:11:03.720 --> 00:11:05.330
clamping to the actual frustum.

00:11:08.640 --> 00:11:11.480
Pixel transfer,
we talked about RBM imaging, histogram,

00:11:11.820 --> 00:11:14.820
blending, min-max,
some convolution filters,

00:11:14.820 --> 00:11:20.690
those are all in there in every OpenGL,
any CPU that you have,

00:11:20.690 --> 00:11:23.490
RBM imaging will be supported.

00:11:23.500 --> 00:11:26.480
And also we have some new ATI extension,
blend equation separate,

00:11:26.480 --> 00:11:29.450
which allows a separate equation
for the alpha and for the color,

00:11:29.540 --> 00:11:32.470
which can be very useful at times,
and weighted min-max,

00:11:32.560 --> 00:11:34.500
which allows you to do weighting
values for your blending.

00:11:34.500 --> 00:11:38.040
And then lastly, blend square,
so for some lighting calculations,

00:11:38.040 --> 00:11:40.860
that allows you to square in
the blending to bring out the

00:11:40.860 --> 00:11:42.280
highlight if that's needed.

00:11:42.500 --> 00:11:45.500
Point parameters,
both point parameters and point sprite

00:11:45.500 --> 00:11:49.720
are supported across certain hardware,
and that allows you to specify

00:11:49.840 --> 00:11:54.500
OpenGL either as points for like
a particle system or put a texture

00:11:54.500 --> 00:11:57.960
at that point and show the texture,
so you can do billboarding

00:11:57.980 --> 00:11:59.500
textures very simply.

00:12:00.200 --> 00:12:03.000
So, that completes kind of
what's new for Jaguar.

00:12:03.000 --> 00:12:06.100
We think that we really have
a great OpenGL and one of the

00:12:06.100 --> 00:12:08.880
driving factors behind some of
the improvements has been some of

00:12:08.880 --> 00:12:12.070
the research that Nvidia has done,
including the Wolfman demo.

00:12:12.190 --> 00:12:14.320
We need to make sure that we
have all the features there,

00:12:14.320 --> 00:12:17.040
we can run this,
and I guarantee that what you have in

00:12:17.040 --> 00:12:21.100
your seed is exactly what we have up
here on stage running the Wolfman demo.

00:12:21.100 --> 00:12:24.300
So all the features that Simon's
going to talk about are in Jaguar,

00:12:24.300 --> 00:12:27.100
in the seed,
and are planned for the final release.

00:12:27.100 --> 00:12:30.280
So, without further ado,
Simon Green from Nvidia to talk

00:12:30.280 --> 00:12:32.100
about the anatomy of the Wolfman.

00:12:40.590 --> 00:12:41.890
Thank you, Geoff.

00:12:42.140 --> 00:12:45.300
So I'm not sure if I'd really
consider myself a celebrity,

00:12:45.310 --> 00:12:47.550
but I do work for NVIDIA.

00:12:47.640 --> 00:12:49.500
I actually work in the demo team.

00:12:49.500 --> 00:12:51.440
For those of you that
aren't familiar with that,

00:12:51.490 --> 00:12:55.800
NVIDIA actually has an internal group
whose job it is basically to create

00:12:55.910 --> 00:12:58.500
demos that show off NVIDIA's hardware.

00:12:58.560 --> 00:13:01.920
So today I'm going to be talking a
little bit about the Wolfman demo,

00:13:01.920 --> 00:13:03.500
the anatomy of the Wolfman.

00:13:03.500 --> 00:13:07.460
And it's all about the advanced
fur rendering techniques

00:13:07.460 --> 00:13:09.500
that we used using OpenGL.

00:13:09.510 --> 00:13:12.810
And that's a little
preview of the sound there.

00:13:17.640 --> 00:13:21.160
So we have a little motto
in the NVIDIA demo team.

00:13:21.230 --> 00:13:24.600
We make the marketing lies come true.

00:13:24.760 --> 00:13:27.490
Now that's really just a joke,
but it has a serious point behind it.

00:13:27.650 --> 00:13:32.210
Because when NVIDIA comes out
with a new piece of hardware,

00:13:32.210 --> 00:13:35.320
we always have a number of new features.

00:13:35.320 --> 00:13:38.750
So it's very much our job to
demonstrate those new features,

00:13:38.750 --> 00:13:42.590
demonstrate what you can do
with the extra performance

00:13:42.590 --> 00:13:45.440
that the new product provides.

00:13:45.440 --> 00:13:47.560
It doesn't really matter
how good your technology is.

00:13:47.560 --> 00:13:50.420
If you don't have something
that demonstrates it and shows

00:13:50.540 --> 00:13:54.250
developers what's possible,
it's really not worth anything.

00:13:54.370 --> 00:13:56.790
So that's our little motto.

00:13:59.230 --> 00:14:01.500
Okay, so I'm going to give you
a brief overview here.

00:14:01.650 --> 00:14:07.150
So the Wolfman was one of four
GeForce 4 demos that we had at launch,

00:14:07.150 --> 00:14:10.290
and it was actually running on
the Macintosh on OS X at our

00:14:10.290 --> 00:14:12.200
launch event in San Francisco.

00:14:12.200 --> 00:14:15.900
And as I said,
the main reason for these demos is really

00:14:15.900 --> 00:14:21.310
to showcase the performance and also
the programmability of the GeForce 4,

00:14:21.410 --> 00:14:25.390
because GeForce 4 had several new
features that kind of enhanced

00:14:25.840 --> 00:14:28.200
the programmability of the part.

00:14:28.390 --> 00:14:33.700
Clearly, the main focus of the Werewolf
demo was to demonstrate this

00:14:33.710 --> 00:14:36.200
volumetric fur rendering.

00:14:36.200 --> 00:14:39.200
And the whole thing was animated
using the vertex shaders,

00:14:39.200 --> 00:14:41.190
and I'll talk about that a little later.

00:14:41.410 --> 00:14:46.200
And also the lighting was done using the
pixel shader technology that we have.

00:14:46.300 --> 00:14:49.140
And the whole thing is also,
as Geoff mentioned,

00:14:49.140 --> 00:14:51.200
is shadowed using shadow maps.

00:14:51.350 --> 00:14:57.200
And it runs using OpenGL with
NVIDIA extensions.

00:14:57.200 --> 00:14:59.160
So how did we do it?

00:15:02.500 --> 00:15:04.610
So before we get to that, first of all,
why fur?

00:15:04.870 --> 00:15:10.010
There were lots of different
demos we could have done.

00:15:10.310 --> 00:15:12.620
But if you look in the real world,
a lot of things in the

00:15:12.620 --> 00:15:13.690
real world are fuzzy.

00:15:13.820 --> 00:15:18.880
It's very easy to do plastic and very
hard materials in computer graphics,

00:15:19.010 --> 00:15:24.440
but it's much harder to do things that
are kind of fluffy or fuzzy or hairy,

00:15:24.440 --> 00:15:27.200
those kind of general effects.

00:15:28.270 --> 00:15:30.650
In addition to that,
fur wasn't something that people

00:15:30.650 --> 00:15:32.170
had seen in real time very much.

00:15:32.210 --> 00:15:35.340
There had been a couple of
Microsoft demos with some quite

00:15:35.350 --> 00:15:39.440
simple fur rendering techniques,
but people hadn't seen it before on a

00:15:39.440 --> 00:15:42.200
kind of fully animated character model.

00:15:42.350 --> 00:15:45.390
So we thought that would
be a cool thing to try.

00:15:47.030 --> 00:15:48.640
So how do you render fur?

00:15:48.970 --> 00:15:50.860
Well, there are two basic methods.

00:15:50.870 --> 00:15:53.090
The first method is probably
the most obvious one,

00:15:53.090 --> 00:15:55.020
and that's just to use geometry.

00:15:55.050 --> 00:15:58.510
So clearly fur is made up of
a number of different kind of,

00:15:58.510 --> 00:16:01.820
well, a lot of hair strands, basically.

00:16:01.860 --> 00:16:03.900
So the most obvious way to
model it is just with geometry.

00:16:03.900 --> 00:16:08.100
So for each individual hair in the fur,
you basically just draw a curve,

00:16:08.110 --> 00:16:11.110
and that curve would be
made up of line strips,

00:16:11.110 --> 00:16:12.170
basically.

00:16:13.400 --> 00:16:17.570
So the obvious problem with that method
is there's a lot of hairs in fur,

00:16:17.570 --> 00:16:18.230
right?

00:16:18.250 --> 00:16:20.300
I don't know how many of
you have seen Monsters,

00:16:20.300 --> 00:16:23.060
Inc., the Pixar movie,
but apparently the Sully

00:16:23.060 --> 00:16:26.160
character in that actually has
three million hairs on him.

00:16:26.370 --> 00:16:29.190
So, you know, our hardware's good,
but it's not quite at the point

00:16:29.570 --> 00:16:32.280
where it can actually render
three million individual hairs

00:16:32.280 --> 00:16:34.670
and light them in real time.

00:16:34.710 --> 00:16:38.570
So instead, we actually used what's
known as a volumetric method.

00:16:38.570 --> 00:16:44.070
And the basic idea behind this is the
fur is represented using textures.

00:16:44.100 --> 00:16:47.880
So rather than using geometry,
you're using images.

00:16:47.880 --> 00:16:52.010
And it kind of approximates the kind of
gross look of the fur without actually

00:16:52.460 --> 00:16:54.820
having to draw each individual hair.

00:16:54.850 --> 00:16:56.020
So that's the method that we use.

00:16:58.130 --> 00:17:03.240
So I'm just going to give you a little
brief history of fur rendering here.

00:17:03.240 --> 00:17:07.180
Probably the first and most influential
reference in the literature to

00:17:07.280 --> 00:17:11.110
do with fur rendering is this
paper called "Rendering Fur with

00:17:11.110 --> 00:17:16.150
Three-Dimensional Textures." This is one
that Jim Kajir did back in SIGGRAPH 1989.

00:17:16.150 --> 00:17:19.570
And, you know, 1989 is a long time ago
in computer graphics.

00:17:19.570 --> 00:17:22.970
It's very much the kind of
golden age of computer graphics,

00:17:22.970 --> 00:17:24.660
so this is a pretty old paper.

00:17:24.820 --> 00:17:28.410
So the basic idea here was that
rather than using geometry,

00:17:28.410 --> 00:17:33.900
you just represent the density of
the fur using a 3D volume texture.

00:17:33.900 --> 00:17:36.740
And that basically just means
if you imagine an image and just

00:17:36.740 --> 00:17:40.080
generalize it into three dimensions,
you have a volume texture.

00:17:40.100 --> 00:17:42.410
So rather than having
a 2D array of pixels,

00:17:42.540 --> 00:17:46.560
you have a 3D array of what actually
he called "texels," although

00:17:46.570 --> 00:17:49.340
that's a slightly confusing term
because we now also use "texels"

00:17:49.340 --> 00:17:51.920
to mean pixels within textures.

00:17:51.920 --> 00:17:54.320
But that's just a detail.

00:17:54.320 --> 00:17:57.320
His other main contribution was this
idea of actually lighting the hairs

00:17:57.510 --> 00:17:59.020
based on the tangent direction.

00:17:59.030 --> 00:18:02.900
Now, all the tangent direction means is
that's just the direction that each

00:18:02.900 --> 00:18:04.810
individual hair strand is pointing in.

00:18:07.300 --> 00:18:15.960
So what he did with all this was he
did quite a cool image of a teddy bear.

00:18:15.960 --> 00:18:15.960
And if I go on

00:18:16.200 --> 00:18:18.020
I can show you that picture.

00:18:18.020 --> 00:18:19.880
And as you can see,
it's a very nice image.

00:18:19.880 --> 00:18:24.480
And in some ways,
the fur rendering here is better quality

00:18:24.480 --> 00:18:26.700
than the stuff that we do in real time.

00:18:26.850 --> 00:18:30.120
But you have to bear in mind that
this was rendered on a network

00:18:30.120 --> 00:18:35.160
of 16 IBM mainframes in total,
or at least there were 16 processors.

00:18:35.160 --> 00:18:38.700
And it took two hours just
to create this one image.

00:18:38.850 --> 00:18:45.060
So it's nice, but it took a lot of time,
and it's a long way from being real time.

00:18:46.610 --> 00:18:49.690
So now we're going to
jump ahead 10 years or so.

00:18:49.690 --> 00:18:52.780
This was the next major
paper on fur rendering.

00:18:52.800 --> 00:18:57.000
This paper called "Real-time
Fur Over Arbitrary Surfaces" by a guy

00:18:57.000 --> 00:19:00.500
called Jed Lengel at Microsoft Research.

00:19:00.500 --> 00:19:04.500
He introduced this concept
of shell and fin rendering.

00:19:04.500 --> 00:19:06.500
I'll get into what exactly
that means later on.

00:19:06.500 --> 00:19:11.500
But the basic idea is you
create these concentric shells.

00:19:11.500 --> 00:19:17.220
Imagine taking the base polygon mesh of
the character and then extruding it out

00:19:17.280 --> 00:19:20.500
to create a number of concentric shells.

00:19:20.500 --> 00:19:24.500
It's kind of like a Russian doll
with one inside the other.

00:19:24.500 --> 00:19:28.020
Then you texture each of those
shells with a different image,

00:19:28.030 --> 00:19:30.490
and that approximates the fur volume.

00:19:30.490 --> 00:19:32.490
We'll talk about that more later on.

00:19:32.500 --> 00:19:36.780
The second part is this idea of fins,
which is basically just extra

00:19:36.970 --> 00:19:40.490
geometry that you use to
improve the silhouette edge.

00:19:40.500 --> 00:19:44.020
The image that he created,
or at least the most

00:19:44.020 --> 00:19:49.470
famous one that he created,
was this furry bunny rabbit right here.

00:19:49.630 --> 00:19:54.100
And you can see, again,
this is a pretty impressive image.

00:19:54.360 --> 00:19:59.130
This, I think,
had about 5,000 polygons in it.

00:19:59.400 --> 00:20:02.600
And he was actually running
this on the original GeForce.

00:20:02.600 --> 00:20:04.600
It was like a GeForce DDR.

00:20:04.770 --> 00:20:07.560
And I believe it ran at
about 12 frames a second.

00:20:07.560 --> 00:20:08.600
So pretty good.

00:20:08.600 --> 00:20:11.600
I mean, interactive,
but not as fast as it could be.

00:20:11.660 --> 00:20:14.980
And you can see there isn't really
much in the way of lighting on the fur,

00:20:15.110 --> 00:20:15.510
either.

00:20:15.590 --> 00:20:18.600
It looks relatively flat.

00:20:18.600 --> 00:20:20.700
There's no kind of gloss to it.

00:20:22.450 --> 00:20:27.540
So we decided we wanted to do a fur demo,
but teddy bears and bunnies,

00:20:27.540 --> 00:20:29.190
they're really not NVIDIA's style.

00:20:29.430 --> 00:20:33.080
So we had a meeting and we were
thinking about different things.

00:20:33.140 --> 00:20:37.400
We considered doing a gorilla,
we considered doing a yeti,

00:20:37.400 --> 00:20:39.400
the Sasquatch.

00:20:39.450 --> 00:20:42.380
But in the end we decided on a werewolf.

00:20:42.460 --> 00:20:45.050
So this is actually one of
the concept sketches that our

00:20:45.050 --> 00:20:46.400
artist Daniel Hornick did.

00:20:46.400 --> 00:20:49.570
And I have to give full credit
for him because these demos are

00:20:49.570 --> 00:20:51.190
really all about the artwork.

00:20:51.400 --> 00:20:54.410
If it wasn't for the art,
you'd probably be looking

00:20:54.410 --> 00:20:57.530
at a furry Taurus,
or maybe a furry teapot,

00:20:57.560 --> 00:21:00.180
rather than the furry werewolf right now.

00:21:02.200 --> 00:21:04.910
Okay, so now I'm going to go ahead
and actually show you the demo,

00:21:04.910 --> 00:21:08.110
so if we can switch to that machine.

00:21:11.300 --> 00:21:15.940
I'm not sure how many of
you have seen this before,

00:21:15.940 --> 00:21:18.780
but this is our werewolf demo.

00:21:21.210 --> 00:21:23.960
As you can see, he just kind of happily
walks along this street.

00:21:23.960 --> 00:21:28.110
He has a number of different
animations that he goes through.

00:21:28.900 --> 00:21:32.790
This is very much the money shot here,
I think,

00:21:32.800 --> 00:21:34.490
where he does the howl at the moon.

00:21:34.500 --> 00:21:37.660
If I just wait a little while.

00:21:43.150 --> 00:21:45.860
There's several interesting things
that you should be looking at here.

00:21:45.970 --> 00:21:48.070
First of all, the fur itself.

00:21:48.180 --> 00:21:51.190
If we just pause it here,
you notice there's a pretty

00:21:51.190 --> 00:21:55.030
convincing sense of furriness here.

00:21:55.150 --> 00:21:59.760
You notice when I move
the light around here,

00:21:59.760 --> 00:22:04.620
you notice that there's a very
subtle sheen that goes across

00:22:04.620 --> 00:22:06.040
the fur as we move the light.

00:22:06.040 --> 00:22:09.940
That's all done using the
pixel shader hardware,

00:22:09.940 --> 00:22:13.040
and I'll talk about that in a minute.

00:22:15.700 --> 00:22:20.800
The second obvious thing is the whole
scene is shadowed using shadow maps.

00:22:20.830 --> 00:22:25.010
So you notice as the werewolf
walks past the lights here,

00:22:25.010 --> 00:22:28.070
he is casting shadows
not only on the ground,

00:22:28.070 --> 00:22:30.080
but actually on his body as well.

00:22:30.080 --> 00:22:34.340
If I run it in slow motion here,
you notice there is, for instance,

00:22:34.350 --> 00:22:34.960
a shadow.

00:22:36.100 --> 00:22:41.090
There is a shadow of his arm on his leg,
for instance.

00:22:41.140 --> 00:22:44.100
So, you know,
his body is casting shadows on itself,

00:22:44.100 --> 00:22:48.190
not just on the ground.

00:22:49.800 --> 00:22:52.640
The other major feature we're
showing off here is bump mapping.

00:22:52.640 --> 00:22:57.170
Now, other demos have done this,
but if you look at the quality of

00:22:57.240 --> 00:23:01.530
the bump mapping on his face here,
you'll see there's a lot of detail

00:23:01.600 --> 00:23:03.800
if we look at the wireframe.

00:23:03.880 --> 00:23:09.030
One of our marketing guys described this
as an irresponsible use of polygons.

00:23:09.030 --> 00:23:11.820
I think that's an apt description.

00:23:11.820 --> 00:23:16.120
When you look at the wireframe and
it just looks completely white,

00:23:16.120 --> 00:23:18.370
that's really what we aim for.

00:23:18.570 --> 00:23:20.490
But if you look at the
geometry on the face here,

00:23:20.490 --> 00:23:23.900
you'll notice that a lot of that
detail really comes from the bump map.

00:23:23.940 --> 00:23:27.010
It's not in the geometry itself.

00:23:36.230 --> 00:23:41.950
Okay, so that gives you an idea
of what the demo looks like.

00:23:49.050 --> 00:23:52.140
If we can switch back to the slides.

00:23:52.140 --> 00:23:54.050
Oh, we're on.

00:23:54.550 --> 00:23:56.720
So just a few statistics about that.

00:23:56.850 --> 00:24:01.390
There are about 100,000 polygons in
the model and the scene in total.

00:24:01.490 --> 00:24:03.500
So it's saying 100,000
polygons per frame.

00:24:03.500 --> 00:24:06.610
And the demo runs at
about 30 frames a second.

00:24:06.620 --> 00:24:09.790
So it's pretty fast.

00:24:11.870 --> 00:24:14.090
So, rendering fur with shells and fins.

00:24:14.130 --> 00:24:16.750
So how do you actually
use this technique?

00:24:16.780 --> 00:24:19.340
So as I said earlier,
the basic idea is to generate these

00:24:19.470 --> 00:24:23.800
concentric shells by scaling the base
skin mesh along the vertex normal.

00:24:23.800 --> 00:24:27.300
Now, I'm not sure how familiar you
people are with 3D graphics,

00:24:27.510 --> 00:24:29.800
but that's a relatively
simple thing to do.

00:24:29.800 --> 00:24:33.800
Once you have the polygon mesh,
you just duplicate it several times

00:24:33.800 --> 00:24:35.800
and scale it along the vertex normal.

00:24:35.800 --> 00:24:39.620
Perhaps later on we might go back
to the demo and I can actually show

00:24:39.720 --> 00:24:41.800
you it within the demo as well.

00:24:41.880 --> 00:24:46.170
So once you have these shells,
you texture each shell with a

00:24:46.170 --> 00:24:51.790
separate 2D texture that describes
a slice through the fur geometry.

00:24:51.900 --> 00:24:55.720
So you have this fur geometry
that describes all the individual

00:24:55.790 --> 00:24:59.180
pieces of hair in the fur,
and then you generate these

00:24:59.180 --> 00:25:01.800
2D textures that kind of slice
it through that geometry.

00:25:01.800 --> 00:25:05.780
So once you have those fur textures,
you apply them to the shells,

00:25:05.890 --> 00:25:11.510
you blend it all together using blending,
and that gives you the final result

00:25:11.510 --> 00:25:14.800
of this semi-transparent furry volume.

00:25:14.800 --> 00:25:21.540
And one other trick that you can use to
kind of improve the illusion of depth,

00:25:21.640 --> 00:25:26.410
if you like, is to just shade the lower
layers in the fur a little bit

00:25:26.410 --> 00:25:27.800
darker than the top layers.

00:25:27.800 --> 00:25:31.930
And that kind of simulates
the self-shadowing of the fur,

00:25:31.930 --> 00:25:36.800
because clearly light doesn't get
so deep into the lower layers.

00:25:36.970 --> 00:25:40.800
And in this demo,
we actually just used eight layers.

00:25:40.800 --> 00:25:43.800
Now, you could use more,
but clearly for each extra layer you use,

00:25:43.800 --> 00:25:44.800
that decreases the bit of depth.

00:25:44.800 --> 00:25:47.770
So we experimented
with different numbers,

00:25:47.800 --> 00:25:50.200
but eight was the best kind
of balance between the look of

00:25:50.300 --> 00:25:51.800
the fur and the performance.

00:25:51.800 --> 00:25:54.400
So you might be asking
yourself the question,

00:25:54.470 --> 00:25:56.790
how do you create these fur textures?

00:25:56.800 --> 00:26:01.480
And we spent quite a lot of time on this,
and we ended up actually doing

00:26:01.490 --> 00:26:04.800
a special kind of custom tool
just to generate the fur.

00:26:04.800 --> 00:26:08.400
A lot of the initial demos we had
just used very simple fur that

00:26:08.400 --> 00:26:10.790
looked very kind of combed and flat.

00:26:10.800 --> 00:26:12.580
And, you know,
we decided that wasn't really the

00:26:12.580 --> 00:26:13.780
look we wanted for a werewolf.

00:26:13.880 --> 00:26:14.800
You know, you have to have a lot of hair.

00:26:14.800 --> 00:26:18.710
You expect werewolf fur to be
more kind of matted and dirty.

00:26:18.810 --> 00:26:21.190
So we actually came up with
this fur design tool that,

00:26:21.210 --> 00:26:25.010
you know, enabled us to kind of
tweak the fur parameters,

00:26:25.010 --> 00:26:26.800
like the curly nurse.

00:26:26.800 --> 00:26:29.500
And, you know,
you can kind of apply noise to it to

00:26:29.500 --> 00:26:31.780
basically kind of make it more random.

00:26:31.890 --> 00:26:35.910
And this is a screenshot of the tool,
and you can kind of see the

00:26:35.910 --> 00:26:37.800
sliders at the top there.

00:26:40.360 --> 00:26:43.130
So I just went through most of this.

00:26:43.140 --> 00:26:48.790
The hairs themselves are actually defined
something like using a particle system.

00:26:48.870 --> 00:26:54.000
So that just means that they're kind
of points moving almost under gravity.

00:26:54.100 --> 00:26:59.120
And that's what we use to kind of define
the path that each individual hair takes.

00:26:59.310 --> 00:27:01.010
And then in the tool,
those hairs are previewed

00:27:01.060 --> 00:27:02.200
using line strips.

00:27:02.250 --> 00:27:05.100
And then once you're happy
with the look of the fur,

00:27:05.100 --> 00:27:07.960
you press a button and it
actually voxelizes that

00:27:07.960 --> 00:27:11.910
geometry into a volume texture,
and then it writes out

00:27:11.910 --> 00:27:13.890
those textures to disk.

00:27:14.340 --> 00:27:18.860
So this is what those fur
textures actually look like.

00:27:20.180 --> 00:27:23.590
You can see, so 0 to 7 here,
this is actually going up

00:27:23.590 --> 00:27:24.680
through the fur volume.

00:27:24.780 --> 00:27:28.100
So you can see at level 0 there,
they just look like a lot of kind of

00:27:28.210 --> 00:27:31.070
small points because the hairs are
kind of pointing straight upwards.

00:27:31.100 --> 00:27:33.690
And then as we go up,
they kind of move over,

00:27:33.690 --> 00:27:35.890
the fur is kind of combed to the right.

00:27:36.180 --> 00:27:41.100
So as we move up through those textures,
you kind of see more and more of the fur.

00:27:41.100 --> 00:27:44.490
And then by the time we get to level 7,
a lot of the hairs

00:27:44.490 --> 00:27:46.100
have kind of faded out.

00:27:46.100 --> 00:27:50.100
So as we go up through the volume,
the density decreases.

00:27:50.100 --> 00:27:54.420
So we actually used relatively
small fur textures in this demo,

00:27:54.420 --> 00:27:57.100
just 256 by 256 pixels.

00:27:57.100 --> 00:28:00.770
And the main reason for that is
because fur is relatively random,

00:28:00.770 --> 00:28:04.200
you can actually repeat it
several times over the surface,

00:28:04.200 --> 00:28:07.100
and you don't really notice
that it's a repeating pattern.

00:28:07.100 --> 00:28:10.100
And it's good to keep textures small
because it also improves the texture.

00:28:10.100 --> 00:28:15.100
It improves the kind of cache coherency
in the texture mapping hardware.

00:28:15.710 --> 00:28:18.680
So we use 256 by 256.

00:28:18.750 --> 00:28:21.290
And what you're actually
seeing in these images here

00:28:21.710 --> 00:28:23.810
is actually the alpha channel.

00:28:23.810 --> 00:28:26.390
So that represents the
density of the fur,

00:28:26.490 --> 00:28:28.600
effectively,
how much fur there is at any one point.

00:28:28.960 --> 00:28:33.400
What you're not seeing is the
RGB components of the texture,

00:28:33.680 --> 00:28:37.600
which actually store a
per pixel tangent vector.

00:28:37.600 --> 00:28:41.020
So that basically describes
which direction each individual

00:28:41.130 --> 00:28:42.600
fur strand is pointing in.

00:28:42.690 --> 00:28:45.970
And we use that to do the lighting,
which is what gives the fur

00:28:45.980 --> 00:28:47.600
that kind of glossy look.

00:28:48.950 --> 00:28:51.900
So this is just an image
of the fur without any kind

00:28:51.900 --> 00:28:53.440
of color or lighting on it.

00:28:53.440 --> 00:28:57.710
And you can see it looks pretty good,
but it's very, it looks like an albino

00:28:57.710 --> 00:29:00.080
wolf or something.

00:29:00.100 --> 00:29:02.780
So if we go on to the next image here.

00:29:03.290 --> 00:29:06.320
So to give the fur color,
we actually use this fur,

00:29:06.320 --> 00:29:08.740
a totally separate fur color texture.

00:29:08.740 --> 00:29:12.540
And this fur color texture
covers the whole of the surface,

00:29:12.740 --> 00:29:16.700
whereas the fur textures
themselves are repeated like,

00:29:16.700 --> 00:29:18.700
you know, ten times over each surface.

00:29:18.760 --> 00:29:21.860
The fur color texture covers the whole
surface and allows us to kind of,

00:29:21.860 --> 00:29:27.070
you know, give it this colored,
kind of striped look.

00:29:27.510 --> 00:29:31.260
So when you put the fur textures together
with the color texture and the lighting,

00:29:31.270 --> 00:29:33.920
you get something that looks like that.

00:29:37.790 --> 00:29:42.350
So there's only one problem with
using this shells technique.

00:29:42.350 --> 00:29:45.050
And as you can imagine,
when you look at the

00:29:45.360 --> 00:29:47.430
shells from the side,
especially on the

00:29:47.440 --> 00:29:49.780
silhouette of the character,
you start to see the gaps

00:29:49.930 --> 00:29:51.290
between those shells.

00:29:51.440 --> 00:29:53.700
And I'll show you what that
looks like in a second.

00:29:53.760 --> 00:29:58.920
So the solution that Jed Langell came
up with to improve this was to add

00:29:59.010 --> 00:30:01.700
this geometry that he calls fins.

00:30:01.700 --> 00:30:05.560
And they're called fins because literally
they kind of stick out from the surface.

00:30:05.700 --> 00:30:09.700
And the way we generate this
geometry is we basically just,

00:30:09.700 --> 00:30:12.700
for each edge in the
original polygon mesh,

00:30:12.700 --> 00:30:15.960
we create an additional quadrangle
that just kind of sticks

00:30:15.960 --> 00:30:17.700
up straight from that mesh.

00:30:17.700 --> 00:30:21.460
And these fins are textured
with a totally separate image

00:30:21.580 --> 00:30:23.860
that just has a kind of,
you know,

00:30:24.020 --> 00:30:26.650
generic cross section of the fur in it.

00:30:26.700 --> 00:30:32.670
I'll show you what that
looks like in a minute.

00:30:32.920 --> 00:30:34.180
Now,
there's several ways you could do this.

00:30:34.310 --> 00:30:39.020
You could try and dynamically generate
these fins just on the silhouette,

00:30:39.130 --> 00:30:41.130
but that would be quite expensive.

00:30:41.170 --> 00:30:44.880
So, it turns out the easiest way to do it
is just to create fins everywhere in

00:30:44.880 --> 00:30:48.840
the model and then just fade them in
and out based on the angle between the

00:30:48.840 --> 00:30:52.330
surface normal and the view direction,
so that they only --

00:30:52.330 --> 00:30:55.560
they're always there,
but they only appear on

00:30:55.560 --> 00:30:57.400
the silhouette edges.

00:30:57.430 --> 00:31:01.570
So, this is what the actual
fin texture looks like.

00:31:05.520 --> 00:31:09.120
Okay, so we're just going to step
through a few images here.

00:31:09.220 --> 00:31:12.000
This is just a close-up
of the werewolf's arm,

00:31:12.110 --> 00:31:15.190
and you can see the polygon mesh there.

00:31:15.540 --> 00:31:21.180
This is what it looks like with the first
shells that I was talking about earlier.

00:31:21.180 --> 00:31:25.760
You can see they're just
copies of the base mesh,

00:31:25.880 --> 00:31:29.570
but just extruded out
along the vertex normal.

00:31:31.610 --> 00:31:34.220
And then finally we add the fins in it,
and it's a little hard to see

00:31:34.240 --> 00:31:38.300
where the fins really are there,
but you can see that they kind of poke

00:31:38.370 --> 00:31:40.600
out from the silhouette of the character.

00:31:43.660 --> 00:31:45.740
So when you put it all together,
it looks something like that.

00:31:45.820 --> 00:31:48.770
And in this image, at the edges here,
you do start to see the

00:31:48.830 --> 00:31:50.600
gaps between the shells.

00:31:50.710 --> 00:31:54.520
And it's pretty obvious that
the fins and the shells aren't

00:31:54.520 --> 00:31:56.290
really perfectly lined up.

00:31:56.660 --> 00:31:58.790
But when you look at
that from a distance,

00:31:58.790 --> 00:31:59.940
you really can't tell.

00:32:00.300 --> 00:32:03.120
So it's, like all computer graphics,
it's a hack, right?

00:32:03.140 --> 00:32:05.290
It's an illusion, but...

00:32:05.900 --> 00:32:18.590
It works.

00:32:18.590 --> 00:32:18.590
So actually at this point
I might just switch back to the,

00:32:18.590 --> 00:32:18.590
to demo machine three if I could.

00:32:18.590 --> 00:32:18.590
Because this stuff is
easier to understand.

00:32:24.200 --> 00:32:29.800
[Transcript missing]

00:32:35.780 --> 00:32:38.700
So I'm going to try and zoom up here
and show you actually how the fur works.

00:32:38.700 --> 00:32:42.890
So first of all,
I'm going to switch off the fins,

00:32:42.890 --> 00:32:46.190
and I'm going to remove
all the fur layers.

00:32:47.280 --> 00:32:53.610
So this is what a naked werewolf looks
like if you're into that kind of thing.

00:32:54.110 --> 00:32:58.490
One of the slightly crazy things
actually is that even underneath his fur,

00:32:58.490 --> 00:33:02.050
this werewolf is bump mapped,
which may seem a bit over the top,

00:33:02.050 --> 00:33:04.750
but you can see as
I move the light around,

00:33:04.800 --> 00:33:08.200
you can see all his ribs
there and his spine.

00:33:12.910 --> 00:33:15.400
So I'm going to add back in
the fur layers one by one.

00:33:15.400 --> 00:33:17.680
You can kind of see the
effect that each one has.

00:33:17.780 --> 00:33:18.950
So that's the base layer.

00:33:19.150 --> 00:33:22.300
That's level zero that we
saw in the images earlier.

00:33:22.420 --> 00:33:25.050
Yeah,
it doesn't really look like fur yet.

00:33:25.120 --> 00:33:30.790
So that's layer 1, 2, 3, 4, 5, 6, 7.

00:33:31.400 --> 00:33:34.290
So you can see as you add in the layers,
you get more and more depth.

00:33:34.310 --> 00:33:38.050
And we can also kind of
scale the layers between,

00:33:38.070 --> 00:33:40.280
or scale the distance
between each of those shells.

00:33:40.280 --> 00:33:46.440
You know, this gives the well something
of a kind of blow-dried look,

00:33:46.490 --> 00:33:48.130
I always think.

00:33:49.690 --> 00:33:54.240
But yeah, if you go too far,
then the illusion is really shattered,

00:33:54.240 --> 00:33:59.990
so we usually keep it
relatively modest like that.

00:34:00.200 --> 00:34:03.140
So this is without fins,
and you can see that

00:34:03.140 --> 00:34:04.510
if you get too close,

00:34:04.800 --> 00:34:28.200
[Transcript missing]

00:34:28.900 --> 00:34:32.040
So you see, because the light is
behind the character here,

00:34:32.040 --> 00:34:37.230
the fins are lit in such a way that
they actually receive light from behind,

00:34:37.230 --> 00:34:43.830
so it gives him a nice kind of rim
lighting highlight around his edge there.

00:34:45.920 --> 00:34:50.030
Okay, so hopefully that gives you a
good idea of how the FUR works.

00:34:50.060 --> 00:34:54.090
We can switch back to the slides.

00:34:59.450 --> 00:35:02.690
Okay, so how do we model and
animate this character?

00:35:02.820 --> 00:35:07.950
So the whole thing was modeled in Maya,
which is, of course,

00:35:07.960 --> 00:35:09.320
now available on OS X.

00:35:09.400 --> 00:35:12.300
So you can all rush home and
model your own werewolves.

00:35:12.300 --> 00:35:14.400
There's no excuse.

00:35:14.400 --> 00:35:17.440
One of the interesting things
about our workflow is we do

00:35:17.440 --> 00:35:19.910
model everything as NURBS,
NURBS surfaces,

00:35:19.980 --> 00:35:22.400
which are a curved surface description.

00:35:22.400 --> 00:35:25.630
And the nice thing about that is it kind
of gives us the flexibility to change

00:35:25.640 --> 00:35:27.360
the number of polygons in the model.

00:35:27.620 --> 00:35:32.470
So we model it as NURBS,
and then once it looks good,

00:35:32.470 --> 00:35:33.400
we then convert it to polygons.

00:35:33.400 --> 00:35:37.000
And then if we later decide that
we can get away with more polygons,

00:35:37.070 --> 00:35:40.390
or perhaps we need to scale
back and we need fewer polygons,

00:35:40.390 --> 00:35:43.400
then we can just change
the tessellation in Maya,

00:35:43.400 --> 00:35:46.400
and it'll generate that
many polygons for us.

00:35:46.400 --> 00:35:49.400
So it is nice to have that flexibility.

00:35:49.420 --> 00:35:51.400
The base mesh of the character
I showed you is a little bit different.

00:35:51.420 --> 00:35:55.360
The base mesh of the character I showed
you has about 20,000 polygons in total.

00:35:55.470 --> 00:35:58.400
Now, not all of those, as you noticed,
are furry.

00:35:58.400 --> 00:36:01.400
Not everywhere on the werewolf is furry,
mainly his back and his arms,

00:36:01.400 --> 00:36:03.400
and there's a bit on the legs.

00:36:03.500 --> 00:36:06.230
So when you take those polygons
and multiply them by eight,

00:36:06.230 --> 00:36:09.400
that's where the 100,000
polygons comes from.

00:36:10.330 --> 00:36:12.360
Now, as for the animation,
the whole thing is

00:36:12.360 --> 00:36:17.050
animated using a skeleton,
and that skeleton has 61 bones in it.

00:36:17.160 --> 00:36:21.460
So, you know, all the spine, the arm,
the legs, and it even has, like,

00:36:21.460 --> 00:36:23.580
all the fingers and thumbs.

00:36:23.680 --> 00:36:27.670
So, you know, if we wanted to,
this werewolf could play the piano.

00:36:27.840 --> 00:36:33.720
An interesting thing that our artists
pointed out to me is that in some ways

00:36:33.750 --> 00:36:38.920
these characters are comparable to
the complexity that people are using

00:36:39.300 --> 00:36:40.800
in film and television production.

00:36:40.800 --> 00:36:45.800
The number of polygons perhaps isn't,
but the character setup is.

00:36:45.830 --> 00:36:51.220
In total there were about a thousand
frames of animation that was keyframed

00:36:51.250 --> 00:36:56.980
by an animator that we contracted,
and it runs at 30 frames a second.

00:36:57.340 --> 00:37:02.480
So this is just a quick
screenshot of the Wolfman in Maya.

00:37:02.480 --> 00:37:05.620
You can see the skeleton
there and the fingers.

00:37:05.920 --> 00:37:11.720
The yellow surfaces that you see are
the surfaces that we applied fur to.

00:37:12.100 --> 00:37:15.040
And the red ones, I think,
are just the surfaces

00:37:15.040 --> 00:37:16.660
that weren't skinned.

00:37:16.700 --> 00:37:19.910
So that means they don't
actually bend at all,

00:37:19.910 --> 00:37:23.430
like the claws are always
just static objects.

00:37:23.990 --> 00:37:27.700
So that's what our werewolf
looks like in Maya.

00:37:27.800 --> 00:37:30.980
So once we have this stuff in Maya,
you may be asking the question,

00:37:31.000 --> 00:37:37.240
how do we make it run in real time?

00:37:37.240 --> 00:37:38.820
In the demo team,
we actually have our own

00:37:38.820 --> 00:37:45.960
proprietary NVIDIA demo engine,
which we imaginatively call NVDemo.

00:37:46.110 --> 00:37:50.220
This is used for all of the in-house,
well, pretty much most of the demos

00:37:50.230 --> 00:37:52.760
that we do in-house at NVIDIA.

00:37:52.760 --> 00:37:55.650
And it basically provides us
with a scene graph library.

00:37:55.730 --> 00:37:59.610
So this is something that kind of
manages all the lights and materials

00:38:00.120 --> 00:38:02.770
and cameras and all that kind of stuff.

00:38:02.810 --> 00:38:05.800
And it also, it takes care of managing
all that scene data,

00:38:06.170 --> 00:38:09.480
also doing stuff like
culling and sorting.

00:38:09.520 --> 00:38:14.630
Basically all that kind of tedious
legwork that you have to do when you're

00:38:14.720 --> 00:38:18.500
doing a real time 3D application.

00:38:18.500 --> 00:38:21.410
And the other big part of it is we
also have a Maya plug-in that will

00:38:21.470 --> 00:38:25.710
take the data from Maya and convert
the geometry and the lights and the

00:38:25.760 --> 00:38:30.640
materials to our own custom file format,
which is then loaded into the demo

00:38:30.650 --> 00:38:32.820
engine for display in real time.

00:38:35.000 --> 00:38:38.750
Okay, so how do we actually
make this werewolf move?

00:38:38.960 --> 00:38:41.990
So all the animation is
done using vertex shaders.

00:38:42.110 --> 00:38:45.410
And I believe in previous
sessions they have talked about

00:38:45.410 --> 00:38:46.900
vertex programs a little bit.

00:38:46.900 --> 00:38:50.900
So I'm not going to go into
too much technical detail here.

00:38:50.940 --> 00:38:52.900
But vertex shaders are really cool.

00:38:52.900 --> 00:38:58.820
So they basically give you total control
over the hardware processing of geometry.

00:38:58.950 --> 00:39:00.900
So you can do your own transformations.

00:39:00.900 --> 00:39:03.810
You can do your own
lighting calculations.

00:39:03.860 --> 00:39:06.900
If you want to do some
weird kind of deformation,

00:39:06.900 --> 00:39:10.890
you can basically write
that code yourself.

00:39:10.900 --> 00:39:15.170
And it's exposed as a relatively
simple assembly language,

00:39:15.600 --> 00:39:17.900
which does scare off some people.

00:39:17.900 --> 00:39:19.900
But I personally like
writing in assembly language,

00:39:19.900 --> 00:39:19.900
but that's just my personal preference.

00:39:20.900 --> 00:39:24.460
But one interesting thing is
there are going to be higher

00:39:24.530 --> 00:39:26.900
level languages coming out soon.

00:39:26.900 --> 00:39:30.960
There's OpenGL 2.0 and there's
various other efforts that

00:39:31.100 --> 00:39:32.880
are going on at this point.

00:39:32.900 --> 00:39:36.710
So at some point you will be able to
write in a C-like language and then

00:39:36.710 --> 00:39:40.840
it will be compiled to the actual
vertex program assembly language.

00:39:40.900 --> 00:39:46.720
So we use vertex shaders in the
werewolf demo for several things.

00:39:47.240 --> 00:39:48.760
First of all to do the skinning.

00:39:48.900 --> 00:39:50.890
I'm going to talk about a
little bit about the skinning.

00:39:50.900 --> 00:39:54.790
I'm going to talk a little bit about
what skinning is about in a minute.

00:39:55.010 --> 00:39:58.540
But basically that's the
process of making the skin

00:39:58.540 --> 00:40:00.900
deform as the skeleton moves.

00:40:01.830 --> 00:40:06.900
Secondly, for scaling the fur layers
along the vertex normal,

00:40:07.120 --> 00:40:10.510
that's actually a very important thing,
but it's a very simple thing

00:40:10.590 --> 00:40:11.460
to do in a vertex shader.

00:40:11.460 --> 00:40:15.810
That's just a single instruction that
takes the vertex position and basically

00:40:16.240 --> 00:40:21.690
adds a fraction of the normal onto that
position for each of the fur layers.

00:40:21.700 --> 00:40:25.600
Thirdly,
we use vertex shaders for the setup

00:40:26.180 --> 00:40:31.570
calculations for the per-pixel
lighting for the bump mapping and

00:40:31.740 --> 00:40:34.700
for the fur shader that you saw.

00:40:34.700 --> 00:40:37.590
Lastly,
we use it to do the text coordinate

00:40:37.590 --> 00:40:40.220
generation for the shadow mapping.

00:40:40.640 --> 00:40:44.280
So I don't think I'm going to go
through this in too much detail,

00:40:44.280 --> 00:40:48.760
but this is just a little extract
from one of the vertex programs

00:40:48.880 --> 00:40:51.500
that we used in the werewolf demo.

00:40:52.130 --> 00:40:55.030
And it starts off with the skinning.

00:40:55.030 --> 00:40:59.240
So what we do here is we're
actually using a technique called

00:40:59.240 --> 00:41:00.780
matrix palette skinning here.

00:41:00.830 --> 00:41:05.600
So that means there's several matrices,
and then for each vertex there's

00:41:05.600 --> 00:41:10.700
an index which describes which of
those matrices we're going to use.

00:41:10.810 --> 00:41:15.040
So anyway, so basically we transform
the vertex by the first bone,

00:41:15.210 --> 00:41:19.400
and then we also have to transform
the normal by that bone matrix.

00:41:19.540 --> 00:41:26.100
And each of these is weighted as well,
so that's what those moles there do.

00:41:26.170 --> 00:41:28.930
We also have to do that
for binormals as well,

00:41:28.930 --> 00:41:32.600
which is part of how the
per pixel lighting is done.

00:41:32.780 --> 00:41:38.140
So next you see we have the MAD here,
and that's what does the scaling

00:41:38.140 --> 00:41:44.280
of the vertex along the normal,
and that's just a single instruction.

00:41:44.640 --> 00:41:47.140
Next, we actually have to project
that vertex to the screen.

00:41:47.140 --> 00:41:52.430
So these four DP4s actually take
that coordinate in I-space and

00:41:52.430 --> 00:41:56.330
then transform it to clip space.

00:41:56.950 --> 00:42:00.830
So once we've actually figured
out the position of the vertex,

00:42:00.830 --> 00:42:04.400
we have to do some calculations
to figure out the lighting.

00:42:04.520 --> 00:42:08.000
So we work out the view vector,
so that's basically the vector

00:42:08.000 --> 00:42:13.040
from the eye to the position of
the vertex that we're lighting.

00:42:13.150 --> 00:42:15.030
So we work that out.

00:42:16.850 --> 00:42:20.350
Then we work out the half-angle vector.

00:42:20.360 --> 00:42:25.030
This is a kind of standard
way of doing Blinn shading.

00:42:25.290 --> 00:42:29.570
It's basically a vector that's
halfway between the eye vector and

00:42:29.670 --> 00:42:33.330
the light direction in this case.

00:42:33.720 --> 00:42:36.360
We have to transform
that into tangent space.

00:42:36.360 --> 00:42:38.730
I'm not going to go into
a huge amount of detail,

00:42:38.750 --> 00:42:39.470
as I said earlier.

00:42:39.600 --> 00:42:42.100
But basically,
once we've done all that setup,

00:42:42.140 --> 00:42:47.350
we take those values and we
store them in the output colors.

00:42:49.100 --> 00:42:53.750
So that gives you a feel, at least,
for what a real vertex program

00:42:53.750 --> 00:42:57.760
looks like and the kind

00:42:58.570 --> 00:43:02.250
So the first part of the code there
that we saw was doing the skinning.

00:43:02.600 --> 00:43:06.790
So the justification behind skinning is,
you know,

00:43:06.790 --> 00:43:11.630
we want to have a smooth skin that
covers the whole of the character,

00:43:11.740 --> 00:43:12.380
right?

00:43:12.380 --> 00:43:15.910
And we want that skin to move
as the character animates.

00:43:16.080 --> 00:43:18.620
Now,
there are several ways you could do that.

00:43:18.620 --> 00:43:21.460
You can imagine the easiest way to
do it would just be to store the

00:43:21.460 --> 00:43:25.380
positions of each of those vertices
for every frame in the animation,

00:43:25.380 --> 00:43:25.710
right?

00:43:25.710 --> 00:43:27.380
And that would give you
a lot of flexibility.

00:43:27.380 --> 00:43:29.790
You know,
you could do muscles bulging and have

00:43:29.790 --> 00:43:31.420
jiggle and all that kind of stuff.

00:43:31.420 --> 00:43:34.390
But that would be a very
expensive way of doing it,

00:43:34.430 --> 00:43:40.540
both in terms of storage -- actually,
mainly just in terms of storage.

00:43:40.970 --> 00:43:45.890
So the idea behind skinning is
rather than storing all that data,

00:43:45.980 --> 00:43:49.800
we basically just store a
static skin for the character.

00:43:49.800 --> 00:43:51.720
And then we animate the skeleton.

00:43:51.780 --> 00:43:55.130
So the skeleton is what
I showed you earlier in Maya.

00:43:55.400 --> 00:44:00.620
So we animate the skeleton and we use the
skeleton to deform the skin in real time.

00:44:00.740 --> 00:44:05.320
And the vertex shading hardware
of the GeForce 4 is actually doing

00:44:05.320 --> 00:44:07.300
that deformation in real time.

00:44:07.300 --> 00:44:10.210
So the basic idea is,
as we saw in the code,

00:44:10.210 --> 00:44:15.300
is you transform each vertex by
multiple different transformations.

00:44:15.400 --> 00:44:19.280
And they're basically the
transformations of the nearby bones.

00:44:19.300 --> 00:44:24.210
So if you imagine in a werewolf's arm,
this position on his skin is clearly

00:44:24.710 --> 00:44:30.050
affected by the bone of the forearm
here and also by this kind of upper arm

00:44:30.060 --> 00:44:31.290
bone and maybe the shoulder as well.

00:44:31.300 --> 00:44:36.110
So the final position of the vertex
is basically a kind of weighted

00:44:36.110 --> 00:44:39.300
blend between those transformations.

00:44:39.570 --> 00:44:44.300
And we store those weights
actually with each vertex.

00:44:44.300 --> 00:44:45.300
And we store those weights
actually with each vertex.

00:44:45.300 --> 00:44:49.300
There are tools within Maya where you
can actually paint vertex weightings.

00:44:49.300 --> 00:44:53.290
And most Maya users are
familiar with this technique.

00:44:53.300 --> 00:44:59.300
I think it's called smooth
skinning within Maya itself.

00:45:01.000 --> 00:45:03.580
One of the things about skinning is
it's always a lot of fun to debug

00:45:04.020 --> 00:45:06.880
because when you're--it's one of
those things where either you get

00:45:06.880 --> 00:45:09.190
it right or it's totally broken.

00:45:09.300 --> 00:45:12.820
So this is just a funny image,
which is one of the--where

00:45:12.820 --> 00:45:14.530
the skinning went wrong.

00:45:14.720 --> 00:45:18.560
I must confess I had nightmares
about this for weeks afterwards.

00:45:18.610 --> 00:45:20.990
It's something about the way his
hand is kind of distorted and he

00:45:20.990 --> 00:45:22.460
has these really long fingers.

00:45:22.840 --> 00:45:27.300
Yeah,
I still can't look at that actually.

00:45:27.750 --> 00:45:33.000
This is another kind of one
of these outtake images.

00:45:33.000 --> 00:45:34.470
This actually wasn't a bug in the code.

00:45:34.470 --> 00:45:37.830
This was because the animator we had,
Geoff Bell, who did a great job,

00:45:37.900 --> 00:45:42.020
by the way, was more of a kind of
traditional 2D animator.

00:45:42.120 --> 00:45:44.180
So he was animating
this character in Maya,

00:45:44.180 --> 00:45:46.380
mainly looking at it from the side.

00:45:46.380 --> 00:45:48.620
So he wasn't really, you know,
from the view you're

00:45:48.620 --> 00:45:51.070
normally looking at it at,
it's not clear that the hand was

00:45:51.190 --> 00:45:53.480
actually going through its face.

00:45:53.480 --> 00:45:56.840
But when we looked at it from this angle,
it was a lot more obvious

00:45:56.920 --> 00:46:00.400
that that wasn't a good
position for his hand to be in.

00:46:02.450 --> 00:46:03.640
Okay,
so now we're going to go on and talk

00:46:03.640 --> 00:46:06.350
about pixel shaders a little bit.

00:46:06.510 --> 00:46:12.150
Again, I'm not sure how much experience
you guys have with pixel shaders,

00:46:12.150 --> 00:46:12.150
but...

00:46:12.260 --> 00:46:18.080
The basic idea is pixel shaders offer you
programmability at the per pixel level.

00:46:18.130 --> 00:46:21.480
Now, at this point in time,
they're not quite as flexible

00:46:21.490 --> 00:46:22.480
as the vertex shaders.

00:46:22.580 --> 00:46:26.420
You have some control over what
you can do with pixels and you can

00:46:26.510 --> 00:46:29.260
do a lot of blending operations,
but it's more of a kind of

00:46:29.260 --> 00:46:33.010
configurable hardware than
actual programmability per se.

00:46:33.200 --> 00:46:38.040
Now, in OpenGL on NVIDIA hardware,
pixel shaders are exposed

00:46:38.250 --> 00:46:40.190
using two extensions.

00:46:40.190 --> 00:46:43.070
The first one is MVTextureShader.

00:46:43.070 --> 00:46:45.600
Now,
that's what gives you control over the

00:46:45.600 --> 00:46:48.200
kind of texture addressing operations.

00:46:48.350 --> 00:46:50.980
So you can do dependent texture lookups.

00:46:51.050 --> 00:46:55.310
That is kind of using the results
of one texture lookup to affect the

00:46:55.310 --> 00:46:58.160
lookup in a subsequent texture lookup.

00:46:58.200 --> 00:47:00.860
And you can also do things
like you can do dot products

00:47:01.300 --> 00:47:03.190
between texture coordinates.

00:47:03.200 --> 00:47:05.200
You can do that by adding color values.

00:47:05.200 --> 00:47:09.410
So quite often you use that for lighting.

00:47:09.600 --> 00:47:11.130
The nice thing about
texture shader as well,

00:47:11.290 --> 00:47:14.880
everything happens in
floating point precision.

00:47:14.910 --> 00:47:18.870
So you have a much more precise result.

00:47:18.890 --> 00:47:23.380
The second part of pixel shaders
in OpenGL on NVIDIA hardware is

00:47:23.510 --> 00:47:26.900
the NV register combiner extension.

00:47:27.130 --> 00:47:33.080
Now, this is basically a programmable
means of combining texture

00:47:33.180 --> 00:47:35.000
and color results together.

00:47:35.210 --> 00:47:39.980
And it's actually very flexible on the
GeForce 4 because you actually have

00:47:40.090 --> 00:47:43.000
eight combiner stages that you can use.

00:47:43.000 --> 00:47:47.000
So that means that there's a lot of math
you can do in the register combiners.

00:47:47.050 --> 00:47:51.680
And the anisotropic lighting model that
you saw on the fur there was actually

00:47:51.780 --> 00:47:53.940
all done in the register combiners.

00:47:54.000 --> 00:47:57.720
The only disadvantage of the
register combiners is that they

00:47:57.720 --> 00:47:59.990
happen in fixed point precision.

00:48:00.000 --> 00:48:02.990
So I think it's actually
a nine bit precision.

00:48:03.000 --> 00:48:05.000
But they are very, very fast.

00:48:05.000 --> 00:48:07.000
So that's the kind of trade-off.

00:48:08.700 --> 00:49:13.300
[Transcript missing]

00:49:15.110 --> 00:49:19.780
OK, so let's talk a bit about shadows.

00:49:19.780 --> 00:49:22.000
Everything in the demo is
shadowed using shadow maps.

00:49:22.000 --> 00:49:26.220
For those of you that aren't
familiar with shadow maps,

00:49:26.220 --> 00:49:29.710
shadow maps are the same technique
that are like Pixar used,

00:49:29.710 --> 00:49:34.000
for instance,
in "Renderman" to do all their shadows.

00:49:34.000 --> 00:49:39.000
The great thing about shadow maps is
that they're an image space technique.

00:49:39.000 --> 00:49:44.000
You may also be familiar
with stencil shadow volumes,

00:49:44.000 --> 00:49:47.140
which can be a great way of doing
your shadows for some applications.

00:49:47.140 --> 00:49:52.330
But the great thing about shadow
maps is that because they're

00:49:52.420 --> 00:49:58.120
an image space technique,
all you have to do is one extra pass.

00:49:59.500 --> 00:50:02.260
As I say here,
the other good thing is that

00:50:02.360 --> 00:50:05.040
performance is linear with
the complexity of the scene.

00:50:05.040 --> 00:50:08.500
You really don't have to do any
kind of pre-processing of the scene.

00:50:08.500 --> 00:50:12.500
If you can render something,
then you can shadow it.

00:50:12.500 --> 00:50:16.980
They are relatively easy to
implement once you have the code

00:50:16.980 --> 00:50:19.850
for reading back the depth buffer.

00:50:20.970 --> 00:50:24.510
Now, in OpenGL,
the shadow mapping hardware on

00:50:24.510 --> 00:50:30.590
the GeForce 3 and 4 are exposed
using the GL ARB Shadow extension.

00:50:30.680 --> 00:50:35.090
There was also--this demo is
actually using the SGIX extension,

00:50:35.090 --> 00:50:37.590
which provides pretty much
the same functionality,

00:50:37.710 --> 00:50:42.720
but that functionality is now being
rolled into the ARB Shadow extension.

00:50:43.340 --> 00:50:47.300
The only disadvantages of using
shadow maps are the aliasing.

00:50:47.300 --> 00:50:50.760
You might have noticed in the demo that
I showed you that you do occasionally see

00:50:50.760 --> 00:50:54.300
some kind of blockiness in the shadows.

00:50:54.300 --> 00:50:58.300
That's just not a fact of the fact
that it is an image space technique.

00:50:58.300 --> 00:51:01.300
Where the shadow map
texture is magnified,

00:51:01.300 --> 00:51:06.400
you are going to start seeing
those kind of magnified textiles.

00:51:08.200 --> 00:51:12.280
So I'm just going to briefly go
over the shadow map algorithm here.

00:51:12.380 --> 00:51:15.720
So as I said,
the first pass when you're using

00:51:15.720 --> 00:51:19.110
shadow maps is to render the scene
from the light's point of view.

00:51:19.510 --> 00:51:22.020
So if you imagine where the
lights were in that scene,

00:51:22.020 --> 00:51:24.460
the street lights,
we're actually in a separate

00:51:24.900 --> 00:51:27.870
pass rendering the scene from
that light's point of view,

00:51:27.870 --> 00:51:30.880
kind of looking down on
the werewolf at the street.

00:51:31.380 --> 00:51:37.060
So, once we've done that render,
we copy the depth information.

00:51:37.060 --> 00:51:38.880
And that's an interesting point,
because you only really

00:51:38.880 --> 00:51:39.900
need the depth values.

00:51:39.900 --> 00:51:44.300
You don't have to render color or
textures or any of that kind of stuff.

00:51:44.300 --> 00:51:47.250
You just copy the depth
information to a texture.

00:51:47.290 --> 00:51:51.770
So that texture basically
is our shadow map texture.

00:51:52.630 --> 00:51:55.370
So in the second pass,
when we're actually drawing

00:51:55.370 --> 00:51:58.450
the character with color,
we project that shadow map

00:51:58.450 --> 00:52:01.710
texture back onto the scene,
and this is using projective

00:52:01.750 --> 00:52:06.330
texturing in OpenGL,
which is a fairly well-known technique.

00:52:06.380 --> 00:52:09.280
And if you look in your OpenGL Redbook,
it will explain how

00:52:09.280 --> 00:52:10.960
projective texturing works.

00:52:11.050 --> 00:52:14.390
And I should also mention that
if you go to the NVIDIA website,

00:52:14.660 --> 00:52:18.730
we do have a lot of examples and a
lot of presentations about how to

00:52:18.730 --> 00:52:22.460
do shadow mapping and how to use
pixel shaders and vertex shaders.

00:52:23.130 --> 00:52:27.150
But anyway, you project that shadow map
texture back onto the scene,

00:52:27.150 --> 00:52:29.990
and then the hardware
actually does this comparison.

00:52:29.990 --> 00:52:34.510
So it does a comparison between the depth
of the pixel that you're rendering at

00:52:34.520 --> 00:52:38.930
that point and the corresponding depth
from the point of view of the light.

00:52:39.000 --> 00:52:41.680
So I really should have
had a diagram here,

00:52:41.680 --> 00:52:48.910
but the basic idea is if the value in
the shadow map is less than the depth

00:52:48.970 --> 00:52:52.800
value of the pixel we're rendering,
then that means that there must be

00:52:52.800 --> 00:52:54.800
something between us and the light.

00:52:54.800 --> 00:52:59.790
So therefore,
the point we're looking at is shadowed.

00:53:00.000 --> 00:53:03.630
On the other hand,
if those values are roughly equal,

00:53:03.660 --> 00:53:06.300
that means there's nothing in the way
and therefore the point is visible,

00:53:06.300 --> 00:53:08.400
so we're unshallowed.

00:53:09.900 --> 00:53:11.110
So that's how shadow maps work.

00:53:11.270 --> 00:53:16.000
And they're a great technique,
and I recommend you use them.

00:53:16.900 --> 00:53:21.750
So here I just thought I'd give you
a little bit of a look into what

00:53:21.750 --> 00:53:24.620
the actual pixel shader code does.

00:53:24.620 --> 00:53:28.920
Now, there are various different ways
of expressing pixel shaders,

00:53:29.000 --> 00:53:33.370
and I've actually just given you pseudo
code here because the actual register

00:53:33.430 --> 00:53:37.800
combiner setup code would be very long
and it would fill like pages and pages.

00:53:37.990 --> 00:53:41.840
So this is really just pseudo code,
but it gives you a good idea of

00:53:42.010 --> 00:53:45.800
basically how we're doing the
bump mapping in the werewolf demo.

00:53:46.800 --> 00:53:51.040
So I showed you a lot of the
kind of textures that were

00:53:51.720 --> 00:53:54.300
kind of made up for earlier,
but this is concentrating

00:53:54.350 --> 00:53:54.760
on the bump mapping.

00:53:54.820 --> 00:53:57.800
So in texture zero we have the color map.

00:53:57.930 --> 00:54:00.700
So that's basically just
the color of the surface.

00:54:00.930 --> 00:54:05.160
One interesting detail is the
alpha channel of that color map

00:54:05.250 --> 00:54:07.660
contains a kind of shininess map.

00:54:07.690 --> 00:54:11.790
So that basically represents
how shiny each point is.

00:54:11.860 --> 00:54:14.740
So, for instance,
on the mouth of the werewolf,

00:54:14.740 --> 00:54:18.060
we want that to look wet and shiny,
so that would have a very

00:54:18.060 --> 00:54:19.270
high shininess value.

00:54:19.280 --> 00:54:22.670
I'll actually show you some
of the textures later on.

00:54:22.780 --> 00:54:26.280
So in texture unit one,
we have the bump map.

00:54:26.360 --> 00:54:28.690
In actual fact, it's a normal map,
and I'll show you what that

00:54:28.730 --> 00:54:29.700
looks like in a second.

00:54:29.700 --> 00:54:34.050
In texture unit two,
we actually have special

00:54:34.050 --> 00:54:38.690
texture that encodes the,
it's not really a Phong specular map,

00:54:38.740 --> 00:54:41.700
actually, it's more of a kind of Phong,
Phong-Blin specular map.

00:54:41.900 --> 00:54:47.900
But that basically determines how
the light interacts with the surface,

00:54:47.900 --> 00:54:51.700
and how big the specular highlight looks.

00:54:51.730 --> 00:54:54.590
So if you look at that texture,
it basically just encodes a curve,

00:54:54.590 --> 00:54:56.700
a kind of power curve
that goes up like this.

00:54:57.680 --> 00:55:00.600
and Texture 3 contains a shadow map.

00:55:00.620 --> 00:55:06.430
So, one of the cool things
about the GeForce 4 was that

00:55:06.580 --> 00:55:09.360
It actually exposed a new
texture-shadow operation,

00:55:09.360 --> 00:55:14.240
which meant that we could do the
color map and bump map with specular

00:55:14.620 --> 00:55:19.500
in just three texture units,
whereas previously it took four.

00:55:19.620 --> 00:55:21.830
That allowed us to also
include a shadow map,

00:55:21.830 --> 00:55:24.730
so for the first time we
could actually do color map,

00:55:24.920 --> 00:55:28.500
bump map stuff with a shadow
map all in a single path.

00:55:28.610 --> 00:55:31.840
That's what we're using in the demo here.

00:55:34.640 --> 00:55:38.450
So, in the primary and secondary colors,
we send down the light direction

00:55:38.530 --> 00:55:39.780
and the half-angle vector.

00:55:39.900 --> 00:55:43.300
And then basically in
the register combiners,

00:55:43.410 --> 00:55:50.170
we're computing the diffuse lighting,
so that just computes n.l, basically.

00:55:50.300 --> 00:55:53.080
That gives you your diffuse lighting.

00:55:53.230 --> 00:55:54.690
Then we calculate the shadow factor.

00:55:54.800 --> 00:55:58.200
One of the things you'll come across
with shadows is you don't want your

00:55:58.200 --> 00:56:00.700
shadows to look completely black.

00:56:01.110 --> 00:56:04.300
Although, in the real world,
that's how they would be.

00:56:04.300 --> 00:56:06.490
If you have a point light up
here and something's in the way,

00:56:06.660 --> 00:56:08.560
then this part is completely black.

00:56:09.130 --> 00:56:14.700
There's a lot of ambient lighting that
we're not really simulating in real time.

00:56:14.700 --> 00:56:21.520
To compensate for that fact,
we make the shadows only slightly darken

00:56:21.630 --> 00:56:25.630
the color of the surface at that point.

00:56:26.000 --> 00:56:30.500
When something's in shadow,
it just gets 50% darker.

00:56:30.500 --> 00:56:32.500
It doesn't actually go to black.

00:56:32.630 --> 00:56:35.500
That's what that shadow
factor there means.

00:56:35.500 --> 00:56:40.290
Then we just multiply the diffuse
lighting by the color map.

00:56:40.970 --> 00:56:46.470
Now, at the same time,
the specular lighting is being

00:56:46.470 --> 00:56:50.080
computed in the texture shaders.

00:56:50.100 --> 00:56:52.660
So, the texture shaders,
if you look at the bottom here,

00:56:52.720 --> 00:56:55.750
are actually doing this dot
product texture 1D operation,

00:56:55.780 --> 00:56:59.230
which basically does a dot product
between the half angle vector that

00:56:59.230 --> 00:57:03.900
we sent down and the normal value
that came out of the normal map,

00:57:03.900 --> 00:57:07.900
and then looking up in a 1D texture
that kind of gives us the exponent.

00:57:07.900 --> 00:57:12.400
So, the 1D texture is what gives us
that to the power of p there.

00:57:12.400 --> 00:57:15.960
So, in the register combiners,
we take that specular value,

00:57:15.960 --> 00:57:20.400
we multiply it by the shininess,
and that gives us our specular lighting.

00:57:20.400 --> 00:57:24.670
And that's what gives you the kind
of highlights on the bump maps.

00:57:25.260 --> 00:57:31.030
So, and then, almost done,
we multiply both of those

00:57:31.160 --> 00:57:33.260
by the shadow factors.

00:57:33.960 --> 00:57:38.610
So one interesting thing is you do
want the specular term to completely

00:57:38.660 --> 00:57:41.350
disappear when the surface is in shadow.

00:57:41.370 --> 00:57:45.200
So you see we multiply the
diffuse by the shadow factor,

00:57:45.200 --> 00:57:47.660
and then we just multiply the
specular by the actual shadow

00:57:47.660 --> 00:57:51.300
value out of the shadow map,
which is just 0 or 1.

00:57:51.570 --> 00:57:53.400
And then finally, we do the fog.

00:57:53.500 --> 00:57:58.460
I'm not sure if you noticed in the demo,
but the street does actually

00:57:58.460 --> 00:58:00.500
kind of fog out to transparent.

00:58:00.500 --> 00:58:03.780
So that's what gives you that effect.

00:58:07.370 --> 00:58:10.320
Okay, so here I'm just going to show
you some of the texture maps

00:58:10.410 --> 00:58:13.300
that are used in the demo.

00:58:13.390 --> 00:58:16.910
These were all actually mainly
painted within Photoshop.

00:58:17.020 --> 00:58:21.300
We also used DeepPaint 3D for some work.

00:58:21.530 --> 00:58:24.020
But these are really,
really detailed maps.

00:58:24.110 --> 00:58:26.160
Some of these go up to 2K by 2K.

00:58:26.680 --> 00:58:30.540
One of the nice things,
GeForce 4 has 128 meg of memory,

00:58:30.600 --> 00:58:34.250
so you have plenty of memory to
waste on really big textures.

00:58:34.300 --> 00:58:37.300
So that's what the color map looks like.

00:58:37.320 --> 00:58:39.300
So this is obviously the
face we're looking at here.

00:58:39.300 --> 00:58:42.300
The eyes are separate surfaces,
so you don't see the eyes.

00:58:42.300 --> 00:58:46.650
The purple bit at the bottom
is actually the mouth.

00:58:47.380 --> 00:58:51.400
So this is the shininess map
that I was talking about earlier.

00:58:51.410 --> 00:58:54.760
So you can see the mouth is
almost completely white because we

00:58:54.760 --> 00:58:56.520
want that area to be very shiny.

00:58:56.520 --> 00:59:01.300
And the nostrils also tend to be a bit
kind of greasy and therefore shiny.

00:59:01.410 --> 00:59:08.160
And his eyes, well the eye sockets at
least aren't shiny at all.

00:59:09.520 --> 00:59:12.040
So this is what a normal map looks like.

00:59:12.160 --> 00:59:14.940
Now, for those of you who haven't
seen a normal map before,

00:59:15.100 --> 00:59:16.400
this probably looks a little bit unusual.

00:59:16.400 --> 00:59:20.310
The way this works is we
actually don't author these

00:59:20.360 --> 00:59:22.400
normal maps looking like this.

00:59:22.400 --> 00:59:24.400
We author them as
basically a height field.

00:59:24.400 --> 00:59:28.240
So they're just drawn as a black and
white image where black represents

00:59:28.710 --> 00:59:32.400
kind of a low part in the surface
and white represents a high part.

00:59:32.440 --> 00:59:35.440
And then we run them through a
special filter that kind of takes that

00:59:35.440 --> 00:59:39.230
height field and then works out what
the normal would be at each point.

00:59:39.490 --> 00:59:45.160
So, and then that normal is
encoded as an RGB color.

00:59:45.400 --> 00:59:47.400
So that's why this
looks a little unusual.

00:59:47.400 --> 00:59:50.680
The reason it's mainly blue is
because the normals are mainly

00:59:51.140 --> 00:59:52.790
pointing out of the page,
right,

00:59:52.790 --> 00:59:56.470
which means their Z value is very big,
and a big Z value translates

00:59:56.520 --> 00:59:57.960
to a big blue value.

00:59:57.960 --> 00:59:59.520
And so it mainly looks blue.

00:59:59.520 --> 01:00:03.010
And then depending on the
direction that normal is pointing,

01:00:03.010 --> 01:00:06.060
it'll have different amounts
of red and green in it.

01:00:06.140 --> 01:00:10.220
The other way you can think about
it is it's like it was a real

01:00:10.220 --> 01:00:12.120
surface that's lit with a red,
green,

01:00:12.200 --> 01:00:14.520
and a blue light in different positions.

01:00:14.520 --> 01:00:17.420
So that's what a normal map looks like.

01:00:19.080 --> 01:00:23.670
And then you put it all together and
that's what the final result looks like.

01:00:25.910 --> 01:00:27.610
So we're almost out of time here.

01:00:27.780 --> 01:00:32.900
Just a little few words about
future extensions to this technique.

01:00:33.070 --> 01:00:36.380
One of the things that we thought
about but didn't really have

01:00:36.380 --> 01:00:38.980
time for were the fur dynamics.

01:00:39.000 --> 01:00:43.980
It would have been nice to actually make
the fur move as the character animated.

01:00:44.020 --> 01:00:48.200
You could do this by moving the
shell geometry independently

01:00:48.200 --> 01:00:50.000
from the underlying skin.

01:00:50.020 --> 01:00:57.170
You could do that either based on a real
physical simulation or maybe just make

01:00:57.170 --> 01:00:59.990
it lag behind the skin a little bit.

01:01:00.000 --> 01:01:03.000
That's one of the really
cool things that Pixar do.

01:01:03.000 --> 01:01:08.000
Their fur has a full physics simulation
run on it so it bounces around.

01:01:08.000 --> 01:01:11.470
The other thing that's going to
be interesting on future hardware

01:01:11.470 --> 01:01:15.440
is this idea of ray marching,
which is basically similar to

01:01:15.580 --> 01:01:19.530
the shells and fins technique,
but you're actually doing all the

01:01:19.530 --> 01:01:21.000
blending within the pixel shader.

01:01:21.000 --> 01:01:24.920
I don't think it's any secret that
future hardware is going to be a

01:01:24.920 --> 01:01:28.850
lot more programmable and a lot
more flexible and a lot faster.

01:01:29.000 --> 01:01:32.560
You'll actually be able to do all
that blending within the pixel shader

01:01:32.560 --> 01:01:36.730
itself and actually march through a
3D texture to give you that illusion

01:01:36.730 --> 01:01:38.870
of depth without using the shells.

01:01:39.000 --> 01:01:42.670
The nice thing about that is that
reduces the amount of blending that

01:01:42.790 --> 01:01:46.000
you're having to do in the frame buffer,
which is very bandwidth intensive.

01:01:48.050 --> 01:01:52.000
And then lastly, the holy grail is just
to do with geometry.

01:01:52.000 --> 01:01:55.440
So just draw curves for each
individual strand of hair,

01:01:55.440 --> 01:01:55.930
as I said.

01:01:56.080 --> 01:01:58.260
But it's very hard to
do the anti-aliasing and

01:01:58.260 --> 01:01:59.960
the shadowing with that.

01:02:00.090 --> 01:02:02.010
But we'll get there.

01:02:03.310 --> 01:02:05.180
Okay, so just a final summary.

01:02:05.280 --> 01:02:10.940
Program of vertex and pixel shaders
allow you to control the hardware.

01:02:11.270 --> 01:02:15.340
And I think it is true in some
sense that real time and offline

01:02:15.340 --> 01:02:17.160
production rendering are converging.

01:02:17.670 --> 01:02:22.200
What people were doing offline
in movies a couple of years ago,

01:02:22.200 --> 01:02:26.180
we are kind of approaching
doing in real time now.

01:02:26.200 --> 01:02:28.130
And the tools are getting
a lot better as well,

01:02:28.230 --> 01:02:31.310
so it's becoming a lot easier to just
author something in Maya and then just

01:02:31.310 --> 01:02:33.130
display it in real time and animate it.

01:02:33.190 --> 01:02:38.200
So I think it's a very exciting
time for real time 3D graphics.

01:02:38.200 --> 01:02:42.030
One of the other interesting
things is that this programmable

01:02:42.110 --> 01:02:46.200
graphics hardware is not only
useful for graphics these days,

01:02:46.200 --> 01:02:53.290
not only games and those kind of things,
but also, as we've seen in the Jaguar

01:02:53.290 --> 01:02:56.660
UI work that's been done at Apple,
it's also very useful for doing

01:02:56.660 --> 01:02:58.200
2D operations as well now.

01:02:58.200 --> 01:03:05.170
2D imaging, filters, video processing,
and also user interfaces.

01:03:05.200 --> 01:03:05.200
In fact, people are even using pixel
shaders to do 3D rendering.

01:03:06.200 --> 01:03:07.180
And I think it's a really interesting
time for real time 3D rendering.

01:03:08.200 --> 01:03:10.760
And kind of simulation work as well,
doing kind of fluid

01:03:10.760 --> 01:03:12.060
dynamics in pixel shaders.

01:03:12.190 --> 01:03:15.000
So there's a lot of possibilities there.

01:03:15.330 --> 01:03:17.050
And as I said,
the next generation hardware

01:03:17.050 --> 01:03:19.200
is going to be faster,
even more programmable.

01:03:19.200 --> 01:03:22.200
So it's only going to get better.

01:03:22.200 --> 01:03:25.200
So, yeah,
you should start learning this stuff now.

01:03:27.200 --> 01:03:29.940
I don't want to make this sound
like an off-square speech,

01:03:29.940 --> 01:03:31.960
but I'm just going to
give a few credits here.

01:03:31.960 --> 01:03:34.190
Curtis Beeson and Joe Demers
did the engine code.

01:03:34.260 --> 01:03:38.200
Daniel Hornick did all the
modeling and texturing.

01:03:38.200 --> 01:03:40.180
Geoff Bell did the character animation.

01:03:40.230 --> 01:03:42.190
Ken Crete-Aditz, sound design.

01:03:42.190 --> 01:03:48.310
I just did some additional
code on the shaders.

01:03:48.310 --> 01:03:48.310
Mark Daly's my boss,
so I have to say thanks to him.

01:03:48.600 --> 01:03:51.430
And that's just another outtake
image where the werewolf's mouth for

01:03:51.430 --> 01:03:54.060
some reason popped out of his head.

01:03:56.000 --> 01:03:58.760
And there are some references,
should you want to pursue

01:03:58.760 --> 01:03:59.990
this in your own time.

01:04:00.000 --> 01:04:02.990
And that's all I have.

01:04:02.990 --> 01:04:03.840
Thank you.

01:04:10.930 --> 01:04:12.220
Thank you very much, Simon.

01:04:12.220 --> 01:04:15.540
I just want to mention
here a quick roadmap.

01:04:15.620 --> 01:04:20.740
This is a must-attend session, 5.1.4,
OpenGL Performance and Optimization.

01:04:20.790 --> 01:04:23.760
And the feedback forum
tomorrow afternoon,

01:04:23.930 --> 01:04:27.620
last session of the conference,
for you to let us know

01:04:27.620 --> 01:04:29.260
what else you need.

01:04:30.160 --> 01:04:34.350
Here's a couple of contacts,
Simon for NVIDIA and myself,

01:04:34.470 --> 01:04:38.400
Sergio at Apple.com,
for any inquiries you may have.
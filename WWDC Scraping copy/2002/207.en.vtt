WEBVTT

00:00:01.750 --> 00:00:05.750
Ladies and gentlemen,
please welcome Mac OS X evangelist,

00:00:05.800 --> 00:00:07.390
Xavier Legros.

00:00:11.700 --> 00:00:13.610
Hi everybody.

00:00:14.090 --> 00:00:14.560
Welcome back.

00:00:14.760 --> 00:00:18.050
Welcome to session 207,
Improving Performance with Carbon Events.

00:00:18.060 --> 00:00:19.420
So, great.

00:00:19.420 --> 00:00:22.120
You're all on Mac OS X now.

00:00:22.120 --> 00:00:23.500
You have a great Carbon application.

00:00:23.500 --> 00:00:25.240
Now, what's the next step?

00:00:25.340 --> 00:00:28.490
We showed you this morning about
where the toolbox is going,

00:00:28.520 --> 00:00:30.960
and we really hope that
you guys are going to take

00:00:31.130 --> 00:00:32.990
advantage of these new features.

00:00:33.000 --> 00:00:35.980
But there is something
that is very important.

00:00:35.980 --> 00:00:38.850
In order to be a good and
a great Mac OS X citizen,

00:00:38.850 --> 00:00:41.110
performance is very important.

00:00:41.910 --> 00:00:44.620
Carbon event is a way to achieve
a great level of performance.

00:00:44.620 --> 00:00:47.690
In this session,
we're going to talk about some of

00:00:47.700 --> 00:00:51.490
the pitfalls and some of the concepts
that Carbon developers have been

00:00:51.490 --> 00:00:56.050
using on Mac OS 9 that don't really
work well in this new environment.

00:00:56.060 --> 00:00:57.980
And for that...

00:01:00.080 --> 00:01:05.230
I'd like to introduce David McLeod,
who's not exactly the apparent slave,

00:01:05.230 --> 00:01:08.530
but works in the toolbox team,
and will take you through some

00:01:08.530 --> 00:01:11.740
of the main steps to make your
application a great Mac OS X citizen.

00:01:11.950 --> 00:01:14.520
Hey, David.

00:01:16.200 --> 00:01:17.100
Thank you.

00:01:17.100 --> 00:01:19.010
Thanks for sticking around
after those other sessions.

00:01:19.030 --> 00:01:23.840
Ed and Guy gave great sessions and
showed all the new features that we have,

00:01:23.900 --> 00:01:27.240
but all those features aren't very good
unless your application is performing.

00:01:27.240 --> 00:01:30.810
So what I'm going to try to show
you today is a few tips to use

00:01:30.810 --> 00:01:35.680
Carbon events to get some great
performance out of your applications.

00:01:38.050 --> 00:01:40.790
So just a quick overview of
what I'm going to talk about.

00:01:40.920 --> 00:01:44.080
First, I'm going to cover timers and how
to use them in your application,

00:01:44.080 --> 00:01:46.380
as opposed to doing pooling.

00:01:46.660 --> 00:01:49.120
Then I'm going to talk about mouse
tracking and mouse tracking regions.

00:01:49.120 --> 00:01:50.600
This is a new feature in Jaguar.

00:01:52.350 --> 00:01:55.740
Next, I'm going to talk about
Carbon events as notifications.

00:01:55.740 --> 00:01:59.330
It's kind of an overlooked
feature of Carbon events.

00:01:59.450 --> 00:02:01.790
After that,
I'm going to talk about tracking loops.

00:02:01.980 --> 00:02:07.390
What I mean by that is when you
watch the mouse for mouse down,

00:02:07.390 --> 00:02:07.390
mouse up,

00:02:07.500 --> 00:02:20.200
[Transcript missing]

00:02:20.320 --> 00:02:22.950
And also right at the end,
I have a few sort of unrelated to

00:02:23.000 --> 00:02:28.570
Carbon event tips sort of compiled based
on some feedback we got on mailing lists.

00:02:28.680 --> 00:02:30.690
So let's get right into it.

00:02:32.690 --> 00:02:34.360
What is a timer anyway?

00:02:34.390 --> 00:02:36.440
I'd just like to read off the slide here,
because I wrote that one

00:02:36.440 --> 00:02:39.480
and it's a really good,
really good definition.

00:02:39.580 --> 00:02:44.110
A Carbon event timer is a way to
request delayed execution of code.

00:02:45.020 --> 00:02:47.490
Now, Carbon event timers are a little
bit different than the timers you

00:02:47.520 --> 00:02:49.600
might have been used to in OS 9.

00:02:49.690 --> 00:02:52.640
They're not VBL tasks or
anything odd like that.

00:02:52.960 --> 00:02:54.870
They're controlled by the event loop.

00:02:55.010 --> 00:02:59.110
This is really important because
those other ways of doing timers,

00:02:59.180 --> 00:03:02.050
you couldn't really call into
the toolbox because you were

00:03:02.360 --> 00:03:04.550
accessing at interrupt time.

00:03:04.630 --> 00:03:08.660
So because they're
controlled by the event loop,

00:03:08.660 --> 00:03:13.090
you can call into any of
the HI toolbox APIs safely.

00:03:13.630 --> 00:03:16.100
They're time-based,
which is important because you can say,

00:03:16.140 --> 00:03:19.250
I would like something to
happen X seconds from now,

00:03:19.560 --> 00:03:23.780
or I would like something to happen
on a frequency of every half second,

00:03:23.870 --> 00:03:26.190
and not worry about ticks
or anything like that.

00:03:26.350 --> 00:03:28.920
It's all nice human-based time.

00:03:30.380 --> 00:03:33.860
And a nice side effect is that the
code stays with the implementation.

00:03:33.920 --> 00:03:38.800
You register an event timer with a
UPP that calls back into your code.

00:03:38.860 --> 00:03:42.290
So your timer activities can stay
with the rest of your implementation.

00:03:42.370 --> 00:03:46.290
It keeps everything
simple and easy to code.

00:03:48.900 --> 00:03:54.400
Primers are important with
respect to performance because

00:03:54.780 --> 00:03:57.260
The event loop is going
to do everything for you.

00:03:57.260 --> 00:03:59.760
So from your point of view,
there's no continuous checks to see

00:03:59.760 --> 00:04:02.440
if it's time for you to do something,
do an animation or do

00:04:02.740 --> 00:04:05.190
something for the user.

00:04:05.590 --> 00:04:10.500
There's no wasted time watching
for and processing null events.

00:04:10.500 --> 00:04:13.500
It eliminates all of that
time in the overhead entirely,

00:04:13.500 --> 00:04:14.420
so you don't have to worry about it.

00:04:16.860 --> 00:04:19.140
There are three kinds of timers.

00:04:19.140 --> 00:04:20.080
There's a one-shot timer.

00:04:20.080 --> 00:04:23.700
You just set it and later it occurs
and your callback happens once.

00:04:23.730 --> 00:04:26.950
There's a periodic timer.

00:04:27.300 --> 00:04:28.660
You set it.

00:04:28.660 --> 00:04:30.140
After a while, you get a callback.

00:04:30.140 --> 00:04:34.410
And then periodically afterwards,
with a regular frequency,

00:04:34.460 --> 00:04:37.810
your timer callback will get called.

00:04:38.110 --> 00:04:41.640
and there's a new kind of timer
in Jaguar called an idle timer.

00:04:41.640 --> 00:04:45.930
What an idle timer is,
I'll go into in detail in a second.

00:04:47.760 --> 00:04:51.080
So like I said, a one-shot timer,
it fires once.

00:04:51.160 --> 00:04:53.260
You set up a duration
when you first create it,

00:04:53.260 --> 00:04:56.210
say, you know,
I want to be called in two seconds or so.

00:04:57.850 --> 00:04:59.850
After it fires,
it doesn't get destroyed or

00:04:59.870 --> 00:05:04.350
removed from the timer loop,
from the event loop.

00:05:04.390 --> 00:05:06.920
Its duration is just set to forever,
so the next time it's going

00:05:06.920 --> 00:05:08.690
to happen is forever from now.

00:05:08.820 --> 00:05:12.190
What you can do is reset it
to refire at a later time.

00:05:12.600 --> 00:05:17.610
And, say you set a duration and
you change your mind before...

00:05:18.120 --> 00:05:19.640
That callback is called.

00:05:19.720 --> 00:05:22.290
You can chicken out or delay it
so that it happens at a later

00:05:22.300 --> 00:05:24.550
time and cancel it entirely.

00:05:24.640 --> 00:05:26.960
A good example of that
would be a dialogue.

00:05:26.960 --> 00:05:30.420
Say it comes up and no user
interaction happens for a while.

00:05:30.590 --> 00:05:33.000
You want to say,
I want this to go away after two minutes.

00:05:33.000 --> 00:05:36.810
You can just automatically
make it go away using a timer.

00:05:38.500 --> 00:05:42.080
Periodic timer is very
similar to one-shot timer.

00:05:42.080 --> 00:05:46.400
It happens, you set a duration and your
callback gets called once

00:05:46.400 --> 00:05:48.650
after the duration you specify.

00:05:48.800 --> 00:05:50.900
But then after that,
it gets called back again

00:05:50.900 --> 00:05:52.340
at specific intervals.

00:05:52.420 --> 00:05:54.150
And you can set the interval
to any time you want.

00:05:55.370 --> 00:05:58.960
Like the one-shot timer,
it can be delayed or

00:05:58.960 --> 00:06:01.530
cancelled before you,
before it actually gets executed.

00:06:01.590 --> 00:06:02.200
You have complete control over that.

00:06:02.310 --> 00:06:06.570
And a good example of this,
and maybe even a little known fact,

00:06:06.650 --> 00:06:09.270
is that we use timers everywhere in
the toolbox where there's animation.

00:06:09.280 --> 00:06:14.020
So when you see a pulsing button,
not throbbing,

00:06:14.110 --> 00:06:18.070
you see the chasing arrows, or, you know,
the

00:06:19.050 --> 00:06:20.000
There's another one.

00:06:20.000 --> 00:06:22.460
Progress Bar.

00:06:22.640 --> 00:06:25.120
I had to eliminate that one because
I say Progress Bar and nobody

00:06:25.120 --> 00:06:25.960
knows what I'm talking about.

00:06:26.000 --> 00:06:32.240
And lastly, the new kind of timer in
Jaguar called an idle timer.

00:06:32.930 --> 00:06:36.210
These you set to fire a certain duration
after the user becomes inactive.

00:06:36.360 --> 00:06:39.300
And what that means is when the
user stops moving the mouse around,

00:06:39.390 --> 00:06:42.940
or stops clicking the mouse,
or stops touching the keyboard.

00:06:43.690 --> 00:06:45.830
Like the other two,
it can be delayed or canceled

00:06:45.840 --> 00:06:47.280
before it gets called back.

00:06:47.360 --> 00:06:50.740
A good example of this would
be type ahead in a search

00:06:50.740 --> 00:06:51.580
field or something like that.

00:06:51.580 --> 00:06:56.490
You might not want to process all
the events the second the user types.

00:06:56.520 --> 00:06:57.520
You might want to wait.

00:06:57.520 --> 00:06:58.680
You might have a huge database.

00:06:58.680 --> 00:07:01.590
It might be a spell checker
lookup or something like that.

00:07:01.600 --> 00:07:04.290
You might want to make sure they're
good and settled on the letters

00:07:04.290 --> 00:07:08.300
they've typed and they've pressed
backspace enough times like I would.

00:07:08.300 --> 00:07:10.720
Another good example
would be input validation.

00:07:10.720 --> 00:07:13.410
You want to make sure what
they have in a text edit field,

00:07:13.410 --> 00:07:16.140
for example,
is what they're going to type before

00:07:16.140 --> 00:07:20.000
you validate whether it's good or bad
instead of doing it over and over.

00:07:22.510 --> 00:07:26.310
So let's just have a look
at what the APIs look like.

00:07:26.520 --> 00:07:28.490
Making a one-shot timer
is fairly straightforward.

00:07:28.570 --> 00:07:31.610
You call the API,
install event loop timer.

00:07:33.250 --> 00:07:36.830
The second parameter here,
10 times k event duration second,

00:07:36.910 --> 00:07:39.940
specifies the first time
that it's going to fire.

00:07:39.940 --> 00:07:42.940
So 10 seconds from this point,
my timer callback UPP is

00:07:43.250 --> 00:07:45.290
going to be called.

00:07:46.220 --> 00:07:49.230
The third parameter, zero,
just fire once,

00:07:49.280 --> 00:07:51.600
is what makes this a one-shot timer.

00:07:51.720 --> 00:07:54.360
So it's gonna fire once,
and then it doesn't have

00:07:54.360 --> 00:07:56.660
a refiring frequency.

00:07:56.830 --> 00:07:59.340
That's what's used to
make a periodic timer.

00:07:59.500 --> 00:08:02.290
It's the exact same API.

00:08:02.550 --> 00:08:05.220
In this case,
I used the same first fire time,

00:08:05.350 --> 00:08:07.260
10 times k event duration second.

00:08:07.260 --> 00:08:09.640
But you'll see the third
highlighted parameter,

00:08:09.680 --> 00:08:11.460
2 times k event duration second.

00:08:11.630 --> 00:08:15.570
That's the frequency with which
it will be called back after

00:08:15.640 --> 00:08:18.370
the first time it's called.

00:08:19.230 --> 00:08:38.490
and Idle Timer has its own API.

00:08:38.490 --> 00:08:38.490
We couldn't recycle those other
ones because it's a special kind.

00:08:38.490 --> 00:08:38.490
It's called Install Idle Timer.

00:08:38.490 --> 00:08:38.490
But all of the parameters are the same.

00:08:38.490 --> 00:08:38.490
You'll see the second parameter
is the first fire time again.

00:08:38.490 --> 00:08:38.490
And there's even a third parameter,
and the Idle Timer can be called with

00:08:38.490 --> 00:08:38.490
a frequency after it first starts.

00:08:40.440 --> 00:08:41.830
Just a little bit more
on event loop timers.

00:08:41.890 --> 00:08:43.800
There's a couple more
APIs that are important.

00:08:43.860 --> 00:08:48.340
Like I said with the one-shot timer,
after it fires, it does not go away.

00:08:48.380 --> 00:08:50.240
And you can reuse it afterwards.

00:08:50.240 --> 00:08:54.670
So what you can do is set event
loop timer next fire time.

00:08:55.330 --> 00:08:58.240
What happens with that is the
time gets set and it's just like

00:08:58.240 --> 00:08:59.660
the first time you installed it.

00:08:59.770 --> 00:09:06.050
This is also the way that you can
delay any of the timer callbacks.

00:09:06.300 --> 00:09:09.850
Lastly, if you want to remove an
event loop timer entirely,

00:09:09.850 --> 00:09:10.990
that's the API.

00:09:11.000 --> 00:09:14.390
We always have our creative names,
like Guy says.

00:09:14.720 --> 00:09:17.000
So I'd like to ask Curt Rothert,
another engineer on the

00:09:17.000 --> 00:09:21.160
High Level Toolbox team,
to come up and give us a demo.

00:09:21.160 --> 00:09:21.160
Curt?

00:09:25.840 --> 00:09:27.350
Thank you, David.

00:09:27.350 --> 00:09:31.700
So it's great that you can move
your application up to Mac OS X,

00:09:31.700 --> 00:09:35.620
but it's more important that you
be a good citizen on the system.

00:09:35.620 --> 00:09:38.620
It's really important
in terms of performance.

00:09:38.620 --> 00:09:43.450
One thing that I typically would do when
I'd write a wait-next-event application

00:09:43.490 --> 00:09:47.560
is I would be lazy or not want to
necessarily calculate the sleep time

00:09:47.560 --> 00:09:50.260
necessary when I need to be called back.

00:09:50.600 --> 00:09:54.300
And so if you saw the session 203
on migrating to Carbon events,

00:09:54.300 --> 00:09:57.660
I was really trying to push home
to get off of wait-next-event for

00:09:57.660 --> 00:09:59.570
your null event idle processing.

00:09:59.570 --> 00:10:01.700
So what can you do instead?

00:10:01.700 --> 00:10:04.120
Well,
timers are an excellent way of doing it.

00:10:04.190 --> 00:10:05.620
I just want to demonstrate.

00:10:05.620 --> 00:10:09.460
I don't always believe everything that
I hear until I actually see it in action.

00:10:09.460 --> 00:10:12.190
So I just wanted to demonstrate
what's going on here.

00:10:12.830 --> 00:10:17.180
So, I have this application and
I'm using WaitNext Event with

00:10:17.240 --> 00:10:18.460
a sleep timeout of zero.

00:10:18.530 --> 00:10:22.780
Because I may not know when
I want to be called back or

00:10:22.900 --> 00:10:24.290
I need to do some calculations.

00:10:24.310 --> 00:10:25.790
There's some overhead
associated with that.

00:10:25.820 --> 00:10:28.350
Like I get the current
tick counts and I say,

00:10:28.360 --> 00:10:32.100
"Ooh, I want to be called back in a third
of a second or so." And so I add

00:10:32.100 --> 00:10:33.610
the appropriate ticks to that.

00:10:33.840 --> 00:10:37.030
And then I wait and check with
WaitNext Event and see if it's the

00:10:37.090 --> 00:10:40.340
appropriate time to update my animation.

00:10:40.410 --> 00:10:42.440
So first,
since this is a performance session,

00:10:42.440 --> 00:10:44.580
I want to bring up CPU Monitor.

00:10:44.590 --> 00:10:46.780
So you can see how the CPU is.

00:10:46.800 --> 00:10:48.980
I'm sitting idle right now.

00:10:55.130 --> 00:10:57.980
Now I'm just sitting waiting next
event with a timeout of zero,

00:10:57.980 --> 00:11:00.500
which is spinning on the processor.

00:11:03.120 --> 00:11:06.100
It's consuming every resource
that the computer has.

00:11:06.100 --> 00:11:09.190
I mean, if you put this in perspective,
your laptop would be

00:11:09.190 --> 00:11:11.090
burning your legs right now.

00:11:11.250 --> 00:11:13.560
Which is just not a very
good user experience.

00:11:13.660 --> 00:11:16.760
In addition, I've heard the argument that
I want my application to be as

00:11:16.760 --> 00:11:19.300
responsive as possible for the user.

00:11:19.380 --> 00:11:22.030
Well, that's fine,
but your computer is not responding,

00:11:22.030 --> 00:11:25.040
and in subtle ways
you're becoming a less,

00:11:25.040 --> 00:11:28.330
you're making a less happy user
because they're downloading the

00:11:28.340 --> 00:11:33.140
background or maybe they're ripping a
CD and it's going to be going slower.

00:11:33.260 --> 00:11:37.310
So the solution is to
use event loop timers.

00:11:38.750 --> 00:11:40.760
I mean, that's pretty dramatic.

00:11:40.820 --> 00:11:45.350
All I need to do is update this image
one third-- every third of a second.

00:11:46.400 --> 00:11:50.870
And you can see that the CPU is
hardly utilized at that point.

00:11:50.970 --> 00:11:53.500
Now let's see what's
going on in the code.

00:12:00.490 --> 00:12:02.330
So in the case where I'm
using Wait Next Event,

00:12:02.330 --> 00:12:05.330
I'm just defining the tick delay
to be one-third of a second.

00:12:05.340 --> 00:12:10.190
Or since there's 60 ticks per second,
I'm just dividing that by three.

00:12:11.400 --> 00:12:19.000
[Transcript missing]

00:12:22.760 --> 00:12:24.700
and when I idle,
I just call this one function

00:12:24.700 --> 00:12:27.880
and all it does is it updates
the image that you saw.

00:12:29.810 --> 00:12:32.440
Now, this is what I'm doing when
I'm idling with WaitNextEvent.

00:12:32.480 --> 00:12:34.460
Now, this was a mildly contrived example.

00:12:34.460 --> 00:12:35.940
If you're just doing
one simple animation,

00:12:35.940 --> 00:12:39.030
you're not necessarily going to sit
on WaitNextEvent with a zero timeout.

00:12:39.280 --> 00:12:40.610
But it's important to
demonstrate because,

00:12:40.640 --> 00:12:43.200
as I said,
I have heard the argument that I want

00:12:43.290 --> 00:12:45.490
my app to be as responsive as possible.

00:12:45.550 --> 00:12:48.060
So you can see I'm sitting
on WaitNextEvent spinning,

00:12:48.100 --> 00:12:50.070
and then I'm doing a calculation
to see if this is the appropriate

00:12:50.180 --> 00:12:54.540
time to update my animation,
and then I idle, and then I recalculate.

00:12:54.560 --> 00:12:57.120
Well, instead of doing that,

00:12:59.220 --> 00:13:04.240
It's very simple to do in order
to idle with event loop timers.

00:13:04.270 --> 00:13:08.000
You just create your event loop timer.

00:13:08.030 --> 00:13:10.600
In this case,
I'm not waiting because I want

00:13:10.770 --> 00:13:12.100
it to call back immediately.

00:13:12.130 --> 00:13:15.480
My delay is 1/3 of a second,
like you saw defined above.

00:13:15.990 --> 00:13:17.990
and then I can still continue
to sit on wait next event.

00:13:18.130 --> 00:13:22.770
But this time,
I've made the timeout much longer.

00:13:23.350 --> 00:13:24.290
The events are coming in.

00:13:24.290 --> 00:13:28.010
The idle is happening at the same
frequency using a different method.

00:13:28.110 --> 00:13:31.110
And you can see from my
example that the CPU is hardly

00:13:31.110 --> 00:13:33.090
being utilized at that point.

00:13:35.760 --> 00:13:38.710
So next,
I would like to show you a simple

00:13:38.710 --> 00:13:41.040
demonstration about idle timers.

00:13:41.150 --> 00:13:43.070
Now what I'm going to do is I'm
going to bring up an application,

00:13:43.070 --> 00:13:48.090
and as long as you're responding or
you're interacting with the application,

00:13:48.220 --> 00:13:50.050
the application will stay awake.

00:13:50.150 --> 00:13:52.590
But we're going to install an idle timer,
so when the user becomes

00:13:52.760 --> 00:13:56.560
quiet and doesn't do anything,
something interesting is going to happen.

00:14:00.400 --> 00:14:01.890
and many of you have probably seen Guy.

00:14:01.910 --> 00:14:04.740
And the whole point of this exercise
is to keep him awake because he's

00:14:04.740 --> 00:14:07.390
pretty tired after preparing for WWDC.

00:14:07.440 --> 00:14:09.400
So we can poke him, you know,
startle him.

00:14:09.400 --> 00:14:11.400
Oh, he's pretty scared.

00:14:11.400 --> 00:14:13.450
Or we can even do the stare down.

00:14:16.270 --> 00:14:18.130
It's important we can
discuss his pastimes.

00:14:18.130 --> 00:14:20.300
He's really into hockey and Canada.

00:14:20.300 --> 00:14:20.850
I don't know why.

00:14:20.860 --> 00:14:23.580
Let's have a conversation with him.

00:14:31.520 --> 00:14:34.330
But the interesting part is
when we don't do anything,

00:14:34.330 --> 00:14:37.450
he's really tired and he goes to sleep.

00:14:39.920 --> 00:14:41.190
So let's see that again.

00:14:41.280 --> 00:14:43.740
As long as we're active with them,
things are fine.

00:14:43.740 --> 00:14:48.310
We can poke them, we can scare them,
prod them.

00:14:49.100 --> 00:15:00.700
[Transcript missing]

00:15:06.940 --> 00:15:11.540
So we've set the timeout
to be five seconds.

00:15:11.680 --> 00:15:13.400
Pretty simple to do.

00:15:13.530 --> 00:15:15.500
We declare our callback.

00:15:18.380 --> 00:15:21.240
This is where we install
our idle event timer.

00:15:21.290 --> 00:15:23.940
And as David mentioned, the parameters,
you're installing it on the current

00:15:24.000 --> 00:15:26.240
event loop with our timeout.

00:15:26.300 --> 00:15:27.810
And then after that,
we don't want to call back,

00:15:27.950 --> 00:15:30.580
so the duration is forever.

00:15:33.230 --> 00:15:37.030
and when our callback is called,
after that five second duration,

00:15:37.030 --> 00:15:39.140
we make Guy go to sleep.

00:15:39.180 --> 00:15:42.750
It's quite simple and the performance
improvements using event loop timers

00:15:42.870 --> 00:15:45.960
are considerable since you're not
sitting on one entry point polling the

00:15:45.960 --> 00:15:50.130
hardware for no actions essentially.

00:15:50.150 --> 00:15:52.080
David?

00:15:52.140 --> 00:15:53.670
Thanks, Curt.

00:15:58.970 --> 00:16:01.320
So that's a good example of how
you can gain performance by not

00:16:01.520 --> 00:16:03.340
polling continuously for null events.

00:16:05.680 --> 00:16:07.650
And if you're not going to do this,
I encourage you to buy one of

00:16:07.650 --> 00:16:09.870
those leather laptop protectors
so you don't burn your legs.

00:16:09.970 --> 00:16:10.740
That's a good point, Curt.

00:16:12.310 --> 00:16:15.700
Next I'd like to talk about
mouse tracking regions.

00:16:15.700 --> 00:16:18.200
This is another area where
you can gain some performance.

00:16:18.200 --> 00:16:19.300
What do I mean by mouse tracking regions?

00:16:19.300 --> 00:16:25.060
What I mean is generally people
want to track the mouse around in

00:16:25.220 --> 00:16:27.460
a window or such in an application.

00:16:27.910 --> 00:16:30.890
and it will behave differently depending
on where it's pointing in a window.

00:16:30.890 --> 00:16:34.020
You might want to change the cursor
or display status for different

00:16:34.020 --> 00:16:38.060
pieces or even change the behavior
of the application entirely depending

00:16:38.060 --> 00:16:39.890
on where the mouse is pointing.

00:16:41.830 --> 00:16:45.900
The way you could do this with
OS X when we shipped it was to

00:16:45.900 --> 00:16:49.370
install a K event mouse moved handler.

00:16:49.990 --> 00:16:52.620
So you'd watch where the mouse went
every time and you'd get an event every

00:16:52.620 --> 00:16:55.970
single time wherever the mouse was.

00:16:56.410 --> 00:16:58.640
You might not have cared where the
mouse was unless it was pretty close

00:16:58.640 --> 00:17:01.340
to the important place for you.

00:17:01.450 --> 00:17:04.960
So there's too many mouse moved events,
and it's kind of expensive to process the

00:17:04.960 --> 00:17:07.170
ones that you don't really care about.

00:17:08.740 --> 00:17:12.490
A new feature on Jaguar
are mouse tracking regions,

00:17:12.540 --> 00:17:14.580
and I encourage you to use those instead.

00:17:14.630 --> 00:17:18.680
What you can do is register
different hot regions in your window.

00:17:18.930 --> 00:17:22.760
Then, you get callbacks that track
entry and exit of the regions.

00:17:22.760 --> 00:17:24.940
What that means is you get
a Carbon event that says,

00:17:24.940 --> 00:17:29.100
you get one Carbon event that says,
the mouse just entered your region.

00:17:29.100 --> 00:17:33.200
You get one Carbon event that means
the mouse just exited your region.

00:17:36.820 --> 00:17:39.010
So now you can ignore
the mouse mood events,

00:17:39.010 --> 00:17:41.040
and by extension,
if nobody else is worried

00:17:41.040 --> 00:17:44.230
about mouse mood events,
the toolbox underneath you can stop

00:17:44.240 --> 00:17:46.230
worrying about mouse mood events.

00:17:46.510 --> 00:17:48.670
This has got a nice side effect
in that we don't have to call

00:17:48.670 --> 00:17:51.100
back to the Windows server,
and there's some additional underlying

00:17:51.180 --> 00:17:53.500
performance gain for you as well.

00:17:53.870 --> 00:17:58.530
Another good side effect is this can work
on inactive windows in the background.

00:17:58.620 --> 00:17:59.060
We have a demo.

00:17:59.060 --> 00:18:01.540
Maybe Curt will show that in the demo.

00:18:02.410 --> 00:18:04.990
So there's a huge performance
gain because you're not processing

00:18:05.050 --> 00:18:07.410
so many mouse mood events.

00:18:08.180 --> 00:18:08.940
When could you use them?

00:18:08.940 --> 00:18:13.660
Like I said,
you might want to change the cursor

00:18:13.660 --> 00:18:15.260
as you move it over different regions.

00:18:15.260 --> 00:18:17.440
You know,
where you have a pencil when you're on

00:18:17.440 --> 00:18:19.380
a doodle area or something like that.

00:18:19.380 --> 00:18:23.450
When the mouse leaves the window,
maybe with some widget rollover

00:18:23.450 --> 00:18:25.120
to change an image or a title.

00:18:25.120 --> 00:18:28.600
You might notice in the document
window as you move the mouse over

00:18:28.600 --> 00:18:32.280
the control buttons up in the corner,
the close box, the collapse box,

00:18:32.280 --> 00:18:34.330
and the zoom box, that they change image.

00:18:35.610 --> 00:18:38.300
We use mouse tracking regions for that.

00:18:38.320 --> 00:18:42.840
It was a hidden API that we
were testing before Jaguar,

00:18:42.840 --> 00:18:44.360
and now we're exposing it for you to use.

00:18:44.360 --> 00:18:46.280
And again, status tracking.

00:18:46.280 --> 00:18:49.990
A good example of that would
be in Internet Explorer when

00:18:50.140 --> 00:18:52.080
you hold the mouse over a link.

00:18:52.200 --> 00:18:55.040
It changes the status on the bottom,
tells you where you're about to click to.

00:18:57.780 --> 00:18:59.120
So how do you use mouse tracking regions?

00:18:59.350 --> 00:19:01.980
It's very simple.

00:19:02.040 --> 00:19:04.760
At the top,
I declare a mouse tracking region ID,

00:19:04.940 --> 00:19:09.280
and I put in my own signature
and my own region ID number.

00:19:09.420 --> 00:19:12.000
You want to use those because it
uniquely identifies your region.

00:19:12.000 --> 00:19:15.300
You don't want to do things
or respond to other regions.

00:19:18.860 --> 00:19:21.710
Afterwards, you use the
Create Mouse Tracking Region API,

00:19:21.930 --> 00:19:24.600
passing in that region
ID that you created above.

00:19:24.660 --> 00:19:27.670
Now, there's some extra information
like which window it was in,

00:19:27.730 --> 00:19:29.480
what the region you're worried about is.

00:19:29.650 --> 00:19:31.800
You can have complex regions
rather than just rectangles.

00:19:31.800 --> 00:19:35.870
What the clip is and some options.

00:19:36.870 --> 00:19:39.010
But the important one is your
region ID because you're going

00:19:39.010 --> 00:19:41.720
to use that later to make sure
you're tracking the right region.

00:19:41.790 --> 00:19:44.820
Afterwards,
you just install a Carbon event handler

00:19:44.900 --> 00:19:47.120
and you register for some events.

00:19:47.200 --> 00:19:50.000
And you continue on and your
target will be notified so

00:19:50.000 --> 00:19:51.770
you'll get the Carbon events.

00:19:51.890 --> 00:19:56.980
The events you get are K event mouse
entered and K event mouse exited.

00:19:57.070 --> 00:19:58.800
One event on each action.

00:19:58.880 --> 00:20:00.120
So you're not getting a
whole bunch of events,

00:20:00.120 --> 00:20:02.520
you're just getting them one at a time.

00:20:04.370 --> 00:20:08.490
Some other important mouse tracking APIs.

00:20:08.730 --> 00:20:11.180
Release Mouse Tracking Region.

00:20:11.300 --> 00:20:14.820
If you're not tracking an area anymore,
you can disable it,

00:20:14.900 --> 00:20:19.080
but it's better to deallocate it
entirely and free up resources.

00:20:19.340 --> 00:20:22.600
You want to be able to get mouse
tracking region ID so you can check

00:20:22.600 --> 00:20:26.600
to see that the region you're acting
on is the one that's important to you.

00:20:26.730 --> 00:20:31.100
There's a couple of APIs to change
and move the mouse tracking region.

00:20:32.520 --> 00:20:35.680
And an important one is to set mouse
tracking region enabled with a true

00:20:35.780 --> 00:20:39.620
or false Boolean to indicate whether
or not you actually want to track.

00:20:39.620 --> 00:20:42.390
So you can temporarily turn them
off or temporarily turn them on.

00:20:42.400 --> 00:20:44.870
It's very useful.

00:20:46.410 --> 00:20:49.100
So I mentioned the region ID and
being important to make sure

00:20:49.100 --> 00:20:51.570
you're acting on the right region.

00:20:51.680 --> 00:20:55.960
When you get the mouse entered
or mouse exited events,

00:20:59.120 --> 00:21:01.920
As a parameter,
you get the mouse tracking region

00:21:01.970 --> 00:21:05.800
reference to indicate which mouse
tracking region is being acted upon.

00:21:05.800 --> 00:21:11.030
And what you can do is extract the region
ID from that track graph and compare

00:21:11.030 --> 00:21:14.100
it to your signatures to make sure,
your signature and your ID,

00:21:14.100 --> 00:21:16.130
to make sure that's the
one that you care about.

00:21:20.160 --> 00:21:23.600
Now you really might want to
do KMouseMoved event handling.

00:21:23.600 --> 00:21:27.230
Say you're moving the mouse around
and you want to make a graphic

00:21:27.300 --> 00:21:29.060
underneath and know every point.

00:21:29.130 --> 00:21:30.680
But you don't need it
for the whole window,

00:21:30.680 --> 00:21:32.100
you just need it for one area.

00:21:32.100 --> 00:21:37.040
What I would recommend in that case
is to use mouse tracking regions and

00:21:37.040 --> 00:21:41.490
then when the mouse enters your region,
install the mouse moved handlers

00:21:41.490 --> 00:21:44.640
and start paying attention
to the mouse moved events.

00:21:44.690 --> 00:21:46.400
And if the mouse moves out
of your tracking region,

00:21:46.460 --> 00:21:47.660
then uninstall those handlers.

00:21:47.660 --> 00:21:51.770
And only track the mouse moved events
for that one small area that you care

00:21:51.820 --> 00:21:53.280
about and not for the whole window.

00:21:57.510 --> 00:22:00.100
So I'd like to ask Curt to come
back up again and give another demo,

00:22:00.100 --> 00:22:01.800
this time on mouse tracking regions.

00:22:01.800 --> 00:22:02.960
Curt?

00:22:08.220 --> 00:22:10.950
Thanks, David.

00:22:11.010 --> 00:22:14.080
So this is just to demonstrate--well,
traditionally,

00:22:14.080 --> 00:22:16.520
you would use WaitNext Event,
like the mouse region,

00:22:16.520 --> 00:22:19.770
to figure out where the mouse is--if
the mouse has exited a region.

00:22:19.770 --> 00:22:22.780
But the limitation with using
WaitNext Event is that you can only

00:22:22.850 --> 00:22:25.640
have one region per application,
and then there's some overhead

00:22:25.640 --> 00:22:28.160
on your part to determine,
okay, once I've exited,

00:22:28.170 --> 00:22:29.580
I need to reset that region.

00:22:29.810 --> 00:22:32.180
Well, using Carbon Events,
you could have installed

00:22:32.180 --> 00:22:34.860
a mouse move handler,
and David just went through all the

00:22:34.920 --> 00:22:36.400
performance implications of that.

00:22:36.420 --> 00:22:38.980
And I'd just like to
demonstrate that as well.

00:22:40.690 --> 00:22:43.700
So here again we have Guy,
who's our demo guy.

00:22:43.750 --> 00:22:47.750
And you can see that as I move
the mouse into the window,

00:22:47.750 --> 00:22:48.920
we're getting mouse moved events.

00:22:48.920 --> 00:22:53.380
In fact,
it might be interesting to look at

00:22:53.430 --> 00:22:55.570
the CPU monitor while we do this.

00:23:02.400 --> 00:23:16.200
[Transcript missing]

00:23:16.500 --> 00:23:20.140
"Even when we're in this region,
we continue to get events.

00:23:20.140 --> 00:23:24.170
Exit, we can say, 'Hey, how you doing?'"

00:23:25.230 --> 00:23:28.450
You can see we're just
accumulating events.

00:23:28.450 --> 00:23:30.040
We're not even interested in them.

00:23:30.040 --> 00:23:34.280
We're only interested in it when the
mouse is over a particular region.

00:23:35.380 --> 00:23:37.500
Using Mass Tracking Regions,
that's what we get.

00:23:37.500 --> 00:23:39.690
You can see I'm moving in the window,
nothing's happening.

00:23:39.760 --> 00:23:42.100
We're not getting any events,
there's nothing to process.

00:23:42.210 --> 00:23:47.900
The only time we get an event is when we
have entered a region or exited a region.

00:23:47.930 --> 00:23:52.450
You can see, two as opposed to 1100
is a pretty big savings.

00:23:53.910 --> 00:23:58.840
Again, let's go look at the code
and see how that was done.

00:23:58.950 --> 00:24:01.340
Did you note that 6, just a 6?

00:24:01.360 --> 00:24:02.530
That's a pretty low number.

00:24:02.560 --> 00:24:04.710
That's a pretty low number.

00:24:07.690 --> 00:24:11.490
So again, we just have a region ID,
which we populated with

00:24:11.490 --> 00:24:12.720
the tracking box signature.

00:24:12.750 --> 00:24:15.390
And in this particular case,
we've associated that with the control,

00:24:15.500 --> 00:24:19.110
so we're just going to use the
same control ID that we've used.

00:24:20.200 --> 00:24:24.100
Then we go ahead and we create
the mouse tracking region.

00:24:24.100 --> 00:24:27.490
Specifying the window that that
region's gonna be bound to.

00:24:27.830 --> 00:24:30.100
The Control Region that
we're interested in.

00:24:30.200 --> 00:24:32.510
We can even clip that
complex region if we want to,

00:24:32.510 --> 00:24:34.950
but we don't want to in
this particular case.

00:24:34.980 --> 00:24:37.720
The Options Standard,
that means that it's going to be

00:24:37.780 --> 00:24:39.440
a local region to that window.

00:24:39.440 --> 00:24:41.700
The Region ID,
some of our own window data,

00:24:41.700 --> 00:24:45.010
so when we get the event,
we can extract some information.

00:24:47.400 --> 00:24:50.850
Initially, in this window,
we've disabled them.

00:24:50.880 --> 00:24:54.670
Well then later on we go ahead
and enable them when I selected

00:24:54.680 --> 00:24:56.480
that item from the menu.

00:25:01.200 --> 00:25:03.440
We go ahead and we
install for these events.

00:25:03.450 --> 00:25:06.400
This is the K event class mouse,
K event mouse entered,

00:25:06.400 --> 00:25:09.450
and K event mouse exited events.

00:25:09.710 --> 00:25:11.770
And when we get those events,
we just tickle the event counter,

00:25:11.860 --> 00:25:14.190
which you saw on the bottom,
and then we go ahead and update

00:25:14.300 --> 00:25:16.800
the highlight of that image.

00:25:16.820 --> 00:25:20.960
And of course, when we're done,
we release the mouse tracking region.

00:25:21.200 --> 00:25:25.210
So you can see that it was very
simple to install a region,

00:25:25.210 --> 00:25:28.710
and we get some considerable
performance gains by not listening

00:25:28.710 --> 00:25:30.380
to each mouse moved event.

00:25:32.700 --> 00:25:38.620
That really is just a lot when you're not
interested in anything except for this.

00:25:38.620 --> 00:25:39.620
David?

00:25:39.620 --> 00:25:40.530
Thanks, Curt.

00:25:40.680 --> 00:25:41.480
Thank you.

00:25:48.350 --> 00:25:52.630
So hopefully the choice between
processing hundreds and hundreds

00:25:52.670 --> 00:25:55.940
of events versus six is an
easy one for you to make.

00:25:55.970 --> 00:25:59.560
Mousetracking regions are also
very convenient and easy to use.

00:26:00.290 --> 00:26:02.900
Next,
I'd like to talk about Carbon events,

00:26:02.900 --> 00:26:05.840
but from a different point of view,
viewing them as notifications.

00:26:05.840 --> 00:26:09.090
It's sort of an overlooked
feature of Carbon events.

00:26:09.130 --> 00:26:11.100
Toolbox actually sends many,
many of these.

00:26:11.100 --> 00:26:14.040
If you look through carbonevents.h,
there's a really good source of

00:26:14.040 --> 00:26:17.160
information for determining what kind
of Carbon events are available to you.

00:26:17.160 --> 00:26:21.220
They're just Carbon events that you can
easily watch for these notifications.

00:26:24.700 --> 00:26:28.240
And there's not really a big how-to
session I can give on how to use them.

00:26:28.300 --> 00:26:32.340
Just register for the Carbon event,
and you'll just get the one event that

00:26:32.410 --> 00:26:34.620
is interesting to you as a notification.

00:26:34.620 --> 00:26:37.460
Some examples are when
your window becomes hidden,

00:26:37.550 --> 00:26:39.990
when your application becomes hidden,

00:26:40.960 --> 00:26:43.740
Warning that your menu
is about to populate.

00:26:43.850 --> 00:26:46.440
These are really good notifications
and you can use them to your benefit

00:26:46.440 --> 00:26:47.900
to increase your performance.

00:26:47.900 --> 00:26:52.990
And, instead of checking continuously
to see if something has happened,

00:26:52.990 --> 00:27:00.900
getting a notification just
once is a lot better for you.

00:27:01.030 --> 00:27:03.040
Here's a quick example.

00:27:05.400 --> 00:27:08.470
I've declared an event list of a couple
of events that I'm interested in.

00:27:08.610 --> 00:27:11.880
In this case, the volume mounted and
the volume unmounted.

00:27:11.880 --> 00:27:15.700
You don't have to--in this case,
we want to not care about the

00:27:15.740 --> 00:27:19.150
volume list and check this
continuously to see if it's changed.

00:27:19.170 --> 00:27:21.710
We just want to install an
application event handler to receive

00:27:21.710 --> 00:27:24.860
the K event volume mounted or
the K event volume unmounted events,

00:27:24.930 --> 00:27:28.730
which will notify us when the volume
has been mounted or unmounted.

00:27:28.730 --> 00:27:31.700
It's a lot better than polling,
wouldn't you say?

00:27:32.920 --> 00:27:34.670
That's really all I have to
say about the notifications,

00:27:34.670 --> 00:27:36.700
but you should really
check carbonevents.h.

00:27:36.700 --> 00:27:39.080
Next, tracking loops.

00:27:40.580 --> 00:27:45.600
What I mean by tracking loops is keeping
track of the mouse while you do things,

00:27:45.650 --> 00:27:49.900
whether the mouse button is down
or the key modifiers have changed.

00:27:53.710 --> 00:27:55.260
Traditionally,
the way to do this was to call

00:27:55.260 --> 00:27:58.300
still down or button in tight loops.

00:27:58.390 --> 00:28:02.380
It's very, very expensive on OS X.

00:28:02.480 --> 00:28:04.080
They hoard the CPU entirely.

00:28:04.200 --> 00:28:05.480
Check out that CPU meter over there.

00:28:05.480 --> 00:28:07.220
It's pegged.

00:28:08.810 --> 00:28:10.860
What you want to do instead
is use a tracking loop.

00:28:10.860 --> 00:28:14.900
You want to call track mouse
location or track mouse region.

00:28:15.650 --> 00:28:18.520
You're not calling it a tight loop.

00:28:18.630 --> 00:28:25.220
It blocks entirely and will only return
when something important has happened.

00:28:25.220 --> 00:28:29.730
Nice part about that is you
won't get a rainbow cursor.

00:28:29.730 --> 00:28:34.530
Now, a lot of people view the
rainbow cursor as a bad thing,

00:28:34.530 --> 00:28:35.310
but it's actually a feature of the
OS that indicates to the user that an

00:28:35.310 --> 00:28:35.310
application has become unresponsive.

00:28:35.310 --> 00:28:35.310
And the way...

00:28:35.890 --> 00:28:38.650
Getting a rainbow cursor and working
around it is not really the solution.

00:28:38.660 --> 00:28:42.790
What you want to do is solve the
problem that is alerting you too.

00:28:44.360 --> 00:28:46.430
Nice side effect,
when you call track mouse

00:28:46.430 --> 00:28:49.180
location and it blocks entirely,
it's calling the event

00:28:49.410 --> 00:28:51.270
loop and timers fire.

00:28:51.350 --> 00:28:54.270
But the best part is that
it frees the CPU entirely.

00:28:54.350 --> 00:28:57.540
Notice it's a lot different
here with the mouse button down.

00:28:59.260 --> 00:29:01.200
How do you use Track Mouse Location?

00:29:01.200 --> 00:29:02.500
It's very simple.

00:29:02.590 --> 00:29:05.440
You just call the API with
a couple of parameters,

00:29:05.490 --> 00:29:07.830
one being the tracking result.

00:29:08.770 --> 00:29:11.450
You can call it in a loop because it's
not going to come back to you many,

00:29:11.450 --> 00:29:12.000
many times.

00:29:12.000 --> 00:29:14.860
It'll only come back to you
when interesting things happen,

00:29:14.860 --> 00:29:18.330
like whether the mouse is down
or whether the mouse is up.

00:29:18.390 --> 00:29:19.150
That's all you have to do.

00:29:21.470 --> 00:29:24.620
and Curt's going to come up and give
one more demo showing the difference in

00:29:24.620 --> 00:29:26.530
performance using trackmost location.

00:29:30.040 --> 00:29:31.990
Thanks, David.

00:29:32.030 --> 00:29:32.240
You're welcome.

00:29:32.310 --> 00:29:34.570
So in this particular case,
what I've done is I've written

00:29:34.670 --> 00:29:37.340
a new drawing application.

00:29:37.360 --> 00:29:39.990
And so it's very important for me
to get the location of the mouse

00:29:40.100 --> 00:29:43.760
and actually track that mouse and
see what's going on with the user.

00:29:43.870 --> 00:29:47.250
So initially,
I went ahead and I implemented that

00:29:47.250 --> 00:29:51.360
using while still down git mouse,
which I found was extremely inefficient.

00:29:51.420 --> 00:29:55.790
And I just wanted to show you
the difference in performance.

00:30:04.690 --> 00:30:07.400
This is my groovy new
drawing application.

00:30:07.400 --> 00:30:09.140
It's very, very cool.

00:30:09.290 --> 00:30:12.710
So let's use-- I'm going to use--
WaitNextEvent in this particular case,

00:30:12.800 --> 00:30:15.400
and I'm just going to--
The demonstration is definitely just

00:30:15.440 --> 00:30:18.740
to show you while still down GitMouse.

00:30:19.820 --> 00:30:22.400
I'm going to click the mouse button,
and we're going to see that

00:30:22.450 --> 00:30:24.640
the CPU is completely pegged.

00:30:24.700 --> 00:30:26.220
I'm not doing anything.

00:30:26.370 --> 00:30:28.690
Here, I go ahead and I draw.

00:30:31.200 --> 00:30:33.740
While doing this, the CPU is pegged.

00:30:33.830 --> 00:30:37.590
Now let's say I implement some
groovy new feature in here.

00:30:38.080 --> 00:30:42.910
Where this application can actually
look at what I'm drawing and do some

00:30:42.910 --> 00:30:44.760
image processing while I'm going on.

00:30:44.880 --> 00:30:47.640
So I'm going to want to show the
user that something's happening,

00:30:47.640 --> 00:30:50.560
so his head's going to rotate,
similar to my first demo.

00:30:50.560 --> 00:30:53.910
So see, I'm going to do something and
he's going to start moving around.

00:30:54.030 --> 00:30:56.620
Well, the second I click the mouse down,
he stops.

00:30:56.890 --> 00:31:00.000
We're in this really tight loop,
and we're not letting any other

00:31:00.000 --> 00:31:02.560
events happen in this particular case.

00:31:02.640 --> 00:31:04.620
Pegging the CPU.

00:31:12.050 --> 00:31:18.000
Okay, let's go ahead and use
Track Mouse Location.

00:31:18.000 --> 00:31:22.340
I'm gonna click the mouse down,
and we see that nothing's happening.

00:31:22.360 --> 00:31:24.730
I go ahead and I can draw.

00:31:25.230 --> 00:31:27.200
Nothing is happening with this CPU.

00:31:27.200 --> 00:31:28.890
We're not consuming resources.

00:31:28.900 --> 00:31:32.900
It's taken away from other applications
that are currently running on our system.

00:31:33.460 --> 00:31:35.500
And as David was mentioning,
it's pretty nice because

00:31:35.500 --> 00:31:36.690
timers will continue to fire.

00:31:36.700 --> 00:31:41.910
You can still see that the animation
is continuing even while I draw.

00:31:43.190 --> 00:31:45.350
So that provides a better
user experience to the user.

00:31:45.400 --> 00:31:47.100
It's allowing it to get
into the event loop,

00:31:47.120 --> 00:31:51.300
and it's blocked when I'm
not doing anything extra.

00:31:51.420 --> 00:31:54.290
So let's go take a look at
the code for that as well.

00:32:05.450 --> 00:32:10.090
So initially,
you can see that I was just calling

00:32:10.090 --> 00:32:13.030
this simple loop while still down,
getMouse.

00:32:13.120 --> 00:32:14.590
And I do a few calculations
to see if the mouse has moved,

00:32:14.620 --> 00:32:17.420
and then I actually draw
a line if that's happened.

00:32:17.450 --> 00:32:21.620
And this does not do anything other than
pull the mouse and see what's going on.

00:32:21.640 --> 00:32:24.660
And as I mentioned in session 203,
what you're doing here while

00:32:24.660 --> 00:32:28.220
sitting in this tight loop,
it consumes resources initially, yes,

00:32:28.220 --> 00:32:31.330
but when we call getMouse,
that requires interprocess communication

00:32:31.330 --> 00:32:33.900
with the Windows Server too,
which can be expensive.

00:32:33.920 --> 00:32:38.700
It's just not necessary to sit in a tight
loop if the user's not doing anything.

00:32:41.110 --> 00:32:44.200
In contrast,
we can still sit in a loop in

00:32:44.200 --> 00:32:48.190
this particular case by calling--
while sitting in a while loop,

00:32:48.210 --> 00:32:50.490
but instead use track mouse location.

00:32:50.570 --> 00:32:52.580
In that particular call,
it will block in the CPU.

00:32:52.580 --> 00:32:55.040
There's nothing going on
unless the mouse is moved.

00:32:55.040 --> 00:32:57.290
If the mouse state has changed
because it's moved or the

00:32:57.390 --> 00:32:59.000
mouse button has been released.

00:32:59.100 --> 00:33:02.420
And then we'll go ahead and we'll
do the same thing until-- as

00:33:02.520 --> 00:33:07.140
the mouse is dragged and we'll
exit when the mouse says comma.

00:33:08.390 --> 00:33:10.060
So you can see that
that's really important.

00:33:10.060 --> 00:33:12.900
It was such a small change
that we needed to make,

00:33:13.020 --> 00:33:18.340
and we were able to dramatically
decrease our CPU usage.

00:33:18.380 --> 00:33:19.400
David?

00:33:19.550 --> 00:33:21.150
Thanks, Curt.

00:33:28.120 --> 00:33:31.390
So if anything from these three demos,
you can see that you probably want to

00:33:31.430 --> 00:33:35.410
keep the CPU meter up and keep an eye
on to see how your application is using

00:33:35.620 --> 00:33:37.500
the resources that are available to it.

00:33:37.590 --> 00:33:40.780
If it's using all of them and
you're not doing something really,

00:33:40.780 --> 00:33:43.610
really crazily cool,
then you probably want to go

00:33:43.610 --> 00:33:45.290
visit a few pieces of your code.

00:33:45.640 --> 00:33:48.860
And you can see that it's very simple
to replace it with a timer or a track

00:33:48.860 --> 00:33:52.370
mouse region or track mouse location,
or mouse tracking regions

00:33:52.480 --> 00:33:54.010
or track mouse location.

00:33:55.810 --> 00:33:57.990
Next,
I'd like to convince you guys to stop

00:33:58.090 --> 00:34:00.060
calling find window and tight loops.

00:34:00.120 --> 00:34:03.160
Historically,
people have called find window and find

00:34:03.320 --> 00:34:05.460
control and those associated calls.

00:34:05.560 --> 00:34:09.900
When you got an event to try and
figure out where events occurred,

00:34:09.900 --> 00:34:09.900
you had to go back to
the start button and

00:34:10.660 --> 00:34:14.450
Unfortunately, FindWindow has to call
the Windows server.

00:34:14.450 --> 00:34:16.700
There's a bit of a performance
hit with that because there's

00:34:16.780 --> 00:34:18.400
inter-process communication.

00:34:18.700 --> 00:34:21.670
And really, all the information you need
is in your Carbon event.

00:34:21.670 --> 00:34:23.650
So you really want to avoid
calling FindWinnow because it's

00:34:23.650 --> 00:34:24.800
not really a necessary call.

00:34:26.230 --> 00:34:28.790
For example, the mouse down Carbon event.

00:34:28.900 --> 00:34:31.800
That's probably a pretty common
one that most of us would

00:34:31.800 --> 00:34:33.840
register and want to see.

00:34:34.450 --> 00:34:37.390
Once we receive that event,
we're probably concerned which

00:34:38.240 --> 00:34:41.070
window this was occurring in.

00:34:41.100 --> 00:34:44.700
And it's right there in the
kEventParamDirect object.

00:34:44.700 --> 00:34:46.940
Or where the mouse location is.

00:34:46.940 --> 00:34:47.830
You can see it there.

00:34:47.840 --> 00:34:50.240
Or even what the keyboard modifiers are.

00:34:50.240 --> 00:34:53.650
And if there was a control in the
window that was being clicked,

00:34:53.740 --> 00:34:56.320
that'll show up as a control
ref in the parameter list.

00:34:56.340 --> 00:34:59.670
So you don't need to call anything
other than the extractors for

00:34:59.670 --> 00:35:01.480
the Carbon event parameters.

00:35:03.380 --> 00:35:05.220
Here's another example.

00:35:05.480 --> 00:35:07.420
This is a Carbon event that you
might use if you're writing a

00:35:07.420 --> 00:35:09.590
custom control of some sort.

00:35:09.700 --> 00:35:11.380
When you're writing that,
you're probably interested in what

00:35:11.380 --> 00:35:14.530
happens when the mouse gets clicked
and when you're going to track.

00:35:14.630 --> 00:35:18.090
You're interested in which control ref,
what the control ref is.

00:35:18.180 --> 00:35:20.400
You're again interested
in the mouse location,

00:35:20.400 --> 00:35:21.740
the keyboard modifiers.

00:35:21.830 --> 00:35:24.580
You might even be interested in
which control part was clicked.

00:35:24.670 --> 00:35:27.930
And it's all right there
in the Carbon event.

00:35:31.400 --> 00:35:34.610
Event avail is another call
that can be inefficient when

00:35:34.610 --> 00:35:36.580
you call it in tight loops.

00:35:37.360 --> 00:35:43.080
Historically, developers have used it to
figure out what the state

00:35:43.700 --> 00:35:56.200
[Transcript missing]

00:35:56.980 --> 00:36:00.520
The Event Queue is thread safe,
so there's some

00:36:00.520 --> 00:36:02.780
synchronization costs as well.

00:36:07.400 --> 00:36:10.590
An Event Avail runs the event
loop and fires the timers.

00:36:10.670 --> 00:36:13.220
It can also flush the windows.

00:36:13.970 --> 00:36:24.900
and Fire the Timers.

00:36:24.900 --> 00:36:24.900
So you really want to avoid
calling EventAvail if you're

00:36:24.900 --> 00:36:24.900
just trying to figure out a few
different little parameters.

00:36:24.900 --> 00:36:24.900
And I'll show you some other ways
that you can grab that information.

00:36:28.130 --> 00:36:30.620
You can check the loop with
some APIs that we've introduced,

00:36:30.700 --> 00:36:33.250
get GlobalMouse,
and get current key modifiers.

00:36:33.250 --> 00:36:35.260
Those have been there for a while.

00:36:36.070 --> 00:36:38.760
They don't check the event queue.

00:36:38.760 --> 00:36:40.040
However, they do call the Windows server.

00:36:40.040 --> 00:36:43.100
So this is a little bit better solution.

00:36:43.920 --> 00:36:47.200
Much better than using
EventAvail by any means.

00:36:47.200 --> 00:36:50.800
Even better than that, and new in Jaguar,
there's two APIs,

00:36:50.850 --> 00:36:54.800
GetCurrentEventButtonState and
GetCurrentEventKeyboardModifiers.

00:36:54.800 --> 00:36:58.230
What happens here is,
as we pop an event off the queue,

00:36:58.340 --> 00:37:02.300
we keep track of that information
so that you can access it quickly.

00:37:02.600 --> 00:37:06.260
And we just restore that information.

00:37:06.830 --> 00:37:09.210
and we can send it back to you
without pulling the Windows server

00:37:09.210 --> 00:37:10.600
so there's no performance costs.

00:37:10.600 --> 00:37:13.090
Or very low, anyway.

00:37:15.980 --> 00:37:19.280
Another time when you might be checking
the event queue in that fashion is

00:37:19.280 --> 00:37:20.740
to determine if the user's canceled.

00:37:20.740 --> 00:37:25.490
You're looking for a command period
or a click on a cancel button.

00:37:25.900 --> 00:37:29.480
We have a conveniently named API,
Check Event Queue for User Cancel.

00:37:29.710 --> 00:37:32.800
Very descriptive, imaginative,
like Guy says.

00:37:32.840 --> 00:37:34.790
That's the kind of APIs you need.

00:37:34.830 --> 00:37:38.280
It doesn't call the event loop,
and the toolbox can check this

00:37:38.280 --> 00:37:41.410
faster than using those other calls.

00:37:41.590 --> 00:37:44.200
And if that's all you're interested in,
then Check Event Queue for

00:37:44.280 --> 00:37:45.920
User Counsel is the API for you.

00:37:47.580 --> 00:37:51.250
The ultimate thing to do though,
like I mentioned earlier,

00:37:51.290 --> 00:37:54.800
is to check the Carbon event parameter
list for the Carbon event that you have.

00:37:55.060 --> 00:37:56.790
Because the information
might already be there.

00:37:56.800 --> 00:37:59.570
The Carbon event often
includes modifiers.

00:37:59.570 --> 00:38:01.510
It often includes the mouse location.

00:38:02.990 --> 00:38:06.860
Back to my control track
Carbon event parameter list.

00:38:06.860 --> 00:38:08.350
You can see that they're right there.

00:38:08.360 --> 00:38:11.480
And that's probably the information
you're going to be looking for.

00:38:14.710 --> 00:38:17.130
So those are really the key
areas I wanted to cover as far

00:38:17.130 --> 00:38:18.910
as Carbon event performance.

00:38:19.020 --> 00:38:21.500
And you've seen over the
course of the day many new

00:38:21.500 --> 00:38:23.940
Carbon events have been mentioned.

00:38:24.030 --> 00:38:26.880
So there's a whole bunch
of other new Carbon events.

00:38:27.420 --> 00:38:29.980
and in case anybody's frantically
scribbling these down,

00:38:29.980 --> 00:38:31.220
you might want to grab those ones too.

00:38:31.220 --> 00:38:36.820
I could keep doing this a few more times
because there's been a lot of new events.

00:38:36.870 --> 00:38:38.840
This is the way we're going forward.

00:38:38.840 --> 00:38:41.410
We're always going to be
adding to the Carbon events

00:38:41.470 --> 00:38:43.610
and adding to the Carbon event
parameters that are available.

00:38:43.620 --> 00:38:47.740
What you want to do is keep
in tune with Carbonevents.h.

00:38:47.740 --> 00:38:52.040
It's definitely the best documented
area in all of the high-level toolbox.

00:38:52.170 --> 00:38:54.060
Whenever we add an event,
we document it fully.

00:38:54.060 --> 00:38:56.690
Whenever we add a parameter,
we document it fully.

00:38:57.400 --> 00:39:00.260
And if you do find that
particular documentation lacking,

00:39:00.260 --> 00:39:03.220
be sure to give us that feedback because
this area is very important to us.

00:39:07.110 --> 00:39:09.600
So I'd like to go on to some
additional performance tips,

00:39:09.640 --> 00:39:12.110
as I mentioned in the introduction.

00:39:14.740 --> 00:39:18.600
These are things that have come up based
on questions from the Carbon Dev mailing

00:39:18.640 --> 00:39:23.560
list and other sources where there's
some niggling performance problems

00:39:23.630 --> 00:39:25.090
where people are having trouble.

00:39:25.300 --> 00:39:28.630
So we've just compiled a few
tips that we think are helpful,

00:39:28.720 --> 00:39:33.500
sort of the big bang for a small effort.

00:39:33.560 --> 00:39:37.760
I have some in the Control Manager,
just a couple, some in the Menu Manager,

00:39:37.820 --> 00:39:42.090
and I have three quick drawing
tips that might be helpful to you.

00:39:44.690 --> 00:39:47.230
First, the control manager.

00:39:47.320 --> 00:39:49.840
The controls we draw are fairly complex.

00:39:49.970 --> 00:39:54.630
Drawing Aqua is not always easy,
so redrawing can be a little slow.

00:39:54.720 --> 00:40:00.790
We make them perform as well as we can,
but when you modify them,

00:40:01.290 --> 00:40:20.590
It can force a redraw.

00:40:20.590 --> 00:40:20.590
Really a good example of this is if you
add many items to a pop-up button's menu.

00:40:20.590 --> 00:40:20.590
You do that over and over.

00:40:20.590 --> 00:40:20.590
It does some calculations
based on the size of the menu

00:40:20.590 --> 00:40:20.590
items that you're adding,
and it might force a

00:40:20.590 --> 00:40:20.590
redraw of that button.

00:40:20.590 --> 00:40:20.590
Redrawing that button over and over
can definitely be a performance hit.

00:40:20.900 --> 00:40:23.910
What you want to do under these
types of circumstances is use

00:40:23.980 --> 00:40:26.490
the API set control visibility.

00:40:26.590 --> 00:40:29.760
What you can do with this API is
temporarily hide a control

00:40:30.120 --> 00:40:31.780
before you start changing it.

00:40:31.870 --> 00:40:34.210
You can change it many times.

00:40:34.330 --> 00:40:36.460
And then once you're done,
use set control visibility

00:40:36.460 --> 00:40:38.940
again and show it afterwards.

00:40:39.070 --> 00:40:42.930
So it will only redraw once at most.

00:40:44.060 --> 00:40:46.900
So here's an example of that.

00:40:46.900 --> 00:40:49.780
How to make control changes
a little more speedy.

00:40:49.780 --> 00:40:53.180
You can see the first call at the top,
set control visibility.

00:40:53.180 --> 00:40:55.730
I tell the control not to draw.

00:40:55.770 --> 00:40:58.060
In this particular example,
it's back to that pop-up control again.

00:40:58.060 --> 00:40:59.270
I'm adding a bunch of menu items.

00:40:59.340 --> 00:41:03.340
So I have a loop of, say, I don't know,
too many menu items going

00:41:03.340 --> 00:41:04.690
into a pop-up control.

00:41:04.790 --> 00:41:05.930
I do that.

00:41:06.160 --> 00:41:08.280
When I'm finished,
I call set control visibility again.

00:41:09.600 --> 00:41:12.000
with True to tell it to draw again.

00:41:12.070 --> 00:41:15.660
And at most,
I'll only redraw that control once.

00:41:15.660 --> 00:41:19.540
It's a lot better than
drawing it menu items times.

00:41:20.910 --> 00:41:21.890
That's what I have for
the Control Manager.

00:41:21.890 --> 00:41:24.800
Next, the Menu Manager.

00:41:24.910 --> 00:41:26.800
One of the key areas with the
Menu Manager where you can gain

00:41:26.800 --> 00:41:32.190
some performance is try to avoid
invalidating the menu key cache.

00:41:33.180 --> 00:41:35.900
Because it forces a
rebuild of the whole thing,

00:41:35.900 --> 00:41:36.920
and that can be expensive.

00:41:37.190 --> 00:41:39.490
What is the menu key cache?

00:41:39.850 --> 00:41:44.170
The menu key cache is an internal
set of data that we keep so

00:41:44.170 --> 00:41:49.710
that we can determine how to map
keyboard shortcuts onto menu items.

00:41:50.870 --> 00:41:53.760
We have to keep that up to date,
so if any keyboard input comes in,

00:41:53.760 --> 00:41:58.600
we know to route it to you through
the menus and perhaps as a command ID.

00:42:00.480 --> 00:42:03.520
So what are the things that
invalidate the menu key cache?

00:42:03.550 --> 00:42:08.590
Will you change a menu item's
modifiers or the shortcut key?

00:42:09.750 --> 00:42:13.030
If you insert or delete menus,
if you add new menus that

00:42:13.030 --> 00:42:15.600
have command keys on them,
definitely will do that.

00:42:15.740 --> 00:42:18.510
If you clear the menu bar
or set a whole new one,

00:42:18.510 --> 00:42:19.950
it has to go through the whole menu bar.

00:42:20.090 --> 00:42:23.330
Or if you change any of the submenus,
it invalidates it because it has to

00:42:23.410 --> 00:42:25.260
become aware of those new submenus.

00:42:25.260 --> 00:42:27.890
So how can you avoid this?

00:42:28.510 --> 00:42:29.720
Don't invalidate it.

00:42:29.840 --> 00:42:32.500
And that's easy to say,
but how do you catch that?

00:42:32.500 --> 00:42:35.390
How do you figure out what's
invalidating your menu key cache?

00:42:35.490 --> 00:42:36.800
Here's what I would do.

00:42:36.860 --> 00:42:40.260
I'd run my application
using GDB and attach to it,

00:42:40.310 --> 00:42:43.180
or run it from the command line.

00:42:43.210 --> 00:42:49.400
and David Levy will be here to talk
about the new features of Carbon Events.

00:42:50.640 --> 00:42:53.770
Now, if you're doing this before Jaguar,
there's no underscore before

00:42:53.770 --> 00:42:56.360
invalidate menu key cache,
something we added in Jaguar.

00:42:56.360 --> 00:42:58.100
But that is the API you want to break on.

00:42:59.700 --> 00:43:02.120
Now, I know there's a couple of
Code Warrior developers here,

00:43:02.120 --> 00:43:05.290
so I'll go through the
GDB session a little bit.

00:43:07.610 --> 00:43:10.100
Like I said,
you attach or you run from the

00:43:10.100 --> 00:43:15.160
command line with GDB and you break on
underscore and validate menu key cache.

00:43:15.160 --> 00:43:16.220
And you continue on.

00:43:16.270 --> 00:43:19.160
And you use your application
until you hit that break point.

00:43:19.400 --> 00:43:24.870
Once you hit that break point,
that's our internal notification API

00:43:25.020 --> 00:43:28.190
and David L.

00:43:28.410 --> 00:43:29.280
L.

00:43:29.280 --> 00:43:30.560
L.

00:43:30.560 --> 00:43:30.560
L.

00:43:31.360 --> 00:43:32.400
Just who the culprit was.

00:43:32.570 --> 00:43:37.180
In this case, someone's changing the item
command of a menu item.

00:43:41.000 --> 00:43:43.450
So you can use GDB to
try and eliminate those.

00:43:43.590 --> 00:43:46.320
Find points and maybe find out why
you were doing that and see if you

00:43:46.410 --> 00:43:47.430
can avoid doing it at that point.

00:43:49.200 --> 00:43:53.320
Next with the menu manager,
using the K event update

00:43:53.320 --> 00:43:55.430
command status event,

00:43:56.710 --> 00:44:00.630
When you receive that,
you want to use enable items wisely.

00:44:00.720 --> 00:44:03.340
When you get this event,
it doesn't necessarily mean, oh, geez,

00:44:03.420 --> 00:44:05.980
the whole menu's gone bad and you
need to update everything and tell

00:44:06.070 --> 00:44:07.360
us what the state of everything is.

00:44:10.520 --> 00:44:13.090
There's parameters that come
along with that event to indicate

00:44:14.180 --> 00:44:15.660
what the requested items are.

00:44:15.660 --> 00:44:19.200
It's only really concerned
with a finite set of items,

00:44:19.200 --> 00:44:21.000
maybe not the whole thing.

00:44:21.000 --> 00:44:22.320
And if you were to do the
whole thing every time,

00:44:22.360 --> 00:44:23.550
that's a performance hit for you.

00:44:25.830 --> 00:44:28.910
So you want to listen to the
K event menu context parameter.

00:44:28.920 --> 00:44:29.940
See what it says.

00:44:29.950 --> 00:44:33.890
It's well documented in carbon-events.h.

00:44:33.890 --> 00:44:37.690
And you really want to only update
the items that it cares about.

00:44:40.530 --> 00:44:46.580
Lastly with the Menu Manager,
use set menu item data instead

00:44:46.580 --> 00:44:52.170
of making multiple calls
to other set menu foo APIs.

00:44:52.610 --> 00:44:56.740
The cost here is that when you
call any of the menu setter APIs,

00:44:56.840 --> 00:45:00.620
we have to map the menu ref and the
menu item index onto some internal data

00:45:00.650 --> 00:45:05.460
structures within the menu manager,
and that can be expensive.

00:45:05.570 --> 00:45:08.110
It's something we need to do,
but we shouldn't do it

00:45:08.110 --> 00:45:09.710
more often than we need to.

00:45:11.230 --> 00:45:14.980
So here's an example of a little
bit slower way of doing it.

00:45:15.060 --> 00:45:20.610
I'm calling a set item foo API,
or set menu item foo API, three times.

00:45:20.710 --> 00:45:25.100
And you'll notice each of these
APIs has a menu and an item parameter.

00:45:25.220 --> 00:45:27.310
So every time there's a
menu and an item parameter,

00:45:27.310 --> 00:45:29.870
we have to map them,
this is a menu ref and a menu item index,

00:45:29.930 --> 00:45:31.860
onto our internal data structures.

00:45:31.990 --> 00:45:34.730
So we're doing it three times there.

00:45:34.770 --> 00:45:36.950
A better way for you to do it

00:45:37.800 --> 00:45:58.200
[Transcript missing]

00:45:58.410 --> 00:46:01.760
We set the command key field,
the key modifiers field,

00:46:01.760 --> 00:46:04.110
and the command ID fields

00:46:04.280 --> 00:46:05.830
All at once in the record.

00:46:05.930 --> 00:46:07.790
And then you see at the bottom,
set menu item data.

00:46:07.800 --> 00:46:09.120
We just call it API once.

00:46:09.390 --> 00:46:12.940
We're only going to map the menu
ref and the menu item index onto

00:46:12.940 --> 00:46:15.200
the internal data structures once.

00:46:17.740 --> 00:46:21.140
So aside from initializing the record,
which is pretty fast,

00:46:21.140 --> 00:46:23.340
this code's going to be three
times as fast as the other one.

00:46:23.400 --> 00:46:25.610
And who knows how many times
you're calling those other -- you

00:46:25.700 --> 00:46:29.200
might be setting every possible
thing you can for the menu item.

00:46:29.200 --> 00:46:31.000
You'd have to map it every time.

00:46:31.010 --> 00:46:32.550
This way, you do it all in one go.

00:46:32.620 --> 00:46:33.550
It's the best way to do it.

00:46:36.130 --> 00:46:39.100
On to Quick Draw.

00:46:39.180 --> 00:46:43.180
Tip 1: Quick Draw Flush Port Buffer.

00:46:43.220 --> 00:46:45.560
Some people here might have
familiarized themselves with this.

00:46:45.620 --> 00:46:49.270
This API flushes the
Quick Draw Port Buffer and people

00:46:49.270 --> 00:46:51.100
might use it to try and get their

00:46:51.300 --> 00:47:01.300
[Transcript missing]

00:47:01.510 --> 00:47:03.230
And you definitely don't want
to call it more often than the

00:47:03.230 --> 00:47:04.260
screen's actually going to update.

00:47:04.260 --> 00:47:08.600
You'll be updating the buffers faster
than the system is updating the buffers,

00:47:08.600 --> 00:47:10.020
and this is all a waste of time.

00:47:11.340 --> 00:47:13.640
and you definitely don't want
to call it unnecessarily.

00:47:13.710 --> 00:47:16.840
In fact, you might not have to call it at
all because it might get flushed

00:47:16.840 --> 00:47:20.540
automatically and that type of
flushing might be good enough for you.

00:47:23.610 --> 00:47:28.070
Quick Draw Tip #2:
Complex Quick Draw Drawing.

00:47:28.070 --> 00:47:31.300
You might be drawing something
with Quick Draw and drawing

00:47:31.300 --> 00:47:32.760
thousands and thousands of lines.

00:47:32.760 --> 00:47:37.870
I think I saw someone with
an example like that on the

00:47:37.870 --> 00:47:37.870
Carbon Development List recently.

00:47:40.310 --> 00:47:42.420
What you want to do here,
and what the performance problem is,

00:47:42.450 --> 00:47:46.230
is that every time Quick Draw draws,
it's calculating its dirty region.

00:47:47.630 --> 00:47:49.290
So when you say you're
drawing a bunch of lines,

00:47:49.410 --> 00:47:52.650
every time it's checking to see
if the region of that line is

00:47:52.690 --> 00:47:55.150
intersecting with the dirty region.

00:47:55.380 --> 00:47:59.390
What you can do is just dirty the region
as a big rectangle of where you're

00:47:59.390 --> 00:48:02.300
going to draw before you start to draw.

00:48:02.300 --> 00:48:07.520
By using the API qd
add_rect to dirty_region.

00:48:08.390 --> 00:48:10.150
What this does,
when you actually do your drawing,

00:48:10.150 --> 00:48:13.780
say you're drawing a line,
the region calculation to see if

00:48:13.780 --> 00:48:16.940
that line intersects the rectangle
that you've already set as the

00:48:16.960 --> 00:48:19.990
dirty region is a very simple
calculation and can happen very fast,

00:48:20.360 --> 00:48:23.290
rather than comparing
two complex regions.

00:48:23.300 --> 00:48:27.390
Make sure it covers your drawing area,
and then the dirty region

00:48:27.480 --> 00:48:30.200
calculations become simple,
and this will definitely

00:48:30.200 --> 00:48:31.530
improve the speed of your code.

00:48:32.850 --> 00:48:34.980
One caveat, though,
is that you don't want to ignore

00:48:34.980 --> 00:48:36.080
the existing dirty region.

00:48:36.080 --> 00:48:39.510
Make sure you use this API,
qdadrect to dirty region.

00:48:39.780 --> 00:48:42.580
There's another one that ends
in set dirty region that ignores

00:48:42.580 --> 00:48:45.570
the existing dirty region,
so anything that was dirty

00:48:45.570 --> 00:48:47.350
won't get flushed properly.

00:48:49.420 --> 00:48:51.890
And my last quick draw tip.

00:48:52.000 --> 00:48:55.490
Again, before you do a large number
of drawing operations,

00:48:55.490 --> 00:48:58.050
consider using locked
port bits on your port,

00:48:58.170 --> 00:49:00.740
but only if your drawing
time is very short,

00:49:00.800 --> 00:49:03.050
less than a second or so.

00:49:04.070 --> 00:49:07.550
If you leave that port lock too long,
the behaviors become a little

00:49:07.550 --> 00:49:10.500
bit unpredictable and you
might have some redraw issues.

00:49:10.500 --> 00:49:13.100
And definitely if you use that call,
don't forget to unlock the

00:49:13.250 --> 00:49:14.500
port bits when you're finished.

00:49:14.540 --> 00:49:18.500
Because your drawing will definitely
have problems if you don't do that.

00:49:18.500 --> 00:49:20.500
I'm far from being a QuickDraw expert.

00:49:20.500 --> 00:49:21.500
I'm not on the QuickDraw team.

00:49:21.500 --> 00:49:24.500
So I would recommend if you're
interested in QuickDraw performance

00:49:24.500 --> 00:49:27.500
to go to session 516 on Friday,
QuickDraw Performance.

00:49:27.500 --> 00:49:31.900
There's a QuickDraw engineer there
that will give an extended set of

00:49:31.990 --> 00:49:34.390
performance tips for QuickDraw.

00:49:41.090 --> 00:49:44.740
As far as performance documentation goes,
I would really recommend that you read

00:49:44.860 --> 00:49:46.650
the OS X performance documentation.

00:49:46.770 --> 00:49:51.060
It has some great tips in there
for how to isolate and identify

00:49:51.060 --> 00:49:54.880
which areas of your applications are
causing you performance problems.

00:49:55.060 --> 00:49:58.210
I'd also recommend rereading
the Handling Carbon Events and

00:49:58.210 --> 00:50:01.700
Carbon Events Manager Reference
documentation.

00:50:01.770 --> 00:50:05.950
We've said many things today
in reference to Carbon events.

00:50:06.050 --> 00:50:08.170
Some of it might seem new to you,
but some of it has been in

00:50:08.170 --> 00:50:09.340
there for quite a while.

00:50:09.400 --> 00:50:12.040
And you definitely want to keep fresh
on there and understand what's in there.

00:50:12.100 --> 00:50:14.810
I would even recommend
reading carbonevents.h every

00:50:14.870 --> 00:50:18.530
time there's a release,
because it's definitely going to

00:50:18.530 --> 00:50:24.430
become fuller and have more events,
better documentation in the future.

00:50:26.270 --> 00:50:31.740
So in summary, use timers instead of
continuous pooling tracking.

00:50:31.850 --> 00:50:37.100
Use mouse tracking regions instead
of mouse-moved event handlers.

00:50:37.250 --> 00:50:41.570
Pay attention to the notifications that
are available to you as Carbon events.

00:50:42.120 --> 00:50:47.500
And use tracking loops with track mouse
location or track mouse region instead

00:50:47.500 --> 00:50:50.280
of still down or button down tight loops.

00:50:50.280 --> 00:50:54.520
And please stop calling find window
and event avail in tight loops.

00:50:56.460 --> 00:50:58.400
A Roadmap.

00:50:58.420 --> 00:51:01.960
Unfortunately, or fortunately,
maybe you've been to all of these,

00:51:02.000 --> 00:51:04.930
there's been a bunch of
great sessions at WWDC.

00:51:05.430 --> 00:51:09.600
There's Ed's sessions this morning,
the Architectural Overview

00:51:09.600 --> 00:51:12.830
and Introducing HIV,
Guy's session, and there was also

00:51:12.830 --> 00:51:15.910
Curt's session yesterday,
Migrating to Carbon Events.

00:51:15.960 --> 00:51:20.420
I recommend that you watch
all of those on the DVDs.

00:51:20.420 --> 00:51:21.180
That's it for me.

00:51:21.420 --> 00:51:22.480
We'll have Zavia come up.
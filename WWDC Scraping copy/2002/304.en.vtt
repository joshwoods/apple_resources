WEBVTT

00:00:06.620 --> 00:00:08.640
Good evening, folks.

00:00:08.640 --> 00:00:11.720
My name is Chuck Pisula,
and I'm an engineer in the

00:00:11.720 --> 00:00:13.380
Cocoa Frameworks group.

00:00:13.600 --> 00:00:16.540
Today we're going to be
talking about Cocoa Controls,

00:00:16.590 --> 00:00:23.550
and my colleague will be talking about
the Cocoa's new accessibility APIs.

00:00:24.300 --> 00:00:27.730
Now,
Cocoa has a large variety of controls,

00:00:27.740 --> 00:00:31.140
and you'll find that these
controls are easy to use.

00:00:31.200 --> 00:00:34.280
They can be customized and
can bend to suit your needs.

00:00:34.520 --> 00:00:37.540
And also, you'll find if you need
to write your own control,

00:00:37.610 --> 00:00:39.750
well, that's also pretty easy to do.

00:00:41.510 --> 00:00:44.450
So today,
my goal is to talk about some of

00:00:44.560 --> 00:00:49.360
the basic control concepts and APIs,
and my hope in doing so is

00:00:49.360 --> 00:00:52.960
that when you leave here today,
you'll have a basic understanding on how

00:00:53.080 --> 00:00:58.420
to use Cocoa Controls and how to do some
customization of these Cocoa Controls.

00:00:59.180 --> 00:01:01.710
and I'm also hoping that by
the time you leave here today,

00:01:01.710 --> 00:01:04.890
you'll have some insight on
how you write your own control.

00:01:05.000 --> 00:01:08.120
Now, to underscore all these points,
as we go along,

00:01:08.120 --> 00:01:14.210
I'll be presenting a demo which shows
how you can write your own control,

00:01:14.350 --> 00:01:16.790
extend it,
and use it in different various

00:01:16.800 --> 00:01:18.810
ways in your own application.

00:01:20.850 --> 00:01:25.950
So many controls in the
Cocoa frameworks are subclasses of

00:01:25.950 --> 00:01:28.540
these things called NSControl and NSL.

00:01:28.710 --> 00:01:33.480
And we're going to focus today on
those specific set of controls.

00:01:33.650 --> 00:01:36.090
Now,
there are also many other UI elements in

00:01:36.090 --> 00:01:41.380
the Cocoa frameworks which are subclasses
of things other than NSControl and NSL.

00:01:41.510 --> 00:01:45.130
For those today, I'm just going to refer
you to the documentation,

00:01:45.130 --> 00:01:51.090
and we'll move on today
focusing on NSControl and NSL.

00:01:52.210 --> 00:01:53.560
So I mentioned two classes.

00:01:53.790 --> 00:01:56.010
This doesn't mean, however,
that we're going to be talking about

00:01:56.280 --> 00:01:59.030
two completely separate things today.

00:01:59.140 --> 00:02:03.530
In fact, NS Controls and NS Cells
work very closely together,

00:02:03.530 --> 00:02:07.820
and in general this means that
they have very similar APIs.

00:02:07.930 --> 00:02:14.370
Typically, an NS Control does its work,
in fact, by asking its own cell or one of

00:02:14.380 --> 00:02:18.080
its cells to do the work for it.

00:02:21.040 --> 00:02:25.200
Now, a control,
being a subclass of NSView,

00:02:25.200 --> 00:02:29.180
is the one that knows its
location in the view hierarchy,

00:02:29.180 --> 00:02:34.300
and that's sort of its job,
is to manage either its only cell or

00:02:34.410 --> 00:02:38.540
one of its cells and tell it what to do,
and not only what to do,

00:02:38.540 --> 00:02:40.860
but where it should do it.

00:02:40.910 --> 00:02:46.370
And we're going to sort of discover how
this happens throughout our discussion.

00:02:47.370 --> 00:02:52.070
Now, it turns out that this division of
labor between control managing its

00:02:52.210 --> 00:02:57.330
cells and cells doing work for its
control provides us a lot of flexibility.

00:02:57.600 --> 00:03:00.160
In fact,
it makes it pretty easy for us to

00:03:00.160 --> 00:03:04.620
write a control such as a table view,
which can group multiple,

00:03:04.680 --> 00:03:07.820
potentially even
different kinds of cells.

00:03:07.860 --> 00:03:13.710
And it can do this in a manner that
doesn't require lots of memory because a

00:03:13.740 --> 00:03:19.930
cell doesn't have to carry along its own
graphics context like an NSView does.

00:03:23.300 --> 00:03:26.800
So let's talk a little bit
more about NSControl now.

00:03:26.850 --> 00:03:30.200
As I've said,
NSControl is a subclass of NSView,

00:03:30.280 --> 00:03:33.430
so it's the one between
NSControl and NSCell that has

00:03:33.590 --> 00:03:35.620
a place in the view hierarchy.

00:03:35.660 --> 00:03:37.810
And it has sort of two main functions.

00:03:37.990 --> 00:03:43.340
One is to manage its cell or
multiple cells and manage when

00:03:43.340 --> 00:03:44.940
the cell does the work for it.

00:03:45.050 --> 00:03:49.870
So a control will ask its cells
to do things like drawing for it,

00:03:50.030 --> 00:03:52.560
store values for it, and so on.

00:03:52.610 --> 00:03:56.070
And the other bit of work that
it typically does involves

00:03:56.070 --> 00:04:00.080
things not related to cells,
sort of aggregate-level functionality.

00:04:00.240 --> 00:04:02.750
For instance,
a table is the one that's in charge

00:04:02.820 --> 00:04:04.650
of maintaining a row selection.

00:04:04.830 --> 00:04:07.420
Cells do not do the row selection.

00:04:09.860 --> 00:04:13.360
Now, I've been talking about this point
that cells do the work for controls,

00:04:13.470 --> 00:04:18.000
and here is an example of how a
cell can do the work for control,

00:04:18.110 --> 00:04:21.000
even though it doesn't have a
place in the view hierarchy.

00:04:21.060 --> 00:04:23.800
For instance,
when a cell is told to draw,

00:04:23.840 --> 00:04:30.590
it's told where to draw and in
what view it's doing its drawing.

00:04:31.560 --> 00:04:33.520
Now, besides drawing,
cells have lots of other

00:04:33.630 --> 00:04:34.730
things that they do.

00:04:34.740 --> 00:04:40.770
They are able to set and store
values and typically provide

00:04:40.770 --> 00:04:44.900
functionality that allows you to
customize the look of a control.

00:04:48.410 --> 00:04:52.030
Now, I've been driving home this
point that NS Control does its

00:04:52.080 --> 00:04:55.050
work by telling its NS cell,
or one of its cells,

00:04:55.050 --> 00:04:56.070
to do the work for it.

00:04:56.300 --> 00:05:02.300
And what this means then is that if
you're writing your own control and cell,

00:05:02.310 --> 00:05:04.300
you're not writing twice as much code.

00:05:04.820 --> 00:05:08.970
Because typically, NS Control is simply,
its methods are simply

00:05:09.100 --> 00:05:11.300
covers for NS cell methods.

00:05:11.450 --> 00:05:14.280
So when you ask a button
for its string value,

00:05:14.330 --> 00:05:18.300
it just implements it by asking its
button cell for its string value.

00:05:18.300 --> 00:05:22.280
And you'll find that you don't actually
really even end up writing lots of this

00:05:22.280 --> 00:05:26.960
boilerplate code that forwards methods,
because NS Control itself provides most

00:05:26.960 --> 00:05:31.300
of this base functionality for you,
so that you don't have to do it yourself.

00:05:39.350 --> 00:05:44.430
Now, so, from here on out,
since controls and cells are so

00:05:44.430 --> 00:05:48.470
similar and have very similar APIs,
I'm mostly going to be using the

00:05:48.480 --> 00:05:52.290
term "control" when I'm referring
to NSControls and NSCells.

00:05:52.630 --> 00:05:55.030
And where I want to be specific,
I'll specifically say,

00:05:55.100 --> 00:05:58.170
"This pertains to NSControls
or this pertains to NSCells."

00:05:58.270 --> 00:06:01.270
So just to simplify the discussion,
I'll use "controls" to mean

00:06:01.270 --> 00:06:03.000
both for most of the time.

00:06:03.450 --> 00:06:04.830
From here,
we're going to move on to talking a

00:06:04.830 --> 00:06:08.950
little bit about some of the standard
functionality provided by controls,

00:06:08.960 --> 00:06:14.810
including setting and getting values,
dealing with target actions, delegation,

00:06:15.070 --> 00:06:19.960
control sizes, and various other things
that cells provide for you.

00:06:20.630 --> 00:06:23.940
Excuse me, controls.

00:06:25.840 --> 00:06:31.880
So to start off, controls have this
concept of setting values,

00:06:31.970 --> 00:06:36.800
and it's not really a very
hard concept to understand.

00:06:36.910 --> 00:06:41.080
But the thing that's interesting
to know is that typically a control

00:06:41.160 --> 00:06:43.590
implements lots of different

00:06:43.930 --> 00:06:47.730
The first thing I want to talk
about is the value of a slider.

00:06:47.770 --> 00:06:50.440
It seems natural that a
slider would provide you a set

00:06:50.500 --> 00:06:53.880
floating point value method,
and that would reflect in the

00:06:53.880 --> 00:06:56.360
slider the value that you just set.

00:06:56.410 --> 00:07:00.630
However, a slider also allows you to set
its value using a string value.

00:07:00.680 --> 00:07:04.510
As long as it can convert that into
something it knows how to display,

00:07:04.600 --> 00:07:08.680
it will go ahead and convert the
string into a floating point value.

00:07:08.680 --> 00:07:12.960
So it's good to know that
whenever you're using controls,

00:07:13.280 --> 00:07:16.780
you can typically set any kind of
value on them as long as they can

00:07:16.850 --> 00:07:18.680
convert it into what they need to do.

00:07:19.030 --> 00:07:22.670
And likewise, they can return you values
in multiple formats.

00:07:22.680 --> 00:07:26.400
So you'll also want to keep this in mind
when you're writing your own control,

00:07:26.400 --> 00:07:28.810
that if it makes sense,
you should support as many

00:07:28.810 --> 00:07:31.790
different kinds of setters
and getters that you can.

00:07:36.800 --> 00:07:39.910
The next thing I'm going to
talk about is control size.

00:07:40.230 --> 00:07:43.690
When you're dealing with views,
normally you can have a view

00:07:43.690 --> 00:07:46.100
resized to just about any size.

00:07:46.180 --> 00:07:48.940
But when you're dealing
with standard UI elements,

00:07:49.020 --> 00:07:55.740
typically you want to have them be one
of the standard sizes in the system.

00:07:55.770 --> 00:08:01.370
And this control size property that
controls have allow you to pick either

00:08:01.370 --> 00:08:07.440
a small or a regular variant of the
standard controls in the frameworks.

00:08:07.520 --> 00:08:10.060
So if you want to have, for example,
a small button,

00:08:10.230 --> 00:08:14.390
you would set its control size
to be in a small control size.

00:08:15.120 --> 00:08:22.560
and typically the cell is the one that
implements this control size property.

00:08:22.590 --> 00:08:27.380
But when you have a control
that doesn't have a cell,

00:08:27.720 --> 00:08:32.790
it makes sense for the NSControl
to be the one that implements this.

00:08:32.790 --> 00:08:32.790
So for instance,
NSTabView doesn't deal in cells,

00:08:32.790 --> 00:08:32.790
so it's the one that implements
this control size setter.

00:08:40.400 --> 00:08:45.350
Okay, so I figure everybody's already
attended the intro sections,

00:08:45.350 --> 00:08:47.100
or they're already very
familiar with target action,

00:08:47.120 --> 00:08:50.040
so we're not going to talk about
the concept of target action.

00:08:50.080 --> 00:08:54.180
I'm just going to mention
that controls are,

00:08:54.200 --> 00:08:55.620
you know,
typically tend to be things that

00:08:55.620 --> 00:08:59.380
users interact with and they click on,
and users expect things to

00:08:59.440 --> 00:09:00.520
happen when they click on them.

00:09:00.680 --> 00:09:03.230
And this is where target
action comes into play.

00:09:03.610 --> 00:09:08.490
Controls have a target that they send
an action method to when some sort

00:09:08.500 --> 00:09:10.620
of user interaction has happened.

00:09:10.650 --> 00:09:13.160
When you click a button,
the action method gets sent.

00:09:13.180 --> 00:09:15.720
When a slider value changes,
the action method gets sent.

00:09:15.880 --> 00:09:18.850
And for some controls,
they will actually do this continuously,

00:09:18.850 --> 00:09:21.820
or they could wait until you're
done manipulating the value.

00:09:21.870 --> 00:09:24.060
So a slider could
continuously send this action,

00:09:24.060 --> 00:09:27.250
or it could wait until you've
reached your final value

00:09:27.260 --> 00:09:29.350
that you decided to pick.

00:09:29.680 --> 00:09:32.850
An interesting thing to note when
you're programming is that the sender

00:09:32.850 --> 00:09:36.600
argument in these target action
methods will always be the control.

00:09:36.670 --> 00:09:39.600
If for some reason you
need to access the cell,

00:09:39.660 --> 00:09:43.230
then, well, it's either the only cell
that the control has,

00:09:43.270 --> 00:09:46.940
or if it has multiple cells,
it'll be the selected cell.

00:09:48.940 --> 00:09:52.040
And sometimes controls
provide their own actions,

00:09:52.040 --> 00:09:57.330
so I might want to be able to receive
a distinct action method when someone

00:09:57.330 --> 00:10:01.020
double-clicks in a table view row.

00:10:04.520 --> 00:10:08.190
Many people writing their own
applications often want to customize

00:10:08.240 --> 00:10:12.660
or be involved in the text editing
that's going on in a control,

00:10:12.660 --> 00:10:15.260
and controls allow you this ability.

00:10:15.650 --> 00:10:18.380
They give you a couple different options.

00:10:18.400 --> 00:10:23.070
So if you need to customize text editing,
one way is to implement some

00:10:23.140 --> 00:10:26.420
delegate methods that let you know,
for instance,

00:10:26.560 --> 00:10:31.400
that a text value just changed,
or you could have the control ask you,

00:10:31.400 --> 00:10:33.400
"Should text begin
editing?" and so forth.

00:10:33.400 --> 00:10:35.400
I'm going to touch on a
little bit of this API,

00:10:35.400 --> 00:10:38.270
the specific API for this,
a little bit later,

00:10:38.270 --> 00:10:41.190
so I'll just leave it at that for now.

00:10:41.370 --> 00:10:46.020
If you need to customize
how editing actually works,

00:10:46.020 --> 00:10:49.090
there's something called a
field editor that you can modify

00:10:49.220 --> 00:10:51.060
attributes for or even replace.

00:10:51.130 --> 00:10:53.390
It turns out that

00:10:53.770 --> 00:10:57.200
Even if you have multiple
text fields in a window,

00:10:57.290 --> 00:11:01.060
there's only one view
that does the editing.

00:11:01.070 --> 00:11:06.660
When you start editing in a text field,
a text view is swapped in its place,

00:11:06.670 --> 00:11:09.460
and that's where the
editing actually happens.

00:11:09.550 --> 00:11:12.460
Typically, you don't have to worry about
this level of indirection,

00:11:12.630 --> 00:11:15.720
but if you want to customize editing,
it's something you might

00:11:15.720 --> 00:11:17.000
need to know about.

00:11:17.090 --> 00:11:22.180
Now, you're probably maybe thinking,
"Why would I need to customize this

00:11:22.240 --> 00:11:27.740
editor?" One good example is the secure
text field in the Cocoa frameworks.

00:11:27.900 --> 00:11:32.440
It goes ahead and replaces the standard
field editor with its own so that it

00:11:32.550 --> 00:11:35.490
knows that it shouldn't copy and paste.

00:11:36.830 --> 00:11:38.600
And finally,
another way to customize text

00:11:38.700 --> 00:11:42.230
editing is to simply attach
formatters to a text field.

00:11:42.570 --> 00:11:45.640
For instance,
you could force the values in

00:11:45.640 --> 00:11:48.530
a text field to be date values.

00:11:50.160 --> 00:11:56.140
Okay, so I just mentioned these text
editing notifications and delegation,

00:11:56.190 --> 00:11:59.640
and now we're going to see
what the API looks like.

00:11:59.720 --> 00:12:02.440
In general,
controls will provide their own

00:12:02.710 --> 00:12:05.840
delegate messages so that you
can customize their behavior.

00:12:05.970 --> 00:12:09.510
So each specific control will
have their own specific set of

00:12:09.510 --> 00:12:10.890
these delegation and notification.

00:12:10.970 --> 00:12:17.660
But it turns out that any control that
allows text editing has a standard set

00:12:17.660 --> 00:12:20.100
of delegate messages and notifications.

00:12:20.320 --> 00:12:26.460
And basically what it does is send
you... Let me back up a second.

00:12:26.660 --> 00:12:28.880
The control...

00:12:29.440 --> 00:12:34.470
The table view that's being edited wants
to be the delegate of this field editor.

00:12:34.690 --> 00:12:39.320
It's actually the one that's receiving
text-editing delegate messages,

00:12:39.320 --> 00:12:43.930
because a table view really needs to
know that text started editing and it

00:12:43.930 --> 00:12:46.510
needs to know when it ends editing.

00:12:46.930 --> 00:12:52.900
But being a good citizen,
any control that is doing this decides

00:12:53.030 --> 00:12:56.490
that it will forward these delegate
messages to you so that you can be part

00:12:56.530 --> 00:12:58.740
of the decisions that are going on.

00:12:58.780 --> 00:13:02.350
And you can also know that, for instance,
text just changed in this

00:13:02.350 --> 00:13:04.460
table view that's being edited.

00:13:04.690 --> 00:13:07.990
So if you need to know, for instance,
that text has changed,

00:13:08.070 --> 00:13:10.650
you would register for the
NS Control text to change

00:13:10.810 --> 00:13:12.790
notification on your table.

00:13:21.300 --> 00:13:27.200
Okay, so controlled, excuse me,
NS cells are the ones that do lots

00:13:27.280 --> 00:13:29.420
of the work for their controls.

00:13:29.440 --> 00:13:32.720
And in fact,
we've already touched on drawing,

00:13:33.040 --> 00:13:35.750
that cells,
even though they're not a view,

00:13:35.920 --> 00:13:38.700
they do the drawing for their NS control.

00:13:38.850 --> 00:13:41.680
They also can do things
like handle mouse events.

00:13:41.880 --> 00:13:45.910
So you see the method up here,
trackMouse, indirect of view,

00:13:45.970 --> 00:13:47.300
until mouseUp.

00:13:47.330 --> 00:13:54.520
This is the method that gets sent to
a cell when it starts mouse tracking.

00:13:54.520 --> 00:13:56.810
And of course, again,
you'll see this as a recurring

00:13:56.930 --> 00:13:59.550
theme that when we tell it to
do something for a view that

00:13:59.610 --> 00:14:03.770
involves event handling or drawing,
it's told what the cell frame

00:14:03.890 --> 00:14:05.990
is and in what view it's in.

00:14:07.440 --> 00:14:12.850
It turns out that if you want to do
mouse tracking at a finer granularity,

00:14:12.900 --> 00:14:16.320
there's a set of three methods that
you could override that make it a

00:14:16.320 --> 00:14:17.900
little easier than doing this one.

00:14:17.930 --> 00:14:21.220
And I'll just refer you to
the documentation for that.

00:14:21.280 --> 00:14:26.260
Now, it sounds like basically cell is
always told what it's supposed to do.

00:14:26.280 --> 00:14:33.360
It turns out it actually is allowed
to tell its control some things too.

00:14:33.440 --> 00:14:37.360
For instance, if a cell knows that it
needs to be at least so big,

00:14:37.380 --> 00:14:40.220
you can override the cell
size for bounds method and try

00:14:40.260 --> 00:14:43.550
and tell your control that,
"Hey, I need to be at least this big."

00:14:47.500 --> 00:14:51.030
Okay,
so you can draw in a cell using a cell.

00:14:51.030 --> 00:14:52.660
You can track the mouse using a cell.

00:14:52.740 --> 00:14:56.770
You can actually even provide
context menus as a cell.

00:14:57.090 --> 00:15:01.230
Views provide the functionality
of having context menus.

00:15:01.390 --> 00:15:07.770
There's methods like set menu,
return the menu, provide a default menu,

00:15:07.850 --> 00:15:10.440
but cells are also allowed
to provide their own menu.

00:15:10.530 --> 00:15:13.800
And again, you see this mantra again,
"Menu for event,

00:15:13.950 --> 00:15:16.980
in-rect of view." There's the
in-rect of view parameter,

00:15:17.050 --> 00:15:19.520
so that the cell can use that
information to determine,

00:15:19.600 --> 00:15:22.200
you know,
say if I'm in the right half of the cell,

00:15:22.250 --> 00:15:23.680
then I provide this one menu.

00:15:23.900 --> 00:15:26.820
If I'm in the left half,
I'll give this other one.

00:15:36.200 --> 00:15:37.940
Okay,
so that's a little bit about some of

00:15:37.940 --> 00:15:44.760
the basic concepts and APIs that you'll
find when you're dealing with controls,

00:15:44.840 --> 00:15:46.200
NS Controls and NS Cells.

00:15:46.450 --> 00:15:51.320
Now, there are lots of simple controls
in the Cocoa framework you can just

00:15:51.370 --> 00:15:53.700
use right off the pallet in IB.

00:15:53.900 --> 00:15:56.530
And because they're
really so simple to use,

00:15:56.700 --> 00:15:59.110
I just decided I would throw
up a picture of them and not

00:15:59.110 --> 00:16:00.170
really talk too much about them.

00:16:00.250 --> 00:16:03.200
I think it's something everyone
can go and explore on their own.

00:16:03.390 --> 00:16:06.640
But of the ones I have up here,
there's some interesting

00:16:06.740 --> 00:16:08.260
comments to be made.

00:16:08.660 --> 00:16:12.450
The checkbox, the radio button,
and all the variations of

00:16:12.560 --> 00:16:16.580
button you see on the left side,
actually all happen to be just

00:16:16.580 --> 00:16:19.090
different styles of an NSButton.

00:16:20.710 --> 00:16:24.600
The secure text field,
you see that actually that

00:16:24.810 --> 00:16:28.530
just has the dots in it,
is a subclass of NSTextFieldCell,

00:16:28.560 --> 00:16:31.840
and these are the two
main forms of text entry.

00:16:31.890 --> 00:16:35.830
There are controls that allow
you to just display an image.

00:16:36.050 --> 00:16:39.420
Controls such as the color wall
that allow you to select a color

00:16:39.420 --> 00:16:43.500
and bring up the color panel.

00:16:43.550 --> 00:16:45.110
And there are controls that combine

00:16:45.750 --> 00:16:50.140
Characteristics of things like
the text field and pop-up buttons

00:16:50.150 --> 00:16:53.570
and give you something like
the combo box on the far right.

00:16:53.590 --> 00:16:57.280
The combo box is part text field,
part pop-up.

00:16:58.420 --> 00:17:00.700
So,
if you want to find out more about those,

00:17:00.770 --> 00:17:04.260
I would just go on IB,
drag them off the palette,

00:17:04.260 --> 00:17:07.220
and just play around with the
different attributes that you

00:17:07.220 --> 00:17:10.340
can set and use with them.

00:17:10.340 --> 00:17:13.210
For now,
I'd like to go to the demo machine.

00:17:21.700 --> 00:17:24.880
Okay, for our first demo,
we're going to start by

00:17:24.890 --> 00:17:28.220
creating our own control,
and you'll see some of these methods

00:17:28.480 --> 00:17:31.610
that we talked about in action,
as well as some of the controls

00:17:31.690 --> 00:17:33.920
that we just saw on the screen.

00:17:35.220 --> 00:17:39.030
So let's start out by going, well,
let's start out by me explaining

00:17:39.030 --> 00:17:40.500
what we're going to do.

00:17:40.550 --> 00:17:43.570
We're going to start out and
try and create a project that

00:17:44.060 --> 00:17:45.820
has our own clock control on it.

00:17:46.000 --> 00:17:49.930
So we're going to create a subclass
of NSControl that's a clock control.

00:17:49.980 --> 00:17:54.880
We're going to create a subclass
of NSCell that's a clock cell.

00:17:55.160 --> 00:17:59.150
And we're going to use it just in
a straightforward way in this demo,

00:17:59.150 --> 00:18:03.720
but then we're going to use it throughout
in our other demos and extend it.

00:18:03.740 --> 00:18:05.690
So to start,
let's show you the declaration

00:18:05.690 --> 00:18:07.800
of this clock cell.

00:18:14.560 --> 00:18:19.060
Clock Cell actually is a
subclass of NS Action Cell.

00:18:19.070 --> 00:18:22.240
That's something I'll just refer
you to the documentation for.

00:18:22.240 --> 00:18:26.140
NS Action Cell is the one that
has the action and a target.

00:18:26.150 --> 00:18:29.120
It's aptly named Action Cell.

00:18:29.120 --> 00:18:30.790
And we've declared a couple methods.

00:18:30.880 --> 00:18:32.070
We want to be able to set times.

00:18:32.160 --> 00:18:36.210
We want to be able to connect
it to things in IB that tell it,

00:18:36.220 --> 00:18:40.060
"Hey, take your hour value
from me," and so forth.

00:18:40.070 --> 00:18:44.420
And again, because controls and cells
do lots of the same things,

00:18:44.470 --> 00:18:49.500
you see the clock control has pretty much
the same interface as the clock cell.

00:18:51.660 --> 00:18:56.200
So let's go take a look at the code.

00:18:56.230 --> 00:18:59.440
And let me point out first,
there's a lot of code there,

00:18:59.440 --> 00:19:04.420
but a lot of it's just legalese.

00:19:04.440 --> 00:19:09.210
The first thing I want to point out
is that there's really not much to the

00:19:09.210 --> 00:19:12.880
NS Control subclass that we've made.

00:19:12.900 --> 00:19:16.490
There's a couple things we do for setup.

00:19:17.000 --> 00:19:23.750
and then a couple of the setter methods
and the take value from type methods.

00:19:23.750 --> 00:19:25.980
And all we really do is
forward it off to our cell.

00:19:25.990 --> 00:19:28.000
We don't really do anything ourselves.

00:19:28.000 --> 00:19:31.390
And you might be thinking, "Well,
how does this cell ever end up drawing?

00:19:31.560 --> 00:19:34.780
We don't tell it to draw anywhere." Well,
it turns out that NS Control provides

00:19:35.360 --> 00:19:38.890
lots of standard default behavior
for it that just does what we want.

00:19:39.010 --> 00:19:41.820
So we're going to be
able to draw our clock,

00:19:41.870 --> 00:19:47.080
be able to track the mouse,
pop up a context menu,

00:19:47.100 --> 00:19:51.000
all with what we currently have here,
which is basically just default behavior.

00:19:51.000 --> 00:19:55.780
So let's go look at what we've
done for cell a little bit.

00:19:57.000 --> 00:19:59.140
And before I go on,
let me point out that I'm not

00:19:59.280 --> 00:20:04.300
really going to hover or hang around
with any of the code too much.

00:20:04.320 --> 00:20:06.340
I'm going to skim over it pretty quickly.

00:20:06.380 --> 00:20:09.240
But we've made the code available.

00:20:09.260 --> 00:20:11.570
It wasn't available
as of 3 o'clock today,

00:20:11.570 --> 00:20:13.180
but it should be there soon.

00:20:13.640 --> 00:20:17.760
What you should do is log into the
ADC site and use your seed key to check

00:20:17.850 --> 00:20:21.430
out what's new in the downloadable area.

00:20:23.210 --> 00:20:24.620
So we've got some initial setup.

00:20:24.710 --> 00:20:26.370
We have some initialization routines.

00:20:26.370 --> 00:20:27.570
I'm going to skim over these.

00:20:27.660 --> 00:20:33.330
They're pretty standard,
in it with coders, archiving-type things.

00:20:33.400 --> 00:20:35.600
We need the ability to be able
to copy for various things.

00:20:35.670 --> 00:20:39.340
They're just boilerplate things
that we sort of fill out always.

00:20:39.380 --> 00:20:43.510
And we're going to have a clock
that's changing its value,

00:20:43.660 --> 00:20:47.490
so we're actually going to want to
be able to send an action message

00:20:47.490 --> 00:20:49.060
to someone when our value changes.

00:20:49.060 --> 00:20:55.730
So here's a little utility routine
that will send the action for us.

00:20:56.730 --> 00:21:02.400
Moving on, we've got a bunch of utility
routines that set the time in

00:21:02.570 --> 00:21:06.140
various manners by incrementing,
by moving to a specific time,

00:21:06.260 --> 00:21:09.710
by checking the angle from north.

00:21:10.630 --> 00:21:13.730
We've got some other setters.

00:21:13.730 --> 00:21:18.970
And I decided that it made sense to allow
someone to set it using a string value.

00:21:19.100 --> 00:21:23.420
As long as it's a format I understand,
I'll convert the string value to a time.

00:21:25.860 --> 00:21:29.300
We've implemented our
"takeMinuteValueFrom,"

00:21:29.300 --> 00:21:32.770
"takeHourValueFrom," "takeStyleMethods."

00:21:33.470 --> 00:21:38.080
Then we have a routine here which
draws the hands of the clock.

00:21:38.110 --> 00:21:39.000
This is a lot of math.

00:21:39.020 --> 00:21:41.270
I'm just going to skip over it.

00:21:42.870 --> 00:21:48.230
And finally, we have our Draw With Frame,
which does the work of looking up an

00:21:48.230 --> 00:21:53.170
image that we draw in our background
and finally drawing the image

00:21:53.360 --> 00:21:55.850
and then drawing the clock hands.

00:21:57.220 --> 00:22:02.980
We've got some utility routine here,
I'll skip over.

00:22:02.980 --> 00:22:02.980
And then we have...

00:22:03.410 --> 00:22:06.840
If we scroll down to it,
the mouse tracking routine,

00:22:06.840 --> 00:22:08.450
which is going to track the mouse.

00:22:08.610 --> 00:22:11.460
So when I click on the clock,
I want it to update its time

00:22:11.590 --> 00:22:13.600
as I move the mouse around.

00:22:15.200 --> 00:22:19.250
And the stuff I skipped over is just
sort of hit detection and event tracking.

00:22:19.450 --> 00:22:23.140
That's stuff you can look at in
the demo code if you download it.

00:22:23.320 --> 00:22:26.430
And then I've overridden menu for
event to return a context menu,

00:22:26.440 --> 00:22:30.130
which will show me the time and
allow me to change the time.

00:22:32.200 --> 00:22:33.700
and that's it.

00:22:33.760 --> 00:22:37.890
So now let's go look at what
we have in Interface Builder.

00:22:39.600 --> 00:22:44.000
I've got a lot of material to cover,
so I've already... Excuse me.

00:22:44.040 --> 00:22:48.450
I've gone ahead and already
dragged out all of the things that

00:22:48.450 --> 00:22:49.550
I want to use in the interface.

00:22:49.660 --> 00:22:53.120
I'm just going to connect them up
so I can show you what's happening.

00:22:53.120 --> 00:22:59.110
I want this slider value,
when it's moved to...

00:23:00.700 --> 00:23:16.500
[Transcript missing]

00:23:18.510 --> 00:23:23.480
We're going to let our application
controller have an outlet so that

00:23:23.620 --> 00:23:25.260
we'll call it a time readout.

00:23:25.310 --> 00:23:30.880
Whenever the clock time changes,
we will actually have the clock send

00:23:30.880 --> 00:23:33.290
the action method to the app controller,
and then it's going

00:23:33.400 --> 00:23:34.340
to update the readout.

00:23:34.340 --> 00:23:37.760
So we connect the clock's
action to our app controller,

00:23:37.760 --> 00:23:41.280
and it'll invoke the
clock time changed method.

00:23:41.280 --> 00:23:42.270
So let's save.

00:23:42.270 --> 00:23:47.680
We'll go back to Project Builder
2nd and show you the action method.

00:23:52.100 --> 00:23:54.440
"It's really pretty simple.

00:23:54.440 --> 00:23:58.120
All it does is ask the
clock for its string value,

00:23:58.120 --> 00:24:01.730
which the clock converts
to a standard format,

00:24:01.730 --> 00:24:03.230
and we display it.

00:24:03.370 --> 00:24:05.410
So let's build and run."

00:24:09.300 --> 00:24:13.270
Okay,
so you saw again that the control code

00:24:13.320 --> 00:24:14.530
was really pretty straightforward.

00:24:14.590 --> 00:24:16.220
We didn't tell it where
it was supposed to draw,

00:24:16.360 --> 00:24:18.460
when it was supposed to draw,
but it's drawing because

00:24:18.540 --> 00:24:19.840
it inherited that behavior.

00:24:20.030 --> 00:24:22.290
Same thing for tracking.

00:24:23.370 --> 00:24:45.600
Thank you for joining us.

00:24:46.820 --> 00:24:46.850
I'm going to go back to some more
discussion and then we'll come back

00:24:46.850 --> 00:24:46.850
to this demo a little bit later and
extend it and use it in different ways.

00:24:46.850 --> 00:24:46.850
So if we could have the slides again,
please.

00:24:54.710 --> 00:24:57.390
Okay, we're going to talk about
some more controls now.

00:24:57.540 --> 00:25:00.200
Specifically,
the stuff we've been talking about so far

00:25:00.380 --> 00:25:04.150
have been sort of single-celled beasts,
where, for instance,

00:25:04.210 --> 00:25:08.040
a button has one cell, an NSButton cell.

00:25:08.110 --> 00:25:09.570
Now we're going to be
talking about controls that

00:25:09.950 --> 00:25:12.100
typically have multiple cells.

00:25:12.380 --> 00:25:15.490
We're going to talk about NSTabView,
we're going to talk about TableView,

00:25:15.650 --> 00:25:18.110
OutlineView, and Browser.

00:25:19.910 --> 00:25:24.570
And as tab view actually is a class
that doesn't really use any cells.

00:25:24.570 --> 00:25:29.340
And as tab view is a control
because it has a target in action.

00:25:29.370 --> 00:25:32.010
So when you change the
currently selected tab,

00:25:32.090 --> 00:25:34.740
it'll send an action
method to its target.

00:25:34.820 --> 00:25:39.810
But the things that it displays happen
to be the views of its tab view items.

00:25:39.970 --> 00:25:46.320
And the things that it displays
in the tab at the top happen to be

00:25:46.320 --> 00:25:46.520
the label of the tab view items.

00:25:47.410 --> 00:25:52.790
NSTabView in Jaguar now
supports directional tabs,

00:25:52.800 --> 00:25:56.120
so you can have tabs in the left, right,
bottom, and top.

00:25:56.130 --> 00:25:59.720
And also, it supports tabless tabs,
if you happen to need

00:25:59.720 --> 00:26:00.520
something like that.

00:26:00.520 --> 00:26:03.640
It can be useful as a
simple view swapper.

00:26:03.660 --> 00:26:07.720
And because NSTabView doesn't
have any cells,

00:26:07.720 --> 00:26:09.960
it's the one that implements
this control size property,

00:26:09.960 --> 00:26:12.600
so you can have small
and regular controls,

00:26:12.620 --> 00:26:19.650
but you would tell the tab that
you want the small control size.

00:26:20.140 --> 00:26:21.850
Next, I'm going to talk about matrix.

00:26:22.100 --> 00:26:26.010
And the thing I want to point
out about matrix is you usually

00:26:26.010 --> 00:26:27.230
don't make these programmatically.

00:26:27.230 --> 00:26:29.390
These are usually things
that you get in IB.

00:26:29.510 --> 00:26:33.430
If you've played around
in IB and happened to,

00:26:33.440 --> 00:26:37.960
I believe it's option drag, say a button,
you'll notice that all of a sudden

00:26:38.000 --> 00:26:41.540
you start getting more buttons,
all grouped in a regular grid.

00:26:41.970 --> 00:26:52.510
Well, this option dragging has created a
matrix of NSButton cells for you.

00:26:52.510 --> 00:26:52.510
It started with a button, with one cell,
and then converted it into

00:26:52.510 --> 00:26:52.510
a matrix of button cells.

00:26:54.840 --> 00:26:57.340
Now, if you need to create a
matrix programmatically,

00:26:57.340 --> 00:27:01.670
it can surely be done, and it's useful,
for instance, when you want to have a

00:27:01.670 --> 00:27:03.940
gridded group of cells.

00:27:04.070 --> 00:27:09.010
And there's lots of API that allows you
to control the arrangement of cells and

00:27:09.010 --> 00:27:10.700
control the appearance and so forth.

00:27:10.890 --> 00:27:13.010
And I'm not going to go into
those because the real reason

00:27:13.020 --> 00:27:17.410
I wanted to talk about matrix is
because it's used by NSBrowser.

00:27:17.930 --> 00:27:22.300
So NSBrowser is used-- you're all,
I'm sure,

00:27:22.300 --> 00:27:23.540
familiar with it from the open panel.

00:27:23.540 --> 00:27:26.180
It displays hierarchical data.

00:27:26.520 --> 00:27:35.030
and each column in the browser
happens to be in NSMatrix that's

00:27:35.030 --> 00:27:35.030
wrapped in an NSScrollView.

00:27:35.210 --> 00:27:37.620
These matrices are filled
with a bunch of cells,

00:27:37.680 --> 00:27:40.850
and all the cells happen
to be NSBrowserCell or

00:27:40.850 --> 00:27:42.860
NSBrowserCell subclasses.

00:27:42.920 --> 00:27:47.640
And the data that's going to go
into these cells is provided by you.

00:27:47.650 --> 00:27:50.360
When you're writing your program,
you're going to supply a

00:27:50.360 --> 00:27:53.820
delegate for the browser,
and it's this delegate that will

00:27:54.200 --> 00:27:58.280
load data into these cells that
the browser then displays for you.

00:27:58.550 --> 00:28:01.060
and again,
there's lots of API that I would

00:28:01.680 --> 00:28:05.630
recommend just going to the documentation
for to figure out how it allows you

00:28:05.860 --> 00:28:08.480
to control NS Browser in various ways.

00:28:09.410 --> 00:28:13.110
Okay, so you're the one that's in control
of loading the data into the browser.

00:28:13.260 --> 00:28:14.440
So how do you do it?

00:28:14.560 --> 00:28:16.290
Well,
there's two mechanisms for doing it.

00:28:16.300 --> 00:28:19.290
One is referred to in the
documentation as active.

00:28:19.420 --> 00:28:21.540
The other one is referred to as passive.

00:28:21.600 --> 00:28:26.040
I sometimes prefer to think
of this as immediate or lazy.

00:28:26.290 --> 00:28:32.080
Not because I'm a lazy person,
but just immediate or lazy.

00:28:33.510 --> 00:28:38.780
In the immediate manner,
when the browser needs to load

00:28:38.810 --> 00:28:42.030
a new column with some data,
it's going to send a message

00:28:42.100 --> 00:28:46.740
to your delegate and say,
"Hey, go ahead and load a list of this

00:28:46.810 --> 00:28:52.430
many browser cells into this matrix
that I sent you." And it turns out

00:28:52.430 --> 00:28:56.510
that this matrix happens to be at
a particular place in the browser.

00:28:56.600 --> 00:29:01.750
So you're given the matrix and you fill
it with your own custom NSBrowser cells.

00:29:02.770 --> 00:29:05.930
When you're loading
data in a lazy fashion,

00:29:05.930 --> 00:29:09.200
and this makes sense, for instance,
if you're an open panel,

00:29:09.200 --> 00:29:12.550
which doesn't want to necessarily
touch everything in a directory that

00:29:12.620 --> 00:29:14.860
you just saw on a network file system.

00:29:14.990 --> 00:29:20.420
So what you would do in that situation is

00:29:21.130 --> 00:29:23.970
Implement methods that tell the browser,
"Okay,

00:29:24.110 --> 00:29:28.070
for this new column that you just saw,
this is how many rows I want to

00:29:28.070 --> 00:29:30.990
have in it." And then you don't
actually load the data right away.

00:29:30.990 --> 00:29:35.000
You just tell it these are how
many rows that the column has.

00:29:35.050 --> 00:29:39.000
Now, each time the browser has to
display one of those cells,

00:29:39.000 --> 00:29:42.940
it will realize that cell's not loaded,
and it will send you the "browser

00:29:43.010 --> 00:29:46.000
will display cell at row" method.

00:29:46.080 --> 00:29:49.000
And at that point,
what you do is load the data.

00:29:49.000 --> 00:29:51.350
So the first time the cell
has to be displayed is the

00:29:51.810 --> 00:29:54.000
time when you load the data.

00:30:00.620 --> 00:30:04.140
Now, because browser cells
can be loaded lazily,

00:30:04.140 --> 00:30:09.100
browser cells have to be able to tell
you if they've been loaded or not.

00:30:09.100 --> 00:30:13.140
And the only other real property
that's interesting in NSBrowser cells

00:30:13.210 --> 00:30:17.720
themselves is the fact that they can
be a leaf node or a non-leaf node.

00:30:17.740 --> 00:30:21.590
Typically, you're going to just make your
own subclasses of NSBrowserCell,

00:30:21.660 --> 00:30:25.680
and that's what you're going to load
into the matrices of your browser.

00:30:28.360 --> 00:30:33.790
Okay, so let's move on to NS Table View,
which is not a hierarchical data.

00:30:33.800 --> 00:30:38.280
It's basically a simple list that

00:30:38.570 --> 00:30:42.240
is divided into many different parts.

00:30:42.250 --> 00:30:45.400
A table happens to live
inside of a scroll view,

00:30:45.400 --> 00:30:50.120
which has a header view,
which is divided into multiple columns.

00:30:50.220 --> 00:30:54.290
So there's many parts
to an NS table view.

00:30:54.740 --> 00:30:58.040
The important parts,
which we're gonna touch on,

00:30:58.060 --> 00:31:02.370
are the table itself
and the table column.

00:31:06.930 --> 00:31:10.690
Okay, so just like NS Browser,
NS TableView depends

00:31:10.730 --> 00:31:12.490
heavily on a data source.

00:31:12.800 --> 00:31:17.240
In fact, it depends even more heavily on
someone to supply it with data.

00:31:17.310 --> 00:31:22.820
Whereas the browser has an immediate mode
where it can load all the data up front,

00:31:22.880 --> 00:31:24.290
TableView has no such option.

00:31:24.420 --> 00:31:28.120
All of its data always
comes from the data source.

00:31:28.170 --> 00:31:33.080
And one of the main reasons for this is,
for instance, in, say you're writing a

00:31:33.080 --> 00:31:35.800
database application,
and you had thousands of elements

00:31:35.950 --> 00:31:38.700
that you wanted to have on a table,
you would never want to load

00:31:38.840 --> 00:31:40.560
all those elements into a table.

00:31:40.690 --> 00:31:42.680
You want to load it in a lazy manner.

00:31:42.690 --> 00:31:47.260
And another good reason for this is
that this clearly separates your model

00:31:47.390 --> 00:31:52.210
from your view in your application,
and allows you much more flexibility.

00:31:52.940 --> 00:31:55.400
So as a data source,
you implement two methods.

00:31:55.400 --> 00:32:00.140
The first one, much like the browser,
tells it how many rows it has.

00:32:00.190 --> 00:32:03.890
And the second one is a method
which provides data that's going

00:32:03.890 --> 00:32:06.880
to be given to a cell so the cell
knows what it should display.

00:32:07.000 --> 00:32:08.730
So the second method
is the interesting one,

00:32:08.760 --> 00:32:10.900
which I'm going to talk
about a little bit later.

00:32:11.030 --> 00:32:12.860
You notice it's returning
this thing called,

00:32:12.890 --> 00:32:16.860
given a table view, it returns the object
value for a particular

00:32:16.860 --> 00:32:18.820
intersection of column and row.

00:32:18.900 --> 00:32:22.660
And we'll talk about a little bit
later what this object value is.

00:32:24.170 --> 00:32:26.870
Now, since you're the one that's
controlling all the data,

00:32:27.090 --> 00:32:30.120
there are a couple methods that you
need to know about so that you can tell

00:32:30.220 --> 00:32:32.100
the table it needs to refresh itself.

00:32:32.140 --> 00:32:35.340
You can tell it to reload or note
that the number of rows in your cell,

00:32:35.380 --> 00:32:38.140
the table has changed.

00:32:38.270 --> 00:32:41.180
So let's talk about this object value.

00:32:43.820 --> 00:32:45.310
Remember,
there are a bunch of different set

00:32:45.400 --> 00:32:48.760
methods that NSLs had implemented:
setString, setFloat.

00:32:48.760 --> 00:32:53.700
Well, one that they all happen to
implement also is setObjectValue.

00:32:53.740 --> 00:32:58.430
So the object value that's returned
from this data source method is handed

00:32:58.510 --> 00:33:02.110
to a cell in the setObjectValue,
and the cell looks at it and says, "Oh,

00:33:02.120 --> 00:33:04.120
the object value I was handed
was this type of thing.

00:33:04.120 --> 00:33:07.180
I'll convert it into what I need to,
so I now know how to

00:33:07.180 --> 00:33:09.890
display." And a cell also,
of course,

00:33:09.900 --> 00:33:13.240
then needs to be able to report
what its object value is.

00:33:13.290 --> 00:33:16.570
So it has a setObjectValue and
a getObjectValue type method.

00:33:16.590 --> 00:33:22.860
An example usage of this would be,
say you had a text field in your table.

00:33:22.860 --> 00:33:27.920
Well, your data source could return the
string created by string with format,

00:33:28.000 --> 00:33:31.300
Homer, and it would set the object
value of that cell to Homer,

00:33:31.300 --> 00:33:35.060
which is then going to be displayed
at that column and row intersection.

00:33:36.380 --> 00:33:41.180
Okay, now say you also want to be able
to edit your cells in your table.

00:33:41.250 --> 00:33:43.450
There's another method you would
implement in your data source,

00:33:43.450 --> 00:33:46.500
which is similar to the
getStyle object value,

00:33:46.500 --> 00:33:48.680
except for this one
is a set object value.

00:33:48.930 --> 00:33:53.510
So when an object value changes,
you'll be sent the tableView set object

00:33:53.510 --> 00:33:55.920
value for table column row message.

00:33:56.210 --> 00:33:59.320
The object value you're set is
the new object value of the cell,

00:33:59.320 --> 00:34:02.180
and it's up to you to store
this in your data store,

00:34:02.230 --> 00:34:04.300
so that the next time it asks
you for the object value,

00:34:04.300 --> 00:34:06.160
you return that new object value.

00:34:06.280 --> 00:34:07.330
Okay.

00:34:07.340 --> 00:34:09.700
And finally,
there's all sorts of other data

00:34:09.700 --> 00:34:13.340
source and delegate methods that
you can implement for your table

00:34:13.340 --> 00:34:16.400
view that allow you to do things
like drag and drop and so forth.

00:34:16.460 --> 00:34:18.590
And I'll just refer you
to the documentation to

00:34:18.690 --> 00:34:20.860
find out more about those.

00:34:27.910 --> 00:34:36.690
TableView also provides lots of
delegation and notifications that

00:34:36.690 --> 00:34:38.160
allow you to customize its behavior,
such as you can know

00:34:38.160 --> 00:34:38.160
when a row was selected,

00:34:38.350 --> 00:34:41.330
You can know when the table
header column has been dragged

00:34:41.400 --> 00:34:42.980
from one position to another.

00:34:43.200 --> 00:34:46.190
There's lots of delegation notifications.

00:34:46.310 --> 00:34:48.200
Table view is highly customizable.

00:34:48.200 --> 00:34:51.190
And that's my whole point
in listing these up here.

00:34:51.210 --> 00:34:54.200
I'll just again refer you to the
documentation to find out those.

00:34:54.200 --> 00:34:57.140
Just know that table view
is highly customizable.

00:34:57.800 --> 00:35:02.400
NSOutlineView happens to be
a subclass of NSTableView,

00:35:02.400 --> 00:35:08.050
and it is a hierarchical version
that can display hierarchies of data.

00:35:08.460 --> 00:35:10.890
And its main difference comes
from the fact that it is able

00:35:11.150 --> 00:35:13.800
to display hierarchies of data.

00:35:13.910 --> 00:35:17.190
So it makes sense that
TableView deals in rows,

00:35:17.190 --> 00:35:20.980
but it doesn't necessarily make sense
that an OutlineView deals in rows,

00:35:20.990 --> 00:35:21.000
right?

00:35:21.130 --> 00:35:24.930
Because,
say you expand a particular row and

00:35:24.930 --> 00:35:27.030
display the children in that row,
now all of a sudden all the

00:35:27.030 --> 00:35:28.000
rows have shifted around.

00:35:28.000 --> 00:35:30.500
So OutlineView doesn't
like to deal in rows.

00:35:30.500 --> 00:35:34.490
Instead,
it deals in these things we call "items."

00:35:35.100 --> 00:35:40.110
and you'll see this in all
of the API for Outline View.

00:35:41.950 --> 00:35:46.600
So again, Outline View requires a data
source to supply it with data,

00:35:46.600 --> 00:35:50.250
and the difference here relates to
the fact that it displays a hierarchy

00:35:50.340 --> 00:35:52.930
of data and it deals in items.

00:35:53.110 --> 00:35:57.040
and so you need to be able
to tell it for a particular

00:35:57.290 --> 00:35:59.700
item how many children it has.

00:35:59.770 --> 00:36:04.900
If a particular item is expandable,
you need to be able to tell it

00:36:09.500 --> 00:36:12.510
You need to be able to tell it
what the particular object value

00:36:12.510 --> 00:36:15.110
of a child is and so forth.

00:36:15.110 --> 00:36:19.270
And one important note is that
the nil item refers to the

00:36:19.270 --> 00:36:21.910
root item of your outline view.

00:36:22.480 --> 00:36:24.060
So now I'm going to go
back to the demo machine,

00:36:24.060 --> 00:36:25.730
please.

00:36:25.820 --> 00:36:30.000
And we're going to see a little bit
how you can use the custom control

00:36:30.000 --> 00:36:39.740
that we just made in a table view.

00:36:44.400 --> 00:36:49.060
So I've gone ahead and,
ahead of time again,

00:36:49.130 --> 00:36:51.940
created a window with a table in it.

00:36:51.960 --> 00:36:53.800
It has a remove button and an add button.

00:36:53.980 --> 00:36:56.300
We're going to sort of
make a mini-planner.

00:36:56.330 --> 00:37:00.290
And the columns of this table

00:37:02.020 --> 00:37:04.370
I guess I forgot to
mention one of my slides.

00:37:04.660 --> 00:37:07.460
Columns are identified by
something called an identifier,

00:37:07.560 --> 00:37:09.940
so that's something that we
have to set in the attributes.

00:37:09.970 --> 00:37:12.490
We'll call this column "time."

00:37:12.860 --> 00:37:15.520
and we'll call this column "info."
So one will display the clock,

00:37:15.650 --> 00:37:17.270
the other one will have info.

00:37:17.600 --> 00:37:20.670
Now we need to wire some things up.

00:37:21.100 --> 00:37:23.840
We've created some new methods
in our application controller

00:37:23.840 --> 00:37:27.970
to add an appointment,
remove,

00:37:30.430 --> 00:37:35.540
and our controller needs
to know about the table.

00:37:35.560 --> 00:37:37.940
And finally, the data source.

00:37:38.030 --> 00:37:40.930
The table has to know who
it's getting its data from,

00:37:40.940 --> 00:37:42.900
so we'll set that up.

00:37:43.990 --> 00:37:49.270
So now we should have all our
pieces set up in Interface Builder.

00:37:49.870 --> 00:37:52.800
Look at the code that we've added.

00:37:52.870 --> 00:37:57.600
Remember, our application controller is
the data source for the table.

00:37:57.890 --> 00:38:00.840
So we must have added
some new methods to it.

00:38:00.880 --> 00:38:03.000
Well, first of all,
it looks like in our Wake From Nib,

00:38:03.080 --> 00:38:06.900
we've gone ahead and changed
the data cell of the time

00:38:07.090 --> 00:38:09.080
column to be a clock cell.

00:38:09.110 --> 00:38:16.270
And we've done some nifty stuff with
the data cell in the info column.

00:38:16.290 --> 00:38:19.490
And we've started out with
an initial appointment.

00:38:20.400 --> 00:38:24.170
Okay, and then we've implemented our
methods to add appointments,

00:38:24.290 --> 00:38:27.710
they update a datastore that we have,
remove an appointment that

00:38:27.710 --> 00:38:29.720
will also update our datastore.

00:38:29.910 --> 00:38:33.350
And finally, the interesting thing,
which is the

00:38:34.100 --> 00:38:50.100
[Transcript missing]

00:38:51.130 --> 00:38:57.670
We will access the record at the
index in our appointment datastore,

00:38:57.670 --> 00:39:00.870
and then we will simply
return the time of that.

00:39:00.960 --> 00:39:04.260
So the time will be handed off to the
clock cell that's about to display,

00:39:04.370 --> 00:39:06.300
and then the clock cell will know, "Oh,
this is my time.

00:39:06.410 --> 00:39:08.720
This is the time that I display."

00:39:09.450 --> 00:39:13.160
And since we want to allow editing,
we need to override the set

00:39:13.230 --> 00:39:15.630
object value data source method.

00:39:15.650 --> 00:39:21.800
So we receive a new object value,
and that object value is passed to,

00:39:21.860 --> 00:39:24.950
is used to set the time,
if we're in the time column,

00:39:24.950 --> 00:39:29.360
or set the information string if
we're in the information column.

00:39:30.030 --> 00:39:33.020
I did mention that we're
now using object values,

00:39:33.020 --> 00:39:36.450
so we must have to go back to
our clock cell and implement

00:39:37.250 --> 00:39:39.790
the set object value method.

00:39:40.720 --> 00:39:44.880
and I don't remember where it is,
so we'll do a quick scan.

00:39:44.890 --> 00:39:48.120
And there's our new set
object value method.

00:39:48.280 --> 00:39:52.340
What we'll do is look at the object value
and see if it's an NS Calendar date.

00:39:52.420 --> 00:39:54.470
Well,
we know how to handle that natively,

00:39:54.490 --> 00:39:58.380
so we'll just set the time
using that object that we got.

00:39:58.420 --> 00:40:00.820
If it happens to be a string, well,
we already know how to

00:40:00.820 --> 00:40:03.840
convert from strings to time,
so we'll use that.

00:40:03.900 --> 00:40:06.280
Otherwise,
we'll just raise an exception because

00:40:06.280 --> 00:40:08.050
we don't know how to handle it.

00:40:08.240 --> 00:40:10.980
So we go ahead, build and run.

00:40:13.800 --> 00:40:16.500
And our initial point
where we gave it is there.

00:40:16.520 --> 00:40:21.640
If we edit one of the table
columns and say something like,

00:40:21.640 --> 00:40:23.710
"Release the hounds,"

00:40:24.900 --> 00:40:47.200
[Transcript missing]

00:40:47.730 --> 00:40:49.480
Okay,
and that's all I wanted to show for that.

00:40:49.600 --> 00:40:52.700
We can add all sorts
of records if we want.

00:40:52.910 --> 00:40:55.370
Okay, can we back the slides, please?

00:41:01.900 --> 00:41:06.390
So now I'd like to move on to
accessibility considerations,

00:41:06.390 --> 00:41:10.390
including keyboard accessibility,
keyboard navigation,

00:41:10.390 --> 00:41:12.990
and Cocoa's new accessibility APIs.

00:41:13.970 --> 00:41:19.190
So the first thing in dealing with
keyboard accessibility and keyboard

00:41:19.200 --> 00:41:21.470
navigation is having a keyboard loop.

00:41:21.590 --> 00:41:25.390
So first we need to set up a keyboard
loop in our application's windows.

00:41:25.540 --> 00:41:29.200
We need to be able to display focus if
we're running our own custom control.

00:41:29.250 --> 00:41:31.670
We also need to be able to
tell the system we want focus,

00:41:31.670 --> 00:41:34.140
and once we have focus,
we should do something with it.

00:41:34.220 --> 00:41:36.780
So we need to handle keyboard events.

00:41:36.880 --> 00:41:40.080
To tell the system you want focus,
override the AcceptFirstResponder

00:41:40.090 --> 00:41:43.790
method and return "Yes" if you
want to be able to have focus.

00:41:44.240 --> 00:41:48.900
FirstResponder roughly equates
to being the focused control.

00:41:48.900 --> 00:41:52.390
And now that we've told the
system that we want focus,

00:41:52.390 --> 00:41:54.890
we need to tell it when and in
what situation we want focus.

00:41:54.940 --> 00:41:59.020
If we want to act more like a text
field and allow clicks to give us focus,

00:41:59.230 --> 00:42:02.160
then you should return "Yes"
from "NeedsPanel" to become key.

00:42:02.400 --> 00:42:04.460
If, however,
you only want to receive focus

00:42:04.570 --> 00:42:07.390
when someone tabs to you when
any control is accessible,

00:42:07.390 --> 00:42:09.400
then you should return "No" from this.

00:42:09.500 --> 00:42:11.410
So in general,
things like buttons don't get

00:42:11.530 --> 00:42:12.800
focus when you click on them.

00:42:12.970 --> 00:42:15.420
They shouldn't shift focus away from
a text field if you click on a button.

00:42:17.880 --> 00:42:19.720
Okay,
so we told the system we want focus.

00:42:19.800 --> 00:42:22.940
Now we have to know that we have focus.

00:42:23.110 --> 00:42:25.250
To know you have focus,
override the become

00:42:25.250 --> 00:42:26.800
first responder method.

00:42:26.810 --> 00:42:29.160
To know that you no longer have focus,
override the resign

00:42:29.160 --> 00:42:30.410
first responder method.

00:42:30.490 --> 00:42:34.810
And to check if you have focus,
we said that roughly being first

00:42:34.810 --> 00:42:36.610
responder means you have focus.

00:42:36.610 --> 00:42:38.980
Check with the window to
see who's first responder.

00:42:38.980 --> 00:42:40.800
If it's you, you have focus.

00:42:40.800 --> 00:42:43.870
Now when you draw focus,
you shouldn't draw focus only

00:42:43.870 --> 00:42:45.800
if you're the first responder.

00:42:45.800 --> 00:42:48.940
You should make sure that
you're also in the key window.

00:42:49.010 --> 00:42:52.040
Because if you're not in the key
window and you're drawing focus,

00:42:52.160 --> 00:42:56.190
we could have a situation where
two windows are showing focus.

00:42:57.530 --> 00:42:59.330
Okay,
now that we know we've gotten focused,

00:42:59.330 --> 00:43:02.440
we need to be able to tell
the system to redraw ourselves

00:43:02.690 --> 00:43:06.300
so that once we get focused,
we update our drawing.

00:43:06.420 --> 00:43:09.080
So if you override become
and resign first responder,

00:43:09.180 --> 00:43:12.420
you would do a set needs display
so that you redraw yourself.

00:43:12.570 --> 00:43:17.760
And similarly, you would want to find out
when the window you're in

00:43:17.970 --> 00:43:19.620
has changed its key state.

00:43:19.760 --> 00:43:23.300
And when the window changes key state,
you again need to redisplay yourself

00:43:23.300 --> 00:43:26.190
to either show or stop showing focus.

00:43:27.060 --> 00:43:32.600
and finally, if you're drawing focus
and you need to redisplay,

00:43:32.610 --> 00:43:36.580
you should use the new Set Keyboard
Focus Ring Needs Display Interact

00:43:36.770 --> 00:43:44.470
because keyboard focus rings can happen
to fall outside of your view's bounds,

00:43:44.470 --> 00:43:44.470
and this special method will
help take care of that situation.

00:43:45.140 --> 00:43:48.300
Okay, now that we have focus,
we need to do something with it.

00:43:48.370 --> 00:43:52.540
One way is to override key down
and handle the raw key events.

00:43:52.570 --> 00:43:57.710
Another way is to override one
of a series of standard methods

00:43:57.720 --> 00:44:01.670
that the Cocoa text input system
will automatically convert

00:44:01.910 --> 00:44:05.380
Keystrokes To and
Send To the focused control.

00:44:05.380 --> 00:44:11.220
For instance, when a right arrow is
pressed on the keyboard,

00:44:11.220 --> 00:44:16.320
the text input system will convert that
into a move right method and try and

00:44:16.320 --> 00:44:18.630
send it to the control that has focus.

00:44:18.680 --> 00:44:20.790
If it implements it,
well then it can do what

00:44:20.820 --> 00:44:22.200
it wants to and move right.

00:44:22.390 --> 00:44:26.880
And if it doesn't,
well then you'll eventually get a

00:44:26.880 --> 00:44:26.880
key down and you can handle it there.

00:44:29.450 --> 00:44:32.180
Okay, so now let's talk a little bit
about how you set up keyboard

00:44:32.200 --> 00:44:34.900
loops in your application window.

00:44:36.630 --> 00:44:40.400
Typically what you do is set the
initial first responder of your window,

00:44:40.400 --> 00:44:44.800
and then for each control in your window,
you would set the next key view

00:44:44.800 --> 00:44:48.000
outlet until you have the keyboard
loop you want in your window.

00:44:48.140 --> 00:44:51.290
Now if you find that this is tedious,
what you could do is just not set the

00:44:51.290 --> 00:44:55.740
initial first responder or do anything
at all and let Cocoa compute it for you.

00:44:55.830 --> 00:44:57.710
And it turns out,
if you're not adding and

00:44:57.710 --> 00:45:00.890
removing views all the time,
this is usually just what you want,

00:45:00.980 --> 00:45:02.880
so see if that works for you first.

00:45:02.960 --> 00:45:04.920
Now if you are adding and
removing views all the time,

00:45:05.000 --> 00:45:07.680
you'll need to make sure that
you maintain the keyboard loop,

00:45:07.680 --> 00:45:11.810
or you'll get in strange situations
where a view in the keyboard loop is not

00:45:11.810 --> 00:45:14.760
actually still in the view hierarchy.

00:45:18.270 --> 00:45:21.600
Okay, and finally,
I'd like to show a demo.

00:45:21.600 --> 00:45:23.990
Back to the demo machine, please.

00:45:24.120 --> 00:45:28.820
For this demo,
we will add a focus ring to our clock.

00:45:34.610 --> 00:45:37.840
I haven't shown anything yet.

00:45:37.840 --> 00:45:44.640
Okay, so we've added some code to our
controller to do the focus ring stuff.

00:45:50.180 --> 00:45:53.140
We've told it, yes,
we do indeed want to be first responder,

00:45:53.140 --> 00:45:55.020
and we'd prefer to act
more like a button.

00:45:55.020 --> 00:45:58.620
We want people to have to tab
to us to be able to get focus.

00:45:58.620 --> 00:46:01.780
We've overridden the view to
move to Windows so that we can

00:46:01.820 --> 00:46:05.450
figure out when the window we're
in has changed its key state.

00:46:06.640 --> 00:46:10.270
and we've overridden "become" and
"resign first responder" to know that

00:46:10.270 --> 00:46:19.070
we have gained first responder and
we re-display in those situations.

00:46:22.100 --> 00:46:34.700
[Transcript missing]

00:46:34.900 --> 00:46:56.700
[Transcript missing]

00:46:57.350 --> 00:47:00.200
We've added it to the cell.

00:47:00.700 --> 00:47:03.520
So when the cell receives a move right,
it will increment the time.

00:47:03.520 --> 00:47:05.640
When it receives a move left,
it will decrement,

00:47:05.790 --> 00:47:09.800
and various things for other
types of standard messages.

00:47:10.270 --> 00:47:13.640
So let's run, and I'll just demonstrate
what it's capable of.

00:47:13.840 --> 00:47:18.900
So I tab and I notice I can't get there,
so I forgot to do one thing.

00:47:18.960 --> 00:47:22.190
I have to bring up System Preferences
and tell it that I want to be

00:47:22.190 --> 00:47:23.900
able to access any control.

00:47:23.960 --> 00:47:27.400
Because I returned "no" from that
"needs panel to become key" method,

00:47:27.470 --> 00:47:31.160
that means I can only get
focus there until I tab to it.

00:47:31.410 --> 00:47:32.800
So I've tabbed to it now.

00:47:32.870 --> 00:47:35.730
I can use the keyboard
to change the time.

00:47:35.900 --> 00:47:51.500
[Transcript missing]

00:47:52.400 --> 00:47:54.300
and all I'm doing is using the keyboard.

00:47:54.460 --> 00:47:55.350
Okay.

00:47:55.570 --> 00:47:57.930
Can we go back to the slides, please?

00:48:00.840 --> 00:48:05.100
Okay, now I would like to invite up on
stage the guy that will be keeping

00:48:05.100 --> 00:48:07.640
you from getting to the beer bash.

00:48:07.690 --> 00:48:11.070
And I hope I've left him with
enough time so that he can get done

00:48:11.070 --> 00:48:12.880
and we have time for questions.

00:48:12.920 --> 00:48:14.490
Mike Engber.

00:48:20.210 --> 00:48:23.440
My name is Mike Engber,
and for the next 20 minutes or so,

00:48:23.440 --> 00:48:26.290
or until you get too anxious
to get to the beer bash,

00:48:26.400 --> 00:48:30.670
I'm going to talk to you about the
new accessibility APIs and what they

00:48:30.790 --> 00:48:33.310
mean to you as Cocoa developers.

00:48:34.560 --> 00:48:38.970
So in Jaguar, we've introduced some
new accessibility APIs.

00:48:38.970 --> 00:48:43.070
And basically what these APIs let
assistive apps do is look at the

00:48:43.160 --> 00:48:46.460
user interface of other applications.

00:48:46.640 --> 00:48:50.770
For instance, a screen reader could use
these APIs to discover the

00:48:50.770 --> 00:48:55.950
windows in another application,
and then find in the window a button,

00:48:56.070 --> 00:48:59.800
discover what text the button displays,
present that to the user,

00:48:59.840 --> 00:49:02.270
and then finally press that button.

00:49:03.700 --> 00:49:18.000
[Transcript missing]

00:49:19.450 --> 00:49:20.830
In this session,
we're going to talk about

00:49:20.900 --> 00:49:24.470
the other side of those APIs,
what the target application has to do

00:49:24.750 --> 00:49:27.200
in order to present its user interface.

00:49:27.330 --> 00:49:28.930
And specifically,
we're going to talk about what

00:49:28.960 --> 00:49:31.300
Cocoa applications have to do.

00:49:32.600 --> 00:49:37.980
To help motivate you to take the
trouble to make your apps accessible,

00:49:38.040 --> 00:49:41.820
Kevin Aiitken from the Speech Group is
going to show what they can do

00:49:41.820 --> 00:49:44.200
with an app that is accessible.

00:49:57.200 --> 00:50:00.090
We need to go to demo machine number one.

00:50:00.300 --> 00:50:01.180
Oh right, we're there.

00:50:01.360 --> 00:50:02.590
Okay.

00:50:02.600 --> 00:50:06.700
So the speech group's been working on
a number of new features for Jaguar.

00:50:06.700 --> 00:50:09.900
Two of them are using the new
accessibility API and I want to go

00:50:09.910 --> 00:50:13.810
through those real quick and I also
want to touch on as a developer who's

00:50:13.810 --> 00:50:18.580
creating a custom control in Cocoa,
I want you to think about these

00:50:18.580 --> 00:50:23.760
new built-in speech features and
make sure that your custom control

00:50:23.760 --> 00:50:27.240
works well with those and I'll
just touch on those real quick.

00:50:27.290 --> 00:50:30.280
So let me go to the
speech preference panel.

00:50:31.500 --> 00:50:37.380
And first what I'll do is I will turn on
new feature in our text to speech system.

00:50:37.510 --> 00:50:38.980
Speaker 2: Speak text under the mouse.

00:50:38.980 --> 00:50:42.950
That speaks to text under the
mouse as I move around the screen.

00:50:43.060 --> 00:50:44.740
Speaker 2: Speech recognition.

00:50:44.740 --> 00:50:51.660
I'm using accessibility API to ask it
first what is underneath the mouse.

00:50:51.660 --> 00:50:56.080
It gives me an object and then
from that object I get its title.

00:50:56.420 --> 00:51:00.140
Well, that works really well for
all these standard controls.

00:51:00.140 --> 00:51:05.740
But because I know that which
ones I want to get the title from,

00:51:05.790 --> 00:51:07.700
which ones I want to get the value.

00:51:07.700 --> 00:51:10.900
But for custom control I'm not
quite sure what I should get.

00:51:10.900 --> 00:51:11.900
Speaker 2: Cloud control.

00:51:12.050 --> 00:51:17.120
Speaker 3: And so in here we have
some standard controls.

00:51:17.120 --> 00:51:20.070
Should be speaking.

00:51:21.150 --> 00:51:27.360
"And..." "There we go." "Page..." "But
for a custom control like the clock,

00:51:27.450 --> 00:51:29.700
we're not sure what we
should be asking for.

00:51:29.700 --> 00:51:30.930
Should we be asking for the title?

00:51:30.930 --> 00:51:32.740
Should we be asking for the value?

00:51:32.810 --> 00:51:38.160
So what we're suggesting is that you add
an additional attribute that Mike will

00:51:38.160 --> 00:51:41.300
talk about here in a little bit,
about attributes.

00:51:41.330 --> 00:51:44.980
But we would like you to add an
attribute called 'Apple Synthesis'

00:51:44.980 --> 00:51:48.960
and that way we can look for that
specific attribute and then speak it.

00:51:49.050 --> 00:51:53.090
So in this case, we've implemented that
attribute." "At the tone,

00:51:53.280 --> 00:51:55.340
the time will be 3:12 PM.

00:51:55.680 --> 00:52:02.250
Beep." "So we've done something a bit."

00:52:04.900 --> 00:52:08.170
humorist there,
but that points out that you'll be

00:52:08.170 --> 00:52:14.030
able to fine tune exactly what you
want our built in text to speech system

00:52:14.040 --> 00:52:18.020
to say when the user mouses over that.

00:52:18.020 --> 00:52:22.280
So, likewise,
really quickly show speech recognition.

00:52:22.280 --> 00:52:25.350
And let me turn off the screen reader.

00:52:25.350 --> 00:52:27.980
So speech recognition has the same issue.

00:52:27.980 --> 00:52:31.940
What we do is we use the accessibility
API to go through the front window

00:52:31.940 --> 00:52:35.460
and create a command for each
one of the items in there as

00:52:35.520 --> 00:52:37.110
well as items in the menu bar.

00:52:37.110 --> 00:52:43.060
But again, we have the same problem
for a custom control.

00:52:43.060 --> 00:52:46.320
So you'll see a bit
later that this clock,

00:52:46.320 --> 00:52:51.680
well, actually saw in Chuck's demo that
you can increment and decrement.

00:52:51.680 --> 00:52:56.650
So something we'll be documenting is
how you can provide the spoken command

00:52:56.650 --> 00:53:00.800
and map that to the actions that you
support for the speech recognition.

00:53:00.800 --> 00:53:00.800
So that's a little bit of a demo.

00:53:00.800 --> 00:53:00.800
So, I'm going to go ahead and
show you how to do that.

00:53:00.800 --> 00:53:01.850
So, I'm going to go ahead and show
you how to do that custom control.

00:53:01.850 --> 00:53:04.490
So, with that,
I'll turn it back over to Mike.

00:53:04.500 --> 00:53:04.980
Okay.

00:53:04.980 --> 00:53:06.040
Can we get the slides back?

00:53:13.550 --> 00:53:16.540
Okay,
so first I'll give you some good news.

00:53:16.680 --> 00:53:19.250
All the standard user interface
elements that you use in

00:53:19.250 --> 00:53:20.670
Cocoa are already accessible.

00:53:20.980 --> 00:53:25.590
So if you use those,
there's not much you need to do.

00:53:25.700 --> 00:54:00.000
[Transcript missing]

00:54:02.470 --> 00:54:04.210
Before we can get into the
details of the protocol,

00:54:04.250 --> 00:54:07.120
there's a couple fundamental
concepts I want to explain to

00:54:07.120 --> 00:54:09.650
you about the accessibility APIs.

00:54:09.950 --> 00:54:13.670
One of the big issues that has
to be solved is how does a target

00:54:13.700 --> 00:54:17.280
app represent its user interface
to the assistive application?

00:54:17.410 --> 00:54:22.190
And this diagram shows an assistive
application trying to query what's

00:54:22.190 --> 00:54:23.960
in a Cocoa app and a Carbon app.

00:54:24.050 --> 00:54:27.620
And the question marks indicate that
it's not really clear how they should

00:54:27.660 --> 00:54:30.810
communicate their user interfaces back.

00:54:31.120 --> 00:54:39.010
Each of these applications has a natural
representation of its user interface

00:54:39.010 --> 00:54:47.060
in terms of its own native types.

00:54:47.060 --> 00:54:47.060
The Cocoa app has
NSWindows and NSControls,

00:54:47.060 --> 00:54:47.060
and the Carbon app has
WindowRefs and ControlRefs.

00:54:47.300 --> 00:54:50.110
There are some problems trying to
use these natural representations.

00:54:50.240 --> 00:54:52.850
For one thing, it means the assistive app
gets to do twice as much work.

00:54:52.930 --> 00:54:56.340
It has to understand all the
native widgetry of Cocoa and

00:54:56.340 --> 00:54:58.620
the native widgetry of Carbon.

00:54:58.620 --> 00:55:02.280
Another problem is there is a lot of
excess of detail that would be exposed.

00:55:02.280 --> 00:55:05.560
If you consider a simple example
of just a button in a window,

00:55:05.680 --> 00:55:09.410
in a Cocoa app that's really a
button cell inside a button control,

00:55:09.480 --> 00:55:13.230
inside the content view of the window,
inside another view,

00:55:13.540 --> 00:55:15.050
and finally you get to the window.

00:55:15.210 --> 00:55:17.680
The assistive app really only
wants to know there's a window

00:55:17.900 --> 00:55:21.790
and there's a button in it,
and it doesn't care about the rest.

00:55:23.720 --> 00:55:28.230
So this slide is basically the same
diagram with some boxes showing the

00:55:28.230 --> 00:55:30.900
new code that was added in Jaguar.

00:55:30.960 --> 00:55:34.340
The box in front of the assistive
app are the accessibility APIs.

00:55:34.450 --> 00:55:38.150
The box in front of the Cocoa app
is the accessibility protocol.

00:55:38.400 --> 00:55:42.590
And you'll notice that the question
mark has been replaced with the

00:55:42.590 --> 00:55:46.950
word "UI element." A UI element is
short for user interface element,

00:55:47.050 --> 00:55:50.280
and that's basically our solution
to the representation problem.

00:55:50.500 --> 00:55:52.460
Everything is a user interface element.

00:55:52.460 --> 00:55:54.280
A button is a user interface element.

00:55:54.320 --> 00:55:55.970
A menu is a user interface element.

00:55:56.070 --> 00:55:58.240
A window is a user interface element.

00:55:58.370 --> 00:56:02.390
And there's even a special user
interface element to represent

00:56:02.390 --> 00:56:04.490
the top-level application.

00:56:07.920 --> 00:56:13.940
So basically,
applications are represented as a

00:56:13.940 --> 00:56:13.940
hierarchy of user interface elements.

00:56:14.560 --> 00:56:17.900
User interface elements
have attributes and actions.

00:56:17.950 --> 00:56:20.880
Attributes are how you get information
about a user interface element.

00:56:21.070 --> 00:56:24.410
For instance, its title, or its value,
or its children,

00:56:24.570 --> 00:56:28.490
which would be the basis for
traversing the whole hierarchy.

00:56:28.570 --> 00:56:29.800
They also could support actions.

00:56:29.850 --> 00:56:32.500
A button user interface
element would support press.

00:56:32.570 --> 00:56:35.870
A slider might support
increment and decrement.

00:56:42.260 --> 00:56:46.040
So the magic that makes this work
is the accessibility protocol.

00:56:46.040 --> 00:56:49.730
And it's a protocol on NSObject
because there's a wide variety of

00:56:49.810 --> 00:56:53.070
different objects in Cocoa that
can act as user interface elements.

00:56:53.290 --> 00:56:57.140
For instance, windows, controls, views,
and cells.

00:56:57.170 --> 00:56:59.280
And really,
the only common ancestor in their

00:56:59.380 --> 00:57:02.320
inheritance hierarchy is NSObject.

00:57:06.230 --> 00:57:09.920
So the first part of the
protocol deals with methods.

00:57:10.010 --> 00:57:15.530
And so there's a method for returning a
list of all the attributes you support.

00:57:15.750 --> 00:57:19.500
There's a method for returning the
value of a particular attribute.

00:57:19.540 --> 00:57:23.500
There's a method for testing if a
particular attribute can be set.

00:57:23.530 --> 00:57:26.890
And finally,
there's a method for setting its value.

00:57:30.090 --> 00:57:34.570
You're probably most likely
to override the method for

00:57:34.570 --> 00:57:36.310
returning an attribute's value.

00:57:36.380 --> 00:57:40.090
If you consider override,
you're interested in returning a custom

00:57:40.220 --> 00:57:44.860
value for the title of some UI element,
you would override the accessibility

00:57:44.980 --> 00:57:46.440
attribute value method.

00:57:46.500 --> 00:57:49.370
And the first thing you would do is
test if the name of the attribute

00:57:49.970 --> 00:57:51.710
that's being asked about is the title.

00:57:51.890 --> 00:57:54.310
If it is, you can return whatever
you want for the title.

00:57:54.410 --> 00:57:58.990
If it's not, you call super so that other
attributes will be handled for you

00:57:59.290 --> 00:58:02.500
from the inheritance hierarchy.

00:58:02.500 --> 00:58:04.410
One thing I'd like to point
out is that you should avoid

00:58:04.410 --> 00:58:06.050
inventing new kinds of attributes.

00:58:06.300 --> 00:58:09.020
Assistive apps aren't going
to be expecting them and they

00:58:09.360 --> 00:58:11.940
may completely ignore them.

00:58:11.940 --> 00:58:16.560
So when I accessorize the clock,
instead of creating a time attribute,

00:58:16.570 --> 00:58:20.050
I just use the value attribute
and return the time as a string.

00:58:25.840 --> 00:58:28.780
The second suite of methods in
the protocol deal with actions,

00:58:28.870 --> 00:58:33.790
and there's a method to return the
names of all the actions you support.

00:58:33.980 --> 00:58:41.820
and the rest of the team will
be joined in the next session.

00:58:45.810 --> 00:58:48.400
You're less likely to
override the action methods.

00:58:48.520 --> 00:58:51.350
If you create a kind of button,
the odds are that you want it

00:58:51.350 --> 00:58:54.200
to support the press action,
which you're going to inherit for free,

00:58:54.360 --> 00:58:57.840
and what you'd like it to do
when it's pressed is invoke

00:58:57.840 --> 00:58:59.750
the action on its target.

00:58:59.890 --> 00:59:02.520
You should think of actions
as very simple things,

00:59:02.590 --> 00:59:04.860
basically what you could accomplish
with a single click of the mouse,

00:59:05.070 --> 00:59:09.440
pressing a button, picking a menu item,
things like that.

00:59:10.410 --> 00:59:13.440
and some other things you should keep
in mind is that attributes aren't

00:59:13.550 --> 00:59:17.400
the only way that an assistive app
can interact with your application.

00:59:17.400 --> 00:59:20.400
So you might say,
"How am I going to implement an action

00:59:20.400 --> 00:59:24.770
that selects text because actions
don't get any parameters?" Well,

00:59:24.770 --> 00:59:27.030
the way that's done is
there's an attribute,

00:59:27.120 --> 00:59:30.000
the selected text range,
and if the assistive app wants to change

00:59:30.000 --> 00:59:33.750
the range of text that's selected,
they just set the value of the attribute.

00:59:37.510 --> 00:59:40.980
So now that we know some of the
basic concepts of the accessibility,

00:59:41.040 --> 00:59:44.200
we're going to bring Kevin back,
and he's going to demonstrate a tool

00:59:44.820 --> 00:59:52.110
that explores how some Cocoa apps are
exposed to the accessibility APIs.

00:59:53.310 --> 00:59:55.200
Great, thanks Mike.

00:59:55.200 --> 00:59:59.110
Let me turn speech recognition
off just so we can have some

00:59:59.120 --> 01:00:00.900
more screen real estate here.

01:00:01.000 --> 01:00:03.510
So what I'm going to do is start
up an application that we wrote

01:00:03.510 --> 01:00:05.350
called UI Element Inspector.

01:00:05.370 --> 01:00:09.320
Let me move it here and
make the font larger.

01:00:12.400 --> 01:00:31.800
[Transcript missing]

01:00:32.640 --> 01:00:36.160
Let's go through the things in here.

01:00:36.180 --> 01:00:39.180
As you see right here,
it says "analog clock." That is

01:00:39.180 --> 01:00:43.920
basically the type of object
that we're getting back for.

01:00:43.950 --> 01:00:48.180
It's inside a window with the
name "window," and it's inside an

01:00:48.180 --> 01:00:52.510
application named "clock control."
As Mike talked about the attributes,

01:00:52.510 --> 01:00:56.520
it lists out all the attributes:
the role, role description,

01:00:56.520 --> 01:00:59.250
some state information,
whether it's enabled, focused,

01:00:59.380 --> 01:01:04.700
some references to its parent,
its window, its size, its position,

01:01:04.700 --> 01:01:05.850
its value.

01:01:05.870 --> 01:01:08.280
You can see here's the
string that's returned.

01:01:08.570 --> 01:01:14.690
And then here is this extra attribute
that we used in the speech synthesis,

01:01:14.720 --> 01:01:22.440
giving what we call an embedded command
string that produces that text-to-speech

01:01:22.440 --> 01:01:24.440
that we heard when we moused over it.

01:01:24.440 --> 01:01:27.020
And then if we scroll
down here a little bit,

01:01:27.070 --> 01:01:30.160
we'll see the actions,
and it supports an increment

01:01:30.160 --> 01:01:32.260
action and a decrement action.

01:01:32.280 --> 01:01:32.280
So let's play with it just a little bit.

01:01:32.300 --> 01:01:35.480
And send it an increment action.

01:01:35.480 --> 01:01:37.480
As we do that through
the accessibility API,

01:01:37.480 --> 01:01:43.190
you'll see the increments,
and we can change and send it an action,

01:01:43.240 --> 01:01:45.360
or a decrement action.

01:01:46.010 --> 01:01:49.400
And then we can also change attributes.

01:01:49.400 --> 01:01:53.070
So the ones with a W say
that we can write to them.

01:01:53.080 --> 01:01:55.380
So we can do something like this.

01:01:55.380 --> 01:01:58.780
We can set one to be true.

01:01:58.780 --> 01:02:02.640
As we click set value,
it will miniaturize the window

01:02:02.640 --> 01:02:05.260
and set it back to zero.

01:02:05.260 --> 01:02:07.110
And it will bring it back.

01:02:07.120 --> 01:02:09.660
So anyway, that's a quick demo of that.

01:02:09.700 --> 01:02:14.210
Our speech session is tomorrow
afternoon in the same room.

01:02:14.440 --> 01:02:17.120
So if you'd like to attend that,
we'd love to have you there.

01:02:17.120 --> 01:02:18.090
So thanks a lot.

01:02:22.000 --> 01:02:53.600
[Transcript missing]

01:02:56.160 --> 01:02:59.870
There's a method called
"accessibilityIsIgnored" in the protocol,

01:02:59.980 --> 01:03:04.180
and if you return "yes" from that,
then that means you're

01:03:04.450 --> 01:03:06.240
supposed to be ignored.

01:03:06.370 --> 01:03:10.040
So when the button returns its parent,
if the parent's ignored,

01:03:10.040 --> 01:03:12.160
it should return its parent, and so on.

01:03:12.370 --> 01:03:14.460
Similarly,
when you ask the window for its children,

01:03:14.600 --> 01:03:17.800
if the content view is ignored,
we then go to the

01:03:17.800 --> 01:03:19.740
content view's children.

01:03:20.460 --> 01:03:23.550
To keep you from having to
write this code to walk these

01:03:23.550 --> 01:03:27.390
hierarchies up and down,
we have a few convenience routines.

01:03:27.400 --> 01:03:29.970
If you're returning
your parent attribute,

01:03:30.110 --> 01:03:33.440
you can use the accessibility
unignored ancestor routine,

01:03:33.560 --> 01:03:36.380
and there's another routine if
you're returning your children,

01:03:36.380 --> 01:03:40.300
and there's a couple other related
routines for similar needs.

01:03:44.160 --> 01:03:49.210
Another thing that the
Accessibility APIs allow

01:03:49.320 --> 01:03:52.800
is to determine what user interface
element is under the mouse,

01:03:52.860 --> 01:03:56.340
and we saw Kevin making
extensive use of that.

01:03:56.460 --> 01:03:59.280
And there's also a similar
facility for finding out what user

01:03:59.420 --> 01:04:02.310
interface element has the focus.

01:04:02.540 --> 01:04:04.800
So how is this going to be accomplished?

01:04:04.920 --> 01:04:08.450
You can imagine, in a Cocoa app,
the first thing we would do is find

01:04:08.450 --> 01:04:12.220
out what window the mouse is in,
and then we could use View's hit test

01:04:12.220 --> 01:04:14.890
method to find out which view was hit.

01:04:15.010 --> 01:04:17.340
But that's about all Cocoa could do.

01:04:17.390 --> 01:04:19.240
And similarly,
if we want to find the focus,

01:04:19.240 --> 01:04:21.890
we can find out what the key window is,
and then we can discover

01:04:21.970 --> 01:04:23.040
the first responder.

01:04:23.200 --> 01:04:25.790
But that's about all
that we can do for you.

01:04:25.900 --> 01:04:29.540
If you happen to have substructure,
like a matrix has cells within it,

01:04:29.660 --> 01:04:32.700
and you want to make it appear that
one of the cells has the focus,

01:04:32.840 --> 01:04:35.300
that's really up to the matrix to do it.

01:04:35.420 --> 01:04:39.000
If we were trying to accessorize the
analog clock a little differently,

01:04:39.000 --> 01:04:41.740
if we wanted the hands to
show up and be hit testable,

01:04:41.870 --> 01:04:44.300
we would have to do that work.

01:04:45.910 --> 01:04:50.200
So basically, if you have substructure
that you want to expose,

01:04:50.210 --> 01:04:53.290
these methods that I'm going
to show you here are what

01:04:53.290 --> 01:04:55.140
you're going to need to use.

01:04:55.250 --> 01:04:57.770
So there's one for hit testing
and one for focus testing.

01:04:57.920 --> 01:05:01.340
And when these methods are called,
it means it's already been determined

01:05:01.340 --> 01:05:04.840
that you have the keyboard focus or
that the mouse is within your bounds.

01:05:04.950 --> 01:05:10.290
And that's your chance to decide if some
subpart of you has it and return that,

01:05:10.300 --> 01:05:13.800
or failing that,
you can just return yourself.

01:05:17.660 --> 01:05:22.320
The last part of the accessibility
APIs has to do with notifications.

01:05:22.490 --> 01:05:26.440
So assistive apps want to find out about
changes in their target application.

01:05:26.530 --> 01:05:28.510
They want to find out
when the application gets

01:05:28.590 --> 01:05:30.580
activated or deactivated.

01:05:30.740 --> 01:05:33.160
And then there's window events,
if a window is miniaturized

01:05:33.260 --> 01:05:36.460
or deminiaturized,
if the focus changes,

01:05:36.510 --> 01:05:38.260
or when UI elements get destroyed.

01:05:38.370 --> 01:05:40.420
So there's a whole
variety of notifications,

01:05:40.420 --> 01:05:44.090
and most of them are
handled by Cocoa for you.

01:05:44.340 --> 01:05:47.190
If you need to post a notification,
the most likely one that you

01:05:47.360 --> 01:05:49.340
would need to do is value change.

01:05:49.350 --> 01:05:52.220
So the clock would be a prime example.

01:05:52.220 --> 01:05:54.090
When we change its value,
we'd want to post a value

01:05:54.090 --> 01:05:55.180
change notification.

01:05:55.390 --> 01:06:00.140
And the call you make is an
S-accessibility post notification.

01:06:00.290 --> 01:06:02.210
That's fairly straightforward.

01:06:06.320 --> 01:06:10.090
So there's one special attribute
I haven't talked about that much,

01:06:10.170 --> 01:06:11.880
and that's the role attribute.

01:06:11.940 --> 01:06:15.590
This attribute identifies
what kind of user interface

01:06:15.680 --> 01:06:16.980
element you're dealing with.

01:06:17.070 --> 01:06:19.590
For instance,
there's like a role for buttons,

01:06:19.730 --> 01:06:22.900
check boxes have a role,
menus have a role.

01:06:23.980 --> 01:06:27.850
A role should indicate that anything
of that role should have the same

01:06:27.970 --> 01:06:30.600
set of actions and attributes,
and assistive apps are going to

01:06:30.600 --> 01:06:32.400
generally rely on that information.

01:06:32.500 --> 01:06:34.160
So you should avoid inventing new roles.

01:06:34.420 --> 01:06:37.590
Assistive apps won't be
prepared to deal with it.

01:06:37.930 --> 01:06:42.050
Now, one pitfall you want to avoid
is the temptation to invent

01:06:42.050 --> 01:06:44.950
a rule just to provide some
instance-specific information.

01:06:44.950 --> 01:06:47.740
For instance, you've got a print button
in your application,

01:06:47.740 --> 01:06:50.020
and you might ask yourself, "Well,
how is this assistive app going to

01:06:50.020 --> 01:06:53.890
know that this is a print button?"
The answer is it's not going to know.

01:06:54.020 --> 01:06:57.670
The assistive app is only designed to
help the user use your application.

01:06:57.670 --> 01:06:59.720
It's going to know
there's a button there,

01:06:59.720 --> 01:07:01.770
it's going to know
there's a press action,

01:07:01.770 --> 01:07:05.160
and it can tell the user that
the title of the button is print.

01:07:05.160 --> 01:07:07.200
And that's where it stops.

01:07:07.200 --> 01:07:10.030
If the user can understand
that and if they want to print,

01:07:10.030 --> 01:07:14.370
they can tell the assistive app,
"Go ahead and perform the button action."

01:07:17.080 --> 01:07:21.830
So in summary,
using Cocoa is going to give you a

01:07:21.830 --> 01:07:23.910
leg up on making your app accessible.

01:07:24.020 --> 01:07:27.660
So I would say most Cocoa apps
already work to a large

01:07:27.660 --> 01:07:29.990
extent with accessibility.

01:07:30.110 --> 01:07:33.420
Your custom UI elements,
as long as you remain in the same

01:07:33.540 --> 01:07:37.000
spirit of what you're inheriting from,
they're probably going to work too.

01:07:37.000 --> 01:07:39.640
But if you create
something totally novel,

01:07:39.930 --> 01:07:43.410
like a clock widget,
then you need to read up on

01:07:43.410 --> 01:07:48.670
the accessibility protocol
and implement a few methods.
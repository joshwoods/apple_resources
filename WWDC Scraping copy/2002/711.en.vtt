WEBVTT

00:00:01.300 --> 00:00:03.890
So our next session is
Advanced Data Modeling,

00:00:03.890 --> 00:00:06.680
and I'd like to introduce
Matt Firlik and Justin Henzie,

00:00:06.680 --> 00:00:09.510
who are presenting the
next session for you.

00:00:27.700 --> 00:00:27.880
Anyone know how to work this?

00:00:27.880 --> 00:00:28.040
Okay, good afternoon.

00:00:28.040 --> 00:00:28.510
My name is Justin Henzie,
and on stage with me is Matthew Firlik.

00:00:28.630 --> 00:00:32.200
Today we're going to be talking to
you about advanced data modeling

00:00:32.200 --> 00:00:36.120
with EOModeler and connectivity.

00:00:36.750 --> 00:00:39.370
Matthew and I both work in
the PowerSchool division

00:00:39.370 --> 00:00:41.210
of Apple using WebObjects.

00:00:41.240 --> 00:00:46.340
So today we're going to break
this session into two parts,

00:00:46.390 --> 00:00:48.000
which unfortunately for me are not equal.

00:00:48.000 --> 00:00:54.000
The first part will be using EOModeler
to map relational data structures,

00:00:54.000 --> 00:00:57.800
the concrete example
of which is database,

00:00:58.140 --> 00:00:59.300
into objects.

00:00:59.300 --> 00:01:01.560
The second part,
which will be handled by Matthew,

00:01:01.560 --> 00:01:06.180
is dealing with connectivity
with the JDBC and JNDI adapters.

00:01:09.250 --> 00:01:14.160
Okay, so before we go any further,
we'll just do a brief resume of EOF.

00:01:14.350 --> 00:01:18.880
The slide that's on screen at the
moment handily condenses every lecture

00:01:18.880 --> 00:01:23.070
you've been to so far into something
you can absorb in two or three seconds.

00:01:23.080 --> 00:01:25.530
And fortunately for the
tone deaf among you,

00:01:25.530 --> 00:01:27.970
it doesn't require a song,
and for those with

00:01:28.260 --> 00:01:30.650
delicate sensibilities,
it does not require me

00:01:30.750 --> 00:01:32.220
to remove any clothing.

00:01:36.340 --> 00:01:37.140
I'll pay you later.

00:01:37.140 --> 00:01:37.980
Thank you for that laugh.

00:01:37.980 --> 00:01:42.850
Okay, so what we're trying to display
in this screen at the top,

00:01:42.970 --> 00:01:45.360
you can see a blue cylinder
which represents the database.

00:01:45.360 --> 00:01:49.850
And we're trying to encapsulate
that the EOModel helps us take that

00:01:49.930 --> 00:01:54.770
database representation of the data,
convert it first into dictionaries,

00:01:54.820 --> 00:01:58.840
and then into Java objects which your
developers will be familiar with.

00:01:59.420 --> 00:02:03.600
And what we're trying to convey is
that the whole purpose of EOF is to

00:02:03.770 --> 00:02:08.150
abstract the database away from your
developers so they don't have to deal

00:02:08.150 --> 00:02:10.170
with the nuances of particular databases.

00:02:12.830 --> 00:02:16.460
Okay, so what exactly is an EOModel?

00:02:16.560 --> 00:02:19.090
On the screen to your right,

00:02:21.080 --> 00:02:23.410
is an example of a very simple model.

00:02:23.410 --> 00:02:25.680
And I should explain that
throughout this talk,

00:02:25.770 --> 00:02:29.990
we are going to be talking about
the features of EOModeler and

00:02:29.990 --> 00:02:32.520
how to achieve certain functions,
and at the same time

00:02:32.520 --> 00:02:34.640
demonstrating those features.

00:02:34.770 --> 00:02:37.100
So if you can't see the
screen to your right,

00:02:37.210 --> 00:02:41.320
then it would probably be advantageous to
move to the center where you can see it.

00:02:41.470 --> 00:02:43.450
But they're pretty big screens.

00:02:43.550 --> 00:02:50.950
Okay, so a model basically maps a
database into Java objects.

00:02:51.070 --> 00:02:58.000
And a model consists of entities which
map individual tables into an object.

00:02:58.100 --> 00:03:03.770
And an entity has a name,
it maps to a table,

00:03:03.810 --> 00:03:07.170
and it has a class name.

00:03:07.580 --> 00:03:11.170
Now the default class
name is EOGenericRecord,

00:03:11.240 --> 00:03:12.800
and this is provided for you.

00:03:13.110 --> 00:03:17.200
And this basically just provides
accesses and mutators to the

00:03:17.350 --> 00:03:19.270
attributes of that entity.

00:03:19.400 --> 00:03:22.920
If you want to provide business
logic around accessing and

00:03:22.920 --> 00:03:27.650
mutating those attributes,
then you can provide your own

00:03:27.650 --> 00:03:31.780
subclass or hierarchy of subclasses.

00:03:32.080 --> 00:03:34.740
where you can implement
that business logic.

00:03:34.740 --> 00:03:38.450
Also in the model is a connection
dictionary which dictates the

00:03:38.450 --> 00:03:43.510
type and location of the database
against which you're modeling.

00:03:43.800 --> 00:03:47.050
This is a very useful piece of
functionality because it actually

00:03:47.100 --> 00:03:52.580
allows you to browse the data in the
database as represented by your model.

00:03:52.580 --> 00:03:57.550
So it's a very useful tool to check
whether your modeling is correct,

00:03:57.730 --> 00:04:00.410
whether you've actually got
the table column names right,

00:04:00.430 --> 00:04:00.750
etc.

00:04:00.830 --> 00:04:04.250
And the other high-level
artifact that you'll find in

00:04:04.280 --> 00:04:06.600
the model is stored procedures.

00:04:07.480 --> 00:04:10.440
Basically, there are some things that
you're going to do which,

00:04:10.440 --> 00:04:12.540
for efficiency's sake,
you might implement

00:04:12.540 --> 00:04:13.670
as a stored procedure.

00:04:13.680 --> 00:04:18.100
And what we're trying to achieve is
allowing you to expose those stored

00:04:18.100 --> 00:04:22.900
procedures to your developers through
the model so that they basically

00:04:22.980 --> 00:04:27.560
have one place where they can find
all of these things they're used

00:04:27.910 --> 00:04:30.520
to doing with either JDBC or ODBC.

00:04:32.570 --> 00:04:32.820
Okay.

00:04:32.820 --> 00:04:36.510
So, what then is an EO entity?

00:04:36.710 --> 00:04:39.480
Well, an EO entity basically,
as we've already said,

00:04:39.740 --> 00:04:42.750
maps a table to a class.

00:04:42.750 --> 00:04:46.540
And just as with a class,
there are certain characteristics

00:04:46.540 --> 00:04:49.000
that you can specify for an entity.

00:04:49.310 --> 00:04:53.020
So, for instance,
you can declare an entity as abstract.

00:04:53.130 --> 00:04:56.950
And as for a Java class,
that simply specifies that this entity

00:04:56.950 --> 00:05:01.460
and classes which you associate with
this entity will never be instantiated.

00:05:01.460 --> 00:05:04.260
They're effectively just generic types.

00:05:04.260 --> 00:05:08.580
And the reason you would declare
an entity as abstract is because

00:05:08.580 --> 00:05:13.010
perhaps you want it to be the
root of an inheritance hierarchy.

00:05:13.710 --> 00:05:18.250
So if you have an inheritance hierarchy,
obviously you need to be able to

00:05:18.250 --> 00:05:20.540
specify that the entity has a parent.

00:05:20.540 --> 00:05:25.310
And in the demonstration now,
you can see that our agent entity

00:05:25.310 --> 00:05:27.880
inherits from our user entity.

00:05:27.880 --> 00:05:31.590
That basically states that this
entity will expose all of the

00:05:31.820 --> 00:05:34.000
attributes of the user entity.

00:05:36.620 --> 00:05:40.690
Now given that you have,
I'm going to go forward one

00:05:40.820 --> 00:05:41.630
slide and then come back.

00:05:42.880 --> 00:05:48.680
So an example of inheritance in
EOF is single table inheritance.

00:05:48.790 --> 00:05:51.260
And that's exactly what
we've modeled here.

00:05:51.260 --> 00:05:55.080
And you can see that we have
four entities in the example

00:05:55.080 --> 00:05:57.520
which all map to the user table.

00:05:57.520 --> 00:06:00.120
This is single table inheritance.

00:06:00.120 --> 00:06:03.400
Essentially every attribute
that you are modeling in your

00:06:03.460 --> 00:06:05.440
entities exists in this table.

00:06:07.520 --> 00:06:12.860
The consequence of that is that
not every row in that table is

00:06:12.860 --> 00:06:14.400
appropriate for each entity.

00:06:14.400 --> 00:06:17.440
So you would want to be able
to specify a restricting

00:06:17.440 --> 00:06:23.260
qualifier to each entity type,
filtering the rows in the database

00:06:23.260 --> 00:06:26.860
so that only the appropriate rows are
pulled in that represent that entity.

00:06:26.860 --> 00:06:29.520
And in this case,
you can see we have a qualifier

00:06:29.520 --> 00:06:31.080
of user type equals one.

00:06:31.080 --> 00:06:34.740
And if we were to look at the data,
you would see that the agent

00:06:34.850 --> 00:06:36.830
types have a user type of one.

00:06:40.690 --> 00:06:44.590
Sometimes entities
represent read-only data,

00:06:44.660 --> 00:06:46.750
reference data, typically read-only.

00:06:46.870 --> 00:06:49.140
You can specify that
the entity is read-only.

00:06:49.140 --> 00:06:53.400
Now, this is not going to stop you from
changing the value of the attributes.

00:06:53.400 --> 00:06:56.620
It's not akin to the property
veto exceptions you would

00:06:56.720 --> 00:06:58.560
find in traditional Java.

00:06:58.560 --> 00:07:03.570
But what will happen if you try and
save that entity is EOF will raise

00:07:03.670 --> 00:07:06.260
an exception and abort the save.

00:07:07.030 --> 00:07:10.770
Sometimes you know that you are
going to want to fetch a certain

00:07:10.850 --> 00:07:12.460
type of entity repeatedly.

00:07:12.460 --> 00:07:16.800
And you can actually specify that you
would like the entity cached in memory.

00:07:16.800 --> 00:07:21.040
And this has the effect that the
first time you hit that entity,

00:07:21.040 --> 00:07:24.340
every single row in the database
is going to be pulled into memory.

00:07:24.340 --> 00:07:26.790
Subsequent fetches are
going to be against memory,

00:07:26.790 --> 00:07:27.800
not the database.

00:07:27.800 --> 00:07:30.500
So you don't have the overhead
of going to the database

00:07:30.500 --> 00:07:32.040
every time you want to fetch.

00:07:33.520 --> 00:07:36.950
It's particularly important to understand
that caching them does not prevent

00:07:36.950 --> 00:07:38.380
them from being garbage collected.

00:07:38.380 --> 00:07:45.480
So if you do have situations where you
would like to have objects in memory

00:07:45.480 --> 00:07:49.290
for the duration of an application,
then perhaps the shared editing context

00:07:49.380 --> 00:07:51.510
is a more appropriate vessel for you.

00:07:51.680 --> 00:07:54.840
Shared editing context is
not part of this lecture.

00:07:54.840 --> 00:07:58.960
It's actually detailed in Advanced EOF,
which is immediately following.

00:08:04.710 --> 00:08:11.140
So just as an entity maps
a table to an object,

00:08:11.180 --> 00:08:16.190
attributes map individual columns
in those tables to instance

00:08:16.190 --> 00:08:19.700
variables in your classes.

00:08:20.130 --> 00:08:22.850
So we have our property
entity selected here,

00:08:22.850 --> 00:08:28.310
and you can see that it has
numerous attributes modeled.

00:08:28.560 --> 00:08:33.190
How do you tell Modeler which
attribute to expose in your Java class?

00:08:33.360 --> 00:08:35.670
Well, we're going to describe
the characteristics of the

00:08:35.670 --> 00:08:37.380
attribute from left to right.

00:08:37.380 --> 00:08:40.330
And the first column
is these diamond icons,

00:08:40.430 --> 00:08:43.470
which basically say,
"Expose this attribute as a

00:08:43.470 --> 00:08:47.700
property in my class." Now,
you might be asking,

00:08:47.700 --> 00:08:51.440
"Why would you model an attribute
if you're not going to expose

00:08:51.470 --> 00:08:55.020
it as a class property?" Well,
there are certain attributes

00:08:55.160 --> 00:08:58.260
that EOF needs to be able
to perform its functions,

00:08:58.330 --> 00:08:59.880
one of which is primary key.

00:09:00.370 --> 00:09:03.830
Primary key, as in a database,
is used to unique that,

00:09:04.030 --> 00:09:08.160
an instance of this entity
in your application.

00:09:08.160 --> 00:09:12.340
And you can see here we have a
primary key indicated by the key icon,

00:09:12.340 --> 00:09:16.100
and it is indeed not
exposed as a class property.

00:09:16.240 --> 00:09:18.690
Now, you may expose it as a
class property if you want,

00:09:18.700 --> 00:09:23.790
but really changing the value of a
primary key isn't terribly useful.

00:09:24.950 --> 00:09:25.950
The locking icon.

00:09:25.960 --> 00:09:31.590
Now, the locking icon is part
of EOF's facility to detect

00:09:31.720 --> 00:09:33.270
optimistic locking failures.

00:09:33.280 --> 00:09:38.230
And every single attribute that you label
as a locked attribute is going to be

00:09:38.230 --> 00:09:43.660
compared against the database values for
that attribute when you try and save.

00:09:43.660 --> 00:09:47.860
And this is how EOF is going to try
and prevent last save wins behavior.

00:09:49.120 --> 00:09:52.400
Typically,
you should not lock any attribute

00:09:52.400 --> 00:09:56.330
which maps to a large object type,
so blobs or clobs.

00:09:56.330 --> 00:09:59.030
And the reason is,
is because EOF has to fetch those

00:09:59.250 --> 00:10:01.810
values into memory to do the comparison.

00:10:01.810 --> 00:10:05.820
So there's a memory
overhead for doing that.

00:10:06.280 --> 00:10:10.210
Ideally, you would like to find an
attribute against which to lock,

00:10:10.230 --> 00:10:15.320
which is guaranteed to change
every time you save the database.

00:10:15.320 --> 00:10:19.050
So, for instance,
if you modeled a modified date,

00:10:19.050 --> 00:10:24.250
which you'd set up your eogeneric record
or subclass thereof or editing context

00:10:24.270 --> 00:10:28.600
to set every time you save an entity,
then you could have literally

00:10:28.600 --> 00:10:29.940
one locking attribute.

00:10:30.490 --> 00:10:33.840
And this would actually speed up
the comparison because obviously

00:10:33.840 --> 00:10:37.820
the SQL that's going to be generated
through the comparison will be simpler.

00:10:39.190 --> 00:10:42.870
You'll note actually that the primary key
is not a locking attribute simply because

00:10:42.890 --> 00:10:44.530
it's used to fetch the record anyway.

00:10:44.540 --> 00:10:49.400
So the next column is allows null.

00:10:49.490 --> 00:10:53.200
And this basically, as for a database,
allows you to specify

00:10:53.200 --> 00:10:56.490
that this attribute,
while mapped to a column in the database,

00:10:56.600 --> 00:10:58.040
may actually be null.

00:10:58.130 --> 00:11:00.100
And thus it may be null in the database.

00:11:00.170 --> 00:11:05.980
Now, from my own experience,
I would say that allowing attributes

00:11:05.980 --> 00:11:07.970
to be null is necessary sometimes.

00:11:08.240 --> 00:11:12.620
But I would also say that if you can,
you should try and get away from

00:11:12.620 --> 00:11:14.740
allowing your developers to set null.

00:11:14.880 --> 00:11:18.900
Finding a database full of
nulls is not terribly useful.

00:11:19.140 --> 00:11:23.480
If you need to specify default values,
then within your code,

00:11:23.480 --> 00:11:29.040
you can actually override methods
away from insertion to set

00:11:29.040 --> 00:11:31.700
default values into those fields.

00:11:32.510 --> 00:11:35.930
So the next column is the name,
and this simply uniquely identifies

00:11:36.040 --> 00:11:38.660
this attribute within this entity.

00:11:38.930 --> 00:11:43.050
And this name is going to be used to
generate methods for accessing and

00:11:43.170 --> 00:11:48.520
mutating this property should you
choose to expose it as a class property.

00:11:49.500 --> 00:11:51.250
Value Class.

00:11:51.410 --> 00:11:59.760
We need to know what type to map
the database type to in your class.

00:11:59.760 --> 00:12:03.620
We offer a certain,
a discrete number of types to map to,

00:12:03.620 --> 00:12:07.760
and we'll talk about
those in just a minute.

00:12:08.430 --> 00:12:10.280
Column name,
obviously the column name that this

00:12:10.280 --> 00:12:11.620
attribute maps to in the database.

00:12:11.680 --> 00:12:14.040
External type.

00:12:14.520 --> 00:12:17.810
This dictates the type in the database.

00:12:17.820 --> 00:12:21.690
Now the reason we have to
provide this is because most

00:12:22.330 --> 00:12:26.590
databases have their own types,
and they're not always the same for, say,

00:12:26.600 --> 00:12:28.040
for instance, string.

00:12:28.040 --> 00:12:36.230
So by allowing us to list the
JDBC data types and either

00:12:36.230 --> 00:12:40.110
restrict or augment those types
with a vendor-specific plug-in,

00:12:40.120 --> 00:12:43.440
we can provide you with a drop-down
list of what types you can actually

00:12:43.440 --> 00:12:45.390
map to for this specific database.

00:12:47.350 --> 00:12:49.860
Value types.

00:12:49.920 --> 00:12:53.020
You'll note in our example
that the bathrooms attribute,

00:12:53.050 --> 00:12:57.000
the value class that we're
talking about for mapping to

00:12:57.000 --> 00:12:58.640
in the Java class is number.

00:12:58.930 --> 00:13:01.210
And for those of you that
are familiar with number,

00:13:01.310 --> 00:13:03.780
it's an abstract class,
so it couldn't actually

00:13:03.890 --> 00:13:05.310
be directly instantiated.

00:13:05.620 --> 00:13:10.940
The value type allow you to indicate
which concrete subclass of number

00:13:10.940 --> 00:13:15.580
you would like to be instantiated
for this particular attribute.

00:13:15.930 --> 00:13:19.200
There are actually
other uses of this type.

00:13:19.380 --> 00:13:25.300
For instance, for car database types,
you can give a value type which will

00:13:25.380 --> 00:13:28.890
identify whether you would like to
strip or retain training spaces.

00:13:28.900 --> 00:13:31.900
The value types are all
detailed in the release notes,

00:13:31.900 --> 00:13:34.000
and they're quite comprehensive.

00:13:35.580 --> 00:13:37.040
Okay.

00:13:37.170 --> 00:13:41.340
So you can see the basic
characteristics of an attribute here,

00:13:41.510 --> 00:13:42.740
but there are others.

00:13:42.860 --> 00:13:45.500
And at the very bottom
of the attributes panel,

00:13:45.500 --> 00:13:48.920
you can see a drop-down which
allows you to add additional

00:13:49.640 --> 00:13:55.740
columns to the view so that you can
actually have a customized view.

00:13:55.740 --> 00:14:00.100
If you want to remove a column,
you just select it and delete it,

00:14:00.100 --> 00:14:01.540
and it goes away.

00:14:03.920 --> 00:14:08.720
Okay, so we've basically covered
simple attribute characteristics,

00:14:08.720 --> 00:14:11.750
but attributes can have some
advanced characteristics.

00:14:11.800 --> 00:14:15.040
Notably,
if you want finer-grained control over

00:14:15.040 --> 00:14:20.160
whether your developers can actually
write to the attribute rather than

00:14:20.160 --> 00:14:24.710
marking the entire entity as read-only,
you can mark individual

00:14:24.770 --> 00:14:26.900
attributes as read-only.

00:14:27.470 --> 00:14:33.540
Custom formatting allows you to specify
in a database-independent fashion

00:14:33.700 --> 00:14:36.730
Processing that you would like
to happen to the attribute on a

00:14:36.750 --> 00:14:38.990
write or a read from the database.

00:14:39.020 --> 00:14:41.980
And this processing is going
to happen in the database,

00:14:41.980 --> 00:14:43.880
not in the application server.

00:14:43.880 --> 00:14:47.450
So a good example is,
and one that we use,

00:14:47.450 --> 00:14:50.540
is truncation of time from a date.

00:14:50.620 --> 00:14:54.560
So you can simply specify in the
write custom formatting that you would

00:14:54.750 --> 00:14:55.930
like to truncate time off a date.

00:14:57.510 --> 00:15:00.420
We're not doing that.

00:15:00.490 --> 00:15:03.600
As I talked about earlier,
we provide a discrete list of

00:15:03.740 --> 00:15:05.500
classes that you can map to.

00:15:05.560 --> 00:15:09.720
And nine times out of ten,
and maybe 9.9 times out of ten,

00:15:09.790 --> 00:15:12.220
these are going to be
sufficient for your purpose.

00:15:12.300 --> 00:15:14.840
But on occasion, it's not,
and you would like to map it

00:15:14.940 --> 00:15:17.940
to a class of your own design.

00:15:18.000 --> 00:15:22.200
So we allow you to specify
a custom class type.

00:15:22.250 --> 00:15:26.480
And the custom class type,
you create the class yourself.

00:15:26.540 --> 00:15:29.800
But obviously, EOF needs to know how
to create that class.

00:15:29.860 --> 00:15:34.240
And so we need to specify a
factory method within that class.

00:15:34.300 --> 00:15:37.040
And for those of you not
familiar with the term factory,

00:15:37.100 --> 00:15:40.790
all we're really talking about is
a static method within the class.

00:15:41.070 --> 00:15:43.470
Additionally,
we need to know the data type that you're

00:15:43.470 --> 00:15:45.160
going to be passing to that method.

00:15:45.160 --> 00:15:50.520
And right now we support NSData, string,
and a byte array.

00:15:52.130 --> 00:15:54.860
So having got your data
into your custom class,

00:15:54.980 --> 00:15:58.160
we obviously now need to know
how to get the data back out.

00:15:58.180 --> 00:16:02.920
And so we ask that you provide
a conversion method that will

00:16:02.920 --> 00:16:06.320
return an appropriate type,
usually the same type as

00:16:06.320 --> 00:16:08.720
the initializing type,
that can be mapped

00:16:08.720 --> 00:16:10.410
successfully to the database.

00:16:13.930 --> 00:16:18.580
Sometimes you would like
to model attributes in your

00:16:18.580 --> 00:16:23.400
entities which don't naturally
map to a column in the database.

00:16:23.400 --> 00:16:25.680
And these are called derived types.

00:16:25.680 --> 00:16:30.560
And typically they are calculated
from some other attribute.

00:16:30.560 --> 00:16:35.570
And you simply change the
type from column to derived,

00:16:35.940 --> 00:16:37.830
enter your formula,
and you will have that

00:16:37.940 --> 00:16:39.560
derived type in that entity.

00:16:39.560 --> 00:16:42.450
Now because they are calculated
from some other value,

00:16:42.450 --> 00:16:45.080
they are effectively read-only
because there is actually

00:16:45.080 --> 00:16:46.180
nowhere to write them back to.

00:16:48.660 --> 00:16:53.000
Okay, so a special type of derived
attribute is the flattened attribute.

00:16:53.000 --> 00:16:56.480
And this effectively is an
attribute from an entirely

00:16:56.480 --> 00:17:01.760
different entity that you would like
to expose in this particular entity.

00:17:01.800 --> 00:17:04.980
So if you have a relationship
between one entity,

00:17:04.980 --> 00:17:06.810
I know we haven't talked
about relationships yet,

00:17:06.890 --> 00:17:07.940
but we will very shortly.

00:17:07.940 --> 00:17:11.200
If you have a relationship
from one entity to another,

00:17:11.200 --> 00:17:16.440
you can navigate that relationship,
select the attribute you

00:17:16.440 --> 00:17:19.900
would like to flatten,
and flatten it into your entity.

00:17:20.070 --> 00:17:23.800
And you can see here we have agent
last name flattened into property.

00:17:23.800 --> 00:17:27.180
When you access this attribute,
EOF is going to navigate

00:17:27.180 --> 00:17:30.160
that relationship and pull
that value back for you.

00:17:37.190 --> 00:17:42.040
Relationships.

00:17:42.520 --> 00:17:48.800
EOF allows you to map a foreign
key from one entity into another,

00:17:48.950 --> 00:17:53.420
or an attribute from
one object to another.

00:17:53.440 --> 00:17:58.570
Just as you can define foreign
key relationships in a database,

00:17:58.630 --> 00:18:02.370
EOF has the same axiom.

00:18:02.690 --> 00:18:07.100
Relationships fall into
one of two general types.

00:18:07.160 --> 00:18:09.780
To one, relationships,
which basically say there

00:18:09.780 --> 00:18:13.060
is going to be one instance,
potentially one instance of an entity

00:18:13.060 --> 00:18:14.600
at the end of this relationship.

00:18:14.810 --> 00:18:19.000
To many, which basically says there's
going to be an array,

00:18:19.640 --> 00:18:23.520
possibly, of instances at the end
of this relationship.

00:18:24.660 --> 00:18:28.640
Now, we have two examples of
relationships on screen.

00:18:28.640 --> 00:18:32.350
And we're using the diagram view here
because it makes it slightly clearer.

00:18:32.560 --> 00:18:34.660
And we have our agent entity.

00:18:34.840 --> 00:18:38.650
And it has a 2-1
relationship to agent photo.

00:18:38.810 --> 00:18:43.860
And you can see it's 2-1 because it's
marked with a 1 greater than symbol,

00:18:43.890 --> 00:18:46.280
and the relationship
line has a single arrow.

00:18:49.350 --> 00:18:53.570
We also have a
relationship to properties.

00:18:53.570 --> 00:18:56.780
Now this is a to-many relationship,
which is indicated by the two

00:18:56.780 --> 00:18:59.680
greater-than symbols and the
fact that the relationship

00:18:59.680 --> 00:19:00.910
line has duplicate arrows.

00:19:05.120 --> 00:19:08.890
Having mapped a relationship
from one entity to another,

00:19:08.890 --> 00:19:13.020
it's sometimes useful to
make a relationship back

00:19:13.150 --> 00:19:15.120
to the originating entity.

00:19:15.120 --> 00:19:20.670
In both cases here, we have relationships
going back to the agent.

00:19:21.440 --> 00:19:24.070
These are called inverse relationships.

00:19:24.070 --> 00:19:27.270
You should consider carefully
what you really want to do

00:19:27.670 --> 00:19:29.270
with inverse relationships.

00:19:29.580 --> 00:19:35.340
Typically, an inverse relationship which
is a too many may end up firing

00:19:35.440 --> 00:19:39.190
relationship faults or creating
relationship faults for numerous

00:19:39.190 --> 00:19:41.000
objects which you didn't really intend.

00:19:41.000 --> 00:19:47.470
Just be careful about what type of
inverse relationships you're creating.

00:19:49.900 --> 00:19:58.200
[Transcript missing]

00:19:58.810 --> 00:20:05.020
So sometimes the relationship
between two entities is quite loose.

00:20:05.020 --> 00:20:07.550
So, for instance,
if we look at the property

00:20:08.450 --> 00:20:12.260
relationship here,
we can see that an agent may have

00:20:12.450 --> 00:20:18.190
maybe a particularly bad agent,
and he may manage zero properties.

00:20:18.200 --> 00:20:22.690
But we may have a particularly
good agent on hand,

00:20:22.720 --> 00:20:25.000
and they may manage many properties.

00:20:25.000 --> 00:20:27.440
So this relationship is optional.

00:20:29.110 --> 00:20:30.660
There may be zero or there may be many.

00:20:32.400 --> 00:20:36.180
However, we can say that the
relationship is mandatory.

00:20:36.180 --> 00:20:39.660
And what we're saying there is
there's a much stronger relationship.

00:20:39.800 --> 00:20:43.040
And we're saying that for
each agent in this case,

00:20:43.680 --> 00:20:49.080
if we look at the photo relationship,
there must be at least one photo.

00:20:49.150 --> 00:20:52.290
And what's going to happen is if you
try and save an agent without a photo,

00:20:52.390 --> 00:20:55.970
EOF is going to stop you from saving,
and you will have to set

00:20:55.970 --> 00:20:57.570
up that relationship.

00:20:57.740 --> 00:21:00.420
This sort of relationship
won't stop you from fetching

00:21:00.420 --> 00:21:04.080
the agents from the database,
but if you then try and save one which

00:21:04.240 --> 00:21:08.790
doesn't have this relationship set up,
then EOF's going to prevent that save.

00:21:09.020 --> 00:21:10.900
Okay, I've missed one at the top here.

00:21:10.950 --> 00:21:11.900
Batch faulting.

00:21:12.000 --> 00:21:15.200
This is only appropriate
to too many relationships,

00:21:15.280 --> 00:21:19.200
and when EOF fetches

00:21:19.440 --> 00:21:27.390
and David Bates The relationships of
an entity are populated with faults.

00:21:27.420 --> 00:21:31.240
In Java, a fault is a fully
constituted Java class,

00:21:31.260 --> 00:21:35.000
but it doesn't have all the data
sucked in from the database.

00:21:36.400 --> 00:21:40.750
So in the case of too many relationships,
you have an array of relationship faults.

00:21:40.940 --> 00:21:45.980
Now as you navigate that relationship
and start to use those faults,

00:21:46.050 --> 00:21:50.180
they fire and become
fully constituted classes.

00:21:51.060 --> 00:21:54.100
The problem with this is that
as you iterate over that array,

00:21:54.100 --> 00:21:59.540
every time you hit one of those faults,
it files a fetch to the database,

00:21:59.540 --> 00:22:01.360
gets the data, populates the class.

00:22:01.460 --> 00:22:04.130
So if you have a large array,
you can see that it might pose

00:22:04.130 --> 00:22:07.430
some performance problem for
your application because you have

00:22:07.480 --> 00:22:09.530
many round trips to the database.

00:22:09.540 --> 00:22:14.590
Batch faulting allows you to say,
when I access this relationship,

00:22:14.610 --> 00:22:17.830
when I fire this fault,
I want you to fire that

00:22:17.930 --> 00:22:20.060
fault and this many more.

00:22:20.590 --> 00:22:23.060
So you can avoid numerous
trips to the database.

00:22:23.060 --> 00:22:25.060
It's a very useful feature.

00:22:27.020 --> 00:22:28.360
Okay, delete rules.

00:22:28.380 --> 00:22:34.480
Now the delete rules talk about what you
want to happen to the destination entity

00:22:35.110 --> 00:22:38.540
when this source entity is deleted.

00:22:38.540 --> 00:22:42.150
And the top of the list,
and therefore the default, is nullify,

00:22:42.320 --> 00:22:44.400
which usually isn't what you want.

00:22:44.880 --> 00:22:48.360
And this basically says that
if you have a relationship to a

00:22:48.360 --> 00:22:51.490
foreign key in your target entity,
just null it out.

00:22:51.580 --> 00:22:55.540
So in our properties example,
if you deleted this agent

00:22:55.540 --> 00:22:59.540
and your rule was nullify,
you would null out the agent ID.

00:22:59.710 --> 00:23:04.340
So this has the implication, of course,
that when you're modeling that attribute,

00:23:04.430 --> 00:23:07.320
you need to mark it as nullable.

00:23:07.330 --> 00:23:09.830
And that's one of the
very few circumstances,

00:23:09.830 --> 00:23:14.040
I think, where allowing null
is a reasonable thing.

00:23:15.600 --> 00:23:18.360
So the second rule is cascade.

00:23:18.360 --> 00:23:22.160
And this basically says
when I delete this source,

00:23:22.220 --> 00:23:26.390
I want to delete any related entity.

00:23:26.500 --> 00:23:30.740
So in this case,
if I were to delete my agent,

00:23:30.810 --> 00:23:35.050
EOF would attempt to
delete the agent photo.

00:23:37.080 --> 00:23:38.420
So if you didn't want
to delete the photo,

00:23:38.420 --> 00:23:40.400
you could just unrelate it.

00:23:40.490 --> 00:23:44.400
Unfortunately, this is mandatory,
so I wouldn't let you do that either.

00:23:44.530 --> 00:23:48.030
So the next rule is deny,
and that basically says,

00:23:48.030 --> 00:23:52.890
if at the end of this relationship
there is another entity,

00:23:52.980 --> 00:23:56.540
then do not allow me
to delete this entity.

00:23:56.820 --> 00:24:00.310
So if you wanted to delete
something which had a deny rule,

00:24:00.490 --> 00:24:04.180
you would have to disassociate
the target from the source,

00:24:04.340 --> 00:24:06.820
and then you could go
ahead and delete it.

00:24:07.490 --> 00:24:15.390
The other things, owns destination and
propagate primary key.

00:24:15.420 --> 00:24:21.580
These things imply an extremely strong
relationship between your entities.

00:24:21.580 --> 00:24:26.980
Owns destination says that
the destination entity cannot

00:24:26.990 --> 00:24:29.700
exist without the source.

00:24:29.700 --> 00:24:33.260
So in this case,
we have an agent with a photo

00:24:33.260 --> 00:24:35.830
relationship to agent photo.

00:24:35.940 --> 00:24:40.770
And the relationship is such
that it says that a photo

00:24:40.770 --> 00:24:47.070
cannot exist without a parent,
without an owning agent.

00:24:47.210 --> 00:24:50.970
Now the implication of this
is if you disassociate an

00:24:50.970 --> 00:24:55.550
agent photo from an agent,
then EOF is going to mark

00:24:55.550 --> 00:24:58.230
that photo for deletion.

00:24:58.720 --> 00:25:02.750
The other implication is
that if you create an agent,

00:25:02.750 --> 00:25:06.620
EOF is automatically going to
create an agent photo for you,

00:25:06.620 --> 00:25:10.110
insert it into the editing context,
and set up the relationship.

00:25:11.090 --> 00:25:14.000
Propagates primary key simply
says that when that sort of

00:25:14.030 --> 00:25:18.490
relationship is established,
the primary key of the source should

00:25:18.490 --> 00:25:20.020
be propagated to the destination.

00:25:20.020 --> 00:25:26.350
So we're basically going to establish a
relationship primary key to primary key.

00:25:32.390 --> 00:25:36.980
Okay, so having created our model,
we've created our entities,

00:25:36.980 --> 00:25:39.780
we have our attributes,
we've set up our relationships.

00:25:39.780 --> 00:25:42.160
How does it relate to the database?

00:25:42.330 --> 00:25:45.340
How does it relate to our code?

00:25:45.450 --> 00:25:48.660
So nine times out of ten,
you're going to come to a problem

00:25:48.730 --> 00:25:52.770
or you're going to be appointed to
model this particular circumstance,

00:25:52.770 --> 00:25:55.100
and the schema probably already exists.

00:25:55.160 --> 00:25:59.120
There's a DBA that's been
working away very hard and naming

00:25:59.120 --> 00:26:01.670
columns with lots of underbars.

00:26:01.830 --> 00:26:04.320
You're going to be expected
to map this through to a

00:26:04.320 --> 00:26:06.060
reasonable Java object model.

00:26:06.060 --> 00:26:11.390
If you had to do that by hand,
it would be an extremely onerous task.

00:26:11.400 --> 00:26:17.110
EOModeler allows you to reverse
engineer an existing schema

00:26:17.180 --> 00:26:19.900
to create a basic model.

00:26:19.900 --> 00:26:22.730
In this case,
we're going to reverse engineer

00:26:23.000 --> 00:26:25.000
an open-based database.

00:26:25.000 --> 00:26:28.330
Obviously,
you can reverse engineer as much or as

00:26:28.410 --> 00:26:30.970
little of that database as you want.

00:26:31.460 --> 00:26:34.880
So we're going to just go
ahead-- you've seen this before,

00:26:34.880 --> 00:26:34.880
I know.

00:26:37.180 --> 00:26:37.730
So there you go.

00:26:37.890 --> 00:26:40.030
It's created a basic model for you.

00:26:40.030 --> 00:26:43.440
And sometimes this model
might be enough for you.

00:26:43.440 --> 00:26:46.790
But you're probably going to
want to change attribute names.

00:26:46.790 --> 00:26:48.980
You may want to infer
other relationships.

00:26:48.980 --> 00:26:53.870
But one thing you'll note that's
different between our newly created

00:26:53.870 --> 00:26:58.180
model and our example model is
that the inheritance entities

00:26:58.180 --> 00:27:02.840
that we'd set up previously,
notably administrator and agent,

00:27:02.840 --> 00:27:05.600
aren't included in our new model.

00:27:05.600 --> 00:27:09.040
So we would want to go ahead and
do that sort of modeling ourselves.

00:27:09.040 --> 00:27:11.910
But it's still a very useful feature.

00:27:12.180 --> 00:27:15.440
Now occasionally,
and I admit it's very occasionally,

00:27:15.440 --> 00:27:19.080
you get to a project and you
have total control of the schema.

00:27:19.080 --> 00:27:24.620
So in that circumstance,
you can actually use EOModeler to

00:27:25.240 --> 00:27:30.520
model your entire project and then
have Modeler generate the SQL that

00:27:30.520 --> 00:27:33.060
will create the schema for you.

00:27:33.080 --> 00:27:37.800
So in our example here,
we're going to create the SQL for agent.

00:27:38.480 --> 00:27:42.980
Now, again, you can create as little
or as much SQL as you like.

00:27:43.080 --> 00:27:46.940
Now,
you can either execute the SQL directly,

00:27:46.940 --> 00:27:51.440
in which case it will connect to
the database you have specified

00:27:51.440 --> 00:27:54.490
in your connection dictionary,
or you can save it off as a separate

00:27:54.610 --> 00:27:58.920
script so that you can recreate
this database whenever you want to.

00:28:02.180 --> 00:28:07.490
So now we have our database
and we have our model.

00:28:07.590 --> 00:28:09.550
How do we give our developers
what they really need,

00:28:09.600 --> 00:28:11.630
which is classes?

00:28:12.390 --> 00:28:18.190
So from an entity,
Modeler allows you to generate Java code

00:28:18.250 --> 00:28:23.150
according to the class name that
you have specified for that entity.

00:28:23.210 --> 00:28:26.020
Now for EOGenericRecord,
you don't have to do anything.

00:28:26.210 --> 00:28:28.200
EOFs are going to create
an EOGenericRecord,

00:28:28.330 --> 00:28:34.370
give it the right entity name,
and Bob's your uncle.

00:28:34.370 --> 00:28:34.370
There you go.

00:28:34.370 --> 00:28:34.370
Bob Fraser, that is.

00:28:35.830 --> 00:28:40.690
But when you specified your own
class where you wanted to build

00:28:40.690 --> 00:28:45.130
up your own business logic,
you can generate Java code which

00:28:45.200 --> 00:28:47.960
can then be imported into your
project and your developers can use.

00:28:47.960 --> 00:28:49.710
So you can save this
to wherever you want,

00:28:49.710 --> 00:28:52.580
import it into your project,
put it into your source code system.

00:28:52.580 --> 00:28:55.760
So we've created one simple class here,
the agent.

00:28:55.760 --> 00:28:58.200
And you'll note in this case
that this class does not

00:28:58.310 --> 00:28:59.900
extend the eogenetic record.

00:28:59.900 --> 00:29:03.580
It actually extends user
because if you'll remember,

00:29:03.980 --> 00:29:07.120
agent was one of our
inherited classes from user.

00:29:07.120 --> 00:29:11.000
And basically the generated
class is extremely simple.

00:29:11.000 --> 00:29:13.480
It doesn't contain a
lot of bump and cruft.

00:29:13.600 --> 00:29:18.490
It contains accesses and mutators
appropriate to the class properties

00:29:18.490 --> 00:29:22.370
that you have exposed and the
relationships that you have exposed.

00:29:27.700 --> 00:29:33.450
So, in the circumstance where you end
up with a fastidious DBA creating

00:29:33.450 --> 00:29:36.660
all manner of tables that
you're now expected to model to,

00:29:36.660 --> 00:29:38.470
it's going to happen.

00:29:38.480 --> 00:29:40.470
The schema is going to
change underneath you,

00:29:40.620 --> 00:29:42.890
and you're going to be expected
to keep in sync with it.

00:29:43.430 --> 00:29:43.830
Now...

00:29:45.060 --> 00:29:47.510
A while ago,
you would have had to individually,

00:29:47.630 --> 00:29:50.920
you would look at the database itself,
and then you would have to model

00:29:50.960 --> 00:29:52.270
each individual table yourself.

00:29:52.340 --> 00:29:57.460
EOModeler now allows you to synchronize
the database schema with your model.

00:29:57.460 --> 00:30:00.320
And what it's going to do is
it's going to examine the schema,

00:30:00.400 --> 00:30:02.940
reverse engineer it,
compare it to your model,

00:30:02.940 --> 00:30:09.460
and provide you with hints,
actions that you need to take to bring

00:30:09.480 --> 00:30:12.530
your model into sync with the schema.

00:30:12.540 --> 00:30:14.280
Extremely useful feature.

00:30:15.000 --> 00:30:18.900
Okay.

00:30:23.990 --> 00:30:27.280
So now you have your Java classes,
and you have your model,

00:30:27.280 --> 00:30:28.540
and you have your database.

00:30:28.540 --> 00:30:33.160
So how do your developers
get to those classes?

00:30:33.160 --> 00:30:37.160
They can't instantiate them directly
because there'll just be an empty class.

00:30:37.200 --> 00:30:38.210
There'll be no data there.

00:30:38.220 --> 00:30:42.860
So we have these things called
EO Fetch Specifications,

00:30:42.860 --> 00:30:47.330
which are essentially queries
to the database which will allow

00:30:47.330 --> 00:30:52.100
you to fetch a qualified set of
objects into an editing context.

00:30:52.460 --> 00:30:56.060
Once they're in the editing context,
your developers can then manipulate them,

00:30:56.060 --> 00:30:57.800
save them, delete them, whatever.

00:30:59.620 --> 00:31:02.190
So we're going to show you
a brief example of building

00:31:02.300 --> 00:31:03.920
a fetch specification.

00:31:04.010 --> 00:31:06.500
So we're going to build a
fetch spec called super agent.

00:31:06.500 --> 00:31:10.860
And we're going to ask for--you
can build the qualifier on

00:31:10.960 --> 00:31:12.880
any attribute in this entity.

00:31:13.010 --> 00:31:15.300
So we're going to ask for

00:31:15.930 --> 00:31:18.650
First name of Tony,
because we understand that

00:31:18.650 --> 00:31:22.000
there's an agent called Tony,
and she's particularly good.

00:31:22.050 --> 00:31:26.540
And by the way,
she has no impact on my salary.

00:31:29.800 --> 00:31:31.590
So in this case,
you can see we used the browse

00:31:31.640 --> 00:31:35.020
facility to fire that fetch spec
and we got the right result back.

00:31:35.050 --> 00:31:38.180
But obviously, the static search is
not really that useful,

00:31:38.210 --> 00:31:41.780
so we allow you to
specify binding variables,

00:31:41.790 --> 00:31:45.240
which allow you to programmatically
specify what your users

00:31:45.240 --> 00:31:46.780
are actually looking for.

00:31:47.100 --> 00:31:50.040
So in this case,
we have a binding name of last name.

00:31:50.410 --> 00:31:52.360
In your code,
you would create a dictionary of

00:31:52.470 --> 00:31:55.510
bindings where the key would be
last name and the value would be

00:31:55.510 --> 00:31:58.640
whatever you're searching for.

00:31:59.910 --> 00:32:00.660
Sort Orderings.

00:32:00.660 --> 00:32:03.690
So as well as qualifying the fetch,
you can also use sort

00:32:03.710 --> 00:32:05.240
orderings to sort your results.

00:32:05.240 --> 00:32:07.660
You can sort on any
attribute in that entity,

00:32:07.660 --> 00:32:11.990
and these sorts can be ascending
or descending and can be case

00:32:11.990 --> 00:32:14.560
sensitive or case insensitive.

00:32:17.830 --> 00:32:18.560
Pre-fetching.

00:32:18.590 --> 00:32:21.460
We mentioned earlier
about batch faulting,

00:32:21.460 --> 00:32:25.440
where you batch fault a particular
relationship to make sure that

00:32:25.450 --> 00:32:28.860
you get a certain number of
those relationship faults fired,

00:32:28.860 --> 00:32:31.410
and thus you have that data
to hand with one round trip.

00:32:31.440 --> 00:32:34.350
Well,
pre-fetching allows you to effectively

00:32:34.910 --> 00:32:39.360
fetch a relationship at the same
time as you fetch the entity.

00:32:39.360 --> 00:32:42.460
So if you know, for instance,
in a particular area of your

00:32:42.460 --> 00:32:46.700
application that you are going to need
to navigate a certain relationship,

00:32:46.700 --> 00:32:49.970
iterate over all the
values that you find there,

00:32:49.980 --> 00:32:54.160
then pre-fetching will allow you to
fetch that relationship at the same

00:32:54.190 --> 00:32:58.500
time as the entity and will avoid
numerous round trips to the database.

00:33:02.110 --> 00:33:04.220
Raw Fetch.

00:33:04.250 --> 00:33:09.660
Okay, so sometimes everybody knows
there is a small overhead,

00:33:09.660 --> 00:33:12.810
small, to creating a Java class.

00:33:12.900 --> 00:33:16.940
So sometimes there are going to be areas
of your applications where it's not

00:33:16.940 --> 00:33:23.470
efficient to create 10,000 instances
of an object when all you really want

00:33:23.510 --> 00:33:28.200
to do is look at the values in that
object and take action from there.

00:33:28.200 --> 00:33:32.080
So EOF allows you to specify
that you want to do a raw fetch.

00:33:32.250 --> 00:33:35.970
That is,
you want to retrieve the entities

00:33:35.990 --> 00:33:38.420
as dictionaries of values.

00:33:38.820 --> 00:33:41.500
And you can either fetch all of the
attributes or just a specific number

00:33:41.560 --> 00:33:43.370
of attributes depending on your needs.

00:33:45.700 --> 00:33:53.590
I actually would say that doing raw
fetches is fine for certain applications,

00:33:53.600 --> 00:33:57.330
but I wouldn't actually go that way
until you actually have realistic

00:33:57.330 --> 00:34:01.900
performance metrics that say that you
really do have a performance problem.

00:34:01.900 --> 00:34:05.390
In the event that you do do a raw fetch
and you then want to leverage the fact

00:34:05.430 --> 00:34:10.560
that you have business logic in your EOs,
there are facilities to turn that raw

00:34:10.560 --> 00:34:14.490
row into the corresponding Java class.

00:34:16.090 --> 00:34:17.840
Options.

00:34:17.860 --> 00:34:19.280
Fetch limit.

00:34:19.550 --> 00:34:22.300
Okay, so sometimes your
databases are full of many,

00:34:22.300 --> 00:34:24.500
many, many rows.

00:34:24.600 --> 00:34:26.300
One million.

00:34:27.450 --> 00:34:29.890
Thank you very much.

00:34:29.890 --> 00:34:36.540
So we can restrict how many rows that you
can fetch by specifying a fetch limit.

00:34:36.540 --> 00:34:38.900
And what's going to happen
is when EOF fetches,

00:34:38.900 --> 00:34:41.880
it's going to fetch up to that many rows.

00:34:41.880 --> 00:34:46.360
If it hits that fetch limit,
it's going to stop.

00:34:46.360 --> 00:34:50.860
And you can actually specify that you
would like to be prompted on that limit.

00:34:50.860 --> 00:34:54.080
And there are delegate methods,
which we don't cover, but delegates are

00:34:54.080 --> 00:34:56.840
covered in advanced EOF,
that you can implement,

00:34:57.230 --> 00:35:00.480
which will be invoked if
that fetch limit is reached.

00:35:01.070 --> 00:35:05.830
Sometimes you're going to come across
situations where certain users,

00:35:05.830 --> 00:35:08.340
you know, I'm the boss, I need the info.

00:35:08.340 --> 00:35:11.550
They're going to say,
I can't have a 200 limit fetch,

00:35:11.690 --> 00:35:13.460
I need every row in the table.

00:35:13.460 --> 00:35:17.420
So you can either programmatically
alter this fetch limit,

00:35:17.420 --> 00:35:21.260
or alternatively provide an
additional fetch specification

00:35:21.260 --> 00:35:22.680
that doesn't have the restriction.

00:35:22.680 --> 00:35:25.830
And then in your application code,
you can make determination

00:35:25.830 --> 00:35:28.830
based on privileges or whatever,
which fetch specification

00:35:28.900 --> 00:35:30.090
is going to be invoked.

00:35:31.810 --> 00:35:34.920
perform deep inheritance fetch.

00:35:34.920 --> 00:35:39.050
When you are modeling
inheritance in Modeler,

00:35:39.060 --> 00:35:43.340
as we've already seen,
you have root entities and

00:35:43.780 --> 00:35:47.870
and maybe a potentially quite deep
hierarchy down to your leaves.

00:35:48.220 --> 00:35:51.890
When you fetch that root entity,

00:35:52.240 --> 00:35:57.100
Setting this option is going to
make EOF fetch those entities and

00:35:57.100 --> 00:35:59.030
all of the subentities as well.

00:35:59.040 --> 00:36:01.580
So you're going to end up with an
array of entities which you don't

00:36:01.580 --> 00:36:02.850
really know what the types are.

00:36:02.860 --> 00:36:05.840
So you would typically iterate
over that array and perform

00:36:06.030 --> 00:36:10.840
instance of operations to determine
which actual type to cast it to.

00:36:10.840 --> 00:36:14.420
An alternative would be
to use the abstract type,

00:36:14.610 --> 00:36:19.530
the user, in our case,
and differentiate by values in the table.

00:36:21.540 --> 00:36:22.410
Fetch distinct rows.

00:36:22.410 --> 00:36:23.980
This simply uniques the query.

00:36:23.980 --> 00:36:28.560
So if you end up with duplicate rows in
the results of the fetch specification,

00:36:28.570 --> 00:36:29.330
they'll be eliminated.

00:36:32.080 --> 00:36:34.300
They're actually eliminated
with a distinct in the query,

00:36:34.300 --> 00:36:38.330
so it's not something that EUF does
when the results come back.

00:36:39.400 --> 00:36:41.820
Lock all fetched objects.

00:36:41.920 --> 00:36:46.580
OK, so if you had a one user application
and you wanted to strictly

00:36:46.580 --> 00:36:50.220
control access to the database,
then possibly you might

00:36:50.220 --> 00:36:51.780
want to lock objects.

00:36:51.860 --> 00:36:56.370
But in the W3 world,
the world we all live in,

00:36:56.470 --> 00:37:00.340
this is actually a very strict
restriction of your database.

00:37:00.340 --> 00:37:02.320
And I would advise you
actually don't do it.

00:37:02.640 --> 00:37:08.730
If you need to lock individual objects,
there is API to support that.

00:37:10.670 --> 00:37:15.810
So when EOF fetches objects
into an editing context,

00:37:15.900 --> 00:37:20.890
it keeps a snapshot of those objects,
and it builds an object graph.

00:37:21.020 --> 00:37:24.190
If a subsequent fetch goes
against the same objects,

00:37:24.270 --> 00:37:28.310
it's going to use the instances
it has in the editing context

00:37:28.550 --> 00:37:31.730
to service that request.

00:37:32.130 --> 00:37:36.260
This is a significant problem when
you have extremely volatile data.

00:37:36.880 --> 00:37:41.620
So setting refresh fetched objects
means that every time a fetch is fired,

00:37:41.620 --> 00:37:44.080
it's actually going to go to the
database and get the most up-to-date

00:37:44.080 --> 00:37:45.290
values and bring them back in.

00:37:45.300 --> 00:37:48.300
So in volatile data situations,
this is a good thing.

00:37:50.290 --> 00:37:55.220
Require variable bindings simply refers
to when we built our fetch specification,

00:37:55.430 --> 00:37:57.440
we specified two variables.

00:37:57.550 --> 00:38:00.220
One was static, one was binding.

00:38:00.420 --> 00:38:02.630
If you set this option,
the fetch specification is

00:38:02.630 --> 00:38:06.200
not going to work unless you
specify a value for that binding.

00:38:06.200 --> 00:38:08.370
If you don't,
you can just fire it and we'd

00:38:08.370 --> 00:38:10.040
end up with results of Tony.

00:38:15.910 --> 00:38:19.850
We spoke briefly earlier about
single table inheritance,

00:38:19.860 --> 00:38:22.950
but there are actually two
different types of inheritance,

00:38:22.950 --> 00:38:25.200
two other types of inheritance.

00:38:25.200 --> 00:38:29.130
The first one is vertical,
and basically this specifies that each

00:38:29.220 --> 00:38:33.790
entity in your inheritance hierarchy
is mapped to an individual table.

00:38:33.800 --> 00:38:36.470
So in our example here,
we have vertical inheritance,

00:38:36.470 --> 00:38:38.700
and you can see that we
have a person entity,

00:38:38.700 --> 00:38:41.620
and we have a professor entity,
and a student entity.

00:38:42.300 --> 00:38:48.170
And basically, every attribute which is
specific to the professor,

00:38:48.280 --> 00:38:52.260
perhaps beard quotient,
would be mapped to a

00:38:52.270 --> 00:38:54.320
column in that table.

00:38:54.320 --> 00:38:57.950
The implication of vertical
inheritance is this.

00:38:57.950 --> 00:39:02.640
If you fetch one of those leaves,
EOF is going to have to perform as

00:39:02.640 --> 00:39:06.990
many joins as there are entities
in that hierarchy to get the full

00:39:07.140 --> 00:39:10.230
attribute set to satisfy your request.

00:39:10.900 --> 00:39:15.210
So with a deep inheritance hierarchy,
vertical inheritance can pose some

00:39:15.240 --> 00:39:17.430
significant performance overheads.

00:39:17.440 --> 00:39:22.230
The other type of inheritance...

00:39:23.310 --> 00:39:25.240
horizontal inheritance.

00:39:25.360 --> 00:39:31.360
Essentially what we're saying is we
have abstract entities in our hierarchy,

00:39:31.360 --> 00:39:39.200
and our subentities are mapped to
tables which specify attributes

00:39:39.200 --> 00:39:43.980
or columns that match every single
attribute in the inheritance hierarchy.

00:39:43.980 --> 00:39:47.320
In this case you can see our
professor and our student are

00:39:47.320 --> 00:39:50.100
mapped to two individual tables.

00:39:50.220 --> 00:39:53.100
Now this has better performance
than vertical inheritance,

00:39:53.200 --> 00:39:54.960
but it does have a maintenance overhead.

00:39:54.960 --> 00:39:59.170
If you change attributes
in that root entity,

00:39:59.170 --> 00:40:03.020
you're going to have to change
the model for both or all

00:40:03.450 --> 00:40:04.600
of the inherited entities.

00:40:08.260 --> 00:40:09.350
Okay, I'm spent.

00:40:09.380 --> 00:40:14.340
So I'll now hand you over to Matthew,
who will talk about connectivity.

00:40:21.570 --> 00:40:23.760
Because he's English.

00:40:23.760 --> 00:40:24.940
I'm English.

00:40:25.030 --> 00:40:27.900
So Justin's talked about two
stratified layers of information.

00:40:27.930 --> 00:40:30.520
We've talked about information
from the database-- tables,

00:40:30.700 --> 00:40:32.400
columns, and rows of information.

00:40:32.480 --> 00:40:34.410
We've also talked about
objects you're generating with

00:40:34.410 --> 00:40:38.200
attributes and relationships,
all sorts of API to manipulate them.

00:40:38.200 --> 00:40:40.630
These actually correspond to
two stratified layers in the

00:40:40.630 --> 00:40:42.250
Enterprise Object Framework layer.

00:40:42.350 --> 00:40:44.100
If you look in the Java doc,
if you look in the API,

00:40:44.100 --> 00:40:47.470
you'll note that there are two packages,
one for EO access,

00:40:47.690 --> 00:40:50.130
which is the lower layer,
and one for EO control,

00:40:50.190 --> 00:40:51.800
which is the upper layer.

00:40:51.840 --> 00:40:54.300
There's a piece of technology,
which is the EO adapter,

00:40:54.320 --> 00:40:57.400
that allows you to bridge this layer,
to take information from one layer to

00:40:57.400 --> 00:40:59.600
the next and move it back and forth.

00:40:59.760 --> 00:41:04.820
The EO adapter basically allows EOF to
talk back and forth to your database.

00:41:05.570 --> 00:41:06.990
Most developers,
when you're working with objects,

00:41:06.990 --> 00:41:08.640
you're working in an editing context.

00:41:08.740 --> 00:41:10.960
You're working in part
of the EO control layer,

00:41:10.960 --> 00:41:13.540
which has underneath it an
object store coordinator.

00:41:13.650 --> 00:41:15.040
Figures out where the
information comes from,

00:41:15.040 --> 00:41:17.500
how to manage it, how to keep it unique.

00:41:17.620 --> 00:41:19.460
Underneath that,
slightly underneath that,

00:41:19.560 --> 00:41:21.300
is something called
the EO database layer,

00:41:21.380 --> 00:41:24.100
which has a number of different pieces,
a context and a channel,

00:41:24.100 --> 00:41:26.500
which represents a single
connection to a database,

00:41:26.500 --> 00:41:29.000
a unique connection to a database.

00:41:29.110 --> 00:41:31.150
Underneath that layer, though,
is a composite layer

00:41:31.150 --> 00:41:33.640
of adapter information,
a context and a channel,

00:41:33.710 --> 00:41:37.400
in addition to a concrete
EO adapter that bridges that gap.

00:41:37.400 --> 00:41:40.120
Actually, the database layer is
the intermediary layer,

00:41:40.260 --> 00:41:43.530
basically between the editing context,
where you want to work with your objects,

00:41:43.640 --> 00:41:45.140
and then the database,
where we need to convert

00:41:45.140 --> 00:41:48.940
that information to rows,
columns, tables, information, and such.

00:41:49.070 --> 00:41:52.210
And your relational
database arrives underneath.

00:41:53.210 --> 00:41:55.280
So what we have is we
have the JDBC adapter.

00:41:55.280 --> 00:41:56.880
We say the adapter.

00:41:56.880 --> 00:42:00.170
In versions of WebObjects Priority 5,
we had multiple adapters.

00:42:00.180 --> 00:42:04.260
We had individual adapters for
particular database vendors using

00:42:04.400 --> 00:42:05.630
their native client libraries.

00:42:05.640 --> 00:42:09.120
What we have now is a JDBC adapter,
which uses a standard API,

00:42:09.120 --> 00:42:12.580
writing back and forth to JDBC to
do all of our database connectivity.

00:42:12.580 --> 00:42:15.690
We obviously realize that there
are database vendors and specific

00:42:15.710 --> 00:42:17.320
specifications that need to be altered.

00:42:17.320 --> 00:42:20.640
Not everyone will play in the same
space or play nicely with JDBC.

00:42:21.430 --> 00:42:23.620
So to alter that,
to have vendor-specific behavior,

00:42:23.620 --> 00:42:27.110
there is a JDBC plug-in to allow
us to implement specific features

00:42:27.120 --> 00:42:30.990
or vendors to alter the specific
implementation to suit their needs.

00:42:33.150 --> 00:42:36.540
Part of the adapter, as we saw before,
was a connection dictionary.

00:42:36.620 --> 00:42:39.410
Connection dictionary is basically the
information that tells the adapter where

00:42:39.410 --> 00:42:41.710
the database is and how to get to it.

00:42:41.740 --> 00:42:44.830
There's some required information and
there's some optional information.

00:42:44.860 --> 00:42:46.990
Required information is
username and password,

00:42:46.990 --> 00:42:48.940
which may or may not
be used by a database,

00:42:48.940 --> 00:42:52.410
but most specifically the JDBC URL,
which tells the adapter

00:42:52.420 --> 00:42:55.380
where the database is,
protocol, subprotocol,

00:42:55.380 --> 00:42:56.800
how to connect to it.

00:42:56.830 --> 00:42:59.610
Optionally, there's a plug-in and driver
information that can be specified

00:42:59.610 --> 00:43:01.030
in the connection dictionary.

00:43:01.030 --> 00:43:04.820
While we say here that it's optional,
it's actually, if not provided,

00:43:04.820 --> 00:43:08.870
derived from the JDBC URL,
which we'll see in just a second.

00:43:09.780 --> 00:43:13.920
An example of a JDBC URL in
a generic form is JDBC,

00:43:14.100 --> 00:43:16.600
the main protocol,
followed by a subprotocol,

00:43:16.600 --> 00:43:18.860
followed by the data source.

00:43:18.920 --> 00:43:21.380
In the example of Oracle,
you'll see that the Oracle and

00:43:21.510 --> 00:43:23.260
Thin is the subprotocol.

00:43:23.350 --> 00:43:26.930
Afterwards, the data source is
recognized by a host name,

00:43:27.080 --> 00:43:30.760
the port number,
and the SID for the particular database.

00:43:30.830 --> 00:43:33.360
In the case of OpenBase,
they just use OpenBase and something

00:43:33.360 --> 00:43:37.460
that looks like the URL to the database,
which is just the machine and instance

00:43:37.460 --> 00:43:38.990
name for the particular database.

00:43:41.410 --> 00:43:44.710
The JDBC plugin, as I said before,
customizes the behavior of the adapter,

00:43:44.720 --> 00:43:47.330
allows us to customize
different information based

00:43:47.330 --> 00:43:49.400
on the particular vendor.

00:43:49.410 --> 00:43:51.700
If not provided in the
connection condition area,

00:43:51.700 --> 00:43:53.900
it's guessed by looking
at the subprotocol,

00:43:53.900 --> 00:43:57.290
looking at the piece of the subprotocol,
basically capitalizing the first

00:43:57.290 --> 00:43:59.180
letter and adding "plugin" to the end.

00:43:59.250 --> 00:44:01.240
So in the case of Oracle,
you would get capital

00:44:01.240 --> 00:44:02.900
"O" for Oracle plugin.

00:44:03.000 --> 00:44:06.820
It is also assumed that if not provided,
the package name is as provided,

00:44:06.910 --> 00:44:09.300
comwebobjectsjdbcadapter.

00:44:09.420 --> 00:44:11.430
So you need to take that in
mind if you are going to work

00:44:11.430 --> 00:44:13.300
on your own custom adapter.

00:44:13.620 --> 00:44:17.300
There are some ways to specify
your own plugin information.

00:44:17.300 --> 00:44:19.670
Obviously, you could put it in the
connection dictionary.

00:44:20.110 --> 00:44:22.800
There's also API,
set plugin name for subprotocol,

00:44:22.800 --> 00:44:24.800
where you can specify a specific one.

00:44:24.800 --> 00:44:28.300
And lesser known is the fact that you
can specify it in Java properties.

00:44:28.530 --> 00:44:30.700
There are two properties you can set,
one which lists all the

00:44:30.700 --> 00:44:33.470
subprotocol information,
and then one which lists for each

00:44:33.530 --> 00:44:36.300
subprotocol the JDBC plugin to use.

00:44:36.440 --> 00:44:39.300
This is all in the API documentation
for the JDBC adapter.

00:44:39.300 --> 00:44:40.660
so it's easily referenced.

00:44:43.010 --> 00:44:46.240
The driver is also guessed
by the JDBC plugin.

00:44:46.240 --> 00:44:48.080
You can override this in
the connection dictionary.

00:44:48.140 --> 00:44:50.140
As seen here,
you'd want to specify the Oracle driver

00:44:50.140 --> 00:44:51.800
if you needed a special one.

00:44:51.890 --> 00:44:55.020
It is also assumed that the driver
is somewhere within your class path.

00:44:55.150 --> 00:44:58.250
So if not in a standard
location like libExt,

00:44:58.350 --> 00:45:01.310
you need to specify
it in your class path.

00:45:01.430 --> 00:45:05.050
One quick way to figure this out is when
it starts up and you can't do anything,

00:45:05.050 --> 00:45:06.570
this is probably the case.

00:45:08.270 --> 00:45:10.640
In EOModeler,
you'll note that there are some options

00:45:10.860 --> 00:45:12.890
for modifying adapter information.

00:45:13.040 --> 00:45:16.600
You can either switch the adapter
or set information on the adapter.

00:45:16.700 --> 00:45:18.900
While they seem somewhat the same,
there's actually very

00:45:18.900 --> 00:45:20.560
distinct differences.

00:45:20.710 --> 00:45:23.640
Switching the adapter has
the notion of actually asking

00:45:23.640 --> 00:45:27.070
you to pick a new adapter,
filling out the connection information,

00:45:27.090 --> 00:45:29.070
and actually after you do that,
underneath it's actually

00:45:29.130 --> 00:45:30.360
going and updating the model.

00:45:30.360 --> 00:45:33.490
If the external types have changed,
if anything specific to the

00:45:33.490 --> 00:45:36.540
driver or anything has changed,
the model will be updated.

00:45:36.610 --> 00:45:38.900
If you just set adapter info,
all you're doing is altering

00:45:38.900 --> 00:45:40.180
the connection information.

00:45:40.310 --> 00:45:43.910
So the model is assumed to have the same
database type and the same information

00:45:43.940 --> 00:45:45.600
that's still specified in the model.

00:45:45.680 --> 00:45:48.800
So if you are switching database
types or rather specific drivers,

00:45:48.890 --> 00:45:50.570
you want to make sure
you switch the adapter,

00:45:50.570 --> 00:45:52.930
not just set the information.

00:45:54.970 --> 00:45:58.300
So new in WebObjects 5
is now a JNDI adapter,

00:45:58.320 --> 00:45:59.810
which is much like JDBC.

00:46:00.080 --> 00:46:03.240
It's a generic adapter to talk to
a specific kind of information.

00:46:03.300 --> 00:46:04.900
We're not talking about
relational database now.

00:46:04.900 --> 00:46:08.150
We're talking about Java's
naming and directory interface.

00:46:08.160 --> 00:46:11.710
Standard API, much like JDBC,
and there are a number of examples

00:46:11.710 --> 00:46:13.500
of JNDI systems you can talk to.

00:46:13.500 --> 00:46:16.500
LDAP, NetInfo, DNS,
providing the methods to connect

00:46:16.570 --> 00:46:18.400
that into your application.

00:46:18.400 --> 00:46:21.640
Obviously, there are ways to connect to
some of these things outside

00:46:21.640 --> 00:46:22.900
of an adapter context.

00:46:22.900 --> 00:46:25.380
There are probably much easier
ways to get DNS information

00:46:25.400 --> 00:46:27.150
than creating a JNDI adapter.

00:46:27.160 --> 00:46:29.190
But this is very useful when
you'd want to model this

00:46:29.190 --> 00:46:30.700
somewhere in your application.

00:46:30.700 --> 00:46:33.920
If you have people in LDAP that
you want to model into another

00:46:33.920 --> 00:46:37.060
database or connect into a model
of another database or the like.

00:46:37.160 --> 00:46:40.050
So it provides you with the
ability to model this much like

00:46:40.050 --> 00:46:43.660
you would relational data and
provide that into your application.

00:46:44.100 --> 00:49:03.800
[Transcript missing]

00:49:06.400 --> 00:49:08.180
More than me.

00:49:08.350 --> 00:49:10.500
Actually, for information on the
Relative Distinguished Name,

00:49:10.500 --> 00:49:13.620
you should look in the
API documentation for the LDAP plugin.

00:49:13.760 --> 00:49:15.430
It's actually spelled
out very specifically,

00:49:15.470 --> 00:49:17.530
but there are some
important nuances to it.

00:49:17.660 --> 00:49:21.260
Unlike with the JDBC adapter,
we don't know how to create--

00:49:21.360 --> 00:49:23.140
This would be considered a primary key.

00:49:23.350 --> 00:49:26.860
We don't know how to create a Relative
Distinguished Name for you by default.

00:49:26.860 --> 00:49:28.600
It could be a composite of information.

00:49:28.680 --> 00:49:31.560
It's also domain information that's
specific to your LDAP system.

00:49:31.670 --> 00:49:33.940
So there have to be ways to
provide this information,

00:49:33.940 --> 00:49:36.950
to set this as a primary key if you
wanted to actually insert a row or

00:49:37.010 --> 00:49:39.780
create rows in your LDAP system.

00:49:39.930 --> 00:49:44.080
One way to do it is to include
the attribute as a class property,

00:49:44.140 --> 00:49:46.330
which I know Justin said we shouldn't do,
but in this case,

00:49:46.390 --> 00:49:47.390
it's actually okay to do.

00:49:47.530 --> 00:49:51.580
You could create APIs and some
programmatic way to set that information.

00:49:51.700 --> 00:49:55.500
An additional way, though, is to specify,
as we said before, a write format.

00:49:55.620 --> 00:49:58.630
Instead of specifying SQL as you
would with a normal data source,

00:49:58.740 --> 00:50:01.480
you would specify a format where,
in this case, if we wanted our Relative

00:50:01.480 --> 00:50:05.100
Distinguished Name to be,
for example, RCN, our common name,

00:50:05.100 --> 00:50:08.500
we would just specify CN equals,
and then we use a greater than

00:50:08.500 --> 00:50:11.830
and less than sign notation
to specify an attribute within

00:50:11.830 --> 00:50:13.500
the context of this entity.

00:50:13.500 --> 00:50:15.430
So in this case, we could specify CN.

00:50:15.540 --> 00:50:18.630
That would write physically the
string CN equals whatever the

00:50:18.630 --> 00:50:22.520
value of the common name into
the Relative Distinguished Name.

00:50:22.840 --> 00:50:29.210
There are some differences between
object representations in JNDI and JDBC.

00:50:29.480 --> 00:50:32.380
You'll note that every single
entity in this particular model has

00:50:32.540 --> 00:50:34.700
an attribute called object class.

00:50:34.700 --> 00:50:36.120
It is not a class property.

00:50:36.200 --> 00:50:37.690
It's not a primary key.

00:50:37.700 --> 00:50:40.700
It's a string that represents
the object class of an object

00:50:40.700 --> 00:50:42.700
or an entity within LDAP.

00:50:42.700 --> 00:50:44.770
This is kind of like
an object within Java,

00:50:44.770 --> 00:50:45.700
but a little bit different.

00:50:45.700 --> 00:50:48.690
The inheritance hierarchy
is a little bit different.

00:50:48.700 --> 00:50:52.760
You only actually obtain attributes
from the parent in certain cases,

00:50:52.770 --> 00:50:53.690
and it's important to note.

00:50:53.700 --> 00:50:56.700
But other than that,
everything in the JNDI models

00:50:56.700 --> 00:50:59.660
works exactly the same as
it would in a JDBC model.

00:51:05.320 --> 00:51:08.240
That's actually all the information we
had on-- specific on the two models,

00:51:08.240 --> 00:51:11.740
the two types, adapters,
and the model that Justin had.

00:51:11.740 --> 00:51:14.400
If you guys want more information
on the WebObjects Beta or

00:51:14.400 --> 00:51:16.990
be considered for the Beta,
there is information on the

00:51:16.990 --> 00:51:19.400
Appleseed site for accessing that.

00:51:19.410 --> 00:51:22.260
We still do have the WebObjects Lab for
the rest of today and all of tomorrow.

00:51:22.260 --> 00:51:25.690
If you have questions to be
asked on these topics or any

00:51:25.740 --> 00:51:28.680
other topics about WebObjects.

00:51:29.200 --> 00:51:31.770
If you have any questions
specific on EOF that we didn't

00:51:31.850 --> 00:51:34.470
cover or more information on
topics that we covered here,

00:51:34.560 --> 00:51:37.590
you can either ask Justin or I or
probably more specifically stay

00:51:37.680 --> 00:51:44.070
for the session afterwards where
they may cover some of these topics

00:51:44.070 --> 00:51:44.070
in more detail as well as come
to the feedback session tomorrow.

00:51:44.420 --> 00:51:47.280
and the standard list of
contact information for people

00:51:47.340 --> 00:51:49.940
if you have questions outside
of what we can answer here.

00:51:49.960 --> 00:51:51.940
Yeah, it is Bob.

00:51:53.070 --> 00:51:54.820
And for more information,
there's documentation

00:51:55.090 --> 00:51:56.960
on a number of websites,
tech support,

00:51:56.990 --> 00:52:01.290
as well as mailing lists you
can subscribe to for more info.
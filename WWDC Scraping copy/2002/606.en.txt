---
Title:  QuickTime for the Web
Year:   2002
Web:    https://nonstrict.eu/wwdcindex/wwdc2002/606/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Good afternoon. Welcome to your session 606. This is QuickTime for the Web. And let me get this out of the way right away. This is the book QuickTime for the Web. And if you put QuickTime on web pages, you need this book. So you can get it at Developer Depot. You can get it from the Apple Store, from Amazon.com. But believe me, it will help you with things that you're doing.

I'm Steve Gulie. I'm the senior technical writer and multimedia web monkey for Apple in the QuickTime group. And we're going to talk about QuickTime and how it works for web delivery, mainly HTTP. And we'll be looking at different parts of QuickTime, not just the API, as most of you have been working on all week, but at the Plug-in, the ActiveX control, QuickTime Player, and the QuickTime file format.

And we'll be looking at HTML, the tags and extensions you'll be using, and scripting mainly, client-side scripting in JavaScript and server-side scripting, you know, CGI, SSI, PERL, Python, whatever you're And we're going to cover a number of things today. When we look at the tags and extensions, we'll look, of course, at just embedding QuickTime movies in a web page, but also at detecting QuickTime with JavaScript or with QuickTime itself, launching QuickTime Player from a web page, going full screen, look at some differences between the plug-in and the player, the QuickTime file format and how you can use it effectively on the web, ways to create web movies dynamically from a script, and how to script the plug-in in the ActiveX controller. And finally, we'll look at some wired actions and server-side scripts. And hopefully most of this stuff will run, but bear with us.

So in HTML, the main way you put a QuickTime movie in a web page is with the embed tag. And you can just link to it, but we'll talk about that a little more later. The embed tag was originated by Netscape. They invented it to display kinds of media that their browser wasn't capable of displaying natively. And they had it in mind that you would basically invent a new media type and write a plug-in, and they would install it. And when they came upon that media type, they go, oh, if they have a plug-in to play this, we'll use that.

So they gave you three things that you could tell them-- the source, the file that you wanted to play, the type, in case the server didn't know it, the MIME type, and the plugins page, where to get the plug-in if you didn't have it. And that seemed adequate.

And then it said any other parameters you want to pass to your plug-in, just put them in here, and we'll pass them along. The problem with it was that you didn't anticipate today's world, where you have MP3 files, and you've got 10 plug-ins that can all play MP3. So which one do you use? There's no way to specify which one you want.

But here's the embed tag, and here's what it looks like. You get a height and a width, and that's all the space you have. You can't go any bigger than that. Tell it what file you want it to play, what the type is. And the type, of course, should always be video quick time for a movie. And the plugins page should always be Apple quick time download.

And any other parameters you want to pass. I'm not going to go into detail about all the embed tag parameters today, but they're on the website, and there's quite an extensive list. You can make movies autoplay, loop, play double size, half size, do a lot of interesting things. So be sure and check that out.

As I said, it depends on the MIME type. So the problem here, as I mentioned, was if you just pass the MIME type, how does the browser know which plugin to use? Well, if the MIME type is application QuickTime or video QuickTime, you would think it would use the QuickTime plugin. But other plugins have, at times, registered to use that MIME type.

So in order to prevent hijacking by -- by hijacking, what I mean is Windows Media Player, for example, an older version, might think it can play your QuickTime movies. So you say embed this movie, and instead of using the QuickTime player, it tries to bring it up in Windows Media Player, and it can't display it. So you don't want to have that happen. And what we do is we have a tag called QTSource. Let me back up here. The source goes to the browser.

So it's going to load that file, and the QT source tells the QuickTime Plug-in, "Well, okay, you loaded that file, but what I really want to do is display this other file." And that gets around the MP3 problem. You want to play an MP3 with QuickTime Player or a QuickTime Plug-in, pass a MIME type that QuickTime understands, that only QuickTime understands, the browser calls QuickTime, and then tell QuickTime, "Play this MP3 file." And I'll show you what I mean. Can we go to demo one here? Can we switch the screen? Thank you. Okay. Let's take a look at that.

Here we've got a movie and we've used Qt source to fix that limitation of embed. What we've said is embed, set the width and height, and set the source to a QuickTime image file, which only QuickTime is registered to play, and set the plug-ins page, of course, always to QuickTime download. But the Qt source is this movie.

So the browser sees that you want to load a QuickTime image file. No one registers for QuickTime image files besides QuickTime. So if you don't have it, it gets it. If you do have it, it loads it. QuickTime looks at the QuickTime source and says, "Okay, play this movie." Now one significant point here, and of course we can pass autoplay equals true and set the volume in case it turned it down low because it's a loud movie.

The source file must actually exist because the browser is going to download it. And the source should be a QuickTime file, a MIME type that only QuickTime uses, such as movie, video QuickTime, although this has been hijacked in the past. ImageMechPaint, I promise you, you know it. no one will ever take that.

QuickTime image file, no one has ever taken that either, and I don't think they will, or a QTL file application in the X QuickTime Player, although this is a new one, so your server may not know about that yet. So probably the best choice all in all is the QuickTime image file format.

Just to show you we can play an MP3 in QuickTime Player. This is how you play movies, things that are not QuickTime movies, in a browser with QuickTime Player. Pass a QuickTime image file, and you can make a QuickTime image file by opening any kind of image that QuickTime can open. GIF, JPEG, anything, and saving it as a QuickTime image.

It's really simple, and it could be a one-pixel GIF. It doesn't have to be anything significant. And then in QTSource, you pass whatever file QuickTime can play. The browser doesn't see this, only QuickTime does, and then you can do things with it with the QuickTime plugin. Any questions about that? Is that straightforward? Okay, good.

Okay. Theoretically, what will happen if the person doesn't have QuickTime is the browser will look at the Plug-ins page and say, "Oh, would you like to get the browser? You don't have a Plug-in for this. Would you like to get it?" And if you say yes, it should take you to that page. And that doesn't always happen, and I'll get into that in a moment. But it should. Get back to slides, please.

Now, the embed tag works with plugins. It also works with ActiveX controls, which many people don't know. If you have QuickTime and QuickTime ActiveX, it works just fine. That machine has QuickTime ActiveX. No, it doesn't. It's a married Mac OS. Sorry. It works fine on Windows. If you have QuickTime and the QuickTime ActiveX control, latest version of QuickTime, you can use the plugin tag and it works great. It's supported by all current browsers, Mac OS and Windows. They all work with the embed tag just fine.

There is one problem, i.e. for Windows 5.5 SP2 and later, ignore the plugins page tag. Because it's not a Plug-in, it's an ActiveX control. So if you have QuickTime and ActiveX, it works great. But if you don't, it doesn't offer to get it for you. It just says, "I don't know what to do with this." And that's not good.

So, one way to solve that is to use the object tag. Now, the object tag was designed for plugins, ActiveX, and other things. It's meant to be very forward-looking. It's a W3 standard. And they kind of went round and round about this. But they finally decided they were going to settle on the object tag rather than the embed tag.

But it basically duplicates the embed tag's functionality. It has most of the same characteristics. And for a brief Halcyon day, I think maybe three months, you could actually run the object tag. And it worked the same on Netscape, Internet Explorer, Mac, and Windows. It was great. But then they added some Microsoft-only extensions and kind of changed how it behaves on Windows.

But there are some wonderful things about these extensions. You can specify the class ID and code base of the ActiveX control. So there's none of this ambiguity about, well, who gets this file? It's an MP3 file. Who wants it? Who registered for it last or first? You say, I want to use this particular ActiveX control. And if it's not there, here's where I want to get it. It's got a class ID which says who it is, a code base that says where it is. So that's nice. It only works with ActiveX controls, so it doesn't work on Mac OS.

or Netscape plugins, and it only works on IE4 and later on Windows. So obviously there are some limitations there, but here it is. It's great if you're running Explorer on Windows. This is the class ID and code base for QuickTime. It should always be set to that. And the syntax is very similar to Embed, but it's a little different. You've got a height and width, in this case the class ID and code base, and that's all you put in the object tag.

Then you have a bunch of param tags. So you have a param for the source, whose name is source, and whose value is where you want to go, what file you want to show, and any other names. Let me back up a couple slides here so you can see the embed tag syntax. Here we have source equals something, other equals stuff.

And we go here, we have name equals source, value equals something, name equals other, value equals stuff. So all your parameters work that way. You just take what's on the opposite ends of the equal side in the embed tag, and one is the name, the other is the value.

Okay, so the embed tag works for IE Windows 5.5 plus. Okay. It ignores the Plug-ins page in that situation. And it's subject to hijacking. The object tag prevents hijacking and works only in an -- oh, you're just using BULB. What does that look like? Well, it looks like kind of a mess, but it actually works. You set the object tag up, give the class ID and code base.

Now Internet Explorer 5.5 and later for Windows, actually 4 and later, will use this ActiveX control only. If it doesn't have it, it knows where to go and get it, and it will download it automatically. It's even nicer than the plugins page. And if they're using something else, using a Netscape browser or a Mac OS, then the embed tag kicks in, and it works.

You can go ahead and continue to use the plugins page and type and everything else. And you just have to remember to close it carefully. When you get to the end of it, notice there's a close embed at the end of the embed tag. That's not necessary if you're just doing embed, but if you're putting it inside of an object tag, it is. And this thing will work on all browsers and all platforms, and it's actually pretty nice. So if we go back to the demo machine, we'll take a look at that. And... Here we go.

In this case, we've got the movie in here, and this is what it looks like. "That's not formatted just the way I want, so let me make it a little wider so you can see it a little better. There we go. Come on. Okay. You've got your object tag.

For AMs for the source, that's a movie you want to play, anything you want to pass to QuickTime, And then inside the object tag you have an embed tag with its type, its source, the QT source, again height and width, the plug-ins page. And it all works together and it all plays very nicely and it works on all operating systems and all browsers that I know of. There's some things that you can notice about this that are semi-useful. QT source, you don't need it in the object tag because the object has a class ID.

So you don't need to tell it, you don't need to, if you want to play an MP3 file using the object tag, you just say, hey, use this plug-in to play this file. You don't have to go through the song again and say, well, this is the file I want. No, this is the file I really want.

"It just works. So when you're doing that translation, you don't have to translate those things. You can just translate everything and it works fine. But if you want to simplify your life a little bit, you can go ahead and point to the file you want in the object tag and only do the dance around in the embed tag." And if you do that, the QT source for the embed tag points to the same place as the source for the object tag. Does this make any sense? Okay.

I know I'm going a little fast here. All right. Well, that's how that works, and believe it or not, it actually does work. So if you go back to slides, Just to go into this a little further, suppose you don't like that big ugly thing. You say, well, look, do I really have to do that? Do I have to put the embed tag inside an object tag? No. No, you don't.

Once the user has QuickTime and the ActiveX control, everything works fine. The embed tag works great, so you don't have to surround it with the object tag every place it occurs. You could just surround the first occurrence of it on your entry page. And if the user doesn't have QuickTime, the object tag kicks in and says, oh, or they have QuickTime, an older version, but they don't have the ActiveX.

It'll say, do you need it? You want it? Go get it, and it'll fetch it, and then it has it, and the embed tag works thereafter. So if you have a gateway where everybody comes through this entrance page, you can just put it on the gateway, and that takes care of it.

But, you know, we're in a world where people do Google searches and jump to the middle of your website in a lot of cases. And if that's the case, where people can just jump into the middle, then the gateway isn't good and you really should wrap a bunch of your tags. Fortunately, there are applications that will do it for you. I think that GoLive now does it automatically. Maybe Dreamweaver, too, at this point. There are freeware, shareware applications that will do it for you. You don't have to go through and do it all by hand. Okay.

Now, if you're an applications developer and you're generating HTML, you're working on Go Live or whatever, we recommend that you create both object and embed tags by default. You know, you've got the software, just grind it out and make the big tag. You may want to allow the option to use the embed tag only if a script is used to detect Internet Explorer for Windows and QuickTime ActiveX.

And the reason you might want to do that is, If you don't have QuickTime and you hit the object tag, the browser will go -- the Explorer will go, "You need the QuickTime ActiveX control. Here it is. You want me to go get it?" If you're making a website for somebody who doesn't want that to happen, they say, "Look, QuickTime is great, but that's not the center of our focus here.

We're trying to sell shoes." If they have QuickTime, they can see the VR of the shoe. If they don't, we don't even want to talk about it. We just want to show them the JPEG of the shoe. In that case, you don't put the object tag in. You just use the embed tag.

And you can use JavaScript to test to see if QuickTime is there and direct them one way or the other. And I'll show you how that's done. It works pretty well. So you can prevent that download from happening if you want to. Usually it's a good thing. Usually if the user doesn't have QuickTime, you want them to get it.

But if you're in that situation where you don't want people to be hit with a download balloon, you can avoid it. Okay, and I'm going to pass on some of these things. I already talked about it. There is one thing I should mention, which is QT source, don't use browser. We couldn't think of a longer tag name, so we used that.

normally the QuickTime plugin uses the browser to load files. If you say use this file and then at the end of it get another file or if somebody clicks on the movie get this other file, the QuickTime will ask the browser to fetch that file for it and then do what it needs to do.

Sometimes you don't want to do that. Suppose you have a live stream, RTSP protocol. If you put a URL in your file that says embed something something RTSP, a lot of times the browser will go okay, RTSP protocol, that's a weird one, I'm going to use a special program to handle that.

I'll give that to real or I'll give that to Windows. I don't even want to look at the source. I've got a URL here. So if you're embedding a URL that's got a RTSP protocol, you really want to use the QT source rather than the source and say QT source, don't use browser, let me get it. That means QuickTime will get the QT source file using its own internal data handlers.

Another case where you would want to use that is if you're embedding your content on a CD-ROM. You notice that in this browser it tries to load the data off the CD-ROM into a hard disk on the cache and then play it out of the cache. That's no good. That's not what you want because the system just gets swamped with the high bandwidth movie.

It's trying to read it from the CD-ROM, write it to the hard drive, read it from the hard drive and display it all at the same time. It just runs out of steam. Don't use the browser. QuickTime will just read it directly from the CD and it'll work great.

It's a little workaround that's sometimes very handy. Okay, speaking of URLs, of course HTTP is the standard way you get things over the web, but a lot of people don't realize that QuickTime can also handle URLs that are FTP, RTSP, RTP, file protocol. There's a minor problem, well, it's not minor, but it's there in QuickTime Player on OS X.

You can't load a file directly from the browser into the player on this version of OS X that you have on Jaguar, because there's a link broken. It's got the file protocol, the path name is broken. So you have to use an HTTP URL to play with it, but I'm pretty sure that, well, maybe it'll be fixed by the time we release it. If it's not, be aware of it.

Actually, I'm going to ask a question of one of my audience members. Can we handle HTTPS, secure HTTP? No, okay. Okay, and here's the URL protocol you probably haven't heard of, the data protocol. That's where you're actually going to put the data inline in your movie. And every once in a while this is useful. And if we can switch over to the demo machine.

I'll show you what this looks like. It's kind of wacky. This is a little bit small. Welcome to WWDC. And what we've done here that's odd is we haven't really embedded a movie that's a file or a stream or on the web. We said embed, set the width and height, give it a source so that it would call QuickTime, set the plugins page because that's a good thing to do. And then we said the QT source is data colon mime type, in this case text plain.

And then, comma, and then, something we would ordinarily have put in a file. TextText, which is an Atom hack that I'll show you later, and the text Welcome to WWDC. So, this made it, it built a QuickTime movie on the fly out of data that was actually inside the embed tag.

If we wanted to, we could have put a JPEG in there, but it would have had to have been Base64 encoded. Anything that won't fit between these quotes, anything that's got angle brackets or quotes in it or really, really odd characters should be Base64 encoded. And I wouldn't go crazy with this, but every once in a while it can turn out to be a lifesaver when you've got something in your work process that says, no, this needs to happen inside the HTML. I can't be getting another file right now. So it's something to be aware of.

When you load URLs in QuickTime, this includes the QT source or if there's an HREF, any time there's a URL inside the tag that you're passing to QuickTime, the QuickTime plug-in knows the URL of the movie that it's playing right now. It doesn't know the URL of the web page it came from because the browser doesn't tell it.

So any URL that's a rel-- if it's an absolute URL, that's great. But if it's a relative URL, it has to be relative to the movie that is currently loaded. And this will bite you many, many times if your movies are in one directory and your HTML is another.

If you load the movie, if there's an href in that movie, even though it's in your embed tag in your HTML, it's relative to the movie that's currently loaded. And if you're Here's a relative URL. Up a folder, into the movies folder, go to the next movie. Sure. But what if you loaded a data URL? What is that relative to? Don't do that.

and that's really all there is to that. We go back to slides. Another kind of URL that you can send from QuickTime is a JavaScript URL, open with the JavaScript protocol. And believe it or not, QuickTime will call JavaScript, and you can call functions. You can pass parameters. And it's true that JavaScript can't control QuickTime in all browsers and all platforms. There are some obstacles there. But going the other way works all the time. You can call a JavaScript URL from within QuickTime.

So your movie, you click here, it can cause a JavaScript function to execute, open a new window, load another movie, do all kinds of things for you. Once in a while, you'll have a problem with browsers that just have difficulty with JavaScript. If you run into a problem where you can't do it that way, you can load an HTML file that's in a hidden frame, maybe two pixels by two pixels, that has the JavaScript in it and executes on load. And that always works. But really, in current browsers and current operating systems, the JavaScript URL should just work.

Finally, there's one thing you would probably like to know, which is that you can pass a URL with a target in QuickTime and with embed tags. So let's say I've got a movie that's looping continuously with no controller. And when you click it, I want to load another movie. But I don't want it to load with a controller in play. I want it to load and run continuously in a loop.

So I can say URL -- oops -- is the movie I want to run. The target is myself loaded here and extra there are additional embed tags. AutoPlay equals true, loop equals true, controller equals false. Anything you can put in the embed tag you can stick in the e tag.

And this is a really nice thing. This lets you have movies that behave differently in the browser. You really only have one embed tag, right? So you can only put in one set of protocols. Do you want controller or don't you? Do you want it to loop or don't you? But if you're doing a series of movies you might want them to behave differently. The VR has a controller and this one doesn't. So you can actually link them with this and pass the embed tags along to the next guy in the parade. And that's pretty handy.

Okay. Speaking of embed tag parameters, like I said, I'm not going to go over all of them. Most of them are there, and they just control how the movie looks and acts and plays. But there are a few that people don't know about. One is save embed tags, which says -- it's kind of like passing the E and saying, "Everything they did to me, do to the next guy.

Whatever. Pass it along." And that's really handy because ordinarily when you load a new movie, it comes up with a controller. If you don't want it to have one, if you want it to have the same characteristics as the current movie has, save the embed tags, pass them along.

A far more complicated one is allowing BedTag overrides, where you're saying, "It's been set one way. I'm going to now set it a different way." And why would you want to do that? Well, there's kind of a hierarchy. If I load a movie and I don't specify autoplay, the user has preferences. Movies either autoplay or don't, depending on how he set his preferences. But if I set autoplay to be true in my HTML that overrides the user settings.

Well, there are other places I could try to set it that would also have an effect. And it just says, kind of pushes things down in the hierarchy. And I'll show you how that actually works in a minute because it's hard to understand. Another embed tag is autoplay at. Now, up until QuickTime 5, autoplay was either true or false. You know, it autoplays or it doesn't. But you probably noticed that occasionally you'll go to a web page and you'll load a QuickTime movie and it'll start to play and then stop and then start up again.

And what happens, what autoplay does is it says to the movie controller, look, as soon as you can, I want you to play this movie. But don't start it until you've got enough data in the pipeline. And it's coming through that you can play it through until the end smoothly in one go.

Well, maybe things start up quickly and you're getting a lot of data and it says, hey, at this rate, we can go. And then things slow down. So it runs out of data and it starts to stutter. And it's very common right near the beginning of a file. There's a lot of stuff that's just really easy to transport. The modems compress it better. And so you get a data rate that kind of jumps and then drops off.

You can get around it this way. You can say, look, autoplay when you get to this point in the movie timeline. Make sure you've downloaded at least 10 seconds or 30 seconds of the movie timeline. And then you'll see it's going to stop. And then you can start to play it. And then you'll see it's going to 30 seconds of the movie before you start to autoplay. And we'll get past that skip. So, okay, autoplay at hours, minutes, seconds, frames. Well, not frames, fractions actually.

[Transcript missing]

And that is... Here we go. Autoplay override. And here you can actually see...

[Transcript missing]

We have set autoplay equals true. And we do that because early versions of QuickTime say autoplay equals true or false. And if it's not true or false, then I guess it must be false. If you try to set autoplay equals waka waka, that's false. I'm sorry. So we're setting it true for old versions of QuickTime. We're saying, OK, if you've got QuickTime 5 or later, though, you know what allow embed tag overrides means. So set it true.

Now what I really want, ideally, is to autoplay when it's 8 seconds uploaded because I know that won't stutter. So I've set that. Now turn it back off so the user's preferences don't take over. It's a sequence. You turn it on. You reset it. You turn it back off again. And that's typically how you use it. And the reason is here, if I just use autoplay at, if the guy's got QuickTime 5 or later, that's great. It works. If they have an earlier version, it's the opposite of what I want. It doesn't autoplay.

So I would rather have it autoplay and maybe stutter on older versions. And on newer versions, just play right. So I set it to true. Set it the old way. Turn on overrides. Set it the way I want it. Turn it back off again. There are other even crazier situations where you might want to use that. But that's probably the fundamental one.

Okay, and if we go back to the slides, and I'm just going to breeze over these very quickly. There are some embed tags that people don't seem to realize are there. So you can set a movie's name in an embed tag. You can say, load this movie and call it yada yada.

And so you can load any movie in that web page and it has that name. Once you've named a movie, you can control it from JavaScript by name. You can control it by another movie by name. So you can have a remote controller that operates on main movie, stops it, starts it, turns languages on and off, does things to it.

And any movie you load in that you name main movie, it will control. So this is a very nice way to give you some flexibility where you can put it in your HTML and just change the movie and drop it in there and it just behaves the way that the other movie did.

You can set pan, tilt, field of view, node, and hotspots where they go in your HTML. And if you're not familiar with QuickTime VR, pay no attention. But if you are, you may, "What? I can?" You can load a VR panorama looking magnified, tilted, in a node if it's multi-node, anywhere you want. You can direct where those hotspots should go, what they should link to.

You can do that in your HTML. And sometimes it's very handy. Steven Gulie Enable JavaScript. If you're going to try to control it with JavaScript, you definitely want to turn that on. And there's a URL substitute. Sometimes you've written a whole website and the customer has to move to a new server.

Or you move it to a different place on the website and you go, I don't want to do it because I embedded those tags inside the movie where they're hard to get to. URL substitute in most cases, if the URL goes through the Plug-in in the browser, will say, "Oh, I can substitute this string for that string, so server A is now server B," and it just flows through.

You don't have to go in and re-edit all the movies. You can pick it up in the HTML, and that can be really a life-saver. Okay, so I know we covered a lot of ground there. Is anybody just kind of stunned and wandering around hopelessly lost, or are we all together on this? Yeah.

Yeah, okay, yes. If I have an href, so I say embed my movie, href equals, and href means if I click on this movie, go there. So href equals, quote, angle bracket, the URL of the place you want to go, space, capital T bracket, the target, which is the frame or window you want to go to, or myself, if it's me or a QuickTime player, any target QuickTime accepts, space, E, bracket, embed tags, autoplay equals true, volume equals 120, so on and so forth.

Yeah, you would normally put it there, but you can embed it in a movie. Any place where QuickTime can send a URL, and there are lots of places, like a hotspot in a VR, you can use this. Okay. So, there are some differences between the Plug-in and the Player, and you can address them both from the web.

And the Plug-in or ActiveX control gets its data from the embed tag, which is what we've been looking at, these embed tag parameters. And it also has a plug atom, which I'll talk about the QuickTime format later if you don't know about it. But there's an atom inside. Have you ever used Plug-in Helper? Does anybody here know what that is?

Okay, plugin helper is a tool from Apple that lets you embed things into movies. Basically, put embed tags inside of movies. So, and it's free from the web. We've got it for Windows, we've got it for Mac OS. It's in the Quicktime tools and it's really a handy tool. You can do lots of neat stuff with it. So, it stores those settings, basically embed tag settings, in the plug atom. And if you have plugin helper, you can look at these settings and see what they are. But normally, you pass them to the embed tag.

And that's different from the player. The player doesn't use embed tags, right? And it doesn't pay attention to the plug atom. So, this is how the plugin is controlled, where it gets its settings from. So, basically, anything that you can pass in an embed tag addresses the capability that the plugin has.

The plugin also handles hypertext reference tracks, which are, it's a text track that has a bunch of URLs in it. So, with the automatic download feature. So, I can have a text track in a movie, and when that text sample loads, it will automatically load a URL in a web page, in another frame, typically. So, as the movie plays, these web pages are displayed, although it can also launch other movies and replace itself and do a lot of things.

That doesn't work in the player, because the plugin was designed with the thought in mind of, well, I'll be playing in a browser, so you might want to download these things at certain times. And the player doesn't currently handle that, although that's subject to change. The plugin uses the browser for downloads, so be aware of that. If you don't want things to show up in the browser cache, you might not want to load them through the plugin.

And the plugin has the ability to consistently have multiple movies open. You can have movies that talk to each other. So you can have a controller movie that talks to three other movies. And if you have a web page in the plugin, you know you can open up all four movies at once, and it'll all be there. You can't necessarily do that in QuickTime Player. The user has a preference setting, open in new player, open in same window. If they've got their system set to open in the same window, you can target four different movies to QuickTime Player, and one after another they'll load.

If they've got it set the other way, the windows proliferate. So you can do it in the plugin, and that's something that it has the capability to do that the player doesn't. The player, by contrast, gets its settings from the movie menu. Open up QuickTime Player, look in the movie menu, look at all the things you can do. Play double, play half, present movie. Those are the things that the player knows how to do.

If you've got an embed tag but no corresponding player setting, that's probably something the plugin can do that the player can't. And vice versa. Gee, I don't see an embed tag for play full screen. Well, there isn't one because the browser plugin has to play within the height and width the browser gives it. But the player can go full screen. So that's a way to predict what one can do and what the other can do. And it stores these in settings inside the movie itself, and a user data atom inside the movie atom.

And we'll look at some more at the QuickTime file format a little deeper in here. But that's where the settings are stored. So it's going to look there. It's going to look in the user data atom, not in the plug atom. And it ignores some things, as I already mentioned, the AURL. If it's a streaming Ahrefs track, the player does honor those. And the E extension to URL is not currently, well, those are embed tags, so the player is not paying any attention to them. It handles most non-HTML URLs natively.

So if you are in the movie and you load another file, another movie, typically that won't end up in the browser cache because we're bringing it in ourselves. And, of course, it has full screen modes, which are such nice things. So how do you launch the player from a web page? Well, there are two main ways to go. The most common one is a poster movie. You load a movie and you have a hypertext reference in it.

Ahrefs equals URL, and the target is QuickTime player. So notice the position of the quotes in the angle brackets. It's all very important. And what this means is we're going to load a movie, and when someone clicks on that movie, we'll go to QuickTime player and load this other movie or this URL. And the second way to do it is to launch a QTL file, but let me bring this one up on the demo and show you that.

Here we go, launch QuickTime Player. Okay. Here we are, and if you look at this, it says, "Click the image above for a movie in QuickTime Player." That's the kind of label you put on it. This is a QuickTime movie. It's displayed without a controller, and it's only a single image. There's not much to it, but when I click it, it launches the movie in QuickTime Player. So this is a way to launch QuickTime Player.

from the browser. And that's the most common way you do it. Now, if you look at the tag, it's just -- well, okay, href equals URL, target is QuickTimePlayer. If I add the tag auto href equals true, then you don't have to click the movie. When you load the Web page, QuickTimePlayer will just launch.

But typically you want to give the user some control over that, so you do it this way. The other way is to use a text link to a QTL file. And I'll bring that up in the slides in a moment. But basically this is a text link to what is essentially a text file, but when you click it, it loads whatever that URL is in QuickTimePlayer.

And that's a pretty nice thing. People have been asking for a long time, you know, "Can I launch QuickTime Player from a text link?" And now you can. However, what's happening here is you're going to load, you're telling the browser to load a QTL file. A QTL file has a MIME type of application, QuickTime Player.

So the browser says, okay, well, I'll give that to QuickTime. And the QTL file is just a little text file. It's a little XML file. It's like four lines of text which says, here's where the movie really is. So this file is going to be downloaded to your disk and handed off to the player. The URL in the file has to be an absolute URL.

If it's relative, the browser says, hey, QuickTime Player, here's this movie from this cache folder. You go to a relative URL that's relative to that cache folder, not so good. So basically, this is really hard to use on a CD. This is the one you want to use over the Internet. You want to use an HTTP URL. And let's go ahead back to the slides for a second, and we'll look a little more closely at that QTL file. The type is application X QuickTime Player.

And it starts out with the same two lines always, query XML version 1.0 and QuickTime type equals application QuickTime media link. And what happens is when QuickTime opens this file, it sees query XML and it says, wait a minute, what am I dealing with here? It sees that it's a QuickTime media link and it goes, okay, I got it.

Then it looks at the embed source. And this third line, the line at the bottom, is the one that you change. That's when you have it point to your movie rather than this movie. Basically cut and paste this file, change that, and save it with a .qtl extension. And some systems will immediately pick up a QuickTime movie icon and, you know, it looks like a movie.

You can also save it with the .MOV file extension. And it looks like a QuickTime movie, and QuickTime will treat it as one. You can embed it in a web page as a movie. So here's a thing where you've got a CGI script and you're generating text. You can generate this file out of anything that will generate text, Perl, anything.

So now you have the ability to say, embed this movie, but this movie can be anything you want it to be. You can point to anywhere, and you can generate it at runtime from a script. So you don't have to make a reference movie that you're constantly changing. You can change it on the fly. It's pretty nice.

And of course, the reason you mainly want to go to QuickTime Player is to launch full-screen movies. There are several full-screen modes, normal size, double size, half size. Full size, which means whatever the screen is, but it will try to change the screen resolution if it can to better match that of the movie so you get better playback performance. And current, which means whatever size it is now. There are a couple ways to set that mode, set it to full-screen mode.

You can either put something in the movie so that when QuickTime Player loads that movie, it knows it's a full-screen movie. Or you can have some external means of telling QuickTime Player, okay, the movie isn't a full-screen movie, there's nothing in it that says that it is, but I'm telling you to display it that way.

Internally, you can set it using the API, the QuickTime API if you're a programmer, or you have an application that will do that for you. You can use it using AppleScript if you have a... if you're running on Mac OS. And it's going to store it in this PTV atom. If you're getting down and dirty here, you're taking notes for programming. That's the print-to-video atom.

It's part of the user data atom for the movie. And it's documented in the QuickTime file format, which is on the web, set it to the right value, and by golly, when that movie opens and plays, it will play in full-screen mode. Externally, you can... Well, another quasi-internal way is there's a wired sprite action.

You can tell a sprite or a piece of text or anything in QuickTime that accepts wired actions, when I'm activated, go to full-screen, or when this set of conditions is true, go to full-screen. And I'll show you a movie later that has a little button on it. You can click it, and it goes into full-screen mode.

And that's pretty nice. If you write a smile file, there's a tags QT full-screen equals full. We've added that extension to smile. So you can just say, look, I'm going to write out a four-line smile file that says go to full-screen, and here's the name of the movie I want to play. And it's pretty much just like playing a movie, but it plays in full-screen mode.

And as we were talking about earlier, the XML I was showing you, you can add, after your embed source, full-screen equals full, or full-screen equals half, or full-screen equals double, whatever, depending on which mode you want to run it in. And that QTL file, or QTI file, it says QTI, but it should say QTL, QuickTime Media Link file, will launch in full-screen mode.

So if I have... If I have a movie, and I want QuickTime Player to play it in full-screen mode, but I don't have access to the API, I don't have AppleScript, I can generate a text file from any kind of CGI script that says, here's the XML file, here's the movie I want to play, play it in full-screen mode, name it .mov, embed it in the web page.

When you click it, it thinks it's a movie. QuickTime gets the real movie, plays it in full-screen mode in QuickTime Player. And if we go back to... "The demo machine, I'll show you what that looks like, and it's certainly a better experience. This looks the same. Here we have the poster. It's going to launch QuickTime Player, but this time..."

I think that's a much better experience for the user than watching it in a little window. Now that actually had it set to play it full-screen and then quit when done. I had another window open. But that was a full-screen movie. The movie itself was set to be full-screen. And here's a text link to a QTL file that's going to play a normal-sized movie but tell QuickTime to play it on full-screen, and it's going to act just the same.

Okay, and as I said, here we've added a few lines to the QT, say, full-screen equals full, autoplay equals true, quit when done equals true, and those things just happen. Okay. Any questions about launching QuickTime Player full-screen mode? Okay, what is the difference between normal mode and current mode? Normal is the actual size of the movie when it was last saved.

Current is whatever size it is now. If you're playing in QuickTime Player and you drag it to be a certain size, and then you hit a button that says "Go full screen," and it says "Go full screen current," it'll display at that size on a black background, whatever size you're at. You would very, very rarely want to use that. Yeah, of course. All right, and if we could go back to slides.

Let's look at writing. Is there anybody here who writes CGI or SSI scripts? Okay. Well, I'm just talking to you then. You can write your embed tag on the fly using JavaScript. And there are a lot of reasons why you might want to do that. The most obvious one is to check for QuickTime, check the browser, correct the operating system, and then write the object tag or the embed tag or both, or skip tags. Say, you know what?

If they have QuickTime, I want to play this background audio, but if they don't, I don't want to bug them to do a download. I just won't write that tag in. I won't write the embed tag for that audio. Or you can say, well, they don't have QuickTime, so instead of embedding a movie, I'll put in an image tag and show them a JPEG.

Or, no, I'll redirect them to an alternate content page because this page really needs QuickTime, but I want them to be able to buy my shoes even if they don't have QuickTime, so I'll send them over here. Or redirect them to a download page that says, gee, they don't have QuickTime. Let's send them over to a page that tells them to get it because they really got to have it.

And I don't want to just depend on the browser popping up some little window that's an ambiguous tag that's going to confuse the user. Do you trust Apple to download an ActiveX? I'll bring it to a web page that says, hey, you need QuickTime. You're going to get it by clicking here. It's free. Don't worry.

Ignore the $30 pro fee. Just click for the free player. Yes, it works for Windows and whatever you want to say. Or, of course, you can direct them to our download page at www.apple.com QuickTime Download. And that's guaranteed to be there. So I'll show you back on the demo machine.

So, kind of what that looks like, we're going to load a screen that's got some JavaScript in it. It checks for QuickTime, and it either embeds this movie or it says, "Oh, you need QuickTime." It's very simple, and if we just look at the view, at the source, realize it's kind of tiny, but it's There's a script.

It says, "Check for the ActiveX control. Now check for the Plug-in." And if QuickTime is true, Document write embed source. Else, document write, you don't have QuickTime. Now, this is really skeletal. You would do a much more finished job, but I just wanted to make it really obvious how it's working. Checks for QuickTime either embeds the QuickTime content or says do something else. And that's pretty straightforward. If you do any JavaScript programming at all, that's pretty simple to do. And let's go back to slides again.

Okay, so there are really two ways to detect QuickTime. JavaScript, which is what we just looked at, and if you use JavaScript, you're also going to use a little VB script for Windows, and what you do is you get the browser type, browser version, OS, and then check for QuickTime.

If it's Netscape or Mozilla or Internet Explorer for the Mac, just use the navigator plug-in's object, and it'll tell you if QuickTime is installed, if the QuickTime plug-in is there. If you're in Internet Explorer for Windows, it's a little more complicated. You create an object and then check for that object and see if it's available, and it works.

It tells you if the ActiveX is there. So you do them both, and if either of them is true, then QuickTime is there. Otherwise, it's basically not. The other possibility is to use QuickTime to detect itself, and that's more reliable and somewhat more interesting. Use QuickTime to detect itself.

You embed a QuickTime movie, and you have an href to the page that you want people to go to if they have QuickTime and say auto href equals true. If they have QuickTime, they're going to go through that page in less than a second. They'll be there, and then they'll be there gone. They'll be directed to the page you want it to go to. If they don't have QuickTime installed or it's not properly configured for their browser or something is wrong, then it's there at that page.

So put some text on it that gives them something to read while you wait for a timeout, and set a timeout in the HTML that says, hey, if they don't have QuickTime, after 30 seconds, 45 seconds, however long I want to give it, take them to another page. HTML has a facility for this. It's HTTP Equiv. Set it to refresh. Set the content to be, the timeout, the URL you want to go to, and that's all there is to it.

So it works like this. The user comes in to the test page, and if they have QuickTime, QuickTime takes them to another page. If they don't have QuickTime, there's a timeout to go to the alternate content. And it works -- it looks like this. We go back to the demos. There's not a lot to see here because what's going to happen is we're going to load Redirect. Boom. Let's -- you want to see it again?

Okay, let's go back. Checking for QuickTime. You have QuickTime. Checking for QuickTime. Oh, you have QuickTime. Checking for QuickTime. Oh, you have QuickTime. I could disable QuickTime and it would go to the page that says you don't have QuickTime, but I think you can imagine what that looks like.

It's really pretty straightforward, pretty easy to do. Just put it in a QuickTime movie with an href, auto href, make up the pages for has it, doesn't have it, and you're done. So we go back to slides. It's really, really not that bad. I'm just going to back up here. Two lines for QuickTime, href and auto href, one line for HTML, http-equiv.

That goes in your header and any HTML The tutorial will show you how to do that. So the good thing about using JavaScript and VBScript is you can prevent the prompt for download we talked about earlier if you don't want that to happen under any circumstances, and you only write the tags if QuickTime is present. The bad side is, it could be wrong.

You could say, "Yeah, the QuickTime Plug-in is there, but it's not set to play movies." All you know is that it's there. Or you could have a false negative. You could have an older version of QuickTime. QuickTime is there, but it's too early a version for Windows to know about.

Doing it with QuickTime works every time. It's really reliable. And it will prompt for a download when needed. And normally, that's a positive, not a negative. And it uses the Plug-ins page if it's a Plug-in or the class ID and code base if it's an ActiveX control. So if it needs a Plug-in, it'll get the Plug-in. If it needs an ActiveX control, it will get that.

The only downside to that is if you really, really, really don't want anybody ever to get a download prompt, well, if they don't have QuickTime, they're going to get a prompt that says, "You need it." Okay. I'm going to go on to QuickTime file format for the web. Any questions about that last little sequence there?

Okay. I see many eyes glazing over. I know that wasn't right up everybody's alley here. Okay. We're going to look at fast start and slow start movies, flattening movies, reference movies, storing data in external files, and copy protection in a way. So let's look at it. QuickTime file format. QuickTime movies are divided into two parts. There's a header. Sometimes we refer to it as a card index.

It's the metadata about the movie. It says how many tracks are there, what kind of tracks are there, and where is all the data located for these tracks. Then there's the data itself, which is video frames, audio samples, images. And these can be in any kind of file. They can be in the same file as the movie information. They can be on the World Wide Web. They can be in a mixture of files. You can have live streams, stuff from the web, stuff that's local, all in the same movie.

The critical thing is there's the metadata, the movie resource, if you will, which is if you program in QuickTime, it's the movie, and the sample data, which may or may not be in the same file. And if you look at the file, you pull it open in a hex editor, you'll see that the movie information is stored in a move atom, M-O-O-V, and the data is stored in an MDAT atom, M-D-A-T.

If you just pull it up in a hex editor and look at it, you'll see a bunch of garbage, but you'll see those characters. Right at the beginning of the file, typically, there's either a move or an MDAT. And, uh... How it works is, if it's a fast start movie, the move atom is first.

FastStart is also called Progressive Download. We've got a QuickTime movie on a file server. You start to download it in your HTML page. You don't wait for the movie to download and then watch it. You can watch it while it's downloading. Well, how does that work? Well, the first thing in the file is the metadata that says, "These are the tracks.

This is the data. This is where it all is." And then the data is nicely interleaved behind that. for time. So you don't have just the, here's the audio, here's the video, here's the text. It's like, here's the first few frames of audio and the first few thousand samples of video, the first few thousand samples of audio, the first few lines of text, and then we'll continue on like that.

So the data itself is a hash. We've taken the whole library and put it through a blender and sorted it by time. You've got to have that movie metadata to make any sense of it at all. But if movie metadata is there, then you can make sense of it perfectly from beginning to end.

So a fast start movie, the header is usually quick. The metadata is a few K. And the data itself can run into the megabytes very easily. So you want to make sure that the metadata is at the front. The movie atom is at the front and the mdata is at the back. And if you open a file on the same QuickTime player and you make a few edits and you save it, but you don't save as self-contained, you just save it.

it's going to try to write the movie data back, the movie header information back to that file. If it doesn't fit because it's gotten bigger, it's not going to move the data over because it's got byte offsets to all that data in the header. It's going to put the header at the end of the file and mark that beginning. It says, well, this space is free now.

And so you may find that if you pick up a QuickTime movie that was working just fine and you edited it and saved it back, and now people are saying, I go to your site and I see a big blue queue that lasts for 15 minutes and then the movie starts playing. Oh, that's because the movie now resources at the end of the file. It has to get through all this hash of data before it finally gets to the part of the file that has the information it needs to know what to do with the data.

You can very easily look for this even if you're not terribly sophisticated. If you have a hex editor or a BBEdit used to do this, you just drag it in and look at it and go, "Oh, free instead of move," and then there's a bunch of garbage and then there's an MDAT. At the end of the file, "Oh, gosh, here's my move, Adam." Okay.

How do you prevent that? If you open a file in QuickTime Player and edit it, don't save, save as. Create a new file, put the movie first, data second, makes a nice new header for the data, and everything works great. If you're working from the API level, then you use flattenMovie and flattenMovieData to create these items, and there are flags to make sure that the movie is stored first. But that's the default behavior. That's normally how it works now.

This low-start movie is just a movie that has the move Adam at the end. And you can make one if you want to, but why would you want to? Okay, is there anybody here who's programming at the API level with QuickTime? Okay, I'm going to skip this 10 because you don't care.

Well, you might care in a way. If you do a Save As, create a new file, and you say make it self-contained, That's going to do this. It's going to make the movie self-contained, put the movie resource in the data fork, which is the only fork that most systems have, store the movie item before the data.

It resolves all the references. So if you're looking at a JPEG image over here and an IFF file there, it's going to pull them in. It's going to throw away any data that you don't use and pull in any data that you do use. And if you use it six times, it's going to make six copies. And it puts preloaded data up front.

Okay. Now, what's different? Well, if you're not programming with the API, do you really care about this? Yeah, a little bit. OK, reference movies are movies that point to other movies, basically. And they have external sample data. The sample data is not enclosed in the movie file. Now, a true reference movie refers to one or typically a bunch of other movie files.

If the user has a 56K modem, send them this file. If they have a 128K modem, send them this file. If they're on a T1, send them this file. If they're English, send them this file. If they're French, send them that file. If their screen resolution is 640x480, send them this movie. It lists the things and the conditions under which to send them.

And it selects the movie best suited to the viewer. These are pretty easy to construct. We'll talk about that in just a moment. There are also pointer movies, like that little QTL file that just point to one other movie. It's not a reference movie in the same sense.

It's not a true reference movie, but it is still an indirection. And there are movies that just have external dependencies. I can open a bunch of JPEGs, save the movie just as a movie, and it depends on those JPEGs. It's a complete movie resource, it's structured like a QuickTime movie file, but there's no mdatatm anywhere. It's pointing to external files.

You don't care about this if you're not programming. Okay. The way to build a true reference movie is to import from XML. And currently there's a tool on the web that you can download called XML to Ref Movie. And it's Hathi.net written by Peter Hathi, one of the original QuickTime architects. And it's a neat little tool. It only runs on Mac OS but it will turn your text into a reference movie.

So you can give it a list, the movies you want to play and conditions under which you want to play them. And it will turn that into a movie you can embed in a web page. When somebody loads that movie, what they actually see depends on who they are, what those conditions are, which ones are met. And it's a really powerful tool that will let you send the right bandwidth movie to the right person. And it can do a lot of things.

It has selectors not just for connection speed but for CPU and OS. So you can say, well, on Macintosh I want to send this file because it's got this text. If they've got Windows, I want to send this movie because it's a different set of instructions. French people get this one. Germans get that one. Screen resolution, QuickTime version, presence of a specific component.

If they have Sorensen's Video 3, I want to send them this movie. If they don't, I want to send them that movie. Do they have the AugVorbis component? Do they have the Kodak? Great. They're going to hear this audio. If they don't, oh, okay, we'll use sound design or IMA.

The pointer movies are very simple. They're just files that point to another movie, the XML movies we talked about. There are some tricks you can play. RTSP text, If I make a file that says RTSP text, RTSP colon, and an address, and I save that file, that little text file, as a move.mov, QuickTime will say, oh, is it a movie file? Try to open it, look at it, go, this is a funny-looking movie file. Oh, but the first characters are RTSP text.

I'll bet it's an RTSP address. And if it is, it will resolve it and play the movie. So this is a really quick workaround. If you want to point people to a stream from a script, your CGI can just generate, bang, a one-line text file that has the RTSP address of the stream you really want it to play, embed it as a movie file, it's downloaded over HTTP, it looks like a movie, it double-clicks from the desktop, everything just works, but it's a line of text that points to the stream to get. So that's a nice thing. And a movie that contains only a streaming track.

If you open a live stream, you've got sound, video, maybe a lot of things happening, and you save it from QuickTime Player, what you actually save is the URL of the thing you were looking at, and if it was video on demand, where you were. If it's a live stream, just how to get it. And again, this is a little tiny text file. It's not a text file, but it's a very small file.

Movies with external dependencies do contain a movie resource, but they may or may not contain some of the data. If it's got external dependencies, some of the data is external. There may be internal data as well. "A movie can have some of its data internally and some externally. I can include everything except the soundtrack and say, 'Here's the video,' but the soundtrack is going to be language dependent.

So the soundtrack depends on what--it's one of these files, depending on what language you're at, or my text track is that way. But the main video goes to everybody. So the main video is self-contained, and the audio will pick from one of these external files. And that way I don't have to send all the audio to everybody."

They contain data references, which can be an alias, which is a file. This movie points to data in another file, and it's in this directory, or it's relative to -- it's in my directory. It can point to a URL, so the data is on this server. Go here and get it. It's not on a file. It's a URL.

And you can create these pretty easily. If I open a movie and save as to a new file but allow dependencies, then I have a URL that has a data alias. It points to this other file. If I get rid of that file the movie no longer plays because it knows how to play it but there's no data. So sometimes you want to do that. Usually you don't.

URL, data references, same things. And those are often very handy. If I go to QuickTime Player and say open from URL or if I'm in the API and I say new movie from DataRef and that DataRef is a URL, then I'm going to open a stream or a file on a web server and I can save the movie resource, just save allowing dependencies, and now I have URL data references. I've got all the information about how to play the movie but the data I'm saying is on a server.

Now, why in the world would you want to do that? Well, you might want to copy-protect your movie a little bit. I'm going to talk a little bit about copy protection. Very little, I think. There are three main modes for copy protection. The most important one is jujitsu. Don't try to copy-protect your movie.

If we go back to the demo machine here, Oh, here's a reference movie. I really should have shown you this, but I didn't mark the slide. This is a very simple reference movie. What speed is your Internet connection? And it could run any one of these movies. It says, "Oh, I'm here.

If I change my Internet speed and load this page again, I'll see a different movie." So it's very simple how it operates, and it's a very small -- the reference movie itself is very small. So you can have lots of different versions, but you only download the one that the user actually is going to see that you actually need. And let's look at what I call Jiu-Jitsu.

Okay. This is a piece of graphics that was given to us by Robert West, Janie Fitzgerald, and Michael Schaff through their kindness. And I'll just load it here. And this is something QuickTime can do that you won't see much of anyplace else, is it can make skinned movies. So rather than copy protect your movie, put a skin on it that's your product, your company, your logo, your look and feel. Every time somebody makes a copy of that movie, they're advertising for you. You can put a click through here where it clicks through to your website.

And this can be anything. Now this is a Can we get the volume up a little bit on this? There we go. This is a VR movie. It's got directional sound, so I can look away from the noise and I can zoom in and go, "Who's that guy? What's he doing there?" "If I go back and look towards the... So this is a promo piece for their thing."

But the point is that if you copy their movie, you're also copying their player, their logo, click through to their website, and then you don't really have to worry about making -- I mean, make it work for you. Has anybody here listened to Wilco? Okay. They're a band out of Chicago.

They just released a number 13 on the Billboard charts. They put all their movie on the Internet -- all their music on the Internet free for MP3 first, and that's how they got popular. And everything on the CD is on the Internet. Why would people buy it? Because it rocks.

So here's a little full-screen button. Oh, that was a go-away button, sorry. Wrong button. Maybe this is a full-screen button. There we go. So this is an example of a wired action going to full screen, which is kind of a cool thing, although you lose a lot of the point of having a skin because you don't have a window.

You can go full-screen as a wired action inside the movie itself. You really want to look into this technology. This is the way you want to package your movies. This is not like a media skin for somebody else's player. Where they can put a skin on your movie. And now your movie is playing with your competitor's advertisement running next to it. Or it's running in a leopard skin thing with a funny hat. And you know, it just looks ridiculous.

You make the player. You don't have to use Apple's player. This is a standard movie. This movie, you can put this on Windows. You can put it on Mac OS. Double click it from the desktop. It does the same thing in both platforms. And it's a really nice way to do your stuff. So I really recommend you look at that technology. Because it's not hard to do. And it really has big payoff.

OK, back to slides. We also have some very polite copy protection. You can set kiosk mode in your HTML. And that tells people that you don't want to copy it. So if they have QuickTime Pro and they want to select Save Movie, it says, no, that's grayed out. Now, can they turn kiosk mode off and download it anyway? Yeah. So it just keeps out people who are honest. It says, I don't want you to make a copy of this movie. So if you had any doubt, I'm just letting you know.

And the other ways to copy-predict a movie typically are based on the media. You have media keys, some form of encryption. You can open a movie up in QuickTime Player and disallow saving, and that will tell QuickTime in a far more serious way that it won't save the movie. You can't just change HTML and make it save it. It's hard to break. All these kinds of copy protection are subject to being broken. None of them are reliable or foolproof, but sometimes they're valuable.

We're not really doing copy protection in QuickTime yet. We're just kind of at the beginning stages of deciding what's the right thing to do. However, there is a form of copy protecting movie files that is used a lot, and they're not encrypted. They're just technically difficult to get at, and the best example of that is streaming movies. It's hard to copy a movie from a stream.

They're not encrypted. Anyone who programs in the QuickTime interface, anyone who works at the API level can just go through, read the spec, write the code, and recreate the movie, pick up the stream off the web, and make the movie. But you can't drag it from the browser cache.

You can't just do a get and get it from the file server. You have to go through some work, and it's just too complicated for somewhere between 99.9 and 99.99% of the population, and that's most of what you're concerned about. It's no challenge for a hacker. There's no encryption to break.

It's just a lot of tedious work and very little payoff because you have to go through it again for the next movie. So, um, A lot of people use streaming because they want to copy protect their movies. And they say, gee, I'd like to use Fast Start. It's better quality. It looks sharper.

I can deliver a movie that has higher bandwidth than the user's connection. But I really don't want them to just drag copies from the browser. I want them to have to come to my server to get it each time. So they use streams. And sometimes that's great. And sometimes it's not what you want.

So is there a way to make Fast Start movies roughly as secure as streaming? And yeah, there is. And again, this isn't copy protection. It's just making it reasonably safe. We call it the box of rocks defense. And what we do is we put URL data references in the movie file.

So you open a movie and it says the data is on the server. And there's nothing, you know, it's not copy protected. It's just my data is on the server. And here's where it is. You can compress the movie header so that's not visible. But they can get it anyway. But the point is the external data on the server is not in a movie file.

So if they download it, it doesn't have that movie header information. It's that shredded version of the library. You know, we've got a video frame and some audio samples. And it doesn't say, here's the video, here's the audio. It's just there in a big mess. And unsorting it is very painful without the header. So now, again, anybody who is a QuickTime programmer can de-scramble it, but that's not that many people. And what happens is you embed the movie in your web page, and it depends on its data on a server.

So if the user says, oh, I've got this movie now, and they play it again, it just goes to the server again for the data. So that's fine. If you don't want them to have access to your server, you can deny it. You can take the movie off the server. You can change it.

You have control. It's your movie. They have to come to your server every time they want it. And, yeah, they can copy the data too, but it's not a playable movie, and the movie won't play it. It goes to the server. It's got URL data references. So this works.

We've put a bunch of movies up on the web. This way, it's fine. The right way to do this is using the QuickTime API, and I'm going to go through this even though there aren't many API programmers in here, which is what I thought I was talking to today. Sorry if my presentation was a little skewed. You open your movie, flatten the movie data to a data file. Don't set the flatten add movie to data fork.

And what that says is it says, save the data to a file, don't add the movie resource. And this will return a new movie data structure pointing to this new file. Set the media data reference to URL. The user will give you a URL and say, this is where I want to put. I'm talking about writing an application here where somebody is going to give you a movie. You're going to bring it into your application and create a data file to put on a server and a movie file to embed. This is how you go about it.

You create the data file. You create the movie file by iterating through the tracks in the movie and the data refs in the tracks and doing a set media data ref to the URL where the user says he's going to put it. Save the new movie using these API elements.

Create movie file. Add movie resource. Close movie file. Now you've got a movie file that just has the resource. You upload the DAT file to the server and you're ready to go. And that's the right way to do it. Now for people who are here in this room, there's a quick and dirty way to do it. I don't recommend this. This will void the warnings. on your movie.

I'm joking but I'm not. If you make a QuickTime movie ten years ago and you play it today, it's going to play almost in every case. But there are things you can do to hack up the movie file that are not guaranteed to work in the future. They work now, but they might not work with QuickTime 6, 7, 8, 9, 10. So bear that in mind if you're going to do this that this is not the right way. But it's a way to test it and see if it works.

And then if it works, if you are a C programmer or you know a C programmer or you can hire a C programmer or you have a box of jelly donuts with which to entice a C programmer to work for you, you can get them to write. It shouldn't take all day to write this application that I just described. It might take all day, but it shouldn't take too long. So what you do if you want to just try this out is copy your movie, copy it to a DAT file. And what is that?

I'm just saying copy it and give it a DAT file extension. So that the server knows, everybody knows this is not a movie. Don't try to open this with QuickTime Player. It's just some data. And upload it to your server. So your server says this is not a QuickTime Movie. It's a data file.

I don't know what's in it. It's just binary data. Then do an open URL in QuickTime Player. Open that movie up. So you rename the movie .dat, put it on a server, open it in QuickTime Player. Save, allowing dependencies. Now you've got a little movie on your desk that points to the data on the server. That's great, except the data on the server is also a playable movie. So if somebody downloads it, they can play it.

So you make it unplayable. How do you do that? Well, you void your warranty. If it's a slow start movie, you delete the movie file from the end. If it's a fast start movie, you zero out the movie at the start. Just overwrite it with zeros. Do not change the byte offsets in the file.

The movie resource is pointing to exact specific points in the file to say this video frame starts here and ends here. This audio sample starts here and ends here. If you add a byte or subtract a byte from this file before the movie data atom, everything is wrong and it will do bad, bad, bad, bad things. It may even crash QuickTime.

We try not to let that happen but if you do stuff like this, you know, all bets are off. So be very, very careful if you do this but you can check it out and see it. And I've done it at 3:00 in the morning at need and it does work. Any questions about that? Hey, we're rocking. You're all asleep. We're running out of time here. Gee, not many scripters here. You can use a number of ways to create movies on the fly for your users by combining resources.

One of them is Smile, and I'm not going to go into it in any detail, but it's a very simple text-oriented language. It says what movies to present in what order and where on the screen, and you can just generate a text file. There's a pretty popular website that does this where the user selects what movies he wants to see.

Then it just builds a text file on the fly that says it's a Smile file. Play this video, play this video, play this video, play this video, and it just runs through. And you can do it in full screen mode. You can do a lot of neat stuff with it.

Check it out if you are into scripting. And you can create this on the fly in response to a submitted form the user's filled out or a cookie in their browser or some wired action that they've given in another movie. Or you can just generate a movie of the day this way that your HTML pages don't have to change. They play the movie of the day, which is a little text file that your script spits out periodically.

Or okay. Okay, here's just a really simple example. Let's say you've got a database. You've got MP3s, you've got rock videos for some of them, you've got an item, which is the CD that it comes from that you can buy, and you've got some artwork. So the user selects a list -- a song list, and your CGI says, okay, create a sequence of parallel elements. And the parallel elements will be the MP3 audio, which I'm going to play, the video if I've got it or the CD artwork if I don't, to display while it plays, and an href to the CD. So if the user clicks on it, that's where they go.

Okay. running out of time, so thank you all for coming. It was more fun stuff to do, but we just ran out of time. The QuickTime Roadmap, all these things have passed except QuickTime and MPEG-4, which is this room in 330. Any second now. Who to talk to?

Me, I'm the guy to blame. Eric Carlson, if you have a specific question about the QuickTime plugin or ActiveX control. Book QuickTime for the Web, QuickTime developer documentation, tutorials, sample code and tools. Even if you're not a developer, go to that page and check it out. There's tools like Plugin Helper.

There's a lot of neat stuff that you can use there that are very helpful. Good places to go, Codex Central, Blue Abuse, and the QuickTime talk and API mailing lists, both at list.apple.com. And if you're running OS X Help, you can get the QuickTime TechPubs stuff out of your Help Center. Just go to Help, Help Center, Developer, QT. Virtually all the documentation that's on the web is on the CDs that you got with Jaguar.

[Transcript missing]

WEBVTT

00:00:01.800 --> 00:00:02.440
Good morning.

00:00:02.440 --> 00:00:05.060
Let's see if I got
everything working here.

00:00:05.060 --> 00:00:08.140
All right, so we're here to talk
about the Darwin Kernel.

00:00:08.140 --> 00:00:09.700
I hope you guys are all excited about it.

00:00:09.770 --> 00:00:12.300
It's tough to get excited
at 9 o'clock in the morning,

00:00:12.310 --> 00:00:15.460
but it's better than last session
on Friday like we had last year.

00:00:18.320 --> 00:00:20.040
So what are we going to talk about today?

00:00:20.040 --> 00:00:23.770
First of all,
we're talking about the Darwin Kernel

00:00:23.770 --> 00:00:28.060
and how that defines the core set
of services inside of Mac OS X.

00:00:28.060 --> 00:00:32.870
Basically,
everything you do affects your code.

00:00:33.400 --> 00:00:35.060
Everything in the kernel
affects your code,

00:00:35.130 --> 00:00:36.740
whether you're using it or not.

00:00:36.770 --> 00:00:41.180
So it's important for everybody
to understand how the kernel

00:00:41.180 --> 00:00:43.210
is affecting their work.

00:00:44.560 --> 00:00:47.200
And also that while the
kernel is fairly stable,

00:00:47.210 --> 00:00:49.560
it's still under constant refinement.

00:00:49.560 --> 00:00:52.520
Most of the time we're refining
the implementations of things.

00:00:52.520 --> 00:00:55.800
But we're also talking about
refining the semantics and syntax

00:00:55.880 --> 00:00:57.760
of certain areas of the kernel.

00:00:57.760 --> 00:01:01.750
And we want to give you a heads
up on what those things are.

00:01:01.760 --> 00:01:04.250
So what you're going to
learn in this session is,

00:01:04.250 --> 00:01:07.020
you know, which services may be
affecting your code,

00:01:07.110 --> 00:01:10.300
how they're affecting your code,
and how I'm going to do that is to

00:01:10.410 --> 00:01:14.540
give a brief overview of how the
kernel services play into the kernel.

00:01:14.580 --> 00:01:17.300
to the higher level
services in the system.

00:01:17.300 --> 00:01:21.140
And therefore how that
may be affecting you.

00:01:21.360 --> 00:01:24.360
Talk about some of the changes
we have planned for Jaguar.

00:01:24.360 --> 00:01:27.060
Some of those are already
on the CD you have.

00:01:27.060 --> 00:01:29.060
Some of those are still to come.

00:01:29.060 --> 00:01:32.380
Some may not make it,
so this is all just a tentative list

00:01:32.380 --> 00:01:35.030
of some of the things we're looking at.

00:01:35.060 --> 00:01:40.700
And also looking at some of the
things that are coming beyond Jaguar.

00:01:40.700 --> 00:01:44.480
So give you a heads up on some
of the things we're looking at.

00:01:44.600 --> 00:01:47.100
Again, this is really a tentative list.

00:01:47.100 --> 00:01:51.280
We want you to help us drive that
list of things that are coming.

00:01:51.300 --> 00:01:53.200
Some of the things that
we need to look at,

00:01:53.270 --> 00:01:53.930
we need to do.

00:01:53.930 --> 00:01:56.960
But we also want to give you a heads
up on some of those things that

00:01:56.960 --> 00:01:58.870
we're already thinking about doing.

00:02:00.790 --> 00:02:02.190
All right,
and this is the classic picture

00:02:02.190 --> 00:02:06.100
you've seen time and time again,
the multi-layered facet of

00:02:06.100 --> 00:02:08.260
Mac OS X with Darwin as the core.

00:02:10.530 --> 00:02:25.530
and the traditional picture
of the Darwin Kernel.

00:02:25.530 --> 00:02:25.530
It is composed of three basic components,
the BSD Kernel, the Mach Kernel,

00:02:25.530 --> 00:02:25.530
and Iocat.

00:02:25.530 --> 00:02:25.530
But we tend not to... Sorry.

00:02:26.100 --> 00:02:27.530
Where did that come from?

00:02:27.770 --> 00:02:33.590
Well, the Mac code came from Mac 3.0,
basically the OSFMK 7.3 code,

00:02:33.600 --> 00:02:34.670
if you were here last year.

00:02:34.680 --> 00:02:35.880
Nothing different.

00:02:35.880 --> 00:02:38.370
We have not picked up
any new version of Mac.

00:02:38.440 --> 00:02:41.860
There really aren't new whole
versions of Mac to pick up.

00:02:41.960 --> 00:02:45.940
But that defines the virtual memory,
the scheduling,

00:02:45.940 --> 00:02:48.420
and the inter-process communication
that happens in the system,

00:02:48.420 --> 00:02:50.790
at least the fundamental
versions of those things.

00:02:51.840 --> 00:02:56.380
Our BSD code was originally
from BSD 4.4.Lights2.

00:02:56.380 --> 00:03:00.760
That defines the process model,
the scheduling,

00:03:00.760 --> 00:03:03.060
the security model in the system.

00:03:03.060 --> 00:03:08.020
Mac has some security features,
but it's mostly security policy agnostic.

00:03:08.020 --> 00:03:13.400
So the BSD part of the system is
what defines the security policy

00:03:13.400 --> 00:03:14.360
for the rest of the system.

00:03:14.360 --> 00:03:17.780
And it also defines the
file management system.

00:03:17.780 --> 00:03:21.780
And also we had the networking
code came from FreeBSD.

00:03:21.840 --> 00:03:22.700
FreeBSD as well.

00:03:22.700 --> 00:03:25.040
While we're not really talking
about the networking code,

00:03:25.040 --> 00:03:27.730
it's important to kind of see
how that all came together.

00:03:30.280 --> 00:03:33.190
For a large part of the system,
including the networking

00:03:33.190 --> 00:03:36.680
code and the NFS system,
those have been refreshed in the Jaguar

00:03:37.150 --> 00:03:39.360
timeframe to come up to FreeBSD 4.4.

00:03:39.360 --> 00:03:45.940
But the rest of the kernel,
while looking at FreeBSD 4.4,

00:03:45.940 --> 00:03:49.990
what it defines as services and semantics
and syntax is really important to us.

00:03:50.020 --> 00:03:54.580
Our versions of those parts of the
system are radically different in

00:03:54.580 --> 00:03:57.730
implementation than the FreeBSD version.

00:03:57.740 --> 00:04:01.650
So you can't just take whole cloth
those sections of the system and bring

00:04:01.650 --> 00:04:06.000
them forward to the current day Jaguar
system or the current day Darwin Kernel.

00:04:06.000 --> 00:04:12.330
So we've more picked and looked
at certain aspects of that code

00:04:12.330 --> 00:04:15.550
and have decided what parts we
like and what parts we don't,

00:04:15.750 --> 00:04:17.110
how we can bring those in.

00:04:17.120 --> 00:04:22.690
But we cannot possibly take new refreshes
of that whole cloth hunks of code.

00:04:24.800 --> 00:06:34.900
[Transcript missing]

00:06:35.370 --> 00:06:40.050
So, but we don't really like to look
at the system as Mach BSD I/O Kit,

00:06:40.150 --> 00:06:44.700
especially the Mach BSD differentiation.

00:06:44.930 --> 00:06:47.630
We have a unified kernel.

00:06:47.760 --> 00:06:51.540
We're not really that interested
in experimenting and showing how

00:06:51.540 --> 00:06:55.560
to the world that you can implement
BSD as a user-level service.

00:06:55.560 --> 00:06:58.360
It's not at all interesting to us.

00:06:58.450 --> 00:07:01.200
What is interesting is
the silos of service,

00:07:01.200 --> 00:07:05.840
the vertical services that are provided,
the process management, the threading,

00:07:05.840 --> 00:07:11.660
right, and Mach and BSD provide services
in each of those areas combined.

00:07:11.720 --> 00:07:16.190
They make up what we have
in the kernel as services.

00:07:17.490 --> 00:07:20.470
And when you look at that
in the services area,

00:07:20.470 --> 00:07:22.040
what's new for Jaguar?

00:07:22.040 --> 00:07:25.530
Well, we've had a lot of performance
enhancements in Jaguar.

00:07:25.680 --> 00:07:31.240
That's probably our primary goal,
performance and stability.

00:07:31.310 --> 00:07:34.660
And so a lot of the implementations
have been refined on a lot of

00:07:34.740 --> 00:07:36.980
things throughout the kernel.

00:07:37.220 --> 00:07:40.800
But one of the things that we look
at all the time for performance is

00:07:40.800 --> 00:07:45.850
not just to make this call run 10%
faster or that call run 5% faster,

00:07:45.860 --> 00:07:49.860
but to look at the higher-level services
and the higher-level applications

00:07:49.860 --> 00:07:53.800
and try to define new services or
change the semantics of some of the

00:07:53.800 --> 00:07:56.890
existing services to let them run faster.

00:07:56.900 --> 00:08:00.270
And so provide better matching
of the services to the higher

00:08:00.270 --> 00:08:03.860
level is something that we're
really always watching out for,

00:08:03.860 --> 00:08:05.750
and there's a lot of that in Jaguar.

00:08:07.000 --> 00:09:19.000
[Transcript missing]

00:09:19.310 --> 00:09:25.100
And just reams of new bug fixes
and reams of new features.

00:09:25.110 --> 00:09:28.130
Just in the pure kernel part,
not counting the file system

00:09:28.130 --> 00:09:32.640
implementations of the networking part,
but the pure part that I showed earlier,

00:09:32.730 --> 00:09:36.560
there's been over 600
enhancements since Puma,

00:09:36.560 --> 00:09:40.060
since 10.1 released.

00:09:40.180 --> 00:09:42.330
But where are we going?

00:09:43.960 --> 00:09:45.540
More and more performance enhancements.

00:09:45.590 --> 00:09:48.890
This is one of our primary goals,
something you'll see us doing

00:09:48.900 --> 00:09:50.400
over and over and over again.

00:09:50.820 --> 00:09:52.270
Again, the same two areas.

00:09:52.360 --> 00:09:56.740
Implementation of existing
services and working our way

00:09:56.740 --> 00:09:58.530
towards new and better services.

00:09:58.540 --> 00:10:02.480
Yet more standards adherence.

00:10:02.540 --> 00:10:06.540
There are still some things in
POSIX that we don't support,

00:10:06.600 --> 00:10:11.540
and we're constantly striving to have
essentially a POSIX-compliant system.

00:10:11.910 --> 00:10:15.540
And a single-user--single-unit
specification.

00:10:15.540 --> 00:10:18.980
That's been moving along faster
and a little bit further in

00:10:19.110 --> 00:10:21.530
front of just the standard POSIX.

00:10:21.540 --> 00:10:25.030
And we've been looking at
tracking those things as well,

00:10:25.040 --> 00:10:29.230
and we're going to be implementing
a lot of the things that are there.

00:10:29.680 --> 00:10:35.400
But one of the things that is really
new coming forward is this notion

00:10:35.400 --> 00:10:39.390
of rigorously defined KEXT services.

00:10:39.550 --> 00:10:46.440
We've had, in I/O Kit land,
we've had a strong and fairly rigid set

00:10:46.440 --> 00:10:50.990
of things you can do in I/O Kit when
you develop an I/O Kit KEXT.

00:10:51.290 --> 00:10:56.160
We do not have those same kind of
systems in place when you're writing

00:10:56.420 --> 00:10:58.340
network kecks or file system kecks.

00:10:58.340 --> 00:11:02.760
And basically what people have
done is adopt the BSD model,

00:11:02.760 --> 00:11:06.330
which is you reach in and you
grab whatever you need and

00:11:06.600 --> 00:11:10.120
write a kecks that accesses all
the internal data structures,

00:11:10.120 --> 00:11:14.560
knows about all the function calls and
every little bit of the internal thing,

00:11:14.560 --> 00:11:16.280
and build kecks out of that.

00:11:17.180 --> 00:11:21.220
And in essence, you've got to,
every release of the system,

00:11:21.220 --> 00:11:25.440
you've got to re-roll that kecks
and get a new kecks because it's

00:11:25.440 --> 00:11:26.780
not going to run in an old system.

00:11:26.780 --> 00:11:31.320
Well, that doesn't really match very
well with Mac OS X as a commercial

00:11:31.440 --> 00:11:35.380
product because obviously people
don't like to have to go out and buy

00:11:35.380 --> 00:11:40.180
or get an upgrade version of their
file system every time Apple decides

00:11:40.240 --> 00:11:42.580
to roll out an update release.

00:11:42.580 --> 00:11:45.730
And so we're looking at,
now that we've gotten the

00:11:45.730 --> 00:11:49.700
higher-level services,
the ones towards user-level applications,

00:11:49.700 --> 00:11:53.730
fairly well complete,
we're now looking internally and

00:11:53.730 --> 00:11:57.880
trying to define those services so
we can get better release-to-release

00:11:57.880 --> 00:11:59.680
compatibility for your kecks.

00:12:02.930 --> 00:12:05.580
And of course,
just constantly new features

00:12:05.580 --> 00:12:07.130
and other bug fixes.

00:12:07.130 --> 00:12:13.450
So when we look at the services
provided by the kernel,

00:12:13.660 --> 00:12:17.860
We need to go through and kind
of describe to you what it is

00:12:17.860 --> 00:12:21.600
that each of these services does
and what we've changed in them.

00:12:21.700 --> 00:12:25.440
So in the process world,
everything starts with a Mach task.

00:12:25.460 --> 00:12:29.650
A Mach task is the unit of
ownership inside of Mach.

00:12:29.700 --> 00:12:35.420
All the resources that are mock-related
are defined and held in a task.

00:12:35.420 --> 00:12:38.960
So in essence, it provides an environment
in which threads run.

00:12:39.860 --> 00:12:43.760
So you've got an address space,
a set of communication rights to

00:12:43.790 --> 00:12:48.390
communicate to other parts of the system,
and exception handling to handle faults

00:12:48.390 --> 00:12:50.680
or whatever inside of that space.

00:12:52.300 --> 00:12:55.880
and a Mach task is represented by
a data structure called a task T.

00:12:55.880 --> 00:12:59.920
It's available to you when you're
programming at higher levels,

00:13:00.290 --> 00:13:00.730
but...

00:13:01.860 --> 00:13:06.580
Each BSD process actually
contains a Mach task.

00:13:06.580 --> 00:13:08.440
So you have a BSD process.

00:13:08.440 --> 00:13:10.430
It's got a Mach task.

00:13:10.430 --> 00:13:13.310
It uses the Mach task in certain ways.

00:13:13.310 --> 00:13:17.340
When you try to access and
manipulate the Mach task directly,

00:13:17.340 --> 00:13:20.770
you have to be careful not to
step on or interfere with some

00:13:20.770 --> 00:13:22.650
of the things that BSD does.

00:13:23.360 --> 00:13:27.310
We try to solve some of that for you,
like we don't let you terminate a

00:13:27.330 --> 00:13:29.860
task out from underneath a process.

00:13:29.860 --> 00:13:33.320
You have to come through and actually,
if it's a BSD process,

00:13:33.320 --> 00:13:37.500
you have to come through an exit
call in the BSD level to get the

00:13:37.520 --> 00:13:42.580
process to go away or shoot it with
a signal that's got a fatal handler.

00:13:42.580 --> 00:13:46.530
So we've done some of that work for you,
but obviously there's some other things.

00:13:46.540 --> 00:13:50.280
If you suspend a task out from
underneath of a BSD process,

00:13:50.280 --> 00:13:53.200
well, you're going to get behavior
that BSD is not going to do.

00:13:53.220 --> 00:13:56.510
and expecting and may or may not, uh,

00:13:57.400 --> 00:14:00.400
provide the capability
you're looking for.

00:14:00.530 --> 00:14:03.750
So each BSD process contains a Mach task.

00:14:03.890 --> 00:14:08.040
You're normally gonna program at the
BSD process level for most things.

00:14:08.220 --> 00:14:11.660
And it adds a file management
part of the process,

00:14:11.660 --> 00:14:14.460
or I use process as its own
set of file descriptors.

00:14:14.460 --> 00:14:16.700
It adds signal handling
in the Mach level.

00:14:16.700 --> 00:14:20.180
We had exception handling
at the task level.

00:14:20.430 --> 00:14:25.020
BSD is an exception handling client
of Mach and provides-- turns those

00:14:25.020 --> 00:14:26.940
around and makes those signals.

00:14:27.050 --> 00:14:31.700
So there's an interesting mix
when you interact with the signals

00:14:32.320 --> 00:14:35.880
at BSD level and the exception
handling at the Mach level,

00:14:36.040 --> 00:14:38.880
and something you always
have to be careful of.

00:14:39.040 --> 00:14:42.280
And it provides process naming,
a Mach task.

00:14:42.420 --> 00:14:44.480
You can have umpteen
Mach tasks in the system.

00:14:44.480 --> 00:14:46.980
There is no name space
for the Mach tasks.

00:14:47.150 --> 00:14:48.480
They're just out there.

00:14:48.480 --> 00:14:51.480
You need to know them before
you can even find them.

00:14:51.480 --> 00:14:54.830
And it provides a process
group relationship.

00:14:55.220 --> 00:14:57.670
and it's normally
represented through the PID.

00:14:57.670 --> 00:15:01.960
Now, normally you're working along
in a process and you're,

00:15:01.990 --> 00:15:05.270
you know, doing standard BSD things,
fork, exec, all of those.

00:15:05.320 --> 00:15:09.740
But there's this one call that
basically opens Pandora's box for you,

00:15:09.740 --> 00:15:11.410
and it's called task for PID.

00:15:11.420 --> 00:15:15.380
It's a new call just in Darwin,
and it basically, not new,

00:15:15.380 --> 00:15:18.430
but it's been there from the beginning,
but it's only in Darwin.

00:15:18.840 --> 00:15:22.860
And it basically allows you to
get at the underlying task for

00:15:22.870 --> 00:15:25.460
certain PIDs and manipulate them.

00:15:25.480 --> 00:15:29.630
And while that's, you know,
a really powerful feature because

00:15:29.630 --> 00:15:34.770
Mac has all these third-party task
manipulation facilities where most of

00:15:34.960 --> 00:15:39.160
the BSD stuff is within my process,
it also has problems,

00:15:39.170 --> 00:15:41.780
and we'll talk about some of that later.

00:15:43.670 --> 00:15:47.240
Okay, but most of you are not even
programming to BSD processes.

00:15:47.240 --> 00:15:49.640
You're programming to
a Mac OS X application.

00:15:51.730 --> 00:15:55.480
All right, and in Mac OS X applications,
there's an additional

00:15:55.660 --> 00:15:58.000
BSD Processes Head process groups.

00:15:58.000 --> 00:16:04.400
There's this additional notion
inside of a Mac OS X application,

00:16:04.400 --> 00:16:07.240
this notion of a session and
services that are provided by

00:16:07.340 --> 00:16:08.880
the core services of the system.

00:16:08.900 --> 00:16:13.980
You have pasteboard services,
and you have the clipboard,

00:16:13.980 --> 00:16:18.080
and you have input services and
Apple events and all of those

00:16:18.080 --> 00:16:23.460
things that add on to what you
get in a standard BSD process.

00:16:23.460 --> 00:16:27.670
And those are managed in
a scope called a session,

00:16:27.680 --> 00:16:29.630
basically the login session, if you will.

00:16:29.640 --> 00:16:33.980
And that adds additional burdens
and additional interactions

00:16:33.980 --> 00:16:36.290
to some of the things that
you might do at the BSD level.

00:16:36.300 --> 00:16:39.880
And we'll talk about some of that
in the security part of this.

00:16:39.880 --> 00:16:45.480
And it provides additional and
different ways to get things launched.

00:16:46.720 --> 00:16:49.420
In typical fashion,
you would use launch services

00:16:49.420 --> 00:16:53.560
or just use the Docker finder
or whatever to get applications

00:16:53.560 --> 00:16:55.280
launched at the Mac OS X level.

00:16:55.280 --> 00:16:58.720
They all go through the
launch services of the system.

00:16:58.720 --> 00:17:01.940
And there is an interaction issue, right?

00:17:01.940 --> 00:17:07.220
Because most of these services that
are in that session are represented

00:17:07.220 --> 00:17:10.410
by Mach ports and are per session.

00:17:10.420 --> 00:17:17.510
And fork at the Unix level does
not inherit any of the Mach ports

00:17:17.510 --> 00:17:19.630
that are associated with a task.

00:17:19.700 --> 00:17:24.100
It just basically creates a new task,
shared memory space, but no shared ports.

00:17:24.100 --> 00:17:28.850
You can end up with an issue if you're in
a Mac OS X application and you call fork.

00:17:28.920 --> 00:17:34.240
You can end up in a situation where the
address space of the new application that

00:17:34.240 --> 00:17:38.410
you got by forking thinks that there are
certain services available to it that it

00:17:38.430 --> 00:17:42.340
had already established connections to,
but they're not there because the

00:17:42.340 --> 00:17:44.270
ports that back those aren't there.

00:17:44.280 --> 00:17:47.460
So, again, this is, you know,
one of those areas where

00:17:47.460 --> 00:17:50.560
you have to be careful when
dealing at the higher levels.

00:17:50.580 --> 00:17:54.680
Don't dip down to the BSD or
the Mach level too much.

00:17:54.680 --> 00:18:00.580
And if you do, be careful about some of
these interaction issues.

00:18:03.280 --> 00:18:05.600
So what's new in Jaguar in this space?

00:18:05.640 --> 00:18:08.940
All right, well, performance,
performance, performance,

00:18:08.940 --> 00:18:11.840
there's...that's our main goal.

00:18:11.840 --> 00:18:15.660
But process creation and process exit,
there's been a lot of work to make

00:18:15.750 --> 00:18:18.040
those even faster than they were before.

00:18:18.040 --> 00:18:22.760
One of the big areas,
now that in the BSD world,

00:18:22.760 --> 00:18:29.700
signals are part of the process space,
we now have a lot more adherent

00:18:29.700 --> 00:18:30.960
POSIX signal semantics.

00:18:31.400 --> 00:18:36.830
And so we have all the SIG action
options that we were missing in 10.1.

00:18:40.650 --> 00:18:41.360
But where are we going?

00:18:41.360 --> 00:18:46.700
Well, performance boost,
performance boost, performance boost.

00:18:46.700 --> 00:18:48.400
That's basically where we're going.

00:18:48.400 --> 00:18:51.970
One of the things beyond just
trying to make what we do better is

00:18:52.430 --> 00:18:56.970
trying to make our services match
the higher-level services better.

00:18:56.980 --> 00:19:01.750
Launch Services is a
spawn kind of facility.

00:19:01.780 --> 00:19:04.560
It allows applications
to just be created.

00:19:04.560 --> 00:19:08.240
It's not make a copy of myself and
then turn myself into something.

00:19:08.240 --> 00:19:09.160
It's just create.

00:19:09.740 --> 00:19:13.410
And so we're looking at things like
the POSIX spawn or other versions,

00:19:13.410 --> 00:19:17.860
variants of the same thing to provide
facilities for the higher levels

00:19:17.860 --> 00:19:19.510
that match their semantics better.

00:19:20.970 --> 00:19:25.060
And we're looking at, you know,
even more of the POSIX signal stuff.

00:19:25.140 --> 00:19:30.340
POSIX now defines 128 different
signal levels that you can send.

00:19:30.340 --> 00:19:34.800
There's definitely some interest
from some of the people.

00:19:34.800 --> 00:19:36.600
I think if you have
interest in that area,

00:19:36.600 --> 00:19:37.780
you ought to bring that forward.

00:19:37.780 --> 00:19:42.520
But POSIX also specified in their
real-time versions a real-time

00:19:42.520 --> 00:19:44.340
signal delivery mechanism.

00:19:44.340 --> 00:19:48.540
We've looked at that, and we've decided,
well, you know, we like the 128.

00:19:48.540 --> 00:19:49.830
That sounds pretty good.

00:19:49.970 --> 00:19:53.610
But the real-time delivery kind of
conflicts with some of the real-time

00:19:53.660 --> 00:19:58.120
behaviors that we have for other things,
and in particular,

00:19:58.120 --> 00:20:02.970
conflict with some of the run
loop support and things like that.

00:20:02.980 --> 00:20:05.970
And so we're probably not
going to delve into that world.

00:20:08.430 --> 00:20:09.800
Alright, so now we have processes.

00:20:09.800 --> 00:20:13.400
Processes are basically an
area in which threads run.

00:20:13.400 --> 00:20:15.330
So let's talk about threads.

00:20:15.340 --> 00:20:17.880
Well, every thread in the
system is a Mach thread,

00:20:17.880 --> 00:20:18.480
pretty much.

00:20:18.480 --> 00:20:23.340
There are some things that people
call threads at some of the higher

00:20:23.340 --> 00:20:26.580
level that aren't fully Mach threads,
but everything you're going to

00:20:26.580 --> 00:20:28.120
typically deal with is a Mach thread.

00:20:28.120 --> 00:20:31.630
A Mach thread is the unit
of execution in the system.

00:20:31.640 --> 00:20:34.100
It's what the scheduler schedules.

00:20:34.100 --> 00:20:37.840
It owns no resources of its own.

00:20:37.860 --> 00:20:40.260
It is simply a state.

00:20:40.360 --> 00:20:44.590
It describes an execution
state within a set of resources

00:20:44.590 --> 00:20:46.820
that's a task or a process.

00:20:46.820 --> 00:20:50.450
It defines the how and
the where of execution,

00:20:50.450 --> 00:20:52.870
but not what to execute with.

00:20:55.050 --> 00:20:59.070
There's thread-specific exception
handling at the Mach level.

00:20:59.210 --> 00:21:01.500
So you can grab exception handlers.

00:21:01.500 --> 00:21:04.030
You know, you can register exception
handlers at the per-thread

00:21:04.030 --> 00:21:05.200
level and do certain things.

00:21:05.200 --> 00:21:09.260
A lot of you may be tool writers,
and this has been something that

00:21:09.260 --> 00:21:14.950
people have been doing is grabbing
the Mach exceptions basically before

00:21:14.950 --> 00:21:19.200
BSD gets them so that they don't
become signals and kill the process

00:21:19.200 --> 00:21:21.810
out from underneath of your tools.

00:21:21.830 --> 00:21:26.200
And thread T is the basic data
structure that's defined there.

00:21:26.200 --> 00:21:28.260
And again, you can create and terminate.

00:21:28.260 --> 00:21:32.480
Again, one of the generic differences
between BSD services and

00:21:32.480 --> 00:21:37.290
Mach services is Mach services
are always third-party enabled.

00:21:37.300 --> 00:21:44.340
So any process can reach out and do all
the Mach services to some other entity.

00:21:44.340 --> 00:21:46.060
They don't have to just
do it to themselves.

00:21:46.080 --> 00:21:52.220
And that provides a real carrot for
people to delve into the Mach services

00:21:52.240 --> 00:21:55.740
because you can reach over and
manipulate this other address space,

00:21:55.740 --> 00:21:59.890
or you can reach over and stop this other
thread without the thread's consent and

00:21:59.890 --> 00:22:03.490
doing things like that if you have the
privileged port that lets you do it.

00:22:03.580 --> 00:22:07.740
So people have been striving to
find ways to get those privileged

00:22:07.850 --> 00:22:09.100
ports so that they can do this.

00:22:09.100 --> 00:22:11.640
We urge you to be careful.

00:22:11.640 --> 00:22:18.950
When you manipulate something out from
underneath of itself without its consent,

00:22:18.980 --> 00:22:19.040
it's not going to work.

00:22:19.040 --> 00:22:21.810
And often you're going to get
in trouble with the higher-level

00:22:21.810 --> 00:22:25.760
services that are depending upon
a known state in that thing.

00:22:25.760 --> 00:22:29.190
But one of the things you can
do and is fairly well-defined

00:22:29.200 --> 00:22:30.100
is the exception handling.

00:22:32.880 --> 00:22:39.770
is the developer of the kernel,
and he's going to talk

00:22:39.770 --> 00:22:39.770
about the kernel system.

00:22:39.950 --> 00:22:43.930
All right, and it's our portable layer
of threading in the system.

00:22:43.930 --> 00:22:47.500
You can pretty much create a
Pthread at any level of our system

00:22:47.500 --> 00:22:51.720
and any application space and
get fairly well-defined behavior.

00:22:51.740 --> 00:22:58.040
Not only do they provide, you know,
an easier way to create and set

00:22:58.040 --> 00:23:02.420
them up than the Mach threads,
because Mach threads have no resources,

00:23:02.420 --> 00:23:03.700
Pthreads have resources.

00:23:03.700 --> 00:23:05.950
And so you can just tell Pthreads,
create one,

00:23:05.950 --> 00:23:08.840
and it creates the resources for you,
rather than you having

00:23:08.840 --> 00:23:09.840
to do that manually.

00:23:09.900 --> 00:23:13.890
It also provides synchronization,
which the Mach threads don't

00:23:13.890 --> 00:23:17.680
have any native form of
synchronization inside a process.

00:23:17.760 --> 00:23:22.440
They simply can use global
synchronization services,

00:23:22.440 --> 00:23:25.450
but they don't have anything
inherent to the process.

00:23:25.460 --> 00:23:29.220
And Pthreads adds, you know,
synchronizers in the form

00:23:29.240 --> 00:23:30.860
of mutexes and conditions.

00:23:30.860 --> 00:23:36.060
You've got thread-specific
resources as well.

00:23:36.060 --> 00:23:39.480
You've got a stack,
and you've got per-thread data.

00:23:41.300 --> 00:23:44.260
And basically, you can do the standard
Pthreads things with those.

00:23:44.260 --> 00:23:47.240
At the higher levels,
I don't want to spend a

00:23:47.330 --> 00:23:52.960
whole lot of time on this,
but each MP task or Carbon thread

00:23:52.960 --> 00:23:56.000
has essentially a Pthread underneath,
and that has a Mach thread

00:23:56.180 --> 00:23:57.150
underneath of it.

00:23:57.190 --> 00:24:03.030
But there are some situations like
deferred threads in the IOSpace

00:24:03.030 --> 00:24:08.090
at Carbon and others where certain
behaviors are dependent upon,

00:24:08.220 --> 00:24:12.170
right, of those threads,
and they may be multiplex,

00:24:12.240 --> 00:24:14.450
so you may have deferred work.

00:24:14.540 --> 00:24:18.000
There may be one worker thread
doing all the deferred thread work

00:24:18.100 --> 00:24:20.760
inside of a Carbon application,
so you've got to be careful,

00:24:20.760 --> 00:24:24.130
especially in those environments,
not to do something to the thread

00:24:24.140 --> 00:24:27.820
that will affect other things that
depend upon using that same thread.

00:24:29.570 --> 00:24:31.140
What's new in threading in Jaguar?

00:24:31.140 --> 00:24:32.480
Performance.

00:24:32.480 --> 00:24:36.820
Again, faster creation,
faster termination of threads.

00:24:36.820 --> 00:24:40.750
So you can create almost two
times as many threads per second

00:24:40.760 --> 00:24:44.740
in Jaguar as you could in 10.1.

00:24:44.740 --> 00:24:47.680
P-thread synchronizers.

00:24:47.680 --> 00:24:51.840
Well, we now have read-write locks at
the P-thread level in Jaguar.

00:24:51.840 --> 00:24:55.900
We have recursive mutexes,
or we will be having recursive

00:24:55.900 --> 00:24:57.080
mutexes in the near future.

00:24:58.560 --> 00:25:03.510
And we have, or will be having improved
P-thread cancel semantics as well.

00:25:03.560 --> 00:25:05.550
More adherent to the standards.

00:25:05.590 --> 00:25:09.440
But a big thing we have that
a lot of people have asked

00:25:09.490 --> 00:25:10.900
for is per-thread signals.

00:25:10.900 --> 00:25:13.820
And so that's in Jaguar
or on the CD you've got.

00:25:13.860 --> 00:25:14.930
Thank you.

00:25:15.820 --> 00:25:18.740
Where are we going?

00:25:19.050 --> 00:25:22.440
Again, better adherence to the
standards for Pthreads.

00:25:22.490 --> 00:25:27.630
There are certain small APIs that
we're not adherent to at this point.

00:25:27.670 --> 00:25:30.240
Most of the big things I think
we've got covered at this point,

00:25:30.300 --> 00:25:34.200
but we've got some things more to do.

00:25:34.240 --> 00:25:37.700
Another thing we're doing
is at the Mach level,

00:25:37.750 --> 00:25:41.840
there has never been the notion of,
at the thread and task level,

00:25:41.840 --> 00:25:45.840
the ability to look at something
without manipulating it.

00:25:46.020 --> 00:25:51.440
And because of that task for
Pid and the ability to reach out

00:25:51.440 --> 00:25:55.320
and grab third-party threads,
a lot of you are using those

00:25:55.320 --> 00:25:59.740
things to just gather statistics
or to look at their state,

00:25:59.950 --> 00:26:01.740
but not to control them.

00:26:01.890 --> 00:26:04.850
And so we've been looking at and are
probably going to be adding in the

00:26:04.850 --> 00:26:11.400
future the ability to separate those
semantics of access without control.

00:26:12.890 --> 00:26:15.040
But all this just leads to the scheduler.

00:26:15.140 --> 00:26:19.160
Threads are uninteresting
if they don't get scheduled.

00:26:19.160 --> 00:26:24.820
So a lot of you have struggled
with this particular area as well.

00:26:24.820 --> 00:26:28.080
Well, what is all of the scheduling
information inside of Darwin?

00:26:28.080 --> 00:26:28.850
How do you do it?

00:26:28.920 --> 00:26:31.100
How does it affect the
higher-level things?

00:26:31.120 --> 00:26:36.340
Basically, we've got a banded priority
space inside of Darwin,

00:26:36.340 --> 00:26:42.600
and in particular, Mac OS X,
where most of the

00:26:42.600 --> 00:26:44.270
application threads run.

00:26:44.280 --> 00:26:46.470
If you just create something
that runs in the background

00:26:46.480 --> 00:26:49.350
off of a terminal or whatever,
you're going to end up

00:26:49.350 --> 00:26:51.660
in this priority space,
0 to 31,

00:26:51.660 --> 00:26:55.350
where things just get time-shared
in and out in that space,

00:26:55.360 --> 00:26:57.750
which means their priorities
adjust up and down based on the

00:26:57.760 --> 00:26:58.990
amount of CPU they're using.

00:26:59.000 --> 00:27:04.240
And so we kind of be fair at that level.

00:27:04.240 --> 00:27:07.770
But we've added, you know,
the ability to have these

00:27:07.820 --> 00:27:11.500
time-constrained threads,
which are threads which,

00:27:11.520 --> 00:27:14.570
which run under very strict
constraints for real-time.

00:27:14.580 --> 00:27:19.760
You obviously can't allow a real-time
thread to just kind of adjust and

00:27:19.760 --> 00:27:21.390
be fairly scheduled in the system.

00:27:21.400 --> 00:27:27.420
It has to respond to very real-time
events in the outside world under

00:27:27.750 --> 00:27:32.070
time constraints that obviously
that standard kind of adjusting

00:27:32.070 --> 00:27:34.140
time-share policy wouldn't allow.

00:27:34.200 --> 00:27:37.860
And so we've added the ability to
create time-constrained threads.

00:27:37.940 --> 00:27:42.860
You'd specify the constraints,
the kernel, you know,

00:27:42.860 --> 00:27:45.360
the amount of time it
takes for you to execute,

00:27:45.360 --> 00:27:49.260
the amount of time,
the period at which you have to respond,

00:27:49.260 --> 00:27:51.990
and we'll compute a priority for you.

00:27:52.000 --> 00:27:53.700
Right now we do that very simply.

00:27:53.700 --> 00:27:56.160
We assign them all the same priority,
but in the future we're

00:27:56.190 --> 00:27:57.890
actually going to be using that.

00:27:57.940 --> 00:27:59.420
So be careful.

00:27:59.420 --> 00:28:03.490
But anybody can create a
time-constrained thread.

00:28:03.500 --> 00:28:04.790
You can just say, create me one.

00:28:04.800 --> 00:28:08.460
And the reason you can do
that is they're watched.

00:28:08.500 --> 00:28:11.440
We won't allow a time-constrained thread.

00:28:11.440 --> 00:28:14.120
We're not going to allow a
time-constrained thread to take over

00:28:14.230 --> 00:28:15.410
the system and not give it back.

00:28:15.490 --> 00:28:18.990
It can take it over for a little while,
but it'll eventually give

00:28:18.990 --> 00:28:19.440
it back because we watch it.

00:28:19.440 --> 00:28:21.440
There is no portable interface to that.

00:28:21.440 --> 00:28:27.580
You can't--there's no Pthreads or, uh,
uh, Standard POSIX way to

00:28:27.580 --> 00:28:29.410
create one of these threads.

00:28:29.480 --> 00:28:33.150
That's an invention strictly to Darwin.

00:28:33.320 --> 00:28:38.700
And we've also got a band of
priorities for GUI application threads.

00:28:38.700 --> 00:28:44.850
The Windows Server and other things
help assign a set of priorities to

00:28:44.850 --> 00:28:49.670
anything that responds to GUI events,
such that, you know,

00:28:49.770 --> 00:28:52.690
you get quick response to
clicking throughout the system.

00:28:52.900 --> 00:28:56.690
And those tend to fall in
that range from 63 to 31.

00:28:56.810 --> 00:28:59.520
And then we have all these
other magic priority ranges,

00:28:59.700 --> 00:29:04.700
basically where the kernel runs
and where the core services run.

00:29:04.700 --> 00:29:08.470
One of the struggling points
that people have with all of this

00:29:08.970 --> 00:29:11.700
is how do I get in that space?

00:29:11.770 --> 00:29:14.700
And hopefully I can cover
that in a little bit.

00:29:15.010 --> 00:29:19.700
But you can also create fixed
priority threads in the system,

00:29:19.700 --> 00:29:21.520
but...

00:29:22.250 --> 00:29:24.790
There's a problem with those,
and that is that once you

00:29:24.790 --> 00:29:29.710
create a thread fixed,
it can take over the system or anything

00:29:29.800 --> 00:29:35.340
below that and deny anything lower a
priority service throughout the system.

00:29:35.340 --> 00:29:40.530
And so that operation is privileged.

00:29:40.990 --> 00:29:43.420
Basically,
the Mach scheduler assigns threads,

00:29:43.660 --> 00:29:46.780
runnable threads, to processors,
and we do that symmetrically

00:29:46.780 --> 00:29:48.350
on a multiprocessor system.

00:29:48.360 --> 00:29:50.820
So we will run threads on
any available processor.

00:29:50.820 --> 00:29:55.090
But it's tuned for affinity to
try and run the same thread on

00:29:55.100 --> 00:29:58.520
the same processor to keep the
same cache set and other things.

00:29:59.930 --> 00:30:04.280
It's a fully preemptive scheduler,
which means that whenever a

00:30:04.280 --> 00:30:07.260
higher priority thread gets
set running in the system,

00:30:07.380 --> 00:30:13.410
it will preempt immediately any user
level thread that is available at a

00:30:13.680 --> 00:30:16.360
lower priority that's taking a CPU.

00:30:16.470 --> 00:30:19.760
And it'll also preempt threads
that are running in the kernel,

00:30:19.980 --> 00:30:25.140
but only if the thread waking up
is marked as a real-time thread.

00:30:27.200 --> 00:30:31.470
BSD adds some things on top of that,
and mostly in the realm of Pthreads,

00:30:31.470 --> 00:30:35.240
the ability to set via Pthreads
the scheduling attributes.

00:30:35.240 --> 00:30:39.980
But one of the problems with
that model is that it assumes,

00:30:39.980 --> 00:30:44.200
basically the POSIX model assumes
a system-wide view of things,

00:30:44.200 --> 00:30:47.600
that you understand the priority
of everything else in the system,

00:30:47.600 --> 00:30:49.310
and you know exactly
where you want to go,

00:30:49.330 --> 00:30:50.100
right?

00:30:50.100 --> 00:30:51.380
And you can assign your priority.

00:30:52.020 --> 00:30:55.420
Well, in our system,
that's almost impossible to figure out,

00:30:55.510 --> 00:30:58.080
because there's applications
written by many developers running

00:30:58.080 --> 00:31:01.740
on the system at the same time,
so you can't possibly do that.

00:31:01.780 --> 00:31:04.780
So we allow the Pthread
attributes to be used,

00:31:04.780 --> 00:31:10.200
but we restrict it to that range
that's basically for timeshare threads,

00:31:10.200 --> 00:31:14.820
so you can adjust your priorities
using Pthreads within that realm,

00:31:14.820 --> 00:31:20.640
but you can't use that facility
to get yourself up into some of

00:31:20.690 --> 00:31:23.510
the higher levels of the system.

00:31:25.800 --> 00:31:40.200
[Transcript missing]

00:31:45.000 --> 00:33:13.800
[Transcript missing]

00:33:14.960 --> 00:33:24.690
And again, in each environment,
we allow for these time-critical threads,

00:33:24.690 --> 00:33:24.690
but we have this problem with trying to

00:33:24.800 --> 00:33:41.800
[Transcript missing]

00:33:41.990 --> 00:33:46.190
So we have some new things
in Jaguar to go in this area.

00:33:46.330 --> 00:33:53.520
We have better SMP support,
so we will immediately now set a

00:33:53.600 --> 00:33:56.940
higher priority thread running on the
other processor than what was already

00:33:56.940 --> 00:33:58.130
running on the other processor.

00:33:58.140 --> 00:34:00.130
It used to be that would take a while.

00:34:00.140 --> 00:34:03.900
So for some of you that have
real-time apps that need the power

00:34:03.900 --> 00:34:07.740
of both processors in real-time,
this actually provides now

00:34:07.740 --> 00:34:10.050
the ability to do that.

00:34:10.460 --> 00:34:15.390
It also provides stronger affinity
than what used to be in the scheduler,

00:34:15.390 --> 00:34:18.700
so that we will work harder
to keep the same threads

00:34:18.740 --> 00:34:20.860
running on the same processor.

00:34:20.860 --> 00:34:26.500
But obviously we're not going to let that
override the real-time nature of things.

00:34:28.030 --> 00:34:37.400
is the head of the Kernel
Management Team at Mac OS X.

00:34:37.400 --> 00:34:47.530
Jim is the head of the Kernel
Management Team at Mac OS X.

00:34:47.530 --> 00:34:52.790
Jim is the head of the Kernel
Management Team at Mac OS X.

00:34:53.730 --> 00:34:54.730
Future directions.

00:34:54.740 --> 00:34:57.570
Again, enhanced priority inheritance.

00:34:57.580 --> 00:35:02.260
We really are looking for a way
to make sure that we can drive

00:35:02.270 --> 00:35:07.980
threads through to completion,
even though the lower-level threads

00:35:08.040 --> 00:35:10.610
have got something locked in the
kernel that you need or locked

00:35:10.610 --> 00:35:11.880
at user space that you need.

00:35:11.920 --> 00:35:14.900
And we will make that, you know,
in the future,

00:35:14.900 --> 00:35:17.080
we're looking at making that
the default in the system.

00:35:17.080 --> 00:35:21.350
We want real-time behavior out of
the system without programmers having

00:35:21.350 --> 00:35:24.160
to program everything for real time.

00:35:24.160 --> 00:35:29.670
Right now, almost every queuing mechanism
in the system is FIFO,

00:35:29.670 --> 00:35:32.770
which means you get a whole
slew of low-priority threads

00:35:32.770 --> 00:35:33.980
queued up on something.

00:35:33.980 --> 00:35:36.330
High-priority thread
comes along and wants it,

00:35:36.450 --> 00:35:41.080
and it's going to have to wait in turn
for all those low-priority threads,

00:35:41.080 --> 00:35:44.000
except for the processor,
to get that resource.

00:35:44.000 --> 00:35:47.420
And so while we have priority
queuing in the processors,

00:35:47.420 --> 00:35:50.830
we're looking at trying to make
a more widespread use of priority

00:35:50.890 --> 00:35:53.070
queuing throughout the system that,
again,

00:35:53.160 --> 00:35:56.120
give much better real-time response.

00:35:56.260 --> 00:35:59.760
And one of the things we're looking at,
and this is really kind of up in the air,

00:35:59.760 --> 00:36:06.000
is a producer-consumer type queuing
mechanism that will allow you to have

00:36:06.050 --> 00:36:10.400
threads that either feed or suck the
data off of one of these time constraint

00:36:10.400 --> 00:36:14.740
threads in such a way that you don't have
to manually black art set its priority,

00:36:14.740 --> 00:36:19.120
and yet it will adjust its priority
based on its ability to keep up with

00:36:19.210 --> 00:36:24.570
the real-time threads to try and help us
help you get over this problem without

00:36:25.310 --> 00:36:26.180
basically locking in the threads.

00:36:43.810 --> 00:36:52.010
And in the future, we will be, again,
doing real-time critical priorities.

00:36:52.260 --> 00:37:00.610
So don't fake out your time constraints
that you provide to the time

00:37:00.610 --> 00:37:02.880
constraint setting mechanism right now,
because eventually those

00:37:02.880 --> 00:37:02.880
will be used for something.

00:37:03.420 --> 00:37:06.160
The kernel also provides a
bunch of files mechanism.

00:37:06.160 --> 00:37:10.760
The files,
Mac has no notion of what a file is.

00:37:10.760 --> 00:37:12.500
It has no concept of file systems.

00:37:12.500 --> 00:37:16.160
But it has a concept of memory objects,
and it manages all the

00:37:16.170 --> 00:37:17.710
cache data in the system.

00:37:17.740 --> 00:37:19.830
It manages the physical
pages in the system,

00:37:19.840 --> 00:37:25.520
and it manages the logical assignment
of pages to things called objects.

00:37:25.520 --> 00:37:29.570
It will fill all of
memory with cache data,

00:37:29.600 --> 00:37:34.310
unlike a lot of systems that
will only fill 10% of the memory

00:37:34.320 --> 00:37:39.540
with cache data from files,
or 20% or 15%. It will just fill

00:37:39.540 --> 00:37:41.560
up all of memory with cache data.

00:37:41.560 --> 00:37:46.820
This actually is a very nice thing for a
lot of your applications because you have

00:37:46.820 --> 00:37:52.260
very large data sets in some of these,
and restricting you to only small parts

00:37:52.260 --> 00:37:58.520
of the memory for caching tends to be
a performance problem on some systems.

00:37:58.540 --> 00:38:02.560
But it also has its drawbacks,
and so you have to be very careful

00:38:02.560 --> 00:38:08.260
how you manage your data such that
you don't swamp the rest of the

00:38:08.260 --> 00:38:10.110
system and push everything else out.

00:38:10.120 --> 00:38:16.340
All the backing store for all
these pages is managed by pagers.

00:38:16.340 --> 00:38:20.100
And the biggest pager in our system,
or the most common pager,

00:38:20.100 --> 00:38:23.820
is actually the file system
pager that's built into BSD.

00:38:23.820 --> 00:38:26.820
But on top of that,
we also have a default

00:38:26.920 --> 00:38:30.270
pager which swaps files,
swaps pages out that are just

00:38:30.270 --> 00:38:31.800
dynamically allocated in the system.

00:38:32.450 --> 00:38:34.720
And that's called the default pager.

00:38:35.340 --> 00:38:39.330
And how all this works is that
these memory objects then get mapped

00:38:39.330 --> 00:38:41.190
into parts of your address space.

00:38:41.200 --> 00:38:44.230
So it gives you access to these objects.

00:38:44.320 --> 00:38:50.700
If you're not actually mapping the file,
but you're using the file system in BSD,

00:38:50.700 --> 00:38:55.780
each one of these objects can represent,
and often does represent,

00:38:55.780 --> 00:38:58.660
a single VNode or a
single file on the system.

00:38:58.660 --> 00:39:04.940
And so we support traditional
read-write semantics through files,

00:39:05.200 --> 00:39:10.650
by essentially the file system
inside of BSD uses the Mach objects

00:39:10.650 --> 00:39:16.110
and the Mach cache to provide
the data into and store the

00:39:16.110 --> 00:39:19.140
cache data for each of the files,
and we do that through a thing

00:39:19.200 --> 00:39:20.420
called universal buffer cache.

00:39:20.420 --> 00:39:24.390
And that's why you get this ability,
because they're all just

00:39:24.470 --> 00:39:27.570
memory objects in the system,
the ability to just fill up

00:39:27.730 --> 00:39:29.500
memory with all of your caching.

00:39:31.870 --> 00:39:36.490
But it also supports the MMAP semantics
inside of POSIX by essentially

00:39:36.510 --> 00:39:40.360
directly letting you map those
objects into your address space.

00:39:40.360 --> 00:39:44.860
This is what DYLD does and the
loader does in the system to

00:39:44.860 --> 00:39:46.500
just give you your task image.

00:39:46.500 --> 00:39:50.780
But it's also what you can do
manually to get active files.

00:39:52.400 --> 00:39:58.610
And it has a clustering support to
do more efficient loading of that

00:39:58.700 --> 00:40:02.600
data and writing of that data back
to disk with a smaller number of IOs.

00:40:05.580 --> 00:40:08.690
And at the application level,
even higher above,

00:40:08.690 --> 00:40:11.480
you have asynchronous support.

00:40:11.770 --> 00:40:16.240
Well,
the BSD file system is all synchronous.

00:40:16.340 --> 00:40:18.490
All the semantics there are synchronous.

00:40:18.620 --> 00:40:22.100
So you end up having at the higher
levels worker threads that help

00:40:22.210 --> 00:40:24.000
you do asynchronous semantics.

00:40:24.000 --> 00:40:29.050
They emulate the asynchronous behavior.

00:40:29.920 --> 00:40:33.830
There's also the ability to
access additional data from

00:40:34.380 --> 00:40:35.910
traditional file systems.

00:40:35.920 --> 00:40:40.250
You can access the resource
forks and things like that,

00:40:40.730 --> 00:40:43.210
which are all... Oh, I'm sorry.

00:40:43.250 --> 00:40:43.870
Wrong one.

00:40:44.210 --> 00:40:49.950
Because at the BSD level,
you don't have a notion of

00:40:49.950 --> 00:40:52.240
separate seek pointers on a file.

00:40:52.240 --> 00:40:54.210
You have a file that has
a current seek pointer,

00:40:54.210 --> 00:40:57.420
but the higher-level
application semantics,

00:40:57.700 --> 00:41:03.200
both in Carbon and in Cocoa,
had the ability to give you

00:41:03.200 --> 00:41:06.390
access to ranges of files,
and you can have multiple

00:41:07.090 --> 00:41:09.940
threads coming in and trying to
simultaneously access a file.

00:41:09.940 --> 00:41:16.750
You needed to lock things out at user
space and arbitrate over the control

00:41:16.760 --> 00:41:20.600
of where the current seek pointer is
for a file to try and keep threads

00:41:20.600 --> 00:41:24.060
from fighting over it and moving it
out from underneath of each other.

00:41:24.140 --> 00:41:27.500
And that was all handled
at the higher levels.

00:41:27.500 --> 00:41:32.170
And then you had the legacy
emulation for things that some of

00:41:32.220 --> 00:41:35.700
our file systems just can't support,
some of the resource forks and

00:41:35.700 --> 00:41:37.800
catalog search kind of things.

00:41:38.600 --> 00:42:43.600
[Transcript missing]

00:42:46.820 --> 00:42:49.680
And if you implement some-- one of
the things that comes along with that

00:42:49.740 --> 00:42:53.380
is if you are a file system writer,
we've noticed at least in

00:42:53.440 --> 00:42:57.050
several of the file systems
that people have written so far,

00:42:57.240 --> 00:42:59.390
that they were not expecting
these larger page lists,

00:42:59.460 --> 00:43:02.140
these larger clusters
to be coming through,

00:43:02.280 --> 00:43:04.910
and it confused them a little
bit in their implementation,

00:43:04.910 --> 00:43:07.600
so you might want to watch out for that.

00:43:07.780 --> 00:43:12.270
But one of the things we've also added is
in the POSIX PREAD and PWRITE semantics,

00:43:12.300 --> 00:43:17.100
or APIs, that now gets us away from that
locked-out file seek pointer

00:43:17.100 --> 00:43:19.300
problem that I talked about earlier.

00:43:19.390 --> 00:43:23.400
You no longer have a single
current offset in a file.

00:43:23.400 --> 00:43:26.980
These calls take the offset
as part of the parameter,

00:43:27.080 --> 00:43:27.140
right?

00:43:27.140 --> 00:43:31.580
And so now multiple threads can issue
I/Os to the same file simultaneously

00:43:31.580 --> 00:43:34.720
to different parts of the file,
and the system will deal

00:43:34.720 --> 00:43:36.390
with that just fine.

00:43:37.490 --> 00:43:38.810
Where are we going?

00:43:38.930 --> 00:43:41.400
Obviously, caching is important.

00:43:41.450 --> 00:43:43.300
Performance going to
the disk is important,

00:43:43.300 --> 00:43:47.210
so our clustering and caching
is something that we're gonna be

00:43:47.210 --> 00:43:48.960
working on for quite a while now.

00:43:48.960 --> 00:43:53.880
This is one of the biggest areas
that you notice performance.

00:43:54.080 --> 00:43:57.380
And we're headed towards true async
file I/O so that we can get rid

00:43:57.380 --> 00:44:01.920
of those worker threads at user
space and do everything directly

00:44:02.060 --> 00:44:05.110
through the kernel async support.

00:44:05.700 --> 00:44:17.600
[Transcript missing]

00:44:19.110 --> 00:44:21.700
But again,
the file system is only as good as

00:44:21.700 --> 00:44:25.940
the virtual memory system because it's
housed on the virtual memory system.

00:44:26.030 --> 00:44:29.940
All right, and Mac basically creates this
very complex view of the world.

00:44:29.940 --> 00:44:32.140
You have objects mapped
into the address spaces.

00:44:32.140 --> 00:44:36.260
The objects are backed by files
which are implemented by pagers

00:44:36.260 --> 00:44:38.860
inside the BSD file system,
which use clustering to get

00:44:38.860 --> 00:44:42.150
to the disk to do their work.

00:44:42.650 --> 00:44:46.170
And Mac basically is the
arbiter of all of that.

00:44:46.650 --> 00:44:50.120
All right, it allows every address space
to be laid out uniquely and in

00:44:50.120 --> 00:44:54.270
a pattern of their own choosing,
mapping objects and creating

00:44:54.270 --> 00:44:56.910
anonymous memory however they like.

00:44:58.430 --> 00:45:02.760
provides protected address spaces so
that what I have mapped into my address

00:45:02.760 --> 00:45:05.150
space is available to everyone else.

00:45:05.150 --> 00:45:09.680
So I can map that file without worrying
about someone who doesn't have access

00:45:09.680 --> 00:45:11.510
to that file getting at the data.

00:45:14.300 --> 00:45:17.710
It has these copy-on-write
optimizations that are well

00:45:17.710 --> 00:45:20.900
published inside of it for mapping.

00:45:20.900 --> 00:45:26.260
It's mostly good for mapping
copies of text and copies of data

00:45:26.370 --> 00:45:31.610
from files into address spaces in
such a way that as you-- for text,

00:45:31.610 --> 00:45:33.640
you typically don't touch it at all.

00:45:33.830 --> 00:45:37.310
But you may when a debugger comes along,
and you would really hate to have

00:45:37.310 --> 00:45:41.460
a debugger write a break point
into a mapped file and actually

00:45:41.490 --> 00:45:43.400
have that show up on the file.

00:45:43.410 --> 00:45:46.090
That would be very, very bad.

00:45:46.230 --> 00:45:49.300
And so you essentially,
whenever an executable is

00:45:49.380 --> 00:45:52.810
mapped into the system,
it's mapped in copy-on-write just in case

00:45:52.870 --> 00:45:55.600
somebody's gonna come along and touch it.

00:45:55.600 --> 00:45:57.600
And so from an
optimization point of view,

00:45:57.640 --> 00:46:03.610
that is dramatically better
than going ahead and pulling in,

00:46:03.610 --> 00:46:05.670
you know,
unique copies of those things for

00:46:05.710 --> 00:46:08.790
every instance that's running.

00:46:09.820 --> 00:46:13.540
And it allows for controlled
sharing at various levels,

00:46:13.540 --> 00:46:18.250
single-page level,
sharing ranges of a mapped file,

00:46:18.250 --> 00:46:20.840
to sharing complex regions.

00:46:20.860 --> 00:46:24.210
And in fact, we do that in the system.

00:46:24.220 --> 00:46:26.300
As you noticed,
we have a lot of frameworks

00:46:26.870 --> 00:46:30.100
inside of our system that most
applications are using all of them,

00:46:30.100 --> 00:46:31.830
or a large portion of them.

00:46:31.840 --> 00:46:36.820
Just the overhead of mapping in 127
or 100 and something frameworks into

00:46:36.820 --> 00:46:39.400
every application is part of launching.

00:46:40.120 --> 00:46:40.340
Right?

00:46:40.340 --> 00:46:42.680
Can be a fairly onerous task.

00:46:42.800 --> 00:46:46.040
And so we optimize that for you.

00:46:46.040 --> 00:46:47.850
We have a shared region in the system.

00:46:47.860 --> 00:46:51.330
This is optional use,
but the linker currently

00:46:51.330 --> 00:46:54.580
at the higher level,
DYLD, uses it fairly heavily.

00:46:54.580 --> 00:46:59.420
That allows you to have global regions
that are mapped into everybody.

00:46:59.420 --> 00:47:02.590
And that's where he maps
in all of the frameworks.

00:47:02.660 --> 00:47:06.140
So that everybody gets a
shared mapping of that.

00:47:08.040 --> 00:47:10.550
And the way that works is,
you come along and let's

00:47:10.550 --> 00:47:11.620
just look at the global part.

00:47:11.660 --> 00:47:17.640
Again, behind every mapping is an object,
and behind the object is

00:47:17.640 --> 00:47:21.280
a pager memory object,
and that may go to the disk, right?

00:47:21.280 --> 00:47:23.710
But you take a fault
in one of those areas,

00:47:23.720 --> 00:47:24.340
right?

00:47:24.340 --> 00:47:27.840
Well, normally, every application,
when it takes a fault,

00:47:27.840 --> 00:47:31.370
would query the VM system,
would handle the fault, and say, okay,

00:47:31.380 --> 00:47:32.760
what file is mapped there?

00:47:32.760 --> 00:47:36.220
Here he realizes that it's a
global region that's mapped there,

00:47:36.820 --> 00:47:41.820
and he sends the request on to the global
region who forwards it on to the object,

00:47:41.820 --> 00:47:47.220
who creates a mapping
for a temporary file,

00:47:47.220 --> 00:47:48.300
basically a placeholder.

00:47:48.300 --> 00:47:52.500
But unlike normal,
this actually shows up in every

00:47:52.500 --> 00:47:56.360
address space at the same time
because it's a true shared mapping.

00:47:56.360 --> 00:47:58.920
So everybody gets the placeholder.

00:47:58.920 --> 00:48:02.360
One guy's driving the fault,
but when the data is finally

00:48:02.470 --> 00:48:06.660
supplied by the pager,
it shows up everywhere and it's a very,

00:48:06.660 --> 00:48:07.740
very good example of how to do this.

00:48:07.740 --> 00:48:10.150
Typically, if I have a file and you
have the same file mapped,

00:48:10.240 --> 00:48:14.110
when I take a fault,
I would get a translation for my

00:48:14.110 --> 00:48:17.370
page that lets me access that,
but you don't.

00:48:17.480 --> 00:48:20.980
And so when you access it,
you would have to go

00:48:20.980 --> 00:48:22.380
and go to the VM system.

00:48:22.380 --> 00:48:24.020
He says, oh, the page is in cache.

00:48:24.020 --> 00:48:24.760
That's no problem.

00:48:24.760 --> 00:48:26.000
Here's a translation.

00:48:26.000 --> 00:48:29.770
But you still have to take a fault,
right, for it to find it and provide

00:48:29.770 --> 00:48:31.300
a translation unique to you.

00:48:31.300 --> 00:48:35.640
Because these global regions are shared,
the translations are shared,

00:48:35.740 --> 00:48:40.630
so any application faulting in a page
from the core foundation or from the

00:48:40.630 --> 00:48:44.380
system framework actually makes that page
immediately available to everybody so

00:48:44.380 --> 00:48:46.540
they don't even have to take the faults.

00:48:48.210 --> 00:48:52.640
So where are those areas
located in the system?

00:48:52.640 --> 00:48:58.700
Well, in 10.1,
there was two 256-megabyte regions where

00:48:58.700 --> 00:49:03.550
they sat at 7 bazillion and 8 bazillion,
respectively.

00:49:03.820 --> 00:49:10.400
All right.

00:49:11.570 --> 00:49:11.570
And these map the system-wide frameworks,
right, and gave you that multiple

00:49:11.570 --> 00:49:11.570
level of efficiency.

00:49:11.770 --> 00:49:14.350
But they kind of got in your way,
didn't they?

00:49:14.350 --> 00:49:18.800
If you needed to allocate large
portions of virtually contiguous memory,

00:49:18.800 --> 00:49:24.810
we didn't leave you very many big open
spaces with the way this was laid out.

00:49:26.360 --> 00:49:28.530
So in Jaguar, we're moving them.

00:49:28.600 --> 00:49:32.690
Right now,
they're moved up a little bit so that

00:49:32.690 --> 00:49:36.900
you now have just under 2 gigabytes
of available space to you maximum,

00:49:36.900 --> 00:49:40.020
you know,
between your heaps and these spaces.

00:49:40.020 --> 00:49:47.900
We've also dramatically improved the
ability of the system to determine

00:49:47.900 --> 00:49:50.420
what you're using in your space.

00:49:50.420 --> 00:49:52.040
So we have task-working sets.

00:49:52.040 --> 00:49:55.890
They were in 10.1,
but they've been enhanced in

00:49:55.910 --> 00:50:00.080
Jaguar to do a better job of,
if you touch one page,

00:50:00.080 --> 00:50:03.280
knowing what pages you touched
around that same page last time,

00:50:03.280 --> 00:50:07.410
and getting them all in at the same
time so that you don't have to take

00:50:07.410 --> 00:50:11.500
a fault on every page you access if
you're needing to bring pages in.

00:50:11.500 --> 00:50:15.840
So when you get to the point where
you launch the N plus 1 application,

00:50:15.840 --> 00:50:18.140
where N fits in memory
and N plus 1 doesn't,

00:50:18.240 --> 00:50:21.770
this dramatically improves your
ability to switch back and forth

00:50:21.880 --> 00:50:23.140
between those applications.

00:50:25.800 --> 00:50:29.030
And also there's preheat,
so that we know when you've done

00:50:29.160 --> 00:50:32.830
this once on an application,
that when you come along and

00:50:32.840 --> 00:50:36.530
launch that application again,
we actually don't have to

00:50:36.660 --> 00:50:39.400
build up the working set,
the initial working set.

00:50:39.420 --> 00:50:42.340
It's already there and
remembered from the last time,

00:50:42.380 --> 00:50:44.870
so we'll go ahead and
use that to bring in.

00:50:45.010 --> 00:50:48.350
So second and third and fourth
launches are dramatically faster than

00:50:48.460 --> 00:50:51.590
the first ever for an application.

00:50:52.100 --> 00:51:03.000
[Transcript missing]

00:51:03.400 --> 00:51:27.200
[Transcript missing]

00:51:27.400 --> 00:51:47.600
[Transcript missing]

00:51:48.480 --> 00:51:50.090
Okay, so now we've got this task.

00:51:50.170 --> 00:51:50.560
We're running.

00:51:50.560 --> 00:51:54.400
We're doing all kinds of fun stuff,
but we're in a little silo.

00:51:54.400 --> 00:51:57.050
We can't interact with
anything else in the system.

00:51:57.060 --> 00:52:01.040
So we've got to have
inter-process communication in

00:52:01.080 --> 00:52:03.060
order for everything to work.

00:52:03.140 --> 00:52:09.960
A lot of the system depends upon Mac's
basic inter-process communication system,

00:52:09.960 --> 00:52:10.900
which is a Mac port.

00:52:10.920 --> 00:52:13.480
Sorry.

00:52:13.480 --> 00:52:16.550
They're the endpoints of
communication within Mac.

00:52:16.620 --> 00:52:20.310
They allow you to send messages
back and forth on message queues

00:52:20.310 --> 00:52:23.310
or semaphores or lock sets,
basically synchronization

00:52:23.310 --> 00:52:24.560
at those levels.

00:52:26.540 --> 00:52:30.320
A Mac port is actually-- you
don't access a Mac port directly.

00:52:30.450 --> 00:52:31.820
That's the endpoint.

00:52:31.820 --> 00:52:34.150
What you have is a right to access that.

00:52:34.720 --> 00:52:39.530
And these are represented by
send and receive rights and send

00:52:39.530 --> 00:52:44.930
once rights inside a Mac that
allow you to communicate back

00:52:45.310 --> 00:52:48.460
and forth to various services.

00:52:48.520 --> 00:52:53.440
And in Mac itself,
almost every object in the system,

00:52:53.440 --> 00:52:53.440
a task, a thread, the--

00:52:54.150 --> 00:52:54.780
You name it.

00:52:54.780 --> 00:52:56.480
VM object, those kind of things.

00:52:56.630 --> 00:52:58.340
They're all represented by ports.

00:52:58.340 --> 00:53:01.880
So in order to manipulate them,
you have to have a right to the port

00:53:01.880 --> 00:53:04.900
to send a message to the port to say,
change yourself.

00:53:04.900 --> 00:53:08.150
And that's how you get that third-party,
anybody can change

00:53:08.150 --> 00:53:09.860
anybody else's behavior.

00:53:11.330 --> 00:53:14.780
And these messages carry data,
they carry port rights,

00:53:14.780 --> 00:53:19.110
and they also carry security information
to identify who the sender is.

00:53:20.800 --> 00:53:25.440
And BSD adds, you know,
typical BSD IPC services on top of that,

00:53:25.440 --> 00:53:30.010
sockets and pipes, POSIX semaphores,
both named and unnamed.

00:53:30.020 --> 00:53:35.010
And Pthread synchronizers,
which have options to be

00:53:35.480 --> 00:53:37.910
inter-process communication as well.

00:53:37.920 --> 00:53:40.930
Right now,
those are all implemented on top of

00:53:40.930 --> 00:53:46.700
Mach ports in such a way that it is very
difficult for us to export them across.

00:53:46.760 --> 00:53:49.590
So right now,
all the Pthread synchronizers

00:53:49.590 --> 00:53:52.170
are only intra-process,
so you can only use

00:53:52.170 --> 00:53:53.460
them within a process.

00:53:53.460 --> 00:53:56.060
All the options to go
cross-processes are disabled.

00:53:58.340 --> 00:54:02.010
and then you have these
higher level concepts of IPC,

00:54:02.010 --> 00:54:03.490
like the CFRunLoop, right?

00:54:03.500 --> 00:54:06.240
And the CFRunLoop is all built
on the Mac side of things,

00:54:06.290 --> 00:54:07.000
right?

00:54:07.000 --> 00:54:09.800
So you have a port set, right,
which is a collection of ports.

00:54:09.900 --> 00:54:13.540
Each port represents an object
or an event source in the system.

00:54:16.710 --> 00:54:20.980
And so you sit and wait for a Mach event,
Mach port event to occur.

00:54:20.980 --> 00:54:25.370
Well, a lot of the driving events,
a lot of the things that drive these

00:54:25.370 --> 00:54:27.090
events are not Mach port based.

00:54:27.100 --> 00:54:32.400
And so the CF code and CF networking
and CF socket and those things reflect

00:54:32.400 --> 00:54:36.140
events from those into the port set,
right,

00:54:36.140 --> 00:54:41.190
via worker threads or via call outs or
whatever it can work out to do that.

00:54:41.200 --> 00:54:44.730
Most often it's a thread, right,
to drive it into the run loop so

00:54:44.730 --> 00:54:46.360
that you can see it in your run loop.

00:54:48.300 --> 00:54:58.300
[Transcript missing]

00:54:58.510 --> 00:55:03.090
We have, again, from System 5,
we have the System 5 IPC, thanks to the

00:55:03.090 --> 00:55:07.000
Darwin Development Organization,
the Darwin community.

00:55:07.000 --> 00:55:10.520
Again, we'd like that to be
for compatibility only,

00:55:10.520 --> 00:55:11.100
but it's there.

00:55:12.890 --> 00:55:14.840
Where are we going?

00:55:14.970 --> 00:55:18.900
Well, one of the things that we're
doing from the BSD side is looking

00:55:18.900 --> 00:55:21.940
at adding the pole interface.

00:55:21.940 --> 00:55:23.940
There's lots of things
in the way of doing that,

00:55:23.940 --> 00:55:25.930
and so we've got to
work those issues out,

00:55:25.940 --> 00:55:27.600
but we'd really like to do it.

00:55:27.710 --> 00:55:30.040
In fact, you know,
we'd also like to look at

00:55:30.040 --> 00:55:33.720
adding the BSD KQ support.

00:55:33.720 --> 00:55:37.950
One of the things that looks really nice
about that is it looks like it could be

00:55:37.950 --> 00:55:41.790
interchangeable with run loops in such
a way that you can choose to either use

00:55:41.790 --> 00:55:47.770
a run loop to do your event processing
or you could use to do a KQ to do it,

00:55:48.310 --> 00:55:52.280
depending upon the semantics of your app,
and still have the same event

00:55:52.280 --> 00:55:54.360
sources providing data into both.

00:55:54.420 --> 00:55:57.800
That's really just
something we're considering,

00:55:57.800 --> 00:55:59.930
but it actually looks pretty good.

00:56:02.460 --> 00:56:07.480
And more directly, you know, first,
we're looking at ways to do the

00:56:07.480 --> 00:56:09.560
POSIX inter-process synchronizers.

00:56:11.020 --> 00:56:16.180
And again, real-time being a key
factor in all of this,

00:56:16.180 --> 00:56:18.800
we're looking at
inter-process communication.

00:56:19.110 --> 00:56:20.820
security in the system.

00:56:20.840 --> 00:56:23.560
Nothing here.

00:56:23.560 --> 00:56:25.700
Now that you can share
and you're isolated,

00:56:25.700 --> 00:56:27.820
now you have to be able to
do it in a controlled way.

00:56:27.840 --> 00:56:31.140
Mac itself does no
authentication checking.

00:56:31.140 --> 00:56:34.340
Everything it does is
based on capabilities.

00:56:34.340 --> 00:56:37.230
If you have a port to
manipulate something,

00:56:37.290 --> 00:56:38.390
you can do it.

00:56:38.600 --> 00:57:17.900
[Transcript missing]

00:57:18.330 --> 00:57:23.170
is the developer who runs the kernel.

00:57:23.170 --> 00:57:29.240
He's been working on the
kernel for a long time.

00:57:29.400 --> 00:57:35.220
He's been working on the
kernel for a long time.

00:57:35.220 --> 00:57:35.220
He's been working on the
kernel for a long time.

00:57:35.220 --> 00:57:35.220
He's been working on the
kernel for a long time.

00:57:35.330 --> 00:57:38.140
Right,
and the V nodes inside of BSD provide

00:57:38.140 --> 00:57:43.080
the cache of all of the permission
information from the file systems itself.

00:57:43.150 --> 00:57:46.690
I won't be going into how
file systems do all of that.

00:57:46.910 --> 00:57:52.000
But again, Mac OS X applications are much
more than just BSD processes.

00:57:52.000 --> 00:57:55.660
And so there's additional security
semantics that are added on that,

00:57:55.660 --> 00:57:58.730
and they interact with the
kernel services in certain ways.

00:57:58.760 --> 00:58:02.810
One of the things that happens is
individual applications now have

00:58:02.810 --> 00:58:06.280
unique capabilities in Mac OS X,
right?

00:58:06.280 --> 00:58:07.440
Not just users.

00:58:07.440 --> 00:58:11.260
So you can have an application
that has a keychain item,

00:58:11.260 --> 00:58:12.360
right?

00:58:12.360 --> 00:58:18.230
And that keychain item allows it to
decrypt a file or do a certain operation,

00:58:18.230 --> 00:58:19.200
right?

00:58:19.200 --> 00:58:21.180
And these have to be protected.

00:58:21.180 --> 00:58:25.800
This is somewhat contrary to the
typical BSD model where every

00:58:26.250 --> 00:58:27.980
process owned by a user is equal.

00:58:27.980 --> 00:58:32.530
You don't have to protect any one process
from another process at that user level,

00:58:32.530 --> 00:58:33.120
right?

00:58:34.400 --> 00:58:45.300
[Transcript missing]

00:58:45.850 --> 00:58:47.200
What's new in the security world?

00:58:47.200 --> 00:58:50.320
Well, at the Mach level,
we've got security tokens added,

00:58:50.320 --> 00:58:55.270
and the CFRunLoop provides those so that
people can do authorization on anything

00:58:55.350 --> 00:58:57.100
that's mock-based at the CF level.

00:58:58.530 --> 00:58:59.900
Where are we going?

00:58:59.900 --> 00:59:03.590
Again, we're probably going to split
some of the Mach capabilities up,

00:59:03.710 --> 00:59:05.950
especially in the thread
and task name port world.

00:59:07.400 --> 00:59:10.160
And one of the big E's,
we're going to be restricting tasks

00:59:10.160 --> 00:59:14.390
for PID in such a way that you
won't be able to reach out and grab

00:59:14.390 --> 00:59:19.980
another task and manipulate it
without some kind of authorization,

00:59:19.980 --> 00:59:26.810
some kind of privilege,
in order to protect those higher-level

00:59:26.810 --> 00:59:26.810
keys from the application level.

00:59:27.240 --> 00:59:31.260
And we've got people that are looking
at the system in a way to determine

00:59:31.280 --> 00:59:37.400
if it's evaluatable in a secure way,
and we'll be looking at bringing some

00:59:37.400 --> 00:59:40.790
of those changes into the base system.

00:59:41.570 --> 00:59:46.080
We've got a new,
from serviceability part of the system,

00:59:46.080 --> 00:59:48.460
we've got some new things.

00:59:48.460 --> 00:59:50.640
We've got a new panic user experience.

00:59:50.640 --> 00:59:52.620
We don't want the user to
ever experience a panic.

00:59:52.620 --> 00:59:56.320
But the old panic was really bad.

00:59:56.350 --> 01:00:00.140
It just scrolled over your screen
and just spewed data all over.

01:00:00.140 --> 01:00:02.550
Now you've got a nice
little UI that pops up.

01:00:02.630 --> 01:00:05.940
The panic data is saved
and captured on the reboot.

01:00:05.940 --> 01:00:09.480
And so you can just cut and
paste a report and send it off.

01:00:09.600 --> 01:00:13.360
You don't have to type in or copy the
data off the screen or take a digital

01:00:13.360 --> 01:00:14.990
picture of the screen and send it in.

01:00:18.820 --> 01:00:24.020
Again, we don't want users to ever panic,
but... All right.

01:00:24.020 --> 01:00:32.640
And for people who write kernel services,
we've now got additional

01:00:32.640 --> 01:00:34.250
debugger support,
including the ability to debug

01:00:34.250 --> 01:00:34.250
across routers and things like that
so the debugger can handle arping.

01:00:35.700 --> 01:00:38.890
And we've got K-Trace support
in the system as well,

01:00:38.890 --> 01:00:42.010
so now you can trace things
using standard K-Trace tools.

01:00:45.230 --> 01:00:47.540
Which leads us to KEXT services.

01:00:47.540 --> 01:00:53.230
We've got, in Darwin,
we've got these KEXTs.

01:00:53.910 --> 01:00:55.700
And IOK KEXTs.

01:00:55.920 --> 01:00:58.080
We've always discouraged writing KEXTs.

01:00:58.210 --> 01:00:59.900
If you can do it at user level,
please do,

01:00:59.900 --> 01:01:05.080
because we don't want to repeat
the behavior and the instability

01:01:05.080 --> 01:01:09.220
of 9 by having everything everyone
does written as a KEXT that can

01:01:09.220 --> 01:01:10.240
bring the whole system down.

01:01:10.260 --> 01:01:15.450
But we understood that most IOK things
needed to be done as a KEXT,

01:01:15.480 --> 01:01:18.400
right, or a large number of them anyway,
right?

01:01:18.400 --> 01:01:20.980
And we expected most
KEXTs to be IOK KEXTs.

01:01:21.040 --> 01:01:25.150
But we've done it in such a way that
most of the hard work is done in

01:01:25.150 --> 01:01:29.020
abstracted families and things like that,
so the actual KEXT is fairly small

01:01:29.020 --> 01:01:31.260
and can be rigorously tested.

01:01:31.260 --> 01:01:35.070
But then we've got all these other KEXTs,
right?

01:01:35.080 --> 01:01:38.820
We've got BSD KEXTs that do
file systems and do networking,

01:01:38.820 --> 01:01:39.400
right?

01:01:39.400 --> 01:01:42.180
And BSD is BSD.

01:01:42.180 --> 01:01:44.820
It's a traditional kernel,
opened up to the world,

01:01:44.820 --> 01:01:47.190
so anyone can reach in and
do anything they wanted.

01:01:47.200 --> 01:01:50.220
And it was based on that recompile model.

01:01:51.520 --> 01:01:52.530
So what's new?

01:01:52.540 --> 01:01:57.440
Well, non-IO kecks are still
highly discouraged,

01:01:57.440 --> 01:01:58.970
even more so than they used to be.

01:01:59.030 --> 01:02:02.880
And we will preserve the
binary compatibility of those

01:02:02.910 --> 01:02:05.500
kecks for a little while,
probably not much beyond

01:02:05.500 --> 01:02:06.980
this current release.

01:02:06.980 --> 01:02:09.090
We don't know exactly when,
but at some point,

01:02:09.270 --> 01:02:10.420
those things will break.

01:02:10.500 --> 01:02:13.320
And you'll either have
to keep recompiling them

01:02:13.320 --> 01:02:15.240
with every release or not.

01:02:15.240 --> 01:02:20.880
But we need the ability to,
as some other companies often,

01:02:21.010 --> 01:02:21.970
we need to be able to innovate.

01:02:21.980 --> 01:02:26.370
And so right now,
we're locked out of innovating in

01:02:26.370 --> 01:02:29.630
the kernel because we have kecks
that reach in and grab every little

01:02:29.740 --> 01:02:31.370
private data structure we've got.

01:02:31.400 --> 01:02:34.270
And we don't want to
break those binaries,

01:02:34.280 --> 01:02:36.280
but we're going to have
to in order to go forward.

01:02:36.280 --> 01:02:41.110
And so we're marking all the
non-sustainable APIs inside the

01:02:41.130 --> 01:02:44.640
kernel as such in the header,
so that you'll have to turn

01:02:44.640 --> 01:02:46.670
on a flag basically saying,
I understand.

01:02:46.680 --> 01:02:50.300
I'm no longer using
sustainable interfaces,

01:02:50.500 --> 01:02:51.460
right?

01:02:51.460 --> 01:02:54.080
I'm going to have to figure out
something else to do in the future,

01:02:54.080 --> 01:02:56.720
or I'm going to have to keep
tracking the kernel from release

01:02:56.720 --> 01:02:58.160
to release to release to release.

01:03:00.020 --> 01:03:03.250
So what we're doing in the future then,
we're doing that now,

01:03:03.250 --> 01:03:06.990
and then in the future we're going
to be defining sustainable interfaces

01:03:07.020 --> 01:03:10.680
for those file system and network
kecks so that binaries will be able

01:03:10.680 --> 01:03:13.160
to go forward from release to release.

01:03:13.160 --> 01:03:17.470
We're defining controlled access
to system services so people

01:03:17.470 --> 01:03:19.750
can stop patching the system.

01:03:19.760 --> 01:03:23.760
It's amazing what people do when they
have the kernel sources available to

01:03:23.860 --> 01:03:27.760
them and they have the kernel fully
symboled and everything available.

01:03:27.920 --> 01:03:30.980
They've been doing some really,
really bizarre things,

01:03:31.010 --> 01:03:32.390
and we want to stop that.

01:03:34.410 --> 01:03:37.400
and many of our services,
we're trying to figure out ways

01:03:37.400 --> 01:03:39.420
to move things to user space.

01:03:39.420 --> 01:03:40.780
Kecks are bad.

01:03:40.870 --> 01:03:41.580
Kecks are bad.

01:03:41.600 --> 01:03:43.910
We want to do everything at
user space that we can do.

01:03:43.920 --> 01:03:48.600
So we're trying to define interfaces
to move things up to user space.

01:03:48.600 --> 01:03:51.200
And so whatever you're
doing in the kernel,

01:03:51.200 --> 01:03:53.800
if any of you are kecks writers,
whatever you're doing,

01:03:53.800 --> 01:03:57.010
and you need access to, come talk to us.

01:03:57.040 --> 01:03:58.020
Send us your input.

01:03:58.020 --> 01:03:59.220
We're really begging for it.

01:03:59.220 --> 01:04:02.230
To help us figure out how to, A,
get you out of the kernel

01:04:02.230 --> 01:04:04.340
in the first place,
and if not,

01:04:04.480 --> 01:04:08.480
define a set of controlled and
sustainable interfaces for you

01:04:08.480 --> 01:04:11.360
to use in the kernel so that we
don't have to go through this,

01:04:11.430 --> 01:04:14.200
we jointly don't have to keep going
through this release after release.

01:04:16.850 --> 01:04:19.040
All right,
so that pretty much covers everything.

01:04:19.040 --> 01:04:20.000
The roadmap.

01:04:20.000 --> 01:04:22.740
Well,
you want to talk about that KEXT thing

01:04:22.740 --> 01:04:27.000
some more right after this in this
very session is managing KEXT.

01:04:27.000 --> 01:04:30.820
So you want to definitely hang out
for that if you're a KEXT writer.

01:04:30.820 --> 01:04:34.660
More of the security stuff
later this afternoon.

01:04:34.660 --> 01:04:36.890
The Darwin feedback forum later today.

01:04:36.890 --> 01:04:40.900
That's definitely something we're
interested in getting your feedback,

01:04:40.900 --> 01:04:43.880
and if you can start giving
us some of that input on KEXT,

01:04:43.970 --> 01:04:45.290
that would be great.

01:04:46.140 --> 01:04:50.120
And to learn about some of the Pthread
stuff that's new in this release,

01:04:50.120 --> 01:04:53.810
go to the Pthread session tomorrow
and learn about those there.

01:04:53.810 --> 01:04:57.040
And on Friday,
the developing for performance.

01:04:57.040 --> 01:04:58.790
We give you a lot of rope in this system.

01:04:58.790 --> 01:05:02.300
We don't restrict you from very much,
but we also give you a

01:05:02.420 --> 01:05:05.980
lot of rope to mess up the
performance of everybody else.

01:05:05.980 --> 01:05:09.260
And so you really need to write
your applications in a way that

01:05:09.260 --> 01:05:12.250
are not only performant for you,
but performant for the

01:05:12.250 --> 01:05:15.020
rest of the system,
and that session on Friday will

01:05:15.020 --> 01:05:15.480
cover a lot of that.

01:05:15.480 --> 01:05:18.870
a lot of how to take that into account.

01:05:19.500 --> 01:05:24.000
To contact Jason Yao is the
technology manager for CoreOS,

01:05:24.000 --> 01:05:27.700
and you probably want to
send him any requests.

01:05:27.700 --> 01:05:33.840
But we're also the Darwin developer
sites and the Darwin documentation.

01:05:33.840 --> 01:05:36.990
If you have questions,
we're very responsive to

01:05:37.040 --> 01:05:38.720
the Darwin development list.

01:05:38.720 --> 01:05:43.170
We can talk things out on that list
if you don't want to go through

01:05:43.170 --> 01:05:44.380
developer relations as well.
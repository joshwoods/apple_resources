WEBVTT

00:00:03.120 --> 00:00:04.000
Hi, everybody.

00:00:04.000 --> 00:00:05.810
Thank you for joining us today.

00:00:05.930 --> 00:00:10.230
Welcome to session 200,
Making Your Application Unicode-Savvy.

00:00:10.320 --> 00:00:12.720
If you were here yesterday in one
of the keynotes in the afternoon,

00:00:12.720 --> 00:00:17.370
you saw Scott Forstall discuss the new
international features in the upcoming

00:00:17.460 --> 00:00:19.550
version of Mac OS X codenamed Jaguar.

00:00:19.650 --> 00:00:22.330
A lot of people have been
asking in the past years about

00:00:22.720 --> 00:00:26.140
tier-three support in Mac OS X,
better support for Unicode fonts,

00:00:26.260 --> 00:00:28.800
better support for
extended character sets,

00:00:28.880 --> 00:00:30.450
better support for keyboards.

00:00:30.450 --> 00:00:33.090
Well, I'm glad that today we're
going to be actually telling

00:00:33.090 --> 00:00:34.820
you about all these things.

00:00:34.820 --> 00:00:37.340
There is one thing that
was missing in the keynote,

00:00:37.420 --> 00:00:41.620
is that support for new
languages will be achieved only,

00:00:41.620 --> 00:00:44.280
and I say only, through Unicode.

00:00:44.290 --> 00:00:46.920
So you will need to have
a Unicode application,

00:00:46.920 --> 00:00:50.630
use Unicode technologies to display
text in order to be able to do,

00:00:50.630 --> 00:00:55.050
you know, Indie scripts, support BIDI,
support Hebrew, Arabic,

00:00:55.050 --> 00:00:58.930
and all these new languages
will be supporting in Mac OS X.

00:01:00.790 --> 00:01:02.700
What was my title?

00:01:02.810 --> 00:01:05.550
To discuss all these Unicode features
that we're going to be adding in

00:01:05.550 --> 00:01:09.990
the upcoming version of Mac OS X,
I'd like to introduce Deborah Goldsmith,

00:01:09.990 --> 00:01:12.040
who is the manager, actually,
of our phone team,

00:01:12.040 --> 00:01:13.720
and she'll be discussing
all these features today.

00:01:13.810 --> 00:01:15.290
Deborah.

00:01:25.300 --> 00:01:26.300
"Is this mic on?

00:01:26.300 --> 00:01:26.970
No.

00:01:27.270 --> 00:01:27.910
Okay.

00:01:27.910 --> 00:01:31.800
Alright, I'll speak over here.

00:01:31.800 --> 00:01:33.740
Is this mic on?

00:01:33.740 --> 00:01:37.690
Hello?

00:01:37.690 --> 00:01:37.900
Okay.

00:01:45.270 --> 00:01:46.960
Oh, is this mic on now?

00:01:47.190 --> 00:01:48.300
Yes, okay.

00:01:48.300 --> 00:01:50.960
Good morning, everyone.

00:01:50.960 --> 00:01:55.200
Today we'll be talking about how to
make your application Unicode-savvy.

00:01:55.200 --> 00:01:59.020
And in fact,
I'll be covering two sets of topics.

00:01:59.220 --> 00:02:04.200
First, I'll give an overview of the
Unicode support in Mac OS X.

00:02:04.200 --> 00:02:10.280
And then I'll go into more detail
about what you can do in your

00:02:10.280 --> 00:02:10.280
application in order to support Unicode.

00:02:12.780 --> 00:02:17.360
So first, let's look in depth at the
UniCode support in Mac OS X,

00:02:17.360 --> 00:02:19.630
both in the current version
and in the new version,

00:02:19.630 --> 00:02:20.650
codenamed Jaguar.

00:02:23.960 --> 00:02:25.620
Before I do that,
I'd like to talk a little

00:02:25.690 --> 00:02:26.590
bit about the past.

00:02:26.620 --> 00:02:30.700
In the past, on Mac OS 9,
we used a technology called

00:02:30.700 --> 00:02:32.390
WorldScript rather than UniCode.

00:02:32.400 --> 00:02:36.130
And in WorldScript, every script,
every writing system had

00:02:36.200 --> 00:02:38.180
its own character encoding.

00:02:38.180 --> 00:02:42.360
In fact, some of them,
like Roman and Arabic, had more than one.

00:02:42.360 --> 00:02:44.800
There were several different
versions of the Roman encoding.

00:02:44.800 --> 00:02:51.570
And these character encodings were
based originally on standards.

00:02:51.800 --> 00:02:56.620
Mac Roman is based on ASCII,
and Mac Japanese is based on ShiftJS,

00:02:56.620 --> 00:02:58.800
but they weren't standard themselves.

00:02:58.800 --> 00:03:00.130
They were unique to Apple.

00:03:02.060 --> 00:03:04.810
How did you figure out which one of
these character encodings to use?

00:03:04.990 --> 00:03:08.220
Well, that was implied by the ID of
the font you were using.

00:03:08.300 --> 00:03:11.420
If the ID of a font fell
within a specific range,

00:03:11.690 --> 00:03:16.240
that implied a specific script system
and a specific character encoding.

00:03:16.330 --> 00:03:21.830
The problem with that is that if you
chose the wrong font for some text,

00:03:21.830 --> 00:03:23.560
you got garbage.

00:03:23.580 --> 00:03:27.120
Would anybody like to try to
guess what language that is

00:03:27.120 --> 00:03:29.320
at the bottom of the slide?

00:03:32.930 --> 00:03:38.620
No, it's not French, it's Korean,
but you can't tell because

00:03:38.620 --> 00:03:38.620
it's the wrong font.

00:03:41.600 --> 00:03:43.900
So,
Unicode provides a much better solution

00:03:43.900 --> 00:03:46.020
to the problem of character encoding.

00:03:46.020 --> 00:03:49.120
First of all,
Unicode is a worldwide standard.

00:03:49.120 --> 00:03:52.380
It's defined by the
International Standards Organization and

00:03:52.380 --> 00:03:56.330
the Unicode Consortium,
and it covers most of the writing

00:03:56.330 --> 00:03:58.890
systems in use in the world today.

00:03:58.890 --> 00:04:02.180
In Unicode,
unlike the Mac OS character sets,

00:04:02.630 --> 00:04:05.640
every character has its
own unique code point.

00:04:05.640 --> 00:04:09.590
So, a given code number means one
and exactly one character.

00:04:09.700 --> 00:04:15.320
So, an A is always an A is always an A,
with apologies to Gertrude Stein.

00:04:15.480 --> 00:04:22.140
And in Unicode 3.2,
there are 95,156 graphic characters,

00:04:22.140 --> 00:04:25.240
meaning characters that produce
something on the screen.

00:04:30.170 --> 00:04:33.330
So what are the advantages
for Mac OS X of using Unicode

00:04:33.410 --> 00:04:35.140
as a character encoding?

00:04:35.170 --> 00:04:39.000
First of all, there's one character
set for all languages.

00:04:39.000 --> 00:04:42.280
You don't have to worry about
which character set you're

00:04:42.280 --> 00:04:44.010
using for a specific language.

00:04:44.010 --> 00:04:45.140
There's only one.

00:04:45.150 --> 00:04:47.610
You get more characters
for existing languages.

00:04:47.610 --> 00:04:51.260
So even if it's a language you're
already supporting through Unicode,

00:04:51.260 --> 00:04:55.060
you can get access to more characters
that your customers want to get at.

00:04:55.060 --> 00:04:58.220
And I'll talk more about that later.

00:04:58.220 --> 00:05:00.530
There's support for more languages.

00:05:00.580 --> 00:05:03.410
Xavier mentioned that
briefly in the introduction,

00:05:03.410 --> 00:05:06.820
and we'll see more of that
later in the presentation.

00:05:06.820 --> 00:05:09.170
A big plus is no more garbled text.

00:05:09.200 --> 00:05:12.950
You don't see garbage like you
saw in the previous slide in

00:05:12.950 --> 00:05:17.130
the Korean example because each
character has a unique meaning.

00:05:17.220 --> 00:05:20.190
It doesn't depend on
the font that's in use.

00:05:20.190 --> 00:05:23.220
Because Unicode covers
multiple languages,

00:05:23.220 --> 00:05:27.650
you can get multiple languages at once
in your text stream without having to

00:05:27.650 --> 00:05:29.790
worry about which font is being used.

00:05:29.880 --> 00:05:33.120
So plain text can support
multiple languages.

00:05:33.220 --> 00:05:36.730
A very important example of plain
text is file names in the Finder.

00:05:38.520 --> 00:05:41.560
And finally,
because Unicode is a worldwide standard,

00:05:41.570 --> 00:05:44.820
not just defined by Apple,
it's cross-platform.

00:05:44.940 --> 00:05:49.840
You can send Unicode text to Windows,
to Unix systems across the internet,

00:05:49.840 --> 00:05:53.120
and other applications and other
systems will know how to deal with it.

00:05:58.810 --> 00:06:02.430
Let's take a little look at the
Unicode coverage in the currently

00:06:02.430 --> 00:06:06.150
shipping version of Mac OS X 10.1.

00:06:06.420 --> 00:06:09.700
In our Lucida Grande font,
we support a wide variety

00:06:09.700 --> 00:06:12.720
of Roman characters as well
as several other languages.

00:06:12.720 --> 00:06:15.250
So we have support for
the Roman characters,

00:06:15.250 --> 00:06:18.080
not just that are in the
Mac Roman character set,

00:06:18.080 --> 00:06:21.940
but also that you would find in
Mac Central European and several

00:06:21.940 --> 00:06:24.060
other accented Latin letters.

00:06:24.060 --> 00:06:28.270
We also support the Cyrillic
alphabet that's used in Russia and

00:06:28.290 --> 00:06:30.960
other Eastern European countries.

00:06:30.960 --> 00:06:35.500
And we support the set of accented
letters that are needed for Vietnamese.

00:06:36.210 --> 00:06:38.120
And finally,
there's a complete set of modern

00:06:38.120 --> 00:06:39.500
Greek characters in Lucida.

00:06:39.500 --> 00:06:42.600
And that's all available
today to Unicode applications.

00:06:42.600 --> 00:06:47.140
If you have a non-Unicode application,
Lucida will just look like another

00:06:47.140 --> 00:06:50.270
Mac Roman font and you won't get
access to these extra characters.

00:06:52.290 --> 00:06:55.850
Some of our other fonts, like Times,
Helvetica, Geneva, and so on,

00:06:55.850 --> 00:06:59.080
also have an extended
set of Roman characters.

00:06:59.080 --> 00:07:02.100
And again, these are only available
to Unicode applications.

00:07:07.180 --> 00:07:10.380
Next, I'd like to talk about the
Japanese support in Mac OS X,

00:07:10.380 --> 00:07:13.060
and this is where our Unicode
support really starts to shine.

00:07:13.060 --> 00:07:18.260
In Mac OS X 10.1,
we shipped a family of six

00:07:18.260 --> 00:07:22.230
desktop publishing quality
open type Type 1 fonts,

00:07:22.260 --> 00:07:23.920
the Hidagino family.

00:07:24.160 --> 00:07:27.780
And these fonts have more
Japanese characters than anything

00:07:27.780 --> 00:07:31.260
we've seen on the Mac platform
and I think lead the industry in

00:07:31.260 --> 00:07:33.320
terms of their character coverage.

00:07:33.320 --> 00:07:36.200
These fonts contain the
complete repertoire of the new

00:07:36.360 --> 00:07:39.170
GIST 213 character set standard.

00:07:39.290 --> 00:07:44.430
They contain the complete set
of Adobe Japan 1.4 characters.

00:07:44.430 --> 00:07:49.720
They also contain the set of Shaken
78 kanji that are used for photo

00:07:49.720 --> 00:07:51.910
typesetting machines in Japan.

00:07:51.910 --> 00:07:55.110
And finally,
they contain--they follow the

00:07:55.160 --> 00:07:59.510
shape recommendations from the
National Language Committee for kanji

00:07:59.510 --> 00:08:05.900
that are not in the Jo-Yo kanji,
the Hyogai kanji.

00:08:05.900 --> 00:08:08.220
So it's a very complete
character repertoire.

00:08:14.160 --> 00:08:18.450
So the net result of all this is,
compared to the approximately 7,000

00:08:18.450 --> 00:08:21.660
characters that are available in
the Mac Japanese character set,

00:08:21.690 --> 00:08:27.020
there are over 20,000 characters
available for Japanese support

00:08:27.040 --> 00:08:28.460
in the Hiragino font family.

00:08:28.460 --> 00:08:32.070
And again, those are only available
to Unicode applications.

00:08:32.100 --> 00:08:36.890
And because of this,
the gaiji problem is greatly reduced.

00:08:36.910 --> 00:08:38.100
Now, what's the gaiji problem?

00:08:38.100 --> 00:08:42.180
For those of you not familiar with it,
7,000 characters just

00:08:42.490 --> 00:08:43.780
isn't really enough.

00:08:44.210 --> 00:08:46.510
To support Japanese the
way customers want to.

00:08:46.520 --> 00:08:50.040
So if you're printing people's
business cards or doing some

00:08:50.070 --> 00:08:53.760
other application where you need a
kanji that's not in Mac Japanese,

00:08:53.760 --> 00:08:57.750
you have to use a font editor or a
special Dingbad font or something to

00:08:57.750 --> 00:09:00.250
get that kanji character that you need.

00:09:00.280 --> 00:09:03.260
And because it's done that way,
it's not a standard character,

00:09:03.370 --> 00:09:06.340
and it's not interchangeable with
other applications or systems.

00:09:06.340 --> 00:09:07.900
That's the gaiji problem.

00:09:07.900 --> 00:09:11.510
Because the Hiragino fonts have
so many characters in them,

00:09:11.510 --> 00:09:15.430
the gaiji problem is greatly reduced,
and rather than being something that

00:09:15.430 --> 00:09:18.230
you have to deal with every single day,
it's something you can deal

00:09:18.280 --> 00:09:19.800
with on an exception basis.

00:09:22.450 --> 00:09:27.590
Because of that,
your data is now reusable and

00:09:27.590 --> 00:09:30.060
can be sent to other platforms
where it'll be understood,

00:09:30.060 --> 00:09:32.350
unlike the standard Gaiji solutions.

00:09:32.360 --> 00:09:35.440
Because these are our
standard Japanese fonts,

00:09:35.440 --> 00:09:38.320
you can use them in the user
interface of your application

00:09:38.320 --> 00:09:39.910
and not just for documents.

00:09:41.680 --> 00:09:44.840
And soon, planned support for Jaguar.

00:09:44.840 --> 00:09:48.830
There are some characters in
the Hiragino fonts that are not

00:09:48.830 --> 00:09:51.760
accessible through Unicode because
they don't have Unicode code points.

00:09:51.760 --> 00:09:57.520
There are slightly variant versions of
kanji that exist in the font already.

00:09:57.520 --> 00:10:02.660
And for Jaguar, we plan to provide access
to these additional glyphs

00:10:02.660 --> 00:10:05.080
through an extension to TSM.

00:10:07.180 --> 00:10:11.290
And that will also be discussed at
the ATSUI session this afternoon,

00:10:11.290 --> 00:10:12.210
I believe.

00:10:15.850 --> 00:10:18.920
So now I'd like to demonstrate
a few of the features of our

00:10:19.040 --> 00:10:21.810
Japanese support via Unicode.

00:10:27.170 --> 00:10:30.800
Here I have a document,
and this document contains some Japanese.

00:10:30.800 --> 00:10:35.580
And I've color-coded some of
the characters in this document.

00:10:35.580 --> 00:10:41.300
The characters that are in red are
characters that are not in GIS-208,

00:10:41.550 --> 00:10:46.260
which is equivalent to Shift-GIS and
roughly equivalent to Mac Japanese.

00:10:46.260 --> 00:10:50.400
And the characters that are
in blue are not in GIS-213,

00:10:50.490 --> 00:10:51.960
but are in Unicode.

00:10:52.700 --> 00:10:56.140
So in the first sentence here,
I have an example of a

00:10:56.240 --> 00:10:57.930
name written two ways.

00:10:57.930 --> 00:10:58.880
It's Yoshida.

00:10:58.880 --> 00:11:03.660
And the standard way of writing
Yoshida is with this kanji.

00:11:03.660 --> 00:11:08.740
But some people with that name
like to write their names this way,

00:11:08.740 --> 00:11:11.440
and you can see that the
characters are slightly different.

00:11:11.440 --> 00:11:14.520
In the standard version,
the middle stroke is longer,

00:11:14.620 --> 00:11:18.440
but in this different version,
the middle stroke is shorter.

00:11:18.440 --> 00:11:22.060
And if that's the way
I like to write my name,

00:11:22.340 --> 00:11:24.910
I'm probably going to be a
little irritated if my computer

00:11:24.970 --> 00:11:26.630
forces me to do it this way.

00:11:26.640 --> 00:11:31.920
And so I'd like to be able to
use that character for my name,

00:11:31.920 --> 00:11:35.660
but in a Mac Japanese application,
I can't do that because only

00:11:35.660 --> 00:11:37.520
this version is available.

00:11:37.520 --> 00:11:40.280
But in a Unicode application
with the Hiragino fonts,

00:11:40.280 --> 00:11:42.050
many more kanji are available.

00:11:44.280 --> 00:11:47.050
Similarly, here's some more family names.

00:11:47.240 --> 00:11:48.460
They're all Kusanagi.

00:11:48.500 --> 00:11:52.960
This one can be written using
characters in standard Mac Japanese,

00:11:52.960 --> 00:11:55.060
but these two versions can't.

00:11:55.060 --> 00:11:58.250
You can see that there are characters.

00:11:58.290 --> 00:12:01.640
They're in red or orange, I guess.

00:12:01.640 --> 00:12:04.880
And so they're in GIST 213,
but not in GIST 208, and again,

00:12:04.880 --> 00:12:06.060
not in Mac Japanese.

00:12:07.770 --> 00:12:09.240
Down here we have a person's name.

00:12:09.240 --> 00:12:12.970
This is Takata,
except that the first kanji

00:12:13.280 --> 00:12:14.660
is again a different form.

00:12:14.660 --> 00:12:16.440
It's not available in Mac Japanese.

00:12:16.440 --> 00:12:18.200
It is available in Unicode.

00:12:18.200 --> 00:12:21.850
And there's also a character in
the person's given name that's

00:12:21.850 --> 00:12:23.920
not available in Mac Japanese.

00:12:26.250 --> 00:12:29.720
Here's the name of a
department store in Japan,

00:12:29.880 --> 00:12:30.620
Takajimaya.

00:12:30.990 --> 00:12:34.850
And again,
the first kanji is a non-standard form

00:12:34.850 --> 00:12:37.490
that's not available in Mac Japanese.

00:12:37.570 --> 00:12:41.440
So you can see that especially for
people's names or names of companies,

00:12:41.510 --> 00:12:44.250
there's demand for these characters
because people have used them

00:12:44.250 --> 00:12:45.830
traditionally for that purpose.

00:12:45.830 --> 00:12:51.570
And you can help your
customers do that by supporting

00:12:52.140 --> 00:12:52.750
Unicode in your application.

00:12:53.450 --> 00:12:54.940
And I have a lot more examples in here.

00:12:54.940 --> 00:12:57.100
I'm not going to go into them in detail.

00:12:57.120 --> 00:13:00.330
But I want to show you
some of the differences,

00:13:00.360 --> 00:13:05.520
the subtle differences that you can find
in kanji that are important to customers.

00:13:05.520 --> 00:13:08.350
So this is a standard
Mac Japanese character.

00:13:08.490 --> 00:13:12.150
And if I make it a little bit bigger,
you can see that in this

00:13:12.150 --> 00:13:15.580
version of the character,
there's two strokes.

00:13:15.580 --> 00:13:16.570
There's a break there.

00:13:17.360 --> 00:13:21.630
But in this alternate version,
which is not in Mac Japanese and

00:13:21.730 --> 00:13:24.670
not in GIST 213,
you can see it's done

00:13:24.670 --> 00:13:26.110
with a single stroke.

00:13:29.300 --> 00:13:32.940
So these are some of the kinds of
subtle differences that customers

00:13:32.940 --> 00:13:37.290
can start to express with an
application that supports Unicode.

00:13:40.140 --> 00:13:44.870
Before I go back to my slides,
I'd like to give a brief tour of the

00:13:44.870 --> 00:13:48.640
Japanese repertoire in the Hiragino font.

00:13:48.640 --> 00:13:52.140
So I brought up the character
palette in our Japanese input method,

00:13:52.140 --> 00:13:54.760
and you can see all
these characters here.

00:13:54.760 --> 00:13:57.690
But a lot of them, I don't know if it's
visible on the projector,

00:13:57.760 --> 00:13:59.150
a lot of them are grayed out.

00:13:59.180 --> 00:14:01.620
And the reason for that
is if you click on them,

00:14:01.650 --> 00:14:05.270
you'll see at the bottom it will tell
you that a Unicode application is

00:14:05.270 --> 00:14:07.520
required to access this character.

00:14:11.360 --> 00:14:13.700
And you can see that there
are quite a number of them

00:14:13.700 --> 00:14:15.330
that fall into that category.

00:14:15.330 --> 00:14:16.580
In fact, most of them.

00:14:16.620 --> 00:14:20.340
That's because two-thirds of the
characters in Hidagino are only

00:14:20.340 --> 00:14:28.340
accessible to Unicode applications.

00:14:28.400 --> 00:14:31.010
Let me go back to my slides now.

00:14:36.190 --> 00:14:40.640
Okay, so that's what we have that's
shipping today in Mac OS 10.1.

00:14:40.640 --> 00:14:44.140
How about what do we
have planned for Jaguar?

00:14:44.140 --> 00:14:48.080
Well, in Jaguar, we'll be turning our
attention to Chinese,

00:14:48.200 --> 00:14:51.780
and we're planning to include
some new fonts to support the

00:14:51.780 --> 00:14:55.450
new Chinese GB18030 standard,
and these fonts contain

00:14:55.450 --> 00:14:59.290
over 32,000 characters,
so they greatly increase

00:14:59.290 --> 00:15:01.020
our Unicode repertoire.

00:15:01.800 --> 00:15:09.230
These fonts fully support the entire
CJK unified ideograph region in Unicode,

00:15:09.230 --> 00:15:14.660
plus ideographic extension A,
so this means all the ideographs

00:15:14.660 --> 00:15:18.150
in versions of Unicode up to 3.0.

00:15:20.160 --> 00:15:23.460
In addition, these fonts contain support
for the Yi writing system,

00:15:23.460 --> 00:15:25.480
which is a minority
writing system in China,

00:15:25.480 --> 00:15:28.620
and partial coverage of
Tibetan and Mongolian.

00:15:28.740 --> 00:15:33.000
So we're adding new support all the time,
but again, this is only available

00:15:33.000 --> 00:15:34.700
to Unicode applications.

00:15:39.470 --> 00:15:41.660
Well, we're not just adding
new support for Chinese.

00:15:41.850 --> 00:15:44.700
There are some old favorites that
have been available on Mac OS 9

00:15:44.700 --> 00:15:49.000
for a long time that we're finally
adding support for in Mac OS X.

00:15:49.000 --> 00:15:54.770
These include Arabic, Hebrew, Thai,
Devanagri, Gurmukhi, Gujarati, Icelandic,

00:15:54.770 --> 00:16:00.300
Turkish, Greek, Croatian, Romanian,
Slovenian, and a new one, Hawaiian.

00:16:01.820 --> 00:16:04.920
Which is very important in Hawaii,
obviously.

00:16:04.940 --> 00:16:07.920
And as Xavier mentioned,
all future scripts,

00:16:07.920 --> 00:16:11.950
these scripts plus all future scripts
that we might add in the future,

00:16:11.950 --> 00:16:14.240
will only be available via Unicode.

00:16:14.240 --> 00:16:18.600
We are not planning to support
World Script 1 or Roman variant

00:16:18.600 --> 00:16:20.160
scripts on Mac OS X.

00:16:20.160 --> 00:16:22.620
In addition,
we are not planning to make any

00:16:22.770 --> 00:16:26.460
extensions to World Script 2,
so we will not be extending our

00:16:26.460 --> 00:16:30.770
existing double byte character sets,
nor will we be adding new ones.

00:16:31.360 --> 00:16:33.480
Everything in the future
will be via Unicode.

00:16:39.490 --> 00:16:42.460
Now I'd like to talk a little
bit about what's required to add

00:16:42.530 --> 00:16:44.700
support for a language to Mac OS X.

00:16:44.700 --> 00:16:48.700
Well, first of all,
you need to have a font so that

00:16:48.700 --> 00:16:51.700
you can display the characters on
the screen or on the printed page.

00:16:51.700 --> 00:16:56.300
You also need to have an
input method or a keyboard so

00:16:56.760 --> 00:16:59.620
you can enter the characters.

00:17:00.550 --> 00:17:04.500
Other things you might want to
do are override the sort order.

00:17:04.500 --> 00:17:08.080
The default is to use the Unicode
sort order that's defined in Unicode

00:17:08.080 --> 00:17:11.280
Technical Standard Number 10,
but you might want to override

00:17:11.280 --> 00:17:13.360
that for language-specific sorting.

00:17:13.360 --> 00:17:16.630
And, of course,
every country has its own date, time,

00:17:16.630 --> 00:17:20.190
and currency formats,
so you want to be able to format dates,

00:17:20.450 --> 00:17:24.200
times, and monetary amounts using
that country's standards.

00:17:24.900 --> 00:17:28.450
Unfortunately, today,
we don't allow you to override either

00:17:28.450 --> 00:17:32.520
the collation order or the date,
time, and currency formatting,

00:17:32.520 --> 00:17:33.980
which is why those are shown in blue.

00:17:33.980 --> 00:17:37.400
It's always been possible
to add fonts to Mac OS X,

00:17:37.430 --> 00:17:40.430
and new in our planned
support for Jaguar,

00:17:40.610 --> 00:17:42.870
you can now add new keyboards.

00:17:46.230 --> 00:17:48.100
But first,
I'll talk a little bit about what you

00:17:48.100 --> 00:17:51.800
need to do with a font in order for
it to work with Unicode applications.

00:17:51.800 --> 00:17:56.570
And this is aimed primarily
at font developers.

00:17:56.580 --> 00:17:59.800
First of all,
your font needs to have a valid,

00:18:00.030 --> 00:18:02.340
comprehensive Unicode CMAP.

00:18:02.400 --> 00:18:06.130
And by comprehensive,
I mean that every character that your

00:18:06.130 --> 00:18:08.820
font contains should have a CMAP entry.

00:18:08.820 --> 00:18:12.660
Quite often, we'll see a font that has
a glyph for a character,

00:18:12.660 --> 00:18:15.210
but there isn't an entry
in the Unicode CMAP.

00:18:15.710 --> 00:18:17.840
And if that's the case,
it's not accessible to

00:18:17.840 --> 00:18:19.340
a Unicode application.

00:18:19.340 --> 00:18:24.210
It should have a valid POST table
in order for printing to work.

00:18:25.620 --> 00:18:27.380
It needs to have a valid name table.

00:18:27.380 --> 00:18:31.540
It needs containing the PostScript name,
which is, again,

00:18:31.540 --> 00:18:34.000
necessary for printing and
also to work with AppKit.

00:18:34.000 --> 00:18:39.040
It needs to have a correct unique name,
the full name, the family name,

00:18:39.040 --> 00:18:41.700
the style, and a version string.

00:18:41.700 --> 00:18:45.920
It should have a valid OS2 table,
and the fields of primary

00:18:45.920 --> 00:18:50.780
interest there are the UL Unicode
range and the UL CodePage range.

00:18:51.380 --> 00:18:55.170
The reason we would like to see those
in your font is so that the system

00:18:55.170 --> 00:19:00.110
can tell what parts of Unicode or
what code pages the font supports.

00:19:00.160 --> 00:19:03.550
And finally,
if your font supports a language

00:19:03.550 --> 00:19:07.560
that has shaping behavior
like Devanagri or Arabic,

00:19:07.560 --> 00:19:12.280
you want to put in a morph
table in order to control that.

00:19:12.320 --> 00:19:16.810
Now, if your font just supports standard
Unicode composition like base

00:19:17.540 --> 00:19:21.940
characters and combining accents,
it's planned for Jaguar that we will

00:19:21.940 --> 00:19:25.800
support that composition automatically
because we will synthesize the

00:19:25.850 --> 00:19:27.840
necessary tables in the system.

00:19:27.840 --> 00:19:32.020
But still, even in that case,
it's better to put an explicit morph

00:19:32.020 --> 00:19:36.020
table in your font because then you have
complete control as the font designer.

00:19:52.190 --> 00:19:54.980
Okay,
next I'm going to talk about keyboards,

00:19:54.980 --> 00:19:58.160
and we have something new that
we have planned for Jaguar,

00:19:58.160 --> 00:20:00.440
and that's drop-in keyboard support.

00:20:00.440 --> 00:20:05.560
So finally, thank you, thank you,
finally you can add a new keyboard

00:20:05.560 --> 00:20:09.970
to Jaguar without having to
patch the system frameworks.

00:20:10.040 --> 00:20:15.100
There's a new folder in the library
folder called Keyboard Layouts.

00:20:15.180 --> 00:20:17.670
It can either be in the shared
library folder or the library

00:20:17.670 --> 00:20:19.220
folder in your home directory.

00:20:20.410 --> 00:20:23.670
And it supports all of our
existing keyboard formats,

00:20:23.710 --> 00:20:26.440
the K-char format and the U-char format.

00:20:26.440 --> 00:20:29.330
You can just drop a file in
containing one of those as long

00:20:29.330 --> 00:20:33.540
as it's in the right format,
and that keyboard will become available.

00:20:33.540 --> 00:20:38.940
But we also have a new keyboard format
that's meant to make it a little bit

00:20:38.940 --> 00:20:42.020
easier to design your own keyboards.

00:20:42.020 --> 00:20:47.760
And that's a Unicode keyboard layout
format defined via an XML text file.

00:20:48.620 --> 00:20:51.360
Now, functionally,
this is equivalent to our

00:20:51.360 --> 00:20:55.860
existing U-char keyboard layouts,
but it's a lot easier to edit.

00:20:55.860 --> 00:20:59.850
In order to edit a U-char,
you had to read the documentation in

00:20:59.850 --> 00:21:02.770
the document supporting Unicode input.

00:21:02.820 --> 00:21:03.890
You had to decipher it.

00:21:04.070 --> 00:21:05.620
There were no tools available.

00:21:05.620 --> 00:21:08.340
It wasn't very easy to use.

00:21:08.340 --> 00:21:10.720
So this makes things a lot easier.

00:21:12.140 --> 00:21:15.070
Because we now support
drop-in keyboard layouts,

00:21:15.130 --> 00:21:18.600
you can't get at these keyboard
layouts via the resource manager.

00:21:18.600 --> 00:21:23.120
So if you have an application that
accesses keyboard resources directly,

00:21:23.120 --> 00:21:27.160
you need to use the new APIs,
which have names like

00:21:27.160 --> 00:21:31.110
KLGetKeyboardLayout,
et cetera, et cetera,

00:21:31.110 --> 00:21:34.830
to access keyboards,
because the keyboards that are added

00:21:34.830 --> 00:21:39.220
via the keyboard layouts folder will not
be accessible via the resource manager.

00:21:39.710 --> 00:21:42.840
This is very similar to
what happened with fonts in

00:21:42.990 --> 00:21:45.080
earlier versions of Mac OS X.

00:21:51.130 --> 00:21:55.440
So now I'd like to show you a
little bit about what one of these

00:21:55.440 --> 00:21:57.190
XML keyboard layouts looks like.

00:21:57.190 --> 00:21:59.600
And I'll switch back to the demo machine.

00:21:59.600 --> 00:22:05.080
Let me hide world text away.

00:22:05.080 --> 00:22:07.030
Let's see.

00:22:07.870 --> 00:22:08.800
You need to have text edit.

00:22:08.800 --> 00:22:11.080
So here I have text edit.

00:22:11.170 --> 00:22:15.350
And just to show that these
are part of the system,

00:22:16.120 --> 00:22:17.940
Switch the encoding to UTF-8.

00:22:17.940 --> 00:22:25.560
So, the keyboard layouts are in System,
Library, Keyboard Layouts,

00:22:25.590 --> 00:22:28.130
look in the UniCode bundle.

00:22:29.700 --> 00:22:31.920
And there they are.

00:22:32.020 --> 00:22:35.870
Let's open the US Extended
Keyboard Layout.

00:22:40.180 --> 00:22:42.650
I'll make this a little bigger.

00:22:42.650 --> 00:22:48.390
Let's make it a 13-point font.

00:22:48.430 --> 00:22:50.270
There.

00:22:50.460 --> 00:22:54.340
Okay, so I opened this straight
out of the keyboard layouts

00:22:54.340 --> 00:22:56.560
folder in the Jaguar system.

00:22:56.560 --> 00:22:58.130
Here's an example.

00:22:58.200 --> 00:22:59.100
This is the U.S.

00:22:59.130 --> 00:23:01.840
extended keyboard layout,
which used to be called the

00:23:01.840 --> 00:23:03.320
extended Roman keyboard layout.

00:23:03.320 --> 00:23:09.700
And you can see it's a standard XML file,
and it just uses standard XML syntax to

00:23:09.700 --> 00:23:13.270
describe how the keyboard layout works.

00:23:13.300 --> 00:23:16.560
First,
there's a section which defines which

00:23:16.560 --> 00:23:20.470
hardware keyboards are supported,
and this is necessary for

00:23:20.470 --> 00:23:22.300
remapping keys on just keyboards.

00:23:22.300 --> 00:23:26.540
There's a section which defines
how the modifier keys are mapped.

00:23:27.950 --> 00:23:29.900
And then down here is
the meat of the keyboard,

00:23:29.900 --> 00:23:32.480
which is the key map set,
which maps a virtual

00:23:32.480 --> 00:23:39.080
key code to a character,
or in some cases, a state machine action.

00:23:41.110 --> 00:23:45.030
And one of the nicest things about
using XML for a keyboard layout

00:23:45.030 --> 00:23:48.930
is because XML uses Unicode,
this is a UTF-8 text file,

00:23:48.930 --> 00:23:52.160
I can just put the characters
that I need right in the file.

00:23:52.160 --> 00:23:56.420
So let's scroll down to a section where
there's some more interesting characters,

00:23:56.420 --> 00:23:58.200
like the options section.

00:23:58.210 --> 00:24:02.260
You can see there are all sorts
of interesting characters in here.

00:24:02.260 --> 00:24:03.420
I don't know if those are visible.

00:24:05.240 --> 00:24:06.680
You can just type them in directly.

00:24:06.680 --> 00:24:10.480
Also, because it's XML,
you can use a numeric character

00:24:10.480 --> 00:24:13.600
entity to define a character as well.

00:24:13.600 --> 00:24:15.560
You don't have to actually
type it into the document.

00:24:15.560 --> 00:24:23.010
And then way down at the end,
past all the key mapping sections...

00:24:24.160 --> 00:24:28.760
There are the state machine actions
which control things like dead keys.

00:24:35.400 --> 00:24:38.400
So this is a good example to look at.

00:24:38.450 --> 00:24:41.270
If you install the Jaguar
CD that you received yesterday,

00:24:41.470 --> 00:24:45.020
you can just navigate to the same place
and open this file with text edit and

00:24:45.030 --> 00:24:50.260
look through it and get an idea of how
to create XML keyboard layouts yourself.

00:24:50.280 --> 00:24:59.650
Okay, I'll go back to the slides now.

00:25:06.510 --> 00:25:11.660
Okay, so that concludes the section on
Unicode support in the operating system,

00:25:11.660 --> 00:25:14.820
and now I'd like to spend the rest
of the presentation talking about

00:25:14.920 --> 00:25:18.570
what you can do in your application
to support all these great Unicode

00:25:18.570 --> 00:25:19.980
features that you just saw.

00:25:24.420 --> 00:25:26.890
Before I do that,
I'd like to talk about some of

00:25:26.980 --> 00:25:30.680
the concepts that are important in
understanding and supporting Unicode.

00:25:30.680 --> 00:25:35.260
And probably the most important
concept is the character glyph model.

00:25:35.260 --> 00:25:40.470
It's a very central idea that's
necessary in processing Unicode.

00:25:40.470 --> 00:25:44.270
And it's discussed in detail
in Unicode Technical Report 17.

00:25:46.240 --> 00:25:49.490
The best way to understand the
distinction between characters and

00:25:49.490 --> 00:25:53.900
glyphs is you can think of characters
as being like the spoken language.

00:25:53.900 --> 00:26:00.050
They represent strings of information
the way that you would speak them aloud.

00:26:01.560 --> 00:26:05.600
Glyphs are the shapes that you see
on the screen or on the printed page.

00:26:05.730 --> 00:26:09.260
You can think of that as being
the written form of the language.

00:26:09.290 --> 00:26:11.970
And quite often,
there's a one-to-one relationship

00:26:11.970 --> 00:26:13.690
between characters and glyphs.

00:26:13.830 --> 00:26:18.100
One character goes to one glyph,
but that's not always the case.

00:26:18.150 --> 00:26:21.920
That's true in complex writing
systems like Arabic and Indic,

00:26:22.010 --> 00:26:24.340
but it can be true even
in English and Japanese,

00:26:24.340 --> 00:26:27.990
and we'll see examples of that later on.

00:26:28.160 --> 00:26:31.760
And a Unicode rendering system,
in order to fully support Unicode,

00:26:31.850 --> 00:26:36.730
has to be able to map characters to
glyphs in a many-to-many fashion.

00:26:40.420 --> 00:26:44.600
So here's an example of the character
glyph model at its most daunting.

00:26:44.750 --> 00:26:48.160
This is a string of characters
in the Devanagri script.

00:26:48.160 --> 00:26:49.400
It's Sanskrit.

00:26:49.400 --> 00:26:55.050
I'm going to use the mouse over here
so I can point things out a little bit.

00:26:55.090 --> 00:26:59.020
Here is a string of Unicode
characters in Devanagri in the

00:26:59.020 --> 00:27:01.770
order in which you might speak them.

00:27:02.540 --> 00:27:05.210
But the order in which those
characters are presented on the

00:27:05.210 --> 00:27:07.020
screen is actually quite different.

00:27:07.030 --> 00:27:10.300
As part of the layout process,
while the first character

00:27:10.300 --> 00:27:12.960
winds up in the first position,
that's not too surprising,

00:27:12.960 --> 00:27:21.800
but the second character
winds up down here.

00:27:21.800 --> 00:27:21.800
The third and the fourth characters
get combined into a ligature up here.

00:27:22.310 --> 00:27:27.770
The fifth character is down here,
and the sixth character is

00:27:27.860 --> 00:27:30.490
back over here in the middle.

00:27:30.500 --> 00:27:34.180
So you can see there's quite a
lot of rearrangement that goes on,

00:27:34.320 --> 00:27:38.010
and in no sense is there a
one-to-one mapping between

00:27:38.010 --> 00:27:39.260
the characters and the glyphs.

00:27:39.350 --> 00:27:42.760
And this is just a normal feature
of the Devanagri writing system.

00:27:42.760 --> 00:27:46.800
And this is not the only writing system
in the world that has features like this.

00:27:46.920 --> 00:27:47.820
There's quite a few of them.

00:27:53.410 --> 00:28:00.170
And just to demonstrate that this
actually goes on live in the system and

00:28:00.170 --> 00:28:07.220
not just on a slide in a presentation,
I'm going to bring up WorldText again.

00:28:07.220 --> 00:28:12.000
I'll close the Japanese document
that I have open.

00:28:12.000 --> 00:28:16.620
And I'm now using the Devanagri keyboard.

00:28:16.620 --> 00:28:20.720
You can see some of the keyboards
that are available in Jaguar.

00:28:22.520 --> 00:28:25.680
And I'm now going to type that example.

00:28:30.600 --> 00:28:34.530
And you can see that as I type,
different characters wind

00:28:34.530 --> 00:28:36.460
up in different places.

00:28:36.460 --> 00:28:41.180
And the form that's shown on the screen
changes shape as I type each character.

00:28:49.000 --> 00:28:52.290
And again, this is only available
to Unicode applications.

00:28:52.290 --> 00:28:57.380
Okay, let's switch back to the slides.

00:29:03.230 --> 00:29:07.460
So that's some of what you have to worry
about when you're handling Unicode.

00:29:07.700 --> 00:29:12.960
But let's now get into the details of
supporting Unicode in your application.

00:29:12.960 --> 00:29:15.620
So the first thing you have to worry
about when you're handling Unicode is,

00:29:15.620 --> 00:29:16.540
how do I store it?

00:29:16.560 --> 00:29:19.640
And Unicode can be stored
in several different forms.

00:29:19.700 --> 00:29:23.940
Probably the purest form of Unicode
is what's called the scalar value.

00:29:23.940 --> 00:29:29.290
And this is just a number from
0 through 10FFFF that defines a

00:29:29.290 --> 00:29:32.040
particular Unicode code point.

00:29:32.040 --> 00:29:35.360
The scalar values are
used in HTML and XML.

00:29:35.360 --> 00:29:39.030
You saw an example in that
XML keyboard that I brought up.

00:29:39.200 --> 00:29:43.960
Those numeric character entities
were Unicode scalar values.

00:29:44.520 --> 00:29:48.880
But we don't use that in Mac OS X,
except in the context of HTML or XML.

00:29:48.880 --> 00:29:54.340
The format of Unicode that's most
widely used in the industry and that

00:29:54.340 --> 00:29:59.630
we use in Mac OS X for Carbon and
Cocoa and Java is the UTF-16 form,

00:29:59.630 --> 00:30:06.510
and that represents Unicode code points
as either one or two 16-bit values.

00:30:06.520 --> 00:30:10.220
If a Unicode code point
is in the first 64K,

00:30:10.220 --> 00:30:14.880
that is, it's from 0 to FFFF,
then it's one 16-bit value.

00:30:14.910 --> 00:30:17.580
If it's above that, then you use two.

00:30:18.970 --> 00:30:24.720
There's another form of Unicode
called UTF-8 that's used in

00:30:24.720 --> 00:30:28.100
the BSD part of Mac OS X and
is also used in Unix systems,

00:30:28.100 --> 00:30:29.550
wherever Unicode is used.

00:30:29.590 --> 00:30:32.240
The reason is it's compatible with ASCII.

00:30:32.240 --> 00:30:35.320
It looks like a multibyte
encoding like ShiftJIS or any

00:30:35.320 --> 00:30:37.400
other multiple byte encoding.

00:30:37.400 --> 00:30:42.140
And so it works better with software
that's expecting multibyte encodings.

00:30:42.140 --> 00:30:47.440
There are one to four bytes per
Unicode scalar value in UTF-8.

00:30:49.120 --> 00:30:52.340
And finally,
there's another form called UTF-32,

00:30:52.390 --> 00:30:55.540
where each Unicode scale
or value takes 32 bits,

00:30:55.540 --> 00:30:59.930
and that form is not used in Mac OS X or
indeed on most other operating systems.

00:31:08.100 --> 00:31:11.680
Another issue to worry about in
storing Unicode is the normalization

00:31:11.680 --> 00:31:13.160
form that you're going to use.

00:31:13.160 --> 00:31:15.030
Well, what does that mean?

00:31:15.080 --> 00:31:18.040
This is discussed in Unicode
Standard Annex Number 15,

00:31:18.120 --> 00:31:19.620
if you want to read
about it in more detail.

00:31:19.620 --> 00:31:25.100
But in Unicode, there's several ways to
represent the same character.

00:31:25.100 --> 00:31:27.520
Not for every character,
but for a good many of them.

00:31:28.380 --> 00:31:32.440
A very good example is the E with an
acute accent that you see up there.

00:31:32.440 --> 00:31:34.230
There's two ways to represent it.

00:31:34.230 --> 00:31:38.330
One is by a pre-composed character,
that is the E with acute

00:31:38.330 --> 00:31:42.090
accent as one character,
and another is as the character

00:31:42.160 --> 00:31:45.740
E followed by a combining accent,
and that's the form you

00:31:45.740 --> 00:31:47.320
see on the left there.

00:31:48.630 --> 00:31:53.860
And the combining form is
used for most Latin support,

00:31:53.860 --> 00:31:57.280
but there are a large number of
pre-composed forms in Unicode as well,

00:31:57.280 --> 00:32:00.430
and those are there for compatibility.

00:32:00.900 --> 00:32:02.480
So, which form do you use?

00:32:02.480 --> 00:32:04.930
That's where the
normalization forms come in.

00:32:04.930 --> 00:32:10.400
The fully decomposed form of Unicode,
which is the version that we use for file

00:32:10.400 --> 00:32:15.950
names in HFS+, you always store things as
a base character plus a combining mark.

00:32:16.020 --> 00:32:18.990
So you'll never see the
pre-composed E with a cute accent

00:32:19.080 --> 00:32:20.940
in the fully decomposed form.

00:32:22.630 --> 00:32:23.450
That's one form.

00:32:23.450 --> 00:32:25.860
And that's what we use in HFS Plus.

00:32:25.860 --> 00:32:30.360
But on the Internet and on Windows,
they prefer the other form,

00:32:30.360 --> 00:32:32.040
the canonical composed form.

00:32:32.040 --> 00:32:34.760
And in that form,
you always use the precomposed

00:32:34.760 --> 00:32:36.220
form if it's available.

00:32:36.220 --> 00:32:37.550
Sometimes it's not.

00:32:39.060 --> 00:32:42.840
In preference to the base character
followed by a combining mark.

00:32:43.150 --> 00:32:47.000
And in the currently
shipping version of Mac OS X,

00:32:47.000 --> 00:32:51.200
it's possible to convert from the
canonical composed form to another form,

00:32:51.200 --> 00:32:54.600
but it's not possible to convert
to the canonical composed form.

00:32:54.600 --> 00:32:59.420
We're planning to add support for
that in Jaguar so you can convert

00:32:59.420 --> 00:33:05.170
to the canonical composed form in
order to send it to Windows or to

00:33:05.170 --> 00:33:06.510
another application that expects it.

00:33:08.020 --> 00:33:10.700
And there are two more forms which
I won't discuss today that have to

00:33:10.700 --> 00:33:13.050
do with compatibility decompositions.

00:33:13.050 --> 00:33:16.620
You can read about them in
Unicode Standard Annex Number 15.

00:33:21.370 --> 00:33:24.120
So you have these UTF-16
values which I discussed.

00:33:24.230 --> 00:33:25.640
How do you store them?

00:33:25.640 --> 00:33:28.150
Well, if you're using Cocoa,
the answer is easy.

00:33:28.150 --> 00:33:29.050
It's NSString.

00:33:29.340 --> 00:33:31.460
NSString provides string storage.

00:33:31.460 --> 00:33:33.990
It will store UTF-16 for you.

00:33:34.510 --> 00:33:38.360
Carbon has a subset of
NSString called CFString.

00:33:38.370 --> 00:33:40.840
And in addition,
you also have the option of

00:33:40.840 --> 00:33:42.700
storing them as raw arrays.

00:33:42.700 --> 00:33:46.990
We have a data type called Unicar,
which represents a single

00:33:46.990 --> 00:33:49.770
UTF-16 value that you can use.

00:33:49.960 --> 00:33:55.530
On disk, either in your own documents
or in a .strings or .plist file

00:33:55.530 --> 00:33:59.740
for your app's user interface,
you can use either UTF-8

00:33:59.740 --> 00:34:01.480
or BigND and UTF-16.

00:34:01.480 --> 00:34:07.690
The UTF-16 format is preferred,
but UTF-8 will work just fine.

00:34:12.700 --> 00:34:14.240
Well,
now that you've got some Unicode text,

00:34:14.240 --> 00:34:16.210
the first thing you're going
to want to do is process it.

00:34:16.210 --> 00:34:18.540
And that's where you can
start to run into trouble.

00:34:19.850 --> 00:34:21.920
The first set of issues I'm
going to talk about have to

00:34:21.960 --> 00:34:23.420
do with handling characters.

00:34:23.440 --> 00:34:26.480
Now, you might think that characters
are pretty simple once you

00:34:26.480 --> 00:34:29.880
have 16-bit characters,
but as I've mentioned in the

00:34:30.090 --> 00:34:33.160
slide on normalization forms,
there's actually several

00:34:33.160 --> 00:34:34.510
different ways to represent them.

00:34:34.520 --> 00:34:38.360
So one issue in processing
characters is dealing with clusters.

00:34:38.360 --> 00:34:42.220
An example of a cluster is the
base character plus combining form,

00:34:42.220 --> 00:34:45.160
which I just showed you,
such as the E with a cute accent.

00:34:45.160 --> 00:34:47.920
But it can also occur in other languages.

00:34:48.690 --> 00:34:52.700
For example,
the Hidagana character ga there,

00:34:52.700 --> 00:34:55.920
which is a base character
ka plus a combining dakuten.

00:34:57.950 --> 00:35:00.730
Another issue with representing
characters is surrogates.

00:35:00.750 --> 00:35:06.900
Now, I mentioned that characters that are
above the first 64K of UniCode require

00:35:06.900 --> 00:35:13.160
two UTF-16 values to represent them,
and those are called a surrogate pair.

00:35:13.160 --> 00:35:17.210
So the character on the left
is in the first 64K of UniCode,

00:35:17.240 --> 00:35:20.180
so it's represented by
a single UTF-16 value.

00:35:20.310 --> 00:35:24.700
But the character on the right is not,
and so it requires two UTF-16

00:35:24.700 --> 00:35:26.360
values to represent it.

00:35:28.220 --> 00:35:31.950
And finally, because there are different
ways to represent the same

00:35:31.950 --> 00:35:36.780
character data in Unicode,
there's different spellings, if you will,

00:35:36.780 --> 00:35:38.700
for the same character data.

00:35:38.730 --> 00:35:44.070
The pre-combined form on the left
or the decomposed form on the right.

00:35:47.780 --> 00:35:51.120
So what happens if you're not aware of
these issues when you're processing data?

00:35:51.120 --> 00:35:56.580
Well, one example on the top there is if
I'm not aware that I can have a base

00:35:56.580 --> 00:36:01.170
character plus a combining accent,
if I were truncating that text there,

00:36:01.170 --> 00:36:04.890
"long resume," I might think that
the combining accent is a separate

00:36:05.350 --> 00:36:07.160
character from the base character.

00:36:07.260 --> 00:36:10.480
And so when I'm truncating,
I might just lop it off.

00:36:10.740 --> 00:36:14.750
As a result, I've now got an unaccented
"e," which is not the result

00:36:14.850 --> 00:36:16.440
that the user wants to see.

00:36:16.440 --> 00:36:19.460
If I have a surrogate pair
for a character that's not

00:36:19.460 --> 00:36:22.700
in the first 64K of UniCode,
and I think that those are two

00:36:22.790 --> 00:36:27.400
separate characters because
they're two separate 16-bit values,

00:36:27.400 --> 00:36:33.320
then I split the character in two
and I wind up with garbage like that.

00:36:33.320 --> 00:36:36.040
And finally,
if I'm doing sorting or searching and

00:36:36.040 --> 00:36:40.370
I don't recognize that the precomposed
form of "e" with a cute accent is

00:36:40.370 --> 00:36:44.350
the same as the decomposed form,
then I might think that all of

00:36:44.350 --> 00:36:47.860
those words are different when,
in fact, they're all exactly the same.

00:36:53.660 --> 00:36:56.820
Of course, the way to avoid all these
problems is to use the APIs that

00:36:56.850 --> 00:36:58.910
Mac OS X provides to your application.

00:36:58.940 --> 00:37:04.330
So for Cocoa applications,
NSString has a pair of APIs.

00:37:04.340 --> 00:37:08.540
Range of Composed Character Sequence
at Index will tell your application

00:37:08.540 --> 00:37:10.780
the boundaries of a character cluster.

00:37:10.780 --> 00:37:13.660
So the base character plus
the combining accents,

00:37:13.670 --> 00:37:17.030
or in the case of a surrogate pair,
it will tell you the boundaries

00:37:17.110 --> 00:37:18.360
of that surrogate pair.

00:37:18.760 --> 00:37:22.440
So if you want to truncate a string
or get a substring out of a string,

00:37:22.440 --> 00:37:26.400
you can use that API to find a
safe place to break the string.

00:37:26.400 --> 00:37:31.890
The NSString Compare API will compare
two strings in a Unicode-savvy and

00:37:31.890 --> 00:37:36.210
locale-sensitive way so that things
like multiple spellings for the

00:37:36.210 --> 00:37:38.260
same data are taken into account.

00:37:38.260 --> 00:37:43.780
On the Carbon side,
the Unicode utilities have two APIs,

00:37:43.780 --> 00:37:49.990
UC Find Text Break and UC Compare Text,
which will find boundaries

00:37:49.990 --> 00:37:54.030
in Unicode text and compare
text in a Unicode-savvy way.

00:37:54.040 --> 00:37:56.960
And finally,
you can truncate your text while

00:37:57.020 --> 00:38:01.120
you're drawing it without actually
having to change the underlying data

00:38:01.160 --> 00:38:05.350
by using the Katsu line truncation tag.

00:38:05.380 --> 00:38:09.110
And again,
that's done in a Unicode-savvy way.

00:38:14.220 --> 00:38:15.380
But wait, there's more.

00:38:15.380 --> 00:38:19.580
When you started to get into
the really complex writing

00:38:19.580 --> 00:38:22.900
systems that Unicode can support,
there are even more problems,

00:38:22.900 --> 00:38:28.480
particularly in support of bidirectional
and cursive scripts and rearrangement.

00:38:28.500 --> 00:38:32.260
So let's take a look at some of
these more complex writing systems.

00:38:32.260 --> 00:38:35.040
Arabic is a right-to-left language.

00:38:35.170 --> 00:38:37.350
It's written right-to-left.

00:38:37.480 --> 00:38:39.830
And in addition,
it's also a cursive script,

00:38:39.830 --> 00:38:43.320
which means that the letters
flow together and form ligatures.

00:38:43.980 --> 00:38:47.950
So in this example,
let me use the mouse pointer again.

00:38:48.850 --> 00:38:52.080
The first character,
which is on the left here,

00:38:52.460 --> 00:38:55.050
winds up on the right
side of the final result.

00:38:55.080 --> 00:39:00.440
And the individual letters
flow together in a cursive way.

00:39:01.950 --> 00:39:04.920
Hebrew is also bidirectional
but is not cursive,

00:39:04.950 --> 00:39:08.160
so it's a fairly straightforward
alphabetic language,

00:39:08.160 --> 00:39:09.780
except that it also goes right to left.

00:39:11.520 --> 00:39:14.130
But even English can have
some of these attributes.

00:39:14.310 --> 00:39:17.820
For example, the Zapfino font,
which is part of Mac OS X and

00:39:17.850 --> 00:39:20.930
has been since the beginning,
is a cursive font and turns

00:39:20.980 --> 00:39:23.720
English into a cursive writing system.

00:39:23.720 --> 00:39:28.500
So the reason to support these kinds
of writing features is not just for

00:39:28.500 --> 00:39:31.350
languages that you may not care about.

00:39:31.380 --> 00:39:34.990
It's also to support nice
typography in English.

00:39:36.930 --> 00:39:42.100
And as we saw earlier when I showed
an example of typing in Devanagari,

00:39:42.100 --> 00:39:46.840
there's also rearrangement where rather
than left to right or right to left,

00:39:46.970 --> 00:39:49.920
you have something even more
complicated where things just wind

00:39:49.920 --> 00:39:52.120
up in different positions altogether.

00:39:52.120 --> 00:39:55.910
So, for example,
you can see that the second character

00:39:55.910 --> 00:40:00.740
in this Devanagari string winds up
as the first glyph on the screen.

00:40:07.300 --> 00:40:09.700
What happens if you don't take
these issues into account?

00:40:09.720 --> 00:40:14.390
Well, probably the biggest problem
in supporting bidirectional or

00:40:14.590 --> 00:40:17.960
rearranged text is style runs.

00:40:18.140 --> 00:40:22.140
Many, many applications will draw
style runs one at a time.

00:40:22.140 --> 00:40:27.620
So you find the first range of characters
that has a given font or a given style.

00:40:27.620 --> 00:40:28.750
You draw that.

00:40:28.780 --> 00:40:30.210
You take the next range.

00:40:30.260 --> 00:40:30.940
You draw that.

00:40:31.090 --> 00:40:32.380
That's the way Quick Draw works.

00:40:32.380 --> 00:40:35.900
The problem is if you do things
that way and you don't take

00:40:35.900 --> 00:40:39.250
bidirectional issues into account,
you get the wrong result.

00:40:39.430 --> 00:40:42.940
So, for example, the first string,
which is drawn correctly,

00:40:42.940 --> 00:40:47.040
has an English word,
an Arabic word in a large font,

00:40:47.040 --> 00:40:51.020
and the same Arabic word in a small font,
followed by another English word.

00:40:51.020 --> 00:40:55.100
And because Arabic goes right to left,
it's important that the

00:40:55.150 --> 00:40:56.960
first word come on the right.

00:40:57.020 --> 00:41:00.420
But if you just draw
style runs left to right,

00:41:00.440 --> 00:41:04.820
you'll wind up putting the word
with the large font on the left.

00:41:04.840 --> 00:41:07.740
Because it's the first one you
encounter in the text stream,

00:41:07.740 --> 00:41:09.300
and the result is wrong.

00:41:11.360 --> 00:41:13.810
For scripts with
rearrangement like Devanagri,

00:41:13.940 --> 00:41:17.690
you get even worse results if you
assume that things go left to right.

00:41:17.740 --> 00:41:22.790
The mapping between a character index
and a glyph index is very complicated,

00:41:22.790 --> 00:41:26.770
and if you assume that they're the same,
hit testing, highlighting,

00:41:26.770 --> 00:41:31.400
moving the cursor with the arrow keys,
none of that is going to work correctly.

00:41:36.660 --> 00:41:41.800
Of course, we provide APIs to work
around all these problems.

00:41:41.960 --> 00:41:44.550
Because of bidirectional
issues in Unicode,

00:41:44.550 --> 00:41:49.210
to do bidirectional layout correctly,
you have to work on an

00:41:49.210 --> 00:41:50.840
entire paragraph at a time.

00:41:50.840 --> 00:41:52.940
You can't just do a little bit at a time.

00:41:52.940 --> 00:41:56.020
That's the way the Unicode
bidirectional model works.

00:41:56.020 --> 00:42:02.010
And by a paragraph,
I just mean the text between one hard

00:42:02.010 --> 00:42:02.710
line break and another hard line break.

00:42:03.660 --> 00:42:07.960
So both Cocoa and Carbon provide
APIs to do this for you.

00:42:07.960 --> 00:42:10.100
On the Cocoa side,
there's NSAttributedString,

00:42:10.100 --> 00:42:13.150
which lets you store an entire
paragraph with style runs and all,

00:42:13.150 --> 00:42:15.850
and NSTypeSetter,
which will lay that out.

00:42:15.880 --> 00:42:19.690
On the Carbon side,
we have AtsuTextLayout and AtsuStyle,

00:42:19.770 --> 00:42:25.010
which will also let you represent an
entire paragraph or more of styled text.

00:42:25.040 --> 00:42:29.030
That lets the system have all the
text in the paragraph at once so that

00:42:29.030 --> 00:42:31.240
it can handle these issues for you.

00:42:32.930 --> 00:42:36.800
If you're mapping between character
offsets and coordinates on the screen,

00:42:36.800 --> 00:42:38.960
there are APIs available
that will do that for you.

00:42:39.090 --> 00:42:42.120
ATSU, Offset to Position and
Position to Offset.

00:42:42.200 --> 00:42:46.370
The ATSUI APIs for moving the
cursor with the arrow keys.

00:42:46.420 --> 00:42:49.500
And on the Cocoa side,
NSLayoutManager will handle

00:42:49.500 --> 00:42:51.200
all of these issues for you.

00:43:00.810 --> 00:43:01.980
So all is well and good.

00:43:01.980 --> 00:43:04.920
You have your Unicode
application working perfectly.

00:43:04.920 --> 00:43:06.400
There's only one problem.

00:43:06.400 --> 00:43:10.430
All the data out there is not in Unicode,
or a lot of it isn't anyway.

00:43:10.430 --> 00:43:14.860
Your customers have lots of
documents and information that

00:43:14.860 --> 00:43:17.990
are not stored in Unicode,
and you need to get that into

00:43:17.990 --> 00:43:19.710
your Unicode application.

00:43:19.710 --> 00:43:21.020
So how do you do that?

00:43:21.080 --> 00:43:25.040
Well, there's many APIs in the system
for doing encoding conversion,

00:43:25.040 --> 00:43:28.680
but one thing you need to know
is which encoding the data is in.

00:43:29.160 --> 00:43:33.970
And quite often the data isn't
labeled as to which encoding it's in.

00:43:34.610 --> 00:43:36.840
There are some APIs you can
use to make a good guess.

00:43:36.840 --> 00:43:40.190
Probably the one that you
should use the most often is

00:43:40.190 --> 00:43:42.300
Get Application Text Encoding.

00:43:42.300 --> 00:43:46.430
And what that does is return
the character encoding that

00:43:46.430 --> 00:43:50.680
corresponds to the language that your
application is currently running in.

00:43:50.720 --> 00:43:53.620
So if I have an application
that's localized into

00:43:53.620 --> 00:43:56.880
several different languages,
and I launch it and

00:43:56.880 --> 00:44:00.720
it's running in English,
that encoding will be Mac Roman.

00:44:01.300 --> 00:44:03.650
If I launch it and the
Japanese version runs because of

00:44:03.650 --> 00:44:07.640
the user's language preference,
then that encoding will be Mac Japanese.

00:44:07.640 --> 00:44:10.860
So that's the encoding,
the legacy encoding,

00:44:10.860 --> 00:44:14.890
that corresponds to the
language of the user interface.

00:44:14.900 --> 00:44:16.810
Usually that's the right choice.

00:44:16.840 --> 00:44:18.480
Sometimes it's not.

00:44:18.520 --> 00:44:22.880
Sometimes you want to use the encoding
for the user's most preferred language,

00:44:22.880 --> 00:44:26.450
regardless of what language
your application is running in.

00:44:26.480 --> 00:44:29.960
For that,
you can use CFStringGetSystemEncoding.

00:44:29.960 --> 00:44:33.740
And that will return... the legacy
encoding that corresponds to the

00:44:34.050 --> 00:44:38.000
language that the user put first
in their language preferences.

00:44:39.610 --> 00:44:41.570
If neither of those are right,
then it's pretty much

00:44:41.660 --> 00:44:42.820
application dependent.

00:44:42.820 --> 00:44:47.600
For many Internet applications,
the character encoding information will

00:44:47.600 --> 00:44:51.350
come in as part of the Internet header
or will be embedded in the document,

00:44:51.350 --> 00:44:52.590
and you can use that.

00:44:54.480 --> 00:44:57.410
Once you know the right
character encoding to use,

00:44:57.560 --> 00:45:02.100
there are several APIs available
to convert to and from Unicode.

00:45:02.210 --> 00:45:09.110
CFString and NSString both have APIs for
converting between text encodings.

00:45:09.330 --> 00:45:12.850
At a lower level,
the text encoding converter is available,

00:45:12.980 --> 00:45:18.840
and that supports converting between
a wide variety of character encodings.

00:45:19.010 --> 00:45:24.180
And all of these handle not
just legacy Mac OS encodings,

00:45:24.300 --> 00:45:28.220
they also support internet,
encodings that are used on the internet

00:45:28.320 --> 00:45:30.030
and encodings that are used on Windows.

00:45:30.030 --> 00:45:31.720
It's just a wide variety of them.

00:45:41.240 --> 00:45:44.590
Now I'd like to go over the
APIs we looked at today and

00:45:44.660 --> 00:45:48.260
summarize their capabilities.

00:45:48.260 --> 00:45:52.120
We looked at CFString and NSString.

00:45:52.120 --> 00:45:57.340
Those provide storage for UTF-16
characters and other encodings as well,

00:45:57.340 --> 00:46:03.720
but the basis for those string
APIs is UTF-16 and UniCode.

00:46:03.720 --> 00:46:09.190
They provide APIs for string
manipulation and encoding conversion.

00:46:11.220 --> 00:46:14.800
In addition, NSString provides more
support for Unicode.

00:46:14.800 --> 00:46:18.880
It provides APIs to
find cluster boundaries,

00:46:18.880 --> 00:46:21.460
which are very important if you're
going to break a string in the middle,

00:46:21.460 --> 00:46:24.640
and for doing locale-sensitive collation.

00:46:36.840 --> 00:46:39.890
At a lower level,
the Unicode utilities provide

00:46:39.910 --> 00:46:43.760
many functions for doing Unicode
operations in your application.

00:46:43.760 --> 00:46:48.400
You can find text boundaries,
that is the boundaries

00:46:48.400 --> 00:46:52.230
between characters,
between clusters, between words,

00:46:52.290 --> 00:46:53.300
and between lines.

00:46:53.300 --> 00:46:59.130
So it contains support for all of those,
both going forwards and going backwards.

00:46:59.810 --> 00:47:03.380
They provide APIs for
doing cursor movement.

00:47:03.480 --> 00:47:07.490
So if the user hits the arrow key,
you can figure out where to move

00:47:07.490 --> 00:47:09.930
the cursor to in either direction.

00:47:10.190 --> 00:47:14.810
There are APIs for doing text
comparison or collation for comparing

00:47:14.920 --> 00:47:16.900
two strings of Unicode text.

00:47:17.080 --> 00:47:20.170
And again,
that's done in a locale-sensitive

00:47:20.170 --> 00:47:22.060
and Unicode-savvy way.

00:47:23.160 --> 00:47:27.440
And the Unicode utilities also provide
APIs for mapping between the locales

00:47:27.440 --> 00:47:31.350
that are used in our more modern
APIs and the regions and script codes

00:47:31.350 --> 00:47:33.460
that were used in the script manager.

00:47:33.460 --> 00:47:36.650
So if you have some data
that has a script manager

00:47:36.780 --> 00:47:40.820
script code or a region code,
the Unicode utilities provide a

00:47:40.820 --> 00:47:43.120
way to convert that to a locale.

00:47:46.300 --> 00:47:49.370
There are also APIs in the
Script Manager for converting a

00:47:49.370 --> 00:47:52.610
script code or region code into
a text encoding that you can use

00:47:52.630 --> 00:47:54.280
for character set conversion.

00:48:00.950 --> 00:48:03.490
Well,
a lot of this has been very low level,

00:48:03.500 --> 00:48:07.680
but fortunately there are also higher
level APIs that will do even more

00:48:07.680 --> 00:48:11.770
for you so that you have to worry
about less in your application.

00:48:12.740 --> 00:48:15.790
Carbon, there's MLTE,
the Multilingual Text Engine,

00:48:15.790 --> 00:48:19.260
and that's a complete text
editing solution for Unicode.

00:48:19.260 --> 00:48:22.880
If you use MLTE, you don't have to worry
about cursor movement,

00:48:22.880 --> 00:48:26.290
you don't have to worry about
breaking text between characters,

00:48:26.290 --> 00:48:27.380
words, or lines.

00:48:27.400 --> 00:48:29.560
All that is taken care of for you.

00:48:29.560 --> 00:48:32.780
You just put the text in,
and MLTE takes care of displaying

00:48:32.780 --> 00:48:34.880
it and supporting editing for you.

00:48:36.620 --> 00:48:40.600
It's a superset of the functionality
that was available in the old text

00:48:40.620 --> 00:48:44.760
edit APIs that we've had for many
years in Mac OS since the beginning.

00:48:44.760 --> 00:48:49.520
On the Cocoa side, there's NSTextView,
which similarly provides a

00:48:49.520 --> 00:48:53.800
complete solution for Unicode
text editing and display.

00:49:04.700 --> 00:49:08.270
Some other APIs that will be
useful for your application are

00:49:08.270 --> 00:49:10.220
the Text Encoding Converter.

00:49:10.370 --> 00:49:13.190
Again,
it supports a large number of encodings,

00:49:13.270 --> 00:49:15.880
not just for Mac OS,
but for various systems.

00:49:15.900 --> 00:49:18.440
And it supports multiple
forms of UniCode,

00:49:18.470 --> 00:49:21.340
including, new for Jaguar,
support for converting to the

00:49:21.500 --> 00:49:24.560
canonical composed form of UniCode.

00:49:25.280 --> 00:49:29.460
If you're doing your own text input,
if you're not using MLTE or if you're

00:49:29.560 --> 00:49:34.420
not using NSTextView and you have
to receive Unicode input directly,

00:49:34.420 --> 00:49:37.740
then you'll want to use
the Text Services Manager.

00:49:37.740 --> 00:49:42.540
And that's necessary to support
input either for Unicode or for

00:49:42.540 --> 00:49:45.380
double byte languages or for both.

00:49:47.370 --> 00:49:50.180
And again,
if you use MLTE or NS TextView,

00:49:50.180 --> 00:49:52.700
you don't have to worry about that.

00:50:00.100 --> 00:50:02.800
I'd like to recap what we're
planning to do in terms of

00:50:02.800 --> 00:50:04.500
Unicode support for Jaguar.

00:50:04.500 --> 00:50:08.820
First of all,
we'll be adding more Unicode coverage.

00:50:08.820 --> 00:50:13.580
We'll be adding fonts to support
the GB18030 Chinese standard.

00:50:13.580 --> 00:50:18.240
And those fonts have over
32,000 characters in them.

00:50:18.240 --> 00:50:24.040
We'll be adding a wide variety of
languages that we supported previously

00:50:24.040 --> 00:50:28.870
on Mac OS 9 via the language kits,
as well as a couple more besides.

00:50:30.780 --> 00:50:33.720
We're adding supports that you
can drop in new keyboard layouts

00:50:33.720 --> 00:50:35.540
without having to edit the system.

00:50:35.540 --> 00:50:40.060
And among the keyboard layout
formats that we support is

00:50:40.060 --> 00:50:44.650
a new XML text file format,
which makes it really easy to edit

00:50:44.740 --> 00:50:48.540
a keyboard layout yourself and add
new keyboard layouts to the system.

00:50:50.250 --> 00:50:54.350
And finally, as I mentioned,
we'll be adding support for converting

00:50:54.350 --> 00:50:57.580
to the pre-composed form of Unicode,
which should make it a lot

00:50:57.640 --> 00:51:00.780
easier to send data out on the
Internet or to Windows systems,

00:51:00.780 --> 00:51:02.400
where that's the preferred format.

00:51:11.460 --> 00:51:13.640
Well, there is a lot of information
in this presentation,

00:51:13.640 --> 00:51:15.680
but there's even more
information out there,

00:51:15.680 --> 00:51:18.840
and here are some of the places
that you can go to get that.

00:51:19.100 --> 00:51:21.920
The best source of
information about Unicode is,

00:51:21.920 --> 00:51:28.830
not surprisingly, the Unicode Consortium,
and the website is www.unicode.org.

00:51:28.900 --> 00:51:32.560
And there you'll find
all sorts of information.

00:51:32.560 --> 00:51:34.800
You'll find all the technical
reports I mentioned.

00:51:35.700 --> 00:51:39.950
You'll find a complete set of code
charts showing a representative glyph

00:51:40.030 --> 00:51:42.940
and the character code for every
single character that's in Unicode.

00:51:42.940 --> 00:51:47.000
And you'll find sample code
for processing Unicode data.

00:51:48.530 --> 00:51:51.300
If you want all that in an
easy-to-reference format,

00:51:51.490 --> 00:51:53.960
you can buy a copy of
the Unicode 3.0 book.

00:51:54.060 --> 00:51:55.520
There's the ISBN number.

00:51:55.520 --> 00:51:58.940
And that's available at
technical bookstores everywhere.

00:51:58.940 --> 00:52:03.320
And you can order it from Amazon.com
and all sorts of other places as well.

00:52:06.630 --> 00:52:11.190
We have a special web page for users
concerned with international issues,

00:52:11.190 --> 00:52:18.230
and that's developer.apple.com/intl,
and that summarizes all of our

00:52:18.230 --> 00:52:19.760
international technologies.

00:52:19.760 --> 00:52:24.610
So it's kind of one-stop shopping
for finding references to information

00:52:24.610 --> 00:52:29.600
that you need to make your application
Unicode and international savvy.

00:52:31.300 --> 00:52:34.400
If you're a font developer or
you're interested in fonts,

00:52:34.550 --> 00:52:38.310
we have a web page that's specifically
for supporting font developers,

00:52:38.390 --> 00:52:42.780
and that's developer.apple.com/fonts.

00:52:42.910 --> 00:52:48.100
There you'll find complete specifications
for the TrueType font format,

00:52:48.180 --> 00:52:51.940
information on how to add a
morph table to your fonts,

00:52:52.090 --> 00:52:57.090
plus a wide variety of font tools
that you can use to edit your fonts

00:52:57.370 --> 00:52:59.800
and add more features to them.

00:53:06.650 --> 00:53:11.380
There are some other sessions that you'll
probably find useful if you're interested

00:53:11.380 --> 00:53:13.040
in the kind of topics we cover today.

00:53:13.040 --> 00:53:18.940
This afternoon, there's session 202,
Drawing Text with Atsui,

00:53:18.940 --> 00:53:23.980
and this will discuss our
Carbon APIs for drawing Unicode text.

00:53:23.980 --> 00:53:26.780
And that's at 3.30 in Room J.

00:53:26.780 --> 00:53:29.880
And if you are a Carbon developer,
I strongly recommend

00:53:29.910 --> 00:53:31.520
attending this session.

00:53:31.520 --> 00:53:35.680
You'll find out a lot more about how to
draw Unicode text in your application.

00:53:36.760 --> 00:53:39.730
Tonight, at 7.30,
there's the International Birds of

00:53:39.780 --> 00:53:42.280
a Feather session,
which is in Room N downstairs.

00:53:42.280 --> 00:53:46.490
And that will be your opportunity to
meet the engineers who work on these

00:53:46.500 --> 00:53:49.920
technologies and ask them all sorts
of questions that you might have that

00:53:49.940 --> 00:53:51.840
weren't covered in the presentations.

00:53:54.020 --> 00:53:56.480
On Thursday,
if you're looking for a higher

00:53:56.480 --> 00:54:00.320
level solution for Carbon text,
there's a session on the

00:54:00.320 --> 00:54:01.680
multilingual text engine.

00:54:01.680 --> 00:54:04.140
That's Thursday at 9 a.m.

00:54:04.140 --> 00:54:05.400
in Room A2.

00:54:05.400 --> 00:54:08.460
And again, I highly recommend that if
you're a Carbon developer.

00:54:12.130 --> 00:54:14.630
And finally,
all of this stuff works perfectly,

00:54:14.760 --> 00:54:17.520
but just in case you want to
talk to us for another reason,

00:54:17.520 --> 00:54:21.930
there's the International Feedback Forum,
which is Thursday at 5 p.m.

00:54:21.930 --> 00:54:23.060
in Room J1.

00:54:23.060 --> 00:54:24.970
And I'm sure you won't have
any feedback to give us,

00:54:24.970 --> 00:54:26.060
but you can come anyway.
WEBVTT

00:00:02.690 --> 00:00:03.600
Good afternoon, everyone.

00:00:03.600 --> 00:00:06.030
I'm Travis Brown,
the graphics and imaging evangelist.

00:00:06.040 --> 00:00:09.030
And I'd like to welcome you to the
Image Capture Framework session,

00:00:09.040 --> 00:00:11.900
which is session 515.

00:00:11.900 --> 00:00:14.360
At last year's WWDC,
we introduced Image Capture,

00:00:14.360 --> 00:00:18.520
which is Apple's technology to allow
users to have a really great user

00:00:18.560 --> 00:00:21.370
experience with digital cameras,
where essentially they can just

00:00:21.370 --> 00:00:26.560
plug their digital camera in and get
images off the camera very seamlessly.

00:00:26.600 --> 00:00:31.380
A key point is Image Capture has always
had APIs available for developers to

00:00:31.380 --> 00:00:35.490
essentially enhance their application
with the ability to work with a huge

00:00:35.500 --> 00:00:38.000
number of models of digital cameras.

00:00:38.270 --> 00:00:41.310
That fact's also very important
because one of the things

00:00:41.350 --> 00:00:43.180
we're going to be talking about
this year is scanner support,

00:00:43.180 --> 00:00:46.040
which is being introduced
into Image Capture.

00:00:46.040 --> 00:00:49.510
And so in one sense,
you can have a single set of APIs in

00:00:49.510 --> 00:00:53.640
your application that allow you to
retrieve images off a digital camera or

00:00:53.640 --> 00:00:55.920
access images being taken from a scanner.

00:00:55.920 --> 00:00:57.600
So it's a very exciting story.

00:00:57.670 --> 00:01:01.950
So to finish out the story,
I'd like to invite Werner Neubrand,

00:01:02.040 --> 00:01:04.800
an image capture specialist image
capture engineer to the stage.

00:01:09.440 --> 00:01:11.090
Hello everybody.

00:01:11.130 --> 00:01:14.300
So I'm going to talk about the
Image Capture Framework today.

00:01:14.300 --> 00:01:18.130
We have a pretty tight agenda,
so we will...

00:01:18.270 --> 00:01:23.240
Look at Image Capture in general very
shortly and then look into the scanner

00:01:23.240 --> 00:01:26.510
support for Image Capture and actually
also talk about the Twain Framework

00:01:26.790 --> 00:01:31.460
and some other changes in Jaguar for
the Image Capture Framework itself.

00:01:31.480 --> 00:01:34.090
And at the end we will have a short Q&A.

00:01:34.140 --> 00:01:36.400
Image Capture, where does it fit?

00:01:36.480 --> 00:01:40.860
Well, you probably saw this set up a
couple of times this week and

00:01:40.860 --> 00:01:44.930
Image Capture technically is
part of the Carbon Framework.

00:01:45.520 --> 00:01:48.200
So Image Capture Framework,
part of Carbon Framework,

00:01:48.330 --> 00:01:50.800
but it can be used from all
your Cocoa applications,

00:01:50.800 --> 00:01:53.460
from all your Carbon applications.

00:01:57.560 --> 00:02:00.590
What really is meant when
we talk about Image Capture,

00:02:00.660 --> 00:02:01.700
the framework?

00:02:01.850 --> 00:02:07.730
Well, we treat the framework as a single
central piece technology that

00:02:07.740 --> 00:02:09.530
deals with image capture devices.

00:02:09.530 --> 00:02:12.600
We are focused on still images.

00:02:13.220 --> 00:02:15.450
The nice thing about
Image Capture is really it's

00:02:15.560 --> 00:02:19.780
abstracting the device specifics,
meaning you can write a single

00:02:19.780 --> 00:02:23.380
application that works with
multiple devices without knowing

00:02:23.590 --> 00:02:26.350
too much about the various devices.

00:02:28.280 --> 00:02:33.700
It also brings you a driver architecture
to create your own camera or,

00:02:33.700 --> 00:02:36.580
you will see later, scanner modules.

00:02:36.950 --> 00:02:39.780
And it, of course, supports standard
architectures and protocols.

00:02:39.800 --> 00:02:43.600
So for cameras, for example,
we have the PTP protocol.

00:02:43.600 --> 00:02:45.240
We support mass storage devices.

00:02:45.240 --> 00:02:50.960
And those devices on PTP on
the FireWire and USB.

00:02:53.280 --> 00:02:56.870
So if you look at this slide,
you get basically an idea of

00:02:56.880 --> 00:02:59.520
what components are involved.

00:02:59.580 --> 00:03:02.640
First of all,
on the left-hand side we have a camera.

00:03:02.660 --> 00:03:08.600
The camera is the hardware that
you connect to your machine.

00:03:08.630 --> 00:03:13.250
It will be recognized by the system
and a specific camera module that deals

00:03:13.370 --> 00:03:16.400
with this hardware will be launched.

00:03:16.410 --> 00:03:20.390
This camera module talks to
the Image Capture Framework.

00:03:20.840 --> 00:03:26.090
Which really knows about
multiple connected devices and

00:03:26.260 --> 00:03:29.370
can handle multiple clients.

00:03:29.380 --> 00:03:33.870
So one client that you all get for
free whenever you install Mac OS X is

00:03:33.960 --> 00:03:36.070
the Image Capture Application.

00:03:36.100 --> 00:03:40.300
And now, just as a reminder,
when we talk about Image Capture,

00:03:40.300 --> 00:03:42.660
a lot of people just see the
Image Capture Application,

00:03:42.660 --> 00:03:46.380
but they have no idea about
the underlying framework.

00:03:46.380 --> 00:03:47.550
So there's really more.

00:03:47.550 --> 00:03:49.420
It's not just the application.

00:03:50.720 --> 00:03:52.850
For example,
iPhoto is just another client.

00:03:52.890 --> 00:03:55.330
It's also using the
Image Capture Framework.

00:03:55.410 --> 00:03:58.110
It's just a replacement in the front end.

00:03:58.110 --> 00:04:01.110
And in there fit your
application as well.

00:04:01.120 --> 00:04:03.950
So if you want to write an application,
we'll see later on,

00:04:03.950 --> 00:04:05.780
we'll look at some code samples.

00:04:05.780 --> 00:04:07.600
It's very easy to do that.

00:04:07.600 --> 00:04:11.070
Write an application that
uses Image Capture to

00:04:11.140 --> 00:04:13.300
access images on a device.

00:04:15.610 --> 00:04:17.010
Well, that was last year's slide.

00:04:17.030 --> 00:04:20.620
This year,
we are going to add scanner support.

00:04:20.640 --> 00:04:25.140
So this year, basically the same setup,
we have different modules.

00:04:25.200 --> 00:04:29.460
So scanner modules also talk,
get launched when the

00:04:29.520 --> 00:04:33.820
scanner is connected,
talk to Image Capture, to the framework,

00:04:33.820 --> 00:04:36.490
and the framework talks
to your application,

00:04:36.550 --> 00:04:37.700
or your application
talks to the framework.

00:04:40.610 --> 00:04:43.160
So before I was mentioning
abstracting the device,

00:04:43.220 --> 00:04:44.230
how do we do that?

00:04:44.320 --> 00:04:50.820
Well, we do that by introducing the
concept of objects and properties.

00:04:50.820 --> 00:04:59.670
Objects are the things that deal with or
that are used to represent like a device,

00:04:59.760 --> 00:05:04.310
like an image or a file
on a device or a folder.

00:05:04.320 --> 00:05:08.580
And properties are the things
that deal with the real data.

00:05:09.380 --> 00:05:14.510
Both of them, objects and properties,
are identified by a type and a subtype.

00:05:18.600 --> 00:05:23.420
Now, last year we were showing
you a slide like this,

00:05:23.420 --> 00:05:26.940
and it's actually also for Jaguar.

00:05:26.940 --> 00:05:28.620
The setup is exactly the same.

00:05:28.620 --> 00:05:31.100
So we have at the top,
we have a device list

00:05:31.400 --> 00:05:32.930
that's a single object.

00:05:33.000 --> 00:05:37.220
It's always there,
and that object has reference to all

00:05:37.220 --> 00:05:40.700
the other devices that are connected.

00:05:40.700 --> 00:05:45.520
Now if you look at Camera 2 in this case,
Camera 2 has three images.

00:05:45.520 --> 00:05:48.480
So we have three image objects.

00:05:48.960 --> 00:05:53.000
Camera 2 has also, in this case,
two properties.

00:05:53.040 --> 00:05:56.570
One for the name and one for the icon.

00:05:57.520 --> 00:06:01.540
Image 3, I'm just showing that here,
but all the other images

00:06:01.540 --> 00:06:05.850
exactly have the same,
has also properties, also name and icon.

00:06:07.940 --> 00:06:13.560
And then there's a way using
image capture APIs to really

00:06:13.560 --> 00:06:16.600
go and walk through the tree.

00:06:17.090 --> 00:06:21.000
and allow you an easy access to
all the objects and properties.

00:06:25.320 --> 00:06:27.170
But that's all good and fine.

00:06:27.170 --> 00:06:32.360
And we were finding out that
having multiple properties,

00:06:32.580 --> 00:06:37.390
properties for all possible data,
is just a hassle to work with.

00:06:37.480 --> 00:06:43.120
We will actually end up by splitting up
all the metadata that belong to an image.

00:06:43.220 --> 00:06:49.350
We were about to introduce, I don't know,
20, 30, 40 different properties.

00:06:49.380 --> 00:06:51.020
And it's just a hassle to get those.

00:06:51.020 --> 00:06:54.220
Because you would have to
do a call for each property.

00:06:55.040 --> 00:06:58.920
And you probably have to know the
property type and subtype in front.

00:06:58.950 --> 00:07:05.060
So the idea was, well, we're introducing
XML property dictionary.

00:07:06.710 --> 00:07:10.620
And that's actually what we did,
and the current system, 10.1,

00:07:10.620 --> 00:07:12.770
already has that in there.

00:07:13.110 --> 00:07:19.920
So by reducing the actual properties to
just the file data and thumbnail data,

00:07:19.920 --> 00:07:22.550
so the preview icon,
these are the only properties

00:07:22.630 --> 00:07:23.830
that basically stay.

00:07:23.840 --> 00:07:27.790
Well, all the others that were introduced
in version 10 also stay just

00:07:27.790 --> 00:07:29.560
for backward compatibility.

00:07:29.560 --> 00:07:35.960
But the idea is reduce everything with
the properties just for the real data,

00:07:35.960 --> 00:07:37.880
for the image data and thumbnail data.

00:07:37.900 --> 00:07:44.100
And all the rest is really handled
with XML property dictionaries.

00:07:47.420 --> 00:07:51.780
So again, thumbnail and actual image
data are in properties.

00:07:51.780 --> 00:07:54.710
All the rest, everything else,
is done and handled in

00:07:54.710 --> 00:07:56.620
XML property dictionaries.

00:07:56.620 --> 00:07:59.800
How do you get to a property dictionary?

00:07:59.800 --> 00:08:02.420
Well, there's a new call,
and actually it fits

00:08:02.590 --> 00:08:04.090
barely on that first line.

00:08:04.100 --> 00:08:09.550
So the long API name,
it's ICA Copy Object Property Dictionary.

00:08:09.560 --> 00:08:13.040
What it does, you pass in an object,
and you get back an

00:08:13.040 --> 00:08:14.770
XML dictionary for that.

00:08:15.990 --> 00:08:21.330
Well, it's really the best way to get
to image or device information.

00:08:23.520 --> 00:08:26.790
For device object,
you actually get some basic

00:08:26.790 --> 00:08:31.670
information about the device,
like the device name, a reference to the

00:08:31.740 --> 00:08:33.520
device icon and all that.

00:08:33.620 --> 00:08:37.200
And for image objects,
you get access to the metadata.

00:08:39.050 --> 00:08:44.160
So if we just look at the device,
focus on that, and we see, well,

00:08:44.310 --> 00:08:47.480
we get the name and, for example,
also device capabilities.

00:08:47.500 --> 00:08:49.560
Can this device take pictures?

00:08:49.560 --> 00:08:51.450
Can this device delete pictures?

00:08:51.450 --> 00:08:53.680
Can it synchronize the clock?

00:08:53.740 --> 00:08:57.530
All these things are just returned
within the device dictionary.

00:08:59.400 --> 00:09:04.080
Another interesting thing
that is returned is actually

00:09:04.080 --> 00:09:11.440
a way to access all the data,
all the images on your device.

00:09:11.440 --> 00:09:13.720
And this is actually done in two flavors.

00:09:13.760 --> 00:09:18.840
There's one flattened out,
this flattened out sub-dictionary.

00:09:18.840 --> 00:09:21.940
Actually, it is a CFArrayRef.

00:09:22.100 --> 00:09:28.640
So it's an array of dictionaries
that contains information about all

00:09:28.640 --> 00:09:32.130
the images that are on the device.

00:09:32.140 --> 00:09:37.640
And there's also a
hierarchical representation,

00:09:37.640 --> 00:09:40.160
the tree structure.

00:09:40.160 --> 00:09:45.290
And this one contains not only images,
but it contains also other

00:09:45.290 --> 00:09:47.650
data that's on the device.

00:09:47.660 --> 00:09:49.760
For example, Depov information.

00:09:49.800 --> 00:09:51.900
Or, for example, firmware.

00:09:52.130 --> 00:09:54.940
That is really represented
in the file system.

00:09:54.940 --> 00:09:57.190
We will have a look at that in a second.

00:09:57.280 --> 00:10:00.240
And if you look at the...

00:10:02.830 --> 00:10:08.790
These two, we see really,
they have all the basic information

00:10:09.150 --> 00:10:13.890
that you need in order to
access all data on the device.

00:10:15.310 --> 00:10:21.440
For the image object,
we also return the name,

00:10:21.550 --> 00:10:24.370
some metadata information,
so basically everything that

00:10:24.460 --> 00:10:30.200
we can extract using QuickTime,
the graphics importer.

00:10:30.200 --> 00:10:34.200
We extract that and put
it into a dictionary,

00:10:34.200 --> 00:10:37.510
which is actually a very easy
and convenient way to get

00:10:37.510 --> 00:10:40.600
to all the information that
you might be interested in.

00:10:41.770 --> 00:10:48.470
So the best way actually to learn
about that and see it in practice.

00:10:48.480 --> 00:10:55.550
So what I want to do is I want to go over
here and launch an application that's

00:10:55.550 --> 00:10:58.180
actually part of the Image Capture SDK.

00:10:58.220 --> 00:11:00.520
It's called Image Capture Browser.

00:11:00.540 --> 00:11:06.590
So what this application does is
it basically represents the tree

00:11:06.820 --> 00:11:10.400
structure that we have inside a device.

00:11:11.850 --> 00:11:16.570
So right now I have one camera
connected to this camera.

00:11:17.420 --> 00:11:19.600
If I select that one,
then it's talking to the

00:11:19.600 --> 00:11:22.520
device and brings back the
information that it can get.

00:11:22.580 --> 00:11:26.640
Like in this case,
everything in bold is a property.

00:11:26.640 --> 00:11:28.700
So we have two properties
for that device.

00:11:28.740 --> 00:11:31.720
That's volume label and a camera icon.

00:11:34.590 --> 00:11:37.530
It also has a directory,
and that directory has

00:11:37.530 --> 00:11:39.000
a file name as property.

00:11:39.000 --> 00:11:42.580
So it is 001001.

00:11:42.620 --> 00:11:44.280
Not very interesting,
but actually there's a

00:11:44.300 --> 00:11:45.460
store number on that device.

00:11:45.460 --> 00:11:51.460
That directory has another sub-directory,
which has another sub-directory,

00:11:51.460 --> 00:11:52.680
and it actually has the images.

00:11:52.720 --> 00:11:56.020
So now we can select an image,
and we will get some

00:11:56.410 --> 00:11:58.100
information about that.

00:11:58.200 --> 00:12:01.520
So these are the properties
that belong to this first image,

00:12:01.520 --> 00:12:03.500
like the file name.

00:12:04.510 --> 00:12:06.240
DCP 0477.

00:12:06.240 --> 00:12:09.620
We have thumbnail information,
image size.

00:12:09.640 --> 00:12:12.920
So it's about 236K.

00:12:15.200 --> 00:12:21.400
[Transcript missing]

00:12:21.930 --> 00:12:24.260
That's all good and well,
so basically this application

00:12:24.260 --> 00:12:29.800
is now showing all the different
objects up here and properties.

00:12:31.890 --> 00:12:35.690
Just before I mentioned that
it's really better and easier to

00:12:35.750 --> 00:12:37.800
just work with the dictionaries.

00:12:37.800 --> 00:12:41.290
So actually down here,
I'm displaying the dictionary

00:12:41.360 --> 00:12:43.640
for the selected device up here.

00:12:43.680 --> 00:12:47.880
So for the camera,
we have as part of the dictionary,

00:12:47.880 --> 00:12:50.390
we have a capability information.

00:12:50.400 --> 00:12:56.960
So this camera supports the DEL1,
which means delete one.

00:12:58.320 --> 00:13:03.900
It's a camera can take new pictures,
and the camera is able

00:13:03.900 --> 00:13:04.880
to synchronize clock.

00:13:04.960 --> 00:13:07.680
Then we have the...

00:13:10.190 --> 00:13:18.280
We flattened out directory information
that has all the images really in it.

00:13:18.280 --> 00:13:23.760
So if you look at the first one here,
we see we have an image file name,

00:13:23.760 --> 00:13:28.110
the file size, we have a reference to
a thumbnail property,

00:13:28.110 --> 00:13:29.640
and a data property.

00:13:29.720 --> 00:13:34.240
So all we have to do is when we want,
for example, to download or get the

00:13:34.240 --> 00:13:38.030
data for the thumbnail,
is pass this as property into

00:13:38.030 --> 00:13:41.070
the ICA Get Property Data call.

00:13:44.880 --> 00:13:48.310
And we have additional information like
whether that file is locked or not.

00:13:48.400 --> 00:13:55.480
So if you scroll down, we see this is the
flattened out structure.

00:13:56.400 --> 00:13:57.900
I don't know how many
images we have on here.

00:13:57.900 --> 00:13:59.100
I guess a couple.

00:13:59.100 --> 00:14:05.370
So then we get information what
device module is handling this device.

00:14:05.370 --> 00:14:10.130
Well, here we see it's the
PTP camera app doing that.

00:14:11.700 --> 00:14:13.620
We learn about the file type.

00:14:13.870 --> 00:14:17.250
We learn what the ICA object
for the device is.

00:14:17.280 --> 00:14:21.560
And down here we have the tree structure.

00:14:23.630 --> 00:14:26.560
Basically, the same information as
in the data structure,

00:14:26.560 --> 00:14:30.850
but now really represented as
an exact copy of the layout

00:14:30.870 --> 00:14:33.770
on the device memory card.

00:14:36.890 --> 00:14:45.540
Okay, so this is just the basic setup,
and the Image Capture Browser allows

00:14:45.600 --> 00:14:49.360
you also to look at the data and
tree dictionary basically directly,

00:14:49.360 --> 00:14:53.400
and it draws you a nice outline.

00:14:53.400 --> 00:15:01.550
So you see we have one device list,
we have, that's the DC4800 camera,

00:15:01.740 --> 00:15:03.400
and these are the images.

00:15:03.630 --> 00:15:08.200
But I can also switch to the
tree view and then see really

00:15:08.200 --> 00:15:11.800
the layout on the memory card.

00:15:13.990 --> 00:15:17.000
So let's actually, as next thing,
look at some sample

00:15:17.000 --> 00:15:21.680
code to walk the tree.

00:15:24.550 --> 00:15:30.740
This is a small application.

00:15:30.790 --> 00:15:34.380
Actually, it's a command line tool
that we are going to look at.

00:15:34.460 --> 00:15:38.890
And all it does is, in its main...

00:15:40.000 --> 00:15:41.460
Get some parameters.

00:15:41.460 --> 00:15:44.820
We're not interested in those now,
but actually all we want to look

00:15:44.890 --> 00:15:52.380
at is the dump children function,
which takes an object that's the device,

00:15:52.380 --> 00:15:56.920
the list object,
and prints out some information.

00:15:56.920 --> 00:16:01.370
So if we look at the...

00:16:07.800 --> 00:16:13.340
The Dump Children function,
all it does is it gets an object and

00:16:13.340 --> 00:16:17.390
an indent and a number of planks.

00:16:17.420 --> 00:16:23.140
And for that object that we pass in,
we do a get child count.

00:16:23.260 --> 00:16:29.410
So we want to find out how many children,
how many sub-objects are referred by

00:16:29.540 --> 00:16:32.910
this first object that we look at.

00:16:34.130 --> 00:16:37.880
We get back a number
in this countPB.count.

00:16:37.880 --> 00:16:41.100
And now we loop over those.

00:16:41.450 --> 00:16:44.580
So we go from zero up to the...

00:16:44.770 --> 00:16:49.900
Number of children,
and we do just get nth child,

00:16:49.960 --> 00:16:55.700
passing in our child loop as the index.

00:16:57.610 --> 00:17:01.650
This call, getNthChild,
actually returns information

00:17:01.660 --> 00:17:02.880
about the object.

00:17:02.940 --> 00:17:06.000
And remember I was talking,
an object is identified

00:17:06.010 --> 00:17:08.980
by type and subtype.

00:17:08.980 --> 00:17:12.750
So this call is returning
type and subtype,

00:17:12.780 --> 00:17:17.230
and that's actually what
we are dumping down here.

00:17:21.970 --> 00:17:29.830
And if the type, the object type,
is a directory,

00:17:31.010 --> 00:17:35.800
"Or the type is a device,
then actually what we are doing

00:17:36.190 --> 00:17:39.900
is we call the same function,
this is just a recursive function,

00:17:39.900 --> 00:17:45.900
we call into the same function
and dump its object children.

00:17:46.170 --> 00:17:51.180
So if we actually execute
this in the command line,

00:17:55.820 --> 00:18:02.700
It really lists the
files that are in here.

00:18:02.700 --> 00:18:09.900
So now, let's go back to the first slide.

00:18:15.720 --> 00:18:20.010
There's another interesting call
that we want to look at today,

00:18:20.010 --> 00:18:22.080
and that's ICA Download File.

00:18:22.080 --> 00:18:27.280
ICA Download File is a single
API that allows you to download

00:18:27.570 --> 00:18:29.930
a specified ICA object.

00:18:34.290 --> 00:18:37.830
So the call takes,
as all image capture API calls,

00:18:37.830 --> 00:18:39.700
takes two parameters.

00:18:39.700 --> 00:18:42.820
The first one is a parameter plug,
and the second one is a completion plug.

00:18:42.820 --> 00:18:46.980
If the completion plug is null,
then it's a synchronous call.

00:18:46.980 --> 00:18:51.580
Otherwise, it's executed asynchronously,
and after completion of the call,

00:18:51.610 --> 00:18:54.360
you will get called in
your completion plug.

00:18:56.990 --> 00:19:02.420
So the parameter block for the
ICA download file looks like this.

00:19:02.520 --> 00:19:06.820
So you're basically
specifying the object.

00:19:06.840 --> 00:19:14.170
You're specifying a directory, FSREF,
that is really the destination directory.

00:19:15.150 --> 00:19:17.420
Then you specify some flags.

00:19:17.620 --> 00:19:22.360
The flags could be one of the listed
ones like delete after download,

00:19:22.930 --> 00:19:32.310
create custom icon, rotate it,
create or set file type and creator.

00:19:32.480 --> 00:19:33.720
Embed a color sync profile.

00:19:33.910 --> 00:19:34.550
Very convenient.

00:19:34.720 --> 00:19:38.090
Just a single call,
a single flag that you have to make.

00:19:38.200 --> 00:19:50.300
[Transcript missing]

00:19:50.740 --> 00:19:52.840
To be executed.

00:19:52.840 --> 00:19:57.220
And on return,
this call just returns an FS spec.

00:19:59.000 --> 00:20:01.200
Oh, sorry, Evers Ref,
away from Evers Specs.

00:20:01.720 --> 00:20:05.100
Okay.

00:20:05.100 --> 00:20:09.730
So, well, actually, again,
let's look at some source code.

00:20:16.100 --> 00:20:23.500
[Transcript missing]

00:20:28.120 --> 00:20:31.590
What we want to do-- actually,
I want to run the application first,

00:20:31.590 --> 00:20:34.390
and then show you what it
really takes to do that.

00:20:34.530 --> 00:20:39.740
So the application comes
up with a table view.

00:20:40.150 --> 00:20:42.200
It lists some names.

00:20:42.330 --> 00:20:45.110
These are the images on disk.

00:20:45.630 --> 00:20:47.660
And file size.

00:20:47.780 --> 00:20:50.740
We can select one image and we can
download it to the picture folder.

00:20:50.760 --> 00:20:54.330
So let's do that.

00:20:55.320 --> 00:20:57.500
So here it says it was downloaded to two.

00:20:57.500 --> 00:21:02.560
And actually,
if we go to the picture folder,

00:21:02.560 --> 00:21:04.730
we should see it.

00:21:11.290 --> 00:21:13.560
So what does it take to write
an application like that?

00:21:13.600 --> 00:21:15.560
Actually, it's very simple.

00:21:15.560 --> 00:21:21.560
So let me open...

00:21:30.870 --> 00:21:37.040
We see that after we awake from
the small Cocoa application,

00:21:37.040 --> 00:21:43.890
of course, after we awake from Nib,
we update our files and then

00:21:43.890 --> 00:21:45.660
install the notification.

00:21:45.660 --> 00:21:48.830
Well, updating the files is
actually very simple.

00:21:48.840 --> 00:21:53.960
So first, we get the device list.

00:21:54.040 --> 00:21:55.110
Okay.

00:21:56.220 --> 00:22:03.170
And then we get the nth
child we're interested in.

00:22:04.450 --> 00:22:07.530
The first device that is connected.

00:22:07.550 --> 00:22:08.230
Get the nth child.

00:22:08.770 --> 00:22:15.910
Then for that child, we use the new call,
the ICA Copy Object Property Dictionary.

00:22:17.180 --> 00:22:19.580
So we do that down here.

00:22:19.580 --> 00:22:25.060
And that dictionary on return...

00:22:25.800 --> 00:22:32.190
The Image Capture Framework
is a software that can be used

00:22:32.190 --> 00:22:32.190
for all kinds of applications.

00:22:32.640 --> 00:22:39.920
For example, the device name,
which is keyed off under IFIL.

00:22:41.300 --> 00:22:46.600
And we use that to set the window type.

00:22:46.600 --> 00:22:53.740
And then all we do is we have our
own data array and set that to

00:22:53.740 --> 00:22:59.480
whatever we have in the device
dictionary under the data key.

00:23:03.250 --> 00:23:03.800
That's all we do.

00:23:03.800 --> 00:23:08.760
Now, how does that now really
display some information?

00:23:08.760 --> 00:23:10.480
Well, very simple.

00:23:10.480 --> 00:23:16.730
What we are doing is,
since DataArray is a data member

00:23:16.770 --> 00:23:23.030
of this MyWindow controller,
we just take the count and return that

00:23:23.030 --> 00:23:26.970
as number of rows for the table view.

00:23:29.360 --> 00:23:34.840
When we are asked to return
the values that we are going

00:23:35.010 --> 00:23:38.340
to display in the table,
what we are doing is,

00:23:38.470 --> 00:23:42.090
we look at the identifier
of the table column.

00:23:42.230 --> 00:23:46.450
If the identifier is the index,
then we just return basically

00:23:46.450 --> 00:23:48.630
the row that gets passed in.

00:23:48.680 --> 00:23:53.310
If the identifier is the name,
then we are asked to

00:23:53.430 --> 00:23:55.410
display the file name.

00:23:55.610 --> 00:23:56.960
Well, that's easy to do.

00:23:56.970 --> 00:24:00.780
All we have to do is
look at our data array.

00:24:01.100 --> 00:24:04.940
and get the nth object out of that,
which was a dictionary.

00:24:04.940 --> 00:24:09.880
So we're looking at the object
at index row that gets passed in,

00:24:09.880 --> 00:24:17.790
and that dictionary contains for
the IFIL key the name of the file.

00:24:19.980 --> 00:24:21.900
That's all we return.

00:24:22.100 --> 00:24:26.590
Well, down here,
if you ask for the size to display, well,

00:24:26.600 --> 00:24:28.320
we basically do the same thing.

00:24:28.460 --> 00:24:35.700
Get that dictionary that's at the end,
that row position of the data array,

00:24:35.750 --> 00:24:46.010
and then ask for the data that's
specified by the iSize key.

00:24:47.350 --> 00:24:49.730
So that's for displaying.

00:24:49.780 --> 00:24:55.290
And what we want to do is really,
we want to download the file.

00:24:55.300 --> 00:24:59.780
So we are listening to the mouse
down on the download button.

00:25:01.610 --> 00:25:06.450
So the target for the
download button is this here,

00:25:06.460 --> 00:25:09.050
this download method.

00:25:09.270 --> 00:25:15.080
And what we're doing in here is, well,
we want to get the selected row.

00:25:15.620 --> 00:25:22.380
Once we have the selected row,
we ask for the ICA object value.

00:25:23.900 --> 00:25:36.100
[Transcript missing]

00:25:38.020 --> 00:25:42.570
Once we have that,
then we set up the parameter

00:25:43.610 --> 00:25:45.900
block for the ICA download file.

00:25:48.960 --> 00:25:52.210
Then we execute ICA download
files so it will download

00:25:52.870 --> 00:25:57.730
the specified object and just

00:25:59.120 --> 00:26:03.000
After that, we want to display where
the file was downloaded to.

00:26:03.000 --> 00:26:07.310
So we're just updating an info string.

00:26:10.930 --> 00:26:13.460
We don't want to have that
there for a long time,

00:26:13.460 --> 00:26:17.670
so after four seconds,
we will clear off that value.

00:26:17.700 --> 00:26:19.680
Once again, let's quickly run it.

00:26:28.700 --> 00:26:41.400
[Transcript missing]

00:26:42.240 --> 00:26:46.110
So it's really not much of code that
is involved in order to do that.

00:26:46.200 --> 00:26:50.540
Okay, so let's go back.

00:26:54.720 --> 00:26:58.160
and talk about a complete new
area for image capture and

00:26:58.190 --> 00:26:59.240
that's the scanner support.

00:27:01.870 --> 00:27:04.980
We've been asked to support
scanners for quite a while,

00:27:04.980 --> 00:27:06.350
and I guess now it's really in.

00:27:06.350 --> 00:27:09.640
And for Jaguar,
we will have the scanner support.

00:27:09.640 --> 00:27:13.390
And I'm going to give you a small
architecture overview and talk about

00:27:13.390 --> 00:27:15.940
some additional APIs for scanners.

00:27:17.120 --> 00:27:20.700
Architectural overview is very
simple because I guess I told

00:27:20.700 --> 00:27:23.240
you already everything at the
beginning of this session.

00:27:23.240 --> 00:27:24.790
Because it's the same.

00:27:24.790 --> 00:27:31.420
So we have a device list and that
device list now just supports scanners.

00:27:31.460 --> 00:27:37.230
So the same thing that was true for
cameras is now true for scanners.

00:27:37.300 --> 00:27:38.690
It's an ICA object.

00:27:38.900 --> 00:27:40.600
It will have properties.

00:27:40.600 --> 00:27:46.410
However,
handling is a little bit different.

00:27:47.720 --> 00:27:53.000
The handling scanners on the
image capture architecture

00:27:53.000 --> 00:27:57.070
is really session-based.

00:27:57.480 --> 00:28:01.290
For cameras, it was easy to just support
multiple clients at the same time.

00:28:01.330 --> 00:28:05.340
So you could really have two or three
applications running at the same time,

00:28:05.410 --> 00:28:06.470
talking to the same device.

00:28:06.480 --> 00:28:07.920
You could handle that very easily.

00:28:09.960 --> 00:28:12.320
For scanners,
it's a bit more complicated because

00:28:12.970 --> 00:28:15.460
there's really no atomic scan operation.

00:28:15.480 --> 00:28:19.440
It's really,
you get some scanner parameters,

00:28:19.440 --> 00:28:22.360
you set some scanner parameters,
and then you start the scan.

00:28:22.360 --> 00:28:25.910
So it's really a session
that you have to work with.

00:28:25.980 --> 00:28:29.700
So all our new APIs...

00:28:31.750 --> 00:28:37.200
Like the ICA Open,
this kind of Open session,

00:28:37.490 --> 00:28:43.280
and Scanner Closed Session
are working with a session ID.

00:28:43.860 --> 00:28:47.220
So for the first one,
basically it returns the session

00:28:47.220 --> 00:28:51.440
ID that you're going to use
on all subsequent ICA scanner,

00:28:51.480 --> 00:28:53.710
whatever, APIs.

00:28:56.640 --> 00:28:59.500
There's a scanner initialize
and a scanner status call.

00:28:59.500 --> 00:29:02.580
Scanner initialize basically sets
the scanner in a default mode.

00:29:02.640 --> 00:29:07.530
Getting the scanner status will report
the current scanner status and give

00:29:07.530 --> 00:29:09.990
you information about the device.

00:29:12.000 --> 00:29:14.880
These are very important calls,
the get and set parameter call.

00:29:14.920 --> 00:29:21.060
Because set and get parameter allows
you to control really the scan area

00:29:21.070 --> 00:29:23.670
resolution and everything you want to do.

00:29:23.680 --> 00:29:26.790
And these calls,
you'll see that in a second,

00:29:26.790 --> 00:29:33.710
are really set up around property
dictionaries that you pass around.

00:29:33.720 --> 00:29:37.900
So the get parameters returns
your dictionary filled with

00:29:37.900 --> 00:29:41.660
all the information that
the scanner module puts in.

00:29:41.900 --> 00:29:45.280
And on the set parameters,
you fill in information about

00:29:45.290 --> 00:29:49.460
the scan that you're going
to start with the next call,

00:29:49.460 --> 00:29:50.770
with the ICA scanner start.

00:29:54.330 --> 00:30:01.110
Let's have a look at
Scanner on the Internet.

00:30:02.300 --> 00:30:13.000
[Transcript missing]

00:30:14.780 --> 00:30:20.060
What you should see is that
we will recognize the device.

00:30:20.060 --> 00:30:24.760
This is a small application that just
shows what devices are connected.

00:30:24.760 --> 00:30:27.900
We have a Type 1 scanner connected.

00:30:27.900 --> 00:30:33.310
Let me just look at a small...

00:30:36.600 --> 00:30:42.700
[Transcript missing]

00:30:44.710 --> 00:30:48.600
So what this does is basically it's
just exercising the different APIs.

00:30:48.600 --> 00:30:56.200
So after I opened the session,
I did get back an ICA scanner session ID.

00:30:56.200 --> 00:31:00.240
And now I can, for example,
get scanner parameters.

00:31:02.340 --> 00:31:06.200
And scanner parameters have
information about the device.

00:31:06.320 --> 00:31:11.250
See, we have tablet height,
resolution minimum, maximum,

00:31:11.250 --> 00:31:13.700
some basic information.

00:31:13.800 --> 00:31:17.750
I can actually set the parameters.

00:31:18.990 --> 00:31:23.260
And by just doing that,
I'm filling in some information,

00:31:23.280 --> 00:31:29.510
for example, the resolution and X and Y,
bit depth and all that.

00:31:29.640 --> 00:31:36.110
So I'm downloading the
parameters to the scanner.

00:31:36.230 --> 00:31:43.610
And with the ICA scanner start,
I would actually exercise

00:31:43.750 --> 00:31:45.040
the downloaded parameters.

00:31:45.160 --> 00:31:49.760
You probably don't hear it,
but the scanner is doing something.

00:31:49.830 --> 00:31:56.380
Currently, this small app is not
displaying anything useful,

00:31:56.480 --> 00:31:59.040
but let's look at the code.

00:32:07.800 --> 00:32:11.350
For example, for the get parameters.

00:32:11.360 --> 00:32:14.640
So, get parameters.

00:32:14.640 --> 00:32:21.080
All we do is we create a
NNS mutable dictionary.

00:32:23.450 --> 00:32:30.660
Set that equal to the dict in the
ICS get parameters parameter plug.

00:32:32.720 --> 00:32:36.110
and just do an ICA scanner
get parameters.

00:32:36.130 --> 00:32:41.030
After that,
we display the result and see that,

00:32:41.060 --> 00:32:44.140
we saw that in the window,
all the information that we got back.

00:32:44.140 --> 00:32:46.080
And then we release the dictionary.

00:32:47.960 --> 00:32:55.220
Well, for doing the set parameters,
we basically do the same.

00:32:55.420 --> 00:32:57.300
See here?

00:32:58.480 --> 00:33:03.770
I do get the parameters first,
but I'm going to add...

00:33:03.970 --> 00:33:06.710
I'm going to add a new information to it.

00:33:06.710 --> 00:33:09.390
I'm doing that down here.

00:33:09.390 --> 00:33:09.780
I do set

00:33:10.320 --> 00:33:12.830
The user scan area.

00:33:12.870 --> 00:33:16.590
And the user scan area is
something that I do set up here.

00:33:17.270 --> 00:33:20.040
So for the user scan area,
I'm setting up and

00:33:20.180 --> 00:33:24.450
specifying the color mode,
bit depth, resolution,

00:33:24.450 --> 00:33:27.750
and offset width and height.

00:33:28.160 --> 00:33:29.560
Now this is a very simple setup.

00:33:29.560 --> 00:33:36.170
You can add much more parameters,
but this actually is just enough to do a

00:33:36.370 --> 00:33:41.590
low-resolution scan of the entire area,
scan area.

00:33:46.240 --> 00:33:50.830
Looking at the scanner start, well,
all it takes is a session

00:33:50.850 --> 00:33:55.660
ID and then the start,
and it currently produces,

00:33:55.660 --> 00:34:00.030
this plug-in that we have,
produces in temp a

00:34:00.030 --> 00:34:02.760
scanned image directly.

00:34:02.760 --> 00:34:04.330
And I'm...

00:34:04.500 --> 00:34:07.110
Just not displaying it right now.

00:34:07.110 --> 00:34:11.040
However,
we have of course also a new version

00:34:11.140 --> 00:34:15.310
of the Image Capture application that

00:34:16.200 --> 00:34:18.800
Basically does the same thing.

00:34:18.840 --> 00:34:26.720
So, Image Capture Application is
now handling not only cameras,

00:34:26.720 --> 00:34:29.190
but also scanners.

00:34:29.420 --> 00:34:36.530
The way we do it is we have come up
with a plug-in concept for the UI.

00:34:36.680 --> 00:34:46.690
Basically, it allows you and us to have
multiple devices with different

00:34:46.740 --> 00:34:49.940
UIs all within Image Capture.

00:34:50.100 --> 00:34:53.000
For example,
if you want to have your camera

00:34:53.090 --> 00:34:58.630
vendor and you want to have your
own UI for a specific camera,

00:34:58.630 --> 00:35:01.940
then it's very,
very easy to plug that in.

00:35:03.980 --> 00:35:10.490
So in this case, the scanner is really
handled by the scanner

00:35:11.120 --> 00:35:16.310
The Image Capture Framework is a plug-in,
and what you can do is...

00:35:17.500 --> 00:35:25.270
You can do a fine scan or better scan
of the selected area and get that.

00:35:27.910 --> 00:35:32.200
There are some parameters
that you can set,

00:35:32.260 --> 00:35:34.190
but that's just the very first UI.

00:35:34.240 --> 00:35:37.920
We're still working on that
and it will be a fleshed out

00:35:37.920 --> 00:35:41.040
version in the Jaguar release.

00:35:42.000 --> 00:35:48.030
Another important thing is,
as for all camera devices,

00:35:48.080 --> 00:35:51.470
it's also true for scanner devices,
we will have device-specific

00:35:51.680 --> 00:35:58.180
parameters in the image
capture application for Jaguar.

00:35:59.070 --> 00:36:03.980
Could, for example, have device-specific
profiles or settings,

00:36:04.000 --> 00:36:09.680
whether you want to download
and create custom icons or not?

00:36:10.970 --> 00:36:19.150
That's the simple-to-use scanner
UI within the Image Capture application.

00:36:19.170 --> 00:36:23.570
So there's really one application
that does both cameras and scanners.

00:36:23.600 --> 00:36:27.320
Switch back to the...

00:36:33.700 --> 00:36:39.200
[Transcript missing]

00:36:39.810 --> 00:36:43.650
Well, scanner drivers are supported
by Image Capture and we

00:36:43.650 --> 00:36:45.950
support basically two flavors.

00:36:45.980 --> 00:36:49.110
One is the Image Capture native ones.

00:36:49.110 --> 00:36:52.640
These are the scanner modules
that are very similar to the

00:36:52.650 --> 00:36:54.800
camera modules that we support.

00:36:54.800 --> 00:37:00.110
And we support twain data sources.

00:37:01.780 --> 00:37:03.970
Let's look at the image
capture ones first,

00:37:03.980 --> 00:37:05.010
the native ones first.

00:37:05.020 --> 00:37:10.750
Well, we again have a scanner device
framework that's very similar

00:37:10.750 --> 00:37:11.980
to the camera framework.

00:37:12.000 --> 00:37:17.960
It has just a whole bunch of codes
that you normally have to deal

00:37:18.010 --> 00:37:22.700
with when talking to the device
and more administrative things,

00:37:22.700 --> 00:37:27.290
like whenever a device gets connected,
you have to register it

00:37:27.430 --> 00:37:29.740
with Image Capture so that
it can talk with that.

00:37:29.840 --> 00:37:35.910
So all that code is really
provided by us in this framework,

00:37:35.910 --> 00:37:38.780
one for cameras, one for scanners.

00:37:40.740 --> 00:37:48.580
And the idea behind it is by just having
you implement a couple of functions

00:37:48.580 --> 00:37:54.220
that talk to the hardware directly,
it will be a lot easier for you to

00:37:54.680 --> 00:37:57.900
create scanner or camera modules.

00:38:02.370 --> 00:38:06.860
One thing that we were also asked by a
couple of vendors was button support.

00:38:06.940 --> 00:38:12.480
A lot of the new scanners have a
button or multiple buttons in front

00:38:12.510 --> 00:38:17.920
where you can click to do a copy,
click to do an email and all that.

00:38:17.980 --> 00:38:19.840
And yes, we will support that.

00:38:20.930 --> 00:38:22.390
So,

00:38:22.880 --> 00:38:26.060
Again,
we will have something in the scanner

00:38:26.860 --> 00:38:29.530
framework that deals with that.

00:38:29.580 --> 00:38:38.290
And we can do it because what you
have to do to enable it is really put

00:38:38.500 --> 00:38:40.660
some information in a special P-list.

00:38:40.660 --> 00:38:45.030
So this camera or scanner module...

00:38:46.500 --> 00:38:52.570
has deviceinfo.plist that contains
information about the device.

00:38:53.700 --> 00:39:13.100
[Transcript missing]

00:39:16.370 --> 00:39:20.900
We will have a short overview of
the train framework on Jaguar,

00:39:20.900 --> 00:39:25.700
look at some data sources,
and also client applications.

00:39:26.660 --> 00:39:30.570
Well, Twain was established as
an industry-wide standard,

00:39:30.570 --> 00:39:32.460
and it's used all over the place.

00:39:32.460 --> 00:39:38.150
I mean, for a long, long time,
we have Twain data sources.

00:39:38.770 --> 00:39:43.740
However, the support on Mac OS 9 was
unfortunately not really that great,

00:39:43.820 --> 00:39:47.520
because a long time it was
not updated and all that.

00:39:47.580 --> 00:39:51.560
But for Mac OS X,
I guess we have a really good solution.

00:39:53.570 --> 00:40:01.520
So, the three key components that are
really important for understanding

00:40:01.590 --> 00:40:05.740
the overall Twain framework are:
we have client applications,

00:40:05.740 --> 00:40:08.000
very similar to the Image Capture
client applications.

00:40:08.110 --> 00:40:10.830
We have a data source manager,
very similar to the

00:40:10.880 --> 00:40:12.270
Image Capture Framework.

00:40:12.660 --> 00:40:15.830
And we have data source,
very similar to an Image Capture

00:40:15.830 --> 00:40:17.560
camera or scanner module.

00:40:19.300 --> 00:40:24.950
So the really important part
for Twain and Jaguar really

00:40:24.970 --> 00:40:27.170
is Twain is part of Jaguar.

00:40:27.200 --> 00:40:31.200
So for the first time on
Macintosh operating system,

00:40:31.200 --> 00:40:33.520
we are installing Twain by default.

00:40:36.700 --> 00:40:39.910
And the nice thing is,
if you already have an application

00:40:39.960 --> 00:40:42.610
running with the current beta,

00:40:42.900 --> 00:41:21.000
[Transcript missing]

00:41:22.310 --> 00:41:26.920
Stop installing the Twain shared library,
the CFM shared library.

00:41:26.920 --> 00:41:30.460
So if you have an
application that you are...

00:41:31.400 --> 00:41:45.200
[Transcript missing]

00:41:46.210 --> 00:41:50.690
We will install the DSM basically
at two different locations.

00:41:50.810 --> 00:41:54.710
Well, we have, as I said before,
Twain as a native Mac-O framework

00:41:55.530 --> 00:41:58.320
in system library frameworks.

00:41:59.270 --> 00:42:03.640
And we have some clue code
for CFM-based applications in

00:42:03.640 --> 00:42:07.530
System Library CFM Support.

00:42:11.650 --> 00:42:14.430
There's also a new location
for the data sources.

00:42:14.430 --> 00:42:17.390
So if you are going to
install a data source,

00:42:17.520 --> 00:42:20.960
it's no longer in the
application support folder,

00:42:20.960 --> 00:42:24.060
but it's really in
System Library Image Capture

00:42:24.060 --> 00:42:25.600
Twain data sources.

00:42:31.000 --> 00:42:37.600
So the Twain DSM was rewritten
to be now MacO based.

00:42:37.640 --> 00:42:41.550
And the nice thing is really
it supports then MacO based

00:42:41.550 --> 00:42:44.120
Carbon and Cocoa applications.

00:42:44.120 --> 00:42:49.890
And of course,
they made sure that Twain supports

00:42:49.890 --> 00:42:53.870
MacO and CFM based data sources.

00:42:54.020 --> 00:42:58.110
So both flavors will work.

00:43:00.340 --> 00:43:05.200
There are a couple of issues if
you're currently writing a DS.

00:43:06.730 --> 00:43:08.650
Unfortunately, you have to rev.

00:43:08.750 --> 00:43:10.950
So the client application
does not have to do anything,

00:43:10.950 --> 00:43:14.500
but the DS writers, they have to rev.

00:43:15.500 --> 00:43:19.200
They have to rev in four points
that we want to look at now.

00:43:19.200 --> 00:43:22.200
The first one is packaging.

00:43:22.300 --> 00:43:25.100
It used to be that they were
just CFM shared libraries,

00:43:25.190 --> 00:43:26.850
single binary.

00:43:27.400 --> 00:43:33.350
Well, that doesn't work good with the
framework and the overall Mac OS X,

00:43:33.350 --> 00:43:37.010
so we ask you to really create bundles.

00:43:37.060 --> 00:43:40.470
Well,
these could be CFM or Mac OS bundles,

00:43:40.470 --> 00:43:42.820
but put them into a bundle.

00:43:42.820 --> 00:43:45.080
This gives you actually
a lot of advantages.

00:43:45.080 --> 00:43:49.990
Also, like localization,
so you can have multiple languages

00:43:50.170 --> 00:43:56.590
of your DS in a single binary,
a single folder bundle.

00:43:58.500 --> 00:44:16.100
[Transcript missing]

00:44:16.460 --> 00:44:19.440
Well,
for a new Carbon application with the

00:44:19.520 --> 00:44:24.390
Carbon event model or Cocoa application,
there's really no easy place to hook

00:44:24.510 --> 00:44:26.410
in your wait-next event for that.

00:44:26.460 --> 00:44:28.900
It was really bad because you had to,
like,

00:44:29.240 --> 00:44:32.470
before calling into wait-next event,
you had to call into the

00:44:32.470 --> 00:44:34.800
DS and give it some idle time.

00:44:34.800 --> 00:44:39.150
Then you get the wait-next event,
and after that you have to ask the DS,

00:44:39.150 --> 00:44:40.780
is this event for you?

00:44:40.780 --> 00:44:42.420
The DS would say no.

00:44:42.420 --> 00:44:45.380
It comes back to the application,
and the application handles it.

00:44:46.060 --> 00:44:46.450
Kind of bad.

00:44:46.520 --> 00:44:48.120
It's really this polling mechanism.

00:44:48.120 --> 00:44:49.500
We want to get away from that.

00:44:49.540 --> 00:44:54.210
So the new DS has to support
the Carbon event model.

00:44:55.620 --> 00:45:03.210
It should not be too hard to convert
existing DS to this Carbon event model.

00:45:03.740 --> 00:45:07.080
All you do is basically,
wherever you were called and

00:45:07.340 --> 00:45:12.470
asked to handle an event,
now you install Carbon Event Handler

00:45:12.470 --> 00:45:17.500
for that window or control,
and then your handler gets called

00:45:17.590 --> 00:45:20.550
directly and you handle that event.

00:45:24.920 --> 00:45:29.400
The old wait-next-event model was
also used to pass information back

00:45:29.560 --> 00:45:32.300
from the DS to the client application.

00:45:32.320 --> 00:45:35.640
Well, of course,
that's not working anymore.

00:45:35.640 --> 00:45:40.220
So what we had to do was really
introduce a callback mechanism.

00:45:40.240 --> 00:45:42.540
So a new...

00:45:45.370 --> 00:45:50.350
The TWAIN client that you will see
some source code for TWAIN client

00:45:50.400 --> 00:45:55.630
written in a small Cocoa app,
really will not get data back from the

00:45:55.770 --> 00:46:01.120
DS based on a wait-next-event call,
but it will get called via a callback.

00:46:04.140 --> 00:46:09.600
and you will get informed through that
callback whether there's a mistransfer

00:46:09.600 --> 00:46:12.280
ready or whether the DS will close.

00:46:15.980 --> 00:46:22.680
We also ask you to support an optional
feature that was the UI-less operation.

00:46:23.300 --> 00:46:29.350
So what we really want is that
the user choose whether to use

00:46:29.580 --> 00:46:38.100
the original Twain UI or our very
simplified UI within Image Capture.

00:46:38.280 --> 00:46:43.230
So in Image Capture, in the application,
there's an option which one to use.

00:46:43.570 --> 00:46:45.460
The user can choose.

00:46:47.440 --> 00:46:53.780
And we ask you, as a 20DS developer,
provide us with a device

00:46:53.780 --> 00:46:57.360
Info.plist and add that to your bundle.

00:46:57.360 --> 00:47:03.620
And that device Info.plist should contain
some information about the device itself.

00:47:04.910 --> 00:47:09.280
By just doing that,
we will be able to detect,

00:47:09.410 --> 00:47:16.050
without loading the 20S code,
to detect whether a device that's

00:47:16.130 --> 00:47:18.850
connected is handled by a given DS.

00:47:20.250 --> 00:47:25.600
This has a great advantage over the
current model because if you you will see

00:47:25.600 --> 00:47:28.960
that when we use for example Photoshop

00:47:29.330 --> 00:47:32.590
to handle or to use a
TWAIN DS is all they can do,

00:47:32.590 --> 00:47:37.580
and there's really no way around that,
all they can do is go through the

00:47:37.930 --> 00:47:40.280
installed DSs and add them to a menu.

00:47:40.280 --> 00:47:43.940
They cannot at runtime detect
whether a DS is able to

00:47:43.940 --> 00:47:46.180
handle the connected device.

00:47:46.300 --> 00:47:50.990
Or if there's no device connected,
they even list all the devices.

00:47:51.380 --> 00:47:55.100
And then you open the DS and
then the DS will get loaded and

00:47:55.100 --> 00:47:59.570
will tell you after maybe 10,
15 seconds, well,

00:47:59.570 --> 00:48:01.100
I couldn't find the device on the bus.

00:48:01.100 --> 00:48:02.900
That's kind of bad user experience.

00:48:02.900 --> 00:48:06.260
It would be nice to just dim that
menu item or not even show it at

00:48:06.260 --> 00:48:08.420
all if the device is not connected.

00:48:08.520 --> 00:48:15.290
So we will get to that whenever
we evaluate the device Info.plist.

00:48:18.050 --> 00:48:21.800
So for Twain clients,
like the previous model, as I said,

00:48:21.880 --> 00:48:24.800
was around wait next event,
and it still works.

00:48:24.800 --> 00:48:32.220
So if I would show you Photoshop running
using the new Twain framework,

00:48:32.290 --> 00:48:34.020
Photoshop was not modified.

00:48:34.020 --> 00:48:35.120
It just runs.

00:48:35.120 --> 00:48:41.260
So what we do is really getting
the event calls from Photoshop.

00:48:41.380 --> 00:48:46.210
We just pass them back immediately
and still use that mechanism

00:48:46.210 --> 00:48:50.630
to really communicate from the
DS to the Photoshop application.

00:48:52.380 --> 00:48:55.450
So the important thing is
really here for newer Carbon,

00:48:55.530 --> 00:48:59.540
newer Carbon means really
Carbon event based applications,

00:48:59.540 --> 00:49:04.260
and Cocoa applications,
they really have to register callbacks.

00:49:05.750 --> 00:49:08.300
And the callbacks, they look like that.

00:49:08.390 --> 00:49:13.560
It's very similar to the
regular DSM entry call.

00:49:15.160 --> 00:49:20.460
And all we pass back is,
or all we pass into this

00:49:20.460 --> 00:49:26.100
call is DAT callback and
message register callback.

00:49:26.200 --> 00:49:29.890
And the callback function
itself could look like that.

00:49:29.960 --> 00:49:34.460
It has the same parameters
and you get back a message.

00:49:34.510 --> 00:49:39.260
And the message could be, for example,
there's a close DS request.

00:49:39.960 --> 00:49:45.140
And then your client application will
just call TWDisabledDS and close the DS.

00:49:45.140 --> 00:49:51.130
So let's have a look at the sample.

00:49:55.700 --> 00:50:10.900
[Transcript missing]

00:50:11.700 --> 00:50:14.320
Epson, Twain, for Jaguar.

00:50:14.320 --> 00:50:22.020
So the Epson guys helped us recreate
with providing us a new native

00:50:22.020 --> 00:50:25.560
DS that uses the Carbon event model.

00:50:25.560 --> 00:50:30.000
And you see the standard
Photoshop application is just working.

00:50:30.020 --> 00:50:40.390
So I can select this and do a scan.

00:50:48.600 --> 00:50:56.600
[Transcript missing]

00:50:58.700 --> 00:51:08.500
[Transcript missing]

00:51:15.100 --> 00:51:20.200
[Transcript missing]

00:51:21.100 --> 00:51:22.100
Let's see.

00:51:22.100 --> 00:51:26.100
So when the application
did finish launch,

00:51:26.140 --> 00:51:29.350
what we do is we initialize Twain.

00:51:30.420 --> 00:51:36.280
Initializing Twain means we have
to set up application identity

00:51:36.280 --> 00:51:39.430
and call into TWInitialize.

00:51:39.440 --> 00:51:45.820
This TWInitialize is a function that
gets actually part of some Twain

00:51:45.830 --> 00:51:48.090
sources that are part of the Twain SDK.

00:51:48.150 --> 00:51:51.550
So you don't have to write that yourself.

00:51:51.560 --> 00:51:53.480
And just use that.

00:51:53.560 --> 00:51:56.880
So this is directly out of the SDK.

00:51:56.880 --> 00:51:58.930
Use that.

00:51:59.190 --> 00:52:01.520
Fill in some information
like the language,

00:52:01.630 --> 00:52:03.010
country, and all that.

00:52:03.060 --> 00:52:05.060
So after the...

00:52:06.820 --> 00:52:11.320
When TWAIN is initialized,
we register a callback.

00:52:11.320 --> 00:52:13.390
Registering a callback

00:52:14.510 --> 00:52:21.400
This is a function that we
added to the Twain sources.

00:52:21.400 --> 00:52:29.500
It's basically directly communicating
whatever call I was showing you earlier.

00:52:29.930 --> 00:52:31.720
Well, that's it on launching.

00:52:31.780 --> 00:52:36.740
So we have a select data source.

00:52:36.960 --> 00:52:42.130
Well, that's the regular
TW Select DS part of the train SDK.

00:52:42.180 --> 00:52:46.180
And we have...

00:52:48.950 --> 00:52:54.860
"We have a TW acquire
where we do a TW acquire.

00:52:54.860 --> 00:53:02.140
Unfortunately, currently the native image
type is still a pick handle.

00:53:03.110 --> 00:53:05.970
So we get back a pick handle and
have to convert that into an NSImage

00:53:05.990 --> 00:53:07.060
because we want to show that.

00:53:07.060 --> 00:53:14.480
We do that with an NSImage alloc with
data and pass in the image data and set

00:53:14.890 --> 00:53:17.360
the M image and that's basically it.

00:53:17.510 --> 00:53:18.720
So let's run this small app.

00:53:25.390 --> 00:53:32.100
So that's the new native Mac O Twain
DSM showing this selection dialog.

00:53:32.100 --> 00:53:35.540
You noticed before that
Photoshop is not using that dialog.

00:53:35.540 --> 00:53:40.240
Photoshop is just evaluating,
examining the DSS directly

00:53:40.240 --> 00:53:46.100
and adding those DSS that
it finds to the import menu.

00:53:46.100 --> 00:53:50.540
So this application is
using the selection dialog.

00:53:50.540 --> 00:53:53.860
And we can do acquire.

00:53:56.370 --> 00:54:01.670
The first thing you acquire in
this case brings up the 20S.

00:54:09.000 --> 00:54:15.100
[Transcript missing]

00:54:21.100 --> 00:54:25.170
"We scan in the image,
actually it's currently still open,

00:54:25.170 --> 00:54:29.430
close it, and we just scan in an image
in a Cocoa application that's

00:54:29.430 --> 00:54:31.780
just a couple of lines of code."

00:54:35.390 --> 00:54:41.960
Okay, so we both have,
well we have now two different

00:54:42.190 --> 00:54:44.220
ways to talk to a scanner.

00:54:44.220 --> 00:54:47.210
Image Capture and Twain.

00:54:47.240 --> 00:54:53.180
See the sample application here we were
just using Twain APIs to do the scanning.

00:54:53.180 --> 00:54:58.270
Another question is really for you.

00:55:00.010 --> 00:55:03.100
How do both work together?

00:55:03.100 --> 00:55:07.650
So do you have to install one or
remove the others or all that?

00:55:07.770 --> 00:55:11.900
Well, actually,
we will have a Twain bridge.

00:55:11.960 --> 00:55:14.910
So that means we will
have a piece of code,

00:55:14.910 --> 00:55:20.310
an image capture device module,
that talks to a Twain DS.

00:55:20.820 --> 00:55:26.230
So that means that you can still
be all in the image capture world,

00:55:26.330 --> 00:55:31.540
the ICA API world, and use the 20S.

00:55:34.070 --> 00:55:36.400
The advantage of having this
train bridge is actually one

00:55:36.430 --> 00:55:37.640
thing that I mentioned before.

00:55:37.640 --> 00:55:39.060
That's also the button support.

00:55:39.100 --> 00:55:43.600
Because train bridge will get launched
whenever the scanner is connected.

00:55:45.490 --> 00:55:51.630
Then this Twain Bridge is running and
it actually will monitor device buttons.

00:55:51.680 --> 00:55:54.240
So you press a button and the
Twain Bridge will listen to it.

00:55:54.680 --> 00:55:59.040
Then depending on the
section that you made before,

00:55:59.040 --> 00:56:04.440
actually it will allow you to
trigger the correct action.

00:56:07.880 --> 00:56:12.400
So device arbitration
is just what I said.

00:56:12.400 --> 00:56:15.920
And for you, the question now.

00:56:16.240 --> 00:56:18.240
Which framework should you use?

00:56:18.250 --> 00:56:20.190
It's really up to your needs.

00:56:20.350 --> 00:56:25.300
So, Image Capture should give
you an easy way to work with

00:56:25.300 --> 00:56:28.480
Image Capture and 2nds devices.

00:56:30.230 --> 00:56:35.330
Twain is probably more powerful
because you have more control.

00:56:35.330 --> 00:56:38.600
So the Image Capture Approach
is really keep it simple,

00:56:38.600 --> 00:56:44.930
make it simple for a lot of applications
to just have an acquire or import button.

00:56:44.930 --> 00:56:50.630
But if you really want to go into
the depth of controlling the device,

00:56:50.630 --> 00:56:53.300
Twain might be the right way.

00:56:57.710 --> 00:57:01.890
Now let's look at some other changes
in the upcoming Jaguar release.

00:57:01.900 --> 00:57:04.790
First of all, Digital Hub.

00:57:06.510 --> 00:57:13.780
Digital Hub and Application Launching
is something that will be new in Jaguar.

00:57:13.780 --> 00:57:17.580
And we actually got
asked a couple of times,

00:57:17.580 --> 00:57:24.690
how do I change the hot plug action
on a current Mac OS X system?

00:57:24.700 --> 00:57:27.920
So a lot of people
were installing iPhoto,

00:57:27.920 --> 00:57:33.160
and iPhoto may be their default
application for a while,

00:57:33.160 --> 00:57:37.000
but if they just want to change
that to an image capture or

00:57:37.000 --> 00:57:40.000
another third-party application,
how do they do that?

00:57:40.100 --> 00:57:41.910
Well, unfortunately,
they had to go to the

00:57:41.990 --> 00:57:43.280
image capture application.

00:57:43.760 --> 00:57:47.750
Although it has only three pop-ups,
it was not quite obvious

00:57:47.900 --> 00:57:50.550
for a lot of people,
so we got a lot of questions about that.

00:57:52.140 --> 00:57:58.550
So I guess the better solution is really,
and not only for image capture devices,

00:57:58.630 --> 00:58:01.970
but a lot of other devices,
since we're claiming to

00:58:02.170 --> 00:58:04.730
be the ideal digital hub,

00:58:05.040 --> 00:58:11.250
We will have, and you probably saw
that this week already,

00:58:11.250 --> 00:58:18.440
we'll have a digital hub panel or
part in the system preferences.

00:58:18.460 --> 00:58:20.940
So let me just show you that.

00:58:27.210 --> 00:58:32.890
So, going in here,
you see System Preferences come up with

00:58:32.890 --> 00:58:39.190
a Digital Hub part and for photography,
well, you can now choose what to do

00:58:39.190 --> 00:58:42.770
when a camera gets connected,
when you insert a picture CD,

00:58:43.000 --> 00:58:47.700
when you connect a scanner,
or when you press the scanner's button.

00:58:48.360 --> 00:58:56.230
So it's quite often probably
that you will want to do nothing

00:58:56.230 --> 00:58:58.600
when the scanner is connected,
because quite often the scanner

00:58:58.600 --> 00:58:59.840
is connected all the time.

00:58:59.840 --> 00:59:07.040
And you want to activate your application
only when you push a button on it.

00:59:07.040 --> 00:59:09.220
That's the way to launch it.

00:59:10.850 --> 00:59:13.700
And while we are here,
the upcoming changes,

00:59:13.700 --> 00:59:19.530
one thing I want to show you as well.

00:59:22.410 --> 00:59:30.680
That's new in the new version of
the Image Capture application.

00:59:30.770 --> 00:59:35.590
I was saying before that one application,
due to plug-in mechanism,

00:59:35.590 --> 00:59:40.090
is now able to handle multiple
devices and present multiple UIs.

00:59:40.360 --> 00:59:49.470
See, the same application here is
now showing the UI for camera.

00:59:50.510 --> 00:59:53.490
The only difference to
the current version,

00:59:53.500 --> 00:59:55.890
at least the first difference
is there's one pop-up missing,

00:59:55.900 --> 00:59:57.100
the hot-block action is missing.

00:59:57.100 --> 01:00:00.440
That's really now part
of the digital hub.

01:00:01.120 --> 01:00:04.600
These options are now,
I mentioned that before,

01:00:04.600 --> 01:00:08.200
are device specific.

01:00:09.600 --> 01:00:16.210
So you can specify a profile per camera,
and that will stick with that camera.

01:00:16.900 --> 01:00:22.800
[Transcript missing]

01:00:23.140 --> 01:00:28.280
So if you're at home and you and
your wife or you and your husband,

01:00:28.280 --> 01:00:31.950
they have two cameras.

01:00:33.110 --> 01:00:46.850
www.img-report.com/image-capture-frame
work-applications/

01:00:47.260 --> 01:00:50.860
So downloading SAM, well,
it's also a bit new UI here.

01:00:50.860 --> 01:00:56.040
But also one very nice thing is you
have the pop-ups also in this window.

01:00:56.040 --> 01:00:58.930
Basically,
you can go to the data browser window,

01:00:58.930 --> 01:01:03.100
select a couple of images,
specify a download folder for these two,

01:01:03.100 --> 01:01:06.070
press download, and download the two,
and download the next four

01:01:06.070 --> 01:01:07.420
to a different location.

01:01:09.040 --> 01:01:13.190
So a couple of things that we
actually added to the UI here.

01:01:13.290 --> 01:01:17.440
For example, you can also add a
thumbnail size here and then

01:01:19.000 --> 01:01:33.300
[Transcript missing]

01:01:40.340 --> 01:01:44.500
So one upcoming change is an
extended event notification.

01:01:44.500 --> 01:01:51.000
The current mechanism was not
that suitable to propagate events

01:01:51.000 --> 01:01:57.160
that come from the device to
the client application directly.

01:01:57.160 --> 01:02:01.350
So currently we are supporting
very well device connected,

01:02:01.450 --> 01:02:06.160
device disconnected,
image card removed or put in,

01:02:06.160 --> 01:02:08.200
or image was taken.

01:02:08.200 --> 01:02:12.870
This camera actually can take images from
within the Image Capture application.

01:02:12.930 --> 01:02:17.720
Or whenever you delete an image,
then also the client

01:02:17.720 --> 01:02:20.580
application gets notified.

01:02:20.790 --> 01:02:25.780
But there are some cameras that
have some events that they produce.

01:02:25.870 --> 01:02:27.290
For example, the camera is connected.

01:02:27.380 --> 01:02:29.420
You take pictures from there,
so there's no interaction

01:02:29.420 --> 01:02:30.450
from the client application.

01:02:30.490 --> 01:02:32.950
You take the pictures
directly on the device,

01:02:32.950 --> 01:02:36.580
and you still want to propagate
that to the client application.

01:02:36.580 --> 01:02:41.110
For that,
we really had to extend the current event

01:02:41.240 --> 01:02:49.100
register notification parameter block,
so we were adding things to it, like...

01:02:50.900 --> 01:03:07.400
[Transcript missing]

01:03:08.800 --> 01:03:13.200
So registering and unregistering
is actually the same as before.

01:03:13.250 --> 01:03:20.630
You register by specifying an object
that could be nil to an EXCD to get

01:03:20.630 --> 01:03:28.550
notified for new notifications of 00 in
both cases to get notified on all events.

01:03:28.600 --> 01:03:31.030
And to unregister,
basically use the same parameters

01:03:31.380 --> 01:03:36.410
as on the registration except
specify null as completion proc.

01:03:36.870 --> 01:03:41.560
So in this case here, we are just doing a
registration for all events.

01:03:41.570 --> 01:03:44.460
And on registration for all events,
you see the difference is that my

01:03:44.460 --> 01:03:49.590
completion proc gets changed by,
replaced by another.

01:03:50.200 --> 01:03:53.640
DeviceInfo.plist, we talked about that a
couple of times before,

01:03:53.720 --> 01:03:59.460
and we really have that as a way to
identify more features of the device.

01:04:00.860 --> 01:04:05.490
And for example, currently we use that to
display a nice camera icon.

01:04:05.500 --> 01:04:08.760
Depending on the model that you connect,
you will see that Image Capture

01:04:08.780 --> 01:04:12.850
Application comes up with a
real nice icon for that device.

01:04:12.910 --> 01:04:16.910
And that's really done based on
the information in the Info.plist.

01:04:17.390 --> 01:04:19.480
Well,
we also are going to extend that and

01:04:19.480 --> 01:04:21.440
add some more information in here.

01:04:21.440 --> 01:04:22.940
For example, a color sync profile.

01:04:22.940 --> 01:04:27.210
So the color sync profile
and device class information

01:04:27.210 --> 01:04:29.740
is added to the Info.plist.

01:04:31.530 --> 01:04:39.000
and allows us to use and embed later
on the correct profile for your images.

01:04:41.160 --> 01:04:46.100
One other thing where we are going to
add a new feature that's a pass-through

01:04:46.100 --> 01:04:53.090
mechanism that's basically a simple way
to control device-specific features.

01:04:53.130 --> 01:04:57.000
So if you know exactly about
the device that's connected,

01:04:57.000 --> 01:05:02.540
most likely that's a
vendor-specific application.

01:05:03.540 --> 01:05:10.120
So if you know about that device
and you want to do some private

01:05:10.130 --> 01:05:14.190
calls and private commands,
send that to the device.

01:05:14.220 --> 01:05:16.960
That's also easy to do now
with a pass-through mechanism

01:05:17.300 --> 01:05:20.160
where Image Capture just
treats it as a plug of data.

01:05:20.160 --> 01:05:23.730
We send it to the device and the
device knows what happens with it,

01:05:23.730 --> 01:05:24.520
what to do.

01:05:27.110 --> 01:05:29.430
Metadata for input devices.

01:05:29.430 --> 01:05:32.040
Well, of course,
there are some color issues,

01:05:32.040 --> 01:05:36.120
and you probably learned earlier
this week that Megalos 10 is really

01:05:36.120 --> 01:05:38.340
a full color-managed environment.

01:05:38.340 --> 01:05:43.400
And in the ColorSync session,
you also learned about a couple of weak

01:05:43.650 --> 01:05:46.780
links in that whole ColorSync workflow.

01:05:47.660 --> 01:05:50.900
Like one weak link is
right at the beginning.

01:05:50.900 --> 01:05:55.690
That's whenever we get the
images from a digital camera,

01:05:55.800 --> 01:05:58.990
and they may not contain
ColorSync profiles.

01:05:59.070 --> 01:06:02.020
But the user may want to
embed a ColorSync profile.

01:06:02.020 --> 01:06:03.750
So what is the best way to do that?

01:06:03.820 --> 01:06:07.370
Well, actually,
a good way is whenever I'm

01:06:07.470 --> 01:06:11.660
going to embed a profile,
I use the default profile

01:06:11.660 --> 01:06:13.510
for input devices.

01:06:15.480 --> 01:06:20.440
A better way is the device itself
specifies a profile for all its images.

01:06:20.470 --> 01:06:26.680
Actually, the best way is if the device
would specify a per-image profile.

01:06:30.530 --> 01:06:33.130
And now it's important
for your application,

01:06:33.130 --> 01:06:36.530
dealing with images,
that you preserve the metadata.

01:06:36.560 --> 01:06:39.420
Preserving metadata...

01:06:41.700 --> 01:06:47.330
is also preserving embedded profiles.

01:06:47.330 --> 01:06:47.330
So if the device embeds a profile,

01:06:47.500 --> 01:07:08.000
[Transcript missing]

01:07:09.040 --> 01:07:11.580
And I guess the last thing
I'm going to show you is a

01:07:11.640 --> 01:07:15.500
small application that we have,
and it's called Camera Check.

01:07:15.670 --> 01:07:20.520
And the idea behind it is really
give the user a chance to hook

01:07:20.690 --> 01:07:26.140
up his camera and then see about
the capabilities for that camera.

01:07:26.140 --> 01:07:30.780
So in this case,
I have the Image Capture application.

01:07:30.780 --> 01:07:32.820
Just quit that and launch Camera Check.

01:07:32.860 --> 01:07:37.880
It comes up with a dialog saying, well,
a couple of things about the application.

01:07:38.720 --> 01:07:43.170
It tells you about its
preferences and allows you to...

01:07:43.400 --> 01:08:10.400
[Transcript missing]

01:08:11.100 --> 01:08:14.300
We'll find out that this device
is able to take pictures.

01:08:14.330 --> 01:08:17.920
So the result is okay.

01:08:17.920 --> 01:08:26.290
That means if I go back to
the Image Capture application,

01:08:26.290 --> 01:08:26.290
I can actually...

01:08:29.510 --> 01:08:32.840
"I'm going to drag this one up here.

01:08:32.840 --> 01:08:37.710
So I have a take picture and what
I can do is then really go in here.

01:08:38.340 --> 01:08:42.680
Take a picture and then after
the camera stops flashing,

01:08:42.680 --> 01:08:46.330
the new picture should
show up and be in here.

01:08:46.360 --> 01:08:47.940
So just, okay, not great.

01:08:48.090 --> 01:08:50.560
Okay.
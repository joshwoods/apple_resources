WEBVTT

00:00:03.460 --> 00:00:04.380
Good afternoon everyone.

00:00:04.400 --> 00:00:08.760
Welcome to session 501,
which is Quartz 2D & PDF.

00:00:08.790 --> 00:00:09.480
I'm Travis Brown.

00:00:09.480 --> 00:00:11.380
I'm the graphics and imaging evangelist.

00:00:11.430 --> 00:00:14.350
And one of the technologies I work
with and help drive developer

00:00:14.350 --> 00:00:16.680
adoption with is Quartz 2D.

00:00:16.750 --> 00:00:19.160
And one thing that was important
that Avi mentioned in yesterday's

00:00:19.160 --> 00:00:22.570
keynote is for developers to start
considering creating applications

00:00:22.580 --> 00:00:24.110
that run only on Mac OS X.

00:00:24.110 --> 00:00:28.470
One of the fantastic opportunities
you have in deploying Mac OS X only

00:00:28.470 --> 00:00:31.950
applications is leveraging
technologies that only exist on X.

00:00:32.020 --> 00:00:34.490
And one technology that we're
really proud of and we think offers

00:00:34.500 --> 00:00:38.090
a lot of benefit for the developer
and the end user is Quartz 2D,

00:00:38.240 --> 00:00:41.360
which is a new 2D drawing library.

00:00:41.450 --> 00:00:42.240
It's very powerful.

00:00:42.340 --> 00:00:44.700
It's based on a different
imaging model from Quickdraw,

00:00:44.820 --> 00:00:48.010
which we're very familiar with,
but also suffers from none of the

00:00:48.010 --> 00:00:54.040
limitations that Quickdraw has saddled
us with for over the past near 15 years.

00:00:54.040 --> 00:00:56.770
So it's interesting to see that
certain developers have already

00:00:57.060 --> 00:00:58.490
gone ahead and done this.

00:00:58.500 --> 00:01:02.490
We held up Microsoft as an example in
a couple sessions where they decided to

00:01:02.490 --> 00:01:07.750
deliver Office 10 only on Mac OS X and
decided to begin to move their

00:01:07.840 --> 00:01:11.610
Carbon application from Quickdraw-based
calls to sort of incrementally begin

00:01:11.610 --> 00:01:15.290
to move that application over to using
Quartz 2D for part of its rendering.

00:01:15.390 --> 00:01:19.150
And it's something that's very
possible for all applications to do.

00:01:19.150 --> 00:01:22.100
So you don't have to really
consider your development cycle to

00:01:22.100 --> 00:01:25.910
engage new Mac OS X technologies
and particularly Quartz 2D to

00:01:25.910 --> 00:01:28.170
be an all or nothing proposition.

00:01:28.210 --> 00:01:30.630
And that's something you really need
to be thinking about as we go through

00:01:30.660 --> 00:01:33.580
today's presentation where we talk
specifically about the advantages of

00:01:33.590 --> 00:01:37.080
Quartz 2D and also how it works and a
lot of new features that we've put in

00:01:37.080 --> 00:01:39.470
specifically upon developer request.

00:01:39.560 --> 00:01:41.390
So to help out with the
rest of the session,

00:01:41.440 --> 00:01:44.710
I'd like to invite Derek Clegg
with Quartz Engineering to stage to

00:01:44.710 --> 00:01:46.950
take you through the presentation.

00:01:53.930 --> 00:01:54.840
My name is Derek Clegg.

00:01:54.930 --> 00:01:59.040
I'm the principal engineer
responsible for the API in Quartz 2D.

00:01:59.060 --> 00:02:03.720
And today we're going to discuss sort
of a general overview of what Quartz is.

00:02:03.740 --> 00:02:06.290
We're going to talk a little bit
about the Quartz architecture,

00:02:06.410 --> 00:02:09.580
but mostly spend our
time on the Quartz APIs.

00:02:10.020 --> 00:02:14.310
We'll have a little bit of demo thrown
in here and there along the way.

00:02:15.210 --> 00:02:16.100
So what is Quartz?

00:02:16.180 --> 00:02:18.100
Well, as you probably have seen
in the earlier sessions,

00:02:18.130 --> 00:02:21.100
it's the underlying
graphics system on Mac OS X.

00:02:21.150 --> 00:02:23.100
There are two components of
it that are important today.

00:02:23.100 --> 00:02:26.100
There's Quartz 2D,
which is the API level that you call,

00:02:26.100 --> 00:02:30.010
and there's the Quartz compositor
that lives underneath that.

00:02:30.360 --> 00:02:32.960
This is a diagram you may have
seen in an earlier session.

00:02:32.960 --> 00:02:39.430
Quartz 2D, the one little lozenge,
lives on top of the Quartz compositor

00:02:39.430 --> 00:02:41.060
as well as OpenGL and QuickTime.

00:02:41.380 --> 00:02:47.730
All of those talk to the lower
level piece of the system which

00:02:47.730 --> 00:02:47.730
actually takes Windows and
composites them up on the screen.

00:02:48.220 --> 00:02:51.100
The compositor itself is
treated in a separate session,

00:02:51.100 --> 00:02:52.720
one right after this one.

00:02:52.770 --> 00:02:53.700
It's very interesting.

00:02:53.700 --> 00:02:56.100
You may have seen some of
this earlier in Peter's talk.

00:02:56.100 --> 00:02:59.060
I definitely would recommend
going to that talk if you're

00:02:59.060 --> 00:03:01.240
interested at all in the compositor.

00:03:01.280 --> 00:03:02.400
I won't talk about that today.

00:03:02.400 --> 00:03:07.100
I'm going to be focusing on
the higher level APIs that

00:03:07.100 --> 00:03:07.100
you call in your application.

00:03:07.520 --> 00:03:10.540
So what is Quartz 2D
from your point of view?

00:03:10.620 --> 00:03:12.960
It's a low-level,
lightweight rendering library.

00:03:12.960 --> 00:03:16.540
So it lives underneath a lot of
the other parts of the system,

00:03:16.610 --> 00:03:19.220
underneath the main frameworks,
Carbon and Cocoa.

00:03:19.410 --> 00:03:21.910
It's lightweight in that
the APIs are very simple.

00:03:22.210 --> 00:03:26.240
There's a real clear design choice
to make the APIs powerful but not

00:03:26.240 --> 00:03:29.780
sort of give you an entire pile
of things that you have to learn.

00:03:29.880 --> 00:03:31.400
It's very simple and easy to use.

00:03:31.400 --> 00:03:32.740
And of course it's 2D only.

00:03:32.740 --> 00:03:34.110
We're not trying to do any 3D.

00:03:34.190 --> 00:03:35.460
We're just focusing on 2D.

00:03:35.560 --> 00:03:36.930
It's resolution independent.

00:03:37.110 --> 00:03:40.400
What that means is that
whether you're talking to a 300

00:03:40.490 --> 00:03:43.340
DPI printer or a 72 DPI screen,
the API that you use,

00:03:43.340 --> 00:03:45.560
the calls you make are exactly identical.

00:03:45.560 --> 00:03:49.030
So you don't have to worry about
the final destination in terms

00:03:49.030 --> 00:03:50.920
of what your calls are doing.

00:03:50.920 --> 00:03:54.080
Similarly, device independent, a printer,
a screen, a bitmap,

00:03:54.080 --> 00:03:55.840
all the same API calls that you make.

00:03:55.840 --> 00:03:58.120
So your application doesn't have to
worry about all that kind of stuff.

00:03:58.140 --> 00:04:00.920
And that can be very powerful.

00:04:00.920 --> 00:04:04.380
Because we want to provide
high quality text and colors,

00:04:04.380 --> 00:04:07.550
we leverage Apple technology
for font management.

00:04:07.550 --> 00:04:11.360
We use ATS so we get all of the type one,
true type, so on font support.

00:04:11.360 --> 00:04:13.280
And we use ColorSync for color rendering.

00:04:13.280 --> 00:04:17.410
That guarantees you get high fidelity
color so what you see on the screen

00:04:17.470 --> 00:04:19.590
is going to be what you end up on the

00:04:21.700 --> 00:04:22.960
So who uses it currently?

00:04:23.050 --> 00:04:25.440
Well, obviously the highest level
parts of the system do.

00:04:25.440 --> 00:04:28.070
Cocoa and Carbon both use
Quartz 2D very heavily.

00:04:28.370 --> 00:04:32.820
In fact, Cocoa is very closely
matching the Quartz 2D APIs.

00:04:32.820 --> 00:04:35.280
In many cases,
if you use a Cocoa application,

00:04:35.280 --> 00:04:37.830
if you write one in Cocoa,
you don't actually need to go down

00:04:37.920 --> 00:04:40.610
to the Quartz 2D level because
a lot of that stuff is already

00:04:40.610 --> 00:04:42.480
handled at the Cocoa level.

00:04:42.540 --> 00:04:46.320
Carbon, however, still,
as was mentioned earlier,

00:04:46.320 --> 00:04:48.370
there are cases where
Carbon is using Quick Draw,

00:04:48.530 --> 00:04:52.330
but it's also starting to use
Core Graphics Quartz 2D more and more.

00:04:52.360 --> 00:04:55.930
And so that's a place where
we're also having the framework

00:04:56.030 --> 00:04:57.550
live on top of Quartz 2D.

00:04:57.550 --> 00:04:59.380
Java also uses it for many things.

00:04:59.660 --> 00:05:02.160
A lot of third-party
applications are switching over.

00:05:02.160 --> 00:05:04.500
As Travis mentioned,
Microsoft has started to use

00:05:04.640 --> 00:05:07.030
Quartz 2D almost exclusively
for a lot of their drawing.

00:05:07.140 --> 00:05:10.360
And of course,
your application can use it.

00:05:10.360 --> 00:05:14.320
The way your application would use it
is by using the Core Graphics framework.

00:05:14.430 --> 00:05:17.270
The APIs are called Core Graphics
for historical reasons.

00:05:17.270 --> 00:05:20.100
I'm going to use both Core Graphics
and CG and Quartz 2D interchangeably.

00:05:20.370 --> 00:05:22.970
They're all the same basic idea.

00:05:23.200 --> 00:05:27.100
The advantages of Quartz 2D are
pretty straightforward over Quickdraw.

00:05:27.100 --> 00:05:30.740
In principle,
you get very high quality 2D graphics.

00:05:30.740 --> 00:05:32.570
In particular,
you get anti-alias rendering

00:05:32.570 --> 00:05:36.820
for all of your drawing,
sometimes whether you like it or not.

00:05:36.820 --> 00:05:38.910
Some people have issues with
anti-alias rendering of text,

00:05:39.040 --> 00:05:41.950
but for regular drawing,
for vector art and so on,

00:05:41.950 --> 00:05:43.070
nothing beats it.

00:05:43.110 --> 00:05:45.710
It makes your application look
really smooth and really nice.

00:05:45.780 --> 00:05:48.950
And of course, you get transparency,
which allows you to do fades

00:05:48.950 --> 00:05:51.880
and do overlays and stuff like
that in a very simple way.

00:05:51.900 --> 00:05:54.340
Quartz 2D can also be used
for off-screen rendering.

00:05:54.420 --> 00:05:57.650
You can create an off-screen bitmap
that you draw to just the same way

00:05:57.650 --> 00:06:01.240
you would to draw on screen or to an
output printer or something like that.

00:06:01.240 --> 00:06:03.010
And then once you have
that off-screen bitmap,

00:06:03.010 --> 00:06:06.740
you could then say, for example,
draw it back into your application

00:06:06.740 --> 00:06:11.310
or send it out as a special image,
anything like that that you want to do.

00:06:11.420 --> 00:06:14.150
For PDF document import,
if you have PDF files that

00:06:14.210 --> 00:06:16.620
you're interested in bringing
into your application,

00:06:16.730 --> 00:06:20.570
Quartz 2D supports that and lets you draw
any page in the document very easily.

00:06:20.700 --> 00:06:25.420
And similarly, if you want to export PDF,
if you want to export

00:06:25.420 --> 00:06:27.620
PDF on your own way,
not necessarily going

00:06:27.620 --> 00:06:30.320
through the printing system,
sort of the print preview feature,

00:06:30.550 --> 00:06:35.180
but by creating your own PDF files,
it's very easy to do that with Quartz 2D.

00:06:35.180 --> 00:06:38.290
So as a simple example,
here we have a nice, you know,

00:06:38.420 --> 00:06:41.460
perfectly fine Excel document
drawn using Quick Draw.

00:06:41.500 --> 00:06:43.540
It's really good, but you sort of,
you know,

00:06:43.680 --> 00:06:47.660
you can't quite figure out what's
going on behind that blue wall.

00:06:47.660 --> 00:06:51.600
So if you use transparency,
you can get a much nicer effect.

00:06:51.600 --> 00:06:53.620
So this is actually a
pretty simple example,

00:06:53.630 --> 00:06:56.970
but it shows sort of how your
application might use transparency,

00:06:56.980 --> 00:06:59.230
maybe you might use
anti-aliasing and so on,

00:06:59.380 --> 00:07:03.570
to get a better result in the final,
for your final output.

00:07:04.140 --> 00:07:10.200
Okay, so that's the basic overview
of the architecture.

00:07:11.280 --> 00:07:14.980
And now we're going to talk a little
bit more technically about some of the,

00:07:14.980 --> 00:07:18.020
what we call the core graphics types,
the basic pieces of the

00:07:18.020 --> 00:07:19.200
system that you use.

00:07:19.300 --> 00:07:24.310
I'm going to talk about all
the types that are available,

00:07:24.420 --> 00:07:28.760
but I'm mostly going to
focus on the new things.

00:07:28.760 --> 00:07:33.610
I want to make sure that we
cover everything for people

00:07:33.610 --> 00:07:33.910
who are new here this year,
but the primary focus is

00:07:33.910 --> 00:07:33.910
going to be on the new APIs.

00:07:34.190 --> 00:07:36.900
So what kind of types are
available for Core Graphics?

00:07:36.950 --> 00:07:37.670
Well, context.

00:07:37.930 --> 00:07:39.010
Context is sort of the workhorse.

00:07:39.100 --> 00:07:41.000
Everything goes through a context.

00:07:41.030 --> 00:07:43.800
Once you have a context,
you can use a path to

00:07:43.890 --> 00:07:47.160
draw to the context,
fonts, images, PDF documents.

00:07:47.210 --> 00:07:49.550
Whoops, excuse me.

00:07:49.880 --> 00:07:51.760
If you're drawing,
once you start drawing things,

00:07:51.760 --> 00:07:55.090
of course you're going to be working
with colors and color spaces.

00:07:55.380 --> 00:07:58.620
Patterns are new this year,
allow you to do replicated drawing.

00:07:58.620 --> 00:08:00.840
Shadings for gradient fills
are also new this year.

00:08:00.840 --> 00:08:04.180
We have additional functions to let
you manage geometry and API transforms,

00:08:04.180 --> 00:08:05.260
some convenience functions.

00:08:05.260 --> 00:08:09.330
And data managers are the way you get
data into and out of Core graphics.

00:08:09.410 --> 00:08:13.000
So let's talk about each of those
in a little bit more detail.

00:08:13.000 --> 00:08:16.420
The context is the principal thing.

00:08:16.430 --> 00:08:17.870
Everything goes to the context.

00:08:17.960 --> 00:08:19.560
If you don't have a context,
you're not drawing.

00:08:19.600 --> 00:08:21.260
So you've got to start with the context.

00:08:21.820 --> 00:08:25.410
It abstracts the device and
represents sort of wherever you

00:08:25.410 --> 00:08:27.730
might be going to the destination.

00:08:27.740 --> 00:08:30.830
So you have a context for a printer,
for a PDF file, for a bitmap,

00:08:30.830 --> 00:08:34.180
for the on-screen rendering,
all the same basic thing.

00:08:34.180 --> 00:08:36.200
It all comes down to a
single context you talk to.

00:08:36.200 --> 00:08:40.500
Additionally, the context keeps track of
graphic state information for you,

00:08:40.580 --> 00:08:43.140
so you don't have to be resetting
that information every single time.

00:08:43.160 --> 00:08:46.730
It would track the color or
the line width or various other

00:08:46.730 --> 00:08:48.780
parameters of your drawing.

00:08:48.780 --> 00:08:51.480
And the state that contains
all that information,

00:08:51.820 --> 00:08:53.820
can be saved and restored.

00:08:53.820 --> 00:08:57.300
So you can save the state,
change some of the parameters,

00:08:57.400 --> 00:08:59.440
do a little bit of drawing and
restore back to the original state.

00:08:59.440 --> 00:09:03.010
So you don't have to do as
much tracking yourself as well.

00:09:03.480 --> 00:09:06.740
The contexts that are supported
are the same as last year.

00:09:06.770 --> 00:09:10.020
The window context, which is created for
you by Carbon or Cocoa,

00:09:10.280 --> 00:09:12.930
still that's the way you
get to a window context.

00:09:13.260 --> 00:09:16.370
Postscript context,
usually created by the printing

00:09:16.810 --> 00:09:19.820
system when you're going to
go to a postscript printer.

00:09:19.820 --> 00:09:24.120
A PDF context also is often created
for you by the printing system,

00:09:24.170 --> 00:09:28.620
but it can be created by you directly
if you want to create a PDF file

00:09:28.620 --> 00:09:31.930
with the CGPDFCONTEXT_CREATE function
that allows you to create

00:09:31.930 --> 00:09:34.500
PDF context directly to draw into.

00:09:34.500 --> 00:09:37.500
And then off-screen bitmaps,
or just regular bitmaps,

00:09:37.500 --> 00:09:41.500
CGBitmapContextCreate, you pass in data,
you pass in a bunch of parameters

00:09:41.500 --> 00:09:44.230
that say how the data is arranged,
and then all of the drawing

00:09:44.240 --> 00:09:45.500
will end up on that context.

00:09:45.500 --> 00:09:49.030
Sorry, onto that data for you.

00:09:50.680 --> 00:09:54.040
So the primitives that we have this year,
there are a couple of new

00:09:54.040 --> 00:09:56.870
ones and some old favorites.

00:10:00.120 --> 00:10:03.440
Basic drawing is pretty much
broken down into vector geometry,

00:10:03.510 --> 00:10:04.300
text, and images.

00:10:04.300 --> 00:10:07.400
That's a lot of the basic
components of drawing any sort

00:10:07.400 --> 00:10:09.740
of graphics you want to do.

00:10:09.850 --> 00:10:13.640
To do vector geometry,
we have this year a CGPath type,

00:10:13.730 --> 00:10:17.260
which lets you abstract away how a
path is represented in the system.

00:10:17.380 --> 00:10:20.950
There's also, of course, as in the past,
paths built into the context itself.

00:10:21.060 --> 00:10:23.610
But we now have a separate type
that lets you record a path and

00:10:23.610 --> 00:10:26.700
keep track of a path independently
from the context itself.

00:10:26.800 --> 00:10:29.220
CGFont is for text, CGImage, of course,
for images,

00:10:29.260 --> 00:10:32.940
and PDFDocument for PDF document import.

00:10:33.080 --> 00:10:36.680
This year we have added patterns,
so that lets you do repeated

00:10:36.680 --> 00:10:39.340
drawing in a very easy way.

00:10:39.340 --> 00:10:42.140
And CGShading,
that's our way of abstracting gradients,

00:10:42.140 --> 00:10:45.630
typically either an
axial or radial gradient.

00:10:46.180 --> 00:10:49.460
So let's switch to demo one,
and we'll have a little demo

00:10:49.730 --> 00:10:55.000
of vector geometry and path
objects in Core Graphics.

00:10:55.030 --> 00:10:56.910
Let's see.

00:10:59.460 --> 00:11:02.400
So as you see,
here's a simple application.

00:11:02.440 --> 00:11:05.660
It's a Cocoa application that I wrote in,
I don't know, a couple hours.

00:11:05.660 --> 00:11:07.900
Every Cocoa application, they always say,
oh, you can write it in 10 minutes,

00:11:07.980 --> 00:11:09.420
and it turned out a
little longer than that,

00:11:09.510 --> 00:11:10.260
but it was still pretty fast.

00:11:10.320 --> 00:11:14.690
What I'm showing you here is a
Cocoa application that's using

00:11:14.800 --> 00:11:18.580
native Core Graphics calls to do all
of the drawing inside the windows.

00:11:18.600 --> 00:11:22.610
So I haven't done any optimization,
so you'll see it's actually

00:11:22.610 --> 00:11:25.290
pretty fast without actually
doing anything special at all.

00:11:26.060 --> 00:11:29.650
So this is an example of drawing a path.

00:11:29.730 --> 00:11:31.140
In this case, I'm drawing a rectangle.

00:11:31.140 --> 00:11:34.120
As you can see,
the path is the rectangle itself,

00:11:34.190 --> 00:11:36.000
and here I'm both filling and stroking.

00:11:36.000 --> 00:11:40.940
To show you the actual path
element that I have created,

00:11:40.940 --> 00:11:46.360
the actual thing that I tell the context
to draw is this red line in the middle.

00:11:46.360 --> 00:11:50.260
So you can see that what that
means is that when we stroke,

00:11:50.260 --> 00:11:54.510
for example, we're actually stroking
on both sides of the path,

00:11:54.660 --> 00:11:57.980
inside and outside,
and the fill is all inside the path.

00:11:58.210 --> 00:12:02.670
If I turn off the stroking,
you can see I'm just filling

00:12:02.670 --> 00:12:04.450
the interior of the path.

00:12:04.540 --> 00:12:05.480
So let's turn that off.

00:12:05.560 --> 00:12:08.300
Now, paths, of course,
can be obviously rectangles.

00:12:08.300 --> 00:12:09.100
Those are pretty simple.

00:12:10.710 --> 00:12:14.250
Let's get this back
down to a little better.

00:12:14.420 --> 00:12:17.460
Circles, pretty easy.

00:12:17.510 --> 00:12:18.680
You can draw an oval if you want.

00:12:18.780 --> 00:12:21.570
That's no different
from drawing a circle.

00:12:21.970 --> 00:12:25.980
Some people have asked in the past
for Core graphics to have some sort of

00:12:26.040 --> 00:12:27.500
simple way to do rounded rectangles.

00:12:27.500 --> 00:12:30.260
It's actually very easy,
and there's some code samples

00:12:30.300 --> 00:12:32.540
available that show how to do this.

00:12:32.690 --> 00:12:34.590
Very simple thing are stars.

00:12:34.720 --> 00:12:35.640
Pretty much anything you want.

00:12:35.640 --> 00:12:39.310
It's, you know, these are all,
this is all pretty basic stuff.

00:12:39.420 --> 00:12:41.600
A path itself doesn't
have to be connected.

00:12:41.640 --> 00:12:45.960
You can have a single line
segment that's not filled.

00:12:46.170 --> 00:12:51.850
And then we have some additional ways
of modifying the way the path looks.

00:12:51.980 --> 00:12:53.840
So let me just increase the line width.

00:12:53.940 --> 00:12:56.720
And here you see my curve.

00:12:56.720 --> 00:12:59.940
So one thing that's interesting,
on the ends of the path,

00:13:00.050 --> 00:13:01.480
I can change the way that looks.

00:13:01.480 --> 00:13:03.360
Right now I have what's
known as a butt cap.

00:13:03.430 --> 00:13:07.740
In other words, the stroked region ends
precisely where the path ends.

00:13:07.740 --> 00:13:09.760
If I want,
I can change that to a round cap so

00:13:09.760 --> 00:13:11.580
I have a nice little round corner.

00:13:11.580 --> 00:13:14.190
And I can also change
that to a square cap.

00:13:14.300 --> 00:13:17.630
So I have a square end
added to the end of my path.

00:13:17.720 --> 00:13:20.570
Now, some people, when they're drawing,
I mean,

00:13:20.600 --> 00:13:23.770
this is all fine if you're just sort
of naively drawing a single curve.

00:13:23.880 --> 00:13:26.930
If you're drawing 10 or 20
or 30,000 lines at a time,

00:13:26.930 --> 00:13:30.810
doing a round line cap isn't really
very efficient because we have

00:13:30.820 --> 00:13:34.280
to do an awful lot of calculation
to fill in that little end point.

00:13:34.360 --> 00:13:36.820
So you typically,
for lots of line drawing,

00:13:36.820 --> 00:13:38.780
you want to use a simple butt cap.

00:13:39.590 --> 00:13:43.600
Additionally, for shapes,
let's bring up the star.

00:13:45.400 --> 00:13:46.140
Oops, I'll start in the center.

00:13:46.140 --> 00:13:49.850
As you can see,
we have this path that consists of

00:13:49.980 --> 00:13:51.170
several different line segments.

00:13:51.230 --> 00:13:54.780
The way the ends of the line
segments are drawn is controlled

00:13:54.860 --> 00:13:55.940
by a line join parameter.

00:13:55.940 --> 00:13:58.410
So here we have a miter line join,
but if I like,

00:13:58.410 --> 00:14:00.080
I can also change that to round.

00:14:00.080 --> 00:14:04.290
So you can see here at each point,
I'm having a nice round

00:14:04.290 --> 00:14:07.370
join of the curve,
or I can change that to a bevel,

00:14:07.370 --> 00:14:09.640
so that just chops it off at each angle.

00:14:09.640 --> 00:14:12.940
And that, you know,
depends on what you're looking for.

00:14:12.940 --> 00:14:15.340
But again,
round is a little bit more expensive,

00:14:15.360 --> 00:14:18.120
so if you do that,
you're going to be slightly slower.

00:14:18.120 --> 00:14:20.080
Miter's actually pretty cheap.

00:14:20.250 --> 00:14:22.070
But you can see for a simple
application like this,

00:14:22.070 --> 00:14:25.890
here I'm actually really limited by the
fact that I have 60 hertz refresh rate.

00:14:25.940 --> 00:14:29.810
I mean, when you're not limited by that,
it actually draws pretty

00:14:29.810 --> 00:14:31.380
much instantaneously.

00:14:31.410 --> 00:14:34.040
And of course, colors,
you can change the colors.

00:14:34.040 --> 00:14:37.370
You can make the color be anything
you want for the fill or the stroke.

00:14:37.430 --> 00:14:39.920
So this is all just sort
of basic CG drawing.

00:14:39.920 --> 00:14:40.520
It's pretty simple.

00:14:40.520 --> 00:14:42.920
I mean, you've probably seen applications
like this for $1,500.

00:14:42.920 --> 00:14:43.450
It's pretty simple.

00:14:43.580 --> 00:14:46.390
But this is just to show that
you have that basic structure.

00:14:46.440 --> 00:14:50.680
So if we could switch back to the slides,
and I can find my little thingy.

00:14:53.410 --> 00:14:56.960
So as I mentioned,
paths can be both simple and complex.

00:14:57.040 --> 00:15:00.380
On the upper left you have a path
that's just a single straight line,

00:15:00.440 --> 00:15:01.220
but it's dashed.

00:15:01.370 --> 00:15:03.440
This is a parameter that you
can change in the graphic state,

00:15:03.550 --> 00:15:04.610
the way a path is drawn.

00:15:04.970 --> 00:15:07.260
You can ask for it to be dashed for you.

00:15:07.610 --> 00:15:10.670
A path doesn't have to be closed,
it can just be a single set

00:15:10.850 --> 00:15:12.200
of lines in the upper middle.

00:15:12.580 --> 00:15:14.160
The path can be relatively complicated.

00:15:14.160 --> 00:15:20.240
So here we have the state of California,
relatively complicated

00:15:20.240 --> 00:15:20.240
path filled and stroked.

00:15:20.580 --> 00:15:21.840
Oh, that's interesting.

00:15:21.840 --> 00:15:28.180
So on the lower left in the middle,
in the lower middle,

00:15:28.180 --> 00:15:30.130
you see two paths that look identical.

00:15:30.210 --> 00:15:33.120
However, they shouldn't look identical,
it turns out.

00:15:33.330 --> 00:15:36.390
The one on the left is an example
that a path can be self-intersecting.

00:15:36.400 --> 00:15:39.020
And in this case,
we have the path is filled with

00:15:39.110 --> 00:15:40.500
what's known as the even-odd rule.

00:15:40.500 --> 00:15:42.440
So the center is not filled.

00:15:42.440 --> 00:15:45.940
The one to the run in the middle
here should have the center filled.

00:15:45.940 --> 00:15:47.460
That's an example of
a different fill rule,

00:15:47.460 --> 00:15:48.580
which is called the winding number fill.

00:15:48.580 --> 00:15:52.320
So imagine, if you will,
the center filled in that star.

00:15:52.320 --> 00:15:56.920
And then over to the
far right on the bottom,

00:15:56.920 --> 00:16:01.080
you can see here's a path that's created
out of two separate independent subpaths.

00:16:01.220 --> 00:16:04.160
In this case, it's two circles,
one inside the other.

00:16:04.160 --> 00:16:07.860
So a path can consist of multiple
independent segments of paths.

00:16:07.900 --> 00:16:10.040
And here, when we fill it,
we just get the ring,

00:16:10.040 --> 00:16:11.900
not sort of the whole thing.

00:16:19.670 --> 00:16:23.210
The focus is on important Quartz 2D
features such as device/resolution

00:16:23.360 --> 00:16:26.810
independent rendering,
advanced drawing model, transformations,

00:16:26.870 --> 00:16:28.130
and support for PDF.

00:16:28.350 --> 00:16:31.820
This year, we've added,
as I mentioned before, a path type.

00:16:32.050 --> 00:16:35.340
This sort of works like
the core foundation model,

00:16:35.340 --> 00:16:36.660
if you're familiar with that.

00:16:36.760 --> 00:16:39.440
You create a mutable path,
which means one that you can modify.

00:16:39.440 --> 00:16:42.800
So there's a call
"cg_path.create_mutable." Then you

00:16:42.920 --> 00:16:45.440
add line segments and so on to it.

00:16:45.440 --> 00:16:47.750
So there's a function
"move_to_point_in_the_path," add

00:16:47.750 --> 00:16:52.080
a line to the point in the path,
add a curve, add a quadratic curve,

00:16:52.140 --> 00:16:52.930
and so on.

00:16:52.940 --> 00:16:58.320
And then because those are sort of
the primitive notions of the path API,

00:16:58.320 --> 00:17:00.680
we also have some convenience
functions that make it easier to

00:17:00.680 --> 00:17:02.060
do something more complicated.

00:17:02.060 --> 00:17:06.060
So we have an add_arc function,
which will add a circular arc.

00:17:06.350 --> 00:17:09.270
Excuse me, we have an add_rect function,
which adds a rectangle.

00:17:09.300 --> 00:17:12.530
So there's some sort of common things
that you might use frequently in your

00:17:12.530 --> 00:17:16.760
own application that we've added as
convenience functions for your API.

00:17:17.000 --> 00:17:21.010
And then we also provide DTS sample code
to do some even more complicated things.

00:17:21.100 --> 00:17:24.060
So while we don't have
an add_oval function,

00:17:24.060 --> 00:17:25.680
it's about four lines of code.

00:17:25.800 --> 00:17:30.010
There's a DTS example that shows
you how to draw an oval for a path.

00:17:30.290 --> 00:17:31.480
Same thing with round_and_rect.

00:17:31.540 --> 00:17:34.280
We don't supply that, but again,
it's a handful of lines of code,

00:17:34.280 --> 00:17:36.260
and you can just download that directly.

00:17:36.480 --> 00:17:38.980
And then once you've
created a path to draw with,

00:17:38.980 --> 00:17:41.260
you call cg_context_add_path.

00:17:41.580 --> 00:17:45.520
That takes the path that you've
created and adds it to the

00:17:45.520 --> 00:17:47.870
context for later rendering.

00:17:47.880 --> 00:17:51.820
And here, what I example is,
I might fill it or I might stroke it.

00:17:51.820 --> 00:17:54.480
I could do other things
with it and so on.

00:17:54.480 --> 00:17:56.810
The operation that we're doing here
is that you can do combinations,

00:17:56.810 --> 00:17:58.340
in fact, that you can do.

00:17:58.340 --> 00:17:59.440
You can certainly fill it.

00:17:59.440 --> 00:18:00.440
You can stroke it.

00:18:00.440 --> 00:18:02.440
You can do combinations,
like fill_stroke, if you want.

00:18:02.440 --> 00:18:05.440
And you can clip to it,
which means that you constrain

00:18:05.440 --> 00:18:10.050
all future rendering to be just
within the inside of the path.

00:18:11.170 --> 00:18:13.890
I'll have an example of
that on the next slide.

00:18:14.120 --> 00:18:15.600
When you go to stroke,
there's a couple of parameters

00:18:15.600 --> 00:18:18.680
in the graphics state that let
you change the look of the path.

00:18:18.850 --> 00:18:19.830
You can change its width.

00:18:20.040 --> 00:18:23.140
You can change how the line join,
I showed that before,

00:18:23.270 --> 00:18:25.900
how the two line segments are joined,
the line cap, what's at the end,

00:18:25.960 --> 00:18:27.560
whether it's a round or join and so on.

00:18:27.800 --> 00:18:31.320
Some other parameters, the MITRE limit,
the line dash.

00:18:31.540 --> 00:18:34.220
So here's an example of
using a path to clip.

00:18:34.300 --> 00:18:38.470
In this case, we have a path that
consists of two subpaths.

00:18:38.600 --> 00:18:40.440
The whole path is the apple.

00:18:40.440 --> 00:18:42.810
There's two subpaths,
the leaf and the little

00:18:42.810 --> 00:18:43.830
apple with a bite out of it.

00:18:44.150 --> 00:18:47.000
Those are two independent paths,
but they all can join together

00:18:47.000 --> 00:18:48.830
to make one single closed path.

00:18:48.910 --> 00:18:51.860
I take that path and
I add it to the context,

00:18:51.860 --> 00:18:54.000
and then I tell the context to clip.

00:18:54.100 --> 00:18:56.280
In other words,
what I'm telling the context is,

00:18:56.370 --> 00:18:59.780
from now on, only draw anything that
shows through the apple.

00:19:00.160 --> 00:19:02.580
In this case, what I'm going to do
is then draw a bitmap,

00:19:02.650 --> 00:19:07.620
and what happens is that only
the part of the bitmap that's

00:19:07.620 --> 00:19:08.920
inside the apple gets drawn.

00:19:08.920 --> 00:19:11.550
So that can be really powerful
in some circumstances when you're

00:19:11.640 --> 00:19:12.780
trying to do complicated drawing.

00:19:12.780 --> 00:19:16.530
You have the path outline,
but you don't necessarily want to

00:19:16.540 --> 00:19:19.020
convert that to an image that you
need to filter and all that stuff.

00:19:19.060 --> 00:19:20.710
You just can let
Core Graphics do that for you.

00:19:22.050 --> 00:19:24.800
The Quartz 2D graphics system
is a very important part of

00:19:24.950 --> 00:19:26.110
the Mac OS X application.

00:19:26.110 --> 00:19:28.990
It is a very important part
of the Mac OS X application.

00:19:29.100 --> 00:19:35.000
It is a very important part
of the Mac OS X application.

00:19:35.000 --> 00:19:43.050
The Quartz 2D graphics system
is a very important part of

00:19:43.050 --> 00:19:43.050
the Mac OS X application.

00:19:45.970 --> 00:19:50.000
Here I'm going to create
a path which is a circle.

00:19:50.000 --> 00:19:52.040
Because I want to, maybe I love circles.

00:19:52.040 --> 00:19:53.570
I want to draw thousands
of circles or something.

00:19:53.710 --> 00:19:57.060
So in this case what I'm going
to do is I create a path,

00:19:57.060 --> 00:19:59.340
CGPathCreateMutable starts me off.

00:19:59.340 --> 00:20:00.330
I add an arc.

00:20:00.360 --> 00:20:04.360
In this case I'm going to add an arc
from 0 all the way round to 360 degrees.

00:20:04.420 --> 00:20:06.300
Now that at that point
still is an open path.

00:20:06.410 --> 00:20:08.440
It doesn't have, it's not closed.

00:20:08.510 --> 00:20:11.060
So then I call CGPathClosedSubPath
to actually close it.

00:20:11.060 --> 00:20:16.160
Otherwise, if I didn't do the close,
I'd have line caps on the ends of my

00:20:16.160 --> 00:20:18.740
curve which would look pretty ugly.

00:20:19.010 --> 00:20:22.620
And then I call CGContextAddPath
to add the path to the context.

00:20:22.690 --> 00:20:24.950
And I call CGFill to get
the nice filled circle.

00:20:25.050 --> 00:20:27.420
Now what's nice is that once
I've created that circle,

00:20:27.420 --> 00:20:29.120
I can use it over and over again.

00:20:29.120 --> 00:20:31.420
I can draw, as I said,
thousands of circles.

00:20:31.540 --> 00:20:33.510
But I can also do more clever things.

00:20:33.640 --> 00:20:35.120
For example,
one of the things I can do to

00:20:35.160 --> 00:20:38.670
a context is change the way it
transforms information from what

00:20:38.950 --> 00:20:41.070
you provide to the destination.

00:20:41.320 --> 00:20:42.810
For example,
I can scale the context to the

00:20:42.810 --> 00:20:42.920
way it transforms the information.

00:20:42.920 --> 00:20:44.660
So I can do that in the
context in one dimension,

00:20:44.670 --> 00:20:45.260
not in the other.

00:20:45.340 --> 00:20:48.900
So I can stretch it in X,
and I can not stretch it in Y.

00:20:49.160 --> 00:20:52.130
And what I'll get when
I draw the path then,

00:20:53.900 --> 00:21:51.700
[Transcript missing]

00:21:52.360 --> 00:21:53.840
Okay, so that's vector geometry.

00:21:53.840 --> 00:22:00.350
Now if we move on to text,
Core Graphics has support for

00:22:00.490 --> 00:22:04.910
text but it is not something
that we have a lot of API for.

00:22:04.910 --> 00:22:07.770
Here you can see, though,
we do an awful lot of

00:22:07.850 --> 00:22:09.090
interesting things with text.

00:22:09.180 --> 00:22:12.370
We certainly support, you know,
fonts that are relatively complicated.

00:22:12.370 --> 00:22:13.870
That's the welcome font up there.

00:22:13.880 --> 00:22:14.670
That's Zepfino.

00:22:14.670 --> 00:22:17.320
That's drawn with using Core Graphics.

00:22:17.370 --> 00:22:21.380
We support Chinese, Korean, Japanese,
and so on text.

00:22:21.380 --> 00:22:23.320
You can take text and you can rotate it.

00:22:23.320 --> 00:22:25.200
That's the example in green there.

00:22:25.260 --> 00:22:26.490
And you can fill and stroke it.

00:22:26.690 --> 00:22:28.020
That's the stroke example.

00:22:28.020 --> 00:22:30.020
All those effects are just
straight Core Graphics.

00:22:30.020 --> 00:22:32.640
There's nothing special about them.

00:22:32.640 --> 00:22:35.940
However, that said,
we do have a font that--we do have

00:22:35.940 --> 00:22:38.810
a type that represents system font,
CG font.

00:22:38.810 --> 00:22:42.390
And it does support TrueType, Type 1,
and CID font.

00:22:42.390 --> 00:22:46.020
CIDs are for Korean, Japanese, Chinese,
and so on.

00:22:46.200 --> 00:22:50.000
But we still recommend,
if you're going to do text rendering,

00:22:50.000 --> 00:22:50.730
to use CID.

00:22:50.850 --> 00:22:53.160
And if you're going to do text rendering,
you can use CID.

00:22:53.280 --> 00:22:54.870
And we do have a font that's called CID.

00:22:54.980 --> 00:22:56.100
And we do have a font that's called CID.

00:22:56.100 --> 00:22:57.440
And we do have a font that's called CID.

00:22:57.440 --> 00:22:58.800
And we do have a font that's called CID.

00:22:58.800 --> 00:23:00.160
And we do have a font that's called CID.

00:23:00.160 --> 00:23:01.600
And we do have a font that's called CID.

00:23:01.600 --> 00:23:02.960
And we do have a font that's called CID.

00:23:02.960 --> 00:23:04.970
And we do have a font that's called CID.

00:23:04.970 --> 00:23:07.230
And we do have a font that's called CID.

00:23:07.230 --> 00:23:09.300
And we do have a font that's called CID.

00:23:09.300 --> 00:23:10.960
And we do have a font that's called CID.

00:23:10.960 --> 00:23:12.650
And we do have a font that's called CID.

00:23:12.650 --> 00:23:13.870
And we do have a font that's called CID.

00:23:13.980 --> 00:23:15.130
And we do have a font that's called CID.

00:23:15.130 --> 00:23:16.730
And we do have a font that's called CID.

00:23:16.870 --> 00:23:18.140
And we do have a font that's called CID.

00:23:18.230 --> 00:23:24.370
And we do have a font that's called CID.

00:23:24.370 --> 00:23:26.790
And we do have a font that's called CID.

00:23:26.870 --> 00:23:29.070
And we do have a font that's called CID.

00:23:29.120 --> 00:23:31.170
And we do have a font that's called CID.

00:23:31.230 --> 00:23:33.150
And we do have a font that's called CID.

00:23:33.150 --> 00:23:34.340
And we do have a font that's called CID.

00:23:34.490 --> 00:23:35.720
And we do have a font that's called CID.

00:23:35.730 --> 00:23:37.090
And we do have a font that's called CID.

00:23:37.090 --> 00:23:38.450
And we do have a font that's called CID.

00:23:38.460 --> 00:23:40.680
And we do have a font that's called CID.

00:23:40.760 --> 00:23:43.130
And we do have a font that's called CID.

00:23:43.130 --> 00:23:43.720
And we do have

00:23:44.030 --> 00:23:47.890
The type that you use to
represent image data is CG image.

00:23:47.890 --> 00:23:52.900
We support a lot of color spaces,
RGB certainly, CMYK.

00:23:52.900 --> 00:23:56.950
You can have ICC profiles,
that's the same thing as Color Sync

00:23:56.950 --> 00:23:58.550
profiles associated with the image.

00:23:58.610 --> 00:24:00.990
A lot of cameras,
the JPEG data that comes off now will

00:24:01.130 --> 00:24:02.820
have a profile associated with it.

00:24:03.020 --> 00:24:06.900
So that means that you're going to get
high fidelity color managed images.

00:24:06.900 --> 00:24:10.560
As I mentioned before,
we have support for alpha channels,

00:24:10.610 --> 00:24:11.700
transparency.

00:24:12.050 --> 00:24:13.850
Alpha can be pre-multiplied
or not pre-multiplied,

00:24:13.960 --> 00:24:16.900
that's sort of technical,
but that's good.

00:24:16.900 --> 00:24:22.910
And we support image masks as well,
which are a way to specify an 8-bit deep

00:24:22.910 --> 00:24:27.120
or 1-bit deep or some depth of image and
draw color through it and the color will

00:24:27.240 --> 00:24:31.510
only show up where the image is non-zero.

00:24:31.880 --> 00:24:35.240
In Jaguar, we've added support for
extended bit depths.

00:24:35.350 --> 00:24:37.980
We now go from 1 to
32 bits per component.

00:24:38.090 --> 00:24:41.600
That's not total bits per pixel,
that's per component.

00:24:41.600 --> 00:24:45.500
So you can have an RGB image
with 24 bits of red,

00:24:45.950 --> 00:24:48.680
24 bits of green, 24 bits of blue,
24 bits of alpha,

00:24:48.960 --> 00:24:50.240
and will render it correctly.

00:24:50.390 --> 00:24:52.620
So that can be really
significant for people who need

00:24:52.780 --> 00:24:54.300
to have high bit depth images.

00:24:54.300 --> 00:24:57.680
And that seems to be happening
more and more as more things

00:24:57.700 --> 00:25:01.800
start getting deeper in terms of
the bit depth of the components.

00:25:03.120 --> 00:25:08.170
The one thing about that though is
that we don't have output formats

00:25:08.310 --> 00:25:10.340
yet that adequately represent that.

00:25:10.340 --> 00:25:13.590
So while we can bring in
32 bits per component,

00:25:13.790 --> 00:25:16.100
we can't write it out and
preserve that 32 bits.

00:25:16.170 --> 00:25:16.990
We'll always truncate it.

00:25:17.070 --> 00:25:19.320
In time,
we expect the image formats will catch

00:25:19.410 --> 00:25:23.420
up and we'll support the ones that
already do support deeper bit depths.

00:25:23.480 --> 00:25:26.300
But currently, most of them are limited
to 8 bits per component.

00:25:26.300 --> 00:25:28.180
So you might have some
problems on output,

00:25:28.180 --> 00:25:30.120
but on input, we can support all of that.

00:25:31.110 --> 00:25:33.410
Additionally,
we've built in support for high

00:25:33.510 --> 00:25:35.350
fidelity color managed images.

00:25:35.700 --> 00:25:38.250
Again, this is based on ColorSync.

00:25:38.250 --> 00:25:42.680
So ColorSync will take the data that
comes in the image and match it to the

00:25:42.700 --> 00:25:47.140
destination so you'll get the correct
look as you go through the system.

00:25:47.140 --> 00:25:50.290
But for that to work,
your image has to have calibrated colors.

00:25:50.360 --> 00:25:52.340
Your image needs to have a
color space associated with it.

00:25:52.340 --> 00:25:54.520
If it doesn't,
then you're probably going to

00:25:54.520 --> 00:25:56.410
need to supply that yourself.

00:25:56.420 --> 00:25:59.930
And I'll talk about that
a little bit more later.

00:26:00.680 --> 00:26:04.460
So if you wanted to use images,
it's actually really easy.

00:26:04.460 --> 00:26:07.680
You first create a data
provider to supply image data.

00:26:07.680 --> 00:26:09.280
So what's a data provider?

00:26:09.280 --> 00:26:12.990
A data provider is the way you
give us information from your

00:26:13.180 --> 00:26:15.660
side of things inside the CG.

00:26:15.660 --> 00:26:19.240
It's sort of a general
workhorse that we have that is

00:26:19.240 --> 00:26:22.730
based on a callback mechanism,
so you can do a lot of things with the

00:26:22.820 --> 00:26:24.590
data provider to give us image data.

00:26:24.600 --> 00:26:27.940
Once you've created one of those,
you can call CG image create.

00:26:27.940 --> 00:26:31.600
That passes a lot of parameters to
specify the format of the image data.

00:26:31.600 --> 00:26:33.640
And then CG context draw image.

00:26:33.640 --> 00:26:40.750
So here's a code sample to illustrate
that in a little bit more depth.

00:26:40.950 --> 00:26:44.030
As you can see,
we imagine here that what I have

00:26:44.030 --> 00:26:47.810
is a... I have a big blob of
memory that represents my image.

00:26:47.820 --> 00:26:50.000
It's already, you know, ready to go.

00:26:50.000 --> 00:26:50.600
It's in memory.

00:26:50.600 --> 00:26:51.440
It's in there.

00:26:51.440 --> 00:26:53.590
It's in that data parameter,
and it's a certain size.

00:26:53.640 --> 00:26:56.880
So I start out by creating
a data provider with data,

00:26:56.880 --> 00:26:59.960
passing in the data that I have,
and then I start to

00:27:00.030 --> 00:27:01.750
synthesize the information,
and that creates the

00:27:01.760 --> 00:27:02.760
data provider for me.

00:27:02.760 --> 00:27:04.260
Then I create the CG image.

00:27:04.260 --> 00:27:06.220
I pass in all these
parameters-- the width,

00:27:06.220 --> 00:27:07.760
the height,
the number of bits per sample,

00:27:07.800 --> 00:27:09.750
the number of bits per pixel,
the bytes per row.

00:27:09.760 --> 00:27:11.760
I mean, you can read the list.

00:27:12.070 --> 00:27:16.260
But all of those things tell
Core Graphics how to interpret the data,

00:27:16.350 --> 00:27:20.760
whether the data's RGB or CMYK and so on,
whether it has alpha or not.

00:27:20.770 --> 00:27:23.670
All of that stuff is part of the
process of creating an image and letting

00:27:23.770 --> 00:27:25.260
us know how to interpret the data.

00:27:25.300 --> 00:27:28.260
Once you've created the image,
you release the provider,

00:27:28.280 --> 00:27:29.160
because you don't want to leave it there.

00:27:29.160 --> 00:27:31.290
You don't want to leak memory,
and the image itself will

00:27:31.290 --> 00:27:32.100
retain the provider for you.

00:27:32.270 --> 00:27:38.660
Works just like the auto-retain-release
mechanism in Cocoa and Core Foundation.

00:27:38.660 --> 00:27:40.660
And then once you--now you
have an image ready to draw.

00:27:40.660 --> 00:27:44.160
You can draw that 100 times,
10,000 times, as many times as you want.

00:27:44.250 --> 00:27:46.120
In this case, I'm going to draw it once.

00:27:46.290 --> 00:27:49.560
So I want to draw it at a
certain place in my context.

00:27:49.660 --> 00:27:50.930
So I create a rectangle.

00:27:51.160 --> 00:27:54.380
I'm going to give it the origin, x, y,
the width and height that

00:27:54.450 --> 00:27:55.660
I want to make the image.

00:27:55.660 --> 00:27:58.960
And then I call CGContextDrawImage,
passing in the rectangle,

00:27:58.960 --> 00:28:01.380
the rectangle that I want
to map the image to,

00:28:01.460 --> 00:28:03.460
the image itself and the context.

00:28:03.540 --> 00:28:04.460
And then now that I'm
done with the image,

00:28:04.460 --> 00:28:05.260
I release it.

00:28:05.460 --> 00:28:07.670
As I said,
if you didn't release it-- well,

00:28:07.670 --> 00:28:09.360
if you didn't release it,
you'd leak memory.

00:28:09.460 --> 00:28:10.960
But if you wanted to
draw it multiple times,

00:28:11.020 --> 00:28:13.960
once you've created the image,
you can just call that CGContextDrawImage

00:28:13.960 --> 00:28:17.270
call as many times as you want,
and the image will get

00:28:17.280 --> 00:28:19.150
redrawn every single time.

00:28:20.210 --> 00:28:23.700
What's interesting about data providers
and the mechanism that we use to

00:28:23.780 --> 00:28:27.250
get information into core graphics
is that because it is based on a

00:28:27.410 --> 00:28:31.670
callback scheme that you create,
you can actually do anything you

00:28:31.670 --> 00:28:33.440
want to in that data provider.

00:28:33.630 --> 00:28:37.390
Here we have the source data comes in,
you write your own routines

00:28:37.390 --> 00:28:39.400
to sort of decode it,
figure out what it does, and so on,

00:28:39.400 --> 00:28:42.170
and then pass it into CG image.

00:28:42.960 --> 00:28:46.610
The focus is on important Quartz 2D
features such as device/resolution

00:28:46.810 --> 00:28:50.470
independent rendering,
advanced drawing model, transformations,

00:28:50.470 --> 00:28:51.820
and support for PDF.

00:28:51.880 --> 00:28:54.310
Here, for example,
I'm imagining that I might have,

00:28:54.460 --> 00:28:58.230
instead of an interleaved image,
which is what CG does understand, RGB,

00:28:58.300 --> 00:29:02.540
RGB, RGB, RGB for each pixel,
I might have an image that's planar,

00:29:02.540 --> 00:29:04.720
so I have a whole plane
of all the red components,

00:29:04.780 --> 00:29:06.900
I have a whole plane of
all the green components,

00:29:06.900 --> 00:29:08.390
a whole plane of all the blue components.

00:29:08.460 --> 00:29:10.320
Now CG doesn't know how
to render that image.

00:29:10.450 --> 00:29:12.040
It doesn't understand those.

00:29:12.040 --> 00:29:15.400
However, if you create a custom data
provider that knows how to take

00:29:15.540 --> 00:29:18.880
that data and interleave it in
a form that CG does understand,

00:29:18.880 --> 00:29:21.560
suddenly we're able to
render those images,

00:29:21.690 --> 00:29:22.820
and that's actually very powerful.

00:29:22.820 --> 00:29:28.420
Here, as an example in this code case,
I've created a couple of callback

00:29:28.530 --> 00:29:34.360
functions that I'm going to put into my
CG data provider callbacks structure.

00:29:34.360 --> 00:29:37.710
I've imagined that I have a planar
get bytes function that knows

00:29:37.710 --> 00:29:39.740
how to take the planar data,
interleave it appropriately,

00:29:39.740 --> 00:29:41.420
and write it out to a destination buffer.

00:29:41.420 --> 00:29:45.740
A planar skip bytes function,
that's used so if, for example,

00:29:45.740 --> 00:29:49.640
Core Graphics wants to only display
the bottom half of an image because

00:29:49.650 --> 00:29:52.760
the rest of it's clipped or something,
we would call the skip bytes function

00:29:52.760 --> 00:29:57.330
to allow you to skip forward rapidly
in the image without actually doing all

00:29:57.330 --> 00:29:58.790
the decoding and all the work yourself.

00:29:58.930 --> 00:30:02.320
A rewind function, so if we need to draw
the image multiple times,

00:30:02.350 --> 00:30:05.840
we just sort of tell the data provider,
oh, go back to the beginning,

00:30:05.840 --> 00:30:07.170
we're going to start
drawing something again.

00:30:07.180 --> 00:30:11.080
And then the planar release releases
all the extra info that you might

00:30:11.280 --> 00:30:13.270
have used to do your own work.

00:30:13.360 --> 00:30:17.540
Then once you have the callbacks,
you create the data provider,

00:30:17.540 --> 00:30:19.940
CG data provider create,
you pass in an info parameter,

00:30:19.940 --> 00:30:22.760
that's the stuff you
use to do your decoding,

00:30:22.760 --> 00:30:24.720
so whatever you want to,
it's just a void star,

00:30:24.720 --> 00:30:26.080
and the callbacks array.

00:30:26.080 --> 00:30:29.540
Now you have a provider
that can be used to,

00:30:29.540 --> 00:30:31.410
just like before, create an image.

00:30:31.540 --> 00:30:34.840
So here we just create a regular image,
pass in similar sets of parameters.

00:30:34.840 --> 00:30:38.600
Of course, these are the parameters that
are appropriate for the way

00:30:38.600 --> 00:30:40.120
you will decode the image.

00:30:40.210 --> 00:30:43.630
So, for example, if you're going to say,
well, I'm going to decode to

00:30:43.630 --> 00:30:46.770
an RGB 8-bit deep buffer,
then you need to say, well,

00:30:46.860 --> 00:30:50.290
the bits per sample are 8, 8 bits of R,
8 bits of G, and so on, bits per pixel,

00:30:50.360 --> 00:30:51.180
24, and so on.

00:30:51.320 --> 00:30:55.510
So the only thing that matters is
that this is sort of the way you're

00:30:55.590 --> 00:30:58.640
planning to format your data when
we call you with the data provider.

00:30:58.640 --> 00:31:01.040
But you can do anything you
want with that data provider,

00:31:01.040 --> 00:31:02.200
and that can be really powerful.

00:31:02.200 --> 00:31:06.540
For example, one thing that has
actually been used already,

00:31:06.540 --> 00:31:07.960
and I have an example
of this I'll show you,

00:31:07.960 --> 00:31:11.000
you might choose to support a
format that we don't support,

00:31:11.070 --> 00:31:13.100
I mean, in terms of what we ship.

00:31:13.290 --> 00:31:17.200
So Cineon is an image format used
for movies and film and so on,

00:31:17.200 --> 00:31:21.200
and it's not something that
we support as part of Jaguar,

00:31:21.200 --> 00:31:23.610
but it's something that you could
write a data provider to decode the

00:31:23.690 --> 00:31:25.500
data and bring it into Core Graphics.

00:31:26.050 --> 00:31:27.670
Similarly,
you might want to do some sort of

00:31:27.860 --> 00:31:29.400
complicated or fancy image filtering.

00:31:29.400 --> 00:31:31.990
You might want to downsample
your image data in some special,

00:31:32.100 --> 00:31:35.900
clever way that is top secret
and patented and everything,

00:31:35.900 --> 00:31:38.250
and you could write a data
provider to do that for you.

00:31:38.320 --> 00:31:41.960
Or you could do any sort of
regular unsharped mass filtering

00:31:41.960 --> 00:31:42.840
or whatever you might want.

00:31:42.860 --> 00:31:48.640
Or you might want to get access to data
that's normally not typically available.

00:31:48.700 --> 00:31:52.000
For example, you might want to say, oh,
well, QuickTime's pretty good at

00:31:52.020 --> 00:31:53.230
understanding lots of image formats.

00:31:53.300 --> 00:31:56.620
If only I could get
QuickTime data into Core Graphics.

00:31:56.620 --> 00:31:57.560
Wouldn't that be great?

00:31:57.760 --> 00:32:00.890
You could write a QuickTime data provider
that knew how to talk to QuickTime,

00:32:00.900 --> 00:32:04.670
get QuickTime to do the decoding,
and then pass information back

00:32:04.730 --> 00:32:06.300
into Core Graphics to do drawing.

00:32:10.390 --> 00:32:12.900
I said Apple could write one for you.

00:32:13.050 --> 00:32:15.240
Well, I wonder why that doesn't happen.

00:32:15.500 --> 00:32:17.600
His question,
he made the comment that Apple could

00:32:17.600 --> 00:32:21.940
actually write a QuickTime data provider,
and I would agree, Apple should.

00:32:26.550 --> 00:32:31.650
I think the QuickTime feedback
session is a little later.

00:32:31.730 --> 00:32:34.220
So, because this is actually a
pretty powerful mechanism,

00:32:34.220 --> 00:32:37.580
we have used it ourselves, it turns out,
maybe not for QuickTime,

00:32:37.680 --> 00:32:38.700
but for JPEG and PNG.

00:32:38.830 --> 00:32:44.370
We've written two data providers to allow
someone to get JPEG data or PNG data into

00:32:44.410 --> 00:32:47.620
Core Graphics to image on the screen.

00:32:47.800 --> 00:32:52.030
The nice thing about these both
are that they bring the image

00:32:52.180 --> 00:32:55.840
data into Core Graphics and on
the screen they'll decompress it.

00:32:55.840 --> 00:32:57.600
But when they're writing
out to PDF files,

00:32:57.610 --> 00:32:59.700
for example, we don't decompress.

00:32:59.820 --> 00:33:02.880
So that means that JPEG data,
because PDF understands how to write,

00:33:02.880 --> 00:33:05.690
how to support JPEG natively,
we can write the JPEG data

00:33:05.730 --> 00:33:08.910
directly into the PDF file,
which means that your PDF files

00:33:08.910 --> 00:33:11.620
suddenly are like a tenth
of the size or a quarter,

00:33:11.620 --> 00:33:13.960
you know, a millionth of the size,
whatever.

00:33:13.960 --> 00:33:16.280
But much,
much smaller than they were maybe

00:33:16.280 --> 00:33:18.470
in earlier versions of Mac OS X.

00:33:18.470 --> 00:33:22.980
PNG is a little trickier in
that PDF doesn't provide a

00:33:22.980 --> 00:33:23.330
native way to take the PNG data.

00:33:23.330 --> 00:33:23.470
It's a little trickier in that
PDF doesn't provide a native

00:33:23.470 --> 00:33:23.620
way to take the PNG data.

00:33:23.620 --> 00:33:23.620
But it's a little trickier
in that PDF doesn't provide a

00:33:23.620 --> 00:33:23.680
native way to take the PNG data.

00:33:23.680 --> 00:33:23.780
But it's a little trickier in that
PDF doesn't provide a native way

00:33:23.780 --> 00:33:28.460
to take the PNG file directly and
just dump it into the PDF file.

00:33:28.460 --> 00:33:32.080
However, we can take part of the
PNG data and write it out,

00:33:32.080 --> 00:33:33.100
so we do do that.

00:33:33.100 --> 00:33:36.960
So those are two ways to get
information out of Core Graph--I mean,

00:33:37.080 --> 00:33:40.690
sorry, from a native format with
a custom data provider into

00:33:40.690 --> 00:33:43.810
Core Graphics in a special way.

00:33:43.810 --> 00:33:46.290
And I think--yes, okay.

00:33:46.350 --> 00:33:51.090
So I'm going to go to Demo2,
and I'll just show a little

00:33:51.090 --> 00:33:53.140
example of images and demo.

00:33:53.310 --> 00:33:55.620
The image stuff.

00:33:55.620 --> 00:33:57.250
Yes, OK.

00:33:57.840 --> 00:34:00.600
So here's an application.

00:34:00.600 --> 00:34:03.630
So this is a simple
application I've written.

00:34:03.720 --> 00:34:08.750
This is, for example,
I can bring in-- this is just a

00:34:08.750 --> 00:34:14.430
native CG image view that knows
how to draw images using CG,

00:34:14.430 --> 00:34:15.840
not using NSImage.

00:34:15.870 --> 00:34:20.280
So for example, I can bring in JPEGs.

00:34:20.480 --> 00:34:24.230
If I like, I can bring in-- whoops,
not PDF.

00:34:27.620 --> 00:34:30.450
The Quartz 2D graphics system is a great
example of how developers can integrate

00:34:30.450 --> 00:34:33.440
the full power of the Quartz 2D graphics
system into their Mac OS X applications.

00:34:35.470 --> 00:34:39.480
As I mentioned before,
I have a special data provider that

00:34:39.480 --> 00:34:43.100
I've written which knows how to take
Cineon images and bring them in.

00:34:43.100 --> 00:34:45.440
Now, there's a little delay, you'll see.

00:34:45.440 --> 00:34:49.700
This image is about 40 megabytes,
so it does take a little bit of time.

00:34:49.700 --> 00:34:54.340
This is a format that,
if I didn't write the data provider,

00:34:54.550 --> 00:34:56.660
we'd never be able to render.

00:34:56.660 --> 00:35:01.180
It really takes about a handful of
lines of code to get this to work.

00:35:01.180 --> 00:35:03.680
Same thing, here's another Cineon image.

00:35:05.320 --> 00:35:10.860
Now let's go back to the JPEG.

00:35:11.400 --> 00:35:12.100
Well, actually, I'll start here.

00:35:12.100 --> 00:35:16.500
Okay, so one thing that you note,
it took me a little bit of time to

00:35:16.620 --> 00:35:19.980
render that from the disk into memory.

00:35:19.980 --> 00:35:23.680
Now, one thing that, I mean,
that's obviously not very good if

00:35:23.680 --> 00:35:27.100
you're trying to do really fast
rendering of images or something.

00:35:27.100 --> 00:35:30.090
So a lot of times what people want to do
is they want to create an image cache.

00:35:30.140 --> 00:35:34.360
They want to take the image data and
then create another bitmap context

00:35:34.360 --> 00:35:37.960
that they draw the image into and
then convert that bitmap context

00:35:38.140 --> 00:35:39.620
into an image that they then reuse.

00:35:39.820 --> 00:35:43.220
So as an example, what I'm doing here,
as you can see,

00:35:43.220 --> 00:35:49.030
I've just taken the image from the Cineon
file itself and I've created a brand

00:35:49.120 --> 00:35:53.650
new off-screen bitmap at a smaller size,
and I've drawn the image into

00:35:53.650 --> 00:35:57.640
the bitmap and then I put it
here in the cached image window.

00:35:57.640 --> 00:36:01.380
So you can see the difference
if I turn that off and I try

00:36:01.550 --> 00:36:02.800
to animate with this image.

00:36:02.800 --> 00:36:04.280
This is the source image.

00:36:04.330 --> 00:36:06.290
I'm decoding the Cineon data every time.

00:36:06.300 --> 00:36:07.320
That's actually pretty slow.

00:36:08.340 --> 00:36:12.180
If I create the cache
and do the same thing,

00:36:12.180 --> 00:36:13.320
it's much smoother.

00:36:13.320 --> 00:36:16.360
So that can be a really powerful
technique for you to just down-simple

00:36:16.440 --> 00:36:19.780
your image into an off-screen
bitmap and then use that as a

00:36:19.780 --> 00:36:21.520
CG image to redraw over and over.

00:36:21.520 --> 00:36:26.140
Now one thing that you might
need to worry about when you're

00:36:26.140 --> 00:36:29.380
doing that is the image may or
may not have color profile data.

00:36:29.380 --> 00:36:37.130
So let's go, let me bring up a different
set of different image.

00:36:42.120 --> 00:36:45.100
Now, here's an example of a jpeg
that has no color profile.

00:36:45.100 --> 00:36:48.610
So, what you might want to do is
add a profile to that image.

00:36:48.780 --> 00:36:51.800
Now, you probably can't see
much of a difference.

00:36:51.880 --> 00:36:55.070
I don't think there's really
a strong difference here.

00:36:55.070 --> 00:36:59.210
Mostly because of the way all this goes
through the whole thing up to the screen.

00:36:59.210 --> 00:37:02.000
So, here's a little bit different
example where what I have is

00:37:02.000 --> 00:37:04.760
I start out with an image that has
no color information at all in it.

00:37:04.930 --> 00:37:05.890
No profile or anything.

00:37:05.890 --> 00:37:08.300
I just say, you know,
all it claims is I'm red, green, blue.

00:37:08.350 --> 00:37:10.880
I'm red, green, blue.

00:37:10.880 --> 00:37:15.430
What we do here is I take
a profile from the system,

00:37:15.530 --> 00:37:18.480
a color profile, just like in ColorSync,
and I say, well, look,

00:37:18.480 --> 00:37:21.750
when I want to render it,
I'm going to use this profile to show the

00:37:21.750 --> 00:37:24.240
image so that it actually looks correct.

00:37:24.340 --> 00:37:28.020
Now, here I picked a really weird profile
just for illustration purposes which

00:37:28.050 --> 00:37:30.360
swaps the red and the blue channels.

00:37:30.360 --> 00:37:33.330
So,
that's why you get this odd yellow image.

00:37:33.490 --> 00:37:35.410
Normally,
you'd want to use this button right here,

00:37:35.410 --> 00:37:37.030
which is the user's document default.

00:37:37.120 --> 00:37:37.680
That's the thing that
shows up on the screen.

00:37:37.750 --> 00:37:38.280
And then you can see that it's
a little bit more of a blue.

00:37:38.280 --> 00:37:38.280
So, you can see that it's a
little bit more of a red.

00:37:38.280 --> 00:37:38.280
So,
that's why you get this odd yellow image.

00:37:38.280 --> 00:37:38.400
Normally,
you'd want to use this button right up

00:37:38.470 --> 00:37:43.260
on the color sync preferences panel,
and it tells you what the user

00:37:43.260 --> 00:37:47.230
wants his documents to show up at,
and what profile the

00:37:47.230 --> 00:37:51.200
user wants the document,
the user wants you to display

00:37:51.200 --> 00:37:54.640
images if the image doesn't have
a profile associated with it.

00:37:54.640 --> 00:37:56.700
So normally you would use this profile,
but it doesn't really

00:37:56.740 --> 00:37:57.860
look that much different.

00:37:57.980 --> 00:38:01.440
Once you've created that, then,
of course, you have the same thing,

00:38:01.460 --> 00:38:03.750
it works the same way,
it's just a cached image

00:38:03.750 --> 00:38:04.920
with a different profile.

00:38:05.020 --> 00:38:07.710
Of course, when you go to print,
if you wanted to print this,

00:38:07.710 --> 00:38:10.750
you would make sure that you
started out with the source data

00:38:10.750 --> 00:38:13.620
and the appropriate profile,
normally if it wasn't specified

00:38:13.750 --> 00:38:16.010
the user's documented default,
not your cache.

00:38:16.020 --> 00:38:18.230
If you try to print the cache,
you get something that

00:38:18.300 --> 00:38:21.760
wasn't quite appropriate,
it'd be too small, look blurry,

00:38:21.820 --> 00:38:22.860
and so on.

00:38:23.130 --> 00:38:28.370
Okay, so that's-- we could
switch back to the slides.

00:38:29.100 --> 00:38:31.840
Okay, so that's images.

00:38:31.960 --> 00:38:35.360
And now we're going to
move on to PDF documents.

00:38:35.460 --> 00:38:39.800
This is an API that's been
present for a while in Mac OS X,

00:38:39.860 --> 00:38:41.460
but it can be very powerful.

00:38:41.520 --> 00:38:43.300
It works similarly to images.

00:38:43.590 --> 00:38:45.720
In this case,
what we have is a data provider

00:38:45.820 --> 00:38:50.220
that you give us to take
information from a PDF file and

00:38:50.220 --> 00:38:54.330
then give it to a CGPDF document,
and we use that information

00:38:54.440 --> 00:38:57.300
to decode and draw and so on.

00:38:57.360 --> 00:38:59.720
Now,
once you've created the PDF document,

00:38:59.880 --> 00:39:02.600
there's some accessor functions
that are conveniences for you.

00:39:02.600 --> 00:39:04.450
You can ask the document for
the number of pages it has,

00:39:04.560 --> 00:39:06.960
the bounding box for each page,
all of that stuff.

00:39:07.010 --> 00:39:08.800
And you draw it the same
way you draw images.

00:39:08.840 --> 00:39:12.100
CGContext draw a PDF document
where you pass in a rect,

00:39:12.170 --> 00:39:14.230
pass in the document and the page number.

00:39:14.280 --> 00:39:17.460
An example, another code example.

00:39:17.550 --> 00:39:20.540
In this case,
what I have is another URL convenience

00:39:20.580 --> 00:39:23.040
function that I'm using--sorry,
a data provider convenience function

00:39:23.040 --> 00:39:25.330
that I'm using which takes a URL.

00:39:25.340 --> 00:39:27.300
This is a CFURL.

00:39:27.300 --> 00:39:30.800
So you can work with HTTP colon blah,
blah, blah stuff.

00:39:30.800 --> 00:39:33.090
You can work with file colon so on.

00:39:33.610 --> 00:39:36.050
Once you have the URL, though,
you create the data

00:39:36.050 --> 00:39:39.820
provider with that URL,
and we'll call CF, Core Foundation,

00:39:39.900 --> 00:39:43.400
to suck in the information
from the URL that we need.

00:39:43.400 --> 00:39:47.920
Then you create the CGPDF document
with that CGPDF document create

00:39:47.920 --> 00:39:49.500
call and release the provider.

00:39:49.500 --> 00:39:51.260
Make sure you clean up after yourself.

00:39:51.260 --> 00:39:53.500
And then just like with images,
same idea.

00:39:53.740 --> 00:39:56.280
You want to draw that PDF document,
a particular page of it

00:39:56.320 --> 00:39:58.800
in a certain rectangle,
so you create a rectangle,

00:39:58.980 --> 00:40:01.980
draw a PDF document, we'll draw it,
you pass in the page number in

00:40:01.980 --> 00:40:05.450
this case to say where you want
the-- which page you want to

00:40:05.530 --> 00:40:08.150
have the document be displayed,
and then you release it after you're

00:40:08.150 --> 00:40:10.100
done to clean up after yourself.

00:40:10.270 --> 00:40:13.570
Or you hang on to it and
draw multiple PDF pages.

00:40:14.420 --> 00:40:20.570
So for Jaguar,
we have full support for PDF 1.3.

00:40:20.820 --> 00:40:21.300
So we can import every PDF 1.3 document.

00:40:21.300 --> 00:40:28.060
When we create PDF documents,
we create PDF 1.3 documents.

00:40:28.060 --> 00:40:30.240
So they're compliant in that respect.

00:40:30.240 --> 00:40:34.330
The one exception is there are
cases where PDF 1.3 does not support

00:40:34.470 --> 00:40:36.250
things that we want to write out.

00:40:36.330 --> 00:40:37.960
The big one is transparency.

00:40:37.960 --> 00:40:40.600
So when we write out transparency,
we'll typically bump up the

00:40:40.600 --> 00:40:43.300
version that we create to PDF 1.4.

00:40:43.300 --> 00:40:46.860
We're sort of limited by the
fact that 1.3 doesn't have any

00:40:46.950 --> 00:40:48.530
transparency support at all.

00:40:48.670 --> 00:40:49.650
So that's one thing to be aware of.

00:40:49.720 --> 00:40:54.060
But normally we're going to
generate PDF 1.3 documents.

00:40:54.060 --> 00:40:56.990
But what's important too about
that is that we support a full

00:40:57.030 --> 00:40:59.030
roundtripping of our CG API.

00:40:59.040 --> 00:41:02.350
And what I mean by that is that if
you draw something with a regular

00:41:02.350 --> 00:41:05.160
window context and it shows up
on the screen in a certain way,

00:41:05.410 --> 00:41:07.480
and then you create a
PDF context and make the exact

00:41:07.570 --> 00:41:09.730
same calls to that PDF context,
you get a PDF context that's not

00:41:09.730 --> 00:41:09.800
going to be in the PDF context.

00:41:09.800 --> 00:41:10.650
So you can use that to create a PDF file.

00:41:10.650 --> 00:41:12.540
But if you create a PDF file and
you bring that up in preview,

00:41:12.840 --> 00:41:14.370
you'll see the same thing.

00:41:14.670 --> 00:41:18.590
So we don't have a situation where
the stuff that you call in our

00:41:18.630 --> 00:41:22.360
API doesn't map to PDF or which
doesn't show up correctly when

00:41:22.440 --> 00:41:24.430
you bring that PDF up in preview.

00:41:24.430 --> 00:41:27.150
So that's a very important
piece of the puzzle.

00:41:27.150 --> 00:41:29.800
And then we're also
adding support for PDFX3.

00:41:29.870 --> 00:41:34.610
It's a graphics art workflow format
that I'll talk about in just a second.

00:41:34.860 --> 00:41:37.260
Let's switch to demo 1.

00:41:37.380 --> 00:41:41.170
I just want to show you some
PDF files that in previous versions

00:41:41.200 --> 00:41:44.640
of Mac OS X were uninteresting.

00:41:44.680 --> 00:41:45.460
For example, this one.

00:41:45.600 --> 00:41:48.400
This takes a little bit of time
because it's pretty complicated.

00:41:48.640 --> 00:41:52.730
If you try to open this up earlier,
I don't think you'd have a crash,

00:41:52.810 --> 00:41:54.630
but you'd have a big blank page.

00:41:54.630 --> 00:42:00.650
Did I even click on it?

00:42:00.650 --> 00:42:00.650
No.

00:42:00.650 --> 00:42:00.650
Oops.

00:42:04.430 --> 00:42:06.100
And now you have nothing.

00:42:06.230 --> 00:42:07.500
Oh, there you go.

00:42:07.500 --> 00:42:08.640
Okay.

00:42:08.740 --> 00:42:11.370
So as you see, this is actually a very
complicated document.

00:42:11.420 --> 00:42:14.630
There's lots of shadings,
lots of things going on here.

00:42:14.870 --> 00:42:20.140
Previously, we would have had the
Words Adobe Illustrator at the bottom,

00:42:20.140 --> 00:42:21.180
and that's about it.

00:42:21.430 --> 00:42:23.300
So that's actually a good thing.

00:42:23.300 --> 00:42:24.900
Similarly, here's another document.

00:42:24.900 --> 00:42:28.100
Also uses complicated shadings,
a few other things that

00:42:28.510 --> 00:42:31.090
were missing before,
so we have a nice set of

00:42:31.680 --> 00:42:34.600
rendering that we weren't able
to render correctly in the past.

00:42:34.670 --> 00:42:40.100
And we've also beefed up some of our
Japanese and Chinese and so on support.

00:42:40.100 --> 00:42:42.510
So here you can see this is a PDF file.

00:42:42.800 --> 00:42:45.600
This text, you might not know it if
you don't read Japanese.

00:42:45.600 --> 00:42:48.100
This is vertical,
so that's actually working now.

00:42:48.100 --> 00:42:50.600
A couple other things in here
were previously not working,

00:42:50.600 --> 00:42:52.090
some of the shadings and so on.

00:42:52.220 --> 00:42:53.490
So all of that's there.

00:42:53.620 --> 00:42:56.600
So we're actually continuing
to track the PDF specification.

00:42:56.600 --> 00:42:59.240
We're making sure that we're
compliant and fixing any

00:42:59.240 --> 00:43:00.540
bugs that we happen to find.

00:43:00.600 --> 00:43:04.600
And we want to make sure that we're
able to keep tracking it in the future.

00:43:05.170 --> 00:43:09.230
Okay, so if we go back to the slides.

00:43:12.160 --> 00:43:13.340
Okay, so I mentioned PDF/X3.

00:43:13.340 --> 00:43:16.680
This is becoming a more and
more important standard.

00:43:16.800 --> 00:43:17.930
It's going to be an ISO standard.

00:43:17.940 --> 00:43:18.970
It's not there yet.

00:43:19.370 --> 00:43:22.090
Just briefly,
this is a pretty hairy code sample,

00:43:22.230 --> 00:43:28.090
but for those of you who are interested,
it's now possible in Jaguar to create

00:43:28.130 --> 00:43:31.100
documents which are PDF/X3 compliant.

00:43:31.100 --> 00:43:33.490
And the way you do that,
the key thing there is to

00:43:33.590 --> 00:43:35.100
provide an output intent.

00:43:35.100 --> 00:43:40.370
The output intent basically tells people,
tells us that this is the sort of how

00:43:40.370 --> 00:43:45.210
I imagine the PDF file to be printed,
the sort of the color space and so on,

00:43:45.210 --> 00:43:47.100
the information there.

00:43:47.100 --> 00:43:52.520
Now, it's a little bit complicated,
but as you can see,

00:43:52.730 --> 00:43:57.230
the key thing that I'm doing here
in the first couple of lines is I'm

00:43:57.230 --> 00:43:59.030
creating an auxiliary info dictionary.

00:43:59.110 --> 00:44:01.870
This is actually more
useful than just for PDF/X3.

00:44:02.200 --> 00:44:05.080
For example, you can provide a title
for your document.

00:44:05.110 --> 00:44:07.090
You can provide the author
information and so on.

00:44:07.130 --> 00:44:10.100
Once I've created the
auxiliary info dictionary,

00:44:10.100 --> 00:44:16.090
I pass that in to CGPDFContextCreate,
the very bottom line, create with URL,

00:44:16.120 --> 00:44:19.590
which that gives information for
the PDF context to put into the

00:44:19.590 --> 00:44:21.090
PDF file that you're generating.

00:44:21.100 --> 00:44:24.330
And we plan, over time,
this may become a larger and larger

00:44:24.330 --> 00:44:28.900
set of items that you can put into this
dictionary to change the final result

00:44:28.900 --> 00:44:31.100
of the PDF file that you're creating.

00:44:31.100 --> 00:44:34.380
In this case, I start out by,
I create the dictionary,

00:44:34.380 --> 00:44:36.510
just a regular old CFDictionary.

00:44:36.770 --> 00:44:39.630
I began by adding a title, my document.

00:44:39.720 --> 00:44:43.440
It's all CF-based,
so you sort of need to know about CF.

00:44:43.570 --> 00:44:46.240
If you don't, you'll probably learn that.

00:44:46.240 --> 00:44:51.440
And then the key thing for PDF/X3
is the output intent dictionary.

00:44:51.440 --> 00:44:54.200
I create an output intent
dictionary that has a bunch of keys.

00:44:54.200 --> 00:44:55.920
There's a whole pile more
that get put in there.

00:44:56.040 --> 00:45:00.110
And once I've done all that,
I pass that output-- I put that

00:45:00.110 --> 00:45:03.510
output intent dictionary into
the auxiliary info dictionary,

00:45:03.610 --> 00:45:05.890
and then I create the context.

00:45:06.040 --> 00:45:09.180
So this is sort of an example of
how you might create a PDF/X3 file.

00:45:09.180 --> 00:45:11.080
As I mentioned before,
it's not quite a standard yet.

00:45:11.080 --> 00:45:14.220
It should be a standard in the summer,
but we are tracking that to try

00:45:14.370 --> 00:45:17.580
to make sure that we're compliant
in the documents we generate.

00:45:17.780 --> 00:45:21.380
By default, unless you create this
output intent dictionary,

00:45:21.420 --> 00:45:23.580
you won't have a PDF/X3 file.

00:45:23.890 --> 00:45:27.780
Probably not a problem for most people,
but just so you know that.

00:45:28.040 --> 00:45:29.560
Okay.

00:45:34.920 --> 00:45:35.920
So, color spaces.

00:45:35.920 --> 00:45:39.250
So, at this point,
just to step back a little bit,

00:45:39.250 --> 00:45:43.480
we've gone through the basic types
that are used to draw in a context.

00:45:43.590 --> 00:45:46.740
So, we talked about vector
geometry with CG path,

00:45:46.740 --> 00:45:49.840
images, CG image, CG PDF documents,
and so on.

00:45:49.910 --> 00:45:53.800
And so now we're at the point where
we need to talk about sort of,

00:45:53.800 --> 00:45:58.160
well, it's all nice to specify the
geometry and all that kind of thing,

00:45:58.280 --> 00:45:59.940
but how do I actually draw?

00:45:59.960 --> 00:46:02.730
How do I fill with a color and so on?

00:46:02.930 --> 00:46:08.480
So, what we have are a couple of things
now that specify how to fill the

00:46:08.480 --> 00:46:11.000
content of the things you're drawing.

00:46:11.160 --> 00:46:15.340
The CG color space is the type
that we use to specify the way

00:46:15.390 --> 00:46:16.800
to interpret the color data.

00:46:16.800 --> 00:46:20.720
So, it tells whether the
color data is RGB or CMYK,

00:46:20.720 --> 00:46:23.330
whether it's got an
ICC profile and so on.

00:46:23.750 --> 00:46:26.600
There are two flavors of color
spaces that are typically used.

00:46:26.720 --> 00:46:29.170
Device dependent,
from the name you can tell

00:46:29.170 --> 00:46:30.960
it means device dependent.

00:46:30.960 --> 00:46:35.220
That means that how-- the color is
rendered is completely up to the device.

00:46:35.220 --> 00:46:37.960
They could take red and turn
it into blue if they wanted to.

00:46:37.960 --> 00:46:40.220
It's completely not in your control.

00:46:40.220 --> 00:46:43.480
So, that's not typically the best
choice for most rendering.

00:46:43.730 --> 00:46:46.380
Normally, people want to use device
independent color spaces.

00:46:46.400 --> 00:46:50.700
If they want high fidelity color,
that's always the best idea.

00:46:51.480 --> 00:46:54.140
For Jaguar,
we're going to add some additional

00:46:54.140 --> 00:46:56.390
color space convenience functions.

00:46:56.500 --> 00:46:59.250
Currently, we have a set of them,
but they're pretty low level.

00:46:59.320 --> 00:47:03.680
We're going to add functions that allow
you to get information from color sync

00:47:03.680 --> 00:47:08.060
but through CG without necessarily
going and learning all about color sync.

00:47:08.060 --> 00:47:10.720
In particular,
the user's document default color space,

00:47:10.740 --> 00:47:14.350
that's the thing that shows up in
the color sync preferences panel.

00:47:14.350 --> 00:47:18.620
We're going to add a color space
that's special in that it gives

00:47:18.770 --> 00:47:23.430
you fast on-screen drawing,
which means that the colors may

00:47:23.430 --> 00:47:27.510
not be precisely correct on screen,
but that's sometimes okay

00:47:27.510 --> 00:47:30.850
for certain applications,
but will preserve the color

00:47:30.950 --> 00:47:32.300
fidelity when you print.

00:47:32.300 --> 00:47:34.690
So you get the right results when
you print where it often matters,

00:47:34.690 --> 00:47:37.840
but you might get a slight
approximation to the truth on screen,

00:47:37.850 --> 00:47:40.740
but it will be fast,
so that can be very important

00:47:40.740 --> 00:47:42.420
for some applications.

00:47:42.420 --> 00:47:44.500
Other API to let you get at some
of the standard Apple color spaces,

00:47:44.500 --> 00:47:45.420
we're going to add a little bit of color.

00:47:45.780 --> 00:47:46.660
and so on.

00:47:46.850 --> 00:47:50.270
So you should look for
that API coming soon.

00:47:51.390 --> 00:47:54.500
There are a couple of
other special color spaces,

00:47:54.500 --> 00:47:58.540
indexed GIF images are a good
example where an index value is

00:47:58.540 --> 00:48:04.040
used to look up in a table which
specifies the actual color of a pixel.

00:48:04.070 --> 00:48:05.200
I'm not going to talk
about that very much.

00:48:05.250 --> 00:48:08.200
I'm going to focus more on patterns,
which are new since last year.

00:48:08.200 --> 00:48:12.380
Although they were part of Mac OS 10.1,
we didn't actually talk about

00:48:12.380 --> 00:48:14.950
them in last year's session,
so I wanted to go through

00:48:15.040 --> 00:48:17.150
that a little bit more.

00:48:19.400 --> 00:49:55.900
[Transcript missing]

00:49:56.950 --> 00:50:00.740
I can change the spacing
between the pattern elements.

00:50:00.840 --> 00:50:05.500
And as you see,
here I am drawing a circle,

00:50:05.500 --> 00:50:08.530
but the pattern can actually be,
for example, a star.

00:50:08.970 --> 00:50:10.210
That's pretty simple.

00:50:10.340 --> 00:50:11.540
And I can just fill that.

00:50:11.610 --> 00:50:16.120
I can draw with, you know,
pretty much-- I can fill any

00:50:16.120 --> 00:50:19.170
shape I want to with my pattern.

00:50:21.010 --> 00:50:23.900
and I think I mentioned the size.

00:50:23.920 --> 00:50:27.980
I can change the color of the
pattern to be some other color

00:50:28.020 --> 00:50:30.080
that I might like better.

00:50:31.400 --> 00:50:47.910
The first step is to create
the Quartz 2D graphics system.

00:50:47.910 --> 00:50:47.910
The first step is to create
the Quartz 2D graphics system.

00:50:47.910 --> 00:50:47.910
The second step is to create
the Quartz 2D graphics system.

00:50:47.910 --> 00:50:47.910
The third step is to create
the Quartz 2D graphics system.

00:50:47.910 --> 00:50:47.910
The fourth step is to create
the Quartz 2D graphics system.

00:50:49.370 --> 00:51:01.450
The focus is on important Quartz 2D
features such as device/resolution

00:51:01.450 --> 00:51:01.450
independent rendering,

00:51:03.300 --> 00:51:25.700
[Transcript missing]

00:51:26.400 --> 00:52:24.500
[Transcript missing]

00:52:26.700 --> 00:52:28.550
So suppose you said, "Oh, that's so nice.

00:52:28.640 --> 00:52:31.190
I want to do patterns myself." Well,
what would you do?

00:52:31.190 --> 00:52:34.360
Well, you'd create a pattern
with CGPatternCreate.

00:52:34.360 --> 00:52:37.000
You'd tell us that you're
going to be using patterns by

00:52:37.000 --> 00:52:39.800
specifying a pattern color space,
and then you'd set the

00:52:39.800 --> 00:52:41.520
pattern in the context,
and then you'd just

00:52:41.680 --> 00:52:42.840
fill or stroke the path.

00:52:42.970 --> 00:52:46.210
So you might get the idea by
thinking about that that patterns,

00:52:46.210 --> 00:52:49.220
from our point of view,
are just the same as colors.

00:52:49.320 --> 00:52:51.240
So just like you might say,
"I'm going to draw with--I'm

00:52:51.480 --> 00:52:52.720
going to fill the circle with red.

00:52:52.720 --> 00:52:55.800
I'm going to fill the circle with
umbrellas." It's all the same to us.

00:52:55.820 --> 00:52:59.480
It's just sort of
conceptually like a color.

00:52:59.480 --> 00:53:03.910
So another code example.

00:53:04.420 --> 00:53:07.800
Here's a case where we're
going to draw a pattern.

00:53:07.800 --> 00:53:11.800
This is actually a little bit
complicated to look at and absorb.

00:53:11.800 --> 00:53:14.790
As you can see though,
the key thing here is the very top line,

00:53:15.090 --> 00:53:15.760
draw a circle.

00:53:16.090 --> 00:53:19.110
That's the function you
provide to-- in our case,

00:53:19.110 --> 00:53:21.800
this is an example of a
pattern that's just a circular,

00:53:21.860 --> 00:53:22.860
using a circle.

00:53:23.080 --> 00:53:26.140
That's the thing that you provide
that makes everything else possible.

00:53:26.140 --> 00:53:29.740
So in the same way that here
I'm using draw a circle,

00:53:29.740 --> 00:53:32.420
you could have draw a PDF document,
or draw image from my

00:53:32.420 --> 00:53:34.980
favorite file format,
or anything else.

00:53:35.100 --> 00:53:38.800
So the callback mechanism is
very powerful and very useful.

00:53:38.800 --> 00:53:43.100
And then we have a whole pile of
stuff that sort of is the mechanism

00:53:43.100 --> 00:53:45.300
by which we step through to say,
"Well,

00:53:45.300 --> 00:53:47.000
we want the pattern cell to be this big.

00:53:47.000 --> 00:53:49.060
"We want it to be spaced by this amount.

00:53:49.100 --> 00:53:52.120
"We need to tell you about the
color space "we're going to be

00:53:52.120 --> 00:53:55.410
drawing in." All of this goop,
and this is all-- it turns out,

00:53:55.510 --> 00:53:59.260
this typically turns out to be sort of
boilerplate code that you just typically

00:53:59.260 --> 00:54:03.500
write once and put into a function that
you can call yourself multiple times.

00:54:03.500 --> 00:54:07.100
But once you get to the end of it,
you then, the very last line,

00:54:07.100 --> 00:54:09.000
when you say,
"CGContact set full pattern,"

00:54:09.000 --> 00:54:12.190
you specify the pattern you're
interested in and a color,

00:54:12.370 --> 00:54:15.300
typically,
that will just contain alpha information.

00:54:15.300 --> 00:54:18.660
So that says how, you know,
whether the actual pattern is

00:54:18.660 --> 00:54:22.500
composited with what alpha value,
with what transparency value.

00:54:22.500 --> 00:54:24.000
And then you clean up after yourself.

00:54:24.000 --> 00:54:27.300
And then once you set the fill pattern,
you just fill a circle,

00:54:27.300 --> 00:54:29.700
you stroke a circle, whatever,
whatever shape you like,

00:54:29.700 --> 00:54:33.100
and you'll get the pattern
replicated in that region.

00:54:33.100 --> 00:54:35.300
So again,
this is a little bit hairy to look at.

00:54:35.300 --> 00:54:37.100
We're going to--all the
examples I've shown today,

00:54:37.100 --> 00:54:41.090
all of the demos are going to
be available to you through DTS,

00:54:41.120 --> 00:54:43.470
and so you'll be able to look at
that a little bit more closely and

00:54:43.470 --> 00:54:46.900
understand it a little bit better,
better than I think I can do

00:54:47.020 --> 00:54:49.900
here in a large talk like this.

00:54:50.140 --> 00:54:51.310
Okay, so that's patterns.

00:54:51.400 --> 00:54:53.770
And then the one final thing that
we're going to talk about in terms

00:54:54.220 --> 00:54:56.690
of filling a region is shadings.

00:54:56.940 --> 00:54:58.900
This is also new in Jaguar.

00:54:59.210 --> 00:55:02.700
And the shading idea,
it's a way we abstract gradient,

00:55:02.790 --> 00:55:05.360
radial-axial gradients.

00:55:05.700 --> 00:55:09.920
The word "shading" comes from PDF,
where they actually support

00:55:09.920 --> 00:55:11.690
more things as well.

00:55:11.750 --> 00:55:14.500
Again, just like with patterns,
it's resolution independent.

00:55:14.560 --> 00:55:16.620
So it's not just like a
little weird bitmap that gets

00:55:16.620 --> 00:55:18.000
replicated and looks ugly.

00:55:18.050 --> 00:55:19.700
Instead, it's, you know,
pretty much a full,

00:55:19.760 --> 00:55:23.700
nice shading that scales the
resolution of the output device.

00:55:23.710 --> 00:55:25.110
And it's, again,
better than doing it yourself.

00:55:25.200 --> 00:55:26.690
We can do the same
types of optimizations,

00:55:26.700 --> 00:55:29.620
same types of tricks that we
do with patterns to make the

00:55:29.690 --> 00:55:32.300
shadings look really well.

00:55:32.330 --> 00:55:37.100
So just a quick demo, demo one.

00:55:37.160 --> 00:55:42.180
I'll show you the--what we have here.

00:55:43.910 --> 00:55:46.240
So there are two flavors
of shadings in Jaguar.

00:55:46.240 --> 00:55:49.750
There's the axial shading,

00:55:49.940 --> 00:55:54.200
And here you see what I have for an axial
shading is I have a start point here,

00:55:54.200 --> 00:55:58.420
and then I have an end point,
and the shading changes along that axis.

00:55:58.440 --> 00:56:02.140
And of course, it's scaled appropriately,
and so we can rotate it.

00:56:02.190 --> 00:56:03.790
We're free to do all of that.

00:56:03.900 --> 00:56:06.380
I can also create a radial shading.

00:56:06.400 --> 00:56:10.700
So in this case,
I have a circle that has the color

00:56:10.700 --> 00:56:14.500
changes along an axis along the radius,
starts at this point and ends

00:56:14.500 --> 00:56:15.960
out here at this other point.

00:56:16.110 --> 00:56:18.060
So there's the two flavors of shadings.

00:56:18.080 --> 00:56:19.020
Let's go back to axial.

00:56:19.750 --> 00:56:23.430
Now, again, because we really like the
callback mechanism because it

00:56:23.840 --> 00:56:25.810
means you do a lot of the work.

00:56:25.960 --> 00:56:31.650
Rather, we're enabling you to do the
work that otherwise it might

00:56:31.760 --> 00:56:33.120
not be able to be available.

00:56:33.180 --> 00:56:36.090
So here, for example,
we're not stuck with...

00:56:36.110 --> 00:56:37.860
Travis is laughing at me.

00:56:37.970 --> 00:56:40.600
You're not stuck with
just linear shadings,

00:56:40.620 --> 00:56:42.040
which some people would say, oh,
that's good enough.

00:56:42.170 --> 00:56:44.480
You can, in the callback,
do anything you want to.

00:56:44.480 --> 00:56:46.320
So it's a regular
general-purpose function.

00:56:46.320 --> 00:56:49.160
So you can make the shading
look your favorite way.

00:56:49.700 --> 00:56:52.170
Which actually can make
things look really nice.

00:56:52.270 --> 00:56:54.340
So here I have a simple linear shading.

00:56:54.340 --> 00:56:57.630
But if I want,
I can change that to just a sine wave.

00:56:57.640 --> 00:57:01.590
So this is a different look because
I'm free to change these values.

00:57:01.600 --> 00:57:04.490
I can make this have multiple...
a different frequency.

00:57:04.550 --> 00:57:05.550
I can even animate it.

00:57:05.750 --> 00:57:08.100
In this case,
this is just a bunch of different

00:57:08.190 --> 00:57:11.640
shadings that are being cycled
through at different frequencies.

00:57:11.640 --> 00:57:14.290
But none of this is sort of
built into core graphics.

00:57:14.410 --> 00:57:18.390
Instead, what we're doing is we're
providing you callback mechanisms

00:57:18.750 --> 00:57:19.440
to do this type of thing.

00:57:19.450 --> 00:57:20.110
This type of drawing.

00:57:20.140 --> 00:57:26.980
So you'll see in the example
code that we're not saying,

00:57:26.980 --> 00:57:30.260
oh, create a shading with a sinusoidal
function that has these parameters.

00:57:30.260 --> 00:57:32.290
Instead,
it's just a callback that happens to be,

00:57:32.430 --> 00:57:33.720
in this case, a sine wave.

00:57:33.850 --> 00:57:34.990
And of course,
I can do that with a radial

00:57:34.990 --> 00:57:37.330
shading if I want to,
which is a little weird.

00:57:37.350 --> 00:57:40.620
But I hope nobody suffers
any ill effects from this.

00:57:42.700 --> 00:57:46.730
The focus is on important Quartz 2D
features such as device/resolution

00:57:46.820 --> 00:57:50.830
independent rendering,
advanced drawing model, transformations,

00:57:50.830 --> 00:57:52.260
and support for PDF.

00:57:52.440 --> 00:57:53.930
pull this over here.

00:57:54.220 --> 00:57:58.340
We can change the start
color to be anything we like.

00:57:58.340 --> 00:58:01.690
Let's make that a little brighter.

00:58:01.780 --> 00:58:05.600
And we can change the end color,
if we want, to be something different.

00:58:05.600 --> 00:58:11.560
So all of this, again, you know,
this is all just unoptimized, simple API,

00:58:11.560 --> 00:58:14.580
API calls directly into CG.

00:58:14.730 --> 00:58:18.400
This is one area that currently
is not available in Cocoa,

00:58:18.400 --> 00:58:19.400
I believe.

00:58:19.430 --> 00:58:22.540
So this might be the one case where if
you were writing a Cocoa application,

00:58:22.540 --> 00:58:25.780
you might want to drop directly
down into Core Graphics.

00:58:26.120 --> 00:58:28.680
The other thing we can do
is we have a feature which,

00:58:28.690 --> 00:58:31.240
if you draw the shading,
that can often be very nice,

00:58:31.240 --> 00:58:34.600
but sometimes you want to
sort of fill in past the ends.

00:58:34.760 --> 00:58:37.430
So we can turn on
starting and end filling.

00:58:37.780 --> 00:58:41.500
So the final color will
be replicated infinitely,

00:58:41.640 --> 00:58:42.780
sort of from that point onward.

00:58:42.780 --> 00:58:46.650
So that can be sometimes useful depending
on the effect you're trying to get.

00:58:47.030 --> 00:58:50.560
And of course that is also
tracked by the actual color.

00:58:50.680 --> 00:58:51.780
Thank you.

00:58:54.600 --> 00:59:07.460
Quartz 2D is a software-based
software that is designed to support

00:59:07.460 --> 00:59:07.460
the performance of the Mac OS X.

00:59:09.000 --> 00:59:20.000
[Transcript missing]

00:59:20.480 --> 00:59:23.400
The Quartz 2D graphics
system is a simple,

00:59:23.660 --> 00:59:27.340
easy-to-use, and fast-growing,
highly-efficient,

00:59:50.400 --> 00:59:52.930
first lower left corner,
the starting circle has radius zero,

00:59:52.930 --> 00:59:56.720
so that's why you sort of see the shading
go from the center out to the edge.

00:59:56.720 --> 00:59:59.650
Now, the two circles don't have
to have the same center.

01:00:00.030 --> 01:00:02.370
Here I have a shading which,
a radial shading where the

01:00:02.460 --> 01:00:06.960
starting circle is sort of
upper right in the ball,

01:00:06.960 --> 01:00:10.730
and the outer circle is the outer circle.

01:00:11.110 --> 01:00:13.560
And so then when I fill it,
the interpolation sort of makes it

01:00:13.660 --> 01:00:16.060
look a little bit like a bowling ball,
a billiard ball.

01:00:16.060 --> 01:00:18.300
And then the two circles
don't even have to intersect.

01:00:18.670 --> 01:00:21.590
So here I have in the upper left
hand corner a small tiny circle,

01:00:21.770 --> 01:00:22.440
which is yellow.

01:00:22.680 --> 01:00:25.460
I have a larger circle as my
ending circle in the right,

01:00:25.460 --> 01:00:28.360
which is the big circle,
and I interpolate between

01:00:28.360 --> 01:00:29.990
those two to fill the region.

01:00:29.990 --> 01:00:31.940
So you get sort of a megaphone look.

01:00:32.080 --> 01:00:35.880
So you can do a number of interesting
little effects with shadings.

01:00:35.890 --> 01:00:38.330
But the key things are
things like gradients,

01:00:38.330 --> 01:00:40.990
linear gradients, very useful.

01:00:41.080 --> 01:00:44.490
Certainly circular shadings can be useful

01:00:45.420 --> 01:00:48.920
As I mentioned before,
they're not required to be linear.

01:00:49.110 --> 01:00:52.560
Your callback can be anything
complicated that you want.

01:00:52.750 --> 01:00:56.360
The key thing is that we're going
to pass you a value between 0 and 1,

01:00:56.370 --> 01:00:59.350
which is the distance along
the axis that you specify,

01:00:59.350 --> 01:01:00.630
the scale distance.

01:01:00.660 --> 01:01:05.020
The way you give us information back
is with what we call a CG function.

01:01:05.130 --> 01:01:08.310
This is a new type that we've added,
which it's a little bit more

01:01:08.380 --> 01:01:12.320
general than what I described here,
but basically for this application,

01:01:12.320 --> 01:01:15.010
it takes one value in,
which is the distance along

01:01:15.010 --> 01:01:18.080
the axis of the radius,
and you give us back a color.

01:01:18.590 --> 01:01:20.990
So one value in that place,
and then you calculate what

01:01:21.090 --> 01:01:22.340
color you want it to be.

01:01:22.340 --> 01:01:24.660
Normally,
your start color is going to be value 0,

01:01:24.800 --> 01:01:27.850
your end color is going to be value 1,
and you decide what it's

01:01:27.910 --> 01:01:29.650
going to be along that axis.

01:01:29.660 --> 01:01:32.710
So as a simple example here,
I'm just going to imagine that

01:01:32.770 --> 01:01:34.440
I'm going to do a linear shading.

01:01:34.440 --> 01:01:38.180
I have some magic function somewhere
called evaluate linear that knows

01:01:38.240 --> 01:01:41.430
how to take a value in and do
a linear interpolation between

01:01:41.430 --> 01:01:43.490
two colors and return that out.

01:01:43.620 --> 01:01:48.540
I need to pass in information to the
function that tells what the domain is.

01:01:48.560 --> 01:01:50.020
The domain of the function is how,
in this case,

01:01:50.130 --> 01:01:51.350
it's going to be always 0 to 1.

01:01:51.360 --> 01:01:55.780
What the range is for RGB, again, 0 to 1.

01:01:55.780 --> 01:01:57.680
Other color spaces might
have different ranges.

01:01:57.680 --> 01:02:00.980
And then I call CG function
create info parameters,

01:02:00.980 --> 01:02:05.140
void stars, which you pass in for any
information you might need to

01:02:05.140 --> 01:02:08.300
track to calculate the function.

01:02:08.300 --> 01:02:10.940
I pass in the number of parameters
for the domain and range,

01:02:10.940 --> 01:02:12.240
and I give the callbacks.

01:02:12.360 --> 01:02:13.220
And so that's my function.

01:02:13.220 --> 01:02:18.200
Now I have a thing which I can use to
give to a shading to do an evaluation.

01:02:18.560 --> 01:02:20.210
So I'm going to do a linear
interpolation between two colors.

01:02:20.320 --> 01:02:22.440
Whoops.

01:02:25.100 --> 01:03:10.600
[Transcript missing]

01:03:10.700 --> 01:03:25.900
[Transcript missing]

01:03:26.400 --> 01:03:29.020
We could switch to demo one.

01:03:29.020 --> 01:03:33.720
So here we have a bunch of different
things that are drawn using CG,

01:03:33.720 --> 01:03:34.610
all the different things.

01:03:34.640 --> 01:03:35.890
We'll just swoosh them out.

01:03:35.960 --> 01:03:41.270
And as you see, we have things with
patterns through them.

01:03:41.280 --> 01:03:44.060
We have solid shapes and so on.

01:03:44.060 --> 01:03:45.420
We have text animated.

01:03:45.420 --> 01:03:48.180
And we even have some bugs, which,
as you can see,

01:03:48.180 --> 01:03:50.620
some of the little things,
the shadings are there,

01:03:50.620 --> 01:03:52.180
and then they disappear.

01:03:52.180 --> 01:03:55.760
I don't know why,
but I just discovered that today.

01:03:56.400 --> 01:03:58.840
But nevertheless,
this is a simple example

01:03:59.000 --> 01:04:03.500
of just... You know,
I have to sort of keep mentioning this.

01:04:03.800 --> 01:04:04.980
This is a Cocoa app.

01:04:05.250 --> 01:04:05.880
Cocoa's amazing.

01:04:05.880 --> 01:04:06.820
It's really, really great.

01:04:06.820 --> 01:04:09.260
And I didn't do any optimization.

01:04:09.260 --> 01:04:11.280
This is just really simple stuff, right?

01:04:11.330 --> 01:04:14.330
No special back buffers,
no double buffering, no crazy stuff.

01:04:14.710 --> 01:04:17.770
Core graphics has a lot of
power in it to let you do really

01:04:17.770 --> 01:04:19.210
complicated things very easily.

01:04:19.220 --> 01:04:22.030
And you should know... I mean,
the stuff I'm creating here, I mean,

01:04:22.040 --> 01:04:24.980
I'm not even being careful about it,
right?

01:04:24.980 --> 01:04:27.820
I mean, it's sort of sloppy code,
but it still runs pretty fast.

01:04:27.960 --> 01:04:33.090
So just so you... Just my
little plug for Cocoa and so on.

01:04:33.120 --> 01:04:37.220
Okay, so if we go back to the slides,
just for the last bit.

01:04:37.390 --> 01:04:41.830
So in summary,
we have a lot of new API this

01:04:42.140 --> 01:04:44.640
year that we want you to try out.

01:04:44.820 --> 01:04:45.910
Let us know what you think.

01:04:45.960 --> 01:04:51.500
We want to continue growing our API set,
though I should mention that our

01:04:51.750 --> 01:04:55.200
philosophy is not necessarily
to provide you with a house.

01:04:55.280 --> 01:04:57.040
It's to provide you with a toolset,
but it's also to build a house.

01:04:57.040 --> 01:05:00.000
So in our API,
we try to have pretty simple,

01:05:00.000 --> 01:05:03.730
lightweight, non-complicated things that
let you do really powerful

01:05:03.850 --> 01:05:05.590
stuff in your own application.

01:05:05.610 --> 01:05:07.440
But we don't want to
necessarily sort of cram down.

01:05:07.440 --> 01:05:10.270
Like, that's why we didn't do, you know,
oh, here's a linear shader for you,

01:05:10.310 --> 01:05:11.950
because everybody wants only that, right?

01:05:11.960 --> 01:05:13.540
Instead,
it's really much more general than that.

01:05:13.630 --> 01:05:16.450
So we're trying to sort of continue
to add API where it makes sense,

01:05:16.460 --> 01:05:19.900
but also make sure that the general
philosophy of giving you tools to let

01:05:19.900 --> 01:05:21.840
you do complex things is respected.

01:05:21.950 --> 01:05:25.450
And that said, your feedback,
always great.

01:05:25.530 --> 01:05:26.210
We love feedback.

01:05:26.340 --> 01:05:29.480
It really helps us help focus where
we want to go and what's sort of

01:05:29.550 --> 01:05:31.050
missing that we want to add and so on.

01:05:31.110 --> 01:05:33.600
So we encourage everybody to
give feedback wherever possible.

01:05:33.600 --> 01:05:40.040
And I think we have some documentation
that you might want to look at.

01:05:40.040 --> 01:05:44.180
Listed here,
there's the documentation website.

01:05:44.180 --> 01:05:50.240
And the principal way, I think, still,
for the new Jaguar APIs to get

01:05:50.280 --> 01:05:52.900
information about some of the
functions was the header bot comments.

01:05:53.040 --> 01:05:55.490
So if you look in the headers
in the Core Graphics Framework,

01:05:56.280 --> 01:05:58.280
there's some technical notes listed here.

01:05:58.280 --> 01:06:02.180
And as I mentioned before,
some of the sample code

01:06:02.180 --> 01:06:03.490
will be provided by DTS.

01:06:03.560 --> 01:06:05.660
So now,
if I could give this back to Travis,

01:06:05.820 --> 01:06:07.670
he will take us to the
end of the presentation.

01:06:13.990 --> 01:06:15.840
Yeah,
I'm going to hustle through a roadmap

01:06:15.840 --> 01:06:18.970
here real quick because we ran a little
long and we want to get a Q and A in.

01:06:18.980 --> 01:06:20.850
So,
I just want to bring your attention to

01:06:20.850 --> 01:06:24.580
certain sessions that we have at this
year's WWC that you may be interested in.

01:06:25.160 --> 01:06:27.620
Obviously,
at 3:30 today we have in Hall 2

01:06:27.620 --> 01:06:31.460
"Exploring the Quartz Compositor,"
where we'll be going over in

01:06:31.510 --> 01:06:34.560
more depth the sort of compositor
architecture and talk in depth about

01:06:34.590 --> 01:06:37.410
the architecture of Quartz Xtreme,
which was shown in the Graphics

01:06:37.460 --> 01:06:40.080
and Imaging Overview and also
in the keynote yesterday.

01:06:40.660 --> 01:06:44.610
Additionally,
we have an interesting session,

01:06:44.610 --> 01:06:49.540
which is OpenGL Integrated Graphics 2,
where I'll essentially show how

01:06:49.540 --> 01:06:52.450
to build your own compositor,
which is something that if you liked

01:06:52.550 --> 01:06:54.600
what you saw with Quartz Xtreme,
you definitely want to

01:06:54.600 --> 01:06:55.630
attend that session.

01:06:55.640 --> 01:07:00.420
And then also, I wanted to call out
ColorSync Digital Media.

01:07:00.420 --> 01:07:03.920
We obviously talked about ColorSync
and how it's integrated with Quartz 2D.

01:07:03.920 --> 01:07:07.420
We'll go into a little more detail in
the ColorSync session and additionally

01:07:07.460 --> 01:07:10.100
we'll be talking about how to
leverage ColorSync in the future.

01:07:10.100 --> 01:07:14.510
And then we'll also talk about
how to leverage ColorSync in new

01:07:14.720 --> 01:07:16.740
ways for addressing the needs of
media beyond just still images.

01:07:17.280 --> 01:07:20.330
And then finally,
I think that there's a really

01:07:20.340 --> 01:07:24.700
nice session coming up on Friday,
which is 5:16 in Hall 2,

01:07:24.700 --> 01:07:26.990
which is Graphics, Imaging,
and Performance Tuning.

01:07:27.110 --> 01:07:29.140
Derek was getting pretty good
performance with his demos up here

01:07:29.140 --> 01:07:32.000
without doing any performance tuning,
but obviously we hear a lot from our

01:07:32.000 --> 01:07:37.330
developers about how do I performance
tune for Mac OS X's visual architecture.

01:07:37.440 --> 01:07:40.550
And we're going to be going in
depth on the tricks of the trade

01:07:40.550 --> 01:07:44.380
to definitely squeeze the most
performance out of the visual pipeline

01:07:44.380 --> 01:07:46.570
and the drawing APIs in the system.

01:07:46.900 --> 01:07:49.600
If you need to contact me on any
issues relating to Quartz 2D,

01:07:49.600 --> 01:07:51.240
I'm your single point of contact.

01:07:51.270 --> 01:07:52.010
There's my email.

01:07:52.160 --> 01:07:53.500
It's travis@apple.com.

01:07:53.500 --> 01:07:54.920
Feel free to email me
with your questions,

01:07:54.920 --> 01:07:56.240
concerns, or whatnot.
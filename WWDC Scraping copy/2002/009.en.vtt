WEBVTT

00:00:00.940 --> 00:00:03.010
I'm Travis Brown,
and I'm in the Technology Evangelism

00:00:03.010 --> 00:00:04.660
Department at Apple.

00:00:04.760 --> 00:00:08.120
And many of you might have recognized
me from some of the graphics sessions.

00:00:08.120 --> 00:00:10.800
I am responsible for graphics
and imaging at Apple,

00:00:10.920 --> 00:00:14.760
at least in working with developers
and helping grow those technologies.

00:00:14.760 --> 00:00:17.150
But one of the other areas that
I actually play a significant

00:00:17.150 --> 00:00:18.980
role in is accessibility.

00:00:19.010 --> 00:00:23.610
I'm sort of the technologist who
keeps track of what assistive

00:00:23.880 --> 00:00:27.930
technology needs in terms of
operating systems requirements,

00:00:27.930 --> 00:00:30.950
and also how to -- and I bring
that message directly into

00:00:30.950 --> 00:00:32.990
engineering to effect change.

00:00:32.990 --> 00:00:37.250
And one thing we've been doing is a
team inside Apple has been working very,

00:00:37.250 --> 00:00:38.650
very hard on accessibility.

00:00:38.740 --> 00:00:42.000
And so one thing I want to make
really clear is that a lot of

00:00:42.020 --> 00:00:45.230
developers and a lot of users
were worried when Mac OS X came

00:00:45.430 --> 00:00:49.620
out that Apple wasn't committed to
doing anything with accessibility.

00:00:49.680 --> 00:00:53.310
But we really are,
because we consider that it's a

00:00:53.390 --> 00:00:58.600
great idea to make our platform
open and accessible to all users.

00:00:58.700 --> 00:01:00.420
And so in Jaguar,
we spent quite a bit of time doing that.

00:01:00.420 --> 00:01:02.780
I'm doing just that.

00:01:03.970 --> 00:01:05.780
So let's look at the agenda real quick.

00:01:05.800 --> 00:01:07.730
What we're going to do is we're
going to give sort of a real

00:01:07.830 --> 00:01:10.520
quick overview of accessibility in
case there are developers in the

00:01:10.520 --> 00:01:13.220
audience who are not familiar with
issues relating to accessibility.

00:01:13.220 --> 00:01:16.620
So we'll bracket why
accessibility is important.

00:01:16.620 --> 00:01:20.280
We'll talk a little bit, a really,
really high level on Section 508

00:01:20.830 --> 00:01:24.440
because that's the way many developers
have been introduced to accessibility

00:01:24.460 --> 00:01:26.970
is through Section 508 requirements.

00:01:27.580 --> 00:01:30.760
Then we're going to quickly begin
to focus on accessibility in Jaguar.

00:01:30.840 --> 00:01:33.660
And we'll talk about our universal
access features that you've seen

00:01:33.710 --> 00:01:35.320
demonstrated in a variety of sessions.

00:01:35.320 --> 00:01:39.310
I found that the zooming feature that's
now built into Jaguar has been very,

00:01:39.430 --> 00:01:40.380
very popular.

00:01:40.380 --> 00:01:43.750
And it's been used in practically
every session I've attended

00:01:43.750 --> 00:01:45.320
to focus in on something.

00:01:45.320 --> 00:01:50.070
So we'll also then continue on to what's
the most important part of this session,

00:01:50.080 --> 00:01:53.140
which is the developer
accessibility features.

00:01:53.180 --> 00:01:57.240
This is for developers to use to
make their applications accessible.

00:01:57.580 --> 00:02:00.760
And that'll culminate, obviously,
in a lot of detail

00:02:00.890 --> 00:02:03.660
provided by Mike Engber,
who will be on stage,

00:02:03.660 --> 00:02:06.910
who will present the
Jaguar accessibility APIs.

00:02:06.920 --> 00:02:09.820
And so we're really proud of
the fact that now we have an

00:02:09.820 --> 00:02:13.810
API dedicated to accessibility
that's part of the operating system.

00:02:17.190 --> 00:02:18.500
Why is accessibility important?

00:02:18.600 --> 00:02:21.400
If you're a developer and
you've heard about this,

00:02:21.400 --> 00:02:23.670
why is it important for you
to really take accessibility

00:02:23.670 --> 00:02:24.920
seriously in your applications?

00:02:24.920 --> 00:02:29.640
Well, an important and stunning fact is
that 54 million people in the U.S.

00:02:29.640 --> 00:02:31.610
have some form of disability.

00:02:31.620 --> 00:02:33.060
And that's a huge number.

00:02:33.070 --> 00:02:36.210
And that's a pretty up-to-date number,
considering we checked it with the U.S.

00:02:36.220 --> 00:02:37.740
Department of Education on Friday.

00:02:38.800 --> 00:02:42.070
But again,
that means a large number of customers,

00:02:42.090 --> 00:02:45.590
potential users of your
software or your peripherals,

00:02:45.610 --> 00:02:48.550
could be affected by
some form of disability.

00:02:48.560 --> 00:02:53.020
And therefore, they might not be able to
access the full functionality

00:02:53.020 --> 00:02:55.120
that your software performs.

00:02:55.120 --> 00:02:57.520
So it's a real key point.

00:02:57.540 --> 00:03:00.410
These are mutual customers,
disabled or not.

00:03:00.740 --> 00:03:04.130
Those are customers, and those are sales
opportunities for your products,

00:03:04.130 --> 00:03:06.380
peripherals, and in our case, hardware.

00:03:08.060 --> 00:03:10.900
Increasingly,
this issue has become something

00:03:10.900 --> 00:03:13.850
that the state and local governments
have taken up as a requirement.

00:03:13.940 --> 00:03:16.570
So when you sell product
in through a federal,

00:03:16.570 --> 00:03:19.680
state, or local channel,
frequently you're going to have

00:03:19.680 --> 00:03:23.020
to make some sort of declaration
on how accessible your product is.

00:03:23.080 --> 00:03:25.360
This is also being done in education.

00:03:25.400 --> 00:03:28.280
So it's a real significant requirement,
and it's becoming an

00:03:28.400 --> 00:03:31.380
increasing requirement,
particularly on the back of Section 508,

00:03:31.390 --> 00:03:35.150
which we'll talk about in a moment,
that really dictates what minimum

00:03:35.280 --> 00:03:38.120
accessibility standards your
application needs to follow

00:03:38.120 --> 00:03:41.780
to be considered accessible,
and therefore, in many cases,

00:03:41.780 --> 00:03:45.100
able to be put on, you know,
purchased by the federal government.

00:03:45.100 --> 00:03:48.370
And then the last point is it's
really the right thing to do,

00:03:48.380 --> 00:03:51.800
because before I started working
with community with disabilities,

00:03:51.800 --> 00:03:56.820
I really didn't understand
how much the computer,

00:03:56.820 --> 00:03:59.640
in the case of this Macintosh,
can be fundamentally enabling and

00:03:59.640 --> 00:04:01.940
empowering to users with disabilities.

00:04:02.880 --> 00:04:05.760
It's something that's,
you almost have to experience it,

00:04:06.260 --> 00:04:10.420
because we do many operations
with our computer that is trivial,

00:04:10.420 --> 00:04:15.920
and we can, we don't really view them in
a serious and necessary light.

00:04:16.170 --> 00:04:19.480
But, for example,
text-to-speech may be absolutely

00:04:19.480 --> 00:04:23.850
vital to a user who's unable to speak,
and that might be a whole entree to

00:04:23.850 --> 00:04:26.030
communicating with the world at large.

00:04:26.100 --> 00:04:30.350
So it's a really good thing to do, and,
you know, coupled with the fact that

00:04:30.490 --> 00:04:33.260
it's now a sales requirement,
and, you know,

00:04:33.260 --> 00:04:36.780
the potential of the fact that
there's a large number of customers

00:04:36.780 --> 00:04:40.400
that you may be missing when selling
your software or hardware solutions,

00:04:40.400 --> 00:04:41.900
it's a really important thing to do.

00:04:45.210 --> 00:04:47.960
Let's talk just really
briefly about Section 508.

00:04:47.980 --> 00:04:53.300
Essentially, Section 508 is an extension
of the Rehabilitation Act of,

00:04:53.300 --> 00:04:55.240
I believe, 1973.

00:04:55.290 --> 00:05:01.820
And so there's been laws regulating
support for persons with disabilities

00:05:02.250 --> 00:05:03.400
for a long time in the books.

00:05:03.400 --> 00:05:09.000
It's just they never really reached
in and sort of provided minimum

00:05:09.000 --> 00:05:15.180
standards for things like computers,
operating systems, applications,

00:05:15.270 --> 00:05:18.630
websites, and general electronic devices.

00:05:18.840 --> 00:05:23.260
And this was a problem because
those areas have grown up so

00:05:23.380 --> 00:05:26.580
fast over the past 20 years,
in many cases,

00:05:26.590 --> 00:05:29.250
little or no effort was put
into making them accessible.

00:05:29.450 --> 00:05:33.260
So this is a significant problem
that the functionality that we

00:05:33.400 --> 00:05:37.570
find every day in our computers,
in many cases, is not available to a

00:05:37.570 --> 00:05:39.490
person with a disability.

00:05:39.600 --> 00:05:41.840
So the federal government
has weighed in and says,

00:05:41.870 --> 00:05:43.470
"We're going to have to make
sure that we have a standard

00:05:43.650 --> 00:05:44.700
for things that it purchases.

00:05:44.840 --> 00:05:48.840
Those products need to be compliant and
adhere it to some of the minimal rules

00:05:48.840 --> 00:05:54.660
laid down in Section 508." And the key
thing is that this is good and bad.

00:05:54.870 --> 00:05:58.210
One is this has caused accessibility
to sort of percolate up to becoming an

00:05:58.210 --> 00:06:01.560
important issue for software developers
and hardware developers to deal with.

00:06:01.640 --> 00:06:07.530
But it's also bad because Section 508
is being taken as the only standard.

00:06:07.670 --> 00:06:11.170
So that if you do Section 508,
you're fully accessible and you're done.

00:06:11.290 --> 00:06:14.520
That's not really the attitude
you should take as you approach

00:06:14.650 --> 00:06:16.280
accessibility in your products.

00:06:16.300 --> 00:06:19.790
Because one thing is the spectrum
of disabilities is quite large,

00:06:19.860 --> 00:06:23.640
and Section 508 doesn't necessarily
address every single one of them.

00:06:23.660 --> 00:06:27.920
But it's important that it started and
opened the dialogue and caused people

00:06:27.920 --> 00:06:30.180
to take the whole matter seriously.

00:06:32.010 --> 00:06:33.940
Now,
if you haven't already done this and you

00:06:33.940 --> 00:06:37.330
want to find out more about Section 508,
what you need to do is go to

00:06:37.330 --> 00:06:40.580
the Access Board's website and
download or take a look online

00:06:40.580 --> 00:06:42.600
at Section 508 requirements.

00:06:42.600 --> 00:06:44.400
They're pretty interesting.

00:06:44.400 --> 00:06:48.310
It's actually a fairly sizable document,
but the parts that really apply

00:06:48.310 --> 00:06:51.960
to operating system software
and peripherals is fairly short.

00:06:52.100 --> 00:06:54.600
If I remember,
the part that applies to operating

00:06:54.600 --> 00:06:57.770
systems is about a column and
a half inside the document.

00:06:58.780 --> 00:07:02.730
And you look at it and you'll first go,
hmm, this is not that bad.

00:07:02.760 --> 00:07:05.080
Then you'll look at it again and go,
okay,

00:07:05.080 --> 00:07:07.510
this has some difficulties in some areas.

00:07:07.520 --> 00:07:09.470
Then you'll look at it
again and you'll go,

00:07:09.470 --> 00:07:11.970
I'm going to have to redo
my complete application.

00:07:11.980 --> 00:07:15.970
So the key thing is don't panic,
because first place you want to

00:07:16.120 --> 00:07:20.790
look at is the commentary documents
that are up there on the website.

00:07:20.800 --> 00:07:22.710
In many cases,
if you're having an issue with

00:07:22.810 --> 00:07:26.040
a particular part of Section 508
that might be mandating a certain

00:07:26.110 --> 00:07:31.080
functionality in your application,
and you don't think that might not

00:07:31.200 --> 00:07:35.110
apply to your application or you
don't know if it applies or how

00:07:35.220 --> 00:07:38.330
it applies to your application,
often someone has asked that

00:07:38.330 --> 00:07:40.760
question before and those
comments are going to be,

00:07:40.870 --> 00:07:42.870
you can find them up
there on the website.

00:07:42.880 --> 00:07:44.910
So it's a good first start.

00:07:45.090 --> 00:07:47.330
But the key point to really
remember is that there's really

00:07:47.400 --> 00:07:48.920
three players in accessibility.

00:07:48.920 --> 00:07:51.920
There's going to be, obviously, you,
the application writer.

00:07:51.920 --> 00:07:54.330
There's going to be the
operating system vendor,

00:07:54.330 --> 00:07:55.250
which is Apple.

00:07:55.260 --> 00:07:58.750
And then also there's going to be
something called assistive technology.

00:07:58.770 --> 00:08:01.180
That we'll actually get at in a moment.

00:08:01.180 --> 00:08:04.440
But essentially the burden of
accessibility is shared by all three.

00:08:04.600 --> 00:08:07.760
And the way Section 508 works is
that you don't have to implement all

00:08:07.890 --> 00:08:10.900
of Section 508 if another part of,
let's say, for example,

00:08:10.900 --> 00:08:13.240
the operating system
supports that feature.

00:08:13.360 --> 00:08:15.850
And if your application is
based on the operating system,

00:08:15.890 --> 00:08:19.750
it might pick that functionality up for
free and therefore meet the requirement.

00:08:19.760 --> 00:08:23.280
The same is true if assistive
technology can actually perform that

00:08:23.280 --> 00:08:27.300
function as well on behalf of your
application or the operating system.

00:08:27.300 --> 00:08:28.680
So you're not alone in this.

00:08:28.680 --> 00:08:31.620
So the key thing is when
you look at Section 508,

00:08:31.620 --> 00:08:35.000
look at the commentary,
understand what it's talking about.

00:08:35.180 --> 00:08:38.470
But then also the next questions
to ask are first come to us,

00:08:38.470 --> 00:08:41.910
come to Apple and say, hey,
how's my application impacted by

00:08:41.910 --> 00:08:44.620
this particular part of Section 508?

00:08:44.720 --> 00:08:47.130
And we might be able to reply,
you're covered.

00:08:47.260 --> 00:08:49.730
The operating system,
Jaguar now supports that.

00:08:49.980 --> 00:08:53.260
So the key thing is take a look at it.

00:08:53.360 --> 00:08:56.780
It is the document to sort of get
your feet wet with accessibility.

00:08:56.780 --> 00:08:58.250
And it also happens to be the
document that a lot of the people use.

00:08:58.870 --> 00:09:00.830
It's not just the document
that a lot of the federal,

00:09:00.830 --> 00:09:03.780
state, and local and educational
requirements are being based on.

00:09:07.710 --> 00:09:10.440
So let's actually talk more
about accessibility in Jaguar.

00:09:10.480 --> 00:09:11.720
Obviously, we saw the keynote.

00:09:11.720 --> 00:09:15.020
We announced that we have support
for a lot of accessibility features.

00:09:15.020 --> 00:09:17.940
And we really sort of factored
the problem into two levels.

00:09:17.980 --> 00:09:22.160
One thing is we want the platform
to be reasonably accessible

00:09:22.160 --> 00:09:24.020
right outside of the box.

00:09:24.120 --> 00:09:28.460
And so we've created a bunch of features
which we call user-level accessibility.

00:09:28.460 --> 00:09:30.670
And those are what we call
universal access features.

00:09:30.740 --> 00:09:32.530
That's sort of our
umbrella term for them.

00:09:33.300 --> 00:09:37.050
And then the more interesting part
for today's discussion is really

00:09:37.160 --> 00:09:41.060
the developer-level accessibility,
which is what you as a developer

00:09:41.140 --> 00:09:44.690
have to do inside your applications
to either expose them to our

00:09:44.690 --> 00:09:49.100
accessibility APIs or work in
conjunction with assistive technology.

00:09:49.120 --> 00:09:52.820
So we'll start first and talk a little
bit about user-level accessibility.

00:09:52.820 --> 00:09:55.180
And that's universal access.

00:09:55.180 --> 00:09:57.260
Now, some of you may have
seen this little icon.

00:09:57.370 --> 00:09:59.040
It appeared actually in 10.1.

00:09:59.060 --> 00:10:01.980
We actually snuck some of
this functionality in 10.1.

00:10:03.380 --> 00:10:07.040
And this little icon
resides in the press panel.

00:10:07.040 --> 00:10:10.520
So if you're not familiar,
you can go to the system preferences.

00:10:10.520 --> 00:10:11.650
You can click on them.

00:10:11.650 --> 00:10:12.760
Universal access.

00:10:12.760 --> 00:10:15.880
And that's where most of the features
dealing with accessibility will live.

00:10:16.110 --> 00:10:17.220
There's some exceptions.

00:10:17.370 --> 00:10:19.930
For example,
some of the speech-related features

00:10:19.930 --> 00:10:23.180
are actually under the speech
area in the operating system.

00:10:23.180 --> 00:10:25.060
So let's look at the Jaguar features.

00:10:25.060 --> 00:10:28.340
The first thing we have is the zooming
feature that I spoke about earlier.

00:10:28.340 --> 00:10:32.860
Essentially, this is meant to aid
people who have low vision.

00:10:33.300 --> 00:10:38.680
So if you need the screen magnified,
this is a method that you can dynamically

00:10:38.680 --> 00:10:41.210
zoom in on any part of the screen.

00:10:41.220 --> 00:10:44.830
And the interesting thing here
as compared to things like

00:10:44.830 --> 00:10:48.440
CloseView that ran under Mac OS 9
is this is done at a very low

00:10:48.550 --> 00:10:50.640
level inside the operating system.

00:10:50.640 --> 00:10:53.750
So it supports things
that CloseView never did.

00:10:53.920 --> 00:10:56.200
For example,
we're able to support zooming

00:10:56.350 --> 00:10:59.560
of QuickTime movies and also
zooming of OpenGL content.

00:10:59.560 --> 00:11:02.580
So it's a very fundamentally
integrated component.

00:11:02.840 --> 00:11:04.160
It enables you to zoom.

00:11:04.160 --> 00:11:10.220
I can't remember the exact size,
but you can zoom up to a huge degree.

00:11:10.220 --> 00:11:15.160
And it also has supports for zooming in
and out very rapidly so that it has some

00:11:15.160 --> 00:11:18.020
nice usability features there as well.

00:11:21.060 --> 00:11:24.820
The next one is Inversion,
which is also relating to vision.

00:11:24.870 --> 00:11:28.030
Many users might have issues
with contrast or brightness or

00:11:28.030 --> 00:11:32.440
a contrast disability that means
they need to have maximum degree

00:11:32.440 --> 00:11:33.840
of contrast to detect edges.

00:11:34.000 --> 00:11:36.700
And this is a mode that you
can put the whole screen in,

00:11:36.700 --> 00:11:41.200
which essentially does a screen inversion
taking white to black and black to white,

00:11:41.200 --> 00:11:47.300
and enables you to get the maximum
contrast ratio to see the screen.

00:11:49.140 --> 00:11:52.630
We also have the Visual Beep,
which on Mac OS 9,

00:11:52.630 --> 00:11:57.660
if you turn the volume off,
we'd actually flash the menu bar.

00:11:57.660 --> 00:12:00.080
We've done something a little
more comprehensive than Mac OS X,

00:12:00.080 --> 00:12:02.490
so we actually will flash the screen.

00:12:02.520 --> 00:12:06.920
This enables a user with a hearing
disability to understand that the

00:12:06.920 --> 00:12:12.270
system has actually sounded the alert,
that the system needs attention and

00:12:12.310 --> 00:12:16.500
needs for the user to look maybe at the
dock or some other part of the system

00:12:16.500 --> 00:12:20.900
or a dialogue that's popped up and
address a particular alert condition.

00:12:22.060 --> 00:12:24.210
We also have Sticky Keys.

00:12:24.370 --> 00:12:28.120
Sticky Keys is essentially
an input device,

00:12:28.120 --> 00:12:32.600
a form of input method that
essentially is going to allow

00:12:32.600 --> 00:12:37.140
users with coordination issues to,
instead of chord keys like

00:12:37.200 --> 00:12:40.380
we do for many operations,
like let's say creating a folder,

00:12:40.380 --> 00:12:43.060
they're able to hit each key
individually in sequence,

00:12:43.060 --> 00:12:46.640
and Sticky Keys will automatically
coalesce them into that key press.

00:12:46.640 --> 00:12:50.860
So this means things like
creating a new folder,

00:12:50.860 --> 00:12:55.410
such as hitting Command-Shift-N,
you can do singly,

00:12:55.600 --> 00:12:59.210
and the system will essentially
show you the actual key presses

00:12:59.300 --> 00:13:02.950
in a little transparent floating
window on the upper left.

00:13:03.210 --> 00:13:05.410
And then once you actually
complete the sequence,

00:13:05.470 --> 00:13:08.830
it will actually perform past that
coalesced key event into the system,

00:13:08.830 --> 00:13:10.800
and the system will act accordingly.

00:13:10.800 --> 00:13:12.630
And that works system-wide.

00:13:12.740 --> 00:13:13.860
It works in applications.

00:13:13.860 --> 00:13:15.880
Obviously, in this case,
it's shown working in the Finder.

00:13:17.690 --> 00:13:21.560
Slow keys, another form of input method
that is essentially going to

00:13:22.380 --> 00:13:28.220
take and give a user with maybe a
coordination issue the ability to

00:13:28.220 --> 00:13:32.240
type and hold a key to indicate
that's the key press they intend.

00:13:32.240 --> 00:13:36.660
So this prevents users who may hit other
keys in the action of trying to press

00:13:36.700 --> 00:13:42.360
a key the ability to really indicate to
the system they mean this particular key.

00:13:44.320 --> 00:13:47.040
We also have mouse keys,
and this is useful in general.

00:13:47.040 --> 00:13:51.200
You can actually navigate,
move the mouse with the keyboard.

00:13:51.200 --> 00:13:55.110
So it also gives a very fine
degree of control as well.

00:13:56.450 --> 00:13:59.300
And then actually something that's
another example of assistive

00:13:59.380 --> 00:14:02.720
technology being really useful
in general is keyboard navigation.

00:14:02.780 --> 00:14:05.420
Carbon and Cocoa now both
support keyboard navigation.

00:14:05.440 --> 00:14:09.100
And this means most applications are
going to support keyboard navigation

00:14:09.190 --> 00:14:12.060
because this functionality has been
integrated into the frameworks.

00:14:12.060 --> 00:14:16.780
There's also ways, and those will end the
sessions later today,

00:14:16.780 --> 00:14:20.730
for Carbon accessibility
and also Cocoa controls.

00:14:21.290 --> 00:14:23.720
They'll talk a little more at length
about how to sort of customize and

00:14:23.720 --> 00:14:27.290
add some additional functionality to
the keyboard navigation that comes

00:14:27.360 --> 00:14:29.030
automatically on your behalf in Jaguar.

00:14:29.040 --> 00:14:31.820
But essentially,
you can fully navigate the user

00:14:31.820 --> 00:14:34.260
interface using the keyboard in Jaguar.

00:14:36.770 --> 00:14:42.620
Now let me segue over to a
different type of development that's

00:14:42.620 --> 00:14:45.510
done relative to accessibility,
and that's assistive technology.

00:14:45.510 --> 00:14:50.930
This is the part that I said
is part of the three parts that

00:14:51.060 --> 00:14:55.080
support and meet accessibility
requirements relative to Section 508.

00:14:55.560 --> 00:15:00.200
And that is software developers who
specialize on creating solutions that

00:15:00.240 --> 00:15:03.430
are going to change or modify the
behavior of the system in order to

00:15:03.430 --> 00:15:05.290
accommodate someone with a disability.

00:15:05.300 --> 00:15:08.860
And, for example,
here I have Niedermeyer Consulting's

00:15:08.860 --> 00:15:11.580
rather excellent Keystrokes,
which is essentially

00:15:12.200 --> 00:15:13.940
an on-screen keyboard.

00:15:13.940 --> 00:15:17.490
So without even having a keyboard,
you can actually use your mouse

00:15:17.490 --> 00:15:19.510
and push and type into the system.

00:15:19.520 --> 00:15:22.910
And this is very useful for someone,
for example, who may use a head mouse or

00:15:22.910 --> 00:15:25.300
some other sort of pointing
device to be able to work.

00:15:25.600 --> 00:15:27.030
type.

00:15:28.620 --> 00:15:31.490
So, the technical definition
of accessibility is this.

00:15:31.540 --> 00:15:35.840
It's essentially taking your system,
your Macintosh,

00:15:35.960 --> 00:15:38.950
and modifying it with hardware
or software to accommodate

00:15:38.950 --> 00:15:41.210
a specific disability.

00:15:41.220 --> 00:15:44.480
And there's a huge industry, well,
actually a small cottage industry

00:15:44.480 --> 00:15:47.460
is actually more to the point,
that creates these solutions.

00:15:47.520 --> 00:15:51.980
And also creates these solutions
to address the significant number

00:15:51.980 --> 00:15:54.660
of different types of disabilities.

00:15:54.960 --> 00:15:58.660
And this is an important community
to understand and interact with

00:15:58.670 --> 00:16:02.360
as you start looking to make
your applications accessible.

00:16:02.400 --> 00:16:05.470
Because these, in many ways,
are going to be the way that someone

00:16:05.590 --> 00:16:09.480
with a disability is going to interact
through assistive technology to actually

00:16:09.480 --> 00:16:11.530
make your application accessible.

00:16:11.540 --> 00:16:17.060
So, let's actually spend a little bit of
time on how this relates to Section 508.

00:16:18.680 --> 00:16:21.180
Section 508,
one of the key things it does,

00:16:21.180 --> 00:16:25.370
in addition to providing sort of a
minimum list of things that applications

00:16:25.470 --> 00:16:29.420
must do to be considered accessible,
there's actually sort of a subtext there,

00:16:29.420 --> 00:16:33.050
which those requirements,
for the most part, are for the enablement

00:16:33.050 --> 00:16:34.720
of assistive technology.

00:16:34.720 --> 00:16:37.460
They are to remove the
roadblocks that prevented the

00:16:37.620 --> 00:16:41.060
assistive technology community,
which provided that finishing

00:16:41.070 --> 00:16:44.740
step to really making platforms
accessible on behalf of application

00:16:44.740 --> 00:16:47.300
developers and hardware manufacturers.

00:16:47.300 --> 00:16:49.830
They removed the roadblocks
because there were many.

00:16:49.860 --> 00:16:53.080
So, for example, one of the first things,
right off the bat,

00:16:53.080 --> 00:16:55.880
I think it's Section A and
Part A in Section 508,

00:16:55.960 --> 00:16:58.800
is applications must
support keyboard navigation.

00:16:58.880 --> 00:17:02.520
The reason that's done is because
keyboard navigation is one of the primary

00:17:02.520 --> 00:17:04.700
ways assistive technology can be used.

00:17:04.720 --> 00:17:07.700
It controls applications and makes
those applications accessible.

00:17:07.700 --> 00:17:11.680
And then also certain low-level things,
such as exposing a lot of

00:17:11.690 --> 00:17:14.700
user interface information,
such as the controls

00:17:14.890 --> 00:17:18.400
that are on the screen,
what type they are, where they are,

00:17:18.400 --> 00:17:20.820
if they're in a particular state,
and also how they work.

00:17:20.920 --> 00:17:22.200
Focus.

00:17:22.210 --> 00:17:23.490
I mean, that's pretty obvious to us.

00:17:23.630 --> 00:17:26.450
We can use our eyes to track
where the insert point is or

00:17:26.450 --> 00:17:29.300
where the mouse pointer is,
but someone with a vision

00:17:29.330 --> 00:17:30.790
disability might not.

00:17:30.960 --> 00:17:33.540
So that information needs to
be programmatically exposed.

00:17:33.560 --> 00:17:34.700
On screen.

00:17:34.700 --> 00:17:35.910
On screen text is another issue.

00:17:35.920 --> 00:17:38.590
Your application freely
puts text up on the screen,

00:17:38.590 --> 00:17:41.750
but that's a very important thing
to make available to assistive

00:17:42.220 --> 00:17:45.190
technology because they may need
to act upon that or communicate

00:17:45.190 --> 00:17:47.200
that text in a different manner.

00:17:47.200 --> 00:17:49.780
And there's a couple others
inside the specification.

00:17:52.200 --> 00:20:00.800
[Transcript missing]

00:20:02.570 --> 00:20:07.700
And then a very interesting form of
assistive technology is a screen reader.

00:20:07.700 --> 00:20:10.110
And it does essentially what it says.

00:20:10.170 --> 00:20:12.740
It takes the textual contents
on the screen and typically

00:20:12.740 --> 00:20:15.510
reads it out loud with some sort
of text-to-speech synthesis.

00:20:15.530 --> 00:20:18.570
In many cases,
it will also work in conjunction with

00:20:18.570 --> 00:20:22.420
a Braille display so that the text on
the screen is going to be displayed

00:20:22.420 --> 00:20:25.680
on an instrument that allows someone
who can read Braille to understand the

00:20:25.690 --> 00:20:29.500
characters that are actually on screen.

00:20:29.550 --> 00:20:33.560
This is probably the most tricky form
of assistive technology right here.

00:20:33.560 --> 00:20:36.670
It's technically very,
very difficult because actually we had a

00:20:36.750 --> 00:20:41.510
bird of a feather just the other day and
the screen reader manufacturer was there.

00:20:41.570 --> 00:20:44.540
And they made an important point,
something I hadn't thought of,

00:20:44.540 --> 00:20:47.650
is like an operating system,
a screen reader has to support all

00:20:47.710 --> 00:20:49.730
the applications on the system.

00:20:49.800 --> 00:20:52.300
And that's a very, very daunting task.

00:20:52.300 --> 00:20:55.000
And this is why we need
to work in conjunction.

00:20:55.090 --> 00:20:59.420
Apple Application developers who are
interested in accessibility and also

00:20:59.640 --> 00:21:02.190
the assistive technology providers,
in this case the screen

00:21:02.190 --> 00:21:04.890
reader developers,
are all going to need to work together

00:21:04.970 --> 00:21:09.370
because this is a very difficult problem
for any one party to solve alone.

00:21:09.600 --> 00:21:13.660
A typical sort of OS-level functionality
that needs to be provided to support

00:21:13.660 --> 00:21:18.070
screen readers is going to be methods
to discover the user interface state.

00:21:18.140 --> 00:21:22.380
Focus, where the mouse is,
where the insert point is,

00:21:22.730 --> 00:21:26.830
and also to be able to
determine exact mouse location.

00:21:30.730 --> 00:21:33.170
Now, an important thing happened
when we moved to Mac OS X,

00:21:33.170 --> 00:21:36.780
and this is one of the reasons
sort of for the delay why Apple is

00:21:36.800 --> 00:21:39.200
just now coming out and saying,
hey, we have this great

00:21:39.200 --> 00:21:41.470
accessibility message in Jaguar.

00:21:41.480 --> 00:21:47.760
It's because assistive technology
on the Macintosh used essentially

00:21:47.830 --> 00:21:51.200
methods that don't work on Mac OS X.

00:21:51.200 --> 00:21:54.880
The old extension, install an extension,
trap and patch something,

00:21:54.940 --> 00:21:58.050
insert some code at some random
specific place in the operating

00:21:58.150 --> 00:22:00.000
system to change the behavior.

00:22:00.690 --> 00:22:01.940
So this was typical.

00:22:01.940 --> 00:22:05.530
Most assistive technology that
was developed on the Macintosh

00:22:05.690 --> 00:22:07.480
essentially worked this way.

00:22:07.480 --> 00:22:09.460
Basically,
you installed a set of extensions.

00:22:09.460 --> 00:22:12.600
Those extensions dramatically changed
the behavior of the operating system,

00:22:12.750 --> 00:22:14.910
but they did it without the
application's knowledge.

00:22:14.920 --> 00:22:17.740
This is why you,
if you're an application developer,

00:22:17.780 --> 00:22:20.820
in many cases had no idea that
someone might be using a screen

00:22:20.820 --> 00:22:24.650
reader to interact with your software,
because it wasn't something that

00:22:24.650 --> 00:22:26.570
you ever really had to develop for.

00:22:26.580 --> 00:22:30.580
But when Mac OS moved,
when Mac OS X moved,

00:22:30.600 --> 00:22:32.140
when Mac OS X came out,
we moved to a protected memory model.

00:22:32.160 --> 00:22:35.890
So this means one application
has one memory partition,

00:22:36.000 --> 00:22:38.640
and it cannot affect
another running application.

00:22:38.750 --> 00:22:42.330
So this technique of creating
assistive technology completely

00:22:42.560 --> 00:22:44.180
and fundamentally broke.

00:22:45.620 --> 00:22:48.720
But also has some benefits because
this technique was also very,

00:22:48.720 --> 00:22:49.840
very fragile.

00:22:49.860 --> 00:22:53.270
A lot of you may not have been aware that
as we all like to revise our products,

00:22:53.360 --> 00:22:57.510
in many cases as we made a new version,
particularly if we went to a major

00:22:57.510 --> 00:23:00.980
new version of an application,
we would simultaneously break

00:23:01.050 --> 00:23:05.240
assistive technology that was making
assumptions about where they could

00:23:05.550 --> 00:23:08.890
patch in and modify things to get
the hooks they needed to make an app

00:23:09.030 --> 00:23:13.230
which was fundamentally inaccessible
and not designed for accessibility

00:23:13.230 --> 00:23:14.610
under Mac OS 9 fully accessible.

00:23:15.390 --> 00:23:17.140
So what do we want to try to do on 10?

00:23:17.190 --> 00:23:19.600
The end goal of what we're
going to be talking about here,

00:23:19.700 --> 00:23:22.840
essentially the Accessibility APIs,
is to allow an assistive

00:23:22.910 --> 00:23:25.700
technology application,
which again is in many cases going

00:23:25.700 --> 00:23:30.080
to be finishing the accessibility
picture on behalf of your application.

00:23:31.310 --> 00:23:35.020
It needs to be able to run just
like any other app on the system.

00:23:35.020 --> 00:23:40.000
No different requirements,
no special privileges.

00:23:40.000 --> 00:23:42.190
It's just going to run
like another application.

00:23:42.190 --> 00:23:48.850
It's going to have to do things in
conjunction with the operating system

00:23:49.420 --> 00:23:56.410
to be able to reach across those memory
partitions and do things like parse

00:23:56.410 --> 00:23:56.410
UI state and do things like that.

00:23:57.030 --> 00:24:01.590
So these pathways are
available in JAGUAR.

00:24:01.710 --> 00:24:04.010
So assistive technology
applications have several ways

00:24:04.010 --> 00:24:06.050
to now interact with the system.

00:24:06.270 --> 00:24:09.400
They vary from I/O Kit,
which is where you do device driver

00:24:09.410 --> 00:24:12.370
development and really kind of
touch the hardware in Mac OS X.

00:24:12.570 --> 00:24:16.310
There's also some API in Quartz,
which is the windowing system

00:24:16.410 --> 00:24:18.520
and also the drawing system.

00:24:18.520 --> 00:24:23.480
The frameworks have been modified
in JAGUAR to support accessibility.

00:24:23.480 --> 00:24:28.240
And the assistive technology application,
and to a lesser extent

00:24:28.270 --> 00:24:31.420
your own application,
are going to be clients or

00:24:31.470 --> 00:24:36.480
targets to the accessibility
APIs that are new in JAGUAR.

00:24:37.450 --> 00:24:42.860
So let's look at a couple different
techniques where assistive technology

00:24:42.860 --> 00:24:45.720
vendors can actually approach the system,
and I'll go into a little more detail.

00:24:45.720 --> 00:24:48.340
At the highest level,
a lot of assistive technology,

00:24:48.340 --> 00:24:50.830
particularly input methods,
are going to be able to rely

00:24:50.830 --> 00:24:53.130
on the keyboard navigation
that's part of Jaguar.

00:24:53.140 --> 00:24:56.730
They can essentially generate macros of
keystrokes and put them into the system,

00:24:56.730 --> 00:25:00.790
and the UI is going to respond to them
as if it was driven from a keyboard.

00:25:02.140 --> 00:25:06.120
One level below that is going to be
some APIs such as CG Remote Operation,

00:25:06.130 --> 00:25:08.580
which essentially allows
you to synthesize an event

00:25:08.580 --> 00:25:11.860
and pop it into the system,
and it'll go through the

00:25:11.860 --> 00:25:12.940
regular event queues.

00:25:13.020 --> 00:25:15.920
So that gives you this sort
of synthesis aspect that a lot

00:25:15.920 --> 00:25:17.740
of assistive technology needs.

00:25:17.780 --> 00:25:20.470
Then also,
one thing that's important is if you are

00:25:20.470 --> 00:25:24.900
an assistive technology developer and
you're bringing product over to Mac OS X,

00:25:24.920 --> 00:25:28.990
I think it's important for you to look at
the USB human interface device classes,

00:25:29.070 --> 00:25:32.040
because we find a lot of
assistive technology vendors are,

00:25:32.240 --> 00:25:35.080
they're bringing USB peripherals
over and they do a custom

00:25:35.080 --> 00:25:38.640
device implementation under USB,
and that requires a custom driver

00:25:38.640 --> 00:25:40.820
to be plugged in to the Macintosh.

00:25:40.920 --> 00:25:45.600
There's an interesting sort of
huge specification that's part

00:25:45.600 --> 00:25:47.820
of the USB spec called HID.

00:25:47.880 --> 00:25:52.400
HID has several hundred different
categories of input devices.

00:25:52.400 --> 00:25:57.130
If you rely on HID,
it makes it much easier for applications,

00:25:57.130 --> 00:26:01.620
even your own companion assistive
technology application that may

00:26:01.620 --> 00:26:05.060
support the actual input device,
easier to write.

00:26:05.150 --> 00:26:08.540
The operating system can
offer more functionality.

00:26:08.540 --> 00:26:11.580
Things are much more discreet than
if you do a custom implementation.

00:26:12.460 --> 00:26:15.540
And then at the lowest level,
if you absolutely have to,

00:26:15.570 --> 00:26:18.460
you can always develop a
custom driver for your device.

00:26:18.460 --> 00:26:21.700
We generally, if you're going to do that,
please talk to us because in many

00:26:21.700 --> 00:26:24.310
cases there's ways to accomplish
just that in a different way that

00:26:24.400 --> 00:26:25.960
you might not have thought of.

00:26:26.140 --> 00:26:29.050
It's very common for assistive
technology developers to immediately

00:26:29.050 --> 00:26:31.270
jump at the IOCit level and
try to do a device driver,

00:26:31.270 --> 00:26:34.220
and in many cases that's sort of
the wrong way to approach things.

00:26:37.700 --> 00:26:40.930
As you notice,
the sort of thread between what

00:26:41.020 --> 00:26:45.170
your application needs to provide,
vis-a-vis Section 508,

00:26:45.370 --> 00:26:48.960
and what assistive technology needs
to be able to drive your applications,

00:26:48.960 --> 00:26:52.550
is mainly relating to discovering
and understanding and driving

00:26:52.550 --> 00:26:54.550
the user interface on the system.

00:26:54.560 --> 00:26:57.430
And this is where we spent
a lot of work in Jaguar,

00:26:57.470 --> 00:27:00.420
is creating the infrastructure
to support this.

00:27:00.520 --> 00:27:03.140
For the first time,
we have API-level support

00:27:03.140 --> 00:27:06.730
for discovery of UI elements
inside the operating system.

00:27:07.500 --> 00:27:10.890
And this is very, very important,
because this moves us away from the model

00:27:10.890 --> 00:27:14.460
where assistive technology vendors are
going to have to rely purely on their own

00:27:14.460 --> 00:27:16.640
cleverness to make these solutions work.

00:27:16.700 --> 00:27:20.050
And essentially,
it just performs a function where I can

00:27:20.150 --> 00:27:24.610
have an assistive technology application
running in one memory partition,

00:27:24.660 --> 00:27:26.970
and it can have a dialogue
with the framework that's

00:27:26.970 --> 00:27:30.320
supporting another application,
and figure out what the status

00:27:30.570 --> 00:27:33.680
of the user interface is,
where controls are,

00:27:33.680 --> 00:27:36.930
and it can even send messages
to control that user interface.

00:27:37.500 --> 00:27:42.120
So this gives assistive technology
the pipeline to control applications.

00:27:42.120 --> 00:27:46.070
And the important point here
is this really provides a

00:27:46.180 --> 00:27:50.380
common ground for Apple,
the application developer,

00:27:50.380 --> 00:27:55.050
and the assistive technology developer
to come together and work together.

00:27:55.060 --> 00:27:57.720
Because obviously,
what we're showing here is the first

00:27:57.830 --> 00:28:00.220
implementation of the accessibility APIs.

00:28:00.220 --> 00:28:02.430
We happen to think it's pretty good,
but I'm sure there's

00:28:02.430 --> 00:28:03.620
areas where we've missed.

00:28:03.660 --> 00:28:06.940
And that's where we're going to rely
on response from this community.

00:28:07.300 --> 00:28:08.570
And that's where we're going to rely
on the accessibility API to tell us

00:28:08.570 --> 00:28:09.430
where we need to iterate and improve.

00:28:09.440 --> 00:28:12.780
And then once we deliver
that functionality in API,

00:28:12.780 --> 00:28:15.790
that becomes sort of the
de facto way to do it.

00:28:15.980 --> 00:28:20.010
So it's very important that we all
work together to continue to involve

00:28:20.010 --> 00:28:22.140
accessibility on the platform.

00:28:22.140 --> 00:28:25.170
Because if we all cooperate,
it's going to make the whole

00:28:25.230 --> 00:28:27.870
act of making all users
able to use your software,

00:28:28.040 --> 00:28:32.480
our hardware, our operating system,
and your peripherals that much easier.

00:28:32.480 --> 00:28:35.840
So what I'd like to do is
invite Mike Ingber on stage.

00:28:37.200 --> 00:28:40.650
And he's going to talk more
directly to the engineering

00:28:40.650 --> 00:28:43.120
aspects of the accessibility APIs.

00:28:43.140 --> 00:28:46.140
Thank you.

00:28:46.140 --> 00:28:47.510
Thank you.

00:28:50.890 --> 00:28:53.060
My name is Mike Engber,
and I'm a software engineer

00:28:53.060 --> 00:28:53.880
in the Cocoa Group.

00:28:54.140 --> 00:28:57.360
And for the next 20 minutes or so,
I'm going to talk to you about

00:28:57.360 --> 00:29:01.100
the new Accessibility APIs that
we've introduced in Jaguar.

00:29:04.240 --> 00:29:08.430
Accessibility APIs allow one
application to examine the user

00:29:08.430 --> 00:29:10.740
interface of another application.

00:29:10.740 --> 00:29:14.360
The clients of these APIs are
intended to be assistive applications.

00:29:14.360 --> 00:29:17.580
For example,
a screen reader could use these APIs to

00:29:17.790 --> 00:29:22.410
discover what windows are in some other
application and then dig around in the

00:29:22.410 --> 00:29:26.800
window and find out there's a button,
discover the text in the button,

00:29:26.800 --> 00:29:31.100
present that text to the user,
and then finally press the button.

00:29:31.100 --> 00:29:34.930
There's a whole other half to this story,
and that's what the target applications

00:29:34.940 --> 00:29:37.120
have to do to allow this to work.

00:29:38.700 --> 00:29:42.550
This session is going to focus on
the Accessibility APIs themselves.

00:29:42.610 --> 00:29:45.400
The two sessions immediately
following it are going to cover

00:29:45.400 --> 00:29:47.220
what target applications have to do.

00:29:47.420 --> 00:29:50.840
The next session, Session 209,
is going to talk about what

00:29:50.920 --> 00:29:52.160
Carbon apps have to do.

00:29:52.470 --> 00:29:54.820
And the session after that is
going to cover Cocoa Controls.

00:29:54.930 --> 00:30:01.630
And then about a third of that
talk is going to cover specifically

00:30:01.680 --> 00:30:03.870
what Cocoa apps need to do to
work with the Accessibility APIs.

00:30:06.680 --> 00:30:09.840
So I'm going to start out by
mentioning the goals behind

00:30:09.840 --> 00:30:12.240
the design of these APIs.

00:30:12.270 --> 00:30:15.340
The first thing we wanted to do,
as has been mentioned before,

00:30:15.340 --> 00:30:18.540
is we wanted to allow
applications to examine the user

00:30:18.540 --> 00:30:21.190
interface of other applications.

00:30:21.590 --> 00:30:24.110
We also wanted them to be
able to interact with the user

00:30:24.520 --> 00:30:27.830
interface of other applications,
press buttons, move sliders,

00:30:27.830 --> 00:30:29.000
things like that.

00:30:29.050 --> 00:30:31.650
And then finally,
we wanted them to be able to be notified

00:30:31.650 --> 00:30:33.960
of changes in their target applications.

00:30:34.020 --> 00:30:38.480
If a window goes away or a
value of some control changes,

00:30:38.520 --> 00:30:43.130
the assistive app wants to know
about it and behave appropriately.

00:30:44.880 --> 00:30:49.200
A second goal is that we wanted a
single set of APIs to work against

00:30:49.370 --> 00:30:53.360
both Cocoa and Carbon applications,
so that you basically don't

00:30:53.420 --> 00:30:55.230
have to do twice the work.

00:30:56.960 --> 00:31:00.910
The third goal was to make sure that
these APIs worked out of the box with

00:31:00.910 --> 00:31:03.700
the standard user interface elements.

00:31:03.770 --> 00:31:07.130
And this means that most existing
applications already have

00:31:07.280 --> 00:31:09.690
some degree of accessibility.

00:31:10.090 --> 00:31:14.330
and it also means that developers
have a minimal burden in

00:31:14.330 --> 00:31:16.660
implementing or making their apps

00:31:18.200 --> 00:31:20.830
And the final goal was to make
it possible for developers who

00:31:20.830 --> 00:31:26.480
have non-standard user interface
features to make them accessible.

00:31:29.770 --> 00:31:34.010
So I'm going to bring Kevin Aitken
of the Speech Group on stage,

00:31:34.040 --> 00:31:36.680
and he's going to demonstrate
what the Speech Group has been

00:31:36.680 --> 00:31:39.640
able to do using these APIs.

00:31:47.370 --> 00:31:48.300
Can you hear me?

00:31:48.300 --> 00:31:49.300
Oh, boy.

00:31:49.320 --> 00:31:51.060
Okay, sounds great.

00:31:51.060 --> 00:31:53.510
Okay,
I think I need demo machine number one.

00:31:53.600 --> 00:31:55.170
Demo one.

00:32:00.900 --> 00:32:03.800
I'm from the Speech Group and the
Speech Group has been working hard on

00:32:03.800 --> 00:32:07.150
a number of new features for Jaguar.

00:32:07.150 --> 00:32:09.480
I'm going to show two
of them in this session.

00:32:09.480 --> 00:32:13.030
The reason I'm going to be showing
just two is because we're using

00:32:13.030 --> 00:32:16.310
Accessibility API to implement these.

00:32:16.340 --> 00:32:20.330
We're really excited about this
because this allows us to extend what

00:32:20.330 --> 00:32:22.890
we're able to provide out of the box.

00:32:22.900 --> 00:32:26.130
The two features,
the first one is an enhancement

00:32:26.130 --> 00:32:28.280
to our text-to-speech system.

00:32:28.280 --> 00:32:32.400
It allows us to speak the
on-screen text that the user sees.

00:32:32.400 --> 00:32:35.900
And the other is an enhancement to
our speakable items application.

00:32:35.900 --> 00:32:38.900
This is our built-in speech
recognition command and control system.

00:32:38.900 --> 00:32:42.380
And now you'll be able to
speak menu items and the

00:32:42.380 --> 00:32:44.890
items inside the front window.

00:32:45.080 --> 00:32:52.160
So let me go to the speech
preference panel here.

00:32:52.160 --> 00:32:52.160
You may have seen this in the keynote,
but I'll just...

00:32:52.900 --> 00:32:54.660
So I'm going to run it really quick.

00:32:54.660 --> 00:32:55.660
Speaker 2: Speak recognition.

00:32:55.660 --> 00:32:58.020
As I move around the
screen it... Speaker 2:

00:32:58.020 --> 00:32:58.900
Speak text under the mouse.

00:32:58.900 --> 00:33:04.590
It speaks to visible text and we're
all using accessibility API here

00:33:04.600 --> 00:33:06.670
so as I go down through the doc.

00:33:06.680 --> 00:33:07.670
Speaker 2: System preferences.

00:33:07.690 --> 00:33:10.570
What we're doing is we're
basically making two calls here.

00:33:10.580 --> 00:33:16.890
We're asking accessibility API what
is the object under the mouse at

00:33:16.890 --> 00:33:21.430
this moment and then given that
object we ask what is the title.

00:33:21.470 --> 00:33:24.260
In this case it comes back as
system preferences and that's

00:33:24.260 --> 00:33:27.070
what we synthesize to the speaker.

00:33:27.610 --> 00:33:30.740
So we have access to
virtually all of the system.

00:33:30.740 --> 00:33:31.390
Find it.

00:33:31.400 --> 00:33:34.280
We can go up here to the-- Go.

00:33:34.500 --> 00:33:39.900
[Transcript missing]

00:33:40.270 --> 00:33:42.440
So let me go back to the
speech preference panel.

00:33:42.440 --> 00:33:44.200
I'm going to turn that off.

00:33:44.200 --> 00:33:46.570
And I'm going to switch gears and
go to the speech recognition to

00:33:46.570 --> 00:33:48.960
show what we're doing with that.

00:33:48.960 --> 00:33:51.530
That uses a little bit
different method because,

00:33:51.530 --> 00:33:54.640
you know, the mouse really isn't
involved in that case.

00:33:54.640 --> 00:33:58.460
And so what we want to do is come
up from the bottom and explore what

00:33:58.540 --> 00:34:00.960
the application is providing to us.

00:34:00.960 --> 00:34:03.430
So let me turn that on.

00:34:03.980 --> 00:34:06.700
And instead of actually speak to it,
I'm just going to,

00:34:06.700 --> 00:34:11.120
I think it may be more effective that you
can see over here in the speech commands,

00:34:11.120 --> 00:34:14.400
you may not be able to read all
the commands that are in there.

00:34:14.400 --> 00:34:17.800
But you'll see that as
I change the user interface,

00:34:17.800 --> 00:34:22.340
we get notification and we update
that list of spoke commands that

00:34:22.340 --> 00:34:24.520
are possible at that moment.

00:34:24.520 --> 00:34:28.120
So we're able to via the
accessibility API keep up with the

00:34:28.120 --> 00:34:31.780
user whether they're using a mouse,
whether they're using some

00:34:31.780 --> 00:34:33.410
other kind of input device.

00:34:33.420 --> 00:34:36.000
And so I can switch to
another application.

00:34:36.000 --> 00:34:39.650
We get notification that
the application has changed.

00:34:39.650 --> 00:34:43.110
We can go up to the window
here and as it appears,

00:34:43.110 --> 00:34:45.270
we then get notification.

00:34:45.270 --> 00:34:46.890
We get a reference.

00:34:46.890 --> 00:34:51.410
We can easily find out that this
is the front window and then begin

00:34:51.420 --> 00:34:55.880
exploring the full contents of that
window and make decisions about

00:34:55.880 --> 00:34:58.180
what we want to provide to the user.

00:34:58.200 --> 00:34:59.740
So that's a real quick demo of that.

00:34:59.740 --> 00:35:00.280
We have a speech session.

00:35:00.280 --> 00:35:01.260
We have a speech session
tomorrow afternoon.

00:35:01.270 --> 00:35:04.790
We'd love you to come attend
and see how you can use more of

00:35:04.790 --> 00:35:07.040
a speech in your application.

00:35:07.040 --> 00:35:10.560
And I think the time of the session
will be at the end of this presentation.

00:35:10.560 --> 00:35:12.560
So back to you, Mike.

00:35:12.560 --> 00:35:12.560
Okay.

00:35:22.100 --> 00:35:28.790
Bring the slides back on.

00:35:29.390 --> 00:35:34.780
Okay, so the first problem that has
to be solved in implementing the

00:35:34.780 --> 00:35:39.470
Accessibility APIs is how we're
gonna represent the user interface.

00:35:39.840 --> 00:35:43.550
This diagram is an abstract
representation of an assistive app

00:35:44.020 --> 00:35:47.060
trying to examine the user interface
of two target applications,

00:35:47.060 --> 00:35:49.940
one Cocoa application,
one Carbon application.

00:35:49.940 --> 00:35:54.190
And the question marks are meant to
indicate that it's not exactly obvious

00:35:54.200 --> 00:35:58.590
what kind of information is going to be
passed back from the target application

00:35:58.700 --> 00:36:01.390
to represent its user interface.

00:36:03.400 --> 00:36:06.800
Each of these applications has a
natural representation of its user

00:36:06.860 --> 00:36:09.430
interface in terms of its own framework.

00:36:09.510 --> 00:36:12.970
Cocoa apps have NSWindows and NSControls.

00:36:13.440 --> 00:36:16.330
Carbon apps have
ControlRefs and WindowRefs.

00:36:16.420 --> 00:36:19.600
But there are problems trying to
use these natural representations.

00:36:19.620 --> 00:36:23.620
One problem is that they're
specific to the framework,

00:36:23.620 --> 00:36:27.920
which means the assistive application
has to deal with all the complexity

00:36:27.920 --> 00:36:32.140
of Cocoa applications and all the
complexity of Carbon applications.

00:36:33.530 --> 00:36:36.970
Another problem is that the
natural representations contain

00:36:36.970 --> 00:36:38.440
a lot of extraneous detail.

00:36:38.440 --> 00:36:43.740
If you consider just the simple button
in a window in a Cocoa application,

00:36:43.740 --> 00:36:47.260
what you actually have is a
button cell inside a control,

00:36:47.260 --> 00:36:52.020
inside the content view of the window,
inside another view,

00:36:52.020 --> 00:36:54.090
and finally you get to the NSWindow.

00:36:54.100 --> 00:36:57.250
And the only thing the assistive
app is really interested in is

00:36:57.250 --> 00:36:59.430
the fact that there's a window
and there's a button in it.

00:37:03.710 --> 00:37:07.510
So this next slide shows
our solution to the problem.

00:37:07.760 --> 00:37:11.890
The boxes in green are the new layers
of code that were added in Jaguar.

00:37:11.900 --> 00:37:15.290
The box in front of the assistive
app are the Accessibility APIs,

00:37:15.290 --> 00:37:16.720
which we're discussing.

00:37:16.900 --> 00:37:21.100
And the boxes in front of the target
applications are the framework-specific

00:37:21.160 --> 00:37:25.120
protocols that allow them to
work with the Accessibility APIs.

00:37:25.240 --> 00:37:28.700
Now you'll notice that the question
marks have been replaced by the

00:37:28.700 --> 00:37:31.170
phrase or the term UI element,
which is short for

00:37:31.310 --> 00:37:33.740
user interface element.

00:37:33.920 --> 00:37:37.890
and our solution, or our representation,
is to use a generic user

00:37:37.890 --> 00:37:40.980
interface element object,
or UI element for short.

00:37:40.980 --> 00:37:43.010
And everything is a UI element.

00:37:43.140 --> 00:37:45.640
A window is a UI element,
a menu is a UI element,

00:37:45.640 --> 00:37:48.630
a button is a UI element,
and there's even a special

00:37:48.640 --> 00:37:53.540
UI element that represents the top
level or the whole application.

00:37:59.520 --> 00:38:02.130
So now that we know what
the representation is,

00:38:02.170 --> 00:38:06.370
basically a hierarchy of UI elements,
we're going to talk about the details

00:38:06.430 --> 00:38:08.290
of what UI elements have to offer.

00:38:08.300 --> 00:38:10.350
First, there's attributes.

00:38:10.440 --> 00:38:13.470
And attributes provide
information about a UI element.

00:38:13.480 --> 00:38:19.600
There's attributes to return its
title or its value or its children,

00:38:19.600 --> 00:38:22.610
which would be the basis for
walking the whole hierarchy.

00:38:22.620 --> 00:38:25.850
And UI elements also support actions.

00:38:25.860 --> 00:38:29.440
And this is a way for you to
interact with the application.

00:38:29.520 --> 00:38:32.060
For instance, a button UI element would
have a press action.

00:38:32.060 --> 00:38:34.840
A slider might have an
increment or decrement action.

00:38:39.750 --> 00:38:42.740
Now we're going to spend a couple
of slides talking about attributes.

00:38:42.740 --> 00:38:45.630
So as I said before,
attributes are designed to

00:38:45.760 --> 00:38:48.750
provide information about
a user interface element.

00:38:48.750 --> 00:38:53.340
And there's basically four
operations that the Accessibility

00:38:53.750 --> 00:38:56.020
APIs allow with attributes.

00:38:56.420 --> 00:38:59.180
First, you can get a list of a
UI element's attributes.

00:38:59.180 --> 00:39:02.510
Second, you can get the value
of a specific attribute.

00:39:02.510 --> 00:39:05.550
Third, you can check if that
attribute can be set.

00:39:05.560 --> 00:39:08.910
And finally,
you can set the value of that attribute.

00:39:13.970 --> 00:39:16.280
Now one special attribute
is the role attribute,

00:39:16.280 --> 00:39:19.750
which basically describes
the class or the kind of

00:39:19.750 --> 00:39:21.290
UI element you're dealing with.

00:39:21.380 --> 00:39:24.040
So there's going to be
roles for checkboxes,

00:39:24.140 --> 00:39:26.380
buttons, menus, things like that.

00:39:26.460 --> 00:39:31.090
Now this attribute is really
for developers to use.

00:39:31.160 --> 00:39:32.660
It's not to be presented to the user.

00:39:32.720 --> 00:39:36.140
It's something you could test off of
and make a decision in the logic of

00:39:36.150 --> 00:39:38.350
your program based on the value of it.

00:39:39.190 --> 00:39:43.630
If you want to present to the user what
kind of UI element you're dealing with,

00:39:43.730 --> 00:39:45.120
then there's the role description.

00:39:45.120 --> 00:39:49.020
And that's a localized string
that you can present to the user.

00:39:50.420 --> 00:39:53.100
Another attribute that's
commonly used is the title.

00:39:53.100 --> 00:39:56.250
For instance, a button,
the text in a button is the

00:39:56.470 --> 00:39:57.820
value of its title attribute.

00:39:57.820 --> 00:40:02.370
If it's a graphical button like an arrow,
its title might be down.

00:40:07.880 --> 00:40:10.840
Another common attribute
is the Value attribute.

00:40:10.890 --> 00:40:14.800
A slider's value would be a number.

00:40:14.840 --> 00:40:18.030
The value of a text
field would be a string.

00:40:18.820 --> 00:40:22.630
And then there's two more attributes that
relate to the hierarchy of UI elements.

00:40:22.750 --> 00:40:25.570
The parent attribute is your
parent in the hierarchy,

00:40:25.580 --> 00:40:30.130
and the children attribute is,
if it's present,

00:40:30.360 --> 00:40:33.540
reveals the child UI elements.

00:40:42.230 --> 00:40:45.100
So the other thing that
UI elements support are actions.

00:40:45.100 --> 00:40:48.480
And you should think of actions
as very simple operations.

00:40:48.800 --> 00:40:52.410
Basically, about what you could do with
a single click of a mouse.

00:40:52.410 --> 00:40:55.880
Press a button, pick a menu item,
things like that.

00:40:56.110 --> 00:41:00.250
And there's three basic operations that
are allowed with respect to actions.

00:41:00.250 --> 00:41:03.390
You can get a list of the
actions a UI element supports.

00:41:03.390 --> 00:41:06.190
You can get the description
of a specific action,

00:41:06.190 --> 00:41:08.620
if you want to present that to the user.

00:41:08.620 --> 00:41:11.180
And finally, you can perform that action.

00:41:15.620 --> 00:41:17.210
A couple of points to make about actions.

00:41:17.320 --> 00:41:19.480
One, they're very generic.

00:41:19.480 --> 00:41:21.970
They're going to be
things like pick or press.

00:41:22.430 --> 00:41:26.170
There's no instance-specific information.

00:41:26.240 --> 00:41:28.700
If you have a print
button or a cancel button,

00:41:28.700 --> 00:41:31.400
its action is still going to be press.

00:41:32.970 --> 00:41:36.440
The Assistive App doesn't really know
anything apart from the fact that

00:41:36.560 --> 00:41:38.660
it's a button and it can be pressed.

00:41:38.980 --> 00:41:42.240
It does have the option of presenting
the title of the button to the user,

00:41:42.250 --> 00:41:44.640
and if the title says "Print," then
the user is going to have an idea

00:41:44.640 --> 00:41:46.310
of what this button's going to do.

00:41:46.550 --> 00:41:48.900
But apart from that,
there's no attempt to make

00:41:48.900 --> 00:41:52.220
this information available
to the Assistive App.

00:41:53.740 --> 00:41:57.640
And another point to make is that
actions aren't the only way to

00:41:57.640 --> 00:42:00.500
interact with the target application.

00:42:00.580 --> 00:42:02.110
So, for instance,
you might be surprised to

00:42:02.240 --> 00:42:06.790
discover there's no action to
select the text in a text field.

00:42:06.930 --> 00:42:11.710
Instead, what you do is set the value of
the selected text range attribute.

00:42:19.280 --> 00:42:22.700
So now we're going to talk about
a couple of special UI elements.

00:42:22.750 --> 00:42:28.150
And the first is the application,
or the top-level user interface element.

00:42:28.500 --> 00:42:31.040
This is basically going to be
your starting point into the

00:42:31.040 --> 00:42:35.190
hierarchy if your assistive app
sort of works from the top down.

00:42:38.630 --> 00:42:41.950
Your children will be the
windows in the application and

00:42:41.950 --> 00:42:45.400
the menu bar in the application.

00:42:45.400 --> 00:42:47.800
There's a special attribute to return
the menu bar so you don't have to dig

00:42:47.810 --> 00:42:49.550
through the window list to find it.

00:42:49.550 --> 00:42:53.970
And there's another attribute
to return the list of windows.

00:42:54.020 --> 00:42:57.270
There's also an attribute to
return the UI element that

00:42:57.270 --> 00:42:59.960
currently has the keyboard focus.

00:42:59.960 --> 00:43:03.810
And there's an attribute to return
whether the application is active.

00:43:03.830 --> 00:43:06.930
There's also attributes
to return the main window,

00:43:06.930 --> 00:43:08.910
the key window,
and there's a whole variety of other

00:43:08.910 --> 00:43:10.460
attributes that I'm not going to go into.

00:43:16.400 --> 00:43:19.490
There are also two special
calls in the API that only work

00:43:19.490 --> 00:43:21.200
on application UI elements.

00:43:21.200 --> 00:43:23.130
And one of them is for hit testing.

00:43:23.280 --> 00:43:28.740
If you wish to discover what
UI element is at a specific position,

00:43:28.800 --> 00:43:36.230
you can use the application UI element,
pass it the coordinates,

00:43:36.230 --> 00:43:36.230
and you'll get back the
UI element at that position.

00:43:36.240 --> 00:43:38.970
and there's also a special
call in case you wish to post

00:43:39.070 --> 00:43:40.640
keystrokes to an application.

00:43:40.640 --> 00:43:45.000
So if your assistive app needs to
emulate a keyboard for some reason,

00:43:45.000 --> 00:43:47.490
you can use this API to send
keystrokes to an application.

00:43:52.140 --> 00:43:55.920
A similar and related concept
is the system-wide U-Element.

00:43:55.950 --> 00:44:01.080
It's kind of an application U-Element,
but it represents all applications.

00:44:01.080 --> 00:44:04.980
But depending on what your
assistive app is trying to do,

00:44:04.980 --> 00:44:08.810
it might be convenient to discover
what U-Element is under the mouse,

00:44:08.920 --> 00:44:11.510
regardless of what application it is.

00:44:11.610 --> 00:44:15.830
And so if you do hit testing
on the system-wide U-Element,

00:44:15.830 --> 00:44:19.820
you're going to get back some U-Element,
and you don't know what

00:44:19.920 --> 00:44:21.880
application it's going to be in.

00:44:23.910 --> 00:44:27.220
And for instance,
that's what the reading the button,

00:44:27.220 --> 00:44:30.510
this speech demo was using.

00:44:31.030 --> 00:44:33.600
The system-wide UI element also
supports posting keystrokes,

00:44:33.750 --> 00:44:35.900
and they go to the active application.

00:44:36.100 --> 00:44:40.140
And there's also an attribute to
return the current keyboard focus,

00:44:40.260 --> 00:44:43.690
again, regardless of the application.

00:44:50.090 --> 00:44:53.050
The last section of the APIs has
to deal with notifications.

00:44:53.160 --> 00:44:57.690
Assistive apps want to be notified about
changes in their target application.

00:44:57.820 --> 00:45:00.340
There's a series of notifications
having to do with Windows,

00:45:00.460 --> 00:45:03.900
when they're created, when they're moved,
they're miniaturized.

00:45:04.030 --> 00:45:10.250
There's also a series of notifications
having to deal with changes in

00:45:10.320 --> 00:45:13.670
the state of the application,
if it's hidden, if it's activated,

00:45:13.670 --> 00:45:13.670
deactivated, things like that.

00:45:14.510 --> 00:45:18.050
There's also a notification that'll tell
you if a specific UI element has been

00:45:18.050 --> 00:45:22.200
destroyed or if its value has changed.

00:45:24.880 --> 00:45:28.370
When you register for a notification,
you specify the name of the

00:45:28.370 --> 00:45:30.970
notification you're interested in,
and then you have a choice.

00:45:31.170 --> 00:45:34.540
You can either specify a specific
UI element you want to observe,

00:45:34.630 --> 00:45:37.060
or you can pass the
application UI element,

00:45:37.150 --> 00:45:40.960
meaning any notification of this
type that happens in the application,

00:45:41.020 --> 00:45:42.910
I want to hear about it.

00:45:48.410 --> 00:45:53.850
So we've covered the basic concepts
behind the Accessibility APIs,

00:45:53.860 --> 00:45:57.860
and I thought I'd like to sort of
wrap that part up by pointing out

00:45:57.860 --> 00:46:01.480
a few things the APIs do not do.

00:46:02.790 --> 00:46:07.660
So one of them is the Accessibility
APIs do not really address the

00:46:07.800 --> 00:46:09.800
same problems that scripting does.

00:46:10.840 --> 00:46:14.560
If you think about just the relatively
simple example of printing a document,

00:46:14.660 --> 00:46:16.390
in Apple Script,
you can do that with a single line.

00:46:16.400 --> 00:46:21.040
You tell the application to
print the print file whatever,

00:46:21.080 --> 00:46:22.300
and it prints it.

00:46:22.370 --> 00:46:24.670
If you try to do this with
the Accessibility APIs,

00:46:25.060 --> 00:46:28.300
first you get to dig through the
menu bar and find the file menu.

00:46:28.370 --> 00:46:31.530
Then you find the open item,
and you get to pick it.

00:46:31.680 --> 00:46:35.570
Then you have to use the standard
file dialogue and navigate to your

00:46:35.700 --> 00:46:38.120
file and eventually open it up.

00:46:38.740 --> 00:46:40.740
Then you get to dig back
through the menu bar,

00:46:40.870 --> 00:46:43.930
find the print menu item, and so on.

00:46:43.940 --> 00:46:45.660
You get to deal with the print dialog.

00:46:45.810 --> 00:46:47.520
So it's very tedious.

00:46:47.740 --> 00:46:52.540
So if what you're trying to
do is drive the application,

00:46:52.560 --> 00:46:54.850
AppleScript is really
better suited to the task.

00:46:54.870 --> 00:46:58.110
But if what you're trying to
do is help a user with the user

00:46:58.260 --> 00:47:03.970
interface of the application,
that's what accessibility does.

00:47:05.510 --> 00:47:09.960
Another thing you might notice as you
use these APIs is that there's things

00:47:10.040 --> 00:47:11.180
we could have done that we didn't.

00:47:11.300 --> 00:47:15.180
For instance, the title of a window,
that attribute could be settable,

00:47:15.210 --> 00:47:16.780
but it's not.

00:47:16.860 --> 00:47:21.300
Or we could have allowed you to set
the value of a radio button directly.

00:47:21.300 --> 00:47:24.690
Instead,
all you can do is press the radio button.

00:47:26.130 --> 00:47:28.830
So again,
bear in mind that these APIs are designed

00:47:28.830 --> 00:47:32.950
to allow you to do what a user could do
if they were driving the user interface.

00:47:32.950 --> 00:47:36.570
They're not designed to allow you
to program this other application.

00:47:38.430 --> 00:47:41.210
And in the case of setting
the value of a radio button,

00:47:41.210 --> 00:47:44.880
that could be pretty dangerous
because if you uncheck a radio button,

00:47:44.880 --> 00:47:47.730
you might leave the radio cluster
in a state where nothing's selected,

00:47:47.730 --> 00:47:52.630
a state that the programmer may not
have anticipated being possible.

00:47:55.600 --> 00:47:59.820
And so my final comment on this is
that I'm sure these APIs are going to

00:47:59.880 --> 00:48:03.580
be put to all kinds of creative uses.

00:48:03.580 --> 00:48:07.600
And I'm not going to pass judgment on
what's an assistive app and what's not.

00:48:07.600 --> 00:48:10.880
But one thing you should keep in
mind is that this functionality

00:48:10.880 --> 00:48:12.830
is going to be off by default.

00:48:12.910 --> 00:48:15.590
In your C disks,
it's turned on by default.

00:48:15.730 --> 00:48:20.160
But when we finally ship,
the user is going to need to go

00:48:20.190 --> 00:48:23.750
into the universal access system
preferences and turn it on.

00:48:27.340 --> 00:48:29.930
So now we're going to
bring Kevin back on,

00:48:29.930 --> 00:48:32.630
and he's going to demonstrate a tool

00:48:32.800 --> 00:48:45.300
[Transcript missing]

00:48:50.800 --> 00:49:08.300
[Transcript missing]

00:49:14.030 --> 00:49:20.680
So what it's doing is it's following
the mouse around and picking up what

00:49:20.700 --> 00:49:24.720
object or UI element is under the
mouse at this moment and displaying

00:49:24.720 --> 00:49:29.660
all the information that is available
through the Accessibility API.

00:49:29.770 --> 00:49:34.060
So let's stop up here and lock
on this startup disk icon.

00:49:34.060 --> 00:49:37.560
I'm going to push F10 and
that's going to lock us on there

00:49:37.560 --> 00:49:39.280
so I can have my mouse back.

00:49:39.710 --> 00:49:41.960
So as we look through here,
at the top part here,

00:49:41.960 --> 00:49:45.720
we see the Startup Disk Push button.

00:49:45.720 --> 00:49:48.080
And we can work up the hierarchy.

00:49:48.200 --> 00:49:52.160
It's inside a toolbar,
which is inside the window named Speech.

00:49:52.160 --> 00:49:55.740
And that is inside the application
name System Preferences.

00:49:55.760 --> 00:49:59.100
So that gives you an idea of
where this push button lives.

00:49:59.120 --> 00:50:01.960
And then, as Mike talked about,
here are the attributes.

00:50:01.960 --> 00:50:05.450
So we have the role,
the role description, the help,

00:50:05.450 --> 00:50:09.790
there's no help, some state information,
some pointers to its

00:50:09.800 --> 00:50:12.400
parent and its window,
the position, size,

00:50:12.400 --> 00:50:13.920
and finally the title.

00:50:13.920 --> 00:50:17.380
And this is what you saw in
our text-to-speech demo where

00:50:17.390 --> 00:50:20.160
we're grabbing the title,
and that's what we're going to speak.

00:50:21.580 --> 00:50:23.730
And then at the bottom
down here are the actions.

00:50:23.730 --> 00:50:26.240
And so this supports a single action,
press.

00:50:26.290 --> 00:50:29.960
So let's go try it out and
see if that actually works.

00:50:29.980 --> 00:50:33.100
So what I'm going to do is I'm
going to click on this perform

00:50:33.110 --> 00:50:36.810
button and it's going to use the
Accessibility API to send that press

00:50:36.810 --> 00:50:38.860
action to the startup disk icon.

00:50:38.990 --> 00:50:42.870
So I'll push that and
you'll see that it changes.

00:50:42.880 --> 00:50:50.020
So let me go lock on something else and
I'll lock on the actual window itself.

00:50:50.020 --> 00:50:55.770
And it doesn't have any actions per se,
but it has some rules.

00:50:56.080 --> 00:50:58.540
So let me bring it forward.

00:50:58.740 --> 00:51:02.890
So the ones that have W's after them
are things that we can actually change.

00:51:02.920 --> 00:51:04.200
So let's do something fun.

00:51:04.200 --> 00:51:08.190
Let's change the position of it.

00:51:09.800 --> 00:51:23.100
[Transcript missing]

00:51:23.210 --> 00:51:26.620
Set it back to zero,
which is Google in default,

00:51:26.640 --> 00:51:27.730
and it pops back up.

00:51:27.990 --> 00:51:32.900
So this tool is really great because
it allows you as a target application

00:51:32.940 --> 00:51:36.240
developer to go through your
application and to test to make sure

00:51:36.240 --> 00:51:38.930
that your accessibility features work.

00:51:38.940 --> 00:51:42.180
And as an accessibility
client application developer,

00:51:42.180 --> 00:51:45.720
you can look around through all the
system and different applications

00:51:45.720 --> 00:51:47.470
to see what is available for you.

00:51:47.670 --> 00:51:49.790
So that's all I wanted to show.

00:51:50.200 --> 00:51:50.910
Back to you.

00:52:00.500 --> 00:52:02.360
Bring the slides back on.

00:52:02.360 --> 00:52:07.170
Okay, so now that we've gone over sort
of the high-level overview of the

00:52:07.170 --> 00:52:12.600
concepts behind the Accessibility APIs,
now we've got about seven slides that

00:52:12.600 --> 00:52:15.020
are more or less the header files.

00:52:15.020 --> 00:52:18.540
So I apologize in advance
if it's a little dry.

00:52:19.330 --> 00:52:21.830
I think for the programmers
in the audience,

00:52:21.840 --> 00:52:23.600
this is what you want to see.

00:52:23.700 --> 00:52:25.760
So as I mentioned before,
accessibility is not

00:52:25.760 --> 00:52:26.990
going to be on by default.

00:52:27.150 --> 00:52:29.630
And if your system app wants to
determine whether or not it's on,

00:52:29.640 --> 00:52:33.520
there's an API,
AX API enabled that will let

00:52:33.660 --> 00:52:36.090
you know whether it's on.

00:52:36.090 --> 00:52:40.600
And if it's not,
you'll have to explain to the user

00:52:40.630 --> 00:52:43.750
what they need to do to turn it on.

00:52:43.750 --> 00:52:43.810
You'll notice all these
APIs start with the letters AX.

00:52:44.360 --> 00:52:46.760
One issue I've been kind
of skirting around is,

00:52:46.760 --> 00:52:51.370
what is the data type of these
UI elements that we're talking about?

00:52:51.550 --> 00:52:52.910
They're a CF type.

00:52:53.000 --> 00:52:58.080
It's a type of our own invention,
and they're reference counted

00:52:58.080 --> 00:52:59.920
like other CF types are.

00:52:59.920 --> 00:53:03.120
You have to use retain and
release to manage that.

00:53:03.410 --> 00:53:06.200
You could use them as
elements of CFArrays,

00:53:06.200 --> 00:53:08.330
as keys in CFDictionary's.

00:53:08.620 --> 00:53:14.140
If you want to determine if some
ref you have is a UI element,

00:53:14.140 --> 00:53:19.540
you can compare its type against the
return value of AX UI element get type.

00:53:27.190 --> 00:53:32.510
So this slide presents basically the
starting point for most of you into

00:53:32.510 --> 00:53:36.000
the user interface element hierarchy.

00:53:36.050 --> 00:53:38.880
If you're doing sort
of a top-down approach,

00:53:38.900 --> 00:53:42.130
like the speech recognition system does,
every time an app is activated it

00:53:42.130 --> 00:53:45.530
starts at the top and starts looking
around at the active window and

00:53:45.530 --> 00:53:49.220
digging through and finding out all
the commands it should recognize.

00:53:49.440 --> 00:53:51.530
Then you'll use the
create application call.

00:53:51.540 --> 00:53:55.850
It takes the process ID of an application
and it returns you a UI element

00:53:55.850 --> 00:53:59.410
for its top or application object.

00:53:59.690 --> 00:54:02.070
If, on the other hand,
you're doing more of

00:54:02.070 --> 00:54:06.480
a bottom-up approach,
as Kevin was just demonstrating,

00:54:06.480 --> 00:54:09.750
for instance, you want to know what
UI element is under the mouse,

00:54:09.780 --> 00:54:13.490
then you'll probably start by
creating a system-wide UI element

00:54:13.490 --> 00:54:15.210
with Create System-Wide.

00:54:15.220 --> 00:54:19.100
And then you can use the call
Copy UI Element at Position to get

00:54:19.100 --> 00:54:21.800
the UI element at a specific position.

00:54:23.130 --> 00:54:27.300
And then also, this slide also shows
the keyboard posting API,

00:54:27.300 --> 00:54:30.460
if your application needs
to emulate a keyboard.

00:54:36.800 --> 00:54:42.530
So this slide shows all the
API that's involving attributes.

00:54:42.690 --> 00:54:45.330
Given a UI element, the first call,
Copy Attribute Names,

00:54:45.330 --> 00:54:49.120
is going to give you a list of
all the attributes it supports.

00:54:49.240 --> 00:54:52.660
Copy Attribute Value will give you
the value of a specific attribute.

00:54:52.660 --> 00:55:00.240
Is Attribute Settable will let you know
whether you can set that attribute.

00:55:00.260 --> 00:55:01.270
And finally, Set Attribute Value will
let you set its value.

00:55:04.810 --> 00:55:07.950
There are actually two more
APIs involving attributes.

00:55:08.170 --> 00:55:12.580
These are special ones for attributes
whose values could be large arrays.

00:55:12.820 --> 00:55:17.020
You could imagine a table view
with a large number of children.

00:55:17.200 --> 00:55:40.500
[Transcript missing]

00:55:44.730 --> 00:55:50.110
Another issue I've kind of skirted is
what is the data type of these values?

00:55:50.200 --> 00:55:51.980
In some cases, it's pretty obvious.

00:55:51.980 --> 00:55:55.700
CFStrings would represent strings.

00:55:55.700 --> 00:55:57.300
CFNumbers will represent numbers.

00:55:57.300 --> 00:56:01.670
But there's a few other odd
cases like sizes or ranges or

00:56:01.670 --> 00:56:06.820
points that there's really no,
or at least there's currently no

00:56:06.820 --> 00:56:10.080
CF type that represents it very well.

00:56:10.090 --> 00:56:12.930
So in these cases,
you're going to get back

00:56:12.930 --> 00:56:14.580
a generic CF type rep.

00:56:14.600 --> 00:56:17.890
And you can pass it to AX value get type.

00:56:18.090 --> 00:56:20.460
And that's going to tell you
whether or not it's one of

00:56:20.600 --> 00:56:22.320
these points or sizes or ranges.

00:56:22.320 --> 00:56:25.360
Or if it returns a legal value,
it means it's just something else.

00:56:27.900 --> 00:56:30.380
Once you determine you have
one of these special values,

00:56:30.430 --> 00:56:32.880
like a point,
and you actually want to work with it,

00:56:32.900 --> 00:56:37.910
then you pass it to axValue.getValue,
and that will return

00:56:37.910 --> 00:56:43.600
the point as a CG point,
and then you can extract

00:56:43.600 --> 00:56:43.600
its x and y coordinates.

00:56:44.200 --> 00:56:47.120
and then the opposite
direction is also possible.

00:56:47.220 --> 00:56:50.020
For instance,
if you want to set the position,

00:56:50.020 --> 00:56:53.670
you need to create one of these
things and you use AX value create

00:56:53.670 --> 00:56:55.730
to create one of these types.

00:57:00.170 --> 00:57:03.800
These are the three APIs that
are dealing with actions.

00:57:03.850 --> 00:57:08.010
The first one lets you get a list of all
the actions that a UI element supports.

00:57:08.070 --> 00:57:11.950
The second one allows you to get the
description of a particular action

00:57:11.950 --> 00:57:13.600
in order to present it to the user.

00:57:13.600 --> 00:57:17.760
And the final one lets
you perform the action.

00:57:23.160 --> 00:57:25.790
And these are the notification APIs.

00:57:25.950 --> 00:57:31.690
You start out by creating an observer,
which basically associates a callback

00:57:31.860 --> 00:57:36.090
routine with a particular application.

00:57:36.300 --> 00:57:39.760
Then you use Add Notification to
hook that up to observe whatever

00:57:39.760 --> 00:57:41.260
notification you're interested in.

00:57:41.270 --> 00:57:44.170
And then you could use
Remove Notification if you lose

00:57:44.390 --> 00:57:45.790
interest in that notification.

00:57:45.800 --> 00:57:51.380
Now, the reason we have this extra step
of creating an observer instead of

00:57:51.800 --> 00:57:55.490
having Add Notification take a callback
directly is that we wanted to give

00:57:55.490 --> 00:58:00.030
you flexibility over what run loop
your callbacks would be executed in.

00:58:00.700 --> 00:58:04.930
So the thing to remember is
after you create your observer,

00:58:04.930 --> 00:58:09.700
you have to get its run loop source
and then add it to some run loop.

00:58:09.850 --> 00:58:12.900
If you fail to do this,
your notification will not get called.

00:58:18.470 --> 00:58:21.640
And that's it for the APIs.

00:58:21.710 --> 00:58:25.560
This slide shows some of the
documentation that's available.

00:58:26.030 --> 00:58:30.060
And the first document covers
these APIs and how you,

00:58:30.240 --> 00:58:33.390
you know, from the point of view of
someone writing an assistive app.

00:58:33.500 --> 00:58:38.330
And the second document is the
topic of the next two sessions,

00:58:38.450 --> 00:58:41.660
basically what Cocoa and
Carbon developers need to do in

00:58:41.660 --> 00:58:43.660
order to work with these APIs.

00:58:49.800 --> 00:58:51.760
I have a road map slide
somewhere in here.

00:58:51.910 --> 00:58:53.610
Yes, it's the next slide.

00:58:53.680 --> 00:58:55.460
Just to let you know,
there's actually two

00:58:55.590 --> 00:58:57.110
other sessions today.

00:58:57.110 --> 00:58:59.040
I think they're in this hall.

00:58:59.040 --> 00:59:01.010
I think they're one after another.

00:59:01.010 --> 00:59:01.940
Yes, they are.

00:59:02.120 --> 00:59:05.500
And those sort of finish out
the accessibility story because,

00:59:05.500 --> 00:59:07.360
like I said,
there's a relationship between

00:59:07.510 --> 00:59:10.080
the Accessibility APIs,
which then talk to some of

00:59:10.080 --> 00:59:14.310
the new stuff we've put in
each framework to support it.

00:59:14.320 --> 00:59:18.030
And we have an Accessibility and Carbon,
which will go into details of

00:59:18.030 --> 00:59:20.380
your Carbon application developer,
what you have to do

00:59:20.380 --> 00:59:21.380
to support these APIs.

00:59:21.380 --> 00:59:23.730
In some cases,
you get a lot of functionality free.

00:59:23.730 --> 00:59:26.580
But in other cases, like custom controls,
you may actually have

00:59:26.660 --> 00:59:27.980
to implement something.

00:59:28.020 --> 00:59:31.970
And then Cocoa Controls and
Cocoa Accessibility is actually going

00:59:32.030 --> 00:59:35.390
to cover both Cocoa Controls with,
towards the end,

00:59:35.400 --> 00:59:40.060
a little bit of information on the
accessibility for Cocoa because a lot

00:59:40.060 --> 00:59:44.190
of the Cocoa Controls automatically
support accessibility now.

00:59:44.320 --> 00:59:47.070
So those two sessions
are a little bit later.

00:59:47.070 --> 00:59:52.180
And please come see those to get the
whole picture of accessibility on Jaguar.

00:59:52.370 --> 00:59:55.370
Now what I'd like to do is
host a question and answer.

00:59:55.370 --> 00:59:55.800
I'd like to invite...
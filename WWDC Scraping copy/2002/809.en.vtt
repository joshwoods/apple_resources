WEBVTT

00:00:08.860 --> 00:00:09.700
Good morning.

00:00:09.700 --> 00:00:12.800
I'd like to welcome you to
session 809 on Thursday,

00:00:12.800 --> 00:00:14.920
Advanced Mac OS X Networking.

00:00:15.080 --> 00:00:20.160
We're going to talk a little bit about
how to work with the new networking

00:00:20.160 --> 00:00:26.520
features that are in Jaguar on your CD,
including IPsec and IPv6.

00:00:26.520 --> 00:00:29.450
So with that,
I'd like to introduce Vincent Lubet,

00:00:29.450 --> 00:00:31.410
manager of CoreOS Networking.

00:00:31.630 --> 00:00:31.890
Thank you.

00:00:31.900 --> 00:00:33.010
Thank you.

00:00:40.700 --> 00:00:44.600
Before going into IPv6 and IPsec,
we'll talk a little

00:00:44.600 --> 00:00:49.150
bit about performance,
NKE network kernel extensions,

00:00:49.170 --> 00:00:52.850
world of quotients,
and then we'll go into IP,

00:00:52.850 --> 00:00:59.790
the big new feature of the Core OS,
networking.

00:01:00.140 --> 00:01:03.080
So let's get to it.

00:01:03.240 --> 00:01:07.020
So at this level you are really
in the Core OS in Darwin.

00:01:07.060 --> 00:01:07.100
All the application environment can take
advantage of many of those features.

00:01:07.100 --> 00:01:10.780
So performance.

00:01:10.780 --> 00:01:22.880
So again if you came into the session,
you would have seen that the

00:01:23.530 --> 00:01:26.030
The overview session,
the networking overview session,

00:01:26.030 --> 00:01:31.230
and also just during the keynote,
Avi said the biggest impact

00:01:31.300 --> 00:01:33.680
on performance is polling.

00:01:33.680 --> 00:01:38.660
So it's really a plea for
application developers not to poll.

00:01:38.660 --> 00:01:45.120
So it uses all the CPUs for
multitasking systems like Mac OS X.

00:01:45.120 --> 00:01:49.360
It still cycles away
from other processes.

00:01:50.500 --> 00:01:54.010
It has implications for
autonomy of portables.

00:01:54.020 --> 00:01:58.700
And for those of you who are still
using the Open Transport API,

00:01:58.700 --> 00:02:01.260
I mean,
there's a very relatively easy way to use

00:02:01.260 --> 00:02:04.320
Open Transport is to use Sync Idle Event.

00:02:04.360 --> 00:02:09.260
And just remember that Sync
Idle Event is a form of polling.

00:02:09.260 --> 00:02:14.720
So you should really avoid, I mean,
in addition of trying to get

00:02:14.720 --> 00:02:19.620
away from Open Transport APIs,
if you can, but if you still need,

00:02:19.800 --> 00:02:22.620
for example,
to have your application run on 9 and 10,

00:02:22.620 --> 00:02:27.180
the same binary run on 9 and 10,
you should try to get, I mean,

00:02:27.180 --> 00:02:31.280
to use other form of
Open Transport modes.

00:02:31.280 --> 00:02:34.650
So what should you do?

00:02:34.660 --> 00:02:36.950
I mean, you should either block
or be event-driven.

00:02:36.960 --> 00:02:39.720
And blocking is the...

00:02:41.120 --> 00:02:54.990
The typical model for a server
using sockets is to span a new

00:02:54.990 --> 00:02:59.920
thread for each new connection and
all the calls are made blocking.

00:02:59.960 --> 00:03:01.840
It's very efficient.

00:03:01.840 --> 00:03:05.060
If you have maybe a more
complex application,

00:03:05.130 --> 00:03:09.590
the client application that can
use many simultaneous connections,

00:03:09.770 --> 00:03:14.280
you should be event-driven.

00:03:14.280 --> 00:03:17.300
There are many ways,
depending on what kind

00:03:17.440 --> 00:03:19.160
of APIs you're using.

00:03:19.160 --> 00:03:22.380
There are many facilities to do that.

00:03:22.380 --> 00:03:26.210
For sockets, BSD sockets,
we have the select system code that

00:03:26.210 --> 00:03:32.730
allows to multiplex and wait for events
on multiple file descriptors at once.

00:03:32.890 --> 00:03:36.770
It can be a mix of any
kind of file descriptor,

00:03:36.770 --> 00:03:42.540
sockets being one,
but it can be a mix of regular files.

00:03:42.540 --> 00:03:46.390
For open transport,
to get the best out of open transport,

00:03:46.520 --> 00:03:50.750
especially in Mac OS X,
you should use the asynchronous

00:03:51.660 --> 00:03:54.920
mode from within your notifier.

00:03:54.920 --> 00:03:57.490
There are some applications that
are using asynchronous mode,

00:03:57.560 --> 00:04:00.380
but they, for example,
when they get the event,

00:04:00.390 --> 00:04:05.410
they just signal a main
thread or cooperative threads,

00:04:05.410 --> 00:04:11.880
and that adds context-switching,
which hurts performance.

00:04:11.880 --> 00:04:16.920
For the higher-level APIs,
they are all integrated in

00:04:16.920 --> 00:04:18.940
the run loop or a run loop.

00:04:18.940 --> 00:04:25.940
Usually, you shouldn't have to... That's
being taken care of by the

00:04:25.940 --> 00:04:27.760
implementation of those APIs.

00:04:30.450 --> 00:04:33.520
So a word about open transport.

00:04:33.640 --> 00:04:36.160
So that's the truth.

00:04:36.160 --> 00:04:38.800
Open transport on
Mac OS X is kind of slow.

00:04:38.800 --> 00:04:43.870
It works well for, in simple case,
you know, you have one endpoint.

00:04:43.880 --> 00:04:49.900
But because we need to emulate
the different execution level

00:04:49.900 --> 00:04:56.960
of the traditional Mac OS,
that means default task, interrupt time,

00:04:56.960 --> 00:04:59.420
and things like that.

00:05:00.050 --> 00:05:03.840
We do that in the background, in threads,
in worker threads in the background.

00:05:03.840 --> 00:05:08.590
But the communication between, you know,
the main API context and the

00:05:08.820 --> 00:05:13.430
worker threads in the background
adds additional context switches.

00:05:13.440 --> 00:05:15.550
So on...

00:05:17.010 --> 00:05:22.820
If you have just a simple application
that just uses only one endpoint,

00:05:22.950 --> 00:05:23.900
that's okay.

00:05:24.030 --> 00:05:28.410
But as you add endpoints,
the combination of all those context

00:05:28.470 --> 00:05:36.880
switches and the managing of all those
endpoints will add up and cost CPU usage.

00:05:37.530 --> 00:05:42.900
There are also other facts.

00:05:42.900 --> 00:05:46.900
The fact that lookups, name lookups,
for example, are serialized.

00:05:47.300 --> 00:05:52.900
That also adds a significant
impact on performance.

00:05:53.030 --> 00:05:59.770
Usually we say there's a typical
10-15% impact on performance for...

00:05:59.920 --> 00:06:01.510
But that's really an average.

00:06:01.560 --> 00:06:07.260
I mean,
if you have a very simple usage scenario,

00:06:07.310 --> 00:06:10.730
just using one endpoint, for example,
you can get relatively high

00:06:10.730 --> 00:06:14.720
throughput and not much worse
CPU usage compared to socket.

00:06:14.720 --> 00:06:15.960
Always a little bit more.

00:06:16.200 --> 00:06:19.600
But as you add,
you use many more endpoints

00:06:19.610 --> 00:06:24.170
and other kind of providers,
the toll on the CPU usage

00:06:24.170 --> 00:06:26.430
is greater and greater.

00:06:27.480 --> 00:06:32.190
So,
open transport is fine in simple case,

00:06:32.320 --> 00:06:38.680
but if you have an application
that is network-intensive,

00:06:38.890 --> 00:06:42.770
that makes use of a lot
of...access a lot of the...

00:06:42.950 --> 00:06:44.400
A lot of resources on the network.

00:06:44.510 --> 00:06:47.840
You should really think
about using other APIs,

00:06:47.840 --> 00:06:53.710
BSD or even other
higher-level APIs if you can.

00:06:55.290 --> 00:07:02.660
Another important factor for
performance is buffer size.

00:07:02.880 --> 00:07:09.980
You have to find a good compromise
between too small and too big.

00:07:10.150 --> 00:07:14.710
and so it affects and also
again if you come from,

00:07:14.720 --> 00:07:17.750
application comes from
open transport online,

00:07:17.750 --> 00:07:21.100
you need not to have to
watch very much about those,

00:07:21.100 --> 00:07:23.600
for example,
the socket buffer size or the

00:07:23.600 --> 00:07:25.100
equivalent for open transport.

00:07:25.110 --> 00:07:30.100
On the BSD system, BSD-based system,
it's much more important.

00:07:30.110 --> 00:07:37.930
And so by default, for example,
for TCP socket, you,

00:07:38.020 --> 00:07:44.100
TCP socket can hold up to 32K
of data buffered in the kernel.

00:07:44.100 --> 00:07:48.750
And usually that's enough, I mean.

00:07:49.190 --> 00:07:52.000
Except if you want to have
very high performance,

00:07:52.000 --> 00:07:54.340
maybe on very low latency
link like gigabit,

00:07:54.340 --> 00:07:58.010
maybe you should think to add that a bit,
maybe double or triple that.

00:07:58.100 --> 00:08:02.580
But also what's very important
that affects direct impact on the

00:08:02.580 --> 00:08:06.790
performance of your application
is the size of the buffer you

00:08:06.790 --> 00:08:09.020
pass to send and receive calls.

00:08:09.020 --> 00:08:13.340
So the worst we can see is that reading
or writing white byte at a time.

00:08:13.990 --> 00:08:18.140
So for example,
if you need to pass something,

00:08:18.140 --> 00:08:20.370
you have a protocol
that you need to pass,

00:08:20.470 --> 00:08:23.240
the easiest way of course is to,
for example,

00:08:23.280 --> 00:08:28.160
if you receive an HTTP message,
to pass one byte at a time.

00:08:28.160 --> 00:08:30.100
But you should avoid that.

00:08:30.160 --> 00:08:35.880
You should have an intermediate buffer
when you read by several K at a time.

00:08:36.270 --> 00:08:41.730
And also we've seen recently,
I've added the fact that the

00:08:41.730 --> 00:08:49.570
socket receive buffer in the
BSD implementation is directly,

00:08:49.570 --> 00:08:55.530
is really directly affects
the TCP window size that is

00:08:55.540 --> 00:08:56.960
advertised to the other side.

00:08:56.960 --> 00:09:04.320
So if you don't empty,
if you don't read fast enough or if

00:09:04.320 --> 00:09:10.160
you do read too few bytes at a time,
you will,

00:09:10.610 --> 00:09:13.040
the stack will close the window size.

00:09:13.060 --> 00:09:16.910
That means that instead of
having a nice streaming of data,

00:09:16.910 --> 00:09:21.800
the other side will stop sending for
a while and so you will have hiccups.

00:09:21.800 --> 00:09:27.860
And so that's why you should try to,
when you... When you have

00:09:27.860 --> 00:09:31.120
an event on a socket,
you should try to empty

00:09:31.120 --> 00:09:32.900
it as much as you can.

00:09:37.700 --> 00:09:45.810
Okay, so kind of to sum up,
so the idea here is to minimize

00:09:45.870 --> 00:09:50.140
latency to have the best streaming,
to have the best throughput.

00:09:50.140 --> 00:09:57.410
So cooperative thread should be avoided
because usually that means that you

00:09:57.450 --> 00:10:02.880
are serialized with other lengthy
activity and it's really one thread

00:10:02.880 --> 00:10:06.280
at a time can run and it's cooperative.

00:10:06.750 --> 00:10:10.030
So you could be doing,
your application could

00:10:10.030 --> 00:10:14.100
be doing something very,
very expensive and data would

00:10:14.100 --> 00:10:16.520
accumulate in the socket buffer.

00:10:16.520 --> 00:10:22.700
And on the other hand,
we've seen there's a socket and we've

00:10:22.770 --> 00:10:25.050
seen very recently an example of that.

00:10:25.060 --> 00:10:30.390
In the socket,
you can use a flag called message.

00:10:30.450 --> 00:10:33.260
I think it's the wait all option.

00:10:33.260 --> 00:10:38.280
That means that, for example,
the receive call will not return until

00:10:38.280 --> 00:10:40.760
you get all the data you've asked for.

00:10:40.780 --> 00:10:45.110
If you ask, for example,
if you ask for a very

00:10:45.110 --> 00:10:47.900
large amount of data,
which is more or less the size of

00:10:47.900 --> 00:10:53.040
the socket receive buffer size,
that means that you will not

00:10:53.530 --> 00:10:54.760
empty and not have a nice flow.

00:10:54.760 --> 00:11:00.980
So the window size,
the TCP window size will go down to zero.

00:11:00.980 --> 00:11:04.820
And those are kind of extreme,
extreme case of bad throughput.

00:11:04.820 --> 00:11:09.340
It's just because there was
some code that were just using

00:11:09.340 --> 00:11:14.130
this flag and it was just,
I think, a copy and paste.

00:11:14.180 --> 00:11:19.140
But you can use that,
but you can use that for amount of

00:11:19.140 --> 00:11:23.320
a buffer that is much smaller than
the socket receive buffer size,

00:11:23.320 --> 00:11:29.370
which is 32k by default.

00:11:29.660 --> 00:11:34.320
And also,
disk I/O can also affect network I/O.

00:11:34.320 --> 00:11:38.230
So you should try to--

00:11:39.890 --> 00:11:43.330
To apply the same rules,
sometimes people say

00:11:43.330 --> 00:11:47.420
the download is slow,
but it's because maybe there are

00:11:47.630 --> 00:11:51.790
some disk operations that are
serialized with the networking.

00:11:51.840 --> 00:11:55.790
You should watch that.

00:11:55.900 --> 00:12:02.400
[Transcript missing]

00:12:04.450 --> 00:12:08.800
that you can use to watch for, I mean,
the different parameters for performance.

00:12:08.800 --> 00:12:12.270
So, for example,
I've listed a few of them.

00:12:12.500 --> 00:12:18.040
TOP allows you to watch
various statistics,

00:12:18.040 --> 00:12:21.220
like CPU usage and memory usage.

00:12:21.220 --> 00:12:24.670
FS usage is very nice
because it allows you to see,

00:12:24.730 --> 00:12:28.020
for example,
if you're using network RU and disk RU,

00:12:28.020 --> 00:12:33.770
it lists, it gets you a trace of all the
hardware related system calls.

00:12:33.850 --> 00:12:37.590
So you can see, for example,
you can see from your application what

00:12:37.830 --> 00:12:43.420
are those calls and how big they are,
how much data is returned.

00:12:43.640 --> 00:12:46.100
Also, sample is a nice tool.

00:12:46.100 --> 00:12:49.040
It gets you kind of a
statistical graph of,

00:12:49.040 --> 00:12:51.680
I mean,
statistical view of your call graph.

00:12:51.750 --> 00:12:54.600
So you can see, for example,
if you're polling,

00:12:54.600 --> 00:12:58.320
you will see that you have
the same kind of piece of code

00:12:58.320 --> 00:13:01.610
that is called all the time.

00:13:02.070 --> 00:13:07.230
And also this word here,
I think it's kind of also

00:13:07.230 --> 00:13:12.590
a word of caution is that
sometimes people optimize,

00:13:12.590 --> 00:13:19.460
try to optimize so much that
certainly the application is very,

00:13:19.460 --> 00:13:24.020
I mean, has great performance,
but it comes at the price of efficiency.

00:13:24.050 --> 00:13:28.930
That means that certainly it
works well if the application

00:13:28.930 --> 00:13:33.910
runs alone in the system,
but it's not very efficient because

00:13:34.100 --> 00:13:39.030
it uses too much resources like
memory or CPU or things like that.

00:13:39.210 --> 00:13:42.010
So you should try to find
also a right balance between

00:13:42.010 --> 00:13:43.810
performance and efficiency.

00:13:43.900 --> 00:13:50.630
And in session 906, Friday morning,
there's a performance session

00:13:50.630 --> 00:13:53.760
that goes into much more detail.

00:13:53.760 --> 00:13:58.650
So that if you're interested
in getting the most performance

00:13:58.660 --> 00:14:01.720
at the lowest cost possible,
you should attend this session.

00:14:04.330 --> 00:14:09.760
Now a totally different subject,
a word about network kernel extensions.

00:14:09.760 --> 00:14:12.790
Network kernel extensions,
or NKE in short,

00:14:12.790 --> 00:14:20.400
allows to extend network services and
allows you either to trap data in the

00:14:20.400 --> 00:14:25.300
kernel or just add new functionality.

00:14:25.300 --> 00:14:31.670
So we've added that years ago,
the ability to add dynamically

00:14:31.670 --> 00:14:35.300
new services in the kernel.

00:14:35.300 --> 00:14:37.130
It's dynamic,
you don't need to recompile the

00:14:37.130 --> 00:14:38.460
kernel and things like that.

00:14:38.570 --> 00:14:43.830
So it's great, but if you're developing a
network kernel extension,

00:14:43.830 --> 00:14:47.850
you should be aware of that
running in the kernel comes

00:14:47.850 --> 00:14:50.760
with a lot of responsibilities.

00:14:51.150 --> 00:14:54.940
So the first one,
and that's certainly something

00:14:54.940 --> 00:15:00.310
that we stress over and over and
over because it's very important.

00:15:00.320 --> 00:15:06.570
In the kernel, there is no real API,
especially for NKs.

00:15:06.600 --> 00:15:10.400
So D and it's the same
for file system extension.

00:15:10.400 --> 00:15:13.260
So if you use the I/O Kit, you are safe.

00:15:13.440 --> 00:15:17.420
But otherwise,
for the BSD side of the kernel,

00:15:17.420 --> 00:15:22.090
there is no real APIs.

00:15:22.100 --> 00:15:26.650
We expose all the mechanism,
the implementation details.

00:15:26.670 --> 00:15:30.100
That's really where you
hook up in the kernel.

00:15:30.100 --> 00:15:35.380
So as we add functionalities,
that may change at any time.

00:15:35.380 --> 00:15:38.100
And also there's something
that we're aware of,

00:15:38.130 --> 00:15:45.610
and that the headers do not...
do not make clear what is

00:15:45.610 --> 00:15:47.400
private and what is public.

00:15:47.480 --> 00:15:52.580
And so we are seeing a lot of
kernel extensions that are using,

00:15:52.580 --> 00:15:55.580
for example, symbols they shouldn't use.

00:15:55.580 --> 00:16:00.340
And it's understandable because
that was not very well documented.

00:16:00.400 --> 00:16:03.400
We are planning to remedy that fact.

00:16:03.440 --> 00:16:09.930
But the big, big message here is that we
cannot guarantee backwards or

00:16:09.930 --> 00:16:11.680
forwards compatibility in the case.

00:16:11.680 --> 00:16:13.670
So, I mean, if you're developing...
if you're developing a

00:16:13.670 --> 00:16:15.920
network... a kernel extension,
especially an NK,

00:16:15.920 --> 00:16:21.660
you should be prepared to release
update in lockstep with Apple.

00:16:21.660 --> 00:16:23.360
So it's a big burden.

00:16:25.790 --> 00:16:30.840
So why do we,
why does we have to change that?

00:16:30.840 --> 00:16:38.480
Because for bug fixes, I mean,
the very first, the very first software

00:16:38.480 --> 00:16:44.200
update of Mac OS X,
that means Mac OS X 0.1, a year ago,

00:16:44.210 --> 00:16:45.790
had to fix a problem.

00:16:45.790 --> 00:16:49.780
We had to change, for example,
the size of the socket structure, so,

00:16:49.810 --> 00:16:52.390
which is used by many, many NKE.

00:16:52.600 --> 00:16:57.940
And we were just lucky that there
weren't any NKE shipping at that time,

00:16:57.940 --> 00:17:01.940
but otherwise it could
have had a big impact.

00:17:01.940 --> 00:17:04.470
We also had new functionality.

00:17:04.480 --> 00:17:09.430
For example, this year with Jaguar,
we're introducing IPsec and IPv6.

00:17:09.430 --> 00:17:14.550
That means that all the NKEs
that are looking into the

00:17:14.560 --> 00:17:21.320
TCP control block will have to,
may break because the structure,

00:17:21.320 --> 00:17:26.720
an IP address, I mean, all the,
everywhere you have an IP address, IP is,

00:17:26.720 --> 00:17:30.550
the size has changed because it
can be an IPv4 or an IPv6 address,

00:17:30.560 --> 00:17:32.020
which is much larger.

00:17:32.030 --> 00:17:34.690
So the size of the
structure has increased.

00:17:34.700 --> 00:17:40.040
And also sometimes just for, to,
for performance enhancement,

00:17:40.160 --> 00:17:45.180
we need to change the way things are
implemented to be more efficient.

00:17:46.000 --> 00:17:55.400
So, kind of the message here is that we
recommend that you should avoid to

00:17:56.490 --> 00:17:59.030
To develop NKs when possible.

00:17:59.120 --> 00:18:01.340
They are alternatives.

00:18:01.340 --> 00:18:05.970
For example,
if you are writing a network interface,

00:18:06.000 --> 00:18:08.800
you should really use the I/O Kit.

00:18:08.890 --> 00:18:14.210
You have the IO Networking family
for Ethernet-like interfaces

00:18:14.330 --> 00:18:19.650
or IO Serial family for PPP,
where in fact, that's the classic

00:18:19.650 --> 00:18:23.280
example where you pretend,
for example,

00:18:23.280 --> 00:18:26.350
your device pretends to work.

00:18:26.450 --> 00:18:30.320
It pretends to be a serial device,
a pseudo-serial device,

00:18:30.320 --> 00:18:31.980
and do the inframing.

00:18:31.980 --> 00:18:33.100
That's not new.

00:18:33.130 --> 00:18:39.400
A lot of drivers were like
that already on Mac OS 8 and 9.

00:18:39.400 --> 00:18:42.400
That's really the recommended way.

00:18:42.400 --> 00:18:47.400
If you do that, do not depend on the BSD.

00:18:48.270 --> 00:18:50.490
So that's the most important.

00:18:50.500 --> 00:18:58.000
So if you need to talk between the kernel
and maybe your controller in user space,

00:18:58.030 --> 00:19:02.260
something like that, you should use the
I/O Kit User Client API.

00:19:02.260 --> 00:19:06.180
It's also something that's very well,
that has nice abstraction layer,

00:19:06.190 --> 00:19:08.500
so that's something we recommend.

00:19:08.520 --> 00:19:12.760
And sometimes we have
always the question,

00:19:12.840 --> 00:19:17.080
so I need to add new network protocols.

00:19:17.100 --> 00:19:22.080
And if this protocol is to be
used only by one application,

00:19:22.100 --> 00:19:27.500
we recommend that you implement, in fact,
the protocol in user space.

00:19:27.500 --> 00:19:33.180
We have a socket called PF-NDRV for
network drivers that allows to

00:19:33.180 --> 00:19:38.280
capture datagram directly and
get them in user space directly.

00:19:38.350 --> 00:19:41.600
So it's the recommended way if you
don't want to provide a network

00:19:41.740 --> 00:19:45.540
protocol that would be available
for all the application but you

00:19:45.540 --> 00:19:48.670
have kind of vertical solution.

00:19:51.040 --> 00:19:57.480
So, but if you still,
if you need to develop an NKE,

00:19:57.480 --> 00:20:00.230
there are a number of
rules you should follow.

00:20:00.240 --> 00:20:04.600
For example,
the first one is do strip global symbols.

00:20:04.600 --> 00:20:10.570
As we are adding features, for example,
we are adding IP with IPsec,

00:20:10.590 --> 00:20:14.180
we've added a bunch of crypto modules.

00:20:14.680 --> 00:20:20.890
And we've seen that, for example,
DES is kind of common, is in common use.

00:20:20.960 --> 00:20:24.980
Hey, we got the BSD implementation
and it's used,

00:20:24.980 --> 00:20:30.380
and it clashes with some,
already some third-party extension.

00:20:30.380 --> 00:20:34.310
So, make, I mean, really,
you should really export

00:20:34.330 --> 00:20:37.960
only two symbols from NKE,
that you start and stop module.

00:20:37.960 --> 00:20:39.710
Everything else you should strip.

00:20:39.720 --> 00:20:42.190
And there are various ways of doing that.

00:20:42.360 --> 00:20:45.970
There's a strip command,
or you can... You can use the,

00:20:45.970 --> 00:20:50.220
that you can run at, when you,
on your executable,

00:20:50.220 --> 00:20:54.260
you can also declare a
symbol private extern.

00:20:54.260 --> 00:20:57.980
It's kind of an addition from Apple.

00:20:59.460 --> 00:21:07.200
Another rule should be is that
you should just treat all the BSD,

00:21:07.200 --> 00:21:12.010
all the kernel-side data structures
as opaque data structure.

00:21:12.200 --> 00:21:14.700
Do not go down on the reference.

00:21:14.710 --> 00:21:17.200
Use accessors,
and if there are no accessors,

00:21:17.250 --> 00:21:19.950
please let us know what you need.

00:21:20.050 --> 00:21:27.550
Because those structures,
they change size all the time.

00:21:28.360 --> 00:21:32.100
In the kernel there's a
socket layer which is used

00:21:32.180 --> 00:21:35.240
by many network file systems.

00:21:35.320 --> 00:21:39.160
Usually,
if you look at the implementation of NFS,

00:21:39.270 --> 00:21:41.530
that's where it plugs into the kernel.

00:21:41.550 --> 00:21:44.340
It's the same for AFP.

00:21:44.340 --> 00:21:46.440
It's a nice layer.

00:21:46.460 --> 00:21:53.230
It mimics more or less the user-lens
socket layer and we don't expect

00:21:53.230 --> 00:21:56.130
it to change that drastically.

00:21:56.160 --> 00:22:01.340
Just still a word of caution, as it is,
we are fixing that as much as we can.

00:22:01.340 --> 00:22:05.990
In the headers you see a lot of
accessors that are still macros,

00:22:05.990 --> 00:22:08.420
and of course that's not
good for binary compatibility

00:22:08.420 --> 00:22:11.360
because we are changing that.

00:22:11.470 --> 00:22:18.690
If you find some, just let us know and
we'll try to fix them.

00:22:19.500 --> 00:22:24.250
So again, on Jaguar,
because of IPv6 and IPsec,

00:22:24.310 --> 00:22:31.660
the TCP/IP control blocks,
the layout of the structure has changed.

00:22:31.660 --> 00:22:36.180
We have also new mbuf routines
to isolate your code from the

00:22:36.180 --> 00:22:38.940
details of the implementation.

00:22:38.980 --> 00:22:42.980
So a lot of the existing macro,
Mac OS X dot one,

00:22:42.980 --> 00:22:50.460
are just macro and they just
reference internal data structures.

00:22:50.460 --> 00:22:54.590
And as we go and as we want certainly
to improve performance in this area,

00:22:54.590 --> 00:22:58.360
we'd like to move away from the
way it is implemented today.

00:22:58.360 --> 00:23:02.620
And we cannot do that today
because it breaks all the NKE.

00:23:02.850 --> 00:23:07.700
We've done also, following the feedback
from a few developers,

00:23:07.700 --> 00:23:12.120
we've changed the way the socket
connect call is intercepted and

00:23:12.120 --> 00:23:15.700
also the accept connect call.

00:23:15.700 --> 00:23:18.700
You should watch that and
make sure that it should work.

00:23:18.700 --> 00:23:22.100
For example, the connect call,
it didn't work before,

00:23:22.100 --> 00:23:25.290
so you couldn't do something that worked.

00:23:26.210 --> 00:23:30.460
The NKE manager is deprecated.

00:23:30.460 --> 00:23:38.280
We have a new kernel event protocol in
the PF system that allows you to create

00:23:38.420 --> 00:23:42.610
control stream between your NKE and the

00:23:43.010 --> 00:23:46.860
and something,
a controller in user space.

00:23:46.870 --> 00:23:51.710
And also something new is that
interface can be detached in Jaguar.

00:23:51.710 --> 00:23:57.360
So that was a loss for, for example,
a USB device or PCI network

00:23:57.360 --> 00:24:00.060
device to be cleanly detached.

00:24:00.140 --> 00:24:02.510
And there was a problem.

00:24:02.670 --> 00:24:04.240
It was not possible before that.

00:24:04.240 --> 00:24:08.240
Thank you.

00:24:09.260 --> 00:24:13.870
Okay, so you will see on the
developer SDK we've started

00:24:13.990 --> 00:24:16.200
to clean up the headers,
especially the kernel headers.

00:24:16.200 --> 00:24:23.750
So kind of the rule is that do
not reference anything that does

00:24:23.770 --> 00:24:26.200
not appear in a public header.

00:24:26.200 --> 00:24:29.200
So we've cleaned up a bunch of headers.

00:24:29.200 --> 00:24:32.530
I mean,
most of them really are headers for,

00:24:32.530 --> 00:24:35.190
for example, for network protocols.

00:24:35.260 --> 00:24:40.200
We don't implement, you know,
the ISO protocol and things like that.

00:24:40.200 --> 00:24:44.850
But really, if you don't see a symbol
in the public header,

00:24:44.860 --> 00:24:46.110
do not use it.

00:24:46.230 --> 00:24:48.240
It's relatively easy
because we have Darwin,

00:24:48.240 --> 00:24:51.660
we're open source, so you can see,
go into Darwin and see

00:24:51.660 --> 00:24:53.180
how the kernel works.

00:24:53.200 --> 00:24:54.120
So that's great.

00:24:54.230 --> 00:24:56.970
I mean,
it can certainly help you into your

00:24:56.970 --> 00:24:59.200
understanding what you should do.

00:24:59.200 --> 00:25:04.200
But that doesn't mean that because
a symbol is globally accessible,

00:25:04.200 --> 00:25:09.200
because it's exported by the kernel,
it's not stripped, that it is an API.

00:25:09.200 --> 00:25:14.150
Certainly it can be an SPI,
which means a system API.

00:25:14.220 --> 00:25:20.300
We are also, as Apple is getting,

00:25:20.650 --> 00:25:25.790
One of our goals is to reduce the
size of the kernel and put more

00:25:25.790 --> 00:25:29.740
functionality in kernel extensions.

00:25:29.740 --> 00:25:36.250
We reserve the right to have system APIs,
things that can communicate between

00:25:36.260 --> 00:25:38.340
the kernel and some kernel extensions.

00:25:38.340 --> 00:25:42.180
But we can do that easily
because as we bring a new system,

00:25:42.180 --> 00:25:45.150
we will ship and rebuild
everything at once,

00:25:45.150 --> 00:25:47.500
the kernel and our kernel extensions.

00:25:48.190 --> 00:25:52.120
We cannot build your kernel extensions,
so you shouldn't use that.

00:25:52.120 --> 00:25:56.780
And also something to...

00:25:57.800 --> 00:26:01.780
Here is that things that
are built for Jaguar,

00:26:01.780 --> 00:26:05.560
in fact,
here it's more backward compatibility,

00:26:05.560 --> 00:26:10.650
but if you build your NK on Jaguar,
it won't run on previous system

00:26:10.650 --> 00:26:16.800
because of the changes we've made.

00:26:18.820 --> 00:26:24.510
So really,
so the last slide is that we are

00:26:24.510 --> 00:26:27.630
trying to solve that problem.

00:26:27.660 --> 00:26:30.220
So we would like to come
up with a more sustainable,

00:26:30.220 --> 00:26:32.540
real API if you want in the kernel.

00:26:32.540 --> 00:26:37.280
So there are things you should do.

00:26:37.280 --> 00:26:39.700
I mean,
you should use the command nm to list,

00:26:39.800 --> 00:26:42.760
for example,
the global symbols you export.

00:26:42.790 --> 00:26:47.990
And you will see that, I mean, typically,
kernel extension export

00:26:48.500 --> 00:26:50.700
hundreds of symbols,
and they will clash.

00:26:50.700 --> 00:26:56.820
They may clash at any time with a
new feature added to the kernel.

00:26:56.820 --> 00:27:00.560
So you should use,
if you need to export global symbols,

00:27:00.560 --> 00:27:02.270
you should use a prefix.

00:27:02.270 --> 00:27:05.770
I mean, for example,
something with the name of your

00:27:05.770 --> 00:27:08.320
company or something like that.

00:27:08.320 --> 00:27:12.280
Also, there's the kegslot command.

00:27:12.280 --> 00:27:14.120
You can use that to check
for common mistakes.

00:27:14.120 --> 00:27:18.790
So there's a number of rules
that we are enforcing for kernel

00:27:18.790 --> 00:27:21.520
extension as a whole in Jaguar.

00:27:21.520 --> 00:27:29.500
So things you could get away with
in Mac OS 10.1 won't work anymore.

00:27:29.500 --> 00:27:31.490
For example,
permissions of your executable

00:27:31.490 --> 00:27:32.560
and things like that.

00:27:32.580 --> 00:27:39.030
So if you're developing an NKE, really,
you should work with us with

00:27:39.030 --> 00:27:41.720
developer relation and DTS.

00:27:41.780 --> 00:27:47.480
We need to know who you are so that
we can work together and make the

00:27:47.480 --> 00:27:51.140
transition and the release of new
system as painless as possible.

00:27:53.520 --> 00:27:57.480
With that,
I would like to call Josh Graessley,

00:27:57.480 --> 00:28:01.330
who's going to talk
about IPsec in Jaguar.

00:28:06.170 --> 00:28:06.900
Good morning.

00:28:06.900 --> 00:28:11.850
I'm going to give you a brief overview
of IPSec and what we've got in Jaguar.

00:28:12.250 --> 00:28:14.190
Why are we interested in IPSec?

00:28:14.200 --> 00:28:18.340
IPSec gives us a way to securely
communicate over the Internet.

00:28:18.340 --> 00:28:19.460
We can prevent eavesdropping.

00:28:19.460 --> 00:28:21.960
We can authenticate
the origin of traffic.

00:28:22.020 --> 00:28:26.200
This also lets us -- IPSec is
also based on IETF standards,

00:28:26.200 --> 00:28:30.200
so we can interoperate with
other platforms out there.

00:28:30.200 --> 00:28:34.350
IPSec also gives us a foundation for
building virtual private networks.

00:28:34.350 --> 00:28:35.660
It gives us some protocols.

00:28:35.750 --> 00:28:37.770
It's important, however,
to note that IPSec is not

00:28:37.770 --> 00:28:38.950
a virtual private network.

00:28:39.050 --> 00:28:43.410
There's a lot of pieces missing,
so it's a third-party opportunity.

00:28:45.680 --> 00:28:47.600
What exactly is IPSec?

00:28:47.610 --> 00:28:52.600
IPSec gives us per-packet authentication
and encryption using a set of protocols.

00:28:52.600 --> 00:28:56.940
It works with any IP protocol.

00:28:57.160 --> 00:28:59.900
If you can put an IP header in front
of it and put it out on the wire,

00:28:59.900 --> 00:29:01.740
it'll work with IPSec.

00:29:01.740 --> 00:29:03.020
It's transparent to applications.

00:29:03.080 --> 00:29:06.970
The applications don't necessarily have
to be rewritten to make use of this.

00:29:07.730 --> 00:29:09.600
IPsec is also host-to-host.

00:29:09.600 --> 00:29:12.420
The authentication and
encryption are based on hosts,

00:29:12.420 --> 00:29:13.240
not on users.

00:29:13.240 --> 00:29:15.170
So if you have multiple
users on a given host,

00:29:15.170 --> 00:29:18.700
it does nothing to discern the
difference between traffic sent from

00:29:18.700 --> 00:29:21.130
one user as opposed to another user.

00:29:23.180 --> 00:29:26.140
IPSec is comprised of three protocols.

00:29:26.260 --> 00:29:29.510
There's authentication header,
encapsulated secure payload,

00:29:29.510 --> 00:29:31.050
and IP compression.

00:29:31.260 --> 00:29:34.490
Authentication header is used to
authenticate the packets so we can

00:29:34.580 --> 00:29:37.570
find out where the packets came from.

00:29:37.650 --> 00:29:41.230
Encapsulated secure payload
gives us some encryption,

00:29:41.360 --> 00:29:44.410
and IP compression
compresses the packets.

00:29:45.170 --> 00:29:48.320
The authentication header gives
us--validates the originator.

00:29:48.350 --> 00:29:49.650
It'll detect modifications.

00:29:49.680 --> 00:29:52.980
It'll also detect duplicates,
so we can do some duplicate suppression.

00:29:53.100 --> 00:29:55.540
It supports multiple algorithms.

00:29:55.610 --> 00:30:02.890
In Jaguar, we have support for HMAC-MD5,
HMAC-SHA1, and a few others.

00:30:03.410 --> 00:30:06.250
Encapsulated Security Payload
encrypts the payload.

00:30:06.290 --> 00:30:09.460
It doesn't encrypt the IP header,
it just encrypts the payload.

00:30:09.520 --> 00:30:13.400
It can also be used to
authenticate the payload.

00:30:13.400 --> 00:30:16.440
This gives us protection against
wiretaps and products like

00:30:16.740 --> 00:30:19.070
EtherPeak and people using TCP dump.

00:30:21.010 --> 00:30:24.240
We do support encapsulated
security payload,

00:30:24.240 --> 00:30:26.680
supports multiple algorithms.

00:30:26.680 --> 00:30:31.680
In Jaguar we have support for Triple DES,
AES, Blowfish, and a few others.

00:30:32.200 --> 00:30:35.480
IP compression lets you
compress the IP payload before

00:30:35.480 --> 00:30:36.760
you actually encrypt it.

00:30:36.960 --> 00:30:39.940
This is kind of important
because if you encrypt something,

00:30:40.040 --> 00:30:45.410
it makes it really difficult to
compress if your encryption is any good.

00:30:45.630 --> 00:30:48.310
The implementation uses
Zlib in the kernel.

00:30:48.460 --> 00:30:50.620
Zlib wasn't really intended
to be used in the kernel.

00:30:50.620 --> 00:30:51.800
It allocates a lot of memory.

00:30:51.800 --> 00:30:54.500
It's kind of an expensive operation.

00:30:54.500 --> 00:30:57.440
IP comp isn't widely used,
and if you don't need to use it,

00:30:57.440 --> 00:31:00.530
we recommend against using it for now.

00:31:00.650 --> 00:31:03.740
In Jaguar, we only support the
inflate-deflate algorithm,

00:31:03.770 --> 00:31:06.660
although the protocol does
allow for multiple algorithms.

00:31:08.890 --> 00:31:10.570
IPSec can operate in two modes.

00:31:10.690 --> 00:31:12.730
There's tunnel mode and transport mode.

00:31:12.860 --> 00:31:16.940
In tunnel mode,
we can securely tunnel traffic

00:31:17.050 --> 00:31:19.910
between two networks or
between a host and a network.

00:31:20.000 --> 00:31:22.390
This is commonly used for VPNs.

00:31:22.590 --> 00:31:27.040
Transport mode lets us secure
communications between two different

00:31:27.040 --> 00:31:29.150
hosts or any number of hosts.

00:31:30.750 --> 00:31:34.600
So we've got these great protocols
to encrypt and authenticate traffic.

00:31:34.600 --> 00:31:37.390
The kernel needs a way to know
what traffic should be encrypted

00:31:37.450 --> 00:31:39.700
and how it should be encrypted.

00:31:39.700 --> 00:31:45.080
We use security policies to
define a filter that defines

00:31:45.080 --> 00:31:50.690
what level of processing is
going to apply to what traffic.

00:31:50.700 --> 00:31:54.320
We use a filter based on a few selectors,
such as the source and

00:31:54.330 --> 00:31:57.700
destination addresses or
ports or even the IP protocol.

00:31:57.700 --> 00:32:01.700
This security policy also defines
what level of processing will occur,

00:32:01.700 --> 00:32:04.920
whether the traffic is
allowed to bypass IPSec,

00:32:04.920 --> 00:32:08.700
whether IPSec is required,
whether IPSec is used,

00:32:08.700 --> 00:32:12.290
or whether the traffic
should just be discarded.

00:32:13.210 --> 00:32:15.930
If the policy is set to
require or use IPSec,

00:32:15.980 --> 00:32:18.100
it will also specify which
protocol should be used:

00:32:18.100 --> 00:32:20.600
ESP, AH, or IP Comp.

00:32:20.870 --> 00:32:26.410
And it will also specify the mode:
tunnel mode or transport mode.

00:32:28.340 --> 00:32:30.500
The security policy
doesn't give us everything,

00:32:30.500 --> 00:32:31.040
though.

00:32:31.040 --> 00:32:34.680
We still need an algorithm and a key.

00:32:34.680 --> 00:32:37.540
We have security associations
to keep track of that.

00:32:37.540 --> 00:32:42.150
The security policy gives us a general,
"This is the traffic that should be using

00:32:42.150 --> 00:32:46.240
IPsec and this is the protocol." But when
communicating with a specific host,

00:32:46.240 --> 00:32:50.940
we need to know a key that's unique
to that host and maybe a different

00:32:50.940 --> 00:32:53.020
algorithm that's unique to that host.

00:32:53.020 --> 00:32:58.180
A security association lets us do that,
and it does it in one direction only.

00:32:58.180 --> 00:33:00.820
In order to encrypt traffic to one host,
we may need at least two

00:33:00.820 --> 00:33:02.810
security associations:
one for traffic sent to the

00:33:02.810 --> 00:33:07.140
host and one for traffic coming
back from that host to us.

00:33:07.420 --> 00:33:11.430
Security Association does keep
track of the algorithm and the key.

00:33:11.470 --> 00:33:13.670
It can also have timeouts,
so you can have keys

00:33:13.670 --> 00:33:16.740
expire for better security.

00:33:17.860 --> 00:33:20.660
Setting up security associations
would be a real pain to do manually,

00:33:20.810 --> 00:33:25.400
so there's Internet Key Exchange, or Ike,
which lets you authenticate... Ike

00:33:25.400 --> 00:33:29.670
will communicate with a remote host
and authenticate the keys... Sorry.

00:33:29.900 --> 00:33:33.120
Will securely communicate with a
remote host and authenticate the remote

00:33:33.140 --> 00:33:36.800
host using either pre-shared keys,
certificates, or Kerberos.

00:33:36.800 --> 00:33:40.930
And it will then negotiate an algorithm,
whether it's an encryption algorithm

00:33:40.930 --> 00:33:45.380
or an authentication algorithm,
and it will exchange any keys.

00:33:47.300 --> 00:33:54.300
In Mac OS X, we've got two APIs for
setting the IPSec stuff.

00:33:54.300 --> 00:33:57.660
We've got the PFKey socket,
which lets you open a socket

00:33:57.810 --> 00:34:00.940
and then set security policies
and security associations.

00:34:01.020 --> 00:34:07.870
You can also receive notifications
when there's a security association

00:34:07.870 --> 00:34:11.990
that's missing or when somebody
sets a policy or an association.

00:34:12.050 --> 00:34:16.220
It requires root privileges
for pretty obvious reasons.

00:34:16.230 --> 00:34:22.100
IPsec Policy Socket Option lets you
set the policy on a per-socket basis.

00:34:22.100 --> 00:34:23.170
Your application can use this.

00:34:23.230 --> 00:34:25.940
This does not require root unless
you're trying to bypass IPsec.

00:34:28.960 --> 00:34:31.960
In Jaguar, we have two tools.

00:34:31.960 --> 00:34:33.840
We've got SetKey and Raccoon.

00:34:33.960 --> 00:34:36.840
SetKey is a tool that lets you
manually set security policies

00:34:36.840 --> 00:34:38.740
and security associations.

00:34:38.910 --> 00:34:42.300
And Raccoon is a daemon
that implements Ike.

00:34:42.700 --> 00:34:46.010
It'll exchange the keys if a
security association is missing.

00:34:46.010 --> 00:34:49.700
And then it'll create the
security associations.

00:34:49.700 --> 00:34:52.700
Raccoon does not run
by default as we ship.

00:34:52.700 --> 00:34:58.250
And I'm going to give you a quick
demo of IPSec running on Jaguar.

00:35:01.850 --> 00:35:04.750
So I'm going to go ahead
and launch Etherpeak.

00:35:04.810 --> 00:35:07.490
Actually,
I've already got Etherpeak running.

00:35:07.500 --> 00:35:11.120
And we're going to go ahead
and bring up Internet Explorer.

00:35:11.120 --> 00:35:14.150
And we're going to load a page on
the other demo machine running here.

00:35:17.300 --> 00:35:21.180
And if we go ahead and
look at the packet,

00:35:21.180 --> 00:35:23.050
we can actually see a
lot of the transaction.

00:35:23.060 --> 00:35:27.340
We can see the get, the get,
and if we keep going,

00:35:27.340 --> 00:35:30.090
we can probably see the
contents of the page.

00:35:30.380 --> 00:35:34.300
Which is not too useful if you're
really interested in security.

00:35:34.430 --> 00:35:39.830
So we can come along here and we
can go ahead and set our policy.

00:35:52.400 --> 00:35:54.400
We'll try that again.

00:35:54.400 --> 00:35:59.400
Clear the packets.

00:35:59.400 --> 00:36:04.360
And this time it used Ike to
try and negotiate the keys.

00:36:05.600 --> 00:36:12.100
[Transcript missing]

00:36:12.490 --> 00:36:16.230
We have all of the data is encrypted
using ESP and we can no longer

00:36:16.230 --> 00:36:19.400
see the contents of the web page.

00:36:19.430 --> 00:36:30.120
So with that, I'd like to bring up
Laurent to talk about IPv6.

00:37:00.600 --> 00:46:22.500
[Transcript missing]

00:46:23.050 --> 00:46:28.180
So, a little bit more about the
IPv6 auto-configuration.

00:46:28.220 --> 00:46:32.920
It's an Apple-talk-like ease-of-use,
you know, ease-of-setup for IP.

00:46:35.640 --> 00:46:40.800
Those link local addresses that you have,
this is a little bit for support for

00:46:40.800 --> 00:46:44.240
HADOC networking and home networking
where you don't have a router and

00:46:44.590 --> 00:46:48.180
you can still have IP addresses.

00:46:48.180 --> 00:46:52.070
Some of this has been ported back,
if you want,

00:46:52.070 --> 00:46:59.660
in the v4 space where you get those 169
addresses for the auto-configuration.

00:47:00.080 --> 00:47:05.400
IPv6 came with this first and
it's designed from the start.

00:47:05.400 --> 00:47:09.900
In our case, it's all done in the kernel
where basically we're going

00:47:09.970 --> 00:47:14.240
to try to get the link local
address based on your MAC address.

00:47:14.300 --> 00:47:18.860
All this fits very well.

00:47:18.860 --> 00:47:21.570
This afternoon,
there was a rendezvous session,

00:47:21.730 --> 00:47:25.980
but this fits very well with the ideas
behind a rendezvous where basically

00:47:25.980 --> 00:47:29.150
you don't have to do any configuration.

00:47:29.160 --> 00:47:33.120
It doesn't solve any of the DNS problem,
the IPv6 per se.

00:47:33.120 --> 00:47:36.270
It just solves the address
side of the problem here with

00:47:36.340 --> 00:47:38.290
getting link local addresses.

00:47:39.800 --> 00:47:44.520
So, a little diagram about how
auto-configuration works.

00:47:44.520 --> 00:47:47.040
We got here, let's say,
a little setting with two

00:47:47.080 --> 00:47:48.950
machines and one printer.

00:47:49.130 --> 00:47:53.840
And first, by the fact that they're
just connected together,

00:47:53.950 --> 00:47:59.310
each of them will get a guaranteed
unique link local address,

00:47:59.460 --> 00:48:04.310
which is made by each of the
device here running IPv6,

00:48:04.310 --> 00:48:07.500
assuming the printer is IPv6.

00:48:07.500 --> 00:48:10.860
So they can all communicate
together through this address.

00:48:10.860 --> 00:48:14.560
And the scope of this address,
they cannot, of course, do anything else.

00:48:14.610 --> 00:48:16.420
They just communicate in between.

00:48:16.440 --> 00:48:19.270
Let's say in this case,
the case of the convention center,

00:48:19.270 --> 00:48:23.330
we got a site local address,
in which case we can communicate

00:48:23.330 --> 00:48:26.430
at a little bit of a higher level.

00:48:26.470 --> 00:48:30.260
We can cross the link local boundary
because we have a router here,

00:48:30.260 --> 00:48:33.020
which gives us a site local address.

00:48:33.020 --> 00:48:37.380
But we still cannot get to the internet
because this is just a local address.

00:48:37.480 --> 00:48:44.290
Now, the router is sending us a
routing advertisement telling us,

00:48:44.360 --> 00:48:48.120
you know, giving us some address,
some global addresses,

00:48:48.120 --> 00:48:52.720
in which case we'll acquire those
addresses automatically and we'll form

00:48:52.720 --> 00:48:57.040
an address based on our MAC address
from the prefix the router is sending,

00:48:57.040 --> 00:49:00.750
which will give us global
connectivity to the internet.

00:49:01.310 --> 00:49:04.490
So, IPv6 in Mac OS X.

00:49:04.580 --> 00:49:08.920
So,
you probably heard the session before.

00:49:08.920 --> 00:49:14.830
Our implementation of IPsec and IPv6
is based on the FreeBSD CAME stack,

00:49:14.860 --> 00:49:19.320
which means that we have in the kernel,
in the Darwin kernel,

00:49:19.350 --> 00:49:23.800
we have a stack which is pretty
close to what is in FreeBSD 4.4 now,

00:49:23.800 --> 00:49:26.180
and it's based from the work from CAME.

00:49:26.880 --> 00:49:31.360
And we'll see a little bit of the
details of that for Mac OS X in Jaguar.

00:49:31.360 --> 00:49:34.590
So, all this is on your CD,
on your Jaguar CD.

00:49:34.590 --> 00:49:35.930
IPv6 is turned on.

00:49:35.940 --> 00:49:39.390
You have the link local addresses,
and if I start a router here,

00:49:39.430 --> 00:49:42.880
you're all going to get,
my machine is going to be overloaded,

00:49:42.880 --> 00:49:45.510
but you're all going to
get a global address.

00:49:45.580 --> 00:49:48.490
So, a lot of the mechanisms are in there.

00:49:48.490 --> 00:49:52.010
We still have some work to
do on some applications,

00:49:52.010 --> 00:49:56.560
things like this, but the basic kernel
parts are all in IPsec.

00:49:56.640 --> 00:49:59.500
in Jaguar right now.

00:50:00.400 --> 00:51:51.000
[Transcript missing]

00:51:52.080 --> 00:51:55.100
The stack itself is a
support for transitions.

00:51:55.100 --> 00:51:58.100
We have what we call a
dual stack implementation,

00:51:58.100 --> 00:52:02.220
which means that we
don't have IPv6 or IPv4.

00:52:02.220 --> 00:52:03.320
We have two stacks.

00:52:03.340 --> 00:52:10.310
You can have IPv6 and IPv4
running at the same time.

00:52:10.310 --> 00:52:13.840
If you have an IPv4 address, that's fine.

00:52:13.840 --> 00:52:16.820
IPv6 can still work and vice versa.

00:52:17.520 --> 00:52:22.940
Another thing for transitions
that we have in Jaguar is a 624.

00:52:22.940 --> 00:52:28.220
624 is an IPv6 tunnel over IPv4.

00:52:28.220 --> 00:52:33.340
What it means is that it can give
you global IPv6 connectivity even

00:52:33.690 --> 00:52:36.000
if you only have an IPv4 address.

00:52:36.000 --> 00:52:40.630
That's a good way for people like us to
test things to see if the application

00:52:40.750 --> 00:52:43.420
is working fine with IPv6 and so on.

00:52:43.420 --> 00:52:48.260
What it does is that it's going to
call to... Once it's configured,

00:52:48.280 --> 00:52:49.740
it's called the device STF.

00:52:50.370 --> 00:52:57.260
It will use your IPv4 address,
your globally accessible IPv4 address,

00:52:57.740 --> 00:53:02.860
and then call to a router
which will route this IPv6

00:53:02.860 --> 00:53:05.200
address to the global IPv6 net.

00:53:05.260 --> 00:53:08.620
This is embedded in IPv4 packets,
so you don't need to

00:53:08.660 --> 00:53:10.320
have IPv6 all the way.

00:53:10.320 --> 00:53:15.480
Let your machine be part
of a bigger IPv6 network.

00:53:16.630 --> 00:53:18.630
If you don't have all
the links being IPv6,

00:53:18.810 --> 00:53:20.330
that's an interesting way.

00:53:20.340 --> 00:53:24.480
The IPv6 routing is part of
what we have in Mac OS X.

00:53:24.480 --> 00:53:28.760
You could potentially turn
this into a full IPv6 router.

00:53:28.760 --> 00:53:32.440
Another thing that we have in
there is the auto-configuration

00:53:32.510 --> 00:53:34.480
and the neighbor discovery.

00:53:34.480 --> 00:53:40.940
Turn by default on your CDs is
listening for router advertisement.

00:53:40.940 --> 00:53:43.700
If there is a router
advertising prefixes,

00:53:43.700 --> 00:53:45.460
we'll pick up the address.

00:53:46.120 --> 00:53:51.560
We'll use that as a configuration
and we'll use this as a router or

00:53:51.560 --> 00:53:53.320
default router to the IPv6 world.

00:53:53.340 --> 00:53:56.380
That's something which is in Jaguar.

00:53:56.380 --> 00:54:02.840
In Jaguar also,
one caveat is the DNS for IPv6.

00:54:02.940 --> 00:54:07.200
We're doing the DNS resolution over V4.

00:54:07.200 --> 00:54:10.560
There is no DNS over V6
in Jaguar at this point.

00:54:10.600 --> 00:54:12.900
That's a little bit of a limitation.

00:54:12.900 --> 00:54:18.580
What happens is that you can get...
Let's say you're looking up an

00:54:18.580 --> 00:54:22.580
address like mymachine at apple.com.

00:54:22.580 --> 00:54:27.800
If your DNS is configured
with Quad Air Records,

00:54:27.800 --> 00:54:33.900
it will send back information
about the IPv6 addresses configured

00:54:33.900 --> 00:54:39.110
for the Quad Air Records as
well as the IPv4 addresses.

00:54:39.120 --> 00:54:42.630
Then in your program,
you can choose which address you want to

00:54:42.630 --> 00:54:44.320
use to communicate with the other side.

00:54:44.320 --> 00:54:47.990
If you can go through this,
you can go through the six.

00:54:48.910 --> 00:54:54.190
Some of the tools that we have in Jaguar,
ifconfig,

00:54:54.200 --> 00:54:58.770
right now that's the only way you'll
see that you're on IPv6 is if you go

00:54:58.790 --> 00:55:04.200
in the terminal and do an ifconfig-a,
you'll see the fe80 and something

00:55:04.200 --> 00:55:08.900
at the last 64 bits that looks like
your Mac address with an ffe inside.

00:55:08.900 --> 00:55:11.640
That's not going to show
up in the control panel.

00:55:11.640 --> 00:55:13.060
You need to do ifconfig.

00:55:13.060 --> 00:55:14.800
You can also do a man-ifconfig.

00:55:14.800 --> 00:55:22.100
We updated the man page for those
tools and add yourself an IPv6 address.

00:55:22.160 --> 00:55:27.530
Or you can also configure the tunnels,
IPv4 to v6 tunnels through ifconfig.

00:55:27.550 --> 00:55:31.660
Ping6, which, you know, like ping,
lets you ping hosts.

00:55:31.820 --> 00:55:36.300
There is a difference here that
this is a way I saw was installed

00:55:36.300 --> 00:55:38.960
at Jaguar on their PowerBooks here.

00:55:38.960 --> 00:55:42.840
Is that if I do a multicast ping,
I can tell, you know, everybody.

00:55:43.060 --> 00:55:45.530
Who has an IPv6 address
is going to respond.

00:55:45.540 --> 00:55:49.900
And there is some way to do a
multicast ping on the link to

00:55:50.040 --> 00:55:52.540
see who has IPv6 addresses.

00:55:52.540 --> 00:55:57.610
Trace route 6, you know,
same thing as trace route to see.

00:55:57.740 --> 00:55:58.620
Netstat has been updated.

00:55:58.620 --> 00:56:01.140
It's going to show if
you do a netstat-rn,

00:56:01.140 --> 00:56:04.050
it's going to show your route with IPv6.

00:56:04.480 --> 00:56:06.940
Route, also to add your route.

00:56:07.010 --> 00:56:09.620
TCP dump,
which actually in the CD doesn't work.

00:56:09.620 --> 00:56:12.600
One of the libraries is
not working for IPv6.

00:56:12.600 --> 00:56:14.360
But it's there also.

00:56:14.360 --> 00:56:18.320
And RT-SOL,
which is for the router solicitation.

00:56:18.320 --> 00:56:20.730
Some of the apps also are v6-aware.

00:56:21.070 --> 00:56:23.360
SSH, FTP, Telnet.

00:56:23.360 --> 00:56:26.430
All those, I think there are still
some bugs on your CD.

00:56:26.500 --> 00:56:29.980
And they are, all those are open source.

00:56:29.980 --> 00:56:32.980
So you can go on Darwin and
look at what they are doing.

00:56:33.010 --> 00:56:36.840
And they are a good source of
protocol independent implementation.

00:56:36.840 --> 00:56:40.960
Because let's,
in the case of SSH or FTP or Telnet,

00:56:40.960 --> 00:56:42.110
they work the same executable.

00:56:42.150 --> 00:56:44.550
It's working for both v4 and v6.

00:56:44.580 --> 00:56:48.440
And they have some example in there,
you know, showing how they decide

00:56:48.440 --> 00:56:51.390
which address and which,
you know,

00:56:51.500 --> 00:56:56.380
protocol to use if they use v4 or v6,
depending of what the DNS is getting

00:56:57.800 --> 00:57:02.100
So on that, for you, for developers,
what you should be aware,

00:57:02.100 --> 00:57:07.210
even if you're not thinking right
now about getting IPv6 completely

00:57:07.210 --> 00:57:10.140
implemented in your application,
what you should be aware of.

00:57:10.260 --> 00:57:13.240
Of course,
that IPv6 addresses are bigger.

00:57:13.240 --> 00:57:18.120
They're 128 bits instead of 32 bits.

00:57:18.180 --> 00:57:21.320
So all your structure,
all the assumption you might be doing,

00:57:21.320 --> 00:57:24.830
thinking, ah,
all I'm going to get is a 4-byte address.

00:57:25.060 --> 00:57:27.910
They're not going to work because
in the list of addresses you'll get,

00:57:27.970 --> 00:57:30.550
you may get and you will
get the link local address,

00:57:30.550 --> 00:57:31.950
which is 128 bits.

00:57:31.960 --> 00:57:34.780
So that's one of the things.

00:57:34.780 --> 00:57:36.580
It's on the CD.

00:57:36.580 --> 00:57:41.460
It's like we've been catching a few
mistakes in our code where people were

00:57:41.460 --> 00:57:46.860
making assumptions about the length of
the addresses they were getting back.

00:57:46.920 --> 00:57:54.110
So nowadays, it's true for v4,
but to a lesser extent.

00:57:54.480 --> 00:57:57.250
But now with IPv6 interfaces,
when you're looking at interfaces,

00:57:57.250 --> 00:57:58.540
they have multiple addresses.

00:57:58.660 --> 00:58:04.220
So you cannot do things like
identifying an interface by its address.

00:58:04.220 --> 00:58:10.390
Because you have multiple addresses and
they are auto-configured in many cases.

00:58:10.420 --> 00:58:14.430
So the address might change because
the router advertised something else.

00:58:14.500 --> 00:58:17.780
So don't identify an
interface by its address.

00:58:17.880 --> 00:58:21.750
You cannot, as I said,
you cannot assume the AFI net length,

00:58:21.750 --> 00:58:23.480
you know, 32 bits.

00:58:24.010 --> 00:58:27.350
You have a new function and there's
a good man page on this one,

00:58:27.360 --> 00:58:29.640
which is called getIF adders.

00:58:29.740 --> 00:58:32.550
And this is the new way
of sorting through the

00:58:32.620 --> 00:58:34.630
addresses you're going to get.

00:58:34.720 --> 00:58:38.620
That gives you a table back with all
the addresses of all the interfaces.

00:58:40.150 --> 00:58:44.280
And as we mentioned before,
address can be auto-configured.

00:58:44.280 --> 00:58:46.860
There is multiple scopes for addresses.

00:58:46.860 --> 00:58:52.750
And there is rules and there is macros
and tools to decide which address is

00:58:52.750 --> 00:58:54.590
the best to use in which circumstances.

00:58:54.900 --> 00:59:00.640
To that,
if you're interested in looking at this,

00:59:01.130 --> 00:59:06.590
there is a basic BSD API, the RFC 2553,
which talk about the IPv4

00:59:06.590 --> 00:59:08.360
binary compatibility.

00:59:08.360 --> 00:59:11.440
All those functions work for v4.

00:59:11.440 --> 00:59:15.700
And one of the goals there was
everything that has been compiled

00:59:15.700 --> 00:59:18.590
for v4 still works with v6 in there.

00:59:18.820 --> 00:59:22.270
However, you don't take advantage
of the v6 functionality.

00:59:22.780 --> 00:59:24.710
and Alex Schroeder.

00:59:24.710 --> 00:59:29.140
The RFC gives some very
good advice about IPv6,

00:59:29.140 --> 00:59:32.540
IPv4 independent programming.

00:59:32.540 --> 00:59:37.480
You can know what the caveats are
here and what to do to get your

00:59:37.480 --> 00:59:40.960
application or protocol independent.

00:59:40.990 --> 00:59:46.160
GetAdderInfo is now the new
main address independent API.

00:59:46.580 --> 00:59:51.200
This is what lets you choose v4,
v6 and you get to use it

00:59:51.380 --> 00:59:52.660
instead of getOsByName.

00:59:52.660 --> 00:59:56.500
getOsByName only works, it still works,
but only works for v4.

00:59:56.500 --> 01:00:01.400
It won't be able because it
assumes AFInet lens for addresses.

01:00:01.400 --> 01:00:02.970
Look at GetAdderInfo.

01:00:02.970 --> 01:00:05.520
GetAdderInfo is a bit of a complex API.

01:00:05.520 --> 01:00:08.620
It does a lot of things,
but this is a new API which

01:00:08.620 --> 01:00:10.300
is address independent.

01:00:10.300 --> 01:00:10.940
It would work for all of us.

01:00:10.940 --> 01:00:12.940
It would work with v6 and v4.

01:00:13.260 --> 01:00:16.910
Check the JaguarMan pages
for the new resolver calls.

01:00:16.940 --> 01:00:23.660
GetNameInfo, getIPnodeByName,
inetp2n and inetn2pr is the main one.

01:00:24.000 --> 01:00:30.090
They are all more or less based
or there are some specific duty

01:00:30.090 --> 01:00:33.300
function over GetAdderInfo.

01:00:33.710 --> 01:00:36.170
Those are the new calls.

01:00:37.920 --> 01:00:41.440
And also if you're trying
to do an application which,

01:00:41.520 --> 01:00:45.390
you know,
take advantage of the IPv6 features,

01:00:45.390 --> 01:00:51.820
you get a more advanced API,
the RFC2292 is describing it,

01:00:51.820 --> 01:00:57.120
and lets you do, you know,
some of the new cool stuff with multicast

01:00:57.120 --> 01:01:01.430
and IPv6 or access to the raw IPv6,
you know, sockets.

01:01:01.570 --> 01:01:05.370
And for the higher level API,
you can use CF Networks.

01:01:05.460 --> 01:01:11.750
CF Networks is IPv6 aware and depending,
you know, if the address you're trying

01:01:11.750 --> 01:01:17.310
to resolve has any IPv6,
it will deal with that and that will

01:01:17.310 --> 01:01:23.570
make things much simpler for you so
you don't have to worry about it.

01:01:23.660 --> 01:01:27.220
And for more details about
the protocol independence,

01:01:27.480 --> 01:01:30.580
this is the right URL in
the CAME.net newsletter.

01:01:30.580 --> 01:01:34.470
It talks about what to do for getting
your tools or your daemons or,

01:01:34.590 --> 01:01:37.570
you know,
being able-- If you're a listener,

01:01:37.570 --> 01:01:41.630
don't use a socket or in,
use a socket or storage in which case you

01:01:41.630 --> 01:01:46.630
will receive a connection for V4 and for
V6 and you don't have to worry about it.

01:01:46.660 --> 01:01:50.250
If you're using something, you know,
just for V4,

01:01:50.260 --> 01:01:53.020
you won't be able to get V6 sockets.

01:01:54.550 --> 01:01:59.060
So with that, the roadmap for today.

01:01:59.060 --> 01:02:01.460
So the Darwin roadmap, that was Monday.

01:02:01.500 --> 01:02:05.500
Darwin kernel yesterday morning.

01:02:05.500 --> 01:02:08.540
Managing kernel extension,
where some of the things Vincent was

01:02:08.690 --> 01:02:12.060
talking about are also in details,
was yesterday morning.

01:02:12.720 --> 01:02:15.840
Tomorrow morning,
developing for performance.

01:02:15.840 --> 01:02:19.100
That's another thing that
you might be interested in.

01:02:19.250 --> 01:02:25.520
Or on the CoreOS Networking
Feedback Forum tomorrow afternoon.

01:02:25.530 --> 01:02:28.590
Another thing which is
not in this roadmap here,

01:02:28.590 --> 01:02:32.190
but we need to add, is the ZeroConf,
or AKA rendezvous,

01:02:32.190 --> 01:02:34.320
this afternoon at 2 p.m.

01:02:34.320 --> 01:02:36.170
And I think the location changed.

01:02:36.230 --> 01:02:38.240
It's now in the main hall in Hall 2.

01:02:38.240 --> 01:02:41.520
So instead of whatever room it was in.

01:02:41.520 --> 01:02:42.700
So it's in the big hall.

01:02:42.720 --> 01:02:43.030
So it's in the main hall here.

01:02:43.060 --> 01:02:45.680
Who to contact?

01:02:46.020 --> 01:02:46.280
Tom.

01:02:46.280 --> 01:02:48.440
Tom Weyer is your contact.

01:02:48.700 --> 01:02:52.630
And Vincent is our manager here.

01:02:52.680 --> 01:02:57.390
For more information,
for Kame IPsec and IPv6,

01:02:57.390 --> 01:03:00.770
you can go on the kame.net.

01:03:00.860 --> 01:03:04.790
It's got a very good page with
pointers to a lot of things.

01:03:04.900 --> 01:03:06.620
FreeBSD out-tools.

01:03:06.700 --> 01:03:10.000
And it tells you a little
bit of demos that Josh did.

01:03:10.040 --> 01:03:11.500
How to do that.

01:03:11.670 --> 01:03:12.700
You know, we got some cool tools.

01:03:12.700 --> 01:03:16.720
They're a little bit
complex to configure.

01:03:16.720 --> 01:03:19.900
But once you get the hang of it,
you know, it's pretty cool.

01:03:19.920 --> 01:03:22.370
Some other performance tip.

01:03:22.440 --> 01:03:26.560
The perf book on the
developer.apple.com page.

01:03:26.560 --> 01:03:31.410
And some Darwin programming
documentation in the tech pubs.

01:03:31.460 --> 01:03:34.490
So with that,
I'll call back Tom for the QA.

01:03:34.500 --> 01:03:35.240
Thanks.
WEBVTT

00:00:03.000 --> 00:00:05.210
Hello everyone,
thank you very much for coming,

00:00:05.210 --> 00:00:08.140
or thank you very much
for sticking around.

00:00:08.180 --> 00:00:11.760
Welcome to session 506,
OpenGL Integrated Graphics 2.

00:00:12.510 --> 00:00:16.940
This section takes the discussion
of OpenGL as a fundamental layer

00:00:16.940 --> 00:00:20.840
for graphics and imaging for
Mac OS X to the next level.

00:00:20.900 --> 00:00:27.080
In Jaguar,
OpenGL is indeed the fundamental part

00:00:27.080 --> 00:00:32.100
of accelerating graphics and imaging.

00:00:32.450 --> 00:00:36.180
And in this session,
we'll discuss techniques on

00:00:36.180 --> 00:00:38.900
how to integrate QuickTime,
OpenGL,

00:00:38.900 --> 00:00:43.890
and Quartz to achieve unprecedented
results and creative possibilities.

00:00:43.900 --> 00:00:46.800
So to present session 506,
Integrated Graphics 2,

00:00:46.800 --> 00:00:49.890
I would like to welcome to the
stage OpenGL engineer Ken Dyke.

00:00:49.900 --> 00:00:49.900
Hello everyone,
thank you very much for coming,

00:00:49.900 --> 00:00:49.900
or thank you for sticking around.

00:00:49.900 --> 00:00:49.900
Welcome to session 506,
OpenGL Integrated Graphics 2.

00:00:49.900 --> 00:00:49.900
This session takes the discussion
of OpenGL as a fundamental layer

00:00:49.900 --> 00:00:49.900
for graphics and imaging for
Mac OS X to the next level.

00:00:49.900 --> 00:00:51.230
engineer Ken Dyke.

00:00:51.280 --> 00:00:52.480
Thanks, Sergio.

00:00:56.230 --> 00:00:58.100
All right.

00:00:58.100 --> 00:01:00.510
Come on.

00:01:00.570 --> 00:01:00.950
That's me.

00:01:01.070 --> 00:01:03.100
I'm not really a mad scientist,
but it looks cool on your business cards.

00:01:03.100 --> 00:01:07.880
So today we're going to talk
about integrating 2D content

00:01:07.880 --> 00:01:12.200
with OpenGL in a little bit more
detail than Jeff Stahl just talked

00:01:12.200 --> 00:01:13.780
about in the previous session.

00:01:13.780 --> 00:01:16.940
We're going to go over
things like how to get really

00:01:17.050 --> 00:01:20.750
high-performance QuickTime video in,
how to pull in things like DV,

00:01:20.750 --> 00:01:23.920
how to pull in Quartz 2D
content into OpenGL with as

00:01:23.920 --> 00:01:25.980
little overhead as possible.

00:01:26.010 --> 00:01:29.220
I'm going to go over doing
compositing with OpenGL a little bit.

00:01:29.220 --> 00:01:32.070
This is just to sort of give you
guys a feel for the kinds of stuff

00:01:32.070 --> 00:01:34.960
we're doing in Quartz Xtreme,
but to show you guys how to do

00:01:34.960 --> 00:01:36.720
it in your own applications.

00:01:36.740 --> 00:01:40.040
And then finally I want to go over just
a couple of little examples of doing

00:01:40.040 --> 00:01:45.370
image processing effects with GL once
you've got your content into the system.

00:01:46.920 --> 00:01:50.160
So,
as far as 2D content in the system goes,

00:01:50.220 --> 00:01:51.620
we've basically got two different things.

00:01:51.710 --> 00:01:56.220
We've got Quartz, sort of new,
high-performance, anti-aliased,

00:01:56.310 --> 00:01:59.140
really nice-looking 2D system in OS X.

00:01:59.320 --> 00:02:00.410
And then we've got QuickTime.

00:02:00.540 --> 00:02:04.850
Now, probably for the most of you,
QuickTime is probably going to be

00:02:04.850 --> 00:02:08.930
the most important thing if you're
doing compositing work for film

00:02:09.130 --> 00:02:11.500
or even potentially game effects.

00:02:11.650 --> 00:02:12.900
So let's just jump right in.

00:02:13.130 --> 00:02:15.450
So, sample code already.

00:02:15.650 --> 00:02:18.970
So if you want to pull
stuff in from Quartz,

00:02:19.180 --> 00:02:21.660
the trick you want to do is
basically create an off-screen sort

00:02:21.820 --> 00:02:23.330
of rendering context in Quartz.

00:02:23.450 --> 00:02:27.600
And the way you do this is
with CG bitmap context create,

00:02:27.600 --> 00:02:31.600
and you pass in, for example, up here,
where your data is going to live,

00:02:31.740 --> 00:02:37.050
how wide is it, how high is it, you know,
number of bits per sample, bytes per row,

00:02:37.050 --> 00:02:40.100
all that type of junk
you'd normally want.

00:02:40.130 --> 00:02:42.830
And then the other trick you
want to do is you want to use,

00:02:43.010 --> 00:02:45.100
similar to what Jeff showed
in the last session,

00:02:45.100 --> 00:02:49.100
you want to, like, Quartz is going to do
that in ARGB format.

00:02:49.100 --> 00:02:52.530
So to get ARGB out of OpenGL,
you use GO BGRA and

00:02:52.530 --> 00:02:54.880
GO unsigned in 888 reversed.

00:02:55.100 --> 00:03:00.090
Don't blame me for the wacky naming
scheme the ARB came up with on this.

00:03:00.090 --> 00:03:04.220
And the other thing that's really
important in a minute is that CG content

00:03:04.220 --> 00:03:06.600
is always rendered pre-multiplied.

00:03:06.600 --> 00:03:08.600
And Peter can yell at me if that's wrong,
but I believe that's the case.

00:03:08.600 --> 00:03:12.350
And that's really important
for when you're doing blending,

00:03:12.350 --> 00:03:14.860
and I'll get into that
in a minute as well,

00:03:14.860 --> 00:03:16.870
as to what the difference is.

00:03:18.880 --> 00:03:23.020
So, just a real quick demo
of doing Quartz 2D,

00:03:23.020 --> 00:03:25.630
and I will apologize,
it's not as flashy as some

00:03:25.670 --> 00:03:27.780
of the stuff yesterday.

00:03:29.460 --> 00:03:30.900
In fact, it's pretty non-flashy.

00:03:30.900 --> 00:03:32.560
Oops, I forgot to recompile it.

00:03:32.650 --> 00:03:34.280
So here's a partial arc.

00:03:34.280 --> 00:03:36.600
Not real interesting,
but it'll get more interesting

00:03:36.610 --> 00:03:39.120
in a minute when I combine
this with some other content.

00:03:39.160 --> 00:03:42.850
So I just want to show you
the code real quick for,

00:03:42.850 --> 00:03:46.160
again, what this looks like in
full for setting this up.

00:03:46.160 --> 00:03:50.130
Oh, no.

00:03:50.130 --> 00:03:50.130
Stop that.

00:03:52.300 --> 00:03:53.300
I don't want to release notes either.

00:03:53.300 --> 00:03:56.300
I know all about the new project builder.

00:03:56.340 --> 00:03:59.580
So I'll cover this application
in a little bit more detail

00:03:59.580 --> 00:04:02.440
later on in the session,
but basically it's just a

00:04:02.440 --> 00:04:04.020
big compositing lab thing.

00:04:04.400 --> 00:04:06.500
So what I've got here

00:04:07.040 --> 00:04:09.600
As you can see,
I set up all this internal

00:04:09.600 --> 00:04:12.940
information in the application,
such as, you know, again, bytes per row.

00:04:13.000 --> 00:04:15.000
And you can see that I'm actually
padding it out in this case,

00:04:15.000 --> 00:04:18.250
because for some of the stuff I'm
going to talk about in a little bit,

00:04:18.260 --> 00:04:20.990
OpenGL likes this particular
case to be 32-byte aligned.

00:04:20.990 --> 00:04:24.460
And I allocate the memory for it,
set some OpenGL parameters that

00:04:24.460 --> 00:04:27.520
I'll use later on in the app,
and then I just do the CG bitmap

00:04:27.520 --> 00:04:29.110
context create right here.

00:04:29.400 --> 00:04:30.640
Pretty straightforward.

00:04:30.710 --> 00:04:34.000
Apologize for the formatting.

00:04:34.000 --> 00:04:37.240
And then I've got a really simple
case of drawing something with it.

00:04:37.240 --> 00:04:39.780
In this case,
I'm basically just clearing the

00:04:39.780 --> 00:04:42.990
entire context out so that it
starts on a clear background,

00:04:43.230 --> 00:04:44.760
and then I'm just adding a simple art.

00:04:44.850 --> 00:04:47.000
And, for example,
I can go in and change this,

00:04:47.000 --> 00:04:48.330
because I thought I had
compiled it earlier,

00:04:48.340 --> 00:04:50.000
and get a full circle in here.

00:04:50.000 --> 00:04:54.870
So let's do this on the fly real quick.

00:04:58.300 --> 00:05:00.340
If I was really studly,
I would try and do something more

00:05:00.340 --> 00:05:04.790
interesting with CG than draw an arc,
but I ran out of time.

00:05:06.470 --> 00:05:08.540
So we can go and add that layer back in.

00:05:08.560 --> 00:05:11.020
And now we get a full, nice,
anti-alias circle.

00:05:11.160 --> 00:05:15.370
So this is basically getting turned into
a texture that you can then drag around,

00:05:15.370 --> 00:05:18.290
and it's got nice anti-alias
edges on it and everything.

00:05:18.390 --> 00:05:20.940
That's pretty cool, but again,
it'll be a little bit more

00:05:20.940 --> 00:05:22.990
interesting in just a few minutes.

00:05:23.070 --> 00:05:25.210
Can I go back to the slides, please?

00:05:27.040 --> 00:05:30.740
So, I'm going to spend a lot of time
talking about QuickTime because

00:05:30.740 --> 00:05:34.900
this is where I probably spent the
longest amount of time trying to get,

00:05:34.900 --> 00:05:36.490
you know,
I wanted to do high-performance stuff

00:05:36.560 --> 00:05:39.880
with QuickTime and there's all this
really cool stuff you can do with it,

00:05:39.890 --> 00:05:41.940
but there's a lot of issues
I ran into with getting the

00:05:42.040 --> 00:05:43.500
performance through the system.

00:05:43.550 --> 00:05:48.010
Normally, OpenGL tends to make a lot of
copies and we just can't do that.

00:05:48.340 --> 00:05:51.450
You know, if you're doing standard
definition video in YUV format,

00:05:51.590 --> 00:05:55.600
720, 480, 30 frames per second or so,
that's about 20 megabytes per second.

00:05:55.690 --> 00:05:56.560
That's not too bad.

00:05:56.560 --> 00:05:59.740
You know, even with some data copies,
we've got the bandwidth in the

00:05:59.850 --> 00:06:01.390
system and we can deal with that.

00:06:01.460 --> 00:06:04.470
However,
if you're doing high-definition video,

00:06:04.470 --> 00:06:10.920
you know, like 1920 by 1024 or whatever,
that's like 120 megabytes per second.

00:06:10.920 --> 00:06:12.820
That's a lot of data to
get through the machine.

00:06:12.820 --> 00:06:15.320
And you're not going to, like,
be able to pull this off if

00:06:15.320 --> 00:06:17.970
you're using a CPU to copy
this data around all the time.

00:06:17.980 --> 00:06:22.020
So, we want to get on the
fast path in OpenGL.

00:06:22.020 --> 00:06:24.640
You know,
what's the fastest path we can do?

00:06:25.600 --> 00:06:28.560
You know, and we also have to get
rid of all the CPU copies.

00:06:28.570 --> 00:06:30.180
You know,
we don't want to be touching the pixels.

00:06:30.180 --> 00:06:33.170
Or at least,
as much as we can get away with.

00:06:33.270 --> 00:06:36.730
If you're using DV or Sorensen or MPEG,
obviously the CPU is going to

00:06:36.730 --> 00:06:38.500
have to decompress the data.

00:06:38.500 --> 00:06:40.160
But once it's there
and it's in its buffer,

00:06:40.160 --> 00:06:41.640
we don't want to touch it anymore.

00:06:45.030 --> 00:06:49.690
So, one of the first things we're going
to do is use the GL Apple Client

00:06:49.690 --> 00:06:51.650
Storage extension in OpenGL.

00:06:51.780 --> 00:06:54.260
Now what this does in
a nutshell is it lets,

00:06:54.320 --> 00:06:58.360
instead of OpenGL immediately making a
copy of your data when you give it the

00:06:58.360 --> 00:07:03.450
pointer for the GL Text Image 2D call,
it lets OpenGL just remember that pointer

00:07:03.490 --> 00:07:05.900
and always refer to your data instead.

00:07:06.100 --> 00:07:08.590
This saves memory,
it saves OpenGL from having

00:07:08.760 --> 00:07:11.550
to make a copy of it,
and generally is going to get

00:07:11.550 --> 00:07:12.890
you pretty good performance.

00:07:12.890 --> 00:07:14.870
Now the only downside is,
is obviously you have

00:07:14.960 --> 00:07:15.870
to keep the data around.

00:07:15.900 --> 00:07:17.520
But if you're going to be using
QuickTime and you're going to

00:07:17.520 --> 00:07:20.760
be using a GL world with it,
you're going to have that data

00:07:21.180 --> 00:07:26.110
buffer around for the life of the
movie you're trying to play back.

00:07:26.820 --> 00:07:30.600
The top line here shows you how you
enable client storage in the system.

00:07:30.600 --> 00:07:31.340
It's really simple.

00:07:31.340 --> 00:07:33.520
It's just a PixelStore I call.

00:07:33.700 --> 00:07:37.200
And the interesting thing about this
that I'll mention is it's sort of sticky.

00:07:37.200 --> 00:07:39.950
If you turn it on,
every text image call you

00:07:39.950 --> 00:07:43.570
make from that point on,
client storage is automatically enabled.

00:07:43.700 --> 00:07:46.170
So if you've got some textures
that you want it on and some

00:07:46.170 --> 00:07:49.320
textures that you want it off,
make sure you keep track of

00:07:49.400 --> 00:07:51.700
which way you set that last time.

00:07:51.700 --> 00:07:54.520
From there on out,
the rest of the calls are exactly like

00:07:54.520 --> 00:07:56.580
you'd specify any other image in OpenGL.

00:07:56.700 --> 00:08:00.560
It's just geobind_texture, geotexture_2d,
give it the name you want,

00:08:00.780 --> 00:08:04.700
and then call geotext_image_2d
to pass in the data.

00:08:04.750 --> 00:08:07.700
Now,
for those of you familiar with OpenGL,

00:08:07.830 --> 00:08:10.970
you can't use client storage
as best as I can remember with

00:08:10.970 --> 00:08:12.700
the default texture in OpenGL.

00:08:12.700 --> 00:08:16.700
Bob can correct me if I'm wrong on that.

00:08:16.720 --> 00:08:20.700
But I believe you have to use other
texture objects other than default

00:08:20.700 --> 00:08:21.700
to be able to set client storage.

00:08:21.700 --> 00:08:24.710
Just something to point out in
case you're trying to use a single

00:08:24.710 --> 00:08:26.700
texture and it's not working for you.

00:08:28.150 --> 00:08:33.100
So the other new extension for
Jaguar is GeoAppleTextureRange.

00:08:33.230 --> 00:08:36.430
Now this is very similar to the vertex
array range stuff that we're going to

00:08:36.540 --> 00:08:39.000
cover in some of the OpenGL sessions.

00:08:39.140 --> 00:08:42.100
So what this does is it sort
of gives a hint to the lower

00:08:42.100 --> 00:08:46.760
level drivers in OpenGL as how
to best store the texture data.

00:08:47.300 --> 00:08:51.000
This is basically just a new
enum type to glTextParameterI.

00:08:51.000 --> 00:08:53.910
Now this is called after
you've created the texture.

00:08:54.020 --> 00:08:56.950
So after you've bound to it
and you've passed in the image,

00:08:57.020 --> 00:08:59.000
you want to call glTextParameterI.

00:08:59.000 --> 00:09:03.000
And I'll have an example of
that here in just a second.

00:09:03.000 --> 00:09:09.000
Now, there's three different
hints basically to this call.

00:09:09.000 --> 00:09:15.000
The first one is you want to tell the
driver just keep your own private copy

00:09:15.000 --> 00:09:19.000
of whatever texture data that you've
gotten from the upper level of OpenGL.

00:09:19.000 --> 00:09:23.000
So normally this is how
OpenGL works by default.

00:09:23.000 --> 00:09:28.830
Normally in the non-client storage case,
what'll happen is

00:09:28.950 --> 00:09:31.800
you'll call glTextImage,
OpenGL Engine will make

00:09:31.800 --> 00:09:34.360
a copy of the data,
and then later on when the driver

00:09:34.360 --> 00:09:37.350
needs to like get it in video memory,
it needs to put it into a

00:09:37.350 --> 00:09:40.000
hardware specific format so
it makes another copy of it,

00:09:40.010 --> 00:09:44.000
and then that can actually be used to
DMA the texture up into the system.

00:09:44.000 --> 00:09:48.000
Texture storage hint, oops,
the old name of it, sorry,

00:09:48.290 --> 00:09:51.750
texture range lets you
change how that works.

00:09:52.000 --> 00:09:55.000
So again, private is how the
driver normally does it.

00:09:55.000 --> 00:09:59.000
So for what we want to use today,
this isn't particularly interesting.

00:09:59.000 --> 00:10:02.750
The one thing I'll mention though is that
this extension doesn't have any issues

00:10:02.750 --> 00:10:04.000
with making changes to the texture.

00:10:04.000 --> 00:10:06.990
You can do it anytime you want,
and you'll never have to worry

00:10:07.000 --> 00:10:11.000
about synchronizing with it because
there's an extra copy involved.

00:10:12.560 --> 00:10:16.760
So, shared basically tells the
OpenGL low-level drivers to tell

00:10:16.760 --> 00:10:20.730
the hardware to try and share
whatever copy directly they're

00:10:20.730 --> 00:10:22.750
getting from OpenGL Engine.

00:10:23.010 --> 00:10:26.090
Now,
if you're using client storage in this,

00:10:26.330 --> 00:10:29.680
this is effectively like having the
hardware do direct AGP texturing

00:10:29.760 --> 00:10:30.640
right from your memory.

00:10:30.740 --> 00:10:33.000
So every single time you
draw a polygon with it,

00:10:33.120 --> 00:10:35.950
the hardware is going to pull
the bits across the AGP bus.

00:10:36.090 --> 00:10:37.990
Now, in some cases,
this can be really useful if you're

00:10:38.060 --> 00:10:40.420
making lots of little minute changes
and you're not drawing a lot.

00:10:40.530 --> 00:10:42.660
But there are some bandwidth
concerns to worry about,

00:10:42.660 --> 00:10:45.310
because, again,
the bits are going to cross the

00:10:45.310 --> 00:10:49.490
bus every single time the hardware
needs to fetch textiles from it.

00:10:49.610 --> 00:10:53.670
So this can be kind of slow
with really large images that

00:10:53.670 --> 00:10:56.500
you're repeatedly drawing with.

00:10:56.830 --> 00:11:00.000
Again, this basically forces
AGP or PCI texturing.

00:11:00.000 --> 00:11:05.100
This does work on the
PCI Radeon and the Rage 128s.

00:11:05.520 --> 00:11:08.160
This also lowers VRAM.

00:11:08.240 --> 00:11:10.040
Obviously,
if the texture is only ever going to

00:11:10.040 --> 00:11:12.830
live in your memory buffer in the system,
we're not going to copy

00:11:12.830 --> 00:11:15.150
it into video memory,
which will leave more room.

00:11:15.160 --> 00:11:18.710
So if you're on a PowerBook,
there may be some cases where you know

00:11:18.710 --> 00:11:22.050
you're going to be low on video memory,
but you can now force the system to keep

00:11:22.110 --> 00:11:26.640
all of its textures in AGP space and
not upload everything to video memory.

00:11:26.780 --> 00:11:29.570
Now in this case,
there is some synchronization

00:11:29.910 --> 00:11:32.240
issues involved,
but as long as you're

00:11:32.240 --> 00:11:35.120
not using client storage,
OpenGL can deal with all the

00:11:35.120 --> 00:11:36.450
synchronization stuff for you.

00:11:36.450 --> 00:11:39.460
But there can be cases where OpenGL will
need to go synchronous internally.

00:11:39.460 --> 00:11:41.990
It'll just sort of been hidden from you.

00:11:42.540 --> 00:11:48.440
Now the last mode basically tells the
driver to tell the hardware directly

00:11:49.420 --> 00:11:53.700
access the data that OpenGL does,
but anytime we've told you to dirty it,

00:11:53.890 --> 00:11:56.370
pull it up into video memory
and keep a cache of it there.

00:11:56.480 --> 00:11:58.680
Now this is basically the
same exact mechanism that the

00:11:58.740 --> 00:12:01.640
Windows Server uses right now to
get window backing stores into video

00:12:01.640 --> 00:12:03.350
memory and sort of leave them there.

00:12:03.400 --> 00:12:07.010
So we'll only upload pieces
of the backing store whenever

00:12:07.610 --> 00:12:09.190
they change in the window.

00:12:09.570 --> 00:12:11.400
This is, you know,
sort of the best of both worlds.

00:12:11.400 --> 00:12:14.390
We get direct access to our texture data,
but it leaves,

00:12:14.530 --> 00:12:18.390
gets to stick around in video
memory for cases where we know

00:12:18.390 --> 00:12:20.400
we're going to use it quite a bit.

00:12:20.500 --> 00:12:22.370
And it's also useful
for the QuickTime case.

00:12:22.560 --> 00:12:27.400
So this again uses a very
high-speed DMA texture upload path.

00:12:27.400 --> 00:12:30.400
It's about four to five hundred
megabytes per second of bandwidth.

00:12:30.430 --> 00:12:32.400
The CPU doesn't have
to deal with it at all.

00:12:32.680 --> 00:12:37.300
Obviously it uses more VRAMs since
we're now again caching stuff up there.

00:12:37.390 --> 00:12:40.400
So if you're going to repaint from this
image more than you're going to do,

00:12:40.670 --> 00:12:44.400
this is pretty much exactly
what we want to use.

00:12:44.400 --> 00:12:47.400
Because, you know, again,
it's going to get cached.

00:12:47.400 --> 00:12:50.460
And like the AGP case,
there's some synchronization issues

00:12:50.530 --> 00:12:52.400
that you have to watch out for.

00:12:52.400 --> 00:12:55.400
And we'll get into that
just a little bit later.

00:12:56.090 --> 00:12:57.590
So,

00:12:58.030 --> 00:12:59.360
I guess right now, actually.

00:12:59.480 --> 00:13:01.480
So if you're using
either extension alone,

00:13:01.490 --> 00:13:03.520
either client storage
that Jeff talked about,

00:13:03.700 --> 00:13:05.890
or you're only using the
texture range extension,

00:13:05.900 --> 00:13:08.690
you kind of don't have to
worry about synchronization.

00:13:08.810 --> 00:13:13.100
Internally,
we can hide most of that for you.

00:13:13.100 --> 00:13:13.100
But

00:13:13.420 --> 00:13:16.600
If you try and use both at the same time,
it gets a little bit tricky,

00:13:16.630 --> 00:13:20.480
because now you can envision
this case where you've passed

00:13:20.630 --> 00:13:23.210
some data to the hardware and you
want to start drawing from it,

00:13:23.210 --> 00:13:25.410
and that can start
initiating a DMA from it.

00:13:25.610 --> 00:13:28.060
But the hardware is now
accessing your buffer directly.

00:13:28.060 --> 00:13:32.310
There's no intermediate copy anywhere to
sort of buffer changes that you're making

00:13:32.310 --> 00:13:34.350
to the data from what the hardware sees.

00:13:34.460 --> 00:13:37.190
So if you get in there, you know,
and start drawing a frame

00:13:37.190 --> 00:13:39.660
and call GL swap and then
start partying on the bits,

00:13:39.730 --> 00:13:42.600
it's pretty likely that you're going
to start modifying data in system

00:13:42.600 --> 00:13:46.090
memory before it's been pulled out,
and you'll get all kinds of weird tearing

00:13:46.090 --> 00:13:48.110
or decompression artifacts on the screen.

00:13:48.370 --> 00:13:51.120
But this is really not
what we want to do.

00:13:51.330 --> 00:13:53.860
And there's a lot of
gory details behind this,

00:13:53.980 --> 00:13:57.000
but without doing--spending
15 minutes on diagrams,

00:13:57.040 --> 00:14:00.400
I won't bore you with it,
but trust me on this.

00:14:00.670 --> 00:14:03.600
So there's a couple of different ways you
can deal with the synchronization issue.

00:14:03.600 --> 00:14:06.830
One, you can do the real brute force,
hit it over the head with a really

00:14:06.830 --> 00:14:10.070
large sledgehammer and just call
geofinish anytime you've done a swap.

00:14:10.160 --> 00:14:12.810
This makes sure that OpenGL has
completed everything in the

00:14:12.840 --> 00:14:14.680
system and it's just done.

00:14:14.830 --> 00:14:17.600
Now you can go and touch
the data all you want.

00:14:17.600 --> 00:14:19.660
You know,
this is not very optimal because

00:14:19.670 --> 00:14:22.370
your app can't run asynchronous
to the GL pipeline now,

00:14:22.370 --> 00:14:25.520
so you're going to have pretty
major performance problems.

00:14:25.670 --> 00:14:28.150
Another way to do it
is you can use the new,

00:14:28.350 --> 00:14:31.750
in Jaguar,
fence operators to basically set a fence.

00:14:32.010 --> 00:14:34.600
Anytime you've drawn something
with a particular texture,

00:14:34.670 --> 00:14:36.600
you can set a fence.

00:14:36.680 --> 00:14:38.970
And then later on,
when you need to modify that texture,

00:14:39.030 --> 00:14:42.280
you can wait for that particular--you
can wait for that fence to complete

00:14:42.700 --> 00:14:45.600
and then modify the texture data before
you're going to pull it through OpenGL.

00:14:45.600 --> 00:14:47.490
Now there is a performance
cost with using set fence,

00:14:47.600 --> 00:14:49.600
though, that's a little bit of
a drag in this case.

00:14:49.600 --> 00:14:52.600
If you're doing lots of different
layers with different textures

00:14:52.600 --> 00:14:55.600
and you fence on each one,
there is an expense involved.

00:14:55.600 --> 00:14:57.600
So you want to try and avoid that.

00:14:57.600 --> 00:15:00.060
The other thing you can do that's
also new in Jaguar that's part of

00:15:00.070 --> 00:15:03.590
the fence stuff is you can wait--you
can just wait on a particular texture

00:15:03.600 --> 00:15:06.600
to be done without having to have
set a fence on it ahead of time.

00:15:06.830 --> 00:15:12.600
So this lets you wait for, for example,
access to a vertex array to be completed.

00:15:12.600 --> 00:15:15.720
Or in our case,
we want to wait for any hardware

00:15:15.720 --> 00:15:20.600
accesses to that texture to be done
before we go in and modify the data.

00:15:20.600 --> 00:15:24.600
So an example of making that call,
we'd call geofinish object,

00:15:24.600 --> 00:15:26.640
pass in geofinish object,
pass in gl_texture,

00:15:26.640 --> 00:15:29.600
and then probably provide the name of
the texture that we want to wait for.

00:15:32.120 --> 00:15:37.440
So now we know how to deal with the
synchronization issue from OpenGL.

00:15:37.440 --> 00:15:39.000
How do we deal with
synchronization from QuickTime?

00:15:39.000 --> 00:15:41.960
Well, this is tricky,
and it took me a long time

00:15:41.960 --> 00:15:45.370
to figure this stuff out,
so I get to share all this with you guys.

00:15:45.560 --> 00:15:51.550
So the stuff Jeff demonstrated before
that used the movie completion procs,

00:15:51.550 --> 00:15:54.280
that stuff's pretty cool,
but you can only really use it

00:15:54.440 --> 00:15:57.840
if you're not trying to use all
these high-speed extensions.

00:15:57.930 --> 00:16:01.580
And the reason for this is you're only
going to get the call after QuickTime has

00:16:01.580 --> 00:16:03.400
gone in and modified all the data.

00:16:03.440 --> 00:16:05.450
Well, this is the same problem
I mentioned before,

00:16:05.450 --> 00:16:08.560
where if you start--QuickTime goes in
and just starts partying on the bits

00:16:08.760 --> 00:16:10.900
before the stuff's made it to the screen,
you're going to see

00:16:10.900 --> 00:16:15.800
half-decompressed frames into OpenGL,
which is not what you really want to do.

00:16:15.940 --> 00:16:21.130
So we need to know before and
after QuickTime modifies the data.

00:16:21.290 --> 00:16:23.810
We need to know before so
that QuickTime--so we can

00:16:23.810 --> 00:16:27.280
basically pause and say,
"Hey, wait, hold off QuickTime.

00:16:27.510 --> 00:16:29.250
"Don't decompress." We don't
decompress the frame until we know

00:16:29.250 --> 00:16:30.700
the hardware's done with the last one.

00:16:30.760 --> 00:16:33.900
Then we need to know when it's done
compressing the frame so we can tell GL,

00:16:33.960 --> 00:16:35.300
"Hey, the data's dirty.

00:16:35.340 --> 00:16:41.180
"Next time we draw with it,
you need to upload it." So the solution.

00:16:41.950 --> 00:16:45.480
If you write a custom
transfer codec in QuickTime,

00:16:45.690 --> 00:16:48.740
which is not non-trivial,
I'll grant that,

00:16:48.800 --> 00:16:51.870
you can get access to the sort
of lock bits/unlock bits calls.

00:16:52.050 --> 00:16:55.870
This lets you know any time the
image compression manager is going

00:16:55.870 --> 00:16:59.670
to start to touch a buffer before,
you know, back up a second.

00:16:59.920 --> 00:17:02.660
You can tell before and after
the ICM is basically going to

00:17:02.720 --> 00:17:04.900
decompress an image into your buffer.

00:17:04.900 --> 00:17:09.490
So, and the other sort of cool benefit
about using a custom transfer codec is

00:17:09.490 --> 00:17:13.890
we get to advertise exactly which pixel
formats we can support via texturing.

00:17:13.890 --> 00:17:19.230
So we can say,
I know how to do T2VUI or YUVS or

00:17:19.230 --> 00:17:22.900
ARGB or any of the other pixel formats
that there's QuickTime equivalents for.

00:17:22.900 --> 00:17:25.780
We can advertise exactly
just those formats.

00:17:25.900 --> 00:17:29.510
And the sort of nice thing about
this is if there's some funky movie

00:17:29.510 --> 00:17:32.980
that comes along in a strange format,
the ICM can try and match up

00:17:33.120 --> 00:17:34.900
what it has transfer codecs
for to the transfer codec.

00:17:35.010 --> 00:17:38.730
or what its codecs know about
to something that we can use.

00:17:39.180 --> 00:17:43.230
So part of the trickiness with those,
how do we get QuickTime to

00:17:43.300 --> 00:17:45.240
use our custom transfer codec?

00:17:45.310 --> 00:17:48.940
There isn't any way you can sort
of force it in the system directly.

00:17:49.110 --> 00:17:52.690
So there's sort of a
backhanded thing you can do,

00:17:52.690 --> 00:17:52.690
though.

00:17:53.590 --> 00:17:57.360
If you create a GWorld with a
custom pixel format that the

00:17:57.360 --> 00:18:01.740
ICM doesn't know anything about,
and then make your transfer codec say,

00:18:01.740 --> 00:18:05.680
"I know how to talk to that format,"
you can basically perform the

00:18:05.680 --> 00:18:09.740
Jedi mind trick on the ICM and get
it to use your custom pixel format.

00:18:09.770 --> 00:18:14.060
So in my case, in the example code,
we basically create this

00:18:14.060 --> 00:18:16.160
OGLX made-up pixel format.

00:18:16.160 --> 00:18:17.160
It doesn't mean anything.

00:18:17.160 --> 00:18:19.410
It doesn't have any
real pixel data there.

00:18:19.750 --> 00:18:23.480
It's just a special, you know,
four-character code that the ICM is gonna

00:18:23.480 --> 00:18:25.810
have to try and match up with some codec.

00:18:26.210 --> 00:18:39.210
And the other trick we do is we can use
that base pointer in Qt New GWorld from

00:18:39.210 --> 00:18:39.210
Pointer to point to anything we want.

00:18:39.210 --> 00:18:39.210
It doesn't even have to
point to pixels in this case.

00:18:39.210 --> 00:18:39.210
In my case, I'm just sort of treating
it as a void star.

00:18:41.000 --> 00:18:45.200
So, here's a real simple block
diagram of the solution.

00:18:45.200 --> 00:18:48.010
Say we've got DV input, for example,
and we want to pull that and

00:18:48.020 --> 00:18:50.860
get it all the way out to
OpenGL as fast as possible.

00:18:51.160 --> 00:18:55.260
So, what you end up with is the DV is
basically going to decompress

00:18:55.510 --> 00:19:00.260
into my custom transfer codec,
and then sort of via this custom GWorld

00:19:00.260 --> 00:19:03.940
magic that I'll get into in a minute,
you can basically connect that to

00:19:03.940 --> 00:19:07.900
what I have in my example application,
a sort of layer object,

00:19:07.900 --> 00:19:09.820
which is used for compositing stuff.

00:19:09.900 --> 00:19:13.900
Now that my transfer codec can
communicate with the layer object,

00:19:13.900 --> 00:19:15.870
the layer object can
deal with telling OpenGL,

00:19:15.950 --> 00:19:17.800
"Hey, the texture data's been
dirtied by QuickTime.

00:19:17.910 --> 00:19:21.790
Redraw everything," what have you.

00:19:23.140 --> 00:19:26.920
So, some more details on this
transfer codec that I wrote.

00:19:26.920 --> 00:19:31.990
This one basically just advertises
two VUI and YUVS formats.

00:19:31.990 --> 00:19:34.880
These are the two most common
things you're going to see for MPEG,

00:19:34.880 --> 00:19:37.730
Sorenson, I believe, DV formats.

00:19:37.800 --> 00:19:40.000
You're going to use one
of these two formats.

00:19:40.010 --> 00:19:42.500
The implementation of this
was pretty straightforward.

00:19:42.500 --> 00:19:44.790
There's not a lot of code in
this transfer codec because

00:19:44.830 --> 00:19:48.000
it's not touching the data,
it's not decompressing anything.

00:19:48.000 --> 00:19:50.490
Its main functionality was
just to get access to the lock

00:19:50.490 --> 00:19:52.000
and unlock bits codec calls.

00:19:52.000 --> 00:19:54.870
And then what I'm doing in
my case is that the transfer

00:19:55.580 --> 00:19:58.030
codec is sort of written,
it's basically written in

00:19:58.050 --> 00:19:59.000
this case in Objective-C.

00:19:59.000 --> 00:20:02.990
It's still basically a C, you know,
interface to QuickTime,

00:20:03.000 --> 00:20:07.300
but on the back end it basically
is treating the base pointer that

00:20:07.430 --> 00:20:13.040
it's getting when I attach the,
let me back up here for a second.

00:20:16.500 --> 00:20:20.500
Sorry, I'm trying to think of the
best way to explain this.

00:20:20.500 --> 00:20:22.300
So I end up creating this custom GWorld,
for example.

00:20:22.300 --> 00:20:23.500
It's got whatever format I make up, OGLX.

00:20:23.500 --> 00:20:27.500
I call QT new GWorld,
give it that pointer.

00:20:27.500 --> 00:20:30.440
Then later I can do set movie
GWorld and get it attached to that.

00:20:30.570 --> 00:20:34.500
That's going to cause my OpenGL transfer
codec to get attached to that.

00:20:34.620 --> 00:20:37.450
Now the codec is basically
going to be able to see that

00:20:37.450 --> 00:20:40.800
GWorld that it gets attached to,
and it's going to see there's

00:20:40.940 --> 00:20:43.390
this pointer there for where
the data is supposed to be.

00:20:43.500 --> 00:20:46.820
In this case, my transfer codec knows
that this OGLX thing really

00:20:46.820 --> 00:20:48.230
doesn't point to pixel data.

00:20:48.640 --> 00:20:52.490
So that pointer in my case is really
just an Objective-C object ID.

00:20:52.560 --> 00:20:56.490
I can show you in the sample code
what that looks like in a little bit.

00:20:57.450 --> 00:21:00.140
So that was for YUV data.

00:21:00.140 --> 00:21:01.190
What about RGB?

00:21:01.340 --> 00:21:06.700
Well, as it turns out, the ICM,
if I try advertising RAW directly,

00:21:06.700 --> 00:21:11.140
is something that my format,
my transfer codec supports,

00:21:11.140 --> 00:21:14.830
the ICM believes it more,
knows too much about RAW and will

00:21:14.830 --> 00:21:18.820
just try and hit my buffers directly,
which is, again, not what I want.

00:21:19.100 --> 00:21:23.760
So what I had to do here, and again,
this is in the sample code that

00:21:23.760 --> 00:21:27.110
we're going to give to you guys,
I had to basically use another

00:21:27.110 --> 00:21:30.740
transfer codec to sort of stack
on top of the one I already had.

00:21:30.740 --> 00:21:33.940
So in this case, I make up,
in my original YUV codec,

00:21:33.940 --> 00:21:38.590
I make up this OGLR format,
which is OGLRAW, if you will,

00:21:38.590 --> 00:21:42.910
and then advertise that this
new codec here for RGB knows how

00:21:43.020 --> 00:21:44.980
to go from RAW to that format.

00:21:45.030 --> 00:21:46.950
So now the ICM doesn't have a choice.

00:21:47.040 --> 00:21:51.820
It basically has to use this
My Custom RGB Transfer Codec,

00:21:51.930 --> 00:21:53.200
which then talks to my sort of, you know,
my custom codec.

00:21:53.200 --> 00:21:57.020
So I can just go to my special
OpenGL YUV codec and then I can

00:21:57.020 --> 00:21:58.200
connect everything to OpenGL.

00:21:58.200 --> 00:22:00.650
And again, this is also a really
tiny little bit of code.

00:22:00.650 --> 00:22:03.330
It was just, like I said,
a little trick to get the

00:22:03.330 --> 00:22:05.200
ICM to do what you want.

00:22:05.640 --> 00:22:10.730
So, just to give you guys a real quick
example of doing some of this stuff,

00:22:10.730 --> 00:22:15.540
I'm going to start
this guy back up again.

00:22:17.930 --> 00:22:21.120
Let me get rid of Project Builder
here for a minute.

00:22:21.260 --> 00:22:25.340
So just as a real simple movie,
this is a, I believe this one's a DV clip

00:22:25.340 --> 00:22:26.900
playing through the system.

00:22:27.030 --> 00:22:29.760
So you can see the fish all
swim around nice and smooth.

00:22:29.760 --> 00:22:31.190
This is 720 by 480.

00:22:31.250 --> 00:22:37.480
Now the sort of beauty of this though is,
where's the CPU monitor?

00:22:40.100 --> 00:22:41.100
Can anybody see it?

00:22:41.100 --> 00:22:42.100
Is it hiding somewhere?

00:22:42.100 --> 00:22:44.610
Let's see.

00:22:45.180 --> 00:22:45.860
There we go.

00:22:45.870 --> 00:22:48.090
You can see the CPU is sort
of barely working at all.

00:22:48.090 --> 00:22:50.050
You know,
we're playing full frame rate video

00:22:50.050 --> 00:22:53.570
through this and the CPU is just going,
"Yeah, whatever." And you know,

00:22:53.670 --> 00:22:55.180
this is kind of cool
since it's through OpenGL,

00:22:55.180 --> 00:22:56.500
I can just do whatever I want to it.

00:22:56.500 --> 00:23:00.400
You know, I can just size it around,
make it really big,

00:23:00.470 --> 00:23:05.070
accidentally drag it into the dock,
make myself look stupid.

00:23:05.200 --> 00:23:07.800
So this, you know,
just a real simple example.

00:23:07.800 --> 00:23:09.540
So, you know,
we've got some CPU headroom here,

00:23:09.540 --> 00:23:13.040
so we can also drag in a photo
JPEG clip that's also running.

00:23:13.170 --> 00:23:16.020
And I can resize it,
do this type of stuff.

00:23:16.110 --> 00:23:19.540
And you can again see the CPU is doing,
you know, a little bit more work.

00:23:19.690 --> 00:23:21.790
So, well,
maybe we can drag in some more images.

00:23:21.870 --> 00:23:26.300
Now these guys are just thumbnails,
for example, here.

00:23:26.560 --> 00:23:28.900
And, well, where did they go?

00:23:28.970 --> 00:23:30.280
Oh, I know why that didn't work.

00:23:30.360 --> 00:23:34.710
We'll do this a different way.

00:23:34.720 --> 00:23:37.300
Let's see.

00:23:37.310 --> 00:23:37.310
Let me know if you see...

00:23:40.690 --> 00:23:43.280
My drag-and-drop support wasn't
complete for all these little guys,

00:23:43.280 --> 00:23:46.410
so now I can pull in a
bunch more little movies.

00:23:46.700 --> 00:24:03.600
[Transcript missing]

00:24:05.230 --> 00:24:07.990
You know,
and OpenGL just sits there and takes it,

00:24:07.990 --> 00:24:09.440
so that's pretty cool.

00:24:09.470 --> 00:24:11.240
You know,
we can probably drag it down in the dirt.

00:24:11.270 --> 00:24:14.980
And I think what we'll end up with
first is we'll probably get disk limited

00:24:15.590 --> 00:24:18.570
before we actually get CPU limited.

00:24:18.800 --> 00:24:20.680
Yeah, so it's stuttering now,
but it's basically

00:24:20.730 --> 00:24:22.600
because the disk is going,
"Hey, hey, you're trying to pull off,

00:24:22.660 --> 00:24:24.430
like,
too many 6 megabyte per second streams,

00:24:24.430 --> 00:24:26.160
and I can't deal with this
anymore." So if I had a

00:24:26.160 --> 00:24:28.700
RAID or something like that,
it would probably work.

00:24:28.810 --> 00:24:30.700
So anyway, so now I've killed my demo.

00:24:30.700 --> 00:24:35.400
We'll start them back up in a minute.

00:24:38.620 --> 00:24:40.990
Go back to the slides, please.

00:24:41.170 --> 00:24:46.490
So, now I want to spend quite a bit more
time talking about OpenGL blending,

00:24:46.500 --> 00:24:47.970
because this kind of gets complicated.

00:24:48.180 --> 00:24:52.850
So, as you've seen from Quartz Extreme,
we can do all of the blending

00:24:53.060 --> 00:24:56.780
effects that the windowing system
uses through standard OpenGL.

00:24:56.960 --> 00:25:00.300
Now, OpenGL's blending is not
particularly complicated.

00:25:00.300 --> 00:25:02.830
It's really just got one formula
that it uses all the time.

00:25:02.840 --> 00:25:05.980
It's just source color times
source function plus destination

00:25:06.020 --> 00:25:07.990
color times destination function.

00:25:08.220 --> 00:25:13.480
So, the two of them that I'm
going to demonstrate today,

00:25:13.480 --> 00:25:13.500
for example,

00:25:13.810 --> 00:25:18.860
right here are using just your source
alpha to perform the blending operation.

00:25:19.010 --> 00:25:21.650
So in the first example here
where I'm using-- the first

00:25:21.880 --> 00:25:25.000
argument to this is basically,
what do I want the source function to be,

00:25:25.000 --> 00:25:28.210
and the second argument is what the
destination function is going to be.

00:25:28.480 --> 00:25:30.830
So if you can sort of imagine in
your head what's going to happen

00:25:30.840 --> 00:25:33.350
when this is all put together,
you're going to have sort

00:25:33.580 --> 00:25:36.400
of source destination color
times your source alpha,

00:25:36.610 --> 00:25:40.770
and then it's going to be the destination
color times one minus the source alpha.

00:25:40.960 --> 00:25:43.800
So as an example,
if your source alpha is zero,

00:25:43.800 --> 00:25:46.710
you're going to take nothing of the
source image and add that to the full

00:25:46.870 --> 00:25:48.540
brightness of the destination image.

00:25:48.540 --> 00:25:50.460
You'll only see the destination.

00:25:50.580 --> 00:25:53.450
You know, the opposite of that is if
your source alpha is one,

00:25:53.890 --> 00:25:56.950
you're going to see all of the
source and none of the destination.

00:25:56.960 --> 00:26:01.300
If it's 50/50, if your alpha's 50,
you get, you know, 50/50.

00:26:01.450 --> 00:26:04.670
The second example on here is if you're
dealing with pre-multiplied alpha,

00:26:04.680 --> 00:26:08.860
like core graphics content or
some TIFF image data off disk.

00:26:09.000 --> 00:26:11.740
In this case,
the source color times source alpha

00:26:11.840 --> 00:26:13.550
was already performed in the image.

00:26:13.780 --> 00:26:17.360
So in this case, we don't want OpenGL to
do that multiply again,

00:26:17.360 --> 00:26:19.160
'cause we'll get the wrong results.

00:26:19.340 --> 00:26:23.220
So we just want to tell OpenGL,
just take source color as is.

00:26:23.220 --> 00:26:24.520
It's already pre-multiplied.

00:26:24.810 --> 00:26:27.190
But for the destination,
you still need to perform the

00:26:27.190 --> 00:26:30.620
destination times one minus source alpha.

00:26:32.480 --> 00:26:37.010
So that's using standard OpenGL blending
at the end of the pipeline,

00:26:37.120 --> 00:26:41.290
but there's some other tricks you
can do to do blending as well.

00:26:42.020 --> 00:26:44.100
If you've got an... Oh,
let me back up for a second.

00:26:44.150 --> 00:26:47.560
That's really useful if your source
image already has alpha in it,

00:26:47.560 --> 00:26:50.320
like if it's an RGBA image
premultiplied or not.

00:26:50.530 --> 00:26:53.090
If you've got cases where...

00:26:53.380 --> 00:26:55.960
Your source image data, like if it's YUV,
for example,

00:26:56.060 --> 00:26:58.200
doesn't have an inline alpha channel.

00:26:58.230 --> 00:27:01.000
You know, if it's YUV 422,
there's no place for an alpha channel.

00:27:01.000 --> 00:27:01.700
What are you going to do?

00:27:01.800 --> 00:27:03.320
Well,
there's a couple of solutions to this.

00:27:03.480 --> 00:27:05.000
This is one of them.

00:27:05.070 --> 00:27:07.930
For multi-texture blending,
you can basically use a second

00:27:07.930 --> 00:27:11.900
texture unit to sort of bring in
the alpha in an out-of-line fashion.

00:27:11.990 --> 00:27:15.580
So you can have your--a
separate alpha mask,

00:27:15.580 --> 00:27:18.760
for example,
and you can multiply that alpha

00:27:18.760 --> 00:27:23.180
mask in sort of a second texture
unit times your source image data.

00:27:24.050 --> 00:27:25.220
There's some benefits to doing this.

00:27:25.320 --> 00:27:27.630
One, you can get a fill rate
advantage out of doing it.

00:27:27.690 --> 00:27:30.800
Most of the hardware's going to do much
better if you pull in your source image,

00:27:30.810 --> 00:27:33.040
alpha, all at once,
do all the calculations on it,

00:27:33.040 --> 00:27:36.950
and just hit the frame buffer once.

00:27:37.850 --> 00:27:40.260
It also may be easier to
combine with different effects.

00:27:40.260 --> 00:27:42.200
If you're trying to, like,
do some of the stuff I'm gonna

00:27:42.200 --> 00:27:44.610
get into later in the talk,
it can be really tricky

00:27:44.610 --> 00:27:45.960
if you're trying to,
you know,

00:27:45.960 --> 00:27:50.320
bring in your alpha in a different
way if you don't get the sort of,

00:27:50.320 --> 00:27:50.340
you know, the, the, the, the

00:27:50.780 --> 00:27:53.320
Final result on what you were
trying to do with your layer:

00:27:53.340 --> 00:27:55.810
combine all together at once.

00:27:56.790 --> 00:28:01.900
So, and this is another case where
you may actually have source

00:28:01.900 --> 00:28:05.300
pre-multiplied data that you're also
trying to apply an extra mask to.

00:28:05.300 --> 00:28:08.050
So you actually may still want
to use this in cases where you do

00:28:08.050 --> 00:28:09.700
have pre-multiplied source data.

00:28:09.880 --> 00:28:12.880
And what's important here is to
set the internal format for your

00:28:12.880 --> 00:28:14.700
alpha mask to the correct value.

00:28:14.700 --> 00:28:20.840
If you're non-pre-multiplied,
say for example on texture unit 0,

00:28:20.840 --> 00:28:24.700
does anybody here not understand
multi-texture by the way?

00:28:24.880 --> 00:28:25.440
Okay, good.

00:28:25.460 --> 00:28:26.700
Just want to make sure.

00:28:26.700 --> 00:28:30.690
So if you're on texture unit 0,
and you've got like an YUV texture data,

00:28:30.700 --> 00:28:33.700
and you've got alpha
in the second channel,

00:28:33.700 --> 00:28:35.650
and what's your alpha mask?

00:28:35.770 --> 00:28:38.910
If you're not pre-multiplied,
you can basically just tell OpenGL, "Hey,

00:28:38.910 --> 00:28:41.670
treat that second texture as alpha."
So the only thing that's going to

00:28:41.770 --> 00:28:44.710
happen is this passes through the
pipeline if you're using modulate,

00:28:44.880 --> 00:28:48.700
is for GL alpha textures,
the RGB is basically just 1, 1, 1.

00:28:48.710 --> 00:28:52.700
It's just treated as 1.0,
so nothing happens.

00:28:53.240 --> 00:28:55.900
And... Sorry.

00:28:58.420 --> 00:29:01.640
But the alpha channel basically
will get multiplied times the

00:29:01.640 --> 00:29:03.450
alpha value in your YUV data.

00:29:03.460 --> 00:29:05.700
In this case,
that's just going to be a 1.0.

00:29:05.840 --> 00:29:08.900
So the end result is you'll
basically have the new alpha

00:29:08.900 --> 00:29:11.510
mask replacing the alpha channel.

00:29:11.510 --> 00:29:14.880
So in the bottom of the pipeline,
you can basically have the results

00:29:14.970 --> 00:29:18.740
of your YUV data ending up in RGB and
your alpha mask in the alpha channel.

00:29:18.800 --> 00:29:21.660
Now,
if your source data is pre-multiplied,

00:29:21.660 --> 00:29:26.900
you need to do the alpha--you sort
of also need to do the mask or alpha

00:29:27.530 --> 00:29:30.800
multiply in the texture unit itself.

00:29:30.800 --> 00:29:33.770
I'll get into that and show some
demos in a second of why that is.

00:29:33.800 --> 00:29:35.670
So in this case,
what you want to do in your alpha

00:29:35.670 --> 00:29:38.780
mask is not use an alpha texture,
but you want to treat it as intensity.

00:29:38.830 --> 00:29:41.790
And the nice thing about this
is it replicates the alpha value

00:29:41.800 --> 00:29:44.800
all the way across the alpha red,
green, blue channels.

00:29:44.800 --> 00:29:47.520
So that now if you're modulating
a second texture with an alpha

00:29:47.580 --> 00:29:47.800
mask times your alpha value,
you're going to be able

00:29:47.800 --> 00:29:47.800
to do the same thing.

00:29:47.800 --> 00:29:47.800
So that's the first thing.

00:29:47.800 --> 00:29:47.800
So now, if you're modulating a
second texture with an alpha

00:29:47.800 --> 00:29:47.800
mask times your alpha value,
you're going to be able

00:29:47.800 --> 00:29:47.800
to do the same thing.

00:29:47.800 --> 00:29:47.800
So that's the first thing.

00:29:47.800 --> 00:29:52.310
alpha mask times your first RGB texture,
the multiply there happens

00:29:52.310 --> 00:29:54.180
right there in the texture unit.

00:29:54.240 --> 00:29:56.250
So at the bottom of the texture pipe,
you still basically have

00:29:56.420 --> 00:29:57.680
pre-multiplied alpha data.

00:29:57.700 --> 00:30:01.510
Your alpha channel contains the new,
you know, alpha mask times the alpha data

00:30:01.510 --> 00:30:05.340
in your pre-multiplied data,
plus we've done an additional

00:30:06.230 --> 00:30:12.020
pre-multiplied alpha in a,
in a sense, in the other channels.

00:30:12.370 --> 00:30:16.300
That's one way of doing
blending with multi-texturing.

00:30:16.340 --> 00:30:20.300
And here's the diagram that
I should have had up a minute ago.

00:30:20.420 --> 00:30:24.300
So if you start out with like an
RGBA image or just an RGB image,

00:30:24.300 --> 00:30:27.290
and you've got an alpha
mask in a different channel,

00:30:27.310 --> 00:30:30.300
you can basically pull
off an effect like this,

00:30:30.300 --> 00:30:35.280
where in the end, you basically-- at the
bottom of the texture pipe,

00:30:35.300 --> 00:30:37.230
you'll end up with just the alpha mask,
or the original sort

00:30:37.230 --> 00:30:40.300
of source color data,
but it's been all clipped out,

00:30:40.300 --> 00:30:44.300
nice soft edges and everything,
if you've got anti-aliased masks.

00:30:44.420 --> 00:30:47.770
And at the bottom of the texture pipe,
we'll just see this masked

00:30:47.770 --> 00:30:49.300
texture value already.

00:30:52.590 --> 00:30:56.840
So, another way you can do alpha blending
is to use the destination alpha

00:30:56.840 --> 00:30:59.500
channel in your OpenGL buffer.

00:31:00.060 --> 00:31:01.710
So,

00:31:02.600 --> 00:31:05.120
One of the cool things that
Jeff talked about in the previous

00:31:05.120 --> 00:31:08.970
session with the mask operations
is there's also an alpha mask.

00:31:09.230 --> 00:31:12.800
So one of the things you can do is

00:31:13.360 --> 00:31:17.320
"Write like one layer in there, you know,
like a background or what have you.

00:31:17.320 --> 00:31:19.400
And then you can turn off the red, green,
blue channels so you don't

00:31:19.400 --> 00:31:20.290
want to touch that anymore.

00:31:20.300 --> 00:31:23.540
And then you can draw an
alpha mask any way you want

00:31:23.550 --> 00:31:25.540
into that destination buffer.

00:31:25.740 --> 00:31:29.740
So you can use custom geometry,
you could draw a cube,

00:31:29.800 --> 00:31:32.480
you could draw a text,
you could draw a circle, square,

00:31:32.600 --> 00:31:34.470
you know,
whatever kind of polygonal stuff

00:31:34.470 --> 00:31:37.050
you want to do into the destination,
but it doesn't show up

00:31:37.050 --> 00:31:38.300
visible to the user.

00:31:38.300 --> 00:31:42.300
It really only ends up
into the destination alpha.

00:31:42.660 --> 00:31:46.540
And just to give you guys a
diagram of what that looks like,

00:31:46.540 --> 00:31:49.840
so say I start out with that
same similar background again.

00:31:49.910 --> 00:31:51.790
First step,
just draw it into the destination.

00:31:51.790 --> 00:31:57.070
It shows up there, you've got red, green,
blue, all enabled.

00:31:57.070 --> 00:31:57.070
The second stage,

00:31:57.240 --> 00:31:58.950
You want to draw in with the alpha mask.

00:31:59.200 --> 00:32:02.720
Now, in this case, I'm just drawing it
here for visualization,

00:32:02.760 --> 00:32:04.900
but I'll show you guys in the demo a
second what this really looks like.

00:32:05.040 --> 00:32:08.670
So in the second pass,
you can imagine we're drawing that alpha

00:32:08.670 --> 00:32:12.360
mask lettering just in the destination,
but that you can't actually see it.

00:32:12.360 --> 00:32:14.060
Pretend it's not there,
but it did go into the

00:32:14.090 --> 00:32:15.890
destination alpha channel.

00:32:16.020 --> 00:32:19.650
Now I can bring in another
stage that draws in there,

00:32:19.820 --> 00:32:22.800
but blends using that destination alpha.

00:32:22.900 --> 00:32:25.400
So now I've basically sort
of done a three-step process.

00:32:25.400 --> 00:32:28.290
I've drawn the destination in,
then I've drawn my mask,

00:32:28.310 --> 00:32:31.650
and now I can basically paint
through that mask with whatever

00:32:31.650 --> 00:32:32.700
source material I want.

00:32:32.700 --> 00:32:35.590
So I can do, you know,
use multi-texturing to

00:32:35.590 --> 00:32:39.550
do some really wacky,
wild effect, but still do some custom

00:32:39.550 --> 00:32:41.690
rendering for the alpha mask.

00:32:41.700 --> 00:32:45.090
So I'll show you guys an example
of some of the blending stuff here.

00:32:45.140 --> 00:32:46.700
I'll spend a little bit of time on this.

00:32:46.770 --> 00:32:51.170
Pull up my magic demo that disappeared.

00:32:52.300 --> 00:32:54.940
Let me get my project
builder here for a second.

00:32:54.940 --> 00:32:57.820
So for example,
if I just bring in a simple

00:32:59.010 --> 00:33:02.800
background image like you guys
have probably seen before.

00:33:02.800 --> 00:33:06.620
So this image, as it stands,
is just a standard straight plate,

00:33:06.660 --> 00:33:09.430
not particularly interesting,
but we can kind of do

00:33:09.430 --> 00:33:10.490
some blending effects.

00:33:10.550 --> 00:33:17.290
Let me bring actually another,
what can I bring in on top of this?

00:33:17.290 --> 00:33:18.150
Actually, let me try that one more time.

00:33:20.920 --> 00:33:22.130
Do this in two passes.

00:33:22.130 --> 00:33:25.510
So we can start out with like
a background plate like this.

00:33:25.640 --> 00:33:25.920
Okay.

00:33:26.070 --> 00:33:29.680
And then we want to bring in,
for example, a foreground plate.

00:33:29.680 --> 00:33:32.500
So, we need to get rid of
that black background.

00:33:32.500 --> 00:33:35.790
Now, as it turns out,
this image already has alpha data in

00:33:35.790 --> 00:33:38.060
it and it happens to be premultiplied.

00:33:38.060 --> 00:33:38.910
So,

00:33:39.140 --> 00:33:41.160
I'll pull up my magical little
inspector here that has all

00:33:41.160 --> 00:33:42.500
my blending controls in it.

00:33:42.810 --> 00:33:44.500
Probably way more than
I need for this demo.

00:33:44.720 --> 00:33:47.940
So here I can do things
like turn that layer,

00:33:48.130 --> 00:33:49.720
the top one, on and off,
so you can see what it

00:33:49.720 --> 00:33:50.550
looks like without it.

00:33:50.650 --> 00:33:52.500
I can just turn off
the different channels,

00:33:52.570 --> 00:33:54.500
sort of do the same type of stuff
that Jeff was doing in the last.

00:33:54.500 --> 00:33:56.490
You can see red, green, blue, alpha.

00:33:56.500 --> 00:33:59.500
And I can also enable blending.

00:33:59.500 --> 00:34:02.500
Now, right now, with blending turned on,
I'm just using 1 and 0,

00:34:02.500 --> 00:34:04.470
which basically means you're
only going to see the source

00:34:04.500 --> 00:34:05.950
and none of the destination.

00:34:06.000 --> 00:34:07.200
I can flip these around.

00:34:07.500 --> 00:34:10.900
Well, now you get black-- not
particularly interesting.

00:34:11.130 --> 00:34:13.390
and I can make the
destination here be one.

00:34:13.390 --> 00:34:17.700
So now I only see the destination,
similar to the example I gave before.

00:34:17.750 --> 00:34:19.400
I can do, I can add them both in.

00:34:19.400 --> 00:34:20.980
So now they add on top of each other.

00:34:20.990 --> 00:34:24.820
Also, maybe not useful.

00:34:25.510 --> 00:34:29.230
However,
I can also blend using source color also,

00:34:29.230 --> 00:34:30.400
but that's not what I want.

00:34:30.400 --> 00:34:33.060
However, this image I know happens
to be premultiplied,

00:34:33.060 --> 00:34:38.290
so in the example I gave before,
I want one for the source and I want one

00:34:38.290 --> 00:34:41.400
minus source alpha for the destination.

00:34:41.400 --> 00:34:43.900
And now I get the images nicely
blended on top of each other.

00:34:43.900 --> 00:34:45.800
You can see the edges in
here are nice and soft.

00:34:45.890 --> 00:34:46.960
I can drag it around.

00:34:46.960 --> 00:34:51.440
It's all sort of anti-aliased.

00:34:53.900 --> 00:34:55.660
"I'm going to zoom in here,
and I don't know if you can

00:34:55.660 --> 00:34:57.340
see as I move it around,
but it kind of fades.

00:34:57.340 --> 00:35:00.550
You can kind of see that it's
got a nice soft edge on it."

00:35:03.310 --> 00:35:06.670
Now, if I didn't--hadn't known that
this image was pre-multiplied,

00:35:06.670 --> 00:35:08.430
I may have just tried
to use source alpha.

00:35:08.450 --> 00:35:09.940
And what you'll see is
what happens is that,

00:35:09.940 --> 00:35:11.150
like, these edges went dark.

00:35:11.280 --> 00:35:13.280
Did you guys see that in there?

00:35:13.520 --> 00:35:14.000
Yes, no?

00:35:14.250 --> 00:35:16.240
Let me just switch it back in here.

00:35:16.340 --> 00:35:17.800
See, the edges are almost too dark.

00:35:17.800 --> 00:35:19.020
It doesn't look quite right.

00:35:19.080 --> 00:35:20.400
And, you know,
there's this sort of obvious border.

00:35:20.400 --> 00:35:23.170
And what's happening here is the
source color data was a ri- has

00:35:23.340 --> 00:35:25.150
already been multiplied by alpha.

00:35:25.150 --> 00:35:26.900
So you don't want to multiply
it times alpha again.

00:35:26.900 --> 00:35:28.400
It's gonna darken it too much.

00:35:28.720 --> 00:35:34.190
So it's something to watch out
for if you realize that your edges

00:35:34.190 --> 00:35:34.190
aren't working quite correctly.

00:35:36.430 --> 00:35:43.040
Now, let's see,
what's another fun demo here?

00:35:43.690 --> 00:35:45.630
So, okay,
so one of the other things I talked

00:35:45.700 --> 00:35:47.560
about was the destination alpha blending.

00:35:47.770 --> 00:35:51.820
So, for example,
let me start off with just a,

00:35:52.150 --> 00:35:56.010
let me redo,
quit this and start again with another.

00:35:57.470 --> 00:36:18.190
A couple of backgrounds here.

00:36:18.190 --> 00:36:18.190
So say, for example,
I've got these are two

00:36:18.190 --> 00:36:18.190
original movies again,
you know, one on top of the other.

00:36:18.190 --> 00:36:18.190
I can do all the same
blending effects in real time.

00:36:18.190 --> 00:36:18.190
Now, in this case,
neither of these images

00:36:18.190 --> 00:36:18.190
are pre-multiplied alpha.

00:36:18.190 --> 00:36:18.190
They've got just YUV data.

00:36:18.190 --> 00:36:18.190
There's no alpha channel there.

00:36:18.190 --> 00:36:18.190
But I can still use blending
to sort of fade between them.

00:36:18.190 --> 00:36:18.190
And the way I can do that,
if I set up source alpha...

00:36:18.450 --> 00:36:21.450
1- source alpha again, enable blending.

00:36:21.550 --> 00:36:22.990
Well, there's no alpha channel there.

00:36:23.000 --> 00:36:25.500
It's not particularly interesting.

00:36:26.530 --> 00:36:28.980
But since I'm running
everything through OpenGL,

00:36:28.980 --> 00:36:34.320
I can basically modulate OpenGL's primary
color times either one of those layers.

00:36:34.420 --> 00:36:38.140
So for example, I can colorize it red,
green, blue, you know,

00:36:38.270 --> 00:36:38.900
sort of purple-ize it.

00:36:38.900 --> 00:36:41.400
Now this is just doing a simple multiply.

00:36:41.570 --> 00:36:44.700
However, the other thing I can do is
I can also change the alpha

00:36:44.700 --> 00:36:47.600
value that's being fed to GL,
and I can sort of cleanly

00:36:47.600 --> 00:36:49.040
white between these two.

00:36:49.220 --> 00:36:53.390
Okay, so if, you know,
it's 50/50 in this case, you know,

00:36:53.390 --> 00:36:55.070
3% here.

00:36:55.260 --> 00:36:56.200
Whatever.

00:36:56.200 --> 00:36:56.560
Okay?

00:36:56.710 --> 00:36:58.560
Nice fade, you know,
see this type of stuff

00:36:58.630 --> 00:36:59.900
on TV all the time.

00:36:59.900 --> 00:37:02.200
Usually with much more
expensive equipment.

00:37:02.200 --> 00:37:07.610
You can do all kinds of fun stuff,
like...

00:37:09.400 --> 00:37:14.500
Let's see if I... Okay,
let me show you the

00:37:14.500 --> 00:37:17.400
destination alpha blend,
and then do one of my Ken's Infamous

00:37:17.400 --> 00:37:20.400
on the fly demo things again quick.

00:37:20.400 --> 00:37:25.400
So I can--let me turn off this layer
for a second and just enable a polygon.

00:37:25.400 --> 00:37:27.400
So in that same layer that
I've got that top one,

00:37:27.400 --> 00:37:30.400
one of the things I can do before
I draw the sort of sports thing

00:37:30.400 --> 00:37:32.340
is just draw a simple polygon.

00:37:32.420 --> 00:37:36.380
In this case, it's just a simple diamond,
not particularly interesting.

00:37:36.400 --> 00:37:38.270
And as you can see from
what my slide looked like,

00:37:38.400 --> 00:37:40.620
it's the same thing,
where I've basically drawn some

00:37:40.620 --> 00:37:42.400
kind of mask into the destination.

00:37:42.400 --> 00:37:44.300
Now, in this case, I've got red, green,
and blue turned on,

00:37:44.400 --> 00:37:47.400
so it's obviously splatting
all over the image.

00:37:47.400 --> 00:37:49.400
This isn't exactly what we want.

00:37:49.400 --> 00:37:52.200
However, I can basically turn
on red-- turn off red,

00:37:52.200 --> 00:37:53.400
green, and blue.

00:37:53.400 --> 00:37:55.370
Now that mask is still there.

00:37:55.410 --> 00:37:57.400
It's just in the
destination alpha channel,

00:37:57.400 --> 00:37:59.390
so you can't see it, though.

00:37:59.400 --> 00:38:03.400
So if I turn on my frontmost layer again,
it's all blended here.

00:38:03.400 --> 00:38:04.750
But now I can use the destination alpha

00:38:06.830 --> 00:38:08.010
Where'd it go?

00:38:08.010 --> 00:38:08.440
Oh.

00:38:08.440 --> 00:38:12.290
To punch through with just
that particular shape.

00:38:12.290 --> 00:38:16.560
Now, I can also use blending on
the polygon itself as well.

00:38:16.560 --> 00:38:20.860
So I can turn on blending,
and of course it just turned off

00:38:20.860 --> 00:38:23.170
because I've got it set to zero.

00:38:23.280 --> 00:38:25.210
So let me use source alpha.

00:38:25.350 --> 00:38:26.060
Again.

00:38:26.060 --> 00:38:28.680
One minus source alpha here.

00:38:30.190 --> 00:38:34.100
So now I can take that shape and
I can also apply a fade to it as well.

00:38:34.190 --> 00:38:36.640
So I can just fade out on
that one particular diamond.

00:38:36.750 --> 00:38:38.630
So you can, you know,
you can sort of see how you can stack up

00:38:38.750 --> 00:38:41.660
these layers multiple times to achieve
different kinds of video effects.

00:38:41.770 --> 00:38:44.690
Now obviously you could animate this
diamond to do some sort of animated

00:38:44.690 --> 00:38:47.140
cut from one type of video to another.

00:38:47.230 --> 00:38:50.190
So, you know,
you can sort of build your own little

00:38:50.190 --> 00:38:52.170
switcher here if you wanted to.

00:38:54.590 --> 00:38:57.990
Now, one thing I forgot to demo a minute
ago-- let me see if I can get my little

00:38:57.990 --> 00:39:01.410
camera on here-- was pulling in...

00:39:02.550 --> 00:39:04.260
Live DV content.

00:39:04.380 --> 00:39:08.410
So I can take--add another layer in here.

00:39:09.340 --> 00:39:11.530
"If I get lucky,
I want to just add it to the background.

00:39:11.570 --> 00:39:12.080
All right.

00:39:12.100 --> 00:39:13.200
Let me get him out of here.

00:39:13.200 --> 00:39:14.730
So, there's my arm.

00:39:14.730 --> 00:39:16.300
Not real interesting.

00:39:16.300 --> 00:39:20.810
But this is an example just of using
DV content through... I'm going to

00:39:20.810 --> 00:39:24.290
avoid you guys so we don't have to worry
about having you guys sign anything.

00:39:24.640 --> 00:39:27.220
So, pointed at me.

00:39:27.630 --> 00:39:27.910
Hi.

00:39:28.300 --> 00:39:30.500
So, anyway,
so this is just pulling live DV.

00:39:30.500 --> 00:39:33.300
This is basically using the
same technique I was doing.

00:39:33.300 --> 00:39:36.210
So this is using a sequence
grabber hooked up to my same

00:39:36.210 --> 00:39:38.300
YUV transfer codec that I had before.

00:39:38.300 --> 00:39:42.290
It was amazingly little code as it turned
out to get QuickTime to do this for me.

00:39:42.300 --> 00:39:45.920
So, again,
I can basically pull in... Like I said,

00:39:45.920 --> 00:39:48.400
this is not a particularly
interesting image here,

00:39:48.400 --> 00:39:50.210
and Ken will kill me
if I drop this camera.

00:39:50.320 --> 00:39:52.560
But, you know, I can still do all this
live compositing stuff,

00:39:52.610 --> 00:39:54.300
but now I can do it
with live video as well.

00:39:54.300 --> 00:39:56.300
You know, same sort of thing.

00:39:56.300 --> 00:39:58.170
And I can still scale these layers down.

00:39:58.300 --> 00:40:00.410
I can take the video
layer and scale it down,

00:40:00.410 --> 00:40:01.430
do whatever I want.

00:40:01.430 --> 00:40:03.130
You know, move these guys around.

00:40:03.130 --> 00:40:04.230
And it all just works.

00:40:04.350 --> 00:40:07.300
And you can see the CPU, yeah,
it's doing some more work

00:40:07.300 --> 00:40:07.300
because it's pulling two
6-megabyte-per-second streams.

00:40:07.300 --> 00:40:11.260
Off-disk and pulling from FireWire,
whatever rate it needs to for DV.

00:40:11.310 --> 00:40:15.350
But, you know, this machine,
dual 1 gigahertz, GeForce 4,

00:40:15.350 --> 00:40:17.300
it can handle it, you know.

00:40:17.300 --> 00:40:19.300
I think that's pretty cool.

00:40:19.300 --> 00:40:21.520
I used to do video stuff
on my Amiga long ago,

00:40:21.520 --> 00:40:23.300
and you can never do this stuff.

00:40:23.300 --> 00:40:25.300
Not in real time anymore.

00:40:25.300 --> 00:40:30.830
So, kill the DV stream here.

00:40:35.030 --> 00:40:38.360
I knew the demo gods were
going to get me eventually.

00:40:38.530 --> 00:40:45.110
All right, well,
let me kick this thing in the head.

00:40:45.690 --> 00:40:46.090
briefly.

00:40:46.150 --> 00:40:48.140
That's what I get for
messing with FireWire.

00:40:48.140 --> 00:40:49.610
I'll blame the FireWire guys.

00:40:49.870 --> 00:40:51.460
That'll make me feel better.

00:40:51.540 --> 00:40:53.290
It really was an OpenGL.

00:40:53.290 --> 00:40:56.200
So let me just,
this will probably throw my,

00:40:56.200 --> 00:40:58.520
throw me off just a little bit here.

00:40:58.660 --> 00:41:01.810
So we'll come back to some of the
more compositing stuff in a minute

00:41:01.890 --> 00:41:04.680
once the machine comes back to life.

00:41:05.140 --> 00:41:08.520
So now I want to get into image
effects stuff just a little bit.

00:41:08.650 --> 00:41:12.680
Now, as you saw in that previous demo,
I can do really simple color

00:41:12.680 --> 00:41:14.710
scaling effects using OpenGL.

00:41:14.710 --> 00:41:18.030
You know, just basically take the primary
color and modulate that or

00:41:18.070 --> 00:41:21.020
multiply it against whatever data
is coming through the pipeline.

00:41:21.020 --> 00:41:25.580
So I could colorize it red, green, blue,
red and green, yellow it,

00:41:25.740 --> 00:41:28.580
or use it to modify
the source alpha value.

00:41:28.580 --> 00:41:31.600
So that's pretty powerful.

00:41:31.600 --> 00:41:33.520
As the example shows here,
the thing you really want to do

00:41:33.580 --> 00:41:35.910
is you just call before you're
going to render your polygon,

00:41:35.910 --> 00:41:38.280
you just call geocolor 4f,
give it the red, green, blue,

00:41:38.280 --> 00:41:39.920
alpha that you want.

00:41:39.920 --> 00:41:43.800
And make sure you set up the
modulate texture environment mode.

00:41:43.800 --> 00:41:46.320
And this will apply this entire layer.

00:41:46.320 --> 00:41:50.940
Now you could obviously do,
we just keep it on the slides until the,

00:41:51.310 --> 00:41:53.680
I'll tell you guys when to kick it back,
where to go.

00:41:53.880 --> 00:41:54.110
Thanks.

00:41:56.740 --> 00:41:57.760
This will apply to the whole layer.

00:41:57.760 --> 00:42:00.160
Now, you could obviously do
this on a per-vertex thing,

00:42:00.160 --> 00:42:03.230
or you could also dice up the
image into little rectangles

00:42:03.300 --> 00:42:05.340
and do sort of colorized,
wavy effects on the

00:42:05.340 --> 00:42:06.430
image if you wanted to.

00:42:06.600 --> 00:42:08.850
So you don't have to do it
just on the whole layer.

00:42:08.850 --> 00:42:12.280
You know, whatever granularity you want
to break the image up to,

00:42:12.280 --> 00:42:13.490
you can do it that way.

00:42:13.670 --> 00:42:15.960
Another really cool thing, though,
you can do with OpenGL,

00:42:15.960 --> 00:42:19.780
and I'll demo this in a minute,
is sort of perspective warping effects.

00:42:19.920 --> 00:42:22.200
Now, there's a paper a guy wrote,
and I think,

00:42:22.200 --> 00:42:25.210
and I learned from the QuickTime guys
yesterday that QuickTime actually

00:42:25.330 --> 00:42:27.960
has a function to do this for you,
and it'll give you the right matrix,

00:42:28.160 --> 00:42:32.440
to warp basically one quadrilateral
to any other quadrilateral.

00:42:32.600 --> 00:42:35.940
And the sort of cool part about
this is you can sort of modify

00:42:36.060 --> 00:42:39.940
the perspective of an image and,
or basically undo a perspective

00:42:39.940 --> 00:42:41.590
that's already there.

00:42:41.600 --> 00:42:42.980
You know,
if you've got something that was shot,

00:42:42.980 --> 00:42:45.140
like, up at a building at an angle,
you can basically make it

00:42:45.230 --> 00:42:48.000
look like you were standing,
you know, infinitely far away and the

00:42:48.000 --> 00:42:49.440
building was straight up.

00:42:49.800 --> 00:42:53.300
The sort of cool thing about this
is that the OpenGL handles all the

00:42:53.300 --> 00:42:57.130
homogeneous coordinate stuff for you,
and because it's doing the divide

00:42:57.130 --> 00:43:01.600
per pixel and right perspective
correct texture mapping,

00:43:01.780 --> 00:43:04.330
you know,
you get really nice results out of it,

00:43:04.330 --> 00:43:07.480
and it just doesn't cost
you a lot performance-wise.

00:43:09.160 --> 00:43:13.920
and now we can get to the how we did
that magical keynote color keying stuff.

00:43:13.940 --> 00:43:15.740
So I'm going to spend a little
bit of time in talking about this

00:43:15.760 --> 00:43:17.280
because it's kind of complicated.

00:43:17.580 --> 00:43:19.580
This sort of simplifies it,
but I'm trying to spend

00:43:19.580 --> 00:43:21.080
some time explaining it.

00:43:21.210 --> 00:43:25.320
So with the GeForce 4 titanium
and I believe eventually the

00:43:25.320 --> 00:43:31.100
ATI Radion 8500 with pixel shaders,
you can do dependent 3D texture reads.

00:43:31.100 --> 00:43:33.600
You know,
what this basically means is you can

00:43:33.600 --> 00:43:35.870
create a three-dimensional texture.

00:43:36.100 --> 00:43:40.100
In my case,
I think I'm using like 32 by 32 by 32.

00:43:40.100 --> 00:43:44.100
It doesn't have to be large because all
the intermediate points will be filtered.

00:43:44.100 --> 00:43:47.090
And you can basically use that
three-dimensional lookup table,

00:43:47.130 --> 00:43:51.250
or use that three-dimensional table, ehh,
three-dimensional texture

00:43:51.250 --> 00:43:52.100
as a lookup table.

00:43:52.100 --> 00:43:54.720
And you can think of any kind of
function you can apply to a red,

00:43:54.760 --> 00:43:56.100
green, blue input value.

00:43:56.100 --> 00:43:59.000
You can get a red, green,
blue alpha value out of.

00:43:59.100 --> 00:44:00.070
This is like it says up here.

00:44:00.200 --> 00:44:05.050
You know, red prime, green prime,
blue prime, alpha prime is F of RGB.

00:44:05.360 --> 00:44:07.100
You can do a lot with this.

00:44:07.100 --> 00:44:10.090
You can make all your video look antique,
for example,

00:44:10.180 --> 00:44:12.050
if you feed in the right kind of matrix.

00:44:12.190 --> 00:44:17.090
You can do color sync
correction as another example.

00:44:17.150 --> 00:44:22.100
You know, take a color sync profile,
throw it into the texture, and, you know,

00:44:22.100 --> 00:44:23.100
color correct your image.

00:44:23.100 --> 00:44:24.130
You can combine it.

00:44:24.130 --> 00:44:27.050
You can basically take your,
take an RGB value, apply some,

00:44:27.090 --> 00:44:30.920
something to it, apply more to it,
and put all that and the

00:44:30.920 --> 00:44:32.100
results of that into a table.

00:44:32.100 --> 00:44:34.100
And with enough texture,
you can do a lot with this.

00:44:34.250 --> 00:44:35.950
With enough texture units,
you could actually put them in

00:44:35.950 --> 00:44:37.100
separate tables if you wanted.

00:44:37.100 --> 00:44:40.950
So you could have, you know, one,
one texture unit that

00:44:40.950 --> 00:44:43.980
basically does sepia,
and then you can convert

00:44:43.980 --> 00:44:45.090
sepia to black and white.

00:44:45.130 --> 00:44:47.090
Probably not useful.

00:44:47.100 --> 00:44:49.180
But you could, you know,
swap color channels around,

00:44:49.180 --> 00:44:50.100
do anything you want.

00:44:50.100 --> 00:44:53.100
Now, in our case,
what we did for the keynote demo,

00:44:53.100 --> 00:44:56.100
we can thank Peter for
coming up with this idea,

00:44:56.100 --> 00:44:57.650
was, well,
why can't we just take anything

00:44:57.690 --> 00:45:00.100
that's green and basically sort
of turn it into transparent?

00:45:00.100 --> 00:45:03.060
Pull out the,
pull out the green screen background.

00:45:03.140 --> 00:45:05.020
So that's what we did.

00:45:05.100 --> 00:45:08.100
Ralph Bruner, he's really good at
image processing stuff,

00:45:08.100 --> 00:45:11.100
sat down and came out with the formula
that we wanted to use for this.

00:45:11.260 --> 00:45:15.090
Basically, could build up a table that we
could adjust and pull pretty

00:45:15.420 --> 00:45:18.470
much any color we want out of,
out of anything and just, like,

00:45:18.470 --> 00:45:19.090
sort of alpha blend it out.

00:45:19.100 --> 00:45:23.160
In our case, we wanted to take just that
sort of green tinged stuff and

00:45:23.350 --> 00:45:25.100
pull it right out of the image.

00:45:25.100 --> 00:45:28.290
Now, the way this works is...

00:45:28.780 --> 00:45:31.630
In the texture shader
stuff in NVIDIA's hardware,

00:45:31.640 --> 00:45:35.630
basically, the way this works is,
on texture unit zero, you'd have,

00:45:35.710 --> 00:45:39.700
for example, your source image data that
just feeds through RGB.

00:45:39.800 --> 00:45:42.400
Or you could even use, you know,
two texture units, you know,

00:45:42.400 --> 00:45:46.700
alpha and a mask, and then feed that into
a next texture stage.

00:45:46.750 --> 00:45:50.070
What happens in the stage where you're
using sort of this dependent texture

00:45:50.120 --> 00:45:52.530
read stuff is the incoming red,
green,

00:45:52.530 --> 00:45:56.070
blue from the previous texture stage
end up being turned into the S,

00:45:56.150 --> 00:45:57.680
T, and R coordinates.

00:45:57.840 --> 00:46:00.700
So that's sort of how
the table lookup happens.

00:46:00.700 --> 00:46:03.250
So rather than just being able to
take those colors and blend them with,

00:46:03.250 --> 00:46:06.700
like, texture combiners,
the regular OpenGL blending path,

00:46:06.700 --> 00:46:09.130
you can basically use
those to just pass it,

00:46:09.380 --> 00:46:10.650
you know, as a lookup.

00:46:10.810 --> 00:46:13.780
So the S, the incoming red goes to the S,
so that's sort of the

00:46:13.830 --> 00:46:15.520
X coordinate in the texture.

00:46:15.890 --> 00:46:18.990
The T, red value coming in basically
goes to the T coordinate,

00:46:18.990 --> 00:46:20.700
so that gives you the Y value.

00:46:20.700 --> 00:46:23.060
And then the blue basically
ends up the Z value in this

00:46:23.060 --> 00:46:24.690
three-dimensional texture.

00:46:24.790 --> 00:46:26.700
So any RGB can get anywhere
in this big color cube.

00:46:26.700 --> 00:46:30.260
And you get, you know, as I said,
you get a four component

00:46:30.260 --> 00:46:31.700
result out of that.

00:46:33.570 --> 00:46:37.210
So, spend some time giving you
guys a demo of like throwing

00:46:37.210 --> 00:46:38.300
all this stuff together now.

00:46:38.420 --> 00:46:42.240
So we'll go over the image
warping stuff here now.

00:46:42.240 --> 00:46:45.110
I'll embarrass myself and... Oh, alright.

00:46:45.520 --> 00:46:48.220
Someone want to come up here
and tell me what the login is?

00:46:48.360 --> 00:46:50.310
Thank you, Jeff.

00:46:50.340 --> 00:46:52.120
Nobody told me.

00:46:55.180 --> 00:46:58.340
No, see, denied.

00:46:58.480 --> 00:47:00.790
Okay, thank you, Jeff.

00:47:01.630 --> 00:47:05.020
I don't normally type on QWERTY,
so I probably wouldn't have

00:47:05.020 --> 00:47:07.670
gotten it right anyway.

00:47:08.000 --> 00:47:09.990
I'm going to find a little guy
and pull him up here and stay

00:47:09.990 --> 00:47:11.950
away from the FireWire camera.

00:47:11.950 --> 00:47:13.000
FireWire bad.

00:47:13.060 --> 00:47:17.210
Well, FireWire good,
but FireWire bad today.

00:47:18.830 --> 00:47:19.690
Okay.

00:47:19.690 --> 00:47:25.700
So, let's start out and do...
First I'll do a silly example.

00:47:25.700 --> 00:47:30.640
So, of course, every... No,
it's not what I want.

00:47:31.190 --> 00:47:33.770
Everything has now been
completely forgotten,

00:47:33.770 --> 00:47:34.660
obviously.

00:47:34.720 --> 00:47:35.110
Ugh.

00:47:35.110 --> 00:47:35.460
Mail.

00:47:35.770 --> 00:47:37.700
I'm doing good here.

00:47:43.630 --> 00:47:46.960
: Let's get to a real view.

00:47:46.960 --> 00:47:50.180
I can navigate quickly.

00:47:50.180 --> 00:47:52.300
Green screen.

00:47:56.480 --> 00:47:57.740
Okay.

00:47:57.890 --> 00:47:59.050
Back to semi-normal here.

00:47:59.180 --> 00:48:03.040
So, you know, we were talking about
using color effects before.

00:48:03.040 --> 00:48:04.880
So, for example, again,
I'll just bring in,

00:48:05.190 --> 00:48:08.610
just to go over that real quick,
if I've got my background image in here,

00:48:08.640 --> 00:48:12.590
bring up my magical hidden control panel.

00:48:13.170 --> 00:48:15.670
I can basically, again,
take anything I want in

00:48:15.740 --> 00:48:16.460
here and colorize it.

00:48:16.460 --> 00:48:20.100
I can make it yellow, whatever.

00:48:20.100 --> 00:48:21.630
This whole thing is written in Cocoa.

00:48:21.730 --> 00:48:24.360
It's really simple to just
take an NSColor well and

00:48:24.360 --> 00:48:25.890
basically get a color out of it.

00:48:26.000 --> 00:48:29.730
Obviously, if we want to do these,
I'll work two.

00:48:30.790 --> 00:48:34.530
"I spend all day playing with this stuff.

00:48:34.570 --> 00:48:40.390
Now obviously here you can see
the interesting thing is that this

00:48:40.390 --> 00:48:44.160
opacity isn't doing anything anymore.

00:48:44.260 --> 00:48:45.800
And this is because
I don't have blending on.

00:48:45.800 --> 00:48:45.800
Even if I turn it on here,
it still doesn't do anything.

00:48:45.800 --> 00:48:45.800
So you really have to make sure if you're
going to do this that you set up your

00:48:47.200 --> 00:48:48.260
Set up your blending modes properly.

00:48:48.260 --> 00:48:53.680
So I can do, again,
source alpha and one minus source alpha.

00:48:53.680 --> 00:48:54.100
Now I can blend it out.

00:48:54.150 --> 00:48:57.230
Now we can sort of fake
pre-multiplied alpha in this case,

00:48:57.230 --> 00:49:00.700
just to give you guys a better
idea what the math looks like.

00:49:00.700 --> 00:49:04.690
So one of the things my app
can do is I can tell it,

00:49:04.690 --> 00:49:04.690
you

00:49:06.050 --> 00:49:07.000
You can pre-multiply the alpha.

00:49:07.000 --> 00:49:09.300
Now you see it just got dark,
sort of that similar effect to

00:49:09.300 --> 00:49:10.600
what I actually did in here.

00:49:10.600 --> 00:49:11.600
Let me show you.

00:49:11.600 --> 00:49:13.840
Remember that thing I showed
you before where if you had

00:49:13.840 --> 00:49:15.960
the SELRS alpha set wrong,
it got too dark?

00:49:15.960 --> 00:49:19.940
Well, what's happening here is that
I can pre-multiply the alpha

00:49:19.940 --> 00:49:22.100
by the geocolor4f parameter.

00:49:22.150 --> 00:49:26.200
So I can effectively kind of do
that multiply with that part of

00:49:26.320 --> 00:49:29.630
the texture stage instead of doing
the pre-multiply with the blender.

00:49:29.770 --> 00:49:33.090
So if I set this back to 1,
I basically-- I can now

00:49:33.090 --> 00:49:35.950
do the same exact-- well,
hey, turn this off.

00:49:36.890 --> 00:49:41.200
I can do the blending effect here,
even though my source blend factor is 1.

00:49:41.200 --> 00:49:44.480
So there are some cases where if you're
dealing with pre-multiplied alpha

00:49:45.050 --> 00:49:49.510
and you want to additionally fade it,
you'll have to take your alpha value

00:49:49.710 --> 00:49:52.650
and pre-multiply it times the red,
green, blue values that you're passing

00:49:52.650 --> 00:49:53.930
into the geocolor4f call.

00:49:54.040 --> 00:49:56.310
Otherwise the math won't work out right.

00:49:57.750 --> 00:49:59.690
So that was that colorizing thing.

00:49:59.790 --> 00:50:02.380
So the other cool little thing, though,
was that perspective warp

00:50:02.380 --> 00:50:03.420
thing I was talking about.

00:50:03.550 --> 00:50:06.090
So I can kind of take
these guys and do fun,

00:50:06.100 --> 00:50:10.750
really silly stuff and make the math
fall apart and do strange things.

00:50:11.650 --> 00:50:13.900
So the cool part is you don't, you know,
you can really make it look like you're

00:50:13.900 --> 00:50:15.840
standing way on end with this thing.

00:50:15.860 --> 00:50:17.300
You know,
it just sits there with this thing

00:50:17.300 --> 00:50:18.140
and just sits there and takes it.

00:50:18.310 --> 00:50:21.440
Now there are slightly more useful
things you can do with this,

00:50:21.440 --> 00:50:23.090
and I'll get into it here in a second.

00:50:23.150 --> 00:50:25.100
So let me...

00:50:25.200 --> 00:50:26.030
Well, let's see.

00:50:26.030 --> 00:50:27.430
Let's play around here for a second.

00:50:27.510 --> 00:50:28.800
So let's see if we can
just take something.

00:50:28.800 --> 00:50:31.400
I've never tried this before.

00:50:31.680 --> 00:50:36.490
: So this is that background removal
thing that we used in the keynote.

00:50:36.490 --> 00:50:39.650
I've got a little bit
more control over here.

00:50:39.650 --> 00:50:43.410
I get to actually pick the
color and play with it more.

00:50:43.410 --> 00:50:48.120
So I can turn this on, and right now,
you know, removing black isn't

00:50:48.120 --> 00:50:49.700
going to do anything.

00:50:49.790 --> 00:50:52.440
There isn't much black in this image.

00:50:52.440 --> 00:50:53.100
But I can go in here and pick,
for example, a different color.

00:50:53.100 --> 00:50:53.100
So let's see if we can
get this blue out of here,

00:50:53.100 --> 00:50:53.100
for example.

00:50:54.810 --> 00:50:55.650
So, blue's gone.

00:50:55.690 --> 00:50:56.690
I can just take it out.

00:50:56.700 --> 00:50:58.700
Okay.

00:50:58.700 --> 00:51:00.690
Or, you know, I can pick any color.

00:51:00.700 --> 00:51:02.700
I can just sit here and play around
with this whole thing and go,

00:51:02.700 --> 00:51:05.160
"Well, pick the color that you don't
want to show up." You know,

00:51:05.260 --> 00:51:06.700
if you don't want any red,
you don't like green.

00:51:06.700 --> 00:51:09.070
You know,
obviously blue in this case is the one

00:51:09.070 --> 00:51:10.650
you would probably want to get rid of.

00:51:10.700 --> 00:51:16.770
So if we can... What an angle
on these flat panels up here.

00:51:19.280 --> 00:51:21.290
So let's see,
actually to make this more interesting,

00:51:21.300 --> 00:51:24.700
let me start this over real quick.

00:51:24.700 --> 00:51:24.700
Pull in.

00:51:25.690 --> 00:51:27.940
A background first.

00:51:27.940 --> 00:51:30.600
So if I throw this photo
JPEG on here again,

00:51:30.710 --> 00:51:33.980
then throw this guy on top,

00:51:34.570 --> 00:51:36.860
We can again go over here
and get rid of this blue,

00:51:36.860 --> 00:51:39.190
and we should be able to just
see the fish sort of swimming

00:51:39.250 --> 00:51:41.280
on top of this other background.

00:51:42.950 --> 00:51:44.900
So we want that color.

00:51:45.120 --> 00:51:45.600
Oh, oh.

00:51:45.880 --> 00:51:46.900
So what's wrong?

00:51:46.900 --> 00:51:49.400
Anybody know?

00:51:49.660 --> 00:51:51.400
Got to turn on blending.

00:51:51.400 --> 00:51:54.090
So, source alpha.

00:51:55.600 --> 00:51:57.400
One minus source alpha.

00:51:57.480 --> 00:51:59.500
Oh, look at the JPEG artifacts.

00:51:59.500 --> 00:52:01.740
But you can see I've
sort of got this fish,

00:52:01.740 --> 00:52:04.100
you know, now I've pulled out the blue
background of the fish and I've sort

00:52:04.100 --> 00:52:05.300
of got the fish swimming around.

00:52:05.300 --> 00:52:07.530
And we can go ahead and adjust it,
you know.

00:52:10.160 --> 00:52:12.930
- I'm going to pick how much
of it we want to take out.

00:52:12.930 --> 00:52:15.510
You probably want to take out
just as little as possible

00:52:15.890 --> 00:52:17.450
to get the effect you want.

00:52:17.450 --> 00:52:19.780
Obviously,
I can take out enough blue that

00:52:19.780 --> 00:52:21.580
the bottom begins to bleed out.

00:52:21.580 --> 00:52:24.430
You can also play around
with adjusting this.

00:52:25.000 --> 00:52:31.100
[Transcript missing]

00:52:31.310 --> 00:52:34.800
"It's not useful, but anyway.

00:52:34.820 --> 00:52:39.350
But now let me start
this over one more time."

00:52:42.460 --> 00:52:44.940
As we showed before,
I want to build up the whole thing

00:52:44.940 --> 00:52:45.830
that was done in the Keynote.

00:52:45.940 --> 00:52:48.490
Now, for the Keynote they pulled in,
they had like made up that whole

00:52:48.500 --> 00:52:50.490
background all at once so they
didn't have to spend time doing this,

00:52:50.540 --> 00:52:52.390
but I thought it would be useful
to show you guys this stuff again.

00:52:52.400 --> 00:52:56.160
So here we've got one static background
image layer that's pulled in.

00:52:56.320 --> 00:52:59.480
And then we've got this guy again,
so we want to pull in

00:53:01.000 --> 00:53:06.100
[Transcript missing]

00:53:09.000 --> 00:53:10.500
So we've got the background there.

00:53:10.550 --> 00:53:14.400
Now I can bring in, for example,
the people.

00:53:15.420 --> 00:53:19.480
Oops, I just did something stupid there,
but that's okay.

00:53:20.040 --> 00:53:21.470
Three.

00:53:21.470 --> 00:53:21.470
Thank you, Peter.

00:53:21.970 --> 00:53:25.180
So, now I've got this in here again,
and because I threw the

00:53:25.180 --> 00:53:27.900
garbage mat on the other image,
I'm hosed and have to start all over.

00:53:28.010 --> 00:53:30.870
So, I'm going to cheat and just
use this full background image.

00:53:30.890 --> 00:53:34.180
So I don't have to do that
first stage over again.

00:53:34.180 --> 00:53:34.180
So,

00:53:34.530 --> 00:53:35.400
That's everything altogether.

00:53:35.400 --> 00:53:37.400
That's what the real background
is supposed to look like.

00:53:37.400 --> 00:53:39.450
So, again,
I can bring the people over here,

00:53:39.450 --> 00:53:41.610
and you guys all saw this in the keynote,
hopefully, and we can go in and do

00:53:41.720 --> 00:53:44.200
so the same thing again,
so that they'll have a

00:53:44.200 --> 00:53:45.400
little more control over it.

00:53:45.530 --> 00:53:48.400
So I can go in here and
pick this background again.

00:53:48.400 --> 00:53:52.440
And I just get to go in and pick
the green I want to get rid of.

00:53:55.170 --> 00:53:55.880
He's gone.

00:53:55.920 --> 00:53:58.100
Of course, I have to try blending again.

00:53:58.100 --> 00:54:02.070
In this case, it's...

00:54:02.640 --> 00:54:04.350
I don't think it's supposed
to be pre-multiplied.

00:54:04.460 --> 00:54:06.220
So no, we've got the guys walking around.

00:54:06.290 --> 00:54:08.120
And we can do the other blending effect.

00:54:08.210 --> 00:54:12.280
Now, this garbage mat thing,
which I probably should have spent

00:54:12.280 --> 00:54:15.510
a little bit of time on earlier,
is actually using multi-texture.

00:54:15.630 --> 00:54:19.130
So what's happening is we're doing,
if I take this image here,

00:54:19.190 --> 00:54:21.600
let me just actually pull it up.

00:54:21.660 --> 00:54:24.590
So this is just the alpha
garbage mat we're going to use

00:54:24.590 --> 00:54:26.270
to get rid of these people.

00:54:26.720 --> 00:54:30.160
So, what happens when I drag it on top
of this layer is I've done the color

00:54:30.160 --> 00:54:32.140
correction and background removal,
and then I've taken

00:54:32.240 --> 00:54:34.130
another texture stage,
the last texture stage,

00:54:34.180 --> 00:54:36.600
and multiplied the alpha
mask through it as well.

00:54:36.600 --> 00:54:39.130
So now I've gotten rid of
the background and done,

00:54:39.150 --> 00:54:41.470
you know,
gotten rid of all the extra stuff and

00:54:41.470 --> 00:54:44.590
done the color removal all in one basic,
all in one pass.

00:54:44.600 --> 00:54:48.600
Now we can also go in and do this
sort of color correction thing,

00:54:48.600 --> 00:54:53.740
and I can find, oh, that color,
and we kind of want to make

00:54:54.140 --> 00:54:56.600
that more like this color.

00:54:56.600 --> 00:54:59.600
I can go in and sort of tweak that out.

00:54:59.660 --> 00:55:01.600
Or, in this case, it's probably fading it
more than anything else.

00:55:01.600 --> 00:55:07.620
Now, I'm going to turn some of this
stuff off here for just a second.

00:55:08.700 --> 00:55:11.700
Actually, I want to go turn off
blending for just a second.

00:55:11.700 --> 00:55:14.710
No, that's not it.

00:55:15.080 --> 00:55:17.160
Now, you can see that these guys
need to be scaled down,

00:55:17.160 --> 00:55:17.460
right?

00:55:17.600 --> 00:55:21.840
Even if I scale them down,
I can't quite get that, you know,

00:55:21.840 --> 00:55:23.970
the angle sort of wrong on this.

00:55:23.980 --> 00:55:27.450
So, but with the perspective
correction stuff,

00:55:27.450 --> 00:55:29.910
I can kind of go in here and...

00:55:30.450 --> 00:55:33.820
Sort of match them up to where
they're more... the angle they're

00:55:33.820 --> 00:55:36.280
supposed to be to match this scene.

00:55:37.810 --> 00:55:39.700
Now they look like they're
just supposed to be there.

00:55:39.710 --> 00:55:43.200
You can obviously, you know,
make it completely screwy.

00:55:43.800 --> 00:55:45.120
But, you know,
the trick is to play with it a little

00:55:45.130 --> 00:55:46.840
bit and get it just where you want it.

00:55:46.960 --> 00:55:47.540
So there's that.

00:55:47.700 --> 00:55:50.700
And obviously we had the train again.

00:55:50.700 --> 00:55:52.700
And we can do the same
sort of thing there.

00:55:52.700 --> 00:55:53.870
Go in.

00:55:54.960 --> 00:55:57.460
Get rid of the green.

00:55:57.560 --> 00:56:00.210
Make sure we turn on blending.

00:56:04.510 --> 00:56:06.100
And again,
we've got that one last people there.

00:56:06.100 --> 00:56:08.740
And the other green is just
sort of tricky to get rid of.

00:56:08.800 --> 00:56:10.280
And unfortunately,
I'm going to run out of time

00:56:10.280 --> 00:56:12.560
here to show you guys how to
get rid of the other green.

00:56:12.710 --> 00:56:15.630
So again,
I can do the same sort of people movie,

00:56:15.630 --> 00:56:18.390
people mat,
get rid of all the other stuff,

00:56:18.390 --> 00:56:20.520
make sure I turn on blending.

00:56:26.900 --> 00:56:28.900
"I'm going to put this down here.

00:56:28.900 --> 00:56:32.190
See, obviously in the keynote they
didn't have to do all this junk,

00:56:32.220 --> 00:56:34.890
but this gives you guys a
better idea of what's going on.

00:56:34.890 --> 00:56:37.920
So I'm not going to do the color
correction thing on these guys,

00:56:37.920 --> 00:56:39.900
but I can do the perspective correction.

00:56:40.050 --> 00:56:44.750
So, you know, I can sort of get the angle
up and I can basically change

00:56:44.750 --> 00:56:44.750
the different corners of it."

00:56:46.700 --> 00:56:50.260
It takes a little bit of
practice to get them just right.

00:56:50.260 --> 00:56:52.490
But now I can sort of make them
look--they're a little bit tilted.

00:56:52.490 --> 00:56:56.970
But now I can sort of make them look more
like they're supposed to be in the image,

00:56:57.110 --> 00:56:59.620
like they were supposed
to have been there,

00:56:59.620 --> 00:56:59.620
for example.

00:56:59.900 --> 00:57:02.240
So the other sort of cool thing we
can do with the dependent texture,

00:57:02.240 --> 00:57:03.990
you just throw a color matrix on this.

00:57:04.090 --> 00:57:07.990
So I can take these guys off,
so change their brightness.

00:57:08.320 --> 00:57:10.290
"If I want to change the effect,
change the saturation,

00:57:10.300 --> 00:57:11.280
I can make them black and white.

00:57:11.350 --> 00:57:13.910
I can't even change their hue,
which isn't useful if you

00:57:13.950 --> 00:57:15.300
don't have saturation.

00:57:15.440 --> 00:57:17.520
So you can also do other
kinds of color correction.

00:57:17.670 --> 00:57:20.830
This is another example of using
dependent texture reads is to

00:57:20.830 --> 00:57:22.500
use a color matrix for this."

00:57:23.380 --> 00:57:25.890
So anyway, so that's sort of the demo of
rolling all of this different

00:57:25.930 --> 00:57:29.120
stuff together all at once.

00:57:32.160 --> 00:57:35.100
So just to give you guys a real
quick overview of this whole

00:57:35.100 --> 00:57:37.860
application that we're probably
going to turn into sample code,

00:57:37.860 --> 00:57:40.200
so you guys all know how
to do all this stuff.

00:57:40.290 --> 00:57:41.860
I don't want you guys to
have to go through all the

00:57:41.860 --> 00:57:43.040
QuickTime junk I went through.

00:57:43.130 --> 00:57:44.960
QuickTime's cool.

00:57:45.520 --> 00:57:47.000
But it can take some getting used to.

00:57:47.000 --> 00:57:49.860
Unfortunately, I know some of the guys
I'm recognizing back here,

00:57:49.860 --> 00:57:52.190
and Tim and Jean-Marie help
me a lot with all this stuff.

00:57:52.310 --> 00:57:54.390
So thanks to these
QuickTime guys in the back.

00:57:54.510 --> 00:57:56.470
So the whole compositor
lab is Cocoa-based.

00:57:56.620 --> 00:57:58.850
There's basically a really
simple class hierarchy.

00:57:59.010 --> 00:58:02.340
There's one controller object which
sort of drives the whole thing.

00:58:02.440 --> 00:58:06.680
There's a composite GL view,
which is doing all of the GL side

00:58:06.820 --> 00:58:08.400
of the rendering for everything.

00:58:08.400 --> 00:58:11.060
That deals with drawing
the layers bottom to top,

00:58:11.150 --> 00:58:14.400
deals with what texture modes
are supposed to be turned on,

00:58:14.400 --> 00:58:16.390
how to use the texture shader
stuff to do color removal,

00:58:16.390 --> 00:58:18.400
all this other stuff.

00:58:18.540 --> 00:58:21.200
And then the master of
everything is this layer object.

00:58:21.450 --> 00:58:26.380
It does the actual drawing,
has a lot of the layer setup code,

00:58:26.380 --> 00:58:29.610
sets up the texturing,
sets up how to do all

00:58:29.610 --> 00:58:32.280
the client storage stuff,
how to pull everything

00:58:32.280 --> 00:58:33.230
through pretty quickly.

00:58:33.400 --> 00:58:35.350
And then from that I've
got different subclasses.

00:58:35.420 --> 00:58:38.210
So there's one for pulling in
stuff from a QuickTime movie.

00:58:38.500 --> 00:58:40.620
As you saw,
there's one for pulling stuff in

00:58:40.620 --> 00:58:42.340
from a simple DV capture stream.

00:58:42.570 --> 00:58:45.160
There's one for pulling
in from Quartz 2D.

00:58:45.520 --> 00:58:48.550
And then finally there's one
that'll pull in stuff just from

00:58:48.660 --> 00:58:50.350
an NSImage that's dragged in.

00:58:50.530 --> 00:58:55.220
And the code for all the subclasses
is actually really small.

00:58:56.220 --> 00:58:59.100
So everything in this whole
thing is driven by layers.

00:58:59.100 --> 00:59:01.820
The layers just get told, you know,
they get the callbacks

00:59:01.940 --> 00:59:03.200
from QuickTime that says,
hey, I'm dirty,

00:59:03.200 --> 00:59:06.760
and they tell the view system, hey,
you need to redraw at some point.

00:59:06.910 --> 00:59:08.180
The movies are just in play mode.

00:59:08.180 --> 00:59:10.560
I'm not doing the stuff that's
been done before with the set

00:59:10.560 --> 00:59:12.080
movie time to set each frame.

00:59:12.450 --> 00:59:14.710
The movies are just playing
at full performance,

00:59:14.720 --> 00:59:18.340
which is really what you want to do,
because otherwise you're not going

00:59:18.370 --> 00:59:20.220
to get the full streaming thing.

00:59:20.960 --> 00:59:23.880
So just a real quick summary,
since I've got about 20 seconds left.

00:59:23.940 --> 00:59:27.680
So hopefully you guys saw that OpenGL is
really good at doing this type of

00:59:27.690 --> 00:59:29.450
video and graphics integration stuff.

00:59:29.520 --> 00:59:32.670
You can get really, you know,
pretty cool effects without

00:59:32.670 --> 00:59:34.060
using a lot of CPU time.

00:59:34.060 --> 00:59:36.640
You get to leverage all of the
stuff QuickTime knows how to do,

00:59:36.640 --> 00:59:39.420
pulling in live video and what have you.

00:59:39.420 --> 00:59:42.510
And you get really good
compositing effects.

00:59:42.700 --> 00:59:44.620
You get, you know,
all the blending you can ever imagine.

00:59:44.620 --> 00:59:46.520
You know,
plenty of layers is not an issue.

00:59:46.520 --> 00:59:48.300
If you saw the Quartz
Extreme demo yesterday,

00:59:48.300 --> 00:59:51.080
you can just stack layer and layer
and layer and layer on top of stuff,

00:59:51.160 --> 00:59:52.410
and it just sits there and takes it.

00:59:52.460 --> 00:59:55.720
And, you know,
the texture shader stuff is

00:59:55.720 --> 00:59:59.220
just a sort of simple example
of things you can do with this,

00:59:59.220 --> 00:59:59.800
okay?

00:59:59.800 --> 01:00:03.320
Future hardware,
there's going to be so much more you can

01:00:03.320 --> 01:00:06.600
do on the per-pixel level that the sooner
you guys get the stuff into OpenGL,

01:00:06.600 --> 01:00:11.110
the more you're going to be able to take
advantage of that hardware when it comes.

01:00:11.120 --> 01:00:13.940
And trust me,
there's some really cool stuff coming.

01:00:13.940 --> 01:00:16.800
So if at all possible, get on OpenGL,
because, you know,

01:00:16.940 --> 01:00:19.510
once you're on this path,
you'll be able to do some pretty

01:00:19.510 --> 01:00:21.890
amazing stuff stuff with it.

01:00:22.210 --> 01:00:24.540
So, roadmap real quick.

01:00:24.680 --> 01:00:26.600
If you weren't there,
graphics and imaging overview

01:00:26.600 --> 01:00:30.850
gave you a real quick run-through
of all the GNI technologies,

01:00:30.860 --> 01:00:32.090
including some of this stuff.

01:00:32.100 --> 01:00:34.700
Exploring the Quartz
compositor is yesterday,

01:00:34.700 --> 01:00:39.100
where we went over Quartz
Extreme in general.

01:00:39.300 --> 01:00:41.570
Graphics programmability
was also yesterday,

01:00:41.690 --> 01:00:43.600
so I hope you guys didn't miss that one.

01:00:43.780 --> 01:00:45.600
OpenGL integrated graphics
was just before this,

01:00:45.600 --> 01:00:49.810
so Jeff sort of gave the
high-level overview of this stuff.

01:00:50.530 --> 01:01:11.870
This was me.

01:01:11.870 --> 01:01:11.870
So the color sync one you really
won't want to miss because I think

01:01:11.870 --> 01:01:11.870
they're also going to show a demo of
doing the color sync style stuff with

01:01:11.870 --> 01:01:11.870
the same type of code I was doing.

01:01:11.870 --> 01:01:11.870
So you guys can see how to use
real color sync profiles to

01:01:11.870 --> 01:01:11.870
pull off all this type of work.

01:01:11.870 --> 01:01:11.870
For you guys doing game stuff,
obviously the game sessions

01:01:11.870 --> 01:01:11.870
are going to be pretty useful.

01:01:11.870 --> 01:01:11.870
And

01:01:12.900 --> 01:01:15.170
Tomorrow we've got other
advanced 3D effects,

01:01:15.170 --> 01:01:15.890
as Jeff talked about.

01:01:16.000 --> 01:01:18.320
That's going to be incredibly
useful as well if you guys

01:01:18.320 --> 01:01:21.450
want to apply some of the other
OpenGL techniques to this stuff.

01:01:21.530 --> 01:01:24.940
The performance and optimization session
will also go into some of the texture,

01:01:24.980 --> 01:01:27.940
high-speed texture paths and
go into the performance of

01:01:27.940 --> 01:01:29.900
that path a little bit more.

01:01:29.930 --> 01:01:33.040
And you won't want to miss the graphics
and imaging performance tuning session

01:01:33.060 --> 01:01:35.400
if you're trying to do Quartz 2D stuff,
for example,

01:01:35.400 --> 01:01:36.500
and putting that into OpenGL.

01:01:36.500 --> 01:01:38.600
I'm sure those guys will
have good tips for you.

01:01:38.620 --> 01:01:41.200
And the feedback forum is
really useful to us as well.

01:01:41.200 --> 01:01:43.360
Give us feedback on
what else you guys need.

01:01:43.360 --> 01:01:45.300
If there's other sample
code we can provide,

01:01:45.300 --> 01:01:46.190
that would be great.

01:01:46.200 --> 01:01:51.320
So, I'd like to bring
Sergio back up for a Q&A.
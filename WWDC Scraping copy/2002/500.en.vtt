WEBVTT

00:00:00.660 --> 00:00:01.990
Good morning everyone.

00:00:02.050 --> 00:00:04.540
I'm Travis Brown,
I'm the graphics and imaging evangelist,

00:00:04.600 --> 00:00:06.490
and I'd like to welcome
you to session 500,

00:00:06.500 --> 00:00:08.500
which is a graphics and imaging overview.

00:00:08.840 --> 00:00:11.300
Hopefully you all had the opportunity
yesterday to see an exciting

00:00:11.300 --> 00:00:13.410
new announcement that we made,
Quartz Extreme.

00:00:13.500 --> 00:00:17.240
Quartz Extreme is a fantastic
new technology that leverages

00:00:17.240 --> 00:00:21.500
the power of Mac OS X to take
our compositing window model,

00:00:21.500 --> 00:00:24.350
the Quartz Compositor,
and drive that in conjunction with our

00:00:24.350 --> 00:00:28.500
really excellent OpenGL implementation
to do something that's industry leading.

00:00:28.500 --> 00:00:31.530
In fact,
we're two years ahead of the competition,

00:00:31.740 --> 00:00:35.410
delivering a fully composited
GPU leveraging windowing system,

00:00:35.500 --> 00:00:38.450
and a lot of those tools and
techniques that we use to do that

00:00:38.450 --> 00:00:40.290
are available to you as developers.

00:00:40.500 --> 00:00:42.950
The interesting thing is the
Quartz Compositor is not the

00:00:43.040 --> 00:00:44.340
only big announcement we have.

00:00:44.500 --> 00:00:47.170
All throughout the graphics
technology stack in Jaguar,

00:00:47.170 --> 00:00:49.290
we have new developments,
and that's what the

00:00:49.410 --> 00:00:52.060
purpose of this session is,
to communicate the new things that

00:00:52.060 --> 00:00:54.930
we've been up to over the past year,
and how we've taken the power

00:00:55.010 --> 00:00:56.500
of Mac OS X and harnessed it to
do new and interesting things.

00:00:56.500 --> 00:00:56.500
That's what the purpose
of this session is,

00:00:56.500 --> 00:00:56.500
to communicate the new things that
we've been up to over the past year,

00:00:56.500 --> 00:00:56.500
and how we've taken the power
of Mac OS X and harnessed it to

00:00:56.500 --> 00:00:56.500
do new and interesting things.

00:00:56.580 --> 00:00:57.240
That's what the purpose
of this session is,

00:00:57.240 --> 00:00:58.490
to communicate the new things that
we've been up to over the past year,

00:00:58.500 --> 00:00:58.500
and how we've taken the power
of Mac OS X and harnessed it to

00:00:58.500 --> 00:00:58.500
do new and interesting things.

00:00:58.620 --> 00:01:01.400
So what I'd like to do is have
you welcome Peter Graffagnino,

00:01:01.400 --> 00:01:03.240
the Director of Graphics
and Imaging Engineering,

00:01:03.240 --> 00:01:04.500
to stage, and he'll take you
through the presentation.

00:01:04.500 --> 00:01:06.490
Thank you.

00:01:06.500 --> 00:01:07.690
Thanks, Travis.

00:01:10.840 --> 00:01:13.700
Hey everybody, welcome to WWDC.

00:01:13.700 --> 00:01:15.060
Hope you're going to
have a great conference.

00:01:15.060 --> 00:01:18.000
We've got a lot of interesting
stuff in the graphics areas,

00:01:18.000 --> 00:01:21.910
as Travis said, so please attend all the
sessions I'm going to talk

00:01:21.970 --> 00:01:24.650
about here and point you to,
and enjoy the demos

00:01:24.650 --> 00:01:26.160
we have for you today.

00:01:26.590 --> 00:01:32.470
The basic agenda is to do a loop through
all the technologies we have in terms

00:01:32.470 --> 00:01:35.060
of graphics and imaging on the platform.

00:01:35.060 --> 00:01:38.500
That's Quartz 2D, OpenGL,
the Quartz Compositor with the

00:01:38.610 --> 00:01:41.830
new accelerated implementation
called Quartz Extreme,

00:01:41.980 --> 00:01:44.680
ColorSync, Image Capture, and printing.

00:01:44.680 --> 00:01:46.920
I'm going to do a brief
overview of each technology.

00:01:47.000 --> 00:01:48.750
Some of it might be a
little bit of a review,

00:01:48.750 --> 00:01:52.220
but I think we have some new people here
this year who haven't seen it before.

00:01:52.220 --> 00:01:56.140
Then I'm going to focus
on what's new in Jaguar.

00:01:56.620 --> 00:01:59.780
and also show you some demos.

00:02:00.680 --> 00:02:01.600
So let's get started.

00:02:01.600 --> 00:02:04.160
Architecture diagram,
you've all seen this for a few years.

00:02:04.160 --> 00:02:08.570
The graphics stack sit right above the
Core OS and below the Frameworks layer.

00:02:08.840 --> 00:02:12.580
And the three primary
interactive technologies we have,

00:02:12.580 --> 00:02:15.600
APIs you can call to
get bits on the screen,

00:02:15.770 --> 00:02:18.960
are Quartz, the 2D graphics library.

00:02:19.330 --> 00:02:21.080
For 3D, we have OpenGL.

00:02:21.190 --> 00:02:25.360
And for video and multimedia,
we have QuickTime.

00:02:26.060 --> 00:02:29.240
So first I'll talk a
little bit about Quartz.

00:02:29.260 --> 00:02:34.640
Quartz 2D, as we call it,
is our 2D imaging model that's

00:02:34.640 --> 00:02:39.000
based on the industry standard
PostScript and PDF imaging model.

00:02:39.000 --> 00:02:43.160
This imaging model's probably
printed every page you've

00:02:43.160 --> 00:02:46.460
read in the last 20 years,
15 years or so.

00:02:46.660 --> 00:02:48.520
But it's really been industry proven.

00:02:48.520 --> 00:02:52.440
It's got a very robust model for fonts,
line art, graphics, sampled images.

00:02:52.440 --> 00:02:58.530
And what Quartz 2D really is is just
a straightforward C library that's an

00:02:58.650 --> 00:03:01.280
implementation of that imaging model.

00:03:01.280 --> 00:03:03.940
So there's no real language
built into Quartz 2D.

00:03:03.940 --> 00:03:06.920
It's really just an
immediate mode graphics API.

00:03:06.920 --> 00:03:11.530
What we did do was we added PDF read
and write capability to the library

00:03:11.620 --> 00:03:13.880
because we wanted a metafile format.

00:03:13.880 --> 00:03:18.460
In fact, we kind of arrived at the API by
working backwards from the metafile,

00:03:18.460 --> 00:03:21.180
knowing we wanted to record
and play back 2D as PDF.

00:03:21.180 --> 00:03:22.420
And then what kind of
images we wanted to have.

00:03:22.420 --> 00:03:25.360
And then what kind of C API would
we want on top of that that would be

00:03:25.410 --> 00:03:27.280
relatively straightforward to use.

00:03:27.280 --> 00:03:31.460
The other thing we knew is we wanted
to use a lot of nicely anti-aliased

00:03:31.460 --> 00:03:35.290
content in the user interface,
have alpha composited icons,

00:03:35.290 --> 00:03:36.910
have nice looking text.

00:03:37.040 --> 00:03:39.040
And so we knew it had to be really fast.

00:03:39.250 --> 00:03:42.610
So we have a really fast
anti-aliasing algorithm in there

00:03:42.860 --> 00:03:45.000
that's pretty state of the art.

00:03:45.190 --> 00:03:48.130
And we're pretty proud of that.

00:03:48.290 --> 00:03:50.750
The other thing I didn't mention
last year but I think is important

00:03:50.830 --> 00:03:52.400
to understand about Quartz 2D.

00:03:52.400 --> 00:03:55.300
Is it has the concept
of destination alpha.

00:03:55.330 --> 00:04:00.260
Which basically means that it records
the coverage information as it's drawing.

00:04:00.280 --> 00:04:01.510
So this is pretty powerful.

00:04:01.530 --> 00:04:04.160
Not only do you get the RGB value
for every pixel you draw,

00:04:04.160 --> 00:04:06.040
you get a coverage value.

00:04:06.070 --> 00:04:09.280
So for example,
you can clear a canvas to a clear

00:04:09.280 --> 00:04:12.680
color and record in the alpha
just the bits that are shown.

00:04:12.780 --> 00:04:16.630
So you can create, for example,
an overlay pretty easily

00:04:16.690 --> 00:04:18.890
using the destination alpha.

00:04:19.090 --> 00:04:21.370
The other thing that's pretty
important about a 2D graphics

00:04:21.440 --> 00:04:23.000
library is the font support.

00:04:23.000 --> 00:04:26.040
And fortunately,
Apple's been at this for a while,

00:04:26.070 --> 00:04:28.730
and we have a really good type
system called Apple Type System,

00:04:28.740 --> 00:04:30.780
which is built in the Quartz 2D.

00:04:30.780 --> 00:04:37.300
So for all of the PDF font handling,
Apple Type System handles both TrueType,

00:04:37.600 --> 00:04:40.900
and we also have a Type 1
scaler that we got from Adobe.

00:04:40.900 --> 00:04:45.080
So whether it's TrueType, Type 1,
or whatever,

00:04:45.080 --> 00:04:48.000
we can render it with Quartz 2D.

00:04:48.660 --> 00:04:50.660
And finally,
another thing Apple's been at

00:04:50.770 --> 00:04:54.210
for a while is color management,
and we have ColorSync built in.

00:04:54.220 --> 00:05:01.820
The color processing model of PDF is
pretty similar to the ICC model that

00:05:02.190 --> 00:05:04.520
has been a standard for a while.

00:05:04.520 --> 00:05:08.230
And so Quartz 2D,
when it has to do color calculations,

00:05:08.260 --> 00:05:12.360
just builds a color world and
uses ColorSync to do that.

00:05:15.990 --> 00:05:17.560
So what's new in Quartz 2D?

00:05:17.560 --> 00:05:19.800
Well, there's some new features.

00:05:19.800 --> 00:05:24.550
There's a full PDF 1.3 support,
which includes gradients and patterns.

00:05:24.550 --> 00:05:28.200
We, in fact,
have API for linear and radial gradients,

00:05:28.200 --> 00:05:29.790
and we have patterns.

00:05:29.790 --> 00:05:32.880
These are full vector patterns,
not like quick draw patterns you

00:05:32.880 --> 00:05:36.410
might have been familiar with,
but basically arbitrary graphics can be,

00:05:36.410 --> 00:05:38.710
you know,
step and repeat through the page.

00:05:39.440 --> 00:05:41.180
We have transparency in PDF.

00:05:41.180 --> 00:05:44.460
We don't have the full 1.4
transparency model yet,

00:05:44.460 --> 00:05:48.630
but we have the alpha and alpha image
calls that we've had in Quartz 2D for a

00:05:48.720 --> 00:05:53.800
while now get recorded and played back
using the 1.4 transparency operators.

00:05:53.800 --> 00:05:55.870
We also have PDF X3 support.

00:05:55.870 --> 00:06:00.560
PDF X3 is a graphic arts standard
that's emerging for file exchange and

00:06:00.560 --> 00:06:03.770
graphic arts based on the PDF 1.3 spec.

00:06:04.020 --> 00:06:07.500
You have to add a little extra
metadata to the file to get it to work,

00:06:07.500 --> 00:06:09.130
but we have that coming in.

00:06:09.440 --> 00:06:11.110
Jaguar.

00:06:12.030 --> 00:06:13.470
The other important
thing I wanted to make,

00:06:13.540 --> 00:06:16.510
if you went to the keynote yesterday,
you heard Avi kind of touch on using

00:06:16.510 --> 00:06:19.230
native services in your applications.

00:06:19.260 --> 00:06:22.140
And I think a prime example
of this is Quartz 2D.

00:06:22.140 --> 00:06:26.810
We've actually made it pretty easy
from a Carbon application to intermix

00:06:26.810 --> 00:06:29.540
your QuickDraw and Quartz 2D calls.

00:06:29.540 --> 00:06:32.800
We don't necessarily expect
every large Carbon application to

00:06:32.800 --> 00:06:36.030
rip out all of their QuickDraw,
but for certain areas

00:06:36.030 --> 00:06:37.540
it might make sense.

00:06:38.120 --> 00:06:42.500
And one example of this is Excel and
what the guys at Microsoft did

00:06:42.520 --> 00:06:45.130
with the Excel charting engine.

00:06:45.140 --> 00:06:48.080
So, for example,
here's a graphic the way you

00:06:48.120 --> 00:06:50.080
might see it on OS 9 Excel.

00:06:50.080 --> 00:06:54.200
You'll notice you have jaggies
and the rotated text and kind of

00:06:54.200 --> 00:06:56.880
a straightforward looking graphic.

00:06:56.880 --> 00:06:59.800
But then with Quartz 2D,
they were able to add transparency.

00:06:59.800 --> 00:07:02.470
And I apologize for the
scaling of the slide.

00:07:02.480 --> 00:07:04.120
PowerPoint didn't do a great job on that.

00:07:04.170 --> 00:07:05.590
Probably not using Quartz 2D yet.

00:07:07.860 --> 00:07:10.800
The rotation of the text
you can see is much nicer.

00:07:10.880 --> 00:07:14.020
In fact, you know, when this prints,
the rotated text shows up in the file

00:07:14.020 --> 00:07:15.620
as real fonts rather than bitmaps.

00:07:15.780 --> 00:07:19.960
And so all of that is very nice and
gets them better printing as well.

00:07:19.960 --> 00:07:23.100
So they took their chart engine,
which is obviously not all of Office,

00:07:23.100 --> 00:07:27.200
and were able to bring that over
to Quartz 2D pretty reasonably.

00:07:27.200 --> 00:07:28.860
So anyway, keep that in mind.

00:07:28.860 --> 00:07:32.270
There's a couple of things
we've done to make Quartz 2D a

00:07:32.300 --> 00:07:36.360
little easier coming from the
Carbon world and QuickDraw world.

00:07:36.400 --> 00:07:37.820
We've added Quartz.

00:07:37.930 --> 00:07:39.830
We've added Picked
rendering with Quartz 2D.

00:07:39.880 --> 00:07:41.860
This has actually been
in for a little while.

00:07:41.860 --> 00:07:47.350
But we basically take the same logic
in the LaserWriter 8 driver on OS 9,

00:07:47.350 --> 00:07:51.170
if you're familiar with that,
which basically takes QuickDraw

00:07:51.170 --> 00:07:53.720
calls and converts it to the
PostScript imaging model.

00:07:53.720 --> 00:07:57.570
And we've converted that to take
the QuickDraw calls and make

00:07:57.810 --> 00:08:01.960
Core graphics calls or Quartz 2D
calls to enable the playback of

00:08:01.960 --> 00:08:04.460
Picked through a Quartz 2D context.

00:08:04.460 --> 00:08:08.890
And so that gives you the WYSIWYG fonts
and allows you to convert Picked

00:08:08.890 --> 00:08:11.240
to PDF and all those features.

00:08:11.240 --> 00:08:13.380
So that's, you know,
if you're used to Picked,

00:08:13.670 --> 00:08:15.240
that's one thing you can do.

00:08:15.240 --> 00:08:19.240
One thing I don't have on the slide that
I should mention is EPS support as well.

00:08:19.240 --> 00:08:22.240
You can also get
EPS through Core graphics.

00:08:22.250 --> 00:08:25.240
So if that's one of the reasons why you
feel you need to stay with QuickDraw,

00:08:25.410 --> 00:08:29.810
we do have API in Quartz to
handle embedded EPS that will pass

00:08:29.810 --> 00:08:31.230
through to a PostScript printer.

00:08:31.240 --> 00:08:35.240
QuickDraw text rendering with Quartz
2D is another thing we've added,

00:08:35.240 --> 00:08:35.870
which is the ability to, you know,
use Quartz 2D to run a lot

00:08:35.870 --> 00:08:36.160
of the work that we do.

00:08:36.260 --> 00:08:36.700
So that's one thing we've added.

00:08:36.800 --> 00:08:40.990
And then we also have the ability to
take Draw text calls and have them call

00:08:41.050 --> 00:08:47.740
Quartz 2D's rendering facilities to
get anti-alias text through QuickDraw.

00:08:47.740 --> 00:08:49.730
There's a couple of
modes that can run in.

00:08:49.740 --> 00:08:53.540
It can run in a metric-compatible
mode with OS 9 if you can't

00:08:53.540 --> 00:08:55.740
afford your layout to change.

00:08:55.860 --> 00:08:59.390
In that case, you know,
the text doesn't look as great as it

00:08:59.650 --> 00:09:03.740
could if you turn that mode off and you
just use the natural metrics of the font.

00:09:03.740 --> 00:09:05.740
And in some situations,
you're able to do that,

00:09:05.740 --> 00:09:08.020
That's the way you get the best text.

00:09:09.770 --> 00:09:12.300
So we have some sessions on Quartz 2D.

00:09:12.300 --> 00:09:14.830
In fact, later this afternoon,
I think it's in this room,

00:09:14.830 --> 00:09:17.870
there'll be Quartz 2D in PDF to
kind of give you an update

00:09:18.020 --> 00:09:19.640
on what's new in Quartz 2D.

00:09:19.640 --> 00:09:25.120
If you want to hear more about ColorSync,
there's a session 509 on Wednesday.

00:09:25.120 --> 00:09:27.840
And finally,
the Graphics and Image Performance Tuning

00:09:27.840 --> 00:09:31.190
session on Friday at 3.30 is
going to be a pretty good one.

00:09:31.200 --> 00:09:34.760
A lot of tips and techniques on
how to get your application to

00:09:34.760 --> 00:09:39.200
run faster and take advantage of
Quartz 2D and the graphics system.

00:09:41.680 --> 00:09:43.240
So with that,
I'm going to move on to OpenGL.

00:09:43.240 --> 00:09:46.240
OpenGL is our 3D graphics library.

00:09:46.240 --> 00:09:49.710
It's, again,
an industry standard technology.

00:09:49.710 --> 00:09:51.080
It's been around for a long time.

00:09:51.080 --> 00:09:54.070
It was originally the
GL library on the SGI machines.

00:09:54.080 --> 00:09:57.240
It's been kind of an open
standard for maybe about 10 years.

00:09:57.240 --> 00:10:01.840
We work pretty hard with our partners,
our OEMs, NVIDIA and ATI,

00:10:01.840 --> 00:10:04.480
to get really good
drivers into the system.

00:10:04.480 --> 00:10:07.720
And those guys are really pushing
the state of the art in terms of what

00:10:07.730 --> 00:10:09.660
can be done with graphics hardware.

00:10:10.500 --> 00:10:12.830
And actually,
I have a demo of some of the

00:10:12.920 --> 00:10:14.970
latest stuff I can get demo 2 up.

00:10:16.910 --> 00:10:22.040
So this is a Wolfman demo from
NVIDIA running on the GeForce

00:10:22.040 --> 00:10:24.790
4 Ti card we have in here.

00:10:24.800 --> 00:10:28.840
And you can see this is all using
OpenGL and some of the latest

00:10:28.840 --> 00:10:31.890
extensions that NVIDIA added
that we've put in Jaguar as

00:10:32.010 --> 00:10:36.120
well to allow per-pixel shading.

00:10:36.120 --> 00:10:39.190
I think this guy's
about 100,000 polygons,

00:10:39.190 --> 00:10:41.300
100,000 triangles.

00:10:41.300 --> 00:10:43.120
He's got self-shaded fur.

00:10:43.120 --> 00:10:45.130
I can figure out how to stop him here.

00:10:46.800 --> 00:10:48.670
Let's see, shift.

00:10:51.300 --> 00:10:58.300
[Transcript missing]

00:10:59.400 --> 00:11:15.300
[Transcript missing]

00:11:16.930 --> 00:11:22.010
Can I get back to the slide machine,
please?

00:11:23.930 --> 00:11:26.820
So, and obviously GL,
one of the big reasons why we

00:11:26.820 --> 00:11:30.400
have it is for great game support,
and this is 4x4 Evolution 2,

00:11:30.400 --> 00:11:31.860
which has some really great graphics.

00:11:31.940 --> 00:11:35.870
But it's more than just about games.

00:11:35.960 --> 00:11:37.930
I mean,
we feel pretty strongly that there

00:11:37.930 --> 00:11:41.370
are a lot of applications out
there that want to use 3D that,

00:11:41.520 --> 00:11:44.730
you know, are not just, you know,
take over the screen

00:11:44.730 --> 00:11:45.700
immersive experiences.

00:11:45.740 --> 00:11:49.220
So there's a lot of packages out there.

00:11:49.260 --> 00:11:52.100
I won't go through the whole list here,
but a lot of people are kind of jumping

00:11:52.230 --> 00:11:56.560
on OS X because they're realizing the
combination of kind of Unix and OpenGL,

00:11:56.560 --> 00:11:59.850
which, you know,
has been a traditional market for them,

00:11:59.880 --> 00:12:02.300
is actually here on OS X.

00:12:02.300 --> 00:12:04.820
And makes it pretty easy for
them to bring things over.

00:12:04.820 --> 00:12:09.550
So if I get the demo
machine back again...

00:12:12.500 --> 00:12:18.990
I'll bring up the TweakWaves demo,
which I don't know if you saw at

00:12:18.990 --> 00:12:22.740
the Macworld session in January.

00:12:22.740 --> 00:12:25.240
But this is a company
that is in San Francisco.

00:12:25.270 --> 00:12:26.500
They do special effects.

00:12:26.500 --> 00:12:31.970
They specialize in physical
simulations of pretty hard phenomena

00:12:32.070 --> 00:12:33.450
for the special effects industry.

00:12:33.580 --> 00:12:35.500
So they have a good wave simulator.

00:12:35.500 --> 00:12:38.720
And what they wanted to do,
they have this engine is

00:12:38.720 --> 00:12:42.460
all just straight ahead,
pretty portable, Unix C code.

00:12:42.500 --> 00:12:45.760
And what they did is they
spent a little bit of time with

00:12:45.760 --> 00:12:49.500
Cocoa and put a straightforward
user interface on top of it,

00:12:49.690 --> 00:12:53.500
where, you know, they have some pretty
basic controls here.

00:12:53.500 --> 00:12:59.470
You can change the behavior of the model,
crank down the resolution,

00:12:59.470 --> 00:13:03.500
the crest sharpness, things like that.

00:13:03.500 --> 00:13:07.890
They have an appearance thing where
you can have an environment map

00:13:08.000 --> 00:13:10.500
and throw in some geometry there.

00:13:10.500 --> 00:13:12.100
But the nice thing
about this is they have,

00:13:12.100 --> 00:13:14.470
you know, this physics engine that
is very sophisticated.

00:13:14.570 --> 00:13:18.830
And you can imagine taking an application
like this and wrapping it up and kind of,

00:13:18.830 --> 00:13:20.500
you know, if you're trying to bid
on a job or something,

00:13:20.500 --> 00:13:22.470
you say, "Here's what I can do.

00:13:22.510 --> 00:13:23.360
Here's all the controls.

00:13:23.510 --> 00:13:26.000
You know, you can go tweak my
algorithm and tell me if,

00:13:26.000 --> 00:13:27.900
you know,
you can get a good effect for your

00:13:28.040 --> 00:13:31.050
film." And he doesn't have to,
you know, sit over the shoulder with

00:13:31.050 --> 00:13:33.500
the art director or whatever
to kind of get the effect.

00:13:33.500 --> 00:13:36.250
He can just say, you know,
"Tell me the settings you like and I'll

00:13:36.250 --> 00:13:40.440
go run you some frames." So I think
that's a pretty powerful story to have,

00:13:40.520 --> 00:13:44.650
you know, just an engine code written
in straightforward C wrapped

00:13:44.660 --> 00:13:46.500
in a Cocoa user interface.

00:13:46.500 --> 00:13:50.180
And if you went to the session yesterday,
I think you saw an IB demo where

00:13:50.290 --> 00:13:53.670
they actually turned this into
an interface builder palette and

00:13:53.860 --> 00:13:57.470
ran it in Photoshop as a plug-in.

00:13:57.630 --> 00:13:59.500
So pretty impressive.

00:13:59.500 --> 00:14:01.500
Let me go back to slides.

00:14:03.500 --> 00:14:05.030
Thanks.

00:14:07.900 --> 00:14:11.270
So let me spend a few minutes
on Mac OS X OpenGL and talk

00:14:11.410 --> 00:14:13.480
about the architecture there.

00:14:13.480 --> 00:14:15.970
It's really a
state-of-the-art architecture.

00:14:15.980 --> 00:14:21.110
We approached the whole problem as
more of an OS resource management

00:14:21.110 --> 00:14:28.750
problem rather than kind of a dedicated,
hardwired game console architecture

00:14:28.780 --> 00:14:31.720
because we knew we wanted to
host a lot of applications.

00:14:31.720 --> 00:14:36.620
We knew we wanted to accelerate
the whole desktop with OpenGL,

00:14:37.210 --> 00:14:39.580
so we had to be very careful
about our resource optimizations,

00:14:39.580 --> 00:14:46.200
make sure when an application wanted
everything it could out of the GPU,

00:14:46.200 --> 00:14:49.110
everything else paged off and
it can get entire access to it.

00:14:49.160 --> 00:14:51.570
When there are a bunch
of applications going,

00:14:51.570 --> 00:14:52.920
they share it pretty reasonably.

00:14:52.920 --> 00:14:57.140
So there's a lot of optimizations
in the resource virtualization.

00:14:57.140 --> 00:15:01.370
There's data flow optimizations
as well to try to get textures to

00:15:01.430 --> 00:15:03.020
the screen as fast as possible.

00:15:03.020 --> 00:15:06.300
And with some of the Quartz
Extreme technology that you've seen,

00:15:06.440 --> 00:15:15.730
it's really a great tool to bring to
people who are used to doing overlays.

00:15:15.800 --> 00:15:19.510
The other important thing is that
Apple co-develops the drivers.

00:15:19.520 --> 00:15:21.750
We work with NVIDIA and
ATI on their drivers.

00:15:21.760 --> 00:15:24.040
We're in constant contact
with their engineering teams.

00:15:24.040 --> 00:15:25.430
We have the source code.

00:15:25.460 --> 00:15:28.640
We can make changes,
and that allows us to do

00:15:28.740 --> 00:15:31.020
single-stop shopping for developers.

00:15:31.020 --> 00:15:33.680
If developers need a certain
path tuned through the system,

00:15:33.680 --> 00:15:36.340
we can do it once,
and it'll work across all the hardware.

00:15:36.440 --> 00:15:37.440
Which is really nice.

00:15:37.440 --> 00:15:40.870
And so we can respond very
quickly to your request.

00:15:41.030 --> 00:15:42.530
If you need a new feature, for example.

00:15:42.660 --> 00:15:45.740
It takes a few years to get
things in the hardware sometimes,

00:15:45.830 --> 00:15:48.940
but if there's some application
you think would be really cool,

00:15:48.940 --> 00:15:50.790
we can talk to the vendors.

00:15:50.840 --> 00:15:52.920
And since we write them checks,
we can say, "Hey,

00:15:52.920 --> 00:15:57.340
could you throw this in the chip?"
The other thing that's important

00:15:57.340 --> 00:16:01.020
is it allows us to maintain
consistency across the product line.

00:16:01.100 --> 00:16:05.460
I mean,
we do support vendor-specific extensions,

00:16:05.460 --> 00:16:06.240
so we don't take a new product line.

00:16:06.300 --> 00:16:08.240
We don't take an extremely
hard line on that,

00:16:08.320 --> 00:16:10.870
because we realize there's a lot
of innovation in things like pixel

00:16:10.910 --> 00:16:12.320
programming and stuff like that.

00:16:12.480 --> 00:16:18.210
But we do want to maintain things
as consistently as possible.

00:16:18.310 --> 00:16:20.520
So for example,
non-power-of-two texturing.

00:16:20.520 --> 00:16:22.100
NVIDIA has an extension.

00:16:22.100 --> 00:16:23.230
ATI has an extension.

00:16:23.240 --> 00:16:25.640
We just did one,
and we made it work on everything.

00:16:28.450 --> 00:16:30.500
The other thing is,
since we work closely with the

00:16:30.500 --> 00:16:33.550
vendors and write them big checks,
is that we have a lot of

00:16:33.550 --> 00:16:36.460
visibility into what's going
on with 3D graphics hardware.

00:16:36.460 --> 00:16:40.330
So we can help push your requests,
as I was saying,

00:16:40.330 --> 00:16:45.440
and sometimes we can find a unique
solution if you have a problem.

00:16:45.440 --> 00:16:50.560
Since we can kind of see the whole stack,
we can understand exactly where the

00:16:50.650 --> 00:16:53.300
best place to meet your need would be.

00:16:53.300 --> 00:16:56.830
And we're also starting to take more
of a leadership role in the OpenGL ARB.

00:16:56.970 --> 00:17:00.550
The ARB is the
Architecture Review Board for OpenGL,

00:17:00.830 --> 00:17:02.890
where all of the standard is set.

00:17:02.920 --> 00:17:06.320
And Apple has been extremely
vocal recently with trying to

00:17:06.370 --> 00:17:10.540
get the vendors to converge on a
vertex programming specification.

00:17:10.540 --> 00:17:12.400
And we think that's
going along really well.

00:17:12.400 --> 00:17:14.120
In fact, that's in your CD.

00:17:17.210 --> 00:17:19.100
So what's new in OpenGL for Jaguar?

00:17:19.100 --> 00:17:20.050
Well, there's a whole lot.

00:17:20.300 --> 00:17:23.670
There's programmable shaders,
so we have programming at the

00:17:24.040 --> 00:17:25.670
vertex and the pixel level.

00:17:25.680 --> 00:17:27.800
A lot of system integration features.

00:17:27.850 --> 00:17:32.600
We've got real great improvements
in texture upload performance.

00:17:32.600 --> 00:17:36.580
Lots of new extensions
and some amazing tools.

00:17:36.580 --> 00:17:39.180
And a lot of the work
that we did for OpenGL,

00:17:39.190 --> 00:17:42.040
we had to do for the
Quartz Extreme effort.

00:17:42.300 --> 00:17:44.210
And we kind of made the bet that, hey,
you know,

00:17:44.210 --> 00:17:47.060
if we're going to try to run the
windowing system through OpenGL,

00:17:47.060 --> 00:17:50.010
I'll bet all the performance
optimizations we have to do to OpenGL are

00:17:50.010 --> 00:17:51.900
just going to make OpenGL even better.

00:17:51.900 --> 00:17:53.500
And that really turned out to be true.

00:17:55.190 --> 00:17:58.260
So for example, programmable shaders.

00:17:58.360 --> 00:18:04.300
We have vertex shading based on the
Arb Vertex program proposed standard.

00:18:04.620 --> 00:18:07.340
Pixel and texture shading,
the vendors have not quite

00:18:07.340 --> 00:18:10.300
converged on that yet,
so we're currently using the

00:18:10.300 --> 00:18:12.600
vendor-specific extensions.

00:18:12.620 --> 00:18:15.590
On the NVIDIA side,
there's Texture Shader 1, 2, 3,

00:18:15.690 --> 00:18:17.710
and register combiners.

00:18:18.060 --> 00:18:21.960
And on the ATI side,
I think it's actually ATI, not ATI-X,

00:18:21.960 --> 00:18:23.510
fragment program.

00:18:24.840 --> 00:18:27.970
We have a great new tool
for Vertex programs called

00:18:27.970 --> 00:18:29.500
the OpenGL Shader Builder.

00:18:29.720 --> 00:18:35.780
It's kind of a mini-IDE for
developing little shading programs.

00:18:35.890 --> 00:18:41.110
I've got on the left my

00:18:41.310 --> 00:18:45.880
program window where I can talk
about the-- enter code and have

00:18:45.880 --> 00:18:47.800
it syntax-checked in real time.

00:18:47.990 --> 00:18:49.460
I've got a preview of what I'm doing.

00:18:49.560 --> 00:18:53.340
I've got a complete register dump of
the state of the vertex processor.

00:18:53.340 --> 00:18:56.360
We can actually run it in
software emulation mode,

00:18:56.380 --> 00:18:59.460
so you can actually examine registers
as you step through the code.

00:18:59.470 --> 00:19:05.100
We've got documentation
for the various commands.

00:19:05.150 --> 00:19:07.190
You can, you know,
click on a command and see a

00:19:07.260 --> 00:19:09.400
little syntax of how to use it.

00:19:09.420 --> 00:19:11.040
So it's a real powerful tool.

00:19:11.040 --> 00:19:13.420
If you go to the session
on vertex programming,

00:19:13.460 --> 00:19:15.760
I think you'll be pretty
impressed with that.

00:19:15.900 --> 00:19:18.780
System integration-- again,
a lot of this work came from doing

00:19:19.130 --> 00:19:22.080
the windowing system on top of GL.

00:19:22.280 --> 00:19:24.730
So quartz on a texture.

00:19:24.790 --> 00:19:28.500
We've got really high-quality
2D anti-aliasing in quartz,

00:19:28.580 --> 00:19:35.790
and it matches up well with the
ARGB texture formats that we

00:19:35.840 --> 00:19:39.240
have optimized in our OpenGL.

00:19:39.310 --> 00:19:43.020
So you can basically get quartz
to draw into an ARGB texture,

00:19:43.020 --> 00:19:46.210
and that's a pre-multiplied texture,
which you can then use in a scene

00:19:46.220 --> 00:19:48.560
with the appropriate blending modes,
and you get really nice

00:19:48.620 --> 00:19:51.540
text in your OpenGL,
and it's very straightforward.

00:19:51.540 --> 00:19:54.220
The other important thing, obviously,
was video if we're gonna be running

00:19:54.220 --> 00:19:56.140
the windowing system through OpenGL.

00:19:56.170 --> 00:19:58.570
So we have non-power-of-two textures.

00:19:58.580 --> 00:20:03.120
We have YUV texture formats,
a variety of formats required there.

00:20:03.130 --> 00:20:04.860
The other thing,
now that the windowing system

00:20:04.880 --> 00:20:09.690
is on top of GL as well,
is it allows us to do things like

00:20:09.690 --> 00:20:12.490
overlays in a much more natural way,
rather than having, you know,

00:20:12.550 --> 00:20:14.380
separate planes of the frame buffer.

00:20:14.380 --> 00:20:19.770
You actually have just another
off-screen surface in video memory

00:20:20.080 --> 00:20:22.560
that you can render and update
at whatever frequency you want,

00:20:22.560 --> 00:20:25.720
and you can render your GL underneath
at whatever frequency you want,

00:20:25.720 --> 00:20:28.030
and the windowing system will
just keep compositing those

00:20:28.110 --> 00:20:30.940
every frame update for you.

00:20:31.310 --> 00:20:33.900
And that allows, you know,
pretty interesting new heads-up

00:20:34.070 --> 00:20:38.160
user interfaces for 3D apps,
I think, where, you know,

00:20:38.200 --> 00:20:41.790
you're not constrained by an overlay
system where you have to give,

00:20:41.800 --> 00:20:43.500
you know, concrete per-pixel ownership.

00:20:43.610 --> 00:20:45.900
You could have a
translucent user interface,

00:20:45.920 --> 00:20:49.520
like a drag selection over 3D content,
that sort of thing.

00:20:49.520 --> 00:20:52.910
So we think that'll be a good
thing to take advantage of.

00:20:53.450 --> 00:20:57.120
Texture upload performance,
we put a lot of work into this.

00:20:57.120 --> 00:21:01.230
We have direct EMA from all of the
native kind of Mac texture formats

00:21:01.300 --> 00:21:04.140
with no per-pixel CPU involvement.

00:21:04.140 --> 00:21:09.960
What this means is when you call
GL Text Image 2D or something like that,

00:21:09.960 --> 00:21:12.480
GL does not actually copy the data.

00:21:12.480 --> 00:21:16.550
If you put it in client texture mode,
it'll just refer the data and

00:21:16.550 --> 00:21:20.180
then dynamically map it into
AGP when it needs to use it.

00:21:20.480 --> 00:21:23.120
Now this obviously introduces
a synchronization issue.

00:21:23.120 --> 00:21:25.180
If you're going to go
and touch that texture,

00:21:25.330 --> 00:21:27.410
you need to know that the
hardware is done with it.

00:21:27.570 --> 00:21:31.860
So we have a fence primitive that
you can insert after that texture,

00:21:31.990 --> 00:21:37.220
and when the pipe clears that texture,
you can wait on that fence and have it go

00:21:37.220 --> 00:21:40.310
on with your work and update the texture.

00:21:40.320 --> 00:21:42.650
So these things were
particularly important in

00:21:42.650 --> 00:21:44.340
doing the Quartz Extreme work.

00:21:50.100 --> 00:21:52.760
And here's the, I think,
pretty accurate list of 30 or more

00:21:52.760 --> 00:21:56.100
extensions that we're adding in Jaguar.

00:21:56.100 --> 00:21:59.510
You can see there's a
combination of Apple extensions,

00:21:59.510 --> 00:22:02.800
where we tried to synthesize
things that were out there already.

00:22:02.820 --> 00:22:06.080
There's ARB extensions from
the Architecture Review Board.

00:22:06.200 --> 00:22:08.790
Then there's some
multi-vendor extensions,

00:22:08.860 --> 00:22:10.100
those are the EXTs.

00:22:10.100 --> 00:22:12.660
And then there's some
proprietary extensions,

00:22:12.660 --> 00:22:15.900
a bunch of things from ATI and
from NVIDIA for doing all the real

00:22:15.900 --> 00:22:18.100
low-level pixel programming stuff.

00:22:18.100 --> 00:22:20.340
So anyway, we think people are going to
be pretty excited about that.

00:22:20.340 --> 00:22:24.600
We had an OpenGL early
bird session on Sunday,

00:22:24.600 --> 00:22:29.600
and people were pretty blown
away by the new features there,

00:22:29.600 --> 00:22:30.820
so great.

00:22:30.980 --> 00:22:33.990
OpenGL Profiler is another really
interesting tool that we have.

00:22:34.210 --> 00:22:38.690
It's kind of a performance analysis
console that allows you to attach

00:22:39.000 --> 00:22:43.830
basically to anything that's running,
any OpenGL application that's running.

00:22:43.840 --> 00:22:44.920
You can attach to it.

00:22:44.920 --> 00:22:48.300
You can get a complete list of the
OpenGL calls and their frequencies,

00:22:48.300 --> 00:22:49.860
how often it's being made.

00:22:49.860 --> 00:22:52.640
You can get a call dump of all
the arguments to all the calls.

00:22:52.650 --> 00:22:54.620
You can get a hardware
performance monitor.

00:22:54.620 --> 00:22:55.840
You can trace VRAM used.

00:22:55.850 --> 00:22:58.440
You can trace hardware wait
time on various queues.

00:22:58.460 --> 00:23:03.010
You can trace, I don't know,
command buffer wait time.

00:23:03.020 --> 00:23:09.340
You know, there's about 30 different
little items you can measure.

00:23:09.340 --> 00:23:14.120
And you can attach to applications
and get all these great statistics.

00:23:14.120 --> 00:23:17.460
And we've had some developers in
and gave them a sneak peek at this,

00:23:17.480 --> 00:23:19.840
and people are able to get incredible,
I mean,

00:23:19.900 --> 00:23:23.560
the low-hanging fruit out there on
some of the apps is pretty amazing.

00:23:23.560 --> 00:23:27.690
So I won't embarrass anyone,
but the tool like this.

00:23:28.300 --> 00:23:31.460
The great thing about this tool, too, is,
you know, there are some performance

00:23:31.460 --> 00:23:33.700
profilers out there that some
of the hardware vendors do,

00:23:33.710 --> 00:23:34.770
which are quite good.

00:23:34.820 --> 00:23:36.600
But the issue there is
then you've got to learn,

00:23:36.610 --> 00:23:41.710
you know, ATI's tool set or NVIDIA's
tool set to be able to do that.

00:23:41.770 --> 00:23:42.830
And, you know,
they don't always have the time

00:23:42.950 --> 00:23:43.880
to port those things to the Mac.

00:23:44.040 --> 00:23:49.350
But now we have one central tool
that you can use in your apps.

00:23:49.480 --> 00:23:51.450
And whether you're running on
ATI hardware or NVIDIA hardware,

00:23:51.450 --> 00:23:52.760
you can see where you're waiting.

00:23:52.760 --> 00:23:54.340
So we think that's a pretty nice thing.

00:23:56.800 --> 00:23:58.140
Great.

00:23:58.140 --> 00:24:01.240
Keep it up.

00:24:01.360 --> 00:24:03.730
OpenGL guys are in the audience,
I like that.

00:24:03.860 --> 00:24:07.640
So we got a bunch of
sessions on OpenGL going on.

00:24:07.640 --> 00:24:13.420
We've got the programmability
session late today in this room,

00:24:13.480 --> 00:24:14.340
I guess.

00:24:14.340 --> 00:24:18.540
We've got two sessions tomorrow on
what we call integrated graphics.

00:24:18.580 --> 00:24:22.270
And these are all things in the
area of doing video on the texture,

00:24:22.270 --> 00:24:24.250
doing 2D on the texture.

00:24:24.470 --> 00:24:27.090
In the 5.06 session, we're gonna,
in fact,

00:24:27.170 --> 00:24:29.890
show you how to build kind of your
own little Quartz extreme using

00:24:29.890 --> 00:24:33.310
all the stuff we learned and all
the extensions for doing really

00:24:33.330 --> 00:24:35.740
fast layer handling in OpenGL.

00:24:35.810 --> 00:24:40.200
And that's gonna be a sample
code that we just give away.

00:24:40.270 --> 00:24:44.130
And in 5.13,
there's an advanced 3D session.

00:24:44.140 --> 00:24:46.380
I think we're gonna get
a guest speaker for that.

00:24:46.500 --> 00:24:49.110
Is that confirmed?

00:24:49.550 --> 00:24:50.300
Shout it out?

00:24:50.410 --> 00:24:50.720
No?

00:24:50.860 --> 00:24:51.560
Yes?

00:24:51.680 --> 00:24:52.920
Maybe.

00:24:53.600 --> 00:24:54.400
Well, go to that session.

00:24:54.400 --> 00:24:57.520
It promises to be good.

00:24:57.910 --> 00:25:09.090
OpenGL performance optimizations are
going to talk you through some of the

00:25:09.090 --> 00:25:09.090
common pitfalls in OpenGL programming
and also look at the tools,

00:25:09.090 --> 00:25:09.090
the profiler, show you how to use that.

00:25:09.510 --> 00:25:13.150
So the last sort of drawing
API that we have is QuickTime.

00:25:13.200 --> 00:25:15.000
I'm not really going to
talk a lot about QuickTime.

00:25:15.000 --> 00:25:16.960
You saw some of the demos in the keynote.

00:25:17.120 --> 00:25:20.750
QuickTime with QuickTime 6 and MPEG-4,
obviously really big news.

00:25:20.760 --> 00:25:24.330
There's a whole track tomorrow
on QuickTime in this room,

00:25:24.330 --> 00:25:28.990
and there's also some sessions on Friday,
so don't forget about those.

00:25:32.500 --> 00:25:34.650
Okay,
so those are kind of all the APIs you

00:25:34.700 --> 00:25:36.880
can use to get data to the screen.

00:25:36.880 --> 00:25:42.780
There's another important
piece of technology on OS X,

00:25:42.780 --> 00:25:44.350
which is the windowing system itself.

00:25:44.350 --> 00:25:46.740
And that's what we call
the Quartz Compositor.

00:25:46.740 --> 00:25:50.050
We talked about this last year,
but the basic notion is

00:25:50.050 --> 00:25:53.880
you've got application content
from arbitrary drawing APIs,

00:25:53.880 --> 00:25:58.970
and the Quartz Compositor is responsible
for presenting those on the display.

00:25:59.640 --> 00:26:04.160
And so the nice thing about this
is it realizes the orthogonality

00:26:04.200 --> 00:26:08.640
between the composition of the
desktop and a graphics API.

00:26:08.640 --> 00:26:11.720
So all graphics APIs are peers,
whether they're hardware

00:26:11.720 --> 00:26:13.940
accelerated or rendered in software.

00:26:13.940 --> 00:26:17.400
We get the pixels to the screen
in the fastest way possible

00:26:17.510 --> 00:26:19.540
and present them to the user.

00:26:19.540 --> 00:26:23.820
So we think the Compositor
architecture could outlast any

00:26:23.820 --> 00:26:26.400
graphics API that's out there.

00:26:26.880 --> 00:26:30.140
It gives us a lot of
flexibility moving forward.

00:26:30.140 --> 00:26:32.570
If a new graphics API comes along,
we can just add it in

00:26:32.570 --> 00:26:33.940
and it'll get composited.

00:26:36.320 --> 00:26:41.590
So this borrows some principles that have
been known in computer graphics for a

00:26:41.590 --> 00:26:43.740
while called digital image composition.

00:26:43.740 --> 00:26:46.930
In the paper in 1984,
Porter and Duff introduced the

00:26:46.930 --> 00:26:49.130
alpha channel and alpha compositing.

00:26:49.140 --> 00:26:51.580
And back in those days,
it was you had one program that

00:26:51.580 --> 00:26:54.490
could do spheres and another
program that could do terrain.

00:26:54.490 --> 00:26:56.410
And if you wanted to do a scene,
you didn't want to run

00:26:56.590 --> 00:26:57.710
them both all the time.

00:26:58.160 --> 00:27:00.400
So you needed a way to
kind of mix the content.

00:27:00.400 --> 00:27:02.800
And, you know,
that's sort of analogous to, you know,

00:27:02.800 --> 00:27:04.140
fast forward 20 years.

00:27:04.140 --> 00:27:05.940
What we're doing today is
we've got applications.

00:27:05.940 --> 00:27:08.880
We don't want them all
redrawing every screen update.

00:27:08.880 --> 00:27:13.600
We want to be able to recomposite the
display as one element is changing.

00:27:13.600 --> 00:27:18.840
So we're just applying those techniques
in real time with the Windows system.

00:27:18.860 --> 00:27:22.990
So that allows us to do, you know,
a windowing system like this

00:27:23.300 --> 00:27:25.150
where we've got QuickTime.

00:27:25.150 --> 00:27:27.400
We have the Wolf demo you saw.

00:27:27.400 --> 00:27:27.820
We've got the Translator.

00:27:28.040 --> 00:27:30.220
We've got the Transparent
Terminal with the volume control

00:27:30.220 --> 00:27:32.470
all being composited together.

00:27:32.800 --> 00:27:36.150
You know,
obviously the great looking Aqua icons

00:27:36.150 --> 00:27:39.140
and all that stuff clock in the corner.

00:27:40.700 --> 00:27:42.940
You see that CPU monitor's
up pretty high.

00:27:42.940 --> 00:27:46.460
What are we gonna do about that?

00:27:46.540 --> 00:27:49.270
So just to review the model,

00:27:49.420 --> 00:27:55.630
So applications drawn to buffers,
and then the buffers are composited

00:27:55.630 --> 00:27:55.630
together onto the screen.

00:27:55.810 --> 00:27:58.950
So, as you saw the CPU meter there,
the model can be computationally

00:27:59.010 --> 00:28:01.830
expensive in some cases if
there's a lot of transparency,

00:28:01.850 --> 00:28:04.580
particularly if you're trying to blend,
say, video, say,

00:28:04.590 --> 00:28:07.760
the volume control with video
or DVD or something like that.

00:28:07.760 --> 00:28:11.430
And we also get issues with people
who are concerned that we've

00:28:11.430 --> 00:28:13.380
taken away the frame buffer.

00:28:13.380 --> 00:28:17.370
But we haven't been able to tell the
whole story of why we're going in

00:28:17.370 --> 00:28:20.000
this direction until this conference.

00:28:20.000 --> 00:28:22.940
So, we've been working on Quartz
Extreme for a long time,

00:28:22.940 --> 00:28:26.110
and the whole driver architecture
on OS X is based around it.

00:28:26.220 --> 00:28:28.040
So,
it's kind of nice to be able to finally,

00:28:28.040 --> 00:28:29.960
you know, tell you guys what we're up to.

00:28:29.980 --> 00:28:33.040
Which is,
we really see GPUs kind of taking over

00:28:33.040 --> 00:28:35.920
the presentation aspect of the desktop.

00:28:35.920 --> 00:28:39.130
And so,
we went and we implemented the Quartz

00:28:39.130 --> 00:28:41.900
compositing logic on top of OpenGL.

00:28:41.900 --> 00:28:45.840
The nice thing about that is
that it completely removes the

00:28:45.840 --> 00:28:48.540
transparency tax for video in 3D.

00:28:48.540 --> 00:28:49.970
So, you can have layers of terminal.

00:28:50.000 --> 00:28:52.450
On top of 3D and video,
and everything just works.

00:28:52.580 --> 00:28:59.070
It frees up the CPU to do useful work
while the screen composite's going on.

00:28:59.100 --> 00:29:03.300
And it allows us to kind of showcase
the GPU and the user interface.

00:29:03.360 --> 00:29:05.970
So, if you have, like,
some screen animation,

00:29:05.970 --> 00:29:09.160
maybe it works a little better
on a higher-end machine.

00:29:09.160 --> 00:29:13.440
Maybe there's some little flourish to it
that we put in for our high-end users.

00:29:13.440 --> 00:29:17.060
But we really think that we're
going to get a lot of advantages

00:29:17.060 --> 00:29:18.890
out of something like that.

00:29:18.940 --> 00:29:21.240
And as I said,
since it's all available to you,

00:29:21.240 --> 00:29:23.000
you guys can do that too.

00:29:23.400 --> 00:29:28.900
So, with that, let's do a demo.

00:29:28.900 --> 00:29:35.210
If I can get the demo, demo two.

00:29:38.780 --> 00:29:44.970
So kind of the first thing to see
is the translucent terminal demo.

00:29:45.200 --> 00:29:47.080
Oh, these are great.

00:29:47.800 --> 00:29:48.800
That was a great demo.

00:29:48.800 --> 00:29:51.000
Let me get my CPU monitor going here.

00:29:51.000 --> 00:29:54.190
One of the things I have
is a little frame counter.

00:30:16.590 --> 00:30:16.590
So this just kind of shows you the
frame rate we get on the display.

00:30:16.590 --> 00:30:16.590
So I've got about three layers.

00:30:16.590 --> 00:30:16.590
It subtracts out itself,
so that's why it sits at zero.

00:30:16.590 --> 00:30:16.590
We've got about three layers
of terminal going on here,

00:30:16.590 --> 00:30:16.590
and you can see what happens
when I start to drag a window.

00:30:17.000 --> 00:30:29.300
[Transcript missing]

00:30:29.800 --> 00:30:40.670
Add a few more layers and there it is.

00:30:40.670 --> 00:30:40.670
So, that's pretty cool.

00:30:40.670 --> 00:30:40.670
Thanks.

00:30:40.670 --> 00:30:40.670
But wait.

00:30:41.150 --> 00:30:44.080
So one of the things that we
weren't able to do before Jaguar

00:30:44.180 --> 00:30:49.400
was be able to really have 3D take
its proper place in this scene.

00:30:49.400 --> 00:30:52.490
I mean, you always had 3D with a
black rectangle around it,

00:30:52.490 --> 00:30:55.310
and it was just blasting to the hardware.

00:30:55.370 --> 00:30:58.990
But now, with Quartz Extreme,
we can just put 3D in a layer,

00:30:58.990 --> 00:31:02.600
and then add-- you can see that
gear is actually transparent,

00:31:02.600 --> 00:31:06.440
and it's animating,
and it's in its own layer in the system.

00:31:06.440 --> 00:31:10.600
And you can see I'm getting
pretty good frame rate.

00:31:13.370 --> 00:31:16.000
So the 3D is somehow able to get over 60.

00:31:16.000 --> 00:31:20.460
I'll have to ask the 3D guys
how they pulled that one off.

00:31:21.600 --> 00:31:26.600
Here's a couple more little
widgets we can get going here.

00:31:26.600 --> 00:31:31.090
And we're pretty much pegged
at 70 frames a second here.

00:31:31.160 --> 00:31:40.410
So, and they're all on their own layers,
as you would expect.

00:31:47.000 --> 00:31:49.240
What was I going to do next?

00:31:49.240 --> 00:31:53.390
Let's bring up another
3D widget on the desktop,

00:31:53.400 --> 00:31:55.000
which is the NVIDIA Chameleon.

00:31:55.060 --> 00:31:59.470
So the guys went in and they took
the NVIDIA Chameleon demo and kind

00:31:59.470 --> 00:32:01.000
of stripped out the vine he walks on.

00:32:01.000 --> 00:32:02.990
I don't know if you guys
have seen this demo.

00:32:03.030 --> 00:32:06.000
And made him render
on a clear background.

00:32:06.000 --> 00:32:10.990
And then Quartz Extreme comes
in and composites him in.

00:32:11.040 --> 00:32:13.230
So he's actually transparent.

00:32:14.090 --> 00:32:16.000
You know, he's running with, you know,
full vertex shading

00:32:16.000 --> 00:32:20.290
and all of that stuff,
just getting blended into the desktop,

00:32:20.360 --> 00:32:21.420
you know.

00:32:23.000 --> 00:32:44.300
[Transcript missing]

00:32:45.600 --> 00:32:50.780
We were talking to the guy
who works on the screensavers,

00:32:50.840 --> 00:32:54.160
Mike Trent, about the Quartz Extreme,
and he's like, "You know,

00:32:54.210 --> 00:32:57.370
I could take the screensavers and just
run them in the background because

00:32:57.370 --> 00:32:58.780
everything's getting composited.

00:32:58.970 --> 00:33:02.550
So what's the window number
to get between the desktop and

00:33:02.720 --> 00:33:07.700
the icons?" And so we're like,
"Eh, well..." So we told Mike.

00:33:10.300 --> 00:33:18.600
[Transcript missing]

00:33:23.200 --> 00:33:25.420
- Cruising along about
60 frames a second,

00:33:25.420 --> 00:33:26.780
everything's pretty interactive.

00:33:26.820 --> 00:33:30.250
This is a GeForce 4 TI in here,
so it's not breaking

00:33:30.300 --> 00:33:32.110
much of the sweat yet.

00:33:32.210 --> 00:33:38.040
I think if you go to
Ken Dyke's session later,

00:33:38.040 --> 00:33:38.040
you'll try to see where it breaks down.

00:33:38.210 --> 00:33:41.190
This thing's got 10 gigabytes per second
of memory bandwidth on the video card,

00:33:41.300 --> 00:33:47.630
so probably a number you haven't
really dealt with before.

00:33:49.770 --> 00:33:51.700
So I think that's enough on that demo.

00:33:53.020 --> 00:33:54.940
Great, thanks.

00:34:00.150 --> 00:34:03.570
So a few things I wanted to talk
about on kind of a different level

00:34:03.570 --> 00:34:06.380
than you might see in the kind of
keynote demo of this kind of stuff,

00:34:06.460 --> 00:34:10.290
but kind of why architecturally
we're moving towards this

00:34:10.470 --> 00:34:11.760
fully accelerated desktop.

00:34:11.760 --> 00:34:15.410
And it kind of goes back to just first
principles of computer architecture,

00:34:15.460 --> 00:34:17.010
looking at programmed I.O.

00:34:17.010 --> 00:34:17.880
versus DMA.

00:34:17.880 --> 00:34:19.940
You know, in programmed I.O.

00:34:19.940 --> 00:34:24.590
model, traditionally the CPU, you know,
maps in some registers and pushes

00:34:24.590 --> 00:34:26.500
on data to send it to a device.

00:34:27.200 --> 00:34:30.710
The problem is that the difference,
you know, in the compute capacity of a,

00:34:30.730 --> 00:34:33.360
say,
gigahertz CPU and a 100 megahertz I.O.

00:34:33.360 --> 00:34:34.980
bus is pretty inefficient.

00:34:34.980 --> 00:34:39.030
So traditionally what people have done
is they've moved to a DMA-based I.O.

00:34:39.030 --> 00:34:42.320
model where you tell the device
you want it to take its commands

00:34:42.350 --> 00:34:45.450
or its data from a certain area,
and you tell it to go,

00:34:45.610 --> 00:34:49.520
and then it just directly
pulls the memory to the device,

00:34:49.520 --> 00:34:53.390
and you can check when it's done
or get an interrupt or however the

00:34:53.390 --> 00:34:55.320
driver architecture wants to do it.

00:34:55.380 --> 00:34:56.970
And that allows the CPU to proceed.

00:34:57.040 --> 00:34:58.500
And do something else while the I.O.

00:34:58.500 --> 00:34:59.150
is occurring.

00:34:59.160 --> 00:34:59.970
Because I.O.

00:34:59.970 --> 00:35:02.420
is really basically a pretty
straightforward thing,

00:35:02.550 --> 00:35:05.460
and there's no reason to, you know,
spend your CPU doing it.

00:35:05.520 --> 00:35:08.640
So if you think about it,
the CPU drawing in the frame buffer,

00:35:08.640 --> 00:35:11.290
and the reason we took it away,
is the CPU really is,

00:35:11.290 --> 00:35:13.210
it really is just programmed I.O.

00:35:13.220 --> 00:35:14.620
is what you're doing.

00:35:14.620 --> 00:35:16.530
That's not a very
efficient way to do things.

00:35:16.560 --> 00:35:19.750
And the cards have plenty of bandwidth
to pull the data out of system memory

00:35:19.750 --> 00:35:21.560
while you're doing something else.

00:35:21.560 --> 00:35:26.260
And you can get much higher frame rates
DMA-ing your content up to the screen.

00:35:26.360 --> 00:35:31.100
and you can actually try to reach out
over the bus and touch pixels anyway.

00:35:32.540 --> 00:35:35.580
Another interesting kind of thing
that's going on in the industry is

00:35:35.580 --> 00:35:37.570
the difference between CPUs and GPUs.

00:35:37.630 --> 00:35:46.530
CPUs typically have a higher clock rate,
but they do less work because they

00:35:46.650 --> 00:35:48.500
can't be parallelized as much.

00:35:48.500 --> 00:35:50.310
You know,
you think of them hitting little

00:35:50.410 --> 00:35:53.240
4K pages and taking little sips
of water out of the memory system,

00:35:53.240 --> 00:35:55.090
whereas a GPU is just
sort of gulping along,

00:35:55.090 --> 00:35:57.500
chunking through, you know,
gigabytes per second.

00:35:58.800 --> 00:36:01.350
The other thing is people
in the industry have kind of

00:36:01.450 --> 00:36:04.220
quipped this Moore's Law cubed,
which is the fact that if

00:36:04.330 --> 00:36:07.450
you look in recent history,
the GPU performance is doubling

00:36:07.500 --> 00:36:12.010
about every six months versus the
standard rule of thumb for CPUs,

00:36:12.010 --> 00:36:14.100
which is 18 months.

00:36:14.100 --> 00:36:19.920
So that's kind of a cubed factor
and 3X the exponent there.

00:36:19.920 --> 00:36:23.880
The other thing is to look
at the transistor counts.

00:36:23.950 --> 00:36:26.080
Since graphics is such
a parallel problem,

00:36:26.080 --> 00:36:27.710
you can just duplicate out.

00:36:28.670 --> 00:36:30.520
You can just duplicate out
the same pipeline and do

00:36:30.540 --> 00:36:31.220
more and more pixels at once.

00:36:31.260 --> 00:36:35.050
And so that's an extra degree of
freedom that the CPU guys don't have.

00:36:35.060 --> 00:36:38.610
So for example,
GeForce 4 Ti has 63 million transistors

00:36:38.610 --> 00:36:40.590
in it compared to 10 million in a G4.

00:36:40.650 --> 00:36:43.250
So pretty impressive what's going on.

00:36:43.260 --> 00:36:45.780
And obviously, you know, again,
it's not just for games.

00:36:45.840 --> 00:36:48.000
We think there's a lot of things
that we all can do with it,

00:36:48.240 --> 00:36:51.040
both in the desktop user experience
and in your applications,

00:36:51.040 --> 00:36:54.480
to take advantage of all that hardware.

00:36:56.120 --> 00:36:58.090
So a block diagram of Quartz Extreme.

00:36:58.100 --> 00:37:01.740
Basically what happens is the
application draws its content,

00:37:02.120 --> 00:37:05.260
whether it's software
rendered or hardware rendered,

00:37:05.260 --> 00:37:07.770
into some kind of buffer,
whether it's a window backing

00:37:07.770 --> 00:37:10.420
store in system memory or
a surface in video memory.

00:37:10.420 --> 00:37:15.160
And then the Quartz Compositor
programs the GPU with OpenGL to just

00:37:15.160 --> 00:37:20.340
pull all of that data up into the
GPU and composite it onto the display.

00:37:20.520 --> 00:37:22.820
So for surfaces that
are in system memory,

00:37:22.870 --> 00:37:26.470
like the window backing store
that's happening over the AGP bus,

00:37:26.470 --> 00:37:31.700
for surfaces that may already
have the gears rendered in it,

00:37:31.830 --> 00:37:35.920
it's just turning around and treating
that GL buffer as a texture to

00:37:36.060 --> 00:37:38.140
feed into the final composite.

00:37:39.560 --> 00:37:43.440
We're going to talk more about this in
the Quartz Extreme session later today.

00:37:45.150 --> 00:37:47.810
So the other thing that's
interesting to point out is

00:37:47.810 --> 00:37:51.240
Apple is leading the industry here,
but everyone else is going to do

00:37:51.240 --> 00:37:54.460
this because it's sort of the natural
evolution of windowing systems.

00:37:54.460 --> 00:37:58.420
And there's been lots of sort of hacks
out there to try to do transparent

00:37:58.420 --> 00:38:02.880
menus and little flourishes in the
UI that need this kind of performance.

00:38:02.880 --> 00:38:07.430
But we really wanted to just do it
right and get it done with so that we

00:38:07.540 --> 00:38:10.400
could just ride the headroom of the GPU.

00:38:11.320 --> 00:38:13.450
And we think it is kind
of an inflection point,

00:38:13.550 --> 00:38:16.300
to use a fancy word,
in platform graphics architecture,

00:38:16.300 --> 00:38:23.090
that now that GPUs are all kind of doing
similar architectures in terms of DMA in

00:38:23.240 --> 00:38:27.800
both command data and texture data,
we think we can just treat them a

00:38:27.800 --> 00:38:29.500
lot more like we treat regular I.O.

00:38:29.500 --> 00:38:33.620
devices and really just kind of
use traditional OS and operating

00:38:33.620 --> 00:38:37.240
system techniques to manage them
and bring out their performance

00:38:37.240 --> 00:38:38.580
to their fullest potential.

00:38:38.580 --> 00:38:44.330
And the great thing about all of
this... The advances we've made in

00:38:44.330 --> 00:38:48.280
OpenGL to kind of make all of this
work and be well-behaved are directly

00:38:48.390 --> 00:38:50.630
usable to you if you're an OpenGL app.

00:38:50.650 --> 00:38:55.740
All of the extensions we use to run the
windowing system are in the headers,

00:38:55.780 --> 00:38:58.560
so you can use it.

00:38:59.640 --> 00:39:03.540
So there's a session this afternoon
that talks about if you want to

00:39:03.540 --> 00:39:05.650
leverage the windowing system,
for example,

00:39:05.650 --> 00:39:08.850
to do transparent overlays and
just understand the model in

00:39:08.900 --> 00:39:12.210
more detail of what we're doing,
there's the Exploring the

00:39:12.300 --> 00:39:15.440
Quartz Compositor session
in Hall 2 this afternoon.

00:39:15.440 --> 00:39:18.990
If you want to understand, well,
how did they actually implement

00:39:19.130 --> 00:39:22.450
Quartz Extreme and what are the
GL extensions I need if I want

00:39:22.450 --> 00:39:26.650
to blend three layers of video,
then you go to 506,

00:39:26.720 --> 00:39:32.610
which is the Integrated Graphics 2 talk,
where Ken Dyke's going to walk you

00:39:32.610 --> 00:39:37.340
through a whole example of how to
do all those layer calculations.

00:39:40.350 --> 00:39:49.250
So that's it for the OpenGL,
Quartz Compositor,

00:39:49.250 --> 00:39:49.250
and all of the interactive APIs.

00:39:49.250 --> 00:39:49.250
There are some other...

00:39:50.000 --> 00:39:55.400
Other technologies that
I want to cover here as well.

00:39:56.100 --> 00:39:59.240
These are not technologies that
necessarily get pixels on the screen,

00:39:59.320 --> 00:40:01.740
but there are other things in
the graphics and imaging area,

00:40:01.740 --> 00:40:04.260
and there's some exciting
new opportunities going on.

00:40:04.450 --> 00:40:07.390
The first one is ColorSync.

00:40:09.200 --> 00:40:15.600
ColorSync is our standard color
calculation engine based on the

00:40:15.600 --> 00:40:19.820
ICC standard for color matching,
which Apple helped introduce.

00:40:19.820 --> 00:40:22.430
And you can read more
about it at color.org.

00:40:22.490 --> 00:40:27.500
But it basically is a framework for
color calculations that represents

00:40:27.500 --> 00:40:29.540
device transforms as profiles.

00:40:29.540 --> 00:40:33.230
And you can string a bunch of transforms
together into a pipeline chain and

00:40:33.480 --> 00:40:35.440
then send pixels through the chain.

00:40:35.440 --> 00:40:40.690
And ColorSync will concatenate all
of those and create what many times

00:40:40.740 --> 00:40:47.310
turns out to be a big 3D lookup
table to get f of RGB equals RGB out.

00:40:47.320 --> 00:40:50.900
It's built into Quartz 2D,
so all the color handling,

00:40:50.940 --> 00:40:54.210
as I mentioned before,
goes through ColorSync.

00:40:54.240 --> 00:40:58.030
It's also been successfully used in
the print industry for a long time.

00:40:58.040 --> 00:41:02.740
And it's emerging in the
film and video markets.

00:41:02.740 --> 00:41:05.060
There's been some activity in the ICC.

00:41:05.360 --> 00:41:07.360
Where people from that
industry have come and said,

00:41:07.630 --> 00:41:09.320
well,
here's some special things about the real

00:41:09.320 --> 00:41:10.720
dark surround you get in the theater.

00:41:10.720 --> 00:41:19.880
And some new techniques for the
color workflow in film production.

00:41:19.920 --> 00:41:24.690
And I think that there's a lot of synergy
there that could be pretty interesting.

00:41:24.700 --> 00:41:29.470
So what's new in ColorSync is we
have a velocity engine implementation

00:41:29.470 --> 00:41:31.760
of the color matching engine.

00:41:31.760 --> 00:41:34.870
We have ICC4,
which is the latest profile spec.

00:41:35.280 --> 00:41:39.530
We've added a bunch of convenience
color spaces to Quartz 2D.

00:41:39.680 --> 00:41:43.600
So that if you want to get, for example,
the user's default RGB color space,

00:41:43.610 --> 00:41:47.680
you can make a
straightforward call into CG.

00:41:47.690 --> 00:41:51.430
And get that color space
and start drawing with that.

00:41:51.680 --> 00:41:53.680
And the last thing which
is kind of interesting,

00:41:53.680 --> 00:41:57.080
and this is just sort of emerging now,
is the ability to do real

00:41:57.190 --> 00:41:58.680
time color correction.

00:41:58.680 --> 00:42:02.090
Because of the GeForce 4 Ti,
which admittedly is right

00:42:02.090 --> 00:42:05.200
now a high end card,
they have a feature called 3D Dependency.

00:42:05.200 --> 00:42:07.140
And it's a feature that allows you
to do 3D dependent texture reads.

00:42:07.200 --> 00:42:08.840
And what that means is you
can give a 3D texture to the

00:42:08.840 --> 00:42:15.200
hardware and have it send RGB,
use RGB as indices into a 3D table.

00:42:15.340 --> 00:42:19.200
And then produce an
RGBA value out the other end.

00:42:19.200 --> 00:42:23.140
So obviously since that's a lot of what
color management calculations have to do,

00:42:23.200 --> 00:42:27.200
I think there's some really
interesting opportunities here.

00:42:27.200 --> 00:42:30.020
And we're going to have a demo
of actually taking a profile and

00:42:30.130 --> 00:42:32.200
converting it to a 3D dependent texture.

00:42:32.320 --> 00:42:35.120
And rendering it in hardware
in the ColorSync session.

00:42:35.120 --> 00:42:39.120
So I thought what I would do here
is recreate the Keynote demo,

00:42:39.140 --> 00:42:43.120
which uses the,
if I can get the demo machine,

00:42:43.120 --> 00:42:51.120
uses basically the same, let's see.

00:42:51.120 --> 00:42:53.770
Where did I start off that frame counter?

00:43:02.180 --> 00:43:03.880
So I'm going to go into
a little more detail than

00:43:04.440 --> 00:43:06.920
Richard Karras did in the keynote,
because it's kind of a fun

00:43:06.920 --> 00:43:08.100
story behind this demo.

00:43:08.210 --> 00:43:11.760
So we knew we were going to be showing

00:43:12.300 --> 00:44:46.000
[Transcript missing]

00:44:46.300 --> 00:44:48.880
- So that's what's going on there.

00:44:49.030 --> 00:44:52.020
The other thing, we were also like,
what about the stage?

00:44:52.020 --> 00:44:53.800
You know,
what do we do about all that stuff?

00:44:53.830 --> 00:44:56.000
And the guy said, oh,
there's this thing called garbage mats,

00:44:56.000 --> 00:44:59.790
which are these things you paint
and they composite in to get

00:44:59.800 --> 00:45:02.190
rid of things you don't want.

00:45:02.310 --> 00:45:04.460
So that's just a static image
that you have to render through.

00:45:04.530 --> 00:45:07.300
So we went and did that.

00:45:07.300 --> 00:45:09.400
And again, the hardware,
that's pretty easy.

00:45:09.640 --> 00:45:13.690
See, I can tune out that
green a little bit more.

00:45:14.090 --> 00:45:16.000
And then for another
piece of the color cube,

00:45:16.010 --> 00:45:20.150
although we do the green extraction
and the matte extraction and this

00:45:20.150 --> 00:45:24.090
color correction all in the same table,
because we just throw it all together

00:45:24.150 --> 00:45:27.880
into one big RGB to RGBA transformation,
we made like a little brown

00:45:28.270 --> 00:45:31.820
hue adjustment to try to get
these guys fit into the floor.

00:45:31.820 --> 00:45:37.990
These layers also scale,
so I can kind of scale them back there.

00:45:38.450 --> 00:45:41.120
This layer is kind of funny.

00:45:41.220 --> 00:45:45.290
We got this layer another
three gigabytes later.

00:45:45.520 --> 00:45:50.180
It's like, "Okay,
so this is a CG train rendered with

00:45:50.430 --> 00:45:55.170
film noise in green screen." We're like,
"Why couldn't they have just rendered an

00:45:55.170 --> 00:45:58.370
alpha channel from the renderer instead
of putting noise in the alpha channel?"

00:45:58.500 --> 00:46:03.090
I guess this is the way film guys work.

00:46:03.610 --> 00:46:05.930
So the unfortunate thing
about that is you can't,

00:46:05.940 --> 00:46:08.640
you can see how the greens
are all over the map here,

00:46:08.640 --> 00:46:11.530
and in fact in the corner you
can't really get rid of the,

00:46:11.530 --> 00:46:14.170
I'm pointing at this,
you can't really get rid of all the green

00:46:14.170 --> 00:46:17.290
the way we have the tolerances set up,
but, you know,

00:46:17.350 --> 00:46:21.030
someone who spent more than a
day trying to get this to happen

00:46:21.030 --> 00:46:23.210
could probably do a better job.

00:46:24.380 --> 00:46:25.800
So you can see how that works.

00:46:25.800 --> 00:46:27.060
They also put film noise in it.

00:46:27.060 --> 00:46:29.760
You can see the little
pops as the train goes by.

00:46:29.800 --> 00:46:31.850
That's all rendered in the CG layer.

00:46:31.940 --> 00:46:35.660
I mean,
I could drag more layers in here too,

00:46:35.730 --> 00:46:38.800
but one thing I wanted to do
that they didn't do in the

00:46:38.800 --> 00:46:42.280
keynote is another little...

00:46:42.500 --> 00:47:00.200
[Transcript missing]

00:47:02.620 --> 00:47:09.340
What I'm going to do is do a print
preview of the Word document.

00:47:09.400 --> 00:47:15.100
And what that does is create a PDF file
that then is opened up in preview.

00:47:15.150 --> 00:47:19.300
The nice thing about Word is it
doesn't actually draw the white page.

00:47:19.300 --> 00:47:21.420
It just leaves it clear.

00:47:21.560 --> 00:47:25.130
So what I've actually got on
this PDF file is just the text.

00:47:25.200 --> 00:47:31.970
And so what I can do with that is just
drag it in on a layer over the content.

00:47:38.420 --> 00:47:38.940
That's pretty fun.

00:47:39.070 --> 00:47:42.330
It's a little jerky,
and I'm not sure why,

00:47:42.330 --> 00:47:44.600
but we can fix it in post, as they say.

00:47:44.600 --> 00:47:48.290
Let's see, what else did I have?

00:47:48.300 --> 00:47:49.780
I think that's it for that demo.

00:47:57.610 --> 00:48:01.760
So the ColorSync session is
Session 509 on Wednesday.

00:48:01.760 --> 00:48:07.170
You can go there and hear about how
ColorSync fits into OS X and also another

00:48:07.170 --> 00:48:13.240
peek at how you might be able to use some
hardware to do some color correction.

00:48:14.600 --> 00:48:17.680
Another important technology
we have is Image Capture.

00:48:17.680 --> 00:48:21.240
Image Capture you're probably familiar
with if you've ever used iPhoto.

00:48:21.240 --> 00:48:24.760
It's the application that
basically manages all the

00:48:24.930 --> 00:48:26.940
cameras attached to a computer.

00:48:26.940 --> 00:48:31.160
We introduced this last year,
and we knew the iPhoto team was

00:48:31.160 --> 00:48:35.640
working on their application,
so we worked pretty closely with

00:48:35.660 --> 00:48:39.910
them and all the camera vendors
to get camera modules for a lot

00:48:39.910 --> 00:48:42.570
of the consumer-level cameras.

00:48:43.490 --> 00:48:46.460
The way the architecture works,
basically we have an input architecture,

00:48:46.570 --> 00:48:48.740
which is a camera module.

00:48:48.880 --> 00:48:52.900
It flows into an Image Capture framework,
which can run as a daemon.

00:48:52.900 --> 00:48:54.930
Then your application
attaches to the daemon,

00:48:54.930 --> 00:48:57.460
and it can enumerate all the
cameras that are attached.

00:48:57.490 --> 00:49:00.400
It can ask the cameras for pictures.

00:49:00.400 --> 00:49:04.870
The Image Capture framework
isolates you from the details of

00:49:04.870 --> 00:49:09.420
whether the camera might be a PTP,
which is a USB camera standard,

00:49:09.420 --> 00:49:12.420
or some cameras are vendor-specific
proprietary protocols.

00:49:12.420 --> 00:49:14.860
Some cameras are just
mass storage devices,

00:49:14.880 --> 00:49:16.350
and they look like disks.

00:49:16.420 --> 00:49:20.420
But all of those are kind of hidden
from you if you just ask Image Capture,

00:49:20.420 --> 00:49:24.680
"Hey, are any cameras attached?" "Yes,
there's 30 images in it." "Okay,

00:49:24.710 --> 00:49:27.020
give me image 5." That kind of API,
pretty straightforward.

00:49:27.740 --> 00:49:38.400
But the new thing that we've
been working on is scanning.

00:49:40.540 --> 00:49:45.110
So we've got scanner modules which fit in
in an analogous way to the camera modules

00:49:45.630 --> 00:49:47.360
into the image capture architecture.

00:49:47.360 --> 00:49:50.920
So again,
you write a module for image capture,

00:49:50.920 --> 00:49:55.370
it can recognize it, and you can pull it
into your application.

00:49:55.380 --> 00:50:00.230
One of the nice things we're doing
is we're integrating with Twain.

00:50:00.240 --> 00:50:02.540
So, yeah, go ahead.

00:50:02.680 --> 00:50:03.650
No Twain.

00:50:04.840 --> 00:50:08.210
Twain is a good standard a lot
of vendors have adopted for

00:50:08.210 --> 00:50:11.980
developing their scanner modules.

00:50:11.980 --> 00:50:20.000
And we have kind of a bridge between
Twain and the image capture framework

00:50:20.000 --> 00:50:23.120
that allows you to examine any
Twain devices on the system as well.

00:50:23.120 --> 00:50:27.120
We've also worked with the
Twain folks on making the DSM.

00:50:27.120 --> 00:50:29.740
If you go to their website,
they have one that's CFM only.

00:50:29.740 --> 00:50:32.820
We've been working on a fully native
version so you can call it from Cocoa.

00:50:32.820 --> 00:50:35.840
And it works across... across the board.

00:50:35.840 --> 00:50:37.840
And so that'll be coming out soon.

00:50:37.860 --> 00:50:39.840
In fact,
I think a copy of it's on your CD.

00:50:39.990 --> 00:50:41.840
We also have a basic scanner UI.

00:50:41.840 --> 00:50:47.010
Just like for image capture,
we have the basic image capture panel

00:50:47.070 --> 00:50:47.840
that comes up when you attach a camera.

00:50:47.840 --> 00:50:51.840
And we have FireWire camera support.

00:50:51.900 --> 00:50:57.840
So some new professional cameras coming
online which have FireWire interfaces.

00:50:57.840 --> 00:51:00.840
Here's a picture of the scanner UI.

00:51:00.840 --> 00:51:02.840
I mean, it's pretty basic.

00:51:02.840 --> 00:51:04.840
Just meant for like a
consumer plugs in his camera.

00:51:04.840 --> 00:51:08.840
Wants to take... Get a scan...
A picture off the scanner.

00:51:08.840 --> 00:51:11.770
You can see we got a little
translucent cropping rectangle.

00:51:11.860 --> 00:51:13.840
You do a preview scan and a full scan.

00:51:13.840 --> 00:51:14.840
Pretty straightforward.

00:51:14.840 --> 00:51:15.760
Not a lot of bells and whistles.

00:51:15.860 --> 00:51:19.840
But, you know,
something my mom could use kind of thing.

00:51:20.950 --> 00:51:23.700
So if you want to hear about that,
go to the Image Capture session.

00:51:23.700 --> 00:51:28.520
That's on Friday at 2, session 515.

00:51:31.000 --> 00:51:33.540
The last thing I'd like
to cover is printing.

00:51:33.540 --> 00:51:38.050
So there are some changes in printing,
but let me set the

00:51:38.150 --> 00:51:39.220
stage a little bit here.

00:51:39.220 --> 00:51:42.720
So in the beginning,
QuickDraw did it all.

00:51:42.720 --> 00:51:46.780
The Mac was revolutionary in the
sense that QuickDraw was the same API.

00:51:46.780 --> 00:51:51.230
It unified paper and display
and had nice-looking fonts

00:51:51.290 --> 00:51:53.600
and did the whole... You know,
even just the fact that it

00:51:53.600 --> 00:51:54.900
was black text on white,
you know,

00:51:54.990 --> 00:51:56.630
not all computers were doing that then.

00:51:56.640 --> 00:52:00.900
Just to try to get that simulation
of paper really nice with

00:52:01.050 --> 00:52:02.080
the graphical user interface.

00:52:02.080 --> 00:52:06.660
But the reality was that as people
tried to really do... The publishing

00:52:06.670 --> 00:52:09.400
industry saw it and said,
you know, that's really cool.

00:52:09.400 --> 00:52:10.600
We can do new applications.

00:52:10.620 --> 00:52:14.190
But the reality was QuickDraw kind
of fell down a little bit in terms

00:52:14.190 --> 00:52:15.800
of what it was capable to do.

00:52:15.800 --> 00:52:18.710
It didn't have outline,
didn't have outline fonts,

00:52:18.720 --> 00:52:22.780
didn't have a very sophisticated
processing model behind it.

00:52:23.000 --> 00:52:25.430
And so Adobe invented PostScript.

00:52:25.440 --> 00:52:28.450
And what happened is, you know,
QuickDraw and the platform graphics

00:52:28.540 --> 00:52:30.190
architecture kind of got sidestepped.

00:52:30.800 --> 00:52:31.800
By QuickDraw.

00:52:31.800 --> 00:52:34.800
And we've been living with this
kind of combination world where,

00:52:34.800 --> 00:52:37.490
you know, you can do some things in a
QuickDraw printer and you can do

00:52:37.490 --> 00:52:39.120
some things in a PostScript printer.

00:52:39.120 --> 00:52:42.360
But the real professional
imaging model is this,

00:52:42.470 --> 00:52:44.980
you know,
total bypass shunt where people are

00:52:44.980 --> 00:52:47.360
just sending PostScript to PostScript.

00:52:47.360 --> 00:52:50.890
And then people who buy inkjet printers
don't get nice outline fonts and

00:52:50.890 --> 00:52:52.780
jaggies and all of those problems.

00:52:52.860 --> 00:52:56.460
But, you know,
PostScript was a great invention and,

00:52:56.500 --> 00:53:00.140
you know, really proved that this
is an imaging model that,

00:53:00.140 --> 00:53:01.940
you know,
is good enough for professionals

00:53:01.940 --> 00:53:03.270
and can describe all the pages.

00:53:03.280 --> 00:53:06.050
So really one way to look at
what we've done with Quartz 2D is

00:53:06.050 --> 00:53:08.330
kind of go back to that and say,
well, you know,

00:53:08.330 --> 00:53:11.280
let's just have a 2D API that's
kind of good enough to describe

00:53:11.280 --> 00:53:16.380
every page ever printed and use that
and go back to the original idea

00:53:16.380 --> 00:53:19.050
of having a unified imaging model.

00:53:19.060 --> 00:53:23.880
And so that kind of
tells you where we're,

00:53:24.300 --> 00:53:28.120
what our thinking was going behind
the printing architecture on OS X.

00:53:28.120 --> 00:53:32.350
And so what happens is,
an application like a

00:53:32.350 --> 00:53:37.020
Carbon application in this example,
Internet Explorer,

00:53:37.020 --> 00:53:39.520
calls Quickdraw to draw its pages.

00:53:39.520 --> 00:53:44.780
The Quickdraw commands are converted to
Core Graphics calls or Quartz 2D calls.

00:53:44.780 --> 00:53:48.620
And those files are,
those calls are recorded into a PDF file.

00:53:48.620 --> 00:53:53.150
That PDF file flows through what
we call a spooling system to the

00:53:53.150 --> 00:53:58.440
back end of the print architecture
where the PDF file is decoded.

00:53:58.440 --> 00:54:00.440
It's either converted into
PostScript for PostScript,

00:54:00.510 --> 00:54:08.130
or rendered for a inkjet printer
using our Quartz 2D rasterizer.

00:54:10.020 --> 00:54:15.600
So what we've done in Jaguar is
completely replace the spooling system.

00:54:15.600 --> 00:54:18.810
So we have a new spooling system
that's based on open source,

00:54:18.830 --> 00:54:23.220
so we think it's a really great
addition to what we have and allows

00:54:23.220 --> 00:54:25.640
us to do some pretty new features.

00:54:25.640 --> 00:54:28.260
But don't worry,
it's binary compatible with your apps

00:54:28.340 --> 00:54:30.840
and with the drivers that are out there,
too.

00:54:30.840 --> 00:54:35.750
So we've kind of ripped out most of
the kernel of the data flow processing,

00:54:35.850 --> 00:54:38.140
but we've kept compatibility.

00:54:39.340 --> 00:54:42.730
And this allows us to do a couple new
features that we're really excited about.

00:54:42.860 --> 00:54:47.000
Printer sharing with IPP,
which is a better replacement to the

00:54:47.000 --> 00:54:49.920
old USB printer sharing we had on OS 9.

00:54:49.920 --> 00:54:54.050
And the Cocoa Print Center is
another little thing we put on there.

00:54:54.050 --> 00:54:57.140
We took the old Print Center,
rewrote it in Cocoa,

00:54:57.140 --> 00:54:59.890
shrunk the code size by
about a factor of six,

00:55:00.000 --> 00:55:03.060
and it actually looks
nicer and works better.

00:55:03.060 --> 00:55:04.700
So that was a good thing.

00:55:06.970 --> 00:55:08.270
What are we using for a spooling system?

00:55:08.350 --> 00:55:11.030
We're using something called
the Common Unix Printing System,

00:55:11.140 --> 00:55:11.500
or CUPS.

00:55:11.500 --> 00:55:14.700
It uses printer sharing via IPP.

00:55:14.700 --> 00:55:16.040
There's a book out about it.

00:55:16.080 --> 00:55:16.680
You can read it.

00:55:16.810 --> 00:55:19.090
You can go to CUPS.org.

00:55:20.900 --> 00:55:23.340
IPP is a kind of dialect of HTTP.

00:55:23.340 --> 00:55:26.170
It uses a different port.

00:55:26.390 --> 00:55:28.900
But basically,
the way to think about it is you're

00:55:28.900 --> 00:55:31.870
kind of doing put of your print data,
and the server on the

00:55:31.870 --> 00:55:32.980
other side is taking it.

00:55:33.040 --> 00:55:37.640
So it's a replacement for kind of
the LPD kind of socket wire protocol.

00:55:37.640 --> 00:55:42.750
But on the flip side,
as far as the Unix user is concerned,

00:55:42.760 --> 00:55:48.280
CUPS also comes with a full set
of LPR and LP emulation tools.

00:55:48.280 --> 00:55:50.690
So finally, you can LPR to that inkjet.

00:55:50.940 --> 00:55:54.080
It's sitting right next to you,
which you couldn't do in 10.1.

00:55:58.920 --> 00:56:01.080
And if you like LP, you can do that, too.

00:56:01.080 --> 00:56:03.540
And so it's a really
flexible architecture.

00:56:03.650 --> 00:56:06.940
If you go to this session
and hear about it,

00:56:06.940 --> 00:56:10.630
at the back end is a really nice
kind of MIME conversion table where

00:56:10.630 --> 00:56:13.910
you can take source formats and
convert them to destination formats.

00:56:13.960 --> 00:56:17.100
And the spooling
architecture figures out,

00:56:17.150 --> 00:56:20.570
you know,
how to get your source document to a

00:56:20.570 --> 00:56:22.420
format that the printer can understand.

00:56:22.420 --> 00:56:25.960
It's been picked up by
several Linux distributions.

00:56:27.680 --> 00:56:32.710
And people have been really successful
using CUPS in a lot of environments,

00:56:32.720 --> 00:56:36.430
and we're pretty happy to be working
with those guys on the OS X version.

00:56:38.700 --> 00:56:43.290
So with that, I'm going to do the ever
popular printing demo,

00:56:43.290 --> 00:56:46.270
rarely done on stage.

00:56:46.470 --> 00:56:49.060
My lovely assistant
Rich will come up and help.

00:56:49.440 --> 00:56:52.030
Rich Blanchi.

00:56:53.920 --> 00:56:57.050
So if I could get demo four.

00:56:57.140 --> 00:57:00.540
So what I have here is a PowerBook.

00:57:00.540 --> 00:57:03.960
You can see it's not attached to anything
except power and video for you guys.

00:57:04.100 --> 00:57:08.310
But it's running a wire,
it's on a wireless network.

00:57:08.380 --> 00:57:09.440
We've got an airport card in there.

00:57:09.440 --> 00:57:11.880
These two guys,
these two computers are on a private,

00:57:12.030 --> 00:57:14.020
you know, little airport connection.

00:57:14.020 --> 00:57:17.780
And what I have here
is an iMac data sheet.

00:57:17.780 --> 00:57:20.890
And you'll see, oh, by the way,
this is the new preview.

00:57:20.890 --> 00:57:23.680
You can see we've got
little page thumbnails now.

00:57:24.010 --> 00:57:26.340
Anyway.

00:57:26.590 --> 00:57:30.450
If I bring up the print dialog,
I don't have any printers because

00:57:30.540 --> 00:57:32.200
I'm not attached to anything.

00:57:32.200 --> 00:57:34.810
There's nothing on the network right now.

00:57:34.920 --> 00:57:40.600
And so Rich's machine is
not attached to his printer.

00:57:40.600 --> 00:57:41.740
He's going to attach the printer.

00:57:41.740 --> 00:57:44.890
And what's going to happen
is that machine is going to

00:57:45.000 --> 00:57:47.620
get the USB hot plug event,
understand that there's

00:57:47.690 --> 00:57:48.610
a printer attached.

00:57:48.620 --> 00:57:52.030
He's got printer sharing enabled,
so it's going to send a broadcast

00:57:52.040 --> 00:57:53.510
packet out on the network.

00:57:54.300 --> 00:57:59.040
And sometime in the next 30 seconds,
DeskJet 840 is going to show up here.

00:58:06.600 --> 00:58:11.000
Now the real hard part
is can I actually print?

00:58:11.000 --> 00:58:12.500
We have an HP printer here.

00:58:12.570 --> 00:58:14.200
Yep, it's starting up.

00:58:14.200 --> 00:58:16.650
So we'll leave that to print.

00:58:16.660 --> 00:58:21.250
It's a little bit of an older printer.

00:58:23.740 --> 00:58:24.770
No, we're on a private network.

00:58:25.060 --> 00:58:25.490
Stay away.

00:58:25.510 --> 00:58:30.720
Let me get back to the slides for a sec.

00:58:33.800 --> 00:58:35.680
to tell you about the printing
sessions that are coming up.

00:58:35.850 --> 00:58:38.840
So there's the printing in Mac OS X.

00:58:38.840 --> 00:58:42.920
Well, you'll hear about printing APIs we
have and the architecture update.

00:58:43.280 --> 00:58:44.580
That's on Thursday.

00:58:44.580 --> 00:58:48.320
Tomorrow,
there's a Darwin printing session.

00:58:48.320 --> 00:58:50.940
We've invited the guy who wrote CUPS,
Michael Sweet,

00:58:50.940 --> 00:58:52.520
to come and talk to you about CUPS.

00:58:52.620 --> 00:58:55.110
And all of CUPS is live
in the Darwin repository,

00:58:55.110 --> 00:58:56.000
right, Rich?

00:58:56.040 --> 00:58:56.830
Starting now.

00:58:56.980 --> 00:59:01.230
So you guys can go see what the spooling
system done and the few minor changes

00:59:01.230 --> 00:59:03.860
we had to make to make it work on OS X.

00:59:03.860 --> 00:59:06.060
And what do you got there?

00:59:06.060 --> 00:59:07.230
You got half a page or so?

00:59:09.200 --> 00:59:15.000
[Transcript missing]

00:59:17.200 --> 00:59:20.340
So the other piece of feedback we got
from all you guys was documentation.

00:59:21.020 --> 00:59:25.620
So we're trying really hard at
this WWC to tell you about all

00:59:25.620 --> 00:59:27.200
the documentation we've done.

00:59:27.200 --> 00:59:30.370
We know there's still more work to do,
but in the area of general

00:59:30.370 --> 00:59:33.350
graphics technologies,
there's been thousands of

00:59:33.350 --> 00:59:35.210
pages of new documentation.

00:59:35.220 --> 00:59:39.160
I'm sure there's still more you want,
but there's a bunch of revised books,

00:59:39.170 --> 00:59:41.410
a bunch of QA samples,
some new tech notes,

00:59:41.430 --> 00:59:44.560
and there'll be more showing
up after the conference.

00:59:44.740 --> 00:59:47.250
We've got a bunch of new code samples,
and there'll be more showing

00:59:47.250 --> 00:59:48.380
up after the conference.

00:59:48.380 --> 00:59:50.860
We've got a full set of OpenGL man pages.

00:59:50.860 --> 00:59:55.810
And don't forget about a lot of
the technologies in our area,

00:59:55.810 --> 00:59:59.460
like PDF, PostScript, OpenGL, CUPS.

00:59:59.460 --> 01:00:02.660
These are all things that you can
just go buy books on and read,

01:00:02.660 --> 01:00:05.350
and that's really good, too,
so you can understand

01:00:05.350 --> 01:00:06.800
what's going on there.

01:00:08.240 --> 01:00:11.340
So with that, I'll just point you at
our feedback session,

01:00:11.340 --> 01:00:14.370
which is this Friday,
last thing of the conference.

01:00:14.390 --> 01:00:14.420
So with that, I'll just point you at
our feedback session,

01:00:14.430 --> 01:00:14.470
which is this Friday,
last thing of the conference.

01:00:14.470 --> 01:00:14.720
I'm sure you've all been there.

01:00:14.720 --> 01:00:15.020
I'm sure you've all been there.

01:00:15.020 --> 01:00:16.640
I'm sure you all are going to hang
around to give us lots of feedback.

01:00:16.640 --> 01:00:21.120
But we'll be there
Friday at 5 in room J1.

01:00:21.140 --> 01:00:22.180
And that's all I have.

01:00:22.280 --> 01:00:24.430
Thanks a lot for your attention,
and have a great conference.

01:00:24.500 --> 01:00:25.890
Thank you.
WEBVTT

00:00:09.210 --> 00:00:10.090
Good morning.

00:00:10.180 --> 00:00:11.780
Thank you very much for coming.

00:00:11.890 --> 00:00:16.580
Welcome to session 505,
OpenGL Integrated Graphics 1.

00:00:17.620 --> 00:00:23.790
One of the highlights of JAGWR is how
OpenGL takes a fundamental role in

00:00:23.790 --> 00:00:26.500
graphics and imaging for Mac OS X.

00:00:26.660 --> 00:00:31.890
This is a one session of a part
of two discussing techniques of

00:00:32.070 --> 00:00:36.790
how to utilize the OpenGL API to
achieve high performance and

00:00:36.790 --> 00:00:44.500
creative possibilities for 2D,
2.5D video and sprites, etc.

00:00:44.500 --> 00:00:48.330
To present session 505,
OpenGL Integrated Graphics 1,

00:00:48.530 --> 00:00:51.500
I would like to welcome to the stage
Apple OpenGL engineer Geoff Stahl.

00:00:52.600 --> 00:00:54.610
Thanks, Sergio.

00:00:57.950 --> 00:01:00.220
As Sergio mentioned,
what we're going to talk about

00:01:00.740 --> 00:01:05.240
today is really the lead-in to
how to use OpenGL with Mac OS X.

00:01:05.240 --> 00:01:07.090
We'll show you some new stuff,
we'll show you some

00:01:07.170 --> 00:01:08.900
stuff that's been around,
but really this is kind of

00:01:08.900 --> 00:01:11.190
the meat and potatoes of,
you have an image,

00:01:11.190 --> 00:01:13.390
you want to display it,
you have a texture you need

00:01:13.390 --> 00:01:15.660
to get into the system,
you want to load a texture,

00:01:15.660 --> 00:01:17.970
you want to display a movie,
you have a QuickTime VR,

00:01:17.970 --> 00:01:19.010
you want to display that.

00:01:19.160 --> 00:01:22.960
So we're going to talk all, kind of,
touch base on all those areas.

00:01:22.960 --> 00:01:25.380
So in the second session,
Ken's going to take you into some more

00:01:25.380 --> 00:01:28.840
detail of some high performance issues
with this and how to get the most

00:01:28.850 --> 00:01:31.300
maximum performance out of the system.

00:01:31.450 --> 00:01:33.460
So with that, let's move on.

00:01:33.600 --> 00:01:35.080
That's me.

00:01:35.580 --> 00:01:42.210
Again, first we'll talk about why would
you want to use OpenGL for 2D,

00:01:42.560 --> 00:01:47.100
plain video, 2.5D, kind of the forced
perspective kind of thing.

00:01:47.100 --> 00:01:50.500
Why is OpenGL a good solution for this?

00:01:50.710 --> 00:01:54.690
Then we'll go into OpenGL integration
by talking about images and movies.

00:01:56.760 --> 00:01:58.750
So why do you want to use OpenGL?

00:01:58.850 --> 00:02:00.640
First,
it's the fastest pipeline in the system.

00:02:00.640 --> 00:02:04.880
As you've seen, with Course Extreme,
we've utilized the power of

00:02:04.880 --> 00:02:07.700
OpenGL and the graphics processing
unit for the Windows Server.

00:02:07.700 --> 00:02:09.730
That's a 2D application, basically.

00:02:09.740 --> 00:02:13.640
It is a layered application, but really,
the fastest way to get that to the screen

00:02:13.640 --> 00:02:15.700
is through the horsepower of the GPU.

00:02:15.700 --> 00:02:16.700
We've talked about it yesterday.

00:02:16.700 --> 00:02:20.640
The GeForce 4 Titanium has
63 million transistors.

00:02:20.750 --> 00:02:23.680
The PowerPC only has about
10 million transistors.

00:02:23.760 --> 00:02:28.250
The PowerPC is a general purpose
computational unit where the GPU is

00:02:28.380 --> 00:02:33.080
specifically made to handle bits,
handle graphics, and move things to the

00:02:33.080 --> 00:02:34.540
screen in a very fast way.

00:02:34.700 --> 00:02:40.700
On that GPU, you have up to 10 gigabytes
per second of memory bandwidth.

00:02:40.830 --> 00:02:44.700
You're only at about 800
megabytes per second in the CPU.

00:02:44.700 --> 00:02:47.510
So you look at that,
and that's a factor of 10 as far

00:02:47.510 --> 00:02:50.700
as that's an order of magnitude
more internal bandwidth.

00:02:50.700 --> 00:02:50.700
So if you can get your image,
your texture, your memory,

00:02:50.700 --> 00:02:50.700
and your graphics to the screen,
that's a factor of 10.

00:02:50.700 --> 00:02:50.700
So if you can get your image,
your texture, your memory,

00:02:50.700 --> 00:02:50.700
and your graphics to the screen,
that's a factor of 10.

00:02:50.700 --> 00:02:51.080
So if you can get your image,
your texture,

00:02:51.080 --> 00:02:51.700
your graphics to the screen,
that's a factor of 10.

00:02:51.700 --> 00:02:52.080
So if you can get your image,
your texture,

00:02:52.080 --> 00:02:52.700
your graphics to the screen,
that's a factor of 10.

00:02:52.700 --> 00:02:57.190
texture, your movie, onto the GPU,
you can utilize that power and

00:02:57.440 --> 00:03:02.180
really take advantage of the system,
or the advancements in that GPU.

00:03:02.180 --> 00:03:05.150
We also offer with OpenGL a flexible API.

00:03:05.150 --> 00:03:09.680
Some people think of OpenGL as just 3D,
but it is an open graphics language.

00:03:09.680 --> 00:03:13.810
It allows you to, if you want to,
just pass values in 2D coordinate space.

00:03:13.910 --> 00:03:18.440
You can transform your view area
to window coordinates and really

00:03:18.440 --> 00:03:21.550
just work with it like a 2D API,
using textures to

00:03:21.650 --> 00:03:23.100
upload your information.

00:03:23.100 --> 00:03:26.330
Also, obviously, hardware acceleration.

00:03:26.340 --> 00:03:30.620
ATI and NVIDIA have done a tremendous
amount of research over the last years,

00:03:30.670 --> 00:03:34.000
along with 3D Labs and Matrox,
and they're really pushing ahead.

00:03:34.000 --> 00:03:36.240
If you went to the
Compositor talk yesterday,

00:03:36.240 --> 00:03:40.200
you noted that Peter Graffagnino
spoke about Moore's Law.

00:03:40.200 --> 00:03:44.210
Processors were seeing about
an 18-month double in power

00:03:44.220 --> 00:03:47.390
for general-purpose processors.

00:03:47.400 --> 00:03:50.970
For GPUs,
we're seeing about 6-month turnarounds.

00:03:50.980 --> 00:03:54.610
We're seeing a really,
really accelerated advancement

00:03:54.610 --> 00:03:56.080
in graphics processing units.

00:03:56.130 --> 00:03:57.040
Take advantage of that.

00:03:57.100 --> 00:03:58.280
Utilize an OpenGL.

00:03:58.280 --> 00:04:01.820
Lastly,
there's tons of great sample code.

00:04:01.990 --> 00:04:03.740
It's documented very well.

00:04:03.740 --> 00:04:07.420
It's an easy API to get into,
take a sample,

00:04:07.420 --> 00:04:10.860
manipulate it to what you need to do,
and go from there.

00:04:12.630 --> 00:04:14.500
But why not OpenGL?

00:04:14.670 --> 00:04:17.500
Wouldn't be a fair conversation if
we didn't talk about both sides.

00:04:17.860 --> 00:04:21.500
First, OpenGL accelerates 16
and 32-bit pixel formats.

00:04:21.500 --> 00:04:24.500
It doesn't handle 8-bit
pixel formats very well,

00:04:24.570 --> 00:04:27.500
and it may not be the optimum solution
if you have a special 8-bit case.

00:04:27.500 --> 00:04:30.910
Let's say you're writing a game that
you have a custom engine that all

00:04:31.020 --> 00:04:32.330
it puts out is 8-bit index color.

00:04:32.500 --> 00:04:36.490
OpenGL may not be a good replacement
for the entire game engine.

00:04:36.510 --> 00:04:38.630
You may want to then put
it into your back buffer,

00:04:38.630 --> 00:04:40.500
then use OpenGL or the
accelerated Windows Server,

00:04:40.500 --> 00:04:42.500
and bring that to the screen that way.

00:04:42.500 --> 00:04:44.500
So you're utilizing the
power of the graphics unit,

00:04:44.500 --> 00:04:47.300
but you have your custom
code that manipulates your

00:04:47.300 --> 00:04:48.470
pixels in that 8-bit format.

00:04:48.500 --> 00:04:51.500
I would say if you are
working with 8-bit graphics,

00:04:51.500 --> 00:04:54.500
you may want to think about
that you have a lot more memory,

00:04:54.610 --> 00:04:56.430
you have a lot more bandwidth,
and utilize the power of

00:04:56.430 --> 00:05:00.370
the accelerated graphics,
bring out the 32-bit, 16-bit,

00:05:00.370 --> 00:05:04.490
what have you,
and use that for your applications.

00:05:06.000 --> 00:05:09.580
Also,
if you're looking at anti-alias fonts,

00:05:09.580 --> 00:05:13.290
complicated anti-alias lines,
some of the things that we get shapes,

00:05:13.430 --> 00:05:15.370
the shape handling of a PDF.

00:05:15.480 --> 00:05:18.740
You may not want to use OpenGL actually
as your drawing mechanism.

00:05:18.740 --> 00:05:20.530
You may want to draw it into a buffer.

00:05:20.570 --> 00:05:22.540
And as we'll show you later,
use that as an image that

00:05:22.540 --> 00:05:23.560
you can bring to the screen.

00:05:23.560 --> 00:05:27.060
So you can composite both a
PDF that you may have rendered

00:05:27.060 --> 00:05:31.160
in Quartz 2D with OpenGL,
combine that with some 3D graphics

00:05:31.160 --> 00:05:33.010
and put that to the screen.

00:05:33.320 --> 00:05:36.680
That's something you can do,
but you may want to keep your

00:05:36.680 --> 00:05:39.180
Quartz 2D graphics in Quartz 2D.

00:05:39.300 --> 00:05:40.890
It is a large API.

00:05:40.890 --> 00:05:44.800
As I said, there's a lot of sample code,
but with about 500 or so

00:05:44.800 --> 00:05:47.610
entry points at this point,
it is a little daunting to learn.

00:05:47.880 --> 00:05:50.100
And most people,
when they start with OpenGL,

00:05:50.100 --> 00:05:53.470
they kind of pull up a sample,
start writing, change some stuff,

00:05:53.560 --> 00:05:54.500
and guess what?

00:05:54.500 --> 00:05:55.350
They get a black screen.

00:05:55.560 --> 00:05:57.490
They work on some more stuff,
they get another black screen.

00:05:57.590 --> 00:06:00.090
So take the sample code
and work through it,

00:06:00.090 --> 00:06:02.800
make small changes,
and you'll see pretty quickly,

00:06:02.800 --> 00:06:05.240
understand how the state
machine of OpenGL works and

00:06:05.240 --> 00:06:06.480
how OpenGL works as an API.

00:06:08.880 --> 00:06:11.560
So what are we going to talk about today?

00:06:11.640 --> 00:06:14.030
For images,
what I really want to get across

00:06:14.130 --> 00:06:16.720
is rendering texture anywhere.

00:06:16.850 --> 00:06:20.340
So what you really have up to this point,
people say, well,

00:06:20.360 --> 00:06:23.580
I have to load into a texture
and then draw from that.

00:06:23.710 --> 00:06:26.400
Well, my graphic isn't a texture.

00:06:26.400 --> 00:06:29.790
It's an image, or it's a file,
or it's a movie.

00:06:29.790 --> 00:06:31.920
So how does that relate to a texture?

00:06:31.920 --> 00:06:32.790
We'll go through that.

00:06:32.800 --> 00:06:35.570
And then also, what are you rendering to?

00:06:35.880 --> 00:06:37.800
Are you rendering to,
you want to get to a file?

00:06:37.800 --> 00:06:38.800
You want to get to an image?

00:06:38.800 --> 00:06:39.750
You want to get to the screen?

00:06:39.820 --> 00:06:40.800
You want to get to an off screen?

00:06:40.800 --> 00:06:42.800
We'll talk about the differences there.

00:06:42.800 --> 00:06:45.360
Now, in Mac OS X,
we've integrated in such

00:06:45.450 --> 00:06:48.300
a way that it's very,
very simple to use all those

00:06:48.400 --> 00:06:50.790
different targets of a texturing.

00:06:50.790 --> 00:06:53.270
We'll talk a little bit about
image display and how to,

00:06:53.370 --> 00:06:55.930
if you do have 2D content,
you want to get it to the screen,

00:06:55.940 --> 00:06:56.800
how you can do that.

00:06:56.800 --> 00:06:59.790
I'll talk about a special case
of planar texture handling.

00:06:59.790 --> 00:07:02.800
So instead of the chunky pixels,
you have a planar texture.

00:07:02.850 --> 00:07:05.280
So you can get an image organized
in a planar fashion and how you have

00:07:05.410 --> 00:07:06.800
to render that in a special way.

00:07:06.800 --> 00:07:11.270
And that's a case where you don't want
to go through the image and actually

00:07:11.280 --> 00:07:12.730
swizzle all the pixels back together.

00:07:12.800 --> 00:07:16.800
Then I'll finish up with movies,
talk about QuickTime VRs.

00:07:16.840 --> 00:07:18.660
QuickTime VRs and OpenGL have a
really interesting integration.

00:07:18.950 --> 00:07:22.800
The fact that a QuickTime VR is a
special case of a QuickTime movie

00:07:22.800 --> 00:07:24.800
with the Cubic VR having six faces.

00:07:24.800 --> 00:07:30.800
And OpenGL also has a Cubic texture map,
so you can, excuse me,

00:07:30.800 --> 00:07:30.800
map Cubic VRs very easily.

00:07:30.800 --> 00:07:32.800
So you can map Cubic VRs very easily.

00:07:32.800 --> 00:07:34.800
to the Cubics in QuickTime.

00:07:34.800 --> 00:07:38.160
And then lastly I'll talk about
movie playback integrating

00:07:38.160 --> 00:07:39.600
QuickTime with OpenGL.

00:07:43.700 --> 00:07:46.410
So for images, we're going to talk
about render to anywhere,

00:07:46.490 --> 00:07:49.100
texture from anywhere, image display,
and then player images.

00:07:49.140 --> 00:07:50.840
We've covered what we're
going to talk about there.

00:07:50.840 --> 00:07:52.040
We'll move on.

00:07:52.110 --> 00:07:54.090
So render to anywhere.

00:07:54.320 --> 00:07:58.060
The two places you really want to
render to are a surface or an image.

00:07:58.320 --> 00:08:00.400
Everyone normally knows
about rendering to a surface.

00:08:00.400 --> 00:08:02.330
That's where you,
if you set up OpenGL and

00:08:02.330 --> 00:08:03.960
you render to a window,
that's a surface.

00:08:04.020 --> 00:08:06.710
You're rendering to what you
would consider just a normal,

00:08:06.910 --> 00:08:08.240
this is how OpenGL works.

00:08:08.410 --> 00:08:12.110
We'll then move on to how
do you get that to an image.

00:08:12.830 --> 00:08:15.700
So render to a surface,
normally use AGL sector-allable,

00:08:15.900 --> 00:08:18.570
or maybe an NSOpenGL view if
you're using Cocoa to actually

00:08:18.570 --> 00:08:19.590
get the image to a surface.

00:08:19.630 --> 00:08:21.190
This seems normal and ordinary.

00:08:21.310 --> 00:08:24.560
We get a lot of requests, people saying,
"Hey, how about P-buffers?

00:08:24.560 --> 00:08:26.200
How about this off-screen stuff?

00:08:26.200 --> 00:08:29.550
How do I get accelerated
graphics to an off-screen?" Well,

00:08:29.550 --> 00:08:32.670
in Mac OS X,
the integration is such that really,

00:08:32.670 --> 00:08:35.200
you're doing exactly the same thing.

00:08:35.250 --> 00:08:37.700
You simply don't show the window.

00:08:37.840 --> 00:08:42.310
So if I'm in Carbon, for example,
and I just create a window, pixel format,

00:08:42.310 --> 00:08:45.700
attach my drawable,
have the OpenGL contacts attached to it,

00:08:45.800 --> 00:08:49.700
and I don't call show window where
I build a window that is off-screen,

00:08:49.700 --> 00:08:51.180
it works as you would expect.

00:08:51.200 --> 00:08:55.200
You get fully accelerated graphics
to that off-screen window.

00:08:55.460 --> 00:08:58.910
And with Mac OS X,
we allow you to manipulate that in

00:08:58.910 --> 00:09:01.700
new ways we'll show you in a minute.

00:09:01.700 --> 00:09:05.010
One caveat here is,
if you have a single monitor situation,

00:09:05.010 --> 00:09:06.200
it's pretty easy.

00:09:06.200 --> 00:09:07.200
You bring the window up.

00:09:07.220 --> 00:09:09.110
You know it's going to attach
to the right graphics card.

00:09:09.220 --> 00:09:11.130
You know everything's
going to work as expected.

00:09:11.220 --> 00:09:14.010
In multiple monitor situations, though,
you have something

00:09:14.010 --> 00:09:15.190
called a virtual screen.

00:09:15.200 --> 00:09:20.320
Both AGL and Cocoa have methods to
set the virtual screen to ensure that

00:09:20.520 --> 00:09:24.120
your content tracks with the window.

00:09:24.250 --> 00:09:26.260
For example,
let's say I have an off-screen window,

00:09:26.260 --> 00:09:29.190
which is just hidden,
and it's on the main monitor.

00:09:29.200 --> 00:09:32.200
So that's where it was placed or
what graphics card it's using.

00:09:32.200 --> 00:09:34.820
Then I have my secondary
window that I'm using,

00:09:34.820 --> 00:09:36.700
I'm drawing something into that and
taking something out of that window.

00:09:36.700 --> 00:09:38.700
I'm using it somewhere else.

00:09:38.700 --> 00:09:41.700
If I switch graphics cards,
the user switches graphics cards,

00:09:41.700 --> 00:09:44.700
drags the window somewhere else,
I need to make sure that it tracks,

00:09:44.700 --> 00:09:47.700
that the graphics accelerator
tracks with where my target is.

00:09:47.700 --> 00:09:49.700
And I'll show you that in a minute.

00:09:51.350 --> 00:09:54.260
So,
let's move on to texturing from an image.

00:09:54.300 --> 00:09:56.630
So it's pretty simple to
texture from an image.

00:09:56.630 --> 00:10:03.300
This is kind of your standard
thing if you have OpenGL content.

00:10:03.300 --> 00:10:06.300
A lot of folks say, "Hey,
I have an OpenGL screen.

00:10:06.300 --> 00:10:07.300
I want to make a movie of it.

00:10:07.300 --> 00:10:08.290
I want to take a snapshot of it.

00:10:08.310 --> 00:10:09.230
How do I do it?

00:10:09.300 --> 00:10:10.300
It's some strange format.

00:10:10.300 --> 00:10:14.070
I can't get the back buffer." Well,
it's actually almost easier.

00:10:14.070 --> 00:10:16.300
You're going to create a buffer,
which is the size of your image,

00:10:16.300 --> 00:10:17.300
real simply.

00:10:17.300 --> 00:10:19.300
Height, width, and bit depth.

00:10:19.300 --> 00:10:22.250
Then you're going to read
from the back buffer,

00:10:22.570 --> 00:10:27.490
setting the buffer to the back,
and then using GL read pixels to simply

00:10:27.490 --> 00:10:34.110
read the full accelerator back buffer
into your buffer you just created.

00:10:34.300 --> 00:10:36.290
I'm not going to go into
really depth on how to do this.

00:10:36.420 --> 00:10:39.950
In the game solutions section,
Todd Prevital will actually

00:10:40.040 --> 00:10:41.300
show a demo of this.

00:10:41.300 --> 00:10:45.050
He'll talk about how to do this and
even extend this into taking a series of

00:10:45.050 --> 00:10:47.300
snapshots and turning it into a movie.

00:10:47.300 --> 00:10:49.950
If you do have OpenGL content,
you have single image content

00:10:50.090 --> 00:10:53.240
and you want to pull it down,
it's very simple to do.

00:10:53.340 --> 00:10:55.300
It's just a few lines of code.

00:10:57.110 --> 00:10:59.240
So let's talk about
texture from anywhere.

00:10:59.300 --> 00:11:03.920
I'm going to kind of stretch the
idea of texturing to file loading,

00:11:03.920 --> 00:11:06.880
texturing from an image,
so moving an image into a texture,

00:11:07.190 --> 00:11:09.990
and then actually talking
about surface texturing.

00:11:10.830 --> 00:11:12.150
So texture from a file.

00:11:12.290 --> 00:11:16.330
This is kind of the meat and potatoes
of how to get textures in from any

00:11:16.350 --> 00:11:21.200
kind of file you have into an image,
and then you can texture from that.

00:11:21.300 --> 00:11:24.390
So I'm going to use the QuickTime image
compression API in this example.

00:11:24.430 --> 00:11:28.190
It is really a little bit of setup,
really powerful.

00:11:28.410 --> 00:11:30.810
Anything that QuickTime supports,
you can support,

00:11:30.840 --> 00:11:33.930
and it's a really great thing because,
you know, when QuickTime supports,

00:11:33.930 --> 00:11:38.200
it has TIFF support, it has JPEG support,
or QuickTime has Windows and

00:11:38.200 --> 00:11:39.770
Windows Media support.

00:11:40.120 --> 00:11:42.700
You can bring that in
without an additional code.

00:11:42.700 --> 00:11:45.870
You don't have to handle,
we get a lot of questions about, hey,

00:11:45.870 --> 00:11:47.840
how do I read a bitmap,
or how do I read this?

00:11:48.030 --> 00:11:51.460
Just use QuickTime, read it in,
you can do lossless,

00:11:51.640 --> 00:11:55.880
bring it in in a lossless way,
and you get the image at full quality.

00:11:56.090 --> 00:11:57.840
So I'm going to get a
graphics importer for file.

00:11:57.950 --> 00:12:01.050
So we'll assume in this case that
I have found a file that I like,

00:12:01.050 --> 00:12:05.280
and I want to get the graphics
importer to bring this in.

00:12:05.360 --> 00:12:08.630
What this does is it actually
does kind of a smart search.

00:12:08.710 --> 00:12:11.340
It looks at the file extension to say,
hey, do I know how to do this file?

00:12:11.340 --> 00:12:12.600
Is it a .jpeg?

00:12:12.940 --> 00:12:15.070
And also, if it has to,
it'll look at the file

00:12:15.070 --> 00:12:16.500
type and the file content.

00:12:16.500 --> 00:12:21.290
So if it's just a file named My File,
it'll actually look in the

00:12:21.290 --> 00:12:24.280
content and try and find its
decompressor for that file.

00:12:24.440 --> 00:12:25.700
I get the natural bounds here.

00:12:25.700 --> 00:12:29.040
What that tells me is
actually the size of the file,

00:12:29.040 --> 00:12:31.620
the size of the actual image,
so I get the right

00:12:31.700 --> 00:12:32.880
buffer in the background.

00:12:33.110 --> 00:12:36.360
The row stride in this
case is pretty simple.

00:12:36.430 --> 00:12:38.240
It's just the width and height,
but if you notice,

00:12:38.290 --> 00:12:39.440
there's a target depth.

00:12:39.580 --> 00:12:42.560
The target depth is how
deep do I want my texture.

00:12:42.560 --> 00:12:45.360
I can read, in QuickTime,
I can read it into any depth thing.

00:12:45.360 --> 00:12:48.530
So I can take a 32-bit image and
read it into a 16-bit buffer,

00:12:48.530 --> 00:12:49.440
or vice versa.

00:12:49.440 --> 00:12:51.500
So I make sure I know
where I'm reading it into.

00:12:51.500 --> 00:12:54.540
Usually, you may want to keep textures
corresponding to your screen depth,

00:12:54.640 --> 00:12:58.250
or you may want them at
32 to keep the accuracy.

00:12:58.890 --> 00:13:01.580
The base address,
I'm going to use that new pointer clear.

00:13:01.580 --> 00:13:05.390
Again, basically just create a buffer and
that's going to be the size of the image,

00:13:05.720 --> 00:13:09.290
row stride,
and the top and the bottom of the image.

00:13:11.560 --> 00:13:13.640
So let's build a back
buffer for the image.

00:13:13.640 --> 00:13:14.570
You'll see this a lot.

00:13:14.590 --> 00:13:16.180
You'll see it in Ken's presentation.

00:13:16.180 --> 00:13:18.000
You'll see it in my
presentation more than once.

00:13:18.170 --> 00:13:20.250
Qt New GWorld from Pointer.

00:13:20.250 --> 00:13:22.500
Why Qt New GWorld from Pointer?

00:13:22.500 --> 00:13:24.250
Why not some other routine?

00:13:24.260 --> 00:13:25.640
Why not some Cocoa routine?

00:13:25.700 --> 00:13:26.820
Why not New GWorld?

00:13:27.150 --> 00:13:30.930
The key here is this routine
creates a buffer that is unpadded.

00:13:30.930 --> 00:13:33.160
So there's no extra row byte padding.

00:13:33.160 --> 00:13:36.670
They didn't decide that, hey,
we may want to keep each row 16

00:13:36.750 --> 00:13:39.560
byte aligned or something like that,
so we'll throw some

00:13:39.560 --> 00:13:40.500
unknown padding at the end.

00:13:40.500 --> 00:13:42.740
The key here is this is
a packed pixel buffer,

00:13:42.740 --> 00:13:47.070
and you can hand this directly to OpenGL,
and OpenGL will directly texture from it.

00:13:47.440 --> 00:13:48.480
Works like a champ.

00:13:48.500 --> 00:13:49.700
So I have two cases here.

00:13:49.700 --> 00:13:53.190
One case is 32-bit, one case is 16-bit,
and the only difference is

00:13:53.190 --> 00:13:54.890
actually the pixel format here.

00:13:55.210 --> 00:13:56.490
Again, this is the key.

00:13:56.520 --> 00:13:59.500
If you're bringing in a 32-bit
image you want to put in 16-bit,

00:13:59.500 --> 00:14:02.050
you would use the second case there.

00:14:04.950 --> 00:14:06.900
So now we're going to
set a scaling matrix.

00:14:06.930 --> 00:14:09.010
In some cases you have an image
that you really don't want a

00:14:09.140 --> 00:14:10.660
texture from that native resolution.

00:14:10.660 --> 00:14:13.140
For example,
we'll talk a little bit about

00:14:13.140 --> 00:14:17.900
texture rectangle and texture 2D,
geotexture 2D.

00:14:17.940 --> 00:14:21.860
Geotexture 2D had limited to
two powers of two texturing,

00:14:21.880 --> 00:14:24.340
so you get 16, 32, 64.

00:14:24.340 --> 00:14:27.000
In that case you may want to bring an
image in and actually shrink it down

00:14:27.000 --> 00:14:28.370
to fit one of those powers of two.

00:14:28.580 --> 00:14:30.890
You can do that with the
scale matrix in QuickTime.

00:14:30.910 --> 00:14:31.750
It's very simple to do.

00:14:31.750 --> 00:14:35.710
You set up a texture width
divided by the image width,

00:14:35.740 --> 00:14:36.900
so I'm getting a ratio here.

00:14:37.090 --> 00:14:39.900
The height of the texture
divided by the image height,

00:14:39.900 --> 00:14:42.870
again a ratio, and I'm not doing any kind
of other transformation.

00:14:42.910 --> 00:14:44.900
So this is a simple 2D transformation.

00:14:44.930 --> 00:14:47.900
When QuickTime reads it in,
it will scale it.

00:14:48.350 --> 00:14:50.890
Interestingly to note,
this also works for movies.

00:14:50.900 --> 00:14:53.900
Very similar kind of calls for movies.

00:14:53.900 --> 00:14:56.900
If you have a movie and you
want to scale the movie on draw,

00:14:56.900 --> 00:14:57.880
this works.

00:14:57.970 --> 00:15:00.900
And QuickTime does a
very good job of scaling.

00:15:00.900 --> 00:15:01.900
When it does a movie.

00:15:01.900 --> 00:15:04.900
It sets up the scaling matrix,
does an optimized routine.

00:15:04.910 --> 00:15:08.030
So I've used this significantly
during my movie code,

00:15:08.030 --> 00:15:09.770
and it really is,
you don't pay a penalty for

00:15:09.770 --> 00:15:10.900
actually doing movie scaling.

00:15:10.900 --> 00:15:12.720
It's not doing some kind of
floating point scale that it

00:15:12.720 --> 00:15:13.900
calculates every single frame.

00:15:13.900 --> 00:15:17.900
It sets up a table lookup,
and it uses that to scale the movie.

00:15:20.310 --> 00:15:23.030
So this is the meat of this routine.

00:15:23.030 --> 00:15:25.100
Graphics import setGworld,
so we're going to tell it to

00:15:25.190 --> 00:15:26.130
point to the right G world.

00:15:26.170 --> 00:15:28.100
We're going to set the
quality to lossless.

00:15:28.520 --> 00:15:30.190
So this is saying, hey,
I want to compress the image

00:15:30.240 --> 00:15:31.200
when I'm reading it in.

00:15:31.200 --> 00:15:32.700
I just want to read it
in exactly the format.

00:15:32.700 --> 00:15:35.400
So if you have a bitmap,
you have a TIFF file that actually

00:15:35.400 --> 00:15:38.410
doesn't have any compression,
this will make sure your image in

00:15:38.560 --> 00:15:41.490
memory does not have compression either,
or it just doesn't have

00:15:41.620 --> 00:15:43.200
any loss in bringing it in.

00:15:43.200 --> 00:15:45.360
I'm going to get the Pixmap
and make sure I lock it.

00:15:45.360 --> 00:15:50.100
Always make sure you lock your pixels
and you check when you lock it.

00:15:50.110 --> 00:15:55.040
Graphics import draw,
which will draw it into your G world now,

00:15:55.040 --> 00:15:57.960
so now your packed buffer of
G world has the pixels you want.

00:15:57.980 --> 00:15:59.190
Unlock the pixels, close the component.

00:15:59.200 --> 00:16:00.590
Now what do you have?

00:16:00.590 --> 00:16:02.200
What is in that G world?

00:16:02.200 --> 00:16:06.140
That G world has an
ARGB pixel representation.

00:16:06.150 --> 00:16:09.090
Two cases: 32-bit and 16-bit.

00:16:09.210 --> 00:16:12.200
32-bit is 8 bits per component, alpha,
red, green, blue.

00:16:12.200 --> 00:16:14.200
16-bit is 1555.

00:16:14.200 --> 00:16:18.930
One bit of alpha, 5 bits for red, green,
and blue together.

00:16:19.300 --> 00:16:21.150
So remember this when
we get to other things.

00:16:21.270 --> 00:16:24.200
The key here is that you have a
format now that OpenGL can understand.

00:16:24.200 --> 00:16:26.580
Using a Packed Pixels extension,
which I'll bring up later,

00:16:26.580 --> 00:16:28.200
you can pass it directly into OpenGL.

00:16:28.200 --> 00:16:30.200
No pixel swizzling.

00:16:30.200 --> 00:16:33.650
You don't say, oh, I've got to get RGB,
so I've got to take the AR component

00:16:33.650 --> 00:16:36.200
and move it over and pack it
all in and change my bounds.

00:16:36.200 --> 00:16:36.620
No.

00:16:36.750 --> 00:16:40.200
This works very easily
right out of the box.

00:16:41.280 --> 00:16:42.900
So let's talk about
texturing from an image.

00:16:42.900 --> 00:16:44.160
So now we've loaded the image.

00:16:44.310 --> 00:16:46.280
So we have this nice image in,
we can texture from it.

00:16:46.560 --> 00:16:48.200
How do I do it?

00:16:48.370 --> 00:16:50.520
The easiest thing is to
use texture rectangle.

00:16:50.860 --> 00:16:56.200
This was introduced in, I believe, 10.1,
and it still persists in Jaguar.

00:16:56.200 --> 00:16:58.230
And the rule of thumb is,
if you check for the

00:16:58.360 --> 00:17:01.100
texture rectangle extension,
and it exists, use it.

00:17:01.200 --> 00:17:05.200
It will provide the fastest method of
access for the cards that support it.

00:17:05.200 --> 00:17:06.980
For example,
the Rage 128 does not support

00:17:07.070 --> 00:17:10.200
non-power of two textures,
which is what texture rectangle means.

00:17:10.200 --> 00:17:13.200
Most other cards do
support texture rectangle.

00:17:13.200 --> 00:17:17.600
The GeForce 2 MX, GeForce 4 MX,
GeForce 3 and 4,

00:17:17.610 --> 00:17:22.290
and the ATI Radeon 8500 all
support texture rectangle,

00:17:22.290 --> 00:17:24.200
which means any size
texture can be passed in.

00:17:24.200 --> 00:17:26.910
It's really nice when you
have an image or something,

00:17:26.910 --> 00:17:29.310
or for example,
in the Windows server you have a

00:17:29.310 --> 00:17:31.200
window that's not a power of two.

00:17:31.200 --> 00:17:32.650
I mean,
we're trying to play content in the

00:17:32.650 --> 00:17:34.080
Windows server that's not a power of two.

00:17:34.230 --> 00:17:36.200
A DV stream may not be a power of two.

00:17:36.200 --> 00:17:39.180
Thus, texture rectangle is key
to getting this stuff out.

00:17:41.270 --> 00:17:42.760
So here's how you check
for the extension.

00:17:42.920 --> 00:17:44.730
GL_EXT_TEXTURE_RECTANGLE.

00:17:44.730 --> 00:17:46.960
Do a string comparison
on the extension string.

00:17:46.990 --> 00:17:48.690
Make sure that you have that extension.

00:17:48.700 --> 00:17:51.840
Once you know you have the extension,
you can enable texture rectangle just

00:17:51.840 --> 00:17:53.600
like you would enable a 2D texture.

00:17:53.750 --> 00:17:58.480
So if I'm texturing from OpenGL,
normally I would call GL_TEXTURE_2D.

00:17:58.580 --> 00:18:02.060
In this case,
I'll call GL_TEXTURE_RECTANGLE_EXT.

00:18:03.580 --> 00:18:05.500
So now I'm in a texture with
the correct texture target.

00:18:05.500 --> 00:18:07.310
So we have our image.

00:18:07.450 --> 00:18:10.060
It was in the buffer,
and I called GL text image 2D.

00:18:10.060 --> 00:18:12.950
So this is actually
pointing GL from the buffer,

00:18:13.720 --> 00:18:16.640
from the image buffer,
telling it to do whether it needs

00:18:16.640 --> 00:18:19.100
to load it or just understand
that that's the current texture.

00:18:19.100 --> 00:18:20.890
Texture rectangle EXT.

00:18:20.890 --> 00:18:22.160
It's an RGBA format.

00:18:22.160 --> 00:18:24.820
It's OpenGL's internal format
that it's going to handle.

00:18:25.300 --> 00:18:27.640
And the next line is
pretty critical here.

00:18:27.650 --> 00:18:33.280
GL BGRA EXT GL unsigned in 888 reversed.

00:18:33.380 --> 00:18:36.140
It's kind of complicated
to read and understand.

00:18:36.140 --> 00:18:38.420
What actually it means is
the reverse at the end,

00:18:38.420 --> 00:18:40.820
the rev at the end, applies to the BGRA.

00:18:40.820 --> 00:18:44.060
So if you reverse that,
you get ARGB 8888,

00:18:44.060 --> 00:18:48.060
and that's the format the Mac supports
normally and you have in your image.

00:18:48.500 --> 00:18:53.730
Obviously, if you had done a 16-bit,
it would be 1555 reversed.

00:18:53.860 --> 00:18:57.090
Very key that allows OpenGL to
take that format natively,

00:18:57.230 --> 00:19:00.390
manipulate it without you having
to do any pixel swizzling.

00:19:00.710 --> 00:19:03.120
One key with using texture rectangle:
when you look into some

00:19:03.120 --> 00:19:05.000
OpenGL sample code,
one of the mistakes people make when

00:19:05.000 --> 00:19:07.900
they move to texture rectangle is
not understanding that the texture

00:19:08.000 --> 00:19:11.680
coordinates in texture rectangle are
actual image coordinates in the texture,

00:19:11.680 --> 00:19:13.600
or textual coordinates in the texture.

00:19:13.710 --> 00:19:16.240
So instead of wanting to use
a full size of a texture,

00:19:16.240 --> 00:19:19.580
normally I would do 00:11
as a texturing coordinates.

00:19:19.600 --> 00:19:24.590
In this case,
I'm going to use 00:320x240, or 256x256,

00:19:24.650 --> 00:19:26.600
or whatever my texture size is.

00:19:26.600 --> 00:19:31.600
So make sure you note that when you're
switching over to texture rectangle.

00:19:31.600 --> 00:19:34.600
Let's move on to talking about
some other techniques for using it.

00:19:34.600 --> 00:19:36.570
So now texture rectangle
is not available.

00:19:36.620 --> 00:19:37.550
What do I do with an image now?

00:19:37.650 --> 00:19:39.590
The simplest thing you can do is scaling.

00:19:39.600 --> 00:19:45.650
So we saw that QuickTime has a scaling
matrix when you read the texture in,

00:19:45.660 --> 00:19:46.600
and you can scale it to any size.

00:19:46.600 --> 00:19:50.600
So, hmm, don't have texture rectangle,
just do power of two textures.

00:19:50.600 --> 00:19:52.600
Well,
I'll take the simple path out of this,

00:19:52.600 --> 00:19:55.600
and what I'll do is I'll
scale it to 256x256,

00:19:55.600 --> 00:19:56.590
which is a lot of work.

00:19:56.600 --> 00:19:58.690
So what I'm going to do is,
as you see on the image

00:19:58.690 --> 00:20:03.770
on your left here,
is squeeze down to a size that OpenGL can

00:20:03.770 --> 00:20:05.600
manage without texture rectangle.

00:20:05.600 --> 00:20:07.210
When I draw it,
all I'm going to do is draw it to a

00:20:07.210 --> 00:20:11.420
polygon that's actually the correct
aspect ratio for the original image.

00:20:11.830 --> 00:20:16.600
OpenGL will take care of linearly
filtering that texture and scaling it up.

00:20:16.800 --> 00:20:18.670
There is data loss, though,
because you are actually

00:20:18.670 --> 00:20:21.560
squeezing it down,
and you are stretching it back out.

00:20:21.600 --> 00:20:24.600
So realize that this is not the
most accurate way to do things,

00:20:24.600 --> 00:20:25.600
but for a lot of cases, this may suffice.

00:20:25.600 --> 00:20:27.830
this may suffice.

00:20:29.080 --> 00:20:30.730
So, how do we, how do we scale?

00:20:30.730 --> 00:20:35.890
Basically, this is in sample code in
the OpenGL image sample.

00:20:35.890 --> 00:20:37.260
I'm going to walk you
through it a little bit.

00:20:37.520 --> 00:20:39.320
Basically, what this is going to
do is take a texture,

00:20:39.320 --> 00:20:41.340
a texture dimension
from an image dimension.

00:20:41.430 --> 00:20:43.710
So,
if you pass an image dimension in here,

00:20:43.800 --> 00:20:46.930
what's going to happen is,
you're actually going to find

00:20:46.950 --> 00:20:50.640
out the largest texture size that
this supports at the power of two.

00:20:50.640 --> 00:20:52.800
So, if you can see,
it says if it's larger than

00:20:52.800 --> 00:20:54.900
the max texture size supported,
we're going to return that.

00:20:55.140 --> 00:20:57.870
Otherwise, it uses a,
it uses a shift and shifts texture

00:20:57.890 --> 00:21:01.510
dimension down until it finds an
image that is the largest size

00:21:01.550 --> 00:21:05.400
that can be supported for the,
that can be scaled into.

00:21:07.810 --> 00:21:09.080
What's another option?

00:21:09.220 --> 00:21:10.560
Now I don't want to lose pixels.

00:21:10.620 --> 00:21:14.310
I don't want to squeeze it down and lose
some pixels when I stretch it back out.

00:21:14.410 --> 00:21:16.140
This is image slicing.

00:21:16.240 --> 00:21:20.230
Most engines that support-- game engines
that have their own UI that support

00:21:20.630 --> 00:21:26.190
kind of a 2D presentation of things
will use an image slicing algorithm.

00:21:26.390 --> 00:21:27.870
Basically,
what here you're going to do is,

00:21:27.880 --> 00:21:31.460
if you see the green lines represent
actual polygons that are being drawn.

00:21:31.460 --> 00:21:34.540
So in this case, with this image,
it's not a power of two image.

00:21:34.660 --> 00:21:37.890
So I'm going to slice it down to a
number of polygons using an algorithm

00:21:37.890 --> 00:21:41.660
that finds the largest texture that
I can fit in the space that's remaining.

00:21:41.660 --> 00:21:44.450
So if I have 320
remaining across the top,

00:21:44.530 --> 00:21:46.350
I take a 256 slice out.

00:21:46.360 --> 00:21:50.870
I subtract that out, look at what's left,
and then take the next largest texture

00:21:50.870 --> 00:21:52.790
slice that I can do out of that.

00:21:53.780 --> 00:21:55.420
Key here is when you texture from these.

00:21:55.500 --> 00:21:59.300
We saw that you actually pass
a buffer into GLTextImage2D.

00:21:59.320 --> 00:22:02.140
What you need to do with that is
actually offset that to the top of

00:22:02.140 --> 00:22:04.320
each texture you're texturing from.

00:22:04.360 --> 00:22:06.510
Pretty simple if you know
what your offsets are,

00:22:06.510 --> 00:22:09.300
because you do have a packed buffer,
you know what your row stride is,

00:22:09.370 --> 00:22:11.900
you know what the number of rows is,
and you can just offset in as

00:22:11.900 --> 00:22:14.170
you walk through the textures.

00:22:14.350 --> 00:22:17.460
Use the image width for row stride so
that will never be the same because

00:22:17.460 --> 00:22:21.130
OpenGL needs the entire row stride,
not just that piece of the texture,

00:22:21.130 --> 00:22:22.460
to texture it from.

00:22:22.460 --> 00:22:26.260
And you need to use unpack
row length to set this.

00:22:28.380 --> 00:22:30.740
So what we're going to do here is we're
going to find the number of textures

00:22:30.740 --> 00:22:32.700
and generate texture objects for that.

00:22:32.810 --> 00:22:35.480
So texture_action,
texture_y are two routines that I'll

00:22:35.480 --> 00:22:38.080
show you in a minute that actually
generate the number of textures,

00:22:38.120 --> 00:22:40.260
x and y, from an image size.

00:22:40.300 --> 00:22:46.760
Then we're going to use new_pointer_clear
to generate a bin for the textures.

00:22:46.860 --> 00:22:49.140
This may be something like--
not like 1,000 by 1,000,

00:22:49.140 --> 00:22:51.240
but we're talking about
something like 5 by 4.

00:22:51.530 --> 00:22:54.660
So maybe new_pointer_clear
will generate 20 textures.

00:22:54.700 --> 00:22:57.400
Then what I do is set
the unpacked row length,

00:22:57.400 --> 00:22:58.840
as I showed you, to the texture width.

00:22:58.970 --> 00:23:01.060
So this is the texture
width for all of them.

00:23:01.110 --> 00:23:03.590
And then I gen_textures the number
of textures I need for the image.

00:23:03.790 --> 00:23:06.460
So what this is doing is this
is basically saying I need

00:23:06.460 --> 00:23:09.890
to store five texture names,
20 texture names to

00:23:09.890 --> 00:23:10.890
texture from this image.

00:23:11.020 --> 00:23:14.920
I need to generate them,
and I need to store the width of that.

00:23:14.970 --> 00:23:18.470
Moving on, this is going to texture
from each slice here.

00:23:18.800 --> 00:23:20.890
So what this does,
it gets the next texture size.

00:23:20.960 --> 00:23:21.900
We talked about this already.

00:23:21.900 --> 00:23:27.540
It takes what's remaining,
the 340 or whatever you have remaining,

00:23:27.550 --> 00:23:30.010
and finds the largest texture
that will fit in that slice.

00:23:30.150 --> 00:23:31.900
In that case it would be 256.

00:23:31.900 --> 00:23:35.850
It then offsets the buffer pointer,
as I mentioned previously,

00:23:35.850 --> 00:23:37.890
to the start point of the texture.

00:23:39.130 --> 00:23:41.570
We then get the texture
size for the height.

00:23:41.570 --> 00:23:43.400
We bind to the appropriate texture.

00:23:43.400 --> 00:23:45.000
We're going to walk
through them in order.

00:23:45.230 --> 00:23:48.050
And you've seen the
familiar GL text image 2D.

00:23:48.280 --> 00:23:50.500
Using texture 2D,
because remember we're not using

00:23:50.500 --> 00:23:52.970
texture rectangle in this case,
so we're just using the

00:23:53.050 --> 00:23:54.000
power of two textures.

00:23:54.000 --> 00:23:57.780
You've seen the two BGRAs,
unsigned int888 reversed and

00:23:57.790 --> 00:24:00.000
unsigned short888 reversed.

00:24:00.180 --> 00:24:02.960
And then we'll offset X and
Y to the next texture.

00:24:03.070 --> 00:24:05.000
So this is,
you just walk through the textures.

00:24:05.000 --> 00:24:06.960
When you draw them,
you basically do the exact same thing.

00:24:06.960 --> 00:24:09.390
You walk through the
textures and draw them.

00:24:09.990 --> 00:24:11.900
So this is two of the routines
I said I would mention.

00:24:12.640 --> 00:24:15.900
First,
get text number from texture dimension.

00:24:15.900 --> 00:24:17.900
This basically is going to
tell you how many textures.

00:24:17.930 --> 00:24:20.900
If you look at what it does,
it starts with a very large texture.

00:24:20.900 --> 00:24:26.980
If the image is that size or larger,
it just increments "i" and it

00:24:27.000 --> 00:24:29.320
walks through every texture
without breaking out of that and

00:24:29.320 --> 00:24:30.900
adds through how many textures.

00:24:30.900 --> 00:24:36.900
So it says, is there an 8000 size
to 8192 size texture?

00:24:36.900 --> 00:24:39.350
If the image is larger than that,
it subtracts that from

00:24:39.450 --> 00:24:42.900
the image and says,
is there 4000 left, is there 2000 left,

00:24:42.900 --> 00:24:43.890
is there 1000 left, etc.

00:24:43.900 --> 00:24:44.900
through the entire image.

00:24:44.900 --> 00:24:45.900
So it's real simple.

00:24:45.900 --> 00:24:47.900
It just tells you how
many textures and x and y.

00:24:47.900 --> 00:24:51.210
Again, all the sample code is in the
OpenGL image sample which is

00:24:51.210 --> 00:24:52.900
currently posted on the web.

00:24:53.760 --> 00:24:55.530
This gets the next texture size.

00:24:55.660 --> 00:24:59.500
So this basically says what part
of the image do I have left,

00:24:59.550 --> 00:25:02.370
what's the max texture,
and I want to tell you what the

00:25:02.370 --> 00:25:04.060
next texture size is going to be.

00:25:06.720 --> 00:25:07.800
Okay, you have a G world.

00:25:07.800 --> 00:25:09.060
We've talked about this before.

00:25:09.230 --> 00:25:13.440
We read your image into a G world,
and now you want a texture from that.

00:25:13.440 --> 00:25:15.430
So what do you need to do?

00:25:16.110 --> 00:25:17.780
You want to use Packed Pixels.

00:25:18.070 --> 00:25:20.560
Because the software renderer has not
supported Packed Pixels in the past,

00:25:20.560 --> 00:25:24.760
I would recommend No Recovery,
which tells your implementation

00:25:24.760 --> 00:25:28.840
that you do not want to have a
software fallback for your case.

00:25:28.840 --> 00:25:32.460
You want to just allocate the hardware
renderer on whatever card you're on.

00:25:32.600 --> 00:25:36.120
Then you need OpenGL version 1.2,
so you can check the version string,

00:25:36.120 --> 00:25:38.460
or check the GL Apple Packed
Pixels extension,

00:25:38.460 --> 00:25:42.300
which should be supported across the
board on every accelerated video card.

00:25:42.400 --> 00:25:48.700
What that allows you to do is use
the BGRA EXT in the reversed format.

00:25:48.780 --> 00:25:49.700
You've seen this before.

00:25:50.090 --> 00:25:51.630
Standard OpenGL texturing.

00:25:51.880 --> 00:25:55.350
You're going to texture from
the G world that you have,

00:25:55.350 --> 00:25:56.760
as you saw before.

00:25:57.870 --> 00:26:00.020
Okay, so texture from NSImage.

00:26:00.020 --> 00:26:02.730
Assuming you have an NSImage
that you want to texture from,

00:26:02.880 --> 00:26:05.500
it's fairly simple.

00:26:05.500 --> 00:26:07.200
It's fairly close to the same thing.

00:26:07.300 --> 00:26:10.550
In this case, you're going to get a
TIFF representation of that image,

00:26:10.630 --> 00:26:12.790
so you actually have
a flat representation.

00:26:12.800 --> 00:26:15.520
We're checking to see if we have alpha,
and that basically determines

00:26:15.520 --> 00:26:16.750
the OpenGL internal format.

00:26:16.810 --> 00:26:19.800
NSImages have a slightly
different format than GWorlds,

00:26:19.800 --> 00:26:23.800
so in this case we're going to either
do an RGBA for OpenGL internal format,

00:26:23.800 --> 00:26:27.800
or RGB, and we need to understand what
pixel size we're dealing with,

00:26:27.870 --> 00:26:30.110
three or four bytes per pixel.

00:26:30.750 --> 00:26:33.010
Then we're going to get the
number of bytes per row for

00:26:33.010 --> 00:26:34.300
the image using that method.

00:26:34.350 --> 00:26:35.960
We're going to get a
pointer to the bitmap data,

00:26:35.960 --> 00:26:38.440
which is basically the
same as our buffer pointer.

00:26:38.550 --> 00:26:40.490
We get the image size.

00:26:40.640 --> 00:26:42.080
So, unpack row length.

00:26:42.180 --> 00:26:45.940
Again, that needs to be set to the number
of bytes as the length of the row.

00:26:46.070 --> 00:26:50.540
Set the alignment for pixel store,
so we're doing a byte alignment.

00:26:50.600 --> 00:26:54.050
And then text image 2D call,
very similar.

00:26:54.310 --> 00:26:57.060
Image width, image height,
and image data.

00:26:57.130 --> 00:27:01.310
But notice we're using RGBA and
unsigned byte as the format.

00:27:01.650 --> 00:27:05.820
Whereas GWorlds are in that kind
of reversed ARGB packed format.

00:27:05.880 --> 00:27:07.980
This representation of the
image is going to be an

00:27:07.980 --> 00:27:09.560
RGBA representation of the image.

00:27:09.620 --> 00:27:14.600
And so you want to use the RGBA when you
pass it in from an NSImage to OpenGL.

00:27:14.660 --> 00:27:18.000
And then we're going to release the
image rep that we got for the TIFF image.

00:27:18.080 --> 00:27:19.090
Pretty simple.

00:27:19.280 --> 00:27:20.230
Works well.

00:27:20.340 --> 00:27:22.790
Carbon works well in Cocoa.

00:27:23.690 --> 00:27:25.600
Okay.

00:27:25.680 --> 00:27:28.040
What are one of the cool
things that we can do?

00:27:28.110 --> 00:27:30.240
One of the cool things we can
do is texture from surface.

00:27:30.240 --> 00:27:32.260
This is new for Jaguar.

00:27:32.450 --> 00:27:36.740
People have been saying, "Hey,
we want that accelerated P buffer so

00:27:36.740 --> 00:27:41.210
we can render into that and use that to
use somewhere else." We could render a

00:27:41.210 --> 00:27:44.740
reflection into an off-screen and then
use that to texture somewhere else.

00:27:44.850 --> 00:27:49.790
In this case,
we're going to use texture from surface

00:27:49.960 --> 00:27:49.960
and we'll show you how that works.

00:27:51.480 --> 00:27:53.970
First you need to pick the
appropriate texture target.

00:27:53.970 --> 00:27:56.890
Texture from Surface works on whatever
texture target your card supports.

00:27:56.890 --> 00:27:58.850
It works on all of our
accelerated video cards,

00:27:58.850 --> 00:28:01.390
so if you have a Rage 128,
you do have this capability.

00:28:01.590 --> 00:28:04.420
But, remember, the Rage 128 does not
have texture rectangle,

00:28:04.690 --> 00:28:06.220
thus you'll have to use texture 2D.

00:28:06.410 --> 00:28:08.550
And as I said before,
the rule of thumb here is

00:28:08.670 --> 00:28:09.930
to use the best available.

00:28:09.930 --> 00:28:12.530
Assume texture rectangle
is better than texture 2D,

00:28:12.600 --> 00:28:15.390
use that if you have it,
and use the best available.

00:28:15.400 --> 00:28:19.400
That will allow the card to
use its most optimum path.

00:28:19.400 --> 00:28:21.400
In Carbon,
the call is AGL Surface Texture.

00:28:21.400 --> 00:28:24.300
You pass your AGL context
you're currently using.

00:28:24.380 --> 00:28:26.400
You pass your texture target.

00:28:26.770 --> 00:28:32.080
You pass RGBA8 or RGB.

00:28:32.500 --> 00:28:35.400
And then the last parameter
is another context.

00:28:35.510 --> 00:28:36.520
So you have two windows.

00:28:36.830 --> 00:28:38.620
You have the context for both windows.

00:28:38.620 --> 00:28:42.400
You use one window as the source for
the rendering into the second window.

00:28:42.400 --> 00:28:45.840
In Cocoa, Create Texture,
you'll pass a view into that.

00:28:45.930 --> 00:28:47.400
So you pass an NSView,
and you'll have to pass

00:28:47.400 --> 00:28:47.400
an internal format,
the RGB.

00:28:47.400 --> 00:28:52.190
to pass an internal format, the RGBA8,
is the Cocoa method.

00:28:52.770 --> 00:28:55.050
So, let's look at a demo of this.

00:28:55.080 --> 00:28:58.030
Let me bring up the demo 2.

00:29:00.700 --> 00:29:03.230
Okay,
so what I have here is really just a cube

00:29:03.230 --> 00:29:08.340
spinning with a ship being drawn on it.

00:29:08.630 --> 00:29:09.380
I mean, what's up with that?

00:29:09.410 --> 00:29:11.240
That's not very exciting.

00:29:11.440 --> 00:29:11.920
That's easy.

00:29:11.920 --> 00:29:12.600
Anyone can do that.

00:29:12.600 --> 00:29:18.600
Well, the key here is the image on that
cube is being rendered somewhere else.

00:29:18.600 --> 00:29:20.540
It's being rendered hardware accelerated.

00:29:20.620 --> 00:29:22.500
This works on my PowerBook as
well as it works on here.

00:29:22.600 --> 00:29:27.500
So, to prove that to you,
let's bring a wireframe up.

00:29:27.600 --> 00:29:30.630
So now I just switched to
wireframe rendering for the

00:29:30.850 --> 00:29:32.600
original source texture.

00:29:32.600 --> 00:29:37.130
So the ship is now being rendered
in wireframe and I can switch

00:29:37.130 --> 00:29:38.600
back off to the normal rendering.

00:29:38.600 --> 00:29:39.600
So, let's bring that window up.

00:29:39.600 --> 00:29:42.600
Remember I said all it
is is hiding the window.

00:29:42.950 --> 00:29:44.600
There's a source surface.

00:29:44.710 --> 00:29:47.310
So, I have this window here.

00:29:48.260 --> 00:29:48.800
on my mouse.

00:29:48.800 --> 00:29:52.460
I have this window here,
and it is the source for

00:29:52.470 --> 00:29:53.790
the spaces of that cube.

00:29:53.840 --> 00:29:56.180
Obviously,
this is a simple implementation.

00:29:56.230 --> 00:29:57.780
You can do much more with it.

00:29:57.780 --> 00:29:59.180
You can genie it down there.

00:29:59.350 --> 00:30:00.060
It still works.

00:30:00.170 --> 00:30:01.140
It's not a problem.

00:30:01.140 --> 00:30:03.370
I bring it back up,
and it's still working.

00:30:03.430 --> 00:30:04.430
I can drag it around.

00:30:04.440 --> 00:30:06.900
It doesn't matter if it's
off-screen or on-screen.

00:30:06.900 --> 00:30:10.380
The key here is that surface
is the source texture,

00:30:10.390 --> 00:30:14.410
and you just created that just
like you created any other window.

00:30:14.410 --> 00:30:17.320
You don't have to create a p-buffer
and understand that extension.

00:30:17.500 --> 00:30:19.550
All you have to do is
create a window of context.

00:30:19.650 --> 00:30:22.560
I didn't show the window, and I said,
hey, HL surface texture,

00:30:22.560 --> 00:30:26.300
instead of calling text image 2D,
I call the HL surface texture call.

00:30:26.300 --> 00:30:29.240
It directly substitutes in,
and you can do things like this.

00:30:29.240 --> 00:30:31.720
You can do things like
stretching meshes around it.

00:30:31.780 --> 00:30:34.520
You can render a movie onto
a mesh and then render that

00:30:34.520 --> 00:30:36.040
object into another scene.

00:30:36.300 --> 00:30:39.570
You can do all kinds of things
that are two-stage dependent

00:30:39.670 --> 00:30:41.620
rendering here is what you get.

00:30:44.120 --> 00:30:47.750
And again, this is new for Jaguar.

00:30:47.920 --> 00:30:49.850
Bring the slides back up.

00:30:53.420 --> 00:30:55.960
So now let's talk a little
bit about image display.

00:30:56.000 --> 00:30:59.880
This is a pretty simple topic to cover,
but it eludes people at some points

00:30:59.960 --> 00:31:03.300
about handling pixels and getting
everything set up correctly.

00:31:03.390 --> 00:31:05.960
If you want to display images in OpenGL,
what you're going to want to

00:31:05.960 --> 00:31:07.300
do is a parallel projection.

00:31:07.300 --> 00:31:11.030
Normally you think of OpenGL as a 3D
API where all you're going to do with

00:31:11.100 --> 00:31:16.140
it is do a projective projection.

00:31:16.390 --> 00:31:18.240
In this case,
what we're going to do is we're going

00:31:18.240 --> 00:31:21.090
to set up a parallel projection,
so an orthographic display ignoring Z.

00:31:21.290 --> 00:31:23.300
So we're going to use a
painter's kind of algorithm.

00:31:23.300 --> 00:31:24.190
Whatever's in the back is
going to be in the back,

00:31:24.190 --> 00:31:25.300
whatever's in the front is
going to be in the front.

00:31:25.340 --> 00:31:28.300
This is very similar to how the
accelerated Windows server works.

00:31:28.450 --> 00:31:31.630
Very similar algorithm.

00:31:31.910 --> 00:31:34.090
We're going to use
polygons to scale images.

00:31:34.200 --> 00:31:38.290
So your polygon is always going to
have the appropriate relative ratios

00:31:38.300 --> 00:31:39.680
between the height and the width.

00:31:39.770 --> 00:31:42.240
And you're going to use the polygon
size to actually scale the image.

00:31:42.240 --> 00:31:43.800
The texture size will never change.

00:31:43.830 --> 00:31:45.430
Texture coordinates will never change.

00:31:45.470 --> 00:31:48.240
So texture coordinates stay in the
corners of the polygon and you actually

00:31:48.240 --> 00:31:49.800
move the polygon to scale the image.

00:31:49.800 --> 00:31:51.960
If you wanted to,
you could use texture coordinates

00:31:52.030 --> 00:31:54.720
as you could keep the polygon your
full screen or your window size and

00:31:54.830 --> 00:31:57.750
you could use texture coordinates
to manipulate the area of the image.

00:31:57.790 --> 00:31:59.900
I think the polygon scale is
a lot simpler to think about,

00:31:59.900 --> 00:32:02.800
but may not be applicable to every
single case you can think of.

00:32:02.800 --> 00:32:05.360
And we're going to use the model
view matrix as you would normally

00:32:05.360 --> 00:32:06.800
in OpenGL to offset and scale.

00:32:06.800 --> 00:32:08.800
So what that's going to
do is if you want to move,

00:32:08.800 --> 00:32:10.800
if you want to rotate
or move your viewpoint,

00:32:10.800 --> 00:32:15.370
you're going to actually do a translate
or rotate on the model view matrix

00:32:15.370 --> 00:32:17.790
and simply to scale your position.

00:32:17.800 --> 00:32:19.800
So let's hop right into a demo with this.

00:32:19.800 --> 00:32:21.200
this.

00:32:23.090 --> 00:32:25.190
One of the things that
we talked about before,

00:32:25.190 --> 00:32:28.960
at the very beginning,
was I tried to make a plea that says,

00:32:29.050 --> 00:32:32.660
use the power of the video card.

00:32:32.750 --> 00:32:36.030
We get emails, we have discussions,
there's been discussions over years

00:32:36.080 --> 00:32:38.740
and years about how's the best
way to get things to the screen.

00:32:38.740 --> 00:32:42.450
We get requests a lot to say, hey,
can I get access to that frame buffer?

00:32:42.530 --> 00:32:44.730
I want to push pixels to the screen.

00:32:44.730 --> 00:32:48.080
Because I can write a
really fast AlteVec blitter.

00:32:49.210 --> 00:32:52.000
As we showed in the beginning,
and we'll show tomorrow

00:32:52.000 --> 00:32:55.030
at the performance thing,
we're getting 400 to 500 megabytes

00:32:55.080 --> 00:32:57.740
per second across the AGP bus.

00:32:57.770 --> 00:32:59.340
I don't think I couldn't
write that in Blitter.

00:32:59.340 --> 00:33:01.760
I don't think many people
could figure out a way,

00:33:01.760 --> 00:33:03.780
unless they're really working
with the OpenGL drivers or

00:33:03.780 --> 00:33:05.900
working with the graphics drivers,
to actually write a software

00:33:05.900 --> 00:33:07.560
Blitter that does that.

00:33:07.670 --> 00:33:10.660
The second part of that is
your Blitter may be great,

00:33:10.710 --> 00:33:11.860
but it's CPU intensive.

00:33:11.860 --> 00:33:14.590
It is using every ounce of
horsepower of that PowerPC to

00:33:14.630 --> 00:33:17.560
get those pixels to the screen,
because you're touching every pixel,

00:33:17.700 --> 00:33:19.050
whether you're using AlteVec or not.

00:33:19.390 --> 00:33:21.050
This is using the GPU.

00:33:21.220 --> 00:33:23.540
It can use texturing from AGP space.

00:33:23.540 --> 00:33:27.020
So it can actually texture in
a way that the GPU is directly

00:33:27.020 --> 00:33:28.920
DMAing that from your memory.

00:33:28.920 --> 00:33:30.160
So you're not touching it.

00:33:30.380 --> 00:33:33.410
You're not utilizing CPU continuously
to move those pixels around.

00:33:33.870 --> 00:33:37.230
Also,
once the texture's on the graphics card,

00:33:37.240 --> 00:33:39.140
you can see outstanding...

00:33:39.600 --> 00:34:08.800
[Transcript missing]

00:34:09.110 --> 00:34:10.410
So let's take a simple image.

00:34:10.460 --> 00:34:12.410
I just picked a generic image.

00:34:12.410 --> 00:34:15.630
And I'm going to overlap the
textures and use a tiling.

00:34:15.660 --> 00:34:21.460
So, what I'm going to do here is turn
on client memory and AGP memory,

00:34:21.460 --> 00:34:23.700
which John will talk about
in a performance demo.

00:34:23.900 --> 00:34:25.190
I bring this image up.

00:34:25.410 --> 00:34:30.280
And what's interesting here is that this
image actually is in my system memory.

00:34:30.360 --> 00:34:31.080
I have a buffer.

00:34:31.240 --> 00:34:34.430
The graphics card has gone, "Hmm,
you have a buffer.

00:34:34.430 --> 00:34:36.740
You told me that you want to
keep track of that buffer.

00:34:36.740 --> 00:34:38.740
You don't want me to keep
track of the buffer." Okay,

00:34:38.740 --> 00:34:42.710
I'll remap AGP, the point to your buffer,
and you can take care of it.

00:34:42.710 --> 00:34:45.580
So at this point, there's no extra copy
on the graphics card.

00:34:45.750 --> 00:34:49.670
Where the graphics card does the optimal
solution for all cases in this thing.

00:34:49.870 --> 00:34:53.140
We can see if I rotate the image,
I get 700 frames per

00:34:53.140 --> 00:34:54.100
second rotating the image.

00:34:54.100 --> 00:34:58.130
And that's a 400 by 600 image.

00:34:58.130 --> 00:35:01.920
And I can do things like
I can scale and zoom.

00:35:02.070 --> 00:35:04.380
You can go full screen,
I can move the image around,

00:35:04.380 --> 00:35:06.090
and I'm still getting
500 frames per second.

00:35:06.090 --> 00:35:09.800
So we can see that by loading
this into the graphics card,

00:35:10.210 --> 00:35:12.940
You're relying on OpenGL to
do these transformations,

00:35:12.950 --> 00:35:17.010
and these are things that you would have
to work really hard in the CPU to do.

00:35:18.210 --> 00:35:20.300
So let's skip to the little small image.

00:35:20.300 --> 00:35:21.700
That was 400 by 700.

00:35:21.700 --> 00:35:24.300
I mean, that's--anyone can do that.

00:35:24.470 --> 00:35:27.370
Let's bring an image in
that's slightly larger.

00:35:27.840 --> 00:35:31.790
This image right here
is 75 megabytes on disk.

00:35:31.790 --> 00:35:36.970
Actually, let me start it loading,
because it does take a minute to do this.

00:35:38.200 --> 00:35:53.400
[Transcript missing]

00:35:57.900 --> 00:36:03.140
And so that's rotating
at 368 frames per second.

00:36:03.560 --> 00:36:06.060
And you say, nah, that's not a big image.

00:36:06.130 --> 00:36:07.390
That's not that big.

00:36:07.480 --> 00:36:08.380
There's no way I can be doing that.

00:36:08.500 --> 00:36:12.940
So if you were doing this on the GPU,
that's like 36 gigabytes per second

00:36:12.940 --> 00:36:14.140
if you're walking every pixel.

00:36:14.140 --> 00:36:18.640
That's what the pixel-- what the
data throughput you would have to

00:36:18.640 --> 00:36:21.830
average to manipulate the image.

00:36:21.970 --> 00:36:25.580
So how can I prove to you
that it really is that big?

00:36:25.670 --> 00:36:27.420
Oh, let me stop it from rotating.

00:36:27.610 --> 00:36:31.400
That's the image at real size.

00:36:31.820 --> 00:36:33.580
So that's one-to-one image.

00:36:33.860 --> 00:36:37.940
It's 5,900 by 4,400 at 32-bit.

00:36:37.980 --> 00:36:40.700
That is a 100-megabyte
image in this card.

00:36:40.860 --> 00:36:47.760
It's all loaded onto the CPU, scaling,
zooming, dragging, no problems.

00:36:48.450 --> 00:36:58.020
We're at 10% of image size
there to fit it to the screen.

00:37:00.510 --> 00:37:04.470
The key here is that you can
manipulate very large images on

00:37:04.470 --> 00:37:06.930
the GPU without any CPU overhead.

00:37:07.020 --> 00:37:10.260
Actually, I'm going to take a second
to actually do that,

00:37:10.260 --> 00:37:11.140
if I can.

00:37:11.310 --> 00:37:13.830
I'll have to search for the...

00:37:14.940 --> 00:37:16.620
I'm going to bring up the CPU monitor.

00:37:16.850 --> 00:37:21.300
And I have not done this
with this particular image,

00:37:21.390 --> 00:37:23.140
so I have no idea what this will show me.

00:37:23.140 --> 00:37:27.690
But I'm expecting that it will show...

00:37:30.550 --> 00:37:31.700
Okay.

00:37:31.790 --> 00:37:34.980
So we have some mouse moves, but here,
this again, let's zoom into an area,

00:37:34.980 --> 00:37:37.080
well, let's leave it at this size.

00:37:37.200 --> 00:37:40.760
So this is rotating at
400 frames per second.

00:37:40.820 --> 00:37:44.640
There is some CPU overhead.

00:37:44.640 --> 00:37:44.640
Let's, uh...

00:37:49.700 --> 00:37:54.360
Really, we're using maybe half a CPU,
we're using like a full CPU total,

00:37:54.360 --> 00:37:56.790
we're using half the power
of the machine to get,

00:37:56.790 --> 00:38:00.390
you know,
36 gigabytes per second of effective

00:38:00.390 --> 00:38:03.360
data throughput that you would
have to use completely with a CPU.

00:38:03.480 --> 00:38:06.480
So there's definitely a lot of
overhead to do other things here

00:38:06.590 --> 00:38:08.350
other than just rotate the image.

00:38:08.360 --> 00:38:12.350
Let's go back to slides.

00:38:15.180 --> 00:38:16.100
Go ahead and back to slides.

00:38:16.100 --> 00:38:17.940
Thank you.

00:38:18.030 --> 00:38:19.940
So let's talk about planar
textures a little bit.

00:38:20.070 --> 00:38:21.740
So what are planar textures?

00:38:21.860 --> 00:38:23.740
Planar textures are,
instead of chunky pixels,

00:38:23.790 --> 00:38:27.580
which we talked about either
are ARGB or RGBA in the system,

00:38:27.580 --> 00:38:29.720
depending on whether
you're in Carbon or Cocoa,

00:38:29.790 --> 00:38:32.910
these are organized in
a set of red pixels,

00:38:32.930 --> 00:38:35.460
a set of green pixels,
and a set of blue pixels.

00:38:35.560 --> 00:38:39.160
I don't have an image to do that,
so what I've done in the sample program,

00:38:39.160 --> 00:38:40.860
I'll show you in a minute,
is actually when I load it in,

00:38:40.880 --> 00:38:43.010
I split it up,
so there's no way you could pass

00:38:43.090 --> 00:38:45.600
that into anything in the system
right now and actually display it.

00:38:45.600 --> 00:38:48.590
But OpenGL can handle that
very easily in a simple method.

00:38:48.600 --> 00:38:50.600
We're going to do a
multi-pass technique here.

00:38:50.720 --> 00:38:52.850
And I'll show you in the demo that
this really doesn't affect your

00:38:52.960 --> 00:38:57.140
overhead unless you're severely
fill rate limited on your card.

00:38:57.700 --> 00:38:59.970
So first thing,
we're going to use three textures.

00:39:00.070 --> 00:39:02.730
We're going to use a new type of
texture format called GL luminance 8.

00:39:03.010 --> 00:39:07.350
What that says is I'm going to take
that 8-bit representation of red pixels,

00:39:07.490 --> 00:39:10.050
so it's every byte,
and I'm going to use it as a luminance

00:39:10.210 --> 00:39:12.310
value instead of using it as a red value.

00:39:12.420 --> 00:39:15.450
And I'm going to do that for
all three of these textures.

00:39:15.690 --> 00:39:18.270
And when I set up the textures,
I'm going to offset the buffer

00:39:18.350 --> 00:39:20.920
pointer to the start of each plane,
as we did with the slicing.

00:39:21.020 --> 00:39:24.420
I'm going to do this with the three
sections of textures and offset

00:39:24.420 --> 00:39:26.150
the buffer pointer for each one.

00:39:26.550 --> 00:39:28.670
I'm going to bind to the
textures as appropriate and

00:39:28.700 --> 00:39:30.000
draw with a colored polygon.

00:39:30.000 --> 00:39:33.320
So I'm going to use a primary
colored polygon to actually

00:39:33.320 --> 00:39:35.000
colorize what I'm drawing.

00:39:35.000 --> 00:39:38.070
So I'm going to use a bind texture 2D,
the texture name,

00:39:38.070 --> 00:39:40.500
I have three textures there, 0, 1, and 2.

00:39:40.500 --> 00:39:44.500
And in this case alpha, so 0, 1, 2,
and 3.

00:39:44.500 --> 00:39:48.510
I'll use color 4f here to set,
as you see this is in the red case,

00:39:48.610 --> 00:39:52.500
I would have one red, zero green,
zero blue, and one alpha.

00:39:52.500 --> 00:39:57.190
So I'm setting this actually to
completely be red for all the

00:39:57.190 --> 00:39:59.500
areas that are max luminance value.

00:39:59.630 --> 00:40:01.500
And then I'm going to use
what's called a color mask.

00:40:01.500 --> 00:40:03.500
The first layer drawn,
I'll just draw normally,

00:40:03.500 --> 00:40:06.500
I'll draw normally red so it
knocks out all the background.

00:40:06.500 --> 00:40:10.770
But then the color mask says, "Hey,
only draw the pixels that have a value

00:40:10.820 --> 00:40:14.080
that is in that color." So in this case,
if I set it to red,

00:40:14.080 --> 00:40:16.500
I'm only going to draw the
red pixels in the image.

00:40:16.500 --> 00:40:19.500
So even if I have green and blue
pixels that end up in a luminance,

00:40:19.500 --> 00:40:22.500
for example, and have a gray scale value,
they're not going to be drawn.

00:40:22.500 --> 00:40:24.490
So I'm only going to draw
the red component of that.

00:40:24.500 --> 00:40:28.500
So it masks the components,
all the others are passed through.

00:40:29.300 --> 00:40:34.480
So, a simple demo of how to do planar,
doing planar textures.

00:40:42.220 --> 00:40:43.590
Okay, if you notice, that's one layer.

00:40:43.750 --> 00:40:47.100
That's the red layer of
drawing the chameleon,

00:40:47.100 --> 00:40:49.390
still shot of the chameleon.

00:40:50.390 --> 00:40:52.530
So we can easily switch on in this case.

00:40:52.550 --> 00:40:55.210
I added the green layer in,
and added the blue layer,

00:40:55.210 --> 00:40:56.880
and you see the original image.

00:40:56.910 --> 00:41:00.020
Let me zoom out to the window.

00:41:00.160 --> 00:41:03.160
So that's the original
image of the chameleon,

00:41:03.220 --> 00:41:07.130
and by simply telling OpenGL not
to draw certain layers,

00:41:13.120 --> 00:41:17.100
I can get to the full image.

00:41:17.120 --> 00:41:20.040
So that's a simple technique for
using OpenGL for planar images.

00:41:20.100 --> 00:41:22.990
A lot of people get data in planar
images and want to know how to do it.

00:41:23.100 --> 00:41:26.130
So you just use a color mask,
you draw in three separate passes,

00:41:26.360 --> 00:41:26.980
works very well.

00:41:27.190 --> 00:41:28.100
And again, performance.

00:41:28.100 --> 00:41:30.100
How's performance on this?

00:41:33.200 --> 00:41:36.640
330 frames per second,
rotating the image.

00:41:36.640 --> 00:41:38.200
Whole image is up on the graphics card.

00:41:38.430 --> 00:41:40.560
And it's not the fact that we're
doing texture loading here.

00:41:40.560 --> 00:41:41.300
That's not what I want to show.

00:41:41.300 --> 00:41:44.140
What I want to show is that doing the
three passes on this image doesn't

00:41:44.140 --> 00:41:45.980
really fill rate limit this card.

00:41:45.980 --> 00:41:49.240
There are some cases that you could
have an image big enough that three

00:41:49.240 --> 00:41:50.840
passes on this would be a problem.

00:41:50.940 --> 00:41:53.520
But the Windows server, again,
does multiple passes when it needs

00:41:53.520 --> 00:41:54.900
to and uses the same technique.

00:41:54.900 --> 00:41:59.430
There are techniques you can do
to compress this to one pass.

00:41:59.570 --> 00:42:01.980
But with unextended
OpenGL in a simple case,

00:42:01.980 --> 00:42:02.970
this would be the simplest.

00:42:03.110 --> 00:42:03.380
solution.

00:42:03.380 --> 00:42:05.780
Go back to the slides now, please.

00:42:10.500 --> 00:42:12.240
So let's talk about QuickTime VR.

00:42:12.270 --> 00:42:15.570
I'm not going to go into
the infinite detail on this.

00:42:15.580 --> 00:42:18.160
I'm going to have some sample
code up that shows how to do this.

00:42:18.260 --> 00:42:23.620
But basically,
a cube map is six faces of a texture.

00:42:23.680 --> 00:42:27.940
All six faces are connected together:
positive x, positive y, negative x,

00:42:27.940 --> 00:42:30.660
negative y, positive and negative z.

00:42:30.750 --> 00:42:33.300
And it's very similar to a
QuickTime VR cubic texture

00:42:33.350 --> 00:42:35.030
because it has the same faces.

00:42:35.190 --> 00:42:37.640
They're not in quite the same order,
but they're there.

00:42:37.740 --> 00:42:39.910
So what we're going to do to
render a QuickTime VR movie,

00:42:40.020 --> 00:42:42.040
we're going to initialize
and open the VR movie,

00:42:42.270 --> 00:42:47.800
set up the movie and count the frames,
read the VR frames, and in the front,

00:42:47.800 --> 00:42:51.280
right, back, left, top, and bottom,
and then we're going

00:42:51.280 --> 00:42:52.890
to render the cube map.

00:42:53.220 --> 00:42:55.280
There's a lot of code here, and again,
this will be a sample posted.

00:42:55.280 --> 00:42:58.300
But some of the key points,
as you look down here,

00:42:58.300 --> 00:42:59.700
is standard kind of opening movie.

00:42:59.700 --> 00:43:01.580
You're going to get the
track count on the movie.

00:43:01.580 --> 00:43:04.290
You're going to get a media handler
for it as you step through each track.

00:43:04.380 --> 00:43:07.710
And what you're looking for
is the video media track.

00:43:07.760 --> 00:43:12.630
If you notice the QuickTime VR, QTVR,
QTVR type, and the Panorama type,

00:43:12.630 --> 00:43:13.840
we're going to disable those.

00:43:13.840 --> 00:43:15.310
We're looking for the video media type.

00:43:15.450 --> 00:43:16.740
And then what we're
going to do is look for,

00:43:16.740 --> 00:43:18.320
usually there's two video media tracks.

00:43:18.440 --> 00:43:19.840
One is a preview, a very small image.

00:43:19.920 --> 00:43:20.970
One is the normal image.

00:43:20.980 --> 00:43:22.480
So I'm going to look for the largest one.

00:43:23.190 --> 00:43:26.110
Video media track, largest image,
that's the track we're going to look at.

00:43:30.190 --> 00:43:31.800
Now we're going to open the movie.

00:43:31.900 --> 00:43:34.340
So we're going to use whatever
NavKit file or whatever way

00:43:34.340 --> 00:43:36.260
you want to open the movie.

00:43:36.260 --> 00:43:38.470
We're going to open the movie file,
new movie from file,

00:43:38.470 --> 00:43:41.030
we're going to close the movie
file so we have our movie now.

00:43:41.090 --> 00:43:46.100
This is kind of standard QuickTime and
it's in a lot of QuickTime examples

00:43:46.100 --> 00:43:48.140
that you can look this up.

00:43:48.520 --> 00:43:51.300
So now we need to set
up the VR movie here.

00:43:51.390 --> 00:43:53.540
We set the play hints,
we want to get the highest quality.

00:43:53.630 --> 00:43:55.440
We obviously want to get
the natural bounds right,

00:43:55.440 --> 00:43:58.300
because cubic textures
need to be square textures,

00:43:58.300 --> 00:44:01.190
and we need to know the bounds to
appropriately set up our textures.

00:44:01.250 --> 00:44:04.540
So we're going to do that,
set the movie box up to that,

00:44:04.680 --> 00:44:07.340
get the width and height
for storage later.

00:44:07.480 --> 00:44:10.400
We're going to make sure we
know what the texture size is

00:44:10.530 --> 00:44:12.830
and then do the power of two.

00:44:12.840 --> 00:44:15.900
So if we need to do a power
of two change on the movie,

00:44:15.900 --> 00:44:16.400
we'll do that.

00:44:16.400 --> 00:44:19.100
So we'll actually scale it or
whatever into power of two.

00:44:19.190 --> 00:44:21.450
If you add a texture rectangle,
you could also do a non-power

00:44:21.450 --> 00:44:22.300
of two in this case.

00:44:22.400 --> 00:44:23.390
I'm sorry,
you can't do a non-power of two.

00:44:23.390 --> 00:44:25.510
It needs to be power of two.

00:44:26.460 --> 00:44:27.890
So again, you've seen this code before.

00:44:28.100 --> 00:44:28.770
Set the matrix up.

00:44:28.880 --> 00:44:31.500
So we're going to set up a
scaling matrix on this movie.

00:44:31.510 --> 00:44:33.190
And we're going to scale
it to the appropriate size

00:44:33.230 --> 00:44:34.230
as we read each frame in.

00:44:34.960 --> 00:44:38.270
Use a set movie matrix instead of
set the image decompressor matrix.

00:44:39.080 --> 00:44:41.400
And we're going to set up the
off-screen just as we did before.

00:44:41.400 --> 00:44:44.490
I'm not going to include the code here,
but this is the same off-screen setup,

00:44:44.540 --> 00:44:46.900
Qt New GWorld from Pointer,
as you've seen before.

00:44:46.900 --> 00:44:48.700
So you're using that
same kind of routine,

00:44:48.700 --> 00:44:49.510
same technique.

00:44:49.520 --> 00:44:53.640
We're going to set the movie GWorld to
point to that off-screen we just created.

00:44:53.640 --> 00:44:55.960
And the last thing I'm going
to do is check to make sure

00:44:55.960 --> 00:44:56.380
the frame count is correct.

00:44:56.380 --> 00:44:58.300
So we're going to set
the frame count to 6.

00:44:58.720 --> 00:45:01.030
There are cylindrical VRs.

00:45:01.030 --> 00:45:04.450
Those are the VRs you can't really look
all the way up or look all the way down.

00:45:04.460 --> 00:45:06.020
There's an earlier format.

00:45:06.120 --> 00:45:09.420
Most VRs these days are in cubic format,
but you want to make sure

00:45:09.420 --> 00:45:11.110
you have six frames there.

00:45:12.930 --> 00:45:14.170
This is count the frames.

00:45:14.220 --> 00:45:17.750
This actually is a little routine that
the QuickTime folks helped me out with.

00:45:17.820 --> 00:45:21.700
The key here is the middle routine there:
get movie next interesting time.

00:45:21.730 --> 00:45:25.690
A very interesting thing,
but basically that's going to look at

00:45:25.850 --> 00:45:29.250
every time that a frame is being redrawn.

00:45:29.320 --> 00:45:31.390
In this case,
it really doesn't matter what

00:45:31.460 --> 00:45:34.020
the time scale of a cubic VR is,
but there are six frames.

00:45:34.260 --> 00:45:36.460
They are sequenced,
and what you can do with that is you

00:45:36.560 --> 00:45:38.290
can step through interesting times.

00:45:38.300 --> 00:45:40.630
You don't care how far apart they are,
because it's kind of

00:45:40.710 --> 00:45:42.800
arbitrary for QuickTime VR,
but they are going to

00:45:42.800 --> 00:45:43.810
be separated by time.

00:45:44.040 --> 00:45:46.540
And this is what this will do:
move to the next time and

00:45:46.540 --> 00:45:47.900
the next media sample.

00:45:49.500 --> 00:45:53.150
So this is reading the VR frames,
and this is kind of the meat

00:45:53.150 --> 00:45:55.400
of how you do a cubic here.

00:45:55.570 --> 00:45:59.310
As you notice that there's
texture types for negative Z,

00:45:59.320 --> 00:46:01.400
positive X, positive Z, negative X.

00:46:01.690 --> 00:46:08.400
All those are enumerated in the
cubic texture map extension or type.

00:46:08.400 --> 00:46:10.330
So it's not just one type,
it's actually a type for

00:46:10.360 --> 00:46:11.400
each face of that cube.

00:46:11.400 --> 00:46:15.490
What I've done here is modify the
order of these types to be the same

00:46:15.490 --> 00:46:18.400
order as the QuickTime VR stores it.

00:46:18.450 --> 00:46:20.780
And then I take my target and
I'm going to texture into it

00:46:20.940 --> 00:46:22.400
from that buffer that I just got.

00:46:22.400 --> 00:46:23.370
Same code we showed before.

00:46:23.410 --> 00:46:25.400
So all this code kind
of builds on itself.

00:46:25.400 --> 00:46:29.400
And you can use the same code
you used for one thing for this.

00:46:31.030 --> 00:46:33.340
So this is kind of the
get the next frame.

00:46:33.340 --> 00:46:34.560
So we move frame by frame.

00:46:34.560 --> 00:46:35.500
And again, this is the key.

00:46:35.500 --> 00:46:39.300
The meat of this routine is the
movie get next interesting time.

00:46:39.430 --> 00:46:41.010
And we're going to set
the movie time value.

00:46:41.360 --> 00:46:44.560
Calling movie task at the bottom for
all movies is what draws the movie.

00:46:44.560 --> 00:46:48.480
So actually, again,
think of a QuickTime VR as a sequence

00:46:48.480 --> 00:46:53.280
of six frames that actually show you,
or time separated by an arbitrary

00:46:53.280 --> 00:46:55.600
time that you don't care about.

00:46:55.880 --> 00:46:57.630
In this case,
we're going to draw the cube map.

00:46:57.750 --> 00:46:59.190
We're going to draw six faces.

00:46:59.260 --> 00:47:01.220
We're going to draw four
coordinates per face,

00:47:01.380 --> 00:47:04.440
both the texture
coordinate and the vertex,

00:47:04.630 --> 00:47:08.800
and we're going to enable
cubic texture maps before.

00:47:08.800 --> 00:47:12.430
So, this is a little demo of this.

00:47:19.450 --> 00:47:24.640
So this is based on a demo that
was done by NVIDIA a long time ago,

00:47:24.660 --> 00:47:29.640
back in the G4 TNT2 days, I believe,
actually, when this demo was done.

00:47:29.640 --> 00:47:33.190
But the thing we've added here,
I added the QuickTime VR reading to it.

00:47:33.280 --> 00:47:36.090
So you can take any
QuickTime VR and display it.

00:47:36.220 --> 00:47:39.630
So you can see that the performance
of the QuickTime VR is very nice.

00:47:39.750 --> 00:47:41.070
You get very good performance.

00:47:41.140 --> 00:47:44.140
And also, the quality,
you can actually use this in.

00:47:44.140 --> 00:47:49.090
You can see that the quality of
the QuickTime VR is outstanding.

00:47:49.800 --> 00:48:11.100
[Transcript missing]

00:48:12.070 --> 00:48:14.230
is that you can do any QuickTime VR.

00:48:14.240 --> 00:48:17.520
So your content does not
have to be limited to,

00:48:17.540 --> 00:48:20.840
I have to create two special images or
I have to package it up in a special way.

00:48:20.840 --> 00:48:26.520
You can take any QuickTime VR image,
add it in, and you can see that it's a...

00:48:28.360 --> 00:48:31.300
gets reflections on both
sides of the bubble.

00:48:31.350 --> 00:48:35.650
And it's pretty impressive for a very,
very simple technique.

00:48:35.700 --> 00:48:40.660
I mean, this is really simple,
just a few lines of code.

00:48:40.930 --> 00:48:43.140
Back to the slides here.

00:48:48.660 --> 00:48:51.120
So the last thing we're going to
do is build upon these techniques

00:48:51.220 --> 00:48:52.600
and show movie playback.

00:48:52.770 --> 00:48:57.010
This will lead into Ken's discussion
later in the next session,

00:48:57.250 --> 00:48:59.360
which will actually take this
to the next level and tell you

00:48:59.450 --> 00:49:01.600
about optimized movie playback.

00:49:01.600 --> 00:49:05.850
So, you've seen a lot of this before,
so I'm going to kind of skip over

00:49:05.850 --> 00:49:08.390
the parts and just mention them,
the things we've talked

00:49:08.390 --> 00:49:09.600
about and built on already.

00:49:09.600 --> 00:49:11.590
Qt New GWorld from Poynter.

00:49:11.590 --> 00:49:12.150
We've seen that.

00:49:12.150 --> 00:49:13.600
That's going to allocate
your pack to buffer.

00:49:13.600 --> 00:49:17.600
Texture format: the movie can be read
directly into a GWorld.

00:49:17.700 --> 00:49:20.600
Thus, you have a packed pixel format
that you can directly read in.

00:49:20.600 --> 00:49:25.600
We saw that with BGRA reverse
and the 8888 or 1555.

00:49:26.680 --> 00:49:27.910
QuickTime synchronization.

00:49:27.910 --> 00:49:29.480
One thing you need to do with
QuickTime is realize that

00:49:29.580 --> 00:49:32.930
QuickTime needs to draw that frame and
needs to know the interesting time,

00:49:32.930 --> 00:49:34.800
so to speak,
of when that frame was updated.

00:49:34.800 --> 00:49:37.600
In this case, time does matter because
you're playing a movie.

00:49:37.710 --> 00:49:40.010
So,
if a movie is at 20 frames per second,

00:49:40.020 --> 00:49:44.590
you don't want to just start willy-nilly
texturing from whatever buffer you have.

00:49:44.600 --> 00:49:47.020
You would like to limit your
texture uploads to actually

00:49:47.020 --> 00:49:49.600
when QuickTime updates the
frame and has new information.

00:49:49.600 --> 00:49:52.600
So, this is a way to do callback
to synchronize that.

00:49:52.600 --> 00:49:54.560
And drawing lastly, text subimage 2D.

00:49:54.670 --> 00:49:56.580
It's your friend in this case.

00:49:56.630 --> 00:50:00.770
GL text subimage 2D basically says, "Hey,
I updated an area of a texture and

00:50:00.840 --> 00:50:04.580
I want to just upload that texture." So,
in this case,

00:50:04.690 --> 00:50:07.600
the example you're going to see
doesn't use texture rectangle.

00:50:07.600 --> 00:50:11.600
It's a 256 or whatever power
of two texture you want to use.

00:50:11.600 --> 00:50:15.140
And it's only updating the movie
area every movie update frame.

00:50:15.140 --> 00:50:17.610
So, in this case,
it may almost be half of the data

00:50:17.920 --> 00:50:19.840
that you would normally update.

00:50:21.260 --> 00:50:22.700
So, pretty simple.

00:50:22.700 --> 00:50:24.800
I think we've seen almost
exactly the same code.

00:50:24.800 --> 00:50:25.180
Amazing.

00:50:25.190 --> 00:50:26.960
It's the same code again.

00:50:27.080 --> 00:50:28.200
Continue G World from Pointer.

00:50:28.200 --> 00:50:30.800
Make sure you have a
buffer the right size.

00:50:30.900 --> 00:50:31.940
Set the G World.

00:50:32.060 --> 00:50:33.680
In this case,
you also do set movie G World.

00:50:33.770 --> 00:50:36.870
Make sure the movie's
pointing to the right place.

00:50:38.360 --> 00:50:40.290
Hey, I've seen this before too.

00:50:40.290 --> 00:50:42.080
This is exactly the same code.

00:50:42.410 --> 00:50:47.530
Texturing from a buffer in a G world,
you're going to use a

00:50:47.530 --> 00:50:50.330
BGRA format with the two,
depending on 16 or 32 bit,

00:50:50.340 --> 00:50:52.300
depending on what you have.

00:50:53.250 --> 00:50:54.580
So let's talk about
QuickTime synchronization.

00:50:54.580 --> 00:50:56.960
This is the key again for this area.

00:50:57.060 --> 00:50:59.790
You're going to do a movie draw
complete UPP and then you're going

00:50:59.790 --> 00:51:01.500
to take a movie completion proc.

00:51:01.500 --> 00:51:04.810
And what that's going to do is
that's going to basically tell

00:51:04.960 --> 00:51:06.150
you when to update the texture.

00:51:06.160 --> 00:51:10.150
The completion proc in this
case is a movie text update.

00:51:10.660 --> 00:51:12.840
So my movie completion
process is really simple.

00:51:12.970 --> 00:51:15.800
All I'm going to do is take,
set the long RefCon,

00:51:15.800 --> 00:51:19.440
which in this case is my, my,
should I update the texture,

00:51:19.440 --> 00:51:20.360
and set that to true.

00:51:20.360 --> 00:51:22.640
So basically every time
I complete a frame,

00:51:22.690 --> 00:51:24.230
that actually I've
drawn something into it,

00:51:24.240 --> 00:51:26.930
not just, not just,
this is actually a QuickTime frame

00:51:26.930 --> 00:51:29.490
that's actually been drawn,
I'm going to say, hey,

00:51:29.490 --> 00:51:32.740
your textures need to be updated,
or your texture's dirty.

00:51:34.070 --> 00:51:34.580
So how do we draw?

00:51:34.580 --> 00:51:36.940
Looks pretty similar.

00:51:36.940 --> 00:51:38.040
We've seen this before.

00:51:38.040 --> 00:51:43.380
So if I need to update the texture,
I'm going to... I'm sorry.

00:51:43.380 --> 00:51:47.240
If I need to do the texture update,
I'm going to use the text subimage 2D.

00:51:47.240 --> 00:51:49.950
So I'll reset the texture,
and that updates the area that

00:51:49.960 --> 00:51:53.810
the movie is actually updated,
the actual bounds of

00:51:53.810 --> 00:51:54.880
the movie in this case.

00:51:54.930 --> 00:51:56.240
I'm going to use texture
width and texture height.

00:51:56.280 --> 00:52:00.440
And then I'm going to move the frame
wherever I want to move the frame to.

00:52:00.440 --> 00:52:02.770
So I do any of my manipulation,
any of my translation rotation.

00:52:03.200 --> 00:52:06.390
And then I'm going to simply
draw a colored quad that is the

00:52:06.390 --> 00:52:08.040
movie and is textured correctly.

00:52:08.040 --> 00:52:10.860
So let's do the demo.

00:52:16.380 --> 00:52:18.840
So in this case,
I'm going to scale everything to 512x512.

00:52:18.840 --> 00:52:21.340
I'm going to use 800x600
display initially,

00:52:21.340 --> 00:52:23.460
and I'm going to use
a 32-bit back buffer.

00:52:23.520 --> 00:52:25.500
I am going to use
PacPixels as we've shown,

00:52:25.500 --> 00:52:29.200
because if you... all of
Mac OS X uses PacPixels.

00:52:29.300 --> 00:52:33.850
With our previous OS, in a lot of cases,
you had to do an extra texture copy.

00:52:33.910 --> 00:52:37.190
This case, at QuickTime and OpenGL,
can tie in directly to each

00:52:37.190 --> 00:52:41.000
other and can directly texture
from that same piece of memory.

00:52:49.790 --> 00:52:54.440
So what this is, is just a simple movie.

00:52:54.450 --> 00:52:57.240
And you've probably seen
this commercial before.

00:52:57.290 --> 00:53:01.120
Some of the keys here though
are that your texturing,

00:53:01.120 --> 00:53:03.340
if you can't read it,
the upper number in the corner

00:53:03.340 --> 00:53:04.400
tells you frames per second.

00:53:04.460 --> 00:53:06.800
It's about 350 frames per second.

00:53:06.860 --> 00:53:10.880
So OpenGL is drawing full
screen using QuickTime,

00:53:10.930 --> 00:53:15.150
having QuickTime update the movie
into about 500 by 500 texture and

00:53:15.210 --> 00:53:17.500
drawing that at 300 frames per second.

00:53:17.510 --> 00:53:18.720
That's pretty good.

00:53:18.740 --> 00:53:20.260
That's not a bad frame rate.

00:53:20.260 --> 00:53:23.420
I think we can play almost
anything really smoothly.

00:53:24.480 --> 00:53:26.580
One of the keys here, again,
is only update the

00:53:26.580 --> 00:53:27.400
movie when you have to.

00:53:27.400 --> 00:53:29.260
You don't need to update the
movie every time you want to

00:53:29.300 --> 00:53:31.350
draw a-- update the texture every
time you want to draw a frame.

00:53:31.400 --> 00:53:35.470
What I'm going to do here is I'm going
to put kind of a lock on it that says,

00:53:35.470 --> 00:53:37.220
"Hey,
this--I'm going to draw every single

00:53:37.220 --> 00:53:40.650
time I need to draw a frame with OpenGL,
I'm going to upload that

00:53:40.650 --> 00:53:42.810
texture." In this case,
you see it dropped to

00:53:42.880 --> 00:53:44.310
about 80 frames per second.

00:53:44.350 --> 00:53:47.520
So that's the difference between leaving
the texture on the graphics card and

00:53:47.800 --> 00:53:51.300
only manipulating it when you need to,
which--it may not apply to just movies.

00:53:51.400 --> 00:53:55.960
If you have--if you're drawing,
for example, a--a sprite engine that you

00:53:55.960 --> 00:53:59.310
have a set of textures that
don't change frame to frame,

00:53:59.430 --> 00:54:01.400
put them on the graphics
card and leave them there.

00:54:01.400 --> 00:54:03.390
You don't need to upload
them every single time.

00:54:03.400 --> 00:54:04.940
If you do that,
you're going to cut your--cut your

00:54:04.940 --> 00:54:07.390
frame rate because you're dealing
with a bus bandwidth every time.

00:54:07.400 --> 00:54:10.100
In this case,
I went from 300 to 85 frames per

00:54:10.100 --> 00:54:13.160
second just by saying I need to
upload that texture every time.

00:54:13.400 --> 00:54:16.280
And what you can--what
I'm--as another thing,

00:54:16.280 --> 00:54:18.400
I'm going to go to synchronous.

00:54:18.400 --> 00:54:20.710
I think I'm going to go synchronous.

00:54:27.200 --> 00:54:30.230
Okay, oh yeah, there, okay, that's right.

00:54:30.410 --> 00:54:33.610
In this case, I'm synchronous now,
and it's 24 frames per second.

00:54:33.780 --> 00:54:35.700
So that's the native
frame rate of the movie.

00:54:35.700 --> 00:54:36.960
It's playing at 24 frames per second.

00:54:36.960 --> 00:54:39.200
I'm now updating it at
24 frames per second.

00:54:39.290 --> 00:54:40.950
It's not bad,
it's kind of a little chunky.

00:54:41.060 --> 00:54:43.380
But again,
if we take out that synchronicity

00:54:43.380 --> 00:54:47.200
and allow OpenGL to manipulate and
draw every single frame in there,

00:54:47.200 --> 00:54:50.720
and then allow the movie
to update when it needs to,

00:54:50.860 --> 00:54:54.430
you get much smoother animation,
you have a much smoother

00:54:54.610 --> 00:54:55.980
convincing playback.

00:54:56.140 --> 00:54:58.420
And the things that I haven't
shown here as a simple demo,

00:54:58.540 --> 00:55:00.910
things you could do with this,
you can stretch this

00:55:00.910 --> 00:55:02.390
texture around an object.

00:55:02.670 --> 00:55:04.340
You can twist the texture.

00:55:04.400 --> 00:55:07.980
You can put a grid behind this
and twist it in any way you want.

00:55:08.260 --> 00:55:09.800
You can paste it on a wall.

00:55:09.800 --> 00:55:13.450
You can have a control panel in a
game that has a movie play on it.

00:55:13.680 --> 00:55:15.670
And you can just put the
texture in the right place.

00:55:15.700 --> 00:55:16.700
You can do effects with it.

00:55:16.700 --> 00:55:18.430
We talked about
programmability yesterday.

00:55:18.730 --> 00:55:21.800
You can do a sepa-tone
movie with a pixel shader.

00:55:21.930 --> 00:55:23.540
And, I mean,
all these things are possible

00:55:23.690 --> 00:55:24.800
using the power of OpenGL,
integrating it with the graphics.

00:55:24.800 --> 00:55:27.620
You can do effects with OpenGL,
integrating it with QuickTime,

00:55:27.650 --> 00:55:31.640
integrating it with QuickDraw,
with GWorld, integrating it with Cocoa.

00:55:32.250 --> 00:55:33.420
Really simple to do.

00:55:33.520 --> 00:55:35.500
And if you notice,
a little bit of work on this code,

00:55:35.500 --> 00:55:38.990
a little bit of investigation will
yield dividends because you'll

00:55:38.990 --> 00:55:42.330
be able to integrate with almost
all the graphics in Mac OS X.

00:55:44.960 --> 00:55:48.400
Let me bring the slides back up, please.

00:55:48.560 --> 00:55:50.660
So what do you learn about this stuff?

00:55:50.680 --> 00:55:54.530
You learn about it from two books,
from the web, from the tons of examples

00:55:54.570 --> 00:55:55.400
that are out there.

00:55:55.530 --> 00:55:57.060
Two books I'm saying,
if you're working with OpenGL,

00:55:57.060 --> 00:55:58.370
definitely get these two books.

00:55:58.520 --> 00:56:01.060
The red book and the blue book,
they're affectionately called.

00:56:01.060 --> 00:56:04.430
The red book is the programming guide,
and that's kind of a step-by-step,

00:56:04.430 --> 00:56:06.140
let's get introduced to OpenGL.

00:56:06.140 --> 00:56:08.440
Take you through a whole
bunch of different options,

00:56:08.440 --> 00:56:10.260
take you through the
OpenGL end of things,

00:56:10.260 --> 00:56:13.360
where I showed you the kind of the
system integration end of things.

00:56:13.400 --> 00:56:15.400
And the blue book is
just a reference manual.

00:56:15.400 --> 00:56:17.900
The blue book is a reference
manual of every single OpenGL call.

00:56:17.900 --> 00:56:22.990
The blue book covers calls that are
actually in the spec where there is,

00:56:22.990 --> 00:56:26.870
we've shown some extensions today,
the texture rectangle extension

00:56:26.950 --> 00:56:27.900
and some other extensions.

00:56:27.900 --> 00:56:29.090
Those are available on the web.

00:56:29.210 --> 00:56:31.900
The best place to get for extension
is the extension registry,

00:56:31.910 --> 00:56:35.390
which can be accessed via
the OpenGL.org website.

00:56:35.400 --> 00:56:37.400
And that shows you all the extensions.

00:56:37.590 --> 00:56:41.190
Tomorrow's advanced 3D talk
will actually go through all

00:56:41.190 --> 00:56:43.390
the new extensions for Jaguar.

00:56:43.400 --> 00:56:46.860
And you always can get the extension
list just by using some of the

00:56:46.940 --> 00:56:49.400
GL info stuff that we have built in.

00:56:49.700 --> 00:56:53.900
Also, if you're building OpenGL,
we invite you to subscribe

00:56:54.040 --> 00:56:56.400
to the OpenGL mailing list,
list.apple.com.

00:56:56.400 --> 00:56:58.400
You can search for OpenGL and find that.

00:56:58.400 --> 00:57:03.220
And lastly, developer.apple.com/opengl,
where we'll put updates and information

00:57:03.220 --> 00:57:05.210
that we have as it becomes available.

00:57:07.490 --> 00:57:10.240
Okay, so what did we cover?

00:57:10.340 --> 00:57:11.900
OpenGL is not just for 3D.

00:57:11.900 --> 00:57:14.770
OpenGL can be used for 2D,
and as we've shown with the

00:57:14.770 --> 00:57:18.870
accelerated Windows server,
OpenGL makes a great 2D platform

00:57:18.940 --> 00:57:19.960
to build your application on.

00:57:19.960 --> 00:57:24.220
Whether you're displaying data,
showing movies, doing the latest game,

00:57:24.360 --> 00:57:26.430
OpenGL can be the engine behind that.

00:57:26.440 --> 00:57:28.240
You can do all of your data manipulation.

00:57:28.240 --> 00:57:29.950
You can do your hard math.

00:57:30.060 --> 00:57:33.400
You can do your gravitational effects.

00:57:33.400 --> 00:57:35.800
And then when you want to show
that and put it on the screen,

00:57:35.930 --> 00:57:37.380
let OpenGL do a lot of the work for you.

00:57:37.400 --> 00:57:40.190
Because it has a hardware
accelerated GPU behind it,

00:57:40.240 --> 00:57:43.020
which has tremendous power,
more power than you can

00:57:43.020 --> 00:57:45.570
even get out of the CPU,
and it frees up that CPU to

00:57:45.570 --> 00:57:48.670
let you do other things,
other great things with it.

00:57:49.260 --> 00:57:51.110
Sample code will be up on the samples.

00:57:51.110 --> 00:57:52.990
And that's all I got.

00:58:01.190 --> 00:58:02.360
Let me talk about the
roadmap a little bit,

00:58:02.360 --> 00:58:03.540
and then we'll take Q&A.

00:58:03.670 --> 00:58:06.570
Right after this session, in this room,
Ken Dykes is going to take this a

00:58:06.600 --> 00:58:11.940
step further and show you really
how to get to the high horsepower,

00:58:12.050 --> 00:58:16.100
how to really do these things in a very
interesting manner as far as getting

00:58:16.110 --> 00:58:17.940
to max performance and acceleration.

00:58:18.070 --> 00:58:20.600
There's color sync and
digital media later today.

00:58:20.870 --> 00:58:23.370
Tomorrow we have game solutions,
two game solutions.

00:58:23.670 --> 00:58:25.620
And as I mentioned,
in the first game solutions,

00:58:25.730 --> 00:58:27.980
we'll talk more about
using that read pixels,

00:58:28.120 --> 00:58:29.860
saving it to a frame or
saving it to a movie,

00:58:29.860 --> 00:58:32.250
and show you how to get your
OpenGL content out that you

00:58:32.250 --> 00:58:35.270
can put into a movie and send
it off to your best friend.

00:58:36.130 --> 00:58:38.470
That afternoon we have Advanced 3D,
which will talk about

00:58:38.470 --> 00:58:40.810
all the new extensions,
take you through kind of

00:58:40.810 --> 00:58:42.000
deconstructing the Wolfman.

00:58:42.000 --> 00:58:44.890
How did they pull off
the magic in that demo?

00:58:45.080 --> 00:58:47.000
OpenGL Performance and Optimization.

00:58:47.000 --> 00:58:50.000
If you're doing OpenGL,
go to that session.

00:58:50.000 --> 00:58:52.970
We'll show you some new tools that
will really make your life much easier.

00:58:53.000 --> 00:58:57.060
Graphics Imaging and Performance Tuning
Friday and following last

00:58:57.370 --> 00:59:00.000
session of the conference,
come and tell us what you want,

00:59:00.000 --> 00:59:05.000
what you need,
and we'll try and get it into the OS.

00:59:05.850 --> 00:59:08.560
Sergio will come back up and
moderate the questions here,

00:59:08.560 --> 00:59:11.000
and that's his contact information
if you have specific questions

00:59:11.000 --> 00:59:13.550
about our OpenGL implementation.
WEBVTT

00:00:01.880 --> 00:00:03.280
Okay, welcome.

00:00:03.280 --> 00:00:04.400
I'd like to start our next session.

00:00:04.400 --> 00:00:12.160
And it is my pleasure to
introduce Andreas Wenkker.

00:00:20.750 --> 00:00:23.400
So good afternoon, everybody,
and welcome to the last

00:00:23.430 --> 00:00:25.730
WebObjects session for the day.

00:00:25.810 --> 00:00:28.380
My name is Andreas Wendker,
and I'm one of the managers in

00:00:28.380 --> 00:00:30.740
the WebObjects engineering team.

00:00:30.800 --> 00:00:33.940
And in this session,
I would basically like to continue

00:00:33.940 --> 00:00:38.470
what we started in the previous
session and add some more details to

00:00:38.520 --> 00:00:42.260
the information about Java Client.

00:00:43.290 --> 00:00:47.190
So let me just start by summarizing
quickly what Java Client is.

00:00:47.200 --> 00:00:50.620
So Java Client is a very,
very powerful technology to create

00:00:50.820 --> 00:00:53.700
distributed desktop applications.

00:00:53.800 --> 00:00:57.860
And right now, Java Client is based on a
three-tier architecture.

00:00:57.860 --> 00:00:59.970
So that means that for your application,
you have to maintain

00:00:59.970 --> 00:01:00.890
three different pieces.

00:01:00.940 --> 00:01:03.760
You have the client application,
you have a WebObjects

00:01:03.830 --> 00:01:07.510
application that's in the middle,
and you have a database.

00:01:08.140 --> 00:01:09.840
The client is based on Swing.

00:01:09.840 --> 00:01:11.090
It's pure Java.

00:01:11.230 --> 00:01:13.600
It's platform independent,
which is great.

00:01:13.710 --> 00:01:17.500
The communication between the client
and the server is usually HTTP.

00:01:17.670 --> 00:01:20.800
What that really means for you
is that you get the connectivity

00:01:20.800 --> 00:01:24.640
of an HTML-based application,
but you have an opportunity to

00:01:24.660 --> 00:01:27.070
add a much richer user interface.

00:01:28.150 --> 00:01:32.830
What we announced several times earlier
this week is that going forward,

00:01:32.830 --> 00:01:36.060
we're looking at adding
two-tier support to Java Client.

00:01:36.060 --> 00:01:40.030
Tony has asked me to just
spend a couple minutes on that.

00:01:40.050 --> 00:01:43.800
I don't have slides for that,
so I just improvised a little bit.

00:01:43.800 --> 00:01:47.700
I hope it's helpful anyway for you.

00:01:48.080 --> 00:01:52.790
The four topics I wanted to cover
originally was how you can get

00:01:52.790 --> 00:01:55.520
the most out of Interface Builder.

00:01:55.820 --> 00:01:59.920
I wanted to talk about options
when you deploy your client.

00:02:00.020 --> 00:02:02.980
I wanted to talk about some
details of the distribution layer,

00:02:02.980 --> 00:02:04.200
how it really works.

00:02:04.330 --> 00:02:06.900
And then most importantly, I guess,
how you can make these

00:02:06.900 --> 00:02:07.800
applications secure.

00:02:07.800 --> 00:02:12.480
Because you can probably imagine
that with all three-tier systems,

00:02:12.480 --> 00:02:15.120
which have rich clients,
that you open the door for a lot of

00:02:15.120 --> 00:02:17.170
remote method invocations on your server.

00:02:17.180 --> 00:02:19.880
And knowing how to make it
secure is quite important.

00:02:20.030 --> 00:02:23.420
Before I go into these topics,
I will just talk quickly

00:02:23.550 --> 00:02:25.700
about the two-tier support.

00:02:30.400 --> 00:02:34.360
What we do in Java Client
is that we have a full

00:02:34.360 --> 00:02:36.800
EUF environment on the client side.

00:02:36.830 --> 00:02:39.400
So we have an EU control layer
where your business logic lives,

00:02:39.400 --> 00:02:42.840
we have an interface layer,
and we have a database access layer,

00:02:42.900 --> 00:02:44.530
or something like that.

00:02:44.640 --> 00:02:48.670
The one that you're usually used to
use on the server side is EU access.

00:02:48.820 --> 00:02:52.150
That's the object-relational
mapping layer that goes and

00:02:52.150 --> 00:02:55.380
generates the SQL for you,
talks to the database,

00:02:55.390 --> 00:02:59.410
and then maps the raw data from
the database into business objects.

00:02:59.630 --> 00:03:03.970
And on the client side, in Java Client,
we use a layer that is actually very

00:03:03.970 --> 00:03:06.360
similar from the API perspective.

00:03:06.410 --> 00:03:09.200
But instead of talking to a database,
it goes and talks to the

00:03:09.200 --> 00:03:12.470
WebObjects application server,
and then fetches the objects

00:03:12.470 --> 00:03:14.510
through the application server.

00:03:14.680 --> 00:03:15.790
So that's the three-tier system.

00:03:15.800 --> 00:03:20.940
And the problem with that is,
I think it's a great technology,

00:03:20.940 --> 00:03:23.240
and it's very useful if
you care about security.

00:03:23.310 --> 00:03:25.150
So if you have a fairly
distributed environment,

00:03:25.150 --> 00:03:28.360
you have potentially end users
that are outside your own company,

00:03:28.360 --> 00:03:32.680
then the three-tier system gives
you all the necessary hooks to

00:03:32.680 --> 00:03:35.180
make the application still secure.

00:03:35.180 --> 00:03:37.830
Because the application server
in the middle is the one that

00:03:37.830 --> 00:03:39.590
controls the access to the database.

00:03:39.660 --> 00:03:44.380
And none of the clients can
access the database directly.

00:03:44.500 --> 00:03:47.370
So it's a very secure layer,
or architecture.

00:03:47.380 --> 00:03:51.010
But the downside of it is that
there's obviously this additional

00:03:51.010 --> 00:03:53.420
communication you have to go through.

00:03:53.420 --> 00:03:56.170
And so you might see some performance...

00:03:57.420 --> 00:04:06.630
The Java Client is incredibly fast.

00:04:06.970 --> 00:04:09.600
It's the fastest three-tier
architecture I've ever seen.

00:04:09.730 --> 00:04:12.050
But still,
having this additional layer in

00:04:12.050 --> 00:04:13.950
the middle might be problematic.

00:04:14.000 --> 00:04:18.120
So going two-tier will allow
you to write applications that

00:04:18.120 --> 00:04:20.340
have faster response times.

00:04:20.370 --> 00:04:24.210
And also the second item or issue we
will address with two-tier is that

00:04:24.300 --> 00:04:26.890
your administration gets much simpler.

00:04:26.900 --> 00:04:27.060
Instead of having to
write a single layer,

00:04:27.080 --> 00:04:27.280
you can write a whole new layer.

00:04:27.280 --> 00:04:27.280
So it's a very, very simple process.

00:04:27.280 --> 00:04:29.140
Instead of having to
maintain three pieces,

00:04:29.230 --> 00:04:31.090
now you just have to
worry about two pieces.

00:04:31.090 --> 00:04:34.620
You just write one set of business logic,
not two sets, those kind of things.

00:04:34.620 --> 00:04:37.960
So I'd like to give a quick demo,
so if you could switch

00:04:38.120 --> 00:04:39.660
to the demo one machine.

00:04:39.660 --> 00:04:40.810
Okay.

00:04:46.100 --> 00:04:52.000
Basically what I thought doing
is create two projects for you.

00:04:52.100 --> 00:04:55.000
One with the three-tier system
and one with the two-tier system.

00:04:55.000 --> 00:04:56.910
And I'll show you that they,
from the client perspective,

00:04:57.000 --> 00:04:59.000
really look the same.

00:04:59.000 --> 00:05:02.990
And then maybe go through the
differences in the project.

00:05:03.130 --> 00:05:07.120
So let me start by creating a
direct-to-Java client application,

00:05:07.120 --> 00:05:09.000
which is the old three-tier setup.

00:05:09.280 --> 00:05:13.000
And I'll just give it a name.

00:05:13.740 --> 00:05:16.060
These are the usual WebObjects questions.

00:05:16.130 --> 00:05:18.720
I will add our Java real
estate framework that we use

00:05:18.720 --> 00:05:20.490
throughout the conference here.

00:05:26.800 --> 00:05:33.360
This is a fairly usual
WebOptics application.

00:05:33.360 --> 00:05:35.700
It has an application class,
it has a session class,

00:05:35.700 --> 00:05:39.340
it has a direct action class,
just the normal template.

00:05:39.340 --> 00:05:44.440
I'll talk about that later.

00:05:44.440 --> 00:05:48.200
It's building the project right now,
and then it will start the client.

00:05:50.400 --> 00:05:55.150
This is the client setting up right now.

00:05:55.210 --> 00:05:57.200
And that's the application it generates,
and I think you've seen

00:05:57.200 --> 00:05:59.900
that in the session before,
or otherwise last year.

00:05:59.960 --> 00:06:06.780
So let me now go ahead and
create another project,

00:06:06.780 --> 00:06:08.300
which is a direct-to-swing application.

00:06:08.300 --> 00:06:10.750
Also, this is the two-tier setup.

00:06:13.700 --> 00:06:26.700
[Transcript missing]

00:06:36.570 --> 00:06:38.620
I need to find my frameworks here.

00:06:38.650 --> 00:06:39.620
Is this error tree?

00:06:39.620 --> 00:06:45.580
One second.

00:06:48.930 --> 00:06:53.340
I refined it.

00:06:53.340 --> 00:06:55.960
So I'll just add the model directly.

00:06:55.990 --> 00:06:57.210
And then again,
if you ask me whether I want to

00:06:57.210 --> 00:07:04.280
build and launch the project now,
we'll do that.

00:07:04.300 --> 00:07:06.750
And then we'll start the application.

00:07:16.330 --> 00:07:18.210
And this is what you get.

00:07:18.230 --> 00:07:23.600
So from the client perspective here,
the applications really

00:07:23.600 --> 00:07:24.830
behave exactly the same.

00:07:24.860 --> 00:07:29.900
So you can perform your
searches the normal way.

00:07:29.920 --> 00:07:33.500
Everything is the same.

00:07:33.500 --> 00:07:35.510
You can open this,
look at some details for listing.

00:07:35.510 --> 00:07:37.860
I can do the same with
the two-tier client.

00:07:40.510 --> 00:07:43.460
Andreas Wenkert,
and you will see it really behaves

00:07:43.460 --> 00:07:46.060
identically from the user perspective.

00:07:46.310 --> 00:07:50.470
So what we really do is we really just
switch one part of the architecture.

00:07:50.600 --> 00:07:53.640
We just switch the distribution layer,
which usually goes and talks

00:07:53.720 --> 00:07:56.330
to the WebObjects application
server to get the data.

00:07:56.340 --> 00:08:00.640
We swap it out to use uAccess that
talks directly to the database.

00:08:00.740 --> 00:08:02.390
And everything else is actually the same.

00:08:02.400 --> 00:08:05.870
So including the root system,
which we use for direct-to-Java Client,

00:08:05.870 --> 00:08:09.330
and that's why these applications
really just look the same way.

00:08:10.950 --> 00:08:14.520
You can use interface files, Nib files,
if you don't want to use

00:08:14.670 --> 00:08:16.930
direct-to-Java Client,
you can do all that

00:08:17.010 --> 00:08:18.430
in both architectures.

00:08:18.440 --> 00:08:21.180
The same Nib file will actually
work for a two-tier application

00:08:21.240 --> 00:08:22.840
and a three-tier application.

00:08:27.110 --> 00:08:30.930
Even something like having a setup
where you have a local database

00:08:31.290 --> 00:08:35.700
and you have another database
somewhere running in your company,

00:08:35.700 --> 00:08:39.120
and you want to talk to the local
database if you're not in the network,

00:08:39.120 --> 00:08:42.880
but you want to talk to the
large company-wide database

00:08:42.880 --> 00:08:44.850
if you're in the network.

00:08:45.260 --> 00:08:47.360
Something like that is certainly
possible that you basically

00:08:47.500 --> 00:08:49.950
just check at startup time,
am I connected right now or not,

00:08:49.950 --> 00:08:52.590
and then you just choose either
EU distribution or EU access.

00:08:53.250 --> 00:08:57.000
So this is all possible,
and from the level up, EU control,

00:08:57.000 --> 00:08:59.920
EU interface, EU application,
EU generation, all these layers,

00:08:59.920 --> 00:09:01.930
the functionality will
really be the same.

00:09:01.940 --> 00:09:03.680
Your code will work
in both architectures.

00:09:05.170 --> 00:09:09.380
So that's basically everything I wanted
to say about the two-tier stuff.

00:09:09.600 --> 00:09:13.060
Can I just see kind of a show of
hands whether that's approximately

00:09:13.070 --> 00:09:15.340
what you guys expected,
or do you want me to talk

00:09:15.340 --> 00:09:18.120
more about that right now,
or shall we just wait

00:09:18.120 --> 00:09:19.920
for question and answers?

00:09:19.920 --> 00:09:22.950
Yes, okay.

00:09:32.900 --> 00:09:33.300
Right.

00:09:33.330 --> 00:09:35.630
So the question was,
we have two different project types here,

00:09:35.640 --> 00:09:39.920
and the question is whether we can
basically make this a runtime check,

00:09:40.090 --> 00:09:41.000
whether it's two-tier, three-tier.

00:09:41.000 --> 00:09:43.130
Yes, technology-wise, that would work.

00:09:43.190 --> 00:09:45.390
Project builder-wise,
we would probably not

00:09:45.390 --> 00:09:46.860
support that out of the box.

00:09:46.860 --> 00:09:49.660
So you would have to do a
little bit of setup by hand,

00:09:49.700 --> 00:09:52.560
because I don't think it's
going to be very common.

00:09:52.560 --> 00:09:55.130
But technology-wise, that should work.

00:09:56.110 --> 00:10:01.040
Okay, so I suggest that then if
you go back to the slides,

00:10:01.040 --> 00:10:04.190
I would just continue with my
presentation and then maybe

00:10:04.190 --> 00:10:08.640
we can cover a little more at
the end in the Q&A section.

00:10:08.640 --> 00:10:12.860
So I have to turn this around.

00:10:15.400 --> 00:10:21.090
Now, Besity talked about that.

00:10:21.180 --> 00:10:25.380
So now I have to play
around a little bit.

00:10:25.380 --> 00:10:25.380
Sorry.

00:10:25.820 --> 00:10:29.500
So I wanted to start out by
explaining some more details,

00:10:29.510 --> 00:10:32.200
or by talking a little more
about interface builder.

00:10:32.200 --> 00:10:35.370
So the two ways you can
generate user interfaces for

00:10:35.400 --> 00:10:39.610
Java Client are direct-to-Java
Client and interface files.

00:10:39.710 --> 00:10:41.700
Direct-to-Java Client is rule-based,
code-free.

00:10:41.700 --> 00:10:44.960
We recommend this as the default way,
or as your starting point, at least,

00:10:44.960 --> 00:10:47.840
for the development process,
because it just saves you a lot of time.

00:10:47.840 --> 00:10:48.690
It's much easier.

00:10:48.730 --> 00:10:51.420
You make progress much faster.

00:10:51.580 --> 00:10:56.480
We understand that the default
applications won't give you the

00:10:56.530 --> 00:11:00.090
polished application that you
want to deploy to your customers,

00:11:00.090 --> 00:11:02.080
so we have a bunch of
customization techniques.

00:11:02.180 --> 00:11:05.190
One of these customization techniques
is using Interface Builder and

00:11:05.190 --> 00:11:06.900
creating interface files by hand.

00:11:07.000 --> 00:11:10.700
If you don't like the root system at all,
you can also just create an application

00:11:10.700 --> 00:11:15.880
just using Interface Builder and not
using any of the dynamic UI generation.

00:11:16.300 --> 00:11:18.290
But a question that we
hear quite common is,

00:11:18.360 --> 00:11:20.830
why in the world are you
guys using Interface Builder?

00:11:21.070 --> 00:11:23.200
Because it doesn't do swing, right?

00:11:23.200 --> 00:11:26.760
Interface Builder is a tool that you
can use to create Cocoa applications

00:11:26.790 --> 00:11:30.100
and maybe Carbon applications,
but it's not generating swing libfiles.

00:11:30.100 --> 00:11:34.510
The answer to that is actually not easy.

00:11:34.680 --> 00:11:41.450
The answer is that, unfortunately,
to automate the user interfaces and to do

00:11:41.450 --> 00:11:45.480
all the work that EOF is doing for you,
we need very rich connections.

00:11:45.500 --> 00:11:49.370
The connections are called associations,
and they are really

00:11:49.370 --> 00:11:51.260
multi-aspect connections.

00:11:51.310 --> 00:11:55.500
For one widget, it's not just a point,
an outlet to something else.

00:11:55.500 --> 00:11:58.900
There are multiple aspects to it,
what kind of value you want to show,

00:11:59.230 --> 00:11:59.900
and which condition you want to show.

00:11:59.900 --> 00:11:59.900
So, for example,
if you have a project that's

00:11:59.900 --> 00:11:59.900
running on a Java project,
and you want to show it to a user,

00:11:59.900 --> 00:11:59.900
you can show it to a user,
and then you can show it to a user.

00:11:59.900 --> 00:12:03.180
you want to enable or
disable that widget,

00:12:03.240 --> 00:12:06.110
what kind of colors you want to use,
whether you want to highlight

00:12:06.160 --> 00:12:09.220
it with a certain color,
the text, something like that.

00:12:09.220 --> 00:12:12.500
And InterfaceBuilder, unfortunately,
is still the only tool

00:12:12.500 --> 00:12:16.070
available to us that allows to
create these rich connections.

00:12:16.230 --> 00:12:20.480
There's really no other GUI editor
in the Java world that allows

00:12:20.490 --> 00:12:23.280
us to do these connections.

00:12:23.500 --> 00:12:26.270
If you find one, let me know.

00:12:26.270 --> 00:12:26.270
Until then, we

00:12:26.540 --> 00:12:28.770
Interface Builder is actually
not a bad choice for us,

00:12:28.800 --> 00:12:31.910
especially since we can leverage what
we do for the Cocoa integration as well.

00:12:33.940 --> 00:12:39.330
I'd actually like to ask Norbert
to come up on stage and quickly

00:12:40.100 --> 00:12:45.090
give a demonstration of that so
that we can see some more details.

00:12:53.160 --> 00:12:55.990
So what Norbert will do for us is
he will create an application that

00:12:56.000 --> 00:12:58.600
doesn't use direct-to-Java Client,
just an interface file.

00:12:58.600 --> 00:13:01.290
We have an assistant for that in
Project Builder to create a new project.

00:13:01.340 --> 00:13:03.910
We enter a name.

00:13:06.740 --> 00:13:10.380
These are the standard
questions that we always get.

00:13:10.420 --> 00:13:14.950
Here we are also at the
Java Real Estate Business Logic Framework

00:13:14.950 --> 00:13:14.950
.

00:13:16.360 --> 00:13:18.890
And then what's different to the
assistant that we saw before is that

00:13:19.010 --> 00:13:22.130
he had asked for a class name for a
so-called interface controller class.

00:13:22.200 --> 00:13:23.440
I will talk about that in a second.

00:13:26.300 --> 00:13:27.560
These are just the same questions.

00:13:27.560 --> 00:13:31.330
And then here it gets different.

00:13:31.340 --> 00:13:36.690
So when we create Nib files,
Project Builder basically gives

00:13:36.690 --> 00:13:39.260
us an assistant that helps with
the most common cases where we

00:13:39.370 --> 00:13:42.460
create something like simple
tables or master detail interfaces.

00:13:42.480 --> 00:13:46.560
So what Norbert will do is, I think,
choose the listing entity as the

00:13:46.560 --> 00:13:50.540
master table or master entity,
and choose a couple of properties

00:13:50.540 --> 00:13:53.740
to be displayed in this table,
like the listing number,

00:13:53.740 --> 00:13:55.450
maybe the asking price.

00:13:57.420 --> 00:14:04.620
The system will ask for some form fields.

00:14:04.620 --> 00:14:07.890
The first question was about what
kind of properties to use for a table,

00:14:08.000 --> 00:14:11.690
and then we create form
fields for us as well.

00:14:14.360 --> 00:14:18.050
And then it will ask us for
master detail relationship,

00:14:18.050 --> 00:14:20.520
and then what kind of properties for
the detail relationship to display.

00:14:20.520 --> 00:14:24.210
So we just choose the last name and
the first name of all the customers.

00:14:26.270 --> 00:14:27.700
And that's it.

00:14:27.790 --> 00:14:32.140
So as you can see,
the assistant generated a

00:14:32.260 --> 00:14:35.040
project with a Nib file.

00:14:35.040 --> 00:14:41.490
And this is the Nib file it generated,
so I'll just make that

00:14:41.490 --> 00:14:44.560
a little more pretty.

00:14:53.150 --> 00:14:56.620
Save that, and then we will, I guess,
build the project and run it.

00:14:56.700 --> 00:15:05.040
So one thing that is interesting
about the assistant is that,

00:15:05.250 --> 00:15:08.430
together with the interface file,
it actually generated a Java class,

00:15:08.510 --> 00:15:10.940
which is a so-called
EO Interface Controller subclass.

00:15:10.960 --> 00:15:14.240
And that's basically a class that
is there for your convenience.

00:15:14.240 --> 00:15:15.380
It makes it very easy.

00:15:15.380 --> 00:15:17.910
It's a very easy entry
point in your source code,

00:15:17.910 --> 00:15:21.500
how you can load the interface file
and then to play around with it.

00:15:22.580 --> 00:15:26.500
So, nobody's running the
application there right now.

00:15:29.780 --> 00:15:33.370
So this is the application running,
and what we wanted to do is basically

00:15:33.370 --> 00:15:37.730
overlay that with the file we
created in Interface Builder,

00:15:37.790 --> 00:15:41.420
and then show you how this
translation works from Cocoa to

00:15:41.420 --> 00:15:43.700
Swing that we performed for you.

00:15:43.700 --> 00:15:47.170
So basically what Norbert is doing
there right now is he's showing

00:15:47.240 --> 00:15:51.070
you the file in Interface Builder
on top of the running application,

00:15:51.070 --> 00:15:52.920
and the file in Interface
Builder is Cocoa,

00:15:52.920 --> 00:15:55.030
and the application in
the background is Swing.

00:15:55.300 --> 00:15:58.060
So as you can see,
it overlaps pretty well, and yeah,

00:15:58.060 --> 00:16:00.300
so that's basically
all we wanted to show.

00:16:00.300 --> 00:16:01.920
Thank you, Norbert.

00:16:01.980 --> 00:16:08.950
Okay, if you could go back to the slides.

00:16:14.900 --> 00:16:19.470
So this interface file
translation from Swing to Cocoa,

00:16:19.470 --> 00:16:22.080
as you saw, works pretty well.

00:16:22.150 --> 00:16:25.980
But unfortunately, it only works well for
the pieces that we expect.

00:16:26.030 --> 00:16:28.930
It works well for all the
standard widgets that we deal

00:16:29.040 --> 00:16:32.820
with in the EU interface layer,
like tables, text fields, buttons,

00:16:32.820 --> 00:16:34.220
those kind of things.

00:16:34.340 --> 00:16:37.480
The Nib first installation doesn't
do a very good job when it comes

00:16:37.480 --> 00:16:41.010
to additional widgets that we don't
support by default in EU interface.

00:16:41.010 --> 00:16:43.220
We just basically ignore those things.

00:16:43.220 --> 00:16:46.700
And also, Swing and Cocoa don't
always match perfectly.

00:16:46.700 --> 00:16:49.030
So some of the aspects
that you can adjust in,

00:16:49.090 --> 00:16:52.820
some of the parameters you can adjust
in Interface Builder don't make it into

00:16:53.050 --> 00:16:55.440
the Swing version of the interface file.

00:16:55.440 --> 00:16:59.900
And I wanted to give you a couple of
tips that you can use to work with the

00:16:59.900 --> 00:17:02.610
interface files and get more out of it.

00:17:02.700 --> 00:17:07.350
So, what you should know is that
there's basically a method on

00:17:07.360 --> 00:17:10.560
the EU Interface Controller class
which is called LoadArchive.

00:17:10.600 --> 00:17:14.000
And LoadArchive is the method that
triggers loading an interface file.

00:17:14.000 --> 00:17:18.070
The good news for you is that you
don't ever have to invoke that.

00:17:18.100 --> 00:17:21.070
It's done for you, well,
there's one case where you might want to.

00:17:21.080 --> 00:17:24.040
But in the normal case,
you don't invoke this method.

00:17:24.040 --> 00:17:26.870
It's done for you automatically
whenever this interface controller

00:17:26.870 --> 00:17:29.280
is integrated into the application.

00:17:29.280 --> 00:17:31.400
It's asked to basically show
the window on the screen.

00:17:31.400 --> 00:17:33.440
And if you trigger that,
it'll automatically for you.

00:17:35.100 --> 00:17:39.740
But the methods that are interesting
for you are two additional methods.

00:17:39.760 --> 00:17:42.600
One is controllerDidLoadArchive,
and it's there right now.

00:17:42.600 --> 00:17:45.000
And in the next release,
we are planning to add another method,

00:17:45.000 --> 00:17:46.940
which is controllerWillLoadArchive.

00:17:47.060 --> 00:17:49.310
controllerDidLoadArchive,
as the name says,

00:17:49.400 --> 00:17:52.070
is invoked after the libfile
loading is completed,

00:17:52.070 --> 00:17:54.960
and willLoadArchive will
be invoked right before.

00:17:55.410 --> 00:18:00.190
This is useful for you if you basically
want to start an interface builder,

00:18:00.350 --> 00:18:03.340
create all the common
widgets like tables,

00:18:03.370 --> 00:18:07.690
text fields, buttons, what I just listed,
and then basically programmatically

00:18:07.710 --> 00:18:09.100
complete this Nib file.

00:18:09.100 --> 00:18:12.910
We find that interface builder,
even if it doesn't cover maybe

00:18:12.910 --> 00:18:16.990
100% of your user interface needs,
it will still be a great

00:18:17.290 --> 00:18:20.100
starting point for you,
as long as we cover it in

00:18:20.100 --> 00:18:21.840
our Nib file translation.

00:18:23.680 --> 00:18:27.090
So with these two methods here,
you will be able to then take an

00:18:27.300 --> 00:18:31.520
interface that is at least close
to be 100% of your user interface,

00:18:31.520 --> 00:18:34.080
and then programmatically customize that.

00:18:34.080 --> 00:18:37.740
What you would typically do is you
would probably search for some objects

00:18:37.740 --> 00:18:41.290
that you loaded from the Nib file,
and then send some methods to it to maybe

00:18:41.320 --> 00:18:43.280
change colors or certain parameters.

00:18:43.280 --> 00:18:47.540
Or sometimes you might place
something like a placeholder view,

00:18:47.540 --> 00:18:52.600
just an empty view inside your interface
file to basically mark a position,

00:18:52.860 --> 00:18:54.540
and then add additional views in there.

00:18:54.540 --> 00:18:58.470
So if you want to integrate a swing
view that somebody wrote that is not

00:18:58.820 --> 00:19:01.880
covered by our Nib file translation,
you just place an empty view

00:19:01.880 --> 00:19:03.640
somewhere in the Nib file,
say this is the position,

00:19:03.640 --> 00:19:04.530
the size it should be.

00:19:04.540 --> 00:19:06.810
Then at runtime,
you would load that Nib file,

00:19:06.810 --> 00:19:09.800
look for this empty view,
and place your own view inside.

00:19:09.800 --> 00:19:14.680
And the two ways that you can
use to identify objects are

00:19:14.680 --> 00:19:17.320
outlets and named objects.

00:19:17.400 --> 00:19:20.120
So outlets is basically a name
that comes from the Cocoa word,

00:19:20.120 --> 00:19:22.730
and outlet is basically a
reference to another object.

00:19:22.960 --> 00:19:25.730
So what you would do is typically
on your EU interface class,

00:19:25.850 --> 00:19:29.200
you would create an instance variable,
and then you would connect

00:19:29.200 --> 00:19:31.480
that in Interface Builder,
and you would say this

00:19:31.480 --> 00:19:33.400
is my placeholder view,
and then while the

00:19:33.400 --> 00:19:36.070
interface file is loaded,
this reference is filled in,

00:19:36.140 --> 00:19:40.520
and then in Control-Edit Load Archive,
you can add your own views to it.

00:19:40.560 --> 00:19:43.840
And the other way you have to
identify objects is to give it a name.

00:19:43.840 --> 00:19:47.630
Interface Builder allows you to
provide names for some of the objects,

00:19:47.630 --> 00:19:49.920
not for every object,
but typically for all the

00:19:49.920 --> 00:19:52.670
objects in the file window,
like display groups, editing context,

00:19:53.110 --> 00:19:54.770
the windows itself.

00:19:54.930 --> 00:19:56.630
So for those,
you can specify a name in the

00:19:56.650 --> 00:19:59.520
Inspector in Interface Builder,
and then we actually provide you a

00:19:59.520 --> 00:20:04.100
dictionary of all the named objects as
an argument to Control-Edit Load Archive.

00:20:04.100 --> 00:20:11.170
So outlets and giving it a name are ways
to identify the objects in the archive.

00:20:11.500 --> 00:20:14.980
Another thing that might be interesting
to use is that these two methods,

00:20:14.980 --> 00:20:17.590
or this API,
should also allow you to plug in other

00:20:17.590 --> 00:20:19.410
GUI editors if you really want to.

00:20:19.420 --> 00:20:23.460
So there are various tools out
there for swing that usually

00:20:23.460 --> 00:20:26.880
do source code generation,
so you can use that to place

00:20:26.920 --> 00:20:29.340
buttons and text fields,
all this stuff.

00:20:29.360 --> 00:20:31.760
They usually don't offer
you to do these connections.

00:20:31.760 --> 00:20:34.800
You will not be able to create
associations in these GUI editors.

00:20:34.940 --> 00:20:37.830
But if you prefer that over
using interface builder and

00:20:37.830 --> 00:20:40.940
the Nib for translation,
use those tools and then use these

00:20:41.100 --> 00:20:44.600
methods to plug those user interfaces
into your controllers and then

00:20:44.600 --> 00:20:45.860
create the associations by hand.

00:20:45.860 --> 00:20:47.820
It's really up to you
what you want to choose.

00:20:53.170 --> 00:20:56.370
So once you've created your application
and you want to go into deployment,

00:20:56.380 --> 00:20:58.100
there are a couple of
things you should know.

00:20:58.100 --> 00:21:02.100
First of all, the only requirement that
we have is just J2SE,

00:21:02.100 --> 00:21:06.090
the standard edition, 1.3.1, and up.

00:21:06.330 --> 00:21:08.540
If you're one of the
lucky users of Mac OS X,

00:21:08.540 --> 00:21:12.290
then that's the version that's
integrated into Mac OS X right now.

00:21:12.300 --> 00:21:15.620
Otherwise,
you're obviously downloaded from Sun.

00:21:15.620 --> 00:21:17.660
But J2SE is the only
requirement that we have.

00:21:17.720 --> 00:21:23.880
And there are basically two options
for you to deploy right now.

00:21:23.880 --> 00:21:26.160
One is you create a little
desktop application,

00:21:26.160 --> 00:21:29.140
which means that you create a
little start program and put

00:21:29.170 --> 00:21:33.220
all your classes in a Java file,
pre-install it on the client machine,

00:21:33.220 --> 00:21:35.830
and then the user can
start it per double-click.

00:21:36.430 --> 00:21:38.930
And the other way is
to run it as an applet,

00:21:38.930 --> 00:21:42.980
so then the application is embedded
in an HTML page and the user

00:21:43.040 --> 00:21:44.540
runs it from inside the browser.

00:21:44.540 --> 00:21:48.000
Let me compare these two
options for you quickly.

00:21:50.600 --> 00:21:54.560
So the biggest advantage of
Applets is really how easy the

00:21:54.570 --> 00:21:59.250
simplicity of the installation
and potentially upgrading process,

00:21:59.330 --> 00:22:00.680
because there is no such process.

00:22:00.680 --> 00:22:04.840
When Applets starts up,
they always download all the classes

00:22:04.840 --> 00:22:09.340
they need to this client machine,
and then the program is executed there.

00:22:09.340 --> 00:22:11.830
And when the application is
quit or the browser quits,

00:22:11.830 --> 00:22:13.800
the classes are basically thrown away.

00:22:13.800 --> 00:22:15.610
And the next time the
application starts up,

00:22:15.610 --> 00:22:16.790
it downloads them again.

00:22:16.800 --> 00:22:19.750
Which means that if you deploy
a new version in the meantime,

00:22:19.880 --> 00:22:23.170
it will automatically download
this latest version for you.

00:22:23.480 --> 00:22:25.970
The desktop applications are
unfortunately not that easy because you

00:22:26.120 --> 00:22:28.100
have to create a little startup program.

00:22:28.180 --> 00:22:31.740
You have to pre-install these
classes on the client machine.

00:22:31.740 --> 00:22:34.190
So in the worst case,
if you can't control

00:22:34.190 --> 00:22:36.650
your user base very well,
you might even have to deal with

00:22:36.770 --> 00:22:38.450
multiple client versions out there.

00:22:38.490 --> 00:22:41.540
So that's the biggest
disadvantage of applications.

00:22:41.620 --> 00:22:44.080
There's one interesting thing
that we introduced in the last

00:22:44.170 --> 00:22:45.750
release in WebObjects 5.1.

00:22:45.960 --> 00:22:49.190
We now provide you a class loader.

00:22:49.550 --> 00:22:55.190
We're just able to download all the
application-specific classes that you

00:22:55.240 --> 00:22:57.160
write yourself to desktop applications.

00:22:57.160 --> 00:23:02.290
So what this allows you to do is
basically deploy the UF-based system,

00:23:02.290 --> 00:23:02.290
which

00:23:02.300 --> 00:23:28.500
[Transcript missing]

00:23:31.790 --> 00:23:34.840
But then,
once the application is started up,

00:23:34.840 --> 00:23:39.800
from the user perspective,
the performance of applications

00:23:39.800 --> 00:23:41.960
is much better than for applets.

00:23:42.070 --> 00:23:43.870
First of all,
obviously the startup time is much

00:23:43.870 --> 00:23:47.040
shorter because the classes are
already present on the client side.

00:23:47.140 --> 00:23:50.220
And then you will also find that it
runs a little bit faster because there's

00:23:50.220 --> 00:23:53.060
usually no security manager in place,
and browsers don't do their

00:23:53.060 --> 00:23:54.230
own thing with the applets.

00:23:54.280 --> 00:23:56.070
So it really runs a little bit faster.

00:23:56.130 --> 00:23:59.530
It's not a big difference,
but probably a couple percent.

00:23:59.660 --> 00:24:02.960
More important is that the user
experience is just much better

00:24:02.960 --> 00:24:05.090
than desktop applications,
because the desktop applications

00:24:05.120 --> 00:24:09.190
are really embedded in the
normal operating system desktop.

00:24:09.200 --> 00:24:11.390
So they run as standard-owned processes.

00:24:11.400 --> 00:24:16.110
You can see the application
in the dock on Mac OS X.

00:24:16.190 --> 00:24:17.940
If need be,
you can quit them individually or

00:24:17.940 --> 00:24:20.560
kill them individually if they hang.

00:24:20.690 --> 00:24:24.540
You have access to the services menu.

00:24:24.540 --> 00:24:27.930
All these things are there,
so the user experience is

00:24:27.940 --> 00:24:31.160
really much better for desktop
applications than for applets.

00:24:31.300 --> 00:24:34.910
Since they run isolated,

00:24:35.100 --> 00:24:36.660
The stability is also much better.

00:24:36.660 --> 00:24:39.920
Applets that are, if multiple applets run
on the client machine,

00:24:39.920 --> 00:24:42.560
they all share the same
VM inside that browser.

00:24:42.630 --> 00:24:45.510
And that can obviously have all
kinds of negative side effects on

00:24:45.580 --> 00:24:47.320
both performance and stability.

00:24:47.550 --> 00:24:50.360
When it comes to security restrictions,
it's not that easy.

00:24:50.430 --> 00:24:53.030
From your perspective as the developer,
you would probably prefer to write

00:24:53.100 --> 00:24:57.820
desktop applications because there
will be no security manager in place,

00:24:57.820 --> 00:24:59.780
so you don't have to worry
about accessing the file system,

00:24:59.890 --> 00:25:01.710
getting security exceptions,
those kind of things.

00:25:01.710 --> 00:25:03.260
From your perspective, that's nice.

00:25:04.160 --> 00:25:06.460
For applets,
there might be a lot of problems.

00:25:06.460 --> 00:25:09.680
Users will probably see,
and that's why the app

00:25:09.680 --> 00:25:13.610
that's got a little dot here,
is that users might have a little

00:25:14.300 --> 00:25:17.830
different perspective on that
because they know that for applets,

00:25:18.100 --> 00:25:20.110
the VM will enforce security for them.

00:25:20.170 --> 00:25:23.290
They will know that the
application can mess around,

00:25:23.350 --> 00:25:27.030
that their file system delete files,
those kind of things.

00:25:27.060 --> 00:25:30.110
So they might actually prefer running
these applications as an applet.

00:25:32.470 --> 00:25:35.920
One last thing that's handy for
desktop applications is that you have

00:25:36.140 --> 00:25:42.440
the ability to tune VM parameters
individually for each application.

00:25:42.440 --> 00:25:45.600
While all the applets share all the same
settings and you can really control them,

00:25:45.600 --> 00:25:51.050
you know exactly how you will
start the desktop application.

00:25:51.080 --> 00:25:55.080
So if you have the need for large
heap sizes or you give it a lot

00:25:55.080 --> 00:25:58.040
of images and a lot of memory,
you can do that with

00:25:58.040 --> 00:25:59.220
desktop applications.

00:25:59.220 --> 00:26:01.640
You will probably have many,
many problems with applets.

00:26:05.280 --> 00:26:07.780
So we're pretty happy
with desktop applications,

00:26:07.780 --> 00:26:10.470
and as long as you can deal with the
installation and upgrading process,

00:26:10.470 --> 00:26:12.580
we think it's probably the
best way for you to deploy it.

00:26:12.680 --> 00:26:16.960
And applets, we think,
are pretty fragile, and in general,

00:26:16.960 --> 00:26:19.710
we think there's probably a
pretty dark future for applets,

00:26:19.880 --> 00:26:23.140
because, as you all know,
Windows XP doesn't support Java anymore,

00:26:23.140 --> 00:26:26.720
so we don't really expect a lot of
applets to be written in the future.

00:26:26.720 --> 00:26:31.040
So the good news is that our friends
at Sun have recognized it as well,

00:26:31.070 --> 00:26:33.980
and they're actually in the
process of providing us with a

00:26:33.980 --> 00:26:37.800
great replacement for applets,
and that replacement is called WebStart.

00:26:40.640 --> 00:26:43.860
WebStart is basically a new
technology from Cyan which

00:26:43.860 --> 00:26:45.560
will be part of the JDK 1.4.

00:26:45.560 --> 00:26:49.580
And it's already available as
an optional package for JDK 1.3.

00:26:51.620 --> 00:26:55.580
If you're actually using Mac OS 10.1
with the latest Java update,

00:26:55.580 --> 00:26:58.170
WebStart is already
integrated into Mac OS X.

00:26:58.170 --> 00:26:59.810
So that's a good thing.

00:27:00.350 --> 00:27:05.070
The idea behind WebStart is that
you as the developer create a nice

00:27:05.250 --> 00:27:10.700
entry page in HTML that the user
can navigate to in the browser.

00:27:10.770 --> 00:27:13.650
And then on this HTML page,
there's a special hyperlink

00:27:13.880 --> 00:27:16.100
that will trigger WebStart.

00:27:16.290 --> 00:27:22.240
When the user presses this hyperlink,
WebStart will download the

00:27:22.240 --> 00:27:26.040
classes to the client machine,
but then it will start the

00:27:26.040 --> 00:27:29.090
application outside the browser
as a standalone process.

00:27:29.150 --> 00:27:31.260
So it's not going to be
embedded in the browser anymore.

00:27:31.260 --> 00:27:33.790
It's now running outside the browser.

00:27:36.930 --> 00:27:41.160
and I think the biggest advantage
of WebStart is that it solves

00:27:41.170 --> 00:27:43.320
the upgrade problem for you.

00:27:43.390 --> 00:27:47.400
WebStart actually tracks the version
numbers or the version of the

00:27:47.400 --> 00:27:51.150
Java classes that you need on the
client side and it will automatically

00:27:51.150 --> 00:27:54.690
detect the next time the client
starts up that there's a new

00:27:54.700 --> 00:27:58.990
version available for the Java files
and then it will download them.

00:27:59.010 --> 00:28:01.370
So what WebStart does is it
actually caches the Java files,

00:28:01.480 --> 00:28:05.100
wants to download them on the client
machine and then when the client starts

00:28:05.100 --> 00:28:08.460
up the next time it will go and check
with the server quickly whether there's

00:28:08.460 --> 00:28:11.350
a new version available and if it is
it will download the new version but

00:28:11.350 --> 00:28:13.180
otherwise it will use the cached version.

00:28:13.260 --> 00:28:14.110
So that's really great.

00:28:14.120 --> 00:28:18.170
It's very elegant.

00:28:18.170 --> 00:28:18.170
Can we keep that until Q&A?

00:28:18.170 --> 00:28:18.170
Great, thank you.

00:28:21.390 --> 00:28:23.790
and it gets even better.

00:28:23.870 --> 00:28:29.440
WebStart really has a nice
solution for the security issue.

00:28:29.520 --> 00:28:34.290
Instead of relying on settings for
applets that are for all applets,

00:28:34.370 --> 00:28:38.170
security settings,
the user can grant permissions

00:28:38.170 --> 00:28:40.840
individually for each application.

00:28:40.940 --> 00:28:46.160
So basically the applications tell
WebStart that they either need

00:28:46.440 --> 00:28:48.400
access to the file system or not.

00:28:48.490 --> 00:28:50.890
And then if they do,
WebStart will bring up a panel

00:28:51.020 --> 00:28:52.100
before the application launches.

00:28:52.100 --> 00:28:53.940
We ask the user,
do you want to give permission

00:28:54.230 --> 00:28:55.600
to this application or not?

00:28:55.600 --> 00:28:58.690
And that's individual
for each application.

00:28:58.820 --> 00:29:03.350
And also WebStart requires,
if the application wants

00:29:03.350 --> 00:29:06.700
access to the file system,
wants to run outside the sandbox,

00:29:06.700 --> 00:29:10.240
it will require all the Java files
for this application to be signed.

00:29:10.330 --> 00:29:13.020
And that doesn't really prevent
the application from doing

00:29:13.070 --> 00:29:14.460
something bad on that machine.

00:29:14.550 --> 00:29:17.360
But what we always say is it gives
a better illusion of security.

00:29:17.440 --> 00:29:18.360
At least people can decide.

00:29:18.370 --> 00:29:22.930
whether they want to
trust the vendors or not.

00:29:23.880 --> 00:29:27.300
WebStart also comes with a
little manager application.

00:29:27.450 --> 00:29:31.680
This application basically allows
you to see information about the

00:29:31.680 --> 00:29:34.500
application that has been started before.

00:29:34.520 --> 00:29:36.220
You keep all that in mind.

00:29:36.220 --> 00:29:40.230
Then you can start applications
right out of the WebStart manager

00:29:40.640 --> 00:29:43.720
without going back to the HTML page,
the entry page.

00:29:43.720 --> 00:29:47.070
These managers also allow
you to create shortcuts.

00:29:47.070 --> 00:29:49.660
I believe for the next
version on Mac OS X,

00:29:49.660 --> 00:29:53.760
the WebStart manager will
allow you to create shortcuts.

00:29:53.810 --> 00:29:55.380
You can create shortcuts for
the applications that you

00:29:55.380 --> 00:29:56.200
can then place in the dock.

00:29:56.200 --> 00:29:57.880
On Windows,
the WebStart manager allows you to

00:29:57.880 --> 00:29:59.450
create shortcuts for the applications.

00:29:59.460 --> 00:30:02.910
Basically,
once the user downloads the application,

00:30:03.120 --> 00:30:07.900
they can then create little shortcuts,
and it feels much better and much simpler

00:30:07.900 --> 00:30:10.400
to navigate to the application again.

00:30:10.400 --> 00:30:14.560
They don't have to type in a
URL again and those kind of things.

00:30:16.420 --> 00:30:20.300
All you have to do if you want to deploy
an application through WebStart is

00:30:20.300 --> 00:30:22.030
you have to create a JNLP file.

00:30:22.040 --> 00:30:25.200
This JNLP file stores all the
information that WebStart needs,

00:30:25.200 --> 00:30:29.850
so the application name, the version,
description for it, who the vendor is,

00:30:29.850 --> 00:30:33.070
the home page,
the entry page for this application,

00:30:33.070 --> 00:30:35.430
and then a list of all the Java files.

00:30:35.620 --> 00:30:37.310
So we think WebStart is terrific.

00:30:37.430 --> 00:30:42.380
And going forward,
what we would like to do is we would

00:30:42.380 --> 00:30:46.810
probably deprecate applet support so it
will still be there in the next version,

00:30:46.810 --> 00:30:49.510
but long term we are
planning to remove it.

00:30:49.730 --> 00:30:52.390
As an alternative,
we will integrate WebStart as

00:30:52.390 --> 00:30:53.740
a deployment option.

00:30:53.810 --> 00:30:56.690
We will do that in a way
that is very automatic,

00:30:56.690 --> 00:30:59.000
so that you don't even have to
write the JNLP file by hand.

00:30:59.000 --> 00:31:00.290
We will do that all for you.

00:31:00.290 --> 00:31:04.400
When your parameters change,
your Java files change,

00:31:04.400 --> 00:31:08.410
we will update the JNLP file
automatically for you.

00:31:09.930 --> 00:31:12.300
Thanks.

00:31:12.300 --> 00:31:14.840
We also changed our templates in
Project Build a little bit to reflect

00:31:15.280 --> 00:31:19.790
that now you need an entry page in
HTML and then a page that basically

00:31:19.790 --> 00:31:21.840
configures your client application.

00:31:21.840 --> 00:31:27.290
What that means is that this deployment
matrix changes to something like this.

00:31:27.340 --> 00:31:32.340
Applets, as I said, will be deprecated,
and then WebStart will be a new option.

00:31:32.340 --> 00:31:34.770
We think that it's really great,
especially for the

00:31:34.770 --> 00:31:38.350
installation upgrade process,
and that it handles security very well.

00:31:38.360 --> 00:31:40.620
We think WebStart is a
really good solution,

00:31:40.620 --> 00:31:42.360
probably the best compromise.

00:31:42.360 --> 00:31:46.780
The only downside is still that,
at least for the first time,

00:31:46.780 --> 00:31:48.540
customers need to
download the application,

00:31:48.540 --> 00:31:51.620
so there's a long installation or there's
a long startup time the first time.

00:31:51.620 --> 00:31:54.540
Also, there's still a security
manager in place with WebStart,

00:31:54.540 --> 00:31:57.380
so the application will also perform
a little slower than a desktop

00:31:57.770 --> 00:31:59.560
application without all these things.

00:32:01.150 --> 00:32:03.930
So I'd like Norbert to
come up again on stage,

00:32:04.030 --> 00:32:07.910
and we'd like to show
you our WebStart support.

00:32:14.290 --> 00:32:17.220
So we create a new project again,
and this time I think we just do a

00:32:17.220 --> 00:32:20.950
direct-to-Java Client application.

00:32:21.000 --> 00:32:23.030
Give it a name again.

00:32:28.300 --> 00:32:36.200
[Transcript missing]

00:32:40.440 --> 00:32:42.620
And then,
let's spend a couple seconds here.

00:32:42.620 --> 00:32:46.380
So there's going to be a new page
in the Assistant going forward where

00:32:46.770 --> 00:32:49.740
you have to enter three values,
an application name,

00:32:49.740 --> 00:32:52.610
a reasonable application
name for the client side,

00:32:52.610 --> 00:32:56.060
who you are, the vendor name,
and then a description.

00:33:01.730 --> 00:33:03.800
This is going to be the same
for Direct-to-Java Client and

00:33:03.800 --> 00:33:06.880
NIP-Fi-based Java Clients.

00:33:06.920 --> 00:33:11.740
The application project is compiling
right now and the server is starting up.

00:33:13.330 --> 00:33:16.600
Then it will, like usual,
start the desktop

00:33:16.600 --> 00:33:17.740
application for us again.

00:33:29.830 --> 00:33:32.260
So this time we will just quit the
desktop application right away,

00:33:32.260 --> 00:33:36.040
and instead we will
navigate to the browser.

00:33:36.050 --> 00:33:38.370
We just paste in the URL.

00:33:51.320 --> 00:33:52.830
So it's a fairly simple page.

00:33:52.930 --> 00:33:56.560
We will rely on you to make that pretty.

00:33:56.660 --> 00:33:59.150
But basically, there's this hyperlink,
and if Norbert clicks on that,

00:33:59.280 --> 00:34:00.440
then WebStart will fire up.

00:34:00.440 --> 00:34:02.700
It will download the JNAP file quickly.

00:34:02.820 --> 00:34:06.490
And then WebStart comes up.

00:34:06.490 --> 00:34:06.490
So here it's downloading.

00:34:06.910 --> 00:34:08.900
That was too quick.

00:34:08.900 --> 00:34:10.120
That's okay.

00:34:10.240 --> 00:34:11.520
Just quit again and do it one more time.

00:34:16.200 --> 00:34:23.580
WebStart starts with the
download of the classes,

00:34:23.580 --> 00:34:26.200
the Java files,
and then checking for versions.

00:34:26.200 --> 00:34:30.340
It's pretty quick right now because
we are on the same machine here,

00:34:30.340 --> 00:34:33.200
but if you're on the Internet,
it will take a little longer.

00:34:33.200 --> 00:34:36.180
But then basically you get
the normal application.

00:34:36.210 --> 00:34:37.180
There's really no
difference for the user.

00:34:37.200 --> 00:34:41.080
The nice thing about this is you really
don't have to worry about deploying as a

00:34:41.100 --> 00:34:43.200
desktop application or through WebStart.

00:34:43.200 --> 00:34:46.270
As you saw, both of it is just supported
right out of the box,

00:34:46.280 --> 00:34:50.200
and it's just up to the user to
choose the right deployment mechanism.

00:34:50.200 --> 00:34:53.510
Norbert is right now on Project Builder,
and I just wanted to show

00:34:53.510 --> 00:34:57.200
you quickly that now the new
projects have two components.

00:34:57.200 --> 00:35:01.130
There's the main component,
just with the hyperlink.

00:35:01.290 --> 00:35:04.480
You can make this really pretty
and put your own company logo

00:35:04.480 --> 00:35:06.200
there and all these things.

00:35:06.200 --> 00:35:08.200
Norbert goes to the source code.

00:35:08.200 --> 00:35:13.200
The link is basically bound to
a method on the main component.

00:35:13.200 --> 00:35:16.480
And if you show that,
then you will find that there's

00:35:18.480 --> 00:35:21.760
The static method that we provide to
you on the VoJava Client component,

00:35:21.760 --> 00:35:25.590
which generates the right link,
the URL for the link for you.

00:35:25.600 --> 00:35:30.260
So this is the way for you to
integrate JNLP links into your pages.

00:35:30.260 --> 00:35:31.260
Pretty straightforward.

00:35:31.260 --> 00:35:33.510
And then there's the
Java Client component,

00:35:33.530 --> 00:35:36.500
which looks very similar to
the ones that we had before.

00:35:36.500 --> 00:35:38.650
In earlier times,
there was the VoJava Client applet.

00:35:38.660 --> 00:35:41.790
Now there's the VoJava Client component,
and they're all the same bindings,

00:35:41.820 --> 00:35:44.360
like the application class name,
what interface files to use.

00:35:45.320 --> 00:35:46.460
There are a couple of
additional bindings,

00:35:46.460 --> 00:35:48.400
obviously, for WebStart,
like the application name,

00:35:48.400 --> 00:35:50.510
what you entered in
ProjectBit and the assistant.

00:35:50.520 --> 00:35:51.380
Okay.

00:35:51.380 --> 00:35:52.760
Thank you.

00:36:03.210 --> 00:36:06.960
If you go back to the slides.

00:36:07.030 --> 00:36:10.820
Okay, so for the rest of the session,
I want to spend some time

00:36:10.900 --> 00:36:13.140
on the distribution layer.

00:36:13.190 --> 00:36:15.910
And the one thing,
the one message about the

00:36:15.910 --> 00:36:18.080
distribution layer is it's fast.

00:36:18.190 --> 00:36:21.860
For a three-tier system, it's really,
really fast.

00:36:22.140 --> 00:36:25.770
The reason why it's fast is that it
uses a copy distribution mechanism.

00:36:25.910 --> 00:36:29.380
What that means is that when
you fetch objects from the

00:36:29.420 --> 00:36:32.520
server to the client side,
the objects are copied to the client,

00:36:32.710 --> 00:36:35.400
and then they live there on the
client side as fully functioning

00:36:35.400 --> 00:36:38.160
objects in your EOF stack.

00:36:38.260 --> 00:36:42.760
So most other technologies create,
do something like with stubs.

00:36:42.800 --> 00:36:46.600
So usually their clients use some
kind of placeholder objects that

00:36:46.840 --> 00:36:49.600
go and talk to the server all
the time for every little detail,

00:36:49.600 --> 00:36:50.100
right?

00:36:50.120 --> 00:36:52.640
And maybe they do some
smart things with caching,

00:36:52.650 --> 00:36:56.380
but what you would find with these
other technologies is that they

00:36:56.380 --> 00:36:59.800
have a lot of communication going
on between client and server.

00:36:59.860 --> 00:37:01.780
So in our world,
if you really just copy the client,

00:37:01.780 --> 00:37:01.780
you can actually do a lot
of things with the client.

00:37:01.780 --> 00:37:01.780
So in our world,
if you really just copy the client,

00:37:01.780 --> 00:37:01.780
you can actually do a lot
of things with the client.

00:37:01.780 --> 00:37:01.780
So in our world,
if you really just copy the client,

00:37:01.780 --> 00:37:01.880
you can actually do a lot
of things with the client.

00:37:01.900 --> 00:37:06.590
plot the optics to decline and then
the lift and you editing context and

00:37:06.590 --> 00:37:09.970
you can do all the things that you
used to do in the u_s_ validation

00:37:10.160 --> 00:37:13.910
you know if you say input um...

00:37:14.000 --> 00:37:21.000
[Transcript missing]

00:37:22.210 --> 00:37:27.760
This is just a little
architectural diagram.

00:37:27.870 --> 00:37:30.100
The left side here shows the client side.

00:37:30.120 --> 00:37:33.280
The right side shows the
WebObjects application.

00:37:33.400 --> 00:37:36.580
And again, what I wanted to point out
is just the control layer,

00:37:36.680 --> 00:37:38.770
the EU control layer,
which is the layer in EUF that

00:37:38.770 --> 00:37:41.550
you work with most of the time,
the layer that you use for

00:37:41.580 --> 00:37:44.860
writing your business logic,
that exists in identical form on

00:37:44.880 --> 00:37:46.260
the client and the server side.

00:37:46.360 --> 00:37:49.030
And you only get different
behavior because there's another

00:37:49.030 --> 00:37:50.400
layer plugged in from underneath.

00:37:50.410 --> 00:37:52.540
Instead of EU access,
which is used on the server side,

00:37:52.540 --> 00:37:55.360
you use the EU distribution layer.

00:37:55.560 --> 00:37:57.160
And again,
the communication between client

00:37:57.160 --> 00:37:59.980
and server is usually through HTTP.

00:38:01.890 --> 00:38:06.160
There are four object classes in the
distribution layer that make this happen.

00:38:06.270 --> 00:38:10.100
On the client side, there's the so-called
UDistributedObjectStore,

00:38:10.130 --> 00:38:11.900
and then the UDistributionChannel.

00:38:11.980 --> 00:38:14.350
And UDistributionChannel is
actually an abstract class and

00:38:14.350 --> 00:38:17.800
usually uses a concrete subclass,
which is the UHTTP channel.

00:38:17.910 --> 00:38:21.540
On the server side,
there's the so-called VoJavaClientApplet.

00:38:21.590 --> 00:38:23.300
The name might be a little confusing.

00:38:23.300 --> 00:38:26.380
This is actually not an applet,
it's a Vo component that

00:38:26.380 --> 00:38:28.730
generates the HTML for an applet.

00:38:28.890 --> 00:38:33.680
And as you heard just a minute ago,
we will replace that going forward with

00:38:33.680 --> 00:38:36.240
this so-called VoJavaClientComponent,
which basically has

00:38:36.380 --> 00:38:38.760
the same functionality,
it just doesn't generate applets anymore.

00:38:38.760 --> 00:38:41.260
It's specialized for WebStart now.

00:38:41.340 --> 00:38:44.860
And the fourth object also on the
server side is the UDistributionContext.

00:38:44.970 --> 00:38:49.150
So I'd like to talk about these
four objects for a few minutes.

00:38:49.390 --> 00:38:53.760
Let's start on the client side
with the DistributedObjectStore.

00:38:54.600 --> 00:39:02.400
[Transcript missing]

00:39:02.700 --> 00:39:35.300
[Transcript missing]

00:39:36.740 --> 00:39:40.320
To plug in this EU distribution
layer on the client side,

00:39:40.320 --> 00:39:42.890
we just use a different kind
of object store for the parent

00:39:42.940 --> 00:39:44.400
for the editing context.

00:39:44.480 --> 00:39:46.500
And that's this
EU distributed object store.

00:39:46.610 --> 00:39:49.460
So it takes the place of the
EU database context that you

00:39:49.460 --> 00:39:53.210
usually use on the server side,
and becomes the parent of the

00:39:53.340 --> 00:39:56.150
editing context on the client side.

00:39:56.790 --> 00:39:59.500
To you,
that should be pretty transparent.

00:39:59.500 --> 00:40:02.360
You hardly ever write code,
or at least you should

00:40:02.460 --> 00:40:04.580
hardly ever write code,
against objects in the

00:40:04.660 --> 00:40:05.960
EU access layer directly.

00:40:05.960 --> 00:40:08.180
The EU access layer
deals with SQL for you.

00:40:08.180 --> 00:40:10.140
You don't have to worry about this.

00:40:10.140 --> 00:40:13.270
The objects that you deal with are
the objects in the EU control layer,

00:40:13.280 --> 00:40:15.360
and that's most of the
EU editing context.

00:40:15.360 --> 00:40:20.790
So this should be a change that will
just happen pretty transparently for you.

00:40:21.700 --> 00:40:25.540
The distributed object store
then uses an object that's called

00:40:25.540 --> 00:40:27.740
the EU distribution channel.

00:40:27.820 --> 00:40:32.420
The EU distribution channel is the object
that implements the concrete protocol to

00:40:32.450 --> 00:40:34.130
communicate between client and server.

00:40:34.190 --> 00:40:37.260
It basically gets a stream of data,
and it's supposed to transfer that

00:40:37.260 --> 00:40:41.160
to the server side in some form,
and then read the result back.

00:40:41.270 --> 00:40:44.300
And the channel that we ship by default,
the concrete subclass,

00:40:44.300 --> 00:40:45.420
is EU HTTP channel.

00:40:45.420 --> 00:40:48.210
That's the one that you usually use.

00:40:50.180 --> 00:40:54.040
The advantages of this
architecture here is that these

00:40:54.060 --> 00:40:55.240
objects are actually separated.

00:40:55.240 --> 00:40:58.320
The channel is not integrated
in the object store,

00:40:58.370 --> 00:41:00.490
so that you can plug in
a different behavior.

00:41:00.500 --> 00:41:04.480
You can use your own distribution
channel subclass to change the way

00:41:04.580 --> 00:41:06.020
you communicate with the server.

00:41:06.020 --> 00:41:13.000
Very common use cases for that are
adding security or adding SSL support,

00:41:13.000 --> 00:41:14.420
basically.

00:41:15.220 --> 00:41:20.750
You might also choose to do IIOP channels
or whatever is in your mind.

00:41:20.760 --> 00:41:23.420
I guess the most common
case is to do SSA.

00:41:25.210 --> 00:41:27.950
So this distribution of the
channel basically takes data and

00:41:27.960 --> 00:41:30.160
sends it over to the server side.

00:41:30.250 --> 00:41:33.690
And on the server side,
the object that listens to these remote

00:41:33.690 --> 00:41:38.060
method invocations is the component,
the VoJava Client applet,

00:41:38.060 --> 00:41:41.340
and later going forward,
the VoJava Client component,

00:41:41.360 --> 00:41:43.460
that you use to configure
the client-side parameters.

00:41:43.510 --> 00:41:47.620
So that's actually the real
object listening to the requests.

00:41:48.050 --> 00:41:50.220
But it doesn't really do anything
with these three requests.

00:41:50.350 --> 00:41:52.610
It just forwards them to
the distribution context.

00:41:52.790 --> 00:41:54.530
So again, there's an architecture.

00:41:54.530 --> 00:41:58.400
This is not one object class so that
you can plug in different behavior.

00:41:58.400 --> 00:42:01.440
You can choose to write a subclass
of the EU distribution context.

00:42:01.440 --> 00:42:03.510
The distribution context
is the object that really

00:42:03.660 --> 00:42:04.980
performs the EUF-related work.

00:42:05.050 --> 00:42:09.720
It's the object that then basically goes
to the editing context on the server

00:42:09.720 --> 00:42:14.570
side and fetches objects and saves,
fires faults, those kind of things.

00:42:15.900 --> 00:42:19.200
So these four classes really make
the distribution layer happen.

00:42:20.830 --> 00:42:24.920
To make this a little simpler to you,
I think the best way to think about

00:42:24.920 --> 00:42:29.700
the distribution layer is simply that
the editing context on the client side

00:42:30.060 --> 00:42:33.880
behaves like nested editing context to
the editing context on the server side.

00:42:33.950 --> 00:42:35.710
If you think a little
bit about object stores,

00:42:35.740 --> 00:42:38.750
what the distribution layer does,
basically it connects the editing

00:42:38.750 --> 00:42:41.770
context from the client to the
editing context on the server side.

00:42:41.940 --> 00:42:46.130
The editing context on the server
side basically behaves like the parent

00:42:46.240 --> 00:42:48.210
object store to the client side.

00:42:48.240 --> 00:42:52.350
One thing that's important with
our HTTP channel is that it's

00:42:52.380 --> 00:42:54.220
an unidirectional connection.

00:42:54.220 --> 00:42:56.260
It's not a bidirectional connection.

00:42:56.260 --> 00:43:01.260
What you typically find in a WebObjects
application is that once a change

00:43:01.260 --> 00:43:04.350
comes down from one object store,
from one editing context,

00:43:04.420 --> 00:43:06.860
gets saved to the database,
all the other editing contexts

00:43:06.860 --> 00:43:10.140
in that same application are
synchronized with the changes you made.

00:43:10.180 --> 00:43:12.500
And that's automatic.

00:43:13.300 --> 00:43:17.780
But in our model here,
that doesn't work because you can't

00:43:17.950 --> 00:43:20.650
push back changes through HTTP.

00:43:20.710 --> 00:43:21.910
There has to be a request.

00:43:21.920 --> 00:43:23.620
It has to be pulled from the client.

00:43:23.620 --> 00:43:28.820
So what we do in the distribution layer
is that we keep track of all the changes,

00:43:28.820 --> 00:43:31.890
and the next time the client connects,
we will synchronize the

00:43:31.920 --> 00:43:33.440
changes on the server side.

00:43:33.440 --> 00:43:35.720
So if you have multiple client
applications running through

00:43:35.720 --> 00:43:38.580
the same application server,
and one client makes a change,

00:43:38.580 --> 00:43:41.760
it will be saved to the database,
and the other clients will be

00:43:41.860 --> 00:43:44.900
synchronized with that state,
the next time they connect.

00:43:44.980 --> 00:43:47.220
And then potentially it
might even have to do with

00:43:47.220 --> 00:43:49.730
optimistic locking errors or so,
but they are the normal ways

00:43:49.730 --> 00:43:50.800
in EUF how you deal with that.

00:43:55.930 --> 00:43:57.900
So what do you need to
know about security?

00:43:57.920 --> 00:44:01.270
Obviously, the moment you have clients,
rich clients that can go to

00:44:01.350 --> 00:44:05.060
the server and fetch data and
save change to the database,

00:44:05.060 --> 00:44:07.890
that opens up potentially
a lot of security holes.

00:44:07.900 --> 00:44:12.300
So the most important mechanism for you
to make your application secure is what

00:44:12.360 --> 00:44:16.530
we call business logic partitioning,
and I'll talk a lot about that.

00:44:17.180 --> 00:44:20.180
The second thing you need to
know is that on the server side,

00:44:20.180 --> 00:44:25.940
there's a delegate to the distribution
context that has full control over

00:44:25.990 --> 00:44:28.390
every remote method invocation.

00:44:28.420 --> 00:44:34.190
So the delegate to the distribution
context is the object that you really

00:44:34.400 --> 00:44:38.870
use to make the application secure
if you care about every individual

00:44:38.870 --> 00:44:42.620
invocation and if business logic
partitioning is not good enough.

00:44:44.100 --> 00:44:47.340
The third thing you need to know is
that if you want a secure connection,

00:44:47.340 --> 00:44:50.760
right now you would have to subclass
our EU HTTP channel and then use

00:44:50.760 --> 00:44:55.340
additional packages like JSSE or so
from some to create secure sockets.

00:44:55.370 --> 00:44:57.890
We actually showed a
demonstration of that last year,

00:44:57.890 --> 00:45:00.100
so if you can go back to
the DVDs from last year,

00:45:00.100 --> 00:45:01.660
there's even some source
code how to do that.

00:45:01.800 --> 00:45:04.010
Otherwise,
maybe you can come to me afterwards

00:45:04.010 --> 00:45:05.760
and I can point you to that code.

00:45:05.760 --> 00:45:10.170
Let's talk about business
logic partitioning.

00:45:10.790 --> 00:45:13.840
What business logic partitioning
means is that you can choose

00:45:13.920 --> 00:45:18.120
whether you want to use identical
business logic implementations on

00:45:18.120 --> 00:45:21.740
the client side and the server side,
or whether you want to use specific

00:45:21.770 --> 00:45:24.010
implementations on client and server.

00:45:24.480 --> 00:45:26.320
In greater detail,
what you can do is you can

00:45:26.320 --> 00:45:30.380
choose two different classes
to represent your objects on

00:45:30.490 --> 00:45:32.520
the client and the server side.

00:45:34.000 --> 00:45:40.120
And you can limit or restrict the view
of the client to a subset of properties.

00:45:40.160 --> 00:45:44.400
So if there's something like a
password field in a user object,

00:45:44.520 --> 00:45:48.200
you can simply say that this is not
supposed to be visible on the client,

00:45:48.200 --> 00:45:52.580
and the distribution layer will make
sure that it's never sent to the client,

00:45:52.580 --> 00:45:54.760
so it's not visible to the client.

00:45:55.460 --> 00:45:58.240
So business logic is very
important for security,

00:45:58.240 --> 00:45:59.980
and it's actually also very
important for performance,

00:45:59.980 --> 00:46:03.240
because, at least what I hear from
several of the customers,

00:46:03.240 --> 00:46:06.480
from several of you guys,
is that to create a successful

00:46:06.480 --> 00:46:09.620
three-tier application,
you have to be fairly

00:46:10.320 --> 00:46:15.570
careful about sending data,
or too much data, to the client side.

00:46:15.650 --> 00:46:19.070
Often you can avoid sending data
to the client just because you

00:46:19.100 --> 00:46:20.920
will never display it there.

00:46:20.940 --> 00:46:23.630
Often you're just interested
in some derived information,

00:46:23.630 --> 00:46:25.300
something like an average value.

00:46:25.400 --> 00:46:28.300
If you wanted, for example,
to have a list of departments,

00:46:28.300 --> 00:46:31.880
and then the average salary of all
the employees in that department.

00:46:31.880 --> 00:46:36.060
So instead of sending all the
employee objects to the client side,

00:46:36.060 --> 00:46:39.700
and then performing the average
computation on the client side,

00:46:39.700 --> 00:46:43.050
it's much better for you to just
compute that on the server side,

00:46:43.060 --> 00:46:46.000
and just send the entry side over,
and avoid that you send

00:46:46.070 --> 00:46:47.480
all these employee objects.

00:46:47.480 --> 00:46:51.450
And from what I hear from you is
actually that that's the key to have a

00:46:51.710 --> 00:46:55.880
successful implementation in Java Client,
that you make sure that you

00:46:55.880 --> 00:46:57.150
don't send too much data.

00:46:57.220 --> 00:47:05.520
If you want the response
times to be reasonably low,

00:47:05.520 --> 00:47:08.680
or small,
then you need to make sure that you

00:47:08.680 --> 00:47:11.570
only send the data to the client
that you really need to send.

00:47:11.580 --> 00:47:13.570
And if you don't display it there,
if you don't need it for any

00:47:13.660 --> 00:47:16.870
computation on the client,
keep it on the server side.

00:47:18.270 --> 00:47:19.860
Another advantage of doing that,
by the way,

00:47:19.860 --> 00:47:26.740
is that you can use a class if you
have a fairly secure algorithm that,

00:47:26.910 --> 00:47:28.920
for some reason, you don't want to be
visible on the client.

00:47:28.920 --> 00:47:32.260
And keep in mind that with Java,
classes can be very easily decompiled,

00:47:32.260 --> 00:47:34.600
so everybody can look
at your implementation.

00:47:34.600 --> 00:47:37.820
If you don't want that,
you can force your client to talk to

00:47:37.820 --> 00:47:40.200
the server for some of the operations.

00:47:40.200 --> 00:47:42.030
That way,
you don't make your implementation

00:47:42.030 --> 00:47:43.240
visible on the client side.

00:47:45.890 --> 00:47:50.830
So the tool that you use to configure the
business logic partitioning is EOModeler.

00:47:50.830 --> 00:47:52.510
And there's a column that
you're all familiar with,

00:47:52.510 --> 00:47:53.840
which is the class name column.

00:47:53.840 --> 00:47:57.890
And that's where you specify the class
that you want to use to represent

00:47:58.250 --> 00:48:00.010
an object for a given entity.

00:48:00.600 --> 00:48:05.490
And there's a little menu in the
lower left corner of the table view,

00:48:05.490 --> 00:48:08.170
the Add Column pop-up menu there.

00:48:08.200 --> 00:48:11.200
And that allows you to
reveal additional columns.

00:48:11.200 --> 00:48:14.390
And there's one that is
not visible by default,

00:48:14.390 --> 00:48:17.330
but if you do the Java Client,
you need to look at it.

00:48:17.410 --> 00:48:19.260
It's just called Client-Side Class Name.

00:48:19.260 --> 00:48:23.230
So here you can specify the class name
for the objects on the client side.

00:48:23.240 --> 00:48:26.360
And as you can see in this example here,
for some of the entities,

00:48:26.360 --> 00:48:27.860
I used the same class name.

00:48:27.860 --> 00:48:30.580
And for some of them,
like the second one, the customer,

00:48:30.580 --> 00:48:34.620
I'm using classes in different packages.

00:48:34.620 --> 00:48:38.080
One is the example.serverCustomer,
and the other one is the clientCustomer.

00:48:38.080 --> 00:48:42.880
So here I can choose different
classes for client and server.

00:48:43.420 --> 00:48:48.480
The other thing that you're
interested in is the class properties.

00:48:49.060 --> 00:48:51.550
If you look at an entity,
there's the column that

00:48:51.640 --> 00:48:55.170
you're all familiar with,
which specifies which of these

00:48:55.260 --> 00:48:58.920
attributes and relationships is
really part of your business object.

00:48:59.010 --> 00:49:01.000
That's what we call a class property.

00:49:01.000 --> 00:49:04.000
There's a second column you can reveal,
which is for the client side.

00:49:04.000 --> 00:49:07.870
So here you can specify that the client,
for example,

00:49:07.960 --> 00:49:12.990
has no access to the phone number,
I believe, and the member date.

00:49:17.430 --> 00:49:19.560
And then also if you deal with
business logic partitioning,

00:49:19.560 --> 00:49:22.080
there's some API that's
fairly important to you.

00:49:22.230 --> 00:49:24.120
There are three methods
that you care about.

00:49:24.140 --> 00:49:28.230
There's invoke remote method,
there's evade from client update,

00:49:28.300 --> 00:49:30.620
and prepare values for client.

00:49:30.640 --> 00:49:33.240
The first method is
used on the client side,

00:49:33.250 --> 00:49:37.510
and the other two methods
are used on the server side.

00:49:37.810 --> 00:49:39.990
Invoke remote method

00:49:42.500 --> 00:52:04.300
[Transcript missing]

00:52:07.550 --> 00:52:10.500
There's a fairly important
naming convention that we have.

00:52:10.550 --> 00:52:13.000
And the naming convention is
that if the name of the method

00:52:13.240 --> 00:52:18.200
starts with client-side request,
then we consider that a method that

00:52:18.200 --> 00:52:20.250
is open for unrestricted access.

00:52:20.320 --> 00:52:24.260
So we consider that a method that
can be invoked by any client.

00:52:25.370 --> 00:52:26.740
If you don't follow
this naming convention,

00:52:26.740 --> 00:52:29.910
you will actually have to go through
some extra code to enable that,

00:52:29.910 --> 00:52:32.550
because by default,
we only allow methods that

00:52:32.670 --> 00:52:33.680
follow these naming conventions.

00:52:33.700 --> 00:52:36.620
We don't want to open
additional holes in your stack.

00:52:36.720 --> 00:52:40.460
We don't want to allow clients
to invoke any method that

00:52:40.460 --> 00:52:42.560
you don't intend to open up.

00:52:42.640 --> 00:52:45.100
So that's why this naming
convention is fairly important.

00:52:47.900 --> 00:52:49.870
One recommendation if you work
with business logic partitioning,

00:52:49.870 --> 00:52:52.470
you use different classes on
the client and the server side,

00:52:52.470 --> 00:52:56.300
is to not use two classes,
but actually three classes.

00:52:56.390 --> 00:52:59.310
What we recommend is that you create
a common superclass in which you

00:52:59.370 --> 00:53:04.200
implement all the shared functionality,
and you define all the methods that have

00:53:04.200 --> 00:53:08.370
different implementations as abstract
methods on this common superclass,

00:53:08.380 --> 00:53:12.110
and you use two complete subclasses,
one for the client, one for the server.

00:53:12.500 --> 00:53:17.180
For example, a class secret here,
an abstract class,

00:53:17.310 --> 00:53:20.240
and there's an abstract
method definition.

00:53:20.260 --> 00:53:23.400
On the client side,
I could implement that to

00:53:23.420 --> 00:53:25.340
simply go to the server.

00:53:25.340 --> 00:53:28.610
So I would just use invoke remote method,
and that would basically just move the

00:53:28.610 --> 00:53:30.660
method execution to the server side.

00:53:30.660 --> 00:53:33.920
And on the server side,
the method secret value would

00:53:33.960 --> 00:53:37.120
actually return a concrete value,
and then there's the

00:53:37.120 --> 00:53:38.500
client side request method.

00:53:38.500 --> 00:53:39.760
Let me go back one slide.

00:53:39.880 --> 00:53:41.870
As you can see,
I follow the naming convention

00:53:41.870 --> 00:53:43.160
client side request here.

00:53:43.160 --> 00:53:46.730
So this is a method that's considered
open for unrestricted access that

00:53:47.000 --> 00:53:50.680
just invokes the real method.

00:53:50.720 --> 00:53:54.520
This might look a little complicated,
but it has a big advantage for you.

00:53:54.520 --> 00:53:56.950
The advantage is that you
can write business logic code

00:53:56.980 --> 00:54:00.340
against the abstract super class,
and that business logic code is usable

00:54:00.450 --> 00:54:02.560
on both the client and the server side.

00:54:02.580 --> 00:54:05.720
So it really increases the
reusability of your business logic.

00:54:05.740 --> 00:54:09.080
If you use the secret class,
you can write some code,

00:54:09.080 --> 00:54:09.850
and it will execute in the secret.

00:54:09.890 --> 00:54:11.980
same form of client and server
side as long as you write it

00:54:11.980 --> 00:54:13.280
against the abstract superclass.

00:54:19.490 --> 00:54:22.190
So invoking remote
methods on EOs is fine,

00:54:22.290 --> 00:54:24.120
and it's very, very important.

00:54:24.170 --> 00:54:27.990
But in reality,
if you have a desktop application,

00:54:28.020 --> 00:54:31.600
you will need to talk to the
server for reasons that are not

00:54:31.600 --> 00:54:35.790
related to your business logic,
typically loading some resources or maybe

00:54:35.790 --> 00:54:39.370
performing some user authentication,
those kind of things.

00:54:39.490 --> 00:54:43.370
So we also have an API for that,
and this API is on the

00:54:43.390 --> 00:54:46.000
EODistributedObject store.

00:54:46.060 --> 00:54:48.520
So if you remember the
picture from before,

00:54:48.520 --> 00:54:50.970
the EODistributedObject
store is the parent object

00:54:50.970 --> 00:54:53.780
store of the editing context,
and the simplest way to find

00:54:53.780 --> 00:54:56.390
it is to invoke a static
method on EU editing context,

00:54:56.620 --> 00:54:58.500
default parent object store.

00:54:58.630 --> 00:55:00.800
So that's the best way for you to
get to the distributed object store,

00:55:00.800 --> 00:55:04.790
and there's an API that you can use
to perform application logic-specific

00:55:04.790 --> 00:55:06.700
remote method invocations.

00:55:08.840 --> 00:55:11.430
There are two methods that
are interesting to you.

00:55:11.550 --> 00:55:14.350
One is called
invokeRemoteMethodWithKeyPath,

00:55:14.350 --> 00:55:18.830
and the other one is called
invokeStatelessRemoteMethodWithKeyPath.

00:55:18.950 --> 00:55:20.260
Let me go back one slide.

00:55:20.390 --> 00:55:23.860
So the arguments to the first
one are an editing context,

00:55:23.930 --> 00:55:27.830
a key path that will identify the
object on the server side-- I'll talk

00:55:27.830 --> 00:55:31.800
about that in a second-- a method name,
and then the arguments.

00:55:32.120 --> 00:55:35.070
The method invoke_remote,
or invoke_remote method with

00:55:35.100 --> 00:55:38.880
keypath is a method that can
include enterprise objects.

00:55:38.980 --> 00:55:42.400
So if you have a remote method
invocation that is somehow

00:55:42.400 --> 00:55:46.240
related to your business objects,
then you can use this method here

00:55:46.250 --> 00:55:50.840
on the distributed object store.

00:55:51.600 --> 00:56:32.500
[Transcript missing]

00:56:34.010 --> 00:56:36.480
We just introduced this
method in the last release,

00:56:36.570 --> 00:56:38.640
by the way, so I don't think a lot
of you have seen this.

00:56:38.640 --> 00:56:40.760
So WebOpt.js 5.1 introduced this method.

00:56:40.760 --> 00:56:43.530
And the great advantage of it is,
by the way, that it's thread-safe,

00:56:43.600 --> 00:56:46.120
so it's actually ideal
for some background tasks.

00:56:46.120 --> 00:56:50.760
A common use case of this method is to
perform a background ping every five

00:56:50.870 --> 00:56:54.930
minutes that checks with the server side,
are there any changes?

00:56:55.000 --> 00:56:57.280
And if yes, then you actually fetch them.

00:56:57.280 --> 00:57:00.480
So this is a fairly cheap method
that doesn't have the overhead

00:57:00.480 --> 00:57:04.140
of the state-full remote method
invocation and just there's no

00:57:04.140 --> 00:57:06.980
enterprise object in the communication.

00:57:11.010 --> 00:57:15.560
So let's talk about how the object
on the server side is identified.

00:57:15.770 --> 00:57:17.950
The argument to these methods
that identifies the server

00:57:17.980 --> 00:57:19.560
side object is the key path.

00:57:19.580 --> 00:57:25.360
It's a key path that's evaluated
relative to the distribution context.

00:57:25.370 --> 00:57:27.880
A typical example is session.

00:57:27.940 --> 00:57:31.250
You would specify a key path
starting with the distribution

00:57:31.250 --> 00:57:35.340
context on the server side,
a key path that goes to the

00:57:35.350 --> 00:57:39.050
target object on which you want
to invoke your remote method.

00:57:39.160 --> 00:57:40.410
There are two special cases.

00:57:40.650 --> 00:57:44.560
One is if you personalize the argument,
you try to invoke the method on

00:57:44.560 --> 00:57:46.260
the distribution context itself.

00:57:46.300 --> 00:57:50.510
That's mostly interesting if you use
subclasses of your distribution context.

00:57:50.920 --> 00:57:53.970
If you pass an empty string,
then for your convenience,

00:57:53.990 --> 00:57:57.100
if you have a registry on
the distribution context,

00:57:57.100 --> 00:57:59.960
you can plug in additional
objects that want to listen

00:57:59.960 --> 00:58:01.460
to remote method invocations.

00:58:01.460 --> 00:58:04.730
So that's just a registry,
and if the key path is

00:58:04.820 --> 00:58:07.700
just an empty string,
you just go through all the objects

00:58:07.700 --> 00:58:11.460
in this registry and find the first
object in this registry that responds

00:58:11.550 --> 00:58:15.640
to the method and then perform the
remote method invocation on that object.

00:58:15.660 --> 00:58:21.740
So that's basically just a convenience
for you so that you can plug in

00:58:21.750 --> 00:58:25.390
arbitrary remote method listeners.

00:58:29.900 --> 00:58:35.130
It might be hard to register these
additional targets because every session

00:58:35.230 --> 00:58:36.950
uses its own distribution context.

00:58:37.040 --> 00:58:41.000
So distribution context come and
go together with the sessions.

00:58:41.130 --> 00:58:44.710
So to make that easy for you,
we introduced a notification

00:58:44.710 --> 00:58:45.760
that we sent out.

00:58:45.760 --> 00:58:49.400
It's called your remote method
receiver needed notification.

00:58:49.510 --> 00:58:54.370
Basically, in your application,
you can register for this notification.

00:58:55.450 --> 00:58:59.300
and then when you receive it,
you receive it for a new

00:58:59.300 --> 00:59:01.520
distribution context,
and then you register your

00:59:01.540 --> 00:59:03.300
objects as invocation targets.

00:59:04.630 --> 00:59:08.020
Again,
the naming convention client-set request

00:59:08.130 --> 00:59:12.420
applies to both methods that are on
enterprise objects and to the application

00:59:12.500 --> 00:59:14.640
logic-specific remote method invocations.

00:59:33.250 --> 00:59:34.980
This confused me.

00:59:35.090 --> 00:59:40.330
I think there's something missing now.

00:59:45.060 --> 00:59:48.670
With all these remote method invocations,
again, if they follow the client-side

00:59:48.670 --> 00:59:51.160
request naming convention,
we consider them open

00:59:51.270 --> 00:59:54.260
for arbitrary access,
so they would just go through.

00:59:54.260 --> 00:59:58.580
If you don't use this naming convention,
you have full control over

00:59:58.650 --> 01:00:02.260
every single invocation,
and you have the control over these

01:00:02.280 --> 01:00:06.440
invocations in the delegate of the
distribution context on the server side.

01:00:06.440 --> 01:00:09.150
So you register a delegate object,
and then there are several methods

01:00:09.150 --> 01:00:13.250
that we will send this delegate object,
and you can control either per

01:00:13.430 --> 01:00:18.240
method name or for the key path,
which method invocations are allowed.

01:00:18.240 --> 01:00:23.550
You have full access about which fetch
specifications the client can execute,

01:00:23.550 --> 01:00:26.000
which faults the client can fire.

01:00:26.000 --> 01:00:30.760
So this delegate is really the one
instance that you use to control

01:00:30.980 --> 01:00:33.720
client on a fine-grained level.

01:00:33.760 --> 01:00:36.330
Business logic partitioning
does the first.

01:00:36.440 --> 01:00:39.530
It does a very good job as long as it
can describe the difference between

01:00:39.530 --> 01:00:42.640
client and server in the schema,
but often you need more

01:00:42.710 --> 01:00:44.640
fine-grained control.

01:00:44.640 --> 01:00:48.560
For example, once a user logs in,
you might allow access

01:00:48.560 --> 01:00:52.520
to certain objects,
certain fetch specifications.

01:00:52.520 --> 01:00:57.710
You might want to enhance qualifiers
to limit the search results,

01:00:57.860 --> 01:01:00.530
but those are not schema-based.

01:01:00.560 --> 01:01:03.150
Those are really data-based,
and for those kind of things,

01:01:03.150 --> 01:01:05.500
you use the delegate on
the distribution context.

01:01:06.260 --> 01:01:08.190
And there's, again,
a notification that you can

01:01:08.190 --> 01:01:10.380
use to set this delegate for
the distribution context,

01:01:10.380 --> 01:01:12.690
because there will be many,
many distribution contexts

01:01:12.690 --> 01:01:14.640
in your application,
one for each client.

01:01:14.640 --> 01:01:17.080
And this notification is
your distribution context

01:01:17.080 --> 01:01:20.720
instantiated notification,
so that's sent out, again,

01:01:20.720 --> 01:01:24.220
when the distribution context is created.

01:01:27.540 --> 01:01:30.170
So I'd like to ask Norbert
to come up on stage.

01:01:30.170 --> 01:01:34.050
And what we'd like to do
is show you an example,

01:01:34.050 --> 01:01:36.380
a couple of details,
of an example that we shipped

01:01:36.420 --> 01:01:37.290
with the last release.

01:01:37.300 --> 01:01:41.300
Attention WWDC 2002 attendees.

01:01:41.300 --> 01:01:45.150
Hall 1, including the exhibitor
fair and internet cafe,

01:01:45.160 --> 01:01:46.300
is now closed.

01:01:46.300 --> 01:01:48.920
Please join us on the concourse for sex.

01:01:48.920 --> 01:01:53.360
And then again at 6.30 in Hall 2
for the Apple Design Awards,

01:01:53.380 --> 01:01:56.310
followed at 7.30 by Stumpy Experts.

01:01:56.310 --> 01:01:57.260
Thank you.

01:01:58.600 --> 01:02:05.200
[Transcript missing]

01:02:05.810 --> 01:02:08.800
We added an example to the last release,
WebObjects 5.1,

01:02:08.800 --> 01:02:09.880
which we call Discussion Board.

01:02:09.880 --> 01:02:13.750
It's a Java Client example that
shows how to do authentication and

01:02:13.890 --> 01:02:17.240
to use all these distribution context
delegate mechanisms to control

01:02:17.240 --> 01:02:19.130
security on a fine-grained level.

01:02:19.140 --> 01:02:21.220
Let us show you the application quickly.

01:02:21.220 --> 01:02:25.060
It starts with a login panel,
and Norbert is logging in as

01:02:25.060 --> 01:02:27.170
an administrator right now.

01:02:27.920 --> 01:02:32.800
He gets a fairly standard Java Client UI.

01:02:32.830 --> 01:02:34.640
As an administrator,
he can perform every single

01:02:34.640 --> 01:02:35.800
operation that he wants.

01:02:35.800 --> 01:02:38.790
He can search, open records, etc.

01:02:38.800 --> 01:02:42.800
The editor menu items,
the tools menu called Logout.

01:02:42.800 --> 01:02:44.800
It goes back to the login panel.

01:02:44.800 --> 01:02:48.800
Norbert will log in as a normal user,
not as an administrator.

01:02:48.800 --> 01:02:51.990
Then what you will see is that

01:02:52.620 --> 01:02:55.010
There's a very customized UI,
so it's not a direct-to-Java

01:02:55.120 --> 01:02:56.010
Client UI anymore.

01:02:56.100 --> 01:02:58.990
So there's a subscriptions
window for the discussion board.

01:02:59.090 --> 01:03:01.860
You can look at discussion
boards individually.

01:03:02.030 --> 01:03:05.000
And there's also something
like a preferences panel.

01:03:05.000 --> 01:03:07.510
So as you can see,
this UI really has nothing to do with

01:03:07.510 --> 01:03:09.500
direct-to-Java Client standard UIs.

01:03:09.640 --> 01:03:14.270
So we wanted to just show you a
couple of places in the source code

01:03:14.270 --> 01:03:17.070
that might be interesting for you.

01:03:17.870 --> 01:03:21.200
This is all in WebObjects 5.1,
so we don't want to show you too

01:03:21.200 --> 01:03:23.480
many details because you can always
go back and look at it there,

01:03:23.480 --> 01:03:25.650
but just a couple of places.

01:03:25.660 --> 01:03:29.650
The way this example works is that
there's an object on the client side that

01:03:29.770 --> 01:03:33.100
tracks the user authentication state,
and there's an object on the

01:03:33.100 --> 01:03:35.840
server side that does the same,
and those two are obviously in sync.

01:03:35.900 --> 01:03:39.070
The object on the server side
is actually the session object,

01:03:39.070 --> 01:03:42.920
so that the user authentication is
handled for each individual client.

01:03:44.000 --> 01:03:46.730
On the client side,
the authentication center,

01:03:46.730 --> 01:03:50.770
that's the object class that controls
the authentication state there,

01:03:50.800 --> 01:03:54.610
if the user logs out or logs in,
basically what happens is that

01:03:54.630 --> 01:03:58.040
the startup sequence is played
again and again and again.

01:03:58.040 --> 01:04:01.340
The startup sequence, in our world here,
basically means to get rid of all

01:04:01.340 --> 01:04:03.170
the windows that were opened before.

01:04:03.180 --> 01:04:05.810
It will forget all the objects,
all the EU enterprise objects

01:04:05.810 --> 01:04:08.240
that were fetched before,
all these things will forget,

01:04:08.280 --> 01:04:10.560
all the preferences values,
all these things.

01:04:10.560 --> 01:04:12.790
Then, if you start this,
and we basically perform

01:04:12.820 --> 01:04:13.890
the start sequence.

01:04:14.000 --> 01:04:17.190
since this is a
direct-to-JavaClient application.

01:04:17.490 --> 01:04:20.310
What happens is that if the
user is not authenticated,

01:04:20.310 --> 01:04:23.930
the server will actually provide a
description for the client side that

01:04:23.960 --> 01:04:28.400
says the windows that are there are the
login window and the registration panel.

01:04:28.400 --> 01:04:31.340
Then once the user logs in,
the state is cleared up again,

01:04:31.360 --> 01:04:33.680
and if you perform the
start sequence again,

01:04:33.680 --> 01:04:39.420
and then the server decides again,
depending on the user who logged in,

01:04:39.430 --> 01:04:41.100
what kind of UI to generate.

01:04:41.680 --> 01:04:43.590
So for an administrator,
if you just create a

01:04:43.590 --> 01:04:45.740
direct-to-Java Client UI,
and for a normal user,

01:04:45.740 --> 01:04:47.420
if you create a very customized UI.

01:04:47.420 --> 01:04:49.490
So as you can see,
the server really is the object that

01:04:49.570 --> 01:04:51.500
controls what happens on the client side.

01:04:51.500 --> 01:04:54.350
And we actually use all these methods,
the distribution context

01:04:54.550 --> 01:04:56.710
delegate methods,
to control the individual

01:04:56.710 --> 01:04:58.280
remote method invocations.

01:04:58.280 --> 01:05:00.500
And one thing that we won't show you,
but it's there too,

01:05:00.500 --> 01:05:03.720
is that we also make use of that in the
rule system for direct-to-Java Client.

01:05:03.720 --> 01:05:09.260
Basically, since the user authentication
information is stored in the session,

01:05:09.260 --> 01:05:11.660
we can use a key path starting from
the user authentication information.

01:05:11.660 --> 01:05:14.570
So starting with the session,
something like session.isAdministrator,

01:05:14.640 --> 01:05:17.720
in the rule system to decide
what kind of windows to generate

01:05:17.720 --> 01:05:18.720
for direct-to-Java Client.

01:05:18.720 --> 01:05:21.240
Okay, so the one-up method,
we wanted to show you

01:05:21.240 --> 01:05:22.640
four places in the code.

01:05:22.640 --> 01:05:26.200
The first method is, are there five?

01:05:26.240 --> 01:05:27.150
Maybe there are five.

01:05:27.200 --> 01:05:30.070
So it's called, in the authentication
center on the client side,

01:05:30.070 --> 01:05:31.420
perform launch sequence.

01:05:31.420 --> 01:05:32.920
That's the method you want to look at.

01:05:32.920 --> 01:05:35.060
It's doing all the cleanup work,
closing all the windows,

01:05:35.060 --> 01:05:39.230
invalidating all the objects,
invalidating all the UI information

01:05:39.230 --> 01:05:42.280
retrieved for the controller factory,
so far.

01:05:42.280 --> 01:05:47.920
And then, one method invocation that's
interesting here is factory.

01:05:47.920 --> 01:05:48.640
I'll go back.

01:05:48.660 --> 01:05:49.810
Okay.

01:05:50.720 --> 01:05:56.240
There's this method, controller factory,
open default.

01:05:56.240 --> 01:05:58.310
I'm going to scroll down a little bit.

01:06:00.000 --> 01:06:00.780
It's at the bottom.

01:06:00.780 --> 01:06:05.560
Activate default controllers.

01:06:05.560 --> 01:06:07.550
So that's the method that
triggers the startup sequence

01:06:07.560 --> 01:06:09.000
again on the controller factory.

01:06:09.000 --> 01:06:10.700
So that might be interesting for you.

01:06:10.700 --> 01:06:14.500
The other method, interesting,
is the method that actually

01:06:14.500 --> 01:06:17.060
sends the user name and the
password to the server side.

01:06:17.170 --> 01:06:21.280
And what we do here is we just do a
stateless remote method invocation,

01:06:21.280 --> 01:06:24.900
and we send the name and the
password to the server side.

01:06:25.030 --> 01:06:29.050
That arrives in the
session on the server side.

01:06:29.500 --> 01:07:12.200
[Transcript missing]

01:07:12.370 --> 01:07:15.770
So, again,
I think it's a very useful example.

01:07:15.770 --> 01:07:19.350
I would recommend looking at
that if you're interested in

01:07:19.350 --> 01:07:20.590
security with Java Client.

01:07:20.600 --> 01:07:21.640
Thank you, Norbert.

01:07:32.310 --> 01:07:37.260
Okay, so the conclusion for this talk,
just a quick summary.

01:07:37.260 --> 01:07:42.530
So the things I'd like you to remember
is that the distribution layer is a very,

01:07:42.550 --> 01:07:47.290
very efficient layer for, you know,
it's certainly slower than

01:07:47.290 --> 01:07:49.520
a two-tier application,
but it's doing a very,

01:07:49.520 --> 01:07:52.940
very good job for a
three-tier architecture.

01:07:52.940 --> 01:07:56.850
The items about security that
you should remember are business

01:07:56.960 --> 01:07:58.520
logic partitioning is your friend.

01:07:58.520 --> 01:08:00.820
Business logic partitioning is
your best mechanism to control

01:08:00.860 --> 01:08:03.680
what the client can see.

01:08:03.680 --> 01:08:05.600
If you need finer-grained control,
you use a delegate for

01:08:05.720 --> 01:08:08.670
the distribution context,
and if you want a secure connection,

01:08:08.750 --> 01:08:11.020
you use a distribution channel subclass.

01:08:11.020 --> 01:08:14.180
And then going forward,
we will deprecate,

01:08:14.180 --> 01:08:17.580
or we are planning to deprecate
applet support in Java Client

01:08:17.580 --> 01:08:21.250
and replace it with WebStart,
and from what I hear from you guys,

01:08:21.250 --> 01:08:22.990
that's probably what you do anyway today.

01:08:22.990 --> 01:08:27.920
So I guess I have a couple
of usual slides here.

01:08:27.920 --> 01:08:29.840
The lab is closed now.

01:08:31.300 --> 01:08:34.860
But you can go there tomorrow again.

01:08:34.860 --> 01:08:38.910
The two sessions I would recommend
to you if you want to have more

01:08:38.910 --> 01:08:41.600
information are 7.11 and 7.12.

01:08:41.600 --> 01:08:42.950
They are about EUF.

01:08:43.120 --> 01:08:45.840
One is about data modeling part,
and one is about how to

01:08:45.840 --> 01:08:48.530
deal with synchronization
in EUF and things like that,

01:08:48.540 --> 01:08:50.880
advanced enterprise object frameworks.

01:08:50.880 --> 01:08:54.080
And then you can obviously beat
us up in the feedback session.

01:08:54.080 --> 01:08:56.040
Who to contact?

01:08:56.140 --> 01:09:01.910
Tony and Bob.

01:09:01.910 --> 01:09:01.910
You've probably all seen that.

01:09:03.940 --> 01:09:07.400
Again, there's a great book about
Java Client desktop applications.

01:09:07.440 --> 01:09:11.520
It was actually written by Brent,
who did the demos in the last session.

01:09:11.520 --> 01:09:14.260
This is a really good entry point
for you if you want to know.

01:09:14.260 --> 01:09:18.660
It mostly talks about UI generation
direct to Java Client and Java Client,

01:09:18.660 --> 01:09:20.400
and also talks a little bit
about the distribution layer.

01:09:20.400 --> 01:09:23.740
There's the information
about the documentation.

01:09:23.740 --> 01:09:28.170
And that's it.

01:09:28.170 --> 01:09:29.440
Thank you.
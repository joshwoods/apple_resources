WEBVTT

00:00:03.410 --> 00:00:10.260
which is Accessibility and Carbon.

00:00:10.410 --> 00:00:18.300
So just in case you weren't
aware or you weren't unable to

00:00:18.300 --> 00:00:18.300
attend the previous session,
009,

00:00:18.300 --> 00:00:22.300
as it applies to the Carbon framework.

00:00:22.300 --> 00:00:39.270
So if you didn't see it,
please take the opportunity to join us.

00:00:39.290 --> 00:00:39.520
So what I'd like to do now is
welcome Guy Fullerton on the stage

00:00:39.520 --> 00:00:39.710
so he can present today's content.

00:00:39.710 --> 00:00:39.710
Thank you.

00:00:46.000 --> 00:00:46.600
Yeah, there we go.

00:00:46.600 --> 00:00:46.960
I'm Guy.

00:00:47.160 --> 00:00:49.230
I'm one of the high-level
Toolbox engineers,

00:00:49.230 --> 00:00:50.540
or HI Toolbox engineers.

00:00:50.590 --> 00:00:54.230
And in particular,
I've been working on the accessibility

00:00:54.290 --> 00:00:56.600
side of Carbon for the last month or two.

00:00:56.600 --> 00:01:03.070
And I want to show you basically how
you can take a Carbon application

00:01:03.070 --> 00:01:03.070
and make it accessible.

00:01:06.300 --> 00:02:50.600
[Transcript missing]

00:02:50.760 --> 00:02:54.170
So we solve that with a
set of Accessibility APIs,

00:02:54.510 --> 00:03:01.700
which abstract the notion of an
interface into these UI element objects.

00:03:01.700 --> 00:03:07.400
And the Assistive API set is basically
the green boxes on the slide you see.

00:03:07.440 --> 00:03:09.580
But in particular,
since this is a Carbon-focused session,

00:03:09.600 --> 00:03:13.750
I'm just going to show you how the green
boxes work on the Carbon side and how you

00:03:13.750 --> 00:03:16.100
can make a Carbon app fully accessible.

00:03:16.700 --> 00:03:19.540
So there's three basic things an
application needs to do in order

00:03:19.540 --> 00:03:21.630
to be considered accessible.

00:03:21.680 --> 00:03:24.920
The first is it needs to be
able to explain to an assistive

00:03:24.940 --> 00:03:27.740
application what its interface is.

00:03:27.970 --> 00:03:31.640
What windows are in my app, what menus,
menu items, controls, buttons,

00:03:31.660 --> 00:03:33.440
text fields, and all that stuff.

00:03:33.440 --> 00:03:35.860
It needs to be able to
communicate that stuff.

00:03:35.920 --> 00:03:38.940
Likewise, an assistive app might say,
well, tell me what widget is

00:03:38.940 --> 00:03:42.610
underneath a given screen point,
something like that.

00:03:42.680 --> 00:03:45.460
The second thing your application
would need to do is to allow an

00:03:45.460 --> 00:03:49.420
assistive application to press buttons,
choose menu commands,

00:03:49.680 --> 00:03:52.230
or invoke other sorts of
functionality within your application.

00:03:52.240 --> 00:03:55.050
Finally,
the third thing your app would need

00:03:55.100 --> 00:03:58.680
to do is send out notifications
to the assistive app saying,

00:03:58.680 --> 00:04:01.700
hey, this part of my interface changed,
and a user's probably going to

00:04:01.700 --> 00:04:05.230
want to know about that part,
so please communicate it to them.

00:04:06.520 --> 00:04:08.560
And the way this all basically
works is through Carbon events.

00:04:08.610 --> 00:04:09.900
I mean, Carbon events are the future.

00:04:09.900 --> 00:04:11.560
We've been saying this for
the last couple of years.

00:04:11.560 --> 00:04:13.860
We've been saying you're going to
need to learn about Carbon events

00:04:13.950 --> 00:04:15.400
to adopt all the new features.

00:04:15.410 --> 00:04:16.840
And this feature is no exception.

00:04:16.840 --> 00:04:19.980
The suite of Carbon events
that we use to implement the

00:04:20.010 --> 00:04:24.370
accessibility stuff on our side is,
they correspond pretty

00:04:24.590 --> 00:04:26.420
directly to the C APIs.

00:04:26.420 --> 00:04:30.950
So if you saw last session, you know,
assistive apps can say things like,

00:04:31.020 --> 00:04:32.970
tell me what UI elements
under this point.

00:04:32.970 --> 00:04:34.650
Give me the focused UI element.

00:04:34.650 --> 00:04:36.890
Once I've got a UI element, you know,
they want to say,

00:04:36.900 --> 00:04:39.340
give me some actions and
attributes and things like that.

00:04:39.400 --> 00:04:43.420
And so we broke up the suite of
Carbon events into three basic sets.

00:04:43.420 --> 00:04:48.230
The first set allows the assistive
application to pull UI elements out

00:04:48.230 --> 00:04:53.100
of your application so that it can
see what the interface looks like.

00:04:53.180 --> 00:04:55.750
It can get a given UI element at a point.

00:04:56.240 --> 00:05:00.760
It can find the focused UI element and
look at your containment hierarchy.

00:05:00.760 --> 00:05:03.300
It can find out about a given
UI element's parent or children.

00:05:03.300 --> 00:05:09.350
The next suite of Carbon events allows
the assistive app to pull individual

00:05:09.350 --> 00:05:12.300
pieces of data out of a UI element.

00:05:12.300 --> 00:05:16.200
You might want to find out what a
button's title is or a window's title,

00:05:16.200 --> 00:05:18.260
things like that.

00:05:18.650 --> 00:05:22.700
Likewise, you also want to find out what
actions a UI element supports.

00:05:22.740 --> 00:05:25.990
You know, a button might say that, hey,
I can be pressed.

00:05:26.060 --> 00:05:26.060
Or a menu item might say,
I can be pressed.

00:05:26.100 --> 00:05:28.310
Say, I can be picked.

00:05:29.790 --> 00:05:32.290
And finally,
the third set is ways for the

00:05:32.290 --> 00:05:36.800
assistive application to trigger
functionality in your app.

00:05:37.080 --> 00:05:39.000
That's done in two basic ways.

00:05:39.000 --> 00:05:41.790
As we showed in the previous session,
some attributes of a

00:05:41.790 --> 00:05:44.330
UI element are modifiable,
so of course that's one way

00:05:44.440 --> 00:05:45.700
to invoke functionality.

00:05:45.780 --> 00:05:50.490
But the other way is to ask
UI elements to perform actions.

00:05:51.770 --> 00:05:53.120
So some of you right now
are probably thinking,

00:05:53.180 --> 00:05:56.100
oh, geez, Carbon Events, you know,
this is going to be such hard work.

00:05:56.210 --> 00:05:57.460
Do I really want to do this?

00:05:57.540 --> 00:05:59.200
We've got all this old legacy code.

00:05:59.200 --> 00:06:00.380
You know, I'm in education.

00:06:00.410 --> 00:06:02.130
We've had this code
working for ten years.

00:06:02.130 --> 00:06:03.150
We haven't modified it.

00:06:03.150 --> 00:06:04.870
We were lucky to get
it just working on ten.

00:06:04.870 --> 00:06:06.240
How am I going to deal with this?

00:06:06.600 --> 00:06:08.360
Well, it's actually really simple.

00:06:08.460 --> 00:06:12.550
Carbon Events are adoptable
in a piece-by-piece fashion.

00:06:12.600 --> 00:06:14.700
You don't have to rewrite
your entire application.

00:06:14.700 --> 00:06:16.320
And they work with WaitNextEvent.

00:06:16.320 --> 00:06:19.840
You can take your existing code
and just wire up accessibility

00:06:19.840 --> 00:06:23.470
support into it and leave most
of the rest of your code alone.

00:06:23.470 --> 00:06:25.900
I'll talk about some of the other minor
changes you'll need to make later.

00:06:25.900 --> 00:06:28.370
But in particular,
you can find out more details

00:06:28.370 --> 00:06:31.920
about migrating to Carbon Events by
checking out session 203,

00:06:32.020 --> 00:06:35.360
which happened, what, two days ago,
Tuesday or Wednesday?

00:06:36.360 --> 00:06:39.200
Get the DVD if you weren't
able to attend that session.

00:06:39.200 --> 00:06:42.240
But it talks about the basics on
how to adopt Carbon Events and shows

00:06:42.240 --> 00:06:43.880
you some techniques you can use.

00:06:46.580 --> 00:06:49.920
So these Accessibility
Carbon Events need to get sent someplace,

00:06:49.970 --> 00:06:50.380
right?

00:06:50.380 --> 00:06:53.880
We need to make these requests into
certain places in your application.

00:06:53.880 --> 00:06:55.630
And if you're familiar
with Carbon Events,

00:06:55.630 --> 00:06:59.620
you know that you need a target
for a Carbon Event to be sent to.

00:06:59.620 --> 00:07:02.630
And in particular,
the Accessibility Carbon Events will

00:07:02.680 --> 00:07:06.150
be sent to potentially any
HI objects in your interface.

00:07:06.190 --> 00:07:08.640
As we explained in our
HI Objects session,

00:07:08.760 --> 00:07:11.710
windows controls and
menus are all HI objects.

00:07:11.770 --> 00:07:13.670
You can make HI objects of your own.

00:07:13.670 --> 00:07:18.030
And any of these could be or can be the
target of an Accessibility Carbon Event.

00:07:18.070 --> 00:07:21.540
The really cool thing here is that all
of the standard system controls and

00:07:21.540 --> 00:07:25.710
menus and windows and stuff like that,
they already have the accessibility

00:07:25.720 --> 00:07:27.130
basics wired into them.

00:07:27.240 --> 00:07:30.540
So you won't have to do any work
to make a button accessible.

00:07:30.790 --> 00:07:32.670
You might want to augment
the button's accessibility

00:07:32.680 --> 00:07:33.730
to add a few extra features.

00:07:33.740 --> 00:07:35.370
And you can do that if you want.

00:07:35.370 --> 00:07:37.890
But all the basic functionality is there.

00:07:39.360 --> 00:07:43.220
Okay, so I'm going to get into a weird,
subtle concept thing here,

00:07:43.220 --> 00:07:45.060
so bear with me.

00:07:45.070 --> 00:07:47.680
So like I said,
these Accessibility Carbon events

00:07:47.920 --> 00:07:50.900
and requests are made onto
windows controls and menus,

00:07:50.900 --> 00:07:52.950
and that makes a lot of sense, right?

00:07:52.950 --> 00:07:55.970
You might -- if you've got a window,
you might want to know what

00:07:55.970 --> 00:07:58.660
children UI elements it's got,
or like it shows on the slide,

00:07:58.660 --> 00:08:02.020
you might want to find out a push
button's title or a menu's size.

00:08:02.370 --> 00:08:04.480
But that doesn't answer
a couple other questions.

00:08:04.530 --> 00:08:07.880
You might want to find out something
about an individual menu item,

00:08:08.040 --> 00:08:10.850
like what's its title,
or something really weird

00:08:10.870 --> 00:08:12.370
like a scroll bar's arrow.

00:08:12.710 --> 00:08:16.840
That, from the accessibility standpoint,
needs to look like a button.

00:08:16.840 --> 00:08:20.710
But there's nothing to represent
an individual arrow in a scroll

00:08:20.820 --> 00:08:22.960
bar in terms of an HI object.

00:08:22.960 --> 00:08:26.710
So we don't really have a way to
send a Carbon event directly to a

00:08:26.710 --> 00:08:28.970
menu item or a scroll bar arrow.

00:08:28.990 --> 00:08:32.740
The way we solve that is by saying
that the owner of that subcomponent,

00:08:32.740 --> 00:08:34.480
the HI object that has
that subcomponent in it,

00:08:34.480 --> 00:08:35.380
is the target of the
Accessibility Carbon event.

00:08:35.380 --> 00:08:35.660
And that's the way we solve that.

00:08:35.660 --> 00:08:43.550
So for example, if you want to find out
the title of a menu item,

00:08:43.560 --> 00:08:46.340
that Accessibility Carbon event is
going to be sent to the menu ref,

00:08:46.340 --> 00:08:48.710
which is an HI object,
and which therefore can

00:08:48.750 --> 00:08:50.780
receive Carbon events.

00:08:53.000 --> 00:08:55.040
The other main goal is
we need to have a really,

00:08:55.070 --> 00:08:58.140
really flexible representation
for this notion of a UI element,

00:08:58.140 --> 00:09:00.150
for this notion of an accessible object.

00:09:00.150 --> 00:09:02.390
Obviously,
it's got to be able to represent all

00:09:02.390 --> 00:09:06.170
the things I've talked about so far,
windows, menu items, things like that.

00:09:06.170 --> 00:09:09.080
But it also needs to be flexible
enough to represent completely

00:09:09.150 --> 00:09:10.870
custom parts in your application.

00:09:10.870 --> 00:09:13.650
We know there's a lot of Carbon apps
out there that have maybe

00:09:13.650 --> 00:09:16.450
their own text editing engine,
or you don't use the control

00:09:16.450 --> 00:09:19.340
manager a lot because you've
got some custom-looking stuff,

00:09:19.340 --> 00:09:21.880
and so you just hand-roll
that on your own.

00:09:21.900 --> 00:09:24.990
We need to make sure that our
Carbon mechanism for allowing

00:09:24.990 --> 00:09:29.900
accessibility lets you make every
part of your application accessible.

00:09:31.370 --> 00:09:33.420
And the way we do that is
with a type that we talked

00:09:33.500 --> 00:09:36.600
about in the previous session,
the AX UI element ref.

00:09:36.670 --> 00:09:39.100
Like all the Accessibility
APIs and types,

00:09:39.100 --> 00:09:41.660
this one starts with AX.

00:09:41.700 --> 00:09:44.810
And so when I refer to a UI element,
what I'm actually talking about is

00:09:44.810 --> 00:09:47.300
one of these AX UI element refs.

00:09:47.300 --> 00:09:48.250
These are CF types.

00:09:48.360 --> 00:09:51.970
You retain them and release them and
put them in CF collections and stuff,

00:09:52.070 --> 00:09:55.700
all like that, just like you would do
with any other CF type.

00:09:55.700 --> 00:09:59.760
And this type allows you to represent
any accessible widget on the screen,

00:09:59.760 --> 00:10:00.990
anything you want.

00:10:01.610 --> 00:10:05.850
And most importantly,
one of these UI element refs is a proxy.

00:10:05.990 --> 00:10:08.000
So this is what one might
look like in memory.

00:10:08.000 --> 00:10:12.000
It's got a process ID in it pointing to
the application to which it came from.

00:10:12.120 --> 00:10:15.360
And it's also going to have some
framework-specific references that point

00:10:15.490 --> 00:10:17.560
into some data within your application.

00:10:17.560 --> 00:10:20.820
So, for instance, on Carbon,
these pointers might look like

00:10:20.950 --> 00:10:24.570
a control ref or a menu ref,
something like that, whereas for Cocoa,

00:10:24.570 --> 00:10:27.860
they're going to point to
the various Cocoa structures.

00:10:30.270 --> 00:10:33.220
So on Carbon,
a UI element's framework-specific

00:10:33.240 --> 00:10:35.500
data has two fundamental pieces.

00:10:35.570 --> 00:10:37.160
It's obviously got an HI object.

00:10:37.200 --> 00:10:39.420
You know, like I said,
we need a place to which we

00:10:39.420 --> 00:10:40.700
send these Carbon events.

00:10:40.840 --> 00:10:43.180
But it's also got a 64-bit
identifier associated with it,

00:10:43.270 --> 00:10:45.660
and I'll talk more about why
we need that in a minute.

00:10:45.660 --> 00:10:48.150
You manage them with three basic APIs.

00:10:48.180 --> 00:10:51.820
There's ax-ui-element,
create with HI object and identifier.

00:10:51.840 --> 00:10:54.390
I tried to make a really,
really long API name

00:10:54.390 --> 00:10:57.080
because I like those,
but you use that to create

00:10:57.080 --> 00:10:58.770
one of these UI elements.

00:10:59.230 --> 00:11:03.020
Once you've created one and you're
hanging on to it for whatever reason,

00:11:03.150 --> 00:11:06.480
you can pull out the HI object
or the 64-bit identifier with

00:11:06.480 --> 00:11:08.310
one of the other accessor APIs.

00:11:10.570 --> 00:11:13.550
Okay, so like I said,
the UI element has an HI object

00:11:13.570 --> 00:11:14.960
in it for a Carbon app.

00:11:15.100 --> 00:11:18.150
And fundamentally speaking,
this is just the target of the

00:11:18.150 --> 00:11:22.220
Carbon events that might correspond to
requests for information or requests

00:11:22.320 --> 00:11:24.590
for action on one of those UI elements.

00:11:24.640 --> 00:11:26.550
And generally,
it's going to be one of the

00:11:26.550 --> 00:11:28.900
Toolbox data structures,
like a control ref or a menu

00:11:29.030 --> 00:11:30.420
ref or something like that.

00:11:30.490 --> 00:11:33.160
But it can be any other
HI object you might desire.

00:11:33.160 --> 00:11:36.740
If you feel like expanding the
toolbar HI object's functionality,

00:11:36.740 --> 00:11:40.430
hey, you can throw Accessibility
Carbon event handlers on that.

00:11:40.500 --> 00:11:42.850
And start returning UI elements
based on the toolbar if you want.

00:11:42.950 --> 00:11:45.240
Now, granted,
the system's already going to support

00:11:45.290 --> 00:11:47.090
accessibility for the toolbar,
but you might want to

00:11:47.090 --> 00:11:48.210
augment that in some fashion.

00:11:50.440 --> 00:11:55.220
So the 64-bit identifier is what
allows a UI element to represent

00:11:55.220 --> 00:11:58.010
a subcomponent of an HI object.

00:11:58.100 --> 00:12:02.220
And I've got some graphical
examples here in a sec,

00:12:02.220 --> 00:12:03.850
but bear with me.

00:12:03.910 --> 00:12:05.950
If you've got a UI element--well,
you know what,

00:12:05.950 --> 00:12:07.920
let's just jump right into the examples.

00:12:07.960 --> 00:12:11.140
It'll be easier to explain.

00:12:11.150 --> 00:12:13.710
If you've got a UI element that
contains the framework-specific

00:12:13.710 --> 00:12:17.810
data of a menu ref and zero,
that's going to represent the whole menu,

00:12:17.810 --> 00:12:18.370
right?

00:12:18.370 --> 00:12:22.580
Zero generally means the whole thing,
the whole HI object that I'm talking to.

00:12:22.790 --> 00:12:27.720
Whereas if I've got a UI element that
has a menu ref and an identifier of two,

00:12:28.000 --> 00:12:32.360
that might represent the menu item,
the second menu item of that menu.

00:12:32.360 --> 00:12:36.240
The one important thing to note here
is that this 64-bit identifier space is

00:12:36.350 --> 00:12:39.670
privately definable by the HI object.

00:12:39.780 --> 00:12:43.330
So if you have a system
ref like a menu ref,

00:12:43.360 --> 00:12:47.210
you don't want to make assumptions
that that menu ref plus two

00:12:47.480 --> 00:12:50.450
equals the UI element that
represents the second menu item,

00:12:50.590 --> 00:12:50.880
right?

00:12:50.900 --> 00:12:53.310
It's up to the menu ref's
implementation to decide what

00:12:53.310 --> 00:12:56.210
the 64-bit identifier means.

00:12:56.530 --> 00:13:00.360
Just another example here,
if you've got a data browser control

00:13:00.440 --> 00:13:08.450
and you build a UI element that
contains the control ref and zero,

00:13:08.520 --> 00:13:10.830
that's going to represent
the whole outline view,

00:13:10.840 --> 00:13:15.390
which is our term for a data browser and
list view in the accessibility space.

00:13:15.510 --> 00:13:19.110
Whereas if you've got a UI element
that contains the control ref and

00:13:19.190 --> 00:13:23.500
some hex identifier of some fashion,
it might refer to some cell

00:13:23.930 --> 00:13:26.150
within the data browser.

00:13:26.810 --> 00:13:29.350
So to make this,
just to hammer this point home,

00:13:29.690 --> 00:13:34.020
this is probably a technique
you will want to take advantage

00:13:34.020 --> 00:13:35.430
of within your own application.

00:13:35.430 --> 00:13:37.800
And here's one way you
might want to do that.

00:13:38.000 --> 00:13:40.590
Let's say you've got a custom
text editing engine in your app,

00:13:40.590 --> 00:13:43.650
and it's not implemented in terms
of controls or anything like that,

00:13:43.650 --> 00:13:47.030
and you want to make it accessible,
you can use this same technique.

00:13:47.070 --> 00:13:52.620
If you need to generate an accessible,
sorry, a UI element that represents the

00:13:52.620 --> 00:13:56.520
entire text engine in that window,
you're going to create an HI object

00:13:56.520 --> 00:13:59.690
to represent that text engine
and create a UI element wrapped

00:13:59.770 --> 00:14:01.540
around that HI object and zero.

00:14:01.540 --> 00:14:02.910
And that will point to the whole thing.

00:14:02.920 --> 00:14:06.050
But let's say you want to go a step
further and you want to make individual

00:14:06.080 --> 00:14:07.950
sections of your document accessible.

00:14:07.950 --> 00:14:10.900
You know, you want to expose paragraphs
or words or something like

00:14:10.910 --> 00:14:12.600
that as individual UI elements.

00:14:12.640 --> 00:14:13.780
You can do that, too.

00:14:13.780 --> 00:14:16.430
And so one thing you might do is say,
all right,

00:14:16.710 --> 00:14:17.040
if I want to make this accessible,
I'm going to have to make it accessible.

00:14:17.040 --> 00:14:19.540
If I want to represent the
12th word of this document,

00:14:19.540 --> 00:14:24.550
I'm going to create a UI element wrapped
around that engine's HI object and the

00:14:24.550 --> 00:14:27.880
identifier 12 or something like that.

00:14:29.440 --> 00:14:31.860
So now we know,
you know a little bit about

00:14:31.860 --> 00:14:33.910
representing your application,
but I want to talk about

00:14:33.910 --> 00:14:35.500
it from a higher level.

00:14:35.500 --> 00:14:39.920
The UI elements that an
accessible application looks at,

00:14:39.940 --> 00:14:42.290
sorry,
that an assistive application looks at,

00:14:42.380 --> 00:14:44.830
form a containment hierarchy, right?

00:14:44.920 --> 00:14:46.670
You've got an app UI element.

00:14:46.670 --> 00:14:49.950
That app points at a couple
windows as its children and also

00:14:49.950 --> 00:14:51.620
has the menu bar as a child.

00:14:51.620 --> 00:14:54.660
Each of those windows might have
a root control as its child,

00:14:54.830 --> 00:14:57.440
and any of the controls in
there might contain lots more

00:14:57.440 --> 00:14:59.120
controls and things like that.

00:14:59.300 --> 00:15:01.990
So as you think about how
to represent your app,

00:15:01.990 --> 00:15:04.200
keep those basic concepts in mind.

00:15:04.200 --> 00:15:06.290
You want to form a hierarchy.

00:15:07.430 --> 00:15:10.750
So,
the examples I showed on the other side,

00:15:10.950 --> 00:15:14.050
other slide obviously,
the system's going to handle

00:15:14.050 --> 00:15:15.640
most of the stuff for you.

00:15:15.640 --> 00:15:17.350
We already make windows accessible.

00:15:17.410 --> 00:15:20.230
We already make menus,
the menu bar and individual

00:15:20.240 --> 00:15:21.400
menus accessible.

00:15:21.400 --> 00:15:24.340
You know, we already make the control
hierarchy accessible.

00:15:24.470 --> 00:15:27.850
And the important part for you is
that you're going to want to do work

00:15:27.850 --> 00:15:31.520
to make the custom areas of your
application as accessible as possible.

00:15:31.520 --> 00:15:35.670
And to do that, fundamentally,
you just need to create HI objects

00:15:35.760 --> 00:15:36.960
to represent those parts.

00:15:37.280 --> 00:15:40.170
Better yet,
create HI views to represent those parts.

00:15:40.270 --> 00:15:43.430
And then you're going to fit in
with our new HI view model as well.

00:15:43.430 --> 00:15:44.660
So, it's a double win.

00:15:44.660 --> 00:15:49.740
The one trick, if you do not turn your,
represent your application

00:15:50.420 --> 00:15:55.930
with HI views or control rafts,
and instead you're just building

00:15:55.940 --> 00:16:02.120
HI objects and using those to represent
your app in an accessible manner,

00:16:02.220 --> 00:16:06.500
in order to make sure
your app's HI objects are

00:16:06.500 --> 00:16:06.560
represented in the right way,
you're going to want to do a lot of work

00:16:06.560 --> 00:16:06.560
to make sure that your app's HI objects
are represented in the right way.

00:16:06.560 --> 00:16:08.690
So, if your app's HI objects are
represented in this hierarchy,

00:16:08.720 --> 00:16:12.320
you're going to need to override
certain default handling.

00:16:12.530 --> 00:16:15.510
In particular, if you want,
let's say you've got

00:16:15.510 --> 00:16:16.490
a text editing engine.

00:16:16.790 --> 00:16:21.420
You want to make sure that engine is
represented as a child of the window.

00:16:21.490 --> 00:16:24.620
You're going to need to make sure
to override that window's handling

00:16:24.620 --> 00:16:26.750
of the get children Carbon event,
right?

00:16:26.760 --> 00:16:30.130
So, you can put your UI element in that
array of the window's children.

00:16:32.450 --> 00:16:35.940
And this is another weird note
that I want to talk about.

00:16:36.100 --> 00:16:39.540
Sometimes as you're thinking
about your hierarchy and looking

00:16:39.540 --> 00:16:42.370
at how the system does things,
you might be worried that too much

00:16:42.420 --> 00:16:45.580
information is going to be thrown in
the face of an assistive application.

00:16:45.580 --> 00:16:49.680
The picture on the left there shows
what an actual control hierarchy

00:16:49.680 --> 00:16:51.490
in a window might look like.

00:16:51.840 --> 00:16:53.820
Obviously you've got a
window ref on the outside.

00:16:54.130 --> 00:16:56.050
That window ref is going
to have a root control.

00:16:56.230 --> 00:16:59.850
You might have a couple other controls
that ultimately wrap a user pane.

00:16:59.860 --> 00:17:01.420
And inside that user
pane is a push button.

00:17:01.420 --> 00:17:04.080
And as it turns out,
the root control and the user

00:17:04.190 --> 00:17:06.080
pane aren't really important.

00:17:06.200 --> 00:17:10.000
They may not actually represent any
information that the user ever sees.

00:17:10.000 --> 00:17:13.170
Obviously the root control is there
just because the system needs it.

00:17:13.290 --> 00:17:16.510
And the user pane might be there just
as a convenience for your development

00:17:16.510 --> 00:17:18.240
or some other grouping mechanism.

00:17:18.240 --> 00:17:20.990
So you don't want an assistive
app to actually see those.

00:17:20.990 --> 00:17:24.400
You want the assistive app to see what
we show in the picture on the right,

00:17:24.400 --> 00:17:27.160
which is just, hey,
there's a button in this window.

00:17:27.170 --> 00:17:31.400
And the way we allow that on Carbon is
through the use of the assistive app.

00:17:31.420 --> 00:17:34.000
of ignored UIElements.

00:17:34.130 --> 00:17:38.080
Any HI object can be marked
as accessibility ignored.

00:17:38.080 --> 00:17:40.660
And if you mark it as
accessibility ignored,

00:17:40.660 --> 00:17:44.310
it can still be returned as a
child or a parent of various

00:17:44.380 --> 00:17:46.380
other accessible objects.

00:17:46.380 --> 00:17:51.160
But the layer that actually services
the request from Carbon and hands

00:17:51.160 --> 00:17:53.870
something back across to the
assistive application makes sure

00:17:53.990 --> 00:17:56.000
to filter those out transparently.

00:17:56.000 --> 00:17:58.090
It does all the hard work for you.

00:17:59.340 --> 00:18:03.400
Okay, so let's get down into
some nuts and bolts here.

00:18:03.400 --> 00:18:06.390
The first thing an assistive application
is going to ask you for is UI elements.

00:18:06.400 --> 00:18:08.180
It can't start anywhere without them.

00:18:08.250 --> 00:18:12.230
So you need to know how to send those
over to the assistive application,

00:18:12.230 --> 00:18:15.280
or more correctly,
how to service requests

00:18:15.370 --> 00:18:17.380
for those UI elements.

00:18:17.380 --> 00:18:19.560
They can ask for them
three different ways.

00:18:19.580 --> 00:18:22.400
They can ask your app, hey,
tell me what UI element is under this

00:18:22.400 --> 00:18:24.510
particular mouse position on the screen.

00:18:24.530 --> 00:18:27.170
Or they might say, hey,
tell me what focused -- sorry,

00:18:27.170 --> 00:18:29.430
what UI element is focused
in your app right now.

00:18:29.550 --> 00:18:31.690
Or they might be tunneling
down from the root,

00:18:31.750 --> 00:18:31.850
right?

00:18:31.920 --> 00:18:34.020
They might have grabbed your
application's UI element and

00:18:34.030 --> 00:18:36.550
start traversing the hierarchy,
and ultimately they're trying to

00:18:36.550 --> 00:18:39.140
find some grandchild or child of
some window or something like that.

00:18:41.470 --> 00:18:43.820
So the first way,
which is finding something by position,

00:18:44.020 --> 00:18:48.920
is done via the K-event accessible
get-child-at-point Carbon event.

00:18:48.920 --> 00:18:51.190
This Carbon event
contains two parameters.

00:18:51.260 --> 00:18:54.550
The first, obviously,
is the UI element that's being queried,

00:18:54.560 --> 00:19:00.320
and it'll contain a global screen
point that they're interested in.

00:19:00.320 --> 00:19:02.850
So one other note I should
probably make about these,

00:19:02.860 --> 00:19:06.810
the Carbon accessibility engine will
send these sorts of events recursively.

00:19:06.830 --> 00:19:11.180
So your responsibility when serving,
servicing one of these events is

00:19:11.180 --> 00:19:15.900
actually just to pass back your
immediate child that's under that point.

00:19:15.900 --> 00:19:19.280
And the Carbon accessibility
engine will take care of any

00:19:19.280 --> 00:19:21.210
recursion that needs to happen.

00:19:21.210 --> 00:19:24.350
So fundamentally,
when the assistive app wants to find

00:19:24.350 --> 00:19:27.560
a UI element under a given point,
a bunch of these Carbon events

00:19:27.570 --> 00:19:29.060
are going to get sent out.

00:19:29.320 --> 00:19:31.960
One's first going to get sent to
the application accessible object,

00:19:31.960 --> 00:19:34.460
and it'll say, oh, okay,
this window's under the point.

00:19:34.640 --> 00:19:36.540
Then that window will
be sent the same event,

00:19:36.540 --> 00:19:39.030
and it'll say, okay,
this first-order control

00:19:39.030 --> 00:19:40.260
is under that point.

00:19:40.320 --> 00:19:42.880
Then we'll send the event
to that first-order control,

00:19:42.880 --> 00:19:44.820
and it'll say, okay,
this sub-control's under that point.

00:19:44.820 --> 00:19:47.120
And we'll keep going until
somebody finally says,

00:19:47.320 --> 00:19:49.670
oh, not handled,
there's no child under that point.

00:19:49.830 --> 00:19:53.190
And at that instance, the engine knows,
okay,

00:19:53.190 --> 00:19:54.960
the last person I ask is the leaf node.

00:19:54.980 --> 00:19:57.470
So you want to make sure
when you handle this event,

00:19:57.470 --> 00:19:59.600
only return your immediate children.

00:20:00.600 --> 00:20:02.940
So, okay, I want to give you an
interesting code example here,

00:20:03.050 --> 00:20:07.470
and this kind of plays into the
notion of injecting one of your

00:20:07.470 --> 00:20:09.540
HI objects into the hierarchy.

00:20:09.640 --> 00:20:13.470
So for purposes of this
example and some of the others,

00:20:13.520 --> 00:20:16.110
I'm going to assume we're
trying to make an application

00:20:16.110 --> 00:20:18.710
with a text editor accessible,
and that text editor is

00:20:18.710 --> 00:20:19.970
not based on any controls.

00:20:19.980 --> 00:20:22.630
You've got your own custom
text editing engine,

00:20:22.630 --> 00:20:25.290
but you've built an
HI object to represent that,

00:20:25.290 --> 00:20:28.170
and you want to make sure that
that HI object is reported

00:20:28.260 --> 00:20:29.900
as a child of the window.

00:20:30.500 --> 00:20:33.600
So to do that, like I mentioned before,
you want to override the

00:20:33.600 --> 00:20:36.610
window's handling of the
getChildAtPoint Carbon event,

00:20:36.700 --> 00:20:36.900
right?

00:20:36.900 --> 00:20:39.750
Because your engine is
going to be in the window,

00:20:39.770 --> 00:20:43.130
and if the mouse is over that engine,
you want to make sure

00:20:43.130 --> 00:20:45.370
to return that child,
not the one that the window

00:20:45.370 --> 00:20:47.460
normally would have returned,
which is probably going to be some

00:20:47.460 --> 00:20:48.510
control or something like that.

00:20:50.060 --> 00:20:52.840
Okay,
so this code in here would be in the

00:20:52.840 --> 00:20:57.500
handler that you write and install on
the window to override its handling

00:20:57.500 --> 00:20:59.700
of the getChildAtPoint Carbon event.

00:20:59.700 --> 00:21:02.380
The first thing you would do
is pull the accessible object

00:21:02.850 --> 00:21:03.750
out of the Carbon event.

00:21:03.820 --> 00:21:07.090
This is the accessible object
that the request is being made of.

00:21:07.090 --> 00:21:09.410
In this case,
it's going to be the window.

00:21:09.710 --> 00:21:12.800
Here's a subtle point that you
want to remember when you're

00:21:12.800 --> 00:21:14.800
overwriting somebody's handling.

00:21:14.900 --> 00:21:17.980
You've just got a UI element out,
and presumably, well,

00:21:18.160 --> 00:21:21.570
that UI element will contain the
HI object that is the window ref

00:21:21.590 --> 00:21:25.100
to whom the Carbon event was sent,
but that UI element might also

00:21:25.110 --> 00:21:28.320
have some identifier in it,
some non-zero identifier.

00:21:28.320 --> 00:21:31.750
Remember, like I was saying,
a non-zero identifier refers to

00:21:31.870 --> 00:21:33.740
some subcomponent of the window.

00:21:33.740 --> 00:21:37.740
I'm going to get the identifier out,
and if that identifier is not zero,

00:21:37.750 --> 00:21:40.550
I'm going to say, okay,
I don't want to handle this.

00:21:40.550 --> 00:21:43.950
I don't want to override the window's
handling of fetch me a child of,

00:21:44.010 --> 00:21:46.800
you know, the close box,
because I don't want my engine

00:21:46.800 --> 00:21:48.340
to be a child of the close box.

00:21:48.340 --> 00:21:52.660
So I'd return event not handled
error if I get a non-zero identifier.

00:21:52.660 --> 00:21:55.150
So assuming I don't get
a non-zero identifier,

00:21:55.150 --> 00:21:57.770
I fetch the next parameter out,
which is the global

00:21:57.890 --> 00:22:00.830
screen mouse location,
convert it from global to local,

00:22:00.940 --> 00:22:04.740
and then I'm going to ask my text editor,
hey, do you contain this point?

00:22:04.760 --> 00:22:07.870
And if it says no, then, again,
I don't want to handle it.

00:22:07.940 --> 00:22:11.250
I want to let the windows
default handling of this event

00:22:11.250 --> 00:22:12.190
take care of the situation.

00:22:12.190 --> 00:22:15.530
You know, maybe the window might return,
oh, some controls under the

00:22:15.530 --> 00:22:17.370
mouse or something like that.

00:22:18.390 --> 00:22:20.160
But assuming it is
within the text editor,

00:22:20.160 --> 00:22:23.570
you would call your text
editor to create a UI element.

00:22:23.580 --> 00:22:25.290
So you've got a hold of that.

00:22:25.480 --> 00:22:28.130
And then you put that in the Carbon event
in one of the return parameters.

00:22:28.140 --> 00:22:30.630
In particular, you say, okay,
this UI element,

00:22:30.680 --> 00:22:32.440
this is the accessible child parameter.

00:22:32.440 --> 00:22:35.620
And at that point,
you can release the UI element

00:22:35.620 --> 00:22:38.170
and return no error because
you've completely handled it.

00:22:38.200 --> 00:22:40.380
You just said, hey,
my engine is a child of the window.

00:22:40.380 --> 00:22:45.170
Carbon event savvy people who've
used them a lot might see something

00:22:45.170 --> 00:22:46.740
really scary in this batch of code.

00:22:47.660 --> 00:22:50.010
In particular, I do an allocation.

00:22:50.060 --> 00:22:52.280
I stick that allocation
in the Carbon event,

00:22:52.280 --> 00:22:54.800
and then I deallocate the memory.

00:22:54.800 --> 00:22:58.740
And then when I return,
you might be thinking, oh,

00:22:58.740 --> 00:23:01.120
problems are going to ensue because,
you know,

00:23:01.120 --> 00:23:04.020
the subsystem is going to try to pull
this parameter out and act on it,

00:23:04.020 --> 00:23:05.520
and I've disposed it,
and we're going to blow up.

00:23:05.790 --> 00:23:06.630
Well, no, we're not.

00:23:06.680 --> 00:23:07.920
I actually fixed Jaguar.

00:23:07.920 --> 00:23:09.500
Oh, whoops.

00:23:09.520 --> 00:23:10.470
I guess I don't know if it's live.

00:23:10.480 --> 00:23:14.420
If we see a CF type come in
as a Carbon event parameter,

00:23:14.420 --> 00:23:16.440
we'll retain it.

00:23:17.210 --> 00:23:20.120
That reference will be valid for
the life of that Carbon event.

00:23:20.140 --> 00:23:22.180
So you can do these kind
of convenient things.

00:23:22.180 --> 00:23:28.940
So this will work for any CF type ref
that is put into a Carbon event parameter

00:23:28.940 --> 00:23:31.620
with one of the type CF type ref types.

00:23:31.620 --> 00:23:33.060
Oh, that's kind of confusing.

00:23:33.060 --> 00:23:35.890
But on the slide, you can obviously see
type CF type ref up there.

00:23:35.900 --> 00:23:39.520
But it'll also work for the
various other type CF refs that

00:23:39.520 --> 00:23:40.390
we've defined in the headers.

00:23:40.400 --> 00:23:42.790
It's like a type
CFStringRef and type CFArrayRef.

00:23:42.930 --> 00:23:44.270
We do all the magic with those two.

00:23:45.830 --> 00:23:48.080
Okay, so the next Carbon event
I want to talk about is the

00:23:48.080 --> 00:23:50.870
GetFocusedChild Carbon event.

00:23:50.910 --> 00:23:52.800
Just like the
GetChildAtPoint Carbon event,

00:23:52.800 --> 00:23:56.470
this one tunnels down automatically,
so you want to make sure you

00:23:56.470 --> 00:23:59.840
only return the leaf node child
that might be focused of you.

00:23:59.840 --> 00:24:02.180
And if you don't have a
focused child within you,

00:24:02.180 --> 00:24:04.040
just say event not handled error.

00:24:04.040 --> 00:24:07.000
And again,
that just lets the subsystem know that,

00:24:07.000 --> 00:24:10.290
okay, they asked you,
you're probably the focused one,

00:24:10.290 --> 00:24:13.670
and it can make sure to return
you as the focused thing.

00:24:15.060 --> 00:24:18.140
The third way that they
can ask for UI elements is

00:24:18.220 --> 00:24:20.290
through familial references.

00:24:20.290 --> 00:24:24.670
They might ask for your children or your
parent or maybe some other attribute

00:24:24.670 --> 00:24:26.630
of you which is implicitly a child.

00:24:26.640 --> 00:24:30.180
Like we showed before,
the application supports an attribute,

00:24:30.180 --> 00:24:32.650
the menu bar, right,
and that's implicitly a

00:24:32.650 --> 00:24:34.300
child of the application.

00:24:34.300 --> 00:24:38.100
So all this is fundamentally
just a specific case of

00:24:38.100 --> 00:24:40.520
fetching attributes in general.

00:24:40.520 --> 00:24:44.420
So attributes of a UI element are
just pieces of data that you can

00:24:44.420 --> 00:24:44.420
record and use to fetch attributes.

00:24:44.420 --> 00:24:59.810
So all this is fundamentally just a
specific case of fetch attributes.

00:24:59.810 --> 00:24:59.810
So all this is fundamentally just a
specific case of fetch attributes.

00:25:01.040 --> 00:25:05.240
Yeah, so we saw the examples.

00:25:05.240 --> 00:25:07.720
Now,
certain attributes we consider required,

00:25:07.720 --> 00:25:10.150
and we're still working on
exactly what the required set is,

00:25:10.320 --> 00:25:12.120
but my current thinking is this.

00:25:12.810 --> 00:25:14.700
Every UI element must have a role.

00:25:14.710 --> 00:25:18.010
The role describes a
UI element's basic purpose,

00:25:18.010 --> 00:25:18.610
right?

00:25:18.700 --> 00:25:19.480
Are you a button?

00:25:19.480 --> 00:25:22.430
Are you a checkbox or a window
or a menu or something like that?

00:25:22.490 --> 00:25:26.950
And this allows the assistive application
to make some internal logical decisions

00:25:26.950 --> 00:25:30.980
about what the user might be able to
do with that particular UI element.

00:25:31.000 --> 00:25:35.310
But it's important to note that even
though the role is a CFStringRef,

00:25:35.310 --> 00:25:40.080
it's not intended to be
communicated to the user via speech.

00:25:40.080 --> 00:25:42.610
In our case,
all the standard roles that we

00:25:42.610 --> 00:25:47.070
return are prefixed with K-A-X,
or sorry, just A-X and then some name.

00:25:47.170 --> 00:25:49.550
So you generally don't want to read that.

00:25:49.720 --> 00:25:53.000
If you do want to present
something readable to the user,

00:25:53.000 --> 00:25:56.850
you would ask for the role description,
and so it's up to you guys

00:25:56.850 --> 00:26:01.560
to supply a readable role
description for your various items.

00:26:01.730 --> 00:26:04.370
For instance, if you have a button,
its role description might actually

00:26:04.370 --> 00:26:05.590
be button or something similar.

00:26:05.860 --> 00:26:08.650
Likewise, well,
and this is kind of a subtle point,

00:26:08.650 --> 00:26:10.540
the size and position attributes,

00:26:13.250 --> 00:26:17.550
So if I step back for a sec, UI elements,
pretty much, not pretty much,

00:26:17.780 --> 00:26:20.420
they should only represent
what's on screen.

00:26:20.420 --> 00:26:24.650
It would be kind of silly to have a
UI element that represents something

00:26:24.650 --> 00:26:28.810
that the user couldn't see or that
a conventional user couldn't see.

00:26:28.960 --> 00:26:33.640
So any UI element, since it's on screen,
is going to have a size and position.

00:26:33.640 --> 00:26:36.560
We've got a couple new
types to talk about those,

00:26:36.560 --> 00:26:38.120
AX size and AX position.

00:26:38.120 --> 00:26:41.760
Those are defined in the
accessibility headers.

00:26:41.760 --> 00:26:45.980
But if you like, for convenience,
and since HITooLbox supports them,

00:26:45.980 --> 00:26:51.300
you can also pass those back in
terms of an HI size or an HI point.

00:26:51.300 --> 00:26:54.830
And likewise,
any attributes that should be represented

00:26:54.840 --> 00:26:57.500
as UI elements are UI elements,
right?

00:26:57.500 --> 00:27:00.660
You can pass back,
if somebody asks you for your parent,

00:27:00.730 --> 00:27:02.750
you're going to want to pass
back an actual AX UI element

00:27:02.750 --> 00:27:04.040
ref to represent the parent.

00:27:04.160 --> 00:27:06.250
And likewise,
if they ask you for your children,

00:27:06.410 --> 00:27:09.260
you want to pass back a
CFArray of AX UI element refs

00:27:09.260 --> 00:27:11.690
that represent your children.

00:27:12.650 --> 00:27:15.340
Okay, so the first Carbon event
having to do with attributes

00:27:15.420 --> 00:27:17.520
is get all attribute names.

00:27:17.580 --> 00:27:20.230
It's got two pieces of information in it,
the UI element to whom the

00:27:20.230 --> 00:27:24.300
question's being asked,
and a CFArrayRef for you to fill out

00:27:24.300 --> 00:27:29.240
with all of the attribute names that
your accessible object supports.

00:27:29.260 --> 00:27:29.830
So that's your job.

00:27:29.910 --> 00:27:33.270
You handle the event simply by filling
up this array with a bunch of strings

00:27:33.300 --> 00:27:35.420
representing the attributes you support.

00:27:35.560 --> 00:27:38.500
We've got a ton,
a ton of attribute names in the header.

00:27:38.570 --> 00:27:42.150
An important thing to realize
is that we're still working on

00:27:42.150 --> 00:27:44.020
this set of attribute names.

00:27:44.020 --> 00:27:46.900
You're going to see some flux
between now and when Jaguar actually,

00:27:46.980 --> 00:27:47.960
actually ships.

00:27:48.080 --> 00:27:50.320
We want to kind of refine the
set of attribute names down

00:27:50.390 --> 00:27:53.870
into some reasonable group,
at least the default attribute names.

00:27:53.870 --> 00:27:57.020
But you're free to return
whatever attribute names you want.

00:27:57.060 --> 00:28:00.660
If you want a really,
really rich accessibility application,

00:28:00.660 --> 00:28:04.220
sorry, accessibility implementation
in your application,

00:28:04.220 --> 00:28:07.510
you know,
you can pass in 30 or 40 attributes as

00:28:07.510 --> 00:28:09.870
supported by one of your UI elements.

00:28:10.080 --> 00:28:13.580
So let me run through a quick example.

00:28:13.580 --> 00:28:18.620
Unlike the last example,
this is a handler that's

00:28:18.620 --> 00:28:19.950
installed on your HI object.

00:28:20.050 --> 00:28:23.640
This is not some patch
on some other HI object.

00:28:24.300 --> 00:28:28.070
But like the other example,
this might show you what a text engine

00:28:28.070 --> 00:28:33.540
would do in terms of reporting the
attributes that it wants to support.

00:28:33.540 --> 00:28:35.220
So we receive the Carbon event.

00:28:35.220 --> 00:28:38.220
We pull out the mutable array
ref that we need to fill up.

00:28:38.220 --> 00:28:41.920
And then we're going to put in
all the required attribute names,

00:28:41.940 --> 00:28:45.220
you know, role, role description, parent,
children, all those things.

00:28:45.220 --> 00:28:48.980
And then we're going to put in our
more interesting attribute names

00:28:48.980 --> 00:28:51.110
that are specific to a text engine.

00:28:51.190 --> 00:28:52.700
You're probably going to want
to supply a text attribute,

00:28:52.700 --> 00:28:53.010
right?

00:28:53.010 --> 00:28:53.750
You're a text engine.

00:28:53.750 --> 00:28:55.460
You need to supply text.

00:28:55.460 --> 00:28:57.710
You probably also want to
support the selection attribute

00:28:57.710 --> 00:29:01.140
so that a screen reader might
be able to tell the user that,

00:29:01.370 --> 00:29:04.160
yeah,
characters 50 through 100 are selected,

00:29:04.160 --> 00:29:05.640
and maybe others.

00:29:05.640 --> 00:29:07.320
And then you return -- oh,
and then you return no error,

00:29:07.320 --> 00:29:07.840
and you're done.

00:29:07.840 --> 00:29:09.190
Thank you.

00:29:11.540 --> 00:29:14.340
So the next Carbon event
is Get Named Attribute.

00:29:14.340 --> 00:29:18.800
This will be sent to you when the
assistive application has a UI element

00:29:18.800 --> 00:29:22.560
and it's found out what attributes you
support and it wants to find out what the

00:29:22.560 --> 00:29:24.860
data is behind one of those attributes.

00:29:24.860 --> 00:29:28.320
So the Carbon event contains, obviously,
the UI element to whom the

00:29:28.320 --> 00:29:31.260
question is being asked,
and then CFStringRef of

00:29:31.260 --> 00:29:35.070
the attribute name that the
assistive app is interested in.

00:29:35.350 --> 00:29:38.140
And your responsibility is
simply to pass back the data

00:29:38.460 --> 00:29:40.870
that represents that attribute.

00:29:41.940 --> 00:29:43.230
is an expert in the world of text.

00:29:43.240 --> 00:29:44.910
So let me give you a
quick example of that.

00:29:44.910 --> 00:29:46.900
You're going to pull out the
name that you're interested in.

00:29:46.900 --> 00:29:48.960
At this point,
I've already pulled out the UI element,

00:29:49.070 --> 00:29:50.700
if that's at all interesting to me.

00:29:50.870 --> 00:29:53.080
So here I'm pulling
out the attribute name,

00:29:53.340 --> 00:29:56.370
and I'm going to do a test to
see if it's the text attribute.

00:29:56.370 --> 00:29:58.720
You know,
I'm going to have a bunch of if else,

00:29:58.720 --> 00:30:01.230
if else, if else,
and this happens to be the first one.

00:30:01.330 --> 00:30:05.060
So if I find out it is a
request for the text attribute,

00:30:05.180 --> 00:30:08.280
I'm going to put the data into the event.

00:30:08.280 --> 00:30:12.130
So I'll ask my text engine, hey,
please create a CFString for me.

00:30:12.330 --> 00:30:14.900
I've got the string,
and then I shove that back

00:30:14.990 --> 00:30:17.910
in the Carbon event as an
output parameter in the,

00:30:17.910 --> 00:30:21.040
what is it,
accessible attribute value parameter,

00:30:21.040 --> 00:30:23.340
and then I release the
string to clean up,

00:30:23.340 --> 00:30:25.580
and I'll return no error.

00:30:25.580 --> 00:30:29.890
One important thing to note is
the suite of Carbon events and

00:30:29.900 --> 00:30:32.360
the assistive applications really,
really,

00:30:32.360 --> 00:30:34.260
really want you to return CF types.

00:30:34.260 --> 00:30:37.980
It's a very generic way
of representing data.

00:30:37.980 --> 00:30:42.400
So when possible, return attribute values
in terms of CF types.

00:30:42.460 --> 00:30:44.310
The toolbox does a little
bit of conversion for you for

00:30:44.310 --> 00:30:45.560
some of the things like H.I.

00:30:45.560 --> 00:30:46.340
points and H.I.

00:30:46.340 --> 00:30:50.400
sizes, and we will, you know, likewise,
if you happen to put data in the

00:30:50.400 --> 00:30:55.870
event that's type Unicode text,
we'll build a CFString rep out of that.

00:30:56.000 --> 00:30:57.780
But, you know,
we can't cover all the bases,

00:30:57.780 --> 00:31:01.070
so we're kind of leaning on you
guys to make sure you return the

00:31:01.070 --> 00:31:03.080
data in the form of a CF type.

00:31:03.080 --> 00:31:05.740
And this is particularly important
because ultimately this data

00:31:05.740 --> 00:31:07.680
needs to get sent cross process.

00:31:07.880 --> 00:31:11.280
And CF has a very convenient,
easy way for us to send

00:31:11.380 --> 00:31:15.550
this data across process,
and other types don't necessarily.

00:31:18.110 --> 00:31:20.780
So attributes aren't just static.

00:31:20.920 --> 00:31:22.550
Some of them can be changed.

00:31:22.680 --> 00:31:25.120
And assistive applications
might want to find out,

00:31:25.120 --> 00:31:27.760
hey,
which of your attributes are changeable?

00:31:27.760 --> 00:31:31.900
And they would do that by calling
into the Accessibility APIs.

00:31:31.900 --> 00:31:36.350
And then we would send your UI element
the isNamedAttributeSetableCarbon event.

00:31:36.650 --> 00:31:37.600
Really straightforward.

00:31:37.630 --> 00:31:38.990
They're going to give
you your UI element.

00:31:39.030 --> 00:31:41.050
They're going to give
you the attribute name.

00:31:41.210 --> 00:31:44.340
And your job is simply to return a
Boolean that represents whether or

00:31:44.450 --> 00:31:46.120
not that attribute can be modified.

00:31:46.290 --> 00:31:50.430
If you don't support the event or if
you return event not handled error,

00:31:50.530 --> 00:31:54.520
it's just an assumption that that
particular attribute is non-modifiable.

00:31:54.520 --> 00:31:58.240
So if in your implementation you find,
okay, I've got this UI element.

00:31:58.240 --> 00:31:59.880
I want to support these attributes.

00:32:00.010 --> 00:32:01.440
But none of them are modifiable.

00:32:01.560 --> 00:32:04.010
You don't even need to
support this Carbon event.

00:32:05.500 --> 00:32:08.200
So just as a quick example of this,
we're going to get the attribute

00:32:08.210 --> 00:32:10.970
name out of the Carbon event,
take a look, and in this case,

00:32:11.060 --> 00:32:12.330
it happens to be our text.

00:32:12.330 --> 00:32:16.520
So we see that it's the text,
and we want to allow the assistive

00:32:16.520 --> 00:32:18.950
application to change the text.

00:32:19.030 --> 00:32:20.560
We want this to be a
modifiable attribute.

00:32:20.560 --> 00:32:24.550
So we set our Boolean value to true,
we stick it in the Carbon event,

00:32:24.550 --> 00:32:25.420
and return.

00:32:25.420 --> 00:32:26.870
That's all you need to do for that.

00:32:27.820 --> 00:32:30.420
So once the assistive
application has found out that,

00:32:30.500 --> 00:32:32.760
yeah,
I've got this settable attribute here,

00:32:32.760 --> 00:32:34.930
it may present that
information to the user,

00:32:35.000 --> 00:32:38.050
and the user says, okay,
change this attribute to some value,

00:32:38.060 --> 00:32:40.820
you will receive the set
named attribute Carbon event.

00:32:40.830 --> 00:32:43.240
And that's going to contain
three pieces of data,

00:32:43.240 --> 00:32:46.590
the UI element, the attribute name,
and the data that the user wants to

00:32:46.680 --> 00:32:48.540
have inserted into that attribute.

00:32:48.540 --> 00:32:51.790
So your job simply is to take the data
out of the Carbon event and put it

00:32:51.790 --> 00:32:54.560
into whatever your implementation is.

00:32:54.560 --> 00:32:55.020
So in this case,
we get the attribute name,

00:32:55.020 --> 00:32:55.590
we see that it's the attribute name,
and we want to allow the user to

00:32:55.590 --> 00:32:55.900
change the attribute to some value.

00:32:55.940 --> 00:32:56.490
So we set our Boolean value to true,
we stick it in the Carbon event,

00:32:56.490 --> 00:32:56.610
and return.

00:32:56.610 --> 00:32:57.240
That's all you need to do for that.

00:32:57.240 --> 00:32:59.100
We see that it's the text again.

00:32:59.100 --> 00:33:02.970
So now we're going to need to extract
the data out of the Carbon event and

00:33:03.090 --> 00:33:06.480
push it into our text editing engine,
which is fairly straightforward.

00:33:06.480 --> 00:33:10.060
The data coming into the
Carbon event is in the accessible

00:33:10.060 --> 00:33:12.040
attribute value parameter.

00:33:12.040 --> 00:33:13.940
So we pull the data out.

00:33:14.200 --> 00:33:15.880
You want to check for no error here.

00:33:15.880 --> 00:33:17.450
Let me step back real quick.

00:33:17.760 --> 00:33:21.000
When I'm pulling the data here,
pulling the data out here,

00:33:21.000 --> 00:33:23.940
I'm actually asking for
it as generic CF type ref.

00:33:24.060 --> 00:33:26.650
We do have more specific types in there.

00:33:26.660 --> 00:33:29.960
But generally,
just -- you want to ask for

00:33:29.960 --> 00:33:33.420
it as the generic CF type ref,
and then later,

00:33:33.420 --> 00:33:36.800
dynamically look and see what real type
it is and see if you can handle it.

00:33:36.800 --> 00:33:38.880
And I've got an example
of that in the slide.

00:33:39.180 --> 00:33:42.980
Now, it's possible that the data
that the app sent you can't be

00:33:42.980 --> 00:33:46.120
translated to the type you requested.

00:33:46.150 --> 00:33:49.340
And if that's the case,
you're going to receive an error back.

00:33:49.340 --> 00:33:52.270
And if you get that error,
go ahead and stop processing.

00:33:52.790 --> 00:33:57.660
: Otherwise, we get some valid data,
and I know my text engine can

00:33:57.730 --> 00:34:01.810
only handle CF types--sorry,
can only handle CFStrings for

00:34:01.810 --> 00:34:04.660
purposes of shoving data into it.

00:34:04.850 --> 00:34:08.590
So here I want to check the actual
CF type ID of the data I got

00:34:08.590 --> 00:34:10.400
and make sure it's a string.

00:34:10.400 --> 00:34:13.240
And if it's not a string,
I know I can't handle it,

00:34:13.240 --> 00:34:16.900
so I'm just going to say event
not handle error and be done.

00:34:16.900 --> 00:34:19.200
Otherwise,
I'm going to tell my text engine, "Hey,

00:34:19.200 --> 00:34:22.420
please set your text to this."
It's pretty straightforward.

00:34:22.440 --> 00:34:24.820
And then you're going to return no error.

00:34:26.240 --> 00:34:30.290
So one way that assistive
applications will want to affect

00:34:30.390 --> 00:34:35.310
your app is in terms of actions.

00:34:35.500 --> 00:34:52.700
[Transcript missing]

00:34:53.720 --> 00:35:13.980
: It's lots of things
you can do with actions.

00:35:13.980 --> 00:35:13.980
Obviously, press is the big example.

00:35:13.980 --> 00:35:13.980
Picking a menu item is a big example.

00:35:13.980 --> 00:35:13.980
But you want to think pretty carefully
about what actions you support.

00:35:13.980 --> 00:35:13.980
If something can be better
represented as settable attributes,

00:35:13.980 --> 00:35:13.980
go ahead and do it as a settable
attribute as opposed to an action.

00:35:16.410 --> 00:35:18.270
So this is going to look really familiar.

00:35:18.310 --> 00:35:22.330
The first action related Carbon event is
the means for an assistive application

00:35:22.330 --> 00:35:26.260
to find out all the actions that
your particular UI element supports.

00:35:26.260 --> 00:35:29.220
This is virtually identical to
the get all attribute names.

00:35:29.270 --> 00:35:32.070
Just put the word action in
there instead and you return

00:35:32.090 --> 00:35:33.700
different stuff in the array.

00:35:33.730 --> 00:35:36.900
We have a bunch of standard
actions in the headers and just

00:35:36.900 --> 00:35:39.950
as with the attribute names,
the action names are in

00:35:39.950 --> 00:35:40.980
a little bit of flux.

00:35:40.980 --> 00:35:44.180
We want to figure out what the default
set of actions are and And so you

00:35:44.180 --> 00:35:47.110
will see some changes to the header
when Jaguar is finally shipped.

00:35:50.190 --> 00:35:52.260
So the next interesting thing
about actions is the notion

00:35:52.310 --> 00:35:55.600
of an action description.

00:35:55.600 --> 00:35:59.980
Action strings are generally
not meant to be human readable.

00:36:00.040 --> 00:36:02.220
Our default strings are
all prefixed with AX,

00:36:02.230 --> 00:36:02.570
right?

00:36:02.610 --> 00:36:05.990
And it wouldn't be reasonable
to say this button represents,

00:36:06.060 --> 00:36:09.150
or sorry,
this button supports the AXPRESS action.

00:36:09.210 --> 00:36:10.800
That wouldn't make any sense whatsoever.

00:36:10.800 --> 00:36:14.580
But assistive apps do need to
communicate what the meaning

00:36:14.580 --> 00:36:16.520
of an action is to the user.

00:36:16.520 --> 00:36:20.040
And they do that by finding out
what the action's description is.

00:36:20.100 --> 00:36:22.900
So when an assistive app
needs to find that out,

00:36:22.900 --> 00:36:27.120
your UI element will be sent the get
named action description Carbon event.

00:36:27.190 --> 00:36:29.920
It's going to contain the UI element,
the action name that

00:36:29.930 --> 00:36:32.820
they're interested in,
and a modifiable string ref that you

00:36:32.820 --> 00:36:36.570
need to fill out with a sort of human
readable description of the action.

00:36:36.580 --> 00:36:40.250
Another important thing to note
is that these strings that you

00:36:40.250 --> 00:36:43.840
return that are human readable,
they should be localized,

00:36:43.860 --> 00:36:47.230
and they should match whatever
language your app happens

00:36:47.230 --> 00:36:49.100
to be running in right now.

00:36:53.040 --> 00:36:55.200
So finally,
an assistive app has found out, okay,

00:36:55.200 --> 00:36:57.070
yeah, this widget supports some action.

00:36:57.080 --> 00:36:57.950
All right, invoke it.

00:36:57.980 --> 00:37:01.150
And when they want to invoke it,
your UI element will be sent the

00:37:01.180 --> 00:37:03.050
form named action CarbonEvent.

00:37:03.050 --> 00:37:06.780
It's got the UI element in it and the
action name that they want to invoke.

00:37:06.780 --> 00:37:09.370
And your job is simply to
make the interface react,

00:37:09.370 --> 00:37:10.600
do the right thing.

00:37:12.700 --> 00:37:15.130
So here's another example.

00:37:15.160 --> 00:37:19.990
This is pulled out almost verbatim
from our push button control.

00:37:20.040 --> 00:37:21.480
But this is one example where
you might want the button

00:37:21.480 --> 00:37:22.590
to support the press action.

00:37:22.860 --> 00:37:25.600
You're going to pull out the UI element.

00:37:26.350 --> 00:37:29.160
And in this case,
we're going to also get the

00:37:29.250 --> 00:37:31.150
HI object out of the UI element.

00:37:31.150 --> 00:37:33.630
In this particular case,
the HI object will be

00:37:33.760 --> 00:37:35.240
the button's control ref.

00:37:35.310 --> 00:37:38.380
And then we call the
HIViewSimulateClick API,

00:37:38.380 --> 00:37:42.540
which is an HIView API that we added
in Jaguar to do click simulation.

00:37:42.600 --> 00:37:45.500
You can think of this as a
wrap around the old technique

00:37:45.580 --> 00:37:48.690
of calling highlight control,
delay, highlight control,

00:37:48.690 --> 00:37:50.930
but it does it in a more
Carbon event-based fashion.

00:37:51.080 --> 00:37:54.360
And there's some hooks for CDEFs to
get in there and modify the behaviors.

00:37:54.360 --> 00:37:58.060
But the other really cool thing
about HIViewSimulateClick is

00:37:58.060 --> 00:38:02.080
that it has the same post-click
behaviors as something like handle

00:38:02.080 --> 00:38:06.440
control click or track control,
in that if the view that you're clicking

00:38:06.440 --> 00:38:10.950
or the control that you're clicking
has a command ID associated with it,

00:38:11.060 --> 00:38:12.570
HIViewSimulateClick will make sure
that you're clicking on the button.

00:38:12.610 --> 00:38:14.730
sure to send out that command
ID so that the rest of your

00:38:14.740 --> 00:38:17.550
interface can react appropriately.

00:38:18.230 --> 00:38:23.570
Okay, so here's another subtle point,
but since assistive applications

00:38:23.640 --> 00:38:28.610
are going to be invoking press
actions in buttons that the system

00:38:28.780 --> 00:38:33.740
has already made accessible,
you will not be able to react to that

00:38:33.740 --> 00:38:38.340
button press unless you've got a handler
that handles that button's command.

00:38:38.340 --> 00:38:41.160
So let me give you kind
of a roundabout example.

00:38:41.160 --> 00:38:45.330
If you've got an application
probably ported from original 9 code,

00:38:45.410 --> 00:38:48.790
wait next event based,
and you're event handling

00:38:48.790 --> 00:38:51.080
looks something like,
okay, wait next event,

00:38:51.080 --> 00:38:54.030
I got a mouse down event, okay,
is that mouse down event in the window?

00:38:54.030 --> 00:38:57.260
Yeah, it's in a window, okay,
find control, oh, I found a control,

00:38:57.260 --> 00:39:00.660
okay, I need to call track control,
I call track control,

00:39:00.760 --> 00:39:03.710
I found out that K button part was hit,
and now I have this big switch

00:39:03.750 --> 00:39:06.820
statement and a bunch of ifs to say,
okay, which control was hit,

00:39:06.850 --> 00:39:09.500
if that button was hit,
go off and do some action.

00:39:09.550 --> 00:39:14.140
That works great if you're getting
events in through wait next event,

00:39:14.340 --> 00:39:17.510
but that sort of technique will not
work when an assistive application

00:39:17.510 --> 00:39:19.370
is telling you that you're not
getting your button to press,

00:39:19.370 --> 00:39:22.480
because this button press is going to
come in completely behind your back.

00:39:22.610 --> 00:39:25.350
The system is just going
to see this press request,

00:39:25.350 --> 00:39:29.060
we're going to flash the button,
and your app needs to react.

00:39:29.130 --> 00:39:33.650
Likewise, if you are used to handling
your menu commands by calling

00:39:33.650 --> 00:39:36.900
menu select or menu event,
looking what the result was,

00:39:37.020 --> 00:39:39.790
and then doing some big switch
case statement and figuring out

00:39:39.790 --> 00:39:42.170
what functionality to trigger,
that also won't work with

00:39:42.290 --> 00:39:44.550
assistive applications that
try to pick your menu items,

00:39:44.550 --> 00:39:46.690
because, of course,
that menu selection is also going to

00:39:46.710 --> 00:39:47.980
happen completely behind your back.

00:39:48.030 --> 00:39:48.960
So you're going to have to do that.

00:39:49.040 --> 00:39:52.720
So your only way to hook in
to an assistive application's

00:39:52.720 --> 00:39:57.850
triggering of controls and
menus is through H I commands.

00:39:57.960 --> 00:39:59.500
We've talked about this in the past.

00:39:59.620 --> 00:40:04.780
We've got some documentation out there,
but basically H I commands are a

00:40:04.870 --> 00:40:10.340
simple way to put these four character
constants into your controls and menus,

00:40:10.340 --> 00:40:15.040
and you will be informed when a menu
item is chosen or a control is clicked

00:40:15.160 --> 00:40:18.020
by that command ID through Carbon events.

00:40:18.020 --> 00:40:20.170
So, you can see here,
the button's command ID is

00:40:20.170 --> 00:40:23.220
sent out first to the button,
then to the button's parent,

00:40:23.220 --> 00:40:24.480
things like that.

00:40:24.480 --> 00:40:28.430
We have a feature in Jaguar
whereby I think controls and

00:40:28.430 --> 00:40:30.040
menus can have their commands.

00:40:30.040 --> 00:40:31.490
I'm looking for Eric to nod.

00:40:31.600 --> 00:40:35.500
Both controls and menus can have
their commands sent to the user focus.

00:40:38.530 --> 00:40:38.740
Okay.

00:40:38.740 --> 00:40:40.540
Okay.

00:40:40.540 --> 00:40:43.420
So menus automatically have their
commands sent to the user focus,

00:40:43.420 --> 00:40:44.620
and I think controls can, too.

00:40:44.620 --> 00:40:47.600
So just put a bunch of the
standard or custom commands in

00:40:47.600 --> 00:40:51.350
your menu items and your controls,
and then take out all that code you

00:40:51.350 --> 00:40:54.750
do after calling handle control click,
where you look at it,

00:40:54.750 --> 00:40:57.870
see if it was a button part,
see what control was hitting,

00:40:58.000 --> 00:40:59.090
all that stuff.

00:40:59.160 --> 00:41:01.800
Take out all the post menu
select code that you do with

00:41:01.800 --> 00:41:05.050
the big switch case statements,
and turn that into Carbon event

00:41:05.190 --> 00:41:08.790
handlers that listen for the k
event command process Carbon event.

00:41:08.800 --> 00:41:12.140
You can put those on your windows
or your controls or even the

00:41:12.140 --> 00:41:14.230
application as you find easiest.

00:41:16.260 --> 00:41:19.380
So the third major piece of
functionality with respect to

00:41:19.380 --> 00:41:21.580
accessibility are notifications.

00:41:21.640 --> 00:41:25.280
These are ways that a UI element can say,
"Hey, something happened to me.

00:41:25.280 --> 00:41:28.620
You know, my value changed if
I'm a scroll bar," or,

00:41:28.620 --> 00:41:33.280
you know,
"A window moved," or something like that.

00:41:34.130 --> 00:41:39.550
An assistive application will register
for specific notifications on your app,

00:41:39.760 --> 00:41:43.370
but you want to go ahead and call
the API that I'll show you here

00:41:43.540 --> 00:41:49.070
in a second whenever anything
happens to your HI object.

00:41:49.130 --> 00:41:52.090
And the system will make sure to
only send a cross-process message

00:41:52.130 --> 00:41:55.160
if somebody's actually interested in
hearing that notification cross-process.

00:41:55.160 --> 00:41:57.130
And of course,
we're going to send out all

00:41:57.130 --> 00:41:59.980
the normal notifications for
all of our standard widgets,

00:42:00.150 --> 00:42:03.370
and all you need to do is the work
for your custom implementations.

00:42:03.380 --> 00:42:08.760
And again, we've got lots of standard
notification strings in the header.

00:42:08.880 --> 00:42:12.870
And that is probably the most
influx suite of constants.

00:42:13.010 --> 00:42:15.060
We were just talking
about it the other day.

00:42:15.060 --> 00:42:17.360
We need to figure out what the
right set of notifications is that

00:42:17.600 --> 00:42:20.910
still provides a rich enough set
of information for assistive apps,

00:42:20.910 --> 00:42:24.850
but isn't cumbersome for people to adopt,
particularly us.

00:42:24.920 --> 00:42:27.660
You know, we've got a lot of controls
to send out information for.

00:42:27.740 --> 00:42:29.410
So we need to find the right balance.

00:42:31.390 --> 00:42:33.900
So the notification posting
example is really simple.

00:42:33.900 --> 00:42:36.640
It's just one line of code.

00:42:36.640 --> 00:42:39.210
You don't actually supply
a UI element to this API.

00:42:39.210 --> 00:42:42.600
It would be kind of silly considering
we're just going to take that

00:42:42.600 --> 00:42:44.300
UI element apart in the implementation.

00:42:44.300 --> 00:42:47.580
So you just call the notify API,
pass the notification

00:42:47.580 --> 00:42:50.040
you're interested in,
and then the two separate

00:42:50.040 --> 00:42:51.840
component parts of the UI element.

00:42:51.840 --> 00:42:54.320
You pass your HI object, ref,
and the identifier.

00:42:54.320 --> 00:42:55.650
And the engine will do the right thing.

00:42:55.650 --> 00:42:57.430
It will send it
cross-process if it needs to,

00:42:57.430 --> 00:43:00.990
or it will just be nice and
quiet if it doesn't need to.

00:43:02.080 --> 00:43:05.180
So some of my examples today
were in the text space.

00:43:05.520 --> 00:43:08.320
And the reason for that is
text is probably the most

00:43:08.320 --> 00:43:14.160
important thing to represent for
a truly accessible application.

00:43:14.160 --> 00:43:17.950
A huge space of assistive applications
are completely broken if you

00:43:17.980 --> 00:43:20.530
can't report the text in your app.

00:43:20.670 --> 00:43:23.900
So please, when you're implementing your
custom accessibility support,

00:43:23.900 --> 00:43:27.270
make sure all the text in your app
is reported as best as possible.

00:43:27.400 --> 00:43:29.430
Even if you can just do
something really simple,

00:43:29.440 --> 00:43:32.010
which is, OK,
I've got an HI object that represents

00:43:32.120 --> 00:43:34.630
the entire text of my document,
that's going to be more

00:43:34.650 --> 00:43:35.680
useful than nothing.

00:43:35.780 --> 00:43:37.480
But if you can make it richer, hey,
great.

00:43:37.540 --> 00:43:42.120
You know, start reporting paragraphs or
individual words if you can.

00:43:43.760 --> 00:43:48.220
And keyboard navigation is also
a big part of accessibility,

00:43:48.510 --> 00:43:52.300
but it's sort of a
separate piece of adoption.

00:43:52.410 --> 00:43:56.700
We've greatly expanded what parts of the
system are keyboard navigable in Jaguar.

00:43:56.700 --> 00:43:59.200
You can switch up to the menu
bar and start choosing items

00:43:59.200 --> 00:44:00.700
and navigate between menus.

00:44:00.700 --> 00:44:03.670
You can navigate between
windows in the whole system or

00:44:03.780 --> 00:44:05.070
windows in your application.

00:44:05.070 --> 00:44:08.600
You can move the focus to toolbars,
and you can now focus to a

00:44:08.600 --> 00:44:10.780
much wider variety of controls.

00:44:10.780 --> 00:44:13.560
We've tried to make all the system
controls keyboard navigable.

00:44:13.710 --> 00:44:17.830
And we'd really like you guys
to make the custom parts of your

00:44:17.830 --> 00:44:20.110
application keyboard navigable.

00:44:20.110 --> 00:44:21.860
I mean,
you're going to fit in better on Jaguar,

00:44:21.860 --> 00:44:23.330
because it's going to
look really strange when,

00:44:23.380 --> 00:44:25.840
hey, I can focus to the standard
system push buttons,

00:44:25.840 --> 00:44:28.490
but I can't focus to this
application's custom push buttons.

00:44:28.580 --> 00:44:28.840
Why?

00:44:28.840 --> 00:44:33.620
But it also is going to
make assistive apps easier,

00:44:33.730 --> 00:44:36.560
and it'll make users of assistive
apps also have an easier time,

00:44:36.620 --> 00:44:38.420
because a lot of them
can't use the mouse,

00:44:38.520 --> 00:44:41.370
and they rely on using the
keyboard as much as possible.

00:44:41.720 --> 00:44:45.290
I talked an awful lot about keyboard
navigation yesterday in our new

00:44:45.290 --> 00:44:47.010
controls and services session.

00:44:47.010 --> 00:44:50.160
If you didn't get a chance to go
to that and see all the details,

00:44:50.160 --> 00:44:52.150
grab the DVD and take a look at that.

00:44:54.660 --> 00:44:58.260
I mentioned this a couple times,
but this is all still in flux.

00:44:58.260 --> 00:45:01.590
We really want to hear your feedback,
but more importantly,

00:45:01.710 --> 00:45:03.570
some of the stuff I've talked
about today isn't implemented yet.

00:45:03.630 --> 00:45:06.640
The notification API,
the Carbon side of that

00:45:06.640 --> 00:45:07.700
is not implemented.

00:45:07.700 --> 00:45:10.700
That will be implemented, obviously,
by the time we ship.

00:45:10.960 --> 00:45:14.220
And likewise,
the ability for you to mark an HI object

00:45:14.360 --> 00:45:16.800
as ignored is also not exported.

00:45:16.800 --> 00:45:20.220
And we're going to try to nail down
the set of attributes and actions

00:45:20.220 --> 00:45:23.160
and notifications as soon as we can,
and we'd love to hear

00:45:23.160 --> 00:45:24.580
your guys' opinions.

00:45:24.640 --> 00:45:29.080
We've taken a look at lots of
other accessibility solutions,

00:45:29.130 --> 00:45:32.600
and there's lots of ways of doing things.

00:45:32.600 --> 00:45:35.530
We've got our own opinions on it,
but your feedback will be

00:45:35.730 --> 00:45:37.050
really important to us.

00:45:37.050 --> 00:45:40.050
And likewise,
if you get a chance to try out Jaguar

00:45:40.050 --> 00:45:44.760
and you play with the various sample apps
that they showed in the last session,

00:45:44.810 --> 00:45:49.530
you'll see that there's a wide variety
of levels of support in the system.

00:45:49.530 --> 00:45:52.010
Right now,
the work I've been doing and my fellow

00:45:52.010 --> 00:45:55.680
teammates have been doing on Carbon,
trails a little bit behind Cocoa.

00:45:55.680 --> 00:45:58.610
So you'll see some applications
that report tons and tons of stuff,

00:45:58.810 --> 00:46:01.490
and you go in other applications and
it supports a smaller subset of stuff.

00:46:01.630 --> 00:46:03.710
Realize that we're still working on this.

00:46:03.840 --> 00:46:06.600
We are going to make sure that we have
full parity between Carbon and Cocoa,

00:46:06.600 --> 00:46:10.050
and that if you get a UI element
that represents a button,

00:46:10.050 --> 00:46:13.200
if you're an assistive app,
you shouldn't be able to tell whether

00:46:13.210 --> 00:46:14.970
that's a Carbon or Cocoa button.

00:46:14.970 --> 00:46:17.240
And we're going to try to make
sure of that by reporting the

00:46:17.240 --> 00:46:20.000
exact same set of actions and
attributes and stuff like that.

00:46:23.040 --> 00:46:25.200
So to sum up,
there's about four things you want

00:46:25.200 --> 00:46:26.710
to do to make your app accessible.

00:46:26.820 --> 00:46:28.720
Make sure you switch over
to using HI commands.

00:46:28.720 --> 00:46:30.510
Put those in your menus
and your controls.

00:46:30.690 --> 00:46:33.200
Because without that,
assistive apps will not be

00:46:33.220 --> 00:46:34.960
able to drive your interface.

00:46:34.960 --> 00:46:38.180
And then make sure to wire up your
custom content for the appropriate

00:46:38.230 --> 00:46:39.860
accessibility Carbon events.

00:46:39.860 --> 00:46:43.080
And send notifications for any
meaningful state change that

00:46:43.080 --> 00:46:44.600
happened in your HI objects.

00:46:44.600 --> 00:46:46.350
And get keyboard navigation in there.

00:46:46.350 --> 00:46:49.320
You know, you may be thinking of that
as an accessibility feature,

00:46:49.320 --> 00:46:50.910
but it's really just a
general user feature,

00:46:50.910 --> 00:46:52.590
and everybody's going
to find that useful.

00:46:54.690 --> 00:46:57.600
We've already got
documentation out there.

00:46:57.740 --> 00:46:59.240
I think both of these are on the CD.

00:46:59.240 --> 00:47:02.440
No, it looks like one's on the -- oh,
maybe both are on the web.

00:47:02.440 --> 00:47:05.980
We have documentation that takes you
over what I've talked about and what

00:47:05.980 --> 00:47:09.420
they talked about in the last session,
the overview and the C APIs that

00:47:09.430 --> 00:47:11.840
an assistive application would use.

00:47:11.840 --> 00:47:14.480
And we also have a white paper that
kind of explains what we're doing

00:47:14.480 --> 00:47:17.040
from a conceptual point of view,
gives us some of the background

00:47:17.040 --> 00:47:19.120
of what we're doing and some
of our thinking behind it.

00:47:19.200 --> 00:47:21.470
So check those out if you can.

00:47:22.260 --> 00:47:24.960
And unfortunately, everything on the
roadmaps already happened,

00:47:24.960 --> 00:47:27.290
so if you didn't get a chance
to go to these various sessions,

00:47:27.490 --> 00:47:28.840
get the DVD, check them out.

00:47:28.890 --> 00:47:31.640
We talk about a lot of
important information in there.

00:47:31.640 --> 00:47:35.570
In particular,
session 204 is where we define HI objects

00:47:35.720 --> 00:47:39.890
and how we show how they're the future,
and we explain how controls, windows,

00:47:39.890 --> 00:47:43.500
and menus all fit into the
notion of the HI object.

00:47:43.500 --> 00:47:47.060
And we'll show you how to-- that
session also shows you how to

00:47:47.090 --> 00:47:48.860
create HI objects and manage them.

00:47:48.860 --> 00:47:51.140
And you'll need to know how to
do that when you're making custom

00:47:51.190 --> 00:47:52.520
parts of your app accessible.

00:47:52.710 --> 00:47:55.920
And session 203 talks about
the Carbon Event basics,

00:47:55.920 --> 00:48:00.470
how to install Carbon Event handlers,
how to handle them, and things like that.

00:48:00.570 --> 00:48:02.520
So if you're unfamiliar with
Carbon Events and this is

00:48:02.520 --> 00:48:05.060
gonna be your first foray in,
you want to check out that session,

00:48:05.060 --> 00:48:06.560
get some of the basics.

00:48:06.560 --> 00:48:09.560
The session right before this
was the Accessibility Overview,

00:48:09.840 --> 00:48:12.360
where it talks about maybe
more conceptual stuff,

00:48:12.370 --> 00:48:14.850
and it also shows you the
APIs you need to use if you

00:48:14.930 --> 00:48:17.900
want to write an assistive app,
like a screen reader.

00:48:18.450 --> 00:48:21.430
and Travis Brown is our WWDR contact.

00:48:21.580 --> 00:48:24.240
So if you have any questions
or feedback about this stuff,

00:48:24.310 --> 00:48:24.900
drop him an email.

00:48:24.900 --> 00:48:28.240
And I'd like to bring him up
now to lead us through some Q&A.

00:48:28.500 --> 00:48:28.620
Travis.
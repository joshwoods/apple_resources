WEBVTT

00:00:03.010 --> 00:00:05.800
This is session 807, Bluetooth In-Depth.

00:00:05.940 --> 00:00:09.430
And with that,
I'd like to introduce Michael Larson,

00:00:09.740 --> 00:00:12.900
who is the manager of
Bluetooth Engineering at Apple.

00:00:22.300 --> 00:00:22.780
Thanks, Tom.

00:00:22.780 --> 00:00:26.880
I'd like to welcome everyone
to WWDC this week again.

00:00:26.880 --> 00:00:31.380
I'm here to talk to you about Bluetooth,
what kind of code we've

00:00:31.540 --> 00:00:35.520
written to support Bluetooth,
what the APIs that we're

00:00:35.520 --> 00:00:39.560
going to provide to you in an
SDK later this afternoon are,

00:00:39.560 --> 00:00:45.320
and what you can do by expanding on our
support of Bluetooth using our APIs to

00:00:45.320 --> 00:00:49.060
make applications that support Bluetooth.

00:00:51.640 --> 00:00:55.570
and use our APIs to make it even better.

00:00:55.960 --> 00:01:00.090
I'm going to start off with a brief
description of Bluetooth technology,

00:01:00.090 --> 00:01:04.920
an overview of the technology,
including the terms

00:01:04.920 --> 00:01:09.820
used in the technology,
how RF implementations are

00:01:09.820 --> 00:01:13.530
built up between two devices,
and how data gets transferred

00:01:13.570 --> 00:01:15.000
between the devices.

00:01:15.660 --> 00:01:19.320
I'll follow that up with an
overview of our implementation

00:01:19.320 --> 00:01:24.110
of Bluetooth technology,
including the framework that we provide,

00:01:24.200 --> 00:01:29.720
and the objects that you can use to use
our framework to develop applications.

00:01:29.720 --> 00:01:34.420
Also included in that will be our
kernel objects that you can use to

00:01:34.420 --> 00:01:39.960
write drivers for new and special
hardware using different transport types

00:01:39.960 --> 00:01:43.180
that Apple does not provide support for.

00:01:47.010 --> 00:01:51.400
We'll kick it off with Bluetooth basics,
how Bluetooth works,

00:01:51.470 --> 00:01:53.720
and basic terminology
terms for Bluetooth,

00:01:53.720 --> 00:01:59.110
then go into Apple's implementation,
show you how to find devices,

00:01:59.110 --> 00:02:02.620
query the services that
are on those devices,

00:02:02.620 --> 00:02:07.140
and open the different channel types
to transfer data between devices.

00:02:12.030 --> 00:02:13.700
So what is Bluetooth?

00:02:13.730 --> 00:02:17.120
We started looking at Bluetooth some
time ago and implementing what

00:02:17.160 --> 00:02:18.700
we've released now in Preview 2.

00:02:18.700 --> 00:02:23.400
Bluetooth is a very low-bandwidth,
short-range wireless protocol.

00:02:23.400 --> 00:02:25.850
As you heard in the
previous presentation,

00:02:25.850 --> 00:02:29.830
if you attended that,
we intended to be used for peripherals

00:02:29.980 --> 00:02:33.920
and not as a networking protocol because
of its low bandwidth and short range.

00:02:33.920 --> 00:02:37.270
In order to get data to
transfer over Bluetooth,

00:02:37.270 --> 00:02:40.720
it happens over a series
of layered protocols.

00:02:41.730 --> 00:02:44.060
At the very bottom,
there's a baseband connection.

00:02:44.060 --> 00:02:48.750
A baseband connection represents
the lowest level RF link

00:02:48.750 --> 00:02:51.240
between two radio devices.

00:02:52.980 --> 00:02:56.050
On top of this baseband
connection to transfer data,

00:02:56.050 --> 00:02:59.100
there's a protocol called L2CAP.

00:02:59.650 --> 00:03:03.420
L2CAP is, we'll go into that a
little more in depth later,

00:03:03.420 --> 00:03:05.820
but it's a basic data transfer protocol.

00:03:05.820 --> 00:03:10.650
On top of L2CAP,
Bluetooth has built a thing called RFCOM.

00:03:10.660 --> 00:03:13.800
RFCOM is a serial emulation layer.

00:03:13.800 --> 00:03:15.140
We'll also go into that later.

00:03:15.140 --> 00:03:19.580
And an additional protocol
on top of RFCOM is OBEX.

00:03:19.680 --> 00:03:22.320
If any of you were involved
in the old IR days,

00:03:22.390 --> 00:03:26.680
you might remember OBEX as it's a
protocol left over from those days.

00:03:28.500 --> 00:03:32.040
Bluetooth devices are
identified by a 6-byte address.

00:03:32.040 --> 00:03:35.520
It's identical to an Ethernet address.

00:03:35.520 --> 00:03:37.360
In fact,
it's assigned by the same organization.

00:03:37.440 --> 00:03:43.260
So if you use Apple's preview
implementation and the D-Link card,

00:03:43.260 --> 00:03:47.350
you'll find that the device address that
you get for Bluetooth is actually the

00:03:47.350 --> 00:03:49.260
same as your built-in Ethernet address.

00:03:54.020 --> 00:03:57.620
So let's get into some more
of the basics of Bluetooth.

00:03:57.640 --> 00:04:00.820
In order to build connections,
there are really two

00:04:01.230 --> 00:04:02.560
modes a device can be in.

00:04:02.560 --> 00:04:07.800
A device can be either discoverable
or connectable or both.

00:04:07.800 --> 00:04:11.430
They're really independent states.

00:04:11.630 --> 00:04:14.560
So what does it mean to be discoverable?

00:04:14.560 --> 00:04:18.400
When a device is discoverable,
a remote device can use what's known

00:04:18.470 --> 00:04:20.690
as an inquiry to find that device.

00:04:20.780 --> 00:04:23.400
If you saw the Bluetooth demo
in the last presentation,

00:04:23.500 --> 00:04:27.290
there was an inquiry done there to
find all other devices within range.

00:04:27.320 --> 00:04:32.720
This is a generic mechanism used to
find the devices that are within that

00:04:32.720 --> 00:04:36.620
30-foot range of Bluetooth connectivity.

00:04:38.660 --> 00:04:42.400
So that is a mode that you will
put your device in if you want

00:04:42.490 --> 00:04:44.450
to be able to be found by others.

00:04:44.450 --> 00:04:47.310
Sometimes that's not a good thing,
so we provide the

00:04:47.420 --> 00:04:48.840
ability to turn that off.

00:04:48.940 --> 00:04:51.830
For example, cell phones,
a lot of times you don't

00:04:51.830 --> 00:04:55.500
want to be able to be found,
but you'd like to connect them.

00:04:55.500 --> 00:04:59.990
So that takes us into the next
aspect of the Bluetooth connectivity,

00:04:59.990 --> 00:05:01.700
which is connectable.

00:05:02.740 --> 00:05:04.970
It's a different concept
than discoverable,

00:05:05.130 --> 00:05:08.400
so that if devices are looking
for you and you're connectable,

00:05:08.400 --> 00:05:10.580
you won't respond to inquiry requests.

00:05:10.600 --> 00:05:13.780
But if they know about you
explicitly through a prior inquiry,

00:05:13.780 --> 00:05:16.130
or someone's provided
you the device address,

00:05:16.180 --> 00:05:18.400
they will be able to build a connection.

00:05:18.400 --> 00:05:22.350
This way, you can design a device
that can allow connections,

00:05:22.350 --> 00:05:25.450
but will not be found if
someone's trying to just,

00:05:25.490 --> 00:05:28.100
for example,
show up in this hall and find

00:05:28.150 --> 00:05:31.740
out what other devices are
around and cause trouble.

00:05:32.340 --> 00:05:34.130
So they're mutually exclusive states.

00:05:34.210 --> 00:05:39.410
You can use those to design devices
and design them so that they behave

00:05:39.410 --> 00:05:42.440
exactly like you would want them to,
and users can control that

00:05:42.440 --> 00:05:43.730
behavior independently.

00:05:45.910 --> 00:05:49.900
There are a number of security
concepts with Bluetooth.

00:05:50.040 --> 00:05:52.440
The first one is a paired relationship.

00:05:52.530 --> 00:05:57.830
If you can create a paired relationship
between two different devices so

00:05:57.830 --> 00:06:03.470
that you no longer have to do some
initial setup or ask for passwords

00:06:03.540 --> 00:06:07.320
each time you connect-- for example,
I've paired my Bluetooth laptop

00:06:07.320 --> 00:06:11.910
with my Bluetooth phone so that
all future connections happen

00:06:12.400 --> 00:06:15.030
without any user intervention.

00:06:15.210 --> 00:06:19.280
Pairing works by using a shared secret
that's never transmitted across the air.

00:06:19.280 --> 00:06:22.160
That secret's known as a passkey.

00:06:22.160 --> 00:06:25.300
So the first time I go to
pair my laptop with my phone,

00:06:25.540 --> 00:06:29.850
I enter the same passkey on both devices.

00:06:30.070 --> 00:06:33.500
And that passkey is used
to create a link key.

00:06:33.530 --> 00:06:37.330
That link key is stored inside the
hardware and also on the computer

00:06:37.330 --> 00:06:42.540
so it can be provided for future
connections without user intervention.

00:06:42.570 --> 00:06:45.550
Link keys can also be deleted so
that if you want to delete that

00:06:45.550 --> 00:06:49.370
paired relationship with a device,
you can do that.

00:06:53.000 --> 00:06:56.520
Another security concept
with Bluetooth is encryption.

00:06:56.520 --> 00:07:02.040
A Bluetooth link can require encryption
or it cannot require encryption.

00:07:02.080 --> 00:07:04.320
That's up to the particular service type.

00:07:04.370 --> 00:07:07.610
An encryption is done
inside the hardware.

00:07:08.400 --> 00:07:12.740
One of the items used to determine
the encryption is the link key,

00:07:12.740 --> 00:07:16.470
so that encryption is very
useful for paired devices.

00:07:16.470 --> 00:07:21.490
The link key is used as a seed to the
encryption engine to provide 128-bit

00:07:21.490 --> 00:07:24.500
encryption for the Bluetooth connection.

00:07:29.190 --> 00:07:34.070
That covers the basic introduction
to Bluetooth technology,

00:07:34.490 --> 00:07:38.120
and we're going to cover
where we position it here.

00:07:38.120 --> 00:07:42.430
We really view it on this slide
as a peripheral technology

00:07:42.550 --> 00:07:45.140
using a wireless connection.

00:07:45.140 --> 00:07:48.760
It doesn't mean that USB and
FireWire devices are going away.

00:07:48.760 --> 00:07:51.630
They have much higher speed,
but also have the burden of cables.

00:07:51.640 --> 00:07:58.510
This is for very low-bandwidth devices
that can really use the cable to be cut.

00:07:58.780 --> 00:08:01.050
So cell phones are an obvious choice.

00:08:01.120 --> 00:08:04.520
PDAs are another good choice,
and there are several other out there.

00:08:04.520 --> 00:08:08.620
And that's what we would like to see
you guys start to get into and find

00:08:08.820 --> 00:08:12.760
those other cables to cut and provide
some other functionality over Bluetooth.

00:08:16.640 --> 00:08:20.580
We released Preview 1 about a
month ago at Macworld Tokyo.

00:08:20.590 --> 00:08:23.960
Preview 2 is going to be released
this afternoon and really doesn't

00:08:24.020 --> 00:08:28.810
add any new profile support but
adds some additional UI and polish

00:08:28.810 --> 00:08:30.990
to what we did in Preview 1.

00:08:31.500 --> 00:08:37.580
What we support in Preview 1 and also
Preview 2 are three primary profiles.

00:08:37.580 --> 00:08:39.830
The first being dial-up networking.

00:08:39.830 --> 00:08:45.190
Dial-up networking replaces the
IR or serial cable link that would

00:08:45.190 --> 00:08:49.220
previously exist between a laptop
and a cell phone with Bluetooth.

00:08:50.810 --> 00:08:55.380
The serial port profile also replaces
the cable that would previously

00:08:55.410 --> 00:08:57.780
exist between a PDA and a laptop.

00:08:57.780 --> 00:09:02.620
And then object push enables a quick
exchange of objects or small files

00:09:02.620 --> 00:09:05.760
between two Bluetooth-enabled devices.

00:09:05.760 --> 00:09:10.420
This can be used to quickly
exchange a small file about

00:09:10.560 --> 00:09:16.020
several hundred K or so between a
PDA and a laptop or two laptops,

00:09:16.020 --> 00:09:20.520
or send a V-card to your phone so you
don't have to enter it on the keypad.

00:09:24.180 --> 00:09:27.780
So let's get into what the
Bluetooth stack looks like.

00:09:27.780 --> 00:09:30.390
At the very bottom of the stack,
there's a Bluetooth module.

00:09:30.390 --> 00:09:35.660
That'll be a hardware device,
rather it be a USB device like we

00:09:35.660 --> 00:09:38.640
have with the D-Link module that
we introduced about a month ago,

00:09:38.640 --> 00:09:41.730
or it's a serial controller,
or a PC card,

00:09:41.730 --> 00:09:46.620
whatever type of transport it is,
there's a Bluetooth module.

00:09:47.220 --> 00:09:51.240
On top of that, there are several other
protocols and profiles that are

00:09:51.320 --> 00:09:54.100
used to talk to that module,
and we'll go into those in a little

00:09:54.100 --> 00:09:55.690
more depth in the following slides.

00:09:58.910 --> 00:10:02.900
The first layer that's used to
talk to a Bluetooth module is HCI.

00:10:02.900 --> 00:10:05.880
HCI stands for host controller interface.

00:10:05.880 --> 00:10:10.440
It's an abstraction to be able to
send commands and receive events

00:10:10.440 --> 00:10:12.860
and transfer data to the radio.

00:10:12.860 --> 00:10:17.000
So using a well-defined
protocol called HCI,

00:10:17.160 --> 00:10:21.850
we can talk to any type of
Bluetooth device over USB or

00:10:22.090 --> 00:10:27.960
serial or PCI as long as it
conforms to the HCI protocol.

00:10:27.960 --> 00:10:32.770
And a driver needs to be written
underneath this to transmit the data in

00:10:32.770 --> 00:10:35.560
the HCI format into whatever bus it is.

00:10:36.050 --> 00:10:37.980
Apple's provided a USB driver.

00:10:37.980 --> 00:10:41.430
There are currently no other
drivers that Apple provides.

00:10:41.460 --> 00:10:42.840
That's an opportunity for you guys.

00:10:42.860 --> 00:10:46.600
To go write a serial one if you want
to support a serial device or PC card,

00:10:46.780 --> 00:10:48.620
whatever else there is out there.

00:10:52.370 --> 00:10:55.730
On top of HCI, we need a layer,
a protocol layer,

00:10:55.820 --> 00:10:57.520
to transmit data between two devices.

00:10:57.660 --> 00:11:00.070
This layer is called L2CAP.

00:11:00.140 --> 00:11:06.050
It's a link control layer to transfer
simple data between two devices.

00:11:06.060 --> 00:11:10.380
Once there's a baseband connection,
which is created using an HCI call,

00:11:10.380 --> 00:11:13.630
you can use L2CAP calls to
open independent channels and

00:11:14.120 --> 00:11:16.010
transfer data between two devices.

00:11:16.020 --> 00:11:20.030
L2CAP supports a number of things,
including different channel

00:11:20.030 --> 00:11:24.240
types and channel IDs,
and one of its primary goals is to

00:11:24.240 --> 00:11:29.420
segment and reassemble different packets
according to the maximum packet size.

00:11:33.800 --> 00:11:35.900
On top of L2CAP is RFCOM.

00:11:35.900 --> 00:11:40.840
RFCOM's primary purpose in life
is to make a data channel appear

00:11:40.840 --> 00:11:43.650
to be a legacy serial port.

00:11:43.660 --> 00:11:48.380
So it has mechanisms to open
multiplex data channels.

00:11:48.380 --> 00:11:53.610
You can have several channels over
an L2CAP channel to a remote device.

00:11:53.620 --> 00:11:56.640
And on top of that,
it adds some primitives

00:11:56.830 --> 00:11:58.840
to set serial port speeds.

00:11:59.010 --> 00:12:02.630
So if you were actually talking to a
device that had a real serial port,

00:12:02.640 --> 00:12:06.460
you could control those speed settings
like it were a real serial cable.

00:12:06.460 --> 00:12:10.390
And an RFCOM channel,
or the multiple RFCOM channels,

00:12:10.390 --> 00:12:15.610
will use a single L2CAP channel as
its transport to the remote device.

00:12:19.540 --> 00:12:26.730
Kind of a peer to RFCOM in terms of
them both using an L2CAP channel is SDP.

00:12:26.850 --> 00:12:32.000
SDP is a service discovery protocol,
and it is used to query remote devices

00:12:32.000 --> 00:12:34.420
about what services they support.

00:12:34.420 --> 00:12:39.520
So if you have a remote device that
you found through a prior inquiry,

00:12:39.520 --> 00:12:43.020
and you want to know whether it supports
the service you're interested in,

00:12:43.020 --> 00:12:47.560
you can use SDP to query that device
and find out whether it supports it.

00:12:47.630 --> 00:12:50.980
You can query it as to whether it
supports a serial port profile,

00:12:50.980 --> 00:12:55.500
and it will respond with all its services
that are serial port profile services.

00:12:55.500 --> 00:12:58.440
Or you can query it as to whether
it supports dial-up networking,

00:12:58.440 --> 00:13:01.260
and it will tell you whether
it supports dial-up networking.

00:13:01.260 --> 00:13:04.350
It also uses an L2CAP channel
as its transport,

00:13:04.470 --> 00:13:08.180
and there's a single
L2CAP channel to be used for SDP.

00:13:10.830 --> 00:13:13.520
On top of RFCOM, there is OBEX.

00:13:13.520 --> 00:13:16.670
OBEX,
if any of you know it from the IR days,

00:13:16.830 --> 00:13:20.550
is an HTTP-like protocol,
and it transfers simple

00:13:20.550 --> 00:13:22.660
objects to another device.

00:13:22.780 --> 00:13:28.860
It uses primitives like PUT and
GET to transfer blocks of data.

00:13:28.860 --> 00:13:36.180
The OBEX protocol is based on the V1.2
version of the IR OBEX specification.

00:13:36.660 --> 00:13:40.910
This is an area where Bluetooth has said,
there's already something that exists

00:13:40.910 --> 00:13:44.100
out there in the world that does the
data transfer the way we want to.

00:13:44.100 --> 00:13:49.010
We'll just leverage that and map
those rules onto Bluetooth technology

00:13:49.010 --> 00:13:52.500
rather than IR technology,
and we'll get all the other

00:13:52.550 --> 00:13:54.940
applications that know OBEX for free.

00:13:54.940 --> 00:13:59.090
OBEX uses an RFCOM channel as
its transport because of the

00:13:59.090 --> 00:14:02.260
similarities between IRTA and serial.

00:14:07.410 --> 00:14:12.280
So that's the description of all the
Bluetooth protocols and how they're used.

00:14:12.350 --> 00:14:13.620
It's a brief description.

00:14:13.620 --> 00:14:18.690
Now, in order to use those on
Mac OS X with either Puma or Jaguar,

00:14:18.790 --> 00:14:20.740
we're releasing a SDK.

00:14:20.870 --> 00:14:24.920
It should be on the web this afternoon,
and the URL will be available

00:14:24.920 --> 00:14:26.770
later in the presentation.

00:14:28.720 --> 00:14:33.500
And alongside the SDK,
we're also posting Preview Release 2

00:14:33.500 --> 00:14:38.250
for the end users that might want to
upgrade their software and see what the

00:14:38.250 --> 00:14:40.160
latest support we have for Bluetooth is.

00:14:41.970 --> 00:14:45.340
In terms of the SDK,
there's two important things to know.

00:14:45.340 --> 00:14:49.160
One is it's a superset,
a complete superset of Preview Release 2.

00:14:49.160 --> 00:14:52.960
So if you install the SDK,
you do not need Preview Release 2.

00:14:52.960 --> 00:14:54.370
It's all included there.

00:14:54.380 --> 00:14:58.440
The SDK installs header files and
the frameworks you need to develop

00:14:58.440 --> 00:15:03.400
applications using Bluetooth,
which Preview Release 2 does not install.

00:15:04.340 --> 00:15:07.590
And there are two separate
SDK versions since you guys

00:15:07.730 --> 00:15:09.820
just got a Jaguar Preview CD.

00:15:09.820 --> 00:15:12.340
We've developed one
that works under Jaguar,

00:15:12.340 --> 00:15:13.740
and there's a separate one for Puma.

00:15:13.740 --> 00:15:20.070
So whichever version of the OS you
feel comfortable developing for,

00:15:20.170 --> 00:15:23.190
there's SDKs for both of those.

00:15:27.960 --> 00:15:29.920
What is the SDK going to give you?

00:15:29.920 --> 00:15:34.800
We provide access to a number
of APIs through the SDK.

00:15:34.800 --> 00:15:40.880
The first two are our in-kernel APIs,
the HCI controller,

00:15:40.910 --> 00:15:44.220
which is the bottom block on the
stack diagram we just covered,

00:15:44.220 --> 00:15:49.200
and then the USB HCI controller,
which is Apple's specific implementation

00:15:49.200 --> 00:15:52.490
of an HCI controller to work over USB.

00:15:52.720 --> 00:15:56.900
HCI, we'll cover those in-depth
in the next slide.

00:15:56.930 --> 00:16:01.940
There's also a number of
user-level APIs that we provide.

00:16:01.940 --> 00:16:05.910
We provide objects that
represent a Bluetooth device,

00:16:05.910 --> 00:16:11.740
an L2CAP channel, an RF-COM channel,
or an OBEX session.

00:16:11.740 --> 00:16:16.870
We also provide objects that represent
the service discovery profile objects

00:16:16.900 --> 00:16:19.630
that exist between two devices.

00:16:22.390 --> 00:16:24.550
Looking at the kernel objects,
the first is the

00:16:24.620 --> 00:16:26.300
IO Bluetooth HCI controller.

00:16:26.300 --> 00:16:29.500
It's a representation of
a generic HCI controller.

00:16:29.500 --> 00:16:33.080
This is the base class that you
want to look at if you want to

00:16:33.080 --> 00:16:37.250
write an I/O Kit driver for a
different type of Bluetooth hardware,

00:16:37.250 --> 00:16:37.830
i.e.

00:16:37.830 --> 00:16:41.250
a PC card or something that
Apple does not provide.

00:16:44.020 --> 00:16:50.400
The class is available in the SDK and the
documentation is available there as well.

00:16:50.960 --> 00:16:56.130
In addition to the base HCI controller,
we have a USB HCI controller.

00:16:56.130 --> 00:17:00.270
If you have a USB bit of hardware
that more or less works with

00:17:00.390 --> 00:17:03.880
our class driver implementation,
because our USB driver in the

00:17:03.890 --> 00:17:07.740
preview release and the SDK is
a generic USB class driver,

00:17:07.740 --> 00:17:10.240
but it adds some
additional features like,

00:17:10.240 --> 00:17:14.330
say, a special LED to show something,
you can subclass this to add these

00:17:14.330 --> 00:17:16.830
special features for your USB device.

00:17:20.400 --> 00:17:22.540
In terms of what Apple has
done support for,

00:17:22.540 --> 00:17:26.790
Apple's supporting the USB driver,
and we have not looked at

00:17:26.810 --> 00:17:28.040
any other transports now.

00:17:28.040 --> 00:17:30.370
So if you have hardware
that uses the other one,

00:17:30.530 --> 00:17:34.090
this is a good opportunity to
provide the driver for that hardware.

00:17:37.810 --> 00:17:39.720
Getting into the user space objects.

00:17:39.780 --> 00:17:44.770
The way that the Bluetooth API is
designed from the user space,

00:17:44.870 --> 00:17:46.800
it's very object-oriented.

00:17:46.800 --> 00:17:51.180
There are objects to represent
all the different channels and

00:17:51.180 --> 00:17:53.790
the remote devices on the system.

00:17:55.140 --> 00:17:58.660
We also provide both a C version
and an Objective-C version of

00:17:58.690 --> 00:18:01.330
the APIs for the Bluetooth stack.

00:18:02.520 --> 00:18:05.100
In addition to that,
we've also provided some common

00:18:05.100 --> 00:18:08.600
UI elements so that you can call
and don't have to handle things

00:18:08.600 --> 00:18:10.760
like inquiries or SDP searches.

00:18:10.760 --> 00:18:14.820
You can just call one of our UI elements,
and we will bring up the UI and

00:18:14.820 --> 00:18:19.100
search for devices and do the service
discovery to find exactly the device

00:18:19.100 --> 00:18:21.560
or the service you're interested in.

00:18:23.080 --> 00:18:26.410
In order to provide similarity
between the C version and

00:18:26.410 --> 00:18:29.510
the Objective-C version,
we've adopted a naming convention,

00:18:29.580 --> 00:18:30.710
which is shown on the slide.

00:18:30.740 --> 00:18:33.630
The C version tacks on a
ref to the end of what the

00:18:33.630 --> 00:18:36.140
Objective-C version name would be.

00:18:42.040 --> 00:18:47.010
So getting into the IO Bluetooth device.

00:18:47.130 --> 00:18:53.900
This is the one object in our stack that
you can have that really does not need to

00:18:53.980 --> 00:18:56.090
have a concrete representation behind it.

00:18:56.200 --> 00:19:00.200
An IO Bluetooth device can be created
and can represent a remote device

00:19:00.200 --> 00:19:02.340
for which there is no connection.

00:19:04.080 --> 00:19:09.450
These devices can either be created
programmatically by code if you know

00:19:09.450 --> 00:19:14.260
the device address or have saved that
off from a previous device search.

00:19:17.000 --> 00:19:19.790
In addition to that,
this is the root object that you will

00:19:19.790 --> 00:19:23.440
use to create any type of connection
you would like to a remote device.

00:19:23.520 --> 00:19:26.300
The baseband connection
is started from here.

00:19:26.300 --> 00:19:29.970
You can open L2CAP channels using
the device as the root object.

00:19:30.020 --> 00:19:32.990
You can also open RFCOM channels,
and it's used for

00:19:33.110 --> 00:19:34.960
OBEX session connections.

00:19:34.960 --> 00:19:39.440
In addition, if you want to do any kind
of SDP service searches,

00:19:39.440 --> 00:19:42.870
the device is really the important
part to remember and use to

00:19:42.870 --> 00:19:44.640
do those service searches.

00:19:50.620 --> 00:19:53.950
On top of the device,
there's a Bluetooth L2CAP channel.

00:19:53.950 --> 00:19:56.620
These can exist.

00:19:56.760 --> 00:20:00.120
I said before that the device is the
only one that can exist without a

00:20:00.120 --> 00:20:01.960
concrete representation behind it.

00:20:02.140 --> 00:20:05.100
It's really the only one that
can be created without a concrete

00:20:05.210 --> 00:20:06.630
representation behind it.

00:20:06.720 --> 00:20:10.960
The rest of the channels,
like an L2CAP channel or future channels,

00:20:10.960 --> 00:20:13.930
can exist,
but they will have to be created when a

00:20:14.040 --> 00:20:16.760
concrete channel representation exists.

00:20:16.760 --> 00:20:20.260
They will exist after the
channel goes away behind it,

00:20:20.260 --> 00:20:23.070
but will return errors for all the calls.

00:20:23.480 --> 00:20:29.430
An IO Bluetooth L2CAT channel represents
the data conduit between the local device

00:20:29.560 --> 00:20:32.160
you're running on and a remote device.

00:20:32.210 --> 00:20:36.270
Using that data conduit,
there are commands to open the channel,

00:20:36.350 --> 00:20:39.400
read and write data to
and from the channel,

00:20:39.450 --> 00:20:41.400
and close the channel.

00:20:41.470 --> 00:20:46.170
And following the naming convention,
there's a C version that

00:20:46.170 --> 00:20:48.480
tacks on the ref to the name.

00:20:51.610 --> 00:20:56.110
On top of L2CAP,
we have the IO Bluetooth RF Comp channel.

00:20:56.290 --> 00:21:00.970
Similarly to L2CAP,
there are APIs to open, read, write,

00:21:01.120 --> 00:21:03.050
or close a channel.

00:21:03.280 --> 00:21:07.360
There are, in addition,
event notifications, and incoming data is

00:21:07.360 --> 00:21:09.130
considered an event type.

00:21:09.180 --> 00:21:13.630
But other event types for RFCOM might
be changing the serial port

00:21:13.630 --> 00:21:17.530
speed or some other bits of the
serial port emulation things that

00:21:17.680 --> 00:21:19.960
RFCOM handles and was designed to do.

00:21:23.480 --> 00:21:27.370
Also, following the naming convention,
just tack on the ref to the end

00:21:27.370 --> 00:21:29.040
of the name to get the C version.

00:21:33.880 --> 00:21:38.140
For implementation of the
service discovery profile,

00:21:38.140 --> 00:21:40.720
there are three things that you can do.

00:21:40.730 --> 00:21:43.020
You can create a service to Vend.

00:21:43.030 --> 00:21:45.760
If you write an application
that's Bluetooth-aware and say

00:21:45.760 --> 00:21:49.500
you wanted to provide a chat
application over Bluetooth,

00:21:49.510 --> 00:21:54.400
you would create a special chat service
and Vend that from your chat application,

00:21:54.400 --> 00:22:00.930
and that would enter our service database
to be Vended for other devices to query.

00:22:01.360 --> 00:22:04.820
If you're writing the chat
client on another machine,

00:22:04.820 --> 00:22:09.170
you will use the SDP APIs to go query
remote devices and find out if they

00:22:09.200 --> 00:22:13.300
support the chat service and then
exist and what channel that's on.

00:22:13.730 --> 00:22:16.890
There are a number of
SDP-specific classes,

00:22:17.250 --> 00:22:22.640
including the service record,
the service attribute, data element,

00:22:22.680 --> 00:22:23.760
and UUID.

00:22:24.250 --> 00:22:27.120
and their C versions for all those APIs.

00:22:27.250 --> 00:22:35.100
So a UUID is it's a UUID and the typical,
if you've used Core Foundation,

00:22:35.130 --> 00:22:36.810
they have UUID services.

00:22:36.810 --> 00:22:41.200
It's a 128-bit value that can
be reduced down to 16 or 32 bits

00:22:41.600 --> 00:22:43.960
to represent a unique service.

00:22:44.000 --> 00:22:49.430
The Bluetooth Special Interest Group has
defined a number of generic UUIDs.

00:22:49.430 --> 00:22:52.480
For example,
serial port has one or dial-up

00:22:52.480 --> 00:22:53.840
networking has another.

00:22:53.860 --> 00:22:58.040
If you were to create a chat
service that was your specific one,

00:22:58.070 --> 00:23:01.200
you would generate your own
128-bit value one and use that

00:23:01.350 --> 00:23:03.100
to identify the chat service.

00:23:05.900 --> 00:23:11.610
The data element and service attribute
classes are used to extract data from

00:23:11.610 --> 00:23:17.560
a service record and tell whether that
service has the attribute of chat or

00:23:17.560 --> 00:23:24.480
dial-up networking or whatever other
type of service you're looking for.

00:23:26.750 --> 00:23:31.810
On top of RF-COM, there's OBEX,
which is the generic object exchange.

00:23:31.810 --> 00:23:35.410
OBEX transfers happen
through an OBEX session.

00:23:35.410 --> 00:23:40.620
There's both a client session object
and a service session object that

00:23:40.620 --> 00:23:43.400
both work over an RF-COM channel.

00:23:43.550 --> 00:23:47.920
The current API that we're providing
in the SDK requires a pretty in-depth

00:23:48.050 --> 00:23:52.360
knowledge of the OBEX protocol in
terms of knowing when to respond

00:23:52.520 --> 00:23:54.130
to different portions of things.

00:23:54.200 --> 00:23:57.560
We do plan on releasing a
convenience API that will handle

00:23:57.560 --> 00:24:01.010
a lot of that for you if you
don't want to get that in-depth.

00:24:03.110 --> 00:24:05.420
In addition to that,
we plan to provide some simple

00:24:05.660 --> 00:24:08.320
file transfer services if you
just want to transfer a file

00:24:08.320 --> 00:24:09.800
from one device to another.

00:24:09.800 --> 00:24:13.510
That's coming in a future
version of the SDK.

00:24:15.770 --> 00:24:20.070
What is provided in the SDK today
are some simple OBEX header parsing

00:24:20.070 --> 00:24:23.660
utilities and creation utilities.

00:24:23.660 --> 00:24:29.380
In addition to that, to simplify OBEX,
we've provided some vCard or vObject,

00:24:29.380 --> 00:24:33.040
as we call them, creation utilities,
so you can create a vCard or a

00:24:33.040 --> 00:24:36.300
vCalendar event from code easily.

00:24:39.410 --> 00:24:42.560
So you've got your idea that you
want to implement over Bluetooth.

00:24:42.560 --> 00:24:45.750
Now you need to know how to do it.

00:24:46.100 --> 00:24:49.230
There are three UI elements
that you might want to use to

00:24:49.280 --> 00:24:53.230
either pair with the device,
find a particular service,

00:24:53.230 --> 00:24:54.930
or just find a remote device.

00:24:56.860 --> 00:25:02.190
These UI objects have common aspects
in terms of their ability to filter

00:25:02.190 --> 00:25:06.220
on different types of devices,
so you can find only phones

00:25:06.250 --> 00:25:09.560
or only laptops or whatever
device type you would like.

00:25:09.640 --> 00:25:13.920
They also have the ability to
filter out to only certain services,

00:25:13.920 --> 00:25:16.710
so if you're only interested
in devices that have your

00:25:16.710 --> 00:25:20.740
chat service as an example,
you can filter out only those devices.

00:25:26.180 --> 00:25:28.560
The first device is the pairing panel.

00:25:28.620 --> 00:25:31.560
If any of you had a chance
to play with Preview 1,

00:25:31.560 --> 00:25:34.140
you've probably seen this when you've
connected to your Bluetooth phone,

00:25:34.140 --> 00:25:34.840
if you've done that.

00:25:34.860 --> 00:25:38.620
This is a common UI element
available to any application,

00:25:38.620 --> 00:25:40.560
which is Bluetooth Aware.

00:25:40.560 --> 00:25:43.830
You can use this element to
find and create a paired device

00:25:43.950 --> 00:25:47.440
relationship between your
computer and a remote device.

00:25:52.990 --> 00:25:55.890
The second panel that's
available through our API in the

00:25:55.890 --> 00:25:57.700
SDK is a service search panel.

00:25:57.700 --> 00:26:02.780
This handles all the aspects of doing
the finding remote devices and doing

00:26:02.780 --> 00:26:04.510
the service searches for those devices.

00:26:04.620 --> 00:26:08.490
You can tell this panel when you
call it to look for certain device

00:26:08.490 --> 00:26:12.390
types or only certain service types,
and it will handle all the

00:26:12.390 --> 00:26:16.560
SDP transactions for you so you don't
have to go learn how to do that code

00:26:16.560 --> 00:26:18.120
and how to parse out those responses.

00:26:18.810 --> 00:26:22.080
All you need to do is provide the
service type that you're interested in,

00:26:22.080 --> 00:26:24.140
and we can filter that out for you.

00:26:24.180 --> 00:26:27.790
So this will return to you
a list of the device and the

00:26:27.790 --> 00:26:31.790
service that the user selected,
and you can go do things on that.

00:26:31.930 --> 00:26:34.780
We have a code example later
that exhibits how this works.

00:26:38.200 --> 00:26:40.420
And then the third panel
is a device search panel.

00:26:40.420 --> 00:26:43.970
For example,
if you're doing a file transfer

00:26:43.970 --> 00:26:48.120
application thing or if you want
to send a vCard to somebody,

00:26:48.120 --> 00:26:50.930
you may want to send it to
several devices at once.

00:26:51.000 --> 00:26:55.570
This is a UI panel we've created
to allow the user to select one or

00:26:55.570 --> 00:27:03.600
multiple devices and return those to
the application so they can decide

00:27:03.600 --> 00:27:09.580
how many files to send to remote
devices and how to handle that.

00:27:14.440 --> 00:27:17.050
Now we have some code examples.

00:27:17.240 --> 00:27:20.140
What we've done here is
the elements in orange,

00:27:20.140 --> 00:27:24.700
we've highlighted orange to show
that it's either an API name

00:27:24.700 --> 00:27:29.330
or one of the data types that
we've defined for Bluetooth use.

00:27:29.500 --> 00:27:33.300
So the first example we're going to
step through here is a C code example.

00:27:33.300 --> 00:27:35.720
We also have an
Objective-C version coming later.

00:27:35.720 --> 00:27:40.770
And this example uses an RF com
channel to open up and transfer

00:27:40.880 --> 00:27:43.350
data between two devices.

00:27:44.100 --> 00:27:48.170
There's really four elements that
you will need to do if you want to

00:27:48.170 --> 00:27:50.660
open a remote connection to a device.

00:27:50.770 --> 00:27:55.450
The first is a reference
to that remote device.

00:27:55.790 --> 00:28:01.520
The second is the service record to find
out what the services are on that device.

00:28:02.070 --> 00:28:04.310
And if you're dealing
with RF com channel,

00:28:04.510 --> 00:28:07.260
the last two are an RF com
channel reference and the

00:28:07.480 --> 00:28:09.160
ID number of that channel.

00:28:12.600 --> 00:28:18.300
So for the first step of finding
the device to connect to,

00:28:18.350 --> 00:28:20.790
the first call is the
IO Bluetooth Service Browser

00:28:20.790 --> 00:28:22.260
Controller Browse Devices.

00:28:22.260 --> 00:28:28.820
That's our API to bring up the service
browser to find all the devices within

00:28:28.820 --> 00:28:31.950
range and list the services on them.

00:28:32.900 --> 00:28:37.150
It will return to you a service
record that gets filled out based

00:28:37.150 --> 00:28:40.280
on which service the user selected.

00:28:41.900 --> 00:28:46.710
On top of the,
one of the calls into the SDP services

00:28:46.710 --> 00:28:51.300
on a service record will return you
exactly which device was selected.

00:28:51.300 --> 00:28:54.800
Using that call,
you can find out what device,

00:28:54.800 --> 00:28:58.460
what remote device the user selected,
and that returns to you

00:28:58.460 --> 00:29:00.480
an IO Bluetooth device.

00:29:01.270 --> 00:29:04.490
Once you have the device,
you can also query the SDP info that

00:29:04.570 --> 00:29:08.800
was returned to find out which RF com
channel number that service is on.

00:29:08.800 --> 00:29:11.800
It's an important bit of data
to know that you're opening

00:29:11.880 --> 00:29:13.420
the proper RF com channel.

00:29:17.650 --> 00:29:20.150
So once we get to this
portion of the slide,

00:29:20.180 --> 00:29:22.700
we've already got the remote
device that we want to talk to,

00:29:22.740 --> 00:29:26.090
and we have the channel ID of the
channel we want to open on that device.

00:29:27.840 --> 00:29:32.020
So the first step is to create the
connection to that remote device.

00:29:32.060 --> 00:29:34.340
That's the first call
that you see up there.

00:29:34.410 --> 00:29:36.660
That will go and page the remote device.

00:29:36.750 --> 00:29:39.770
It will answer back,
and an RF link will be established

00:29:39.770 --> 00:29:41.390
between the two devices.

00:29:41.970 --> 00:29:45.450
Once we have that initial
RF link between the two devices,

00:29:45.560 --> 00:29:48.670
we need to open the other
layered protocols on top of that.

00:29:48.790 --> 00:29:51.500
If you recall back
from the layered slide,

00:29:51.560 --> 00:29:56.260
on top of ACI there's
L2CAP and then RFCOM.

00:29:56.360 --> 00:29:58.460
If you're interested
in the RFCOM channel,

00:29:58.520 --> 00:30:01.280
we open the L2CAP channel for
that automatically for you.

00:30:01.350 --> 00:30:05.330
All you need to do is request
for that channel to be opened.

00:30:05.490 --> 00:30:08.070
That's the second call you see there.

00:30:08.280 --> 00:30:11.850
Once you've made that second call,
now you have an open RF com

00:30:11.850 --> 00:30:16.400
channel that you can use to
transfer data between two devices.

00:30:18.450 --> 00:30:21.980
The next step you must do with
RFCOM is to register an incoming

00:30:22.380 --> 00:30:24.840
listener for that RFCOM channel.

00:30:24.840 --> 00:30:29.530
That way you will get notified
of incoming data or incoming

00:30:29.540 --> 00:30:31.410
event types over RFCOM.

00:30:31.660 --> 00:30:35.120
So you register that on
the third line there.

00:30:35.220 --> 00:30:41.010
Also, the fifth line shows the function
declaration for that if you're curious.

00:30:41.100 --> 00:30:45.100
Then the next step,
you now have an open RF comm channel.

00:30:45.100 --> 00:30:46.440
You can start transferring data.

00:30:46.440 --> 00:30:48.840
There's an example of the write call.

00:30:48.840 --> 00:30:51.380
Send data on the write call.

00:30:51.380 --> 00:30:55.680
You'll get data back on the
read or on the event listener.

00:30:55.680 --> 00:30:58.360
And from there,
you've got an open conduit

00:30:58.430 --> 00:30:59.770
to a remote device.

00:31:04.810 --> 00:31:07.240
The next example is the
Objective-C version.

00:31:07.240 --> 00:31:09.680
For those of you who are coming
from the next days or have

00:31:09.690 --> 00:31:13.130
been around OS X for a while,
it's just a little different.

00:31:13.140 --> 00:31:16.310
And to change things
around for this example,

00:31:16.310 --> 00:31:19.950
instead of using RFCOM,
we use L2CAP as a different

00:31:19.950 --> 00:31:21.590
channel type to use.

00:31:21.660 --> 00:31:23.400
It just looks slightly different.

00:31:24.860 --> 00:31:27.680
It's very similar to the C version.

00:31:27.740 --> 00:31:30.460
The first step is to call the
service browser controller.

00:31:30.600 --> 00:31:33.760
A little different look
because it's Objective C,

00:31:33.850 --> 00:31:35.480
but it's the same idea.

00:31:35.590 --> 00:31:37.280
Service record browser
controller will run.

00:31:37.380 --> 00:31:40.340
The user will select the device,
and it will return that to

00:31:40.340 --> 00:31:42.520
you in the service record.

00:31:43.300 --> 00:31:46.700
Then, using the service record,
you can get the remote device that

00:31:46.700 --> 00:31:49.430
was a part of that service record.

00:31:50.210 --> 00:31:54.690
You can also, the same way there is a
RFCOM channel ID for RFCOM channels,

00:31:54.690 --> 00:31:58.670
the same concept for
L2CAP is called a PSM.

00:31:58.680 --> 00:32:02.560
So you can get the L2CAP PSM from
the service record.

00:32:04.620 --> 00:32:09.010
And now you have all the information
you need to go and open that particular

00:32:09.010 --> 00:32:10.600
channel for that remote device.

00:32:13.970 --> 00:32:17.260
Using that information,
slightly different than RFCOM,

00:32:17.310 --> 00:32:20.300
opening an L2CAP channel
automatically handles the

00:32:20.390 --> 00:32:22.640
opening the baseband connection.

00:32:22.640 --> 00:32:25.280
So if you're doing L2CAP,
we don't need to open the

00:32:25.280 --> 00:32:27.300
baseband connection ahead of time.

00:32:27.300 --> 00:32:28.850
That gets handled for us.

00:32:29.020 --> 00:32:32.810
Just tell the remote device to open
a particular RFCOM channel with

00:32:32.810 --> 00:32:35.160
the parameters we're interested in.

00:32:35.180 --> 00:32:39.590
That returns to us an
L2CAP channel object.

00:32:40.400 --> 00:32:43.950
Using that L2CAP channel object,
we can now register for

00:32:43.950 --> 00:32:48.880
incoming data to come into us
on a particular data listener,

00:32:48.880 --> 00:32:50.860
which is my data listener up there.

00:32:50.860 --> 00:32:53.600
And then we can start
writing to the channel.

00:32:53.600 --> 00:32:55.460
Data will come in on
our listener routine,

00:32:55.460 --> 00:32:58.860
and we've got all the pieces we
need to communicate to a remote

00:32:58.960 --> 00:33:01.080
device over an L2CAP channel.

00:33:05.740 --> 00:33:09.680
So as part of the SDK,
we've provided a series

00:33:09.680 --> 00:33:11.330
of sample applications.

00:33:13.210 --> 00:33:14.900
A lot of them work over OBEX.

00:33:14.900 --> 00:33:17.230
They're all listed there.

00:33:17.230 --> 00:33:22.440
OBEX Quick Push is a quick sample
application to transfer a file

00:33:22.440 --> 00:33:26.060
or a vCard or any other type of
data from one machine to another.

00:33:26.060 --> 00:33:28.810
The complete sample code is there.

00:33:29.680 --> 00:33:33.180
Obix Sample Send vCard allows
you to enter in address and

00:33:33.180 --> 00:33:37.100
telephone contact information,
and it will package that up

00:33:37.100 --> 00:33:40.850
as a vCard data object and
send that to a remote device.

00:33:40.860 --> 00:33:43.900
Similar,
you can enter address book entries

00:33:43.900 --> 00:33:47.740
onto your Bluetooth phone that way,
all sample codes there.

00:33:47.740 --> 00:33:53.150
The two RFCOM sample applications,
the Client Sample and the Server Sample,

00:33:53.200 --> 00:33:56.280
are actually an RFCOM chat application.

00:33:56.920 --> 00:34:01.370
They exhibit how to create a service,
then that service on your

00:34:01.510 --> 00:34:06.420
local Bluetooth device,
and then the Client Sample exhibits how

00:34:06.450 --> 00:34:11.340
to connect to a remote Bluetooth device
that sends a service you're interested

00:34:11.740 --> 00:34:14.920
in and open up an RFCOM sample
to transfer data back and forth.

00:34:20.310 --> 00:34:23.380
In addition to the sample code,
we provided object code

00:34:23.380 --> 00:34:24.720
for two different tools.

00:34:24.780 --> 00:34:28.860
One thing,
if you're doing Bluetooth development,

00:34:28.860 --> 00:34:31.650
you're really interested in
what the data is that's being

00:34:31.650 --> 00:34:35.400
transferred between the two devices,
both HCI commands and events

00:34:35.400 --> 00:34:40.400
and also the L2CAP or RFCOM data
that's being transferred.

00:34:40.400 --> 00:34:44.540
The Packet Decoder 2
application is just this.

00:34:44.660 --> 00:34:51.050
It logs every single HCI command
or HCI event as well as all the

00:34:51.050 --> 00:34:54.040
ACL or L2CAP data being transferred.

00:34:54.040 --> 00:34:57.740
And it will decode that according to
the different specification protocols.

00:34:57.740 --> 00:35:02.540
Currently,
we decode the Service Discovery Protocol,

00:35:02.540 --> 00:35:06.730
L2CAP protocol, and RFCOM,
although we have been thinking

00:35:06.730 --> 00:35:10.340
about adding decoding options for
different protocols as they're needed.

00:35:12.200 --> 00:35:14.290
In addition to that,
there's also an application

00:35:14.290 --> 00:35:15.700
called Bluetooth Monitor.

00:35:15.700 --> 00:35:21.500
If you're developing your Bluetooth code
and sometimes the Bluetooth connection

00:35:21.500 --> 00:35:24.400
remains live because your app
crashed or something and you

00:35:24.600 --> 00:35:28.910
want to go kill that connection,
Bluetooth Monitor will list all existing

00:35:28.910 --> 00:35:33.350
connections and channels between devices,
and you can kill off those channels

00:35:33.350 --> 00:35:34.920
or connections independently.

00:35:35.140 --> 00:35:39.230
So it's a handy little tool as you're
developing Bluetooth stuff when you

00:35:39.230 --> 00:35:42.940
get into trouble and just want to
knock things down and start over again.

00:35:42.940 --> 00:35:44.320
It can do that for you.

00:35:51.190 --> 00:35:53.660
There's some other presentations
that touch on Bluetooth.

00:35:53.660 --> 00:35:59.180
The only other one at WWDC this week
was a session just prior to this one.

00:35:59.180 --> 00:36:03.350
So there's not much you can do
about it now other than if you

00:36:03.350 --> 00:36:06.800
get the DVDs and slide sets,
you might want to go look at that

00:36:06.800 --> 00:36:10.220
one to find out what Apple's future
plans are with Bluetooth and also

00:36:10.220 --> 00:36:12.360
how it integrates with 802.11.

00:36:15.930 --> 00:36:20.440
For future contact information,
the person to start off your

00:36:20.440 --> 00:36:23.540
initial contacts with is Tom Weier.

00:36:23.540 --> 00:36:26.990
He'll be joining me on stage in just
a few moments to handle the Q&A,

00:36:26.990 --> 00:36:29.300
and he was the person who introduced me.

00:36:29.300 --> 00:36:33.170
In addition to that,
we've set up a developer mailing list.

00:36:33.390 --> 00:36:34.880
The URL is listed there.

00:36:34.880 --> 00:36:37.630
The entire Bluetooth team
will be monitoring that,

00:36:37.630 --> 00:36:39.380
so feel free to ask questions.

00:36:39.380 --> 00:36:42.910
Whatever you need there,
we'll be monitoring that

00:36:42.910 --> 00:36:44.840
for what you want from us.

00:36:48.200 --> 00:36:51.640
And here are a series of links for
more information about Bluetooth.

00:36:51.640 --> 00:36:55.870
There's a link provided for
our SDK that you should be able

00:36:55.930 --> 00:36:58.080
to download this afternoon.

00:36:59.890 --> 00:37:03.960
In addition to that,
the Bluetooth specifications available

00:37:04.140 --> 00:37:08.490
online and other specifications
which the Bluetooth specification

00:37:08.520 --> 00:37:10.240
uses are also available online.

00:37:10.240 --> 00:37:14.400
So if you're looking for any of
the specifications referred to

00:37:14.400 --> 00:37:19.120
in the initial Bluetooth spec,
there are some URLs to start looking at.

00:37:20.910 --> 00:37:24.200
In addition, as Tom mentioned in the
presentation before,

00:37:24.200 --> 00:37:28.520
we found one book that we really
like that simplifies the description

00:37:28.550 --> 00:37:30.310
of all the Bluetooth stuff.

00:37:30.380 --> 00:37:33.200
As a specification,
it's about 1,600 pages.

00:37:33.200 --> 00:37:35.560
It's a little dry, a lot to read.

00:37:35.580 --> 00:37:40.140
Bluetooth Connect without cables
simplifies that down to about 250

00:37:40.350 --> 00:37:44.980
pages and is a very good description
of what Bluetooth is and how to use it.
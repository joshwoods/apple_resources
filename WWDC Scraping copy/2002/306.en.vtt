WEBVTT

00:00:12.800 --> 00:00:14.300
Good afternoon, everyone.

00:00:14.380 --> 00:00:18.010
I'm here to talk to you
about the Cocoa text system.

00:00:19.770 --> 00:00:22.660
I'm Doug Davidson.

00:00:22.690 --> 00:00:25.960
So one of the most important
features of Cocoa is its powerful

00:00:25.960 --> 00:00:27.900
and sophisticated text system.

00:00:27.900 --> 00:00:32.110
The text system is very important
to Cocoa because it is involved in

00:00:32.110 --> 00:00:37.010
just about everything in Cocoa that
puts text up on the screen.

00:00:37.040 --> 00:00:40.140
Now, by now,
most of you have probably seen

00:00:40.140 --> 00:00:44.170
our instant text editor demo,
and you probably all worked

00:00:44.300 --> 00:00:48.640
with applications like TextEdit
and Mail and Project Builder.

00:00:48.640 --> 00:00:52.810
So you should have some idea of the
sorts of features that the Cocoa text

00:00:52.810 --> 00:00:54.780
system provides you by default.

00:00:54.850 --> 00:00:58.590
But what may not be quite so
obvious is that the text system

00:00:58.650 --> 00:01:04.190
is also designed to be highly
customizable in a variety of ways.

00:01:04.330 --> 00:01:07.090
For example,
you might have taken a look at

00:01:07.120 --> 00:01:10.420
a couple of new applications,
iChat and the new

00:01:10.420 --> 00:01:12.570
Address Book application.

00:01:12.750 --> 00:01:16.040
These are both Cocoa applications,
and they may be a little

00:01:16.040 --> 00:01:16.040
bit more sophisticated than
the other applications.

00:01:16.040 --> 00:01:16.040
But they are both very easy to use.

00:01:16.040 --> 00:01:16.040
And they are very easy to use.

00:01:16.040 --> 00:01:16.060
And they are very easy to use.

00:01:16.060 --> 00:01:17.060
And they are very easy to use.

00:01:17.060 --> 00:01:17.060
And they are very easy to use.

00:01:17.060 --> 00:01:17.060
And they are very easy to use.

00:01:17.060 --> 00:01:18.800
And they make use of the
Cocoa text system to do some

00:01:18.800 --> 00:01:20.810
rather interesting things.

00:01:20.850 --> 00:01:25.070
Now, I want to say,
we did not add anything to the text

00:01:25.070 --> 00:01:28.080
system to support these applications.

00:01:28.140 --> 00:01:31.340
What they did with the text system,
any of you could do with the

00:01:31.390 --> 00:01:36.490
sort of things that I'm going
to be talking about today.

00:01:36.940 --> 00:01:40.640
So I'm not going to be able to go
into great detail on any one area,

00:01:40.640 --> 00:01:45.450
but what I want to do is at least
tell you where you can get started for

00:01:45.450 --> 00:01:48.660
each different kind of modification.

00:01:48.660 --> 00:01:56.060
What I'm going to do is first I'll talk
about some general principles and how the

00:01:56.060 --> 00:02:00.950
text system operates and how it's used,
and I'll discuss how

00:02:00.950 --> 00:02:04.530
you can customize it,
and I'll give some very

00:02:04.530 --> 00:02:06.270
simple examples of this.

00:02:10.190 --> 00:02:16.300
So, you probably know by now that
Cocoa fundamentally deals with strings

00:02:16.300 --> 00:02:19.420
as sequences of Unicode characters.

00:02:19.420 --> 00:02:23.620
But the fundamental object for
the text system is not the string,

00:02:23.620 --> 00:02:25.750
but the attributed string.

00:02:25.750 --> 00:02:29.310
That is,
sequence of characters with certain

00:02:29.320 --> 00:02:32.750
attributes attached to a given character.

00:02:32.750 --> 00:02:37.200
And these attributes can be any
of a wide variety of things.

00:02:37.200 --> 00:02:42.440
They might be character level
attributes like fonts or colors.

00:02:42.560 --> 00:02:48.450
They might be paragraph level attributes,
things like margins, indentation,

00:02:48.450 --> 00:02:52.910
justification, and so forth,
and a variety of other things.

00:02:53.670 --> 00:02:58.620
So the job of the text system is
to take an attributed string and

00:02:59.110 --> 00:03:03.580
convert it into the sort of things
that you might see displayed up

00:03:03.580 --> 00:03:06.010
on the screen when there's text.

00:03:06.010 --> 00:03:06.010
Now,

00:03:06.220 --> 00:03:09.710
These things that are displayed
on the screen are not characters,

00:03:09.710 --> 00:03:11.940
but they may look like it.

00:03:11.940 --> 00:03:12.940
They're glyphs.

00:03:12.940 --> 00:03:19.760
A glyph is an individual,
displayable element in a particular font.

00:03:19.760 --> 00:03:23.280
And the relationship between
characters and glyphs is not simple.

00:03:23.280 --> 00:03:26.270
It's not necessarily one-to-one.

00:03:26.290 --> 00:03:29.720
It may be that a single character
ends up being represented

00:03:29.790 --> 00:03:33.820
by several different glyphs,
and it may be that several

00:03:33.820 --> 00:03:40.010
different characters combine and
are represented by a single glyph.

00:03:40.140 --> 00:03:43.610
What the text system does is to
take this attributed string and

00:03:43.610 --> 00:03:46.200
convert it into a list of glyphs.

00:03:46.270 --> 00:03:51.860
Then it takes these glyphs and it
positions them appropriately for display,

00:03:51.860 --> 00:03:55.000
breaks them up into
lines and positions them.

00:03:55.090 --> 00:03:58.850
And then it passes them on
down to Quartz to be rendered

00:03:58.850 --> 00:04:01.150
and displayed on the screen.

00:04:02.270 --> 00:04:06.640
So one other fundamental
concept is the container.

00:04:06.710 --> 00:04:12.980
And a container represents a geometrical
region within which text is laid out,

00:04:12.980 --> 00:04:16.660
for example,
such as a page or a column on a page.

00:04:18.390 --> 00:04:23.480
So, for example,
we might have a character that

00:04:23.750 --> 00:04:24.630
represents an A with an acute accent.

00:04:24.860 --> 00:04:29.450
and it might have some attributes,
like a font, Helvetica 64,

00:04:29.450 --> 00:04:30.810
and a color blue.

00:04:31.060 --> 00:04:33.420
Now, depending on the font,
or possibly even on the

00:04:33.420 --> 00:04:36.200
font implementation,
this might be represented

00:04:36.200 --> 00:04:41.180
by a single A accent glyph,
or it might be represented by two glyphs,

00:04:41.180 --> 00:04:43.680
an A glyph and an accent glyph.

00:04:43.690 --> 00:04:46.670
The text system figures that out.

00:04:47.240 --> 00:04:51.580
calculates these glyphs and then
positions them appropriately to

00:04:51.580 --> 00:04:55.720
get the final displayed result,
which is, appropriately,

00:04:55.740 --> 00:04:58.290
a blue accented A in the right font.

00:05:00.050 --> 00:05:02.430
Now, in order to do this job,
the text system goes through a

00:05:02.440 --> 00:05:06.620
number of separate processes.

00:05:06.620 --> 00:05:10.690
In an attributed string, conceptually,
you could have any combination of

00:05:10.700 --> 00:05:12.600
characters with any attributes.

00:05:12.600 --> 00:05:16.000
But that doesn't necessarily mean
that every combination makes sense.

00:05:16.110 --> 00:05:21.400
The job of attribute fixing is
to reform the text so that the

00:05:21.580 --> 00:05:26.540
combination of characters and
attributes does make sense.

00:05:26.790 --> 00:05:31.040
For example, we make sure that the font
attribute associated with a given

00:05:31.040 --> 00:05:34.500
character is a font that can
actually display that character.

00:05:34.590 --> 00:05:38.760
And we make sure that paragraph-level
attributes are actually constant

00:05:38.820 --> 00:05:43.010
over the length of a given paragraph,
that is, from one hard-line break

00:05:43.010 --> 00:05:44.630
character to the next.

00:05:45.500 --> 00:05:51.100
[Transcript missing]

00:05:51.280 --> 00:05:55.170
is Glyph Generation,
in which the text system takes the

00:05:55.170 --> 00:06:00.600
characters and their attributes and
combines them to form a list of glyphs.

00:06:04.290 --> 00:06:09.060
Then the next process is layout,
in which the glyphs are positioned

00:06:09.060 --> 00:06:12.100
within their containers,
broken up into lines,

00:06:12.130 --> 00:06:14.180
positioned within the lines.

00:06:14.450 --> 00:06:18.280
And finally, we have display,
in which the list of glyphs is marched

00:06:18.280 --> 00:06:22.290
up with their positions and sent
on down to Quartz to be rendered.

00:06:22.380 --> 00:06:24.110
Now,
it's characteristic of the Cocoa text

00:06:24.160 --> 00:06:29.490
system that these processes
are generally performed lazily,

00:06:29.580 --> 00:06:36.410
automatically, on demand,
as they are needed when some particular

00:06:36.410 --> 00:06:36.410
information is required that needs them.

00:06:37.560 --> 00:06:40.960
So, for example,
the display mechanism follows

00:06:40.960 --> 00:06:45.360
the standard Cocoa pattern,
where typically a view will have

00:06:45.360 --> 00:06:49.450
"set needs display" called on it,
which will eventually, later on,

00:06:49.640 --> 00:06:53.620
cause some display as needed.

00:06:53.800 --> 00:06:56.660
But because all of these
processes are typically on demand,

00:06:56.660 --> 00:07:01.360
what often happens is that
this is driven backwards.

00:07:01.360 --> 00:07:06.480
That is, some view needs to be displayed,
but in order to display,

00:07:06.500 --> 00:07:09.670
we need to have the layout information,
so layout happens.

00:07:09.670 --> 00:07:12.590
But in order to do layout,
we need to have the glyphs,

00:07:12.640 --> 00:07:14.470
so glyph generation must occur.

00:07:14.600 --> 00:07:17.850
In order to do glyph generation,
we have to fix the attributes,

00:07:17.850 --> 00:07:19.320
so attribute fixing occurs.

00:07:19.320 --> 00:07:22.290
So the whole process gets
pulled from the display end.

00:07:22.290 --> 00:07:24.620
Now, that's not always what happens.

00:07:24.670 --> 00:07:29.380
It may happen often,
but also if the text system

00:07:29.380 --> 00:07:32.370
finds some idle time,
it will, in some cases,

00:07:32.370 --> 00:07:35.760
precompute some of these
things for performance.

00:07:40.780 --> 00:07:42.630
So I've discussed some of
the fundamental concepts.

00:07:42.740 --> 00:07:45.570
Now I want to talk about some of
the classes that implement these

00:07:45.620 --> 00:07:47.940
things and perform these processes.

00:07:48.130 --> 00:07:52.300
So this is a diagram of the four
major text system classes in the

00:07:52.380 --> 00:07:54.640
order in which they contribute.

00:07:54.820 --> 00:07:57.900
So NSTextStorage stores the text.

00:07:57.900 --> 00:08:02.700
NSLayoutManager controls the
glyph generation and layout.

00:08:02.700 --> 00:08:06.540
NSTextContainer models the
geometry of the containers.

00:08:06.540 --> 00:08:10.460
And the NSTextView is the view that
actually sits in the display hierarchy

00:08:10.530 --> 00:08:12.300
and handles user input and display.

00:08:12.300 --> 00:08:16.210
And we'll be coming back to
this diagram again later on.

00:08:19.410 --> 00:08:21.240
Why so many different classes?

00:08:21.270 --> 00:08:26.780
Well, the text system is one of the more
complex examples in AppKit of the

00:08:26.780 --> 00:08:29.130
model view controller paradigm.

00:08:29.130 --> 00:08:33.010
That is, we have some classes
that represent the model,

00:08:33.010 --> 00:08:38.440
in this case, the underlying text and its
attributes and the geometry of it.

00:08:38.500 --> 00:08:43.410
And we have other classes
that handle the view portion,

00:08:43.410 --> 00:08:47.410
that actually sit in the view
hierarchy that do display,

00:08:47.410 --> 00:08:48.540
do user interaction.

00:08:48.550 --> 00:08:52.320
And we have controller classes that
sit in the middle and intermediate

00:08:52.780 --> 00:08:54.790
between them and manage things.

00:08:55.790 --> 00:08:59.040
So I'm going to talk about
each of these in turn.

00:08:59.040 --> 00:09:04.120
Now, I spoke of the text as
being an attributed string.

00:09:04.120 --> 00:09:08.200
And in Foundation,
there are the classes NSAttributedString

00:09:08.200 --> 00:09:10.720
and NSMutableAttributedString.

00:09:10.720 --> 00:09:15.200
But the actual storage for the
text system is not one of these.

00:09:15.200 --> 00:09:18.490
It is an AppKit class
called NSTextStorage.

00:09:18.490 --> 00:09:23.080
And NSTextStorage is a subclass
of NSMutableAttributedString.

00:09:23.100 --> 00:09:23.700
Keep that in mind.

00:09:23.700 --> 00:09:25.220
Whenever you're dealing
with a text storage,

00:09:25.220 --> 00:09:30.100
you can use all the
NSMutableAttributedString methods on it.

00:09:30.100 --> 00:09:31.510
But it has something extra.

00:09:31.510 --> 00:09:35.800
And the extra thing that NSTextStorage
does is that whenever it changes,

00:09:35.800 --> 00:09:40.300
it notifies other components
of the text system that it has

00:09:40.650 --> 00:09:45.410
And okay, there are other classes that
are model classes that model

00:09:45.410 --> 00:09:51.340
the attributes of the text,
the obvious ones, NSFont, NSColor.

00:09:51.340 --> 00:09:55.360
For paragraph-level attributes,
we have NSParagraphStyle,

00:09:55.360 --> 00:10:00.310
which models things like line spacing,
justification, margins, and so forth.

00:10:00.360 --> 00:10:03.600
And also,
it may contain multiple tab stops,

00:10:03.600 --> 00:10:07.190
which--each of which is
modeled by the NSText tab.

00:10:07.190 --> 00:10:11.920
And there's a special class
called NSTextAttachment,

00:10:12.130 --> 00:10:16.630
which models an attached
file or an inline image.

00:10:16.920 --> 00:10:19.000
And finally,
I'm going to consider the text

00:10:19.020 --> 00:10:20.890
container as being a model class.

00:10:21.000 --> 00:10:24.230
What an S-text container
does is it's pure geometry.

00:10:24.260 --> 00:10:26.510
It simply models a geometrical region.

00:10:27.140 --> 00:10:30.560
It might be a page or a column or
something more complicated within

00:10:30.560 --> 00:10:32.410
which text is going to be laid out.

00:10:34.470 --> 00:10:40.440
Now, instead of speaking of an instance
of the class NSTextStorage,

00:10:40.440 --> 00:10:46.680
for short, I might say a text storage,
and so on for the other classes.

00:10:49.820 --> 00:10:54.050
Next, we have the controller classes,
of which the most important--probably

00:10:54.050 --> 00:10:58.700
the most important class in the
tech system is NSLayoutManager.

00:10:58.700 --> 00:11:04.160
NSLayoutManager manages the processes
of glyph generation and layout.

00:11:04.160 --> 00:11:07.150
It stores all the layout information.

00:11:07.150 --> 00:11:09.840
It stores the glyphs themselves.

00:11:10.100 --> 00:11:13.440
And NSLayoutManager,
interestingly enough,

00:11:13.490 --> 00:11:16.960
is actually the class
that does the display,

00:11:16.960 --> 00:11:20.990
that is, that marshals glyphs and sends
them to Quartz to be rendered

00:11:21.010 --> 00:11:24.080
at the request of the view.

00:11:24.130 --> 00:11:26.500
If you want to know anything about the
glyphs or anything about the layout,

00:11:26.500 --> 00:11:27.800
you ask NSLayoutManager.

00:11:30.030 --> 00:11:34.390
In addition, there is another class which
we usually do not deal with

00:11:34.710 --> 00:11:39.060
directly that is controlled by
NSLAM Manager called NSTypeSetter.

00:11:39.270 --> 00:11:46.020
NSTypeSetter is a class that
actually does the layout of

00:11:46.020 --> 00:11:46.020
the glyphs into the containers.

00:11:48.440 --> 00:11:51.540
Finally, we have the view classes,
of which the most

00:11:51.540 --> 00:11:54.060
important is NSTextView.

00:11:54.060 --> 00:11:58.070
One NSTextView handles the display
and user input for the text

00:11:58.100 --> 00:12:03.580
displayed in a single container,
a single NSText container.

00:12:03.580 --> 00:12:06.260
When you drag that object off
the palette in Interface Builder,

00:12:06.340 --> 00:12:07.770
what you get is an NSTextView.

00:12:07.780 --> 00:12:13.100
It's probably a class most
of you have dealt with.

00:12:13.100 --> 00:12:15.870
One thing to mention about
NSTextView is that for historical

00:12:15.870 --> 00:12:19.040
reasons it has a super class,
NSText.

00:12:19.040 --> 00:12:22.180
And some of the NSTextView methods
are actually defined there.

00:12:22.180 --> 00:12:26.830
But currently, the only subclass of
NSText is NSTextView.

00:12:26.860 --> 00:12:32.490
So you can think of them
as being the same thing.

00:12:32.950 --> 00:12:37.180
As I said,
one NSTextView handles the display and

00:12:37.180 --> 00:12:40.220
input for a single NSTextContainer.

00:12:40.530 --> 00:12:43.660
So if you have a situation
with multiple text containers,

00:12:43.850 --> 00:12:48.190
say, multiple pages in a document
or multiple columns on a page,

00:12:48.270 --> 00:12:52.140
then there would be one text
container for each of these and one

00:12:52.140 --> 00:12:54.830
NSTextView for each of the containers.

00:12:54.900 --> 00:12:59.490
And these associated TextViews
will know about each other,

00:12:59.490 --> 00:13:02.230
will work together,
and will have some shared state.

00:13:02.430 --> 00:13:07.330
For example,
the user's selected range in the text.

00:13:10.600 --> 00:13:12.600
And there are other
classes at the view level.

00:13:12.600 --> 00:13:18.040
The standard AppKit ruler
classes are used for text rulers.

00:13:18.060 --> 00:13:22.360
And there is a special subclass in
NSL called NSTextAttachmentCell,

00:13:22.360 --> 00:13:28.900
which does the drawing for
the NSText attachments,

00:13:28.900 --> 00:13:28.900
that is,
for attached files or inline images.

00:13:33.200 --> 00:13:35.860
So now,
how do these classes work together?

00:13:35.860 --> 00:13:37.640
We're back at the diagram.

00:13:37.700 --> 00:13:39.980
This is the most common situation.

00:13:39.980 --> 00:13:43.680
That is, where you have a single instance
of each of the major classes:

00:13:43.680 --> 00:13:51.100
one NSTextStorage, one NSLayoutManager,
one TextContainer, one TextView.

00:13:51.100 --> 00:13:54.410
This is not the only possibility.

00:13:54.930 --> 00:13:58.460
For example, a single text,
that is a single NS Text Storage,

00:13:58.550 --> 00:14:02.560
might be presented to the
user in multiple ways.

00:14:02.670 --> 00:14:08.430
And for that, each of these ways can have
its own layout manager,

00:14:08.520 --> 00:14:11.400
representing a different
layout of the same text.

00:14:11.600 --> 00:14:18.730
So a single NS Text Storage may have one,
or more than one, NS Layout Manager.

00:14:19.640 --> 00:14:26.690
Now, likewise, as I mentioned before,
a single NSLayoutManager may be laying

00:14:26.850 --> 00:14:32.700
out into a single text container,
a single page or a single long document.

00:14:32.700 --> 00:14:36.110
Or there may be more than one
NSTextContainer representing,

00:14:36.140 --> 00:14:38.060
for example, multiple pages.

00:14:38.060 --> 00:14:43.860
So one NSLayoutManager may have one
or more than one NSTextContainer.

00:14:43.860 --> 00:14:47.220
And these are in an ordered list
so that the text flows from the

00:14:47.220 --> 00:14:51.790
first text container to the next
to the next as it is laid out.

00:14:52.730 --> 00:14:57.820
But, as I mentioned before,
a text container has at most

00:14:57.820 --> 00:15:00.620
one text view and vice versa.

00:15:01.260 --> 00:15:03.720
Now,
usually the conceptual ownership flows

00:15:03.720 --> 00:15:05.750
in the direction I'm talking about.

00:15:05.750 --> 00:15:07.880
That is,
the text storage owns the layout,

00:15:07.890 --> 00:15:11.760
owns the container, owns the view,
although there is another simplified

00:15:11.760 --> 00:15:14.070
option that we'll talk about in a moment.

00:15:14.740 --> 00:15:19.170
So this is what the diagram would
look like if you have multiple text

00:15:19.230 --> 00:15:21.570
containers on a single layout manager.

00:15:21.600 --> 00:15:24.590
That is, for example, in this case,
multiple pages.

00:15:24.700 --> 00:15:30.790
And as you can see,
the text flows as it's laid out from

00:15:30.790 --> 00:15:30.790
the first text container into the next.

00:15:35.000 --> 00:15:37.890
This, on the other hand,
is what the diagram would look like

00:15:37.980 --> 00:15:41.800
if you have multiple layout managers,
that is, multiple presentations,

00:15:41.800 --> 00:15:42.860
on the same text.

00:15:42.970 --> 00:15:51.340
So each layout manager would have its own
text container or set of text containers,

00:15:51.340 --> 00:15:51.340
and they each present the same
text in possibly different ways.

00:15:56.720 --> 00:15:59.740
So now we've discussed some of
the basic text system concepts,

00:15:59.860 --> 00:16:03.660
and we've at least
touched on the classes.

00:16:03.790 --> 00:16:06.830
So now I'm going to talk about
how you use the text system.

00:16:06.980 --> 00:16:09.200
So first,
I want to touch briefly on the very

00:16:09.200 --> 00:16:12.930
simplest uses of the text system,
those that don't involve you

00:16:12.980 --> 00:16:15.300
touching an NS TextView directly.

00:16:15.300 --> 00:16:21.060
Now, the very simplest APIs are
just categories on--defined

00:16:21.060 --> 00:16:25.730
in the app kit on NSString and
NSAttributedString that simply say,

00:16:25.730 --> 00:16:26.300
"Draw this string, and then you can use
it to create text." So,

00:16:26.300 --> 00:16:26.300
this is a very simple system.

00:16:26.620 --> 00:16:27.600
You just want to do some simple drawing.

00:16:27.980 --> 00:16:31.920
You want to put this text here.

00:16:31.920 --> 00:16:35.420
No fuss, no muss.

00:16:35.420 --> 00:16:38.830
Just draw it.

00:16:39.580 --> 00:16:41.980
Under the hood,
there are all of these text

00:16:42.120 --> 00:16:47.050
system classes working for you,
but you don't have to

00:16:47.050 --> 00:16:47.050
deal with them directly.

00:16:47.260 --> 00:16:51.170
The next simplest situation is that
that might be used by a control,

00:16:51.250 --> 00:16:54.350
let us say a button that
needs to draw its title,

00:16:54.350 --> 00:16:55.390
for example.

00:16:55.480 --> 00:17:01.360
And what it uses in that
situation is an NSL.

00:17:01.460 --> 00:17:04.480
And the NSL knows how to draw itself.

00:17:04.540 --> 00:17:05.560
The NSL does the drawing.

00:17:05.560 --> 00:17:09.710
The NSL talks to the text system for you.

00:17:09.710 --> 00:17:12.410
You don't have to deal with it,
although it is there under the hood.

00:17:12.640 --> 00:17:18.390
So what happens if a control
doesn't need to just display itself,

00:17:18.390 --> 00:17:20.900
but it also needs to do some input?

00:17:21.210 --> 00:17:23.970
Say a text field is editing.

00:17:23.970 --> 00:17:30.280
For that we--what we do is that each
window has a single shared text view

00:17:30.310 --> 00:17:33.250
called the field editor for the window.

00:17:33.290 --> 00:17:37.530
Only one control is going to be editing
in the window at any given time,

00:17:37.640 --> 00:17:40.750
so the field editor can
be shared among controls.

00:17:40.820 --> 00:17:45.990
And when a control starts editing,
the field editor is attached to it,

00:17:45.990 --> 00:17:50.530
is put in there in the view hierarchy,
and while that control is editing,

00:17:50.530 --> 00:17:54.840
the field editor takes over the
display and does all the input for it.

00:17:54.960 --> 00:17:59.950
So input in the text system is
always handled by a text view.

00:18:00.980 --> 00:18:07.180
There is one more usage of the text
system that doesn't involve a text

00:18:07.180 --> 00:18:11.740
view that's somewhat more complicated,
and that is that in a

00:18:11.840 --> 00:18:15.330
custom view of yours,
you can use a layout manager

00:18:15.410 --> 00:18:21.940
with text containers without
text views to do measuring of

00:18:22.100 --> 00:18:25.420
text or to do drawing for you.

00:18:25.420 --> 00:18:26.560
And I'll mention that
briefly again later on.

00:18:27.640 --> 00:18:32.630
So next I want to talk about the simplest
usages of the text system that do involve

00:18:32.970 --> 00:18:37.800
you touching an NSTextView directly.

00:18:37.800 --> 00:18:37.800
And

00:18:37.870 --> 00:18:42.240
So the simplest and most common case is
that in which there is one text storage,

00:18:42.320 --> 00:18:46.510
one layout manager, one text container,
one text view.

00:18:46.520 --> 00:18:48.820
And that's what you get when
you drag that object off the

00:18:48.840 --> 00:18:50.240
palette in Interface Builder.

00:18:52.330 --> 00:18:55.020
And when you create a
text view in this way,

00:18:55.020 --> 00:18:58.840
the text view automatically
creates all of the other elements

00:18:58.840 --> 00:19:00.300
of the text system for you.

00:19:00.390 --> 00:19:04.320
And in this situation,
you use a simplified ownership model

00:19:04.450 --> 00:19:10.840
where the text view conceptually
owns all the other pieces so that,

00:19:10.840 --> 00:19:16.170
if you like, you don't ever need to
talk to any other object.

00:19:16.170 --> 00:19:16.170
You don't need to deal with
anything but the text view.

00:19:17.910 --> 00:19:22.860
Now, even in this very simple situation,
there's actually a great deal

00:19:22.860 --> 00:19:27.200
that you can do in the way of
customization of the text system.

00:19:27.320 --> 00:19:31.780
You may think that I'm going to talk
here about subclassing in NSTextView,

00:19:31.860 --> 00:19:35.260
but I'm not, not yet.

00:19:35.260 --> 00:19:39.980
One rule of thumb in Cocoa is that
subclassing of the kit objects

00:19:40.140 --> 00:19:44.180
should not be your first resort,
but rather one of your last.

00:19:44.180 --> 00:19:48.240
Before you try subclassing,
first thing you should think of

00:19:48.240 --> 00:19:54.520
is to do everything you can with
notification and/or delegation.

00:19:54.520 --> 00:19:59.950
And in the case of NSTextView,
there is actually quite a bit

00:19:59.950 --> 00:20:03.070
that can be done as the TextView

00:20:03.210 --> 00:20:08.490
The TextViews delegate is notified of any
change that the user makes to the text,

00:20:08.610 --> 00:20:13.010
and it gets to veto
or modify that change.

00:20:13.240 --> 00:20:18.190
The TextView's delegate is notified
of any change that the user makes

00:20:18.190 --> 00:20:24.110
to the selection of the text and
gets to veto or modify that change.

00:20:24.160 --> 00:20:28.300
The TextView's delegate is also notified
when the user presses some special key,

00:20:28.320 --> 00:20:29.640
like an arrow key.

00:20:29.760 --> 00:20:33.940
And again, the delegate gets to veto
or modify that action.

00:20:34.100 --> 00:20:39.870
So what this means is that the TextView's
delegate has almost complete control over

00:20:39.870 --> 00:20:43.840
the user's interaction with the TextView.

00:20:43.900 --> 00:20:47.340
I want to emphasize this point because
this is the number one question that

00:20:47.430 --> 00:20:49.340
I get asked about the text system.

00:20:49.340 --> 00:20:52.900
That is,
"I'm working with the TextView and

00:20:52.900 --> 00:20:55.500
I want to do something
special when the user presses,

00:20:55.630 --> 00:20:57.440
let us say, the return key.

00:20:57.590 --> 00:21:00.780
What do I do?" And my
answer to this is always,

00:21:00.780 --> 00:21:08.390
"Well, the first thing you should try is
acting as the TextView's delegate."

00:21:10.180 --> 00:21:13.100
And now I have a very
simple demo of that.

00:21:13.100 --> 00:21:15.100
We can move over to the demo screen.

00:21:15.240 --> 00:21:18.680
So suppose you're writing a, say,
a chat program.

00:21:18.780 --> 00:21:25.780
And, well,
while the user is typing in a message,

00:21:25.780 --> 00:21:29.550
they can edit it freely,
but once they hit return,

00:21:29.550 --> 00:21:29.550
that message is sent and
can't modify it anymore.

00:21:29.750 --> 00:21:32.350
The simplest way you can do
that is as a TextViews delegate.

00:21:32.470 --> 00:21:35.200
Now,
I've written a very simple demo of that.

00:21:35.200 --> 00:21:38.370
When I was writing up these demos,
I decided I wanted to make

00:21:38.370 --> 00:21:41.740
them as simple as possible,
so I limited myself to 25 lines

00:21:41.740 --> 00:21:43.660
of code in any individual demo.

00:21:43.750 --> 00:21:49.890
And I think these demos should be
available from ADC as download.

00:21:49.890 --> 00:21:53.410
I'm just going to show it to you here.

00:21:53.410 --> 00:21:56.730
So, for example, I can type along,
and then when I hit return,

00:21:57.080 --> 00:21:58.790
The TextView's delegate is notified.

00:21:58.920 --> 00:22:01.490
In this case,
it makes some changes to the text.

00:22:01.490 --> 00:22:05.060
It turns it red.

00:22:05.200 --> 00:22:08.260
In the text that I'm typing,
I can edit it.

00:22:08.340 --> 00:22:10.790
Once I've hit return, though,

00:22:12.370 --> 00:22:15.090
That text is selectable,
but I can't modify it because

00:22:15.090 --> 00:22:19.300
the TextViews delegate is
forbidding that change.

00:22:19.300 --> 00:22:22.960
All right.

00:22:23.010 --> 00:22:25.090
Let's go back to the slides.

00:22:31.490 --> 00:22:33.680
So,
next thing I want to talk about is some

00:22:33.680 --> 00:22:37.480
more complicated text system usages,
where you go beyond the

00:22:37.480 --> 00:22:40.950
single layout manager,
single text container,

00:22:40.970 --> 00:22:42.900
single text view model.

00:22:43.080 --> 00:22:50.020
So,
the simplest and most common case here

00:22:52.000 --> 00:23:17.300
[Transcript missing]

00:23:18.490 --> 00:23:21.100
The way this works is that
the layout manager has a list,

00:23:21.100 --> 00:23:25.700
an ordered list, of its text containers.

00:23:25.700 --> 00:23:27.820
And it lays the text in these containers.

00:23:27.820 --> 00:23:30.280
The text flows from one to
the next as it's laid out.

00:23:30.550 --> 00:23:33.090
You can add or remove
containers from this list,

00:23:33.090 --> 00:23:36.700
and the text will automatically
be laid out into them.

00:23:36.790 --> 00:23:40.760
As I said before,
you will have one text view.

00:23:40.760 --> 00:23:44.510
If you want text views,
you'll have one text view per container.

00:23:47.990 --> 00:23:53.740
If there are many text containers and
text views on a single layout manager,

00:23:53.810 --> 00:23:59.990
they will know about each other
and they will share some state,

00:23:59.990 --> 00:23:59.990
such as the user-selected region.

00:24:00.890 --> 00:24:04.190
So again, here is a diagram where we
have multiple text containers

00:24:04.190 --> 00:24:05.750
on a single layout manager.

00:24:05.800 --> 00:24:07.800
The text flows from one to the next.

00:24:07.850 --> 00:24:10.760
This is what you would use
if you had multiple pages or,

00:24:10.760 --> 00:24:13.210
for example, multiple columns on a page.

00:24:14.420 --> 00:24:18.590
Another possibility is that
you may wish to have multiple

00:24:18.590 --> 00:24:20.890
presentations of the same text.

00:24:21.030 --> 00:24:24.210
For example, if you're writing,
let us say,

00:24:24.240 --> 00:24:27.160
a slide presentation application.

00:24:27.190 --> 00:24:31.550
You might want to have one
presentation of the text in a list

00:24:31.580 --> 00:24:37.130
of small fixed-sized text containers
representing the slides on one side.

00:24:37.130 --> 00:24:40.360
And on the other side,
you might want to have a separate

00:24:40.360 --> 00:24:44.800
presentation of the same text
in a single long text container

00:24:44.800 --> 00:24:46.870
as a continuous outline.

00:24:47.470 --> 00:24:53.630
So, what you would do in that case is
you would set up two different layout

00:24:53.630 --> 00:24:56.930
managers on the same text storage.

00:24:57.070 --> 00:25:10.500
: Then one layout manager would
get a single long text container.

00:25:10.500 --> 00:25:10.500
The other layout manager
would get a series of small,

00:25:10.500 --> 00:25:10.500
appropriately-sized text containers.

00:25:10.500 --> 00:25:10.500
And that's all you need to do.

00:25:10.860 --> 00:25:13.920
The text system will automatically
lay out the text in all these and

00:25:13.920 --> 00:25:17.200
present it in both at the same time.

00:25:17.350 --> 00:25:21.320
Now, what happens if the user
makes a change in one of these

00:25:21.320 --> 00:25:23.490
presentations of the text?

00:25:23.490 --> 00:25:23.490
All right.

00:25:24.300 --> 00:25:26.090
Here's a sequence of what happens.

00:25:26.180 --> 00:25:28.990
The user makes a change, say,
types in one of them,

00:25:28.990 --> 00:25:31.630
in one of these text views.

00:25:31.690 --> 00:25:36.290
The text view then makes that change
on the underlying text storage.

00:25:36.680 --> 00:25:40.310
Now, remember I said that the special
thing about NSTextStorage

00:25:40.310 --> 00:25:43.320
was that when it changes,
it makes some notifications.

00:25:43.320 --> 00:25:47.770
It notifies its layout
managers that it has changed.

00:25:47.770 --> 00:25:51.850
And these layout managers,
when they receive that notification,

00:25:51.850 --> 00:25:55.820
what they do is they notice,
depending on the region that is changed,

00:25:55.820 --> 00:25:59.900
which of the portions of glyph and
layout information that they maintain

00:25:59.900 --> 00:26:01.960
are now made invalid by that change.

00:26:01.960 --> 00:26:03.720
And they mark them as invalid.

00:26:03.720 --> 00:26:07.100
They don't necessarily
recalculate them right away.

00:26:07.200 --> 00:26:12.550
Then they tell the affected text views
that they're going to need display,

00:26:12.550 --> 00:26:13.970
a set needs display.

00:26:13.970 --> 00:26:17.720
Now, eventually at some later point,
some of those text

00:26:17.720 --> 00:26:19.490
views may be displayed.

00:26:19.610 --> 00:26:23.120
When that happens,
the text view will need display,

00:26:23.120 --> 00:26:26.220
so it will ask the layout manager
for layout information to determine

00:26:26.260 --> 00:26:27.950
what needs to be displayed.

00:26:27.950 --> 00:26:31.720
So the layout manager has
already marked as invalid some

00:26:31.720 --> 00:26:34.160
portions of its information,
so it knows it needs to be displayed.

00:26:34.160 --> 00:26:34.790
And then it will ask the layout manager
to determine what needs to be displayed.

00:26:34.790 --> 00:26:36.100
So the layout manager knows
it needs to be recalculated,

00:26:36.100 --> 00:26:38.430
so they will be recalculated on demand.

00:26:38.450 --> 00:26:41.360
The glyph generation and
layout will be performed.

00:26:41.640 --> 00:26:45.490
And then the views will
be properly redisplayed.

00:26:45.500 --> 00:26:49.410
So in this way,
the changes made in one text view in one

00:26:49.410 --> 00:26:52.110
presentation propagate to all the others.

00:26:52.110 --> 00:26:55.890
I emphasize this because if
you understand how this works,

00:26:55.890 --> 00:27:00.110
you go a long way toward understanding
how the text system works

00:27:00.530 --> 00:27:03.580
changes propagate down from
the views to the model,

00:27:03.580 --> 00:27:07.720
and they propagate back up through the
controllers back to the views again.

00:27:19.100 --> 00:27:21.730
And again,
here is a diagram for the situation in

00:27:21.730 --> 00:27:26.010
which you have multiple layout managers,
multiple presentations of the same

00:27:26.010 --> 00:27:27.880
text on the same text storage.

00:27:27.960 --> 00:27:32.020
They present the same text
in possibly different ways.

00:27:32.700 --> 00:27:36.350
Now, there are also a number of
options that you can set as to how

00:27:36.520 --> 00:27:39.740
your text is going to be shown.

00:27:39.740 --> 00:27:41.890
When you drag that object off
the palette and interface,

00:27:41.890 --> 00:27:45.850
though, you may notice that it
scrolls in only one direction.

00:27:45.850 --> 00:27:49.730
That is the--and the text
in it is arbitrarily long,

00:27:49.730 --> 00:27:51.610
but it's not arbitrarily wide.

00:27:51.610 --> 00:27:52.750
It's fixed width.

00:27:52.750 --> 00:27:56.650
These are options that are set on
your TextView in your text container.

00:27:56.650 --> 00:28:00.850
And you could set these things
independently in the horizontal

00:28:00.850 --> 00:28:04.150
and vertical directions.

00:28:04.360 --> 00:28:07.900
For this, I would like to point you
to an example on your CDs,

00:28:07.900 --> 00:28:11.780
the text sizing example
in the app kit examples,

00:28:11.830 --> 00:28:17.220
which has some very clear and
complete examples of many different

00:28:17.220 --> 00:28:19.630
combinations of this sort of thing.

00:28:19.730 --> 00:28:23.880
There are also some positioning options.

00:28:24.560 --> 00:28:30.880
You can set an amount by which the text
container is inset within the text view.

00:28:30.970 --> 00:28:34.560
And when you're laying out the
text in the text container,

00:28:34.680 --> 00:28:39.790
you can set an amount of padding by which
text is inset within the text container.

00:28:44.590 --> 00:28:50.700
There are also quite a few options
that can be set on the Textview itself.

00:28:50.760 --> 00:28:54.000
And many of these are probably
familiar because they're represented

00:28:54.000 --> 00:28:56.460
as checkboxes in Interface Builder.

00:28:56.460 --> 00:28:58.740
Not all of them are, though.

00:28:58.740 --> 00:29:01.650
For example,
on the Textview you can control

00:29:01.650 --> 00:29:05.840
whether the Textview is selectable,
whether it's editable,

00:29:05.900 --> 00:29:10.760
whether it shows plain and rich text,
whether attachments can be dragged in,

00:29:10.830 --> 00:29:14.680
whether rules will be shown,
whether the font panel will be used,

00:29:14.680 --> 00:29:17.450
whether as you type spell
checking is allowed,

00:29:17.520 --> 00:29:22.000
whether it uses a so-called
smart cut-and-paste behavior.

00:29:22.100 --> 00:29:28.110
You can control the attributes that will
be given to designate selected text.

00:29:28.140 --> 00:29:30.210
It doesn't have to be a gray background.

00:29:30.320 --> 00:29:34.880
And you can also control whether the
Textview acts like a field editor.

00:29:34.940 --> 00:29:39.160
That means acts like a field editor
with respect to tab and return.

00:29:39.200 --> 00:29:40.720
For a field editor, tab and return.

00:29:40.720 --> 00:29:44.780
and editing rather than inserting
tab and return characters.

00:29:45.570 --> 00:29:48.520
There are also some options,
not quite as obvious,

00:29:48.650 --> 00:29:52.140
that can be set on the layout manager,
on the text view.

00:29:52.140 --> 00:29:56.730
By setting options on the layout manager,
you can control, for example,

00:29:56.890 --> 00:29:58.860
whether hyphenation is used.

00:29:58.860 --> 00:30:04.250
You can control whether the layout
manager does that precalculation,

00:30:04.280 --> 00:30:07.240
the background layout
I mentioned at idle time.

00:30:07.240 --> 00:30:11.220
You can control whether inline
images and attachments are

00:30:11.510 --> 00:30:14.140
scaled to fit the text container.

00:30:14.430 --> 00:30:19.510
And you can control whether the
layout manager would use fonts with

00:30:19.510 --> 00:30:23.350
screen metrics if they're available.

00:30:24.810 --> 00:30:27.190
So at this point,
people usually want to know,

00:30:27.320 --> 00:30:30.840
how do you put the pieces together
to get one of these things working?

00:30:30.830 --> 00:30:35.430
So the usual process would be,
first you create this text storage

00:30:35.430 --> 00:30:38.110
and populate it with your text.

00:30:38.180 --> 00:30:43.070
Then you create a layout manager and
simply add it to the text storage.

00:30:43.180 --> 00:30:46.090
Text storage can have any
number of layout managers.

00:30:46.190 --> 00:31:10.090
Then you create however many
text containers you want,

00:31:10.090 --> 00:31:10.090
size them appropriately,
add them to the Layout Manager.

00:31:10.090 --> 00:31:10.090
If you want text views,
you create those and set

00:31:10.090 --> 00:31:10.090
them for the text containers.

00:31:10.090 --> 00:31:10.090
Set all the options, and you're done.

00:31:10.090 --> 00:31:10.090
It's that simple.

00:31:10.090 --> 00:31:10.090
The text system will automatically
lay out the text for you.

00:31:10.090 --> 00:31:10.090
So, at this point,
I have a small demo of this.

00:31:16.890 --> 00:31:25.830
So here is the sort of situation
that I was talking about before,

00:31:26.170 --> 00:31:32.400
where we have on one side of the screen,
the text is laid out as a single

00:31:32.400 --> 00:31:35.540
long text view as an outline.

00:31:35.800 --> 00:31:42.650
And the other side, we have some smaller
fixed-size containers,

00:31:42.650 --> 00:31:42.650
which might represent slides.

00:31:46.030 --> 00:31:47.530
Again, a very simple demo.

00:31:47.750 --> 00:31:50.730
All I do is create these objects,
add them to each other,

00:31:50.830 --> 00:31:53.200
position them under 20 lines of code.

00:31:53.220 --> 00:31:55.840
You can download this example from ADC.

00:31:57.290 --> 00:32:02.250
Now, just to show you what happens when
you make changes in one of them.

00:32:09.800 --> 00:32:12.780
As you can see,
they're automatically transferred from

00:32:12.780 --> 00:32:14.360
one of these presentations to the other.

00:32:14.360 --> 00:32:19.780
Let's go back to the slides.

00:32:30.150 --> 00:32:34.340
So at this point,
I would like to talk about

00:32:34.340 --> 00:32:39.390
what you can do when you deal
directly with the text storage,

00:32:39.560 --> 00:32:42.360
with the model layer of the system.

00:32:42.450 --> 00:32:44.540
Most people, when they start out working
with the text system,

00:32:44.540 --> 00:32:45.720
start off working with nsTextView.

00:32:45.840 --> 00:32:49.820
And nsTextView certainly does
have some methods that allow you

00:32:49.910 --> 00:32:52.060
to alter the underlying text.

00:32:52.060 --> 00:32:56.010
But at some point,
you'll probably want to go beyond that.

00:32:56.120 --> 00:32:59.760
For complete control over the text,
you want to deal directly

00:32:59.760 --> 00:33:02.210
with the underlying model,
the text storage.

00:33:03.480 --> 00:33:05.880
Now, let me say again,
NSTextStorage is a subclass

00:33:05.970 --> 00:33:09.200
of NSMutableAttributedString,
and all of the mutable attributed

00:33:09.200 --> 00:33:11.200
string methods can be used on it.

00:33:11.200 --> 00:33:14.580
The special thing about the text storage,
though, is that when it changes,

00:33:14.580 --> 00:33:17.420
it notifies all its layout
managers that it changes.

00:33:17.420 --> 00:33:20.770
There's one corollary to that,
and that is that if you're

00:33:20.800 --> 00:33:24.620
making a lot of small changes,
you don't want the text contained to the

00:33:24.620 --> 00:33:30.080
-- you don't want the layout managers
to be notified of each one individually,

00:33:30.080 --> 00:33:33.300
and have to do work for every single one.

00:33:33.340 --> 00:33:35.630
So for efficiency's sake,
if you're making a number

00:33:35.630 --> 00:33:38.180
of changes in a row,
what you should do is wrap them

00:33:38.180 --> 00:33:42.340
first in a call to begin editing,
and finally, when you're done,

00:33:42.340 --> 00:33:46.250
with a call to end editing that
allows these notifications to be

00:33:46.250 --> 00:33:48.320
coalesced into one at the end.

00:33:50.910 --> 00:33:53.090
So what can you do with the text storage?

00:33:53.180 --> 00:33:56.830
One very common thing you'll want to
go to is to be able to set attributes.

00:33:56.890 --> 00:34:03.870
And the attributes that are available
that are recognized by the text system

00:34:03.870 --> 00:34:06.350
are listed for you in the app kits
and as distributed string.h header.

00:34:06.800 --> 00:34:09.220
: And let me just mention some of them.

00:34:09.270 --> 00:34:10.460
You can set fonts.

00:34:10.460 --> 00:34:13.900
You can set colors,
foreground and background colors.

00:34:14.000 --> 00:34:18.360
You can set underlines,
subscripting and superscripting.

00:34:18.440 --> 00:34:22.390
You can move the baseline up or down.

00:34:22.390 --> 00:34:26.780
You can control the use of ligatures.

00:34:26.780 --> 00:34:29.710
You can modify kerning.

00:34:29.710 --> 00:34:32.070
And there are also
paragraph-level attributes,

00:34:32.070 --> 00:34:32.070
things like

00:34:32.200 --> 00:35:03.900
[Transcript missing]

00:35:04.630 --> 00:35:12.300
As I say, the paragraph level attributes
are all part of NSParagraphStyle.

00:35:12.300 --> 00:35:18.200
And they're all set by
setting NSParagraphStyle.

00:35:18.200 --> 00:35:25.990
And this includes things like margins,
line spacing, justification,

00:35:25.990 --> 00:35:30.300
the wrapping style, and tab stops.

00:35:30.300 --> 00:35:34.990
Now one thing that is new for Jaguar
is that we now have complete support

00:35:35.100 --> 00:35:40.900
for all different kinds of tabs,
that is left tab stops, right, center,

00:35:40.900 --> 00:35:42.350
decimal tabs.

00:35:45.330 --> 00:35:49.960
There are a couple of special
attributes that I want to mention.

00:35:50.060 --> 00:35:54.390
One of them--okay,
when you have a document open in

00:35:54.400 --> 00:36:01.340
TextEdit and you drag in a file,
what you get is usually either an icon,

00:36:01.490 --> 00:36:05.430
or if the file's an image,
you might get inline representation

00:36:05.440 --> 00:36:08.340
of the image in the text.

00:36:08.340 --> 00:36:09.900
This is called an attachment.

00:36:09.900 --> 00:36:13.750
It's represented in the text
storage as a special character,

00:36:13.780 --> 00:36:17.610
the text attachment character,
with a special attribute,

00:36:17.680 --> 00:36:19.500
the text attachment attribute.

00:36:19.600 --> 00:36:22.620
And the value of that
attribute is a text attachment,

00:36:22.620 --> 00:36:24.620
an NSTextAttachment.

00:36:24.740 --> 00:36:30.300
This--what an NSTextAttachment usually
does is it points to a file wrapper.

00:36:30.400 --> 00:36:34.620
And this file wrapper-- I'm not gonna
discuss in detail file wrappers here,

00:36:34.620 --> 00:36:40.110
but the file wrapper models the contents
of the file or a link to the file.

00:36:40.400 --> 00:36:44.940
How is that going to be
displayed by the text system?

00:36:44.940 --> 00:36:48.870
If you just create one
with a file wrapper,

00:36:48.920 --> 00:36:52.620
then the text system will
automatically create some appropriate

00:36:52.620 --> 00:36:56.640
cell with an appropriate image,
typically according to what it

00:36:56.650 --> 00:37:00.550
thinks is best to represent that,
usually either an icon or

00:37:00.550 --> 00:37:04.180
an image representation,
if it's an image file.

00:37:04.240 --> 00:37:06.640
But you can change that programmatically.

00:37:06.640 --> 00:37:09.450
For example, if you have some alternate
image you want to use,

00:37:09.450 --> 00:37:13.820
you can simply set that image as
the image for the attachment cell.

00:37:13.820 --> 00:37:17.290
Or if you have some alternate
kind of cell you want to use,

00:37:17.300 --> 00:37:19.820
you can set that cell
for the text attachment.

00:37:20.020 --> 00:37:23.720
You can even create a custom
subclass of an attachment cell,

00:37:23.720 --> 00:37:28.640
and we'll discuss that in a moment,
to do more or less arbitrary

00:37:28.670 --> 00:37:31.080
drawing inside the text.

00:37:31.870 --> 00:37:35.360
Another attribute is the link attribute,
which is typically used to

00:37:35.360 --> 00:37:38.440
represent clickable hyperlinks.

00:37:38.440 --> 00:37:42.380
And usually the value of
that link might be an NSURL.

00:37:42.460 --> 00:37:47.240
The default behavior when clicking on
a section of text with this is to open

00:37:47.240 --> 00:37:51.790
that link in the user's default browser,
usually.

00:37:52.460 --> 00:37:53.930
But you can override that.

00:37:53.940 --> 00:37:58.840
Again, as the TextView is delegate,
you can respond to that click and

00:37:58.950 --> 00:38:01.800
do whatever behavior you want.

00:38:04.350 --> 00:38:06.660
I mentioned attribute fixing earlier.

00:38:06.850 --> 00:38:11.910
Attribute fixing is something that is
performed by the NS Text Storage lazily

00:38:12.040 --> 00:38:17.650
on demand whenever something
asks for some of its attributes.

00:38:17.660 --> 00:38:21.610
And it's at this point
that we make certain,

00:38:21.630 --> 00:38:26.120
for example,
that by font fixing that the font

00:38:26.120 --> 00:38:30.150
attribute for each character is a font
that can actually render that character.

00:38:30.360 --> 00:38:36.650
And we also do something called paragraph
fixing and make sure that the paragraph

00:38:36.660 --> 00:38:41.660
style attribute is actually constant
over the length of the entire paragraph,

00:38:41.660 --> 00:38:45.250
that is, from one hard library
character to the next.

00:38:45.250 --> 00:38:51.380
And another thing, among the things we do
is attachment fixing,

00:38:51.380 --> 00:38:55.060
which makes sure that the
attachment attribute always goes

00:38:55.060 --> 00:38:55.060
with the attachment character.

00:39:00.040 --> 00:39:04.640
So one obvious question is,
how do I get text into

00:39:04.640 --> 00:39:07.130
or out of a text storage?

00:39:07.340 --> 00:39:11.870
The format that the app--that
Cocoa usually uses for storing

00:39:11.870 --> 00:39:15.670
and transferring text is RTF,
or an extension RTFD for

00:39:15.670 --> 00:39:17.620
text that has attachments.

00:39:17.620 --> 00:39:21.510
This is the format that we'll
provide when putting styled

00:39:21.510 --> 00:39:23.260
text on the pasteboard.

00:39:23.310 --> 00:39:26.510
Of course,
we do provide plain text as well.

00:39:26.520 --> 00:39:32.570
And there are methods that you can
use to easily read or write RTF,

00:39:32.570 --> 00:39:37.840
RTFD to and from an NS Text storage
or any sub-range thereof.

00:39:39.340 --> 00:39:42.610
There are also some methods
that you can use to read into

00:39:42.620 --> 00:39:46.020
a text storage from a file.

00:39:46.020 --> 00:39:50.720
And for these methods, what we can do,
if you choose,

00:39:50.800 --> 00:39:57.200
is have the text system automatically
decide what format that file is in and

00:39:57.250 --> 00:40:00.490
automatically import from that file.

00:40:00.710 --> 00:40:04.460
Now, the formats we can import
from are obviously plain text,

00:40:04.550 --> 00:40:06.940
RTF and RTFD, plus a few others.

00:40:06.940 --> 00:40:10.720
We can import from the
simple text file format.

00:40:10.720 --> 00:40:13.220
And we can import from HTML.

00:40:13.220 --> 00:40:16.440
We do not write HTML out.

00:40:16.440 --> 00:40:21.000
And this list can also be
extended with the third-party

00:40:21.060 --> 00:40:24.240
additions called filter services.

00:40:24.240 --> 00:40:27.670
What a filter service is,
is something that one of you might write,

00:40:27.670 --> 00:40:31.160
install on the system,
and it would advertise what format

00:40:31.160 --> 00:40:35.360
it understands and what format
from among the ones we natively

00:40:35.360 --> 00:40:36.720
understand that it converts to.

00:40:36.720 --> 00:40:41.860
As when this is installed on the system,
the text system will know about it.

00:40:41.960 --> 00:40:45.180
And when a file of that type
is tempted to be opened,

00:40:45.180 --> 00:40:49.420
your filter service can automatically
be invoked to do that conversion.

00:40:49.420 --> 00:40:55.550
So any application using the text system
could then open files at that time.

00:40:56.770 --> 00:40:59.600
At this point,
I should probably say a little

00:40:59.600 --> 00:41:02.300
something about services in general.

00:41:02.300 --> 00:41:05.130
Filtered services are one small
special case of the general

00:41:05.250 --> 00:41:08.560
mechanism called services,
which are means of allowing

00:41:08.560 --> 00:41:11.600
third-party editions that act on text.

00:41:11.600 --> 00:41:13.880
Well,
they actually act on more than text,

00:41:13.970 --> 00:41:16.260
but this is a text talk,
and so I'll talk about

00:41:16.260 --> 00:41:17.680
how they apply to text.

00:41:17.700 --> 00:41:23.060
In a typical case of a service,
what will happen is that you can select

00:41:23.060 --> 00:41:27.840
some portion of text in any application,
invoke the service,

00:41:27.840 --> 00:41:32.410
that text is placed on the pasteboard,
send over to your service-providing

00:41:32.620 --> 00:41:35.670
application and process,
which then acts on it,

00:41:36.000 --> 00:41:39.180
performs whatever custom
modification your service provides,

00:41:39.200 --> 00:41:42.680
puts it back on the pasteboard,
sends it back to the

00:41:42.680 --> 00:41:44.880
requesting application,
or it's pasted back in.

00:41:44.900 --> 00:41:47.630
That's the standard kind of service.

00:41:47.820 --> 00:41:50.530
There are also filter services,
as I have mentioned.

00:41:50.640 --> 00:41:52.820
Filter services for text.

00:41:53.020 --> 00:41:58.330
There are also--are filter
services available for images.

00:41:58.660 --> 00:42:01.120
And there's one other
custom kind of service,

00:42:01.190 --> 00:42:04.140
and that is a spell checking service.

00:42:04.140 --> 00:42:07.430
So it is possible, as you know,
Cocoa applications can

00:42:07.430 --> 00:42:09.060
make use of spell checking.

00:42:09.230 --> 00:42:16.680
But it is possible for anyone to write
a third-party spell checker that can

00:42:16.680 --> 00:42:20.350
be installed on the system and made
available to users as an option they

00:42:20.350 --> 00:42:20.350
can select in the spelling panel.

00:42:20.860 --> 00:42:24.810
Of course, Apple does ship a spell
checker with the system.

00:42:24.870 --> 00:42:28.290
I should note that for Jaguar,
that our spell checker has

00:42:28.290 --> 00:42:29.280
been entirely replaced.

00:42:29.280 --> 00:42:37.860
We now have an entirely new spell
checker that is much improved

00:42:37.860 --> 00:42:40.630
in its English version and that
also has support now for a number

00:42:40.630 --> 00:42:40.630
of other languages as well.

00:42:45.580 --> 00:42:51.830
One other way of storing things
in the text system is archiving.

00:42:53.250 --> 00:42:56.350
Archiving is a mechanism, for example,
that Interface View Builder

00:42:56.350 --> 00:42:57.660
uses to store its nibs.

00:42:57.750 --> 00:43:01.470
I can't discuss archiving
in complete generality here,

00:43:01.470 --> 00:43:05.640
but I do want to say some things
about it for those of you who

00:43:05.640 --> 00:43:08.220
know what it is and what it does.

00:43:08.220 --> 00:43:10.100
If you were at the
Cocoa What's New session,

00:43:10.100 --> 00:43:14.290
you know that there have been some
significant changes to archiving.

00:43:14.310 --> 00:43:17.580
We now have the new
keyed archiving system.

00:43:17.840 --> 00:43:22.190
Now, it used to be pre-Jaguar that most
of the classes in the text system

00:43:22.190 --> 00:43:23.800
would not archive themselves.

00:43:23.910 --> 00:43:28.310
It was just one special case that was
used by Interface Builder for TextViews.

00:43:28.450 --> 00:43:32.510
But now, with the new keyed archiving,
all the major classes in

00:43:32.510 --> 00:43:34.700
the text system can archive.

00:43:34.700 --> 00:43:40.010
So it is now possible to archive
more or less arbitrary configuration,

00:43:40.010 --> 00:43:45.190
like the one I have on this demo app,
of multiple layout managers,

00:43:45.220 --> 00:43:49.110
text containers, text storages,
TextViews, and so forth.

00:43:49.110 --> 00:43:54.250
Now, when you archive a text storage,
well, when you store a text as RTF,

00:43:54.250 --> 00:43:59.160
the attributes have to be converted
into the form of RTF_understands,

00:43:59.210 --> 00:44:03.510
and only those attributes that are
convertible to RTF will be stored.

00:44:03.820 --> 00:44:07.610
When you archive a text storage,
on the other hand,

00:44:07.610 --> 00:44:10.380
all the attributes will be stored.

00:44:10.380 --> 00:44:12.760
But one corollary to this, of course,
is that if you create

00:44:12.760 --> 00:44:15.790
some custom attribute,
which you certainly can,

00:44:15.790 --> 00:44:22.280
it might be a good idea to make sure
that the values used for that normal.

00:44:26.950 --> 00:44:30.460
So we've discussed dealing
with the model layer,

00:44:30.460 --> 00:44:31.820
the text storage.

00:44:31.900 --> 00:44:35.000
Now I want to talk about sorts of
things you can do by dealing with

00:44:35.000 --> 00:44:36.980
the controller level of the system,
that is,

00:44:37.040 --> 00:44:39.530
with the layout manager primarily.

00:44:39.650 --> 00:44:46.190
I said the layout manager controls the
processes of lift generation and layout.

00:44:46.420 --> 00:44:51.390
The Layout Manager is the object
that stores the glyphs themselves.

00:44:51.440 --> 00:44:59.990
It stores all the layout information
and performs glyph generation

00:44:59.990 --> 00:44:59.990
and layout as needed on demand.

00:45:02.800 --> 00:45:06.370
And as we saw in our example of
the multiple layout managers,

00:45:06.370 --> 00:45:10.710
that when the text is changed,
the layout manager observes that change,

00:45:10.710 --> 00:45:14.630
the text storage notifies it,
and the layout manager invalidates

00:45:14.630 --> 00:45:18.610
any stored information it might have
that is made invalid by that change

00:45:18.610 --> 00:45:21.130
for later recomputation on demand.

00:45:21.300 --> 00:45:28.200
It is also possible for you to manually
invalidate some of that information if

00:45:28.200 --> 00:45:28.200
you want to force it to be recalculated.

00:45:34.340 --> 00:45:36.190
Now,
remember what I said at the beginning,

00:45:36.190 --> 00:45:42.200
that the mapping between characters and
glyphs is not necessarily one to one.

00:45:42.300 --> 00:45:45.650
So since it's the LayoutManager
that controls the glyph generation,

00:45:45.650 --> 00:45:50.010
the LayoutManager is the one that
knows exactly how this mapping works.

00:45:50.010 --> 00:45:54.930
So if you want to know which character,
which range of characters maps to which

00:45:54.930 --> 00:45:58.370
range of glyphs in the glyph stream,
you ask the LayoutManager.

00:45:58.370 --> 00:45:59.880
LayoutManager will tell you.

00:45:59.880 --> 00:46:02.730
LayoutManager stores the glyphs.

00:46:02.730 --> 00:46:09.010
And if you can ask it what the
glyphs are for any particular range,

00:46:09.190 --> 00:46:13.690
Generally speaking,
the glyphs are just numerical

00:46:13.830 --> 00:46:15.860
indexes into a font.

00:46:15.860 --> 00:46:18.450
There are a couple of
special values that we use.

00:46:18.510 --> 00:46:22.160
There's a control glyph that's used
for non-printed characters like

00:46:22.260 --> 00:46:24.290
tabs and line breaks and so forth.

00:46:24.380 --> 00:46:27.390
And there's a null glyph that the
layout manager will sometimes use for

00:46:27.460 --> 00:46:29.440
padding for its own internal purposes.

00:46:29.440 --> 00:46:33.390
The layout manager also stores
certain what are called glyph

00:46:33.600 --> 00:46:35.480
attributes on the glyphs.

00:46:35.600 --> 00:46:37.810
These are completely different
from the character attributes

00:46:37.860 --> 00:46:40.560
we've been talking about along.

00:46:40.560 --> 00:46:44.080
The glyph attributes are things
like the elastic attribute,

00:46:44.090 --> 00:46:49.760
which appears usually on spaces to show
that they can be -- they might not need

00:46:49.760 --> 00:46:52.630
to be laid out at the end of a line.

00:46:53.030 --> 00:46:57.010
They can be expanded as
needed for justification.

00:46:57.100 --> 00:47:00.170
There is also an inscription attribute,
for example.

00:47:00.170 --> 00:47:04.940
This would be used on things like
an accent character to show that the

00:47:04.940 --> 00:47:10.980
accent should be laid out above the
preceding glyph instead of following it.

00:47:14.520 --> 00:47:16.940
When the Layout
Manager needs to do layout,

00:47:16.940 --> 00:47:20.360
it contacts the typesetter,
instance of NSTypeSetter,

00:47:20.480 --> 00:47:22.500
which actually does the layout.

00:47:22.630 --> 00:47:25.180
So the typesetter

00:47:25.270 --> 00:47:28.800
contacts the layout manager to
find out what the glyphs are.

00:47:28.870 --> 00:47:33.200
Then it contacts the text container
to find out what the geometry,

00:47:33.200 --> 00:47:36.190
what the geometric region
they are to be laid out in.

00:47:36.190 --> 00:47:40.770
And then it's the typesetter that
breaks the glyphs up into lines and

00:47:40.770 --> 00:47:45.460
positions the lines in the containers,
positions the glyphs in the lines.

00:47:45.530 --> 00:47:50.130
And the typesetter is also allowed
to make insertions or changes in

00:47:50.190 --> 00:47:51.990
the glyph stream as necessary.

00:47:51.990 --> 00:47:57.570
For example, if hyphenation is in effect,
then the typesetter might need to

00:47:57.570 --> 00:48:04.530
insert a hyphen glyph into the glyph
stream when a hyphenation is performed.

00:48:04.540 --> 00:48:06.900
And then when the
typesetter has done this,

00:48:06.950 --> 00:48:10.480
it calls back and notifies that
layout manager as to exactly

00:48:10.480 --> 00:48:12.530
where each glyph ended up.

00:48:12.530 --> 00:48:16.840
So it tells the layout manager
which container a glyph ended

00:48:16.840 --> 00:48:21.090
up in and what line within that
container the glyph ended up in,

00:48:21.090 --> 00:48:24.570
what position of the line
is and the size of the line,

00:48:24.580 --> 00:48:28.600
and the location of each
individual glyph in that line.

00:48:28.600 --> 00:48:31.240
And the layout manager
stores that information.

00:48:31.240 --> 00:48:35.140
So usually you will not want to
contact the typesetter directly.

00:48:35.150 --> 00:48:37.780
You ask the layout manager
for any of that information.

00:48:39.500 --> 00:48:43.130
So, for example,
if you were writing your chat program

00:48:43.160 --> 00:48:46.470
and you wanted to put some nice
fancy bubbles around your text,

00:48:46.470 --> 00:48:49.000
you need to know where it was laid out.

00:48:49.000 --> 00:48:50.630
You ask the layout manager.

00:48:50.630 --> 00:48:55.360
The layout manager can tell
you many things about layout.

00:48:55.360 --> 00:48:58.950
It can tell you where
each line is located,

00:48:58.950 --> 00:49:03.430
what its size is positioned
within a text container.

00:49:03.430 --> 00:49:08.720
It can tell you which glyphs ended
up in a particular text container.

00:49:08.720 --> 00:49:14.140
It can tell you for any particular glyph
what text container it ended up in,

00:49:14.140 --> 00:49:18.310
what line it ended up in,
and where in that line it went.

00:49:19.530 --> 00:49:21.800
It can also do a number
of different conversions.

00:49:21.970 --> 00:49:24.640
For example,
if you have a particular point and

00:49:24.640 --> 00:49:28.800
you want to know what glyph lies at
that point or closest to that point,

00:49:28.980 --> 00:49:31.140
the Layout Manager will tell you.

00:49:31.170 --> 00:49:38.000
If you have some range of glyphs and
say these are the selected glyphs and

00:49:38.000 --> 00:49:45.290
you want to know what rectangle should
be drawn to represent the selection,

00:49:45.290 --> 00:49:45.290
the Layout Manager will tell you that.

00:49:46.700 --> 00:50:06.150
And again, it is actually the layout
manager that does the drawing

00:50:06.150 --> 00:50:06.150
at the request of the view.

00:50:06.150 --> 00:50:06.150
That is, the layout manager marshals
the list of glyphs,

00:50:06.150 --> 00:50:06.150
their positions, and sends them down
to courts to be drawn,

00:50:06.150 --> 00:50:06.150
along with drawing other things
like backgrounds and underlines.

00:50:06.150 --> 00:50:06.150
And

00:50:06.350 --> 00:50:10.300
You do not have to actually
use an NSTextView to use this.

00:50:10.300 --> 00:50:13.810
You can do this, for example,
in your own custom view class,

00:50:13.840 --> 00:50:15.260
a couple of caveats.

00:50:15.260 --> 00:50:20.010
You must have locked focus on some
appropriate view to do the drawing.

00:50:20.010 --> 00:50:25.300
And one other thing to remember when
you do this is that the LayoutManager's

00:50:25.300 --> 00:50:30.660
notion of position of glyphs is almost
always relative to the text container,

00:50:30.660 --> 00:50:32.880
not necessarily coordinates
in any particular view.

00:50:32.880 --> 00:50:34.740
It's coordinates in the text container.

00:50:34.740 --> 00:50:38.700
Now, there is an example of this, again,
on your CDs.

00:50:38.790 --> 00:50:43.320
This is the CircleView example
in the AppKit examples.

00:50:44.940 --> 00:50:50.370
And that gives a very straightforward
example of how to draw glyphs

00:50:50.370 --> 00:50:56.040
in a custom view by talking
to the lab manager directly.

00:50:56.220 --> 00:51:00.030
Now, at this point,
I have another small demo.

00:51:04.210 --> 00:51:06.920
So,
suppose you wanted to do something else,

00:51:06.920 --> 00:51:10.230
something like,
something special for a rollover,

00:51:10.240 --> 00:51:12.530
a rollover effect in your text view.

00:51:12.610 --> 00:51:16.700
I decided to give a very
simple example of that.

00:51:16.700 --> 00:51:16.700
If you want to know

00:51:17.030 --> 00:51:21.070
If you know where the
mouse is in the text view,

00:51:21.070 --> 00:51:24.730
then you can ask the
layout manager to find out,

00:51:24.780 --> 00:51:29.460
for example, what glyph it's over,
what character that corresponds

00:51:29.460 --> 00:51:34.360
to or what set of characters,
and other things like what line it's in.

00:51:34.420 --> 00:51:39.110
And so, for example, as I roll over,
I've asked that,

00:51:39.110 --> 00:51:43.070
and then I've highlighted
those characters,

00:51:43.070 --> 00:51:44.480
those glyphs, in some specific colors.

00:51:46.780 --> 00:51:50.480
Again, a very simple example,
under 25 lines, and you should be able

00:51:50.480 --> 00:51:53.160
to download it from ADC.

00:52:07.710 --> 00:52:14.800
On to the final and more
dangerous portions of the talk.

00:52:17.370 --> 00:52:20.580
If you want to go beyond this,
you may wish to subclass one of

00:52:20.580 --> 00:52:23.340
the objects in the text system.

00:52:23.340 --> 00:52:26.170
So before you subclass one of
the objects in the text system,

00:52:26.320 --> 00:52:30.210
first I'd like you to check to
see whether you can do what you

00:52:30.210 --> 00:52:33.060
want to do without subclassing.

00:52:33.110 --> 00:52:38.860
So there are quite a lot of options
and settings that you can use.

00:52:38.890 --> 00:52:42.090
I've mentioned so far,
there are many that I haven't mentioned.

00:52:42.100 --> 00:52:43.740
And you should take a
look at some of these.

00:52:43.740 --> 00:52:46.500
They can do a lot of interesting
things for you without subclassing.

00:52:46.570 --> 00:52:49.900
For example,
I mentioned something about selected

00:52:49.900 --> 00:52:52.300
text attributes in the text view.

00:52:52.440 --> 00:52:55.000
Usually the selection is
displayed as a gray rectangle.

00:52:55.000 --> 00:52:56.710
That's by changing the background color.

00:52:56.810 --> 00:53:00.220
But that's actually something
you can choose arbitrarily.

00:53:00.220 --> 00:53:02.990
You could choose an
arbitrary set of attributes.

00:53:03.510 --> 00:53:06.150
for representing the selected text.

00:53:06.150 --> 00:53:10.000
Another thing is a mechanism
called temporary attributes.

00:53:10.020 --> 00:53:13.420
And that was actually the mechanism
I used on this most recent demo

00:53:13.420 --> 00:53:15.580
to change the background color.

00:53:15.580 --> 00:53:20.240
Temporary attributes are
character-style attributes,

00:53:20.240 --> 00:53:23.600
like primarily colors,
that can be set at the

00:53:23.600 --> 00:53:24.850
layout manager level.

00:53:24.850 --> 00:53:27.720
So they affect only some
specific layout manager.

00:53:27.720 --> 00:53:30.030
They don't change the
underlying text storage.

00:53:30.030 --> 00:53:32.960
They can be used for things
like temporary highlighting,

00:53:33.010 --> 00:53:36.000
maybe syntax coloring or
something of that sort.

00:53:36.000 --> 00:53:41.060
So you should take a look at many
of the options that can be set.

00:53:41.060 --> 00:53:44.500
You should try using
notification and delegation.

00:53:44.500 --> 00:53:47.920
As I mentioned,
it's a very powerful mechanism.

00:53:47.920 --> 00:53:52.810
For example, the first demo I did,
you can intercept a wide variety

00:53:52.810 --> 00:53:54.800
of user actions this way.

00:53:54.830 --> 00:53:56.930
But if you do decide
that you need a subclass,

00:53:56.980 --> 00:53:59.770
if what you want to do can't be done,
one of the things I've mentioned so far,

00:53:59.820 --> 00:54:02.020
then you should try to
override the user actions.

00:54:02.020 --> 00:54:05.020
The second thing is to use the minimal
set of methods to do what you want to do.

00:54:05.020 --> 00:54:08.350
So let me talk about some of
the interesting things you might

00:54:08.370 --> 00:54:10.400
want to subclass and what you can

00:54:11.160 --> 00:54:13.240
You might want to
subclass the model level,

00:54:13.340 --> 00:54:14.610
NSTextStorage.

00:54:14.950 --> 00:54:18.700
You could subclass an NSTextStorage,
for example, to provide your own storage

00:54:18.740 --> 00:54:20.190
mechanism for the text.

00:54:20.290 --> 00:54:23.080
For example,
maybe your underlying model in your

00:54:23.080 --> 00:54:28.160
app is not an attributed string,
but say, some character-- sequence of

00:54:28.160 --> 00:54:32.520
characters with nested style
sheets or something of that sort.

00:54:32.670 --> 00:54:36.600
You might have a custom text storage
subclass that converts from your

00:54:36.600 --> 00:54:39.870
underlying representation to the
representation the app gets once,

00:54:39.910 --> 00:54:41.940
text storage.

00:54:41.940 --> 00:54:45.380
You might subclass NSTextStorage
if you want to intervene at

00:54:45.380 --> 00:54:48.360
the attribute fixing level,
if you want to modify what

00:54:48.360 --> 00:54:50.600
is done in attribute fixing,
if you want to add some

00:54:50.600 --> 00:54:52.540
attribute fixing of your own.

00:54:52.540 --> 00:54:57.680
Or perhaps you might want to modify it to
subclass NSTextStorage so it notifies not

00:54:57.680 --> 00:55:03.380
just the layout managers but some other
objects of your own when it changes.

00:55:05.050 --> 00:55:08.700
You can subclass in this text container.

00:55:08.730 --> 00:55:12.400
I should say that all the objects
I'm mentioning here now have fairly

00:55:12.400 --> 00:55:16.520
well-defined subclass interfaces,
and so they should be

00:55:16.620 --> 00:55:19.590
reasonably easy to subclass.

00:55:19.700 --> 00:55:23.120
The obvious reason to subclass
NSTextContainer is to provide

00:55:23.120 --> 00:55:27.300
some custom geometry that's more
complicated than just a rectangle.

00:55:27.360 --> 00:55:35.310
And you can get more or less arbitrary
geometry by subclassing NSTextContainer.

00:55:35.710 --> 00:55:38.720
The way this works is that your
text container subclass will

00:55:38.730 --> 00:55:40.360
be asked by the typesetter.

00:55:40.360 --> 00:55:42.650
The typesetter will say,
"I want to lay out

00:55:42.650 --> 00:55:44.040
some text in this line.

00:55:44.040 --> 00:55:47.640
I propose this rectangle here."
And you get to modify it and say,

00:55:47.640 --> 00:55:52.970
"No, no, you really want to use this
rectangle here." And if you have

00:55:52.970 --> 00:55:58.720
holes in your text container,
you can say, "And by the way,

00:55:58.810 --> 00:56:00.230
there's some more space following
the hole that you can use,

00:56:00.230 --> 00:56:00.230
too."

00:56:04.090 --> 00:56:08.340
Subclass NSTextView Subclass
NSTextView is what does the

00:56:08.340 --> 00:56:10.000
drawing and the user interaction.

00:56:10.000 --> 00:56:14.480
You can subclass NSTextView to alter,
in more or less arbitrary ways,

00:56:14.620 --> 00:56:18.700
the way that the view
interacts with the user.

00:56:18.700 --> 00:56:25.100
You might alter selection behavior,
you might alter drawing behavior,

00:56:25.100 --> 00:56:28.920
you might alter click behavior,
you might alter auxiliary

00:56:28.920 --> 00:56:32.750
things like context menus,
you might alter the behavior of

00:56:32.750 --> 00:56:36.310
cut and paste or drag and drop,
any number of things.

00:56:39.310 --> 00:56:41.880
Going a little further,
you might want to subclass

00:56:41.880 --> 00:56:43.440
possibly NSLayoutManager.

00:56:43.440 --> 00:56:49.860
Now, remember that NSLayoutManager is a
class that actually does the drawing.

00:56:50.020 --> 00:56:55.800
So, you might want to subclass
NSLayoutManager if you want to provide,

00:56:55.800 --> 00:57:00.240
let's say, some custom drawing
behavior at this level,

00:57:00.440 --> 00:57:05.150
custom background drawing, or custom,
maybe you want to respond to some

00:57:05.150 --> 00:57:05.150
custom attributes that you have set.

00:57:05.890 --> 00:57:10.330
You might want to subclass to store
additional attributes that you may

00:57:10.340 --> 00:57:14.690
have defined on that occur on the
glyphs rather than on the characters.

00:57:14.810 --> 00:57:18.470
Or you might subclass to override
some of the other behavior

00:57:18.610 --> 00:57:20.740
that a layout manager provides.

00:57:20.750 --> 00:57:23.080
As I said,
the layout manager is what gets

00:57:23.100 --> 00:57:26.910
interrogated to find out what glyph
lies under a particular point,

00:57:26.910 --> 00:57:30.500
or it provides the rectangles
that represent selections.

00:57:30.500 --> 00:57:35.800
So you might override NSLayoutManager
to override any of that behavior.

00:57:37.390 --> 00:57:40.650
You might override NSTextAttachmentCell.

00:57:40.780 --> 00:57:42.850
As I mentioned,
there are many ways that you

00:57:42.860 --> 00:57:46.760
can alter the drawing that
represents a text attachment.

00:57:46.870 --> 00:57:48.900
You can supply a custom image.

00:57:49.010 --> 00:57:51.050
You can supply a custom cell.

00:57:51.150 --> 00:57:54.700
You can use a custom subclass
in NSTextAttachmentCell.

00:57:54.760 --> 00:58:00.120
And with this,
you can obtain more or less arbitrary

00:58:00.120 --> 00:58:04.370
drawing within some region that you
get to pick in line in the text.

00:58:04.700 --> 00:58:08.010
And not only that,
but it is also possible with such a

00:58:08.080 --> 00:58:13.290
subclass to be able to handle user clicks
within that region in the text view.

00:58:15.900 --> 00:58:52.700
[Transcript missing]

00:58:53.660 --> 00:58:56.640
At this point, I have one final demo.

00:58:56.720 --> 00:58:58.300
This is one I didn't write.

00:58:58.490 --> 00:59:00.860
So here's a new address book application.

00:59:00.860 --> 00:59:05.390
Let's see how some of all this comes
together in a real application.

00:59:05.480 --> 00:59:08.940
So first of all, let's notice what sort
of things we have here.

00:59:09.130 --> 00:59:12.440
We have, well,
there might be an image here,

00:59:12.500 --> 00:59:15.290
a picture of the user,
if we had a picture.

00:59:15.380 --> 00:59:18.790
And there's a custom text
container here that is cut

00:59:19.000 --> 00:59:21.400
out with space for this image.

00:59:21.970 --> 00:59:26.880
You notice some nice little rollover
effects as we move over various items.

00:59:26.890 --> 00:59:29.380
You've seen how to do that.

00:59:29.820 --> 00:59:33.560
Let's see if we go to edit it.

00:59:33.590 --> 00:59:36.580
There are some changes
to selection behavior.

00:59:39.350 --> 00:59:39.920
What else do we have?

00:59:39.940 --> 00:59:40.300
Awesome.

00:59:40.300 --> 00:59:44.630
Custom cell for drawing this.

00:59:47.710 --> 00:59:50.700
Well, there are a number of
little tricks in here,

00:59:50.700 --> 00:59:52.360
and I'll let you play
around with it yourselves.

00:59:52.360 --> 00:59:55.790
You all have a copy of this,
and you can see how it works.

00:59:59.800 --> 01:00:01.150
So where do you go from here?

01:00:01.220 --> 01:00:03.270
I've mentioned a number of examples.

01:00:03.350 --> 01:00:04.760
There are some others.

01:00:04.850 --> 01:00:08.850
There are a number of
text-related examples on your CD.

01:00:08.950 --> 01:00:12.120
There is also some documentation of this.

01:00:12.120 --> 01:00:16.700
They -- in the
Cocoa documentation section,

01:00:16.700 --> 01:00:19.510
you can find it on the website,
if you have one.

01:00:19.510 --> 01:00:24.460
There are, of course, a number of books,
program topics, and other things

01:00:27.900 --> 01:00:34.900
Of course, most of the sessions
have already occurred.

01:00:34.900 --> 01:00:38.020
And you can contact Heather Hickman,
our technology manager.

01:00:38.080 --> 01:00:45.620
And we also have a mailing list,
Cocoa Dev, and a feedback address for

01:00:45.620 --> 01:00:45.620
sending feedback to us.
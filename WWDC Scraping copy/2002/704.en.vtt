WEBVTT

00:00:07.500 --> 00:00:10.510
Our next session this
afternoon is XML in WebObjects.

00:00:10.530 --> 00:00:13.090
I'd like to introduce Bob Frank,
who's going to give the

00:00:13.170 --> 00:00:15.100
presentation for this session.

00:00:15.100 --> 00:00:16.140
Bob?

00:00:16.140 --> 00:00:18.400
Thank you, Toni.

00:00:26.930 --> 00:00:27.360
Hold on.

00:00:27.360 --> 00:00:29.210
There's the clicker.

00:00:29.260 --> 00:00:31.260
Good afternoon.

00:00:31.260 --> 00:00:33.070
Welcome to XML in WebObjects.

00:00:33.520 --> 00:00:38.370
Today we're going to cover a wide
variety of materials so that you

00:00:38.430 --> 00:00:41.620
can get familiar with what is XML,
how to use it in WebObjects,

00:00:41.890 --> 00:00:43.490
and why you should be using it.

00:00:43.680 --> 00:00:47.230
Han Ming is going to cover
the basics of what XML is,

00:00:47.480 --> 00:00:51.680
what are the key concepts,
and basically give you an overview

00:00:51.680 --> 00:00:52.710
if you're not familiar with it.

00:00:53.130 --> 00:00:57.490
Also he'll discuss serialization
of... using XML to read and

00:00:57.500 --> 00:01:01.260
write simple configuration files,
which is a very common use of XML.

00:01:01.260 --> 00:01:05.330
Also we'll be discussing
serialization of EOs.

00:01:05.420 --> 00:01:08.640
Slightly more sophisticated,
but using the same approach

00:01:08.640 --> 00:01:14.540
as you use for reading and
writing files is serializing

00:01:14.540 --> 00:01:22.570
EOs into XML and also using XSLT,
which is XML-style transformations,

00:01:22.590 --> 00:01:27.910
which allow you to transform one
XML document into another XML document.

00:01:27.920 --> 00:01:32.330
Lastly,
we'll be discussing a very popular way of

00:01:32.330 --> 00:01:35.850
using XML to communicate between servers,
XML RPC.

00:01:35.860 --> 00:01:40.700
We'll discuss what it is, how to use it,
and compare and contrast it with SOAP.

00:01:40.760 --> 00:01:44.040
You'll see the letter X so
many times in this session that

00:01:44.330 --> 00:01:45.650
you'll probably be sick of it.

00:01:45.880 --> 00:01:49.400
And without further ado, Han Ming.

00:01:53.060 --> 00:01:53.480
There you go.

00:01:53.540 --> 00:01:55.690
This button.

00:01:55.830 --> 00:01:56.830
Good afternoon.

00:01:56.940 --> 00:01:58.090
My name is Han-Ming Ong.

00:01:58.090 --> 00:02:00.590
I'm in the engineering team.

00:02:00.590 --> 00:02:03.470
And I'm going to give you
a quick refresher on XML.

00:02:03.550 --> 00:02:07.230
I have 10 to 15 minutes,
so I'm going to assume that you

00:02:07.260 --> 00:02:09.760
have done some XML work before.

00:02:09.840 --> 00:02:12.750
So I'm going to give you some definition,
basic definitions of XML,

00:02:12.750 --> 00:02:15.110
followed by constraints,
so that it can make

00:02:15.210 --> 00:02:16.390
sense out of XML data.

00:02:16.390 --> 00:02:25.120
There are two main specifications.

00:02:25.120 --> 00:02:25.120
Sorry about that.

00:02:25.750 --> 00:02:27.100
Okay.

00:02:27.180 --> 00:02:29.690
So there are two main specifications
for doing constraints.

00:02:29.970 --> 00:02:33.460
One is document type definition, DTD,
and schema.

00:02:33.460 --> 00:02:39.480
So as Bob mentioned, with XML technology,
there's a proliferation of acronyms.

00:02:39.480 --> 00:02:41.970
So my advice is don't worry
too much about the letters,

00:02:41.970 --> 00:02:44.280
but try to understand
the meaning behind them.

00:02:45.290 --> 00:02:48.360
Then I'll talk about
processing of XML data,

00:02:48.360 --> 00:02:53.400
which means the producing and the
consumption and the consuming of

00:02:53.400 --> 00:02:58.200
XML data using low-level APIs like DOM,
DOM, SAX, and JXP.

00:03:00.150 --> 00:03:03.540
Then I'm going to give you a list
of parsers that one would use

00:03:03.590 --> 00:03:05.480
to parse and consume XML data.

00:03:10.070 --> 00:03:11.540
So what is XML?

00:03:11.560 --> 00:03:16.520
Essentially, XML is structured data that
always has the same fixed,

00:03:16.780 --> 00:03:18.670
big, synthetic formation.

00:03:18.830 --> 00:03:21.360
It is always hierarchical
and tree-like form,

00:03:21.380 --> 00:03:25.240
which means for developers like us,
we worry a lot less about the how

00:03:25.240 --> 00:03:28.110
of extracting information out of it.

00:03:28.460 --> 00:03:32.330
And because it is organized,
so it is familiar for

00:03:32.400 --> 00:03:33.400
laymen to read as well.

00:03:33.610 --> 00:03:36.650
That's one of the goals of XML.

00:03:37.240 --> 00:03:41.640
The other great goal of XML is
that it should be portable.

00:03:41.770 --> 00:03:46.520
And the reason why it is portable is
because it encodes the data as text.

00:03:46.770 --> 00:03:50.820
A piece of text string is the
same across different development

00:03:50.820 --> 00:03:52.770
platforms and languages.

00:03:53.390 --> 00:03:57.170
and not only is it in text,
it accepts Unicode characters.

00:03:57.340 --> 00:04:01.640
That means all the languages in
the world can be written in XML.

00:04:01.710 --> 00:04:04.580
And it puts that encoding right at the
top in the declaration so that most

00:04:04.720 --> 00:04:08.780
of the time you don't have to apply
heuristics to try to understand it.

00:04:09.350 --> 00:04:12.740
The next slide I'm going to show
you is a simple XML document

00:04:13.010 --> 00:04:15.020
so that you have a feel of it.

00:04:20.720 --> 00:04:25.500
So the first line that you see is
what we call the XML declaration.

00:04:25.540 --> 00:04:27.340
The version is 1.0.

00:04:27.360 --> 00:04:31.920
The W3C organization did a good job,
so after two years or so, it's still 1.0.

00:04:32.060 --> 00:04:34.180
They may wrap it up soon to 1.1.

00:04:34.200 --> 00:04:40.240
The encoding that we see here is UTF-8,
which is a good default encoding.

00:04:40.380 --> 00:04:43.930
For your, you know,
if you have just have English, you can,

00:04:44.110 --> 00:04:47.100
you can, you can don't put it down
or you can put S-U-S-S key.

00:04:47.100 --> 00:04:48.960
That will make the parsing a lot faster.

00:04:50.480 --> 00:04:53.360
Here in this XML document,
we see a root element

00:04:53.650 --> 00:04:55.180
called purchase order.

00:04:55.210 --> 00:04:57.260
The starting tag is a line 3.

00:04:57.290 --> 00:04:59.670
The ending tag is a line 10.

00:05:00.390 --> 00:05:06.340
This root element has two char,
comment and item.

00:05:06.440 --> 00:05:10.060
And here it has an
attribute called order date.

00:05:10.150 --> 00:05:12.740
Attributes may or may not be required.

00:05:12.870 --> 00:05:15.850
When it's present,
it usually means metadata.

00:05:16.080 --> 00:05:19.830
and to illustrate the fact that
you can have Unicode character,

00:05:19.830 --> 00:05:23.290
I put in some Chinese character,
which I'm sure all of you understand.

00:05:27.050 --> 00:05:27.710
OK.

00:05:28.190 --> 00:05:29.160
This thing right here.

00:05:29.210 --> 00:05:30.160
I figured it out.

00:05:30.210 --> 00:05:32.340
Linking at me.

00:05:32.400 --> 00:05:33.690
Constraints.

00:05:33.780 --> 00:05:36.660
The above XML document that we just saw

00:05:37.090 --> 00:05:41.250
adheres to a concept called
well-formedness that is defined by

00:05:41.780 --> 00:05:43.930
the basic XML 1.0 specifications.

00:05:44.000 --> 00:05:48.920
The basic rules say stuff like,
you must have one and only one

00:05:48.920 --> 00:05:53.400
root element in an XML document,
and every element must have an

00:05:53.470 --> 00:05:55.370
opening tag and an ending tag.

00:05:55.500 --> 00:05:57.600
There are many exceptions to it.

00:05:58.130 --> 00:06:02.490
Validity is a contract of
structure between the producer

00:06:03.450 --> 00:06:05.800
and the consumer of the XML data.

00:06:05.890 --> 00:06:09.750
The producer of the XML data
would say stuff something like,

00:06:09.750 --> 00:06:14.230
expect to see the root element
purchase order having a child element,

00:06:14.260 --> 00:06:17.510
two child elements, comment an item.

00:06:18.240 --> 00:06:21.450
The contract of structure varies
across domains and industry.

00:06:21.450 --> 00:06:24.020
So when one says that an
XML document is valid,

00:06:24.140 --> 00:06:28.160
it is always with respect to a contract.

00:06:28.310 --> 00:06:31.900
And the structural contract
is defined in two ways.

00:06:31.950 --> 00:06:33.990
More than two ways,
but the two most common

00:06:34.020 --> 00:06:39.400
ways is using DTD,
document depth definition, and schemas.

00:06:43.910 --> 00:06:45.960
So document type definition.

00:06:46.310 --> 00:06:48.440
That's rooted way back in the SGML world.

00:06:48.490 --> 00:06:53.500
And so for some of us
who have worked with XML,

00:06:53.500 --> 00:06:55.520
you may find the syntax a bit weird.

00:06:55.630 --> 00:06:58.630
But to some of the old timers out there,
it's very natural.

00:06:58.640 --> 00:07:02.350
So you still have to publish
your contract in DTD.

00:07:03.250 --> 00:07:06.160
The two main deficiencies with DTD,
unfortunately, is that it doesn't

00:07:06.160 --> 00:07:07.140
have a typing facility.

00:07:08.620 --> 00:07:10.820
and that it doesn't work
naturally with namespace.

00:07:10.920 --> 00:07:13.220
Now, words in English,
common words in English,

00:07:13.260 --> 00:07:15.990
are very important to some domains,
and they are common.

00:07:16.160 --> 00:07:18.740
So you have to have namespace
to avoid the name conflict,

00:07:18.840 --> 00:07:22.250
just like packages or namespace in C++.

00:07:22.500 --> 00:07:24.900
So in the next slide,
I'm going to show you an example,

00:07:24.900 --> 00:07:29.300
a simple example of a DTD, part of it,
that constrains the XML data

00:07:29.300 --> 00:07:30.180
that we saw earlier on.

00:07:30.200 --> 00:07:32.370
I don't want you to
focus too much into it,

00:07:32.380 --> 00:07:35.190
but just, you know,
you'll find it intuitive.

00:07:38.010 --> 00:07:41.300
So what it says here is,
you might find an element

00:07:41.300 --> 00:07:43.720
called purchase order,
and it must have two child

00:07:43.720 --> 00:07:46.850
elements in sequence,
comment, and item.

00:07:46.860 --> 00:07:51.060
And it must have an
attribute called order date,

00:07:51.360 --> 00:07:53.730
and it must be a parsed data.

00:07:53.740 --> 00:07:55.460
So on and so forth.

00:07:59.240 --> 00:08:21.430
Schema.

00:08:21.430 --> 00:08:21.430
The same grand goals as DTD,
except that there are

00:08:21.430 --> 00:08:21.430
three main differences.

00:08:21.430 --> 00:08:21.430
The first one is it's written in XML,
which means for most of us

00:08:21.430 --> 00:08:21.430
who are familiar with XML,
it's easy.

00:08:21.430 --> 00:08:21.430
You can use your favorite XML editor,
create your schema file,

00:08:21.430 --> 00:08:21.430
and have it validate
across the schema schema.

00:08:22.170 --> 00:08:24.500
and solve two main problems, of course.

00:08:24.590 --> 00:08:25.600
Data typing.

00:08:25.670 --> 00:08:28.340
You can have the basic
system types like string,

00:08:28.420 --> 00:08:33.150
integer, and so on and so forth,
and even customize types,

00:08:33.570 --> 00:08:39.370
which means in schema files you can
put in stricter permissible content,

00:08:39.390 --> 00:08:41.630
which can be validated.

00:08:41.730 --> 00:08:44.750
And it works very
naturally with namespace.

00:08:46.000 --> 00:08:47.700
So in the next slide,
I'm going to show you an

00:08:47.810 --> 00:08:52.350
example of a schema file that
constrains the same XML data.

00:08:52.600 --> 00:08:56.580
Despite slightly more verbose,
you will find it as intuitive.

00:08:58.730 --> 00:09:02.510
I highlighted using colors to show
you the sections I want to talk about.

00:09:02.510 --> 00:09:06.650
Red color is a prefix of a namespace.

00:09:06.770 --> 00:09:08.340
You can call the prefix anything.

00:09:08.420 --> 00:09:12.580
So in this case,
the prefix is linked to a namespace.

00:09:12.760 --> 00:09:16.540
Namespace has a one-to-one
relationship with the URI.

00:09:16.640 --> 00:09:22.930
In this case, our URI is an URL,
www.apple.com/publications.

00:09:23.050 --> 00:09:25.810
So the prefix which
I chose to use is Apple.

00:09:26.000 --> 00:09:28.880
If you focus on the gold color now,
these are just the elements.

00:09:28.990 --> 00:09:30.840
We've seen that before.

00:09:30.920 --> 00:09:33.900
Purchase order must have
two child in sequence,

00:09:34.020 --> 00:09:34.950
two children in sequence.

00:09:35.190 --> 00:09:37.190
The first child is comment.

00:09:37.270 --> 00:09:39.780
The second child is item.

00:09:40.590 --> 00:09:42.670
and the green colors are the data types.

00:09:42.910 --> 00:09:46.810
I've mentioned before,
string in this case is a basic data type.

00:09:46.940 --> 00:09:50.830
And it's great that, you know,
that W3C actually studied

00:09:50.990 --> 00:09:54.110
quite a lot of languages to
find some common system type,

00:09:54.160 --> 00:09:56.540
like string, integer, boolean.

00:09:56.620 --> 00:10:01.000
It's very similar to Java,
so it's very easy for us to use.

00:10:01.090 --> 00:10:03.850
And you can customize the type as well,
of course.

00:10:06.300 --> 00:10:08.250
So at this point,
I'd like to take a little pause,

00:10:08.440 --> 00:10:12.530
a little breather for me and for
some of you out there to remind

00:10:12.530 --> 00:10:14.130
ourselves what XML is not really.

00:10:15.760 --> 00:10:21.480
So a contract of structure
is just what it is.

00:10:21.730 --> 00:10:22.720
There's no semantics in it.

00:10:22.820 --> 00:10:24.410
It doesn't explain
what purchase order is.

00:10:24.690 --> 00:10:28.850
What that means is the producer
of the XML data has to talk to the

00:10:28.990 --> 00:10:34.390
consumer of the XML data to explain
to her what the XML elements are.

00:10:34.820 --> 00:10:40.900
What the producer of the XML data usually
does is put the semantic explanation

00:10:40.900 --> 00:10:43.900
in the DTD or in the schema file.

00:10:44.030 --> 00:10:46.690
So you still have to talk
to achieve interoperability.

00:10:46.790 --> 00:10:52.390
The second thing is that a piece of
XML data is just structured text data.

00:10:52.390 --> 00:10:56.470
You still have to find
domains for end users for it.

00:10:56.540 --> 00:10:59.440
Some of the users that we
have seen out there is storing

00:10:59.440 --> 00:11:01.420
XML configuration information.

00:11:01.420 --> 00:11:04.400
And to do that,
you have to find a way to store XML data.

00:11:04.420 --> 00:11:08.570
You do content publishing,
meaning you store XML, your data is XML,

00:11:08.920 --> 00:11:14.480
then you apply transformation to get WML,
HTML, or even binary formats like PDF.

00:11:14.480 --> 00:11:19.260
And of course, a lot of companies,
including Apple WebObjects,

00:11:19.260 --> 00:11:24.030
is leveraging XML to build web services,
whatever that means.

00:11:27.970 --> 00:11:33.060
So we move on to processing of XML data.

00:11:33.060 --> 00:11:37.260
This set of low-level APIs is
called Document Object Model.

00:11:37.330 --> 00:11:40.630
Document Object Model has been used,
again, in the SGML world and way

00:11:40.630 --> 00:11:43.440
back to model any documents,
not only XML.

00:11:43.440 --> 00:11:46.530
Those of you in the audience who
have worked with HTML browsers must

00:11:46.860 --> 00:11:48.640
have seen DOM models of HTML before.

00:11:49.280 --> 00:11:51.760
So it is a very general tree structure.

00:11:51.920 --> 00:11:54.360
And for me, at least,
and for some of you,

00:11:54.410 --> 00:11:56.420
most of you out there,
you probably use it

00:11:56.520 --> 00:11:58.640
for producing XML data,
serialize it out.

00:12:00.000 --> 00:12:05.180
It is less useful parsing because
it is pretty memory intensive.

00:12:05.250 --> 00:12:09.450
It builds the entire object tree
and let you manipulate from then.

00:12:09.600 --> 00:12:14.840
There's another low-level
API that allows you to do parsing,

00:12:15.010 --> 00:12:19.480
and most people like
this simple API for XML.

00:12:19.910 --> 00:12:23.130
It is faster than DOM because
it is very sequential.

00:12:23.250 --> 00:12:26.040
It starts at the very top,
look at the first element,

00:12:26.160 --> 00:12:30.670
and it generates standard callbacks that
you're supposed to implement and handle.

00:12:31.020 --> 00:12:34.160
It maintains very little
state information and hence

00:12:34.750 --> 00:12:38.320
extremely lightweight,
which is good for parsing.

00:12:42.060 --> 00:12:47.690
Jack Spie, this is neither sex nor DOM,
but it is an abstract layer that

00:12:47.690 --> 00:12:52.610
Sun provides for you to instantiate
parsers and transformers so that

00:12:52.610 --> 00:12:56.230
you can easily plug in transformers
and parsers from different vendors.

00:12:56.460 --> 00:12:59.330
I would advise you to start
using it if you have not.

00:12:59.460 --> 00:13:05.660
This will make your code more portable,
and you can choose parsers

00:13:05.660 --> 00:13:06.980
depending on their performance
and functionality and speed.

00:13:08.620 --> 00:13:12.540
So next slide will show you a list
of parsers that you can choose.

00:13:12.600 --> 00:13:15.840
And if you have JaxP,
you can plug and play.

00:13:15.890 --> 00:13:18.280
The Xerces parser, very popular.

00:13:18.440 --> 00:13:22.570
Sun's Crimson parser is
going to be included in 1.4.

00:13:23.020 --> 00:13:24.940
and I.B.M.

00:13:24.940 --> 00:13:26.050
have their own parser.

00:13:26.160 --> 00:13:28.600
And just to illustrate that, you know,
a lot of people write parsers as well,

00:13:28.600 --> 00:13:31.540
James Clark has a
pretty reputable parser,

00:13:31.540 --> 00:13:32.430
which I think is fast.

00:13:36.390 --> 00:13:42.380
Okay, I'm going to switch gear now and
talk about the integration of

00:13:42.420 --> 00:13:44.120
XML technology with WebObjects.

00:13:44.120 --> 00:13:46.770
I'm finished with the refresher
so the XML expert can wake up.

00:13:48.520 --> 00:13:52.910
So we're going to ship the
Xerces 2 parser and the Xilin

00:13:52.910 --> 00:13:55.300
2 transformer in the Java XML.

00:13:55.300 --> 00:13:59.200
Before, we used to, we planned, sorry,
I have to say this.

00:13:59.270 --> 00:14:02.910
We planned to ship Xerces 2 and Xilin 2.

00:14:03.030 --> 00:14:05.870
In the current WebObjects,
we only have the Xerces 1 parser,

00:14:05.870 --> 00:14:08.420
but we have noticed that our
developers started using the

00:14:08.440 --> 00:14:10.080
Xilin 2 transformer anyway.

00:14:10.080 --> 00:14:11.770
So we want to facilitate that.

00:14:11.880 --> 00:14:15.510
And synchronization of versions,
as some of you out there might know,

00:14:15.510 --> 00:14:16.690
is very important.

00:14:16.700 --> 00:14:17.750
So we keep them synchronized.

00:14:19.810 --> 00:14:22.520
That's support at the lower API level.

00:14:22.610 --> 00:14:27.310
At the slightly higher API level,
we have two serialization

00:14:27.310 --> 00:14:30.590
schemes for WebObjects.

00:14:30.710 --> 00:14:33.290
The first one,
as some of you may have used it,

00:14:33.300 --> 00:14:36.620
is OXML Coding Decoder,
and we plan to support a new one

00:14:37.330 --> 00:14:39.500
called NSXML Input and Output Stream.

00:14:39.700 --> 00:14:42.410
So let's talk about them.

00:14:43.640 --> 00:14:47.290
What is XML Coder and Decoder?

00:14:47.390 --> 00:14:52.200
We like to deprecate them,
following the philosophy of deprecating,

00:14:52.200 --> 00:14:56.280
of aligning our serialization
APIs with Java APIs.

00:14:56.580 --> 00:15:01.280
Now the analogy here is
NS coding versus serializable.

00:15:01.360 --> 00:15:04.150
We used to have NS coding,
which is a more objective C-way

00:15:04.270 --> 00:15:06.600
of doing binary serialization.

00:15:06.600 --> 00:15:12.070
We made the transition in
WebObjects 5 to serializable.

00:15:12.730 --> 00:15:17.450
So we'd like to follow that and
deprecate all XML coder and decoder.

00:15:17.630 --> 00:15:20.560
Following that deprecation,
we'll be saying goodbye

00:15:21.080 --> 00:15:23.260
to our mapping file,
the non-standard mapping file that

00:15:23.260 --> 00:15:28.400
we use for transforming XML data,
and say hello to XSLT.

00:15:28.680 --> 00:15:31.200
My colleague Mike Brumbelow,
he will talk more about

00:15:31.510 --> 00:15:33.140
XSLT transformation later on.

00:15:37.180 --> 00:15:39.930
Now,
XSLT is an industry standard that became

00:15:39.930 --> 00:15:43.330
a recommendation by W3C about a year ago,
I think.

00:15:43.340 --> 00:15:46.780
And it is good because
knowledge is very portable.

00:15:46.780 --> 00:15:51.410
Once you learn XSLT, you can use that
knowledge in Objective-C,

00:15:51.560 --> 00:15:55.040
in C++, or even in Microsoft,
different platforms.

00:15:55.130 --> 00:15:59.560
If you're already an XSLT expert,
you can apply the knowledge immediately.

00:16:03.450 --> 00:16:07.340
So the new XML serialization scheme,
for the most part,

00:16:07.340 --> 00:16:11.120
is going to be as easy as
the binary serialization,

00:16:11.480 --> 00:16:15.040
because it follows the basic
binary serialization rules.

00:16:15.040 --> 00:16:19.040
What that means is classes,
they already implement serializable.

00:16:19.040 --> 00:16:21.590
You get,
they become XML serializable for free.

00:16:23.450 --> 00:16:27.480
This is because the classes
that does the serialization,

00:16:27.490 --> 00:16:30.830
an XML input stream and output stream,
they are built on top of

00:16:30.830 --> 00:16:33.310
the respective I/O classes.

00:16:34.180 --> 00:16:37.030
Instead of instantiating
object output stream,

00:16:37.150 --> 00:16:40.670
you instantiate object
and XML output stream.

00:16:40.790 --> 00:16:46.380
You write out the object and vice
versa for NSXML input stream.

00:16:47.490 --> 00:16:50.430
So the WebObjects does the
heavy lifting of figuring out

00:16:50.530 --> 00:16:51.660
what should be serialized.

00:16:51.860 --> 00:16:55.240
And as I said, they follow the basic
serialization rules.

00:16:55.320 --> 00:16:59.070
What that means is non-transitive,
non-static data members

00:16:59.610 --> 00:17:00.900
become serializable.

00:17:01.000 --> 00:17:04.290
And if you want to be fancier,
you override the two methods,

00:17:04.290 --> 00:17:07.020
the write and read object,
to customize them.

00:17:07.020 --> 00:17:08.360
They will be called.

00:17:10.650 --> 00:17:14.190
And by aligning our APIs with
the Java industry standard,

00:17:14.190 --> 00:17:18.030
the serializable interface,
we make our APIs more available to

00:17:18.030 --> 00:17:22.290
Java developers who are learning
WebObjects and Java developers

00:17:22.300 --> 00:17:25.760
who are more familiar with
the serializable interface.

00:17:28.160 --> 00:17:33.990
So here is the default XML output
of a serialized object.

00:17:34.040 --> 00:17:36.420
I want you to focus in the middle part,
because the rest are

00:17:36.540 --> 00:17:38.080
just namespace and stuff.

00:17:38.210 --> 00:17:42.190
We have a serialized object,
and this first child

00:17:42.680 --> 00:17:46.160
is a class structure,
which most of us who are focusing on

00:17:46.160 --> 00:17:47.580
the content part of it can ignore.

00:17:47.590 --> 00:17:50.810
Those of you guys who want
to know the class structure,

00:17:50.810 --> 00:17:52.110
it is there for you.

00:17:52.570 --> 00:17:54.740
I'm going to skip to the content.

00:17:54.820 --> 00:18:00.060
It just says that this object
has a field called first name,

00:18:00.060 --> 00:18:04.640
and it is of data type string,
and the content is just Mike.

00:18:04.640 --> 00:18:06.640
Now, this, this is, this is, this is,
this

00:18:06.900 --> 00:18:11.240
This XML content is actually
deserializable to become a person object

00:18:11.680 --> 00:18:15.300
in memory if you use an XML input stream.

00:18:19.390 --> 00:18:25.020
So here is an example of how to
write out that particular object.

00:18:25.090 --> 00:18:27.480
You must have seen this before
if you have used serialization,

00:18:27.550 --> 00:18:30.960
binary serialization,
the last two lines at least.

00:18:31.030 --> 00:18:35.850
You instantiate an object,
an NSXML output stream.

00:18:35.910 --> 00:18:37.530
You write out the object,
and you close it.

00:18:37.810 --> 00:18:39.200
That's it.

00:18:40.020 --> 00:18:42.850
Now I want you to focus hard on the
next slide because it's going to be

00:18:42.850 --> 00:18:45.270
really complicated for reading it in.

00:18:48.200 --> 00:18:49.140
All right, that didn't go well.

00:18:49.140 --> 00:18:50.660
It went well during rehearsal.

00:18:50.660 --> 00:18:54.730
It's supposed to be a joke.

00:18:54.850 --> 00:19:00.480
So, again,
you instantiate an NSXML input stream.

00:19:00.570 --> 00:19:02.270
You read the object in, the XML data in.

00:19:02.420 --> 00:19:06.990
You pass it to your class,
and then you close it.

00:19:06.990 --> 00:19:08.000
That's it.

00:19:08.000 --> 00:19:08.820
Good.

00:19:08.820 --> 00:19:11.990
I'm doing pretty well on time.

00:19:12.040 --> 00:19:16.000
So I'm going to give you a demo now,
demo two.

00:19:16.000 --> 00:19:16.000
So

00:19:20.950 --> 00:19:26.320
On using the new serialization
scheme to do configuration.

00:19:26.370 --> 00:19:29.460
Now one word about storing
XML is configuration.

00:19:29.460 --> 00:19:32.990
Now as I said earlier on,
because the basic structure

00:19:33.090 --> 00:19:37.470
of XML is always the same,
so storing configuration data

00:19:37.470 --> 00:19:40.430
into XML is becoming more popular.

00:19:40.520 --> 00:19:43.760
You see it in Ant and almost everywhere,
in Tomcat.

00:19:43.760 --> 00:19:46.740
This is because people worry a lot
less about the extracting of it.

00:19:47.060 --> 00:19:49.480
They worry more about what
you're going to do with the data.

00:19:49.730 --> 00:19:52.790
Compare this with makefiles, where,
you know, a tab is actually a very

00:19:52.790 --> 00:19:53.920
important delimiter.

00:19:54.230 --> 00:19:56.460
You miss that tab,
your makefile won't compile.

00:19:56.460 --> 00:19:59.480
Or in the Apache configuration,
where the new line is an

00:19:59.480 --> 00:20:01.790
important delimiter as well.

00:20:01.910 --> 00:20:04.460
So here,
I'm going to make use of an example

00:20:04.460 --> 00:20:07.880
that was shipped with WebObjects 5,
so that you're familiar with it.

00:20:07.950 --> 00:20:09.160
It's create plot.

00:20:09.300 --> 00:20:12.290
Create plot is a very simple example
that shows you how to make use of

00:20:12.300 --> 00:20:14.890
the plotting APIs to create graphs.

00:20:14.960 --> 00:20:16.880
And there are three kind of graphs.

00:20:16.920 --> 00:20:19.260
One is based on floating point number.

00:20:19.260 --> 00:20:21.210
The other one is based on string.

00:20:21.210 --> 00:20:23.210
And the last one is based on date.

00:20:23.300 --> 00:20:27.030
We hard-coded the example when we
shipped it so that it always started

00:20:27.480 --> 00:20:29.690
with the floating point example.

00:20:30.800 --> 00:20:35.070
I've already run it,
and let me bring up Y.

00:20:39.280 --> 00:20:45.340
So this is the example that
started up when you first run it.

00:20:45.420 --> 00:20:48.440
And it just plots a
graph of floating point.

00:20:48.440 --> 00:20:53.900
And you can illustrate there are
three kind of graphs-- floating point,

00:20:53.990 --> 00:20:55.930
date, and string.

00:20:56.260 --> 00:20:59.530
So when the application started up,
it writes out a configuration file,

00:20:59.530 --> 00:21:01.380
which I'm going to show you.

00:21:03.770 --> 00:21:05.360
This is the XML configuration file.

00:21:05.360 --> 00:21:08.660
It is similar to the XML data
that we saw earlier on.

00:21:08.740 --> 00:21:10.710
And I added a comment.

00:21:10.710 --> 00:21:12.030
I'll show you how to do it later on.

00:21:12.170 --> 00:21:16.980
It says, "Change its value to configure
the starting plot." I'm

00:21:17.070 --> 00:21:23.060
going to change it to object.

00:21:23.170 --> 00:21:27.100
Save it.

00:21:27.210 --> 00:21:28.970
Create a new session.

00:21:34.870 --> 00:21:36.800
So a new session comes in.

00:21:36.820 --> 00:21:37.560
And there you go.

00:21:37.560 --> 00:21:41.100
It is a new CACIA object.

00:21:41.110 --> 00:21:43.240
It is an object based on string.

00:21:43.250 --> 00:21:46.960
And let me change it again back to date.

00:21:47.040 --> 00:21:52.780
I have a new application.

00:21:58.320 --> 00:22:00.610
So we have a new plot based on date.

00:22:00.730 --> 00:22:03.410
So imagine an administrator who
is just concerned about changing

00:22:03.410 --> 00:22:06.890
the configuration file and doesn't
care about WebObjects application.

00:22:07.000 --> 00:22:10.860
She can go in and change the XML file,
and the next time the session comes in,

00:22:10.860 --> 00:22:12.100
you have a new plot.

00:22:12.220 --> 00:22:17.520
So now I'm going to go to the code
and walk you through it briefly.

00:22:18.980 --> 00:22:24.070
I created a class called StudConfig
and I made it serializable.

00:22:24.840 --> 00:22:28.520
And I'm following the
rules of serialization,

00:22:28.520 --> 00:22:30.400
binary serialization.

00:22:30.470 --> 00:22:35.000
I created a variable, instance,
a member variable called starting plot.

00:22:36.070 --> 00:22:38.400
Make sure it's non-transitive
and non-static.

00:22:38.520 --> 00:22:41.560
And because I added-- I wanted to
customize it by adding a comment,

00:22:41.660 --> 00:22:44.560
if you do want to add a comment,
you don't have to customize--

00:22:44.830 --> 00:22:47.510
override the WriteObject method.

00:22:48.810 --> 00:22:54.000
I have a couple of utility
methods to help me create it.

00:22:54.160 --> 00:22:58.300
Those are,
these are the stuff you saw earlier on.

00:22:58.410 --> 00:23:00.300
Write an object and close it.

00:23:00.400 --> 00:23:05.940
And this is the creation of the class.

00:23:05.940 --> 00:23:08.600
And here, what I did was, I

00:23:21.700 --> 00:23:24.490
I customize it so that
the session itself,

00:23:24.490 --> 00:23:28.900
on a per session basis,
you can put this method in application

00:23:28.900 --> 00:23:30.130
and it becomes application-wide.

00:23:30.220 --> 00:23:35.400
And last, in the main.

00:23:35.400 --> 00:23:41.140
So instead of hard coding it in main,
I now get it from the session.

00:23:45.090 --> 00:23:46.000
That's it.

00:23:46.080 --> 00:23:47.440
So with that, I'm going to bring up Mike.

00:23:47.440 --> 00:23:50.400
He's going to talk about
serialization of EOs using the

00:23:50.400 --> 00:23:52.300
new XML serialization scheme.

00:23:52.300 --> 00:23:55.020
And he's going to talk about
transformation as well,

00:23:55.020 --> 00:23:56.790
XSLT, one of my favorite topics.

00:23:56.850 --> 00:23:57.800
Mike, please.

00:23:58.140 --> 00:23:58.850
Thank you.

00:24:08.150 --> 00:24:09.450
Hopefully this isn't the demon clicker.

00:24:09.500 --> 00:24:17.350
Hi, my name is Mike Brumbelow,
and today I'll be talking about

00:24:17.430 --> 00:24:19.870
EOXML serialization and XSLT.

00:24:24.650 --> 00:24:28.800
The good news about EO XML serialization
is that it's easy as pie.

00:24:28.800 --> 00:24:34.020
You give us a collection of EOs,
and we go through,

00:24:34.020 --> 00:24:38.400
and using NSXML output stream,
we serialize it out for you.

00:24:38.400 --> 00:24:42.930
And using NSXML input stream,
we read that back in for you.

00:24:42.940 --> 00:24:46.890
Now,
concerning managing your object graph,

00:24:46.890 --> 00:24:51.560
the good thing is that as a part
of the serialization process,

00:24:51.560 --> 00:24:53.410
we don't fire off any faults.

00:24:53.420 --> 00:24:56.790
So the objects you give us are
the objects you serialize out.

00:24:56.820 --> 00:24:58.490
We don't fault any objects in.

00:25:05.320 --> 00:25:06.500
Let me demo this for you here.

00:25:06.530 --> 00:25:16.100
I wrote an application
that takes an RSS document.

00:25:16.100 --> 00:25:18.470
An RSS stands for RDF Site Summary.

00:25:18.600 --> 00:25:22.380
An RDF stands for
Resource Description Framework.

00:25:22.420 --> 00:25:25.980
It's a way of describing
content information for a site.

00:25:25.980 --> 00:25:30.470
And a lot of news sites vend this
kind of document out to the public,

00:25:30.600 --> 00:25:33.050
and you can use it to
read news and information.

00:25:33.080 --> 00:25:36.400
And I wrote an application that goes out,
pulls out this document,

00:25:36.400 --> 00:25:38.140
and we'll display it on the screen here.

00:25:38.140 --> 00:25:40.390
Where are you at?

00:25:40.410 --> 00:25:42.240
There you go.

00:25:42.270 --> 00:25:44.210
Now I'm going to launch it.

00:25:58.960 --> 00:26:03.780
Okay,
I'm going to select a site to look at.

00:26:03.840 --> 00:26:06.280
I'm going out and
fetching the RSS document,

00:26:06.280 --> 00:26:07.940
and it's an XML document.

00:26:08.020 --> 00:26:09.900
Going through and
displaying all the links,

00:26:09.900 --> 00:26:13.560
information associated with that site,
the different news today.

00:26:13.860 --> 00:26:16.300
Let's see, is there anything here for us?

00:26:16.620 --> 00:26:17.430
No?

00:26:17.530 --> 00:26:18.540
Okay.

00:26:18.690 --> 00:26:19.840
Let's go to Wired.

00:26:19.840 --> 00:26:22.460
Is there anything here concerning us?

00:26:22.500 --> 00:26:24.240
Any news?

00:26:25.320 --> 00:26:26.290
The last one, where's that at?

00:26:26.350 --> 00:26:29.270
Hmm, let's look at that.

00:26:32.500 --> 00:26:33.700
Interesting.

00:26:33.790 --> 00:26:36.640
So, you know, we can navigate and look at
the different news articles and

00:26:36.640 --> 00:26:37.600
everything underneath there.

00:26:37.600 --> 00:26:40.040
So let's go back to cnetnews.com.

00:26:40.040 --> 00:26:43.700
Now, when I press this button
at the bottom here,

00:26:43.700 --> 00:26:46.620
Save Articles, that's going to go out.

00:26:46.640 --> 00:26:49.640
It's going to fetch
that XML RSS document.

00:26:49.640 --> 00:26:52.720
It's then going to save
it out to the database,

00:26:52.720 --> 00:26:55.290
and then from there,
it'll convert it into EOs and

00:26:55.290 --> 00:26:56.320
save it out to the database.

00:26:56.320 --> 00:26:59.020
And then from there,
we're going to then serialize

00:26:59.020 --> 00:27:00.900
those EOs out to the file system.

00:27:05.800 --> 00:27:08.140
magically it happens.

00:27:08.240 --> 00:27:12.070
So let's go look at the document
that gets generated here.

00:27:15.890 --> 00:27:17.950
As you can see, wow,
there's a lot of stuff there.

00:27:17.950 --> 00:27:21.670
Really, no data is serialized out.

00:27:21.920 --> 00:27:24.100
Basically, references to our data.

00:27:24.100 --> 00:27:28.790
And you can see in here, for instance,
we've actually serialized out,

00:27:28.790 --> 00:27:32.640
let me highlight that for you,
the editing context and some

00:27:32.640 --> 00:27:34.230
of the other EOs as well.

00:27:34.430 --> 00:27:36.790
It's a nice little long document.

00:27:38.710 --> 00:27:39.150
Close that out.

00:27:39.150 --> 00:27:44.000
Now the next thing I'm going to
do is navigate to the next page.

00:27:44.000 --> 00:27:48.710
From here, we're going to deserialize and
bring all of those EOs back into the

00:27:48.710 --> 00:27:51.200
application and display the links again.

00:27:51.200 --> 00:27:53.920
It's just that fast.

00:27:53.920 --> 00:27:57.320
We'll click on an item.

00:27:57.320 --> 00:28:00.140
Voila.

00:28:04.560 --> 00:28:11.660
And let's look a little bit of
code here to see how simple it was.

00:28:11.780 --> 00:28:15.520
For serializing out,
you pass us your objects,

00:28:15.720 --> 00:28:19.490
and then from there we go through and
we get a hold of an NSXML output stream.

00:28:19.770 --> 00:28:22.840
We format it,
and then from there we write out,

00:28:22.890 --> 00:28:25.300
and then from there flush
and close the buffer,

00:28:25.360 --> 00:28:26.220
and we're all set to go.

00:28:26.350 --> 00:28:27.840
Of course, you know,
there's some error handling there.

00:28:27.920 --> 00:28:30.980
That's a positive thing.

00:28:31.790 --> 00:28:34.460
Then to deserialize
and bring back the EO,

00:28:34.460 --> 00:28:37.700
you just go out and get
a hold of your stream.

00:28:37.700 --> 00:28:40.720
Then from there,
create an NSXML input stream,

00:28:40.790 --> 00:28:43.560
read it back in,
and you're all set to go.

00:28:43.560 --> 00:28:48.010
So it's easy as pie, very simple,
straightforward, to the point.

00:28:48.020 --> 00:28:53.700
Back to slides.

00:28:57.950 --> 00:29:00.400
Next, I want to talk to you about XSL.

00:29:00.400 --> 00:29:05.060
XSL stands for Extensible
Style Sheet Language.

00:29:05.060 --> 00:29:08.800
It has two rule-based vocabularies,
that being XSLT,

00:29:08.840 --> 00:29:12.010
or Extensible Style Sheet
Language Transformation,

00:29:12.040 --> 00:29:14.820
and the other one, XSLFO.

00:29:14.820 --> 00:29:17.360
That stands for Formatting Objects.

00:29:17.610 --> 00:29:21.040
Both of these vocabularies
transform source XML documents,

00:29:21.060 --> 00:29:24.860
and both specify the
formatting of XML documents.

00:29:25.340 --> 00:29:28.410
Now,
formatting objects is an XML vocabulary

00:29:28.520 --> 00:29:33.560
that defines page layout,
pagination, the placement of images,

00:29:33.560 --> 00:29:38.100
text, that kind of thing, on a document,
and then from there,

00:29:38.100 --> 00:29:41.390
it's converted to a binary format,
like PDF and Word.

00:29:41.400 --> 00:29:46.940
And you can also maybe generate an
SGV file or any kind of binary output

00:29:46.940 --> 00:29:50.140
that you want based on these objects.

00:29:50.200 --> 00:29:55.160
And a really good place to go to
get information concerning FO,

00:29:55.340 --> 00:29:58.020
XSLFO, is the Apache site.

00:29:58.020 --> 00:30:02.790
They have a formatting objects parser
out there that you can download and

00:30:02.880 --> 00:30:04.290
use as a part of your application.

00:30:04.300 --> 00:30:06.490
It's very simple, straightforward,
and to the point.

00:30:06.500 --> 00:30:10.210
But what we really want to focus on...

00:30:11.710 --> 00:30:15.520
is XSLT,
which is the rules document of XSL.

00:30:15.530 --> 00:30:20.170
It enables us to extract data from
a source XML document and then

00:30:20.170 --> 00:30:25.950
transform it into whatever format,
XML, text, HTML that we want to.

00:30:26.280 --> 00:30:30.110
Now,
the XSLT vocabulary has many constructs,

00:30:30.280 --> 00:30:35.030
and the main one is the
template matching functionality.

00:30:35.030 --> 00:30:37.820
And that enables you to
look in your XML document,

00:30:37.870 --> 00:30:41.700
identify an element, tag,
and then from there, work on that tag,

00:30:41.700 --> 00:30:45.020
the data that's inside of it as well,
the content.

00:30:45.020 --> 00:30:49.120
It also has copying,
control structures such as if-then-else,

00:30:49.120 --> 00:30:50.740
if-then-else-choose.

00:30:50.740 --> 00:30:54.260
It also has iteration,
the ability to loop through.

00:30:54.260 --> 00:30:56.020
And it also gives you
the ability to mainstay.

00:30:56.280 --> 00:30:58.670
It also gives you the ability to
maintain state by defining variables.

00:30:58.700 --> 00:31:02.590
Using XPath,
which is an expression matching

00:31:02.690 --> 00:31:07.420
functionality as a part of XSLT,
you're able to find data

00:31:07.420 --> 00:31:11.260
and then from there,
work upon that data.

00:31:11.260 --> 00:31:14.060
And we'll kind of touch upon
that in a small example coming

00:31:14.060 --> 00:31:15.460
up here in a few moments.

00:31:18.370 --> 00:31:22.220
Now,
the components that make up XSLT are the

00:31:22.220 --> 00:31:28.910
source valid XSL transformation document,
the XALAN XSL transformation

00:31:28.990 --> 00:31:33.460
parser or processor,
and a valid source XML document.

00:31:33.460 --> 00:31:38.380
And those three components work together
to generate an output XML document.

00:31:38.920 --> 00:31:42.100
So you're basically going and
you're converting an XML document

00:31:42.100 --> 00:31:44.900
to another XML document,
or maybe converting an

00:31:45.140 --> 00:31:48.610
XML document to an HTML document,
XHTML document,

00:31:48.720 --> 00:31:51.270
or even a text-formatted document.

00:31:54.540 --> 00:31:57.500
Now here are some examples of
the components that make up

00:31:57.560 --> 00:31:58.880
the transformation process.

00:31:58.880 --> 00:32:05.000
At the top, we have foo.xml,
and this is a basic input document,

00:32:05.000 --> 00:32:06.260
very simple, straightforward.

00:32:06.260 --> 00:32:08.000
It's kind of like a
Hello World kind of document.

00:32:08.000 --> 00:32:11.150
In the middle,
there's our XSLT style sheet,

00:32:11.160 --> 00:32:15.320
and you can see there that
there's a template element,

00:32:15.320 --> 00:32:22.310
and that's used to find the tag
or the element and work upon it.

00:32:22.770 --> 00:32:27.000
You see that one of the
attributes is the name match,

00:32:27.000 --> 00:32:29.370
and that tells you what
the name of the element is.

00:32:29.420 --> 00:32:34.260
And as a part of that,
there's also the value of element,

00:32:34.260 --> 00:32:36.640
and that enables you to find
the content inside of there.

00:32:36.670 --> 00:32:39.160
And at the bottom,
there's the output that gets

00:32:39.160 --> 00:32:40.620
generated based on that.

00:32:44.490 --> 00:32:50.130
Now, some of the uses of XSLT are
transforming XML to HTML,

00:32:50.130 --> 00:32:54.880
XHTML, WML,
and you can also take a FO document,

00:32:54.880 --> 00:32:58.930
put it through your XSLT processor,
and then from there

00:32:58.930 --> 00:33:00.190
generate a PDF document.

00:33:00.200 --> 00:33:04.810
There's any number of different text
transformations that you can do as well.

00:33:08.980 --> 00:33:18.580
Now, some of the two key processors in
XSLT are Apache Xalan and Saxon,

00:33:18.580 --> 00:33:20.140
which is located at SourceForge.

00:33:20.160 --> 00:33:24.230
And here are some of the URLs that
you can go to to get more information.

00:33:27.610 --> 00:33:29.940
Give you a moment to jot those down.

00:33:30.060 --> 00:33:30.890
Now let's look at the demo.

00:33:30.890 --> 00:33:34.680
And as a part of this demo,
what I'm going to do is I'm going to

00:33:34.790 --> 00:33:42.260
take an XML document and convert it into
an HTML document to show you how simple

00:33:42.260 --> 00:33:47.780
and easy it is to do transformations
in WebObjects using our parser.

00:33:51.790 --> 00:33:54.000
Okay,
so we bring up the application here,

00:33:54.000 --> 00:33:55.560
and let's fire it up.

00:34:09.000 --> 00:34:10.340
Okay.

00:34:10.340 --> 00:34:14.190
So the first thing I'm going to do is I'm
going to load in an XML document called

00:34:16.790 --> 00:34:20.400
And then I'm going to
take an XSLT style sheet,

00:34:20.510 --> 00:34:24.520
load that in,
and I'm going to enter the name

00:34:24.580 --> 00:34:26.030
of our destination document.

00:34:26.040 --> 00:34:35.120
And by pressing this button,
I'm going to do the transformation.

00:34:44.030 --> 00:34:46.610
and magically there it appears.

00:34:46.660 --> 00:34:50.080
Let's look at this real quickly,
the document that we just generated.

00:34:50.170 --> 00:34:54.770
It's just straight HTML, very simple,
straightforward and to the point.

00:34:54.770 --> 00:34:58.010
And if we look at the style sheet,

00:34:59.560 --> 00:35:03.130
A very basic style sheet that
enables you to go through and

00:35:03.130 --> 00:35:05.600
transform the source XML document.

00:35:05.640 --> 00:35:07.360
And you can see the template here.

00:35:07.500 --> 00:35:10.070
And it's looking for the tag product.

00:35:10.170 --> 00:35:12.530
And based on that,
it's going to pull out the data

00:35:12.530 --> 00:35:14.110
where you see the description in.

00:35:14.120 --> 00:35:19.690
I'm sorry?

00:35:20.240 --> 00:35:20.290
We're not as close to your

00:35:22.700 --> 00:35:35.900
[Transcript missing]

00:35:37.090 --> 00:35:39.460
So there's the XML document
that we transformed.

00:35:39.460 --> 00:35:42.610
And let's go back again,
give you a better look

00:35:42.680 --> 00:35:43.380
at the other document.

00:35:49.610 --> 00:35:49.900
How's that?

00:35:49.900 --> 00:35:52.340
Thank you.

00:35:52.380 --> 00:35:59.720
So there we're doing transformations
from an XML document to XSLT.

00:35:59.720 --> 00:36:02.670
Now the next thing we're going to do,
and this is kind of a

00:36:02.670 --> 00:36:06.530
little bit unplanned here,
is we're going to go ahead

00:36:06.930 --> 00:36:07.800
and we're going to take...

00:36:08.700 --> 00:36:24.500
[Transcript missing]

00:36:27.400 --> 00:36:41.400
[Transcript missing]

00:36:43.200 --> 00:36:43.560
Okay.

00:36:43.560 --> 00:36:45.620
What's your favorite card game?

00:36:45.620 --> 00:36:47.520
Solitaire.

00:36:47.520 --> 00:36:48.210
Solitaire.

00:36:48.340 --> 00:36:49.040
Excellent.

00:36:49.040 --> 00:36:53.630
I prefer Magic, but...

00:36:56.050 --> 00:36:57.110
Okay, let's hope that works.

00:36:57.250 --> 00:36:57.540
Okay.

00:36:57.540 --> 00:37:00.780
So now by pressing this button,
I'm going to go through

00:37:00.780 --> 00:37:03.080
and do the transformation,
and I'm going to write it

00:37:03.080 --> 00:37:04.780
out here to the console.

00:37:04.780 --> 00:37:08.490
So let me just clear the console there,
so keep me honest.

00:37:08.490 --> 00:37:10.480
Press the submit button.

00:37:13.000 --> 00:37:13.900
And magically, there you are.

00:37:13.900 --> 00:37:18.600
We've taken an XML document-- I'm sorry,
we've taken a NSDictionary,

00:37:18.600 --> 00:37:21.860
and we've converted it into an
XML representation of a plist.

00:37:22.030 --> 00:37:24.670
So let's look at some code real quick.

00:37:27.070 --> 00:37:32.080
This is the serialization portion for
taking an NSDictionary and converting

00:37:32.080 --> 00:37:36.300
it to an XML representation of a plist.

00:37:36.840 --> 00:37:39.280
Pretty straightforward to the point.

00:37:41.340 --> 00:37:44.650
And we want to kind of focus
on this line of code here.

00:37:44.700 --> 00:37:46.800
Let me get to it right now.

00:37:46.890 --> 00:37:50.350
He's the guy that does the
quote unquote "heavy lifting."

00:37:51.090 --> 00:37:54.800
And to do the XSLT transformations
that we saw previously,

00:37:54.970 --> 00:37:57.260
there's a code there.

00:37:57.700 --> 00:37:59.220
Pretty straightforward to the point.

00:38:02.000 --> 00:38:03.100
And that's it.

00:38:03.210 --> 00:38:08.600
So pretty much it's very simple,
very little code that enables

00:38:08.600 --> 00:38:12.650
you to do transformations
inside of WebObjects using XSLT.

00:38:12.770 --> 00:38:17.820
And with that,
I'm going to call up Bob Frank so that

00:38:17.820 --> 00:38:21.600
he can demo XMLRPC and WoXMLCoder.

00:38:21.600 --> 00:38:21.610
Bob?

00:38:29.960 --> 00:38:30.650
Thank you, Mike.

00:38:30.910 --> 00:38:31.200
Very good.

00:38:31.260 --> 00:38:37.250
WoXML node and XML RPC.

00:38:37.850 --> 00:38:39.120
What is WoXML Node?

00:38:39.130 --> 00:38:41.280
WoXML Node,
if you're not familiar with it,

00:38:41.330 --> 00:38:47.040
is a graphical way that you can use
WoBuilder to create XML documents.

00:38:47.040 --> 00:38:52.240
It allows you to use all of the dynamic
elements that you're familiar with for

00:38:52.240 --> 00:38:55.110
building WebObjects HTML documents.

00:38:55.140 --> 00:38:57.130
You can use WoConditional,
you can use WoSwitch,

00:38:57.130 --> 00:38:59.070
you can use repetitions, etc., and so on.

00:38:59.100 --> 00:39:02.690
And instead of producing
a pure HTML document,

00:39:02.700 --> 00:39:05.330
it will produce an XML document.

00:39:06.720 --> 00:39:10.000
It has a very tight integration
with WebObjects Builder.

00:39:10.000 --> 00:39:11.050
You can drag and drop.

00:39:11.350 --> 00:39:15.660
You can drag relationships from EOs,
from objects that are in the

00:39:15.660 --> 00:39:19.800
bottom part of WebObjects Builder,
and use them to populate your

00:39:19.850 --> 00:39:21.450
values for your WoXML nodes.

00:39:21.500 --> 00:39:25.280
And the document format is
under your precise control.

00:39:25.280 --> 00:39:32.960
From a verboseness perspective,
compared to some of the automatic tools

00:39:33.020 --> 00:39:38.210
that you get to do the heavy lifting,
like NSXML, Object Input Stream,

00:39:38.380 --> 00:39:42.050
and Output Stream,
it's probably going to give you a more

00:39:42.050 --> 00:39:46.980
compact representation when you build
it yourself and you specifically specify

00:39:46.980 --> 00:39:50.050
what you want the document to look like.

00:39:50.220 --> 00:39:52.650
On the other hand,
when you use the automatic tools

00:39:52.730 --> 00:39:55.700
that you get with Object Input
Stream and Output Stream,

00:39:55.700 --> 00:40:00.030
they have a bunch of other automated
facilities that allow you to serialize,

00:40:00.030 --> 00:40:02.390
for example,
an EO and serialize it back in

00:40:02.520 --> 00:40:04.190
in another application easily.

00:40:04.560 --> 00:40:08.860
When you do use WoXML node, though,
one thing that you need to

00:40:08.860 --> 00:40:11.960
do in your component that's
generating your XML document,

00:40:11.960 --> 00:40:16.590
your page, is you need to set the header,
the response.setHeader,

00:40:16.600 --> 00:40:19.230
to text XML as your content type.

00:40:19.430 --> 00:40:21.300
What this does,
and I'll show it to you in the demo,

00:40:21.300 --> 00:40:26.260
it tells the browser to realize,
or whoever's receiving it,

00:40:26.430 --> 00:40:27.480
that this is an XML document.

00:40:27.500 --> 00:40:32.060
IE happens to be very intelligent when
it comes to receiving XML documents,

00:40:32.270 --> 00:40:34.190
and they have a little
XML browser built in.

00:40:36.320 --> 00:40:40.460
You're all familiar with the
typical WoW HTTP application.

00:40:40.470 --> 00:40:43.000
Well, okay, so maybe this isn't quite
a typical application.

00:40:43.000 --> 00:40:45.250
This is a fairly complex application.

00:40:45.250 --> 00:40:47.290
You have the browsers
communicating via HTTP,

00:40:47.290 --> 00:40:49.680
going through the firewall,
hitting the web servers,

00:40:49.690 --> 00:40:52.200
sending all sorts of messages
all over the place to a variety

00:40:52.290 --> 00:40:53.700
of application instances.

00:40:53.700 --> 00:40:55.800
Well, it's a very nice application.

00:40:57.470 --> 00:41:03.800
What XMLRPC does,
it is a method that allows

00:41:04.360 --> 00:41:09.690
servers to communicate directly
to each other over HTTP,

00:41:09.760 --> 00:41:15.820
typically, and it allows you to execute
remote procedure calls.

00:41:15.820 --> 00:41:16.100
So,

00:41:16.550 --> 00:41:22.570
What you'll see is a simple communication
between servers to allow them to

00:41:22.570 --> 00:41:27.870
generate requests on another machine,
perhaps running WebObjects, perhaps not,

00:41:27.920 --> 00:41:32.920
and send a request and get
back a response or a fault.

00:41:32.960 --> 00:41:34.970
A fault is like an exception or an error.

00:41:36.710 --> 00:41:39.210
What is XMLRPC and SOAP?

00:41:39.460 --> 00:41:43.660
They're both technologies that
are used in the coming popular

00:41:43.660 --> 00:41:45.450
buzzword of web services.

00:41:45.460 --> 00:41:50.240
We have an entire session, session 705,
devoted exclusively to web services,

00:41:50.240 --> 00:41:53.400
focusing primarily on the SOAP aspect,
so I'm not going to

00:41:53.400 --> 00:41:54.870
touch very much on SOAP.

00:41:54.920 --> 00:42:00.490
XMLRPC is an earlier and a much more
simple approach to web services.

00:42:00.490 --> 00:42:04.580
It's a parameter marshalling
mechanism that focuses very much

00:42:04.760 --> 00:42:06.680
on the metaphor of a remote.

00:42:06.680 --> 00:42:10.370
SOAP stands for
Simple Object Access Protocol.

00:42:10.370 --> 00:42:14.190
It's much more robust,
and it has a lot more buzzword

00:42:14.190 --> 00:42:17.860
momentum going for it,
with a lot of large players

00:42:17.860 --> 00:42:20.520
in the web services industry.

00:42:20.520 --> 00:42:25.590
It has much more typing specifications,
as Han-Min pointed out earlier,

00:42:25.950 --> 00:42:28.970
regarding namespacing
for schema documents,

00:42:28.970 --> 00:42:32.770
and therefore it is typically
more compact for certain

00:42:32.770 --> 00:42:35.000
types of representations.

00:42:35.000 --> 00:42:40.890
And, once again... C705 for more than
you ever wanted to know about web

00:42:40.960 --> 00:42:43.690
services and the SOAP aspects of it.

00:42:43.790 --> 00:42:46.690
One other comment about SOAP,
it's a W3C note.

00:42:46.730 --> 00:42:48.660
XML RPC is not.

00:42:49.060 --> 00:42:54.190
But both are focusing on remote
communication between servers so

00:42:54.190 --> 00:42:57.080
that you don't need to do something,
for example, like screen scraping.

00:42:57.080 --> 00:43:00.380
If you wanted to get data
from a remote server,

00:43:00.380 --> 00:43:05.290
typically many people have implemented
a variety of screen scraping

00:43:05.290 --> 00:43:09.020
mechanisms in order to get data,
whether data stock data, et cetera,

00:43:09.020 --> 00:43:09.520
et cetera.

00:43:09.920 --> 00:43:12.780
Now, with web services becoming
more and more popular,

00:43:12.780 --> 00:43:14.340
none of that's necessary.

00:43:14.340 --> 00:43:18.360
And when neither of these
protocols focus on remote object

00:43:18.660 --> 00:43:23.270
activation or garbage collection,
those are implementation details

00:43:23.270 --> 00:43:27.820
of the implementation on either
side of the communications channel.

00:43:29.940 --> 00:43:31.280
XML RPC.

00:43:31.280 --> 00:43:33.710
What do I mean when
I say strict RPC concept?

00:43:33.710 --> 00:43:37.520
It means that you have a method
or a function name on the remote

00:43:37.520 --> 00:43:39.180
server that you wish to execute.

00:43:39.180 --> 00:43:42.850
And you're going to send
an XML-based request.

00:43:42.850 --> 00:43:46.790
Your document is going to be a request,
please execute this method for me,

00:43:46.800 --> 00:43:48.380
and give me back a response.

00:43:48.450 --> 00:43:51.350
Very much just like traditional
functional programming.

00:43:52.940 --> 00:43:58.640
All requests in the XML document are
falling under a method call XML tag.

00:43:58.640 --> 00:44:00.140
I'll show you the document
structure in a second.

00:44:00.140 --> 00:44:05.520
All responses are wrapped in a
method response document tag.

00:44:05.560 --> 00:44:09.720
XML RPC uses faults to
represent error conditions.

00:44:09.730 --> 00:44:14.150
And in Java, it is handled very
similar to an exception,

00:44:14.150 --> 00:44:19.660
but in most XML RPC representations
and what most error codes mean,

00:44:19.660 --> 00:44:22.920
they are typically less
severe than the error codes.

00:44:22.940 --> 00:44:26.210
an exception in Java.

00:44:28.520 --> 00:44:33.890
To build up a method call,
you specify the method name that you

00:44:33.890 --> 00:44:35.900
want to execute on the remote server.

00:44:35.900 --> 00:44:40.610
And as you build that up,
you add the parameters that

00:44:40.610 --> 00:44:43.320
you want to pass along to it.

00:44:43.610 --> 00:44:48.670
And those are passed to the document,
depending on the library

00:44:48.670 --> 00:44:50.520
that you're using.

00:44:50.520 --> 00:44:54.230
In my demo,
you'll see an implementation wrapping,

00:44:54.230 --> 00:44:56.480
the Apache XMLRPC jar files.

00:44:56.940 --> 00:44:59.940
And they take a vector of your arguments.

00:44:59.940 --> 00:45:04.690
I've written a simple wrapper
that maintains the array for you.

00:45:04.700 --> 00:45:09.180
And you don't need to necessarily
build an independent vector or

00:45:09.180 --> 00:45:12.690
an array and pad all of it with
the parameters that you want.

00:45:16.170 --> 00:45:21.210
XMLRPC supports a very simple
set of base primitive types,

00:45:21.210 --> 00:45:25.370
boolean, double, date time, integers,
strings.

00:45:25.380 --> 00:45:31.420
They are typically getting more
and more support from underlying

00:45:31.530 --> 00:45:33.960
XMLRPC parsers to support Unicode.

00:45:34.430 --> 00:45:40.460
Originally, the XMLRPC specification,
I believe, specified only ASCII,

00:45:40.460 --> 00:45:45.450
but due to the fact that more and
more XML parsers support Unicode,

00:45:45.450 --> 00:45:46.820
you get that for free nowadays.

00:45:51.040 --> 00:45:54.210
Additional types for
encoding binary data,

00:45:54.390 --> 00:45:58.970
it specifies a base64 encoding,
which transforms binary data

00:45:59.310 --> 00:46:01.260
into a character representation.

00:46:01.260 --> 00:46:06.000
Additionally, it has data structures
to contain complex data,

00:46:06.000 --> 00:46:11.030
arrays-- I think everyone understands
the concept of arrays-- and structs,

00:46:11.250 --> 00:46:13.700
which is their representation
of a dictionary.

00:46:13.700 --> 00:46:18.200
Names are strings used for keys,
and values may be of any type.

00:46:18.200 --> 00:46:20.780
Obviously, it's unordered.

00:46:24.470 --> 00:46:28.160
The values in the XML document
are exactly as I specified

00:46:28.160 --> 00:46:30.230
them in the previous slide.

00:46:30.240 --> 00:46:34.290
An int is an int tag,
and the content goes inside the tag.

00:46:34.600 --> 00:46:38.200
Boolean is a Boolean specified by 0 or 1.

00:46:38.200 --> 00:46:40.680
String is a string, any content.

00:46:40.700 --> 00:46:46.220
Double is a double,
and datetime follows this ISO format.

00:46:46.840 --> 00:46:51.340
And in the XML RPC jar file
from the Apache jar file,

00:46:51.340 --> 00:46:54.990
it has a convenience formatter
that takes a Java date and

00:46:55.240 --> 00:46:56.700
formats it in this format.

00:46:56.700 --> 00:46:59.620
All values, oh, and base64.

00:46:59.620 --> 00:47:03.470
All values are wrapped with a value tag.

00:47:03.480 --> 00:47:06.040
For example, if you have a string,
hello world,

00:47:06.040 --> 00:47:09.800
everybody's first program string,
it's wrapped with the value tag.

00:47:13.620 --> 00:47:15.090
An array looks like this.

00:47:15.210 --> 00:47:18.250
You have an array and
it contains its data,

00:47:18.300 --> 00:47:20.590
and the data contains an
ordered set of values.

00:47:20.710 --> 00:47:25.430
So this value is serialized into the
XML document and un-serialized in this

00:47:25.430 --> 00:47:28.920
order from the client to the server.

00:47:32.570 --> 00:47:37.150
And the dictionary, each member of the
dictionary is a member tag.

00:47:37.160 --> 00:47:40.030
That specifies a name-value pair.

00:47:40.030 --> 00:47:43.990
Your key are your names and
your values are your ints.

00:47:43.990 --> 00:47:47.160
And you see in a name,
it doesn't specify a string.

00:47:47.160 --> 00:47:50.580
In XMLRPC,
if you do not specify any data type,

00:47:50.580 --> 00:47:54.540
all data types are implicitly
assumed to be string.

00:47:54.540 --> 00:47:57.560
But it's best, just like in Java,
to specify your types,

00:47:57.580 --> 00:48:00.620
it's always best to specify
exactly what type you have.

00:48:00.660 --> 00:48:05.440
This is the whole tamale of what
an XMLRPC request looks like.

00:48:05.500 --> 00:48:11.460
You have a standard HTTP header
specifying where it's going and what

00:48:11.460 --> 00:48:13.360
the path to the method on the server is.

00:48:13.830 --> 00:48:20.170
All XMLRPC requests are done via POST.

00:48:20.540 --> 00:48:23.600
And the content type is text, XML.

00:48:23.950 --> 00:48:26.520
Content length must be accurate,
must be specified.

00:48:26.760 --> 00:48:29.150
And you have your XML header.

00:48:29.250 --> 00:48:33.640
The method call tag begins the
body of the XML document where

00:48:33.640 --> 00:48:35.590
it specifies your method name.

00:48:35.590 --> 00:48:38.620
In this case, examples.getStateName.

00:48:38.620 --> 00:48:42.770
On the server side,
you will be looking for this method.

00:48:42.770 --> 00:48:45.960
And the value is an int specifying 32.

00:48:48.870 --> 00:48:50.100
The response comes back.

00:48:50.360 --> 00:48:51.600
What is the 30-second state?

00:48:51.600 --> 00:48:54.900
You can see here the answer is Minnesota.

00:48:54.900 --> 00:49:02.300
The response is a standard HTTP packet
with an HTTP response code connection,

00:49:02.300 --> 00:49:06.320
content length, which again is mandatory,
must be specified and accurate,

00:49:06.320 --> 00:49:09.390
content type, date, and server.

00:49:09.400 --> 00:49:11.840
You have your XML header,
and then your method response

00:49:11.850 --> 00:49:13.530
makes up the body of your document.

00:49:13.570 --> 00:49:16.810
A method response has
a single params tag,

00:49:16.810 --> 00:49:19.780
which includes a single parameter.

00:49:19.780 --> 00:49:22.870
The parameter can
include a compound type,

00:49:22.900 --> 00:49:27.520
an array, or a dictionary, a struct,
an XMLRPC vocabulary.

00:49:27.520 --> 00:49:31.520
And what this does is this gives
you the ability to return any

00:49:31.520 --> 00:49:34.080
value you want from your function.

00:49:36.080 --> 00:49:40.500
A fault is a method response,
includes a fault and a value,

00:49:40.520 --> 00:49:45.250
and unlike the method response,
it includes a dictionary with two values,

00:49:45.270 --> 00:49:48.200
a fault code, which is a numeric value,
and a fault string,

00:49:48.200 --> 00:49:51.420
which is a descriptive
term for what the error is.

00:49:52.090 --> 00:49:58.530
There are several common extensions in
XML RPC that many servers implement.

00:49:58.960 --> 00:50:01.380
System.multi-call is
commonly implemented,

00:50:01.380 --> 00:50:04.960
and it allows you to include an
array of dictionaries in the body

00:50:04.960 --> 00:50:08.140
of your payload that allows you
to execute multiple methods in

00:50:08.140 --> 00:50:09.880
a single request response loop.

00:50:09.960 --> 00:50:13.930
And a few introspection methods are also
commonly implemented by many servers.

00:50:13.930 --> 00:50:16.710
List methods, method signature,
and method help.

00:50:18.670 --> 00:50:22.690
Other key features, because it,
by default, goes over HTTP,

00:50:22.820 --> 00:50:26.880
it's very easy to go over HTTPS if
your web server supports it.

00:50:27.000 --> 00:50:31.650
And also it has built-in support for
HTTP user password authentication.

00:50:31.680 --> 00:50:37.480
Likewise, since it's not encrypted,
by default, standard HTTP user password

00:50:37.560 --> 00:50:41.740
authentication is more secure
if you run it over HTTPS.

00:50:42.520 --> 00:50:46.130
At this point,
I'd like to go to demo three to give

00:50:46.190 --> 00:50:49.260
you an example of XML RPC and blogging.

00:50:53.630 --> 00:50:55.640
Let me quick fire up the server here.

00:50:55.640 --> 00:50:59.720
I'm going to show you a quick screen
of what the application looks like,

00:50:59.790 --> 00:51:02.160
and then we'll dive in and
take a quick look at the code.

00:51:25.900 --> 00:51:27.900
Blogging, by the way,
is a very popular thing,

00:51:27.900 --> 00:51:30.040
popular use of XMLRPC.

00:51:30.040 --> 00:51:34.480
And in addition to other popular
technologies like Jabber,

00:51:34.480 --> 00:51:36.160
it's also based on XMLRPC.

00:51:36.160 --> 00:51:38.720
So let me quick log in.

00:51:41.970 --> 00:51:46.100
First, if you want to take a look,
using WoE XML node,

00:51:46.100 --> 00:51:50.390
I created a WoE component
that demonstrates what the

00:51:50.390 --> 00:51:52.170
request is going to look like.

00:51:52.280 --> 00:51:56.200
And since I set the header
content to type text XML,

00:51:56.200 --> 00:52:00.740
Internet Explorer receives this
as an XML document and realizes,

00:52:00.740 --> 00:52:03.840
hey, this is in fact an XML document.

00:52:03.840 --> 00:52:06.540
I have a little handling built
in to show how this works.

00:52:06.540 --> 00:52:07.900
Here is the structure.

00:52:07.900 --> 00:52:09.860
Here is the method that we're using.

00:52:10.520 --> 00:52:13.360
Get user blogs is a login function.

00:52:13.360 --> 00:52:16.240
It returns empty if there's
no blogs for this user.

00:52:16.240 --> 00:52:20.500
And a temp app key is another
parameter that I'm requiring.

00:52:20.500 --> 00:52:23.170
So let's go ahead and log in.

00:52:29.200 --> 00:52:30.870
And you can see it's
a very standard WOAP.

00:52:31.110 --> 00:52:33.430
This is a client application.

00:52:33.460 --> 00:52:37.290
Boy, am I happy to be here.

00:52:40.820 --> 00:52:43.340
and we've successfully submitted
it to the server process,

00:52:43.400 --> 00:52:44.680
which is running on the same box.

00:52:44.680 --> 00:52:48.620
They're communicating
over TCP/IP using XML RPC.

00:52:48.680 --> 00:52:52.680
The request that went
out looked like this.

00:52:52.680 --> 00:52:54.680
Boy, am I happy to be here.

00:52:54.680 --> 00:52:58.230
And the method was new post.

00:52:58.520 --> 00:53:01.760
So, just so that you can see it works,
let's take a look at

00:53:01.830 --> 00:53:03.520
what the blog looks like.

00:53:03.740 --> 00:53:05.840
Rather than actually
publishing a static HTML file,

00:53:05.840 --> 00:53:07.760
I cheated and just made
a little direct action.

00:53:07.760 --> 00:53:10.650
But, boy, am I happy to be here.

00:53:10.650 --> 00:53:12.970
I'm very happy to be here.

00:53:12.980 --> 00:53:18.360
So,
what is involved with this application?

00:53:18.360 --> 00:53:25.890
I made a little core framework
wrapping the Apache XMLRPC jar files.

00:53:27.940 --> 00:53:31.880
The one thing that I've
done that is not--well,

00:53:32.060 --> 00:53:32.940
two things that I've done.

00:53:32.940 --> 00:53:36.550
The first thing that I did that was
not standard or does not come with

00:53:36.890 --> 00:53:40.910
the Apache XMLRPC file is I wrote
a little converter that converts

00:53:40.960 --> 00:53:45.400
NSDictionary's and NSArrays to vectors
and hash tables and back and forth again.

00:53:45.580 --> 00:53:48.460
So that way,
I don't need to modify the Apache code,

00:53:48.700 --> 00:53:52.940
and I can still use all of the native
types that come with WebObjects

00:53:52.940 --> 00:53:57.480
and come from my EOs and EOF and
just have to call one static method

00:53:57.480 --> 00:53:59.980
to do a conversion of my array.

00:54:00.130 --> 00:54:03.030
And you can see here,
depending on the various

00:54:03.370 --> 00:54:06.480
types that they are,
instance of, I convert it one way,

00:54:06.690 --> 00:54:09.370
and then I convert it back another way.

00:54:10.030 --> 00:54:13.190
The second thing that I've
done is I've wrapped... Hmm,

00:54:13.240 --> 00:54:14.160
what are you doing here?

00:54:14.160 --> 00:54:18.730
The second thing that I've
done is I've wrapped... Well,

00:54:18.730 --> 00:54:21.850
it doesn't seem to be happy.

00:54:29.750 --> 00:54:40.940
I wrapped the XML RPC code
with a woe method call.

00:54:40.950 --> 00:54:44.200
The machine appears to be spinning,
so I will talk for a second while

00:54:44.200 --> 00:54:49.340
I try and get back the machine here.

00:54:50.200 --> 00:55:10.400
[Transcript missing]

00:55:38.700 --> 00:55:55.200
[Transcript missing]

00:55:55.560 --> 00:55:56.810
What?

00:55:56.930 --> 00:56:00.310
I think actually you'd probably
want to pay me not to sing.

00:56:00.590 --> 00:56:05.390
But at this point,
I have one last wrap-up slide.

00:56:05.400 --> 00:56:07.290
Maybe if you have some
time at the end of Q&A,

00:56:07.300 --> 00:56:08.820
I'll show some more demo later.

00:56:08.820 --> 00:56:14.120
I just wanted to summarize a few
things about XMLRPC and compare

00:56:14.120 --> 00:56:16.670
it with SOAP in one more way.

00:56:19.350 --> 00:56:23.680
It really is a very simple protocol.

00:56:23.680 --> 00:56:29.180
It says to the remote server,
go ahead and do this one function for

00:56:29.180 --> 00:56:30.970
me and give me back this one result.

00:56:31.370 --> 00:56:37.860
The spec for XMLRPC,
if you go to userland, this is it.

00:56:37.930 --> 00:56:41.290
It's only about, let's see,
six pages long.

00:56:42.130 --> 00:56:46.540
But if you were to go
to the W3C and ask them,

00:56:46.540 --> 00:56:50.260
well, the simple, this is like in SOAP,
is like the green in Greenland.

00:56:50.260 --> 00:56:54.480
Because if you print this out...

00:56:55.320 --> 00:56:57.120
It's like 50 pages long.

00:56:57.140 --> 00:57:05.530
And so I just wanted to point out that
it's good for doing very limited tasks,

00:57:05.530 --> 00:57:08.350
but I think that that'll cover
a lot of what people want.

00:57:08.390 --> 00:57:11.850
At this point,
I think while the demo machine

00:57:11.850 --> 00:57:16.660
comes back to life slowly,
we could probably take some Q&A.
WEBVTT

00:00:03.500 --> 00:00:06.880
It's a real pleasure to be here
today to introduce for the first

00:00:06.880 --> 00:00:11.110
time the CFNetwork APIs at WWDC.

00:00:13.030 --> 00:00:14.510
Okay,
so what we're going to start with is

00:00:14.510 --> 00:00:18.720
just a basic overview of what CF network
is and what it's intended to do.

00:00:18.720 --> 00:00:22.130
Then we're going to back up for a
second and talk about some basic

00:00:22.130 --> 00:00:25.840
concepts that CF network inherits
from Core Foundation itself.

00:00:25.880 --> 00:00:29.100
Once we've covered that,
we're going to get into the meat

00:00:29.100 --> 00:00:32.260
of what the APIs actually provide,
and we're going to start

00:00:32.320 --> 00:00:33.440
with CF socket stream.

00:00:33.440 --> 00:00:37.680
Then move on to the
HTTP engine inside CF network.

00:00:37.810 --> 00:00:43.360
There are two types associated with that,
CF HTTP message and CF HTTP stream.

00:00:43.360 --> 00:00:46.560
Then we're going to talk
about CF net services.

00:00:46.560 --> 00:00:49.750
Those are the APIs that
provide you with access to

00:00:49.900 --> 00:00:52.320
rendezvous and all of its power.

00:00:52.320 --> 00:00:55.100
Then finally,
we're going to wrap up with a simple

00:00:55.210 --> 00:00:57.480
demo about how it all comes together.

00:01:00.020 --> 00:01:02.300
So I'm going to start
out with the overview.

00:01:02.360 --> 00:01:05.200
And we're going to be
answering these five questions.

00:01:05.300 --> 00:01:06.930
What is CFNetwork?

00:01:07.210 --> 00:01:10.100
How does it fit into the
Mac OS X stack as a whole?

00:01:10.100 --> 00:01:12.540
What does it provide to you?

00:01:12.540 --> 00:01:17.540
When you should be using CFNetwork,
as opposed to one of the other

00:01:17.540 --> 00:01:19.620
APIs available on Mac OS X?

00:01:19.620 --> 00:01:22.600
And finally, where is it available?

00:01:24.260 --> 00:01:29.720
So, CFNetwork provides three basic
chunks of functionality in Jaguar.

00:01:29.720 --> 00:01:34.090
It provides, basically,
libraries of abstractions

00:01:34.090 --> 00:01:37.600
for network protocols you all
know and are familiar with.

00:01:37.600 --> 00:01:43.560
So that means sockets, HTTP,
and the new rendezvous APIs.

00:01:43.560 --> 00:01:46.090
The APIs are all in the
style of core foundation.

00:01:46.230 --> 00:01:48.940
We export all of our
functionality using CF types,

00:01:48.940 --> 00:01:52.540
and we build on all of the the
types available in core foundation,

00:01:52.550 --> 00:01:54.970
most notably the run loop.

00:01:56.190 --> 00:02:00.460
So what are the goals
of CFNetwork as a whole?

00:02:00.480 --> 00:02:04.570
The primary goal of CFNetwork
is to expose the full power and

00:02:04.570 --> 00:02:07.600
functionality of the underlying protocol.

00:02:07.750 --> 00:02:13.690
We try to make the protocol accessible
to you in easy and natural terms,

00:02:13.720 --> 00:02:18.060
but we do it without
hiding any of the power,

00:02:18.060 --> 00:02:21.250
any of the flexibility of
whatever protocol lies underneath.

00:02:21.650 --> 00:02:28.020
We try to have strong integration with
the existing API paradigms on the system.

00:02:28.160 --> 00:02:32.550
Most notably, again, is the CFRunLoop,
which, whether you're a Carbon app

00:02:32.680 --> 00:02:35.710
or a Cocoa application,
brings the user events into your

00:02:35.900 --> 00:02:38.080
application for your processing.

00:02:40.690 --> 00:02:46.280
We make sure that our overhead compared
to raw BSD sockets is little to nothing.

00:02:46.320 --> 00:02:49.150
There is a slight memory
footprint overhead,

00:02:49.150 --> 00:02:52.200
and as far as throughput goes,
there's almost no overhead.

00:02:52.200 --> 00:02:54.800
It's in the noise,
provided the packet leaves

00:02:54.800 --> 00:02:57.530
the computer over the network.

00:02:57.580 --> 00:03:01.120
However, what we will not do is we
will not protect you from

00:03:01.120 --> 00:03:03.140
the details of the protocol.

00:03:03.140 --> 00:03:06.570
We can't provide you with the full
flexibility of the protocol while

00:03:06.570 --> 00:03:08.520
shielding you from those details.

00:03:11.080 --> 00:03:12.340
So how does it fit in?

00:03:12.400 --> 00:03:15.140
You've probably seen this diagram
or something pretty similar

00:03:15.140 --> 00:03:16.850
a few million times by now.

00:03:16.960 --> 00:03:21.170
It's the basic API stacks
available to you as a developer.

00:03:21.920 --> 00:03:25.820
And here I've overlaid
the basic networking APIs.

00:03:25.910 --> 00:03:29.170
Down at the Core OS layer in Darwin,
we have Berkeley Sockets.

00:03:29.230 --> 00:03:30.260
That's our foundation.

00:03:30.260 --> 00:03:34.760
Everything inside CFNetwork
is done on top of TCP/IP.

00:03:34.760 --> 00:03:39.450
CFNetwork itself resides
inside the core services layer,

00:03:39.560 --> 00:03:42.340
so it's beneath all the
application frameworks.

00:03:42.350 --> 00:03:46.830
That's also below the UI layer,
so it's accessible to you if you're

00:03:46.830 --> 00:03:48.720
a faceless application or a daemon.

00:03:48.900 --> 00:03:51.950
And then up inside the
application frameworks,

00:03:52.030 --> 00:03:54.780
Carbon and Cocoa,
you see some of the other

00:03:54.780 --> 00:03:56.720
networking APIs on the platform.

00:03:57.040 --> 00:04:03.110
They're built on this foundation of
CFNetwork on top of Berkeley Sockets.

00:04:03.460 --> 00:04:05.060
But it gets more interesting.

00:04:05.120 --> 00:04:07.770
If you look inside of
core services itself,

00:04:07.880 --> 00:04:10.140
you can find some more layering.

00:04:10.160 --> 00:04:13.780
And here we can see that CFNetwork
is built on top of the foundation

00:04:13.780 --> 00:04:15.960
provided by core foundation.

00:04:15.970 --> 00:04:20.880
In particular, we use CFURL, CFStream,
and CFRunLoop quite heavily.

00:04:21.660 --> 00:04:26.850
And then other core services networking
APIs are built on top of CFNetwork.

00:04:26.910 --> 00:04:32.390
So the two most notable examples of
that are the new web services framework,

00:04:32.390 --> 00:04:35.600
which provides access to
SOAP and XMLRPC messaging,

00:04:35.730 --> 00:04:36.370
and NSL.

00:04:39.130 --> 00:04:43.040
So just to summarize, CFNetwork,
part of the core services layer,

00:04:43.040 --> 00:04:46.720
builds on top of BSD sockets
plus core foundation,

00:04:46.720 --> 00:04:51.140
used by all of the higher-level
frameworks like NSURL,

00:04:51.140 --> 00:04:53.000
NSL, web services.

00:04:53.000 --> 00:04:56.150
But it's also used directly
by many apps on our platform,

00:04:56.150 --> 00:04:59.960
largely at times when they want a
performance boost relative to using

00:04:59.960 --> 00:05:02.560
the more convenient higher-level APIs.

00:05:03.240 --> 00:05:08.850
So just as some examples, Mail,
Software Update, Sherlock, iPhoto,

00:05:09.220 --> 00:05:12.880
and the new iChat all use CFNetwork
for their networking needs.

00:05:15.680 --> 00:05:19.840
Okay,
so what do you find inside CFNetwork?

00:05:19.960 --> 00:05:23.340
Three basic pieces,
some common socket abstractions that

00:05:23.430 --> 00:05:27.950
provide the basic streaming model
that we're going to use throughout.

00:05:28.230 --> 00:05:31.660
An HTTP 1.1 engine,
so that's fully persistent,

00:05:31.790 --> 00:05:35.520
pipelined connections,
exported through two types,

00:05:35.520 --> 00:05:38.920
HTTP message and HTTP stream.

00:05:38.920 --> 00:05:44.360
And finally, the Net Services layer,
which provides API access to

00:05:44.360 --> 00:05:46.960
zero configuration or rendezvous.

00:05:46.960 --> 00:05:51.100
And we have two types there,
CFNet Service and CFNet Service Browser.

00:05:51.170 --> 00:05:55.970
And we're going to walk you through
all of those APIs in detail here.

00:05:57.430 --> 00:06:00.200
So, finally,
when should you use CF network?

00:06:00.200 --> 00:06:05.080
Well, use CF network precisely
when you need a low-level,

00:06:05.080 --> 00:06:06.240
high-performance framework.

00:06:06.240 --> 00:06:09.390
If you're thinking about,
should I use CF network instead

00:06:09.390 --> 00:06:13.490
of one of the higher-level APIs,
you should drop to CF network

00:06:13.620 --> 00:06:15.630
if this describes you.

00:06:15.640 --> 00:06:19.140
You want to work directly with
the socket more intimately.

00:06:19.140 --> 00:06:24.160
You need exacting control of when the
bytes are read or written to the network.

00:06:24.540 --> 00:06:26.840
You're not happy with letting
a higher-level framework

00:06:26.840 --> 00:06:28.060
move the bytes for you.

00:06:29.390 --> 00:06:34.730
You need detailed control of
HTTP and an HTTP transaction.

00:06:34.880 --> 00:06:35.980
You want to link low.

00:06:36.000 --> 00:06:40.430
You want to avoid linking with
something in the UI layer.

00:06:40.710 --> 00:06:43.580
or you need new features that
are only available in CFNetwork,

00:06:43.690 --> 00:06:46.250
and Net Services would be
the big example of that.

00:06:46.340 --> 00:06:49.910
But please, by all means,
use the higher-level

00:06:49.910 --> 00:06:52.020
APIs when it's possible.

00:06:52.020 --> 00:06:53.240
They're more convenient.

00:06:53.240 --> 00:06:54.020
They're simpler.

00:06:54.020 --> 00:06:57.100
They just don't give you as much power,
so you have to decide

00:06:57.100 --> 00:06:58.150
what your needs are.

00:07:01.100 --> 00:07:03.560
Now let's look at it from the other side.

00:07:03.770 --> 00:07:07.370
How do you know you should climb
to CFNetwork if you're thinking

00:07:07.430 --> 00:07:09.200
about using sockets instead?

00:07:09.200 --> 00:07:14.100
Well, use CFNetwork if you need
integration with the run loop.

00:07:14.110 --> 00:07:19.590
You can do it yourself,
but we've done it for you,

00:07:19.590 --> 00:07:19.590
so why not take advantage
of the work we've done?

00:07:20.210 --> 00:07:22.560
In particular,
if you want to avoid managing

00:07:22.560 --> 00:07:25.650
the details of select,
let us do that for you.

00:07:25.700 --> 00:07:30.110
Or if you want simple
TLS or SSL integration,

00:07:30.130 --> 00:07:33.050
we can provide that for you.

00:07:33.210 --> 00:07:37.480
Or if you want some kind of
a basic object abstraction,

00:07:37.480 --> 00:07:42.290
I've put object in quotes because core
foundation is not a true OO language,

00:07:42.430 --> 00:07:45.590
but it does give you
some object-orientedness.

00:07:45.600 --> 00:07:48.930
And in particular, it provides you with
some reference counting.

00:07:52.000 --> 00:07:53.420
So where can you find CFNetwork?

00:07:53.490 --> 00:07:59.360
CFNetwork actually appeared as a
public API for the first time in 10.1,

00:07:59.360 --> 00:08:02.060
but we've added many new
features starting with Jaguar.

00:08:02.060 --> 00:08:03.640
Here are the three big ones.

00:08:03.730 --> 00:08:09.040
We've added SOX support,
that's SOX v4 and v5, CFNet services,

00:08:09.040 --> 00:08:12.530
of course, and we've moved from HTTP.

00:08:12.610 --> 00:08:15.460
They were 1.1 connections,
but they were not persistent.

00:08:15.460 --> 00:08:18.090
Starting with Jaguar,
we have full persistent

00:08:18.090 --> 00:08:20.530
pipelined HTTP 1.1 connections.

00:08:23.500 --> 00:08:25.840
Okay,
so with that I'm going to move on to

00:08:25.950 --> 00:08:29.060
start talking about some basic concepts.

00:08:30.300 --> 00:08:33.860
There are two basic concepts from
Core Foundation that we leverage heavily,

00:08:33.860 --> 00:08:38.380
and it's going to be difficult for you to
use CFNetwork without understanding them.

00:08:38.400 --> 00:08:41.920
Those are streams and run loops,
so I'm going to breeze through the

00:08:41.920 --> 00:08:43.780
basics of those two types here.

00:08:43.780 --> 00:08:46.320
However,
if you're not familiar with them,

00:08:46.320 --> 00:08:49.820
I highly recommend you come
to session 808 tomorrow,

00:08:49.820 --> 00:08:50.940
Managing I.O.

00:08:50.940 --> 00:08:54.290
That session is all about
using CFStream and CFRunLoop.

00:08:54.410 --> 00:08:58.810
We go into just tons more detail
than I have time for today.

00:09:01.500 --> 00:09:02.110
So streams.

00:09:02.200 --> 00:09:04.460
What is a stream?

00:09:04.520 --> 00:09:10.490
A stream is simply a one-way byte stream
to some source or some destination.

00:09:10.590 --> 00:09:15.720
The APIs are very similar to
simple POSIX file descriptors.

00:09:15.860 --> 00:09:20.460
You create the stream, you open it,
you do a bunch of reads or writes.

00:09:20.530 --> 00:09:24.110
When you're done,
you close it and dispose of it.

00:09:24.260 --> 00:09:27.180
There are two true CF types
to represent the streams,

00:09:27.200 --> 00:09:30.640
CF Read stream and CF Write stream,
so that's one for each direction.

00:09:30.640 --> 00:09:34.780
However, as I go through this talk,
I'll be talking about

00:09:34.880 --> 00:09:39.040
other types of streams,
like a socket stream or an HTTP stream.

00:09:39.040 --> 00:09:42.410
Those are just special cases
of read or write streams,

00:09:42.410 --> 00:09:47.100
and you should be aware that they are
not true CF types in their own right.

00:09:52.110 --> 00:09:52.690
Properties.

00:09:52.790 --> 00:09:54.710
So streams carry properties.

00:09:54.770 --> 00:09:59.450
That's the way you represent anything
about the stream that is not actually

00:09:59.460 --> 00:10:01.890
part of the data transfer itself.

00:10:02.550 --> 00:10:05.520
properties describe how the
stream is going to behave.

00:10:05.570 --> 00:10:08.910
They also represent any
information discovered by the

00:10:08.920 --> 00:10:10.900
stream as it does its processing.

00:10:12.410 --> 00:10:15.360
So when you need to configure a stream,
you're going to do that by

00:10:15.370 --> 00:10:17.570
setting properties on the stream.

00:10:17.720 --> 00:10:20.580
And when you need to get
information from the stream,

00:10:20.580 --> 00:10:22.720
you may well do it by
querying properties.

00:10:28.150 --> 00:10:29.400
So how do you use properties?

00:10:29.400 --> 00:10:33.720
Properties come in name-value pairs.

00:10:33.720 --> 00:10:36.980
So you're going to access
the property by name.

00:10:36.980 --> 00:10:38.090
The name is a CFString.

00:10:38.090 --> 00:10:41.400
And the value is going to
be some kind of CFType.

00:10:41.490 --> 00:10:44.540
You should be aware that when
you get and set properties,

00:10:44.620 --> 00:10:47.720
streams always have the
right to refuse properties.

00:10:47.720 --> 00:10:50.340
Properties is a very generic mechanism.

00:10:50.340 --> 00:10:54.330
And if you ask a stream about a property,
it doesn't recognize.

00:10:54.400 --> 00:10:57.160
It's simply going to
say no or return null.

00:10:58.990 --> 00:11:02.940
So a stream will refuse a property
if it doesn't recognize it,

00:11:02.980 --> 00:11:06.500
if the value is invalid
or somehow misformatted,

00:11:06.500 --> 00:11:09.730
or if the stream has already been opened.

00:11:10.120 --> 00:11:12.660
There are certain properties
that you can set on the fly,

00:11:12.660 --> 00:11:15.860
but unless you see documentation
that says otherwise,

00:11:16.000 --> 00:11:20.500
assume you must configure the stream,
you must set the properties

00:11:20.500 --> 00:11:22.770
prior to opening the stream.

00:11:23.410 --> 00:11:26.040
So how do you know when a
stream's refused a property?

00:11:26.160 --> 00:11:28.740
Well,
copy property is going to return null.

00:11:28.820 --> 00:11:31.290
Set property will return false.

00:11:33.260 --> 00:11:35.090
So here are some examples.

00:11:35.100 --> 00:11:38.930
In the first one,
I'm asking an HTTP stream for

00:11:38.930 --> 00:11:41.100
the response headers it's read.

00:11:41.100 --> 00:11:44.090
Read stream copy property,
pass the stream,

00:11:44.090 --> 00:11:46.000
and then the named property.

00:11:46.000 --> 00:11:49.090
KCF stream property,
HTTP response headers.

00:11:49.250 --> 00:11:52.450
In the second one,
I'm setting the security level

00:11:52.450 --> 00:11:55.340
on a socket to be negotiated SSL.

00:11:55.340 --> 00:11:58.090
This would be, for instance,
the setting you'd want if you were

00:11:58.090 --> 00:12:00.400
trying to program HTTPS yourself.

00:12:00.400 --> 00:12:03.590
You'd set it to negotiate
SSL with the server.

00:12:04.330 --> 00:12:09.660
Finally, I'm configuring an HTTP proxy
on presumably an HTTP stream,

00:12:09.660 --> 00:12:13.540
and I'm passing in a proxy
dictionary to describe that proxy.

00:12:20.200 --> 00:12:23.360
Okay, so that's your brief 30-second
introduction to streams.

00:12:23.360 --> 00:12:26.100
Now you're going to get a 30-second
introduction to run loops.

00:12:26.100 --> 00:12:28.600
So run loops are also
from Core Foundation,

00:12:28.600 --> 00:12:31.690
and they're represented by a CF type,
CF run loop.

00:12:31.960 --> 00:12:34.940
And it's a basic abstraction
for an event loop.

00:12:35.020 --> 00:12:38.230
The idea is that the run loop
has several different sources,

00:12:38.300 --> 00:12:42.000
and in the course of its lifetime,
it looks at those sources and waits

00:12:42.000 --> 00:12:44.120
for something interesting to happen.

00:12:44.120 --> 00:12:47.370
If something interesting
happens to one of the sources,

00:12:47.370 --> 00:12:49.090
that triggers a callback.

00:12:49.480 --> 00:12:52.190
the callback handles the event.

00:12:52.390 --> 00:12:55.670
So, for example,
some typical sources you'd see on a

00:12:55.670 --> 00:13:00.680
run loop inside a running application
would be sources to handle user events,

00:13:00.680 --> 00:13:03.480
mouse clicks, key presses,
that kind of thing.

00:13:03.480 --> 00:13:07.860
Sources to field Mach messages
coming in over IPC.

00:13:07.860 --> 00:13:11.560
Possibly timers,
and then the one of greatest

00:13:11.660 --> 00:13:15.080
interest to us here,
socket sources.

00:13:15.720 --> 00:13:20.010
Anytime we talk about a CF run loop,
it's important to keep in mind there's

00:13:20.040 --> 00:13:23.030
exactly one CF run loop per thread.

00:13:23.110 --> 00:13:26.280
If you have multiple threads,
you have multiple run loops.

00:13:26.280 --> 00:13:29.240
If you have a run loop,
you're talking about a thread.

00:13:32.770 --> 00:13:36.320
So here's the basic
lifetime of a run loop.

00:13:36.430 --> 00:13:38.690
The run loop sits watching its sources.

00:13:38.810 --> 00:13:41.840
When something interesting happens,
the run loop notices,

00:13:42.120 --> 00:13:43.100
triggers a callback.

00:13:43.200 --> 00:13:47.090
The callback will execute something,
somehow process the event,

00:13:47.090 --> 00:13:48.120
and then return.

00:13:48.120 --> 00:13:51.640
And the run loop simply
goes back to watching again,

00:13:51.640 --> 00:13:54.990
looking for something
interesting to happen.

00:13:55.830 --> 00:13:59.490
The point behind all of this is
it allows you to manage multiple

00:13:59.490 --> 00:14:01.220
inputs on a single thread.

00:14:01.310 --> 00:14:02.880
You have five sockets?

00:14:02.960 --> 00:14:03.340
Fine.

00:14:03.340 --> 00:14:06.180
Just install five socket
sources on the run loop.

00:14:06.310 --> 00:14:10.070
The run loop is now watching all five
sockets on a single thread for you.

00:14:14.320 --> 00:14:15.380
Runloops and clients.

00:14:15.380 --> 00:14:21.760
So clients is a notion that CFNetwork
and CFStream together use pretty heavily.

00:14:21.760 --> 00:14:26.510
The idea behind setting a client
is you are setting your callback,

00:14:26.640 --> 00:14:32.080
your info pointer, and saying, hey,
I'm interested in these kinds of events.

00:14:32.080 --> 00:14:34.180
Please inform me via the runloop.

00:14:34.800 --> 00:14:37.530
So to use a client,
what you do is you first call

00:14:37.530 --> 00:14:39.700
setClient on the relevant object.

00:14:39.700 --> 00:14:41.410
CFReadStream setClient.

00:14:41.430 --> 00:14:44.160
You pass the stream,
you pass your refcon,

00:14:44.290 --> 00:14:46.320
and then you pass a callback.

00:14:47.890 --> 00:14:52.690
Then you take the CFNetwork object
and you schedule it on a run loop.

00:14:53.190 --> 00:14:57.700
Remember, run loop is a thread,
so essentially what you're saying is

00:14:57.700 --> 00:15:00.270
I want to handle events on this thread.

00:15:00.350 --> 00:15:04.490
CF read stream schedule with run loop,
pass the stream,

00:15:04.550 --> 00:15:07.110
you pass the run loop of interest.

00:15:07.110 --> 00:15:10.670
Typically you're going to be
scheduling on the current run loop,

00:15:10.790 --> 00:15:14.320
meaning I want the callback on
this thread that is executing now.

00:15:14.950 --> 00:15:16.100
CF run loop get current.

00:15:16.100 --> 00:15:20.030
And then finally the modes,
which we'll get into more

00:15:20.030 --> 00:15:22.030
detail in session 808.

00:15:22.090 --> 00:15:25.140
I'm just going to use
the common modes here.

00:15:27.780 --> 00:15:31.030
So you can always schedule on
multiple run loops if you want.

00:15:31.140 --> 00:15:34.290
Just call schedule with
run loop multiple times.

00:15:34.290 --> 00:15:38.940
But remember, multiple run loops
means multiple threads.

00:15:38.940 --> 00:15:41.940
The objects that we're
talking about are not,

00:15:41.940 --> 00:15:43.740
in general, thread safe.

00:15:43.740 --> 00:15:48.410
You must make sure you are only accessing
them from a single thread at a time.

00:15:48.430 --> 00:15:51.190
So if you've scheduled
on multiple run loops,

00:15:51.190 --> 00:15:54.360
it is your responsibility
to protect the objects.

00:15:59.510 --> 00:16:00.580
So now what happens?

00:16:00.670 --> 00:16:02.900
I've taken this object,
set my client on it,

00:16:03.030 --> 00:16:04.330
and scheduled it on a run loop.

00:16:04.390 --> 00:16:09.480
Well, as the run loop runs,
the CFNetwork object is going

00:16:09.480 --> 00:16:13.530
to detect interesting events,
bytes arriving on the socket,

00:16:13.530 --> 00:16:17.140
an error occurring,
the connect occurring,

00:16:17.140 --> 00:16:19.170
those kinds of things.

00:16:19.430 --> 00:16:22.400
As it detects those changes,
it will trigger your

00:16:22.400 --> 00:16:23.760
callback from the thread.

00:16:23.800 --> 00:16:28.140
Now, the catch here is that if
the run loop is not running,

00:16:28.140 --> 00:16:32.300
the CFNetwork object isn't
looking for interesting events.

00:16:32.300 --> 00:16:35.130
So it is, again,
your responsibility to make sure

00:16:35.130 --> 00:16:38.890
that the run loop is running if
you've scheduled an object on it.

00:16:38.900 --> 00:16:41.700
Now,
the good news is that both the Cocoa and

00:16:41.800 --> 00:16:46.480
Carbon UI frameworks will run the
run loop for the main thread for you.

00:16:46.500 --> 00:16:49.040
That's how it's watching for user events.

00:16:49.660 --> 00:16:53.770
However, if you spawn a secondary thread,
or if you're not linked with one

00:16:53.770 --> 00:16:56.700
of these high-level frameworks,
running the run loop is going

00:16:56.700 --> 00:16:58.120
to be your responsibility.

00:17:02.120 --> 00:17:06.600
Okay, so for most CF objects,
when you're done with them,

00:17:06.830 --> 00:17:10.350
you simply release them,
and that's your signal to say, okay,

00:17:10.350 --> 00:17:11.880
I never need to hear from you again.

00:17:11.890 --> 00:17:12.770
Go away.

00:17:12.780 --> 00:17:16.620
That does not work with run-loop sources,
because remember,

00:17:16.620 --> 00:17:19.120
they're holding a refcon back to you.

00:17:19.120 --> 00:17:22.680
And just because you have released
your reference on them doesn't

00:17:22.740 --> 00:17:26.100
mean someone else isn't holding
on to the CFNetwork object.

00:17:26.190 --> 00:17:28.940
And as long as that
CFNetwork object is alive,

00:17:28.940 --> 00:17:30.940
it may well call back into you.

00:17:31.730 --> 00:17:34.700
So, how do you work with that?

00:17:34.870 --> 00:17:38.010
When you are done with
the CFNetwork object,

00:17:38.010 --> 00:17:42.370
make sure to call setClientNull
to tell the CFNetwork object,

00:17:42.370 --> 00:17:45.480
never trigger my callback again.

00:17:46.340 --> 00:17:49.310
At the same time,
you should also unschedule from any

00:17:49.310 --> 00:17:54.220
run loops to avoid causing unnecessary
thrashing or running on the run loop.

00:17:54.330 --> 00:17:55.250
So it looks like this.

00:17:55.550 --> 00:17:58.900
CF read stream set client null.

00:17:59.310 --> 00:18:03.040
Unschedule from run loop, stream,
the same run loop you scheduled on,

00:18:03.070 --> 00:18:06.650
the same modes you scheduled with,
and then finally you're done.

00:18:06.680 --> 00:18:07.810
You can release the stream.

00:18:12.530 --> 00:18:15.580
So that's it for the basics
from Core Foundation.

00:18:15.630 --> 00:18:20.140
Now we're going to move into the meat of
what the APIs inside CFNetwork provide.

00:18:22.380 --> 00:18:25.200
We're going to start
out with socket streams.

00:18:25.350 --> 00:18:29.490
From core foundation itself,
there are APIs that allow you to

00:18:29.650 --> 00:18:34.140
create a read stream and a write
stream pair for a given socket.

00:18:34.190 --> 00:18:39.270
You can specify the remote end of
the socket stream these three ways,

00:18:39.270 --> 00:18:44.120
by host name, meaning domain name,
and the port number.

00:18:44.530 --> 00:18:47.280
By the raw socket,
maybe you already have a socket that

00:18:47.350 --> 00:18:49.100
you've configured from some other source.

00:18:49.100 --> 00:18:54.380
Or by the socket signature,
in other words, by the sock adder.

00:18:54.890 --> 00:18:58.140
Basic support, like I said,
is provided inside of core foundation,

00:18:58.140 --> 00:19:02.500
but CFNetwork adds a number of
interesting configuration properties.

00:19:04.720 --> 00:19:06.120
and, right.

00:19:06.170 --> 00:19:11.540
Okay, so you can find those properties
inside cfsocketstream.h.

00:19:11.540 --> 00:19:14.800
One thing to keep in
mind is with the socket,

00:19:14.800 --> 00:19:18.600
the read stream and the write stream
are using that same underlying resource.

00:19:18.600 --> 00:19:20.320
They're both talking to the same socket.

00:19:20.320 --> 00:19:23.890
So if you configure the read stream,
that's going to affect the

00:19:23.890 --> 00:19:25.810
write stream and vice versa.

00:19:26.420 --> 00:19:30.110
And you should also keep in mind
that you can set socket properties on

00:19:30.110 --> 00:19:34.900
any streams built on top of sockets,
and we take care of passing it through.

00:19:35.050 --> 00:19:38.380
So for example,
if you want to set the SOX proxy,

00:19:38.460 --> 00:19:42.500
which is a socket stream property,
on an HTTP stream,

00:19:42.570 --> 00:19:49.000
just go ahead and do it,
and it's the HTTP stream's responsibility

00:19:49.010 --> 00:19:49.010
to pass that property setting through.

00:19:49.150 --> 00:19:54.010
Now, this, I have to admit,
is not quite working on the CDs you have.

00:19:54.750 --> 00:19:58.300
However, it will be working by Jaguar,
really.

00:20:01.560 --> 00:20:03.950
So what are the interesting
socket properties?

00:20:04.050 --> 00:20:06.160
Here they are.

00:20:06.180 --> 00:20:11.260
The SOCKS proxy settings are one
of the interesting properties.

00:20:11.260 --> 00:20:12.870
You can configure V4, V5.

00:20:12.870 --> 00:20:16.240
You can configure the remote address.

00:20:16.240 --> 00:20:18.180
If you want,
you can construct the dictionary

00:20:18.180 --> 00:20:20.000
with these values yourself.

00:20:20.070 --> 00:20:24.760
If instead you want to just inherit
whatever the setting is on the computer,

00:20:24.760 --> 00:20:29.080
on the current host,
use system config to grab the proxy

00:20:29.120 --> 00:20:32.610
dict and just pass it blindly through.

00:20:32.680 --> 00:20:33.890
You don't have to look at it.

00:20:33.890 --> 00:20:36.500
We have made the formats match.

00:20:36.970 --> 00:20:42.230
The other interesting property
that you'll find in CFNetwork

00:20:42.230 --> 00:20:43.640
is the TLS or SSL level.

00:20:46.510 --> 00:20:54.810
I'm going to move on now to talk about
the HTTP engine inside of CFNetwork.

00:20:58.600 --> 00:21:01.920
So, again,
there are two basic CF types we

00:21:01.940 --> 00:21:04.540
provide for handling HTTP transactions.

00:21:04.540 --> 00:21:11.400
CF HTTP message is just a data object,
represents an HTTP request or response.

00:21:13.250 --> 00:21:17.140
CFHTTP Stream, on the other hand,
is the object that

00:21:17.140 --> 00:21:19.250
actually does the download,
actually builds the

00:21:19.330 --> 00:21:20.480
connection to the server.

00:21:21.830 --> 00:21:26.370
So the normal way you're going to use
the HTTP engine is you first create an

00:21:26.370 --> 00:21:28.560
HTTP message that represents the request.

00:21:28.560 --> 00:21:32.700
Then you create a stream
from the HTTP message.

00:21:32.790 --> 00:21:37.790
Then you open from the stream
and read the bytes off.

00:21:41.420 --> 00:21:46.600
So, first CFHTTP message.

00:21:46.820 --> 00:21:50.300
Like I said,
it represents the request or response.

00:21:50.300 --> 00:21:53.330
You can get and set the header fields,
you can get and set the body,

00:21:53.330 --> 00:21:58.290
you can configure every
aspect of the HTTP message.

00:22:00.000 --> 00:22:04.030
And when you use the HTTP message,
there are two basic usage patterns.

00:22:04.070 --> 00:22:07.860
Either you're going to construct
the message programmatically,

00:22:07.860 --> 00:22:09.040
that's the normal usage.

00:22:09.040 --> 00:22:12.050
You say, I want a request,
it's going to be a get request,

00:22:12.180 --> 00:22:14.860
here's the URL,
and here are the header fields.

00:22:15.840 --> 00:22:20.050
Or you're trying to parse out a
message from a series of bytes,

00:22:20.050 --> 00:22:24.380
so you know you have a byte stream
that is coming from an HTTP server

00:22:24.480 --> 00:22:29.430
or that represents an HTTP message,
and you just want us to go through the

00:22:29.500 --> 00:22:32.300
work of parsing out the HTTP structures.

00:22:35.870 --> 00:22:37.530
So what does it look like?

00:22:37.660 --> 00:22:40.000
Here's how I construct a message.

00:22:40.140 --> 00:22:42.650
CFHTTP message create request.

00:22:42.830 --> 00:22:44.850
I pass the allocator.

00:22:44.850 --> 00:22:50.230
I pass the request string,
so in this case I'm doing a post.

00:22:50.230 --> 00:22:54.230
I pass the URL that I'm
interested in accessing.

00:22:54.370 --> 00:22:57.680
And then finally I pass
the version string.

00:22:59.900 --> 00:23:02.570
Now I've got my object,
and I can go ahead and start

00:23:02.610 --> 00:23:03.840
setting header fields on it.

00:23:03.950 --> 00:23:08.110
So here I'm setting the user
agent to be some string.

00:23:08.600 --> 00:23:11.700
You can set any number of them,
obviously.

00:23:12.300 --> 00:23:14.760
And then at some point in the future,
you may want to set a

00:23:14.760 --> 00:23:15.820
body on the request.

00:23:15.860 --> 00:23:20.520
CFHTTP message, set body,
and here I'm just setting

00:23:20.520 --> 00:23:21.700
it to be some post data.

00:23:25.020 --> 00:23:25.860
Here's the other usage.

00:23:25.960 --> 00:23:30.800
I'm going to breeze through this
because this is the less common usage.

00:23:31.020 --> 00:23:34.300
But if you do have a series of
bytes from an HTTP server and

00:23:34.780 --> 00:23:36.900
you're parsing it manually,
here's how you do it.

00:23:37.030 --> 00:23:38.530
You'd create an empty message.

00:23:38.530 --> 00:23:42.860
You would go and get the bytes from
wherever you're getting them from.

00:23:42.860 --> 00:23:47.650
And then as you get byte buffers,
you would call HTTP message append bytes.

00:23:47.650 --> 00:23:51.210
That function will return true,
assuming the parse succeeded.

00:23:51.240 --> 00:23:53.510
If it returns false,
it means the data you

00:23:53.590 --> 00:23:54.880
gave it was not valid.

00:23:54.900 --> 00:23:57.410
to validate HTTP data.

00:23:58.160 --> 00:24:01.420
Once you're done, you can now examine the
message that you got,

00:24:01.600 --> 00:24:05.770
find out what the status code is,
look at any of the header fields.

00:24:10.000 --> 00:24:11.620
Okay, so much for HTTP message.

00:24:11.620 --> 00:24:13.740
Now let's move on to HTTP stream.

00:24:16.070 --> 00:24:19.820
You create an HTTP stream
from an HTTP message,

00:24:19.950 --> 00:24:22.560
which represents a request.

00:24:22.570 --> 00:24:26.340
When you open and read from that stream,
you're not going to get the header data.

00:24:26.420 --> 00:24:30.200
What you're getting is
the pure body bytes.

00:24:31.050 --> 00:24:34.130
If you need to examine
the HTTP header itself,

00:24:34.130 --> 00:24:37.980
you will do that by fetching a
property like we saw earlier,

00:24:37.980 --> 00:24:41.470
CFStreamPropertyHttpResponseHeader.

00:24:44.230 --> 00:24:56.360
CFHTTP Stream provides a number of
properties that are interesting above

00:24:56.360 --> 00:24:59.680
and beyond the socket properties.

00:24:59.680 --> 00:24:59.680
You can find those HTTP-specific
properties in CFHTTPStream.h.

00:24:59.990 --> 00:25:00.730
Here's a list of them.

00:25:00.820 --> 00:25:04.650
The ones that are settable are whether
the stream should automatically redirect

00:25:04.890 --> 00:25:07.990
when it receives a 300 response.

00:25:08.070 --> 00:25:09.550
You can set the proxy settings.

00:25:09.660 --> 00:25:12.930
That works exactly the same
way as the SOX proxy settings.

00:25:12.930 --> 00:25:16.890
Just get the dictionary from system
config and pass it blindly through

00:25:17.290 --> 00:25:20.670
if you simply want to use the
proxy settings on the host itself.

00:25:20.670 --> 00:25:26.200
And you can set whether or not
to use a persistent connection.

00:25:27.070 --> 00:25:31.030
The gettable properties are
the response header and the

00:25:31.160 --> 00:25:32.740
final URL that was accessed.

00:25:32.810 --> 00:25:36.160
The final URL will only differ
from the URL in the request

00:25:36.160 --> 00:25:41.270
if there was a redirection and
automatic redirection was turned on.

00:25:43.730 --> 00:25:46.000
So how do I use an HTTP stream?

00:25:46.030 --> 00:25:50.630
Well, create it and configure it,
schedule it,

00:25:50.760 --> 00:25:56.420
Get the response in your callback,
and then after that's all done, clean up.

00:25:57.710 --> 00:26:00.090
We're going to walk through
each of those in detail.

00:26:00.090 --> 00:26:03.600
So here's the creation phase.

00:26:03.760 --> 00:26:07.580
Construct the request from somewhere,
like we did before.

00:26:08.910 --> 00:26:09.990
Then create the stream.

00:26:10.120 --> 00:26:12.530
CFReadStream create for HTTP request.

00:26:12.680 --> 00:26:16.400
Pass the allocator and the
CFHTTP message for the request.

00:26:19.240 --> 00:26:21.580
Now do any configuration
that's interesting.

00:26:21.590 --> 00:26:25.000
If you want to, for instance,
if you want automatic

00:26:25.150 --> 00:26:28.300
redirection to go on,
set it now.

00:26:28.480 --> 00:26:30.570
If you have a proxy
dictionary you want to set,

00:26:30.890 --> 00:26:33.680
now would be the time to do that.

00:26:34.240 --> 00:26:36.430
When you're done, return the stream.

00:26:36.520 --> 00:26:39.890
So now we have a stream and
we're ready to schedule.

00:26:41.120 --> 00:26:44.300
As part of scheduling,
you're going to need to set your client.

00:26:44.300 --> 00:26:47.280
The first part of setting the client
is deciding what events in the

00:26:47.280 --> 00:26:50.500
stream lifetime you're interested in.

00:26:51.310 --> 00:26:54.900
So here I'm saying that the
events I'm interested in are

00:26:55.210 --> 00:26:59.320
when the open is completed,
when the stream is fully opened.

00:26:59.470 --> 00:27:04.200
I want to know when the stream has bytes
available that are ready to be read off.

00:27:04.210 --> 00:27:07.300
I want to know when the end of
the stream has been reached.

00:27:07.430 --> 00:27:11.300
And I want to know if any
error occurs along the way.

00:27:13.640 --> 00:27:15.990
Okay, now I'm ready to set the client.

00:27:16.110 --> 00:27:19.720
Set client, pass the stream,
pass the events that

00:27:19.720 --> 00:27:23.660
you're interested in,
then the callback, handle event,

00:27:23.690 --> 00:27:25.560
finally your context pointer.

00:27:30.730 --> 00:27:32.400
Streams been configured.

00:27:32.430 --> 00:27:33.630
I've set my client.

00:27:33.850 --> 00:27:36.300
Now I'm ready to
schedule on the run loop.

00:27:36.510 --> 00:27:38.650
CFReadStreams schedule with run loop.

00:27:38.700 --> 00:27:41.010
Here, again,
I'm scheduling on the current

00:27:41.010 --> 00:27:42.660
run loop in the common modes.

00:27:42.760 --> 00:27:47.030
So I'm saying that as long as the
toolboxes are just doing normal things,

00:27:47.030 --> 00:27:51.320
as long as the run loop has not been
put into some kind of funky mode,

00:27:51.320 --> 00:27:54.380
I want my callback,
and I want it on this thread.

00:27:57.940 --> 00:28:01.660
Finally, I'm ready to open the stream.

00:28:01.690 --> 00:28:03.660
Now I just sit back and wait.

00:28:03.660 --> 00:28:07.510
The RunLoop and CFNetwork
is doing your work for you,

00:28:07.740 --> 00:28:10.910
and all you have to do is wait
for your callback to come in.

00:28:13.460 --> 00:28:18.100
So first I'm going to show you
the signature for the callback.

00:28:18.190 --> 00:28:19.660
Callback takes three arguments.

00:28:19.720 --> 00:28:23.580
The first one is going to be
the stream reporting the event.

00:28:23.730 --> 00:28:26.900
Second argument is
what event has come in.

00:28:26.930 --> 00:28:29.620
And the last argument
is your info pointer.

00:28:32.220 --> 00:28:34.950
Most of the time,
your callback is simply going to be a

00:28:34.950 --> 00:28:40.410
giant switch with a case statement for
each of the events you registered for.

00:28:40.950 --> 00:28:44.720
I added the default line here with the
just prints you should never get here.

00:28:44.720 --> 00:28:48.100
You will never receive an
event you didn't register for.

00:28:48.100 --> 00:28:52.820
So now let's look at each of
those cases in particular.

00:28:55.030 --> 00:28:57.580
First one, CFStream event open completed.

00:28:57.580 --> 00:29:00.940
There's usually not a lot you
want to do it when open completed.

00:29:00.940 --> 00:29:03.770
It's just sort of a nice milestone
to know that the stream is

00:29:03.920 --> 00:29:05.040
progressing in its lifetime.

00:29:05.040 --> 00:29:06.800
So I'm just going to print that out.

00:29:06.800 --> 00:29:08.120
The open's completed.

00:29:11.200 --> 00:29:12.000
End Encountered.

00:29:12.180 --> 00:29:14.840
Now the stream has reached
the end of its lifetime.

00:29:14.840 --> 00:29:18.560
I'm going to print out all done,
and then go on to clean up the stream.

00:29:25.450 --> 00:29:27.780
In the error case,
I'm going to want to do

00:29:27.780 --> 00:29:29.660
some kind of error handling.

00:29:29.660 --> 00:29:33.250
I can get the error that's
occurred back from the stream

00:29:33.420 --> 00:29:38.500
by calling CFReadStreamGetError,
and then I'm going off into handle error,

00:29:38.500 --> 00:29:42.350
some error handling
routine that I've written.

00:29:42.610 --> 00:29:44.620
Again, the stream is done at this point.

00:29:44.760 --> 00:29:46.880
Once a stream's errored out,
you can't recover.

00:29:46.880 --> 00:29:48.690
So I'm going to clean up this stream.

00:29:52.200 --> 00:29:56.770
And now on to the more interesting one,
the has bytes available.

00:29:56.770 --> 00:30:01.190
This is where the most interesting work
is going to be done in your callback.

00:30:03.310 --> 00:30:05.770
Before dealing with that middle code,
I'm going to jump to the end.

00:30:05.790 --> 00:30:10.360
Every time I enter this callback,
I want to get the bytes out of the

00:30:10.360 --> 00:30:13.040
stream that have been reported.

00:30:13.120 --> 00:30:16.940
I do that by calling CFReadStreamRead,
pass in a buffer in

00:30:17.030 --> 00:30:18.820
the size of the buffer.

00:30:19.200 --> 00:30:25.550
That causes the stream to copy in all of
the bytes that it has into your buffer,

00:30:25.550 --> 00:30:30.700
and just like the POSIX read call,
it returns to you the number

00:30:30.700 --> 00:30:30.840
of bytes that it's filled.

00:30:31.050 --> 00:30:32.620
And then I can handle those body bytes.

00:30:32.660 --> 00:30:37.040
Again, all of the HTTP headers,
all of the HTTP control

00:30:37.040 --> 00:30:38.310
data has been stripped out.

00:30:38.510 --> 00:30:43.600
All you're receiving here are the raw
data bytes carried by the HTTP response.

00:30:46.570 --> 00:30:53.410
But often, you will have some special
processing that you want to do when

00:30:53.520 --> 00:30:55.580
you first get the response header.

00:30:55.720 --> 00:31:00.040
So the way you do that is the first
time you receive has bytes available,

00:31:00.040 --> 00:31:02.360
you know,
you're receiving the first data byte,

00:31:02.360 --> 00:31:04.270
so the header itself must be complete.

00:31:04.320 --> 00:31:07.930
Go to the stream and ask
for the response header.

00:31:07.940 --> 00:31:12.280
Copy property, KCF stream property,
HTTP response header.

00:31:13.640 --> 00:31:15.190
That's an HTTP message ref.

00:31:15.260 --> 00:31:17.840
You can examine it,
look at what has happened,

00:31:17.840 --> 00:31:21.490
and here I'm calling process
headers just to represent that work.

00:31:21.560 --> 00:31:25.240
Then when you're done,
copy property has the word copy in it,

00:31:25.330 --> 00:31:26.850
so you received a reference.

00:31:26.910 --> 00:31:30.260
Make sure to release that
reference by calling CF release.

00:31:33.900 --> 00:31:35.760
That's it for handle event.

00:31:35.790 --> 00:31:39.400
Now the last stage is
cleaning up the stream.

00:31:39.800 --> 00:31:42.200
I have gone into kind
of painful detail here.

00:31:42.200 --> 00:31:45.380
Often in your own code,
you will only need to do

00:31:45.380 --> 00:31:48.270
two or three of these steps,
but I want to walk you through all of

00:31:48.270 --> 00:31:56.180
them and explain what each one is doing,
and then depending on your situation,

00:31:56.180 --> 00:31:56.180
you will use some of these
and maybe not others.

00:31:56.960 --> 00:32:00.270
The first thing you may want to
do is call CF Read Stream Close.

00:32:00.420 --> 00:32:05.720
That is your cue to the stream that it
can release all of its system resources.

00:32:05.720 --> 00:32:09.890
You are done using the
stream to transfer bytes.

00:32:13.070 --> 00:32:16.980
Now I want to guarantee that the stream
never triggers my callback again.

00:32:17.030 --> 00:32:20.590
I want it to forget all knowledge
it has about my info pointer

00:32:20.590 --> 00:32:22.120
and my callback function.

00:32:22.140 --> 00:32:28.020
Set client HTTP stream, no events,
no callback, no info pointer.

00:32:33.170 --> 00:32:36.170
Now I need to scrub the read
stream off the run loops so that

00:32:36.380 --> 00:32:39.360
even though it's not calling me,
it's not causing the run

00:32:39.360 --> 00:32:40.410
loops to spin at all.

00:32:40.590 --> 00:32:44.290
On schedule from run loop,
I pass the same run loop and the same

00:32:44.330 --> 00:32:46.740
modes I used when I first scheduled.

00:32:46.740 --> 00:32:48.630
Current run loop, common modes.

00:32:48.640 --> 00:32:54.750
Finally,
I release our reference to the stream.

00:32:59.810 --> 00:33:03.390
So that's the most common
usage of HTTP streams,

00:33:03.390 --> 00:33:07.110
but there is this other case
that comes up from time to time.

00:33:07.110 --> 00:33:11.800
Sometimes you're going to
want to send an HTTP request

00:33:11.800 --> 00:33:15.240
where the body is very large,
larger than you want to

00:33:15.360 --> 00:33:16.770
hold inside of memory.

00:33:17.280 --> 00:33:22.640
Well, as you just saw,
when we called CF Readstream create HTTP,

00:33:22.700 --> 00:33:29.020
we were creating from an HTTP request
which had the body already attached.

00:33:29.090 --> 00:33:32.660
So in that case,
the body was resident in memory.

00:33:33.880 --> 00:33:36.310
If you don't want to
put the body in memory,

00:33:36.310 --> 00:33:38.200
use this function instead.

00:33:38.200 --> 00:33:40.900
Create for streamed HTTP request.

00:33:40.900 --> 00:33:46.130
And what you're going to do is provide a
read stream that provides the body data.

00:33:48.500 --> 00:33:52.390
When you open the stream,
it will transmit the headers

00:33:52.420 --> 00:33:55.640
and then automatically open the
stream you provided and start

00:33:55.700 --> 00:33:57.200
sending body bytes from it.

00:33:58.660 --> 00:34:00.840
There are a couple gotchas.

00:34:00.850 --> 00:34:05.610
If you provide a content length
inside of the request headers,

00:34:05.610 --> 00:34:07.160
it had better be correct, basically.

00:34:07.160 --> 00:34:09.900
Otherwise, that's going to screw up
the HTTP transmission.

00:34:11.640 --> 00:34:15.810
Also, because we have no way of
backing up your body stream,

00:34:16.060 --> 00:34:19.080
we cannot perform automatic
redirection in this case.

00:34:19.080 --> 00:34:23.120
We couldn't somehow unroll
the HTTP body content.

00:34:26.700 --> 00:34:30.040
And that's all I had about HTTP services.

00:34:30.110 --> 00:34:33.860
Now I'm going to invite Jeremy Wyld
up onto the screen to talk about

00:34:33.930 --> 00:34:36.320
Rendezvous and Network Services.

00:34:43.300 --> 00:34:46.570
So today I want to talk
about network services,

00:34:46.660 --> 00:34:51.710
what they are,
and how they pertain to CFNetwork.

00:34:53.320 --> 00:35:03.280
Think of network services as a method for
advertising a service by name and type,

00:35:03.310 --> 00:35:05.670
much like MBP did.

00:35:05.780 --> 00:35:10.840
on a domain on the network,
much like AppleTalk's zones.

00:35:10.840 --> 00:35:12.140
How do we do this?

00:35:12.140 --> 00:35:15.240
This great new technology
called rendezvous or zero

00:35:15.300 --> 00:35:17.820
configuration networking.

00:35:17.820 --> 00:35:22.280
This is brand new in Jaguar,
and it provides a local networking

00:35:22.460 --> 00:35:27.770
protocol that's simple to use,
like AppleTalk was, but it's also

00:35:28.340 --> 00:35:31.800
It's built upon industry standards.

00:35:31.800 --> 00:35:34.660
In order to get the nitty-gritty of this,
I'd really invite you to go

00:35:34.660 --> 00:35:39.530
to session 811 on Thursday and
really find out what we do there.

00:35:41.940 --> 00:35:46.140
So what does Xero
Configuration provide for you?

00:35:46.210 --> 00:35:49.630
It provides a standard for
advertising services on the network.

00:35:49.710 --> 00:35:52.900
It's a name-based registration.

00:35:52.900 --> 00:35:59.330
You provide a name, a type,
and it supports TCP and UDP.

00:35:59.450 --> 00:36:03.850
And then finally,
you can register on any domain,

00:36:03.850 --> 00:36:08.610
so you're not stuck to a
single registration domain.

00:36:08.640 --> 00:36:13.060
It also provides a standard for
discovering services on the network,

00:36:13.060 --> 00:36:15.530
and on top of that,
for discovering topology

00:36:15.900 --> 00:36:19.820
about the network,
other domains that exist on the network,

00:36:19.820 --> 00:36:24.240
so you can find out about those
other zones or domains that exist.

00:36:26.690 --> 00:36:31.370
So what did we do for
CFNetwork with this?

00:36:31.870 --> 00:36:33.600
Well, we created CFNet Services.

00:36:33.600 --> 00:36:37.530
We've abstracted two different types.

00:36:37.590 --> 00:36:43.170
We've created Net Services and
Net Service Browsers.

00:36:43.800 --> 00:36:49.020
A net service represents the single
service provider on the network.

00:36:50.840 --> 00:36:55.630
Some of the attributes for that service:
your domain, your type of service

00:36:55.630 --> 00:36:59.700
that you're providing,
your name of your service,

00:36:59.850 --> 00:37:03.180
its address or addresses,
and then what port your

00:37:03.180 --> 00:37:05.480
service is listening on.

00:37:06.470 --> 00:37:10.520
The Network Service Browser then
represents a search for either

00:37:10.520 --> 00:37:15.290
services or domains on the network,
one or the other.

00:37:17.000 --> 00:37:20.980
With these two types,
they both follow the same

00:37:21.550 --> 00:37:25.940
CF type stream usage model.

00:37:25.940 --> 00:37:27.970
You're going to create them

00:37:28.200 --> 00:37:31.010
You're going to schedule
them on a run loop.

00:37:31.020 --> 00:37:32.740
You're going to tell them to run.

00:37:32.780 --> 00:37:34.820
And then, finally,
you just sit back and wait to handle

00:37:34.820 --> 00:37:36.880
the callbacks when these things occur.

00:37:36.880 --> 00:37:41.630
So,
what do you do with these two objects?

00:37:43.290 --> 00:37:45.660
Well, there's three main things that
you're going to want to do.

00:37:45.670 --> 00:37:49.230
You're going to either want
to advertise your service that

00:37:49.360 --> 00:37:52.410
you've created on the network,
or you're going to want to

00:37:52.410 --> 00:37:52.410
advertise your service that
you've created on the network.

00:37:52.620 --> 00:37:56.420
You're going to want to find
services on the network.

00:37:56.420 --> 00:38:01.880
Thirdly, you're going to want to resolve,
connect to, use that service.

00:38:01.880 --> 00:38:08.900
What I'm going to do is walk through a
simple application that's meant to be

00:38:09.480 --> 00:38:12.910
just an Echo server and then a client.

00:38:13.050 --> 00:38:15.560
I'm going to walk through this code,
and we're going to do

00:38:15.560 --> 00:38:18.550
each one of these things.

00:38:18.620 --> 00:38:22.470
First off,
let's start with advertising the service.

00:38:23.610 --> 00:38:26.760
So, just like the usage
pattern I stated earlier,

00:38:26.790 --> 00:38:28.760
we create the service.

00:38:28.760 --> 00:38:30.380
We create our object.

00:38:30.380 --> 00:38:33.060
In this case,
creating it with the default allocator.

00:38:33.060 --> 00:38:35.140
We're going to, we're going to

00:38:35.320 --> 00:38:37.580
Create it on the default domain.

00:38:37.580 --> 00:38:41.340
This is indicated by the empty string.

00:38:42.500 --> 00:38:47.550
I'm registering a service
of the echo type over TCP.

00:38:48.940 --> 00:38:50.760
The name of my service.

00:38:50.800 --> 00:38:54.920
This may have either come
from the system control panel,

00:38:54.920 --> 00:38:58.920
where the person set their name,
or maybe I've prompted the user for it,

00:38:58.920 --> 00:39:02.920
or, however, you know,
I just formulated this, pass it along.

00:39:02.920 --> 00:39:05.800
This is a CFString,
can be formulated however you wish.

00:39:06.240 --> 00:39:08.240
Finally, what port I'm listening on.

00:39:08.240 --> 00:39:12.110
Now in this example, I'm listening on the
well-known port for echo,

00:39:12.160 --> 00:39:13.880
which is seven.

00:39:14.760 --> 00:39:18.000
Had I been using a real socket,
what I could have done

00:39:18.000 --> 00:39:20.280
is queried the socket,
asked it for its local port,

00:39:20.450 --> 00:39:21.490
and then used it instead.

00:39:21.510 --> 00:39:25.000
That's one of the
beauties behind CFNetwork.

00:39:25.320 --> 00:39:29.440
The Rendezvous Protocol is that this
port is no longer going to be important.

00:39:29.440 --> 00:39:33.230
What is important is the name and the
service type that we're registering.

00:39:35.560 --> 00:39:39.740
Next, in the usage model,
we schedule it on the run loop.

00:39:39.740 --> 00:39:42.690
We've set the client,
so I'm setting a callback,

00:39:42.820 --> 00:39:48.360
so my register callback, this context,
which is going to hold my

00:39:48.420 --> 00:39:52.660
refcon and some functions,
I schedule it on the run loop.

00:39:53.140 --> 00:39:57.030
Scheduling it on the current
run loop in common modes,

00:39:57.030 --> 00:39:58.900
just like streams.

00:40:00.460 --> 00:40:02.400
Finally, I tell it to run.

00:40:02.400 --> 00:40:05.000
In this case,
we're telling it to register.

00:40:05.000 --> 00:40:08.060
This is going to go out,
register the service on the network.

00:40:08.140 --> 00:40:11.220
We pass along the service
that we want to register,

00:40:11.220 --> 00:40:14.980
we pass along a reference
to an error struct.

00:40:14.990 --> 00:40:19.630
Should an error occur as a process
of starting up the registration,

00:40:19.790 --> 00:40:22.120
we can find out about it this way.

00:40:22.120 --> 00:40:26.280
Now, registration and some of these
other functions that I'm going to

00:40:26.280 --> 00:40:29.720
show are inherently asynchronous.

00:40:29.720 --> 00:40:33.280
In this case, we're registering.

00:40:33.280 --> 00:40:36.590
You can assume at this point you
are registered on the network.

00:40:36.880 --> 00:40:41.160
You can assume so until you
hear back on your callback.

00:40:42.590 --> 00:40:45.390
And for registration,
your callback will get

00:40:45.560 --> 00:40:47.090
called for one reason.

00:40:47.090 --> 00:40:49.010
There's been an error.

00:40:50.910 --> 00:40:54.740
There's really one important
error situation that you really

00:40:54.740 --> 00:40:59.980
want to make sure you handle,
and that is that there's been a

00:40:59.980 --> 00:41:01.800
name collision on the network.

00:41:02.220 --> 00:41:05.500
So at this point, what you want to do is
formulate a new name,

00:41:05.500 --> 00:41:07.800
or maybe you just want to quit.

00:41:07.800 --> 00:41:09.620
I'd suggest formulating a new name.

00:41:10.910 --> 00:41:15.800
So, you can formulate a name either by
something as simple as adding a number

00:41:15.920 --> 00:41:21.700
to the end of your name that you used,
you know, adding a two or a three,

00:41:21.700 --> 00:41:23.480
whatever, at the end.

00:41:23.480 --> 00:41:26.800
Or you can prompt the user again,
ask them for a new name,

00:41:26.800 --> 00:41:28.440
choose a different name,
that one's already

00:41:28.490 --> 00:41:29.820
existing on the network.

00:41:29.820 --> 00:41:34.380
And then we just go about trying
to register the service again.

00:41:34.380 --> 00:41:38.920
Either way,
we have to kill off our old service.

00:41:39.400 --> 00:41:42.360
So we know it off just
like we do streams.

00:41:42.360 --> 00:41:44.540
We make sure we pull it off the run loop.

00:41:44.540 --> 00:41:46.460
We go ahead and release the service.

00:41:46.530 --> 00:41:48.030
The service is gone at that point.

00:41:48.190 --> 00:41:51.710
You're no longer
registered on the network.

00:41:52.000 --> 00:41:57.700
[Transcript missing]

00:41:57.800 --> 00:42:00.820
We have a service sitting out there,
but people are going to want

00:42:00.820 --> 00:42:03.180
to be able to use your service.

00:42:03.270 --> 00:42:05.700
It doesn't do much good to
create a service if you don't

00:42:06.120 --> 00:42:07.700
have people feeding on it.

00:42:07.890 --> 00:42:12.160
What we want to do is find
services on the network.

00:42:12.310 --> 00:42:14.320
Once again, same usage model.

00:42:14.320 --> 00:42:16.900
We create our object.

00:42:16.900 --> 00:42:21.600
In this case, we're creating a browser
instead of a service.

00:42:22.200 --> 00:42:26.510
Create with the allocator.

00:42:26.520 --> 00:42:30.700
We're giving it a callback
function and our context.

00:42:31.500 --> 00:42:36.190
The callback function is part
of the creation because we

00:42:36.210 --> 00:42:38.220
have to do these callbacks.

00:42:38.220 --> 00:42:43.610
We have to be able to inform
you that services exist,

00:42:43.610 --> 00:42:46.400
or domains exist, on the network.

00:42:46.400 --> 00:42:50.210
It's a part of the object's nature.

00:42:51.090 --> 00:42:54.650
Finally, the context I'm passing in,
you'll notice on my context

00:42:54.840 --> 00:42:58.000
that I'm using a mutable array.

00:42:58.000 --> 00:43:00.280
The reason being that
as services come in,

00:43:00.600 --> 00:43:03.440
I'm going to add them
to this cached list,

00:43:03.440 --> 00:43:05.000
or array of services.

00:43:05.130 --> 00:43:08.000
When I find services,
I'm going to put them in this list.

00:43:08.000 --> 00:43:11.990
When they go away,
I'll take them out of the list.

00:43:12.650 --> 00:43:17.180
And because I'm using a standard CF type,
I can use CF retain, CF release,

00:43:17.180 --> 00:43:22.580
and CF copy description
for my context functions.

00:43:23.150 --> 00:43:28.630
So at this point, we go ahead,
register it on the run loop,

00:43:28.630 --> 00:43:28.630
and then we're going to

00:43:33.900 --> 00:43:37.910
Registring on the current
run loop in the common modes.

00:43:37.910 --> 00:43:40.100
Finally, we tell it to run.

00:43:41.810 --> 00:43:46.370
So in this case,
we're telling it to search for services.

00:43:46.420 --> 00:43:49.200
We're telling it to search for services,
again, in a local domain,

00:43:49.200 --> 00:43:51.080
indicated by the empty string.

00:43:51.110 --> 00:43:54.240
We're searching for echo TCP types.

00:43:54.980 --> 00:43:57.720
And once again,
pass along a reference to our error

00:43:57.790 --> 00:44:02.260
struct just in case an error occurs as
a process of starting up the search.

00:44:02.260 --> 00:44:06.180
Had I wished to find out
about network topology,

00:44:06.180 --> 00:44:10.040
I could have replaced this with a
call for search for domains instead.

00:44:10.040 --> 00:44:14.090
And then I can search and find out
other domains that exist on the network.

00:44:16.110 --> 00:44:19.730
So we have this service
registered on the network.

00:44:20.080 --> 00:44:22.650
We have someone else looking for it.

00:44:22.990 --> 00:44:25.040
Eventually,
a user is going to find what they want.

00:44:25.280 --> 00:44:26.040
Oh, sorry.

00:44:26.460 --> 00:44:28.580
I better tell you about the callback.

00:44:28.680 --> 00:44:32.110
We find the services on the network.

00:44:32.120 --> 00:44:35.390
Like I said before,
we're going to add and remove

00:44:35.420 --> 00:44:37.080
them from our cache list.

00:44:40.240 --> 00:44:43.560
When your callback gets called,
you're going to get called with

00:44:43.560 --> 00:44:47.300
the browser that you created.

00:44:47.510 --> 00:44:54.370
There's going to be a set of bit
flags indicating many specific things.

00:44:55.230 --> 00:44:57.700
The type of thing that you found.

00:44:57.700 --> 00:44:59.860
In this case,
we're searching for services,

00:44:59.860 --> 00:45:02.100
so we know we're going
to be receiving services.

00:45:02.100 --> 00:45:08.910
Had this been a search for domains,
we'd be receiving domain strings instead.

00:45:08.920 --> 00:45:14.230
And finally, the error pointer,
indicating an error if one occurs,

00:45:14.230 --> 00:45:17.620
or an info pointer, or your info pointer.

00:45:19.700 --> 00:45:24.200
In this case,
we check to see whether we're removing

00:45:24.200 --> 00:45:26.420
an item or being told to add an item.

00:45:26.420 --> 00:45:28.990
This is indicated by
one of those bit flags.

00:45:29.070 --> 00:45:32.910
Check to see whether we're
removing it or adding it and do so.

00:45:34.820 --> 00:45:39.070
And then, finally,
we have this nice little flag down

00:45:39.090 --> 00:45:41.700
here called KCFNetService More Coming.

00:45:41.700 --> 00:45:47.170
This is used

00:45:47.790 --> 00:45:52.120
If you're on a large network,
you're receiving hundreds of

00:45:52.120 --> 00:45:56.420
services from the network,
or lots of domains.

00:45:56.420 --> 00:45:59.710
Instead of having one of those apps
out there that flickers every time

00:45:59.710 --> 00:46:03.190
you receive one of these things,
trying to do an update,

00:46:03.190 --> 00:46:08.050
what we'll do is we'll indicate
with everyone that one's coming,

00:46:08.050 --> 00:46:10.980
unless we know that one is not.

00:46:11.050 --> 00:46:15.020
If we get to the end of the list,
what we can do is turn around and say,

00:46:15.020 --> 00:46:15.020
"Hey, I'm going

00:46:15.330 --> 00:46:17.960
Let's not pass along that flag.

00:46:17.960 --> 00:46:20.790
And now you can detect that, oh,
this means that I can

00:46:20.790 --> 00:46:21.960
finally do the update.

00:46:22.130 --> 00:46:28.670
I can inform the user that it's okay,
and they see their full list.

00:46:30.650 --> 00:46:35.080
So we've got one application
registering a service.

00:46:35.100 --> 00:46:38.580
We've got another one
finding these services.

00:46:38.580 --> 00:46:43.290
Now we need to go out, connect to,
and use that service.

00:46:43.820 --> 00:46:49.390
We do this very similar to the
way we register our service.

00:46:49.880 --> 00:46:51.800
Once again, we create it.

00:46:51.800 --> 00:46:56.900
It looks very similar to the
way we did the registration.

00:46:58.000 --> 00:47:03.910
We're creating a service, local domain,
Echo TCP,

00:47:04.670 --> 00:47:08.970
The name of the service that we found,
but you'll notice this

00:47:08.970 --> 00:47:13.220
time I'm passing in a zero,
because in this case the

00:47:13.220 --> 00:47:15.360
port is not important.

00:47:15.400 --> 00:47:18.100
We're going to ask the
network for this information.

00:47:18.100 --> 00:47:21.540
We want to get the address and port of
this machine that we're going to talk to.

00:47:24.780 --> 00:47:28.460
We register and put it on the run loop,
and then we tell it to resolve.

00:47:28.460 --> 00:47:34.460
Very similar to the registration,
we're just going to ask the

00:47:34.460 --> 00:47:38.930
network now for that other
machine's network address and port.

00:47:40.360 --> 00:47:46.540
At some point, hopefully it finds it,
or it'll get a network error.

00:47:46.720 --> 00:47:49.900
But the thing to note is that
this is an asynchronous call.

00:47:50.010 --> 00:47:52.800
It's not meant to necessarily complete.

00:47:52.820 --> 00:47:57.960
I can say, find my printer that I've
been using for months,

00:47:57.960 --> 00:47:57.960
and

00:47:58.190 --> 00:48:01.350
But because someone walked by
it and decided to turn it off,

00:48:01.350 --> 00:48:04.590
I may not see it,
and I'm going to tell it to go print.

00:48:07.700 --> 00:48:09.970
All of a sudden I realize
it's not finding it.

00:48:10.150 --> 00:48:16.620
I can go down, flip on the printer,
come back, it's found it.

00:48:17.080 --> 00:48:19.390
So at some point in the future,
you're going to get your callback.

00:48:20.040 --> 00:48:22.050
Hopefully, you'll be told that
there's been no error.

00:48:22.050 --> 00:48:24.500
It's returned an address.

00:48:26.570 --> 00:48:28.800
So what do you do now?

00:48:28.800 --> 00:48:32.770
Well,
you ask the NetService for its address.

00:48:33.130 --> 00:48:36.490
The one important thing to note here
is that when you ask for the address,

00:48:36.520 --> 00:48:39.710
it's going to return a list of addresses.

00:48:39.900 --> 00:48:43.550
You've got to remember that
these are multi-homing machines,

00:48:43.860 --> 00:48:44.560
right?

00:48:44.560 --> 00:48:46.800
So they can have multiple addresses.

00:48:47.120 --> 00:48:50.880
In this thing, in this example,
I'm doing one nasty thing in that

00:48:51.070 --> 00:48:53.810
I'm grabbing the first address,
and I'm going to try

00:48:53.810 --> 00:48:55.520
connecting to it and it only.

00:48:55.520 --> 00:48:58.280
I would suggest you do
something a little better.

00:48:59.750 --> 00:49:05.040
So in this case, I'm going to get the
address that we want.

00:49:05.230 --> 00:49:09.340
I'm going to pass along to a routine
to connect the socket and do whatever

00:49:09.340 --> 00:49:11.880
protocol work it needs to do.

00:49:12.190 --> 00:49:15.400
Had there been an error,
of course I want to go ahead

00:49:15.400 --> 00:49:16.800
and destroy the resolve.

00:49:16.800 --> 00:49:19.710
It didn't work.

00:49:19.800 --> 00:49:22.450
Remove ourselves as a client,
remove it from the run loop,

00:49:22.620 --> 00:49:24.780
go ahead and release it, and it's gone.

00:49:27.280 --> 00:49:32.490
So everything that I've shown has
been the asynchronous usage model,

00:49:32.720 --> 00:49:35.810
but sometimes that doesn't
always work in your applications.

00:49:37.110 --> 00:49:40.140
Well, we support other threading models.

00:49:40.140 --> 00:49:46.270
So you can do a synchronous
usage of CFNet services.

00:49:47.710 --> 00:49:50.750
The difference being that don't
schedule yourself on a run loop.

00:49:50.860 --> 00:49:53.740
Don't set the client.

00:49:53.850 --> 00:49:54.550
Don't set the run loop.

00:49:54.680 --> 00:49:57.320
You're now synchronous
instead of asynchronous.

00:49:59.690 --> 00:50:01.850
Browser is still going
to require a callback.

00:50:01.980 --> 00:50:05.110
It has to be able to inform you that
these things are found on the network.

00:50:05.210 --> 00:50:07.760
It needs to know how to
contact you to tell you that.

00:50:10.180 --> 00:50:13.920
All the functions that run
and perform will now block.

00:50:13.920 --> 00:50:18.370
So register, resolve,
browser search for services,

00:50:18.430 --> 00:50:21.840
and browser search for
domains are now blocking.

00:50:21.840 --> 00:50:25.410
And they will block indefinitely until,
in the case of a register,

00:50:25.410 --> 00:50:26.760
an error occurs.

00:50:26.760 --> 00:50:31.020
In the case of a resolve,
an error occurs or it finds an address.

00:50:31.110 --> 00:50:33.280
And then finally,
search for domains and search

00:50:33.370 --> 00:50:38.700
for services will go indefinitely
until they're canceled.

00:50:40.460 --> 00:50:46.050
So, at this point,
we'd like to show you some code

00:50:46.280 --> 00:50:52.500
and a demo of an application
that was taken from the examples,

00:50:52.500 --> 00:50:55.860
developer examples app kit,
and they're two things.

00:50:55.890 --> 00:50:58.210
They're called picture sharing
and picture sharing browser.

00:50:58.210 --> 00:51:01.580
And, we're going to go ahead and

00:51:02.060 --> 00:51:05.150
What we've done is taken
the code that they used,

00:51:05.310 --> 00:51:11.260
which uses the foundation form of
CFNet services and SNet services,

00:51:11.260 --> 00:51:15.540
and a raw socket to transfer
a picture from a sharing

00:51:16.160 --> 00:51:17.950
device to a browsing device.

00:51:17.990 --> 00:51:23.160
What we've done is gone and filled
that all with CFNetwork instead.

00:51:23.160 --> 00:51:29.510
We're using CFStreams, CFHTTP messages,
and CFNet services.

00:51:30.260 --> 00:51:35.160
So the first thing that we're
going to do is we're going

00:51:35.250 --> 00:51:44.660
to walk through the browser,
the client application,

00:51:44.660 --> 00:51:44.660
and we're going to show CFNet services,

00:51:45.540 --> 00:51:49.870
Browsing for them, resolving them,
HTTP to actually connect to

00:51:50.000 --> 00:51:52.700
the server and pull them down.

00:51:52.700 --> 00:51:57.040
So, first thing what we're going
to do is create a new browser.

00:51:57.610 --> 00:52:01.340
Like I said before,
NetService Browser Create,

00:52:01.380 --> 00:52:03.860
default allocator,
passing along a browser

00:52:03.860 --> 00:52:07.140
callback in our context,
which happens to be ourself.

00:52:07.280 --> 00:52:09.450
This is a nice Cocoa app.

00:52:10.510 --> 00:52:13.630
If it successfully created it,
get the run loop,

00:52:13.810 --> 00:52:16.200
we're going to schedule it,
and we're going to start

00:52:16.280 --> 00:52:17.390
a search for services.

00:52:17.390 --> 00:52:21.980
Now, we're searching for HTTP services.

00:52:23.150 --> 00:52:30.500
So we can have running on this
machine services which handle HTTP,

00:52:30.500 --> 00:52:33.300
but they're not running
as part of a browser.

00:52:33.300 --> 00:52:34.720
They're not Apache.

00:52:34.720 --> 00:52:36.370
They're some other application.

00:52:36.650 --> 00:52:40.360
And I don't have to tell my
grandmother what port to go to.

00:52:40.360 --> 00:52:42.500
We're going to find it on the network.

00:52:42.570 --> 00:52:44.300
So we create our browser.

00:52:44.300 --> 00:52:46.160
We scheduled it.

00:52:46.380 --> 00:52:47.700
We're going to tell
it to search for them,

00:52:48.100 --> 00:52:51.300
and at some point,
we're going to get callbacks on

00:52:51.300 --> 00:52:52.600
our browser callback function.

00:52:56.090 --> 00:52:59.720
So browser callback functions.

00:52:59.780 --> 00:53:03.120
Fires, we're going to be told,
looks like very similar code

00:53:03.160 --> 00:53:04.500
to what I showed earlier.

00:53:04.500 --> 00:53:08.360
We're going to be told to remove items,
or we're going to be told to add items.

00:53:08.360 --> 00:53:09.940
So in this case,
I'm going to tell my object to

00:53:09.950 --> 00:53:12.240
either remove or add the services.

00:53:12.280 --> 00:53:18.200
And those are just held in a list that
I then later display in a table view.

00:53:18.820 --> 00:53:21.430
At some point, I'm gonna be told that
there's no more coming,

00:53:21.490 --> 00:53:25.960
at which point I tell it to refresh,
reload the data, ListView's gonna update

00:53:26.140 --> 00:53:29.020
and populate itself,
and the user will be able to

00:53:29.020 --> 00:53:32.370
see everything that's in the
known list of items at that time.

00:53:34.630 --> 00:53:37.180
The user then sees that list.

00:53:37.180 --> 00:53:38.600
They're going to click on an item.

00:53:38.600 --> 00:53:41.600
They're going to click that service.

00:53:41.600 --> 00:53:45.500
So at this point,
we've got a list of services.

00:53:45.500 --> 00:53:47.720
These are actual CFNet service types.

00:53:47.740 --> 00:53:50.900
I've been holding those in a list,
so at this point what I can do is

00:53:51.190 --> 00:53:55.100
grab out the one that they clicked,
right.

00:53:55.100 --> 00:53:57.660
I'm pulling it out by index.

00:53:57.670 --> 00:54:01.980
I retain it just in case,
while I'm doing this other lookup stuff,

00:54:02.280 --> 00:54:03.450
this service goes away.

00:54:03.760 --> 00:54:06.270
I'm still holding a reference to it.

00:54:07.500 --> 00:54:10.840
So I'm going to retain it.

00:54:10.840 --> 00:54:14.990
I get its name so that I can
display a little status to the user,

00:54:15.000 --> 00:54:17.840
this is what we're looking for.

00:54:17.880 --> 00:54:19.760
We schedule it on the run loop.

00:54:19.900 --> 00:54:22.310
We tell it to go resolve.

00:54:24.720 --> 00:54:31.740
At a point in the future, hopefully,
we will be told that it resolved.

00:54:33.540 --> 00:54:36.360
At this point,
what we're going to do is ask the

00:54:36.360 --> 00:54:40.130
service for its list of addresses.

00:54:40.170 --> 00:54:42.770
It's going to come back with a list.

00:54:44.300 --> 00:54:46.700
I'm going to pull out, once again,
nasty code.

00:54:46.700 --> 00:54:49.540
I'm going to pull out the first one.

00:54:50.040 --> 00:54:54.950
And what these things are
inside the list of addresses are

00:54:54.950 --> 00:55:00.640
actual wrappers on SOC struct,
they're struct SOC adders.

00:55:01.230 --> 00:55:03.950
So, I'm gonna pull that out.

00:55:04.120 --> 00:55:09.260
I'm going to take the
IP address and more nasty code.

00:55:09.260 --> 00:55:14.360
I'm assuming AFInet opposed
to AFInet or AFInet6 for IPv6,

00:55:14.450 --> 00:55:17.470
because it can be either one.

00:55:18.070 --> 00:55:20.650
I'm going to create a
string for the dotted IP,

00:55:20.780 --> 00:55:26.020
then what I'm going to do is
create a URL based upon the IP.

00:55:26.020 --> 00:55:29.460
What we're going to do is
do an HTTP to that URL,

00:55:29.470 --> 00:55:33.760
along with the port number that
also came from the addressing.

00:55:33.770 --> 00:55:37.360
We're going to formulate that URL,
and then we're going to

00:55:37.380 --> 00:55:38.910
create an HTTP message.

00:55:39.010 --> 00:55:42.940
We're performing get request to the URL.

00:55:42.940 --> 00:55:46.090
We're doing one-oh HTTP.

00:55:48.170 --> 00:55:50.960
We're setting a header field
to indicate who we are.

00:55:50.960 --> 00:55:55.070
We are the user agent
picture sharing 1.0.

00:55:55.980 --> 00:56:02.150
We create our stream based upon that
HTTP request that we just formulated.

00:56:02.230 --> 00:56:05.300
At this point,
we schedule it on a run loop.

00:56:10.580 --> 00:56:11.450
We opened the stream.

00:56:11.500 --> 00:56:17.980
That would be all the way down here, huh?

00:56:18.330 --> 00:56:22.540
As part of setting the client,
we've set up our read events.

00:56:22.540 --> 00:56:27.780
In this case,
what we care about are read events,

00:56:27.780 --> 00:56:32.250
so when it has bytes available,

00:56:33.550 --> 00:56:36.840
When an error occurs,
and when it hits the end of the stream.

00:56:36.840 --> 00:56:41.440
So when there's no more
bytes of data to be read.

00:56:41.440 --> 00:56:44.400
So at some point in the future,
we're gonna get an event.

00:56:45.890 --> 00:56:50.180
If it has bytes available,
we're going to try reading off the bytes.

00:56:50.180 --> 00:56:52.960
The only case I care about
right here is if it succeeds.

00:56:52.960 --> 00:56:55.720
If it doesn't,
the event will still come through

00:56:55.720 --> 00:57:00.540
for whatever happened for the
error or if it hit the end.

00:57:00.540 --> 00:57:04.610
We're going to append the bytes to a
data buffer that we're building up.

00:57:05.340 --> 00:57:09.410
At some point, we may get the end,
or I assume we'll get the end,

00:57:09.710 --> 00:57:13.720
in which case that is the
entire image data that we've

00:57:13.720 --> 00:57:16.640
now received from the browser,
or the server.

00:57:16.640 --> 00:57:23.880
We build up an image from it,
we're going to put it

00:57:23.880 --> 00:57:23.880
into our image view,
and then display it.

00:57:26.050 --> 00:57:31.160
Had an error occurred,
we're going to stop the stream.

00:57:31.160 --> 00:57:35.580
In either case of reading
in the stream or the error,

00:57:35.610 --> 00:57:39.000
we're going to close down our stream.

00:57:39.000 --> 00:57:42.430
So to close a stream,
Becky showed it earlier,

00:57:42.490 --> 00:57:47.020
we remove ourselves as a client,
we unschedule ourselves

00:57:47.020 --> 00:57:50.190
from the run loop,
finally we close.

00:57:51.210 --> 00:57:54.540
So at this point,
let's show the application

00:57:54.550 --> 00:57:56.110
actually running.

00:57:56.110 --> 00:57:58.100
Here we have the browser.

00:57:58.120 --> 00:58:02.620
And in this case,
we have a server that's sitting there.

00:58:02.740 --> 00:58:03.920
It's not even running.

00:58:03.920 --> 00:58:06.300
On another machine we've
got three instances of the

00:58:06.300 --> 00:58:08.220
application sharing documents.

00:58:08.220 --> 00:58:11.340
You can see, we can click around,
we can see what those are.

00:58:11.800 --> 00:58:12.100
Right?

00:58:12.100 --> 00:58:17.920
And it's downloading a very large, like,
4 meg TIFF or something across the wire,

00:58:17.920 --> 00:58:21.480
over to this other machine, just appears.

00:58:21.650 --> 00:58:22.650
OK?

00:58:22.650 --> 00:58:22.650
So,

00:58:23.100 --> 00:58:28.760
You want to start yours up and see about
dragging on something from the browser,

00:58:28.760 --> 00:58:29.160
maybe?

00:58:29.160 --> 00:58:30.080
Sure.

00:58:30.080 --> 00:58:32.060
Oh, we just appeared, you can see.

00:58:32.060 --> 00:58:36.490
So she started it, goes away, comes back.

00:58:39.030 --> 00:58:39.360
Click it.

00:58:39.530 --> 00:58:42.060
There it is.

00:58:42.270 --> 00:58:44.690
Just to prove that we are, in fact,
doing HTTP,

00:58:44.720 --> 00:58:47.660
I'm going to copy the URL that
appears down here and give

00:58:47.660 --> 00:58:49.280
it to Internet Explorer.

00:58:53.360 --> 00:58:53.560
Ta-da!

00:58:53.560 --> 00:58:56.040
Internet Explorer can
get that same image,

00:58:56.040 --> 00:58:58.730
but better.

00:58:59.340 --> 00:59:03.100
Now I'm going to grab an
image here out of Google.

00:59:03.100 --> 00:59:05.900
I did the search a little earlier for
pictures of the Golden Gate Bridge.

00:59:05.900 --> 00:59:08.890
I'm just going to grab one.

00:59:11.280 --> 00:59:13.780
drag it into my server.

00:59:13.790 --> 00:59:16.300
Now let's get IE out of the way.

00:59:16.320 --> 00:59:19.710
And I'm going to ask it to
re-fetch this image for me.

00:59:23.800 --> 00:59:24.160
There we go.

00:59:24.160 --> 00:59:28.220
All right.

00:59:28.530 --> 00:59:33.590
Now, I just have a few closing slides,
and then we're going

00:59:33.590 --> 00:59:33.590
to move on to the Q&A.

00:59:35.370 --> 00:59:38.560
So to get more information about this,
you should look at the sample code

00:59:38.610 --> 00:59:40.800
in Developer Examples Networking.

00:59:40.800 --> 00:59:45.040
There's a simple Echo server and
client there that uses CFStream.

00:59:45.040 --> 00:59:48.320
There's also a little
application URL load that shows

00:59:48.380 --> 00:59:52.580
how you can use CFNetwork,
as well as NSURL or URL access

00:59:52.580 --> 00:59:55.270
to download URLs off the web.

00:59:56.350 --> 00:59:59.790
I'd also like to point you
at Developer Examples Cocoa,

00:59:59.790 --> 01:00:03.750
which includes the Cocoa versions of
the picture sharer that we just showed.

01:00:03.750 --> 01:00:08.280
There's also a subscription mailing
list hosted by DTS at Apple,

01:00:08.280 --> 01:00:11.630
macnetworkprog at lists.apple.com.

01:00:11.630 --> 01:00:13.890
If you subscribe to that,
you're more than welcome to

01:00:13.890 --> 01:00:15.140
send any questions there.

01:00:15.140 --> 01:00:18.210
Both Jeremy and I monitor that list,
and we'll happily

01:00:18.210 --> 01:00:19.870
respond to any questions.

01:00:23.200 --> 01:00:27.260
And then I want to just highlight again
the two sessions we talked about earlier.

01:00:27.260 --> 01:00:31.600
808, which talks about CFRunLoop and
CF Stream in much more detail

01:00:31.600 --> 01:00:33.240
than I was able to go into here.

01:00:33.240 --> 01:00:40.820
And then 811, for all of the deep,
dark secrets of zero-conf and rendezvous.

01:00:41.230 --> 01:00:45.270
And with that, oh, right,
also who to contact,

01:00:45.420 --> 01:00:49.290
Tom Weyer from Worldwide
Developer Relations will be

01:00:49.300 --> 01:00:50.960
happy to take your emails.

01:00:50.980 --> 01:00:53.500
Again, the subscription list.
WEBVTT

00:00:00.880 --> 00:00:05.800
and the Mac OS X evangelist,
Xavier Legros.

00:00:05.800 --> 00:00:11.800
Hi, everybody.

00:00:12.130 --> 00:00:16.790
Welcome to session 203,
Migrating to Carbon Events.

00:00:19.380 --> 00:00:22.760
This session is very important
for all Carbon developers,

00:00:22.760 --> 00:00:27.710
not because Carbon Events are very
important technology in Mac OS X,

00:00:27.710 --> 00:00:30.440
but because it's the start of the future.

00:00:30.540 --> 00:00:33.510
This session is the beginning where
we're going to be introducing brand

00:00:33.510 --> 00:00:35.300
new features for Carbon developers.

00:00:35.390 --> 00:00:37.410
And for that,
for you to take advantage of

00:00:37.410 --> 00:00:40.390
actually these new features
we're going to be bringing,

00:00:40.500 --> 00:00:43.490
you're going to have
to use Carbon Events.

00:00:44.090 --> 00:00:45.930
Today we're going to be
talking about a lot of things.

00:00:46.060 --> 00:00:48.820
We're going to help you understand
all the different steps for

00:00:48.820 --> 00:00:50.400
you to move to Carbon Events.

00:00:50.480 --> 00:00:53.360
And you have to understand
that this session is the

00:00:53.360 --> 00:00:55.070
base for you to move forward.

00:00:55.270 --> 00:00:57.880
and to talk about the future and
to talk about how you're going to

00:00:57.880 --> 00:01:00.880
be developing and how you're going
to be migrating to Carbon Events.

00:01:00.930 --> 00:01:04.080
I'd like to invite on stage Curt Rothert,
who actually has been working

00:01:04.080 --> 00:01:06.790
on the toolbox and will take
you on a step-by-step approach

00:01:07.170 --> 00:01:09.910
for migrating your application.

00:01:09.910 --> 00:01:09.910
Curt?

00:01:19.520 --> 00:01:21.690
So good afternoon, ladies and gentlemen.

00:01:21.770 --> 00:01:25.730
It is a pleasure to be here with
you to talk about Carbon Events.

00:01:26.350 --> 00:01:31.280
Carbon Events, in a nutshell,
is the event dispatching system

00:01:31.670 --> 00:01:33.760
in the high-level toolbox.

00:01:33.780 --> 00:01:37.390
It permeates every part of the toolbox,
and it has been designed

00:01:37.520 --> 00:01:43.000
specifically for performance,
extensibility, and modularity.

00:01:45.130 --> 00:01:47.690
So, what is this session about?

00:01:47.920 --> 00:01:51.680
First, I'm going to give you an overview
of the Carbon Event model so

00:01:51.680 --> 00:01:54.050
we can become familiar with it.

00:01:54.190 --> 00:01:57.410
and be comfortable with using it to
migrate your WaitNext Event-based

00:01:57.430 --> 00:02:00.620
application to Carbon Events.

00:02:02.740 --> 00:02:05.000
Who is this design for?

00:02:05.140 --> 00:02:08.600
Well, if you have an application that
you want to add new features to,

00:02:08.690 --> 00:02:13.600
if you're running--existing running
on OS 9 or OS X using WaitNext Event,

00:02:13.730 --> 00:02:16.160
and you want to take advantage of
new features or new technologies

00:02:16.160 --> 00:02:19.620
that are available on OS X,
this is for you.

00:02:19.790 --> 00:02:21.570
It's also if you want to
migrate your current event

00:02:21.710 --> 00:02:26.450
processing over to Carbon Events,
and also to be a good Mac OS X citizen in

00:02:26.450 --> 00:02:28.540
terms of performance and functionality.

00:02:31.110 --> 00:02:34.030
So you may be asking yourself,
"What benefits will I get by

00:02:34.120 --> 00:02:40.590
moving to Carbon Events?" Well,
importantly, it encourages a modular

00:02:40.590 --> 00:02:42.900
design in your application.

00:02:43.110 --> 00:02:47.090
That is, that you can incorporate
your event processing with

00:02:47.090 --> 00:02:50.010
your UI of your application.

00:02:50.060 --> 00:02:54.340
So if you work with different groups,
they can incorporate different modules,

00:02:54.340 --> 00:02:56.090
and you can put them
together with very few,

00:02:56.090 --> 00:02:58.100
if any, integration problems whatsoever.

00:02:58.100 --> 00:03:03.200
It's also compatible back to Mac OS 8.6
with the Carbon Lib shared library.

00:03:03.200 --> 00:03:07.630
It's important because the toolbox
can add new features for free.

00:03:07.640 --> 00:03:11.400
You benefit from standard features
that are available in the toolbox,

00:03:12.110 --> 00:03:15.890
And as new features are added,
you get those for free.

00:03:17.390 --> 00:03:21.850
It's also helpful because this
predictable behavior defined by Apple.

00:03:21.940 --> 00:03:25.260
Now, traditionally,
Apple has provided human interface

00:03:25.260 --> 00:03:27.960
guidelines that you would
have had to react to and put

00:03:27.960 --> 00:03:31.510
together into your application,
which makes your application's

00:03:31.590 --> 00:03:33.800
event processing part of your app.

00:03:33.880 --> 00:03:37.000
Well, using Carbon Events,
we have the responsibility of

00:03:37.000 --> 00:03:38.990
taking care of the event processing.

00:03:39.850 --> 00:03:45.810
and new features in Mac OS X and in the
high-level toolbox are Carbon Event only.

00:03:46.390 --> 00:03:48.740
There's also a number of
performance improvements.

00:03:48.850 --> 00:03:53.000
You may be asking yourself,
what kind of performance improvements?

00:03:53.120 --> 00:03:55.780
Well, it encourages no polling.

00:03:55.890 --> 00:03:57.930
Using WaitNextEvent,
you're sitting on one entry point,

00:03:58.140 --> 00:04:01.720
polling, trying to figure out if
an event has happened.

00:04:01.840 --> 00:04:04.300
With Carbon Events,
you no longer have to do that.

00:04:04.390 --> 00:04:05.650
It's a direct dispatching model.

00:04:05.840 --> 00:04:09.330
So when an event happens,
it's dispatched to your event handler,

00:04:09.450 --> 00:04:12.560
and you do the processing
that you need to do.

00:04:12.650 --> 00:04:14.740
In this way,
there's no dead-end event processing.

00:04:14.840 --> 00:04:17.820
And what I mean by that is,
let's say the user clicks in the

00:04:17.820 --> 00:04:20.430
menu bar to track down a menu,
and then they decide they don't

00:04:20.440 --> 00:04:21.550
want to select a menu item.

00:04:21.690 --> 00:04:23.840
So they track off and release.

00:04:23.990 --> 00:04:26.790
Using WaitNextEvent,
you would be getting that mouse down.

00:04:26.990 --> 00:04:29.450
You'd be asking the toolbox,
where was that mouse down,

00:04:29.500 --> 00:04:32.040
finding that it was in the menu bar,
and then telling the

00:04:32.080 --> 00:04:33.240
toolbox to track that.

00:04:33.330 --> 00:04:34.920
Well, the user drags off.

00:04:34.920 --> 00:04:36.980
They don't select any menu item.

00:04:37.160 --> 00:04:40.700
And your application was involved with
dispatching an event that did nothing.

00:04:40.850 --> 00:04:43.180
So Carbon Events gets away from that.

00:04:43.180 --> 00:04:47.180
And there are APIs that are
specifically designed for performance.

00:04:47.180 --> 00:04:50.730
And for a lot more information on that,
please go see Session 207,

00:04:51.100 --> 00:04:55.730
Performance with Carbon Events,
which is tomorrow in this hall at 3:30.

00:04:58.520 --> 00:05:00.320
So an important thing to know
about Carbon Events is you

00:05:00.370 --> 00:05:02.100
can migrate at your own pace.

00:05:02.180 --> 00:05:05.600
You can make incremental changes
in your application that help

00:05:05.600 --> 00:05:09.950
move off of WaitNextEvent
and go over to Carbon Events.

00:05:10.200 --> 00:05:13.510
Like I mentioned earlier,
it encourages a modular

00:05:13.510 --> 00:05:15.260
design in your application.

00:05:15.390 --> 00:05:19.090
So you can add new modules
to your application and not

00:05:19.090 --> 00:05:23.460
have your WaitNext Event code
affected by those changes.

00:05:26.630 --> 00:05:28.650
At this point,
I think it's important to look at

00:05:28.680 --> 00:05:33.160
the relationship between the look
and feel of a Mac OS application.

00:05:33.240 --> 00:05:37.060
Traditionally, the look is presented by
the appearance manager.

00:05:37.130 --> 00:05:40.100
The UI is drawn by that.

00:05:40.380 --> 00:05:44.030
And it's important to use the
Appearance Manager because it adds a

00:05:44.030 --> 00:05:46.350
layer of abstraction for the drawing.

00:05:46.360 --> 00:05:49.390
If you were always drawing your
custom controls every time,

00:05:49.400 --> 00:05:54.660
like the migration from OS 9 and
OS 8 using Platinum over to Aquon 10,

00:05:54.660 --> 00:05:55.730
it would have been very difficult.

00:05:55.830 --> 00:05:59.100
So it was facilitated by
using the Appearance Manager.

00:05:59.180 --> 00:06:02.440
Well, similarly,
the event processing using

00:06:02.440 --> 00:06:06.350
WaitNextEvent is limited in the
sense that we can't move forward,

00:06:06.490 --> 00:06:09.350
add new behaviors, add new functionality.

00:06:12.340 --> 00:06:18.880
So the toolbox has provided that,
just tools for you to add and

00:06:18.880 --> 00:06:21.540
make your own application,
such as different types of controls,

00:06:21.540 --> 00:06:23.650
push buttons, radio buttons, check boxes.

00:06:23.660 --> 00:06:26.160
You put all of those
into your application,

00:06:26.160 --> 00:06:29.160
and you're responsible for taking care
of what happens with those controls.

00:06:29.200 --> 00:06:33.170
Well, it's useful to think of
Carbon Events as a full framework.

00:06:33.190 --> 00:06:35.270
The framework for your
house is already built.

00:06:35.370 --> 00:06:37.880
All you need to do is plug into
the functionality that you're

00:06:37.940 --> 00:06:39.550
interested in benefiting from.

00:06:39.560 --> 00:06:44.900
So what does this mean
for an event-driven app?

00:06:46.350 --> 00:06:48.560
Well, with WaitNextEvent,
as I mentioned earlier,

00:06:48.670 --> 00:06:52.240
you have to process each event
and tell the toolbox what to do.

00:06:52.320 --> 00:06:54.420
Now, it's important to understand
that WaitNextEvent is based

00:06:54.420 --> 00:06:56.100
on top of Carbon Events.

00:06:56.210 --> 00:06:59.050
So any new functionality that
you add using Carbon Events won't

00:06:59.050 --> 00:07:00.590
affect your WaitNextEvent code.

00:07:00.680 --> 00:07:04.000
In fact, it will bypass-- if you
handle certain events,

00:07:04.000 --> 00:07:05.340
it won't even be returned
to WaitNextEvent.

00:07:05.340 --> 00:07:09.840
So you can take care of some event
processing on your own by bypassing that.

00:07:09.910 --> 00:07:12.690
And with Carbon Events,
the toolbox processes each event

00:07:13.130 --> 00:07:15.480
and then tells you what to do.

00:07:16.620 --> 00:07:18.500
So graphically, what's going on here?

00:07:18.530 --> 00:07:21.050
Is with WaitNextEvent, your application

00:07:22.310 --> 00:07:24.060
gets an event from the event loop.

00:07:24.170 --> 00:07:27.600
It figures out what to do with
many switch case statements,

00:07:27.600 --> 00:07:29.840
tries to figure out where
should I dispatch this to,

00:07:29.980 --> 00:07:34.290
dispatches it to your own handlers,
and then you tell the toolbox what to do.

00:07:36.860 --> 00:07:39.640
With Carbon Events,
you define a set of events that

00:07:39.680 --> 00:07:41.340
you're interested in receiving.

00:07:41.340 --> 00:07:43.300
You tell the toolbox about that.

00:07:43.440 --> 00:07:47.200
You get into the event loop,
which blocks,

00:07:47.360 --> 00:07:49.040
and the toolbox will dispatch events.

00:07:49.040 --> 00:07:51.770
And if it's an event that
you're interested in,

00:07:51.770 --> 00:07:54.800
it will call back into your
application's handlers,

00:07:54.800 --> 00:07:56.790
and you take care of the event.

00:07:59.110 --> 00:08:03.310
So because of this,
it encourages the event handling of your

00:08:03.310 --> 00:08:06.600
application to be part of the design.

00:08:06.670 --> 00:08:09.390
Like I mentioned earlier,
you can design all the functionality

00:08:09.400 --> 00:08:12.560
in a module that deals with the UI.

00:08:13.210 --> 00:08:15.880
for example, if you wanted to add a
new Inspector window,

00:08:15.910 --> 00:08:19.240
all of the event handling for that
window could be in the file or module

00:08:19.240 --> 00:08:21.900
that deals with the UI of that window.

00:08:21.900 --> 00:08:24.110
So you can take new modules,
plug them in,

00:08:24.110 --> 00:08:25.990
very few integration problems.

00:08:26.100 --> 00:08:29.960
And a lot of standard behaviors are
provided for free by the toolbox.

00:08:30.080 --> 00:08:34.550
But those behaviors can be
overrided by you to enhance it

00:08:34.550 --> 00:08:36.770
with your own functionality.

00:08:40.230 --> 00:08:43.960
So how are events
dispatched in the toolbox?

00:08:44.090 --> 00:08:48.330
As you can see in this image,
an event can go, like, let's say,

00:08:48.580 --> 00:08:51.460
for example,
that the user clicks in a control.

00:08:52.800 --> 00:08:56.800
If the control does not handle the event,
it gets propagated to its parent

00:08:56.800 --> 00:09:00.730
if it's in an embedded situation.

00:09:00.910 --> 00:09:04.160
If its parent doesn't handle the event,
it gets dispatched and

00:09:04.160 --> 00:09:05.900
falls down to the window.

00:09:06.000 --> 00:09:09.640
If the window doesn't handle it,
it propagates to the application.

00:09:09.710 --> 00:09:13.530
At that point, if it's not handled,
it gets returned via WaitNextEvent.

00:09:14.270 --> 00:09:18.540
So at any point along this,
you can install a handler,

00:09:18.660 --> 00:09:21.390
handle the event,
take care of your functionality.

00:09:21.400 --> 00:09:25.840
If you've handled the event,
the propagation stops processing.

00:09:25.920 --> 00:09:28.330
If you don't handle the event,
it drops down to the application

00:09:28.490 --> 00:09:31.300
and then out via WaitNextEvent,
if it makes sense for

00:09:31.410 --> 00:09:33.590
WaitNextEvent to return that event.

00:09:40.460 --> 00:09:43.300
So it's a hierarchical dispatching model.

00:09:43.390 --> 00:09:45.540
And because of that,
we can have standard handling,

00:09:45.540 --> 00:09:47.760
which comes for free.

00:09:47.860 --> 00:09:48.760
We have our handlers.

00:09:48.760 --> 00:09:52.020
The toolbox has its handlers
installed on particular targets,

00:09:52.070 --> 00:09:53.500
and it can take care of actions.

00:09:53.500 --> 00:09:57.160
You can override those,
or if it's not handled,

00:09:57.160 --> 00:10:00.740
it falls down out through WaitNextEvent.

00:10:00.830 --> 00:10:04.640
But you can modify the standard
behavior because handlers are stackable.

00:10:04.810 --> 00:10:06.710
Certain handlers are
provided by the toolbox,

00:10:06.850 --> 00:10:08.820
and you can stack your
handler on top of that.

00:10:08.860 --> 00:10:10.790
If you don't handle it,
it falls into the toolbox's

00:10:10.910 --> 00:10:12.910
domain to take care of.

00:10:14.400 --> 00:10:18.000
So first, let's go through a primer,
figure out what is this Carbon Event.

00:10:18.000 --> 00:10:20.570
So let's become
comfortable with using it.

00:10:21.030 --> 00:10:23.760
So I want to talk about the
data types and the APIs that

00:10:23.760 --> 00:10:25.240
are specific to Carbon Events.

00:10:25.350 --> 00:10:28.360
Now, all of these are in the
carbontevents.h header.

00:10:28.440 --> 00:10:32.450
So if you have your laptop,
you can pop it out and read it as we go.

00:10:33.880 --> 00:10:38.280
So I'll be talking about the
event type spec data structure,

00:10:38.380 --> 00:10:41.470
which indicates in the toolbox
what events you're interested in.

00:10:42.490 --> 00:10:46.590
I'll talk about the Event Ref type,
which is the main type of notification,

00:10:46.620 --> 00:10:50.200
how you are notified that
an event has happened.

00:10:51.360 --> 00:10:54.370
will talk about the Event Target Ref,
and this is where you install your

00:10:54.370 --> 00:10:57.310
handler and where events are sent to.

00:10:57.660 --> 00:11:00.870
and also an Event Handler Ref,
which is a reference to your

00:11:00.870 --> 00:11:03.350
installed Event Handler.

00:11:06.970 --> 00:11:09.980
So the event type spec is a
very simple data structure,

00:11:09.980 --> 00:11:12.940
which includes the event
class and the event kind.

00:11:13.070 --> 00:11:15.960
The event class is the high-level
class of the type of event.

00:11:16.150 --> 00:11:19.240
For example,
if an event happened in a control,

00:11:19.350 --> 00:11:22.340
it's K event class control.

00:11:22.460 --> 00:11:23.840
Or, no, yes.

00:11:23.910 --> 00:11:26.800
If it's in a window,
it's a K event class window.

00:11:26.920 --> 00:11:30.940
And then the event kind is a constant
indicating what kind of event that was.

00:11:30.950 --> 00:11:32.530
So if there was a mouse down,
for instance,

00:11:32.650 --> 00:11:36.600
that would be K event class mouse,
K event mouse down.

00:11:36.910 --> 00:11:39.640
And usually you're interested
in more than one type of event.

00:11:39.750 --> 00:11:42.060
So when you tell the toolbox
what events you're interested in,

00:11:42.060 --> 00:11:45.170
you pass it in as an array of this type.

00:11:49.850 --> 00:11:53.940
The Event Ref is an opaque data type.

00:11:54.020 --> 00:11:56.770
So when you need to get information
in or out of an Event Ref,

00:11:57.000 --> 00:11:59.330
you have to use accessors.

00:11:59.750 --> 00:12:02.810
and it can contain an arbitrary
amount of data in terms of

00:12:02.810 --> 00:12:06.890
the number of data types,
in terms of the size of the data,

00:12:06.890 --> 00:12:09.290
and in terms of the type of data.

00:12:09.470 --> 00:12:12.280
Now, this is important because
it's extremely extensible.

00:12:12.360 --> 00:12:14.130
In the future,
if we decide we want to add

00:12:14.140 --> 00:12:19.700
different data to a particular event,
we can go ahead and do that.

00:12:21.350 --> 00:12:24.600
and the data is referenced by
a parameter and a type pair.

00:12:24.600 --> 00:12:27.630
And all of this is in the
Carbonevents.h header.

00:12:27.830 --> 00:12:31.960
has a listing of what types of
parameters are in each particular

00:12:32.110 --> 00:12:35.600
event and what type of data
that is that you can get out.

00:12:36.500 --> 00:12:38.680
And also, it's a two-way street.

00:12:39.030 --> 00:12:41.240
Information can come
in with an Event Ref,

00:12:41.240 --> 00:12:43.990
and then you can set
information in that event,

00:12:44.070 --> 00:12:47.720
and when the toolbox gets that,
it can act on that as well.

00:12:51.610 --> 00:12:56.840
Each UI element has an event
target associated with it.

00:12:56.960 --> 00:13:01.960
So that's in terms of windows, controls,
menus, the application,

00:13:02.050 --> 00:13:05.440
even the user focus,
and the event dispatcher itself.

00:13:05.560 --> 00:13:08.000
This is where you install
your event handler.

00:13:08.000 --> 00:13:10.790
So if you're interested in
getting an event in a control,

00:13:10.930 --> 00:13:14.100
you would install event
on that control target.

00:13:14.220 --> 00:13:19.530
And the events are then sent to that
target and then to your handler.

00:13:21.710 --> 00:13:26.340
The EventHandlerRef is a
reference to your EventHandler.

00:13:26.430 --> 00:13:30.430
You get this when you
call installEventHandler.

00:13:31.080 --> 00:13:32.460
You don't have to get this return.

00:13:32.460 --> 00:13:36.240
You can pass it null if
you aren't interested.

00:13:36.420 --> 00:13:39.450
But it's useful if you get into
a modal situation or a certain

00:13:39.450 --> 00:13:43.100
particular mode where you want to add
event types to that handler or remove

00:13:43.100 --> 00:13:46.370
event types from that handler because
you want a broader range of events

00:13:46.410 --> 00:13:49.390
being dispatched to your handler,
for instance.

00:13:51.050 --> 00:13:54.530
So that's the basic data
types to get going on a

00:13:54.530 --> 00:13:56.660
Carbon Event-based application.

00:13:56.790 --> 00:13:59.040
But how do I get notifications?

00:13:59.160 --> 00:14:01.360
Well, you have to define your
Carbon Event handler,

00:14:01.470 --> 00:14:04.500
and I'll describe how that looks next.

00:14:04.610 --> 00:14:07.700
And then you install your
handler on an event target.

00:14:07.800 --> 00:14:10.470
And then when events get dispatched,
they will get--your

00:14:10.900 --> 00:14:13.040
callback will get called.

00:14:14.490 --> 00:14:18.500
So this is what your event
handler would look like.

00:14:18.590 --> 00:14:22.890
When you install on a particular
target and an event comes in,

00:14:22.980 --> 00:14:27.440
it will call your handler with
an event handler call ref,

00:14:27.440 --> 00:14:31.500
which is useful for manual propagation,
which I'll talk about later.

00:14:31.640 --> 00:14:34.610
It will also give you the event ref,
what is the type of event

00:14:34.610 --> 00:14:36.240
that has just occurred.

00:14:36.240 --> 00:14:41.360
And it will also return to you some
user data that you specified when you

00:14:41.360 --> 00:14:42.230
installed the handler on that target.

00:14:42.530 --> 00:14:44.890
and the propagation,
whether it's dispatched

00:14:44.890 --> 00:14:48.160
along the hierarchy,
is controlled by your return value.

00:14:48.160 --> 00:14:50.960
If you handle the event,
you'll return no error.

00:14:51.090 --> 00:14:53.650
And that tells the toolbox that
the event has been handled.

00:14:53.890 --> 00:14:56.050
Stop propagation.

00:14:56.180 --> 00:15:00.500
If the event not handled
error is returned,

00:15:00.640 --> 00:15:04.320
that will tell the toolbox that
the event has not been handled.

00:15:04.380 --> 00:15:06.010
Continue propagation.

00:15:07.830 --> 00:15:13.240
So finally, to install the Event Handler,
you call installEventHandler.

00:15:13.380 --> 00:15:18.130
Now this takes the target
that you're interested in,

00:15:18.300 --> 00:15:30.100
[Transcript missing]

00:15:30.420 --> 00:15:37.140
Now, if you get the EventHandler ref,
you can also remove the EventHandler

00:15:37.140 --> 00:15:37.140
using RemoveEventHandler.

00:15:38.600 --> 00:15:41.100
talk about all these groovy concepts.

00:15:41.100 --> 00:15:44.740
I'd like to bring out Bryan Prusha
to give a quick demo of getting

00:15:44.740 --> 00:15:47.740
a quick Carbon Event app running.

00:15:47.760 --> 00:15:49.440
Bryan?

00:15:49.650 --> 00:15:51.550
Thank you very much, Curt.

00:15:54.700 --> 00:15:58.100
I'd like to just give a small walkthrough
of installing a Carbon Event and then

00:15:58.100 --> 00:16:01.860
handling that Carbon Event elsewhere
in the application.

00:16:02.330 --> 00:16:06.800
So this is pretty much the default
code generated by Project Builder

00:16:06.800 --> 00:16:09.260
for a Carbon Nib-based application.

00:16:09.370 --> 00:16:12.100
Now, the first thing I'd like
to do is show you the Nib.

00:16:12.100 --> 00:16:14.300
So this is an Interface Builder document.

00:16:14.410 --> 00:16:15.840
And so here's our default window.

00:16:15.970 --> 00:16:18.780
I'm just going to add a couple
buttons and show off some of the

00:16:18.860 --> 00:16:20.540
features of Interface Builder.

00:16:20.640 --> 00:16:25.340
So you notice the lines appearing show
you how to line up your UI according

00:16:25.340 --> 00:16:28.180
to the Aqua Human Interface guidelines.

00:16:29.760 --> 00:16:35.130
So I'm going to make this a quit button,
and we'll make this a beat button.

00:16:35.670 --> 00:16:41.300
Now here, I can show the information,
all the attributes on these buttons.

00:16:41.380 --> 00:16:44.200
And I'm going to add
what's called a command ID.

00:16:44.320 --> 00:16:46.440
So we'll make this the quit command.

00:16:46.540 --> 00:16:49.090
There are a whole series
of default commands here.

00:16:49.100 --> 00:16:50.860
I'll just choose quit.

00:16:50.930 --> 00:16:56.850
So command IDs are things that can be
passed around as a Carbon Event that

00:16:56.850 --> 00:16:58.030
you can intercept later.

00:16:58.100 --> 00:17:01.320
So if I click this button,
this quit command ID will be sent out.

00:17:01.500 --> 00:17:04.340
I can intercept that and
do what I want with it.

00:17:04.400 --> 00:17:08.110
Now, for the beep button,
I'll just give it a beep command.

00:17:08.200 --> 00:17:31.900
[Transcript missing]

00:17:34.200 --> 00:17:44.600
[Transcript missing]

00:17:52.400 --> 00:17:54.860
We also have the beep
command installed here.

00:17:54.860 --> 00:17:57.460
And so this command ID can
be sent out from the menus,

00:17:57.610 --> 00:18:00.940
from buttons, and in fact,
it can also be sent out

00:18:00.940 --> 00:18:01.990
from keyboard events.

00:18:02.060 --> 00:18:05.290
So if I bring the window back up,
and here's the beep control.

00:18:05.460 --> 00:18:07.810
I'm going to set this
to the default button.

00:18:07.820 --> 00:18:11.740
So when I hit return or enter,
the button will be activated,

00:18:11.860 --> 00:18:13.490
and the command will also be sent out.

00:18:13.680 --> 00:18:15.510
So let me save that.

00:18:17.030 --> 00:18:19.600
will come back to the code here.

00:18:19.690 --> 00:18:22.420
Now here is just grabbing all
the information out of the nib,

00:18:22.770 --> 00:18:25.760
grabbing the menu bar, the window that we
were just dealing with.

00:18:25.780 --> 00:18:31.640
And then what I want to do special is
install this command event handler.

00:18:31.710 --> 00:18:37.530
So the type of Carbon Event I want to
deal with is the kEvent class command

00:18:37.590 --> 00:18:40.610
and kEvent command process kind.

00:18:43.210 --> 00:18:45.840
So here I'll create the
universal procedure proc,

00:18:45.870 --> 00:18:48.260
UPP, for my event handler.

00:18:48.380 --> 00:18:50.400
And then I want to install
that event handler.

00:18:50.560 --> 00:18:53.740
So I call the aptly named
installEventHandler.

00:18:53.840 --> 00:18:55.740
And I want to install this on
the application event target.

00:18:55.770 --> 00:18:59.640
Like I said, this is a high-level event,
not anything like a mouse down.

00:18:59.640 --> 00:19:02.750
I don't have to--I don't care
whether it's in my control or a

00:19:02.750 --> 00:19:04.600
window or a menu specifically.

00:19:04.690 --> 00:19:06.680
In this case,
I want to get it no matter where

00:19:06.800 --> 00:19:08.760
it comes from in the application.

00:19:09.430 --> 00:19:11.280
So I'll install my event handler.

00:19:11.350 --> 00:19:14.500
I'll count up the number of
events that I'm registering for.

00:19:14.590 --> 00:19:18.190
And I'll register for these
particular notifications.

00:19:19.500 --> 00:19:23.550
I'll call runApplicationEventLoop,
which drops us down into the

00:19:23.550 --> 00:19:26.080
HIToolbox's event handling routines.

00:19:26.080 --> 00:19:28.540
And this is where all
the standard handling,

00:19:28.540 --> 00:19:30.260
things like that, happen for you.

00:19:30.520 --> 00:19:32.660
And after we're done
running the application,

00:19:32.770 --> 00:19:35.900
we want to dispose of that event handler.

00:19:36.010 --> 00:19:38.370
So let's look at the
event handler itself.

00:19:41.290 --> 00:19:44.450
Here I want to look at the HICommand,
which is what I registered for.

00:19:44.630 --> 00:19:51.900
An HICommand is a data structure which
contains the command ID that I passed in.

00:19:52.020 --> 00:19:54.460
So I want to get this
particular event parameter.

00:19:54.460 --> 00:19:58.760
In this case,
it's the kventparam direct object.

00:19:58.880 --> 00:20:01.060
And it's of type HICommand.

00:20:01.170 --> 00:20:03.790
And I'll just grab
that command right out.

00:20:05.400 --> 00:20:09.640
and I'm going to switch
off the command ID.

00:20:09.910 --> 00:20:13.260
And in the case where it's beep,
which is my private type, which I set up,

00:20:13.360 --> 00:20:15.730
I want to just call sys beep.

00:20:15.810 --> 00:20:18.290
And in that case,
I want to return no error because I don't

00:20:18.290 --> 00:20:20.090
want this to propagate anywhere else.

00:20:20.350 --> 00:20:22.770
Nothing in the toolbox
cares about the beep ID.

00:20:22.910 --> 00:20:24.200
It's only important to me.

00:20:24.370 --> 00:20:27.020
So I don't want anybody
else to know about this.

00:20:27.130 --> 00:20:30.440
But I also want to make sure
that in every other case,

00:20:30.440 --> 00:20:33.440
for the default case,
I return event not handled error.

00:20:33.620 --> 00:20:36.350
And this will allow the application
to go on processing every other

00:20:36.360 --> 00:20:37.780
type of command that comes through.

00:20:37.940 --> 00:20:40.900
In the case of this demo,
where I created the

00:20:40.900 --> 00:20:43.200
quit beep-- I'm sorry,
the quit button,

00:20:43.200 --> 00:20:46.100
I want to make sure that that quit
command ID is processed through

00:20:46.200 --> 00:20:49.780
so the toolbox can intercept it
later and quit your application

00:20:49.780 --> 00:20:52.440
on your behalf in a standard way.

00:20:52.440 --> 00:20:56.280
So I'll go ahead and
run this application.

00:20:56.300 --> 00:20:58.580
And we'll see how it behaves.

00:21:03.900 --> 00:21:06.910
Now, there will be a lot of things that
happen for us here because the standard

00:21:06.910 --> 00:21:09.200
event handlers are all being used.

00:21:09.340 --> 00:21:13.140
So we'll get window dragging
and menu activation.

00:21:13.140 --> 00:21:17.460
Oh, this is my worst nightmare.

00:21:17.480 --> 00:21:19.540
Just compile it again.

00:21:22.300 --> 00:21:25.300
Hmm.

00:21:25.310 --> 00:21:26.130
Great.

00:21:26.230 --> 00:21:28.600
Well, we're going to go a little
hardcore on you here,

00:21:28.690 --> 00:21:30.740
so give me just a second.

00:21:33.700 --> 00:21:35.590
I'm sorry?

00:21:35.600 --> 00:21:38.500
All right.

00:21:38.520 --> 00:21:41.740
Let me clean this, make sure everything's
all cleaned out here.

00:21:41.780 --> 00:21:43.740
Build from scratch.

00:21:53.850 --> 00:21:55.040
All right, here we go.

00:21:55.170 --> 00:21:56.800
Whew.

00:21:56.900 --> 00:21:57.990
Now we have our window.

00:21:58.000 --> 00:21:58.930
It's dragging around.

00:21:59.030 --> 00:22:01.500
We get that for free because
it's a default behavior.

00:22:01.590 --> 00:22:02.720
We get the resize.

00:22:02.880 --> 00:22:04.300
We get menu tracking.

00:22:04.420 --> 00:22:04.860
This is great.

00:22:04.860 --> 00:22:07.140
I didn't have to do anything
specifically to handle this.

00:22:07.240 --> 00:22:09.500
What we're here to look
at is the command ID.

00:22:09.630 --> 00:22:13.280
So here's my beep button,
and I'm gonna click, and then the command

00:22:13.280 --> 00:22:15.410
ID beep will be sent out,
and I'll intercept it

00:22:15.410 --> 00:22:17.240
in my handler and beep.

00:22:17.800 --> 00:22:20.180
So, just as you would imagine,
this would happen.

00:22:20.180 --> 00:22:22.300
And again,
because this is a high-level event,

00:22:22.720 --> 00:22:24.580
I can hit Enter.

00:22:24.700 --> 00:22:28.300
It tracks for me automatically,
and we get the same behavior.

00:22:28.440 --> 00:22:30.840
And again from the menu.

00:22:32.020 --> 00:22:33.700
If I wanted to,
I could quit this application

00:22:33.700 --> 00:22:38.240
through the default quit menu item.

00:22:38.350 --> 00:22:41.560
But in this case, I'm going to send this
off somewhere else.

00:22:41.560 --> 00:22:43.900
I want to quit with my button.

00:22:44.550 --> 00:22:48.710
So that quit command ID is sent off
and handled in a standard manner

00:22:49.180 --> 00:22:51.580
by the IHI toolbox on your behalf.

00:22:51.580 --> 00:22:53.740
All right, thank you very much.

00:22:53.790 --> 00:22:55.500
Back to you, Curt.

00:22:58.930 --> 00:22:59.930
Thanks, Bryan.

00:23:00.130 --> 00:23:01.500
As you can see,
there was very little additional

00:23:01.500 --> 00:23:05.680
code that needed to go in in
order to make a simple application

00:23:05.750 --> 00:23:06.980
that actually did something.

00:23:07.120 --> 00:23:10.870
There wasn't any boilerplate code
required using WaitNextEvent in order

00:23:10.870 --> 00:23:14.060
to track the event and process it.

00:23:14.900 --> 00:23:19.910
and So now that we understand how
to build a basic Carbon application,

00:23:19.990 --> 00:23:24.070
Carbon Event-based application,
let's talk about how to migrate

00:23:24.070 --> 00:23:25.710
your existing application.

00:23:26.330 --> 00:23:30.630
So I've listed five steps for migration.

00:23:30.780 --> 00:23:34.710
The first two steps
I think you could do today.

00:23:35.820 --> 00:23:38.700
That is, first,
replace your tracking loops.

00:23:38.720 --> 00:23:42.530
If you need to track where the mouse is,
for instance, the user clicks in a

00:23:42.660 --> 00:23:46.220
certain area of your screen,
and you need to track where the mouse

00:23:46.220 --> 00:23:50.150
location is while the mouse is down,
traditionally you'd sit in a

00:23:50.200 --> 00:23:51.830
loop and pull the mouse location.

00:23:51.930 --> 00:23:54.560
Well, we have API specifically
designed to get away from that,

00:23:54.670 --> 00:23:56.760
and I'll describe that in a moment.

00:23:56.910 --> 00:24:01.590
Second, get rid of null event
idling with WaitNextEvent.

00:24:02.020 --> 00:24:04.830
WaitNextEvent, as you know,
returns null events if

00:24:04.830 --> 00:24:07.900
no events have come in,
and you've asked for null events,

00:24:08.030 --> 00:24:10.740
or it'll just return false.

00:24:10.850 --> 00:24:12.210
And then you can do
some particular idling.

00:24:12.240 --> 00:24:15.010
Well,
there's ways to deal with that as well.

00:24:15.740 --> 00:24:18.120
And those two things you can do today.

00:24:18.120 --> 00:24:21.090
Next,
get your feet wet with Carbon Events.

00:24:21.160 --> 00:24:25.290
Design some new features
using Carbon Events.

00:24:25.910 --> 00:24:28.310
will allow you to become
familiar with the data types,

00:24:28.420 --> 00:24:30.870
the event handling,
how to install handlers

00:24:30.940 --> 00:24:32.800
and handle those events.

00:24:32.830 --> 00:24:34.950
Next.

00:24:35.500 --> 00:24:40.160
With your existing event processing,
migrate that over to using Carbon Events.

00:24:40.220 --> 00:24:42.460
I'll describe that in a moment as well.

00:24:42.590 --> 00:24:44.700
And lastly,
when you've taken care of everything,

00:24:44.840 --> 00:24:46.660
get rid of WaitNextEvent altogether.

00:24:46.660 --> 00:24:49.990
It's been a good friend,
but we want to move forward.

00:24:53.140 --> 00:24:56.560
Step one, replace your tracking loops.

00:24:56.700 --> 00:24:59.120
Like I mentioned, traditionally,
when the user clicks on the mouse

00:24:59.150 --> 00:25:05.140
button and you want to track that,
you would call, while still down,

00:25:05.140 --> 00:25:06.980
getMouse.

00:25:07.360 --> 00:25:09.610
Now what this does is
it sits in a tight loop,

00:25:09.660 --> 00:25:13.690
pulling the hardware to see if--
where the mouse location is.

00:25:15.310 --> 00:25:17.480
It's bad because it's
sitting in a tight loop,

00:25:17.480 --> 00:25:18.950
even though maybe nothing has happened.

00:25:18.960 --> 00:25:21.060
Maybe the user hasn't actually
done anything with the mouse in

00:25:21.060 --> 00:25:24.090
terms of moving it or releasing
it or doing anything interesting.

00:25:24.240 --> 00:25:28.060
It's doubly bad because this
requires inter-process communication.

00:25:28.170 --> 00:25:31.270
We have to ask the Windows server
for the state of the mouse.

00:25:31.380 --> 00:25:35.840
So instead,
use the API trackMouseLocation.

00:25:35.990 --> 00:25:37.540
What this does is it
gets in the event loop,

00:25:37.560 --> 00:25:40.690
and it blocks until the user
actually moves the mouse or does

00:25:40.750 --> 00:25:43.070
something interesting with the mouse.

00:25:45.130 --> 00:25:48.000
This frees the CPU up
for other processes.

00:25:48.080 --> 00:25:51.420
You're not starving the processor
or starving other applications

00:25:52.120 --> 00:25:54.080
that need to do things.

00:25:54.210 --> 00:25:56.080
And also,
since it's blocked on the event loop,

00:25:56.110 --> 00:25:59.280
if you have any timers installed,
they will still be called and your

00:25:59.310 --> 00:26:03.970
application can continue processing
even while the mouse is down.

00:26:05.260 --> 00:26:08.100
In addition,
there's a new mouse tracking region API.

00:26:08.200 --> 00:26:10.250
This is new in Jaguar.

00:26:10.520 --> 00:26:15.730
This is as a replacement for the mouse
region parameter in WaitNextEvent.

00:26:16.880 --> 00:26:19.270
The advantages of this are using
the mouse region parameter in

00:26:19.270 --> 00:26:24.420
WaitNextEvent limited you to one
mouse region per application.

00:26:24.530 --> 00:26:27.270
While using the mouse
tracking region API,

00:26:27.270 --> 00:26:30.830
you can have many regions per
window that you want to track.

00:26:30.920 --> 00:26:34.400
And this allows you to get entered
notifications and exited notifications.

00:26:34.430 --> 00:26:37.700
So if the user enters a
particular region of your window,

00:26:37.940 --> 00:26:40.640
you'll get a notification
to do something.

00:26:40.760 --> 00:26:42.390
This is useful if you need
to do cursor switching.

00:26:42.400 --> 00:26:45.240
If you have a text field that
when you drag the cursor over,

00:26:45.240 --> 00:26:47.640
you want to turn to an I-beam,
for example.

00:26:47.790 --> 00:26:50.700
And this is also how
the window widgets work.

00:26:50.710 --> 00:26:52.340
So when you drag the
mouse over the close,

00:26:52.350 --> 00:26:55.760
minimize, or maximize widget,
we'll highlight them.

00:26:55.870 --> 00:26:58.270
And this is exactly how it's done.

00:27:00.030 --> 00:27:05.330
Step 2: Get rid of your Null
Event Idle Processing.

00:27:05.480 --> 00:27:06.760
This is important because
you're just spinning.

00:27:06.760 --> 00:27:10.670
You're sitting on WaitNextEvent waiting
for nothing to happen in order for

00:27:10.670 --> 00:27:12.690
you to go ahead and do something.

00:27:14.590 --> 00:27:15.500
So what is the problem?

00:27:15.500 --> 00:27:18.250
What are you trying to solve
with ILEvent processing?

00:27:18.310 --> 00:27:20.140
Well,
perhaps you need to do some processing

00:27:20.140 --> 00:27:25.370
at periodic times to animate an image,
for instance, or blink the cursor.

00:27:26.080 --> 00:27:30.070
or let's say you have a text editor
and you need to do repagination.

00:27:30.100 --> 00:27:32.260
Well, you don't want to interfere with
the user while they're typing,

00:27:32.260 --> 00:27:34.200
so you want to wait a
certain amount of time,

00:27:34.310 --> 00:27:36.160
repaginate while they're
not doing anything,

00:27:36.260 --> 00:27:39.110
or do some searching or
sorting in the background.

00:27:41.900 --> 00:27:44.480
What are the problems
with using WaitNextEvent?

00:27:44.490 --> 00:27:46.540
As I mentioned, it wastes CPU cycles.

00:27:46.660 --> 00:27:49.010
Sometimes you're sitting there
and you're not interested in any

00:27:49.010 --> 00:27:50.560
particular event at this one time.

00:27:50.560 --> 00:27:53.240
You want to wait for a certain amount
of time before something happens.

00:27:53.350 --> 00:27:58.980
But you're still returning
from WaitNextEvent and have

00:27:58.980 --> 00:27:58.980
to do some calculations.

00:27:58.980 --> 00:27:58.980
It's also not modular.

00:27:59.170 --> 00:28:01.440
If you have a new module that
needs some idle processing,

00:28:01.440 --> 00:28:05.000
you need to incorporate that,
include that into your existing code with

00:28:05.220 --> 00:28:09.280
WaitNextEvent to handle some processing.

00:28:09.380 --> 00:28:12.140
And it requires internal
logic to maintain timers.

00:28:12.230 --> 00:28:13.840
And what I mean by that is,
let's say you have two

00:28:13.840 --> 00:28:15.700
animations in your document.

00:28:15.770 --> 00:28:19.890
One that needs to be animated four times
a second and one five times a second.

00:28:19.980 --> 00:28:22.700
Well,
since WaitNextEvent is based on ticks,

00:28:22.790 --> 00:28:25.800
the easiest solution is to call
yourself back 20 times a second,

00:28:25.890 --> 00:28:28.900
do some calculations to figure
out which image needs to be

00:28:28.900 --> 00:28:30.840
animated that particular time.

00:28:32.600 --> 00:28:33.790
Solution?

00:28:33.880 --> 00:28:35.740
Use event loop timers.

00:28:35.740 --> 00:28:37.840
It's a very simple API,
and it allows you to

00:28:37.840 --> 00:28:39.050
install one timer per task.

00:28:39.050 --> 00:28:42.620
In my example, if you had two images
that you needed to update,

00:28:42.620 --> 00:28:44.750
you would just install
one timer for one image,

00:28:44.810 --> 00:28:47.790
a different timer for another image,
and each of those would only be

00:28:47.800 --> 00:28:49.740
updated when they need to be updated.

00:28:49.740 --> 00:28:52.240
There's also three classes of timers.

00:28:52.240 --> 00:28:55.270
There's one shot for singular events.

00:28:55.270 --> 00:28:58.310
That is, let's say you build up a cache,
you want to keep it around for

00:28:58.310 --> 00:29:00.580
a particular amount of time,
and then flush it.

00:29:00.620 --> 00:29:02.300
You'd use a one-shot timer for that.

00:29:02.500 --> 00:29:03.580
Thank you.

00:29:04.020 --> 00:29:05.900
There's periodic timers
for recurring events,

00:29:06.110 --> 00:29:09.140
like an animation, cursor blanking, etc.

00:29:09.270 --> 00:29:11.130
And new in Jaguar, there's idle timers.

00:29:11.250 --> 00:29:14.020
Now, this is a type of timer that
you can install that will be

00:29:14.020 --> 00:29:17.540
called when the user is idle,
in terms of moving the mouse,

00:29:17.650 --> 00:29:19.440
keyboard input, etc.

00:29:19.530 --> 00:29:22.200
There's more information
on this in Session 207,

00:29:22.200 --> 00:29:24.880
which is Performance Carbon Events,
which, again, is tomorrow,

00:29:24.880 --> 00:29:27.500
here in this hall at 3:30.

00:29:29.400 --> 00:29:32.460
Like I mentioned,
the Event Loop Timer API is very simple.

00:29:32.630 --> 00:29:35.360
There's Install Event Loop Timer.

00:29:35.510 --> 00:29:40.160
This takes the event loop that you're
interested in installing this timer on,

00:29:40.160 --> 00:29:43.310
so you can install per preemptive thread.

00:29:43.750 --> 00:29:49.500
: Hi, everyone.

00:29:49.500 --> 00:29:55.880
I'm Curt Rothert,
and I'm the founder of the

00:29:55.880 --> 00:29:55.880
Carbon Event Management team.

00:29:56.430 --> 00:29:59.000
and then the toolbox will never
get rid of a timer for you,

00:29:59.070 --> 00:30:01.610
specifically for if you
want to reset the time.

00:30:01.710 --> 00:30:03.540
So you'll always have to
call RemoveEventLoopTimer

00:30:03.540 --> 00:30:05.400
when you're done using it.

00:30:06.340 --> 00:30:09.020
I'm going to talk about idle timers
and show how easy it is to get up on

00:30:09.100 --> 00:30:10.300
them and get off of WaitNextEvent.

00:30:10.300 --> 00:30:12.800
I'd like to bring Bryan Prusha back up.

00:30:12.800 --> 00:30:18.970
Thank you again, Curt.

00:30:23.600 --> 00:30:27.170
All right, for this demo,
I have a WaitNextEvent-based app,

00:30:27.230 --> 00:30:30.310
which I will convert over
to event loop timers.

00:30:36.340 --> 00:30:42.300
So here we have... here
we have our main.cp.

00:30:42.300 --> 00:30:44.300
And I initialized some
things from our NID.

00:30:44.300 --> 00:30:46.300
This is, again, a NID-based app.

00:30:46.300 --> 00:30:50.300
And I'm going to be running an
animation of the Game of Life.

00:30:50.300 --> 00:30:52.680
You may have seen it
on some screen savers.

00:30:53.050 --> 00:30:56.780
So I initialize my animation,
and then I run that nasty

00:30:56.780 --> 00:31:00.230
boilerplate event loop code
wrapped around WaitNextEvent

00:31:00.230 --> 00:31:01.950
that everybody has to write.

00:31:02.170 --> 00:31:03.870
And then when I'm done
with the application,

00:31:03.870 --> 00:31:07.980
I'm going to go ahead and
dispose of my animation.

00:31:09.690 --> 00:31:11.600
So let's look at that
boilerplate event code.

00:31:11.760 --> 00:31:13.930
Here we have WaitNextEvent.

00:31:14.010 --> 00:31:17.880
And then when an event comes through,
we have to decide, okay,

00:31:17.880 --> 00:31:19.540
is this a mouse down?

00:31:19.660 --> 00:31:20.690
Is this a key down?

00:31:20.900 --> 00:31:23.940
What are we going to do with each one
of those different types of events?

00:31:24.000 --> 00:31:27.730
Oh, if it's a mouse down,
is it going to be in the menu bar?

00:31:27.900 --> 00:31:30.150
Is it going to be in the
drag part of the menu?

00:31:30.250 --> 00:31:32.440
I'm sorry, the drag part of the window?

00:31:32.440 --> 00:31:34.660
And the go away box, the grow box,
all these things.

00:31:34.660 --> 00:31:37.400
So all this code that you
have to handle manually.

00:31:37.470 --> 00:31:39.800
and it becomes a lot of code.

00:31:43.360 --> 00:31:46.130
So here we come back
again to WaitNextEvent.

00:31:46.130 --> 00:31:49.450
And I'm calling this
back to every six ticks,

00:31:49.570 --> 00:31:52.960
which is every ten times a second,
to update my animation.

00:31:53.750 --> 00:31:56.250
Now, as Curt described,
we have to wait until

00:31:56.250 --> 00:31:58.040
something doesn't happen.

00:31:58.200 --> 00:32:03.060
So when WaitNextEvent returns false,
we're going to go ahead and come

00:32:03.060 --> 00:32:05.900
down to this switch statement,
handle our null event,

00:32:06.100 --> 00:32:09.210
and this is where I evolve the animation.

00:32:12.400 --> 00:32:15.830
And so now that we've looked at this,
let's go ahead and run the

00:32:15.830 --> 00:32:17.360
app and see what it does.

00:32:17.360 --> 00:32:19.040
So here's the nice
animation running along,

00:32:19.060 --> 00:32:21.260
updating every tenth of a second.

00:32:21.260 --> 00:32:24.330
But what happens when an
event does happen and we

00:32:24.640 --> 00:32:26.600
can't process on all events?

00:32:27.700 --> 00:32:34.200
[Transcript missing]

00:32:40.200 --> 00:32:44.740
Okay, then.

00:32:44.740 --> 00:32:45.250
All right.

00:32:45.550 --> 00:32:49.880
So if I go to resize my window, again,
everything stops.

00:32:49.950 --> 00:32:53.570
Or if I just go to access the menu,
everything grinds to a halt.

00:32:54.190 --> 00:32:56.340
This isn't necessarily the
greatest thing in the world.

00:32:56.480 --> 00:32:58.940
So I'm going to go ahead and quit this.

00:32:59.010 --> 00:33:01.130
And I'm going to go over
to my animation code.

00:33:01.230 --> 00:33:04.220
Part of what Carbon Events does for
you is it allows you to bring the event

00:33:04.220 --> 00:33:08.060
handling over to those parts of the
application where it really matters.

00:33:08.060 --> 00:33:13.290
I want to keep my animation code together
with the event processing for it.

00:33:20.010 --> 00:33:22.150
So here's my initialization routine.

00:33:22.200 --> 00:33:24.340
And I grabbed some more
information from the nib.

00:33:24.430 --> 00:33:28.110
And what I want to do in
this initialization now is

00:33:28.110 --> 00:33:30.520
install an event loop timer.

00:33:33.770 --> 00:33:37.000
So here I'm creating the
event loop timer UPP.

00:33:37.120 --> 00:33:39.500
And I want to install that
on the current event loop.

00:33:39.640 --> 00:33:43.730
So in the multi-threaded case,
this would be on whatever

00:33:43.730 --> 00:33:45.460
thread I'm running in.

00:33:45.500 --> 00:33:46.660
In this case, it's single thread.

00:33:46.660 --> 00:33:48.540
I'm running on the main event loop.

00:33:49.580 --> 00:33:51.570
Now I'm going to fire this off
immediately because I don't want

00:33:51.570 --> 00:33:52.540
to wait for my animation to start.

00:33:52.540 --> 00:33:54.790
I just want to get right
in there and going.

00:33:54.890 --> 00:33:58.500
And again, like the WaitNextEvent case,
I'm going to go ahead and have this

00:33:58.580 --> 00:34:01.500
call back every ten times a second.

00:34:01.570 --> 00:34:06.590
And I'll pass through my UPP,
and I'll be notified

00:34:06.600 --> 00:34:09.400
whenever this timer fires.

00:34:10.740 --> 00:34:13.010
So here in my timer,
all I'm doing is calling Evolve

00:34:13.210 --> 00:34:16.390
Life just like I was back
in the WaitNextEvent case.

00:34:18.050 --> 00:34:22.900
Now that I install that timer,
I can go ahead and remove this

00:34:22.900 --> 00:34:25.960
WaitNextEvent null idle processing.

00:34:26.040 --> 00:34:29.160
It's no longer necessary.

00:34:29.250 --> 00:34:31.370
So I'm gonna go ahead and rebuild.

00:34:33.400 --> 00:34:37.770
One other thing that's very important
is once you move over to null event

00:34:37.770 --> 00:34:41.200
processing-- or from null event
processing to event loop timers,

00:34:41.370 --> 00:34:44.580
you want to give your WaitNext event
a very long timeout so it's not

00:34:44.760 --> 00:34:46.060
being needlessly called back.

00:34:46.200 --> 00:34:49.200
So we'll give it a very long timeout.

00:34:59.480 --> 00:35:02.370
So now that I'm running on timers,
you'll see there are some basic

00:35:02.370 --> 00:35:04.160
changes in the application.

00:35:04.290 --> 00:35:08.560
For one, as soon as I do have events,
things don't stop processing.

00:35:08.640 --> 00:35:09.360
This is great.

00:35:09.360 --> 00:35:10.860
My animation keeps going.

00:35:10.980 --> 00:35:14.360
And while I resize,
the animation continues,

00:35:14.470 --> 00:35:17.560
and we can even watch the
animation underneath these

00:35:17.560 --> 00:35:19.680
wonderful translucent menus.

00:35:24.280 --> 00:35:27.980
So there we've converted the
WaitNext Event idle event processing

00:35:28.460 --> 00:35:31.140
over to Carbon Event timers.

00:35:31.140 --> 00:35:32.740
So thank you very much.

00:35:32.850 --> 00:35:34.500
Back to you, Curt.

00:35:37.360 --> 00:35:39.060
Thanks, Bryan.

00:35:39.140 --> 00:35:40.450
So that looked pretty easy, didn't it?

00:35:40.540 --> 00:35:45.680
You could get off of WaitNextEvent for
your event processing and use timers.

00:35:47.240 --> 00:35:49.200
So those two steps I think
you could do today.

00:35:49.250 --> 00:35:53.720
Get off of tracking the mouse
using while still down get mouse.

00:35:53.780 --> 00:35:57.860
and also using Null
Event Processing with WaitNextEvent.

00:35:58.110 --> 00:35:59.710
Step three.

00:36:01.140 --> 00:36:03.400
Do your new development
with Carbon Events.

00:36:03.400 --> 00:36:06.310
It helps you become familiar
with Carbon Events concepts,

00:36:06.480 --> 00:36:10.890
data types, APIs,
when your event handlers are called, etc.

00:36:11.640 --> 00:36:14.540
It won't impact your existing code.

00:36:14.660 --> 00:36:17.000
Like I mentioned,
it encourages modularity.

00:36:17.110 --> 00:36:19.800
So as you create a new module,
you can just plug it in.

00:36:19.900 --> 00:36:22.990
It won't impact your
existing WaitNext Event code.

00:36:26.190 --> 00:36:28.450
So do this when you have to
add new application features,

00:36:28.450 --> 00:36:32.060
such as if you're going to do a toolbar,
or an inspector window,

00:36:32.180 --> 00:36:33.300
or even new window definitions.

00:36:33.300 --> 00:36:35.840
They can be completely
Carbon Event-based.

00:36:35.950 --> 00:36:37.680
Also become familiar with using NIBs.

00:36:37.700 --> 00:36:40.230
As you saw in Bryan's demo,
it was very easy to construct an

00:36:40.330 --> 00:36:43.340
interface in Interface Builder.

00:36:43.460 --> 00:36:46.130
And it generates what's called a NIB.

00:36:48.410 --> 00:36:52.360
also do this when you want to
adopt new toolbox features.

00:36:52.490 --> 00:36:57.840
Most new features will and are
implemented using Carbon Events,

00:36:58.000 --> 00:37:00.930
such as the Services menu,
the mouse tracking

00:37:01.000 --> 00:37:03.990
regions which I mentioned,
even HI Object,

00:37:03.990 --> 00:37:07.440
which is this cool new philosophy
that we're really excited about.

00:37:07.560 --> 00:37:12.650
It'll be talked more about tomorrow
at 9:00 in this hall in the overview

00:37:12.650 --> 00:37:15.360
of the HI Toolbox architecture.

00:37:15.480 --> 00:37:16.290
All Carbon Event-based.

00:37:16.600 --> 00:37:18.180
It's very cool.

00:37:20.010 --> 00:37:25.400
So step four,
migrate your existing event processing

00:37:25.970 --> 00:37:28.210
over to using Carbon Events.

00:37:28.630 --> 00:37:31.510
You don't have to deal with all
the event dispatching yourself.

00:37:31.530 --> 00:37:34.000
Give that responsibility to us.

00:37:34.500 --> 00:37:49.900
[Transcript missing]

00:37:52.970 --> 00:37:54.600
So what's the problem with
handling events the old way?

00:37:54.750 --> 00:37:56.300
What's wrong with it?

00:37:56.400 --> 00:38:00.460
Well, it's limited to 16 types of events,
and that's simply because WaitNextEvent's

00:38:00.500 --> 00:38:03.580
event mask is a 16-bit integer.

00:38:03.820 --> 00:38:07.040
Since it has the limitation of
only returning 16 types of events,

00:38:07.160 --> 00:38:09.000
it gives you the low-level event.

00:38:09.000 --> 00:38:12.340
A mouse down has occurred,
a keyboard down has occurred.

00:38:12.470 --> 00:38:16.220
It doesn't have a full,
rich sense of events,

00:38:16.390 --> 00:38:18.990
like actions that have happened.

00:38:19.330 --> 00:38:21.640
You also see that it's the
main bottleneck for idle event

00:38:21.640 --> 00:38:24.700
processing and mouse tracking,
which I already mentioned.

00:38:24.820 --> 00:38:29.110
It makes your architecture very
difficult and hard to maintain.

00:38:29.630 --> 00:38:33.040
and you are required to
do the proper dispatching.

00:38:33.040 --> 00:38:36.690
So if we ever want to change behavior,
you have to go maintain your code.

00:38:36.840 --> 00:38:38.330
Change it.

00:38:38.800 --> 00:38:43.190
Now, an example of that is when the proxy
icon was added to the window title bar.

00:38:43.270 --> 00:38:46.160
If you wanted to take advantage of that,
you were required to go into

00:38:46.250 --> 00:38:49.990
your WaitNextEvent-based code
and deal with that accordingly.

00:38:51.850 --> 00:38:55.160
We want to give you an
extensible solution.

00:38:55.160 --> 00:38:57.560
So the easiest thing to do
is use the standard handlers.

00:38:57.560 --> 00:39:00.100
You get standard behaviors for free.

00:39:00.200 --> 00:39:03.700
For example, with the window,
you saw in Bryan's first example that

00:39:03.700 --> 00:39:05.730
you could drag the window around,
resize it.

00:39:05.790 --> 00:39:08.420
All that was provided
for free by the toolbox.

00:39:08.420 --> 00:39:12.030
And now if we include
any future technologies,

00:39:12.210 --> 00:39:13.640
you'll also get that for free.

00:39:13.640 --> 00:39:17.610
And it allows you to migrate
off of WaitNextEvent.

00:39:18.710 --> 00:39:21.300
So for a window,
if you want to take advantage

00:39:21.660 --> 00:39:23.950
of standard handlers,
you would set the

00:39:23.950 --> 00:39:26.360
KWindowStandardHandler attribute.

00:39:26.450 --> 00:39:28.940
Now, this you could do in
creation with the API.

00:39:28.940 --> 00:39:29.900
It takes attributes.

00:39:30.000 --> 00:39:32.590
There's also an API change
window attributes.

00:39:32.690 --> 00:39:34.990
Or if you're using Interface Builder,
there's a checkbox that

00:39:35.010 --> 00:39:36.020
says Standard Handler.

00:39:36.140 --> 00:39:38.040
And you click it,
and you get all this for free.

00:39:38.150 --> 00:39:41.950
Resizing, dragging, tracking the widgets.

00:39:42.640 --> 00:39:44.500
Very cool.

00:39:44.600 --> 00:39:46.290
Then you can also customize the behavior.

00:39:46.310 --> 00:39:49.950
If you're not satisfied with the standard
behavior provided by the toolbox,

00:39:50.010 --> 00:39:54.240
you can go ahead and install handlers
for the events that you're interested in.

00:39:54.770 --> 00:39:57.310
Let's say you want to know when
the user has dragged a window

00:39:57.740 --> 00:39:59.740
close to the edge of the screen,
so you could snap the window

00:39:59.740 --> 00:40:01.200
to the edge of the screen.

00:40:01.300 --> 00:40:05.400
Well, you could install a handler to
find out when the window has moved,

00:40:05.500 --> 00:40:08.200
and then change data in
that event ref accordingly,

00:40:08.290 --> 00:40:11.340
and the toolbox will listen
to that and snap the window.

00:40:11.420 --> 00:40:15.090
Or let's say you want to grow the window,
and you want to constrain the size so

00:40:15.090 --> 00:40:17.430
it doesn't just have odd dimensions.

00:40:17.510 --> 00:40:18.800
You can also do that.

00:40:18.920 --> 00:40:20.720
Install a handler for
that particular event,

00:40:20.740 --> 00:40:23.300
a bounds-changing event.

00:40:24.400 --> 00:40:40.900
[Transcript missing]

00:40:43.930 --> 00:40:47.020
I mentioned earlier that you can
control the propagation of an event as

00:40:47.170 --> 00:40:49.660
it's dispatched through the hierarchy.

00:40:49.730 --> 00:40:52.440
Well, for standard handling,
you would set the standard handler

00:40:52.620 --> 00:40:54.700
attribute and then do nothing.

00:40:54.740 --> 00:40:57.330
The toolbox takes care
of everything for you.

00:40:57.680 --> 00:41:00.460
Now let's say you want to override
some of the standard behavior.

00:41:00.570 --> 00:41:04.560
Well, you would install a handler
on a target for the particular

00:41:04.610 --> 00:41:06.040
event you're interested in.

00:41:06.130 --> 00:41:09.200
You'd handle that event,
and then you return no error.

00:41:09.310 --> 00:41:13.530
Processing stops--it doesn't
propagate any further.

00:41:13.810 --> 00:41:15.600
But let's say you want to
modify the standard behavior.

00:41:15.680 --> 00:41:19.700
You want to get the standard behavior,
but you want to do something in addition.

00:41:19.790 --> 00:41:21.640
Well, you still can do that.

00:41:21.750 --> 00:41:24.520
If you want to pre-process,
you install your handler on a

00:41:24.520 --> 00:41:26.400
target for that particular event.

00:41:26.500 --> 00:41:29.740
When your handler is called,
you can do something and

00:41:29.740 --> 00:41:31.360
return event not handled there.

00:41:31.440 --> 00:41:34.080
The toolbox will continue propagation.

00:41:34.400 --> 00:41:36.400
or you could post-process it.

00:41:36.540 --> 00:41:39.220
And you would explicitly
continue propagation by

00:41:39.220 --> 00:41:43.100
calling CallNextEventHandler.

00:41:43.230 --> 00:41:45.690
Or you could do a combination of both.

00:41:49.630 --> 00:41:52.940
Now let's go on to some
advanced event processing.

00:41:53.030 --> 00:41:55.420
So that's kind of the basics.

00:41:55.810 --> 00:41:58.600
Now, it can also be useful to
create your own events.

00:41:58.730 --> 00:42:02.400
Let's say you have a command
handler for the Close event,

00:42:02.540 --> 00:42:04.360
like for a window.

00:42:04.450 --> 00:42:08.930
What you've seen is that the user has
tracked over the close box of a window,

00:42:09.040 --> 00:42:12.210
and you want to generate a close command.

00:42:12.330 --> 00:42:16.400
So you can use the API createEvent and
direct that towards the application

00:42:16.790 --> 00:42:20.430
so all your event handling goes
through the same bottleneck,

00:42:20.440 --> 00:42:23.170
if you will, the same handling.

00:42:23.800 --> 00:42:26.400
You can also use Carbon Events for
internal communication.

00:42:26.550 --> 00:42:30.000
Go ahead and define
your own event classes,

00:42:30.130 --> 00:42:34.430
and then you can use-- create event,
send the event to a target.

00:42:34.460 --> 00:42:37.200
Let's say you created a module
for an inspector window,

00:42:37.300 --> 00:42:38.540
and all the event
handling's dealt with that,

00:42:38.680 --> 00:42:41.530
and it defines an interface
using event classes.

00:42:41.590 --> 00:42:45.300
A different part of your application
can create an event of that class,

00:42:45.410 --> 00:42:48.660
send it to the window,
and it can react to that.

00:42:48.780 --> 00:42:52.880
It's also useful for communicating
between preemptive threads.

00:42:56.130 --> 00:42:58.510
So you've done all of that.

00:42:58.510 --> 00:43:01.430
And you don't want to stay
so long to WaitNextEvent.

00:43:03.100 --> 00:43:05.000
What are the steps to doing that?

00:43:05.000 --> 00:43:08.230
So follow all four steps
I mentioned earlier.

00:43:08.370 --> 00:43:10.090
When you're done with that,
maximize the sleep,

00:43:10.100 --> 00:43:12.270
which you saw Bryan do.

00:43:12.810 --> 00:43:15.000
And what that does is it makes
sure that your timers are doing

00:43:15.000 --> 00:43:17.590
what you would expect them to do,
that your application continues to

00:43:17.590 --> 00:43:20.630
process events the way you would expect.

00:43:21.180 --> 00:43:24.240
Then,
you remove WaitNextEvent and replace

00:43:24.240 --> 00:43:27.130
it with runApplicationEventLoop.

00:43:27.170 --> 00:43:29.760
I'll describe that API next.

00:43:29.860 --> 00:43:31.300
And then finally,
you would remove all of the

00:43:31.330 --> 00:43:33.000
WaitNextEvent artifacts.

00:43:33.110 --> 00:43:37.540
All of that switch case
stuff just should go away.

00:43:39.120 --> 00:43:42.170
RunApplicationEventLoop,
the replacement for WaitNextEvent,

00:43:42.170 --> 00:43:44.700
when you call it,
it enters the event loop,

00:43:44.820 --> 00:43:47.540
and then it will block
until any events occur.

00:43:47.670 --> 00:43:49.740
That means that your application
is not processing events,

00:43:49.740 --> 00:43:53.240
it's not doing anything until
something interesting happens.

00:43:53.250 --> 00:43:55.540
So this provides a good
user experience to the user,

00:43:55.640 --> 00:43:59.730
because your application does not consume
resources when it's not doing anything.

00:43:59.890 --> 00:44:02.850
While it's in this function,
it will dispatch events to

00:44:02.850 --> 00:44:06.030
your handlers as they come in,
and it will only return when

00:44:06.130 --> 00:44:08.600
QuitApplicationEventLoop is called.

00:44:08.690 --> 00:44:12.370
Now, that can either be called explicitly
by you and one of your event handlers

00:44:12.580 --> 00:44:14.700
or implicitly by the toolbox.

00:44:14.800 --> 00:44:18.180
For example,
it will take care of the H-I command

00:44:18.560 --> 00:44:20.930
Quit and call this function,
so it will return from

00:44:20.930 --> 00:44:27.190
RunApplicationEventLoop
and come out of your code.

00:44:27.950 --> 00:44:30.180
And so to go through these
advanced things and actually

00:44:30.210 --> 00:44:34.100
show a very cool demo,
I'd like to call Bryan back up.

00:44:37.100 --> 00:44:39.100
All right, thank you again, Curt.

00:44:39.100 --> 00:44:41.610
This time I'm going
to knock on wood here.

00:44:41.710 --> 00:44:44.540
All right, I'm going to come back
to this animation demo.

00:44:44.600 --> 00:44:49.320
And what I'm going to do
first is go open the nib.

00:44:50.270 --> 00:44:51.500
So there's some things
I want to do there.

00:44:51.500 --> 00:44:53.040
I want to start using
standard event handlers.

00:44:53.040 --> 00:44:56.470
I want to kind of get
myself off of WaitNextEvent.

00:44:56.990 --> 00:44:58.390
So here's the main window.

00:44:58.460 --> 00:45:04.000
And so down here, as Curt mentioned,
there's the standard handler checkbox.

00:45:04.140 --> 00:45:05.400
Now I'm gonna click it.

00:45:05.510 --> 00:45:10.200
Now that I'm using standard handlers,
I'm gonna click live resize,

00:45:10.290 --> 00:45:13.800
and I'll get live resize
in the standard behavior.

00:45:13.910 --> 00:45:15.840
I can save off that nib.

00:45:18.700 --> 00:45:20.540
I'm going to come back to the code.

00:45:20.610 --> 00:45:24.200
I'll go again to the animation code.

00:45:24.440 --> 00:45:26.940
And here there is more code to uncomment.

00:45:27.090 --> 00:45:31.820
So I'm going to install another
command event process handler.

00:45:34.490 --> 00:45:36.800
And so this looks just
like it did before.

00:45:36.800 --> 00:45:38.890
I'm installing this on the
application event target.

00:45:38.920 --> 00:45:40.550
I have my handler.

00:45:40.590 --> 00:45:45.010
And the same KEVENT class command,
KEVENT command process

00:45:45.010 --> 00:45:47.900
types for the event.

00:45:49.140 --> 00:45:50.990
So I'll come down here
and look at the handler.

00:45:51.080 --> 00:45:53.320
And like before,
I'll call getEventParameter,

00:45:53.320 --> 00:45:55.900
get the direct object,
which is the command,

00:45:55.990 --> 00:45:58.180
and I'll switch off the command ID.

00:45:58.280 --> 00:46:01.580
But I want to handle
specifically the khicmdnew,

00:46:01.780 --> 00:46:04.560
which is outlined in carbontevents.h.

00:46:04.660 --> 00:46:08.240
And I'm going to initialize
my animation here.

00:46:08.660 --> 00:46:11.980
and again, return no error,
because I want to be the only

00:46:11.980 --> 00:46:14.160
thing that handles the new command.

00:46:14.830 --> 00:46:19.530
I'm also going to handle
khicmdquit and dispose of all

00:46:19.580 --> 00:46:22.400
the pieces of my animation.

00:46:22.500 --> 00:46:25.230
But this I do want to
go ahead and continue,

00:46:25.300 --> 00:46:28.300
so I'm going to return
event not handled error.

00:46:29.140 --> 00:46:32.550
because I want to have
the standard handler call

00:46:32.880 --> 00:46:35.690
QuitApplicationEventLoop on my behalf.

00:46:39.550 --> 00:46:43.580
Now I can go back to my main.cp.

00:46:43.580 --> 00:46:48.090
Because I'm handling the quit command,
I no longer have to dispose

00:46:48.090 --> 00:46:51.040
of my animation here.

00:46:51.110 --> 00:46:54.660
In fact, because I'm using
standard event handlers,

00:46:54.720 --> 00:46:57.230
I no longer need my
boilerplate event loop.

00:46:57.300 --> 00:47:01.190
Instead, this is going to be replaced
by runApplicationEventLoop.

00:47:08.100 --> 00:47:11.080
And since I'm no longer using
my boilerplate event code,

00:47:11.160 --> 00:47:13.150
I can simply delete it.

00:47:15.810 --> 00:47:19.460
certainly makes that file a lot shorter,
which is very nice.

00:47:19.550 --> 00:47:21.130
Good benefit.

00:47:21.700 --> 00:47:23.720
Okay,
now I'm going to go ahead and run this.

00:47:23.720 --> 00:47:28.260
And we'll see that I can
actually remove code,

00:47:28.260 --> 00:47:29.590
and using the standard event handlers,

00:47:30.090 --> 00:47:34.060
I don't have... The application
still behaves very similarly

00:47:34.060 --> 00:47:35.060
to what it did before.

00:47:35.060 --> 00:47:38.060
I can still drag it around,
the widgets still update,

00:47:38.170 --> 00:47:42.150
and now I even get benefits for free,
like live resizing.

00:47:45.040 --> 00:47:47.460
And again, the menus still track.

00:47:47.550 --> 00:47:52.840
I can close this window...
and then choose New,

00:47:52.840 --> 00:47:54.590
and it comes back.

00:47:55.430 --> 00:48:02.540
So I'm now handling all my event
processing in my animation code itself.

00:48:02.680 --> 00:48:05.600
So everything is all
localized and modularized.

00:48:05.700 --> 00:48:10.770
Now, just to really belabor this point,
I'm gonna go ahead and add a completely

00:48:10.770 --> 00:48:13.280
new module to this application.

00:48:20.420 --> 00:48:22.400
I have a new module set up right here.

00:48:22.400 --> 00:48:24.990
I'm just going to drag
it into Project Builder,

00:48:25.070 --> 00:48:26.660
into my sources.

00:48:26.730 --> 00:48:28.330
I'll add it.

00:48:30.090 --> 00:48:33.460
And so I have just some code,
a header file,

00:48:33.460 --> 00:48:36.590
and a nib part of my module.

00:48:38.800 --> 00:48:44.390
I'm going to go back to my
main code and include module.h.

00:48:52.830 --> 00:48:58.710
and then I'll initialize my module just
like I initialized my life animation.

00:49:03.400 --> 00:49:07.060
Now, in my module,
I handle the MODL command ID.

00:49:07.200 --> 00:49:09.600
So I'm going to go back to my main nib.

00:49:12.430 --> 00:49:15.440
and add a new menu item.

00:49:15.520 --> 00:49:18.140
I'll just duplicate the new item here.

00:49:18.270 --> 00:49:24.770
And I'll say "new module." I'll give
it a new command key equivalent.

00:49:31.520 --> 00:49:36.680
And then in this menu item,
I want to handle the MODL--

00:49:38.720 --> 00:49:43.300
and the MODL command.

00:49:43.440 --> 00:49:46.090
Now, when I choose this menu item,
it'll send out this command,

00:49:46.240 --> 00:49:50.060
be intercepted by the event
handler that was installed in my

00:49:50.060 --> 00:49:55.460
module during the initialization,
and it'll create the new module for me.

00:49:55.630 --> 00:49:56.940
Save that off.

00:49:57.050 --> 00:49:58.850
Go ahead and rerun.

00:50:02.700 --> 00:50:05.350
and now with very little effort,
I'm able to add a completely

00:50:05.350 --> 00:50:06.530
new module to my application.

00:50:09.500 --> 00:50:11.590
Now,
this module also has standard events,

00:50:11.590 --> 00:50:13.830
so I can go ahead and
just drag this around.

00:50:13.840 --> 00:50:15.960
It's completely separate from this.

00:50:15.960 --> 00:50:20.900
I didn't have to handle
anything specifically.

00:50:20.920 --> 00:50:23.990
I can resize live just
like I could before.

00:50:24.800 --> 00:50:31.340
And if I close this and choose
New Module from the File menu,

00:50:31.340 --> 00:50:33.360
it'll pop up and just start going again.

00:50:33.520 --> 00:50:37.960
So I can dynamically dispose
and recreate my module.

00:50:37.980 --> 00:50:40.950
So here it is,
complete new functionality,

00:50:41.040 --> 00:50:41.960
completely wrapped up.

00:50:42.070 --> 00:50:45.040
So if there are two groups working on
the development of this application,

00:50:45.160 --> 00:50:48.640
they can work independently and
with very little work integrate

00:50:48.640 --> 00:50:51.600
them together into their app.

00:50:51.600 --> 00:50:52.700
So thank you very much.

00:50:52.860 --> 00:50:54.390
Back to Curt.

00:51:01.130 --> 00:51:02.290
Thanks, Bryan.

00:51:02.310 --> 00:51:05.760
So you can see, it was very little effort
to take a new module.

00:51:05.800 --> 00:51:07.980
You don't have to know anything
about the module other than

00:51:07.980 --> 00:51:09.860
the interface to initialize it.

00:51:09.910 --> 00:51:14.580
Maybe some Carbon Events,
event class or two that

00:51:14.690 --> 00:51:17.220
the new module requires.

00:51:17.680 --> 00:51:19.240
and the integration was very easy.

00:51:19.360 --> 00:51:23.160
Plug it into Project Builder,
and it just built and worked.

00:51:24.180 --> 00:51:27.000
So some tips for using Carbon Events.

00:51:27.100 --> 00:51:29.100
Sometimes you may not know
what events are coming in,

00:51:29.120 --> 00:51:33.530
going out,
what I should be installing a handler on.

00:51:33.630 --> 00:51:36.050
Well,
you can find out what events are going

00:51:36.050 --> 00:51:40.090
on by setting this environment variable,
event trace.

00:51:40.160 --> 00:51:44.500
Now, there's a number of ways to do this,
but on Mac OS X, in Terminal,

00:51:44.600 --> 00:51:48.200
what you would do is you would
type in setEnv event trace 1,

00:51:48.260 --> 00:51:51.270
and that sets the environment variable,
and then you would launch your

00:51:51.350 --> 00:51:53.510
application from that terminal session.

00:51:53.800 --> 00:51:55.270
Better make sure your
terminal buffer's pretty high,

00:51:55.300 --> 00:51:58.890
because there's a lot of spewage that
comes out telling you which events

00:51:58.980 --> 00:52:01.980
are being sent and what's going on.

00:52:02.740 --> 00:52:07.090
There's also some very valuable
information on the web in a Tips and

00:52:07.160 --> 00:52:10.400
Tricks page for Carbon Events.

00:52:10.450 --> 00:52:13.380
It's on Apple's developer website.

00:52:19.700 --> 00:52:23.230
So I hope I've been able to impress
upon you that migration is easy.

00:52:23.340 --> 00:52:25.860
I mean, it's an incremental process.

00:52:25.890 --> 00:52:27.350
I don't expect you to do all of it today.

00:52:27.360 --> 00:52:29.770
There's some that can be done today.

00:52:30.630 --> 00:52:34.090
But it's useful to do any new
development using Carbon Events.

00:52:34.090 --> 00:52:38.080
In fact, you should be doing all new
development with Carbon Events.

00:52:39.230 --> 00:52:41.800
Carbon Events are the
future of the toolbox.

00:52:41.850 --> 00:52:43.540
This is the direction that we're going.

00:52:43.610 --> 00:52:45.470
If you want to take
advantage of new features,

00:52:45.610 --> 00:52:47.200
you'll have to be Carbon Event-based.

00:52:47.200 --> 00:52:48.940
So it's useful to get
up and on there now.

00:52:50.850 --> 00:52:54.270
And it's a must-have for being
good OS X citizens in terms of

00:52:54.280 --> 00:52:56.340
performance and functionality.

00:52:56.340 --> 00:52:58.600
Like I mentioned,
there's a lot of new functionality

00:52:58.600 --> 00:52:59.750
that's Carbon Event only.

00:52:59.800 --> 00:53:03.790
If you want to take advantage of that,
you have to be up on Carbon Events.

00:53:05.710 --> 00:53:07.800
There's some excellent
documentation available.

00:53:07.970 --> 00:53:11.260
There's a Carbon Porting Guide.

00:53:11.380 --> 00:53:14.600
There's a book on handling Carbon Events,
Carbon Event Manager Reference.

00:53:14.700 --> 00:53:17.820
There's some documentation
on your Jaguar CD.

00:53:18.600 --> 00:53:27.040
and John Lennon will be
joining us for the session.

00:53:30.300 --> 00:53:32.300
Five steps of migration.

00:53:32.300 --> 00:53:33.790
It's pretty straightforward.

00:53:33.890 --> 00:53:36.400
You saw Bryan go through
everything today.

00:53:36.420 --> 00:53:38.030
Replace the track and loops.

00:53:38.100 --> 00:53:40.730
Get rid of WaitNextEvent-hidling.

00:53:40.970 --> 00:53:43.960
Design all of your new
features using Carbon Events.

00:53:44.110 --> 00:53:46.250
Migrate your event processing
over to Carbon Events.

00:53:46.260 --> 00:53:48.260
And finally,
get rid of WaitNextEvent and all

00:53:48.260 --> 00:53:50.710
the cruft associated with that.

00:53:53.700 --> 00:53:55.900
and the High-Level Toolbox
team is completely monopolizing

00:53:55.900 --> 00:53:58.830
this room tomorrow,
so I'd encourage you to go see all

00:53:58.830 --> 00:54:00.680
of the sessions that are available.

00:54:00.720 --> 00:54:03.700
There's an architectural overview,
which will discuss new features

00:54:03.700 --> 00:54:05.700
coming into the toolbox.

00:54:05.700 --> 00:54:08.700
A HIView session, excellent session.

00:54:08.700 --> 00:54:12.680
New controls and services to go in more
depth of what's going on in the toolbox,

00:54:12.780 --> 00:54:13.700
new stuff that's available.

00:54:13.700 --> 00:54:16.650
And I highly recommend seeing Improving
Performance with Carbon Events,

00:54:16.700 --> 00:54:17.600
and that's at 3:30.

00:54:17.700 --> 00:54:22.560
And that will teach you how to use
To Be a Better Citizen for performance.
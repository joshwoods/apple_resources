WEBVTT

00:00:09.700 --> 00:00:10.840
Good morning everyone.

00:00:10.840 --> 00:00:15.600
Welcome to session 511, Game Solutions:
Graphics and Events.

00:00:15.640 --> 00:00:17.550
That's great, we have a full house.

00:00:17.640 --> 00:00:22.100
There are some available seats over here
for you guys if you want to take them.

00:00:22.280 --> 00:00:27.380
This is the first of a series
of two dedicated game sessions

00:00:27.380 --> 00:00:29.430
here at WWDC this year.

00:00:29.880 --> 00:00:36.280
The contents of these sessions were
a result of some research we've

00:00:36.330 --> 00:00:40.390
done with our game community through
mailing lists and direct contact

00:00:40.450 --> 00:00:46.020
so we could tailor these sessions to
the most frequently challenged space

00:00:46.020 --> 00:00:48.800
by game developing on Mac OS X.

00:00:48.800 --> 00:00:52.690
We have some really good content
but we're also looking forward to

00:00:52.860 --> 00:00:57.200
your feedback and your questions
afterwards so we can further improve

00:00:57.530 --> 00:00:59.800
game technologies on the Mac.

00:00:59.800 --> 00:01:04.000
We have two presenters,
two game experts DTS engineers here and

00:01:04.110 --> 00:01:08.790
for the first part of the presentation
we'd like to welcome to the stage

00:01:08.790 --> 00:01:11.910
Apple DTS engineer David Hill.

00:01:16.720 --> 00:01:18.700
Thank you, Sergio.

00:01:18.720 --> 00:01:20.500
As Sergio said,
welcome to our first of two

00:01:20.500 --> 00:01:22.820
sessions in this very room.

00:01:22.850 --> 00:01:26.810
And we're going to be talking to
you about graphics and events today.

00:01:27.300 --> 00:01:32.680
I am David Hill and my cohort,
Todd Previt is hiding somewhere.

00:01:32.680 --> 00:01:33.750
We'll be talking to you today.

00:01:33.860 --> 00:01:37.340
I'll start out the talk and then
he'll come up for the second half.

00:01:38.180 --> 00:01:39.780
So what are we going to
be talking about today?

00:01:39.800 --> 00:01:42.600
We decided to take a slightly
different approach to these sessions

00:01:42.710 --> 00:01:45.090
this year than we did in the past.

00:01:45.100 --> 00:01:48.240
This year,
rather than focusing on a specific

00:01:48.240 --> 00:01:52.100
technology and trying to cover
it and kind of repeating a lot

00:01:52.100 --> 00:01:55.100
of what the engineering groups
are doing in other sessions,

00:01:55.100 --> 00:01:59.100
we're going to focus on some more unique
aspects of Mac OS X game development,

00:01:59.320 --> 00:02:03.490
perhaps some undocumented or
under-documented areas that you

00:02:03.490 --> 00:02:06.580
may have run into troubles with,
and cover a few little tips and

00:02:06.580 --> 00:02:08.880
tricks that we've picked up,
both in our work and

00:02:08.950 --> 00:02:11.480
working with developers,
and just general things we've

00:02:11.540 --> 00:02:13.100
picked up off the mailing list.

00:02:14.070 --> 00:02:16.300
and also maybe cover a few things
that are a little bit new to some

00:02:16.300 --> 00:02:18.990
of you that are just coming from
Mac OS 9 and haven't really started

00:02:19.170 --> 00:02:21.990
exploring what you can do with Mac OS X.

00:02:25.520 --> 00:02:27.070
So what are you going to learn?

00:02:27.150 --> 00:02:29.670
We're going to cover a
wide range of topics today.

00:02:29.810 --> 00:02:33.790
First, I'm going to start out and give
a brief update of what's happened

00:02:33.790 --> 00:02:35.700
with the CG Direct Display API.

00:02:35.700 --> 00:02:40.120
There have been some additional
APIs added to help you out with Jaguar.

00:02:40.130 --> 00:02:42.590
Then I'm going to go into some
full-screen debugging techniques.

00:02:42.630 --> 00:02:46.650
We found some developers that were having
a little bit of trouble on Mac OS X when

00:02:46.650 --> 00:02:49.930
you capture all the displays,
your app takes over the displays,

00:02:49.970 --> 00:02:50.960
everything goes black.

00:02:50.980 --> 00:02:53.270
Well, if you've got a bug
and your app gets hung,

00:02:53.420 --> 00:02:54.540
what do you do?

00:02:54.540 --> 00:02:55.960
We're going to cover
a little bit of that.

00:02:55.980 --> 00:02:59.330
I'm also going to give a little
bit of explanation about how you

00:02:59.340 --> 00:03:02.900
can go put Carbon controls and
other content on top of OpenGL.

00:03:02.980 --> 00:03:07.510
If you've seen some of the GL sessions,
they've been downloading some really

00:03:07.510 --> 00:03:09.630
amazing new features and tools.

00:03:09.650 --> 00:03:13.380
They've been talking about some
new things that you can do to

00:03:13.380 --> 00:03:17.460
layer Carbon and Cocoa content
on top of your OpenGL surface.

00:03:17.460 --> 00:03:20.160
I'll be talking about one example,
a couple of examples of that,

00:03:20.160 --> 00:03:23.160
and going into detail about one
that actually does work both

00:03:23.160 --> 00:03:26.300
on Mac OS 10.1 and on Jaguar.

00:03:26.350 --> 00:03:28.620
Once I get done, I'll bring Todd up and
he's going to cover some

00:03:28.720 --> 00:03:31.200
QuickTime and OpenGL integration,
how to get data out of

00:03:31.200 --> 00:03:34.420
OpenGL and into QuickTime,
some OpenGL buffer operations,

00:03:34.420 --> 00:03:37.390
and then a little bit
about Carbon events.

00:03:39.580 --> 00:03:41.300
So let's talk about CG Direct Display.

00:03:41.320 --> 00:03:44.610
As some of you may or may not know,
CG Direct Display is the

00:03:44.610 --> 00:03:50.410
Mac OS X API for managing displays,
for doing--iterating over your displays,

00:03:50.550 --> 00:03:53.440
finding out what modes they support,
switching between modes,

00:03:53.440 --> 00:03:56.160
doing gamma fades and
those kinds of things.

00:03:56.160 --> 00:03:58.650
And it's been around since the
beginning of Mac OS X and we've

00:03:58.660 --> 00:04:00.890
been improving it as we go.

00:04:00.900 --> 00:04:05.020
And this year we've added
a few new things in Jaguar.

00:04:05.020 --> 00:04:07.670
For some of you,
you've been asking specifically,

00:04:07.670 --> 00:04:11.840
"How do I tell if a display mode
is stretched?" If you don't know,

00:04:11.970 --> 00:04:15.110
on some of the monitors like the
LCD panels we have and on the

00:04:15.110 --> 00:04:17.980
tie books and things like that,
the aspect ratio on the

00:04:17.980 --> 00:04:19.760
display is slightly different.

00:04:19.830 --> 00:04:23.550
So there's an 800 by 600 aspect
ratio and then there's an--I don't

00:04:23.750 --> 00:04:26.980
remember what the exact numbers are,
but there's another one

00:04:27.090 --> 00:04:29.070
that's a little bit wider,
it has more pixels.

00:04:29.070 --> 00:04:33.350
And you have a choice whether you want
to stretch that 800 by 600 content all

00:04:33.490 --> 00:04:37.030
the way across those extra pixels or
whether you want to leave it 800 by

00:04:37.030 --> 00:04:39.120
600 and have black bars on the sides.

00:04:39.190 --> 00:04:41.220
So the stretched mode is the
one that stretches it out.

00:04:41.330 --> 00:04:43.270
And depending on your
content and your users,

00:04:43.270 --> 00:04:46.260
you may want to be able to tell,
"Is the mode I'm going to switch

00:04:46.390 --> 00:04:50.120
to or the mode I'm currently in,
is it stretched or not?"

00:04:50.120 --> 00:04:53.860
Some gameplay--some game players
may want to fill the whole screen.

00:04:53.860 --> 00:04:55.220
They hate the little black bars.

00:04:55.220 --> 00:04:58.380
And some of them may want to make
sure your art is at the right

00:04:58.510 --> 00:05:00.670
aspect ratio and maintain that.

00:05:00.870 --> 00:05:03.180
So in the display mode dictionary,
when you get information

00:05:03.180 --> 00:05:04.820
about a particular display
mode in Direct Display,

00:05:04.920 --> 00:05:06.620
you're going to want to
check the display mode.

00:05:06.620 --> 00:05:10.620
You can actually check this
KCG display mode is stretched flag.

00:05:10.620 --> 00:05:13.380
And it'll tell you whether
or not it's stretched.

00:05:13.420 --> 00:05:17.100
We've also added a lot of support for
both software and hardware mirroring.

00:05:17.100 --> 00:05:19.600
And in order for you to be able
to tell what's going on in the

00:05:19.760 --> 00:05:22.740
system when your app comes up,
you need to be able to tell whether a

00:05:22.740 --> 00:05:26.180
particular display is mirrored or not,
whether it's the main display in a mirror

00:05:26.300 --> 00:05:29.920
set or whether it's one of the copies.

00:05:29.920 --> 00:05:33.660
For the most part, for your game,
when you're using CG Direct Display,

00:05:33.660 --> 00:05:35.620
you're not going to care.

00:05:35.620 --> 00:05:39.380
If you capture the main display in a set,
it will capture all of them.

00:05:39.380 --> 00:05:42.530
If you capture one of the copies,
it will also implicitly

00:05:42.530 --> 00:05:44.150
capture all of the others.

00:05:44.380 --> 00:05:46.270
So CG Direct Display helps you out there.

00:05:46.270 --> 00:05:47.780
You don't have to worry
about that too much.

00:05:47.790 --> 00:05:51.060
But in cases where you want to, say,
do a gamma fade,

00:05:51.140 --> 00:05:55.540
you may have to fade all of
the monitors individually.

00:05:55.610 --> 00:05:58.250
And so you'll need to know
what you're dealing with.

00:05:58.300 --> 00:06:00.620
And so we've added some
extra APIs for that.

00:06:00.620 --> 00:06:03.840
In addition,
we've had some developers asking, well,

00:06:03.840 --> 00:06:06.980
if I've got multiple displays,
can I change the resolutions

00:06:06.990 --> 00:06:09.460
or the bit depths or whatever
on all of them at once?

00:06:09.460 --> 00:06:13.490
Well, we have a new concept of display
configuration where you can say,

00:06:13.490 --> 00:06:15.140
I want to begin a configuration.

00:06:15.150 --> 00:06:17.450
I want to set monitor one to this,
monitor two to this,

00:06:17.450 --> 00:06:18.620
monitor three to this.

00:06:18.670 --> 00:06:20.620
OK, end the configuration and commit it.

00:06:20.620 --> 00:06:21.940
And they'll all change at once.

00:06:22.000 --> 00:06:24.520
So that's another useful
technique for you.

00:06:24.530 --> 00:06:27.200
We've also added a convenience
API to just capture all

00:06:27.340 --> 00:06:28.960
the displays with one call.

00:06:29.010 --> 00:06:31.090
So if your game is going to
be drawing on one display,

00:06:31.090 --> 00:06:33.480
but you definitely want to
black everything out for the

00:06:33.590 --> 00:06:36.320
most immersive experience,
one call you can capture all

00:06:36.320 --> 00:06:39.210
the displays and be ready to go.

00:06:39.550 --> 00:06:43.600
And then we've also added some
APIs to allow you to control fading.

00:06:43.610 --> 00:06:46.910
A lot of times your game may want
to fade to black and then back

00:06:47.000 --> 00:06:51.260
up to a movie or vice versa to do
transitions between areas in your game.

00:06:51.300 --> 00:06:54.350
We've got fade APIs that
are very simple to use.

00:06:54.650 --> 00:06:59.270
You make one call to reserve a display
for some amount of time and then

00:06:59.270 --> 00:07:03.260
you say fade from the current normal
color set to a particular color.

00:07:03.260 --> 00:07:06.340
You can fade to black,
you can fade to red, whatever,

00:07:06.340 --> 00:07:08.110
over a specific span of time.

00:07:08.240 --> 00:07:11.250
And so you can do everything
from simply fading the display

00:07:11.280 --> 00:07:12.260
to black and then back up.

00:07:12.260 --> 00:07:15.500
You can do a quick flash to
red if somebody gets hurt.

00:07:15.590 --> 00:07:17.260
Those kinds of things.

00:07:17.260 --> 00:07:20.440
And one really nice thing about these
APIs is there's a flag at the end,

00:07:20.440 --> 00:07:22.260
if you look in the
CG Direct Display header,

00:07:22.260 --> 00:07:25.240
there's a flag at the end that tells
whether it's synchronous or asynchronous.

00:07:25.240 --> 00:07:28.630
So you can actually make a call
that's asynchronous and you say,

00:07:28.630 --> 00:07:31.260
okay, over the next three seconds
I want you to fade to black.

00:07:31.380 --> 00:07:33.260
It immediately comes right back to you.

00:07:33.260 --> 00:07:35.260
And the Windows server handles the fade.

00:07:35.260 --> 00:07:36.260
And so you can continue
to play your movie,

00:07:36.260 --> 00:07:39.260
you can continue to fade out
at the end of your game play,

00:07:39.260 --> 00:07:40.030
what have you.

00:07:40.170 --> 00:07:41.260
Real nice effect.

00:07:43.260 --> 00:07:46.820
So those are the new things
for CG Direct Display.

00:07:46.820 --> 00:07:49.540
So let's talk about
full-screen debugging.

00:07:49.540 --> 00:07:52.440
So a typical scenario,
you've written your full-screen game.

00:07:52.470 --> 00:07:55.130
Your game captures the
screen and fades to black.

00:07:55.430 --> 00:07:57.900
You know, everybody knows,
the game's supposed to fade right

00:07:57.900 --> 00:08:00.900
back in and display your new content,
but it doesn't.

00:08:02.880 --> 00:08:04.500
So what do you do?

00:08:04.510 --> 00:08:05.700
How do you tell what went wrong?

00:08:05.720 --> 00:08:08.110
How do you debug that situation?

00:08:08.890 --> 00:08:12.160
We looked at a couple of
possible scenarios for this.

00:08:12.160 --> 00:08:15.160
There are some standard things
like printf and other logging where

00:08:15.170 --> 00:08:18.570
you just sprinkle calls throughout
your code and watch the log and

00:08:18.700 --> 00:08:19.770
try to find out what's going on.

00:08:20.300 --> 00:08:22.800
There's also,
if you happen to be using DrawSprocket,

00:08:22.800 --> 00:08:26.160
if you come over from 9 and
you're still using DrawSprocket,

00:08:26.160 --> 00:08:29.920
DrawSprocket has a debug mode
that you may or may not know

00:08:29.920 --> 00:08:32.320
about that could be very helpful.

00:08:32.320 --> 00:08:34.390
Then there's the topic we're
going to focus on a little bit

00:08:34.390 --> 00:08:34.390
today which is remote debugging.

00:08:35.390 --> 00:08:37.180
So we'll look at each of those
in turn and kind of think

00:08:37.650 --> 00:08:38.700
about what's good and bad.

00:08:38.700 --> 00:08:41.520
So for printf and other logging,
it's good for post-mortem

00:08:41.520 --> 00:08:45.260
debugging because when you
capture the display on Mac OS X,

00:08:45.260 --> 00:08:48.390
display goes black,
the force quit command,

00:08:48.390 --> 00:08:52.450
command option escape, still works,
but in this case,

00:08:52.540 --> 00:08:54.460
we don't know what state the
screen's going to be in or anything,

00:08:54.460 --> 00:08:58.390
so we simply kill the frontmost app,
which is very helpful

00:08:58.390 --> 00:09:00.530
when you're debugging,
you get something wrong and

00:09:00.530 --> 00:09:01.850
you need to quit the app.

00:09:02.060 --> 00:09:05.040
The problem is you don't get any
state information about where

00:09:05.040 --> 00:09:06.430
the app was when you killed it.

00:09:06.540 --> 00:09:09.470
So printf and other logging,
you can go look at the log

00:09:09.470 --> 00:09:11.320
after you've killed the app,
take a look at it and

00:09:11.320 --> 00:09:12.460
find out what's going on.

00:09:12.480 --> 00:09:15.040
It does require that
you modify your code,

00:09:15.140 --> 00:09:17.100
so you have to sprinkle
these statements throughout.

00:09:17.100 --> 00:09:20.100
And if you're not exactly
sure where the problem is,

00:09:20.160 --> 00:09:23.160
you may have to get into this
binary search mode where you say,

00:09:23.210 --> 00:09:24.930
okay, well, I'm going to put a log in
here and a log in here,

00:09:24.930 --> 00:09:26.120
okay, it happens somewhere in between.

00:09:26.120 --> 00:09:29.130
So I put a log in in the middle,
and then, okay, it happened in the first

00:09:29.210 --> 00:09:31.260
half or the second half,
kind of divide and conquer approach.

00:09:31.260 --> 00:09:33.500
It's not the most efficient way to debug.

00:09:35.820 --> 00:09:37.700
We happen to be using DrawSprocket.

00:09:37.800 --> 00:09:42.640
DrawSprocket has a nice debug mode that
doesn't show the blanking window and

00:09:42.640 --> 00:09:44.360
doesn't completely fade the screen out.

00:09:44.490 --> 00:09:46.190
When you do a fade,
it will actually fade partially

00:09:46.190 --> 00:09:49.100
out and then come back,
so you can still see what's going on.

00:09:49.230 --> 00:09:53.490
And one good thing about this is
it does work on Mac OS 9 or 10.

00:09:54.800 --> 00:09:56.800
So if you want to turn
DrawSpark at debug mode on,

00:09:56.800 --> 00:09:57.710
there's two ways.

00:09:57.790 --> 00:09:59.860
You can do it programmatically
within your app.

00:10:00.030 --> 00:10:02.100
You can call it DSP set
debug mode to true,

00:10:02.100 --> 00:10:05.520
call it DSP set debug mode to false
when you want to turn it back off.

00:10:05.520 --> 00:10:08.690
Or you can create a folder
in the same directory as your

00:10:08.690 --> 00:10:10.240
app called DSP set debug mode.

00:10:11.380 --> 00:10:16.160
One important caveat to this is that
you have to enable this before you

00:10:16.160 --> 00:10:20.210
enable your context because it takes,
before you activate your context

00:10:20.210 --> 00:10:23.430
because it starts to take
effect with the next context.

00:10:23.500 --> 00:10:26.620
And on 9, specifically,
you must be using the

00:10:26.620 --> 00:10:28.350
debug build of DrawSpark.

00:10:28.600 --> 00:10:32.290
On Mac OS X, the DrawSpark framework
takes care of this for you.

00:10:32.300 --> 00:10:35.490
You don't have to worry about switching
builds of DrawSpark in and out.

00:10:35.490 --> 00:10:39.370
So that's a good thing to think about
if you're still using DrawSpark.

00:10:40.830 --> 00:10:44.460
And now we're going to talk
about remote debugging.

00:10:44.600 --> 00:10:49.330
So this is a great thing,
a great power of Mac OS X because

00:10:50.320 --> 00:10:53.240
unlike 9 when your game is taken over
the screen and perhaps locked in a

00:10:53.240 --> 00:10:56.650
tight loop not processing events,
on 10 there's all these

00:10:56.750 --> 00:10:58.290
other processes running.

00:10:59.730 --> 00:11:04.680
So if you do have a second machine
handy somewhere on the network you

00:11:04.730 --> 00:11:08.360
can actually remote login using SSH

00:11:08.600 --> 00:11:10.940
and then tell what's
going on in your program.

00:11:10.990 --> 00:11:13.890
You can attach to it with GDB,
find out where it's going,

00:11:13.890 --> 00:11:15.500
you can actually step through.

00:11:15.530 --> 00:11:19.370
Now of course GDB is a command line tool,
doesn't provide an IDE,

00:11:19.370 --> 00:11:21.550
but contrary to some, you know,
misconceptions,

00:11:21.580 --> 00:11:23.320
it does allow for source level debugging.

00:11:23.560 --> 00:11:26.120
When you compile your
code with Project Builder,

00:11:26.120 --> 00:11:29.500
say, it actually embeds in there
where the source files are.

00:11:29.500 --> 00:11:32.200
So when you go with GDB,
it can actually pull up the source

00:11:32.200 --> 00:11:35.760
for you and you can step through line
by line and watch what's going on.

00:11:37.300 --> 00:11:39.820
So for those of you that perhaps
aren't familiar with GDB,

00:11:39.840 --> 00:11:42.360
especially some people coming
from 9 that have never really

00:11:42.450 --> 00:11:43.790
used something like this,

00:11:44.200 --> 00:11:46.760
Probably the first place you should
start playing around is in the help.

00:11:46.830 --> 00:11:51.020
There's a basic command help,
and it'll list a number of different

00:11:51.020 --> 00:11:53.100
options you can use for getting help.

00:11:53.160 --> 00:11:56.640
The two important ones are
help and a command class name,

00:11:56.640 --> 00:12:00.190
in which case GDB will actually
list out all the commands.

00:12:00.310 --> 00:12:03.400
For example, there's a class of commands
for handling breakpoints.

00:12:03.400 --> 00:12:05.230
There's a class of commands
for dealing with the stack,

00:12:05.290 --> 00:12:07.470
for showing info about the
state of the program and things.

00:12:07.480 --> 00:12:11.010
And once you figure out, okay,
I need to know about that

00:12:11.010 --> 00:12:14.410
specific breakpoint command,
well, then you can help in the

00:12:14.410 --> 00:12:15.960
specific command name,
and that'll give you

00:12:16.060 --> 00:12:17.440
the full documentation,
tell you how to use it.

00:12:17.550 --> 00:12:20.120
So there's a lot of help in there,
very useful.

00:12:20.120 --> 00:12:22.300
You can just get in and
start playing around with it.

00:12:24.360 --> 00:12:27.680
So if you want to start using GDB,
and in our scenario that

00:12:27.680 --> 00:12:31.010
we talked about earlier,
your app is running, it's faded out,

00:12:31.010 --> 00:12:33.320
it's gone to black, hasn't come back.

00:12:33.400 --> 00:12:35.260
Well,
typically you'll go to a second machine,

00:12:35.260 --> 00:12:38.120
and I will point out that
because of the way this is done,

00:12:38.130 --> 00:12:39.840
it doesn't have to be another Mac.

00:12:40.180 --> 00:12:42.320
Some of you may be dual
platform developers,

00:12:42.320 --> 00:12:43.980
you have a PC and a
Mac in the same office,

00:12:43.980 --> 00:12:47.160
you're running your code on the Mac and
it goes black and doesn't come back.

00:12:47.310 --> 00:12:49.860
You can simply go over to the PC,
and as long as you have

00:12:50.000 --> 00:12:53.400
access to secure shell,
and secure shell into an IP address,

00:12:53.400 --> 00:12:56.340
you can do the same debugging,
because GDB is actually

00:12:56.340 --> 00:12:58.760
running on the target machine,
not on your PC.

00:13:00.160 --> 00:13:03.860
So once you've secured
Sheldon and you run GDB,

00:13:03.860 --> 00:13:05.550
you need to find out
what the process ID is.

00:13:06.010 --> 00:13:09.090
That's the PID that I have labeled there.

00:13:09.090 --> 00:13:10.970
And you need to attach to it.

00:13:11.520 --> 00:13:16.400
The AppDir is a tool that allows
you to run your apps in the app.

00:13:16.400 --> 00:13:19.270
If you have a problem,
you can launch it from within GDB.

00:13:19.580 --> 00:13:24.400
You type in file and the path to the
app you're going to debug and then run.

00:13:24.400 --> 00:13:26.330
For typing in the path,
you have to watch out

00:13:26.330 --> 00:13:29.400
because once you get on 10,
you're doing a lot of bundled apps.

00:13:29.550 --> 00:13:33.400
You have to give the path to the
actual executable inside the bundle,

00:13:33.400 --> 00:13:35.310
not the bundle itself.

00:13:35.430 --> 00:13:38.350
In this case,
if you're AppDir/content/macos/

00:13:38.350 --> 00:13:41.150
and the actual executable,
the app to debug.

00:13:41.400 --> 00:13:43.460
And then you can run that
and GDB will launch it,

00:13:43.560 --> 00:13:45.400
load it into libraries and everything.

00:13:47.370 --> 00:13:51.540
So, I don't know about you, but for me,
I'm used to a debugger that has, okay,

00:13:51.540 --> 00:13:55.940
step into, step over, step out, continue,
those kinds of commands.

00:13:55.960 --> 00:13:57.940
And GDB has the very same things.

00:13:58.280 --> 00:14:01.360
They're in respective order, step, next,
finish, and continue.

00:14:01.360 --> 00:14:03.730
And you can typically abbreviate those.

00:14:03.740 --> 00:14:07.520
GDB is pretty good about trying
to figure out what you mean.

00:14:08.470 --> 00:14:13.300
and it will tell you if you try
to give an ambiguous abbreviation.

00:14:13.300 --> 00:14:16.800
And so that gives you all of your
basic source level debugging,

00:14:16.860 --> 00:14:19.100
stepping and everything.

00:14:19.100 --> 00:14:20.990
Once you've actually gotten
into your source code,

00:14:20.990 --> 00:14:22.300
you need to set breakpoints.

00:14:22.300 --> 00:14:24.300
There's a couple of different
ways to go about this.

00:14:24.300 --> 00:14:28.270
You can specify by file and line number,
by function name.

00:14:28.340 --> 00:14:31.300
An interesting one to point out
there is that little FB there.

00:14:31.300 --> 00:14:34.300
That's a fun one for GDB that
I haven't seen in some other things.

00:14:34.300 --> 00:14:35.300
It's called Future Break.

00:14:35.300 --> 00:14:39.300
You can set a future break on a file and
a line number or just a function name.

00:14:39.440 --> 00:14:42.300
And every time GDB has to load--every
time your app loads in a new library,

00:14:42.300 --> 00:14:45.260
GDB loads in the symbols and
tries to match that function name

00:14:45.920 --> 00:14:48.300
against the libraries that come in.

00:14:48.300 --> 00:14:50.430
And so you can actually set a
breakpoint in a library that

00:14:50.430 --> 00:14:51.300
hasn't even been loaded yet.

00:14:51.300 --> 00:14:54.030
It can be pretty handy,
especially if you're debugging

00:14:54.030 --> 00:14:56.190
plug-ins or other things like that.

00:14:56.380 --> 00:15:00.300
Also, you need to know how to
get rid of breakpoints.

00:15:00.300 --> 00:15:03.290
You can either clear by an address
or delete by a breakpoint number.

00:15:03.300 --> 00:15:05.560
So the next logical question is,
"How do you find breakpoints?" You can

00:15:05.650 --> 00:15:07.300
find out what the breakpoint number is.

00:15:07.300 --> 00:15:08.300
It typically tells you when you set it.

00:15:08.440 --> 00:15:10.300
And also you can type
in info breakpoints,

00:15:10.300 --> 00:15:12.880
and it'll give you a list of the
current breakpoints and whether

00:15:12.880 --> 00:15:16.300
they're enabled or disabled and
those kinds of state information.

00:15:17.970 --> 00:15:19.630
So once you've stopped at a breakpoint,
you've got to figure out

00:15:19.640 --> 00:15:20.970
what's going on in your app.

00:15:20.970 --> 00:15:22.280
And there's some really simple commands.

00:15:22.310 --> 00:15:23.500
BT is a good one to remember.

00:15:23.500 --> 00:15:25.900
It gives you a stack backtrace.

00:15:25.900 --> 00:15:27.440
You can find out about
the local variables.

00:15:27.500 --> 00:15:30.490
You can find out about
globals and static variables.

00:15:30.580 --> 00:15:32.660
If you see a variable in the source
that you're looking at and you

00:15:32.660 --> 00:15:35.300
can't remember what type it is,
you can type what is variable name

00:15:35.300 --> 00:15:38.000
and it'll show you what type it is.

00:15:38.100 --> 00:15:40.160
If you want to actually
list parts of the source,

00:15:40.160 --> 00:15:41.140
you can type list.

00:15:41.240 --> 00:15:44.230
And by default it shows you the
area around the program counter.

00:15:44.390 --> 00:15:46.620
You can type list and a line
number and it'll show you

00:15:46.730 --> 00:15:48.090
the list and a current file.

00:15:48.160 --> 00:15:51.800
You can even type list and a file
name colon and a line number and it'll

00:15:51.800 --> 00:15:53.880
show you source from a different file.

00:15:53.980 --> 00:15:56.670
And if you need to gather information
about the current source file,

00:15:56.670 --> 00:15:57.900
you can type info source.

00:15:57.990 --> 00:16:00.060
That's another helpful one.

00:16:00.870 --> 00:16:02.200
Displaying variables is interesting.

00:16:02.200 --> 00:16:03.970
There's a P command that
will print variables.

00:16:03.970 --> 00:16:08.420
There's also a really powerful X command.

00:16:08.490 --> 00:16:10.240
I'm not sure exactly what it stands for.

00:16:10.240 --> 00:16:11.190
Maybe extended print.

00:16:11.200 --> 00:16:11.570
Who knows?

00:16:11.600 --> 00:16:15.490
And you type X slash a format specifier
and an address or variable name.

00:16:15.540 --> 00:16:17.650
You can even include a repeat count.

00:16:17.650 --> 00:16:20.090
And you can specify a
number of different formats,

00:16:20.090 --> 00:16:23.870
decimal, float, hexadecimal,
how you want to display it, and the size.

00:16:23.900 --> 00:16:25.910
And so, for example,
if you had a float variable,

00:16:25.910 --> 00:16:28.260
you could type X slash F and a
float variable name and it would

00:16:28.260 --> 00:16:29.900
display floating point content.

00:16:31.030 --> 00:16:33.640
Depending on what kind of
debugging you're doing,

00:16:33.640 --> 00:16:36.310
you may need to tweak variables
so you continue execution if

00:16:36.310 --> 00:16:37.800
you've got something broken.

00:16:37.940 --> 00:16:40.350
You can set a variable
name equal to a new value.

00:16:40.550 --> 00:16:43.610
That will update it and you
can continue from there.

00:16:44.000 --> 00:16:47.010
For those of you that are starting
to explore Cocoa and Objective-C,

00:16:47.120 --> 00:16:49.370
there's some built-in
functionality there.

00:16:49.530 --> 00:16:50.940
There's a PO command.

00:16:51.000 --> 00:16:55.100
You give PO an Objective-C object ref,
and that will actually print out

00:16:55.100 --> 00:16:58.190
the contents of that variable.

00:16:58.380 --> 00:17:01.820
That's an interesting point because
what it's actually doing is calling

00:17:01.820 --> 00:17:03.900
the description method on the object.

00:17:03.960 --> 00:17:09.110
A lot of Objective-C objects have a
knowledge way to describe themselves.

00:17:10.830 --> 00:17:15.820
This call will actually call
code in your app on that class

00:17:16.210 --> 00:17:17.700
and have it describe itself.

00:17:17.790 --> 00:17:19.700
So GDB doesn't have to
know anything about it.

00:17:19.770 --> 00:17:22.810
So even for your custom classes,
if you implement description methods,

00:17:22.850 --> 00:17:24.700
you can actually have it executed.

00:17:24.750 --> 00:17:29.700
And that brings me to perhaps one of
the most powerful functions of GDB.

00:17:29.700 --> 00:17:33.700
You can actually call functions
in your code from GDB.

00:17:33.700 --> 00:17:37.690
And the typical way you would do it,
you would call and give it a return type,

00:17:37.760 --> 00:17:39.700
a function name, and whatever arguments.

00:17:39.820 --> 00:17:42.120
And for those of you dealing with CF,
you've probably run

00:17:42.120 --> 00:17:44.590
across this one before,
CFShow.

00:17:44.780 --> 00:17:47.700
Very useful, I always forget it.

00:17:47.700 --> 00:17:50.910
Returns void, CFShow,
and any CF type ref,

00:17:50.910 --> 00:17:54.520
and it will describe the object for you.

00:17:54.700 --> 00:17:55.660
So that one's pretty helpful.

00:17:55.830 --> 00:17:58.570
This is also extremely
useful in your own code.

00:17:58.750 --> 00:18:00.700
A lot of you have your
own debugging functions,

00:18:00.700 --> 00:18:02.670
have your own, you know,
tell me the state of this object,

00:18:02.740 --> 00:18:05.700
validate this object,
those kinds of functions.

00:18:05.840 --> 00:18:08.670
You can call them
directly from within GDB.

00:18:08.710 --> 00:18:11.620
that's kind of hard to
do in other debuggers.

00:18:11.720 --> 00:18:14.160
You can call it directly from there,
you know,

00:18:14.160 --> 00:18:15.690
dump my internal state for some object.

00:18:15.700 --> 00:18:18.090
It's important to watch
out for side effects,

00:18:18.090 --> 00:18:18.690
though.

00:18:18.700 --> 00:18:21.700
This does execute code in your app.

00:18:21.700 --> 00:18:26.700
So if you make state changes to objects
when you're doing these kinds of things,

00:18:26.700 --> 00:18:30.150
you may get some weird side effects as
you go along because you're changing

00:18:30.270 --> 00:18:32.270
the state when you didn't expect
to in your program because you're

00:18:32.320 --> 00:18:33.680
calling things sort of out of order.

00:18:33.900 --> 00:18:35.700
So watch out for that.

00:18:35.700 --> 00:18:40.430
So I thought we'd run you
through a real quick demo.

00:18:41.710 --> 00:18:44.240
This is demo two here.

00:18:44.360 --> 00:18:47.030
So we're going to pull
up full-screen debug.

00:18:47.250 --> 00:18:53.910
And I've basically written a really
simple app that captures the screen.

00:18:54.230 --> 00:18:56.310
and oh look,
that doesn't look quite right.

00:18:56.460 --> 00:18:58.590
I'm not coming back.

00:18:58.680 --> 00:19:01.590
So if we can switch over
to number three here,

00:19:01.630 --> 00:19:03.760
we've got our handy terminal.

00:19:04.150 --> 00:19:14.590
And we're going to try to do this live,
so 86, 63, and 161.

00:19:16.750 --> 00:19:18.700
Yes, that's a good idea.

00:19:18.700 --> 00:19:22.520
Bigger, let's go bigger.

00:19:25.800 --> 00:19:27.410
Can you all read that now?

00:19:27.530 --> 00:19:30.440
Is that a little better?

00:19:30.550 --> 00:19:30.850
Yeah.

00:19:31.020 --> 00:19:31.280
OK.

00:19:31.540 --> 00:19:33.040
So now we're logged into this machine.

00:19:33.140 --> 00:19:35.440
So all I had to know,
I had to be able to run SSH from here,

00:19:35.440 --> 00:19:38.250
I had to know the
IP address and the password.

00:19:38.410 --> 00:19:41.700
In this case, because I didn't specify to
SSH who I was logging in as,

00:19:41.760 --> 00:19:44.660
it just assumed I wanted to log
in as the user I'm logged in here,

00:19:44.740 --> 00:19:45.600
Apple.

00:19:45.710 --> 00:19:48.460
So I have to know the password
for Apple on that machine.

00:19:48.590 --> 00:19:50.270
So here I am.

00:19:50.670 --> 00:19:53.600
And I need to know where that process is.

00:19:53.600 --> 00:19:58.100
So we look through this output,
and it looks like this is it right here.

00:19:58.190 --> 00:20:00.390
Running off the desktop.

00:20:01.070 --> 00:20:07.220
And so I can say, well, please, I'm GDB,
and attach to, what was that number?

00:20:07.220 --> 00:20:07.900
624.

00:20:08.000 --> 00:20:15.200
So GDB finds that process and it
loads in the shared libraries.

00:20:17.430 --> 00:20:21.840
Boy, this is a lot faster on
a dual processor machine.

00:20:21.840 --> 00:20:23.890
I want one of these.

00:20:24.100 --> 00:20:26.490
Okay, so now we're switched.

00:20:26.490 --> 00:20:29.820
And we say, okay, well,
where did we stop?

00:20:30.170 --> 00:20:32.470
Well, looking at this,
I can see that from my

00:20:32.470 --> 00:20:34.480
main I was calling sleep.

00:20:34.480 --> 00:20:36.300
Told you this was a simple app.

00:20:36.460 --> 00:20:40.000
And it's stuck way down
in there somewhere.

00:20:40.110 --> 00:20:43.050
So the important thing here is
I don't really care about clock,

00:20:43.280 --> 00:20:45.300
sleep, trap, nano sleep, sleep, whatever.

00:20:45.720 --> 00:20:48.460
One of the things you can
do is you can type finish.

00:20:48.890 --> 00:20:51.870
This is a camera run until
I exit from clock sleep trap.

00:20:51.870 --> 00:20:54.170
That puts me back at nano sleep.

00:20:54.560 --> 00:20:56.960
Well, I found this bug yesterday.

00:20:57.120 --> 00:21:01.500
If we look at the backtrace again,
that doesn't look quite right.

00:21:01.790 --> 00:21:04.670
So it turns out, and this doesn't happen
on all of my apps,

00:21:04.740 --> 00:21:07.720
I tried it on a couple of things,
there appears to be a bug in GDB,

00:21:07.750 --> 00:21:09.800
I think it's a known bug,
at least from some of

00:21:09.800 --> 00:21:15.580
the Project Builder guys,
that Finish doesn't, always.

00:21:17.430 --> 00:21:20.470
Now, it appears to just get a little
confused as to what the backtrace is.

00:21:20.560 --> 00:21:22.430
Now, the important thing is
the app is still fine.

00:21:22.600 --> 00:21:24.860
So I can step, and we happen to be near
the end of NanoSleep.

00:21:24.860 --> 00:21:26.930
So step takes me to sleep.

00:21:26.930 --> 00:21:31.050
And if I step again, oh good,
I'm back out in my code.

00:21:31.060 --> 00:21:32.400
So watch out for that.

00:21:32.400 --> 00:21:34.610
This is on the Jaguar seed that you have.

00:21:34.690 --> 00:21:38.730
It appears to be a little flaky,
at least as far as backtrace finish goes.

00:21:38.780 --> 00:21:42.650
So now we're back in our code,
and I can type list.

00:21:42.730 --> 00:21:44.760
And oh look, I'm in a loop.

00:21:44.770 --> 00:21:47.510
I'm asking some other function,
should I loop?

00:21:47.650 --> 00:21:49.080
And then I'm sleeping.

00:21:49.080 --> 00:21:52.150
So let's step,
which will actually step in.

00:21:52.270 --> 00:21:55.120
Okay, now I'm in should I loop.

00:21:55.120 --> 00:21:58.380
Let's take a look at what I'm doing.

00:21:58.380 --> 00:21:58.380
Okay, so I

00:21:58.870 --> 00:21:59.990
Thank you for joining us.

00:22:00.050 --> 00:22:02.230
I'm David Hill,
and I'm going to talk about the most

00:22:02.230 --> 00:22:05.700
important part of the process of creating
a balanced and efficient Mac OS X.

00:22:05.800 --> 00:22:14.890
I'm David Hill,
and I'm going to talk about the most

00:22:14.890 --> 00:22:28.770
important part of the process of creating
a balanced and efficient Mac OS X.

00:22:28.800 --> 00:22:31.750
which is,
I should actually show you that.

00:22:33.850 --> 00:22:35.930
So here are my local variables.

00:22:35.990 --> 00:22:38.840
Wait for GDB is a local
variable set to one.

00:22:38.850 --> 00:22:41.490
And none of the code that I showed
you am I actually changing that.

00:22:41.560 --> 00:22:43.500
So silly me, I goofed up.

00:22:43.780 --> 00:22:46.470
So let's just set that wait for GDB

00:22:48.350 --> 00:22:50.540
Back to zero.

00:22:50.570 --> 00:22:56.660
And if we continue from here,
it'll go wait, sleep for a second,

00:22:56.710 --> 00:22:59.300
and then oh look,

00:23:00.370 --> 00:23:01.300
We're back.

00:23:01.390 --> 00:23:04.100
So now I'm back out of that loop
and I'm going on with my program.

00:23:04.100 --> 00:23:06.450
And in this case we can
just quit and go on.

00:23:06.620 --> 00:23:10.340
So let me quit out of GDB right quick.

00:23:13.330 --> 00:23:14.600
Okay, so that's my connection.

00:23:14.720 --> 00:23:15.130
Good deal.

00:23:15.180 --> 00:23:18.200
All right, so that's your real simple
introduction to GDB.

00:23:18.200 --> 00:23:19.570
It's real easy to use.

00:23:19.570 --> 00:23:22.340
You can start playing with it,
get in there and take a look

00:23:22.340 --> 00:23:24.200
and see what you can do.

00:23:24.200 --> 00:23:26.150
So let's go back to number one.

00:23:26.150 --> 00:23:29.090
We've got a few more
slides to talk about here.

00:23:29.090 --> 00:23:31.200
Okay,
so you know how to debug a little bit.

00:23:31.200 --> 00:23:34.200
Now let's look at something
more interesting that came

00:23:34.200 --> 00:23:37.170
about with the announcement
of Jaguar and Quartz Extreme.

00:23:37.200 --> 00:23:40.990
People start to get interested in, oh,
well, we can now layer all this content.

00:23:41.150 --> 00:23:46.410
And, you know, I have a game editor, say,
and I want to be able to have

00:23:46.410 --> 00:23:49.690
my OpenGL content displayed
in all of its splendor and put

00:23:49.760 --> 00:23:51.790
some controls over the top.

00:23:53.230 --> 00:23:54.090
How do I do that?

00:23:54.090 --> 00:23:58.060
We're going to look at a
couple of possibilities.

00:23:58.060 --> 00:24:01.000
One possibility is always you
can implement your own controls.

00:24:01.030 --> 00:24:03.240
You guys know how to do graphics,
know how to do events and things.

00:24:03.290 --> 00:24:05.380
You can implement your own controls.

00:24:05.580 --> 00:24:10.830
You can pick a normal window and put
those controls in a higher level window.

00:24:10.830 --> 00:24:13.660
You can use one of the new
overlay windows in Carbon,

00:24:13.730 --> 00:24:16.500
which is completely transparent and
then you can draw your content in it.

00:24:16.520 --> 00:24:19.390
Or you can use some of the
new surface ordering APIs that

00:24:19.390 --> 00:24:20.920
we introduced in Jaguar.

00:24:21.520 --> 00:24:24.460
So if we look at those one by one,
you decide to implement

00:24:24.510 --> 00:24:26.470
your own controls,
you have extremely precise

00:24:26.470 --> 00:24:29.580
control over the drawing
because you're doing everything.

00:24:29.580 --> 00:24:31.190
And you can place it
on screen with OpenGL.

00:24:31.190 --> 00:24:34.050
You would typically render your
controls into a texture and

00:24:34.050 --> 00:24:36.370
put them on screen with OpenGL,
say.

00:24:37.690 --> 00:24:40.730
Your users are going to expect at
least some level of consistency

00:24:40.880 --> 00:24:43.300
with the app and the OS.

00:24:43.400 --> 00:24:46.400
So you have to kind of try to
mimic the Aqua user experience.

00:24:46.510 --> 00:24:48.650
And you also do have to
draw everything yourself.

00:24:48.770 --> 00:24:49.840
So that's a bit of work.

00:24:49.900 --> 00:24:51.380
And unless you already
have code to do that,

00:24:51.380 --> 00:24:54.460
I don't particularly recommend it.

00:24:54.570 --> 00:24:55.880
You can place controls
in a higher window.

00:24:56.140 --> 00:24:59.600
If you do an opaque window,
just a normal-- you can ask

00:24:59.810 --> 00:25:02.860
Carbon to create a window
with no borders and no shadow.

00:25:02.950 --> 00:25:05.200
You can layer that on top
of your OpenGL content.

00:25:05.200 --> 00:25:07.690
So it's just a layer-- a
window floating on top.

00:25:07.790 --> 00:25:08.760
You don't have to draw the controls.

00:25:08.760 --> 00:25:10.700
You can put normal Carbon controls in it.

00:25:10.780 --> 00:25:13.550
And you don't have to handle
any of the event interaction.

00:25:13.660 --> 00:25:15.140
The problem is it's opaque.

00:25:15.140 --> 00:25:17.760
So it blocks out a rectangular
area of whatever your content is.

00:25:17.840 --> 00:25:19.940
And you may or may not want that,
depending on how you have

00:25:19.940 --> 00:25:20.960
your content laid out.

00:25:21.070 --> 00:25:23.260
And you're going to
have multiple windows.

00:25:23.370 --> 00:25:25.700
And I'll tell you how to get around
some of the management problems

00:25:25.700 --> 00:25:27.960
with multiple windows in a minute.

00:25:29.080 --> 00:25:31.280
So what if we wanted to show
our content through the window?

00:25:31.280 --> 00:25:33.840
We just had a round button
we want to put on our window.

00:25:33.840 --> 00:25:35.840
We want the rest to be transparent.

00:25:35.920 --> 00:25:37.470
We can use an overlay window.

00:25:37.820 --> 00:25:39.290
Again, the OS handles the controls.

00:25:39.290 --> 00:25:40.700
You don't have to mess with them.

00:25:40.770 --> 00:25:43.700
And your OpenGL content can show
through except for where you've

00:25:43.720 --> 00:25:45.310
made that overlay window opaque.

00:25:45.750 --> 00:25:49.000
Now, the cons are you will have a speed
penalty if you're in the software

00:25:49.000 --> 00:25:52.590
compositor as opposed to Quartz Extreme,
and you still have those

00:25:52.590 --> 00:25:54.300
multiple windows to manage.

00:25:55.320 --> 00:25:58.760
and then the new thing we've introduced
for Jaguar is surface ordering.

00:25:58.810 --> 00:26:01.590
With surface ordering
you can actually take

00:26:01.690 --> 00:26:04.150
The ordering of the surface
is the OpenGL surface and the

00:26:04.150 --> 00:26:05.570
window back buffer surface.

00:26:05.580 --> 00:26:07.470
And normally, you can rearrange them.

00:26:07.470 --> 00:26:09.700
Normally,
you have the OpenGL surface on top.

00:26:09.800 --> 00:26:12.150
And for those of you that
have tried to actually draw,

00:26:12.180 --> 00:26:14.330
say,
quick draw content on top of your OpenGL,

00:26:14.330 --> 00:26:16.510
you always say, well, it never shows up.

00:26:16.590 --> 00:26:18.840
And then as soon as I dispose
of the OpenGL context,

00:26:18.840 --> 00:26:20.140
well, there's my drawing.

00:26:20.140 --> 00:26:21.130
Why wasn't it there?

00:26:21.130 --> 00:26:24.320
Well, it's actually just in a surface
behind the OpenGL surface.

00:26:24.320 --> 00:26:28.110
With this API,
you can put the OpenGL surface behind

00:26:29.060 --> 00:26:31.200
the back buffer surface for the window.

00:26:31.200 --> 00:26:33.540
And if you clear out the alpha
properly in the back buffer,

00:26:33.760 --> 00:26:36.020
you can actually do the same
kinds of tricks where you put,

00:26:36.140 --> 00:26:41.850
say, a Carbon button that's transparent
around it on top of your OpenGL content.

00:26:42.420 --> 00:26:44.400
So this you can do with Carbon and Cocoa.

00:26:44.450 --> 00:26:46.410
The OpenGL content does show through.

00:26:46.540 --> 00:26:49.510
Again, there's a speed penalty if you're
using the software compositor.

00:26:49.550 --> 00:26:53.240
And it does require Jaguar,
so you have to be aware of that.

00:26:54.110 --> 00:26:56.750
So for those of you that can't
quite require Jaguar yet,

00:26:56.750 --> 00:27:00.040
especially since it hasn't shipped,
you might want to look

00:27:00.040 --> 00:27:01.070
at the overlay windows.

00:27:01.100 --> 00:27:05.210
Overlay windows can actually give
you reasonably good speed and

00:27:05.640 --> 00:27:09.560
they do allow your content to
show through and they will work on

00:27:09.560 --> 00:27:12.500
Mac OS X1 and on Jaguar when it ships.

00:27:12.600 --> 00:27:14.170
So what do you have to do?

00:27:14.350 --> 00:27:16.080
Well you have to create the
overlay window obviously.

00:27:16.080 --> 00:27:19.170
And then in order to help you
manage those multiple windows,

00:27:19.170 --> 00:27:20.340
there's a concept of window groups.

00:27:20.400 --> 00:27:22.980
You can create a window group and
add your windows to it and the

00:27:23.010 --> 00:27:25.940
window manager will actually manage
a lot of those windows for you.

00:27:26.200 --> 00:27:28.330
And then you install your controls
and your Carbon event handlers

00:27:28.410 --> 00:27:29.500
and all those kinds of things.

00:27:29.550 --> 00:27:32.900
Todd will talk a little bit more
about Carbon event handlers later.

00:27:33.490 --> 00:27:35.570
So creating an overlay window,
you use the standard

00:27:35.570 --> 00:27:37.100
Carbon Create New Window call.

00:27:37.160 --> 00:27:38.980
The important thing to
know is you have to pass

00:27:39.030 --> 00:27:43.900
OverlayWindowClass instead of your normal
DocumentWindowClass or what have you.

00:27:43.900 --> 00:27:45.870
And you get back a window ref.

00:27:46.130 --> 00:27:47.950
So then we need to create a window group.

00:27:48.060 --> 00:27:50.100
And a real simple API.

00:27:50.180 --> 00:27:52.160
And in this case we're not
passing any group attributes in.

00:27:52.160 --> 00:27:54.450
We're going to set them at the end
and I'll talk about them there.

00:27:54.570 --> 00:27:56.710
You have to tell the window
group what its parent is.

00:27:56.750 --> 00:28:00.050
In this case we're just saying, "Ah,
let it live with the document windows.

00:28:00.050 --> 00:28:00.790
That's fine."

00:28:00.860 --> 00:28:03.270
And then for each of our windows,
say we have an OpenGL window

00:28:03.270 --> 00:28:07.220
ref and an overlay window ref,
we add each of those to that group.

00:28:07.290 --> 00:28:09.580
And then we're going to set
some important attributes.

00:28:09.590 --> 00:28:11.290
And there are a number
of things you can set.

00:28:11.300 --> 00:28:14.600
In my particular case,
I want the windows to move together.

00:28:14.680 --> 00:28:17.460
So I've got a main document window and
I've got an overlay window over the top.

00:28:17.580 --> 00:28:19.700
And when I drag the main document window,
I don't want to have to mess

00:28:19.700 --> 00:28:20.660
with the overlay window.

00:28:20.660 --> 00:28:22.180
I want the overlay
window to move with it.

00:28:22.310 --> 00:28:23.390
So that's the first one.

00:28:23.550 --> 00:28:24.450
Add or move together.

00:28:24.530 --> 00:28:27.900
Layer together means if I switch
that document to the back and

00:28:27.900 --> 00:28:29.790
bring it back to the front,
those windows stay together.

00:28:29.800 --> 00:28:31.040
That's very handy.

00:28:31.170 --> 00:28:33.800
And also hide on collapse means
if I collapse the main window,

00:28:33.800 --> 00:28:35.290
the overlay window goes with it.

00:28:35.300 --> 00:28:38.470
And then if I bring it back,
it'll automatically repaint the

00:28:38.470 --> 00:28:40.500
overlay window when it comes back.

00:28:40.500 --> 00:28:43.420
So let's look at a quick demo of that.

00:28:44.650 --> 00:28:46.860
All right, we're up.

00:28:46.860 --> 00:28:48.240
Let's go back over here.

00:28:48.240 --> 00:28:50.550
Actually, I bet I'm in the dock.

00:28:51.460 --> 00:28:53.680
We planned ahead.

00:28:53.680 --> 00:28:57.780
So let's just pick an image.

00:28:58.290 --> 00:29:00.600
And for those of you that
have been paying attention,

00:29:00.600 --> 00:29:04.590
I have liberally borrowed from
Jeff's excellent OpenGL image sample.

00:29:05.160 --> 00:29:08.700
And so what we're seeing here is just
OpenGL image sample and I've simply

00:29:08.700 --> 00:29:11.200
put in an overlay window over the top.

00:29:11.290 --> 00:29:13.860
So, and I put it in a group
and it's layered together.

00:29:13.960 --> 00:29:19.340
So, this big red thing here is
actually some quartz 2D drawing.

00:29:19.410 --> 00:29:22.840
So that's layered on top and it's nicely,
you know, transparent and you

00:29:22.890 --> 00:29:25.520
can see if you zoom in,
I don't think the accessibility

00:29:25.520 --> 00:29:27.500
stuff is turned on,
but if you zoom in you can see

00:29:27.500 --> 00:29:29.060
it's anti-aliased and everything.

00:29:29.090 --> 00:29:32.340
And I've also got one
lonely little Carbon button.

00:29:32.420 --> 00:29:35.750
So what happens if I click this button?

00:29:37.770 --> 00:29:40.290
So I've just leveraged
the app as it exists.

00:29:40.550 --> 00:29:44.130
Jeff has a command Carbon event handler
that takes commands from buttons

00:29:44.130 --> 00:29:45.400
and menus and those kinds of things.

00:29:45.400 --> 00:29:48.280
And I've just co-opted
the auto-rotate command.

00:29:48.280 --> 00:29:51.860
So this button just has the same
command ID as that menu item.

00:29:51.860 --> 00:29:55.600
So I can stop and start,
and I can drag it around

00:29:55.600 --> 00:29:56.820
while it's rotating.

00:29:56.820 --> 00:29:59.400
And if you notice,
you look in that bottom left corner,

00:29:59.400 --> 00:30:01.440
for those that you can read it,
it displays the frame rate.

00:30:01.520 --> 00:30:03.940
And we're doing this
at 60 frames a second.

00:30:03.940 --> 00:30:06.740
And I'm not doing anything
too terribly bright.

00:30:06.830 --> 00:30:09.540
I've got an overlay window that's
the entire size of this content.

00:30:09.540 --> 00:30:12.740
And I can drag it around
while it's moving.

00:30:14.350 --> 00:30:16.240
all sorts of things,
and the Windows server keeps

00:30:16.240 --> 00:30:17.300
everything nice and tidy.

00:30:17.300 --> 00:30:22.180
If you were doing this for real and, say,
you had a button and this other thing,

00:30:22.180 --> 00:30:24.040
you might want to make the
overlay window smaller,

00:30:24.040 --> 00:30:26.360
so especially in the
software compositor case,

00:30:26.440 --> 00:30:28.510
it has less work to do,
less compositing to do,

00:30:28.520 --> 00:30:31.940
because in the software compositor case,
the compositing happens on the CPU,

00:30:31.940 --> 00:30:35.050
but this nice GL content
happens on the card,

00:30:35.060 --> 00:30:37.840
so it has to read back across the bus,
do the compositing and software,

00:30:37.940 --> 00:30:38.580
and put it back.

00:30:38.770 --> 00:30:40.910
But you still get
reasonably good frame rates,

00:30:41.100 --> 00:30:44.200
and if you optimize it some, like I said,
if you make the overlay window

00:30:44.350 --> 00:30:48.890
small and another small window here,
you can carry off effects like

00:30:48.890 --> 00:30:52.400
this even on 10.1 in the software
render and get really good results.

00:30:54.860 --> 00:31:00.170
Okay, so that's the simple image demo.

00:31:01.600 --> 00:31:04.700
All right, we're back to slides.

00:31:04.720 --> 00:31:06.360
So that's it for my half.

00:31:06.360 --> 00:31:10.560
I've covered CG Direct Display changes,
some full-screen debugging introduction,

00:31:10.560 --> 00:31:14.160
and also how to put Carbon,
and you can also do it with Cocoa,

00:31:14.240 --> 00:31:16.200
controls over OpenGL content.

00:31:16.240 --> 00:31:22.280
Now we're going to bring Todd up,
and he's going to talk to

00:31:22.280 --> 00:31:23.870
you about event loop timers,
quick time in OpenGL,

00:31:23.870 --> 00:31:23.870
and OpenGL buffer operations.

00:31:30.500 --> 00:31:31.500
Thanks, David.

00:31:31.500 --> 00:31:35.090
So I'm going to start first going
into event loops and timers,

00:31:35.180 --> 00:31:38.110
then into, as David said,
QuickTime and OpenGL,

00:31:38.110 --> 00:31:41.570
and then following up with
some buffer operations in

00:31:46.500 --> 00:31:48.330
So here's the story on Carbon events.

00:31:48.340 --> 00:31:49.100
This is how you get into it.

00:31:49.220 --> 00:31:54.300
Run application event loop from your
main function is what actually kicks you

00:31:54.300 --> 00:31:56.030
into the whole Carbon event structure.

00:31:57.150 --> 00:32:00.330
And when you're ready to quit out of it,
quit application event loop is what will

00:32:00.330 --> 00:32:02.460
bring you back out next to the shell.

00:32:02.560 --> 00:32:05.110
I've also included a little
addendum about wait next event

00:32:05.120 --> 00:32:06.420
down there at the bottom.

00:32:06.420 --> 00:32:09.640
Wait next event is dead, folks,
and it's time to start

00:32:09.650 --> 00:32:11.740
moving on to Carbon events.

00:32:11.740 --> 00:32:14.290
Everybody has complained historically
about the performance of Carbon events

00:32:14.300 --> 00:32:17.450
and with a lot of the changes that we've
made in the recent builds of Carbon lib,

00:32:17.450 --> 00:32:20.500
I think you'll find that performance
is definitely there and it's going

00:32:20.500 --> 00:32:22.650
to do better for you in the future.

00:32:26.420 --> 00:32:29.060
So some basic structure on Carbon events.

00:32:29.060 --> 00:32:32.740
It's kind of broken
down into event levels.

00:32:32.740 --> 00:32:34.310
These are the four main levels.

00:32:34.360 --> 00:32:37.670
I believe there might be one or two more,
but these are the ones that you're

00:32:37.670 --> 00:32:39.440
really going to be concerned with.

00:32:39.490 --> 00:32:43.410
At the application level,
these are events that are to

00:32:43.470 --> 00:32:47.760
be received by the application
at the highest possible level.

00:32:47.760 --> 00:32:51.810
They have the highest possible priority,
and they're usually

00:32:51.890 --> 00:32:53.620
reserved for things like

00:32:53.880 --> 00:33:13.510
Human Interface Toolbox Commands.

00:33:13.510 --> 00:33:13.510
You can accept any Carbon event at
this level because you can always

00:33:13.510 --> 00:33:13.510
handle it as it's the highest
application level and everything

00:33:13.510 --> 00:33:13.510
will actually roll down into it.

00:33:13.510 --> 00:33:13.510
But it's kind of the catch-all
and if you don't handle it here,

00:33:13.510 --> 00:33:13.510
it gets kicked back to the
system and usually if you've

00:33:13.510 --> 00:33:13.510
installed a default handler,
the default handler

00:33:13.510 --> 00:33:13.510
will take it from there.

00:33:13.750 --> 00:33:17.600
Window events or the window event level
constrains all your events to the window.

00:33:17.600 --> 00:33:20.630
This becomes really important
for things like mouse events.

00:33:20.670 --> 00:33:23.320
If you register for mouse
events at the window level,

00:33:23.500 --> 00:33:26.960
your mouse motion stops once the
cursor moves outside of the window.

00:33:26.960 --> 00:33:29.320
Certain games and certain
applications will want to take

00:33:29.320 --> 00:33:31.040
advantage of something like that.

00:33:31.040 --> 00:33:33.240
Others,
for full-screen apps or for windowed

00:33:33.240 --> 00:33:35.820
applications where if you have
multiple monitors and you want

00:33:35.820 --> 00:33:38.680
to have the mouse still continue
moving the screen in the game,

00:33:38.930 --> 00:33:41.470
even after you pass outside the window,
you'd want to register for your

00:33:41.550 --> 00:33:44.920
mouse events at the application
level instead of at the window level.

00:33:45.060 --> 00:33:46.450
Otherwise,
you'll end up pinning your mouse

00:33:46.450 --> 00:33:50.820
cursor to the side of the window,
at least as far as the game is concerned,

00:33:50.820 --> 00:33:53.780
while all the mouse moving events
and stuff will stop once that

00:33:53.780 --> 00:33:55.200
cursor leaves the window region.

00:33:56.950 --> 00:34:00.050
The menu event level is
pretty much just that.

00:34:00.060 --> 00:34:03.380
It's all about your menus and that's
where you would register for handling

00:34:03.380 --> 00:34:07.540
commands off your menus and for
anything else that's related to them.

00:34:07.540 --> 00:34:10.470
And then the control level is basically
the lowest level possible and it

00:34:10.470 --> 00:34:15.100
allows you to install individual event
handlers right into the control itself.

00:34:15.100 --> 00:34:18.560
My personal preference is actually
to have one handler deal with all the

00:34:18.650 --> 00:34:22.280
controls in my application if I can,
as opposed to having individual

00:34:22.280 --> 00:34:24.480
handlers on the controls themselves.

00:34:25.680 --> 00:34:28.920
A little further down
are the event classes.

00:34:28.920 --> 00:34:31.360
The event levels is where you
register for these events.

00:34:31.410 --> 00:34:33.530
The event classes are the actual
events that you register for.

00:34:33.640 --> 00:34:35.480
I just put some samples up there.

00:34:35.480 --> 00:34:38.160
This is certainly by no
means an exhaustive list,

00:34:38.160 --> 00:34:42.880
but these are some of the more important
ones that you'll be using quite often.

00:34:42.880 --> 00:34:46.160
Mouse events, keyboard events,
window events, and menu events.

00:34:46.160 --> 00:34:51.150
As I discussed just a few minutes ago,
the mouse events will give

00:34:51.150 --> 00:34:53.180
you things like button clicks.

00:34:53.280 --> 00:34:56.120
They'll give you your motion,
your mouse deltas.

00:34:56.130 --> 00:34:59.120
That's a particularly important
one for game developers.

00:34:59.120 --> 00:35:00.740
We were asked about that quite a bit.

00:35:00.810 --> 00:35:02.740
They've been there for quite a while.

00:35:02.940 --> 00:35:04.290
They work really, really well.

00:35:04.520 --> 00:35:07.470
As a matter of fact,
I use them in several of my applications.

00:35:09.790 --> 00:35:17.600
and the mouse class events deal
entirely with the mouse scroll wheels,

00:35:17.720 --> 00:35:19.620
motion, all that kind of stuff.

00:35:19.690 --> 00:35:22.380
Your keyboard events will give you
everything from key up and key down,

00:35:22.390 --> 00:35:25.700
all the modifiers,
and everything related to

00:35:25.700 --> 00:35:27.650
receiving events from keyboards.

00:35:27.760 --> 00:35:30.140
Window events give you things
like activation and deactivation,

00:35:30.140 --> 00:35:34.710
show and hide, grow, shrink,
all those sort of things that

00:35:34.710 --> 00:35:37.090
control the behavior of a window.

00:35:38.210 --> 00:35:41.600
The menu events are,
as I described just a few minutes ago,

00:35:41.670 --> 00:35:44.790
dealing with selections of items,
which items are selected.

00:35:44.850 --> 00:35:47.670
I believe also through the
Carbon event structures how you can

00:35:47.720 --> 00:35:53.130
programmatically change the text in
your menu items and things like that.

00:35:54.890 --> 00:35:57.350
So what is an event,
how do you get these events and

00:35:57.350 --> 00:35:59.020
how do you register for them?

00:35:59.020 --> 00:36:02.070
Well, as part of the installation,
as you'll see in a minute,

00:36:02.070 --> 00:36:05.460
you have to give an event type
count as to how many events

00:36:05.520 --> 00:36:11.320
you're actually passing in to the
handle that you're installing.

00:36:11.320 --> 00:36:17.970
This particular one comes
from application level events.

00:36:18.040 --> 00:36:20.480
It's the event type specifier,
and I just called it App Event List,

00:36:20.520 --> 00:36:23.060
which is a list of all the events
that you want to handle at this

00:36:23.110 --> 00:36:24.850
particular application level.

00:36:24.910 --> 00:36:28.490
You can pass any event list to any
level to install on any handle.

00:36:28.500 --> 00:36:33.140
I just happened to choose the
application one for demonstration here.

00:36:33.140 --> 00:36:35.540
I've highlighted a couple
of the more important ones.

00:36:35.550 --> 00:36:39.440
The KEVENTCLASS command, that was,
as I discussed, about the human interface

00:36:39.440 --> 00:36:41.570
toolbox commands.

00:36:41.570 --> 00:36:47.020
These are things like OK, Redo, Undo,
Cancel.

00:36:47.020 --> 00:36:48.940
That's where all of
those will get handled.

00:36:48.940 --> 00:36:51.410
Obviously the mouse events,
as I just described,

00:36:51.690 --> 00:36:52.660
are not going to be handled.

00:36:52.720 --> 00:36:54.720
You can see how these are broken down.

00:36:54.720 --> 00:36:57.940
I'm actually registering here for,
as far as the mouse event classes go,

00:36:58.030 --> 00:37:03.540
I'm registering for mouseDown, mouseUp,
and for mouseDragon and mouseWheelMoved.

00:37:03.750 --> 00:37:07.710
I'm not registering for mouseDeltas,
but that's another one that

00:37:07.710 --> 00:37:09.020
you could also register for.

00:37:09.110 --> 00:37:11.450
At that point,
wherever you installed that

00:37:11.680 --> 00:37:14.790
particular handler is where
that event would get handled.

00:37:16.780 --> 00:37:20.580
This is what they look like.

00:37:20.580 --> 00:37:28.460
As I said, the command processes, OK,
QUIT, COMMAND, OK, QUIT, UNDO, etc.

00:37:28.460 --> 00:37:31.410
This is how they're structured.

00:37:32.110 --> 00:37:34.260
How do you actually install these things?

00:37:34.540 --> 00:37:39.990
For basic use, what you want to do is,
before you install any event handler,

00:37:39.990 --> 00:37:41.330
in case there's something
you don't cover,

00:37:41.330 --> 00:37:43.940
you always want to install
the standard handlers.

00:37:43.940 --> 00:37:46.980
This is not required,
but it's usually a good idea.

00:37:47.040 --> 00:37:48.930
They're very simple to do.

00:37:49.000 --> 00:37:51.960
The function protocols are right there.

00:37:52.460 --> 00:37:55.320
What you want to do is when you call
the Install the Standard Event Handler,

00:37:55.400 --> 00:37:58.000
say you want to install it on the window,
that's the top one over here.

00:37:58.190 --> 00:38:00.150
This is Get Window Event Target.

00:38:00.150 --> 00:38:01.670
You pass in a pointer to your window.

00:38:01.840 --> 00:38:03.990
I believe it's a window
ref or a window pointer.

00:38:04.260 --> 00:38:06.190
That's all you have to do.

00:38:06.240 --> 00:38:08.960
Then the system will automatically go
through and it will put the default

00:38:08.960 --> 00:38:11.180
handlers and install them on that window.

00:38:11.180 --> 00:38:14.900
Now it will handle
everything that you don't.

00:38:14.900 --> 00:38:17.410
If you explicitly specify
other events that you want to

00:38:17.410 --> 00:38:20.190
handle in your application,
those will take precedence

00:38:20.190 --> 00:38:21.840
over the standard handler.

00:38:22.400 --> 00:38:25.870
The other two here are just
the standard handlers for the

00:38:25.870 --> 00:38:27.960
application and menu events.

00:38:27.960 --> 00:38:30.460
For the application event target,
you don't have to pass anything in.

00:38:30.530 --> 00:38:33.280
It will just grab the current
process and install it on that.

00:38:33.810 --> 00:38:37.680
Whereas the menu event handler,
you have to pass in a

00:38:37.680 --> 00:38:38.350
handle to your menu.

00:38:40.850 --> 00:38:43.560
This is the basic setup
of installing your own.

00:38:43.600 --> 00:38:47.320
The app command processor variable
right there is actually an

00:38:47.490 --> 00:38:51.460
event universal process pointer.

00:38:51.460 --> 00:38:53.420
We're just creating it
with new event handler UPP.

00:38:53.710 --> 00:38:57.330
The function parameter there is
actually the name of the function

00:38:57.330 --> 00:39:01.790
that we're going to use as a
callback when we receive events.

00:39:02.380 --> 00:39:04.750
The following function there,
Install Application Event Handler,

00:39:04.880 --> 00:39:09.000
is actually a macro for
Install Event Handler,

00:39:09.000 --> 00:39:14.360
but you can see these
all in carbonevents.h.

00:39:14.360 --> 00:39:18.180
It's really just kind of a
shortcut for installing a

00:39:18.180 --> 00:39:21.080
handler into the application.

00:39:21.080 --> 00:39:24.140
The first parameter there
is our command processor,

00:39:24.140 --> 00:39:27.800
which is the routine that will be
called as our callback and will

00:39:27.800 --> 00:39:29.700
deal with the events directly.

00:39:29.700 --> 00:39:32.330
As I showed you earlier,
getEventTypeCount will pass in

00:39:32.350 --> 00:39:35.270
the number of events that you
specified in the app event list.

00:39:35.310 --> 00:39:38.580
It's kind of handy because that way
you don't have to count up how many

00:39:38.580 --> 00:39:42.330
events you have in your event list and
then have to pass that in manually.

00:39:42.380 --> 00:39:43.800
It just does it for you.

00:39:43.800 --> 00:39:46.590
The app event list there is that
list of events that we created

00:39:46.590 --> 00:39:48.880
before with the event type spec.

00:39:48.880 --> 00:39:53.820
You can pass in any user data if you
want to through the next parameter.

00:39:53.820 --> 00:39:58.210
If you want to keep a handle to this
particular routine after you install it,

00:39:58.210 --> 00:40:00.680
you can pass in an event
handler ref at the end.

00:40:00.680 --> 00:40:01.300
I never do.

00:40:01.300 --> 00:40:05.250
All of your event handlers will
get uninstalled once you quit.

00:40:08.490 --> 00:40:12.540
Timers are really useful
for a variety of things.

00:40:12.540 --> 00:40:14.720
I use them all over the place.

00:40:14.720 --> 00:40:18.670
The three main things that I do
is I use a control in my rendering

00:40:18.800 --> 00:40:23.170
loop so I can either increase or
decrease my frame rate as I need

00:40:23.170 --> 00:40:25.900
simply by reinstalling the timer.

00:40:25.900 --> 00:40:27.590
It's really useful for things like that.

00:40:27.670 --> 00:40:28.830
It works pretty well.

00:40:28.830 --> 00:40:31.850
I've never seen any major
performance problems from it,

00:40:31.850 --> 00:40:35.580
although there have been a few times
when I've passed in the wrong parameters

00:40:35.580 --> 00:40:38.520
and ended up slowing way down.

00:40:38.520 --> 00:40:40.220
It's also really good
for handling game events,

00:40:40.220 --> 00:40:41.240
application events.

00:40:41.310 --> 00:40:44.930
If you want to have a timer that's
sitting there waiting and processing

00:40:44.930 --> 00:40:49.090
anything that happens to come in,
if you want to process events

00:40:49.150 --> 00:40:52.800
that you have in your game or
create your own event loops,

00:40:52.800 --> 00:40:54.960
then this is another good way to do it.

00:40:54.960 --> 00:40:56.790
It's also good for time-based events.

00:40:56.850 --> 00:41:00.260
If you wanted to, say,
take a snapshot in the future,

00:41:00.290 --> 00:41:02.970
you just create a timer,
you pass in the start time,

00:41:03.080 --> 00:41:05.800
you pass in a firing delay,
you want to take a picture

00:41:05.890 --> 00:41:08.020
in five seconds of whatever
happens to be going on,

00:41:08.040 --> 00:41:09.490
and then the timer will fire.

00:41:09.520 --> 00:41:12.130
It's a one-shot deal,
and you've accomplished the task

00:41:12.130 --> 00:41:13.800
that you wanted to accomplish.

00:41:16.590 --> 00:41:20.110
So the first thing you want to do
is you want that event loop timer

00:41:20.630 --> 00:41:22.570
ref to keep track of your timer.

00:41:22.580 --> 00:41:26.290
You're going to need that later
for when you want to dispose of it.

00:41:26.540 --> 00:41:28.880
The timer UPP is just that.

00:41:28.880 --> 00:41:31.710
It's the universal procedure pointer for
the timer that you're going to create.

00:41:31.750 --> 00:41:35.200
Again, you will need that later for
when you want to dispose of them.

00:41:35.330 --> 00:41:41.310
The function prototype at the bottom
there is for the callback routine that

00:41:41.310 --> 00:41:44.190
the timer will call every time it fires.

00:41:44.370 --> 00:41:48.270
There's really not a whole lot
to them aside from passing in the

00:41:48.330 --> 00:41:53.570
timer ref and any other data that
you want to send to the routine.

00:41:55.180 --> 00:42:01.080
Here we create the snapshot
timer UPP by using new event

00:42:01.360 --> 00:42:05.530
loop timer UPP and we pass in,
again, the name of the routine that

00:42:05.530 --> 00:42:07.380
we want to use as our callback.

00:42:07.920 --> 00:42:14.120
The first parameter you want to pass
in is where you want to install it,

00:42:14.120 --> 00:42:16.930
as in if you want to install
it on your application,

00:42:16.930 --> 00:42:18.930
which is pretty much the default.

00:42:18.980 --> 00:42:22.500
I actually don't know if you can install
it on somebody else's application.

00:42:22.500 --> 00:42:24.870
I haven't tried that,
but it would be pretty funny

00:42:24.870 --> 00:42:27.640
if you could actually install a
timer into somebody else's app.

00:42:27.670 --> 00:42:30.440
I haven't tried that.

00:42:30.440 --> 00:42:33.800
The next parameter is the start delay,
and the following parameter

00:42:33.800 --> 00:42:38.200
after that is the duration,
or the time interval between each firing.

00:42:38.200 --> 00:42:41.170
You'll notice at the end of that that
I have a variable attached to the

00:42:41.170 --> 00:42:43.260
multiplication of the constant there.

00:42:43.280 --> 00:42:46.950
It's because this code
actually comes right out of the

00:42:47.260 --> 00:42:53.880
CarbonGL snapshot demo that you'll
be seeing in just a few minutes.

00:42:53.880 --> 00:42:59.700
What I do is I multiply the milliseconds
by my time interval so I can have it

00:42:59.700 --> 00:43:02.900
take snapshots at varying intervals.

00:43:03.260 --> 00:43:06.920
The Snapshot Timer UPP is the
one we created just above there.

00:43:06.920 --> 00:43:09.200
The next parameter is any
user data you want to send.

00:43:09.200 --> 00:43:13.560
The last parameter is that timer ref
we created on the previous screen.

00:43:15.900 --> 00:43:19.370
So you've got this thing created
and you're happily sailing along,

00:43:19.370 --> 00:43:20.420
but now you want to get rid of it.

00:43:20.660 --> 00:43:22.260
So what do you do?

00:43:22.690 --> 00:43:26.650
Remove event loop timer and
dispose event loop timer UPP.

00:43:26.760 --> 00:43:29.240
Those are the only two functions
that you really need to call

00:43:29.260 --> 00:43:30.790
to get rid of your timers.

00:43:31.010 --> 00:43:35.920
The first one you pass in the timer ref,
the last one you pass in the timer UPP.

00:43:36.340 --> 00:43:38.590
That gets rid of them and stops
them from firing regardless

00:43:38.590 --> 00:43:39.750
of where they happen to be.

00:43:41.170 --> 00:43:43.710
I always clear the pointers on my timers.

00:43:43.790 --> 00:43:46.980
I use them for various other
things like I will look at them

00:43:46.980 --> 00:43:48.530
and see if they're actually valid.

00:43:48.530 --> 00:43:50.690
If they're valid,
I know I'm in the middle of taking

00:43:50.690 --> 00:43:53.660
a sequence or I'm in the middle
of doing something in the timer,

00:43:53.660 --> 00:43:55.520
so I don't go through and
start another sequence.

00:43:55.560 --> 00:43:58.420
If somebody happens to be
pressing one of the activation

00:43:58.420 --> 00:44:01.360
buttons very rapidly and it says,
"Start another timer,

00:44:01.360 --> 00:44:04.340
start another timer,
start another timer," well,

00:44:04.360 --> 00:44:07.740
I go through and I check and
make sure that those are null.

00:44:07.740 --> 00:44:09.940
It's not required that you do this.

00:44:09.940 --> 00:44:11.260
I just do it as a good habit.

00:44:13.700 --> 00:44:16.880
Now we'll move on into
QuickTime and OpenGL.

00:44:16.880 --> 00:44:20.850
Most of our demonstrations that
we've done with QuickTime and

00:44:20.850 --> 00:44:24.770
OpenGL in the past have been
with getting movies into OpenGL,

00:44:24.770 --> 00:44:29.250
getting images into OpenGL,
using all the various data that

00:44:29.250 --> 00:44:32.400
QuickTime has as an input into OpenGL.

00:44:32.400 --> 00:44:35.970
Well,
I've kind of reversed that and now I'm

00:44:35.970 --> 00:44:39.340
using OpenGL as input into QuickTime.

00:44:39.340 --> 00:44:41.230
There's three ways that I'm
going to show you how to do this.

00:44:41.280 --> 00:44:44.550
The QuickTime snapshots are
actually just single image files

00:44:44.560 --> 00:44:47.080
that are taken out of OpenGL.

00:44:47.080 --> 00:44:50.840
The snapshot sequences are image
files that are created based on the

00:44:50.840 --> 00:44:54.160
content of an OpenGL context over time,
and then a QuickTime movie

00:44:54.160 --> 00:44:55.650
from OpenGL is just that.

00:44:55.700 --> 00:44:59.900
It creates a movie based on the content
that was in the OpenGL buffer at the

00:44:59.900 --> 00:45:02.360
time that the movie was being created.

00:45:03.710 --> 00:45:06.940
So like I said, the snapshot uses data
from an OpenGL context to

00:45:06.940 --> 00:45:09.740
build a simple image file.

00:45:09.730 --> 00:45:10.710
It's one function.

00:45:10.860 --> 00:45:13.760
It's a single function
that creates a single file.

00:45:13.840 --> 00:45:15.960
The file format and type is arbitrary.

00:45:16.020 --> 00:45:19.600
You can specify any format that
QuickTime happens to support,

00:45:19.600 --> 00:45:23.290
which is--it keeps increasing
with every release that they do.

00:45:23.390 --> 00:45:27.230
The whole goal here was to let
QuickTime do all of the work for you as

00:45:27.270 --> 00:45:29.860
far as getting the image out to disk.

00:45:30.010 --> 00:45:31.910
You don't have to worry about
swizzling it around much.

00:45:31.910 --> 00:45:34.090
You don't have to worry about
processing it or writing

00:45:34.190 --> 00:45:35.730
your own file format parser.

00:45:35.740 --> 00:45:37.470
QuickTime does it all for you.

00:45:38.760 --> 00:45:41.870
So the basic methodology of what
we're doing is we're using GL read

00:45:41.870 --> 00:45:45.700
pixels to get the image data out
of OpenGL in the first place.

00:45:45.730 --> 00:45:49.820
Then we create a new GWorld with
that data so that we now have the

00:45:49.820 --> 00:45:54.130
OpenGL image data in main memory in
a format that QuickTime recognizes.

00:45:54.140 --> 00:45:58.930
Then you set up QuickTime to create
the image file with that data.

00:45:58.930 --> 00:46:01.080
And those steps are very, very simple.

00:46:01.080 --> 00:46:04.570
And it really just kind of follows
the same methodology as most of the

00:46:04.600 --> 00:46:10.490
other QuickTime imaging methods,
which are you do a variety of things.

00:46:10.490 --> 00:46:14.240
You specify your inputs, your outputs,
and you just tell it to do it,

00:46:14.260 --> 00:46:15.940
and QuickTime just does.

00:46:15.940 --> 00:46:17.910
The final step is to export
the data to the file.

00:46:19.680 --> 00:46:20.600
So how do you do that?

00:46:20.600 --> 00:46:22.220
How do you get data out of OpenGL?

00:46:22.400 --> 00:46:23.840
This is a pretty basic operation.

00:46:23.940 --> 00:46:28.550
The first thing you want to do is
set your read buffer to the back.

00:46:28.890 --> 00:46:30.300
This is default.

00:46:30.300 --> 00:46:33.240
OpenGL will always read from the back
buffer unless you specify otherwise,

00:46:33.330 --> 00:46:36.760
but I've found that it's usually a good
idea to specify it anyways in case you

00:46:36.760 --> 00:46:38.670
have been in some other part of your app.

00:46:38.740 --> 00:46:40.960
If you've been reading from the
front or if you've been reading

00:46:40.990 --> 00:46:43.920
from an aux buffer or from the
depth buffer or something like that,

00:46:43.920 --> 00:46:47.690
then you want to go ahead and set it back
to the back buffer so you can read out

00:46:47.690 --> 00:46:49.610
everything that's been drawn into it.

00:46:51.600 --> 00:46:53.560
The next command is GL read pixels.

00:46:53.600 --> 00:46:57.100
The first four parameters are
the dimensions of the area

00:46:57.100 --> 00:46:58.280
that you want to read out.

00:46:58.360 --> 00:47:01.200
In this case,
I've hard-coded it to 640 by 480.

00:47:01.320 --> 00:47:04.430
I start at 00, which for OpenGL is the
lower left-hand corner,

00:47:04.570 --> 00:47:08.380
and end it at 640 and 480,
which is the upper right-hand corner.

00:47:08.460 --> 00:47:12.300
So I'm reading out the entire
contents of the back buffer as they

00:47:12.300 --> 00:47:14.700
stand when this command is issued.

00:47:15.160 --> 00:47:18.080
The next parameter to GL read
pixels is the format of the

00:47:18.080 --> 00:47:20.480
pixels that you want to read out.

00:47:20.480 --> 00:47:25.200
In this instance,
it's a reversed format which is BGRA.

00:47:25.200 --> 00:47:27.630
There's a reason for this that
I will go into momentarily,

00:47:27.750 --> 00:47:30.170
that you want to read things out in BGRA.

00:47:30.170 --> 00:47:32.170
It makes things much easier.

00:47:32.170 --> 00:47:35.480
It also puts you on the
fast path through OpenGL.

00:47:35.480 --> 00:47:38.220
The next parameter there is the type.

00:47:38.320 --> 00:47:41.600
So actually,
what is the type of one pixel?

00:47:41.600 --> 00:47:44.350
In this case,
we're talking about an unsigned

00:47:44.350 --> 00:47:49.670
integer that is broken down into four
8-bit fields that are now reversed

00:47:49.670 --> 00:47:53.160
to match the BGRA type that we have.

00:47:53.550 --> 00:47:55.330
Finally,
you pass in a handle to a data buffer,

00:47:55.510 --> 00:47:57.760
and it is very important that
you allocate enough memory

00:47:57.760 --> 00:48:00.280
to that data buffer before
you make this function call.

00:48:00.280 --> 00:48:02.350
GL read pixels will not
allocate memory for you.

00:48:03.650 --> 00:48:06.660
The last function there
is invert GL image,

00:48:06.660 --> 00:48:09.970
which is just a little function that
I wrote to swizzle the image around

00:48:09.970 --> 00:48:13.100
and get it into the proper orientation.

00:48:13.100 --> 00:48:17.980
When you read data out of OpenGL,
it will be upside down and inverted.

00:48:17.980 --> 00:48:20.610
So in order to get it to a
normal screen orientation,

00:48:20.610 --> 00:48:23.120
so it's just as you see it
on the screen from OpenGL,

00:48:23.290 --> 00:48:24.730
you have to swizzle it around.

00:48:24.830 --> 00:48:26.900
Now, this particular function
takes the data buffer,

00:48:26.900 --> 00:48:29.460
the image size,
and then the row bytes because it

00:48:29.460 --> 00:48:33.510
actually goes through and does a
four-byte reversal all the way across.

00:48:33.510 --> 00:48:39.220
So you actually get the proper image and
the proper format all the way through.

00:48:39.220 --> 00:48:42.160
Now when you reverse BGRA,
what do you come out with?

00:48:42.270 --> 00:48:42.730
ARGB.

00:48:42.760 --> 00:48:45.860
That happens to be the "native"
format that the Macintosh supports,

00:48:45.860 --> 00:48:47.880
and that's what puts you on
the fast path through OpenGL.

00:48:50.960 --> 00:48:52.760
So the next thing we want to
do is create a new G World.

00:48:52.810 --> 00:48:55.020
It's very important to use
new G World from pointer

00:48:55.020 --> 00:48:56.320
and not just new G World.

00:48:56.320 --> 00:49:00.170
New G World will give you a buffered
G World which you do not want.

00:49:00.170 --> 00:49:04.210
At that point you would end up with
an image that's going to be off by

00:49:04.380 --> 00:49:08.680
a great deal because it's going to
add an extra padding on the rows.

00:49:08.680 --> 00:49:11.100
So new G World from pointer
gives you just a straight

00:49:11.100 --> 00:49:13.050
G World with no padding whatsoever.

00:49:13.140 --> 00:49:15.790
The first parameter is the destination
G World that you want to use,

00:49:15.820 --> 00:49:18.340
which is a variable that
you would have specified.

00:49:18.340 --> 00:49:19.120
The next is the format.

00:49:19.120 --> 00:49:22.720
You'll notice that this is 32-bit ARGB,
which is exactly the reverse of

00:49:22.720 --> 00:49:26.010
the one that I specified when
reading the data out of OpenGL.

00:49:26.010 --> 00:49:29.360
Now that we've swizzled it around
with the invert GL image function,

00:49:29.430 --> 00:49:33.070
it is in this proper format
and should be no problem.

00:49:33.320 --> 00:49:35.620
The next parameter there is a rectangle,
the bounding rect of the

00:49:35.620 --> 00:49:38.200
region that you're reading in.

00:49:38.200 --> 00:49:39.960
The next three parameters
are color table,

00:49:39.960 --> 00:49:40.950
G device, and flags.

00:49:41.000 --> 00:49:43.200
You can pass zero or null.

00:49:43.200 --> 00:49:47.240
They don't really have much effect
in this particular situation.

00:49:47.240 --> 00:49:50.600
The parameter down near the bottom there,
the data buffer, that's the actual data

00:49:50.640 --> 00:49:52.710
that we read out of OpenGL.

00:49:52.780 --> 00:49:56.910
We'll pass that in there and
this quick draw is going to build

00:49:57.000 --> 00:49:58.980
the new G world with that data.

00:49:59.050 --> 00:50:00.360
Finally, we pass in the row bytes.

00:50:00.440 --> 00:50:02.770
At the end of this,
we're going to need to

00:50:02.850 --> 00:50:05.880
create a file spec somewhere,
as that's usually what

00:50:05.880 --> 00:50:08.650
QuickTime wants to deal with,
for QuickTime to use to write out the

00:50:08.720 --> 00:50:10.340
image when we finally get to that step.

00:50:16.350 --> 00:50:20.210
QuicktimeComponents.h has a list
of the OS file type or OS type

00:50:20.210 --> 00:50:24.240
file specifications for all the
various formats that it supports.

00:50:24.240 --> 00:50:26.530
In this particular instance,
I'm using JPEG files.

00:50:26.530 --> 00:50:28.900
They were the easiest
for me to deal with.

00:50:29.180 --> 00:50:30.900
So these are the real,
I was talking about the really

00:50:30.900 --> 00:50:32.740
simple steps that it takes
to get QuickTime set up.

00:50:32.850 --> 00:50:34.100
Well these are them.

00:50:34.120 --> 00:50:36.500
You just open a default component,
you tell it what the type is,

00:50:36.500 --> 00:50:39.100
in this case we're going to
graphics exporter component.

00:50:39.100 --> 00:50:42.180
We pass in the file type,
in this case OS file type

00:50:42.220 --> 00:50:44.030
would be set to be a JPEG.

00:50:44.110 --> 00:50:47.810
And then finally you pass in
the graphics exporter component,

00:50:47.810 --> 00:50:51.240
or the address of the graphics exporter
component that you want to use,

00:50:51.240 --> 00:50:54.370
which is another variable you
would have specified above.

00:50:54.380 --> 00:50:56.290
Following that you
specify the input GWIRL,

00:50:56.290 --> 00:50:57.840
which is the GWIRL we just created.

00:50:57.840 --> 00:50:59.170
You just pass that to it.

00:50:59.170 --> 00:51:02.420
Again, you're passing in the graphics
exporter component first,

00:51:02.650 --> 00:51:03.620
and then you pass in the GWIRL.

00:51:05.010 --> 00:51:08.750
Following that, you pass in that file
spec we just talked about.

00:51:08.820 --> 00:51:10.540
That sets the output file
where QuickTime is going to

00:51:10.540 --> 00:51:11.610
actually write out its image.

00:51:14.970 --> 00:51:17.230
Next, if you need it for the file
format that you're using,

00:51:17.230 --> 00:51:19.970
you'll want to specify
the compression quality.

00:51:20.030 --> 00:51:23.240
At this point,
I've specified lossless quality.

00:51:23.240 --> 00:51:25.900
There are a variety of
different ones that you can use.

00:51:25.900 --> 00:51:28.740
Lossless will probably provide
the largest possible image and

00:51:28.740 --> 00:51:31.350
the best possible quality for you,
but you can adjust that

00:51:31.350 --> 00:51:33.070
depending on what you want to do.

00:51:33.350 --> 00:51:37.460
Finally, the command that really does the
work there is "do export." Again,

00:51:37.470 --> 00:51:39.420
you just pass in which
component you want to use,

00:51:39.460 --> 00:51:41.200
which is the one you've
been using all along,

00:51:41.210 --> 00:51:43.270
and out it goes.

00:51:43.320 --> 00:51:45.270
That's what tells QuickTime,
"Do the work.

00:51:45.320 --> 00:51:46.090
Write out the file.

00:51:46.380 --> 00:51:47.430
Give me the image.

00:51:47.530 --> 00:51:51.890
We're done." Finally, as a clean-up step,
you'll want to dispose of your

00:51:51.890 --> 00:51:54.690
component and close the component

00:51:56.460 --> 00:52:00.940
So the snapshot sequence actually
extrapolates on this function itself.

00:52:00.950 --> 00:52:03.390
We started with one function which
was just taking the snapshot,

00:52:03.490 --> 00:52:06.860
and the snapshot sequence is
going to use that function over

00:52:07.130 --> 00:52:12.590
time to take a sequence of image
shots from the same back buffer.

00:52:12.750 --> 00:52:14.470
Again, your type and format is arbitrary.

00:52:14.470 --> 00:52:15.300
It doesn't matter.

00:52:15.300 --> 00:52:17.790
Whatever you want to use,
you can use here as well.

00:52:17.790 --> 00:52:21.680
And this will also be using the
Carbon timers to generate the sequence.

00:52:25.740 --> 00:52:30.250
So, the way I controlled it from within
the timer was I just looked to

00:52:30.280 --> 00:52:34.820
see how many frames that I had and
how many frames I wanted to take,

00:52:34.820 --> 00:52:37.020
and I decrement that every
time I go through the loop.

00:52:37.060 --> 00:52:40.550
Once I hit zero,
we stop the timer and stopping the

00:52:40.860 --> 00:52:45.790
timer code was exactly what you
saw earlier with removing timers.

00:52:46.170 --> 00:52:48.080
In Windows Snapshot,
I'm just passing in the main window.

00:52:48.120 --> 00:52:51.790
It happens to be the function
parameter that that particular

00:52:51.790 --> 00:52:53.520
snapshot function wants.

00:52:53.520 --> 00:52:54.500
It's just how it's set up.

00:52:54.560 --> 00:52:57.070
What you'd want to do here is
you'd want to take your snapshot,

00:52:57.070 --> 00:53:01.260
call your function,
and then decrement your frame count.

00:53:02.840 --> 00:53:08.040
So with QuickTime Movies,
it follows the same methodology.

00:53:08.230 --> 00:53:11.190
However, what you're going to be doing
is you're going to be reading

00:53:11.190 --> 00:53:12.380
the images into a buffer.

00:53:12.440 --> 00:53:15.880
As a matter of fact,
I re-architected the application.

00:53:15.880 --> 00:53:19.010
Initially, it was just the snapshot
sequence was doing all the

00:53:19.090 --> 00:53:20.980
QuickTime stuff all in one block.

00:53:21.130 --> 00:53:25.260
But to make things a little smoother,
what I did was I re-architected it

00:53:25.260 --> 00:53:28.810
to follow this particular format,
which is it reads the data from

00:53:28.810 --> 00:53:32.650
OpenGL as fast as it possibly can,
throws it into a buffer,

00:53:32.680 --> 00:53:36.280
and an asynchronous task comes
along to process that buffer

00:53:36.280 --> 00:53:37.890
and write them out to disk.

00:53:38.200 --> 00:53:40.220
Now with the QuickTime Movie,
what you'll be doing is

00:53:40.220 --> 00:53:42.770
you'll be creating a movie
using Add Movie to Frame,

00:53:42.780 --> 00:53:45.310
I believe is the function
call from QuickTime,

00:53:45.310 --> 00:53:49.100
and it'll just build the movie
right as you're going along.

00:53:49.970 --> 00:53:52.020
So again,
it's going to be using GeoReadPixels

00:53:52.100 --> 00:53:55.280
to grab the back buffer and to
send it off into the G world,

00:53:55.290 --> 00:53:58.090
or into the G world
buffer as the case may be.

00:53:58.310 --> 00:54:04.130
I created an array that is of an
arbitrary size at the present time,

00:54:04.340 --> 00:54:07.650
but you can obviously hard code it or
you can specify a certain amount of

00:54:07.650 --> 00:54:09.160
memory that you want to take up with it.

00:54:09.160 --> 00:54:11.800
It all depends on how you want
to architect your application.

00:54:11.900 --> 00:54:14.360
The key here is to have a
separate thread asynchronously

00:54:14.360 --> 00:54:16.480
processing that particular buffer.

00:54:16.480 --> 00:54:20.000
You want to go through there and
have it go through in a... If you're

00:54:20.000 --> 00:54:22.340
on a dual processor machine,
use the other processor.

00:54:22.340 --> 00:54:24.530
Don't be taking up the processor
that's actually processing

00:54:24.530 --> 00:54:25.550
all the GL information.

00:54:25.580 --> 00:54:28.430
You can keep rendering, keep going,
keep moving along in your game.

00:54:28.430 --> 00:54:32.110
Meanwhile, in the background,
you're processing all these images out.

00:54:32.900 --> 00:54:35.940
At the end of that, once all these things
have been processed,

00:54:35.980 --> 00:54:39.830
you just have quick time to dump out
the movie in .mov or .avi format,

00:54:39.830 --> 00:54:41.030
whatever you want.

00:54:43.760 --> 00:54:45.420
Some things to remember
when you're doing this.

00:54:45.500 --> 00:54:49.070
The images do need to be swizzled
when they're coming out of GL.

00:54:49.230 --> 00:54:51.760
The routine that I'm using
is terribly unoptimized,

00:54:51.880 --> 00:54:55.940
and so you would want to do this
probably with AltaVec in order to

00:54:55.950 --> 00:54:58.730
get the most performance out of
it so you're not taking a hit when

00:54:58.730 --> 00:55:00.350
you're swizzling that data around.

00:55:00.560 --> 00:55:02.670
I would recommend doing the
processing of the image data

00:55:02.670 --> 00:55:04.250
before you're building your images.

00:55:04.280 --> 00:55:07.600
I'd recommend doing that asynchronously.

00:55:07.600 --> 00:55:10.130
Again, if you don't,
you're going to see a serious

00:55:10.130 --> 00:55:10.130
performance degradation.

00:55:10.540 --> 00:55:15.400
Arbitrary movie sizes require much,
much more complex array

00:55:15.400 --> 00:55:19.520
and buffer sizing routines.

00:55:19.640 --> 00:55:22.900
I did some dynamic allocation,
but I do think I've pinned it

00:55:22.900 --> 00:55:26.040
at either 128 or 256 megabytes.

00:55:26.040 --> 00:55:29.000
So it'll suck up a lot of memory,
but it is pinned in

00:55:29.000 --> 00:55:30.600
one manner or another.

00:55:30.600 --> 00:55:32.640
Your frame size and frame rate
will affect how much memory

00:55:32.700 --> 00:55:33.820
you should reserve for it.

00:55:33.820 --> 00:55:35.000
Obviously,
the bigger your OpenGL context,

00:55:35.050 --> 00:55:38.040
the more memory you're going to be taking
up with the data you read out of it.

00:55:38.040 --> 00:55:40.860
Again, again,
if you want to do this all dynamically,

00:55:40.860 --> 00:55:42.530
it's going to be more complicated.

00:55:42.530 --> 00:55:46.920
So I'm going to do a little demo.

00:55:52.610 --> 00:55:57.280
You can see what this looks like.

00:55:57.280 --> 00:55:58.600
So I've got an OpenGL context here.

00:55:58.660 --> 00:56:00.680
It's just kind of oscillating back
and forth so you can get an idea

00:56:00.680 --> 00:56:01.720
of what the motion looks like.

00:56:01.830 --> 00:56:05.400
Of course, when we click over here--it's
not obscured so we're not

00:56:05.400 --> 00:56:07.600
seeing performance decrease.

00:56:07.600 --> 00:56:09.680
When I take the first snapshot, I'm going

00:56:11.060 --> 00:56:13.330
I didn't really see much happen there.

00:56:13.480 --> 00:56:15.000
So I'll take another one.

00:56:15.000 --> 00:56:17.910
And we'll take another one.

00:56:32.720 --> 00:56:34.690
And there's the three
snapshots we took right there.

00:56:34.720 --> 00:56:35.900
Zero, one, two, and three.

00:56:35.900 --> 00:56:42.770
So if we open this up in preview.

00:56:49.560 --> 00:56:53.760
There's zero, there's one,
and there's the third one.

00:56:53.760 --> 00:56:54.960
All at different states in the context.

00:56:54.960 --> 00:57:00.400
You can see that the graph on the
bottom there is moving back and forth.

00:57:00.400 --> 00:57:02.160
So they're just kind of like
little snapshots in time.

00:57:04.200 --> 00:57:07.260
We'll get rid of those.

00:57:07.260 --> 00:57:09.480
Let's bring the application to the front.

00:57:09.480 --> 00:57:14.200
As it's still oscillating around there,
let's go ahead and do 100 milliseconds.

00:57:14.320 --> 00:57:18.260
So every 100 milliseconds we'll take
a snapshot of this moving context

00:57:18.530 --> 00:57:20.080
here for a total of 10 frames.

00:57:20.080 --> 00:57:22.200
So we click our sequence off.

00:57:22.330 --> 00:57:26.980
Notice it kind of gets a little
chunky there as it was going through,

00:57:26.980 --> 00:57:29.670
but there's all 10 snapshots.

00:57:42.920 --> 00:57:46.340
And we can just go right through these.

00:57:46.350 --> 00:57:47.690
Of course,
it would be nice if it put them in order,

00:57:47.690 --> 00:57:49.300
wouldn't it?

00:57:49.330 --> 00:57:51.380
So there's zero.

00:57:51.550 --> 00:57:53.330
There's one.

00:57:54.660 --> 00:57:57.600
There's two.

00:57:57.690 --> 00:57:59.400
Oh, great, now I'm on eight.

00:57:59.500 --> 00:58:05.410
So there's two, three, four.

00:58:08.900 --> 00:58:18.700
[Transcript missing]

00:58:24.640 --> 00:58:29.540
And then we'll go back to the slides.

00:58:29.590 --> 00:58:32.700
So, I'm going to wrap up with a little
bit about OpenGL's buffers and some

00:58:32.700 --> 00:58:33.840
operations you can do with them.

00:58:33.840 --> 00:58:36.230
I'm really going to focus
on the auxiliary buffers

00:58:36.240 --> 00:58:38.610
and then render to texture.

00:58:38.800 --> 00:58:41.090
We've had a lot of questions
recently about some of the

00:58:41.110 --> 00:58:43.680
rendering to texture stuff,
so I'm going to focus

00:58:43.780 --> 00:58:45.280
pretty heavily on that.

00:58:45.310 --> 00:58:48.170
A lot of people have resisted using
auxiliary buffers because you can't

00:58:48.310 --> 00:58:50.470
go and use them both on 9 and 10.

00:58:50.550 --> 00:58:53.880
On 9, they are available,
but it will dump you into

00:58:53.890 --> 00:58:57.460
the software renderer,
so a lot of people avoid them.

00:58:57.460 --> 00:59:03.180
This is going to show you how
to do some relatively cool

00:59:03.180 --> 00:59:03.180
things with auxiliary buffers.

00:59:03.350 --> 00:59:07.000
So some buffer basics.

00:59:07.010 --> 00:59:10.560
A lot of people make requests to
access the front buffer directly and

00:59:10.650 --> 00:59:12.300
do this and that and the other thing.

00:59:12.410 --> 00:59:14.300
You ought to leave the
front buffer alone.

00:59:14.300 --> 00:59:16.740
There's no reason to be
playing around with it.

00:59:16.740 --> 00:59:20.920
You should do all your drawing and do
all your reading from the back buffer.

00:59:20.920 --> 00:59:22.620
Whenever it needs to be
pushed to the screen,

00:59:22.620 --> 00:59:26.300
the system will handle that for you,
either the Windows Server or GL directly.

00:59:26.340 --> 00:59:29.980
There's no reason to be dinking
around with the front buffer.

00:59:30.860 --> 00:59:34.000
And finally,
a little pet peeve of mine is

00:59:34.000 --> 00:59:40.180
that nobody needs any direct
access to any of OpenGL's buffers.

00:59:40.180 --> 00:59:44.140
For one, it's not going to happen because
OpenGL happens to move its handles

00:59:44.140 --> 00:59:47.280
around internally whenever it wants to.

00:59:47.280 --> 00:59:50.770
The memory space on the graphics
cards these days is all flat.

00:59:50.770 --> 00:59:54.740
So when OpenGL needs to make some room
for a texture here or a texture there,

00:59:54.740 --> 00:59:57.340
it's going to move handles
around and shuffle things around.

00:59:57.470 --> 00:59:59.710
So you'll never know whether
or not they're current,

00:59:59.710 --> 01:00:01.530
even if you could read them anyways.

01:00:01.530 --> 01:00:04.210
If you could get a handle out of GL,
there's no guarantee that it would be

01:00:04.290 --> 01:00:06.490
current the next time you went to use it.

01:00:06.610 --> 01:00:13.060
So that's why no one is ever going
to get access to those buffers.

01:00:13.260 --> 01:00:16.150
The Depth, Accum, and Stencil Buffers.

01:00:16.240 --> 01:00:19.160
I put them on here just to kind of give,
for those of you who are not

01:00:19.160 --> 01:00:22.440
terribly familiar with OpenGL,
I put them up here because they

01:00:22.440 --> 01:00:25.520
are additional buffers that are
used very heavily by OpenGL.

01:00:25.560 --> 01:00:28.400
The Depth Buffer especially
is for ordering and face

01:00:28.480 --> 01:00:32.070
culling on your polygons,
where the Accumulation Buffer has

01:00:32.070 --> 01:00:36.080
traditionally been used for compositing,
and the Stencil Buffer is for

01:00:36.110 --> 01:00:39.640
drawing containment where you
want to just scissor out a portion

01:00:39.640 --> 01:00:42.760
of the screen and just draw to
it or remove it or do whatever.

01:00:42.990 --> 01:00:47.810
This is just kind of a little simple
overview to illustrate some of the issues

01:00:47.810 --> 01:00:50.220
that we have with the buffers of OpenGL.

01:00:51.990 --> 01:00:54.020
So what do you do with auxiliary buffers?

01:00:54.040 --> 01:00:55.900
There's three main things you can do.

01:00:55.900 --> 01:00:57.320
You've got damage repair,
you've got state saving

01:00:57.330 --> 01:00:58.340
and rendering to texture.

01:00:58.340 --> 01:01:00.650
Now this is, again,
by no means an exhaustive list,

01:01:00.700 --> 01:01:04.210
but these are the common things
that most people do with them.

01:01:04.210 --> 01:01:07.900
Damage repair means that if you move,
say, a cursor over a particular section

01:01:07.900 --> 01:01:10.150
of your OpenGL context and you
need to get the background there,

01:01:10.220 --> 01:01:13.560
you need to get that back behind it,
what you would do is you would save off

01:01:13.560 --> 01:01:17.270
a little chunk over in your auxiliary
buffer and then blit it back across

01:01:17.320 --> 01:01:19.730
whenever the cursor had left that area.

01:01:19.820 --> 01:01:22.380
State saving: If, say,
you wanted to disconnect your

01:01:22.490 --> 01:01:27.390
OpenGL context from your window and
then put it back or play QuickTime movie

01:01:27.390 --> 01:01:32.140
through there or load something else,
you could disconnect,

01:01:32.160 --> 01:01:34.040
save off your OpenGL,
or before you disconnect you

01:01:34.140 --> 01:01:36.140
save off your OpenGL state,
you read it over into

01:01:36.140 --> 01:01:39.040
the auxiliary buffer,
disconnect, and when you reconnected it,

01:01:39.100 --> 01:01:41.230
it's going to clear that buffer,
you blit it back from

01:01:41.230 --> 01:01:44.470
the auxiliary buffer,
and you've got your state back.

01:01:44.540 --> 01:01:47.230
The final thing that you can
do with it is rendered texture.

01:01:47.640 --> 01:01:50.320
Now there is still a

01:01:50.700 --> 01:01:53.530
There is still a pixel copy
involved with using auxiliary

01:01:53.530 --> 01:01:56.890
buffers to render the texture,
but it works very well and it's

01:01:56.890 --> 01:02:00.070
a whole lot less complicated
than AGL surface texture.

01:02:00.600 --> 01:02:02.380
So,
how are you going to actually render to

01:02:02.380 --> 01:02:04.110
a texture with the auxiliary buffers?

01:02:04.530 --> 01:02:07.280
Well, what you do is,
once you do all your drawing,

01:02:07.320 --> 01:02:11.470
you can go ahead and use a copy text
image or copy text sub-image to read out

01:02:11.510 --> 01:02:16.620
the particular portion of the buffer that
you want to read back in as your texture,

01:02:16.680 --> 01:02:18.880
that you want to specify as your texture.

01:02:18.960 --> 01:02:22.460
It's very easy to do, but like I said,
it still has a pixel copy.

01:02:22.460 --> 01:02:25.740
The next method is AGL Surface Texture,
which is a little more complicated,

01:02:25.770 --> 01:02:28.180
but there is no pixel
copy involved in it.

01:02:28.210 --> 01:02:30.340
Finally,
I did want to mention Arb Render Texture,

01:02:30.340 --> 01:02:32.360
which There's an extension
that has been developed by R,

01:02:32.430 --> 01:02:34.990
but we do not currently support it,

01:02:36.590 --> 01:02:38.680
As I was going through the
methodology of the aux buffers,

01:02:38.680 --> 01:02:39.260
this is it.

01:02:39.260 --> 01:02:42.640
You'd want to specify your
draw buffer as glAux0.

01:02:42.640 --> 01:02:44.910
I specified aux0 because
it's the first aux buffer.

01:02:44.980 --> 01:02:48.100
I believe our limit on
auxiliary buffers is 4,

01:02:48.100 --> 01:02:50.060
so you could do 0 through 3.

01:02:50.430 --> 01:02:52.920
Once you have that done,
you do all your drawing and you render

01:02:52.920 --> 01:02:56.890
whatever you want to in the aux buffer,
and then finally you set your read

01:02:56.930 --> 01:02:58.740
buffer to the aux buffer as well.

01:02:59.000 --> 01:03:33.500
[Transcript missing]

01:03:33.880 --> 01:03:37.560
AGL surface texture is a
little more interesting.

01:03:37.560 --> 01:03:42.240
This one actually takes a separate
OpenGL context and then the

01:03:42.240 --> 01:03:44.630
texture target and the format.

01:03:44.800 --> 01:03:48.800
The first parameter is the main
context that will be using the texture.

01:03:49.030 --> 01:03:53.240
The second and third parameter are your
texture target and your internal format.

01:03:53.240 --> 01:03:57.730
Finally,
you have the surface context that

01:03:57.730 --> 01:03:57.730
you want to be using as your texture.

01:03:57.770 --> 01:04:00.460
So the methodology of it is very simple.

01:04:00.460 --> 01:04:02.660
You create a P buffer,
an off-screen context,

01:04:02.690 --> 01:04:04.060
to use as your texture.

01:04:04.080 --> 01:04:07.800
You perform your drawing operations
and then you call AGL surface

01:04:07.800 --> 01:04:12.070
texture using the aforementioned
parameters and then you specify the

01:04:12.070 --> 01:04:16.190
surface context as the context that
you want to use as your texture.

01:04:17.310 --> 01:04:21.570
So, AGL surface texture is Jaguar only,
so it won't be terribly useful

01:04:21.570 --> 01:04:24.230
until after Jaguar is released.

01:04:24.240 --> 01:04:27.690
The Xuri buffer solution, as I said,
is available on Mac OS X only,

01:04:27.690 --> 01:04:31.440
and it does still require a pixel copy.

01:04:31.440 --> 01:04:34.280
The surface texture does
not have a pixel copy,

01:04:34.350 --> 01:04:37.610
but it does require another
OpenGL context to be present.

01:04:37.700 --> 01:04:46.600
[Transcript missing]

01:04:48.110 --> 01:04:49.560
This one's simple.

01:04:49.560 --> 01:04:53.440
Any of you guys were at Jeff's demos,
you'd have seen this one before.

01:04:53.440 --> 01:04:57.140
So basically what he's doing is the
context on the left is the surface

01:04:57.140 --> 01:05:00.540
that he's drawing into and then
he's using that as a texture on all

01:05:00.540 --> 01:05:02.520
the faces of the cube on the right.

01:05:03.320 --> 01:05:06.120
Now this uses AGL surface texture,
this does not use aux buffers.

01:05:06.180 --> 01:05:08.770
Aux buffers can do the same thing except
you wouldn't have the second context.

01:05:21.390 --> 01:05:23.920
So I think at this point I'm
going to bring Sergio back up

01:05:23.920 --> 01:05:27.120
here and he's going to go over
the roadmap and handle the Q&As.
WEBVTT

00:00:08.540 --> 00:00:10.430
Good afternoon.

00:00:10.530 --> 00:00:11.400
My name is Mark Tozer.

00:00:11.400 --> 00:00:14.840
I'm the technology
evangelist for hardware.

00:00:14.940 --> 00:00:19.660
You're in session 111, Accessing SCSI and
ATA Devices in Mac OS X.

00:00:20.780 --> 00:00:23.540
Today we'll go over lots of topics,
and this is not SCSI as

00:00:23.540 --> 00:00:26.650
SCSI hardware connecting SCSI,
so for those of you who think

00:00:26.650 --> 00:00:28.900
we're going back to SCSI,
that's not the case.

00:00:28.900 --> 00:00:29.720
This is the protocol.

00:00:29.720 --> 00:00:34.310
I'd like to invite Tim McLeod,
engineer in the mass

00:00:34.310 --> 00:00:36.830
storage software group.

00:00:44.280 --> 00:00:44.660
Thank you, Marc.

00:00:44.740 --> 00:00:54.190
So, this session today,
we're going to talk about

00:00:54.190 --> 00:00:55.940
SCSI and ATA Devices.

00:00:55.940 --> 00:00:59.030
The last couple years,
we focused on how to write

00:00:59.160 --> 00:01:02.280
drivers so that these devices
can be used by Mac OS X.

00:01:02.280 --> 00:01:04.760
This year,
we're going to focus more on how

00:01:04.760 --> 00:01:09.270
do applications make use of these
services provided by these devices.

00:01:09.300 --> 00:01:12.780
There's already many
services built into Mac OS X,

00:01:14.970 --> 00:01:18.000
The next release of JAGUAR will
be adding even more,

00:01:18.120 --> 00:01:21.930
such as scanner support
via image capture,

00:01:21.970 --> 00:01:26.440
printing support via CUPS,
and disk burning through the

00:01:26.440 --> 00:01:28.270
disk recording framework.

00:01:30.310 --> 00:01:32.840
So,
I know the question everyone here has is,

00:01:32.980 --> 00:01:35.850
what are these services,
how do they differ,

00:01:35.850 --> 00:01:38.260
and which one should you be using?

00:01:39.300 --> 00:01:41.600
So what you will actually
take away from this session is

00:01:41.600 --> 00:01:45.290
what SCSI and ATA devices are,
what we mean when we use

00:01:45.290 --> 00:01:48.340
the term SCSI or ATA,
how these devices are

00:01:48.340 --> 00:01:53.990
represented in Mac OS X,
the services that are

00:01:53.990 --> 00:01:56.540
provided by these devices,
and how to access these

00:01:56.540 --> 00:01:56.540
devices from applications.

00:01:56.770 --> 00:01:58.220
So first, what is a SCSI device?

00:01:58.270 --> 00:02:05.610
A SCSI device is defined as a device that
complies with one of the SCSI command

00:02:05.610 --> 00:02:12.390
sets as defined by the T10 committee,
which is the controlling committee

00:02:12.390 --> 00:02:15.310
for SCSI and SCSI specifications.

00:02:15.900 --> 00:02:21.540
A SCSI device can actually be connected
via different physical interconnects,

00:02:21.540 --> 00:02:25.540
such as FireWire,
ATA using the Atapi protocol, USB,

00:02:25.580 --> 00:02:28.380
or traditional SCSI parallel.

00:02:28.380 --> 00:02:35.380
More information on these can be found
at the T10 website at www.t10.org.

00:02:35.460 --> 00:02:41.310
Now, in Mac OS X, when we say SCSI,
we don't mean traditional parallel SCSI.

00:02:41.400 --> 00:02:45.050
When we do mean the traditional SCSI,
parallel SCSI,

00:02:45.060 --> 00:02:45.880
we will actually be talking
about the SCSI protocol.

00:02:45.880 --> 00:02:47.500
We will actually use
the name SCSI parallel,

00:02:47.500 --> 00:02:50.880
or the more formal name,
SCSI parallel interface.

00:02:53.610 --> 00:02:55.160
So next, what is an ATA device?

00:02:55.170 --> 00:03:00.170
Well, an ATA device is a device that
meets one of the specifications

00:03:00.180 --> 00:03:02.790
defined by the T13 Committee,
which is the controlling

00:03:02.840 --> 00:03:03.960
committee for ATA.

00:03:03.960 --> 00:03:08.290
And these are such devices as
standard ATA hard drives or

00:03:08.300 --> 00:03:13.400
PCMCIA ATA devices such as the
IBM MicroDrive or CompactFlash.

00:03:13.500 --> 00:03:21.050
And more information on this can be
found at the T13 website at www.t13.org.

00:03:23.160 --> 00:03:26.730
So SCSI and ATA devices can provide
different types of services.

00:03:27.000 --> 00:03:29.470
One is, of course,
standard storage services

00:03:29.660 --> 00:03:32.800
such as mounting volumes
and reading/writing blocks.

00:03:32.950 --> 00:03:36.830
Other are application-specific
services such as tape drives,

00:03:36.900 --> 00:03:38.760
scanners, and printers.

00:03:38.760 --> 00:03:42.640
Or a device can actually provide both,
such as DVD drives,

00:03:42.740 --> 00:03:48.050
which provide both block read and
write and an application-specific

00:03:48.050 --> 00:03:50.640
service such as disk writing.

00:03:51.990 --> 00:03:56.210
Now, there are a couple assumptions
and limitations that are placed on

00:03:56.220 --> 00:03:58.440
these type of devices in Mac OS X.

00:03:58.570 --> 00:04:01.310
One of the main assumptions
is we treat all devices as

00:04:01.310 --> 00:04:03.550
detachable from the system.

00:04:03.760 --> 00:04:08.140
So any device is designed to
be hot-pluggable regardless of

00:04:08.140 --> 00:04:10.580
what bus it's connected via.

00:04:10.930 --> 00:04:15.630
and the other one is only a single entity
can control a device at any given time.

00:04:15.740 --> 00:04:23.020
So basically one driver or application
owns the device at any time.

00:04:23.480 --> 00:04:27.020
So first, let's look at the general
model of how storage devices

00:04:27.110 --> 00:04:29.850
are presented in Mac OS X.

00:04:29.930 --> 00:04:32.930
So first you have the controller layer,
which is actually the

00:04:32.930 --> 00:04:35.510
lowest level hardware layer,
which encompasses things

00:04:35.530 --> 00:04:40.100
like the PCI chip,
the controller chip,

00:04:40.100 --> 00:04:43.680
and any of the services
provided by the hardware.

00:04:43.870 --> 00:04:47.030
To allow the transport
layer to talk to it.

00:04:47.160 --> 00:04:51.000
The transport layers actually
have requests get sent

00:04:51.080 --> 00:04:53.390
down across a physical bus.

00:04:54.290 --> 00:04:57.100
On top of the transport layer,
we have the device services layer,

00:04:57.100 --> 00:05:02.040
which is these are the services that are
provided by these devices to the system,

00:05:02.040 --> 00:05:05.840
and this is how the system and
applications access these services.

00:05:07.610 --> 00:05:10.670
And in storage on top of that,
we have the media access layer,

00:05:10.810 --> 00:05:15.450
which provides an entry point for
the BSD media shims and allows

00:05:15.790 --> 00:05:19.300
volumes to be mounted on it so that
block reading rights can occur.

00:05:21.180 --> 00:05:23.220
So first we'll look at the ATA model.

00:05:23.220 --> 00:05:27.870
So the way an ATA device fits into this
is you have the control at the bottom,

00:05:27.870 --> 00:05:32.130
which creates an IO-ATA device,
which on top is the

00:05:32.190 --> 00:05:36.680
IO-ATA block storage driver,
and this makes up the transport layer.

00:05:37.160 --> 00:05:39.600
On top of that,
in the device services layer,

00:05:39.600 --> 00:05:44.940
you have the IO-ATA block storage device,
which actually translates between

00:05:45.020 --> 00:05:48.620
the IO block storage driver,
which is the entry point into

00:05:48.620 --> 00:05:51.950
the device services layer,
for the IO media object,

00:05:52.110 --> 00:05:55.810
which represents the media in the device.

00:05:55.820 --> 00:05:58.870
And then on top of that,
you can have BSD media shims and more

00:05:58.870 --> 00:06:01.250
IO media objects that represent volumes.

00:06:03.870 --> 00:06:08.270
For SCSI storage,
and in this example we use a DVD drive,

00:06:08.330 --> 00:06:12.200
in the controller layer we
have the IO-ATA controller.

00:06:12.200 --> 00:06:15.540
The transport layer in this
case actually has three pieces.

00:06:15.540 --> 00:06:21.030
We have the IOTOPI protocol transport,
which converts between the

00:06:21.150 --> 00:06:25.260
SCSI architecture model
pieces and the ATA bus.

00:06:25.460 --> 00:06:29.780
That's how SCSI tasks get
sent to the device across ATA.

00:06:30.740 --> 00:06:34.320
On top of that we have the
IOScsi peripheral device nub,

00:06:34.320 --> 00:06:36.240
which represents the physical device.

00:06:36.240 --> 00:06:39.280
And then we have the IOScsi
peripheral device type 5 driver,

00:06:39.310 --> 00:06:42.980
which is actually what builds
and sends commands to the device.

00:06:42.980 --> 00:06:46.170
On top of that we have
the IODVD services,

00:06:46.350 --> 00:06:50.240
which provides an interface
for IODVD block storage driver,

00:06:50.540 --> 00:06:55.240
which allows system requests for reading
and writing from the IOMedia object,

00:06:55.490 --> 00:07:00.140
which allows us to read and write
blocks from the volumes on that media.

00:07:01.180 --> 00:07:03.640
So the next we have is
SCSI application-specific model.

00:07:03.650 --> 00:07:06.500
So like I said,
devices can either provide

00:07:06.500 --> 00:07:10.520
storage function or
application-specific function.

00:07:10.520 --> 00:07:13.060
In this example,
we use a FireWire tape drive.

00:07:13.120 --> 00:07:16.130
In the control layer,
we have IO FireWire family

00:07:16.130 --> 00:07:17.840
and IO FireWire SBB2.

00:07:17.840 --> 00:07:22.260
This represents the necessary
protocols for the IO FireWire

00:07:22.290 --> 00:07:27.100
serial bus protocol transport
to send commands across the bus.

00:07:28.010 --> 00:07:31.690
the IFYWire serial bus
protocol transport,

00:07:31.930 --> 00:07:37.960
Connects the SCSI architecture model
pieces with the I/O Firewire family.

00:07:37.970 --> 00:07:42.500
On top of that,
we have I/O SCSI peripheral device nub.

00:07:42.500 --> 00:07:46.480
But in this case,
since it's a device that does not

00:07:46.480 --> 00:07:52.280
have a driver already in the system,
it actually will allow the SCSI task

00:07:52.280 --> 00:07:57.130
user client to load on top of
it in the device services layer,

00:07:57.130 --> 00:07:59.510
which allows an application
to talk to the device.

00:08:02.410 --> 00:08:05.210
So there are actually several
methods of access to talk to

00:08:05.210 --> 00:08:07.060
these devices in Mac OS X.

00:08:07.060 --> 00:08:13.100
And an application can access the
provided services via these methods,

00:08:13.190 --> 00:08:17.620
the Media Access Layer and
BSD Media Shims and IR Media Filters.

00:08:17.620 --> 00:08:21.070
This is basically how you
would talk to a mounted volume.

00:08:21.080 --> 00:08:24.880
The other is user clients,
both provided and custom.

00:08:24.880 --> 00:08:29.120
Mac OS X provides some,
and it also allows third parties

00:08:29.120 --> 00:08:33.830
to provide their own for special
and specific vendor features.

00:08:33.840 --> 00:08:39.960
The IORegistry for doing very simple
transfer of the information between an

00:08:40.460 --> 00:08:43.400
application and the device's driver.

00:08:43.400 --> 00:08:47.620
And then the last thing we're actually
going to talk about are older methods

00:08:47.620 --> 00:08:52.280
of access which are being obsoleted
and how you can migrate from these.

00:08:52.280 --> 00:08:55.030
And these are such things
as the IOSSCSI Live,

00:08:55.060 --> 00:08:57.390
IOCDB Live, and SCSI Action.

00:08:59.700 --> 00:09:02.100
And so now to talk about
the first method of access,

00:09:02.220 --> 00:09:06.180
which is the media access layer,
the BSD shims and volumes,

00:09:06.180 --> 00:09:08.170
is Craig Marciniak.

00:09:08.260 --> 00:09:13.350
Thank you.

00:09:17.450 --> 00:09:18.240
Good evening.

00:09:18.240 --> 00:09:20.470
I'm Craig Marciniak,
and we're going to have

00:09:20.470 --> 00:09:22.280
so much fun tonight,
you just won't be able

00:09:22.280 --> 00:09:23.190
to contain yourself.

00:09:25.780 --> 00:09:28.510
There's a myth that mass
storage is kind of boring,

00:09:28.510 --> 00:09:30.940
and we're here to dispel that.

00:09:31.640 --> 00:09:35.810
Okay, so we're going to learn
about IO Media Objects.

00:09:35.810 --> 00:09:38.960
And the BSD and Unix experts
in here are going to have to

00:09:39.000 --> 00:09:40.590
bear with me a little bit.

00:09:40.710 --> 00:09:42.990
For the benefit of
traditional Mac programmers,

00:09:42.990 --> 00:09:47.560
I'm going to give a real brief
overview of some real basic

00:09:47.560 --> 00:09:50.900
IO functions and how the BSD APIs work.

00:09:51.280 --> 00:09:54.770
And then we'll talk a little bit about,
once we understand that,

00:09:54.770 --> 00:10:00.190
of how you get to the
BSD APIs from Carbon and Cocoa.

00:10:00.440 --> 00:10:03.500
And then I'm going to talk
about how IO filters work,

00:10:03.620 --> 00:10:06.860
which are going to be
interesting to some people here.

00:10:06.860 --> 00:10:09.660
And then to bring it all home,
tie it all together,

00:10:09.660 --> 00:10:14.090
we've prepared a zippy, fun little demo.

00:10:14.410 --> 00:10:19.650
So just to set context,
I'm going to be talking about the media

00:10:19.650 --> 00:10:24.490
access layer and the objects and the
support in that section of the stack.

00:10:27.290 --> 00:10:31.590
Okay,
IO Media Objects are contiguous logical

00:10:31.590 --> 00:10:35.440
object representations of storage.

00:10:35.440 --> 00:10:41.100
This is all abstracted up away from all
the bus specifics and idiosyncrasies.

00:10:41.140 --> 00:10:42.830
It's really pretty straightforward.

00:10:42.840 --> 00:10:48.440
It's a byte-based API that's
64-bit clean at this point.

00:10:50.140 --> 00:10:57.010
So here's the overview of the BSD stuff.

00:10:57.400 --> 00:11:01.400
Device nodes, we talk about device nodes,
you'll hear people talk

00:11:01.400 --> 00:11:02.170
about device nodes.

00:11:02.180 --> 00:11:06.480
They're nothing but file representations
of physical hardware on your machine.

00:11:06.480 --> 00:11:09.600
If you go to the directory dev
slash dev and do a listing,

00:11:09.620 --> 00:11:13.500
you're going to see file representations
of your hardware and you can

00:11:13.500 --> 00:11:15.780
open them up and read and write,
close,

00:11:15.780 --> 00:11:20.220
and we're going to learn about something
called iOcto a little bit later.

00:11:21.160 --> 00:11:29.290
The BSD interface is the
user client access point.

00:11:29.440 --> 00:11:34.840
The examples I have here are dev disk
zero and you'll see a lot of things

00:11:34.840 --> 00:11:37.090
that mirror it with an R in front of it.

00:11:37.230 --> 00:11:41.970
The R in this case for
disk zero means raw.

00:11:42.420 --> 00:11:47.160
And so it's a real straightforward,
simple, five-point API, open, read,

00:11:47.260 --> 00:11:48.560
write, close, iOctl.

00:11:48.560 --> 00:11:51.400
Some of the books,
when you go get Unix books,

00:11:51.510 --> 00:11:55.000
we'll talk about other API stuff
that we don't implement.

00:11:56.920 --> 00:12:03.830
So there are two BSD device interfaces,
the raw and the block.

00:12:04.750 --> 00:12:06.700
There's a lot of confusion about the RAW.

00:12:06.700 --> 00:12:10.980
If you go and read the,
there's the red book

00:12:10.990 --> 00:12:15.680
with the devil on it,
the design and implementation of BSD 4.4.

00:12:15.680 --> 00:12:22.320
It refers to and it talks to it and it's
known as the character device interface.

00:12:22.340 --> 00:12:26.230
This really confuses people because
this is what we're talking about

00:12:26.230 --> 00:12:30.090
here is a block interface and you
shouldn't think of characters as 8

00:12:30.140 --> 00:12:32.310
byte ASCII values or byte streams.

00:12:32.320 --> 00:12:34.010
This has nothing to do with it.

00:12:34.700 --> 00:12:40.290
This goes back to legacy terminology
for this was a way to do TTY access.

00:12:40.290 --> 00:12:44.820
So the block interface,
what we've done to try to avoid the

00:12:44.820 --> 00:12:49.160
confusion internally is we always
refer to the RAW device interface

00:12:49.260 --> 00:12:51.520
and the block device interface.

00:12:51.520 --> 00:12:55.600
If you're really interested
in the details on this,

00:12:55.770 --> 00:13:01.100
on page 201 of the design and
implementation of BSD 4.4,

00:13:01.100 --> 00:13:04.520
about halfway down the page,
there's a really good description.

00:13:04.700 --> 00:13:11.510
That brings up all this
stuff for the curious.

00:13:12.000 --> 00:13:19.890
The raw device accesses through the /dev,
R, disk, blah, blah, blah device nodes.

00:13:19.960 --> 00:13:26.260
Access must be a multiple of the
natural block size of that device or

00:13:26.360 --> 00:13:27.900
it will be rejected with an error.

00:13:27.900 --> 00:13:31.700
Low-level disk utilities
should be using this interface.

00:13:31.700 --> 00:13:39.200
Another example is,
let's say someone has a high-end database

00:13:39.200 --> 00:13:41.480
that does not want to go through the UBC.

00:13:42.060 --> 00:13:43.220
The unified buffer cache.

00:13:43.240 --> 00:13:47.850
Because they have a usage pattern that
isn't optimized for that particular

00:13:47.930 --> 00:13:50.960
caching scheme and they want to
implement their own caching scheme,

00:13:50.960 --> 00:13:54.280
they would be candidates that might
want to use the raw device interface.

00:13:56.400 --> 00:13:59.820
So the block device interface,
media is accessed through

00:14:00.200 --> 00:14:04.160
just the normal disk entry.

00:14:04.310 --> 00:14:08.240
Access does not have to be a multiple
of the natural block size of the device.

00:14:08.240 --> 00:14:13.750
You can ask for arbitrary lengths
and arbitrary addresses of stuff.

00:14:13.830 --> 00:14:17.480
The file systems generally
use this interface.

00:14:18.070 --> 00:14:21.040
So using the interfaces,
you would use the

00:14:21.040 --> 00:14:23.960
POSIX style IO functions.

00:14:23.960 --> 00:14:28.680
This is the open, read, write, close,
and iOctal.

00:14:28.680 --> 00:14:34.800
And this shouldn't be confused
with the ANSI standard C APIs.

00:14:34.800 --> 00:14:38.770
The modes follow the
established Unix semantics.

00:14:38.770 --> 00:14:43.010
Modes is the permissions,
and you can use the man page to

00:14:43.010 --> 00:14:47.800
get all the Unix semantics if
you're not familiar with them.

00:14:48.000 --> 00:14:54.000
And so once you get to this point,
you need a BSD path to do stuff.

00:14:54.000 --> 00:14:57.200
So, ending paths from Cocoa.

00:14:57.540 --> 00:15:02.820
Cocoa's NS file manager and workspace,
NS workspace, use mount points.

00:15:03.090 --> 00:15:09.520
Mount points can be translated
to BSD paths from the get

00:15:09.700 --> 00:15:12.650
mount info call or statfs.

00:15:14.260 --> 00:15:16.880
So here's an example.

00:15:17.260 --> 00:15:21.520
This is kind of goofy pseudocode.

00:15:21.810 --> 00:15:28.570
and We're going to look for something as
a mount to name that equals mount point.

00:15:28.630 --> 00:15:34.950
When we find that, there's an element off
this StataFS structure

00:15:35.120 --> 00:15:40.530
called mount to from name,
and we can get the BSD path from there.

00:15:40.660 --> 00:15:45.460
It turns out that getMountInfo
actually calls StataFS.

00:15:45.490 --> 00:15:50.880
This is a shortcut if you don't have the
requirement to iterate through stuff.

00:15:52.030 --> 00:15:54.220
So getting BSD passed from Carbon.

00:15:54.220 --> 00:15:58.780
Carbon traditional APIs use
volume reference numbers.

00:15:58.780 --> 00:16:02.220
There's a whole bunch of different ways
you can get volume reference numbers.

00:16:02.220 --> 00:16:08.320
Most people that have experience
with that know what they need.

00:16:08.320 --> 00:16:14.280
And so here's one example of taking
a VREFNUM and using the PBH get

00:16:14.280 --> 00:16:17.560
volume parameters sync call.

00:16:18.440 --> 00:16:23.310
We have the VM device ID here,
which actually turns out to be the path.

00:16:23.400 --> 00:16:26.280
So.

00:16:31.000 --> 00:16:32.940
I'm going to go through
those APIs really quick.

00:16:33.040 --> 00:16:34.060
Open.

00:16:34.060 --> 00:16:37.940
Basically,
we need to... The first argument

00:16:37.950 --> 00:16:39.130
is going to be our path.

00:16:39.260 --> 00:16:41.280
The second argument is the mode.

00:16:41.300 --> 00:16:42.660
In this case, it's a read-only.

00:16:42.660 --> 00:16:45.460
There's a pattern here.

00:16:45.460 --> 00:16:48.120
The FDU,
the file descriptor in this case,

00:16:48.120 --> 00:16:51.500
if it comes back negative one,
it failed to open,

00:16:51.500 --> 00:16:55.640
and you can use AirNode to get
refined information on that error.

00:16:55.640 --> 00:16:57.540
Again, see the man pages.

00:16:58.650 --> 00:17:04.540
The BSD design and implementation for
an operating system book is really good,

00:17:04.540 --> 00:17:07.670
and Stephen's advanced programming
in the Unix environment is

00:17:07.670 --> 00:17:08.960
also a really good reference.

00:17:10.690 --> 00:17:12.740
Read and writes are
pretty straightforward.

00:17:12.740 --> 00:17:17.410
Once we have a valid
opened file descriptor,

00:17:17.410 --> 00:17:18.440
we can pass that in.

00:17:18.440 --> 00:17:20.920
We give it our read count again.

00:17:20.920 --> 00:17:23.950
If it fails, we'll get a negative
one in the byte count,

00:17:24.050 --> 00:17:25.880
and we can go look at that error.

00:17:25.880 --> 00:17:27.720
Reads use the similar thing.

00:17:27.720 --> 00:17:28.920
Very straightforward.

00:17:30.260 --> 00:17:32.060
Now we go to IOctals.

00:17:32.230 --> 00:17:37.080
IOctals, I've also heard some people
call them IO Controls.

00:17:37.150 --> 00:17:38.670
It means IO Controls.

00:17:38.880 --> 00:17:43.020
Traditional Mac programmers,
this is just like a PB Control call.

00:17:43.020 --> 00:17:46.010
We provide a whole bunch of them for you.

00:17:46.030 --> 00:17:48.160
Actually, not that many.

00:17:48.160 --> 00:17:53.530
You can go to the IO Media BSD client
and the CD Media BSD client,

00:17:53.530 --> 00:17:57.500
and these header files will define them.

00:17:57.520 --> 00:18:02.150
The examples I have on the
bottom here are... DKIOC Eject.

00:18:02.280 --> 00:18:04.860
They look kind of hard to read at first.

00:18:04.860 --> 00:18:08.140
Historically, just for the trivia,
DK means disk.

00:18:08.270 --> 00:18:10.420
The IOC means IO Control.

00:18:10.500 --> 00:18:12.500
The first one would be an Eject.

00:18:12.500 --> 00:18:14.810
The second one is a Get Block Size.

00:18:14.810 --> 00:18:23.260
New to Jaguar, we've added some stuff
for our optical devices.

00:18:23.280 --> 00:18:30.030
The flush, excuse me,
synchronized cache call, the read talk,

00:18:30.110 --> 00:18:33.700
the read disk info and read
track information for the CDs.

00:18:33.840 --> 00:18:40.390
Then in DV, we've added read disk info
and read our zone info.

00:18:40.680 --> 00:18:45.940
So here's an example where we actually
open up and get a valid descriptor.

00:18:45.980 --> 00:18:49.500
And we're going to use the
iActl to get the block size.

00:18:49.550 --> 00:18:52.180
And once we call that,
when we come back without an error,

00:18:52.180 --> 00:18:55.380
we can actually print BS to the screen.

00:18:57.760 --> 00:19:05.660
Media filters provide block-oriented
parsing at a strategic place high

00:19:05.660 --> 00:19:09.010
up in the stack at this media
access layer that's completely

00:19:09.010 --> 00:19:12.230
abstracted away from all the buzz
specifics and idiosyncrasies.

00:19:12.720 --> 00:19:18.540
Again, this is a byte-based
API with 64-bit parameters.

00:19:18.540 --> 00:19:23.160
Last year's presentation,
we did an overview of the whole

00:19:23.230 --> 00:19:25.540
mass storage architecture.

00:19:26.400 --> 00:19:29.300
In the last chapter of that book,
we actually have a brief

00:19:29.300 --> 00:19:35.770
description and some example
code to actually write a filter.

00:19:35.910 --> 00:19:39.980
We have refined and polished
and made a much better example,

00:19:39.980 --> 00:19:43.240
which will be available
to you from our website.

00:19:43.240 --> 00:19:48.040
And we've actually, for this session,
designed and wrote a nice little

00:19:48.120 --> 00:19:49.850
filter that I'm going to call up.

00:19:50.020 --> 00:19:54.300
Dan, I'm sorry, I'm ahead of myself.

00:19:54.320 --> 00:19:59.610
The simple media filter,
I've got to back up.

00:20:11.530 --> 00:20:14.570
A simple media filter basically
takes this IO media object,

00:20:14.570 --> 00:20:20.330
which is a representation of media,
filters it, and then presents filtered

00:20:20.340 --> 00:20:21.990
media to the system.

00:20:22.600 --> 00:20:26.580
What we've done here is
the filter represents this

00:20:26.680 --> 00:20:29.400
purple color which is tinted,
this hard drive,

00:20:29.400 --> 00:20:31.240
to show that it is now filtered.

00:20:31.240 --> 00:20:35.550
As it turns out,
a partition scheme is nothing

00:20:35.550 --> 00:20:39.360
more than a complex filter.

00:20:39.360 --> 00:20:42.750
So we take an IO media
representation of a full volume

00:20:42.750 --> 00:20:47.680
and we supply multiple partitions.

00:20:48.080 --> 00:20:51.400
We can do arbitrarily complex filters.

00:20:51.400 --> 00:20:55.930
The classic example is Software Raid,
where we can take any

00:20:55.930 --> 00:20:59.240
amount of IO objects,
filter them,

00:20:59.260 --> 00:21:01.160
and present anything we really want to.

00:21:01.160 --> 00:21:03.880
There's really no limit to
what you can do with this.

00:21:03.880 --> 00:21:08.100
We expect to see lots of
interesting things from our...

00:21:09.450 --> 00:21:11.300
and other developers.

00:21:11.300 --> 00:21:14.800
Now I'll bring up
Dan Preston for the demo.

00:21:23.530 --> 00:21:28.740
So, we came up with an example
filter scheme for this session.

00:21:29.140 --> 00:21:31.680
And all it does is simple byte swapping.

00:21:31.800 --> 00:21:36.280
So, in any filter scheme,
the most important calls are the

00:21:36.280 --> 00:21:38.500
read and the write because they're
actually doing the filtering for you.

00:21:38.510 --> 00:21:44.480
So, let's go ahead and take a look
at the read example right here.

00:21:45.990 --> 00:21:49.340
Since we're actually not going to be
doing any manipulation of the data

00:21:49.340 --> 00:21:53.780
until after the read actually completes,
we need to set up a completion routine

00:21:54.390 --> 00:21:57.160
in order to post-process the data.

00:21:57.160 --> 00:21:59.260
So that's where we're going
to be doing our byte swapping.

00:21:59.260 --> 00:22:01.710
But first there's some
setup we need to do.

00:22:01.720 --> 00:22:06.010
So one of the things we're doing
is we're going to be using memory

00:22:06.010 --> 00:22:09.390
mapping instead of read bytes,
write bytes.

00:22:09.460 --> 00:22:11.950
Now,
memory mapping gets you a little bit of

00:22:11.950 --> 00:22:15.260
a performance gain over the read bytes,
write bytes.

00:22:15.620 --> 00:22:19.170
So that's kind of a win.

00:22:19.360 --> 00:22:30.460
And then as you can see,
we set up our completion structure here.

00:22:30.460 --> 00:22:33.310
And we call read.

00:22:33.310 --> 00:22:33.310
And when the read completes,
it'll go down to our completion routine.

00:22:33.310 --> 00:22:33.310
So you can see here,

00:22:33.660 --> 00:22:44.810
and David Breslis have been involved in
the development of the BITESwap project.

00:22:44.810 --> 00:22:45.310
Tim McLeod: So,
the first thing we're going to do is

00:22:45.310 --> 00:22:45.310
we're going to do a BITESwap project.

00:22:45.310 --> 00:22:45.310
So,
we're going to use the BITESwap project.

00:22:45.670 --> 00:22:51.300
So one kind of subtle aspect of this is
that you're going to take a performance

00:22:51.800 --> 00:22:54.890
hit when you initially map the buffer.

00:22:54.960 --> 00:22:58.380
So you want to kind of,
you want to do that on the client side,

00:22:58.410 --> 00:23:00.040
which is in the initial read call.

00:23:00.100 --> 00:23:05.360
Everything on the read completion
call is on the work loop,

00:23:05.360 --> 00:23:09.500
and so you want to keep your stuff there
real inexpensive and fast if possible.

00:23:09.570 --> 00:23:13.310
So that's why we map it actually up here.

00:23:13.700 --> 00:23:16.600
So that's pretty much the read routine.

00:23:16.600 --> 00:23:19.230
If we take a look at the write now.

00:23:20.350 --> 00:23:22.480
It's pretty much the same thing.

00:23:22.600 --> 00:23:25.560
You know,
we're going to save a completion

00:23:25.560 --> 00:23:30.600
routine and map the buffer.

00:23:30.970 --> 00:23:33.630
And then we're going to actually
byte swap the data as it comes in

00:23:33.640 --> 00:23:34.980
before we write it to the drive.

00:23:35.080 --> 00:23:38.030
The reason we're doing,
setting up a completion again

00:23:38.040 --> 00:23:42.660
is because you're potentially,
when you are byte swapping this,

00:23:42.660 --> 00:23:45.640
you're potentially manipulating
the client's actual

00:23:45.640 --> 00:23:47.380
in-memory copy of this data.

00:23:47.380 --> 00:23:50.100
And so there's two
ways to deal with this.

00:23:50.100 --> 00:23:54.330
You can, if it's a cheap operation,
if you're only doing something

00:23:54.330 --> 00:23:58.460
simple like byte swapping,
you can have a completion routine

00:23:58.460 --> 00:24:02.630
that will actually swap the
data back and get you back to

00:24:02.630 --> 00:24:04.900
the initial state of the data.

00:24:04.900 --> 00:24:09.800
Otherwise, if it's something expensive
like encryption or compression

00:24:09.800 --> 00:24:12.350
or something like that,
you might want to think about

00:24:12.550 --> 00:24:13.940
double buffering the data

00:24:15.580 --> 00:24:22.280
www.timclmc.com/sci-access

00:24:22.800 --> 00:24:27.980
and Chris Schaefer are the speakers.

00:24:29.950 --> 00:24:32.130
So that's a look at the code.

00:24:32.320 --> 00:24:35.990
So let's take a look
at how this all works.

00:24:36.060 --> 00:24:38.550
So we've got this text loaded
on our system right now.

00:24:38.630 --> 00:24:43.740
I'm going to go ahead and create
a disk image that's going to

00:24:43.740 --> 00:24:45.380
be filtered using our filter.

00:24:45.380 --> 00:24:52.390
So to do that, we use this command line
utility called hdiutil.

00:24:52.500 --> 00:24:57.990
Tell it how big we want it to be.

00:25:01.900 --> 00:25:03.860
We're going to pass it a partition type.

00:25:03.900 --> 00:25:12.980
Now what this partition type is,
is it's actually the content hit

00:25:13.060 --> 00:25:14.220
that gets placed on the image.

00:25:14.220 --> 00:25:18.850
So if you're creating some
sort of filtering scheme,

00:25:18.850 --> 00:25:22.110
that's how your driver is going to match,
is by the content hit.

00:25:22.150 --> 00:25:25.130
And you're going to be putting
a property in your driver's

00:25:25.130 --> 00:25:27.690
personality called content hit,
and then it's going to

00:25:27.690 --> 00:25:28.450
match on that value.

00:25:28.940 --> 00:25:30.420
So that's how our project is set up.

00:25:30.480 --> 00:25:32.500
It's set up to match on
Apple ByteSwap to HFS.

00:25:32.500 --> 00:25:35.000
So then we'll give it a name.

00:25:40.000 --> 00:25:50.200
[Transcript missing]

00:25:51.150 --> 00:25:54.910
and you can see that our driver
has found it and there's an extra

00:25:54.950 --> 00:25:57.590
slide called Apple Byte Swapped HFS.

00:25:57.750 --> 00:26:00.250
Now we're going to create
a file system on there.

00:26:06.200 --> 00:26:18.700
[Transcript missing]

00:26:20.560 --> 00:26:24.230
If we take a look, you'll be able to see.

00:26:24.350 --> 00:26:28.560
So we'll take a look at
the filtered slice first.

00:26:29.300 --> 00:26:31.870
If we go to offset 400,
we should see the file

00:26:32.320 --> 00:26:34.200
system signature right there.

00:26:34.320 --> 00:26:36.300
It says H+.

00:26:39.800 --> 00:26:45.750
Now if we open up the unfiltered slice,
and we go to the same offset,

00:26:47.320 --> 00:26:58.240
and David Koehn,
and I'm going to give you a quick

00:26:58.240 --> 00:26:58.240
example of a few of the things
that we've been working on.

00:26:58.460 --> 00:27:02.140
are some of the important aspects
of writing a filter scheme.

00:27:02.140 --> 00:27:06.200
And now I'd like to
call up Chris Sarcone.

00:27:06.200 --> 00:27:06.200
He's going to talk for a bit.

00:27:13.000 --> 00:27:13.380
Thanks, Dan.

00:27:13.680 --> 00:27:18.600
So I have the front part of
the methods of access here,

00:27:18.600 --> 00:27:20.250
the user clients,
something that everybody

00:27:20.250 --> 00:27:20.990
wants to know about.

00:27:21.630 --> 00:27:23.020
There are...

00:27:24.510 --> 00:27:28.360
Probably a lot of questions out there,
like what is a user client?

00:27:28.420 --> 00:27:31.820
A user client is actually an
intermediary between a kernel

00:27:31.820 --> 00:27:35.420
object and a user space client,
such as an application.

00:27:35.420 --> 00:27:41.600
A user client exports control to user
space code via one of several mechanisms.

00:27:41.600 --> 00:27:44.980
The most popular is a device interface.

00:27:44.980 --> 00:27:49.240
Device interfaces are based
on an IO CFPlugin structure,

00:27:49.240 --> 00:27:52.660
and they act as proxies
for kernel objects.

00:27:53.480 --> 00:27:56.060
Another method,
which Craig went into detail about,

00:27:56.190 --> 00:27:57.220
is the IOCTL.

00:27:57.220 --> 00:28:00.960
And there are other
methods which you can use,

00:28:00.960 --> 00:28:03.530
such as like raw mic Mach IPC.

00:28:07.150 --> 00:28:13.090
So, you're probably asking what user
clients does Apple actually supply?

00:28:13.170 --> 00:28:17.600
Apple supplies several user clients,
some at the media layer and

00:28:17.600 --> 00:28:19.540
some at the device layer.

00:28:19.550 --> 00:28:24.200
Craig's kind of gone into what the
user clients do at the media layer,

00:28:24.200 --> 00:28:27.440
and I'm going to talk to you
a lot about what the user

00:28:27.440 --> 00:28:29.580
clients do at the device layer.

00:28:29.650 --> 00:28:32.880
At the device layer,
we provide two user clients,

00:28:32.970 --> 00:28:37.050
the ATA Smart user client and
the SCSI Task user client.

00:28:37.940 --> 00:28:40.540
First, let's look at the ATA user client.

00:28:40.540 --> 00:28:45.030
The user client for ATA devices
is called ATA Smart User Client.

00:28:45.030 --> 00:28:49.090
It's only available for those
devices which report that they

00:28:49.180 --> 00:28:53.630
support the self-monitoring
analysis and reporting technology as

00:28:54.140 --> 00:28:56.520
defined in the ATA 6 specification.

00:28:57.520 --> 00:29:01.350
There's actually an identifier
in their identified data that

00:29:01.350 --> 00:29:03.310
says that they support that.

00:29:03.500 --> 00:29:06.260
If they do support that,
there will be some keys

00:29:06.260 --> 00:29:08.140
placed in the IORegistry.

00:29:08.140 --> 00:29:12.490
A smart user client can attach,
as you can see at the ATA block

00:29:12.500 --> 00:29:16.660
storage device object,
and the client application can talk

00:29:16.880 --> 00:29:21.360
through the ATA smart interface to
get smart information from the device.

00:29:21.360 --> 00:29:24.360
Documentation for this is forthcoming.

00:29:24.360 --> 00:29:26.020
This is a new feature in Jaguar.

00:29:27.240 --> 00:29:29.460
For now,
you can consult the HeaderDoc placed

00:29:29.460 --> 00:29:31.220
in the ATA smart lib header file.

00:29:31.220 --> 00:29:35.240
And like I said,
it will be fully documented, I hope,

00:29:35.240 --> 00:29:37.320
by the time Jaguar ships.

00:29:39.080 --> 00:29:41.600
Now let's look at user
clients for SCSI devices.

00:29:41.600 --> 00:29:46.230
The user client for SCSI device
provides two device interfaces.

00:29:46.230 --> 00:29:48.540
One is the SCSI task device interface.

00:29:48.540 --> 00:29:50.880
The other is the MMC device interface.

00:29:50.880 --> 00:29:55.930
There are also supplemental interfaces
which aren't actually device interfaces,

00:29:56.080 --> 00:29:58.220
such as the SCSI task interface.

00:29:58.220 --> 00:30:02.600
We may add more device interfaces
or supplemental interfaces as more

00:30:02.620 --> 00:30:04.960
features are requested from you.

00:30:04.960 --> 00:30:08.000
So if you have more feature requests,
let us know.

00:30:08.000 --> 00:30:11.670
These device interfaces and
supplemental interfaces are

00:30:11.670 --> 00:30:16.100
fully documented inside Mac OS X,
accessing hardware from applications.

00:30:16.120 --> 00:30:19.910
There's a chapter on using
SCSI architecture model devices,

00:30:19.910 --> 00:30:24.040
and you can find that in
soft copy and hard copy.

00:30:24.040 --> 00:30:27.940
And we have an SDK available
for you to get up to speed on

00:30:27.940 --> 00:30:30.340
SCSI task user client today.

00:30:33.120 --> 00:30:35.080
Let's look at the
SCSI TAS device interface.

00:30:35.080 --> 00:30:40.240
The SCSI TAS device interface is provided
for peripheral device types not supported

00:30:40.240 --> 00:30:42.170
by Apple with in-kernel drivers.

00:30:42.220 --> 00:30:47.980
These devices are tape drives, scanners,
printers, medium changers,

00:30:47.980 --> 00:30:53.440
basically anything that doesn't have
storage built in like a hard drive.

00:30:53.550 --> 00:30:57.990
The SCSI TAS device interface requires
an exclusive access model so that it

00:30:58.060 --> 00:31:02.500
can provide the client application
with full control of the device.

00:31:03.320 --> 00:31:05.740
New in Jaguar,
we're going to be adding the

00:31:05.770 --> 00:31:07.900
SCSI task management functions.

00:31:08.060 --> 00:31:12.330
These task management functions
include things like abort task,

00:31:12.340 --> 00:31:19.360
abort task set, reset logical unit,
reset target device, etc.

00:31:22.740 --> 00:31:26.220
So, here's an illustration of the
stack and how it builds up for

00:31:26.220 --> 00:31:28.860
a user client for a SCSI device.

00:31:28.860 --> 00:31:31.970
In this example,
we have a FireWire tape drive.

00:31:31.980 --> 00:31:35.320
There's the FireWire
family and FireWire SPP2,

00:31:35.320 --> 00:31:39.100
which represents the
physical interconnect.

00:31:39.100 --> 00:31:42.850
We then have the IO FireWire serial
bus protocol transport and the

00:31:43.050 --> 00:31:44.990
IO SCSI peripheral device NUM.

00:31:45.000 --> 00:31:48.450
The stack doesn't build up any
higher than this for us because

00:31:48.450 --> 00:31:52.140
there is no internal logical
unit driver for tape drives.

00:31:52.710 --> 00:31:56.420
So, the SCSI task user client is
used by the client application

00:31:56.420 --> 00:31:58.680
to communicate with this device.

00:31:58.680 --> 00:32:02.690
As you can see, the client application
and SCSI task user client,

00:32:02.700 --> 00:32:05.600
when used in conjunction,
become the logical unit driver.

00:32:05.600 --> 00:32:09.900
And the SCSI task user client
sort of straddles the application

00:32:09.900 --> 00:32:13.180
and kernel address space,
so it does the dirty work for

00:32:13.180 --> 00:32:14.700
transferring the commands.

00:32:17.410 --> 00:32:19.660
Now let's look at the
MMC device interface.

00:32:19.660 --> 00:32:23.600
The MMC device interface is
provided for all MMC2 compliant

00:32:23.630 --> 00:32:25.540
drives capable of authoring.

00:32:25.620 --> 00:32:30.000
Apple defines an authoring capable
drive as one which provides get

00:32:30.000 --> 00:32:34.760
configuration profiles that says
that it does CD or DVD burning,

00:32:34.820 --> 00:32:39.120
or it says that in the mechanical
capabilities mode page.

00:32:40.090 --> 00:32:44.370
The MMC device interface can be used
in conjunction with the SCSI task

00:32:44.400 --> 00:32:47.920
device interface to gain exclusive
access to authoring devices.

00:32:47.920 --> 00:32:50.450
However,
if you are going to be doing authoring,

00:32:50.450 --> 00:32:53.390
you might want to look at
the disk recording framework.

00:32:53.470 --> 00:32:57.940
It's much, much more simple than using
the SCSI task device interface,

00:32:57.940 --> 00:33:02.040
and it will simplify the amount of
time that you need to spend to get

00:33:02.040 --> 00:33:04.700
burning working in your applications.

00:33:04.700 --> 00:33:09.960
We also wanted to let you know that
part of the MMC device interface

00:33:09.960 --> 00:33:09.960
is a little bit more complicated.

00:33:09.960 --> 00:33:14.250
The MMC device interface today provides
information which has now been migrated

00:33:14.320 --> 00:33:16.110
to iOctools at the media layer.

00:33:16.320 --> 00:33:19.840
And so in the next couple of
revisions of the MMC device interface,

00:33:19.880 --> 00:33:22.700
we'll be phasing out some of
those commands in preference

00:33:23.130 --> 00:33:25.070
for you using the iOctools.

00:33:27.110 --> 00:33:31.720
Here we have an example stack
diagram for a DVD burner.

00:33:31.720 --> 00:33:35.480
It's an Atopy DVD drive,
so we have an Atopy

00:33:35.560 --> 00:33:37.120
protocol transport driver.

00:33:37.120 --> 00:33:40.220
We also noticed that the stack
builds all the way up to the

00:33:40.220 --> 00:33:42.020
IO DVD block storage driver.

00:33:42.020 --> 00:33:46.700
Now when the SCSI task user client
connects and the client gets

00:33:46.700 --> 00:33:51.450
exclusive access to the device,
you'll notice the peripheral device type

00:33:51.640 --> 00:33:53.900
5 driver and up are sort of grayed out.

00:33:54.180 --> 00:33:57.370
That's to note that they're
sort of quiesced at that time.

00:33:57.400 --> 00:34:01.210
And so, again, the client application,
when used in conjunction with

00:34:01.250 --> 00:34:04.900
the SCSI task user client,
become the logical unit driver and

00:34:04.900 --> 00:34:07.040
have full control of the device.

00:34:09.800 --> 00:34:12.230
So now you're probably asking, well,
how do I obtain exclusive

00:34:12.230 --> 00:34:13.700
access to one of these devices?

00:34:13.700 --> 00:34:17.620
The first thing you need to do is
make sure that you've unmounted all

00:34:17.620 --> 00:34:19.860
mounted volumes for that device.

00:34:19.860 --> 00:34:25.030
We have new Carbon APIs in
Files.h to unmount the volumes.

00:34:25.030 --> 00:34:28.850
Some of these APIs include
fscreate volume operation,

00:34:28.970 --> 00:34:33.540
fsdespose volume operation,
and fsunmount volume synchronous

00:34:33.540 --> 00:34:36.720
or the async variety,
depending on what your

00:34:36.720 --> 00:34:38.700
applications need is.

00:34:39.500 --> 00:34:42.270
Also,
you can use a new feature in Jaguar.

00:34:42.270 --> 00:34:45.750
The digital hub,
which we have as the center for

00:34:45.750 --> 00:34:49.780
all of your digital products,
such as the CD burners and

00:34:50.000 --> 00:34:56.030
any sort of camera and stuff,
the digital hub will actually

00:34:56.120 --> 00:35:00.780
send notifications when blank
media is inserted to the drive,

00:35:00.780 --> 00:35:05.150
and it'll send notifications to
the app that is chosen in the

00:35:05.150 --> 00:35:09.200
user's preference pane as the one
for blank CD media or blank media.

00:35:09.200 --> 00:35:16.780
And these new APIs are there because
previously people had to use a sort of

00:35:16.780 --> 00:35:21.140
private SPI called disk arbitration.

00:35:21.140 --> 00:35:26.380
We're hoping that developers will
migrate to these new APIs so that we

00:35:26.380 --> 00:35:29.470
can wean them from disk arbitration.

00:35:30.560 --> 00:35:34.170
So once you've unmounted all volumes,
you can use the SCSI task device

00:35:34.170 --> 00:35:36.750
interface to query whether
exclusive access is available.

00:35:36.760 --> 00:35:40.530
If exclusive access is available,
you can then obtain it.

00:35:40.620 --> 00:35:44.130
And once you've obtained it,
your application again becomes

00:35:44.220 --> 00:35:47.010
the logical unit driver,
and it can send SCSI tasks

00:35:47.010 --> 00:35:48.280
down to the device.

00:35:48.280 --> 00:35:51.520
Now I'd like to call up
Dan Preston again to do a demo

00:35:51.690 --> 00:35:54.130
using the SCSI task user client.

00:35:54.160 --> 00:35:55.820
Thanks, Chris.

00:36:02.020 --> 00:36:03.860
Okay, so let's open up the project here.

00:36:03.860 --> 00:36:14.580
So we thought it'd be kind of
cool to create a demo that does,

00:36:14.580 --> 00:36:17.380
it kind of is a simple
diagnostic utility,

00:36:17.380 --> 00:36:21.390
and all it really does
is perform a sequence of,

00:36:21.530 --> 00:36:26.280
you know, sequential reads on a CD,
and then it kind of

00:36:26.720 --> 00:36:28.050
measures how fast it goes.

00:36:28.070 --> 00:36:34.380
So, um, the main function in this
is run exclusive test suite.

00:36:34.950 --> 00:36:38.100
So the first thing that happens
before this gets called is that

00:36:38.270 --> 00:36:45.200
we use the new Carbon APIs to
unmount any devices or any volumes.

00:36:45.860 --> 00:36:50.090
So then this gets past a
SCSI task device interface.

00:36:50.230 --> 00:36:54.540
Now the first thing that we do is we
obtain exclusive access for the device,

00:36:54.540 --> 00:36:57.040
and if that fails, then we bail out.

00:36:57.040 --> 00:37:00.340
Otherwise,
we have obtained exclusive access.

00:37:00.420 --> 00:37:02.640
Second,
we're going to create the SCSI task,

00:37:02.670 --> 00:37:06.210
and that's what we're going
to use to do our work.

00:37:06.640 --> 00:37:09.160
We allocate some memory in here.

00:37:09.170 --> 00:37:13.040
And then we're going to start
looping and doing our reads.

00:37:13.040 --> 00:37:14.530
So...

00:37:17.380 --> 00:37:21.140
The next thing we do
is we fill out our CDB.

00:37:21.210 --> 00:37:25.290
And in this case, it's just a read 10.

00:37:25.660 --> 00:37:29.480
And we're going to set the command
descriptor block within the task.

00:37:29.620 --> 00:37:32.920
And then we're going to set
the scatter gather entries.

00:37:37.210 --> 00:37:39.760
And after that,
you have to set the timeout.

00:37:39.940 --> 00:37:43.290
And optionally,
you can set task attributes with

00:37:43.290 --> 00:37:45.790
the set task attribute call.

00:37:46.050 --> 00:37:51.490
In our case, we're setting head of queue.

00:37:51.490 --> 00:37:51.490
That's just an example.

00:37:51.490 --> 00:37:51.490
It's, you don't have to...

00:37:51.600 --> 00:38:14.500
[Transcript missing]

00:38:15.090 --> 00:38:20.110
and then we're going to send that
information to the graph so it knows.

00:38:23.190 --> 00:38:26.730
Finally,
all we have to do is release our memory,

00:38:26.740 --> 00:38:29.270
release a task,
and then release exclusive

00:38:29.330 --> 00:38:31.370
access to the device.

00:38:34.830 --> 00:38:38.500
So let's fire this thing up.

00:38:38.500 --> 00:38:43.880
And it shows all the devices
on the computer right here.

00:38:46.000 --> 00:38:56.600
[Transcript missing]

00:39:01.450 --> 00:39:03.470
So it does 100 reads on the drive.

00:39:03.500 --> 00:39:08.170
And then you can see it's getting a
little over a meg and a half a second.

00:39:08.500 --> 00:39:26.100
[Transcript missing]

00:39:27.000 --> 00:39:40.800
[Transcript missing]

00:39:40.900 --> 00:39:46.780
will have details on how to sign up
for that at the end of the session.

00:39:46.780 --> 00:39:46.780
So that's about it.

00:39:46.780 --> 00:39:46.780
Chris?

00:39:52.120 --> 00:39:53.900
Thanks, Dan.

00:39:54.150 --> 00:39:57.920
So now, now that we've covered the
Apple-supplied user clients,

00:39:57.920 --> 00:40:00.500
the ATA user client and
the SCSI task user client,

00:40:00.570 --> 00:40:05.130
and we've given you an example of
how to use the SCSI task user client,

00:40:05.240 --> 00:40:09.200
these two user clients might
not satisfy all your needs.

00:40:09.200 --> 00:40:12.920
You might need to actually
write a custom user client.

00:40:13.050 --> 00:40:16.430
Before you go down the path of
writing a custom user client,

00:40:16.560 --> 00:40:18.760
we'd like you to ask
yourself a few questions.

00:40:19.010 --> 00:40:21.900
First of all,
is a user client really necessary?

00:40:22.100 --> 00:40:25.620
Well, you might ask yourself, "Well,
how do I know if it's necessary or

00:40:25.630 --> 00:40:29.530
not?" The questions to ask yourself are,
"Well, how much data do I need to

00:40:29.530 --> 00:40:32.800
move back and forth "between
my application and my driver?

00:40:32.870 --> 00:40:37.060
"And how often do I need to
do it?" If your data is very,

00:40:37.060 --> 00:40:40.560
very small,
something less than four kilobytes,

00:40:40.650 --> 00:40:44.870
or you're not doing it too often,
like say you're doing it less than,

00:40:45.030 --> 00:40:49.060
you know, once every ten seconds,
you might be able to get

00:40:49.060 --> 00:40:50.910
away with other methods.

00:40:51.080 --> 00:40:55.000
And so we'd like you to
consider some other options.

00:40:55.180 --> 00:40:57.990
You can use I/O registry properties.

00:40:58.190 --> 00:41:00.790
You can find static
properties in an application,

00:41:00.880 --> 00:41:03.800
and you can set static
properties in a driver.

00:41:03.800 --> 00:41:07.700
This is all documented in the
I/O Kit Fundamentals book.

00:41:07.700 --> 00:41:10.540
Also, you can dynamically set properties.

00:41:11.040 --> 00:41:15.480
Dynamically setting properties requires
an application to build a dictionary and

00:41:15.480 --> 00:41:17.490
send the properties down to a device.

00:41:17.630 --> 00:41:22.000
And all the device driver has to do
is override a I/O Kit Fundamentals.

00:41:22.000 --> 00:41:23.890
And then it's a function
to get those properties.

00:41:24.070 --> 00:41:28.000
This works really well for people
that have to set preferences.

00:41:28.000 --> 00:41:32.030
So if you have to set preferences,
you might want to think about

00:41:32.030 --> 00:41:36.930
creating a system startup item and
then use this method to dynamically

00:41:37.010 --> 00:41:38.920
set properties in your driver.

00:41:39.090 --> 00:41:42.520
Also, there's a method of doing
asynchronous notifications from the

00:41:42.520 --> 00:41:45.000
driver to interested applications.

00:41:45.000 --> 00:41:48.940
An application can register for
general interest notifications

00:41:49.010 --> 00:41:53.310
and attach that to their run loop,
and then get notified asynchronously from

00:41:53.710 --> 00:41:56.920
the driver when certain things happen.

00:41:58.830 --> 00:42:02.480
So if you decide that those methods
can't help you and you really

00:42:02.480 --> 00:42:06.330
have to write a user client,
you need to create a subclass

00:42:06.540 --> 00:42:08.620
of the IO user client class.

00:42:08.620 --> 00:42:11.810
You then need to define the
API you want to use between your

00:42:11.930 --> 00:42:13.840
application and your driver.

00:42:13.840 --> 00:42:17.060
You need to implement those
functions in the kernel.

00:42:17.060 --> 00:42:21.350
And then finally you can test it
with a command line app or tool.

00:42:22.160 --> 00:42:28.720
There's actually sample code provided
by DTS to do simple user clients,

00:42:28.720 --> 00:42:33.280
and that can be expanded to
do lots of different things.

00:42:34.800 --> 00:42:37.500
Now we're going to move on
to another method of access,

00:42:37.600 --> 00:42:38.640
the IORegistry.

00:42:38.640 --> 00:42:44.390
As I mentioned a couple slides before,
you can get static properties from

00:42:44.390 --> 00:42:45.900
the registry from an application.

00:42:45.900 --> 00:42:49.860
You do this by first finding
out which IO service you

00:42:50.150 --> 00:42:52.760
want to get information from.

00:42:52.760 --> 00:42:56.070
You do that by calling
IOServiceGetMatchingServices,

00:42:56.130 --> 00:43:02.840
and you pass it the I/O Kit master
port and a dictionary for stuff that

00:43:03.050 --> 00:43:06.170
signifies what you want it to match.

00:43:06.180 --> 00:43:09.460
In this case,
we'll be matching on a driver

00:43:09.930 --> 00:43:12.220
whose name is my class name.

00:43:12.260 --> 00:43:15.600
This call returns an iterator to you.

00:43:15.600 --> 00:43:20.810
You can then loop over that iterator
to get the actual IOService objects.

00:43:20.900 --> 00:43:22.710
On that,
you can get the actual IOService object.

00:43:22.790 --> 00:43:25.720
You can call
IORegistryEntryCreateCFProperties,

00:43:25.720 --> 00:43:30.860
and that gives you back a CFDictionary in
which you can inspect that and look for

00:43:30.860 --> 00:43:32.650
properties that you're interested in.

00:43:35.890 --> 00:43:38.570
The other way is to
dynamically set properties.

00:43:38.570 --> 00:43:41.240
Like I mentioned,
if you wanted to write a system

00:43:41.240 --> 00:43:44.880
startup item to set properties,
again, you would try and find the

00:43:44.970 --> 00:43:48.710
object you're trying to look for,
and then you call IORegistryEntry

00:43:48.710 --> 00:43:52.250
set CF properties after building
a dictionary to send down using

00:43:52.260 --> 00:43:54.400
the core foundation routines.

00:43:57.460 --> 00:44:01.100
In the kernel, for the set properties,
you would have to

00:44:01.290 --> 00:44:03.040
override set properties.

00:44:03.200 --> 00:44:04.880
It gets passed in an OS object.

00:44:04.950 --> 00:44:08.900
You can cast that to an OS dictionary
and make sure it's the right type.

00:44:08.960 --> 00:44:11.030
And once you get that
OS dictionary object,

00:44:11.100 --> 00:44:14.520
you can look inside it for properties
that the driver understands.

00:44:14.520 --> 00:44:16.610
And from there,
you can go ahead and execute

00:44:16.610 --> 00:44:19.940
whatever commands you need to to
set those properties correctly.

00:44:22.210 --> 00:44:25.780
Finally, we're going to talk about
migration from obsoleted methods.

00:44:25.780 --> 00:44:31.340
There are some methods we
would like to obsolete.

00:44:31.340 --> 00:44:34.030
Number one,
we'd like to obsolete SCSI action.

00:44:34.040 --> 00:44:38.540
We will be obsoleting SCSI action
in the future because I/O Kit should

00:44:38.540 --> 00:44:40.120
contain hardware APIs.

00:44:40.120 --> 00:44:44.260
Carbon is going to formally
deprecate this API in Jaguar.

00:44:44.260 --> 00:44:47.520
Carbon will remove this API post-Jaguar.

00:44:48.360 --> 00:44:52.080
One of the major reasons why we are
getting rid of SCSI action is because

00:44:52.170 --> 00:44:53.890
the performance is not very great.

00:44:53.960 --> 00:44:57.870
It's a shim on top of a shim,
and you don't tend to get too

00:44:57.870 --> 00:44:59.800
great a performance from that.

00:44:59.900 --> 00:45:05.010
SCSI action is actually shimmed on
top of IOSCSI lib and IOCDB lib.

00:45:05.020 --> 00:45:09.090
Both of these have a limitation
inherent that they will only work

00:45:09.090 --> 00:45:11.610
with IOSCSI family-based drivers.

00:45:11.620 --> 00:45:15.490
IOSCSI family itself is
going to be replaced by a new

00:45:15.490 --> 00:45:18.340
IOSCSI parallel family in Jaguar.

00:45:18.340 --> 00:45:23.800
We're hoping to have all of the major
host-bust adapters for SCSI using

00:45:23.800 --> 00:45:26.660
the new IOSCSI parallel family.

00:45:26.660 --> 00:45:32.430
When they do, IOSCSI lib and IOCDB lib
will no longer function.

00:45:32.460 --> 00:45:37.900
One of the main reasons why we're
getting rid of IOSCSI lib is because

00:45:37.900 --> 00:45:44.650
most of the functionality is equivalent
or better in the SCSI task user clients.

00:45:46.290 --> 00:45:52.570
Finally, those of you who are working
on scanner or printer drivers,

00:45:52.810 --> 00:45:57.770
you should look into using the
image capture architecture so that

00:45:57.780 --> 00:46:01.700
you can promote system-wide use for
applications for scanners or printers.

00:46:01.700 --> 00:46:09.700
For CUPS printers, the CUPS architecture,
the Common Unix Printing

00:46:09.700 --> 00:46:14.500
System architecture,
is what will be used in Jaguar

00:46:14.750 --> 00:46:16.040
for system-wide printing.

00:46:16.040 --> 00:46:21.210
You can use SCSI task user clients
to actually talk to your devices,

00:46:21.230 --> 00:46:24.600
but you'd really like to make them
fit within these Apple-supplied

00:46:24.600 --> 00:46:29.900
architectures for doing good drivers.

00:46:30.170 --> 00:46:32.350
Finally,
we have a roadmap of other sessions

00:46:32.930 --> 00:46:35.000
you might be interested in.

00:46:35.360 --> 00:46:40.460
There's a session tomorrow
at 2 p.m., session 008,

00:46:40.460 --> 00:46:42.030
the Disrecording APIs.

00:46:42.040 --> 00:46:45.800
This shows you how to write CDs and
DVDs from your applications.

00:46:45.800 --> 00:46:49.960
Also, session 510, Printing in Mac OS X.

00:46:49.960 --> 00:46:53.340
This is an overview of
the CUPS architecture,

00:46:53.340 --> 00:46:57.070
and that is tomorrow at 10.30 a.m.

00:46:57.580 --> 00:47:01.010
And finally, session 515,
the Image Capture Framework,

00:47:01.100 --> 00:47:03.310
and that is Friday at 2 p.m.

00:47:05.100 --> 00:47:09.740
For more information,
you can look at the T10 Committee website

00:47:09.740 --> 00:47:12.140
for the SCSI specifications.

00:47:12.140 --> 00:47:15.020
It's found at www.t10.org.

00:47:15.020 --> 00:47:19.990
And for ATA specifications,
you can visit www.t13.org.

00:47:20.080 --> 00:47:23.860
Also,
we have a mass storage discussion list.

00:47:23.920 --> 00:47:28.800
To subscribe, you can send an email to
requests at sam.apple.com,

00:47:28.800 --> 00:47:31.850
and the message would be
subscribe xmassstorage.

00:47:33.700 --> 00:47:36.650
Finally, we also have some documentation.

00:47:36.650 --> 00:47:39.950
As mentioned earlier,
we have the Accessing Hardware

00:47:39.950 --> 00:47:41.580
from Applications book.

00:47:41.740 --> 00:47:44.600
The chapter that you'd probably be
interested would be working with

00:47:44.600 --> 00:47:47.440
SCSI Architecture Model Devices.

00:47:47.500 --> 00:47:52.090
Both soft copy and hard copy are
available at the following URLs.

00:47:52.490 --> 00:47:58.380
and there's also an excellent book on
writing drivers for mass storage devices.

00:47:58.380 --> 00:48:01.180
And again,
soft copy and hard copy are available.

00:48:01.380 --> 00:48:03.800
And finally,
if you need to contact somebody,

00:48:03.850 --> 00:48:05.100
you can contact Mark Tozer.

00:48:05.310 --> 00:48:07.060
He's the hardware evangelist.
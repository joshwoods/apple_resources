WEBVTT

00:00:02.490 --> 00:00:03.400
Welcome.

00:00:03.400 --> 00:00:03.890
My name is Godfried E.

00:00:03.890 --> 00:00:04.100
Giorgi.

00:00:04.200 --> 00:00:07.070
I'm the Technology Manager for
Development Tools,

00:00:07.130 --> 00:00:09.920
and I'd like to welcome you
to our session on compiler

00:00:09.920 --> 00:00:11.390
developments at Apple.

00:00:11.470 --> 00:00:16.950
As we drill deeper today into our tools
and into the development of our tools,

00:00:16.990 --> 00:00:21.100
it's proving to be a very,
very interesting day with the

00:00:21.100 --> 00:00:23.510
questions we've seen so far.

00:00:23.510 --> 00:00:23.510
At that note,

00:00:23.700 --> 00:00:26.440
Let me introduce John Graziano,
the manager of the

00:00:26.510 --> 00:00:29.260
Mac OS X Compiler Development Group.

00:00:34.400 --> 00:00:39.700
[Transcript missing]

00:00:40.200 --> 00:00:44.020
Today we're going to talk about GCC 3.1,
which is the next compiler

00:00:44.020 --> 00:00:45.980
coming for Mac OS X.

00:00:46.040 --> 00:00:47.590
We'll touch on some of the new features.

00:00:47.720 --> 00:00:49.980
We'll also talk at the end
about converting projects,

00:00:49.980 --> 00:00:51.780
some issues you might encounter.

00:00:51.810 --> 00:00:55.890
And we'll spend a lot of time talking
about developments we've done in

00:00:55.920 --> 00:00:59.070
code quality and compile time.

00:00:59.300 --> 00:01:03.000
So how many people actually use
GCC for Mac OS X development?

00:01:03.000 --> 00:01:07.200
How many people here
work with Code Warrior?

00:01:07.200 --> 00:01:11.390
How many people here actually
work for Code Warrior.

00:01:18.340 --> 00:01:22.200
I should probably talk
about that slide going back.

00:01:22.200 --> 00:01:25.080
The GNU C Compiler, for those of you that
haven't seen it before,

00:01:25.080 --> 00:01:26.120
it's free software.

00:01:26.500 --> 00:01:28.980
It supports ANSI C, C++, and Objective-C.

00:01:28.980 --> 00:01:31.390
There's also a bunch of other front ends,
including Ada,

00:01:31.390 --> 00:01:33.060
but these are the ones that we focus on.

00:01:33.620 --> 00:01:38.050
It has a very robust C++
implementation because there's many

00:01:38.120 --> 00:01:40.380
years of work and testing on this.

00:01:40.380 --> 00:01:42.610
There's just billions and
billions of lines of code that

00:01:42.620 --> 00:01:44.160
have gone through this compiler.

00:01:44.160 --> 00:01:48.370
It's used as a reference compiler
on many systems for many developers,

00:01:48.720 --> 00:01:53.020
and we use it on Mac OS X because,
frankly, it compiles all of Mac OS X.

00:01:53.020 --> 00:01:57.700
When you start up OS X, start the finder,
you're running mail,

00:01:57.700 --> 00:02:02.580
pretty much everything you see
on Mac OS X is built with GCC3.

00:02:03.460 --> 00:02:05.400
at this point.

00:02:08.090 --> 00:02:11.130
So the latest work in 295,
what you got on the

00:02:11.130 --> 00:02:16.160
April Developer Tools CD and
what's shipping on Mac OS 10.1.

00:02:16.180 --> 00:02:18.890
295 is the default compiler on 10.1.

00:02:18.890 --> 00:02:21.040
It's the default compiler
on the April Tools CD.

00:02:21.040 --> 00:02:24.400
We've made some improvements
to the code generation,

00:02:24.400 --> 00:02:28.260
including code quality and
reduction of memory footprint,

00:02:28.260 --> 00:02:31.420
which, as you've seen if you attended
the performance tools session,

00:02:31.420 --> 00:02:32.850
is a critical feature for us.

00:02:33.600 --> 00:02:36.880
We added Objective C++,
and we put in two-level namespace

00:02:37.010 --> 00:02:39.260
the same way it works with Mac OS 9.

00:02:39.280 --> 00:02:42.900
So let's talk about GCC 3.1.

00:02:45.120 --> 00:02:47.580
So there's new features in the compiler.

00:02:47.580 --> 00:02:51.440
The community has added C99 compliance.

00:02:51.440 --> 00:02:53.990
We have C++ ANSI compliance.

00:02:54.000 --> 00:02:58.740
We've integrated the preprocessor,
so we no longer have a separate process

00:02:58.850 --> 00:03:00.950
that runs to do the preprocessing.

00:03:01.750 --> 00:03:03.660
There are more optimizations.

00:03:03.880 --> 00:03:06.590
The optimizations that are
there have been improved.

00:03:06.830 --> 00:03:12.410
And most specifically
for C++ programmers,

00:03:12.410 --> 00:03:12.450
there's a new ABI.

00:03:16.320 --> 00:03:18.800
So some things that we've added to 3.1.

00:03:18.800 --> 00:03:23.280
We've actually gone in and made further
improvements to the code generation.

00:03:23.290 --> 00:03:27.050
We've added a new pre-compiled
header scheme for C++,

00:03:27.120 --> 00:03:30.530
and we'll talk a lot about
that in future slides.

00:03:30.720 --> 00:03:34.320
We again have integrated our
Objective C++ support in with

00:03:34.370 --> 00:03:38.060
the Objective C support that
comes with the GNU C Compiler.

00:03:38.060 --> 00:03:41.090
And of course we've
added our MachO support.

00:03:42.480 --> 00:03:45.350
So, we're saying this in every session,
but I want to make it clear:

00:03:45.430 --> 00:03:51.000
wait for Jaguar to ship before
shipping any products with 3.1.

00:03:51.020 --> 00:03:52.900
It's a beta compiler right now.

00:03:52.900 --> 00:03:56.040
We're correcting some things,
including a couple C-ABI issues

00:03:56.150 --> 00:03:59.770
having to do with Bool that are
going to be critical for making

00:03:59.770 --> 00:04:01.700
your apps run well on Jaguar.

00:04:01.750 --> 00:04:06.710
So wait before you ship anything
until we ship the final version.

00:04:08.240 --> 00:04:11.100
So let's talk a little
bit about Objective-C++.

00:04:11.120 --> 00:04:13.900
I stood up here last year and Zem Lasky
stood up here last year and we talked

00:04:14.000 --> 00:04:18.810
about what we were going to deliver
in the next tool CD for Objective-C++.

00:04:18.810 --> 00:04:21.960
Well, we delivered that and people
have actually been using it.

00:04:22.040 --> 00:04:24.940
So for those of you that
aren't familiar with it,

00:04:24.940 --> 00:04:28.450
Objective-C++ is a combination,
a syntactic combination

00:04:28.530 --> 00:04:30.020
of C and Objective-C.

00:04:30.020 --> 00:04:35.330
It allows us to integrate C++
code with Cocoa applications.

00:04:35.330 --> 00:04:36.310
That's the intention.

00:04:36.360 --> 00:04:37.240
That's why we did it.

00:04:37.290 --> 00:04:38.180
So you could take your
legacy C++ code and you could

00:04:38.180 --> 00:04:38.180
integrate it with your C++ code.

00:04:38.200 --> 00:04:42.290
You could move it over to
Mac OS X and you could put a

00:04:42.460 --> 00:04:44.560
nice Cocoa UI on top of it.

00:04:46.210 --> 00:04:50.270
We've added a new file extension, .mm,
so if you see projects with .mm in it,

00:04:50.360 --> 00:04:53.510
that means that they
are Objective C++ files.

00:04:53.520 --> 00:04:57.590
We also used to have the .M
back in the old Next Step days,

00:04:57.590 --> 00:04:59.750
and of course on HFS that
doesn't work too well.

00:04:59.890 --> 00:05:02.750
So we still support it,
but we discourage the use of it because

00:05:02.750 --> 00:05:06.580
it collisions with the lowercase m,
which is used for Objective C files.

00:05:09.310 --> 00:05:13.780
So we allow you to do a lot of
mixing with Objective-C and C++.

00:05:13.780 --> 00:05:15.690
You can mix declarations.

00:05:15.810 --> 00:05:18.800
You can have Objective-C objects
point at C++ objects.

00:05:18.880 --> 00:05:22.260
You can have C++ objects
point at Objective-C objects.

00:05:22.310 --> 00:05:26.950
And you can invoke Objective-C message
sends anywhere in a C++ expression.

00:05:29.870 --> 00:05:32.740
So there are some
restrictions that we have.

00:05:32.740 --> 00:05:35.650
First and foremost,
you cannot mix the object hierarchies.

00:05:35.780 --> 00:05:38.700
So the object models are
kept completely separate and,

00:05:38.790 --> 00:05:41.040
as Zem likes to say, mutually oblivious.

00:05:41.100 --> 00:05:45.240
And we did that intentionally,
first of all, because it would be really

00:05:45.270 --> 00:05:49.100
hard to mix them together,
and also because it introduces a lot

00:05:49.110 --> 00:05:54.100
of corner cases that we just don't want
to have developers have to think about.

00:05:54.240 --> 00:05:56.960
It's much simpler to keep
them completely separate.

00:05:57.020 --> 00:05:59.390
Objective-C objects descend
from Objective-C objects.

00:05:59.400 --> 00:06:03.140
C++ objects descend from C++ objects.

00:06:03.560 --> 00:06:06.240
C++ classes, of course,
cannot be receivers of

00:06:06.240 --> 00:06:08.780
Objective-C messages,
and vice versa.

00:06:08.830 --> 00:06:13.240
You can't invoke a function in
Objective-C as you would on a C++ class.

00:06:13.240 --> 00:06:16.120
And finally,
you can't statically allocate new

00:06:16.120 --> 00:06:18.230
or delete Objective-C objects.

00:06:18.230 --> 00:06:22.200
You use the same alloc init paradigm
that you're used to with Objective-C.

00:06:25.220 --> 00:06:25.920
So it's for real.

00:06:26.150 --> 00:06:30.610
We've been shipping a compiler
with it for almost a year now.

00:06:31.000 --> 00:06:34.870
And we have actual apps that
are shipping on the system that

00:06:34.870 --> 00:06:36.760
have Objective C++ in them.

00:06:36.910 --> 00:06:39.060
Project Builder has Objective C++ in it.

00:06:39.290 --> 00:06:41.330
IDVD has Objective C++ in it.

00:06:41.690 --> 00:06:45.950
There's a lot of third-party
applications that are also shipping

00:06:46.060 --> 00:06:48.900
with Objective C++ in their code base.

00:06:51.210 --> 00:06:53.100
So, code generation.

00:06:53.100 --> 00:06:57.880
Let's talk a little bit about
how we measure code quality.

00:06:59.420 --> 00:07:01.500
The first thing that we
use is real-world code.

00:07:01.710 --> 00:07:03.900
We plug a lot of code
through this compiler.

00:07:03.900 --> 00:07:06.860
Again,
we are the compiler for all of Mac OS X,

00:07:06.860 --> 00:07:10.520
so we have a lot of things that
we can look at and test to see how

00:07:10.520 --> 00:07:12.640
we're doing with code generation.

00:07:13.490 --> 00:07:14.970
We use benchmarks like everyone else.

00:07:15.020 --> 00:07:18.200
It's a good way to
isolate compiler problems.

00:07:18.200 --> 00:07:20.840
And finally, we test ourselves
against other compilers.

00:07:20.840 --> 00:07:22.200
We look at Code Warrior.

00:07:22.200 --> 00:07:22.780
We look at Mr.

00:07:22.780 --> 00:07:26.200
C, which a lot of people had
high regard for on Mac OS 9.

00:07:26.200 --> 00:07:31.660
And we look at GCC 295 to see how much
we're improving the code generation

00:07:31.670 --> 00:07:33.430
from one release to the next.

00:07:34.370 --> 00:07:38.540
So, some real-world code that we look at,
and the reason that we use real-world

00:07:38.540 --> 00:07:42.910
code is that we can get at large
components of the operating system and

00:07:42.910 --> 00:07:45.300
see overall how the compiler is doing.

00:07:45.520 --> 00:07:50.360
It allows us to measure big
factors like memory usage,

00:07:50.360 --> 00:07:55.300
system usage,
how much we're accessing the disk.

00:07:55.300 --> 00:07:57.300
We have large chunks of code.

00:07:57.300 --> 00:08:00.250
We can measure things like code
size a lot easier than measuring a

00:08:00.250 --> 00:08:05.460
simple benchmark because the code
size tends to accumulate overall.

00:08:06.200 --> 00:08:09.340
Some of the real-world code that we use,
well, we look at QuickTime,

00:08:09.430 --> 00:08:10.870
see what frame rates we get.

00:08:11.170 --> 00:08:13.760
We look at iTunes for the encoder,
see how quickly we can

00:08:13.760 --> 00:08:15.560
encode and decode your music.

00:08:15.600 --> 00:08:17.980
We look at the Mach kernel
and run benchmarks on that

00:08:17.980 --> 00:08:21.090
for networking and file system
access and so on and so forth.

00:08:21.310 --> 00:08:23.650
We look at Quartz and OpenGL.

00:08:23.860 --> 00:08:25.810
And we look at the Java VM.

00:08:25.960 --> 00:08:30.600
That's just a subset of some
of the things that we look at

00:08:30.600 --> 00:08:34.060
when we're measuring our code
quality on Mac OS X in general.

00:08:35.190 --> 00:08:37.190
So we also rely a lot on benchmarks.

00:08:37.440 --> 00:08:40.080
One of the problems with real
world code is if you find that,

00:08:40.080 --> 00:08:43.540
oh, you know, QuickTime is running,
you know, 4% slower.

00:08:43.540 --> 00:08:46.470
There's a lot of code in QuickTime,
so it's very hard to track down exactly

00:08:46.570 --> 00:08:48.500
where the compiler is slowing you down.

00:08:48.500 --> 00:08:52.260
So benchmarks make it easier to isolate
some of these code gen problems.

00:08:52.300 --> 00:08:55.570
A benchmark is just a collection
of CPU-intensive routines,

00:08:55.570 --> 00:08:59.110
something preferably that can be
built from multiple platforms by

00:08:59.110 --> 00:09:02.920
multiple compilers so that you can
get a lot of axes of comparison.

00:09:05.090 --> 00:09:09.680
Each test will hopefully target a
subset of compiler code generation,

00:09:09.680 --> 00:09:12.940
either integer code generation,
floating point code generation,

00:09:12.940 --> 00:09:13.360
and so on.

00:09:13.580 --> 00:09:17.220
We use it to measure our
basic optimization techniques

00:09:17.220 --> 00:09:19.360
to see how well we're doing.

00:09:20.900 --> 00:09:23.240
So some of the benchmarks we use.

00:09:23.470 --> 00:09:26.170
This is sort of becoming the standard,
CPU2000,

00:09:26.170 --> 00:09:28.140
which was formerly known as SpecMarks.

00:09:28.200 --> 00:09:29.540
It's a big test.

00:09:29.880 --> 00:09:33.800
As an example, one of the tests in
SpecMarks is GCC itself.

00:09:33.800 --> 00:09:37.300
They test how quickly an older
version of GCC can run a bootstrap.

00:09:37.300 --> 00:09:38.550
So it's a very big test.

00:09:38.650 --> 00:09:42.300
A lot of system interaction,
a lot of calls that the compiler

00:09:42.300 --> 00:09:44.620
doesn't control into libraries.

00:09:46.310 --> 00:09:50.330
So it's a good test of an overall system,
but it's not the best thing for tracking

00:09:50.330 --> 00:09:52.320
down a particular code gen issue.

00:09:54.080 --> 00:09:55.690
We've looked at ByteMarkz.

00:09:55.740 --> 00:09:59.130
The back-end guys are not
big fans of ByteMarkz.

00:09:59.240 --> 00:10:01.240
It's kind of an older test.

00:10:01.240 --> 00:10:03.910
A lot of people have stopped using it.

00:10:04.030 --> 00:10:07.500
It's easy to manipulate this to
get an inflated score on ByteMarkz.

00:10:07.500 --> 00:10:11.340
You can do a lot of optimizations that
don't have any application in the real

00:10:11.340 --> 00:10:15.500
world that don't make Mac OS X better,
but make your ByteMarkz score better.

00:10:15.580 --> 00:10:17.970
And also, of course,
it doesn't have things

00:10:17.970 --> 00:10:20.560
like AltaVec on it,
so you can't test your AltaVec

00:10:20.690 --> 00:10:22.790
performance by using ByteMarkz.

00:10:23.220 --> 00:10:26.140
And we have one called Skidmarks
that I'm going to talk about

00:10:26.140 --> 00:10:28.730
a little more in general,
which we rely a lot on.

00:10:28.780 --> 00:10:33.530
It has been incredibly helpful in us
in helping us improve the compiler.

00:10:36.090 --> 00:10:39.210
So, if you take an overview of SkidMarkz,
it was developed by

00:10:39.210 --> 00:10:40.740
Apple's hardware group.

00:10:40.810 --> 00:10:44.440
If any of you were at the
performance tools talk yesterday,

00:10:44.440 --> 00:10:48.000
you saw some of the guys who
developed the SkidMarkz benchmark.

00:10:48.000 --> 00:10:52.960
We actually took samples of real world
code that was running on the Macintosh

00:10:52.960 --> 00:10:58.100
so that we could actually have targeted
attack at the code generation problems

00:10:58.130 --> 00:11:00.730
that affect you on a day-to-day basis.

00:11:01.010 --> 00:11:03.990
They're very small tests,
much smaller than SpecMarkz.

00:11:04.000 --> 00:11:05.000
They stay in cache.

00:11:05.000 --> 00:11:07.000
They don't have a lot of system calls.

00:11:07.000 --> 00:11:13.000
So, we can actually measure how we're
doing on the production of actual code.

00:11:13.000 --> 00:11:15.920
And it's broken up into
three categories of tests.

00:11:16.070 --> 00:11:19.440
We have integer tests,
we have floating point tests,

00:11:19.670 --> 00:11:21.500
and we have AlteVec tests.

00:11:21.860 --> 00:11:24.800
So let's look at what's
actually in SkidMarkz.

00:11:24.840 --> 00:11:27.920
We have an MPEG-2 encoder that we test.

00:11:27.930 --> 00:11:31.120
We have a pixel blender that we
use in Final Cut Pro and iDVD.

00:11:31.160 --> 00:11:33.300
So again,
shipping code that goes out to you,

00:11:33.360 --> 00:11:35.710
we're making sure that we
optimize it as best we can.

00:11:35.890 --> 00:11:40.480
We have two encryption routines which
appear in our security software.

00:11:42.090 --> 00:11:45.640
For the floating point test,
we actually have a sample of Quake 3.

00:11:45.680 --> 00:11:47.610
We're testing one of their
math routines to see how we do.

00:11:47.640 --> 00:11:51.270
We have, of course,
a standard fast Fourier transform

00:11:51.400 --> 00:11:53.100
and a volume integration.

00:11:57.180 --> 00:11:58.610
And then we have Altevec tests.

00:11:58.690 --> 00:12:01.820
We have gravity
calculation called Galaxy.

00:12:01.920 --> 00:12:04.660
We have something called Inverse
Discrete Cosine Transform,

00:12:04.660 --> 00:12:06.120
which somebody told me
once what that meant,

00:12:06.260 --> 00:12:10.720
but I know that it's used in QuickTime in
the codex to generate images.

00:12:10.720 --> 00:12:13.790
And again, we have multiplication
of really big numbers,

00:12:13.790 --> 00:12:16.600
which is one of the things
that scientific computation

00:12:16.640 --> 00:12:18.170
wants to use Altevec for.

00:12:20.690 --> 00:12:23.130
So, let's see where we were.

00:12:23.280 --> 00:12:27.100
This is where we were last year
when we were talking about GCC 295.

00:12:27.100 --> 00:12:29.780
So, and just to note, smaller is better.

00:12:29.950 --> 00:12:35.370
So, in 295 on the integer tests,
Code Warrior 7 beat us

00:12:35.370 --> 00:12:37.890
by about 5%, and Mr.

00:12:37.890 --> 00:12:43.190
C on Mac OS 9 beat us
by 33%. Not very good.

00:12:43.380 --> 00:12:45.320
On Floating Point,
we're in a similar state.

00:12:45.440 --> 00:12:48.460
Code Warrior 7 was beating us by 18%. Mr.

00:12:48.460 --> 00:12:51.170
C was beating us by 12%.

00:12:51.630 --> 00:12:56.960
And then finally on our AlteVec test,
Code Warrior beat us by 19, Mr.

00:12:56.960 --> 00:12:58.500
C beat us by 15.

00:12:58.520 --> 00:12:59.960
So of course,
this is something we weren't too

00:12:59.960 --> 00:13:02.730
happy with and we wanted to go
ahead and try and fix this in

00:13:02.880 --> 00:13:04.930
the next version of the compiler.

00:13:05.310 --> 00:13:10.040
So overall, what we're seeing is that
Code Warrior was 13% ahead of

00:13:10.090 --> 00:13:12.180
us on just general code gen,
and Mr.

00:13:12.260 --> 00:13:16.200
C was beating us by 21%
on general code gen.

00:13:17.490 --> 00:13:19.160
So what did we do to go fix this?

00:13:19.200 --> 00:13:22.300
Well, the first thing we do is we run
something called Nullstones.

00:13:22.330 --> 00:13:26.580
And Nullstones is kind of a benchmark
for the compiler where it tells you

00:13:26.580 --> 00:13:30.990
what optimizations are actually in the
compiler and how well they're doing.

00:13:30.990 --> 00:13:35.530
So we can test individual
optimization passes,

00:13:35.530 --> 00:13:39.040
see that, oh,
it's not doing the scheduling

00:13:39.700 --> 00:13:40.110
the way we expect it to,
or it's not doing alias analysis

00:13:40.110 --> 00:13:40.110
the way we expect it to.

00:13:41.220 --> 00:13:44.060
Again, as we've said, we do head-to-head
comparisons with compilers.

00:13:44.090 --> 00:13:47.480
As you see, Code Warrior was doing better
code gen on a lot of things.

00:13:47.580 --> 00:13:47.880
Mr.

00:13:47.900 --> 00:13:49.550
C was doing better code
gen on a lot of things.

00:13:49.570 --> 00:13:52.750
It's very instructive for us
to look at what they're doing,

00:13:52.750 --> 00:13:56.060
how they're getting those numbers,
so we can see what we can put

00:13:56.060 --> 00:13:57.750
into GCC to make it better.

00:13:59.300 --> 00:14:02.190
This involves a lot of
inspection of assembly files.

00:14:02.200 --> 00:14:05.990
A lot of times I walk past the offices
of the back end guys and I see them

00:14:05.990 --> 00:14:09.930
scrunched up looking at these lines
and lines and lines of assembly output

00:14:10.180 --> 00:14:15.770
trying to figure out where this one
variable is hanging out in an inner

00:14:15.770 --> 00:14:15.770
loop and whether we can take it out.

00:14:16.850 --> 00:14:19.190
And then finally,
we just sit and look at compiler

00:14:19.190 --> 00:14:21.510
source code and see if there's
any bonehead bugs in the back

00:14:21.510 --> 00:14:23.080
end of the compiler source code.

00:14:23.170 --> 00:14:25.100
Again, this is not magic.

00:14:25.180 --> 00:14:28.420
It's just a lot of work and
it's a lot of qualification.

00:14:28.470 --> 00:14:31.360
And every time we make a
change to code generation,

00:14:31.370 --> 00:14:34.560
we have to run all of Mac OS X through
the compiler again to make sure

00:14:34.560 --> 00:14:36.570
we didn't mess anything up.

00:14:38.750 --> 00:14:41.260
Let's look at how we were doing in 3.1.

00:14:41.300 --> 00:14:43.300
Well, one thing we've added
is a forward inliner.

00:14:43.300 --> 00:14:46.730
This came from the community,
but it lets us do more

00:14:46.730 --> 00:14:48.930
and better inlining.

00:14:48.930 --> 00:14:52.700
And a lot of times this lets
us benchmark a lot better,

00:14:52.840 --> 00:14:55.500
and in some cases it'll let
your code run a lot better.

00:14:55.500 --> 00:14:58.820
But as we'll talk about a little later,
you need to be careful with the inliner.

00:14:59.940 --> 00:15:04.100
We've added something called
dynamic non-pick or non-position

00:15:04.220 --> 00:15:06.320
independent function calls.

00:15:06.420 --> 00:15:09.380
I wanted to have a little
propeller head beanie for this one,

00:15:09.380 --> 00:15:11.830
but for those of you that
aren't compiler heads,

00:15:12.350 --> 00:15:19.290
basically in Mac OS 10.1 we generated all
of our code as position independent code,

00:15:19.290 --> 00:15:22.800
which meant that we had to do a little
bit of extra instructions every time

00:15:22.800 --> 00:15:26.260
we made a function call in order to
find the address of the function.

00:15:26.260 --> 00:15:29.800
Well, one of the things that we noted was
that we had to do a little bit of

00:15:29.800 --> 00:15:29.800
extra instructions every time we
made a function call in order to

00:15:29.800 --> 00:15:29.800
find the address of the function.

00:15:29.830 --> 00:15:32.800
When you generate an executable,
it doesn't have to be

00:15:32.800 --> 00:15:33.510
position independent.

00:15:33.520 --> 00:15:37.080
It doesn't have to be able to
slide its address around the way a

00:15:37.080 --> 00:15:39.060
shared library or a library would.

00:15:39.080 --> 00:15:42.360
So we don't have to have
position independent code.

00:15:42.360 --> 00:15:45.880
What this lets us do is it
removes one level of indirection

00:15:45.880 --> 00:15:49.100
for our library calls,
and it saves us two loads

00:15:49.100 --> 00:15:50.670
per call on average.

00:15:50.800 --> 00:15:55.940
For small functions, for example,
on a Hello World,

00:15:55.940 --> 00:15:59.300
I actually ran this on Hello World and
noticed that it reduced,

00:15:59.810 --> 00:16:03.860
the calls, the instruction stream by
eight instructions for a

00:16:03.930 --> 00:16:06.450
simple call out to a function.

00:16:06.520 --> 00:16:09.440
So if you have a lot of functions
that just call out to other functions

00:16:09.440 --> 00:16:12.580
or call out to a couple functions,
you should see a good win on this.

00:16:12.580 --> 00:16:18.980
We've added AlteVec and
floating point optimizations.

00:16:19.430 --> 00:16:21.290
And of course,
we've just continued and continued

00:16:21.730 --> 00:16:24.500
incremental improvement of the compiler.

00:16:24.500 --> 00:16:28.110
The reason I emphasize the incremental
improvement of the compiler is

00:16:28.160 --> 00:16:31.940
because we build every week all
of Mac OS X with this compiler.

00:16:32.050 --> 00:16:36.580
So I sort of think about it as
constructing the 747 in mid-air.

00:16:36.760 --> 00:16:41.560
You have to keep the compiler running
for every build of Mac OS X while you're

00:16:41.560 --> 00:16:43.870
making these code gen improvements.

00:16:44.970 --> 00:16:46.800
So let's look at how we did.

00:16:46.890 --> 00:16:52.000
So this was the graph we got
for the integer processing.

00:16:52.820 --> 00:16:55.400
And GCC 3.1 now comes in here.

00:16:55.470 --> 00:16:58.900
It's 28% improvement over 295.

00:16:59.150 --> 00:17:01.790
beats Code Warrior 7 by 22%. Mr.

00:17:01.790 --> 00:17:06.000
C is still a little bit ahead of us,
but we're working on that.

00:17:06.000 --> 00:17:10.000
On the floating point processing,

00:17:12.800 --> 00:17:15.040
We have a 20% improvement over 295.

00:17:15.080 --> 00:17:17.980
We're pretty much in a
virtual tie with Code Warrior.

00:17:18.070 --> 00:17:19.010
And with Mr.

00:17:19.130 --> 00:17:21.410
C, we're beating it by 7%.

00:17:23.720 --> 00:17:28.100
And on AlteVec, 28% over 295.

00:17:28.100 --> 00:17:30.800
This was the biggest complaint
that we got out of 295 was that our

00:17:30.800 --> 00:17:33.600
AlteVec code generation was really,
really terrible.

00:17:33.600 --> 00:17:37.010
And Dale Johannesson is one of
the guys on my team and he did a

00:17:37.030 --> 00:17:42.990
great job in making our AlteVec
code the best for Mac OS X.

00:17:45.150 --> 00:17:49.890
So overall what you see is GCC 3.1
on our internal benchmarks is

00:17:49.890 --> 00:17:53.770
giving us 11% over CodeWarrior 7,
is giving us 4% on Mr.

00:17:53.770 --> 00:18:01.760
C, and is beating GCC 295 by 25%. It's a
25% improvement in code gen over 295.

00:18:08.930 --> 00:18:10.800
So, what you can do with CodeGen.

00:18:10.800 --> 00:18:14.790
First thing,
and I always have to say this,

00:18:14.920 --> 00:18:17.110
is optimize your code.

00:18:17.420 --> 00:18:21.890
We get a lot of bugs coming in from
external and internal users that say,

00:18:21.890 --> 00:18:26.240
"GCC's code gen is 50% slower
than my other compiler." And we

00:18:26.240 --> 00:18:29.590
find out that they're not passing
an optimization flag to it.

00:18:29.600 --> 00:18:34.300
GCC's code gen for unoptimized
code is fairly unoptimized.

00:18:35.100 --> 00:18:36.750
So...

00:18:38.090 --> 00:18:40.990
So one thing that we recommend
is a new flag called -OS.

00:18:41.090 --> 00:18:43.600
It was actually on 295 but
didn't work that great.

00:18:43.600 --> 00:18:46.010
I'll talk a little bit more about -OS.

00:18:46.280 --> 00:18:50.550
But -OS is the flag that you
want to pass in to your projects

00:18:51.090 --> 00:18:55.000
when you don't have any other
reason to change the optimization.

00:18:55.170 --> 00:19:00.010
If you don't know what
optimization to put on your code,

00:19:00.010 --> 00:19:00.010
use -OS.

00:19:00.980 --> 00:19:01.510
And measure.

00:19:01.520 --> 00:19:04.670
If you have performance-intensive
parts of your code,

00:19:04.920 --> 00:19:05.440
measure them.

00:19:05.500 --> 00:19:07.520
Use the performance tools
that you saw yesterday.

00:19:07.520 --> 00:19:11.740
In a lot of cases,
the optimal settings depend on your code.

00:19:11.740 --> 00:19:18.810
There's absolutely no way that we can
give you a generic set of optimization

00:19:18.810 --> 00:19:21.510
switches for everyone's code.

00:19:21.640 --> 00:19:23.450
It's going to depend on
how you're using C++.

00:19:23.630 --> 00:19:26.080
It's going to depend on how
many function calls you have,

00:19:26.140 --> 00:19:28.120
how many loops you have,
so on and so forth.

00:19:28.420 --> 00:19:30.620
There may be cases where
inlining is great for you.

00:19:30.960 --> 00:19:32.940
There may be cases where
inlining is terrible for you.

00:19:32.940 --> 00:19:36.110
It depends on what your
application is actually doing.

00:19:38.530 --> 00:19:41.000
Let's talk about Dash OS,
optimized for size.

00:19:41.180 --> 00:19:43.970
This is something that we're
pushing really hard internally,

00:19:43.970 --> 00:19:46.000
and we want people to use it externally.

00:19:46.040 --> 00:19:48.800
As we've talked about,
one of the key things for

00:19:48.800 --> 00:19:51.070
Mac OS X performance is memory footprint.

00:19:51.170 --> 00:19:59.040
If you want your app to start up quickly,
one of the ways to have it

00:19:59.040 --> 00:19:59.040
start up quickly is to have it
load less code off the disk.

00:19:59.680 --> 00:20:04.830
So, -OS produces the smallest binary
size for most executables.

00:20:04.860 --> 00:20:06.940
In fact,
for all the executables that we've tried,

00:20:06.940 --> 00:20:09.150
it produces the smallest binary size.

00:20:09.210 --> 00:20:12.440
It's roughly equivalent to -02.

00:20:12.440 --> 00:20:13.590
We turn off a couple of things.

00:20:13.600 --> 00:20:15.490
We don't have loop unrolling.

00:20:15.880 --> 00:20:18.330
We don't schedule your code,
which can lead to bloat

00:20:18.330 --> 00:20:19.600
or do register renaming.

00:20:19.770 --> 00:20:21.520
And we have limited inlining.

00:20:21.600 --> 00:20:25.030
We don't do any inlining unless you
actually include the inline keyword.

00:20:25.040 --> 00:20:28.920
So, what this will do is, you know,
there may be a few optimizations

00:20:28.920 --> 00:20:32.570
that are missing out of -02,
but you more than make up for that

00:20:32.640 --> 00:20:35.850
if you just save one page off the
disk when your app starts up or when

00:20:36.010 --> 00:20:37.900
your app has to be swapped in again.

00:20:38.300 --> 00:20:41.210
Also, because your code is smaller,
more of it is going to

00:20:41.390 --> 00:20:43.320
sit in the on-chip cache.

00:20:43.430 --> 00:20:46.630
So, you're going to get better
performance through that.

00:20:47.950 --> 00:20:50.410
The other thing I want to
talk about is -mdynamicnopic.

00:20:50.490 --> 00:20:53.540
And this again is a propeller head slide.

00:20:53.700 --> 00:20:57.340
But people who are using Makefiles
especially for building executables,

00:20:57.370 --> 00:21:00.230
either tools or applications,
you want to know about this.

00:21:00.250 --> 00:21:02.990
It's new in GCC 3.1.

00:21:03.520 --> 00:21:07.630
It generates indirect,
non-position independent function calls.

00:21:07.640 --> 00:21:13.380
And the big thing is it reduces your
code size by 10%, and it increases your

00:21:13.700 --> 00:21:21.620
code performance by 10%. This is great
for applications that use our toolboxes.

00:21:21.800 --> 00:21:26.110
The applications that most people
are writing are going to be heavily

00:21:26.540 --> 00:21:29.870
dependent on a lot of library calls,
a lot of system library calls,

00:21:29.920 --> 00:21:34.180
and this focuses right on those call
sites and makes them more efficient.

00:21:35.910 --> 00:21:43.170
For people using Project Builder,
on the Jaguar CD that you have,

00:21:43.200 --> 00:21:46.300
it's the default.

00:21:46.300 --> 00:21:48.800
You just hit Build and you
get this flag passed in.

00:21:48.800 --> 00:21:52.430
If you're using Makefiles,
you're going to have to add

00:21:52.430 --> 00:21:53.900
it to your compiler switches.

00:21:53.900 --> 00:21:57.550
Again, I'll emphasize,
use this only on executables.

00:21:57.550 --> 00:22:01.340
If you're building libraries,
if you're building shared libraries,

00:22:01.750 --> 00:22:04.580
anything like that, frameworks,
you can't use this because the

00:22:04.580 --> 00:22:08.140
frameworks and libraries can come in,
and bundles and plugins as well,

00:22:08.140 --> 00:22:09.660
can come in at any address.

00:22:09.950 --> 00:22:13.230
The code has to be position independent.

00:22:16.250 --> 00:22:19.560
So one thing I want to
talk about also is -03.

00:22:19.560 --> 00:22:23.640
We found that a lot of people use -03,
and when we asked them why

00:22:23.640 --> 00:22:27.660
they felt they needed -03,
the general response we got was, "Well,

00:22:27.780 --> 00:22:30.590
3 is more than 2, right?"

00:22:31.170 --> 00:22:31.990
It's got to be better.

00:22:32.000 --> 00:22:34.420
Well, that's not always the case.

00:22:34.420 --> 00:22:37.280
The big thing that you get
with Dash03 is it turns on

00:22:37.530 --> 00:22:40.390
automatic inlining of your code.

00:22:40.460 --> 00:22:46.340
So before, if you're running with DashOS,
it would obey the inline keyword.

00:22:46.340 --> 00:22:49.820
If you're running with Dash01,
you don't get any inlining.

00:22:49.820 --> 00:22:53.310
But if you're running with Dash03,
you get inlining at the

00:22:53.310 --> 00:22:55.120
discretion of the compiler.

00:22:55.120 --> 00:23:01.990
So you may get some surprising results,
especially since the inline

00:23:01.990 --> 00:23:04.000
keyword only uses a hint.

00:23:04.000 --> 00:23:06.910
It's kind of like the register
keyword at this point.

00:23:06.940 --> 00:23:13.150
And the limit set by the inlining
is measured in internal data

00:23:13.290 --> 00:23:15.740
structures of the compiler.

00:23:15.740 --> 00:23:20.440
It's about as deep of a flag as
you can pass to the compiler.

00:23:20.440 --> 00:23:24.160
The inline limit, I think,
by default is about 600,

00:23:24.160 --> 00:23:29.120
but it's measured in nodes
of the compiler tree,

00:23:29.120 --> 00:23:32.120
and it really doesn't have... it doesn't
have any direct meaning for your code.

00:23:32.240 --> 00:23:36.290
The only thing that it has
is that you set it higher,

00:23:36.510 --> 00:23:37.540
you get more inlining.

00:23:37.540 --> 00:23:39.270
You set it lower, you get less inlining.

00:23:39.300 --> 00:23:41.200
So it's something that
you have to play with.

00:23:41.290 --> 00:23:45.740
But the key is,
if you run at Dash03 and you

00:23:45.780 --> 00:23:51.280
set an inline limit very high,
you could get very, very bloated code.

00:23:51.480 --> 00:23:56.150
You know, 40% bigger,
60% bigger than the code that you

00:23:56.200 --> 00:23:58.100
would have with Dash02 or DashOS.

00:23:58.100 --> 00:23:59.720
So this is something that you have to do.

00:23:59.730 --> 00:23:59.910
So this is something that you have to do.

00:23:59.940 --> 00:24:00.990
This is something that
you have to be very,

00:24:01.120 --> 00:24:01.680
very careful about.

00:24:01.680 --> 00:24:04.790
If you're running with Dash03,
you want to look at the

00:24:04.890 --> 00:24:08.820
difference between your code at
Dash03 and your code at DashOS.

00:24:08.820 --> 00:24:11.380
If you have some
performance-intensive routines,

00:24:11.380 --> 00:24:13.370
you may still want to get some inlining.

00:24:13.380 --> 00:24:17.400
But if you notice that DashOS,
you can obey the inline.

00:24:17.400 --> 00:24:20.420
You can have it obey the inline keyword.

00:24:20.420 --> 00:24:23.400
You can actually hand inline
those if you want to get

00:24:23.400 --> 00:24:25.440
better performance out of them.

00:24:29.410 --> 00:24:32.660
So, if you're using Project Builder,
a lot of this is taken care of for you.

00:24:32.660 --> 00:24:35.670
The MDynamic no-pick is passed
by default on executables.

00:24:35.800 --> 00:24:40.120
-OS, if you make a new project,
is going to be your default

00:24:40.120 --> 00:24:41.300
optimization setting.

00:24:41.750 --> 00:24:45.590
And of course,
there's some compiler switches that you

00:24:45.590 --> 00:24:49.760
can control for setting the optimization,
for setting the debugging symbols.

00:24:50.230 --> 00:24:52.720
There's a nice GUI for this.

00:24:56.160 --> 00:24:57.660
Let's go on and talk about build time.

00:24:57.790 --> 00:25:02.370
This is something that has
been a key feature for us.

00:25:02.480 --> 00:25:05.590
A lot of people have complained
about GCC's build time,

00:25:05.820 --> 00:25:10.430
especially for C++ because we didn't have
a precompiled header solution for C++.

00:25:11.540 --> 00:25:17.680
We've been looking at C++ build time,
and we actually looked at the most

00:25:17.820 --> 00:25:27.990
popular C++ framework out there,
which is Power Plant, to see how we did.

00:25:29.160 --> 00:25:33.630
GCC3 takes 25 minutes and 40
seconds out of the box to build

00:25:33.640 --> 00:25:35.800
Power Plan on our fastest CPU.

00:25:35.800 --> 00:25:40.500
Now, for those of you that don't know
where Code Warrior is on this,

00:25:40.510 --> 00:25:41.800
they're there.

00:25:42.190 --> 00:25:43.190
41 seconds.

00:25:46.530 --> 00:25:50.210
So we always go back to this
and look at it and just say,

00:25:50.210 --> 00:25:52.640
how did they get so fast?

00:25:53.480 --> 00:25:55.410
So we've been asking ourselves,
how do they get so fast?

00:25:55.580 --> 00:25:59.120
Where does the time go in GCC3?

00:25:59.190 --> 00:26:00.520
Well, we have a little bit of overhead.

00:26:00.520 --> 00:26:02.660
We run separate processes,
so we pay a little bit there

00:26:02.660 --> 00:26:05.000
for starting up the processes.

00:26:05.980 --> 00:26:09.520
Then, we spend a whole bunch
of time in every compile

00:26:09.770 --> 00:26:12.610
Processing headers, just parsing headers,
looking for headers,

00:26:12.610 --> 00:26:15.330
just doing a bunch of header processing.

00:26:16.200 --> 00:26:20.400
After that,
we have source code processing,

00:26:20.470 --> 00:26:23.840
code generation,
a little bit of assembler,

00:26:23.840 --> 00:26:25.200
and a small amount of link time.

00:26:25.220 --> 00:26:30.190
And that all adds up in Power Plant to
25 minutes and 40 seconds.

00:26:32.220 --> 00:26:35.590
So,
what happens when you're parsing headers?

00:26:35.670 --> 00:26:39.840
First off,
you spend a lot of time in I/O.

00:26:40.040 --> 00:26:41.920
You're reading files,
and not only are you reading files,

00:26:42.010 --> 00:26:43.090
you're looking for files.

00:26:43.110 --> 00:26:44.800
You're searching the disk for files.

00:26:44.800 --> 00:26:47.710
And because we run the
compiler as a batch process,

00:26:47.710 --> 00:26:50.370
it has to research
every time it starts up.

00:26:50.540 --> 00:26:52.950
We're doing the pre-processing,
which can be costly depending

00:26:52.950 --> 00:26:55.200
on how many macros you have.

00:26:55.270 --> 00:26:58.900
And of course we're parsing declarations,
which we pay for in a couple of areas.

00:26:58.900 --> 00:27:01.870
We pay for,
and of course the CPU uses just the

00:27:01.950 --> 00:27:03.880
compiler doing its computations.

00:27:03.890 --> 00:27:07.380
And in memory allocation,
especially in C++ because the compiler

00:27:07.380 --> 00:27:12.580
has to allocate a lot of memory to handle
all of the declarations that we process.

00:27:12.600 --> 00:27:16.540
It's a hundred thousand lines
of declarations in Carbon alone.

00:27:16.570 --> 00:27:20.770
And we have to process all of
those for every file you build.

00:27:22.890 --> 00:27:25.260
So, people are asking,
"What about CPP Precomp?" This is

00:27:25.260 --> 00:27:29.740
something that we leverage heavily
on 295 in our C and Objective-C.

00:27:29.800 --> 00:27:32.920
It's a precompiled mechanism
that we brought over from Next,

00:27:32.920 --> 00:27:35.800
and it stores all of your
headers in tokenized form.

00:27:35.800 --> 00:27:40.020
And one of the best parts of it,
and one of the reasons why it

00:27:40.050 --> 00:27:42.800
is so fast and gets you such a
good result on C and Objective-C,

00:27:42.830 --> 00:27:47.370
is that it selectively unparses only
the declarations that you reference

00:27:47.650 --> 00:27:49.800
and passes those to the compiler.

00:27:49.800 --> 00:27:54.800
So, it's a much smaller set of code that
you build for every translation unit.

00:27:56.310 --> 00:28:01.280
It has good project builder support,
but the one problem is

00:28:01.350 --> 00:28:03.530
it cannot contain C++.

00:28:03.620 --> 00:28:08.290
We've done some work to get CppPrecomp
to kind of live in the C++ world,

00:28:08.290 --> 00:28:12.960
but you can't precompile any
C++ code into CppPrecomp.

00:28:15.720 --> 00:28:20.340
So we came up with a new mechanism
we call the persistent front end.

00:28:20.340 --> 00:28:24.480
And the persistent front end saves
the entire front end state to disk.

00:28:24.600 --> 00:28:27.600
You basically go all the
way through the parse,

00:28:27.620 --> 00:28:30.600
we get to the end of the parse,
and we dump that out to disk.

00:28:30.600 --> 00:28:34.280
And then what we do is on
subsequent runs of the compiler,

00:28:34.280 --> 00:28:36.570
we map that in at a known address.

00:28:36.640 --> 00:28:38.600
This lets us get a couple
of things for free.

00:28:38.610 --> 00:28:41.600
One,
we don't have to go through and swizzle

00:28:41.600 --> 00:28:43.770
all the pointers in the data structures.

00:28:43.770 --> 00:28:44.600
They just work.

00:28:44.730 --> 00:28:48.150
And two, those pages that we've mapped
in will stay resident from

00:28:48.150 --> 00:28:49.600
run to run of the compiler.

00:28:49.600 --> 00:28:54.670
So we've cut down all the I/O that we
need to do to bring in these pages from

00:28:54.820 --> 00:28:57.600
one run of the compiler to the next.

00:28:58.610 --> 00:29:03.900
Supports all C flavors, all four of them:
C, Objective-C, C++, Objective-C++.

00:29:03.900 --> 00:29:05.500
It gets all the constructs.

00:29:05.580 --> 00:29:09.270
It uses the actual
compiler to do its work.

00:29:09.270 --> 00:29:13.550
So there's no difference between
running your code with the PFE and

00:29:13.550 --> 00:29:16.490
running your code without the
PFE in terms of semantic processing.

00:29:16.500 --> 00:29:18.200
You should see absolutely no difference.

00:29:18.270 --> 00:29:23.490
In CPP PreComp, we had a couple of things
that were different because

00:29:23.490 --> 00:29:26.850
it was a separate application
outside of the compiler world.

00:29:30.430 --> 00:29:31.540
Let's see how we do with the PFE.

00:29:31.700 --> 00:29:32.230
Here's where we were.

00:29:32.260 --> 00:29:36.040
GCC3 was at 25 minutes and 40 seconds.

00:29:36.070 --> 00:29:39.830
CodeWarrior's building
power plan at 41 seconds.

00:29:40.050 --> 00:29:43.160
The PFE comes somewhere in the middle.

00:29:43.190 --> 00:29:45.140
We get down to 4 minutes and 21 seconds.

00:29:45.140 --> 00:29:50.170
That's a 6x improvement
over GCC3 out of the box.

00:29:55.290 --> 00:29:58.260
So this will get,
for big C++ applications,

00:29:58.260 --> 00:30:01.070
this will get your turnaround
time into the realm of reasonable.

00:30:01.070 --> 00:30:04.480
We're still not at the code where,
oh my god, that's so fast.

00:30:04.480 --> 00:30:08.370
But we're at the point where
you can actually get reasonable

00:30:08.370 --> 00:30:10.370
turnaround time out of this.

00:30:13.600 --> 00:30:18.280
A compile time improvement up
to six times faster with GCC 3.1

00:30:18.280 --> 00:30:20.360
using the persistent front-end.

00:30:26.250 --> 00:30:28.180
So where do you set this up?

00:30:28.240 --> 00:30:31.700
Anders Bertelrud at 2 o'clock
today is going to go into much more

00:30:31.700 --> 00:30:35.350
detail on how you use the persistent
front end from Project Builder.

00:30:35.360 --> 00:30:37.440
But there's a couple things
that I wanted to point out here.

00:30:37.440 --> 00:30:41.300
First of all,
you need to set up a prefix header.

00:30:41.900 --> 00:30:43.880
How many people have set
up a prefix header in their

00:30:43.930 --> 00:30:45.710
projects in Project Builder?

00:30:45.830 --> 00:30:46.890
You know how to do this.

00:30:46.930 --> 00:30:49.440
You basically just take a header,
you let it import a whole

00:30:49.440 --> 00:30:53.370
bunch of other headers,
and then you click the Precompile button.

00:30:53.550 --> 00:30:56.580
It's the same thing that you do
with CPP Precomp in the current

00:30:56.580 --> 00:30:58.250
version of Project Builder.

00:30:58.300 --> 00:31:02.080
Now, we have one more thing that you
have to do in this version that

00:31:02.150 --> 00:31:07.140
you've got on the Jaguar CD.

00:31:07.140 --> 00:31:07.140
Ooh, new compiler UI.

00:31:08.340 --> 00:31:12.940
This is not the new color
scheme for Project Builder.

00:31:12.940 --> 00:31:16.730
But down here you have to actually
add a custom build flag and I promise

00:31:16.730 --> 00:31:21.300
you and the PB team promises you
that we will have UI for doing this.

00:31:21.300 --> 00:31:28.900
But you have to say use GCC3 PFE support,
set that to yes on the Jaguar CD.

00:31:29.350 --> 00:31:32.050
If you don't do this,
you'll get the old CPP Precomp

00:31:32.060 --> 00:31:34.970
mechanism because we wanted to
bring that support forward in the

00:31:34.970 --> 00:31:38.140
compiler for people who are using
it and like it in Objective-C and C.

00:31:38.450 --> 00:31:41.700
You can still use that with GCC 3.1.

00:31:41.770 --> 00:31:47.810
But if you want to try out the new PFE,
you set this to yes,

00:31:47.810 --> 00:31:50.290
have a prefix header, hit precompile,
and you'll get the PFE.

00:31:52.280 --> 00:31:58.280
So, today, we've sped up raw header
processing 8 to 10x.

00:31:58.280 --> 00:32:03.440
We've given full support for C++,
Objective-C, Objective-C++.

00:32:05.580 --> 00:32:09.660
And we've given you overall build
speed increase as much as 6x.

00:32:09.700 --> 00:32:10.590
And we've actually seen this.

00:32:10.680 --> 00:32:13.320
This is not just some rigged up thing.

00:32:13.320 --> 00:32:16.900
We just saw that the Finder
team is getting 6x build speed

00:32:16.900 --> 00:32:19.720
ups with GCC3 and the PFE.

00:32:19.780 --> 00:32:21.420
Power plant, six times.

00:32:21.530 --> 00:32:25.070
We've seen some of our other applications
that we're converting over to the PFE,

00:32:25.150 --> 00:32:26.940
they get in the realm of six times.

00:32:26.940 --> 00:32:28.850
So this is something,
this is not really a

00:32:28.850 --> 00:32:30.040
your mileage may vary.

00:32:30.040 --> 00:32:32.910
You may see something,
depending on how your app is structured,

00:32:32.910 --> 00:32:35.470
depending on how much you put
into the precompiled header,

00:32:35.640 --> 00:32:38.440
somewhere on the order of
four times to eight times.

00:32:38.580 --> 00:32:42.670
But it's definitely a significant
improvement over GCC3.1 out of

00:32:42.670 --> 00:32:45.480
the box and 295 compile times.

00:32:49.810 --> 00:32:54.660
So, how do you move on to GCC 3.1?

00:32:54.690 --> 00:32:56.690
There are some changes in the
compiler that are going to

00:32:56.800 --> 00:33:00.760
affect you and they're going to
especially affect C++ programmers.

00:33:00.770 --> 00:33:04.140
You've got a new STL and
lib standard C++.

00:33:04.170 --> 00:33:07.700
Changes to things like iterators,
exceptions, there's the whole support for

00:33:07.700 --> 00:33:11.140
I/O stream in there with the locales.

00:33:11.170 --> 00:33:13.510
We have stricter ANSI compliance.

00:33:13.600 --> 00:33:15.940
This is going to bite some people,
especially if you're used to

00:33:15.940 --> 00:33:18.460
using 295 or Code Warrior.

00:33:18.460 --> 00:33:21.360
We catch a few more things
in terms of ANSI compliance.

00:33:21.390 --> 00:33:23.020
We have better error checking.

00:33:23.060 --> 00:33:24.660
This is good and bad.

00:33:24.680 --> 00:33:29.040
The bad part is you may get more
errors in your code or you may

00:33:29.040 --> 00:33:30.560
get more warnings in your code.

00:33:30.580 --> 00:33:33.060
The good part is a lot of
those warnings are real and a

00:33:33.060 --> 00:33:34.130
lot of those errors are real.

00:33:34.140 --> 00:33:38.560
We've actually caught a lot of bugs in
Mac OS X just by running them through

00:33:38.560 --> 00:33:42.170
GCC 3.1 and correcting build failures.

00:33:42.550 --> 00:33:49.430
And of course, we have a new C++ ABI,
which is going to have implications

00:33:49.430 --> 00:33:49.430
for how you build your code.

00:33:49.690 --> 00:33:52.940
So let's talk about the first one,
C++ ABI.

00:33:52.940 --> 00:33:57.700
So if you see this problem where
you're building a C++ application,

00:33:57.720 --> 00:34:00.300
you're linking against a library,
and the link is just failing

00:34:00.300 --> 00:34:03.610
with many undefined symbols,
especially symbols that you

00:34:03.610 --> 00:34:07.870
recognize from your library,
the problem is that you probably forgot

00:34:07.870 --> 00:34:11.080
to compile a library with GCC 3.1.

00:34:11.080 --> 00:34:17.210
The entire C++ stack that you're
running needs to be built with 3.1.

00:34:17.360 --> 00:34:20.350
We've changed the name mangling,
we've changed the Vtable layout,

00:34:20.850 --> 00:34:21.100
everything.

00:34:21.200 --> 00:34:25.500
So it's just not going to
work to link a C++ application

00:34:25.510 --> 00:34:28.440
against a 295-built library.

00:34:28.440 --> 00:34:30.750
You need to have them
both built with GCC 3.1.

00:34:34.950 --> 00:34:36.800
Also, namespaces.

00:34:36.800 --> 00:34:39.600
GCC 3.1 strictly adheres to namespaces.

00:34:39.600 --> 00:34:43.640
If you see that your compile fails
with some symbol not in scope,

00:34:44.090 --> 00:34:49.890
the cause may be that all
C++ library classes are now

00:34:49.940 --> 00:34:51.800
in the standard namespace.

00:34:51.820 --> 00:34:57.110
To fix this, you prefix those library
references with the standard colon,

00:34:57.170 --> 00:34:59.690
colon,
or you use the using standard directive.

00:35:00.160 --> 00:35:04.680
This should clear up those symbol errors.

00:35:06.460 --> 00:35:07.590
So we have STL changes.

00:35:07.590 --> 00:35:11.380
This is one that we ran into a
lot when we were trying to get

00:35:11.410 --> 00:35:14.980
Mac OS X rolled out onto GCC 3.1.

00:35:14.980 --> 00:35:24.360
The problem here is that the exception in
the STL has added empty throw specifiers

00:35:24.360 --> 00:35:26.740
to its constructors and its destructor.

00:35:26.740 --> 00:35:29.850
And if you have a subclass,
or if you're subclassing

00:35:29.850 --> 00:35:33.410
from L exception in the STL,
you need to add those same

00:35:33.520 --> 00:35:37.100
throw specifiers so you have the
same declarations in your code.

00:35:37.120 --> 00:35:41.320
So if you put on an
empty throw specifier,

00:35:41.320 --> 00:35:45.030
when you see this error,
this should clear up

00:35:45.100 --> 00:35:46.450
this problem for you.

00:35:48.610 --> 00:35:51.040
So finally,
linking with lib standard C++.

00:35:51.210 --> 00:35:54.300
If you see that your link is
failing with strange undefineds

00:35:54.300 --> 00:35:58.960
like underbar GXX personalities,
things that you've never put into

00:35:58.960 --> 00:36:03.500
your code or into your libraries,
it probably is that you're failing to

00:36:03.500 --> 00:36:06.800
get a link against lib standard C++.

00:36:07.290 --> 00:36:10.930
So the easy way around this
is to use the C++ command.

00:36:11.210 --> 00:36:15.440
We have a lot of ways that you can invoke
the compiler from the command line,

00:36:15.440 --> 00:36:17.900
a lot of ways that you can
invoke it from Project Builder.

00:36:17.980 --> 00:36:22.200
Project Builder will handle this
automatically for your C++ builds now.

00:36:22.330 --> 00:36:25.470
So if it sees that you have
C++ files in your project,

00:36:25.470 --> 00:36:29.630
it will link using the C++ command
rather than the CC command.

00:36:31.000 --> 00:36:35.760
So this is the easy way to get all of
the default behavior that you want on

00:36:35.840 --> 00:36:38.710
your link line is just to link with C++.

00:36:43.000 --> 00:36:45.460
A couple of other issues
that you might encounter.

00:36:45.520 --> 00:36:49.880
Type agreement is strictly enforced,
so if you're passing in const where

00:36:49.880 --> 00:36:52.960
there is no const or vice versa,
you're going to have to cast that.

00:36:53.050 --> 00:36:57.960
We caught a lot of issues with
casting where GCC295 led it through.

00:36:57.960 --> 00:37:00.220
GCC3.1 is going to flag
that with an error.

00:37:01.650 --> 00:37:03.680
Here's one that we've been
wrestling with for a long time.

00:37:03.680 --> 00:37:07.970
We fixed a bunch of bugs in this area,
but since CPP Precomp is something that

00:37:08.040 --> 00:37:13.350
is mostly applied to C and Objective-C,
we haven't gone all the way to having

00:37:13.350 --> 00:37:15.790
CPP Precomp understand the new STL.

00:37:15.800 --> 00:37:18.460
There's a lot,
lot more stuff in the new STL,

00:37:18.460 --> 00:37:22.620
and there's a few things that
CPP Precomp just flat out doesn't like.

00:37:22.700 --> 00:37:26.260
So if you're using CPP Precomp
with your C++ code,

00:37:26.350 --> 00:37:31.460
I definitely recommend that you go
over to the Persistent Frontend.

00:37:31.460 --> 00:37:34.350
It's going to get you a lot
better performance because

00:37:34.350 --> 00:37:37.310
you can take your C++ code,
your power plant headers,

00:37:37.310 --> 00:37:40.660
your stable headers from your project,
you can put them all in

00:37:40.660 --> 00:37:43.100
a precompiled header,
and you can leverage a

00:37:43.100 --> 00:37:44.500
lot more of the code.

00:37:44.500 --> 00:37:47.550
You can put the STL headers
into the precompiled header,

00:37:47.740 --> 00:37:51.040
and you can get a lot more of a
win in compile time out of that.

00:37:52.360 --> 00:37:58.030
And finally, C++, the C++ compiler,
now recognizes operator names.

00:37:58.130 --> 00:38:00.760
So you can actually type in and, not eq.

00:38:00.760 --> 00:38:05.090
These are all recognized as keywords now,
xor and or and a few others.

00:38:05.580 --> 00:38:09.580
These are all recognized now
as keywords in the compiler.

00:38:09.580 --> 00:38:14.020
If you find out, if you want to name your
variables and or not eq,

00:38:14.020 --> 00:38:18.280
you can pass in f no operator
names and that turns that off.

00:38:19.060 --> 00:38:21.390
So this is a couple things
that may bite you as you're

00:38:21.430 --> 00:38:23.390
converting your code to GCC 3.1.

00:38:26.080 --> 00:38:32.000
So, the bottom line is that C++ projects
are going to require some code changes.

00:38:32.220 --> 00:38:35.010
The read we got from the Finder team,
they were sort of one

00:38:35.010 --> 00:38:37.120
of our early adopters,
is about 98,

00:38:37.120 --> 00:38:41.270
99% of their stuff just built
and they had to make a few tweaks

00:38:41.270 --> 00:38:45.100
in terms of adding some CAS,
in terms of adding some using directives,

00:38:45.140 --> 00:38:46.320
and so on and so forth.

00:38:46.370 --> 00:38:49.290
But it's not,
we're not talking re-engineering here,

00:38:49.340 --> 00:38:52.910
we're just talking about bringing
your app more into the compliance

00:38:52.980 --> 00:38:55.030
that GCC 3.1 is expecting.

00:38:56.000 --> 00:38:59.000
C and Objective C should just work.

00:38:59.000 --> 00:39:03.960
You should just be able to take
your code with your C files,

00:39:04.040 --> 00:39:07.320
switch over to using GCC 3.1,
hit build in Project Builder,

00:39:07.530 --> 00:39:08.500
and it should just go.

00:39:08.500 --> 00:39:12.350
Anybody sees any problem with that,
they should let us know because

00:39:12.440 --> 00:39:15.520
we definitely have worked to make
this as seamless as possible.

00:39:19.000 --> 00:39:21.130
So we're still working on this.

00:39:21.130 --> 00:39:24.100
What you have is not the
final copy for Jaguar.

00:39:24.260 --> 00:39:26.360
The first thing that's happening
is we're giving you a full

00:39:26.660 --> 00:39:28.970
sync with the GCC 3.1 release.

00:39:29.010 --> 00:39:31.530
I saw Stan Shebs walk
in late to this talk,

00:39:31.620 --> 00:39:33.060
and I'm sure that's
what he was working on,

00:39:33.060 --> 00:39:38.010
is getting the latest build with the
full merge of the GCC 3.1 release.

00:39:38.580 --> 00:39:40.620
We're making further
code gen improvements.

00:39:40.620 --> 00:39:43.190
We didn't stop just to cut the CD,
so we're putting in further

00:39:43.190 --> 00:39:44.440
code gen improvements.

00:39:44.440 --> 00:39:49.440
We're making some adjustments for speed,
some improvements in speed,

00:39:49.440 --> 00:39:55.190
but mostly what we've been focusing on
since the compiler that you have is size,

00:39:55.190 --> 00:39:57.340
especially C++ code size.

00:39:57.380 --> 00:40:00.340
A lot of you guys will see when
you run this compiler that your C++

00:40:00.430 --> 00:40:04.430
binaries are going to be a little
bit bigger than they were in 2.9.5.

00:40:04.500 --> 00:40:08.380
We're adding a lot of features,
a lot of code gen improvements.

00:40:08.580 --> 00:40:12.900
We're going to bring that back
in line with what 2.9.5 was.

00:40:14.530 --> 00:40:16.400
We're working on tuning the PFE.

00:40:16.400 --> 00:40:19.750
The PFE at this point is basically
a big architectural change.

00:40:19.760 --> 00:40:22.960
We've taken the back of the front end,
we saved it out to disk,

00:40:23.090 --> 00:40:24.340
we loaded it back in.

00:40:24.400 --> 00:40:25.520
And that was our big win.

00:40:25.520 --> 00:40:26.730
We got 6x out of that.

00:40:26.820 --> 00:40:30.600
Now we're looking at doing some of the
harder and more incremental things,

00:40:30.600 --> 00:40:33.390
tightening up the data structures,
tightening up the algorithms

00:40:33.450 --> 00:40:38.060
inside the persistent front end,
inside the front end of GCC itself,

00:40:38.140 --> 00:40:43.660
and getting you better turnaround
time even than we're delivering today.

00:40:43.740 --> 00:40:48.150
And finally, expect to see great
PFE support in Project Builder.

00:40:48.220 --> 00:40:52.680
Expect to see just point and click
and you're off and running with the

00:40:52.870 --> 00:40:56.120
new PFE as opposed to CPP Precomp.

00:40:57.840 --> 00:41:02.750
So, GCC 3.1,
you get better C++ compliance,

00:41:02.850 --> 00:41:05.790
you get improved code quality,
and you get

00:41:07.060 --> 00:41:08.680
You get other things.

00:41:08.920 --> 00:41:11.080
Faster compile time.

00:41:11.080 --> 00:41:14.550
And use it now,
but ship with it on Jaguar.

00:41:14.740 --> 00:41:17.040
Again, don't ship with it now.

00:41:18.630 --> 00:41:21.810
So just one more pointer to
the technical documentation.

00:41:22.430 --> 00:41:27.370
Developer documentation is in
/developer/documentation/devtools.

00:41:27.460 --> 00:41:28.890
There's stuff on the compiler.

00:41:29.180 --> 00:41:30.560
There's the GCC release notes.

00:41:30.690 --> 00:41:35.860
There's write-up on the preprocessor,
on the debugger, and also a brand new

00:41:35.860 --> 00:41:38.830
book on the Mako runtime,
which should be very interesting

00:41:38.830 --> 00:41:41.760
to anybody who really gets into
reading about the Mako runtime.

00:41:41.800 --> 00:41:45.810
So at this point,
I think it's time for Godfrey again.

00:41:54.800 --> 00:41:55.800
Thank you, John.

00:41:55.800 --> 00:41:56.800
Testimony to a lot of work.

00:41:56.800 --> 00:42:00.430
A big hand for John and his team
who are all in the front row here.

00:42:02.720 --> 00:42:05.700
We intentionally wanted to leave a lot of
time for questions during this session,

00:42:05.700 --> 00:42:09.100
so just a very brief look at the
roadmap for the rest of the day.

00:42:09.100 --> 00:42:12.680
This afternoon, we have our session,
Delivering with Project Builder,

00:42:12.770 --> 00:42:15.480
which talks about how to get
the most out of Project Builder,

00:42:15.510 --> 00:42:17.580
utilize the build system
to great advantage.

00:42:17.850 --> 00:42:22.700
We have the Development Tools Feedback
Forum in Room J1 right next door.

00:42:22.700 --> 00:42:28.290
And then we close the day
with Debugging in Mac OS X.

00:42:28.290 --> 00:42:28.290
And I hope to see you all there.

00:42:29.200 --> 00:42:30.890
Contacts for Development Tools.

00:42:30.960 --> 00:42:33.980
I'm always a primary contact
if you have business issues,

00:42:34.010 --> 00:42:37.300
if you want to talk to people on
the engineering team in person,

00:42:37.370 --> 00:42:39.570
I can always help to facilitate that.

00:42:39.570 --> 00:42:42.390
We have a mailing address,
which you've seen in many

00:42:42.390 --> 00:42:43.540
of our Tools sessions,
for the

00:42:43.540 --> 00:42:46.340
Development Tools Engineering feedback.

00:42:46.340 --> 00:42:50.760
This talks to the managers and key
people throughout the organization.

00:42:50.760 --> 00:42:52.300
And also for bug reporting.

00:42:52.430 --> 00:42:53.690
We want to hear your bugs.

00:42:53.720 --> 00:42:56.460
We have a project builder users
mailing list and several other

00:42:56.470 --> 00:43:00.000
development mailing lists where people
talk about problems they've run into.

00:43:00.200 --> 00:43:03.730
What we need to see is things that are
identified as bugs reported to us with

00:43:03.770 --> 00:43:07.480
Bug Reporter so that they're on our map,
so they're on our priority list.
WEBVTT

00:00:10.090 --> 00:00:12.880
Good afternoon and
welcome to session 507,

00:00:12.880 --> 00:00:14.750
which is about audio and MIDI.

00:00:14.830 --> 00:00:16.040
I'm Craig Keithley.

00:00:16.040 --> 00:00:18.430
I'm Apple's USB and FireWire evangelist.

00:00:18.480 --> 00:00:22.860
As I mentioned in the session yesterday,
audio is one of my favorite topics,

00:00:22.860 --> 00:00:25.760
and so I'm happy to help
with this session today.

00:00:25.850 --> 00:00:28.860
Some of the topics we're going to talk
about are going to be the core audio,

00:00:28.860 --> 00:00:31.320
how, and I'm going to bring
Jeff Moore up here in a second.

00:00:31.390 --> 00:00:33.790
Before I do,
I just want to say that some of

00:00:33.790 --> 00:00:35.370
today's equipment is kind of special.

00:00:35.460 --> 00:00:38.240
We work closely with Harman
Kardon on a lot of areas.

00:00:38.240 --> 00:00:41.470
As you can see,
we've got JBL speakers all around here.

00:00:41.550 --> 00:00:46.160
We've got a high-end Harman
Kardon AVR-8000 that's doing AC3

00:00:46.280 --> 00:00:49.280
or SPDIF to multi-channel decode.

00:00:49.280 --> 00:00:50.030
We like Harman.

00:00:50.120 --> 00:00:51.300
They do a lot of good things for us.

00:00:51.440 --> 00:00:51.910
Thank you very much.

00:00:52.030 --> 00:00:52.120
Jeff.

00:01:00.010 --> 00:01:02.170
So as Craig said, my name is Jeff Moore.

00:01:02.450 --> 00:01:05.300
I'm an engineer with
the Core Audio Group.

00:01:05.370 --> 00:01:08.920
I'm going to tell you a little
bit about the HAL today.

00:01:08.920 --> 00:01:15.820
I hope to impart the anatomy
of how things work and at least

00:01:15.840 --> 00:01:19.750
get you kind of familiarized
with how the API is laid out.

00:01:19.780 --> 00:01:24.110
So as most of you know,
the HAL provides the lowest level

00:01:24.110 --> 00:01:27.080
access to audio devices in Mac OS X.

00:01:27.120 --> 00:01:32.320
The HAL supports pretty much any
kind of audio device you can imagine,

00:01:32.320 --> 00:01:36.220
as long as there's a driver for it,
from simple consumer

00:01:36.220 --> 00:01:38.220
gear to complex pro gear.

00:01:38.220 --> 00:01:43.510
The key things that we do
with the HAL is multi-channel,

00:01:43.820 --> 00:01:47.380
high sample rates,
and new with Jaguar this year is

00:01:47.380 --> 00:01:51.580
support for nonlinear PCM formats
to be sent to hardware.

00:01:54.790 --> 00:01:58.980
To get you started with the HAL API,
you should know that it's a

00:01:58.980 --> 00:02:03.130
loosely object-oriented API,
but it's a C API.

00:02:03.140 --> 00:02:07.740
Understanding the object
hierarchy is important for

00:02:07.740 --> 00:02:09.130
understanding how the HAL works.

00:02:09.140 --> 00:02:15.190
One of the common things you'll find with
all the Core Audio APIs is that we use

00:02:15.190 --> 00:02:20.500
what we call properties to provide access
to a manipulation of state and behavior

00:02:20.900 --> 00:02:23.440
of all different kinds of objects.

00:02:24.140 --> 00:02:27.940
What I say about properties here are
generally true for properties just

00:02:27.940 --> 00:02:29.710
about anywhere in the audio system.

00:02:32.420 --> 00:02:36.760
So, property objects are
addressed as key-value pairs.

00:02:37.150 --> 00:02:40.300
The keys will vary from object
to object and API to API,

00:02:40.300 --> 00:02:45.300
but they will always
include an integer ID.

00:02:45.300 --> 00:02:54.690
And the value is always an untyped
block of memory whose contents is going

00:02:54.690 --> 00:02:54.690
to be predetermined based on the ID.

00:02:54.800 --> 00:02:58.200
In the HAL,
all the get property info routines

00:02:58.200 --> 00:03:03.100
for the various objects provide
you with the size of the property

00:03:03.100 --> 00:03:07.700
as well as whether or not you
can actually set that property.

00:03:07.700 --> 00:03:10.790
A lot of properties don't
necessarily require you to call

00:03:10.790 --> 00:03:14.700
get property info because their
size is always predetermined.

00:03:14.700 --> 00:03:17.050
A good example is the
buffer size of the HAL,

00:03:17.060 --> 00:03:20.100
which is always going
to be a 32-bit integer.

00:03:21.170 --> 00:03:27.980
So the HAL also provides notifications
for when property value changes.

00:03:27.980 --> 00:03:33.190
The client can sign up for notifications
for all properties that the HAL provides,

00:03:33.190 --> 00:03:36.860
and they just provide a property
listener proc to the HAL through the

00:03:36.910 --> 00:03:39.380
appropriate add property listener calls.

00:03:41.440 --> 00:03:44.360
The other thing that makes this a little
easier is that the HAL supports wildcards

00:03:44.450 --> 00:03:48.620
for the various different aspects of what
you have to set up to get a listener.

00:03:48.620 --> 00:03:53.930
An example is you might want to listen
to all the properties on a given channel,

00:03:53.930 --> 00:03:59.640
or you just might want to listen to all
the volume notifications for this device.

00:03:59.640 --> 00:04:03.480
The permutations can get pretty rich.

00:04:03.500 --> 00:04:10.080
Your listener proc is going to get
called on the HAL's CF run loop.

00:04:10.500 --> 00:04:14.380
The HAL provides a global property
in each process to allow you to

00:04:14.380 --> 00:04:18.630
actually manage what this CF run
loop is and what thread it runs on.

00:04:18.700 --> 00:04:24.190
For most Carbon and Cocoa-based apps,
you're going to want to actually set

00:04:24.190 --> 00:04:29.500
this run loop to your app's main run
loop to allow you to do things like draw

00:04:29.610 --> 00:04:32.740
when the property listener fires off.

00:04:34.190 --> 00:04:38.750
Another thing to remember about
properties in the how is that changing

00:04:38.750 --> 00:04:41.060
them is an asynchronous operation.

00:04:41.060 --> 00:04:46.220
You definitely want to wait for
a notification to come back from

00:04:46.220 --> 00:04:50.220
the system before you assume that
the value has actually changed.

00:04:50.220 --> 00:04:53.980
A common place where people have
been falling into this trap is when

00:04:54.050 --> 00:04:55.840
setting the formats of a device.

00:04:55.840 --> 00:04:59.000
You definitely don't want to
assume the format is just set

00:04:59.010 --> 00:05:00.710
when you call set property.

00:05:00.710 --> 00:05:04.070
You want to wait until you get the
appropriate notifications back.

00:05:04.100 --> 00:05:08.070
So it's very important that you sign up
for all the notifications that you need.

00:05:10.140 --> 00:05:12.550
The first object that I'd
like to talk about in the

00:05:12.550 --> 00:05:14.180
HAL is the HAL system object.

00:05:14.710 --> 00:05:19.090
It's addressed in the
API for the routines that are

00:05:19.090 --> 00:05:21.520
prefixed with audio hardware.

00:05:21.540 --> 00:05:25.990
Its job is to manage the
process global state for the

00:05:25.990 --> 00:05:29.200
HAL in that individual process.

00:05:29.340 --> 00:05:34.140
Its properties are only
addressed by their four care IDs.

00:05:34.140 --> 00:05:37.650
Some of the interesting properties
in the global object are going

00:05:37.650 --> 00:05:42.040
to be the device list property,
K-audio hardware property devices,

00:05:42.040 --> 00:05:45.010
the run loop property,
which I mentioned previously,

00:05:45.010 --> 00:05:47.460
as well as a new property
that we've added,

00:05:47.500 --> 00:05:49.390
which is something you
should pay attention to.

00:05:49.470 --> 00:05:58.450
If you're using audio sporadically,
you will probably want... New in Jaguar,

00:05:58.450 --> 00:06:03.360
the HAL has brought in a new property
that will prevent it from unloading

00:06:03.470 --> 00:06:06.240
itself after a given timeout.

00:06:06.240 --> 00:06:09.320
there's a property that allows
you to turn that on and off.

00:06:09.590 --> 00:06:12.900
The next object in the how
is the audio device object.

00:06:12.900 --> 00:06:17.270
The audio device object is
the basic unit for doing I.O.

00:06:17.270 --> 00:06:18.860
and also for doing timing.

00:06:18.860 --> 00:06:24.380
The properties in the device
object are addressed by the ID,

00:06:24.380 --> 00:06:28.860
the direction for the section
that the property applies to,

00:06:28.860 --> 00:06:32.540
and that's going to be input or output,
and what individual channel

00:06:32.540 --> 00:06:34.420
that you're speaking about.

00:06:35.540 --> 00:06:39.350
Some important properties that
you have for the device object

00:06:39.350 --> 00:06:42.550
are the buffer frame size,
which allows you to

00:06:42.550 --> 00:06:44.460
change the size of I.O.

00:06:44.850 --> 00:06:46.670
that you do in each I.O.

00:06:46.710 --> 00:06:49.680
proc,
as well as the stream configuration,

00:06:49.680 --> 00:06:54.560
which allows you to get the buffer
layout of the device prior to your I.O.

00:06:54.560 --> 00:06:58.540
proc being called so you know
what to expect when your I.O.

00:06:58.540 --> 00:06:59.880
proc is called.

00:06:59.880 --> 00:07:05.190
Then you can change the device's format
using the stream format property.

00:07:07.450 --> 00:07:12.150
The devices are broken down
into stream objects as well.

00:07:12.150 --> 00:07:20.390
Stream objects represent a single
buffer of I/O on the device.

00:07:20.400 --> 00:07:24.400
Their properties are adjusted
just by the ID and the channel.

00:07:24.400 --> 00:07:26.940
The direction is implicit
in the stream itself,

00:07:27.060 --> 00:07:30.400
because streams can only
be either input or output.

00:07:30.570 --> 00:07:34.220
Some of the stream properties that
you're going to be interested in getting

00:07:34.220 --> 00:07:38.030
a hold of is the starting channel,
which tells you what channel number that

00:07:38.040 --> 00:07:40.390
that stream's first channel applies to.

00:07:40.400 --> 00:07:43.850
If you have a multi-channel
device with multiple streams and

00:07:43.850 --> 00:07:47.010
you're looking at just a stream,
you need to know this is

00:07:47.010 --> 00:07:49.080
channel 5 out of 8 or whatever.

00:07:49.400 --> 00:07:52.770
Then you can also set the
format for the device,

00:07:52.770 --> 00:07:56.300
the physical format,
which is a little different

00:07:56.340 --> 00:07:58.400
from the virtual format.

00:07:58.400 --> 00:07:59.370
This is the device that the
audio and MIDI system uses.

00:07:59.430 --> 00:08:05.400
This is the format that the device is
actually doing I/O with the hardware on.

00:08:05.550 --> 00:08:09.390
That would be like 16-bit
integer versus 24-bit integer,

00:08:09.390 --> 00:08:10.400
for instance.

00:08:11.560 --> 00:08:15.940
So that pretty much wraps up
kind of what the HAL looks like.

00:08:15.990 --> 00:08:19.120
I'm going to talk a little bit,
I'm going to show you a little

00:08:19.210 --> 00:08:22.750
bit some of these concepts in a
moment with some of our new stuff,

00:08:22.890 --> 00:08:25.900
but I'm also going to talk a lot,
show you a lot about playing

00:08:26.030 --> 00:08:28.900
an AC3 file now with the HAL,
sending it straight to

00:08:28.900 --> 00:08:30.460
hardware for decoding.

00:08:31.360 --> 00:08:33.500
Before we get started,
I'll tell you a little

00:08:33.500 --> 00:08:35.070
bit about AC3 bit streams.

00:08:35.070 --> 00:08:39.410
Each packet is 1536 frames in size.

00:08:39.410 --> 00:08:42.920
That's roughly 30
milliseconds of time at 48K.

00:08:42.920 --> 00:08:46.770
Each packet does vary in byte size.

00:08:46.770 --> 00:08:51.220
AC3 is implicitly a
variable bit rate format.

00:08:51.220 --> 00:08:56.130
Each packet, much like MPEG,
starts with a 16-bit sync word.

00:08:56.160 --> 00:09:02.790
To get AC3 into a format that you can
put on a digital interface like SPDIF,

00:09:03.340 --> 00:09:05.120
you have to add an
additional 8-byte header.

00:09:05.120 --> 00:09:07.760
I'm going to go in to show you
a little bit about that as well.

00:09:15.160 --> 00:09:16.870
Could we bring up demo four, please?

00:09:16.870 --> 00:09:18.100
Thank you.

00:09:18.130 --> 00:09:23.230
So the first thing I want to show you is
a new application that we have in Jaguar

00:09:23.700 --> 00:09:26.160
called the Audio MIDI Setup application.

00:09:26.180 --> 00:09:31.600
It is a richer UI on the
individual audio devices as well

00:09:31.600 --> 00:09:34.600
as configuring MIDI devices.

00:09:34.940 --> 00:09:37.750
I'm going to tell you a little
bit about its audio support,

00:09:37.750 --> 00:09:41.220
and we'll hear about the
MIDI support a little bit later.

00:09:41.220 --> 00:09:45.440
As you can see,
it gives you a dashboard interface

00:09:45.440 --> 00:09:48.880
on pretty much what a HAL device is.

00:09:48.880 --> 00:09:53.130
Here you see the built-in controller,
and it's showing up

00:09:53.370 --> 00:09:56.840
exactly what it can do.

00:09:56.840 --> 00:09:59.870
In this case,
the built-in audio controller doesn't

00:09:59.870 --> 00:10:04.840
support a global input and output volume,
but it does support a global

00:10:04.840 --> 00:10:09.720
out/mute button as well as a
global play-through option.

00:10:09.720 --> 00:10:11.960
Each of the individual
channels has volume,

00:10:11.960 --> 00:10:14.000
as you can see down here.

00:10:14.900 --> 00:10:21.800
So when we go to other devices,
like the USB AudioSport MD-1,

00:10:21.800 --> 00:10:24.230
which I'll be using to
demonstrate our AC3 playback,

00:10:24.230 --> 00:10:31.290
you can see that this device is
a USB device and... Where is it?

00:10:31.360 --> 00:10:33.380
I'll show it to you.

00:10:33.400 --> 00:10:35.590
Here it is.

00:10:36.080 --> 00:10:39.340
As you can see,
it's a very small digital output.

00:10:39.340 --> 00:10:42.410
It connects over the USB bus,
and it provides an

00:10:42.540 --> 00:10:44.890
optical SPDIF connection.

00:10:49.730 --> 00:10:54.390
So you can change the default
device and you can get and set

00:10:54.410 --> 00:10:56.600
the device's format as well.

00:10:56.600 --> 00:11:00.440
As you can see right now,
the device's format is set up for AC3.

00:11:00.570 --> 00:11:01.940
You can move it around.

00:11:01.940 --> 00:11:05.480
This device happens to support all
sorts of different sample rates and

00:11:05.480 --> 00:11:08.830
a couple of different bit depths.

00:11:08.960 --> 00:11:13.340
I'm going to be playing an AC3 file,
so I'm just going to set it up for AC3

00:11:18.580 --> 00:11:22.860
So to play an AC3 file,
I've written a small command line

00:11:23.090 --> 00:11:29.770
tool that parses an AC3 file and
doles out the packets to the hardware.

00:11:29.770 --> 00:11:30.880
The I.O.

00:11:30.880 --> 00:11:36.040
path for dealing with encoded audio
is slightly different for dealing

00:11:36.150 --> 00:11:38.550
with normal linear PCM audio.

00:11:39.190 --> 00:11:41.540
The key difference is, in your I.O.

00:11:41.540 --> 00:11:45.140
proc, when you provide data
back to the output buffer,

00:11:45.140 --> 00:11:52.360
you also need to change the data size
to say how many bytes you've provided.

00:11:52.360 --> 00:11:57.800
For constant bitrate formats like
the AC3 on the digital interface,

00:11:57.800 --> 00:12:01.850
the number of bytes is
always going to be the same.

00:12:01.850 --> 00:12:05.500
But if you're talking about a
variable bitrate AC3 format,

00:12:05.500 --> 00:12:08.160
that number will change with every frame.

00:12:08.600 --> 00:12:13.710
The structure of my little command
line tool is I've abstracted out

00:12:13.780 --> 00:12:16.840
each device into a little C++ object.

00:12:16.840 --> 00:12:18.580
Here's the initialized routine.

00:12:18.580 --> 00:12:22.590
One of the other interesting things
that we've added in Jaguar to the HAL is

00:12:22.590 --> 00:12:26.870
the ability to turn individual streams
on and off for each individual I.O.

00:12:26.870 --> 00:12:27.460
proc.

00:12:27.610 --> 00:12:32.790
If you're not using the input section,
you should go in and turn it off.

00:12:32.790 --> 00:12:38.280
I'll show you some code here in a
second that shows how to do that.

00:12:43.510 --> 00:12:49.030
Here's the C++ method in my
device superclass that allows me

00:12:49.090 --> 00:12:55.210
to call the HAL API to tell it,
hey, turn off this set of input streams.

00:12:55.270 --> 00:12:59.500
It takes an array of bools in
to say which streams to leave on

00:12:59.500 --> 00:13:01.010
and which streams to leave off.

00:13:01.570 --> 00:13:08.860
The HAL API actually uses UN32s
to carry those boolean values.

00:13:08.860 --> 00:13:13.600
It has to construct the list,
which must match the stream

00:13:13.830 --> 00:13:15.770
configuration of the device.

00:13:15.840 --> 00:13:17.220
You can't have less streams.

00:13:17.320 --> 00:13:18.860
You can't specify more streams.

00:13:18.860 --> 00:13:20.220
It must be precise.

00:13:20.250 --> 00:13:24.050
It gets the number of streams,
and it allocates a buffer.

00:13:24.050 --> 00:13:27.350
Then it stuffs in all
those boolean values.

00:13:27.460 --> 00:13:32.240
Then all you have to do to tell
the HAL to turn off the streams

00:13:32.240 --> 00:13:36.130
for that IOPROC is to just set
the property on the device.

00:13:36.130 --> 00:13:37.240
Here you see an example.

00:13:37.260 --> 00:13:41.910
I'm calling audio device set property,
where it's passing in the device

00:13:41.910 --> 00:13:46.380
ID that we're working with,
the IOPROC stream usage

00:13:46.400 --> 00:13:50.580
property for the output section.

00:13:50.580 --> 00:13:53.480
The channel number on this
isn't really important,

00:13:53.490 --> 00:13:55.320
so you can put anything.

00:13:55.320 --> 00:13:59.380
In this case, I put one,
which is a fine idea when in doubt.

00:13:59.380 --> 00:14:03.910
Then you just pass in the size and
the pointer that has the struct

00:14:04.520 --> 00:14:06.850
containing the stream usage.

00:14:09.100 --> 00:14:10.950
So once you've turned
off all the streams,

00:14:10.950 --> 00:14:12.880
the next thing to do is to open the file.

00:14:12.880 --> 00:14:14.280
You parse the file.

00:14:14.320 --> 00:14:19.740
You'll get the packetization that
I described earlier for the file.

00:14:19.740 --> 00:14:23.880
And then you register your I/O proc.

00:14:23.880 --> 00:14:26.080
And once you've done that,
you've just got to feed the

00:14:26.090 --> 00:14:29.360
data back to the output buffers.

00:14:29.360 --> 00:14:32.760
And the way you do that
is a little different.

00:14:32.760 --> 00:14:37.920
Here's the I/O proc for this.

00:14:37.920 --> 00:14:37.920
No, that's not it.

00:14:39.540 --> 00:14:45.090
Here's the I/O proc for this device,
or for this application.

00:14:45.420 --> 00:14:46.130
It comes in.

00:14:46.130 --> 00:14:49.860
Now, this code is a little simplistic,
so it makes the assumption that the

00:14:49.860 --> 00:14:53.080
device only really ever has one stream,
and that's the stream it's

00:14:53.130 --> 00:14:55.740
going to be doing I/O on.

00:14:55.740 --> 00:14:58.060
In reality,
you'll probably want to change

00:14:58.190 --> 00:15:03.400
that based on the number of
streams the device really has.

00:15:03.400 --> 00:15:07.370
So, for here, we get the device,
we cast it to a pointer to bytes,

00:15:07.370 --> 00:15:13.310
so that later on when we're
going to copy the data,

00:15:13.370 --> 00:15:15.630
the AC3 data into, um, the AC3 data,
we're

00:15:16.500 --> 00:15:37.900
[Transcript missing]

00:15:38.200 --> 00:15:44.780
The first thing it does is reinterpret
the buffer as a 16-bit buffer,

00:15:44.830 --> 00:15:48.030
because AC3 is inherently
a two-byte format.

00:15:48.090 --> 00:15:51.060
Then it just starts
stuffing in the header.

00:15:51.200 --> 00:15:54.790
For the digital interface for AC3,
there are some bits that you have

00:15:54.790 --> 00:15:57.930
to fill out that are based on
the actual values in the stream.

00:15:58.420 --> 00:16:03.940
You fill out the sync word,
and then you fill out all the

00:16:03.940 --> 00:16:05.230
appropriate stuff for the header.

00:16:05.540 --> 00:16:09.500
And then you just copy the next
buffer into the output buffer.

00:16:09.500 --> 00:16:14.050
Now, a key thing to remember about the
constant bitrate AC3 is quite often

00:16:14.160 --> 00:16:16.140
the data needs to be little-endian.

00:16:16.150 --> 00:16:19.860
On the disk,
AC3 is almost always big-endian.

00:16:19.970 --> 00:16:22.100
So once you're done,
you have to go through and

00:16:22.100 --> 00:16:25.080
byte swap everything so it gets
put out on the wire correctly.

00:16:25.080 --> 00:16:28.430
And here's some code for doing that.

00:16:29.240 --> 00:16:34.490
And then once you're done,
it just updates the file position

00:16:34.490 --> 00:16:36.750
and writes back out to the

00:16:37.660 --> 00:16:40.410
The data size that it just wrote.

00:16:40.410 --> 00:16:46.230
Now I'm going to play some AC3 files
to give you a feel for what's going on

00:16:46.230 --> 00:16:48.920
and show that it actually all works.

00:16:50.680 --> 00:16:54.470
So the first file is
kind of a noisy file,

00:16:54.470 --> 00:16:57.980
but it'll show that there's
sound coming out of each channel.

00:17:25.450 --> 00:17:30.580
That's a test file that just puts a
different sound source in each channel.

00:17:30.580 --> 00:17:34.110
Here's another test file that's
some more musical content.

00:18:11.610 --> 00:18:13.940
To close this off,
I wish I could turn this around.

00:18:13.940 --> 00:18:16.750
You can see that we've got this
big Carmen Harden amp that's

00:18:16.750 --> 00:18:18.530
doing the decoding for us.

00:18:18.530 --> 00:18:22.130
You can see all the channel
lights turning on and off.

00:18:22.130 --> 00:18:26.470
It's just coming straight over
the optical spit of connection.

00:18:26.570 --> 00:18:29.860
To close out,
I'd like to just ask all the hardware

00:18:29.940 --> 00:18:33.990
developers to please make every
effort you can to conform to the

00:18:33.990 --> 00:18:36.320
relevant spec governing your hardware.

00:18:36.320 --> 00:18:39.520
One of the key things that we've
had bringing up the support is that

00:18:39.520 --> 00:18:43.870
some devices will say they can do
digital I/O and some devices won't,

00:18:43.930 --> 00:18:47.640
even though they have a
digital connection on them.

00:18:47.690 --> 00:18:50.720
It's very hard for us to do
the right thing if you're

00:18:50.720 --> 00:18:52.850
not conforming to the spec.

00:18:52.950 --> 00:18:55.990
With that,
I'd like to bring up Doug Wyatt,

00:18:55.990 --> 00:18:59.430
and he's going to
discuss the MIDI support.

00:19:07.800 --> 00:19:09.140
Thanks, Jeff.

00:19:09.230 --> 00:19:09.740
Good afternoon.

00:19:09.740 --> 00:19:10.480
I'm Doug Wyatt.

00:19:10.540 --> 00:19:12.860
I'm an engineer in the Core Audio Group.

00:19:12.950 --> 00:19:17.780
I work on various pieces of the system,
but I'm primarily responsible

00:19:17.780 --> 00:19:20.300
for the Core MIDI framework.

00:19:21.990 --> 00:19:24.510
So today,
I recognize there are some of you who

00:19:24.510 --> 00:19:28.020
haven't worked with core MIDI before,
but there are probably a lot of

00:19:28.030 --> 00:19:31.840
you who have seen me give the
same talk two years in a row,

00:19:31.840 --> 00:19:35.440
going through all the basics of the API.

00:19:35.440 --> 00:19:39.770
So as I figured out how
I was going to organize this,

00:19:39.770 --> 00:19:42.680
I thought, okay,
we'll just go through the

00:19:42.680 --> 00:19:46.560
API concept by concept,
and we'll touch on the areas that

00:19:46.710 --> 00:19:51.040
are causing a lot of questions
for developers and introduce

00:19:51.040 --> 00:19:54.210
some new features for Jaguar.

00:19:57.210 --> 00:20:01.540
So architecturally,
core MIDI sits on top of

00:20:01.590 --> 00:20:03.880
I/O Kit and the kernel.

00:20:04.080 --> 00:20:09.570
and we have higher level services in
the audio toolbox that also use core

00:20:09.570 --> 00:20:15.450
MIDI such as the sequencing services and
the AU MIDI controller for controlling

00:20:15.450 --> 00:20:18.160
music devices and audio units.

00:20:18.240 --> 00:20:27.670
And your client application, of course,
can also talk to core MIDI directly for

00:20:27.670 --> 00:20:27.670
high performance access to MIDI devices.

00:20:30.990 --> 00:20:36.140
So looking at the core
MIDI implementation,

00:20:36.350 --> 00:20:42.160
Down in the kernel we have the I/O Kit,
where we do all our I/O.

00:20:42.160 --> 00:20:46.290
We have a MIDI server process,
which is in user space.

00:20:46.400 --> 00:20:51.080
The MIDI server loads MIDI drivers,
which are CFPlugins.

00:20:51.870 --> 00:20:54.640
And on top of that,
we have the core MIDI framework,

00:20:54.710 --> 00:20:57.140
which your client
application links against.

00:20:57.140 --> 00:21:02.340
The core MIDI framework uses
Mach interprocess communication to

00:21:02.520 --> 00:21:08.170
talk to the MIDI server and implement
the API that your application uses.

00:21:15.440 --> 00:21:19.290
So the first concept I'd like
to go over in the API is the

00:21:19.290 --> 00:21:23.340
MIDI device entity and endpoint.

00:21:23.340 --> 00:21:25.860
These structures are hierarchical.

00:21:25.860 --> 00:21:29.060
Devices contain entities,
which are logically

00:21:29.060 --> 00:21:30.910
distinct subcomponents.

00:21:30.910 --> 00:21:35.450
One example is a multiport
MIDI interface like this Roland device

00:21:35.470 --> 00:21:39.640
we have on the screen here,
or Edderall, I should say.

00:21:39.680 --> 00:21:43.520
This is a graphic from our
audio MIDI setup application,

00:21:43.560 --> 00:21:46.200
which Jeff showed you,
and I'll be showing you the MIDI pane

00:21:46.340 --> 00:21:51.400
in that application in a moment.

00:21:51.400 --> 00:21:53.960
So the big -- you know,
the device itself has an icon.

00:21:54.070 --> 00:21:56.740
These little nubs
underneath are the entities,

00:21:56.740 --> 00:22:01.460
and an entity is simply a grouping
of source and destination endpoints.

00:22:01.460 --> 00:22:06.280
And so we see this device publishes
itself as having nine entities,

00:22:06.280 --> 00:22:10.240
each with one source and
one destination endpoint.

00:22:12.280 --> 00:22:17.690
So these are driver-owned devices which
are distinct from external devices,

00:22:17.700 --> 00:22:20.190
which I'll bring up later in the talk.

00:22:23.060 --> 00:22:25.900
Okay,
contrary to what Jeff was just saying

00:22:25.900 --> 00:22:29.910
about most of our property APIs using--

00:22:30.300 --> 00:22:34.810
and So, in terms of the integer
keys and void types,

00:22:34.810 --> 00:22:36.660
the MIDI API is a bit different.

00:22:36.660 --> 00:22:41.150
Our properties in the MIDI API have
to use strings for their keys

00:22:41.150 --> 00:22:43.950
for some implementation reasons.

00:22:44.220 --> 00:22:48.560
But in any case, the concept is the same.

00:22:48.560 --> 00:22:53.040
Devices and entities and endpoints
all have these properties.

00:22:53.430 --> 00:22:57.250
and furthermore,
since devices contain entities

00:22:57.380 --> 00:23:01.230
which contain endpoints,
we have an inheritance mechanism

00:23:01.230 --> 00:23:03.520
in place for these properties.

00:23:03.630 --> 00:23:06.440
So, for instance,
the device has a property saying

00:23:06.440 --> 00:23:10.720
that its manufacturer name is XCorp.

00:23:10.720 --> 00:23:17.490
But if you were to ask the endpoint
for the manufacturer property,

00:23:17.490 --> 00:23:19.950
it would be inheriting that
property from the device.

00:23:21.340 --> 00:23:26.100
and David But by contrast,
the name property is set separately

00:23:26.100 --> 00:23:28.260
on each of these three objects.

00:23:28.270 --> 00:23:30.640
The device has a name,
the entity has a name,

00:23:30.640 --> 00:23:32.300
and the endpoint has a name.

00:23:32.330 --> 00:23:36.630
So properties can either be
inherited or set individually

00:23:36.630 --> 00:23:38.890
on the objects in the API.

00:23:41.870 --> 00:23:49.360
So on these driver-created objects,
the driver will set the properties.

00:23:49.460 --> 00:23:53.480
And as far as the standard properties go,
your application shouldn't

00:23:53.480 --> 00:23:56.550
be touching those properties
on the driver-owned devices.

00:23:56.550 --> 00:24:00.420
You can look at them,
and that's what they're there for.

00:24:00.420 --> 00:24:02.070
They're there for you to interrogate.

00:24:02.070 --> 00:24:05.240
But you shouldn't touch
the standard properties.

00:24:05.380 --> 00:24:11.210
But if you have some reason to
store private information attached

00:24:11.210 --> 00:24:17.730
to a device or entity or endpoint,
you can attach a private property.

00:24:17.730 --> 00:24:20.770
And the header file
tells you how to do that.

00:24:24.220 --> 00:24:28.920
One thing that has come up as people
use the MIDI APIs is a bit of confusion

00:24:29.420 --> 00:24:34.540
about how to display the names of
the source and destination endpoints.

00:24:34.540 --> 00:24:38.590
Since there are names at all
three levels of the hierarchy,

00:24:38.780 --> 00:24:43.380
the simplest way to do this,
which seems to be most reliable and

00:24:43.380 --> 00:24:49.260
provide the best user experience,
is to first ask for the endpoint name.

00:24:49.260 --> 00:24:52.800
In the case of that Roland interface,
which I showed you a moment ago,

00:24:52.900 --> 00:24:56.660
you might just see port 1, port 2,
port 3, and so on.

00:24:56.750 --> 00:24:58.830
In a lot of situations,
if there's only one

00:24:58.830 --> 00:25:02.460
MIDI interface in the system,
that will be a unique name,

00:25:02.500 --> 00:25:05.260
and that's all you really
need to show the user.

00:25:05.340 --> 00:25:09.000
If it's not unique, there might be two of
those MIDI interfaces,

00:25:09.110 --> 00:25:13.620
then you can prepend the device
name to the endpoint name,

00:25:13.720 --> 00:25:16.770
and that should give you a unique name.

00:25:20.860 --> 00:25:23.860
Another thing that has come
up as people use the APIs,

00:25:23.860 --> 00:25:28.040
there's a bit of confusion about how
to actually go and locate MIDI sources

00:25:28.040 --> 00:25:30.460
and destinations in the system.

00:25:30.540 --> 00:25:39.890
And there's two completely different
ways to find these endpoints,

00:25:39.890 --> 00:25:39.890
and they each have their uses.

00:25:39.890 --> 00:25:39.890
When you're doing MIDI.io,

00:25:40.410 --> 00:25:44.400
The recommended way,
and this is true for most circumstances,

00:25:44.400 --> 00:25:47.040
is the first method here,
which is to just iterate

00:25:47.190 --> 00:25:49.660
through the source and
destination endpoints directly.

00:25:49.660 --> 00:25:52.420
There are the functions
MIDI get number of sources,

00:25:52.420 --> 00:25:57.000
get number of destinations,
MIDI get source by index.

00:25:57.000 --> 00:25:58.450
That's not the name of the function.

00:25:58.460 --> 00:26:01.400
It's just called MIDI get source,
but you're passing it one of the indexes.

00:26:01.400 --> 00:26:03.940
And that's the best
way to find endpoints.

00:26:03.940 --> 00:26:07.580
And you have to use that set of
APIs if you want to see virtual

00:26:07.580 --> 00:26:09.540
sources and destinations.

00:26:10.420 --> 00:26:15.070
There are some specialized
circumstances where you want to

00:26:15.070 --> 00:26:19.660
walk through the device tree and see
absolutely everything that's there.

00:26:19.660 --> 00:26:26.500
So you can index through the
devices in the system and find out,

00:26:26.660 --> 00:26:29.290
and then you can walk through
each device's entities and

00:26:29.290 --> 00:26:30.850
each entity's endpoints.

00:26:30.880 --> 00:26:34.510
And that way you'll see even more
endpoints in some situations.

00:26:34.520 --> 00:26:40.380
But one reason you might want to do that
is if you're doing some sort of studio.

00:26:40.380 --> 00:26:43.810
If you're doing a studio setup view,
you might want to actually show the

00:26:44.150 --> 00:26:46.010
objects which aren't present right now.

00:26:46.020 --> 00:26:50.550
But of course the danger in doing
this hierarchical walk is that

00:26:50.550 --> 00:26:53.200
you will see some special objects.

00:26:53.320 --> 00:26:56.140
You'll see some offline endpoints.

00:26:56.140 --> 00:27:01.590
Offline meaning an endpoint for a piece
of hardware that isn't present right now.

00:27:01.600 --> 00:27:06.190
So there's an offline property that you
would have to look at if you're walking

00:27:06.200 --> 00:27:08.540
through the studio in this manner.

00:27:11.000 --> 00:27:13.740
You may also see some
objects that are private,

00:27:13.740 --> 00:27:19.460
which is another property that drivers
can attach to their end points.

00:27:19.460 --> 00:27:24.220
And they're not doing that to
try to hide things from you.

00:27:24.220 --> 00:27:29.740
There are situations where drivers
may wish to create end points for

00:27:29.740 --> 00:27:35.950
their own applications to have
private communication channels

00:27:35.950 --> 00:27:38.590
to the device for configuring it.

00:27:38.590 --> 00:27:42.630
So you'll probably want to
hide those private end points.

00:27:42.630 --> 00:27:45.420
They're really not there
to make sense to the user.

00:27:47.420 --> 00:27:50.520
and also if you do this
hierarchical walk you won't see any

00:27:50.620 --> 00:27:54.930
virtual sources or destinations,
as you will if you ask directly

00:27:54.930 --> 00:27:56.780
for the sources and destinations.

00:28:00.430 --> 00:28:04.260
So everything I've spoken
about so far is about the

00:28:04.260 --> 00:28:08.300
driver-created objects in the system.

00:28:08.300 --> 00:28:12.360
In 10.1, we introduced the concept
of external devices,

00:28:12.360 --> 00:28:16.500
but it wasn't a fully
fleshed-out set of APIs.

00:28:16.500 --> 00:28:21.680
There wasn't a studio setup editor
where you could really manipulate them.

00:28:21.680 --> 00:28:26.020
But with our new audio and
MIDI setup application in Jaguar,

00:28:26.020 --> 00:28:30.030
the user will have a way to
create these external devices,

00:28:30.030 --> 00:28:33.940
and we fleshed out how those are
going to look to the user and what

00:28:33.940 --> 00:28:36.550
the APIs to manipulate them are.

00:28:36.760 --> 00:28:41.600
They use the same data structures
as driver-owned devices,

00:28:41.820 --> 00:28:45.610
namely MIDI device, MIDI entity,
and MIDI endpoint.

00:28:45.610 --> 00:28:49.160
These objects have the same properties.

00:28:49.180 --> 00:28:52.660
I'll be describing what those
properties are in more detail later.

00:28:52.660 --> 00:28:55.860
But the user adds them to
the system typically with our

00:28:55.860 --> 00:28:57.750
audio MIDI setup application.

00:28:57.990 --> 00:29:01.890
Although it's using public APIs,
so if you want it to create your own,

00:29:01.970 --> 00:29:05.560
there's nothing we can do
to discourage you from that.

00:29:05.640 --> 00:29:08.150
And actually,
we encourage you to if you have

00:29:08.150 --> 00:29:10.580
some reason you'd like to do that.

00:29:10.710 --> 00:29:13.190
You'll be manipulating the
same global database because

00:29:13.370 --> 00:29:16.620
you're using the same APIs,
and the two applications should

00:29:16.620 --> 00:29:21.100
present -- they should stay in sync
with each other because they're

00:29:21.100 --> 00:29:24.530
both manipulating the same data.

00:29:25.020 --> 00:29:27.870
Another thing I'd like to emphasize
about these external devices is

00:29:27.870 --> 00:29:30.060
that they're completely optional.

00:29:30.190 --> 00:29:33.750
They're just there for the user
to tell us what's there beyond

00:29:33.780 --> 00:29:35.900
the external MIDI connector.

00:29:35.900 --> 00:29:39.150
So instead of displaying
port one to the user,

00:29:39.150 --> 00:29:43.010
you can display the actual
name of the MIDI device.

00:29:48.260 --> 00:29:53.800
So we have these driver-owned devices
and we have the external devices.

00:29:53.800 --> 00:29:58.720
And the way that the connections
between them are represented

00:29:58.720 --> 00:30:04.740
is with a property called
midi-property-connection-unique-ID.

00:30:04.740 --> 00:30:09.570
Every object in the system, the devices,
entities and end points,

00:30:09.570 --> 00:30:12.460
has a 32-bit unique identifier.

00:30:12.540 --> 00:30:17.960
So when we want to signify that
a driver-owned end point has a

00:30:18.090 --> 00:30:22.940
connection to an external end point,
what we do is we set a property

00:30:23.020 --> 00:30:26.430
on the driver end point,
which is the unique ID of the

00:30:26.470 --> 00:30:28.900
external device's end point.

00:30:31.070 --> 00:30:36.210
As of Jaguar, this property can also be
an array of unique IDs,

00:30:36.220 --> 00:30:39.100
so we can signify a fan-out connection.

00:30:39.120 --> 00:30:45.010
One MIDI port may be connected to, say,
half a dozen MIDI devices.

00:30:48.850 --> 00:30:55.000
So from the application's point of view,
a bit more work's involved to look at

00:30:55.000 --> 00:31:02.840
these external devices and entities and
endpoints and obtain their properties.

00:31:03.490 --> 00:31:07.720
um, if you like,
you can skip doing this and you can just

00:31:07.840 --> 00:31:13.200
present the generic view of the world
that you had in 10.1 with just whatever

00:31:13.200 --> 00:31:17.660
information your driver gave you,
but we have this application

00:31:17.660 --> 00:31:21.220
so the user can tell you what's
beyond the MIDI cable now.

00:31:21.220 --> 00:31:22.280
And so here's how you do it.

00:31:22.430 --> 00:31:25.250
After you've followed the
connection unique ID property

00:31:25.410 --> 00:31:29.600
to go find the external object,
then you can use the external

00:31:29.720 --> 00:31:35.260
object's properties to override
those of the driver-owned object.

00:31:35.260 --> 00:31:37.970
So if you want to know
the name of that endpoint,

00:31:37.980 --> 00:31:41.090
you could say, okay,
so external endpoint, what's your name?

00:31:41.280 --> 00:31:44.450
And you might see something
like DX7 instead of the

00:31:44.450 --> 00:31:48.580
driver-owned object's name,
which might be port 1.

00:31:49.250 --> 00:31:52.330
But since there are a lot
of possibilities here,

00:31:52.330 --> 00:31:56.320
that port one might be connected to,
as I said, five different MIDI devices,

00:31:56.320 --> 00:31:58.570
each with different names.

00:31:58.640 --> 00:32:01.860
You might think that it might be
simpler to just display port one

00:32:01.860 --> 00:32:03.940
if there's a lot of devices there.

00:32:03.940 --> 00:32:06.220
You might want to
concatenate all the names.

00:32:06.220 --> 00:32:11.010
You might be able to say, oh,
I know that the DX7 is only on channel

00:32:11.010 --> 00:32:14.220
one and the D50 is only on channel two.

00:32:14.220 --> 00:32:18.540
And so it's a user interface question.

00:32:18.540 --> 00:32:23.750
So we make you perform that
look up yourself right now.

00:32:28.030 --> 00:32:34.810
So just to go over the properties that
you're going to find on the MIDI devices.

00:32:35.350 --> 00:32:39.730
Some of these have
been around since 10.0,

00:32:39.730 --> 00:32:43.130
but we have a few new ones for Jaguar.

00:32:43.390 --> 00:32:47.090
Looking at a device or its endpoints,
you can find out what MIDI channels

00:32:47.090 --> 00:32:49.220
it transmits or receives on.

00:32:49.220 --> 00:32:54.260
You can find out what MIDI event
types it sends and receives.

00:32:54.260 --> 00:32:59.400
You can ask it whether it supports
general MIDI or MIDI machine control.

00:32:59.400 --> 00:33:01.780
And there are a few more
esoteric properties,

00:33:01.780 --> 00:33:04.410
and they're all described
in the header file.

00:33:06.810 --> 00:33:12.260
Some other things that we've done with
properties that are new for Jaguar.

00:33:12.450 --> 00:33:18.750
Since 10.0, we've had a property that
driver-owned endpoints can define

00:33:18.750 --> 00:33:23.600
to support scheduling in advance,
which is good for those companies

00:33:23.600 --> 00:33:28.400
who have hardware that do hardware
scheduling of outgoing MIDI.

00:33:28.400 --> 00:33:32.650
But for virtual destinations,
such as software synths,

00:33:32.650 --> 00:33:35.400
we haven't had that
schedule-ahead capability.

00:33:35.420 --> 00:33:40.410
So a soft synth would only be
receiving its MIDI just at the moment

00:33:40.410 --> 00:33:43.400
it was supposed to be rendering it.

00:33:43.530 --> 00:33:47.670
But now in Jaguar,
the creator of the virtual endpoint

00:33:47.940 --> 00:33:52.970
can set this property saying,
"I want to be scheduled ahead."

00:33:53.170 --> 00:33:57.200
and then the MIDI server will bypass
its normal scheduling process in

00:33:57.380 --> 00:34:00.690
delivering the data to that endpoint.

00:34:00.860 --> 00:34:06.080
The soft synth will receive its MIDI as
soon as the sender schedules it,

00:34:06.200 --> 00:34:10.520
which will hopefully be a
little bit of time in advance,

00:34:10.620 --> 00:34:15.560
so that the soft synth can render
in a sample-accurate manner.

00:34:16.800 --> 00:34:21.100
Another new property,
as might be obvious from

00:34:21.100 --> 00:34:27.220
our setup application,
is that devices have a property on

00:34:27.220 --> 00:34:31.030
them for defining an icon or image.

00:34:31.730 --> 00:34:37.120
and the creator of a virtual
endpoint can set its own unique ID.

00:34:37.120 --> 00:34:40.730
This was actually possible in 10.1,
but we weren't doing any checks to

00:34:40.820 --> 00:34:46.640
make sure that it was actually unique,
which could have been quite problematic.

00:34:46.640 --> 00:34:48.480
We now defend against that.

00:34:48.550 --> 00:34:53.940
And for Jaguar,
we've also defined some new properties

00:34:54.050 --> 00:35:02.020
that allow you to attach XML documents
that describe the device's patch names.

00:35:02.020 --> 00:35:05.070
We had some properties
along these lines in 10.1,

00:35:05.070 --> 00:35:10.100
and as we've worked on the spec,
it became apparent that the property

00:35:10.100 --> 00:35:12.490
set needs to be a little more elaborate.

00:35:12.490 --> 00:35:14.900
And so the old properties
have been deprecated,

00:35:14.900 --> 00:35:17.870
and there's a new one
in place to do this now.

00:35:17.910 --> 00:35:22.510
And I'll be describing that
in a little more detail later.

00:35:24.800 --> 00:35:29.230
and David On our mailing list,
some developers have been

00:35:29.240 --> 00:35:33.850
asking for a few new APIs,
and you asked for them.

00:35:33.870 --> 00:35:34.920
We got them.

00:35:34.920 --> 00:35:37.680
One is MIDI Object Find by Unique ID.

00:35:37.680 --> 00:35:40.800
So given the unique ID of an object,
you don't have to go trundling

00:35:40.800 --> 00:35:43.610
through the whole system to
find out what it refers to.

00:35:43.760 --> 00:35:48.740
You can quickly just get back a
reference to the object and a constant

00:35:48.740 --> 00:35:51.250
to tell you what kind of object it is.

00:35:51.620 --> 00:35:54.400
Previously,
you could only walk down through

00:35:54.400 --> 00:35:58.580
the device entity endpoint
hierarchy from the top down.

00:35:58.600 --> 00:36:01.860
There wasn't any way to
go up that hierarchy.

00:36:01.930 --> 00:36:07.410
So we now have APIs to fetch
a device given an entity and

00:36:07.410 --> 00:36:10.550
to fetch the entity that owns

00:36:13.670 --> 00:36:18.250
One other thing that developers ask
about from time to time is how to save

00:36:18.250 --> 00:36:24.700
references to the objects in the API,
such as MIDI endpoints.

00:36:24.700 --> 00:36:29.910
What we recommend is that you save both
the object's name and its unique ID.

00:36:30.430 --> 00:36:34.930
That way, if the user renames the object,
you'll still have the unique ID,

00:36:34.930 --> 00:36:38.550
which won't have changed,
and you'll still get a

00:36:38.630 --> 00:36:41.330
reference to the same object.

00:36:41.350 --> 00:36:46.740
On the other hand, if that fails,
meaning the object has been deleted,

00:36:46.740 --> 00:36:49.950
probably,
you'll still have the object's name to

00:36:49.950 --> 00:36:54.380
show the user what it is that he used
to be working with that isn't there now.

00:36:54.380 --> 00:36:56.470
Maybe he has to get his
DX7 out of his garage.

00:36:56.480 --> 00:37:01.700
In any case, you can show him the name,
and he can use that to decide

00:37:01.730 --> 00:37:06.250
what he's going to do about it,
choose a new device or say, "Oh,

00:37:06.330 --> 00:37:08.600
I actually don't need
that sound anyways."

00:37:11.460 --> 00:37:16.700
Okay, continuing through the MIDI API,
we have the MIDI client object,

00:37:16.760 --> 00:37:20.400
whose main purpose is,
aside from just bootstrapping

00:37:20.400 --> 00:37:24.390
yourself into the system,
its main purpose is to receive

00:37:24.390 --> 00:37:29.190
notifications of changes to
the state of the MIDI system.

00:37:29.430 --> 00:37:35.760
You can have more than one per process
if you have a modular application.

00:37:35.760 --> 00:37:40.020
And that's just to answer a
frequently asked question.

00:37:40.020 --> 00:37:43.980
And for Jaguar, we've changed the way
the notifications work.

00:37:44.000 --> 00:37:47.720
In 10.1,
we just had a single notification which

00:37:47.900 --> 00:37:51.420
said something in the world's changed,
and you had to go figure out

00:37:51.420 --> 00:37:52.590
what it was that changed.

00:37:52.650 --> 00:37:56.400
You pretty much had to
interrogate the whole state.

00:37:56.400 --> 00:37:58.730
And in Jaguar,
we have these new fine-grained

00:37:58.750 --> 00:38:01.080
notifications that say
an object was added,

00:38:01.220 --> 00:38:03.800
an object was removed,
or an object's property changed.

00:38:05.650 --> 00:38:08.980
Now, for backwards compatibility,
we still have to send the

00:38:08.980 --> 00:38:12.880
world change notification,
but if you're handling these new ones,

00:38:12.880 --> 00:38:14.870
you can ignore that.

00:38:19.100 --> 00:38:27.340
The next object in the
API is the MIDI port object.

00:38:27.440 --> 00:38:32.200
Just to clear up a common
source of confusion here,

00:38:32.200 --> 00:38:36.340
the MIDI port that you see in the
API isn't a five-pin MIDI connector.

00:38:36.340 --> 00:38:41.510
It's a communication channel to
the server like a Mach port or

00:38:41.860 --> 00:38:44.100
inter-process communication port.

00:38:44.120 --> 00:38:47.460
People seem to get confused about
this at first every now and then.

00:38:47.460 --> 00:38:53.740
You only need multiple ports in your
application if you are highly modular or

00:38:53.740 --> 00:38:58.100
if you need MIDI merging of your output.

00:38:58.170 --> 00:39:00.870
Unlike a five-pin MIDI connector,
one of these communication

00:39:01.010 --> 00:39:04.710
ports can communicate with all
of the sources and -- well,

00:39:04.730 --> 00:39:08.530
one output port can send to all
of the destinations in the system,

00:39:08.640 --> 00:39:12.980
and one input port can receive from
all of the sources in the system.

00:39:17.510 --> 00:39:23.470
So another new API that we have in
Jaguar is the MIDI through connection.

00:39:23.870 --> 00:39:27.900
This allows you to do MIDI throughing
in the server process where it

00:39:27.910 --> 00:39:32.560
can be a lot more efficient than
doing an inter-process communication

00:39:32.560 --> 00:39:36.210
message from the server to your
client and then immediately back to

00:39:36.210 --> 00:39:38.390
the server just to do MIDI through.

00:39:39.020 --> 00:39:39.900
and the rest of the team.

00:39:39.900 --> 00:39:42.560
Not only is it convenient,
but it's more efficient.

00:39:42.560 --> 00:39:45.840
And we also provide some fairly
extensive MIDI filtering and

00:39:45.880 --> 00:39:50.540
mapping functionality here.

00:39:50.540 --> 00:39:55.030
And the goal here was to let you
do things like change the channels,

00:39:55.030 --> 00:40:00.120
remove event types, and remap controls,
a few more things like that.

00:40:00.150 --> 00:40:03.800
I tried to make it as powerful as
I could while keeping it able to

00:40:03.880 --> 00:40:06.860
be described in one data structure.

00:40:11.000 --> 00:40:17.580
Earlier I mentioned our new properties
for describing a device's patch names

00:40:17.590 --> 00:40:20.560
as well as its note and control names.

00:40:20.560 --> 00:40:26.360
We're working on a draft of
a spec for this file format,

00:40:26.410 --> 00:40:30.660
which we're calling MIDI Name Documents.

00:40:30.660 --> 00:40:35.590
The whole goal here is to
integrate into the system what

00:40:35.690 --> 00:40:43.160
OMS and FreeMIDI had 10 years ago,
a set of name services,

00:40:43.240 --> 00:40:46.790
so users can see things in terms
of their names instead of saying,

00:40:46.910 --> 00:40:50.700
"Program change 42," or
"Control 7," for instance.

00:40:50.840 --> 00:40:54.730
And this is just a brief little
snippet of XML to give you a

00:40:54.890 --> 00:40:58.960
flavor for what it looks like
if you've never seen XML before.

00:41:01.710 --> 00:41:07.440
It's not trivial to parse XML,
but there are a lot of free open

00:41:07.440 --> 00:41:11.790
source XML parsers out there.

00:41:12.000 --> 00:41:18.740
Once we have finalized this format,
we will be releasing a parser

00:41:18.810 --> 00:41:21.790
as part of our example code.

00:41:26.400 --> 00:41:31.640
Okay, so there's the review of what's
new in core MIDI and what's old.

00:41:31.640 --> 00:41:35.760
I'd like to go to machine five now.

00:41:35.760 --> 00:41:37.750
Is it awake?

00:41:37.750 --> 00:41:39.680
Yeah.

00:41:39.680 --> 00:41:46.620
And just give you a quick
look at our audio MIDI

00:41:53.400 --> 00:41:56.130
Saw some screenshots from this earlier.

00:41:56.190 --> 00:42:01.470
This is--this loopback device
is a driver which I use for

00:42:01.470 --> 00:42:03.830
debugging and I don't need it.

00:42:05.080 --> 00:42:10.500
and here's a Roland UM-880,
Etch-It's-Etter-All.

00:42:11.040 --> 00:42:12.000
We saw that earlier.

00:42:12.000 --> 00:42:15.240
That's my MIDI interface.

00:42:15.270 --> 00:42:18.000
And I can define an external device.

00:42:18.000 --> 00:42:22.900
And I can double click
on it and give it a name.

00:42:35.200 --> 00:42:38.890
This is going to get a bit
more elaborate with more of the

00:42:39.070 --> 00:42:40.830
properties I talked about earlier.

00:42:42.500 --> 00:42:46.250
And then having created
this external device,

00:42:46.250 --> 00:42:50.300
I can show how it's connected
to my MIDI interface.

00:42:50.300 --> 00:42:53.180
It doesn't have to be symmetrical.

00:42:54.700 --> 00:42:59.260
I can say the MIDI out from
port one goes into my synth,

00:42:59.340 --> 00:43:03.010
and the output of my
synth goes into port four.

00:43:04.890 --> 00:43:11.290
So that's actually all there is to it.

00:43:11.290 --> 00:43:17.720
Can I go back to the slides, please?

00:43:23.150 --> 00:43:26.640
So in a moment,
Bill Stewart's going to talk about

00:43:26.640 --> 00:43:32.290
some larger scheduling and threading
issues related to audio and MIDI and how

00:43:32.290 --> 00:43:35.130
they fit into the rest of the system.

00:43:35.360 --> 00:43:40.860
But as a lead-in to that
part of this session,

00:43:41.030 --> 00:43:44.690
I'd just like to touch on a
few issues relating to the

00:43:44.690 --> 00:43:44.690
MIDI system and threading.

00:43:45.520 --> 00:43:48.380
The core MIDI framework,
which your applications use,

00:43:48.460 --> 00:43:51.180
is completely thread-safe,
meaning that you can call

00:43:51.180 --> 00:43:53.500
any function from any thread.

00:43:53.510 --> 00:43:56.790
The core MIDI server framework,
which only driver writers

00:43:56.790 --> 00:44:00.100
really need to know about,
is not thread-safe.

00:44:00.260 --> 00:44:03.510
You need to make all of your
calls other than your I/O calls,

00:44:03.600 --> 00:44:06.300
which happen on really
high-priority I/O threads,

00:44:06.480 --> 00:44:09.910
but all your other calls have
to happen on the main thread.

00:44:12.270 --> 00:44:16.910
On the client side,
when you create a MIDI input port,

00:44:16.910 --> 00:44:20.910
your read proc for that input port,
no matter how many

00:44:20.910 --> 00:44:24.650
input ports you create,
all of those read procs get serviced

00:44:24.660 --> 00:44:27.110
by a single high-priority thread.

00:44:27.400 --> 00:44:41.100
[Transcript missing]

00:44:43.180 --> 00:44:48.020
All of the notification callbacks
that your client gets get called

00:44:48.020 --> 00:44:51.720
from the run loop or thread on
which you first called core MIDI,

00:44:51.880 --> 00:44:59.480
which would typically be your
application's main thread.

00:44:59.480 --> 00:44:59.480
This is good to know because

00:45:00.110 --> 00:45:05.000
You can draw from that thread in
response to the notifications.

00:45:05.000 --> 00:45:08.190
You don't have to worry about
synchronization issues if you're

00:45:08.270 --> 00:45:12.210
accessing global data structures
where you're mirroring what

00:45:12.340 --> 00:45:14.690
Core MIDI is telling you is there.

00:45:17.230 --> 00:45:21.100
Okay, so that's the end of this section
of the talk about core MIDI,

00:45:21.180 --> 00:45:24.320
and I'd like to bring up
Bill Stewart to talk about audio,

00:45:24.320 --> 00:45:26.500
MIDI, and thread priorities.

00:45:31.900 --> 00:45:38.420
Okay, so I'm going to probably venture
where angels feed a thread and tread.

00:45:40.700 --> 00:46:12.200
[Transcript missing]

00:46:13.490 --> 00:46:17.420
So, first off, let's start sort of from
the top and work down.

00:46:17.420 --> 00:46:24.700
Basically, audio devices themselves,
and if we're talking about USB,

00:46:24.700 --> 00:46:29.050
MIDI devices,
etc., they're using interrupts to deal

00:46:29.060 --> 00:46:31.370
with the actual hardware interfacing.

00:46:31.980 --> 00:46:40.170
And so, for the hell part of this,
we actually expect that the audio drivers

00:46:40.400 --> 00:46:45.660
themselves supply very accurate timing
information so that the audio system can

00:46:45.660 --> 00:46:48.130
actually correctly schedule your I.O.

00:46:48.140 --> 00:46:51.210
And so,
it's probably the single most important

00:46:51.210 --> 00:46:56.070
thing that a driver needs to do,
aside from its actual handling of I.O.,

00:46:56.070 --> 00:46:58.770
is to supply this timing information.

00:46:58.790 --> 00:47:05.560
And the... The process of getting the
data to and from the drivers is actually

00:47:05.600 --> 00:47:10.440
done in the time-constrained threads,
including any transformation

00:47:10.570 --> 00:47:14.580
from a floating-point format
to the driver's native format.

00:47:14.580 --> 00:47:16.610
And we call that mix and clip.

00:47:16.620 --> 00:47:21.080
And so, that actually runs on the context
that your application is doing,

00:47:21.080 --> 00:47:25.960
that your application is seeing and
doing the work that it's doing for audio.

00:47:29.860 --> 00:47:32.360
And this sort of brings us
to time-constrained threads.

00:47:32.360 --> 00:47:35.420
Time-constrained threads
are fixed-priority threads.

00:47:35.420 --> 00:47:39.800
They'll be seen by the
system as a priority of 96.

00:47:39.870 --> 00:47:41.780
By fixed-priority,
I mean that the priority

00:47:41.780 --> 00:47:45.680
won't degrade over time,
and the system will continue to use

00:47:45.680 --> 00:47:48.800
this as a very high-priority thread.

00:47:48.800 --> 00:47:51.500
When you create a
time-constrained thread,

00:47:51.500 --> 00:47:56.100
you give it information to the system
about some of the time conditions that

00:47:56.100 --> 00:48:00.800
you expect to be met by the scheduler
when they're running that thread.

00:48:00.800 --> 00:48:06.560
And one of the most important of these
is actually the timeout period that the

00:48:06.560 --> 00:48:12.350
scheduler will use before it looks to
see if there's another thread to run.

00:48:12.780 --> 00:48:16.290
The core audio I/O proc thread
is a time constraint thread,

00:48:16.290 --> 00:48:17.820
as you probably know.

00:48:17.820 --> 00:48:23.080
The I/O threads of the MIDI server
are also time constraint threads.

00:48:23.080 --> 00:48:26.800
This is done in order to
meet the very tight and very

00:48:26.810 --> 00:48:31.980
real deadlines that I/O has,
particularly in the case of MIDI,

00:48:31.980 --> 00:48:36.940
you're talking about not introducing any
jitter into the transport of MIDI data.

00:48:36.940 --> 00:48:40.350
In the case of audio, of course,
you don't want to get

00:48:40.380 --> 00:48:42.260
glitches or missed data.

00:48:45.000 --> 00:48:47.470
Colonel tasks,
if we're sort of going down now,

00:48:47.470 --> 00:48:50.310
the Colonel does all of its
work at fixed priority as well,

00:48:50.310 --> 00:48:51.800
and that's a fixed priority of 80.

00:48:51.800 --> 00:48:55.780
And we're still not at your
application level at this point.

00:48:55.780 --> 00:48:59.440
So there is going to be work
being done in the Colonel,

00:48:59.440 --> 00:49:03.990
and one of the biggest jobs that we
have internally in talking to the

00:49:03.990 --> 00:49:09.220
Colonel team is to make sure that they're
not going to be introducing problems

00:49:09.350 --> 00:49:14.980
by doing more work in the Colonel and
not introducing problems in the kernel.

00:49:15.000 --> 00:49:20.560
And so we spend some time with them,
and they spend a lot of time just going

00:49:20.670 --> 00:49:26.020
through the system and making sure
this works as we would like it to.

00:49:27.900 --> 00:49:32.450
If we get to the application level,
you have both fixed priority

00:49:32.450 --> 00:49:36.160
threads available to you
and the timeshare threads.

00:49:37.580 --> 00:49:41.510
Fixed priority threads in Jaguar
have got some very important

00:49:41.510 --> 00:49:43.590
changes in the way that they behave.

00:49:44.260 --> 00:49:47.580
Basically,
they're given some special privileges.

00:49:47.580 --> 00:49:51.600
These special privileges are to
preempt some of the activities

00:49:51.730 --> 00:49:53.320
that are going on in the kernel.

00:49:53.320 --> 00:49:56.580
Otherwise, you tend to get,
and I think we've seen

00:49:56.580 --> 00:49:59.300
this in some cases,
you tend to get a problem

00:49:59.440 --> 00:50:01.130
of priority inversion.

00:50:01.180 --> 00:50:04.680
You may get some activity
that you've made a call and

00:50:04.680 --> 00:50:08.140
you've made that call from,
say, a 33 thread.

00:50:08.140 --> 00:50:11.620
That ends up having to transition
to the kernel to do some work.

00:50:11.680 --> 00:50:15.900
Then suddenly a 52 thread that needs
to do some work cannot do that work

00:50:15.910 --> 00:50:20.470
because an 80 thread is running in
response to a low priority request.

00:50:20.480 --> 00:50:26.330
The fixed priority threads are going to
have this ability to preempt that work

00:50:26.330 --> 00:50:29.220
and to get to actually do their work.

00:50:29.940 --> 00:50:32.580
Then that work will get
done after that's done.

00:50:32.580 --> 00:50:37.680
In a very meaningful way, in Jaguar,
the fixed priority threads will

00:50:37.780 --> 00:50:42.740
tend to behave very much like the
real-time time constraints thread.

00:50:42.740 --> 00:50:45.940
They'll have some
special abilities to run.

00:50:45.940 --> 00:50:50.060
The understanding is that they
have tasks that really have some

00:50:50.060 --> 00:50:52.610
time-sensitive elements to them.

00:50:52.620 --> 00:50:55.280
The highest priority
that's available to you,

00:50:55.400 --> 00:50:58.620
both for fixed and for timeshare threads,
is 63.

00:50:58.700 --> 00:51:01.820
In the user space,
except for the time-constrained thread,

00:51:01.820 --> 00:51:02.580
of course.

00:51:02.580 --> 00:51:05.580
Then you can go down from there.

00:51:07.580 --> 00:51:13.170
The Windows Server has been an
issue of much debate in terms of

00:51:13.170 --> 00:51:17.090
where it does its work and what
priorities it uses to do its work.

00:51:18.880 --> 00:51:24.440
In Jaguar, we've been talking to them and
giving them feedback from some

00:51:24.440 --> 00:51:28.810
developers about the fact that they
are getting some of the work that the

00:51:28.810 --> 00:51:35.560
Windows Server does can actually cause
undesirable effects in a 10.1 system.

00:51:35.560 --> 00:51:37.800
So there's been some changes
to the Windows Server,

00:51:37.800 --> 00:51:41.330
a lot of changes I'm sure that have
been covered in other sessions.

00:51:41.390 --> 00:51:45.770
The one that we most care about is
that in a Jaguar system there's going

00:51:45.770 --> 00:51:52.590
to be very little work done at the 63
thread that the Windows Server runs.

00:51:52.710 --> 00:51:57.170
That 63 thread will basically just
be an event type thread and then any

00:51:57.280 --> 00:52:02.220
work that needs to be done from that
will be dispatched to a lower priority

00:52:02.220 --> 00:52:05.140
thread and that thread is running at 51.

00:52:05.140 --> 00:52:09.450
You can see multiple 51 threads if
you're running a dual processor machine.

00:52:09.450 --> 00:52:14.160
You see 151 thread per CPU.

00:52:14.750 --> 00:52:16.680
The 51 thread in the 10.1
system is going to be a very,

00:52:16.680 --> 00:52:16.680
very complex system.

00:52:16.680 --> 00:52:17.180
It's going to be a very complex system.

00:52:17.180 --> 00:52:17.180
It's going to be a very complex system.

00:52:17.180 --> 00:52:20.480
It's going to be is being used to do
compositing by the Windows server,

00:52:20.480 --> 00:52:26.680
and it will now in Jaguar be used to
also field requests from applications.

00:52:26.680 --> 00:52:29.810
A good example of this
is calling findWindow.

00:52:29.820 --> 00:52:36.200
FindWindow is a Carbon call,
and on a Mac OS system,

00:52:36.200 --> 00:52:40.240
that was just to look up
something in a global record.

00:52:40.240 --> 00:52:45.820
In a Carbon on a Mac OS X system,
that ends up being a mark

00:52:45.820 --> 00:52:49.560
message to the Windows server,
and it was doing that work

00:52:49.560 --> 00:52:54.020
at the 63 priority thread,
so you'd get this unexpected

00:52:54.470 --> 00:52:57.360
behavior where it would just
take away time from you.

00:52:57.400 --> 00:53:03.050
And then some of the work
the Windows server does...

00:53:18.700 --> 00:53:25.260
Some of the work that the
Windows Server is asked to do can

00:53:25.260 --> 00:53:30.160
involve transitions to the kernel,
and so the need for fixed priority

00:53:30.160 --> 00:53:32.580
threads to be able to pre-empt that.

00:53:33.410 --> 00:53:37.500
Fixed priority threads
are used in the Carbon.

00:53:37.500 --> 00:53:45.940
There's three threads that would relate
to interrupts on a Mac OS system.

00:53:45.940 --> 00:53:48.190
There's a time manager,
the async file and the

00:53:48.320 --> 00:53:51.310
deferred task threads,
and those are the priorities.

00:53:51.310 --> 00:53:56.090
They're published as fixed
priority threads in a Fuma system,

00:53:56.090 --> 00:53:59.460
and that'll be the same
in a Jaguar system.

00:53:59.460 --> 00:54:05.490
MP threads, which are another Carbon API,
are currently timeshare threads,

00:54:05.490 --> 00:54:09.900
and there will be some additional APIs in
Jaguar to allow you to set the policy of

00:54:09.900 --> 00:54:12.320
those threads to being fixed priority.

00:54:14.870 --> 00:54:19.840
So just to recap how this all lines
up if we go from top to bottom.

00:54:19.860 --> 00:54:22.680
We start off with the
interrupts from the hardware,

00:54:22.680 --> 00:54:25.670
then we've got a scheduler
running above that.

00:54:29.260 --> 00:54:32.140
And then we have the time constraint
threads that are used by both

00:54:32.210 --> 00:54:34.530
the audio and the MIDI system.

00:54:34.530 --> 00:54:38.900
Kernel tasks, the MIDI client thread,
we're considering taking that out

00:54:38.900 --> 00:54:43.180
of the real-time band so that it
doesn't compete with the I/O and

00:54:43.180 --> 00:54:46.670
taking that to a fixed priority of 63.

00:54:46.790 --> 00:54:50.220
And then we look at the event
thread of the Windows server at 63,

00:54:50.220 --> 00:54:55.240
fixed priority threads for Carbon,
and then the Carbon MP threads

00:54:55.280 --> 00:54:58.100
will be user-definable,
including their policy.

00:54:58.100 --> 00:55:00.320
The main problem,
I guess I should have said,

00:55:00.350 --> 00:55:03.340
in a timeshare policy,
and I'll show you this in a minute,

00:55:03.340 --> 00:55:07.310
the priority will degrade,
and we'll see why fixed priority becomes

00:55:07.310 --> 00:55:09.760
a very important thing for you to use.

00:55:09.760 --> 00:55:12.430
And then you've got down at
the bottom your main thread,

00:55:12.430 --> 00:55:15.210
which will typically be
somewhere around the 30s.

00:55:15.970 --> 00:55:18.820
So if we can go to demo machine three.

00:55:21.780 --> 00:55:26.710
Okay,
so this is an app that we wrote because

00:55:26.710 --> 00:55:31.960
we were really needing to try and
understand how threading was going to

00:55:31.960 --> 00:55:37.100
affect audio applications and how the
system guys really needed to understand

00:55:37.100 --> 00:55:41.580
the kinds of activities that audio and
MIDI apps are doing and the kinds of

00:55:41.580 --> 00:55:48.340
behaviors that we need from the system
in order to get the guarantees that those

00:55:48.370 --> 00:55:49.600
apps need in order to do their work.

00:55:49.850 --> 00:55:51.990
I'm going to launch
this from the terminal.

00:55:52.020 --> 00:55:56.190
This app is called Million Monkeys
and it's a reference to Shakespeare,

00:55:56.190 --> 00:55:56.540
I guess.

00:55:57.100 --> 00:56:05.480
The idea of this app is not to
show you how to write a threaded

00:56:05.480 --> 00:56:08.220
application for doing audio.

00:56:08.220 --> 00:56:11.940
In fact,
our main purpose of this was to create

00:56:12.010 --> 00:56:17.370
a very fragile situation so that we
could look at the problems of threading,

00:56:17.780 --> 00:56:21.240
the problems of getting
guarantees in order to run,

00:56:21.240 --> 00:56:25.010
and to try and understand what is
causing those problems and get diagnosis

00:56:25.010 --> 00:56:26.760
from those problems and fix them.

00:56:26.760 --> 00:56:33.170
This is actually on your Jaguar CD,
so you can run this at home and in the

00:56:33.170 --> 00:56:35.660
office if you're not working at home.

00:56:35.740 --> 00:56:41.730
You can use this to actually help
us to file bugs and help us to

00:56:41.730 --> 00:56:47.520
understand where there may be latencies
being introduced into the system.

00:56:47.780 --> 00:56:54.100
This uses a tool that is covered
in some other talks called latency.

00:56:54.150 --> 00:56:59.900
Latency is an ability for you to see
what the latency of the scheduler is.

00:56:59.900 --> 00:57:02.990
In order to run latency,
you need to execute the

00:57:02.990 --> 00:57:04.550
application as root.

00:57:04.710 --> 00:57:08.240
That's why I ran it
from the command line.

00:57:08.380 --> 00:57:12.740
This is probably the most exciting
audio content you'll hear all week.

00:57:12.780 --> 00:57:15.010
It's a sine wave and
I thought I'd turn that off.

00:57:15.180 --> 00:57:21.090
What we're seeing here is that,
this feeder thread is being run at

00:57:21.170 --> 00:57:23.410
a priority of 63 and it's not fixed.

00:57:23.420 --> 00:57:28.420
All these purple lines mean that
that thread is missing its deadline.

00:57:28.420 --> 00:57:33.420
I'm telling the thread that I want
it to consume 80% of its CPU.

00:57:33.420 --> 00:57:38.210
The sine wave,
the crackling that you can hear there is

00:57:38.210 --> 00:57:42.420
the fact that even though I think I've
set this to the maximum priority I can,

00:57:42.460 --> 00:57:47.630
I'm not being able to do my work at
all and I'm overloading like crazy.

00:57:47.700 --> 00:57:50.360
If I'm able to make this
a fixed priority thread,

00:57:50.360 --> 00:57:54.700
then I'm able to actually maintain my
priority and I'm not going to degrade.

00:57:54.700 --> 00:57:57.450
When it's not fixed priority,
as you take time,

00:57:57.450 --> 00:58:01.700
and I'm taking a lot of time here,
the system degrades that priority.

00:58:01.700 --> 00:58:05.270
You can see just by making
this a fixed priority thread,

00:58:05.270 --> 00:58:09.050
I'm able to actually get the
work done and utilize 80% of

00:58:09.050 --> 00:58:11.110
the CPU in my second thread.

00:58:11.390 --> 00:58:18.350
and what I'm going to do here now is to
run this again using an execution trace

00:58:18.470 --> 00:58:20.440
and I'll show you what that looks like.

00:58:20.500 --> 00:58:23.500
So I'm going to start like
this here and then I'm going

00:58:23.500 --> 00:58:26.450
to put this up to a 63 thread.

00:58:26.450 --> 00:58:31.850
Then I'm stopping it and what
I can do is click here and this is

00:58:31.990 --> 00:58:35.130
the trace that latency gives me.

00:58:35.400 --> 00:58:39.800
And I can step through
backwards and I can see,

00:58:39.800 --> 00:58:42.120
okay, so I overloaded at this point.

00:58:42.120 --> 00:58:46.540
Now,
was this a thread scheduling problem?

00:58:46.540 --> 00:58:47.940
It doesn't look like it.

00:58:47.940 --> 00:58:53.380
And so I probably know at this point
that it was because at that point

00:58:53.380 --> 00:58:56.860
I was running it as a timeshare thread.

00:58:56.890 --> 00:59:03.890
And I can go through and each,
when you're doing the trace itself,

00:59:03.890 --> 00:59:12.260
each time the time the thread is running,
you're running it as a timeshare thread.

00:59:12.260 --> 00:59:15.550
And we basically look at from the
time the I/O thread ran to the time

00:59:15.550 --> 00:59:19.780
that our feeder thread got to run
and we look at what was happening in

00:59:19.840 --> 00:59:22.070
the system between those two times.

00:59:22.170 --> 00:59:25.270
And we're trying to understand
what is holding off my second

00:59:25.270 --> 00:59:27.640
thread from running if that's okay.

00:59:27.640 --> 00:59:33.330
So here's a longer trace and you
can see that this took actually 365

00:59:33.330 --> 00:59:36.970
microseconds for it to actually run.

00:59:37.360 --> 00:59:41.240
And I can go through here and I can
see what was it that from this time,

00:59:41.240 --> 00:59:43.710
this is the point here when
I was trying to get to run,

00:59:43.710 --> 00:59:46.560
to this point here when
I actually got to run,

00:59:46.640 --> 00:59:49.120
what was going on in the system?

00:59:49.120 --> 00:59:52.200
Well,
the window manager was doing something.

00:59:52.210 --> 00:59:54.670
At this point,
we would probably turn around

00:59:54.780 --> 00:59:57.580
to the kernel guys and say,
"There is a kernel task going

00:59:57.580 --> 01:00:00.650
on here." We'd turn around to
the scheduler guys and we'd say,

01:00:00.650 --> 01:00:04.660
"There really is something going on
here that we need to understand,"

01:00:04.660 --> 01:00:08.740
and we'd give them the tool,
and away we go from there.

01:00:08.820 --> 01:00:12.750
We'd really encourage you to use this
tool to help us to track down these

01:00:12.910 --> 01:00:17.350
bugs because this basically will help
all of the applications work very well.

01:00:17.360 --> 01:00:20.190
If we can go back to the slides.

01:00:27.500 --> 01:00:31.880
So just to conclude before we do Q&A,
there's a whole bunch of new APIs,

01:00:31.880 --> 01:00:33.220
so look for them in Jaguar.

01:00:33.220 --> 01:00:37.720
We've had some apps that are shipping
already using Cordio and MIDI.

01:00:37.720 --> 01:00:42.800
We're seeing some device drivers coming
out for both audio and MIDI devices,

01:00:42.800 --> 01:00:47.720
and we're very enthusiastic about that
and very pleased to see that progress,

01:00:47.720 --> 01:00:50.490
and we hope,
particularly with the changes in Jaguar,

01:00:50.490 --> 01:00:52.280
that we'll see a lot more of this.

01:00:52.960 --> 01:00:55.020
And once again,
I'd like to reiterate a point

01:00:55.020 --> 01:00:58.420
that you've probably heard
from a lot of Doug's comments,

01:00:58.420 --> 01:01:01.000
but in particular earlier, and Jeff's,
is that we really do

01:01:01.000 --> 01:01:02.260
listen to your feedback.

01:01:02.260 --> 01:01:04.960
We really would like to encourage
you to continue to tell us

01:01:04.960 --> 01:01:08.110
things that you're missing,
things that you like about the system,

01:01:08.210 --> 01:01:11.740
things you don't like about the system,
and we do try to respond and

01:01:11.770 --> 01:01:15.960
make this as good a system for
you to use as we possibly can.

01:01:17.450 --> 01:01:19.560
Here's some roadmap.

01:01:19.560 --> 01:01:24.320
We had a session yesterday where
we were doing 3D mixing and stuff.

01:01:24.320 --> 01:01:28.430
In the session after this one,
we'll be talking about writing audio

01:01:28.480 --> 01:01:30.620
units and some of the audio codecs.

01:01:30.660 --> 01:01:35.100
There's a short discussion of AAC,
which is implemented using the new

01:01:35.100 --> 01:01:36.930
audio codec component on Friday.

01:01:37.050 --> 01:01:39.280
We have,
in this room on Friday afternoon,

01:01:39.350 --> 01:01:40.480
a feedback forum.

01:01:40.480 --> 01:01:44.820
If you've got any more complex
questions or comments or discussions,

01:01:44.900 --> 01:01:48.920
then it might be a good forum
to come to and bring that up.

01:01:50.480 --> 01:01:58.400
and Craig Craig will be able to
fill general comments and so forth.

01:01:58.400 --> 01:02:01.580
There's his email contacts.

01:02:01.580 --> 01:02:05.900
We have an API list which is public,
list.apple.com.

01:02:05.900 --> 01:02:07.560
We have SDKs.

01:02:07.560 --> 01:02:11.610
All the code that we're doing
this week we will endeavor to

01:02:11.610 --> 01:02:18.610
get out to the developers for
you guys to download next week.

01:02:18.690 --> 01:02:20.500
Just keep an eye on that website.

01:02:20.670 --> 01:02:23.020
We'll put a link up for
that then and do Q&A.
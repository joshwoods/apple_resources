WEBVTT

00:00:16.260 --> 00:00:18.200
Okay, hi everybody.

00:00:18.200 --> 00:00:20.740
Welcome to 1.1.5 FireWire In-Depth.

00:00:20.740 --> 00:00:24.870
This is a gigantic room,
so feel free to come forwards if

00:00:24.880 --> 00:00:26.320
you want to be a little closer.

00:00:26.320 --> 00:00:32.450
We have a lot of material to cover today,
so let's get started.

00:00:34.430 --> 00:00:39.290
This session is all about writing
software for FireWire devices,

00:00:39.350 --> 00:00:41.300
obviously in Mac OS X.

00:00:41.300 --> 00:00:45.480
We're going to have a very detailed
look at the software architecture,

00:00:45.480 --> 00:00:48.290
how all the parts fit together
and what they do for you.

00:00:48.300 --> 00:00:53.010
We will specifically identify things that
we've added since last year that you can

00:00:53.010 --> 00:00:55.300
now use in your software development.

00:00:55.300 --> 00:00:58.300
And then we'll look at things
that we're still working on,

00:00:58.300 --> 00:01:01.930
things that we are going to be
adding in the future to expand

00:01:02.010 --> 00:01:06.300
even further the capabilities
of what you can do on FireWire.

00:01:06.300 --> 00:01:11.300
Also, this year we've added a section
on how-to organized by device.

00:01:11.300 --> 00:01:14.410
So if you've got some device and
you want to know how to get started,

00:01:14.420 --> 00:01:17.290
we'll list all the different
options that you have.

00:01:20.830 --> 00:01:24.680
The slides are divided
into five categories.

00:01:24.760 --> 00:01:28.560
The first is probably the longest,
a detailed study of how all the

00:01:28.560 --> 00:01:31.540
FireWire parts in Mac OS X work.

00:01:31.640 --> 00:01:37.530
Then, specifically list the changes to
FireWire since WWDC last year.

00:01:38.020 --> 00:01:40.660
Then we cover the
planned future services,

00:01:40.700 --> 00:01:43.100
do that how-to section
that I talked about,

00:01:43.100 --> 00:01:47.290
and we'll wrap up with a brief review
of all of the developer services that

00:01:47.290 --> 00:01:52.080
we have available to help you develop
products using FireWire on Mac OS X.

00:01:52.080 --> 00:01:55.880
Plus, we'll leave plenty of time for Q&A.

00:01:59.250 --> 00:02:04.020
Okay, in Mac OS X,
FireWire is a kernel service.

00:02:04.380 --> 00:02:07.200
There's a variety of reasons why
FireWire belongs in the kernel,

00:02:07.200 --> 00:02:12.150
but one that by itself is good enough
is that to boot from a FireWire disk,

00:02:12.190 --> 00:02:16.160
FireWire would have to be in the kernel
because of the chicken and egg problem.

00:02:16.160 --> 00:02:18.780
So it's in there.

00:02:19.590 --> 00:02:25.380
FireWire is in the kernel in the
form of I/O kits architecture,

00:02:25.380 --> 00:02:29.200
so it leverages all of the
I/O Kit services that other

00:02:29.790 --> 00:02:34.500
family interfaces provide,
like USB, SCSI, and so on.

00:02:34.500 --> 00:02:38.490
So lots of stuff it has in
common with other services.

00:02:38.530 --> 00:02:40.500
It's implemented as a
set of kernel extensions.

00:02:40.500 --> 00:02:44.240
We will go over what those
are and what they do.

00:02:44.530 --> 00:02:49.500
Now, having just explained that it's in
the kernel because it has to be there,

00:02:49.600 --> 00:02:52.880
most of this presentation will
be explaining how you can write

00:02:52.900 --> 00:02:56.500
your software out in user space
instead of writing in the kernel.

00:02:56.500 --> 00:02:59.650
There's lots of advantages
to working in user space,

00:02:59.650 --> 00:03:03.140
and for most of you,
we believe we've provided the services

00:03:03.140 --> 00:03:05.500
that will make it possible to do that.

00:03:05.530 --> 00:03:08.520
So we'll talk about that at length.

00:03:11.340 --> 00:03:16.200
I'm going to show a diagram
of the core FireWire services.

00:03:16.240 --> 00:03:19.200
We're going to start at
the bottom with hardware.

00:03:19.270 --> 00:03:21.600
From a FireWire point of view,
that's where everything begins.

00:03:21.600 --> 00:03:25.420
If there is no FireWire hardware,
then our software isn't

00:03:25.420 --> 00:03:27.360
running and nothing happens.

00:03:28.110 --> 00:03:31.320
So at the bottom of the diagram,
this item marked hardware,

00:03:31.590 --> 00:03:36.180
that represents the FireWire
interface in a Macintosh system.

00:03:36.180 --> 00:03:39.540
There could be more than one,
but we'll just focus on one at a time.

00:03:39.540 --> 00:03:45.380
Specifically, in 1394 terms,
the interface consists

00:03:45.380 --> 00:03:47.260
of a link and a PHY.

00:03:47.260 --> 00:03:50.300
These won't be covered in
detail because they're hardware,

00:03:50.300 --> 00:03:54.260
but the link is the part that
knows how to form packets.

00:03:54.260 --> 00:03:55.620
It does checksums.

00:03:55.620 --> 00:03:56.580
It does DMA.

00:03:57.640 --> 00:04:01.890
The PHY is the counterpart that knows how
to actually wiggle the wires around in

00:04:01.890 --> 00:04:05.200
order to send data serially on the cable.

00:04:05.200 --> 00:04:09.060
So the two together form the
FireWire interface that backs up the

00:04:09.060 --> 00:04:11.400
ports that you see on our products.

00:04:11.400 --> 00:04:16.870
So when I/O Kit discovers that
the Mac has a FireWire port

00:04:16.870 --> 00:04:22.420
by looking for PCI devices,
the discovery of that hardware triggers

00:04:22.420 --> 00:04:24.780
all of the processes that follow.

00:04:24.780 --> 00:04:28.580
By the way, that interface could be...
It could be a PCI card.

00:04:28.600 --> 00:04:31.000
It could be a Cardbus card.

00:04:31.000 --> 00:04:36.210
It could also be the built-in FireWire
that we now have in our CoreLogic chipset

00:04:36.350 --> 00:04:38.420
on all of our currently shipping systems.

00:04:38.420 --> 00:04:40.820
For all of these,
they would all load the same way,

00:04:40.840 --> 00:04:42.960
and they would all use the same software.

00:04:45.630 --> 00:04:49.480
So when I/O Kit finds that hardware,
it starts a process of filling

00:04:49.480 --> 00:04:53.700
in the core FireWire services,
which will be shown in this box.

00:04:53.750 --> 00:04:56.940
And then we're going to build
a bunch of other services up on

00:04:56.940 --> 00:04:59.000
top of that as the diagram grows.

00:04:59.940 --> 00:05:03.050
Strictly speaking,
the part that loads first is the device

00:05:03.050 --> 00:05:06.500
driver for the hardware interface itself.

00:05:06.500 --> 00:05:10.350
In most cases, this is Apple FW-OHCI.

00:05:10.420 --> 00:05:12.500
That's the open host
controller interface.

00:05:12.500 --> 00:05:19.240
It corresponds to a PCI or PCI-like,
such as Cardbus, interface link chip

00:05:19.240 --> 00:05:21.700
found in the hardware.

00:05:21.920 --> 00:05:27.080
This is the driver that takes interrupts,
programs the DMA, handles physical to

00:05:27.110 --> 00:05:28.880
virtual memory issues.

00:05:28.880 --> 00:05:32.450
It does all of the lowest level
software work for controlling the

00:05:32.470 --> 00:05:35.910
FireWire hardware so that we can
send and receive packets and do

00:05:35.950 --> 00:05:37.900
interesting things on the bus.

00:05:40.930 --> 00:05:45.600
The layer above that, that gets loaded in
response to OHCI loading,

00:05:45.680 --> 00:05:48.220
is IOFireWire family.

00:05:48.750 --> 00:05:51.980
Technically, this should really be
labeled IOFireWireController,

00:05:51.980 --> 00:05:56.000
but I've labeled it as Family because
the Family is the kernel service

00:05:56.000 --> 00:06:01.200
that binds all of this together and
collectively provides these services.

00:06:01.550 --> 00:06:06.370
The family is the common layer for
all of the things using FireWire,

00:06:06.390 --> 00:06:08.340
to multiplex through.

00:06:08.510 --> 00:06:11.020
For example,
the FireWire bus may have many

00:06:11.020 --> 00:06:13.400
different devices connected to it.

00:06:13.400 --> 00:06:17.080
Many different drivers and
applications may be loaded that

00:06:17.300 --> 00:06:19.230
want to talk to those devices.

00:06:19.240 --> 00:06:23.200
But there's only one hardware interface,
so they're all going to have to share.

00:06:23.200 --> 00:06:26.100
They all have to peacefully
coexist and do their thing

00:06:26.100 --> 00:06:28.060
without stepping on each other.

00:06:28.140 --> 00:06:32.560
So the family's job is to provide that
multiplexing point where everybody

00:06:32.560 --> 00:06:37.460
can use the bus in their own way,
but do it in a cooperative way.

00:06:37.610 --> 00:06:41.340
The family provides additional
services that are bus general,

00:06:41.340 --> 00:06:45.180
such as scanning for new devices,
in order to start the

00:06:45.180 --> 00:06:47.350
process of loading drivers.

00:06:49.390 --> 00:06:52.600
As the family finds devices
on the FireWire bus,

00:06:52.700 --> 00:06:56.170
it creates IO FireWire device objects.

00:06:56.240 --> 00:07:00.350
There's one of these created
for each node on the FireWire

00:07:00.350 --> 00:07:05.100
bus that has a configuration
ROM that we're able to read.

00:07:05.160 --> 00:07:07.510
Most nodes fall into this category.

00:07:07.510 --> 00:07:10.020
The exception would be, there's two.

00:07:10.090 --> 00:07:12.420
You could have a FireWire hub.

00:07:12.420 --> 00:07:15.140
In FireWire,
the hubs are like Ethernet hubs.

00:07:15.140 --> 00:07:19.810
They're completely
self-configuring and self-active.

00:07:19.890 --> 00:07:21.120
They don't require drivers.

00:07:21.190 --> 00:07:23.470
They don't require
software to turn them on.

00:07:23.570 --> 00:07:27.760
So a FireWire hub on the bus wouldn't
create IO FireWire device because we

00:07:27.760 --> 00:07:30.520
wouldn't find any config ROM in it.

00:07:30.600 --> 00:07:36.490
The second exception would be some
FireWire device that is turned off,

00:07:36.490 --> 00:07:38.800
and so it's acting like a hub.

00:07:38.800 --> 00:07:43.340
For example, our G4 tower,
if you turn it off,

00:07:43.380 --> 00:07:46.240
its FireWire chips are all turned off,
except for the PHY,

00:07:46.240 --> 00:07:48.640
which continues to run from AC power.

00:07:48.800 --> 00:07:53.240
That's so that if you've plugged in
two devices like a camera and a TV,

00:07:53.300 --> 00:07:57.160
they can still talk to each other through
the hub that's acting in that PHY,

00:07:57.160 --> 00:07:58.940
even though the computer's turned off.

00:07:59.010 --> 00:08:02.370
That would be a case of a device
where it is a node on the bus,

00:08:02.370 --> 00:08:05.280
but nobody can read a
configuration ROM from it,

00:08:05.340 --> 00:08:09.810
so we would not create an
IO FireWire device object for that.

00:08:11.590 --> 00:08:15.620
Then, for the devices where we do
find a configuration ROM,

00:08:15.620 --> 00:08:17.740
we create IOFireWireUnit.

00:08:17.740 --> 00:08:21.340
This is the object that represents
a unit directory discovered

00:08:21.440 --> 00:08:22.560
in the configuration ROM.

00:08:22.560 --> 00:08:24.860
Most devices will have at least one.

00:08:24.860 --> 00:08:26.980
Occasionally,
a device might have more than one.

00:08:30.140 --> 00:08:32.500
And that corresponds to a unit directory.

00:08:32.570 --> 00:08:35.500
The unit directory in the
configuration ROM expresses the

00:08:35.570 --> 00:08:40.160
first level of information about
what actual function some device has.

00:08:40.160 --> 00:08:44.260
So this is the layer at which things
start to differentiate into disks or

00:08:44.280 --> 00:08:47.000
camcorders or printers or something else.

00:08:47.000 --> 00:08:51.360
So those four together form the
core FireWire services because

00:08:51.360 --> 00:08:56.230
within this box we haven't done
anything that's device-specific.

00:08:56.460 --> 00:08:59.910
Nothing was specific to
DV or to hard drives.

00:08:59.910 --> 00:09:05.750
It's all just generic FireWire
services supporting multiplexing

00:09:05.750 --> 00:09:09.860
of various devices and drivers and
supporting the discovery of the

00:09:09.860 --> 00:09:12.050
first level of device functions.

00:09:12.060 --> 00:09:15.070
We'll come back to this and
build on it a great deal,

00:09:15.070 --> 00:09:18.240
but first let's review
what those services were.

00:09:20.170 --> 00:09:22.220
We'll start with IO FireWire
family because that's,

00:09:22.220 --> 00:09:24.540
as I said, that's the part that really
brings everything together.

00:09:26.340 --> 00:09:28.810
The family makes everybody get along.

00:09:28.930 --> 00:09:31.410
All the drivers,
all the devices can share a

00:09:31.440 --> 00:09:34.710
single interface onto the bus
and all do their thing without

00:09:34.710 --> 00:09:36.620
even knowing about each other.

00:09:36.620 --> 00:09:39.600
For example, with iMovie,
you could be capturing DV video

00:09:39.600 --> 00:09:42.920
from a FireWire camcorder,
recording it onto a FireWire

00:09:42.930 --> 00:09:44.710
hard drive on the same bus.

00:09:44.950 --> 00:09:48.420
Both will be sending packets
furiously to accomplish their thing,

00:09:48.420 --> 00:09:50.350
but they don't have to
know about each other.

00:09:50.360 --> 00:09:53.510
The family keeps them separate and
makes sure they each do their own thing.

00:09:53.610 --> 00:09:57.450
For example, iMovie is not bothered
with hard drive packets,

00:09:57.450 --> 00:10:01.160
and the hard drive isn't bothered
with commands for the camcorder.

00:10:01.280 --> 00:10:03.140
They just don't see each other.

00:10:03.140 --> 00:10:06.260
In addition to keeping everyone
playing well on the bus,

00:10:06.260 --> 00:10:08.280
the family does the bus scanning.

00:10:08.280 --> 00:10:11.920
So if a new device is plugged in,
the family will come along and

00:10:11.920 --> 00:10:17.080
look at it and see what it is,
create the device and the unit objects,

00:10:17.210 --> 00:10:19.940
and then let the matching start.

00:10:19.940 --> 00:10:21.240
Driver matching is listed there.

00:10:21.240 --> 00:10:22.980
It's not really done by the family.

00:10:22.990 --> 00:10:24.450
The family enables it.

00:10:24.460 --> 00:10:28.040
The family finds the information
that will be needed for matching,

00:10:28.090 --> 00:10:31.710
but then it hands it over to I/O Kit,
so the matching happens just

00:10:31.710 --> 00:10:34.700
like any other I/O device
in the kernel in Mac OS X.

00:10:36.460 --> 00:10:39.200
The family handles
GUID and topology tracking.

00:10:39.320 --> 00:10:42.960
We'll talk more about GUIDs later,
but this means as devices are

00:10:42.960 --> 00:10:46.360
added to or removed from the bus,
the family keeps track

00:10:46.430 --> 00:10:48.340
of where they went,
so that if the user is

00:10:48.340 --> 00:10:51.250
rearranging the bus,
we don't lose track of some disk,

00:10:51.360 --> 00:10:54.180
for example,
and suddenly unmount its file system.

00:10:54.180 --> 00:10:57.270
We can keep track of the devices
even though the bus has hot

00:10:57.360 --> 00:10:59.100
plugging activity going on.

00:11:00.100 --> 00:11:02.240
And the last item,
perhaps the most important,

00:11:02.240 --> 00:11:03.740
packet transmit and receive.

00:11:03.740 --> 00:11:08.120
The family is the funnel for
all packet activities between

00:11:08.120 --> 00:11:10.060
drivers and their devices.

00:11:13.110 --> 00:11:15.630
I mentioned driver matching and loading.

00:11:15.870 --> 00:11:18.850
FireWire doesn't do its own
driver loading or matching.

00:11:18.950 --> 00:11:22.650
FireWire just gathers information
about the devices by reading their

00:11:22.650 --> 00:11:27.120
configuration ROMs and publishes
this information in the I/O registry.

00:11:27.180 --> 00:11:32.040
Then FireWire asks I/O Kit to activate
its general matching service to find

00:11:32.160 --> 00:11:36.790
drivers to load for these devices
that were discovered on the bus.

00:11:36.790 --> 00:11:41.930
And this may be an iterative process if,
in doing so, more information is

00:11:41.930 --> 00:11:44.510
learned about the devices.

00:11:44.530 --> 00:11:47.950
So this means that your matching
mechanism is very flexible.

00:11:47.960 --> 00:11:51.060
I/O Kit allows, for example,
active probing.

00:11:51.070 --> 00:11:53.630
A driver can run,
take a look at the device and

00:11:53.630 --> 00:11:57.030
make a decision on the spot as
to whether it's really the best

00:11:57.030 --> 00:11:58.760
choice for that device or not.

00:11:59.050 --> 00:12:03.660
So this is really more powerful and more
flexible than what we had in Mac OS 9.

00:12:03.670 --> 00:12:08.220
It's also more uniform because the
actual mechanism is shared with USB,

00:12:08.220 --> 00:12:12.290
ATA, SCSI, PCI,
all kinds of other interfaces.

00:12:12.570 --> 00:12:16.170
Some of the information that we
put in the IO Registry is the GUID,

00:12:16.170 --> 00:12:17.790
which I mentioned before.

00:12:17.790 --> 00:12:19.930
That stands for Globally Unique ID.

00:12:19.930 --> 00:12:23.490
It's a 64-bit serial number
that we read from the device.

00:12:23.490 --> 00:12:26.250
This lets us tell one
device from the next.

00:12:26.320 --> 00:12:28.700
For example,
if the customer has connected

00:12:28.930 --> 00:12:32.350
four FireWire hard drives,
perhaps they want to make a RAID,

00:12:32.350 --> 00:12:36.580
they might be identical in every way,
except they have different GUIDs.

00:12:36.600 --> 00:12:39.960
And this way we can be sure we're
sending each packet to the right drive,

00:12:40.010 --> 00:12:43.020
because nothing would work if
we lost track of who was who.

00:12:44.680 --> 00:12:47.740
Additionally, we find a vendor ID,
model name.

00:12:47.740 --> 00:12:50.950
In fact,
we take usually the entire configuration

00:12:50.960 --> 00:12:52.530
ROM and just put that in the I.O.

00:12:52.540 --> 00:12:54.610
registry to make it easy to access.

00:12:56.250 --> 00:12:59.530
Finally,
the family scans for unit directories,

00:12:59.530 --> 00:13:03.690
that was the top object in
the modules I showed you,

00:13:03.690 --> 00:13:07.540
and creates an entry in
IO registry for each one of those.

00:13:07.550 --> 00:13:10.970
The unit directory is where
we get the first indication of

00:13:10.970 --> 00:13:16.140
protocol information for a device,
which gives us a hint as to what drivers

00:13:16.140 --> 00:13:20.640
to load or how to take a closer look
at the device to really learn what

00:13:20.640 --> 00:13:23.140
it does and what the best driver is.

00:13:24.970 --> 00:13:28.360
At the very bottom of the software stack,
we had Apple FW-OHCI.

00:13:28.360 --> 00:13:34.220
On a couple of very old
machines that we do support,

00:13:34.220 --> 00:13:39.140
the blue and white G3 and the very
first G4 towers that had PCI graphics,

00:13:39.140 --> 00:13:43.960
we have an earlier generation
FireWire chip called PCI-LINX.

00:13:44.320 --> 00:13:46.290
So we do support that in Mac OS X.

00:13:46.320 --> 00:13:49.010
On those systems,
you'd find a driver called

00:13:49.010 --> 00:13:52.300
Apple LINX instead of Apple FW-OHCI.

00:13:52.300 --> 00:13:56.750
But those two drivers both provide the
same service interface up to the family,

00:13:56.870 --> 00:14:00.630
so there's no hardware-specific
knowledge past that point.

00:14:00.640 --> 00:14:04.780
So, except for those systems,
everything else uses Apple FW-OHCI,

00:14:04.780 --> 00:14:08.180
and that includes all the
products that we sell today.

00:14:08.180 --> 00:14:11.940
OHCI stands for
Open Host Controller Interface.

00:14:11.940 --> 00:14:14.240
It's the industry standard interface.

00:14:14.240 --> 00:14:16.540
It's the only interface that we
have for a FireWire controller,

00:14:16.540 --> 00:14:17.920
at least in a personal computer.

00:14:17.920 --> 00:14:22.060
And there's lots of vendors that
provide good quality OHCI silicon,

00:14:22.060 --> 00:14:24.620
such as on PCI cards and CardBus cards.

00:14:26.240 --> 00:14:29.120
By the way,
if you are going to use an add-in card,

00:14:29.350 --> 00:14:33.500
for example, in one of our older G3s
that doesn't have FireWire,

00:14:33.500 --> 00:14:39.260
use OHCI and be sure that you've selected
one that fully complies with both the

00:14:39.380 --> 00:14:42.500
OHCI standard and the 1394 standard.

00:14:42.500 --> 00:14:46.260
This is not a level at which we
tolerate bugs because there's lots of

00:14:46.260 --> 00:14:48.800
perfectly good controllers out there.

00:14:48.800 --> 00:14:52.390
This is also the only part
of the stack that is not in

00:14:52.390 --> 00:14:54.810
Darwin and not open-sourced.

00:14:55.680 --> 00:14:59.170
The OHCI driver has to
be shared by everybody.

00:14:59.170 --> 00:15:02.350
The camera driver, the disk driver,
scanners, printers,

00:15:02.480 --> 00:15:03.580
anything that's on the bus.

00:15:03.580 --> 00:15:08.420
That means it's a really bad place
to try to insert custom functionality

00:15:08.430 --> 00:15:11.020
for your particular application.

00:15:11.020 --> 00:15:13.240
There's better places to do that.

00:15:16.620 --> 00:15:20.000
Okay,
the next section is additional services.

00:15:20.020 --> 00:15:24.090
I talked about the core that were not
specific to any device or protocol.

00:15:24.250 --> 00:15:27.200
Now we're going to look at the
additional services that we provide

00:15:27.200 --> 00:15:33.390
for the most common kinds of device and
protocol on top of the core services.

00:15:35.290 --> 00:15:38.700
First of all is the FireWire user client.

00:15:38.730 --> 00:15:40.910
Strictly speaking,
this should be called a device interface,

00:15:40.930 --> 00:15:42.840
but we've gotten stuck
on the name user client,

00:15:42.840 --> 00:15:43.940
so we just use both.

00:15:44.000 --> 00:15:51.250
This is a way for application-level
software to talk directly to FireWire.

00:15:51.260 --> 00:15:54.690
It's not protocol-specific,
it just exports the basic

00:15:54.690 --> 00:15:58.370
commands like send a packet,
allocate some address space,

00:15:58.420 --> 00:16:00.500
read the configuration ROM.

00:16:01.720 --> 00:16:06.420
That exists in a package
called iofirewirelib.plugin.

00:16:08.150 --> 00:16:10.790
We also provide a family for SBP-2.

00:16:10.980 --> 00:16:13.080
That stands for Serial Bus Protocol.

00:16:13.220 --> 00:16:16.900
It's the protocol used by mass
storage devices on FireWire,

00:16:16.990 --> 00:16:19.650
most printers,
all scanners that I know of,

00:16:19.740 --> 00:16:21.260
some still cameras.

00:16:21.310 --> 00:16:26.990
It is the high performance optimized
protocol that takes advantage

00:16:26.990 --> 00:16:31.330
of FireWire's architecture to
get really high performance.

00:16:31.630 --> 00:16:35.060
This is provided in the kernel because,
as I said, it's used for storage,

00:16:35.060 --> 00:16:37.760
so we would have to have it
to boot from a FireWire disk.

00:16:37.800 --> 00:16:40.920
But there's a user client that
exports all of the same services

00:16:40.920 --> 00:16:42.560
out into application space.

00:16:42.560 --> 00:16:44.500
So those two parts are listed there.

00:16:44.500 --> 00:16:48.170
The other major protocol
on FireWire is AVC,

00:16:48.170 --> 00:16:51.280
the Audio Video Command Protocol.

00:16:51.280 --> 00:16:55.550
We have a family for that in the
kernel as well as a user client.

00:16:55.560 --> 00:16:59.200
And the names and the
architecture are similar to SBP.

00:17:00.020 --> 00:17:02.660
Though AVC is used for
things like DV cameras,

00:17:02.660 --> 00:17:04.900
TVs, DVD players, and so on.

00:17:07.230 --> 00:17:09.990
So as you probably noticed,
our motto is everything

00:17:09.990 --> 00:17:11.120
has a user client.

00:17:11.120 --> 00:17:13.900
Even though all of our
services are in the kernel,

00:17:13.900 --> 00:17:16.830
we've made everything
available out in user space.

00:17:16.830 --> 00:17:19.970
So it should really be possible
for most of you to do all of

00:17:19.970 --> 00:17:21.800
your development in user space.

00:17:21.870 --> 00:17:25.750
And if you've tried it already,
you know this, it's much easier doing

00:17:25.750 --> 00:17:26.940
this in user space.

00:17:26.940 --> 00:17:30.600
If you have some problems with your
driver at first and it crashes,

00:17:30.730 --> 00:17:32.510
you'll take out an application.

00:17:32.590 --> 00:17:34.480
The system will survive.

00:17:35.320 --> 00:17:38.960
The debugging tools for user space
are much more convenient to use.

00:17:38.960 --> 00:17:42.710
And if you're doing iterative
development on your driver or your app,

00:17:42.710 --> 00:17:45.240
you can reload it,
rerun it as many times as you like,

00:17:45.240 --> 00:17:47.760
rather than rebooting
the computer every time.

00:17:47.780 --> 00:17:51.220
So we've done a lot of work
to make it possible for you to

00:17:51.220 --> 00:17:53.400
write software in user space.

00:17:53.400 --> 00:17:55.000
That should be your target.

00:17:55.000 --> 00:17:58.120
If you find that you think you
need to work in the kernel,

00:17:58.120 --> 00:18:02.160
talk with us, because you can,
but maybe you've overlooked something

00:18:02.170 --> 00:18:04.060
or we've overlooked something.

00:18:04.060 --> 00:18:05.300
And there's a way to do that.

00:18:05.320 --> 00:18:07.500
do what you need to do
in user space instead.

00:18:13.320 --> 00:18:14.670
Now, let's go back to the picture.

00:18:14.940 --> 00:18:16.700
There's the core services.

00:18:16.700 --> 00:18:19.490
Now we're going to fill in all the
additional things that I've talked about

00:18:19.490 --> 00:18:20.790
so you can see how they fit together.

00:18:20.800 --> 00:18:25.190
We're going to need more room,
so I'm going to simplify the names

00:18:25.190 --> 00:18:29.450
and now I'm going to push things
around so I can build on it.

00:18:30.020 --> 00:18:33.340
You can see I've added a number and
a letter to the device and the unit.

00:18:33.340 --> 00:18:35.540
We're going to have more of those.

00:18:35.620 --> 00:18:39.170
Let's start with the simplest case.

00:18:39.520 --> 00:18:43.670
An application that wants to talk
directly to a FireWire device using

00:18:43.670 --> 00:18:45.540
the plain user-client interface.

00:18:45.540 --> 00:18:49.320
It's not SBP, it's not ABC,
or for some reason you don't

00:18:49.330 --> 00:18:52.360
want to use those layers,
you just want direct access.

00:18:53.260 --> 00:18:57.810
Your application runs way up
in the clouds in user land.

00:18:57.810 --> 00:19:01.980
And your application loads the
FireWire lib that we showed earlier.

00:19:02.010 --> 00:19:05.710
The lib knows how to establish
a connection with the kernel,

00:19:05.920 --> 00:19:08.200
crossing, here it is,
the user kernel boundary.

00:19:08.200 --> 00:19:14.080
And as a result, in the kernel,
the user client gets loaded and opened

00:19:14.080 --> 00:19:17.510
as a driver for the unit in that device.

00:19:17.510 --> 00:19:21.120
Now your application can use
the APIs in the FireWire lib

00:19:21.130 --> 00:19:23.180
to communicate on FireWire.

00:19:23.200 --> 00:19:24.700
From application space.

00:19:24.700 --> 00:19:28.480
The user client is really just
a pass-through driver that knows

00:19:28.480 --> 00:19:32.360
how to move your commands and
data in and out of the kernel.

00:19:35.200 --> 00:19:38.190
Let's suppose that your device
actually is a multi-function device,

00:19:38.200 --> 00:19:41.320
and in addition to Unit A,
which is doing some custom thing

00:19:41.320 --> 00:19:44.940
that you talk to from an application,
you also have a Unit B.

00:19:44.940 --> 00:19:49.600
And let's say that this unit represents
just an ordinary disk drive function.

00:19:51.210 --> 00:19:55.200
We would have discovered that the unit
directory indicated the SBP-2 protocol.

00:19:55.200 --> 00:19:58.980
So in the kernel,
the SBP-2 family loads against

00:19:59.230 --> 00:20:01.140
this part of the device.

00:20:01.140 --> 00:20:07.330
The first part of that, SBP-target,
represents the unit directory itself.

00:20:07.330 --> 00:20:12.740
And every SBP device has
at least one logical unit,

00:20:12.740 --> 00:20:14.180
occasionally more than one.

00:20:14.180 --> 00:20:18.180
That's represented by an SBP-LUN object.

00:20:18.180 --> 00:20:20.300
I said this case was a disk drive.

00:20:20.300 --> 00:20:23.960
Disk drivers are in the kernel,
so that will have been loaded

00:20:23.990 --> 00:20:26.990
by I/O Kit right there in
the kernel doing its thing.

00:20:27.020 --> 00:20:30.030
So here you can see a case of a
single FireWire device where we have

00:20:30.140 --> 00:20:34.010
one driver running in the kernel,
an application running out in user space.

00:20:34.070 --> 00:20:37.700
They're both able to hook into the
device and do their thing without

00:20:37.700 --> 00:20:39.540
interfering with each other.

00:20:40.160 --> 00:20:42.220
Let's add another device
to the FireWire bus.

00:20:42.220 --> 00:20:44.300
It will have a single unit.

00:20:44.300 --> 00:20:48.680
This will also be an SBP device,
but let's say it's a scanner.

00:20:48.680 --> 00:20:53.380
The SBP services still load in the
kernel because that's where they exist.

00:20:53.380 --> 00:20:55.670
The scanner has a logical unit.

00:20:55.670 --> 00:20:58.950
But now you come along and
you run some application,

00:20:58.980 --> 00:21:01.840
say Photoshop, up in application space.

00:21:02.240 --> 00:21:05.500
But rather than open the
all-purpose FireWire lib,

00:21:05.500 --> 00:21:10.220
we can use a much more appropriate API,
which is the SBP-2 user client.

00:21:10.220 --> 00:21:14.340
So the lib is the part of that
that lives in application space.

00:21:14.340 --> 00:21:17.590
And when it gets opened,
it establishes a connection with its

00:21:17.590 --> 00:21:22.250
corresponding user client in the kernel,
which acts as the driver for that device.

00:21:22.260 --> 00:21:25.520
Now the application can
communicate with the scanner,

00:21:25.790 --> 00:21:28.350
again running all of its
logic up in user space,

00:21:28.350 --> 00:21:31.980
using the kernel just as a
transport to move stuff in and out.

00:21:32.240 --> 00:21:34.140
of the device.

00:21:35.480 --> 00:21:39.730
Finally, let's connect a device
that is a DV camcorder.

00:21:39.770 --> 00:21:43.300
Again, it has a unit directory
indicating the AVC protocol.

00:21:43.300 --> 00:21:48.270
So, we load the AVC family
corresponding to that.

00:21:48.280 --> 00:21:52.130
Something new I'll talk about later
is that we now do subunit enumeration,

00:21:52.130 --> 00:21:55.250
so we will create a subunit
corresponding to the camcorder's

00:21:55.250 --> 00:21:56.920
specific functionality.

00:21:57.660 --> 00:22:01.240
Now,
an application like iMovie comes along.

00:22:01.490 --> 00:22:04.370
Through QuickTime,
it opens up the AVC lib

00:22:04.370 --> 00:22:08.090
out in user space,
which hooks into the AVC user

00:22:08.090 --> 00:22:11.800
client and is able to directly
send device control commands,

00:22:11.800 --> 00:22:13.640
for example, to the camera.

00:22:13.640 --> 00:22:17.500
It doesn't fit in the picture,
but in the iMovie QuickTime case,

00:22:17.500 --> 00:22:21.720
there's actually also a connection
to the plain FireWire user client,

00:22:21.740 --> 00:22:24.950
which is how the isochronous data,
the real-time DV,

00:22:24.950 --> 00:22:26.880
is captured or exported.

00:22:27.690 --> 00:22:29.660
So, it's a very flexible architecture.

00:22:29.660 --> 00:22:33.310
So, as you can see from this figure,

00:22:34.460 --> 00:22:38.860
This should re-emphasize the point that
everything's available in user space,

00:22:38.870 --> 00:22:40.240
but it also shows something else.

00:22:40.240 --> 00:22:45.120
What we have in user space is just
glue that hooks into the kernel.

00:22:45.120 --> 00:22:48.090
If you look at the center two columns,
we have a disk driver

00:22:48.090 --> 00:22:51.420
running in the kernel,
and we have a scanner running

00:22:51.420 --> 00:22:55.320
out in application space,
but they're both using the

00:22:55.320 --> 00:22:59.970
same SBP family in the kernel,
so there's not a separate or second

00:23:00.260 --> 00:23:02.980
SBP implementation in user space.

00:23:03.280 --> 00:23:05.900
There's just one, and it's in the kernel,
so it's always going

00:23:05.900 --> 00:23:07.010
to work the same way.

00:23:07.020 --> 00:23:09.960
So that helps keep things simple,
even though you have the

00:23:10.050 --> 00:23:13.340
flexibility to access it from
the kernel or from user space.

00:23:17.000 --> 00:23:22.270
Okay, there's more, but it won't fit,
so let's unplug two devices.

00:23:22.510 --> 00:23:25.090
You didn't see it earlier,
but this was actually here all along.

00:23:25.090 --> 00:23:26.020
There just wasn't room.

00:23:26.020 --> 00:23:30.420
In addition to creating device
objects for every device on the bus,

00:23:30.420 --> 00:23:35.650
we will always have one local node
object attached to the family.

00:23:35.650 --> 00:23:39.330
Essentially,
this represents the Mac itself.

00:23:39.330 --> 00:23:42.140
The Mac is also a node
on the FireWire bus,

00:23:42.140 --> 00:23:46.950
but it doesn't discover itself as a
device or load a driver for itself.

00:23:48.000 --> 00:23:50.590
Instead,
we just create this local node object

00:23:50.750 --> 00:23:55.090
as a place where you can hook in if you
want to talk to FireWire in general,

00:23:55.090 --> 00:23:58.780
rather than talking to one
of the devices in particular.

00:23:58.800 --> 00:24:04.310
Suppose you had an application that wants
to show a picture graphically depicting

00:24:04.400 --> 00:24:06.760
the objects on the FireWire bus.

00:24:06.760 --> 00:24:10.350
That application would like
to receive the topology map.

00:24:10.440 --> 00:24:13.060
It might like to read the
configuration ROMs on the devices.

00:24:13.060 --> 00:24:15.980
It might even do some further
dialogue with the devices.

00:24:17.370 --> 00:24:20.180
You can run that application
out in user space,

00:24:20.240 --> 00:24:22.920
use the plain FireWire lib.

00:24:22.980 --> 00:24:25.720
It will trigger the user client
to get hooked into the local node.

00:24:25.720 --> 00:24:29.550
Now you can do anything that you could
do to an ordinary FireWire device,

00:24:29.550 --> 00:24:31.770
but you can do it in a bus-general way.

00:24:35.730 --> 00:24:40.240
The local node is there even if there
are no devices on the FireWire bus.

00:24:40.380 --> 00:24:43.230
Your application won't be showing
a very interesting picture,

00:24:43.230 --> 00:24:46.990
but you can still run and talk to the bus
without having somebody else out there.

00:24:47.010 --> 00:24:48.150
So it's very general.

00:24:48.260 --> 00:24:51.800
It means that you don't have to
track down some random device on

00:24:51.800 --> 00:24:53.950
the bus and try to talk through it.

00:24:53.980 --> 00:24:56.130
If you did that,
you might lock out the driver

00:24:56.130 --> 00:24:57.990
that's trying to use that device.

00:24:58.160 --> 00:25:02.730
So the local node provides a second
path in where you can access FireWire

00:25:02.730 --> 00:25:05.350
without getting in anybody else's way.

00:25:10.650 --> 00:25:12.510
Okay,
now let's look at some of the things

00:25:12.510 --> 00:25:14.160
we've changed since last year.

00:25:14.160 --> 00:25:16.140
We covered these at a
high level on Monday.

00:25:16.140 --> 00:25:18.360
I'm going to go into more
detail about them today.

00:25:20.820 --> 00:25:22.130
SCSITaaskUserclient.

00:25:22.130 --> 00:25:26.850
This is the answer to about half the
questions we get on our mailing list.

00:25:27.110 --> 00:25:32.290
There's a lot of devices out
there that on FireWire use SBP-2,

00:25:32.290 --> 00:25:35.330
but architecturally
they are SAM compliant.

00:25:35.340 --> 00:25:37.500
That's the SCSI architecture model.

00:25:37.620 --> 00:25:42.430
This includes things like CD-ROM burners,
printers, scanners,

00:25:42.430 --> 00:25:44.410
certain still cameras.

00:25:45.720 --> 00:25:48.830
It's been possible to access
these devices through the SBP-2

00:25:48.830 --> 00:25:53.740
family in the kernel or the SBP-2
user client in application space.

00:25:53.740 --> 00:25:57.850
But that exposed you to a lot of
1394 details that may not have

00:25:57.960 --> 00:26:01.600
really been interesting if you
just wanted to control your device.

00:26:01.600 --> 00:26:05.310
The SCSITaaskUserClient, in general,
is a much better way to

00:26:05.310 --> 00:26:06.790
access these devices.

00:26:06.800 --> 00:26:10.800
Now,
this was just finished last year at WWDC,

00:26:10.800 --> 00:26:16.140
but it's really only become available
well into the year since then.

00:26:16.160 --> 00:26:20.260
So it wasn't really possible to
ship things on it a year ago.

00:26:21.580 --> 00:26:23.900
If you have a device of this
type and you haven't already

00:26:23.930 --> 00:26:26.610
looked at SCSITaaskUserclient,
this is probably what

00:26:26.610 --> 00:26:27.740
you should be using.

00:26:27.830 --> 00:26:28.650
It's very high level.

00:26:28.650 --> 00:26:31.730
You can ignore logins, reconnects,
bus resets.

00:26:31.840 --> 00:26:34.170
You can concentrate on picking
commands to send to your

00:26:34.170 --> 00:26:37.240
device to make it do its thing,
rather than worrying about

00:26:37.240 --> 00:26:38.540
the FireWire details.

00:26:38.620 --> 00:26:41.170
On our mailing list,
almost everybody who we send

00:26:41.170 --> 00:26:44.290
off to SCSITaaskUserclient,
they report back that that's what they

00:26:44.290 --> 00:26:47.410
wanted and they stop asking about SBP-2.

00:26:49.180 --> 00:26:52.300
Another thing where we've made
big changes since last year is the

00:26:52.300 --> 00:26:55.250
isochronous services in the user client.

00:26:55.320 --> 00:26:59.080
If you're new to FireWire,
isochronous is the word that describes

00:26:59.230 --> 00:27:03.560
real-time transfer on FireWire,
such as the capturing

00:27:03.570 --> 00:27:05.740
of DV from a camera.

00:27:05.800 --> 00:27:09.240
The opposite is asynchronous,
which is the kind of traffic we

00:27:09.330 --> 00:27:10.900
use for FireWire disk drives.

00:27:10.900 --> 00:27:13.530
It's not real-time,
it just happens at any time,

00:27:13.540 --> 00:27:14.850
thus asynchronous.

00:27:14.860 --> 00:27:20.300
The user client now is very capable
of doing isochronous transfers,

00:27:20.300 --> 00:27:24.100
so you don't have to go into
the kernel to accomplish that.

00:27:24.260 --> 00:27:28.600
You can send and receive these
real-time streams using DCLs.

00:27:28.880 --> 00:27:31.900
DCL is Data Stream Command Language.

00:27:31.920 --> 00:27:36.490
It's an abstract DMA program
that allows you to describe your

00:27:36.510 --> 00:27:41.730
real-time transfer at a very
fine-grained packet-by-packet level.

00:27:41.880 --> 00:27:45.770
It's done this way because the
FireWire real-time transfer sends or

00:27:45.770 --> 00:27:47.990
receives 8,000 packets per second.

00:27:48.000 --> 00:27:52.410
So you don't want to be calling
some API 8,000 times a second

00:27:52.410 --> 00:27:54.020
to send or receive a packet.

00:27:54.020 --> 00:27:58.510
Instead, you write this DMA program
in advance and turn it on,

00:27:58.600 --> 00:28:02.920
and it runs at 8,000 packets per second,
periodically updating you,

00:28:02.920 --> 00:28:06.740
saying that it has produced data or it
needs to be refilled with more data.

00:28:06.740 --> 00:28:09.320
The same thing worked in Mac OS 9.

00:28:10.080 --> 00:28:14.270
Largely, you can copy your programs
directly from Mac OS 9 to Mac OS X.

00:28:14.280 --> 00:28:17.710
There's minor changes,
such as in the way the timestamps work,

00:28:17.710 --> 00:28:20.070
but nothing that should
force you to re-architect.

00:28:21.640 --> 00:28:25.400
Very importantly,
even if your DCL is running,

00:28:25.450 --> 00:28:30.740
even if you're using the user client,
your DCL itself runs in the kernel.

00:28:30.810 --> 00:28:33.430
And all of your memory is used directly.

00:28:33.450 --> 00:28:35.330
It's mapped right into the DMA.

00:28:35.410 --> 00:28:38.190
So even though you're
out in application space,

00:28:38.190 --> 00:28:41.140
there's no penalty copying
data out of the kernel.

00:28:41.320 --> 00:28:45.240
The performance can be just as
good as what you get in the kernel.

00:28:45.440 --> 00:28:50.090
In our SDK,
there is sample code for the IIDC,

00:28:50.170 --> 00:28:57.330
also known as DCAM, type of web camera,
such as the iBot or the ADS Pyro.

00:28:57.520 --> 00:29:00.370
We, as we talked about Monday and
I think is coming up,

00:29:00.370 --> 00:29:03.760
we have a much better driver
that we're including in Jaguar,

00:29:03.760 --> 00:29:07.470
but this sample code should be a
very good start for writing DCLs

00:29:07.470 --> 00:29:09.650
and learning how to control them.

00:29:09.670 --> 00:29:12.500
It's not such a good sample
for how to fit into QuickTime,

00:29:12.610 --> 00:29:15.480
but it's a good sample of
how to work with FireWire.

00:29:20.700 --> 00:29:24.100
Another thing we've made a
lot of changes in since last

00:29:24.100 --> 00:29:25.930
year is the AVC user client.

00:29:26.130 --> 00:29:30.040
Last year it was really just a
stub that iMovie could hook into,

00:29:30.040 --> 00:29:32.370
but it wasn't general purpose.

00:29:32.430 --> 00:29:37.080
Now we have made it fully the equal of
the services available in the kernel,

00:29:37.080 --> 00:29:40.920
and to prove this, in Jaguar,
we are moving the DV driver itself

00:29:41.090 --> 00:29:43.970
out of the kernel into user space.

00:29:44.050 --> 00:29:46.560
This shows that we can
get frame accurate,

00:29:46.670 --> 00:29:49.930
30 frame per second
DV capture over long periods,

00:29:49.960 --> 00:29:53.100
suitable for not just iMovie,
but Final Cut Pro,

00:29:53.100 --> 00:29:55.160
with our driver running in user space.

00:29:55.220 --> 00:29:57.730
So if you're not convinced
that this is a good idea,

00:29:57.800 --> 00:30:01.400
take a look at what we've done,
because it really works pretty well.

00:30:01.750 --> 00:30:05.460
Additionally,
the ABC User Client Support, well,

00:30:05.460 --> 00:30:09.330
FCP is really strictly
what this should be called.

00:30:09.420 --> 00:30:14.260
The Function Control Protocol is
the bottom part of ABC.

00:30:14.460 --> 00:30:19.440
It defines how to send and receive
these commands in 1394 packets.

00:30:19.610 --> 00:30:23.310
ABC defines higher level things,
such as what the commands are and

00:30:23.310 --> 00:30:26.740
associated things that work with them,
like the next bullet.

00:30:26.740 --> 00:30:30.390
So if you're looking for FCP,
it's in here.

00:30:31.290 --> 00:30:33.750
Significantly,
we've added that you can now

00:30:33.750 --> 00:30:35.720
either send or receive these.

00:30:35.720 --> 00:30:40.600
You can send AVC commands and
receive responses from some device,

00:30:40.600 --> 00:30:44.310
like controlling a camera,
or you can receive AVC commands from

00:30:44.310 --> 00:30:47.100
some device and send responses to those.

00:30:47.100 --> 00:30:53.400
For example, if you wanted to implement a
virtual camera or TV on your Mac.

00:30:54.380 --> 00:30:58.510
Also in the ABC UserClient is
access to plug control registers.

00:30:58.600 --> 00:31:03.290
The ABC spec defines these 32-bit
registers at a certain fixed address.

00:31:03.610 --> 00:31:07.380
These registers contain information
about active isochronous

00:31:07.410 --> 00:31:10.290
communication to or from a device.

00:31:10.460 --> 00:31:13.760
So any two devices exchanging
data will have corresponding

00:31:13.760 --> 00:31:15.790
sets of plug control registers.

00:31:15.870 --> 00:31:18.180
The register indicates
what channel it's on,

00:31:18.320 --> 00:31:21.560
how fast it's going,
how many people are listening to it.

00:31:21.700 --> 00:31:24.540
So to be fully compatible with AVC,
you need these,

00:31:24.550 --> 00:31:29.020
and it's now possible to allocate them
and use them in the AVC user client.

00:31:29.040 --> 00:31:32.610
CMP, shown there,
is Connection Management Protocol.

00:31:32.740 --> 00:31:38.180
That's the series of procedures that
you perform on plug control registers

00:31:38.180 --> 00:31:40.360
to set up and tear down connections.

00:31:42.100 --> 00:31:47.080
As I showed in the big diagram,
we now enumerate subunits in AVC devices.

00:31:47.080 --> 00:31:53.640
AVC, the designers really didn't,
they weren't into the spirit of 1394.

00:31:53.760 --> 00:31:56.060
They have a config
ROM with a unit directory,

00:31:56.190 --> 00:31:57.780
but only because they had to.

00:31:57.780 --> 00:32:00.860
They don't put information in
there about what the device does.

00:32:00.860 --> 00:32:04.480
Instead, you have to inquire using an
AVC command to ask the device,

00:32:04.480 --> 00:32:06.180
hey, what do you really do?

00:32:06.180 --> 00:32:10.020
So, since all AVC devices need
that in order to get anywhere,

00:32:10.020 --> 00:32:11.880
we provide that standard.

00:32:12.000 --> 00:32:15.300
And we publish the information
in the I/O registry.

00:32:15.370 --> 00:32:19.160
So, it's similar to what SBP does
in picking protocol information

00:32:19.160 --> 00:32:20.120
out of the config ROM.

00:32:20.120 --> 00:32:21.760
It just comes from a different place.

00:32:21.760 --> 00:32:23.330
But it leads to the same thing.

00:32:23.470 --> 00:32:26.670
You can use the information in
I/O registry to further match and

00:32:26.680 --> 00:32:28.230
discover what the device does.

00:32:28.240 --> 00:32:32.560
Finally, we've added something called
asynchronous connections.

00:32:32.560 --> 00:32:35.610
This is sort of a poor man's SBP-2.

00:32:35.610 --> 00:32:39.620
It's a serial transport for
moving blocks of asynchronous

00:32:39.620 --> 00:32:41.980
data within the framework of AVC.

00:32:41.980 --> 00:32:44.220
It's not very fast.

00:32:44.220 --> 00:32:46.360
It's somewhat clunky compared to SBP-2.

00:32:46.360 --> 00:32:51.360
But if your main thing is DV and you
also want to move some still images,

00:32:51.360 --> 00:32:52.700
it's good enough.

00:32:52.740 --> 00:32:53.950
So, we support that.

00:32:53.950 --> 00:32:58.430
There are cameras coming out that use it,
for example, for still image transport.

00:32:58.460 --> 00:33:01.860
It's there,
but it shouldn't be your first choice.

00:33:01.860 --> 00:33:04.800
If someone's already made a
device and it requires this,

00:33:04.800 --> 00:33:06.320
fine, go ahead and use it.

00:33:06.360 --> 00:33:09.730
If you're designing something new,
you should really look to SBP-2

00:33:09.730 --> 00:33:11.960
instead if you want good performance.

00:33:15.500 --> 00:33:20.100
Speaking of which, in SBP-2,
those really old Macs

00:33:20.110 --> 00:33:22.190
I described earlier,
the blue and white G3

00:33:22.190 --> 00:33:25.310
and certain G4 towers,
use an earlier generation

00:33:25.310 --> 00:33:26.830
FireWire controller.

00:33:26.840 --> 00:33:31.010
One of the reasons we aren't shipping
that anymore is that it had a tendency

00:33:31.010 --> 00:33:33.620
to underflow when transmitting packets.

00:33:33.680 --> 00:33:35.960
In other words,
we would ask it to send a packet,

00:33:35.960 --> 00:33:38.980
and it would start sending the packet,
and then in the middle,

00:33:38.980 --> 00:33:41.400
it would run out of data,
and the packet would be damaged.

00:33:42.320 --> 00:33:45.640
That triggers what's called
"ac data error" on the bus.

00:33:45.840 --> 00:33:48.220
It's not fatal,
the device can recover from it,

00:33:48.410 --> 00:33:52.040
but the device will recover a lot
faster in some cases if we retry

00:33:52.040 --> 00:33:54.200
the packet without being asked.

00:33:54.220 --> 00:33:56.100
So, Mac OS 9 did that.

00:33:56.220 --> 00:33:59.710
We have changed SBP-2 in Mac OS X,
so it will do that too.

00:33:59.720 --> 00:34:02.170
So,
the performance on those older machines

00:34:02.170 --> 00:34:04.220
should now be completely the same.

00:34:04.220 --> 00:34:10.210
We've added a bunch of stuff that
is exclusive to Mac OS X in SBP-2.

00:34:10.280 --> 00:34:14.300
We've added a flag called "Fails on
ACK Busy." You shouldn't set this

00:34:14.420 --> 00:34:19.470
flag without knowing what it does,
but in congested situations,

00:34:19.470 --> 00:34:24.180
some devices will get better performance
if we pace their I/Os a little bit more

00:34:24.180 --> 00:34:26.780
and take some steps to avoid ACK Busy.

00:34:26.960 --> 00:34:30.220
So, for best possible performance,
the disk driver, for example,

00:34:30.220 --> 00:34:32.380
will set this flag when it's appropriate.

00:34:32.490 --> 00:34:35.490
Most people won't need to set it,
you'll just notice higher

00:34:35.490 --> 00:34:37.340
performance from your drives.

00:34:37.440 --> 00:34:38.300
Physical orbs.

00:34:38.300 --> 00:34:40.380
This is pretty esoteric SPP2 stuff.

00:34:41.790 --> 00:34:45.210
We've added the option,
you have a flag to control this,

00:34:45.210 --> 00:34:50.560
to use physical memory for your orbs
rather than FireWire virtual memory,

00:34:50.560 --> 00:34:52.580
also known as a pseudo-address space.

00:34:52.580 --> 00:34:57.230
This takes out one interrupt in
the processing of an orb because

00:34:57.230 --> 00:35:02.640
the FireWire OHCI controller can
respond to the device automatically,

00:35:02.760 --> 00:35:05.170
that's why it's called physical,
rather than sending the

00:35:05.170 --> 00:35:06.390
request up to software.

00:35:07.300 --> 00:35:11.410
Depending on the dynamics of your I/Os,
you may see a 5% increase in disk

00:35:11.420 --> 00:35:13.270
speed when this is turned on.

00:35:13.300 --> 00:35:15.460
So we will be using
this in our disk driver.

00:35:15.540 --> 00:35:17.300
If you're doing a
high-performance device,

00:35:17.300 --> 00:35:18.500
you may want to turn this on.

00:35:18.540 --> 00:35:22.480
For a low-performance device,
you may want to leave this off because if

00:35:22.480 --> 00:35:27.430
you're debugging with a packet analyzer,
it's much easier to spot the

00:35:27.430 --> 00:35:31.750
orbs on the bus if they're
non-physical because the addresses

00:35:31.780 --> 00:35:34.110
are very regular and easy to see.

00:35:34.700 --> 00:35:37.930
A related change to orbs is
unlimited page table size.

00:35:37.930 --> 00:35:42.200
The page table for an SBP-2 orb
has to be physically contiguous.

00:35:42.200 --> 00:35:45.460
So in Mac OS 9,
we limited it to 4 kilobytes,

00:35:45.460 --> 00:35:49.000
and that limit carried
over in Mac OS X until now.

00:35:49.240 --> 00:35:52.120
If you have a gigantic orb,
which might be used, say,

00:35:52.200 --> 00:35:56.780
by a scanner that's going to scan a 100
megabyte page with a single command,

00:35:56.780 --> 00:36:01.890
we will now use a pseudo-address space
to write out the entire page table,

00:36:01.950 --> 00:36:06.020
no matter how large it is,
so that you can get basically

00:36:06.390 --> 00:36:09.360
unlimited transfer size in any orb.

00:36:09.410 --> 00:36:13.130
It will be slightly slower because
it's the opposite of physical orbs.

00:36:13.130 --> 00:36:16.280
The page table accesses are
now going through software.

00:36:16.280 --> 00:36:19.220
But for something like a scanner
that's probably not sacralized...

00:36:19.220 --> 00:36:23.450
...or that's not saturating the bus,
you'll probably prefer to have

00:36:23.450 --> 00:36:27.200
unlimited transfer size rather
than 1% more performance that the

00:36:27.310 --> 00:36:29.290
scanner probably wouldn't use.

00:36:29.500 --> 00:36:32.500
Finally, in SBP-2,
we've added an automatic

00:36:32.500 --> 00:36:34.390
retry feature for logins.

00:36:34.560 --> 00:36:36.910
There are some cases in which
you need to try a few times

00:36:36.910 --> 00:36:38.360
to get logged into a device.

00:36:38.360 --> 00:36:41.400
Rather than forcing every driver
to do it in their own way,

00:36:41.400 --> 00:36:44.030
we've added an optional
feature to do it for you.

00:36:44.030 --> 00:36:47.460
And there's a configurable delay
so that if your device needs a

00:36:47.470 --> 00:36:50.810
little time to think about it,
we can accommodate that.

00:36:54.190 --> 00:36:58.460
Since last year, we have distributed five
new SDKs for Mac OS X.

00:36:58.460 --> 00:37:01.720
Each one of these contains
the latest binaries,

00:37:01.720 --> 00:37:04.540
the latest sample code,
the latest source code,

00:37:04.540 --> 00:37:07.160
all the documentation that we have,
all the tools that we have.

00:37:07.180 --> 00:37:10.760
We're now working to integrate that
with the Mac OS X developer tool

00:37:10.850 --> 00:37:15.010
CD so that everybody will have it,
whether they go looking for it or not.

00:37:15.020 --> 00:37:17.910
But it will continue to be available
for download on our website,

00:37:17.920 --> 00:37:19.620
where you can get the very latest.

00:37:19.620 --> 00:37:21.800
It's always been free public download.

00:37:21.800 --> 00:37:23.260
You don't have to sign up for anything.

00:37:24.100 --> 00:37:26.820
The SDKs are the biggest
product for you guys,

00:37:26.990 --> 00:37:29.660
the developers,
that comes out of this team.

00:37:29.660 --> 00:37:32.130
So we spend a lot of time on that.

00:37:32.280 --> 00:37:34.470
Consequently,
we'd love to get your feedback,

00:37:34.520 --> 00:37:38.580
especially at the feedback forum tomorrow
or today during Q&A if there's time.

00:37:38.580 --> 00:37:41.080
What in there is helpful to you?

00:37:41.080 --> 00:37:42.090
What is not helpful?

00:37:42.090 --> 00:37:43.600
What do you just not understand?

00:37:43.600 --> 00:37:45.940
What can we do to make those better?

00:37:45.940 --> 00:37:47.340
Because we spend a lot of time on those.

00:37:50.090 --> 00:37:54.560
One thing we've done since last year
is added a lot of HeaderDoc into the,

00:37:54.640 --> 00:37:58.710
well, it's in the SDK and it's
also in all the files.

00:37:58.720 --> 00:38:02.540
Almost 100 classes, methods,
and so on documented.

00:38:02.540 --> 00:38:03.970
This calls out some of the highlights.

00:38:04.040 --> 00:38:06.380
So hopefully this makes
things a bit more clear.

00:38:09.220 --> 00:38:12.080
I mentioned it on Monday,
we also have a whole new

00:38:12.100 --> 00:38:13.570
book on user clients.

00:38:13.590 --> 00:38:16.200
There's a link in here for that.

00:38:16.300 --> 00:38:18.740
As I mentioned on Monday,
we have a new driver

00:38:18.740 --> 00:38:21.700
for IIDC type cameras,
also known as DCAM.

00:38:21.740 --> 00:38:25.110
It's very high performance,
it's much better than what we had

00:38:25.110 --> 00:38:26.920
in the sample code in the SDK.

00:38:31.960 --> 00:38:34.400
Now we'll go through some of the
things that we're still working on,

00:38:34.540 --> 00:38:37.790
things that we'd be interested
in working with you on over the

00:38:37.790 --> 00:38:40.470
next few months or the next year.

00:38:42.020 --> 00:38:44.200
There's a lot of interest in IP1394.

00:38:44.410 --> 00:38:47.870
This is the internet protocol,
commonly known as TCP/IP,

00:38:47.930 --> 00:38:50.600
though that's not completely accurate.

00:38:50.730 --> 00:38:57.100
There is a standard in as much as
the IETF ever standardizes anything,

00:38:57.110 --> 00:39:00.150
which means there's an
RFC available on the web.

00:39:00.180 --> 00:39:07.680
You can go to IETF.org and pick up
RFC 2734 and it shows how to transport

00:39:07.680 --> 00:39:10.340
the internet protocol on FireWire.

00:39:10.620 --> 00:39:12.460
It's not super complicated.

00:39:12.500 --> 00:39:18.210
Basically, you send an ARP packet to find
out somebody else who's out there,

00:39:18.210 --> 00:39:19.360
just like on Ethernet.

00:39:19.380 --> 00:39:23.000
And what you get back is a
FireWire address of a FIFO,

00:39:23.030 --> 00:39:26.940
where you can send packets
for a particular device.

00:39:28.800 --> 00:40:32.400
[Transcript missing]

00:40:33.240 --> 00:40:37.040
Here's a picture that shows how
the IP1394 datagram is formed.

00:40:37.320 --> 00:40:40.100
It's encapsulated in
a block write packet.

00:40:40.100 --> 00:40:43.100
The top half of the picture
shows the standard block write

00:40:43.100 --> 00:40:47.320
header for a packet on 1394,
including its address,

00:40:47.320 --> 00:40:50.940
so that FIFO high and FIFO low
are the address that was

00:40:50.940 --> 00:40:53.360
returned from the ARP process.

00:40:53.620 --> 00:40:58.680
Then the payload portion of the packet
simply has a 32-bit encapsulation header

00:40:58.680 --> 00:41:03.050
that covers things like IP fragmentation,
followed by an IP datagram,

00:41:03.050 --> 00:41:05.240
which can be of variable sizes.

00:41:05.240 --> 00:41:06.970
So it's really pretty straightforward.

00:41:09.940 --> 00:41:12.360
We're also doing active
work on audio for FireWire.

00:41:12.360 --> 00:41:16.840
This generally means ISO 61883,
which defines the transport from moving

00:41:16.840 --> 00:41:19.580
audio data in real time across FireWire.

00:41:19.620 --> 00:41:23.680
In case you haven't figured this out,
the FireWire we have today at S400 can

00:41:23.760 --> 00:41:28.390
carry 400 channels of CD quality music,
or any kind of audio.

00:41:28.470 --> 00:41:31.800
So there's tremendous potential
there for audio applications.

00:41:31.910 --> 00:41:35.290
We are working on supporting the
audio subunit and the music subunit,

00:41:35.310 --> 00:41:39.880
both of which are part of AVC,
supporting MIDI over this transport,

00:41:39.910 --> 00:41:42.840
and providing services
for SMPTE timecode.

00:41:42.900 --> 00:41:45.830
If you're interested in
developing drivers for this,

00:41:45.890 --> 00:41:48.900
we have more to talk about,
so please get in contact with us.

00:41:50.910 --> 00:41:53.200
We're also spending some time on 1394b.

00:41:53.330 --> 00:41:55.800
As I described Monday,
this standard is finished.

00:41:55.800 --> 00:41:59.740
It's been published by the IEEE,
or it's being published.

00:41:59.900 --> 00:42:03.790
Almost all of the changes
for 1394b are in the PHY.

00:42:03.810 --> 00:42:06.040
This spec was designed by
a lot of software people,

00:42:06.040 --> 00:42:09.700
so they put all the
changes in the hardware.

00:42:09.700 --> 00:42:11.850
My hat's off to them.

00:42:13.800 --> 00:42:16.600
It's very unlikely you'll have
to change anything in software.

00:42:16.690 --> 00:42:20.160
We have to change a few things in
the family and the OHCI driver.

00:42:20.160 --> 00:42:24.200
For example, simply to program the DMA to
transmit at higher speeds,

00:42:24.200 --> 00:42:27.280
we have to program in some
different speed codes.

00:42:27.300 --> 00:42:32.200
The packets can be larger in 1394B
so that we get high performance.

00:42:32.220 --> 00:42:34.890
For asynchronous, that's limited to 4K.

00:42:34.890 --> 00:42:37.120
I'll show a table on the next slide.

00:42:37.520 --> 00:42:39.630
We have to allocate some
more buffer memory because if

00:42:39.630 --> 00:42:42.340
things are going twice as fast,
we may get twice as much stuff

00:42:42.340 --> 00:42:44.080
piled up before we can sort it out.

00:42:44.120 --> 00:42:47.750
And we have some work to do in
sorting out the topology of the

00:42:47.910 --> 00:42:50.330
devices based on the self-ID packets.

00:42:50.400 --> 00:42:52.390
I'll show some more detail about that.

00:42:52.400 --> 00:42:57.810
These are the packet sizes that are
supported by 1394 at the various speeds.

00:42:57.840 --> 00:43:00.470
The top shows 100, 200, and 400.

00:43:00.500 --> 00:43:03.610
These are the sizes that
have been set for years.

00:43:03.620 --> 00:43:04.740
Nothing has changed there.

00:43:05.120 --> 00:43:08.360
As we move to the higher
speeds that 1394B provides,

00:43:08.360 --> 00:43:10.280
the packet sizes keep going up.

00:43:10.380 --> 00:43:12.680
For isochronous, they continue to double.

00:43:12.680 --> 00:43:15.700
For asynchronous, it's clamped at 4096.

00:43:15.700 --> 00:43:19.960
And this was done because
it's generally felt that with

00:43:19.960 --> 00:43:24.950
the optimizations in 1394B,
which eliminate, for example,

00:43:24.950 --> 00:43:28.100
all of the idle gaps on the bus,
it's no longer necessary to

00:43:28.100 --> 00:43:31.120
keep doubling the packet size
to keep the performance up.

00:43:31.120 --> 00:43:35.090
And it's inconvenient if
packets have to be retargeted.

00:43:35.130 --> 00:43:38.400
And they're, for example, 16 kilobytes.

00:43:38.400 --> 00:43:41.860
That's an awful lot of data to
throw away if just one bit went bad.

00:43:41.860 --> 00:43:45.670
So 4096 is the cap for
asynchronous packets,

00:43:45.720 --> 00:43:48.840
but that should in no way limit
the performance that you can get

00:43:48.840 --> 00:43:51.380
with asynchronous packets on 1394B.

00:43:54.070 --> 00:43:55.650
I talked about topology.

00:43:55.780 --> 00:43:58.400
This figure shows a self-ID packet.

00:43:58.460 --> 00:44:00.600
This is not actually unique to 1394B.

00:44:00.600 --> 00:44:03.240
They look like this in 1394A also.

00:44:03.370 --> 00:44:07.240
The self-ID packet is the very
most primitive level of information

00:44:07.240 --> 00:44:10.840
that we receive about each device,
telling us how it's hooked into the bus.

00:44:11.000 --> 00:44:16.160
For example, on the right-hand side, P0,
P1, P2 represent the first three ports

00:44:16.160 --> 00:44:20.540
on the device and whether or not they
are connected to some other device.

00:44:20.670 --> 00:44:23.440
By receiving all these
packets and doing some math,

00:44:23.440 --> 00:44:25.870
we can figure out who's plugged into who.

00:44:26.300 --> 00:46:05.800
[Transcript missing]

00:46:06.180 --> 00:46:07.560
There's actually two ways to do this.

00:46:07.560 --> 00:46:10.660
You can read the port registers or
you can simply start sending packets

00:46:10.660 --> 00:46:13.860
to the device at faster and faster
speeds and find out what works.

00:46:13.860 --> 00:46:15.530
Each one has its advantages.

00:46:15.530 --> 00:46:18.580
It's possible that you'll
see both in use on the bus.

00:46:18.580 --> 00:46:20.970
This is not something
you'll ever have to do.

00:46:20.980 --> 00:46:24.150
We will do this in the family,
but you may see this activity in Firebug

00:46:24.170 --> 00:46:26.160
and you may wonder what's going on.

00:46:28.880 --> 00:46:30.960
Okay, the next section we'll
go through very quickly.

00:46:30.960 --> 00:46:32.120
It's the how-tos.

00:46:32.120 --> 00:46:34.270
I've got a device.

00:46:34.270 --> 00:46:36.020
I want to write software.

00:46:36.020 --> 00:46:37.260
Where do I start?

00:46:43.700 --> 00:46:45.890
Storage, probably the most common.

00:46:46.010 --> 00:46:48.920
As I described earlier,
we have a built-in

00:46:48.920 --> 00:46:50.460
driver for mass storage.

00:46:50.510 --> 00:46:53.240
Most FireWire storage devices
don't need more software.

00:46:53.240 --> 00:46:57.480
As you move above FireWire,
the layer you hit first is called

00:46:57.680 --> 00:47:01.110
IOFireWireSerialBusProtocolTransport.

00:47:02.150 --> 00:47:04.690
Excuse me.

00:47:06.010 --> 00:47:08.890
and there's many layers above that.

00:47:08.970 --> 00:47:12.290
If necessary, if you're adding some
vendor unique feature,

00:47:12.290 --> 00:47:15.020
you could possibly subclass
that text or subclass other

00:47:15.120 --> 00:47:16.100
parts of the storage class.

00:47:16.100 --> 00:47:19.190
But in most cases,
you can just use our built-in driver.

00:47:19.190 --> 00:47:23.720
If you're doing custom apps,
maybe some kind of jukebox controller,

00:47:23.720 --> 00:47:26.180
SCSITaaskUserClient is
probably the way to go.

00:47:26.210 --> 00:47:29.670
Just two hours ago,
there was a session on the

00:47:29.680 --> 00:47:30.940
new disk recording APIs.

00:47:30.940 --> 00:47:33.080
If you're doing
CD-ROM burning or something,

00:47:33.080 --> 00:47:35.220
that's probably your easiest way to go.

00:47:35.580 --> 00:47:38.720
If all else fails,
you can use the SBP-2 APIs directly,

00:47:38.840 --> 00:47:42.420
preferably from the user client,
or if you're a bootable disk,

00:47:42.420 --> 00:47:45.040
maybe you might have
to go into the kernel.

00:47:45.040 --> 00:47:47.360
But we expect most people
won't have to do that.

00:47:50.250 --> 00:47:53.030
DV, the other really common device.

00:47:53.120 --> 00:47:54.640
Apple has a built-in DV driver.

00:47:54.640 --> 00:47:57.420
It sends and receives
DV in various formats,

00:47:57.420 --> 00:48:00.760
NTSC, PAL, standard definition,
extended play.

00:48:00.760 --> 00:48:02.400
It has device control.

00:48:02.400 --> 00:48:05.640
It's all available through
QuickTime or through the user clients.

00:48:06.950 --> 00:48:10.620
I mentioned on Monday that we had
open-sourced io-firewire-dv KEXT.

00:48:10.620 --> 00:48:14.420
That's actually obsolete because
we've moved it into user space,

00:48:14.420 --> 00:48:18.380
but now you can see how it all works,
and what's in user space, of course,

00:48:18.380 --> 00:48:19.640
is also similar.

00:48:19.640 --> 00:48:24.560
The name changes to
io-fwdv-components in Jaguar.

00:48:26.960 --> 00:48:29.290
The highest level API is the
QuickTime Sequence Grabber.

00:48:29.300 --> 00:48:32.360
If you're trying to import video,
that's what you should be using.

00:48:32.430 --> 00:48:36.630
But you could also talk to it through the
ABC UserClient to have a lower level API.

00:48:36.930 --> 00:48:44.880
Or if you had to,
the services are there in the kernel.

00:48:44.880 --> 00:48:44.880
You could subclass them there or you
could use the plain FireWire UserClient.

00:48:46.210 --> 00:48:50.840
For webcam-type devices, as I said,
we have a standard driver in Jaguar.

00:48:50.840 --> 00:48:54.960
If that's not to your liking,
you probably want to use the

00:48:54.960 --> 00:48:57.600
plain FireWire user client,
starting with the sample

00:48:57.600 --> 00:48:58.740
code that's in our SDK.

00:48:58.740 --> 00:49:01.010
But be advised,
it's not a good example of

00:49:01.010 --> 00:49:03.860
good QuickTime practice,
so study QuickTime.

00:49:06.620 --> 00:49:07.230
Scanners.

00:49:07.460 --> 00:49:10.550
Most FireWire scanners use
the SBP-2 architecture.

00:49:10.550 --> 00:49:14.440
You should probably consider using
Apple's image capture architecture.

00:49:14.440 --> 00:49:18.660
If you need to work at a lower level,
since your device is probably SAM,

00:49:18.660 --> 00:49:21.060
consider using SCSITaaskUserClient.

00:49:21.060 --> 00:49:23.590
Falling back,
you could use the SBP-2 user

00:49:23.590 --> 00:49:27.140
client or even the plain FireWire
user client if you had to.

00:49:27.140 --> 00:49:29.520
In no case should you go into the kernel.

00:49:29.520 --> 00:49:32.490
Scanners are not something
that we need to boot.

00:49:32.510 --> 00:49:34.750
They're not kernel resources,
so don't put scanner

00:49:34.750 --> 00:49:35.920
drivers in the kernel.

00:49:37.880 --> 00:49:38.190
Audio.

00:49:38.200 --> 00:49:41.520
As I said earlier,
we are working on a lot of audio areas.

00:49:41.520 --> 00:49:45.860
If you want to do software
for FireWire audio devices,

00:49:45.860 --> 00:49:49.010
please get in touch with us
because we would like to find out

00:49:49.010 --> 00:49:52.620
what you're doing and help mold
our services to meet your needs.

00:49:54.760 --> 00:49:58.650
Printers like scanners tend to be SAM,
so you can probably use

00:49:58.690 --> 00:50:02.890
SCSITaaskUserclient,
but there are some deviations out there.

00:50:02.930 --> 00:50:05.600
You could use the SBP-2 user client.

00:50:05.640 --> 00:50:11.000
If you want to use PPDT,
also known as IEEE 1394.3,

00:50:11.040 --> 00:50:13.380
you should be able to use
the SBP-2 user client,

00:50:13.410 --> 00:50:15.690
though you'll have to add
a layer on top of that.

00:50:15.780 --> 00:50:19.370
Please let us know if you're doing this,
because we aren't aware of any

00:50:19.420 --> 00:50:21.450
products that actually use this.

00:50:22.500 --> 00:50:24.500
You could use the plain
FireWire user client if you

00:50:24.500 --> 00:50:26.270
have some really custom printer.

00:50:26.270 --> 00:50:28.180
Like scanners,
these do not belong in the kernel.

00:50:28.180 --> 00:50:29.800
In fact,
I think it would be impossible because

00:50:29.890 --> 00:50:33.200
you'd have to hook into PrintCenter,
and that's an application-level service.

00:50:35.250 --> 00:50:35.860
Still cameras.

00:50:35.890 --> 00:50:42.080
There are cameras from Kodak,
Nikon that take still images

00:50:42.080 --> 00:50:43.580
but transfer over FireWire.

00:50:43.580 --> 00:50:47.700
On Monday I went at length as to why
they do this instead of using USB2.

00:50:47.700 --> 00:50:50.260
Here we'll talk about
driver support for them.

00:50:50.260 --> 00:50:52.990
We already support some in
iPhoto and image capture,

00:50:52.990 --> 00:50:55.080
so you may not have to write anything.

00:50:55.080 --> 00:50:56.550
We are working on more.

00:50:56.550 --> 00:50:59.120
So if you have a still camera
and want to write software,

00:50:59.120 --> 00:51:00.470
please get in touch with us.

00:51:00.480 --> 00:51:02.490
We might be able to
save you a lot of time.

00:51:03.120 --> 00:51:07.330
If you have an SBP-2 type camera, again,
SCSITaaskUserclient or perhaps

00:51:07.330 --> 00:51:09.310
the plain SBP-2 user client.

00:51:09.310 --> 00:51:12.200
If you're not using SBP-2,
you really should be.

00:51:12.200 --> 00:51:14.060
These cameras move a lot of data.

00:51:14.060 --> 00:51:16.600
That's why they're on FireWire, not USB.

00:51:16.600 --> 00:51:19.750
And SBP-2 is the good high-performance
protocol for doing that.

00:51:19.750 --> 00:51:21.280
That's what we support best.

00:51:21.280 --> 00:51:24.270
If you have a camcorder that
also doubles as a still camera,

00:51:24.330 --> 00:51:27.060
it probably wants to use
asynchronous connections.

00:51:27.060 --> 00:51:29.400
We're working on that,
but you could access it

00:51:29.400 --> 00:51:31.140
through the ABC user client.

00:51:31.140 --> 00:51:33.990
And if all else fails...
If all else fails,

00:51:34.100 --> 00:51:35.630
use the FireWire user client.

00:51:35.630 --> 00:51:37.320
Again, stay out of the kernel.

00:51:37.320 --> 00:51:39.830
Cameras are not any
kind of kernel resource.

00:51:40.950 --> 00:51:45.730
If you have a PCI card or a Cardbus card,
we hope developers will be making,

00:51:45.970 --> 00:51:51.200
for example, 1394B PCI cards for all of
our G4 towers out there.

00:51:51.310 --> 00:51:54.090
We support open HCI interfaces
if they comply with the spec,

00:51:54.190 --> 00:51:55.160
like I talked about earlier.

00:51:55.160 --> 00:51:57.820
If you have one that
doesn't and it's broken,

00:51:57.820 --> 00:51:59.710
well, you need to get one that works.

00:51:59.740 --> 00:52:01.120
It's that simple.

00:52:01.120 --> 00:52:05.040
If, on the other hand,
you are modifying OHCI silicon

00:52:05.040 --> 00:52:07.820
because you are really clever and
you're adding some special function,

00:52:07.820 --> 00:52:09.120
that may be okay.

00:52:09.120 --> 00:52:10.280
Talk with us.

00:52:10.280 --> 00:52:13.080
We'd like to know about that and
see what we can do to help you.

00:52:15.750 --> 00:52:16.770
Hubs.

00:52:16.770 --> 00:52:19.030
On FireWire,
there is no software for hubs.

00:52:19.030 --> 00:52:20.840
This is different from, say, USB.

00:52:20.840 --> 00:52:22.520
Hubs just work.

00:52:22.570 --> 00:52:23.570
They just repeat packets.

00:52:23.660 --> 00:52:26.050
So, if you want to make a hub,
just get a good hardware

00:52:26.050 --> 00:52:27.320
designer and off you go.

00:52:30.170 --> 00:52:30.790
Protocols.

00:52:30.880 --> 00:52:33.990
This is one of the
most interesting areas.

00:52:34.290 --> 00:52:39.140
Protocols are things like
TCP/IP or certain kinds of audio.

00:52:39.320 --> 00:52:42.340
This is where you want to send
and receive packets on Firewire,

00:52:42.340 --> 00:52:45.090
but not necessarily
just to a single device.

00:52:45.140 --> 00:52:48.340
You may be communicating with
lots of folks out on the bus.

00:52:48.520 --> 00:52:51.510
Rather than loading yourself
over and over again for every

00:52:51.510 --> 00:52:54.360
device that you want to talk to,
if you use the local node,

00:52:54.360 --> 00:52:57.160
you can talk to everyone
on the bus at once.

00:52:57.160 --> 00:52:59.240
The Firewire user client
can talk to the local node,

00:52:59.240 --> 00:53:01.580
or you can do it
directly from the kernel.

00:53:01.580 --> 00:53:03.580
If you're going down this path,
we'd like to know,

00:53:03.580 --> 00:53:05.580
because it's something we
haven't explored very much,

00:53:05.580 --> 00:53:08.200
and we'd like to help you do that.

00:53:09.720 --> 00:53:12.650
If you have some innovative
device that doesn't match

00:53:12.650 --> 00:53:15.540
anything I just talked about,
you've probably figured this out by now,

00:53:15.540 --> 00:53:19.310
use the highest level API that you can,
preferably one of the

00:53:19.310 --> 00:53:20.830
user clients or above.

00:53:20.860 --> 00:53:24.540
If all else fails,
use the FireWire user client.

00:53:25.020 --> 00:53:28.030
Anything you can do on FireWire,
you can do with the FireWire user client,

00:53:28.130 --> 00:53:29.200
although it may not be easy.

00:53:29.200 --> 00:53:32.690
And again, stay out of the kernel
if you possibly can.

00:53:35.180 --> 00:53:36.100
Okay, we're almost done.

00:53:36.100 --> 00:53:39.260
Last section is a recap
of developer resources.

00:53:39.260 --> 00:53:42.260
Apple, most of you already know this,
but we have a very

00:53:42.260 --> 00:53:43.380
strong developer program.

00:53:43.380 --> 00:53:44.940
There's lots of stuff available.

00:53:44.940 --> 00:53:49.460
Please visit developer.apple.com and take
a look if you're not familiar with it.

00:53:49.540 --> 00:53:52.770
Specific to FireWire,
we are having a plug fest tonight

00:53:52.830 --> 00:53:54.720
during the Apple Campus Bash.

00:53:54.720 --> 00:53:58.150
You can go into the quad and get
some beer and then bring your

00:53:58.150 --> 00:54:00.240
devices over to the garage room.

00:54:00.240 --> 00:54:01.620
It's better than it sounds.

00:54:01.620 --> 00:54:03.000
It's above the cafeteria.

00:54:03.080 --> 00:54:04.440
It's a fairly large room.

00:54:05.100 --> 00:54:06.680
Bring your FireWire devices.

00:54:06.740 --> 00:54:08.720
We will be plugging them in to Mac OS X.

00:54:08.720 --> 00:54:11.140
We'll try to get as many
connected as we can.

00:54:11.140 --> 00:54:13.480
You can meet with the FireWire engineers.

00:54:13.480 --> 00:54:14.550
The whole team will be there.

00:54:14.550 --> 00:54:16.500
You can meet with other
FireWire developers.

00:54:16.500 --> 00:54:17.520
It should be fun.

00:54:19.430 --> 00:54:21.670
The 1394 Trade Association has
plug-fests.

00:54:21.740 --> 00:54:23.920
I talked about these on Monday,
if you don't already know.

00:54:23.920 --> 00:54:25.100
These are different.

00:54:25.100 --> 00:54:27.760
This is two or three days
of really focused testing.

00:54:27.760 --> 00:54:30.190
You can get a ton of data,
and you meet a lot of people

00:54:30.190 --> 00:54:32.780
who don't come to Apple events,
so you can get a much more

00:54:32.790 --> 00:54:33.940
broad collection of data.

00:54:33.940 --> 00:54:35.840
Here's the schedule for
ones that are upcoming.

00:54:35.840 --> 00:54:37.160
We go to all of these.

00:54:37.160 --> 00:54:38.310
We get lots of great data.

00:54:38.310 --> 00:54:39.640
You should go to these, too.

00:54:39.640 --> 00:54:44.040
If you want this kind of testing,
but the schedule doesn't meet your

00:54:44.040 --> 00:54:48.440
needs or you need some more privacy,
consider contacting Quantum Parametrics.

00:54:48.440 --> 00:54:51.870
That's the company contracted by
the Trade Association to provide

00:54:51.870 --> 00:54:53.540
some of the tools being used.

00:54:56.170 --> 00:54:57.700
We hold FireWire kitchens.

00:54:57.700 --> 00:55:00.430
It's three or four days where we
get the engineering team together

00:55:00.820 --> 00:55:02.340
with a collection of developers.

00:55:02.340 --> 00:55:05.260
We have tutorials on the
latest things we've added,

00:55:05.370 --> 00:55:08.500
hands-on development and debugging,
and sometimes we give some

00:55:08.500 --> 00:55:10.420
related presentations,
whatever is timely.

00:55:10.420 --> 00:55:12.340
We do these two or three times a year.

00:55:12.340 --> 00:55:15.150
Often we do it when a
new SDK has come out.

00:55:15.230 --> 00:55:20.220
If you'd like to
participate in one of these,

00:55:20.220 --> 00:55:20.220
use the contact information at the end.

00:55:20.680 --> 00:55:21.320
Here's the roadmap.

00:55:21.450 --> 00:55:23.130
Those first two are in the past.

00:55:23.180 --> 00:55:24.880
There's the plugfest I told you about.

00:55:24.940 --> 00:55:26.970
And tomorrow morning at 9 a.m.

00:55:27.170 --> 00:55:29.820
we have a feedback form where
you can come tell us what we're

00:55:29.820 --> 00:55:34.150
doing that you like or don't like
or really say anything you like.

00:55:35.570 --> 00:55:38.740
If you'd like somebody to talk to,
FireWire at Apple.com is

00:55:38.740 --> 00:55:40.420
the primary mail address.

00:55:40.420 --> 00:55:43.090
That goes to Guillermo Ortiz,
who will be up here in just

00:55:43.090 --> 00:55:44.580
a moment to handle the Q&A.

00:55:44.580 --> 00:55:48.540
He is the technology manager for
FireWire in developer relations.

00:55:48.540 --> 00:55:50.730
We have a public mailing list.

00:55:50.800 --> 00:55:52.220
You're all welcome to subscribe.

00:55:52.220 --> 00:55:55.250
A lot of people outside the
Apple community subscribe to it.

00:55:55.290 --> 00:55:56.600
Visit that web page.

00:55:56.600 --> 00:55:59.930
Also, especially if you're
into SCSITaaskUserClient,

00:55:59.950 --> 00:56:01.750
there is a mass storage mailing list.

00:56:01.780 --> 00:56:04.230
It has a slightly different
subscription mechanism.

00:56:04.230 --> 00:56:05.300
You can find it here.

00:56:05.500 --> 00:56:06.580
Thank you.

00:56:08.470 --> 00:56:12.650
All of our SDKs are posted for free
public download on the web starting at

00:56:12.650 --> 00:56:15.300
this page which has other links as well.

00:56:15.300 --> 00:56:19.300
The new document I mentioned earlier,
Working with FireWire Device Interfaces,

00:56:19.300 --> 00:56:21.290
is available on the web.

00:56:21.430 --> 00:56:24.030
You may want to visit the
1394 Trade Association to

00:56:24.030 --> 00:56:25.300
learn about PlugFests.

00:56:25.300 --> 00:56:26.300
Their URL is here.

00:56:26.300 --> 00:56:30.300
Finally, you can go to the IEEE itself
if you need the standards.